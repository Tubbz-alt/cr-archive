<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/loopTransform.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;compiler/compileLog.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;opto/addnode.hpp&quot;
  29 #include &quot;opto/callnode.hpp&quot;
  30 #include &quot;opto/castnode.hpp&quot;
  31 #include &quot;opto/connode.hpp&quot;
  32 #include &quot;opto/convertnode.hpp&quot;
  33 #include &quot;opto/divnode.hpp&quot;
  34 #include &quot;opto/loopnode.hpp&quot;
  35 #include &quot;opto/mulnode.hpp&quot;
  36 #include &quot;opto/movenode.hpp&quot;
  37 #include &quot;opto/opaquenode.hpp&quot;
  38 #include &quot;opto/rootnode.hpp&quot;
  39 #include &quot;opto/runtime.hpp&quot;
  40 #include &quot;opto/subnode.hpp&quot;
  41 #include &quot;opto/superword.hpp&quot;
  42 #include &quot;opto/vectornode.hpp&quot;
  43 
  44 //------------------------------is_loop_exit-----------------------------------
  45 // Given an IfNode, return the loop-exiting projection or NULL if both
  46 // arms remain in the loop.
  47 Node *IdealLoopTree::is_loop_exit(Node *iff) const {
<a name="1" id="anc1"></a><span class="line-modified">  48   if (iff-&gt;outcnt() != 2) return NULL;  // Ignore partially dead tests</span>
  49   PhaseIdealLoop *phase = _phase;
  50   // Test is an IfNode, has 2 projections.  If BOTH are in the loop
  51   // we need loop unswitching instead of peeling.
<a name="2" id="anc2"></a><span class="line-modified">  52   if (!is_member(phase-&gt;get_loop(iff-&gt;raw_out(0))))</span>
  53     return iff-&gt;raw_out(0);
<a name="3" id="anc3"></a><span class="line-modified">  54   if (!is_member(phase-&gt;get_loop(iff-&gt;raw_out(1))))</span>
  55     return iff-&gt;raw_out(1);
  56   return NULL;
  57 }
  58 
  59 
  60 //=============================================================================
  61 
  62 
  63 //------------------------------record_for_igvn----------------------------
  64 // Put loop body on igvn work list
  65 void IdealLoopTree::record_for_igvn() {
<a name="4" id="anc4"></a><span class="line-modified">  66   for (uint i = 0; i &lt; _body.size(); i++) {</span>
  67     Node *n = _body.at(i);
  68     _phase-&gt;_igvn._worklist.push(n);
  69   }
  70   // put body of outer strip mined loop on igvn work list as well
  71   if (_head-&gt;is_CountedLoop() &amp;&amp; _head-&gt;as_Loop()-&gt;is_strip_mined()) {
  72     CountedLoopNode* l = _head-&gt;as_CountedLoop();
  73     Node* outer_loop = l-&gt;outer_loop();
  74     assert(outer_loop != NULL, &quot;missing piece of strip mined loop&quot;);
  75     _phase-&gt;_igvn._worklist.push(outer_loop);
  76     Node* outer_loop_tail = l-&gt;outer_loop_tail();
  77     assert(outer_loop_tail != NULL, &quot;missing piece of strip mined loop&quot;);
  78     _phase-&gt;_igvn._worklist.push(outer_loop_tail);
  79     Node* outer_loop_end = l-&gt;outer_loop_end();
  80     assert(outer_loop_end != NULL, &quot;missing piece of strip mined loop&quot;);
  81     _phase-&gt;_igvn._worklist.push(outer_loop_end);
  82     Node* outer_safepoint = l-&gt;outer_safepoint();
  83     assert(outer_safepoint != NULL, &quot;missing piece of strip mined loop&quot;);
  84     _phase-&gt;_igvn._worklist.push(outer_safepoint);
  85     Node* cle_out = _head-&gt;as_CountedLoop()-&gt;loopexit()-&gt;proj_out(false);
  86     assert(cle_out != NULL, &quot;missing piece of strip mined loop&quot;);
  87     _phase-&gt;_igvn._worklist.push(cle_out);
  88   }
  89 }
  90 
  91 //------------------------------compute_exact_trip_count-----------------------
  92 // Compute loop trip count if possible. Do not recalculate trip count for
  93 // split loops (pre-main-post) which have their limits and inits behind Opaque node.
  94 void IdealLoopTree::compute_trip_count(PhaseIdealLoop* phase) {
  95   if (!_head-&gt;as_Loop()-&gt;is_valid_counted_loop()) {
  96     return;
  97   }
  98   CountedLoopNode* cl = _head-&gt;as_CountedLoop();
  99   // Trip count may become nonexact for iteration split loops since
 100   // RCE modifies limits. Note, _trip_count value is not reset since
 101   // it is used to limit unrolling of main loop.
 102   cl-&gt;set_nonexact_trip_count();
 103 
 104   // Loop&#39;s test should be part of loop.
 105   if (!phase-&gt;is_member(this, phase-&gt;get_ctrl(cl-&gt;loopexit()-&gt;in(CountedLoopEndNode::TestValue))))
 106     return; // Infinite loop
 107 
 108 #ifdef ASSERT
 109   BoolTest::mask bt = cl-&gt;loopexit()-&gt;test_trip();
 110   assert(bt == BoolTest::lt || bt == BoolTest::gt ||
 111          bt == BoolTest::ne, &quot;canonical test is expected&quot;);
 112 #endif
 113 
 114   Node* init_n = cl-&gt;init_trip();
 115   Node* limit_n = cl-&gt;limit();
 116   if (init_n != NULL &amp;&amp; limit_n != NULL) {
 117     // Use longs to avoid integer overflow.
 118     int stride_con = cl-&gt;stride_con();
 119     const TypeInt* init_type = phase-&gt;_igvn.type(init_n)-&gt;is_int();
 120     const TypeInt* limit_type = phase-&gt;_igvn.type(limit_n)-&gt;is_int();
 121     jlong init_con = (stride_con &gt; 0) ? init_type-&gt;_lo : init_type-&gt;_hi;
 122     jlong limit_con = (stride_con &gt; 0) ? limit_type-&gt;_hi : limit_type-&gt;_lo;
 123     int stride_m = stride_con - (stride_con &gt; 0 ? 1 : -1);
 124     jlong trip_count = (limit_con - init_con + stride_m)/stride_con;
 125     if (trip_count &gt; 0 &amp;&amp; (julong)trip_count &lt; (julong)max_juint) {
 126       if (init_n-&gt;is_Con() &amp;&amp; limit_n-&gt;is_Con()) {
 127         // Set exact trip count.
 128         cl-&gt;set_exact_trip_count((uint)trip_count);
 129       } else if (cl-&gt;unrolled_count() == 1) {
 130         // Set maximum trip count before unrolling.
 131         cl-&gt;set_trip_count((uint)trip_count);
 132       }
 133     }
 134   }
 135 }
 136 
 137 //------------------------------compute_profile_trip_cnt----------------------------
 138 // Compute loop trip count from profile data as
 139 //    (backedge_count + loop_exit_count) / loop_exit_count
 140 
 141 float IdealLoopTree::compute_profile_trip_cnt_helper(Node* n) {
 142   if (n-&gt;is_If()) {
 143     IfNode *iff = n-&gt;as_If();
 144     if (iff-&gt;_fcnt != COUNT_UNKNOWN &amp;&amp; iff-&gt;_prob != PROB_UNKNOWN) {
 145       Node *exit = is_loop_exit(iff);
 146       if (exit) {
 147         float exit_prob = iff-&gt;_prob;
<a name="5" id="anc5"></a><span class="line-modified"> 148         if (exit-&gt;Opcode() == Op_IfFalse) {</span>
<span class="line-added"> 149           exit_prob = 1.0 - exit_prob;</span>
<span class="line-added"> 150         }</span>
 151         if (exit_prob &gt; PROB_MIN) {
 152           float exit_cnt = iff-&gt;_fcnt * exit_prob;
 153           return exit_cnt;
 154         }
 155       }
 156     }
 157   }
 158   if (n-&gt;is_Jump()) {
 159     JumpNode *jmp = n-&gt;as_Jump();
 160     if (jmp-&gt;_fcnt != COUNT_UNKNOWN) {
 161       float* probs = jmp-&gt;_probs;
 162       float exit_prob = 0;
 163       PhaseIdealLoop *phase = _phase;
 164       for (DUIterator_Fast imax, i = jmp-&gt;fast_outs(imax); i &lt; imax; i++) {
 165         JumpProjNode* u = jmp-&gt;fast_out(i)-&gt;as_JumpProj();
 166         if (!is_member(_phase-&gt;get_loop(u))) {
 167           exit_prob += probs[u-&gt;_con];
 168         }
 169       }
 170       return exit_prob * jmp-&gt;_fcnt;
 171     }
 172   }
 173   return 0;
 174 }
 175 
 176 void IdealLoopTree::compute_profile_trip_cnt(PhaseIdealLoop *phase) {
 177   if (!_head-&gt;is_Loop()) {
 178     return;
 179   }
 180   LoopNode* head = _head-&gt;as_Loop();
 181   if (head-&gt;profile_trip_cnt() != COUNT_UNKNOWN) {
 182     return; // Already computed
 183   }
 184   float trip_cnt = (float)max_jint; // default is big
 185 
 186   Node* back = head-&gt;in(LoopNode::LoopBackControl);
 187   while (back != head) {
 188     if ((back-&gt;Opcode() == Op_IfTrue || back-&gt;Opcode() == Op_IfFalse) &amp;&amp;
 189         back-&gt;in(0) &amp;&amp;
 190         back-&gt;in(0)-&gt;is_If() &amp;&amp;
 191         back-&gt;in(0)-&gt;as_If()-&gt;_fcnt != COUNT_UNKNOWN &amp;&amp;
 192         back-&gt;in(0)-&gt;as_If()-&gt;_prob != PROB_UNKNOWN &amp;&amp;
 193         (back-&gt;Opcode() == Op_IfTrue ? 1-back-&gt;in(0)-&gt;as_If()-&gt;_prob : back-&gt;in(0)-&gt;as_If()-&gt;_prob) &gt; PROB_MIN) {
 194       break;
 195     }
 196     back = phase-&gt;idom(back);
 197   }
 198   if (back != head) {
 199     assert((back-&gt;Opcode() == Op_IfTrue || back-&gt;Opcode() == Op_IfFalse) &amp;&amp;
 200            back-&gt;in(0), &quot;if-projection exists&quot;);
 201     IfNode* back_if = back-&gt;in(0)-&gt;as_If();
 202     float loop_back_cnt = back_if-&gt;_fcnt * (back-&gt;Opcode() == Op_IfTrue ? back_if-&gt;_prob : (1 - back_if-&gt;_prob));
 203 
 204     // Now compute a loop exit count
 205     float loop_exit_cnt = 0.0f;
 206     if (_child == NULL) {
<a name="6" id="anc6"></a><span class="line-modified"> 207       for (uint i = 0; i &lt; _body.size(); i++) {</span>
 208         Node *n = _body[i];
 209         loop_exit_cnt += compute_profile_trip_cnt_helper(n);
 210       }
 211     } else {
 212       ResourceMark rm;
 213       Unique_Node_List wq;
 214       wq.push(back);
 215       for (uint i = 0; i &lt; wq.size(); i++) {
 216         Node *n = wq.at(i);
 217         assert(n-&gt;is_CFG(), &quot;only control nodes&quot;);
 218         if (n != head) {
 219           if (n-&gt;is_Region()) {
 220             for (uint j = 1; j &lt; n-&gt;req(); j++) {
 221               wq.push(n-&gt;in(j));
 222             }
 223           } else {
 224             loop_exit_cnt += compute_profile_trip_cnt_helper(n);
 225             wq.push(n-&gt;in(0));
 226           }
 227         }
 228       }
 229 
 230     }
 231     if (loop_exit_cnt &gt; 0.0f) {
 232       trip_cnt = (loop_back_cnt + loop_exit_cnt) / loop_exit_cnt;
 233     } else {
 234       // No exit count so use
 235       trip_cnt = loop_back_cnt;
 236     }
 237   } else {
 238     head-&gt;mark_profile_trip_failed();
 239   }
 240 #ifndef PRODUCT
 241   if (TraceProfileTripCount) {
 242     tty-&gt;print_cr(&quot;compute_profile_trip_cnt  lp: %d cnt: %f\n&quot;, head-&gt;_idx, trip_cnt);
 243   }
 244 #endif
 245   head-&gt;set_profile_trip_cnt(trip_cnt);
 246 }
 247 
 248 //---------------------is_invariant_addition-----------------------------
 249 // Return nonzero index of invariant operand for an Add or Sub
 250 // of (nonconstant) invariant and variant values. Helper for reassociate_invariants.
 251 int IdealLoopTree::is_invariant_addition(Node* n, PhaseIdealLoop *phase) {
 252   int op = n-&gt;Opcode();
 253   if (op == Op_AddI || op == Op_SubI) {
 254     bool in1_invar = this-&gt;is_invariant(n-&gt;in(1));
 255     bool in2_invar = this-&gt;is_invariant(n-&gt;in(2));
 256     if (in1_invar &amp;&amp; !in2_invar) return 1;
 257     if (!in1_invar &amp;&amp; in2_invar) return 2;
 258   }
 259   return 0;
 260 }
 261 
 262 //---------------------reassociate_add_sub-----------------------------
 263 // Reassociate invariant add and subtract expressions:
 264 //
 265 // inv1 + (x + inv2)  =&gt;  ( inv1 + inv2) + x
 266 // (x + inv2) + inv1  =&gt;  ( inv1 + inv2) + x
 267 // inv1 + (x - inv2)  =&gt;  ( inv1 - inv2) + x
 268 // inv1 - (inv2 - x)  =&gt;  ( inv1 - inv2) + x
 269 // (x + inv2) - inv1  =&gt;  (-inv1 + inv2) + x
 270 // (x - inv2) + inv1  =&gt;  ( inv1 - inv2) + x
 271 // (x - inv2) - inv1  =&gt;  (-inv1 - inv2) + x
 272 // inv1 + (inv2 - x)  =&gt;  ( inv1 + inv2) - x
 273 // inv1 - (x - inv2)  =&gt;  ( inv1 + inv2) - x
 274 // (inv2 - x) + inv1  =&gt;  ( inv1 + inv2) - x
 275 // (inv2 - x) - inv1  =&gt;  (-inv1 + inv2) - x
 276 // inv1 - (x + inv2)  =&gt;  ( inv1 - inv2) - x
 277 //
 278 Node* IdealLoopTree::reassociate_add_sub(Node* n1, PhaseIdealLoop *phase) {
 279   if ((!n1-&gt;is_Add() &amp;&amp; !n1-&gt;is_Sub()) || n1-&gt;outcnt() == 0) return NULL;
 280   if (is_invariant(n1)) return NULL;
 281   int inv1_idx = is_invariant_addition(n1, phase);
 282   if (!inv1_idx) return NULL;
 283   // Don&#39;t mess with add of constant (igvn moves them to expression tree root.)
 284   if (n1-&gt;is_Add() &amp;&amp; n1-&gt;in(2)-&gt;is_Con()) return NULL;
 285   Node* inv1 = n1-&gt;in(inv1_idx);
 286   Node* n2 = n1-&gt;in(3 - inv1_idx);
 287   int inv2_idx = is_invariant_addition(n2, phase);
 288   if (!inv2_idx) return NULL;
<a name="7" id="anc7"></a><span class="line-added"> 289 </span>
<span class="line-added"> 290   if (!phase-&gt;may_require_nodes(10, 10)) return NULL;</span>
<span class="line-added"> 291 </span>
 292   Node* x    = n2-&gt;in(3 - inv2_idx);
 293   Node* inv2 = n2-&gt;in(inv2_idx);
 294 
 295   bool neg_x    = n2-&gt;is_Sub() &amp;&amp; inv2_idx == 1;
 296   bool neg_inv2 = n2-&gt;is_Sub() &amp;&amp; inv2_idx == 2;
 297   bool neg_inv1 = n1-&gt;is_Sub() &amp;&amp; inv1_idx == 2;
 298   if (n1-&gt;is_Sub() &amp;&amp; inv1_idx == 1) {
 299     neg_x    = !neg_x;
 300     neg_inv2 = !neg_inv2;
 301   }
 302   Node* inv1_c = phase-&gt;get_ctrl(inv1);
 303   Node* inv2_c = phase-&gt;get_ctrl(inv2);
 304   Node* n_inv1;
 305   if (neg_inv1) {
 306     Node *zero = phase-&gt;_igvn.intcon(0);
 307     phase-&gt;set_ctrl(zero, phase-&gt;C-&gt;root());
 308     n_inv1 = new SubINode(zero, inv1);
 309     phase-&gt;register_new_node(n_inv1, inv1_c);
 310   } else {
 311     n_inv1 = inv1;
 312   }
 313   Node* inv;
 314   if (neg_inv2) {
 315     inv = new SubINode(n_inv1, inv2);
 316   } else {
 317     inv = new AddINode(n_inv1, inv2);
 318   }
 319   phase-&gt;register_new_node(inv, phase-&gt;get_early_ctrl(inv));
 320 
 321   Node* addx;
 322   if (neg_x) {
 323     addx = new SubINode(inv, x);
 324   } else {
 325     addx = new AddINode(x, inv);
 326   }
 327   phase-&gt;register_new_node(addx, phase-&gt;get_ctrl(x));
 328   phase-&gt;_igvn.replace_node(n1, addx);
 329   assert(phase-&gt;get_loop(phase-&gt;get_ctrl(n1)) == this, &quot;&quot;);
 330   _body.yank(n1);
 331   return addx;
 332 }
 333 
 334 //---------------------reassociate_invariants-----------------------------
 335 // Reassociate invariant expressions:
 336 void IdealLoopTree::reassociate_invariants(PhaseIdealLoop *phase) {
 337   for (int i = _body.size() - 1; i &gt;= 0; i--) {
 338     Node *n = _body.at(i);
 339     for (int j = 0; j &lt; 5; j++) {
 340       Node* nn = reassociate_add_sub(n, phase);
 341       if (nn == NULL) break;
 342       n = nn; // again
<a name="8" id="anc8"></a><span class="line-modified"> 343     }</span>
 344   }
 345 }
 346 
 347 //------------------------------policy_peeling---------------------------------
<a name="9" id="anc9"></a><span class="line-modified"> 348 // Return TRUE if the loop should be peeled, otherwise return FALSE. Peeling</span>
<span class="line-modified"> 349 // is applicable if we can make a loop-invariant test (usually a null-check)</span>
<span class="line-modified"> 350 // execute before we enter the loop. When TRUE, the estimated node budget is</span>
<span class="line-modified"> 351 // also requested.</span>
<span class="line-modified"> 352 bool IdealLoopTree::policy_peeling(PhaseIdealLoop *phase) {</span>
<span class="line-modified"> 353   uint estimate = estimate_peeling(phase);</span>
<span class="line-modified"> 354 </span>
<span class="line-modified"> 355   return estimate == 0 ? false : phase-&gt;may_require_nodes(estimate);</span>
<span class="line-modified"> 356 }</span>
<span class="line-added"> 357 </span>
<span class="line-added"> 358 // Perform actual policy and size estimate for the loop peeling transform, and</span>
<span class="line-added"> 359 // return the estimated loop size if peeling is applicable, otherwise return</span>
<span class="line-added"> 360 // zero. No node budget is allocated.</span>
<span class="line-added"> 361 uint IdealLoopTree::estimate_peeling(PhaseIdealLoop *phase) {</span>
<span class="line-added"> 362 </span>
<span class="line-added"> 363   // If nodes are depleted, some transform has miscalculated its needs.</span>
<span class="line-added"> 364   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);</span>
<span class="line-added"> 365 </span>
<span class="line-added"> 366   // Peeling does loop cloning which can result in O(N^2) node construction.</span>
<span class="line-added"> 367   if (_body.size() &gt; 255) {</span>
<span class="line-added"> 368     return 0;   // Suppress too large body size.</span>
 369   }
<a name="10" id="anc10"></a><span class="line-added"> 370   // Optimistic estimate that approximates loop body complexity via data and</span>
<span class="line-added"> 371   // control flow fan-out (instead of using the more pessimistic: BodySize^2).</span>
<span class="line-added"> 372   uint estimate = est_loop_clone_sz(2);</span>
 373 
<a name="11" id="anc11"></a><span class="line-modified"> 374   if (phase-&gt;exceeding_node_budget(estimate)) {</span>
<span class="line-modified"> 375     return 0;   // Too large to safely clone.</span>
<span class="line-added"> 376   }</span>
 377 
<a name="12" id="anc12"></a><span class="line-modified"> 378   // Check for vectorized loops, any peeling done was already applied.</span>
<span class="line-modified"> 379   if (_head-&gt;is_CountedLoop()) {</span>
<span class="line-added"> 380     CountedLoopNode* cl = _head-&gt;as_CountedLoop();</span>
<span class="line-added"> 381     if (cl-&gt;is_unroll_only() || cl-&gt;trip_count() == 1) {</span>
<span class="line-added"> 382       return 0;</span>
<span class="line-added"> 383     }</span>
 384   }
 385 
<a name="13" id="anc13"></a><span class="line-modified"> 386   Node* test = tail();</span>
<span class="line-modified"> 387 </span>
<span class="line-added"> 388   while (test != _head) {   // Scan till run off top of loop</span>
<span class="line-added"> 389     if (test-&gt;is_If()) {    // Test?</span>
 390       Node *ctrl = phase-&gt;get_ctrl(test-&gt;in(1));
<a name="14" id="anc14"></a><span class="line-modified"> 391       if (ctrl-&gt;is_top()) {</span>
<span class="line-modified"> 392         return 0;           // Found dead test on live IF?  No peeling!</span>
<span class="line-modified"> 393       }</span>
<span class="line-modified"> 394       // Standard IF only has one input value to check for loop invariance.</span>
<span class="line-added"> 395       assert(test-&gt;Opcode() == Op_If ||</span>
<span class="line-added"> 396              test-&gt;Opcode() == Op_CountedLoopEnd ||</span>
<span class="line-added"> 397              test-&gt;Opcode() == Op_RangeCheck,</span>
<span class="line-added"> 398              &quot;Check this code when new subtype is added&quot;);</span>
 399       // Condition is not a member of this loop?
<a name="15" id="anc15"></a><span class="line-modified"> 400       if (!is_member(phase-&gt;get_loop(ctrl)) &amp;&amp; is_loop_exit(test)) {</span>
<span class="line-modified"> 401         return estimate;    // Found reason to peel!</span>
<span class="line-modified"> 402       }</span>
 403     }
<a name="16" id="anc16"></a><span class="line-modified"> 404     // Walk up dominators to loop _head looking for test which is executed on</span>
<span class="line-modified"> 405     // every path through the loop.</span>
 406     test = phase-&gt;idom(test);
 407   }
<a name="17" id="anc17"></a><span class="line-modified"> 408   return 0;</span>
 409 }
 410 
 411 //------------------------------peeled_dom_test_elim---------------------------
 412 // If we got the effect of peeling, either by actually peeling or by making
 413 // a pre-loop which must execute at least once, we can remove all
 414 // loop-invariant dominated tests in the main body.
<a name="18" id="anc18"></a><span class="line-modified"> 415 void PhaseIdealLoop::peeled_dom_test_elim(IdealLoopTree *loop, Node_List &amp;old_new) {</span>
 416   bool progress = true;
<a name="19" id="anc19"></a><span class="line-modified"> 417   while (progress) {</span>
 418     progress = false;           // Reset for next iteration
 419     Node *prev = loop-&gt;_head-&gt;in(LoopNode::LoopBackControl);//loop-&gt;tail();
 420     Node *test = prev-&gt;in(0);
<a name="20" id="anc20"></a><span class="line-modified"> 421     while (test != loop-&gt;_head) { // Scan till run off top of loop</span>
 422 
 423       int p_op = prev-&gt;Opcode();
<a name="21" id="anc21"></a><span class="line-modified"> 424       if ((p_op == Op_IfFalse || p_op == Op_IfTrue) &amp;&amp;</span>
 425           test-&gt;is_If() &amp;&amp;      // Test?
 426           !test-&gt;in(1)-&gt;is_Con() &amp;&amp; // And not already obvious?
 427           // Condition is not a member of this loop?
 428           !loop-&gt;is_member(get_loop(get_ctrl(test-&gt;in(1))))){
 429         // Walk loop body looking for instances of this test
<a name="22" id="anc22"></a><span class="line-modified"> 430         for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {</span>
 431           Node *n = loop-&gt;_body.at(i);
<a name="23" id="anc23"></a><span class="line-modified"> 432           if (n-&gt;is_If() &amp;&amp; n-&gt;in(1) == test-&gt;in(1) /*&amp;&amp; n != loop-&gt;tail()-&gt;in(0)*/) {</span>
 433             // IfNode was dominated by version in peeled loop body
 434             progress = true;
<a name="24" id="anc24"></a><span class="line-modified"> 435             dominated_by(old_new[prev-&gt;_idx], n);</span>
 436           }
 437         }
 438       }
 439       prev = test;
 440       test = idom(test);
 441     } // End of scan tests in loop
 442 
<a name="25" id="anc25"></a><span class="line-modified"> 443   } // End of while (progress)</span>
 444 }
 445 
 446 //------------------------------do_peeling-------------------------------------
 447 // Peel the first iteration of the given loop.
 448 // Step 1: Clone the loop body.  The clone becomes the peeled iteration.
 449 //         The pre-loop illegally has 2 control users (old &amp; new loops).
 450 // Step 2: Make the old-loop fall-in edges point to the peeled iteration.
 451 //         Do this by making the old-loop fall-in edges act as if they came
 452 //         around the loopback from the prior iteration (follow the old-loop
 453 //         backedges) and then map to the new peeled iteration.  This leaves
 454 //         the pre-loop with only 1 user (the new peeled iteration), but the
 455 //         peeled-loop backedge has 2 users.
 456 // Step 3: Cut the backedge on the clone (so its not a loop) and remove the
 457 //         extra backedge user.
 458 //
 459 //                   orig
 460 //
 461 //                  stmt1
 462 //                    |
 463 //                    v
 464 //              loop predicate
 465 //                    |
 466 //                    v
 467 //                   loop&lt;----+
 468 //                     |      |
 469 //                   stmt2    |
 470 //                     |      |
 471 //                     v      |
 472 //                    if      ^
 473 //                   / \      |
 474 //                  /   \     |
 475 //                 v     v    |
 476 //               false true   |
 477 //               /       \    |
 478 //              /         ----+
 479 //             |
 480 //             v
 481 //           exit
 482 //
 483 //
 484 //            after clone loop
 485 //
 486 //                   stmt1
 487 //                     |
 488 //                     v
 489 //               loop predicate
 490 //                 /       \
 491 //        clone   /         \   orig
 492 //               /           \
 493 //              /             \
 494 //             v               v
 495 //   +----&gt;loop clone          loop&lt;----+
 496 //   |      |                    |      |
 497 //   |    stmt2 clone          stmt2    |
 498 //   |      |                    |      |
 499 //   |      v                    v      |
 500 //   ^      if clone            If      ^
 501 //   |      / \                / \      |
 502 //   |     /   \              /   \     |
 503 //   |    v     v            v     v    |
 504 //   |    true  false      false true   |
 505 //   |    /         \      /       \    |
 506 //   +----           \    /         ----+
 507 //                    \  /
 508 //                    1v v2
 509 //                  region
 510 //                     |
 511 //                     v
 512 //                   exit
 513 //
 514 //
 515 //         after peel and predicate move
 516 //
 517 //                   stmt1
 518 //                    /
 519 //                   /
 520 //        clone     /            orig
 521 //                 /
 522 //                /              +----------+
 523 //               /               |          |
 524 //              /          loop predicate   |
 525 //             /                 |          |
 526 //            v                  v          |
 527 //   TOP--&gt;loop clone          loop&lt;----+   |
 528 //          |                    |      |   |
 529 //        stmt2 clone          stmt2    |   |
 530 //          |                    |      |   ^
 531 //          v                    v      |   |
 532 //          if clone            If      ^   |
 533 //          / \                / \      |   |
 534 //         /   \              /   \     |   |
 535 //        v     v            v     v    |   |
 536 //      true   false      false  true   |   |
 537 //        |         \      /       \    |   |
 538 //        |          \    /         ----+   ^
 539 //        |           \  /                  |
 540 //        |           1v v2                 |
 541 //        v         region                  |
 542 //        |            |                    |
 543 //        |            v                    |
 544 //        |          exit                   |
 545 //        |                                 |
 546 //        +---------------&gt;-----------------+
 547 //
 548 //
 549 //              final graph
 550 //
 551 //                  stmt1
 552 //                    |
 553 //                    v
 554 //                  stmt2 clone
 555 //                    |
 556 //                    v
 557 //                   if clone
 558 //                  / |
 559 //                 /  |
 560 //                v   v
 561 //            false  true
 562 //             |      |
 563 //             |      v
 564 //             | loop predicate
 565 //             |      |
 566 //             |      v
 567 //             |     loop&lt;----+
 568 //             |      |       |
 569 //             |    stmt2     |
 570 //             |      |       |
 571 //             |      v       |
 572 //             v      if      ^
 573 //             |     /  \     |
 574 //             |    /    \    |
 575 //             |   v     v    |
 576 //             | false  true  |
 577 //             |  |        \  |
 578 //             v  v         --+
 579 //            region
 580 //              |
 581 //              v
 582 //             exit
 583 //
<a name="26" id="anc26"></a><span class="line-modified"> 584 void PhaseIdealLoop::do_peeling(IdealLoopTree *loop, Node_List &amp;old_new) {</span>
 585 
 586   C-&gt;set_major_progress();
 587   // Peeling a &#39;main&#39; loop in a pre/main/post situation obfuscates the
 588   // &#39;pre&#39; loop from the main and the &#39;pre&#39; can no longer have its
 589   // iterations adjusted.  Therefore, we need to declare this loop as
 590   // no longer a &#39;main&#39; loop; it will need new pre and post loops before
 591   // we can do further RCE.
 592 #ifndef PRODUCT
 593   if (TraceLoopOpts) {
 594     tty-&gt;print(&quot;Peel         &quot;);
 595     loop-&gt;dump_head();
 596   }
 597 #endif
 598   LoopNode* head = loop-&gt;_head-&gt;as_Loop();
 599   bool counted_loop = head-&gt;is_CountedLoop();
 600   if (counted_loop) {
 601     CountedLoopNode *cl = head-&gt;as_CountedLoop();
 602     assert(cl-&gt;trip_count() &gt; 0, &quot;peeling a fully unrolled loop&quot;);
 603     cl-&gt;set_trip_count(cl-&gt;trip_count() - 1);
 604     if (cl-&gt;is_main_loop()) {
 605       cl-&gt;set_normal_loop();
 606 #ifndef PRODUCT
 607       if (PrintOpto &amp;&amp; VerifyLoopOptimizations) {
 608         tty-&gt;print(&quot;Peeling a &#39;main&#39; loop; resetting to &#39;normal&#39; &quot;);
 609         loop-&gt;dump_head();
 610       }
 611 #endif
 612     }
 613   }
 614   Node* entry = head-&gt;in(LoopNode::EntryControl);
 615 
 616   // Step 1: Clone the loop body.  The clone becomes the peeled iteration.
 617   //         The pre-loop illegally has 2 control users (old &amp; new loops).
 618   clone_loop(loop, old_new, dom_depth(head-&gt;skip_strip_mined()), ControlAroundStripMined);
 619 
 620   // Step 2: Make the old-loop fall-in edges point to the peeled iteration.
 621   //         Do this by making the old-loop fall-in edges act as if they came
 622   //         around the loopback from the prior iteration (follow the old-loop
 623   //         backedges) and then map to the new peeled iteration.  This leaves
 624   //         the pre-loop with only 1 user (the new peeled iteration), but the
 625   //         peeled-loop backedge has 2 users.
 626   Node* new_entry = old_new[head-&gt;in(LoopNode::LoopBackControl)-&gt;_idx];
 627   _igvn.hash_delete(head-&gt;skip_strip_mined());
 628   head-&gt;skip_strip_mined()-&gt;set_req(LoopNode::EntryControl, new_entry);
 629   for (DUIterator_Fast jmax, j = head-&gt;fast_outs(jmax); j &lt; jmax; j++) {
 630     Node* old = head-&gt;fast_out(j);
 631     if (old-&gt;in(0) == loop-&gt;_head &amp;&amp; old-&gt;req() == 3 &amp;&amp; old-&gt;is_Phi()) {
 632       Node* new_exit_value = old_new[old-&gt;in(LoopNode::LoopBackControl)-&gt;_idx];
<a name="27" id="anc27"></a><span class="line-modified"> 633       if (!new_exit_value)     // Backedge value is ALSO loop invariant?</span>
 634         // Then loop body backedge value remains the same.
 635         new_exit_value = old-&gt;in(LoopNode::LoopBackControl);
 636       _igvn.hash_delete(old);
 637       old-&gt;set_req(LoopNode::EntryControl, new_exit_value);
 638     }
 639   }
 640 
 641 
 642   // Step 3: Cut the backedge on the clone (so its not a loop) and remove the
 643   //         extra backedge user.
 644   Node* new_head = old_new[head-&gt;_idx];
 645   _igvn.hash_delete(new_head);
 646   new_head-&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
 647   for (DUIterator_Fast j2max, j2 = new_head-&gt;fast_outs(j2max); j2 &lt; j2max; j2++) {
 648     Node* use = new_head-&gt;fast_out(j2);
 649     if (use-&gt;in(0) == new_head &amp;&amp; use-&gt;req() == 3 &amp;&amp; use-&gt;is_Phi()) {
 650       _igvn.hash_delete(use);
 651       use-&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
 652     }
 653   }
 654 
<a name="28" id="anc28"></a>
 655   // Step 4: Correct dom-depth info.  Set to loop-head depth.
<a name="29" id="anc29"></a><span class="line-modified"> 656 </span>
<span class="line-modified"> 657   int dd = dom_depth(head-&gt;skip_strip_mined());</span>
<span class="line-added"> 658   set_idom(head-&gt;skip_strip_mined(), head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl), dd);</span>
 659   for (uint j3 = 0; j3 &lt; loop-&gt;_body.size(); j3++) {
 660     Node *old = loop-&gt;_body.at(j3);
 661     Node *nnn = old_new[old-&gt;_idx];
<a name="30" id="anc30"></a><span class="line-modified"> 662     if (!has_ctrl(nnn)) {</span>
 663       set_idom(nnn, idom(nnn), dd-1);
<a name="31" id="anc31"></a><span class="line-added"> 664     }</span>
 665   }
 666 
 667   // Now force out all loop-invariant dominating tests.  The optimizer
 668   // finds some, but we _know_ they are all useless.
 669   peeled_dom_test_elim(loop,old_new);
 670 
 671   loop-&gt;record_for_igvn();
 672 }
 673 
<a name="32" id="anc32"></a>

 674 //------------------------------policy_maximally_unroll------------------------
<a name="33" id="anc33"></a><span class="line-modified"> 675 // Calculate the exact  loop trip-count and return TRUE if loop can be fully,</span>
<span class="line-modified"> 676 // i.e. maximally, unrolled, otherwise return FALSE. When TRUE, the estimated</span>
<span class="line-modified"> 677 // node budget is also requested.</span>
<span class="line-modified"> 678 bool IdealLoopTree::policy_maximally_unroll(PhaseIdealLoop* phase) const {</span>
<span class="line-added"> 679   CountedLoopNode* cl = _head-&gt;as_CountedLoop();</span>
 680   assert(cl-&gt;is_normal_loop(), &quot;&quot;);
<a name="34" id="anc34"></a><span class="line-modified"> 681   if (!cl-&gt;is_valid_counted_loop()) {</span>
<span class="line-modified"> 682     return false;   // Malformed counted loop.</span>
<span class="line-modified"> 683   }</span>
 684   if (!cl-&gt;has_exact_trip_count()) {
<a name="35" id="anc35"></a><span class="line-modified"> 685     return false;   // Trip count is not exact.</span>

 686   }
 687 
 688   uint trip_count = cl-&gt;trip_count();
 689   // Note, max_juint is used to indicate unknown trip count.
 690   assert(trip_count &gt; 1, &quot;one iteration loop should be optimized out already&quot;);
<a name="36" id="anc36"></a><span class="line-modified"> 691   assert(trip_count &lt; max_juint, &quot;exact trip_count should be less than max_juint.&quot;);</span>
 692 
<a name="37" id="anc37"></a><span class="line-modified"> 693   // If nodes are depleted, some transform has miscalculated its needs.</span>
<span class="line-modified"> 694   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);</span>
<span class="line-modified"> 695 </span>
<span class="line-modified"> 696   // Allow the unrolled body to get larger than the standard loop size limit.</span>
 697   uint unroll_limit = (uint)LoopUnrollLimit * 4;
<a name="38" id="anc38"></a><span class="line-modified"> 698   assert((intx)unroll_limit == LoopUnrollLimit * 4, &quot;LoopUnrollLimit must fit in 32bits&quot;);</span>
<span class="line-modified"> 699   if (trip_count &gt; unroll_limit || _body.size() &gt; unroll_limit) {</span>
 700     return false;
 701   }
 702 
<a name="39" id="anc39"></a><span class="line-modified"> 703   uint new_body_size = est_loop_unroll_sz(trip_count);</span>




 704 
<a name="40" id="anc40"></a><span class="line-modified"> 705   if (new_body_size == UINT_MAX) { // Check for bad estimate (overflow).</span>




 706     return false;
<a name="41" id="anc41"></a><span class="line-modified"> 707   }</span>
<span class="line-modified"> 708 </span>
<span class="line-modified"> 709   // Fully unroll a loop with few iterations, regardless of other conditions,</span>
<span class="line-added"> 710   // since the following (general) loop optimizations will split such loop in</span>
<span class="line-added"> 711   // any case (into pre-main-post).</span>
<span class="line-added"> 712   if (trip_count &lt;= 3) {</span>
<span class="line-added"> 713     return phase-&gt;may_require_nodes(new_body_size);</span>
<span class="line-added"> 714   }</span>
<span class="line-added"> 715 </span>
<span class="line-added"> 716   // Reject if unrolling will result in too much node construction.</span>
<span class="line-added"> 717   if (new_body_size &gt; unroll_limit || phase-&gt;exceeding_node_budget(new_body_size)) {</span>
 718     return false;
 719   }
 720 
 721   // Do not unroll a loop with String intrinsics code.
 722   // String intrinsics are large and have loops.
 723   for (uint k = 0; k &lt; _body.size(); k++) {
 724     Node* n = _body.at(k);
 725     switch (n-&gt;Opcode()) {
 726       case Op_StrComp:
 727       case Op_StrEquals:
 728       case Op_StrIndexOf:
 729       case Op_StrIndexOfChar:
 730       case Op_EncodeISOArray:
 731       case Op_AryEq:
 732       case Op_HasNegatives: {
 733         return false;
 734       }
 735 #if INCLUDE_RTM_OPT
 736       case Op_FastLock:
 737       case Op_FastUnlock: {
 738         // Don&#39;t unroll RTM locking code because it is large.
 739         if (UseRTMLocking) {
 740           return false;
 741         }
 742       }
 743 #endif
 744     } // switch
 745   }
 746 
<a name="42" id="anc42"></a><span class="line-modified"> 747   return phase-&gt;may_require_nodes(new_body_size);</span>
 748 }
 749 
 750 
 751 //------------------------------policy_unroll----------------------------------
<a name="43" id="anc43"></a><span class="line-modified"> 752 // Return TRUE or FALSE if the loop should be unrolled or not. Apply unroll if</span>
<span class="line-modified"> 753 // the loop is  a counted loop and  the loop body is small  enough. When TRUE,</span>
<span class="line-added"> 754 // the estimated node budget is also requested.</span>
 755 bool IdealLoopTree::policy_unroll(PhaseIdealLoop *phase) {
 756 
 757   CountedLoopNode *cl = _head-&gt;as_CountedLoop();
 758   assert(cl-&gt;is_normal_loop() || cl-&gt;is_main_loop(), &quot;&quot;);
 759 
<a name="44" id="anc44"></a><span class="line-modified"> 760   if (!cl-&gt;is_valid_counted_loop()) {</span>
 761     return false; // Malformed counted loop
<a name="45" id="anc45"></a><span class="line-added"> 762   }</span>
<span class="line-added"> 763 </span>
<span class="line-added"> 764   // If nodes are depleted, some transform has miscalculated its needs.</span>
<span class="line-added"> 765   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);</span>
 766 
 767   // Protect against over-unrolling.
 768   // After split at least one iteration will be executed in pre-loop.
<a name="46" id="anc46"></a><span class="line-modified"> 769   if (cl-&gt;trip_count() &lt;= (cl-&gt;is_normal_loop() ? 2u : 1u)) {</span>
<span class="line-modified"> 770     return false;</span>
<span class="line-modified"> 771   }</span>
<span class="line-added"> 772   _local_loop_unroll_limit  = LoopUnrollLimit;</span>
 773   _local_loop_unroll_factor = 4;
<a name="47" id="anc47"></a><span class="line-modified"> 774   int future_unroll_cnt = cl-&gt;unrolled_count() * 2;</span>
 775   if (!cl-&gt;is_vectorized_loop()) {
<a name="48" id="anc48"></a><span class="line-modified"> 776     if (future_unroll_cnt &gt; LoopMaxUnroll) return false;</span>
 777   } else {
 778     // obey user constraints on vector mapped loops with additional unrolling applied
 779     int unroll_constraint = (cl-&gt;slp_max_unroll()) ? cl-&gt;slp_max_unroll() : 1;
<a name="49" id="anc49"></a><span class="line-modified"> 780     if ((future_unroll_cnt / unroll_constraint) &gt; LoopMaxUnroll) return false;</span>
 781   }
 782 
 783   // Check for initial stride being a small enough constant
<a name="50" id="anc50"></a><span class="line-modified"> 784   if (abs(cl-&gt;stride_con()) &gt; (1&lt;&lt;2)*future_unroll_cnt) return false;</span>
 785 
 786   // Don&#39;t unroll if the next round of unrolling would push us
 787   // over the expected trip count of the loop.  One is subtracted
 788   // from the expected trip count because the pre-loop normally
 789   // executes 1 iteration.
 790   if (UnrollLimitForProfileCheck &gt; 0 &amp;&amp;
 791       cl-&gt;profile_trip_cnt() != COUNT_UNKNOWN &amp;&amp;
<a name="51" id="anc51"></a><span class="line-modified"> 792       future_unroll_cnt        &gt; UnrollLimitForProfileCheck &amp;&amp;</span>
<span class="line-modified"> 793       (float)future_unroll_cnt &gt; cl-&gt;profile_trip_cnt() - 1.0) {</span>
 794     return false;
 795   }
 796 
 797   // When unroll count is greater than LoopUnrollMin, don&#39;t unroll if:
 798   //   the residual iterations are more than 10% of the trip count
 799   //   and rounds of &quot;unroll,optimize&quot; are not making significant progress
 800   //   Progress defined as current size less than 20% larger than previous size.
 801   if (UseSuperWord &amp;&amp; cl-&gt;node_count_before_unroll() &gt; 0 &amp;&amp;
<a name="52" id="anc52"></a><span class="line-modified"> 802       future_unroll_cnt &gt; LoopUnrollMin &amp;&amp;</span>
<span class="line-modified"> 803       (future_unroll_cnt - 1) * (100 / LoopPercentProfileLimit) &gt; cl-&gt;profile_trip_cnt() &amp;&amp;</span>
 804       1.2 * cl-&gt;node_count_before_unroll() &lt; (double)_body.size()) {
 805     return false;
 806   }
 807 
 808   Node *init_n = cl-&gt;init_trip();
 809   Node *limit_n = cl-&gt;limit();
 810   int stride_con = cl-&gt;stride_con();
 811   if (limit_n == NULL) return false; // We will dereference it below.
 812 
 813   // Non-constant bounds.
 814   // Protect against over-unrolling when init or/and limit are not constant
 815   // (so that trip_count&#39;s init value is maxint) but iv range is known.
 816   if (init_n == NULL || !init_n-&gt;is_Con() || !limit_n-&gt;is_Con()) {
 817     Node* phi = cl-&gt;phi();
 818     if (phi != NULL) {
 819       assert(phi-&gt;is_Phi() &amp;&amp; phi-&gt;in(0) == _head, &quot;Counted loop should have iv phi.&quot;);
 820       const TypeInt* iv_type = phase-&gt;_igvn.type(phi)-&gt;is_int();
 821       int next_stride = stride_con * 2; // stride after this unroll
 822       if (next_stride &gt; 0) {
 823         if (iv_type-&gt;_lo + next_stride &lt;= iv_type-&gt;_lo || // overflow
 824             iv_type-&gt;_lo + next_stride &gt;  iv_type-&gt;_hi) {
 825           return false;  // over-unrolling
 826         }
 827       } else if (next_stride &lt; 0) {
 828         if (iv_type-&gt;_hi + next_stride &gt;= iv_type-&gt;_hi || // overflow
 829             iv_type-&gt;_hi + next_stride &lt;  iv_type-&gt;_lo) {
 830           return false;  // over-unrolling
 831         }
 832       }
 833     }
 834   }
 835 
 836   // After unroll limit will be adjusted: new_limit = limit-stride.
 837   // Bailout if adjustment overflow.
 838   const TypeInt* limit_type = phase-&gt;_igvn.type(limit_n)-&gt;is_int();
 839   if ((stride_con &gt; 0 &amp;&amp; ((limit_type-&gt;_hi - stride_con) &gt;= limit_type-&gt;_hi)) ||
 840       (stride_con &lt; 0 &amp;&amp; ((limit_type-&gt;_lo - stride_con) &lt;= limit_type-&gt;_lo)))
 841     return false;  // overflow
 842 
 843   // Adjust body_size to determine if we unroll or not
 844   uint body_size = _body.size();
 845   // Key test to unroll loop in CRC32 java code
 846   int xors_in_loop = 0;
 847   // Also count ModL, DivL and MulL which expand mightly
 848   for (uint k = 0; k &lt; _body.size(); k++) {
 849     Node* n = _body.at(k);
 850     switch (n-&gt;Opcode()) {
 851       case Op_XorI: xors_in_loop++; break; // CRC32 java code
 852       case Op_ModL: body_size += 30; break;
 853       case Op_DivL: body_size += 30; break;
 854       case Op_MulL: body_size += 10; break;
 855       case Op_StrComp:
 856       case Op_StrEquals:
 857       case Op_StrIndexOf:
 858       case Op_StrIndexOfChar:
 859       case Op_EncodeISOArray:
 860       case Op_AryEq:
 861       case Op_HasNegatives: {
 862         // Do not unroll a loop with String intrinsics code.
 863         // String intrinsics are large and have loops.
 864         return false;
 865       }
 866 #if INCLUDE_RTM_OPT
 867       case Op_FastLock:
 868       case Op_FastUnlock: {
 869         // Don&#39;t unroll RTM locking code because it is large.
 870         if (UseRTMLocking) {
 871           return false;
 872         }
 873       }
 874 #endif
 875     } // switch
 876   }
 877 
 878   if (UseSuperWord) {
 879     if (!cl-&gt;is_reduction_loop()) {
 880       phase-&gt;mark_reductions(this);
 881     }
 882 
 883     // Only attempt slp analysis when user controls do not prohibit it
 884     if (LoopMaxUnroll &gt; _local_loop_unroll_factor) {
 885       // Once policy_slp_analysis succeeds, mark the loop with the
 886       // maximal unroll factor so that we minimize analysis passes
<a name="53" id="anc53"></a><span class="line-modified"> 887       if (future_unroll_cnt &gt;= _local_loop_unroll_factor) {</span>
<span class="line-modified"> 888         policy_unroll_slp_analysis(cl, phase, future_unroll_cnt);</span>
 889       }
 890     }
 891   }
 892 
 893   int slp_max_unroll_factor = cl-&gt;slp_max_unroll();
 894   if ((LoopMaxUnroll &lt; slp_max_unroll_factor) &amp;&amp; FLAG_IS_DEFAULT(LoopMaxUnroll) &amp;&amp; UseSubwordForMaxVector) {
 895     LoopMaxUnroll = slp_max_unroll_factor;
 896   }
<a name="54" id="anc54"></a><span class="line-added"> 897 </span>
<span class="line-added"> 898   uint estimate = est_loop_clone_sz(2);</span>
<span class="line-added"> 899 </span>
 900   if (cl-&gt;has_passed_slp()) {
<a name="55" id="anc55"></a><span class="line-modified"> 901     if (slp_max_unroll_factor &gt;= future_unroll_cnt) {</span>
<span class="line-modified"> 902       return phase-&gt;may_require_nodes(estimate);</span>
<span class="line-modified"> 903     }</span>
<span class="line-added"> 904     return false; // Loop too big.</span>
 905   }
 906 
 907   // Check for being too big
 908   if (body_size &gt; (uint)_local_loop_unroll_limit) {
<a name="56" id="anc56"></a><span class="line-modified"> 909     if ((cl-&gt;is_subword_loop() || xors_in_loop &gt;= 4) &amp;&amp; body_size &lt; 4u * LoopUnrollLimit) {</span>
<span class="line-modified"> 910       return phase-&gt;may_require_nodes(estimate);</span>
 911     }
<a name="57" id="anc57"></a><span class="line-modified"> 912     return false; // Loop too big.</span>

 913   }
 914 
<a name="58" id="anc58"></a><span class="line-modified"> 915   if (cl-&gt;is_unroll_only()) {</span>
 916     if (TraceSuperWordLoopUnrollAnalysis) {
<a name="59" id="anc59"></a><span class="line-modified"> 917       tty-&gt;print_cr(&quot;policy_unroll passed vector loop(vlen=%d, factor=%d)\n&quot;,</span>
<span class="line-added"> 918                     slp_max_unroll_factor, future_unroll_cnt);</span>
 919     }
 920   }
 921 
 922   // Unroll once!  (Each trip will soon do double iterations)
<a name="60" id="anc60"></a><span class="line-modified"> 923   return phase-&gt;may_require_nodes(estimate);</span>
 924 }
 925 
<a name="61" id="anc61"></a><span class="line-modified"> 926 void IdealLoopTree::policy_unroll_slp_analysis(CountedLoopNode *cl, PhaseIdealLoop *phase, int future_unroll_cnt) {</span>
<span class="line-added"> 927 </span>
<span class="line-added"> 928   // If nodes are depleted, some transform has miscalculated its needs.</span>
<span class="line-added"> 929   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);</span>
<span class="line-added"> 930 </span>
 931   // Enable this functionality target by target as needed
 932   if (SuperWordLoopUnrollAnalysis) {
 933     if (!cl-&gt;was_slp_analyzed()) {
 934       SuperWord sw(phase);
 935       sw.transform_loop(this, false);
 936 
 937       // If the loop is slp canonical analyze it
 938       if (sw.early_return() == false) {
 939         sw.unrolling_analysis(_local_loop_unroll_factor);
 940       }
 941     }
 942 
 943     if (cl-&gt;has_passed_slp()) {
 944       int slp_max_unroll_factor = cl-&gt;slp_max_unroll();
<a name="62" id="anc62"></a><span class="line-modified"> 945       if (slp_max_unroll_factor &gt;= future_unroll_cnt) {</span>
 946         int new_limit = cl-&gt;node_count_before_unroll() * slp_max_unroll_factor;
 947         if (new_limit &gt; LoopUnrollLimit) {
 948           if (TraceSuperWordLoopUnrollAnalysis) {
 949             tty-&gt;print_cr(&quot;slp analysis unroll=%d, default limit=%d\n&quot;, new_limit, _local_loop_unroll_limit);
 950           }
 951           _local_loop_unroll_limit = new_limit;
 952         }
 953       }
 954     }
 955   }
 956 }
 957 
 958 //------------------------------policy_align-----------------------------------
 959 // Return TRUE or FALSE if the loop should be cache-line aligned.  Gather the
 960 // expression that does the alignment.  Note that only one array base can be
 961 // aligned in a loop (unless the VM guarantees mutual alignment).  Note that
 962 // if we vectorize short memory ops into longer memory ops, we may want to
 963 // increase alignment.
<a name="63" id="anc63"></a><span class="line-modified"> 964 bool IdealLoopTree::policy_align(PhaseIdealLoop *phase) const {</span>
 965   return false;
 966 }
 967 
 968 //------------------------------policy_range_check-----------------------------
<a name="64" id="anc64"></a><span class="line-modified"> 969 // Return TRUE or FALSE if the loop should be range-check-eliminated or not.</span>
<span class="line-modified"> 970 // When TRUE, the estimated node budget is also requested.</span>
<span class="line-modified"> 971 //</span>
<span class="line-added"> 972 // We will actually perform iteration-splitting, a more powerful form of RCE.</span>
<span class="line-added"> 973 bool IdealLoopTree::policy_range_check(PhaseIdealLoop *phase) const {</span>
 974   if (!RangeCheckElimination) return false;
 975 
<a name="65" id="anc65"></a><span class="line-added"> 976   // If nodes are depleted, some transform has miscalculated its needs.</span>
<span class="line-added"> 977   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);</span>
<span class="line-added"> 978 </span>
 979   CountedLoopNode *cl = _head-&gt;as_CountedLoop();
<a name="66" id="anc66"></a><span class="line-modified"> 980   // If we unrolled  with no intention of doing RCE and we  later changed our</span>
<span class="line-modified"> 981   // minds, we got no pre-loop.  Either we need to make a new pre-loop, or we</span>
<span class="line-modified"> 982   // have to disallow RCE.</span>
 983   if (cl-&gt;is_main_no_pre_loop()) return false; // Disallowed for now.
 984   Node *trip_counter = cl-&gt;phi();
 985 
 986   // check for vectorized loops, some opts are no longer needed
<a name="67" id="anc67"></a><span class="line-modified"> 987   if (cl-&gt;is_unroll_only()) return false;</span>
 988 
 989   // Check loop body for tests of trip-counter plus loop-invariant vs
 990   // loop-invariant.
 991   for (uint i = 0; i &lt; _body.size(); i++) {
 992     Node *iff = _body[i];
 993     if (iff-&gt;Opcode() == Op_If ||
 994         iff-&gt;Opcode() == Op_RangeCheck) { // Test?
 995 
 996       // Comparing trip+off vs limit
 997       Node *bol = iff-&gt;in(1);
<a name="68" id="anc68"></a><span class="line-modified"> 998       if (bol-&gt;req() != 2) {</span>
<span class="line-added"> 999         continue; // dead constant test</span>
<span class="line-added">1000       }</span>
1001       if (!bol-&gt;is_Bool()) {
1002         assert(bol-&gt;Opcode() == Op_Conv2B, &quot;predicate check only&quot;);
1003         continue;
1004       }
<a name="69" id="anc69"></a><span class="line-modified">1005       if (bol-&gt;as_Bool()-&gt;_test._test == BoolTest::ne) {</span>
1006         continue; // not RC
<a name="70" id="anc70"></a><span class="line-modified">1007       }</span>
1008       Node *cmp = bol-&gt;in(1);
1009       Node *rc_exp = cmp-&gt;in(1);
1010       Node *limit = cmp-&gt;in(2);
1011 
1012       Node *limit_c = phase-&gt;get_ctrl(limit);
<a name="71" id="anc71"></a><span class="line-modified">1013       if (limit_c == phase-&gt;C-&gt;top()) {</span>
1014         return false;           // Found dead test on live IF?  No RCE!
<a name="72" id="anc72"></a><span class="line-modified">1015       }</span>
<span class="line-added">1016       if (is_member(phase-&gt;get_loop(limit_c))) {</span>
1017         // Compare might have operands swapped; commute them
1018         rc_exp = cmp-&gt;in(2);
1019         limit  = cmp-&gt;in(1);
1020         limit_c = phase-&gt;get_ctrl(limit);
<a name="73" id="anc73"></a><span class="line-modified">1021         if (is_member(phase-&gt;get_loop(limit_c))) {</span>
1022           continue;             // Both inputs are loop varying; cannot RCE
<a name="74" id="anc74"></a><span class="line-added">1023         }</span>
1024       }
1025 
1026       if (!phase-&gt;is_scaled_iv_plus_offset(rc_exp, trip_counter, NULL, NULL)) {
1027         continue;
1028       }
<a name="75" id="anc75"></a><span class="line-modified">1029       // Found a test like &#39;trip+off vs limit&#39;. Test is an IfNode, has two (2)</span>
<span class="line-modified">1030       // projections. If BOTH are in the loop we need loop unswitching instead</span>
<span class="line-modified">1031       // of iteration splitting.</span>
<span class="line-modified">1032       if (is_loop_exit(iff)) {</span>
<span class="line-modified">1033         // Found valid reason to split iterations (if there is room).</span>
<span class="line-added">1034         // NOTE: Usually a gross overestimate.</span>
<span class="line-added">1035         return phase-&gt;may_require_nodes(est_loop_clone_sz(2));</span>
<span class="line-added">1036       }</span>
1037     } // End of is IF
1038   }
1039 
1040   return false;
1041 }
1042 
1043 //------------------------------policy_peel_only-------------------------------
1044 // Return TRUE or FALSE if the loop should NEVER be RCE&#39;d or aligned.  Useful
1045 // for unrolling loops with NO array accesses.
<a name="76" id="anc76"></a><span class="line-modified">1046 bool IdealLoopTree::policy_peel_only(PhaseIdealLoop *phase) const {</span>
<span class="line-added">1047 </span>
<span class="line-added">1048   // If nodes are depleted, some transform has miscalculated its needs.</span>
<span class="line-added">1049   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);</span>
<span class="line-added">1050 </span>
1051   // check for vectorized loops, any peeling done was already applied
<a name="77" id="anc77"></a><span class="line-modified">1052   if (_head-&gt;is_CountedLoop() &amp;&amp; _head-&gt;as_CountedLoop()-&gt;is_unroll_only()) {</span>
<span class="line-added">1053     return false;</span>
<span class="line-added">1054   }</span>
1055 
<a name="78" id="anc78"></a><span class="line-modified">1056   for (uint i = 0; i &lt; _body.size(); i++) {</span>
<span class="line-modified">1057     if (_body[i]-&gt;is_Mem()) {</span>
1058       return false;
<a name="79" id="anc79"></a><span class="line-modified">1059     }</span>
<span class="line-added">1060   }</span>
1061   // No memory accesses at all!
1062   return true;
1063 }
1064 
1065 //------------------------------clone_up_backedge_goo--------------------------
1066 // If Node n lives in the back_ctrl block and cannot float, we clone a private
1067 // version of n in preheader_ctrl block and return that, otherwise return n.
<a name="80" id="anc80"></a><span class="line-modified">1068 Node *PhaseIdealLoop::clone_up_backedge_goo(Node *back_ctrl, Node *preheader_ctrl, Node *n, VectorSet &amp;visited, Node_Stack &amp;clones) {</span>
<span class="line-modified">1069   if (get_ctrl(n) != back_ctrl) return n;</span>
1070 
1071   // Only visit once
1072   if (visited.test_set(n-&gt;_idx)) {
1073     Node *x = clones.find(n-&gt;_idx);
<a name="81" id="anc81"></a><span class="line-modified">1074     return (x != NULL) ? x : n;</span>


1075   }
1076 
1077   Node *x = NULL;               // If required, a clone of &#39;n&#39;
1078   // Check for &#39;n&#39; being pinned in the backedge.
<a name="82" id="anc82"></a><span class="line-modified">1079   if (n-&gt;in(0) &amp;&amp; n-&gt;in(0) == back_ctrl) {</span>
1080     assert(clones.find(n-&gt;_idx) == NULL, &quot;dead loop&quot;);
1081     x = n-&gt;clone();             // Clone a copy of &#39;n&#39; to preheader
1082     clones.push(x, n-&gt;_idx);
<a name="83" id="anc83"></a><span class="line-modified">1083     x-&gt;set_req(0, preheader_ctrl); // Fix x&#39;s control input to preheader</span>
1084   }
1085 
1086   // Recursive fixup any other input edges into x.
1087   // If there are no changes we can just return &#39;n&#39;, otherwise
1088   // we need to clone a private copy and change it.
<a name="84" id="anc84"></a><span class="line-modified">1089   for (uint i = 1; i &lt; n-&gt;req(); i++) {</span>
<span class="line-modified">1090     Node *g = clone_up_backedge_goo(back_ctrl, preheader_ctrl, n-&gt;in(i), visited, clones);</span>
<span class="line-modified">1091     if (g != n-&gt;in(i)) {</span>
<span class="line-modified">1092       if (!x) {</span>
1093         assert(clones.find(n-&gt;_idx) == NULL, &quot;dead loop&quot;);
1094         x = n-&gt;clone();
1095         clones.push(x, n-&gt;_idx);
1096       }
1097       x-&gt;set_req(i, g);
1098     }
1099   }
<a name="85" id="anc85"></a><span class="line-modified">1100   if (x) {                     // x can legally float to pre-header location</span>
<span class="line-modified">1101     register_new_node(x, preheader_ctrl);</span>
1102     return x;
1103   } else {                      // raise n to cover LCA of uses
<a name="86" id="anc86"></a><span class="line-modified">1104     set_ctrl(n, find_non_split_ctrl(back_ctrl-&gt;in(0)));</span>
1105   }
1106   return n;
1107 }
1108 
1109 Node* PhaseIdealLoop::cast_incr_before_loop(Node* incr, Node* ctrl, Node* loop) {
1110   Node* castii = new CastIINode(incr, TypeInt::INT, true);
1111   castii-&gt;set_req(0, ctrl);
1112   register_new_node(castii, ctrl);
1113   for (DUIterator_Fast imax, i = incr-&gt;fast_outs(imax); i &lt; imax; i++) {
1114     Node* n = incr-&gt;fast_out(i);
1115     if (n-&gt;is_Phi() &amp;&amp; n-&gt;in(0) == loop) {
1116       int nrep = n-&gt;replace_edge(incr, castii);
1117       return castii;
1118     }
1119   }
1120   return NULL;
1121 }
1122 
1123 // Make a copy of the skeleton range check predicates before the main
1124 // loop and set the initial value of loop as input. After unrolling,
1125 // the range of values for the induction variable in the main loop can
1126 // fall outside the allowed range of values by the array access (main
1127 // loop is never executed). When that happens, range check
1128 // CastII/ConvI2L nodes cause some data paths to die. For consistency,
1129 // the control paths must die too but the range checks were removed by
1130 // predication. The range checks that we add here guarantee that they do.
1131 void PhaseIdealLoop::duplicate_predicates_helper(Node* predicate, Node* start, Node* end,
1132                                                  IdealLoopTree* outer_loop, LoopNode* outer_main_head,
1133                                                  uint dd_main_head) {
1134   if (predicate != NULL) {
1135     IfNode* iff = predicate-&gt;in(0)-&gt;as_If();
1136     ProjNode* uncommon_proj = iff-&gt;proj_out(1 - predicate-&gt;as_Proj()-&gt;_con);
1137     Node* rgn = uncommon_proj-&gt;unique_ctrl_out();
1138     assert(rgn-&gt;is_Region() || rgn-&gt;is_Call(), &quot;must be a region or call uct&quot;);
1139     assert(iff-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_Opaque1, &quot;unexpected predicate shape&quot;);
1140     predicate = iff-&gt;in(0);
1141     Node* current_proj = outer_main_head-&gt;in(LoopNode::EntryControl);
1142     Node* prev_proj = current_proj;
1143     while (predicate != NULL &amp;&amp; predicate-&gt;is_Proj() &amp;&amp; predicate-&gt;in(0)-&gt;is_If()) {
1144       iff = predicate-&gt;in(0)-&gt;as_If();
1145       uncommon_proj = iff-&gt;proj_out(1 - predicate-&gt;as_Proj()-&gt;_con);
1146       if (uncommon_proj-&gt;unique_ctrl_out() != rgn)
1147         break;
1148       if (iff-&gt;in(1)-&gt;Opcode() == Op_Opaque4) {
1149         assert(skeleton_predicate_has_opaque(iff), &quot;unexpected&quot;);
1150         // Clone the predicate twice and initialize one with the initial
1151         // value of the loop induction variable. Leave the other predicate
1152         // to be initialized when increasing the stride during loop unrolling.
1153         prev_proj = clone_skeleton_predicate(iff, start, predicate, uncommon_proj, current_proj, outer_loop, prev_proj);
1154         assert(skeleton_predicate_has_opaque(prev_proj-&gt;in(0)-&gt;as_If()) == (start-&gt;Opcode() == Op_Opaque1), &quot;&quot;);
1155         prev_proj = clone_skeleton_predicate(iff, end, predicate, uncommon_proj, current_proj, outer_loop, prev_proj);
1156         assert(skeleton_predicate_has_opaque(prev_proj-&gt;in(0)-&gt;as_If()) == (end-&gt;Opcode() == Op_Opaque1), &quot;&quot;);
1157         // Remove the skeleton predicate from the pre-loop
1158         _igvn.replace_input_of(iff, 1, _igvn.intcon(1));
1159       }
1160       predicate = predicate-&gt;in(0)-&gt;in(0);
1161     }
1162     _igvn.replace_input_of(outer_main_head, LoopNode::EntryControl, prev_proj);
1163     set_idom(outer_main_head, prev_proj, dd_main_head);
1164   }
1165 }
1166 
1167 static bool skeleton_follow_inputs(Node* n, int op) {
1168   return (n-&gt;is_Bool() ||
1169           n-&gt;is_Cmp() ||
1170           op == Op_AndL ||
1171           op == Op_OrL ||
1172           op == Op_RShiftL ||
1173           op == Op_LShiftL ||
1174           op == Op_AddL ||
1175           op == Op_AddI ||
1176           op == Op_MulL ||
1177           op == Op_MulI ||
1178           op == Op_SubL ||
1179           op == Op_SubI ||
1180           op == Op_ConvI2L);
1181 }
1182 
1183 bool PhaseIdealLoop::skeleton_predicate_has_opaque(IfNode* iff) {
1184   ResourceMark rm;
1185   Unique_Node_List wq;
1186   wq.push(iff-&gt;in(1)-&gt;in(1));
1187   for (uint i = 0; i &lt; wq.size(); i++) {
1188     Node* n = wq.at(i);
1189     int op = n-&gt;Opcode();
1190     if (skeleton_follow_inputs(n, op)) {
1191       for (uint j = 1; j &lt; n-&gt;req(); j++) {
1192         Node* m = n-&gt;in(j);
1193         if (m != NULL) {
1194           wq.push(m);
1195         }
1196       }
1197       continue;
1198     }
1199     if (op == Op_Opaque1) {
1200       return true;
1201     }
1202   }
1203   return false;
1204 }
1205 
1206 Node* PhaseIdealLoop::clone_skeleton_predicate(Node* iff, Node* value, Node* predicate, Node* uncommon_proj,
1207                                                Node* current_proj, IdealLoopTree* outer_loop, Node* prev_proj) {
1208   Node_Stack to_clone(2);
1209   to_clone.push(iff-&gt;in(1), 1);
1210   uint current = C-&gt;unique();
1211   Node* result = NULL;
1212   // Look for the opaque node to replace with the new value
1213   // and clone everything in between. We keep the Opaque4 node
1214   // so the duplicated predicates are eliminated once loop
1215   // opts are over: they are here only to keep the IR graph
1216   // consistent.
1217   do {
1218     Node* n = to_clone.node();
1219     uint i = to_clone.index();
1220     Node* m = n-&gt;in(i);
1221     int op = m-&gt;Opcode();
1222     if (skeleton_follow_inputs(m, op)) {
1223         to_clone.push(m, 1);
1224         continue;
1225     }
1226     if (op == Op_Opaque1) {
1227       if (n-&gt;_idx &lt; current) {
1228         n = n-&gt;clone();
1229       }
1230       n-&gt;set_req(i, value);
1231       register_new_node(n, current_proj);
1232       to_clone.set_node(n);
1233     }
1234     for (;;) {
1235       Node* cur = to_clone.node();
1236       uint j = to_clone.index();
1237       if (j+1 &lt; cur-&gt;req()) {
1238         to_clone.set_index(j+1);
1239         break;
1240       }
1241       to_clone.pop();
1242       if (to_clone.size() == 0) {
1243         result = cur;
1244         break;
1245       }
1246       Node* next = to_clone.node();
1247       j = to_clone.index();
1248       if (next-&gt;in(j) != cur) {
1249         assert(cur-&gt;_idx &gt;= current || next-&gt;in(j)-&gt;Opcode() == Op_Opaque1, &quot;new node or Opaque1 being replaced&quot;);
1250         if (next-&gt;_idx &lt; current) {
1251           next = next-&gt;clone();
1252           register_new_node(next, current_proj);
1253           to_clone.set_node(next);
1254         }
1255         next-&gt;set_req(j, cur);
1256       }
1257     }
1258   } while (result == NULL);
1259   assert(result-&gt;_idx &gt;= current, &quot;new node expected&quot;);
1260 
1261   Node* proj = predicate-&gt;clone();
1262   Node* other_proj = uncommon_proj-&gt;clone();
1263   Node* new_iff = iff-&gt;clone();
1264   new_iff-&gt;set_req(1, result);
1265   proj-&gt;set_req(0, new_iff);
1266   other_proj-&gt;set_req(0, new_iff);
1267   Node *frame = new ParmNode(C-&gt;start(), TypeFunc::FramePtr);
1268   register_new_node(frame, C-&gt;start());
1269   // It&#39;s impossible for the predicate to fail at runtime. Use an Halt node.
<a name="87" id="anc87"></a><span class="line-modified">1270   Node* halt = new HaltNode(other_proj, frame, &quot;duplicated predicate failed which is impossible&quot;);</span>
1271   C-&gt;root()-&gt;add_req(halt);
1272   new_iff-&gt;set_req(0, prev_proj);
1273 
1274   register_control(new_iff, outer_loop-&gt;_parent, prev_proj);
1275   register_control(proj, outer_loop-&gt;_parent, new_iff);
1276   register_control(other_proj, _ltree_root, new_iff);
1277   register_control(halt, _ltree_root, other_proj);
1278   return proj;
1279 }
1280 
1281 void PhaseIdealLoop::duplicate_predicates(CountedLoopNode* pre_head, Node* start, Node* end,
1282                                           IdealLoopTree* outer_loop, LoopNode* outer_main_head,
1283                                           uint dd_main_head) {
1284   if (UseLoopPredicate) {
1285     Node* entry = pre_head-&gt;in(LoopNode::EntryControl);
1286     Node* predicate = NULL;
1287     predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
1288     if (predicate != NULL) {
1289       entry = skip_loop_predicates(entry);
1290     }
1291     Node* profile_predicate = NULL;
1292     if (UseProfiledLoopPredicate) {
1293       profile_predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);
1294       if (profile_predicate != NULL) {
1295         entry = skip_loop_predicates(entry);
1296       }
1297     }
1298     predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
1299     duplicate_predicates_helper(predicate, start, end, outer_loop, outer_main_head, dd_main_head);
1300     duplicate_predicates_helper(profile_predicate, start, end, outer_loop, outer_main_head, dd_main_head);
1301   }
1302 }
1303 
1304 //------------------------------insert_pre_post_loops--------------------------
1305 // Insert pre and post loops.  If peel_only is set, the pre-loop can not have
1306 // more iterations added.  It acts as a &#39;peel&#39; only, no lower-bound RCE, no
1307 // alignment.  Useful to unroll loops that do no array accesses.
<a name="88" id="anc88"></a><span class="line-modified">1308 void PhaseIdealLoop::insert_pre_post_loops(IdealLoopTree *loop, Node_List &amp;old_new, bool peel_only) {</span>
1309 
1310 #ifndef PRODUCT
1311   if (TraceLoopOpts) {
1312     if (peel_only)
1313       tty-&gt;print(&quot;PeelMainPost &quot;);
1314     else
1315       tty-&gt;print(&quot;PreMainPost  &quot;);
1316     loop-&gt;dump_head();
1317   }
1318 #endif
1319   C-&gt;set_major_progress();
1320 
1321   // Find common pieces of the loop being guarded with pre &amp; post loops
1322   CountedLoopNode *main_head = loop-&gt;_head-&gt;as_CountedLoop();
<a name="89" id="anc89"></a><span class="line-modified">1323   assert(main_head-&gt;is_normal_loop(), &quot;&quot;);</span>
1324   CountedLoopEndNode *main_end = main_head-&gt;loopexit();
<a name="90" id="anc90"></a><span class="line-modified">1325   assert(main_end-&gt;outcnt() == 2, &quot;1 true, 1 false path only&quot;);</span>
1326 
1327   Node *pre_header= main_head-&gt;in(LoopNode::EntryControl);
1328   Node *init      = main_head-&gt;init_trip();
1329   Node *incr      = main_end -&gt;incr();
1330   Node *limit     = main_end -&gt;limit();
1331   Node *stride    = main_end -&gt;stride();
1332   Node *cmp       = main_end -&gt;cmp_node();
1333   BoolTest::mask b_test = main_end-&gt;test_trip();
1334 
1335   // Need only 1 user of &#39;bol&#39; because I will be hacking the loop bounds.
1336   Node *bol = main_end-&gt;in(CountedLoopEndNode::TestValue);
<a name="91" id="anc91"></a><span class="line-modified">1337   if (bol-&gt;outcnt() != 1) {</span>
1338     bol = bol-&gt;clone();
1339     register_new_node(bol,main_end-&gt;in(CountedLoopEndNode::TestControl));
1340     _igvn.replace_input_of(main_end, CountedLoopEndNode::TestValue, bol);
1341   }
1342   // Need only 1 user of &#39;cmp&#39; because I will be hacking the loop bounds.
<a name="92" id="anc92"></a><span class="line-modified">1343   if (cmp-&gt;outcnt() != 1) {</span>
1344     cmp = cmp-&gt;clone();
1345     register_new_node(cmp,main_end-&gt;in(CountedLoopEndNode::TestControl));
1346     _igvn.replace_input_of(bol, 1, cmp);
1347   }
1348 
1349   // Add the post loop
1350   CountedLoopNode *post_head = NULL;
1351   Node *main_exit = insert_post_loop(loop, old_new, main_head, main_end, incr, limit, post_head);
1352 
1353   //------------------------------
1354   // Step B: Create Pre-Loop.
1355 
1356   // Step B1: Clone the loop body.  The clone becomes the pre-loop.  The main
1357   // loop pre-header illegally has 2 control users (old &amp; new loops).
1358   LoopNode* outer_main_head = main_head;
1359   IdealLoopTree* outer_loop = loop;
1360   if (main_head-&gt;is_strip_mined()) {
1361     main_head-&gt;verify_strip_mined(1);
1362     outer_main_head = main_head-&gt;outer_loop();
1363     outer_loop = loop-&gt;_parent;
1364     assert(outer_loop-&gt;_head == outer_main_head, &quot;broken loop tree&quot;);
1365   }
1366   uint dd_main_head = dom_depth(outer_main_head);
1367   clone_loop(loop, old_new, dd_main_head, ControlAroundStripMined);
1368   CountedLoopNode*    pre_head = old_new[main_head-&gt;_idx]-&gt;as_CountedLoop();
1369   CountedLoopEndNode* pre_end  = old_new[main_end -&gt;_idx]-&gt;as_CountedLoopEnd();
1370   pre_head-&gt;set_pre_loop(main_head);
1371   Node *pre_incr = old_new[incr-&gt;_idx];
1372 
1373   // Reduce the pre-loop trip count.
1374   pre_end-&gt;_prob = PROB_FAIR;
1375 
1376   // Find the pre-loop normal exit.
1377   Node* pre_exit = pre_end-&gt;proj_out(false);
<a name="93" id="anc93"></a><span class="line-modified">1378   assert(pre_exit-&gt;Opcode() == Op_IfFalse, &quot;&quot;);</span>
1379   IfFalseNode *new_pre_exit = new IfFalseNode(pre_end);
<a name="94" id="anc94"></a><span class="line-modified">1380   _igvn.register_new_node_with_optimizer(new_pre_exit);</span>
1381   set_idom(new_pre_exit, pre_end, dd_main_head);
1382   set_loop(new_pre_exit, outer_loop-&gt;_parent);
1383 
1384   // Step B2: Build a zero-trip guard for the main-loop.  After leaving the
1385   // pre-loop, the main-loop may not execute at all.  Later in life this
1386   // zero-trip guard will become the minimum-trip guard when we unroll
1387   // the main-loop.
1388   Node *min_opaq = new Opaque1Node(C, limit);
<a name="95" id="anc95"></a><span class="line-modified">1389   Node *min_cmp  = new CmpINode(pre_incr, min_opaq);</span>
<span class="line-modified">1390   Node *min_bol  = new BoolNode(min_cmp, b_test);</span>
<span class="line-modified">1391   register_new_node(min_opaq, new_pre_exit);</span>
<span class="line-modified">1392   register_new_node(min_cmp , new_pre_exit);</span>
<span class="line-modified">1393   register_new_node(min_bol , new_pre_exit);</span>
1394 
1395   // Build the IfNode (assume the main-loop is executed always).
<a name="96" id="anc96"></a><span class="line-modified">1396   IfNode *min_iff = new IfNode(new_pre_exit, min_bol, PROB_ALWAYS, COUNT_UNKNOWN);</span>
<span class="line-modified">1397   _igvn.register_new_node_with_optimizer(min_iff);</span>
1398   set_idom(min_iff, new_pre_exit, dd_main_head);
1399   set_loop(min_iff, outer_loop-&gt;_parent);
1400 
1401   // Plug in the false-path, taken if we need to skip main-loop
<a name="97" id="anc97"></a><span class="line-modified">1402   _igvn.hash_delete(pre_exit);</span>
1403   pre_exit-&gt;set_req(0, min_iff);
1404   set_idom(pre_exit, min_iff, dd_main_head);
1405   set_idom(pre_exit-&gt;unique_ctrl_out(), min_iff, dd_main_head);
1406   // Make the true-path, must enter the main loop
<a name="98" id="anc98"></a><span class="line-modified">1407   Node *min_taken = new IfTrueNode(min_iff);</span>
<span class="line-modified">1408   _igvn.register_new_node_with_optimizer(min_taken);</span>
1409   set_idom(min_taken, min_iff, dd_main_head);
1410   set_loop(min_taken, outer_loop-&gt;_parent);
1411   // Plug in the true path
1412   _igvn.hash_delete(outer_main_head);
1413   outer_main_head-&gt;set_req(LoopNode::EntryControl, min_taken);
1414   set_idom(outer_main_head, min_taken, dd_main_head);
1415 
1416   Arena *a = Thread::current()-&gt;resource_area();
1417   VectorSet visited(a);
1418   Node_Stack clones(a, main_head-&gt;back_control()-&gt;outcnt());
1419   // Step B3: Make the fall-in values to the main-loop come from the
1420   // fall-out values of the pre-loop.
1421   for (DUIterator_Fast i2max, i2 = main_head-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1422     Node* main_phi = main_head-&gt;fast_out(i2);
<a name="99" id="anc99"></a><span class="line-modified">1423     if (main_phi-&gt;is_Phi() &amp;&amp; main_phi-&gt;in(0) == main_head &amp;&amp; main_phi-&gt;outcnt() &gt; 0) {</span>
1424       Node *pre_phi = old_new[main_phi-&gt;_idx];
1425       Node *fallpre  = clone_up_backedge_goo(pre_head-&gt;back_control(),
1426                                              main_head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl),
1427                                              pre_phi-&gt;in(LoopNode::LoopBackControl),
1428                                              visited, clones);
1429       _igvn.hash_delete(main_phi);
<a name="100" id="anc100"></a><span class="line-modified">1430       main_phi-&gt;set_req(LoopNode::EntryControl, fallpre);</span>
1431     }
1432   }
1433 
1434   // Nodes inside the loop may be control dependent on a predicate
1435   // that was moved before the preloop. If the back branch of the main
1436   // or post loops becomes dead, those nodes won&#39;t be dependent on the
1437   // test that guards that loop nest anymore which could lead to an
1438   // incorrect array access because it executes independently of the
1439   // test that was guarding the loop nest. We add a special CastII on
1440   // the if branch that enters the loop, between the input induction
1441   // variable value and the induction variable Phi to preserve correct
1442   // dependencies.
1443 
1444   // CastII for the main loop:
<a name="101" id="anc101"></a><span class="line-modified">1445   Node* castii = cast_incr_before_loop(pre_incr, min_taken, main_head);</span>
1446   assert(castii != NULL, &quot;no castII inserted&quot;);
1447   Node* opaque_castii = new Opaque1Node(C, castii);
1448   register_new_node(opaque_castii, outer_main_head-&gt;in(LoopNode::EntryControl));
1449   duplicate_predicates(pre_head, castii, opaque_castii, outer_loop, outer_main_head, dd_main_head);
1450 
1451   // Step B4: Shorten the pre-loop to run only 1 iteration (for now).
1452   // RCE and alignment may change this later.
1453   Node *cmp_end = pre_end-&gt;cmp_node();
<a name="102" id="anc102"></a><span class="line-modified">1454   assert(cmp_end-&gt;in(2) == limit, &quot;&quot;);</span>
<span class="line-modified">1455   Node *pre_limit = new AddINode(init, stride);</span>
1456 
1457   // Save the original loop limit in this Opaque1 node for
1458   // use by range check elimination.
1459   Node *pre_opaq  = new Opaque1Node(C, pre_limit, limit);
1460 
<a name="103" id="anc103"></a><span class="line-modified">1461   register_new_node(pre_limit, pre_head-&gt;in(0));</span>
<span class="line-modified">1462   register_new_node(pre_opaq , pre_head-&gt;in(0));</span>
1463 
1464   // Since no other users of pre-loop compare, I can hack limit directly
<a name="104" id="anc104"></a><span class="line-modified">1465   assert(cmp_end-&gt;outcnt() == 1, &quot;no other users&quot;);</span>
1466   _igvn.hash_delete(cmp_end);
1467   cmp_end-&gt;set_req(2, peel_only ? pre_limit : pre_opaq);
1468 
1469   // Special case for not-equal loop bounds:
1470   // Change pre loop test, main loop test, and the
1471   // main loop guard test to use lt or gt depending on stride
1472   // direction:
1473   // positive stride use &lt;
1474   // negative stride use &gt;
1475   //
1476   // not-equal test is kept for post loop to handle case
1477   // when init &gt; limit when stride &gt; 0 (and reverse).
1478 
1479   if (pre_end-&gt;in(CountedLoopEndNode::TestValue)-&gt;as_Bool()-&gt;_test._test == BoolTest::ne) {
1480 
1481     BoolTest::mask new_test = (main_end-&gt;stride_con() &gt; 0) ? BoolTest::lt : BoolTest::gt;
1482     // Modify pre loop end condition
1483     Node* pre_bol = pre_end-&gt;in(CountedLoopEndNode::TestValue)-&gt;as_Bool();
1484     BoolNode* new_bol0 = new BoolNode(pre_bol-&gt;in(1), new_test);
<a name="105" id="anc105"></a><span class="line-modified">1485     register_new_node(new_bol0, pre_head-&gt;in(0));</span>
1486     _igvn.replace_input_of(pre_end, CountedLoopEndNode::TestValue, new_bol0);
1487     // Modify main loop guard condition
1488     assert(min_iff-&gt;in(CountedLoopEndNode::TestValue) == min_bol, &quot;guard okay&quot;);
1489     BoolNode* new_bol1 = new BoolNode(min_bol-&gt;in(1), new_test);
<a name="106" id="anc106"></a><span class="line-modified">1490     register_new_node(new_bol1, new_pre_exit);</span>
1491     _igvn.hash_delete(min_iff);
1492     min_iff-&gt;set_req(CountedLoopEndNode::TestValue, new_bol1);
1493     // Modify main loop end condition
1494     BoolNode* main_bol = main_end-&gt;in(CountedLoopEndNode::TestValue)-&gt;as_Bool();
1495     BoolNode* new_bol2 = new BoolNode(main_bol-&gt;in(1), new_test);
<a name="107" id="anc107"></a><span class="line-modified">1496     register_new_node(new_bol2, main_end-&gt;in(CountedLoopEndNode::TestControl));</span>
1497     _igvn.replace_input_of(main_end, CountedLoopEndNode::TestValue, new_bol2);
1498   }
1499 
1500   // Flag main loop
1501   main_head-&gt;set_main_loop();
<a name="108" id="anc108"></a><span class="line-modified">1502   if (peel_only) {</span>
<span class="line-added">1503     main_head-&gt;set_main_no_pre_loop();</span>
<span class="line-added">1504   }</span>
1505 
1506   // Subtract a trip count for the pre-loop.
1507   main_head-&gt;set_trip_count(main_head-&gt;trip_count() - 1);
1508 
1509   // It&#39;s difficult to be precise about the trip-counts
1510   // for the pre/post loops.  They are usually very short,
1511   // so guess that 4 trips is a reasonable value.
1512   post_head-&gt;set_profile_trip_cnt(4.0);
1513   pre_head-&gt;set_profile_trip_cnt(4.0);
1514 
1515   // Now force out all loop-invariant dominating tests.  The optimizer
1516   // finds some, but we _know_ they are all useless.
1517   peeled_dom_test_elim(loop,old_new);
1518   loop-&gt;record_for_igvn();
1519 }
1520 
1521 //------------------------------insert_vector_post_loop------------------------
1522 // Insert a copy of the atomic unrolled vectorized main loop as a post loop,
<a name="109" id="anc109"></a><span class="line-modified">1523 // unroll_policy has  already informed  us that more  unrolling is  about to</span>
<span class="line-modified">1524 // happen  to the  main  loop.  The  resultant  post loop  will  serve as  a</span>
<span class="line-added">1525 // vectorized drain loop.</span>
1526 void PhaseIdealLoop::insert_vector_post_loop(IdealLoopTree *loop, Node_List &amp;old_new) {
1527   if (!loop-&gt;_head-&gt;is_CountedLoop()) return;
1528 
1529   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
1530 
1531   // only process vectorized main loops
1532   if (!cl-&gt;is_vectorized_loop() || !cl-&gt;is_main_loop()) return;
1533 
1534   int slp_max_unroll_factor = cl-&gt;slp_max_unroll();
1535   int cur_unroll = cl-&gt;unrolled_count();
1536 
1537   if (slp_max_unroll_factor == 0) return;
1538 
1539   // only process atomic unroll vector loops (not super unrolled after vectorization)
1540   if (cur_unroll != slp_max_unroll_factor) return;
1541 
1542   // we only ever process this one time
1543   if (cl-&gt;has_atomic_post_loop()) return;
1544 
<a name="110" id="anc110"></a><span class="line-added">1545   if (!may_require_nodes(loop-&gt;est_loop_clone_sz(2))) {</span>
<span class="line-added">1546     return;</span>
<span class="line-added">1547   }</span>
<span class="line-added">1548 </span>
1549 #ifndef PRODUCT
1550   if (TraceLoopOpts) {
1551     tty-&gt;print(&quot;PostVector  &quot;);
1552     loop-&gt;dump_head();
1553   }
1554 #endif
1555   C-&gt;set_major_progress();
1556 
1557   // Find common pieces of the loop being guarded with pre &amp; post loops
1558   CountedLoopNode *main_head = loop-&gt;_head-&gt;as_CountedLoop();
1559   CountedLoopEndNode *main_end = main_head-&gt;loopexit();
1560   // diagnostic to show loop end is not properly formed
1561   assert(main_end-&gt;outcnt() == 2, &quot;1 true, 1 false path only&quot;);
1562 
1563   // mark this loop as processed
1564   main_head-&gt;mark_has_atomic_post_loop();
1565 
1566   Node *incr = main_end-&gt;incr();
1567   Node *limit = main_end-&gt;limit();
1568 
1569   // In this case we throw away the result as we are not using it to connect anything else.
1570   CountedLoopNode *post_head = NULL;
1571   insert_post_loop(loop, old_new, main_head, main_end, incr, limit, post_head);
1572 
1573   // It&#39;s difficult to be precise about the trip-counts
1574   // for post loops.  They are usually very short,
1575   // so guess that unit vector trips is a reasonable value.
1576   post_head-&gt;set_profile_trip_cnt(cur_unroll);
1577 
1578   // Now force out all loop-invariant dominating tests.  The optimizer
1579   // finds some, but we _know_ they are all useless.
1580   peeled_dom_test_elim(loop, old_new);
1581   loop-&gt;record_for_igvn();
1582 }
1583 
1584 
1585 //-------------------------insert_scalar_rced_post_loop------------------------
1586 // Insert a copy of the rce&#39;d main loop as a post loop,
1587 // We have not unrolled the main loop, so this is the right time to inject this.
1588 // Later we will examine the partner of this post loop pair which still has range checks
1589 // to see inject code which tests at runtime if the range checks are applicable.
1590 void PhaseIdealLoop::insert_scalar_rced_post_loop(IdealLoopTree *loop, Node_List &amp;old_new) {
1591   if (!loop-&gt;_head-&gt;is_CountedLoop()) return;
1592 
1593   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
1594 
1595   // only process RCE&#39;d main loops
1596   if (!cl-&gt;is_main_loop() || cl-&gt;range_checks_present()) return;
1597 
1598 #ifndef PRODUCT
1599   if (TraceLoopOpts) {
1600     tty-&gt;print(&quot;PostScalarRce  &quot;);
1601     loop-&gt;dump_head();
1602   }
1603 #endif
1604   C-&gt;set_major_progress();
1605 
1606   // Find common pieces of the loop being guarded with pre &amp; post loops
1607   CountedLoopNode *main_head = loop-&gt;_head-&gt;as_CountedLoop();
1608   CountedLoopEndNode *main_end = main_head-&gt;loopexit();
1609   // diagnostic to show loop end is not properly formed
1610   assert(main_end-&gt;outcnt() == 2, &quot;1 true, 1 false path only&quot;);
1611 
1612   Node *incr = main_end-&gt;incr();
1613   Node *limit = main_end-&gt;limit();
1614 
1615   // In this case we throw away the result as we are not using it to connect anything else.
1616   CountedLoopNode *post_head = NULL;
1617   insert_post_loop(loop, old_new, main_head, main_end, incr, limit, post_head);
1618 
1619   // It&#39;s difficult to be precise about the trip-counts
1620   // for post loops.  They are usually very short,
1621   // so guess that unit vector trips is a reasonable value.
1622   post_head-&gt;set_profile_trip_cnt(4.0);
1623   post_head-&gt;set_is_rce_post_loop();
1624 
1625   // Now force out all loop-invariant dominating tests.  The optimizer
1626   // finds some, but we _know_ they are all useless.
1627   peeled_dom_test_elim(loop, old_new);
1628   loop-&gt;record_for_igvn();
1629 }
1630 
1631 
1632 //------------------------------insert_post_loop-------------------------------
1633 // Insert post loops.  Add a post loop to the given loop passed.
1634 Node *PhaseIdealLoop::insert_post_loop(IdealLoopTree *loop, Node_List &amp;old_new,
1635                                        CountedLoopNode *main_head, CountedLoopEndNode *main_end,
1636                                        Node *incr, Node *limit, CountedLoopNode *&amp;post_head) {
1637   IfNode* outer_main_end = main_end;
1638   IdealLoopTree* outer_loop = loop;
1639   if (main_head-&gt;is_strip_mined()) {
1640     main_head-&gt;verify_strip_mined(1);
1641     outer_main_end = main_head-&gt;outer_loop_end();
1642     outer_loop = loop-&gt;_parent;
1643     assert(outer_loop-&gt;_head == main_head-&gt;in(LoopNode::EntryControl), &quot;broken loop tree&quot;);
1644   }
1645 
1646   //------------------------------
1647   // Step A: Create a new post-Loop.
1648   Node* main_exit = outer_main_end-&gt;proj_out(false);
1649   assert(main_exit-&gt;Opcode() == Op_IfFalse, &quot;&quot;);
1650   int dd_main_exit = dom_depth(main_exit);
1651 
1652   // Step A1: Clone the loop body of main. The clone becomes the post-loop.
1653   // The main loop pre-header illegally has 2 control users (old &amp; new loops).
1654   clone_loop(loop, old_new, dd_main_exit, ControlAroundStripMined);
1655   assert(old_new[main_end-&gt;_idx]-&gt;Opcode() == Op_CountedLoopEnd, &quot;&quot;);
1656   post_head = old_new[main_head-&gt;_idx]-&gt;as_CountedLoop();
1657   post_head-&gt;set_normal_loop();
1658   post_head-&gt;set_post_loop(main_head);
1659 
1660   // Reduce the post-loop trip count.
1661   CountedLoopEndNode* post_end = old_new[main_end-&gt;_idx]-&gt;as_CountedLoopEnd();
1662   post_end-&gt;_prob = PROB_FAIR;
1663 
1664   // Build the main-loop normal exit.
1665   IfFalseNode *new_main_exit = new IfFalseNode(outer_main_end);
1666   _igvn.register_new_node_with_optimizer(new_main_exit);
1667   set_idom(new_main_exit, outer_main_end, dd_main_exit);
1668   set_loop(new_main_exit, outer_loop-&gt;_parent);
1669 
1670   // Step A2: Build a zero-trip guard for the post-loop.  After leaving the
1671   // main-loop, the post-loop may not execute at all.  We &#39;opaque&#39; the incr
1672   // (the previous loop trip-counter exit value) because we will be changing
1673   // the exit value (via additional unrolling) so we cannot constant-fold away the zero
1674   // trip guard until all unrolling is done.
1675   Node *zer_opaq = new Opaque1Node(C, incr);
1676   Node *zer_cmp = new CmpINode(zer_opaq, limit);
1677   Node *zer_bol = new BoolNode(zer_cmp, main_end-&gt;test_trip());
1678   register_new_node(zer_opaq, new_main_exit);
1679   register_new_node(zer_cmp, new_main_exit);
1680   register_new_node(zer_bol, new_main_exit);
1681 
1682   // Build the IfNode
1683   IfNode *zer_iff = new IfNode(new_main_exit, zer_bol, PROB_FAIR, COUNT_UNKNOWN);
1684   _igvn.register_new_node_with_optimizer(zer_iff);
1685   set_idom(zer_iff, new_main_exit, dd_main_exit);
1686   set_loop(zer_iff, outer_loop-&gt;_parent);
1687 
1688   // Plug in the false-path, taken if we need to skip this post-loop
1689   _igvn.replace_input_of(main_exit, 0, zer_iff);
1690   set_idom(main_exit, zer_iff, dd_main_exit);
1691   set_idom(main_exit-&gt;unique_out(), zer_iff, dd_main_exit);
1692   // Make the true-path, must enter this post loop
1693   Node *zer_taken = new IfTrueNode(zer_iff);
1694   _igvn.register_new_node_with_optimizer(zer_taken);
1695   set_idom(zer_taken, zer_iff, dd_main_exit);
1696   set_loop(zer_taken, outer_loop-&gt;_parent);
1697   // Plug in the true path
1698   _igvn.hash_delete(post_head);
1699   post_head-&gt;set_req(LoopNode::EntryControl, zer_taken);
1700   set_idom(post_head, zer_taken, dd_main_exit);
1701 
1702   Arena *a = Thread::current()-&gt;resource_area();
1703   VectorSet visited(a);
1704   Node_Stack clones(a, main_head-&gt;back_control()-&gt;outcnt());
1705   // Step A3: Make the fall-in values to the post-loop come from the
1706   // fall-out values of the main-loop.
1707   for (DUIterator_Fast imax, i = main_head-&gt;fast_outs(imax); i &lt; imax; i++) {
1708     Node* main_phi = main_head-&gt;fast_out(i);
<a name="111" id="anc111"></a><span class="line-modified">1709     if (main_phi-&gt;is_Phi() &amp;&amp; main_phi-&gt;in(0) == main_head &amp;&amp; main_phi-&gt;outcnt() &gt; 0) {</span>
1710       Node *cur_phi = old_new[main_phi-&gt;_idx];
1711       Node *fallnew = clone_up_backedge_goo(main_head-&gt;back_control(),
1712                                             post_head-&gt;init_control(),
1713                                             main_phi-&gt;in(LoopNode::LoopBackControl),
1714                                             visited, clones);
1715       _igvn.hash_delete(cur_phi);
1716       cur_phi-&gt;set_req(LoopNode::EntryControl, fallnew);
1717     }
1718   }
1719 
1720   // CastII for the new post loop:
1721   Node* castii = cast_incr_before_loop(zer_opaq-&gt;in(1), zer_taken, post_head);
1722   assert(castii != NULL, &quot;no castII inserted&quot;);
1723 
1724   return new_main_exit;
1725 }
1726 
1727 //------------------------------is_invariant-----------------------------
1728 // Return true if n is invariant
1729 bool IdealLoopTree::is_invariant(Node* n) const {
1730   Node *n_c = _phase-&gt;has_ctrl(n) ? _phase-&gt;get_ctrl(n) : n;
1731   if (n_c-&gt;is_top()) return false;
1732   return !is_member(_phase-&gt;get_loop(n_c));
1733 }
1734 
1735 void PhaseIdealLoop::update_skeleton_predicates(Node* ctrl, CountedLoopNode* loop_head, Node* init, int stride_con) {
1736   // Search for skeleton predicates and update them according to the new stride
1737   Node* entry = ctrl;
1738   Node* prev_proj = ctrl;
1739   LoopNode* outer_loop_head = loop_head-&gt;skip_strip_mined();
1740   IdealLoopTree* outer_loop = get_loop(outer_loop_head);
1741   while (entry != NULL &amp;&amp; entry-&gt;is_Proj() &amp;&amp; entry-&gt;in(0)-&gt;is_If()) {
1742     IfNode* iff = entry-&gt;in(0)-&gt;as_If();
1743     ProjNode* proj = iff-&gt;proj_out(1 - entry-&gt;as_Proj()-&gt;_con);
1744     if (proj-&gt;unique_ctrl_out()-&gt;Opcode() != Op_Halt) {
1745       break;
1746     }
1747     if (iff-&gt;in(1)-&gt;Opcode() == Op_Opaque4) {
1748       // Look for predicate with an Opaque1 node that can be used as a template
1749       if (!skeleton_predicate_has_opaque(iff)) {
1750         // No Opaque1 node? It&#39;s either the check for the first value
1751         // of the first iteration or the check for the last value of
1752         // the first iteration of an unrolled loop. We can&#39;t
1753         // tell. Kill it in any case.
1754         _igvn.replace_input_of(iff, 1, iff-&gt;in(1)-&gt;in(2));
1755       } else {
1756         // Add back the predicate for the value at the beginning of the first entry
1757         prev_proj = clone_skeleton_predicate(iff, init, entry, proj, ctrl, outer_loop, prev_proj);
1758         assert(!skeleton_predicate_has_opaque(prev_proj-&gt;in(0)-&gt;as_If()), &quot;unexpected&quot;);
1759         // Compute the value of the loop induction variable at the end of the
1760         // first iteration of the unrolled loop: init + new_stride_con - init_inc
1761         int init_inc = stride_con/loop_head-&gt;unrolled_count();
1762         assert(init_inc != 0, &quot;invalid loop increment&quot;);
1763         int new_stride_con = stride_con * 2;
1764         Node* max_value = _igvn.intcon(new_stride_con - init_inc);
1765         max_value = new AddINode(init, max_value);
1766         register_new_node(max_value, get_ctrl(iff-&gt;in(1)));
1767         prev_proj = clone_skeleton_predicate(iff, max_value, entry, proj, ctrl, outer_loop, prev_proj);
1768         assert(!skeleton_predicate_has_opaque(prev_proj-&gt;in(0)-&gt;as_If()), &quot;unexpected&quot;);
1769       }
1770     }
1771     entry = entry-&gt;in(0)-&gt;in(0);
1772   }
1773   if (prev_proj != ctrl) {
1774     _igvn.replace_input_of(outer_loop_head, LoopNode::EntryControl, prev_proj);
1775     set_idom(outer_loop_head, prev_proj, dom_depth(outer_loop_head));
1776   }
1777 }
1778 
1779 //------------------------------do_unroll--------------------------------------
1780 // Unroll the loop body one step - make each trip do 2 iterations.
<a name="112" id="anc112"></a><span class="line-modified">1781 void PhaseIdealLoop::do_unroll(IdealLoopTree *loop, Node_List &amp;old_new, bool adjust_min_trip) {</span>
1782   assert(LoopUnrollLimit, &quot;&quot;);
1783   CountedLoopNode *loop_head = loop-&gt;_head-&gt;as_CountedLoop();
1784   CountedLoopEndNode *loop_end = loop_head-&gt;loopexit();
1785 #ifndef PRODUCT
1786   if (PrintOpto &amp;&amp; VerifyLoopOptimizations) {
1787     tty-&gt;print(&quot;Unrolling &quot;);
1788     loop-&gt;dump_head();
1789   } else if (TraceLoopOpts) {
1790     if (loop_head-&gt;trip_count() &lt; (uint)LoopUnrollLimit) {
1791       tty-&gt;print(&quot;Unroll %d(%2d) &quot;, loop_head-&gt;unrolled_count()*2, loop_head-&gt;trip_count());
1792     } else {
1793       tty-&gt;print(&quot;Unroll %d     &quot;, loop_head-&gt;unrolled_count()*2);
1794     }
1795     loop-&gt;dump_head();
1796   }
1797 
1798   if (C-&gt;do_vector_loop() &amp;&amp; (PrintOpto &amp;&amp; (VerifyLoopOptimizations || TraceLoopOpts))) {
1799     Arena* arena = Thread::current()-&gt;resource_area();
1800     Node_Stack stack(arena, C-&gt;live_nodes() &gt;&gt; 2);
1801     Node_List rpo_list;
1802     VectorSet visited(arena);
1803     visited.set(loop_head-&gt;_idx);
<a name="113" id="anc113"></a><span class="line-modified">1804     rpo(loop_head, stack, visited, rpo_list);</span>
<span class="line-modified">1805     dump(loop, rpo_list.size(), rpo_list);</span>
1806   }
1807 #endif
1808 
1809   // Remember loop node count before unrolling to detect
1810   // if rounds of unroll,optimize are making progress
1811   loop_head-&gt;set_node_count_before_unroll(loop-&gt;_body.size());
1812 
1813   Node *ctrl  = loop_head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
1814   Node *limit = loop_head-&gt;limit();
1815   Node *init  = loop_head-&gt;init_trip();
1816   Node *stride = loop_head-&gt;stride();
1817 
1818   Node *opaq = NULL;
1819   if (adjust_min_trip) {       // If not maximally unrolling, need adjustment
1820     // Search for zero-trip guard.
1821 
1822     // Check the shape of the graph at the loop entry. If an inappropriate
1823     // graph shape is encountered, the compiler bails out loop unrolling;
1824     // compilation of the method will still succeed.
1825     if (!is_canonical_loop_entry(loop_head)) {
1826       return;
1827     }
1828     opaq = loop_head-&gt;skip_predicates()-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(2);
1829     // Zero-trip test uses an &#39;opaque&#39; node which is not shared.
1830     assert(opaq-&gt;outcnt() == 1 &amp;&amp; opaq-&gt;in(1) == limit, &quot;&quot;);
1831   }
1832 
1833   C-&gt;set_major_progress();
1834 
1835   Node* new_limit = NULL;
1836   int stride_con = stride-&gt;get_int();
1837   int stride_p = (stride_con &gt; 0) ? stride_con : -stride_con;
1838   uint old_trip_count = loop_head-&gt;trip_count();
1839   // Verify that unroll policy result is still valid.
1840   assert(old_trip_count &gt; 1 &amp;&amp;
1841       (!adjust_min_trip || stride_p &lt;= (1&lt;&lt;3)*loop_head-&gt;unrolled_count()), &quot;sanity&quot;);
1842 
1843   update_skeleton_predicates(ctrl, loop_head, init, stride_con);
1844 
1845   // Adjust loop limit to keep valid iterations number after unroll.
1846   // Use (limit - stride) instead of (((limit - init)/stride) &amp; (-2))*stride
1847   // which may overflow.
1848   if (!adjust_min_trip) {
1849     assert(old_trip_count &gt; 1 &amp;&amp; (old_trip_count &amp; 1) == 0,
1850         &quot;odd trip count for maximally unroll&quot;);
1851     // Don&#39;t need to adjust limit for maximally unroll since trip count is even.
1852   } else if (loop_head-&gt;has_exact_trip_count() &amp;&amp; init-&gt;is_Con()) {
1853     // Loop&#39;s limit is constant. Loop&#39;s init could be constant when pre-loop
1854     // become peeled iteration.
1855     jlong init_con = init-&gt;get_int();
1856     // We can keep old loop limit if iterations count stays the same:
1857     //   old_trip_count == new_trip_count * 2
1858     // Note: since old_trip_count &gt;= 2 then new_trip_count &gt;= 1
1859     // so we also don&#39;t need to adjust zero trip test.
1860     jlong limit_con  = limit-&gt;get_int();
1861     // (stride_con*2) not overflow since stride_con &lt;= 8.
1862     int new_stride_con = stride_con * 2;
1863     int stride_m    = new_stride_con - (stride_con &gt; 0 ? 1 : -1);
1864     jlong trip_count = (limit_con - init_con + stride_m)/new_stride_con;
1865     // New trip count should satisfy next conditions.
1866     assert(trip_count &gt; 0 &amp;&amp; (julong)trip_count &lt; (julong)max_juint/2, &quot;sanity&quot;);
1867     uint new_trip_count = (uint)trip_count;
1868     adjust_min_trip = (old_trip_count != new_trip_count*2);
1869   }
1870 
1871   if (adjust_min_trip) {
1872     // Step 2: Adjust the trip limit if it is called for.
1873     // The adjustment amount is -stride. Need to make sure if the
1874     // adjustment underflows or overflows, then the main loop is skipped.
1875     Node* cmp = loop_end-&gt;cmp_node();
1876     assert(cmp-&gt;in(2) == limit, &quot;sanity&quot;);
1877     assert(opaq != NULL &amp;&amp; opaq-&gt;in(1) == limit, &quot;sanity&quot;);
1878 
1879     // Verify that policy_unroll result is still valid.
1880     const TypeInt* limit_type = _igvn.type(limit)-&gt;is_int();
1881     assert(stride_con &gt; 0 &amp;&amp; ((limit_type-&gt;_hi - stride_con) &lt; limit_type-&gt;_hi) ||
<a name="114" id="anc114"></a><span class="line-modified">1882            stride_con &lt; 0 &amp;&amp; ((limit_type-&gt;_lo - stride_con) &gt; limit_type-&gt;_lo),</span>
<span class="line-added">1883            &quot;sanity&quot;);</span>
1884 
1885     if (limit-&gt;is_Con()) {
1886       // The check in policy_unroll and the assert above guarantee
1887       // no underflow if limit is constant.
1888       new_limit = _igvn.intcon(limit-&gt;get_int() - stride_con);
1889       set_ctrl(new_limit, C-&gt;root());
1890     } else {
1891       // Limit is not constant.
1892       if (loop_head-&gt;unrolled_count() == 1) { // only for first unroll
1893         // Separate limit by Opaque node in case it is an incremented
1894         // variable from previous loop to avoid using pre-incremented
1895         // value which could increase register pressure.
1896         // Otherwise reorg_offsets() optimization will create a separate
1897         // Opaque node for each use of trip-counter and as result
1898         // zero trip guard limit will be different from loop limit.
1899         assert(has_ctrl(opaq), &quot;should have it&quot;);
1900         Node* opaq_ctrl = get_ctrl(opaq);
<a name="115" id="anc115"></a><span class="line-modified">1901         limit = new Opaque2Node(C, limit);</span>
<span class="line-modified">1902         register_new_node(limit, opaq_ctrl);</span>
1903       }
1904       if ((stride_con &gt; 0 &amp;&amp; (java_subtract(limit_type-&gt;_lo, stride_con) &lt; limit_type-&gt;_lo)) ||
1905           (stride_con &lt; 0 &amp;&amp; (java_subtract(limit_type-&gt;_hi, stride_con) &gt; limit_type-&gt;_hi))) {
1906         // No underflow.
1907         new_limit = new SubINode(limit, stride);
1908       } else {
1909         // (limit - stride) may underflow.
1910         // Clamp the adjustment value with MININT or MAXINT:
1911         //
1912         //   new_limit = limit-stride
1913         //   if (stride &gt; 0)
1914         //     new_limit = (limit &lt; new_limit) ? MININT : new_limit;
1915         //   else
1916         //     new_limit = (limit &gt; new_limit) ? MAXINT : new_limit;
1917         //
1918         BoolTest::mask bt = loop_end-&gt;test_trip();
1919         assert(bt == BoolTest::lt || bt == BoolTest::gt, &quot;canonical test is expected&quot;);
1920         Node* adj_max = _igvn.intcon((stride_con &gt; 0) ? min_jint : max_jint);
1921         set_ctrl(adj_max, C-&gt;root());
1922         Node* old_limit = NULL;
1923         Node* adj_limit = NULL;
1924         Node* bol = limit-&gt;is_CMove() ? limit-&gt;in(CMoveNode::Condition) : NULL;
1925         if (loop_head-&gt;unrolled_count() &gt; 1 &amp;&amp;
1926             limit-&gt;is_CMove() &amp;&amp; limit-&gt;Opcode() == Op_CMoveI &amp;&amp;
1927             limit-&gt;in(CMoveNode::IfTrue) == adj_max &amp;&amp;
1928             bol-&gt;as_Bool()-&gt;_test._test == bt &amp;&amp;
1929             bol-&gt;in(1)-&gt;Opcode() == Op_CmpI &amp;&amp;
1930             bol-&gt;in(1)-&gt;in(2) == limit-&gt;in(CMoveNode::IfFalse)) {
1931           // Loop was unrolled before.
1932           // Optimize the limit to avoid nested CMove:
1933           // use original limit as old limit.
1934           old_limit = bol-&gt;in(1)-&gt;in(1);
1935           // Adjust previous adjusted limit.
1936           adj_limit = limit-&gt;in(CMoveNode::IfFalse);
1937           adj_limit = new SubINode(adj_limit, stride);
1938         } else {
1939           old_limit = limit;
1940           adj_limit = new SubINode(limit, stride);
1941         }
1942         assert(old_limit != NULL &amp;&amp; adj_limit != NULL, &quot;&quot;);
<a name="116" id="anc116"></a><span class="line-modified">1943         register_new_node(adj_limit, ctrl); // adjust amount</span>
1944         Node* adj_cmp = new CmpINode(old_limit, adj_limit);
<a name="117" id="anc117"></a><span class="line-modified">1945         register_new_node(adj_cmp, ctrl);</span>
1946         Node* adj_bool = new BoolNode(adj_cmp, bt);
<a name="118" id="anc118"></a><span class="line-modified">1947         register_new_node(adj_bool, ctrl);</span>
1948         new_limit = new CMoveINode(adj_bool, adj_limit, adj_max, TypeInt::INT);
1949       }
1950       register_new_node(new_limit, ctrl);
1951     }
<a name="119" id="anc119"></a><span class="line-added">1952 </span>
1953     assert(new_limit != NULL, &quot;&quot;);
1954     // Replace in loop test.
1955     assert(loop_end-&gt;in(1)-&gt;in(1) == cmp, &quot;sanity&quot;);
1956     if (cmp-&gt;outcnt() == 1 &amp;&amp; loop_end-&gt;in(1)-&gt;outcnt() == 1) {
1957       // Don&#39;t need to create new test since only one user.
1958       _igvn.hash_delete(cmp);
1959       cmp-&gt;set_req(2, new_limit);
1960     } else {
1961       // Create new test since it is shared.
1962       Node* ctrl2 = loop_end-&gt;in(0);
1963       Node* cmp2  = cmp-&gt;clone();
1964       cmp2-&gt;set_req(2, new_limit);
1965       register_new_node(cmp2, ctrl2);
1966       Node* bol2 = loop_end-&gt;in(1)-&gt;clone();
1967       bol2-&gt;set_req(1, cmp2);
1968       register_new_node(bol2, ctrl2);
1969       _igvn.replace_input_of(loop_end, 1, bol2);
1970     }
1971     // Step 3: Find the min-trip test guaranteed before a &#39;main&#39; loop.
1972     // Make it a 1-trip test (means at least 2 trips).
1973 
1974     // Guard test uses an &#39;opaque&#39; node which is not shared.  Hence I
1975     // can edit it&#39;s inputs directly.  Hammer in the new limit for the
1976     // minimum-trip guard.
1977     assert(opaq-&gt;outcnt() == 1, &quot;&quot;);
1978     _igvn.replace_input_of(opaq, 1, new_limit);
1979   }
1980 
1981   // Adjust max trip count. The trip count is intentionally rounded
1982   // down here (e.g. 15-&gt; 7-&gt; 3-&gt; 1) because if we unwittingly over-unroll,
1983   // the main, unrolled, part of the loop will never execute as it is protected
1984   // by the min-trip test.  See bug 4834191 for a case where we over-unrolled
1985   // and later determined that part of the unrolled loop was dead.
1986   loop_head-&gt;set_trip_count(old_trip_count / 2);
1987 
1988   // Double the count of original iterations in the unrolled loop body.
1989   loop_head-&gt;double_unrolled_count();
1990 
1991   // ---------
1992   // Step 4: Clone the loop body.  Move it inside the loop.  This loop body
1993   // represents the odd iterations; since the loop trips an even number of
1994   // times its backedge is never taken.  Kill the backedge.
1995   uint dd = dom_depth(loop_head);
1996   clone_loop(loop, old_new, dd, IgnoreStripMined);
1997 
1998   // Make backedges of the clone equal to backedges of the original.
1999   // Make the fall-in from the original come from the fall-out of the clone.
2000   for (DUIterator_Fast jmax, j = loop_head-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2001     Node* phi = loop_head-&gt;fast_out(j);
<a name="120" id="anc120"></a><span class="line-modified">2002     if (phi-&gt;is_Phi() &amp;&amp; phi-&gt;in(0) == loop_head &amp;&amp; phi-&gt;outcnt() &gt; 0) {</span>
2003       Node *newphi = old_new[phi-&gt;_idx];
<a name="121" id="anc121"></a><span class="line-modified">2004       _igvn.hash_delete(phi);</span>
<span class="line-modified">2005       _igvn.hash_delete(newphi);</span>
2006 
2007       phi   -&gt;set_req(LoopNode::   EntryControl, newphi-&gt;in(LoopNode::LoopBackControl));
2008       newphi-&gt;set_req(LoopNode::LoopBackControl, phi   -&gt;in(LoopNode::LoopBackControl));
2009       phi   -&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
2010     }
2011   }
2012   Node *clone_head = old_new[loop_head-&gt;_idx];
<a name="122" id="anc122"></a><span class="line-modified">2013   _igvn.hash_delete(clone_head);</span>
2014   loop_head -&gt;set_req(LoopNode::   EntryControl, clone_head-&gt;in(LoopNode::LoopBackControl));
2015   clone_head-&gt;set_req(LoopNode::LoopBackControl, loop_head -&gt;in(LoopNode::LoopBackControl));
2016   loop_head -&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
2017   loop-&gt;_head = clone_head;     // New loop header
2018 
2019   set_idom(loop_head,  loop_head -&gt;in(LoopNode::EntryControl), dd);
2020   set_idom(clone_head, clone_head-&gt;in(LoopNode::EntryControl), dd);
2021 
2022   // Kill the clone&#39;s backedge
2023   Node *newcle = old_new[loop_end-&gt;_idx];
<a name="123" id="anc123"></a><span class="line-modified">2024   _igvn.hash_delete(newcle);</span>
2025   Node *one = _igvn.intcon(1);
2026   set_ctrl(one, C-&gt;root());
2027   newcle-&gt;set_req(1, one);
2028   // Force clone into same loop body
2029   uint max = loop-&gt;_body.size();
<a name="124" id="anc124"></a><span class="line-modified">2030   for (uint k = 0; k &lt; max; k++) {</span>
2031     Node *old = loop-&gt;_body.at(k);
2032     Node *nnn = old_new[old-&gt;_idx];
2033     loop-&gt;_body.push(nnn);
<a name="125" id="anc125"></a><span class="line-modified">2034     if (!has_ctrl(old)) {</span>
2035       set_loop(nnn, loop);
<a name="126" id="anc126"></a><span class="line-added">2036     }</span>
2037   }
2038 
2039   loop-&gt;record_for_igvn();
2040   loop_head-&gt;clear_strip_mined();
2041 
2042 #ifndef PRODUCT
2043   if (C-&gt;do_vector_loop() &amp;&amp; (PrintOpto &amp;&amp; (VerifyLoopOptimizations || TraceLoopOpts))) {
2044     tty-&gt;print(&quot;\nnew loop after unroll\n&quot;);       loop-&gt;dump_head();
2045     for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {
2046       loop-&gt;_body.at(i)-&gt;dump();
2047     }
<a name="127" id="anc127"></a><span class="line-modified">2048     if (C-&gt;clone_map().is_debug()) {</span>
2049       tty-&gt;print(&quot;\nCloneMap\n&quot;);
2050       Dict* dict = C-&gt;clone_map().dict();
2051       DictI i(dict);
2052       tty-&gt;print_cr(&quot;Dict@%p[%d] = &quot;, dict, dict-&gt;Size());
2053       for (int ii = 0; i.test(); ++i, ++ii) {
2054         NodeCloneInfo cl((uint64_t)dict-&gt;operator[]((void*)i._key));
2055         tty-&gt;print(&quot;%d-&gt;%d:%d,&quot;, (int)(intptr_t)i._key, cl.idx(), cl.gen());
2056         if (ii % 10 == 9) {
2057           tty-&gt;print_cr(&quot; &quot;);
2058         }
2059       }
2060       tty-&gt;print_cr(&quot; &quot;);
2061     }
2062   }
2063 #endif
<a name="128" id="anc128"></a>
2064 }
2065 
2066 //------------------------------do_maximally_unroll----------------------------
2067 
<a name="129" id="anc129"></a><span class="line-modified">2068 void PhaseIdealLoop::do_maximally_unroll(IdealLoopTree *loop, Node_List &amp;old_new) {</span>
2069   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
2070   assert(cl-&gt;has_exact_trip_count(), &quot;trip count is not exact&quot;);
2071   assert(cl-&gt;trip_count() &gt; 0, &quot;&quot;);
2072 #ifndef PRODUCT
2073   if (TraceLoopOpts) {
2074     tty-&gt;print(&quot;MaxUnroll  %d &quot;, cl-&gt;trip_count());
2075     loop-&gt;dump_head();
2076   }
2077 #endif
2078 
2079   // If loop is tripping an odd number of times, peel odd iteration
2080   if ((cl-&gt;trip_count() &amp; 1) == 1) {
2081     do_peeling(loop, old_new);
2082   }
2083 
2084   // Now its tripping an even number of times remaining.  Double loop body.
2085   // Do not adjust pre-guards; they are not needed and do not exist.
2086   if (cl-&gt;trip_count() &gt; 0) {
2087     assert((cl-&gt;trip_count() &amp; 1) == 0, &quot;missed peeling&quot;);
2088     do_unroll(loop, old_new, false);
2089   }
2090 }
2091 
2092 void PhaseIdealLoop::mark_reductions(IdealLoopTree *loop) {
2093   if (SuperWordReductions == false) return;
2094 
2095   CountedLoopNode* loop_head = loop-&gt;_head-&gt;as_CountedLoop();
2096   if (loop_head-&gt;unrolled_count() &gt; 1) {
2097     return;
2098   }
2099 
2100   Node* trip_phi = loop_head-&gt;phi();
2101   for (DUIterator_Fast imax, i = loop_head-&gt;fast_outs(imax); i &lt; imax; i++) {
2102     Node* phi = loop_head-&gt;fast_out(i);
2103     if (phi-&gt;is_Phi() &amp;&amp; phi-&gt;outcnt() &gt; 0 &amp;&amp; phi != trip_phi) {
2104       // For definitions which are loop inclusive and not tripcounts.
2105       Node* def_node = phi-&gt;in(LoopNode::LoopBackControl);
2106 
2107       if (def_node != NULL) {
2108         Node* n_ctrl = get_ctrl(def_node);
2109         if (n_ctrl != NULL &amp;&amp; loop-&gt;is_member(get_loop(n_ctrl))) {
2110           // Now test it to see if it fits the standard pattern for a reduction operator.
2111           int opc = def_node-&gt;Opcode();
2112           if (opc != ReductionNode::opcode(opc, def_node-&gt;bottom_type()-&gt;basic_type())
2113               || opc == Op_MinD || opc == Op_MinF || opc == Op_MaxD || opc == Op_MaxF) {
2114             if (!def_node-&gt;is_reduction()) { // Not marked yet
2115               // To be a reduction, the arithmetic node must have the phi as input and provide a def to it
2116               bool ok = false;
2117               for (unsigned j = 1; j &lt; def_node-&gt;req(); j++) {
2118                 Node* in = def_node-&gt;in(j);
2119                 if (in == phi) {
2120                   ok = true;
2121                   break;
2122                 }
2123               }
2124 
2125               // do nothing if we did not match the initial criteria
2126               if (ok == false) {
2127                 continue;
2128               }
2129 
2130               // The result of the reduction must not be used in the loop
2131               for (DUIterator_Fast imax, i = def_node-&gt;fast_outs(imax); i &lt; imax &amp;&amp; ok; i++) {
2132                 Node* u = def_node-&gt;fast_out(i);
2133                 if (!loop-&gt;is_member(get_loop(ctrl_or_self(u)))) {
2134                   continue;
2135                 }
2136                 if (u == phi) {
2137                   continue;
2138                 }
2139                 ok = false;
2140               }
2141 
2142               // iff the uses conform
2143               if (ok) {
2144                 def_node-&gt;add_flag(Node::Flag_is_reduction);
2145                 loop_head-&gt;mark_has_reductions();
2146               }
2147             }
2148           }
2149         }
2150       }
2151     }
2152   }
2153 }
2154 
2155 //------------------------------adjust_limit-----------------------------------
2156 // Helper function for add_constraint().
2157 Node* PhaseIdealLoop::adjust_limit(int stride_con, Node * scale, Node *offset, Node *rc_limit, Node *loop_limit, Node *pre_ctrl, bool round_up) {
2158   // Compute &quot;I :: (limit-offset)/scale&quot;
2159   Node *con = new SubINode(rc_limit, offset);
2160   register_new_node(con, pre_ctrl);
2161   Node *X = new DivINode(0, con, scale);
2162   register_new_node(X, pre_ctrl);
2163 
2164   // When the absolute value of scale is greater than one, the integer
2165   // division may round limit down so add one to the limit.
2166   if (round_up) {
2167     X = new AddINode(X, _igvn.intcon(1));
2168     register_new_node(X, pre_ctrl);
2169   }
2170 
2171   // Adjust loop limit
2172   loop_limit = (stride_con &gt; 0)
2173                ? (Node*)(new MinINode(loop_limit, X))
2174                : (Node*)(new MaxINode(loop_limit, X));
2175   register_new_node(loop_limit, pre_ctrl);
2176   return loop_limit;
2177 }
2178 
2179 //------------------------------add_constraint---------------------------------
2180 // Constrain the main loop iterations so the conditions:
2181 //    low_limit &lt;= scale_con * I + offset  &lt;  upper_limit
2182 // always holds true.  That is, either increase the number of iterations in
2183 // the pre-loop or the post-loop until the condition holds true in the main
2184 // loop.  Stride, scale, offset and limit are all loop invariant.  Further,
2185 // stride and scale are constants (offset and limit often are).
<a name="130" id="anc130"></a><span class="line-modified">2186 void PhaseIdealLoop::add_constraint(int stride_con, int scale_con, Node *offset, Node *low_limit, Node *upper_limit, Node *pre_ctrl, Node **pre_limit, Node **main_limit) {</span>
2187   // For positive stride, the pre-loop limit always uses a MAX function
2188   // and the main loop a MIN function.  For negative stride these are
2189   // reversed.
2190 
2191   // Also for positive stride*scale the affine function is increasing, so the
2192   // pre-loop must check for underflow and the post-loop for overflow.
2193   // Negative stride*scale reverses this; pre-loop checks for overflow and
2194   // post-loop for underflow.
2195 
2196   Node *scale = _igvn.intcon(scale_con);
2197   set_ctrl(scale, C-&gt;root());
2198 
2199   if ((stride_con^scale_con) &gt;= 0) { // Use XOR to avoid overflow
2200     // The overflow limit: scale*I+offset &lt; upper_limit
2201     // For main-loop compute
2202     //   ( if (scale &gt; 0) /* and stride &gt; 0 */
2203     //       I &lt; (upper_limit-offset)/scale
2204     //     else /* scale &lt; 0 and stride &lt; 0 */
2205     //       I &gt; (upper_limit-offset)/scale
2206     //   )
2207     //
2208     // (upper_limit-offset) may overflow or underflow.
2209     // But it is fine since main loop will either have
2210     // less iterations or will be skipped in such case.
2211     *main_limit = adjust_limit(stride_con, scale, offset, upper_limit, *main_limit, pre_ctrl, false);
2212 
2213     // The underflow limit: low_limit &lt;= scale*I+offset.
2214     // For pre-loop compute
2215     //   NOT(scale*I+offset &gt;= low_limit)
2216     //   scale*I+offset &lt; low_limit
2217     //   ( if (scale &gt; 0) /* and stride &gt; 0 */
2218     //       I &lt; (low_limit-offset)/scale
2219     //     else /* scale &lt; 0 and stride &lt; 0 */
2220     //       I &gt; (low_limit-offset)/scale
2221     //   )
2222 
2223     if (low_limit-&gt;get_int() == -max_jint) {
2224       // We need this guard when scale*pre_limit+offset &gt;= limit
2225       // due to underflow. So we need execute pre-loop until
2226       // scale*I+offset &gt;= min_int. But (min_int-offset) will
2227       // underflow when offset &gt; 0 and X will be &gt; original_limit
2228       // when stride &gt; 0. To avoid it we replace positive offset with 0.
2229       //
2230       // Also (min_int+1 == -max_int) is used instead of min_int here
2231       // to avoid problem with scale == -1 (min_int/(-1) == min_int).
2232       Node* shift = _igvn.intcon(31);
2233       set_ctrl(shift, C-&gt;root());
2234       Node* sign = new RShiftINode(offset, shift);
2235       register_new_node(sign, pre_ctrl);
2236       offset = new AndINode(offset, sign);
2237       register_new_node(offset, pre_ctrl);
2238     } else {
2239       assert(low_limit-&gt;get_int() == 0, &quot;wrong low limit for range check&quot;);
2240       // The only problem we have here when offset == min_int
2241       // since (0-min_int) == min_int. It may be fine for stride &gt; 0
2242       // but for stride &lt; 0 X will be &lt; original_limit. To avoid it
2243       // max(pre_limit, original_limit) is used in do_range_check().
2244     }
2245     // Pass (-stride) to indicate pre_loop_cond = NOT(main_loop_cond);
2246     *pre_limit = adjust_limit((-stride_con), scale, offset, low_limit, *pre_limit, pre_ctrl,
2247                               scale_con &gt; 1 &amp;&amp; stride_con &gt; 0);
2248 
2249   } else { // stride_con*scale_con &lt; 0
2250     // For negative stride*scale pre-loop checks for overflow and
2251     // post-loop for underflow.
2252     //
2253     // The overflow limit: scale*I+offset &lt; upper_limit
2254     // For pre-loop compute
2255     //   NOT(scale*I+offset &lt; upper_limit)
2256     //   scale*I+offset &gt;= upper_limit
2257     //   scale*I+offset+1 &gt; upper_limit
2258     //   ( if (scale &lt; 0) /* and stride &gt; 0 */
2259     //       I &lt; (upper_limit-(offset+1))/scale
2260     //     else /* scale &gt; 0 and stride &lt; 0 */
2261     //       I &gt; (upper_limit-(offset+1))/scale
2262     //   )
2263     //
2264     // (upper_limit-offset-1) may underflow or overflow.
2265     // To avoid it min(pre_limit, original_limit) is used
2266     // in do_range_check() for stride &gt; 0 and max() for &lt; 0.
2267     Node *one  = _igvn.intcon(1);
2268     set_ctrl(one, C-&gt;root());
2269 
2270     Node *plus_one = new AddINode(offset, one);
<a name="131" id="anc131"></a><span class="line-modified">2271     register_new_node(plus_one, pre_ctrl);</span>
2272     // Pass (-stride) to indicate pre_loop_cond = NOT(main_loop_cond);
2273     *pre_limit = adjust_limit((-stride_con), scale, plus_one, upper_limit, *pre_limit, pre_ctrl,
2274                               scale_con &lt; -1 &amp;&amp; stride_con &gt; 0);
2275 
2276     if (low_limit-&gt;get_int() == -max_jint) {
2277       // We need this guard when scale*main_limit+offset &gt;= limit
2278       // due to underflow. So we need execute main-loop while
2279       // scale*I+offset+1 &gt; min_int. But (min_int-offset-1) will
2280       // underflow when (offset+1) &gt; 0 and X will be &lt; main_limit
2281       // when scale &lt; 0 (and stride &gt; 0). To avoid it we replace
2282       // positive (offset+1) with 0.
2283       //
2284       // Also (min_int+1 == -max_int) is used instead of min_int here
2285       // to avoid problem with scale == -1 (min_int/(-1) == min_int).
2286       Node* shift = _igvn.intcon(31);
2287       set_ctrl(shift, C-&gt;root());
2288       Node* sign = new RShiftINode(plus_one, shift);
2289       register_new_node(sign, pre_ctrl);
2290       plus_one = new AndINode(plus_one, sign);
2291       register_new_node(plus_one, pre_ctrl);
2292     } else {
2293       assert(low_limit-&gt;get_int() == 0, &quot;wrong low limit for range check&quot;);
2294       // The only problem we have here when offset == max_int
2295       // since (max_int+1) == min_int and (0-min_int) == min_int.
2296       // But it is fine since main loop will either have
2297       // less iterations or will be skipped in such case.
2298     }
2299     // The underflow limit: low_limit &lt;= scale*I+offset.
2300     // For main-loop compute
2301     //   scale*I+offset+1 &gt; low_limit
2302     //   ( if (scale &lt; 0) /* and stride &gt; 0 */
2303     //       I &lt; (low_limit-(offset+1))/scale
2304     //     else /* scale &gt; 0 and stride &lt; 0 */
2305     //       I &gt; (low_limit-(offset+1))/scale
2306     //   )
2307 
2308     *main_limit = adjust_limit(stride_con, scale, plus_one, low_limit, *main_limit, pre_ctrl,
2309                                false);
2310   }
2311 }
2312 
2313 
2314 //------------------------------is_scaled_iv---------------------------------
2315 // Return true if exp is a constant times an induction var
2316 bool PhaseIdealLoop::is_scaled_iv(Node* exp, Node* iv, int* p_scale) {
2317   if (exp == iv) {
2318     if (p_scale != NULL) {
2319       *p_scale = 1;
2320     }
2321     return true;
2322   }
2323   int opc = exp-&gt;Opcode();
2324   if (opc == Op_MulI) {
2325     if (exp-&gt;in(1) == iv &amp;&amp; exp-&gt;in(2)-&gt;is_Con()) {
2326       if (p_scale != NULL) {
2327         *p_scale = exp-&gt;in(2)-&gt;get_int();
2328       }
2329       return true;
2330     }
2331     if (exp-&gt;in(2) == iv &amp;&amp; exp-&gt;in(1)-&gt;is_Con()) {
2332       if (p_scale != NULL) {
2333         *p_scale = exp-&gt;in(1)-&gt;get_int();
2334       }
2335       return true;
2336     }
2337   } else if (opc == Op_LShiftI) {
2338     if (exp-&gt;in(1) == iv &amp;&amp; exp-&gt;in(2)-&gt;is_Con()) {
2339       if (p_scale != NULL) {
2340         *p_scale = 1 &lt;&lt; exp-&gt;in(2)-&gt;get_int();
2341       }
2342       return true;
2343     }
2344   }
2345   return false;
2346 }
2347 
2348 //-----------------------------is_scaled_iv_plus_offset------------------------------
2349 // Return true if exp is a simple induction variable expression: k1*iv + (invar + k2)
2350 bool PhaseIdealLoop::is_scaled_iv_plus_offset(Node* exp, Node* iv, int* p_scale, Node** p_offset, int depth) {
2351   if (is_scaled_iv(exp, iv, p_scale)) {
2352     if (p_offset != NULL) {
2353       Node *zero = _igvn.intcon(0);
2354       set_ctrl(zero, C-&gt;root());
2355       *p_offset = zero;
2356     }
2357     return true;
2358   }
2359   int opc = exp-&gt;Opcode();
2360   if (opc == Op_AddI) {
2361     if (is_scaled_iv(exp-&gt;in(1), iv, p_scale)) {
2362       if (p_offset != NULL) {
2363         *p_offset = exp-&gt;in(2);
2364       }
2365       return true;
2366     }
2367     if (is_scaled_iv(exp-&gt;in(2), iv, p_scale)) {
2368       if (p_offset != NULL) {
2369         *p_offset = exp-&gt;in(1);
2370       }
2371       return true;
2372     }
2373     if (exp-&gt;in(2)-&gt;is_Con()) {
2374       Node* offset2 = NULL;
2375       if (depth &lt; 2 &amp;&amp;
2376           is_scaled_iv_plus_offset(exp-&gt;in(1), iv, p_scale,
2377                                    p_offset != NULL ? &amp;offset2 : NULL, depth+1)) {
2378         if (p_offset != NULL) {
2379           Node *ctrl_off2 = get_ctrl(offset2);
2380           Node* offset = new AddINode(offset2, exp-&gt;in(2));
2381           register_new_node(offset, ctrl_off2);
2382           *p_offset = offset;
2383         }
2384         return true;
2385       }
2386     }
2387   } else if (opc == Op_SubI) {
2388     if (is_scaled_iv(exp-&gt;in(1), iv, p_scale)) {
2389       if (p_offset != NULL) {
2390         Node *zero = _igvn.intcon(0);
2391         set_ctrl(zero, C-&gt;root());
2392         Node *ctrl_off = get_ctrl(exp-&gt;in(2));
2393         Node* offset = new SubINode(zero, exp-&gt;in(2));
2394         register_new_node(offset, ctrl_off);
2395         *p_offset = offset;
2396       }
2397       return true;
2398     }
2399     if (is_scaled_iv(exp-&gt;in(2), iv, p_scale)) {
2400       if (p_offset != NULL) {
2401         *p_scale *= -1;
2402         *p_offset = exp-&gt;in(1);
2403       }
2404       return true;
2405     }
2406   }
2407   return false;
2408 }
2409 
2410 // Same as PhaseIdealLoop::duplicate_predicates() but for range checks
2411 // eliminated by iteration splitting.
2412 Node* PhaseIdealLoop::add_range_check_predicate(IdealLoopTree* loop, CountedLoopNode* cl,
2413                                                 Node* predicate_proj, int scale_con, Node* offset,
2414                                                 Node* limit, jint stride_con, Node* value) {
2415   bool overflow = false;
2416   BoolNode* bol = rc_predicate(loop, predicate_proj, scale_con, offset, value, NULL, stride_con, limit, (stride_con &gt; 0) != (scale_con &gt; 0), overflow);
2417   Node* opaque_bol = new Opaque4Node(C, bol, _igvn.intcon(1));
2418   register_new_node(opaque_bol, predicate_proj);
2419   IfNode* new_iff = NULL;
2420   if (overflow) {
2421     new_iff = new IfNode(predicate_proj, opaque_bol, PROB_MAX, COUNT_UNKNOWN);
2422   } else {
2423     new_iff = new RangeCheckNode(predicate_proj, opaque_bol, PROB_MAX, COUNT_UNKNOWN);
2424   }
2425   register_control(new_iff, loop-&gt;_parent, predicate_proj);
2426   Node* iffalse = new IfFalseNode(new_iff);
2427   register_control(iffalse, _ltree_root, new_iff);
2428   ProjNode* iftrue = new IfTrueNode(new_iff);
2429   register_control(iftrue, loop-&gt;_parent, new_iff);
2430   Node *frame = new ParmNode(C-&gt;start(), TypeFunc::FramePtr);
2431   register_new_node(frame, C-&gt;start());
<a name="132" id="anc132"></a><span class="line-modified">2432   Node* halt = new HaltNode(iffalse, frame, &quot;range check predicate failed which is impossible&quot;);</span>
2433   register_control(halt, _ltree_root, iffalse);
2434   C-&gt;root()-&gt;add_req(halt);
2435   return iftrue;
2436 }
2437 
2438 //------------------------------do_range_check---------------------------------
2439 // Eliminate range-checks and other trip-counter vs loop-invariant tests.
<a name="133" id="anc133"></a><span class="line-modified">2440 int PhaseIdealLoop::do_range_check(IdealLoopTree *loop, Node_List &amp;old_new) {</span>
2441 #ifndef PRODUCT
2442   if (PrintOpto &amp;&amp; VerifyLoopOptimizations) {
2443     tty-&gt;print(&quot;Range Check Elimination &quot;);
2444     loop-&gt;dump_head();
2445   } else if (TraceLoopOpts) {
2446     tty-&gt;print(&quot;RangeCheck   &quot;);
2447     loop-&gt;dump_head();
2448   }
2449 #endif
<a name="134" id="anc134"></a><span class="line-added">2450 </span>
2451   assert(RangeCheckElimination, &quot;&quot;);
2452   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
2453   // If we fail before trying to eliminate range checks, set multiversion state
2454   int closed_range_checks = 1;
2455 
2456   // protect against stride not being a constant
<a name="135" id="anc135"></a><span class="line-modified">2457   if (!cl-&gt;stride_is_con()) {</span>
2458     return closed_range_checks;
<a name="136" id="anc136"></a><span class="line-modified">2459   }</span>
2460   // Find the trip counter; we are iteration splitting based on it
2461   Node *trip_counter = cl-&gt;phi();
2462   // Find the main loop limit; we will trim it&#39;s iterations
2463   // to not ever trip end tests
2464   Node *main_limit = cl-&gt;limit();
2465 
2466   // Check graph shape. Cannot optimize a loop if zero-trip
2467   // Opaque1 node is optimized away and then another round
2468   // of loop opts attempted.
2469   if (!is_canonical_loop_entry(cl)) {
2470     return closed_range_checks;
2471   }
2472 
2473   // Need to find the main-loop zero-trip guard
<a name="137" id="anc137"></a><span class="line-modified">2474   Node *ctrl = cl-&gt;skip_predicates();</span>
2475   Node *iffm = ctrl-&gt;in(0);
2476   Node *opqzm = iffm-&gt;in(1)-&gt;in(1)-&gt;in(2);
2477   assert(opqzm-&gt;in(1) == main_limit, &quot;do not understand situation&quot;);
2478 
2479   // Find the pre-loop limit; we will expand its iterations to
2480   // not ever trip low tests.
2481   Node *p_f = iffm-&gt;in(0);
2482   // pre loop may have been optimized out
2483   if (p_f-&gt;Opcode() != Op_IfFalse) {
2484     return closed_range_checks;
2485   }
2486   CountedLoopEndNode *pre_end = p_f-&gt;in(0)-&gt;as_CountedLoopEnd();
2487   assert(pre_end-&gt;loopnode()-&gt;is_pre_loop(), &quot;&quot;);
2488   Node *pre_opaq1 = pre_end-&gt;limit();
2489   // Occasionally it&#39;s possible for a pre-loop Opaque1 node to be
2490   // optimized away and then another round of loop opts attempted.
2491   // We can not optimize this particular loop in that case.
<a name="138" id="anc138"></a><span class="line-modified">2492   if (pre_opaq1-&gt;Opcode() != Op_Opaque1) {</span>
2493     return closed_range_checks;
<a name="139" id="anc139"></a><span class="line-added">2494   }</span>
2495   Opaque1Node *pre_opaq = (Opaque1Node*)pre_opaq1;
2496   Node *pre_limit = pre_opaq-&gt;in(1);
2497 
2498   // Where do we put new limit calculations
2499   Node *pre_ctrl = pre_end-&gt;loopnode()-&gt;in(LoopNode::EntryControl);
2500 
2501   // Ensure the original loop limit is available from the
2502   // pre-loop Opaque1 node.
2503   Node *orig_limit = pre_opaq-&gt;original_loop_limit();
<a name="140" id="anc140"></a><span class="line-modified">2504   if (orig_limit == NULL || _igvn.type(orig_limit) == Type::TOP) {</span>
2505     return closed_range_checks;
<a name="141" id="anc141"></a><span class="line-modified">2506   }</span>
2507   // Must know if its a count-up or count-down loop
2508 
2509   int stride_con = cl-&gt;stride_con();
2510   Node *zero = _igvn.intcon(0);
2511   Node *one  = _igvn.intcon(1);
2512   // Use symmetrical int range [-max_jint,max_jint]
2513   Node *mini = _igvn.intcon(-max_jint);
2514   set_ctrl(zero, C-&gt;root());
2515   set_ctrl(one,  C-&gt;root());
2516   set_ctrl(mini, C-&gt;root());
2517 
2518   // Range checks that do not dominate the loop backedge (ie.
2519   // conditionally executed) can lengthen the pre loop limit beyond
2520   // the original loop limit. To prevent this, the pre limit is
2521   // (for stride &gt; 0) MINed with the original loop limit (MAXed
2522   // stride &lt; 0) when some range_check (rc) is conditionally
2523   // executed.
2524   bool conditional_rc = false;
2525 
2526   // Count number of range checks and reduce by load range limits, if zero,
2527   // the loop is in canonical form to multiversion.
2528   closed_range_checks = 0;
2529 
2530   Node* predicate_proj = cl-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
2531   assert(predicate_proj-&gt;is_Proj() &amp;&amp; predicate_proj-&gt;in(0)-&gt;is_If(), &quot;if projection only&quot;);
<a name="142" id="anc142"></a><span class="line-added">2532 </span>
2533   // Check loop body for tests of trip-counter plus loop-invariant vs loop-variant.
<a name="143" id="anc143"></a><span class="line-modified">2534   for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {</span>
2535     Node *iff = loop-&gt;_body[i];
2536     if (iff-&gt;Opcode() == Op_If ||
2537         iff-&gt;Opcode() == Op_RangeCheck) { // Test?
2538       // Test is an IfNode, has 2 projections.  If BOTH are in the loop
2539       // we need loop unswitching instead of iteration splitting.
2540       closed_range_checks++;
2541       Node *exit = loop-&gt;is_loop_exit(iff);
<a name="144" id="anc144"></a><span class="line-modified">2542       if (!exit) continue;</span>
2543       int flip = (exit-&gt;Opcode() == Op_IfTrue) ? 1 : 0;
2544 
2545       // Get boolean condition to test
2546       Node *i1 = iff-&gt;in(1);
<a name="145" id="anc145"></a><span class="line-modified">2547       if (!i1-&gt;is_Bool()) continue;</span>
2548       BoolNode *bol = i1-&gt;as_Bool();
2549       BoolTest b_test = bol-&gt;_test;
2550       // Flip sense of test if exit condition is flipped
<a name="146" id="anc146"></a><span class="line-modified">2551       if (flip) {</span>
2552         b_test = b_test.negate();
<a name="147" id="anc147"></a><span class="line-modified">2553       }</span>
2554       // Get compare
2555       Node *cmp = bol-&gt;in(1);
2556 
2557       // Look for trip_counter + offset vs limit
2558       Node *rc_exp = cmp-&gt;in(1);
2559       Node *limit  = cmp-&gt;in(2);
2560       int scale_con= 1;        // Assume trip counter not scaled
2561 
2562       Node *limit_c = get_ctrl(limit);
<a name="148" id="anc148"></a><span class="line-modified">2563       if (loop-&gt;is_member(get_loop(limit_c))) {</span>
2564         // Compare might have operands swapped; commute them
2565         b_test = b_test.commute();
2566         rc_exp = cmp-&gt;in(2);
2567         limit  = cmp-&gt;in(1);
2568         limit_c = get_ctrl(limit);
<a name="149" id="anc149"></a><span class="line-modified">2569         if (loop-&gt;is_member(get_loop(limit_c))) {</span>
2570           continue;             // Both inputs are loop varying; cannot RCE
<a name="150" id="anc150"></a><span class="line-added">2571         }</span>
2572       }
2573       // Here we know &#39;limit&#39; is loop invariant
2574 
2575       // &#39;limit&#39; maybe pinned below the zero trip test (probably from a
2576       // previous round of rce), in which case, it can&#39;t be used in the
2577       // zero trip test expression which must occur before the zero test&#39;s if.
2578       if (is_dominator(ctrl, limit_c)) {
2579         continue;  // Don&#39;t rce this check but continue looking for other candidates.
2580       }
2581 
2582       // Check for scaled induction variable plus an offset
2583       Node *offset = NULL;
2584 
2585       if (!is_scaled_iv_plus_offset(rc_exp, trip_counter, &amp;scale_con, &amp;offset)) {
2586         continue;
2587       }
2588 
2589       Node *offset_c = get_ctrl(offset);
<a name="151" id="anc151"></a><span class="line-modified">2590       if (loop-&gt;is_member(get_loop(offset_c))) {</span>
2591         continue;               // Offset is not really loop invariant
<a name="152" id="anc152"></a><span class="line-added">2592       }</span>
2593       // Here we know &#39;offset&#39; is loop invariant.
2594 
2595       // As above for the &#39;limit&#39;, the &#39;offset&#39; maybe pinned below the
2596       // zero trip test.
2597       if (is_dominator(ctrl, offset_c)) {
2598         continue; // Don&#39;t rce this check but continue looking for other candidates.
2599       }
2600 #ifdef ASSERT
2601       if (TraceRangeLimitCheck) {
2602         tty-&gt;print_cr(&quot;RC bool node%s&quot;, flip ? &quot; flipped:&quot; : &quot;:&quot;);
2603         bol-&gt;dump(2);
2604       }
2605 #endif
2606       // At this point we have the expression as:
2607       //   scale_con * trip_counter + offset :: limit
2608       // where scale_con, offset and limit are loop invariant.  Trip_counter
2609       // monotonically increases by stride_con, a constant.  Both (or either)
2610       // stride_con and scale_con can be negative which will flip about the
2611       // sense of the test.
2612 
2613       // Adjust pre and main loop limits to guard the correct iteration set
<a name="153" id="anc153"></a><span class="line-modified">2614       if (cmp-&gt;Opcode() == Op_CmpU) { // Unsigned compare is really 2 tests</span>
<span class="line-modified">2615         if (b_test._test == BoolTest::lt) { // Range checks always use lt</span>
2616           // The underflow and overflow limits: 0 &lt;= scale*I+offset &lt; limit
<a name="154" id="anc154"></a><span class="line-modified">2617           add_constraint(stride_con, scale_con, offset, zero, limit, pre_ctrl, &amp;pre_limit, &amp;main_limit);</span>
2618           // (0-offset)/scale could be outside of loop iterations range.
2619           conditional_rc = true;
2620           Node* init = cl-&gt;init_trip();
2621           Node* opaque_init = new Opaque1Node(C, init);
2622           register_new_node(opaque_init, predicate_proj);
2623           // template predicate so it can be updated on next unrolling
2624           predicate_proj = add_range_check_predicate(loop, cl, predicate_proj, scale_con, offset, limit, stride_con, opaque_init);
2625           assert(skeleton_predicate_has_opaque(predicate_proj-&gt;in(0)-&gt;as_If()), &quot;unexpected&quot;);
2626           // predicate on first value of first iteration
2627           predicate_proj = add_range_check_predicate(loop, cl, predicate_proj, scale_con, offset, limit, stride_con, init);
2628           assert(!skeleton_predicate_has_opaque(predicate_proj-&gt;in(0)-&gt;as_If()), &quot;unexpected&quot;);
2629           int init_inc = stride_con/cl-&gt;unrolled_count();
2630           assert(init_inc != 0, &quot;invalid loop increment&quot;);
2631           Node* max_value = _igvn.intcon(stride_con - init_inc);
2632           max_value = new AddINode(init, max_value);
2633           register_new_node(max_value, predicate_proj);
2634           // predicate on last value of first iteration (in case unrolling has already happened)
2635           predicate_proj = add_range_check_predicate(loop, cl, predicate_proj, scale_con, offset, limit, stride_con, max_value);
2636           assert(!skeleton_predicate_has_opaque(predicate_proj-&gt;in(0)-&gt;as_If()), &quot;unexpected&quot;);
2637         } else {
2638           if (PrintOpto) {
2639             tty-&gt;print_cr(&quot;missed RCE opportunity&quot;);
2640           }
2641           continue;             // In release mode, ignore it
2642         }
2643       } else {                  // Otherwise work on normal compares
<a name="155" id="anc155"></a><span class="line-modified">2644         switch(b_test._test) {</span>
2645         case BoolTest::gt:
2646           // Fall into GE case
2647         case BoolTest::ge:
2648           // Convert (I*scale+offset) &gt;= Limit to (I*(-scale)+(-offset)) &lt;= -Limit
2649           scale_con = -scale_con;
<a name="156" id="anc156"></a><span class="line-modified">2650           offset = new SubINode(zero, offset);</span>
<span class="line-modified">2651           register_new_node(offset, pre_ctrl);</span>
<span class="line-modified">2652           limit  = new SubINode(zero, limit);</span>
<span class="line-modified">2653           register_new_node(limit, pre_ctrl);</span>
2654           // Fall into LE case
2655         case BoolTest::le:
2656           if (b_test._test != BoolTest::gt) {
2657             // Convert X &lt;= Y to X &lt; Y+1
<a name="157" id="anc157"></a><span class="line-modified">2658             limit = new AddINode(limit, one);</span>
<span class="line-modified">2659             register_new_node(limit, pre_ctrl);</span>
2660           }
2661           // Fall into LT case
2662         case BoolTest::lt:
2663           // The underflow and overflow limits: MIN_INT &lt;= scale*I+offset &lt; limit
2664           // Note: (MIN_INT+1 == -MAX_INT) is used instead of MIN_INT here
2665           // to avoid problem with scale == -1: MIN_INT/(-1) == MIN_INT.
<a name="158" id="anc158"></a><span class="line-modified">2666           add_constraint(stride_con, scale_con, offset, mini, limit, pre_ctrl, &amp;pre_limit, &amp;main_limit);</span>
2667           // ((MIN_INT+1)-offset)/scale could be outside of loop iterations range.
2668           // Note: negative offset is replaced with 0 but (MIN_INT+1)/scale could
2669           // still be outside of loop range.
2670           conditional_rc = true;
2671           break;
2672         default:
2673           if (PrintOpto) {
2674             tty-&gt;print_cr(&quot;missed RCE opportunity&quot;);
2675           }
2676           continue;             // Unhandled case
2677         }
2678       }
2679 
2680       // Kill the eliminated test
2681       C-&gt;set_major_progress();
<a name="159" id="anc159"></a><span class="line-modified">2682       Node *kill_con = _igvn.intcon(1-flip);</span>
2683       set_ctrl(kill_con, C-&gt;root());
2684       _igvn.replace_input_of(iff, 1, kill_con);
2685       // Find surviving projection
2686       assert(iff-&gt;is_If(), &quot;&quot;);
2687       ProjNode* dp = ((IfNode*)iff)-&gt;proj_out(1-flip);
2688       // Find loads off the surviving projection; remove their control edge
2689       for (DUIterator_Fast imax, i = dp-&gt;fast_outs(imax); i &lt; imax; i++) {
2690         Node* cd = dp-&gt;fast_out(i); // Control-dependent node
2691         if (cd-&gt;is_Load() &amp;&amp; cd-&gt;depends_only_on_test()) {   // Loads can now float around in the loop
2692           // Allow the load to float around in the loop, or before it
2693           // but NOT before the pre-loop.
2694           _igvn.replace_input_of(cd, 0, ctrl); // ctrl, not NULL
2695           --i;
2696           --imax;
2697         }
2698       }
2699       if (limit-&gt;Opcode() == Op_LoadRange) {
2700         closed_range_checks--;
2701       }
<a name="160" id="anc160"></a>
2702     } // End of is IF
<a name="161" id="anc161"></a>
2703   }
2704   if (predicate_proj != cl-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl)) {
2705     _igvn.replace_input_of(cl-&gt;skip_strip_mined(), LoopNode::EntryControl, predicate_proj);
2706     set_idom(cl-&gt;skip_strip_mined(), predicate_proj, dom_depth(cl-&gt;skip_strip_mined()));
2707   }
2708 
2709   // Update loop limits
2710   if (conditional_rc) {
2711     pre_limit = (stride_con &gt; 0) ? (Node*)new MinINode(pre_limit, orig_limit)
2712                                  : (Node*)new MaxINode(pre_limit, orig_limit);
2713     register_new_node(pre_limit, pre_ctrl);
2714   }
2715   _igvn.replace_input_of(pre_opaq, 1, pre_limit);
2716 
2717   // Note:: we are making the main loop limit no longer precise;
2718   // need to round up based on stride.
2719   cl-&gt;set_nonexact_trip_count();
2720   Node *main_cle = cl-&gt;loopexit();
2721   Node *main_bol = main_cle-&gt;in(1);
2722   // Hacking loop bounds; need private copies of exit test
<a name="162" id="anc162"></a><span class="line-modified">2723   if (main_bol-&gt;outcnt() &gt; 1) {     // BoolNode shared?</span>
<span class="line-modified">2724     main_bol = main_bol-&gt;clone();   // Clone a private BoolNode</span>
<span class="line-modified">2725     register_new_node(main_bol, main_cle-&gt;in(0));</span>
2726     _igvn.replace_input_of(main_cle, 1, main_bol);
2727   }
2728   Node *main_cmp = main_bol-&gt;in(1);
<a name="163" id="anc163"></a><span class="line-modified">2729   if (main_cmp-&gt;outcnt() &gt; 1) {     // CmpNode shared?</span>
<span class="line-modified">2730     main_cmp = main_cmp-&gt;clone();   // Clone a private CmpNode</span>
<span class="line-modified">2731     register_new_node(main_cmp, main_cle-&gt;in(0));</span>
2732     _igvn.replace_input_of(main_bol, 1, main_cmp);
2733   }
2734   // Hack the now-private loop bounds
2735   _igvn.replace_input_of(main_cmp, 2, main_limit);
2736   // The OpaqueNode is unshared by design
<a name="164" id="anc164"></a><span class="line-modified">2737   assert(opqzm-&gt;outcnt() == 1, &quot;cannot hack shared node&quot;);</span>
2738   _igvn.replace_input_of(opqzm, 1, main_limit);
2739 
2740   return closed_range_checks;
2741 }
2742 
2743 //------------------------------has_range_checks-------------------------------
2744 // Check to see if RCE cleaned the current loop of range-checks.
2745 void PhaseIdealLoop::has_range_checks(IdealLoopTree *loop) {
2746   assert(RangeCheckElimination, &quot;&quot;);
2747 
2748   // skip if not a counted loop
2749   if (!loop-&gt;is_counted()) return;
2750 
2751   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
2752 
2753   // skip this loop if it is already checked
2754   if (cl-&gt;has_been_range_checked()) return;
2755 
2756   // Now check for existence of range checks
2757   for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {
2758     Node *iff = loop-&gt;_body[i];
2759     int iff_opc = iff-&gt;Opcode();
2760     if (iff_opc == Op_If || iff_opc == Op_RangeCheck) {
2761       cl-&gt;mark_has_range_checks();
2762       break;
2763     }
2764   }
2765   cl-&gt;set_has_been_range_checked();
2766 }
2767 
2768 //-------------------------multi_version_post_loops----------------------------
2769 // Check the range checks that remain, if simple, use the bounds to guard
2770 // which version to a post loop we execute, one with range checks or one without
2771 bool PhaseIdealLoop::multi_version_post_loops(IdealLoopTree *rce_loop, IdealLoopTree *legacy_loop) {
2772   bool multi_version_succeeded = false;
2773   assert(RangeCheckElimination, &quot;&quot;);
2774   CountedLoopNode *legacy_cl = legacy_loop-&gt;_head-&gt;as_CountedLoop();
2775   assert(legacy_cl-&gt;is_post_loop(), &quot;&quot;);
2776 
2777   // Check for existence of range checks using the unique instance to make a guard with
2778   Unique_Node_List worklist;
2779   for (uint i = 0; i &lt; legacy_loop-&gt;_body.size(); i++) {
2780     Node *iff = legacy_loop-&gt;_body[i];
2781     int iff_opc = iff-&gt;Opcode();
2782     if (iff_opc == Op_If || iff_opc == Op_RangeCheck) {
2783       worklist.push(iff);
2784     }
2785   }
2786 
2787   // Find RCE&#39;d post loop so that we can stage its guard.
2788   if (!is_canonical_loop_entry(legacy_cl)) return multi_version_succeeded;
2789   Node* ctrl = legacy_cl-&gt;in(LoopNode::EntryControl);
2790   Node* iffm = ctrl-&gt;in(0);
2791 
2792   // Now we test that both the post loops are connected
2793   Node* post_loop_region = iffm-&gt;in(0);
2794   if (post_loop_region == NULL) return multi_version_succeeded;
2795   if (!post_loop_region-&gt;is_Region()) return multi_version_succeeded;
2796   Node* covering_region = post_loop_region-&gt;in(RegionNode::Control+1);
2797   if (covering_region == NULL) return multi_version_succeeded;
2798   if (!covering_region-&gt;is_Region()) return multi_version_succeeded;
2799   Node* p_f = covering_region-&gt;in(RegionNode::Control);
2800   if (p_f == NULL) return multi_version_succeeded;
2801   if (!p_f-&gt;is_IfFalse()) return multi_version_succeeded;
2802   if (!p_f-&gt;in(0)-&gt;is_CountedLoopEnd()) return multi_version_succeeded;
2803   CountedLoopEndNode* rce_loop_end = p_f-&gt;in(0)-&gt;as_CountedLoopEnd();
2804   if (rce_loop_end == NULL) return multi_version_succeeded;
2805   CountedLoopNode* rce_cl = rce_loop_end-&gt;loopnode();
2806   if (rce_cl == NULL || !rce_cl-&gt;is_post_loop()) return multi_version_succeeded;
2807   CountedLoopNode *known_rce_cl = rce_loop-&gt;_head-&gt;as_CountedLoop();
2808   if (rce_cl != known_rce_cl) return multi_version_succeeded;
2809 
2810   // Then we fetch the cover entry test
2811   ctrl = rce_cl-&gt;in(LoopNode::EntryControl);
2812   if (!ctrl-&gt;is_IfTrue() &amp;&amp; !ctrl-&gt;is_IfFalse()) return multi_version_succeeded;
2813 
2814 #ifndef PRODUCT
2815   if (TraceLoopOpts) {
2816     tty-&gt;print(&quot;PostMultiVersion\n&quot;);
2817     rce_loop-&gt;dump_head();
2818     legacy_loop-&gt;dump_head();
2819   }
2820 #endif
2821 
2822   // Now fetch the limit we want to compare against
2823   Node *limit = rce_cl-&gt;limit();
2824   bool first_time = true;
2825 
2826   // If we got this far, we identified the post loop which has been RCE&#39;d and
2827   // we have a work list.  Now we will try to transform the if guard to cause
2828   // the loop pair to be multi version executed with the determination left to runtime
2829   // or the optimizer if full information is known about the given arrays at compile time.
2830   Node *last_min = NULL;
2831   multi_version_succeeded = true;
2832   while (worklist.size()) {
2833     Node* rc_iffm = worklist.pop();
2834     if (rc_iffm-&gt;is_If()) {
2835       Node *rc_bolzm = rc_iffm-&gt;in(1);
2836       if (rc_bolzm-&gt;is_Bool()) {
2837         Node *rc_cmpzm = rc_bolzm-&gt;in(1);
2838         if (rc_cmpzm-&gt;is_Cmp()) {
2839           Node *rc_left = rc_cmpzm-&gt;in(2);
2840           if (rc_left-&gt;Opcode() != Op_LoadRange) {
2841             multi_version_succeeded = false;
2842             break;
2843           }
2844           if (first_time) {
2845             last_min = rc_left;
2846             first_time = false;
2847           } else {
2848             Node *cur_min = new MinINode(last_min, rc_left);
2849             last_min = cur_min;
2850             _igvn.register_new_node_with_optimizer(last_min);
2851           }
2852         }
2853       }
2854     }
2855   }
2856 
2857   // All we have to do is update the limit of the rce loop
2858   // with the min of our expression and the current limit.
2859   // We will use this expression to replace the current limit.
2860   if (last_min &amp;&amp; multi_version_succeeded) {
2861     Node *cur_min = new MinINode(last_min, limit);
2862     _igvn.register_new_node_with_optimizer(cur_min);
2863     Node *cmp_node = rce_loop_end-&gt;cmp_node();
2864     _igvn.replace_input_of(cmp_node, 2, cur_min);
2865     set_ctrl(cur_min, ctrl);
2866     set_loop(cur_min, rce_loop-&gt;_parent);
2867 
2868     legacy_cl-&gt;mark_is_multiversioned();
2869     rce_cl-&gt;mark_is_multiversioned();
2870     multi_version_succeeded = true;
2871 
2872     C-&gt;set_major_progress();
2873   }
2874 
2875   return multi_version_succeeded;
2876 }
2877 
2878 //-------------------------poison_rce_post_loop--------------------------------
2879 // Causes the rce&#39;d post loop to be optimized away if multiversioning fails
2880 void PhaseIdealLoop::poison_rce_post_loop(IdealLoopTree *rce_loop) {
2881   CountedLoopNode *rce_cl = rce_loop-&gt;_head-&gt;as_CountedLoop();
2882   Node* ctrl = rce_cl-&gt;in(LoopNode::EntryControl);
2883   if (ctrl-&gt;is_IfTrue() || ctrl-&gt;is_IfFalse()) {
2884     Node* iffm = ctrl-&gt;in(0);
2885     if (iffm-&gt;is_If()) {
2886       Node* cur_bool = iffm-&gt;in(1);
2887       if (cur_bool-&gt;is_Bool()) {
2888         Node* cur_cmp = cur_bool-&gt;in(1);
2889         if (cur_cmp-&gt;is_Cmp()) {
2890           BoolTest::mask new_test = BoolTest::gt;
2891           BoolNode *new_bool = new BoolNode(cur_cmp, new_test);
2892           _igvn.replace_node(cur_bool, new_bool);
2893           _igvn._worklist.push(new_bool);
2894           Node* left_op = cur_cmp-&gt;in(1);
2895           _igvn.replace_input_of(cur_cmp, 2, left_op);
2896           C-&gt;set_major_progress();
2897         }
2898       }
2899     }
2900   }
2901 }
2902 
2903 //------------------------------DCE_loop_body----------------------------------
2904 // Remove simplistic dead code from loop body
2905 void IdealLoopTree::DCE_loop_body() {
<a name="165" id="anc165"></a><span class="line-modified">2906   for (uint i = 0; i &lt; _body.size(); i++) {</span>
<span class="line-modified">2907     if (_body.at(i)-&gt;outcnt() == 0) {</span>
<span class="line-modified">2908       _body.map(i, _body.pop());</span>
<span class="line-added">2909       i--; // Ensure we revisit the updated index.</span>
<span class="line-added">2910     }</span>
<span class="line-added">2911   }</span>
2912 }
2913 
2914 
2915 //------------------------------adjust_loop_exit_prob--------------------------
2916 // Look for loop-exit tests with the 50/50 (or worse) guesses from the parsing stage.
2917 // Replace with a 1-in-10 exit guess.
<a name="166" id="anc166"></a><span class="line-modified">2918 void IdealLoopTree::adjust_loop_exit_prob(PhaseIdealLoop *phase) {</span>
2919   Node *test = tail();
<a name="167" id="anc167"></a><span class="line-modified">2920   while (test != _head) {</span>
2921     uint top = test-&gt;Opcode();
<a name="168" id="anc168"></a><span class="line-modified">2922     if (top == Op_IfTrue || top == Op_IfFalse) {</span>
2923       int test_con = ((ProjNode*)test)-&gt;_con;
2924       assert(top == (uint)(test_con? Op_IfTrue: Op_IfFalse), &quot;sanity&quot;);
2925       IfNode *iff = test-&gt;in(0)-&gt;as_If();
<a name="169" id="anc169"></a><span class="line-modified">2926       if (iff-&gt;outcnt() == 2) {         // Ignore dead tests</span>
2927         Node *bol = iff-&gt;in(1);
<a name="170" id="anc170"></a><span class="line-modified">2928         if (bol &amp;&amp; bol-&gt;req() &gt; 1 &amp;&amp; bol-&gt;in(1) &amp;&amp;</span>
<span class="line-modified">2929             ((bol-&gt;in(1)-&gt;Opcode() == Op_StorePConditional) ||</span>
<span class="line-modified">2930              (bol-&gt;in(1)-&gt;Opcode() == Op_StoreIConditional) ||</span>
<span class="line-modified">2931              (bol-&gt;in(1)-&gt;Opcode() == Op_StoreLConditional) ||</span>
<span class="line-modified">2932              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeB) ||</span>
<span class="line-modified">2933              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeS) ||</span>
<span class="line-modified">2934              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeI) ||</span>
<span class="line-modified">2935              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeL) ||</span>
<span class="line-modified">2936              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeP) ||</span>
<span class="line-modified">2937              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeN) ||</span>
<span class="line-modified">2938              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapB) ||</span>
<span class="line-modified">2939              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapS) ||</span>
<span class="line-modified">2940              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapI) ||</span>
<span class="line-modified">2941              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapL) ||</span>
<span class="line-modified">2942              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapP) ||</span>
<span class="line-modified">2943              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapN) ||</span>
<span class="line-modified">2944              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapB) ||</span>
<span class="line-modified">2945              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapS) ||</span>
<span class="line-modified">2946              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapI) ||</span>
<span class="line-modified">2947              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapL) ||</span>
<span class="line-modified">2948              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapP) ||</span>
<span class="line-modified">2949              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapN) ||</span>
<span class="line-modified">2950              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahCompareAndExchangeP) ||</span>
<span class="line-modified">2951              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahCompareAndExchangeN) ||</span>
<span class="line-modified">2952              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahWeakCompareAndSwapP) ||</span>
<span class="line-modified">2953              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahWeakCompareAndSwapN) ||</span>
<span class="line-modified">2954              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahCompareAndSwapP) ||</span>
<span class="line-modified">2955              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahCompareAndSwapN)))</span>
2956           return;               // Allocation loops RARELY take backedge
2957         // Find the OTHER exit path from the IF
2958         Node* ex = iff-&gt;proj_out(1-test_con);
2959         float p = iff-&gt;_prob;
<a name="171" id="anc171"></a><span class="line-modified">2960         if (!phase-&gt;is_member(this, ex) &amp;&amp; iff-&gt;_fcnt == COUNT_UNKNOWN) {</span>
<span class="line-modified">2961           if (top == Op_IfTrue) {</span>
<span class="line-modified">2962             if (p &lt; (PROB_FAIR + PROB_UNLIKELY_MAG(3))) {</span>
2963               iff-&gt;_prob = PROB_STATIC_FREQUENT;
2964             }
2965           } else {
<a name="172" id="anc172"></a><span class="line-modified">2966             if (p &gt; (PROB_FAIR - PROB_UNLIKELY_MAG(3))) {</span>
2967               iff-&gt;_prob = PROB_STATIC_INFREQUENT;
2968             }
2969           }
2970         }
2971       }
2972     }
2973     test = phase-&gt;idom(test);
2974   }
2975 }
2976 
2977 #ifdef ASSERT
<a name="173" id="anc173"></a><span class="line-modified">2978 static CountedLoopNode* locate_pre_from_main(CountedLoopNode* main_loop) {</span>
<span class="line-modified">2979   assert(!main_loop-&gt;is_main_no_pre_loop(), &quot;Does not have a pre loop&quot;);</span>
<span class="line-added">2980   Node* ctrl = main_loop-&gt;skip_predicates();</span>
2981   assert(ctrl-&gt;Opcode() == Op_IfTrue || ctrl-&gt;Opcode() == Op_IfFalse, &quot;&quot;);
<a name="174" id="anc174"></a><span class="line-modified">2982   Node* iffm = ctrl-&gt;in(0);</span>
2983   assert(iffm-&gt;Opcode() == Op_If, &quot;&quot;);
<a name="175" id="anc175"></a><span class="line-modified">2984   Node* p_f = iffm-&gt;in(0);</span>
2985   assert(p_f-&gt;Opcode() == Op_IfFalse, &quot;&quot;);
<a name="176" id="anc176"></a><span class="line-modified">2986   CountedLoopNode* pre_loop = p_f-&gt;in(0)-&gt;as_CountedLoopEnd()-&gt;loopnode();</span>
<span class="line-modified">2987   assert(pre_loop-&gt;is_pre_loop(), &quot;No pre loop found&quot;);</span>
<span class="line-modified">2988   return pre_loop;</span>
2989 }
2990 #endif
2991 
2992 // Remove the main and post loops and make the pre loop execute all
2993 // iterations. Useful when the pre loop is found empty.
2994 void IdealLoopTree::remove_main_post_loops(CountedLoopNode *cl, PhaseIdealLoop *phase) {
2995   CountedLoopEndNode* pre_end = cl-&gt;loopexit();
2996   Node* pre_cmp = pre_end-&gt;cmp_node();
2997   if (pre_cmp-&gt;in(2)-&gt;Opcode() != Op_Opaque1) {
2998     // Only safe to remove the main loop if the compiler optimized it
2999     // out based on an unknown number of iterations
3000     return;
3001   }
3002 
3003   // Can we find the main loop?
3004   if (_next == NULL) {
3005     return;
3006   }
3007 
3008   Node* next_head = _next-&gt;_head;
3009   if (!next_head-&gt;is_CountedLoop()) {
3010     return;
3011   }
3012 
3013   CountedLoopNode* main_head = next_head-&gt;as_CountedLoop();
<a name="177" id="anc177"></a><span class="line-modified">3014   if (!main_head-&gt;is_main_loop() || main_head-&gt;is_main_no_pre_loop()) {</span>
3015     return;
3016   }
3017 
3018   assert(locate_pre_from_main(main_head) == cl, &quot;bad main loop&quot;);
3019   Node* main_iff = main_head-&gt;skip_predicates()-&gt;in(0);
3020 
3021   // Remove the Opaque1Node of the pre loop and make it execute all iterations
3022   phase-&gt;_igvn.replace_input_of(pre_cmp, 2, pre_cmp-&gt;in(2)-&gt;in(2));
3023   // Remove the Opaque1Node of the main loop so it can be optimized out
3024   Node* main_cmp = main_iff-&gt;in(1)-&gt;in(1);
3025   assert(main_cmp-&gt;in(2)-&gt;Opcode() == Op_Opaque1, &quot;main loop has no opaque node?&quot;);
3026   phase-&gt;_igvn.replace_input_of(main_cmp, 2, main_cmp-&gt;in(2)-&gt;in(1));
3027 }
3028 
<a name="178" id="anc178"></a><span class="line-modified">3029 //------------------------------do_remove_empty_loop---------------------------</span>
<span class="line-modified">3030 // We always attempt remove empty loops.   The approach is to replace the trip</span>
<span class="line-modified">3031 // counter with the value it will have on the last iteration.  This will break</span>
<span class="line-modified">3032 // the loop.</span>
<span class="line-modified">3033 bool IdealLoopTree::do_remove_empty_loop(PhaseIdealLoop *phase) {</span>
3034   // Minimum size must be empty loop
<a name="179" id="anc179"></a><span class="line-modified">3035   if (_body.size() &gt; EMPTY_LOOP_SIZE) {</span>
3036     return false;
<a name="180" id="anc180"></a><span class="line-modified">3037   }</span>
<span class="line-modified">3038   if (!_head-&gt;is_CountedLoop()) {</span>
<span class="line-modified">3039     return false;   // Dead loop</span>
<span class="line-added">3040   }</span>
3041   CountedLoopNode *cl = _head-&gt;as_CountedLoop();
<a name="181" id="anc181"></a><span class="line-modified">3042   if (!cl-&gt;is_valid_counted_loop()) {</span>
<span class="line-modified">3043     return false;   // Malformed loop</span>
<span class="line-modified">3044   }</span>
<span class="line-modified">3045   if (!phase-&gt;is_member(this, phase-&gt;get_ctrl(cl-&gt;loopexit()-&gt;in(CountedLoopEndNode::TestValue)))) {</span>
<span class="line-modified">3046     return false;   // Infinite loop</span>
<span class="line-added">3047   }</span>
3048   if (cl-&gt;is_pre_loop()) {
<a name="182" id="anc182"></a><span class="line-modified">3049     // If the loop we are removing is a pre-loop then the main and post loop</span>
<span class="line-modified">3050     // can be removed as well.</span>
3051     remove_main_post_loops(cl, phase);
3052   }
3053 
3054 #ifdef ASSERT
3055   // Ensure only one phi which is the iv.
3056   Node* iv = NULL;
3057   for (DUIterator_Fast imax, i = cl-&gt;fast_outs(imax); i &lt; imax; i++) {
3058     Node* n = cl-&gt;fast_out(i);
3059     if (n-&gt;Opcode() == Op_Phi) {
<a name="183" id="anc183"></a><span class="line-modified">3060       assert(iv == NULL, &quot;Too many phis&quot;);</span>
3061       iv = n;
3062     }
3063   }
<a name="184" id="anc184"></a><span class="line-modified">3064   assert(iv == cl-&gt;phi(), &quot;Wrong phi&quot;);</span>
3065 #endif
3066 
3067   // main and post loops have explicitly created zero trip guard
3068   bool needs_guard = !cl-&gt;is_main_loop() &amp;&amp; !cl-&gt;is_post_loop();
3069   if (needs_guard) {
3070     // Skip guard if values not overlap.
3071     const TypeInt* init_t = phase-&gt;_igvn.type(cl-&gt;init_trip())-&gt;is_int();
3072     const TypeInt* limit_t = phase-&gt;_igvn.type(cl-&gt;limit())-&gt;is_int();
3073     int  stride_con = cl-&gt;stride_con();
3074     if (stride_con &gt; 0) {
3075       needs_guard = (init_t-&gt;_hi &gt;= limit_t-&gt;_lo);
3076     } else {
3077       needs_guard = (init_t-&gt;_lo &lt;= limit_t-&gt;_hi);
3078     }
3079   }
3080   if (needs_guard) {
3081     // Check for an obvious zero trip guard.
3082     Node* inctrl = PhaseIdealLoop::skip_all_loop_predicates(cl-&gt;skip_predicates());
3083     if (inctrl-&gt;Opcode() == Op_IfTrue || inctrl-&gt;Opcode() == Op_IfFalse) {
3084       bool maybe_swapped = (inctrl-&gt;Opcode() == Op_IfFalse);
3085       // The test should look like just the backedge of a CountedLoop
3086       Node* iff = inctrl-&gt;in(0);
3087       if (iff-&gt;is_If()) {
3088         Node* bol = iff-&gt;in(1);
3089         if (bol-&gt;is_Bool()) {
3090           BoolTest test = bol-&gt;as_Bool()-&gt;_test;
3091           if (maybe_swapped) {
3092             test._test = test.commute();
3093             test._test = test.negate();
3094           }
3095           if (test._test == cl-&gt;loopexit()-&gt;test_trip()) {
3096             Node* cmp = bol-&gt;in(1);
3097             int init_idx = maybe_swapped ? 2 : 1;
3098             int limit_idx = maybe_swapped ? 1 : 2;
3099             if (cmp-&gt;is_Cmp() &amp;&amp; cmp-&gt;in(init_idx) == cl-&gt;init_trip() &amp;&amp; cmp-&gt;in(limit_idx) == cl-&gt;limit()) {
3100               needs_guard = false;
3101             }
3102           }
3103         }
3104       }
3105     }
3106   }
3107 
3108 #ifndef PRODUCT
3109   if (PrintOpto) {
3110     tty-&gt;print(&quot;Removing empty loop with%s zero trip guard&quot;, needs_guard ? &quot;out&quot; : &quot;&quot;);
3111     this-&gt;dump_head();
3112   } else if (TraceLoopOpts) {
3113     tty-&gt;print(&quot;Empty with%s zero trip guard   &quot;, needs_guard ? &quot;out&quot; : &quot;&quot;);
3114     this-&gt;dump_head();
3115   }
3116 #endif
3117 
3118   if (needs_guard) {
3119     // Peel the loop to ensure there&#39;s a zero trip guard
3120     Node_List old_new;
3121     phase-&gt;do_peeling(this, old_new);
3122   }
3123 
3124   // Replace the phi at loop head with the final value of the last
3125   // iteration.  Then the CountedLoopEnd will collapse (backedge never
3126   // taken) and all loop-invariant uses of the exit values will be correct.
3127   Node *phi = cl-&gt;phi();
3128   Node *exact_limit = phase-&gt;exact_limit(this);
3129   if (exact_limit != cl-&gt;limit()) {
3130     // We also need to replace the original limit to collapse loop exit.
3131     Node* cmp = cl-&gt;loopexit()-&gt;cmp_node();
3132     assert(cl-&gt;limit() == cmp-&gt;in(2), &quot;sanity&quot;);
<a name="185" id="anc185"></a><span class="line-added">3133     // Duplicate cmp node if it has other users</span>
<span class="line-added">3134     if (cmp-&gt;outcnt() &gt; 1) {</span>
<span class="line-added">3135       cmp = cmp-&gt;clone();</span>
<span class="line-added">3136       cmp = phase-&gt;_igvn.register_new_node_with_optimizer(cmp);</span>
<span class="line-added">3137       BoolNode *bol = cl-&gt;loopexit()-&gt;in(CountedLoopEndNode::TestValue)-&gt;as_Bool();</span>
<span class="line-added">3138       phase-&gt;_igvn.replace_input_of(bol, 1, cmp); // put bol on worklist</span>
<span class="line-added">3139     }</span>
3140     phase-&gt;_igvn._worklist.push(cmp-&gt;in(2)); // put limit on worklist
3141     phase-&gt;_igvn.replace_input_of(cmp, 2, exact_limit); // put cmp on worklist
3142   }
3143   // Note: the final value after increment should not overflow since
3144   // counted loop has limit check predicate.
<a name="186" id="anc186"></a><span class="line-modified">3145   Node *final = new SubINode(exact_limit, cl-&gt;stride());</span>
3146   phase-&gt;register_new_node(final,cl-&gt;in(LoopNode::EntryControl));
3147   phase-&gt;_igvn.replace_node(phi,final);
3148   phase-&gt;C-&gt;set_major_progress();
3149   return true;
3150 }
3151 
<a name="187" id="anc187"></a><span class="line-modified">3152 //------------------------------do_one_iteration_loop--------------------------</span>
3153 // Convert one iteration loop into normal code.
<a name="188" id="anc188"></a><span class="line-modified">3154 bool IdealLoopTree::do_one_iteration_loop(PhaseIdealLoop *phase) {</span>
<span class="line-modified">3155   if (!_head-&gt;as_Loop()-&gt;is_valid_counted_loop()) {</span>
3156     return false; // Only for counted loop
<a name="189" id="anc189"></a><span class="line-modified">3157   }</span>
3158   CountedLoopNode *cl = _head-&gt;as_CountedLoop();
3159   if (!cl-&gt;has_exact_trip_count() || cl-&gt;trip_count() != 1) {
3160     return false;
3161   }
3162 
3163 #ifndef PRODUCT
<a name="190" id="anc190"></a><span class="line-modified">3164   if (TraceLoopOpts) {</span>
3165     tty-&gt;print(&quot;OneIteration &quot;);
3166     this-&gt;dump_head();
3167   }
3168 #endif
3169 
3170   Node *init_n = cl-&gt;init_trip();
3171 #ifdef ASSERT
3172   // Loop boundaries should be constant since trip count is exact.
3173   assert(init_n-&gt;get_int() + cl-&gt;stride_con() &gt;= cl-&gt;limit()-&gt;get_int(), &quot;should be one iteration&quot;);
3174 #endif
3175   // Replace the phi at loop head with the value of the init_trip.
3176   // Then the CountedLoopEnd will collapse (backedge will not be taken)
3177   // and all loop-invariant uses of the exit values will be correct.
3178   phase-&gt;_igvn.replace_node(cl-&gt;phi(), cl-&gt;init_trip());
3179   phase-&gt;C-&gt;set_major_progress();
3180   return true;
3181 }
3182 
3183 //=============================================================================
3184 //------------------------------iteration_split_impl---------------------------
<a name="191" id="anc191"></a><span class="line-modified">3185 bool IdealLoopTree::iteration_split_impl(PhaseIdealLoop *phase, Node_List &amp;old_new) {</span>
3186   // Compute loop trip count if possible.
3187   compute_trip_count(phase);
3188 
3189   // Convert one iteration loop into normal code.
<a name="192" id="anc192"></a><span class="line-modified">3190   if (do_one_iteration_loop(phase)) {</span>
3191     return true;
<a name="193" id="anc193"></a><span class="line-modified">3192   }</span>
3193   // Check and remove empty loops (spam micro-benchmarks)
<a name="194" id="anc194"></a><span class="line-modified">3194   if (do_remove_empty_loop(phase)) {</span>
3195     return true;  // Here we removed an empty loop
<a name="195" id="anc195"></a><span class="line-added">3196   }</span>
3197 
<a name="196" id="anc196"></a><span class="line-modified">3198   AutoNodeBudget node_budget(phase);</span>


3199 
3200   // Non-counted loops may be peeled; exactly 1 iteration is peeled.
3201   // This removes loop-invariant tests (usually null checks).
3202   if (!_head-&gt;is_CountedLoop()) { // Non-counted loop
3203     if (PartialPeelLoop &amp;&amp; phase-&gt;partial_peel(this, old_new)) {
3204       // Partial peel succeeded so terminate this round of loop opts
3205       return false;
3206     }
<a name="197" id="anc197"></a><span class="line-modified">3207     if (policy_peeling(phase)) {    // Should we peel?</span>
3208       if (PrintOpto) { tty-&gt;print_cr(&quot;should_peel&quot;); }
<a name="198" id="anc198"></a><span class="line-modified">3209       phase-&gt;do_peeling(this, old_new);</span>
<span class="line-modified">3210     } else if (policy_unswitching(phase)) {</span>
3211       phase-&gt;do_unswitching(this, old_new);
3212     }
3213     return true;
3214   }
3215   CountedLoopNode *cl = _head-&gt;as_CountedLoop();
3216 
3217   if (!cl-&gt;is_valid_counted_loop()) return true; // Ignore various kinds of broken loops
3218 
3219   // Do nothing special to pre- and post- loops
3220   if (cl-&gt;is_pre_loop() || cl-&gt;is_post_loop()) return true;
3221 
3222   // Compute loop trip count from profile data
3223   compute_profile_trip_cnt(phase);
3224 
3225   // Before attempting fancy unrolling, RCE or alignment, see if we want
3226   // to completely unroll this loop or do loop unswitching.
3227   if (cl-&gt;is_normal_loop()) {
<a name="199" id="anc199"></a><span class="line-modified">3228     if (policy_unswitching(phase)) {</span>
3229       phase-&gt;do_unswitching(this, old_new);
3230       return true;
3231     }
<a name="200" id="anc200"></a><span class="line-modified">3232     if (policy_maximally_unroll(phase)) {</span>

3233       // Here we did some unrolling and peeling.  Eventually we will
3234       // completely unroll this loop and it will no longer be a loop.
<a name="201" id="anc201"></a><span class="line-modified">3235       phase-&gt;do_maximally_unroll(this, old_new);</span>
3236       return true;
3237     }
3238   }
3239 
<a name="202" id="anc202"></a><span class="line-modified">3240   uint est_peeling = estimate_peeling(phase);</span>
<span class="line-modified">3241   bool should_peel = 0 &lt; est_peeling;</span>




3242 
3243   // Counted loops may be peeled, may need some iterations run up
3244   // front for RCE, and may want to align loop refs to a cache
3245   // line.  Thus we clone a full loop up front whose trip count is
3246   // at least 1 (if peeling), but may be several more.
3247 
3248   // The main loop will start cache-line aligned with at least 1
3249   // iteration of the unrolled body (zero-trip test required) and
3250   // will have some range checks removed.
3251 
3252   // A post-loop will finish any odd iterations (leftover after
3253   // unrolling), plus any needed for RCE purposes.
3254 
3255   bool should_unroll = policy_unroll(phase);
<a name="203" id="anc203"></a><span class="line-added">3256   bool should_rce    = policy_range_check(phase);</span>
<span class="line-added">3257   // TODO: Remove align -- not used.</span>
<span class="line-added">3258   bool should_align  = policy_align(phase);</span>
3259 
<a name="204" id="anc204"></a><span class="line-modified">3260   // If not RCE&#39;ing  (iteration splitting) or Aligning, then we  do not need a</span>
<span class="line-modified">3261   // pre-loop.  We may still need to peel an initial iteration but we will not</span>
<span class="line-modified">3262   // be needing an unknown number of pre-iterations.</span>




3263   //
<a name="205" id="anc205"></a><span class="line-modified">3264   // Basically, if may_rce_align reports FALSE first time through, we will not</span>
<span class="line-modified">3265   // be able to later do RCE or Aligning on this loop.</span>
3266   bool may_rce_align = !policy_peel_only(phase) || should_rce || should_align;
3267 
3268   // If we have any of these conditions (RCE, alignment, unrolling) met, then
3269   // we switch to the pre-/main-/post-loop model.  This model also covers
3270   // peeling.
3271   if (should_rce || should_align || should_unroll) {
<a name="206" id="anc206"></a><span class="line-modified">3272     if (cl-&gt;is_normal_loop()) { // Convert to &#39;pre/main/post&#39; loops</span>
<span class="line-modified">3273       uint estimate = est_loop_clone_sz(3);</span>
<span class="line-modified">3274       if (!phase-&gt;may_require_nodes(estimate)) {</span>
<span class="line-modified">3275         return false;</span>
<span class="line-modified">3276       }</span>
<span class="line-modified">3277       phase-&gt;insert_pre_post_loops(this, old_new, !may_rce_align);</span>
<span class="line-added">3278     }</span>
<span class="line-added">3279     // Adjust the pre- and main-loop limits to let the pre and  post loops run</span>
<span class="line-added">3280     // with full checks, but the main-loop with no checks.  Remove said checks</span>
<span class="line-added">3281     // from the main body.</span>
3282     if (should_rce) {
3283       if (phase-&gt;do_range_check(this, old_new) != 0) {
3284         cl-&gt;mark_has_range_checks();
3285       }
3286     } else if (PostLoopMultiversioning) {
3287       phase-&gt;has_range_checks(this);
3288     }
3289 
3290     if (should_unroll &amp;&amp; !should_peel &amp;&amp; PostLoopMultiversioning) {
3291       // Try to setup multiversioning on main loops before they are unrolled
3292       if (cl-&gt;is_main_loop() &amp;&amp; (cl-&gt;unrolled_count() == 1)) {
3293         phase-&gt;insert_scalar_rced_post_loop(this, old_new);
3294       }
3295     }
3296 
3297     // Double loop body for unrolling.  Adjust the minimum-trip test (will do
3298     // twice as many iterations as before) and the main body limit (only do
3299     // an even number of trips).  If we are peeling, we might enable some RCE
3300     // and we&#39;d rather unroll the post-RCE&#39;d loop SO... do not unroll if
3301     // peeling.
3302     if (should_unroll &amp;&amp; !should_peel) {
3303       if (SuperWordLoopUnrollAnalysis) {
3304         phase-&gt;insert_vector_post_loop(this, old_new);
3305       }
3306       phase-&gt;do_unroll(this, old_new, true);
3307     }
3308 
<a name="207" id="anc207"></a><span class="line-modified">3309     // Adjust the pre-loop limits to align the main body iterations.</span>
<span class="line-modified">3310     if (should_align) {</span>

3311       Unimplemented();
<a name="208" id="anc208"></a><span class="line-modified">3312     }</span>
3313   } else {                      // Else we have an unchanged counted loop
<a name="209" id="anc209"></a><span class="line-modified">3314     if (should_peel) {          // Might want to peel but do nothing else</span>
<span class="line-modified">3315       if (phase-&gt;may_require_nodes(est_peeling)) {</span>
<span class="line-added">3316         phase-&gt;do_peeling(this, old_new);</span>
<span class="line-added">3317       }</span>
<span class="line-added">3318     }</span>
3319   }
3320   return true;
3321 }
3322 
3323 
3324 //=============================================================================
3325 //------------------------------iteration_split--------------------------------
<a name="210" id="anc210"></a><span class="line-modified">3326 bool IdealLoopTree::iteration_split(PhaseIdealLoop* phase, Node_List &amp;old_new) {</span>
3327   // Recursively iteration split nested loops
<a name="211" id="anc211"></a><span class="line-modified">3328   if (_child &amp;&amp; !_child-&gt;iteration_split(phase, old_new)) {</span>
3329     return false;
<a name="212" id="anc212"></a><span class="line-added">3330   }</span>
3331 
3332   // Clean out prior deadwood
3333   DCE_loop_body();
3334 
<a name="213" id="anc213"></a>
3335   // Look for loop-exit tests with my 50/50 guesses from the Parsing stage.
3336   // Replace with a 1-in-10 exit guess.
<a name="214" id="anc214"></a><span class="line-modified">3337   if (!is_root() &amp;&amp; is_loop()) {</span>



3338     adjust_loop_exit_prob(phase);
3339   }
3340 
<a name="215" id="anc215"></a><span class="line-modified">3341   // Unrolling, RCE and peeling efforts, iff innermost loop.</span>
<span class="line-modified">3342   if (_allow_optimizations &amp;&amp; is_innermost()) {</span>



3343     if (!_has_call) {
<a name="216" id="anc216"></a><span class="line-modified">3344       if (!iteration_split_impl(phase, old_new)) {</span>
<span class="line-modified">3345         return false;</span>
<span class="line-modified">3346       }</span>
<span class="line-modified">3347     } else {</span>
<span class="line-modified">3348       AutoNodeBudget node_budget(phase);</span>
<span class="line-added">3349       if (policy_unswitching(phase)) {</span>
<span class="line-added">3350         phase-&gt;do_unswitching(this, old_new);</span>
<span class="line-added">3351       }</span>
3352     }
3353   }
3354 
3355   // Minor offset re-organization to remove loop-fallout uses of
3356   // trip counter when there was no major reshaping.
3357   phase-&gt;reorg_offsets(this);
3358 
<a name="217" id="anc217"></a><span class="line-modified">3359   if (_next &amp;&amp; !_next-&gt;iteration_split(phase, old_new)) {</span>
3360     return false;
<a name="218" id="anc218"></a><span class="line-added">3361   }</span>
3362   return true;
3363 }
3364 
3365 
3366 //=============================================================================
3367 // Process all the loops in the loop tree and replace any fill
3368 // patterns with an intrinsic version.
3369 bool PhaseIdealLoop::do_intrinsify_fill() {
3370   bool changed = false;
3371   for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {
3372     IdealLoopTree* lpt = iter.current();
3373     changed |= intrinsify_fill(lpt);
3374   }
3375   return changed;
3376 }
3377 
3378 
3379 // Examine an inner loop looking for a a single store of an invariant
3380 // value in a unit stride loop,
3381 bool PhaseIdealLoop::match_fill_loop(IdealLoopTree* lpt, Node*&amp; store, Node*&amp; store_value,
3382                                      Node*&amp; shift, Node*&amp; con) {
3383   const char* msg = NULL;
3384   Node* msg_node = NULL;
3385 
3386   store_value = NULL;
3387   con = NULL;
3388   shift = NULL;
3389 
3390   // Process the loop looking for stores.  If there are multiple
3391   // stores or extra control flow give at this point.
3392   CountedLoopNode* head = lpt-&gt;_head-&gt;as_CountedLoop();
3393   for (uint i = 0; msg == NULL &amp;&amp; i &lt; lpt-&gt;_body.size(); i++) {
3394     Node* n = lpt-&gt;_body.at(i);
3395     if (n-&gt;outcnt() == 0) continue; // Ignore dead
3396     if (n-&gt;is_Store()) {
3397       if (store != NULL) {
3398         msg = &quot;multiple stores&quot;;
3399         break;
3400       }
3401       int opc = n-&gt;Opcode();
3402       if (opc == Op_StoreP || opc == Op_StoreN || opc == Op_StoreNKlass || opc == Op_StoreCM) {
3403         msg = &quot;oop fills not handled&quot;;
3404         break;
3405       }
3406       Node* value = n-&gt;in(MemNode::ValueIn);
3407       if (!lpt-&gt;is_invariant(value)) {
3408         msg  = &quot;variant store value&quot;;
3409       } else if (!_igvn.type(n-&gt;in(MemNode::Address))-&gt;isa_aryptr()) {
3410         msg = &quot;not array address&quot;;
3411       }
3412       store = n;
3413       store_value = value;
3414     } else if (n-&gt;is_If() &amp;&amp; n != head-&gt;loopexit_or_null()) {
3415       msg = &quot;extra control flow&quot;;
3416       msg_node = n;
3417     }
3418   }
3419 
3420   if (store == NULL) {
3421     // No store in loop
3422     return false;
3423   }
3424 
3425   if (msg == NULL &amp;&amp; head-&gt;stride_con() != 1) {
3426     // could handle negative strides too
3427     if (head-&gt;stride_con() &lt; 0) {
3428       msg = &quot;negative stride&quot;;
3429     } else {
3430       msg = &quot;non-unit stride&quot;;
3431     }
3432   }
3433 
3434   if (msg == NULL &amp;&amp; !store-&gt;in(MemNode::Address)-&gt;is_AddP()) {
3435     msg = &quot;can&#39;t handle store address&quot;;
3436     msg_node = store-&gt;in(MemNode::Address);
3437   }
3438 
3439   if (msg == NULL &amp;&amp;
3440       (!store-&gt;in(MemNode::Memory)-&gt;is_Phi() ||
3441        store-&gt;in(MemNode::Memory)-&gt;in(LoopNode::LoopBackControl) != store)) {
3442     msg = &quot;store memory isn&#39;t proper phi&quot;;
3443     msg_node = store-&gt;in(MemNode::Memory);
3444   }
3445 
3446   // Make sure there is an appropriate fill routine
3447   BasicType t = store-&gt;as_Mem()-&gt;memory_type();
3448   const char* fill_name;
3449   if (msg == NULL &amp;&amp;
3450       StubRoutines::select_fill_function(t, false, fill_name) == NULL) {
3451     msg = &quot;unsupported store&quot;;
3452     msg_node = store;
3453   }
3454 
3455   if (msg != NULL) {
3456 #ifndef PRODUCT
3457     if (TraceOptimizeFill) {
3458       tty-&gt;print_cr(&quot;not fill intrinsic candidate: %s&quot;, msg);
3459       if (msg_node != NULL) msg_node-&gt;dump();
3460     }
3461 #endif
3462     return false;
3463   }
3464 
3465   // Make sure the address expression can be handled.  It should be
3466   // head-&gt;phi * elsize + con.  head-&gt;phi might have a ConvI2L(CastII()).
3467   Node* elements[4];
3468   Node* cast = NULL;
3469   Node* conv = NULL;
3470   bool found_index = false;
3471   int count = store-&gt;in(MemNode::Address)-&gt;as_AddP()-&gt;unpack_offsets(elements, ARRAY_SIZE(elements));
3472   for (int e = 0; e &lt; count; e++) {
3473     Node* n = elements[e];
3474     if (n-&gt;is_Con() &amp;&amp; con == NULL) {
3475       con = n;
3476     } else if (n-&gt;Opcode() == Op_LShiftX &amp;&amp; shift == NULL) {
3477       Node* value = n-&gt;in(1);
3478 #ifdef _LP64
3479       if (value-&gt;Opcode() == Op_ConvI2L) {
3480         conv = value;
3481         value = value-&gt;in(1);
3482       }
3483       if (value-&gt;Opcode() == Op_CastII &amp;&amp;
3484           value-&gt;as_CastII()-&gt;has_range_check()) {
3485         // Skip range check dependent CastII nodes
3486         cast = value;
3487         value = value-&gt;in(1);
3488       }
3489 #endif
3490       if (value != head-&gt;phi()) {
3491         msg = &quot;unhandled shift in address&quot;;
3492       } else {
3493         if (type2aelembytes(store-&gt;as_Mem()-&gt;memory_type(), true) != (1 &lt;&lt; n-&gt;in(2)-&gt;get_int())) {
3494           msg = &quot;scale doesn&#39;t match&quot;;
3495         } else {
3496           found_index = true;
3497           shift = n;
3498         }
3499       }
3500     } else if (n-&gt;Opcode() == Op_ConvI2L &amp;&amp; conv == NULL) {
3501       conv = n;
3502       n = n-&gt;in(1);
3503       if (n-&gt;Opcode() == Op_CastII &amp;&amp;
3504           n-&gt;as_CastII()-&gt;has_range_check()) {
3505         // Skip range check dependent CastII nodes
3506         cast = n;
3507         n = n-&gt;in(1);
3508       }
3509       if (n == head-&gt;phi()) {
3510         found_index = true;
3511       } else {
3512         msg = &quot;unhandled input to ConvI2L&quot;;
3513       }
3514     } else if (n == head-&gt;phi()) {
3515       // no shift, check below for allowed cases
3516       found_index = true;
3517     } else {
3518       msg = &quot;unhandled node in address&quot;;
3519       msg_node = n;
3520     }
3521   }
3522 
3523   if (count == -1) {
3524     msg = &quot;malformed address expression&quot;;
3525     msg_node = store;
3526   }
3527 
3528   if (!found_index) {
3529     msg = &quot;missing use of index&quot;;
3530   }
3531 
3532   // byte sized items won&#39;t have a shift
3533   if (msg == NULL &amp;&amp; shift == NULL &amp;&amp; t != T_BYTE &amp;&amp; t != T_BOOLEAN) {
3534     msg = &quot;can&#39;t find shift&quot;;
3535     msg_node = store;
3536   }
3537 
3538   if (msg != NULL) {
3539 #ifndef PRODUCT
3540     if (TraceOptimizeFill) {
3541       tty-&gt;print_cr(&quot;not fill intrinsic: %s&quot;, msg);
3542       if (msg_node != NULL) msg_node-&gt;dump();
3543     }
3544 #endif
3545     return false;
3546   }
3547 
3548   // No make sure all the other nodes in the loop can be handled
3549   VectorSet ok(Thread::current()-&gt;resource_area());
3550 
3551   // store related values are ok
3552   ok.set(store-&gt;_idx);
3553   ok.set(store-&gt;in(MemNode::Memory)-&gt;_idx);
3554 
3555   CountedLoopEndNode* loop_exit = head-&gt;loopexit();
3556 
3557   // Loop structure is ok
3558   ok.set(head-&gt;_idx);
3559   ok.set(loop_exit-&gt;_idx);
3560   ok.set(head-&gt;phi()-&gt;_idx);
3561   ok.set(head-&gt;incr()-&gt;_idx);
3562   ok.set(loop_exit-&gt;cmp_node()-&gt;_idx);
3563   ok.set(loop_exit-&gt;in(1)-&gt;_idx);
3564 
3565   // Address elements are ok
3566   if (con)   ok.set(con-&gt;_idx);
3567   if (shift) ok.set(shift-&gt;_idx);
3568   if (cast)  ok.set(cast-&gt;_idx);
3569   if (conv)  ok.set(conv-&gt;_idx);
3570 
3571   for (uint i = 0; msg == NULL &amp;&amp; i &lt; lpt-&gt;_body.size(); i++) {
3572     Node* n = lpt-&gt;_body.at(i);
3573     if (n-&gt;outcnt() == 0) continue; // Ignore dead
3574     if (ok.test(n-&gt;_idx)) continue;
3575     // Backedge projection is ok
3576     if (n-&gt;is_IfTrue() &amp;&amp; n-&gt;in(0) == loop_exit) continue;
3577     if (!n-&gt;is_AddP()) {
3578       msg = &quot;unhandled node&quot;;
3579       msg_node = n;
3580       break;
3581     }
3582   }
3583 
3584   // Make sure no unexpected values are used outside the loop
3585   for (uint i = 0; msg == NULL &amp;&amp; i &lt; lpt-&gt;_body.size(); i++) {
3586     Node* n = lpt-&gt;_body.at(i);
3587     // These values can be replaced with other nodes if they are used
3588     // outside the loop.
3589     if (n == store || n == loop_exit || n == head-&gt;incr() || n == store-&gt;in(MemNode::Memory)) continue;
3590     for (SimpleDUIterator iter(n); iter.has_next(); iter.next()) {
3591       Node* use = iter.get();
3592       if (!lpt-&gt;_body.contains(use)) {
3593         msg = &quot;node is used outside loop&quot;;
3594         // lpt-&gt;_body.dump();
3595         msg_node = n;
3596         break;
3597       }
3598     }
3599   }
3600 
3601 #ifdef ASSERT
3602   if (TraceOptimizeFill) {
3603     if (msg != NULL) {
3604       tty-&gt;print_cr(&quot;no fill intrinsic: %s&quot;, msg);
3605       if (msg_node != NULL) msg_node-&gt;dump();
3606     } else {
3607       tty-&gt;print_cr(&quot;fill intrinsic for:&quot;);
3608     }
3609     store-&gt;dump();
3610     if (Verbose) {
3611       lpt-&gt;_body.dump();
3612     }
3613   }
3614 #endif
3615 
3616   return msg == NULL;
3617 }
3618 
3619 
3620 
3621 bool PhaseIdealLoop::intrinsify_fill(IdealLoopTree* lpt) {
3622   // Only for counted inner loops
<a name="219" id="anc219"></a><span class="line-modified">3623   if (!lpt-&gt;is_counted() || !lpt-&gt;is_innermost()) {</span>
3624     return false;
3625   }
3626 
3627   // Must have constant stride
3628   CountedLoopNode* head = lpt-&gt;_head-&gt;as_CountedLoop();
3629   if (!head-&gt;is_valid_counted_loop() || !head-&gt;is_normal_loop()) {
3630     return false;
3631   }
3632 
3633   head-&gt;verify_strip_mined(1);
3634 
3635   // Check that the body only contains a store of a loop invariant
3636   // value that is indexed by the loop phi.
3637   Node* store = NULL;
3638   Node* store_value = NULL;
3639   Node* shift = NULL;
3640   Node* offset = NULL;
3641   if (!match_fill_loop(lpt, store, store_value, shift, offset)) {
3642     return false;
3643   }
3644 
3645   Node* exit = head-&gt;loopexit()-&gt;proj_out_or_null(0);
3646   if (exit == NULL) {
3647     return false;
3648   }
3649 
3650 #ifndef PRODUCT
3651   if (TraceLoopOpts) {
3652     tty-&gt;print(&quot;ArrayFill    &quot;);
3653     lpt-&gt;dump_head();
3654   }
3655 #endif
3656 
3657   // Now replace the whole loop body by a call to a fill routine that
3658   // covers the same region as the loop.
3659   Node* base = store-&gt;in(MemNode::Address)-&gt;as_AddP()-&gt;in(AddPNode::Base);
3660 
3661   // Build an expression for the beginning of the copy region
3662   Node* index = head-&gt;init_trip();
3663 #ifdef _LP64
3664   index = new ConvI2LNode(index);
3665   _igvn.register_new_node_with_optimizer(index);
3666 #endif
3667   if (shift != NULL) {
3668     // byte arrays don&#39;t require a shift but others do.
3669     index = new LShiftXNode(index, shift-&gt;in(2));
3670     _igvn.register_new_node_with_optimizer(index);
3671   }
3672   index = new AddPNode(base, base, index);
3673   _igvn.register_new_node_with_optimizer(index);
3674   Node* from = new AddPNode(base, index, offset);
3675   _igvn.register_new_node_with_optimizer(from);
3676   // Compute the number of elements to copy
3677   Node* len = new SubINode(head-&gt;limit(), head-&gt;init_trip());
3678   _igvn.register_new_node_with_optimizer(len);
3679 
3680   BasicType t = store-&gt;as_Mem()-&gt;memory_type();
3681   bool aligned = false;
3682   if (offset != NULL &amp;&amp; head-&gt;init_trip()-&gt;is_Con()) {
3683     int element_size = type2aelembytes(t);
3684     aligned = (offset-&gt;find_intptr_t_type()-&gt;get_con() + head-&gt;init_trip()-&gt;get_int() * element_size) % HeapWordSize == 0;
3685   }
3686 
3687   // Build a call to the fill routine
3688   const char* fill_name;
3689   address fill = StubRoutines::select_fill_function(t, aligned, fill_name);
3690   assert(fill != NULL, &quot;what?&quot;);
3691 
3692   // Convert float/double to int/long for fill routines
3693   if (t == T_FLOAT) {
3694     store_value = new MoveF2INode(store_value);
3695     _igvn.register_new_node_with_optimizer(store_value);
3696   } else if (t == T_DOUBLE) {
3697     store_value = new MoveD2LNode(store_value);
3698     _igvn.register_new_node_with_optimizer(store_value);
3699   }
3700 
3701   Node* mem_phi = store-&gt;in(MemNode::Memory);
3702   Node* result_ctrl;
3703   Node* result_mem;
3704   const TypeFunc* call_type = OptoRuntime::array_fill_Type();
3705   CallLeafNode *call = new CallLeafNoFPNode(call_type, fill,
3706                                             fill_name, TypeAryPtr::get_array_body_type(t));
3707   uint cnt = 0;
3708   call-&gt;init_req(TypeFunc::Parms + cnt++, from);
3709   call-&gt;init_req(TypeFunc::Parms + cnt++, store_value);
3710 #ifdef _LP64
3711   len = new ConvI2LNode(len);
3712   _igvn.register_new_node_with_optimizer(len);
3713 #endif
3714   call-&gt;init_req(TypeFunc::Parms + cnt++, len);
3715 #ifdef _LP64
3716   call-&gt;init_req(TypeFunc::Parms + cnt++, C-&gt;top());
3717 #endif
3718   call-&gt;init_req(TypeFunc::Control,   head-&gt;init_control());
3719   call-&gt;init_req(TypeFunc::I_O,       C-&gt;top());       // Does no I/O.
3720   call-&gt;init_req(TypeFunc::Memory,    mem_phi-&gt;in(LoopNode::EntryControl));
3721   call-&gt;init_req(TypeFunc::ReturnAdr, C-&gt;start()-&gt;proj_out_or_null(TypeFunc::ReturnAdr));
3722   call-&gt;init_req(TypeFunc::FramePtr,  C-&gt;start()-&gt;proj_out_or_null(TypeFunc::FramePtr));
3723   _igvn.register_new_node_with_optimizer(call);
3724   result_ctrl = new ProjNode(call,TypeFunc::Control);
3725   _igvn.register_new_node_with_optimizer(result_ctrl);
3726   result_mem = new ProjNode(call,TypeFunc::Memory);
3727   _igvn.register_new_node_with_optimizer(result_mem);
3728 
3729 /* Disable following optimization until proper fix (add missing checks).
3730 
3731   // If this fill is tightly coupled to an allocation and overwrites
3732   // the whole body, allow it to take over the zeroing.
3733   AllocateNode* alloc = AllocateNode::Ideal_allocation(base, this);
3734   if (alloc != NULL &amp;&amp; alloc-&gt;is_AllocateArray()) {
3735     Node* length = alloc-&gt;as_AllocateArray()-&gt;Ideal_length();
3736     if (head-&gt;limit() == length &amp;&amp;
3737         head-&gt;init_trip() == _igvn.intcon(0)) {
3738       if (TraceOptimizeFill) {
3739         tty-&gt;print_cr(&quot;Eliminated zeroing in allocation&quot;);
3740       }
3741       alloc-&gt;maybe_set_complete(&amp;_igvn);
3742     } else {
3743 #ifdef ASSERT
3744       if (TraceOptimizeFill) {
3745         tty-&gt;print_cr(&quot;filling array but bounds don&#39;t match&quot;);
3746         alloc-&gt;dump();
3747         head-&gt;init_trip()-&gt;dump();
3748         head-&gt;limit()-&gt;dump();
3749         length-&gt;dump();
3750       }
3751 #endif
3752     }
3753   }
3754 */
3755 
3756   if (head-&gt;is_strip_mined()) {
3757     // Inner strip mined loop goes away so get rid of outer strip
3758     // mined loop
3759     Node* outer_sfpt = head-&gt;outer_safepoint();
3760     Node* in = outer_sfpt-&gt;in(0);
3761     Node* outer_out = head-&gt;outer_loop_exit();
3762     lazy_replace(outer_out, in);
3763     _igvn.replace_input_of(outer_sfpt, 0, C-&gt;top());
3764   }
3765 
3766   // Redirect the old control and memory edges that are outside the loop.
3767   // Sometimes the memory phi of the head is used as the outgoing
3768   // state of the loop.  It&#39;s safe in this case to replace it with the
3769   // result_mem.
3770   _igvn.replace_node(store-&gt;in(MemNode::Memory), result_mem);
3771   lazy_replace(exit, result_ctrl);
3772   _igvn.replace_node(store, result_mem);
3773   // Any uses the increment outside of the loop become the loop limit.
3774   _igvn.replace_node(head-&gt;incr(), head-&gt;limit());
3775 
3776   // Disconnect the head from the loop.
3777   for (uint i = 0; i &lt; lpt-&gt;_body.size(); i++) {
3778     Node* n = lpt-&gt;_body.at(i);
3779     _igvn.replace_node(n, C-&gt;top());
3780   }
3781 
3782   return true;
3783 }
<a name="220" id="anc220"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="220" type="hidden" />
</body>
</html>
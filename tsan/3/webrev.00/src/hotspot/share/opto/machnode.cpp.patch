diff a/src/hotspot/share/opto/machnode.cpp b/src/hotspot/share/opto/machnode.cpp
--- a/src/hotspot/share/opto/machnode.cpp
+++ b/src/hotspot/share/opto/machnode.cpp
@@ -22,10 +22,12 @@
  *
  */
 
 #include "precompiled.hpp"
 #include "gc/shared/collectedHeap.hpp"
+#include "memory/universe.hpp"
+#include "oops/compressedOops.hpp"
 #include "opto/machnode.hpp"
 #include "opto/regalloc.hpp"
 #include "utilities/vmError.hpp"
 
 //=============================================================================
@@ -91,11 +93,11 @@
   return 5;
 }
 
 //------------------------------cmp--------------------------------------------
 // Print any per-operand special info
-uint MachOper::cmp( const MachOper &oper ) const {
+bool MachOper::cmp( const MachOper &oper ) const {
   ShouldNotCallThis();
   return opcode() == oper.opcode();
 }
 
 //------------------------------hash-------------------------------------------
@@ -104,11 +106,11 @@
   return _block_num;
 }
 
 //------------------------------cmp--------------------------------------------
 // Print any per-operand special info
-uint labelOper::cmp( const MachOper &oper ) const {
+bool labelOper::cmp( const MachOper &oper ) const {
   return (opcode() == oper.opcode()) && (_label == oper.label());
 }
 
 //------------------------------hash-------------------------------------------
 // Print any per-operand special info
@@ -116,11 +118,11 @@
   return (uint)_method;
 }
 
 //------------------------------cmp--------------------------------------------
 // Print any per-operand special info
-uint methodOper::cmp( const MachOper &oper ) const {
+bool methodOper::cmp( const MachOper &oper ) const {
   return (opcode() == oper.opcode()) && (_method == oper.method());
 }
 
 
 //=============================================================================
@@ -165,19 +167,19 @@
     sum += _opnds[i]->hash();
   return sum+Node::hash();
 }
 
 //-----------------------------cmp---------------------------------------------
-uint MachNode::cmp( const Node &node ) const {
+bool MachNode::cmp( const Node &node ) const {
   MachNode& n = *((Node&)node).as_Mach();
   uint no = num_opnds();
-  if( no != n.num_opnds() ) return 0;
-  if( rule() != n.rule() ) return 0;
+  if( no != n.num_opnds() ) return false;
+  if( rule() != n.rule() ) return false;
   for( uint i=0; i<no; i++ )    // All operands must match
     if( !_opnds[i]->cmp( *n._opnds[i] ) )
-      return 0;                 // mis-matched operands
-  return 1;                     // match
+      return false;             // mis-matched operands
+  return true;                  // match
 }
 
 // Return an equivalent instruction using memory for cisc_operand position
 MachNode *MachNode::cisc_version(int offset) {
   ShouldNotCallThis();
@@ -344,23 +346,23 @@
     // NULL base, any offset means any pointer whatever
     if (offset == Type::OffsetBot) {
       return TypePtr::BOTTOM;
     }
     // %%% make offset be intptr_t
-    assert(!Universe::heap()->is_in_reserved(cast_to_oop(offset)), "must be a raw ptr");
+    assert(!Universe::heap()->is_in(cast_to_oop(offset)), "must be a raw ptr");
     return TypeRawPtr::BOTTOM;
   }
 
   // base of -1 with no particular offset means all of memory
   if (base == NodeSentinel)  return TypePtr::BOTTOM;
 
   const Type* t = base->bottom_type();
-  if (t->isa_narrowoop() && Universe::narrow_oop_shift() == 0) {
+  if (t->isa_narrowoop() && CompressedOops::shift() == 0) {
     // 32-bit unscaled narrow oop can be the base of any address expression
     t = t->make_ptr();
   }
-  if (t->isa_narrowklass() && Universe::narrow_klass_shift() == 0) {
+  if (t->isa_narrowklass() && CompressedKlassPointers::shift() == 0) {
     // 32-bit unscaled narrow oop can be the base of any address expression
     t = t->make_ptr();
   }
   if (t->isa_intptr_t() && offset != 0 && offset != Type::OffsetBot) {
     // We cannot assert that the offset does not look oop-ish here.
@@ -383,14 +385,14 @@
   return tp->add_offset(offset);
 }
 
 
 //-----------------------------operand_index---------------------------------
-int MachNode::operand_index( uint operand ) const {
-  if( operand < 1 )  return -1;
+int MachNode::operand_index(uint operand) const {
+  if (operand < 1)  return -1;
   assert(operand < num_opnds(), "oob");
-  if( _opnds[operand]->num_edges() == 0 )  return -1;
+  if (_opnds[operand]->num_edges() == 0)  return -1;
 
   uint skipped   = oper_input_base(); // Sum of leaves skipped so far
   for (uint opcnt = 1; opcnt < operand; opcnt++) {
     uint num_edges = _opnds[opcnt]->num_edges(); // leaves for operand
     skipped += num_edges;
@@ -408,10 +410,24 @@
   }
   if (_opnds[opcnt] != oper) return -1;
   return skipped;
 }
 
+int MachNode::operand_index(Node* def) const {
+  uint skipped = oper_input_base(); // Sum of leaves skipped so far
+  for (uint opcnt = 1; opcnt < num_opnds(); opcnt++) {
+    uint num_edges = _opnds[opcnt]->num_edges(); // leaves for operand
+    for (uint i = 0; i < num_edges; i++) {
+      if (in(skipped + i) == def) {
+        return opcnt;
+      }
+    }
+    skipped += num_edges;
+  }
+  return -1;
+}
+
 //------------------------------peephole---------------------------------------
 // Apply peephole rule(s) to this instruction
 MachNode *MachNode::peephole(Block *block, int block_index, PhaseRegAlloc *ra_, int &deleted) {
   return NULL;
 }
@@ -649,11 +665,11 @@
 }
 
 
 //=============================================================================
 
-uint MachCallNode::cmp( const Node &n ) const
+bool MachCallNode::cmp( const Node &n ) const
 { return _tf == ((MachCallNode&)n)._tf; }
 const Type *MachCallNode::bottom_type() const { return tf()->range(); }
 const Type* MachCallNode::Value(PhaseGVN* phase) const { return tf()->range(); }
 
 #ifndef PRODUCT
@@ -705,11 +721,11 @@
   return *Compile::current()->matcher()->idealreg2debugmask[in(idx)->ideal_reg()];
 }
 
 //=============================================================================
 uint MachCallJavaNode::size_of() const { return sizeof(*this); }
-uint MachCallJavaNode::cmp( const Node &n ) const {
+bool MachCallJavaNode::cmp( const Node &n ) const {
   MachCallJavaNode &call = (MachCallJavaNode&)n;
   return MachCallNode::cmp(call) && _method->equals(call._method) &&
          _override_symbolic_info == call._override_symbolic_info;
 }
 #ifndef PRODUCT
@@ -743,11 +759,11 @@
   return *debugmask[in(idx)->ideal_reg()];
 }
 
 //=============================================================================
 uint MachCallStaticJavaNode::size_of() const { return sizeof(*this); }
-uint MachCallStaticJavaNode::cmp( const Node &n ) const {
+bool MachCallStaticJavaNode::cmp( const Node &n ) const {
   MachCallStaticJavaNode &call = (MachCallStaticJavaNode&)n;
   return MachCallJavaNode::cmp(call) && _name == call._name;
 }
 
 //----------------------------uncommon_trap_request----------------------------
@@ -789,11 +805,11 @@
   MachCallJavaNode::dump_spec(st);
 }
 #endif
 //=============================================================================
 uint MachCallRuntimeNode::size_of() const { return sizeof(*this); }
-uint MachCallRuntimeNode::cmp( const Node &n ) const {
+bool MachCallRuntimeNode::cmp( const Node &n ) const {
   MachCallRuntimeNode &call = (MachCallRuntimeNode&)n;
   return MachCallNode::cmp(call) && !strcmp(_name,call._name);
 }
 #ifndef PRODUCT
 void MachCallRuntimeNode::dump_spec(outputStream *st) const {

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/live.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="library_call.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="locknode.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/live.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 67   if (_keep_deltas) {
 68     _livein = (IndexSet*)_arena-&gt;Amalloc(sizeof(IndexSet) * _cfg.number_of_blocks());
 69     for (i = 0; i &lt; _cfg.number_of_blocks(); i++) {
 70       _livein[i].initialize(_maxlrg);
 71     }
 72   }
 73 
 74   // Init the sparse arrays for delta-sets.
 75   ResourceMark rm;              // Nuke temp storage on exit
 76 
 77   // Does the memory used by _defs and _deltas get reclaimed?  Does it matter?  TT
 78 
 79   // Array of values defined locally in blocks
 80   _defs = NEW_RESOURCE_ARRAY(IndexSet,_cfg.number_of_blocks());
 81   for (i = 0; i &lt; _cfg.number_of_blocks(); i++) {
 82     _defs[i].initialize(_maxlrg);
 83   }
 84 
 85   // Array of delta-set pointers, indexed by block pre_order-1.
 86   _deltas = NEW_RESOURCE_ARRAY(IndexSet*,_cfg.number_of_blocks());
<span class="line-modified"> 87   memset( _deltas, 0, sizeof(IndexSet*)* _cfg.number_of_blocks());</span>
 88 
 89   _free_IndexSet = NULL;
 90 
 91   // Blocks having done pass-1
 92   VectorSet first_pass(Thread::current()-&gt;resource_area());
 93 
 94   // Outer loop: must compute local live-in sets and push into predecessors.
 95   for (uint j = _cfg.number_of_blocks(); j &gt; 0; j--) {
 96     Block* block = _cfg.get_block(j - 1);
 97 
 98     // Compute the local live-in set.  Start with any new live-out bits.
 99     IndexSet* use = getset(block);
100     IndexSet* def = &amp;_defs[block-&gt;_pre_order-1];
101     DEBUG_ONLY(IndexSet *def_outside = getfreeset();)
102     uint i;
103     for (i = block-&gt;number_of_nodes(); i &gt; 1; i--) {
104       Node* n = block-&gt;get_node(i-1);
105       if (n-&gt;is_Phi()) {
106         break;
107       }
108 
109       uint r = _names.at(n-&gt;_idx);
110       assert(!def_outside-&gt;member(r), &quot;Use of external LRG overlaps the same LRG defined in this block&quot;);
<span class="line-modified">111       def-&gt;insert( r );</span>
<span class="line-modified">112       use-&gt;remove( r );</span>
113       uint cnt = n-&gt;req();
114       for (uint k = 1; k &lt; cnt; k++) {
115         Node *nk = n-&gt;in(k);
116         uint nkidx = nk-&gt;_idx;
117         if (_cfg.get_block_for_node(nk) != block) {
118           uint u = _names.at(nkidx);
119           use-&gt;insert(u);
120           DEBUG_ONLY(def_outside-&gt;insert(u);)
121         }
122       }
123     }
124 #ifdef ASSERT
125     def_outside-&gt;set_next(_free_IndexSet);
126     _free_IndexSet = def_outside;     // Drop onto free list
127 #endif
128     // Remove anything defined by Phis and the block start instruction
129     for (uint k = i; k &gt; 0; k--) {
130       uint r = _names.at(block-&gt;get_node(k - 1)-&gt;_idx);
131       def-&gt;insert(r);
132       use-&gt;remove(r);
</pre>
<hr />
<pre>
135     // Push these live-in things to predecessors
136     for (uint l = 1; l &lt; block-&gt;num_preds(); l++) {
137       Block* p = _cfg.get_block_for_node(block-&gt;pred(l));
138       add_liveout(p, use, first_pass);
139 
140       // PhiNode uses go in the live-out set of prior blocks.
141       for (uint k = i; k &gt; 0; k--) {
142         Node *phi = block-&gt;get_node(k - 1);
143         if (l &lt; phi-&gt;req()) {
144           add_liveout(p, _names.at(phi-&gt;in(l)-&gt;_idx), first_pass);
145         }
146       }
147     }
148     freeset(block);
149     first_pass.set(block-&gt;_pre_order);
150 
151     // Inner loop: blocks that picked up new live-out values to be propagated
152     while (_worklist-&gt;size()) {
153       Block* block = _worklist-&gt;pop();
154       IndexSet *delta = getset(block);
<span class="line-modified">155       assert( delta-&gt;count(), &quot;missing delta set&quot; );</span>
156 
157       // Add new-live-in to predecessors live-out sets
158       for (uint l = 1; l &lt; block-&gt;num_preds(); l++) {
159         Block* predecessor = _cfg.get_block_for_node(block-&gt;pred(l));
160         add_liveout(predecessor, delta, first_pass);
161       }
162 
163       freeset(block);
164     } // End of while-worklist-not-empty
165 
166   } // End of for-all-blocks-outer-loop
167 
168   // We explicitly clear all of the IndexSets which we are about to release.
169   // This allows us to recycle their internal memory into IndexSet&#39;s free list.
170 
171   for (i = 0; i &lt; _cfg.number_of_blocks(); i++) {
172     _defs[i].clear();
173     if (_deltas[i]) {
174       // Is this always true?
175       _deltas[i]-&gt;clear();
176     }
177   }
178   IndexSet *free = _free_IndexSet;
179   while (free != NULL) {
180     IndexSet *temp = free;
181     free = free-&gt;next();
182     temp-&gt;clear();
183   }
184 
185 }
186 
187 #ifndef PRODUCT
188 void PhaseLive::stats(uint iters) const {
189 }
190 #endif
191 
192 // Get an IndexSet for a block.  Return existing one, if any.  Make a new
193 // empty one if a prior one does not exist.
<span class="line-modified">194 IndexSet *PhaseLive::getset( Block *p ) {</span>
195   IndexSet *delta = _deltas[p-&gt;_pre_order-1];
<span class="line-modified">196   if( !delta )                  // Not on worklist?</span>
197     // Get a free set; flag as being on worklist
198     delta = _deltas[p-&gt;_pre_order-1] = getfreeset();

199   return delta;                 // Return set of new live-out items
200 }
201 
202 // Pull from free list, or allocate.  Internal allocation on the returned set
203 // is always from thread local storage.
<span class="line-modified">204 IndexSet *PhaseLive::getfreeset( ) {</span>
205   IndexSet *f = _free_IndexSet;
<span class="line-modified">206   if( !f ) {</span>
207     f = new IndexSet;
<span class="line-removed">208 //    f-&gt;set_arena(Thread::current()-&gt;resource_area());</span>
209     f-&gt;initialize(_maxlrg, Thread::current()-&gt;resource_area());
210   } else {
211     // Pull from free list
212     _free_IndexSet = f-&gt;next();
<span class="line-removed">213   //f-&gt;_cnt = 0;                        // Reset to empty</span>
<span class="line-removed">214 //    f-&gt;set_arena(Thread::current()-&gt;resource_area());</span>
215     f-&gt;initialize(_maxlrg, Thread::current()-&gt;resource_area());
216   }
217   return f;
218 }
219 
220 // Free an IndexSet from a block.
<span class="line-modified">221 void PhaseLive::freeset( Block *p ) {</span>
222   IndexSet *f = _deltas[p-&gt;_pre_order-1];
<span class="line-modified">223   if ( _keep_deltas ) {</span>
224     add_livein(p, f);
225   }
226   f-&gt;set_next(_free_IndexSet);
227   _free_IndexSet = f;           // Drop onto free list
228   _deltas[p-&gt;_pre_order-1] = NULL;
229 }
230 
231 // Add a live-out value to a given blocks live-out set.  If it is new, then
232 // also add it to the delta set and stick the block on the worklist.
<span class="line-modified">233 void PhaseLive::add_liveout( Block *p, uint r, VectorSet &amp;first_pass ) {</span>
234   IndexSet *live = &amp;_live[p-&gt;_pre_order-1];
<span class="line-modified">235   if( live-&gt;insert(r) ) {       // If actually inserted...</span>
236     // We extended the live-out set.  See if the value is generated locally.
237     // If it is not, then we must extend the live-in set.
<span class="line-modified">238     if( !_defs[p-&gt;_pre_order-1].member( r ) ) {</span>
<span class="line-modified">239       if( !_deltas[p-&gt;_pre_order-1] &amp;&amp; // Not on worklist?</span>
<span class="line-modified">240           first_pass.test(p-&gt;_pre_order) )</span>
241         _worklist-&gt;push(p);     // Actually go on worklist if already 1st pass

242       getset(p)-&gt;insert(r);
243     }
244   }
245 }
246 
247 // Add a vector of live-out values to a given blocks live-out set.
<span class="line-modified">248 void PhaseLive::add_liveout( Block *p, IndexSet *lo, VectorSet &amp;first_pass ) {</span>
249   IndexSet *live = &amp;_live[p-&gt;_pre_order-1];
250   IndexSet *defs = &amp;_defs[p-&gt;_pre_order-1];
251   IndexSet *on_worklist = _deltas[p-&gt;_pre_order-1];
252   IndexSet *delta = on_worklist ? on_worklist : getfreeset();
253 
<span class="line-modified">254   IndexSetIterator elements(lo);</span>
<span class="line-modified">255   uint r;</span>
<span class="line-modified">256   while ((r = elements.next()) != 0) {</span>
<span class="line-modified">257     if( live-&gt;insert(r) &amp;&amp;      // If actually inserted...</span>
<span class="line-modified">258         !defs-&gt;member( r ) )    // and not defined locally</span>
<span class="line-modified">259       delta-&gt;insert(r);         // Then add to live-in set</span>



260   }
261 
<span class="line-modified">262   if( delta-&gt;count() ) {                // If actually added things</span>
263     _deltas[p-&gt;_pre_order-1] = delta; // Flag as on worklist now
<span class="line-modified">264     if( !on_worklist &amp;&amp;         // Not on worklist?</span>
<span class="line-modified">265         first_pass.test(p-&gt;_pre_order) )</span>
266       _worklist-&gt;push(p);       // Actually go on worklist if already 1st pass

267   } else {                      // Nothing there; just free it
268     delta-&gt;set_next(_free_IndexSet);
269     _free_IndexSet = delta;     // Drop onto free list
270   }
271 }
272 
273 // Add a vector of live-in values to a given blocks live-in set.
274 void PhaseLive::add_livein(Block *p, IndexSet *lo) {
275   IndexSet *livein = &amp;_livein[p-&gt;_pre_order-1];
<span class="line-modified">276   IndexSetIterator elements(lo);</span>
<span class="line-modified">277   uint r;</span>
<span class="line-modified">278   while ((r = elements.next()) != 0) {</span>
<span class="line-modified">279     livein-&gt;insert(r);         // Then add to live-in set</span>


280   }
281 }
282 
283 #ifndef PRODUCT
284 // Dump the live-out set for a block
<span class="line-modified">285 void PhaseLive::dump( const Block *b ) const {</span>
286   tty-&gt;print(&quot;Block %d: &quot;,b-&gt;_pre_order);
<span class="line-modified">287   if ( _keep_deltas ) {</span>
288     tty-&gt;print(&quot;LiveIn: &quot;);  _livein[b-&gt;_pre_order-1].dump();
289   }
290   tty-&gt;print(&quot;LiveOut: &quot;);  _live[b-&gt;_pre_order-1].dump();
291   uint cnt = b-&gt;number_of_nodes();
<span class="line-modified">292   for( uint i=0; i&lt;cnt; i++ ) {</span>
293     tty-&gt;print(&quot;L%d/&quot;, _names.at(b-&gt;get_node(i)-&gt;_idx));
294     b-&gt;get_node(i)-&gt;dump();
295   }
296   tty-&gt;print(&quot;\n&quot;);
297 }
298 
299 // Verify that base pointers and derived pointers are still sane.
<span class="line-modified">300 void PhaseChaitin::verify_base_ptrs( ResourceArea *a ) const {</span>
301 #ifdef ASSERT
302   Unique_Node_List worklist(a);
303   for (uint i = 0; i &lt; _cfg.number_of_blocks(); i++) {
304     Block* block = _cfg.get_block(i);
305     for (uint j = block-&gt;end_idx() + 1; j &gt; 1; j--) {
306       Node* n = block-&gt;get_node(j-1);
307       if (n-&gt;is_Phi()) {
308         break;
309       }
310       // Found a safepoint?
311       if (n-&gt;is_MachSafePoint()) {
312         MachSafePointNode *sfpt = n-&gt;as_MachSafePoint();
313         JVMState* jvms = sfpt-&gt;jvms();
314         if (jvms != NULL) {
315           // Now scan for a live derived pointer
316           if (jvms-&gt;oopoff() &lt; sfpt-&gt;req()) {
317             // Check each derived/base pair
318             for (uint idx = jvms-&gt;oopoff(); idx &lt; sfpt-&gt;req(); idx++) {
319               Node *check = sfpt-&gt;in(idx);
320               bool is_derived = ((idx - jvms-&gt;oopoff()) &amp; 1) == 0;
321               // search upwards through spills and spill phis for AddP
322               worklist.clear();
323               worklist.push(check);
324               uint k = 0;
<span class="line-modified">325               while( k &lt; worklist.size() ) {</span>
326                 check = worklist.at(k);
327                 assert(check,&quot;Bad base or derived pointer&quot;);
328                 // See PhaseChaitin::find_base_for_derived() for all cases.
329                 int isc = check-&gt;is_Copy();
<span class="line-modified">330                 if( isc ) {</span>
331                   worklist.push(check-&gt;in(isc));
<span class="line-modified">332                 } else if( check-&gt;is_Phi() ) {</span>
333                   for (uint m = 1; m &lt; check-&gt;req(); m++)
334                     worklist.push(check-&gt;in(m));
<span class="line-modified">335                 } else if( check-&gt;is_Con() ) {</span>
336                   if (is_derived) {
337                     // Derived is NULL+offset
338                     assert(!is_derived || check-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::Null,&quot;Bad derived pointer&quot;);
339                   } else {
340                     assert(check-&gt;bottom_type()-&gt;is_ptr()-&gt;_offset == 0,&quot;Bad base pointer&quot;);
341                     // Base either ConP(NULL) or loadConP
342                     if (check-&gt;is_Mach()) {
343                       assert(check-&gt;as_Mach()-&gt;ideal_Opcode() == Op_ConP,&quot;Bad base pointer&quot;);
344                     } else {
345                       assert(check-&gt;Opcode() == Op_ConP &amp;&amp;
346                              check-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::Null,&quot;Bad base pointer&quot;);
347                     }
348                   }
<span class="line-modified">349                 } else if( check-&gt;bottom_type()-&gt;is_ptr()-&gt;_offset == 0 ) {</span>
<span class="line-modified">350                   if(check-&gt;is_Proj() || (check-&gt;is_Mach() &amp;&amp;</span>
351                      (check-&gt;as_Mach()-&gt;ideal_Opcode() == Op_CreateEx ||
352                       check-&gt;as_Mach()-&gt;ideal_Opcode() == Op_ThreadLocal ||
353                       check-&gt;as_Mach()-&gt;ideal_Opcode() == Op_CMoveP ||
354                       check-&gt;as_Mach()-&gt;ideal_Opcode() == Op_CheckCastPP ||
355 #ifdef _LP64
356                       (UseCompressedOops &amp;&amp; check-&gt;as_Mach()-&gt;ideal_Opcode() == Op_CastPP) ||
357                       (UseCompressedOops &amp;&amp; check-&gt;as_Mach()-&gt;ideal_Opcode() == Op_DecodeN) ||
358                       (UseCompressedClassPointers &amp;&amp; check-&gt;as_Mach()-&gt;ideal_Opcode() == Op_DecodeNKlass) ||
359 #endif
360                       check-&gt;as_Mach()-&gt;ideal_Opcode() == Op_LoadP ||
361                       check-&gt;as_Mach()-&gt;ideal_Opcode() == Op_LoadKlass))) {
362                     // Valid nodes
363                   } else {
364                     check-&gt;dump();
365                     assert(false,&quot;Bad base or derived pointer&quot;);
366                   }
367                 } else {
368                   assert(is_derived,&quot;Bad base pointer&quot;);
369                   assert(check-&gt;is_Mach() &amp;&amp; check-&gt;as_Mach()-&gt;ideal_Opcode() == Op_AddP,&quot;Bad derived pointer&quot;);
370                 }
371                 k++;
372                 assert(k &lt; 100000,&quot;Derived pointer checking in infinite loop&quot;);
373               } // End while
374             }
375           } // End of check for derived pointers
376         } // End of Kcheck for debug info
377       } // End of if found a safepoint
378     } // End of forall instructions in block
379   } // End of forall blocks
380 #endif
381 }
382 
383 // Verify that graphs and base pointers are still sane.
<span class="line-modified">384 void PhaseChaitin::verify( ResourceArea *a, bool verify_ifg ) const {</span>
385 #ifdef ASSERT
<span class="line-modified">386   if( VerifyOpto || VerifyRegisterAllocator ) {</span>
387     _cfg.verify();
388     verify_base_ptrs(a);
389     if(verify_ifg)
390       _ifg-&gt;verify(this);
391   }
392 #endif
393 }
394 
395 #endif
</pre>
</td>
<td>
<hr />
<pre>
 67   if (_keep_deltas) {
 68     _livein = (IndexSet*)_arena-&gt;Amalloc(sizeof(IndexSet) * _cfg.number_of_blocks());
 69     for (i = 0; i &lt; _cfg.number_of_blocks(); i++) {
 70       _livein[i].initialize(_maxlrg);
 71     }
 72   }
 73 
 74   // Init the sparse arrays for delta-sets.
 75   ResourceMark rm;              // Nuke temp storage on exit
 76 
 77   // Does the memory used by _defs and _deltas get reclaimed?  Does it matter?  TT
 78 
 79   // Array of values defined locally in blocks
 80   _defs = NEW_RESOURCE_ARRAY(IndexSet,_cfg.number_of_blocks());
 81   for (i = 0; i &lt; _cfg.number_of_blocks(); i++) {
 82     _defs[i].initialize(_maxlrg);
 83   }
 84 
 85   // Array of delta-set pointers, indexed by block pre_order-1.
 86   _deltas = NEW_RESOURCE_ARRAY(IndexSet*,_cfg.number_of_blocks());
<span class="line-modified"> 87   memset(_deltas, 0, sizeof(IndexSet*)* _cfg.number_of_blocks());</span>
 88 
 89   _free_IndexSet = NULL;
 90 
 91   // Blocks having done pass-1
 92   VectorSet first_pass(Thread::current()-&gt;resource_area());
 93 
 94   // Outer loop: must compute local live-in sets and push into predecessors.
 95   for (uint j = _cfg.number_of_blocks(); j &gt; 0; j--) {
 96     Block* block = _cfg.get_block(j - 1);
 97 
 98     // Compute the local live-in set.  Start with any new live-out bits.
 99     IndexSet* use = getset(block);
100     IndexSet* def = &amp;_defs[block-&gt;_pre_order-1];
101     DEBUG_ONLY(IndexSet *def_outside = getfreeset();)
102     uint i;
103     for (i = block-&gt;number_of_nodes(); i &gt; 1; i--) {
104       Node* n = block-&gt;get_node(i-1);
105       if (n-&gt;is_Phi()) {
106         break;
107       }
108 
109       uint r = _names.at(n-&gt;_idx);
110       assert(!def_outside-&gt;member(r), &quot;Use of external LRG overlaps the same LRG defined in this block&quot;);
<span class="line-modified">111       def-&gt;insert(r);</span>
<span class="line-modified">112       use-&gt;remove(r);</span>
113       uint cnt = n-&gt;req();
114       for (uint k = 1; k &lt; cnt; k++) {
115         Node *nk = n-&gt;in(k);
116         uint nkidx = nk-&gt;_idx;
117         if (_cfg.get_block_for_node(nk) != block) {
118           uint u = _names.at(nkidx);
119           use-&gt;insert(u);
120           DEBUG_ONLY(def_outside-&gt;insert(u);)
121         }
122       }
123     }
124 #ifdef ASSERT
125     def_outside-&gt;set_next(_free_IndexSet);
126     _free_IndexSet = def_outside;     // Drop onto free list
127 #endif
128     // Remove anything defined by Phis and the block start instruction
129     for (uint k = i; k &gt; 0; k--) {
130       uint r = _names.at(block-&gt;get_node(k - 1)-&gt;_idx);
131       def-&gt;insert(r);
132       use-&gt;remove(r);
</pre>
<hr />
<pre>
135     // Push these live-in things to predecessors
136     for (uint l = 1; l &lt; block-&gt;num_preds(); l++) {
137       Block* p = _cfg.get_block_for_node(block-&gt;pred(l));
138       add_liveout(p, use, first_pass);
139 
140       // PhiNode uses go in the live-out set of prior blocks.
141       for (uint k = i; k &gt; 0; k--) {
142         Node *phi = block-&gt;get_node(k - 1);
143         if (l &lt; phi-&gt;req()) {
144           add_liveout(p, _names.at(phi-&gt;in(l)-&gt;_idx), first_pass);
145         }
146       }
147     }
148     freeset(block);
149     first_pass.set(block-&gt;_pre_order);
150 
151     // Inner loop: blocks that picked up new live-out values to be propagated
152     while (_worklist-&gt;size()) {
153       Block* block = _worklist-&gt;pop();
154       IndexSet *delta = getset(block);
<span class="line-modified">155       assert(delta-&gt;count(), &quot;missing delta set&quot;);</span>
156 
157       // Add new-live-in to predecessors live-out sets
158       for (uint l = 1; l &lt; block-&gt;num_preds(); l++) {
159         Block* predecessor = _cfg.get_block_for_node(block-&gt;pred(l));
160         add_liveout(predecessor, delta, first_pass);
161       }
162 
163       freeset(block);
164     } // End of while-worklist-not-empty
165 
166   } // End of for-all-blocks-outer-loop
167 
168   // We explicitly clear all of the IndexSets which we are about to release.
169   // This allows us to recycle their internal memory into IndexSet&#39;s free list.
170 
171   for (i = 0; i &lt; _cfg.number_of_blocks(); i++) {
172     _defs[i].clear();
173     if (_deltas[i]) {
174       // Is this always true?
175       _deltas[i]-&gt;clear();
176     }
177   }
178   IndexSet *free = _free_IndexSet;
179   while (free != NULL) {
180     IndexSet *temp = free;
181     free = free-&gt;next();
182     temp-&gt;clear();
183   }
184 
185 }
186 
187 #ifndef PRODUCT
188 void PhaseLive::stats(uint iters) const {
189 }
190 #endif
191 
192 // Get an IndexSet for a block.  Return existing one, if any.  Make a new
193 // empty one if a prior one does not exist.
<span class="line-modified">194 IndexSet *PhaseLive::getset(Block *p) {</span>
195   IndexSet *delta = _deltas[p-&gt;_pre_order-1];
<span class="line-modified">196   if (!delta) {                 // Not on worklist?</span>
197     // Get a free set; flag as being on worklist
198     delta = _deltas[p-&gt;_pre_order-1] = getfreeset();
<span class="line-added">199   }</span>
200   return delta;                 // Return set of new live-out items
201 }
202 
203 // Pull from free list, or allocate.  Internal allocation on the returned set
204 // is always from thread local storage.
<span class="line-modified">205 IndexSet *PhaseLive::getfreeset() {</span>
206   IndexSet *f = _free_IndexSet;
<span class="line-modified">207   if (!f) {</span>
208     f = new IndexSet;

209     f-&gt;initialize(_maxlrg, Thread::current()-&gt;resource_area());
210   } else {
211     // Pull from free list
212     _free_IndexSet = f-&gt;next();


213     f-&gt;initialize(_maxlrg, Thread::current()-&gt;resource_area());
214   }
215   return f;
216 }
217 
218 // Free an IndexSet from a block.
<span class="line-modified">219 void PhaseLive::freeset(Block *p) {</span>
220   IndexSet *f = _deltas[p-&gt;_pre_order-1];
<span class="line-modified">221   if (_keep_deltas) {</span>
222     add_livein(p, f);
223   }
224   f-&gt;set_next(_free_IndexSet);
225   _free_IndexSet = f;           // Drop onto free list
226   _deltas[p-&gt;_pre_order-1] = NULL;
227 }
228 
229 // Add a live-out value to a given blocks live-out set.  If it is new, then
230 // also add it to the delta set and stick the block on the worklist.
<span class="line-modified">231 void PhaseLive::add_liveout(Block *p, uint r, VectorSet &amp;first_pass) {</span>
232   IndexSet *live = &amp;_live[p-&gt;_pre_order-1];
<span class="line-modified">233   if (live-&gt;insert(r)) {        // If actually inserted...</span>
234     // We extended the live-out set.  See if the value is generated locally.
235     // If it is not, then we must extend the live-in set.
<span class="line-modified">236     if (!_defs[p-&gt;_pre_order-1].member(r)) {</span>
<span class="line-modified">237       if (!_deltas[p-&gt;_pre_order-1] &amp;&amp; // Not on worklist?</span>
<span class="line-modified">238           first_pass.test(p-&gt;_pre_order)) {</span>
239         _worklist-&gt;push(p);     // Actually go on worklist if already 1st pass
<span class="line-added">240       }</span>
241       getset(p)-&gt;insert(r);
242     }
243   }
244 }
245 
246 // Add a vector of live-out values to a given blocks live-out set.
<span class="line-modified">247 void PhaseLive::add_liveout(Block *p, IndexSet *lo, VectorSet &amp;first_pass) {</span>
248   IndexSet *live = &amp;_live[p-&gt;_pre_order-1];
249   IndexSet *defs = &amp;_defs[p-&gt;_pre_order-1];
250   IndexSet *on_worklist = _deltas[p-&gt;_pre_order-1];
251   IndexSet *delta = on_worklist ? on_worklist : getfreeset();
252 
<span class="line-modified">253   if (!lo-&gt;is_empty()) {</span>
<span class="line-modified">254     IndexSetIterator elements(lo);</span>
<span class="line-modified">255     uint r;</span>
<span class="line-modified">256     while ((r = elements.next()) != 0) {</span>
<span class="line-modified">257       if (live-&gt;insert(r) &amp;&amp;      // If actually inserted...</span>
<span class="line-modified">258           !defs-&gt;member(r)) {     // and not defined locally</span>
<span class="line-added">259         delta-&gt;insert(r);         // Then add to live-in set</span>
<span class="line-added">260       }</span>
<span class="line-added">261     }</span>
262   }
263 
<span class="line-modified">264   if (delta-&gt;count()) {                // If actually added things</span>
265     _deltas[p-&gt;_pre_order-1] = delta; // Flag as on worklist now
<span class="line-modified">266     if (!on_worklist &amp;&amp;         // Not on worklist?</span>
<span class="line-modified">267         first_pass.test(p-&gt;_pre_order)) {</span>
268       _worklist-&gt;push(p);       // Actually go on worklist if already 1st pass
<span class="line-added">269     }</span>
270   } else {                      // Nothing there; just free it
271     delta-&gt;set_next(_free_IndexSet);
272     _free_IndexSet = delta;     // Drop onto free list
273   }
274 }
275 
276 // Add a vector of live-in values to a given blocks live-in set.
277 void PhaseLive::add_livein(Block *p, IndexSet *lo) {
278   IndexSet *livein = &amp;_livein[p-&gt;_pre_order-1];
<span class="line-modified">279   if (!livein-&gt;is_empty()) {</span>
<span class="line-modified">280     IndexSetIterator elements(lo);</span>
<span class="line-modified">281     uint r;</span>
<span class="line-modified">282     while ((r = elements.next()) != 0) {</span>
<span class="line-added">283       livein-&gt;insert(r);         // Then add to live-in set</span>
<span class="line-added">284     }</span>
285   }
286 }
287 
288 #ifndef PRODUCT
289 // Dump the live-out set for a block
<span class="line-modified">290 void PhaseLive::dump(const Block *b) const {</span>
291   tty-&gt;print(&quot;Block %d: &quot;,b-&gt;_pre_order);
<span class="line-modified">292   if (_keep_deltas) {</span>
293     tty-&gt;print(&quot;LiveIn: &quot;);  _livein[b-&gt;_pre_order-1].dump();
294   }
295   tty-&gt;print(&quot;LiveOut: &quot;);  _live[b-&gt;_pre_order-1].dump();
296   uint cnt = b-&gt;number_of_nodes();
<span class="line-modified">297   for (uint i = 0; i &lt; cnt; i++) {</span>
298     tty-&gt;print(&quot;L%d/&quot;, _names.at(b-&gt;get_node(i)-&gt;_idx));
299     b-&gt;get_node(i)-&gt;dump();
300   }
301   tty-&gt;print(&quot;\n&quot;);
302 }
303 
304 // Verify that base pointers and derived pointers are still sane.
<span class="line-modified">305 void PhaseChaitin::verify_base_ptrs(ResourceArea *a) const {</span>
306 #ifdef ASSERT
307   Unique_Node_List worklist(a);
308   for (uint i = 0; i &lt; _cfg.number_of_blocks(); i++) {
309     Block* block = _cfg.get_block(i);
310     for (uint j = block-&gt;end_idx() + 1; j &gt; 1; j--) {
311       Node* n = block-&gt;get_node(j-1);
312       if (n-&gt;is_Phi()) {
313         break;
314       }
315       // Found a safepoint?
316       if (n-&gt;is_MachSafePoint()) {
317         MachSafePointNode *sfpt = n-&gt;as_MachSafePoint();
318         JVMState* jvms = sfpt-&gt;jvms();
319         if (jvms != NULL) {
320           // Now scan for a live derived pointer
321           if (jvms-&gt;oopoff() &lt; sfpt-&gt;req()) {
322             // Check each derived/base pair
323             for (uint idx = jvms-&gt;oopoff(); idx &lt; sfpt-&gt;req(); idx++) {
324               Node *check = sfpt-&gt;in(idx);
325               bool is_derived = ((idx - jvms-&gt;oopoff()) &amp; 1) == 0;
326               // search upwards through spills and spill phis for AddP
327               worklist.clear();
328               worklist.push(check);
329               uint k = 0;
<span class="line-modified">330               while (k &lt; worklist.size()) {</span>
331                 check = worklist.at(k);
332                 assert(check,&quot;Bad base or derived pointer&quot;);
333                 // See PhaseChaitin::find_base_for_derived() for all cases.
334                 int isc = check-&gt;is_Copy();
<span class="line-modified">335                 if (isc) {</span>
336                   worklist.push(check-&gt;in(isc));
<span class="line-modified">337                 } else if (check-&gt;is_Phi()) {</span>
338                   for (uint m = 1; m &lt; check-&gt;req(); m++)
339                     worklist.push(check-&gt;in(m));
<span class="line-modified">340                 } else if (check-&gt;is_Con()) {</span>
341                   if (is_derived) {
342                     // Derived is NULL+offset
343                     assert(!is_derived || check-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::Null,&quot;Bad derived pointer&quot;);
344                   } else {
345                     assert(check-&gt;bottom_type()-&gt;is_ptr()-&gt;_offset == 0,&quot;Bad base pointer&quot;);
346                     // Base either ConP(NULL) or loadConP
347                     if (check-&gt;is_Mach()) {
348                       assert(check-&gt;as_Mach()-&gt;ideal_Opcode() == Op_ConP,&quot;Bad base pointer&quot;);
349                     } else {
350                       assert(check-&gt;Opcode() == Op_ConP &amp;&amp;
351                              check-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::Null,&quot;Bad base pointer&quot;);
352                     }
353                   }
<span class="line-modified">354                 } else if (check-&gt;bottom_type()-&gt;is_ptr()-&gt;_offset == 0) {</span>
<span class="line-modified">355                   if (check-&gt;is_Proj() || (check-&gt;is_Mach() &amp;&amp;</span>
356                      (check-&gt;as_Mach()-&gt;ideal_Opcode() == Op_CreateEx ||
357                       check-&gt;as_Mach()-&gt;ideal_Opcode() == Op_ThreadLocal ||
358                       check-&gt;as_Mach()-&gt;ideal_Opcode() == Op_CMoveP ||
359                       check-&gt;as_Mach()-&gt;ideal_Opcode() == Op_CheckCastPP ||
360 #ifdef _LP64
361                       (UseCompressedOops &amp;&amp; check-&gt;as_Mach()-&gt;ideal_Opcode() == Op_CastPP) ||
362                       (UseCompressedOops &amp;&amp; check-&gt;as_Mach()-&gt;ideal_Opcode() == Op_DecodeN) ||
363                       (UseCompressedClassPointers &amp;&amp; check-&gt;as_Mach()-&gt;ideal_Opcode() == Op_DecodeNKlass) ||
364 #endif
365                       check-&gt;as_Mach()-&gt;ideal_Opcode() == Op_LoadP ||
366                       check-&gt;as_Mach()-&gt;ideal_Opcode() == Op_LoadKlass))) {
367                     // Valid nodes
368                   } else {
369                     check-&gt;dump();
370                     assert(false,&quot;Bad base or derived pointer&quot;);
371                   }
372                 } else {
373                   assert(is_derived,&quot;Bad base pointer&quot;);
374                   assert(check-&gt;is_Mach() &amp;&amp; check-&gt;as_Mach()-&gt;ideal_Opcode() == Op_AddP,&quot;Bad derived pointer&quot;);
375                 }
376                 k++;
377                 assert(k &lt; 100000,&quot;Derived pointer checking in infinite loop&quot;);
378               } // End while
379             }
380           } // End of check for derived pointers
381         } // End of Kcheck for debug info
382       } // End of if found a safepoint
383     } // End of forall instructions in block
384   } // End of forall blocks
385 #endif
386 }
387 
388 // Verify that graphs and base pointers are still sane.
<span class="line-modified">389 void PhaseChaitin::verify(ResourceArea *a, bool verify_ifg) const {</span>
390 #ifdef ASSERT
<span class="line-modified">391   if (VerifyRegisterAllocator) {</span>
392     _cfg.verify();
393     verify_base_ptrs(a);
394     if(verify_ifg)
395       _ifg-&gt;verify(this);
396   }
397 #endif
398 }
399 
400 #endif
</pre>
</td>
</tr>
</table>
<center><a href="library_call.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="locknode.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
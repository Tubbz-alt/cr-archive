<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/machnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/collectedHeap.hpp&quot;
 27 #include &quot;opto/machnode.hpp&quot;
 28 #include &quot;opto/regalloc.hpp&quot;
 29 #include &quot;utilities/vmError.hpp&quot;
 30 
 31 //=============================================================================
 32 // Return the value requested
 33 // result register lookup, corresponding to int_format
 34 int MachOper::reg(PhaseRegAlloc *ra_, const Node *node) const {
 35   return (int)ra_-&gt;get_encode(node);
 36 }
 37 // input register lookup, corresponding to ext_format
 38 int MachOper::reg(PhaseRegAlloc *ra_, const Node *node, int idx) const {
 39   return (int)(ra_-&gt;get_encode(node-&gt;in(idx)));
 40 }
 41 intptr_t  MachOper::constant() const { return 0x00; }
 42 relocInfo::relocType MachOper::constant_reloc() const { return relocInfo::none; }
 43 jdouble MachOper::constantD() const { ShouldNotReachHere(); return 0.0; }
 44 jfloat  MachOper::constantF() const { ShouldNotReachHere(); return 0.0; }
 45 jlong   MachOper::constantL() const { ShouldNotReachHere(); return CONST64(0) ; }
 46 TypeOopPtr *MachOper::oop() const { return NULL; }
 47 int MachOper::ccode() const { return 0x00; }
 48 // A zero, default, indicates this value is not needed.
 49 // May need to lookup the base register, as done in int_ and ext_format
 50 int MachOper::base (PhaseRegAlloc *ra_, const Node *node, int idx)  const { return 0x00; }
 51 int MachOper::index(PhaseRegAlloc *ra_, const Node *node, int idx)  const { return 0x00; }
 52 int MachOper::scale()  const { return 0x00; }
 53 int MachOper::disp (PhaseRegAlloc *ra_, const Node *node, int idx)  const { return 0x00; }
 54 int MachOper::constant_disp()  const { return 0; }
 55 int MachOper::base_position()  const { return -1; }  // no base input
 56 int MachOper::index_position() const { return -1; }  // no index input
 57 // Check for PC-Relative displacement
 58 relocInfo::relocType MachOper::disp_reloc() const { return relocInfo::none; }
 59 // Return the label
 60 Label*   MachOper::label()  const { ShouldNotReachHere(); return 0; }
 61 intptr_t MachOper::method() const { ShouldNotReachHere(); return 0; }
 62 
 63 
 64 //------------------------------negate-----------------------------------------
 65 // Negate conditional branches.  Error for non-branch operands
 66 void MachOper::negate() {
 67   ShouldNotCallThis();
 68 }
 69 
 70 //-----------------------------type--------------------------------------------
 71 const Type *MachOper::type() const {
 72   return Type::BOTTOM;
 73 }
 74 
 75 //------------------------------in_RegMask-------------------------------------
 76 const RegMask *MachOper::in_RegMask(int index) const {
 77   ShouldNotReachHere();
 78   return NULL;
 79 }
 80 
 81 //------------------------------dump_spec--------------------------------------
 82 // Print any per-operand special info
 83 #ifndef PRODUCT
 84 void MachOper::dump_spec(outputStream *st) const { }
 85 #endif
 86 
 87 //------------------------------hash-------------------------------------------
 88 // Print any per-operand special info
 89 uint MachOper::hash() const {
 90   ShouldNotCallThis();
 91   return 5;
 92 }
 93 
 94 //------------------------------cmp--------------------------------------------
 95 // Print any per-operand special info
 96 uint MachOper::cmp( const MachOper &amp;oper ) const {
 97   ShouldNotCallThis();
 98   return opcode() == oper.opcode();
 99 }
100 
101 //------------------------------hash-------------------------------------------
102 // Print any per-operand special info
103 uint labelOper::hash() const {
104   return _block_num;
105 }
106 
107 //------------------------------cmp--------------------------------------------
108 // Print any per-operand special info
109 uint labelOper::cmp( const MachOper &amp;oper ) const {
110   return (opcode() == oper.opcode()) &amp;&amp; (_label == oper.label());
111 }
112 
113 //------------------------------hash-------------------------------------------
114 // Print any per-operand special info
115 uint methodOper::hash() const {
116   return (uint)_method;
117 }
118 
119 //------------------------------cmp--------------------------------------------
120 // Print any per-operand special info
121 uint methodOper::cmp( const MachOper &amp;oper ) const {
122   return (opcode() == oper.opcode()) &amp;&amp; (_method == oper.method());
123 }
124 
125 
126 //=============================================================================
127 //------------------------------MachNode---------------------------------------
128 
129 //------------------------------emit-------------------------------------------
130 void MachNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
131   #ifdef ASSERT
132   tty-&gt;print(&quot;missing MachNode emit function: &quot;);
133   dump();
134   #endif
135   ShouldNotCallThis();
136 }
137 
138 //---------------------------postalloc_expand----------------------------------
139 // Expand node after register allocation.
140 void MachNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {}
141 
142 //------------------------------size-------------------------------------------
143 // Size of instruction in bytes
144 uint MachNode::size(PhaseRegAlloc *ra_) const {
145   // If a virtual was not defined for this specific instruction,
146   // Call the helper which finds the size by emitting the bits.
147   return MachNode::emit_size(ra_);
148 }
149 
150 //------------------------------size-------------------------------------------
151 // Helper function that computes size by emitting code
152 uint MachNode::emit_size(PhaseRegAlloc *ra_) const {
153   // Emit into a trash buffer and count bytes emitted.
154   assert(ra_ == ra_-&gt;C-&gt;regalloc(), &quot;sanity&quot;);
155   return ra_-&gt;C-&gt;scratch_emit_size(this);
156 }
157 
158 
159 
160 //------------------------------hash-------------------------------------------
161 uint MachNode::hash() const {
162   uint no = num_opnds();
163   uint sum = rule();
164   for( uint i=0; i&lt;no; i++ )
165     sum += _opnds[i]-&gt;hash();
166   return sum+Node::hash();
167 }
168 
169 //-----------------------------cmp---------------------------------------------
170 uint MachNode::cmp( const Node &amp;node ) const {
171   MachNode&amp; n = *((Node&amp;)node).as_Mach();
172   uint no = num_opnds();
173   if( no != n.num_opnds() ) return 0;
174   if( rule() != n.rule() ) return 0;
175   for( uint i=0; i&lt;no; i++ )    // All operands must match
176     if( !_opnds[i]-&gt;cmp( *n._opnds[i] ) )
177       return 0;                 // mis-matched operands
178   return 1;                     // match
179 }
180 
181 // Return an equivalent instruction using memory for cisc_operand position
182 MachNode *MachNode::cisc_version(int offset) {
183   ShouldNotCallThis();
184   return NULL;
185 }
186 
187 void MachNode::use_cisc_RegMask() {
188   ShouldNotReachHere();
189 }
190 
191 
192 //-----------------------------in_RegMask--------------------------------------
193 const RegMask &amp;MachNode::in_RegMask( uint idx ) const {
194   uint numopnds = num_opnds();        // Virtual call for number of operands
195   uint skipped   = oper_input_base(); // Sum of leaves skipped so far
196   if( idx &lt; skipped ) {
197     assert( ideal_Opcode() == Op_AddP, &quot;expected base ptr here&quot; );
198     assert( idx == 1, &quot;expected base ptr here&quot; );
199     // debug info can be anywhere
200     return *Compile::current()-&gt;matcher()-&gt;idealreg2spillmask[Op_RegP];
201   }
202   uint opcnt     = 1;                 // First operand
203   uint num_edges = _opnds[1]-&gt;num_edges(); // leaves for first operand
204   while( idx &gt;= skipped+num_edges ) {
205     skipped += num_edges;
206     opcnt++;                          // Bump operand count
207     assert( opcnt &lt; numopnds, &quot;Accessing non-existent operand&quot; );
208     num_edges = _opnds[opcnt]-&gt;num_edges(); // leaves for next operand
209   }
210 
211   const RegMask *rm = cisc_RegMask();
212   if( rm == NULL || (int)opcnt != cisc_operand() ) {
213     rm = _opnds[opcnt]-&gt;in_RegMask(idx-skipped);
214   }
215   return *rm;
216 }
217 
218 //-----------------------------memory_inputs--------------------------------
219 const MachOper*  MachNode::memory_inputs(Node* &amp;base, Node* &amp;index) const {
220   const MachOper* oper = memory_operand();
221 
222   if (oper == (MachOper*)-1) {
223     base = NodeSentinel;
224     index = NodeSentinel;
225   } else {
226     base = NULL;
227     index = NULL;
228     if (oper != NULL) {
229       // It has a unique memory operand.  Find its index.
230       int oper_idx = num_opnds();
231       while (--oper_idx &gt;= 0) {
232         if (_opnds[oper_idx] == oper)  break;
233       }
234       int oper_pos = operand_index(oper_idx);
235       int base_pos = oper-&gt;base_position();
236       if (base_pos &gt;= 0) {
237         base = _in[oper_pos+base_pos];
238       }
239       int index_pos = oper-&gt;index_position();
240       if (index_pos &gt;= 0) {
241         index = _in[oper_pos+index_pos];
242       }
243     }
244   }
245 
246   return oper;
247 }
248 
249 //-----------------------------get_base_and_disp----------------------------
250 const Node* MachNode::get_base_and_disp(intptr_t &amp;offset, const TypePtr* &amp;adr_type) const {
251 
252   // Find the memory inputs using our helper function
253   Node* base;
254   Node* index;
255   const MachOper* oper = memory_inputs(base, index);
256 
257   if (oper == NULL) {
258     // Base has been set to NULL
259     offset = 0;
260   } else if (oper == (MachOper*)-1) {
261     // Base has been set to NodeSentinel
262     // There is not a unique memory use here.  We will fall to AliasIdxBot.
263     offset = Type::OffsetBot;
264   } else {
265     // Base may be NULL, even if offset turns out to be != 0
266 
267     intptr_t disp = oper-&gt;constant_disp();
268     int scale = oper-&gt;scale();
269     // Now we have collected every part of the ADLC MEMORY_INTER.
270     // See if it adds up to a base + offset.
271     if (index != NULL) {
272       const Type* t_index = index-&gt;bottom_type();
273       if (t_index-&gt;isa_narrowoop() || t_index-&gt;isa_narrowklass()) { // EncodeN, LoadN, LoadConN, LoadNKlass,
274                                                                     // EncodeNKlass, LoadConNklass.
275         // Memory references through narrow oops have a
276         // funny base so grab the type from the index:
277         // [R12 + narrow_oop_reg&lt;&lt;3 + offset]
278         assert(base == NULL, &quot;Memory references through narrow oops have no base&quot;);
279         offset = disp;
280         adr_type = t_index-&gt;make_ptr()-&gt;add_offset(offset);
281         return NULL;
282       } else if (!index-&gt;is_Con()) {
283         disp = Type::OffsetBot;
284       } else if (disp != Type::OffsetBot) {
285         const TypeX* ti = t_index-&gt;isa_intptr_t();
286         if (ti == NULL) {
287           disp = Type::OffsetBot;  // a random constant??
288         } else {
289           disp += ti-&gt;get_con() &lt;&lt; scale;
290         }
291       }
292     }
293     offset = disp;
294 
295     // In i486.ad, indOffset32X uses base==RegI and disp==RegP,
296     // this will prevent alias analysis without the following support:
297     // Lookup the TypePtr used by indOffset32X, a compile-time constant oop,
298     // Add the offset determined by the &quot;base&quot;, or use Type::OffsetBot.
299     if( adr_type == TYPE_PTR_SENTINAL ) {
300       const TypePtr *t_disp = oper-&gt;disp_as_type();  // only !NULL for indOffset32X
301       if (t_disp != NULL) {
302         offset = Type::OffsetBot;
303         const Type* t_base = base-&gt;bottom_type();
304         if (t_base-&gt;isa_intptr_t()) {
305           const TypeX *t_offset = t_base-&gt;is_intptr_t();
306           if( t_offset-&gt;is_con() ) {
307             offset = t_offset-&gt;get_con();
308           }
309         }
310         adr_type = t_disp-&gt;add_offset(offset);
311       } else if( base == NULL &amp;&amp; offset != 0 &amp;&amp; offset != Type::OffsetBot ) {
312         // Use ideal type if it is oop ptr.
313         const TypePtr *tp = oper-&gt;type()-&gt;isa_ptr();
314         if( tp != NULL) {
315           adr_type = tp;
316         }
317       }
318     }
319 
320   }
321   return base;
322 }
323 
324 
325 //---------------------------------adr_type---------------------------------
326 const class TypePtr *MachNode::adr_type() const {
327   intptr_t offset = 0;
328   const TypePtr *adr_type = TYPE_PTR_SENTINAL;  // attempt computing adr_type
329   const Node *base = get_base_and_disp(offset, adr_type);
330   if( adr_type != TYPE_PTR_SENTINAL ) {
331     return adr_type;      // get_base_and_disp has the answer
332   }
333 
334   // Direct addressing modes have no base node, simply an indirect
335   // offset, which is always to raw memory.
336   // %%%%% Someday we&#39;d like to allow constant oop offsets which
337   // would let Intel load from static globals in 1 instruction.
338   // Currently Intel requires 2 instructions and a register temp.
339   if (base == NULL) {
340     // NULL base, zero offset means no memory at all (a null pointer!)
341     if (offset == 0) {
342       return NULL;
343     }
344     // NULL base, any offset means any pointer whatever
345     if (offset == Type::OffsetBot) {
346       return TypePtr::BOTTOM;
347     }
348     // %%% make offset be intptr_t
349     assert(!Universe::heap()-&gt;is_in_reserved(cast_to_oop(offset)), &quot;must be a raw ptr&quot;);
350     return TypeRawPtr::BOTTOM;
351   }
352 
353   // base of -1 with no particular offset means all of memory
354   if (base == NodeSentinel)  return TypePtr::BOTTOM;
355 
356   const Type* t = base-&gt;bottom_type();
357   if (t-&gt;isa_narrowoop() &amp;&amp; Universe::narrow_oop_shift() == 0) {
358     // 32-bit unscaled narrow oop can be the base of any address expression
359     t = t-&gt;make_ptr();
360   }
361   if (t-&gt;isa_narrowklass() &amp;&amp; Universe::narrow_klass_shift() == 0) {
362     // 32-bit unscaled narrow oop can be the base of any address expression
363     t = t-&gt;make_ptr();
364   }
365   if (t-&gt;isa_intptr_t() &amp;&amp; offset != 0 &amp;&amp; offset != Type::OffsetBot) {
366     // We cannot assert that the offset does not look oop-ish here.
367     // Depending on the heap layout the cardmark base could land
368     // inside some oopish region.  It definitely does for Win2K.
369     // The sum of cardmark-base plus shift-by-9-oop lands outside
370     // the oop-ish area but we can&#39;t assert for that statically.
371     return TypeRawPtr::BOTTOM;
372   }
373 
374   const TypePtr *tp = t-&gt;isa_ptr();
375 
376   // be conservative if we do not recognize the type
377   if (tp == NULL) {
378     assert(false, &quot;this path may produce not optimal code&quot;);
379     return TypePtr::BOTTOM;
380   }
381   assert(tp-&gt;base() != Type::AnyPtr, &quot;not a bare pointer&quot;);
382 
383   return tp-&gt;add_offset(offset);
384 }
385 
386 
387 //-----------------------------operand_index---------------------------------
388 int MachNode::operand_index( uint operand ) const {
389   if( operand &lt; 1 )  return -1;
390   assert(operand &lt; num_opnds(), &quot;oob&quot;);
391   if( _opnds[operand]-&gt;num_edges() == 0 )  return -1;
392 
393   uint skipped   = oper_input_base(); // Sum of leaves skipped so far
394   for (uint opcnt = 1; opcnt &lt; operand; opcnt++) {
395     uint num_edges = _opnds[opcnt]-&gt;num_edges(); // leaves for operand
396     skipped += num_edges;
397   }
398   return skipped;
399 }
400 
401 int MachNode::operand_index(const MachOper *oper) const {
402   uint skipped = oper_input_base(); // Sum of leaves skipped so far
403   uint opcnt;
404   for (opcnt = 1; opcnt &lt; num_opnds(); opcnt++) {
405     if (_opnds[opcnt] == oper) break;
406     uint num_edges = _opnds[opcnt]-&gt;num_edges(); // leaves for operand
407     skipped += num_edges;
408   }
409   if (_opnds[opcnt] != oper) return -1;
410   return skipped;
411 }
412 
413 //------------------------------peephole---------------------------------------
414 // Apply peephole rule(s) to this instruction
415 MachNode *MachNode::peephole(Block *block, int block_index, PhaseRegAlloc *ra_, int &amp;deleted) {
416   return NULL;
417 }
418 
419 //------------------------------add_case_label---------------------------------
420 // Adds the label for the case
421 void MachNode::add_case_label( int index_num, Label* blockLabel) {
422   ShouldNotCallThis();
423 }
424 
425 //------------------------------method_set-------------------------------------
426 // Set the absolute address of a method
427 void MachNode::method_set( intptr_t addr ) {
428   ShouldNotCallThis();
429 }
430 
431 //------------------------------rematerialize----------------------------------
432 bool MachNode::rematerialize() const {
433   // Temps are always rematerializable
434   if (is_MachTemp()) return true;
435 
436   uint r = rule();              // Match rule
437   if (r &lt;  Matcher::_begin_rematerialize ||
438       r &gt;= Matcher::_end_rematerialize) {
439     return false;
440   }
441 
442   // For 2-address instructions, the input live range is also the output
443   // live range. Remateralizing does not make progress on the that live range.
444   if (two_adr()) return false;
445 
446   // Check for rematerializing float constants, or not
447   if (!Matcher::rematerialize_float_constants) {
448     int op = ideal_Opcode();
449     if (op == Op_ConF || op == Op_ConD) {
450       return false;
451     }
452   }
453 
454   // Defining flags - can&#39;t spill these! Must remateralize.
455   if (ideal_reg() == Op_RegFlags) {
456     return true;
457   }
458 
459   // Stretching lots of inputs - don&#39;t do it.
460   if (req() &gt; 2) {
461     return false;
462   }
463 
464   if (req() == 2 &amp;&amp; in(1) &amp;&amp; in(1)-&gt;ideal_reg() == Op_RegFlags) {
465     // In(1) will be rematerialized, too.
466     // Stretching lots of inputs - don&#39;t do it.
467     if (in(1)-&gt;req() &gt; 2) {
468       return false;
469     }
470   }
471 
472   // Don&#39;t remateralize somebody with bound inputs - it stretches a
473   // fixed register lifetime.
474   uint idx = oper_input_base();
475   if (req() &gt; idx) {
476     const RegMask &amp;rm = in_RegMask(idx);
477     if (rm.is_bound(ideal_reg())) {
478       return false;
479     }
480   }
481 
482   return true;
483 }
484 
485 #ifndef PRODUCT
486 //------------------------------dump_spec--------------------------------------
487 // Print any per-operand special info
488 void MachNode::dump_spec(outputStream *st) const {
489   uint cnt = num_opnds();
490   for( uint i=0; i&lt;cnt; i++ ) {
491     if (_opnds[i] != NULL) {
492       _opnds[i]-&gt;dump_spec(st);
493     } else {
494       st-&gt;print(&quot; _&quot;);
495     }
496   }
497   const TypePtr *t = adr_type();
498   if( t ) {
499     Compile* C = Compile::current();
500     if( C-&gt;alias_type(t)-&gt;is_volatile() )
501       st-&gt;print(&quot; Volatile!&quot;);
502   }
503 }
504 
505 //------------------------------dump_format------------------------------------
506 // access to virtual
507 void MachNode::dump_format(PhaseRegAlloc *ra, outputStream *st) const {
508   format(ra, st); // access to virtual
509 }
510 #endif
511 
512 //=============================================================================
513 #ifndef PRODUCT
514 void MachTypeNode::dump_spec(outputStream *st) const {
515   if (_bottom_type != NULL) {
516     _bottom_type-&gt;dump_on(st);
517   } else {
518     st-&gt;print(&quot; NULL&quot;);
519   }
520 }
521 #endif
522 
523 
524 //=============================================================================
525 int MachConstantNode::constant_offset() {
526   // Bind the offset lazily.
527   if (_constant.offset() == -1) {
528     Compile::ConstantTable&amp; constant_table = Compile::current()-&gt;constant_table();
529     int offset = constant_table.find_offset(_constant);
530     // If called from Compile::scratch_emit_size return the
531     // pre-calculated offset.
532     // NOTE: If the AD file does some table base offset optimizations
533     // later the AD file needs to take care of this fact.
534     if (Compile::current()-&gt;in_scratch_emit_size()) {
535       return constant_table.calculate_table_base_offset() + offset;
536     }
537     _constant.set_offset(constant_table.table_base_offset() + offset);
538   }
539   return _constant.offset();
540 }
541 
542 int MachConstantNode::constant_offset_unchecked() const {
543   return _constant.offset();
544 }
545 
546 //=============================================================================
547 #ifndef PRODUCT
548 void MachNullCheckNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
549   int reg = ra_-&gt;get_reg_first(in(1)-&gt;in(_vidx));
550   st-&gt;print(&quot;%s %s&quot;, Name(), Matcher::regName[reg]);
551 }
552 #endif
553 
554 void MachNullCheckNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
555   // only emits entries in the null-pointer exception handler table
556 }
557 void MachNullCheckNode::label_set(Label* label, uint block_num) {
558   // Nothing to emit
559 }
560 void MachNullCheckNode::save_label( Label** label, uint* block_num ) {
561   // Nothing to emit
562 }
563 
564 const RegMask &amp;MachNullCheckNode::in_RegMask( uint idx ) const {
565   if( idx == 0 ) return RegMask::Empty;
566   else return in(1)-&gt;as_Mach()-&gt;out_RegMask();
567 }
568 
569 //=============================================================================
570 const Type *MachProjNode::bottom_type() const {
571   if( _ideal_reg == fat_proj ) return Type::BOTTOM;
572   // Try the normal mechanism first
573   const Type *t = in(0)-&gt;bottom_type();
574   if( t-&gt;base() == Type::Tuple ) {
575     const TypeTuple *tt = t-&gt;is_tuple();
576     if (_con &lt; tt-&gt;cnt())
577       return tt-&gt;field_at(_con);
578   }
579   // Else use generic type from ideal register set
580   assert((uint)_ideal_reg &lt; (uint)_last_machine_leaf &amp;&amp; Type::mreg2type[_ideal_reg], &quot;in bounds&quot;);
581   return Type::mreg2type[_ideal_reg];
582 }
583 
584 const TypePtr *MachProjNode::adr_type() const {
585   if (bottom_type() == Type::MEMORY) {
586     // in(0) might be a narrow MemBar; otherwise we will report TypePtr::BOTTOM
587     Node* ctrl = in(0);
588     if (ctrl == NULL)  return NULL; // node is dead
589     const TypePtr* adr_type = ctrl-&gt;adr_type();
590     #ifdef ASSERT
591     if (!VMError::is_error_reported() &amp;&amp; !Node::in_dump())
592       assert(adr_type != NULL, &quot;source must have adr_type&quot;);
593     #endif
594     return adr_type;
595   }
596   assert(bottom_type()-&gt;base() != Type::Memory, &quot;no other memories?&quot;);
597   return NULL;
598 }
599 
600 #ifndef PRODUCT
601 void MachProjNode::dump_spec(outputStream *st) const {
602   ProjNode::dump_spec(st);
603   switch (_ideal_reg) {
604   case unmatched_proj:  st-&gt;print(&quot;/unmatched&quot;);                           break;
605   case fat_proj:        st-&gt;print(&quot;/fat&quot;); if (WizardMode) _rout.dump(st); break;
606   }
607 }
608 #endif
609 
610 //=============================================================================
611 #ifndef PRODUCT
612 void MachIfNode::dump_spec(outputStream *st) const {
613   st-&gt;print(&quot;P=%f, C=%f&quot;,_prob, _fcnt);
614 }
615 #endif
616 
617 //=============================================================================
618 uint MachReturnNode::size_of() const { return sizeof(*this); }
619 
620 //------------------------------Registers--------------------------------------
621 const RegMask &amp;MachReturnNode::in_RegMask( uint idx ) const {
622   return _in_rms[idx];
623 }
624 
625 const TypePtr *MachReturnNode::adr_type() const {
626   // most returns and calls are assumed to consume &amp; modify all of memory
627   // the matcher will copy non-wide adr_types from ideal originals
628   return _adr_type;
629 }
630 
631 //=============================================================================
632 const Type *MachSafePointNode::bottom_type() const {  return TypeTuple::MEMBAR; }
633 
634 //------------------------------Registers--------------------------------------
635 const RegMask &amp;MachSafePointNode::in_RegMask( uint idx ) const {
636   // Values in the domain use the users calling convention, embodied in the
637   // _in_rms array of RegMasks.
638   if( idx &lt; TypeFunc::Parms ) return _in_rms[idx];
639 
640   if (SafePointNode::needs_polling_address_input() &amp;&amp;
641       idx == TypeFunc::Parms &amp;&amp;
642       ideal_Opcode() == Op_SafePoint) {
643     return MachNode::in_RegMask(idx);
644   }
645 
646   // Values outside the domain represent debug info
647   assert(in(idx)-&gt;ideal_reg() != Op_RegFlags, &quot;flags register is not spillable&quot;);
648   return *Compile::current()-&gt;matcher()-&gt;idealreg2spillmask[in(idx)-&gt;ideal_reg()];
649 }
650 
651 
652 //=============================================================================
653 
654 uint MachCallNode::cmp( const Node &amp;n ) const
655 { return _tf == ((MachCallNode&amp;)n)._tf; }
656 const Type *MachCallNode::bottom_type() const { return tf()-&gt;range(); }
657 const Type* MachCallNode::Value(PhaseGVN* phase) const { return tf()-&gt;range(); }
658 
659 #ifndef PRODUCT
660 void MachCallNode::dump_spec(outputStream *st) const {
661   st-&gt;print(&quot;# &quot;);
662   if (tf() != NULL)  tf()-&gt;dump_on(st);
663   if (_cnt != COUNT_UNKNOWN)  st-&gt;print(&quot; C=%f&quot;,_cnt);
664   if (jvms() != NULL)  jvms()-&gt;dump_spec(st);
665 }
666 #endif
667 
668 bool MachCallNode::return_value_is_used() const {
669   if (tf()-&gt;range()-&gt;cnt() == TypeFunc::Parms) {
670     // void return
671     return false;
672   }
673 
674   // find the projection corresponding to the return value
675   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
676     Node *use = fast_out(i);
677     if (!use-&gt;is_Proj()) continue;
678     if (use-&gt;as_Proj()-&gt;_con == TypeFunc::Parms) {
679       return true;
680     }
681   }
682   return false;
683 }
684 
685 // Similar to cousin class CallNode::returns_pointer
686 // Because this is used in deoptimization, we want the type info, not the data
687 // flow info; the interpreter will &quot;use&quot; things that are dead to the optimizer.
688 bool MachCallNode::returns_pointer() const {
689   const TypeTuple *r = tf()-&gt;range();
690   return (r-&gt;cnt() &gt; TypeFunc::Parms &amp;&amp;
691           r-&gt;field_at(TypeFunc::Parms)-&gt;isa_ptr());
692 }
693 
694 //------------------------------Registers--------------------------------------
695 const RegMask &amp;MachCallNode::in_RegMask(uint idx) const {
696   // Values in the domain use the users calling convention, embodied in the
697   // _in_rms array of RegMasks.
698   if (idx &lt; tf()-&gt;domain()-&gt;cnt()) {
699     return _in_rms[idx];
700   }
701   if (idx == mach_constant_base_node_input()) {
702     return MachConstantBaseNode::static_out_RegMask();
703   }
704   // Values outside the domain represent debug info
705   return *Compile::current()-&gt;matcher()-&gt;idealreg2debugmask[in(idx)-&gt;ideal_reg()];
706 }
707 
708 //=============================================================================
709 uint MachCallJavaNode::size_of() const { return sizeof(*this); }
710 uint MachCallJavaNode::cmp( const Node &amp;n ) const {
711   MachCallJavaNode &amp;call = (MachCallJavaNode&amp;)n;
712   return MachCallNode::cmp(call) &amp;&amp; _method-&gt;equals(call._method) &amp;&amp;
713          _override_symbolic_info == call._override_symbolic_info;
714 }
715 #ifndef PRODUCT
716 void MachCallJavaNode::dump_spec(outputStream *st) const {
717   if (_method_handle_invoke)
718     st-&gt;print(&quot;MethodHandle &quot;);
719   if (_method) {
720     _method-&gt;print_short_name(st);
721     st-&gt;print(&quot; &quot;);
722   }
723   MachCallNode::dump_spec(st);
724 }
725 #endif
726 
727 //------------------------------Registers--------------------------------------
728 const RegMask &amp;MachCallJavaNode::in_RegMask(uint idx) const {
729   // Values in the domain use the users calling convention, embodied in the
730   // _in_rms array of RegMasks.
731   if (idx &lt; tf()-&gt;domain()-&gt;cnt()) {
732     return _in_rms[idx];
733   }
734   if (idx == mach_constant_base_node_input()) {
735     return MachConstantBaseNode::static_out_RegMask();
736   }
737   // Values outside the domain represent debug info
738   Matcher* m = Compile::current()-&gt;matcher();
739   // If this call is a MethodHandle invoke we have to use a different
740   // debugmask which does not include the register we use to save the
741   // SP over MH invokes.
742   RegMask** debugmask = _method_handle_invoke ? m-&gt;idealreg2mhdebugmask : m-&gt;idealreg2debugmask;
743   return *debugmask[in(idx)-&gt;ideal_reg()];
744 }
745 
746 //=============================================================================
747 uint MachCallStaticJavaNode::size_of() const { return sizeof(*this); }
748 uint MachCallStaticJavaNode::cmp( const Node &amp;n ) const {
749   MachCallStaticJavaNode &amp;call = (MachCallStaticJavaNode&amp;)n;
750   return MachCallJavaNode::cmp(call) &amp;&amp; _name == call._name;
751 }
752 
753 //----------------------------uncommon_trap_request----------------------------
754 // If this is an uncommon trap, return the request code, else zero.
755 int MachCallStaticJavaNode::uncommon_trap_request() const {
756   if (_name != NULL &amp;&amp; !strcmp(_name, &quot;uncommon_trap&quot;)) {
757     return CallStaticJavaNode::extract_uncommon_trap_request(this);
758   }
759   return 0;
760 }
761 
762 #ifndef PRODUCT
763 // Helper for summarizing uncommon_trap arguments.
764 void MachCallStaticJavaNode::dump_trap_args(outputStream *st) const {
765   int trap_req = uncommon_trap_request();
766   if (trap_req != 0) {
767     char buf[100];
768     st-&gt;print(&quot;(%s)&quot;,
769                Deoptimization::format_trap_request(buf, sizeof(buf),
770                                                    trap_req));
771   }
772 }
773 
774 void MachCallStaticJavaNode::dump_spec(outputStream *st) const {
775   st-&gt;print(&quot;Static &quot;);
776   if (_name != NULL) {
777     st-&gt;print(&quot;wrapper for: %s&quot;, _name );
778     dump_trap_args(st);
779     st-&gt;print(&quot; &quot;);
780   }
781   MachCallJavaNode::dump_spec(st);
782 }
783 #endif
784 
785 //=============================================================================
786 #ifndef PRODUCT
787 void MachCallDynamicJavaNode::dump_spec(outputStream *st) const {
788   st-&gt;print(&quot;Dynamic &quot;);
789   MachCallJavaNode::dump_spec(st);
790 }
791 #endif
792 //=============================================================================
793 uint MachCallRuntimeNode::size_of() const { return sizeof(*this); }
794 uint MachCallRuntimeNode::cmp( const Node &amp;n ) const {
795   MachCallRuntimeNode &amp;call = (MachCallRuntimeNode&amp;)n;
796   return MachCallNode::cmp(call) &amp;&amp; !strcmp(_name,call._name);
797 }
798 #ifndef PRODUCT
799 void MachCallRuntimeNode::dump_spec(outputStream *st) const {
800   st-&gt;print(&quot;%s &quot;,_name);
801   MachCallNode::dump_spec(st);
802 }
803 #endif
804 //=============================================================================
805 // A shared JVMState for all HaltNodes.  Indicates the start of debug info
806 // is at TypeFunc::Parms.  Only required for SOE register spill handling -
807 // to indicate where the stack-slot-only debug info inputs begin.
808 // There is no other JVM state needed here.
809 JVMState jvms_for_throw(0);
810 JVMState *MachHaltNode::jvms() const {
811   return &amp;jvms_for_throw;
812 }
813 
814 uint MachMemBarNode::size_of() const { return sizeof(*this); }
815 
816 const TypePtr *MachMemBarNode::adr_type() const {
817   return _adr_type;
818 }
819 
820 
821 //=============================================================================
822 #ifndef PRODUCT
823 void labelOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
824   st-&gt;print(&quot;B%d&quot;, _block_num);
825 }
826 #endif // PRODUCT
827 
828 //=============================================================================
829 #ifndef PRODUCT
830 void methodOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
831   st-&gt;print(INTPTR_FORMAT, _method);
832 }
833 #endif // PRODUCT
    </pre>
  </body>
</html>
diff a/src/hotspot/share/opto/phaseX.cpp b/src/hotspot/share/opto/phaseX.cpp
--- a/src/hotspot/share/opto/phaseX.cpp
+++ b/src/hotspot/share/opto/phaseX.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -37,10 +37,11 @@
 #include "opto/opcodes.hpp"
 #include "opto/phaseX.hpp"
 #include "opto/regalloc.hpp"
 #include "opto/rootnode.hpp"
 #include "utilities/macros.hpp"
+#include "utilities/powerOfTwo.hpp"
 
 //=============================================================================
 #define NODE_HASH_MINIMUM_SIZE    255
 //------------------------------NodeHash---------------------------------------
 NodeHash::NodeHash(uint est_max_size) :
@@ -238,16 +239,10 @@
     debug_only( counter++ );
     NOT_PRODUCT( _delete_probes++ );
     k = _table[key];            // Get hashed value
     if( !k ) {                  // Miss?
       NOT_PRODUCT( _delete_misses++ );
-#ifdef ASSERT
-      if( VerifyOpto ) {
-        for( uint i=0; i < _max; i++ )
-          assert( _table[i] != n, "changed edges with rehashing" );
-      }
-#endif
       return false;             // Miss! Not in chain
     }
     else if( n == k ) {
       NOT_PRODUCT( _delete_hits++ );
       _table[key] = _sentinel;  // Hit! Label as deleted entry
@@ -264,16 +259,13 @@
   return false;
 }
 
 //------------------------------round_up---------------------------------------
 // Round up to nearest power of 2
-uint NodeHash::round_up( uint x ) {
-  x += (x>>2);                  // Add 25% slop
-  if( x <16 ) return 16;        // Small stuff
-  uint i=16;
-  while( i < x ) i <<= 1;       // Double to fit
-  return i;                     // Return hash table size
+uint NodeHash::round_up(uint x) {
+  x += (x >> 2);                  // Add 25% slop
+  return MAX2(16U, round_up_power_of_2(x));
 }
 
 //------------------------------grow-------------------------------------------
 // Grow _table to next power of 2 and insert old entries
 void  NodeHash::grow() {
@@ -705,17 +697,10 @@
 PhaseValues::PhaseValues( PhaseValues *ptv ) : PhaseTransform( ptv, GVN ),
   _table(&ptv->_table) {
   NOT_PRODUCT( clear_new_values(); )
 }
 
-//------------------------------PhaseValues------------------------------------
-// Used by +VerifyOpto.  Clear out hash table but copy _types array.
-PhaseValues::PhaseValues( PhaseValues *ptv, const char *dummy ) : PhaseTransform( ptv, GVN ),
-  _table(ptv->arena(),ptv->_table.size()) {
-  NOT_PRODUCT( clear_new_values(); )
-}
-
 //------------------------------~PhaseValues-----------------------------------
 #ifndef PRODUCT
 PhaseValues::~PhaseValues() {
   _table.dump();
 
@@ -821,18 +806,10 @@
     i = k->Ideal(this, can_reshape);
   }
   return i;
 }
 
-Node* PhaseGVN::apply_identity(Node* k) {
-  Node* i = BarrierSet::barrier_set()->barrier_set_c2()->identity_node(this, k);
-  if (i == k) {
-    i = k->Identity(this);
-  }
-  return i;
-}
-
 //------------------------------transform--------------------------------------
 // Return a node which computes the same function as this node, but in a
 // faster or cheaper fashion.
 Node *PhaseGVN::transform( Node *n ) {
   return transform_no_reclaim(n);
@@ -883,11 +860,11 @@
     NOT_PRODUCT( set_progress(); )
     return makecon(t);          // Turn into a constant
   }
 
   // Now check for Identities
-  Node *i = apply_identity(k);  // Look for a nearby replacement
+  Node *i = k->Identity(this);  // Look for a nearby replacement
   if( i != k ) {                // Found? Return replacement!
     NOT_PRODUCT( set_progress(); )
     return i;
   }
 
@@ -902,19 +879,22 @@
   // Return Idealized original
   return k;
 }
 
 bool PhaseGVN::is_dominator_helper(Node *d, Node *n, bool linear_only) {
-  if (d->is_top() || n->is_top()) {
+  if (d->is_top() || (d->is_Proj() && d->in(0)->is_top())) {
+    return false;
+  }
+  if (n->is_top() || (n->is_Proj() && n->in(0)->is_top())) {
     return false;
   }
   assert(d->is_CFG() && n->is_CFG(), "must have CFG nodes");
   int i = 0;
   while (d != n) {
     n = IfNode::up_one_dom(n, linear_only);
     i++;
-    if (n == NULL || i >= 10) {
+    if (n == NULL || i >= 100) {
       return false;
     }
   }
   return true;
 }
@@ -946,18 +926,10 @@
   }
 }
 #endif
 
 //=============================================================================
-//------------------------------PhaseIterGVN-----------------------------------
-// Initialize hash table to fresh and clean for +VerifyOpto
-PhaseIterGVN::PhaseIterGVN( PhaseIterGVN *igvn, const char *dummy ) : PhaseGVN(igvn,dummy),
-                                                                      _delay_transform(false),
-                                                                      _stack(C->live_nodes() >> 1),
-                                                                      _worklist( ) {
-}
-
 //------------------------------PhaseIterGVN-----------------------------------
 // Initialize with previous PhaseIterGVN info; used by PhaseCCP
 PhaseIterGVN::PhaseIterGVN( PhaseIterGVN *igvn ) : PhaseGVN(igvn),
                                                    _delay_transform(igvn->_delay_transform),
                                                    _stack( igvn->_stack ),
@@ -1001,13 +973,10 @@
     if( uop == Op_Phi || uop == Op_Region ||
         n->is_Type() ||
         n->is_Mem() )
       add_users_to_worklist(n);
   }
-
-  BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();
-  bs->add_users_to_worklist(&_worklist);
 }
 
 /**
  * Initialize worklist for each node.
  */
@@ -1135,28 +1104,10 @@
     }
   }
 #endif
 
   C->verify_graph_edges();
-  if( VerifyOpto && allow_progress() ) {
-    // Must turn off allow_progress to enable assert and break recursion
-    C->root()->verify();
-    { // Check if any progress was missed using IterGVN
-      // Def-Use info enables transformations not attempted in wash-pass
-      // e.g. Region/Phi cleanup, ...
-      // Null-check elision -- may not have reached fixpoint
-      //                       do not propagate to dominated nodes
-      ResourceMark rm;
-      PhaseIterGVN igvn2(this,"Verify"); // Fresh and clean!
-      // Fill worklist completely
-      igvn2.init_worklist(C->root());
-
-      igvn2.set_allow_progress(false);
-      igvn2.optimize();
-      igvn2.set_allow_progress(true);
-    }
-  }
   if (VerifyIterativeGVN && PrintOpto) {
     if (_verify_counter == _verify_full_passes) {
       tty->print_cr("VerifyIterativeGVN: %d transforms and verify passes",
                     (int) _verify_full_passes);
     } else {
@@ -1277,26 +1228,10 @@
   C->remove_modified_node(k);
   Node* i = apply_ideal(k, /*can_reshape=*/true);
   assert(i != k || is_new || i->outcnt() > 0, "don't return dead nodes");
 #ifndef PRODUCT
   verify_step(k);
-  if (i && VerifyOpto ) {
-    if (!allow_progress()) {
-      if (i->is_Add() && (i->outcnt() == 1)) {
-        // Switched input to left side because this is the only use
-      } else if (i->is_If() && (i->in(0) == NULL)) {
-        // This IF is dead because it is dominated by an equivalent IF When
-        // dominating if changed, info is not propagated sparsely to 'this'
-        // Propagating this info further will spuriously identify other
-        // progress.
-        return i;
-      } else
-        set_progress();
-    } else {
-      set_progress();
-    }
-  }
 #endif
 
   while (i != NULL) {
 #ifdef ASSERT
     if (loop_count >= K) {
@@ -1319,13 +1254,10 @@
     C->remove_modified_node(k);
     i = apply_ideal(k, /*can_reshape=*/true);
     assert(i != k || is_new || (i->outcnt() > 0), "don't return dead nodes");
 #ifndef PRODUCT
     verify_step(k);
-    if (i && VerifyOpto) {
-      set_progress();
-    }
 #endif
   }
 
   // If brand new node, make space in type array.
   ensure_type_or_null(k);
@@ -1357,11 +1289,11 @@
     subsume_node(k, con);       // Everybody using k now uses con
     return con;
   }
 
   // Now check for Identities
-  i = apply_identity(k);      // Look for a nearby replacement
+  i = k->Identity(this);      // Look for a nearby replacement
   if (i != k) {                // Found? Return replacement!
     NOT_PRODUCT(set_progress();)
     add_users_to_worklist(k);
     subsume_node(k, i);       // Everybody using k now uses i
     return i;
@@ -1707,18 +1639,18 @@
     }
     // Loading the java mirror from a Klass requires two loads and the type
     // of the mirror load depends on the type of 'n'. See LoadNode::Value().
     //   LoadBarrier?(LoadP(LoadP(AddP(foo:Klass, #java_mirror))))
     BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();
-    bool has_load_barriers = bs->has_load_barriers();
+    bool has_load_barrier_nodes = bs->has_load_barrier_nodes();
 
     if (use_op == Op_LoadP && use->bottom_type()->isa_rawptr()) {
       for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {
         Node* u = use->fast_out(i2);
         const Type* ut = u->bottom_type();
         if (u->Opcode() == Op_LoadP && ut->isa_instptr()) {
-          if (has_load_barriers) {
+          if (has_load_barrier_nodes) {
             // Search for load barriers behind the load
             for (DUIterator_Fast i3max, i3 = u->fast_outs(i3max); i3 < i3max; i3++) {
               Node* b = u->fast_out(i3);
               if (bs->is_gc_barrier_node(b)) {
                 _worklist.push(b);
@@ -1727,12 +1659,10 @@
           }
           _worklist.push(u);
         }
       }
     }
-
-    BarrierSet::barrier_set()->barrier_set_c2()->igvn_add_users_to_worklist(this, use);
   }
 }
 
 /**
  * Remove the speculative part of all types that we know of
@@ -1830,12 +1760,15 @@
         // receiver to know when to enable the regular fall-through path
         // in addition to the NullPtrException path
         if (m->is_Call()) {
           for (DUIterator_Fast i2max, i2 = m->fast_outs(i2max); i2 < i2max; i2++) {
             Node* p = m->fast_out(i2);  // Propagate changes to uses
-            if (p->is_Proj() && p->as_Proj()->_con == TypeFunc::Control && p->outcnt() == 1) {
-              worklist.push(p->unique_out());
+            if (p->is_Proj() && p->as_Proj()->_con == TypeFunc::Control) {
+              Node* catch_node = p->find_out_with(Op_Catch);
+              if (catch_node != NULL) {
+                worklist.push(catch_node);
+              }
             }
           }
         }
         if (m->bottom_type() != type(m)) { // If not already bottomed out
           worklist.push(m);     // Propagate change to user
@@ -1867,18 +1800,18 @@
           }
         }
         // Loading the java mirror from a Klass requires two loads and the type
         // of the mirror load depends on the type of 'n'. See LoadNode::Value().
         BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();
-        bool has_load_barriers = bs->has_load_barriers();
+        bool has_load_barrier_nodes = bs->has_load_barrier_nodes();
 
         if (m_op == Op_LoadP && m->bottom_type()->isa_rawptr()) {
           for (DUIterator_Fast i2max, i2 = m->fast_outs(i2max); i2 < i2max; i2++) {
             Node* u = m->fast_out(i2);
             const Type* ut = u->bottom_type();
             if (u->Opcode() == Op_LoadP && ut->isa_instptr() && ut != type(u)) {
-              if (has_load_barriers) {
+              if (has_load_barrier_nodes) {
                 // Search for load barriers behind the load
                 for (DUIterator_Fast i3max, i3 = u->fast_outs(i3max); i3 < i3max; i3++) {
                   Node* b = u->fast_out(i3);
                   if (bs->is_gc_barrier_node(b)) {
                     worklist.push(b);
@@ -1887,12 +1820,10 @@
               }
               worklist.push(u);
             }
           }
         }
-
-        BarrierSet::barrier_set()->barrier_set_c2()->ccp_analyze(this, worklist, m);
       }
     }
   }
 }
 
@@ -2194,11 +2125,11 @@
     _max = 1;
     _types = (const Type**)_a->Amalloc( _max * sizeof(Type*) );
     _types[0] = NULL;
   }
   uint old = _max;
-  while( i >= _max ) _max <<= 1;        // Double to fit
+  _max = next_power_of_2(i);
   _types = (const Type**)_a->Arealloc( _types, old*sizeof(Type*),_max*sizeof(Type*));
   memset( &_types[old], 0, (_max-old)*sizeof(Type*) );
 }
 
 //------------------------------dump-------------------------------------------

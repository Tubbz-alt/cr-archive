<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/superword.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="subnode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="superword.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/superword.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;compiler/compileLog.hpp&quot;
  26 #include &quot;libadt/vectset.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;memory/resourceArea.hpp&quot;
  29 #include &quot;opto/addnode.hpp&quot;
  30 #include &quot;opto/callnode.hpp&quot;
  31 #include &quot;opto/castnode.hpp&quot;
  32 #include &quot;opto/convertnode.hpp&quot;
  33 #include &quot;opto/divnode.hpp&quot;
  34 #include &quot;opto/matcher.hpp&quot;
  35 #include &quot;opto/memnode.hpp&quot;
  36 #include &quot;opto/mulnode.hpp&quot;
  37 #include &quot;opto/opcodes.hpp&quot;
  38 #include &quot;opto/opaquenode.hpp&quot;
  39 #include &quot;opto/superword.hpp&quot;
  40 #include &quot;opto/vectornode.hpp&quot;
  41 #include &quot;opto/movenode.hpp&quot;

  42 
  43 //
  44 //                  S U P E R W O R D   T R A N S F O R M
  45 //=============================================================================
  46 
  47 //------------------------------SuperWord---------------------------
  48 SuperWord::SuperWord(PhaseIdealLoop* phase) :
  49   _phase(phase),
  50   _arena(phase-&gt;C-&gt;comp_arena()),
  51   _igvn(phase-&gt;_igvn),
  52   _packset(arena(), 8,  0, NULL),         // packs for the current block
  53   _bb_idx(arena(), (int)(1.10 * phase-&gt;C-&gt;unique()), 0, 0), // node idx to index in bb
  54   _block(arena(), 8,  0, NULL),           // nodes in current block
  55   _post_block(arena(), 8, 0, NULL),       // nodes common to current block which are marked as post loop vectorizable
  56   _data_entry(arena(), 8,  0, NULL),      // nodes with all inputs from outside
  57   _mem_slice_head(arena(), 8,  0, NULL),  // memory slice heads
  58   _mem_slice_tail(arena(), 8,  0, NULL),  // memory slice tails
  59   _node_info(arena(), 8,  0, SWNodeInfo::initial), // info needed per node
  60   _clone_map(phase-&gt;C-&gt;clone_map()),      // map of nodes created in cloning
  61   _cmovev_kit(_arena, this),              // map to facilitate CMoveV creation
</pre>
<hr />
<pre>
 128     #ifndef PRODUCT
 129       if (TraceSuperWord) {
 130         tty-&gt;print_cr(&quot;SuperWord::transform_loop: loop too complicated, cl_exit-&gt;in(0) != lpt-&gt;_head&quot;);
 131         tty-&gt;print(&quot;cl_exit %d&quot;, cl_exit-&gt;_idx); cl_exit-&gt;dump();
 132         tty-&gt;print(&quot;cl_exit-&gt;in(0) %d&quot;, cl_exit-&gt;in(0)-&gt;_idx); cl_exit-&gt;in(0)-&gt;dump();
 133         tty-&gt;print(&quot;lpt-&gt;_head %d&quot;, lpt-&gt;_head-&gt;_idx); lpt-&gt;_head-&gt;dump();
 134         lpt-&gt;dump_head();
 135       }
 136     #endif
 137     return;
 138   }
 139 
 140   // Make sure the are no extra control users of the loop backedge
 141   if (cl-&gt;back_control()-&gt;outcnt() != 1) {
 142     return;
 143   }
 144 
 145   // Skip any loops already optimized by slp
 146   if (cl-&gt;is_vectorized_loop()) return;
 147 
<span class="line-modified"> 148   if (cl-&gt;do_unroll_only()) return;</span>
 149 
 150   if (cl-&gt;is_main_loop()) {
 151     // Check for pre-loop ending with CountedLoopEnd(Bool(Cmp(x,Opaque1(limit))))
 152     CountedLoopEndNode* pre_end = get_pre_loop_end(cl);
 153     if (pre_end == NULL) return;
 154     Node *pre_opaq1 = pre_end-&gt;limit();
 155     if (pre_opaq1-&gt;Opcode() != Op_Opaque1) return;
 156   }
 157 
 158   init(); // initialize data structures
 159 
 160   set_lpt(lpt);
 161   set_lp(cl);
 162 
 163   // For now, define one block which is the entire loop body
 164   set_bb(cl);
 165 
 166   if (do_optimization) {
 167     assert(_packset.length() == 0, &quot;packset must be empty&quot;);
 168     SLP_extract();
</pre>
<hr />
<pre>
 559 //------------------------------find_adjacent_refs---------------------------
 560 // Find the adjacent memory references and create pack pairs for them.
 561 // This is the initial set of packs that will then be extended by
 562 // following use-&gt;def and def-&gt;use links.  The align positions are
 563 // assigned relative to the reference &quot;align_to_ref&quot;
 564 void SuperWord::find_adjacent_refs() {
 565   // Get list of memory operations
 566   Node_List memops;
 567   for (int i = 0; i &lt; _block.length(); i++) {
 568     Node* n = _block.at(i);
 569     if (n-&gt;is_Mem() &amp;&amp; !n-&gt;is_LoadStore() &amp;&amp; in_bb(n) &amp;&amp;
 570         is_java_primitive(n-&gt;as_Mem()-&gt;memory_type())) {
 571       int align = memory_alignment(n-&gt;as_Mem(), 0);
 572       if (align != bottom_align) {
 573         memops.push(n);
 574       }
 575     }
 576   }
 577 
 578   Node_List align_to_refs;

 579   int best_iv_adjustment = 0;
 580   MemNode* best_align_to_mem_ref = NULL;
 581 
 582   while (memops.size() != 0) {
 583     // Find a memory reference to align to.
<span class="line-modified"> 584     MemNode* mem_ref = find_align_to_ref(memops);</span>
 585     if (mem_ref == NULL) break;
 586     align_to_refs.push(mem_ref);
 587     int iv_adjustment = get_iv_adjustment(mem_ref);
 588 
 589     if (best_align_to_mem_ref == NULL) {
 590       // Set memory reference which is the best from all memory operations
 591       // to be used for alignment. The pre-loop trip count is modified to align
 592       // this reference to a vector-aligned address.
 593       best_align_to_mem_ref = mem_ref;
 594       best_iv_adjustment = iv_adjustment;
 595       NOT_PRODUCT(find_adjacent_refs_trace_1(best_align_to_mem_ref, best_iv_adjustment);)
 596     }
 597 
 598     SWPointer align_to_ref_p(mem_ref, this, NULL, false);
 599     // Set alignment relative to &quot;align_to_ref&quot; for all related memory operations.
 600     for (int i = memops.size() - 1; i &gt;= 0; i--) {
 601       MemNode* s = memops.at(i)-&gt;as_Mem();
 602       if (isomorphic(s, mem_ref) &amp;&amp;
 603            (!_do_vector_loop || same_origin_idx(s, mem_ref))) {
 604         SWPointer p2(s, this, NULL, false);
</pre>
<hr />
<pre>
 688       // Second, remove already constructed packs of the same type.
 689       for (int i = _packset.length() - 1; i &gt;= 0; i--) {
 690         Node_List* p = _packset.at(i);
 691         MemNode* s = p-&gt;at(0)-&gt;as_Mem();
 692         if (same_velt_type(s, mem_ref)) {
 693           remove_pack_at(i);
 694         }
 695       }
 696 
 697       // If needed find the best memory reference for loop alignment again.
 698       if (same_velt_type(mem_ref, best_align_to_mem_ref)) {
 699         // Put memory ops from remaining packs back on memops list for
 700         // the best alignment search.
 701         uint orig_msize = memops.size();
 702         for (int i = 0; i &lt; _packset.length(); i++) {
 703           Node_List* p = _packset.at(i);
 704           MemNode* s = p-&gt;at(0)-&gt;as_Mem();
 705           assert(!same_velt_type(s, mem_ref), &quot;sanity&quot;);
 706           memops.push(s);
 707         }
<span class="line-modified"> 708         best_align_to_mem_ref = find_align_to_ref(memops);</span>
 709         if (best_align_to_mem_ref == NULL) {
 710           if (TraceSuperWord) {
 711             tty-&gt;print_cr(&quot;SuperWord::find_adjacent_refs(): best_align_to_mem_ref == NULL&quot;);
 712           }
















 713           break;
 714         }
 715         best_iv_adjustment = get_iv_adjustment(best_align_to_mem_ref);
 716         NOT_PRODUCT(find_adjacent_refs_trace_1(best_align_to_mem_ref, best_iv_adjustment);)
 717         // Restore list.
 718         while (memops.size() &gt; orig_msize)
 719           (void)memops.pop();
 720       }
 721     } // unaligned memory accesses
 722 
 723     // Remove used mem nodes.
 724     for (int i = memops.size() - 1; i &gt;= 0; i--) {
 725       MemNode* m = memops.at(i)-&gt;as_Mem();
 726       if (alignment(m) != top_align) {
 727         memops.remove(i);
 728       }
 729     }
 730 
 731   } // while (memops.size() != 0
 732   set_align_to_ref(best_align_to_mem_ref);
</pre>
<hr />
<pre>
 734   if (TraceSuperWord) {
 735     tty-&gt;print_cr(&quot;\nAfter find_adjacent_refs&quot;);
 736     print_packset();
 737   }
 738 }
 739 
 740 #ifndef PRODUCT
 741 void SuperWord::find_adjacent_refs_trace_1(Node* best_align_to_mem_ref, int best_iv_adjustment) {
 742   if (is_trace_adjacent()) {
 743     tty-&gt;print(&quot;SuperWord::find_adjacent_refs best_align_to_mem_ref = %d, best_iv_adjustment = %d&quot;,
 744        best_align_to_mem_ref-&gt;_idx, best_iv_adjustment);
 745        best_align_to_mem_ref-&gt;dump();
 746   }
 747 }
 748 #endif
 749 
 750 //------------------------------find_align_to_ref---------------------------
 751 // Find a memory reference to align the loop induction variable to.
 752 // Looks first at stores then at loads, looking for a memory reference
 753 // with the largest number of references similar to it.
<span class="line-modified"> 754 MemNode* SuperWord::find_align_to_ref(Node_List &amp;memops) {</span>
 755   GrowableArray&lt;int&gt; cmp_ct(arena(), memops.size(), memops.size(), 0);
 756 
 757   // Count number of comparable memory ops
 758   for (uint i = 0; i &lt; memops.size(); i++) {
 759     MemNode* s1 = memops.at(i)-&gt;as_Mem();
 760     SWPointer p1(s1, this, NULL, false);
 761     // Discard if pre loop can&#39;t align this reference
 762     if (!ref_is_alignable(p1)) {
 763       *cmp_ct.adr_at(i) = 0;
 764       continue;
 765     }
 766     for (uint j = i+1; j &lt; memops.size(); j++) {
 767       MemNode* s2 = memops.at(j)-&gt;as_Mem();
 768       if (isomorphic(s1, s2)) {
 769         SWPointer p2(s2, this, NULL, false);
 770         if (p1.comparable(p2)) {
 771           (*cmp_ct.adr_at(i))++;
 772           (*cmp_ct.adr_at(j))++;
 773         }
 774       }
</pre>
<hr />
<pre>
 821           max_ct = cmp_ct.at(j);
 822           max_vw = vw;
 823           max_idx = j;
 824           min_size = data_size(s);
 825           min_iv_offset = p.offset_in_bytes();
 826         }
 827       }
 828     }
 829   }
 830 
 831 #ifdef ASSERT
 832   if (TraceSuperWord &amp;&amp; Verbose) {
 833     tty-&gt;print_cr(&quot;\nVector memops after find_align_to_ref&quot;);
 834     for (uint i = 0; i &lt; memops.size(); i++) {
 835       MemNode* s = memops.at(i)-&gt;as_Mem();
 836       s-&gt;dump();
 837     }
 838   }
 839 #endif
 840 

 841   if (max_ct &gt; 0) {
 842 #ifdef ASSERT
 843     if (TraceSuperWord) {
 844       tty-&gt;print(&quot;\nVector align to node: &quot;);
 845       memops.at(max_idx)-&gt;as_Mem()-&gt;dump();
 846     }
 847 #endif
 848     return memops.at(max_idx)-&gt;as_Mem();
 849   }
 850   return NULL;
 851 }
 852 
 853 //------------------span_works_for_memory_size-----------------------------
 854 static bool span_works_for_memory_size(MemNode* mem, int span, int mem_size, int offset) {
 855   bool span_matches_memory = false;
 856   if ((mem_size == type2aelembytes(T_BYTE) || mem_size == type2aelembytes(T_SHORT))
 857     &amp;&amp; ABS(span) == type2aelembytes(T_INT)) {
 858     // There is a mismatch on span size compared to memory.
 859     for (DUIterator_Fast jmax, j = mem-&gt;fast_outs(jmax); j &lt; jmax; j++) {
 860       Node* use = mem-&gt;fast_out(j);
</pre>
<hr />
<pre>
2028     Node_List* cnt_pk = my_pack(cnt);
2029     if (cnt_pk != NULL)
2030       return false;
2031     if (!same_inputs(p, 2))
2032       return false;
2033   }
2034   if (!p0-&gt;is_Store()) {
2035     // For now, return false if not all uses are vector.
2036     // Later, implement ExtractNode and allow non-vector uses (maybe
2037     // just the ones outside the block.)
2038     for (uint i = 0; i &lt; p-&gt;size(); i++) {
2039       Node* def = p-&gt;at(i);
2040       if (is_cmov_pack_internal_node(p, def)) {
2041         continue;
2042       }
2043       for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2044         Node* use = def-&gt;fast_out(j);
2045         for (uint k = 0; k &lt; use-&gt;req(); k++) {
2046           Node* n = use-&gt;in(k);
2047           if (def == n) {
<span class="line-modified">2048             // reductions should only have a Phi use at the the loop</span>
<span class="line-modified">2049             // head and out of loop uses</span>
2050             if (def-&gt;is_reduction() &amp;&amp;
2051                 ((use-&gt;is_Phi() &amp;&amp; use-&gt;in(0) == _lpt-&gt;_head) ||
<span class="line-modified">2052                  !_lpt-&gt;is_member(_phase-&gt;get_loop(_phase-&gt;ctrl_or_self(use))))) {</span>
<span class="line-removed">2053               assert(i == p-&gt;size()-1, &quot;must be last element of the pack&quot;);</span>
2054               continue;
2055             }
2056             if (!is_vector_use(use, k)) {
2057               return false;
2058             }
2059           }
2060         }
2061       }
2062     }
2063   }
2064   return true;
2065 }
2066 
2067 //------------------------------schedule---------------------------
2068 // Adjust the memory graph for the packed operations
2069 void SuperWord::schedule() {
2070 
2071   // Co-locate in the memory graph the members of each memory pack
2072   for (int i = 0; i &lt; _packset.length(); i++) {
2073     co_locate_pack(_packset.at(i));
</pre>
<hr />
<pre>
2229       } else { // !in_pack(current, pk) ==&gt; a sandwiched store
2230         remove_and_insert(current, previous, lower_insert_pt, upper_insert_pt, schedule_before_pack);
2231       }
2232 
2233       if (current == first) break;
2234       current = my_mem-&gt;as_Mem();
2235     } // end while
2236 
2237     // Reconnect loads back to upper_insert_pt.
2238     for (uint i = 0; i &lt; memops.size(); i++) {
2239       Node *ld = memops.at(i);
2240       if (ld-&gt;in(MemNode::Memory) != upper_insert_pt) {
2241         _igvn.replace_input_of(ld, MemNode::Memory, upper_insert_pt);
2242       }
2243     }
2244   } else if (pk-&gt;at(0)-&gt;is_Load()) { //load
2245     // all loads in the pack should have the same memory state. By default,
2246     // we use the memory state of the last load. However, if any load could
2247     // not be moved down due to the dependence constraint, we use the memory
2248     // state of the first load.
<span class="line-modified">2249     Node* first_mem = pk-&gt;at(0)-&gt;in(MemNode::Memory);</span>
<span class="line-modified">2250     Node* last_mem = first_mem;</span>
<span class="line-modified">2251     for (uint i = 1; i &lt; pk-&gt;size(); i++) {</span>
<span class="line-modified">2252       Node* ld = pk-&gt;at(i);</span>
<span class="line-modified">2253       Node* mem = ld-&gt;in(MemNode::Memory);</span>
<span class="line-modified">2254       assert(in_bb(first_mem) || in_bb(mem) || mem == first_mem, &quot;2 different memory state from outside the loop?&quot;);</span>
<span class="line-modified">2255       if (in_bb(mem)) {</span>
<span class="line-modified">2256         if (in_bb(first_mem) &amp;&amp; bb_idx(mem) &lt; bb_idx(first_mem)) {</span>
<span class="line-modified">2257           first_mem = mem;</span>
<span class="line-modified">2258         }</span>
<span class="line-modified">2259         if (!in_bb(last_mem) || bb_idx(mem) &gt; bb_idx(last_mem)) {</span>
<span class="line-modified">2260           last_mem = mem;</span>

2261         }
2262       }
2263     }






2264     bool schedule_last = true;
2265     for (uint i = 0; i &lt; pk-&gt;size(); i++) {
2266       Node* ld = pk-&gt;at(i);
<span class="line-modified">2267       for (Node* current = last_mem; current != ld-&gt;in(MemNode::Memory);</span>
<span class="line-modified">2268            current=current-&gt;in(MemNode::Memory)) {</span>
<span class="line-modified">2269         assert(current != first_mem, &quot;corrupted memory graph&quot;);</span>
<span class="line-modified">2270         if(current-&gt;is_Mem() &amp;&amp; !independent(current, ld)){</span>


2271           schedule_last = false; // a later store depends on this load
<span class="line-removed">2272           break;</span>
2273         }
2274       }
2275     }
2276 
2277     Node* mem_input = schedule_last ? last_mem : first_mem;
2278     _igvn.hash_delete(mem_input);
2279     // Give each load the same memory state
2280     for (uint i = 0; i &lt; pk-&gt;size(); i++) {
2281       LoadNode* ld = pk-&gt;at(i)-&gt;as_Load();
2282       _igvn.replace_input_of(ld, MemNode::Memory, mem_input);
2283     }
2284   }
2285 }
2286 
2287 #ifndef PRODUCT
2288 void SuperWord::print_loop(bool whole) {
2289   Node_Stack stack(_arena, _phase-&gt;C-&gt;unique() &gt;&gt; 2);
2290   Node_List rpo_list;
2291   VectorSet visited(_arena);
2292   visited.set(lpt()-&gt;_head-&gt;_idx);
</pre>
<hr />
<pre>
2385         const TypePtr* atyp = n-&gt;adr_type();
2386         vn = LoadVectorNode::make(opc, ctl, mem, adr, atyp, vlen, velt_basic_type(n), control_dependency(p));
2387         vlen_in_bytes = vn-&gt;as_LoadVector()-&gt;memory_size();
2388       } else if (n-&gt;is_Store()) {
2389         // Promote value to be stored to vector
2390         Node* val = vector_opd(p, MemNode::ValueIn);
2391         if (val == NULL) {
2392           if (do_reserve_copy()) {
2393             NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: val should not be NULL, exiting SuperWord&quot;);})
2394             return; //and reverse to backup IG
2395           }
2396           ShouldNotReachHere();
2397         }
2398 
2399         Node* ctl = n-&gt;in(MemNode::Control);
2400         Node* mem = first-&gt;in(MemNode::Memory);
2401         Node* adr = low_adr-&gt;in(MemNode::Address);
2402         const TypePtr* atyp = n-&gt;adr_type();
2403         vn = StoreVectorNode::make(opc, ctl, mem, adr, atyp, val, vlen);
2404         vlen_in_bytes = vn-&gt;as_StoreVector()-&gt;memory_size();






2405       } else if (VectorNode::is_muladds2i(n)) {
2406         assert(n-&gt;req() == 5u, &quot;MulAddS2I should have 4 operands.&quot;);
2407         Node* in1 = vector_opd(p, 1);
2408         Node* in2 = vector_opd(p, 2);
2409         vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));
2410         vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2411       } else if (n-&gt;req() == 3 &amp;&amp; !is_cmov_pack(p)) {
2412         // Promote operands to vector
2413         Node* in1 = NULL;
2414         bool node_isa_reduction = n-&gt;is_reduction();
2415         if (node_isa_reduction) {
2416           // the input to the first reduction operation is retained
2417           in1 = low_adr-&gt;in(1);
2418         } else {
2419           in1 = vector_opd(p, 1);
2420           if (in1 == NULL) {
2421             if (do_reserve_copy()) {
2422               NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: in1 should not be NULL, exiting SuperWord&quot;);})
2423               return; //and reverse to backup IG
2424             }
</pre>
<hr />
<pre>
2436         if (VectorNode::is_invariant_vector(in1) &amp;&amp; (node_isa_reduction == false) &amp;&amp; (n-&gt;is_Add() || n-&gt;is_Mul())) {
2437           // Move invariant vector input into second position to avoid register spilling.
2438           Node* tmp = in1;
2439           in1 = in2;
2440           in2 = tmp;
2441         }
2442         if (node_isa_reduction) {
2443           const Type *arith_type = n-&gt;bottom_type();
2444           vn = ReductionNode::make(opc, NULL, in1, in2, arith_type-&gt;basic_type());
2445           if (in2-&gt;is_Load()) {
2446             vlen_in_bytes = in2-&gt;as_LoadVector()-&gt;memory_size();
2447           } else {
2448             vlen_in_bytes = in2-&gt;as_Vector()-&gt;length_in_bytes();
2449           }
2450         } else {
2451           vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));
2452           vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2453         }
2454       } else if (opc == Op_SqrtF || opc == Op_SqrtD ||
2455                  opc == Op_AbsF || opc == Op_AbsD ||

2456                  opc == Op_NegF || opc == Op_NegD ||
2457                  opc == Op_PopCountI) {
2458         assert(n-&gt;req() == 2, &quot;only one input expected&quot;);
2459         Node* in = vector_opd(p, 1);
2460         vn = VectorNode::make(opc, in, NULL, vlen, velt_basic_type(n));
2461         vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2462       } else if (is_cmov_pack(p)) {
2463         if (can_process_post_loop) {
2464           // do not refactor of flow in post loop context
2465           return;
2466         }
2467         if (!n-&gt;is_CMove()) {
2468           continue;
2469         }
2470         // place here CMoveVDNode
2471         NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print_cr(&quot;SWPointer::output: print before CMove vectorization&quot;); print_loop(false);})
2472         Node* bol = n-&gt;in(CMoveNode::Condition);
2473         if (!bol-&gt;is_Bool() &amp;&amp; bol-&gt;Opcode() == Op_ExtractI &amp;&amp; bol-&gt;req() &gt; 1 ) {
2474           NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print_cr(&quot;SWPointer::output: %d is not Bool node, trying its in(1) node %d&quot;, bol-&gt;_idx, bol-&gt;in(1)-&gt;_idx); bol-&gt;dump(); bol-&gt;in(1)-&gt;dump();})
2475           bol = bol-&gt;in(1); //may be ExtractNode
</pre>
<hr />
<pre>
2657       juint mask = (p0-&gt;bottom_type() == TypeInt::INT) ? (BitsPerInt - 1) : (BitsPerLong - 1);
2658       const TypeInt* t = opd-&gt;find_int_type();
2659       if (t != NULL &amp;&amp; t-&gt;is_con()) {
2660         juint shift = t-&gt;get_con();
2661         if (shift &gt; mask) { // Unsigned cmp
2662           cnt = ConNode::make(TypeInt::make(shift &amp; mask));
2663         }
2664       } else {
2665         if (t == NULL || t-&gt;_lo &lt; 0 || t-&gt;_hi &gt; (int)mask) {
2666           cnt = ConNode::make(TypeInt::make(mask));
2667           _igvn.register_new_node_with_optimizer(cnt);
2668           cnt = new AndINode(opd, cnt);
2669           _igvn.register_new_node_with_optimizer(cnt);
2670           _phase-&gt;set_ctrl(cnt, _phase-&gt;get_ctrl(opd));
2671         }
2672         assert(opd-&gt;bottom_type()-&gt;isa_int(), &quot;int type only&quot;);
2673         if (!opd-&gt;bottom_type()-&gt;isa_int()) {
2674           NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;Should be int type only&quot;);})
2675           return NULL;
2676         }
<span class="line-removed">2677         // Move non constant shift count into vector register.</span>
<span class="line-removed">2678         cnt = VectorNode::shift_count(p0, cnt, vlen, velt_basic_type(p0));</span>
<span class="line-removed">2679       }</span>
<span class="line-removed">2680       if (cnt != opd) {</span>
<span class="line-removed">2681         _igvn.register_new_node_with_optimizer(cnt);</span>
<span class="line-removed">2682         _phase-&gt;set_ctrl(cnt, _phase-&gt;get_ctrl(opd));</span>
2683       }




2684       return cnt;
2685     }
2686     assert(!opd-&gt;is_StoreVector(), &quot;such vector is not expected here&quot;);
2687     if (opd-&gt;is_StoreVector()) {
2688       NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;StoreVector is not expected here&quot;);})
2689       return NULL;
2690     }
2691     // Convert scalar input to vector with the same number of elements as
2692     // p0&#39;s vector. Use p0&#39;s type because size of operand&#39;s container in
2693     // vector should match p0&#39;s size regardless operand&#39;s size.
2694     const Type* p0_t = velt_type(p0);
2695     VectorNode* vn = VectorNode::scalar2vector(opd, vlen, p0_t);
2696 
2697     _igvn.register_new_node_with_optimizer(vn);
2698     _phase-&gt;set_ctrl(vn, _phase-&gt;get_ctrl(opd));
2699 #ifdef ASSERT
2700     if (TraceNewVectors) {
2701       tty-&gt;print(&quot;new Vector node: &quot;);
2702       vn-&gt;dump();
2703     }
</pre>
<hr />
<pre>
3278 Node* SuperWord::executed_last(Node_List* p) {
3279   Node* n = p-&gt;at(0);
3280   int n_rpo = bb_idx(n);
3281   for (uint i = 1; i &lt; p-&gt;size(); i++) {
3282     Node* s = p-&gt;at(i);
3283     int s_rpo = bb_idx(s);
3284     if (s_rpo &gt; n_rpo) {
3285       n = s;
3286       n_rpo = s_rpo;
3287     }
3288   }
3289   return n;
3290 }
3291 
3292 LoadNode::ControlDependency SuperWord::control_dependency(Node_List* p) {
3293   LoadNode::ControlDependency dep = LoadNode::DependsOnlyOnTest;
3294   for (uint i = 0; i &lt; p-&gt;size(); i++) {
3295     Node* n = p-&gt;at(i);
3296     assert(n-&gt;is_Load(), &quot;only meaningful for loads&quot;);
3297     if (!n-&gt;depends_only_on_test()) {
<span class="line-modified">3298       dep = LoadNode::Pinned;</span>







3299     }
3300   }
3301   return dep;
3302 }
3303 
3304 
3305 //----------------------------align_initial_loop_index---------------------------
3306 // Adjust pre-loop limit so that in main loop, a load/store reference
3307 // to align_to_ref will be a position zero in the vector.
3308 //   (iv + k) mod vector_align == 0
3309 void SuperWord::align_initial_loop_index(MemNode* align_to_ref) {
3310   CountedLoopNode *main_head = lp()-&gt;as_CountedLoop();
3311   assert(main_head-&gt;is_main_loop(), &quot;&quot;);
3312   CountedLoopEndNode* pre_end = get_pre_loop_end(main_head);
3313   assert(pre_end != NULL, &quot;we must have a correct pre-loop&quot;);
3314   Node *pre_opaq1 = pre_end-&gt;limit();
3315   assert(pre_opaq1-&gt;Opcode() == Op_Opaque1, &quot;&quot;);
3316   Opaque1Node *pre_opaq = (Opaque1Node*)pre_opaq1;
3317   Node *lim0 = pre_opaq-&gt;in(1);
3318 
</pre>
</td>
<td>
<hr />
<pre>
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;compiler/compileLog.hpp&quot;
  26 #include &quot;libadt/vectset.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;memory/resourceArea.hpp&quot;
  29 #include &quot;opto/addnode.hpp&quot;
  30 #include &quot;opto/callnode.hpp&quot;
  31 #include &quot;opto/castnode.hpp&quot;
  32 #include &quot;opto/convertnode.hpp&quot;
  33 #include &quot;opto/divnode.hpp&quot;
  34 #include &quot;opto/matcher.hpp&quot;
  35 #include &quot;opto/memnode.hpp&quot;
  36 #include &quot;opto/mulnode.hpp&quot;
  37 #include &quot;opto/opcodes.hpp&quot;
  38 #include &quot;opto/opaquenode.hpp&quot;
  39 #include &quot;opto/superword.hpp&quot;
  40 #include &quot;opto/vectornode.hpp&quot;
  41 #include &quot;opto/movenode.hpp&quot;
<span class="line-added">  42 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  43 
  44 //
  45 //                  S U P E R W O R D   T R A N S F O R M
  46 //=============================================================================
  47 
  48 //------------------------------SuperWord---------------------------
  49 SuperWord::SuperWord(PhaseIdealLoop* phase) :
  50   _phase(phase),
  51   _arena(phase-&gt;C-&gt;comp_arena()),
  52   _igvn(phase-&gt;_igvn),
  53   _packset(arena(), 8,  0, NULL),         // packs for the current block
  54   _bb_idx(arena(), (int)(1.10 * phase-&gt;C-&gt;unique()), 0, 0), // node idx to index in bb
  55   _block(arena(), 8,  0, NULL),           // nodes in current block
  56   _post_block(arena(), 8, 0, NULL),       // nodes common to current block which are marked as post loop vectorizable
  57   _data_entry(arena(), 8,  0, NULL),      // nodes with all inputs from outside
  58   _mem_slice_head(arena(), 8,  0, NULL),  // memory slice heads
  59   _mem_slice_tail(arena(), 8,  0, NULL),  // memory slice tails
  60   _node_info(arena(), 8,  0, SWNodeInfo::initial), // info needed per node
  61   _clone_map(phase-&gt;C-&gt;clone_map()),      // map of nodes created in cloning
  62   _cmovev_kit(_arena, this),              // map to facilitate CMoveV creation
</pre>
<hr />
<pre>
 129     #ifndef PRODUCT
 130       if (TraceSuperWord) {
 131         tty-&gt;print_cr(&quot;SuperWord::transform_loop: loop too complicated, cl_exit-&gt;in(0) != lpt-&gt;_head&quot;);
 132         tty-&gt;print(&quot;cl_exit %d&quot;, cl_exit-&gt;_idx); cl_exit-&gt;dump();
 133         tty-&gt;print(&quot;cl_exit-&gt;in(0) %d&quot;, cl_exit-&gt;in(0)-&gt;_idx); cl_exit-&gt;in(0)-&gt;dump();
 134         tty-&gt;print(&quot;lpt-&gt;_head %d&quot;, lpt-&gt;_head-&gt;_idx); lpt-&gt;_head-&gt;dump();
 135         lpt-&gt;dump_head();
 136       }
 137     #endif
 138     return;
 139   }
 140 
 141   // Make sure the are no extra control users of the loop backedge
 142   if (cl-&gt;back_control()-&gt;outcnt() != 1) {
 143     return;
 144   }
 145 
 146   // Skip any loops already optimized by slp
 147   if (cl-&gt;is_vectorized_loop()) return;
 148 
<span class="line-modified"> 149   if (cl-&gt;is_unroll_only()) return;</span>
 150 
 151   if (cl-&gt;is_main_loop()) {
 152     // Check for pre-loop ending with CountedLoopEnd(Bool(Cmp(x,Opaque1(limit))))
 153     CountedLoopEndNode* pre_end = get_pre_loop_end(cl);
 154     if (pre_end == NULL) return;
 155     Node *pre_opaq1 = pre_end-&gt;limit();
 156     if (pre_opaq1-&gt;Opcode() != Op_Opaque1) return;
 157   }
 158 
 159   init(); // initialize data structures
 160 
 161   set_lpt(lpt);
 162   set_lp(cl);
 163 
 164   // For now, define one block which is the entire loop body
 165   set_bb(cl);
 166 
 167   if (do_optimization) {
 168     assert(_packset.length() == 0, &quot;packset must be empty&quot;);
 169     SLP_extract();
</pre>
<hr />
<pre>
 560 //------------------------------find_adjacent_refs---------------------------
 561 // Find the adjacent memory references and create pack pairs for them.
 562 // This is the initial set of packs that will then be extended by
 563 // following use-&gt;def and def-&gt;use links.  The align positions are
 564 // assigned relative to the reference &quot;align_to_ref&quot;
 565 void SuperWord::find_adjacent_refs() {
 566   // Get list of memory operations
 567   Node_List memops;
 568   for (int i = 0; i &lt; _block.length(); i++) {
 569     Node* n = _block.at(i);
 570     if (n-&gt;is_Mem() &amp;&amp; !n-&gt;is_LoadStore() &amp;&amp; in_bb(n) &amp;&amp;
 571         is_java_primitive(n-&gt;as_Mem()-&gt;memory_type())) {
 572       int align = memory_alignment(n-&gt;as_Mem(), 0);
 573       if (align != bottom_align) {
 574         memops.push(n);
 575       }
 576     }
 577   }
 578 
 579   Node_List align_to_refs;
<span class="line-added"> 580   int max_idx;</span>
 581   int best_iv_adjustment = 0;
 582   MemNode* best_align_to_mem_ref = NULL;
 583 
 584   while (memops.size() != 0) {
 585     // Find a memory reference to align to.
<span class="line-modified"> 586     MemNode* mem_ref = find_align_to_ref(memops, max_idx);</span>
 587     if (mem_ref == NULL) break;
 588     align_to_refs.push(mem_ref);
 589     int iv_adjustment = get_iv_adjustment(mem_ref);
 590 
 591     if (best_align_to_mem_ref == NULL) {
 592       // Set memory reference which is the best from all memory operations
 593       // to be used for alignment. The pre-loop trip count is modified to align
 594       // this reference to a vector-aligned address.
 595       best_align_to_mem_ref = mem_ref;
 596       best_iv_adjustment = iv_adjustment;
 597       NOT_PRODUCT(find_adjacent_refs_trace_1(best_align_to_mem_ref, best_iv_adjustment);)
 598     }
 599 
 600     SWPointer align_to_ref_p(mem_ref, this, NULL, false);
 601     // Set alignment relative to &quot;align_to_ref&quot; for all related memory operations.
 602     for (int i = memops.size() - 1; i &gt;= 0; i--) {
 603       MemNode* s = memops.at(i)-&gt;as_Mem();
 604       if (isomorphic(s, mem_ref) &amp;&amp;
 605            (!_do_vector_loop || same_origin_idx(s, mem_ref))) {
 606         SWPointer p2(s, this, NULL, false);
</pre>
<hr />
<pre>
 690       // Second, remove already constructed packs of the same type.
 691       for (int i = _packset.length() - 1; i &gt;= 0; i--) {
 692         Node_List* p = _packset.at(i);
 693         MemNode* s = p-&gt;at(0)-&gt;as_Mem();
 694         if (same_velt_type(s, mem_ref)) {
 695           remove_pack_at(i);
 696         }
 697       }
 698 
 699       // If needed find the best memory reference for loop alignment again.
 700       if (same_velt_type(mem_ref, best_align_to_mem_ref)) {
 701         // Put memory ops from remaining packs back on memops list for
 702         // the best alignment search.
 703         uint orig_msize = memops.size();
 704         for (int i = 0; i &lt; _packset.length(); i++) {
 705           Node_List* p = _packset.at(i);
 706           MemNode* s = p-&gt;at(0)-&gt;as_Mem();
 707           assert(!same_velt_type(s, mem_ref), &quot;sanity&quot;);
 708           memops.push(s);
 709         }
<span class="line-modified"> 710         best_align_to_mem_ref = find_align_to_ref(memops, max_idx);</span>
 711         if (best_align_to_mem_ref == NULL) {
 712           if (TraceSuperWord) {
 713             tty-&gt;print_cr(&quot;SuperWord::find_adjacent_refs(): best_align_to_mem_ref == NULL&quot;);
 714           }
<span class="line-added"> 715           // best_align_to_mem_ref will be used for adjusting the pre-loop limit in</span>
<span class="line-added"> 716           // SuperWord::align_initial_loop_index. Find one with the biggest vector size,</span>
<span class="line-added"> 717           // smallest data size and smallest iv offset from memory ops from remaining packs.</span>
<span class="line-added"> 718           if (_packset.length() &gt; 0) {</span>
<span class="line-added"> 719             if (orig_msize == 0) {</span>
<span class="line-added"> 720               best_align_to_mem_ref = memops.at(max_idx)-&gt;as_Mem();</span>
<span class="line-added"> 721             } else {</span>
<span class="line-added"> 722               for (uint i = 0; i &lt; orig_msize; i++) {</span>
<span class="line-added"> 723                 memops.remove(0);</span>
<span class="line-added"> 724               }</span>
<span class="line-added"> 725               best_align_to_mem_ref = find_align_to_ref(memops, max_idx);</span>
<span class="line-added"> 726               assert(best_align_to_mem_ref == NULL, &quot;sanity&quot;);</span>
<span class="line-added"> 727               best_align_to_mem_ref = memops.at(max_idx)-&gt;as_Mem();</span>
<span class="line-added"> 728             }</span>
<span class="line-added"> 729             assert(best_align_to_mem_ref != NULL, &quot;sanity&quot;);</span>
<span class="line-added"> 730           }</span>
 731           break;
 732         }
 733         best_iv_adjustment = get_iv_adjustment(best_align_to_mem_ref);
 734         NOT_PRODUCT(find_adjacent_refs_trace_1(best_align_to_mem_ref, best_iv_adjustment);)
 735         // Restore list.
 736         while (memops.size() &gt; orig_msize)
 737           (void)memops.pop();
 738       }
 739     } // unaligned memory accesses
 740 
 741     // Remove used mem nodes.
 742     for (int i = memops.size() - 1; i &gt;= 0; i--) {
 743       MemNode* m = memops.at(i)-&gt;as_Mem();
 744       if (alignment(m) != top_align) {
 745         memops.remove(i);
 746       }
 747     }
 748 
 749   } // while (memops.size() != 0
 750   set_align_to_ref(best_align_to_mem_ref);
</pre>
<hr />
<pre>
 752   if (TraceSuperWord) {
 753     tty-&gt;print_cr(&quot;\nAfter find_adjacent_refs&quot;);
 754     print_packset();
 755   }
 756 }
 757 
 758 #ifndef PRODUCT
 759 void SuperWord::find_adjacent_refs_trace_1(Node* best_align_to_mem_ref, int best_iv_adjustment) {
 760   if (is_trace_adjacent()) {
 761     tty-&gt;print(&quot;SuperWord::find_adjacent_refs best_align_to_mem_ref = %d, best_iv_adjustment = %d&quot;,
 762        best_align_to_mem_ref-&gt;_idx, best_iv_adjustment);
 763        best_align_to_mem_ref-&gt;dump();
 764   }
 765 }
 766 #endif
 767 
 768 //------------------------------find_align_to_ref---------------------------
 769 // Find a memory reference to align the loop induction variable to.
 770 // Looks first at stores then at loads, looking for a memory reference
 771 // with the largest number of references similar to it.
<span class="line-modified"> 772 MemNode* SuperWord::find_align_to_ref(Node_List &amp;memops, int &amp;idx) {</span>
 773   GrowableArray&lt;int&gt; cmp_ct(arena(), memops.size(), memops.size(), 0);
 774 
 775   // Count number of comparable memory ops
 776   for (uint i = 0; i &lt; memops.size(); i++) {
 777     MemNode* s1 = memops.at(i)-&gt;as_Mem();
 778     SWPointer p1(s1, this, NULL, false);
 779     // Discard if pre loop can&#39;t align this reference
 780     if (!ref_is_alignable(p1)) {
 781       *cmp_ct.adr_at(i) = 0;
 782       continue;
 783     }
 784     for (uint j = i+1; j &lt; memops.size(); j++) {
 785       MemNode* s2 = memops.at(j)-&gt;as_Mem();
 786       if (isomorphic(s1, s2)) {
 787         SWPointer p2(s2, this, NULL, false);
 788         if (p1.comparable(p2)) {
 789           (*cmp_ct.adr_at(i))++;
 790           (*cmp_ct.adr_at(j))++;
 791         }
 792       }
</pre>
<hr />
<pre>
 839           max_ct = cmp_ct.at(j);
 840           max_vw = vw;
 841           max_idx = j;
 842           min_size = data_size(s);
 843           min_iv_offset = p.offset_in_bytes();
 844         }
 845       }
 846     }
 847   }
 848 
 849 #ifdef ASSERT
 850   if (TraceSuperWord &amp;&amp; Verbose) {
 851     tty-&gt;print_cr(&quot;\nVector memops after find_align_to_ref&quot;);
 852     for (uint i = 0; i &lt; memops.size(); i++) {
 853       MemNode* s = memops.at(i)-&gt;as_Mem();
 854       s-&gt;dump();
 855     }
 856   }
 857 #endif
 858 
<span class="line-added"> 859   idx = max_idx;</span>
 860   if (max_ct &gt; 0) {
 861 #ifdef ASSERT
 862     if (TraceSuperWord) {
 863       tty-&gt;print(&quot;\nVector align to node: &quot;);
 864       memops.at(max_idx)-&gt;as_Mem()-&gt;dump();
 865     }
 866 #endif
 867     return memops.at(max_idx)-&gt;as_Mem();
 868   }
 869   return NULL;
 870 }
 871 
 872 //------------------span_works_for_memory_size-----------------------------
 873 static bool span_works_for_memory_size(MemNode* mem, int span, int mem_size, int offset) {
 874   bool span_matches_memory = false;
 875   if ((mem_size == type2aelembytes(T_BYTE) || mem_size == type2aelembytes(T_SHORT))
 876     &amp;&amp; ABS(span) == type2aelembytes(T_INT)) {
 877     // There is a mismatch on span size compared to memory.
 878     for (DUIterator_Fast jmax, j = mem-&gt;fast_outs(jmax); j &lt; jmax; j++) {
 879       Node* use = mem-&gt;fast_out(j);
</pre>
<hr />
<pre>
2047     Node_List* cnt_pk = my_pack(cnt);
2048     if (cnt_pk != NULL)
2049       return false;
2050     if (!same_inputs(p, 2))
2051       return false;
2052   }
2053   if (!p0-&gt;is_Store()) {
2054     // For now, return false if not all uses are vector.
2055     // Later, implement ExtractNode and allow non-vector uses (maybe
2056     // just the ones outside the block.)
2057     for (uint i = 0; i &lt; p-&gt;size(); i++) {
2058       Node* def = p-&gt;at(i);
2059       if (is_cmov_pack_internal_node(p, def)) {
2060         continue;
2061       }
2062       for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2063         Node* use = def-&gt;fast_out(j);
2064         for (uint k = 0; k &lt; use-&gt;req(); k++) {
2065           Node* n = use-&gt;in(k);
2066           if (def == n) {
<span class="line-modified">2067             // Reductions should only have a Phi use at the loop head or a non-phi use</span>
<span class="line-modified">2068             // outside of the loop if it is the last element of the pack (e.g. SafePoint).</span>
2069             if (def-&gt;is_reduction() &amp;&amp;
2070                 ((use-&gt;is_Phi() &amp;&amp; use-&gt;in(0) == _lpt-&gt;_head) ||
<span class="line-modified">2071                  (!_lpt-&gt;is_member(_phase-&gt;get_loop(_phase-&gt;ctrl_or_self(use))) &amp;&amp; i == p-&gt;size()-1))) {</span>

2072               continue;
2073             }
2074             if (!is_vector_use(use, k)) {
2075               return false;
2076             }
2077           }
2078         }
2079       }
2080     }
2081   }
2082   return true;
2083 }
2084 
2085 //------------------------------schedule---------------------------
2086 // Adjust the memory graph for the packed operations
2087 void SuperWord::schedule() {
2088 
2089   // Co-locate in the memory graph the members of each memory pack
2090   for (int i = 0; i &lt; _packset.length(); i++) {
2091     co_locate_pack(_packset.at(i));
</pre>
<hr />
<pre>
2247       } else { // !in_pack(current, pk) ==&gt; a sandwiched store
2248         remove_and_insert(current, previous, lower_insert_pt, upper_insert_pt, schedule_before_pack);
2249       }
2250 
2251       if (current == first) break;
2252       current = my_mem-&gt;as_Mem();
2253     } // end while
2254 
2255     // Reconnect loads back to upper_insert_pt.
2256     for (uint i = 0; i &lt; memops.size(); i++) {
2257       Node *ld = memops.at(i);
2258       if (ld-&gt;in(MemNode::Memory) != upper_insert_pt) {
2259         _igvn.replace_input_of(ld, MemNode::Memory, upper_insert_pt);
2260       }
2261     }
2262   } else if (pk-&gt;at(0)-&gt;is_Load()) { //load
2263     // all loads in the pack should have the same memory state. By default,
2264     // we use the memory state of the last load. However, if any load could
2265     // not be moved down due to the dependence constraint, we use the memory
2266     // state of the first load.
<span class="line-modified">2267     Node* last_mem  = pk-&gt;at(0)-&gt;in(MemNode::Memory);</span>
<span class="line-modified">2268     Node* first_mem = last_mem;</span>
<span class="line-modified">2269     // Walk the memory graph from the current first load until the</span>
<span class="line-modified">2270     // start of the loop and check if nodes on the way are memory</span>
<span class="line-modified">2271     // edges of loads in the pack. The last one we encounter is the</span>
<span class="line-modified">2272     // first load.</span>
<span class="line-modified">2273     for (Node* current = first_mem; in_bb(current); current = current-&gt;is_Phi() ? current-&gt;in(LoopNode::EntryControl) : current-&gt;in(MemNode::Memory)) {</span>
<span class="line-modified">2274      assert(current-&gt;is_Mem() || (current-&gt;is_Phi() &amp;&amp; current-&gt;in(0) == bb()), &quot;unexpected memory&quot;);</span>
<span class="line-modified">2275      for (uint i = 1; i &lt; pk-&gt;size(); i++) {</span>
<span class="line-modified">2276         Node* ld = pk-&gt;at(i);</span>
<span class="line-modified">2277         if (ld-&gt;in(MemNode::Memory) == current) {</span>
<span class="line-modified">2278           first_mem = current;</span>
<span class="line-added">2279           break;</span>
2280         }
2281       }
2282     }
<span class="line-added">2283     // Find the last load by going over the pack again and walking</span>
<span class="line-added">2284     // the memory graph from the loads of the pack to the memory of</span>
<span class="line-added">2285     // the first load. If we encounter the memory of the current last</span>
<span class="line-added">2286     // load, then we started from further down in the memory graph and</span>
<span class="line-added">2287     // the load we started from is the last load. Check for dependence</span>
<span class="line-added">2288     // constraints in that loop as well.</span>
2289     bool schedule_last = true;
2290     for (uint i = 0; i &lt; pk-&gt;size(); i++) {
2291       Node* ld = pk-&gt;at(i);
<span class="line-modified">2292       for (Node* current = ld-&gt;in(MemNode::Memory); current != first_mem; current = current-&gt;in(MemNode::Memory)) {</span>
<span class="line-modified">2293         assert(current-&gt;is_Mem() &amp;&amp; in_bb(current), &quot;unexpected memory&quot;);</span>
<span class="line-modified">2294         if (current-&gt;in(MemNode::Memory) == last_mem) {</span>
<span class="line-modified">2295           last_mem = ld-&gt;in(MemNode::Memory);</span>
<span class="line-added">2296         }</span>
<span class="line-added">2297         if (!independent(current, ld)) {</span>
2298           schedule_last = false; // a later store depends on this load

2299         }
2300       }
2301     }
2302 
2303     Node* mem_input = schedule_last ? last_mem : first_mem;
2304     _igvn.hash_delete(mem_input);
2305     // Give each load the same memory state
2306     for (uint i = 0; i &lt; pk-&gt;size(); i++) {
2307       LoadNode* ld = pk-&gt;at(i)-&gt;as_Load();
2308       _igvn.replace_input_of(ld, MemNode::Memory, mem_input);
2309     }
2310   }
2311 }
2312 
2313 #ifndef PRODUCT
2314 void SuperWord::print_loop(bool whole) {
2315   Node_Stack stack(_arena, _phase-&gt;C-&gt;unique() &gt;&gt; 2);
2316   Node_List rpo_list;
2317   VectorSet visited(_arena);
2318   visited.set(lpt()-&gt;_head-&gt;_idx);
</pre>
<hr />
<pre>
2411         const TypePtr* atyp = n-&gt;adr_type();
2412         vn = LoadVectorNode::make(opc, ctl, mem, adr, atyp, vlen, velt_basic_type(n), control_dependency(p));
2413         vlen_in_bytes = vn-&gt;as_LoadVector()-&gt;memory_size();
2414       } else if (n-&gt;is_Store()) {
2415         // Promote value to be stored to vector
2416         Node* val = vector_opd(p, MemNode::ValueIn);
2417         if (val == NULL) {
2418           if (do_reserve_copy()) {
2419             NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: val should not be NULL, exiting SuperWord&quot;);})
2420             return; //and reverse to backup IG
2421           }
2422           ShouldNotReachHere();
2423         }
2424 
2425         Node* ctl = n-&gt;in(MemNode::Control);
2426         Node* mem = first-&gt;in(MemNode::Memory);
2427         Node* adr = low_adr-&gt;in(MemNode::Address);
2428         const TypePtr* atyp = n-&gt;adr_type();
2429         vn = StoreVectorNode::make(opc, ctl, mem, adr, atyp, val, vlen);
2430         vlen_in_bytes = vn-&gt;as_StoreVector()-&gt;memory_size();
<span class="line-added">2431       } else if (VectorNode::is_roundopD(n)) {</span>
<span class="line-added">2432         Node* in1 = vector_opd(p, 1);</span>
<span class="line-added">2433         Node* in2 = low_adr-&gt;in(2);</span>
<span class="line-added">2434         assert(in2-&gt;is_Con(), &quot;Constant rounding mode expected.&quot;);</span>
<span class="line-added">2435         vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));</span>
<span class="line-added">2436         vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();</span>
2437       } else if (VectorNode::is_muladds2i(n)) {
2438         assert(n-&gt;req() == 5u, &quot;MulAddS2I should have 4 operands.&quot;);
2439         Node* in1 = vector_opd(p, 1);
2440         Node* in2 = vector_opd(p, 2);
2441         vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));
2442         vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2443       } else if (n-&gt;req() == 3 &amp;&amp; !is_cmov_pack(p)) {
2444         // Promote operands to vector
2445         Node* in1 = NULL;
2446         bool node_isa_reduction = n-&gt;is_reduction();
2447         if (node_isa_reduction) {
2448           // the input to the first reduction operation is retained
2449           in1 = low_adr-&gt;in(1);
2450         } else {
2451           in1 = vector_opd(p, 1);
2452           if (in1 == NULL) {
2453             if (do_reserve_copy()) {
2454               NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: in1 should not be NULL, exiting SuperWord&quot;);})
2455               return; //and reverse to backup IG
2456             }
</pre>
<hr />
<pre>
2468         if (VectorNode::is_invariant_vector(in1) &amp;&amp; (node_isa_reduction == false) &amp;&amp; (n-&gt;is_Add() || n-&gt;is_Mul())) {
2469           // Move invariant vector input into second position to avoid register spilling.
2470           Node* tmp = in1;
2471           in1 = in2;
2472           in2 = tmp;
2473         }
2474         if (node_isa_reduction) {
2475           const Type *arith_type = n-&gt;bottom_type();
2476           vn = ReductionNode::make(opc, NULL, in1, in2, arith_type-&gt;basic_type());
2477           if (in2-&gt;is_Load()) {
2478             vlen_in_bytes = in2-&gt;as_LoadVector()-&gt;memory_size();
2479           } else {
2480             vlen_in_bytes = in2-&gt;as_Vector()-&gt;length_in_bytes();
2481           }
2482         } else {
2483           vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));
2484           vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2485         }
2486       } else if (opc == Op_SqrtF || opc == Op_SqrtD ||
2487                  opc == Op_AbsF || opc == Op_AbsD ||
<span class="line-added">2488                  opc == Op_AbsI || opc == Op_AbsL ||</span>
2489                  opc == Op_NegF || opc == Op_NegD ||
2490                  opc == Op_PopCountI) {
2491         assert(n-&gt;req() == 2, &quot;only one input expected&quot;);
2492         Node* in = vector_opd(p, 1);
2493         vn = VectorNode::make(opc, in, NULL, vlen, velt_basic_type(n));
2494         vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2495       } else if (is_cmov_pack(p)) {
2496         if (can_process_post_loop) {
2497           // do not refactor of flow in post loop context
2498           return;
2499         }
2500         if (!n-&gt;is_CMove()) {
2501           continue;
2502         }
2503         // place here CMoveVDNode
2504         NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print_cr(&quot;SWPointer::output: print before CMove vectorization&quot;); print_loop(false);})
2505         Node* bol = n-&gt;in(CMoveNode::Condition);
2506         if (!bol-&gt;is_Bool() &amp;&amp; bol-&gt;Opcode() == Op_ExtractI &amp;&amp; bol-&gt;req() &gt; 1 ) {
2507           NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print_cr(&quot;SWPointer::output: %d is not Bool node, trying its in(1) node %d&quot;, bol-&gt;_idx, bol-&gt;in(1)-&gt;_idx); bol-&gt;dump(); bol-&gt;in(1)-&gt;dump();})
2508           bol = bol-&gt;in(1); //may be ExtractNode
</pre>
<hr />
<pre>
2690       juint mask = (p0-&gt;bottom_type() == TypeInt::INT) ? (BitsPerInt - 1) : (BitsPerLong - 1);
2691       const TypeInt* t = opd-&gt;find_int_type();
2692       if (t != NULL &amp;&amp; t-&gt;is_con()) {
2693         juint shift = t-&gt;get_con();
2694         if (shift &gt; mask) { // Unsigned cmp
2695           cnt = ConNode::make(TypeInt::make(shift &amp; mask));
2696         }
2697       } else {
2698         if (t == NULL || t-&gt;_lo &lt; 0 || t-&gt;_hi &gt; (int)mask) {
2699           cnt = ConNode::make(TypeInt::make(mask));
2700           _igvn.register_new_node_with_optimizer(cnt);
2701           cnt = new AndINode(opd, cnt);
2702           _igvn.register_new_node_with_optimizer(cnt);
2703           _phase-&gt;set_ctrl(cnt, _phase-&gt;get_ctrl(opd));
2704         }
2705         assert(opd-&gt;bottom_type()-&gt;isa_int(), &quot;int type only&quot;);
2706         if (!opd-&gt;bottom_type()-&gt;isa_int()) {
2707           NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;Should be int type only&quot;);})
2708           return NULL;
2709         }






2710       }
<span class="line-added">2711       // Move shift count into vector register.</span>
<span class="line-added">2712       cnt = VectorNode::shift_count(p0, cnt, vlen, velt_basic_type(p0));</span>
<span class="line-added">2713       _igvn.register_new_node_with_optimizer(cnt);</span>
<span class="line-added">2714       _phase-&gt;set_ctrl(cnt, _phase-&gt;get_ctrl(opd));</span>
2715       return cnt;
2716     }
2717     assert(!opd-&gt;is_StoreVector(), &quot;such vector is not expected here&quot;);
2718     if (opd-&gt;is_StoreVector()) {
2719       NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;StoreVector is not expected here&quot;);})
2720       return NULL;
2721     }
2722     // Convert scalar input to vector with the same number of elements as
2723     // p0&#39;s vector. Use p0&#39;s type because size of operand&#39;s container in
2724     // vector should match p0&#39;s size regardless operand&#39;s size.
2725     const Type* p0_t = velt_type(p0);
2726     VectorNode* vn = VectorNode::scalar2vector(opd, vlen, p0_t);
2727 
2728     _igvn.register_new_node_with_optimizer(vn);
2729     _phase-&gt;set_ctrl(vn, _phase-&gt;get_ctrl(opd));
2730 #ifdef ASSERT
2731     if (TraceNewVectors) {
2732       tty-&gt;print(&quot;new Vector node: &quot;);
2733       vn-&gt;dump();
2734     }
</pre>
<hr />
<pre>
3309 Node* SuperWord::executed_last(Node_List* p) {
3310   Node* n = p-&gt;at(0);
3311   int n_rpo = bb_idx(n);
3312   for (uint i = 1; i &lt; p-&gt;size(); i++) {
3313     Node* s = p-&gt;at(i);
3314     int s_rpo = bb_idx(s);
3315     if (s_rpo &gt; n_rpo) {
3316       n = s;
3317       n_rpo = s_rpo;
3318     }
3319   }
3320   return n;
3321 }
3322 
3323 LoadNode::ControlDependency SuperWord::control_dependency(Node_List* p) {
3324   LoadNode::ControlDependency dep = LoadNode::DependsOnlyOnTest;
3325   for (uint i = 0; i &lt; p-&gt;size(); i++) {
3326     Node* n = p-&gt;at(i);
3327     assert(n-&gt;is_Load(), &quot;only meaningful for loads&quot;);
3328     if (!n-&gt;depends_only_on_test()) {
<span class="line-modified">3329       if (n-&gt;as_Load()-&gt;has_unknown_control_dependency() &amp;&amp;</span>
<span class="line-added">3330           dep != LoadNode::Pinned) {</span>
<span class="line-added">3331         // Upgrade to unknown control...</span>
<span class="line-added">3332         dep = LoadNode::UnknownControl;</span>
<span class="line-added">3333       } else {</span>
<span class="line-added">3334         // Otherwise, we must pin it.</span>
<span class="line-added">3335         dep = LoadNode::Pinned;</span>
<span class="line-added">3336       }</span>
3337     }
3338   }
3339   return dep;
3340 }
3341 
3342 
3343 //----------------------------align_initial_loop_index---------------------------
3344 // Adjust pre-loop limit so that in main loop, a load/store reference
3345 // to align_to_ref will be a position zero in the vector.
3346 //   (iv + k) mod vector_align == 0
3347 void SuperWord::align_initial_loop_index(MemNode* align_to_ref) {
3348   CountedLoopNode *main_head = lp()-&gt;as_CountedLoop();
3349   assert(main_head-&gt;is_main_loop(), &quot;&quot;);
3350   CountedLoopEndNode* pre_end = get_pre_loop_end(main_head);
3351   assert(pre_end != NULL, &quot;we must have a correct pre-loop&quot;);
3352   Node *pre_opaq1 = pre_end-&gt;limit();
3353   assert(pre_opaq1-&gt;Opcode() == Op_Opaque1, &quot;&quot;);
3354   Opaque1Node *pre_opaq = (Opaque1Node*)pre_opaq1;
3355   Node *lim0 = pre_opaq-&gt;in(1);
3356 
</pre>
</td>
</tr>
</table>
<center><a href="subnode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="superword.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
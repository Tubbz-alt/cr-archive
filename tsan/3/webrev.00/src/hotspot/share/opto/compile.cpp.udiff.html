<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/opto/compile.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="coalesce.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compile.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/compile.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -74,13 +74,10 @@</span>
  #include &quot;runtime/stubRoutines.hpp&quot;
  #include &quot;runtime/timer.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  #include &quot;utilities/copy.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
<span class="udiff-line-removed">- #if INCLUDE_ZGC</span>
<span class="udiff-line-removed">- #include &quot;gc/z/c2/zBarrierSetC2.hpp&quot;</span>
<span class="udiff-line-removed">- #endif</span>
  
  
  // -------------------- Compile::mach_constant_base_node -----------------------
  // Constant table base node singleton.
  MachConstantBaseNode* Compile::mach_constant_base_node() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -339,11 +336,11 @@</span>
    VectorSet&amp; useful_node_set = useful.member_set();
  
    for (uint node_idx = 0; node_idx &lt; max_idx; node_idx++) {
      // If node with index node_idx is not in useful set,
      // mark it as dead in dead node list.
<span class="udiff-line-modified-removed">-     if (! useful_node_set.test(node_idx) ) {</span>
<span class="udiff-line-modified-added">+     if (!useful_node_set.test(node_idx)) {</span>
        record_dead_node(node_idx);
      }
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -463,11 +460,10 @@</span>
    assert(compile == Compile::current(), &quot;sanity&quot;);
  
    compile-&gt;set_type_dict(NULL);
    compile-&gt;set_clone_map(new Dict(cmpkey, hashkey, _compile-&gt;comp_arena()));
    compile-&gt;clone_map().set_clone_idx(0);
<span class="udiff-line-removed">-   compile-&gt;set_type_hwm(NULL);</span>
    compile-&gt;set_type_last_size(0);
    compile-&gt;set_last_tf(NULL, NULL);
    compile-&gt;set_indexSet_arena(NULL);
    compile-&gt;set_indexSet_free_block_list(NULL);
    compile-&gt;init_type_arena();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -650,12 +646,14 @@</span>
                    _inlining_incrementally(false),
                    _do_cleanup(false),
                    _has_reserved_stack_access(target-&gt;has_reserved_stack_access()),
  #ifndef PRODUCT
                    _trace_opto_output(directive-&gt;TraceOptoOutputOption),
<span class="udiff-line-added">+                   _print_ideal(directive-&gt;PrintIdealOption),</span>
  #endif
                    _has_method_handle_invokes(false),
<span class="udiff-line-added">+                   _clinit_barrier_on_entry(false),</span>
                    _comp_arena(mtCompiler),
                    _barrier_set_state(BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;create_barrier_state(comp_arena())),
                    _env(ci_env),
                    _directive(directive),
                    _log(ci_env-&gt;log()),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -711,20 +709,23 @@</span>
      tty-&gt;print(&quot;  &quot;);
    }
    TraceTime t1(&quot;Total compilation time&quot;, &amp;_t_totalCompilation, CITime, CITimeVerbose);
    TraceTime t2(NULL, &amp;_t_methodCompilation, CITime, false);
  
<span class="udiff-line-modified-removed">- #ifndef PRODUCT</span>
<span class="udiff-line-modified-added">+ #if defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_ABSTRACT_ASSEMBLY)</span>
    bool print_opto_assembly = directive-&gt;PrintOptoAssemblyOption;
<span class="udiff-line-modified-removed">-   if (!print_opto_assembly) {</span>
<span class="udiff-line-modified-removed">-     bool print_assembly = directive-&gt;PrintAssemblyOption;</span>
<span class="udiff-line-modified-removed">-     if (print_assembly &amp;&amp; !Disassembler::can_decode()) {</span>
<span class="udiff-line-modified-removed">-       tty-&gt;print_cr(&quot;PrintAssembly request changed to PrintOptoAssembly&quot;);</span>
<span class="udiff-line-modified-removed">-       print_opto_assembly = true;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">-   set_print_assembly(print_opto_assembly);</span>
<span class="udiff-line-modified-added">+   // We can always print a disassembly, either abstract (hex dump) or</span>
<span class="udiff-line-modified-added">+   // with the help of a suitable hsdis library. Thus, we should not</span>
<span class="udiff-line-modified-added">+   // couple print_assembly and print_opto_assembly controls.</span>
<span class="udiff-line-modified-added">+   // But: always print opto and regular assembly on compile command &#39;print&#39;.</span>
<span class="udiff-line-modified-added">+   bool print_assembly = directive-&gt;PrintAssemblyOption;</span>
<span class="udiff-line-modified-added">+   set_print_assembly(print_opto_assembly || print_assembly);</span>
<span class="udiff-line-modified-added">+ #else</span>
<span class="udiff-line-modified-added">+   set_print_assembly(false); // must initialize.</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifndef PRODUCT</span>
    set_parsed_irreducible_loop(false);
  
    if (directive-&gt;ReplayInlineOption) {
      _replay_inline_data = ciReplay::load_inline_data(method(), entry_bci(), ci_env-&gt;comp_level());
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -871,11 +872,11 @@</span>
    Optimize();
    if (failing())  return;
    NOT_PRODUCT( verify_graph_edges(); )
  
  #ifndef PRODUCT
<span class="udiff-line-modified-removed">-   if (PrintIdeal) {</span>
<span class="udiff-line-modified-added">+   if (print_ideal()) {</span>
      ttyLocker ttyl;  // keep the following output all in one block
      // This output goes directly to the tty, not the compiler log.
      // To enable tools to match it up with the compilation activity,
      // be sure to tag this tty output with the compile ID.
      if (xtty != NULL) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -981,13 +982,16 @@</span>
      _inlining_progress(false),
      _inlining_incrementally(false),
      _has_reserved_stack_access(false),
  #ifndef PRODUCT
      _trace_opto_output(directive-&gt;TraceOptoOutputOption),
<span class="udiff-line-added">+     _print_ideal(directive-&gt;PrintIdealOption),</span>
  #endif
      _has_method_handle_invokes(false),
<span class="udiff-line-added">+     _clinit_barrier_on_entry(false),</span>
      _comp_arena(mtCompiler),
<span class="udiff-line-added">+     _barrier_set_state(BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;create_barrier_state(comp_arena())),</span>
      _env(ci_env),
      _directive(directive),
      _log(ci_env-&gt;log()),
      _failure_reason(NULL),
      _congraph(NULL),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1025,10 +1029,12 @@</span>
    TraceTime t2(NULL, &amp;_t_stubCompilation, CITime, false);
  
  #ifndef PRODUCT
    set_print_assembly(PrintFrameConverterAssembly);
    set_parsed_irreducible_loop(false);
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+   set_print_assembly(false); // Must initialize.</span>
  #endif
    set_has_irreducible_loop(false); // no loops
  
    CompileWrapper cw(this);
    Init(/*AliasLevel=*/ 0);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1086,11 +1092,11 @@</span>
    _tf      = NULL;  // filled in later
    _top     = NULL;  // cached later
    _matcher = NULL;  // filled in later
    _cfg     = NULL;  // filled in later
  
<span class="udiff-line-modified-removed">-   set_24_bit_selection_and_mode(Use24BitFP, false);</span>
<span class="udiff-line-modified-added">+   IA32_ONLY( set_24_bit_selection_and_mode(true, false); )</span>
  
    _node_note_array = NULL;
    _default_node_notes = NULL;
    DEBUG_ONLY( _modified_nodes = NULL; ) // Used in Optimize()
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1163,10 +1169,13 @@</span>
        // code if UseRTMDeopt is on.
        set_rtm_state(ProfileRTM);
      }
    }
  #endif
<span class="udiff-line-added">+   if (VM_Version::supports_fast_class_init_checks() &amp;&amp; has_method() &amp;&amp; !is_osr_compilation() &amp;&amp; method()-&gt;needs_clinit_barrier()) {</span>
<span class="udiff-line-added">+     set_clinit_barrier_on_entry(true);</span>
<span class="udiff-line-added">+   }</span>
    if (debug_info()-&gt;recording_non_safepoints()) {
      set_node_note_array(new(comp_arena()) GrowableArray&lt;Node_Notes*&gt;
                          (comp_arena(), 8, 0, NULL));
      set_default_node_notes(Node_Notes::make(this));
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1464,12 +1473,10 @@</span>
          ptr = TypePtr::BotPTR;
        } else if( offset == oopDesc::mark_offset_in_bytes() ) {
          tj = TypeInstPtr::MARK;
          ta = TypeAryPtr::RANGE; // generic ignored junk
          ptr = TypePtr::BotPTR;
<span class="udiff-line-removed">-       } else if (BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;flatten_gc_alias_type(tj)) {</span>
<span class="udiff-line-removed">-         ta = tj-&gt;isa_aryptr();</span>
        } else {                  // Random constant offset into array body
          offset = Type::OffsetBot;   // Flatten constant access into array body
          tj = ta = TypeAryPtr::make(ptr,ta-&gt;ary(),ta-&gt;klass(),false,offset);
        }
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1530,12 +1537,10 @@</span>
        // First handle header references such as a LoadKlassNode, even if the
        // object&#39;s klass is unloaded at compile time (4965979).
        if (!is_known_inst) { // Do it only for non-instance types
          tj = to = TypeInstPtr::make(TypePtr::BotPTR, env()-&gt;Object_klass(), false, NULL, offset);
        }
<span class="udiff-line-removed">-     } else if (BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;flatten_gc_alias_type(tj)) {</span>
<span class="udiff-line-removed">-       to = tj-&gt;is_instptr();</span>
      } else if (offset &lt; 0 || offset &gt;= k-&gt;size_helper() * wordSize) {
        // Static fields are in the space above the normal instance
        // fields in the java.lang.Class instance.
        if (to-&gt;klass() != ciEnv::current()-&gt;Class_klass()) {
          to = NULL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1630,12 +1635,11 @@</span>
            (offset == Type::OffsetBot &amp;&amp; tj-&gt;base() == Type::AryPtr) ||
            (offset == Type::OffsetBot &amp;&amp; tj == TypeOopPtr::BOTTOM) ||
            (offset == Type::OffsetBot &amp;&amp; tj == TypePtr::BOTTOM) ||
            (offset == oopDesc::mark_offset_in_bytes() &amp;&amp; tj-&gt;base() == Type::AryPtr) ||
            (offset == oopDesc::klass_offset_in_bytes() &amp;&amp; tj-&gt;base() == Type::AryPtr) ||
<span class="udiff-line-modified-removed">-           (offset == arrayOopDesc::length_offset_in_bytes() &amp;&amp; tj-&gt;base() == Type::AryPtr) ||</span>
<span class="udiff-line-removed">-           (BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;verify_gc_alias_type(tj, offset)),</span>
<span class="udiff-line-modified-added">+           (offset == arrayOopDesc::length_offset_in_bytes() &amp;&amp; tj-&gt;base() == Type::AryPtr),</span>
            &quot;For oops, klasses, raw offset must be constant; for arrays the offset is never known&quot; );
    assert( tj-&gt;ptr() != TypePtr::TopPTR &amp;&amp;
            tj-&gt;ptr() != TypePtr::AnyNull &amp;&amp;
            tj-&gt;ptr() != TypePtr::Null, &quot;No imprecise addresses&quot; );
  //    assert( tj-&gt;ptr() != TypePtr::Constant ||
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1644,10 +1648,11 @@</span>
  
    return tj;
  }
  
  void Compile::AliasType::Init(int i, const TypePtr* at) {
<span class="udiff-line-added">+   assert(AliasIdxTop &lt;= i &amp;&amp; i &lt; Compile::current()-&gt;_max_alias_types, &quot;Invalid alias index&quot;);</span>
    _index = i;
    _adr_type = at;
    _field = NULL;
    _element = NULL;
    _is_rewritable = true; // default
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2184,10 +2189,15 @@</span>
            igvn.remove_dead_node(n);
          }
          --i;
        }
      }
<span class="udiff-line-added">+     // Parsing may have added top inputs to the root node (Path</span>
<span class="udiff-line-added">+     // leading to the Halt node proven dead). Make sure we get a</span>
<span class="udiff-line-added">+     // chance to clean them up.</span>
<span class="udiff-line-added">+     igvn._worklist.push(r);</span>
<span class="udiff-line-added">+     igvn.optimize();</span>
    }
  }
  
  //------------------------------Optimize---------------------------------------
  // Given a graph, optimize it.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2199,12 +2209,12 @@</span>
      BREAKPOINT;
    }
  
  #endif
  
<span class="udiff-line-removed">- #ifdef ASSERT</span>
    BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
<span class="udiff-line-added">+ #ifdef ASSERT</span>
    bs-&gt;verify_gc_barriers(this, BarrierSetC2::BeforeOptimize);
  #endif
  
    ResourceMark rm;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2280,11 +2290,11 @@</span>
    // Perform escape analysis
    if (_do_escape_analysis &amp;&amp; ConnectionGraph::has_candidates(this)) {
      if (has_loops()) {
        // Cleanup graph (remove dead nodes).
        TracePhase tp(&quot;idealLoop&quot;, &amp;timers[_t_idealLoop]);
<span class="udiff-line-modified-removed">-       PhaseIdealLoop::optimize(igvn, LoopOptsNone);</span>
<span class="udiff-line-modified-added">+       PhaseIdealLoop::optimize(igvn, LoopOptsMaxUnroll);</span>
        if (major_progress()) print_method(PHASE_PHASEIDEAL_BEFORE_EA, 2);
        if (failing())  return;
      }
      ConnectionGraph::do_analysis(this, &amp;igvn);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2359,27 +2369,20 @@</span>
    {
      TracePhase tp(&quot;iterGVN2&quot;, &amp;timers[_t_iterGVN2]);
      igvn = ccp;
      igvn.optimize();
    }
<span class="udiff-line-removed">- </span>
    print_method(PHASE_ITER_GVN2, 2);
  
    if (failing())  return;
  
    // Loop transforms on the ideal graph.  Range Check Elimination,
    // peeling, unrolling, etc.
    if (!optimize_loops(igvn, LoopOptsDefault)) {
      return;
    }
  
<span class="udiff-line-removed">- #if INCLUDE_ZGC</span>
<span class="udiff-line-removed">-   if (UseZGC) {</span>
<span class="udiff-line-removed">-     ZBarrierSetC2::find_dominating_barriers(igvn);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
    if (failing())  return;
  
    // Ensure that major progress is now clear
    C-&gt;clear_major_progress();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2395,32 +2398,30 @@</span>
      C-&gt;remove_range_check_casts(igvn);
      igvn.optimize();
    }
  
  #ifdef ASSERT
<span class="udiff-line-modified-removed">-   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="udiff-line-removed">-   bs-&gt;verify_gc_barriers(this, BarrierSetC2::BeforeExpand);</span>
<span class="udiff-line-modified-added">+   bs-&gt;verify_gc_barriers(this, BarrierSetC2::BeforeMacroExpand);</span>
  #endif
  
    {
      TracePhase tp(&quot;macroExpand&quot;, &amp;timers[_t_macroExpand]);
      PhaseMacroExpand  mex(igvn);
<span class="udiff-line-removed">-     print_method(PHASE_BEFORE_MACRO_EXPANSION, 2);</span>
      if (mex.expand_macro_nodes()) {
        assert(failing(), &quot;must bail out w/ explicit message&quot;);
        return;
      }
<span class="udiff-line-added">+     print_method(PHASE_MACRO_EXPANSION, 2);</span>
    }
  
    {
      TracePhase tp(&quot;barrierExpand&quot;, &amp;timers[_t_barrierExpand]);
<span class="udiff-line-removed">-     print_method(PHASE_BEFORE_BARRIER_EXPAND, 2);</span>
<span class="udiff-line-removed">-     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
      if (bs-&gt;expand_barriers(this, igvn)) {
        assert(failing(), &quot;must bail out w/ explicit message&quot;);
        return;
      }
<span class="udiff-line-added">+     print_method(PHASE_BARRIER_EXPANSION, 2);</span>
    }
  
    if (opaque4_count() &gt; 0) {
      C-&gt;remove_opaque4_nodes(igvn);
      igvn.optimize();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2463,11 +2464,15 @@</span>
    Matcher matcher;
    _matcher = &amp;matcher;
    {
      TracePhase tp(&quot;matcher&quot;, &amp;timers[_t_matcher]);
      matcher.match();
<span class="udiff-line-added">+     if (failing()) {</span>
<span class="udiff-line-added">+       return;</span>
<span class="udiff-line-added">+     }</span>
    }
<span class="udiff-line-added">+ </span>
    // In debug mode can dump m._nodes.dump() for mapping of ideal to machine
    // nodes.  Mapping is only valid at the root of each matched subtree.
    NOT_PRODUCT( verify_graph_edges(); )
  
    // If you have too many nodes, or if matching has failed, bail out
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2550,16 +2555,29 @@</span>
  }
  
  
  //------------------------------dump_asm---------------------------------------
  // Dump formatted assembly
<span class="udiff-line-modified-removed">- #ifndef PRODUCT</span>
<span class="udiff-line-modified-removed">- void Compile::dump_asm(int *pcs, uint pc_limit) {</span>
<span class="udiff-line-modified-added">+ #if defined(SUPPORT_OPTO_ASSEMBLY)</span>
<span class="udiff-line-modified-added">+ void Compile::dump_asm_on(outputStream* st, int* pcs, uint pc_limit) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   int pc_digits = 3; // #chars required for pc</span>
<span class="udiff-line-added">+   int sb_chars  = 3; // #chars for &quot;start bundle&quot; indicator</span>
<span class="udiff-line-added">+   int tab_size  = 8;</span>
<span class="udiff-line-added">+   if (pcs != NULL) {</span>
<span class="udiff-line-added">+     int max_pc = 0;</span>
<span class="udiff-line-added">+     for (uint i = 0; i &lt; pc_limit; i++) {</span>
<span class="udiff-line-added">+       max_pc = (max_pc &lt; pcs[i]) ? pcs[i] : max_pc;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     pc_digits  = ((max_pc &lt; 4096) ? 3 : ((max_pc &lt; 65536) ? 4 : ((max_pc &lt; 65536*256) ? 6 : 8))); // #chars required for pc</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   int prefix_len = ((pc_digits + sb_chars + tab_size - 1)/tab_size)*tab_size;</span>
<span class="udiff-line-added">+ </span>
    bool cut_short = false;
<span class="udiff-line-modified-removed">-   tty-&gt;print_cr(&quot;#&quot;);</span>
<span class="udiff-line-modified-removed">-   tty-&gt;print(&quot;#  &quot;);  _tf-&gt;dump();  tty-&gt;cr();</span>
<span class="udiff-line-modified-removed">-   tty-&gt;print_cr(&quot;#&quot;);</span>
<span class="udiff-line-modified-added">+   st-&gt;print_cr(&quot;#&quot;);</span>
<span class="udiff-line-modified-added">+   st-&gt;print(&quot;#  &quot;);  _tf-&gt;dump_on(st);  st-&gt;cr();</span>
<span class="udiff-line-modified-added">+   st-&gt;print_cr(&quot;#&quot;);</span>
  
    // For all blocks
    int pc = 0x0;                 // Program counter
    char starts_bundle = &#39; &#39;;
    _regalloc-&gt;dump_frame();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2573,20 +2591,22 @@</span>
      Block* block = _cfg-&gt;get_block(i);
      if (block-&gt;is_connector() &amp;&amp; !Verbose) {
        continue;
      }
      n = block-&gt;head();
<span class="udiff-line-modified-removed">-     if (pcs &amp;&amp; n-&gt;_idx &lt; pc_limit) {</span>
<span class="udiff-line-modified-removed">-       tty-&gt;print(&quot;%3.3x   &quot;, pcs[n-&gt;_idx]);</span>
<span class="udiff-line-modified-removed">-     } else {</span>
<span class="udiff-line-removed">-       tty-&gt;print(&quot;      &quot;);</span>
<span class="udiff-line-modified-added">+     if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {</span>
<span class="udiff-line-modified-added">+       pc = pcs[n-&gt;_idx];</span>
<span class="udiff-line-modified-added">+       st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);</span>
      }
<span class="udiff-line-modified-removed">-     block-&gt;dump_head(_cfg);</span>
<span class="udiff-line-modified-added">+     st-&gt;fill_to(prefix_len);</span>
<span class="udiff-line-added">+     block-&gt;dump_head(_cfg, st);</span>
      if (block-&gt;is_connector()) {
<span class="udiff-line-modified-removed">-       tty-&gt;print_cr(&quot;        # Empty connector block&quot;);</span>
<span class="udiff-line-modified-added">+       st-&gt;fill_to(prefix_len);</span>
<span class="udiff-line-added">+       st-&gt;print_cr(&quot;# Empty connector block&quot;);</span>
      } else if (block-&gt;num_preds() == 2 &amp;&amp; block-&gt;pred(1)-&gt;is_CatchProj() &amp;&amp; block-&gt;pred(1)-&gt;as_CatchProj()-&gt;_con == CatchProjNode::fall_through_index) {
<span class="udiff-line-modified-removed">-       tty-&gt;print_cr(&quot;        # Block is sole successor of call&quot;);</span>
<span class="udiff-line-modified-added">+       st-&gt;fill_to(prefix_len);</span>
<span class="udiff-line-added">+       st-&gt;print_cr(&quot;# Block is sole successor of call&quot;);</span>
      }
  
      // For all instructions
      Node *delay = NULL;
      for (uint j = 0; j &lt; block-&gt;number_of_nodes(); j++) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2618,59 +2638,58 @@</span>
            !n-&gt;is_Catch() &amp;&amp;     // Would be nice to print exception table targets
            !n-&gt;is_MergeMem() &amp;&amp;  // Not very interesting
            !n-&gt;is_top() &amp;&amp;       // Debug info table constants
            !(n-&gt;is_Con() &amp;&amp; !n-&gt;is_Mach())// Debug info table constants
            ) {
<span class="udiff-line-modified-removed">-         if (pcs &amp;&amp; n-&gt;_idx &lt; pc_limit)</span>
<span class="udiff-line-modified-removed">-           tty-&gt;print(&quot;%3.3x&quot;, pcs[n-&gt;_idx]);</span>
<span class="udiff-line-modified-removed">-         else</span>
<span class="udiff-line-modified-removed">-           tty-&gt;print(&quot;   &quot;);</span>
<span class="udiff-line-modified-removed">-         tty-&gt;print(&quot; %c &quot;, starts_bundle);</span>
<span class="udiff-line-modified-added">+         if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {</span>
<span class="udiff-line-modified-added">+           pc = pcs[n-&gt;_idx];</span>
<span class="udiff-line-modified-added">+           st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);</span>
<span class="udiff-line-modified-added">+         } else {</span>
<span class="udiff-line-modified-added">+           st-&gt;fill_to(pc_digits);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         st-&gt;print(&quot; %c &quot;, starts_bundle);</span>
          starts_bundle = &#39; &#39;;
<span class="udiff-line-modified-removed">-         tty-&gt;print(&quot;\t&quot;);</span>
<span class="udiff-line-modified-removed">-         n-&gt;format(_regalloc, tty);</span>
<span class="udiff-line-modified-removed">-         tty-&gt;cr();</span>
<span class="udiff-line-modified-added">+         st-&gt;fill_to(prefix_len);</span>
<span class="udiff-line-modified-added">+         n-&gt;format(_regalloc, st);</span>
<span class="udiff-line-modified-added">+         st-&gt;cr();</span>
        }
  
        // If we have an instruction with a delay slot, and have seen a delay,
        // then back up and print it
        if (valid_bundle_info(n) &amp;&amp; node_bundling(n)-&gt;use_unconditional_delay()) {
<span class="udiff-line-modified-removed">-         assert(delay != NULL, &quot;no unconditional delay instruction&quot;);</span>
<span class="udiff-line-modified-added">+         // Coverity finding - Explicit null dereferenced.</span>
<span class="udiff-line-added">+         guarantee(delay != NULL, &quot;no unconditional delay instruction&quot;);</span>
          if (WizardMode) delay-&gt;dump();
  
          if (node_bundling(delay)-&gt;starts_bundle())
            starts_bundle = &#39;+&#39;;
<span class="udiff-line-modified-removed">-         if (pcs &amp;&amp; n-&gt;_idx &lt; pc_limit)</span>
<span class="udiff-line-modified-removed">-           tty-&gt;print(&quot;%3.3x&quot;, pcs[n-&gt;_idx]);</span>
<span class="udiff-line-modified-removed">-         else</span>
<span class="udiff-line-modified-removed">-           tty-&gt;print(&quot;   &quot;);</span>
<span class="udiff-line-modified-removed">-         tty-&gt;print(&quot; %c &quot;, starts_bundle);</span>
<span class="udiff-line-modified-added">+         if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {</span>
<span class="udiff-line-modified-added">+           pc = pcs[n-&gt;_idx];</span>
<span class="udiff-line-modified-added">+           st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);</span>
<span class="udiff-line-modified-added">+         } else {</span>
<span class="udiff-line-modified-added">+           st-&gt;fill_to(pc_digits);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         st-&gt;print(&quot; %c &quot;, starts_bundle);</span>
          starts_bundle = &#39; &#39;;
<span class="udiff-line-modified-removed">-         tty-&gt;print(&quot;\t&quot;);</span>
<span class="udiff-line-modified-removed">-         delay-&gt;format(_regalloc, tty);</span>
<span class="udiff-line-modified-removed">-         tty-&gt;cr();</span>
<span class="udiff-line-modified-added">+         st-&gt;fill_to(prefix_len);</span>
<span class="udiff-line-modified-added">+         delay-&gt;format(_regalloc, st);</span>
<span class="udiff-line-modified-added">+         st-&gt;cr();</span>
          delay = NULL;
        }
  
        // Dump the exception table as well
        if( n-&gt;is_Catch() &amp;&amp; (Verbose || WizardMode) ) {
          // Print the exception table for this offset
          _handler_table.print_subtable_for(pc);
        }
<span class="udiff-line-added">+       st-&gt;bol(); // Make sure we start on a new line</span>
      }
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-     if (pcs &amp;&amp; n-&gt;_idx &lt; pc_limit)</span>
<span class="udiff-line-removed">-       tty-&gt;print_cr(&quot;%3.3x&quot;, pcs[n-&gt;_idx]);</span>
<span class="udiff-line-removed">-     else</span>
<span class="udiff-line-removed">-       tty-&gt;cr();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+     st-&gt;cr(); // one empty line between blocks</span>
      assert(cut_short || delay == NULL, &quot;no unconditional delay branch&quot;);
<span class="udiff-line-removed">- </span>
    } // End of per-block dump
<span class="udiff-line-removed">-   tty-&gt;cr();</span>
  
<span class="udiff-line-modified-removed">-   if (cut_short)  tty-&gt;print_cr(&quot;*** disassembly is cut short ***&quot;);</span>
<span class="udiff-line-modified-added">+   if (cut_short)  st-&gt;print_cr(&quot;*** disassembly is cut short ***&quot;);</span>
  }
  #endif
  
  //------------------------------Final_Reshape_Counts---------------------------
  // This class defines counters to help identify when a method
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2798,11 +2817,11 @@</span>
    }
    if (n-&gt;is_MemBar()) {
      MemBarNode* mb = n-&gt;as_MemBar();
      if (mb-&gt;trailing_store() || mb-&gt;trailing_load_store()) {
        assert(mb-&gt;leading_membar()-&gt;trailing_membar() == mb, &quot;bad membar pair&quot;);
<span class="udiff-line-modified-removed">-       Node* mem = mb-&gt;in(MemBarNode::Precedent);</span>
<span class="udiff-line-modified-added">+       Node* mem = BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;step_over_gc_barrier(mb-&gt;in(MemBarNode::Precedent));</span>
        assert((mb-&gt;trailing_store() &amp;&amp; mem-&gt;is_Store() &amp;&amp; mem-&gt;as_Store()-&gt;is_release()) ||
               (mb-&gt;trailing_load_store() &amp;&amp; mem-&gt;is_LoadStore()), &quot;missing mem op&quot;);
      } else if (mb-&gt;leading()) {
        assert(mb-&gt;trailing_membar()-&gt;leading_membar() == mb, &quot;bad membar pair&quot;);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3068,11 +3087,11 @@</span>
        wq.push(n);
        for (uint next = 0; next &lt; wq.size(); ++next) {
          Node *m = wq.at(next);
          for (DUIterator_Fast imax, i = m-&gt;fast_outs(imax); i &lt; imax; i++) {
            Node* use = m-&gt;fast_out(i);
<span class="udiff-line-modified-removed">-           if (use-&gt;is_Mem() || use-&gt;is_EncodeNarrowPtr() || use-&gt;is_ShenandoahBarrier()) {</span>
<span class="udiff-line-modified-added">+           if (use-&gt;is_Mem() || use-&gt;is_EncodeNarrowPtr()) {</span>
              use-&gt;ensure_control_or_add_prec(n-&gt;in(0));
            } else {
              switch(use-&gt;Opcode()) {
              case Op_AddP:
              case Op_DecodeN:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3448,11 +3467,11 @@</span>
        // Code generation on some platforms doesn&#39;t need accurate
        // ConvI2L types. Widening the type can help remove redundant
        // address computations.
        n-&gt;as_Type()-&gt;set_type(TypeLong::INT);
        ResourceMark rm;
<span class="udiff-line-modified-removed">-       Node_List wq;</span>
<span class="udiff-line-modified-added">+       Unique_Node_List wq;</span>
        wq.push(n);
        for (uint next = 0; next &lt; wq.size(); next++) {
          Node *m = wq.at(next);
  
          for(;;) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3463,11 +3482,10 @@</span>
            }
            // Push their uses so we get a chance to remove node made
            // redundant
            for (DUIterator_Fast imax, i = k-&gt;fast_outs(imax); i &lt; imax; i++) {
              Node* u = k-&gt;fast_out(i);
<span class="udiff-line-removed">-             assert(!wq.contains(u), &quot;shouldn&#39;t process one node several times&quot;);</span>
              if (u-&gt;Opcode() == Op_LShiftL ||
                  u-&gt;Opcode() == Op_AddL ||
                  u-&gt;Opcode() == Op_SubL ||
                  u-&gt;Opcode() == Op_AddP) {
                wq.push(u);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3693,18 +3711,20 @@</span>
        Node* iff = new IfNode(init_iff-&gt;in(0), init_iff-&gt;in(1), init_iff-&gt;_prob, init_iff-&gt;_fcnt);
        n-&gt;subsume_by(iff, this);
      }
    }
  
<span class="udiff-line-added">+ #ifdef IA32</span>
    // If original bytecodes contained a mixture of floats and doubles
    // check if the optimizer has made it homogenous, item (3).
<span class="udiff-line-modified-removed">-   if( Use24BitFPMode &amp;&amp; Use24BitFP &amp;&amp; UseSSE == 0 &amp;&amp;</span>
<span class="udiff-line-modified-added">+   if (UseSSE == 0 &amp;&amp;</span>
        frc.get_float_count() &gt; 32 &amp;&amp;
        frc.get_double_count() == 0 &amp;&amp;
        (10 * frc.get_call_count() &lt; frc.get_float_count()) ) {
<span class="udiff-line-modified-removed">-     set_24_bit_selection_and_mode( false,  true );</span>
<span class="udiff-line-modified-added">+     set_24_bit_selection_and_mode(false, true);</span>
    }
<span class="udiff-line-added">+ #endif // IA32</span>
  
    set_java_calls(frc.get_java_call_count());
    set_inner_loops(frc.get_inner_loop_count());
  
    // No infinite loops, no reason to bail out.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3820,13 +3840,46 @@</span>
        }
      }
    }
  }
  
<span class="udiff-line-modified-removed">- bool Compile::is_compiling_clinit_for(ciKlass* k) {</span>
<span class="udiff-line-modified-removed">-   ciMethod* root = method(); // the root method of compilation</span>
<span class="udiff-line-modified-removed">-   return root-&gt;is_static_initializer() &amp;&amp; root-&gt;holder() == k; // access in the context of clinit</span>
<span class="udiff-line-modified-added">+ bool Compile::needs_clinit_barrier(ciMethod* method, ciMethod* accessing_method) {</span>
<span class="udiff-line-modified-added">+   return method-&gt;is_static() &amp;&amp; needs_clinit_barrier(method-&gt;holder(), accessing_method);</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool Compile::needs_clinit_barrier(ciField* field, ciMethod* accessing_method) {</span>
<span class="udiff-line-added">+   return field-&gt;is_static() &amp;&amp; needs_clinit_barrier(field-&gt;holder(), accessing_method);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool Compile::needs_clinit_barrier(ciInstanceKlass* holder, ciMethod* accessing_method) {</span>
<span class="udiff-line-added">+   if (holder-&gt;is_initialized()) {</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (holder-&gt;is_being_initialized()) {</span>
<span class="udiff-line-added">+     if (accessing_method-&gt;holder() == holder) {</span>
<span class="udiff-line-added">+       // Access inside a class. The barrier can be elided when access happens in &lt;clinit&gt;,</span>
<span class="udiff-line-added">+       // &lt;init&gt;, or a static method. In all those cases, there was an initialization</span>
<span class="udiff-line-added">+       // barrier on the holder klass passed.</span>
<span class="udiff-line-added">+       if (accessing_method-&gt;is_static_initializer() ||</span>
<span class="udiff-line-added">+           accessing_method-&gt;is_object_initializer() ||</span>
<span class="udiff-line-added">+           accessing_method-&gt;is_static()) {</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     } else if (accessing_method-&gt;holder()-&gt;is_subclass_of(holder)) {</span>
<span class="udiff-line-added">+       // Access from a subclass. The barrier can be elided only when access happens in &lt;clinit&gt;.</span>
<span class="udiff-line-added">+       // In case of &lt;init&gt; or a static method, the barrier is on the subclass is not enough:</span>
<span class="udiff-line-added">+       // child class can become fully initialized while its parent class is still being initialized.</span>
<span class="udiff-line-added">+       if (accessing_method-&gt;is_static_initializer()) {</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     ciMethod* root = method(); // the root method of compilation</span>
<span class="udiff-line-added">+     if (root != accessing_method) {</span>
<span class="udiff-line-added">+       return needs_clinit_barrier(holder, root); // check access in the context of compilation root</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return true;</span>
  }
  
  #ifndef PRODUCT
  //------------------------------verify_graph_edges---------------------------
  // Walk the Graph and verify that there is a one-to-one correspondence
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4184,10 +4237,13 @@</span>
      if (!ik-&gt;has_subklass() &amp;&amp; !ik-&gt;is_interface()) {
        if (!ik-&gt;is_final()) {
          // Add a dependency if there is a chance of a later subclass.
          dependencies()-&gt;assert_leaf_type(ik);
        }
<span class="udiff-line-added">+       if (ik-&gt;is_abstract()) {</span>
<span class="udiff-line-added">+         return SSC_always_false;</span>
<span class="udiff-line-added">+       }</span>
        return SSC_easy_test;     // (3) caller can do a simple ptr comparison
      }
    } else {
      // A primitive array type has no subtypes.
      return SSC_easy_test;       // (3) caller can do a simple ptr comparison
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4232,27 +4288,42 @@</span>
    }
    const TypeLong* ltype = TypeLong::make(itype-&gt;_lo, itype-&gt;_hi, itype-&gt;_widen);
    return phase-&gt;transform(new ConvI2LNode(value, ltype));
  }
  
<span class="udiff-line-added">+ void Compile::print_inlining_stream_free() {</span>
<span class="udiff-line-added">+   if (_print_inlining_stream != NULL) {</span>
<span class="udiff-line-added">+     _print_inlining_stream-&gt;~stringStream();</span>
<span class="udiff-line-added">+     _print_inlining_stream = NULL;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  // The message about the current inlining is accumulated in
  // _print_inlining_stream and transfered into the _print_inlining_list
  // once we know whether inlining succeeds or not. For regular
  // inlining, messages are appended to the buffer pointed by
  // _print_inlining_idx in the _print_inlining_list. For late inlining,
  // a new buffer is added after _print_inlining_idx in the list. This
  // way we can update the inlining message for late inlining call site
  // when the inlining is attempted again.
  void Compile::print_inlining_init() {
    if (print_inlining() || print_intrinsics()) {
<span class="udiff-line-added">+     // print_inlining_init is actually called several times.</span>
<span class="udiff-line-added">+     print_inlining_stream_free();</span>
      _print_inlining_stream = new stringStream();
<span class="udiff-line-added">+     // Watch out: The memory initialized by the constructor call PrintInliningBuffer()</span>
<span class="udiff-line-added">+     // will be copied into the only initial element. The default destructor of</span>
<span class="udiff-line-added">+     // PrintInliningBuffer will be called when leaving the scope here. If it</span>
<span class="udiff-line-added">+     // would destuct the  enclosed stringStream _print_inlining_list[0]-&gt;_ss</span>
<span class="udiff-line-added">+     // would be destructed, too!</span>
      _print_inlining_list = new (comp_arena())GrowableArray&lt;PrintInliningBuffer&gt;(comp_arena(), 1, 1, PrintInliningBuffer());
    }
  }
  
  void Compile::print_inlining_reinit() {
    if (print_inlining() || print_intrinsics()) {
<span class="udiff-line-added">+     print_inlining_stream_free();</span>
      // Re allocate buffer when we change ResourceMark
      _print_inlining_stream = new stringStream();
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4262,11 +4333,11 @@</span>
  
  void Compile::print_inlining_commit() {
    assert(print_inlining() || print_intrinsics(), &quot;PrintInlining off?&quot;);
    // Transfer the message from _print_inlining_stream to the current
    // _print_inlining_list buffer and clear _print_inlining_stream.
<span class="udiff-line-modified-removed">-   _print_inlining_list-&gt;at(_print_inlining_idx).ss()-&gt;write(_print_inlining_stream-&gt;as_string(), _print_inlining_stream-&gt;size());</span>
<span class="udiff-line-modified-added">+   _print_inlining_list-&gt;at(_print_inlining_idx).ss()-&gt;write(_print_inlining_stream-&gt;base(), _print_inlining_stream-&gt;size());</span>
    print_inlining_reset();
  }
  
  void Compile::print_inlining_push() {
    // Add new buffer to the _print_inlining_list at current position
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4343,13 +4414,20 @@</span>
      }
    }
    if (do_print_inlining) {
      ResourceMark rm;
      stringStream ss;
<span class="udiff-line-added">+     assert(_print_inlining_list != NULL, &quot;process_print_inlining should be called only once.&quot;);</span>
      for (int i = 0; i &lt; _print_inlining_list-&gt;length(); i++) {
        ss.print(&quot;%s&quot;, _print_inlining_list-&gt;adr_at(i)-&gt;ss()-&gt;as_string());
<span class="udiff-line-added">+       _print_inlining_list-&gt;at(i).freeStream();</span>
      }
<span class="udiff-line-added">+     // Reset _print_inlining_list, it only contains destructed objects.</span>
<span class="udiff-line-added">+     // It is on the arena, so it will be freed when the arena is reset.</span>
<span class="udiff-line-added">+     _print_inlining_list = NULL;</span>
<span class="udiff-line-added">+     // _print_inlining_stream won&#39;t be used anymore, either.</span>
<span class="udiff-line-added">+     print_inlining_stream_free();</span>
      size_t end = ss.size();
      _print_inlining_output = NEW_ARENA_ARRAY(comp_arena(), char, end+1);
      strncpy(_print_inlining_output, ss.base(), end+1);
      _print_inlining_output[end] = 0;
    }
</pre>
<center><a href="coalesce.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compile.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
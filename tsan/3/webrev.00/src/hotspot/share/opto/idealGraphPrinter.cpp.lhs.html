<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/idealGraphPrinter.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;memory/resourceArea.hpp&quot;
 27 #include &quot;opto/chaitin.hpp&quot;
 28 #include &quot;opto/idealGraphPrinter.hpp&quot;
 29 #include &quot;opto/machnode.hpp&quot;
 30 #include &quot;opto/parse.hpp&quot;
 31 #include &quot;runtime/threadCritical.hpp&quot;
 32 #include &quot;runtime/threadSMR.hpp&quot;
 33 
 34 #ifndef PRODUCT
 35 
 36 // Constants
 37 // Keep consistent with Java constants
 38 const char *IdealGraphPrinter::INDENT = &quot;  &quot;;
 39 const char *IdealGraphPrinter::TOP_ELEMENT = &quot;graphDocument&quot;;
 40 const char *IdealGraphPrinter::GROUP_ELEMENT = &quot;group&quot;;
 41 const char *IdealGraphPrinter::GRAPH_ELEMENT = &quot;graph&quot;;
 42 const char *IdealGraphPrinter::PROPERTIES_ELEMENT = &quot;properties&quot;;
 43 const char *IdealGraphPrinter::EDGES_ELEMENT = &quot;edges&quot;;
 44 const char *IdealGraphPrinter::PROPERTY_ELEMENT = &quot;p&quot;;
 45 const char *IdealGraphPrinter::EDGE_ELEMENT = &quot;edge&quot;;
 46 const char *IdealGraphPrinter::NODE_ELEMENT = &quot;node&quot;;
 47 const char *IdealGraphPrinter::NODES_ELEMENT = &quot;nodes&quot;;
 48 const char *IdealGraphPrinter::REMOVE_EDGE_ELEMENT = &quot;removeEdge&quot;;
 49 const char *IdealGraphPrinter::REMOVE_NODE_ELEMENT = &quot;removeNode&quot;;
 50 const char *IdealGraphPrinter::METHOD_NAME_PROPERTY = &quot;name&quot;;
 51 const char *IdealGraphPrinter::METHOD_IS_PUBLIC_PROPERTY = &quot;public&quot;;
 52 const char *IdealGraphPrinter::METHOD_IS_STATIC_PROPERTY = &quot;static&quot;;
 53 const char *IdealGraphPrinter::TRUE_VALUE = &quot;true&quot;;
 54 const char *IdealGraphPrinter::NODE_NAME_PROPERTY = &quot;name&quot;;
 55 const char *IdealGraphPrinter::EDGE_NAME_PROPERTY = &quot;name&quot;;
 56 const char *IdealGraphPrinter::NODE_ID_PROPERTY = &quot;id&quot;;
 57 const char *IdealGraphPrinter::FROM_PROPERTY = &quot;from&quot;;
 58 const char *IdealGraphPrinter::TO_PROPERTY = &quot;to&quot;;
 59 const char *IdealGraphPrinter::PROPERTY_NAME_PROPERTY = &quot;name&quot;;
 60 const char *IdealGraphPrinter::GRAPH_NAME_PROPERTY = &quot;name&quot;;
 61 const char *IdealGraphPrinter::INDEX_PROPERTY = &quot;index&quot;;
 62 const char *IdealGraphPrinter::METHOD_ELEMENT = &quot;method&quot;;
 63 const char *IdealGraphPrinter::INLINE_ELEMENT = &quot;inlined&quot;;
 64 const char *IdealGraphPrinter::BYTECODES_ELEMENT = &quot;bytecodes&quot;;
 65 const char *IdealGraphPrinter::METHOD_BCI_PROPERTY = &quot;bci&quot;;
 66 const char *IdealGraphPrinter::METHOD_SHORT_NAME_PROPERTY = &quot;shortName&quot;;
 67 const char *IdealGraphPrinter::CONTROL_FLOW_ELEMENT = &quot;controlFlow&quot;;
 68 const char *IdealGraphPrinter::BLOCK_NAME_PROPERTY = &quot;name&quot;;
 69 const char *IdealGraphPrinter::BLOCK_DOMINATOR_PROPERTY = &quot;dom&quot;;
 70 const char *IdealGraphPrinter::BLOCK_ELEMENT = &quot;block&quot;;
 71 const char *IdealGraphPrinter::SUCCESSORS_ELEMENT = &quot;successors&quot;;
 72 const char *IdealGraphPrinter::SUCCESSOR_ELEMENT = &quot;successor&quot;;
 73 const char *IdealGraphPrinter::ASSEMBLY_ELEMENT = &quot;assembly&quot;;
 74 
 75 int IdealGraphPrinter::_file_count = 0;
 76 
 77 IdealGraphPrinter *IdealGraphPrinter::printer() {
 78   if (!PrintIdealGraph) {
 79     return NULL;
 80   }
 81 
 82   JavaThread *thread = JavaThread::current();
 83   if (!thread-&gt;is_Compiler_thread()) return NULL;
 84 
 85   CompilerThread *compiler_thread = (CompilerThread *)thread;
 86   if (compiler_thread-&gt;ideal_graph_printer() == NULL) {
 87     IdealGraphPrinter *printer = new IdealGraphPrinter();
 88     compiler_thread-&gt;set_ideal_graph_printer(printer);
 89   }
 90 
 91   return compiler_thread-&gt;ideal_graph_printer();
 92 }
 93 
 94 void IdealGraphPrinter::clean_up() {
 95   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *p = jtiwh.next(); ) {
 96     if (p-&gt;is_Compiler_thread()) {
 97       CompilerThread *c = (CompilerThread *)p;
 98       IdealGraphPrinter *printer = c-&gt;ideal_graph_printer();
 99       if (printer) {
100         delete printer;
101       }
102       c-&gt;set_ideal_graph_printer(NULL);
103     }
104   }
105 }
106 
107 // Constructor, either file or network output
108 IdealGraphPrinter::IdealGraphPrinter() {
109 
110   // By default dump both ins and outs since dead or unreachable code
111   // needs to appear in the graph.  There are also some special cases
112   // in the mach where kill projections have no users but should
113   // appear in the dump.
114   _traverse_outs = true;
115   _should_send_method = true;
116   _output = NULL;
117   buffer[0] = 0;
118   _depth = 0;
119   _current_method = NULL;
120   assert(!_current_method, &quot;current method must be initialized to NULL&quot;);
121   _stream = NULL;
122 
123   if (PrintIdealGraphFile != NULL) {
124     ThreadCritical tc;
125     // User wants all output to go to files
126     if (_file_count != 0) {
127       ResourceMark rm;
128       stringStream st;
129       const char* dot = strrchr(PrintIdealGraphFile, &#39;.&#39;);
130       if (dot) {
131         st.write(PrintIdealGraphFile, dot - PrintIdealGraphFile);
132         st.print(&quot;%d%s&quot;, _file_count, dot);
133       } else {
134         st.print(&quot;%s%d&quot;, PrintIdealGraphFile, _file_count);
135       }
136       fileStream *stream = new (ResourceObj::C_HEAP, mtCompiler) fileStream(st.as_string());
137       _output = stream;
138     } else {
139       fileStream *stream = new (ResourceObj::C_HEAP, mtCompiler) fileStream(PrintIdealGraphFile);
140       _output = stream;
141     }
142     _file_count++;
143   } else {
144     _stream = new (ResourceObj::C_HEAP, mtCompiler) networkStream();
145 
146     // Try to connect to visualizer
147     if (_stream-&gt;connect(PrintIdealGraphAddress, PrintIdealGraphPort)) {
148       char c = 0;
149       _stream-&gt;read(&amp;c, 1);
150       if (c != &#39;y&#39;) {
151         tty-&gt;print_cr(&quot;Client available, but does not want to receive data!&quot;);
152         _stream-&gt;close();
153         delete _stream;
154         _stream = NULL;
155         return;
156       }
157       _output = _stream;
158     } else {
159       // It would be nice if we could shut down cleanly but it should
160       // be an error if we can&#39;t connect to the visualizer.
161       fatal(&quot;Couldn&#39;t connect to visualizer at %s:&quot; INTX_FORMAT,
162             PrintIdealGraphAddress, PrintIdealGraphPort);
163     }
164   }
165 
166   _xml = new (ResourceObj::C_HEAP, mtCompiler) xmlStream(_output);
167 
168   head(TOP_ELEMENT);
169 }
170 
171 // Destructor, close file or network stream
172 IdealGraphPrinter::~IdealGraphPrinter() {
173 
174   tail(TOP_ELEMENT);
175 
176   // tty-&gt;print_cr(&quot;Walk time: %d&quot;, (int)_walk_time.milliseconds());
177   // tty-&gt;print_cr(&quot;Output time: %d&quot;, (int)_output_time.milliseconds());
178   // tty-&gt;print_cr(&quot;Build blocks time: %d&quot;, (int)_build_blocks_time.milliseconds());
179 
180   if(_xml) {
181     delete _xml;
182     _xml = NULL;
183   }
184 
185   if (_stream) {
186     delete _stream;
187     if (_stream == _output) {
188       _output = NULL;
189     }
190     _stream = NULL;
191   }
192 
193   if (_output) {
194     delete _output;
195     _output = NULL;
196   }
197 }
198 
199 void IdealGraphPrinter::begin_elem(const char *s) {
200   _xml-&gt;begin_elem(&quot;%s&quot;, s);
201 }
202 
203 void IdealGraphPrinter::end_elem() {
204   _xml-&gt;end_elem();
205 }
206 
207 void IdealGraphPrinter::begin_head(const char *s) {
208   _xml-&gt;begin_head(&quot;%s&quot;, s);
209 }
210 
211 void IdealGraphPrinter::end_head() {
212   _xml-&gt;end_head();
213 }
214 
215 void IdealGraphPrinter::print_attr(const char *name, intptr_t val) {
216   stringStream stream;
217   stream.print(INTX_FORMAT, val);
218   print_attr(name, stream.as_string());
219 }
220 
221 void IdealGraphPrinter::print_attr(const char *name, const char *val) {
222   _xml-&gt;print(&quot; %s=&#39;&quot;, name);
223   text(val);
224   _xml-&gt;print(&quot;&#39;&quot;);
225 }
226 
227 void IdealGraphPrinter::head(const char *name) {
228   _xml-&gt;head(&quot;%s&quot;, name);
229 }
230 
231 void IdealGraphPrinter::tail(const char *name) {
232   _xml-&gt;tail(name);
233 }
234 
235 void IdealGraphPrinter::text(const char *s) {
236   _xml-&gt;text(&quot;%s&quot;, s);
237 }
238 
239 void IdealGraphPrinter::print_prop(const char *name, int val) {
240   stringStream stream;
241   stream.print(&quot;%d&quot;, val);
242   print_prop(name, stream.as_string());
243 }
244 
245 void IdealGraphPrinter::print_prop(const char *name, const char *val) {
246   begin_head(PROPERTY_ELEMENT);
247   print_attr(PROPERTY_NAME_PROPERTY, name);
248   end_head();
249   text(val);
250   tail(PROPERTY_ELEMENT);
251 }
252 
253 void IdealGraphPrinter::print_method(ciMethod *method, int bci, InlineTree *tree) {
254   begin_head(METHOD_ELEMENT);
255 
256   stringStream str;
257   method-&gt;print_name(&amp;str);
258 
259   stringStream shortStr;
260   method-&gt;print_short_name(&amp;shortStr);
261 
262   print_attr(METHOD_NAME_PROPERTY, str.as_string());
263   print_attr(METHOD_SHORT_NAME_PROPERTY, shortStr.as_string());
264   print_attr(METHOD_BCI_PROPERTY, bci);
265 
266   end_head();
267 
268   head(BYTECODES_ELEMENT);
269   _xml-&gt;print_cr(&quot;&lt;![CDATA[&quot;);
270   method-&gt;print_codes_on(_xml);
271   _xml-&gt;print_cr(&quot;]]&gt;&quot;);
272   tail(BYTECODES_ELEMENT);
273 
274   if (tree != NULL &amp;&amp; tree-&gt;subtrees().length() &gt; 0) {
275     head(INLINE_ELEMENT);
276     GrowableArray&lt;InlineTree *&gt; subtrees = tree-&gt;subtrees();
277     for (int i = 0; i &lt; subtrees.length(); i++) {
278       print_inline_tree(subtrees.at(i));
279     }
280     tail(INLINE_ELEMENT);
281   }
282 
283   tail(METHOD_ELEMENT);
284   _xml-&gt;flush();
285 }
286 
287 void IdealGraphPrinter::print_inline_tree(InlineTree *tree) {
288 
289   if (tree == NULL) return;
290 
291   ciMethod *method = tree-&gt;method();
292   print_method(tree-&gt;method(), tree-&gt;caller_bci(), tree);
293 
294 }
295 
296 void IdealGraphPrinter::print_inlining() {
297 
298   // Print inline tree
299   if (_should_send_method) {
300     InlineTree *inlineTree = C-&gt;ilt();
301     if (inlineTree != NULL) {
302       print_inline_tree(inlineTree);
303     } else {
304       // print this method only
305     }
306   }
307 }
308 
309 // Has to be called whenever a method is compiled
310 void IdealGraphPrinter::begin_method() {
311 
312   ciMethod *method = C-&gt;method();
313   assert(_output, &quot;output stream must exist!&quot;);
314   assert(method, &quot;null methods are not allowed!&quot;);
315   assert(!_current_method, &quot;current method must be null!&quot;);
316 
317   head(GROUP_ELEMENT);
318 
319   head(PROPERTIES_ELEMENT);
320 
321   // Print properties
322   // Add method name
323   stringStream strStream;
324   method-&gt;print_name(&amp;strStream);
325   print_prop(METHOD_NAME_PROPERTY, strStream.as_string());
326 
327   if (method-&gt;flags().is_public()) {
328     print_prop(METHOD_IS_PUBLIC_PROPERTY, TRUE_VALUE);
329   }
330 
331   if (method-&gt;flags().is_static()) {
332     print_prop(METHOD_IS_STATIC_PROPERTY, TRUE_VALUE);
333   }
334 
335   tail(PROPERTIES_ELEMENT);
336 
337   _should_send_method = true;
338   this-&gt;_current_method = method;
339 
340   _xml-&gt;flush();
341 }
342 
343 // Has to be called whenever a method has finished compilation
344 void IdealGraphPrinter::end_method() {
345 
346   nmethod* method = (nmethod*)this-&gt;_current_method-&gt;code();
347 
348   tail(GROUP_ELEMENT);
349   _current_method = NULL;
350   _xml-&gt;flush();
351 }
352 
<a name="1" id="anc1"></a><span class="line-removed">353 // Print indent</span>
<span class="line-removed">354 void IdealGraphPrinter::print_indent() {</span>
<span class="line-removed">355   tty-&gt;print_cr(&quot;printing indent %d&quot;, _depth);</span>
<span class="line-removed">356   for (int i = 0; i &lt; _depth; i++) {</span>
<span class="line-removed">357     _xml-&gt;print(&quot;%s&quot;, INDENT);</span>
<span class="line-removed">358   }</span>
<span class="line-removed">359 }</span>
<span class="line-removed">360 </span>
361 bool IdealGraphPrinter::traverse_outs() {
362   return _traverse_outs;
363 }
364 
365 void IdealGraphPrinter::set_traverse_outs(bool b) {
366   _traverse_outs = b;
367 }
368 
369 void IdealGraphPrinter::visit_node(Node *n, bool edges, VectorSet* temp_set) {
370 
371   if (edges) {
372 
373     // Output edge
374     node_idx_t dest_id = n-&gt;_idx;
375     for ( uint i = 0; i &lt; n-&gt;len(); i++ ) {
376       if ( n-&gt;in(i) ) {
377         Node *source = n-&gt;in(i);
378         begin_elem(EDGE_ELEMENT);
379         print_attr(FROM_PROPERTY, source-&gt;_idx);
380         print_attr(TO_PROPERTY, dest_id);
381         print_attr(INDEX_PROPERTY, i);
382         end_elem();
383       }
384     }
385 
386   } else {
387 
388     // Output node
389     begin_head(NODE_ELEMENT);
390     print_attr(NODE_ID_PROPERTY, n-&gt;_idx);
391     end_head();
392 
393     head(PROPERTIES_ELEMENT);
394 
395     Node *node = n;
396 #ifndef PRODUCT
397     Compile::current()-&gt;_in_dump_cnt++;
398     print_prop(NODE_NAME_PROPERTY, (const char *)node-&gt;Name());
399     const Type *t = node-&gt;bottom_type();
400     print_prop(&quot;type&quot;, t-&gt;msg());
401     print_prop(&quot;idx&quot;, node-&gt;_idx);
402 #ifdef ASSERT
403     print_prop(&quot;debug_idx&quot;, node-&gt;_debug_idx);
404 #endif
405 
406     if (C-&gt;cfg() != NULL) {
407       Block* block = C-&gt;cfg()-&gt;get_block_for_node(node);
408       if (block == NULL) {
409         print_prop(&quot;block&quot;, C-&gt;cfg()-&gt;get_block(0)-&gt;_pre_order);
410       } else {
411         print_prop(&quot;block&quot;, block-&gt;_pre_order);
412       }
413     }
414 
415     const jushort flags = node-&gt;flags();
416     if (flags &amp; Node::Flag_is_Copy) {
417       print_prop(&quot;is_copy&quot;, &quot;true&quot;);
418     }
419     if (flags &amp; Node::Flag_rematerialize) {
420       print_prop(&quot;rematerialize&quot;, &quot;true&quot;);
421     }
422     if (flags &amp; Node::Flag_needs_anti_dependence_check) {
423       print_prop(&quot;needs_anti_dependence_check&quot;, &quot;true&quot;);
424     }
425     if (flags &amp; Node::Flag_is_macro) {
426       print_prop(&quot;is_macro&quot;, &quot;true&quot;);
427     }
428     if (flags &amp; Node::Flag_is_Con) {
429       print_prop(&quot;is_con&quot;, &quot;true&quot;);
430     }
431     if (flags &amp; Node::Flag_is_cisc_alternate) {
432       print_prop(&quot;is_cisc_alternate&quot;, &quot;true&quot;);
433     }
434     if (flags &amp; Node::Flag_is_dead_loop_safe) {
435       print_prop(&quot;is_dead_loop_safe&quot;, &quot;true&quot;);
436     }
437     if (flags &amp; Node::Flag_may_be_short_branch) {
438       print_prop(&quot;may_be_short_branch&quot;, &quot;true&quot;);
439     }
440     if (flags &amp; Node::Flag_has_call) {
441       print_prop(&quot;has_call&quot;, &quot;true&quot;);
442     }
443 
444     if (C-&gt;matcher() != NULL) {
445       if (C-&gt;matcher()-&gt;is_shared(node)) {
446         print_prop(&quot;is_shared&quot;, &quot;true&quot;);
447       } else {
448         print_prop(&quot;is_shared&quot;, &quot;false&quot;);
449       }
450       if (C-&gt;matcher()-&gt;is_dontcare(node)) {
451         print_prop(&quot;is_dontcare&quot;, &quot;true&quot;);
452       } else {
453         print_prop(&quot;is_dontcare&quot;, &quot;false&quot;);
454       }
455 
456 #ifdef ASSERT
457       Node* old = C-&gt;matcher()-&gt;find_old_node(node);
458       if (old != NULL) {
459         print_prop(&quot;old_node_idx&quot;, old-&gt;_idx);
460       }
461 #endif
462     }
463 
464     if (node-&gt;is_Proj()) {
465       print_prop(&quot;con&quot;, (int)node-&gt;as_Proj()-&gt;_con);
466     }
467 
468     if (node-&gt;is_Mach()) {
469       print_prop(&quot;idealOpcode&quot;, (const char *)NodeClassNames[node-&gt;as_Mach()-&gt;ideal_Opcode()]);
470     }
471 
472     buffer[0] = 0;
473     stringStream s2(buffer, sizeof(buffer) - 1);
474 
475     node-&gt;dump_spec(&amp;s2);
476     if (t != NULL &amp;&amp; (t-&gt;isa_instptr() || t-&gt;isa_klassptr())) {
477       const TypeInstPtr  *toop = t-&gt;isa_instptr();
478       const TypeKlassPtr *tkls = t-&gt;isa_klassptr();
479       ciKlass*           klass = toop ? toop-&gt;klass() : (tkls ? tkls-&gt;klass() : NULL );
480       if( klass &amp;&amp; klass-&gt;is_loaded() &amp;&amp; klass-&gt;is_interface() ) {
481         s2.print(&quot;  Interface:&quot;);
482       } else if( toop ) {
483         s2.print(&quot;  Oop:&quot;);
484       } else if( tkls ) {
485         s2.print(&quot;  Klass:&quot;);
486       }
487       t-&gt;dump_on(&amp;s2);
488     } else if( t == Type::MEMORY ) {
489       s2.print(&quot;  Memory:&quot;);
490       MemNode::dump_adr_type(node, node-&gt;adr_type(), &amp;s2);
491     }
492 
493     assert(s2.size() &lt; sizeof(buffer), &quot;size in range&quot;);
494     print_prop(&quot;dump_spec&quot;, buffer);
495 
496     if (node-&gt;is_block_proj()) {
497       print_prop(&quot;is_block_proj&quot;, &quot;true&quot;);
498     }
499 
500     if (node-&gt;is_block_start()) {
501       print_prop(&quot;is_block_start&quot;, &quot;true&quot;);
502     }
503 
504     const char *short_name = &quot;short_name&quot;;
505     if (strcmp(node-&gt;Name(), &quot;Parm&quot;) == 0 &amp;&amp; node-&gt;as_Proj()-&gt;_con &gt;= TypeFunc::Parms) {
506       int index = node-&gt;as_Proj()-&gt;_con - TypeFunc::Parms;
507       if (index &gt;= 10) {
508         print_prop(short_name, &quot;PA&quot;);
509       } else {
510         sprintf(buffer, &quot;P%d&quot;, index);
511         print_prop(short_name, buffer);
512       }
513     } else if (strcmp(node-&gt;Name(), &quot;IfTrue&quot;) == 0) {
514       print_prop(short_name, &quot;T&quot;);
515     } else if (strcmp(node-&gt;Name(), &quot;IfFalse&quot;) == 0) {
516       print_prop(short_name, &quot;F&quot;);
517     } else if ((node-&gt;is_Con() &amp;&amp; node-&gt;is_Type()) || node-&gt;is_Proj()) {
518 
519       if (t-&gt;base() == Type::Int &amp;&amp; t-&gt;is_int()-&gt;is_con()) {
520         const TypeInt *typeInt = t-&gt;is_int();
521         assert(typeInt-&gt;is_con(), &quot;must be constant&quot;);
522         jint value = typeInt-&gt;get_con();
523 
524         // max. 2 chars allowed
525         if (value &gt;= -9 &amp;&amp; value &lt;= 99) {
526           sprintf(buffer, &quot;%d&quot;, value);
527           print_prop(short_name, buffer);
528         } else {
529           print_prop(short_name, &quot;I&quot;);
530         }
531       } else if (t == Type::TOP) {
532         print_prop(short_name, &quot;^&quot;);
533       } else if (t-&gt;base() == Type::Long &amp;&amp; t-&gt;is_long()-&gt;is_con()) {
534         const TypeLong *typeLong = t-&gt;is_long();
535         assert(typeLong-&gt;is_con(), &quot;must be constant&quot;);
536         jlong value = typeLong-&gt;get_con();
537 
538         // max. 2 chars allowed
539         if (value &gt;= -9 &amp;&amp; value &lt;= 99) {
540           sprintf(buffer, JLONG_FORMAT, value);
541           print_prop(short_name, buffer);
542         } else {
543           print_prop(short_name, &quot;L&quot;);
544         }
545       } else if (t-&gt;base() == Type::KlassPtr) {
546         const TypeKlassPtr *typeKlass = t-&gt;is_klassptr();
547         print_prop(short_name, &quot;CP&quot;);
548       } else if (t-&gt;base() == Type::Control) {
549         print_prop(short_name, &quot;C&quot;);
550       } else if (t-&gt;base() == Type::Memory) {
551         print_prop(short_name, &quot;M&quot;);
552       } else if (t-&gt;base() == Type::Abio) {
553         print_prop(short_name, &quot;IO&quot;);
554       } else if (t-&gt;base() == Type::Return_Address) {
555         print_prop(short_name, &quot;RA&quot;);
556       } else if (t-&gt;base() == Type::AnyPtr) {
557         print_prop(short_name, &quot;P&quot;);
558       } else if (t-&gt;base() == Type::RawPtr) {
559         print_prop(short_name, &quot;RP&quot;);
560       } else if (t-&gt;base() == Type::AryPtr) {
561         print_prop(short_name, &quot;AP&quot;);
562       }
563     }
564 
565     JVMState* caller = NULL;
566     if (node-&gt;is_SafePoint()) {
567       caller = node-&gt;as_SafePoint()-&gt;jvms();
568     } else {
569       Node_Notes* notes = C-&gt;node_notes_at(node-&gt;_idx);
570       if (notes != NULL) {
571         caller = notes-&gt;jvms();
572       }
573     }
574 
575     if (caller != NULL) {
576       stringStream bciStream;
577       ciMethod* last = NULL;
578       int last_bci;
579       while(caller) {
580         if (caller-&gt;has_method()) {
581           last = caller-&gt;method();
582           last_bci = caller-&gt;bci();
583         }
584         bciStream.print(&quot;%d &quot;, caller-&gt;bci());
585         caller = caller-&gt;caller();
586       }
587       print_prop(&quot;bci&quot;, bciStream.as_string());
588       if (last != NULL &amp;&amp; last-&gt;has_linenumber_table() &amp;&amp; last_bci &gt;= 0) {
589         print_prop(&quot;line&quot;, last-&gt;line_number_from_bci(last_bci));
590       }
591     }
592 
593 #ifdef ASSERT
594     if (node-&gt;debug_orig() != NULL) {
<a name="2" id="anc2"></a><span class="line-modified">595       temp_set-&gt;Clear();</span>
596       stringStream dorigStream;
597       Node* dorig = node-&gt;debug_orig();
598       while (dorig &amp;&amp; temp_set-&gt;test_set(dorig-&gt;_idx)) {
599         dorigStream.print(&quot;%d &quot;, dorig-&gt;_idx);
600       }
601       print_prop(&quot;debug_orig&quot;, dorigStream.as_string());
602     }
603 #endif
604 
605     if (_chaitin &amp;&amp; _chaitin != (PhaseChaitin *)((intptr_t)0xdeadbeef)) {
606       buffer[0] = 0;
607       _chaitin-&gt;dump_register(node, buffer);
608       print_prop(&quot;reg&quot;, buffer);
609       uint lrg_id = 0;
610       if (node-&gt;_idx &lt; _chaitin-&gt;_lrg_map.size()) {
611         lrg_id = _chaitin-&gt;_lrg_map.live_range_id(node);
612       }
613       print_prop(&quot;lrg&quot;, lrg_id);
614     }
615 
616     Compile::current()-&gt;_in_dump_cnt--;
617 #endif
618 
619     tail(PROPERTIES_ELEMENT);
620     tail(NODE_ELEMENT);
621   }
622 }
623 
624 void IdealGraphPrinter::walk_nodes(Node *start, bool edges, VectorSet* temp_set) {
625 
626 
627   VectorSet visited(Thread::current()-&gt;resource_area());
628   GrowableArray&lt;Node *&gt; nodeStack(Thread::current()-&gt;resource_area(), 0, 0, NULL);
629   nodeStack.push(start);
630   visited.test_set(start-&gt;_idx);
631   if (C-&gt;cfg() != NULL) {
632     // once we have a CFG there are some nodes that aren&#39;t really
633     // reachable but are in the CFG so add them here.
634     for (uint i = 0; i &lt; C-&gt;cfg()-&gt;number_of_blocks(); i++) {
635       Block* block = C-&gt;cfg()-&gt;get_block(i);
636       for (uint s = 0; s &lt; block-&gt;number_of_nodes(); s++) {
637         nodeStack.push(block-&gt;get_node(s));
638       }
639     }
640   }
641 
642   while(nodeStack.length() &gt; 0) {
643 
644     Node *n = nodeStack.pop();
645     visit_node(n, edges, temp_set);
646 
647     if (_traverse_outs) {
648       for (DUIterator i = n-&gt;outs(); n-&gt;has_out(i); i++) {
649         Node* p = n-&gt;out(i);
650         if (!visited.test_set(p-&gt;_idx)) {
651           nodeStack.push(p);
652         }
653       }
654     }
655 
656     for ( uint i = 0; i &lt; n-&gt;len(); i++ ) {
657       if ( n-&gt;in(i) ) {
658         if (!visited.test_set(n-&gt;in(i)-&gt;_idx)) {
659           nodeStack.push(n-&gt;in(i));
660         }
661       }
662     }
663   }
664 }
665 
<a name="3" id="anc3"></a><span class="line-modified">666 void IdealGraphPrinter::print_method(const char *name, int level, bool clear_nodes) {</span>
<span class="line-modified">667   print(name, (Node *)C-&gt;root(), level, clear_nodes);</span>


668 }
669 
670 // Print current ideal graph
<a name="4" id="anc4"></a><span class="line-modified">671 void IdealGraphPrinter::print(const char *name, Node *node, int level, bool clear_nodes) {</span>
672 
<a name="5" id="anc5"></a><span class="line-modified">673   if (!_current_method || !_should_send_method || !should_print(level)) return;</span>
674 
675   // Warning, unsafe cast?
676   _chaitin = (PhaseChaitin *)C-&gt;regalloc();
677 
678   begin_head(GRAPH_ELEMENT);
679   print_attr(GRAPH_NAME_PROPERTY, (const char *)name);
680   end_head();
681 
682   VectorSet temp_set(Thread::current()-&gt;resource_area());
683 
684   head(NODES_ELEMENT);
685   walk_nodes(node, false, &amp;temp_set);
686   tail(NODES_ELEMENT);
687 
688   head(EDGES_ELEMENT);
689   walk_nodes(node, true, &amp;temp_set);
690   tail(EDGES_ELEMENT);
691   if (C-&gt;cfg() != NULL) {
692     head(CONTROL_FLOW_ELEMENT);
693     for (uint i = 0; i &lt; C-&gt;cfg()-&gt;number_of_blocks(); i++) {
694       Block* block = C-&gt;cfg()-&gt;get_block(i);
695       begin_head(BLOCK_ELEMENT);
696       print_attr(BLOCK_NAME_PROPERTY, block-&gt;_pre_order);
697       end_head();
698 
699       head(SUCCESSORS_ELEMENT);
700       for (uint s = 0; s &lt; block-&gt;_num_succs; s++) {
701         begin_elem(SUCCESSOR_ELEMENT);
702         print_attr(BLOCK_NAME_PROPERTY, block-&gt;_succs[s]-&gt;_pre_order);
703         end_elem();
704       }
705       tail(SUCCESSORS_ELEMENT);
706 
707       head(NODES_ELEMENT);
708       for (uint s = 0; s &lt; block-&gt;number_of_nodes(); s++) {
709         begin_elem(NODE_ELEMENT);
710         print_attr(NODE_ID_PROPERTY, block-&gt;get_node(s)-&gt;_idx);
711         end_elem();
712       }
713       tail(NODES_ELEMENT);
714 
715       tail(BLOCK_ELEMENT);
716     }
717     tail(CONTROL_FLOW_ELEMENT);
718   }
719   tail(GRAPH_ELEMENT);
720   _xml-&gt;flush();
721 }
722 
723 // Should method be printed?
724 bool IdealGraphPrinter::should_print(int level) {
725   return C-&gt;directive()-&gt;IGVPrintLevelOption &gt;= level;
726 }
727 
728 extern const char *NodeClassNames[];
729 
730 #endif
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
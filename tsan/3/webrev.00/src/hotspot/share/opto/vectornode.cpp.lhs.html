<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/vectornode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2007, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;memory/allocation.inline.hpp&quot;
 26 #include &quot;opto/connode.hpp&quot;
 27 #include &quot;opto/vectornode.hpp&quot;
<a name="1" id="anc1"></a>
 28 
 29 //------------------------------VectorNode--------------------------------------
 30 
 31 // Return the vector operator for the specified scalar operation
 32 // and vector length.
 33 int VectorNode::opcode(int sopc, BasicType bt) {
 34   switch (sopc) {
 35   case Op_AddI:
 36     switch (bt) {
 37     case T_BOOLEAN:
 38     case T_BYTE:      return Op_AddVB;
 39     case T_CHAR:
 40     case T_SHORT:     return Op_AddVS;
 41     case T_INT:       return Op_AddVI;
 42     default:          ShouldNotReachHere(); return 0;
 43     }
 44   case Op_AddL:
 45     assert(bt == T_LONG, &quot;must be&quot;);
 46     return Op_AddVL;
 47   case Op_AddF:
 48     assert(bt == T_FLOAT, &quot;must be&quot;);
 49     return Op_AddVF;
 50   case Op_AddD:
 51     assert(bt == T_DOUBLE, &quot;must be&quot;);
 52     return Op_AddVD;
 53   case Op_SubI:
 54     switch (bt) {
 55     case T_BOOLEAN:
 56     case T_BYTE:   return Op_SubVB;
 57     case T_CHAR:
 58     case T_SHORT:  return Op_SubVS;
 59     case T_INT:    return Op_SubVI;
 60     default:       ShouldNotReachHere(); return 0;
 61     }
 62   case Op_SubL:
 63     assert(bt == T_LONG, &quot;must be&quot;);
 64     return Op_SubVL;
 65   case Op_SubF:
 66     assert(bt == T_FLOAT, &quot;must be&quot;);
 67     return Op_SubVF;
 68   case Op_SubD:
 69     assert(bt == T_DOUBLE, &quot;must be&quot;);
 70     return Op_SubVD;
 71   case Op_MulI:
 72     switch (bt) {
<a name="2" id="anc2"></a><span class="line-modified"> 73     case T_BOOLEAN:</span>
<span class="line-modified"> 74     case T_BYTE:   return 0;   // Unimplemented</span>
 75     case T_CHAR:
 76     case T_SHORT:  return Op_MulVS;
 77     case T_INT:    return Op_MulVI;
 78     default:       ShouldNotReachHere(); return 0;
 79     }
 80   case Op_MulL:
 81     assert(bt == T_LONG, &quot;must be&quot;);
 82     return Op_MulVL;
 83   case Op_MulF:
 84     assert(bt == T_FLOAT, &quot;must be&quot;);
 85     return Op_MulVF;
 86   case Op_MulD:
 87     assert(bt == T_DOUBLE, &quot;must be&quot;);
 88     return Op_MulVD;
 89   case Op_FmaD:
 90     assert(bt == T_DOUBLE, &quot;must be&quot;);
 91     return Op_FmaVD;
 92   case Op_FmaF:
 93     assert(bt == T_FLOAT, &quot;must be&quot;);
 94     return Op_FmaVF;
 95   case Op_CMoveF:
 96     assert(bt == T_FLOAT, &quot;must be&quot;);
 97     return Op_CMoveVF;
 98   case Op_CMoveD:
 99     assert(bt == T_DOUBLE, &quot;must be&quot;);
100     return Op_CMoveVD;
101   case Op_DivF:
102     assert(bt == T_FLOAT, &quot;must be&quot;);
103     return Op_DivVF;
104   case Op_DivD:
105     assert(bt == T_DOUBLE, &quot;must be&quot;);
106     return Op_DivVD;
<a name="3" id="anc3"></a>











107   case Op_AbsF:
108     assert(bt == T_FLOAT, &quot;must be&quot;);
109     return Op_AbsVF;
110   case Op_AbsD:
111     assert(bt == T_DOUBLE, &quot;must be&quot;);
112     return Op_AbsVD;
113   case Op_NegF:
114     assert(bt == T_FLOAT, &quot;must be&quot;);
115     return Op_NegVF;
116   case Op_NegD:
117     assert(bt == T_DOUBLE, &quot;must be&quot;);
118     return Op_NegVD;
<a name="4" id="anc4"></a>


119   case Op_SqrtF:
120     assert(bt == T_FLOAT, &quot;must be&quot;);
121     return Op_SqrtVF;
122   case Op_SqrtD:
123     assert(bt == T_DOUBLE, &quot;must be&quot;);
124     return Op_SqrtVD;
125   case Op_PopCountI:
126     if (bt == T_INT) {
127       return Op_PopCountVI;
128     }
129     // Unimplemented for subword types since bit count changes
130     // depending on size of lane (and sign bit).
131     return 0;
132   case Op_LShiftI:
133     switch (bt) {
134     case T_BOOLEAN:
135     case T_BYTE:   return Op_LShiftVB;
136     case T_CHAR:
137     case T_SHORT:  return Op_LShiftVS;
138     case T_INT:    return Op_LShiftVI;
139       default:       ShouldNotReachHere(); return 0;
140     }
141   case Op_LShiftL:
142     assert(bt == T_LONG, &quot;must be&quot;);
143     return Op_LShiftVL;
144   case Op_RShiftI:
145     switch (bt) {
146     case T_BOOLEAN:return Op_URShiftVB; // boolean is unsigned value
147     case T_CHAR:   return Op_URShiftVS; // char is unsigned value
148     case T_BYTE:   return Op_RShiftVB;
149     case T_SHORT:  return Op_RShiftVS;
150     case T_INT:    return Op_RShiftVI;
151     default:       ShouldNotReachHere(); return 0;
152     }
153   case Op_RShiftL:
154     assert(bt == T_LONG, &quot;must be&quot;);
155     return Op_RShiftVL;
156   case Op_URShiftI:
157     switch (bt) {
158     case T_BOOLEAN:return Op_URShiftVB;
159     case T_CHAR:   return Op_URShiftVS;
160     case T_BYTE:
161     case T_SHORT:  return 0; // Vector logical right shift for signed short
162                              // values produces incorrect Java result for
163                              // negative data because java code should convert
164                              // a short value into int value with sign
165                              // extension before a shift.
166     case T_INT:    return Op_URShiftVI;
167     default:       ShouldNotReachHere(); return 0;
168     }
169   case Op_URShiftL:
170     assert(bt == T_LONG, &quot;must be&quot;);
171     return Op_URShiftVL;
172   case Op_AndI:
173   case Op_AndL:
174     return Op_AndV;
175   case Op_OrI:
176   case Op_OrL:
177     return Op_OrV;
178   case Op_XorI:
179   case Op_XorL:
180     return Op_XorV;
181   case Op_MinF:
182     assert(bt == T_FLOAT, &quot;must be&quot;);
183     return Op_MinV;
184   case Op_MinD:
185     assert(bt == T_DOUBLE, &quot;must be&quot;);
186     return Op_MinV;
187   case Op_MaxF:
188     assert(bt == T_FLOAT, &quot;must be&quot;);
189     return Op_MaxV;
190   case Op_MaxD:
191     assert(bt == T_DOUBLE, &quot;must be&quot;);
192     return Op_MaxV;
193 
194   case Op_LoadB:
195   case Op_LoadUB:
196   case Op_LoadUS:
197   case Op_LoadS:
198   case Op_LoadI:
199   case Op_LoadL:
200   case Op_LoadF:
201   case Op_LoadD:
202     return Op_LoadVector;
203 
204   case Op_StoreB:
205   case Op_StoreC:
206   case Op_StoreI:
207   case Op_StoreL:
208   case Op_StoreF:
209   case Op_StoreD:
210     return Op_StoreVector;
211   case Op_MulAddS2I:
212     return Op_MulAddVS2VI;
213 
214   default:
215     return 0; // Unimplemented
216   }
217 }
218 
219 // Also used to check if the code generator
220 // supports the vector operation.
221 bool VectorNode::implemented(int opc, uint vlen, BasicType bt) {
222   if (is_java_primitive(bt) &amp;&amp;
223       (vlen &gt; 1) &amp;&amp; is_power_of_2(vlen) &amp;&amp;
224       Matcher::vector_size_supported(bt, vlen)) {
225     int vopc = VectorNode::opcode(opc, bt);
<a name="5" id="anc5"></a><span class="line-modified">226     return vopc &gt; 0 &amp;&amp; Matcher::match_rule_supported_vector(vopc, vlen);</span>
227   }
228   return false;
229 }
230 
231 bool VectorNode::is_type_transition_short_to_int(Node* n) {
232   switch (n-&gt;Opcode()) {
233   case Op_MulAddS2I:
234     return true;
235   }
236   return false;
237 }
238 
239 bool VectorNode::is_type_transition_to_int(Node* n) {
240   return is_type_transition_short_to_int(n);
241 }
242 
243 bool VectorNode::is_muladds2i(Node* n) {
244   if (n-&gt;Opcode() == Op_MulAddS2I) {
245     return true;
246   }
247   return false;
248 }
249 
<a name="6" id="anc6"></a>






250 bool VectorNode::is_shift(Node* n) {
251   switch (n-&gt;Opcode()) {
252   case Op_LShiftI:
253   case Op_LShiftL:
254   case Op_RShiftI:
255   case Op_RShiftL:
256   case Op_URShiftI:
257   case Op_URShiftL:
258     return true;
259   default:
260     return false;
261   }
262 }
263 
264 // Check if input is loop invariant vector.
265 bool VectorNode::is_invariant_vector(Node* n) {
266   // Only Replicate vector nodes are loop invariant for now.
267   switch (n-&gt;Opcode()) {
268   case Op_ReplicateB:
269   case Op_ReplicateS:
270   case Op_ReplicateI:
271   case Op_ReplicateL:
272   case Op_ReplicateF:
273   case Op_ReplicateD:
274     return true;
275   default:
276     return false;
277   }
278 }
279 
280 // [Start, end) half-open range defining which operands are vectors
281 void VectorNode::vector_operands(Node* n, uint* start, uint* end) {
282   switch (n-&gt;Opcode()) {
283   case Op_LoadB:   case Op_LoadUB:
284   case Op_LoadS:   case Op_LoadUS:
285   case Op_LoadI:   case Op_LoadL:
286   case Op_LoadF:   case Op_LoadD:
287   case Op_LoadP:   case Op_LoadN:
<a name="7" id="anc7"></a><span class="line-removed">288   case Op_LoadBarrierSlowReg:</span>
<span class="line-removed">289   case Op_LoadBarrierWeakSlowReg:</span>
290     *start = 0;
291     *end   = 0; // no vector operands
292     break;
293   case Op_StoreB:  case Op_StoreC:
294   case Op_StoreI:  case Op_StoreL:
295   case Op_StoreF:  case Op_StoreD:
296   case Op_StoreP:  case Op_StoreN:
297     *start = MemNode::ValueIn;
298     *end   = MemNode::ValueIn + 1; // 1 vector operand
299     break;
300   case Op_LShiftI:  case Op_LShiftL:
301   case Op_RShiftI:  case Op_RShiftL:
302   case Op_URShiftI: case Op_URShiftL:
303     *start = 1;
304     *end   = 2; // 1 vector operand
305     break;
306   case Op_AddI: case Op_AddL: case Op_AddF: case Op_AddD:
307   case Op_SubI: case Op_SubL: case Op_SubF: case Op_SubD:
308   case Op_MulI: case Op_MulL: case Op_MulF: case Op_MulD:
309   case Op_DivF: case Op_DivD:
310   case Op_AndI: case Op_AndL:
311   case Op_OrI:  case Op_OrL:
312   case Op_XorI: case Op_XorL:
313   case Op_MulAddS2I:
314     *start = 1;
315     *end   = 3; // 2 vector operands
316     break;
317   case Op_CMoveI:  case Op_CMoveL:  case Op_CMoveF:  case Op_CMoveD:
318     *start = 2;
319     *end   = n-&gt;req();
320     break;
321   case Op_FmaD:
322   case Op_FmaF:
323     *start = 1;
324     *end   = 4; // 3 vector operands
325     break;
326   default:
327     *start = 1;
328     *end   = n-&gt;req(); // default is all operands
329   }
330 }
331 
332 // Return the vector version of a scalar operation node.
333 VectorNode* VectorNode::make(int opc, Node* n1, Node* n2, uint vlen, BasicType bt) {
334   const TypeVect* vt = TypeVect::make(bt, vlen);
335   int vopc = VectorNode::opcode(opc, bt);
336   // This method should not be called for unimplemented vectors.
337   guarantee(vopc &gt; 0, &quot;Vector for &#39;%s&#39; is not implemented&quot;, NodeClassNames[opc]);
338   switch (vopc) {
339   case Op_AddVB: return new AddVBNode(n1, n2, vt);
340   case Op_AddVS: return new AddVSNode(n1, n2, vt);
341   case Op_AddVI: return new AddVINode(n1, n2, vt);
342   case Op_AddVL: return new AddVLNode(n1, n2, vt);
343   case Op_AddVF: return new AddVFNode(n1, n2, vt);
344   case Op_AddVD: return new AddVDNode(n1, n2, vt);
345 
346   case Op_SubVB: return new SubVBNode(n1, n2, vt);
347   case Op_SubVS: return new SubVSNode(n1, n2, vt);
348   case Op_SubVI: return new SubVINode(n1, n2, vt);
349   case Op_SubVL: return new SubVLNode(n1, n2, vt);
350   case Op_SubVF: return new SubVFNode(n1, n2, vt);
351   case Op_SubVD: return new SubVDNode(n1, n2, vt);
352 
<a name="8" id="anc8"></a>
353   case Op_MulVS: return new MulVSNode(n1, n2, vt);
354   case Op_MulVI: return new MulVINode(n1, n2, vt);
355   case Op_MulVL: return new MulVLNode(n1, n2, vt);
356   case Op_MulVF: return new MulVFNode(n1, n2, vt);
357   case Op_MulVD: return new MulVDNode(n1, n2, vt);
358 
359   case Op_DivVF: return new DivVFNode(n1, n2, vt);
360   case Op_DivVD: return new DivVDNode(n1, n2, vt);
361 
<a name="9" id="anc9"></a>



362   case Op_AbsVF: return new AbsVFNode(n1, vt);
363   case Op_AbsVD: return new AbsVDNode(n1, vt);
364 
365   case Op_NegVF: return new NegVFNode(n1, vt);
366   case Op_NegVD: return new NegVDNode(n1, vt);
367 
368   case Op_SqrtVF: return new SqrtVFNode(n1, vt);
369   case Op_SqrtVD: return new SqrtVDNode(n1, vt);
370 
371   case Op_PopCountVI: return new PopCountVINode(n1, vt);
372 
373   case Op_LShiftVB: return new LShiftVBNode(n1, n2, vt);
374   case Op_LShiftVS: return new LShiftVSNode(n1, n2, vt);
375   case Op_LShiftVI: return new LShiftVINode(n1, n2, vt);
376   case Op_LShiftVL: return new LShiftVLNode(n1, n2, vt);
377 
378   case Op_RShiftVB: return new RShiftVBNode(n1, n2, vt);
379   case Op_RShiftVS: return new RShiftVSNode(n1, n2, vt);
380   case Op_RShiftVI: return new RShiftVINode(n1, n2, vt);
381   case Op_RShiftVL: return new RShiftVLNode(n1, n2, vt);
382 
383   case Op_URShiftVB: return new URShiftVBNode(n1, n2, vt);
384   case Op_URShiftVS: return new URShiftVSNode(n1, n2, vt);
385   case Op_URShiftVI: return new URShiftVINode(n1, n2, vt);
386   case Op_URShiftVL: return new URShiftVLNode(n1, n2, vt);
387 
388   case Op_AndV: return new AndVNode(n1, n2, vt);
389   case Op_OrV:  return new OrVNode (n1, n2, vt);
390   case Op_XorV: return new XorVNode(n1, n2, vt);
391 
392   case Op_MinV: return new MinVNode(n1, n2, vt);
393   case Op_MaxV: return new MaxVNode(n1, n2, vt);
394 
<a name="10" id="anc10"></a>

395   case Op_MulAddVS2VI: return new MulAddVS2VINode(n1, n2, vt);
396   default:
397     fatal(&quot;Missed vector creation for &#39;%s&#39;&quot;, NodeClassNames[vopc]);
398     return NULL;
399   }
400 }
401 
402 VectorNode* VectorNode::make(int opc, Node* n1, Node* n2, Node* n3, uint vlen, BasicType bt) {
403   const TypeVect* vt = TypeVect::make(bt, vlen);
404   int vopc = VectorNode::opcode(opc, bt);
405   // This method should not be called for unimplemented vectors.
406   guarantee(vopc &gt; 0, &quot;Vector for &#39;%s&#39; is not implemented&quot;, NodeClassNames[opc]);
407   switch (vopc) {
408   case Op_FmaVD: return new FmaVDNode(n1, n2, n3, vt);
409   case Op_FmaVF: return new FmaVFNode(n1, n2, n3, vt);
410   default:
411     fatal(&quot;Missed vector creation for &#39;%s&#39;&quot;, NodeClassNames[vopc]);
412     return NULL;
413   }
414 }
415 
416 // Scalar promotion
417 VectorNode* VectorNode::scalar2vector(Node* s, uint vlen, const Type* opd_t) {
418   BasicType bt = opd_t-&gt;array_element_basic_type();
419   const TypeVect* vt = opd_t-&gt;singleton() ? TypeVect::make(opd_t, vlen)
420                                           : TypeVect::make(bt, vlen);
421   switch (bt) {
422   case T_BOOLEAN:
423   case T_BYTE:
424     return new ReplicateBNode(s, vt);
425   case T_CHAR:
426   case T_SHORT:
427     return new ReplicateSNode(s, vt);
428   case T_INT:
429     return new ReplicateINode(s, vt);
430   case T_LONG:
431     return new ReplicateLNode(s, vt);
432   case T_FLOAT:
433     return new ReplicateFNode(s, vt);
434   case T_DOUBLE:
435     return new ReplicateDNode(s, vt);
436   default:
437     fatal(&quot;Type &#39;%s&#39; is not supported for vectors&quot;, type2name(bt));
438     return NULL;
439   }
440 }
441 
442 VectorNode* VectorNode::shift_count(Node* shift, Node* cnt, uint vlen, BasicType bt) {
<a name="11" id="anc11"></a><span class="line-modified">443   assert(VectorNode::is_shift(shift) &amp;&amp; !cnt-&gt;is_Con(), &quot;only variable shift count&quot;);</span>
444   // Match shift count type with shift vector type.
445   const TypeVect* vt = TypeVect::make(bt, vlen);
446   switch (shift-&gt;Opcode()) {
447   case Op_LShiftI:
448   case Op_LShiftL:
449     return new LShiftCntVNode(cnt, vt);
450   case Op_RShiftI:
451   case Op_RShiftL:
452   case Op_URShiftI:
453   case Op_URShiftL:
454     return new RShiftCntVNode(cnt, vt);
455   default:
456     fatal(&quot;Missed vector creation for &#39;%s&#39;&quot;, NodeClassNames[shift-&gt;Opcode()]);
457     return NULL;
458   }
459 }
460 
<a name="12" id="anc12"></a>































461 // Return initial Pack node. Additional operands added with add_opd() calls.
462 PackNode* PackNode::make(Node* s, uint vlen, BasicType bt) {
463   const TypeVect* vt = TypeVect::make(bt, vlen);
464   switch (bt) {
465   case T_BOOLEAN:
466   case T_BYTE:
467     return new PackBNode(s, vt);
468   case T_CHAR:
469   case T_SHORT:
470     return new PackSNode(s, vt);
471   case T_INT:
472     return new PackINode(s, vt);
473   case T_LONG:
474     return new PackLNode(s, vt);
475   case T_FLOAT:
476     return new PackFNode(s, vt);
477   case T_DOUBLE:
478     return new PackDNode(s, vt);
479   default:
480     fatal(&quot;Type &#39;%s&#39; is not supported for vectors&quot;, type2name(bt));
481     return NULL;
482   }
483 }
484 
485 // Create a binary tree form for Packs. [lo, hi) (half-open) range
486 PackNode* PackNode::binary_tree_pack(int lo, int hi) {
487   int ct = hi - lo;
488   assert(is_power_of_2(ct), &quot;power of 2&quot;);
489   if (ct == 2) {
490     PackNode* pk = PackNode::make(in(lo), 2, vect_type()-&gt;element_basic_type());
491     pk-&gt;add_opd(in(lo+1));
492     return pk;
493   } else {
494     int mid = lo + ct/2;
495     PackNode* n1 = binary_tree_pack(lo,  mid);
496     PackNode* n2 = binary_tree_pack(mid, hi );
497 
498     BasicType bt = n1-&gt;vect_type()-&gt;element_basic_type();
499     assert(bt == n2-&gt;vect_type()-&gt;element_basic_type(), &quot;should be the same&quot;);
500     switch (bt) {
501     case T_BOOLEAN:
502     case T_BYTE:
503       return new PackSNode(n1, n2, TypeVect::make(T_SHORT, 2));
504     case T_CHAR:
505     case T_SHORT:
506       return new PackINode(n1, n2, TypeVect::make(T_INT, 2));
507     case T_INT:
508       return new PackLNode(n1, n2, TypeVect::make(T_LONG, 2));
509     case T_LONG:
510       return new Pack2LNode(n1, n2, TypeVect::make(T_LONG, 2));
511     case T_FLOAT:
512       return new PackDNode(n1, n2, TypeVect::make(T_DOUBLE, 2));
513     case T_DOUBLE:
514       return new Pack2DNode(n1, n2, TypeVect::make(T_DOUBLE, 2));
515     default:
516       fatal(&quot;Type &#39;%s&#39; is not supported for vectors&quot;, type2name(bt));
517       return NULL;
518     }
519   }
520 }
521 
522 // Return the vector version of a scalar load node.
523 LoadVectorNode* LoadVectorNode::make(int opc, Node* ctl, Node* mem,
524                                      Node* adr, const TypePtr* atyp,
525                                      uint vlen, BasicType bt,
526                                      ControlDependency control_dependency) {
527   const TypeVect* vt = TypeVect::make(bt, vlen);
528   return new LoadVectorNode(ctl, mem, adr, atyp, vt, control_dependency);
529 }
530 
531 // Return the vector version of a scalar store node.
532 StoreVectorNode* StoreVectorNode::make(int opc, Node* ctl, Node* mem,
533                                        Node* adr, const TypePtr* atyp, Node* val,
534                                        uint vlen) {
535   return new StoreVectorNode(ctl, mem, adr, atyp, val);
536 }
537 
538 // Extract a scalar element of vector.
539 Node* ExtractNode::make(Node* v, uint position, BasicType bt) {
540   assert((int)position &lt; Matcher::max_vector_size(bt), &quot;pos in range&quot;);
541   ConINode* pos = ConINode::make((int)position);
542   switch (bt) {
543   case T_BOOLEAN:
544     return new ExtractUBNode(v, pos);
545   case T_BYTE:
546     return new ExtractBNode(v, pos);
547   case T_CHAR:
548     return new ExtractCNode(v, pos);
549   case T_SHORT:
550     return new ExtractSNode(v, pos);
551   case T_INT:
552     return new ExtractINode(v, pos);
553   case T_LONG:
554     return new ExtractLNode(v, pos);
555   case T_FLOAT:
556     return new ExtractFNode(v, pos);
557   case T_DOUBLE:
558     return new ExtractDNode(v, pos);
559   default:
560     fatal(&quot;Type &#39;%s&#39; is not supported for vectors&quot;, type2name(bt));
561     return NULL;
562   }
563 }
564 
565 int ReductionNode::opcode(int opc, BasicType bt) {
566   int vopc = opc;
567   switch (opc) {
568     case Op_AddI:
569       assert(bt == T_INT, &quot;must be&quot;);
570       vopc = Op_AddReductionVI;
571       break;
572     case Op_AddL:
573       assert(bt == T_LONG, &quot;must be&quot;);
574       vopc = Op_AddReductionVL;
575       break;
576     case Op_AddF:
577       assert(bt == T_FLOAT, &quot;must be&quot;);
578       vopc = Op_AddReductionVF;
579       break;
580     case Op_AddD:
581       assert(bt == T_DOUBLE, &quot;must be&quot;);
582       vopc = Op_AddReductionVD;
583       break;
584     case Op_MulI:
585       assert(bt == T_INT, &quot;must be&quot;);
586       vopc = Op_MulReductionVI;
587       break;
588     case Op_MulL:
589       assert(bt == T_LONG, &quot;must be&quot;);
590       vopc = Op_MulReductionVL;
591       break;
592     case Op_MulF:
593       assert(bt == T_FLOAT, &quot;must be&quot;);
594       vopc = Op_MulReductionVF;
595       break;
596     case Op_MulD:
597       assert(bt == T_DOUBLE, &quot;must be&quot;);
598       vopc = Op_MulReductionVD;
599       break;
600     case Op_MinF:
601       assert(bt == T_FLOAT, &quot;must be&quot;);
602       vopc = Op_MinReductionV;
603       break;
604     case Op_MinD:
605       assert(bt == T_DOUBLE, &quot;must be&quot;);
606       vopc = Op_MinReductionV;
607       break;
608     case Op_MaxF:
609       assert(bt == T_FLOAT, &quot;must be&quot;);
610       vopc = Op_MaxReductionV;
611       break;
612     case Op_MaxD:
613       assert(bt == T_DOUBLE, &quot;must be&quot;);
614       vopc = Op_MaxReductionV;
615       break;
616     // TODO: add MulL for targets that support it
617     default:
618       break;
619   }
620   return vopc;
621 }
622 
623 // Return the appropriate reduction node.
624 ReductionNode* ReductionNode::make(int opc, Node *ctrl, Node* n1, Node* n2, BasicType bt) {
625 
626   int vopc = opcode(opc, bt);
627 
628   // This method should not be called for unimplemented vectors.
629   guarantee(vopc != opc, &quot;Vector for &#39;%s&#39; is not implemented&quot;, NodeClassNames[opc]);
630 
631   switch (vopc) {
632   case Op_AddReductionVI: return new AddReductionVINode(ctrl, n1, n2);
633   case Op_AddReductionVL: return new AddReductionVLNode(ctrl, n1, n2);
634   case Op_AddReductionVF: return new AddReductionVFNode(ctrl, n1, n2);
635   case Op_AddReductionVD: return new AddReductionVDNode(ctrl, n1, n2);
636   case Op_MulReductionVI: return new MulReductionVINode(ctrl, n1, n2);
637   case Op_MulReductionVL: return new MulReductionVLNode(ctrl, n1, n2);
638   case Op_MulReductionVF: return new MulReductionVFNode(ctrl, n1, n2);
639   case Op_MulReductionVD: return new MulReductionVDNode(ctrl, n1, n2);
640   case Op_MinReductionV: return new MinReductionVNode(ctrl, n1, n2);
641   case Op_MaxReductionV: return new MaxReductionVNode(ctrl, n1, n2);
642   default:
643     fatal(&quot;Missed vector creation for &#39;%s&#39;&quot;, NodeClassNames[vopc]);
644     return NULL;
645   }
646 }
647 
648 bool ReductionNode::implemented(int opc, uint vlen, BasicType bt) {
649   if (is_java_primitive(bt) &amp;&amp;
650       (vlen &gt; 1) &amp;&amp; is_power_of_2(vlen) &amp;&amp;
651       Matcher::vector_size_supported(bt, vlen)) {
652     int vopc = ReductionNode::opcode(opc, bt);
653     return vopc != opc &amp;&amp; Matcher::match_rule_supported(vopc);
654   }
655   return false;
656 }
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>
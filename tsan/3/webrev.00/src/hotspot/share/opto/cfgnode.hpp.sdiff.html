<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/cfgnode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="cfgnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="chaitin.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/cfgnode.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
114 
115 //------------------------------PhiNode----------------------------------------
116 // PhiNodes merge values from different Control paths.  Slot 0 points to the
117 // controlling RegionNode.  Other slots map 1-for-1 with incoming control flow
118 // paths to the RegionNode.  For speed reasons (to avoid another pass) we
119 // can turn PhiNodes into copys in-place by NULL&#39;ing out their RegionNode
120 // input in slot 0.
121 class PhiNode : public TypeNode {
122   friend class PhaseRenumberLive;
123 
124   const TypePtr* const _adr_type; // non-null only for Type::MEMORY nodes.
125   // The following fields are only used for data PhiNodes to indicate
126   // that the PhiNode represents the value of a known instance field.
127         int _inst_mem_id; // Instance memory id (node index of the memory Phi)
128         int _inst_id;     // Instance id of the memory slice.
129   const int _inst_index;  // Alias index of the instance memory slice.
130   // Array elements references have the same alias_idx but different offset.
131   const int _inst_offset; // Offset of the instance memory slice.
132   // Size is bigger to hold the _adr_type field.
133   virtual uint hash() const;    // Check the type
<span class="line-modified">134   virtual uint cmp( const Node &amp;n ) const;</span>
135   virtual uint size_of() const { return sizeof(*this); }
136 
137   // Determine if CMoveNode::is_cmove_id can be used at this join point.
138   Node* is_cmove_id(PhaseTransform* phase, int true_path);
139 
140 public:
141   // Node layout (parallels RegionNode):
142   enum { Region,                // Control input is the Phi&#39;s region.
143          Input                  // Input values are [1..len)
144   };
145 
146   PhiNode( Node *r, const Type *t, const TypePtr* at = NULL,
147            const int imid = -1,
148            const int iid = TypeOopPtr::InstanceTop,
149            const int iidx = Compile::AliasIdxTop,
150            const int ioffs = Type::OffsetTop )
151     : TypeNode(t,r-&gt;req()),
152       _adr_type(at),
153       _inst_mem_id(imid),
154       _inst_id(iid),
</pre>
<hr />
<pre>
272 // control values. These are distinguished from other types of MultiNodes
273 // which yield multiple values, but control is always and only projection #0.
274 class MultiBranchNode : public MultiNode {
275 public:
276   MultiBranchNode( uint required ) : MultiNode(required) {
277     init_class_id(Class_MultiBranch);
278   }
279   // returns required number of users to be well formed.
280   virtual int required_outcnt() const = 0;
281 };
282 
283 //------------------------------IfNode-----------------------------------------
284 // Output selected Control, based on a boolean test
285 class IfNode : public MultiBranchNode {
286   // Size is bigger to hold the probability field.  However, _prob does not
287   // change the semantics so it does not appear in the hash &amp; cmp functions.
288   virtual uint size_of() const { return sizeof(*this); }
289 
290 private:
291   // Helper methods for fold_compares
<span class="line-modified">292   bool cmpi_folds(PhaseIterGVN* igvn);</span>
293   bool is_ctrl_folds(Node* ctrl, PhaseIterGVN* igvn);
294   bool has_shared_region(ProjNode* proj, ProjNode*&amp; success, ProjNode*&amp; fail);
295   bool has_only_uncommon_traps(ProjNode* proj, ProjNode*&amp; success, ProjNode*&amp; fail, PhaseIterGVN* igvn);
296   Node* merge_uncommon_traps(ProjNode* proj, ProjNode* success, ProjNode* fail, PhaseIterGVN* igvn);
297   static void improve_address_types(Node* l, Node* r, ProjNode* fail, PhaseIterGVN* igvn);
298   bool is_cmp_with_loadrange(ProjNode* proj);
299   bool is_null_check(ProjNode* proj, PhaseIterGVN* igvn);
300   bool is_side_effect_free_test(ProjNode* proj, PhaseIterGVN* igvn);
301   void reroute_side_effect_free_unc(ProjNode* proj, ProjNode* dom_proj, PhaseIterGVN* igvn);
302   ProjNode* uncommon_trap_proj(CallStaticJavaNode*&amp; call) const;
303   bool fold_compares_helper(ProjNode* proj, ProjNode* success, ProjNode* fail, PhaseIterGVN* igvn);
304   static bool is_dominator_unc(CallStaticJavaNode* dom_unc, CallStaticJavaNode* unc);
305 
306 protected:
307   ProjNode* range_check_trap_proj(int&amp; flip, Node*&amp; l, Node*&amp; r);
308   Node* Ideal_common(PhaseGVN *phase, bool can_reshape);
309   Node* search_identical(int dist);
310 


311 public:
312 
313   // Degrees of branch prediction probability by order of magnitude:
314   // PROB_UNLIKELY_1e(N) is a 1 in 1eN chance.
315   // PROB_LIKELY_1e(N) is a 1 - PROB_UNLIKELY_1e(N)
316 #define PROB_UNLIKELY_MAG(N)    (1e- ## N ## f)
317 #define PROB_LIKELY_MAG(N)      (1.0f-PROB_UNLIKELY_MAG(N))
318 
319   // Maximum and minimum branch prediction probabilties
320   // 1 in 1,000,000 (magnitude 6)
321   //
322   // Although PROB_NEVER == PROB_MIN and PROB_ALWAYS == PROB_MAX
323   // they are used to distinguish different situations:
324   //
325   // The name PROB_MAX (PROB_MIN) is for probabilities which correspond to
326   // very likely (unlikely) but with a concrete possibility of a rare
327   // contrary case.  These constants would be used for pinning
328   // measurements, and as measures for assertions that have high
329   // confidence, but some evidence of occasional failure.
330   //
</pre>
<hr />
<pre>
448 
449 class IfFalseNode : public IfProjNode {
450 public:
451   IfFalseNode( IfNode *ifnode ) : IfProjNode(ifnode,0) {
452     init_class_id(Class_IfFalse);
453   }
454   virtual int Opcode() const;
455 
456 protected:
457   virtual bool always_taken(const TypeTuple* t) const { return t == TypeTuple::IFFALSE; }
458 };
459 
460 
461 //------------------------------PCTableNode------------------------------------
462 // Build an indirect branch table.  Given a control and a table index,
463 // control is passed to the Projection matching the table index.  Used to
464 // implement switch statements and exception-handling capabilities.
465 // Undefined behavior if passed-in index is not inside the table.
466 class PCTableNode : public MultiBranchNode {
467   virtual uint hash() const;    // Target count; table size
<span class="line-modified">468   virtual uint cmp( const Node &amp;n ) const;</span>
469   virtual uint size_of() const { return sizeof(*this); }
470 
471 public:
472   const uint _size;             // Number of targets
473 
474   PCTableNode( Node *ctrl, Node *idx, uint size ) : MultiBranchNode(2), _size(size) {
475     init_class_id(Class_PCTable);
476     init_req(0, ctrl);
477     init_req(1, idx);
478   }
479   virtual int Opcode() const;
480   virtual const Type* Value(PhaseGVN* phase) const;
481   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
482   virtual const Type *bottom_type() const;
483   virtual bool pinned() const { return true; }
484   virtual int required_outcnt() const { return _size; }
485 };
486 
487 //------------------------------JumpNode---------------------------------------
488 // Indirect branch.  Uses PCTable above to implement a switch statement.
</pre>
<hr />
<pre>
490 class JumpNode : public PCTableNode {
491   virtual uint size_of() const { return sizeof(*this); }
492 public:
493   float* _probs; // probability of each projection
494   float _fcnt;   // total number of times this Jump was executed
495   JumpNode( Node* control, Node* switch_val, uint size, float* probs, float cnt)
496     : PCTableNode(control, switch_val, size),
497       _probs(probs), _fcnt(cnt) {
498     init_class_id(Class_Jump);
499   }
500   virtual int   Opcode() const;
501   virtual const RegMask&amp; out_RegMask() const;
502   virtual const Node* is_block_proj() const { return this; }
503 #ifndef PRODUCT
504   virtual void related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const;
505 #endif
506 };
507 
508 class JumpProjNode : public JProjNode {
509   virtual uint hash() const;
<span class="line-modified">510   virtual uint cmp( const Node &amp;n ) const;</span>
511   virtual uint size_of() const { return sizeof(*this); }
512 
513  private:
514   const int  _dest_bci;
515   const uint _proj_no;
516   const int  _switch_val;
517  public:
518   JumpProjNode(Node* jumpnode, uint proj_no, int dest_bci, int switch_val)
519     : JProjNode(jumpnode, proj_no), _dest_bci(dest_bci), _proj_no(proj_no), _switch_val(switch_val) {
520     init_class_id(Class_JumpProj);
521   }
522 
523   virtual int Opcode() const;
524   virtual const Type* bottom_type() const { return Type::CONTROL; }
525   int  dest_bci()    const { return _dest_bci; }
526   int  switch_val()  const { return _switch_val; }
527   uint proj_no()     const { return _proj_no; }
528 #ifndef PRODUCT
529   virtual void dump_spec(outputStream *st) const;
530   virtual void dump_compact_spec(outputStream *st) const;
</pre>
<hr />
<pre>
533 };
534 
535 //------------------------------CatchNode--------------------------------------
536 // Helper node to fork exceptions.  &quot;Catch&quot; catches any exceptions thrown by
537 // a just-prior call.  Looks like a PCTableNode but emits no code - just the
538 // table.  The table lookup and branch is implemented by RethrowNode.
539 class CatchNode : public PCTableNode {
540 public:
541   CatchNode( Node *ctrl, Node *idx, uint size ) : PCTableNode(ctrl,idx,size){
542     init_class_id(Class_Catch);
543   }
544   virtual int Opcode() const;
545   virtual const Type* Value(PhaseGVN* phase) const;
546 };
547 
548 // CatchProjNode controls which exception handler is targetted after a call.
549 // It is passed in the bci of the target handler, or no_handler_bci in case
550 // the projection doesn&#39;t lead to an exception handler.
551 class CatchProjNode : public CProjNode {
552   virtual uint hash() const;
<span class="line-modified">553   virtual uint cmp( const Node &amp;n ) const;</span>
554   virtual uint size_of() const { return sizeof(*this); }
555 
556 private:
557   const int _handler_bci;
558 
559 public:
560   enum {
561     fall_through_index =  0,      // the fall through projection index
562     catch_all_index    =  1,      // the projection index for catch-alls
563     no_handler_bci     = -1       // the bci for fall through or catch-all projs
564   };
565 
566   CatchProjNode(Node* catchnode, uint proj_no, int handler_bci)
567     : CProjNode(catchnode, proj_no), _handler_bci(handler_bci) {
568     init_class_id(Class_CatchProj);
569     assert(proj_no != fall_through_index || handler_bci &lt; 0, &quot;fall through case must have bci &lt; 0&quot;);
570   }
571 
572   virtual int Opcode() const;
573   virtual Node* Identity(PhaseGVN* phase);
</pre>
</td>
<td>
<hr />
<pre>
114 
115 //------------------------------PhiNode----------------------------------------
116 // PhiNodes merge values from different Control paths.  Slot 0 points to the
117 // controlling RegionNode.  Other slots map 1-for-1 with incoming control flow
118 // paths to the RegionNode.  For speed reasons (to avoid another pass) we
119 // can turn PhiNodes into copys in-place by NULL&#39;ing out their RegionNode
120 // input in slot 0.
121 class PhiNode : public TypeNode {
122   friend class PhaseRenumberLive;
123 
124   const TypePtr* const _adr_type; // non-null only for Type::MEMORY nodes.
125   // The following fields are only used for data PhiNodes to indicate
126   // that the PhiNode represents the value of a known instance field.
127         int _inst_mem_id; // Instance memory id (node index of the memory Phi)
128         int _inst_id;     // Instance id of the memory slice.
129   const int _inst_index;  // Alias index of the instance memory slice.
130   // Array elements references have the same alias_idx but different offset.
131   const int _inst_offset; // Offset of the instance memory slice.
132   // Size is bigger to hold the _adr_type field.
133   virtual uint hash() const;    // Check the type
<span class="line-modified">134   virtual bool cmp( const Node &amp;n ) const;</span>
135   virtual uint size_of() const { return sizeof(*this); }
136 
137   // Determine if CMoveNode::is_cmove_id can be used at this join point.
138   Node* is_cmove_id(PhaseTransform* phase, int true_path);
139 
140 public:
141   // Node layout (parallels RegionNode):
142   enum { Region,                // Control input is the Phi&#39;s region.
143          Input                  // Input values are [1..len)
144   };
145 
146   PhiNode( Node *r, const Type *t, const TypePtr* at = NULL,
147            const int imid = -1,
148            const int iid = TypeOopPtr::InstanceTop,
149            const int iidx = Compile::AliasIdxTop,
150            const int ioffs = Type::OffsetTop )
151     : TypeNode(t,r-&gt;req()),
152       _adr_type(at),
153       _inst_mem_id(imid),
154       _inst_id(iid),
</pre>
<hr />
<pre>
272 // control values. These are distinguished from other types of MultiNodes
273 // which yield multiple values, but control is always and only projection #0.
274 class MultiBranchNode : public MultiNode {
275 public:
276   MultiBranchNode( uint required ) : MultiNode(required) {
277     init_class_id(Class_MultiBranch);
278   }
279   // returns required number of users to be well formed.
280   virtual int required_outcnt() const = 0;
281 };
282 
283 //------------------------------IfNode-----------------------------------------
284 // Output selected Control, based on a boolean test
285 class IfNode : public MultiBranchNode {
286   // Size is bigger to hold the probability field.  However, _prob does not
287   // change the semantics so it does not appear in the hash &amp; cmp functions.
288   virtual uint size_of() const { return sizeof(*this); }
289 
290 private:
291   // Helper methods for fold_compares
<span class="line-modified">292   bool cmpi_folds(PhaseIterGVN* igvn, bool fold_ne = false);</span>
293   bool is_ctrl_folds(Node* ctrl, PhaseIterGVN* igvn);
294   bool has_shared_region(ProjNode* proj, ProjNode*&amp; success, ProjNode*&amp; fail);
295   bool has_only_uncommon_traps(ProjNode* proj, ProjNode*&amp; success, ProjNode*&amp; fail, PhaseIterGVN* igvn);
296   Node* merge_uncommon_traps(ProjNode* proj, ProjNode* success, ProjNode* fail, PhaseIterGVN* igvn);
297   static void improve_address_types(Node* l, Node* r, ProjNode* fail, PhaseIterGVN* igvn);
298   bool is_cmp_with_loadrange(ProjNode* proj);
299   bool is_null_check(ProjNode* proj, PhaseIterGVN* igvn);
300   bool is_side_effect_free_test(ProjNode* proj, PhaseIterGVN* igvn);
301   void reroute_side_effect_free_unc(ProjNode* proj, ProjNode* dom_proj, PhaseIterGVN* igvn);
302   ProjNode* uncommon_trap_proj(CallStaticJavaNode*&amp; call) const;
303   bool fold_compares_helper(ProjNode* proj, ProjNode* success, ProjNode* fail, PhaseIterGVN* igvn);
304   static bool is_dominator_unc(CallStaticJavaNode* dom_unc, CallStaticJavaNode* unc);
305 
306 protected:
307   ProjNode* range_check_trap_proj(int&amp; flip, Node*&amp; l, Node*&amp; r);
308   Node* Ideal_common(PhaseGVN *phase, bool can_reshape);
309   Node* search_identical(int dist);
310 
<span class="line-added">311   Node* simple_subsuming(PhaseIterGVN* igvn);</span>
<span class="line-added">312 </span>
313 public:
314 
315   // Degrees of branch prediction probability by order of magnitude:
316   // PROB_UNLIKELY_1e(N) is a 1 in 1eN chance.
317   // PROB_LIKELY_1e(N) is a 1 - PROB_UNLIKELY_1e(N)
318 #define PROB_UNLIKELY_MAG(N)    (1e- ## N ## f)
319 #define PROB_LIKELY_MAG(N)      (1.0f-PROB_UNLIKELY_MAG(N))
320 
321   // Maximum and minimum branch prediction probabilties
322   // 1 in 1,000,000 (magnitude 6)
323   //
324   // Although PROB_NEVER == PROB_MIN and PROB_ALWAYS == PROB_MAX
325   // they are used to distinguish different situations:
326   //
327   // The name PROB_MAX (PROB_MIN) is for probabilities which correspond to
328   // very likely (unlikely) but with a concrete possibility of a rare
329   // contrary case.  These constants would be used for pinning
330   // measurements, and as measures for assertions that have high
331   // confidence, but some evidence of occasional failure.
332   //
</pre>
<hr />
<pre>
450 
451 class IfFalseNode : public IfProjNode {
452 public:
453   IfFalseNode( IfNode *ifnode ) : IfProjNode(ifnode,0) {
454     init_class_id(Class_IfFalse);
455   }
456   virtual int Opcode() const;
457 
458 protected:
459   virtual bool always_taken(const TypeTuple* t) const { return t == TypeTuple::IFFALSE; }
460 };
461 
462 
463 //------------------------------PCTableNode------------------------------------
464 // Build an indirect branch table.  Given a control and a table index,
465 // control is passed to the Projection matching the table index.  Used to
466 // implement switch statements and exception-handling capabilities.
467 // Undefined behavior if passed-in index is not inside the table.
468 class PCTableNode : public MultiBranchNode {
469   virtual uint hash() const;    // Target count; table size
<span class="line-modified">470   virtual bool cmp( const Node &amp;n ) const;</span>
471   virtual uint size_of() const { return sizeof(*this); }
472 
473 public:
474   const uint _size;             // Number of targets
475 
476   PCTableNode( Node *ctrl, Node *idx, uint size ) : MultiBranchNode(2), _size(size) {
477     init_class_id(Class_PCTable);
478     init_req(0, ctrl);
479     init_req(1, idx);
480   }
481   virtual int Opcode() const;
482   virtual const Type* Value(PhaseGVN* phase) const;
483   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
484   virtual const Type *bottom_type() const;
485   virtual bool pinned() const { return true; }
486   virtual int required_outcnt() const { return _size; }
487 };
488 
489 //------------------------------JumpNode---------------------------------------
490 // Indirect branch.  Uses PCTable above to implement a switch statement.
</pre>
<hr />
<pre>
492 class JumpNode : public PCTableNode {
493   virtual uint size_of() const { return sizeof(*this); }
494 public:
495   float* _probs; // probability of each projection
496   float _fcnt;   // total number of times this Jump was executed
497   JumpNode( Node* control, Node* switch_val, uint size, float* probs, float cnt)
498     : PCTableNode(control, switch_val, size),
499       _probs(probs), _fcnt(cnt) {
500     init_class_id(Class_Jump);
501   }
502   virtual int   Opcode() const;
503   virtual const RegMask&amp; out_RegMask() const;
504   virtual const Node* is_block_proj() const { return this; }
505 #ifndef PRODUCT
506   virtual void related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const;
507 #endif
508 };
509 
510 class JumpProjNode : public JProjNode {
511   virtual uint hash() const;
<span class="line-modified">512   virtual bool cmp( const Node &amp;n ) const;</span>
513   virtual uint size_of() const { return sizeof(*this); }
514 
515  private:
516   const int  _dest_bci;
517   const uint _proj_no;
518   const int  _switch_val;
519  public:
520   JumpProjNode(Node* jumpnode, uint proj_no, int dest_bci, int switch_val)
521     : JProjNode(jumpnode, proj_no), _dest_bci(dest_bci), _proj_no(proj_no), _switch_val(switch_val) {
522     init_class_id(Class_JumpProj);
523   }
524 
525   virtual int Opcode() const;
526   virtual const Type* bottom_type() const { return Type::CONTROL; }
527   int  dest_bci()    const { return _dest_bci; }
528   int  switch_val()  const { return _switch_val; }
529   uint proj_no()     const { return _proj_no; }
530 #ifndef PRODUCT
531   virtual void dump_spec(outputStream *st) const;
532   virtual void dump_compact_spec(outputStream *st) const;
</pre>
<hr />
<pre>
535 };
536 
537 //------------------------------CatchNode--------------------------------------
538 // Helper node to fork exceptions.  &quot;Catch&quot; catches any exceptions thrown by
539 // a just-prior call.  Looks like a PCTableNode but emits no code - just the
540 // table.  The table lookup and branch is implemented by RethrowNode.
541 class CatchNode : public PCTableNode {
542 public:
543   CatchNode( Node *ctrl, Node *idx, uint size ) : PCTableNode(ctrl,idx,size){
544     init_class_id(Class_Catch);
545   }
546   virtual int Opcode() const;
547   virtual const Type* Value(PhaseGVN* phase) const;
548 };
549 
550 // CatchProjNode controls which exception handler is targetted after a call.
551 // It is passed in the bci of the target handler, or no_handler_bci in case
552 // the projection doesn&#39;t lead to an exception handler.
553 class CatchProjNode : public CProjNode {
554   virtual uint hash() const;
<span class="line-modified">555   virtual bool cmp( const Node &amp;n ) const;</span>
556   virtual uint size_of() const { return sizeof(*this); }
557 
558 private:
559   const int _handler_bci;
560 
561 public:
562   enum {
563     fall_through_index =  0,      // the fall through projection index
564     catch_all_index    =  1,      // the projection index for catch-alls
565     no_handler_bci     = -1       // the bci for fall through or catch-all projs
566   };
567 
568   CatchProjNode(Node* catchnode, uint proj_no, int handler_bci)
569     : CProjNode(catchnode, proj_no), _handler_bci(handler_bci) {
570     init_class_id(Class_CatchProj);
571     assert(proj_no != fall_through_index || handler_bci &lt; 0, &quot;fall through case must have bci &lt; 0&quot;);
572   }
573 
574   virtual int Opcode() const;
575   virtual Node* Identity(PhaseGVN* phase);
</pre>
</td>
</tr>
</table>
<center><a href="cfgnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="chaitin.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
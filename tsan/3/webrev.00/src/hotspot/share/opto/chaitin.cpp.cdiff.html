<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/chaitin.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="cfgnode.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classes.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/chaitin.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1167,20 ***</span>
  
        // Put the simplified guy on the simplified list.
        lrgs(lo)._next = _simplified;
        _simplified = lo;
        // If this guy is &quot;at risk&quot; then mark his current neighbors
<span class="line-modified">!       if( lrgs(lo)._at_risk ) {</span>
          IndexSetIterator elements(_ifg-&gt;neighbors(lo));
          uint datum;
          while ((datum = elements.next()) != 0) {
            lrgs(datum)._risk_bias = lo;
          }
        }
  
        // Yank this guy from the IFG.
<span class="line-modified">!       IndexSet *adj = _ifg-&gt;remove_node( lo );</span>
  
        // If any neighbors&#39; degrees fall below their number of
        // allowed registers, then put that neighbor on the low degree
        // list.  Note that &#39;degree&#39; can only fall and &#39;numregs&#39; is
        // unchanged by this action.  Thus the two are equal at most once,
<span class="line-new-header">--- 1167,23 ---</span>
  
        // Put the simplified guy on the simplified list.
        lrgs(lo)._next = _simplified;
        _simplified = lo;
        // If this guy is &quot;at risk&quot; then mark his current neighbors
<span class="line-modified">!       if (lrgs(lo)._at_risk &amp;&amp; !_ifg-&gt;neighbors(lo)-&gt;is_empty()) {</span>
          IndexSetIterator elements(_ifg-&gt;neighbors(lo));
          uint datum;
          while ((datum = elements.next()) != 0) {
            lrgs(datum)._risk_bias = lo;
          }
        }
  
        // Yank this guy from the IFG.
<span class="line-modified">!       IndexSet *adj = _ifg-&gt;remove_node(lo);</span>
<span class="line-added">+       if (adj-&gt;is_empty()) {</span>
<span class="line-added">+         continue;</span>
<span class="line-added">+       }</span>
  
        // If any neighbors&#39; degrees fall below their number of
        // allowed registers, then put that neighbor on the low degree
        // list.  Note that &#39;degree&#39; can only fall and &#39;numregs&#39; is
        // unchanged by this action.  Thus the two are equal at most once,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1188,45 ***</span>
        IndexSetIterator elements(adj);
        uint neighbor;
        while ((neighbor = elements.next()) != 0) {
          LRG *n = &amp;lrgs(neighbor);
  #ifdef ASSERT
<span class="line-modified">!         if( VerifyOpto || VerifyRegisterAllocator ) {</span>
            assert( _ifg-&gt;effective_degree(neighbor) == n-&gt;degree(), &quot;&quot; );
          }
  #endif
  
          // Check for just becoming of-low-degree just counting registers.
          // _must_spill live ranges are already on the low degree list.
<span class="line-modified">!         if( n-&gt;just_lo_degree() &amp;&amp; !n-&gt;_must_spill ) {</span>
<span class="line-modified">!           assert(!(*_ifg-&gt;_yanked)[neighbor],&quot;Cannot move to lo degree twice&quot;);</span>
            // Pull from hi-degree list
            uint prev = n-&gt;_prev;
            uint next = n-&gt;_next;
<span class="line-modified">!           if( prev ) lrgs(prev)._next = next;</span>
<span class="line-modified">!           else _hi_degree = next;</span>
            lrgs(next)._prev = prev;
            n-&gt;_next = _lo_degree;
            _lo_degree = neighbor;
          }
        }
      } // End of while lo-degree/lo_stk_degree worklist not empty
  
      // Check for got everything: is hi-degree list empty?
<span class="line-modified">!     if( !_hi_degree ) break;</span>
  
      // Time to pick a potential spill guy
      uint lo_score = _hi_degree;
      double score = lrgs(lo_score).score();
      double area = lrgs(lo_score)._area;
      double cost = lrgs(lo_score)._cost;
      bool bound = lrgs(lo_score)._is_bound;
  
      // Find cheapest guy
      debug_only( int lo_no_simplify=0; );
<span class="line-modified">!     for( uint i = _hi_degree; i; i = lrgs(i)._next ) {</span>
<span class="line-modified">!       assert( !(*_ifg-&gt;_yanked)[i], &quot;&quot; );</span>
        // It&#39;s just vaguely possible to move hi-degree to lo-degree without
        // going through a just-lo-degree stage: If you remove a double from
        // a float live range it&#39;s degree will drop by 2 and you can skip the
        // just-lo-degree stage.  It&#39;s very rare (shows up after 5000+ methods
        // in -Xcomp of Java2Demo).  So just choose this guy to simplify next.
<span class="line-new-header">--- 1191,48 ---</span>
        IndexSetIterator elements(adj);
        uint neighbor;
        while ((neighbor = elements.next()) != 0) {
          LRG *n = &amp;lrgs(neighbor);
  #ifdef ASSERT
<span class="line-modified">!         if (VerifyRegisterAllocator) {</span>
            assert( _ifg-&gt;effective_degree(neighbor) == n-&gt;degree(), &quot;&quot; );
          }
  #endif
  
          // Check for just becoming of-low-degree just counting registers.
          // _must_spill live ranges are already on the low degree list.
<span class="line-modified">!         if (n-&gt;just_lo_degree() &amp;&amp; !n-&gt;_must_spill) {</span>
<span class="line-modified">!           assert(!_ifg-&gt;_yanked-&gt;test(neighbor), &quot;Cannot move to lo degree twice&quot;);</span>
            // Pull from hi-degree list
            uint prev = n-&gt;_prev;
            uint next = n-&gt;_next;
<span class="line-modified">!           if (prev) {</span>
<span class="line-modified">!             lrgs(prev)._next = next;</span>
<span class="line-added">+           } else {</span>
<span class="line-added">+             _hi_degree = next;</span>
<span class="line-added">+           }</span>
            lrgs(next)._prev = prev;
            n-&gt;_next = _lo_degree;
            _lo_degree = neighbor;
          }
        }
      } // End of while lo-degree/lo_stk_degree worklist not empty
  
      // Check for got everything: is hi-degree list empty?
<span class="line-modified">!     if (!_hi_degree) break;</span>
  
      // Time to pick a potential spill guy
      uint lo_score = _hi_degree;
      double score = lrgs(lo_score).score();
      double area = lrgs(lo_score)._area;
      double cost = lrgs(lo_score)._cost;
      bool bound = lrgs(lo_score)._is_bound;
  
      // Find cheapest guy
      debug_only( int lo_no_simplify=0; );
<span class="line-modified">!     for (uint i = _hi_degree; i; i = lrgs(i)._next) {</span>
<span class="line-modified">!       assert(!_ifg-&gt;_yanked-&gt;test(i), &quot;&quot;);</span>
        // It&#39;s just vaguely possible to move hi-degree to lo-degree without
        // going through a just-lo-degree stage: If you remove a double from
        // a float live range it&#39;s degree will drop by 2 and you can skip the
        // just-lo-degree stage.  It&#39;s very rare (shows up after 5000+ methods
        // in -Xcomp of Java2Demo).  So just choose this guy to simplify next.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1247,11 ***</span>
        // evils; in this case pick largest area to spill.
        // Ties also happen when live ranges are defined and used only inside
        // one block. In which case their area is 0 and score set to max.
        // In such case choose bound live range over unbound to free registers
        // or with smaller cost to spill.
<span class="line-modified">!       if( iscore &lt; score ||</span>
            (iscore == score &amp;&amp; iarea &gt; area &amp;&amp; lrgs(lo_score)._was_spilled2) ||
            (iscore == score &amp;&amp; iarea == area &amp;&amp;
             ( (ibound &amp;&amp; !bound) || (ibound == bound &amp;&amp; (icost &lt; cost)) )) ) {
          lo_score = i;
          score = iscore;
<span class="line-new-header">--- 1253,11 ---</span>
        // evils; in this case pick largest area to spill.
        // Ties also happen when live ranges are defined and used only inside
        // one block. In which case their area is 0 and score set to max.
        // In such case choose bound live range over unbound to free registers
        // or with smaller cost to spill.
<span class="line-modified">!       if ( iscore &lt; score ||</span>
            (iscore == score &amp;&amp; iarea &gt; area &amp;&amp; lrgs(lo_score)._was_spilled2) ||
            (iscore == score &amp;&amp; iarea == area &amp;&amp;
             ( (ibound &amp;&amp; !bound) || (ibound == bound &amp;&amp; (icost &lt; cost)) )) ) {
          lo_score = i;
          score = iscore;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1312,11 ***</span>
  // Choose a color using the biasing heuristic
  OptoReg::Name PhaseChaitin::bias_color( LRG &amp;lrg, int chunk ) {
  
    // Check for &quot;at_risk&quot; LRG&#39;s
    uint risk_lrg = _lrg_map.find(lrg._risk_bias);
<span class="line-modified">!   if( risk_lrg != 0 ) {</span>
      // Walk the colored neighbors of the &quot;at_risk&quot; candidate
      // Choose a color which is both legal and already taken by a neighbor
      // of the &quot;at_risk&quot; candidate in order to improve the chances of the
      // &quot;at_risk&quot; candidate of coloring
      IndexSetIterator elements(_ifg-&gt;neighbors(risk_lrg));
<span class="line-new-header">--- 1318,11 ---</span>
  // Choose a color using the biasing heuristic
  OptoReg::Name PhaseChaitin::bias_color( LRG &amp;lrg, int chunk ) {
  
    // Check for &quot;at_risk&quot; LRG&#39;s
    uint risk_lrg = _lrg_map.find(lrg._risk_bias);
<span class="line-modified">!   if (risk_lrg != 0 &amp;&amp; !_ifg-&gt;neighbors(risk_lrg)-&gt;is_empty()) {</span>
      // Walk the colored neighbors of the &quot;at_risk&quot; candidate
      // Choose a color which is both legal and already taken by a neighbor
      // of the &quot;at_risk&quot; candidate in order to improve the chances of the
      // &quot;at_risk&quot; candidate of coloring
      IndexSetIterator elements(_ifg-&gt;neighbors(risk_lrg));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1328,13 ***</span>
          return reg;
      }
    }
  
    uint copy_lrg = _lrg_map.find(lrg._copy_bias);
<span class="line-modified">!   if( copy_lrg != 0 ) {</span>
      // If he has a color,
<span class="line-modified">!     if( !(*(_ifg-&gt;_yanked))[copy_lrg] ) {</span>
        OptoReg::Name reg = lrgs(copy_lrg).reg();
        //  And it is legal for you,
        if (is_legal_reg(lrg, reg, chunk))
          return reg;
      } else if( chunk == 0 ) {
<span class="line-new-header">--- 1334,13 ---</span>
          return reg;
      }
    }
  
    uint copy_lrg = _lrg_map.find(lrg._copy_bias);
<span class="line-modified">!   if (copy_lrg != 0) {</span>
      // If he has a color,
<span class="line-modified">!     if(!_ifg-&gt;_yanked-&gt;test(copy_lrg)) {</span>
        OptoReg::Name reg = lrgs(copy_lrg).reg();
        //  And it is legal for you,
        if (is_legal_reg(lrg, reg, chunk))
          return reg;
      } else if( chunk == 0 ) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1430,45 ***</span>
      int chunk = 0;              // Current chunk is first chunk
      retry_next_chunk:
  
      // Remove neighbor colors
      IndexSet *s = _ifg-&gt;neighbors(lidx);
<span class="line-removed">- </span>
      debug_only(RegMask orig_mask = lrg-&gt;mask();)
<span class="line-modified">!     IndexSetIterator elements(s);</span>
<span class="line-modified">!     uint neighbor;</span>
<span class="line-modified">!     while ((neighbor = elements.next()) != 0) {</span>
<span class="line-modified">!       // Note that neighbor might be a spill_reg.  In this case, exclusion</span>
<span class="line-modified">!       // of its color will be a no-op, since the spill_reg chunk is in outer</span>
<span class="line-modified">!       // space.  Also, if neighbor is in a different chunk, this exclusion</span>
<span class="line-modified">!       // will be a no-op.  (Later on, if lrg runs out of possible colors in</span>
<span class="line-modified">!       // its chunk, a new chunk of color may be tried, in which case</span>
<span class="line-modified">!       // examination of neighbors is started again, at retry_next_chunk.)</span>
<span class="line-modified">!       LRG &amp;nlrg = lrgs(neighbor);</span>
<span class="line-modified">!       OptoReg::Name nreg = nlrg.reg();</span>
<span class="line-modified">!       // Only subtract masks in the same chunk</span>
<span class="line-modified">!       if( nreg &gt;= chunk &amp;&amp; nreg &lt; chunk + RegMask::CHUNK_SIZE ) {</span>
  #ifndef PRODUCT
<span class="line-modified">!         uint size = lrg-&gt;mask().Size();</span>
<span class="line-modified">!         RegMask rm = lrg-&gt;mask();</span>
  #endif
<span class="line-modified">!         lrg-&gt;SUBTRACT(nlrg.mask());</span>
  #ifndef PRODUCT
<span class="line-modified">!         if (trace_spilling() &amp;&amp; lrg-&gt;mask().Size() != size) {</span>
<span class="line-modified">!           ttyLocker ttyl;</span>
<span class="line-modified">!           tty-&gt;print(&quot;L%d &quot;, lidx);</span>
<span class="line-modified">!           rm.dump();</span>
<span class="line-modified">!           tty-&gt;print(&quot; intersected L%d &quot;, neighbor);</span>
<span class="line-modified">!           nlrg.mask().dump();</span>
<span class="line-modified">!           tty-&gt;print(&quot; removed &quot;);</span>
<span class="line-modified">!           rm.SUBTRACT(lrg-&gt;mask());</span>
<span class="line-modified">!           rm.dump();</span>
<span class="line-modified">!           tty-&gt;print(&quot; leaving &quot;);</span>
<span class="line-modified">!           lrg-&gt;mask().dump();</span>
<span class="line-modified">!           tty-&gt;cr();</span>
<span class="line-modified">!         }</span>
  #endif
        }
      }
      //assert(is_allstack == lrg-&gt;mask().is_AllStack(), &quot;nbrs must not change AllStackedness&quot;);
      // Aligned pairs need aligned masks
      assert(!lrg-&gt;_is_vector || !lrg-&gt;_fat_proj, &quot;sanity&quot;);
<span class="line-new-header">--- 1436,47 ---</span>
      int chunk = 0;              // Current chunk is first chunk
      retry_next_chunk:
  
      // Remove neighbor colors
      IndexSet *s = _ifg-&gt;neighbors(lidx);
      debug_only(RegMask orig_mask = lrg-&gt;mask();)
<span class="line-modified">! </span>
<span class="line-modified">!     if (!s-&gt;is_empty()) {</span>
<span class="line-modified">!       IndexSetIterator elements(s);</span>
<span class="line-modified">!       uint neighbor;</span>
<span class="line-modified">!       while ((neighbor = elements.next()) != 0) {</span>
<span class="line-modified">!         // Note that neighbor might be a spill_reg.  In this case, exclusion</span>
<span class="line-modified">!         // of its color will be a no-op, since the spill_reg chunk is in outer</span>
<span class="line-modified">!         // space.  Also, if neighbor is in a different chunk, this exclusion</span>
<span class="line-modified">!         // will be a no-op.  (Later on, if lrg runs out of possible colors in</span>
<span class="line-modified">!         // its chunk, a new chunk of color may be tried, in which case</span>
<span class="line-modified">!         // examination of neighbors is started again, at retry_next_chunk.)</span>
<span class="line-modified">!         LRG &amp;nlrg = lrgs(neighbor);</span>
<span class="line-modified">!         OptoReg::Name nreg = nlrg.reg();</span>
<span class="line-added">+         // Only subtract masks in the same chunk</span>
<span class="line-added">+         if (nreg &gt;= chunk &amp;&amp; nreg &lt; chunk + RegMask::CHUNK_SIZE) {</span>
  #ifndef PRODUCT
<span class="line-modified">!           uint size = lrg-&gt;mask().Size();</span>
<span class="line-modified">!           RegMask rm = lrg-&gt;mask();</span>
  #endif
<span class="line-modified">!           lrg-&gt;SUBTRACT(nlrg.mask());</span>
  #ifndef PRODUCT
<span class="line-modified">!           if (trace_spilling() &amp;&amp; lrg-&gt;mask().Size() != size) {</span>
<span class="line-modified">!             ttyLocker ttyl;</span>
<span class="line-modified">!             tty-&gt;print(&quot;L%d &quot;, lidx);</span>
<span class="line-modified">!             rm.dump();</span>
<span class="line-modified">!             tty-&gt;print(&quot; intersected L%d &quot;, neighbor);</span>
<span class="line-modified">!             nlrg.mask().dump();</span>
<span class="line-modified">!             tty-&gt;print(&quot; removed &quot;);</span>
<span class="line-modified">!             rm.SUBTRACT(lrg-&gt;mask());</span>
<span class="line-modified">!             rm.dump();</span>
<span class="line-modified">!             tty-&gt;print(&quot; leaving &quot;);</span>
<span class="line-modified">!             lrg-&gt;mask().dump();</span>
<span class="line-modified">!             tty-&gt;cr();</span>
<span class="line-modified">!           }</span>
  #endif
<span class="line-added">+         }</span>
        }
      }
      //assert(is_allstack == lrg-&gt;mask().is_AllStack(), &quot;nbrs must not change AllStackedness&quot;);
      // Aligned pairs need aligned masks
      assert(!lrg-&gt;_is_vector || !lrg-&gt;_fat_proj, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1825,11 ***</span>
          }
        }
  
        // Found a safepoint?
        JVMState *jvms = n-&gt;jvms();
<span class="line-modified">!       if( jvms ) {</span>
          // Now scan for a live derived pointer
          IndexSetIterator elements(&amp;liveout);
          uint neighbor;
          while ((neighbor = elements.next()) != 0) {
            // Find reaching DEF for base and derived values
<span class="line-new-header">--- 1833,11 ---</span>
          }
        }
  
        // Found a safepoint?
        JVMState *jvms = n-&gt;jvms();
<span class="line-modified">!       if (jvms &amp;&amp; !liveout.is_empty()) {</span>
          // Now scan for a live derived pointer
          IndexSetIterator elements(&amp;liveout);
          uint neighbor;
          while ((neighbor = elements.next()) != 0) {
            // Find reaching DEF for base and derived values
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2082,13 ***</span>
  }
  
  // Dump a register name into a buffer.  Be intelligent if we get called
  // before allocation is complete.
  char *PhaseChaitin::dump_register( const Node *n, char *buf  ) const {
<span class="line-modified">!   if( this == NULL ) {          // Not got anything?</span>
<span class="line-removed">-     sprintf(buf,&quot;N%d&quot;,n-&gt;_idx); // Then use Node index</span>
<span class="line-removed">-   } else if( _node_regs ) {</span>
      // Post allocation, use direct mappings, no LRG info available
      print_reg( get_reg_first(n), this, buf );
    } else {
      uint lidx = _lrg_map.find_const(n); // Grab LRG number
      if( !_ifg ) {
<span class="line-new-header">--- 2090,11 ---</span>
  }
  
  // Dump a register name into a buffer.  Be intelligent if we get called
  // before allocation is complete.
  char *PhaseChaitin::dump_register( const Node *n, char *buf  ) const {
<span class="line-modified">!   if( _node_regs ) {</span>
      // Post allocation, use direct mappings, no LRG info available
      print_reg( get_reg_first(n), this, buf );
    } else {
      uint lidx = _lrg_map.find_const(n); // Grab LRG number
      if( !_ifg ) {
</pre>
<center><a href="cfgnode.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classes.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
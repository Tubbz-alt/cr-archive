<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/opto/runtime.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="rootnode.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="runtime.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/runtime.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -301,11 +301,11 @@</span>
      int size = ((typeArrayOop)result)-&gt;object_size();
      BasicType elem_type = TypeArrayKlass::cast(array_type)-&gt;element_type();
      const size_t hs = arrayOopDesc::header_size(elem_type);
      // Align to next 8 bytes to avoid trashing arrays&#39;s length.
      const size_t aligned_hs = align_object_offset(hs);
<span class="udiff-line-modified-removed">-     HeapWord* obj = (HeapWord*)result;</span>
<span class="udiff-line-modified-added">+     HeapWord* obj = cast_from_oop&lt;HeapWord*&gt;(result);</span>
      if (aligned_hs &gt; hs) {
        Copy::zero_to_words(obj+hs, aligned_hs-hs);
      }
      // Optimized zeroing.
      Copy::fill_to_aligned_words(obj+aligned_hs, size-aligned_hs);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -898,10 +898,37 @@</span>
    fields[TypeFunc::Parms+0] = TypeInt::INT;
    const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);
    return TypeFunc::make(domain, range);
  }
  
<span class="udiff-line-added">+ // for electronicCodeBook calls of aescrypt encrypt/decrypt, three pointers and a length, returning int</span>
<span class="udiff-line-added">+ const TypeFunc* OptoRuntime::electronicCodeBook_aescrypt_Type() {</span>
<span class="udiff-line-added">+   // create input type (domain)</span>
<span class="udiff-line-added">+   int num_args = 4;</span>
<span class="udiff-line-added">+   if (Matcher::pass_original_key_for_aes()) {</span>
<span class="udiff-line-added">+      num_args = 5;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   int argcnt = num_args;</span>
<span class="udiff-line-added">+   const Type** fields = TypeTuple::fields(argcnt);</span>
<span class="udiff-line-added">+   int argp = TypeFunc::Parms;</span>
<span class="udiff-line-added">+   fields[argp++] = TypePtr::NOTNULL;    // src</span>
<span class="udiff-line-added">+   fields[argp++] = TypePtr::NOTNULL;    // dest</span>
<span class="udiff-line-added">+   fields[argp++] = TypePtr::NOTNULL;    // k array</span>
<span class="udiff-line-added">+   fields[argp++] = TypeInt::INT;        // src len</span>
<span class="udiff-line-added">+   if (Matcher::pass_original_key_for_aes()) {</span>
<span class="udiff-line-added">+      fields[argp++] = TypePtr::NOTNULL;    // original k array</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   assert(argp == TypeFunc::Parms + argcnt, &quot;correct decoding&quot;);</span>
<span class="udiff-line-added">+   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // returning cipher len (int)</span>
<span class="udiff-line-added">+   fields = TypeTuple::fields(1);</span>
<span class="udiff-line-added">+   fields[TypeFunc::Parms + 0] = TypeInt::INT;</span>
<span class="udiff-line-added">+   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);</span>
<span class="udiff-line-added">+   return TypeFunc::make(domain, range);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  //for counterMode calls of aescrypt encrypt/decrypt, four pointers and a length, returning int
  const TypeFunc* OptoRuntime::counterMode_aescrypt_Type() {
    // create input type (domain)
    int num_args = 7;
    if (Matcher::pass_original_key_for_aes()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1082,10 +1109,29 @@</span>
  
    const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);
    return TypeFunc::make(domain, range);
  }
  
<span class="udiff-line-added">+ const TypeFunc * OptoRuntime::bigIntegerShift_Type() {</span>
<span class="udiff-line-added">+   int argcnt = 5;</span>
<span class="udiff-line-added">+   const Type** fields = TypeTuple::fields(argcnt);</span>
<span class="udiff-line-added">+   int argp = TypeFunc::Parms;</span>
<span class="udiff-line-added">+   fields[argp++] = TypePtr::NOTNULL;    // newArr</span>
<span class="udiff-line-added">+   fields[argp++] = TypePtr::NOTNULL;    // oldArr</span>
<span class="udiff-line-added">+   fields[argp++] = TypeInt::INT;        // newIdx</span>
<span class="udiff-line-added">+   fields[argp++] = TypeInt::INT;        // shiftCount</span>
<span class="udiff-line-added">+   fields[argp++] = TypeInt::INT;        // numIter</span>
<span class="udiff-line-added">+   assert(argp == TypeFunc::Parms + argcnt, &quot;correct decoding&quot;);</span>
<span class="udiff-line-added">+   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // no result type needed</span>
<span class="udiff-line-added">+   fields = TypeTuple::fields(1);</span>
<span class="udiff-line-added">+   fields[TypeFunc::Parms + 0] = NULL;</span>
<span class="udiff-line-added">+   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);</span>
<span class="udiff-line-added">+   return TypeFunc::make(domain, range);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  const TypeFunc* OptoRuntime::vectorizedMismatch_Type() {
    // create input type (domain)
    int num_args = 4;
    int argcnt = num_args;
    const Type** fields = TypeTuple::fields(argcnt);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1410,11 +1456,11 @@</span>
  //       to handle deoptimized blobs
  //
  // However, there needs to be a safepoint check in the middle!  So compiled
  // safepoints are completely watertight.
  //
<span class="udiff-line-modified-removed">- // Thus, it cannot be a leaf since it contains the NoGCVerifier.</span>
<span class="udiff-line-modified-added">+ // Thus, it cannot be a leaf since it contains the NoSafepointVerifier.</span>
  //
  // *THIS IS NOT RECOMMENDED PROGRAMMING STYLE*
  //
  address OptoRuntime::rethrow_C(oopDesc* exception, JavaThread* thread, address ret_pc) {
  #ifndef PRODUCT
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1630,11 +1676,11 @@</span>
    NamedCounter* head;
    do {
      c-&gt;set_next(NULL);
      head = _named_counters;
      c-&gt;set_next(head);
<span class="udiff-line-modified-removed">-   } while (Atomic::cmpxchg(c, &amp;_named_counters, head) != head);</span>
<span class="udiff-line-modified-added">+   } while (Atomic::cmpxchg(&amp;_named_counters, head, c) != head);</span>
    return c;
  }
  
  int trace_exception_counter = 0;
  static void trace_exception(outputStream* st, oop exception_oop, address exception_pc, const char* msg) {
</pre>
<center><a href="rootnode.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="runtime.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/opto/castnode.cpp b/src/hotspot/share/opto/castnode.cpp
--- a/src/hotspot/share/opto/castnode.cpp
+++ b/src/hotspot/share/opto/castnode.cpp
@@ -61,10 +61,18 @@
       if( t1 == Type::TOP )  assert(ft == Type::TOP, "special case #1");
       const Type* rt = t1->join_speculative(_type);
       if (rt->empty())       assert(ft == Type::TOP, "special case #2");
       break;
     }
+    case Op_CastLL:
+    {
+      const Type* t1 = phase->type(in(1));
+      if (t1 == Type::TOP)   assert(ft == Type::TOP, "special case #1");
+      const Type* rt = t1->join_speculative(_type);
+      if (rt->empty())       assert(ft == Type::TOP, "special case #2");
+      break;
+    }
     case Op_CastPP:
     if (phase->type(in(1)) == TypePtr::NULL_PTR &&
         _type->isa_ptr() && _type->is_ptr()->_ptr == TypePtr::NotNull)
     assert(ft == Type::TOP, "special case #3");
     break;
@@ -79,11 +87,11 @@
 // control copies
 Node *ConstraintCastNode::Ideal(PhaseGVN *phase, bool can_reshape) {
   return (in(0) && remove_dead_region(phase, can_reshape)) ? this : NULL;
 }
 
-uint ConstraintCastNode::cmp(const Node &n) const {
+bool ConstraintCastNode::cmp(const Node &n) const {
   return TypeNode::cmp(n) && ((ConstraintCastNode&)n)._carry_dependency == _carry_dependency;
 }
 
 uint ConstraintCastNode::size_of() const {
   return sizeof(*this);
@@ -94,10 +102,15 @@
   case Op_CastII: {
     Node* cast = new CastIINode(n, t, carry_dependency);
     cast->set_req(0, c);
     return cast;
   }
+  case Op_CastLL: {
+    Node* cast = new CastLLNode(n, t, carry_dependency);
+    cast->set_req(0, c);
+    return cast;
+  }
   case Op_CastPP: {
     Node* cast = new CastPPNode(n, t, carry_dependency);
     cast->set_req(0, c);
     return cast;
   }
@@ -260,11 +273,11 @@
     }
   }
   return NULL;
 }
 
-uint CastIINode::cmp(const Node &n) const {
+bool CastIINode::cmp(const Node &n) const {
   return ConstraintCastNode::cmp(n) && ((CastIINode&)n)._range_check_dependency == _range_check_dependency;
 }
 
 uint CastIINode::size_of() const {
   return sizeof(*this);
@@ -277,10 +290,49 @@
     st->print(" range check dependency");
   }
 }
 #endif
 
+Node* CastLLNode::Ideal(PhaseGVN* phase, bool can_reshape) {
+  Node* progress = ConstraintCastNode::Ideal(phase, can_reshape);
+  if (progress != NULL) {
+    return progress;
+  }
+
+  // Same as in CastIINode::Ideal but for TypeLong instead of TypeInt
+  if (can_reshape && !phase->C->major_progress()) {
+    const TypeLong* this_type = this->type()->is_long();
+    const TypeLong* in_type = phase->type(in(1))->isa_long();
+    if (in_type != NULL && this_type != NULL &&
+        (in_type->_lo != this_type->_lo ||
+         in_type->_hi != this_type->_hi)) {
+      jlong lo1 = this_type->_lo;
+      jlong hi1 = this_type->_hi;
+      int w1  = this_type->_widen;
+
+      if (lo1 >= 0) {
+        // Keep a range assertion of >=0.
+        lo1 = 0;         hi1 = max_jlong;
+      } else if (hi1 < 0) {
+        // Keep a range assertion of <0.
+        lo1 = min_jlong; hi1 = -1;
+      } else {
+        lo1 = min_jlong; hi1 = max_jlong;
+      }
+      const TypeLong* wtype = TypeLong::make(MAX2(in_type->_lo, lo1),
+                                             MIN2(in_type->_hi, hi1),
+                                             MAX2((int)in_type->_widen, w1));
+      if (wtype != type()) {
+        set_type(wtype);
+        return this;
+      }
+    }
+  }
+  return NULL;
+}
+
+
 //=============================================================================
 //------------------------------Identity---------------------------------------
 // If input is already higher or equal to cast type, then this is an identity.
 Node* CheckCastPPNode::Identity(PhaseGVN* phase) {
   Node* dom = dominating_cast(phase, phase);

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/node.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/shared/barrierSet.hpp&quot;
  27 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  28 #include &quot;libadt/vectset.hpp&quot;
  29 #include &quot;memory/allocation.inline.hpp&quot;
  30 #include &quot;memory/resourceArea.hpp&quot;
  31 #include &quot;opto/castnode.hpp&quot;
  32 #include &quot;opto/cfgnode.hpp&quot;
  33 #include &quot;opto/connode.hpp&quot;
  34 #include &quot;opto/loopnode.hpp&quot;
  35 #include &quot;opto/machnode.hpp&quot;
  36 #include &quot;opto/matcher.hpp&quot;
  37 #include &quot;opto/node.hpp&quot;
  38 #include &quot;opto/opcodes.hpp&quot;
  39 #include &quot;opto/regmask.hpp&quot;
  40 #include &quot;opto/rootnode.hpp&quot;
  41 #include &quot;opto/type.hpp&quot;
  42 #include &quot;utilities/copy.hpp&quot;
  43 #include &quot;utilities/macros.hpp&quot;
<a name="1" id="anc1"></a>
  44 
  45 class RegMask;
  46 // #include &quot;phase.hpp&quot;
  47 class PhaseTransform;
  48 class PhaseGVN;
  49 
  50 // Arena we are currently building Nodes in
  51 const uint Node::NotAMachineReg = 0xffff0000;
  52 
  53 #ifndef PRODUCT
  54 extern int nodes_created;
  55 #endif
  56 #ifdef __clang__
  57 #pragma clang diagnostic push
  58 #pragma GCC diagnostic ignored &quot;-Wuninitialized&quot;
  59 #endif
  60 
  61 #ifdef ASSERT
  62 
  63 //-------------------------- construct_node------------------------------------
  64 // Set a breakpoint here to identify where a particular node index is built.
  65 void Node::verify_construction() {
  66   _debug_orig = NULL;
  67   int old_debug_idx = Compile::debug_idx();
  68   int new_debug_idx = old_debug_idx+1;
  69   if (new_debug_idx &gt; 0) {
  70     // Arrange that the lowest five decimal digits of _debug_idx
  71     // will repeat those of _idx. In case this is somehow pathological,
  72     // we continue to assign negative numbers (!) consecutively.
  73     const int mod = 100000;
  74     int bump = (int)(_idx - new_debug_idx) % mod;
  75     if (bump &lt; 0)  bump += mod;
  76     assert(bump &gt;= 0 &amp;&amp; bump &lt; mod, &quot;&quot;);
  77     new_debug_idx += bump;
  78   }
  79   Compile::set_debug_idx(new_debug_idx);
  80   set_debug_idx( new_debug_idx );
  81   assert(Compile::current()-&gt;unique() &lt; (INT_MAX - 1), &quot;Node limit exceeded INT_MAX&quot;);
  82   assert(Compile::current()-&gt;live_nodes() &lt; Compile::current()-&gt;max_node_limit(), &quot;Live Node limit exceeded limit&quot;);
  83   if (BreakAtNode != 0 &amp;&amp; (_debug_idx == BreakAtNode || (int)_idx == BreakAtNode)) {
  84     tty-&gt;print_cr(&quot;BreakAtNode: _idx=%d _debug_idx=%d&quot;, _idx, _debug_idx);
  85     BREAKPOINT;
  86   }
  87 #if OPTO_DU_ITERATOR_ASSERT
  88   _last_del = NULL;
  89   _del_tick = 0;
  90 #endif
  91   _hash_lock = 0;
  92 }
  93 
  94 
  95 // #ifdef ASSERT ...
  96 
  97 #if OPTO_DU_ITERATOR_ASSERT
  98 void DUIterator_Common::sample(const Node* node) {
  99   _vdui     = VerifyDUIterators;
 100   _node     = node;
 101   _outcnt   = node-&gt;_outcnt;
 102   _del_tick = node-&gt;_del_tick;
 103   _last     = NULL;
 104 }
 105 
 106 void DUIterator_Common::verify(const Node* node, bool at_end_ok) {
 107   assert(_node     == node, &quot;consistent iterator source&quot;);
 108   assert(_del_tick == node-&gt;_del_tick, &quot;no unexpected deletions allowed&quot;);
 109 }
 110 
 111 void DUIterator_Common::verify_resync() {
 112   // Ensure that the loop body has just deleted the last guy produced.
 113   const Node* node = _node;
 114   // Ensure that at least one copy of the last-seen edge was deleted.
 115   // Note:  It is OK to delete multiple copies of the last-seen edge.
 116   // Unfortunately, we have no way to verify that all the deletions delete
 117   // that same edge.  On this point we must use the Honor System.
 118   assert(node-&gt;_del_tick &gt;= _del_tick+1, &quot;must have deleted an edge&quot;);
 119   assert(node-&gt;_last_del == _last, &quot;must have deleted the edge just produced&quot;);
 120   // We liked this deletion, so accept the resulting outcnt and tick.
 121   _outcnt   = node-&gt;_outcnt;
 122   _del_tick = node-&gt;_del_tick;
 123 }
 124 
 125 void DUIterator_Common::reset(const DUIterator_Common&amp; that) {
 126   if (this == &amp;that)  return;  // ignore assignment to self
 127   if (!_vdui) {
 128     // We need to initialize everything, overwriting garbage values.
 129     _last = that._last;
 130     _vdui = that._vdui;
 131   }
 132   // Note:  It is legal (though odd) for an iterator over some node x
 133   // to be reassigned to iterate over another node y.  Some doubly-nested
 134   // progress loops depend on being able to do this.
 135   const Node* node = that._node;
 136   // Re-initialize everything, except _last.
 137   _node     = node;
 138   _outcnt   = node-&gt;_outcnt;
 139   _del_tick = node-&gt;_del_tick;
 140 }
 141 
 142 void DUIterator::sample(const Node* node) {
 143   DUIterator_Common::sample(node);      // Initialize the assertion data.
 144   _refresh_tick = 0;                    // No refreshes have happened, as yet.
 145 }
 146 
 147 void DUIterator::verify(const Node* node, bool at_end_ok) {
 148   DUIterator_Common::verify(node, at_end_ok);
 149   assert(_idx      &lt;  node-&gt;_outcnt + (uint)at_end_ok, &quot;idx in range&quot;);
 150 }
 151 
 152 void DUIterator::verify_increment() {
 153   if (_refresh_tick &amp; 1) {
 154     // We have refreshed the index during this loop.
 155     // Fix up _idx to meet asserts.
 156     if (_idx &gt; _outcnt)  _idx = _outcnt;
 157   }
 158   verify(_node, true);
 159 }
 160 
 161 void DUIterator::verify_resync() {
 162   // Note:  We do not assert on _outcnt, because insertions are OK here.
 163   DUIterator_Common::verify_resync();
 164   // Make sure we are still in sync, possibly with no more out-edges:
 165   verify(_node, true);
 166 }
 167 
 168 void DUIterator::reset(const DUIterator&amp; that) {
 169   if (this == &amp;that)  return;  // self assignment is always a no-op
 170   assert(that._refresh_tick == 0, &quot;assign only the result of Node::outs()&quot;);
 171   assert(that._idx          == 0, &quot;assign only the result of Node::outs()&quot;);
 172   assert(_idx               == that._idx, &quot;already assigned _idx&quot;);
 173   if (!_vdui) {
 174     // We need to initialize everything, overwriting garbage values.
 175     sample(that._node);
 176   } else {
 177     DUIterator_Common::reset(that);
 178     if (_refresh_tick &amp; 1) {
 179       _refresh_tick++;                  // Clear the &quot;was refreshed&quot; flag.
 180     }
 181     assert(_refresh_tick &lt; 2*100000, &quot;DU iteration must converge quickly&quot;);
 182   }
 183 }
 184 
 185 void DUIterator::refresh() {
 186   DUIterator_Common::sample(_node);     // Re-fetch assertion data.
 187   _refresh_tick |= 1;                   // Set the &quot;was refreshed&quot; flag.
 188 }
 189 
 190 void DUIterator::verify_finish() {
 191   // If the loop has killed the node, do not require it to re-run.
 192   if (_node-&gt;_outcnt == 0)  _refresh_tick &amp;= ~1;
 193   // If this assert triggers, it means that a loop used refresh_out_pos
 194   // to re-synch an iteration index, but the loop did not correctly
 195   // re-run itself, using a &quot;while (progress)&quot; construct.
 196   // This iterator enforces the rule that you must keep trying the loop
 197   // until it &quot;runs clean&quot; without any need for refreshing.
 198   assert(!(_refresh_tick &amp; 1), &quot;the loop must run once with no refreshing&quot;);
 199 }
 200 
 201 
 202 void DUIterator_Fast::verify(const Node* node, bool at_end_ok) {
 203   DUIterator_Common::verify(node, at_end_ok);
 204   Node** out    = node-&gt;_out;
 205   uint   cnt    = node-&gt;_outcnt;
 206   assert(cnt == _outcnt, &quot;no insertions allowed&quot;);
 207   assert(_outp &gt;= out &amp;&amp; _outp &lt;= out + cnt - !at_end_ok, &quot;outp in range&quot;);
 208   // This last check is carefully designed to work for NO_OUT_ARRAY.
 209 }
 210 
 211 void DUIterator_Fast::verify_limit() {
 212   const Node* node = _node;
 213   verify(node, true);
 214   assert(_outp == node-&gt;_out + node-&gt;_outcnt, &quot;limit still correct&quot;);
 215 }
 216 
 217 void DUIterator_Fast::verify_resync() {
 218   const Node* node = _node;
 219   if (_outp == node-&gt;_out + _outcnt) {
 220     // Note that the limit imax, not the pointer i, gets updated with the
 221     // exact count of deletions.  (For the pointer it&#39;s always &quot;--i&quot;.)
 222     assert(node-&gt;_outcnt+node-&gt;_del_tick == _outcnt+_del_tick, &quot;no insertions allowed with deletion(s)&quot;);
 223     // This is a limit pointer, with a name like &quot;imax&quot;.
 224     // Fudge the _last field so that the common assert will be happy.
 225     _last = (Node*) node-&gt;_last_del;
 226     DUIterator_Common::verify_resync();
 227   } else {
 228     assert(node-&gt;_outcnt &lt; _outcnt, &quot;no insertions allowed with deletion(s)&quot;);
 229     // A normal internal pointer.
 230     DUIterator_Common::verify_resync();
 231     // Make sure we are still in sync, possibly with no more out-edges:
 232     verify(node, true);
 233   }
 234 }
 235 
 236 void DUIterator_Fast::verify_relimit(uint n) {
 237   const Node* node = _node;
 238   assert((int)n &gt; 0, &quot;use imax -= n only with a positive count&quot;);
 239   // This must be a limit pointer, with a name like &quot;imax&quot;.
 240   assert(_outp == node-&gt;_out + node-&gt;_outcnt, &quot;apply -= only to a limit (imax)&quot;);
 241   // The reported number of deletions must match what the node saw.
 242   assert(node-&gt;_del_tick == _del_tick + n, &quot;must have deleted n edges&quot;);
 243   // Fudge the _last field so that the common assert will be happy.
 244   _last = (Node*) node-&gt;_last_del;
 245   DUIterator_Common::verify_resync();
 246 }
 247 
 248 void DUIterator_Fast::reset(const DUIterator_Fast&amp; that) {
 249   assert(_outp              == that._outp, &quot;already assigned _outp&quot;);
 250   DUIterator_Common::reset(that);
 251 }
 252 
 253 void DUIterator_Last::verify(const Node* node, bool at_end_ok) {
 254   // at_end_ok means the _outp is allowed to underflow by 1
 255   _outp += at_end_ok;
 256   DUIterator_Fast::verify(node, at_end_ok);  // check _del_tick, etc.
 257   _outp -= at_end_ok;
 258   assert(_outp == (node-&gt;_out + node-&gt;_outcnt) - 1, &quot;pointer must point to end of nodes&quot;);
 259 }
 260 
 261 void DUIterator_Last::verify_limit() {
 262   // Do not require the limit address to be resynched.
 263   //verify(node, true);
 264   assert(_outp == _node-&gt;_out, &quot;limit still correct&quot;);
 265 }
 266 
 267 void DUIterator_Last::verify_step(uint num_edges) {
 268   assert((int)num_edges &gt; 0, &quot;need non-zero edge count for loop progress&quot;);
 269   _outcnt   -= num_edges;
 270   _del_tick += num_edges;
 271   // Make sure we are still in sync, possibly with no more out-edges:
 272   const Node* node = _node;
 273   verify(node, true);
 274   assert(node-&gt;_last_del == _last, &quot;must have deleted the edge just produced&quot;);
 275 }
 276 
 277 #endif //OPTO_DU_ITERATOR_ASSERT
 278 
 279 
 280 #endif //ASSERT
 281 
 282 
 283 // This constant used to initialize _out may be any non-null value.
 284 // The value NULL is reserved for the top node only.
 285 #define NO_OUT_ARRAY ((Node**)-1)
 286 
 287 // Out-of-line code from node constructors.
 288 // Executed only when extra debug info. is being passed around.
 289 static void init_node_notes(Compile* C, int idx, Node_Notes* nn) {
 290   C-&gt;set_node_notes_at(idx, nn);
 291 }
 292 
 293 // Shared initialization code.
 294 inline int Node::Init(int req) {
 295   Compile* C = Compile::current();
 296   int idx = C-&gt;next_unique();
 297 
 298   // Allocate memory for the necessary number of edges.
 299   if (req &gt; 0) {
 300     // Allocate space for _in array to have double alignment.
 301     _in = (Node **) ((char *) (C-&gt;node_arena()-&gt;Amalloc_D(req * sizeof(void*))));
 302   }
 303   // If there are default notes floating around, capture them:
 304   Node_Notes* nn = C-&gt;default_node_notes();
 305   if (nn != NULL)  init_node_notes(C, idx, nn);
 306 
 307   // Note:  At this point, C is dead,
 308   // and we begin to initialize the new Node.
 309 
 310   _cnt = _max = req;
 311   _outcnt = _outmax = 0;
 312   _class_id = Class_Node;
 313   _flags = 0;
 314   _out = NO_OUT_ARRAY;
 315   return idx;
 316 }
 317 
 318 //------------------------------Node-------------------------------------------
 319 // Create a Node, with a given number of required edges.
 320 Node::Node(uint req)
 321   : _idx(Init(req))
 322 #ifdef ASSERT
 323   , _parse_idx(_idx)
 324 #endif
 325 {
 326   assert( req &lt; Compile::current()-&gt;max_node_limit() - NodeLimitFudgeFactor, &quot;Input limit exceeded&quot; );
 327   debug_only( verify_construction() );
 328   NOT_PRODUCT(nodes_created++);
 329   if (req == 0) {
 330     _in = NULL;
 331   } else {
 332     Node** to = _in;
 333     for(uint i = 0; i &lt; req; i++) {
 334       to[i] = NULL;
 335     }
 336   }
 337 }
 338 
 339 //------------------------------Node-------------------------------------------
 340 Node::Node(Node *n0)
 341   : _idx(Init(1))
 342 #ifdef ASSERT
 343   , _parse_idx(_idx)
 344 #endif
 345 {
 346   debug_only( verify_construction() );
 347   NOT_PRODUCT(nodes_created++);
 348   assert( is_not_dead(n0), &quot;can not use dead node&quot;);
 349   _in[0] = n0; if (n0 != NULL) n0-&gt;add_out((Node *)this);
 350 }
 351 
 352 //------------------------------Node-------------------------------------------
 353 Node::Node(Node *n0, Node *n1)
 354   : _idx(Init(2))
 355 #ifdef ASSERT
 356   , _parse_idx(_idx)
 357 #endif
 358 {
 359   debug_only( verify_construction() );
 360   NOT_PRODUCT(nodes_created++);
 361   assert( is_not_dead(n0), &quot;can not use dead node&quot;);
 362   assert( is_not_dead(n1), &quot;can not use dead node&quot;);
 363   _in[0] = n0; if (n0 != NULL) n0-&gt;add_out((Node *)this);
 364   _in[1] = n1; if (n1 != NULL) n1-&gt;add_out((Node *)this);
 365 }
 366 
 367 //------------------------------Node-------------------------------------------
 368 Node::Node(Node *n0, Node *n1, Node *n2)
 369   : _idx(Init(3))
 370 #ifdef ASSERT
 371   , _parse_idx(_idx)
 372 #endif
 373 {
 374   debug_only( verify_construction() );
 375   NOT_PRODUCT(nodes_created++);
 376   assert( is_not_dead(n0), &quot;can not use dead node&quot;);
 377   assert( is_not_dead(n1), &quot;can not use dead node&quot;);
 378   assert( is_not_dead(n2), &quot;can not use dead node&quot;);
 379   _in[0] = n0; if (n0 != NULL) n0-&gt;add_out((Node *)this);
 380   _in[1] = n1; if (n1 != NULL) n1-&gt;add_out((Node *)this);
 381   _in[2] = n2; if (n2 != NULL) n2-&gt;add_out((Node *)this);
 382 }
 383 
 384 //------------------------------Node-------------------------------------------
 385 Node::Node(Node *n0, Node *n1, Node *n2, Node *n3)
 386   : _idx(Init(4))
 387 #ifdef ASSERT
 388   , _parse_idx(_idx)
 389 #endif
 390 {
 391   debug_only( verify_construction() );
 392   NOT_PRODUCT(nodes_created++);
 393   assert( is_not_dead(n0), &quot;can not use dead node&quot;);
 394   assert( is_not_dead(n1), &quot;can not use dead node&quot;);
 395   assert( is_not_dead(n2), &quot;can not use dead node&quot;);
 396   assert( is_not_dead(n3), &quot;can not use dead node&quot;);
 397   _in[0] = n0; if (n0 != NULL) n0-&gt;add_out((Node *)this);
 398   _in[1] = n1; if (n1 != NULL) n1-&gt;add_out((Node *)this);
 399   _in[2] = n2; if (n2 != NULL) n2-&gt;add_out((Node *)this);
 400   _in[3] = n3; if (n3 != NULL) n3-&gt;add_out((Node *)this);
 401 }
 402 
 403 //------------------------------Node-------------------------------------------
 404 Node::Node(Node *n0, Node *n1, Node *n2, Node *n3, Node *n4)
 405   : _idx(Init(5))
 406 #ifdef ASSERT
 407   , _parse_idx(_idx)
 408 #endif
 409 {
 410   debug_only( verify_construction() );
 411   NOT_PRODUCT(nodes_created++);
 412   assert( is_not_dead(n0), &quot;can not use dead node&quot;);
 413   assert( is_not_dead(n1), &quot;can not use dead node&quot;);
 414   assert( is_not_dead(n2), &quot;can not use dead node&quot;);
 415   assert( is_not_dead(n3), &quot;can not use dead node&quot;);
 416   assert( is_not_dead(n4), &quot;can not use dead node&quot;);
 417   _in[0] = n0; if (n0 != NULL) n0-&gt;add_out((Node *)this);
 418   _in[1] = n1; if (n1 != NULL) n1-&gt;add_out((Node *)this);
 419   _in[2] = n2; if (n2 != NULL) n2-&gt;add_out((Node *)this);
 420   _in[3] = n3; if (n3 != NULL) n3-&gt;add_out((Node *)this);
 421   _in[4] = n4; if (n4 != NULL) n4-&gt;add_out((Node *)this);
 422 }
 423 
 424 //------------------------------Node-------------------------------------------
 425 Node::Node(Node *n0, Node *n1, Node *n2, Node *n3,
 426                      Node *n4, Node *n5)
 427   : _idx(Init(6))
 428 #ifdef ASSERT
 429   , _parse_idx(_idx)
 430 #endif
 431 {
 432   debug_only( verify_construction() );
 433   NOT_PRODUCT(nodes_created++);
 434   assert( is_not_dead(n0), &quot;can not use dead node&quot;);
 435   assert( is_not_dead(n1), &quot;can not use dead node&quot;);
 436   assert( is_not_dead(n2), &quot;can not use dead node&quot;);
 437   assert( is_not_dead(n3), &quot;can not use dead node&quot;);
 438   assert( is_not_dead(n4), &quot;can not use dead node&quot;);
 439   assert( is_not_dead(n5), &quot;can not use dead node&quot;);
 440   _in[0] = n0; if (n0 != NULL) n0-&gt;add_out((Node *)this);
 441   _in[1] = n1; if (n1 != NULL) n1-&gt;add_out((Node *)this);
 442   _in[2] = n2; if (n2 != NULL) n2-&gt;add_out((Node *)this);
 443   _in[3] = n3; if (n3 != NULL) n3-&gt;add_out((Node *)this);
 444   _in[4] = n4; if (n4 != NULL) n4-&gt;add_out((Node *)this);
 445   _in[5] = n5; if (n5 != NULL) n5-&gt;add_out((Node *)this);
 446 }
 447 
 448 //------------------------------Node-------------------------------------------
 449 Node::Node(Node *n0, Node *n1, Node *n2, Node *n3,
 450                      Node *n4, Node *n5, Node *n6)
 451   : _idx(Init(7))
 452 #ifdef ASSERT
 453   , _parse_idx(_idx)
 454 #endif
 455 {
 456   debug_only( verify_construction() );
 457   NOT_PRODUCT(nodes_created++);
 458   assert( is_not_dead(n0), &quot;can not use dead node&quot;);
 459   assert( is_not_dead(n1), &quot;can not use dead node&quot;);
 460   assert( is_not_dead(n2), &quot;can not use dead node&quot;);
 461   assert( is_not_dead(n3), &quot;can not use dead node&quot;);
 462   assert( is_not_dead(n4), &quot;can not use dead node&quot;);
 463   assert( is_not_dead(n5), &quot;can not use dead node&quot;);
 464   assert( is_not_dead(n6), &quot;can not use dead node&quot;);
 465   _in[0] = n0; if (n0 != NULL) n0-&gt;add_out((Node *)this);
 466   _in[1] = n1; if (n1 != NULL) n1-&gt;add_out((Node *)this);
 467   _in[2] = n2; if (n2 != NULL) n2-&gt;add_out((Node *)this);
 468   _in[3] = n3; if (n3 != NULL) n3-&gt;add_out((Node *)this);
 469   _in[4] = n4; if (n4 != NULL) n4-&gt;add_out((Node *)this);
 470   _in[5] = n5; if (n5 != NULL) n5-&gt;add_out((Node *)this);
 471   _in[6] = n6; if (n6 != NULL) n6-&gt;add_out((Node *)this);
 472 }
 473 
 474 #ifdef __clang__
 475 #pragma clang diagnostic pop
 476 #endif
 477 
 478 
 479 //------------------------------clone------------------------------------------
 480 // Clone a Node.
 481 Node *Node::clone() const {
 482   Compile* C = Compile::current();
 483   uint s = size_of();           // Size of inherited Node
 484   Node *n = (Node*)C-&gt;node_arena()-&gt;Amalloc_D(size_of() + _max*sizeof(Node*));
 485   Copy::conjoint_words_to_lower((HeapWord*)this, (HeapWord*)n, s);
 486   // Set the new input pointer array
 487   n-&gt;_in = (Node**)(((char*)n)+s);
 488   // Cannot share the old output pointer array, so kill it
 489   n-&gt;_out = NO_OUT_ARRAY;
 490   // And reset the counters to 0
 491   n-&gt;_outcnt = 0;
 492   n-&gt;_outmax = 0;
 493   // Unlock this guy, since he is not in any hash table.
 494   debug_only(n-&gt;_hash_lock = 0);
 495   // Walk the old node&#39;s input list to duplicate its edges
 496   uint i;
 497   for( i = 0; i &lt; len(); i++ ) {
 498     Node *x = in(i);
 499     n-&gt;_in[i] = x;
 500     if (x != NULL) x-&gt;add_out(n);
 501   }
 502   if (is_macro())
 503     C-&gt;add_macro_node(n);
 504   if (is_expensive())
 505     C-&gt;add_expensive_node(n);
 506   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 507   bs-&gt;register_potential_barrier_node(n);
 508   // If the cloned node is a range check dependent CastII, add it to the list.
 509   CastIINode* cast = n-&gt;isa_CastII();
 510   if (cast != NULL &amp;&amp; cast-&gt;has_range_check()) {
 511     C-&gt;add_range_check_cast(cast);
 512   }
 513   if (n-&gt;Opcode() == Op_Opaque4) {
 514     C-&gt;add_opaque4_node(n);
 515   }
 516 
 517   n-&gt;set_idx(C-&gt;next_unique()); // Get new unique index as well
 518   debug_only( n-&gt;verify_construction() );
 519   NOT_PRODUCT(nodes_created++);
 520   // Do not patch over the debug_idx of a clone, because it makes it
 521   // impossible to break on the clone&#39;s moment of creation.
 522   //debug_only( n-&gt;set_debug_idx( debug_idx() ) );
 523 
 524   C-&gt;copy_node_notes_to(n, (Node*) this);
 525 
 526   // MachNode clone
 527   uint nopnds;
 528   if (this-&gt;is_Mach() &amp;&amp; (nopnds = this-&gt;as_Mach()-&gt;num_opnds()) &gt; 0) {
 529     MachNode *mach  = n-&gt;as_Mach();
 530     MachNode *mthis = this-&gt;as_Mach();
 531     // Get address of _opnd_array.
 532     // It should be the same offset since it is the clone of this node.
 533     MachOper **from = mthis-&gt;_opnds;
 534     MachOper **to = (MachOper **)((size_t)(&amp;mach-&gt;_opnds) +
 535                     pointer_delta((const void*)from,
 536                                   (const void*)(&amp;mthis-&gt;_opnds), 1));
 537     mach-&gt;_opnds = to;
 538     for ( uint i = 0; i &lt; nopnds; ++i ) {
 539       to[i] = from[i]-&gt;clone();
 540     }
 541   }
 542   // cloning CallNode may need to clone JVMState
 543   if (n-&gt;is_Call()) {
 544     n-&gt;as_Call()-&gt;clone_jvms(C);
 545   }
 546   if (n-&gt;is_SafePoint()) {
 547     n-&gt;as_SafePoint()-&gt;clone_replaced_nodes();
 548   }
 549   return n;                     // Return the clone
 550 }
 551 
 552 //---------------------------setup_is_top--------------------------------------
 553 // Call this when changing the top node, to reassert the invariants
 554 // required by Node::is_top.  See Compile::set_cached_top_node.
 555 void Node::setup_is_top() {
 556   if (this == (Node*)Compile::current()-&gt;top()) {
 557     // This node has just become top.  Kill its out array.
 558     _outcnt = _outmax = 0;
 559     _out = NULL;                           // marker value for top
 560     assert(is_top(), &quot;must be top&quot;);
 561   } else {
 562     if (_out == NULL)  _out = NO_OUT_ARRAY;
 563     assert(!is_top(), &quot;must not be top&quot;);
 564   }
 565 }
 566 
<a name="2" id="anc2"></a><span class="line-removed"> 567 </span>
 568 //------------------------------~Node------------------------------------------
 569 // Fancy destructor; eagerly attempt to reclaim Node numberings and storage
 570 void Node::destruct() {
 571   // Eagerly reclaim unique Node numberings
 572   Compile* compile = Compile::current();
 573   if ((uint)_idx+1 == compile-&gt;unique()) {
 574     compile-&gt;set_unique(compile-&gt;unique()-1);
 575   }
 576   // Clear debug info:
 577   Node_Notes* nn = compile-&gt;node_notes_at(_idx);
 578   if (nn != NULL)  nn-&gt;clear();
 579   // Walk the input array, freeing the corresponding output edges
 580   _cnt = _max;  // forget req/prec distinction
 581   uint i;
 582   for( i = 0; i &lt; _max; i++ ) {
 583     set_req(i, NULL);
 584     //assert(def-&gt;out(def-&gt;outcnt()-1) == (Node *)this,&quot;bad def-use hacking in reclaim&quot;);
 585   }
 586   assert(outcnt() == 0, &quot;deleting a node must not leave a dangling use&quot;);
 587   // See if the input array was allocated just prior to the object
 588   int edge_size = _max*sizeof(void*);
 589   int out_edge_size = _outmax*sizeof(void*);
 590   char *edge_end = ((char*)_in) + edge_size;
 591   char *out_array = (char*)(_out == NO_OUT_ARRAY? NULL: _out);
 592   int node_size = size_of();
 593 
 594   // Free the output edge array
 595   if (out_edge_size &gt; 0) {
 596     compile-&gt;node_arena()-&gt;Afree(out_array, out_edge_size);
 597   }
 598 
 599   // Free the input edge array and the node itself
 600   if( edge_end == (char*)this ) {
 601     // It was; free the input array and object all in one hit
 602 #ifndef ASSERT
 603     compile-&gt;node_arena()-&gt;Afree(_in,edge_size+node_size);
 604 #endif
 605   } else {
 606     // Free just the input array
 607     compile-&gt;node_arena()-&gt;Afree(_in,edge_size);
 608 
 609     // Free just the object
 610 #ifndef ASSERT
 611     compile-&gt;node_arena()-&gt;Afree(this,node_size);
 612 #endif
 613   }
 614   if (is_macro()) {
 615     compile-&gt;remove_macro_node(this);
 616   }
 617   if (is_expensive()) {
 618     compile-&gt;remove_expensive_node(this);
 619   }
 620   CastIINode* cast = isa_CastII();
 621   if (cast != NULL &amp;&amp; cast-&gt;has_range_check()) {
 622     compile-&gt;remove_range_check_cast(cast);
 623   }
 624   if (Opcode() == Op_Opaque4) {
 625     compile-&gt;remove_opaque4_node(this);
 626   }
 627 
 628   if (is_SafePoint()) {
 629     as_SafePoint()-&gt;delete_replaced_nodes();
 630   }
 631   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 632   bs-&gt;unregister_potential_barrier_node(this);
 633 #ifdef ASSERT
 634   // We will not actually delete the storage, but we&#39;ll make the node unusable.
 635   *(address*)this = badAddress;  // smash the C++ vtbl, probably
 636   _in = _out = (Node**) badAddress;
 637   _max = _cnt = _outmax = _outcnt = 0;
 638   compile-&gt;remove_modified_node(this);
 639 #endif
 640 }
 641 
 642 //------------------------------grow-------------------------------------------
 643 // Grow the input array, making space for more edges
 644 void Node::grow( uint len ) {
 645   Arena* arena = Compile::current()-&gt;node_arena();
 646   uint new_max = _max;
 647   if( new_max == 0 ) {
 648     _max = 4;
 649     _in = (Node**)arena-&gt;Amalloc(4*sizeof(Node*));
 650     Node** to = _in;
 651     to[0] = NULL;
 652     to[1] = NULL;
 653     to[2] = NULL;
 654     to[3] = NULL;
 655     return;
 656   }
<a name="3" id="anc3"></a><span class="line-modified"> 657   while( new_max &lt;= len ) new_max &lt;&lt;= 1; // Find next power-of-2</span>
 658   // Trimming to limit allows a uint8 to handle up to 255 edges.
 659   // Previously I was using only powers-of-2 which peaked at 128 edges.
 660   //if( new_max &gt;= limit ) new_max = limit-1;
 661   _in = (Node**)arena-&gt;Arealloc(_in, _max*sizeof(Node*), new_max*sizeof(Node*));
 662   Copy::zero_to_bytes(&amp;_in[_max], (new_max-_max)*sizeof(Node*)); // NULL all new space
 663   _max = new_max;               // Record new max length
 664   // This assertion makes sure that Node::_max is wide enough to
 665   // represent the numerical value of new_max.
 666   assert(_max == new_max &amp;&amp; _max &gt; len, &quot;int width of _max is too small&quot;);
 667 }
 668 
 669 //-----------------------------out_grow----------------------------------------
 670 // Grow the input array, making space for more edges
 671 void Node::out_grow( uint len ) {
 672   assert(!is_top(), &quot;cannot grow a top node&#39;s out array&quot;);
 673   Arena* arena = Compile::current()-&gt;node_arena();
 674   uint new_max = _outmax;
 675   if( new_max == 0 ) {
 676     _outmax = 4;
 677     _out = (Node **)arena-&gt;Amalloc(4*sizeof(Node*));
 678     return;
 679   }
<a name="4" id="anc4"></a><span class="line-modified"> 680   while( new_max &lt;= len ) new_max &lt;&lt;= 1; // Find next power-of-2</span>
 681   // Trimming to limit allows a uint8 to handle up to 255 edges.
 682   // Previously I was using only powers-of-2 which peaked at 128 edges.
 683   //if( new_max &gt;= limit ) new_max = limit-1;
 684   assert(_out != NULL &amp;&amp; _out != NO_OUT_ARRAY, &quot;out must have sensible value&quot;);
 685   _out = (Node**)arena-&gt;Arealloc(_out,_outmax*sizeof(Node*),new_max*sizeof(Node*));
 686   //Copy::zero_to_bytes(&amp;_out[_outmax], (new_max-_outmax)*sizeof(Node*)); // NULL all new space
 687   _outmax = new_max;               // Record new max length
 688   // This assertion makes sure that Node::_max is wide enough to
 689   // represent the numerical value of new_max.
 690   assert(_outmax == new_max &amp;&amp; _outmax &gt; len, &quot;int width of _outmax is too small&quot;);
 691 }
 692 
 693 #ifdef ASSERT
 694 //------------------------------is_dead----------------------------------------
 695 bool Node::is_dead() const {
 696   // Mach and pinch point nodes may look like dead.
 697   if( is_top() || is_Mach() || (Opcode() == Op_Node &amp;&amp; _outcnt &gt; 0) )
 698     return false;
 699   for( uint i = 0; i &lt; _max; i++ )
 700     if( _in[i] != NULL )
 701       return false;
 702   dump();
 703   return true;
 704 }
<a name="5" id="anc5"></a><span class="line-removed"> 705 #endif</span>
 706 
<a name="6" id="anc6"></a>

















 707 
 708 //------------------------------is_unreachable---------------------------------
 709 bool Node::is_unreachable(PhaseIterGVN &amp;igvn) const {
 710   assert(!is_Mach(), &quot;doesn&#39;t work with MachNodes&quot;);
 711   return outcnt() == 0 || igvn.type(this) == Type::TOP || (in(0) != NULL &amp;&amp; in(0)-&gt;is_top());
 712 }
 713 
 714 //------------------------------add_req----------------------------------------
 715 // Add a new required input at the end
 716 void Node::add_req( Node *n ) {
 717   assert( is_not_dead(n), &quot;can not use dead node&quot;);
 718 
 719   // Look to see if I can move precedence down one without reallocating
 720   if( (_cnt &gt;= _max) || (in(_max-1) != NULL) )
 721     grow( _max+1 );
 722 
 723   // Find a precedence edge to move
 724   if( in(_cnt) != NULL ) {       // Next precedence edge is busy?
 725     uint i;
 726     for( i=_cnt; i&lt;_max; i++ )
 727       if( in(i) == NULL )       // Find the NULL at end of prec edge list
 728         break;                  // There must be one, since we grew the array
 729     _in[i] = in(_cnt);          // Move prec over, making space for req edge
 730   }
 731   _in[_cnt++] = n;            // Stuff over old prec edge
 732   if (n != NULL) n-&gt;add_out((Node *)this);
 733 }
 734 
 735 //---------------------------add_req_batch-------------------------------------
 736 // Add a new required input at the end
 737 void Node::add_req_batch( Node *n, uint m ) {
 738   assert( is_not_dead(n), &quot;can not use dead node&quot;);
 739   // check various edge cases
 740   if ((int)m &lt;= 1) {
 741     assert((int)m &gt;= 0, &quot;oob&quot;);
 742     if (m != 0)  add_req(n);
 743     return;
 744   }
 745 
 746   // Look to see if I can move precedence down one without reallocating
 747   if( (_cnt+m) &gt; _max || _in[_max-m] )
 748     grow( _max+m );
 749 
 750   // Find a precedence edge to move
 751   if( _in[_cnt] != NULL ) {     // Next precedence edge is busy?
 752     uint i;
 753     for( i=_cnt; i&lt;_max; i++ )
 754       if( _in[i] == NULL )      // Find the NULL at end of prec edge list
 755         break;                  // There must be one, since we grew the array
 756     // Slide all the precs over by m positions (assume #prec &lt;&lt; m).
 757     Copy::conjoint_words_to_higher((HeapWord*)&amp;_in[_cnt], (HeapWord*)&amp;_in[_cnt+m], ((i-_cnt)*sizeof(Node*)));
 758   }
 759 
 760   // Stuff over the old prec edges
 761   for(uint i=0; i&lt;m; i++ ) {
 762     _in[_cnt++] = n;
 763   }
 764 
 765   // Insert multiple out edges on the node.
 766   if (n != NULL &amp;&amp; !n-&gt;is_top()) {
 767     for(uint i=0; i&lt;m; i++ ) {
 768       n-&gt;add_out((Node *)this);
 769     }
 770   }
 771 }
 772 
 773 //------------------------------del_req----------------------------------------
 774 // Delete the required edge and compact the edge array
 775 void Node::del_req( uint idx ) {
 776   assert( idx &lt; _cnt, &quot;oob&quot;);
 777   assert( !VerifyHashTableKeys || _hash_lock == 0,
 778           &quot;remove node from hash table before modifying it&quot;);
 779   // First remove corresponding def-use edge
 780   Node *n = in(idx);
 781   if (n != NULL) n-&gt;del_out((Node *)this);
 782   _in[idx] = in(--_cnt); // Compact the array
 783   // Avoid spec violation: Gap in prec edges.
 784   close_prec_gap_at(_cnt);
 785   Compile::current()-&gt;record_modified_node(this);
 786 }
 787 
 788 //------------------------------del_req_ordered--------------------------------
 789 // Delete the required edge and compact the edge array with preserved order
 790 void Node::del_req_ordered( uint idx ) {
 791   assert( idx &lt; _cnt, &quot;oob&quot;);
 792   assert( !VerifyHashTableKeys || _hash_lock == 0,
 793           &quot;remove node from hash table before modifying it&quot;);
 794   // First remove corresponding def-use edge
 795   Node *n = in(idx);
 796   if (n != NULL) n-&gt;del_out((Node *)this);
 797   if (idx &lt; --_cnt) {    // Not last edge ?
 798     Copy::conjoint_words_to_lower((HeapWord*)&amp;_in[idx+1], (HeapWord*)&amp;_in[idx], ((_cnt-idx)*sizeof(Node*)));
 799   }
 800   // Avoid spec violation: Gap in prec edges.
 801   close_prec_gap_at(_cnt);
 802   Compile::current()-&gt;record_modified_node(this);
 803 }
 804 
 805 //------------------------------ins_req----------------------------------------
 806 // Insert a new required input at the end
 807 void Node::ins_req( uint idx, Node *n ) {
 808   assert( is_not_dead(n), &quot;can not use dead node&quot;);
 809   add_req(NULL);                // Make space
 810   assert( idx &lt; _max, &quot;Must have allocated enough space&quot;);
 811   // Slide over
 812   if(_cnt-idx-1 &gt; 0) {
 813     Copy::conjoint_words_to_higher((HeapWord*)&amp;_in[idx], (HeapWord*)&amp;_in[idx+1], ((_cnt-idx-1)*sizeof(Node*)));
 814   }
 815   _in[idx] = n;                            // Stuff over old required edge
 816   if (n != NULL) n-&gt;add_out((Node *)this); // Add reciprocal def-use edge
 817 }
 818 
 819 //-----------------------------find_edge---------------------------------------
 820 int Node::find_edge(Node* n) {
 821   for (uint i = 0; i &lt; len(); i++) {
 822     if (_in[i] == n)  return i;
 823   }
 824   return -1;
 825 }
 826 
 827 //----------------------------replace_edge-------------------------------------
 828 int Node::replace_edge(Node* old, Node* neww) {
 829   if (old == neww)  return 0;  // nothing to do
 830   uint nrep = 0;
 831   for (uint i = 0; i &lt; len(); i++) {
 832     if (in(i) == old) {
 833       if (i &lt; req()) {
 834         set_req(i, neww);
 835       } else {
 836         assert(find_prec_edge(neww) == -1, &quot;spec violation: duplicated prec edge (node %d -&gt; %d)&quot;, _idx, neww-&gt;_idx);
 837         set_prec(i, neww);
 838       }
 839       nrep++;
 840     }
 841   }
 842   return nrep;
 843 }
 844 
 845 /**
 846  * Replace input edges in the range pointing to &#39;old&#39; node.
 847  */
 848 int Node::replace_edges_in_range(Node* old, Node* neww, int start, int end) {
 849   if (old == neww)  return 0;  // nothing to do
 850   uint nrep = 0;
 851   for (int i = start; i &lt; end; i++) {
 852     if (in(i) == old) {
 853       set_req(i, neww);
 854       nrep++;
 855     }
 856   }
 857   return nrep;
 858 }
 859 
 860 //-------------------------disconnect_inputs-----------------------------------
 861 // NULL out all inputs to eliminate incoming Def-Use edges.
 862 // Return the number of edges between &#39;n&#39; and &#39;this&#39;
 863 int Node::disconnect_inputs(Node *n, Compile* C) {
 864   int edges_to_n = 0;
 865 
 866   uint cnt = req();
 867   for( uint i = 0; i &lt; cnt; ++i ) {
 868     if( in(i) == 0 ) continue;
 869     if( in(i) == n ) ++edges_to_n;
 870     set_req(i, NULL);
 871   }
 872   // Remove precedence edges if any exist
 873   // Note: Safepoints may have precedence edges, even during parsing
 874   if( (req() != len()) &amp;&amp; (in(req()) != NULL) ) {
 875     uint max = len();
 876     for( uint i = 0; i &lt; max; ++i ) {
 877       if( in(i) == 0 ) continue;
 878       if( in(i) == n ) ++edges_to_n;
 879       set_prec(i, NULL);
 880     }
 881   }
 882 
 883   // Node::destruct requires all out edges be deleted first
 884   // debug_only(destruct();)   // no reuse benefit expected
 885   if (edges_to_n == 0) {
 886     C-&gt;record_dead_node(_idx);
 887   }
 888   return edges_to_n;
 889 }
 890 
 891 //-----------------------------uncast---------------------------------------
 892 // %%% Temporary, until we sort out CheckCastPP vs. CastPP.
 893 // Strip away casting.  (It is depth-limited.)
<a name="7" id="anc7"></a><span class="line-modified"> 894 Node* Node::uncast() const {</span>

 895   // Should be inline:
 896   //return is_ConstraintCast() ? uncast_helper(this) : (Node*) this;
<a name="8" id="anc8"></a><span class="line-modified"> 897   if (is_ConstraintCast())</span>
<span class="line-modified"> 898     return uncast_helper(this);</span>
<span class="line-modified"> 899   else</span>
 900     return (Node*) this;
<a name="9" id="anc9"></a>
 901 }
 902 
 903 // Find out of current node that matches opcode.
 904 Node* Node::find_out_with(int opcode) {
 905   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
 906     Node* use = fast_out(i);
 907     if (use-&gt;Opcode() == opcode) {
 908       return use;
 909     }
 910   }
 911   return NULL;
 912 }
 913 
 914 // Return true if the current node has an out that matches opcode.
 915 bool Node::has_out_with(int opcode) {
 916   return (find_out_with(opcode) != NULL);
 917 }
 918 
 919 // Return true if the current node has an out that matches any of the opcodes.
 920 bool Node::has_out_with(int opcode1, int opcode2, int opcode3, int opcode4) {
 921   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
 922       int opcode = fast_out(i)-&gt;Opcode();
 923       if (opcode == opcode1 || opcode == opcode2 || opcode == opcode3 || opcode == opcode4) {
 924         return true;
 925       }
 926   }
 927   return false;
 928 }
 929 
 930 
 931 //---------------------------uncast_helper-------------------------------------
<a name="10" id="anc10"></a><span class="line-modified"> 932 Node* Node::uncast_helper(const Node* p) {</span>
 933 #ifdef ASSERT
 934   uint depth_count = 0;
 935   const Node* orig_p = p;
 936 #endif
 937 
 938   while (true) {
 939 #ifdef ASSERT
 940     if (depth_count &gt;= K) {
 941       orig_p-&gt;dump(4);
 942       if (p != orig_p)
 943         p-&gt;dump(1);
 944     }
 945     assert(depth_count++ &lt; K, &quot;infinite loop in Node::uncast_helper&quot;);
 946 #endif
 947     if (p == NULL || p-&gt;req() != 2) {
 948       break;
 949     } else if (p-&gt;is_ConstraintCast()) {
<a name="11" id="anc11"></a>


 950       p = p-&gt;in(1);
 951     } else {
 952       break;
 953     }
 954   }
 955   return (Node*) p;
 956 }
 957 
 958 //------------------------------add_prec---------------------------------------
 959 // Add a new precedence input.  Precedence inputs are unordered, with
 960 // duplicates removed and NULLs packed down at the end.
 961 void Node::add_prec( Node *n ) {
 962   assert( is_not_dead(n), &quot;can not use dead node&quot;);
 963 
 964   // Check for NULL at end
 965   if( _cnt &gt;= _max || in(_max-1) )
 966     grow( _max+1 );
 967 
 968   // Find a precedence edge to move
 969   uint i = _cnt;
 970   while( in(i) != NULL ) {
 971     if (in(i) == n) return; // Avoid spec violation: duplicated prec edge.
 972     i++;
 973   }
 974   _in[i] = n;                                // Stuff prec edge over NULL
 975   if ( n != NULL) n-&gt;add_out((Node *)this);  // Add mirror edge
 976 
 977 #ifdef ASSERT
 978   while ((++i)&lt;_max) { assert(_in[i] == NULL, &quot;spec violation: Gap in prec edges (node %d)&quot;, _idx); }
 979 #endif
 980 }
 981 
 982 //------------------------------rm_prec----------------------------------------
 983 // Remove a precedence input.  Precedence inputs are unordered, with
 984 // duplicates removed and NULLs packed down at the end.
 985 void Node::rm_prec( uint j ) {
 986   assert(j &lt; _max, &quot;oob: i=%d, _max=%d&quot;, j, _max);
 987   assert(j &gt;= _cnt, &quot;not a precedence edge&quot;);
 988   if (_in[j] == NULL) return;   // Avoid spec violation: Gap in prec edges.
 989   _in[j]-&gt;del_out((Node *)this);
 990   close_prec_gap_at(j);
 991 }
 992 
 993 //------------------------------size_of----------------------------------------
 994 uint Node::size_of() const { return sizeof(*this); }
 995 
 996 //------------------------------ideal_reg--------------------------------------
 997 uint Node::ideal_reg() const { return 0; }
 998 
 999 //------------------------------jvms-------------------------------------------
1000 JVMState* Node::jvms() const { return NULL; }
1001 
1002 #ifdef ASSERT
1003 //------------------------------jvms-------------------------------------------
1004 bool Node::verify_jvms(const JVMState* using_jvms) const {
1005   for (JVMState* jvms = this-&gt;jvms(); jvms != NULL; jvms = jvms-&gt;caller()) {
1006     if (jvms == using_jvms)  return true;
1007   }
1008   return false;
1009 }
1010 
1011 //------------------------------init_NodeProperty------------------------------
1012 void Node::init_NodeProperty() {
1013   assert(_max_classes &lt;= max_jushort, &quot;too many NodeProperty classes&quot;);
1014   assert(_max_flags &lt;= max_jushort, &quot;too many NodeProperty flags&quot;);
1015 }
1016 #endif
1017 
1018 //------------------------------format-----------------------------------------
1019 // Print as assembly
1020 void Node::format( PhaseRegAlloc *, outputStream *st ) const {}
1021 //------------------------------emit-------------------------------------------
1022 // Emit bytes starting at parameter &#39;ptr&#39;.
1023 void Node::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {}
1024 //------------------------------size-------------------------------------------
1025 // Size of instruction in bytes
1026 uint Node::size(PhaseRegAlloc *ra_) const { return 0; }
1027 
1028 //------------------------------CFG Construction-------------------------------
1029 // Nodes that end basic blocks, e.g. IfTrue/IfFalse, JumpProjNode, Root,
1030 // Goto and Return.
1031 const Node *Node::is_block_proj() const { return 0; }
1032 
1033 // Minimum guaranteed type
1034 const Type *Node::bottom_type() const { return Type::BOTTOM; }
1035 
1036 
1037 //------------------------------raise_bottom_type------------------------------
1038 // Get the worst-case Type output for this Node.
1039 void Node::raise_bottom_type(const Type* new_type) {
1040   if (is_Type()) {
1041     TypeNode *n = this-&gt;as_Type();
1042     if (VerifyAliases) {
1043       assert(new_type-&gt;higher_equal_speculative(n-&gt;type()), &quot;new type must refine old type&quot;);
1044     }
1045     n-&gt;set_type(new_type);
1046   } else if (is_Load()) {
1047     LoadNode *n = this-&gt;as_Load();
1048     if (VerifyAliases) {
1049       assert(new_type-&gt;higher_equal_speculative(n-&gt;type()), &quot;new type must refine old type&quot;);
1050     }
1051     n-&gt;set_type(new_type);
1052   }
1053 }
1054 
1055 //------------------------------Identity---------------------------------------
1056 // Return a node that the given node is equivalent to.
1057 Node* Node::Identity(PhaseGVN* phase) {
1058   return this;                  // Default to no identities
1059 }
1060 
1061 //------------------------------Value------------------------------------------
1062 // Compute a new Type for a node using the Type of the inputs.
1063 const Type* Node::Value(PhaseGVN* phase) const {
1064   return bottom_type();         // Default to worst-case Type
1065 }
1066 
1067 //------------------------------Ideal------------------------------------------
1068 //
1069 // &#39;Idealize&#39; the graph rooted at this Node.
1070 //
1071 // In order to be efficient and flexible there are some subtle invariants
1072 // these Ideal calls need to hold.  Running with &#39;+VerifyIterativeGVN&#39; checks
1073 // these invariants, although its too slow to have on by default.  If you are
1074 // hacking an Ideal call, be sure to test with +VerifyIterativeGVN!
1075 //
1076 // The Ideal call almost arbitrarily reshape the graph rooted at the &#39;this&#39;
1077 // pointer.  If ANY change is made, it must return the root of the reshaped
1078 // graph - even if the root is the same Node.  Example: swapping the inputs
1079 // to an AddINode gives the same answer and same root, but you still have to
1080 // return the &#39;this&#39; pointer instead of NULL.
1081 //
1082 // You cannot return an OLD Node, except for the &#39;this&#39; pointer.  Use the
1083 // Identity call to return an old Node; basically if Identity can find
1084 // another Node have the Ideal call make no change and return NULL.
1085 // Example: AddINode::Ideal must check for add of zero; in this case it
1086 // returns NULL instead of doing any graph reshaping.
1087 //
1088 // You cannot modify any old Nodes except for the &#39;this&#39; pointer.  Due to
1089 // sharing there may be other users of the old Nodes relying on their current
1090 // semantics.  Modifying them will break the other users.
1091 // Example: when reshape &quot;(X+3)+4&quot; into &quot;X+7&quot; you must leave the Node for
1092 // &quot;X+3&quot; unchanged in case it is shared.
1093 //
1094 // If you modify the &#39;this&#39; pointer&#39;s inputs, you should use
1095 // &#39;set_req&#39;.  If you are making a new Node (either as the new root or
1096 // some new internal piece) you may use &#39;init_req&#39; to set the initial
1097 // value.  You can make a new Node with either &#39;new&#39; or &#39;clone&#39;.  In
1098 // either case, def-use info is correctly maintained.
1099 //
1100 // Example: reshape &quot;(X+3)+4&quot; into &quot;X+7&quot;:
1101 //    set_req(1, in(1)-&gt;in(1));
1102 //    set_req(2, phase-&gt;intcon(7));
1103 //    return this;
1104 // Example: reshape &quot;X*4&quot; into &quot;X&lt;&lt;2&quot;
1105 //    return new LShiftINode(in(1), phase-&gt;intcon(2));
1106 //
1107 // You must call &#39;phase-&gt;transform(X)&#39; on any new Nodes X you make, except
1108 // for the returned root node.  Example: reshape &quot;X*31&quot; with &quot;(X&lt;&lt;5)-X&quot;.
1109 //    Node *shift=phase-&gt;transform(new LShiftINode(in(1),phase-&gt;intcon(5)));
1110 //    return new AddINode(shift, in(1));
1111 //
1112 // When making a Node for a constant use &#39;phase-&gt;makecon&#39; or &#39;phase-&gt;intcon&#39;.
1113 // These forms are faster than &#39;phase-&gt;transform(new ConNode())&#39; and Do
1114 // The Right Thing with def-use info.
1115 //
1116 // You cannot bury the &#39;this&#39; Node inside of a graph reshape.  If the reshaped
1117 // graph uses the &#39;this&#39; Node it must be the root.  If you want a Node with
1118 // the same Opcode as the &#39;this&#39; pointer use &#39;clone&#39;.
1119 //
1120 Node *Node::Ideal(PhaseGVN *phase, bool can_reshape) {
1121   return NULL;                  // Default to being Ideal already
1122 }
1123 
1124 // Some nodes have specific Ideal subgraph transformations only if they are
1125 // unique users of specific nodes. Such nodes should be put on IGVN worklist
1126 // for the transformations to happen.
1127 bool Node::has_special_unique_user() const {
1128   assert(outcnt() == 1, &quot;match only for unique out&quot;);
1129   Node* n = unique_out();
1130   int op  = Opcode();
1131   if (this-&gt;is_Store()) {
1132     // Condition for back-to-back stores folding.
1133     return n-&gt;Opcode() == op &amp;&amp; n-&gt;in(MemNode::Memory) == this;
1134   } else if (this-&gt;is_Load() || this-&gt;is_DecodeN() || this-&gt;is_Phi()) {
1135     // Condition for removing an unused LoadNode or DecodeNNode from the MemBarAcquire precedence input
1136     return n-&gt;Opcode() == Op_MemBarAcquire;
1137   } else if (op == Op_AddL) {
1138     // Condition for convL2I(addL(x,y)) ==&gt; addI(convL2I(x),convL2I(y))
1139     return n-&gt;Opcode() == Op_ConvL2I &amp;&amp; n-&gt;in(1) == this;
1140   } else if (op == Op_SubI || op == Op_SubL) {
1141     // Condition for subI(x,subI(y,z)) ==&gt; subI(addI(x,z),y)
1142     return n-&gt;Opcode() == op &amp;&amp; n-&gt;in(2) == this;
1143   } else if (is_If() &amp;&amp; (n-&gt;is_IfFalse() || n-&gt;is_IfTrue())) {
1144     // See IfProjNode::Identity()
1145     return true;
1146   } else {
<a name="12" id="anc12"></a><span class="line-modified">1147     return BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;has_special_unique_user(this);</span>
1148   }
1149 };
1150 
1151 //--------------------------find_exact_control---------------------------------
1152 // Skip Proj and CatchProj nodes chains. Check for Null and Top.
1153 Node* Node::find_exact_control(Node* ctrl) {
1154   if (ctrl == NULL &amp;&amp; this-&gt;is_Region())
1155     ctrl = this-&gt;as_Region()-&gt;is_copy();
1156 
1157   if (ctrl != NULL &amp;&amp; ctrl-&gt;is_CatchProj()) {
1158     if (ctrl-&gt;as_CatchProj()-&gt;_con == CatchProjNode::fall_through_index)
1159       ctrl = ctrl-&gt;in(0);
1160     if (ctrl != NULL &amp;&amp; !ctrl-&gt;is_top())
1161       ctrl = ctrl-&gt;in(0);
1162   }
1163 
1164   if (ctrl != NULL &amp;&amp; ctrl-&gt;is_Proj())
1165     ctrl = ctrl-&gt;in(0);
1166 
1167   return ctrl;
1168 }
1169 
1170 //--------------------------dominates------------------------------------------
1171 // Helper function for MemNode::all_controls_dominate().
1172 // Check if &#39;this&#39; control node dominates or equal to &#39;sub&#39; control node.
1173 // We already know that if any path back to Root or Start reaches &#39;this&#39;,
1174 // then all paths so, so this is a simple search for one example,
1175 // not an exhaustive search for a counterexample.
1176 bool Node::dominates(Node* sub, Node_List &amp;nlist) {
1177   assert(this-&gt;is_CFG(), &quot;expecting control&quot;);
1178   assert(sub != NULL &amp;&amp; sub-&gt;is_CFG(), &quot;expecting control&quot;);
1179 
1180   // detect dead cycle without regions
1181   int iterations_without_region_limit = DominatorSearchLimit;
1182 
1183   Node* orig_sub = sub;
1184   Node* dom      = this;
1185   bool  met_dom  = false;
1186   nlist.clear();
1187 
1188   // Walk &#39;sub&#39; backward up the chain to &#39;dom&#39;, watching for regions.
1189   // After seeing &#39;dom&#39;, continue up to Root or Start.
1190   // If we hit a region (backward split point), it may be a loop head.
1191   // Keep going through one of the region&#39;s inputs.  If we reach the
1192   // same region again, go through a different input.  Eventually we
1193   // will either exit through the loop head, or give up.
1194   // (If we get confused, break out and return a conservative &#39;false&#39;.)
1195   while (sub != NULL) {
1196     if (sub-&gt;is_top())  break; // Conservative answer for dead code.
1197     if (sub == dom) {
1198       if (nlist.size() == 0) {
1199         // No Region nodes except loops were visited before and the EntryControl
1200         // path was taken for loops: it did not walk in a cycle.
1201         return true;
1202       } else if (met_dom) {
1203         break;          // already met before: walk in a cycle
1204       } else {
1205         // Region nodes were visited. Continue walk up to Start or Root
1206         // to make sure that it did not walk in a cycle.
1207         met_dom = true; // first time meet
1208         iterations_without_region_limit = DominatorSearchLimit; // Reset
1209      }
1210     }
1211     if (sub-&gt;is_Start() || sub-&gt;is_Root()) {
1212       // Success if we met &#39;dom&#39; along a path to Start or Root.
1213       // We assume there are no alternative paths that avoid &#39;dom&#39;.
1214       // (This assumption is up to the caller to ensure!)
1215       return met_dom;
1216     }
1217     Node* up = sub-&gt;in(0);
1218     // Normalize simple pass-through regions and projections:
1219     up = sub-&gt;find_exact_control(up);
1220     // If sub == up, we found a self-loop.  Try to push past it.
1221     if (sub == up &amp;&amp; sub-&gt;is_Loop()) {
1222       // Take loop entry path on the way up to &#39;dom&#39;.
1223       up = sub-&gt;in(1); // in(LoopNode::EntryControl);
<a name="13" id="anc13"></a><span class="line-modified">1224     } else if (sub == up &amp;&amp; sub-&gt;is_Region() &amp;&amp; sub-&gt;req() != 3) {</span>
<span class="line-modified">1225       // Always take in(1) path on the way up to &#39;dom&#39; for clone regions</span>
<span class="line-removed">1226       // (with only one input) or regions which merge &gt; 2 paths</span>
<span class="line-removed">1227       // (usually used to merge fast/slow paths).</span>
1228       up = sub-&gt;in(1);
<a name="14" id="anc14"></a><span class="line-modified">1229     } else if (sub == up &amp;&amp; sub-&gt;is_Region()) {</span>
1230       // Try both paths for Regions with 2 input paths (it may be a loop head).
1231       // It could give conservative &#39;false&#39; answer without information
1232       // which region&#39;s input is the entry path.
1233       iterations_without_region_limit = DominatorSearchLimit; // Reset
1234 
1235       bool region_was_visited_before = false;
1236       // Was this Region node visited before?
1237       // If so, we have reached it because we accidentally took a
1238       // loop-back edge from &#39;sub&#39; back into the body of the loop,
1239       // and worked our way up again to the loop header &#39;sub&#39;.
1240       // So, take the first unexplored path on the way up to &#39;dom&#39;.
1241       for (int j = nlist.size() - 1; j &gt;= 0; j--) {
1242         intptr_t ni = (intptr_t)nlist.at(j);
1243         Node* visited = (Node*)(ni &amp; ~1);
1244         bool  visited_twice_already = ((ni &amp; 1) != 0);
1245         if (visited == sub) {
1246           if (visited_twice_already) {
1247             // Visited 2 paths, but still stuck in loop body.  Give up.
1248             return false;
1249           }
1250           // The Region node was visited before only once.
1251           // (We will repush with the low bit set, below.)
1252           nlist.remove(j);
1253           // We will find a new edge and re-insert.
1254           region_was_visited_before = true;
1255           break;
1256         }
1257       }
1258 
1259       // Find an incoming edge which has not been seen yet; walk through it.
1260       assert(up == sub, &quot;&quot;);
1261       uint skip = region_was_visited_before ? 1 : 0;
1262       for (uint i = 1; i &lt; sub-&gt;req(); i++) {
1263         Node* in = sub-&gt;in(i);
1264         if (in != NULL &amp;&amp; !in-&gt;is_top() &amp;&amp; in != sub) {
1265           if (skip == 0) {
1266             up = in;
1267             break;
1268           }
1269           --skip;               // skip this nontrivial input
1270         }
1271       }
1272 
1273       // Set 0 bit to indicate that both paths were taken.
1274       nlist.push((Node*)((intptr_t)sub + (region_was_visited_before ? 1 : 0)));
1275     }
1276 
1277     if (up == sub) {
1278       break;    // some kind of tight cycle
1279     }
1280     if (up == orig_sub &amp;&amp; met_dom) {
1281       // returned back after visiting &#39;dom&#39;
1282       break;    // some kind of cycle
1283     }
1284     if (--iterations_without_region_limit &lt; 0) {
1285       break;    // dead cycle
1286     }
1287     sub = up;
1288   }
1289 
1290   // Did not meet Root or Start node in pred. chain.
1291   // Conservative answer for dead code.
1292   return false;
1293 }
1294 
1295 //------------------------------remove_dead_region-----------------------------
1296 // This control node is dead.  Follow the subgraph below it making everything
1297 // using it dead as well.  This will happen normally via the usual IterGVN
1298 // worklist but this call is more efficient.  Do not update use-def info
1299 // inside the dead region, just at the borders.
1300 static void kill_dead_code( Node *dead, PhaseIterGVN *igvn ) {
1301   // Con&#39;s are a popular node to re-hit in the hash table again.
1302   if( dead-&gt;is_Con() ) return;
1303 
<a name="15" id="anc15"></a><span class="line-modified">1304   // Can&#39;t put ResourceMark here since igvn-&gt;_worklist uses the same arena</span>
<span class="line-removed">1305   // for verify pass with +VerifyOpto and we add/remove elements in it here.</span>
1306   Node_List  nstack(Thread::current()-&gt;resource_area());
1307 
1308   Node *top = igvn-&gt;C-&gt;top();
1309   nstack.push(dead);
1310   bool has_irreducible_loop = igvn-&gt;C-&gt;has_irreducible_loop();
1311 
1312   while (nstack.size() &gt; 0) {
1313     dead = nstack.pop();
1314     if (dead-&gt;Opcode() == Op_SafePoint) {
1315       dead-&gt;as_SafePoint()-&gt;disconnect_from_root(igvn);
1316     }
1317     if (dead-&gt;outcnt() &gt; 0) {
1318       // Keep dead node on stack until all uses are processed.
1319       nstack.push(dead);
1320       // For all Users of the Dead...    ;-)
1321       for (DUIterator_Last kmin, k = dead-&gt;last_outs(kmin); k &gt;= kmin; ) {
1322         Node* use = dead-&gt;last_out(k);
1323         igvn-&gt;hash_delete(use);       // Yank from hash table prior to mod
1324         if (use-&gt;in(0) == dead) {     // Found another dead node
1325           assert (!use-&gt;is_Con(), &quot;Control for Con node should be Root node.&quot;);
1326           use-&gt;set_req(0, top);       // Cut dead edge to prevent processing
1327           nstack.push(use);           // the dead node again.
1328         } else if (!has_irreducible_loop &amp;&amp; // Backedge could be alive in irreducible loop
1329                    use-&gt;is_Loop() &amp;&amp; !use-&gt;is_Root() &amp;&amp;       // Don&#39;t kill Root (RootNode extends LoopNode)
1330                    use-&gt;in(LoopNode::EntryControl) == dead) { // Dead loop if its entry is dead
1331           use-&gt;set_req(LoopNode::EntryControl, top);          // Cut dead edge to prevent processing
1332           use-&gt;set_req(0, top);       // Cut self edge
1333           nstack.push(use);
1334         } else {                      // Else found a not-dead user
1335           // Dead if all inputs are top or null
1336           bool dead_use = !use-&gt;is_Root(); // Keep empty graph alive
1337           for (uint j = 1; j &lt; use-&gt;req(); j++) {
1338             Node* in = use-&gt;in(j);
1339             if (in == dead) {         // Turn all dead inputs into TOP
1340               use-&gt;set_req(j, top);
1341             } else if (in != NULL &amp;&amp; !in-&gt;is_top()) {
1342               dead_use = false;
1343             }
1344           }
1345           if (dead_use) {
1346             if (use-&gt;is_Region()) {
1347               use-&gt;set_req(0, top);   // Cut self edge
1348             }
1349             nstack.push(use);
1350           } else {
1351             igvn-&gt;_worklist.push(use);
1352           }
1353         }
1354         // Refresh the iterator, since any number of kills might have happened.
1355         k = dead-&gt;last_outs(kmin);
1356       }
1357     } else { // (dead-&gt;outcnt() == 0)
1358       // Done with outputs.
1359       igvn-&gt;hash_delete(dead);
1360       igvn-&gt;_worklist.remove(dead);
1361       igvn-&gt;C-&gt;remove_modified_node(dead);
1362       igvn-&gt;set_type(dead, Type::TOP);
1363       if (dead-&gt;is_macro()) {
1364         igvn-&gt;C-&gt;remove_macro_node(dead);
1365       }
1366       if (dead-&gt;is_expensive()) {
1367         igvn-&gt;C-&gt;remove_expensive_node(dead);
1368       }
1369       CastIINode* cast = dead-&gt;isa_CastII();
1370       if (cast != NULL &amp;&amp; cast-&gt;has_range_check()) {
1371         igvn-&gt;C-&gt;remove_range_check_cast(cast);
1372       }
1373       if (dead-&gt;Opcode() == Op_Opaque4) {
1374         igvn-&gt;C-&gt;remove_opaque4_node(dead);
1375       }
1376       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1377       bs-&gt;unregister_potential_barrier_node(dead);
1378       igvn-&gt;C-&gt;record_dead_node(dead-&gt;_idx);
1379       // Kill all inputs to the dead guy
1380       for (uint i=0; i &lt; dead-&gt;req(); i++) {
1381         Node *n = dead-&gt;in(i);      // Get input to dead guy
1382         if (n != NULL &amp;&amp; !n-&gt;is_top()) { // Input is valid?
1383           dead-&gt;set_req(i, top);    // Smash input away
1384           if (n-&gt;outcnt() == 0) {   // Input also goes dead?
1385             if (!n-&gt;is_Con())
1386               nstack.push(n);       // Clear it out as well
1387           } else if (n-&gt;outcnt() == 1 &amp;&amp;
1388                      n-&gt;has_special_unique_user()) {
1389             igvn-&gt;add_users_to_worklist( n );
1390           } else if (n-&gt;outcnt() &lt;= 2 &amp;&amp; n-&gt;is_Store()) {
1391             // Push store&#39;s uses on worklist to enable folding optimization for
1392             // store/store and store/load to the same address.
1393             // The restriction (outcnt() &lt;= 2) is the same as in set_req_X()
1394             // and remove_globally_dead_node().
1395             igvn-&gt;add_users_to_worklist( n );
1396           } else {
1397             BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;enqueue_useful_gc_barrier(igvn, n);
1398           }
1399         }
1400       }
1401     } // (dead-&gt;outcnt() == 0)
1402   }   // while (nstack.size() &gt; 0) for outputs
1403   return;
1404 }
1405 
1406 //------------------------------remove_dead_region-----------------------------
1407 bool Node::remove_dead_region(PhaseGVN *phase, bool can_reshape) {
1408   Node *n = in(0);
1409   if( !n ) return false;
1410   // Lost control into this guy?  I.e., it became unreachable?
1411   // Aggressively kill all unreachable code.
1412   if (can_reshape &amp;&amp; n-&gt;is_top()) {
1413     kill_dead_code(this, phase-&gt;is_IterGVN());
1414     return false; // Node is dead.
1415   }
1416 
1417   if( n-&gt;is_Region() &amp;&amp; n-&gt;as_Region()-&gt;is_copy() ) {
1418     Node *m = n-&gt;nonnull_req();
1419     set_req(0, m);
1420     return true;
1421   }
1422   return false;
1423 }
1424 
1425 //------------------------------hash-------------------------------------------
1426 // Hash function over Nodes.
1427 uint Node::hash() const {
1428   uint sum = 0;
1429   for( uint i=0; i&lt;_cnt; i++ )  // Add in all inputs
1430     sum = (sum&lt;&lt;1)-(uintptr_t)in(i);        // Ignore embedded NULLs
1431   return (sum&gt;&gt;2) + _cnt + Opcode();
1432 }
1433 
1434 //------------------------------cmp--------------------------------------------
1435 // Compare special parts of simple Nodes
<a name="16" id="anc16"></a><span class="line-modified">1436 uint Node::cmp( const Node &amp;n ) const {</span>
<span class="line-modified">1437   return 1;                     // Must be same</span>
1438 }
1439 
1440 //------------------------------rematerialize-----------------------------------
1441 // Should we clone rather than spill this instruction?
1442 bool Node::rematerialize() const {
1443   if ( is_Mach() )
1444     return this-&gt;as_Mach()-&gt;rematerialize();
1445   else
1446     return (_flags &amp; Flag_rematerialize) != 0;
1447 }
1448 
1449 //------------------------------needs_anti_dependence_check---------------------
1450 // Nodes which use memory without consuming it, hence need antidependences.
1451 bool Node::needs_anti_dependence_check() const {
<a name="17" id="anc17"></a><span class="line-modified">1452   if( req() &lt; 2 || (_flags &amp; Flag_needs_anti_dependence_check) == 0 )</span>
1453     return false;
<a name="18" id="anc18"></a><span class="line-modified">1454   else</span>
<span class="line-modified">1455     return in(1)-&gt;bottom_type()-&gt;has_memory();</span>
1456 }
1457 
<a name="19" id="anc19"></a><span class="line-removed">1458 </span>
1459 // Get an integer constant from a ConNode (or CastIINode).
1460 // Return a default value if there is no apparent constant here.
1461 const TypeInt* Node::find_int_type() const {
1462   if (this-&gt;is_Type()) {
1463     return this-&gt;as_Type()-&gt;type()-&gt;isa_int();
1464   } else if (this-&gt;is_Con()) {
1465     assert(is_Mach(), &quot;should be ConNode(TypeNode) or else a MachNode&quot;);
1466     return this-&gt;bottom_type()-&gt;isa_int();
1467   }
1468   return NULL;
1469 }
1470 
1471 // Get a pointer constant from a ConstNode.
1472 // Returns the constant if it is a pointer ConstNode
1473 intptr_t Node::get_ptr() const {
1474   assert( Opcode() == Op_ConP, &quot;&quot; );
1475   return ((ConPNode*)this)-&gt;type()-&gt;is_ptr()-&gt;get_con();
1476 }
1477 
1478 // Get a narrow oop constant from a ConNNode.
1479 intptr_t Node::get_narrowcon() const {
1480   assert( Opcode() == Op_ConN, &quot;&quot; );
1481   return ((ConNNode*)this)-&gt;type()-&gt;is_narrowoop()-&gt;get_con();
1482 }
1483 
1484 // Get a long constant from a ConNode.
1485 // Return a default value if there is no apparent constant here.
1486 const TypeLong* Node::find_long_type() const {
1487   if (this-&gt;is_Type()) {
1488     return this-&gt;as_Type()-&gt;type()-&gt;isa_long();
1489   } else if (this-&gt;is_Con()) {
1490     assert(is_Mach(), &quot;should be ConNode(TypeNode) or else a MachNode&quot;);
1491     return this-&gt;bottom_type()-&gt;isa_long();
1492   }
1493   return NULL;
1494 }
1495 
1496 
1497 /**
1498  * Return a ptr type for nodes which should have it.
1499  */
1500 const TypePtr* Node::get_ptr_type() const {
1501   const TypePtr* tp = this-&gt;bottom_type()-&gt;make_ptr();
1502 #ifdef ASSERT
1503   if (tp == NULL) {
1504     this-&gt;dump(1);
1505     assert((tp != NULL), &quot;unexpected node type&quot;);
1506   }
1507 #endif
1508   return tp;
1509 }
1510 
1511 // Get a double constant from a ConstNode.
1512 // Returns the constant if it is a double ConstNode
1513 jdouble Node::getd() const {
1514   assert( Opcode() == Op_ConD, &quot;&quot; );
1515   return ((ConDNode*)this)-&gt;type()-&gt;is_double_constant()-&gt;getd();
1516 }
1517 
1518 // Get a float constant from a ConstNode.
1519 // Returns the constant if it is a float ConstNode
1520 jfloat Node::getf() const {
1521   assert( Opcode() == Op_ConF, &quot;&quot; );
1522   return ((ConFNode*)this)-&gt;type()-&gt;is_float_constant()-&gt;getf();
1523 }
1524 
1525 #ifndef PRODUCT
1526 
1527 //------------------------------find------------------------------------------
1528 // Find a neighbor of this Node with the given _idx
1529 // If idx is negative, find its absolute value, following both _in and _out.
1530 static void find_recur(Compile* C,  Node* &amp;result, Node *n, int idx, bool only_ctrl,
1531                         VectorSet* old_space, VectorSet* new_space ) {
1532   int node_idx = (idx &gt;= 0) ? idx : -idx;
1533   if (NotANode(n))  return;  // Gracefully handle NULL, -1, 0xabababab, etc.
1534   // Contained in new_space or old_space?   Check old_arena first since it&#39;s mostly empty.
1535   VectorSet *v = C-&gt;old_arena()-&gt;contains(n) ? old_space : new_space;
1536   if( v-&gt;test(n-&gt;_idx) ) return;
1537   if( (int)n-&gt;_idx == node_idx
1538       debug_only(|| n-&gt;debug_idx() == node_idx) ) {
1539     if (result != NULL)
1540       tty-&gt;print(&quot;find: &quot; INTPTR_FORMAT &quot; and &quot; INTPTR_FORMAT &quot; both have idx==%d\n&quot;,
1541                  (uintptr_t)result, (uintptr_t)n, node_idx);
1542     result = n;
1543   }
1544   v-&gt;set(n-&gt;_idx);
1545   for( uint i=0; i&lt;n-&gt;len(); i++ ) {
1546     if( only_ctrl &amp;&amp; !(n-&gt;is_Region()) &amp;&amp; (n-&gt;Opcode() != Op_Root) &amp;&amp; (i != TypeFunc::Control) ) continue;
1547     find_recur(C, result, n-&gt;in(i), idx, only_ctrl, old_space, new_space );
1548   }
1549   // Search along forward edges also:
1550   if (idx &lt; 0 &amp;&amp; !only_ctrl) {
1551     for( uint j=0; j&lt;n-&gt;outcnt(); j++ ) {
1552       find_recur(C, result, n-&gt;raw_out(j), idx, only_ctrl, old_space, new_space );
1553     }
1554   }
1555 #ifdef ASSERT
1556   // Search along debug_orig edges last, checking for cycles
1557   Node* orig = n-&gt;debug_orig();
1558   if (orig != NULL) {
1559     do {
1560       if (NotANode(orig))  break;
1561       find_recur(C, result, orig, idx, only_ctrl, old_space, new_space );
1562       orig = orig-&gt;debug_orig();
1563     } while (orig != NULL &amp;&amp; orig != n-&gt;debug_orig());
1564   }
1565 #endif //ASSERT
1566 }
1567 
1568 // call this from debugger:
1569 Node* find_node(Node* n, int idx) {
1570   return n-&gt;find(idx);
1571 }
1572 
1573 //------------------------------find-------------------------------------------
1574 Node* Node::find(int idx) const {
1575   ResourceArea *area = Thread::current()-&gt;resource_area();
1576   VectorSet old_space(area), new_space(area);
1577   Node* result = NULL;
1578   find_recur(Compile::current(), result, (Node*) this, idx, false, &amp;old_space, &amp;new_space );
1579   return result;
1580 }
1581 
1582 //------------------------------find_ctrl--------------------------------------
1583 // Find an ancestor to this node in the control history with given _idx
1584 Node* Node::find_ctrl(int idx) const {
1585   ResourceArea *area = Thread::current()-&gt;resource_area();
1586   VectorSet old_space(area), new_space(area);
1587   Node* result = NULL;
1588   find_recur(Compile::current(), result, (Node*) this, idx, true, &amp;old_space, &amp;new_space );
1589   return result;
1590 }
1591 #endif
1592 
1593 
1594 
1595 #ifndef PRODUCT
1596 
1597 // -----------------------------Name-------------------------------------------
1598 extern const char *NodeClassNames[];
1599 const char *Node::Name() const { return NodeClassNames[Opcode()]; }
1600 
1601 static bool is_disconnected(const Node* n) {
1602   for (uint i = 0; i &lt; n-&gt;req(); i++) {
1603     if (n-&gt;in(i) != NULL)  return false;
1604   }
1605   return true;
1606 }
1607 
1608 #ifdef ASSERT
1609 static void dump_orig(Node* orig, outputStream *st) {
1610   Compile* C = Compile::current();
1611   if (NotANode(orig)) orig = NULL;
1612   if (orig != NULL &amp;&amp; !C-&gt;node_arena()-&gt;contains(orig)) orig = NULL;
1613   if (orig == NULL) return;
1614   st-&gt;print(&quot; !orig=&quot;);
1615   Node* fast = orig-&gt;debug_orig(); // tortoise &amp; hare algorithm to detect loops
1616   if (NotANode(fast)) fast = NULL;
1617   while (orig != NULL) {
1618     bool discon = is_disconnected(orig);  // if discon, print [123] else 123
1619     if (discon) st-&gt;print(&quot;[&quot;);
1620     if (!Compile::current()-&gt;node_arena()-&gt;contains(orig))
1621       st-&gt;print(&quot;o&quot;);
1622     st-&gt;print(&quot;%d&quot;, orig-&gt;_idx);
1623     if (discon) st-&gt;print(&quot;]&quot;);
1624     orig = orig-&gt;debug_orig();
1625     if (NotANode(orig)) orig = NULL;
1626     if (orig != NULL &amp;&amp; !C-&gt;node_arena()-&gt;contains(orig)) orig = NULL;
1627     if (orig != NULL) st-&gt;print(&quot;,&quot;);
1628     if (fast != NULL) {
1629       // Step fast twice for each single step of orig:
1630       fast = fast-&gt;debug_orig();
1631       if (NotANode(fast)) fast = NULL;
1632       if (fast != NULL &amp;&amp; fast != orig) {
1633         fast = fast-&gt;debug_orig();
1634         if (NotANode(fast)) fast = NULL;
1635       }
1636       if (fast == orig) {
1637         st-&gt;print(&quot;...&quot;);
1638         break;
1639       }
1640     }
1641   }
1642 }
1643 
1644 void Node::set_debug_orig(Node* orig) {
1645   _debug_orig = orig;
1646   if (BreakAtNode == 0)  return;
1647   if (NotANode(orig))  orig = NULL;
1648   int trip = 10;
1649   while (orig != NULL) {
1650     if (orig-&gt;debug_idx() == BreakAtNode || (int)orig-&gt;_idx == BreakAtNode) {
1651       tty-&gt;print_cr(&quot;BreakAtNode: _idx=%d _debug_idx=%d orig._idx=%d orig._debug_idx=%d&quot;,
1652                     this-&gt;_idx, this-&gt;debug_idx(), orig-&gt;_idx, orig-&gt;debug_idx());
1653       BREAKPOINT;
1654     }
1655     orig = orig-&gt;debug_orig();
1656     if (NotANode(orig))  orig = NULL;
1657     if (trip-- &lt;= 0)  break;
1658   }
1659 }
1660 #endif //ASSERT
1661 
1662 //------------------------------dump------------------------------------------
1663 // Dump a Node
1664 void Node::dump(const char* suffix, bool mark, outputStream *st) const {
1665   Compile* C = Compile::current();
1666   bool is_new = C-&gt;node_arena()-&gt;contains(this);
1667   C-&gt;_in_dump_cnt++;
1668   st-&gt;print(&quot;%c%d%s\t%s\t=== &quot;, is_new ? &#39; &#39; : &#39;o&#39;, _idx, mark ? &quot; &gt;&quot; : &quot;&quot;, Name());
1669 
1670   // Dump the required and precedence inputs
1671   dump_req(st);
1672   dump_prec(st);
1673   // Dump the outputs
1674   dump_out(st);
1675 
1676   if (is_disconnected(this)) {
1677 #ifdef ASSERT
1678     st-&gt;print(&quot;  [%d]&quot;,debug_idx());
1679     dump_orig(debug_orig(), st);
1680 #endif
1681     st-&gt;cr();
1682     C-&gt;_in_dump_cnt--;
1683     return;                     // don&#39;t process dead nodes
1684   }
1685 
1686   if (C-&gt;clone_map().value(_idx) != 0) {
1687     C-&gt;clone_map().dump(_idx);
1688   }
1689   // Dump node-specific info
1690   dump_spec(st);
1691 #ifdef ASSERT
1692   // Dump the non-reset _debug_idx
1693   if (Verbose &amp;&amp; WizardMode) {
1694     st-&gt;print(&quot;  [%d]&quot;,debug_idx());
1695   }
1696 #endif
1697 
1698   const Type *t = bottom_type();
1699 
1700   if (t != NULL &amp;&amp; (t-&gt;isa_instptr() || t-&gt;isa_klassptr())) {
1701     const TypeInstPtr  *toop = t-&gt;isa_instptr();
1702     const TypeKlassPtr *tkls = t-&gt;isa_klassptr();
1703     ciKlass*           klass = toop ? toop-&gt;klass() : (tkls ? tkls-&gt;klass() : NULL );
1704     if (klass &amp;&amp; klass-&gt;is_loaded() &amp;&amp; klass-&gt;is_interface()) {
1705       st-&gt;print(&quot;  Interface:&quot;);
1706     } else if (toop) {
1707       st-&gt;print(&quot;  Oop:&quot;);
1708     } else if (tkls) {
1709       st-&gt;print(&quot;  Klass:&quot;);
1710     }
1711     t-&gt;dump_on(st);
1712   } else if (t == Type::MEMORY) {
1713     st-&gt;print(&quot;  Memory:&quot;);
1714     MemNode::dump_adr_type(this, adr_type(), st);
1715   } else if (Verbose || WizardMode) {
1716     st-&gt;print(&quot;  Type:&quot;);
1717     if (t) {
1718       t-&gt;dump_on(st);
1719     } else {
1720       st-&gt;print(&quot;no type&quot;);
1721     }
1722   } else if (t-&gt;isa_vect() &amp;&amp; this-&gt;is_MachSpillCopy()) {
1723     // Dump MachSpillcopy vector type.
1724     t-&gt;dump_on(st);
1725   }
1726   if (is_new) {
1727     debug_only(dump_orig(debug_orig(), st));
1728     Node_Notes* nn = C-&gt;node_notes_at(_idx);
1729     if (nn != NULL &amp;&amp; !nn-&gt;is_clear()) {
1730       if (nn-&gt;jvms() != NULL) {
1731         st-&gt;print(&quot; !jvms:&quot;);
1732         nn-&gt;jvms()-&gt;dump_spec(st);
1733       }
1734     }
1735   }
1736   if (suffix) st-&gt;print(&quot;%s&quot;, suffix);
1737   C-&gt;_in_dump_cnt--;
1738 }
1739 
1740 //------------------------------dump_req--------------------------------------
1741 void Node::dump_req(outputStream *st) const {
1742   // Dump the required input edges
1743   for (uint i = 0; i &lt; req(); i++) {    // For all required inputs
1744     Node* d = in(i);
1745     if (d == NULL) {
1746       st-&gt;print(&quot;_ &quot;);
1747     } else if (NotANode(d)) {
1748       st-&gt;print(&quot;NotANode &quot;);  // uninitialized, sentinel, garbage, etc.
1749     } else {
1750       st-&gt;print(&quot;%c%d &quot;, Compile::current()-&gt;node_arena()-&gt;contains(d) ? &#39; &#39; : &#39;o&#39;, d-&gt;_idx);
1751     }
1752   }
1753 }
1754 
1755 
1756 //------------------------------dump_prec-------------------------------------
1757 void Node::dump_prec(outputStream *st) const {
1758   // Dump the precedence edges
1759   int any_prec = 0;
1760   for (uint i = req(); i &lt; len(); i++) {       // For all precedence inputs
1761     Node* p = in(i);
1762     if (p != NULL) {
1763       if (!any_prec++) st-&gt;print(&quot; |&quot;);
1764       if (NotANode(p)) { st-&gt;print(&quot;NotANode &quot;); continue; }
1765       st-&gt;print(&quot;%c%d &quot;, Compile::current()-&gt;node_arena()-&gt;contains(in(i)) ? &#39; &#39; : &#39;o&#39;, in(i)-&gt;_idx);
1766     }
1767   }
1768 }
1769 
1770 //------------------------------dump_out--------------------------------------
1771 void Node::dump_out(outputStream *st) const {
1772   // Delimit the output edges
1773   st-&gt;print(&quot; [[&quot;);
1774   // Dump the output edges
1775   for (uint i = 0; i &lt; _outcnt; i++) {    // For all outputs
1776     Node* u = _out[i];
1777     if (u == NULL) {
1778       st-&gt;print(&quot;_ &quot;);
1779     } else if (NotANode(u)) {
1780       st-&gt;print(&quot;NotANode &quot;);
1781     } else {
1782       st-&gt;print(&quot;%c%d &quot;, Compile::current()-&gt;node_arena()-&gt;contains(u) ? &#39; &#39; : &#39;o&#39;, u-&gt;_idx);
1783     }
1784   }
1785   st-&gt;print(&quot;]] &quot;);
1786 }
1787 
1788 //----------------------------collect_nodes_i----------------------------------
1789 // Collects nodes from an Ideal graph, starting from a given start node and
1790 // moving in a given direction until a certain depth (distance from the start
1791 // node) is reached. Duplicates are ignored.
1792 // Arguments:
1793 //   nstack:        the nodes are collected into this array.
1794 //   start:         the node at which to start collecting.
1795 //   direction:     if this is a positive number, collect input nodes; if it is
1796 //                  a negative number, collect output nodes.
1797 //   depth:         collect nodes up to this distance from the start node.
1798 //   include_start: whether to include the start node in the result collection.
1799 //   only_ctrl:     whether to regard control edges only during traversal.
1800 //   only_data:     whether to regard data edges only during traversal.
1801 static void collect_nodes_i(GrowableArray&lt;Node*&gt; *nstack, const Node* start, int direction, uint depth, bool include_start, bool only_ctrl, bool only_data) {
1802   Node* s = (Node*) start; // remove const
1803   nstack-&gt;append(s);
1804   int begin = 0;
1805   int end = 0;
1806   for(uint i = 0; i &lt; depth; i++) {
1807     end = nstack-&gt;length();
1808     for(int j = begin; j &lt; end; j++) {
1809       Node* tp  = nstack-&gt;at(j);
1810       uint limit = direction &gt; 0 ? tp-&gt;len() : tp-&gt;outcnt();
1811       for(uint k = 0; k &lt; limit; k++) {
1812         Node* n = direction &gt; 0 ? tp-&gt;in(k) : tp-&gt;raw_out(k);
1813 
1814         if (NotANode(n))  continue;
1815         // do not recurse through top or the root (would reach unrelated stuff)
1816         if (n-&gt;is_Root() || n-&gt;is_top()) continue;
1817         if (only_ctrl &amp;&amp; !n-&gt;is_CFG()) continue;
1818         if (only_data &amp;&amp; n-&gt;is_CFG()) continue;
1819 
1820         bool on_stack = nstack-&gt;contains(n);
1821         if (!on_stack) {
1822           nstack-&gt;append(n);
1823         }
1824       }
1825     }
1826     begin = end;
1827   }
1828   if (!include_start) {
1829     nstack-&gt;remove(s);
1830   }
1831 }
1832 
1833 //------------------------------dump_nodes-------------------------------------
1834 static void dump_nodes(const Node* start, int d, bool only_ctrl) {
1835   if (NotANode(start)) return;
1836 
1837   GrowableArray &lt;Node *&gt; nstack(Compile::current()-&gt;live_nodes());
1838   collect_nodes_i(&amp;nstack, start, d, (uint) ABS(d), true, only_ctrl, false);
1839 
1840   int end = nstack.length();
1841   if (d &gt; 0) {
1842     for(int j = end-1; j &gt;= 0; j--) {
1843       nstack.at(j)-&gt;dump();
1844     }
1845   } else {
1846     for(int j = 0; j &lt; end; j++) {
1847       nstack.at(j)-&gt;dump();
1848     }
1849   }
1850 }
1851 
1852 //------------------------------dump-------------------------------------------
1853 void Node::dump(int d) const {
1854   dump_nodes(this, d, false);
1855 }
1856 
1857 //------------------------------dump_ctrl--------------------------------------
1858 // Dump a Node&#39;s control history to depth
1859 void Node::dump_ctrl(int d) const {
1860   dump_nodes(this, d, true);
1861 }
1862 
1863 //-----------------------------dump_compact------------------------------------
1864 void Node::dump_comp() const {
1865   this-&gt;dump_comp(&quot;\n&quot;);
1866 }
1867 
1868 //-----------------------------dump_compact------------------------------------
1869 // Dump a Node in compact representation, i.e., just print its name and index.
1870 // Nodes can specify additional specifics to print in compact representation by
1871 // implementing dump_compact_spec.
1872 void Node::dump_comp(const char* suffix, outputStream *st) const {
1873   Compile* C = Compile::current();
1874   C-&gt;_in_dump_cnt++;
1875   st-&gt;print(&quot;%s(%d)&quot;, Name(), _idx);
1876   this-&gt;dump_compact_spec(st);
1877   if (suffix) {
1878     st-&gt;print(&quot;%s&quot;, suffix);
1879   }
1880   C-&gt;_in_dump_cnt--;
1881 }
1882 
1883 //----------------------------dump_related-------------------------------------
1884 // Dump a Node&#39;s related nodes - the notion of &quot;related&quot; depends on the Node at
1885 // hand and is determined by the implementation of the virtual method rel.
1886 void Node::dump_related() const {
1887   Compile* C = Compile::current();
1888   GrowableArray &lt;Node *&gt; in_rel(C-&gt;unique());
1889   GrowableArray &lt;Node *&gt; out_rel(C-&gt;unique());
1890   this-&gt;related(&amp;in_rel, &amp;out_rel, false);
1891   for (int i = in_rel.length() - 1; i &gt;= 0; i--) {
1892     in_rel.at(i)-&gt;dump();
1893   }
1894   this-&gt;dump(&quot;\n&quot;, true);
1895   for (int i = 0; i &lt; out_rel.length(); i++) {
1896     out_rel.at(i)-&gt;dump();
1897   }
1898 }
1899 
1900 //----------------------------dump_related-------------------------------------
1901 // Dump a Node&#39;s related nodes up to a given depth (distance from the start
1902 // node).
1903 // Arguments:
1904 //   d_in:  depth for input nodes.
1905 //   d_out: depth for output nodes (note: this also is a positive number).
1906 void Node::dump_related(uint d_in, uint d_out) const {
1907   Compile* C = Compile::current();
1908   GrowableArray &lt;Node *&gt; in_rel(C-&gt;unique());
1909   GrowableArray &lt;Node *&gt; out_rel(C-&gt;unique());
1910 
1911   // call collect_nodes_i directly
1912   collect_nodes_i(&amp;in_rel, this, 1, d_in, false, false, false);
1913   collect_nodes_i(&amp;out_rel, this, -1, d_out, false, false, false);
1914 
1915   for (int i = in_rel.length() - 1; i &gt;= 0; i--) {
1916     in_rel.at(i)-&gt;dump();
1917   }
1918   this-&gt;dump(&quot;\n&quot;, true);
1919   for (int i = 0; i &lt; out_rel.length(); i++) {
1920     out_rel.at(i)-&gt;dump();
1921   }
1922 }
1923 
1924 //------------------------dump_related_compact---------------------------------
1925 // Dump a Node&#39;s related nodes in compact representation. The notion of
1926 // &quot;related&quot; depends on the Node at hand and is determined by the implementation
1927 // of the virtual method rel.
1928 void Node::dump_related_compact() const {
1929   Compile* C = Compile::current();
1930   GrowableArray &lt;Node *&gt; in_rel(C-&gt;unique());
1931   GrowableArray &lt;Node *&gt; out_rel(C-&gt;unique());
1932   this-&gt;related(&amp;in_rel, &amp;out_rel, true);
1933   int n_in = in_rel.length();
1934   int n_out = out_rel.length();
1935 
1936   this-&gt;dump_comp(n_in == 0 ? &quot;\n&quot; : &quot;  &quot;);
1937   for (int i = 0; i &lt; n_in; i++) {
1938     in_rel.at(i)-&gt;dump_comp(i == n_in - 1 ? &quot;\n&quot; : &quot;  &quot;);
1939   }
1940   for (int i = 0; i &lt; n_out; i++) {
1941     out_rel.at(i)-&gt;dump_comp(i == n_out - 1 ? &quot;\n&quot; : &quot;  &quot;);
1942   }
1943 }
1944 
1945 //------------------------------related----------------------------------------
1946 // Collect a Node&#39;s related nodes. The default behaviour just collects the
1947 // inputs and outputs at depth 1, including both control and data flow edges,
1948 // regardless of whether the presentation is compact or not. For data nodes,
1949 // the default is to collect all data inputs (till level 1 if compact), and
1950 // outputs till level 1.
1951 void Node::related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const {
1952   if (this-&gt;is_CFG()) {
1953     collect_nodes_i(in_rel, this, 1, 1, false, false, false);
1954     collect_nodes_i(out_rel, this, -1, 1, false, false, false);
1955   } else {
1956     if (compact) {
1957       this-&gt;collect_nodes(in_rel, 1, false, true);
1958     } else {
1959       this-&gt;collect_nodes_in_all_data(in_rel, false);
1960     }
1961     this-&gt;collect_nodes(out_rel, -1, false, false);
1962   }
1963 }
1964 
1965 //---------------------------collect_nodes-------------------------------------
1966 // An entry point to the low-level node collection facility, to start from a
1967 // given node in the graph. The start node is by default not included in the
1968 // result.
1969 // Arguments:
1970 //   ns:   collect the nodes into this data structure.
1971 //   d:    the depth (distance from start node) to which nodes should be
1972 //         collected. A value &gt;0 indicates input nodes, a value &lt;0, output
1973 //         nodes.
1974 //   ctrl: include only control nodes.
1975 //   data: include only data nodes.
1976 void Node::collect_nodes(GrowableArray&lt;Node*&gt; *ns, int d, bool ctrl, bool data) const {
1977   if (ctrl &amp;&amp; data) {
1978     // ignore nonsensical combination
1979     return;
1980   }
1981   collect_nodes_i(ns, this, d, (uint) ABS(d), false, ctrl, data);
1982 }
1983 
1984 //--------------------------collect_nodes_in-----------------------------------
1985 static void collect_nodes_in(Node* start, GrowableArray&lt;Node*&gt; *ns, bool primary_is_data, bool collect_secondary) {
1986   // The maximum depth is determined using a BFS that visits all primary (data
1987   // or control) inputs and increments the depth at each level.
1988   uint d_in = 0;
1989   GrowableArray&lt;Node*&gt; nodes(Compile::current()-&gt;unique());
1990   nodes.push(start);
1991   int nodes_at_current_level = 1;
1992   int n_idx = 0;
1993   while (nodes_at_current_level &gt; 0) {
1994     // Add all primary inputs reachable from the current level to the list, and
1995     // increase the depth if there were any.
1996     int nodes_at_next_level = 0;
1997     bool nodes_added = false;
1998     while (nodes_at_current_level &gt; 0) {
1999       nodes_at_current_level--;
2000       Node* current = nodes.at(n_idx++);
2001       for (uint i = 0; i &lt; current-&gt;len(); i++) {
2002         Node* n = current-&gt;in(i);
2003         if (NotANode(n)) {
2004           continue;
2005         }
2006         if ((primary_is_data &amp;&amp; n-&gt;is_CFG()) || (!primary_is_data &amp;&amp; !n-&gt;is_CFG())) {
2007           continue;
2008         }
2009         if (!nodes.contains(n)) {
2010           nodes.push(n);
2011           nodes_added = true;
2012           nodes_at_next_level++;
2013         }
2014       }
2015     }
2016     if (nodes_added) {
2017       d_in++;
2018     }
2019     nodes_at_current_level = nodes_at_next_level;
2020   }
2021   start-&gt;collect_nodes(ns, d_in, !primary_is_data, primary_is_data);
2022   if (collect_secondary) {
2023     // Now, iterate over the secondary nodes in ns and add the respective
2024     // boundary reachable from them.
2025     GrowableArray&lt;Node*&gt; sns(Compile::current()-&gt;unique());
2026     for (GrowableArrayIterator&lt;Node*&gt; it = ns-&gt;begin(); it != ns-&gt;end(); ++it) {
2027       Node* n = *it;
2028       n-&gt;collect_nodes(&amp;sns, 1, primary_is_data, !primary_is_data);
2029       for (GrowableArrayIterator&lt;Node*&gt; d = sns.begin(); d != sns.end(); ++d) {
2030         ns-&gt;append_if_missing(*d);
2031       }
2032       sns.clear();
2033     }
2034   }
2035 }
2036 
2037 //---------------------collect_nodes_in_all_data-------------------------------
2038 // Collect the entire data input graph. Include the control boundary if
2039 // requested.
2040 // Arguments:
2041 //   ns:   collect the nodes into this data structure.
2042 //   ctrl: if true, include the control boundary.
2043 void Node::collect_nodes_in_all_data(GrowableArray&lt;Node*&gt; *ns, bool ctrl) const {
2044   collect_nodes_in((Node*) this, ns, true, ctrl);
2045 }
2046 
2047 //--------------------------collect_nodes_in_all_ctrl--------------------------
2048 // Collect the entire control input graph. Include the data boundary if
2049 // requested.
2050 //   ns:   collect the nodes into this data structure.
2051 //   data: if true, include the control boundary.
2052 void Node::collect_nodes_in_all_ctrl(GrowableArray&lt;Node*&gt; *ns, bool data) const {
2053   collect_nodes_in((Node*) this, ns, false, data);
2054 }
2055 
2056 //------------------collect_nodes_out_all_ctrl_boundary------------------------
2057 // Collect the entire output graph until hitting control node boundaries, and
2058 // include those.
2059 void Node::collect_nodes_out_all_ctrl_boundary(GrowableArray&lt;Node*&gt; *ns) const {
2060   // Perform a BFS and stop at control nodes.
2061   GrowableArray&lt;Node*&gt; nodes(Compile::current()-&gt;unique());
2062   nodes.push((Node*) this);
2063   while (nodes.length() &gt; 0) {
2064     Node* current = nodes.pop();
2065     if (NotANode(current)) {
2066       continue;
2067     }
2068     ns-&gt;append_if_missing(current);
2069     if (!current-&gt;is_CFG()) {
2070       for (DUIterator i = current-&gt;outs(); current-&gt;has_out(i); i++) {
2071         nodes.push(current-&gt;out(i));
2072       }
2073     }
2074   }
2075   ns-&gt;remove((Node*) this);
2076 }
2077 
2078 // VERIFICATION CODE
2079 // For each input edge to a node (ie - for each Use-Def edge), verify that
2080 // there is a corresponding Def-Use edge.
2081 //------------------------------verify_edges-----------------------------------
2082 void Node::verify_edges(Unique_Node_List &amp;visited) {
2083   uint i, j, idx;
2084   int  cnt;
2085   Node *n;
2086 
2087   // Recursive termination test
2088   if (visited.member(this))  return;
2089   visited.push(this);
2090 
2091   // Walk over all input edges, checking for correspondence
2092   for( i = 0; i &lt; len(); i++ ) {
2093     n = in(i);
2094     if (n != NULL &amp;&amp; !n-&gt;is_top()) {
2095       // Count instances of (Node *)this
2096       cnt = 0;
2097       for (idx = 0; idx &lt; n-&gt;_outcnt; idx++ ) {
2098         if (n-&gt;_out[idx] == (Node *)this)  cnt++;
2099       }
2100       assert( cnt &gt; 0,&quot;Failed to find Def-Use edge.&quot; );
2101       // Check for duplicate edges
2102       // walk the input array downcounting the input edges to n
2103       for( j = 0; j &lt; len(); j++ ) {
2104         if( in(j) == n ) cnt--;
2105       }
2106       assert( cnt == 0,&quot;Mismatched edge count.&quot;);
2107     } else if (n == NULL) {
<a name="20" id="anc20"></a><span class="line-modified">2108       assert(i &gt;= req() || i == 0 || is_Region() || is_Phi(), &quot;only regions or phis have null data edges&quot;);</span>

2109     } else {
2110       assert(n-&gt;is_top(), &quot;sanity&quot;);
2111       // Nothing to check.
2112     }
2113   }
2114   // Recursive walk over all input edges
2115   for( i = 0; i &lt; len(); i++ ) {
2116     n = in(i);
2117     if( n != NULL )
2118       in(i)-&gt;verify_edges(visited);
2119   }
2120 }
2121 
<a name="21" id="anc21"></a><span class="line-removed">2122 //------------------------------verify_recur-----------------------------------</span>
<span class="line-removed">2123 static const Node *unique_top = NULL;</span>
<span class="line-removed">2124 </span>
2125 void Node::verify_recur(const Node *n, int verify_depth,
2126                         VectorSet &amp;old_space, VectorSet &amp;new_space) {
2127   if ( verify_depth == 0 )  return;
2128   if (verify_depth &gt; 0)  --verify_depth;
2129 
2130   Compile* C = Compile::current();
2131 
2132   // Contained in new_space or old_space?
2133   VectorSet *v = C-&gt;node_arena()-&gt;contains(n) ? &amp;new_space : &amp;old_space;
2134   // Check for visited in the proper space.  Numberings are not unique
2135   // across spaces so we need a separate VectorSet for each space.
2136   if( v-&gt;test_set(n-&gt;_idx) ) return;
2137 
2138   if (n-&gt;is_Con() &amp;&amp; n-&gt;bottom_type() == Type::TOP) {
2139     if (C-&gt;cached_top_node() == NULL)
2140       C-&gt;set_cached_top_node((Node*)n);
2141     assert(C-&gt;cached_top_node() == n, &quot;TOP node must be unique&quot;);
2142   }
2143 
2144   for( uint i = 0; i &lt; n-&gt;len(); i++ ) {
2145     Node *x = n-&gt;in(i);
2146     if (!x || x-&gt;is_top()) continue;
2147 
2148     // Verify my input has a def-use edge to me
2149     if (true /*VerifyDefUse*/) {
2150       // Count use-def edges from n to x
2151       int cnt = 0;
2152       for( uint j = 0; j &lt; n-&gt;len(); j++ )
2153         if( n-&gt;in(j) == x )
2154           cnt++;
2155       // Count def-use edges from x to n
2156       uint max = x-&gt;_outcnt;
2157       for( uint k = 0; k &lt; max; k++ )
2158         if (x-&gt;_out[k] == n)
2159           cnt--;
2160       assert( cnt == 0, &quot;mismatched def-use edge counts&quot; );
2161     }
2162 
2163     verify_recur(x, verify_depth, old_space, new_space);
2164   }
2165 
2166 }
2167 
2168 //------------------------------verify-----------------------------------------
2169 // Check Def-Use info for my subgraph
2170 void Node::verify() const {
2171   Compile* C = Compile::current();
2172   Node* old_top = C-&gt;cached_top_node();
2173   ResourceMark rm;
2174   ResourceArea *area = Thread::current()-&gt;resource_area();
2175   VectorSet old_space(area), new_space(area);
2176   verify_recur(this, -1, old_space, new_space);
2177   C-&gt;set_cached_top_node(old_top);
2178 }
2179 #endif
2180 
2181 
2182 //------------------------------walk-------------------------------------------
2183 // Graph walk, with both pre-order and post-order functions
2184 void Node::walk(NFunc pre, NFunc post, void *env) {
2185   VectorSet visited(Thread::current()-&gt;resource_area()); // Setup for local walk
2186   walk_(pre, post, env, visited);
2187 }
2188 
2189 void Node::walk_(NFunc pre, NFunc post, void *env, VectorSet &amp;visited) {
2190   if( visited.test_set(_idx) ) return;
2191   pre(*this,env);               // Call the pre-order walk function
2192   for( uint i=0; i&lt;_max; i++ )
2193     if( in(i) )                 // Input exists and is not walked?
2194       in(i)-&gt;walk_(pre,post,env,visited); // Walk it with pre &amp; post functions
2195   post(*this,env);              // Call the post-order walk function
2196 }
2197 
2198 void Node::nop(Node &amp;, void*) {}
2199 
2200 //------------------------------Registers--------------------------------------
2201 // Do we Match on this edge index or not?  Generally false for Control
2202 // and true for everything else.  Weird for calls &amp; returns.
2203 uint Node::match_edge(uint idx) const {
2204   return idx;                   // True for other than index 0 (control)
2205 }
2206 
2207 static RegMask _not_used_at_all;
2208 // Register classes are defined for specific machines
2209 const RegMask &amp;Node::out_RegMask() const {
2210   ShouldNotCallThis();
2211   return _not_used_at_all;
2212 }
2213 
2214 const RegMask &amp;Node::in_RegMask(uint) const {
2215   ShouldNotCallThis();
2216   return _not_used_at_all;
2217 }
2218 
2219 //=============================================================================
2220 //-----------------------------------------------------------------------------
2221 void Node_Array::reset( Arena *new_arena ) {
2222   _a-&gt;Afree(_nodes,_max*sizeof(Node*));
2223   _max   = 0;
2224   _nodes = NULL;
2225   _a     = new_arena;
2226 }
2227 
2228 //------------------------------clear------------------------------------------
2229 // Clear all entries in _nodes to NULL but keep storage
2230 void Node_Array::clear() {
2231   Copy::zero_to_bytes( _nodes, _max*sizeof(Node*) );
2232 }
2233 
2234 //-----------------------------------------------------------------------------
2235 void Node_Array::grow( uint i ) {
2236   if( !_max ) {
2237     _max = 1;
2238     _nodes = (Node**)_a-&gt;Amalloc( _max * sizeof(Node*) );
2239     _nodes[0] = NULL;
2240   }
2241   uint old = _max;
<a name="22" id="anc22"></a><span class="line-modified">2242   while( i &gt;= _max ) _max &lt;&lt;= 1;        // Double to fit</span>
2243   _nodes = (Node**)_a-&gt;Arealloc( _nodes, old*sizeof(Node*),_max*sizeof(Node*));
2244   Copy::zero_to_bytes( &amp;_nodes[old], (_max-old)*sizeof(Node*) );
2245 }
2246 
2247 //-----------------------------------------------------------------------------
2248 void Node_Array::insert( uint i, Node *n ) {
2249   if( _nodes[_max-1] ) grow(_max);      // Get more space if full
2250   Copy::conjoint_words_to_higher((HeapWord*)&amp;_nodes[i], (HeapWord*)&amp;_nodes[i+1], ((_max-i-1)*sizeof(Node*)));
2251   _nodes[i] = n;
2252 }
2253 
2254 //-----------------------------------------------------------------------------
2255 void Node_Array::remove( uint i ) {
2256   Copy::conjoint_words_to_lower((HeapWord*)&amp;_nodes[i+1], (HeapWord*)&amp;_nodes[i], ((_max-i-1)*sizeof(Node*)));
2257   _nodes[_max-1] = NULL;
2258 }
2259 
2260 //-----------------------------------------------------------------------------
2261 void Node_Array::sort( C_sort_func_t func) {
2262   qsort( _nodes, _max, sizeof( Node* ), func );
2263 }
2264 
2265 //-----------------------------------------------------------------------------
2266 void Node_Array::dump() const {
2267 #ifndef PRODUCT
2268   for( uint i = 0; i &lt; _max; i++ ) {
2269     Node *nn = _nodes[i];
2270     if( nn != NULL ) {
2271       tty-&gt;print(&quot;%5d--&gt; &quot;,i); nn-&gt;dump();
2272     }
2273   }
2274 #endif
2275 }
2276 
2277 //--------------------------is_iteratively_computed------------------------------
2278 // Operation appears to be iteratively computed (such as an induction variable)
2279 // It is possible for this operation to return false for a loop-varying
2280 // value, if it appears (by local graph inspection) to be computed by a simple conditional.
2281 bool Node::is_iteratively_computed() {
2282   if (ideal_reg()) { // does operation have a result register?
2283     for (uint i = 1; i &lt; req(); i++) {
2284       Node* n = in(i);
2285       if (n != NULL &amp;&amp; n-&gt;is_Phi()) {
2286         for (uint j = 1; j &lt; n-&gt;req(); j++) {
2287           if (n-&gt;in(j) == this) {
2288             return true;
2289           }
2290         }
2291       }
2292     }
2293   }
2294   return false;
2295 }
2296 
2297 //--------------------------find_similar------------------------------
2298 // Return a node with opcode &quot;opc&quot; and same inputs as &quot;this&quot; if one can
2299 // be found; Otherwise return NULL;
2300 Node* Node::find_similar(int opc) {
2301   if (req() &gt;= 2) {
2302     Node* def = in(1);
2303     if (def &amp;&amp; def-&gt;outcnt() &gt;= 2) {
2304       for (DUIterator_Fast dmax, i = def-&gt;fast_outs(dmax); i &lt; dmax; i++) {
2305         Node* use = def-&gt;fast_out(i);
2306         if (use != this &amp;&amp;
2307             use-&gt;Opcode() == opc &amp;&amp;
2308             use-&gt;req() == req()) {
2309           uint j;
2310           for (j = 0; j &lt; use-&gt;req(); j++) {
2311             if (use-&gt;in(j) != in(j)) {
2312               break;
2313             }
2314           }
2315           if (j == use-&gt;req()) {
2316             return use;
2317           }
2318         }
2319       }
2320     }
2321   }
2322   return NULL;
2323 }
2324 
2325 
2326 //--------------------------unique_ctrl_out------------------------------
2327 // Return the unique control out if only one. Null if none or more than one.
2328 Node* Node::unique_ctrl_out() const {
2329   Node* found = NULL;
2330   for (uint i = 0; i &lt; outcnt(); i++) {
2331     Node* use = raw_out(i);
2332     if (use-&gt;is_CFG() &amp;&amp; use != this) {
2333       if (found != NULL) return NULL;
2334       found = use;
2335     }
2336   }
2337   return found;
2338 }
2339 
2340 void Node::ensure_control_or_add_prec(Node* c) {
2341   if (in(0) == NULL) {
2342     set_req(0, c);
2343   } else if (in(0) != c) {
2344     add_prec(c);
2345   }
2346 }
2347 
2348 //=============================================================================
2349 //------------------------------yank-------------------------------------------
2350 // Find and remove
2351 void Node_List::yank( Node *n ) {
2352   uint i;
2353   for( i = 0; i &lt; _cnt; i++ )
2354     if( _nodes[i] == n )
2355       break;
2356 
2357   if( i &lt; _cnt )
2358     _nodes[i] = _nodes[--_cnt];
2359 }
2360 
2361 //------------------------------dump-------------------------------------------
2362 void Node_List::dump() const {
2363 #ifndef PRODUCT
2364   for( uint i = 0; i &lt; _cnt; i++ )
2365     if( _nodes[i] ) {
2366       tty-&gt;print(&quot;%5d--&gt; &quot;,i);
2367       _nodes[i]-&gt;dump();
2368     }
2369 #endif
2370 }
2371 
2372 void Node_List::dump_simple() const {
2373 #ifndef PRODUCT
2374   for( uint i = 0; i &lt; _cnt; i++ )
2375     if( _nodes[i] ) {
2376       tty-&gt;print(&quot; %d&quot;, _nodes[i]-&gt;_idx);
2377     } else {
2378       tty-&gt;print(&quot; NULL&quot;);
2379     }
2380 #endif
2381 }
2382 
2383 //=============================================================================
2384 //------------------------------remove-----------------------------------------
<a name="23" id="anc23"></a><span class="line-modified">2385 void Unique_Node_List::remove( Node *n ) {</span>
<span class="line-modified">2386   if( _in_worklist[n-&gt;_idx] ) {</span>
<span class="line-modified">2387     for( uint i = 0; i &lt; size(); i++ )</span>
<span class="line-modified">2388       if( _nodes[i] == n ) {</span>
<span class="line-modified">2389         map(i,Node_List::pop());</span>
<span class="line-modified">2390         _in_worklist &gt;&gt;= n-&gt;_idx;</span>
2391         return;
2392       }
<a name="24" id="anc24"></a>
2393     ShouldNotReachHere();
2394   }
2395 }
2396 
2397 //-----------------------remove_useless_nodes----------------------------------
2398 // Remove useless nodes from worklist
2399 void Unique_Node_List::remove_useless_nodes(VectorSet &amp;useful) {
2400 
<a name="25" id="anc25"></a><span class="line-modified">2401   for( uint i = 0; i &lt; size(); ++i ) {</span>
2402     Node *n = at(i);
2403     assert( n != NULL, &quot;Did not expect null entries in worklist&quot;);
<a name="26" id="anc26"></a><span class="line-modified">2404     if( ! useful.test(n-&gt;_idx) ) {</span>
<span class="line-modified">2405       _in_worklist &gt;&gt;= n-&gt;_idx;</span>
2406       map(i,Node_List::pop());
2407       // Node *replacement = Node_List::pop();
2408       // if( i != size() ) { // Check if removing last entry
2409       //   _nodes[i] = replacement;
2410       // }
2411       --i;  // Visit popped node
2412       // If it was last entry, loop terminates since size() was also reduced
2413     }
2414   }
2415 }
2416 
2417 //=============================================================================
2418 void Node_Stack::grow() {
2419   size_t old_top = pointer_delta(_inode_top,_inodes,sizeof(INode)); // save _top
2420   size_t old_max = pointer_delta(_inode_max,_inodes,sizeof(INode));
2421   size_t max = old_max &lt;&lt; 1;             // max * 2
2422   _inodes = REALLOC_ARENA_ARRAY(_a, INode, _inodes, old_max, max);
2423   _inode_max = _inodes + max;
2424   _inode_top = _inodes + old_top;        // restore _top
2425 }
2426 
2427 // Node_Stack is used to map nodes.
2428 Node* Node_Stack::find(uint idx) const {
2429   uint sz = size();
2430   for (uint i=0; i &lt; sz; i++) {
2431     if (idx == index_at(i) )
2432       return node_at(i);
2433   }
2434   return NULL;
2435 }
2436 
2437 //=============================================================================
2438 uint TypeNode::size_of() const { return sizeof(*this); }
2439 #ifndef PRODUCT
2440 void TypeNode::dump_spec(outputStream *st) const {
2441   if( !Verbose &amp;&amp; !WizardMode ) {
2442     // standard dump does this in Verbose and WizardMode
2443     st-&gt;print(&quot; #&quot;); _type-&gt;dump_on(st);
2444   }
2445 }
2446 
2447 void TypeNode::dump_compact_spec(outputStream *st) const {
2448   st-&gt;print(&quot;#&quot;);
2449   _type-&gt;dump_on(st);
2450 }
2451 #endif
2452 uint TypeNode::hash() const {
2453   return Node::hash() + _type-&gt;hash();
2454 }
<a name="27" id="anc27"></a><span class="line-modified">2455 uint TypeNode::cmp( const Node &amp;n ) const</span>
2456 { return !Type::cmp( _type, ((TypeNode&amp;)n)._type ); }
2457 const Type *TypeNode::bottom_type() const { return _type; }
2458 const Type* TypeNode::Value(PhaseGVN* phase) const { return _type; }
2459 
2460 //------------------------------ideal_reg--------------------------------------
2461 uint TypeNode::ideal_reg() const {
2462   return _type-&gt;ideal_reg();
2463 }
<a name="28" id="anc28"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="28" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/escape.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="escape.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="gcm.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/escape.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 331,20 ***</span>
                                 // is still being collected. If false,
                                 // no new nodes will be processed.
  
    bool               _verify;  // verify graph
  
<span class="line-removed">-   JavaObjectNode* phantom_obj; // Unknown object</span>
    JavaObjectNode*    null_obj;
    Node*             _pcmp_neq; // ConI(#CC_GT)
    Node*              _pcmp_eq; // ConI(#CC_EQ)
  
    Compile*           _compile; // Compile object for current compilation
    PhaseIterGVN*         _igvn; // Value numbering
  
    Unique_Node_List ideal_nodes; // Used by CG construction and types splitting.
  
    // Address of an element in _nodes.  Used when the element is to be modified
    PointsToNode* ptnode_adr(int idx) const {
      // There should be no new ideal nodes during ConnectionGraph build,
      // growableArray::at() will throw assert otherwise.
      return _nodes.at(idx);
<span class="line-new-header">--- 331,23 ---</span>
                                 // is still being collected. If false,
                                 // no new nodes will be processed.
  
    bool               _verify;  // verify graph
  
    JavaObjectNode*    null_obj;
    Node*             _pcmp_neq; // ConI(#CC_GT)
    Node*              _pcmp_eq; // ConI(#CC_EQ)
  
    Compile*           _compile; // Compile object for current compilation
    PhaseIterGVN*         _igvn; // Value numbering
  
    Unique_Node_List ideal_nodes; // Used by CG construction and types splitting.
  
<span class="line-added">+ public:</span>
<span class="line-added">+   JavaObjectNode* phantom_obj; // Unknown object</span>
<span class="line-added">+ </span>
<span class="line-added">+ private:</span>
    // Address of an element in _nodes.  Used when the element is to be modified
    PointsToNode* ptnode_adr(int idx) const {
      // There should be no new ideal nodes during ConnectionGraph build,
      // growableArray::at() will throw assert otherwise.
      return _nodes.at(idx);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 363,16 ***</span>
    void process_call_arguments(CallNode *call);
  
    // Add PointsToNode node corresponding to a call
    void add_call_node(CallNode* call);
  
<span class="line-removed">-   // Map ideal node to existing PointsTo node (usually phantom_object).</span>
<span class="line-removed">-   void map_ideal_node(Node *n, PointsToNode* ptn) {</span>
<span class="line-removed">-     assert(ptn != NULL, &quot;only existing PointsTo node&quot;);</span>
<span class="line-removed">-     _nodes.at_put(n-&gt;_idx, ptn);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    // Create PointsToNode node and add it to Connection Graph.
    void add_node_to_connection_graph(Node *n, Unique_Node_List *delayed_worklist);
  
    // Add final simple edges to graph.
    void add_final_edges(Node *n);
<span class="line-new-header">--- 366,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 592,10 ***</span>
<span class="line-new-header">--- 589,16 ---</span>
        assert(ptn != NULL, &quot;node should be registered&quot;);
      }
      add_edge(ptnode_adr(n-&gt;_idx), ptn);
    }
  
<span class="line-added">+   // Map ideal node to existing PointsTo node (usually phantom_object).</span>
<span class="line-added">+   void map_ideal_node(Node *n, PointsToNode* ptn) {</span>
<span class="line-added">+     assert(ptn != NULL, &quot;only existing PointsTo node&quot;);</span>
<span class="line-added">+     _nodes.at_put(n-&gt;_idx, ptn);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    void add_to_congraph_unsafe_access(Node* n, uint opcode, Unique_Node_List* delayed_worklist);
    bool add_final_edges_unsafe_access(Node* n, uint opcode);
  
  #ifndef PRODUCT
    void dump(GrowableArray&lt;PointsToNode*&gt;&amp; ptnodes_worklist);
</pre>
<center><a href="escape.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="gcm.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
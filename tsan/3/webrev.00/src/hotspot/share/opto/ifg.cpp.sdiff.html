<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/ifg.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="idealGraphPrinter.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ifnode.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/ifg.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 63   lrgs(b).invalid_degree();
 64   // Sort a and b, so that a is bigger
 65   assert( !_is_square, &quot;only on triangular&quot; );
 66   if( a &lt; b ) { uint tmp = a; a = b; b = tmp; }
 67   return _adjs[a].insert( b );
 68 }
 69 
 70 // Is there an edge between a and b?
 71 int PhaseIFG::test_edge( uint a, uint b ) const {
 72   // Sort a and b, so that a is larger
 73   assert( !_is_square, &quot;only on triangular&quot; );
 74   if( a &lt; b ) { uint tmp = a; a = b; b = tmp; }
 75   return _adjs[a].member(b);
 76 }
 77 
 78 // Convert triangular matrix to square matrix
 79 void PhaseIFG::SquareUp() {
 80   assert( !_is_square, &quot;only on triangular&quot; );
 81 
 82   // Simple transpose
<span class="line-modified"> 83   for( uint i = 0; i &lt; _maxlrg; i++ ) {</span>
<span class="line-modified"> 84     IndexSetIterator elements(&amp;_adjs[i]);</span>
<span class="line-modified"> 85     uint datum;</span>
<span class="line-modified"> 86     while ((datum = elements.next()) != 0) {</span>
<span class="line-modified"> 87       _adjs[datum].insert( i );</span>


 88     }
 89   }
 90   _is_square = true;
 91 }
 92 
 93 // Compute effective degree in bulk
 94 void PhaseIFG::Compute_Effective_Degree() {
 95   assert( _is_square, &quot;only on square&quot; );
 96 
 97   for( uint i = 0; i &lt; _maxlrg; i++ )
 98     lrgs(i).set_degree(effective_degree(i));
 99 }
100 
101 int PhaseIFG::test_edge_sq( uint a, uint b ) const {
102   assert( _is_square, &quot;only on square&quot; );
103   // Swap, so that &#39;a&#39; has the lesser count.  Then binary search is on
104   // the smaller of a&#39;s list and b&#39;s list.
105   if( neighbor_cnt(a) &gt; neighbor_cnt(b) ) { uint tmp = a; a = b; b = tmp; }
106   //return _adjs[a].unordered_member(b);
107   return _adjs[a].member(b);
108 }
109 
110 // Union edges of B into A
<span class="line-modified">111 void PhaseIFG::Union( uint a, uint b ) {</span>
112   assert( _is_square, &quot;only on square&quot; );
113   IndexSet *A = &amp;_adjs[a];
<span class="line-modified">114   IndexSetIterator b_elements(&amp;_adjs[b]);</span>
<span class="line-modified">115   uint datum;</span>
<span class="line-modified">116   while ((datum = b_elements.next()) != 0) {</span>
<span class="line-modified">117     if(A-&gt;insert(datum)) {</span>
<span class="line-modified">118       _adjs[datum].insert(a);</span>
<span class="line-modified">119       lrgs(a).invalid_degree();</span>
<span class="line-modified">120       lrgs(datum).invalid_degree();</span>


121     }
122   }
123 }
124 
125 // Yank a Node and all connected edges from the IFG.  Return a
126 // list of neighbors (edges) yanked.
127 IndexSet *PhaseIFG::remove_node( uint a ) {
128   assert( _is_square, &quot;only on square&quot; );
129   assert( !_yanked-&gt;test(a), &quot;&quot; );
130   _yanked-&gt;set(a);
131 
132   // I remove the LRG from all neighbors.
<span class="line-removed">133   IndexSetIterator elements(&amp;_adjs[a]);</span>
134   LRG &amp;lrg_a = lrgs(a);
<span class="line-modified">135   uint datum;</span>
<span class="line-modified">136   while ((datum = elements.next()) != 0) {</span>
<span class="line-modified">137     _adjs[datum].remove(a);</span>
<span class="line-modified">138     lrgs(datum).inc_degree( -lrg_a.compute_degree(lrgs(datum)) );</span>




139   }
140   return neighbors(a);
141 }
142 
143 // Re-insert a yanked Node.
<span class="line-modified">144 void PhaseIFG::re_insert( uint a ) {</span>
145   assert( _is_square, &quot;only on square&quot; );
146   assert( _yanked-&gt;test(a), &quot;&quot; );
<span class="line-modified">147   (*_yanked) &gt;&gt;= a;</span>


148 
149   IndexSetIterator elements(&amp;_adjs[a]);
150   uint datum;
151   while ((datum = elements.next()) != 0) {
152     _adjs[datum].insert(a);
153     lrgs(datum).invalid_degree();
154   }
155 }
156 
157 // Compute the degree between 2 live ranges.  If both live ranges are
158 // aligned-adjacent powers-of-2 then we use the MAX size.  If either is
159 // mis-aligned (or for Fat-Projections, not-adjacent) then we have to
160 // MULTIPLY the sizes.  Inspect Brigg&#39;s thesis on register pairs to see why
161 // this is so.
<span class="line-modified">162 int LRG::compute_degree( LRG &amp;l ) const {</span>
163   int tmp;
164   int num_regs = _num_regs;
165   int nregs = l.num_regs();
166   tmp =  (_fat_proj || l._fat_proj)     // either is a fat-proj?
167     ? (num_regs * nregs)                // then use product
168     : MAX2(num_regs,nregs);             // else use max
169   return tmp;
170 }
171 
172 // Compute effective degree for this live range.  If both live ranges are
173 // aligned-adjacent powers-of-2 then we use the MAX size.  If either is
174 // mis-aligned (or for Fat-Projections, not-adjacent) then we have to
175 // MULTIPLY the sizes.  Inspect Brigg&#39;s thesis on register pairs to see why
176 // this is so.
<span class="line-modified">177 int PhaseIFG::effective_degree( uint lidx ) const {</span>


178   int eff = 0;
179   int num_regs = lrgs(lidx).num_regs();
180   int fat_proj = lrgs(lidx)._fat_proj;
<span class="line-removed">181   IndexSet *s = neighbors(lidx);</span>
182   IndexSetIterator elements(s);
183   uint nidx;
<span class="line-modified">184   while((nidx = elements.next()) != 0) {</span>
185     LRG &amp;lrgn = lrgs(nidx);
186     int nregs = lrgn.num_regs();
187     eff += (fat_proj || lrgn._fat_proj) // either is a fat-proj?
188       ? (num_regs * nregs)              // then use product
189       : MAX2(num_regs,nregs);           // else use max
190   }
191   return eff;
192 }
193 
194 
195 #ifndef PRODUCT
196 void PhaseIFG::dump() const {
197   tty-&gt;print_cr(&quot;-- Interference Graph --%s--&quot;,
198                 _is_square ? &quot;square&quot; : &quot;triangular&quot; );
<span class="line-modified">199   if( _is_square ) {</span>
<span class="line-modified">200     for( uint i = 0; i &lt; _maxlrg; i++ ) {</span>
<span class="line-modified">201       tty-&gt;print( (*_yanked)[i] ? &quot;XX &quot; : &quot;  &quot;);</span>
202       tty-&gt;print(&quot;L%d: { &quot;,i);
<span class="line-modified">203       IndexSetIterator elements(&amp;_adjs[i]);</span>
<span class="line-modified">204       uint datum;</span>
<span class="line-modified">205       while ((datum = elements.next()) != 0) {</span>
<span class="line-modified">206         tty-&gt;print(&quot;L%d &quot;, datum);</span>


207       }
208       tty-&gt;print_cr(&quot;}&quot;);
209 
210     }
211     return;
212   }
213 
214   // Triangular
215   for( uint i = 0; i &lt; _maxlrg; i++ ) {
216     uint j;
<span class="line-modified">217     tty-&gt;print( (*_yanked)[i] ? &quot;XX &quot; : &quot;  &quot;);</span>
218     tty-&gt;print(&quot;L%d: { &quot;,i);
219     for( j = _maxlrg; j &gt; i; j-- )
220       if( test_edge(j - 1,i) ) {
221         tty-&gt;print(&quot;L%d &quot;,j - 1);
222       }
223     tty-&gt;print(&quot;| &quot;);
<span class="line-modified">224     IndexSetIterator elements(&amp;_adjs[i]);</span>
<span class="line-modified">225     uint datum;</span>
<span class="line-modified">226     while ((datum = elements.next()) != 0) {</span>
<span class="line-modified">227       tty-&gt;print(&quot;L%d &quot;, datum);</span>


228     }
229     tty-&gt;print(&quot;}\n&quot;);
230   }
231   tty-&gt;print(&quot;\n&quot;);
232 }
233 
234 void PhaseIFG::stats() const {
235   ResourceMark rm;
236   int *h_cnt = NEW_RESOURCE_ARRAY(int,_maxlrg*2);
237   memset( h_cnt, 0, sizeof(int)*_maxlrg*2 );
238   uint i;
239   for( i = 0; i &lt; _maxlrg; i++ ) {
240     h_cnt[neighbor_cnt(i)]++;
241   }
242   tty-&gt;print_cr(&quot;--Histogram of counts--&quot;);
243   for( i = 0; i &lt; _maxlrg*2; i++ )
244     if( h_cnt[i] )
245       tty-&gt;print(&quot;%d/%d &quot;,i,h_cnt[i]);
246   tty-&gt;cr();
247 }
248 
249 void PhaseIFG::verify( const PhaseChaitin *pc ) const {
250   // IFG is square, sorted and no need for Find
251   for( uint i = 0; i &lt; _maxlrg; i++ ) {
<span class="line-modified">252     assert(!((*_yanked)[i]) || !neighbor_cnt(i), &quot;Is removed completely&quot; );</span>
253     IndexSet *set = &amp;_adjs[i];
<span class="line-modified">254     IndexSetIterator elements(set);</span>
<span class="line-modified">255     uint idx;</span>
<span class="line-modified">256     uint last = 0;</span>
<span class="line-modified">257     while ((idx = elements.next()) != 0) {</span>
<span class="line-modified">258       assert(idx != i, &quot;Must have empty diagonal&quot;);</span>
<span class="line-modified">259       assert(pc-&gt;_lrg_map.find_const(idx) == idx, &quot;Must not need Find&quot;);</span>
<span class="line-modified">260       assert(_adjs[idx].member(i), &quot;IFG not square&quot;);</span>
<span class="line-modified">261       assert(!(*_yanked)[idx], &quot;No yanked neighbors&quot;);</span>
<span class="line-modified">262       assert(last &lt; idx, &quot;not sorted increasing&quot;);</span>
<span class="line-modified">263       last = idx;</span>


264     }
265     assert(!lrgs(i)._degree_valid || effective_degree(i) == lrgs(i).degree(), &quot;degree is valid but wrong&quot;);
266   }
267 }
268 #endif
269 
270 /*
271  * Interfere this register with everything currently live.
272  * Check for interference by checking overlap of regmasks.
273  * Only interfere if acceptable register masks overlap.
274  */
275 void PhaseChaitin::interfere_with_live(uint lid, IndexSet* liveout) {
<span class="line-modified">276   LRG&amp; lrg = lrgs(lid);</span>
<span class="line-modified">277   const RegMask&amp; rm = lrg.mask();</span>
<span class="line-modified">278   IndexSetIterator elements(liveout);</span>
<span class="line-modified">279   uint interfering_lid = elements.next();</span>
<span class="line-modified">280   while (interfering_lid != 0) {</span>
<span class="line-modified">281     LRG&amp; interfering_lrg = lrgs(interfering_lid);</span>
<span class="line-modified">282     if (rm.overlap(interfering_lrg.mask())) {</span>
<span class="line-modified">283       _ifg-&gt;add_edge(lid, interfering_lid);</span>



284     }
<span class="line-removed">285     interfering_lid = elements.next();</span>
286   }
287 }
288 
289 // Actually build the interference graph.  Uses virtual registers only, no
290 // physical register masks.  This allows me to be very aggressive when
291 // coalescing copies.  Some of this aggressiveness will have to be undone
292 // later, but I&#39;d rather get all the copies I can now (since unremoved copies
293 // at this point can end up in bad places).  Copies I re-insert later I have
294 // more opportunity to insert them in low-frequency locations.
295 void PhaseChaitin::build_ifg_virtual( ) {
296   Compile::TracePhase tp(&quot;buildIFG_virt&quot;, &amp;timers[_t_buildIFGvirtual]);
297 
298   // For all blocks (in any order) do...
299   for (uint i = 0; i &lt; _cfg.number_of_blocks(); i++) {
300     Block* block = _cfg.get_block(i);
301     IndexSet* liveout = _live-&gt;live(block);
302 
303     // The IFG is built by a single reverse pass over each basic block.
304     // Starting with the known live-out set, we remove things that get
305     // defined and add things that become live (essentially executing one
</pre>
<hr />
<pre>
364             n-&gt;in(2)-&gt;in(2) == n ) {
365           Node *tmp = n-&gt;in(1);
366           n-&gt;set_req( 1, n-&gt;in(2) );
367           n-&gt;set_req( 2, tmp );
368         }
369         // Defined value interferes with all inputs
370         uint lidx = _lrg_map.live_range_id(n-&gt;in(idx));
371         for (uint k = 1; k &lt; n-&gt;req(); k++) {
372           uint kidx = _lrg_map.live_range_id(n-&gt;in(k));
373           if (kidx != lidx) {
374             _ifg-&gt;add_edge(r, kidx);
375           }
376         }
377       }
378     } // End of forall instructions in block
379   } // End of forall blocks
380 }
381 
382 #ifdef ASSERT
383 uint PhaseChaitin::count_int_pressure(IndexSet* liveout) {



384   IndexSetIterator elements(liveout);
385   uint lidx = elements.next();
386   uint cnt = 0;
387   while (lidx != 0) {
388     LRG&amp; lrg = lrgs(lidx);
389     if (lrg.mask_is_nonempty_and_up() &amp;&amp;
390         !lrg.is_float_or_vector() &amp;&amp;
391         lrg.mask().overlap(*Matcher::idealreg2regmask[Op_RegI])) {
392       cnt += lrg.reg_pressure();
393     }
394     lidx = elements.next();
395   }
396   return cnt;
397 }
398 
399 uint PhaseChaitin::count_float_pressure(IndexSet* liveout) {



400   IndexSetIterator elements(liveout);
401   uint lidx = elements.next();
402   uint cnt = 0;
403   while (lidx != 0) {
404     LRG&amp; lrg = lrgs(lidx);
405     if (lrg.mask_is_nonempty_and_up() &amp;&amp; lrg.is_float_or_vector()) {
406       cnt += lrg.reg_pressure();
407     }
408     lidx = elements.next();
409   }
410   return cnt;
411 }
412 #endif
413 
414 /*
415  * Adjust register pressure down by 1.  Capture last hi-to-low transition,
416  */
417 void PhaseChaitin::lower_pressure(Block* b, uint location, LRG&amp; lrg, IndexSet* liveout, Pressure&amp; int_pressure, Pressure&amp; float_pressure) {
418   if (lrg.mask_is_nonempty_and_up()) {
419     if (lrg.is_float_or_vector()) {
</pre>
<hr />
<pre>
477       // Do not count the SP and flag registers
478       const RegMask&amp; rm = lrg.mask();
479       if (rm.overlap(*Matcher::idealreg2regmask[Op_RegI])) {
480         int_pressure.raise(lrg);
481       }
482     }
483   }
484 }
485 
486 
487 /*
488  * Computes the initial register pressure of a block, looking at all live
489  * ranges in the liveout. The register pressure is computed for both float
490  * and int/pointer registers.
491  * Live ranges in the liveout are presumed live for the whole block.
492  * We add the cost for the whole block to the area of the live ranges initially.
493  * If a live range gets killed in the block, we&#39;ll subtract the unused part of
494  * the block from the area.
495  */
496 void PhaseChaitin::compute_initial_block_pressure(Block* b, IndexSet* liveout, Pressure&amp; int_pressure, Pressure&amp; float_pressure, double cost) {
<span class="line-modified">497   IndexSetIterator elements(liveout);</span>
<span class="line-modified">498   uint lid = elements.next();</span>
<span class="line-modified">499   while (lid != 0) {</span>
<span class="line-modified">500     LRG&amp; lrg = lrgs(lid);</span>
<span class="line-modified">501     lrg._area += cost;</span>
<span class="line-modified">502     raise_pressure(b, lrg, int_pressure, float_pressure);</span>
<span class="line-modified">503     lid = elements.next();</span>


504   }
505   assert(int_pressure.current_pressure() == count_int_pressure(liveout), &quot;the int pressure is incorrect&quot;);
506   assert(float_pressure.current_pressure() == count_float_pressure(liveout), &quot;the float pressure is incorrect&quot;);
507 }
508 
509 /*
510 * Computes the entry register pressure of a block, looking at all live
511 * ranges in the livein. The register pressure is computed for both float
512 * and int/pointer registers.
513 */
514 void PhaseChaitin::compute_entry_block_pressure(Block* b) {
<span class="line-modified">515   IndexSet* livein = _live-&gt;livein(b);</span>
<span class="line-modified">516   IndexSetIterator elements(livein);</span>
<span class="line-modified">517   uint lid = elements.next();</span>
<span class="line-modified">518   while (lid != 0) {</span>
<span class="line-modified">519     LRG&amp; lrg = lrgs(lid);</span>
<span class="line-modified">520     raise_pressure(b, lrg, _sched_int_pressure, _sched_float_pressure);</span>
<span class="line-modified">521     lid = elements.next();</span>


522   }
523   // Now check phis for locally defined inputs
524   for (uint j = 0; j &lt; b-&gt;number_of_nodes(); j++) {
525     Node* n = b-&gt;get_node(j);
526     if (n-&gt;is_Phi()) {
527       for (uint k = 1; k &lt; n-&gt;req(); k++) {
528         Node* phi_in = n-&gt;in(k);
529         // Because we are talking about phis, raise register pressure once for each
530         // instance of a phi to account for a single value
531         if (_cfg.get_block_for_node(phi_in) == b) {
532           LRG&amp; lrg = lrgs(phi_in-&gt;_idx);
533           raise_pressure(b, lrg, _sched_int_pressure, _sched_float_pressure);
534           break;
535         }
536       }
537     }
538   }
539   _sched_int_pressure.set_start_pressure(_sched_int_pressure.current_pressure());
540   _sched_float_pressure.set_start_pressure(_sched_float_pressure.current_pressure());
541 }
542 
543 /*
544 * Computes the exit register pressure of a block, looking at all live
545 * ranges in the liveout. The register pressure is computed for both float
546 * and int/pointer registers.
547 */
548 void PhaseChaitin::compute_exit_block_pressure(Block* b) {

549   IndexSet* livein = _live-&gt;live(b);
<span class="line-removed">550   IndexSetIterator elements(livein);</span>
551   _sched_int_pressure.set_current_pressure(0);
552   _sched_float_pressure.set_current_pressure(0);
<span class="line-modified">553   uint lid = elements.next();</span>
<span class="line-modified">554   while (lid != 0) {</span>
<span class="line-modified">555     LRG&amp; lrg = lrgs(lid);</span>
<span class="line-modified">556     raise_pressure(b, lrg, _sched_int_pressure, _sched_float_pressure);</span>
<span class="line-modified">557     lid = elements.next();</span>



558   }
559 }
560 
561 /*
562  * Remove dead node if it&#39;s not used.
563  * We only remove projection nodes if the node &quot;defining&quot; the projection is
564  * dead, for example on x86, if we have a dead Add node we remove its
565  * RFLAGS node.
566  */
567 bool PhaseChaitin::remove_node_if_not_used(Block* b, uint location, Node* n, uint lid, IndexSet* liveout) {
568   Node* def = n-&gt;in(0);
569   if (!n-&gt;is_Proj() ||
570       (_lrg_map.live_range_id(def) &amp;&amp; !liveout-&gt;member(_lrg_map.live_range_id(def)))) {
571     if (n-&gt;is_MachProj()) {
572       // Don&#39;t remove KILL projections if their &quot;defining&quot; nodes have
573       // memory effects (have SCMemProj projection node) -
574       // they are not dead even when their result is not used.
575       // For example, compareAndSwapL (and other CAS) and EncodeISOArray nodes.
576       // The method add_input_to_liveout() keeps such nodes alive (put them on liveout list)
577       // when it sees SCMemProj node in a block. Unfortunately SCMemProj node could be placed
</pre>
<hr />
<pre>
637 
638 /*
639  * Copies do not define a new value and so do not interfere.
640  * Remove the copies source from the liveout set before interfering.
641  */
642 void PhaseChaitin::remove_interference_from_copy(Block* b, uint location, uint lid_copy, IndexSet* liveout, double cost, Pressure&amp; int_pressure, Pressure&amp; float_pressure) {
643   if (liveout-&gt;remove(lid_copy)) {
644     LRG&amp; lrg_copy = lrgs(lid_copy);
645     lrg_copy._area -= cost;
646 
647     // Lower register pressure since copy and definition can share the same register
648     lower_pressure(b, location, lrg_copy, liveout, int_pressure, float_pressure);
649   }
650 }
651 
652 /*
653  * The defined value must go in a particular register. Remove that register from
654  * all conflicting parties and avoid the interference.
655  */
656 void PhaseChaitin::remove_bound_register_from_interfering_live_ranges(LRG&amp; lrg, IndexSet* liveout, uint&amp; must_spill) {

657   // Check for common case
658   const RegMask&amp; rm = lrg.mask();
659   int r_size = lrg.num_regs();
660   // Smear odd bits
661   IndexSetIterator elements(liveout);
662   uint l = elements.next();
663   while (l != 0) {
664     LRG&amp; interfering_lrg = lrgs(l);
665     // If &#39;l&#39; must spill already, do not further hack his bits.
666     // He&#39;ll get some interferences and be forced to spill later.
667     if (interfering_lrg._must_spill) {
668       l = elements.next();
669       continue;
670     }
671 
672     // Remove bound register(s) from &#39;l&#39;s choices
673     RegMask old = interfering_lrg.mask();
674     uint old_size = interfering_lrg.mask_size();
675 
676     // Remove the bits from LRG &#39;rm&#39; from LRG &#39;l&#39; so &#39;l&#39; no
</pre>
<hr />
<pre>
816     uint first_inst = first_nonphi_index(block);
817     uint last_inst = block-&gt;end_idx();
818 
819     move_exception_node_up(block, first_inst, last_inst);
820 
821     Pressure int_pressure(last_inst + 1, INTPRESSURE);
822     Pressure float_pressure(last_inst + 1, FLOATPRESSURE);
823     block-&gt;_reg_pressure = 0;
824     block-&gt;_freg_pressure = 0;
825 
826     int inst_count = last_inst - first_inst;
827     double cost = (inst_count &lt;= 0) ? 0.0 : block-&gt;_freq * double(inst_count);
828     assert(cost &gt;= 0.0, &quot;negative spill cost&quot; );
829 
830     compute_initial_block_pressure(block, &amp;liveout, int_pressure, float_pressure, cost);
831 
832     for (uint location = last_inst; location &gt; 0; location--) {
833       Node* n = block-&gt;get_node(location);
834       uint lid = _lrg_map.live_range_id(n);
835 
<span class="line-modified">836       if(lid) {</span>
837         LRG&amp; lrg = lrgs(lid);
838 
839         // A DEF normally costs block frequency; rematerialized values are
840         // removed from the DEF sight, so LOWER costs here.
841         lrg._cost += n-&gt;rematerialize() ? 0 : block-&gt;_freq;
842 
843         if (!liveout.member(lid) &amp;&amp; n-&gt;Opcode() != Op_SafePoint) {
844           if (remove_node_if_not_used(block, location, n, lid, &amp;liveout)) {
845             float_pressure.lower_high_pressure_index();
846             int_pressure.lower_high_pressure_index();
847             continue;
848           }
849           if (lrg._fat_proj) {
850             check_for_high_pressure_transition_at_fatproj(block-&gt;_reg_pressure, location, lrg, int_pressure, Op_RegI);
851             check_for_high_pressure_transition_at_fatproj(block-&gt;_freg_pressure, location, lrg, float_pressure, Op_RegD);
852           }
853         } else {
854           // A live range ends at its definition, remove the remaining area.
855           // If the cost is +Inf (which might happen in extreme cases), the lrg area will also be +Inf,
856           // and +Inf - +Inf = NaN. So let&#39;s not do that subtraction.
</pre>
</td>
<td>
<hr />
<pre>
 63   lrgs(b).invalid_degree();
 64   // Sort a and b, so that a is bigger
 65   assert( !_is_square, &quot;only on triangular&quot; );
 66   if( a &lt; b ) { uint tmp = a; a = b; b = tmp; }
 67   return _adjs[a].insert( b );
 68 }
 69 
 70 // Is there an edge between a and b?
 71 int PhaseIFG::test_edge( uint a, uint b ) const {
 72   // Sort a and b, so that a is larger
 73   assert( !_is_square, &quot;only on triangular&quot; );
 74   if( a &lt; b ) { uint tmp = a; a = b; b = tmp; }
 75   return _adjs[a].member(b);
 76 }
 77 
 78 // Convert triangular matrix to square matrix
 79 void PhaseIFG::SquareUp() {
 80   assert( !_is_square, &quot;only on triangular&quot; );
 81 
 82   // Simple transpose
<span class="line-modified"> 83   for(uint i = 0; i &lt; _maxlrg; i++ ) {</span>
<span class="line-modified"> 84     if (!_adjs[i].is_empty()) {</span>
<span class="line-modified"> 85       IndexSetIterator elements(&amp;_adjs[i]);</span>
<span class="line-modified"> 86       uint datum;</span>
<span class="line-modified"> 87       while ((datum = elements.next()) != 0) {</span>
<span class="line-added"> 88         _adjs[datum].insert(i);</span>
<span class="line-added"> 89       }</span>
 90     }
 91   }
 92   _is_square = true;
 93 }
 94 
 95 // Compute effective degree in bulk
 96 void PhaseIFG::Compute_Effective_Degree() {
 97   assert( _is_square, &quot;only on square&quot; );
 98 
 99   for( uint i = 0; i &lt; _maxlrg; i++ )
100     lrgs(i).set_degree(effective_degree(i));
101 }
102 
103 int PhaseIFG::test_edge_sq( uint a, uint b ) const {
104   assert( _is_square, &quot;only on square&quot; );
105   // Swap, so that &#39;a&#39; has the lesser count.  Then binary search is on
106   // the smaller of a&#39;s list and b&#39;s list.
107   if( neighbor_cnt(a) &gt; neighbor_cnt(b) ) { uint tmp = a; a = b; b = tmp; }
108   //return _adjs[a].unordered_member(b);
109   return _adjs[a].member(b);
110 }
111 
112 // Union edges of B into A
<span class="line-modified">113 void PhaseIFG::Union(uint a, uint b) {</span>
114   assert( _is_square, &quot;only on square&quot; );
115   IndexSet *A = &amp;_adjs[a];
<span class="line-modified">116   if (!_adjs[b].is_empty()) {</span>
<span class="line-modified">117     IndexSetIterator b_elements(&amp;_adjs[b]);</span>
<span class="line-modified">118     uint datum;</span>
<span class="line-modified">119     while ((datum = b_elements.next()) != 0) {</span>
<span class="line-modified">120       if (A-&gt;insert(datum)) {</span>
<span class="line-modified">121         _adjs[datum].insert(a);</span>
<span class="line-modified">122         lrgs(a).invalid_degree();</span>
<span class="line-added">123         lrgs(datum).invalid_degree();</span>
<span class="line-added">124       }</span>
125     }
126   }
127 }
128 
129 // Yank a Node and all connected edges from the IFG.  Return a
130 // list of neighbors (edges) yanked.
131 IndexSet *PhaseIFG::remove_node( uint a ) {
132   assert( _is_square, &quot;only on square&quot; );
133   assert( !_yanked-&gt;test(a), &quot;&quot; );
134   _yanked-&gt;set(a);
135 
136   // I remove the LRG from all neighbors.

137   LRG &amp;lrg_a = lrgs(a);
<span class="line-modified">138 </span>
<span class="line-modified">139   if (!_adjs[a].is_empty()) {</span>
<span class="line-modified">140     IndexSetIterator elements(&amp;_adjs[a]);</span>
<span class="line-modified">141     uint datum;</span>
<span class="line-added">142     while ((datum = elements.next()) != 0) {</span>
<span class="line-added">143       _adjs[datum].remove(a);</span>
<span class="line-added">144       lrgs(datum).inc_degree(-lrg_a.compute_degree(lrgs(datum)));</span>
<span class="line-added">145     }</span>
146   }
147   return neighbors(a);
148 }
149 
150 // Re-insert a yanked Node.
<span class="line-modified">151 void PhaseIFG::re_insert(uint a) {</span>
152   assert( _is_square, &quot;only on square&quot; );
153   assert( _yanked-&gt;test(a), &quot;&quot; );
<span class="line-modified">154   _yanked-&gt;remove(a);</span>
<span class="line-added">155 </span>
<span class="line-added">156   if (_adjs[a].is_empty()) return;</span>
157 
158   IndexSetIterator elements(&amp;_adjs[a]);
159   uint datum;
160   while ((datum = elements.next()) != 0) {
161     _adjs[datum].insert(a);
162     lrgs(datum).invalid_degree();
163   }
164 }
165 
166 // Compute the degree between 2 live ranges.  If both live ranges are
167 // aligned-adjacent powers-of-2 then we use the MAX size.  If either is
168 // mis-aligned (or for Fat-Projections, not-adjacent) then we have to
169 // MULTIPLY the sizes.  Inspect Brigg&#39;s thesis on register pairs to see why
170 // this is so.
<span class="line-modified">171 int LRG::compute_degree(LRG &amp;l) const {</span>
172   int tmp;
173   int num_regs = _num_regs;
174   int nregs = l.num_regs();
175   tmp =  (_fat_proj || l._fat_proj)     // either is a fat-proj?
176     ? (num_regs * nregs)                // then use product
177     : MAX2(num_regs,nregs);             // else use max
178   return tmp;
179 }
180 
181 // Compute effective degree for this live range.  If both live ranges are
182 // aligned-adjacent powers-of-2 then we use the MAX size.  If either is
183 // mis-aligned (or for Fat-Projections, not-adjacent) then we have to
184 // MULTIPLY the sizes.  Inspect Brigg&#39;s thesis on register pairs to see why
185 // this is so.
<span class="line-modified">186 int PhaseIFG::effective_degree(uint lidx) const {</span>
<span class="line-added">187   IndexSet *s = neighbors(lidx);</span>
<span class="line-added">188   if (s-&gt;is_empty()) return 0;</span>
189   int eff = 0;
190   int num_regs = lrgs(lidx).num_regs();
191   int fat_proj = lrgs(lidx)._fat_proj;

192   IndexSetIterator elements(s);
193   uint nidx;
<span class="line-modified">194   while ((nidx = elements.next()) != 0) {</span>
195     LRG &amp;lrgn = lrgs(nidx);
196     int nregs = lrgn.num_regs();
197     eff += (fat_proj || lrgn._fat_proj) // either is a fat-proj?
198       ? (num_regs * nregs)              // then use product
199       : MAX2(num_regs,nregs);           // else use max
200   }
201   return eff;
202 }
203 
204 
205 #ifndef PRODUCT
206 void PhaseIFG::dump() const {
207   tty-&gt;print_cr(&quot;-- Interference Graph --%s--&quot;,
208                 _is_square ? &quot;square&quot; : &quot;triangular&quot; );
<span class="line-modified">209   if (_is_square) {</span>
<span class="line-modified">210     for (uint i = 0; i &lt; _maxlrg; i++) {</span>
<span class="line-modified">211       tty-&gt;print(_yanked-&gt;test(i) ? &quot;XX &quot; : &quot;  &quot;);</span>
212       tty-&gt;print(&quot;L%d: { &quot;,i);
<span class="line-modified">213       if (!_adjs[i].is_empty()) {</span>
<span class="line-modified">214         IndexSetIterator elements(&amp;_adjs[i]);</span>
<span class="line-modified">215         uint datum;</span>
<span class="line-modified">216         while ((datum = elements.next()) != 0) {</span>
<span class="line-added">217           tty-&gt;print(&quot;L%d &quot;, datum);</span>
<span class="line-added">218         }</span>
219       }
220       tty-&gt;print_cr(&quot;}&quot;);
221 
222     }
223     return;
224   }
225 
226   // Triangular
227   for( uint i = 0; i &lt; _maxlrg; i++ ) {
228     uint j;
<span class="line-modified">229     tty-&gt;print(_yanked-&gt;test(i) ? &quot;XX &quot; : &quot;  &quot;);</span>
230     tty-&gt;print(&quot;L%d: { &quot;,i);
231     for( j = _maxlrg; j &gt; i; j-- )
232       if( test_edge(j - 1,i) ) {
233         tty-&gt;print(&quot;L%d &quot;,j - 1);
234       }
235     tty-&gt;print(&quot;| &quot;);
<span class="line-modified">236     if (!_adjs[i].is_empty()) {</span>
<span class="line-modified">237       IndexSetIterator elements(&amp;_adjs[i]);</span>
<span class="line-modified">238       uint datum;</span>
<span class="line-modified">239       while ((datum = elements.next()) != 0) {</span>
<span class="line-added">240         tty-&gt;print(&quot;L%d &quot;, datum);</span>
<span class="line-added">241       }</span>
242     }
243     tty-&gt;print(&quot;}\n&quot;);
244   }
245   tty-&gt;print(&quot;\n&quot;);
246 }
247 
248 void PhaseIFG::stats() const {
249   ResourceMark rm;
250   int *h_cnt = NEW_RESOURCE_ARRAY(int,_maxlrg*2);
251   memset( h_cnt, 0, sizeof(int)*_maxlrg*2 );
252   uint i;
253   for( i = 0; i &lt; _maxlrg; i++ ) {
254     h_cnt[neighbor_cnt(i)]++;
255   }
256   tty-&gt;print_cr(&quot;--Histogram of counts--&quot;);
257   for( i = 0; i &lt; _maxlrg*2; i++ )
258     if( h_cnt[i] )
259       tty-&gt;print(&quot;%d/%d &quot;,i,h_cnt[i]);
260   tty-&gt;cr();
261 }
262 
263 void PhaseIFG::verify( const PhaseChaitin *pc ) const {
264   // IFG is square, sorted and no need for Find
265   for( uint i = 0; i &lt; _maxlrg; i++ ) {
<span class="line-modified">266     assert(!_yanked-&gt;test(i) || !neighbor_cnt(i), &quot;Is removed completely&quot; );</span>
267     IndexSet *set = &amp;_adjs[i];
<span class="line-modified">268     if (!set-&gt;is_empty()) {</span>
<span class="line-modified">269       IndexSetIterator elements(set);</span>
<span class="line-modified">270       uint idx;</span>
<span class="line-modified">271       uint last = 0;</span>
<span class="line-modified">272       while ((idx = elements.next()) != 0) {</span>
<span class="line-modified">273         assert(idx != i, &quot;Must have empty diagonal&quot;);</span>
<span class="line-modified">274         assert(pc-&gt;_lrg_map.find_const(idx) == idx, &quot;Must not need Find&quot;);</span>
<span class="line-modified">275         assert(_adjs[idx].member(i), &quot;IFG not square&quot;);</span>
<span class="line-modified">276         assert(!_yanked-&gt;test(idx), &quot;No yanked neighbors&quot;);</span>
<span class="line-modified">277         assert(last &lt; idx, &quot;not sorted increasing&quot;);</span>
<span class="line-added">278         last = idx;</span>
<span class="line-added">279       }</span>
280     }
281     assert(!lrgs(i)._degree_valid || effective_degree(i) == lrgs(i).degree(), &quot;degree is valid but wrong&quot;);
282   }
283 }
284 #endif
285 
286 /*
287  * Interfere this register with everything currently live.
288  * Check for interference by checking overlap of regmasks.
289  * Only interfere if acceptable register masks overlap.
290  */
291 void PhaseChaitin::interfere_with_live(uint lid, IndexSet* liveout) {
<span class="line-modified">292   if (!liveout-&gt;is_empty()) {</span>
<span class="line-modified">293     LRG&amp; lrg = lrgs(lid);</span>
<span class="line-modified">294     const RegMask &amp;rm = lrg.mask();</span>
<span class="line-modified">295     IndexSetIterator elements(liveout);</span>
<span class="line-modified">296     uint interfering_lid = elements.next();</span>
<span class="line-modified">297     while (interfering_lid != 0) {</span>
<span class="line-modified">298       LRG&amp; interfering_lrg = lrgs(interfering_lid);</span>
<span class="line-modified">299       if (rm.overlap(interfering_lrg.mask())) {</span>
<span class="line-added">300         _ifg-&gt;add_edge(lid, interfering_lid);</span>
<span class="line-added">301       }</span>
<span class="line-added">302       interfering_lid = elements.next();</span>
303     }

304   }
305 }
306 
307 // Actually build the interference graph.  Uses virtual registers only, no
308 // physical register masks.  This allows me to be very aggressive when
309 // coalescing copies.  Some of this aggressiveness will have to be undone
310 // later, but I&#39;d rather get all the copies I can now (since unremoved copies
311 // at this point can end up in bad places).  Copies I re-insert later I have
312 // more opportunity to insert them in low-frequency locations.
313 void PhaseChaitin::build_ifg_virtual( ) {
314   Compile::TracePhase tp(&quot;buildIFG_virt&quot;, &amp;timers[_t_buildIFGvirtual]);
315 
316   // For all blocks (in any order) do...
317   for (uint i = 0; i &lt; _cfg.number_of_blocks(); i++) {
318     Block* block = _cfg.get_block(i);
319     IndexSet* liveout = _live-&gt;live(block);
320 
321     // The IFG is built by a single reverse pass over each basic block.
322     // Starting with the known live-out set, we remove things that get
323     // defined and add things that become live (essentially executing one
</pre>
<hr />
<pre>
382             n-&gt;in(2)-&gt;in(2) == n ) {
383           Node *tmp = n-&gt;in(1);
384           n-&gt;set_req( 1, n-&gt;in(2) );
385           n-&gt;set_req( 2, tmp );
386         }
387         // Defined value interferes with all inputs
388         uint lidx = _lrg_map.live_range_id(n-&gt;in(idx));
389         for (uint k = 1; k &lt; n-&gt;req(); k++) {
390           uint kidx = _lrg_map.live_range_id(n-&gt;in(k));
391           if (kidx != lidx) {
392             _ifg-&gt;add_edge(r, kidx);
393           }
394         }
395       }
396     } // End of forall instructions in block
397   } // End of forall blocks
398 }
399 
400 #ifdef ASSERT
401 uint PhaseChaitin::count_int_pressure(IndexSet* liveout) {
<span class="line-added">402   if (liveout-&gt;is_empty()) {</span>
<span class="line-added">403     return 0;</span>
<span class="line-added">404   }</span>
405   IndexSetIterator elements(liveout);
406   uint lidx = elements.next();
407   uint cnt = 0;
408   while (lidx != 0) {
409     LRG&amp; lrg = lrgs(lidx);
410     if (lrg.mask_is_nonempty_and_up() &amp;&amp;
411         !lrg.is_float_or_vector() &amp;&amp;
412         lrg.mask().overlap(*Matcher::idealreg2regmask[Op_RegI])) {
413       cnt += lrg.reg_pressure();
414     }
415     lidx = elements.next();
416   }
417   return cnt;
418 }
419 
420 uint PhaseChaitin::count_float_pressure(IndexSet* liveout) {
<span class="line-added">421   if (liveout-&gt;is_empty()) {</span>
<span class="line-added">422     return 0;</span>
<span class="line-added">423   }</span>
424   IndexSetIterator elements(liveout);
425   uint lidx = elements.next();
426   uint cnt = 0;
427   while (lidx != 0) {
428     LRG&amp; lrg = lrgs(lidx);
429     if (lrg.mask_is_nonempty_and_up() &amp;&amp; lrg.is_float_or_vector()) {
430       cnt += lrg.reg_pressure();
431     }
432     lidx = elements.next();
433   }
434   return cnt;
435 }
436 #endif
437 
438 /*
439  * Adjust register pressure down by 1.  Capture last hi-to-low transition,
440  */
441 void PhaseChaitin::lower_pressure(Block* b, uint location, LRG&amp; lrg, IndexSet* liveout, Pressure&amp; int_pressure, Pressure&amp; float_pressure) {
442   if (lrg.mask_is_nonempty_and_up()) {
443     if (lrg.is_float_or_vector()) {
</pre>
<hr />
<pre>
501       // Do not count the SP and flag registers
502       const RegMask&amp; rm = lrg.mask();
503       if (rm.overlap(*Matcher::idealreg2regmask[Op_RegI])) {
504         int_pressure.raise(lrg);
505       }
506     }
507   }
508 }
509 
510 
511 /*
512  * Computes the initial register pressure of a block, looking at all live
513  * ranges in the liveout. The register pressure is computed for both float
514  * and int/pointer registers.
515  * Live ranges in the liveout are presumed live for the whole block.
516  * We add the cost for the whole block to the area of the live ranges initially.
517  * If a live range gets killed in the block, we&#39;ll subtract the unused part of
518  * the block from the area.
519  */
520 void PhaseChaitin::compute_initial_block_pressure(Block* b, IndexSet* liveout, Pressure&amp; int_pressure, Pressure&amp; float_pressure, double cost) {
<span class="line-modified">521   if (!liveout-&gt;is_empty()) {</span>
<span class="line-modified">522     IndexSetIterator elements(liveout);</span>
<span class="line-modified">523     uint lid = elements.next();</span>
<span class="line-modified">524     while (lid != 0) {</span>
<span class="line-modified">525       LRG &amp;lrg = lrgs(lid);</span>
<span class="line-modified">526       lrg._area += cost;</span>
<span class="line-modified">527       raise_pressure(b, lrg, int_pressure, float_pressure);</span>
<span class="line-added">528       lid = elements.next();</span>
<span class="line-added">529     }</span>
530   }
531   assert(int_pressure.current_pressure() == count_int_pressure(liveout), &quot;the int pressure is incorrect&quot;);
532   assert(float_pressure.current_pressure() == count_float_pressure(liveout), &quot;the float pressure is incorrect&quot;);
533 }
534 
535 /*
536 * Computes the entry register pressure of a block, looking at all live
537 * ranges in the livein. The register pressure is computed for both float
538 * and int/pointer registers.
539 */
540 void PhaseChaitin::compute_entry_block_pressure(Block* b) {
<span class="line-modified">541   IndexSet *livein = _live-&gt;livein(b);</span>
<span class="line-modified">542   if (!livein-&gt;is_empty()) {</span>
<span class="line-modified">543     IndexSetIterator elements(livein);</span>
<span class="line-modified">544     uint lid = elements.next();</span>
<span class="line-modified">545     while (lid != 0) {</span>
<span class="line-modified">546       LRG &amp;lrg = lrgs(lid);</span>
<span class="line-modified">547       raise_pressure(b, lrg, _sched_int_pressure, _sched_float_pressure);</span>
<span class="line-added">548       lid = elements.next();</span>
<span class="line-added">549     }</span>
550   }
551   // Now check phis for locally defined inputs
552   for (uint j = 0; j &lt; b-&gt;number_of_nodes(); j++) {
553     Node* n = b-&gt;get_node(j);
554     if (n-&gt;is_Phi()) {
555       for (uint k = 1; k &lt; n-&gt;req(); k++) {
556         Node* phi_in = n-&gt;in(k);
557         // Because we are talking about phis, raise register pressure once for each
558         // instance of a phi to account for a single value
559         if (_cfg.get_block_for_node(phi_in) == b) {
560           LRG&amp; lrg = lrgs(phi_in-&gt;_idx);
561           raise_pressure(b, lrg, _sched_int_pressure, _sched_float_pressure);
562           break;
563         }
564       }
565     }
566   }
567   _sched_int_pressure.set_start_pressure(_sched_int_pressure.current_pressure());
568   _sched_float_pressure.set_start_pressure(_sched_float_pressure.current_pressure());
569 }
570 
571 /*
572 * Computes the exit register pressure of a block, looking at all live
573 * ranges in the liveout. The register pressure is computed for both float
574 * and int/pointer registers.
575 */
576 void PhaseChaitin::compute_exit_block_pressure(Block* b) {
<span class="line-added">577 </span>
578   IndexSet* livein = _live-&gt;live(b);

579   _sched_int_pressure.set_current_pressure(0);
580   _sched_float_pressure.set_current_pressure(0);
<span class="line-modified">581   if (!livein-&gt;is_empty()) {</span>
<span class="line-modified">582     IndexSetIterator elements(livein);</span>
<span class="line-modified">583     uint lid = elements.next();</span>
<span class="line-modified">584     while (lid != 0) {</span>
<span class="line-modified">585       LRG &amp;lrg = lrgs(lid);</span>
<span class="line-added">586       raise_pressure(b, lrg, _sched_int_pressure, _sched_float_pressure);</span>
<span class="line-added">587       lid = elements.next();</span>
<span class="line-added">588     }</span>
589   }
590 }
591 
592 /*
593  * Remove dead node if it&#39;s not used.
594  * We only remove projection nodes if the node &quot;defining&quot; the projection is
595  * dead, for example on x86, if we have a dead Add node we remove its
596  * RFLAGS node.
597  */
598 bool PhaseChaitin::remove_node_if_not_used(Block* b, uint location, Node* n, uint lid, IndexSet* liveout) {
599   Node* def = n-&gt;in(0);
600   if (!n-&gt;is_Proj() ||
601       (_lrg_map.live_range_id(def) &amp;&amp; !liveout-&gt;member(_lrg_map.live_range_id(def)))) {
602     if (n-&gt;is_MachProj()) {
603       // Don&#39;t remove KILL projections if their &quot;defining&quot; nodes have
604       // memory effects (have SCMemProj projection node) -
605       // they are not dead even when their result is not used.
606       // For example, compareAndSwapL (and other CAS) and EncodeISOArray nodes.
607       // The method add_input_to_liveout() keeps such nodes alive (put them on liveout list)
608       // when it sees SCMemProj node in a block. Unfortunately SCMemProj node could be placed
</pre>
<hr />
<pre>
668 
669 /*
670  * Copies do not define a new value and so do not interfere.
671  * Remove the copies source from the liveout set before interfering.
672  */
673 void PhaseChaitin::remove_interference_from_copy(Block* b, uint location, uint lid_copy, IndexSet* liveout, double cost, Pressure&amp; int_pressure, Pressure&amp; float_pressure) {
674   if (liveout-&gt;remove(lid_copy)) {
675     LRG&amp; lrg_copy = lrgs(lid_copy);
676     lrg_copy._area -= cost;
677 
678     // Lower register pressure since copy and definition can share the same register
679     lower_pressure(b, location, lrg_copy, liveout, int_pressure, float_pressure);
680   }
681 }
682 
683 /*
684  * The defined value must go in a particular register. Remove that register from
685  * all conflicting parties and avoid the interference.
686  */
687 void PhaseChaitin::remove_bound_register_from_interfering_live_ranges(LRG&amp; lrg, IndexSet* liveout, uint&amp; must_spill) {
<span class="line-added">688   if (liveout-&gt;is_empty()) return;</span>
689   // Check for common case
690   const RegMask&amp; rm = lrg.mask();
691   int r_size = lrg.num_regs();
692   // Smear odd bits
693   IndexSetIterator elements(liveout);
694   uint l = elements.next();
695   while (l != 0) {
696     LRG&amp; interfering_lrg = lrgs(l);
697     // If &#39;l&#39; must spill already, do not further hack his bits.
698     // He&#39;ll get some interferences and be forced to spill later.
699     if (interfering_lrg._must_spill) {
700       l = elements.next();
701       continue;
702     }
703 
704     // Remove bound register(s) from &#39;l&#39;s choices
705     RegMask old = interfering_lrg.mask();
706     uint old_size = interfering_lrg.mask_size();
707 
708     // Remove the bits from LRG &#39;rm&#39; from LRG &#39;l&#39; so &#39;l&#39; no
</pre>
<hr />
<pre>
848     uint first_inst = first_nonphi_index(block);
849     uint last_inst = block-&gt;end_idx();
850 
851     move_exception_node_up(block, first_inst, last_inst);
852 
853     Pressure int_pressure(last_inst + 1, INTPRESSURE);
854     Pressure float_pressure(last_inst + 1, FLOATPRESSURE);
855     block-&gt;_reg_pressure = 0;
856     block-&gt;_freg_pressure = 0;
857 
858     int inst_count = last_inst - first_inst;
859     double cost = (inst_count &lt;= 0) ? 0.0 : block-&gt;_freq * double(inst_count);
860     assert(cost &gt;= 0.0, &quot;negative spill cost&quot; );
861 
862     compute_initial_block_pressure(block, &amp;liveout, int_pressure, float_pressure, cost);
863 
864     for (uint location = last_inst; location &gt; 0; location--) {
865       Node* n = block-&gt;get_node(location);
866       uint lid = _lrg_map.live_range_id(n);
867 
<span class="line-modified">868       if (lid) {</span>
869         LRG&amp; lrg = lrgs(lid);
870 
871         // A DEF normally costs block frequency; rematerialized values are
872         // removed from the DEF sight, so LOWER costs here.
873         lrg._cost += n-&gt;rematerialize() ? 0 : block-&gt;_freq;
874 
875         if (!liveout.member(lid) &amp;&amp; n-&gt;Opcode() != Op_SafePoint) {
876           if (remove_node_if_not_used(block, location, n, lid, &amp;liveout)) {
877             float_pressure.lower_high_pressure_index();
878             int_pressure.lower_high_pressure_index();
879             continue;
880           }
881           if (lrg._fat_proj) {
882             check_for_high_pressure_transition_at_fatproj(block-&gt;_reg_pressure, location, lrg, int_pressure, Op_RegI);
883             check_for_high_pressure_transition_at_fatproj(block-&gt;_freg_pressure, location, lrg, float_pressure, Op_RegD);
884           }
885         } else {
886           // A live range ends at its definition, remove the remaining area.
887           // If the cost is +Inf (which might happen in extreme cases), the lrg area will also be +Inf,
888           // and +Inf - +Inf = NaN. So let&#39;s not do that subtraction.
</pre>
</td>
</tr>
</table>
<center><a href="idealGraphPrinter.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ifnode.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
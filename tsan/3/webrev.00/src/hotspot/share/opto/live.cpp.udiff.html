<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/opto/live.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="library_call.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="locknode.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/live.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -82,11 +82,11 @@</span>
      _defs[i].initialize(_maxlrg);
    }
  
    // Array of delta-set pointers, indexed by block pre_order-1.
    _deltas = NEW_RESOURCE_ARRAY(IndexSet*,_cfg.number_of_blocks());
<span class="udiff-line-modified-removed">-   memset( _deltas, 0, sizeof(IndexSet*)* _cfg.number_of_blocks());</span>
<span class="udiff-line-modified-added">+   memset(_deltas, 0, sizeof(IndexSet*)* _cfg.number_of_blocks());</span>
  
    _free_IndexSet = NULL;
  
    // Blocks having done pass-1
    VectorSet first_pass(Thread::current()-&gt;resource_area());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -106,12 +106,12 @@</span>
          break;
        }
  
        uint r = _names.at(n-&gt;_idx);
        assert(!def_outside-&gt;member(r), &quot;Use of external LRG overlaps the same LRG defined in this block&quot;);
<span class="udiff-line-modified-removed">-       def-&gt;insert( r );</span>
<span class="udiff-line-modified-removed">-       use-&gt;remove( r );</span>
<span class="udiff-line-modified-added">+       def-&gt;insert(r);</span>
<span class="udiff-line-modified-added">+       use-&gt;remove(r);</span>
        uint cnt = n-&gt;req();
        for (uint k = 1; k &lt; cnt; k++) {
          Node *nk = n-&gt;in(k);
          uint nkidx = nk-&gt;_idx;
          if (_cfg.get_block_for_node(nk) != block) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -150,11 +150,11 @@</span>
  
      // Inner loop: blocks that picked up new live-out values to be propagated
      while (_worklist-&gt;size()) {
        Block* block = _worklist-&gt;pop();
        IndexSet *delta = getset(block);
<span class="udiff-line-modified-removed">-       assert( delta-&gt;count(), &quot;missing delta set&quot; );</span>
<span class="udiff-line-modified-added">+       assert(delta-&gt;count(), &quot;missing delta set&quot;);</span>
  
        // Add new-live-in to predecessors live-out sets
        for (uint l = 1; l &lt; block-&gt;num_preds(); l++) {
          Block* predecessor = _cfg.get_block_for_node(block-&gt;pred(l));
          add_liveout(predecessor, delta, first_pass);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -189,117 +189,122 @@</span>
  }
  #endif
  
  // Get an IndexSet for a block.  Return existing one, if any.  Make a new
  // empty one if a prior one does not exist.
<span class="udiff-line-modified-removed">- IndexSet *PhaseLive::getset( Block *p ) {</span>
<span class="udiff-line-modified-added">+ IndexSet *PhaseLive::getset(Block *p) {</span>
    IndexSet *delta = _deltas[p-&gt;_pre_order-1];
<span class="udiff-line-modified-removed">-   if( !delta )                  // Not on worklist?</span>
<span class="udiff-line-modified-added">+   if (!delta) {                 // Not on worklist?</span>
      // Get a free set; flag as being on worklist
      delta = _deltas[p-&gt;_pre_order-1] = getfreeset();
<span class="udiff-line-added">+   }</span>
    return delta;                 // Return set of new live-out items
  }
  
  // Pull from free list, or allocate.  Internal allocation on the returned set
  // is always from thread local storage.
<span class="udiff-line-modified-removed">- IndexSet *PhaseLive::getfreeset( ) {</span>
<span class="udiff-line-modified-added">+ IndexSet *PhaseLive::getfreeset() {</span>
    IndexSet *f = _free_IndexSet;
<span class="udiff-line-modified-removed">-   if( !f ) {</span>
<span class="udiff-line-modified-added">+   if (!f) {</span>
      f = new IndexSet;
<span class="udiff-line-removed">- //    f-&gt;set_arena(Thread::current()-&gt;resource_area());</span>
      f-&gt;initialize(_maxlrg, Thread::current()-&gt;resource_area());
    } else {
      // Pull from free list
      _free_IndexSet = f-&gt;next();
<span class="udiff-line-removed">-   //f-&gt;_cnt = 0;                        // Reset to empty</span>
<span class="udiff-line-removed">- //    f-&gt;set_arena(Thread::current()-&gt;resource_area());</span>
      f-&gt;initialize(_maxlrg, Thread::current()-&gt;resource_area());
    }
    return f;
  }
  
  // Free an IndexSet from a block.
<span class="udiff-line-modified-removed">- void PhaseLive::freeset( Block *p ) {</span>
<span class="udiff-line-modified-added">+ void PhaseLive::freeset(Block *p) {</span>
    IndexSet *f = _deltas[p-&gt;_pre_order-1];
<span class="udiff-line-modified-removed">-   if ( _keep_deltas ) {</span>
<span class="udiff-line-modified-added">+   if (_keep_deltas) {</span>
      add_livein(p, f);
    }
    f-&gt;set_next(_free_IndexSet);
    _free_IndexSet = f;           // Drop onto free list
    _deltas[p-&gt;_pre_order-1] = NULL;
  }
  
  // Add a live-out value to a given blocks live-out set.  If it is new, then
  // also add it to the delta set and stick the block on the worklist.
<span class="udiff-line-modified-removed">- void PhaseLive::add_liveout( Block *p, uint r, VectorSet &amp;first_pass ) {</span>
<span class="udiff-line-modified-added">+ void PhaseLive::add_liveout(Block *p, uint r, VectorSet &amp;first_pass) {</span>
    IndexSet *live = &amp;_live[p-&gt;_pre_order-1];
<span class="udiff-line-modified-removed">-   if( live-&gt;insert(r) ) {       // If actually inserted...</span>
<span class="udiff-line-modified-added">+   if (live-&gt;insert(r)) {        // If actually inserted...</span>
      // We extended the live-out set.  See if the value is generated locally.
      // If it is not, then we must extend the live-in set.
<span class="udiff-line-modified-removed">-     if( !_defs[p-&gt;_pre_order-1].member( r ) ) {</span>
<span class="udiff-line-modified-removed">-       if( !_deltas[p-&gt;_pre_order-1] &amp;&amp; // Not on worklist?</span>
<span class="udiff-line-modified-removed">-           first_pass.test(p-&gt;_pre_order) )</span>
<span class="udiff-line-modified-added">+     if (!_defs[p-&gt;_pre_order-1].member(r)) {</span>
<span class="udiff-line-modified-added">+       if (!_deltas[p-&gt;_pre_order-1] &amp;&amp; // Not on worklist?</span>
<span class="udiff-line-modified-added">+           first_pass.test(p-&gt;_pre_order)) {</span>
          _worklist-&gt;push(p);     // Actually go on worklist if already 1st pass
<span class="udiff-line-added">+       }</span>
        getset(p)-&gt;insert(r);
      }
    }
  }
  
  // Add a vector of live-out values to a given blocks live-out set.
<span class="udiff-line-modified-removed">- void PhaseLive::add_liveout( Block *p, IndexSet *lo, VectorSet &amp;first_pass ) {</span>
<span class="udiff-line-modified-added">+ void PhaseLive::add_liveout(Block *p, IndexSet *lo, VectorSet &amp;first_pass) {</span>
    IndexSet *live = &amp;_live[p-&gt;_pre_order-1];
    IndexSet *defs = &amp;_defs[p-&gt;_pre_order-1];
    IndexSet *on_worklist = _deltas[p-&gt;_pre_order-1];
    IndexSet *delta = on_worklist ? on_worklist : getfreeset();
  
<span class="udiff-line-modified-removed">-   IndexSetIterator elements(lo);</span>
<span class="udiff-line-modified-removed">-   uint r;</span>
<span class="udiff-line-modified-removed">-   while ((r = elements.next()) != 0) {</span>
<span class="udiff-line-modified-removed">-     if( live-&gt;insert(r) &amp;&amp;      // If actually inserted...</span>
<span class="udiff-line-modified-removed">-         !defs-&gt;member( r ) )    // and not defined locally</span>
<span class="udiff-line-modified-removed">-       delta-&gt;insert(r);         // Then add to live-in set</span>
<span class="udiff-line-modified-added">+   if (!lo-&gt;is_empty()) {</span>
<span class="udiff-line-modified-added">+     IndexSetIterator elements(lo);</span>
<span class="udiff-line-modified-added">+     uint r;</span>
<span class="udiff-line-modified-added">+     while ((r = elements.next()) != 0) {</span>
<span class="udiff-line-modified-added">+       if (live-&gt;insert(r) &amp;&amp;      // If actually inserted...</span>
<span class="udiff-line-modified-added">+           !defs-&gt;member(r)) {     // and not defined locally</span>
<span class="udiff-line-added">+         delta-&gt;insert(r);         // Then add to live-in set</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
    }
  
<span class="udiff-line-modified-removed">-   if( delta-&gt;count() ) {                // If actually added things</span>
<span class="udiff-line-modified-added">+   if (delta-&gt;count()) {                // If actually added things</span>
      _deltas[p-&gt;_pre_order-1] = delta; // Flag as on worklist now
<span class="udiff-line-modified-removed">-     if( !on_worklist &amp;&amp;         // Not on worklist?</span>
<span class="udiff-line-modified-removed">-         first_pass.test(p-&gt;_pre_order) )</span>
<span class="udiff-line-modified-added">+     if (!on_worklist &amp;&amp;         // Not on worklist?</span>
<span class="udiff-line-modified-added">+         first_pass.test(p-&gt;_pre_order)) {</span>
        _worklist-&gt;push(p);       // Actually go on worklist if already 1st pass
<span class="udiff-line-added">+     }</span>
    } else {                      // Nothing there; just free it
      delta-&gt;set_next(_free_IndexSet);
      _free_IndexSet = delta;     // Drop onto free list
    }
  }
  
  // Add a vector of live-in values to a given blocks live-in set.
  void PhaseLive::add_livein(Block *p, IndexSet *lo) {
    IndexSet *livein = &amp;_livein[p-&gt;_pre_order-1];
<span class="udiff-line-modified-removed">-   IndexSetIterator elements(lo);</span>
<span class="udiff-line-modified-removed">-   uint r;</span>
<span class="udiff-line-modified-removed">-   while ((r = elements.next()) != 0) {</span>
<span class="udiff-line-modified-removed">-     livein-&gt;insert(r);         // Then add to live-in set</span>
<span class="udiff-line-modified-added">+   if (!livein-&gt;is_empty()) {</span>
<span class="udiff-line-modified-added">+     IndexSetIterator elements(lo);</span>
<span class="udiff-line-modified-added">+     uint r;</span>
<span class="udiff-line-modified-added">+     while ((r = elements.next()) != 0) {</span>
<span class="udiff-line-added">+       livein-&gt;insert(r);         // Then add to live-in set</span>
<span class="udiff-line-added">+     }</span>
    }
  }
  
  #ifndef PRODUCT
  // Dump the live-out set for a block
<span class="udiff-line-modified-removed">- void PhaseLive::dump( const Block *b ) const {</span>
<span class="udiff-line-modified-added">+ void PhaseLive::dump(const Block *b) const {</span>
    tty-&gt;print(&quot;Block %d: &quot;,b-&gt;_pre_order);
<span class="udiff-line-modified-removed">-   if ( _keep_deltas ) {</span>
<span class="udiff-line-modified-added">+   if (_keep_deltas) {</span>
      tty-&gt;print(&quot;LiveIn: &quot;);  _livein[b-&gt;_pre_order-1].dump();
    }
    tty-&gt;print(&quot;LiveOut: &quot;);  _live[b-&gt;_pre_order-1].dump();
    uint cnt = b-&gt;number_of_nodes();
<span class="udiff-line-modified-removed">-   for( uint i=0; i&lt;cnt; i++ ) {</span>
<span class="udiff-line-modified-added">+   for (uint i = 0; i &lt; cnt; i++) {</span>
      tty-&gt;print(&quot;L%d/&quot;, _names.at(b-&gt;get_node(i)-&gt;_idx));
      b-&gt;get_node(i)-&gt;dump();
    }
    tty-&gt;print(&quot;\n&quot;);
  }
  
  // Verify that base pointers and derived pointers are still sane.
<span class="udiff-line-modified-removed">- void PhaseChaitin::verify_base_ptrs( ResourceArea *a ) const {</span>
<span class="udiff-line-modified-added">+ void PhaseChaitin::verify_base_ptrs(ResourceArea *a) const {</span>
  #ifdef ASSERT
    Unique_Node_List worklist(a);
    for (uint i = 0; i &lt; _cfg.number_of_blocks(); i++) {
      Block* block = _cfg.get_block(i);
      for (uint j = block-&gt;end_idx() + 1; j &gt; 1; j--) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -320,21 +325,21 @@</span>
                bool is_derived = ((idx - jvms-&gt;oopoff()) &amp; 1) == 0;
                // search upwards through spills and spill phis for AddP
                worklist.clear();
                worklist.push(check);
                uint k = 0;
<span class="udiff-line-modified-removed">-               while( k &lt; worklist.size() ) {</span>
<span class="udiff-line-modified-added">+               while (k &lt; worklist.size()) {</span>
                  check = worklist.at(k);
                  assert(check,&quot;Bad base or derived pointer&quot;);
                  // See PhaseChaitin::find_base_for_derived() for all cases.
                  int isc = check-&gt;is_Copy();
<span class="udiff-line-modified-removed">-                 if( isc ) {</span>
<span class="udiff-line-modified-added">+                 if (isc) {</span>
                    worklist.push(check-&gt;in(isc));
<span class="udiff-line-modified-removed">-                 } else if( check-&gt;is_Phi() ) {</span>
<span class="udiff-line-modified-added">+                 } else if (check-&gt;is_Phi()) {</span>
                    for (uint m = 1; m &lt; check-&gt;req(); m++)
                      worklist.push(check-&gt;in(m));
<span class="udiff-line-modified-removed">-                 } else if( check-&gt;is_Con() ) {</span>
<span class="udiff-line-modified-added">+                 } else if (check-&gt;is_Con()) {</span>
                    if (is_derived) {
                      // Derived is NULL+offset
                      assert(!is_derived || check-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::Null,&quot;Bad derived pointer&quot;);
                    } else {
                      assert(check-&gt;bottom_type()-&gt;is_ptr()-&gt;_offset == 0,&quot;Bad base pointer&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -344,12 +349,12 @@</span>
                      } else {
                        assert(check-&gt;Opcode() == Op_ConP &amp;&amp;
                               check-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::Null,&quot;Bad base pointer&quot;);
                      }
                    }
<span class="udiff-line-modified-removed">-                 } else if( check-&gt;bottom_type()-&gt;is_ptr()-&gt;_offset == 0 ) {</span>
<span class="udiff-line-modified-removed">-                   if(check-&gt;is_Proj() || (check-&gt;is_Mach() &amp;&amp;</span>
<span class="udiff-line-modified-added">+                 } else if (check-&gt;bottom_type()-&gt;is_ptr()-&gt;_offset == 0) {</span>
<span class="udiff-line-modified-added">+                   if (check-&gt;is_Proj() || (check-&gt;is_Mach() &amp;&amp;</span>
                       (check-&gt;as_Mach()-&gt;ideal_Opcode() == Op_CreateEx ||
                        check-&gt;as_Mach()-&gt;ideal_Opcode() == Op_ThreadLocal ||
                        check-&gt;as_Mach()-&gt;ideal_Opcode() == Op_CMoveP ||
                        check-&gt;as_Mach()-&gt;ideal_Opcode() == Op_CheckCastPP ||
  #ifdef _LP64
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -379,13 +384,13 @@</span>
    } // End of forall blocks
  #endif
  }
  
  // Verify that graphs and base pointers are still sane.
<span class="udiff-line-modified-removed">- void PhaseChaitin::verify( ResourceArea *a, bool verify_ifg ) const {</span>
<span class="udiff-line-modified-added">+ void PhaseChaitin::verify(ResourceArea *a, bool verify_ifg) const {</span>
  #ifdef ASSERT
<span class="udiff-line-modified-removed">-   if( VerifyOpto || VerifyRegisterAllocator ) {</span>
<span class="udiff-line-modified-added">+   if (VerifyRegisterAllocator) {</span>
      _cfg.verify();
      verify_base_ptrs(a);
      if(verify_ifg)
        _ifg-&gt;verify(this);
    }
</pre>
<center><a href="library_call.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="locknode.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/opto/loopPredicate.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;opto/loopnode.hpp&quot;
  27 #include &quot;opto/addnode.hpp&quot;
  28 #include &quot;opto/callnode.hpp&quot;
  29 #include &quot;opto/connode.hpp&quot;
  30 #include &quot;opto/convertnode.hpp&quot;
  31 #include &quot;opto/loopnode.hpp&quot;
  32 #include &quot;opto/matcher.hpp&quot;
  33 #include &quot;opto/mulnode.hpp&quot;
  34 #include &quot;opto/opaquenode.hpp&quot;
  35 #include &quot;opto/rootnode.hpp&quot;
  36 #include &quot;opto/subnode.hpp&quot;
  37 #include &lt;fenv.h&gt;
  38 #include &lt;math.h&gt;
  39 
  40 /*
  41  * The general idea of Loop Predication is to insert a predicate on the entry
  42  * path to a loop, and raise a uncommon trap if the check of the condition fails.
  43  * The condition checks are promoted from inside the loop body, and thus
  44  * the checks inside the loop could be eliminated. Currently, loop predication
  45  * optimization has been applied to remove array range check and loop invariant
  46  * checks (such as null checks).
  47 */
  48 
  49 //-------------------------------register_control-------------------------
  50 void PhaseIdealLoop::register_control(Node* n, IdealLoopTree *loop, Node* pred) {
  51   assert(n-&gt;is_CFG(), &quot;must be control node&quot;);
  52   _igvn.register_new_node_with_optimizer(n);
  53   loop-&gt;_body.push(n);
  54   set_loop(n, loop);
  55   // When called from beautify_loops() idom is not constructed yet.
  56   if (_idom != NULL) {
  57     set_idom(n, pred, dom_depth(pred));
  58   }
  59 }
  60 
  61 //------------------------------create_new_if_for_predicate------------------------
  62 // create a new if above the uct_if_pattern for the predicate to be promoted.
  63 //
  64 //          before                                after
  65 //        ----------                           ----------
  66 //           ctrl                                 ctrl
  67 //            |                                     |
  68 //            |                                     |
  69 //            v                                     v
  70 //           iff                                 new_iff
  71 //          /    \                                /      \
  72 //         /      \                              /        \
  73 //        v        v                            v          v
  74 //  uncommon_proj cont_proj                   if_uct     if_cont
  75 // \      |        |                           |          |
  76 //  \     |        |                           |          |
  77 //   v    v        v                           |          v
  78 //     rgn       loop                          |         iff
  79 //      |                                      |        /     \
  80 //      |                                      |       /       \
  81 //      v                                      |      v         v
  82 // uncommon_trap                               | uncommon_proj cont_proj
  83 //                                           \  \    |           |
  84 //                                            \  \   |           |
  85 //                                             v  v  v           v
  86 //                                               rgn           loop
  87 //                                                |
  88 //                                                |
  89 //                                                v
  90 //                                           uncommon_trap
  91 //
  92 //
  93 // We will create a region to guard the uct call if there is no one there.
  94 // The true projection (if_cont) of the new_iff is returned.
  95 // This code is also used to clone predicates to cloned loops.
  96 ProjNode* PhaseIdealLoop::create_new_if_for_predicate(ProjNode* cont_proj, Node* new_entry,
  97                                                       Deoptimization::DeoptReason reason,
  98                                                       int opcode) {
  99   assert(cont_proj-&gt;is_uncommon_trap_if_pattern(reason), &quot;must be a uct if pattern!&quot;);
 100   IfNode* iff = cont_proj-&gt;in(0)-&gt;as_If();
 101 
 102   ProjNode *uncommon_proj = iff-&gt;proj_out(1 - cont_proj-&gt;_con);
 103   Node     *rgn   = uncommon_proj-&gt;unique_ctrl_out();
 104   assert(rgn-&gt;is_Region() || rgn-&gt;is_Call(), &quot;must be a region or call uct&quot;);
 105 
 106   uint proj_index = 1; // region&#39;s edge corresponding to uncommon_proj
 107   if (!rgn-&gt;is_Region()) { // create a region to guard the call
 108     assert(rgn-&gt;is_Call(), &quot;must be call uct&quot;);
 109     CallNode* call = rgn-&gt;as_Call();
 110     IdealLoopTree* loop = get_loop(call);
 111     rgn = new RegionNode(1);
 112     rgn-&gt;add_req(uncommon_proj);
 113     register_control(rgn, loop, uncommon_proj);
 114     _igvn.replace_input_of(call, 0, rgn);
 115     // When called from beautify_loops() idom is not constructed yet.
 116     if (_idom != NULL) {
 117       set_idom(call, rgn, dom_depth(rgn));
 118     }
 119     for (DUIterator_Fast imax, i = uncommon_proj-&gt;fast_outs(imax); i &lt; imax; i++) {
 120       Node* n = uncommon_proj-&gt;fast_out(i);
 121       if (n-&gt;is_Load() || n-&gt;is_Store()) {
 122         _igvn.replace_input_of(n, 0, rgn);
 123         --i; --imax;
 124       }
 125     }
 126   } else {
 127     // Find region&#39;s edge corresponding to uncommon_proj
 128     for (; proj_index &lt; rgn-&gt;req(); proj_index++)
 129       if (rgn-&gt;in(proj_index) == uncommon_proj) break;
 130     assert(proj_index &lt; rgn-&gt;req(), &quot;sanity&quot;);
 131   }
 132 
 133   Node* entry = iff-&gt;in(0);
 134   if (new_entry != NULL) {
 135     // Clonning the predicate to new location.
 136     entry = new_entry;
 137   }
 138   // Create new_iff
 139   IdealLoopTree* lp = get_loop(entry);
 140   IfNode* new_iff = NULL;
 141   if (opcode == Op_If) {
 142     new_iff = new IfNode(entry, iff-&gt;in(1), iff-&gt;_prob, iff-&gt;_fcnt);
 143   } else {
 144     assert(opcode == Op_RangeCheck, &quot;no other if variant here&quot;);
 145     new_iff = new RangeCheckNode(entry, iff-&gt;in(1), iff-&gt;_prob, iff-&gt;_fcnt);
 146   }
 147   register_control(new_iff, lp, entry);
 148   Node *if_cont = new IfTrueNode(new_iff);
 149   Node *if_uct  = new IfFalseNode(new_iff);
 150   if (cont_proj-&gt;is_IfFalse()) {
 151     // Swap
 152     Node* tmp = if_uct; if_uct = if_cont; if_cont = tmp;
 153   }
 154   register_control(if_cont, lp, new_iff);
 155   register_control(if_uct, get_loop(rgn), new_iff);
 156 
 157   // if_uct to rgn
 158   _igvn.hash_delete(rgn);
 159   rgn-&gt;add_req(if_uct);
 160   // When called from beautify_loops() idom is not constructed yet.
 161   if (_idom != NULL) {
 162     Node* ridom = idom(rgn);
 163     Node* nrdom = dom_lca_internal(ridom, new_iff);
 164     set_idom(rgn, nrdom, dom_depth(rgn));
 165   }
 166 
 167   // If rgn has phis add new edges which has the same
 168   // value as on original uncommon_proj pass.
 169   assert(rgn-&gt;in(rgn-&gt;req() -1) == if_uct, &quot;new edge should be last&quot;);
 170   bool has_phi = false;
 171   for (DUIterator_Fast imax, i = rgn-&gt;fast_outs(imax); i &lt; imax; i++) {
 172     Node* use = rgn-&gt;fast_out(i);
 173     if (use-&gt;is_Phi() &amp;&amp; use-&gt;outcnt() &gt; 0) {
 174       assert(use-&gt;in(0) == rgn, &quot;&quot;);
 175       _igvn.rehash_node_delayed(use);
 176       use-&gt;add_req(use-&gt;in(proj_index));
 177       has_phi = true;
 178     }
 179   }
 180   assert(!has_phi || rgn-&gt;req() &gt; 3, &quot;no phis when region is created&quot;);
 181 
 182   if (new_entry == NULL) {
 183     // Attach if_cont to iff
 184     _igvn.replace_input_of(iff, 0, if_cont);
 185     if (_idom != NULL) {
 186       set_idom(iff, if_cont, dom_depth(iff));
 187     }
 188   }
 189   return if_cont-&gt;as_Proj();
 190 }
 191 
 192 //------------------------------create_new_if_for_predicate------------------------
 193 // Create a new if below new_entry for the predicate to be cloned (IGVN optimization)
 194 ProjNode* PhaseIterGVN::create_new_if_for_predicate(ProjNode* cont_proj, Node* new_entry,
 195                                                     Deoptimization::DeoptReason reason,
 196                                                     int opcode) {
 197   assert(new_entry != 0, &quot;only used for clone predicate&quot;);
 198   assert(cont_proj-&gt;is_uncommon_trap_if_pattern(reason), &quot;must be a uct if pattern!&quot;);
 199   IfNode* iff = cont_proj-&gt;in(0)-&gt;as_If();
 200 
 201   ProjNode *uncommon_proj = iff-&gt;proj_out(1 - cont_proj-&gt;_con);
 202   Node     *rgn   = uncommon_proj-&gt;unique_ctrl_out();
 203   assert(rgn-&gt;is_Region() || rgn-&gt;is_Call(), &quot;must be a region or call uct&quot;);
 204 
 205   uint proj_index = 1; // region&#39;s edge corresponding to uncommon_proj
 206   if (!rgn-&gt;is_Region()) { // create a region to guard the call
 207     assert(rgn-&gt;is_Call(), &quot;must be call uct&quot;);
 208     CallNode* call = rgn-&gt;as_Call();
 209     rgn = new RegionNode(1);
 210     register_new_node_with_optimizer(rgn);
 211     rgn-&gt;add_req(uncommon_proj);
 212     replace_input_of(call, 0, rgn);
 213   } else {
 214     // Find region&#39;s edge corresponding to uncommon_proj
 215     for (; proj_index &lt; rgn-&gt;req(); proj_index++)
 216       if (rgn-&gt;in(proj_index) == uncommon_proj) break;
 217     assert(proj_index &lt; rgn-&gt;req(), &quot;sanity&quot;);
 218   }
 219 
 220   // Create new_iff in new location.
 221   IfNode* new_iff = NULL;
 222   if (opcode == Op_If) {
 223     new_iff = new IfNode(new_entry, iff-&gt;in(1), iff-&gt;_prob, iff-&gt;_fcnt);
 224   } else {
 225     assert(opcode == Op_RangeCheck, &quot;no other if variant here&quot;);
 226     new_iff = new RangeCheckNode(new_entry, iff-&gt;in(1), iff-&gt;_prob, iff-&gt;_fcnt);
 227   }
 228 
 229   register_new_node_with_optimizer(new_iff);
 230   Node *if_cont = new IfTrueNode(new_iff);
 231   Node *if_uct  = new IfFalseNode(new_iff);
 232   if (cont_proj-&gt;is_IfFalse()) {
 233     // Swap
 234     Node* tmp = if_uct; if_uct = if_cont; if_cont = tmp;
 235   }
 236   register_new_node_with_optimizer(if_cont);
 237   register_new_node_with_optimizer(if_uct);
 238 
 239   // if_uct to rgn
 240   hash_delete(rgn);
 241   rgn-&gt;add_req(if_uct);
 242 
 243   // If rgn has phis add corresponding new edges which has the same
 244   // value as on original uncommon_proj pass.
 245   assert(rgn-&gt;in(rgn-&gt;req() -1) == if_uct, &quot;new edge should be last&quot;);
 246   bool has_phi = false;
 247   for (DUIterator_Fast imax, i = rgn-&gt;fast_outs(imax); i &lt; imax; i++) {
 248     Node* use = rgn-&gt;fast_out(i);
 249     if (use-&gt;is_Phi() &amp;&amp; use-&gt;outcnt() &gt; 0) {
 250       rehash_node_delayed(use);
 251       use-&gt;add_req(use-&gt;in(proj_index));
 252       has_phi = true;
 253     }
 254   }
 255   assert(!has_phi || rgn-&gt;req() &gt; 3, &quot;no phis when region is created&quot;);
 256 
 257   return if_cont-&gt;as_Proj();
 258 }
 259 
 260 //--------------------------clone_predicate-----------------------
 261 ProjNode* PhaseIdealLoop::clone_predicate(ProjNode* predicate_proj, Node* new_entry,
 262                                           Deoptimization::DeoptReason reason,
 263                                           PhaseIdealLoop* loop_phase,
 264                                           PhaseIterGVN* igvn) {
 265   ProjNode* new_predicate_proj;
 266   if (loop_phase != NULL) {
 267     new_predicate_proj = loop_phase-&gt;create_new_if_for_predicate(predicate_proj, new_entry, reason, Op_If);
 268   } else {
 269     new_predicate_proj =       igvn-&gt;create_new_if_for_predicate(predicate_proj, new_entry, reason, Op_If);
 270   }
 271   IfNode* iff = new_predicate_proj-&gt;in(0)-&gt;as_If();
 272   Node* ctrl  = iff-&gt;in(0);
 273 
 274   // Match original condition since predicate&#39;s projections could be swapped.
 275   assert(predicate_proj-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;Opcode()==Op_Opaque1, &quot;must be&quot;);
 276   Node* opq = new Opaque1Node(igvn-&gt;C, predicate_proj-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1));
 277   igvn-&gt;C-&gt;add_predicate_opaq(opq);
 278 
 279   Node* bol = new Conv2BNode(opq);
 280   if (loop_phase != NULL) {
 281     loop_phase-&gt;register_new_node(opq, ctrl);
 282     loop_phase-&gt;register_new_node(bol, ctrl);
 283   } else {
 284     igvn-&gt;register_new_node_with_optimizer(opq);
 285     igvn-&gt;register_new_node_with_optimizer(bol);
 286   }
 287   igvn-&gt;hash_delete(iff);
 288   iff-&gt;set_req(1, bol);
 289   return new_predicate_proj;
 290 }
 291 
 292 
 293 //--------------------------clone_loop_predicates-----------------------
 294 // Interface from IGVN
 295 Node* PhaseIterGVN::clone_loop_predicates(Node* old_entry, Node* new_entry, bool clone_limit_check) {
 296   return PhaseIdealLoop::clone_loop_predicates(old_entry, new_entry, clone_limit_check, NULL, this);
 297 }
 298 
 299 // Interface from PhaseIdealLoop
 300 Node* PhaseIdealLoop::clone_loop_predicates(Node* old_entry, Node* new_entry, bool clone_limit_check) {
 301   return clone_loop_predicates(old_entry, new_entry, clone_limit_check, this, &amp;this-&gt;_igvn);
 302 }
 303 
 304 // Clone loop predicates to cloned loops (peeled, unswitched, split_if).
 305 Node* PhaseIdealLoop::clone_loop_predicates(Node* old_entry, Node* new_entry,
 306                                             bool clone_limit_check,
 307                                             PhaseIdealLoop* loop_phase,
 308                                             PhaseIterGVN* igvn) {
 309 #ifdef ASSERT
 310   if (new_entry == NULL || !(new_entry-&gt;is_Proj() || new_entry-&gt;is_Region() || new_entry-&gt;is_SafePoint())) {
 311     if (new_entry != NULL)
 312       new_entry-&gt;dump();
 313     assert(false, &quot;not IfTrue, IfFalse, Region or SafePoint&quot;);
 314   }
 315 #endif
 316   // Search original predicates
 317   Node* entry = old_entry;
 318   ProjNode* limit_check_proj = NULL;
 319   limit_check_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
 320   if (limit_check_proj != NULL) {
 321     entry = skip_loop_predicates(entry);
 322   }
 323   ProjNode* profile_predicate_proj = NULL;
 324   ProjNode* predicate_proj = NULL;
 325   if (UseProfiledLoopPredicate) {
 326     profile_predicate_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);
 327     if (profile_predicate_proj != NULL) {
 328       entry = skip_loop_predicates(entry);
 329     }
 330   }
 331   if (UseLoopPredicate) {
 332     predicate_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
 333   }
 334   if (predicate_proj != NULL) { // right pattern that can be used by loop predication
 335     // clone predicate
 336     new_entry = clone_predicate(predicate_proj, new_entry,
 337                                 Deoptimization::Reason_predicate,
 338                                 loop_phase, igvn);
 339     assert(new_entry != NULL &amp;&amp; new_entry-&gt;is_Proj(), &quot;IfTrue or IfFalse after clone predicate&quot;);
 340     if (TraceLoopPredicate) {
 341       tty-&gt;print(&quot;Loop Predicate cloned: &quot;);
 342       debug_only( new_entry-&gt;in(0)-&gt;dump(); );
 343     }
 344   }
 345   if (profile_predicate_proj != NULL) { // right pattern that can be used by loop predication
 346     // clone predicate
 347     new_entry = clone_predicate(profile_predicate_proj, new_entry,
 348                                 Deoptimization::Reason_profile_predicate,
 349                                 loop_phase, igvn);
 350     assert(new_entry != NULL &amp;&amp; new_entry-&gt;is_Proj(), &quot;IfTrue or IfFalse after clone predicate&quot;);
 351     if (TraceLoopPredicate) {
 352       tty-&gt;print(&quot;Loop Predicate cloned: &quot;);
 353       debug_only( new_entry-&gt;in(0)-&gt;dump(); );
 354     }
 355   }
 356   if (limit_check_proj != NULL &amp;&amp; clone_limit_check) {
 357     // Clone loop limit check last to insert it before loop.
 358     // Don&#39;t clone a limit check which was already finalized
 359     // for this counted loop (only one limit check is needed).
 360     new_entry = clone_predicate(limit_check_proj, new_entry,
 361                                 Deoptimization::Reason_loop_limit_check,
 362                                 loop_phase, igvn);
 363     assert(new_entry != NULL &amp;&amp; new_entry-&gt;is_Proj(), &quot;IfTrue or IfFalse after clone limit check&quot;);
 364     if (TraceLoopLimitCheck) {
 365       tty-&gt;print(&quot;Loop Limit Check cloned: &quot;);
 366       debug_only( new_entry-&gt;in(0)-&gt;dump(); )
 367     }
 368   }
 369   return new_entry;
 370 }
 371 
 372 //--------------------------skip_loop_predicates------------------------------
 373 // Skip related predicates.
 374 Node* PhaseIdealLoop::skip_loop_predicates(Node* entry) {
 375   IfNode* iff = entry-&gt;in(0)-&gt;as_If();
 376   ProjNode* uncommon_proj = iff-&gt;proj_out(1 - entry-&gt;as_Proj()-&gt;_con);
 377   Node* rgn = uncommon_proj-&gt;unique_ctrl_out();
 378   assert(rgn-&gt;is_Region() || rgn-&gt;is_Call(), &quot;must be a region or call uct&quot;);
 379   entry = entry-&gt;in(0)-&gt;in(0);
 380   while (entry != NULL &amp;&amp; entry-&gt;is_Proj() &amp;&amp; entry-&gt;in(0)-&gt;is_If()) {
 381     uncommon_proj = entry-&gt;in(0)-&gt;as_If()-&gt;proj_out(1 - entry-&gt;as_Proj()-&gt;_con);
 382     if (uncommon_proj-&gt;unique_ctrl_out() != rgn)
 383       break;
 384     entry = entry-&gt;in(0)-&gt;in(0);
 385   }
 386   return entry;
 387 }
 388 
 389 Node* PhaseIdealLoop::skip_all_loop_predicates(Node* entry) {
 390   Node* predicate = NULL;
 391   predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
 392   if (predicate != NULL) {
 393     entry = skip_loop_predicates(entry);
 394   }
 395   if (UseProfiledLoopPredicate) {
 396     predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);
 397     if (predicate != NULL) { // right pattern that can be used by loop predication
 398       entry = skip_loop_predicates(entry);
 399     }
 400   }
 401   if (UseLoopPredicate) {
 402     predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
 403     if (predicate != NULL) { // right pattern that can be used by loop predication
 404       entry = skip_loop_predicates(entry);
 405     }
 406   }
 407   return entry;
 408 }
 409 
 410 //--------------------------find_predicate_insertion_point-------------------
 411 // Find a good location to insert a predicate
 412 ProjNode* PhaseIdealLoop::find_predicate_insertion_point(Node* start_c, Deoptimization::DeoptReason reason) {
 413   if (start_c == NULL || !start_c-&gt;is_Proj())
 414     return NULL;
 415   if (start_c-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(reason)) {
 416     return start_c-&gt;as_Proj();
 417   }
 418   return NULL;
 419 }
 420 
 421 //--------------------------find_predicate------------------------------------
 422 // Find a predicate
 423 Node* PhaseIdealLoop::find_predicate(Node* entry) {
 424   Node* predicate = NULL;
 425   predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
 426   if (predicate != NULL) { // right pattern that can be used by loop predication
 427     return entry;
 428   }
 429   if (UseLoopPredicate) {
 430     predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
 431     if (predicate != NULL) { // right pattern that can be used by loop predication
 432       return entry;
 433     }
 434   }
 435   if (UseProfiledLoopPredicate) {
 436     predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);
 437     if (predicate != NULL) { // right pattern that can be used by loop predication
 438       return entry;
 439     }
 440   }
 441   return NULL;
 442 }
 443 
 444 //------------------------------Invariance-----------------------------------
 445 // Helper class for loop_predication_impl to compute invariance on the fly and
 446 // clone invariants.
 447 class Invariance : public StackObj {
 448   VectorSet _visited, _invariant;
 449   Node_Stack _stack;
 450   VectorSet _clone_visited;
 451   Node_List _old_new; // map of old to new (clone)
 452   IdealLoopTree* _lpt;
 453   PhaseIdealLoop* _phase;
 454 
 455   // Helper function to set up the invariance for invariance computation
 456   // If n is a known invariant, set up directly. Otherwise, look up the
 457   // the possibility to push n onto the stack for further processing.
 458   void visit(Node* use, Node* n) {
 459     if (_lpt-&gt;is_invariant(n)) { // known invariant
 460       _invariant.set(n-&gt;_idx);
 461     } else if (!n-&gt;is_CFG()) {
 462       Node *n_ctrl = _phase-&gt;ctrl_or_self(n);
 463       Node *u_ctrl = _phase-&gt;ctrl_or_self(use); // self if use is a CFG
 464       if (_phase-&gt;is_dominator(n_ctrl, u_ctrl)) {
 465         _stack.push(n, n-&gt;in(0) == NULL ? 1 : 0);
 466       }
 467     }
 468   }
 469 
 470   // Compute invariance for &quot;the_node&quot; and (possibly) all its inputs recursively
 471   // on the fly
 472   void compute_invariance(Node* n) {
 473     assert(_visited.test(n-&gt;_idx), &quot;must be&quot;);
 474     visit(n, n);
 475     while (_stack.is_nonempty()) {
 476       Node*  n = _stack.node();
 477       uint idx = _stack.index();
 478       if (idx == n-&gt;req()) { // all inputs are processed
 479         _stack.pop();
 480         // n is invariant if it&#39;s inputs are all invariant
 481         bool all_inputs_invariant = true;
 482         for (uint i = 0; i &lt; n-&gt;req(); i++) {
 483           Node* in = n-&gt;in(i);
 484           if (in == NULL) continue;
 485           assert(_visited.test(in-&gt;_idx), &quot;must have visited input&quot;);
 486           if (!_invariant.test(in-&gt;_idx)) { // bad guy
 487             all_inputs_invariant = false;
 488             break;
 489           }
 490         }
 491         if (all_inputs_invariant) {
 492           // If n&#39;s control is a predicate that was moved out of the
 493           // loop, it was marked invariant but n is only invariant if
 494           // it depends only on that test. Otherwise, unless that test
 495           // is out of the loop, it&#39;s not invariant.
 496           if (n-&gt;is_CFG() || n-&gt;depends_only_on_test() || n-&gt;in(0) == NULL || !_phase-&gt;is_member(_lpt, n-&gt;in(0))) {
 497             _invariant.set(n-&gt;_idx); // I am a invariant too
 498           }
 499         }
 500       } else { // process next input
 501         _stack.set_index(idx + 1);
 502         Node* m = n-&gt;in(idx);
 503         if (m != NULL &amp;&amp; !_visited.test_set(m-&gt;_idx)) {
 504           visit(n, m);
 505         }
 506       }
 507     }
 508   }
 509 
 510   // Helper function to set up _old_new map for clone_nodes.
 511   // If n is a known invariant, set up directly (&quot;clone&quot; of n == n).
 512   // Otherwise, push n onto the stack for real cloning.
 513   void clone_visit(Node* n) {
 514     assert(_invariant.test(n-&gt;_idx), &quot;must be invariant&quot;);
 515     if (_lpt-&gt;is_invariant(n)) { // known invariant
 516       _old_new.map(n-&gt;_idx, n);
 517     } else { // to be cloned
 518       assert(!n-&gt;is_CFG(), &quot;should not see CFG here&quot;);
 519       _stack.push(n, n-&gt;in(0) == NULL ? 1 : 0);
 520     }
 521   }
 522 
 523   // Clone &quot;n&quot; and (possibly) all its inputs recursively
 524   void clone_nodes(Node* n, Node* ctrl) {
 525     clone_visit(n);
 526     while (_stack.is_nonempty()) {
 527       Node*  n = _stack.node();
 528       uint idx = _stack.index();
 529       if (idx == n-&gt;req()) { // all inputs processed, clone n!
 530         _stack.pop();
 531         // clone invariant node
 532         Node* n_cl = n-&gt;clone();
 533         _old_new.map(n-&gt;_idx, n_cl);
 534         _phase-&gt;register_new_node(n_cl, ctrl);
 535         for (uint i = 0; i &lt; n-&gt;req(); i++) {
 536           Node* in = n_cl-&gt;in(i);
 537           if (in == NULL) continue;
 538           n_cl-&gt;set_req(i, _old_new[in-&gt;_idx]);
 539         }
 540       } else { // process next input
 541         _stack.set_index(idx + 1);
 542         Node* m = n-&gt;in(idx);
 543         if (m != NULL &amp;&amp; !_clone_visited.test_set(m-&gt;_idx)) {
 544           clone_visit(m); // visit the input
 545         }
 546       }
 547     }
 548   }
 549 
 550  public:
 551   Invariance(Arena* area, IdealLoopTree* lpt) :
 552     _visited(area), _invariant(area),
 553     _stack(area, 10 /* guess */),
 554     _clone_visited(area), _old_new(area),
 555     _lpt(lpt), _phase(lpt-&gt;_phase)
 556   {
 557     LoopNode* head = _lpt-&gt;_head-&gt;as_Loop();
 558     Node* entry = head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
 559     if (entry-&gt;outcnt() != 1) {
 560       // If a node is pinned between the predicates and the loop
 561       // entry, we won&#39;t be able to move any node in the loop that
 562       // depends on it above it in a predicate. Mark all those nodes
 563       // as non loop invariatnt.
 564       Unique_Node_List wq;
 565       wq.push(entry);
 566       for (uint next = 0; next &lt; wq.size(); ++next) {
 567         Node *n = wq.at(next);
 568         for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
 569           Node* u = n-&gt;fast_out(i);
 570           if (!u-&gt;is_CFG()) {
 571             Node* c = _phase-&gt;get_ctrl(u);
 572             if (_lpt-&gt;is_member(_phase-&gt;get_loop(c)) || _phase-&gt;is_dominator(c, head)) {
 573               _visited.set(u-&gt;_idx);
 574               wq.push(u);
 575             }
 576           }
 577         }
 578       }
 579     }
 580   }
 581 
 582   // Map old to n for invariance computation and clone
 583   void map_ctrl(Node* old, Node* n) {
 584     assert(old-&gt;is_CFG() &amp;&amp; n-&gt;is_CFG(), &quot;must be&quot;);
 585     _old_new.map(old-&gt;_idx, n); // &quot;clone&quot; of old is n
 586     _invariant.set(old-&gt;_idx);  // old is invariant
 587     _clone_visited.set(old-&gt;_idx);
 588   }
 589 
 590   // Driver function to compute invariance
 591   bool is_invariant(Node* n) {
 592     if (!_visited.test_set(n-&gt;_idx))
 593       compute_invariance(n);
 594     return (_invariant.test(n-&gt;_idx) != 0);
 595   }
 596 
 597   // Driver function to clone invariant
 598   Node* clone(Node* n, Node* ctrl) {
 599     assert(ctrl-&gt;is_CFG(), &quot;must be&quot;);
 600     assert(_invariant.test(n-&gt;_idx), &quot;must be an invariant&quot;);
 601     if (!_clone_visited.test(n-&gt;_idx))
 602       clone_nodes(n, ctrl);
 603     return _old_new[n-&gt;_idx];
 604   }
 605 };
 606 
 607 //------------------------------is_range_check_if -----------------------------------
 608 // Returns true if the predicate of iff is in &quot;scale*iv + offset u&lt; load_range(ptr)&quot; format
 609 // Note: this function is particularly designed for loop predication. We require load_range
 610 //       and offset to be loop invariant computed on the fly by &quot;invar&quot;
 611 bool IdealLoopTree::is_range_check_if(IfNode *iff, PhaseIdealLoop *phase, Invariance&amp; invar) const {
 612   if (!is_loop_exit(iff)) {
 613     return false;
 614   }
 615   if (!iff-&gt;in(1)-&gt;is_Bool()) {
 616     return false;
 617   }
 618   const BoolNode *bol = iff-&gt;in(1)-&gt;as_Bool();
 619   if (bol-&gt;_test._test != BoolTest::lt) {
 620     return false;
 621   }
 622   if (!bol-&gt;in(1)-&gt;is_Cmp()) {
 623     return false;
 624   }
 625   const CmpNode *cmp = bol-&gt;in(1)-&gt;as_Cmp();
 626   if (cmp-&gt;Opcode() != Op_CmpU) {
 627     return false;
 628   }
 629   Node* range = cmp-&gt;in(2);
 630   if (range-&gt;Opcode() != Op_LoadRange &amp;&amp; !iff-&gt;is_RangeCheck()) {
 631     const TypeInt* tint = phase-&gt;_igvn.type(range)-&gt;isa_int();
 632     if (tint == NULL || tint-&gt;empty() || tint-&gt;_lo &lt; 0) {
 633       // Allow predication on positive values that aren&#39;t LoadRanges.
 634       // This allows optimization of loops where the length of the
 635       // array is a known value and doesn&#39;t need to be loaded back
 636       // from the array.
 637       return false;
 638     }
 639   }
 640   if (!invar.is_invariant(range)) {
 641     return false;
 642   }
 643   Node *iv     = _head-&gt;as_CountedLoop()-&gt;phi();
 644   int   scale  = 0;
 645   Node *offset = NULL;
 646   if (!phase-&gt;is_scaled_iv_plus_offset(cmp-&gt;in(1), iv, &amp;scale, &amp;offset)) {
 647     return false;
 648   }
 649   if (offset &amp;&amp; !invar.is_invariant(offset)) { // offset must be invariant
 650     return false;
 651   }
 652   return true;
 653 }
 654 
 655 //------------------------------rc_predicate-----------------------------------
 656 // Create a range check predicate
 657 //
 658 // for (i = init; i &lt; limit; i += stride) {
 659 //    a[scale*i+offset]
 660 // }
 661 //
 662 // Compute max(scale*i + offset) for init &lt;= i &lt; limit and build the predicate
 663 // as &quot;max(scale*i + offset) u&lt; a.length&quot;.
 664 //
 665 // There are two cases for max(scale*i + offset):
 666 // (1) stride*scale &gt; 0
 667 //   max(scale*i + offset) = scale*(limit-stride) + offset
 668 // (2) stride*scale &lt; 0
 669 //   max(scale*i + offset) = scale*init + offset
 670 BoolNode* PhaseIdealLoop::rc_predicate(IdealLoopTree *loop, Node* ctrl,
 671                                        int scale, Node* offset,
 672                                        Node* init, Node* limit, jint stride,
 673                                        Node* range, bool upper, bool &amp;overflow) {
 674   jint con_limit  = (limit != NULL &amp;&amp; limit-&gt;is_Con())  ? limit-&gt;get_int()  : 0;
 675   jint con_init   = init-&gt;is_Con()   ? init-&gt;get_int()   : 0;
 676   jint con_offset = offset-&gt;is_Con() ? offset-&gt;get_int() : 0;
 677 
 678   stringStream* predString = NULL;
 679   if (TraceLoopPredicate) {
 680     predString = new stringStream();
 681     predString-&gt;print(&quot;rc_predicate &quot;);
 682   }
 683 
 684   overflow = false;
 685   Node* max_idx_expr = NULL;
 686   const TypeInt* idx_type = TypeInt::INT;
 687   if ((stride &gt; 0) == (scale &gt; 0) == upper) {
 688     guarantee(limit != NULL, &quot;sanity&quot;);
 689     if (TraceLoopPredicate) {
 690       if (limit-&gt;is_Con()) {
 691         predString-&gt;print(&quot;(%d &quot;, con_limit);
 692       } else {
 693         predString-&gt;print(&quot;(limit &quot;);
 694       }
 695       predString-&gt;print(&quot;- %d) &quot;, stride);
 696     }
 697     // Check if (limit - stride) may overflow
 698     const TypeInt* limit_type = _igvn.type(limit)-&gt;isa_int();
 699     jint limit_lo = limit_type-&gt;_lo;
 700     jint limit_hi = limit_type-&gt;_hi;
 701     if ((stride &gt; 0 &amp;&amp; (java_subtract(limit_lo, stride) &lt; limit_lo)) ||
 702         (stride &lt; 0 &amp;&amp; (java_subtract(limit_hi, stride) &gt; limit_hi))) {
 703       // No overflow possible
 704       ConINode* con_stride = _igvn.intcon(stride);
 705       set_ctrl(con_stride, C-&gt;root());
 706       max_idx_expr = new SubINode(limit, con_stride);
 707       idx_type = TypeInt::make(limit_lo - stride, limit_hi - stride, limit_type-&gt;_widen);
 708     } else {
 709       // May overflow
 710       overflow = true;
 711       limit = new ConvI2LNode(limit);
 712       register_new_node(limit, ctrl);
 713       ConLNode* con_stride = _igvn.longcon(stride);
 714       set_ctrl(con_stride, C-&gt;root());
 715       max_idx_expr = new SubLNode(limit, con_stride);
 716     }
 717     register_new_node(max_idx_expr, ctrl);
 718   } else {
 719     if (TraceLoopPredicate) {
 720       if (init-&gt;is_Con()) {
 721         predString-&gt;print(&quot;%d &quot;, con_init);
 722       } else {
 723         predString-&gt;print(&quot;init &quot;);
 724       }
 725     }
 726     idx_type = _igvn.type(init)-&gt;isa_int();
 727     max_idx_expr = init;
 728   }
 729 
 730   if (scale != 1) {
 731     ConNode* con_scale = _igvn.intcon(scale);
 732     set_ctrl(con_scale, C-&gt;root());
 733     if (TraceLoopPredicate) {
 734       predString-&gt;print(&quot;* %d &quot;, scale);
 735     }
 736     // Check if (scale * max_idx_expr) may overflow
 737     const TypeInt* scale_type = TypeInt::make(scale);
 738     MulINode* mul = new MulINode(max_idx_expr, con_scale);
 739     idx_type = (TypeInt*)mul-&gt;mul_ring(idx_type, scale_type);
 740     if (overflow || TypeInt::INT-&gt;higher_equal(idx_type)) {
 741       // May overflow
 742       mul-&gt;destruct();
 743       if (!overflow) {
 744         max_idx_expr = new ConvI2LNode(max_idx_expr);
 745         register_new_node(max_idx_expr, ctrl);
 746       }
 747       overflow = true;
 748       con_scale = _igvn.longcon(scale);
 749       set_ctrl(con_scale, C-&gt;root());
 750       max_idx_expr = new MulLNode(max_idx_expr, con_scale);
 751     } else {
 752       // No overflow possible
 753       max_idx_expr = mul;
 754     }
 755     register_new_node(max_idx_expr, ctrl);
 756   }
 757 
 758   if (offset &amp;&amp; (!offset-&gt;is_Con() || con_offset != 0)){
 759     if (TraceLoopPredicate) {
 760       if (offset-&gt;is_Con()) {
 761         predString-&gt;print(&quot;+ %d &quot;, con_offset);
 762       } else {
 763         predString-&gt;print(&quot;+ offset&quot;);
 764       }
 765     }
 766     // Check if (max_idx_expr + offset) may overflow
 767     const TypeInt* offset_type = _igvn.type(offset)-&gt;isa_int();
 768     jint lo = java_add(idx_type-&gt;_lo, offset_type-&gt;_lo);
 769     jint hi = java_add(idx_type-&gt;_hi, offset_type-&gt;_hi);
 770     if (overflow || (lo &gt; hi) ||
 771         ((idx_type-&gt;_lo &amp; offset_type-&gt;_lo) &lt; 0 &amp;&amp; lo &gt;= 0) ||
 772         ((~(idx_type-&gt;_hi | offset_type-&gt;_hi)) &lt; 0 &amp;&amp; hi &lt; 0)) {
 773       // May overflow
 774       if (!overflow) {
 775         max_idx_expr = new ConvI2LNode(max_idx_expr);
 776         register_new_node(max_idx_expr, ctrl);
 777       }
 778       overflow = true;
 779       offset = new ConvI2LNode(offset);
 780       register_new_node(offset, ctrl);
 781       max_idx_expr = new AddLNode(max_idx_expr, offset);
 782     } else {
 783       // No overflow possible
 784       max_idx_expr = new AddINode(max_idx_expr, offset);
 785     }
 786     register_new_node(max_idx_expr, ctrl);
 787   }
 788 
 789   CmpNode* cmp = NULL;
 790   if (overflow) {
 791     // Integer expressions may overflow, do long comparison
 792     range = new ConvI2LNode(range);
 793     register_new_node(range, ctrl);
 794     cmp = new CmpULNode(max_idx_expr, range);
 795   } else {
 796     cmp = new CmpUNode(max_idx_expr, range);
 797   }
 798   register_new_node(cmp, ctrl);
 799   BoolNode* bol = new BoolNode(cmp, BoolTest::lt);
 800   register_new_node(bol, ctrl);
 801 
 802   if (TraceLoopPredicate) {
 803     predString-&gt;print_cr(&quot;&lt;u range&quot;);
 804     tty-&gt;print(&quot;%s&quot;, predString-&gt;base());
 805     predString-&gt;~stringStream();
 806   }
 807   return bol;
 808 }
 809 
 810 // Should loop predication look not only in the path from tail to head
 811 // but also in branches of the loop body?
 812 bool PhaseIdealLoop::loop_predication_should_follow_branches(IdealLoopTree *loop, ProjNode *predicate_proj, float&amp; loop_trip_cnt) {
 813   if (!UseProfiledLoopPredicate) {
 814     return false;
 815   }
 816 
 817   if (predicate_proj == NULL) {
 818     return false;
 819   }
 820 
 821   LoopNode* head = loop-&gt;_head-&gt;as_Loop();
 822   bool follow_branches = true;
 823   IdealLoopTree* l = loop-&gt;_child;
 824   // For leaf loops and loops with a single inner loop
 825   while (l != NULL &amp;&amp; follow_branches) {
 826     IdealLoopTree* child = l;
 827     if (child-&gt;_child != NULL &amp;&amp;
 828         child-&gt;_head-&gt;is_OuterStripMinedLoop()) {
 829       assert(child-&gt;_child-&gt;_next == NULL, &quot;only one inner loop for strip mined loop&quot;);
 830       assert(child-&gt;_child-&gt;_head-&gt;is_CountedLoop() &amp;&amp; child-&gt;_child-&gt;_head-&gt;as_CountedLoop()-&gt;is_strip_mined(), &quot;inner loop should be strip mined&quot;);
 831       child = child-&gt;_child;
 832     }
 833     if (child-&gt;_child != NULL || child-&gt;_irreducible) {
 834       follow_branches = false;
 835     }
 836     l = l-&gt;_next;
 837   }
 838   if (follow_branches) {
 839     loop-&gt;compute_profile_trip_cnt(this);
 840     if (head-&gt;is_profile_trip_failed()) {
 841       follow_branches = false;
 842     } else {
 843       loop_trip_cnt = head-&gt;profile_trip_cnt();
 844       if (head-&gt;is_CountedLoop()) {
 845         CountedLoopNode* cl = head-&gt;as_CountedLoop();
 846         if (cl-&gt;phi() != NULL) {
 847           const TypeInt* t = _igvn.type(cl-&gt;phi())-&gt;is_int();
 848           float worst_case_trip_cnt = ((float)t-&gt;_hi - t-&gt;_lo) / ABS(cl-&gt;stride_con());
 849           if (worst_case_trip_cnt &lt; loop_trip_cnt) {
 850             loop_trip_cnt = worst_case_trip_cnt;
 851           }
 852         }
 853       }
 854     }
 855   }
 856   return follow_branches;
 857 }
 858 
 859 // Compute probability of reaching some CFG node from a fixed
 860 // dominating CFG node
 861 class PathFrequency {
 862 private:
 863   Node* _dom; // frequencies are computed relative to this node
 864   Node_Stack _stack;
 865   GrowableArray&lt;float&gt; _freqs_stack; // keep track of intermediate result at regions
 866   GrowableArray&lt;float&gt; _freqs; // cache frequencies
 867   PhaseIdealLoop* _phase;
 868 
 869   void set_rounding(int mode) {
 870     // fesetround is broken on windows
 871     NOT_WINDOWS(fesetround(mode);)
 872   }
 873 
 874   void check_frequency(float f) {
 875     NOT_WINDOWS(assert(f &lt;= 1 &amp;&amp; f &gt;= 0, &quot;Incorrect frequency&quot;);)
 876   }
 877 
 878 public:
 879   PathFrequency(Node* dom, PhaseIdealLoop* phase)
 880     : _dom(dom), _stack(0), _phase(phase) {
 881   }
 882 
 883   float to(Node* n) {
 884     // post order walk on the CFG graph from n to _dom
 885     set_rounding(FE_TOWARDZERO); // make sure rounding doesn&#39;t push frequency above 1
 886     IdealLoopTree* loop = _phase-&gt;get_loop(_dom);
 887     Node* c = n;
 888     for (;;) {
 889       assert(_phase-&gt;get_loop(c) == loop, &quot;have to be in the same loop&quot;);
 890       if (c == _dom || _freqs.at_grow(c-&gt;_idx, -1) &gt;= 0) {
 891         float f = c == _dom ? 1 : _freqs.at(c-&gt;_idx);
 892         Node* prev = c;
 893         while (_stack.size() &gt; 0 &amp;&amp; prev == c) {
 894           Node* n = _stack.node();
 895           if (!n-&gt;is_Region()) {
 896             if (_phase-&gt;get_loop(n) != _phase-&gt;get_loop(n-&gt;in(0))) {
 897               // Found an inner loop: compute frequency of reaching this
 898               // exit from the loop head by looking at the number of
 899               // times each loop exit was taken
 900               IdealLoopTree* inner_loop = _phase-&gt;get_loop(n-&gt;in(0));
 901               LoopNode* inner_head = inner_loop-&gt;_head-&gt;as_Loop();
 902               assert(_phase-&gt;get_loop(n) == loop, &quot;only 1 inner loop&quot;);
 903               if (inner_head-&gt;is_OuterStripMinedLoop()) {
 904                 inner_head-&gt;verify_strip_mined(1);
 905                 if (n-&gt;in(0) == inner_head-&gt;in(LoopNode::LoopBackControl)-&gt;in(0)) {
 906                   n = n-&gt;in(0)-&gt;in(0)-&gt;in(0);
 907                 }
 908                 inner_loop = inner_loop-&gt;_child;
 909                 inner_head = inner_loop-&gt;_head-&gt;as_Loop();
 910                 inner_head-&gt;verify_strip_mined(1);
 911               }
 912               set_rounding(FE_UPWARD);  // make sure rounding doesn&#39;t push frequency above 1
 913               float loop_exit_cnt = 0.0f;
 914               for (uint i = 0; i &lt; inner_loop-&gt;_body.size(); i++) {
 915                 Node *n = inner_loop-&gt;_body[i];
 916                 float c = inner_loop-&gt;compute_profile_trip_cnt_helper(n);
 917                 loop_exit_cnt += c;
 918               }
 919               set_rounding(FE_TOWARDZERO);
 920               float cnt = -1;
 921               if (n-&gt;in(0)-&gt;is_If()) {
 922                 IfNode* iff = n-&gt;in(0)-&gt;as_If();
 923                 float p = n-&gt;in(0)-&gt;as_If()-&gt;_prob;
 924                 if (n-&gt;Opcode() == Op_IfFalse) {
 925                   p = 1 - p;
 926                 }
 927                 if (p &gt; PROB_MIN) {
 928                   cnt = p * iff-&gt;_fcnt;
 929                 } else {
 930                   cnt = 0;
 931                 }
 932               } else {
 933                 assert(n-&gt;in(0)-&gt;is_Jump(), &quot;unsupported node kind&quot;);
 934                 JumpNode* jmp = n-&gt;in(0)-&gt;as_Jump();
 935                 float p = n-&gt;in(0)-&gt;as_Jump()-&gt;_probs[n-&gt;as_JumpProj()-&gt;_con];
 936                 cnt = p * jmp-&gt;_fcnt;
 937               }
 938               float this_exit_f = cnt &gt; 0 ? cnt / loop_exit_cnt : 0;
 939               check_frequency(this_exit_f);
 940               f = f * this_exit_f;
 941               check_frequency(f);
 942             } else {
 943               float p = -1;
 944               if (n-&gt;in(0)-&gt;is_If()) {
 945                 p = n-&gt;in(0)-&gt;as_If()-&gt;_prob;
 946                 if (n-&gt;Opcode() == Op_IfFalse) {
 947                   p = 1 - p;
 948                 }
 949               } else {
 950                 assert(n-&gt;in(0)-&gt;is_Jump(), &quot;unsupported node kind&quot;);
 951                 p = n-&gt;in(0)-&gt;as_Jump()-&gt;_probs[n-&gt;as_JumpProj()-&gt;_con];
 952               }
 953               f = f * p;
 954               check_frequency(f);
 955             }
 956             _freqs.at_put_grow(n-&gt;_idx, (float)f, -1);
 957             _stack.pop();
 958           } else {
 959             float prev_f = _freqs_stack.pop();
 960             float new_f = f;
 961             f = new_f + prev_f;
 962             check_frequency(f);
 963             uint i = _stack.index();
 964             if (i &lt; n-&gt;req()) {
 965               c = n-&gt;in(i);
 966               _stack.set_index(i+1);
 967               _freqs_stack.push(f);
 968             } else {
 969               _freqs.at_put_grow(n-&gt;_idx, f, -1);
 970               _stack.pop();
 971             }
 972           }
 973         }
 974         if (_stack.size() == 0) {
 975           set_rounding(FE_TONEAREST);
 976           check_frequency(f);
 977           return f;
 978         }
 979       } else if (c-&gt;is_Loop()) {
 980         ShouldNotReachHere();
 981         c = c-&gt;in(LoopNode::EntryControl);
 982       } else if (c-&gt;is_Region()) {
 983         _freqs_stack.push(0);
 984         _stack.push(c, 2);
 985         c = c-&gt;in(1);
 986       } else {
 987         if (c-&gt;is_IfProj()) {
 988           IfNode* iff = c-&gt;in(0)-&gt;as_If();
 989           if (iff-&gt;_prob == PROB_UNKNOWN) {
 990             // assume never taken
 991             _freqs.at_put_grow(c-&gt;_idx, 0, -1);
 992           } else if (_phase-&gt;get_loop(c) != _phase-&gt;get_loop(iff)) {
 993             if (iff-&gt;_fcnt == COUNT_UNKNOWN) {
 994               // assume never taken
 995               _freqs.at_put_grow(c-&gt;_idx, 0, -1);
 996             } else {
 997               // skip over loop
 998               _stack.push(c, 1);
 999               c = _phase-&gt;get_loop(c-&gt;in(0))-&gt;_head-&gt;as_Loop()-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
1000             }
1001           } else {
1002             _stack.push(c, 1);
1003             c = iff;
1004           }
1005         } else if (c-&gt;is_JumpProj()) {
1006           JumpNode* jmp = c-&gt;in(0)-&gt;as_Jump();
1007           if (_phase-&gt;get_loop(c) != _phase-&gt;get_loop(jmp)) {
1008             if (jmp-&gt;_fcnt == COUNT_UNKNOWN) {
1009               // assume never taken
1010               _freqs.at_put_grow(c-&gt;_idx, 0, -1);
1011             } else {
1012               // skip over loop
1013               _stack.push(c, 1);
1014               c = _phase-&gt;get_loop(c-&gt;in(0))-&gt;_head-&gt;as_Loop()-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
1015             }
1016           } else {
1017             _stack.push(c, 1);
1018             c = jmp;
1019           }
1020         } else if (c-&gt;Opcode() == Op_CatchProj &amp;&amp;
1021                    c-&gt;in(0)-&gt;Opcode() == Op_Catch &amp;&amp;
1022                    c-&gt;in(0)-&gt;in(0)-&gt;is_Proj() &amp;&amp;
1023                    c-&gt;in(0)-&gt;in(0)-&gt;in(0)-&gt;is_Call()) {
1024           // assume exceptions are never thrown
1025           uint con = c-&gt;as_Proj()-&gt;_con;
1026           if (con == CatchProjNode::fall_through_index) {
1027             Node* call = c-&gt;in(0)-&gt;in(0)-&gt;in(0)-&gt;in(0);
1028             if (_phase-&gt;get_loop(call) != _phase-&gt;get_loop(c)) {
1029               _freqs.at_put_grow(c-&gt;_idx, 0, -1);
1030             } else {
1031               c = call;
1032             }
1033           } else {
1034             assert(con &gt;= CatchProjNode::catch_all_index, &quot;what else?&quot;);
1035             _freqs.at_put_grow(c-&gt;_idx, 0, -1);
1036           }
1037         } else if (c-&gt;unique_ctrl_out() == NULL &amp;&amp; !c-&gt;is_If() &amp;&amp; !c-&gt;is_Jump()) {
1038           ShouldNotReachHere();
1039         } else {
1040           c = c-&gt;in(0);
1041         }
1042       }
1043     }
1044     ShouldNotReachHere();
1045     return -1;
1046   }
1047 };
1048 
1049 void PhaseIdealLoop::loop_predication_follow_branches(Node *n, IdealLoopTree *loop, float loop_trip_cnt,
1050                                                       PathFrequency&amp; pf, Node_Stack&amp; stack, VectorSet&amp; seen,
1051                                                       Node_List&amp; if_proj_list) {
1052   assert(n-&gt;is_Region(), &quot;start from a region&quot;);
1053   Node* tail = loop-&gt;tail();
1054   stack.push(n, 1);
1055   do {
1056     Node* c = stack.node();
1057     assert(c-&gt;is_Region() || c-&gt;is_IfProj(), &quot;only region here&quot;);
1058     uint i = stack.index();
1059 
1060     if (i &lt; c-&gt;req()) {
1061       stack.set_index(i+1);
1062       Node* in = c-&gt;in(i);
1063       while (!is_dominator(in, tail) &amp;&amp; !seen.test_set(in-&gt;_idx)) {
1064         IdealLoopTree* in_loop = get_loop(in);
1065         if (in_loop != loop) {
1066           in = in_loop-&gt;_head-&gt;in(LoopNode::EntryControl);
1067         } else if (in-&gt;is_Region()) {
1068           stack.push(in, 1);
1069           break;
1070         } else if (in-&gt;is_IfProj() &amp;&amp;
1071                    in-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;
1072                    (in-&gt;in(0)-&gt;Opcode() == Op_If ||
1073                     in-&gt;in(0)-&gt;Opcode() == Op_RangeCheck)) {
1074           if (pf.to(in) * loop_trip_cnt &gt;= 1) {
1075             stack.push(in, 1);
1076           }
1077           in = in-&gt;in(0);
1078         } else {
1079           in = in-&gt;in(0);
1080         }
1081       }
1082     } else {
1083       if (c-&gt;is_IfProj()) {
1084         if_proj_list.push(c);
1085       }
1086       stack.pop();
1087     }
1088 
1089   } while (stack.size() &gt; 0);
1090 }
1091 
1092 
1093 bool PhaseIdealLoop::loop_predication_impl_helper(IdealLoopTree *loop, ProjNode* proj, ProjNode *predicate_proj,
1094                                                   CountedLoopNode *cl, ConNode* zero, Invariance&amp; invar,
1095                                                   Deoptimization::DeoptReason reason) {
1096   // Following are changed to nonnull when a predicate can be hoisted
1097   ProjNode* new_predicate_proj = NULL;
1098   IfNode*   iff  = proj-&gt;in(0)-&gt;as_If();
1099   Node*     test = iff-&gt;in(1);
1100   if (!test-&gt;is_Bool()){ //Conv2B, ...
1101     return false;
1102   }
1103   BoolNode* bol = test-&gt;as_Bool();
1104   if (invar.is_invariant(bol)) {
1105     // Invariant test
1106     new_predicate_proj = create_new_if_for_predicate(predicate_proj, NULL,
1107                                                      reason,
1108                                                      iff-&gt;Opcode());
1109     Node* ctrl = new_predicate_proj-&gt;in(0)-&gt;as_If()-&gt;in(0);
1110     BoolNode* new_predicate_bol = invar.clone(bol, ctrl)-&gt;as_Bool();
1111 
1112     // Negate test if necessary
1113     bool negated = false;
1114     if (proj-&gt;_con != predicate_proj-&gt;_con) {
1115       new_predicate_bol = new BoolNode(new_predicate_bol-&gt;in(1), new_predicate_bol-&gt;_test.negate());
1116       register_new_node(new_predicate_bol, ctrl);
1117       negated = true;
1118     }
1119     IfNode* new_predicate_iff = new_predicate_proj-&gt;in(0)-&gt;as_If();
1120     _igvn.hash_delete(new_predicate_iff);
1121     new_predicate_iff-&gt;set_req(1, new_predicate_bol);
1122 #ifndef PRODUCT
1123     if (TraceLoopPredicate) {
1124       tty-&gt;print(&quot;Predicate invariant if%s: %d &quot;, negated ? &quot; negated&quot; : &quot;&quot;, new_predicate_iff-&gt;_idx);
1125       loop-&gt;dump_head();
1126     } else if (TraceLoopOpts) {
1127       tty-&gt;print(&quot;Predicate IC &quot;);
1128       loop-&gt;dump_head();
1129     }
1130 #endif
1131   } else if (cl != NULL &amp;&amp; loop-&gt;is_range_check_if(iff, this, invar)) {
1132     // Range check for counted loops
1133     const Node*    cmp    = bol-&gt;in(1)-&gt;as_Cmp();
1134     Node*          idx    = cmp-&gt;in(1);
1135     assert(!invar.is_invariant(idx), &quot;index is variant&quot;);
1136     Node* rng = cmp-&gt;in(2);
1137     assert(rng-&gt;Opcode() == Op_LoadRange || iff-&gt;is_RangeCheck() || _igvn.type(rng)-&gt;is_int()-&gt;_lo &gt;= 0, &quot;must be&quot;);
1138     assert(invar.is_invariant(rng), &quot;range must be invariant&quot;);
1139     int scale    = 1;
1140     Node* offset = zero;
1141     bool ok = is_scaled_iv_plus_offset(idx, cl-&gt;phi(), &amp;scale, &amp;offset);
1142     assert(ok, &quot;must be index expression&quot;);
1143 
1144     Node* init    = cl-&gt;init_trip();
1145     // Limit is not exact.
1146     // Calculate exact limit here.
1147     // Note, counted loop&#39;s test is &#39;&lt;&#39; or &#39;&gt;&#39;.
1148     Node* limit   = exact_limit(loop);
1149     int  stride   = cl-&gt;stride()-&gt;get_int();
1150 
1151     // Build if&#39;s for the upper and lower bound tests.  The
1152     // lower_bound test will dominate the upper bound test and all
1153     // cloned or created nodes will use the lower bound test as
1154     // their declared control.
1155 
1156     // Perform cloning to keep Invariance state correct since the
1157     // late schedule will place invariant things in the loop.
1158     Node *ctrl = predicate_proj-&gt;in(0)-&gt;as_If()-&gt;in(0);
1159     rng = invar.clone(rng, ctrl);
1160     if (offset &amp;&amp; offset != zero) {
1161       assert(invar.is_invariant(offset), &quot;offset must be loop invariant&quot;);
1162       offset = invar.clone(offset, ctrl);
1163     }
1164     // If predicate expressions may overflow in the integer range, longs are used.
1165     bool overflow = false;
1166 
1167     // Test the lower bound
1168     BoolNode* lower_bound_bol = rc_predicate(loop, ctrl, scale, offset, init, limit, stride, rng, false, overflow);
1169     // Negate test if necessary
1170     bool negated = false;
1171     if (proj-&gt;_con != predicate_proj-&gt;_con) {
1172       lower_bound_bol = new BoolNode(lower_bound_bol-&gt;in(1), lower_bound_bol-&gt;_test.negate());
1173       register_new_node(lower_bound_bol, ctrl);
1174       negated = true;
1175     }
1176     ProjNode* lower_bound_proj = create_new_if_for_predicate(predicate_proj, NULL, reason, overflow ? Op_If : iff-&gt;Opcode());
1177     IfNode* lower_bound_iff = lower_bound_proj-&gt;in(0)-&gt;as_If();
1178     _igvn.hash_delete(lower_bound_iff);
1179     lower_bound_iff-&gt;set_req(1, lower_bound_bol);
1180     if (TraceLoopPredicate) tty-&gt;print_cr(&quot;lower bound check if: %s %d &quot;, negated ? &quot; negated&quot; : &quot;&quot;, lower_bound_iff-&gt;_idx);
1181 
1182     // Test the upper bound
1183     BoolNode* upper_bound_bol = rc_predicate(loop, lower_bound_proj, scale, offset, init, limit, stride, rng, true, overflow);
1184     negated = false;
1185     if (proj-&gt;_con != predicate_proj-&gt;_con) {
1186       upper_bound_bol = new BoolNode(upper_bound_bol-&gt;in(1), upper_bound_bol-&gt;_test.negate());
1187       register_new_node(upper_bound_bol, ctrl);
1188       negated = true;
1189     }
1190     ProjNode* upper_bound_proj = create_new_if_for_predicate(predicate_proj, NULL, reason, overflow ? Op_If : iff-&gt;Opcode());
1191     assert(upper_bound_proj-&gt;in(0)-&gt;as_If()-&gt;in(0) == lower_bound_proj, &quot;should dominate&quot;);
1192     IfNode* upper_bound_iff = upper_bound_proj-&gt;in(0)-&gt;as_If();
1193     _igvn.hash_delete(upper_bound_iff);
1194     upper_bound_iff-&gt;set_req(1, upper_bound_bol);
1195     if (TraceLoopPredicate) tty-&gt;print_cr(&quot;upper bound check if: %s %d &quot;, negated ? &quot; negated&quot; : &quot;&quot;, lower_bound_iff-&gt;_idx);
1196 
1197     // Fall through into rest of the clean up code which will move
1198     // any dependent nodes onto the upper bound test.
1199     new_predicate_proj = upper_bound_proj;
1200 
1201     if (iff-&gt;is_RangeCheck()) {
1202       new_predicate_proj = insert_skeleton_predicate(iff, loop, proj, predicate_proj, upper_bound_proj, scale, offset, init, limit, stride, rng, overflow, reason);
1203     }
1204 
1205 #ifndef PRODUCT
1206     if (TraceLoopOpts &amp;&amp; !TraceLoopPredicate) {
1207       tty-&gt;print(&quot;Predicate RC &quot;);
1208       loop-&gt;dump_head();
1209     }
1210 #endif
1211   } else {
1212     // Loop variant check (for example, range check in non-counted loop)
1213     // with uncommon trap.
1214     return false;
1215   }
1216   assert(new_predicate_proj != NULL, &quot;sanity&quot;);
1217   // Success - attach condition (new_predicate_bol) to predicate if
1218   invar.map_ctrl(proj, new_predicate_proj); // so that invariance test can be appropriate
1219 
1220   // Eliminate the old If in the loop body
1221   dominated_by( new_predicate_proj, iff, proj-&gt;_con != new_predicate_proj-&gt;_con );
1222 
1223   C-&gt;set_major_progress();
1224   return true;
1225 }
1226 
1227 
1228 // After pre/main/post loops are created, we&#39;ll put a copy of some
1229 // range checks between the pre and main loop to validate the value
1230 // of the main loop induction variable. Make a copy of the predicates
1231 // here with an opaque node as a place holder for the value (will be
1232 // updated by PhaseIdealLoop::clone_skeleton_predicate()).
1233 ProjNode* PhaseIdealLoop::insert_skeleton_predicate(IfNode* iff, IdealLoopTree *loop,
1234                                                     ProjNode* proj, ProjNode *predicate_proj,
1235                                                     ProjNode* upper_bound_proj,
1236                                                     int scale, Node* offset,
1237                                                     Node* init, Node* limit, jint stride,
1238                                                     Node* rng, bool &amp;overflow,
1239                                                     Deoptimization::DeoptReason reason) {
1240   assert(proj-&gt;_con &amp;&amp; predicate_proj-&gt;_con, &quot;not a range check?&quot;);
1241   Node* opaque_init = new Opaque1Node(C, init);
1242   register_new_node(opaque_init, upper_bound_proj);
1243   BoolNode* bol = rc_predicate(loop, upper_bound_proj, scale, offset, opaque_init, limit, stride, rng, (stride &gt; 0) != (scale &gt; 0), overflow);
1244   Node* opaque_bol = new Opaque4Node(C, bol, _igvn.intcon(1)); // This will go away once loop opts are over
1245   register_new_node(opaque_bol, upper_bound_proj);
1246   ProjNode* new_proj = create_new_if_for_predicate(predicate_proj, NULL, reason, overflow ? Op_If : iff-&gt;Opcode());
1247   _igvn.replace_input_of(new_proj-&gt;in(0), 1, opaque_bol);
1248   assert(opaque_init-&gt;outcnt() &gt; 0, &quot;should be used&quot;);
1249   return new_proj;
1250 }
1251 
1252 //------------------------------ loop_predication_impl--------------------------
1253 // Insert loop predicates for null checks and range checks
1254 bool PhaseIdealLoop::loop_predication_impl(IdealLoopTree *loop) {
1255   if (!UseLoopPredicate) return false;
1256 
1257   if (!loop-&gt;_head-&gt;is_Loop()) {
1258     // Could be a simple region when irreducible loops are present.
1259     return false;
1260   }
1261   LoopNode* head = loop-&gt;_head-&gt;as_Loop();
1262 
1263   if (head-&gt;unique_ctrl_out()-&gt;Opcode() == Op_NeverBranch) {
1264     // do nothing for infinite loops
1265     return false;
1266   }
1267 
1268   if (head-&gt;is_OuterStripMinedLoop()) {
1269     return false;
1270   }
1271 
1272   CountedLoopNode *cl = NULL;
1273   if (head-&gt;is_valid_counted_loop()) {
1274     cl = head-&gt;as_CountedLoop();
1275     // do nothing for iteration-splitted loops
1276     if (!cl-&gt;is_normal_loop()) return false;
1277     // Avoid RCE if Counted loop&#39;s test is &#39;!=&#39;.
1278     BoolTest::mask bt = cl-&gt;loopexit()-&gt;test_trip();
1279     if (bt != BoolTest::lt &amp;&amp; bt != BoolTest::gt)
1280       cl = NULL;
1281   }
1282 
1283   Node* entry = head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
1284   ProjNode *loop_limit_proj = NULL;
1285   ProjNode *predicate_proj = NULL;
1286   ProjNode *profile_predicate_proj = NULL;
1287   // Loop limit check predicate should be near the loop.
1288   loop_limit_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
1289   if (loop_limit_proj != NULL) {
1290     entry = skip_loop_predicates(loop_limit_proj);
1291   }
1292   bool has_profile_predicates = false;
1293   profile_predicate_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);
1294   if (profile_predicate_proj != NULL) {
1295     Node* n = skip_loop_predicates(entry);
1296     // Check if predicates were already added to the profile predicate
1297     // block
1298     if (n != entry-&gt;in(0)-&gt;in(0) || n-&gt;outcnt() != 1) {
1299       has_profile_predicates = true;
1300     }
1301     entry = n;
1302   }
1303   predicate_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
1304 
1305   float loop_trip_cnt = -1;
1306   bool follow_branches = loop_predication_should_follow_branches(loop, profile_predicate_proj, loop_trip_cnt);
1307   assert(!follow_branches || loop_trip_cnt &gt;= 0, &quot;negative trip count?&quot;);
1308 
1309   if (predicate_proj == NULL &amp;&amp; !follow_branches) {
1310 #ifndef PRODUCT
1311     if (TraceLoopPredicate) {
1312       tty-&gt;print(&quot;missing predicate:&quot;);
1313       loop-&gt;dump_head();
1314       head-&gt;dump(1);
1315     }
1316 #endif
1317     return false;
1318   }
1319   ConNode* zero = _igvn.intcon(0);
1320   set_ctrl(zero, C-&gt;root());
1321 
1322   ResourceArea *area = Thread::current()-&gt;resource_area();
1323   Invariance invar(area, loop);
1324 
1325   // Create list of if-projs such that a newer proj dominates all older
1326   // projs in the list, and they all dominate loop-&gt;tail()
1327   Node_List if_proj_list(area);
1328   Node_List regions(area);
1329   Node *current_proj = loop-&gt;tail(); //start from tail
1330 
1331 
1332   Node_List controls(area);
1333   while (current_proj != head) {
1334     if (loop == get_loop(current_proj) &amp;&amp; // still in the loop ?
1335         current_proj-&gt;is_Proj()        &amp;&amp; // is a projection  ?
1336         (current_proj-&gt;in(0)-&gt;Opcode() == Op_If ||
1337          current_proj-&gt;in(0)-&gt;Opcode() == Op_RangeCheck)) { // is a if projection ?
1338       if_proj_list.push(current_proj);
1339     }
1340     if (follow_branches &amp;&amp;
1341         current_proj-&gt;Opcode() == Op_Region &amp;&amp;
1342         loop == get_loop(current_proj)) {
1343       regions.push(current_proj);
1344     }
1345     current_proj = idom(current_proj);
1346   }
1347 
1348   bool hoisted = false; // true if at least one proj is promoted
1349 
1350   if (!has_profile_predicates) {
1351     while (if_proj_list.size() &gt; 0) {
1352       Node* n = if_proj_list.pop();
1353 
1354       ProjNode* proj = n-&gt;as_Proj();
1355       IfNode*   iff  = proj-&gt;in(0)-&gt;as_If();
1356 
1357       CallStaticJavaNode* call = proj-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);
1358       if (call == NULL) {
1359         if (loop-&gt;is_loop_exit(iff)) {
1360           // stop processing the remaining projs in the list because the execution of them
1361           // depends on the condition of &quot;iff&quot; (iff-&gt;in(1)).
1362           break;
1363         } else {
1364           // Both arms are inside the loop. There are two cases:
1365           // (1) there is one backward branch. In this case, any remaining proj
1366           //     in the if_proj list post-dominates &quot;iff&quot;. So, the condition of &quot;iff&quot;
1367           //     does not determine the execution the remining projs directly, and we
1368           //     can safely continue.
1369           // (2) both arms are forwarded, i.e. a diamond shape. In this case, &quot;proj&quot;
1370           //     does not dominate loop-&gt;tail(), so it can not be in the if_proj list.
1371           continue;
1372         }
1373       }
1374       Deoptimization::DeoptReason reason = Deoptimization::trap_request_reason(call-&gt;uncommon_trap_request());
1375       if (reason == Deoptimization::Reason_predicate) {
1376         break;
1377       }
1378 
1379       if (predicate_proj != NULL) {
1380         hoisted = loop_predication_impl_helper(loop, proj, predicate_proj, cl, zero, invar, Deoptimization::Reason_predicate) | hoisted;
1381       }
1382     } // end while
1383   }
1384 
1385   if (follow_branches) {
1386     PathFrequency pf(loop-&gt;_head, this);
1387 
1388     // Some projections were skipped by regular predicates because of
1389     // an early loop exit. Try them with profile data.
1390     while (if_proj_list.size() &gt; 0) {
1391       Node* proj = if_proj_list.pop();
1392       float f = pf.to(proj);
1393       if (proj-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;
1394           f * loop_trip_cnt &gt;= 1) {
1395         hoisted = loop_predication_impl_helper(loop, proj-&gt;as_Proj(), profile_predicate_proj, cl, zero, invar, Deoptimization::Reason_profile_predicate) | hoisted;
1396       }
1397     }
1398 
1399     // And look into all branches
1400     Node_Stack stack(0);
1401     VectorSet seen(Thread::current()-&gt;resource_area());
1402     Node_List if_proj_list_freq(area);
1403     while (regions.size() &gt; 0) {
1404       Node* c = regions.pop();
1405       loop_predication_follow_branches(c, loop, loop_trip_cnt, pf, stack, seen, if_proj_list_freq);
1406     }
1407 
1408     for (uint i = 0; i &lt; if_proj_list_freq.size(); i++) {
1409       ProjNode* proj = if_proj_list_freq.at(i)-&gt;as_Proj();
1410       hoisted = loop_predication_impl_helper(loop, proj, profile_predicate_proj, cl, zero, invar, Deoptimization::Reason_profile_predicate) | hoisted;
1411     }
1412   }
1413 
1414 #ifndef PRODUCT
1415   // report that the loop predication has been actually performed
1416   // for this loop
1417   if (TraceLoopPredicate &amp;&amp; hoisted) {
1418     tty-&gt;print(&quot;Loop Predication Performed:&quot;);
1419     loop-&gt;dump_head();
1420   }
1421 #endif
1422 
1423   head-&gt;verify_strip_mined(1);
1424 
1425   return hoisted;
1426 }
1427 
1428 //------------------------------loop_predication--------------------------------
1429 // driver routine for loop predication optimization
1430 bool IdealLoopTree::loop_predication( PhaseIdealLoop *phase) {
1431   bool hoisted = false;
1432   // Recursively promote predicates
1433   if (_child) {
1434     hoisted = _child-&gt;loop_predication( phase);
1435   }
1436 
1437   // self
1438   if (!_irreducible &amp;&amp; !tail()-&gt;is_top()) {
1439     hoisted |= phase-&gt;loop_predication_impl(this);
1440   }
1441 
1442   if (_next) { //sibling
1443     hoisted |= _next-&gt;loop_predication( phase);
1444   }
1445 
1446   return hoisted;
1447 }
    </pre>
  </body>
</html>
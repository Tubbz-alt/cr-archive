<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/loopnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="loopUnswitch.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopnode.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/loopnode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciMethodData.hpp&quot;
  27 #include &quot;compiler/compileLog.hpp&quot;
  28 #include &quot;gc/shared/barrierSet.hpp&quot;
  29 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  30 #include &quot;libadt/vectset.hpp&quot;
  31 #include &quot;memory/allocation.inline.hpp&quot;
  32 #include &quot;memory/resourceArea.hpp&quot;
  33 #include &quot;opto/addnode.hpp&quot;
  34 #include &quot;opto/callnode.hpp&quot;
  35 #include &quot;opto/connode.hpp&quot;
  36 #include &quot;opto/convertnode.hpp&quot;
  37 #include &quot;opto/divnode.hpp&quot;
  38 #include &quot;opto/idealGraphPrinter.hpp&quot;
  39 #include &quot;opto/loopnode.hpp&quot;
  40 #include &quot;opto/mulnode.hpp&quot;
  41 #include &quot;opto/rootnode.hpp&quot;
  42 #include &quot;opto/superword.hpp&quot;

  43 
  44 //=============================================================================
<span class="line-modified">  45 //------------------------------is_loop_iv-------------------------------------</span>
<span class="line-modified">  46 // Determine if a node is Counted loop induction variable.</span>
<span class="line-modified">  47 // The method is declared in node.hpp.</span>
<span class="line-modified">  48 const Node* Node::is_loop_iv() const {</span>
<span class="line-modified">  49   if (this-&gt;is_Phi() &amp;&amp; !this-&gt;as_Phi()-&gt;is_copy() &amp;&amp;</span>
<span class="line-modified">  50       this-&gt;as_Phi()-&gt;region()-&gt;is_CountedLoop() &amp;&amp;</span>
<span class="line-modified">  51       this-&gt;as_Phi()-&gt;region()-&gt;as_CountedLoop()-&gt;phi() == this) {</span>
<span class="line-removed">  52     return this;</span>
<span class="line-removed">  53   } else {</span>
<span class="line-removed">  54     return NULL;</span>
<span class="line-removed">  55   }</span>
  56 }
  57 
  58 //=============================================================================
  59 //------------------------------dump_spec--------------------------------------
  60 // Dump special per-node info
  61 #ifndef PRODUCT
  62 void LoopNode::dump_spec(outputStream *st) const {
  63   if (is_inner_loop()) st-&gt;print( &quot;inner &quot; );
  64   if (is_partial_peel_loop()) st-&gt;print( &quot;partial_peel &quot; );
  65   if (partial_peel_has_failed()) st-&gt;print( &quot;partial_peel_failed &quot; );
  66 }
  67 #endif
  68 
  69 //------------------------------is_valid_counted_loop-------------------------
  70 bool LoopNode::is_valid_counted_loop() const {
  71   if (is_CountedLoop()) {
  72     CountedLoopNode*    l  = as_CountedLoop();
  73     CountedLoopEndNode* le = l-&gt;loopexit_or_null();
  74     if (le != NULL &amp;&amp;
  75         le-&gt;proj_out_or_null(1 /* true */) == l-&gt;in(LoopNode::LoopBackControl)) {
</pre>
<hr />
<pre>
 931     limit = _igvn.intcon(final_int);
 932   } else {
 933     // Create new LoopLimit node to get exact limit (final iv value).
 934     limit = new LoopLimitNode(C, cl-&gt;init_trip(), cl-&gt;limit(), cl-&gt;stride());
 935     register_new_node(limit, cl-&gt;in(LoopNode::EntryControl));
 936   }
 937   assert(limit != NULL, &quot;sanity&quot;);
 938   return limit;
 939 }
 940 
 941 //------------------------------Ideal------------------------------------------
 942 // Return a node which is more &quot;ideal&quot; than the current node.
 943 // Attempt to convert into a counted-loop.
 944 Node *LoopNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 945   if (!can_be_counted_loop(phase) &amp;&amp; !is_OuterStripMinedLoop()) {
 946     phase-&gt;C-&gt;set_major_progress();
 947   }
 948   return RegionNode::Ideal(phase, can_reshape);
 949 }
 950 
<span class="line-removed"> 951 void LoopNode::verify_strip_mined(int expect_skeleton) const {</span>
 952 #ifdef ASSERT

 953   const OuterStripMinedLoopNode* outer = NULL;
 954   const CountedLoopNode* inner = NULL;
 955   if (is_strip_mined()) {



 956     assert(is_CountedLoop(), &quot;no Loop should be marked strip mined&quot;);
 957     inner = as_CountedLoop();
 958     outer = inner-&gt;in(LoopNode::EntryControl)-&gt;as_OuterStripMinedLoop();
 959   } else if (is_OuterStripMinedLoop()) {
 960     outer = this-&gt;as_OuterStripMinedLoop();
 961     inner = outer-&gt;unique_ctrl_out()-&gt;as_CountedLoop();

 962     assert(!is_strip_mined(), &quot;outer loop shouldn&#39;t be marked strip mined&quot;);
 963   }
 964   if (inner != NULL || outer != NULL) {
 965     assert(inner != NULL &amp;&amp; outer != NULL, &quot;missing loop in strip mined nest&quot;);
 966     Node* outer_tail = outer-&gt;in(LoopNode::LoopBackControl);
 967     Node* outer_le = outer_tail-&gt;in(0);
 968     assert(outer_le-&gt;Opcode() == Op_OuterStripMinedLoopEnd, &quot;tail of outer loop should be an If&quot;);
 969     Node* sfpt = outer_le-&gt;in(0);
 970     assert(sfpt-&gt;Opcode() == Op_SafePoint, &quot;where&#39;s the safepoint?&quot;);
 971     Node* inner_out = sfpt-&gt;in(0);
 972     if (inner_out-&gt;outcnt() != 1) {
 973       ResourceMark rm;
 974       Unique_Node_List wq;
 975 
 976       for (DUIterator_Fast imax, i = inner_out-&gt;fast_outs(imax); i &lt; imax; i++) {
 977         Node* u = inner_out-&gt;fast_out(i);
 978         if (u == sfpt) {
 979           continue;
 980         }
 981         wq.clear();
 982         wq.push(u);
 983         bool found_sfpt = false;
 984         for (uint next = 0; next &lt; wq.size() &amp;&amp; !found_sfpt; next++) {
<span class="line-modified"> 985           Node *n = wq.at(next);</span>
 986           for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax &amp;&amp; !found_sfpt; i++) {
 987             Node* u = n-&gt;fast_out(i);
 988             if (u == sfpt) {
 989               found_sfpt = true;
 990             }
 991             if (!u-&gt;is_CFG()) {
 992               wq.push(u);
 993             }
 994           }
 995         }
 996         assert(found_sfpt, &quot;no node in loop that&#39;s not input to safepoint&quot;);
 997       }
 998     }

 999     CountedLoopEndNode* cle = inner_out-&gt;in(0)-&gt;as_CountedLoopEnd();
1000     assert(cle == inner-&gt;loopexit_or_null(), &quot;mismatch&quot;);
1001     bool has_skeleton = outer_le-&gt;in(1)-&gt;bottom_type()-&gt;singleton() &amp;&amp; outer_le-&gt;in(1)-&gt;bottom_type()-&gt;is_int()-&gt;get_con() == 0;
1002     if (has_skeleton) {
1003       assert(expect_skeleton == 1 || expect_skeleton == -1, &quot;unexpected skeleton node&quot;);
1004       assert(outer-&gt;outcnt() == 2, &quot;only phis&quot;);
1005     } else {
1006       assert(expect_skeleton == 0 || expect_skeleton == -1, &quot;no skeleton node?&quot;);
1007       uint phis = 0;
1008       for (DUIterator_Fast imax, i = inner-&gt;fast_outs(imax); i &lt; imax; i++) {
1009         Node* u = inner-&gt;fast_out(i);
1010         if (u-&gt;is_Phi()) {
1011           phis++;
1012         }
1013       }
1014       for (DUIterator_Fast imax, i = outer-&gt;fast_outs(imax); i &lt; imax; i++) {
1015         Node* u = outer-&gt;fast_out(i);
1016         assert(u == outer || u == inner || u-&gt;is_Phi(), &quot;nothing between inner and outer loop&quot;);
1017       }
1018       uint stores = 0;
1019       for (DUIterator_Fast imax, i = inner_out-&gt;fast_outs(imax); i &lt; imax; i++) {
1020         Node* u = inner_out-&gt;fast_out(i);
1021         if (u-&gt;is_Store()) {
1022           stores++;
1023         }
1024       }
1025       assert(outer-&gt;outcnt() &gt;= phis + 2 &amp;&amp; outer-&gt;outcnt() &lt;= phis + 2 + stores + 1, &quot;only phis&quot;);
1026     }
1027     assert(sfpt-&gt;outcnt() == 1, &quot;no data node&quot;);
1028     assert(outer_tail-&gt;outcnt() == 1 || !has_skeleton, &quot;no data node&quot;);
1029   }
<span class="line-removed">1030 #endif</span>
1031 }

1032 
1033 //=============================================================================
1034 //------------------------------Ideal------------------------------------------
1035 // Return a node which is more &quot;ideal&quot; than the current node.
1036 // Attempt to convert into a counted-loop.
1037 Node *CountedLoopNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1038   return RegionNode::Ideal(phase, can_reshape);
1039 }
1040 
1041 //------------------------------dump_spec--------------------------------------
1042 // Dump special per-node info
1043 #ifndef PRODUCT
1044 void CountedLoopNode::dump_spec(outputStream *st) const {
1045   LoopNode::dump_spec(st);
1046   if (stride_is_con()) {
1047     st-&gt;print(&quot;stride: %d &quot;,stride_con());
1048   }
1049   if (is_pre_loop ()) st-&gt;print(&quot;pre of N%d&quot; , _main_idx);
1050   if (is_main_loop()) st-&gt;print(&quot;main of N%d&quot;, _idx);
1051   if (is_post_loop()) st-&gt;print(&quot;post of N%d&quot;, _main_idx);
</pre>
<hr />
<pre>
1222         trunc_t = TypeInt::SHORT;
1223       } else if (shift == 8) {
1224         trunc_t = TypeInt::BYTE;
1225       }
1226     }
1227   }
1228 
1229   // If (maybe after stripping) it is an AddI, we won:
1230   if (n1op == Op_AddI) {
1231     *trunc1 = t1;
1232     *trunc2 = t2;
1233     *trunc_type = trunc_t;
1234     return n1;
1235   }
1236 
1237   // failed
1238   return NULL;
1239 }
1240 
1241 LoopNode* CountedLoopNode::skip_strip_mined(int expect_skeleton) {
<span class="line-modified">1242   if (is_strip_mined()) {</span>
1243     verify_strip_mined(expect_skeleton);
1244     return in(EntryControl)-&gt;as_Loop();
1245   }
1246   return this;
1247 }
1248 
1249 OuterStripMinedLoopNode* CountedLoopNode::outer_loop() const {
1250   assert(is_strip_mined(), &quot;not a strip mined loop&quot;);
1251   Node* c = in(EntryControl);
1252   if (c == NULL || c-&gt;is_top() || !c-&gt;is_OuterStripMinedLoop()) {
1253     return NULL;
1254   }
1255   return c-&gt;as_OuterStripMinedLoop();
1256 }
1257 
1258 IfTrueNode* OuterStripMinedLoopNode::outer_loop_tail() const {
1259   Node* c = in(LoopBackControl);
1260   if (c == NULL || c-&gt;is_top()) {
1261     return NULL;
1262   }
</pre>
<hr />
<pre>
1784           // Go ahead and clean out old edges from old phi
1785           old_phi-&gt;del_req(i);
1786         }
1787       }
1788       // Search for CSE&#39;s here, because ZKM.jar does a lot of
1789       // loop hackery and we need to be a little incremental
1790       // with the CSE to avoid O(N^2) node blow-up.
1791       Node *p2 = igvn.hash_find_insert(p); // Look for a CSE
1792       if( p2 ) {                // Found CSE
1793         p-&gt;destruct();          // Recover useless new node
1794         p = p2;                 // Use old node
1795       } else {
1796         igvn.register_new_node_with_optimizer(p, old_phi);
1797       }
1798       // Make old Phi refer to new Phi.
1799       old_phi-&gt;add_req(p);
1800       // Check for the special case of making the old phi useless and
1801       // disappear it.  In JavaGrande I have a case where this useless
1802       // Phi is the loop limit and prevents recognizing a CountedLoop
1803       // which in turn prevents removing an empty loop.
<span class="line-modified">1804       Node *id_old_phi = igvn.apply_identity(old_phi);</span>
1805       if( id_old_phi != old_phi ) { // Found a simple identity?
1806         // Note that I cannot call &#39;replace_node&#39; here, because
1807         // that will yank the edge from old_phi to the Region and
1808         // I&#39;m mid-iteration over the Region&#39;s uses.
1809         for (DUIterator_Last imin, i = old_phi-&gt;last_outs(imin); i &gt;= imin; ) {
1810           Node* use = old_phi-&gt;last_out(i);
1811           igvn.rehash_node_delayed(use);
1812           uint uses_found = 0;
1813           for (uint j = 0; j &lt; use-&gt;len(); j++) {
1814             if (use-&gt;in(j) == old_phi) {
1815               if (j &lt; use-&gt;req()) use-&gt;set_req (j, id_old_phi);
1816               else                use-&gt;set_prec(j, id_old_phi);
1817               uses_found++;
1818             }
1819           }
1820           i -= uses_found;    // we deleted 1 or more copies of this edge
1821         }
1822       }
1823       igvn._worklist.push(old_phi);
1824     }
</pre>
<hr />
<pre>
2107     l = igvn.register_new_node_with_optimizer(l, _head);
2108     phase-&gt;set_created_loop_node();
2109     // Go ahead and replace _head
2110     phase-&gt;_igvn.replace_node( _head, l );
2111     _head = l;
2112     phase-&gt;set_loop(_head, this);
2113   }
2114 
2115   // Now recursively beautify nested loops
2116   if( _child ) result |= _child-&gt;beautify_loops( phase );
2117   if( _next  ) result |= _next -&gt;beautify_loops( phase );
2118   return result;
2119 }
2120 
2121 //------------------------------allpaths_check_safepts----------------------------
2122 // Allpaths backwards scan from loop tail, terminating each path at first safepoint
2123 // encountered.  Helper for check_safepts.
2124 void IdealLoopTree::allpaths_check_safepts(VectorSet &amp;visited, Node_List &amp;stack) {
2125   assert(stack.size() == 0, &quot;empty stack&quot;);
2126   stack.push(_tail);
<span class="line-modified">2127   visited.Clear();</span>
2128   visited.set(_tail-&gt;_idx);
2129   while (stack.size() &gt; 0) {
2130     Node* n = stack.pop();
2131     if (n-&gt;is_Call() &amp;&amp; n-&gt;as_Call()-&gt;guaranteed_safepoint()) {
2132       // Terminate this path
2133     } else if (n-&gt;Opcode() == Op_SafePoint) {
2134       if (_phase-&gt;get_loop(n) != this) {
2135         if (_required_safept == NULL) _required_safept = new Node_List();
2136         _required_safept-&gt;push(n);  // save the one closest to the tail
2137       }
2138       // Terminate this path
2139     } else {
2140       uint start = n-&gt;is_Region() ? 1 : 0;
2141       uint end   = n-&gt;is_Region() &amp;&amp; !n-&gt;is_Loop() ? n-&gt;req() : start + 1;
2142       for (uint i = start; i &lt; end; i++) {
2143         Node* in = n-&gt;in(i);
2144         assert(in-&gt;is_CFG(), &quot;must be&quot;);
2145         if (!visited.test_set(in-&gt;_idx) &amp;&amp; is_member(_phase-&gt;get_loop(in))) {
2146           stack.push(in);
2147         }
</pre>
<hr />
<pre>
2426     // Remove safepoints
2427     bool keep_one_sfpt = !(_has_call || _has_sfpt);
2428     remove_safepoints(phase, keep_one_sfpt);
2429 
2430     // Look for induction variables
2431     phase-&gt;replace_parallel_iv(this);
2432 
2433   } else if (_parent != NULL &amp;&amp; !_irreducible) {
2434     // Not a counted loop. Keep one safepoint.
2435     bool keep_one_sfpt = true;
2436     remove_safepoints(phase, keep_one_sfpt);
2437   }
2438 
2439   // Recursively
2440   assert(loop-&gt;_child != this || (loop-&gt;_head-&gt;as_Loop()-&gt;is_OuterStripMinedLoop() &amp;&amp; _head-&gt;as_CountedLoop()-&gt;is_strip_mined()), &quot;what kind of loop was added?&quot;);
2441   assert(loop-&gt;_child != this || (loop-&gt;_child-&gt;_child == NULL &amp;&amp; loop-&gt;_child-&gt;_next == NULL), &quot;would miss some loops&quot;);
2442   if (loop-&gt;_child &amp;&amp; loop-&gt;_child != this) loop-&gt;_child-&gt;counted_loop(phase);
2443   if (loop-&gt;_next)  loop-&gt;_next -&gt;counted_loop(phase);
2444 }
2445 





















































































2446 #ifndef PRODUCT
2447 //------------------------------dump_head--------------------------------------
2448 // Dump 1 liner for loop header info
<span class="line-modified">2449 void IdealLoopTree::dump_head( ) const {</span>
<span class="line-modified">2450   for (uint i=0; i&lt;_nest; i++)</span>
<span class="line-modified">2451     tty-&gt;print(&quot;  &quot;);</span>
<span class="line-removed">2452   tty-&gt;print(&quot;Loop: N%d/N%d &quot;,_head-&gt;_idx,_tail-&gt;_idx);</span>
2453   if (_irreducible) tty-&gt;print(&quot; IRREDUCIBLE&quot;);
2454   Node* entry = _head-&gt;is_Loop() ? _head-&gt;as_Loop()-&gt;skip_strip_mined(-1)-&gt;in(LoopNode::EntryControl) : _head-&gt;in(LoopNode::EntryControl);
2455   Node* predicate = PhaseIdealLoop::find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
2456   if (predicate != NULL ) {
2457     tty-&gt;print(&quot; limit_check&quot;);
2458     entry = PhaseIdealLoop::skip_loop_predicates(entry);
2459   }
2460   if (UseLoopPredicate) {
2461     entry = PhaseIdealLoop::find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
2462     if (entry != NULL) {
2463       tty-&gt;print(&quot; predicated&quot;);
2464       entry = PhaseIdealLoop::skip_loop_predicates(entry);
2465     }
2466   }
2467   if (UseProfiledLoopPredicate) {
2468     entry = PhaseIdealLoop::find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);
2469     if (entry != NULL) {
2470       tty-&gt;print(&quot; profile_predicated&quot;);
2471     }
2472   }
</pre>
<hr />
<pre>
2500   if (_has_call) tty-&gt;print(&quot; has_call&quot;);
2501   if (_has_sfpt) tty-&gt;print(&quot; has_sfpt&quot;);
2502   if (_rce_candidate) tty-&gt;print(&quot; rce&quot;);
2503   if (_safepts != NULL &amp;&amp; _safepts-&gt;size() &gt; 0) {
2504     tty-&gt;print(&quot; sfpts={&quot;); _safepts-&gt;dump_simple(); tty-&gt;print(&quot; }&quot;);
2505   }
2506   if (_required_safept != NULL &amp;&amp; _required_safept-&gt;size() &gt; 0) {
2507     tty-&gt;print(&quot; req={&quot;); _required_safept-&gt;dump_simple(); tty-&gt;print(&quot; }&quot;);
2508   }
2509   if (Verbose) {
2510     tty-&gt;print(&quot; body={&quot;); _body.dump_simple(); tty-&gt;print(&quot; }&quot;);
2511   }
2512   if (_head-&gt;is_Loop() &amp;&amp; _head-&gt;as_Loop()-&gt;is_strip_mined()) {
2513     tty-&gt;print(&quot; strip_mined&quot;);
2514   }
2515   tty-&gt;cr();
2516 }
2517 
2518 //------------------------------dump-------------------------------------------
2519 // Dump loops by loop tree
<span class="line-modified">2520 void IdealLoopTree::dump( ) const {</span>
2521   dump_head();
2522   if (_child) _child-&gt;dump();
2523   if (_next)  _next -&gt;dump();
2524 }
2525 
2526 #endif
2527 
2528 static void log_loop_tree(IdealLoopTree* root, IdealLoopTree* loop, CompileLog* log) {
2529   if (loop == root) {
2530     if (loop-&gt;_child != NULL) {
2531       log-&gt;begin_head(&quot;loop_tree&quot;);
2532       log-&gt;end_head();
2533       if( loop-&gt;_child ) log_loop_tree(root, loop-&gt;_child, log);
2534       log-&gt;tail(&quot;loop_tree&quot;);
2535       assert(loop-&gt;_next == NULL, &quot;what?&quot;);
2536     }
2537   } else {
2538     Node* head = loop-&gt;_head;
2539     log-&gt;begin_head(&quot;loop&quot;);
2540     log-&gt;print(&quot; idx=&#39;%d&#39; &quot;, head-&gt;_idx);
</pre>
<hr />
<pre>
2697         if (n2-&gt;in(0) != c2) {
2698           _igvn.hash_delete(n2);
2699           n2-&gt;set_req(0, c2);
2700           _igvn.hash_insert(n2);
2701           _igvn._worklist.push(n2);
2702           progress = true;
2703         }
2704       }
2705     }
2706   }
2707 
2708   return progress;
2709 }
2710 
2711 
2712 //=============================================================================
2713 //----------------------------build_and_optimize-------------------------------
2714 // Create a PhaseLoop.  Build the ideal Loop tree.  Map each Ideal Node to
2715 // its corresponding LoopNode.  If &#39;optimize&#39; is true, do some loop cleanups.
2716 void PhaseIdealLoop::build_and_optimize(LoopOptsMode mode) {
<span class="line-modified">2717   bool do_split_ifs = (mode == LoopOptsDefault || mode == LoopOptsLastRound);</span>
2718   bool skip_loop_opts = (mode == LoopOptsNone);
2719 
2720   int old_progress = C-&gt;major_progress();
2721   uint orig_worklist_size = _igvn._worklist.size();
2722 
2723   // Reset major-progress flag for the driver&#39;s heuristics
2724   C-&gt;clear_major_progress();
2725 
2726 #ifndef PRODUCT
2727   // Capture for later assert
2728   uint unique = C-&gt;unique();
2729   _loop_invokes++;
2730   _loop_work += unique;
2731 #endif
2732 
2733   // True if the method has at least 1 irreducible loop
2734   _has_irreducible_loops = false;
2735 
2736   _created_loop_node = false;
2737 
</pre>
<hr />
<pre>
2833         i--;                      // Rerun same iteration on compressed edges
2834       }
2835     }
2836 
2837     // Given dominators, try to find inner loops with calls that must
2838     // always be executed (call dominates loop tail).  These loops do
2839     // not need a separate safepoint.
2840     Node_List cisstack(a);
2841     _ltree_root-&gt;check_safepts(visited, cisstack);
2842   }
2843 
2844   // Walk the DATA nodes and place into loops.  Find earliest control
2845   // node.  For CFG nodes, the _nodes array starts out and remains
2846   // holding the associated IdealLoopTree pointer.  For DATA nodes, the
2847   // _nodes array holds the earliest legal controlling CFG node.
2848 
2849   // Allocate stack with enough space to avoid frequent realloc
2850   int stack_size = (C-&gt;live_nodes() &gt;&gt; 1) + 16; // (live_nodes&gt;&gt;1)+16 from Java2D stats
2851   Node_Stack nstack( a, stack_size );
2852 
<span class="line-modified">2853   visited.Clear();</span>
2854   Node_List worklist(a);
2855   // Don&#39;t need C-&gt;root() on worklist since
2856   // it will be processed among C-&gt;top() inputs
<span class="line-modified">2857   worklist.push( C-&gt;top() );</span>
<span class="line-modified">2858   visited.set( C-&gt;top()-&gt;_idx ); // Set C-&gt;top() as visited now</span>
2859   build_loop_early( visited, worklist, nstack );
2860 
2861   // Given early legal placement, try finding counted loops.  This placement
2862   // is good enough to discover most loop invariants.
2863   if (!_verify_me &amp;&amp; !_verify_only &amp;&amp; !strip_mined_loops_expanded) {
2864     _ltree_root-&gt;counted_loop( this );
2865   }
2866 
2867   // Find latest loop placement.  Find ideal loop placement.
<span class="line-modified">2868   visited.Clear();</span>
2869   init_dom_lca_tags();
2870   // Need C-&gt;root() on worklist when processing outs
<span class="line-modified">2871   worklist.push( C-&gt;root() );</span>
2872   NOT_PRODUCT( C-&gt;verify_graph_edges(); )
<span class="line-modified">2873   worklist.push( C-&gt;top() );</span>
2874   build_loop_late( visited, worklist, nstack );
2875 
2876   if (_verify_only) {
<span class="line-modified">2877     // restore major progress flag</span>
<span class="line-removed">2878     for (int i = 0; i &lt; old_progress; i++)</span>
<span class="line-removed">2879       C-&gt;set_major_progress();</span>
2880     assert(C-&gt;unique() == unique, &quot;verification mode made Nodes? ? ?&quot;);
2881     assert(_igvn._worklist.size() == orig_worklist_size, &quot;shouldn&#39;t push anything&quot;);
2882     return;
2883   }
2884 
2885   // clear out the dead code after build_loop_late
2886   while (_deadlist.size()) {
2887     _igvn.remove_globally_dead_node(_deadlist.pop());
2888   }
2889 
2890   if (stop_early) {
2891     assert(do_expensive_nodes, &quot;why are we here?&quot;);
2892     if (process_expensive_nodes()) {
2893       // If we made some progress when processing expensive nodes then
2894       // the IGVN may modify the graph in a way that will allow us to
2895       // make some more progress: we need to try processing expensive
2896       // nodes again.
2897       C-&gt;set_major_progress();
2898     }
2899     _igvn.optimize();
2900     return;
2901   }
2902 
2903   // Some parser-inserted loop predicates could never be used by loop
2904   // predication or they were moved away from loop during some optimizations.
2905   // For example, peeling. Eliminate them before next loop optimizations.
2906   eliminate_useless_predicates();
2907 
2908 #ifndef PRODUCT
2909   C-&gt;verify_graph_edges();
2910   if (_verify_me) {             // Nested verify pass?
2911     // Check to see if the verify mode is broken
2912     assert(C-&gt;unique() == unique, &quot;non-optimize mode made Nodes? ? ?&quot;);
2913     return;
2914   }
<span class="line-modified">2915   if(VerifyLoopOptimizations) verify();</span>
<span class="line-modified">2916   if(TraceLoopOpts &amp;&amp; C-&gt;has_loops()) {</span>
2917     _ltree_root-&gt;dump();
2918   }
2919 #endif
2920 
2921   if (skip_loop_opts) {
2922     // restore major progress flag
<span class="line-modified">2923     for (int i = 0; i &lt; old_progress; i++) {</span>
<span class="line-removed">2924       C-&gt;set_major_progress();</span>
<span class="line-removed">2925     }</span>
2926 
2927     // Cleanup any modified bits
2928     _igvn.optimize();
2929 
2930     if (C-&gt;log() != NULL) {
2931       log_loop_tree(_ltree_root, _ltree_root, C-&gt;log());
2932     }
2933     return;
2934   }
2935 



























2936   if (bs-&gt;optimize_loops(this, mode, visited, nstack, worklist)) {
2937     _igvn.optimize();
2938     if (C-&gt;log() != NULL) {
2939       log_loop_tree(_ltree_root, _ltree_root, C-&gt;log());
2940     }
2941     return;
2942   }
2943 
2944   if (ReassociateInvariants) {
2945     // Reassociate invariants and prep for split_thru_phi
2946     for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {
2947       IdealLoopTree* lpt = iter.current();
2948       bool is_counted = lpt-&gt;is_counted();
<span class="line-modified">2949       if (!is_counted || !lpt-&gt;is_inner()) continue;</span>
2950 
2951       // check for vectorized loops, any reassociation of invariants was already done
<span class="line-modified">2952       if (is_counted &amp;&amp; lpt-&gt;_head-&gt;as_CountedLoop()-&gt;do_unroll_only()) continue;</span>
<span class="line-modified">2953 </span>
<span class="line-modified">2954       lpt-&gt;reassociate_invariants(this);</span>
<span class="line-modified">2955 </span>


2956       // Because RCE opportunities can be masked by split_thru_phi,
2957       // look for RCE candidates and inhibit split_thru_phi
2958       // on just their loop-phi&#39;s for this pass of loop opts
2959       if (SplitIfBlocks &amp;&amp; do_split_ifs) {

2960         if (lpt-&gt;policy_range_check(this)) {
2961           lpt-&gt;_rce_candidate = 1; // = true
2962         }
2963       }
2964     }
2965   }
2966 
2967   // Check for aggressive application of split-if and other transforms
2968   // that require basic-block info (like cloning through Phi&#39;s)
2969   if( SplitIfBlocks &amp;&amp; do_split_ifs ) {
<span class="line-modified">2970     visited.Clear();</span>
<span class="line-modified">2971     split_if_with_blocks( visited, nstack, mode == LoopOptsLastRound );</span>
2972     NOT_PRODUCT( if( VerifyLoopOptimizations ) verify(); );
<span class="line-removed">2973     if (mode == LoopOptsLastRound) {</span>
<span class="line-removed">2974       C-&gt;set_major_progress();</span>
<span class="line-removed">2975     }</span>
2976   }
2977 
2978   if (!C-&gt;major_progress() &amp;&amp; do_expensive_nodes &amp;&amp; process_expensive_nodes()) {
2979     C-&gt;set_major_progress();
2980   }
2981 
2982   // Perform loop predication before iteration splitting
2983   if (C-&gt;has_loops() &amp;&amp; !C-&gt;major_progress() &amp;&amp; (C-&gt;predicate_count() &gt; 0)) {
2984     _ltree_root-&gt;_child-&gt;loop_predication(this);
2985   }
2986 
2987   if (OptimizeFill &amp;&amp; UseLoopPredicate &amp;&amp; C-&gt;has_loops() &amp;&amp; !C-&gt;major_progress()) {
2988     if (do_intrinsify_fill()) {
2989       C-&gt;set_major_progress();
2990     }
2991   }
2992 
2993   // Perform iteration-splitting on inner loops.  Split iterations to avoid
2994   // range checks or one-shot null checks.
2995 
</pre>
<hr />
<pre>
3090 void PhaseIdealLoop::print_statistics() {
3091   tty-&gt;print_cr(&quot;PhaseIdealLoop=%d, sum _unique=%d&quot;, _loop_invokes, _loop_work);
3092 }
3093 
3094 //------------------------------verify-----------------------------------------
3095 // Build a verify-only PhaseIdealLoop, and see that it agrees with me.
3096 static int fail;                // debug only, so its multi-thread dont care
3097 void PhaseIdealLoop::verify() const {
3098   int old_progress = C-&gt;major_progress();
3099   ResourceMark rm;
3100   PhaseIdealLoop loop_verify( _igvn, this );
3101   VectorSet visited(Thread::current()-&gt;resource_area());
3102 
3103   fail = 0;
3104   verify_compare( C-&gt;root(), &amp;loop_verify, visited );
3105   assert( fail == 0, &quot;verify loops failed&quot; );
3106   // Verify loop structure is the same
3107   _ltree_root-&gt;verify_tree(loop_verify._ltree_root, NULL);
3108   // Reset major-progress.  It was cleared by creating a verify version of
3109   // PhaseIdealLoop.
<span class="line-modified">3110   for( int i=0; i&lt;old_progress; i++ )</span>
<span class="line-removed">3111     C-&gt;set_major_progress();</span>
3112 }
3113 
3114 //------------------------------verify_compare---------------------------------
3115 // Make sure me and the given PhaseIdealLoop agree on key data structures
3116 void PhaseIdealLoop::verify_compare( Node *n, const PhaseIdealLoop *loop_verify, VectorSet &amp;visited ) const {
3117   if( !n ) return;
3118   if( visited.test_set( n-&gt;_idx ) ) return;
3119   if( !_nodes[n-&gt;_idx] ) {      // Unreachable
3120     assert( !loop_verify-&gt;_nodes[n-&gt;_idx], &quot;both should be unreachable&quot; );
3121     return;
3122   }
3123 
3124   uint i;
3125   for( i = 0; i &lt; n-&gt;req(); i++ )
3126     verify_compare( n-&gt;in(i), loop_verify, visited );
3127 
3128   // Check the &#39;_nodes&#39; block/loop structure
3129   i = n-&gt;_idx;
3130   if( has_ctrl(n) ) {           // We have control; verify has loop or ctrl
3131     if( _nodes[i] != loop_verify-&gt;_nodes[i] &amp;&amp;
</pre>
<hr />
<pre>
3299         // Last ditch effort to avoid assertion: Its possible that we
3300         // have some users (so outcnt not zero) but are still dead.
3301         // Try to find from root.
3302         if (Compile::current()-&gt;root()-&gt;find(n-&gt;_idx)) {
3303           fail++;
3304           tty-&gt;print(&quot;Verify has that we do not: &quot;);
3305           n-&gt;dump();
3306         }
3307       }
3308     }
3309     assert( !fail, &quot;loop body mismatch&quot; );
3310   }
3311 }
3312 
3313 #endif
3314 
3315 //------------------------------set_idom---------------------------------------
3316 void PhaseIdealLoop::set_idom(Node* d, Node* n, uint dom_depth) {
3317   uint idx = d-&gt;_idx;
3318   if (idx &gt;= _idom_size) {
<span class="line-modified">3319     uint newsize = _idom_size&lt;&lt;1;</span>
<span class="line-removed">3320     while( idx &gt;= newsize ) {</span>
<span class="line-removed">3321       newsize &lt;&lt;= 1;</span>
<span class="line-removed">3322     }</span>
3323     _idom      = REALLOC_RESOURCE_ARRAY( Node*,     _idom,_idom_size,newsize);
3324     _dom_depth = REALLOC_RESOURCE_ARRAY( uint, _dom_depth,_idom_size,newsize);
3325     memset( _dom_depth + _idom_size, 0, (newsize - _idom_size) * sizeof(uint) );
3326     _idom_size = newsize;
3327   }
3328   _idom[idx] = n;
3329   _dom_depth[idx] = dom_depth;
3330 }
3331 
3332 //------------------------------recompute_dom_depth---------------------------------------
3333 // The dominator tree is constructed with only parent pointers.
3334 // This recomputes the depth in the tree by first tagging all
3335 // nodes as &quot;no depth yet&quot; marker.  The next pass then runs up
3336 // the dom tree from each node marked &quot;no depth yet&quot;, and computes
3337 // the depth on the way back down.
3338 void PhaseIdealLoop::recompute_dom_depth() {
3339   uint no_depth_marker = C-&gt;unique();
3340   uint i;
3341   // Initialize depth to &quot;no depth yet&quot; and realize all lazy updates
3342   for (i = 0; i &lt; _idom_size; i++) {
</pre>
<hr />
<pre>
3577             Node* x = m-&gt;fast_out(j);
3578             if (x-&gt;is_CFG() &amp;&amp; x != m &amp;&amp; x != iff)
3579               { cfg = x; break; }
3580           }
3581           assert(cfg != NULL, &quot;must find the control user of m&quot;);
3582           uint k = 0;             // Probably cfg-&gt;in(0)
3583           while( cfg-&gt;in(k) != m ) k++; // But check incase cfg is a Region
3584           cfg-&gt;set_req( k, if_t ); // Now point to NeverBranch
3585           _igvn._worklist.push(cfg);
3586 
3587           // Now create the never-taken loop exit
3588           Node *if_f = new CProjNode( iff, 1 );
3589           _igvn.register_new_node_with_optimizer(if_f);
3590           set_loop(if_f, l);
3591           // Find frame ptr for Halt.  Relies on the optimizer
3592           // V-N&#39;ing.  Easier and quicker than searching through
3593           // the program structure.
3594           Node *frame = new ParmNode( C-&gt;start(), TypeFunc::FramePtr );
3595           _igvn.register_new_node_with_optimizer(frame);
3596           // Halt &amp; Catch Fire
<span class="line-modified">3597           Node *halt = new HaltNode( if_f, frame );</span>
3598           _igvn.register_new_node_with_optimizer(halt);
3599           set_loop(halt, l);
3600           C-&gt;root()-&gt;add_req(halt);
3601         }
3602         set_loop(C-&gt;root(), _ltree_root);
3603       }
3604     }
3605     // Weeny check for irreducible.  This child was already visited (this
3606     // IS the post-work phase).  Is this child&#39;s loop header post-visited
3607     // as well?  If so, then I found another entry into the loop.
3608     if (!_verify_only) {
3609       while( is_postvisited(l-&gt;_head) ) {
3610         // found irreducible
3611         l-&gt;_irreducible = 1; // = true
3612         l = l-&gt;_parent;
3613         _has_irreducible_loops = true;
3614         // Check for bad CFG here to prevent crash, and bailout of compile
3615         if (l == NULL) {
3616           C-&gt;record_method_not_compilable(&quot;unhandled CFG detected during loop optimization&quot;);
3617           return pre_order;
</pre>
<hr />
<pre>
3945 //------------------------------get_late_ctrl----------------------------------
3946 // Compute latest legal control.
3947 Node *PhaseIdealLoop::get_late_ctrl( Node *n, Node *early ) {
3948   assert(early != NULL, &quot;early control should not be NULL&quot;);
3949 
3950   Node* LCA = compute_lca_of_uses(n, early);
3951 #ifdef ASSERT
3952   if (LCA == C-&gt;root() &amp;&amp; LCA != early) {
3953     // def doesn&#39;t dominate uses so print some useful debugging output
3954     compute_lca_of_uses(n, early, true);
3955   }
3956 #endif
3957 
3958   // if this is a load, check for anti-dependent stores
3959   // We use a conservative algorithm to identify potential interfering
3960   // instructions and for rescheduling the load.  The users of the memory
3961   // input of this load are examined.  Any use which is not a load and is
3962   // dominated by early is considered a potentially interfering store.
3963   // This can produce false positives.
3964   if (n-&gt;is_Load() &amp;&amp; LCA != early) {
<span class="line-modified">3965     Node_List worklist;</span>

3966 
<span class="line-modified">3967     Node *mem = n-&gt;in(MemNode::Memory);</span>
<span class="line-modified">3968     for (DUIterator_Fast imax, i = mem-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-modified">3969       Node* s = mem-&gt;fast_out(i);</span>
<span class="line-modified">3970       worklist.push(s);</span>
<span class="line-modified">3971     }</span>
<span class="line-modified">3972     while(worklist.size() != 0 &amp;&amp; LCA != early) {</span>
<span class="line-modified">3973       Node* s = worklist.pop();</span>
<span class="line-modified">3974       if (s-&gt;is_Load() || s-&gt;is_ShenandoahBarrier() || s-&gt;Opcode() == Op_SafePoint ||</span>
<span class="line-modified">3975           (s-&gt;is_CallStaticJava() &amp;&amp; s-&gt;as_CallStaticJava()-&gt;uncommon_trap_request() != 0)) {</span>
<span class="line-modified">3976         continue;</span>
<span class="line-modified">3977       } else if (s-&gt;is_MergeMem()) {</span>
<span class="line-modified">3978         for (DUIterator_Fast imax, i = s-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-modified">3979           Node* s1 = s-&gt;fast_out(i);</span>
<span class="line-modified">3980           worklist.push(s1);</span>
<span class="line-modified">3981         }</span>
<span class="line-modified">3982       } else {</span>
<span class="line-modified">3983         Node *sctrl = has_ctrl(s) ? get_ctrl(s) : s-&gt;in(0);</span>
<span class="line-modified">3984         assert(sctrl != NULL || s-&gt;outcnt() == 0, &quot;must have control&quot;);</span>
<span class="line-modified">3985         if (sctrl != NULL &amp;&amp; !sctrl-&gt;is_top() &amp;&amp; is_dominator(early, sctrl)) {</span>
<span class="line-modified">3986           LCA = dom_lca_for_get_late_ctrl(LCA, sctrl, n);</span>



3987         }
3988       }
3989     }
3990   }
3991 
3992   assert(LCA == find_non_split_ctrl(LCA), &quot;unexpected late control&quot;);
3993   return LCA;
3994 }
3995 
3996 // true if CFG node d dominates CFG node n
3997 bool PhaseIdealLoop::is_dominator(Node *d, Node *n) {
3998   if (d == n)
3999     return true;
4000   assert(d-&gt;is_CFG() &amp;&amp; n-&gt;is_CFG(), &quot;must have CFG nodes&quot;);
4001   uint dd = dom_depth(d);
4002   while (dom_depth(n) &gt;= dd) {
4003     if (n == d)
4004       return true;
4005     n = idom(n);
4006   }
</pre>
<hr />
<pre>
4172       for (uint i = 1; i &lt; m-&gt;req(); i++) {
4173         Node* nn = m-&gt;in(i);
4174         if (nn == n) {
4175           return;
4176         }
4177         if (nn != NULL &amp;&amp; has_ctrl(nn) &amp;&amp; get_loop(get_ctrl(nn)) == loop) {
4178           wq.push(nn);
4179         }
4180       }
4181     }
4182     ShouldNotReachHere();
4183   }
4184 #endif
4185 }
4186 
4187 
4188 //------------------------------build_loop_late_post---------------------------
4189 // Put Data nodes into some loop nest, by setting the _nodes[]-&gt;loop mapping.
4190 // Second pass finds latest legal placement, and ideal loop placement.
4191 void PhaseIdealLoop::build_loop_late_post(Node *n) {
<span class="line-removed">4192   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="line-removed">4193 </span>
<span class="line-removed">4194   if (bs-&gt;build_loop_late_post(this, n)) {</span>
<span class="line-removed">4195     return;</span>
<span class="line-removed">4196   }</span>
<span class="line-removed">4197 </span>
4198   build_loop_late_post_work(n, true);
4199 }
4200 
4201 void PhaseIdealLoop::build_loop_late_post_work(Node *n, bool pinned) {
4202 
4203   if (n-&gt;req() == 2 &amp;&amp; (n-&gt;Opcode() == Op_ConvI2L || n-&gt;Opcode() == Op_CastII) &amp;&amp; !C-&gt;major_progress() &amp;&amp; !_verify_only) {
4204     _igvn._worklist.push(n);  // Maybe we&#39;ll normalize it, if no more loops.
4205   }
4206 
4207 #ifdef ASSERT
4208   if (_verify_only &amp;&amp; !n-&gt;is_CFG()) {
4209     // Check def-use domination.
4210     compute_lca_of_uses(n, get_ctrl(n), true /* verify */);
4211   }
4212 #endif
4213 
4214   // CFG and pinned nodes already handled
4215   if( n-&gt;in(0) ) {
4216     if( n-&gt;in(0)-&gt;is_top() ) return; // Dead?
4217 
</pre>
<hr />
<pre>
4220     // Unlike Stores (which modify an unallocable resource, the memory
4221     // state), Mods/Loads can float around.  So free them up.
4222     switch( n-&gt;Opcode() ) {
4223     case Op_DivI:
4224     case Op_DivF:
4225     case Op_DivD:
4226     case Op_ModI:
4227     case Op_ModF:
4228     case Op_ModD:
4229     case Op_LoadB:              // Same with Loads; they can sink
4230     case Op_LoadUB:             // during loop optimizations.
4231     case Op_LoadUS:
4232     case Op_LoadD:
4233     case Op_LoadF:
4234     case Op_LoadI:
4235     case Op_LoadKlass:
4236     case Op_LoadNKlass:
4237     case Op_LoadL:
4238     case Op_LoadS:
4239     case Op_LoadP:
<span class="line-removed">4240     case Op_LoadBarrierSlowReg:</span>
<span class="line-removed">4241     case Op_LoadBarrierWeakSlowReg:</span>
4242     case Op_LoadN:
4243     case Op_LoadRange:
4244     case Op_LoadD_unaligned:
4245     case Op_LoadL_unaligned:
4246     case Op_StrComp:            // Does a bunch of load-like effects
4247     case Op_StrEquals:
4248     case Op_StrIndexOf:
4249     case Op_StrIndexOfChar:
4250     case Op_AryEq:
4251     case Op_HasNegatives:
4252       pinned = false;
4253     }



4254     if( pinned ) {
4255       IdealLoopTree *chosen_loop = get_loop(n-&gt;is_CFG() ? n : get_ctrl(n));
4256       if( !chosen_loop-&gt;_child )       // Inner loop?
4257         chosen_loop-&gt;_body.push(n); // Collect inner loops
4258       return;
4259     }
4260   } else {                      // No slot zero
4261     if( n-&gt;is_CFG() ) {         // CFG with no slot 0 is dead
4262       _nodes.map(n-&gt;_idx,0);    // No block setting, it&#39;s globally dead
4263       return;
4264     }
4265     assert(!n-&gt;is_CFG() || n-&gt;outcnt() == 0, &quot;&quot;);
4266   }
4267 
4268   // Do I have a &quot;safe range&quot; I can select over?
4269   Node *early = get_ctrl(n);// Early location already computed
4270 
4271   // Compute latest point this Node can go
4272   Node *LCA = get_late_ctrl( n, early );
4273   // LCA is NULL due to uses being dead
</pre>
<hr />
<pre>
4429             tty-&gt;print(&quot;n-&gt;out(%d)-&gt;in(0): &quot;, i); u2-&gt;in(0)-&gt;dump();
4430           }
4431         }
4432       }
4433     }
4434   }
4435   tty-&gt;cr();
4436   int ct = 0;
4437   Node *dbg_legal = LCA;
4438   while(!dbg_legal-&gt;is_Start() &amp;&amp; ct &lt; 100) {
4439     tty-&gt;print(&quot;idom[%d] &quot;,ct); dbg_legal-&gt;dump();
4440     ct++;
4441     dbg_legal = idom(dbg_legal);
4442   }
4443   tty-&gt;cr();
4444 }
4445 #endif
4446 
4447 #ifndef PRODUCT
4448 //------------------------------dump-------------------------------------------
<span class="line-modified">4449 void PhaseIdealLoop::dump( ) const {</span>
4450   ResourceMark rm;
4451   Arena* arena = Thread::current()-&gt;resource_area();
4452   Node_Stack stack(arena, C-&gt;live_nodes() &gt;&gt; 2);
4453   Node_List rpo_list;
4454   VectorSet visited(arena);
4455   visited.set(C-&gt;top()-&gt;_idx);
<span class="line-modified">4456   rpo( C-&gt;root(), stack, visited, rpo_list );</span>
4457   // Dump root loop indexed by last element in PO order
<span class="line-modified">4458   dump( _ltree_root, rpo_list.size(), rpo_list );</span>
4459 }
4460 
<span class="line-modified">4461 void PhaseIdealLoop::dump( IdealLoopTree *loop, uint idx, Node_List &amp;rpo_list ) const {</span>
4462   loop-&gt;dump_head();
4463 
4464   // Now scan for CFG nodes in the same loop
<span class="line-modified">4465   for( uint j=idx; j &gt; 0;  j-- ) {</span>
<span class="line-modified">4466     Node *n = rpo_list[j-1];</span>
<span class="line-modified">4467     if( !_nodes[n-&gt;_idx] )      // Skip dead nodes</span>
4468       continue;
<span class="line-modified">4469     if( get_loop(n) != loop ) { // Wrong loop nest</span>
<span class="line-modified">4470       if( get_loop(n)-&gt;_head == n &amp;&amp;    // Found nested loop?</span>
<span class="line-modified">4471           get_loop(n)-&gt;_parent == loop )</span>
<span class="line-modified">4472         dump(get_loop(n),rpo_list.size(),rpo_list);     // Print it nested-ly</span>

4473       continue;
4474     }
4475 
4476     // Dump controlling node
<span class="line-modified">4477     for( uint x = 0; x &lt; loop-&gt;_nest; x++ )</span>
<span class="line-removed">4478       tty-&gt;print(&quot;  &quot;);</span>
4479     tty-&gt;print(&quot;C&quot;);
<span class="line-modified">4480     if( n == C-&gt;root() ) {</span>
4481       n-&gt;dump();
4482     } else {
4483       Node* cached_idom   = idom_no_update(n);
<span class="line-modified">4484       Node *computed_idom = n-&gt;in(0);</span>
<span class="line-modified">4485       if( n-&gt;is_Region() ) {</span>
4486         computed_idom = compute_idom(n);
4487         // computed_idom() will return n-&gt;in(0) when idom(n) is an IfNode (or
4488         // any MultiBranch ctrl node), so apply a similar transform to
4489         // the cached idom returned from idom_no_update.
4490         cached_idom = find_non_split_ctrl(cached_idom);
4491       }
<span class="line-modified">4492       tty-&gt;print(&quot; ID:%d&quot;,computed_idom-&gt;_idx);</span>
4493       n-&gt;dump();
<span class="line-modified">4494       if( cached_idom != computed_idom ) {</span>
4495         tty-&gt;print_cr(&quot;*** BROKEN IDOM!  Computed as: %d, cached as: %d&quot;,
4496                       computed_idom-&gt;_idx, cached_idom-&gt;_idx);
4497       }
4498     }
4499     // Dump nodes it controls
<span class="line-modified">4500     for( uint k = 0; k &lt; _nodes.Size(); k++ ) {</span>
4501       // (k &lt; C-&gt;unique() &amp;&amp; get_ctrl(find(k)) == n)
4502       if (k &lt; C-&gt;unique() &amp;&amp; _nodes[k] == (Node*)((intptr_t)n + 1)) {
<span class="line-modified">4503         Node *m = C-&gt;root()-&gt;find(k);</span>
<span class="line-modified">4504         if( m &amp;&amp; m-&gt;outcnt() &gt; 0 ) {</span>
4505           if (!(has_ctrl(m) &amp;&amp; get_ctrl_no_update(m) == n)) {
4506             tty-&gt;print_cr(&quot;*** BROKEN CTRL ACCESSOR!  _nodes[k] is %p, ctrl is %p&quot;,
4507                           _nodes[k], has_ctrl(m) ? get_ctrl_no_update(m) : NULL);
4508           }
<span class="line-modified">4509           for( uint j = 0; j &lt; loop-&gt;_nest; j++ )</span>
<span class="line-removed">4510             tty-&gt;print(&quot;  &quot;);</span>
<span class="line-removed">4511           tty-&gt;print(&quot; &quot;);</span>
4512           m-&gt;dump();
4513         }
4514       }
4515     }
4516   }
4517 }
4518 #endif
4519 
4520 // Collect a R-P-O for the whole CFG.
4521 // Result list is in post-order (scan backwards for RPO)
<span class="line-modified">4522 void PhaseIdealLoop::rpo( Node *start, Node_Stack &amp;stk, VectorSet &amp;visited, Node_List &amp;rpo_list ) const {</span>
4523   stk.push(start, 0);
4524   visited.set(start-&gt;_idx);
4525 
4526   while (stk.is_nonempty()) {
4527     Node* m   = stk.node();
4528     uint  idx = stk.index();
4529     if (idx &lt; m-&gt;outcnt()) {
4530       stk.set_index(idx + 1);
4531       Node* n = m-&gt;raw_out(idx);
4532       if (n-&gt;is_CFG() &amp;&amp; !visited.test_set(n-&gt;_idx)) {
4533         stk.push(n, 0);
4534       }
4535     } else {
4536       rpo_list.push(m);
4537       stk.pop();
4538     }
4539   }
4540 }
4541 
4542 
4543 //=============================================================================
<span class="line-modified">4544 //------------------------------LoopTreeIterator-----------------------------------</span>
4545 
4546 // Advance to next loop tree using a preorder, left-to-right traversal.
4547 void LoopTreeIterator::next() {
4548   assert(!done(), &quot;must not be done.&quot;);
4549   if (_curnt-&gt;_child != NULL) {
4550     _curnt = _curnt-&gt;_child;
4551   } else if (_curnt-&gt;_next != NULL) {
4552     _curnt = _curnt-&gt;_next;
4553   } else {
4554     while (_curnt != _root &amp;&amp; _curnt-&gt;_next == NULL) {
4555       _curnt = _curnt-&gt;_parent;
4556     }
4557     if (_curnt == _root) {
4558       _curnt = NULL;
4559       assert(done(), &quot;must be done.&quot;);
4560     } else {
4561       assert(_curnt-&gt;_next != NULL, &quot;must be more to do&quot;);
4562       _curnt = _curnt-&gt;_next;
4563     }
4564   }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciMethodData.hpp&quot;
  27 #include &quot;compiler/compileLog.hpp&quot;
  28 #include &quot;gc/shared/barrierSet.hpp&quot;
  29 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  30 #include &quot;libadt/vectset.hpp&quot;
  31 #include &quot;memory/allocation.inline.hpp&quot;
  32 #include &quot;memory/resourceArea.hpp&quot;
  33 #include &quot;opto/addnode.hpp&quot;
  34 #include &quot;opto/callnode.hpp&quot;
  35 #include &quot;opto/connode.hpp&quot;
  36 #include &quot;opto/convertnode.hpp&quot;
  37 #include &quot;opto/divnode.hpp&quot;
  38 #include &quot;opto/idealGraphPrinter.hpp&quot;
  39 #include &quot;opto/loopnode.hpp&quot;
  40 #include &quot;opto/mulnode.hpp&quot;
  41 #include &quot;opto/rootnode.hpp&quot;
  42 #include &quot;opto/superword.hpp&quot;
<span class="line-added">  43 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  44 
  45 //=============================================================================
<span class="line-modified">  46 //--------------------------is_cloop_ind_var-----------------------------------</span>
<span class="line-modified">  47 // Determine if a node is a counted loop induction variable.</span>
<span class="line-modified">  48 // NOTE: The method is declared in &quot;node.hpp&quot;.</span>
<span class="line-modified">  49 bool Node::is_cloop_ind_var() const {</span>
<span class="line-modified">  50   return (is_Phi() &amp;&amp; !as_Phi()-&gt;is_copy() &amp;&amp;</span>
<span class="line-modified">  51           as_Phi()-&gt;region()-&gt;is_CountedLoop() &amp;&amp;</span>
<span class="line-modified">  52           as_Phi()-&gt;region()-&gt;as_CountedLoop()-&gt;phi() == this);</span>




  53 }
  54 
  55 //=============================================================================
  56 //------------------------------dump_spec--------------------------------------
  57 // Dump special per-node info
  58 #ifndef PRODUCT
  59 void LoopNode::dump_spec(outputStream *st) const {
  60   if (is_inner_loop()) st-&gt;print( &quot;inner &quot; );
  61   if (is_partial_peel_loop()) st-&gt;print( &quot;partial_peel &quot; );
  62   if (partial_peel_has_failed()) st-&gt;print( &quot;partial_peel_failed &quot; );
  63 }
  64 #endif
  65 
  66 //------------------------------is_valid_counted_loop-------------------------
  67 bool LoopNode::is_valid_counted_loop() const {
  68   if (is_CountedLoop()) {
  69     CountedLoopNode*    l  = as_CountedLoop();
  70     CountedLoopEndNode* le = l-&gt;loopexit_or_null();
  71     if (le != NULL &amp;&amp;
  72         le-&gt;proj_out_or_null(1 /* true */) == l-&gt;in(LoopNode::LoopBackControl)) {
</pre>
<hr />
<pre>
 928     limit = _igvn.intcon(final_int);
 929   } else {
 930     // Create new LoopLimit node to get exact limit (final iv value).
 931     limit = new LoopLimitNode(C, cl-&gt;init_trip(), cl-&gt;limit(), cl-&gt;stride());
 932     register_new_node(limit, cl-&gt;in(LoopNode::EntryControl));
 933   }
 934   assert(limit != NULL, &quot;sanity&quot;);
 935   return limit;
 936 }
 937 
 938 //------------------------------Ideal------------------------------------------
 939 // Return a node which is more &quot;ideal&quot; than the current node.
 940 // Attempt to convert into a counted-loop.
 941 Node *LoopNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 942   if (!can_be_counted_loop(phase) &amp;&amp; !is_OuterStripMinedLoop()) {
 943     phase-&gt;C-&gt;set_major_progress();
 944   }
 945   return RegionNode::Ideal(phase, can_reshape);
 946 }
 947 

 948 #ifdef ASSERT
<span class="line-added"> 949 void LoopNode::verify_strip_mined(int expect_skeleton) const {</span>
 950   const OuterStripMinedLoopNode* outer = NULL;
 951   const CountedLoopNode* inner = NULL;
 952   if (is_strip_mined()) {
<span class="line-added"> 953     if (!is_valid_counted_loop()) {</span>
<span class="line-added"> 954       return; // Skip malformed counted loop</span>
<span class="line-added"> 955     }</span>
 956     assert(is_CountedLoop(), &quot;no Loop should be marked strip mined&quot;);
 957     inner = as_CountedLoop();
 958     outer = inner-&gt;in(LoopNode::EntryControl)-&gt;as_OuterStripMinedLoop();
 959   } else if (is_OuterStripMinedLoop()) {
 960     outer = this-&gt;as_OuterStripMinedLoop();
 961     inner = outer-&gt;unique_ctrl_out()-&gt;as_CountedLoop();
<span class="line-added"> 962     assert(inner-&gt;is_valid_counted_loop() &amp;&amp; inner-&gt;is_strip_mined(), &quot;OuterStripMinedLoop should have been removed&quot;);</span>
 963     assert(!is_strip_mined(), &quot;outer loop shouldn&#39;t be marked strip mined&quot;);
 964   }
 965   if (inner != NULL || outer != NULL) {
 966     assert(inner != NULL &amp;&amp; outer != NULL, &quot;missing loop in strip mined nest&quot;);
 967     Node* outer_tail = outer-&gt;in(LoopNode::LoopBackControl);
 968     Node* outer_le = outer_tail-&gt;in(0);
 969     assert(outer_le-&gt;Opcode() == Op_OuterStripMinedLoopEnd, &quot;tail of outer loop should be an If&quot;);
 970     Node* sfpt = outer_le-&gt;in(0);
 971     assert(sfpt-&gt;Opcode() == Op_SafePoint, &quot;where&#39;s the safepoint?&quot;);
 972     Node* inner_out = sfpt-&gt;in(0);
 973     if (inner_out-&gt;outcnt() != 1) {
 974       ResourceMark rm;
 975       Unique_Node_List wq;
 976 
 977       for (DUIterator_Fast imax, i = inner_out-&gt;fast_outs(imax); i &lt; imax; i++) {
 978         Node* u = inner_out-&gt;fast_out(i);
 979         if (u == sfpt) {
 980           continue;
 981         }
 982         wq.clear();
 983         wq.push(u);
 984         bool found_sfpt = false;
 985         for (uint next = 0; next &lt; wq.size() &amp;&amp; !found_sfpt; next++) {
<span class="line-modified"> 986           Node* n = wq.at(next);</span>
 987           for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax &amp;&amp; !found_sfpt; i++) {
 988             Node* u = n-&gt;fast_out(i);
 989             if (u == sfpt) {
 990               found_sfpt = true;
 991             }
 992             if (!u-&gt;is_CFG()) {
 993               wq.push(u);
 994             }
 995           }
 996         }
 997         assert(found_sfpt, &quot;no node in loop that&#39;s not input to safepoint&quot;);
 998       }
 999     }
<span class="line-added">1000 </span>
1001     CountedLoopEndNode* cle = inner_out-&gt;in(0)-&gt;as_CountedLoopEnd();
1002     assert(cle == inner-&gt;loopexit_or_null(), &quot;mismatch&quot;);
1003     bool has_skeleton = outer_le-&gt;in(1)-&gt;bottom_type()-&gt;singleton() &amp;&amp; outer_le-&gt;in(1)-&gt;bottom_type()-&gt;is_int()-&gt;get_con() == 0;
1004     if (has_skeleton) {
1005       assert(expect_skeleton == 1 || expect_skeleton == -1, &quot;unexpected skeleton node&quot;);
1006       assert(outer-&gt;outcnt() == 2, &quot;only phis&quot;);
1007     } else {
1008       assert(expect_skeleton == 0 || expect_skeleton == -1, &quot;no skeleton node?&quot;);
1009       uint phis = 0;
1010       for (DUIterator_Fast imax, i = inner-&gt;fast_outs(imax); i &lt; imax; i++) {
1011         Node* u = inner-&gt;fast_out(i);
1012         if (u-&gt;is_Phi()) {
1013           phis++;
1014         }
1015       }
1016       for (DUIterator_Fast imax, i = outer-&gt;fast_outs(imax); i &lt; imax; i++) {
1017         Node* u = outer-&gt;fast_out(i);
1018         assert(u == outer || u == inner || u-&gt;is_Phi(), &quot;nothing between inner and outer loop&quot;);
1019       }
1020       uint stores = 0;
1021       for (DUIterator_Fast imax, i = inner_out-&gt;fast_outs(imax); i &lt; imax; i++) {
1022         Node* u = inner_out-&gt;fast_out(i);
1023         if (u-&gt;is_Store()) {
1024           stores++;
1025         }
1026       }
1027       assert(outer-&gt;outcnt() &gt;= phis + 2 &amp;&amp; outer-&gt;outcnt() &lt;= phis + 2 + stores + 1, &quot;only phis&quot;);
1028     }
1029     assert(sfpt-&gt;outcnt() == 1, &quot;no data node&quot;);
1030     assert(outer_tail-&gt;outcnt() == 1 || !has_skeleton, &quot;no data node&quot;);
1031   }

1032 }
<span class="line-added">1033 #endif</span>
1034 
1035 //=============================================================================
1036 //------------------------------Ideal------------------------------------------
1037 // Return a node which is more &quot;ideal&quot; than the current node.
1038 // Attempt to convert into a counted-loop.
1039 Node *CountedLoopNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1040   return RegionNode::Ideal(phase, can_reshape);
1041 }
1042 
1043 //------------------------------dump_spec--------------------------------------
1044 // Dump special per-node info
1045 #ifndef PRODUCT
1046 void CountedLoopNode::dump_spec(outputStream *st) const {
1047   LoopNode::dump_spec(st);
1048   if (stride_is_con()) {
1049     st-&gt;print(&quot;stride: %d &quot;,stride_con());
1050   }
1051   if (is_pre_loop ()) st-&gt;print(&quot;pre of N%d&quot; , _main_idx);
1052   if (is_main_loop()) st-&gt;print(&quot;main of N%d&quot;, _idx);
1053   if (is_post_loop()) st-&gt;print(&quot;post of N%d&quot;, _main_idx);
</pre>
<hr />
<pre>
1224         trunc_t = TypeInt::SHORT;
1225       } else if (shift == 8) {
1226         trunc_t = TypeInt::BYTE;
1227       }
1228     }
1229   }
1230 
1231   // If (maybe after stripping) it is an AddI, we won:
1232   if (n1op == Op_AddI) {
1233     *trunc1 = t1;
1234     *trunc2 = t2;
1235     *trunc_type = trunc_t;
1236     return n1;
1237   }
1238 
1239   // failed
1240   return NULL;
1241 }
1242 
1243 LoopNode* CountedLoopNode::skip_strip_mined(int expect_skeleton) {
<span class="line-modified">1244   if (is_strip_mined() &amp;&amp; is_valid_counted_loop()) {</span>
1245     verify_strip_mined(expect_skeleton);
1246     return in(EntryControl)-&gt;as_Loop();
1247   }
1248   return this;
1249 }
1250 
1251 OuterStripMinedLoopNode* CountedLoopNode::outer_loop() const {
1252   assert(is_strip_mined(), &quot;not a strip mined loop&quot;);
1253   Node* c = in(EntryControl);
1254   if (c == NULL || c-&gt;is_top() || !c-&gt;is_OuterStripMinedLoop()) {
1255     return NULL;
1256   }
1257   return c-&gt;as_OuterStripMinedLoop();
1258 }
1259 
1260 IfTrueNode* OuterStripMinedLoopNode::outer_loop_tail() const {
1261   Node* c = in(LoopBackControl);
1262   if (c == NULL || c-&gt;is_top()) {
1263     return NULL;
1264   }
</pre>
<hr />
<pre>
1786           // Go ahead and clean out old edges from old phi
1787           old_phi-&gt;del_req(i);
1788         }
1789       }
1790       // Search for CSE&#39;s here, because ZKM.jar does a lot of
1791       // loop hackery and we need to be a little incremental
1792       // with the CSE to avoid O(N^2) node blow-up.
1793       Node *p2 = igvn.hash_find_insert(p); // Look for a CSE
1794       if( p2 ) {                // Found CSE
1795         p-&gt;destruct();          // Recover useless new node
1796         p = p2;                 // Use old node
1797       } else {
1798         igvn.register_new_node_with_optimizer(p, old_phi);
1799       }
1800       // Make old Phi refer to new Phi.
1801       old_phi-&gt;add_req(p);
1802       // Check for the special case of making the old phi useless and
1803       // disappear it.  In JavaGrande I have a case where this useless
1804       // Phi is the loop limit and prevents recognizing a CountedLoop
1805       // which in turn prevents removing an empty loop.
<span class="line-modified">1806       Node *id_old_phi = old_phi-&gt;Identity(&amp;igvn);</span>
1807       if( id_old_phi != old_phi ) { // Found a simple identity?
1808         // Note that I cannot call &#39;replace_node&#39; here, because
1809         // that will yank the edge from old_phi to the Region and
1810         // I&#39;m mid-iteration over the Region&#39;s uses.
1811         for (DUIterator_Last imin, i = old_phi-&gt;last_outs(imin); i &gt;= imin; ) {
1812           Node* use = old_phi-&gt;last_out(i);
1813           igvn.rehash_node_delayed(use);
1814           uint uses_found = 0;
1815           for (uint j = 0; j &lt; use-&gt;len(); j++) {
1816             if (use-&gt;in(j) == old_phi) {
1817               if (j &lt; use-&gt;req()) use-&gt;set_req (j, id_old_phi);
1818               else                use-&gt;set_prec(j, id_old_phi);
1819               uses_found++;
1820             }
1821           }
1822           i -= uses_found;    // we deleted 1 or more copies of this edge
1823         }
1824       }
1825       igvn._worklist.push(old_phi);
1826     }
</pre>
<hr />
<pre>
2109     l = igvn.register_new_node_with_optimizer(l, _head);
2110     phase-&gt;set_created_loop_node();
2111     // Go ahead and replace _head
2112     phase-&gt;_igvn.replace_node( _head, l );
2113     _head = l;
2114     phase-&gt;set_loop(_head, this);
2115   }
2116 
2117   // Now recursively beautify nested loops
2118   if( _child ) result |= _child-&gt;beautify_loops( phase );
2119   if( _next  ) result |= _next -&gt;beautify_loops( phase );
2120   return result;
2121 }
2122 
2123 //------------------------------allpaths_check_safepts----------------------------
2124 // Allpaths backwards scan from loop tail, terminating each path at first safepoint
2125 // encountered.  Helper for check_safepts.
2126 void IdealLoopTree::allpaths_check_safepts(VectorSet &amp;visited, Node_List &amp;stack) {
2127   assert(stack.size() == 0, &quot;empty stack&quot;);
2128   stack.push(_tail);
<span class="line-modified">2129   visited.clear();</span>
2130   visited.set(_tail-&gt;_idx);
2131   while (stack.size() &gt; 0) {
2132     Node* n = stack.pop();
2133     if (n-&gt;is_Call() &amp;&amp; n-&gt;as_Call()-&gt;guaranteed_safepoint()) {
2134       // Terminate this path
2135     } else if (n-&gt;Opcode() == Op_SafePoint) {
2136       if (_phase-&gt;get_loop(n) != this) {
2137         if (_required_safept == NULL) _required_safept = new Node_List();
2138         _required_safept-&gt;push(n);  // save the one closest to the tail
2139       }
2140       // Terminate this path
2141     } else {
2142       uint start = n-&gt;is_Region() ? 1 : 0;
2143       uint end   = n-&gt;is_Region() &amp;&amp; !n-&gt;is_Loop() ? n-&gt;req() : start + 1;
2144       for (uint i = start; i &lt; end; i++) {
2145         Node* in = n-&gt;in(i);
2146         assert(in-&gt;is_CFG(), &quot;must be&quot;);
2147         if (!visited.test_set(in-&gt;_idx) &amp;&amp; is_member(_phase-&gt;get_loop(in))) {
2148           stack.push(in);
2149         }
</pre>
<hr />
<pre>
2428     // Remove safepoints
2429     bool keep_one_sfpt = !(_has_call || _has_sfpt);
2430     remove_safepoints(phase, keep_one_sfpt);
2431 
2432     // Look for induction variables
2433     phase-&gt;replace_parallel_iv(this);
2434 
2435   } else if (_parent != NULL &amp;&amp; !_irreducible) {
2436     // Not a counted loop. Keep one safepoint.
2437     bool keep_one_sfpt = true;
2438     remove_safepoints(phase, keep_one_sfpt);
2439   }
2440 
2441   // Recursively
2442   assert(loop-&gt;_child != this || (loop-&gt;_head-&gt;as_Loop()-&gt;is_OuterStripMinedLoop() &amp;&amp; _head-&gt;as_CountedLoop()-&gt;is_strip_mined()), &quot;what kind of loop was added?&quot;);
2443   assert(loop-&gt;_child != this || (loop-&gt;_child-&gt;_child == NULL &amp;&amp; loop-&gt;_child-&gt;_next == NULL), &quot;would miss some loops&quot;);
2444   if (loop-&gt;_child &amp;&amp; loop-&gt;_child != this) loop-&gt;_child-&gt;counted_loop(phase);
2445   if (loop-&gt;_next)  loop-&gt;_next -&gt;counted_loop(phase);
2446 }
2447 
<span class="line-added">2448 </span>
<span class="line-added">2449 // The Estimated Loop Clone Size:</span>
<span class="line-added">2450 //   CloneFactor * (~112% * BodySize + BC) + CC + FanOutTerm,</span>
<span class="line-added">2451 // where  BC and  CC are  totally ad-hoc/magic  &quot;body&quot; and &quot;clone&quot; constants,</span>
<span class="line-added">2452 // respectively, used to ensure that the node usage estimates made are on the</span>
<span class="line-added">2453 // safe side, for the most part. The FanOutTerm is an attempt to estimate the</span>
<span class="line-added">2454 // possible additional/excessive nodes generated due to data and control flow</span>
<span class="line-added">2455 // merging, for edges reaching outside the loop.</span>
<span class="line-added">2456 uint IdealLoopTree::est_loop_clone_sz(uint factor) const {</span>
<span class="line-added">2457 </span>
<span class="line-added">2458   precond(0 &lt; factor &amp;&amp; factor &lt; 16);</span>
<span class="line-added">2459 </span>
<span class="line-added">2460   uint const bc = 13;</span>
<span class="line-added">2461   uint const cc = 17;</span>
<span class="line-added">2462   uint const sz = _body.size() + (_body.size() + 7) / 8;</span>
<span class="line-added">2463   uint estimate = factor * (sz + bc) + cc;</span>
<span class="line-added">2464 </span>
<span class="line-added">2465   assert((estimate - cc) / factor == sz + bc, &quot;overflow&quot;);</span>
<span class="line-added">2466 </span>
<span class="line-added">2467   return estimate + est_loop_flow_merge_sz();</span>
<span class="line-added">2468 }</span>
<span class="line-added">2469 </span>
<span class="line-added">2470 // The Estimated Loop (full-) Unroll Size:</span>
<span class="line-added">2471 //   UnrollFactor * (~106% * BodySize) + CC + FanOutTerm,</span>
<span class="line-added">2472 // where CC is a (totally) ad-hoc/magic &quot;clone&quot; constant, used to ensure that</span>
<span class="line-added">2473 // node usage estimates made are on the safe side, for the most part. This is</span>
<span class="line-added">2474 // a &quot;light&quot; version of the loop clone size calculation (above), based on the</span>
<span class="line-added">2475 // assumption that most of the loop-construct overhead will be unraveled when</span>
<span class="line-added">2476 // (fully) unrolled. Defined for unroll factors larger or equal to one (&gt;=1),</span>
<span class="line-added">2477 // including an overflow check and returning UINT_MAX in case of an overflow.</span>
<span class="line-added">2478 uint IdealLoopTree::est_loop_unroll_sz(uint factor) const {</span>
<span class="line-added">2479 </span>
<span class="line-added">2480   precond(factor &gt; 0);</span>
<span class="line-added">2481 </span>
<span class="line-added">2482   // Take into account that after unroll conjoined heads and tails will fold.</span>
<span class="line-added">2483   uint const b0 = _body.size() - EMPTY_LOOP_SIZE;</span>
<span class="line-added">2484   uint const cc = 7;</span>
<span class="line-added">2485   uint const sz = b0 + (b0 + 15) / 16;</span>
<span class="line-added">2486   uint estimate = factor * sz + cc;</span>
<span class="line-added">2487 </span>
<span class="line-added">2488   if ((estimate - cc) / factor != sz) {</span>
<span class="line-added">2489     return UINT_MAX;</span>
<span class="line-added">2490   }</span>
<span class="line-added">2491 </span>
<span class="line-added">2492   return estimate + est_loop_flow_merge_sz();</span>
<span class="line-added">2493 }</span>
<span class="line-added">2494 </span>
<span class="line-added">2495 // Estimate the growth effect (in nodes) of merging control and data flow when</span>
<span class="line-added">2496 // cloning a loop body, based on the amount of  control and data flow reaching</span>
<span class="line-added">2497 // outside of the (current) loop body.</span>
<span class="line-added">2498 uint IdealLoopTree::est_loop_flow_merge_sz() const {</span>
<span class="line-added">2499 </span>
<span class="line-added">2500   uint ctrl_edge_out_cnt = 0;</span>
<span class="line-added">2501   uint data_edge_out_cnt = 0;</span>
<span class="line-added">2502 </span>
<span class="line-added">2503   for (uint i = 0; i &lt; _body.size(); i++) {</span>
<span class="line-added">2504     Node* node = _body.at(i);</span>
<span class="line-added">2505     uint outcnt = node-&gt;outcnt();</span>
<span class="line-added">2506 </span>
<span class="line-added">2507     for (uint k = 0; k &lt; outcnt; k++) {</span>
<span class="line-added">2508       Node* out = node-&gt;raw_out(k);</span>
<span class="line-added">2509       if (out == NULL) continue;</span>
<span class="line-added">2510       if (out-&gt;is_CFG()) {</span>
<span class="line-added">2511         if (!is_member(_phase-&gt;get_loop(out))) {</span>
<span class="line-added">2512           ctrl_edge_out_cnt++;</span>
<span class="line-added">2513         }</span>
<span class="line-added">2514       } else if (_phase-&gt;has_ctrl(out)) {</span>
<span class="line-added">2515         Node* ctrl = _phase-&gt;get_ctrl(out);</span>
<span class="line-added">2516         assert(ctrl != NULL, &quot;must be&quot;);</span>
<span class="line-added">2517         assert(ctrl-&gt;is_CFG(), &quot;must be&quot;);</span>
<span class="line-added">2518         if (!is_member(_phase-&gt;get_loop(ctrl))) {</span>
<span class="line-added">2519           data_edge_out_cnt++;</span>
<span class="line-added">2520         }</span>
<span class="line-added">2521       }</span>
<span class="line-added">2522     }</span>
<span class="line-added">2523   }</span>
<span class="line-added">2524   // Use data and control count (x2.0) in estimate iff both are &gt; 0. This is</span>
<span class="line-added">2525   // a rather pessimistic estimate for the most part, in particular for some</span>
<span class="line-added">2526   // complex loops, but still not enough to capture all loops.</span>
<span class="line-added">2527   if (ctrl_edge_out_cnt &gt; 0 &amp;&amp; data_edge_out_cnt &gt; 0) {</span>
<span class="line-added">2528     return 2 * (ctrl_edge_out_cnt + data_edge_out_cnt);</span>
<span class="line-added">2529   }</span>
<span class="line-added">2530   return 0;</span>
<span class="line-added">2531 }</span>
<span class="line-added">2532 </span>
2533 #ifndef PRODUCT
2534 //------------------------------dump_head--------------------------------------
2535 // Dump 1 liner for loop header info
<span class="line-modified">2536 void IdealLoopTree::dump_head() const {</span>
<span class="line-modified">2537   tty-&gt;sp(2 * _nest);</span>
<span class="line-modified">2538   tty-&gt;print(&quot;Loop: N%d/N%d &quot;, _head-&gt;_idx, _tail-&gt;_idx);</span>

2539   if (_irreducible) tty-&gt;print(&quot; IRREDUCIBLE&quot;);
2540   Node* entry = _head-&gt;is_Loop() ? _head-&gt;as_Loop()-&gt;skip_strip_mined(-1)-&gt;in(LoopNode::EntryControl) : _head-&gt;in(LoopNode::EntryControl);
2541   Node* predicate = PhaseIdealLoop::find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
2542   if (predicate != NULL ) {
2543     tty-&gt;print(&quot; limit_check&quot;);
2544     entry = PhaseIdealLoop::skip_loop_predicates(entry);
2545   }
2546   if (UseLoopPredicate) {
2547     entry = PhaseIdealLoop::find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
2548     if (entry != NULL) {
2549       tty-&gt;print(&quot; predicated&quot;);
2550       entry = PhaseIdealLoop::skip_loop_predicates(entry);
2551     }
2552   }
2553   if (UseProfiledLoopPredicate) {
2554     entry = PhaseIdealLoop::find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);
2555     if (entry != NULL) {
2556       tty-&gt;print(&quot; profile_predicated&quot;);
2557     }
2558   }
</pre>
<hr />
<pre>
2586   if (_has_call) tty-&gt;print(&quot; has_call&quot;);
2587   if (_has_sfpt) tty-&gt;print(&quot; has_sfpt&quot;);
2588   if (_rce_candidate) tty-&gt;print(&quot; rce&quot;);
2589   if (_safepts != NULL &amp;&amp; _safepts-&gt;size() &gt; 0) {
2590     tty-&gt;print(&quot; sfpts={&quot;); _safepts-&gt;dump_simple(); tty-&gt;print(&quot; }&quot;);
2591   }
2592   if (_required_safept != NULL &amp;&amp; _required_safept-&gt;size() &gt; 0) {
2593     tty-&gt;print(&quot; req={&quot;); _required_safept-&gt;dump_simple(); tty-&gt;print(&quot; }&quot;);
2594   }
2595   if (Verbose) {
2596     tty-&gt;print(&quot; body={&quot;); _body.dump_simple(); tty-&gt;print(&quot; }&quot;);
2597   }
2598   if (_head-&gt;is_Loop() &amp;&amp; _head-&gt;as_Loop()-&gt;is_strip_mined()) {
2599     tty-&gt;print(&quot; strip_mined&quot;);
2600   }
2601   tty-&gt;cr();
2602 }
2603 
2604 //------------------------------dump-------------------------------------------
2605 // Dump loops by loop tree
<span class="line-modified">2606 void IdealLoopTree::dump() const {</span>
2607   dump_head();
2608   if (_child) _child-&gt;dump();
2609   if (_next)  _next -&gt;dump();
2610 }
2611 
2612 #endif
2613 
2614 static void log_loop_tree(IdealLoopTree* root, IdealLoopTree* loop, CompileLog* log) {
2615   if (loop == root) {
2616     if (loop-&gt;_child != NULL) {
2617       log-&gt;begin_head(&quot;loop_tree&quot;);
2618       log-&gt;end_head();
2619       if( loop-&gt;_child ) log_loop_tree(root, loop-&gt;_child, log);
2620       log-&gt;tail(&quot;loop_tree&quot;);
2621       assert(loop-&gt;_next == NULL, &quot;what?&quot;);
2622     }
2623   } else {
2624     Node* head = loop-&gt;_head;
2625     log-&gt;begin_head(&quot;loop&quot;);
2626     log-&gt;print(&quot; idx=&#39;%d&#39; &quot;, head-&gt;_idx);
</pre>
<hr />
<pre>
2783         if (n2-&gt;in(0) != c2) {
2784           _igvn.hash_delete(n2);
2785           n2-&gt;set_req(0, c2);
2786           _igvn.hash_insert(n2);
2787           _igvn._worklist.push(n2);
2788           progress = true;
2789         }
2790       }
2791     }
2792   }
2793 
2794   return progress;
2795 }
2796 
2797 
2798 //=============================================================================
2799 //----------------------------build_and_optimize-------------------------------
2800 // Create a PhaseLoop.  Build the ideal Loop tree.  Map each Ideal Node to
2801 // its corresponding LoopNode.  If &#39;optimize&#39; is true, do some loop cleanups.
2802 void PhaseIdealLoop::build_and_optimize(LoopOptsMode mode) {
<span class="line-modified">2803   bool do_split_ifs = (mode == LoopOptsDefault);</span>
2804   bool skip_loop_opts = (mode == LoopOptsNone);
2805 
2806   int old_progress = C-&gt;major_progress();
2807   uint orig_worklist_size = _igvn._worklist.size();
2808 
2809   // Reset major-progress flag for the driver&#39;s heuristics
2810   C-&gt;clear_major_progress();
2811 
2812 #ifndef PRODUCT
2813   // Capture for later assert
2814   uint unique = C-&gt;unique();
2815   _loop_invokes++;
2816   _loop_work += unique;
2817 #endif
2818 
2819   // True if the method has at least 1 irreducible loop
2820   _has_irreducible_loops = false;
2821 
2822   _created_loop_node = false;
2823 
</pre>
<hr />
<pre>
2919         i--;                      // Rerun same iteration on compressed edges
2920       }
2921     }
2922 
2923     // Given dominators, try to find inner loops with calls that must
2924     // always be executed (call dominates loop tail).  These loops do
2925     // not need a separate safepoint.
2926     Node_List cisstack(a);
2927     _ltree_root-&gt;check_safepts(visited, cisstack);
2928   }
2929 
2930   // Walk the DATA nodes and place into loops.  Find earliest control
2931   // node.  For CFG nodes, the _nodes array starts out and remains
2932   // holding the associated IdealLoopTree pointer.  For DATA nodes, the
2933   // _nodes array holds the earliest legal controlling CFG node.
2934 
2935   // Allocate stack with enough space to avoid frequent realloc
2936   int stack_size = (C-&gt;live_nodes() &gt;&gt; 1) + 16; // (live_nodes&gt;&gt;1)+16 from Java2D stats
2937   Node_Stack nstack( a, stack_size );
2938 
<span class="line-modified">2939   visited.clear();</span>
2940   Node_List worklist(a);
2941   // Don&#39;t need C-&gt;root() on worklist since
2942   // it will be processed among C-&gt;top() inputs
<span class="line-modified">2943   worklist.push(C-&gt;top());</span>
<span class="line-modified">2944   visited.set(C-&gt;top()-&gt;_idx); // Set C-&gt;top() as visited now</span>
2945   build_loop_early( visited, worklist, nstack );
2946 
2947   // Given early legal placement, try finding counted loops.  This placement
2948   // is good enough to discover most loop invariants.
2949   if (!_verify_me &amp;&amp; !_verify_only &amp;&amp; !strip_mined_loops_expanded) {
2950     _ltree_root-&gt;counted_loop( this );
2951   }
2952 
2953   // Find latest loop placement.  Find ideal loop placement.
<span class="line-modified">2954   visited.clear();</span>
2955   init_dom_lca_tags();
2956   // Need C-&gt;root() on worklist when processing outs
<span class="line-modified">2957   worklist.push(C-&gt;root());</span>
2958   NOT_PRODUCT( C-&gt;verify_graph_edges(); )
<span class="line-modified">2959   worklist.push(C-&gt;top());</span>
2960   build_loop_late( visited, worklist, nstack );
2961 
2962   if (_verify_only) {
<span class="line-modified">2963     C-&gt;restore_major_progress(old_progress);</span>


2964     assert(C-&gt;unique() == unique, &quot;verification mode made Nodes? ? ?&quot;);
2965     assert(_igvn._worklist.size() == orig_worklist_size, &quot;shouldn&#39;t push anything&quot;);
2966     return;
2967   }
2968 
2969   // clear out the dead code after build_loop_late
2970   while (_deadlist.size()) {
2971     _igvn.remove_globally_dead_node(_deadlist.pop());
2972   }
2973 
2974   if (stop_early) {
2975     assert(do_expensive_nodes, &quot;why are we here?&quot;);
2976     if (process_expensive_nodes()) {
2977       // If we made some progress when processing expensive nodes then
2978       // the IGVN may modify the graph in a way that will allow us to
2979       // make some more progress: we need to try processing expensive
2980       // nodes again.
2981       C-&gt;set_major_progress();
2982     }
2983     _igvn.optimize();
2984     return;
2985   }
2986 
2987   // Some parser-inserted loop predicates could never be used by loop
2988   // predication or they were moved away from loop during some optimizations.
2989   // For example, peeling. Eliminate them before next loop optimizations.
2990   eliminate_useless_predicates();
2991 
2992 #ifndef PRODUCT
2993   C-&gt;verify_graph_edges();
2994   if (_verify_me) {             // Nested verify pass?
2995     // Check to see if the verify mode is broken
2996     assert(C-&gt;unique() == unique, &quot;non-optimize mode made Nodes? ? ?&quot;);
2997     return;
2998   }
<span class="line-modified">2999   if (VerifyLoopOptimizations) verify();</span>
<span class="line-modified">3000   if (TraceLoopOpts &amp;&amp; C-&gt;has_loops()) {</span>
3001     _ltree_root-&gt;dump();
3002   }
3003 #endif
3004 
3005   if (skip_loop_opts) {
3006     // restore major progress flag
<span class="line-modified">3007     C-&gt;restore_major_progress(old_progress);</span>


3008 
3009     // Cleanup any modified bits
3010     _igvn.optimize();
3011 
3012     if (C-&gt;log() != NULL) {
3013       log_loop_tree(_ltree_root, _ltree_root, C-&gt;log());
3014     }
3015     return;
3016   }
3017 
<span class="line-added">3018   if (mode == LoopOptsMaxUnroll) {</span>
<span class="line-added">3019     for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {</span>
<span class="line-added">3020       IdealLoopTree* lpt = iter.current();</span>
<span class="line-added">3021       if (lpt-&gt;is_innermost() &amp;&amp; lpt-&gt;_allow_optimizations &amp;&amp; !lpt-&gt;_has_call &amp;&amp; lpt-&gt;is_counted()) {</span>
<span class="line-added">3022         lpt-&gt;compute_trip_count(this);</span>
<span class="line-added">3023         if (!lpt-&gt;do_one_iteration_loop(this) &amp;&amp;</span>
<span class="line-added">3024             !lpt-&gt;do_remove_empty_loop(this)) {</span>
<span class="line-added">3025           AutoNodeBudget node_budget(this);</span>
<span class="line-added">3026           if (lpt-&gt;_head-&gt;as_CountedLoop()-&gt;is_normal_loop() &amp;&amp;</span>
<span class="line-added">3027               lpt-&gt;policy_maximally_unroll(this)) {</span>
<span class="line-added">3028             memset( worklist.adr(), 0, worklist.Size()*sizeof(Node*) );</span>
<span class="line-added">3029             do_maximally_unroll(lpt, worklist);</span>
<span class="line-added">3030           }</span>
<span class="line-added">3031         }</span>
<span class="line-added">3032       }</span>
<span class="line-added">3033     }</span>
<span class="line-added">3034 </span>
<span class="line-added">3035     C-&gt;restore_major_progress(old_progress);</span>
<span class="line-added">3036 </span>
<span class="line-added">3037     _igvn.optimize();</span>
<span class="line-added">3038 </span>
<span class="line-added">3039     if (C-&gt;log() != NULL) {</span>
<span class="line-added">3040       log_loop_tree(_ltree_root, _ltree_root, C-&gt;log());</span>
<span class="line-added">3041     }</span>
<span class="line-added">3042     return;</span>
<span class="line-added">3043   }</span>
<span class="line-added">3044 </span>
3045   if (bs-&gt;optimize_loops(this, mode, visited, nstack, worklist)) {
3046     _igvn.optimize();
3047     if (C-&gt;log() != NULL) {
3048       log_loop_tree(_ltree_root, _ltree_root, C-&gt;log());
3049     }
3050     return;
3051   }
3052 
3053   if (ReassociateInvariants) {
3054     // Reassociate invariants and prep for split_thru_phi
3055     for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {
3056       IdealLoopTree* lpt = iter.current();
3057       bool is_counted = lpt-&gt;is_counted();
<span class="line-modified">3058       if (!is_counted || !lpt-&gt;is_innermost()) continue;</span>
3059 
3060       // check for vectorized loops, any reassociation of invariants was already done
<span class="line-modified">3061       if (is_counted &amp;&amp; lpt-&gt;_head-&gt;as_CountedLoop()-&gt;is_unroll_only()) {</span>
<span class="line-modified">3062         continue;</span>
<span class="line-modified">3063       } else {</span>
<span class="line-modified">3064         AutoNodeBudget node_budget(this);</span>
<span class="line-added">3065         lpt-&gt;reassociate_invariants(this);</span>
<span class="line-added">3066       }</span>
3067       // Because RCE opportunities can be masked by split_thru_phi,
3068       // look for RCE candidates and inhibit split_thru_phi
3069       // on just their loop-phi&#39;s for this pass of loop opts
3070       if (SplitIfBlocks &amp;&amp; do_split_ifs) {
<span class="line-added">3071         AutoNodeBudget node_budget(this, AutoNodeBudget::NO_BUDGET_CHECK);</span>
3072         if (lpt-&gt;policy_range_check(this)) {
3073           lpt-&gt;_rce_candidate = 1; // = true
3074         }
3075       }
3076     }
3077   }
3078 
3079   // Check for aggressive application of split-if and other transforms
3080   // that require basic-block info (like cloning through Phi&#39;s)
3081   if( SplitIfBlocks &amp;&amp; do_split_ifs ) {
<span class="line-modified">3082     visited.clear();</span>
<span class="line-modified">3083     split_if_with_blocks( visited, nstack);</span>
3084     NOT_PRODUCT( if( VerifyLoopOptimizations ) verify(); );



3085   }
3086 
3087   if (!C-&gt;major_progress() &amp;&amp; do_expensive_nodes &amp;&amp; process_expensive_nodes()) {
3088     C-&gt;set_major_progress();
3089   }
3090 
3091   // Perform loop predication before iteration splitting
3092   if (C-&gt;has_loops() &amp;&amp; !C-&gt;major_progress() &amp;&amp; (C-&gt;predicate_count() &gt; 0)) {
3093     _ltree_root-&gt;_child-&gt;loop_predication(this);
3094   }
3095 
3096   if (OptimizeFill &amp;&amp; UseLoopPredicate &amp;&amp; C-&gt;has_loops() &amp;&amp; !C-&gt;major_progress()) {
3097     if (do_intrinsify_fill()) {
3098       C-&gt;set_major_progress();
3099     }
3100   }
3101 
3102   // Perform iteration-splitting on inner loops.  Split iterations to avoid
3103   // range checks or one-shot null checks.
3104 
</pre>
<hr />
<pre>
3199 void PhaseIdealLoop::print_statistics() {
3200   tty-&gt;print_cr(&quot;PhaseIdealLoop=%d, sum _unique=%d&quot;, _loop_invokes, _loop_work);
3201 }
3202 
3203 //------------------------------verify-----------------------------------------
3204 // Build a verify-only PhaseIdealLoop, and see that it agrees with me.
3205 static int fail;                // debug only, so its multi-thread dont care
3206 void PhaseIdealLoop::verify() const {
3207   int old_progress = C-&gt;major_progress();
3208   ResourceMark rm;
3209   PhaseIdealLoop loop_verify( _igvn, this );
3210   VectorSet visited(Thread::current()-&gt;resource_area());
3211 
3212   fail = 0;
3213   verify_compare( C-&gt;root(), &amp;loop_verify, visited );
3214   assert( fail == 0, &quot;verify loops failed&quot; );
3215   // Verify loop structure is the same
3216   _ltree_root-&gt;verify_tree(loop_verify._ltree_root, NULL);
3217   // Reset major-progress.  It was cleared by creating a verify version of
3218   // PhaseIdealLoop.
<span class="line-modified">3219   C-&gt;restore_major_progress(old_progress);</span>

3220 }
3221 
3222 //------------------------------verify_compare---------------------------------
3223 // Make sure me and the given PhaseIdealLoop agree on key data structures
3224 void PhaseIdealLoop::verify_compare( Node *n, const PhaseIdealLoop *loop_verify, VectorSet &amp;visited ) const {
3225   if( !n ) return;
3226   if( visited.test_set( n-&gt;_idx ) ) return;
3227   if( !_nodes[n-&gt;_idx] ) {      // Unreachable
3228     assert( !loop_verify-&gt;_nodes[n-&gt;_idx], &quot;both should be unreachable&quot; );
3229     return;
3230   }
3231 
3232   uint i;
3233   for( i = 0; i &lt; n-&gt;req(); i++ )
3234     verify_compare( n-&gt;in(i), loop_verify, visited );
3235 
3236   // Check the &#39;_nodes&#39; block/loop structure
3237   i = n-&gt;_idx;
3238   if( has_ctrl(n) ) {           // We have control; verify has loop or ctrl
3239     if( _nodes[i] != loop_verify-&gt;_nodes[i] &amp;&amp;
</pre>
<hr />
<pre>
3407         // Last ditch effort to avoid assertion: Its possible that we
3408         // have some users (so outcnt not zero) but are still dead.
3409         // Try to find from root.
3410         if (Compile::current()-&gt;root()-&gt;find(n-&gt;_idx)) {
3411           fail++;
3412           tty-&gt;print(&quot;Verify has that we do not: &quot;);
3413           n-&gt;dump();
3414         }
3415       }
3416     }
3417     assert( !fail, &quot;loop body mismatch&quot; );
3418   }
3419 }
3420 
3421 #endif
3422 
3423 //------------------------------set_idom---------------------------------------
3424 void PhaseIdealLoop::set_idom(Node* d, Node* n, uint dom_depth) {
3425   uint idx = d-&gt;_idx;
3426   if (idx &gt;= _idom_size) {
<span class="line-modified">3427     uint newsize = next_power_of_2(idx);</span>



3428     _idom      = REALLOC_RESOURCE_ARRAY( Node*,     _idom,_idom_size,newsize);
3429     _dom_depth = REALLOC_RESOURCE_ARRAY( uint, _dom_depth,_idom_size,newsize);
3430     memset( _dom_depth + _idom_size, 0, (newsize - _idom_size) * sizeof(uint) );
3431     _idom_size = newsize;
3432   }
3433   _idom[idx] = n;
3434   _dom_depth[idx] = dom_depth;
3435 }
3436 
3437 //------------------------------recompute_dom_depth---------------------------------------
3438 // The dominator tree is constructed with only parent pointers.
3439 // This recomputes the depth in the tree by first tagging all
3440 // nodes as &quot;no depth yet&quot; marker.  The next pass then runs up
3441 // the dom tree from each node marked &quot;no depth yet&quot;, and computes
3442 // the depth on the way back down.
3443 void PhaseIdealLoop::recompute_dom_depth() {
3444   uint no_depth_marker = C-&gt;unique();
3445   uint i;
3446   // Initialize depth to &quot;no depth yet&quot; and realize all lazy updates
3447   for (i = 0; i &lt; _idom_size; i++) {
</pre>
<hr />
<pre>
3682             Node* x = m-&gt;fast_out(j);
3683             if (x-&gt;is_CFG() &amp;&amp; x != m &amp;&amp; x != iff)
3684               { cfg = x; break; }
3685           }
3686           assert(cfg != NULL, &quot;must find the control user of m&quot;);
3687           uint k = 0;             // Probably cfg-&gt;in(0)
3688           while( cfg-&gt;in(k) != m ) k++; // But check incase cfg is a Region
3689           cfg-&gt;set_req( k, if_t ); // Now point to NeverBranch
3690           _igvn._worklist.push(cfg);
3691 
3692           // Now create the never-taken loop exit
3693           Node *if_f = new CProjNode( iff, 1 );
3694           _igvn.register_new_node_with_optimizer(if_f);
3695           set_loop(if_f, l);
3696           // Find frame ptr for Halt.  Relies on the optimizer
3697           // V-N&#39;ing.  Easier and quicker than searching through
3698           // the program structure.
3699           Node *frame = new ParmNode( C-&gt;start(), TypeFunc::FramePtr );
3700           _igvn.register_new_node_with_optimizer(frame);
3701           // Halt &amp; Catch Fire
<span class="line-modified">3702           Node* halt = new HaltNode(if_f, frame, &quot;never-taken loop exit reached&quot;);</span>
3703           _igvn.register_new_node_with_optimizer(halt);
3704           set_loop(halt, l);
3705           C-&gt;root()-&gt;add_req(halt);
3706         }
3707         set_loop(C-&gt;root(), _ltree_root);
3708       }
3709     }
3710     // Weeny check for irreducible.  This child was already visited (this
3711     // IS the post-work phase).  Is this child&#39;s loop header post-visited
3712     // as well?  If so, then I found another entry into the loop.
3713     if (!_verify_only) {
3714       while( is_postvisited(l-&gt;_head) ) {
3715         // found irreducible
3716         l-&gt;_irreducible = 1; // = true
3717         l = l-&gt;_parent;
3718         _has_irreducible_loops = true;
3719         // Check for bad CFG here to prevent crash, and bailout of compile
3720         if (l == NULL) {
3721           C-&gt;record_method_not_compilable(&quot;unhandled CFG detected during loop optimization&quot;);
3722           return pre_order;
</pre>
<hr />
<pre>
4050 //------------------------------get_late_ctrl----------------------------------
4051 // Compute latest legal control.
4052 Node *PhaseIdealLoop::get_late_ctrl( Node *n, Node *early ) {
4053   assert(early != NULL, &quot;early control should not be NULL&quot;);
4054 
4055   Node* LCA = compute_lca_of_uses(n, early);
4056 #ifdef ASSERT
4057   if (LCA == C-&gt;root() &amp;&amp; LCA != early) {
4058     // def doesn&#39;t dominate uses so print some useful debugging output
4059     compute_lca_of_uses(n, early, true);
4060   }
4061 #endif
4062 
4063   // if this is a load, check for anti-dependent stores
4064   // We use a conservative algorithm to identify potential interfering
4065   // instructions and for rescheduling the load.  The users of the memory
4066   // input of this load are examined.  Any use which is not a load and is
4067   // dominated by early is considered a potentially interfering store.
4068   // This can produce false positives.
4069   if (n-&gt;is_Load() &amp;&amp; LCA != early) {
<span class="line-modified">4070     int load_alias_idx = C-&gt;get_alias_index(n-&gt;adr_type());</span>
<span class="line-added">4071     if (C-&gt;alias_type(load_alias_idx)-&gt;is_rewritable()) {</span>
4072 
<span class="line-modified">4073       Node_List worklist;</span>
<span class="line-modified">4074 </span>
<span class="line-modified">4075       Node *mem = n-&gt;in(MemNode::Memory);</span>
<span class="line-modified">4076       for (DUIterator_Fast imax, i = mem-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-modified">4077         Node* s = mem-&gt;fast_out(i);</span>
<span class="line-modified">4078         worklist.push(s);</span>
<span class="line-modified">4079       }</span>
<span class="line-modified">4080       while(worklist.size() != 0 &amp;&amp; LCA != early) {</span>
<span class="line-modified">4081         Node* s = worklist.pop();</span>
<span class="line-modified">4082         if (s-&gt;is_Load() || s-&gt;Opcode() == Op_SafePoint ||</span>
<span class="line-modified">4083             (s-&gt;is_CallStaticJava() &amp;&amp; s-&gt;as_CallStaticJava()-&gt;uncommon_trap_request() != 0)) {</span>
<span class="line-modified">4084           continue;</span>
<span class="line-modified">4085         } else if (s-&gt;is_MergeMem()) {</span>
<span class="line-modified">4086           for (DUIterator_Fast imax, i = s-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-modified">4087             Node* s1 = s-&gt;fast_out(i);</span>
<span class="line-modified">4088             worklist.push(s1);</span>
<span class="line-modified">4089           }</span>
<span class="line-modified">4090         } else {</span>
<span class="line-modified">4091           Node *sctrl = has_ctrl(s) ? get_ctrl(s) : s-&gt;in(0);</span>
<span class="line-modified">4092           assert(sctrl != NULL || !s-&gt;is_reachable_from_root(), &quot;must have control&quot;);</span>
<span class="line-added">4093           if (sctrl != NULL &amp;&amp; !sctrl-&gt;is_top() &amp;&amp; C-&gt;can_alias(s-&gt;adr_type(), load_alias_idx) &amp;&amp; is_dominator(early, sctrl)) {</span>
<span class="line-added">4094             LCA = dom_lca_for_get_late_ctrl(LCA, sctrl, n);</span>
<span class="line-added">4095           }</span>
4096         }
4097       }
4098     }
4099   }
4100 
4101   assert(LCA == find_non_split_ctrl(LCA), &quot;unexpected late control&quot;);
4102   return LCA;
4103 }
4104 
4105 // true if CFG node d dominates CFG node n
4106 bool PhaseIdealLoop::is_dominator(Node *d, Node *n) {
4107   if (d == n)
4108     return true;
4109   assert(d-&gt;is_CFG() &amp;&amp; n-&gt;is_CFG(), &quot;must have CFG nodes&quot;);
4110   uint dd = dom_depth(d);
4111   while (dom_depth(n) &gt;= dd) {
4112     if (n == d)
4113       return true;
4114     n = idom(n);
4115   }
</pre>
<hr />
<pre>
4281       for (uint i = 1; i &lt; m-&gt;req(); i++) {
4282         Node* nn = m-&gt;in(i);
4283         if (nn == n) {
4284           return;
4285         }
4286         if (nn != NULL &amp;&amp; has_ctrl(nn) &amp;&amp; get_loop(get_ctrl(nn)) == loop) {
4287           wq.push(nn);
4288         }
4289       }
4290     }
4291     ShouldNotReachHere();
4292   }
4293 #endif
4294 }
4295 
4296 
4297 //------------------------------build_loop_late_post---------------------------
4298 // Put Data nodes into some loop nest, by setting the _nodes[]-&gt;loop mapping.
4299 // Second pass finds latest legal placement, and ideal loop placement.
4300 void PhaseIdealLoop::build_loop_late_post(Node *n) {






4301   build_loop_late_post_work(n, true);
4302 }
4303 
4304 void PhaseIdealLoop::build_loop_late_post_work(Node *n, bool pinned) {
4305 
4306   if (n-&gt;req() == 2 &amp;&amp; (n-&gt;Opcode() == Op_ConvI2L || n-&gt;Opcode() == Op_CastII) &amp;&amp; !C-&gt;major_progress() &amp;&amp; !_verify_only) {
4307     _igvn._worklist.push(n);  // Maybe we&#39;ll normalize it, if no more loops.
4308   }
4309 
4310 #ifdef ASSERT
4311   if (_verify_only &amp;&amp; !n-&gt;is_CFG()) {
4312     // Check def-use domination.
4313     compute_lca_of_uses(n, get_ctrl(n), true /* verify */);
4314   }
4315 #endif
4316 
4317   // CFG and pinned nodes already handled
4318   if( n-&gt;in(0) ) {
4319     if( n-&gt;in(0)-&gt;is_top() ) return; // Dead?
4320 
</pre>
<hr />
<pre>
4323     // Unlike Stores (which modify an unallocable resource, the memory
4324     // state), Mods/Loads can float around.  So free them up.
4325     switch( n-&gt;Opcode() ) {
4326     case Op_DivI:
4327     case Op_DivF:
4328     case Op_DivD:
4329     case Op_ModI:
4330     case Op_ModF:
4331     case Op_ModD:
4332     case Op_LoadB:              // Same with Loads; they can sink
4333     case Op_LoadUB:             // during loop optimizations.
4334     case Op_LoadUS:
4335     case Op_LoadD:
4336     case Op_LoadF:
4337     case Op_LoadI:
4338     case Op_LoadKlass:
4339     case Op_LoadNKlass:
4340     case Op_LoadL:
4341     case Op_LoadS:
4342     case Op_LoadP:


4343     case Op_LoadN:
4344     case Op_LoadRange:
4345     case Op_LoadD_unaligned:
4346     case Op_LoadL_unaligned:
4347     case Op_StrComp:            // Does a bunch of load-like effects
4348     case Op_StrEquals:
4349     case Op_StrIndexOf:
4350     case Op_StrIndexOfChar:
4351     case Op_AryEq:
4352     case Op_HasNegatives:
4353       pinned = false;
4354     }
<span class="line-added">4355     if (n-&gt;is_CMove()) {</span>
<span class="line-added">4356       pinned = false;</span>
<span class="line-added">4357     }</span>
4358     if( pinned ) {
4359       IdealLoopTree *chosen_loop = get_loop(n-&gt;is_CFG() ? n : get_ctrl(n));
4360       if( !chosen_loop-&gt;_child )       // Inner loop?
4361         chosen_loop-&gt;_body.push(n); // Collect inner loops
4362       return;
4363     }
4364   } else {                      // No slot zero
4365     if( n-&gt;is_CFG() ) {         // CFG with no slot 0 is dead
4366       _nodes.map(n-&gt;_idx,0);    // No block setting, it&#39;s globally dead
4367       return;
4368     }
4369     assert(!n-&gt;is_CFG() || n-&gt;outcnt() == 0, &quot;&quot;);
4370   }
4371 
4372   // Do I have a &quot;safe range&quot; I can select over?
4373   Node *early = get_ctrl(n);// Early location already computed
4374 
4375   // Compute latest point this Node can go
4376   Node *LCA = get_late_ctrl( n, early );
4377   // LCA is NULL due to uses being dead
</pre>
<hr />
<pre>
4533             tty-&gt;print(&quot;n-&gt;out(%d)-&gt;in(0): &quot;, i); u2-&gt;in(0)-&gt;dump();
4534           }
4535         }
4536       }
4537     }
4538   }
4539   tty-&gt;cr();
4540   int ct = 0;
4541   Node *dbg_legal = LCA;
4542   while(!dbg_legal-&gt;is_Start() &amp;&amp; ct &lt; 100) {
4543     tty-&gt;print(&quot;idom[%d] &quot;,ct); dbg_legal-&gt;dump();
4544     ct++;
4545     dbg_legal = idom(dbg_legal);
4546   }
4547   tty-&gt;cr();
4548 }
4549 #endif
4550 
4551 #ifndef PRODUCT
4552 //------------------------------dump-------------------------------------------
<span class="line-modified">4553 void PhaseIdealLoop::dump() const {</span>
4554   ResourceMark rm;
4555   Arena* arena = Thread::current()-&gt;resource_area();
4556   Node_Stack stack(arena, C-&gt;live_nodes() &gt;&gt; 2);
4557   Node_List rpo_list;
4558   VectorSet visited(arena);
4559   visited.set(C-&gt;top()-&gt;_idx);
<span class="line-modified">4560   rpo(C-&gt;root(), stack, visited, rpo_list);</span>
4561   // Dump root loop indexed by last element in PO order
<span class="line-modified">4562   dump(_ltree_root, rpo_list.size(), rpo_list);</span>
4563 }
4564 
<span class="line-modified">4565 void PhaseIdealLoop::dump(IdealLoopTree* loop, uint idx, Node_List &amp;rpo_list) const {</span>
4566   loop-&gt;dump_head();
4567 
4568   // Now scan for CFG nodes in the same loop
<span class="line-modified">4569   for (uint j = idx; j &gt; 0; j--) {</span>
<span class="line-modified">4570     Node* n = rpo_list[j-1];</span>
<span class="line-modified">4571     if (!_nodes[n-&gt;_idx])      // Skip dead nodes</span>
4572       continue;
<span class="line-modified">4573 </span>
<span class="line-modified">4574     if (get_loop(n) != loop) { // Wrong loop nest</span>
<span class="line-modified">4575       if (get_loop(n)-&gt;_head == n &amp;&amp;    // Found nested loop?</span>
<span class="line-modified">4576           get_loop(n)-&gt;_parent == loop)</span>
<span class="line-added">4577         dump(get_loop(n), rpo_list.size(), rpo_list);     // Print it nested-ly</span>
4578       continue;
4579     }
4580 
4581     // Dump controlling node
<span class="line-modified">4582     tty-&gt;sp(2 * loop-&gt;_nest);</span>

4583     tty-&gt;print(&quot;C&quot;);
<span class="line-modified">4584     if (n == C-&gt;root()) {</span>
4585       n-&gt;dump();
4586     } else {
4587       Node* cached_idom   = idom_no_update(n);
<span class="line-modified">4588       Node* computed_idom = n-&gt;in(0);</span>
<span class="line-modified">4589       if (n-&gt;is_Region()) {</span>
4590         computed_idom = compute_idom(n);
4591         // computed_idom() will return n-&gt;in(0) when idom(n) is an IfNode (or
4592         // any MultiBranch ctrl node), so apply a similar transform to
4593         // the cached idom returned from idom_no_update.
4594         cached_idom = find_non_split_ctrl(cached_idom);
4595       }
<span class="line-modified">4596       tty-&gt;print(&quot; ID:%d&quot;, computed_idom-&gt;_idx);</span>
4597       n-&gt;dump();
<span class="line-modified">4598       if (cached_idom != computed_idom) {</span>
4599         tty-&gt;print_cr(&quot;*** BROKEN IDOM!  Computed as: %d, cached as: %d&quot;,
4600                       computed_idom-&gt;_idx, cached_idom-&gt;_idx);
4601       }
4602     }
4603     // Dump nodes it controls
<span class="line-modified">4604     for (uint k = 0; k &lt; _nodes.Size(); k++) {</span>
4605       // (k &lt; C-&gt;unique() &amp;&amp; get_ctrl(find(k)) == n)
4606       if (k &lt; C-&gt;unique() &amp;&amp; _nodes[k] == (Node*)((intptr_t)n + 1)) {
<span class="line-modified">4607         Node* m = C-&gt;root()-&gt;find(k);</span>
<span class="line-modified">4608         if (m &amp;&amp; m-&gt;outcnt() &gt; 0) {</span>
4609           if (!(has_ctrl(m) &amp;&amp; get_ctrl_no_update(m) == n)) {
4610             tty-&gt;print_cr(&quot;*** BROKEN CTRL ACCESSOR!  _nodes[k] is %p, ctrl is %p&quot;,
4611                           _nodes[k], has_ctrl(m) ? get_ctrl_no_update(m) : NULL);
4612           }
<span class="line-modified">4613           tty-&gt;sp(2 * loop-&gt;_nest + 1);</span>


4614           m-&gt;dump();
4615         }
4616       }
4617     }
4618   }
4619 }
4620 #endif
4621 
4622 // Collect a R-P-O for the whole CFG.
4623 // Result list is in post-order (scan backwards for RPO)
<span class="line-modified">4624 void PhaseIdealLoop::rpo(Node* start, Node_Stack &amp;stk, VectorSet &amp;visited, Node_List &amp;rpo_list) const {</span>
4625   stk.push(start, 0);
4626   visited.set(start-&gt;_idx);
4627 
4628   while (stk.is_nonempty()) {
4629     Node* m   = stk.node();
4630     uint  idx = stk.index();
4631     if (idx &lt; m-&gt;outcnt()) {
4632       stk.set_index(idx + 1);
4633       Node* n = m-&gt;raw_out(idx);
4634       if (n-&gt;is_CFG() &amp;&amp; !visited.test_set(n-&gt;_idx)) {
4635         stk.push(n, 0);
4636       }
4637     } else {
4638       rpo_list.push(m);
4639       stk.pop();
4640     }
4641   }
4642 }
4643 
4644 
4645 //=============================================================================
<span class="line-modified">4646 //------------------------------LoopTreeIterator-------------------------------</span>
4647 
4648 // Advance to next loop tree using a preorder, left-to-right traversal.
4649 void LoopTreeIterator::next() {
4650   assert(!done(), &quot;must not be done.&quot;);
4651   if (_curnt-&gt;_child != NULL) {
4652     _curnt = _curnt-&gt;_child;
4653   } else if (_curnt-&gt;_next != NULL) {
4654     _curnt = _curnt-&gt;_next;
4655   } else {
4656     while (_curnt != _root &amp;&amp; _curnt-&gt;_next == NULL) {
4657       _curnt = _curnt-&gt;_parent;
4658     }
4659     if (_curnt == _root) {
4660       _curnt = NULL;
4661       assert(done(), &quot;must be done.&quot;);
4662     } else {
4663       assert(_curnt-&gt;_next != NULL, &quot;must be more to do&quot;);
4664       _curnt = _curnt-&gt;_next;
4665     }
4666   }
</pre>
</td>
</tr>
</table>
<center><a href="loopUnswitch.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopnode.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
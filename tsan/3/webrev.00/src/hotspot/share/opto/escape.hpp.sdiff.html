<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/escape.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="escape.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="gcm.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/escape.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
316   inline PointsToNode* get() const { return ((PointsToNode*)node)-&gt;as_Field()-&gt;base(i); }
317 };
318 
319 
320 class ConnectionGraph: public ResourceObj {
321   friend class PointsToNode;
322 private:
323   GrowableArray&lt;PointsToNode*&gt;  _nodes; // Map from ideal nodes to
324                                         // ConnectionGraph nodes.
325 
326   GrowableArray&lt;PointsToNode*&gt;  _worklist; // Nodes to be processed
327   VectorSet                  _in_worklist;
328   uint                         _next_pidx;
329 
330   bool            _collecting; // Indicates whether escape information
331                                // is still being collected. If false,
332                                // no new nodes will be processed.
333 
334   bool               _verify;  // verify graph
335 
<span class="line-removed">336   JavaObjectNode* phantom_obj; // Unknown object</span>
337   JavaObjectNode*    null_obj;
338   Node*             _pcmp_neq; // ConI(#CC_GT)
339   Node*              _pcmp_eq; // ConI(#CC_EQ)
340 
341   Compile*           _compile; // Compile object for current compilation
342   PhaseIterGVN*         _igvn; // Value numbering
343 
344   Unique_Node_List ideal_nodes; // Used by CG construction and types splitting.
345 




346   // Address of an element in _nodes.  Used when the element is to be modified
347   PointsToNode* ptnode_adr(int idx) const {
348     // There should be no new ideal nodes during ConnectionGraph build,
349     // growableArray::at() will throw assert otherwise.
350     return _nodes.at(idx);
351   }
352   uint nodes_size() const { return _nodes.length(); }
353 
354   uint next_pidx() { return _next_pidx++; }
355 
356   // Add nodes to ConnectionGraph.
357   void add_local_var(Node* n, PointsToNode::EscapeState es);
358   void add_java_object(Node* n, PointsToNode::EscapeState es);
359   void add_field(Node* n, PointsToNode::EscapeState es, int offset);
360   void add_arraycopy(Node* n, PointsToNode::EscapeState es, PointsToNode* src, PointsToNode* dst);
361 
362   // Compute the escape state for arguments to a call.
363   void process_call_arguments(CallNode *call);
364 
365   // Add PointsToNode node corresponding to a call
366   void add_call_node(CallNode* call);
367 
<span class="line-removed">368   // Map ideal node to existing PointsTo node (usually phantom_object).</span>
<span class="line-removed">369   void map_ideal_node(Node *n, PointsToNode* ptn) {</span>
<span class="line-removed">370     assert(ptn != NULL, &quot;only existing PointsTo node&quot;);</span>
<span class="line-removed">371     _nodes.at_put(n-&gt;_idx, ptn);</span>
<span class="line-removed">372   }</span>
<span class="line-removed">373 </span>
374   // Create PointsToNode node and add it to Connection Graph.
375   void add_node_to_connection_graph(Node *n, Unique_Node_List *delayed_worklist);
376 
377   // Add final simple edges to graph.
378   void add_final_edges(Node *n);
379 
380   // Finish Graph construction.
381   bool complete_connection_graph(GrowableArray&lt;PointsToNode*&gt;&amp;   ptnodes_worklist,
382                                  GrowableArray&lt;JavaObjectNode*&gt;&amp; non_escaped_worklist,
383                                  GrowableArray&lt;JavaObjectNode*&gt;&amp; java_objects_worklist,
384                                  GrowableArray&lt;FieldNode*&gt;&amp;      oop_fields_worklist);
385 
386 #ifdef ASSERT
387   void verify_connection_graph(GrowableArray&lt;PointsToNode*&gt;&amp;   ptnodes_worklist,
388                                GrowableArray&lt;JavaObjectNode*&gt;&amp; non_escaped_worklist,
389                                GrowableArray&lt;JavaObjectNode*&gt;&amp; java_objects_worklist,
390                                GrowableArray&lt;Node*&gt;&amp; addp_worklist);
391 #endif
392 
393   // Add all references to this JavaObject node.
</pre>
<hr />
<pre>
577 
578   // Utility function for nodes that load an object
579   void add_objload_to_connection_graph(Node* n, Unique_Node_List* delayed_worklist);
580 
581   // Add LocalVar node and edge if possible
582   void add_local_var_and_edge(Node* n, PointsToNode::EscapeState es, Node* to,
583                               Unique_Node_List *delayed_worklist) {
584     PointsToNode* ptn = ptnode_adr(to-&gt;_idx);
585     if (delayed_worklist != NULL) { // First iteration of CG construction
586       add_local_var(n, es);
587       if (ptn == NULL) {
588         delayed_worklist-&gt;push(n);
589         return; // Process it later.
590       }
591     } else {
592       assert(ptn != NULL, &quot;node should be registered&quot;);
593     }
594     add_edge(ptnode_adr(n-&gt;_idx), ptn);
595   }
596 






597   void add_to_congraph_unsafe_access(Node* n, uint opcode, Unique_Node_List* delayed_worklist);
598   bool add_final_edges_unsafe_access(Node* n, uint opcode);
599 
600 #ifndef PRODUCT
601   void dump(GrowableArray&lt;PointsToNode*&gt;&amp; ptnodes_worklist);
602 #endif
603 };
604 
605 inline PointsToNode::PointsToNode(ConnectionGraph *CG, Node* n, EscapeState es, NodeType type):
606   _edges(CG-&gt;_compile-&gt;comp_arena(), 2, 0, NULL),
607   _uses (CG-&gt;_compile-&gt;comp_arena(), 2, 0, NULL),
608   _type((u1)type),
609   _flags(ScalarReplaceable),
610   _escape((u1)es),
611   _fields_escape((u1)es),
612   _node(n),
613   _idx(n-&gt;_idx),
614   _pidx(CG-&gt;next_pidx()) {
615   assert(n != NULL &amp;&amp; es != UnknownEscape, &quot;sanity&quot;);
616 }
</pre>
</td>
<td>
<hr />
<pre>
316   inline PointsToNode* get() const { return ((PointsToNode*)node)-&gt;as_Field()-&gt;base(i); }
317 };
318 
319 
320 class ConnectionGraph: public ResourceObj {
321   friend class PointsToNode;
322 private:
323   GrowableArray&lt;PointsToNode*&gt;  _nodes; // Map from ideal nodes to
324                                         // ConnectionGraph nodes.
325 
326   GrowableArray&lt;PointsToNode*&gt;  _worklist; // Nodes to be processed
327   VectorSet                  _in_worklist;
328   uint                         _next_pidx;
329 
330   bool            _collecting; // Indicates whether escape information
331                                // is still being collected. If false,
332                                // no new nodes will be processed.
333 
334   bool               _verify;  // verify graph
335 

336   JavaObjectNode*    null_obj;
337   Node*             _pcmp_neq; // ConI(#CC_GT)
338   Node*              _pcmp_eq; // ConI(#CC_EQ)
339 
340   Compile*           _compile; // Compile object for current compilation
341   PhaseIterGVN*         _igvn; // Value numbering
342 
343   Unique_Node_List ideal_nodes; // Used by CG construction and types splitting.
344 
<span class="line-added">345 public:</span>
<span class="line-added">346   JavaObjectNode* phantom_obj; // Unknown object</span>
<span class="line-added">347 </span>
<span class="line-added">348 private:</span>
349   // Address of an element in _nodes.  Used when the element is to be modified
350   PointsToNode* ptnode_adr(int idx) const {
351     // There should be no new ideal nodes during ConnectionGraph build,
352     // growableArray::at() will throw assert otherwise.
353     return _nodes.at(idx);
354   }
355   uint nodes_size() const { return _nodes.length(); }
356 
357   uint next_pidx() { return _next_pidx++; }
358 
359   // Add nodes to ConnectionGraph.
360   void add_local_var(Node* n, PointsToNode::EscapeState es);
361   void add_java_object(Node* n, PointsToNode::EscapeState es);
362   void add_field(Node* n, PointsToNode::EscapeState es, int offset);
363   void add_arraycopy(Node* n, PointsToNode::EscapeState es, PointsToNode* src, PointsToNode* dst);
364 
365   // Compute the escape state for arguments to a call.
366   void process_call_arguments(CallNode *call);
367 
368   // Add PointsToNode node corresponding to a call
369   void add_call_node(CallNode* call);
370 






371   // Create PointsToNode node and add it to Connection Graph.
372   void add_node_to_connection_graph(Node *n, Unique_Node_List *delayed_worklist);
373 
374   // Add final simple edges to graph.
375   void add_final_edges(Node *n);
376 
377   // Finish Graph construction.
378   bool complete_connection_graph(GrowableArray&lt;PointsToNode*&gt;&amp;   ptnodes_worklist,
379                                  GrowableArray&lt;JavaObjectNode*&gt;&amp; non_escaped_worklist,
380                                  GrowableArray&lt;JavaObjectNode*&gt;&amp; java_objects_worklist,
381                                  GrowableArray&lt;FieldNode*&gt;&amp;      oop_fields_worklist);
382 
383 #ifdef ASSERT
384   void verify_connection_graph(GrowableArray&lt;PointsToNode*&gt;&amp;   ptnodes_worklist,
385                                GrowableArray&lt;JavaObjectNode*&gt;&amp; non_escaped_worklist,
386                                GrowableArray&lt;JavaObjectNode*&gt;&amp; java_objects_worklist,
387                                GrowableArray&lt;Node*&gt;&amp; addp_worklist);
388 #endif
389 
390   // Add all references to this JavaObject node.
</pre>
<hr />
<pre>
574 
575   // Utility function for nodes that load an object
576   void add_objload_to_connection_graph(Node* n, Unique_Node_List* delayed_worklist);
577 
578   // Add LocalVar node and edge if possible
579   void add_local_var_and_edge(Node* n, PointsToNode::EscapeState es, Node* to,
580                               Unique_Node_List *delayed_worklist) {
581     PointsToNode* ptn = ptnode_adr(to-&gt;_idx);
582     if (delayed_worklist != NULL) { // First iteration of CG construction
583       add_local_var(n, es);
584       if (ptn == NULL) {
585         delayed_worklist-&gt;push(n);
586         return; // Process it later.
587       }
588     } else {
589       assert(ptn != NULL, &quot;node should be registered&quot;);
590     }
591     add_edge(ptnode_adr(n-&gt;_idx), ptn);
592   }
593 
<span class="line-added">594   // Map ideal node to existing PointsTo node (usually phantom_object).</span>
<span class="line-added">595   void map_ideal_node(Node *n, PointsToNode* ptn) {</span>
<span class="line-added">596     assert(ptn != NULL, &quot;only existing PointsTo node&quot;);</span>
<span class="line-added">597     _nodes.at_put(n-&gt;_idx, ptn);</span>
<span class="line-added">598   }</span>
<span class="line-added">599 </span>
600   void add_to_congraph_unsafe_access(Node* n, uint opcode, Unique_Node_List* delayed_worklist);
601   bool add_final_edges_unsafe_access(Node* n, uint opcode);
602 
603 #ifndef PRODUCT
604   void dump(GrowableArray&lt;PointsToNode*&gt;&amp; ptnodes_worklist);
605 #endif
606 };
607 
608 inline PointsToNode::PointsToNode(ConnectionGraph *CG, Node* n, EscapeState es, NodeType type):
609   _edges(CG-&gt;_compile-&gt;comp_arena(), 2, 0, NULL),
610   _uses (CG-&gt;_compile-&gt;comp_arena(), 2, 0, NULL),
611   _type((u1)type),
612   _flags(ScalarReplaceable),
613   _escape((u1)es),
614   _fields_escape((u1)es),
615   _node(n),
616   _idx(n-&gt;_idx),
617   _pidx(CG-&gt;next_pidx()) {
618   assert(n != NULL &amp;&amp; es != UnknownEscape, &quot;sanity&quot;);
619 }
</pre>
</td>
</tr>
</table>
<center><a href="escape.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="gcm.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
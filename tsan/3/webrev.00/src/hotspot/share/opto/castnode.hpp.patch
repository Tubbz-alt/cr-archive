diff a/src/hotspot/share/opto/castnode.hpp b/src/hotspot/share/opto/castnode.hpp
--- a/src/hotspot/share/opto/castnode.hpp
+++ b/src/hotspot/share/opto/castnode.hpp
@@ -33,11 +33,11 @@
 // cast to a different range
 class ConstraintCastNode: public TypeNode {
   protected:
   // Can this node be removed post CCP or does it carry a required dependency?
   const bool _carry_dependency;
-  virtual uint cmp( const Node &n ) const;
+  virtual bool cmp( const Node &n ) const;
   virtual uint size_of() const;
 
   public:
   ConstraintCastNode(Node *n, const Type *t, bool carry_dependency)
     : TypeNode(t,2), _carry_dependency(carry_dependency) {
@@ -63,11 +63,11 @@
 // cast integer to integer (different range)
 class CastIINode: public ConstraintCastNode {
   protected:
   // Is this node dependent on a range check?
   const bool _range_check_dependency;
-  virtual uint cmp(const Node &n) const;
+  virtual bool cmp(const Node &n) const;
   virtual uint size_of() const;
 
   public:
   CastIINode(Node* n, const Type* t, bool carry_dependency = false, bool range_check_dependency = false)
     : ConstraintCastNode(n, t, carry_dependency), _range_check_dependency(range_check_dependency) {
@@ -89,10 +89,23 @@
 #ifndef PRODUCT
   virtual void dump_spec(outputStream* st) const;
 #endif
 };
 
+//------------------------------CastLLNode-------------------------------------
+// cast long to long (different range)
+class CastLLNode: public ConstraintCastNode {
+  public:
+  CastLLNode(Node* n, const Type* t, bool carry_dependency = false)
+    : ConstraintCastNode(n, t, carry_dependency) {
+    init_class_id(Class_CastLL);
+  }
+  virtual int Opcode() const;
+  virtual uint ideal_reg() const { return Op_RegL; }
+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);
+};
+
 //------------------------------CastPPNode-------------------------------------
 // cast pointer to pointer (different type)
 class CastPPNode: public ConstraintCastNode {
   public:
   CastPPNode (Node *n, const Type *t, bool carry_dependency = false)

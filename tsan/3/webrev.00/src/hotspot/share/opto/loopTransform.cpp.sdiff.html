<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/loopTransform.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="loopPredicate.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopUnswitch.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/loopTransform.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  28 #include &quot;opto/addnode.hpp&quot;
  29 #include &quot;opto/callnode.hpp&quot;
  30 #include &quot;opto/castnode.hpp&quot;
  31 #include &quot;opto/connode.hpp&quot;
  32 #include &quot;opto/convertnode.hpp&quot;
  33 #include &quot;opto/divnode.hpp&quot;
  34 #include &quot;opto/loopnode.hpp&quot;
  35 #include &quot;opto/mulnode.hpp&quot;
  36 #include &quot;opto/movenode.hpp&quot;
  37 #include &quot;opto/opaquenode.hpp&quot;
  38 #include &quot;opto/rootnode.hpp&quot;
  39 #include &quot;opto/runtime.hpp&quot;
  40 #include &quot;opto/subnode.hpp&quot;
  41 #include &quot;opto/superword.hpp&quot;
  42 #include &quot;opto/vectornode.hpp&quot;
  43 
  44 //------------------------------is_loop_exit-----------------------------------
  45 // Given an IfNode, return the loop-exiting projection or NULL if both
  46 // arms remain in the loop.
  47 Node *IdealLoopTree::is_loop_exit(Node *iff) const {
<span class="line-modified">  48   if( iff-&gt;outcnt() != 2 ) return NULL; // Ignore partially dead tests</span>
  49   PhaseIdealLoop *phase = _phase;
  50   // Test is an IfNode, has 2 projections.  If BOTH are in the loop
  51   // we need loop unswitching instead of peeling.
<span class="line-modified">  52   if( !is_member(phase-&gt;get_loop( iff-&gt;raw_out(0) )) )</span>
  53     return iff-&gt;raw_out(0);
<span class="line-modified">  54   if( !is_member(phase-&gt;get_loop( iff-&gt;raw_out(1) )) )</span>
  55     return iff-&gt;raw_out(1);
  56   return NULL;
  57 }
  58 
  59 
  60 //=============================================================================
  61 
  62 
  63 //------------------------------record_for_igvn----------------------------
  64 // Put loop body on igvn work list
  65 void IdealLoopTree::record_for_igvn() {
<span class="line-modified">  66   for( uint i = 0; i &lt; _body.size(); i++ ) {</span>
  67     Node *n = _body.at(i);
  68     _phase-&gt;_igvn._worklist.push(n);
  69   }
  70   // put body of outer strip mined loop on igvn work list as well
  71   if (_head-&gt;is_CountedLoop() &amp;&amp; _head-&gt;as_Loop()-&gt;is_strip_mined()) {
  72     CountedLoopNode* l = _head-&gt;as_CountedLoop();
  73     Node* outer_loop = l-&gt;outer_loop();
  74     assert(outer_loop != NULL, &quot;missing piece of strip mined loop&quot;);
  75     _phase-&gt;_igvn._worklist.push(outer_loop);
  76     Node* outer_loop_tail = l-&gt;outer_loop_tail();
  77     assert(outer_loop_tail != NULL, &quot;missing piece of strip mined loop&quot;);
  78     _phase-&gt;_igvn._worklist.push(outer_loop_tail);
  79     Node* outer_loop_end = l-&gt;outer_loop_end();
  80     assert(outer_loop_end != NULL, &quot;missing piece of strip mined loop&quot;);
  81     _phase-&gt;_igvn._worklist.push(outer_loop_end);
  82     Node* outer_safepoint = l-&gt;outer_safepoint();
  83     assert(outer_safepoint != NULL, &quot;missing piece of strip mined loop&quot;);
  84     _phase-&gt;_igvn._worklist.push(outer_safepoint);
  85     Node* cle_out = _head-&gt;as_CountedLoop()-&gt;loopexit()-&gt;proj_out(false);
  86     assert(cle_out != NULL, &quot;missing piece of strip mined loop&quot;);
</pre>
<hr />
<pre>
 128         cl-&gt;set_exact_trip_count((uint)trip_count);
 129       } else if (cl-&gt;unrolled_count() == 1) {
 130         // Set maximum trip count before unrolling.
 131         cl-&gt;set_trip_count((uint)trip_count);
 132       }
 133     }
 134   }
 135 }
 136 
 137 //------------------------------compute_profile_trip_cnt----------------------------
 138 // Compute loop trip count from profile data as
 139 //    (backedge_count + loop_exit_count) / loop_exit_count
 140 
 141 float IdealLoopTree::compute_profile_trip_cnt_helper(Node* n) {
 142   if (n-&gt;is_If()) {
 143     IfNode *iff = n-&gt;as_If();
 144     if (iff-&gt;_fcnt != COUNT_UNKNOWN &amp;&amp; iff-&gt;_prob != PROB_UNKNOWN) {
 145       Node *exit = is_loop_exit(iff);
 146       if (exit) {
 147         float exit_prob = iff-&gt;_prob;
<span class="line-modified"> 148         if (exit-&gt;Opcode() == Op_IfFalse) exit_prob = 1.0 - exit_prob;</span>


 149         if (exit_prob &gt; PROB_MIN) {
 150           float exit_cnt = iff-&gt;_fcnt * exit_prob;
 151           return exit_cnt;
 152         }
 153       }
 154     }
 155   }
 156   if (n-&gt;is_Jump()) {
 157     JumpNode *jmp = n-&gt;as_Jump();
 158     if (jmp-&gt;_fcnt != COUNT_UNKNOWN) {
 159       float* probs = jmp-&gt;_probs;
 160       float exit_prob = 0;
 161       PhaseIdealLoop *phase = _phase;
 162       for (DUIterator_Fast imax, i = jmp-&gt;fast_outs(imax); i &lt; imax; i++) {
 163         JumpProjNode* u = jmp-&gt;fast_out(i)-&gt;as_JumpProj();
 164         if (!is_member(_phase-&gt;get_loop(u))) {
 165           exit_prob += probs[u-&gt;_con];
 166         }
 167       }
 168       return exit_prob * jmp-&gt;_fcnt;
</pre>
<hr />
<pre>
 185   while (back != head) {
 186     if ((back-&gt;Opcode() == Op_IfTrue || back-&gt;Opcode() == Op_IfFalse) &amp;&amp;
 187         back-&gt;in(0) &amp;&amp;
 188         back-&gt;in(0)-&gt;is_If() &amp;&amp;
 189         back-&gt;in(0)-&gt;as_If()-&gt;_fcnt != COUNT_UNKNOWN &amp;&amp;
 190         back-&gt;in(0)-&gt;as_If()-&gt;_prob != PROB_UNKNOWN &amp;&amp;
 191         (back-&gt;Opcode() == Op_IfTrue ? 1-back-&gt;in(0)-&gt;as_If()-&gt;_prob : back-&gt;in(0)-&gt;as_If()-&gt;_prob) &gt; PROB_MIN) {
 192       break;
 193     }
 194     back = phase-&gt;idom(back);
 195   }
 196   if (back != head) {
 197     assert((back-&gt;Opcode() == Op_IfTrue || back-&gt;Opcode() == Op_IfFalse) &amp;&amp;
 198            back-&gt;in(0), &quot;if-projection exists&quot;);
 199     IfNode* back_if = back-&gt;in(0)-&gt;as_If();
 200     float loop_back_cnt = back_if-&gt;_fcnt * (back-&gt;Opcode() == Op_IfTrue ? back_if-&gt;_prob : (1 - back_if-&gt;_prob));
 201 
 202     // Now compute a loop exit count
 203     float loop_exit_cnt = 0.0f;
 204     if (_child == NULL) {
<span class="line-modified"> 205       for( uint i = 0; i &lt; _body.size(); i++ ) {</span>
 206         Node *n = _body[i];
 207         loop_exit_cnt += compute_profile_trip_cnt_helper(n);
 208       }
 209     } else {
 210       ResourceMark rm;
 211       Unique_Node_List wq;
 212       wq.push(back);
 213       for (uint i = 0; i &lt; wq.size(); i++) {
 214         Node *n = wq.at(i);
 215         assert(n-&gt;is_CFG(), &quot;only control nodes&quot;);
 216         if (n != head) {
 217           if (n-&gt;is_Region()) {
 218             for (uint j = 1; j &lt; n-&gt;req(); j++) {
 219               wq.push(n-&gt;in(j));
 220             }
 221           } else {
 222             loop_exit_cnt += compute_profile_trip_cnt_helper(n);
 223             wq.push(n-&gt;in(0));
 224           }
 225         }
</pre>
<hr />
<pre>
 267 // (x + inv2) - inv1  =&gt;  (-inv1 + inv2) + x
 268 // (x - inv2) + inv1  =&gt;  ( inv1 - inv2) + x
 269 // (x - inv2) - inv1  =&gt;  (-inv1 - inv2) + x
 270 // inv1 + (inv2 - x)  =&gt;  ( inv1 + inv2) - x
 271 // inv1 - (x - inv2)  =&gt;  ( inv1 + inv2) - x
 272 // (inv2 - x) + inv1  =&gt;  ( inv1 + inv2) - x
 273 // (inv2 - x) - inv1  =&gt;  (-inv1 + inv2) - x
 274 // inv1 - (x + inv2)  =&gt;  ( inv1 - inv2) - x
 275 //
 276 Node* IdealLoopTree::reassociate_add_sub(Node* n1, PhaseIdealLoop *phase) {
 277   if ((!n1-&gt;is_Add() &amp;&amp; !n1-&gt;is_Sub()) || n1-&gt;outcnt() == 0) return NULL;
 278   if (is_invariant(n1)) return NULL;
 279   int inv1_idx = is_invariant_addition(n1, phase);
 280   if (!inv1_idx) return NULL;
 281   // Don&#39;t mess with add of constant (igvn moves them to expression tree root.)
 282   if (n1-&gt;is_Add() &amp;&amp; n1-&gt;in(2)-&gt;is_Con()) return NULL;
 283   Node* inv1 = n1-&gt;in(inv1_idx);
 284   Node* n2 = n1-&gt;in(3 - inv1_idx);
 285   int inv2_idx = is_invariant_addition(n2, phase);
 286   if (!inv2_idx) return NULL;



 287   Node* x    = n2-&gt;in(3 - inv2_idx);
 288   Node* inv2 = n2-&gt;in(inv2_idx);
 289 
 290   bool neg_x    = n2-&gt;is_Sub() &amp;&amp; inv2_idx == 1;
 291   bool neg_inv2 = n2-&gt;is_Sub() &amp;&amp; inv2_idx == 2;
 292   bool neg_inv1 = n1-&gt;is_Sub() &amp;&amp; inv1_idx == 2;
 293   if (n1-&gt;is_Sub() &amp;&amp; inv1_idx == 1) {
 294     neg_x    = !neg_x;
 295     neg_inv2 = !neg_inv2;
 296   }
 297   Node* inv1_c = phase-&gt;get_ctrl(inv1);
 298   Node* inv2_c = phase-&gt;get_ctrl(inv2);
 299   Node* n_inv1;
 300   if (neg_inv1) {
 301     Node *zero = phase-&gt;_igvn.intcon(0);
 302     phase-&gt;set_ctrl(zero, phase-&gt;C-&gt;root());
 303     n_inv1 = new SubINode(zero, inv1);
 304     phase-&gt;register_new_node(n_inv1, inv1_c);
 305   } else {
 306     n_inv1 = inv1;
</pre>
<hr />
<pre>
 318     addx = new SubINode(inv, x);
 319   } else {
 320     addx = new AddINode(x, inv);
 321   }
 322   phase-&gt;register_new_node(addx, phase-&gt;get_ctrl(x));
 323   phase-&gt;_igvn.replace_node(n1, addx);
 324   assert(phase-&gt;get_loop(phase-&gt;get_ctrl(n1)) == this, &quot;&quot;);
 325   _body.yank(n1);
 326   return addx;
 327 }
 328 
 329 //---------------------reassociate_invariants-----------------------------
 330 // Reassociate invariant expressions:
 331 void IdealLoopTree::reassociate_invariants(PhaseIdealLoop *phase) {
 332   for (int i = _body.size() - 1; i &gt;= 0; i--) {
 333     Node *n = _body.at(i);
 334     for (int j = 0; j &lt; 5; j++) {
 335       Node* nn = reassociate_add_sub(n, phase);
 336       if (nn == NULL) break;
 337       n = nn; // again
<span class="line-modified"> 338     };</span>
 339   }
 340 }
 341 
 342 //------------------------------policy_peeling---------------------------------
<span class="line-modified"> 343 // Return TRUE or FALSE if the loop should be peeled or not.  Peel if we can</span>
<span class="line-modified"> 344 // make some loop-invariant test (usually a null-check) happen before the loop.</span>
<span class="line-modified"> 345 bool IdealLoopTree::policy_peeling( PhaseIdealLoop *phase ) const {</span>
<span class="line-modified"> 346   Node *test = ((IdealLoopTree*)this)-&gt;tail();</span>
<span class="line-modified"> 347   int  body_size = ((IdealLoopTree*)this)-&gt;_body.size();</span>
<span class="line-modified"> 348   // Peeling does loop cloning which can result in O(N^2) node construction</span>
<span class="line-modified"> 349   if( body_size &gt; 255 /* Prevent overflow for large body_size */</span>
<span class="line-modified"> 350       || (body_size * body_size + phase-&gt;C-&gt;live_nodes()) &gt; phase-&gt;C-&gt;max_node_limit() ) {</span>
<span class="line-modified"> 351     return false;           // too large to safely clone</span>












 352   }



 353 
<span class="line-modified"> 354   // check for vectorized loops, any peeling done was already applied</span>
<span class="line-modified"> 355   if (_head-&gt;is_CountedLoop() &amp;&amp; _head-&gt;as_CountedLoop()-&gt;do_unroll_only()) return false;</span>

 356 
<span class="line-modified"> 357   if (_head-&gt;is_CountedLoop() &amp;&amp; _head-&gt;as_CountedLoop()-&gt;trip_count() == 1) {</span>
<span class="line-modified"> 358     return false;</span>




 359   }
 360 
<span class="line-modified"> 361   while( test != _head ) {      // Scan till run off top of loop</span>
<span class="line-modified"> 362     if( test-&gt;is_If() ) {       // Test?</span>


 363       Node *ctrl = phase-&gt;get_ctrl(test-&gt;in(1));
<span class="line-modified"> 364       if (ctrl-&gt;is_top())</span>
<span class="line-modified"> 365         return false;           // Found dead test on live IF?  No peeling!</span>
<span class="line-modified"> 366       // Standard IF only has one input value to check for loop invariance</span>
<span class="line-modified"> 367       assert(test-&gt;Opcode() == Op_If || test-&gt;Opcode() == Op_CountedLoopEnd || test-&gt;Opcode() == Op_RangeCheck, &quot;Check this code when new subtype is added&quot;);</span>




 368       // Condition is not a member of this loop?
<span class="line-modified"> 369       if( !is_member(phase-&gt;get_loop(ctrl)) &amp;&amp;</span>
<span class="line-modified"> 370           is_loop_exit(test) )</span>
<span class="line-modified"> 371         return true;            // Found reason to peel!</span>
 372     }
<span class="line-modified"> 373     // Walk up dominators to loop _head looking for test which is</span>
<span class="line-modified"> 374     // executed on every path thru loop.</span>
 375     test = phase-&gt;idom(test);
 376   }
<span class="line-modified"> 377   return false;</span>
 378 }
 379 
 380 //------------------------------peeled_dom_test_elim---------------------------
 381 // If we got the effect of peeling, either by actually peeling or by making
 382 // a pre-loop which must execute at least once, we can remove all
 383 // loop-invariant dominated tests in the main body.
<span class="line-modified"> 384 void PhaseIdealLoop::peeled_dom_test_elim( IdealLoopTree *loop, Node_List &amp;old_new ) {</span>
 385   bool progress = true;
<span class="line-modified"> 386   while( progress ) {</span>
 387     progress = false;           // Reset for next iteration
 388     Node *prev = loop-&gt;_head-&gt;in(LoopNode::LoopBackControl);//loop-&gt;tail();
 389     Node *test = prev-&gt;in(0);
<span class="line-modified"> 390     while( test != loop-&gt;_head ) { // Scan till run off top of loop</span>
 391 
 392       int p_op = prev-&gt;Opcode();
<span class="line-modified"> 393       if( (p_op == Op_IfFalse || p_op == Op_IfTrue) &amp;&amp;</span>
 394           test-&gt;is_If() &amp;&amp;      // Test?
 395           !test-&gt;in(1)-&gt;is_Con() &amp;&amp; // And not already obvious?
 396           // Condition is not a member of this loop?
 397           !loop-&gt;is_member(get_loop(get_ctrl(test-&gt;in(1))))){
 398         // Walk loop body looking for instances of this test
<span class="line-modified"> 399         for( uint i = 0; i &lt; loop-&gt;_body.size(); i++ ) {</span>
 400           Node *n = loop-&gt;_body.at(i);
<span class="line-modified"> 401           if( n-&gt;is_If() &amp;&amp; n-&gt;in(1) == test-&gt;in(1) /*&amp;&amp; n != loop-&gt;tail()-&gt;in(0)*/ ) {</span>
 402             // IfNode was dominated by version in peeled loop body
 403             progress = true;
<span class="line-modified"> 404             dominated_by( old_new[prev-&gt;_idx], n );</span>
 405           }
 406         }
 407       }
 408       prev = test;
 409       test = idom(test);
 410     } // End of scan tests in loop
 411 
<span class="line-modified"> 412   } // End of while( progress )</span>
 413 }
 414 
 415 //------------------------------do_peeling-------------------------------------
 416 // Peel the first iteration of the given loop.
 417 // Step 1: Clone the loop body.  The clone becomes the peeled iteration.
 418 //         The pre-loop illegally has 2 control users (old &amp; new loops).
 419 // Step 2: Make the old-loop fall-in edges point to the peeled iteration.
 420 //         Do this by making the old-loop fall-in edges act as if they came
 421 //         around the loopback from the prior iteration (follow the old-loop
 422 //         backedges) and then map to the new peeled iteration.  This leaves
 423 //         the pre-loop with only 1 user (the new peeled iteration), but the
 424 //         peeled-loop backedge has 2 users.
 425 // Step 3: Cut the backedge on the clone (so its not a loop) and remove the
 426 //         extra backedge user.
 427 //
 428 //                   orig
 429 //
 430 //                  stmt1
 431 //                    |
 432 //                    v
</pre>
<hr />
<pre>
 533 //             | loop predicate
 534 //             |      |
 535 //             |      v
 536 //             |     loop&lt;----+
 537 //             |      |       |
 538 //             |    stmt2     |
 539 //             |      |       |
 540 //             |      v       |
 541 //             v      if      ^
 542 //             |     /  \     |
 543 //             |    /    \    |
 544 //             |   v     v    |
 545 //             | false  true  |
 546 //             |  |        \  |
 547 //             v  v         --+
 548 //            region
 549 //              |
 550 //              v
 551 //             exit
 552 //
<span class="line-modified"> 553 void PhaseIdealLoop::do_peeling( IdealLoopTree *loop, Node_List &amp;old_new ) {</span>
 554 
 555   C-&gt;set_major_progress();
 556   // Peeling a &#39;main&#39; loop in a pre/main/post situation obfuscates the
 557   // &#39;pre&#39; loop from the main and the &#39;pre&#39; can no longer have its
 558   // iterations adjusted.  Therefore, we need to declare this loop as
 559   // no longer a &#39;main&#39; loop; it will need new pre and post loops before
 560   // we can do further RCE.
 561 #ifndef PRODUCT
 562   if (TraceLoopOpts) {
 563     tty-&gt;print(&quot;Peel         &quot;);
 564     loop-&gt;dump_head();
 565   }
 566 #endif
 567   LoopNode* head = loop-&gt;_head-&gt;as_Loop();
 568   bool counted_loop = head-&gt;is_CountedLoop();
 569   if (counted_loop) {
 570     CountedLoopNode *cl = head-&gt;as_CountedLoop();
 571     assert(cl-&gt;trip_count() &gt; 0, &quot;peeling a fully unrolled loop&quot;);
 572     cl-&gt;set_trip_count(cl-&gt;trip_count() - 1);
 573     if (cl-&gt;is_main_loop()) {
</pre>
<hr />
<pre>
 582   }
 583   Node* entry = head-&gt;in(LoopNode::EntryControl);
 584 
 585   // Step 1: Clone the loop body.  The clone becomes the peeled iteration.
 586   //         The pre-loop illegally has 2 control users (old &amp; new loops).
 587   clone_loop(loop, old_new, dom_depth(head-&gt;skip_strip_mined()), ControlAroundStripMined);
 588 
 589   // Step 2: Make the old-loop fall-in edges point to the peeled iteration.
 590   //         Do this by making the old-loop fall-in edges act as if they came
 591   //         around the loopback from the prior iteration (follow the old-loop
 592   //         backedges) and then map to the new peeled iteration.  This leaves
 593   //         the pre-loop with only 1 user (the new peeled iteration), but the
 594   //         peeled-loop backedge has 2 users.
 595   Node* new_entry = old_new[head-&gt;in(LoopNode::LoopBackControl)-&gt;_idx];
 596   _igvn.hash_delete(head-&gt;skip_strip_mined());
 597   head-&gt;skip_strip_mined()-&gt;set_req(LoopNode::EntryControl, new_entry);
 598   for (DUIterator_Fast jmax, j = head-&gt;fast_outs(jmax); j &lt; jmax; j++) {
 599     Node* old = head-&gt;fast_out(j);
 600     if (old-&gt;in(0) == loop-&gt;_head &amp;&amp; old-&gt;req() == 3 &amp;&amp; old-&gt;is_Phi()) {
 601       Node* new_exit_value = old_new[old-&gt;in(LoopNode::LoopBackControl)-&gt;_idx];
<span class="line-modified"> 602       if (!new_exit_value )     // Backedge value is ALSO loop invariant?</span>
 603         // Then loop body backedge value remains the same.
 604         new_exit_value = old-&gt;in(LoopNode::LoopBackControl);
 605       _igvn.hash_delete(old);
 606       old-&gt;set_req(LoopNode::EntryControl, new_exit_value);
 607     }
 608   }
 609 
 610 
 611   // Step 3: Cut the backedge on the clone (so its not a loop) and remove the
 612   //         extra backedge user.
 613   Node* new_head = old_new[head-&gt;_idx];
 614   _igvn.hash_delete(new_head);
 615   new_head-&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
 616   for (DUIterator_Fast j2max, j2 = new_head-&gt;fast_outs(j2max); j2 &lt; j2max; j2++) {
 617     Node* use = new_head-&gt;fast_out(j2);
 618     if (use-&gt;in(0) == new_head &amp;&amp; use-&gt;req() == 3 &amp;&amp; use-&gt;is_Phi()) {
 619       _igvn.hash_delete(use);
 620       use-&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
 621     }
 622   }
 623 
<span class="line-removed"> 624 </span>
 625   // Step 4: Correct dom-depth info.  Set to loop-head depth.
<span class="line-modified"> 626   int dd = dom_depth(head);</span>
<span class="line-modified"> 627   set_idom(head, head-&gt;in(1), dd);</span>

 628   for (uint j3 = 0; j3 &lt; loop-&gt;_body.size(); j3++) {
 629     Node *old = loop-&gt;_body.at(j3);
 630     Node *nnn = old_new[old-&gt;_idx];
<span class="line-modified"> 631     if (!has_ctrl(nnn))</span>
 632       set_idom(nnn, idom(nnn), dd-1);

 633   }
 634 
 635   // Now force out all loop-invariant dominating tests.  The optimizer
 636   // finds some, but we _know_ they are all useless.
 637   peeled_dom_test_elim(loop,old_new);
 638 
 639   loop-&gt;record_for_igvn();
 640 }
 641 
<span class="line-removed"> 642 #define EMPTY_LOOP_SIZE 7 // number of nodes in an empty loop</span>
<span class="line-removed"> 643 </span>
 644 //------------------------------policy_maximally_unroll------------------------
<span class="line-modified"> 645 // Calculate exact loop trip count and return true if loop can be maximally</span>
<span class="line-modified"> 646 // unrolled.</span>
<span class="line-modified"> 647 bool IdealLoopTree::policy_maximally_unroll( PhaseIdealLoop *phase ) const {</span>
<span class="line-modified"> 648   CountedLoopNode *cl = _head-&gt;as_CountedLoop();</span>

 649   assert(cl-&gt;is_normal_loop(), &quot;&quot;);
<span class="line-modified"> 650   if (!cl-&gt;is_valid_counted_loop())</span>
<span class="line-modified"> 651     return false; // Malformed counted loop</span>
<span class="line-modified"> 652 </span>
 653   if (!cl-&gt;has_exact_trip_count()) {
<span class="line-modified"> 654     // Trip count is not exact.</span>
<span class="line-removed"> 655     return false;</span>
 656   }
 657 
 658   uint trip_count = cl-&gt;trip_count();
 659   // Note, max_juint is used to indicate unknown trip count.
 660   assert(trip_count &gt; 1, &quot;one iteration loop should be optimized out already&quot;);
<span class="line-modified"> 661   assert(trip_count &lt; max_juint, &quot;exact trip_count should be less than max_uint.&quot;);</span>
 662 
<span class="line-modified"> 663   // Real policy: if we maximally unroll, does it get too big?</span>
<span class="line-modified"> 664   // Allow the unrolled mess to get larger than standard loop</span>
<span class="line-modified"> 665   // size.  After all, it will no longer be a loop.</span>
<span class="line-modified"> 666   uint body_size    = _body.size();</span>
 667   uint unroll_limit = (uint)LoopUnrollLimit * 4;
<span class="line-modified"> 668   assert( (intx)unroll_limit == LoopUnrollLimit * 4, &quot;LoopUnrollLimit must fit in 32bits&quot;);</span>
<span class="line-modified"> 669   if (trip_count &gt; unroll_limit || body_size &gt; unroll_limit) {</span>
 670     return false;
 671   }
 672 
<span class="line-modified"> 673   // Fully unroll a loop with few iterations regardless next</span>
<span class="line-removed"> 674   // conditions since following loop optimizations will split</span>
<span class="line-removed"> 675   // such loop anyway (pre-main-post).</span>
<span class="line-removed"> 676   if (trip_count &lt;= 3)</span>
<span class="line-removed"> 677     return true;</span>
 678 
<span class="line-modified"> 679   // Take into account that after unroll conjoined heads and tails will fold,</span>
<span class="line-removed"> 680   // otherwise policy_unroll() may allow more unrolling than max unrolling.</span>
<span class="line-removed"> 681   uint new_body_size = EMPTY_LOOP_SIZE + (body_size - EMPTY_LOOP_SIZE) * trip_count;</span>
<span class="line-removed"> 682   uint tst_body_size = (new_body_size - EMPTY_LOOP_SIZE) / trip_count + EMPTY_LOOP_SIZE;</span>
<span class="line-removed"> 683   if (body_size != tst_body_size) // Check for int overflow</span>
 684     return false;
<span class="line-modified"> 685   if (new_body_size &gt; unroll_limit ||</span>
<span class="line-modified"> 686       // Unrolling can result in a large amount of node construction</span>
<span class="line-modified"> 687       new_body_size &gt;= phase-&gt;C-&gt;max_node_limit() - phase-&gt;C-&gt;live_nodes()) {</span>








 688     return false;
 689   }
 690 
 691   // Do not unroll a loop with String intrinsics code.
 692   // String intrinsics are large and have loops.
 693   for (uint k = 0; k &lt; _body.size(); k++) {
 694     Node* n = _body.at(k);
 695     switch (n-&gt;Opcode()) {
 696       case Op_StrComp:
 697       case Op_StrEquals:
 698       case Op_StrIndexOf:
 699       case Op_StrIndexOfChar:
 700       case Op_EncodeISOArray:
 701       case Op_AryEq:
 702       case Op_HasNegatives: {
 703         return false;
 704       }
 705 #if INCLUDE_RTM_OPT
 706       case Op_FastLock:
 707       case Op_FastUnlock: {
 708         // Don&#39;t unroll RTM locking code because it is large.
 709         if (UseRTMLocking) {
 710           return false;
 711         }
 712       }
 713 #endif
 714     } // switch
 715   }
 716 
<span class="line-modified"> 717   return true; // Do maximally unroll</span>
 718 }
 719 
 720 
 721 //------------------------------policy_unroll----------------------------------
<span class="line-modified"> 722 // Return TRUE or FALSE if the loop should be unrolled or not.  Unroll if</span>
<span class="line-modified"> 723 // the loop is a CountedLoop and the body is small enough.</span>

 724 bool IdealLoopTree::policy_unroll(PhaseIdealLoop *phase) {
 725 
 726   CountedLoopNode *cl = _head-&gt;as_CountedLoop();
 727   assert(cl-&gt;is_normal_loop() || cl-&gt;is_main_loop(), &quot;&quot;);
 728 
<span class="line-modified"> 729   if (!cl-&gt;is_valid_counted_loop())</span>
 730     return false; // Malformed counted loop




 731 
 732   // Protect against over-unrolling.
 733   // After split at least one iteration will be executed in pre-loop.
<span class="line-modified"> 734   if (cl-&gt;trip_count() &lt;= (uint)(cl-&gt;is_normal_loop() ? 2 : 1)) return false;</span>
<span class="line-modified"> 735 </span>
<span class="line-modified"> 736   _local_loop_unroll_limit = LoopUnrollLimit;</span>

 737   _local_loop_unroll_factor = 4;
<span class="line-modified"> 738   int future_unroll_ct = cl-&gt;unrolled_count() * 2;</span>
 739   if (!cl-&gt;is_vectorized_loop()) {
<span class="line-modified"> 740     if (future_unroll_ct &gt; LoopMaxUnroll) return false;</span>
 741   } else {
 742     // obey user constraints on vector mapped loops with additional unrolling applied
 743     int unroll_constraint = (cl-&gt;slp_max_unroll()) ? cl-&gt;slp_max_unroll() : 1;
<span class="line-modified"> 744     if ((future_unroll_ct / unroll_constraint) &gt; LoopMaxUnroll) return false;</span>
 745   }
 746 
 747   // Check for initial stride being a small enough constant
<span class="line-modified"> 748   if (abs(cl-&gt;stride_con()) &gt; (1&lt;&lt;2)*future_unroll_ct) return false;</span>
 749 
 750   // Don&#39;t unroll if the next round of unrolling would push us
 751   // over the expected trip count of the loop.  One is subtracted
 752   // from the expected trip count because the pre-loop normally
 753   // executes 1 iteration.
 754   if (UnrollLimitForProfileCheck &gt; 0 &amp;&amp;
 755       cl-&gt;profile_trip_cnt() != COUNT_UNKNOWN &amp;&amp;
<span class="line-modified"> 756       future_unroll_ct        &gt; UnrollLimitForProfileCheck &amp;&amp;</span>
<span class="line-modified"> 757       (float)future_unroll_ct &gt; cl-&gt;profile_trip_cnt() - 1.0) {</span>
 758     return false;
 759   }
 760 
 761   // When unroll count is greater than LoopUnrollMin, don&#39;t unroll if:
 762   //   the residual iterations are more than 10% of the trip count
 763   //   and rounds of &quot;unroll,optimize&quot; are not making significant progress
 764   //   Progress defined as current size less than 20% larger than previous size.
 765   if (UseSuperWord &amp;&amp; cl-&gt;node_count_before_unroll() &gt; 0 &amp;&amp;
<span class="line-modified"> 766       future_unroll_ct &gt; LoopUnrollMin &amp;&amp;</span>
<span class="line-modified"> 767       (future_unroll_ct - 1) * (100 / LoopPercentProfileLimit) &gt; cl-&gt;profile_trip_cnt() &amp;&amp;</span>
 768       1.2 * cl-&gt;node_count_before_unroll() &lt; (double)_body.size()) {
 769     return false;
 770   }
 771 
 772   Node *init_n = cl-&gt;init_trip();
 773   Node *limit_n = cl-&gt;limit();
 774   int stride_con = cl-&gt;stride_con();
 775   if (limit_n == NULL) return false; // We will dereference it below.
 776 
 777   // Non-constant bounds.
 778   // Protect against over-unrolling when init or/and limit are not constant
 779   // (so that trip_count&#39;s init value is maxint) but iv range is known.
 780   if (init_n == NULL || !init_n-&gt;is_Con() || !limit_n-&gt;is_Con()) {
 781     Node* phi = cl-&gt;phi();
 782     if (phi != NULL) {
 783       assert(phi-&gt;is_Phi() &amp;&amp; phi-&gt;in(0) == _head, &quot;Counted loop should have iv phi.&quot;);
 784       const TypeInt* iv_type = phase-&gt;_igvn.type(phi)-&gt;is_int();
 785       int next_stride = stride_con * 2; // stride after this unroll
 786       if (next_stride &gt; 0) {
 787         if (iv_type-&gt;_lo + next_stride &lt;= iv_type-&gt;_lo || // overflow
</pre>
<hr />
<pre>
 831       case Op_FastLock:
 832       case Op_FastUnlock: {
 833         // Don&#39;t unroll RTM locking code because it is large.
 834         if (UseRTMLocking) {
 835           return false;
 836         }
 837       }
 838 #endif
 839     } // switch
 840   }
 841 
 842   if (UseSuperWord) {
 843     if (!cl-&gt;is_reduction_loop()) {
 844       phase-&gt;mark_reductions(this);
 845     }
 846 
 847     // Only attempt slp analysis when user controls do not prohibit it
 848     if (LoopMaxUnroll &gt; _local_loop_unroll_factor) {
 849       // Once policy_slp_analysis succeeds, mark the loop with the
 850       // maximal unroll factor so that we minimize analysis passes
<span class="line-modified"> 851       if (future_unroll_ct &gt;= _local_loop_unroll_factor) {</span>
<span class="line-modified"> 852         policy_unroll_slp_analysis(cl, phase, future_unroll_ct);</span>
 853       }
 854     }
 855   }
 856 
 857   int slp_max_unroll_factor = cl-&gt;slp_max_unroll();
 858   if ((LoopMaxUnroll &lt; slp_max_unroll_factor) &amp;&amp; FLAG_IS_DEFAULT(LoopMaxUnroll) &amp;&amp; UseSubwordForMaxVector) {
 859     LoopMaxUnroll = slp_max_unroll_factor;
 860   }



 861   if (cl-&gt;has_passed_slp()) {
<span class="line-modified"> 862     if (slp_max_unroll_factor &gt;= future_unroll_ct) return true;</span>
<span class="line-modified"> 863     // Normal case: loop too big</span>
<span class="line-modified"> 864     return false;</span>

 865   }
 866 
 867   // Check for being too big
 868   if (body_size &gt; (uint)_local_loop_unroll_limit) {
<span class="line-modified"> 869     if ((cl-&gt;is_subword_loop() || xors_in_loop &gt;= 4) &amp;&amp; body_size &lt; (uint)LoopUnrollLimit * 4) {</span>
<span class="line-modified"> 870       return true;</span>
 871     }
<span class="line-modified"> 872     // Normal case: loop too big</span>
<span class="line-removed"> 873     return false;</span>
 874   }
 875 
<span class="line-modified"> 876   if (cl-&gt;do_unroll_only()) {</span>
 877     if (TraceSuperWordLoopUnrollAnalysis) {
<span class="line-modified"> 878       tty-&gt;print_cr(&quot;policy_unroll passed vector loop(vlen=%d,factor = %d)\n&quot;, slp_max_unroll_factor, future_unroll_ct);</span>

 879     }
 880   }
 881 
 882   // Unroll once!  (Each trip will soon do double iterations)
<span class="line-modified"> 883   return true;</span>
 884 }
 885 
<span class="line-modified"> 886 void IdealLoopTree::policy_unroll_slp_analysis(CountedLoopNode *cl, PhaseIdealLoop *phase, int future_unroll_ct) {</span>




 887   // Enable this functionality target by target as needed
 888   if (SuperWordLoopUnrollAnalysis) {
 889     if (!cl-&gt;was_slp_analyzed()) {
 890       SuperWord sw(phase);
 891       sw.transform_loop(this, false);
 892 
 893       // If the loop is slp canonical analyze it
 894       if (sw.early_return() == false) {
 895         sw.unrolling_analysis(_local_loop_unroll_factor);
 896       }
 897     }
 898 
 899     if (cl-&gt;has_passed_slp()) {
 900       int slp_max_unroll_factor = cl-&gt;slp_max_unroll();
<span class="line-modified"> 901       if (slp_max_unroll_factor &gt;= future_unroll_ct) {</span>
 902         int new_limit = cl-&gt;node_count_before_unroll() * slp_max_unroll_factor;
 903         if (new_limit &gt; LoopUnrollLimit) {
 904           if (TraceSuperWordLoopUnrollAnalysis) {
 905             tty-&gt;print_cr(&quot;slp analysis unroll=%d, default limit=%d\n&quot;, new_limit, _local_loop_unroll_limit);
 906           }
 907           _local_loop_unroll_limit = new_limit;
 908         }
 909       }
 910     }
 911   }
 912 }
 913 
 914 //------------------------------policy_align-----------------------------------
 915 // Return TRUE or FALSE if the loop should be cache-line aligned.  Gather the
 916 // expression that does the alignment.  Note that only one array base can be
 917 // aligned in a loop (unless the VM guarantees mutual alignment).  Note that
 918 // if we vectorize short memory ops into longer memory ops, we may want to
 919 // increase alignment.
<span class="line-modified"> 920 bool IdealLoopTree::policy_align( PhaseIdealLoop *phase ) const {</span>
 921   return false;
 922 }
 923 
 924 //------------------------------policy_range_check-----------------------------
<span class="line-modified"> 925 // Return TRUE or FALSE if the loop should be range-check-eliminated.</span>
<span class="line-modified"> 926 // Actually we do iteration-splitting, a more powerful form of RCE.</span>
<span class="line-modified"> 927 bool IdealLoopTree::policy_range_check( PhaseIdealLoop *phase ) const {</span>


 928   if (!RangeCheckElimination) return false;
 929 



 930   CountedLoopNode *cl = _head-&gt;as_CountedLoop();
<span class="line-modified"> 931   // If we unrolled with no intention of doing RCE and we later</span>
<span class="line-modified"> 932   // changed our minds, we got no pre-loop.  Either we need to</span>
<span class="line-modified"> 933   // make a new pre-loop, or we gotta disallow RCE.</span>
 934   if (cl-&gt;is_main_no_pre_loop()) return false; // Disallowed for now.
 935   Node *trip_counter = cl-&gt;phi();
 936 
 937   // check for vectorized loops, some opts are no longer needed
<span class="line-modified"> 938   if (cl-&gt;do_unroll_only()) return false;</span>
 939 
 940   // Check loop body for tests of trip-counter plus loop-invariant vs
 941   // loop-invariant.
 942   for (uint i = 0; i &lt; _body.size(); i++) {
 943     Node *iff = _body[i];
 944     if (iff-&gt;Opcode() == Op_If ||
 945         iff-&gt;Opcode() == Op_RangeCheck) { // Test?
 946 
 947       // Comparing trip+off vs limit
 948       Node *bol = iff-&gt;in(1);
<span class="line-modified"> 949       if (bol-&gt;req() != 2) continue; // dead constant test</span>


 950       if (!bol-&gt;is_Bool()) {
 951         assert(bol-&gt;Opcode() == Op_Conv2B, &quot;predicate check only&quot;);
 952         continue;
 953       }
<span class="line-modified"> 954       if (bol-&gt;as_Bool()-&gt;_test._test == BoolTest::ne)</span>
 955         continue; // not RC
<span class="line-modified"> 956 </span>
 957       Node *cmp = bol-&gt;in(1);
 958       Node *rc_exp = cmp-&gt;in(1);
 959       Node *limit = cmp-&gt;in(2);
 960 
 961       Node *limit_c = phase-&gt;get_ctrl(limit);
<span class="line-modified"> 962       if( limit_c == phase-&gt;C-&gt;top() )</span>
 963         return false;           // Found dead test on live IF?  No RCE!
<span class="line-modified"> 964       if( is_member(phase-&gt;get_loop(limit_c) ) ) {</span>

 965         // Compare might have operands swapped; commute them
 966         rc_exp = cmp-&gt;in(2);
 967         limit  = cmp-&gt;in(1);
 968         limit_c = phase-&gt;get_ctrl(limit);
<span class="line-modified"> 969         if( is_member(phase-&gt;get_loop(limit_c) ) )</span>
 970           continue;             // Both inputs are loop varying; cannot RCE

 971       }
 972 
 973       if (!phase-&gt;is_scaled_iv_plus_offset(rc_exp, trip_counter, NULL, NULL)) {
 974         continue;
 975       }
<span class="line-modified"> 976       // Yeah!  Found a test like &#39;trip+off vs limit&#39;</span>
<span class="line-modified"> 977       // Test is an IfNode, has 2 projections.  If BOTH are in the loop</span>
<span class="line-modified"> 978       // we need loop unswitching instead of iteration splitting.</span>
<span class="line-modified"> 979       if( is_loop_exit(iff) )</span>
<span class="line-modified"> 980         return true;            // Found reason to split iterations</span>



 981     } // End of is IF
 982   }
 983 
 984   return false;
 985 }
 986 
 987 //------------------------------policy_peel_only-------------------------------
 988 // Return TRUE or FALSE if the loop should NEVER be RCE&#39;d or aligned.  Useful
 989 // for unrolling loops with NO array accesses.
<span class="line-modified"> 990 bool IdealLoopTree::policy_peel_only( PhaseIdealLoop *phase ) const {</span>




 991   // check for vectorized loops, any peeling done was already applied
<span class="line-modified"> 992   if (_head-&gt;is_CountedLoop() &amp;&amp; _head-&gt;as_CountedLoop()-&gt;do_unroll_only()) return false;</span>


 993 
<span class="line-modified"> 994   for( uint i = 0; i &lt; _body.size(); i++ )</span>
<span class="line-modified"> 995     if( _body[i]-&gt;is_Mem() )</span>
 996       return false;
<span class="line-modified"> 997 </span>

 998   // No memory accesses at all!
 999   return true;
1000 }
1001 
1002 //------------------------------clone_up_backedge_goo--------------------------
1003 // If Node n lives in the back_ctrl block and cannot float, we clone a private
1004 // version of n in preheader_ctrl block and return that, otherwise return n.
<span class="line-modified">1005 Node *PhaseIdealLoop::clone_up_backedge_goo( Node *back_ctrl, Node *preheader_ctrl, Node *n, VectorSet &amp;visited, Node_Stack &amp;clones ) {</span>
<span class="line-modified">1006   if( get_ctrl(n) != back_ctrl ) return n;</span>
1007 
1008   // Only visit once
1009   if (visited.test_set(n-&gt;_idx)) {
1010     Node *x = clones.find(n-&gt;_idx);
<span class="line-modified">1011     if (x != NULL)</span>
<span class="line-removed">1012       return x;</span>
<span class="line-removed">1013     return n;</span>
1014   }
1015 
1016   Node *x = NULL;               // If required, a clone of &#39;n&#39;
1017   // Check for &#39;n&#39; being pinned in the backedge.
<span class="line-modified">1018   if( n-&gt;in(0) &amp;&amp; n-&gt;in(0) == back_ctrl ) {</span>
1019     assert(clones.find(n-&gt;_idx) == NULL, &quot;dead loop&quot;);
1020     x = n-&gt;clone();             // Clone a copy of &#39;n&#39; to preheader
1021     clones.push(x, n-&gt;_idx);
<span class="line-modified">1022     x-&gt;set_req( 0, preheader_ctrl ); // Fix x&#39;s control input to preheader</span>
1023   }
1024 
1025   // Recursive fixup any other input edges into x.
1026   // If there are no changes we can just return &#39;n&#39;, otherwise
1027   // we need to clone a private copy and change it.
<span class="line-modified">1028   for( uint i = 1; i &lt; n-&gt;req(); i++ ) {</span>
<span class="line-modified">1029     Node *g = clone_up_backedge_goo( back_ctrl, preheader_ctrl, n-&gt;in(i), visited, clones );</span>
<span class="line-modified">1030     if( g != n-&gt;in(i) ) {</span>
<span class="line-modified">1031       if( !x ) {</span>
1032         assert(clones.find(n-&gt;_idx) == NULL, &quot;dead loop&quot;);
1033         x = n-&gt;clone();
1034         clones.push(x, n-&gt;_idx);
1035       }
1036       x-&gt;set_req(i, g);
1037     }
1038   }
<span class="line-modified">1039   if( x ) {                     // x can legally float to pre-header location</span>
<span class="line-modified">1040     register_new_node( x, preheader_ctrl );</span>
1041     return x;
1042   } else {                      // raise n to cover LCA of uses
<span class="line-modified">1043     set_ctrl( n, find_non_split_ctrl(back_ctrl-&gt;in(0)) );</span>
1044   }
1045   return n;
1046 }
1047 
1048 Node* PhaseIdealLoop::cast_incr_before_loop(Node* incr, Node* ctrl, Node* loop) {
1049   Node* castii = new CastIINode(incr, TypeInt::INT, true);
1050   castii-&gt;set_req(0, ctrl);
1051   register_new_node(castii, ctrl);
1052   for (DUIterator_Fast imax, i = incr-&gt;fast_outs(imax); i &lt; imax; i++) {
1053     Node* n = incr-&gt;fast_out(i);
1054     if (n-&gt;is_Phi() &amp;&amp; n-&gt;in(0) == loop) {
1055       int nrep = n-&gt;replace_edge(incr, castii);
1056       return castii;
1057     }
1058   }
1059   return NULL;
1060 }
1061 
1062 // Make a copy of the skeleton range check predicates before the main
1063 // loop and set the initial value of loop as input. After unrolling,
</pre>
<hr />
<pre>
1189         if (next-&gt;_idx &lt; current) {
1190           next = next-&gt;clone();
1191           register_new_node(next, current_proj);
1192           to_clone.set_node(next);
1193         }
1194         next-&gt;set_req(j, cur);
1195       }
1196     }
1197   } while (result == NULL);
1198   assert(result-&gt;_idx &gt;= current, &quot;new node expected&quot;);
1199 
1200   Node* proj = predicate-&gt;clone();
1201   Node* other_proj = uncommon_proj-&gt;clone();
1202   Node* new_iff = iff-&gt;clone();
1203   new_iff-&gt;set_req(1, result);
1204   proj-&gt;set_req(0, new_iff);
1205   other_proj-&gt;set_req(0, new_iff);
1206   Node *frame = new ParmNode(C-&gt;start(), TypeFunc::FramePtr);
1207   register_new_node(frame, C-&gt;start());
1208   // It&#39;s impossible for the predicate to fail at runtime. Use an Halt node.
<span class="line-modified">1209   Node* halt = new HaltNode(other_proj, frame);</span>
1210   C-&gt;root()-&gt;add_req(halt);
1211   new_iff-&gt;set_req(0, prev_proj);
1212 
1213   register_control(new_iff, outer_loop-&gt;_parent, prev_proj);
1214   register_control(proj, outer_loop-&gt;_parent, new_iff);
1215   register_control(other_proj, _ltree_root, new_iff);
1216   register_control(halt, _ltree_root, other_proj);
1217   return proj;
1218 }
1219 
1220 void PhaseIdealLoop::duplicate_predicates(CountedLoopNode* pre_head, Node* start, Node* end,
1221                                           IdealLoopTree* outer_loop, LoopNode* outer_main_head,
1222                                           uint dd_main_head) {
1223   if (UseLoopPredicate) {
1224     Node* entry = pre_head-&gt;in(LoopNode::EntryControl);
1225     Node* predicate = NULL;
1226     predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
1227     if (predicate != NULL) {
1228       entry = skip_loop_predicates(entry);
1229     }
1230     Node* profile_predicate = NULL;
1231     if (UseProfiledLoopPredicate) {
1232       profile_predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);
1233       if (profile_predicate != NULL) {
1234         entry = skip_loop_predicates(entry);
1235       }
1236     }
1237     predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
1238     duplicate_predicates_helper(predicate, start, end, outer_loop, outer_main_head, dd_main_head);
1239     duplicate_predicates_helper(profile_predicate, start, end, outer_loop, outer_main_head, dd_main_head);
1240   }
1241 }
1242 
1243 //------------------------------insert_pre_post_loops--------------------------
1244 // Insert pre and post loops.  If peel_only is set, the pre-loop can not have
1245 // more iterations added.  It acts as a &#39;peel&#39; only, no lower-bound RCE, no
1246 // alignment.  Useful to unroll loops that do no array accesses.
<span class="line-modified">1247 void PhaseIdealLoop::insert_pre_post_loops( IdealLoopTree *loop, Node_List &amp;old_new, bool peel_only ) {</span>
1248 
1249 #ifndef PRODUCT
1250   if (TraceLoopOpts) {
1251     if (peel_only)
1252       tty-&gt;print(&quot;PeelMainPost &quot;);
1253     else
1254       tty-&gt;print(&quot;PreMainPost  &quot;);
1255     loop-&gt;dump_head();
1256   }
1257 #endif
1258   C-&gt;set_major_progress();
1259 
1260   // Find common pieces of the loop being guarded with pre &amp; post loops
1261   CountedLoopNode *main_head = loop-&gt;_head-&gt;as_CountedLoop();
<span class="line-modified">1262   assert( main_head-&gt;is_normal_loop(), &quot;&quot; );</span>
1263   CountedLoopEndNode *main_end = main_head-&gt;loopexit();
<span class="line-modified">1264   assert( main_end-&gt;outcnt() == 2, &quot;1 true, 1 false path only&quot; );</span>
1265 
1266   Node *pre_header= main_head-&gt;in(LoopNode::EntryControl);
1267   Node *init      = main_head-&gt;init_trip();
1268   Node *incr      = main_end -&gt;incr();
1269   Node *limit     = main_end -&gt;limit();
1270   Node *stride    = main_end -&gt;stride();
1271   Node *cmp       = main_end -&gt;cmp_node();
1272   BoolTest::mask b_test = main_end-&gt;test_trip();
1273 
1274   // Need only 1 user of &#39;bol&#39; because I will be hacking the loop bounds.
1275   Node *bol = main_end-&gt;in(CountedLoopEndNode::TestValue);
<span class="line-modified">1276   if( bol-&gt;outcnt() != 1 ) {</span>
1277     bol = bol-&gt;clone();
1278     register_new_node(bol,main_end-&gt;in(CountedLoopEndNode::TestControl));
1279     _igvn.replace_input_of(main_end, CountedLoopEndNode::TestValue, bol);
1280   }
1281   // Need only 1 user of &#39;cmp&#39; because I will be hacking the loop bounds.
<span class="line-modified">1282   if( cmp-&gt;outcnt() != 1 ) {</span>
1283     cmp = cmp-&gt;clone();
1284     register_new_node(cmp,main_end-&gt;in(CountedLoopEndNode::TestControl));
1285     _igvn.replace_input_of(bol, 1, cmp);
1286   }
1287 
1288   // Add the post loop
1289   CountedLoopNode *post_head = NULL;
1290   Node *main_exit = insert_post_loop(loop, old_new, main_head, main_end, incr, limit, post_head);
1291 
1292   //------------------------------
1293   // Step B: Create Pre-Loop.
1294 
1295   // Step B1: Clone the loop body.  The clone becomes the pre-loop.  The main
1296   // loop pre-header illegally has 2 control users (old &amp; new loops).
1297   LoopNode* outer_main_head = main_head;
1298   IdealLoopTree* outer_loop = loop;
1299   if (main_head-&gt;is_strip_mined()) {
1300     main_head-&gt;verify_strip_mined(1);
1301     outer_main_head = main_head-&gt;outer_loop();
1302     outer_loop = loop-&gt;_parent;
1303     assert(outer_loop-&gt;_head == outer_main_head, &quot;broken loop tree&quot;);
1304   }
1305   uint dd_main_head = dom_depth(outer_main_head);
1306   clone_loop(loop, old_new, dd_main_head, ControlAroundStripMined);
1307   CountedLoopNode*    pre_head = old_new[main_head-&gt;_idx]-&gt;as_CountedLoop();
1308   CountedLoopEndNode* pre_end  = old_new[main_end -&gt;_idx]-&gt;as_CountedLoopEnd();
1309   pre_head-&gt;set_pre_loop(main_head);
1310   Node *pre_incr = old_new[incr-&gt;_idx];
1311 
1312   // Reduce the pre-loop trip count.
1313   pre_end-&gt;_prob = PROB_FAIR;
1314 
1315   // Find the pre-loop normal exit.
1316   Node* pre_exit = pre_end-&gt;proj_out(false);
<span class="line-modified">1317   assert( pre_exit-&gt;Opcode() == Op_IfFalse, &quot;&quot; );</span>
1318   IfFalseNode *new_pre_exit = new IfFalseNode(pre_end);
<span class="line-modified">1319   _igvn.register_new_node_with_optimizer( new_pre_exit );</span>
1320   set_idom(new_pre_exit, pre_end, dd_main_head);
1321   set_loop(new_pre_exit, outer_loop-&gt;_parent);
1322 
1323   // Step B2: Build a zero-trip guard for the main-loop.  After leaving the
1324   // pre-loop, the main-loop may not execute at all.  Later in life this
1325   // zero-trip guard will become the minimum-trip guard when we unroll
1326   // the main-loop.
1327   Node *min_opaq = new Opaque1Node(C, limit);
<span class="line-modified">1328   Node *min_cmp  = new CmpINode( pre_incr, min_opaq );</span>
<span class="line-modified">1329   Node *min_bol  = new BoolNode( min_cmp, b_test );</span>
<span class="line-modified">1330   register_new_node( min_opaq, new_pre_exit );</span>
<span class="line-modified">1331   register_new_node( min_cmp , new_pre_exit );</span>
<span class="line-modified">1332   register_new_node( min_bol , new_pre_exit );</span>
1333 
1334   // Build the IfNode (assume the main-loop is executed always).
<span class="line-modified">1335   IfNode *min_iff = new IfNode( new_pre_exit, min_bol, PROB_ALWAYS, COUNT_UNKNOWN );</span>
<span class="line-modified">1336   _igvn.register_new_node_with_optimizer( min_iff );</span>
1337   set_idom(min_iff, new_pre_exit, dd_main_head);
1338   set_loop(min_iff, outer_loop-&gt;_parent);
1339 
1340   // Plug in the false-path, taken if we need to skip main-loop
<span class="line-modified">1341   _igvn.hash_delete( pre_exit );</span>
1342   pre_exit-&gt;set_req(0, min_iff);
1343   set_idom(pre_exit, min_iff, dd_main_head);
1344   set_idom(pre_exit-&gt;unique_ctrl_out(), min_iff, dd_main_head);
1345   // Make the true-path, must enter the main loop
<span class="line-modified">1346   Node *min_taken = new IfTrueNode( min_iff );</span>
<span class="line-modified">1347   _igvn.register_new_node_with_optimizer( min_taken );</span>
1348   set_idom(min_taken, min_iff, dd_main_head);
1349   set_loop(min_taken, outer_loop-&gt;_parent);
1350   // Plug in the true path
1351   _igvn.hash_delete(outer_main_head);
1352   outer_main_head-&gt;set_req(LoopNode::EntryControl, min_taken);
1353   set_idom(outer_main_head, min_taken, dd_main_head);
1354 
1355   Arena *a = Thread::current()-&gt;resource_area();
1356   VectorSet visited(a);
1357   Node_Stack clones(a, main_head-&gt;back_control()-&gt;outcnt());
1358   // Step B3: Make the fall-in values to the main-loop come from the
1359   // fall-out values of the pre-loop.
1360   for (DUIterator_Fast i2max, i2 = main_head-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1361     Node* main_phi = main_head-&gt;fast_out(i2);
<span class="line-modified">1362     if( main_phi-&gt;is_Phi() &amp;&amp; main_phi-&gt;in(0) == main_head &amp;&amp; main_phi-&gt;outcnt() &gt; 0 ) {</span>
1363       Node *pre_phi = old_new[main_phi-&gt;_idx];
1364       Node *fallpre  = clone_up_backedge_goo(pre_head-&gt;back_control(),
1365                                              main_head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl),
1366                                              pre_phi-&gt;in(LoopNode::LoopBackControl),
1367                                              visited, clones);
1368       _igvn.hash_delete(main_phi);
<span class="line-modified">1369       main_phi-&gt;set_req( LoopNode::EntryControl, fallpre );</span>
1370     }
1371   }
1372 
1373   // Nodes inside the loop may be control dependent on a predicate
1374   // that was moved before the preloop. If the back branch of the main
1375   // or post loops becomes dead, those nodes won&#39;t be dependent on the
1376   // test that guards that loop nest anymore which could lead to an
1377   // incorrect array access because it executes independently of the
1378   // test that was guarding the loop nest. We add a special CastII on
1379   // the if branch that enters the loop, between the input induction
1380   // variable value and the induction variable Phi to preserve correct
1381   // dependencies.
1382 
1383   // CastII for the main loop:
<span class="line-modified">1384   Node* castii = cast_incr_before_loop( pre_incr, min_taken, main_head );</span>
1385   assert(castii != NULL, &quot;no castII inserted&quot;);
1386   Node* opaque_castii = new Opaque1Node(C, castii);
1387   register_new_node(opaque_castii, outer_main_head-&gt;in(LoopNode::EntryControl));
1388   duplicate_predicates(pre_head, castii, opaque_castii, outer_loop, outer_main_head, dd_main_head);
1389 
1390   // Step B4: Shorten the pre-loop to run only 1 iteration (for now).
1391   // RCE and alignment may change this later.
1392   Node *cmp_end = pre_end-&gt;cmp_node();
<span class="line-modified">1393   assert( cmp_end-&gt;in(2) == limit, &quot;&quot; );</span>
<span class="line-modified">1394   Node *pre_limit = new AddINode( init, stride );</span>
1395 
1396   // Save the original loop limit in this Opaque1 node for
1397   // use by range check elimination.
1398   Node *pre_opaq  = new Opaque1Node(C, pre_limit, limit);
1399 
<span class="line-modified">1400   register_new_node( pre_limit, pre_head-&gt;in(0) );</span>
<span class="line-modified">1401   register_new_node( pre_opaq , pre_head-&gt;in(0) );</span>
1402 
1403   // Since no other users of pre-loop compare, I can hack limit directly
<span class="line-modified">1404   assert( cmp_end-&gt;outcnt() == 1, &quot;no other users&quot; );</span>
1405   _igvn.hash_delete(cmp_end);
1406   cmp_end-&gt;set_req(2, peel_only ? pre_limit : pre_opaq);
1407 
1408   // Special case for not-equal loop bounds:
1409   // Change pre loop test, main loop test, and the
1410   // main loop guard test to use lt or gt depending on stride
1411   // direction:
1412   // positive stride use &lt;
1413   // negative stride use &gt;
1414   //
1415   // not-equal test is kept for post loop to handle case
1416   // when init &gt; limit when stride &gt; 0 (and reverse).
1417 
1418   if (pre_end-&gt;in(CountedLoopEndNode::TestValue)-&gt;as_Bool()-&gt;_test._test == BoolTest::ne) {
1419 
1420     BoolTest::mask new_test = (main_end-&gt;stride_con() &gt; 0) ? BoolTest::lt : BoolTest::gt;
1421     // Modify pre loop end condition
1422     Node* pre_bol = pre_end-&gt;in(CountedLoopEndNode::TestValue)-&gt;as_Bool();
1423     BoolNode* new_bol0 = new BoolNode(pre_bol-&gt;in(1), new_test);
<span class="line-modified">1424     register_new_node( new_bol0, pre_head-&gt;in(0) );</span>
1425     _igvn.replace_input_of(pre_end, CountedLoopEndNode::TestValue, new_bol0);
1426     // Modify main loop guard condition
1427     assert(min_iff-&gt;in(CountedLoopEndNode::TestValue) == min_bol, &quot;guard okay&quot;);
1428     BoolNode* new_bol1 = new BoolNode(min_bol-&gt;in(1), new_test);
<span class="line-modified">1429     register_new_node( new_bol1, new_pre_exit );</span>
1430     _igvn.hash_delete(min_iff);
1431     min_iff-&gt;set_req(CountedLoopEndNode::TestValue, new_bol1);
1432     // Modify main loop end condition
1433     BoolNode* main_bol = main_end-&gt;in(CountedLoopEndNode::TestValue)-&gt;as_Bool();
1434     BoolNode* new_bol2 = new BoolNode(main_bol-&gt;in(1), new_test);
<span class="line-modified">1435     register_new_node( new_bol2, main_end-&gt;in(CountedLoopEndNode::TestControl) );</span>
1436     _igvn.replace_input_of(main_end, CountedLoopEndNode::TestValue, new_bol2);
1437   }
1438 
1439   // Flag main loop
1440   main_head-&gt;set_main_loop();
<span class="line-modified">1441   if( peel_only ) main_head-&gt;set_main_no_pre_loop();</span>


1442 
1443   // Subtract a trip count for the pre-loop.
1444   main_head-&gt;set_trip_count(main_head-&gt;trip_count() - 1);
1445 
1446   // It&#39;s difficult to be precise about the trip-counts
1447   // for the pre/post loops.  They are usually very short,
1448   // so guess that 4 trips is a reasonable value.
1449   post_head-&gt;set_profile_trip_cnt(4.0);
1450   pre_head-&gt;set_profile_trip_cnt(4.0);
1451 
1452   // Now force out all loop-invariant dominating tests.  The optimizer
1453   // finds some, but we _know_ they are all useless.
1454   peeled_dom_test_elim(loop,old_new);
1455   loop-&gt;record_for_igvn();
1456 }
1457 
1458 //------------------------------insert_vector_post_loop------------------------
1459 // Insert a copy of the atomic unrolled vectorized main loop as a post loop,
<span class="line-modified">1460 // unroll_policy has already informed us that more unrolling is about to happen to</span>
<span class="line-modified">1461 // the main loop.  The resultant post loop will serve as a vectorized drain loop.</span>

1462 void PhaseIdealLoop::insert_vector_post_loop(IdealLoopTree *loop, Node_List &amp;old_new) {
1463   if (!loop-&gt;_head-&gt;is_CountedLoop()) return;
1464 
1465   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
1466 
1467   // only process vectorized main loops
1468   if (!cl-&gt;is_vectorized_loop() || !cl-&gt;is_main_loop()) return;
1469 
1470   int slp_max_unroll_factor = cl-&gt;slp_max_unroll();
1471   int cur_unroll = cl-&gt;unrolled_count();
1472 
1473   if (slp_max_unroll_factor == 0) return;
1474 
1475   // only process atomic unroll vector loops (not super unrolled after vectorization)
1476   if (cur_unroll != slp_max_unroll_factor) return;
1477 
1478   // we only ever process this one time
1479   if (cl-&gt;has_atomic_post_loop()) return;
1480 




1481 #ifndef PRODUCT
1482   if (TraceLoopOpts) {
1483     tty-&gt;print(&quot;PostVector  &quot;);
1484     loop-&gt;dump_head();
1485   }
1486 #endif
1487   C-&gt;set_major_progress();
1488 
1489   // Find common pieces of the loop being guarded with pre &amp; post loops
1490   CountedLoopNode *main_head = loop-&gt;_head-&gt;as_CountedLoop();
1491   CountedLoopEndNode *main_end = main_head-&gt;loopexit();
1492   // diagnostic to show loop end is not properly formed
1493   assert(main_end-&gt;outcnt() == 2, &quot;1 true, 1 false path only&quot;);
1494 
1495   // mark this loop as processed
1496   main_head-&gt;mark_has_atomic_post_loop();
1497 
1498   Node *incr = main_end-&gt;incr();
1499   Node *limit = main_end-&gt;limit();
1500 
</pre>
<hr />
<pre>
1621   _igvn.replace_input_of(main_exit, 0, zer_iff);
1622   set_idom(main_exit, zer_iff, dd_main_exit);
1623   set_idom(main_exit-&gt;unique_out(), zer_iff, dd_main_exit);
1624   // Make the true-path, must enter this post loop
1625   Node *zer_taken = new IfTrueNode(zer_iff);
1626   _igvn.register_new_node_with_optimizer(zer_taken);
1627   set_idom(zer_taken, zer_iff, dd_main_exit);
1628   set_loop(zer_taken, outer_loop-&gt;_parent);
1629   // Plug in the true path
1630   _igvn.hash_delete(post_head);
1631   post_head-&gt;set_req(LoopNode::EntryControl, zer_taken);
1632   set_idom(post_head, zer_taken, dd_main_exit);
1633 
1634   Arena *a = Thread::current()-&gt;resource_area();
1635   VectorSet visited(a);
1636   Node_Stack clones(a, main_head-&gt;back_control()-&gt;outcnt());
1637   // Step A3: Make the fall-in values to the post-loop come from the
1638   // fall-out values of the main-loop.
1639   for (DUIterator_Fast imax, i = main_head-&gt;fast_outs(imax); i &lt; imax; i++) {
1640     Node* main_phi = main_head-&gt;fast_out(i);
<span class="line-modified">1641     if (main_phi-&gt;is_Phi() &amp;&amp; main_phi-&gt;in(0) == main_head &amp;&amp; main_phi-&gt;outcnt() &gt;0) {</span>
1642       Node *cur_phi = old_new[main_phi-&gt;_idx];
1643       Node *fallnew = clone_up_backedge_goo(main_head-&gt;back_control(),
1644                                             post_head-&gt;init_control(),
1645                                             main_phi-&gt;in(LoopNode::LoopBackControl),
1646                                             visited, clones);
1647       _igvn.hash_delete(cur_phi);
1648       cur_phi-&gt;set_req(LoopNode::EntryControl, fallnew);
1649     }
1650   }
1651 
1652   // CastII for the new post loop:
1653   Node* castii = cast_incr_before_loop(zer_opaq-&gt;in(1), zer_taken, post_head);
1654   assert(castii != NULL, &quot;no castII inserted&quot;);
1655 
1656   return new_main_exit;
1657 }
1658 
1659 //------------------------------is_invariant-----------------------------
1660 // Return true if n is invariant
1661 bool IdealLoopTree::is_invariant(Node* n) const {
</pre>
<hr />
<pre>
1693         int init_inc = stride_con/loop_head-&gt;unrolled_count();
1694         assert(init_inc != 0, &quot;invalid loop increment&quot;);
1695         int new_stride_con = stride_con * 2;
1696         Node* max_value = _igvn.intcon(new_stride_con - init_inc);
1697         max_value = new AddINode(init, max_value);
1698         register_new_node(max_value, get_ctrl(iff-&gt;in(1)));
1699         prev_proj = clone_skeleton_predicate(iff, max_value, entry, proj, ctrl, outer_loop, prev_proj);
1700         assert(!skeleton_predicate_has_opaque(prev_proj-&gt;in(0)-&gt;as_If()), &quot;unexpected&quot;);
1701       }
1702     }
1703     entry = entry-&gt;in(0)-&gt;in(0);
1704   }
1705   if (prev_proj != ctrl) {
1706     _igvn.replace_input_of(outer_loop_head, LoopNode::EntryControl, prev_proj);
1707     set_idom(outer_loop_head, prev_proj, dom_depth(outer_loop_head));
1708   }
1709 }
1710 
1711 //------------------------------do_unroll--------------------------------------
1712 // Unroll the loop body one step - make each trip do 2 iterations.
<span class="line-modified">1713 void PhaseIdealLoop::do_unroll( IdealLoopTree *loop, Node_List &amp;old_new, bool adjust_min_trip ) {</span>
1714   assert(LoopUnrollLimit, &quot;&quot;);
1715   CountedLoopNode *loop_head = loop-&gt;_head-&gt;as_CountedLoop();
1716   CountedLoopEndNode *loop_end = loop_head-&gt;loopexit();
1717 #ifndef PRODUCT
1718   if (PrintOpto &amp;&amp; VerifyLoopOptimizations) {
1719     tty-&gt;print(&quot;Unrolling &quot;);
1720     loop-&gt;dump_head();
1721   } else if (TraceLoopOpts) {
1722     if (loop_head-&gt;trip_count() &lt; (uint)LoopUnrollLimit) {
1723       tty-&gt;print(&quot;Unroll %d(%2d) &quot;, loop_head-&gt;unrolled_count()*2, loop_head-&gt;trip_count());
1724     } else {
1725       tty-&gt;print(&quot;Unroll %d     &quot;, loop_head-&gt;unrolled_count()*2);
1726     }
1727     loop-&gt;dump_head();
1728   }
1729 
1730   if (C-&gt;do_vector_loop() &amp;&amp; (PrintOpto &amp;&amp; (VerifyLoopOptimizations || TraceLoopOpts))) {
1731     Arena* arena = Thread::current()-&gt;resource_area();
1732     Node_Stack stack(arena, C-&gt;live_nodes() &gt;&gt; 2);
1733     Node_List rpo_list;
1734     VectorSet visited(arena);
1735     visited.set(loop_head-&gt;_idx);
<span class="line-modified">1736     rpo( loop_head, stack, visited, rpo_list );</span>
<span class="line-modified">1737     dump(loop, rpo_list.size(), rpo_list );</span>
1738   }
1739 #endif
1740 
1741   // Remember loop node count before unrolling to detect
1742   // if rounds of unroll,optimize are making progress
1743   loop_head-&gt;set_node_count_before_unroll(loop-&gt;_body.size());
1744 
1745   Node *ctrl  = loop_head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
1746   Node *limit = loop_head-&gt;limit();
1747   Node *init  = loop_head-&gt;init_trip();
1748   Node *stride = loop_head-&gt;stride();
1749 
1750   Node *opaq = NULL;
1751   if (adjust_min_trip) {       // If not maximally unrolling, need adjustment
1752     // Search for zero-trip guard.
1753 
1754     // Check the shape of the graph at the loop entry. If an inappropriate
1755     // graph shape is encountered, the compiler bails out loop unrolling;
1756     // compilation of the method will still succeed.
1757     if (!is_canonical_loop_entry(loop_head)) {
</pre>
<hr />
<pre>
1794     int new_stride_con = stride_con * 2;
1795     int stride_m    = new_stride_con - (stride_con &gt; 0 ? 1 : -1);
1796     jlong trip_count = (limit_con - init_con + stride_m)/new_stride_con;
1797     // New trip count should satisfy next conditions.
1798     assert(trip_count &gt; 0 &amp;&amp; (julong)trip_count &lt; (julong)max_juint/2, &quot;sanity&quot;);
1799     uint new_trip_count = (uint)trip_count;
1800     adjust_min_trip = (old_trip_count != new_trip_count*2);
1801   }
1802 
1803   if (adjust_min_trip) {
1804     // Step 2: Adjust the trip limit if it is called for.
1805     // The adjustment amount is -stride. Need to make sure if the
1806     // adjustment underflows or overflows, then the main loop is skipped.
1807     Node* cmp = loop_end-&gt;cmp_node();
1808     assert(cmp-&gt;in(2) == limit, &quot;sanity&quot;);
1809     assert(opaq != NULL &amp;&amp; opaq-&gt;in(1) == limit, &quot;sanity&quot;);
1810 
1811     // Verify that policy_unroll result is still valid.
1812     const TypeInt* limit_type = _igvn.type(limit)-&gt;is_int();
1813     assert(stride_con &gt; 0 &amp;&amp; ((limit_type-&gt;_hi - stride_con) &lt; limit_type-&gt;_hi) ||
<span class="line-modified">1814         stride_con &lt; 0 &amp;&amp; ((limit_type-&gt;_lo - stride_con) &gt; limit_type-&gt;_lo), &quot;sanity&quot;);</span>

1815 
1816     if (limit-&gt;is_Con()) {
1817       // The check in policy_unroll and the assert above guarantee
1818       // no underflow if limit is constant.
1819       new_limit = _igvn.intcon(limit-&gt;get_int() - stride_con);
1820       set_ctrl(new_limit, C-&gt;root());
1821     } else {
1822       // Limit is not constant.
1823       if (loop_head-&gt;unrolled_count() == 1) { // only for first unroll
1824         // Separate limit by Opaque node in case it is an incremented
1825         // variable from previous loop to avoid using pre-incremented
1826         // value which could increase register pressure.
1827         // Otherwise reorg_offsets() optimization will create a separate
1828         // Opaque node for each use of trip-counter and as result
1829         // zero trip guard limit will be different from loop limit.
1830         assert(has_ctrl(opaq), &quot;should have it&quot;);
1831         Node* opaq_ctrl = get_ctrl(opaq);
<span class="line-modified">1832         limit = new Opaque2Node( C, limit );</span>
<span class="line-modified">1833         register_new_node( limit, opaq_ctrl );</span>
1834       }
1835       if ((stride_con &gt; 0 &amp;&amp; (java_subtract(limit_type-&gt;_lo, stride_con) &lt; limit_type-&gt;_lo)) ||
1836           (stride_con &lt; 0 &amp;&amp; (java_subtract(limit_type-&gt;_hi, stride_con) &gt; limit_type-&gt;_hi))) {
1837         // No underflow.
1838         new_limit = new SubINode(limit, stride);
1839       } else {
1840         // (limit - stride) may underflow.
1841         // Clamp the adjustment value with MININT or MAXINT:
1842         //
1843         //   new_limit = limit-stride
1844         //   if (stride &gt; 0)
1845         //     new_limit = (limit &lt; new_limit) ? MININT : new_limit;
1846         //   else
1847         //     new_limit = (limit &gt; new_limit) ? MAXINT : new_limit;
1848         //
1849         BoolTest::mask bt = loop_end-&gt;test_trip();
1850         assert(bt == BoolTest::lt || bt == BoolTest::gt, &quot;canonical test is expected&quot;);
1851         Node* adj_max = _igvn.intcon((stride_con &gt; 0) ? min_jint : max_jint);
1852         set_ctrl(adj_max, C-&gt;root());
1853         Node* old_limit = NULL;
1854         Node* adj_limit = NULL;
1855         Node* bol = limit-&gt;is_CMove() ? limit-&gt;in(CMoveNode::Condition) : NULL;
1856         if (loop_head-&gt;unrolled_count() &gt; 1 &amp;&amp;
1857             limit-&gt;is_CMove() &amp;&amp; limit-&gt;Opcode() == Op_CMoveI &amp;&amp;
1858             limit-&gt;in(CMoveNode::IfTrue) == adj_max &amp;&amp;
1859             bol-&gt;as_Bool()-&gt;_test._test == bt &amp;&amp;
1860             bol-&gt;in(1)-&gt;Opcode() == Op_CmpI &amp;&amp;
1861             bol-&gt;in(1)-&gt;in(2) == limit-&gt;in(CMoveNode::IfFalse)) {
1862           // Loop was unrolled before.
1863           // Optimize the limit to avoid nested CMove:
1864           // use original limit as old limit.
1865           old_limit = bol-&gt;in(1)-&gt;in(1);
1866           // Adjust previous adjusted limit.
1867           adj_limit = limit-&gt;in(CMoveNode::IfFalse);
1868           adj_limit = new SubINode(adj_limit, stride);
1869         } else {
1870           old_limit = limit;
1871           adj_limit = new SubINode(limit, stride);
1872         }
1873         assert(old_limit != NULL &amp;&amp; adj_limit != NULL, &quot;&quot;);
<span class="line-modified">1874         register_new_node( adj_limit, ctrl ); // adjust amount</span>
1875         Node* adj_cmp = new CmpINode(old_limit, adj_limit);
<span class="line-modified">1876         register_new_node( adj_cmp, ctrl );</span>
1877         Node* adj_bool = new BoolNode(adj_cmp, bt);
<span class="line-modified">1878         register_new_node( adj_bool, ctrl );</span>
1879         new_limit = new CMoveINode(adj_bool, adj_limit, adj_max, TypeInt::INT);
1880       }
1881       register_new_node(new_limit, ctrl);
1882     }

1883     assert(new_limit != NULL, &quot;&quot;);
1884     // Replace in loop test.
1885     assert(loop_end-&gt;in(1)-&gt;in(1) == cmp, &quot;sanity&quot;);
1886     if (cmp-&gt;outcnt() == 1 &amp;&amp; loop_end-&gt;in(1)-&gt;outcnt() == 1) {
1887       // Don&#39;t need to create new test since only one user.
1888       _igvn.hash_delete(cmp);
1889       cmp-&gt;set_req(2, new_limit);
1890     } else {
1891       // Create new test since it is shared.
1892       Node* ctrl2 = loop_end-&gt;in(0);
1893       Node* cmp2  = cmp-&gt;clone();
1894       cmp2-&gt;set_req(2, new_limit);
1895       register_new_node(cmp2, ctrl2);
1896       Node* bol2 = loop_end-&gt;in(1)-&gt;clone();
1897       bol2-&gt;set_req(1, cmp2);
1898       register_new_node(bol2, ctrl2);
1899       _igvn.replace_input_of(loop_end, 1, bol2);
1900     }
1901     // Step 3: Find the min-trip test guaranteed before a &#39;main&#39; loop.
1902     // Make it a 1-trip test (means at least 2 trips).
</pre>
<hr />
<pre>
1912   // down here (e.g. 15-&gt; 7-&gt; 3-&gt; 1) because if we unwittingly over-unroll,
1913   // the main, unrolled, part of the loop will never execute as it is protected
1914   // by the min-trip test.  See bug 4834191 for a case where we over-unrolled
1915   // and later determined that part of the unrolled loop was dead.
1916   loop_head-&gt;set_trip_count(old_trip_count / 2);
1917 
1918   // Double the count of original iterations in the unrolled loop body.
1919   loop_head-&gt;double_unrolled_count();
1920 
1921   // ---------
1922   // Step 4: Clone the loop body.  Move it inside the loop.  This loop body
1923   // represents the odd iterations; since the loop trips an even number of
1924   // times its backedge is never taken.  Kill the backedge.
1925   uint dd = dom_depth(loop_head);
1926   clone_loop(loop, old_new, dd, IgnoreStripMined);
1927 
1928   // Make backedges of the clone equal to backedges of the original.
1929   // Make the fall-in from the original come from the fall-out of the clone.
1930   for (DUIterator_Fast jmax, j = loop_head-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1931     Node* phi = loop_head-&gt;fast_out(j);
<span class="line-modified">1932     if( phi-&gt;is_Phi() &amp;&amp; phi-&gt;in(0) == loop_head &amp;&amp; phi-&gt;outcnt() &gt; 0 ) {</span>
1933       Node *newphi = old_new[phi-&gt;_idx];
<span class="line-modified">1934       _igvn.hash_delete( phi );</span>
<span class="line-modified">1935       _igvn.hash_delete( newphi );</span>
1936 
1937       phi   -&gt;set_req(LoopNode::   EntryControl, newphi-&gt;in(LoopNode::LoopBackControl));
1938       newphi-&gt;set_req(LoopNode::LoopBackControl, phi   -&gt;in(LoopNode::LoopBackControl));
1939       phi   -&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
1940     }
1941   }
1942   Node *clone_head = old_new[loop_head-&gt;_idx];
<span class="line-modified">1943   _igvn.hash_delete( clone_head );</span>
1944   loop_head -&gt;set_req(LoopNode::   EntryControl, clone_head-&gt;in(LoopNode::LoopBackControl));
1945   clone_head-&gt;set_req(LoopNode::LoopBackControl, loop_head -&gt;in(LoopNode::LoopBackControl));
1946   loop_head -&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
1947   loop-&gt;_head = clone_head;     // New loop header
1948 
1949   set_idom(loop_head,  loop_head -&gt;in(LoopNode::EntryControl), dd);
1950   set_idom(clone_head, clone_head-&gt;in(LoopNode::EntryControl), dd);
1951 
1952   // Kill the clone&#39;s backedge
1953   Node *newcle = old_new[loop_end-&gt;_idx];
<span class="line-modified">1954   _igvn.hash_delete( newcle );</span>
1955   Node *one = _igvn.intcon(1);
1956   set_ctrl(one, C-&gt;root());
1957   newcle-&gt;set_req(1, one);
1958   // Force clone into same loop body
1959   uint max = loop-&gt;_body.size();
<span class="line-modified">1960   for( uint k = 0; k &lt; max; k++ ) {</span>
1961     Node *old = loop-&gt;_body.at(k);
1962     Node *nnn = old_new[old-&gt;_idx];
1963     loop-&gt;_body.push(nnn);
<span class="line-modified">1964     if (!has_ctrl(old))</span>
1965       set_loop(nnn, loop);

1966   }
1967 
1968   loop-&gt;record_for_igvn();
1969   loop_head-&gt;clear_strip_mined();
1970 
1971 #ifndef PRODUCT
1972   if (C-&gt;do_vector_loop() &amp;&amp; (PrintOpto &amp;&amp; (VerifyLoopOptimizations || TraceLoopOpts))) {
1973     tty-&gt;print(&quot;\nnew loop after unroll\n&quot;);       loop-&gt;dump_head();
1974     for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {
1975       loop-&gt;_body.at(i)-&gt;dump();
1976     }
<span class="line-modified">1977     if(C-&gt;clone_map().is_debug()) {</span>
1978       tty-&gt;print(&quot;\nCloneMap\n&quot;);
1979       Dict* dict = C-&gt;clone_map().dict();
1980       DictI i(dict);
1981       tty-&gt;print_cr(&quot;Dict@%p[%d] = &quot;, dict, dict-&gt;Size());
1982       for (int ii = 0; i.test(); ++i, ++ii) {
1983         NodeCloneInfo cl((uint64_t)dict-&gt;operator[]((void*)i._key));
1984         tty-&gt;print(&quot;%d-&gt;%d:%d,&quot;, (int)(intptr_t)i._key, cl.idx(), cl.gen());
1985         if (ii % 10 == 9) {
1986           tty-&gt;print_cr(&quot; &quot;);
1987         }
1988       }
1989       tty-&gt;print_cr(&quot; &quot;);
1990     }
1991   }
1992 #endif
<span class="line-removed">1993 </span>
1994 }
1995 
1996 //------------------------------do_maximally_unroll----------------------------
1997 
<span class="line-modified">1998 void PhaseIdealLoop::do_maximally_unroll( IdealLoopTree *loop, Node_List &amp;old_new ) {</span>
1999   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
2000   assert(cl-&gt;has_exact_trip_count(), &quot;trip count is not exact&quot;);
2001   assert(cl-&gt;trip_count() &gt; 0, &quot;&quot;);
2002 #ifndef PRODUCT
2003   if (TraceLoopOpts) {
2004     tty-&gt;print(&quot;MaxUnroll  %d &quot;, cl-&gt;trip_count());
2005     loop-&gt;dump_head();
2006   }
2007 #endif
2008 
2009   // If loop is tripping an odd number of times, peel odd iteration
2010   if ((cl-&gt;trip_count() &amp; 1) == 1) {
2011     do_peeling(loop, old_new);
2012   }
2013 
2014   // Now its tripping an even number of times remaining.  Double loop body.
2015   // Do not adjust pre-guards; they are not needed and do not exist.
2016   if (cl-&gt;trip_count() &gt; 0) {
2017     assert((cl-&gt;trip_count() &amp; 1) == 0, &quot;missed peeling&quot;);
2018     do_unroll(loop, old_new, false);
</pre>
<hr />
<pre>
2096   if (round_up) {
2097     X = new AddINode(X, _igvn.intcon(1));
2098     register_new_node(X, pre_ctrl);
2099   }
2100 
2101   // Adjust loop limit
2102   loop_limit = (stride_con &gt; 0)
2103                ? (Node*)(new MinINode(loop_limit, X))
2104                : (Node*)(new MaxINode(loop_limit, X));
2105   register_new_node(loop_limit, pre_ctrl);
2106   return loop_limit;
2107 }
2108 
2109 //------------------------------add_constraint---------------------------------
2110 // Constrain the main loop iterations so the conditions:
2111 //    low_limit &lt;= scale_con * I + offset  &lt;  upper_limit
2112 // always holds true.  That is, either increase the number of iterations in
2113 // the pre-loop or the post-loop until the condition holds true in the main
2114 // loop.  Stride, scale, offset and limit are all loop invariant.  Further,
2115 // stride and scale are constants (offset and limit often are).
<span class="line-modified">2116 void PhaseIdealLoop::add_constraint( int stride_con, int scale_con, Node *offset, Node *low_limit, Node *upper_limit, Node *pre_ctrl, Node **pre_limit, Node **main_limit ) {</span>
2117   // For positive stride, the pre-loop limit always uses a MAX function
2118   // and the main loop a MIN function.  For negative stride these are
2119   // reversed.
2120 
2121   // Also for positive stride*scale the affine function is increasing, so the
2122   // pre-loop must check for underflow and the post-loop for overflow.
2123   // Negative stride*scale reverses this; pre-loop checks for overflow and
2124   // post-loop for underflow.
2125 
2126   Node *scale = _igvn.intcon(scale_con);
2127   set_ctrl(scale, C-&gt;root());
2128 
2129   if ((stride_con^scale_con) &gt;= 0) { // Use XOR to avoid overflow
2130     // The overflow limit: scale*I+offset &lt; upper_limit
2131     // For main-loop compute
2132     //   ( if (scale &gt; 0) /* and stride &gt; 0 */
2133     //       I &lt; (upper_limit-offset)/scale
2134     //     else /* scale &lt; 0 and stride &lt; 0 */
2135     //       I &gt; (upper_limit-offset)/scale
2136     //   )
</pre>
<hr />
<pre>
2181     // post-loop for underflow.
2182     //
2183     // The overflow limit: scale*I+offset &lt; upper_limit
2184     // For pre-loop compute
2185     //   NOT(scale*I+offset &lt; upper_limit)
2186     //   scale*I+offset &gt;= upper_limit
2187     //   scale*I+offset+1 &gt; upper_limit
2188     //   ( if (scale &lt; 0) /* and stride &gt; 0 */
2189     //       I &lt; (upper_limit-(offset+1))/scale
2190     //     else /* scale &gt; 0 and stride &lt; 0 */
2191     //       I &gt; (upper_limit-(offset+1))/scale
2192     //   )
2193     //
2194     // (upper_limit-offset-1) may underflow or overflow.
2195     // To avoid it min(pre_limit, original_limit) is used
2196     // in do_range_check() for stride &gt; 0 and max() for &lt; 0.
2197     Node *one  = _igvn.intcon(1);
2198     set_ctrl(one, C-&gt;root());
2199 
2200     Node *plus_one = new AddINode(offset, one);
<span class="line-modified">2201     register_new_node( plus_one, pre_ctrl );</span>
2202     // Pass (-stride) to indicate pre_loop_cond = NOT(main_loop_cond);
2203     *pre_limit = adjust_limit((-stride_con), scale, plus_one, upper_limit, *pre_limit, pre_ctrl,
2204                               scale_con &lt; -1 &amp;&amp; stride_con &gt; 0);
2205 
2206     if (low_limit-&gt;get_int() == -max_jint) {
2207       // We need this guard when scale*main_limit+offset &gt;= limit
2208       // due to underflow. So we need execute main-loop while
2209       // scale*I+offset+1 &gt; min_int. But (min_int-offset-1) will
2210       // underflow when (offset+1) &gt; 0 and X will be &lt; main_limit
2211       // when scale &lt; 0 (and stride &gt; 0). To avoid it we replace
2212       // positive (offset+1) with 0.
2213       //
2214       // Also (min_int+1 == -max_int) is used instead of min_int here
2215       // to avoid problem with scale == -1 (min_int/(-1) == min_int).
2216       Node* shift = _igvn.intcon(31);
2217       set_ctrl(shift, C-&gt;root());
2218       Node* sign = new RShiftINode(plus_one, shift);
2219       register_new_node(sign, pre_ctrl);
2220       plus_one = new AndINode(plus_one, sign);
2221       register_new_node(plus_one, pre_ctrl);
</pre>
<hr />
<pre>
2342 Node* PhaseIdealLoop::add_range_check_predicate(IdealLoopTree* loop, CountedLoopNode* cl,
2343                                                 Node* predicate_proj, int scale_con, Node* offset,
2344                                                 Node* limit, jint stride_con, Node* value) {
2345   bool overflow = false;
2346   BoolNode* bol = rc_predicate(loop, predicate_proj, scale_con, offset, value, NULL, stride_con, limit, (stride_con &gt; 0) != (scale_con &gt; 0), overflow);
2347   Node* opaque_bol = new Opaque4Node(C, bol, _igvn.intcon(1));
2348   register_new_node(opaque_bol, predicate_proj);
2349   IfNode* new_iff = NULL;
2350   if (overflow) {
2351     new_iff = new IfNode(predicate_proj, opaque_bol, PROB_MAX, COUNT_UNKNOWN);
2352   } else {
2353     new_iff = new RangeCheckNode(predicate_proj, opaque_bol, PROB_MAX, COUNT_UNKNOWN);
2354   }
2355   register_control(new_iff, loop-&gt;_parent, predicate_proj);
2356   Node* iffalse = new IfFalseNode(new_iff);
2357   register_control(iffalse, _ltree_root, new_iff);
2358   ProjNode* iftrue = new IfTrueNode(new_iff);
2359   register_control(iftrue, loop-&gt;_parent, new_iff);
2360   Node *frame = new ParmNode(C-&gt;start(), TypeFunc::FramePtr);
2361   register_new_node(frame, C-&gt;start());
<span class="line-modified">2362   Node* halt = new HaltNode(iffalse, frame);</span>
2363   register_control(halt, _ltree_root, iffalse);
2364   C-&gt;root()-&gt;add_req(halt);
2365   return iftrue;
2366 }
2367 
2368 //------------------------------do_range_check---------------------------------
2369 // Eliminate range-checks and other trip-counter vs loop-invariant tests.
<span class="line-modified">2370 int PhaseIdealLoop::do_range_check( IdealLoopTree *loop, Node_List &amp;old_new ) {</span>
2371 #ifndef PRODUCT
2372   if (PrintOpto &amp;&amp; VerifyLoopOptimizations) {
2373     tty-&gt;print(&quot;Range Check Elimination &quot;);
2374     loop-&gt;dump_head();
2375   } else if (TraceLoopOpts) {
2376     tty-&gt;print(&quot;RangeCheck   &quot;);
2377     loop-&gt;dump_head();
2378   }
2379 #endif

2380   assert(RangeCheckElimination, &quot;&quot;);
2381   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
2382   // If we fail before trying to eliminate range checks, set multiversion state
2383   int closed_range_checks = 1;
2384 
2385   // protect against stride not being a constant
<span class="line-modified">2386   if (!cl-&gt;stride_is_con())</span>
2387     return closed_range_checks;
<span class="line-modified">2388 </span>
2389   // Find the trip counter; we are iteration splitting based on it
2390   Node *trip_counter = cl-&gt;phi();
2391   // Find the main loop limit; we will trim it&#39;s iterations
2392   // to not ever trip end tests
2393   Node *main_limit = cl-&gt;limit();
2394 
2395   // Check graph shape. Cannot optimize a loop if zero-trip
2396   // Opaque1 node is optimized away and then another round
2397   // of loop opts attempted.
2398   if (!is_canonical_loop_entry(cl)) {
2399     return closed_range_checks;
2400   }
2401 
2402   // Need to find the main-loop zero-trip guard
<span class="line-modified">2403   Node *ctrl  = cl-&gt;skip_predicates();</span>
2404   Node *iffm = ctrl-&gt;in(0);
2405   Node *opqzm = iffm-&gt;in(1)-&gt;in(1)-&gt;in(2);
2406   assert(opqzm-&gt;in(1) == main_limit, &quot;do not understand situation&quot;);
2407 
2408   // Find the pre-loop limit; we will expand its iterations to
2409   // not ever trip low tests.
2410   Node *p_f = iffm-&gt;in(0);
2411   // pre loop may have been optimized out
2412   if (p_f-&gt;Opcode() != Op_IfFalse) {
2413     return closed_range_checks;
2414   }
2415   CountedLoopEndNode *pre_end = p_f-&gt;in(0)-&gt;as_CountedLoopEnd();
2416   assert(pre_end-&gt;loopnode()-&gt;is_pre_loop(), &quot;&quot;);
2417   Node *pre_opaq1 = pre_end-&gt;limit();
2418   // Occasionally it&#39;s possible for a pre-loop Opaque1 node to be
2419   // optimized away and then another round of loop opts attempted.
2420   // We can not optimize this particular loop in that case.
<span class="line-modified">2421   if (pre_opaq1-&gt;Opcode() != Op_Opaque1)</span>
2422     return closed_range_checks;

2423   Opaque1Node *pre_opaq = (Opaque1Node*)pre_opaq1;
2424   Node *pre_limit = pre_opaq-&gt;in(1);
2425 
2426   // Where do we put new limit calculations
2427   Node *pre_ctrl = pre_end-&gt;loopnode()-&gt;in(LoopNode::EntryControl);
2428 
2429   // Ensure the original loop limit is available from the
2430   // pre-loop Opaque1 node.
2431   Node *orig_limit = pre_opaq-&gt;original_loop_limit();
<span class="line-modified">2432   if (orig_limit == NULL || _igvn.type(orig_limit) == Type::TOP)</span>
2433     return closed_range_checks;
<span class="line-modified">2434 </span>
2435   // Must know if its a count-up or count-down loop
2436 
2437   int stride_con = cl-&gt;stride_con();
2438   Node *zero = _igvn.intcon(0);
2439   Node *one  = _igvn.intcon(1);
2440   // Use symmetrical int range [-max_jint,max_jint]
2441   Node *mini = _igvn.intcon(-max_jint);
2442   set_ctrl(zero, C-&gt;root());
2443   set_ctrl(one,  C-&gt;root());
2444   set_ctrl(mini, C-&gt;root());
2445 
2446   // Range checks that do not dominate the loop backedge (ie.
2447   // conditionally executed) can lengthen the pre loop limit beyond
2448   // the original loop limit. To prevent this, the pre limit is
2449   // (for stride &gt; 0) MINed with the original loop limit (MAXed
2450   // stride &lt; 0) when some range_check (rc) is conditionally
2451   // executed.
2452   bool conditional_rc = false;
2453 
2454   // Count number of range checks and reduce by load range limits, if zero,
2455   // the loop is in canonical form to multiversion.
2456   closed_range_checks = 0;
2457 
2458   Node* predicate_proj = cl-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
2459   assert(predicate_proj-&gt;is_Proj() &amp;&amp; predicate_proj-&gt;in(0)-&gt;is_If(), &quot;if projection only&quot;);

2460   // Check loop body for tests of trip-counter plus loop-invariant vs loop-variant.
<span class="line-modified">2461   for( uint i = 0; i &lt; loop-&gt;_body.size(); i++ ) {</span>
2462     Node *iff = loop-&gt;_body[i];
2463     if (iff-&gt;Opcode() == Op_If ||
2464         iff-&gt;Opcode() == Op_RangeCheck) { // Test?
2465       // Test is an IfNode, has 2 projections.  If BOTH are in the loop
2466       // we need loop unswitching instead of iteration splitting.
2467       closed_range_checks++;
2468       Node *exit = loop-&gt;is_loop_exit(iff);
<span class="line-modified">2469       if( !exit ) continue;</span>
2470       int flip = (exit-&gt;Opcode() == Op_IfTrue) ? 1 : 0;
2471 
2472       // Get boolean condition to test
2473       Node *i1 = iff-&gt;in(1);
<span class="line-modified">2474       if( !i1-&gt;is_Bool() ) continue;</span>
2475       BoolNode *bol = i1-&gt;as_Bool();
2476       BoolTest b_test = bol-&gt;_test;
2477       // Flip sense of test if exit condition is flipped
<span class="line-modified">2478       if( flip )</span>
2479         b_test = b_test.negate();
<span class="line-modified">2480 </span>
2481       // Get compare
2482       Node *cmp = bol-&gt;in(1);
2483 
2484       // Look for trip_counter + offset vs limit
2485       Node *rc_exp = cmp-&gt;in(1);
2486       Node *limit  = cmp-&gt;in(2);
2487       int scale_con= 1;        // Assume trip counter not scaled
2488 
2489       Node *limit_c = get_ctrl(limit);
<span class="line-modified">2490       if( loop-&gt;is_member(get_loop(limit_c) ) ) {</span>
2491         // Compare might have operands swapped; commute them
2492         b_test = b_test.commute();
2493         rc_exp = cmp-&gt;in(2);
2494         limit  = cmp-&gt;in(1);
2495         limit_c = get_ctrl(limit);
<span class="line-modified">2496         if( loop-&gt;is_member(get_loop(limit_c) ) )</span>
2497           continue;             // Both inputs are loop varying; cannot RCE

2498       }
2499       // Here we know &#39;limit&#39; is loop invariant
2500 
2501       // &#39;limit&#39; maybe pinned below the zero trip test (probably from a
2502       // previous round of rce), in which case, it can&#39;t be used in the
2503       // zero trip test expression which must occur before the zero test&#39;s if.
2504       if (is_dominator(ctrl, limit_c)) {
2505         continue;  // Don&#39;t rce this check but continue looking for other candidates.
2506       }
2507 
2508       // Check for scaled induction variable plus an offset
2509       Node *offset = NULL;
2510 
2511       if (!is_scaled_iv_plus_offset(rc_exp, trip_counter, &amp;scale_con, &amp;offset)) {
2512         continue;
2513       }
2514 
2515       Node *offset_c = get_ctrl(offset);
<span class="line-modified">2516       if( loop-&gt;is_member( get_loop(offset_c) ) )</span>
2517         continue;               // Offset is not really loop invariant

2518       // Here we know &#39;offset&#39; is loop invariant.
2519 
2520       // As above for the &#39;limit&#39;, the &#39;offset&#39; maybe pinned below the
2521       // zero trip test.
2522       if (is_dominator(ctrl, offset_c)) {
2523         continue; // Don&#39;t rce this check but continue looking for other candidates.
2524       }
2525 #ifdef ASSERT
2526       if (TraceRangeLimitCheck) {
2527         tty-&gt;print_cr(&quot;RC bool node%s&quot;, flip ? &quot; flipped:&quot; : &quot;:&quot;);
2528         bol-&gt;dump(2);
2529       }
2530 #endif
2531       // At this point we have the expression as:
2532       //   scale_con * trip_counter + offset :: limit
2533       // where scale_con, offset and limit are loop invariant.  Trip_counter
2534       // monotonically increases by stride_con, a constant.  Both (or either)
2535       // stride_con and scale_con can be negative which will flip about the
2536       // sense of the test.
2537 
2538       // Adjust pre and main loop limits to guard the correct iteration set
<span class="line-modified">2539       if( cmp-&gt;Opcode() == Op_CmpU ) {// Unsigned compare is really 2 tests</span>
<span class="line-modified">2540         if( b_test._test == BoolTest::lt ) { // Range checks always use lt</span>
2541           // The underflow and overflow limits: 0 &lt;= scale*I+offset &lt; limit
<span class="line-modified">2542           add_constraint( stride_con, scale_con, offset, zero, limit, pre_ctrl, &amp;pre_limit, &amp;main_limit );</span>
2543           // (0-offset)/scale could be outside of loop iterations range.
2544           conditional_rc = true;
2545           Node* init = cl-&gt;init_trip();
2546           Node* opaque_init = new Opaque1Node(C, init);
2547           register_new_node(opaque_init, predicate_proj);
2548           // template predicate so it can be updated on next unrolling
2549           predicate_proj = add_range_check_predicate(loop, cl, predicate_proj, scale_con, offset, limit, stride_con, opaque_init);
2550           assert(skeleton_predicate_has_opaque(predicate_proj-&gt;in(0)-&gt;as_If()), &quot;unexpected&quot;);
2551           // predicate on first value of first iteration
2552           predicate_proj = add_range_check_predicate(loop, cl, predicate_proj, scale_con, offset, limit, stride_con, init);
2553           assert(!skeleton_predicate_has_opaque(predicate_proj-&gt;in(0)-&gt;as_If()), &quot;unexpected&quot;);
2554           int init_inc = stride_con/cl-&gt;unrolled_count();
2555           assert(init_inc != 0, &quot;invalid loop increment&quot;);
2556           Node* max_value = _igvn.intcon(stride_con - init_inc);
2557           max_value = new AddINode(init, max_value);
2558           register_new_node(max_value, predicate_proj);
2559           // predicate on last value of first iteration (in case unrolling has already happened)
2560           predicate_proj = add_range_check_predicate(loop, cl, predicate_proj, scale_con, offset, limit, stride_con, max_value);
2561           assert(!skeleton_predicate_has_opaque(predicate_proj-&gt;in(0)-&gt;as_If()), &quot;unexpected&quot;);
2562         } else {
2563           if (PrintOpto) {
2564             tty-&gt;print_cr(&quot;missed RCE opportunity&quot;);
2565           }
2566           continue;             // In release mode, ignore it
2567         }
2568       } else {                  // Otherwise work on normal compares
<span class="line-modified">2569         switch( b_test._test ) {</span>
2570         case BoolTest::gt:
2571           // Fall into GE case
2572         case BoolTest::ge:
2573           // Convert (I*scale+offset) &gt;= Limit to (I*(-scale)+(-offset)) &lt;= -Limit
2574           scale_con = -scale_con;
<span class="line-modified">2575           offset = new SubINode( zero, offset );</span>
<span class="line-modified">2576           register_new_node( offset, pre_ctrl );</span>
<span class="line-modified">2577           limit  = new SubINode( zero, limit );</span>
<span class="line-modified">2578           register_new_node( limit, pre_ctrl );</span>
2579           // Fall into LE case
2580         case BoolTest::le:
2581           if (b_test._test != BoolTest::gt) {
2582             // Convert X &lt;= Y to X &lt; Y+1
<span class="line-modified">2583             limit = new AddINode( limit, one );</span>
<span class="line-modified">2584             register_new_node( limit, pre_ctrl );</span>
2585           }
2586           // Fall into LT case
2587         case BoolTest::lt:
2588           // The underflow and overflow limits: MIN_INT &lt;= scale*I+offset &lt; limit
2589           // Note: (MIN_INT+1 == -MAX_INT) is used instead of MIN_INT here
2590           // to avoid problem with scale == -1: MIN_INT/(-1) == MIN_INT.
<span class="line-modified">2591           add_constraint( stride_con, scale_con, offset, mini, limit, pre_ctrl, &amp;pre_limit, &amp;main_limit );</span>
2592           // ((MIN_INT+1)-offset)/scale could be outside of loop iterations range.
2593           // Note: negative offset is replaced with 0 but (MIN_INT+1)/scale could
2594           // still be outside of loop range.
2595           conditional_rc = true;
2596           break;
2597         default:
2598           if (PrintOpto) {
2599             tty-&gt;print_cr(&quot;missed RCE opportunity&quot;);
2600           }
2601           continue;             // Unhandled case
2602         }
2603       }
2604 
2605       // Kill the eliminated test
2606       C-&gt;set_major_progress();
<span class="line-modified">2607       Node *kill_con = _igvn.intcon( 1-flip );</span>
2608       set_ctrl(kill_con, C-&gt;root());
2609       _igvn.replace_input_of(iff, 1, kill_con);
2610       // Find surviving projection
2611       assert(iff-&gt;is_If(), &quot;&quot;);
2612       ProjNode* dp = ((IfNode*)iff)-&gt;proj_out(1-flip);
2613       // Find loads off the surviving projection; remove their control edge
2614       for (DUIterator_Fast imax, i = dp-&gt;fast_outs(imax); i &lt; imax; i++) {
2615         Node* cd = dp-&gt;fast_out(i); // Control-dependent node
2616         if (cd-&gt;is_Load() &amp;&amp; cd-&gt;depends_only_on_test()) {   // Loads can now float around in the loop
2617           // Allow the load to float around in the loop, or before it
2618           // but NOT before the pre-loop.
2619           _igvn.replace_input_of(cd, 0, ctrl); // ctrl, not NULL
2620           --i;
2621           --imax;
2622         }
2623       }
2624       if (limit-&gt;Opcode() == Op_LoadRange) {
2625         closed_range_checks--;
2626       }
<span class="line-removed">2627 </span>
2628     } // End of is IF
<span class="line-removed">2629 </span>
2630   }
2631   if (predicate_proj != cl-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl)) {
2632     _igvn.replace_input_of(cl-&gt;skip_strip_mined(), LoopNode::EntryControl, predicate_proj);
2633     set_idom(cl-&gt;skip_strip_mined(), predicate_proj, dom_depth(cl-&gt;skip_strip_mined()));
2634   }
2635 
2636   // Update loop limits
2637   if (conditional_rc) {
2638     pre_limit = (stride_con &gt; 0) ? (Node*)new MinINode(pre_limit, orig_limit)
2639                                  : (Node*)new MaxINode(pre_limit, orig_limit);
2640     register_new_node(pre_limit, pre_ctrl);
2641   }
2642   _igvn.replace_input_of(pre_opaq, 1, pre_limit);
2643 
2644   // Note:: we are making the main loop limit no longer precise;
2645   // need to round up based on stride.
2646   cl-&gt;set_nonexact_trip_count();
2647   Node *main_cle = cl-&gt;loopexit();
2648   Node *main_bol = main_cle-&gt;in(1);
2649   // Hacking loop bounds; need private copies of exit test
<span class="line-modified">2650   if( main_bol-&gt;outcnt() &gt; 1 ) {// BoolNode shared?</span>
<span class="line-modified">2651     main_bol = main_bol-&gt;clone();// Clone a private BoolNode</span>
<span class="line-modified">2652     register_new_node( main_bol, main_cle-&gt;in(0) );</span>
2653     _igvn.replace_input_of(main_cle, 1, main_bol);
2654   }
2655   Node *main_cmp = main_bol-&gt;in(1);
<span class="line-modified">2656   if( main_cmp-&gt;outcnt() &gt; 1 ) { // CmpNode shared?</span>
<span class="line-modified">2657     main_cmp = main_cmp-&gt;clone();// Clone a private CmpNode</span>
<span class="line-modified">2658     register_new_node( main_cmp, main_cle-&gt;in(0) );</span>
2659     _igvn.replace_input_of(main_bol, 1, main_cmp);
2660   }
2661   // Hack the now-private loop bounds
2662   _igvn.replace_input_of(main_cmp, 2, main_limit);
2663   // The OpaqueNode is unshared by design
<span class="line-modified">2664   assert( opqzm-&gt;outcnt() == 1, &quot;cannot hack shared node&quot; );</span>
2665   _igvn.replace_input_of(opqzm, 1, main_limit);
2666 
2667   return closed_range_checks;
2668 }
2669 
2670 //------------------------------has_range_checks-------------------------------
2671 // Check to see if RCE cleaned the current loop of range-checks.
2672 void PhaseIdealLoop::has_range_checks(IdealLoopTree *loop) {
2673   assert(RangeCheckElimination, &quot;&quot;);
2674 
2675   // skip if not a counted loop
2676   if (!loop-&gt;is_counted()) return;
2677 
2678   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
2679 
2680   // skip this loop if it is already checked
2681   if (cl-&gt;has_been_range_checked()) return;
2682 
2683   // Now check for existence of range checks
2684   for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {
</pre>
<hr />
<pre>
2813       Node* cur_bool = iffm-&gt;in(1);
2814       if (cur_bool-&gt;is_Bool()) {
2815         Node* cur_cmp = cur_bool-&gt;in(1);
2816         if (cur_cmp-&gt;is_Cmp()) {
2817           BoolTest::mask new_test = BoolTest::gt;
2818           BoolNode *new_bool = new BoolNode(cur_cmp, new_test);
2819           _igvn.replace_node(cur_bool, new_bool);
2820           _igvn._worklist.push(new_bool);
2821           Node* left_op = cur_cmp-&gt;in(1);
2822           _igvn.replace_input_of(cur_cmp, 2, left_op);
2823           C-&gt;set_major_progress();
2824         }
2825       }
2826     }
2827   }
2828 }
2829 
2830 //------------------------------DCE_loop_body----------------------------------
2831 // Remove simplistic dead code from loop body
2832 void IdealLoopTree::DCE_loop_body() {
<span class="line-modified">2833   for( uint i = 0; i &lt; _body.size(); i++ )</span>
<span class="line-modified">2834     if( _body.at(i)-&gt;outcnt() == 0 )</span>
<span class="line-modified">2835       _body.map( i--, _body.pop() );</span>



2836 }
2837 
2838 
2839 //------------------------------adjust_loop_exit_prob--------------------------
2840 // Look for loop-exit tests with the 50/50 (or worse) guesses from the parsing stage.
2841 // Replace with a 1-in-10 exit guess.
<span class="line-modified">2842 void IdealLoopTree::adjust_loop_exit_prob( PhaseIdealLoop *phase ) {</span>
2843   Node *test = tail();
<span class="line-modified">2844   while( test != _head ) {</span>
2845     uint top = test-&gt;Opcode();
<span class="line-modified">2846     if( top == Op_IfTrue || top == Op_IfFalse ) {</span>
2847       int test_con = ((ProjNode*)test)-&gt;_con;
2848       assert(top == (uint)(test_con? Op_IfTrue: Op_IfFalse), &quot;sanity&quot;);
2849       IfNode *iff = test-&gt;in(0)-&gt;as_If();
<span class="line-modified">2850       if( iff-&gt;outcnt() == 2 ) {        // Ignore dead tests</span>
2851         Node *bol = iff-&gt;in(1);
<span class="line-modified">2852         if( bol &amp;&amp; bol-&gt;req() &gt; 1 &amp;&amp; bol-&gt;in(1) &amp;&amp;</span>
<span class="line-modified">2853             ((bol-&gt;in(1)-&gt;Opcode() == Op_StorePConditional ) ||</span>
<span class="line-modified">2854              (bol-&gt;in(1)-&gt;Opcode() == Op_StoreIConditional ) ||</span>
<span class="line-modified">2855              (bol-&gt;in(1)-&gt;Opcode() == Op_StoreLConditional ) ||</span>
<span class="line-modified">2856              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeB ) ||</span>
<span class="line-modified">2857              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeS ) ||</span>
<span class="line-modified">2858              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeI ) ||</span>
<span class="line-modified">2859              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeL ) ||</span>
<span class="line-modified">2860              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeP ) ||</span>
<span class="line-modified">2861              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeN ) ||</span>
<span class="line-modified">2862              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapB ) ||</span>
<span class="line-modified">2863              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapS ) ||</span>
<span class="line-modified">2864              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapI ) ||</span>
<span class="line-modified">2865              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapL ) ||</span>
<span class="line-modified">2866              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapP ) ||</span>
<span class="line-modified">2867              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapN ) ||</span>
<span class="line-modified">2868              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapB ) ||</span>
<span class="line-modified">2869              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapS ) ||</span>
<span class="line-modified">2870              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapI ) ||</span>
<span class="line-modified">2871              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapL ) ||</span>
<span class="line-modified">2872              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapP ) ||</span>
<span class="line-modified">2873              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapN ) ||</span>
<span class="line-modified">2874              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahCompareAndExchangeP ) ||</span>
<span class="line-modified">2875              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahCompareAndExchangeN ) ||</span>
<span class="line-modified">2876              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahWeakCompareAndSwapP ) ||</span>
<span class="line-modified">2877              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahWeakCompareAndSwapN ) ||</span>
<span class="line-modified">2878              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahCompareAndSwapP ) ||</span>
<span class="line-modified">2879              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahCompareAndSwapN )))</span>
2880           return;               // Allocation loops RARELY take backedge
2881         // Find the OTHER exit path from the IF
2882         Node* ex = iff-&gt;proj_out(1-test_con);
2883         float p = iff-&gt;_prob;
<span class="line-modified">2884         if( !phase-&gt;is_member( this, ex ) &amp;&amp; iff-&gt;_fcnt == COUNT_UNKNOWN ) {</span>
<span class="line-modified">2885           if( top == Op_IfTrue ) {</span>
<span class="line-modified">2886             if( p &lt; (PROB_FAIR + PROB_UNLIKELY_MAG(3))) {</span>
2887               iff-&gt;_prob = PROB_STATIC_FREQUENT;
2888             }
2889           } else {
<span class="line-modified">2890             if( p &gt; (PROB_FAIR - PROB_UNLIKELY_MAG(3))) {</span>
2891               iff-&gt;_prob = PROB_STATIC_INFREQUENT;
2892             }
2893           }
2894         }
2895       }
2896     }
2897     test = phase-&gt;idom(test);
2898   }
2899 }
2900 
2901 #ifdef ASSERT
<span class="line-modified">2902 static CountedLoopNode* locate_pre_from_main(CountedLoopNode *cl) {</span>
<span class="line-modified">2903   Node *ctrl  = cl-&gt;skip_predicates();</span>

2904   assert(ctrl-&gt;Opcode() == Op_IfTrue || ctrl-&gt;Opcode() == Op_IfFalse, &quot;&quot;);
<span class="line-modified">2905   Node *iffm = ctrl-&gt;in(0);</span>
2906   assert(iffm-&gt;Opcode() == Op_If, &quot;&quot;);
<span class="line-modified">2907   Node *p_f = iffm-&gt;in(0);</span>
2908   assert(p_f-&gt;Opcode() == Op_IfFalse, &quot;&quot;);
<span class="line-modified">2909   CountedLoopEndNode *pre_end = p_f-&gt;in(0)-&gt;as_CountedLoopEnd();</span>
<span class="line-modified">2910   assert(pre_end-&gt;loopnode()-&gt;is_pre_loop(), &quot;&quot;);</span>
<span class="line-modified">2911   return pre_end-&gt;loopnode();</span>
2912 }
2913 #endif
2914 
2915 // Remove the main and post loops and make the pre loop execute all
2916 // iterations. Useful when the pre loop is found empty.
2917 void IdealLoopTree::remove_main_post_loops(CountedLoopNode *cl, PhaseIdealLoop *phase) {
2918   CountedLoopEndNode* pre_end = cl-&gt;loopexit();
2919   Node* pre_cmp = pre_end-&gt;cmp_node();
2920   if (pre_cmp-&gt;in(2)-&gt;Opcode() != Op_Opaque1) {
2921     // Only safe to remove the main loop if the compiler optimized it
2922     // out based on an unknown number of iterations
2923     return;
2924   }
2925 
2926   // Can we find the main loop?
2927   if (_next == NULL) {
2928     return;
2929   }
2930 
2931   Node* next_head = _next-&gt;_head;
2932   if (!next_head-&gt;is_CountedLoop()) {
2933     return;
2934   }
2935 
2936   CountedLoopNode* main_head = next_head-&gt;as_CountedLoop();
<span class="line-modified">2937   if (!main_head-&gt;is_main_loop()) {</span>
2938     return;
2939   }
2940 
2941   assert(locate_pre_from_main(main_head) == cl, &quot;bad main loop&quot;);
2942   Node* main_iff = main_head-&gt;skip_predicates()-&gt;in(0);
2943 
2944   // Remove the Opaque1Node of the pre loop and make it execute all iterations
2945   phase-&gt;_igvn.replace_input_of(pre_cmp, 2, pre_cmp-&gt;in(2)-&gt;in(2));
2946   // Remove the Opaque1Node of the main loop so it can be optimized out
2947   Node* main_cmp = main_iff-&gt;in(1)-&gt;in(1);
2948   assert(main_cmp-&gt;in(2)-&gt;Opcode() == Op_Opaque1, &quot;main loop has no opaque node?&quot;);
2949   phase-&gt;_igvn.replace_input_of(main_cmp, 2, main_cmp-&gt;in(2)-&gt;in(1));
2950 }
2951 
<span class="line-modified">2952 //------------------------------policy_do_remove_empty_loop--------------------</span>
<span class="line-modified">2953 // Micro-benchmark spamming.  Policy is to always remove empty loops.</span>
<span class="line-modified">2954 // The &#39;DO&#39; part is to replace the trip counter with the value it will</span>
<span class="line-modified">2955 // have on the last iteration.  This will break the loop.</span>
<span class="line-modified">2956 bool IdealLoopTree::policy_do_remove_empty_loop( PhaseIdealLoop *phase ) {</span>
2957   // Minimum size must be empty loop
<span class="line-modified">2958   if (_body.size() &gt; EMPTY_LOOP_SIZE)</span>
2959     return false;
<span class="line-modified">2960 </span>
<span class="line-modified">2961   if (!_head-&gt;is_CountedLoop())</span>
<span class="line-modified">2962     return false;     // Dead loop</span>

2963   CountedLoopNode *cl = _head-&gt;as_CountedLoop();
<span class="line-modified">2964   if (!cl-&gt;is_valid_counted_loop())</span>
<span class="line-modified">2965     return false; // Malformed loop</span>
<span class="line-modified">2966   if (!phase-&gt;is_member(this, phase-&gt;get_ctrl(cl-&gt;loopexit()-&gt;in(CountedLoopEndNode::TestValue))))</span>
<span class="line-modified">2967     return false;             // Infinite loop</span>
<span class="line-modified">2968 </span>

2969   if (cl-&gt;is_pre_loop()) {
<span class="line-modified">2970     // If the loop we are removing is a pre-loop then the main and</span>
<span class="line-modified">2971     // post loop can be removed as well</span>
2972     remove_main_post_loops(cl, phase);
2973   }
2974 
2975 #ifdef ASSERT
2976   // Ensure only one phi which is the iv.
2977   Node* iv = NULL;
2978   for (DUIterator_Fast imax, i = cl-&gt;fast_outs(imax); i &lt; imax; i++) {
2979     Node* n = cl-&gt;fast_out(i);
2980     if (n-&gt;Opcode() == Op_Phi) {
<span class="line-modified">2981       assert(iv == NULL, &quot;Too many phis&quot; );</span>
2982       iv = n;
2983     }
2984   }
<span class="line-modified">2985   assert(iv == cl-&gt;phi(), &quot;Wrong phi&quot; );</span>
2986 #endif
2987 
2988   // main and post loops have explicitly created zero trip guard
2989   bool needs_guard = !cl-&gt;is_main_loop() &amp;&amp; !cl-&gt;is_post_loop();
2990   if (needs_guard) {
2991     // Skip guard if values not overlap.
2992     const TypeInt* init_t = phase-&gt;_igvn.type(cl-&gt;init_trip())-&gt;is_int();
2993     const TypeInt* limit_t = phase-&gt;_igvn.type(cl-&gt;limit())-&gt;is_int();
2994     int  stride_con = cl-&gt;stride_con();
2995     if (stride_con &gt; 0) {
2996       needs_guard = (init_t-&gt;_hi &gt;= limit_t-&gt;_lo);
2997     } else {
2998       needs_guard = (init_t-&gt;_lo &lt;= limit_t-&gt;_hi);
2999     }
3000   }
3001   if (needs_guard) {
3002     // Check for an obvious zero trip guard.
3003     Node* inctrl = PhaseIdealLoop::skip_all_loop_predicates(cl-&gt;skip_predicates());
3004     if (inctrl-&gt;Opcode() == Op_IfTrue || inctrl-&gt;Opcode() == Op_IfFalse) {
3005       bool maybe_swapped = (inctrl-&gt;Opcode() == Op_IfFalse);
</pre>
<hr />
<pre>
3034     tty-&gt;print(&quot;Empty with%s zero trip guard   &quot;, needs_guard ? &quot;out&quot; : &quot;&quot;);
3035     this-&gt;dump_head();
3036   }
3037 #endif
3038 
3039   if (needs_guard) {
3040     // Peel the loop to ensure there&#39;s a zero trip guard
3041     Node_List old_new;
3042     phase-&gt;do_peeling(this, old_new);
3043   }
3044 
3045   // Replace the phi at loop head with the final value of the last
3046   // iteration.  Then the CountedLoopEnd will collapse (backedge never
3047   // taken) and all loop-invariant uses of the exit values will be correct.
3048   Node *phi = cl-&gt;phi();
3049   Node *exact_limit = phase-&gt;exact_limit(this);
3050   if (exact_limit != cl-&gt;limit()) {
3051     // We also need to replace the original limit to collapse loop exit.
3052     Node* cmp = cl-&gt;loopexit()-&gt;cmp_node();
3053     assert(cl-&gt;limit() == cmp-&gt;in(2), &quot;sanity&quot;);







3054     phase-&gt;_igvn._worklist.push(cmp-&gt;in(2)); // put limit on worklist
3055     phase-&gt;_igvn.replace_input_of(cmp, 2, exact_limit); // put cmp on worklist
3056   }
3057   // Note: the final value after increment should not overflow since
3058   // counted loop has limit check predicate.
<span class="line-modified">3059   Node *final = new SubINode( exact_limit, cl-&gt;stride() );</span>
3060   phase-&gt;register_new_node(final,cl-&gt;in(LoopNode::EntryControl));
3061   phase-&gt;_igvn.replace_node(phi,final);
3062   phase-&gt;C-&gt;set_major_progress();
3063   return true;
3064 }
3065 
<span class="line-modified">3066 //------------------------------policy_do_one_iteration_loop-------------------</span>
3067 // Convert one iteration loop into normal code.
<span class="line-modified">3068 bool IdealLoopTree::policy_do_one_iteration_loop( PhaseIdealLoop *phase ) {</span>
<span class="line-modified">3069   if (!_head-&gt;as_Loop()-&gt;is_valid_counted_loop())</span>
3070     return false; // Only for counted loop
<span class="line-modified">3071 </span>
3072   CountedLoopNode *cl = _head-&gt;as_CountedLoop();
3073   if (!cl-&gt;has_exact_trip_count() || cl-&gt;trip_count() != 1) {
3074     return false;
3075   }
3076 
3077 #ifndef PRODUCT
<span class="line-modified">3078   if(TraceLoopOpts) {</span>
3079     tty-&gt;print(&quot;OneIteration &quot;);
3080     this-&gt;dump_head();
3081   }
3082 #endif
3083 
3084   Node *init_n = cl-&gt;init_trip();
3085 #ifdef ASSERT
3086   // Loop boundaries should be constant since trip count is exact.
3087   assert(init_n-&gt;get_int() + cl-&gt;stride_con() &gt;= cl-&gt;limit()-&gt;get_int(), &quot;should be one iteration&quot;);
3088 #endif
3089   // Replace the phi at loop head with the value of the init_trip.
3090   // Then the CountedLoopEnd will collapse (backedge will not be taken)
3091   // and all loop-invariant uses of the exit values will be correct.
3092   phase-&gt;_igvn.replace_node(cl-&gt;phi(), cl-&gt;init_trip());
3093   phase-&gt;C-&gt;set_major_progress();
3094   return true;
3095 }
3096 
3097 //=============================================================================
3098 //------------------------------iteration_split_impl---------------------------
<span class="line-modified">3099 bool IdealLoopTree::iteration_split_impl( PhaseIdealLoop *phase, Node_List &amp;old_new ) {</span>
3100   // Compute loop trip count if possible.
3101   compute_trip_count(phase);
3102 
3103   // Convert one iteration loop into normal code.
<span class="line-modified">3104   if (policy_do_one_iteration_loop(phase))</span>
3105     return true;
<span class="line-modified">3106 </span>
3107   // Check and remove empty loops (spam micro-benchmarks)
<span class="line-modified">3108   if (policy_do_remove_empty_loop(phase))</span>
3109     return true;  // Here we removed an empty loop

3110 
<span class="line-modified">3111   bool should_peel = policy_peeling(phase); // Should we peel?</span>
<span class="line-removed">3112 </span>
<span class="line-removed">3113   bool should_unswitch = policy_unswitching(phase);</span>
3114 
3115   // Non-counted loops may be peeled; exactly 1 iteration is peeled.
3116   // This removes loop-invariant tests (usually null checks).
3117   if (!_head-&gt;is_CountedLoop()) { // Non-counted loop
3118     if (PartialPeelLoop &amp;&amp; phase-&gt;partial_peel(this, old_new)) {
3119       // Partial peel succeeded so terminate this round of loop opts
3120       return false;
3121     }
<span class="line-modified">3122     if (should_peel) {            // Should we peel?</span>
3123       if (PrintOpto) { tty-&gt;print_cr(&quot;should_peel&quot;); }
<span class="line-modified">3124       phase-&gt;do_peeling(this,old_new);</span>
<span class="line-modified">3125     } else if (should_unswitch) {</span>
3126       phase-&gt;do_unswitching(this, old_new);
3127     }
3128     return true;
3129   }
3130   CountedLoopNode *cl = _head-&gt;as_CountedLoop();
3131 
3132   if (!cl-&gt;is_valid_counted_loop()) return true; // Ignore various kinds of broken loops
3133 
3134   // Do nothing special to pre- and post- loops
3135   if (cl-&gt;is_pre_loop() || cl-&gt;is_post_loop()) return true;
3136 
3137   // Compute loop trip count from profile data
3138   compute_profile_trip_cnt(phase);
3139 
3140   // Before attempting fancy unrolling, RCE or alignment, see if we want
3141   // to completely unroll this loop or do loop unswitching.
3142   if (cl-&gt;is_normal_loop()) {
<span class="line-modified">3143     if (should_unswitch) {</span>
3144       phase-&gt;do_unswitching(this, old_new);
3145       return true;
3146     }
<span class="line-modified">3147     bool should_maximally_unroll =  policy_maximally_unroll(phase);</span>
<span class="line-removed">3148     if (should_maximally_unroll) {</span>
3149       // Here we did some unrolling and peeling.  Eventually we will
3150       // completely unroll this loop and it will no longer be a loop.
<span class="line-modified">3151       phase-&gt;do_maximally_unroll(this,old_new);</span>
3152       return true;
3153     }
3154   }
3155 
<span class="line-modified">3156   // Skip next optimizations if running low on nodes. Note that</span>
<span class="line-modified">3157   // policy_unswitching and policy_maximally_unroll have this check.</span>
<span class="line-removed">3158   int nodes_left = phase-&gt;C-&gt;max_node_limit() - phase-&gt;C-&gt;live_nodes();</span>
<span class="line-removed">3159   if ((int)(2 * _body.size()) &gt; nodes_left) {</span>
<span class="line-removed">3160     return true;</span>
<span class="line-removed">3161   }</span>
3162 
3163   // Counted loops may be peeled, may need some iterations run up
3164   // front for RCE, and may want to align loop refs to a cache
3165   // line.  Thus we clone a full loop up front whose trip count is
3166   // at least 1 (if peeling), but may be several more.
3167 
3168   // The main loop will start cache-line aligned with at least 1
3169   // iteration of the unrolled body (zero-trip test required) and
3170   // will have some range checks removed.
3171 
3172   // A post-loop will finish any odd iterations (leftover after
3173   // unrolling), plus any needed for RCE purposes.
3174 
3175   bool should_unroll = policy_unroll(phase);



3176 
<span class="line-modified">3177   bool should_rce = policy_range_check(phase);</span>
<span class="line-modified">3178 </span>
<span class="line-modified">3179   bool should_align = policy_align(phase);</span>
<span class="line-removed">3180 </span>
<span class="line-removed">3181   // If not RCE&#39;ing (iteration splitting) or Aligning, then we do not</span>
<span class="line-removed">3182   // need a pre-loop.  We may still need to peel an initial iteration but</span>
<span class="line-removed">3183   // we will not be needing an unknown number of pre-iterations.</span>
3184   //
<span class="line-modified">3185   // Basically, if may_rce_align reports FALSE first time through,</span>
<span class="line-modified">3186   // we will not be able to later do RCE or Aligning on this loop.</span>
3187   bool may_rce_align = !policy_peel_only(phase) || should_rce || should_align;
3188 
3189   // If we have any of these conditions (RCE, alignment, unrolling) met, then
3190   // we switch to the pre-/main-/post-loop model.  This model also covers
3191   // peeling.
3192   if (should_rce || should_align || should_unroll) {
<span class="line-modified">3193     if (cl-&gt;is_normal_loop())  // Convert to &#39;pre/main/post&#39; loops</span>
<span class="line-modified">3194       phase-&gt;insert_pre_post_loops(this,old_new, !may_rce_align);</span>
<span class="line-modified">3195 </span>
<span class="line-modified">3196     // Adjust the pre- and main-loop limits to let the pre and post loops run</span>
<span class="line-modified">3197     // with full checks, but the main-loop with no checks.  Remove said</span>
<span class="line-modified">3198     // checks from the main body.</span>




3199     if (should_rce) {
3200       if (phase-&gt;do_range_check(this, old_new) != 0) {
3201         cl-&gt;mark_has_range_checks();
3202       }
3203     } else if (PostLoopMultiversioning) {
3204       phase-&gt;has_range_checks(this);
3205     }
3206 
3207     if (should_unroll &amp;&amp; !should_peel &amp;&amp; PostLoopMultiversioning) {
3208       // Try to setup multiversioning on main loops before they are unrolled
3209       if (cl-&gt;is_main_loop() &amp;&amp; (cl-&gt;unrolled_count() == 1)) {
3210         phase-&gt;insert_scalar_rced_post_loop(this, old_new);
3211       }
3212     }
3213 
3214     // Double loop body for unrolling.  Adjust the minimum-trip test (will do
3215     // twice as many iterations as before) and the main body limit (only do
3216     // an even number of trips).  If we are peeling, we might enable some RCE
3217     // and we&#39;d rather unroll the post-RCE&#39;d loop SO... do not unroll if
3218     // peeling.
3219     if (should_unroll &amp;&amp; !should_peel) {
3220       if (SuperWordLoopUnrollAnalysis) {
3221         phase-&gt;insert_vector_post_loop(this, old_new);
3222       }
3223       phase-&gt;do_unroll(this, old_new, true);
3224     }
3225 
<span class="line-modified">3226     // Adjust the pre-loop limits to align the main body</span>
<span class="line-modified">3227     // iterations.</span>
<span class="line-removed">3228     if (should_align)</span>
3229       Unimplemented();
<span class="line-modified">3230 </span>
3231   } else {                      // Else we have an unchanged counted loop
<span class="line-modified">3232     if (should_peel)           // Might want to peel but do nothing else</span>
<span class="line-modified">3233       phase-&gt;do_peeling(this,old_new);</span>



3234   }
3235   return true;
3236 }
3237 
3238 
3239 //=============================================================================
3240 //------------------------------iteration_split--------------------------------
<span class="line-modified">3241 bool IdealLoopTree::iteration_split( PhaseIdealLoop *phase, Node_List &amp;old_new ) {</span>
3242   // Recursively iteration split nested loops
<span class="line-modified">3243   if (_child &amp;&amp; !_child-&gt;iteration_split(phase, old_new))</span>
3244     return false;

3245 
3246   // Clean out prior deadwood
3247   DCE_loop_body();
3248 
<span class="line-removed">3249 </span>
3250   // Look for loop-exit tests with my 50/50 guesses from the Parsing stage.
3251   // Replace with a 1-in-10 exit guess.
<span class="line-modified">3252   if (_parent /*not the root loop*/ &amp;&amp;</span>
<span class="line-removed">3253       !_irreducible &amp;&amp;</span>
<span class="line-removed">3254       // Also ignore the occasional dead backedge</span>
<span class="line-removed">3255       !tail()-&gt;is_top()) {</span>
3256     adjust_loop_exit_prob(phase);
3257   }
3258 
<span class="line-modified">3259   // Gate unrolling, RCE and peeling efforts.</span>
<span class="line-modified">3260   if (!_child &amp;&amp;                // If not an inner loop, do not split</span>
<span class="line-removed">3261       !_irreducible &amp;&amp;</span>
<span class="line-removed">3262       _allow_optimizations &amp;&amp;</span>
<span class="line-removed">3263       !tail()-&gt;is_top()) {     // Also ignore the occasional dead backedge</span>
3264     if (!_has_call) {
<span class="line-modified">3265         if (!iteration_split_impl(phase, old_new)) {</span>
<span class="line-modified">3266           return false;</span>
<span class="line-modified">3267         }</span>
<span class="line-modified">3268     } else if (policy_unswitching(phase)) {</span>
<span class="line-modified">3269       phase-&gt;do_unswitching(this, old_new);</span>



3270     }
3271   }
3272 
3273   // Minor offset re-organization to remove loop-fallout uses of
3274   // trip counter when there was no major reshaping.
3275   phase-&gt;reorg_offsets(this);
3276 
<span class="line-modified">3277   if (_next &amp;&amp; !_next-&gt;iteration_split(phase, old_new))</span>
3278     return false;

3279   return true;
3280 }
3281 
3282 
3283 //=============================================================================
3284 // Process all the loops in the loop tree and replace any fill
3285 // patterns with an intrinsic version.
3286 bool PhaseIdealLoop::do_intrinsify_fill() {
3287   bool changed = false;
3288   for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {
3289     IdealLoopTree* lpt = iter.current();
3290     changed |= intrinsify_fill(lpt);
3291   }
3292   return changed;
3293 }
3294 
3295 
3296 // Examine an inner loop looking for a a single store of an invariant
3297 // value in a unit stride loop,
3298 bool PhaseIdealLoop::match_fill_loop(IdealLoopTree* lpt, Node*&amp; store, Node*&amp; store_value,
</pre>
<hr />
<pre>
3520     if (msg != NULL) {
3521       tty-&gt;print_cr(&quot;no fill intrinsic: %s&quot;, msg);
3522       if (msg_node != NULL) msg_node-&gt;dump();
3523     } else {
3524       tty-&gt;print_cr(&quot;fill intrinsic for:&quot;);
3525     }
3526     store-&gt;dump();
3527     if (Verbose) {
3528       lpt-&gt;_body.dump();
3529     }
3530   }
3531 #endif
3532 
3533   return msg == NULL;
3534 }
3535 
3536 
3537 
3538 bool PhaseIdealLoop::intrinsify_fill(IdealLoopTree* lpt) {
3539   // Only for counted inner loops
<span class="line-modified">3540   if (!lpt-&gt;is_counted() || !lpt-&gt;is_inner()) {</span>
3541     return false;
3542   }
3543 
3544   // Must have constant stride
3545   CountedLoopNode* head = lpt-&gt;_head-&gt;as_CountedLoop();
3546   if (!head-&gt;is_valid_counted_loop() || !head-&gt;is_normal_loop()) {
3547     return false;
3548   }
3549 
3550   head-&gt;verify_strip_mined(1);
3551 
3552   // Check that the body only contains a store of a loop invariant
3553   // value that is indexed by the loop phi.
3554   Node* store = NULL;
3555   Node* store_value = NULL;
3556   Node* shift = NULL;
3557   Node* offset = NULL;
3558   if (!match_fill_loop(lpt, store, store_value, shift, offset)) {
3559     return false;
3560   }
</pre>
</td>
<td>
<hr />
<pre>
  28 #include &quot;opto/addnode.hpp&quot;
  29 #include &quot;opto/callnode.hpp&quot;
  30 #include &quot;opto/castnode.hpp&quot;
  31 #include &quot;opto/connode.hpp&quot;
  32 #include &quot;opto/convertnode.hpp&quot;
  33 #include &quot;opto/divnode.hpp&quot;
  34 #include &quot;opto/loopnode.hpp&quot;
  35 #include &quot;opto/mulnode.hpp&quot;
  36 #include &quot;opto/movenode.hpp&quot;
  37 #include &quot;opto/opaquenode.hpp&quot;
  38 #include &quot;opto/rootnode.hpp&quot;
  39 #include &quot;opto/runtime.hpp&quot;
  40 #include &quot;opto/subnode.hpp&quot;
  41 #include &quot;opto/superword.hpp&quot;
  42 #include &quot;opto/vectornode.hpp&quot;
  43 
  44 //------------------------------is_loop_exit-----------------------------------
  45 // Given an IfNode, return the loop-exiting projection or NULL if both
  46 // arms remain in the loop.
  47 Node *IdealLoopTree::is_loop_exit(Node *iff) const {
<span class="line-modified">  48   if (iff-&gt;outcnt() != 2) return NULL;  // Ignore partially dead tests</span>
  49   PhaseIdealLoop *phase = _phase;
  50   // Test is an IfNode, has 2 projections.  If BOTH are in the loop
  51   // we need loop unswitching instead of peeling.
<span class="line-modified">  52   if (!is_member(phase-&gt;get_loop(iff-&gt;raw_out(0))))</span>
  53     return iff-&gt;raw_out(0);
<span class="line-modified">  54   if (!is_member(phase-&gt;get_loop(iff-&gt;raw_out(1))))</span>
  55     return iff-&gt;raw_out(1);
  56   return NULL;
  57 }
  58 
  59 
  60 //=============================================================================
  61 
  62 
  63 //------------------------------record_for_igvn----------------------------
  64 // Put loop body on igvn work list
  65 void IdealLoopTree::record_for_igvn() {
<span class="line-modified">  66   for (uint i = 0; i &lt; _body.size(); i++) {</span>
  67     Node *n = _body.at(i);
  68     _phase-&gt;_igvn._worklist.push(n);
  69   }
  70   // put body of outer strip mined loop on igvn work list as well
  71   if (_head-&gt;is_CountedLoop() &amp;&amp; _head-&gt;as_Loop()-&gt;is_strip_mined()) {
  72     CountedLoopNode* l = _head-&gt;as_CountedLoop();
  73     Node* outer_loop = l-&gt;outer_loop();
  74     assert(outer_loop != NULL, &quot;missing piece of strip mined loop&quot;);
  75     _phase-&gt;_igvn._worklist.push(outer_loop);
  76     Node* outer_loop_tail = l-&gt;outer_loop_tail();
  77     assert(outer_loop_tail != NULL, &quot;missing piece of strip mined loop&quot;);
  78     _phase-&gt;_igvn._worklist.push(outer_loop_tail);
  79     Node* outer_loop_end = l-&gt;outer_loop_end();
  80     assert(outer_loop_end != NULL, &quot;missing piece of strip mined loop&quot;);
  81     _phase-&gt;_igvn._worklist.push(outer_loop_end);
  82     Node* outer_safepoint = l-&gt;outer_safepoint();
  83     assert(outer_safepoint != NULL, &quot;missing piece of strip mined loop&quot;);
  84     _phase-&gt;_igvn._worklist.push(outer_safepoint);
  85     Node* cle_out = _head-&gt;as_CountedLoop()-&gt;loopexit()-&gt;proj_out(false);
  86     assert(cle_out != NULL, &quot;missing piece of strip mined loop&quot;);
</pre>
<hr />
<pre>
 128         cl-&gt;set_exact_trip_count((uint)trip_count);
 129       } else if (cl-&gt;unrolled_count() == 1) {
 130         // Set maximum trip count before unrolling.
 131         cl-&gt;set_trip_count((uint)trip_count);
 132       }
 133     }
 134   }
 135 }
 136 
 137 //------------------------------compute_profile_trip_cnt----------------------------
 138 // Compute loop trip count from profile data as
 139 //    (backedge_count + loop_exit_count) / loop_exit_count
 140 
 141 float IdealLoopTree::compute_profile_trip_cnt_helper(Node* n) {
 142   if (n-&gt;is_If()) {
 143     IfNode *iff = n-&gt;as_If();
 144     if (iff-&gt;_fcnt != COUNT_UNKNOWN &amp;&amp; iff-&gt;_prob != PROB_UNKNOWN) {
 145       Node *exit = is_loop_exit(iff);
 146       if (exit) {
 147         float exit_prob = iff-&gt;_prob;
<span class="line-modified"> 148         if (exit-&gt;Opcode() == Op_IfFalse) {</span>
<span class="line-added"> 149           exit_prob = 1.0 - exit_prob;</span>
<span class="line-added"> 150         }</span>
 151         if (exit_prob &gt; PROB_MIN) {
 152           float exit_cnt = iff-&gt;_fcnt * exit_prob;
 153           return exit_cnt;
 154         }
 155       }
 156     }
 157   }
 158   if (n-&gt;is_Jump()) {
 159     JumpNode *jmp = n-&gt;as_Jump();
 160     if (jmp-&gt;_fcnt != COUNT_UNKNOWN) {
 161       float* probs = jmp-&gt;_probs;
 162       float exit_prob = 0;
 163       PhaseIdealLoop *phase = _phase;
 164       for (DUIterator_Fast imax, i = jmp-&gt;fast_outs(imax); i &lt; imax; i++) {
 165         JumpProjNode* u = jmp-&gt;fast_out(i)-&gt;as_JumpProj();
 166         if (!is_member(_phase-&gt;get_loop(u))) {
 167           exit_prob += probs[u-&gt;_con];
 168         }
 169       }
 170       return exit_prob * jmp-&gt;_fcnt;
</pre>
<hr />
<pre>
 187   while (back != head) {
 188     if ((back-&gt;Opcode() == Op_IfTrue || back-&gt;Opcode() == Op_IfFalse) &amp;&amp;
 189         back-&gt;in(0) &amp;&amp;
 190         back-&gt;in(0)-&gt;is_If() &amp;&amp;
 191         back-&gt;in(0)-&gt;as_If()-&gt;_fcnt != COUNT_UNKNOWN &amp;&amp;
 192         back-&gt;in(0)-&gt;as_If()-&gt;_prob != PROB_UNKNOWN &amp;&amp;
 193         (back-&gt;Opcode() == Op_IfTrue ? 1-back-&gt;in(0)-&gt;as_If()-&gt;_prob : back-&gt;in(0)-&gt;as_If()-&gt;_prob) &gt; PROB_MIN) {
 194       break;
 195     }
 196     back = phase-&gt;idom(back);
 197   }
 198   if (back != head) {
 199     assert((back-&gt;Opcode() == Op_IfTrue || back-&gt;Opcode() == Op_IfFalse) &amp;&amp;
 200            back-&gt;in(0), &quot;if-projection exists&quot;);
 201     IfNode* back_if = back-&gt;in(0)-&gt;as_If();
 202     float loop_back_cnt = back_if-&gt;_fcnt * (back-&gt;Opcode() == Op_IfTrue ? back_if-&gt;_prob : (1 - back_if-&gt;_prob));
 203 
 204     // Now compute a loop exit count
 205     float loop_exit_cnt = 0.0f;
 206     if (_child == NULL) {
<span class="line-modified"> 207       for (uint i = 0; i &lt; _body.size(); i++) {</span>
 208         Node *n = _body[i];
 209         loop_exit_cnt += compute_profile_trip_cnt_helper(n);
 210       }
 211     } else {
 212       ResourceMark rm;
 213       Unique_Node_List wq;
 214       wq.push(back);
 215       for (uint i = 0; i &lt; wq.size(); i++) {
 216         Node *n = wq.at(i);
 217         assert(n-&gt;is_CFG(), &quot;only control nodes&quot;);
 218         if (n != head) {
 219           if (n-&gt;is_Region()) {
 220             for (uint j = 1; j &lt; n-&gt;req(); j++) {
 221               wq.push(n-&gt;in(j));
 222             }
 223           } else {
 224             loop_exit_cnt += compute_profile_trip_cnt_helper(n);
 225             wq.push(n-&gt;in(0));
 226           }
 227         }
</pre>
<hr />
<pre>
 269 // (x + inv2) - inv1  =&gt;  (-inv1 + inv2) + x
 270 // (x - inv2) + inv1  =&gt;  ( inv1 - inv2) + x
 271 // (x - inv2) - inv1  =&gt;  (-inv1 - inv2) + x
 272 // inv1 + (inv2 - x)  =&gt;  ( inv1 + inv2) - x
 273 // inv1 - (x - inv2)  =&gt;  ( inv1 + inv2) - x
 274 // (inv2 - x) + inv1  =&gt;  ( inv1 + inv2) - x
 275 // (inv2 - x) - inv1  =&gt;  (-inv1 + inv2) - x
 276 // inv1 - (x + inv2)  =&gt;  ( inv1 - inv2) - x
 277 //
 278 Node* IdealLoopTree::reassociate_add_sub(Node* n1, PhaseIdealLoop *phase) {
 279   if ((!n1-&gt;is_Add() &amp;&amp; !n1-&gt;is_Sub()) || n1-&gt;outcnt() == 0) return NULL;
 280   if (is_invariant(n1)) return NULL;
 281   int inv1_idx = is_invariant_addition(n1, phase);
 282   if (!inv1_idx) return NULL;
 283   // Don&#39;t mess with add of constant (igvn moves them to expression tree root.)
 284   if (n1-&gt;is_Add() &amp;&amp; n1-&gt;in(2)-&gt;is_Con()) return NULL;
 285   Node* inv1 = n1-&gt;in(inv1_idx);
 286   Node* n2 = n1-&gt;in(3 - inv1_idx);
 287   int inv2_idx = is_invariant_addition(n2, phase);
 288   if (!inv2_idx) return NULL;
<span class="line-added"> 289 </span>
<span class="line-added"> 290   if (!phase-&gt;may_require_nodes(10, 10)) return NULL;</span>
<span class="line-added"> 291 </span>
 292   Node* x    = n2-&gt;in(3 - inv2_idx);
 293   Node* inv2 = n2-&gt;in(inv2_idx);
 294 
 295   bool neg_x    = n2-&gt;is_Sub() &amp;&amp; inv2_idx == 1;
 296   bool neg_inv2 = n2-&gt;is_Sub() &amp;&amp; inv2_idx == 2;
 297   bool neg_inv1 = n1-&gt;is_Sub() &amp;&amp; inv1_idx == 2;
 298   if (n1-&gt;is_Sub() &amp;&amp; inv1_idx == 1) {
 299     neg_x    = !neg_x;
 300     neg_inv2 = !neg_inv2;
 301   }
 302   Node* inv1_c = phase-&gt;get_ctrl(inv1);
 303   Node* inv2_c = phase-&gt;get_ctrl(inv2);
 304   Node* n_inv1;
 305   if (neg_inv1) {
 306     Node *zero = phase-&gt;_igvn.intcon(0);
 307     phase-&gt;set_ctrl(zero, phase-&gt;C-&gt;root());
 308     n_inv1 = new SubINode(zero, inv1);
 309     phase-&gt;register_new_node(n_inv1, inv1_c);
 310   } else {
 311     n_inv1 = inv1;
</pre>
<hr />
<pre>
 323     addx = new SubINode(inv, x);
 324   } else {
 325     addx = new AddINode(x, inv);
 326   }
 327   phase-&gt;register_new_node(addx, phase-&gt;get_ctrl(x));
 328   phase-&gt;_igvn.replace_node(n1, addx);
 329   assert(phase-&gt;get_loop(phase-&gt;get_ctrl(n1)) == this, &quot;&quot;);
 330   _body.yank(n1);
 331   return addx;
 332 }
 333 
 334 //---------------------reassociate_invariants-----------------------------
 335 // Reassociate invariant expressions:
 336 void IdealLoopTree::reassociate_invariants(PhaseIdealLoop *phase) {
 337   for (int i = _body.size() - 1; i &gt;= 0; i--) {
 338     Node *n = _body.at(i);
 339     for (int j = 0; j &lt; 5; j++) {
 340       Node* nn = reassociate_add_sub(n, phase);
 341       if (nn == NULL) break;
 342       n = nn; // again
<span class="line-modified"> 343     }</span>
 344   }
 345 }
 346 
 347 //------------------------------policy_peeling---------------------------------
<span class="line-modified"> 348 // Return TRUE if the loop should be peeled, otherwise return FALSE. Peeling</span>
<span class="line-modified"> 349 // is applicable if we can make a loop-invariant test (usually a null-check)</span>
<span class="line-modified"> 350 // execute before we enter the loop. When TRUE, the estimated node budget is</span>
<span class="line-modified"> 351 // also requested.</span>
<span class="line-modified"> 352 bool IdealLoopTree::policy_peeling(PhaseIdealLoop *phase) {</span>
<span class="line-modified"> 353   uint estimate = estimate_peeling(phase);</span>
<span class="line-modified"> 354 </span>
<span class="line-modified"> 355   return estimate == 0 ? false : phase-&gt;may_require_nodes(estimate);</span>
<span class="line-modified"> 356 }</span>
<span class="line-added"> 357 </span>
<span class="line-added"> 358 // Perform actual policy and size estimate for the loop peeling transform, and</span>
<span class="line-added"> 359 // return the estimated loop size if peeling is applicable, otherwise return</span>
<span class="line-added"> 360 // zero. No node budget is allocated.</span>
<span class="line-added"> 361 uint IdealLoopTree::estimate_peeling(PhaseIdealLoop *phase) {</span>
<span class="line-added"> 362 </span>
<span class="line-added"> 363   // If nodes are depleted, some transform has miscalculated its needs.</span>
<span class="line-added"> 364   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);</span>
<span class="line-added"> 365 </span>
<span class="line-added"> 366   // Peeling does loop cloning which can result in O(N^2) node construction.</span>
<span class="line-added"> 367   if (_body.size() &gt; 255) {</span>
<span class="line-added"> 368     return 0;   // Suppress too large body size.</span>
 369   }
<span class="line-added"> 370   // Optimistic estimate that approximates loop body complexity via data and</span>
<span class="line-added"> 371   // control flow fan-out (instead of using the more pessimistic: BodySize^2).</span>
<span class="line-added"> 372   uint estimate = est_loop_clone_sz(2);</span>
 373 
<span class="line-modified"> 374   if (phase-&gt;exceeding_node_budget(estimate)) {</span>
<span class="line-modified"> 375     return 0;   // Too large to safely clone.</span>
<span class="line-added"> 376   }</span>
 377 
<span class="line-modified"> 378   // Check for vectorized loops, any peeling done was already applied.</span>
<span class="line-modified"> 379   if (_head-&gt;is_CountedLoop()) {</span>
<span class="line-added"> 380     CountedLoopNode* cl = _head-&gt;as_CountedLoop();</span>
<span class="line-added"> 381     if (cl-&gt;is_unroll_only() || cl-&gt;trip_count() == 1) {</span>
<span class="line-added"> 382       return 0;</span>
<span class="line-added"> 383     }</span>
 384   }
 385 
<span class="line-modified"> 386   Node* test = tail();</span>
<span class="line-modified"> 387 </span>
<span class="line-added"> 388   while (test != _head) {   // Scan till run off top of loop</span>
<span class="line-added"> 389     if (test-&gt;is_If()) {    // Test?</span>
 390       Node *ctrl = phase-&gt;get_ctrl(test-&gt;in(1));
<span class="line-modified"> 391       if (ctrl-&gt;is_top()) {</span>
<span class="line-modified"> 392         return 0;           // Found dead test on live IF?  No peeling!</span>
<span class="line-modified"> 393       }</span>
<span class="line-modified"> 394       // Standard IF only has one input value to check for loop invariance.</span>
<span class="line-added"> 395       assert(test-&gt;Opcode() == Op_If ||</span>
<span class="line-added"> 396              test-&gt;Opcode() == Op_CountedLoopEnd ||</span>
<span class="line-added"> 397              test-&gt;Opcode() == Op_RangeCheck,</span>
<span class="line-added"> 398              &quot;Check this code when new subtype is added&quot;);</span>
 399       // Condition is not a member of this loop?
<span class="line-modified"> 400       if (!is_member(phase-&gt;get_loop(ctrl)) &amp;&amp; is_loop_exit(test)) {</span>
<span class="line-modified"> 401         return estimate;    // Found reason to peel!</span>
<span class="line-modified"> 402       }</span>
 403     }
<span class="line-modified"> 404     // Walk up dominators to loop _head looking for test which is executed on</span>
<span class="line-modified"> 405     // every path through the loop.</span>
 406     test = phase-&gt;idom(test);
 407   }
<span class="line-modified"> 408   return 0;</span>
 409 }
 410 
 411 //------------------------------peeled_dom_test_elim---------------------------
 412 // If we got the effect of peeling, either by actually peeling or by making
 413 // a pre-loop which must execute at least once, we can remove all
 414 // loop-invariant dominated tests in the main body.
<span class="line-modified"> 415 void PhaseIdealLoop::peeled_dom_test_elim(IdealLoopTree *loop, Node_List &amp;old_new) {</span>
 416   bool progress = true;
<span class="line-modified"> 417   while (progress) {</span>
 418     progress = false;           // Reset for next iteration
 419     Node *prev = loop-&gt;_head-&gt;in(LoopNode::LoopBackControl);//loop-&gt;tail();
 420     Node *test = prev-&gt;in(0);
<span class="line-modified"> 421     while (test != loop-&gt;_head) { // Scan till run off top of loop</span>
 422 
 423       int p_op = prev-&gt;Opcode();
<span class="line-modified"> 424       if ((p_op == Op_IfFalse || p_op == Op_IfTrue) &amp;&amp;</span>
 425           test-&gt;is_If() &amp;&amp;      // Test?
 426           !test-&gt;in(1)-&gt;is_Con() &amp;&amp; // And not already obvious?
 427           // Condition is not a member of this loop?
 428           !loop-&gt;is_member(get_loop(get_ctrl(test-&gt;in(1))))){
 429         // Walk loop body looking for instances of this test
<span class="line-modified"> 430         for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {</span>
 431           Node *n = loop-&gt;_body.at(i);
<span class="line-modified"> 432           if (n-&gt;is_If() &amp;&amp; n-&gt;in(1) == test-&gt;in(1) /*&amp;&amp; n != loop-&gt;tail()-&gt;in(0)*/) {</span>
 433             // IfNode was dominated by version in peeled loop body
 434             progress = true;
<span class="line-modified"> 435             dominated_by(old_new[prev-&gt;_idx], n);</span>
 436           }
 437         }
 438       }
 439       prev = test;
 440       test = idom(test);
 441     } // End of scan tests in loop
 442 
<span class="line-modified"> 443   } // End of while (progress)</span>
 444 }
 445 
 446 //------------------------------do_peeling-------------------------------------
 447 // Peel the first iteration of the given loop.
 448 // Step 1: Clone the loop body.  The clone becomes the peeled iteration.
 449 //         The pre-loop illegally has 2 control users (old &amp; new loops).
 450 // Step 2: Make the old-loop fall-in edges point to the peeled iteration.
 451 //         Do this by making the old-loop fall-in edges act as if they came
 452 //         around the loopback from the prior iteration (follow the old-loop
 453 //         backedges) and then map to the new peeled iteration.  This leaves
 454 //         the pre-loop with only 1 user (the new peeled iteration), but the
 455 //         peeled-loop backedge has 2 users.
 456 // Step 3: Cut the backedge on the clone (so its not a loop) and remove the
 457 //         extra backedge user.
 458 //
 459 //                   orig
 460 //
 461 //                  stmt1
 462 //                    |
 463 //                    v
</pre>
<hr />
<pre>
 564 //             | loop predicate
 565 //             |      |
 566 //             |      v
 567 //             |     loop&lt;----+
 568 //             |      |       |
 569 //             |    stmt2     |
 570 //             |      |       |
 571 //             |      v       |
 572 //             v      if      ^
 573 //             |     /  \     |
 574 //             |    /    \    |
 575 //             |   v     v    |
 576 //             | false  true  |
 577 //             |  |        \  |
 578 //             v  v         --+
 579 //            region
 580 //              |
 581 //              v
 582 //             exit
 583 //
<span class="line-modified"> 584 void PhaseIdealLoop::do_peeling(IdealLoopTree *loop, Node_List &amp;old_new) {</span>
 585 
 586   C-&gt;set_major_progress();
 587   // Peeling a &#39;main&#39; loop in a pre/main/post situation obfuscates the
 588   // &#39;pre&#39; loop from the main and the &#39;pre&#39; can no longer have its
 589   // iterations adjusted.  Therefore, we need to declare this loop as
 590   // no longer a &#39;main&#39; loop; it will need new pre and post loops before
 591   // we can do further RCE.
 592 #ifndef PRODUCT
 593   if (TraceLoopOpts) {
 594     tty-&gt;print(&quot;Peel         &quot;);
 595     loop-&gt;dump_head();
 596   }
 597 #endif
 598   LoopNode* head = loop-&gt;_head-&gt;as_Loop();
 599   bool counted_loop = head-&gt;is_CountedLoop();
 600   if (counted_loop) {
 601     CountedLoopNode *cl = head-&gt;as_CountedLoop();
 602     assert(cl-&gt;trip_count() &gt; 0, &quot;peeling a fully unrolled loop&quot;);
 603     cl-&gt;set_trip_count(cl-&gt;trip_count() - 1);
 604     if (cl-&gt;is_main_loop()) {
</pre>
<hr />
<pre>
 613   }
 614   Node* entry = head-&gt;in(LoopNode::EntryControl);
 615 
 616   // Step 1: Clone the loop body.  The clone becomes the peeled iteration.
 617   //         The pre-loop illegally has 2 control users (old &amp; new loops).
 618   clone_loop(loop, old_new, dom_depth(head-&gt;skip_strip_mined()), ControlAroundStripMined);
 619 
 620   // Step 2: Make the old-loop fall-in edges point to the peeled iteration.
 621   //         Do this by making the old-loop fall-in edges act as if they came
 622   //         around the loopback from the prior iteration (follow the old-loop
 623   //         backedges) and then map to the new peeled iteration.  This leaves
 624   //         the pre-loop with only 1 user (the new peeled iteration), but the
 625   //         peeled-loop backedge has 2 users.
 626   Node* new_entry = old_new[head-&gt;in(LoopNode::LoopBackControl)-&gt;_idx];
 627   _igvn.hash_delete(head-&gt;skip_strip_mined());
 628   head-&gt;skip_strip_mined()-&gt;set_req(LoopNode::EntryControl, new_entry);
 629   for (DUIterator_Fast jmax, j = head-&gt;fast_outs(jmax); j &lt; jmax; j++) {
 630     Node* old = head-&gt;fast_out(j);
 631     if (old-&gt;in(0) == loop-&gt;_head &amp;&amp; old-&gt;req() == 3 &amp;&amp; old-&gt;is_Phi()) {
 632       Node* new_exit_value = old_new[old-&gt;in(LoopNode::LoopBackControl)-&gt;_idx];
<span class="line-modified"> 633       if (!new_exit_value)     // Backedge value is ALSO loop invariant?</span>
 634         // Then loop body backedge value remains the same.
 635         new_exit_value = old-&gt;in(LoopNode::LoopBackControl);
 636       _igvn.hash_delete(old);
 637       old-&gt;set_req(LoopNode::EntryControl, new_exit_value);
 638     }
 639   }
 640 
 641 
 642   // Step 3: Cut the backedge on the clone (so its not a loop) and remove the
 643   //         extra backedge user.
 644   Node* new_head = old_new[head-&gt;_idx];
 645   _igvn.hash_delete(new_head);
 646   new_head-&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
 647   for (DUIterator_Fast j2max, j2 = new_head-&gt;fast_outs(j2max); j2 &lt; j2max; j2++) {
 648     Node* use = new_head-&gt;fast_out(j2);
 649     if (use-&gt;in(0) == new_head &amp;&amp; use-&gt;req() == 3 &amp;&amp; use-&gt;is_Phi()) {
 650       _igvn.hash_delete(use);
 651       use-&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
 652     }
 653   }
 654 

 655   // Step 4: Correct dom-depth info.  Set to loop-head depth.
<span class="line-modified"> 656 </span>
<span class="line-modified"> 657   int dd = dom_depth(head-&gt;skip_strip_mined());</span>
<span class="line-added"> 658   set_idom(head-&gt;skip_strip_mined(), head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl), dd);</span>
 659   for (uint j3 = 0; j3 &lt; loop-&gt;_body.size(); j3++) {
 660     Node *old = loop-&gt;_body.at(j3);
 661     Node *nnn = old_new[old-&gt;_idx];
<span class="line-modified"> 662     if (!has_ctrl(nnn)) {</span>
 663       set_idom(nnn, idom(nnn), dd-1);
<span class="line-added"> 664     }</span>
 665   }
 666 
 667   // Now force out all loop-invariant dominating tests.  The optimizer
 668   // finds some, but we _know_ they are all useless.
 669   peeled_dom_test_elim(loop,old_new);
 670 
 671   loop-&gt;record_for_igvn();
 672 }
 673 


 674 //------------------------------policy_maximally_unroll------------------------
<span class="line-modified"> 675 // Calculate the exact  loop trip-count and return TRUE if loop can be fully,</span>
<span class="line-modified"> 676 // i.e. maximally, unrolled, otherwise return FALSE. When TRUE, the estimated</span>
<span class="line-modified"> 677 // node budget is also requested.</span>
<span class="line-modified"> 678 bool IdealLoopTree::policy_maximally_unroll(PhaseIdealLoop* phase) const {</span>
<span class="line-added"> 679   CountedLoopNode* cl = _head-&gt;as_CountedLoop();</span>
 680   assert(cl-&gt;is_normal_loop(), &quot;&quot;);
<span class="line-modified"> 681   if (!cl-&gt;is_valid_counted_loop()) {</span>
<span class="line-modified"> 682     return false;   // Malformed counted loop.</span>
<span class="line-modified"> 683   }</span>
 684   if (!cl-&gt;has_exact_trip_count()) {
<span class="line-modified"> 685     return false;   // Trip count is not exact.</span>

 686   }
 687 
 688   uint trip_count = cl-&gt;trip_count();
 689   // Note, max_juint is used to indicate unknown trip count.
 690   assert(trip_count &gt; 1, &quot;one iteration loop should be optimized out already&quot;);
<span class="line-modified"> 691   assert(trip_count &lt; max_juint, &quot;exact trip_count should be less than max_juint.&quot;);</span>
 692 
<span class="line-modified"> 693   // If nodes are depleted, some transform has miscalculated its needs.</span>
<span class="line-modified"> 694   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);</span>
<span class="line-modified"> 695 </span>
<span class="line-modified"> 696   // Allow the unrolled body to get larger than the standard loop size limit.</span>
 697   uint unroll_limit = (uint)LoopUnrollLimit * 4;
<span class="line-modified"> 698   assert((intx)unroll_limit == LoopUnrollLimit * 4, &quot;LoopUnrollLimit must fit in 32bits&quot;);</span>
<span class="line-modified"> 699   if (trip_count &gt; unroll_limit || _body.size() &gt; unroll_limit) {</span>
 700     return false;
 701   }
 702 
<span class="line-modified"> 703   uint new_body_size = est_loop_unroll_sz(trip_count);</span>




 704 
<span class="line-modified"> 705   if (new_body_size == UINT_MAX) { // Check for bad estimate (overflow).</span>




 706     return false;
<span class="line-modified"> 707   }</span>
<span class="line-modified"> 708 </span>
<span class="line-modified"> 709   // Fully unroll a loop with few iterations, regardless of other conditions,</span>
<span class="line-added"> 710   // since the following (general) loop optimizations will split such loop in</span>
<span class="line-added"> 711   // any case (into pre-main-post).</span>
<span class="line-added"> 712   if (trip_count &lt;= 3) {</span>
<span class="line-added"> 713     return phase-&gt;may_require_nodes(new_body_size);</span>
<span class="line-added"> 714   }</span>
<span class="line-added"> 715 </span>
<span class="line-added"> 716   // Reject if unrolling will result in too much node construction.</span>
<span class="line-added"> 717   if (new_body_size &gt; unroll_limit || phase-&gt;exceeding_node_budget(new_body_size)) {</span>
 718     return false;
 719   }
 720 
 721   // Do not unroll a loop with String intrinsics code.
 722   // String intrinsics are large and have loops.
 723   for (uint k = 0; k &lt; _body.size(); k++) {
 724     Node* n = _body.at(k);
 725     switch (n-&gt;Opcode()) {
 726       case Op_StrComp:
 727       case Op_StrEquals:
 728       case Op_StrIndexOf:
 729       case Op_StrIndexOfChar:
 730       case Op_EncodeISOArray:
 731       case Op_AryEq:
 732       case Op_HasNegatives: {
 733         return false;
 734       }
 735 #if INCLUDE_RTM_OPT
 736       case Op_FastLock:
 737       case Op_FastUnlock: {
 738         // Don&#39;t unroll RTM locking code because it is large.
 739         if (UseRTMLocking) {
 740           return false;
 741         }
 742       }
 743 #endif
 744     } // switch
 745   }
 746 
<span class="line-modified"> 747   return phase-&gt;may_require_nodes(new_body_size);</span>
 748 }
 749 
 750 
 751 //------------------------------policy_unroll----------------------------------
<span class="line-modified"> 752 // Return TRUE or FALSE if the loop should be unrolled or not. Apply unroll if</span>
<span class="line-modified"> 753 // the loop is  a counted loop and  the loop body is small  enough. When TRUE,</span>
<span class="line-added"> 754 // the estimated node budget is also requested.</span>
 755 bool IdealLoopTree::policy_unroll(PhaseIdealLoop *phase) {
 756 
 757   CountedLoopNode *cl = _head-&gt;as_CountedLoop();
 758   assert(cl-&gt;is_normal_loop() || cl-&gt;is_main_loop(), &quot;&quot;);
 759 
<span class="line-modified"> 760   if (!cl-&gt;is_valid_counted_loop()) {</span>
 761     return false; // Malformed counted loop
<span class="line-added"> 762   }</span>
<span class="line-added"> 763 </span>
<span class="line-added"> 764   // If nodes are depleted, some transform has miscalculated its needs.</span>
<span class="line-added"> 765   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);</span>
 766 
 767   // Protect against over-unrolling.
 768   // After split at least one iteration will be executed in pre-loop.
<span class="line-modified"> 769   if (cl-&gt;trip_count() &lt;= (cl-&gt;is_normal_loop() ? 2u : 1u)) {</span>
<span class="line-modified"> 770     return false;</span>
<span class="line-modified"> 771   }</span>
<span class="line-added"> 772   _local_loop_unroll_limit  = LoopUnrollLimit;</span>
 773   _local_loop_unroll_factor = 4;
<span class="line-modified"> 774   int future_unroll_cnt = cl-&gt;unrolled_count() * 2;</span>
 775   if (!cl-&gt;is_vectorized_loop()) {
<span class="line-modified"> 776     if (future_unroll_cnt &gt; LoopMaxUnroll) return false;</span>
 777   } else {
 778     // obey user constraints on vector mapped loops with additional unrolling applied
 779     int unroll_constraint = (cl-&gt;slp_max_unroll()) ? cl-&gt;slp_max_unroll() : 1;
<span class="line-modified"> 780     if ((future_unroll_cnt / unroll_constraint) &gt; LoopMaxUnroll) return false;</span>
 781   }
 782 
 783   // Check for initial stride being a small enough constant
<span class="line-modified"> 784   if (abs(cl-&gt;stride_con()) &gt; (1&lt;&lt;2)*future_unroll_cnt) return false;</span>
 785 
 786   // Don&#39;t unroll if the next round of unrolling would push us
 787   // over the expected trip count of the loop.  One is subtracted
 788   // from the expected trip count because the pre-loop normally
 789   // executes 1 iteration.
 790   if (UnrollLimitForProfileCheck &gt; 0 &amp;&amp;
 791       cl-&gt;profile_trip_cnt() != COUNT_UNKNOWN &amp;&amp;
<span class="line-modified"> 792       future_unroll_cnt        &gt; UnrollLimitForProfileCheck &amp;&amp;</span>
<span class="line-modified"> 793       (float)future_unroll_cnt &gt; cl-&gt;profile_trip_cnt() - 1.0) {</span>
 794     return false;
 795   }
 796 
 797   // When unroll count is greater than LoopUnrollMin, don&#39;t unroll if:
 798   //   the residual iterations are more than 10% of the trip count
 799   //   and rounds of &quot;unroll,optimize&quot; are not making significant progress
 800   //   Progress defined as current size less than 20% larger than previous size.
 801   if (UseSuperWord &amp;&amp; cl-&gt;node_count_before_unroll() &gt; 0 &amp;&amp;
<span class="line-modified"> 802       future_unroll_cnt &gt; LoopUnrollMin &amp;&amp;</span>
<span class="line-modified"> 803       (future_unroll_cnt - 1) * (100 / LoopPercentProfileLimit) &gt; cl-&gt;profile_trip_cnt() &amp;&amp;</span>
 804       1.2 * cl-&gt;node_count_before_unroll() &lt; (double)_body.size()) {
 805     return false;
 806   }
 807 
 808   Node *init_n = cl-&gt;init_trip();
 809   Node *limit_n = cl-&gt;limit();
 810   int stride_con = cl-&gt;stride_con();
 811   if (limit_n == NULL) return false; // We will dereference it below.
 812 
 813   // Non-constant bounds.
 814   // Protect against over-unrolling when init or/and limit are not constant
 815   // (so that trip_count&#39;s init value is maxint) but iv range is known.
 816   if (init_n == NULL || !init_n-&gt;is_Con() || !limit_n-&gt;is_Con()) {
 817     Node* phi = cl-&gt;phi();
 818     if (phi != NULL) {
 819       assert(phi-&gt;is_Phi() &amp;&amp; phi-&gt;in(0) == _head, &quot;Counted loop should have iv phi.&quot;);
 820       const TypeInt* iv_type = phase-&gt;_igvn.type(phi)-&gt;is_int();
 821       int next_stride = stride_con * 2; // stride after this unroll
 822       if (next_stride &gt; 0) {
 823         if (iv_type-&gt;_lo + next_stride &lt;= iv_type-&gt;_lo || // overflow
</pre>
<hr />
<pre>
 867       case Op_FastLock:
 868       case Op_FastUnlock: {
 869         // Don&#39;t unroll RTM locking code because it is large.
 870         if (UseRTMLocking) {
 871           return false;
 872         }
 873       }
 874 #endif
 875     } // switch
 876   }
 877 
 878   if (UseSuperWord) {
 879     if (!cl-&gt;is_reduction_loop()) {
 880       phase-&gt;mark_reductions(this);
 881     }
 882 
 883     // Only attempt slp analysis when user controls do not prohibit it
 884     if (LoopMaxUnroll &gt; _local_loop_unroll_factor) {
 885       // Once policy_slp_analysis succeeds, mark the loop with the
 886       // maximal unroll factor so that we minimize analysis passes
<span class="line-modified"> 887       if (future_unroll_cnt &gt;= _local_loop_unroll_factor) {</span>
<span class="line-modified"> 888         policy_unroll_slp_analysis(cl, phase, future_unroll_cnt);</span>
 889       }
 890     }
 891   }
 892 
 893   int slp_max_unroll_factor = cl-&gt;slp_max_unroll();
 894   if ((LoopMaxUnroll &lt; slp_max_unroll_factor) &amp;&amp; FLAG_IS_DEFAULT(LoopMaxUnroll) &amp;&amp; UseSubwordForMaxVector) {
 895     LoopMaxUnroll = slp_max_unroll_factor;
 896   }
<span class="line-added"> 897 </span>
<span class="line-added"> 898   uint estimate = est_loop_clone_sz(2);</span>
<span class="line-added"> 899 </span>
 900   if (cl-&gt;has_passed_slp()) {
<span class="line-modified"> 901     if (slp_max_unroll_factor &gt;= future_unroll_cnt) {</span>
<span class="line-modified"> 902       return phase-&gt;may_require_nodes(estimate);</span>
<span class="line-modified"> 903     }</span>
<span class="line-added"> 904     return false; // Loop too big.</span>
 905   }
 906 
 907   // Check for being too big
 908   if (body_size &gt; (uint)_local_loop_unroll_limit) {
<span class="line-modified"> 909     if ((cl-&gt;is_subword_loop() || xors_in_loop &gt;= 4) &amp;&amp; body_size &lt; 4u * LoopUnrollLimit) {</span>
<span class="line-modified"> 910       return phase-&gt;may_require_nodes(estimate);</span>
 911     }
<span class="line-modified"> 912     return false; // Loop too big.</span>

 913   }
 914 
<span class="line-modified"> 915   if (cl-&gt;is_unroll_only()) {</span>
 916     if (TraceSuperWordLoopUnrollAnalysis) {
<span class="line-modified"> 917       tty-&gt;print_cr(&quot;policy_unroll passed vector loop(vlen=%d, factor=%d)\n&quot;,</span>
<span class="line-added"> 918                     slp_max_unroll_factor, future_unroll_cnt);</span>
 919     }
 920   }
 921 
 922   // Unroll once!  (Each trip will soon do double iterations)
<span class="line-modified"> 923   return phase-&gt;may_require_nodes(estimate);</span>
 924 }
 925 
<span class="line-modified"> 926 void IdealLoopTree::policy_unroll_slp_analysis(CountedLoopNode *cl, PhaseIdealLoop *phase, int future_unroll_cnt) {</span>
<span class="line-added"> 927 </span>
<span class="line-added"> 928   // If nodes are depleted, some transform has miscalculated its needs.</span>
<span class="line-added"> 929   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);</span>
<span class="line-added"> 930 </span>
 931   // Enable this functionality target by target as needed
 932   if (SuperWordLoopUnrollAnalysis) {
 933     if (!cl-&gt;was_slp_analyzed()) {
 934       SuperWord sw(phase);
 935       sw.transform_loop(this, false);
 936 
 937       // If the loop is slp canonical analyze it
 938       if (sw.early_return() == false) {
 939         sw.unrolling_analysis(_local_loop_unroll_factor);
 940       }
 941     }
 942 
 943     if (cl-&gt;has_passed_slp()) {
 944       int slp_max_unroll_factor = cl-&gt;slp_max_unroll();
<span class="line-modified"> 945       if (slp_max_unroll_factor &gt;= future_unroll_cnt) {</span>
 946         int new_limit = cl-&gt;node_count_before_unroll() * slp_max_unroll_factor;
 947         if (new_limit &gt; LoopUnrollLimit) {
 948           if (TraceSuperWordLoopUnrollAnalysis) {
 949             tty-&gt;print_cr(&quot;slp analysis unroll=%d, default limit=%d\n&quot;, new_limit, _local_loop_unroll_limit);
 950           }
 951           _local_loop_unroll_limit = new_limit;
 952         }
 953       }
 954     }
 955   }
 956 }
 957 
 958 //------------------------------policy_align-----------------------------------
 959 // Return TRUE or FALSE if the loop should be cache-line aligned.  Gather the
 960 // expression that does the alignment.  Note that only one array base can be
 961 // aligned in a loop (unless the VM guarantees mutual alignment).  Note that
 962 // if we vectorize short memory ops into longer memory ops, we may want to
 963 // increase alignment.
<span class="line-modified"> 964 bool IdealLoopTree::policy_align(PhaseIdealLoop *phase) const {</span>
 965   return false;
 966 }
 967 
 968 //------------------------------policy_range_check-----------------------------
<span class="line-modified"> 969 // Return TRUE or FALSE if the loop should be range-check-eliminated or not.</span>
<span class="line-modified"> 970 // When TRUE, the estimated node budget is also requested.</span>
<span class="line-modified"> 971 //</span>
<span class="line-added"> 972 // We will actually perform iteration-splitting, a more powerful form of RCE.</span>
<span class="line-added"> 973 bool IdealLoopTree::policy_range_check(PhaseIdealLoop *phase) const {</span>
 974   if (!RangeCheckElimination) return false;
 975 
<span class="line-added"> 976   // If nodes are depleted, some transform has miscalculated its needs.</span>
<span class="line-added"> 977   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);</span>
<span class="line-added"> 978 </span>
 979   CountedLoopNode *cl = _head-&gt;as_CountedLoop();
<span class="line-modified"> 980   // If we unrolled  with no intention of doing RCE and we  later changed our</span>
<span class="line-modified"> 981   // minds, we got no pre-loop.  Either we need to make a new pre-loop, or we</span>
<span class="line-modified"> 982   // have to disallow RCE.</span>
 983   if (cl-&gt;is_main_no_pre_loop()) return false; // Disallowed for now.
 984   Node *trip_counter = cl-&gt;phi();
 985 
 986   // check for vectorized loops, some opts are no longer needed
<span class="line-modified"> 987   if (cl-&gt;is_unroll_only()) return false;</span>
 988 
 989   // Check loop body for tests of trip-counter plus loop-invariant vs
 990   // loop-invariant.
 991   for (uint i = 0; i &lt; _body.size(); i++) {
 992     Node *iff = _body[i];
 993     if (iff-&gt;Opcode() == Op_If ||
 994         iff-&gt;Opcode() == Op_RangeCheck) { // Test?
 995 
 996       // Comparing trip+off vs limit
 997       Node *bol = iff-&gt;in(1);
<span class="line-modified"> 998       if (bol-&gt;req() != 2) {</span>
<span class="line-added"> 999         continue; // dead constant test</span>
<span class="line-added">1000       }</span>
1001       if (!bol-&gt;is_Bool()) {
1002         assert(bol-&gt;Opcode() == Op_Conv2B, &quot;predicate check only&quot;);
1003         continue;
1004       }
<span class="line-modified">1005       if (bol-&gt;as_Bool()-&gt;_test._test == BoolTest::ne) {</span>
1006         continue; // not RC
<span class="line-modified">1007       }</span>
1008       Node *cmp = bol-&gt;in(1);
1009       Node *rc_exp = cmp-&gt;in(1);
1010       Node *limit = cmp-&gt;in(2);
1011 
1012       Node *limit_c = phase-&gt;get_ctrl(limit);
<span class="line-modified">1013       if (limit_c == phase-&gt;C-&gt;top()) {</span>
1014         return false;           // Found dead test on live IF?  No RCE!
<span class="line-modified">1015       }</span>
<span class="line-added">1016       if (is_member(phase-&gt;get_loop(limit_c))) {</span>
1017         // Compare might have operands swapped; commute them
1018         rc_exp = cmp-&gt;in(2);
1019         limit  = cmp-&gt;in(1);
1020         limit_c = phase-&gt;get_ctrl(limit);
<span class="line-modified">1021         if (is_member(phase-&gt;get_loop(limit_c))) {</span>
1022           continue;             // Both inputs are loop varying; cannot RCE
<span class="line-added">1023         }</span>
1024       }
1025 
1026       if (!phase-&gt;is_scaled_iv_plus_offset(rc_exp, trip_counter, NULL, NULL)) {
1027         continue;
1028       }
<span class="line-modified">1029       // Found a test like &#39;trip+off vs limit&#39;. Test is an IfNode, has two (2)</span>
<span class="line-modified">1030       // projections. If BOTH are in the loop we need loop unswitching instead</span>
<span class="line-modified">1031       // of iteration splitting.</span>
<span class="line-modified">1032       if (is_loop_exit(iff)) {</span>
<span class="line-modified">1033         // Found valid reason to split iterations (if there is room).</span>
<span class="line-added">1034         // NOTE: Usually a gross overestimate.</span>
<span class="line-added">1035         return phase-&gt;may_require_nodes(est_loop_clone_sz(2));</span>
<span class="line-added">1036       }</span>
1037     } // End of is IF
1038   }
1039 
1040   return false;
1041 }
1042 
1043 //------------------------------policy_peel_only-------------------------------
1044 // Return TRUE or FALSE if the loop should NEVER be RCE&#39;d or aligned.  Useful
1045 // for unrolling loops with NO array accesses.
<span class="line-modified">1046 bool IdealLoopTree::policy_peel_only(PhaseIdealLoop *phase) const {</span>
<span class="line-added">1047 </span>
<span class="line-added">1048   // If nodes are depleted, some transform has miscalculated its needs.</span>
<span class="line-added">1049   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);</span>
<span class="line-added">1050 </span>
1051   // check for vectorized loops, any peeling done was already applied
<span class="line-modified">1052   if (_head-&gt;is_CountedLoop() &amp;&amp; _head-&gt;as_CountedLoop()-&gt;is_unroll_only()) {</span>
<span class="line-added">1053     return false;</span>
<span class="line-added">1054   }</span>
1055 
<span class="line-modified">1056   for (uint i = 0; i &lt; _body.size(); i++) {</span>
<span class="line-modified">1057     if (_body[i]-&gt;is_Mem()) {</span>
1058       return false;
<span class="line-modified">1059     }</span>
<span class="line-added">1060   }</span>
1061   // No memory accesses at all!
1062   return true;
1063 }
1064 
1065 //------------------------------clone_up_backedge_goo--------------------------
1066 // If Node n lives in the back_ctrl block and cannot float, we clone a private
1067 // version of n in preheader_ctrl block and return that, otherwise return n.
<span class="line-modified">1068 Node *PhaseIdealLoop::clone_up_backedge_goo(Node *back_ctrl, Node *preheader_ctrl, Node *n, VectorSet &amp;visited, Node_Stack &amp;clones) {</span>
<span class="line-modified">1069   if (get_ctrl(n) != back_ctrl) return n;</span>
1070 
1071   // Only visit once
1072   if (visited.test_set(n-&gt;_idx)) {
1073     Node *x = clones.find(n-&gt;_idx);
<span class="line-modified">1074     return (x != NULL) ? x : n;</span>


1075   }
1076 
1077   Node *x = NULL;               // If required, a clone of &#39;n&#39;
1078   // Check for &#39;n&#39; being pinned in the backedge.
<span class="line-modified">1079   if (n-&gt;in(0) &amp;&amp; n-&gt;in(0) == back_ctrl) {</span>
1080     assert(clones.find(n-&gt;_idx) == NULL, &quot;dead loop&quot;);
1081     x = n-&gt;clone();             // Clone a copy of &#39;n&#39; to preheader
1082     clones.push(x, n-&gt;_idx);
<span class="line-modified">1083     x-&gt;set_req(0, preheader_ctrl); // Fix x&#39;s control input to preheader</span>
1084   }
1085 
1086   // Recursive fixup any other input edges into x.
1087   // If there are no changes we can just return &#39;n&#39;, otherwise
1088   // we need to clone a private copy and change it.
<span class="line-modified">1089   for (uint i = 1; i &lt; n-&gt;req(); i++) {</span>
<span class="line-modified">1090     Node *g = clone_up_backedge_goo(back_ctrl, preheader_ctrl, n-&gt;in(i), visited, clones);</span>
<span class="line-modified">1091     if (g != n-&gt;in(i)) {</span>
<span class="line-modified">1092       if (!x) {</span>
1093         assert(clones.find(n-&gt;_idx) == NULL, &quot;dead loop&quot;);
1094         x = n-&gt;clone();
1095         clones.push(x, n-&gt;_idx);
1096       }
1097       x-&gt;set_req(i, g);
1098     }
1099   }
<span class="line-modified">1100   if (x) {                     // x can legally float to pre-header location</span>
<span class="line-modified">1101     register_new_node(x, preheader_ctrl);</span>
1102     return x;
1103   } else {                      // raise n to cover LCA of uses
<span class="line-modified">1104     set_ctrl(n, find_non_split_ctrl(back_ctrl-&gt;in(0)));</span>
1105   }
1106   return n;
1107 }
1108 
1109 Node* PhaseIdealLoop::cast_incr_before_loop(Node* incr, Node* ctrl, Node* loop) {
1110   Node* castii = new CastIINode(incr, TypeInt::INT, true);
1111   castii-&gt;set_req(0, ctrl);
1112   register_new_node(castii, ctrl);
1113   for (DUIterator_Fast imax, i = incr-&gt;fast_outs(imax); i &lt; imax; i++) {
1114     Node* n = incr-&gt;fast_out(i);
1115     if (n-&gt;is_Phi() &amp;&amp; n-&gt;in(0) == loop) {
1116       int nrep = n-&gt;replace_edge(incr, castii);
1117       return castii;
1118     }
1119   }
1120   return NULL;
1121 }
1122 
1123 // Make a copy of the skeleton range check predicates before the main
1124 // loop and set the initial value of loop as input. After unrolling,
</pre>
<hr />
<pre>
1250         if (next-&gt;_idx &lt; current) {
1251           next = next-&gt;clone();
1252           register_new_node(next, current_proj);
1253           to_clone.set_node(next);
1254         }
1255         next-&gt;set_req(j, cur);
1256       }
1257     }
1258   } while (result == NULL);
1259   assert(result-&gt;_idx &gt;= current, &quot;new node expected&quot;);
1260 
1261   Node* proj = predicate-&gt;clone();
1262   Node* other_proj = uncommon_proj-&gt;clone();
1263   Node* new_iff = iff-&gt;clone();
1264   new_iff-&gt;set_req(1, result);
1265   proj-&gt;set_req(0, new_iff);
1266   other_proj-&gt;set_req(0, new_iff);
1267   Node *frame = new ParmNode(C-&gt;start(), TypeFunc::FramePtr);
1268   register_new_node(frame, C-&gt;start());
1269   // It&#39;s impossible for the predicate to fail at runtime. Use an Halt node.
<span class="line-modified">1270   Node* halt = new HaltNode(other_proj, frame, &quot;duplicated predicate failed which is impossible&quot;);</span>
1271   C-&gt;root()-&gt;add_req(halt);
1272   new_iff-&gt;set_req(0, prev_proj);
1273 
1274   register_control(new_iff, outer_loop-&gt;_parent, prev_proj);
1275   register_control(proj, outer_loop-&gt;_parent, new_iff);
1276   register_control(other_proj, _ltree_root, new_iff);
1277   register_control(halt, _ltree_root, other_proj);
1278   return proj;
1279 }
1280 
1281 void PhaseIdealLoop::duplicate_predicates(CountedLoopNode* pre_head, Node* start, Node* end,
1282                                           IdealLoopTree* outer_loop, LoopNode* outer_main_head,
1283                                           uint dd_main_head) {
1284   if (UseLoopPredicate) {
1285     Node* entry = pre_head-&gt;in(LoopNode::EntryControl);
1286     Node* predicate = NULL;
1287     predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
1288     if (predicate != NULL) {
1289       entry = skip_loop_predicates(entry);
1290     }
1291     Node* profile_predicate = NULL;
1292     if (UseProfiledLoopPredicate) {
1293       profile_predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);
1294       if (profile_predicate != NULL) {
1295         entry = skip_loop_predicates(entry);
1296       }
1297     }
1298     predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
1299     duplicate_predicates_helper(predicate, start, end, outer_loop, outer_main_head, dd_main_head);
1300     duplicate_predicates_helper(profile_predicate, start, end, outer_loop, outer_main_head, dd_main_head);
1301   }
1302 }
1303 
1304 //------------------------------insert_pre_post_loops--------------------------
1305 // Insert pre and post loops.  If peel_only is set, the pre-loop can not have
1306 // more iterations added.  It acts as a &#39;peel&#39; only, no lower-bound RCE, no
1307 // alignment.  Useful to unroll loops that do no array accesses.
<span class="line-modified">1308 void PhaseIdealLoop::insert_pre_post_loops(IdealLoopTree *loop, Node_List &amp;old_new, bool peel_only) {</span>
1309 
1310 #ifndef PRODUCT
1311   if (TraceLoopOpts) {
1312     if (peel_only)
1313       tty-&gt;print(&quot;PeelMainPost &quot;);
1314     else
1315       tty-&gt;print(&quot;PreMainPost  &quot;);
1316     loop-&gt;dump_head();
1317   }
1318 #endif
1319   C-&gt;set_major_progress();
1320 
1321   // Find common pieces of the loop being guarded with pre &amp; post loops
1322   CountedLoopNode *main_head = loop-&gt;_head-&gt;as_CountedLoop();
<span class="line-modified">1323   assert(main_head-&gt;is_normal_loop(), &quot;&quot;);</span>
1324   CountedLoopEndNode *main_end = main_head-&gt;loopexit();
<span class="line-modified">1325   assert(main_end-&gt;outcnt() == 2, &quot;1 true, 1 false path only&quot;);</span>
1326 
1327   Node *pre_header= main_head-&gt;in(LoopNode::EntryControl);
1328   Node *init      = main_head-&gt;init_trip();
1329   Node *incr      = main_end -&gt;incr();
1330   Node *limit     = main_end -&gt;limit();
1331   Node *stride    = main_end -&gt;stride();
1332   Node *cmp       = main_end -&gt;cmp_node();
1333   BoolTest::mask b_test = main_end-&gt;test_trip();
1334 
1335   // Need only 1 user of &#39;bol&#39; because I will be hacking the loop bounds.
1336   Node *bol = main_end-&gt;in(CountedLoopEndNode::TestValue);
<span class="line-modified">1337   if (bol-&gt;outcnt() != 1) {</span>
1338     bol = bol-&gt;clone();
1339     register_new_node(bol,main_end-&gt;in(CountedLoopEndNode::TestControl));
1340     _igvn.replace_input_of(main_end, CountedLoopEndNode::TestValue, bol);
1341   }
1342   // Need only 1 user of &#39;cmp&#39; because I will be hacking the loop bounds.
<span class="line-modified">1343   if (cmp-&gt;outcnt() != 1) {</span>
1344     cmp = cmp-&gt;clone();
1345     register_new_node(cmp,main_end-&gt;in(CountedLoopEndNode::TestControl));
1346     _igvn.replace_input_of(bol, 1, cmp);
1347   }
1348 
1349   // Add the post loop
1350   CountedLoopNode *post_head = NULL;
1351   Node *main_exit = insert_post_loop(loop, old_new, main_head, main_end, incr, limit, post_head);
1352 
1353   //------------------------------
1354   // Step B: Create Pre-Loop.
1355 
1356   // Step B1: Clone the loop body.  The clone becomes the pre-loop.  The main
1357   // loop pre-header illegally has 2 control users (old &amp; new loops).
1358   LoopNode* outer_main_head = main_head;
1359   IdealLoopTree* outer_loop = loop;
1360   if (main_head-&gt;is_strip_mined()) {
1361     main_head-&gt;verify_strip_mined(1);
1362     outer_main_head = main_head-&gt;outer_loop();
1363     outer_loop = loop-&gt;_parent;
1364     assert(outer_loop-&gt;_head == outer_main_head, &quot;broken loop tree&quot;);
1365   }
1366   uint dd_main_head = dom_depth(outer_main_head);
1367   clone_loop(loop, old_new, dd_main_head, ControlAroundStripMined);
1368   CountedLoopNode*    pre_head = old_new[main_head-&gt;_idx]-&gt;as_CountedLoop();
1369   CountedLoopEndNode* pre_end  = old_new[main_end -&gt;_idx]-&gt;as_CountedLoopEnd();
1370   pre_head-&gt;set_pre_loop(main_head);
1371   Node *pre_incr = old_new[incr-&gt;_idx];
1372 
1373   // Reduce the pre-loop trip count.
1374   pre_end-&gt;_prob = PROB_FAIR;
1375 
1376   // Find the pre-loop normal exit.
1377   Node* pre_exit = pre_end-&gt;proj_out(false);
<span class="line-modified">1378   assert(pre_exit-&gt;Opcode() == Op_IfFalse, &quot;&quot;);</span>
1379   IfFalseNode *new_pre_exit = new IfFalseNode(pre_end);
<span class="line-modified">1380   _igvn.register_new_node_with_optimizer(new_pre_exit);</span>
1381   set_idom(new_pre_exit, pre_end, dd_main_head);
1382   set_loop(new_pre_exit, outer_loop-&gt;_parent);
1383 
1384   // Step B2: Build a zero-trip guard for the main-loop.  After leaving the
1385   // pre-loop, the main-loop may not execute at all.  Later in life this
1386   // zero-trip guard will become the minimum-trip guard when we unroll
1387   // the main-loop.
1388   Node *min_opaq = new Opaque1Node(C, limit);
<span class="line-modified">1389   Node *min_cmp  = new CmpINode(pre_incr, min_opaq);</span>
<span class="line-modified">1390   Node *min_bol  = new BoolNode(min_cmp, b_test);</span>
<span class="line-modified">1391   register_new_node(min_opaq, new_pre_exit);</span>
<span class="line-modified">1392   register_new_node(min_cmp , new_pre_exit);</span>
<span class="line-modified">1393   register_new_node(min_bol , new_pre_exit);</span>
1394 
1395   // Build the IfNode (assume the main-loop is executed always).
<span class="line-modified">1396   IfNode *min_iff = new IfNode(new_pre_exit, min_bol, PROB_ALWAYS, COUNT_UNKNOWN);</span>
<span class="line-modified">1397   _igvn.register_new_node_with_optimizer(min_iff);</span>
1398   set_idom(min_iff, new_pre_exit, dd_main_head);
1399   set_loop(min_iff, outer_loop-&gt;_parent);
1400 
1401   // Plug in the false-path, taken if we need to skip main-loop
<span class="line-modified">1402   _igvn.hash_delete(pre_exit);</span>
1403   pre_exit-&gt;set_req(0, min_iff);
1404   set_idom(pre_exit, min_iff, dd_main_head);
1405   set_idom(pre_exit-&gt;unique_ctrl_out(), min_iff, dd_main_head);
1406   // Make the true-path, must enter the main loop
<span class="line-modified">1407   Node *min_taken = new IfTrueNode(min_iff);</span>
<span class="line-modified">1408   _igvn.register_new_node_with_optimizer(min_taken);</span>
1409   set_idom(min_taken, min_iff, dd_main_head);
1410   set_loop(min_taken, outer_loop-&gt;_parent);
1411   // Plug in the true path
1412   _igvn.hash_delete(outer_main_head);
1413   outer_main_head-&gt;set_req(LoopNode::EntryControl, min_taken);
1414   set_idom(outer_main_head, min_taken, dd_main_head);
1415 
1416   Arena *a = Thread::current()-&gt;resource_area();
1417   VectorSet visited(a);
1418   Node_Stack clones(a, main_head-&gt;back_control()-&gt;outcnt());
1419   // Step B3: Make the fall-in values to the main-loop come from the
1420   // fall-out values of the pre-loop.
1421   for (DUIterator_Fast i2max, i2 = main_head-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1422     Node* main_phi = main_head-&gt;fast_out(i2);
<span class="line-modified">1423     if (main_phi-&gt;is_Phi() &amp;&amp; main_phi-&gt;in(0) == main_head &amp;&amp; main_phi-&gt;outcnt() &gt; 0) {</span>
1424       Node *pre_phi = old_new[main_phi-&gt;_idx];
1425       Node *fallpre  = clone_up_backedge_goo(pre_head-&gt;back_control(),
1426                                              main_head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl),
1427                                              pre_phi-&gt;in(LoopNode::LoopBackControl),
1428                                              visited, clones);
1429       _igvn.hash_delete(main_phi);
<span class="line-modified">1430       main_phi-&gt;set_req(LoopNode::EntryControl, fallpre);</span>
1431     }
1432   }
1433 
1434   // Nodes inside the loop may be control dependent on a predicate
1435   // that was moved before the preloop. If the back branch of the main
1436   // or post loops becomes dead, those nodes won&#39;t be dependent on the
1437   // test that guards that loop nest anymore which could lead to an
1438   // incorrect array access because it executes independently of the
1439   // test that was guarding the loop nest. We add a special CastII on
1440   // the if branch that enters the loop, between the input induction
1441   // variable value and the induction variable Phi to preserve correct
1442   // dependencies.
1443 
1444   // CastII for the main loop:
<span class="line-modified">1445   Node* castii = cast_incr_before_loop(pre_incr, min_taken, main_head);</span>
1446   assert(castii != NULL, &quot;no castII inserted&quot;);
1447   Node* opaque_castii = new Opaque1Node(C, castii);
1448   register_new_node(opaque_castii, outer_main_head-&gt;in(LoopNode::EntryControl));
1449   duplicate_predicates(pre_head, castii, opaque_castii, outer_loop, outer_main_head, dd_main_head);
1450 
1451   // Step B4: Shorten the pre-loop to run only 1 iteration (for now).
1452   // RCE and alignment may change this later.
1453   Node *cmp_end = pre_end-&gt;cmp_node();
<span class="line-modified">1454   assert(cmp_end-&gt;in(2) == limit, &quot;&quot;);</span>
<span class="line-modified">1455   Node *pre_limit = new AddINode(init, stride);</span>
1456 
1457   // Save the original loop limit in this Opaque1 node for
1458   // use by range check elimination.
1459   Node *pre_opaq  = new Opaque1Node(C, pre_limit, limit);
1460 
<span class="line-modified">1461   register_new_node(pre_limit, pre_head-&gt;in(0));</span>
<span class="line-modified">1462   register_new_node(pre_opaq , pre_head-&gt;in(0));</span>
1463 
1464   // Since no other users of pre-loop compare, I can hack limit directly
<span class="line-modified">1465   assert(cmp_end-&gt;outcnt() == 1, &quot;no other users&quot;);</span>
1466   _igvn.hash_delete(cmp_end);
1467   cmp_end-&gt;set_req(2, peel_only ? pre_limit : pre_opaq);
1468 
1469   // Special case for not-equal loop bounds:
1470   // Change pre loop test, main loop test, and the
1471   // main loop guard test to use lt or gt depending on stride
1472   // direction:
1473   // positive stride use &lt;
1474   // negative stride use &gt;
1475   //
1476   // not-equal test is kept for post loop to handle case
1477   // when init &gt; limit when stride &gt; 0 (and reverse).
1478 
1479   if (pre_end-&gt;in(CountedLoopEndNode::TestValue)-&gt;as_Bool()-&gt;_test._test == BoolTest::ne) {
1480 
1481     BoolTest::mask new_test = (main_end-&gt;stride_con() &gt; 0) ? BoolTest::lt : BoolTest::gt;
1482     // Modify pre loop end condition
1483     Node* pre_bol = pre_end-&gt;in(CountedLoopEndNode::TestValue)-&gt;as_Bool();
1484     BoolNode* new_bol0 = new BoolNode(pre_bol-&gt;in(1), new_test);
<span class="line-modified">1485     register_new_node(new_bol0, pre_head-&gt;in(0));</span>
1486     _igvn.replace_input_of(pre_end, CountedLoopEndNode::TestValue, new_bol0);
1487     // Modify main loop guard condition
1488     assert(min_iff-&gt;in(CountedLoopEndNode::TestValue) == min_bol, &quot;guard okay&quot;);
1489     BoolNode* new_bol1 = new BoolNode(min_bol-&gt;in(1), new_test);
<span class="line-modified">1490     register_new_node(new_bol1, new_pre_exit);</span>
1491     _igvn.hash_delete(min_iff);
1492     min_iff-&gt;set_req(CountedLoopEndNode::TestValue, new_bol1);
1493     // Modify main loop end condition
1494     BoolNode* main_bol = main_end-&gt;in(CountedLoopEndNode::TestValue)-&gt;as_Bool();
1495     BoolNode* new_bol2 = new BoolNode(main_bol-&gt;in(1), new_test);
<span class="line-modified">1496     register_new_node(new_bol2, main_end-&gt;in(CountedLoopEndNode::TestControl));</span>
1497     _igvn.replace_input_of(main_end, CountedLoopEndNode::TestValue, new_bol2);
1498   }
1499 
1500   // Flag main loop
1501   main_head-&gt;set_main_loop();
<span class="line-modified">1502   if (peel_only) {</span>
<span class="line-added">1503     main_head-&gt;set_main_no_pre_loop();</span>
<span class="line-added">1504   }</span>
1505 
1506   // Subtract a trip count for the pre-loop.
1507   main_head-&gt;set_trip_count(main_head-&gt;trip_count() - 1);
1508 
1509   // It&#39;s difficult to be precise about the trip-counts
1510   // for the pre/post loops.  They are usually very short,
1511   // so guess that 4 trips is a reasonable value.
1512   post_head-&gt;set_profile_trip_cnt(4.0);
1513   pre_head-&gt;set_profile_trip_cnt(4.0);
1514 
1515   // Now force out all loop-invariant dominating tests.  The optimizer
1516   // finds some, but we _know_ they are all useless.
1517   peeled_dom_test_elim(loop,old_new);
1518   loop-&gt;record_for_igvn();
1519 }
1520 
1521 //------------------------------insert_vector_post_loop------------------------
1522 // Insert a copy of the atomic unrolled vectorized main loop as a post loop,
<span class="line-modified">1523 // unroll_policy has  already informed  us that more  unrolling is  about to</span>
<span class="line-modified">1524 // happen  to the  main  loop.  The  resultant  post loop  will  serve as  a</span>
<span class="line-added">1525 // vectorized drain loop.</span>
1526 void PhaseIdealLoop::insert_vector_post_loop(IdealLoopTree *loop, Node_List &amp;old_new) {
1527   if (!loop-&gt;_head-&gt;is_CountedLoop()) return;
1528 
1529   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
1530 
1531   // only process vectorized main loops
1532   if (!cl-&gt;is_vectorized_loop() || !cl-&gt;is_main_loop()) return;
1533 
1534   int slp_max_unroll_factor = cl-&gt;slp_max_unroll();
1535   int cur_unroll = cl-&gt;unrolled_count();
1536 
1537   if (slp_max_unroll_factor == 0) return;
1538 
1539   // only process atomic unroll vector loops (not super unrolled after vectorization)
1540   if (cur_unroll != slp_max_unroll_factor) return;
1541 
1542   // we only ever process this one time
1543   if (cl-&gt;has_atomic_post_loop()) return;
1544 
<span class="line-added">1545   if (!may_require_nodes(loop-&gt;est_loop_clone_sz(2))) {</span>
<span class="line-added">1546     return;</span>
<span class="line-added">1547   }</span>
<span class="line-added">1548 </span>
1549 #ifndef PRODUCT
1550   if (TraceLoopOpts) {
1551     tty-&gt;print(&quot;PostVector  &quot;);
1552     loop-&gt;dump_head();
1553   }
1554 #endif
1555   C-&gt;set_major_progress();
1556 
1557   // Find common pieces of the loop being guarded with pre &amp; post loops
1558   CountedLoopNode *main_head = loop-&gt;_head-&gt;as_CountedLoop();
1559   CountedLoopEndNode *main_end = main_head-&gt;loopexit();
1560   // diagnostic to show loop end is not properly formed
1561   assert(main_end-&gt;outcnt() == 2, &quot;1 true, 1 false path only&quot;);
1562 
1563   // mark this loop as processed
1564   main_head-&gt;mark_has_atomic_post_loop();
1565 
1566   Node *incr = main_end-&gt;incr();
1567   Node *limit = main_end-&gt;limit();
1568 
</pre>
<hr />
<pre>
1689   _igvn.replace_input_of(main_exit, 0, zer_iff);
1690   set_idom(main_exit, zer_iff, dd_main_exit);
1691   set_idom(main_exit-&gt;unique_out(), zer_iff, dd_main_exit);
1692   // Make the true-path, must enter this post loop
1693   Node *zer_taken = new IfTrueNode(zer_iff);
1694   _igvn.register_new_node_with_optimizer(zer_taken);
1695   set_idom(zer_taken, zer_iff, dd_main_exit);
1696   set_loop(zer_taken, outer_loop-&gt;_parent);
1697   // Plug in the true path
1698   _igvn.hash_delete(post_head);
1699   post_head-&gt;set_req(LoopNode::EntryControl, zer_taken);
1700   set_idom(post_head, zer_taken, dd_main_exit);
1701 
1702   Arena *a = Thread::current()-&gt;resource_area();
1703   VectorSet visited(a);
1704   Node_Stack clones(a, main_head-&gt;back_control()-&gt;outcnt());
1705   // Step A3: Make the fall-in values to the post-loop come from the
1706   // fall-out values of the main-loop.
1707   for (DUIterator_Fast imax, i = main_head-&gt;fast_outs(imax); i &lt; imax; i++) {
1708     Node* main_phi = main_head-&gt;fast_out(i);
<span class="line-modified">1709     if (main_phi-&gt;is_Phi() &amp;&amp; main_phi-&gt;in(0) == main_head &amp;&amp; main_phi-&gt;outcnt() &gt; 0) {</span>
1710       Node *cur_phi = old_new[main_phi-&gt;_idx];
1711       Node *fallnew = clone_up_backedge_goo(main_head-&gt;back_control(),
1712                                             post_head-&gt;init_control(),
1713                                             main_phi-&gt;in(LoopNode::LoopBackControl),
1714                                             visited, clones);
1715       _igvn.hash_delete(cur_phi);
1716       cur_phi-&gt;set_req(LoopNode::EntryControl, fallnew);
1717     }
1718   }
1719 
1720   // CastII for the new post loop:
1721   Node* castii = cast_incr_before_loop(zer_opaq-&gt;in(1), zer_taken, post_head);
1722   assert(castii != NULL, &quot;no castII inserted&quot;);
1723 
1724   return new_main_exit;
1725 }
1726 
1727 //------------------------------is_invariant-----------------------------
1728 // Return true if n is invariant
1729 bool IdealLoopTree::is_invariant(Node* n) const {
</pre>
<hr />
<pre>
1761         int init_inc = stride_con/loop_head-&gt;unrolled_count();
1762         assert(init_inc != 0, &quot;invalid loop increment&quot;);
1763         int new_stride_con = stride_con * 2;
1764         Node* max_value = _igvn.intcon(new_stride_con - init_inc);
1765         max_value = new AddINode(init, max_value);
1766         register_new_node(max_value, get_ctrl(iff-&gt;in(1)));
1767         prev_proj = clone_skeleton_predicate(iff, max_value, entry, proj, ctrl, outer_loop, prev_proj);
1768         assert(!skeleton_predicate_has_opaque(prev_proj-&gt;in(0)-&gt;as_If()), &quot;unexpected&quot;);
1769       }
1770     }
1771     entry = entry-&gt;in(0)-&gt;in(0);
1772   }
1773   if (prev_proj != ctrl) {
1774     _igvn.replace_input_of(outer_loop_head, LoopNode::EntryControl, prev_proj);
1775     set_idom(outer_loop_head, prev_proj, dom_depth(outer_loop_head));
1776   }
1777 }
1778 
1779 //------------------------------do_unroll--------------------------------------
1780 // Unroll the loop body one step - make each trip do 2 iterations.
<span class="line-modified">1781 void PhaseIdealLoop::do_unroll(IdealLoopTree *loop, Node_List &amp;old_new, bool adjust_min_trip) {</span>
1782   assert(LoopUnrollLimit, &quot;&quot;);
1783   CountedLoopNode *loop_head = loop-&gt;_head-&gt;as_CountedLoop();
1784   CountedLoopEndNode *loop_end = loop_head-&gt;loopexit();
1785 #ifndef PRODUCT
1786   if (PrintOpto &amp;&amp; VerifyLoopOptimizations) {
1787     tty-&gt;print(&quot;Unrolling &quot;);
1788     loop-&gt;dump_head();
1789   } else if (TraceLoopOpts) {
1790     if (loop_head-&gt;trip_count() &lt; (uint)LoopUnrollLimit) {
1791       tty-&gt;print(&quot;Unroll %d(%2d) &quot;, loop_head-&gt;unrolled_count()*2, loop_head-&gt;trip_count());
1792     } else {
1793       tty-&gt;print(&quot;Unroll %d     &quot;, loop_head-&gt;unrolled_count()*2);
1794     }
1795     loop-&gt;dump_head();
1796   }
1797 
1798   if (C-&gt;do_vector_loop() &amp;&amp; (PrintOpto &amp;&amp; (VerifyLoopOptimizations || TraceLoopOpts))) {
1799     Arena* arena = Thread::current()-&gt;resource_area();
1800     Node_Stack stack(arena, C-&gt;live_nodes() &gt;&gt; 2);
1801     Node_List rpo_list;
1802     VectorSet visited(arena);
1803     visited.set(loop_head-&gt;_idx);
<span class="line-modified">1804     rpo(loop_head, stack, visited, rpo_list);</span>
<span class="line-modified">1805     dump(loop, rpo_list.size(), rpo_list);</span>
1806   }
1807 #endif
1808 
1809   // Remember loop node count before unrolling to detect
1810   // if rounds of unroll,optimize are making progress
1811   loop_head-&gt;set_node_count_before_unroll(loop-&gt;_body.size());
1812 
1813   Node *ctrl  = loop_head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
1814   Node *limit = loop_head-&gt;limit();
1815   Node *init  = loop_head-&gt;init_trip();
1816   Node *stride = loop_head-&gt;stride();
1817 
1818   Node *opaq = NULL;
1819   if (adjust_min_trip) {       // If not maximally unrolling, need adjustment
1820     // Search for zero-trip guard.
1821 
1822     // Check the shape of the graph at the loop entry. If an inappropriate
1823     // graph shape is encountered, the compiler bails out loop unrolling;
1824     // compilation of the method will still succeed.
1825     if (!is_canonical_loop_entry(loop_head)) {
</pre>
<hr />
<pre>
1862     int new_stride_con = stride_con * 2;
1863     int stride_m    = new_stride_con - (stride_con &gt; 0 ? 1 : -1);
1864     jlong trip_count = (limit_con - init_con + stride_m)/new_stride_con;
1865     // New trip count should satisfy next conditions.
1866     assert(trip_count &gt; 0 &amp;&amp; (julong)trip_count &lt; (julong)max_juint/2, &quot;sanity&quot;);
1867     uint new_trip_count = (uint)trip_count;
1868     adjust_min_trip = (old_trip_count != new_trip_count*2);
1869   }
1870 
1871   if (adjust_min_trip) {
1872     // Step 2: Adjust the trip limit if it is called for.
1873     // The adjustment amount is -stride. Need to make sure if the
1874     // adjustment underflows or overflows, then the main loop is skipped.
1875     Node* cmp = loop_end-&gt;cmp_node();
1876     assert(cmp-&gt;in(2) == limit, &quot;sanity&quot;);
1877     assert(opaq != NULL &amp;&amp; opaq-&gt;in(1) == limit, &quot;sanity&quot;);
1878 
1879     // Verify that policy_unroll result is still valid.
1880     const TypeInt* limit_type = _igvn.type(limit)-&gt;is_int();
1881     assert(stride_con &gt; 0 &amp;&amp; ((limit_type-&gt;_hi - stride_con) &lt; limit_type-&gt;_hi) ||
<span class="line-modified">1882            stride_con &lt; 0 &amp;&amp; ((limit_type-&gt;_lo - stride_con) &gt; limit_type-&gt;_lo),</span>
<span class="line-added">1883            &quot;sanity&quot;);</span>
1884 
1885     if (limit-&gt;is_Con()) {
1886       // The check in policy_unroll and the assert above guarantee
1887       // no underflow if limit is constant.
1888       new_limit = _igvn.intcon(limit-&gt;get_int() - stride_con);
1889       set_ctrl(new_limit, C-&gt;root());
1890     } else {
1891       // Limit is not constant.
1892       if (loop_head-&gt;unrolled_count() == 1) { // only for first unroll
1893         // Separate limit by Opaque node in case it is an incremented
1894         // variable from previous loop to avoid using pre-incremented
1895         // value which could increase register pressure.
1896         // Otherwise reorg_offsets() optimization will create a separate
1897         // Opaque node for each use of trip-counter and as result
1898         // zero trip guard limit will be different from loop limit.
1899         assert(has_ctrl(opaq), &quot;should have it&quot;);
1900         Node* opaq_ctrl = get_ctrl(opaq);
<span class="line-modified">1901         limit = new Opaque2Node(C, limit);</span>
<span class="line-modified">1902         register_new_node(limit, opaq_ctrl);</span>
1903       }
1904       if ((stride_con &gt; 0 &amp;&amp; (java_subtract(limit_type-&gt;_lo, stride_con) &lt; limit_type-&gt;_lo)) ||
1905           (stride_con &lt; 0 &amp;&amp; (java_subtract(limit_type-&gt;_hi, stride_con) &gt; limit_type-&gt;_hi))) {
1906         // No underflow.
1907         new_limit = new SubINode(limit, stride);
1908       } else {
1909         // (limit - stride) may underflow.
1910         // Clamp the adjustment value with MININT or MAXINT:
1911         //
1912         //   new_limit = limit-stride
1913         //   if (stride &gt; 0)
1914         //     new_limit = (limit &lt; new_limit) ? MININT : new_limit;
1915         //   else
1916         //     new_limit = (limit &gt; new_limit) ? MAXINT : new_limit;
1917         //
1918         BoolTest::mask bt = loop_end-&gt;test_trip();
1919         assert(bt == BoolTest::lt || bt == BoolTest::gt, &quot;canonical test is expected&quot;);
1920         Node* adj_max = _igvn.intcon((stride_con &gt; 0) ? min_jint : max_jint);
1921         set_ctrl(adj_max, C-&gt;root());
1922         Node* old_limit = NULL;
1923         Node* adj_limit = NULL;
1924         Node* bol = limit-&gt;is_CMove() ? limit-&gt;in(CMoveNode::Condition) : NULL;
1925         if (loop_head-&gt;unrolled_count() &gt; 1 &amp;&amp;
1926             limit-&gt;is_CMove() &amp;&amp; limit-&gt;Opcode() == Op_CMoveI &amp;&amp;
1927             limit-&gt;in(CMoveNode::IfTrue) == adj_max &amp;&amp;
1928             bol-&gt;as_Bool()-&gt;_test._test == bt &amp;&amp;
1929             bol-&gt;in(1)-&gt;Opcode() == Op_CmpI &amp;&amp;
1930             bol-&gt;in(1)-&gt;in(2) == limit-&gt;in(CMoveNode::IfFalse)) {
1931           // Loop was unrolled before.
1932           // Optimize the limit to avoid nested CMove:
1933           // use original limit as old limit.
1934           old_limit = bol-&gt;in(1)-&gt;in(1);
1935           // Adjust previous adjusted limit.
1936           adj_limit = limit-&gt;in(CMoveNode::IfFalse);
1937           adj_limit = new SubINode(adj_limit, stride);
1938         } else {
1939           old_limit = limit;
1940           adj_limit = new SubINode(limit, stride);
1941         }
1942         assert(old_limit != NULL &amp;&amp; adj_limit != NULL, &quot;&quot;);
<span class="line-modified">1943         register_new_node(adj_limit, ctrl); // adjust amount</span>
1944         Node* adj_cmp = new CmpINode(old_limit, adj_limit);
<span class="line-modified">1945         register_new_node(adj_cmp, ctrl);</span>
1946         Node* adj_bool = new BoolNode(adj_cmp, bt);
<span class="line-modified">1947         register_new_node(adj_bool, ctrl);</span>
1948         new_limit = new CMoveINode(adj_bool, adj_limit, adj_max, TypeInt::INT);
1949       }
1950       register_new_node(new_limit, ctrl);
1951     }
<span class="line-added">1952 </span>
1953     assert(new_limit != NULL, &quot;&quot;);
1954     // Replace in loop test.
1955     assert(loop_end-&gt;in(1)-&gt;in(1) == cmp, &quot;sanity&quot;);
1956     if (cmp-&gt;outcnt() == 1 &amp;&amp; loop_end-&gt;in(1)-&gt;outcnt() == 1) {
1957       // Don&#39;t need to create new test since only one user.
1958       _igvn.hash_delete(cmp);
1959       cmp-&gt;set_req(2, new_limit);
1960     } else {
1961       // Create new test since it is shared.
1962       Node* ctrl2 = loop_end-&gt;in(0);
1963       Node* cmp2  = cmp-&gt;clone();
1964       cmp2-&gt;set_req(2, new_limit);
1965       register_new_node(cmp2, ctrl2);
1966       Node* bol2 = loop_end-&gt;in(1)-&gt;clone();
1967       bol2-&gt;set_req(1, cmp2);
1968       register_new_node(bol2, ctrl2);
1969       _igvn.replace_input_of(loop_end, 1, bol2);
1970     }
1971     // Step 3: Find the min-trip test guaranteed before a &#39;main&#39; loop.
1972     // Make it a 1-trip test (means at least 2 trips).
</pre>
<hr />
<pre>
1982   // down here (e.g. 15-&gt; 7-&gt; 3-&gt; 1) because if we unwittingly over-unroll,
1983   // the main, unrolled, part of the loop will never execute as it is protected
1984   // by the min-trip test.  See bug 4834191 for a case where we over-unrolled
1985   // and later determined that part of the unrolled loop was dead.
1986   loop_head-&gt;set_trip_count(old_trip_count / 2);
1987 
1988   // Double the count of original iterations in the unrolled loop body.
1989   loop_head-&gt;double_unrolled_count();
1990 
1991   // ---------
1992   // Step 4: Clone the loop body.  Move it inside the loop.  This loop body
1993   // represents the odd iterations; since the loop trips an even number of
1994   // times its backedge is never taken.  Kill the backedge.
1995   uint dd = dom_depth(loop_head);
1996   clone_loop(loop, old_new, dd, IgnoreStripMined);
1997 
1998   // Make backedges of the clone equal to backedges of the original.
1999   // Make the fall-in from the original come from the fall-out of the clone.
2000   for (DUIterator_Fast jmax, j = loop_head-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2001     Node* phi = loop_head-&gt;fast_out(j);
<span class="line-modified">2002     if (phi-&gt;is_Phi() &amp;&amp; phi-&gt;in(0) == loop_head &amp;&amp; phi-&gt;outcnt() &gt; 0) {</span>
2003       Node *newphi = old_new[phi-&gt;_idx];
<span class="line-modified">2004       _igvn.hash_delete(phi);</span>
<span class="line-modified">2005       _igvn.hash_delete(newphi);</span>
2006 
2007       phi   -&gt;set_req(LoopNode::   EntryControl, newphi-&gt;in(LoopNode::LoopBackControl));
2008       newphi-&gt;set_req(LoopNode::LoopBackControl, phi   -&gt;in(LoopNode::LoopBackControl));
2009       phi   -&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
2010     }
2011   }
2012   Node *clone_head = old_new[loop_head-&gt;_idx];
<span class="line-modified">2013   _igvn.hash_delete(clone_head);</span>
2014   loop_head -&gt;set_req(LoopNode::   EntryControl, clone_head-&gt;in(LoopNode::LoopBackControl));
2015   clone_head-&gt;set_req(LoopNode::LoopBackControl, loop_head -&gt;in(LoopNode::LoopBackControl));
2016   loop_head -&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
2017   loop-&gt;_head = clone_head;     // New loop header
2018 
2019   set_idom(loop_head,  loop_head -&gt;in(LoopNode::EntryControl), dd);
2020   set_idom(clone_head, clone_head-&gt;in(LoopNode::EntryControl), dd);
2021 
2022   // Kill the clone&#39;s backedge
2023   Node *newcle = old_new[loop_end-&gt;_idx];
<span class="line-modified">2024   _igvn.hash_delete(newcle);</span>
2025   Node *one = _igvn.intcon(1);
2026   set_ctrl(one, C-&gt;root());
2027   newcle-&gt;set_req(1, one);
2028   // Force clone into same loop body
2029   uint max = loop-&gt;_body.size();
<span class="line-modified">2030   for (uint k = 0; k &lt; max; k++) {</span>
2031     Node *old = loop-&gt;_body.at(k);
2032     Node *nnn = old_new[old-&gt;_idx];
2033     loop-&gt;_body.push(nnn);
<span class="line-modified">2034     if (!has_ctrl(old)) {</span>
2035       set_loop(nnn, loop);
<span class="line-added">2036     }</span>
2037   }
2038 
2039   loop-&gt;record_for_igvn();
2040   loop_head-&gt;clear_strip_mined();
2041 
2042 #ifndef PRODUCT
2043   if (C-&gt;do_vector_loop() &amp;&amp; (PrintOpto &amp;&amp; (VerifyLoopOptimizations || TraceLoopOpts))) {
2044     tty-&gt;print(&quot;\nnew loop after unroll\n&quot;);       loop-&gt;dump_head();
2045     for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {
2046       loop-&gt;_body.at(i)-&gt;dump();
2047     }
<span class="line-modified">2048     if (C-&gt;clone_map().is_debug()) {</span>
2049       tty-&gt;print(&quot;\nCloneMap\n&quot;);
2050       Dict* dict = C-&gt;clone_map().dict();
2051       DictI i(dict);
2052       tty-&gt;print_cr(&quot;Dict@%p[%d] = &quot;, dict, dict-&gt;Size());
2053       for (int ii = 0; i.test(); ++i, ++ii) {
2054         NodeCloneInfo cl((uint64_t)dict-&gt;operator[]((void*)i._key));
2055         tty-&gt;print(&quot;%d-&gt;%d:%d,&quot;, (int)(intptr_t)i._key, cl.idx(), cl.gen());
2056         if (ii % 10 == 9) {
2057           tty-&gt;print_cr(&quot; &quot;);
2058         }
2059       }
2060       tty-&gt;print_cr(&quot; &quot;);
2061     }
2062   }
2063 #endif

2064 }
2065 
2066 //------------------------------do_maximally_unroll----------------------------
2067 
<span class="line-modified">2068 void PhaseIdealLoop::do_maximally_unroll(IdealLoopTree *loop, Node_List &amp;old_new) {</span>
2069   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
2070   assert(cl-&gt;has_exact_trip_count(), &quot;trip count is not exact&quot;);
2071   assert(cl-&gt;trip_count() &gt; 0, &quot;&quot;);
2072 #ifndef PRODUCT
2073   if (TraceLoopOpts) {
2074     tty-&gt;print(&quot;MaxUnroll  %d &quot;, cl-&gt;trip_count());
2075     loop-&gt;dump_head();
2076   }
2077 #endif
2078 
2079   // If loop is tripping an odd number of times, peel odd iteration
2080   if ((cl-&gt;trip_count() &amp; 1) == 1) {
2081     do_peeling(loop, old_new);
2082   }
2083 
2084   // Now its tripping an even number of times remaining.  Double loop body.
2085   // Do not adjust pre-guards; they are not needed and do not exist.
2086   if (cl-&gt;trip_count() &gt; 0) {
2087     assert((cl-&gt;trip_count() &amp; 1) == 0, &quot;missed peeling&quot;);
2088     do_unroll(loop, old_new, false);
</pre>
<hr />
<pre>
2166   if (round_up) {
2167     X = new AddINode(X, _igvn.intcon(1));
2168     register_new_node(X, pre_ctrl);
2169   }
2170 
2171   // Adjust loop limit
2172   loop_limit = (stride_con &gt; 0)
2173                ? (Node*)(new MinINode(loop_limit, X))
2174                : (Node*)(new MaxINode(loop_limit, X));
2175   register_new_node(loop_limit, pre_ctrl);
2176   return loop_limit;
2177 }
2178 
2179 //------------------------------add_constraint---------------------------------
2180 // Constrain the main loop iterations so the conditions:
2181 //    low_limit &lt;= scale_con * I + offset  &lt;  upper_limit
2182 // always holds true.  That is, either increase the number of iterations in
2183 // the pre-loop or the post-loop until the condition holds true in the main
2184 // loop.  Stride, scale, offset and limit are all loop invariant.  Further,
2185 // stride and scale are constants (offset and limit often are).
<span class="line-modified">2186 void PhaseIdealLoop::add_constraint(int stride_con, int scale_con, Node *offset, Node *low_limit, Node *upper_limit, Node *pre_ctrl, Node **pre_limit, Node **main_limit) {</span>
2187   // For positive stride, the pre-loop limit always uses a MAX function
2188   // and the main loop a MIN function.  For negative stride these are
2189   // reversed.
2190 
2191   // Also for positive stride*scale the affine function is increasing, so the
2192   // pre-loop must check for underflow and the post-loop for overflow.
2193   // Negative stride*scale reverses this; pre-loop checks for overflow and
2194   // post-loop for underflow.
2195 
2196   Node *scale = _igvn.intcon(scale_con);
2197   set_ctrl(scale, C-&gt;root());
2198 
2199   if ((stride_con^scale_con) &gt;= 0) { // Use XOR to avoid overflow
2200     // The overflow limit: scale*I+offset &lt; upper_limit
2201     // For main-loop compute
2202     //   ( if (scale &gt; 0) /* and stride &gt; 0 */
2203     //       I &lt; (upper_limit-offset)/scale
2204     //     else /* scale &lt; 0 and stride &lt; 0 */
2205     //       I &gt; (upper_limit-offset)/scale
2206     //   )
</pre>
<hr />
<pre>
2251     // post-loop for underflow.
2252     //
2253     // The overflow limit: scale*I+offset &lt; upper_limit
2254     // For pre-loop compute
2255     //   NOT(scale*I+offset &lt; upper_limit)
2256     //   scale*I+offset &gt;= upper_limit
2257     //   scale*I+offset+1 &gt; upper_limit
2258     //   ( if (scale &lt; 0) /* and stride &gt; 0 */
2259     //       I &lt; (upper_limit-(offset+1))/scale
2260     //     else /* scale &gt; 0 and stride &lt; 0 */
2261     //       I &gt; (upper_limit-(offset+1))/scale
2262     //   )
2263     //
2264     // (upper_limit-offset-1) may underflow or overflow.
2265     // To avoid it min(pre_limit, original_limit) is used
2266     // in do_range_check() for stride &gt; 0 and max() for &lt; 0.
2267     Node *one  = _igvn.intcon(1);
2268     set_ctrl(one, C-&gt;root());
2269 
2270     Node *plus_one = new AddINode(offset, one);
<span class="line-modified">2271     register_new_node(plus_one, pre_ctrl);</span>
2272     // Pass (-stride) to indicate pre_loop_cond = NOT(main_loop_cond);
2273     *pre_limit = adjust_limit((-stride_con), scale, plus_one, upper_limit, *pre_limit, pre_ctrl,
2274                               scale_con &lt; -1 &amp;&amp; stride_con &gt; 0);
2275 
2276     if (low_limit-&gt;get_int() == -max_jint) {
2277       // We need this guard when scale*main_limit+offset &gt;= limit
2278       // due to underflow. So we need execute main-loop while
2279       // scale*I+offset+1 &gt; min_int. But (min_int-offset-1) will
2280       // underflow when (offset+1) &gt; 0 and X will be &lt; main_limit
2281       // when scale &lt; 0 (and stride &gt; 0). To avoid it we replace
2282       // positive (offset+1) with 0.
2283       //
2284       // Also (min_int+1 == -max_int) is used instead of min_int here
2285       // to avoid problem with scale == -1 (min_int/(-1) == min_int).
2286       Node* shift = _igvn.intcon(31);
2287       set_ctrl(shift, C-&gt;root());
2288       Node* sign = new RShiftINode(plus_one, shift);
2289       register_new_node(sign, pre_ctrl);
2290       plus_one = new AndINode(plus_one, sign);
2291       register_new_node(plus_one, pre_ctrl);
</pre>
<hr />
<pre>
2412 Node* PhaseIdealLoop::add_range_check_predicate(IdealLoopTree* loop, CountedLoopNode* cl,
2413                                                 Node* predicate_proj, int scale_con, Node* offset,
2414                                                 Node* limit, jint stride_con, Node* value) {
2415   bool overflow = false;
2416   BoolNode* bol = rc_predicate(loop, predicate_proj, scale_con, offset, value, NULL, stride_con, limit, (stride_con &gt; 0) != (scale_con &gt; 0), overflow);
2417   Node* opaque_bol = new Opaque4Node(C, bol, _igvn.intcon(1));
2418   register_new_node(opaque_bol, predicate_proj);
2419   IfNode* new_iff = NULL;
2420   if (overflow) {
2421     new_iff = new IfNode(predicate_proj, opaque_bol, PROB_MAX, COUNT_UNKNOWN);
2422   } else {
2423     new_iff = new RangeCheckNode(predicate_proj, opaque_bol, PROB_MAX, COUNT_UNKNOWN);
2424   }
2425   register_control(new_iff, loop-&gt;_parent, predicate_proj);
2426   Node* iffalse = new IfFalseNode(new_iff);
2427   register_control(iffalse, _ltree_root, new_iff);
2428   ProjNode* iftrue = new IfTrueNode(new_iff);
2429   register_control(iftrue, loop-&gt;_parent, new_iff);
2430   Node *frame = new ParmNode(C-&gt;start(), TypeFunc::FramePtr);
2431   register_new_node(frame, C-&gt;start());
<span class="line-modified">2432   Node* halt = new HaltNode(iffalse, frame, &quot;range check predicate failed which is impossible&quot;);</span>
2433   register_control(halt, _ltree_root, iffalse);
2434   C-&gt;root()-&gt;add_req(halt);
2435   return iftrue;
2436 }
2437 
2438 //------------------------------do_range_check---------------------------------
2439 // Eliminate range-checks and other trip-counter vs loop-invariant tests.
<span class="line-modified">2440 int PhaseIdealLoop::do_range_check(IdealLoopTree *loop, Node_List &amp;old_new) {</span>
2441 #ifndef PRODUCT
2442   if (PrintOpto &amp;&amp; VerifyLoopOptimizations) {
2443     tty-&gt;print(&quot;Range Check Elimination &quot;);
2444     loop-&gt;dump_head();
2445   } else if (TraceLoopOpts) {
2446     tty-&gt;print(&quot;RangeCheck   &quot;);
2447     loop-&gt;dump_head();
2448   }
2449 #endif
<span class="line-added">2450 </span>
2451   assert(RangeCheckElimination, &quot;&quot;);
2452   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
2453   // If we fail before trying to eliminate range checks, set multiversion state
2454   int closed_range_checks = 1;
2455 
2456   // protect against stride not being a constant
<span class="line-modified">2457   if (!cl-&gt;stride_is_con()) {</span>
2458     return closed_range_checks;
<span class="line-modified">2459   }</span>
2460   // Find the trip counter; we are iteration splitting based on it
2461   Node *trip_counter = cl-&gt;phi();
2462   // Find the main loop limit; we will trim it&#39;s iterations
2463   // to not ever trip end tests
2464   Node *main_limit = cl-&gt;limit();
2465 
2466   // Check graph shape. Cannot optimize a loop if zero-trip
2467   // Opaque1 node is optimized away and then another round
2468   // of loop opts attempted.
2469   if (!is_canonical_loop_entry(cl)) {
2470     return closed_range_checks;
2471   }
2472 
2473   // Need to find the main-loop zero-trip guard
<span class="line-modified">2474   Node *ctrl = cl-&gt;skip_predicates();</span>
2475   Node *iffm = ctrl-&gt;in(0);
2476   Node *opqzm = iffm-&gt;in(1)-&gt;in(1)-&gt;in(2);
2477   assert(opqzm-&gt;in(1) == main_limit, &quot;do not understand situation&quot;);
2478 
2479   // Find the pre-loop limit; we will expand its iterations to
2480   // not ever trip low tests.
2481   Node *p_f = iffm-&gt;in(0);
2482   // pre loop may have been optimized out
2483   if (p_f-&gt;Opcode() != Op_IfFalse) {
2484     return closed_range_checks;
2485   }
2486   CountedLoopEndNode *pre_end = p_f-&gt;in(0)-&gt;as_CountedLoopEnd();
2487   assert(pre_end-&gt;loopnode()-&gt;is_pre_loop(), &quot;&quot;);
2488   Node *pre_opaq1 = pre_end-&gt;limit();
2489   // Occasionally it&#39;s possible for a pre-loop Opaque1 node to be
2490   // optimized away and then another round of loop opts attempted.
2491   // We can not optimize this particular loop in that case.
<span class="line-modified">2492   if (pre_opaq1-&gt;Opcode() != Op_Opaque1) {</span>
2493     return closed_range_checks;
<span class="line-added">2494   }</span>
2495   Opaque1Node *pre_opaq = (Opaque1Node*)pre_opaq1;
2496   Node *pre_limit = pre_opaq-&gt;in(1);
2497 
2498   // Where do we put new limit calculations
2499   Node *pre_ctrl = pre_end-&gt;loopnode()-&gt;in(LoopNode::EntryControl);
2500 
2501   // Ensure the original loop limit is available from the
2502   // pre-loop Opaque1 node.
2503   Node *orig_limit = pre_opaq-&gt;original_loop_limit();
<span class="line-modified">2504   if (orig_limit == NULL || _igvn.type(orig_limit) == Type::TOP) {</span>
2505     return closed_range_checks;
<span class="line-modified">2506   }</span>
2507   // Must know if its a count-up or count-down loop
2508 
2509   int stride_con = cl-&gt;stride_con();
2510   Node *zero = _igvn.intcon(0);
2511   Node *one  = _igvn.intcon(1);
2512   // Use symmetrical int range [-max_jint,max_jint]
2513   Node *mini = _igvn.intcon(-max_jint);
2514   set_ctrl(zero, C-&gt;root());
2515   set_ctrl(one,  C-&gt;root());
2516   set_ctrl(mini, C-&gt;root());
2517 
2518   // Range checks that do not dominate the loop backedge (ie.
2519   // conditionally executed) can lengthen the pre loop limit beyond
2520   // the original loop limit. To prevent this, the pre limit is
2521   // (for stride &gt; 0) MINed with the original loop limit (MAXed
2522   // stride &lt; 0) when some range_check (rc) is conditionally
2523   // executed.
2524   bool conditional_rc = false;
2525 
2526   // Count number of range checks and reduce by load range limits, if zero,
2527   // the loop is in canonical form to multiversion.
2528   closed_range_checks = 0;
2529 
2530   Node* predicate_proj = cl-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
2531   assert(predicate_proj-&gt;is_Proj() &amp;&amp; predicate_proj-&gt;in(0)-&gt;is_If(), &quot;if projection only&quot;);
<span class="line-added">2532 </span>
2533   // Check loop body for tests of trip-counter plus loop-invariant vs loop-variant.
<span class="line-modified">2534   for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {</span>
2535     Node *iff = loop-&gt;_body[i];
2536     if (iff-&gt;Opcode() == Op_If ||
2537         iff-&gt;Opcode() == Op_RangeCheck) { // Test?
2538       // Test is an IfNode, has 2 projections.  If BOTH are in the loop
2539       // we need loop unswitching instead of iteration splitting.
2540       closed_range_checks++;
2541       Node *exit = loop-&gt;is_loop_exit(iff);
<span class="line-modified">2542       if (!exit) continue;</span>
2543       int flip = (exit-&gt;Opcode() == Op_IfTrue) ? 1 : 0;
2544 
2545       // Get boolean condition to test
2546       Node *i1 = iff-&gt;in(1);
<span class="line-modified">2547       if (!i1-&gt;is_Bool()) continue;</span>
2548       BoolNode *bol = i1-&gt;as_Bool();
2549       BoolTest b_test = bol-&gt;_test;
2550       // Flip sense of test if exit condition is flipped
<span class="line-modified">2551       if (flip) {</span>
2552         b_test = b_test.negate();
<span class="line-modified">2553       }</span>
2554       // Get compare
2555       Node *cmp = bol-&gt;in(1);
2556 
2557       // Look for trip_counter + offset vs limit
2558       Node *rc_exp = cmp-&gt;in(1);
2559       Node *limit  = cmp-&gt;in(2);
2560       int scale_con= 1;        // Assume trip counter not scaled
2561 
2562       Node *limit_c = get_ctrl(limit);
<span class="line-modified">2563       if (loop-&gt;is_member(get_loop(limit_c))) {</span>
2564         // Compare might have operands swapped; commute them
2565         b_test = b_test.commute();
2566         rc_exp = cmp-&gt;in(2);
2567         limit  = cmp-&gt;in(1);
2568         limit_c = get_ctrl(limit);
<span class="line-modified">2569         if (loop-&gt;is_member(get_loop(limit_c))) {</span>
2570           continue;             // Both inputs are loop varying; cannot RCE
<span class="line-added">2571         }</span>
2572       }
2573       // Here we know &#39;limit&#39; is loop invariant
2574 
2575       // &#39;limit&#39; maybe pinned below the zero trip test (probably from a
2576       // previous round of rce), in which case, it can&#39;t be used in the
2577       // zero trip test expression which must occur before the zero test&#39;s if.
2578       if (is_dominator(ctrl, limit_c)) {
2579         continue;  // Don&#39;t rce this check but continue looking for other candidates.
2580       }
2581 
2582       // Check for scaled induction variable plus an offset
2583       Node *offset = NULL;
2584 
2585       if (!is_scaled_iv_plus_offset(rc_exp, trip_counter, &amp;scale_con, &amp;offset)) {
2586         continue;
2587       }
2588 
2589       Node *offset_c = get_ctrl(offset);
<span class="line-modified">2590       if (loop-&gt;is_member(get_loop(offset_c))) {</span>
2591         continue;               // Offset is not really loop invariant
<span class="line-added">2592       }</span>
2593       // Here we know &#39;offset&#39; is loop invariant.
2594 
2595       // As above for the &#39;limit&#39;, the &#39;offset&#39; maybe pinned below the
2596       // zero trip test.
2597       if (is_dominator(ctrl, offset_c)) {
2598         continue; // Don&#39;t rce this check but continue looking for other candidates.
2599       }
2600 #ifdef ASSERT
2601       if (TraceRangeLimitCheck) {
2602         tty-&gt;print_cr(&quot;RC bool node%s&quot;, flip ? &quot; flipped:&quot; : &quot;:&quot;);
2603         bol-&gt;dump(2);
2604       }
2605 #endif
2606       // At this point we have the expression as:
2607       //   scale_con * trip_counter + offset :: limit
2608       // where scale_con, offset and limit are loop invariant.  Trip_counter
2609       // monotonically increases by stride_con, a constant.  Both (or either)
2610       // stride_con and scale_con can be negative which will flip about the
2611       // sense of the test.
2612 
2613       // Adjust pre and main loop limits to guard the correct iteration set
<span class="line-modified">2614       if (cmp-&gt;Opcode() == Op_CmpU) { // Unsigned compare is really 2 tests</span>
<span class="line-modified">2615         if (b_test._test == BoolTest::lt) { // Range checks always use lt</span>
2616           // The underflow and overflow limits: 0 &lt;= scale*I+offset &lt; limit
<span class="line-modified">2617           add_constraint(stride_con, scale_con, offset, zero, limit, pre_ctrl, &amp;pre_limit, &amp;main_limit);</span>
2618           // (0-offset)/scale could be outside of loop iterations range.
2619           conditional_rc = true;
2620           Node* init = cl-&gt;init_trip();
2621           Node* opaque_init = new Opaque1Node(C, init);
2622           register_new_node(opaque_init, predicate_proj);
2623           // template predicate so it can be updated on next unrolling
2624           predicate_proj = add_range_check_predicate(loop, cl, predicate_proj, scale_con, offset, limit, stride_con, opaque_init);
2625           assert(skeleton_predicate_has_opaque(predicate_proj-&gt;in(0)-&gt;as_If()), &quot;unexpected&quot;);
2626           // predicate on first value of first iteration
2627           predicate_proj = add_range_check_predicate(loop, cl, predicate_proj, scale_con, offset, limit, stride_con, init);
2628           assert(!skeleton_predicate_has_opaque(predicate_proj-&gt;in(0)-&gt;as_If()), &quot;unexpected&quot;);
2629           int init_inc = stride_con/cl-&gt;unrolled_count();
2630           assert(init_inc != 0, &quot;invalid loop increment&quot;);
2631           Node* max_value = _igvn.intcon(stride_con - init_inc);
2632           max_value = new AddINode(init, max_value);
2633           register_new_node(max_value, predicate_proj);
2634           // predicate on last value of first iteration (in case unrolling has already happened)
2635           predicate_proj = add_range_check_predicate(loop, cl, predicate_proj, scale_con, offset, limit, stride_con, max_value);
2636           assert(!skeleton_predicate_has_opaque(predicate_proj-&gt;in(0)-&gt;as_If()), &quot;unexpected&quot;);
2637         } else {
2638           if (PrintOpto) {
2639             tty-&gt;print_cr(&quot;missed RCE opportunity&quot;);
2640           }
2641           continue;             // In release mode, ignore it
2642         }
2643       } else {                  // Otherwise work on normal compares
<span class="line-modified">2644         switch(b_test._test) {</span>
2645         case BoolTest::gt:
2646           // Fall into GE case
2647         case BoolTest::ge:
2648           // Convert (I*scale+offset) &gt;= Limit to (I*(-scale)+(-offset)) &lt;= -Limit
2649           scale_con = -scale_con;
<span class="line-modified">2650           offset = new SubINode(zero, offset);</span>
<span class="line-modified">2651           register_new_node(offset, pre_ctrl);</span>
<span class="line-modified">2652           limit  = new SubINode(zero, limit);</span>
<span class="line-modified">2653           register_new_node(limit, pre_ctrl);</span>
2654           // Fall into LE case
2655         case BoolTest::le:
2656           if (b_test._test != BoolTest::gt) {
2657             // Convert X &lt;= Y to X &lt; Y+1
<span class="line-modified">2658             limit = new AddINode(limit, one);</span>
<span class="line-modified">2659             register_new_node(limit, pre_ctrl);</span>
2660           }
2661           // Fall into LT case
2662         case BoolTest::lt:
2663           // The underflow and overflow limits: MIN_INT &lt;= scale*I+offset &lt; limit
2664           // Note: (MIN_INT+1 == -MAX_INT) is used instead of MIN_INT here
2665           // to avoid problem with scale == -1: MIN_INT/(-1) == MIN_INT.
<span class="line-modified">2666           add_constraint(stride_con, scale_con, offset, mini, limit, pre_ctrl, &amp;pre_limit, &amp;main_limit);</span>
2667           // ((MIN_INT+1)-offset)/scale could be outside of loop iterations range.
2668           // Note: negative offset is replaced with 0 but (MIN_INT+1)/scale could
2669           // still be outside of loop range.
2670           conditional_rc = true;
2671           break;
2672         default:
2673           if (PrintOpto) {
2674             tty-&gt;print_cr(&quot;missed RCE opportunity&quot;);
2675           }
2676           continue;             // Unhandled case
2677         }
2678       }
2679 
2680       // Kill the eliminated test
2681       C-&gt;set_major_progress();
<span class="line-modified">2682       Node *kill_con = _igvn.intcon(1-flip);</span>
2683       set_ctrl(kill_con, C-&gt;root());
2684       _igvn.replace_input_of(iff, 1, kill_con);
2685       // Find surviving projection
2686       assert(iff-&gt;is_If(), &quot;&quot;);
2687       ProjNode* dp = ((IfNode*)iff)-&gt;proj_out(1-flip);
2688       // Find loads off the surviving projection; remove their control edge
2689       for (DUIterator_Fast imax, i = dp-&gt;fast_outs(imax); i &lt; imax; i++) {
2690         Node* cd = dp-&gt;fast_out(i); // Control-dependent node
2691         if (cd-&gt;is_Load() &amp;&amp; cd-&gt;depends_only_on_test()) {   // Loads can now float around in the loop
2692           // Allow the load to float around in the loop, or before it
2693           // but NOT before the pre-loop.
2694           _igvn.replace_input_of(cd, 0, ctrl); // ctrl, not NULL
2695           --i;
2696           --imax;
2697         }
2698       }
2699       if (limit-&gt;Opcode() == Op_LoadRange) {
2700         closed_range_checks--;
2701       }

2702     } // End of is IF

2703   }
2704   if (predicate_proj != cl-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl)) {
2705     _igvn.replace_input_of(cl-&gt;skip_strip_mined(), LoopNode::EntryControl, predicate_proj);
2706     set_idom(cl-&gt;skip_strip_mined(), predicate_proj, dom_depth(cl-&gt;skip_strip_mined()));
2707   }
2708 
2709   // Update loop limits
2710   if (conditional_rc) {
2711     pre_limit = (stride_con &gt; 0) ? (Node*)new MinINode(pre_limit, orig_limit)
2712                                  : (Node*)new MaxINode(pre_limit, orig_limit);
2713     register_new_node(pre_limit, pre_ctrl);
2714   }
2715   _igvn.replace_input_of(pre_opaq, 1, pre_limit);
2716 
2717   // Note:: we are making the main loop limit no longer precise;
2718   // need to round up based on stride.
2719   cl-&gt;set_nonexact_trip_count();
2720   Node *main_cle = cl-&gt;loopexit();
2721   Node *main_bol = main_cle-&gt;in(1);
2722   // Hacking loop bounds; need private copies of exit test
<span class="line-modified">2723   if (main_bol-&gt;outcnt() &gt; 1) {     // BoolNode shared?</span>
<span class="line-modified">2724     main_bol = main_bol-&gt;clone();   // Clone a private BoolNode</span>
<span class="line-modified">2725     register_new_node(main_bol, main_cle-&gt;in(0));</span>
2726     _igvn.replace_input_of(main_cle, 1, main_bol);
2727   }
2728   Node *main_cmp = main_bol-&gt;in(1);
<span class="line-modified">2729   if (main_cmp-&gt;outcnt() &gt; 1) {     // CmpNode shared?</span>
<span class="line-modified">2730     main_cmp = main_cmp-&gt;clone();   // Clone a private CmpNode</span>
<span class="line-modified">2731     register_new_node(main_cmp, main_cle-&gt;in(0));</span>
2732     _igvn.replace_input_of(main_bol, 1, main_cmp);
2733   }
2734   // Hack the now-private loop bounds
2735   _igvn.replace_input_of(main_cmp, 2, main_limit);
2736   // The OpaqueNode is unshared by design
<span class="line-modified">2737   assert(opqzm-&gt;outcnt() == 1, &quot;cannot hack shared node&quot;);</span>
2738   _igvn.replace_input_of(opqzm, 1, main_limit);
2739 
2740   return closed_range_checks;
2741 }
2742 
2743 //------------------------------has_range_checks-------------------------------
2744 // Check to see if RCE cleaned the current loop of range-checks.
2745 void PhaseIdealLoop::has_range_checks(IdealLoopTree *loop) {
2746   assert(RangeCheckElimination, &quot;&quot;);
2747 
2748   // skip if not a counted loop
2749   if (!loop-&gt;is_counted()) return;
2750 
2751   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
2752 
2753   // skip this loop if it is already checked
2754   if (cl-&gt;has_been_range_checked()) return;
2755 
2756   // Now check for existence of range checks
2757   for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {
</pre>
<hr />
<pre>
2886       Node* cur_bool = iffm-&gt;in(1);
2887       if (cur_bool-&gt;is_Bool()) {
2888         Node* cur_cmp = cur_bool-&gt;in(1);
2889         if (cur_cmp-&gt;is_Cmp()) {
2890           BoolTest::mask new_test = BoolTest::gt;
2891           BoolNode *new_bool = new BoolNode(cur_cmp, new_test);
2892           _igvn.replace_node(cur_bool, new_bool);
2893           _igvn._worklist.push(new_bool);
2894           Node* left_op = cur_cmp-&gt;in(1);
2895           _igvn.replace_input_of(cur_cmp, 2, left_op);
2896           C-&gt;set_major_progress();
2897         }
2898       }
2899     }
2900   }
2901 }
2902 
2903 //------------------------------DCE_loop_body----------------------------------
2904 // Remove simplistic dead code from loop body
2905 void IdealLoopTree::DCE_loop_body() {
<span class="line-modified">2906   for (uint i = 0; i &lt; _body.size(); i++) {</span>
<span class="line-modified">2907     if (_body.at(i)-&gt;outcnt() == 0) {</span>
<span class="line-modified">2908       _body.map(i, _body.pop());</span>
<span class="line-added">2909       i--; // Ensure we revisit the updated index.</span>
<span class="line-added">2910     }</span>
<span class="line-added">2911   }</span>
2912 }
2913 
2914 
2915 //------------------------------adjust_loop_exit_prob--------------------------
2916 // Look for loop-exit tests with the 50/50 (or worse) guesses from the parsing stage.
2917 // Replace with a 1-in-10 exit guess.
<span class="line-modified">2918 void IdealLoopTree::adjust_loop_exit_prob(PhaseIdealLoop *phase) {</span>
2919   Node *test = tail();
<span class="line-modified">2920   while (test != _head) {</span>
2921     uint top = test-&gt;Opcode();
<span class="line-modified">2922     if (top == Op_IfTrue || top == Op_IfFalse) {</span>
2923       int test_con = ((ProjNode*)test)-&gt;_con;
2924       assert(top == (uint)(test_con? Op_IfTrue: Op_IfFalse), &quot;sanity&quot;);
2925       IfNode *iff = test-&gt;in(0)-&gt;as_If();
<span class="line-modified">2926       if (iff-&gt;outcnt() == 2) {         // Ignore dead tests</span>
2927         Node *bol = iff-&gt;in(1);
<span class="line-modified">2928         if (bol &amp;&amp; bol-&gt;req() &gt; 1 &amp;&amp; bol-&gt;in(1) &amp;&amp;</span>
<span class="line-modified">2929             ((bol-&gt;in(1)-&gt;Opcode() == Op_StorePConditional) ||</span>
<span class="line-modified">2930              (bol-&gt;in(1)-&gt;Opcode() == Op_StoreIConditional) ||</span>
<span class="line-modified">2931              (bol-&gt;in(1)-&gt;Opcode() == Op_StoreLConditional) ||</span>
<span class="line-modified">2932              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeB) ||</span>
<span class="line-modified">2933              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeS) ||</span>
<span class="line-modified">2934              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeI) ||</span>
<span class="line-modified">2935              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeL) ||</span>
<span class="line-modified">2936              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeP) ||</span>
<span class="line-modified">2937              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeN) ||</span>
<span class="line-modified">2938              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapB) ||</span>
<span class="line-modified">2939              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapS) ||</span>
<span class="line-modified">2940              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapI) ||</span>
<span class="line-modified">2941              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapL) ||</span>
<span class="line-modified">2942              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapP) ||</span>
<span class="line-modified">2943              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapN) ||</span>
<span class="line-modified">2944              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapB) ||</span>
<span class="line-modified">2945              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapS) ||</span>
<span class="line-modified">2946              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapI) ||</span>
<span class="line-modified">2947              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapL) ||</span>
<span class="line-modified">2948              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapP) ||</span>
<span class="line-modified">2949              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapN) ||</span>
<span class="line-modified">2950              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahCompareAndExchangeP) ||</span>
<span class="line-modified">2951              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahCompareAndExchangeN) ||</span>
<span class="line-modified">2952              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahWeakCompareAndSwapP) ||</span>
<span class="line-modified">2953              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahWeakCompareAndSwapN) ||</span>
<span class="line-modified">2954              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahCompareAndSwapP) ||</span>
<span class="line-modified">2955              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahCompareAndSwapN)))</span>
2956           return;               // Allocation loops RARELY take backedge
2957         // Find the OTHER exit path from the IF
2958         Node* ex = iff-&gt;proj_out(1-test_con);
2959         float p = iff-&gt;_prob;
<span class="line-modified">2960         if (!phase-&gt;is_member(this, ex) &amp;&amp; iff-&gt;_fcnt == COUNT_UNKNOWN) {</span>
<span class="line-modified">2961           if (top == Op_IfTrue) {</span>
<span class="line-modified">2962             if (p &lt; (PROB_FAIR + PROB_UNLIKELY_MAG(3))) {</span>
2963               iff-&gt;_prob = PROB_STATIC_FREQUENT;
2964             }
2965           } else {
<span class="line-modified">2966             if (p &gt; (PROB_FAIR - PROB_UNLIKELY_MAG(3))) {</span>
2967               iff-&gt;_prob = PROB_STATIC_INFREQUENT;
2968             }
2969           }
2970         }
2971       }
2972     }
2973     test = phase-&gt;idom(test);
2974   }
2975 }
2976 
2977 #ifdef ASSERT
<span class="line-modified">2978 static CountedLoopNode* locate_pre_from_main(CountedLoopNode* main_loop) {</span>
<span class="line-modified">2979   assert(!main_loop-&gt;is_main_no_pre_loop(), &quot;Does not have a pre loop&quot;);</span>
<span class="line-added">2980   Node* ctrl = main_loop-&gt;skip_predicates();</span>
2981   assert(ctrl-&gt;Opcode() == Op_IfTrue || ctrl-&gt;Opcode() == Op_IfFalse, &quot;&quot;);
<span class="line-modified">2982   Node* iffm = ctrl-&gt;in(0);</span>
2983   assert(iffm-&gt;Opcode() == Op_If, &quot;&quot;);
<span class="line-modified">2984   Node* p_f = iffm-&gt;in(0);</span>
2985   assert(p_f-&gt;Opcode() == Op_IfFalse, &quot;&quot;);
<span class="line-modified">2986   CountedLoopNode* pre_loop = p_f-&gt;in(0)-&gt;as_CountedLoopEnd()-&gt;loopnode();</span>
<span class="line-modified">2987   assert(pre_loop-&gt;is_pre_loop(), &quot;No pre loop found&quot;);</span>
<span class="line-modified">2988   return pre_loop;</span>
2989 }
2990 #endif
2991 
2992 // Remove the main and post loops and make the pre loop execute all
2993 // iterations. Useful when the pre loop is found empty.
2994 void IdealLoopTree::remove_main_post_loops(CountedLoopNode *cl, PhaseIdealLoop *phase) {
2995   CountedLoopEndNode* pre_end = cl-&gt;loopexit();
2996   Node* pre_cmp = pre_end-&gt;cmp_node();
2997   if (pre_cmp-&gt;in(2)-&gt;Opcode() != Op_Opaque1) {
2998     // Only safe to remove the main loop if the compiler optimized it
2999     // out based on an unknown number of iterations
3000     return;
3001   }
3002 
3003   // Can we find the main loop?
3004   if (_next == NULL) {
3005     return;
3006   }
3007 
3008   Node* next_head = _next-&gt;_head;
3009   if (!next_head-&gt;is_CountedLoop()) {
3010     return;
3011   }
3012 
3013   CountedLoopNode* main_head = next_head-&gt;as_CountedLoop();
<span class="line-modified">3014   if (!main_head-&gt;is_main_loop() || main_head-&gt;is_main_no_pre_loop()) {</span>
3015     return;
3016   }
3017 
3018   assert(locate_pre_from_main(main_head) == cl, &quot;bad main loop&quot;);
3019   Node* main_iff = main_head-&gt;skip_predicates()-&gt;in(0);
3020 
3021   // Remove the Opaque1Node of the pre loop and make it execute all iterations
3022   phase-&gt;_igvn.replace_input_of(pre_cmp, 2, pre_cmp-&gt;in(2)-&gt;in(2));
3023   // Remove the Opaque1Node of the main loop so it can be optimized out
3024   Node* main_cmp = main_iff-&gt;in(1)-&gt;in(1);
3025   assert(main_cmp-&gt;in(2)-&gt;Opcode() == Op_Opaque1, &quot;main loop has no opaque node?&quot;);
3026   phase-&gt;_igvn.replace_input_of(main_cmp, 2, main_cmp-&gt;in(2)-&gt;in(1));
3027 }
3028 
<span class="line-modified">3029 //------------------------------do_remove_empty_loop---------------------------</span>
<span class="line-modified">3030 // We always attempt remove empty loops.   The approach is to replace the trip</span>
<span class="line-modified">3031 // counter with the value it will have on the last iteration.  This will break</span>
<span class="line-modified">3032 // the loop.</span>
<span class="line-modified">3033 bool IdealLoopTree::do_remove_empty_loop(PhaseIdealLoop *phase) {</span>
3034   // Minimum size must be empty loop
<span class="line-modified">3035   if (_body.size() &gt; EMPTY_LOOP_SIZE) {</span>
3036     return false;
<span class="line-modified">3037   }</span>
<span class="line-modified">3038   if (!_head-&gt;is_CountedLoop()) {</span>
<span class="line-modified">3039     return false;   // Dead loop</span>
<span class="line-added">3040   }</span>
3041   CountedLoopNode *cl = _head-&gt;as_CountedLoop();
<span class="line-modified">3042   if (!cl-&gt;is_valid_counted_loop()) {</span>
<span class="line-modified">3043     return false;   // Malformed loop</span>
<span class="line-modified">3044   }</span>
<span class="line-modified">3045   if (!phase-&gt;is_member(this, phase-&gt;get_ctrl(cl-&gt;loopexit()-&gt;in(CountedLoopEndNode::TestValue)))) {</span>
<span class="line-modified">3046     return false;   // Infinite loop</span>
<span class="line-added">3047   }</span>
3048   if (cl-&gt;is_pre_loop()) {
<span class="line-modified">3049     // If the loop we are removing is a pre-loop then the main and post loop</span>
<span class="line-modified">3050     // can be removed as well.</span>
3051     remove_main_post_loops(cl, phase);
3052   }
3053 
3054 #ifdef ASSERT
3055   // Ensure only one phi which is the iv.
3056   Node* iv = NULL;
3057   for (DUIterator_Fast imax, i = cl-&gt;fast_outs(imax); i &lt; imax; i++) {
3058     Node* n = cl-&gt;fast_out(i);
3059     if (n-&gt;Opcode() == Op_Phi) {
<span class="line-modified">3060       assert(iv == NULL, &quot;Too many phis&quot;);</span>
3061       iv = n;
3062     }
3063   }
<span class="line-modified">3064   assert(iv == cl-&gt;phi(), &quot;Wrong phi&quot;);</span>
3065 #endif
3066 
3067   // main and post loops have explicitly created zero trip guard
3068   bool needs_guard = !cl-&gt;is_main_loop() &amp;&amp; !cl-&gt;is_post_loop();
3069   if (needs_guard) {
3070     // Skip guard if values not overlap.
3071     const TypeInt* init_t = phase-&gt;_igvn.type(cl-&gt;init_trip())-&gt;is_int();
3072     const TypeInt* limit_t = phase-&gt;_igvn.type(cl-&gt;limit())-&gt;is_int();
3073     int  stride_con = cl-&gt;stride_con();
3074     if (stride_con &gt; 0) {
3075       needs_guard = (init_t-&gt;_hi &gt;= limit_t-&gt;_lo);
3076     } else {
3077       needs_guard = (init_t-&gt;_lo &lt;= limit_t-&gt;_hi);
3078     }
3079   }
3080   if (needs_guard) {
3081     // Check for an obvious zero trip guard.
3082     Node* inctrl = PhaseIdealLoop::skip_all_loop_predicates(cl-&gt;skip_predicates());
3083     if (inctrl-&gt;Opcode() == Op_IfTrue || inctrl-&gt;Opcode() == Op_IfFalse) {
3084       bool maybe_swapped = (inctrl-&gt;Opcode() == Op_IfFalse);
</pre>
<hr />
<pre>
3113     tty-&gt;print(&quot;Empty with%s zero trip guard   &quot;, needs_guard ? &quot;out&quot; : &quot;&quot;);
3114     this-&gt;dump_head();
3115   }
3116 #endif
3117 
3118   if (needs_guard) {
3119     // Peel the loop to ensure there&#39;s a zero trip guard
3120     Node_List old_new;
3121     phase-&gt;do_peeling(this, old_new);
3122   }
3123 
3124   // Replace the phi at loop head with the final value of the last
3125   // iteration.  Then the CountedLoopEnd will collapse (backedge never
3126   // taken) and all loop-invariant uses of the exit values will be correct.
3127   Node *phi = cl-&gt;phi();
3128   Node *exact_limit = phase-&gt;exact_limit(this);
3129   if (exact_limit != cl-&gt;limit()) {
3130     // We also need to replace the original limit to collapse loop exit.
3131     Node* cmp = cl-&gt;loopexit()-&gt;cmp_node();
3132     assert(cl-&gt;limit() == cmp-&gt;in(2), &quot;sanity&quot;);
<span class="line-added">3133     // Duplicate cmp node if it has other users</span>
<span class="line-added">3134     if (cmp-&gt;outcnt() &gt; 1) {</span>
<span class="line-added">3135       cmp = cmp-&gt;clone();</span>
<span class="line-added">3136       cmp = phase-&gt;_igvn.register_new_node_with_optimizer(cmp);</span>
<span class="line-added">3137       BoolNode *bol = cl-&gt;loopexit()-&gt;in(CountedLoopEndNode::TestValue)-&gt;as_Bool();</span>
<span class="line-added">3138       phase-&gt;_igvn.replace_input_of(bol, 1, cmp); // put bol on worklist</span>
<span class="line-added">3139     }</span>
3140     phase-&gt;_igvn._worklist.push(cmp-&gt;in(2)); // put limit on worklist
3141     phase-&gt;_igvn.replace_input_of(cmp, 2, exact_limit); // put cmp on worklist
3142   }
3143   // Note: the final value after increment should not overflow since
3144   // counted loop has limit check predicate.
<span class="line-modified">3145   Node *final = new SubINode(exact_limit, cl-&gt;stride());</span>
3146   phase-&gt;register_new_node(final,cl-&gt;in(LoopNode::EntryControl));
3147   phase-&gt;_igvn.replace_node(phi,final);
3148   phase-&gt;C-&gt;set_major_progress();
3149   return true;
3150 }
3151 
<span class="line-modified">3152 //------------------------------do_one_iteration_loop--------------------------</span>
3153 // Convert one iteration loop into normal code.
<span class="line-modified">3154 bool IdealLoopTree::do_one_iteration_loop(PhaseIdealLoop *phase) {</span>
<span class="line-modified">3155   if (!_head-&gt;as_Loop()-&gt;is_valid_counted_loop()) {</span>
3156     return false; // Only for counted loop
<span class="line-modified">3157   }</span>
3158   CountedLoopNode *cl = _head-&gt;as_CountedLoop();
3159   if (!cl-&gt;has_exact_trip_count() || cl-&gt;trip_count() != 1) {
3160     return false;
3161   }
3162 
3163 #ifndef PRODUCT
<span class="line-modified">3164   if (TraceLoopOpts) {</span>
3165     tty-&gt;print(&quot;OneIteration &quot;);
3166     this-&gt;dump_head();
3167   }
3168 #endif
3169 
3170   Node *init_n = cl-&gt;init_trip();
3171 #ifdef ASSERT
3172   // Loop boundaries should be constant since trip count is exact.
3173   assert(init_n-&gt;get_int() + cl-&gt;stride_con() &gt;= cl-&gt;limit()-&gt;get_int(), &quot;should be one iteration&quot;);
3174 #endif
3175   // Replace the phi at loop head with the value of the init_trip.
3176   // Then the CountedLoopEnd will collapse (backedge will not be taken)
3177   // and all loop-invariant uses of the exit values will be correct.
3178   phase-&gt;_igvn.replace_node(cl-&gt;phi(), cl-&gt;init_trip());
3179   phase-&gt;C-&gt;set_major_progress();
3180   return true;
3181 }
3182 
3183 //=============================================================================
3184 //------------------------------iteration_split_impl---------------------------
<span class="line-modified">3185 bool IdealLoopTree::iteration_split_impl(PhaseIdealLoop *phase, Node_List &amp;old_new) {</span>
3186   // Compute loop trip count if possible.
3187   compute_trip_count(phase);
3188 
3189   // Convert one iteration loop into normal code.
<span class="line-modified">3190   if (do_one_iteration_loop(phase)) {</span>
3191     return true;
<span class="line-modified">3192   }</span>
3193   // Check and remove empty loops (spam micro-benchmarks)
<span class="line-modified">3194   if (do_remove_empty_loop(phase)) {</span>
3195     return true;  // Here we removed an empty loop
<span class="line-added">3196   }</span>
3197 
<span class="line-modified">3198   AutoNodeBudget node_budget(phase);</span>


3199 
3200   // Non-counted loops may be peeled; exactly 1 iteration is peeled.
3201   // This removes loop-invariant tests (usually null checks).
3202   if (!_head-&gt;is_CountedLoop()) { // Non-counted loop
3203     if (PartialPeelLoop &amp;&amp; phase-&gt;partial_peel(this, old_new)) {
3204       // Partial peel succeeded so terminate this round of loop opts
3205       return false;
3206     }
<span class="line-modified">3207     if (policy_peeling(phase)) {    // Should we peel?</span>
3208       if (PrintOpto) { tty-&gt;print_cr(&quot;should_peel&quot;); }
<span class="line-modified">3209       phase-&gt;do_peeling(this, old_new);</span>
<span class="line-modified">3210     } else if (policy_unswitching(phase)) {</span>
3211       phase-&gt;do_unswitching(this, old_new);
3212     }
3213     return true;
3214   }
3215   CountedLoopNode *cl = _head-&gt;as_CountedLoop();
3216 
3217   if (!cl-&gt;is_valid_counted_loop()) return true; // Ignore various kinds of broken loops
3218 
3219   // Do nothing special to pre- and post- loops
3220   if (cl-&gt;is_pre_loop() || cl-&gt;is_post_loop()) return true;
3221 
3222   // Compute loop trip count from profile data
3223   compute_profile_trip_cnt(phase);
3224 
3225   // Before attempting fancy unrolling, RCE or alignment, see if we want
3226   // to completely unroll this loop or do loop unswitching.
3227   if (cl-&gt;is_normal_loop()) {
<span class="line-modified">3228     if (policy_unswitching(phase)) {</span>
3229       phase-&gt;do_unswitching(this, old_new);
3230       return true;
3231     }
<span class="line-modified">3232     if (policy_maximally_unroll(phase)) {</span>

3233       // Here we did some unrolling and peeling.  Eventually we will
3234       // completely unroll this loop and it will no longer be a loop.
<span class="line-modified">3235       phase-&gt;do_maximally_unroll(this, old_new);</span>
3236       return true;
3237     }
3238   }
3239 
<span class="line-modified">3240   uint est_peeling = estimate_peeling(phase);</span>
<span class="line-modified">3241   bool should_peel = 0 &lt; est_peeling;</span>




3242 
3243   // Counted loops may be peeled, may need some iterations run up
3244   // front for RCE, and may want to align loop refs to a cache
3245   // line.  Thus we clone a full loop up front whose trip count is
3246   // at least 1 (if peeling), but may be several more.
3247 
3248   // The main loop will start cache-line aligned with at least 1
3249   // iteration of the unrolled body (zero-trip test required) and
3250   // will have some range checks removed.
3251 
3252   // A post-loop will finish any odd iterations (leftover after
3253   // unrolling), plus any needed for RCE purposes.
3254 
3255   bool should_unroll = policy_unroll(phase);
<span class="line-added">3256   bool should_rce    = policy_range_check(phase);</span>
<span class="line-added">3257   // TODO: Remove align -- not used.</span>
<span class="line-added">3258   bool should_align  = policy_align(phase);</span>
3259 
<span class="line-modified">3260   // If not RCE&#39;ing  (iteration splitting) or Aligning, then we  do not need a</span>
<span class="line-modified">3261   // pre-loop.  We may still need to peel an initial iteration but we will not</span>
<span class="line-modified">3262   // be needing an unknown number of pre-iterations.</span>




3263   //
<span class="line-modified">3264   // Basically, if may_rce_align reports FALSE first time through, we will not</span>
<span class="line-modified">3265   // be able to later do RCE or Aligning on this loop.</span>
3266   bool may_rce_align = !policy_peel_only(phase) || should_rce || should_align;
3267 
3268   // If we have any of these conditions (RCE, alignment, unrolling) met, then
3269   // we switch to the pre-/main-/post-loop model.  This model also covers
3270   // peeling.
3271   if (should_rce || should_align || should_unroll) {
<span class="line-modified">3272     if (cl-&gt;is_normal_loop()) { // Convert to &#39;pre/main/post&#39; loops</span>
<span class="line-modified">3273       uint estimate = est_loop_clone_sz(3);</span>
<span class="line-modified">3274       if (!phase-&gt;may_require_nodes(estimate)) {</span>
<span class="line-modified">3275         return false;</span>
<span class="line-modified">3276       }</span>
<span class="line-modified">3277       phase-&gt;insert_pre_post_loops(this, old_new, !may_rce_align);</span>
<span class="line-added">3278     }</span>
<span class="line-added">3279     // Adjust the pre- and main-loop limits to let the pre and  post loops run</span>
<span class="line-added">3280     // with full checks, but the main-loop with no checks.  Remove said checks</span>
<span class="line-added">3281     // from the main body.</span>
3282     if (should_rce) {
3283       if (phase-&gt;do_range_check(this, old_new) != 0) {
3284         cl-&gt;mark_has_range_checks();
3285       }
3286     } else if (PostLoopMultiversioning) {
3287       phase-&gt;has_range_checks(this);
3288     }
3289 
3290     if (should_unroll &amp;&amp; !should_peel &amp;&amp; PostLoopMultiversioning) {
3291       // Try to setup multiversioning on main loops before they are unrolled
3292       if (cl-&gt;is_main_loop() &amp;&amp; (cl-&gt;unrolled_count() == 1)) {
3293         phase-&gt;insert_scalar_rced_post_loop(this, old_new);
3294       }
3295     }
3296 
3297     // Double loop body for unrolling.  Adjust the minimum-trip test (will do
3298     // twice as many iterations as before) and the main body limit (only do
3299     // an even number of trips).  If we are peeling, we might enable some RCE
3300     // and we&#39;d rather unroll the post-RCE&#39;d loop SO... do not unroll if
3301     // peeling.
3302     if (should_unroll &amp;&amp; !should_peel) {
3303       if (SuperWordLoopUnrollAnalysis) {
3304         phase-&gt;insert_vector_post_loop(this, old_new);
3305       }
3306       phase-&gt;do_unroll(this, old_new, true);
3307     }
3308 
<span class="line-modified">3309     // Adjust the pre-loop limits to align the main body iterations.</span>
<span class="line-modified">3310     if (should_align) {</span>

3311       Unimplemented();
<span class="line-modified">3312     }</span>
3313   } else {                      // Else we have an unchanged counted loop
<span class="line-modified">3314     if (should_peel) {          // Might want to peel but do nothing else</span>
<span class="line-modified">3315       if (phase-&gt;may_require_nodes(est_peeling)) {</span>
<span class="line-added">3316         phase-&gt;do_peeling(this, old_new);</span>
<span class="line-added">3317       }</span>
<span class="line-added">3318     }</span>
3319   }
3320   return true;
3321 }
3322 
3323 
3324 //=============================================================================
3325 //------------------------------iteration_split--------------------------------
<span class="line-modified">3326 bool IdealLoopTree::iteration_split(PhaseIdealLoop* phase, Node_List &amp;old_new) {</span>
3327   // Recursively iteration split nested loops
<span class="line-modified">3328   if (_child &amp;&amp; !_child-&gt;iteration_split(phase, old_new)) {</span>
3329     return false;
<span class="line-added">3330   }</span>
3331 
3332   // Clean out prior deadwood
3333   DCE_loop_body();
3334 

3335   // Look for loop-exit tests with my 50/50 guesses from the Parsing stage.
3336   // Replace with a 1-in-10 exit guess.
<span class="line-modified">3337   if (!is_root() &amp;&amp; is_loop()) {</span>



3338     adjust_loop_exit_prob(phase);
3339   }
3340 
<span class="line-modified">3341   // Unrolling, RCE and peeling efforts, iff innermost loop.</span>
<span class="line-modified">3342   if (_allow_optimizations &amp;&amp; is_innermost()) {</span>



3343     if (!_has_call) {
<span class="line-modified">3344       if (!iteration_split_impl(phase, old_new)) {</span>
<span class="line-modified">3345         return false;</span>
<span class="line-modified">3346       }</span>
<span class="line-modified">3347     } else {</span>
<span class="line-modified">3348       AutoNodeBudget node_budget(phase);</span>
<span class="line-added">3349       if (policy_unswitching(phase)) {</span>
<span class="line-added">3350         phase-&gt;do_unswitching(this, old_new);</span>
<span class="line-added">3351       }</span>
3352     }
3353   }
3354 
3355   // Minor offset re-organization to remove loop-fallout uses of
3356   // trip counter when there was no major reshaping.
3357   phase-&gt;reorg_offsets(this);
3358 
<span class="line-modified">3359   if (_next &amp;&amp; !_next-&gt;iteration_split(phase, old_new)) {</span>
3360     return false;
<span class="line-added">3361   }</span>
3362   return true;
3363 }
3364 
3365 
3366 //=============================================================================
3367 // Process all the loops in the loop tree and replace any fill
3368 // patterns with an intrinsic version.
3369 bool PhaseIdealLoop::do_intrinsify_fill() {
3370   bool changed = false;
3371   for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {
3372     IdealLoopTree* lpt = iter.current();
3373     changed |= intrinsify_fill(lpt);
3374   }
3375   return changed;
3376 }
3377 
3378 
3379 // Examine an inner loop looking for a a single store of an invariant
3380 // value in a unit stride loop,
3381 bool PhaseIdealLoop::match_fill_loop(IdealLoopTree* lpt, Node*&amp; store, Node*&amp; store_value,
</pre>
<hr />
<pre>
3603     if (msg != NULL) {
3604       tty-&gt;print_cr(&quot;no fill intrinsic: %s&quot;, msg);
3605       if (msg_node != NULL) msg_node-&gt;dump();
3606     } else {
3607       tty-&gt;print_cr(&quot;fill intrinsic for:&quot;);
3608     }
3609     store-&gt;dump();
3610     if (Verbose) {
3611       lpt-&gt;_body.dump();
3612     }
3613   }
3614 #endif
3615 
3616   return msg == NULL;
3617 }
3618 
3619 
3620 
3621 bool PhaseIdealLoop::intrinsify_fill(IdealLoopTree* lpt) {
3622   // Only for counted inner loops
<span class="line-modified">3623   if (!lpt-&gt;is_counted() || !lpt-&gt;is_innermost()) {</span>
3624     return false;
3625   }
3626 
3627   // Must have constant stride
3628   CountedLoopNode* head = lpt-&gt;_head-&gt;as_CountedLoop();
3629   if (!head-&gt;is_valid_counted_loop() || !head-&gt;is_normal_loop()) {
3630     return false;
3631   }
3632 
3633   head-&gt;verify_strip_mined(1);
3634 
3635   // Check that the body only contains a store of a loop invariant
3636   // value that is indexed by the loop phi.
3637   Node* store = NULL;
3638   Node* store_value = NULL;
3639   Node* shift = NULL;
3640   Node* offset = NULL;
3641   if (!match_fill_loop(lpt, store, store_value, shift, offset)) {
3642     return false;
3643   }
</pre>
</td>
</tr>
</table>
<center><a href="loopPredicate.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopUnswitch.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
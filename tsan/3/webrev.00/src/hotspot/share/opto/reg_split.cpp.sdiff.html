<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/reg_split.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="phasetype.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="regmask.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/reg_split.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1254               n-&gt;as_MachSpillCopy()-&gt;set_in_RegMask(def_rm);
1255               // Put the spill just before the copy
1256               insert_proj( b, insidx++, spill, maxlrg++ );
1257             }
1258           }
1259         }
1260       }
1261     }  // End For All Instructions in Block - Non-PHI Pass
1262 
1263     // Check if each LRG is live out of this block so as not to propagate
1264     // beyond the last use of a LRG.
1265     for( slidx = 0; slidx &lt; spill_cnt; slidx++ ) {
1266       uint defidx = lidxs.at(slidx);
1267       IndexSet *liveout = _live-&gt;live(b);
1268       if( !liveout-&gt;member(defidx) ) {
1269 #ifdef ASSERT
1270         // The index defidx is not live.  Check the liveout array to ensure that
1271         // it contains no members which compress to defidx.  Finding such an
1272         // instance may be a case to add liveout adjustment in compress_uf_map().
1273         // See 5063219.
<span class="line-modified">1274         uint member;</span>
<span class="line-modified">1275         IndexSetIterator isi(liveout);</span>
<span class="line-modified">1276         while ((member = isi.next()) != 0) {</span>
<span class="line-modified">1277           assert(defidx != _lrg_map.find_const(member), &quot;Live out member has not been compressed&quot;);</span>


1278         }
1279 #endif
1280         Reachblock[slidx] = NULL;
1281       } else {
1282         assert(Reachblock[slidx] != NULL,&quot;No reaching definition for liveout value&quot;);
1283       }
1284     }
1285 #ifndef PRODUCT
1286     if( trace_spilling() )
1287       b-&gt;dump();
1288 #endif
1289   }  // End For All Blocks
1290 
1291   //----------PASS 2----------
1292   // Reset all DEF live range numbers here
1293   for( insidx = 0; insidx &lt; defs-&gt;size(); insidx++ ) {
1294     // Grab the def
1295     n1 = defs-&gt;at(insidx);
1296     // Set new lidx for DEF
1297     new_lrg(n1, maxlrg++);
</pre>
</td>
<td>
<hr />
<pre>
1254               n-&gt;as_MachSpillCopy()-&gt;set_in_RegMask(def_rm);
1255               // Put the spill just before the copy
1256               insert_proj( b, insidx++, spill, maxlrg++ );
1257             }
1258           }
1259         }
1260       }
1261     }  // End For All Instructions in Block - Non-PHI Pass
1262 
1263     // Check if each LRG is live out of this block so as not to propagate
1264     // beyond the last use of a LRG.
1265     for( slidx = 0; slidx &lt; spill_cnt; slidx++ ) {
1266       uint defidx = lidxs.at(slidx);
1267       IndexSet *liveout = _live-&gt;live(b);
1268       if( !liveout-&gt;member(defidx) ) {
1269 #ifdef ASSERT
1270         // The index defidx is not live.  Check the liveout array to ensure that
1271         // it contains no members which compress to defidx.  Finding such an
1272         // instance may be a case to add liveout adjustment in compress_uf_map().
1273         // See 5063219.
<span class="line-modified">1274         if (!liveout-&gt;is_empty()) {</span>
<span class="line-modified">1275           uint member;</span>
<span class="line-modified">1276           IndexSetIterator isi(liveout);</span>
<span class="line-modified">1277           while ((member = isi.next()) != 0) {</span>
<span class="line-added">1278             assert(defidx != _lrg_map.find_const(member), &quot;Live out member has not been compressed&quot;);</span>
<span class="line-added">1279           }</span>
1280         }
1281 #endif
1282         Reachblock[slidx] = NULL;
1283       } else {
1284         assert(Reachblock[slidx] != NULL,&quot;No reaching definition for liveout value&quot;);
1285       }
1286     }
1287 #ifndef PRODUCT
1288     if( trace_spilling() )
1289       b-&gt;dump();
1290 #endif
1291   }  // End For All Blocks
1292 
1293   //----------PASS 2----------
1294   // Reset all DEF live range numbers here
1295   for( insidx = 0; insidx &lt; defs-&gt;size(); insidx++ ) {
1296     // Grab the def
1297     n1 = defs-&gt;at(insidx);
1298     // Set new lidx for DEF
1299     new_lrg(n1, maxlrg++);
</pre>
</td>
</tr>
</table>
<center><a href="phasetype.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="regmask.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/opto/phaseX.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="phase.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="phaseX.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/phaseX.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -37,10 +37,11 @@</span>
  #include &quot;opto/opcodes.hpp&quot;
  #include &quot;opto/phaseX.hpp&quot;
  #include &quot;opto/regalloc.hpp&quot;
  #include &quot;opto/rootnode.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
<span class="udiff-line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  //=============================================================================
  #define NODE_HASH_MINIMUM_SIZE    255
  //------------------------------NodeHash---------------------------------------
  NodeHash::NodeHash(uint est_max_size) :
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -238,16 +239,10 @@</span>
      debug_only( counter++ );
      NOT_PRODUCT( _delete_probes++ );
      k = _table[key];            // Get hashed value
      if( !k ) {                  // Miss?
        NOT_PRODUCT( _delete_misses++ );
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-       if( VerifyOpto ) {</span>
<span class="udiff-line-removed">-         for( uint i=0; i &lt; _max; i++ )</span>
<span class="udiff-line-removed">-           assert( _table[i] != n, &quot;changed edges with rehashing&quot; );</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">- #endif</span>
        return false;             // Miss! Not in chain
      }
      else if( n == k ) {
        NOT_PRODUCT( _delete_hits++ );
        _table[key] = _sentinel;  // Hit! Label as deleted entry
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -264,16 +259,13 @@</span>
    return false;
  }
  
  //------------------------------round_up---------------------------------------
  // Round up to nearest power of 2
<span class="udiff-line-modified-removed">- uint NodeHash::round_up( uint x ) {</span>
<span class="udiff-line-modified-removed">-   x += (x&gt;&gt;2);                  // Add 25% slop</span>
<span class="udiff-line-modified-removed">-   if( x &lt;16 ) return 16;        // Small stuff</span>
<span class="udiff-line-removed">-   uint i=16;</span>
<span class="udiff-line-removed">-   while( i &lt; x ) i &lt;&lt;= 1;       // Double to fit</span>
<span class="udiff-line-removed">-   return i;                     // Return hash table size</span>
<span class="udiff-line-modified-added">+ uint NodeHash::round_up(uint x) {</span>
<span class="udiff-line-modified-added">+   x += (x &gt;&gt; 2);                  // Add 25% slop</span>
<span class="udiff-line-modified-added">+   return MAX2(16U, round_up_power_of_2(x));</span>
  }
  
  //------------------------------grow-------------------------------------------
  // Grow _table to next power of 2 and insert old entries
  void  NodeHash::grow() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -705,17 +697,10 @@</span>
  PhaseValues::PhaseValues( PhaseValues *ptv ) : PhaseTransform( ptv, GVN ),
    _table(&amp;ptv-&gt;_table) {
    NOT_PRODUCT( clear_new_values(); )
  }
  
<span class="udiff-line-removed">- //------------------------------PhaseValues------------------------------------</span>
<span class="udiff-line-removed">- // Used by +VerifyOpto.  Clear out hash table but copy _types array.</span>
<span class="udiff-line-removed">- PhaseValues::PhaseValues( PhaseValues *ptv, const char *dummy ) : PhaseTransform( ptv, GVN ),</span>
<span class="udiff-line-removed">-   _table(ptv-&gt;arena(),ptv-&gt;_table.size()) {</span>
<span class="udiff-line-removed">-   NOT_PRODUCT( clear_new_values(); )</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  //------------------------------~PhaseValues-----------------------------------
  #ifndef PRODUCT
  PhaseValues::~PhaseValues() {
    _table.dump();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -821,18 +806,10 @@</span>
      i = k-&gt;Ideal(this, can_reshape);
    }
    return i;
  }
  
<span class="udiff-line-removed">- Node* PhaseGVN::apply_identity(Node* k) {</span>
<span class="udiff-line-removed">-   Node* i = BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;identity_node(this, k);</span>
<span class="udiff-line-removed">-   if (i == k) {</span>
<span class="udiff-line-removed">-     i = k-&gt;Identity(this);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return i;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  //------------------------------transform--------------------------------------
  // Return a node which computes the same function as this node, but in a
  // faster or cheaper fashion.
  Node *PhaseGVN::transform( Node *n ) {
    return transform_no_reclaim(n);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -883,11 +860,11 @@</span>
      NOT_PRODUCT( set_progress(); )
      return makecon(t);          // Turn into a constant
    }
  
    // Now check for Identities
<span class="udiff-line-modified-removed">-   Node *i = apply_identity(k);  // Look for a nearby replacement</span>
<span class="udiff-line-modified-added">+   Node *i = k-&gt;Identity(this);  // Look for a nearby replacement</span>
    if( i != k ) {                // Found? Return replacement!
      NOT_PRODUCT( set_progress(); )
      return i;
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -902,19 +879,22 @@</span>
    // Return Idealized original
    return k;
  }
  
  bool PhaseGVN::is_dominator_helper(Node *d, Node *n, bool linear_only) {
<span class="udiff-line-modified-removed">-   if (d-&gt;is_top() || n-&gt;is_top()) {</span>
<span class="udiff-line-modified-added">+   if (d-&gt;is_top() || (d-&gt;is_Proj() &amp;&amp; d-&gt;in(0)-&gt;is_top())) {</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (n-&gt;is_top() || (n-&gt;is_Proj() &amp;&amp; n-&gt;in(0)-&gt;is_top())) {</span>
      return false;
    }
    assert(d-&gt;is_CFG() &amp;&amp; n-&gt;is_CFG(), &quot;must have CFG nodes&quot;);
    int i = 0;
    while (d != n) {
      n = IfNode::up_one_dom(n, linear_only);
      i++;
<span class="udiff-line-modified-removed">-     if (n == NULL || i &gt;= 10) {</span>
<span class="udiff-line-modified-added">+     if (n == NULL || i &gt;= 100) {</span>
        return false;
      }
    }
    return true;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -946,18 +926,10 @@</span>
    }
  }
  #endif
  
  //=============================================================================
<span class="udiff-line-removed">- //------------------------------PhaseIterGVN-----------------------------------</span>
<span class="udiff-line-removed">- // Initialize hash table to fresh and clean for +VerifyOpto</span>
<span class="udiff-line-removed">- PhaseIterGVN::PhaseIterGVN( PhaseIterGVN *igvn, const char *dummy ) : PhaseGVN(igvn,dummy),</span>
<span class="udiff-line-removed">-                                                                       _delay_transform(false),</span>
<span class="udiff-line-removed">-                                                                       _stack(C-&gt;live_nodes() &gt;&gt; 1),</span>
<span class="udiff-line-removed">-                                                                       _worklist( ) {</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  //------------------------------PhaseIterGVN-----------------------------------
  // Initialize with previous PhaseIterGVN info; used by PhaseCCP
  PhaseIterGVN::PhaseIterGVN( PhaseIterGVN *igvn ) : PhaseGVN(igvn),
                                                     _delay_transform(igvn-&gt;_delay_transform),
                                                     _stack( igvn-&gt;_stack ),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1001,13 +973,10 @@</span>
      if( uop == Op_Phi || uop == Op_Region ||
          n-&gt;is_Type() ||
          n-&gt;is_Mem() )
        add_users_to_worklist(n);
    }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="udiff-line-removed">-   bs-&gt;add_users_to_worklist(&amp;_worklist);</span>
  }
  
  /**
   * Initialize worklist for each node.
   */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1135,28 +1104,10 @@</span>
      }
    }
  #endif
  
    C-&gt;verify_graph_edges();
<span class="udiff-line-removed">-   if( VerifyOpto &amp;&amp; allow_progress() ) {</span>
<span class="udiff-line-removed">-     // Must turn off allow_progress to enable assert and break recursion</span>
<span class="udiff-line-removed">-     C-&gt;root()-&gt;verify();</span>
<span class="udiff-line-removed">-     { // Check if any progress was missed using IterGVN</span>
<span class="udiff-line-removed">-       // Def-Use info enables transformations not attempted in wash-pass</span>
<span class="udiff-line-removed">-       // e.g. Region/Phi cleanup, ...</span>
<span class="udiff-line-removed">-       // Null-check elision -- may not have reached fixpoint</span>
<span class="udiff-line-removed">-       //                       do not propagate to dominated nodes</span>
<span class="udiff-line-removed">-       ResourceMark rm;</span>
<span class="udiff-line-removed">-       PhaseIterGVN igvn2(this,&quot;Verify&quot;); // Fresh and clean!</span>
<span class="udiff-line-removed">-       // Fill worklist completely</span>
<span class="udiff-line-removed">-       igvn2.init_worklist(C-&gt;root());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       igvn2.set_allow_progress(false);</span>
<span class="udiff-line-removed">-       igvn2.optimize();</span>
<span class="udiff-line-removed">-       igvn2.set_allow_progress(true);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
    if (VerifyIterativeGVN &amp;&amp; PrintOpto) {
      if (_verify_counter == _verify_full_passes) {
        tty-&gt;print_cr(&quot;VerifyIterativeGVN: %d transforms and verify passes&quot;,
                      (int) _verify_full_passes);
      } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1277,26 +1228,10 @@</span>
    C-&gt;remove_modified_node(k);
    Node* i = apply_ideal(k, /*can_reshape=*/true);
    assert(i != k || is_new || i-&gt;outcnt() &gt; 0, &quot;don&#39;t return dead nodes&quot;);
  #ifndef PRODUCT
    verify_step(k);
<span class="udiff-line-removed">-   if (i &amp;&amp; VerifyOpto ) {</span>
<span class="udiff-line-removed">-     if (!allow_progress()) {</span>
<span class="udiff-line-removed">-       if (i-&gt;is_Add() &amp;&amp; (i-&gt;outcnt() == 1)) {</span>
<span class="udiff-line-removed">-         // Switched input to left side because this is the only use</span>
<span class="udiff-line-removed">-       } else if (i-&gt;is_If() &amp;&amp; (i-&gt;in(0) == NULL)) {</span>
<span class="udiff-line-removed">-         // This IF is dead because it is dominated by an equivalent IF When</span>
<span class="udiff-line-removed">-         // dominating if changed, info is not propagated sparsely to &#39;this&#39;</span>
<span class="udiff-line-removed">-         // Propagating this info further will spuriously identify other</span>
<span class="udiff-line-removed">-         // progress.</span>
<span class="udiff-line-removed">-         return i;</span>
<span class="udiff-line-removed">-       } else</span>
<span class="udiff-line-removed">-         set_progress();</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       set_progress();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
  #endif
  
    while (i != NULL) {
  #ifdef ASSERT
      if (loop_count &gt;= K) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1319,13 +1254,10 @@</span>
      C-&gt;remove_modified_node(k);
      i = apply_ideal(k, /*can_reshape=*/true);
      assert(i != k || is_new || (i-&gt;outcnt() &gt; 0), &quot;don&#39;t return dead nodes&quot;);
  #ifndef PRODUCT
      verify_step(k);
<span class="udiff-line-removed">-     if (i &amp;&amp; VerifyOpto) {</span>
<span class="udiff-line-removed">-       set_progress();</span>
<span class="udiff-line-removed">-     }</span>
  #endif
    }
  
    // If brand new node, make space in type array.
    ensure_type_or_null(k);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1357,11 +1289,11 @@</span>
      subsume_node(k, con);       // Everybody using k now uses con
      return con;
    }
  
    // Now check for Identities
<span class="udiff-line-modified-removed">-   i = apply_identity(k);      // Look for a nearby replacement</span>
<span class="udiff-line-modified-added">+   i = k-&gt;Identity(this);      // Look for a nearby replacement</span>
    if (i != k) {                // Found? Return replacement!
      NOT_PRODUCT(set_progress();)
      add_users_to_worklist(k);
      subsume_node(k, i);       // Everybody using k now uses i
      return i;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1707,18 +1639,18 @@</span>
      }
      // Loading the java mirror from a Klass requires two loads and the type
      // of the mirror load depends on the type of &#39;n&#39;. See LoadNode::Value().
      //   LoadBarrier?(LoadP(LoadP(AddP(foo:Klass, #java_mirror))))
      BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
<span class="udiff-line-modified-removed">-     bool has_load_barriers = bs-&gt;has_load_barriers();</span>
<span class="udiff-line-modified-added">+     bool has_load_barrier_nodes = bs-&gt;has_load_barrier_nodes();</span>
  
      if (use_op == Op_LoadP &amp;&amp; use-&gt;bottom_type()-&gt;isa_rawptr()) {
        for (DUIterator_Fast i2max, i2 = use-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
          Node* u = use-&gt;fast_out(i2);
          const Type* ut = u-&gt;bottom_type();
          if (u-&gt;Opcode() == Op_LoadP &amp;&amp; ut-&gt;isa_instptr()) {
<span class="udiff-line-modified-removed">-           if (has_load_barriers) {</span>
<span class="udiff-line-modified-added">+           if (has_load_barrier_nodes) {</span>
              // Search for load barriers behind the load
              for (DUIterator_Fast i3max, i3 = u-&gt;fast_outs(i3max); i3 &lt; i3max; i3++) {
                Node* b = u-&gt;fast_out(i3);
                if (bs-&gt;is_gc_barrier_node(b)) {
                  _worklist.push(b);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1727,12 +1659,10 @@</span>
            }
            _worklist.push(u);
          }
        }
      }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;igvn_add_users_to_worklist(this, use);</span>
    }
  }
  
  /**
   * Remove the speculative part of all types that we know of
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1830,12 +1760,15 @@</span>
          // receiver to know when to enable the regular fall-through path
          // in addition to the NullPtrException path
          if (m-&gt;is_Call()) {
            for (DUIterator_Fast i2max, i2 = m-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
              Node* p = m-&gt;fast_out(i2);  // Propagate changes to uses
<span class="udiff-line-modified-removed">-             if (p-&gt;is_Proj() &amp;&amp; p-&gt;as_Proj()-&gt;_con == TypeFunc::Control &amp;&amp; p-&gt;outcnt() == 1) {</span>
<span class="udiff-line-modified-removed">-               worklist.push(p-&gt;unique_out());</span>
<span class="udiff-line-modified-added">+             if (p-&gt;is_Proj() &amp;&amp; p-&gt;as_Proj()-&gt;_con == TypeFunc::Control) {</span>
<span class="udiff-line-modified-added">+               Node* catch_node = p-&gt;find_out_with(Op_Catch);</span>
<span class="udiff-line-added">+               if (catch_node != NULL) {</span>
<span class="udiff-line-added">+                 worklist.push(catch_node);</span>
<span class="udiff-line-added">+               }</span>
              }
            }
          }
          if (m-&gt;bottom_type() != type(m)) { // If not already bottomed out
            worklist.push(m);     // Propagate change to user
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1867,18 +1800,18 @@</span>
            }
          }
          // Loading the java mirror from a Klass requires two loads and the type
          // of the mirror load depends on the type of &#39;n&#39;. See LoadNode::Value().
          BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
<span class="udiff-line-modified-removed">-         bool has_load_barriers = bs-&gt;has_load_barriers();</span>
<span class="udiff-line-modified-added">+         bool has_load_barrier_nodes = bs-&gt;has_load_barrier_nodes();</span>
  
          if (m_op == Op_LoadP &amp;&amp; m-&gt;bottom_type()-&gt;isa_rawptr()) {
            for (DUIterator_Fast i2max, i2 = m-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
              Node* u = m-&gt;fast_out(i2);
              const Type* ut = u-&gt;bottom_type();
              if (u-&gt;Opcode() == Op_LoadP &amp;&amp; ut-&gt;isa_instptr() &amp;&amp; ut != type(u)) {
<span class="udiff-line-modified-removed">-               if (has_load_barriers) {</span>
<span class="udiff-line-modified-added">+               if (has_load_barrier_nodes) {</span>
                  // Search for load barriers behind the load
                  for (DUIterator_Fast i3max, i3 = u-&gt;fast_outs(i3max); i3 &lt; i3max; i3++) {
                    Node* b = u-&gt;fast_out(i3);
                    if (bs-&gt;is_gc_barrier_node(b)) {
                      worklist.push(b);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1887,12 +1820,10 @@</span>
                }
                worklist.push(u);
              }
            }
          }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;ccp_analyze(this, worklist, m);</span>
        }
      }
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2194,11 +2125,11 @@</span>
      _max = 1;
      _types = (const Type**)_a-&gt;Amalloc( _max * sizeof(Type*) );
      _types[0] = NULL;
    }
    uint old = _max;
<span class="udiff-line-modified-removed">-   while( i &gt;= _max ) _max &lt;&lt;= 1;        // Double to fit</span>
<span class="udiff-line-modified-added">+   _max = next_power_of_2(i);</span>
    _types = (const Type**)_a-&gt;Arealloc( _types, old*sizeof(Type*),_max*sizeof(Type*));
    memset( &amp;_types[old], 0, (_max-old)*sizeof(Type*) );
  }
  
  //------------------------------dump-------------------------------------------
</pre>
<center><a href="phase.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="phaseX.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
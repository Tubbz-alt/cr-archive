<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/phaseX.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="phase.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="phaseX.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/phaseX.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/shared/barrierSet.hpp&quot;
  27 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  28 #include &quot;memory/allocation.inline.hpp&quot;
  29 #include &quot;memory/resourceArea.hpp&quot;
  30 #include &quot;opto/block.hpp&quot;
  31 #include &quot;opto/callnode.hpp&quot;
  32 #include &quot;opto/castnode.hpp&quot;
  33 #include &quot;opto/cfgnode.hpp&quot;
  34 #include &quot;opto/idealGraphPrinter.hpp&quot;
  35 #include &quot;opto/loopnode.hpp&quot;
  36 #include &quot;opto/machnode.hpp&quot;
  37 #include &quot;opto/opcodes.hpp&quot;
  38 #include &quot;opto/phaseX.hpp&quot;
  39 #include &quot;opto/regalloc.hpp&quot;
  40 #include &quot;opto/rootnode.hpp&quot;
  41 #include &quot;utilities/macros.hpp&quot;

  42 
  43 //=============================================================================
  44 #define NODE_HASH_MINIMUM_SIZE    255
  45 //------------------------------NodeHash---------------------------------------
  46 NodeHash::NodeHash(uint est_max_size) :
  47   _a(Thread::current()-&gt;resource_area()),
  48   _max( round_up(est_max_size &lt; NODE_HASH_MINIMUM_SIZE ? NODE_HASH_MINIMUM_SIZE : est_max_size) ),
  49   _inserts(0), _insert_limit( insert_limit() ),
  50   _table( NEW_ARENA_ARRAY( _a , Node* , _max ) ) // (Node**)_a-&gt;Amalloc(_max * sizeof(Node*)) ),
  51 #ifndef PRODUCT
  52   , _grows(0),_look_probes(0), _lookup_hits(0), _lookup_misses(0),
  53   _insert_probes(0), _delete_probes(0), _delete_hits(0), _delete_misses(0),
  54    _total_inserts(0), _total_insert_probes(0)
  55 #endif
  56 {
  57   // _sentinel must be in the current node space
  58   _sentinel = new ProjNode(NULL, TypeFunc::Control);
  59   memset(_table,0,sizeof(Node*)*_max);
  60 }
  61 
</pre>
<hr />
<pre>
 223 }
 224 
 225 //------------------------------hash_delete------------------------------------
 226 // Replace in hash table with sentinel
 227 bool NodeHash::hash_delete( const Node *n ) {
 228   Node *k;
 229   uint hash = n-&gt;hash();
 230   if (hash == Node::NO_HASH) {
 231     NOT_PRODUCT( _delete_misses++ );
 232     return false;
 233   }
 234   uint key = hash &amp; (_max-1);
 235   uint stride = key | 0x01;
 236   debug_only( uint counter = 0; );
 237   for( ; /* (k != NULL) &amp;&amp; (k != _sentinel) */; ) {
 238     debug_only( counter++ );
 239     NOT_PRODUCT( _delete_probes++ );
 240     k = _table[key];            // Get hashed value
 241     if( !k ) {                  // Miss?
 242       NOT_PRODUCT( _delete_misses++ );
<span class="line-removed"> 243 #ifdef ASSERT</span>
<span class="line-removed"> 244       if( VerifyOpto ) {</span>
<span class="line-removed"> 245         for( uint i=0; i &lt; _max; i++ )</span>
<span class="line-removed"> 246           assert( _table[i] != n, &quot;changed edges with rehashing&quot; );</span>
<span class="line-removed"> 247       }</span>
<span class="line-removed"> 248 #endif</span>
 249       return false;             // Miss! Not in chain
 250     }
 251     else if( n == k ) {
 252       NOT_PRODUCT( _delete_hits++ );
 253       _table[key] = _sentinel;  // Hit! Label as deleted entry
 254       debug_only(((Node*)n)-&gt;exit_hash_lock()); // Unlock the node upon removal from table.
 255       return true;
 256     }
 257     else {
 258       // collision: move through table with prime offset
 259       key = (key + stride/*7*/) &amp; (_max-1);
 260       assert( counter &lt;= _insert_limit, &quot;Cycle in hash-table&quot;);
 261     }
 262   }
 263   ShouldNotReachHere();
 264   return false;
 265 }
 266 
 267 //------------------------------round_up---------------------------------------
 268 // Round up to nearest power of 2
<span class="line-modified"> 269 uint NodeHash::round_up( uint x ) {</span>
<span class="line-modified"> 270   x += (x&gt;&gt;2);                  // Add 25% slop</span>
<span class="line-modified"> 271   if( x &lt;16 ) return 16;        // Small stuff</span>
<span class="line-removed"> 272   uint i=16;</span>
<span class="line-removed"> 273   while( i &lt; x ) i &lt;&lt;= 1;       // Double to fit</span>
<span class="line-removed"> 274   return i;                     // Return hash table size</span>
 275 }
 276 
 277 //------------------------------grow-------------------------------------------
 278 // Grow _table to next power of 2 and insert old entries
 279 void  NodeHash::grow() {
 280   // Record old state
 281   uint   old_max   = _max;
 282   Node **old_table = _table;
 283   // Construct new table with twice the space
 284 #ifndef PRODUCT
 285   _grows++;
 286   _total_inserts       += _inserts;
 287   _total_insert_probes += _insert_probes;
 288   _insert_probes   = 0;
 289 #endif
 290   _inserts         = 0;
 291   _max     = _max &lt;&lt; 1;
 292   _table   = NEW_ARENA_ARRAY( _a , Node* , _max ); // (Node**)_a-&gt;Amalloc( _max * sizeof(Node*) );
 293   memset(_table,0,sizeof(Node*)*_max);
 294   _insert_limit = insert_limit();
</pre>
<hr />
<pre>
 690   }
 691 }
 692 
 693 #endif
 694 
 695 
 696 //=============================================================================
 697 //------------------------------PhaseValues------------------------------------
 698 // Set minimum table size to &quot;255&quot;
 699 PhaseValues::PhaseValues( Arena *arena, uint est_max_size ) : PhaseTransform(arena, GVN), _table(arena, est_max_size) {
 700   NOT_PRODUCT( clear_new_values(); )
 701 }
 702 
 703 //------------------------------PhaseValues------------------------------------
 704 // Set minimum table size to &quot;255&quot;
 705 PhaseValues::PhaseValues( PhaseValues *ptv ) : PhaseTransform( ptv, GVN ),
 706   _table(&amp;ptv-&gt;_table) {
 707   NOT_PRODUCT( clear_new_values(); )
 708 }
 709 
<span class="line-removed"> 710 //------------------------------PhaseValues------------------------------------</span>
<span class="line-removed"> 711 // Used by +VerifyOpto.  Clear out hash table but copy _types array.</span>
<span class="line-removed"> 712 PhaseValues::PhaseValues( PhaseValues *ptv, const char *dummy ) : PhaseTransform( ptv, GVN ),</span>
<span class="line-removed"> 713   _table(ptv-&gt;arena(),ptv-&gt;_table.size()) {</span>
<span class="line-removed"> 714   NOT_PRODUCT( clear_new_values(); )</span>
<span class="line-removed"> 715 }</span>
<span class="line-removed"> 716 </span>
 717 //------------------------------~PhaseValues-----------------------------------
 718 #ifndef PRODUCT
 719 PhaseValues::~PhaseValues() {
 720   _table.dump();
 721 
 722   // Statistics for value progress and efficiency
 723   if( PrintCompilation &amp;&amp; Verbose &amp;&amp; WizardMode ) {
 724     tty-&gt;print(&quot;\n%sValues: %d nodes ---&gt; %d/%d (%d)&quot;,
 725       is_IterGVN() ? &quot;Iter&quot; : &quot;    &quot;, C-&gt;unique(), made_progress(), made_transforms(), made_new_values());
 726     if( made_transforms() != 0 ) {
 727       tty-&gt;print_cr(&quot;  ratio %f&quot;, made_progress()/(float)made_transforms() );
 728     } else {
 729       tty-&gt;cr();
 730     }
 731   }
 732 }
 733 #endif
 734 
 735 //------------------------------makecon----------------------------------------
 736 ConNode* PhaseTransform::makecon(const Type *t) {
</pre>
<hr />
<pre>
 806   assert((uint)bt &lt;= _zcon_max, &quot;domain check&quot;);
 807   ConNode* zcon = _zcons[bt];
 808   if (zcon != NULL &amp;&amp; zcon-&gt;in(TypeFunc::Control) != NULL)
 809     return zcon;
 810   zcon = (ConNode*) uncached_makecon(Type::get_zero_type(bt));
 811   _zcons[bt] = zcon;
 812   return zcon;
 813 }
 814 
 815 
 816 
 817 //=============================================================================
 818 Node* PhaseGVN::apply_ideal(Node* k, bool can_reshape) {
 819   Node* i = BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;ideal_node(this, k, can_reshape);
 820   if (i == NULL) {
 821     i = k-&gt;Ideal(this, can_reshape);
 822   }
 823   return i;
 824 }
 825 
<span class="line-removed"> 826 Node* PhaseGVN::apply_identity(Node* k) {</span>
<span class="line-removed"> 827   Node* i = BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;identity_node(this, k);</span>
<span class="line-removed"> 828   if (i == k) {</span>
<span class="line-removed"> 829     i = k-&gt;Identity(this);</span>
<span class="line-removed"> 830   }</span>
<span class="line-removed"> 831   return i;</span>
<span class="line-removed"> 832 }</span>
<span class="line-removed"> 833 </span>
 834 //------------------------------transform--------------------------------------
 835 // Return a node which computes the same function as this node, but in a
 836 // faster or cheaper fashion.
 837 Node *PhaseGVN::transform( Node *n ) {
 838   return transform_no_reclaim(n);
 839 }
 840 
 841 //------------------------------transform--------------------------------------
 842 // Return a node which computes the same function as this node, but
 843 // in a faster or cheaper fashion.
 844 Node *PhaseGVN::transform_no_reclaim( Node *n ) {
 845   NOT_PRODUCT( set_transforms(); )
 846 
 847   // Apply the Ideal call in a loop until it no longer applies
 848   Node *k = n;
 849   NOT_PRODUCT( uint loop_count = 0; )
 850   while( 1 ) {
 851     Node *i = apply_ideal(k, /*can_reshape=*/false);
 852     if( !i ) break;
 853     assert( i-&gt;_idx &gt;= k-&gt;_idx, &quot;Idealize should return new nodes, use Identity to return old nodes&quot; );
</pre>
<hr />
<pre>
 868   assert(t != NULL, &quot;value sanity&quot;);
 869   if (type_or_null(k) != t) {
 870 #ifndef PRODUCT
 871     // Do not count initial visit to node as a transformation
 872     if (type_or_null(k) == NULL) {
 873       inc_new_values();
 874       set_progress();
 875     }
 876 #endif
 877     set_type(k, t);
 878     // If k is a TypeNode, capture any more-precise type permanently into Node
 879     k-&gt;raise_bottom_type(t);
 880   }
 881 
 882   if( t-&gt;singleton() &amp;&amp; !k-&gt;is_Con() ) {
 883     NOT_PRODUCT( set_progress(); )
 884     return makecon(t);          // Turn into a constant
 885   }
 886 
 887   // Now check for Identities
<span class="line-modified"> 888   Node *i = apply_identity(k);  // Look for a nearby replacement</span>
 889   if( i != k ) {                // Found? Return replacement!
 890     NOT_PRODUCT( set_progress(); )
 891     return i;
 892   }
 893 
 894   // Global Value Numbering
 895   i = hash_find_insert(k);      // Insert if new
 896   if( i &amp;&amp; (i != k) ) {
 897     // Return the pre-existing node
 898     NOT_PRODUCT( set_progress(); )
 899     return i;
 900   }
 901 
 902   // Return Idealized original
 903   return k;
 904 }
 905 
 906 bool PhaseGVN::is_dominator_helper(Node *d, Node *n, bool linear_only) {
<span class="line-modified"> 907   if (d-&gt;is_top() || n-&gt;is_top()) {</span>



 908     return false;
 909   }
 910   assert(d-&gt;is_CFG() &amp;&amp; n-&gt;is_CFG(), &quot;must have CFG nodes&quot;);
 911   int i = 0;
 912   while (d != n) {
 913     n = IfNode::up_one_dom(n, linear_only);
 914     i++;
<span class="line-modified"> 915     if (n == NULL || i &gt;= 10) {</span>
 916       return false;
 917     }
 918   }
 919   return true;
 920 }
 921 
 922 #ifdef ASSERT
 923 //------------------------------dead_loop_check--------------------------------
 924 // Check for a simple dead loop when a data node references itself directly
 925 // or through an other data node excluding cons and phis.
 926 void PhaseGVN::dead_loop_check( Node *n ) {
 927   // Phi may reference itself in a loop
 928   if (n != NULL &amp;&amp; !n-&gt;is_dead_loop_safe() &amp;&amp; !n-&gt;is_CFG()) {
 929     // Do 2 levels check and only data inputs.
 930     bool no_dead_loop = true;
 931     uint cnt = n-&gt;req();
 932     for (uint i = 1; i &lt; cnt &amp;&amp; no_dead_loop; i++) {
 933       Node *in = n-&gt;in(i);
 934       if (in == n) {
 935         no_dead_loop = false;
 936       } else if (in != NULL &amp;&amp; !in-&gt;is_dead_loop_safe()) {
 937         uint icnt = in-&gt;req();
 938         for (uint j = 1; j &lt; icnt &amp;&amp; no_dead_loop; j++) {
 939           if (in-&gt;in(j) == n || in-&gt;in(j) == in)
 940             no_dead_loop = false;
 941         }
 942       }
 943     }
 944     if (!no_dead_loop) n-&gt;dump(3);
 945     assert(no_dead_loop, &quot;dead loop detected&quot;);
 946   }
 947 }
 948 #endif
 949 
 950 //=============================================================================
<span class="line-removed"> 951 //------------------------------PhaseIterGVN-----------------------------------</span>
<span class="line-removed"> 952 // Initialize hash table to fresh and clean for +VerifyOpto</span>
<span class="line-removed"> 953 PhaseIterGVN::PhaseIterGVN( PhaseIterGVN *igvn, const char *dummy ) : PhaseGVN(igvn,dummy),</span>
<span class="line-removed"> 954                                                                       _delay_transform(false),</span>
<span class="line-removed"> 955                                                                       _stack(C-&gt;live_nodes() &gt;&gt; 1),</span>
<span class="line-removed"> 956                                                                       _worklist( ) {</span>
<span class="line-removed"> 957 }</span>
<span class="line-removed"> 958 </span>
 959 //------------------------------PhaseIterGVN-----------------------------------
 960 // Initialize with previous PhaseIterGVN info; used by PhaseCCP
 961 PhaseIterGVN::PhaseIterGVN( PhaseIterGVN *igvn ) : PhaseGVN(igvn),
 962                                                    _delay_transform(igvn-&gt;_delay_transform),
 963                                                    _stack( igvn-&gt;_stack ),
 964                                                    _worklist( igvn-&gt;_worklist )
 965 {
 966 }
 967 
 968 //------------------------------PhaseIterGVN-----------------------------------
 969 // Initialize with previous PhaseGVN info from Parser
 970 PhaseIterGVN::PhaseIterGVN( PhaseGVN *gvn ) : PhaseGVN(gvn),
 971                                               _delay_transform(false),
 972 // TODO: Before incremental inlining it was allocated only once and it was fine. Now that
 973 //       the constructor is used in incremental inlining, this consumes too much memory:
 974 //                                            _stack(C-&gt;live_nodes() &gt;&gt; 1),
 975 //       So, as a band-aid, we replace this by:
 976                                               _stack(C-&gt;comp_arena(), 32),
 977                                               _worklist(*C-&gt;for_igvn())
 978 {
</pre>
<hr />
<pre>
 986     Node *n = _table.at(i);
 987     if(n != NULL &amp;&amp; n != _table.sentinel() &amp;&amp; n-&gt;outcnt() == 0) {
 988       if( n-&gt;is_top() ) continue;
 989       assert( false, &quot;Parse::remove_useless_nodes missed this node&quot;);
 990       hash_delete(n);
 991     }
 992   }
 993 
 994   // Any Phis or Regions on the worklist probably had uses that could not
 995   // make more progress because the uses were made while the Phis and Regions
 996   // were in half-built states.  Put all uses of Phis and Regions on worklist.
 997   max = _worklist.size();
 998   for( uint j = 0; j &lt; max; j++ ) {
 999     Node *n = _worklist.at(j);
1000     uint uop = n-&gt;Opcode();
1001     if( uop == Op_Phi || uop == Op_Region ||
1002         n-&gt;is_Type() ||
1003         n-&gt;is_Mem() )
1004       add_users_to_worklist(n);
1005   }
<span class="line-removed">1006 </span>
<span class="line-removed">1007   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="line-removed">1008   bs-&gt;add_users_to_worklist(&amp;_worklist);</span>
1009 }
1010 
1011 /**
1012  * Initialize worklist for each node.
1013  */
1014 void PhaseIterGVN::init_worklist(Node* first) {
1015   Unique_Node_List to_process;
1016   to_process.push(first);
1017 
1018   while (to_process.size() &gt; 0) {
1019     Node* n = to_process.pop();
1020     if (!_worklist.member(n)) {
1021       _worklist.push(n);
1022 
1023       uint cnt = n-&gt;req();
1024       for(uint i = 0; i &lt; cnt; i++) {
1025         Node* m = n-&gt;in(i);
1026         if (m != NULL) {
1027           to_process.push(m);
1028         }
</pre>
<hr />
<pre>
1120       assert(false, &quot;modified node is not on IGVN._worklist&quot;);
1121     }
1122   }
1123 #endif
1124 }
1125 
1126 void PhaseIterGVN::verify_PhaseIterGVN() {
1127 #ifdef ASSERT
1128   // Verify nodes with changed inputs.
1129   Unique_Node_List* modified_list = C-&gt;modified_nodes();
1130   while (modified_list != NULL &amp;&amp; modified_list-&gt;size()) {
1131     Node* n = modified_list-&gt;pop();
1132     if (n-&gt;outcnt() != 0 &amp;&amp; !n-&gt;is_Con()) { // skip dead and Con nodes
1133       n-&gt;dump();
1134       assert(false, &quot;modified node was not processed by IGVN.transform_old()&quot;);
1135     }
1136   }
1137 #endif
1138 
1139   C-&gt;verify_graph_edges();
<span class="line-removed">1140   if( VerifyOpto &amp;&amp; allow_progress() ) {</span>
<span class="line-removed">1141     // Must turn off allow_progress to enable assert and break recursion</span>
<span class="line-removed">1142     C-&gt;root()-&gt;verify();</span>
<span class="line-removed">1143     { // Check if any progress was missed using IterGVN</span>
<span class="line-removed">1144       // Def-Use info enables transformations not attempted in wash-pass</span>
<span class="line-removed">1145       // e.g. Region/Phi cleanup, ...</span>
<span class="line-removed">1146       // Null-check elision -- may not have reached fixpoint</span>
<span class="line-removed">1147       //                       do not propagate to dominated nodes</span>
<span class="line-removed">1148       ResourceMark rm;</span>
<span class="line-removed">1149       PhaseIterGVN igvn2(this,&quot;Verify&quot;); // Fresh and clean!</span>
<span class="line-removed">1150       // Fill worklist completely</span>
<span class="line-removed">1151       igvn2.init_worklist(C-&gt;root());</span>
<span class="line-removed">1152 </span>
<span class="line-removed">1153       igvn2.set_allow_progress(false);</span>
<span class="line-removed">1154       igvn2.optimize();</span>
<span class="line-removed">1155       igvn2.set_allow_progress(true);</span>
<span class="line-removed">1156     }</span>
<span class="line-removed">1157   }</span>
1158   if (VerifyIterativeGVN &amp;&amp; PrintOpto) {
1159     if (_verify_counter == _verify_full_passes) {
1160       tty-&gt;print_cr(&quot;VerifyIterativeGVN: %d transforms and verify passes&quot;,
1161                     (int) _verify_full_passes);
1162     } else {
1163       tty-&gt;print_cr(&quot;VerifyIterativeGVN: %d transforms, %d full verify passes&quot;,
1164                   (int) _verify_counter, (int) _verify_full_passes);
1165     }
1166   }
1167 
1168 #ifdef ASSERT
1169   while (modified_list-&gt;size()) {
1170     Node* n = modified_list-&gt;pop();
1171     n-&gt;dump();
1172     assert(false, &quot;VerifyIterativeGVN: new modified node was added&quot;);
1173   }
1174 #endif
1175 }
1176 #endif /* PRODUCT */
1177 
</pre>
<hr />
<pre>
1262 
1263 Node *PhaseIterGVN::transform_old(Node* n) {
1264   DEBUG_ONLY(uint loop_count = 0;);
1265   NOT_PRODUCT(set_transforms());
1266 
1267   // Remove &#39;n&#39; from hash table in case it gets modified
1268   _table.hash_delete(n);
1269   if (VerifyIterativeGVN) {
1270    assert(!_table.find_index(n-&gt;_idx), &quot;found duplicate entry in table&quot;);
1271   }
1272 
1273   // Apply the Ideal call in a loop until it no longer applies
1274   Node* k = n;
1275   DEBUG_ONLY(dead_loop_check(k);)
1276   DEBUG_ONLY(bool is_new = (k-&gt;outcnt() == 0);)
1277   C-&gt;remove_modified_node(k);
1278   Node* i = apply_ideal(k, /*can_reshape=*/true);
1279   assert(i != k || is_new || i-&gt;outcnt() &gt; 0, &quot;don&#39;t return dead nodes&quot;);
1280 #ifndef PRODUCT
1281   verify_step(k);
<span class="line-removed">1282   if (i &amp;&amp; VerifyOpto ) {</span>
<span class="line-removed">1283     if (!allow_progress()) {</span>
<span class="line-removed">1284       if (i-&gt;is_Add() &amp;&amp; (i-&gt;outcnt() == 1)) {</span>
<span class="line-removed">1285         // Switched input to left side because this is the only use</span>
<span class="line-removed">1286       } else if (i-&gt;is_If() &amp;&amp; (i-&gt;in(0) == NULL)) {</span>
<span class="line-removed">1287         // This IF is dead because it is dominated by an equivalent IF When</span>
<span class="line-removed">1288         // dominating if changed, info is not propagated sparsely to &#39;this&#39;</span>
<span class="line-removed">1289         // Propagating this info further will spuriously identify other</span>
<span class="line-removed">1290         // progress.</span>
<span class="line-removed">1291         return i;</span>
<span class="line-removed">1292       } else</span>
<span class="line-removed">1293         set_progress();</span>
<span class="line-removed">1294     } else {</span>
<span class="line-removed">1295       set_progress();</span>
<span class="line-removed">1296     }</span>
<span class="line-removed">1297   }</span>
1298 #endif
1299 
1300   while (i != NULL) {
1301 #ifdef ASSERT
1302     if (loop_count &gt;= K) {
1303       dump_infinite_loop_info(i);
1304     }
1305     loop_count++;
1306 #endif
1307     assert((i-&gt;_idx &gt;= k-&gt;_idx) || i-&gt;is_top(), &quot;Idealize should return new nodes, use Identity to return old nodes&quot;);
1308     // Made a change; put users of original Node on worklist
1309     add_users_to_worklist(k);
1310     // Replacing root of transform tree?
1311     if (k != i) {
1312       // Make users of old Node now use new.
1313       subsume_node(k, i);
1314       k = i;
1315     }
1316     DEBUG_ONLY(dead_loop_check(k);)
1317     // Try idealizing again
1318     DEBUG_ONLY(is_new = (k-&gt;outcnt() == 0);)
1319     C-&gt;remove_modified_node(k);
1320     i = apply_ideal(k, /*can_reshape=*/true);
1321     assert(i != k || is_new || (i-&gt;outcnt() &gt; 0), &quot;don&#39;t return dead nodes&quot;);
1322 #ifndef PRODUCT
1323     verify_step(k);
<span class="line-removed">1324     if (i &amp;&amp; VerifyOpto) {</span>
<span class="line-removed">1325       set_progress();</span>
<span class="line-removed">1326     }</span>
1327 #endif
1328   }
1329 
1330   // If brand new node, make space in type array.
1331   ensure_type_or_null(k);
1332 
1333   // See what kind of values &#39;k&#39; takes on at runtime
1334   const Type* t = k-&gt;Value(this);
1335   assert(t != NULL, &quot;value sanity&quot;);
1336 
1337   // Since I just called &#39;Value&#39; to compute the set of run-time values
1338   // for this Node, and &#39;Value&#39; is non-local (and therefore expensive) I&#39;ll
1339   // cache Value.  Later requests for the local phase-&gt;type of this Node can
1340   // use the cached Value instead of suffering with &#39;bottom_type&#39;.
1341   if (type_or_null(k) != t) {
1342 #ifndef PRODUCT
1343     inc_new_values();
1344     set_progress();
1345 #endif
1346     set_type(k, t);
1347     // If k is a TypeNode, capture any more-precise type permanently into Node
1348     k-&gt;raise_bottom_type(t);
1349     // Move users of node to worklist
1350     add_users_to_worklist(k);
1351   }
1352   // If &#39;k&#39; computes a constant, replace it with a constant
1353   if (t-&gt;singleton() &amp;&amp; !k-&gt;is_Con()) {
1354     NOT_PRODUCT(set_progress();)
1355     Node* con = makecon(t);     // Make a constant
1356     add_users_to_worklist(k);
1357     subsume_node(k, con);       // Everybody using k now uses con
1358     return con;
1359   }
1360 
1361   // Now check for Identities
<span class="line-modified">1362   i = apply_identity(k);      // Look for a nearby replacement</span>
1363   if (i != k) {                // Found? Return replacement!
1364     NOT_PRODUCT(set_progress();)
1365     add_users_to_worklist(k);
1366     subsume_node(k, i);       // Everybody using k now uses i
1367     return i;
1368   }
1369 
1370   // Global Value Numbering
1371   i = hash_find_insert(k);      // Check for pre-existing node
1372   if (i &amp;&amp; (i != k)) {
1373     // Return the pre-existing node if it isn&#39;t dead
1374     NOT_PRODUCT(set_progress();)
1375     add_users_to_worklist(k);
1376     subsume_node(k, i);       // Everybody using k now uses i
1377     return i;
1378   }
1379 
1380   // Return Idealized original
1381   return k;
1382 }
</pre>
<hr />
<pre>
1692         if (u-&gt;is_Mem())
1693           _worklist.push(u);
1694       }
1695     }
1696     // If changed initialization activity, check dependent Stores
1697     if (use_op == Op_Allocate || use_op == Op_AllocateArray) {
1698       InitializeNode* init = use-&gt;as_Allocate()-&gt;initialization();
1699       if (init != NULL) {
1700         Node* imem = init-&gt;proj_out_or_null(TypeFunc::Memory);
1701         if (imem != NULL)  add_users_to_worklist0(imem);
1702       }
1703     }
1704     if (use_op == Op_Initialize) {
1705       Node* imem = use-&gt;as_Initialize()-&gt;proj_out_or_null(TypeFunc::Memory);
1706       if (imem != NULL)  add_users_to_worklist0(imem);
1707     }
1708     // Loading the java mirror from a Klass requires two loads and the type
1709     // of the mirror load depends on the type of &#39;n&#39;. See LoadNode::Value().
1710     //   LoadBarrier?(LoadP(LoadP(AddP(foo:Klass, #java_mirror))))
1711     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
<span class="line-modified">1712     bool has_load_barriers = bs-&gt;has_load_barriers();</span>
1713 
1714     if (use_op == Op_LoadP &amp;&amp; use-&gt;bottom_type()-&gt;isa_rawptr()) {
1715       for (DUIterator_Fast i2max, i2 = use-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1716         Node* u = use-&gt;fast_out(i2);
1717         const Type* ut = u-&gt;bottom_type();
1718         if (u-&gt;Opcode() == Op_LoadP &amp;&amp; ut-&gt;isa_instptr()) {
<span class="line-modified">1719           if (has_load_barriers) {</span>
1720             // Search for load barriers behind the load
1721             for (DUIterator_Fast i3max, i3 = u-&gt;fast_outs(i3max); i3 &lt; i3max; i3++) {
1722               Node* b = u-&gt;fast_out(i3);
1723               if (bs-&gt;is_gc_barrier_node(b)) {
1724                 _worklist.push(b);
1725               }
1726             }
1727           }
1728           _worklist.push(u);
1729         }
1730       }
1731     }
<span class="line-removed">1732 </span>
<span class="line-removed">1733     BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;igvn_add_users_to_worklist(this, use);</span>
1734   }
1735 }
1736 
1737 /**
1738  * Remove the speculative part of all types that we know of
1739  */
1740 void PhaseIterGVN::remove_speculative_types()  {
1741   assert(UseTypeSpeculation, &quot;speculation is off&quot;);
1742   for (uint i = 0; i &lt; _types.Size(); i++)  {
1743     const Type* t = _types.fast_lookup(i);
1744     if (t != NULL) {
1745       _types.map(i, t-&gt;remove_speculative());
1746     }
1747   }
1748   _table.check_no_speculative_types();
1749 }
1750 
1751 //=============================================================================
1752 #ifndef PRODUCT
1753 uint PhaseCCP::_total_invokes   = 0;
</pre>
<hr />
<pre>
1815       }
1816 #endif
1817       set_type(n, t);
1818       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1819         Node* m = n-&gt;fast_out(i);   // Get user
1820         if (m-&gt;is_Region()) {  // New path to Region?  Must recheck Phis too
1821           for (DUIterator_Fast i2max, i2 = m-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1822             Node* p = m-&gt;fast_out(i2); // Propagate changes to uses
1823             if (p-&gt;bottom_type() != type(p)) { // If not already bottomed out
1824               worklist.push(p); // Propagate change to user
1825             }
1826           }
1827         }
1828         // If we changed the receiver type to a call, we need to revisit
1829         // the Catch following the call.  It&#39;s looking for a non-NULL
1830         // receiver to know when to enable the regular fall-through path
1831         // in addition to the NullPtrException path
1832         if (m-&gt;is_Call()) {
1833           for (DUIterator_Fast i2max, i2 = m-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1834             Node* p = m-&gt;fast_out(i2);  // Propagate changes to uses
<span class="line-modified">1835             if (p-&gt;is_Proj() &amp;&amp; p-&gt;as_Proj()-&gt;_con == TypeFunc::Control &amp;&amp; p-&gt;outcnt() == 1) {</span>
<span class="line-modified">1836               worklist.push(p-&gt;unique_out());</span>



1837             }
1838           }
1839         }
1840         if (m-&gt;bottom_type() != type(m)) { // If not already bottomed out
1841           worklist.push(m);     // Propagate change to user
1842         }
1843 
1844         // CmpU nodes can get their type information from two nodes up in the
1845         // graph (instead of from the nodes immediately above). Make sure they
1846         // are added to the worklist if nodes they depend on are updated, since
1847         // they could be missed and get wrong types otherwise.
1848         uint m_op = m-&gt;Opcode();
1849         if (m_op == Op_AddI || m_op == Op_SubI) {
1850           for (DUIterator_Fast i2max, i2 = m-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1851             Node* p = m-&gt;fast_out(i2); // Propagate changes to uses
1852             if (p-&gt;Opcode() == Op_CmpU) {
1853               // Got a CmpU which might need the new type information from node n.
1854               if(p-&gt;bottom_type() != type(p)) { // If not already bottomed out
1855                 worklist.push(p); // Propagate change to user
1856               }
1857             }
1858           }
1859         }
1860         // If n is used in a counted loop exit condition then the type
1861         // of the counted loop&#39;s Phi depends on the type of n. See
1862         // PhiNode::Value().
1863         if (m_op == Op_CmpI) {
1864           PhiNode* phi = countedloop_phi_from_cmp((CmpINode*)m, n);
1865           if (phi != NULL) {
1866             worklist.push(phi);
1867           }
1868         }
1869         // Loading the java mirror from a Klass requires two loads and the type
1870         // of the mirror load depends on the type of &#39;n&#39;. See LoadNode::Value().
1871         BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
<span class="line-modified">1872         bool has_load_barriers = bs-&gt;has_load_barriers();</span>
1873 
1874         if (m_op == Op_LoadP &amp;&amp; m-&gt;bottom_type()-&gt;isa_rawptr()) {
1875           for (DUIterator_Fast i2max, i2 = m-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1876             Node* u = m-&gt;fast_out(i2);
1877             const Type* ut = u-&gt;bottom_type();
1878             if (u-&gt;Opcode() == Op_LoadP &amp;&amp; ut-&gt;isa_instptr() &amp;&amp; ut != type(u)) {
<span class="line-modified">1879               if (has_load_barriers) {</span>
1880                 // Search for load barriers behind the load
1881                 for (DUIterator_Fast i3max, i3 = u-&gt;fast_outs(i3max); i3 &lt; i3max; i3++) {
1882                   Node* b = u-&gt;fast_out(i3);
1883                   if (bs-&gt;is_gc_barrier_node(b)) {
1884                     worklist.push(b);
1885                   }
1886                 }
1887               }
1888               worklist.push(u);
1889             }
1890           }
1891         }
<span class="line-removed">1892 </span>
<span class="line-removed">1893         BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;ccp_analyze(this, worklist, m);</span>
1894       }
1895     }
1896   }
1897 }
1898 
1899 //------------------------------do_transform-----------------------------------
1900 // Top level driver for the recursive transformer
1901 void PhaseCCP::do_transform() {
1902   // Correct leaves of new-space Nodes; they point to old-space.
1903   C-&gt;set_root( transform(C-&gt;root())-&gt;as_Root() );
1904   assert( C-&gt;top(),  &quot;missing TOP node&quot; );
1905   assert( C-&gt;root(), &quot;missing root&quot; );
1906 }
1907 
1908 //------------------------------transform--------------------------------------
1909 // Given a Node in old-space, clone him into new-space.
1910 // Convert any of his old-space children into new-space children.
1911 Node *PhaseCCP::transform( Node *n ) {
1912   Node *new_node = _nodes[n-&gt;_idx]; // Check for transformed node
1913   if( new_node != NULL )
</pre>
<hr />
<pre>
2179       if (use-&gt;in(j) == this) {
2180         if (j &lt; use-&gt;req())
2181               use-&gt;set_req(j, new_node);
2182         else  use-&gt;set_prec(j, new_node);
2183         uses_found++;
2184       }
2185     }
2186     i -= uses_found;    // we deleted 1 or more copies of this edge
2187   }
2188 }
2189 
2190 //=============================================================================
2191 //-----------------------------------------------------------------------------
2192 void Type_Array::grow( uint i ) {
2193   if( !_max ) {
2194     _max = 1;
2195     _types = (const Type**)_a-&gt;Amalloc( _max * sizeof(Type*) );
2196     _types[0] = NULL;
2197   }
2198   uint old = _max;
<span class="line-modified">2199   while( i &gt;= _max ) _max &lt;&lt;= 1;        // Double to fit</span>
2200   _types = (const Type**)_a-&gt;Arealloc( _types, old*sizeof(Type*),_max*sizeof(Type*));
2201   memset( &amp;_types[old], 0, (_max-old)*sizeof(Type*) );
2202 }
2203 
2204 //------------------------------dump-------------------------------------------
2205 #ifndef PRODUCT
2206 void Type_Array::dump() const {
2207   uint max = Size();
2208   for( uint i = 0; i &lt; max; i++ ) {
2209     if( _types[i] != NULL ) {
2210       tty-&gt;print(&quot;  %d\t== &quot;, i); _types[i]-&gt;dump(); tty-&gt;cr();
2211     }
2212   }
2213 }
2214 #endif
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/shared/barrierSet.hpp&quot;
  27 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  28 #include &quot;memory/allocation.inline.hpp&quot;
  29 #include &quot;memory/resourceArea.hpp&quot;
  30 #include &quot;opto/block.hpp&quot;
  31 #include &quot;opto/callnode.hpp&quot;
  32 #include &quot;opto/castnode.hpp&quot;
  33 #include &quot;opto/cfgnode.hpp&quot;
  34 #include &quot;opto/idealGraphPrinter.hpp&quot;
  35 #include &quot;opto/loopnode.hpp&quot;
  36 #include &quot;opto/machnode.hpp&quot;
  37 #include &quot;opto/opcodes.hpp&quot;
  38 #include &quot;opto/phaseX.hpp&quot;
  39 #include &quot;opto/regalloc.hpp&quot;
  40 #include &quot;opto/rootnode.hpp&quot;
  41 #include &quot;utilities/macros.hpp&quot;
<span class="line-added">  42 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  43 
  44 //=============================================================================
  45 #define NODE_HASH_MINIMUM_SIZE    255
  46 //------------------------------NodeHash---------------------------------------
  47 NodeHash::NodeHash(uint est_max_size) :
  48   _a(Thread::current()-&gt;resource_area()),
  49   _max( round_up(est_max_size &lt; NODE_HASH_MINIMUM_SIZE ? NODE_HASH_MINIMUM_SIZE : est_max_size) ),
  50   _inserts(0), _insert_limit( insert_limit() ),
  51   _table( NEW_ARENA_ARRAY( _a , Node* , _max ) ) // (Node**)_a-&gt;Amalloc(_max * sizeof(Node*)) ),
  52 #ifndef PRODUCT
  53   , _grows(0),_look_probes(0), _lookup_hits(0), _lookup_misses(0),
  54   _insert_probes(0), _delete_probes(0), _delete_hits(0), _delete_misses(0),
  55    _total_inserts(0), _total_insert_probes(0)
  56 #endif
  57 {
  58   // _sentinel must be in the current node space
  59   _sentinel = new ProjNode(NULL, TypeFunc::Control);
  60   memset(_table,0,sizeof(Node*)*_max);
  61 }
  62 
</pre>
<hr />
<pre>
 224 }
 225 
 226 //------------------------------hash_delete------------------------------------
 227 // Replace in hash table with sentinel
 228 bool NodeHash::hash_delete( const Node *n ) {
 229   Node *k;
 230   uint hash = n-&gt;hash();
 231   if (hash == Node::NO_HASH) {
 232     NOT_PRODUCT( _delete_misses++ );
 233     return false;
 234   }
 235   uint key = hash &amp; (_max-1);
 236   uint stride = key | 0x01;
 237   debug_only( uint counter = 0; );
 238   for( ; /* (k != NULL) &amp;&amp; (k != _sentinel) */; ) {
 239     debug_only( counter++ );
 240     NOT_PRODUCT( _delete_probes++ );
 241     k = _table[key];            // Get hashed value
 242     if( !k ) {                  // Miss?
 243       NOT_PRODUCT( _delete_misses++ );






 244       return false;             // Miss! Not in chain
 245     }
 246     else if( n == k ) {
 247       NOT_PRODUCT( _delete_hits++ );
 248       _table[key] = _sentinel;  // Hit! Label as deleted entry
 249       debug_only(((Node*)n)-&gt;exit_hash_lock()); // Unlock the node upon removal from table.
 250       return true;
 251     }
 252     else {
 253       // collision: move through table with prime offset
 254       key = (key + stride/*7*/) &amp; (_max-1);
 255       assert( counter &lt;= _insert_limit, &quot;Cycle in hash-table&quot;);
 256     }
 257   }
 258   ShouldNotReachHere();
 259   return false;
 260 }
 261 
 262 //------------------------------round_up---------------------------------------
 263 // Round up to nearest power of 2
<span class="line-modified"> 264 uint NodeHash::round_up(uint x) {</span>
<span class="line-modified"> 265   x += (x &gt;&gt; 2);                  // Add 25% slop</span>
<span class="line-modified"> 266   return MAX2(16U, round_up_power_of_2(x));</span>



 267 }
 268 
 269 //------------------------------grow-------------------------------------------
 270 // Grow _table to next power of 2 and insert old entries
 271 void  NodeHash::grow() {
 272   // Record old state
 273   uint   old_max   = _max;
 274   Node **old_table = _table;
 275   // Construct new table with twice the space
 276 #ifndef PRODUCT
 277   _grows++;
 278   _total_inserts       += _inserts;
 279   _total_insert_probes += _insert_probes;
 280   _insert_probes   = 0;
 281 #endif
 282   _inserts         = 0;
 283   _max     = _max &lt;&lt; 1;
 284   _table   = NEW_ARENA_ARRAY( _a , Node* , _max ); // (Node**)_a-&gt;Amalloc( _max * sizeof(Node*) );
 285   memset(_table,0,sizeof(Node*)*_max);
 286   _insert_limit = insert_limit();
</pre>
<hr />
<pre>
 682   }
 683 }
 684 
 685 #endif
 686 
 687 
 688 //=============================================================================
 689 //------------------------------PhaseValues------------------------------------
 690 // Set minimum table size to &quot;255&quot;
 691 PhaseValues::PhaseValues( Arena *arena, uint est_max_size ) : PhaseTransform(arena, GVN), _table(arena, est_max_size) {
 692   NOT_PRODUCT( clear_new_values(); )
 693 }
 694 
 695 //------------------------------PhaseValues------------------------------------
 696 // Set minimum table size to &quot;255&quot;
 697 PhaseValues::PhaseValues( PhaseValues *ptv ) : PhaseTransform( ptv, GVN ),
 698   _table(&amp;ptv-&gt;_table) {
 699   NOT_PRODUCT( clear_new_values(); )
 700 }
 701 







 702 //------------------------------~PhaseValues-----------------------------------
 703 #ifndef PRODUCT
 704 PhaseValues::~PhaseValues() {
 705   _table.dump();
 706 
 707   // Statistics for value progress and efficiency
 708   if( PrintCompilation &amp;&amp; Verbose &amp;&amp; WizardMode ) {
 709     tty-&gt;print(&quot;\n%sValues: %d nodes ---&gt; %d/%d (%d)&quot;,
 710       is_IterGVN() ? &quot;Iter&quot; : &quot;    &quot;, C-&gt;unique(), made_progress(), made_transforms(), made_new_values());
 711     if( made_transforms() != 0 ) {
 712       tty-&gt;print_cr(&quot;  ratio %f&quot;, made_progress()/(float)made_transforms() );
 713     } else {
 714       tty-&gt;cr();
 715     }
 716   }
 717 }
 718 #endif
 719 
 720 //------------------------------makecon----------------------------------------
 721 ConNode* PhaseTransform::makecon(const Type *t) {
</pre>
<hr />
<pre>
 791   assert((uint)bt &lt;= _zcon_max, &quot;domain check&quot;);
 792   ConNode* zcon = _zcons[bt];
 793   if (zcon != NULL &amp;&amp; zcon-&gt;in(TypeFunc::Control) != NULL)
 794     return zcon;
 795   zcon = (ConNode*) uncached_makecon(Type::get_zero_type(bt));
 796   _zcons[bt] = zcon;
 797   return zcon;
 798 }
 799 
 800 
 801 
 802 //=============================================================================
 803 Node* PhaseGVN::apply_ideal(Node* k, bool can_reshape) {
 804   Node* i = BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;ideal_node(this, k, can_reshape);
 805   if (i == NULL) {
 806     i = k-&gt;Ideal(this, can_reshape);
 807   }
 808   return i;
 809 }
 810 








 811 //------------------------------transform--------------------------------------
 812 // Return a node which computes the same function as this node, but in a
 813 // faster or cheaper fashion.
 814 Node *PhaseGVN::transform( Node *n ) {
 815   return transform_no_reclaim(n);
 816 }
 817 
 818 //------------------------------transform--------------------------------------
 819 // Return a node which computes the same function as this node, but
 820 // in a faster or cheaper fashion.
 821 Node *PhaseGVN::transform_no_reclaim( Node *n ) {
 822   NOT_PRODUCT( set_transforms(); )
 823 
 824   // Apply the Ideal call in a loop until it no longer applies
 825   Node *k = n;
 826   NOT_PRODUCT( uint loop_count = 0; )
 827   while( 1 ) {
 828     Node *i = apply_ideal(k, /*can_reshape=*/false);
 829     if( !i ) break;
 830     assert( i-&gt;_idx &gt;= k-&gt;_idx, &quot;Idealize should return new nodes, use Identity to return old nodes&quot; );
</pre>
<hr />
<pre>
 845   assert(t != NULL, &quot;value sanity&quot;);
 846   if (type_or_null(k) != t) {
 847 #ifndef PRODUCT
 848     // Do not count initial visit to node as a transformation
 849     if (type_or_null(k) == NULL) {
 850       inc_new_values();
 851       set_progress();
 852     }
 853 #endif
 854     set_type(k, t);
 855     // If k is a TypeNode, capture any more-precise type permanently into Node
 856     k-&gt;raise_bottom_type(t);
 857   }
 858 
 859   if( t-&gt;singleton() &amp;&amp; !k-&gt;is_Con() ) {
 860     NOT_PRODUCT( set_progress(); )
 861     return makecon(t);          // Turn into a constant
 862   }
 863 
 864   // Now check for Identities
<span class="line-modified"> 865   Node *i = k-&gt;Identity(this);  // Look for a nearby replacement</span>
 866   if( i != k ) {                // Found? Return replacement!
 867     NOT_PRODUCT( set_progress(); )
 868     return i;
 869   }
 870 
 871   // Global Value Numbering
 872   i = hash_find_insert(k);      // Insert if new
 873   if( i &amp;&amp; (i != k) ) {
 874     // Return the pre-existing node
 875     NOT_PRODUCT( set_progress(); )
 876     return i;
 877   }
 878 
 879   // Return Idealized original
 880   return k;
 881 }
 882 
 883 bool PhaseGVN::is_dominator_helper(Node *d, Node *n, bool linear_only) {
<span class="line-modified"> 884   if (d-&gt;is_top() || (d-&gt;is_Proj() &amp;&amp; d-&gt;in(0)-&gt;is_top())) {</span>
<span class="line-added"> 885     return false;</span>
<span class="line-added"> 886   }</span>
<span class="line-added"> 887   if (n-&gt;is_top() || (n-&gt;is_Proj() &amp;&amp; n-&gt;in(0)-&gt;is_top())) {</span>
 888     return false;
 889   }
 890   assert(d-&gt;is_CFG() &amp;&amp; n-&gt;is_CFG(), &quot;must have CFG nodes&quot;);
 891   int i = 0;
 892   while (d != n) {
 893     n = IfNode::up_one_dom(n, linear_only);
 894     i++;
<span class="line-modified"> 895     if (n == NULL || i &gt;= 100) {</span>
 896       return false;
 897     }
 898   }
 899   return true;
 900 }
 901 
 902 #ifdef ASSERT
 903 //------------------------------dead_loop_check--------------------------------
 904 // Check for a simple dead loop when a data node references itself directly
 905 // or through an other data node excluding cons and phis.
 906 void PhaseGVN::dead_loop_check( Node *n ) {
 907   // Phi may reference itself in a loop
 908   if (n != NULL &amp;&amp; !n-&gt;is_dead_loop_safe() &amp;&amp; !n-&gt;is_CFG()) {
 909     // Do 2 levels check and only data inputs.
 910     bool no_dead_loop = true;
 911     uint cnt = n-&gt;req();
 912     for (uint i = 1; i &lt; cnt &amp;&amp; no_dead_loop; i++) {
 913       Node *in = n-&gt;in(i);
 914       if (in == n) {
 915         no_dead_loop = false;
 916       } else if (in != NULL &amp;&amp; !in-&gt;is_dead_loop_safe()) {
 917         uint icnt = in-&gt;req();
 918         for (uint j = 1; j &lt; icnt &amp;&amp; no_dead_loop; j++) {
 919           if (in-&gt;in(j) == n || in-&gt;in(j) == in)
 920             no_dead_loop = false;
 921         }
 922       }
 923     }
 924     if (!no_dead_loop) n-&gt;dump(3);
 925     assert(no_dead_loop, &quot;dead loop detected&quot;);
 926   }
 927 }
 928 #endif
 929 
 930 //=============================================================================








 931 //------------------------------PhaseIterGVN-----------------------------------
 932 // Initialize with previous PhaseIterGVN info; used by PhaseCCP
 933 PhaseIterGVN::PhaseIterGVN( PhaseIterGVN *igvn ) : PhaseGVN(igvn),
 934                                                    _delay_transform(igvn-&gt;_delay_transform),
 935                                                    _stack( igvn-&gt;_stack ),
 936                                                    _worklist( igvn-&gt;_worklist )
 937 {
 938 }
 939 
 940 //------------------------------PhaseIterGVN-----------------------------------
 941 // Initialize with previous PhaseGVN info from Parser
 942 PhaseIterGVN::PhaseIterGVN( PhaseGVN *gvn ) : PhaseGVN(gvn),
 943                                               _delay_transform(false),
 944 // TODO: Before incremental inlining it was allocated only once and it was fine. Now that
 945 //       the constructor is used in incremental inlining, this consumes too much memory:
 946 //                                            _stack(C-&gt;live_nodes() &gt;&gt; 1),
 947 //       So, as a band-aid, we replace this by:
 948                                               _stack(C-&gt;comp_arena(), 32),
 949                                               _worklist(*C-&gt;for_igvn())
 950 {
</pre>
<hr />
<pre>
 958     Node *n = _table.at(i);
 959     if(n != NULL &amp;&amp; n != _table.sentinel() &amp;&amp; n-&gt;outcnt() == 0) {
 960       if( n-&gt;is_top() ) continue;
 961       assert( false, &quot;Parse::remove_useless_nodes missed this node&quot;);
 962       hash_delete(n);
 963     }
 964   }
 965 
 966   // Any Phis or Regions on the worklist probably had uses that could not
 967   // make more progress because the uses were made while the Phis and Regions
 968   // were in half-built states.  Put all uses of Phis and Regions on worklist.
 969   max = _worklist.size();
 970   for( uint j = 0; j &lt; max; j++ ) {
 971     Node *n = _worklist.at(j);
 972     uint uop = n-&gt;Opcode();
 973     if( uop == Op_Phi || uop == Op_Region ||
 974         n-&gt;is_Type() ||
 975         n-&gt;is_Mem() )
 976       add_users_to_worklist(n);
 977   }



 978 }
 979 
 980 /**
 981  * Initialize worklist for each node.
 982  */
 983 void PhaseIterGVN::init_worklist(Node* first) {
 984   Unique_Node_List to_process;
 985   to_process.push(first);
 986 
 987   while (to_process.size() &gt; 0) {
 988     Node* n = to_process.pop();
 989     if (!_worklist.member(n)) {
 990       _worklist.push(n);
 991 
 992       uint cnt = n-&gt;req();
 993       for(uint i = 0; i &lt; cnt; i++) {
 994         Node* m = n-&gt;in(i);
 995         if (m != NULL) {
 996           to_process.push(m);
 997         }
</pre>
<hr />
<pre>
1089       assert(false, &quot;modified node is not on IGVN._worklist&quot;);
1090     }
1091   }
1092 #endif
1093 }
1094 
1095 void PhaseIterGVN::verify_PhaseIterGVN() {
1096 #ifdef ASSERT
1097   // Verify nodes with changed inputs.
1098   Unique_Node_List* modified_list = C-&gt;modified_nodes();
1099   while (modified_list != NULL &amp;&amp; modified_list-&gt;size()) {
1100     Node* n = modified_list-&gt;pop();
1101     if (n-&gt;outcnt() != 0 &amp;&amp; !n-&gt;is_Con()) { // skip dead and Con nodes
1102       n-&gt;dump();
1103       assert(false, &quot;modified node was not processed by IGVN.transform_old()&quot;);
1104     }
1105   }
1106 #endif
1107 
1108   C-&gt;verify_graph_edges();


















1109   if (VerifyIterativeGVN &amp;&amp; PrintOpto) {
1110     if (_verify_counter == _verify_full_passes) {
1111       tty-&gt;print_cr(&quot;VerifyIterativeGVN: %d transforms and verify passes&quot;,
1112                     (int) _verify_full_passes);
1113     } else {
1114       tty-&gt;print_cr(&quot;VerifyIterativeGVN: %d transforms, %d full verify passes&quot;,
1115                   (int) _verify_counter, (int) _verify_full_passes);
1116     }
1117   }
1118 
1119 #ifdef ASSERT
1120   while (modified_list-&gt;size()) {
1121     Node* n = modified_list-&gt;pop();
1122     n-&gt;dump();
1123     assert(false, &quot;VerifyIterativeGVN: new modified node was added&quot;);
1124   }
1125 #endif
1126 }
1127 #endif /* PRODUCT */
1128 
</pre>
<hr />
<pre>
1213 
1214 Node *PhaseIterGVN::transform_old(Node* n) {
1215   DEBUG_ONLY(uint loop_count = 0;);
1216   NOT_PRODUCT(set_transforms());
1217 
1218   // Remove &#39;n&#39; from hash table in case it gets modified
1219   _table.hash_delete(n);
1220   if (VerifyIterativeGVN) {
1221    assert(!_table.find_index(n-&gt;_idx), &quot;found duplicate entry in table&quot;);
1222   }
1223 
1224   // Apply the Ideal call in a loop until it no longer applies
1225   Node* k = n;
1226   DEBUG_ONLY(dead_loop_check(k);)
1227   DEBUG_ONLY(bool is_new = (k-&gt;outcnt() == 0);)
1228   C-&gt;remove_modified_node(k);
1229   Node* i = apply_ideal(k, /*can_reshape=*/true);
1230   assert(i != k || is_new || i-&gt;outcnt() &gt; 0, &quot;don&#39;t return dead nodes&quot;);
1231 #ifndef PRODUCT
1232   verify_step(k);
















1233 #endif
1234 
1235   while (i != NULL) {
1236 #ifdef ASSERT
1237     if (loop_count &gt;= K) {
1238       dump_infinite_loop_info(i);
1239     }
1240     loop_count++;
1241 #endif
1242     assert((i-&gt;_idx &gt;= k-&gt;_idx) || i-&gt;is_top(), &quot;Idealize should return new nodes, use Identity to return old nodes&quot;);
1243     // Made a change; put users of original Node on worklist
1244     add_users_to_worklist(k);
1245     // Replacing root of transform tree?
1246     if (k != i) {
1247       // Make users of old Node now use new.
1248       subsume_node(k, i);
1249       k = i;
1250     }
1251     DEBUG_ONLY(dead_loop_check(k);)
1252     // Try idealizing again
1253     DEBUG_ONLY(is_new = (k-&gt;outcnt() == 0);)
1254     C-&gt;remove_modified_node(k);
1255     i = apply_ideal(k, /*can_reshape=*/true);
1256     assert(i != k || is_new || (i-&gt;outcnt() &gt; 0), &quot;don&#39;t return dead nodes&quot;);
1257 #ifndef PRODUCT
1258     verify_step(k);



1259 #endif
1260   }
1261 
1262   // If brand new node, make space in type array.
1263   ensure_type_or_null(k);
1264 
1265   // See what kind of values &#39;k&#39; takes on at runtime
1266   const Type* t = k-&gt;Value(this);
1267   assert(t != NULL, &quot;value sanity&quot;);
1268 
1269   // Since I just called &#39;Value&#39; to compute the set of run-time values
1270   // for this Node, and &#39;Value&#39; is non-local (and therefore expensive) I&#39;ll
1271   // cache Value.  Later requests for the local phase-&gt;type of this Node can
1272   // use the cached Value instead of suffering with &#39;bottom_type&#39;.
1273   if (type_or_null(k) != t) {
1274 #ifndef PRODUCT
1275     inc_new_values();
1276     set_progress();
1277 #endif
1278     set_type(k, t);
1279     // If k is a TypeNode, capture any more-precise type permanently into Node
1280     k-&gt;raise_bottom_type(t);
1281     // Move users of node to worklist
1282     add_users_to_worklist(k);
1283   }
1284   // If &#39;k&#39; computes a constant, replace it with a constant
1285   if (t-&gt;singleton() &amp;&amp; !k-&gt;is_Con()) {
1286     NOT_PRODUCT(set_progress();)
1287     Node* con = makecon(t);     // Make a constant
1288     add_users_to_worklist(k);
1289     subsume_node(k, con);       // Everybody using k now uses con
1290     return con;
1291   }
1292 
1293   // Now check for Identities
<span class="line-modified">1294   i = k-&gt;Identity(this);      // Look for a nearby replacement</span>
1295   if (i != k) {                // Found? Return replacement!
1296     NOT_PRODUCT(set_progress();)
1297     add_users_to_worklist(k);
1298     subsume_node(k, i);       // Everybody using k now uses i
1299     return i;
1300   }
1301 
1302   // Global Value Numbering
1303   i = hash_find_insert(k);      // Check for pre-existing node
1304   if (i &amp;&amp; (i != k)) {
1305     // Return the pre-existing node if it isn&#39;t dead
1306     NOT_PRODUCT(set_progress();)
1307     add_users_to_worklist(k);
1308     subsume_node(k, i);       // Everybody using k now uses i
1309     return i;
1310   }
1311 
1312   // Return Idealized original
1313   return k;
1314 }
</pre>
<hr />
<pre>
1624         if (u-&gt;is_Mem())
1625           _worklist.push(u);
1626       }
1627     }
1628     // If changed initialization activity, check dependent Stores
1629     if (use_op == Op_Allocate || use_op == Op_AllocateArray) {
1630       InitializeNode* init = use-&gt;as_Allocate()-&gt;initialization();
1631       if (init != NULL) {
1632         Node* imem = init-&gt;proj_out_or_null(TypeFunc::Memory);
1633         if (imem != NULL)  add_users_to_worklist0(imem);
1634       }
1635     }
1636     if (use_op == Op_Initialize) {
1637       Node* imem = use-&gt;as_Initialize()-&gt;proj_out_or_null(TypeFunc::Memory);
1638       if (imem != NULL)  add_users_to_worklist0(imem);
1639     }
1640     // Loading the java mirror from a Klass requires two loads and the type
1641     // of the mirror load depends on the type of &#39;n&#39;. See LoadNode::Value().
1642     //   LoadBarrier?(LoadP(LoadP(AddP(foo:Klass, #java_mirror))))
1643     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
<span class="line-modified">1644     bool has_load_barrier_nodes = bs-&gt;has_load_barrier_nodes();</span>
1645 
1646     if (use_op == Op_LoadP &amp;&amp; use-&gt;bottom_type()-&gt;isa_rawptr()) {
1647       for (DUIterator_Fast i2max, i2 = use-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1648         Node* u = use-&gt;fast_out(i2);
1649         const Type* ut = u-&gt;bottom_type();
1650         if (u-&gt;Opcode() == Op_LoadP &amp;&amp; ut-&gt;isa_instptr()) {
<span class="line-modified">1651           if (has_load_barrier_nodes) {</span>
1652             // Search for load barriers behind the load
1653             for (DUIterator_Fast i3max, i3 = u-&gt;fast_outs(i3max); i3 &lt; i3max; i3++) {
1654               Node* b = u-&gt;fast_out(i3);
1655               if (bs-&gt;is_gc_barrier_node(b)) {
1656                 _worklist.push(b);
1657               }
1658             }
1659           }
1660           _worklist.push(u);
1661         }
1662       }
1663     }


1664   }
1665 }
1666 
1667 /**
1668  * Remove the speculative part of all types that we know of
1669  */
1670 void PhaseIterGVN::remove_speculative_types()  {
1671   assert(UseTypeSpeculation, &quot;speculation is off&quot;);
1672   for (uint i = 0; i &lt; _types.Size(); i++)  {
1673     const Type* t = _types.fast_lookup(i);
1674     if (t != NULL) {
1675       _types.map(i, t-&gt;remove_speculative());
1676     }
1677   }
1678   _table.check_no_speculative_types();
1679 }
1680 
1681 //=============================================================================
1682 #ifndef PRODUCT
1683 uint PhaseCCP::_total_invokes   = 0;
</pre>
<hr />
<pre>
1745       }
1746 #endif
1747       set_type(n, t);
1748       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1749         Node* m = n-&gt;fast_out(i);   // Get user
1750         if (m-&gt;is_Region()) {  // New path to Region?  Must recheck Phis too
1751           for (DUIterator_Fast i2max, i2 = m-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1752             Node* p = m-&gt;fast_out(i2); // Propagate changes to uses
1753             if (p-&gt;bottom_type() != type(p)) { // If not already bottomed out
1754               worklist.push(p); // Propagate change to user
1755             }
1756           }
1757         }
1758         // If we changed the receiver type to a call, we need to revisit
1759         // the Catch following the call.  It&#39;s looking for a non-NULL
1760         // receiver to know when to enable the regular fall-through path
1761         // in addition to the NullPtrException path
1762         if (m-&gt;is_Call()) {
1763           for (DUIterator_Fast i2max, i2 = m-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1764             Node* p = m-&gt;fast_out(i2);  // Propagate changes to uses
<span class="line-modified">1765             if (p-&gt;is_Proj() &amp;&amp; p-&gt;as_Proj()-&gt;_con == TypeFunc::Control) {</span>
<span class="line-modified">1766               Node* catch_node = p-&gt;find_out_with(Op_Catch);</span>
<span class="line-added">1767               if (catch_node != NULL) {</span>
<span class="line-added">1768                 worklist.push(catch_node);</span>
<span class="line-added">1769               }</span>
1770             }
1771           }
1772         }
1773         if (m-&gt;bottom_type() != type(m)) { // If not already bottomed out
1774           worklist.push(m);     // Propagate change to user
1775         }
1776 
1777         // CmpU nodes can get their type information from two nodes up in the
1778         // graph (instead of from the nodes immediately above). Make sure they
1779         // are added to the worklist if nodes they depend on are updated, since
1780         // they could be missed and get wrong types otherwise.
1781         uint m_op = m-&gt;Opcode();
1782         if (m_op == Op_AddI || m_op == Op_SubI) {
1783           for (DUIterator_Fast i2max, i2 = m-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1784             Node* p = m-&gt;fast_out(i2); // Propagate changes to uses
1785             if (p-&gt;Opcode() == Op_CmpU) {
1786               // Got a CmpU which might need the new type information from node n.
1787               if(p-&gt;bottom_type() != type(p)) { // If not already bottomed out
1788                 worklist.push(p); // Propagate change to user
1789               }
1790             }
1791           }
1792         }
1793         // If n is used in a counted loop exit condition then the type
1794         // of the counted loop&#39;s Phi depends on the type of n. See
1795         // PhiNode::Value().
1796         if (m_op == Op_CmpI) {
1797           PhiNode* phi = countedloop_phi_from_cmp((CmpINode*)m, n);
1798           if (phi != NULL) {
1799             worklist.push(phi);
1800           }
1801         }
1802         // Loading the java mirror from a Klass requires two loads and the type
1803         // of the mirror load depends on the type of &#39;n&#39;. See LoadNode::Value().
1804         BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
<span class="line-modified">1805         bool has_load_barrier_nodes = bs-&gt;has_load_barrier_nodes();</span>
1806 
1807         if (m_op == Op_LoadP &amp;&amp; m-&gt;bottom_type()-&gt;isa_rawptr()) {
1808           for (DUIterator_Fast i2max, i2 = m-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1809             Node* u = m-&gt;fast_out(i2);
1810             const Type* ut = u-&gt;bottom_type();
1811             if (u-&gt;Opcode() == Op_LoadP &amp;&amp; ut-&gt;isa_instptr() &amp;&amp; ut != type(u)) {
<span class="line-modified">1812               if (has_load_barrier_nodes) {</span>
1813                 // Search for load barriers behind the load
1814                 for (DUIterator_Fast i3max, i3 = u-&gt;fast_outs(i3max); i3 &lt; i3max; i3++) {
1815                   Node* b = u-&gt;fast_out(i3);
1816                   if (bs-&gt;is_gc_barrier_node(b)) {
1817                     worklist.push(b);
1818                   }
1819                 }
1820               }
1821               worklist.push(u);
1822             }
1823           }
1824         }


1825       }
1826     }
1827   }
1828 }
1829 
1830 //------------------------------do_transform-----------------------------------
1831 // Top level driver for the recursive transformer
1832 void PhaseCCP::do_transform() {
1833   // Correct leaves of new-space Nodes; they point to old-space.
1834   C-&gt;set_root( transform(C-&gt;root())-&gt;as_Root() );
1835   assert( C-&gt;top(),  &quot;missing TOP node&quot; );
1836   assert( C-&gt;root(), &quot;missing root&quot; );
1837 }
1838 
1839 //------------------------------transform--------------------------------------
1840 // Given a Node in old-space, clone him into new-space.
1841 // Convert any of his old-space children into new-space children.
1842 Node *PhaseCCP::transform( Node *n ) {
1843   Node *new_node = _nodes[n-&gt;_idx]; // Check for transformed node
1844   if( new_node != NULL )
</pre>
<hr />
<pre>
2110       if (use-&gt;in(j) == this) {
2111         if (j &lt; use-&gt;req())
2112               use-&gt;set_req(j, new_node);
2113         else  use-&gt;set_prec(j, new_node);
2114         uses_found++;
2115       }
2116     }
2117     i -= uses_found;    // we deleted 1 or more copies of this edge
2118   }
2119 }
2120 
2121 //=============================================================================
2122 //-----------------------------------------------------------------------------
2123 void Type_Array::grow( uint i ) {
2124   if( !_max ) {
2125     _max = 1;
2126     _types = (const Type**)_a-&gt;Amalloc( _max * sizeof(Type*) );
2127     _types[0] = NULL;
2128   }
2129   uint old = _max;
<span class="line-modified">2130   _max = next_power_of_2(i);</span>
2131   _types = (const Type**)_a-&gt;Arealloc( _types, old*sizeof(Type*),_max*sizeof(Type*));
2132   memset( &amp;_types[old], 0, (_max-old)*sizeof(Type*) );
2133 }
2134 
2135 //------------------------------dump-------------------------------------------
2136 #ifndef PRODUCT
2137 void Type_Array::dump() const {
2138   uint max = Size();
2139   for( uint i = 0; i &lt; max; i++ ) {
2140     if( _types[i] != NULL ) {
2141       tty-&gt;print(&quot;  %d\t== &quot;, i); _types[i]-&gt;dump(); tty-&gt;cr();
2142     }
2143   }
2144 }
2145 #endif
</pre>
</td>
</tr>
</table>
<center><a href="phase.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="phaseX.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
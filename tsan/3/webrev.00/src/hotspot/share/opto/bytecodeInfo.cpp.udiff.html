<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/opto/bytecodeInfo.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="buildOopMap.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c2_globals.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/bytecodeInfo.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -75,10 +75,12 @@</span>
  
  /**
   *  Return true when EA is ON and a java constructor is called or
   *  a super constructor is called from an inlined java constructor.
   *  Also return true for boxing methods.
<span class="udiff-line-added">+  *  Also return true for methods returning Iterator (including Iterable::iterator())</span>
<span class="udiff-line-added">+  *  that is essential for forall-loops performance.</span>
   */
  static bool is_init_with_ea(ciMethod* callee_method,
                              ciMethod* caller_method, Compile* C) {
    if (!C-&gt;do_escape_analysis() || !EliminateAllocations) {
      return false; // EA is off
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -92,10 +94,15 @@</span>
      return true; // super constructor is called from inlined constructor
    }
    if (C-&gt;eliminate_boxing() &amp;&amp; callee_method-&gt;is_boxing_method()) {
      return true;
    }
<span class="udiff-line-added">+   ciType *retType = callee_method-&gt;signature()-&gt;return_type();</span>
<span class="udiff-line-added">+   ciKlass *iter = C-&gt;env()-&gt;Iterator_klass();</span>
<span class="udiff-line-added">+   if(retType-&gt;is_loaded() &amp;&amp; iter-&gt;is_loaded() &amp;&amp; retType-&gt;is_subtype_of(iter)) {</span>
<span class="udiff-line-added">+     return true;</span>
<span class="udiff-line-added">+   }</span>
    return false;
  }
  
  /**
   *  Force inlining unboxing accessor.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -200,19 +207,19 @@</span>
                                     WarmCallInfo* wci_result) {
  
    const char* fail_msg = NULL;
  
    // First check all inlining restrictions which are required for correctness
<span class="udiff-line-modified-removed">-   if ( callee_method-&gt;is_abstract()) {</span>
<span class="udiff-line-modified-added">+   if (callee_method-&gt;is_abstract()) {</span>
      fail_msg = &quot;abstract method&quot;; // // note: we allow ik-&gt;is_abstract()
    } else if (!callee_method-&gt;holder()-&gt;is_initialized() &amp;&amp;
               // access allowed in the context of static initializer
<span class="udiff-line-modified-removed">-              !C-&gt;is_compiling_clinit_for(callee_method-&gt;holder())) {</span>
<span class="udiff-line-modified-added">+              C-&gt;needs_clinit_barrier(callee_method-&gt;holder(), caller_method)) {</span>
      fail_msg = &quot;method holder not initialized&quot;;
<span class="udiff-line-modified-removed">-   } else if ( callee_method-&gt;is_native()) {</span>
<span class="udiff-line-modified-added">+   } else if (callee_method-&gt;is_native()) {</span>
      fail_msg = &quot;native method&quot;;
<span class="udiff-line-modified-removed">-   } else if ( callee_method-&gt;dont_inline()) {</span>
<span class="udiff-line-modified-added">+   } else if (callee_method-&gt;dont_inline()) {</span>
      fail_msg = &quot;don&#39;t inline by annotation&quot;;
    }
  
    // one more inlining restriction
    if (fail_msg == NULL &amp;&amp; callee_method-&gt;has_unloaded_classes_in_signature()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -319,10 +326,39 @@</span>
    }
  
    return false;
  }
  
<span class="udiff-line-added">+ bool InlineTree::is_not_reached(ciMethod* callee_method, ciMethod* caller_method, int caller_bci, ciCallProfile&amp; profile) {</span>
<span class="udiff-line-added">+   if (!UseInterpreter) {</span>
<span class="udiff-line-added">+     return false; // -Xcomp</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (profile.count() &gt; 0) {</span>
<span class="udiff-line-added">+     return false; // reachable according to profile</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (!callee_method-&gt;was_executed_more_than(0)) {</span>
<span class="udiff-line-added">+     return true; // callee was never executed</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (caller_method-&gt;is_not_reached(caller_bci)) {</span>
<span class="udiff-line-added">+     return true; // call site not resolved</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (profile.count() == -1) {</span>
<span class="udiff-line-added">+     return false; // immature profile; optimistically treat as reached</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   assert(profile.count() == 0, &quot;sanity&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Profile info is scarce.</span>
<span class="udiff-line-added">+   // Try to guess: check if the call site belongs to a start block.</span>
<span class="udiff-line-added">+   // Call sites in a start block should be reachable if no exception is thrown earlier.</span>
<span class="udiff-line-added">+   ciMethodBlocks* caller_blocks = caller_method-&gt;get_method_blocks();</span>
<span class="udiff-line-added">+   bool is_start_block = caller_blocks-&gt;block_containing(caller_bci)-&gt;start_bci() == 0;</span>
<span class="udiff-line-added">+   if (is_start_block) {</span>
<span class="udiff-line-added">+     return false; // treat the call reached as part of start block</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return true; // give up and treat the call site as not reached</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  //-----------------------------try_to_inline-----------------------------------
  // return true if ok
  // Relocated from &quot;InliningClosure::try_to_inline&quot;
  bool InlineTree::try_to_inline(ciMethod* callee_method, ciMethod* caller_method,
                                 int caller_bci, JVMState* jvms, ciCallProfile&amp; profile,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -370,11 +406,11 @@</span>
          is_init_with_ea(callee_method, caller_method, C)) {
        // Escape Analysis stress testing when running Xcomp:
        // inline constructors even if they are not reached.
      } else if (forced_inline()) {
        // Inlining was forced by CompilerOracle, ciReplay or annotation
<span class="udiff-line-modified-removed">-     } else if (profile.count() == 0) {</span>
<span class="udiff-line-modified-added">+     } else if (is_not_reached(callee_method, caller_method, caller_bci, profile)) {</span>
        // don&#39;t inline unreached call sites
         set_msg(&quot;call site not reached&quot;);
         return false;
      }
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -447,18 +483,22 @@</span>
    return true;
  }
  
  //------------------------------pass_initial_checks----------------------------
  bool InlineTree::pass_initial_checks(ciMethod* caller_method, int caller_bci, ciMethod* callee_method) {
<span class="udiff-line-removed">-   ciInstanceKlass *callee_holder = callee_method ? callee_method-&gt;holder() : NULL;</span>
    // Check if a callee_method was suggested
<span class="udiff-line-modified-removed">-   if( callee_method == NULL )            return false;</span>
<span class="udiff-line-modified-added">+   if (callee_method == NULL) {</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   ciInstanceKlass *callee_holder = callee_method-&gt;holder();</span>
    // Check if klass of callee_method is loaded
<span class="udiff-line-modified-removed">-   if( !callee_holder-&gt;is_loaded() )      return false;</span>
<span class="udiff-line-modified-removed">-   if( !callee_holder-&gt;is_initialized() &amp;&amp;</span>
<span class="udiff-line-modified-added">+   if (!callee_holder-&gt;is_loaded()) {</span>
<span class="udiff-line-modified-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (!callee_holder-&gt;is_initialized() &amp;&amp;</span>
        // access allowed in the context of static initializer
<span class="udiff-line-modified-removed">-       !C-&gt;is_compiling_clinit_for(callee_holder)) {</span>
<span class="udiff-line-modified-added">+       C-&gt;needs_clinit_barrier(callee_holder, caller_method)) {</span>
      return false;
    }
    if( !UseInterpreter ) /* running Xcomp */ {
      // Checks that constant pool&#39;s call site has been visited
      // stricter than callee_holder-&gt;is_initialized()
</pre>
<center><a href="buildOopMap.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c2_globals.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
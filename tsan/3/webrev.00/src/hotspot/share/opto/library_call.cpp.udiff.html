<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/opto/library_call.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="lcm.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="live.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/library_call.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -30,10 +30,11 @@</span>
  #include &quot;compiler/compileBroker.hpp&quot;
  #include &quot;compiler/compileLog.hpp&quot;
  #include &quot;gc/shared/barrierSet.hpp&quot;
  #include &quot;jfr/support/jfrIntrinsics.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="udiff-line-added">+ #include &quot;oops/klass.inline.hpp&quot;</span>
  #include &quot;oops/objArrayKlass.hpp&quot;
  #include &quot;opto/addnode.hpp&quot;
  #include &quot;opto/arraycopynode.hpp&quot;
  #include &quot;opto/c2compiler.hpp&quot;
  #include &quot;opto/callGenerator.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -55,11 +56,11 @@</span>
  #include &quot;prims/nativeLookup.hpp&quot;
  #include &quot;prims/unsafe.hpp&quot;
  #include &quot;runtime/objectMonitor.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  class LibraryIntrinsic : public InlineCallGenerator {
    // Extend the set of intrinsics known to the runtime:
   public:
   private:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -225,10 +226,11 @@</span>
    bool inline_string_char_access(bool is_store);
    Node* round_double_node(Node* n);
    bool runtime_math(const TypeFunc* call_type, address funcAddr, const char* funcName);
    bool inline_math_native(vmIntrinsics::ID id);
    bool inline_math(vmIntrinsics::ID id);
<span class="udiff-line-added">+   bool inline_double_math(vmIntrinsics::ID id);</span>
    template &lt;typename OverflowOp&gt;
    bool inline_math_overflow(Node* arg1, Node* arg2);
    void inline_math_mathExact(Node* math, Node* test);
    bool inline_math_addExactI(bool is_increment);
    bool inline_math_addExactL(bool is_increment);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -250,19 +252,20 @@</span>
    DecoratorSet mo_decorator_for_access_kind(AccessKind kind);
    bool inline_unsafe_access(bool is_store, BasicType type, AccessKind kind, bool is_unaligned);
    static bool klass_needs_init_guard(Node* kls);
    bool inline_unsafe_allocate();
    bool inline_unsafe_newArray(bool uninitialized);
<span class="udiff-line-added">+   bool inline_unsafe_writeback0();</span>
<span class="udiff-line-added">+   bool inline_unsafe_writebackSync0(bool is_pre);</span>
    bool inline_unsafe_copyMemory();
    bool inline_native_currentThread();
  
    bool inline_native_time_funcs(address method, const char* funcName);
  #ifdef JFR_HAVE_INTRINSICS
    bool inline_native_classID();
    bool inline_native_getEventWriter();
  #endif
<span class="udiff-line-removed">-   bool inline_native_isInterrupted();</span>
    bool inline_native_Class_query(vmIntrinsics::ID id);
    bool inline_native_subtype_check();
    bool inline_native_getLength();
    bool inline_array_copyOf(bool is_copyOfRange);
    bool inline_array_equals(StrIntrinsicNode::ArgEnc ae);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -290,12 +293,14 @@</span>
    bool inline_number_methods(vmIntrinsics::ID id);
    bool inline_reference_get();
    bool inline_Class_cast();
    bool inline_aescrypt_Block(vmIntrinsics::ID id);
    bool inline_cipherBlockChaining_AESCrypt(vmIntrinsics::ID id);
<span class="udiff-line-added">+   bool inline_electronicCodeBook_AESCrypt(vmIntrinsics::ID id);</span>
    bool inline_counterMode_AESCrypt(vmIntrinsics::ID id);
    Node* inline_cipherBlockChaining_AESCrypt_predicate(bool decrypting);
<span class="udiff-line-added">+   Node* inline_electronicCodeBook_AESCrypt_predicate(bool decrypting);</span>
    Node* inline_counterMode_AESCrypt_predicate();
    Node* get_key_start_from_aescrypt_object(Node* aescrypt_object);
    Node* get_original_key_start_from_aescrypt_object(Node* aescrypt_object);
    bool inline_ghash_processBlocks();
    bool inline_base64_encodeBlock();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -320,10 +325,11 @@</span>
    bool inline_hasNegatives();
    bool inline_squareToLen();
    bool inline_mulAdd();
    bool inline_montgomeryMultiply();
    bool inline_montgomerySquare();
<span class="udiff-line-added">+   bool inline_bigIntegerShift(bool isRightShift);</span>
    bool inline_vectorizedMismatch();
    bool inline_fma(vmIntrinsics::ID id);
    bool inline_character_compare(vmIntrinsics::ID id);
    bool inline_fp_min_max(vmIntrinsics::ID id);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -527,14 +533,20 @@</span>
    switch (intrinsic_id()) {
    case vmIntrinsics::_hashCode:                 return inline_native_hashcode(intrinsic()-&gt;is_virtual(), !is_static);
    case vmIntrinsics::_identityHashCode:         return inline_native_hashcode(/*!virtual*/ false,         is_static);
    case vmIntrinsics::_getClass:                 return inline_native_getClass();
  
<span class="udiff-line-added">+   case vmIntrinsics::_ceil:</span>
<span class="udiff-line-added">+   case vmIntrinsics::_floor:</span>
<span class="udiff-line-added">+   case vmIntrinsics::_rint:</span>
    case vmIntrinsics::_dsin:
    case vmIntrinsics::_dcos:
    case vmIntrinsics::_dtan:
    case vmIntrinsics::_dabs:
<span class="udiff-line-added">+   case vmIntrinsics::_fabs:</span>
<span class="udiff-line-added">+   case vmIntrinsics::_iabs:</span>
<span class="udiff-line-added">+   case vmIntrinsics::_labs:</span>
    case vmIntrinsics::_datan2:
    case vmIntrinsics::_dsqrt:
    case vmIntrinsics::_dexp:
    case vmIntrinsics::_dlog:
    case vmIntrinsics::_dlog10:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -738,19 +750,21 @@</span>
    case vmIntrinsics::_fullFence:                return inline_unsafe_fence(intrinsic_id());
  
    case vmIntrinsics::_onSpinWait:               return inline_onspinwait();
  
    case vmIntrinsics::_currentThread:            return inline_native_currentThread();
<span class="udiff-line-removed">-   case vmIntrinsics::_isInterrupted:            return inline_native_isInterrupted();</span>
  
  #ifdef JFR_HAVE_INTRINSICS
    case vmIntrinsics::_counterTime:              return inline_native_time_funcs(CAST_FROM_FN_PTR(address, JFR_TIME_FUNCTION), &quot;counterTime&quot;);
    case vmIntrinsics::_getClassId:               return inline_native_classID();
    case vmIntrinsics::_getEventWriter:           return inline_native_getEventWriter();
  #endif
    case vmIntrinsics::_currentTimeMillis:        return inline_native_time_funcs(CAST_FROM_FN_PTR(address, os::javaTimeMillis), &quot;currentTimeMillis&quot;);
    case vmIntrinsics::_nanoTime:                 return inline_native_time_funcs(CAST_FROM_FN_PTR(address, os::javaTimeNanos), &quot;nanoTime&quot;);
<span class="udiff-line-added">+   case vmIntrinsics::_writeback0:               return inline_unsafe_writeback0();</span>
<span class="udiff-line-added">+   case vmIntrinsics::_writebackPreSync0:        return inline_unsafe_writebackSync0(true);</span>
<span class="udiff-line-added">+   case vmIntrinsics::_writebackPostSync0:       return inline_unsafe_writebackSync0(false);</span>
    case vmIntrinsics::_allocateInstance:         return inline_unsafe_allocate();
    case vmIntrinsics::_copyMemory:               return inline_unsafe_copyMemory();
    case vmIntrinsics::_getLength:                return inline_native_getLength();
    case vmIntrinsics::_copyOf:                   return inline_array_copyOf(false);
    case vmIntrinsics::_copyOfRange:              return inline_array_copyOf(true);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -801,10 +815,14 @@</span>
  
    case vmIntrinsics::_cipherBlockChaining_encryptAESCrypt:
    case vmIntrinsics::_cipherBlockChaining_decryptAESCrypt:
      return inline_cipherBlockChaining_AESCrypt(intrinsic_id());
  
<span class="udiff-line-added">+   case vmIntrinsics::_electronicCodeBook_encryptAESCrypt:</span>
<span class="udiff-line-added">+   case vmIntrinsics::_electronicCodeBook_decryptAESCrypt:</span>
<span class="udiff-line-added">+     return inline_electronicCodeBook_AESCrypt(intrinsic_id());</span>
<span class="udiff-line-added">+ </span>
    case vmIntrinsics::_counterMode_AESCrypt:
      return inline_counterMode_AESCrypt(intrinsic_id());
  
    case vmIntrinsics::_sha_implCompress:
    case vmIntrinsics::_sha2_implCompress:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -826,10 +844,15 @@</span>
    case vmIntrinsics::_montgomeryMultiply:
      return inline_montgomeryMultiply();
    case vmIntrinsics::_montgomerySquare:
      return inline_montgomerySquare();
  
<span class="udiff-line-added">+   case vmIntrinsics::_bigIntegerRightShiftWorker:</span>
<span class="udiff-line-added">+     return inline_bigIntegerShift(true);</span>
<span class="udiff-line-added">+   case vmIntrinsics::_bigIntegerLeftShiftWorker:</span>
<span class="udiff-line-added">+     return inline_bigIntegerShift(false);</span>
<span class="udiff-line-added">+ </span>
    case vmIntrinsics::_vectorizedMismatch:
      return inline_vectorizedMismatch();
  
    case vmIntrinsics::_ghash_processBlocks:
      return inline_ghash_processBlocks();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -906,10 +929,14 @@</span>
    switch (intrinsic_id()) {
    case vmIntrinsics::_cipherBlockChaining_encryptAESCrypt:
      return inline_cipherBlockChaining_AESCrypt_predicate(false);
    case vmIntrinsics::_cipherBlockChaining_decryptAESCrypt:
      return inline_cipherBlockChaining_AESCrypt_predicate(true);
<span class="udiff-line-added">+   case vmIntrinsics::_electronicCodeBook_encryptAESCrypt:</span>
<span class="udiff-line-added">+     return inline_electronicCodeBook_AESCrypt_predicate(false);</span>
<span class="udiff-line-added">+   case vmIntrinsics::_electronicCodeBook_decryptAESCrypt:</span>
<span class="udiff-line-added">+     return inline_electronicCodeBook_AESCrypt_predicate(true);</span>
    case vmIntrinsics::_counterMode_AESCrypt:
      return inline_counterMode_AESCrypt_predicate();
    case vmIntrinsics::_digestBase_implCompressMB:
      return inline_digestBase_implCompressMB_predicate(predicate);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1064,11 +1091,11 @@</span>
  Node* LibraryCallKit::generate_current_thread(Node* &amp;tls_output) {
    ciKlass*    thread_klass = env()-&gt;Thread_klass();
    const Type* thread_type  = TypeOopPtr::make_from_klass(thread_klass)-&gt;cast_to_ptr_type(TypePtr::NotNull);
    Node* thread = _gvn.transform(new ThreadLocalNode());
    Node* p = basic_plus_adr(top()/*!oop*/, thread, in_bytes(JavaThread::threadObj_offset()));
<span class="udiff-line-modified-removed">-   Node* threadObj = make_load(NULL, p, thread_type, T_OBJECT, MemNode::unordered);</span>
<span class="udiff-line-modified-added">+   Node* threadObj = _gvn.transform(LoadNode::make(_gvn, NULL, immutable_memory(), p, p-&gt;bottom_type()-&gt;is_ptr(), thread_type, T_OBJECT, MemNode::unordered));</span>
    tls_output = thread;
    return threadObj;
  }
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1112,13 +1139,10 @@</span>
    Node* arg2 = argument(1);
  
    arg1 = must_be_not_null(arg1, true);
    arg2 = must_be_not_null(arg2, true);
  
<span class="udiff-line-removed">-   arg1 = access_resolve(arg1, ACCESS_READ);</span>
<span class="udiff-line-removed">-   arg2 = access_resolve(arg2, ACCESS_READ);</span>
<span class="udiff-line-removed">- </span>
    // Get start addr and length of first argument
    Node* arg1_start  = array_element_address(arg1, intcon(0), T_BYTE);
    Node* arg1_cnt    = load_array_length(arg1);
  
    // Get start addr and length of second argument
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1142,13 +1166,10 @@</span>
    if (!stopped()) {
  
      arg1 = must_be_not_null(arg1, true);
      arg2 = must_be_not_null(arg2, true);
  
<span class="udiff-line-removed">-     arg1 = access_resolve(arg1, ACCESS_READ);</span>
<span class="udiff-line-removed">-     arg2 = access_resolve(arg2, ACCESS_READ);</span>
<span class="udiff-line-removed">- </span>
      // Get start addr and length of first argument
      Node* arg1_start  = array_element_address(arg1, intcon(0), T_BYTE);
      Node* arg1_cnt    = load_array_length(arg1);
  
      // Get start addr and length of second argument
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1185,13 +1206,10 @@</span>
  bool LibraryCallKit::inline_array_equals(StrIntrinsicNode::ArgEnc ae) {
    assert(ae == StrIntrinsicNode::UU || ae == StrIntrinsicNode::LL, &quot;unsupported array types&quot;);
    Node* arg1 = argument(0);
    Node* arg2 = argument(1);
  
<span class="udiff-line-removed">-   arg1 = access_resolve(arg1, ACCESS_READ);</span>
<span class="udiff-line-removed">-   arg2 = access_resolve(arg2, ACCESS_READ);</span>
<span class="udiff-line-removed">- </span>
    const TypeAryPtr* mtype = (ae == StrIntrinsicNode::UU) ? TypeAryPtr::CHARS : TypeAryPtr::BYTES;
    set_result(_gvn.transform(new AryEqNode(control(), memory(mtype), arg1, arg2, ae)));
    clear_upper_avx();
  
    return true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1214,11 +1232,10 @@</span>
    // Range checks
    generate_string_range_check(ba, offset, len, false);
    if (stopped()) {
      return true;
    }
<span class="udiff-line-removed">-   ba = access_resolve(ba, ACCESS_READ);</span>
    Node* ba_start = array_element_address(ba, offset, T_BYTE);
    Node* result = new HasNegativesNode(control(), memory(TypeAryPtr::BYTES), ba_start, len);
    set_result(_gvn.transform(result));
    return true;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1285,13 +1302,10 @@</span>
    Node*       result_phi = new PhiNode(result_rgn, TypeInt::INT);
  
    src = must_be_not_null(src, true);
    tgt = must_be_not_null(tgt, true);
  
<span class="udiff-line-removed">-   src = access_resolve(src, ACCESS_READ);</span>
<span class="udiff-line-removed">-   tgt = access_resolve(tgt, ACCESS_READ);</span>
<span class="udiff-line-removed">- </span>
    // Get start addr and length of source string
    Node* src_start = array_element_address(src, intcon(0), T_BYTE);
    Node* src_count = load_array_length(src);
  
    // Get start addr and length of substring
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1335,13 +1349,10 @@</span>
    Node* from_index  = argument(4); // char index
  
    src = must_be_not_null(src, true);
    tgt = must_be_not_null(tgt, true);
  
<span class="udiff-line-removed">-   src = access_resolve(src, ACCESS_READ);</span>
<span class="udiff-line-removed">-   tgt = access_resolve(tgt, ACCESS_READ);</span>
<span class="udiff-line-removed">- </span>
    // Multiply byte array index by 2 if String is UTF16 encoded
    Node* src_offset = (ae == StrIntrinsicNode::LL) ? from_index : _gvn.transform(new LShiftINode(from_index, intcon(1)));
    src_count = _gvn.transform(new SubINode(src_count, from_index));
    Node* src_start = array_element_address(src, src_offset, T_BYTE);
    Node* tgt_start = array_element_address(tgt, intcon(0), T_BYTE);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1424,11 +1435,10 @@</span>
    Node* tgt         = argument(1); // tgt is int ch
    Node* from_index  = argument(2);
    Node* max         = argument(3);
  
    src = must_be_not_null(src, true);
<span class="udiff-line-removed">-   src = access_resolve(src, ACCESS_READ);</span>
  
    Node* src_offset = _gvn.transform(new LShiftINode(from_index, intcon(1)));
    Node* src_start = array_element_address(src, src_offset, T_BYTE);
    Node* src_count = _gvn.transform(new SubINode(max, from_index));
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1515,13 +1525,10 @@</span>
    generate_string_range_check(dst, dst_offset, length, convert_dst);
    if (stopped()) {
      return true;
    }
  
<span class="udiff-line-removed">-   src = access_resolve(src, ACCESS_READ);</span>
<span class="udiff-line-removed">-   dst = access_resolve(dst, ACCESS_WRITE);</span>
<span class="udiff-line-removed">- </span>
    Node* src_start = array_element_address(src, src_offset, src_elem);
    Node* dst_start = array_element_address(dst, dst_offset, dst_elem);
    // &#39;src_start&#39; points to src array + scaled offset
    // &#39;dst_start&#39; points to dst array + scaled offset
    Node* count = NULL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1608,11 +1615,10 @@</span>
      Node* klass_node = makecon(TypeKlassPtr::make(ciTypeArrayKlass::make(T_BYTE)));
      newcopy = new_array(klass_node, size, 0);  // no arguments to push
      AllocateArrayNode* alloc = tightly_coupled_allocation(newcopy, NULL);
  
      // Calculate starting addresses.
<span class="udiff-line-removed">-     value = access_resolve(value, ACCESS_READ);</span>
      Node* src_start = array_element_address(value, offset, T_CHAR);
      Node* dst_start = basic_plus_adr(newcopy, arrayOopDesc::base_offset_in_bytes(T_BYTE));
  
      // Check if src array address is aligned to HeapWordSize (dst is always aligned)
      const TypeInt* toffset = gvn().type(offset)-&gt;is_int();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1692,13 +1698,10 @@</span>
    if (stopped()) {
      return true;
    }
  
    if (!stopped()) {
<span class="udiff-line-removed">-     src = access_resolve(src, ACCESS_READ);</span>
<span class="udiff-line-removed">-     dst = access_resolve(dst, ACCESS_WRITE);</span>
<span class="udiff-line-removed">- </span>
      // Calculate starting addresses.
      Node* src_start = array_element_address(src, src_begin, T_BYTE);
      Node* dst_start = array_element_address(dst, dst_begin, T_CHAR);
  
      // Check if array addresses are aligned to HeapWordSize
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1763,11 +1766,10 @@</span>
    if (!is_store &amp;&amp; value-&gt;is_Con() &amp;&amp; index-&gt;is_Con()) {
      return false;
    }
  
    value = must_be_not_null(value, true);
<span class="udiff-line-removed">-   value = access_resolve(value, is_store ? ACCESS_WRITE : ACCESS_READ);</span>
  
    Node* adr = array_element_address(value, index, T_CHAR);
    if (adr-&gt;is_top()) {
      return false;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1781,26 +1783,53 @@</span>
  }
  
  //--------------------------round_double_node--------------------------------
  // Round a double node if necessary.
  Node* LibraryCallKit::round_double_node(Node* n) {
<span class="udiff-line-modified-removed">-   if (Matcher::strict_fp_requires_explicit_rounding &amp;&amp; UseSSE &lt;= 1)</span>
<span class="udiff-line-modified-removed">-     n = _gvn.transform(new RoundDoubleNode(0, n));</span>
<span class="udiff-line-modified-added">+   if (Matcher::strict_fp_requires_explicit_rounding) {</span>
<span class="udiff-line-modified-added">+ #ifdef IA32</span>
<span class="udiff-line-added">+     if (UseSSE &lt; 2) {</span>
<span class="udiff-line-added">+       n = _gvn.transform(new RoundDoubleNode(NULL, n));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+     Unimplemented();</span>
<span class="udiff-line-added">+ #endif // IA32</span>
<span class="udiff-line-added">+   }</span>
    return n;
  }
  
  //------------------------------inline_math-----------------------------------
  // public static double Math.abs(double)
  // public static double Math.sqrt(double)
  // public static double Math.log(double)
  // public static double Math.log10(double)
<span class="udiff-line-modified-removed">- bool LibraryCallKit::inline_math(vmIntrinsics::ID id) {</span>
<span class="udiff-line-modified-added">+ bool LibraryCallKit::inline_double_math(vmIntrinsics::ID id) {</span>
    Node* arg = round_double_node(argument(0));
    Node* n = NULL;
    switch (id) {
    case vmIntrinsics::_dabs:   n = new AbsDNode(                arg);  break;
    case vmIntrinsics::_dsqrt:  n = new SqrtDNode(C, control(),  arg);  break;
<span class="udiff-line-added">+   case vmIntrinsics::_ceil:   n = RoundDoubleModeNode::make(_gvn, arg, RoundDoubleModeNode::rmode_ceil); break;</span>
<span class="udiff-line-added">+   case vmIntrinsics::_floor:  n = RoundDoubleModeNode::make(_gvn, arg, RoundDoubleModeNode::rmode_floor); break;</span>
<span class="udiff-line-added">+   case vmIntrinsics::_rint:   n = RoundDoubleModeNode::make(_gvn, arg, RoundDoubleModeNode::rmode_rint); break;</span>
<span class="udiff-line-added">+   default:  fatal_unexpected_iid(id);  break;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   set_result(_gvn.transform(n));</span>
<span class="udiff-line-added">+   return true;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ //------------------------------inline_math-----------------------------------</span>
<span class="udiff-line-added">+ // public static float Math.abs(float)</span>
<span class="udiff-line-added">+ // public static int Math.abs(int)</span>
<span class="udiff-line-added">+ // public static long Math.abs(long)</span>
<span class="udiff-line-added">+ bool LibraryCallKit::inline_math(vmIntrinsics::ID id) {</span>
<span class="udiff-line-added">+   Node* arg = argument(0);</span>
<span class="udiff-line-added">+   Node* n = NULL;</span>
<span class="udiff-line-added">+   switch (id) {</span>
<span class="udiff-line-added">+   case vmIntrinsics::_fabs:   n = new AbsFNode(                arg);  break;</span>
<span class="udiff-line-added">+   case vmIntrinsics::_iabs:   n = new AbsINode(                arg);  break;</span>
<span class="udiff-line-added">+   case vmIntrinsics::_labs:   n = new AbsLNode(                arg);  break;</span>
    default:  fatal_unexpected_iid(id);  break;
    }
    set_result(_gvn.transform(n));
    return true;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1853,12 +1882,18 @@</span>
      return StubRoutines::dlog10() != NULL ?
        runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dlog10(), &quot;dlog10&quot;) :
        runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dlog10), &quot;LOG10&quot;);
  
      // These intrinsics are supported on all hardware
<span class="udiff-line-modified-removed">-   case vmIntrinsics::_dsqrt:  return Matcher::match_rule_supported(Op_SqrtD) ? inline_math(id) : false;</span>
<span class="udiff-line-modified-removed">-   case vmIntrinsics::_dabs:   return Matcher::has_match_rule(Op_AbsD)   ? inline_math(id) : false;</span>
<span class="udiff-line-modified-added">+   case vmIntrinsics::_ceil:</span>
<span class="udiff-line-modified-added">+   case vmIntrinsics::_floor:</span>
<span class="udiff-line-added">+   case vmIntrinsics::_rint:   return Matcher::match_rule_supported(Op_RoundDoubleMode) ? inline_double_math(id) : false;</span>
<span class="udiff-line-added">+   case vmIntrinsics::_dsqrt:  return Matcher::match_rule_supported(Op_SqrtD) ? inline_double_math(id) : false;</span>
<span class="udiff-line-added">+   case vmIntrinsics::_dabs:   return Matcher::has_match_rule(Op_AbsD)   ? inline_double_math(id) : false;</span>
<span class="udiff-line-added">+   case vmIntrinsics::_fabs:   return Matcher::match_rule_supported(Op_AbsF)   ? inline_math(id) : false;</span>
<span class="udiff-line-added">+   case vmIntrinsics::_iabs:   return Matcher::match_rule_supported(Op_AbsI)   ? inline_math(id) : false;</span>
<span class="udiff-line-added">+   case vmIntrinsics::_labs:   return Matcher::match_rule_supported(Op_AbsL)   ? inline_math(id) : false;</span>
  
    case vmIntrinsics::_dexp:
      return StubRoutines::dexp() != NULL ?
        runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dexp(),  &quot;dexp&quot;) :
        runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dexp),  &quot;EXP&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2229,11 +2264,10 @@</span>
          return basic_plus_adr(top(), raw_base, offset);
        }
      }
      // We don&#39;t know if it&#39;s an on heap or off heap access. Fall back
      // to raw memory access.
<span class="udiff-line-removed">-     base = access_resolve(base, decorators);</span>
      Node* raw = _gvn.transform(new CheckCastPPNode(control(), base, TypeRawPtr::BOTTOM));
      return basic_plus_adr(top(), raw, offset);
    } else {
      assert(base == uncasted_base, &quot;unexpected base change&quot;);
      // We know it&#39;s an on heap access so base can&#39;t be null
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2341,11 +2375,11 @@</span>
    DecoratorSet decorators = C2_UNSAFE_ACCESS;
    guarantee(!is_store || kind != Acquire, &quot;Acquire accesses can be produced only for loads&quot;);
    guarantee( is_store || kind != Release, &quot;Release accesses can be produced only for stores&quot;);
    assert(type != T_OBJECT || !unaligned, &quot;unaligned access not supported with object type&quot;);
  
<span class="udiff-line-modified-removed">-   if (type == T_OBJECT || type == T_ARRAY) {</span>
<span class="udiff-line-modified-added">+   if (is_reference_type(type)) {</span>
      decorators |= ON_UNKNOWN_OOP_REF;
    }
  
    if (unaligned) {
      decorators |= C2_UNALIGNED;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2398,26 +2432,33 @@</span>
           &quot;fieldOffset must be byte-scaled&quot;);
    // 32-bit machines ignore the high half!
    offset = ConvL2X(offset);
    adr = make_unsafe_address(base, offset, is_store ? ACCESS_WRITE : ACCESS_READ, type, kind == Relaxed);
  
<span class="udiff-line-modified-removed">-   if (_gvn.type(base)-&gt;isa_ptr() != TypePtr::NULL_PTR) {</span>
<span class="udiff-line-modified-removed">-     heap_base_oop = base;</span>
<span class="udiff-line-modified-removed">-   } else if (type == T_OBJECT) {</span>
<span class="udiff-line-modified-removed">-     return false; // off-heap oop accesses are not supported</span>
<span class="udiff-line-modified-added">+   if (_gvn.type(base)-&gt;isa_ptr() == TypePtr::NULL_PTR) {</span>
<span class="udiff-line-modified-added">+     if (type != T_OBJECT) {</span>
<span class="udiff-line-modified-added">+       decorators |= IN_NATIVE; // off-heap primitive access</span>
<span class="udiff-line-modified-added">+     } else {</span>
<span class="udiff-line-added">+       return false; // off-heap oop accesses are not supported</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     heap_base_oop = base; // on-heap or mixed access</span>
    }
  
    // Can base be NULL? Otherwise, always on-heap access.
<span class="udiff-line-modified-removed">-   bool can_access_non_heap = TypePtr::NULL_PTR-&gt;higher_equal(_gvn.type(heap_base_oop));</span>
<span class="udiff-line-modified-added">+   bool can_access_non_heap = TypePtr::NULL_PTR-&gt;higher_equal(_gvn.type(base));</span>
  
    if (!can_access_non_heap) {
      decorators |= IN_HEAP;
    }
  
    val = is_store ? argument(4) : NULL;
  
<span class="udiff-line-modified-removed">-   const TypePtr *adr_type = _gvn.type(adr)-&gt;isa_ptr();</span>
<span class="udiff-line-modified-added">+   const TypePtr* adr_type = _gvn.type(adr)-&gt;isa_ptr();</span>
<span class="udiff-line-added">+   if (adr_type == TypePtr::NULL_PTR) {</span>
<span class="udiff-line-added">+     return false; // off-heap access with zero address</span>
<span class="udiff-line-added">+   }</span>
  
    // Try to categorize the address.
    Compile::AliasType* alias_type = C-&gt;alias_type(adr_type);
    assert(alias_type-&gt;index() != Compile::AliasIdxBot, &quot;no bare pointers here&quot;);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2686,11 +2727,11 @@</span>
    const TypePtr *adr_type = _gvn.type(adr)-&gt;isa_ptr();
  
    Compile::AliasType* alias_type = C-&gt;alias_type(adr_type);
    BasicType bt = alias_type-&gt;basic_type();
    if (bt != T_ILLEGAL &amp;&amp;
<span class="udiff-line-modified-removed">-       ((bt == T_OBJECT || bt == T_ARRAY) != (type == T_OBJECT))) {</span>
<span class="udiff-line-modified-added">+       (is_reference_type(bt) != (type == T_OBJECT))) {</span>
      // Don&#39;t intrinsify mismatched object accesses.
      return false;
    }
  
    // For CAS, unlike inline_unsafe_access, there seems no point in
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2723,11 +2764,11 @@</span>
      return true;
    }
  
    int alias_idx = C-&gt;get_alias_index(adr_type);
  
<span class="udiff-line-modified-removed">-   if (type == T_OBJECT || type == T_ARRAY) {</span>
<span class="udiff-line-modified-added">+   if (is_reference_type(type)) {</span>
      decorators |= IN_HEAP | ON_UNKNOWN_OOP_REF;
  
      // Transformation of a value which could be NULL pointer (CastPP #NULL)
      // could be delayed during Parse (for example, in adjust_map_after_if()).
      // Execute transformation here to avoid barrier generation in such case.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2809,10 +2850,59 @@</span>
    ciInstanceKlass* ik = klsptr-&gt;klass()-&gt;as_instance_klass();
    // don&#39;t need a guard for a klass that is already initialized
    return !ik-&gt;is_initialized();
  }
  
<span class="udiff-line-added">+ //----------------------------inline_unsafe_writeback0-------------------------</span>
<span class="udiff-line-added">+ // public native void Unsafe.writeback0(long address)</span>
<span class="udiff-line-added">+ bool LibraryCallKit::inline_unsafe_writeback0() {</span>
<span class="udiff-line-added">+   if (!Matcher::has_match_rule(Op_CacheWB)) {</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ #ifndef PRODUCT</span>
<span class="udiff-line-added">+   assert(Matcher::has_match_rule(Op_CacheWBPreSync), &quot;found match rule for CacheWB but not CacheWBPreSync&quot;);</span>
<span class="udiff-line-added">+   assert(Matcher::has_match_rule(Op_CacheWBPostSync), &quot;found match rule for CacheWB but not CacheWBPostSync&quot;);</span>
<span class="udiff-line-added">+   ciSignature* sig = callee()-&gt;signature();</span>
<span class="udiff-line-added">+   assert(sig-&gt;type_at(0)-&gt;basic_type() == T_LONG, &quot;Unsafe_writeback0 address is long!&quot;);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+   null_check_receiver();  // null-check, then ignore</span>
<span class="udiff-line-added">+   Node *addr = argument(1);</span>
<span class="udiff-line-added">+   addr = new CastX2PNode(addr);</span>
<span class="udiff-line-added">+   addr = _gvn.transform(addr);</span>
<span class="udiff-line-added">+   Node *flush = new CacheWBNode(control(), memory(TypeRawPtr::BOTTOM), addr);</span>
<span class="udiff-line-added">+   flush = _gvn.transform(flush);</span>
<span class="udiff-line-added">+   set_memory(flush, TypeRawPtr::BOTTOM);</span>
<span class="udiff-line-added">+   return true;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ //----------------------------inline_unsafe_writeback0-------------------------</span>
<span class="udiff-line-added">+ // public native void Unsafe.writeback0(long address)</span>
<span class="udiff-line-added">+ bool LibraryCallKit::inline_unsafe_writebackSync0(bool is_pre) {</span>
<span class="udiff-line-added">+   if (is_pre &amp;&amp; !Matcher::has_match_rule(Op_CacheWBPreSync)) {</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (!is_pre &amp;&amp; !Matcher::has_match_rule(Op_CacheWBPostSync)) {</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ #ifndef PRODUCT</span>
<span class="udiff-line-added">+   assert(Matcher::has_match_rule(Op_CacheWB),</span>
<span class="udiff-line-added">+          (is_pre ? &quot;found match rule for CacheWBPreSync but not CacheWB&quot;</span>
<span class="udiff-line-added">+                 : &quot;found match rule for CacheWBPostSync but not CacheWB&quot;));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+   null_check_receiver();  // null-check, then ignore</span>
<span class="udiff-line-added">+   Node *sync;</span>
<span class="udiff-line-added">+   if (is_pre) {</span>
<span class="udiff-line-added">+     sync = new CacheWBPreSyncNode(control(), memory(TypeRawPtr::BOTTOM));</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     sync = new CacheWBPostSyncNode(control(), memory(TypeRawPtr::BOTTOM));</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   sync = _gvn.transform(sync);</span>
<span class="udiff-line-added">+   set_memory(sync, TypeRawPtr::BOTTOM);</span>
<span class="udiff-line-added">+   return true;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  //----------------------------inline_unsafe_allocate---------------------------
  // public native Object Unsafe.allocateInstance(Class&lt;?&gt; cls);
  bool LibraryCallKit::inline_unsafe_allocate() {
    if (callee()-&gt;is_static())  return false;  // caller must have the capability!
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2938,132 +3028,10 @@</span>
    Node* junk = NULL;
    set_result(generate_current_thread(junk));
    return true;
  }
  
<span class="udiff-line-removed">- //------------------------inline_native_isInterrupted------------------</span>
<span class="udiff-line-removed">- // private native boolean java.lang.Thread.isInterrupted(boolean ClearInterrupted);</span>
<span class="udiff-line-removed">- bool LibraryCallKit::inline_native_isInterrupted() {</span>
<span class="udiff-line-removed">-   // Add a fast path to t.isInterrupted(clear_int):</span>
<span class="udiff-line-removed">-   //   (t == Thread.current() &amp;&amp;</span>
<span class="udiff-line-removed">-   //    (!TLS._osthread._interrupted || WINDOWS_ONLY(false) NOT_WINDOWS(!clear_int)))</span>
<span class="udiff-line-removed">-   //   ? TLS._osthread._interrupted : /*slow path:*/ t.isInterrupted(clear_int)</span>
<span class="udiff-line-removed">-   // So, in the common case that the interrupt bit is false,</span>
<span class="udiff-line-removed">-   // we avoid making a call into the VM.  Even if the interrupt bit</span>
<span class="udiff-line-removed">-   // is true, if the clear_int argument is false, we avoid the VM call.</span>
<span class="udiff-line-removed">-   // However, if the receiver is not currentThread, we must call the VM,</span>
<span class="udiff-line-removed">-   // because there must be some locking done around the operation.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // We only go to the fast case code if we pass two guards.</span>
<span class="udiff-line-removed">-   // Paths which do not pass are accumulated in the slow_region.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   enum {</span>
<span class="udiff-line-removed">-     no_int_result_path   = 1, // t == Thread.current() &amp;&amp; !TLS._osthread._interrupted</span>
<span class="udiff-line-removed">-     no_clear_result_path = 2, // t == Thread.current() &amp;&amp;  TLS._osthread._interrupted &amp;&amp; !clear_int</span>
<span class="udiff-line-removed">-     slow_result_path     = 3, // slow path: t.isInterrupted(clear_int)</span>
<span class="udiff-line-removed">-     PATH_LIMIT</span>
<span class="udiff-line-removed">-   };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Ensure that it&#39;s not possible to move the load of TLS._osthread._interrupted flag</span>
<span class="udiff-line-removed">-   // out of the function.</span>
<span class="udiff-line-removed">-   insert_mem_bar(Op_MemBarCPUOrder);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   RegionNode* result_rgn = new RegionNode(PATH_LIMIT);</span>
<span class="udiff-line-removed">-   PhiNode*    result_val = new PhiNode(result_rgn, TypeInt::BOOL);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   RegionNode* slow_region = new RegionNode(1);</span>
<span class="udiff-line-removed">-   record_for_igvn(slow_region);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // (a) Receiving thread must be the current thread.</span>
<span class="udiff-line-removed">-   Node* rec_thr = argument(0);</span>
<span class="udiff-line-removed">-   Node* tls_ptr = NULL;</span>
<span class="udiff-line-removed">-   Node* cur_thr = generate_current_thread(tls_ptr);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Resolve oops to stable for CmpP below.</span>
<span class="udiff-line-removed">-   cur_thr = access_resolve(cur_thr, 0);</span>
<span class="udiff-line-removed">-   rec_thr = access_resolve(rec_thr, 0);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   Node* cmp_thr = _gvn.transform(new CmpPNode(cur_thr, rec_thr));</span>
<span class="udiff-line-removed">-   Node* bol_thr = _gvn.transform(new BoolNode(cmp_thr, BoolTest::ne));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   generate_slow_guard(bol_thr, slow_region);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // (b) Interrupt bit on TLS must be false.</span>
<span class="udiff-line-removed">-   Node* p = basic_plus_adr(top()/*!oop*/, tls_ptr, in_bytes(JavaThread::osthread_offset()));</span>
<span class="udiff-line-removed">-   Node* osthread = make_load(NULL, p, TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);</span>
<span class="udiff-line-removed">-   p = basic_plus_adr(top()/*!oop*/, osthread, in_bytes(OSThread::interrupted_offset()));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Set the control input on the field _interrupted read to prevent it floating up.</span>
<span class="udiff-line-removed">-   Node* int_bit = make_load(control(), p, TypeInt::BOOL, T_INT, MemNode::unordered);</span>
<span class="udiff-line-removed">-   Node* cmp_bit = _gvn.transform(new CmpINode(int_bit, intcon(0)));</span>
<span class="udiff-line-removed">-   Node* bol_bit = _gvn.transform(new BoolNode(cmp_bit, BoolTest::ne));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   IfNode* iff_bit = create_and_map_if(control(), bol_bit, PROB_UNLIKELY_MAG(3), COUNT_UNKNOWN);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // First fast path:  if (!TLS._interrupted) return false;</span>
<span class="udiff-line-removed">-   Node* false_bit = _gvn.transform(new IfFalseNode(iff_bit));</span>
<span class="udiff-line-removed">-   result_rgn-&gt;init_req(no_int_result_path, false_bit);</span>
<span class="udiff-line-removed">-   result_val-&gt;init_req(no_int_result_path, intcon(0));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // drop through to next case</span>
<span class="udiff-line-removed">-   set_control( _gvn.transform(new IfTrueNode(iff_bit)));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifndef _WINDOWS</span>
<span class="udiff-line-removed">-   // (c) Or, if interrupt bit is set and clear_int is false, use 2nd fast path.</span>
<span class="udiff-line-removed">-   Node* clr_arg = argument(1);</span>
<span class="udiff-line-removed">-   Node* cmp_arg = _gvn.transform(new CmpINode(clr_arg, intcon(0)));</span>
<span class="udiff-line-removed">-   Node* bol_arg = _gvn.transform(new BoolNode(cmp_arg, BoolTest::ne));</span>
<span class="udiff-line-removed">-   IfNode* iff_arg = create_and_map_if(control(), bol_arg, PROB_FAIR, COUNT_UNKNOWN);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Second fast path:  ... else if (!clear_int) return true;</span>
<span class="udiff-line-removed">-   Node* false_arg = _gvn.transform(new IfFalseNode(iff_arg));</span>
<span class="udiff-line-removed">-   result_rgn-&gt;init_req(no_clear_result_path, false_arg);</span>
<span class="udiff-line-removed">-   result_val-&gt;init_req(no_clear_result_path, intcon(1));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // drop through to next case</span>
<span class="udiff-line-removed">-   set_control( _gvn.transform(new IfTrueNode(iff_arg)));</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-   // To return true on Windows you must read the _interrupted field</span>
<span class="udiff-line-removed">-   // and check the event state i.e. take the slow path.</span>
<span class="udiff-line-removed">- #endif // _WINDOWS</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // (d) Otherwise, go to the slow path.</span>
<span class="udiff-line-removed">-   slow_region-&gt;add_req(control());</span>
<span class="udiff-line-removed">-   set_control( _gvn.transform(slow_region));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (stopped()) {</span>
<span class="udiff-line-removed">-     // There is no slow path.</span>
<span class="udiff-line-removed">-     result_rgn-&gt;init_req(slow_result_path, top());</span>
<span class="udiff-line-removed">-     result_val-&gt;init_req(slow_result_path, top());</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     // non-virtual because it is a private non-static</span>
<span class="udiff-line-removed">-     CallJavaNode* slow_call = generate_method_call(vmIntrinsics::_isInterrupted);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     Node* slow_val = set_results_for_java_call(slow_call);</span>
<span class="udiff-line-removed">-     // this-&gt;control() comes from set_results_for_java_call</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     Node* fast_io  = slow_call-&gt;in(TypeFunc::I_O);</span>
<span class="udiff-line-removed">-     Node* fast_mem = slow_call-&gt;in(TypeFunc::Memory);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // These two phis are pre-filled with copies of of the fast IO and Memory</span>
<span class="udiff-line-removed">-     PhiNode* result_mem  = PhiNode::make(result_rgn, fast_mem, Type::MEMORY, TypePtr::BOTTOM);</span>
<span class="udiff-line-removed">-     PhiNode* result_io   = PhiNode::make(result_rgn, fast_io,  Type::ABIO);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     result_rgn-&gt;init_req(slow_result_path, control());</span>
<span class="udiff-line-removed">-     result_io -&gt;init_req(slow_result_path, i_o());</span>
<span class="udiff-line-removed">-     result_mem-&gt;init_req(slow_result_path, reset_memory());</span>
<span class="udiff-line-removed">-     result_val-&gt;init_req(slow_result_path, slow_val);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     set_all_memory(_gvn.transform(result_mem));</span>
<span class="udiff-line-removed">-     set_i_o(       _gvn.transform(result_io));</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization</span>
<span class="udiff-line-removed">-   set_result(result_rgn, result_val);</span>
<span class="udiff-line-removed">-   return true;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  //---------------------------load_mirror_from_klass----------------------------
  // Given a klass oop, load its java mirror (a java.lang.Class oop).
  Node* LibraryCallKit::load_mirror_from_klass(Node* klass) {
    Node* p = basic_plus_adr(klass, in_bytes(Klass::java_mirror_offset()));
    Node* load = make_load(NULL, p, TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3414,14 +3382,10 @@</span>
      Node* p = basic_plus_adr(arg, class_klass_offset);
      Node* kls = LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, adr_type, kls_type);
      klasses[which_arg] = _gvn.transform(kls);
    }
  
<span class="udiff-line-removed">-   // Resolve oops to stable for CmpP below.</span>
<span class="udiff-line-removed">-   args[0] = access_resolve(args[0], 0);</span>
<span class="udiff-line-removed">-   args[1] = access_resolve(args[1], 0);</span>
<span class="udiff-line-removed">- </span>
    // Having loaded both klasses, test each for null.
    bool never_see_null = !too_many_traps(Deoptimization::Reason_null_check);
    for (which_arg = 0; which_arg &lt;= 1; which_arg++) {
      Node* kls = klasses[which_arg];
      Node* null_ctl = top();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3703,12 +3667,10 @@</span>
        // How many elements will we copy from the original?
        // The answer is MinI(orig_length - start, length).
        Node* orig_tail = _gvn.transform(new SubINode(orig_length, start));
        Node* moved = generate_min_max(vmIntrinsics::_min, orig_tail, length);
  
<span class="udiff-line-removed">-       original = access_resolve(original, ACCESS_READ);</span>
<span class="udiff-line-removed">- </span>
        // Generate a direct call to the right arraycopy function(s).
        // We know the copy is disjoint but we might not know if the
        // oop stores need checking.
        // Extreme case:  Arrays.copyOf((Integer[])x, 10, String[].class).
        // This will fail a store-check if x contains any non-nulls.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3735,12 +3697,11 @@</span>
  
        bool validated = false;
        // Reason_class_check rather than Reason_intrinsic because we
        // want to intrinsify even if this traps.
        if (!too_many_traps(Deoptimization::Reason_class_check)) {
<span class="udiff-line-modified-removed">-         Node* not_subtype_ctrl = gen_subtype_check(load_object_klass(original),</span>
<span class="udiff-line-removed">-                                                    klass_node);</span>
<span class="udiff-line-modified-added">+         Node* not_subtype_ctrl = gen_subtype_check(original, klass_node);</span>
  
          if (not_subtype_ctrl != top()) {
            PreserveJVMState pjvms(this);
            set_control(not_subtype_ctrl);
            uncommon_trap(Deoptimization::Reason_class_check,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3926,33 +3887,33 @@</span>
    // the null check after castPP removal.
    Node* no_ctrl = NULL;
    Node* header = make_load(no_ctrl, header_addr, TypeX_X, TypeX_X-&gt;basic_type(), MemNode::unordered);
  
    // Test the header to see if it is unlocked.
<span class="udiff-line-modified-removed">-   Node *lock_mask      = _gvn.MakeConX(markOopDesc::biased_lock_mask_in_place);</span>
<span class="udiff-line-modified-added">+   Node *lock_mask      = _gvn.MakeConX(markWord::biased_lock_mask_in_place);</span>
    Node *lmasked_header = _gvn.transform(new AndXNode(header, lock_mask));
<span class="udiff-line-modified-removed">-   Node *unlocked_val   = _gvn.MakeConX(markOopDesc::unlocked_value);</span>
<span class="udiff-line-modified-added">+   Node *unlocked_val   = _gvn.MakeConX(markWord::unlocked_value);</span>
    Node *chk_unlocked   = _gvn.transform(new CmpXNode( lmasked_header, unlocked_val));
    Node *test_unlocked  = _gvn.transform(new BoolNode( chk_unlocked, BoolTest::ne));
  
    generate_slow_guard(test_unlocked, slow_region);
  
    // Get the hash value and check to see that it has been properly assigned.
    // We depend on hash_mask being at most 32 bits and avoid the use of
    // hash_mask_in_place because it could be larger than 32 bits in a 64-bit
<span class="udiff-line-modified-removed">-   // vm: see markOop.hpp.</span>
<span class="udiff-line-modified-removed">-   Node *hash_mask      = _gvn.intcon(markOopDesc::hash_mask);</span>
<span class="udiff-line-modified-removed">-   Node *hash_shift     = _gvn.intcon(markOopDesc::hash_shift);</span>
<span class="udiff-line-modified-added">+   // vm: see markWord.hpp.</span>
<span class="udiff-line-modified-added">+   Node *hash_mask      = _gvn.intcon(markWord::hash_mask);</span>
<span class="udiff-line-modified-added">+   Node *hash_shift     = _gvn.intcon(markWord::hash_shift);</span>
    Node *hshifted_header= _gvn.transform(new URShiftXNode(header, hash_shift));
    // This hack lets the hash bits live anywhere in the mark object now, as long
    // as the shift drops the relevant bits into the low 32 bits.  Note that
    // Java spec says that HashCode is an int so there&#39;s no point in capturing
    // an &#39;X&#39;-sized hashcode (32 in 32-bit build or 64 in 64-bit build).
    hshifted_header      = ConvX2I(hshifted_header);
    Node *hash_val       = _gvn.transform(new AndINode(hshifted_header, hash_mask));
  
<span class="udiff-line-modified-removed">-   Node *no_hash_val    = _gvn.intcon(markOopDesc::no_hash);</span>
<span class="udiff-line-modified-added">+   Node *no_hash_val    = _gvn.intcon(markWord::no_hash);</span>
    Node *chk_assigned   = _gvn.transform(new CmpINode( hash_val, no_hash_val));
    Node *test_assigned  = _gvn.transform(new BoolNode( chk_assigned, BoolTest::eq));
  
    generate_slow_guard(test_assigned, slow_region);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4202,27 +4163,35 @@</span>
    Node* size    = ConvL2X(argument(7));  // type: long
  
    assert(Unsafe_field_offset_to_byte_offset(11) == 11,
           &quot;fieldOffset must be byte-scaled&quot;);
  
<span class="udiff-line-removed">-   src_ptr = access_resolve(src_ptr, ACCESS_READ);</span>
<span class="udiff-line-removed">-   dst_ptr = access_resolve(dst_ptr, ACCESS_WRITE);</span>
    Node* src = make_unsafe_address(src_ptr, src_off, ACCESS_READ);
    Node* dst = make_unsafe_address(dst_ptr, dst_off, ACCESS_WRITE);
  
    // Conservatively insert a memory barrier on all memory slices.
    // Do not let writes of the copy source or destination float below the copy.
    insert_mem_bar(Op_MemBarCPUOrder);
  
<span class="udiff-line-added">+   Node* thread = _gvn.transform(new ThreadLocalNode());</span>
<span class="udiff-line-added">+   Node* doing_unsafe_access_addr = basic_plus_adr(top(), thread, in_bytes(JavaThread::doing_unsafe_access_offset()));</span>
<span class="udiff-line-added">+   BasicType doing_unsafe_access_bt = T_BYTE;</span>
<span class="udiff-line-added">+   assert((sizeof(bool) * CHAR_BIT) == 8, &quot;not implemented&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // update volatile field</span>
<span class="udiff-line-added">+   store_to_memory(control(), doing_unsafe_access_addr, intcon(1), doing_unsafe_access_bt, Compile::AliasIdxRaw, MemNode::unordered);</span>
<span class="udiff-line-added">+ </span>
    // Call it.  Note that the length argument is not scaled.
    make_runtime_call(RC_LEAF|RC_NO_FP,
                      OptoRuntime::fast_arraycopy_Type(),
                      StubRoutines::unsafe_arraycopy(),
                      &quot;unsafe_arraycopy&quot;,
                      TypeRawPtr::BOTTOM,
                      src, dst, size XTOP);
  
<span class="udiff-line-added">+   store_to_memory(control(), doing_unsafe_access_addr, intcon(0), doing_unsafe_access_bt, Compile::AliasIdxRaw, MemNode::unordered);</span>
<span class="udiff-line-added">+ </span>
    // Do not let reads of the copy destination float above the copy.
    insert_mem_bar(Op_MemBarCPUOrder);
  
    return true;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4245,14 +4214,11 @@</span>
      // expansion, we know this AllocateNode is initialized by an array
      // copy and a StoreStore barrier exists after the array copy.
      alloc-&gt;initialization()-&gt;set_complete_with_arraycopy();
    }
  
<span class="udiff-line-removed">-   // Copy the fastest available way.</span>
<span class="udiff-line-removed">-   // TODO: generate fields copies for small objects instead.</span>
    Node* size = _gvn.transform(obj_size);
<span class="udiff-line-removed">- </span>
    access_clone(obj, alloc_obj, size, is_array);
  
    // Do not let reads from the cloned object float above the arraycopy.
    if (alloc != NULL) {
      // Do not let stores that initialize this object be reordered with
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4315,16 +4281,10 @@</span>
            obj = maybe_cast_profiled_obj(obj, obj_type-&gt;speculative_type(), false);
          }
        }
      }
  
<span class="udiff-line-removed">-     Node* obj_klass = load_object_klass(obj);</span>
<span class="udiff-line-removed">-     const TypeKlassPtr* tklass = _gvn.type(obj_klass)-&gt;isa_klassptr();</span>
<span class="udiff-line-removed">-     const TypeOopPtr*   toop   = ((tklass != NULL)</span>
<span class="udiff-line-removed">-                                 ? tklass-&gt;as_instance_type()</span>
<span class="udiff-line-removed">-                                 : TypeInstPtr::NOTNULL);</span>
<span class="udiff-line-removed">- </span>
      // Conservatively insert a memory barrier on all memory slices.
      // Do not let writes into the original float below the clone.
      insert_mem_bar(Op_MemBarCPUOrder);
  
      // paths into result_reg:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4339,10 +4299,11 @@</span>
      result_val             = new PhiNode(result_reg, TypeInstPtr::NOTNULL);
      PhiNode*    result_i_o = new PhiNode(result_reg, Type::ABIO);
      PhiNode*    result_mem = new PhiNode(result_reg, Type::MEMORY, TypePtr::BOTTOM);
      record_for_igvn(result_reg);
  
<span class="udiff-line-added">+     Node* obj_klass = load_object_klass(obj);</span>
      Node* array_ctl = generate_array_guard(obj_klass, (RegionNode*)NULL);
      if (array_ctl != NULL) {
        // It&#39;s an array.
        PreserveJVMState pjvms(this);
        set_control(array_ctl);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4356,15 +4317,14 @@</span>
          // because gc barriers are required when accessing the array.
          Node* is_obja = generate_objArray_guard(obj_klass, (RegionNode*)NULL);
          if (is_obja != NULL) {
            PreserveJVMState pjvms2(this);
            set_control(is_obja);
<span class="udiff-line-removed">-           obj = access_resolve(obj, ACCESS_READ);</span>
            // Generate a direct call to the right arraycopy function(s).
            Node* alloc = tightly_coupled_allocation(alloc_obj, NULL);
            ArrayCopyNode* ac = ArrayCopyNode::make(this, true, obj, intcon(0), alloc_obj, intcon(0), obj_length, alloc != NULL, false);
<span class="udiff-line-modified-removed">-           ac-&gt;set_cloneoop();</span>
<span class="udiff-line-modified-added">+           ac-&gt;set_clone_oop_array();</span>
            Node* n = _gvn.transform(ac);
            assert(n == ac, &quot;cannot disappear&quot;);
            ac-&gt;connect_outputs(this);
  
            result_reg-&gt;init_req(_objArray_path, control());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4472,31 +4432,31 @@</span>
  JVMState* LibraryCallKit::arraycopy_restore_alloc_state(AllocateArrayNode* alloc, int&amp; saved_reexecute_sp) {
    if (alloc != NULL) {
      ciMethod* trap_method = alloc-&gt;jvms()-&gt;method();
      int trap_bci = alloc-&gt;jvms()-&gt;bci();
  
<span class="udiff-line-modified-removed">-     if (!C-&gt;too_many_traps(trap_method, trap_bci, Deoptimization::Reason_intrinsic) &amp;</span>
<span class="udiff-line-modified-removed">-           !C-&gt;too_many_traps(trap_method, trap_bci, Deoptimization::Reason_null_check)) {</span>
<span class="udiff-line-modified-added">+     if (!C-&gt;too_many_traps(trap_method, trap_bci, Deoptimization::Reason_intrinsic) &amp;&amp;</span>
<span class="udiff-line-modified-added">+         !C-&gt;too_many_traps(trap_method, trap_bci, Deoptimization::Reason_null_check)) {</span>
        // Make sure there&#39;s no store between the allocation and the
        // arraycopy otherwise visible side effects could be rexecuted
        // in case of deoptimization and cause incorrect execution.
        bool no_interfering_store = true;
        Node* mem = alloc-&gt;in(TypeFunc::Memory);
        if (mem-&gt;is_MergeMem()) {
          for (MergeMemStream mms(merged_memory(), mem-&gt;as_MergeMem()); mms.next_non_empty2(); ) {
            Node* n = mms.memory();
            if (n != mms.memory2() &amp;&amp; !(n-&gt;is_Proj() &amp;&amp; n-&gt;in(0) == alloc-&gt;initialization())) {
<span class="udiff-line-modified-removed">-             assert(n-&gt;is_Store() || n-&gt;Opcode() == Op_ShenandoahWBMemProj, &quot;what else?&quot;);</span>
<span class="udiff-line-modified-added">+             assert(n-&gt;is_Store(), &quot;what else?&quot;);</span>
              no_interfering_store = false;
              break;
            }
          }
        } else {
          for (MergeMemStream mms(merged_memory()); mms.next_non_empty(); ) {
            Node* n = mms.memory();
            if (n != mem &amp;&amp; !(n-&gt;is_Proj() &amp;&amp; n-&gt;in(0) == alloc-&gt;initialization())) {
<span class="udiff-line-modified-removed">-             assert(n-&gt;is_Store() || n-&gt;Opcode() == Op_ShenandoahWBMemProj, &quot;what else?&quot;);</span>
<span class="udiff-line-modified-added">+             assert(n-&gt;is_Store(), &quot;what else?&quot;);</span>
              no_interfering_store = false;
              break;
            }
          }
        }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4714,12 +4674,12 @@</span>
    }
  
    if (has_src &amp;&amp; has_dest &amp;&amp; can_emit_guards) {
      BasicType src_elem  = top_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
      BasicType dest_elem = top_dest-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
<span class="udiff-line-modified-removed">-     if (src_elem  == T_ARRAY)  src_elem  = T_OBJECT;</span>
<span class="udiff-line-modified-removed">-     if (dest_elem == T_ARRAY)  dest_elem = T_OBJECT;</span>
<span class="udiff-line-modified-added">+     if (is_reference_type(src_elem))   src_elem  = T_OBJECT;</span>
<span class="udiff-line-modified-added">+     if (is_reference_type(dest_elem))  dest_elem = T_OBJECT;</span>
  
      if (src_elem == dest_elem &amp;&amp; src_elem == T_OBJECT) {
        // If both arrays are object arrays then having the exact types
        // for both will remove the need for a subtype check at runtime
        // before the call and may make it possible to pick a faster copy
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4803,20 +4763,21 @@</span>
        generate_negative_guard(length, slow_region);
        negative_length_guard_generated = true;
      }
  
      // (9) each element of an oop array must be assignable
<span class="udiff-line-removed">-     Node* src_klass  = load_object_klass(src);</span>
      Node* dest_klass = load_object_klass(dest);
<span class="udiff-line-modified-removed">-     Node* not_subtype_ctrl = gen_subtype_check(src_klass, dest_klass);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     if (not_subtype_ctrl != top()) {</span>
<span class="udiff-line-modified-removed">-       PreserveJVMState pjvms(this);</span>
<span class="udiff-line-modified-removed">-       set_control(not_subtype_ctrl);</span>
<span class="udiff-line-modified-removed">-       uncommon_trap(Deoptimization::Reason_intrinsic,</span>
<span class="udiff-line-modified-removed">-                     Deoptimization::Action_make_not_entrant);</span>
<span class="udiff-line-modified-removed">-       assert(stopped(), &quot;Should be stopped&quot;);</span>
<span class="udiff-line-modified-added">+     if (src != dest) {</span>
<span class="udiff-line-modified-added">+       Node* not_subtype_ctrl = gen_subtype_check(src, dest_klass);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       if (not_subtype_ctrl != top()) {</span>
<span class="udiff-line-modified-added">+         PreserveJVMState pjvms(this);</span>
<span class="udiff-line-modified-added">+         set_control(not_subtype_ctrl);</span>
<span class="udiff-line-modified-added">+         uncommon_trap(Deoptimization::Reason_intrinsic,</span>
<span class="udiff-line-modified-added">+                       Deoptimization::Action_make_not_entrant);</span>
<span class="udiff-line-added">+         assert(stopped(), &quot;Should be stopped&quot;);</span>
<span class="udiff-line-added">+       }</span>
      }
      {
        PreserveJVMState pjvms(this);
        set_control(_gvn.transform(slow_region));
        uncommon_trap(Deoptimization::Reason_intrinsic,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4833,14 +4794,11 @@</span>
  
    if (stopped()) {
      return true;
    }
  
<span class="udiff-line-modified-removed">-   Node* new_src = access_resolve(src, ACCESS_READ);</span>
<span class="udiff-line-removed">-   Node* new_dest = access_resolve(dest, ACCESS_WRITE);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   ArrayCopyNode* ac = ArrayCopyNode::make(this, true, new_src, src_offset, new_dest, dest_offset, length, alloc != NULL, negative_length_guard_generated,</span>
<span class="udiff-line-modified-added">+   ArrayCopyNode* ac = ArrayCopyNode::make(this, true, src, src_offset, dest, dest_offset, length, alloc != NULL, negative_length_guard_generated,</span>
                                            // Create LoadRange and LoadKlass nodes for use during macro expansion here
                                            // so the compiler has a chance to eliminate them: during macro expansion,
                                            // we have to set their control (CastPP nodes are eliminated).
                                            load_object_klass(src), load_object_klass(dest),
                                            load_array_length(src), load_array_length(dest));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4892,12 +4850,10 @@</span>
      }
    }
  
    // This arraycopy must unconditionally follow the allocation of the ptr.
    Node* alloc_ctl = ptr-&gt;in(0);
<span class="udiff-line-removed">-   assert(just_allocated_object(alloc_ctl) == ptr, &quot;most recent allo&quot;);</span>
<span class="udiff-line-removed">- </span>
    Node* ctl = control();
    while (ctl != alloc_ctl) {
      // There may be guards which feed into the slow_region.
      // Any other control flow means that we might not get a chance
      // to finish initializing the allocated object.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4949,13 +4905,10 @@</span>
    Node *length      = argument(4);
  
    src = must_be_not_null(src, true);
    dst = must_be_not_null(dst, true);
  
<span class="udiff-line-removed">-   src = access_resolve(src, ACCESS_READ);</span>
<span class="udiff-line-removed">-   dst = access_resolve(dst, ACCESS_WRITE);</span>
<span class="udiff-line-removed">- </span>
    const Type* src_type = src-&gt;Value(&amp;_gvn);
    const Type* dst_type = dst-&gt;Value(&amp;_gvn);
    const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
    const TypeAryPtr* top_dest = dst_type-&gt;isa_aryptr();
    if (top_src  == NULL || top_src-&gt;klass()  == NULL ||
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5007,14 +4960,10 @@</span>
    Node* z    = argument(4);
  
    x = must_be_not_null(x, true);
    y = must_be_not_null(y, true);
  
<span class="udiff-line-removed">-   x = access_resolve(x, ACCESS_READ);</span>
<span class="udiff-line-removed">-   y = access_resolve(y, ACCESS_READ);</span>
<span class="udiff-line-removed">-   z = access_resolve(z, ACCESS_WRITE);</span>
<span class="udiff-line-removed">- </span>
    const Type* x_type = x-&gt;Value(&amp;_gvn);
    const Type* y_type = y-&gt;Value(&amp;_gvn);
    const TypeAryPtr* top_x = x_type-&gt;isa_aryptr();
    const TypeAryPtr* top_y = y_type-&gt;isa_aryptr();
    if (top_x  == NULL || top_x-&gt;klass()  == NULL ||
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5119,13 +5068,10 @@</span>
    Node* zlen = argument(3);
  
    x = must_be_not_null(x, true);
    z = must_be_not_null(z, true);
  
<span class="udiff-line-removed">-   x = access_resolve(x, ACCESS_READ);</span>
<span class="udiff-line-removed">-   z = access_resolve(z, ACCESS_WRITE);</span>
<span class="udiff-line-removed">- </span>
    const Type* x_type = x-&gt;Value(&amp;_gvn);
    const Type* z_type = z-&gt;Value(&amp;_gvn);
    const TypeAryPtr* top_x = x_type-&gt;isa_aryptr();
    const TypeAryPtr* top_z = z_type-&gt;isa_aryptr();
    if (top_x  == NULL || top_x-&gt;klass()  == NULL ||
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5171,13 +5117,10 @@</span>
    Node* len      = argument(3);
    Node* k        = argument(4);
  
    out = must_be_not_null(out, true);
  
<span class="udiff-line-removed">-   in = access_resolve(in, ACCESS_READ);</span>
<span class="udiff-line-removed">-   out = access_resolve(out, ACCESS_WRITE);</span>
<span class="udiff-line-removed">- </span>
    const Type* out_type = out-&gt;Value(&amp;_gvn);
    const Type* in_type = in-&gt;Value(&amp;_gvn);
    const TypeAryPtr* top_out = out_type-&gt;isa_aryptr();
    const TypeAryPtr* top_in = in_type-&gt;isa_aryptr();
    if (top_out  == NULL || top_out-&gt;klass()  == NULL ||
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5223,15 +5166,10 @@</span>
    Node* n    = argument(2);
    Node* len  = argument(3);
    Node* inv  = argument(4);
    Node* m    = argument(6);
  
<span class="udiff-line-removed">-   a = access_resolve(a, ACCESS_READ);</span>
<span class="udiff-line-removed">-   b = access_resolve(b, ACCESS_READ);</span>
<span class="udiff-line-removed">-   n = access_resolve(n, ACCESS_READ);</span>
<span class="udiff-line-removed">-   m = access_resolve(m, ACCESS_WRITE);</span>
<span class="udiff-line-removed">- </span>
    const Type* a_type = a-&gt;Value(&amp;_gvn);
    const TypeAryPtr* top_a = a_type-&gt;isa_aryptr();
    const Type* b_type = b-&gt;Value(&amp;_gvn);
    const TypeAryPtr* top_b = b_type-&gt;isa_aryptr();
    const Type* n_type = a-&gt;Value(&amp;_gvn);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5287,14 +5225,10 @@</span>
    Node* n    = argument(1);
    Node* len  = argument(2);
    Node* inv  = argument(3);
    Node* m    = argument(5);
  
<span class="udiff-line-removed">-   a = access_resolve(a, ACCESS_READ);</span>
<span class="udiff-line-removed">-   n = access_resolve(n, ACCESS_READ);</span>
<span class="udiff-line-removed">-   m = access_resolve(m, ACCESS_WRITE);</span>
<span class="udiff-line-removed">- </span>
    const Type* a_type = a-&gt;Value(&amp;_gvn);
    const TypeAryPtr* top_a = a_type-&gt;isa_aryptr();
    const Type* n_type = a-&gt;Value(&amp;_gvn);
    const TypeAryPtr* top_n = n_type-&gt;isa_aryptr();
    const Type* m_type = a-&gt;Value(&amp;_gvn);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5328,10 +5262,64 @@</span>
    }
  
    return true;
  }
  
<span class="udiff-line-added">+ bool LibraryCallKit::inline_bigIntegerShift(bool isRightShift) {</span>
<span class="udiff-line-added">+   address stubAddr = NULL;</span>
<span class="udiff-line-added">+   const char* stubName = NULL;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   stubAddr = isRightShift? StubRoutines::bigIntegerRightShift(): StubRoutines::bigIntegerLeftShift();</span>
<span class="udiff-line-added">+   if (stubAddr == NULL) {</span>
<span class="udiff-line-added">+     return false; // Intrinsic&#39;s stub is not implemented on this platform</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   stubName = isRightShift? &quot;bigIntegerRightShiftWorker&quot; : &quot;bigIntegerLeftShiftWorker&quot;;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;expected 5 arguments&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Node* newArr = argument(0);</span>
<span class="udiff-line-added">+   Node* oldArr = argument(1);</span>
<span class="udiff-line-added">+   Node* newIdx = argument(2);</span>
<span class="udiff-line-added">+   Node* shiftCount = argument(3);</span>
<span class="udiff-line-added">+   Node* numIter = argument(4);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   const Type* newArr_type = newArr-&gt;Value(&amp;_gvn);</span>
<span class="udiff-line-added">+   const TypeAryPtr* top_newArr = newArr_type-&gt;isa_aryptr();</span>
<span class="udiff-line-added">+   const Type* oldArr_type = oldArr-&gt;Value(&amp;_gvn);</span>
<span class="udiff-line-added">+   const TypeAryPtr* top_oldArr = oldArr_type-&gt;isa_aryptr();</span>
<span class="udiff-line-added">+   if (top_newArr == NULL || top_newArr-&gt;klass() == NULL || top_oldArr == NULL</span>
<span class="udiff-line-added">+       || top_oldArr-&gt;klass() == NULL) {</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   BasicType newArr_elem = newArr_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();</span>
<span class="udiff-line-added">+   BasicType oldArr_elem = oldArr_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();</span>
<span class="udiff-line-added">+   if (newArr_elem != T_INT || oldArr_elem != T_INT) {</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Make the call</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     Node* newArr_start = array_element_address(newArr, intcon(0), newArr_elem);</span>
<span class="udiff-line-added">+     Node* oldArr_start = array_element_address(oldArr, intcon(0), oldArr_elem);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Node* call = make_runtime_call(RC_LEAF,</span>
<span class="udiff-line-added">+                                    OptoRuntime::bigIntegerShift_Type(),</span>
<span class="udiff-line-added">+                                    stubAddr,</span>
<span class="udiff-line-added">+                                    stubName,</span>
<span class="udiff-line-added">+                                    TypePtr::BOTTOM,</span>
<span class="udiff-line-added">+                                    newArr_start,</span>
<span class="udiff-line-added">+                                    oldArr_start,</span>
<span class="udiff-line-added">+                                    newIdx,</span>
<span class="udiff-line-added">+                                    shiftCount,</span>
<span class="udiff-line-added">+                                    numIter);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return true;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  //-------------inline_vectorizedMismatch------------------------------
  bool LibraryCallKit::inline_vectorizedMismatch() {
    assert(UseVectorizedMismatchIntrinsic, &quot;not implementated on this platform&quot;);
  
    address stubAddr = StubRoutines::vectorizedMismatch();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5360,12 +5348,10 @@</span>
    }
  
    Node* call;
    jvms()-&gt;set_should_reexecute(true);
  
<span class="udiff-line-removed">-   obja = access_resolve(obja, ACCESS_READ);</span>
<span class="udiff-line-removed">-   objb = access_resolve(objb, ACCESS_READ);</span>
    Node* obja_adr = make_unsafe_address(obja, aoffset, ACCESS_READ);
    Node* objb_adr = make_unsafe_address(objb, boffset, ACCESS_READ);
  
    call = make_runtime_call(RC_LEAF,
      OptoRuntime::vectorizedMismatch_Type(),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5438,11 +5424,10 @@</span>
      return false;
    }
  
    // &#39;src_start&#39; points to src array + scaled offset
    src = must_be_not_null(src, true);
<span class="udiff-line-removed">-   src = access_resolve(src, ACCESS_READ);</span>
    Node* src_start = array_element_address(src, offset, src_elem);
  
    // We assume that range check is done by caller.
    // TODO: generate range check (offset+length &lt; src.length) in debug VM.
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5528,17 +5513,15 @@</span>
      return false;
    }
  
    // &#39;src_start&#39; points to src array + scaled offset
    src = must_be_not_null(src, true);
<span class="udiff-line-removed">-   src = access_resolve(src, ACCESS_READ);</span>
    Node* src_start = array_element_address(src, offset, src_elem);
  
    // static final int[] byteTable in class CRC32C
    Node* table = get_table_from_crc32c_class(callee()-&gt;holder());
    table = must_be_not_null(table, true);
<span class="udiff-line-removed">-   table = access_resolve(table, ACCESS_READ);</span>
    Node* table_start = array_element_address(table, intcon(0), T_INT);
  
    // We assume that range check is done by caller.
    // TODO: generate range check (offset+length &lt; src.length) in debug VM.
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5579,11 +5562,10 @@</span>
    Node* src_start = basic_plus_adr(top(), base, offset);
  
    // static final int[] byteTable in class CRC32C
    Node* table = get_table_from_crc32c_class(callee()-&gt;holder());
    table = must_be_not_null(table, true);
<span class="udiff-line-removed">-   table = access_resolve(table, ACCESS_READ);</span>
    Node* table_start = array_element_address(table, intcon(0), T_INT);
  
    // Call the stub.
    address stubAddr = StubRoutines::updateBytesCRC32C();
    const char *stubName = &quot;updateBytesCRC32C&quot;;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5623,11 +5605,10 @@</span>
    if (src_elem != T_BYTE) {
      return false;
    }
  
    // &#39;src_start&#39; points to src array + scaled offset
<span class="udiff-line-removed">-   src = access_resolve(src, ACCESS_READ);</span>
    Node* src_start = array_element_address(src, offset, src_elem);
  
    // We assume that range check is done by caller.
    // TODO: generate range check (offset+length &lt; src.length) in debug VM.
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5827,13 +5808,10 @@</span>
    Node* dest_offset     = argument(4);
  
    src = must_be_not_null(src, true);
    dest = must_be_not_null(dest, true);
  
<span class="udiff-line-removed">-   src = access_resolve(src, ACCESS_READ);</span>
<span class="udiff-line-removed">-   dest = access_resolve(dest, ACCESS_WRITE);</span>
<span class="udiff-line-removed">- </span>
    // (1) src and dest are arrays.
    const Type* src_type = src-&gt;Value(&amp;_gvn);
    const Type* dest_type = dest-&gt;Value(&amp;_gvn);
    const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
    const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5903,13 +5881,10 @@</span>
    Node* dest_offset                = argument(5);
  
    src = must_be_not_null(src, false);
    dest = must_be_not_null(dest, false);
  
<span class="udiff-line-removed">-   src = access_resolve(src, ACCESS_READ);</span>
<span class="udiff-line-removed">-   dest = access_resolve(dest, ACCESS_WRITE);</span>
<span class="udiff-line-removed">- </span>
    // (1) src and dest are arrays.
    const Type* src_type = src-&gt;Value(&amp;_gvn);
    const Type* dest_type = dest-&gt;Value(&amp;_gvn);
    const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
    const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5951,11 +5926,10 @@</span>
    if (k_start == NULL) return false;
  
    // similarly, get the start address of the r vector
    Node* objRvec = load_field_from_object(cipherBlockChaining_object, &quot;r&quot;, &quot;[B&quot;, /*is_exact*/ false);
    if (objRvec == NULL) return false;
<span class="udiff-line-removed">-   objRvec = access_resolve(objRvec, ACCESS_WRITE);</span>
    Node* r_start = array_element_address(objRvec, intcon(0), T_BYTE);
  
    Node* cbcCrypt;
    if (Matcher::pass_original_key_for_aes()) {
      // on SPARC we need to pass the original key since key expansion needs to happen in intrinsics due to
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5980,10 +5954,98 @@</span>
    Node* retvalue = _gvn.transform(new ProjNode(cbcCrypt, TypeFunc::Parms));
    set_result(retvalue);
    return true;
  }
  
<span class="udiff-line-added">+ //------------------------------inline_electronicCodeBook_AESCrypt-----------------------</span>
<span class="udiff-line-added">+ bool LibraryCallKit::inline_electronicCodeBook_AESCrypt(vmIntrinsics::ID id) {</span>
<span class="udiff-line-added">+   address stubAddr = NULL;</span>
<span class="udiff-line-added">+   const char *stubName = NULL;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   assert(UseAES, &quot;need AES instruction support&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   switch (id) {</span>
<span class="udiff-line-added">+   case vmIntrinsics::_electronicCodeBook_encryptAESCrypt:</span>
<span class="udiff-line-added">+     stubAddr = StubRoutines::electronicCodeBook_encryptAESCrypt();</span>
<span class="udiff-line-added">+     stubName = &quot;electronicCodeBook_encryptAESCrypt&quot;;</span>
<span class="udiff-line-added">+     break;</span>
<span class="udiff-line-added">+   case vmIntrinsics::_electronicCodeBook_decryptAESCrypt:</span>
<span class="udiff-line-added">+     stubAddr = StubRoutines::electronicCodeBook_decryptAESCrypt();</span>
<span class="udiff-line-added">+     stubName = &quot;electronicCodeBook_decryptAESCrypt&quot;;</span>
<span class="udiff-line-added">+     break;</span>
<span class="udiff-line-added">+   default:</span>
<span class="udiff-line-added">+     break;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (stubAddr == NULL) return false;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Node* electronicCodeBook_object = argument(0);</span>
<span class="udiff-line-added">+   Node* src                       = argument(1);</span>
<span class="udiff-line-added">+   Node* src_offset                = argument(2);</span>
<span class="udiff-line-added">+   Node* len                       = argument(3);</span>
<span class="udiff-line-added">+   Node* dest                      = argument(4);</span>
<span class="udiff-line-added">+   Node* dest_offset               = argument(5);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // (1) src and dest are arrays.</span>
<span class="udiff-line-added">+   const Type* src_type = src-&gt;Value(&amp;_gvn);</span>
<span class="udiff-line-added">+   const Type* dest_type = dest-&gt;Value(&amp;_gvn);</span>
<span class="udiff-line-added">+   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();</span>
<span class="udiff-line-added">+   const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();</span>
<span class="udiff-line-added">+   assert(top_src != NULL &amp;&amp; top_src-&gt;klass() != NULL</span>
<span class="udiff-line-added">+          &amp;&amp;  top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL, &quot;args are strange&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // checks are the responsibility of the caller</span>
<span class="udiff-line-added">+   Node* src_start = src;</span>
<span class="udiff-line-added">+   Node* dest_start = dest;</span>
<span class="udiff-line-added">+   if (src_offset != NULL || dest_offset != NULL) {</span>
<span class="udiff-line-added">+     assert(src_offset != NULL &amp;&amp; dest_offset != NULL, &quot;&quot;);</span>
<span class="udiff-line-added">+     src_start = array_element_address(src, src_offset, T_BYTE);</span>
<span class="udiff-line-added">+     dest_start = array_element_address(dest, dest_offset, T_BYTE);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // if we are in this set of code, we &quot;know&quot; the embeddedCipher is an AESCrypt object</span>
<span class="udiff-line-added">+   // (because of the predicated logic executed earlier).</span>
<span class="udiff-line-added">+   // so we cast it here safely.</span>
<span class="udiff-line-added">+   // this requires a newer class file that has this array as littleEndian ints, otherwise we revert to java</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Node* embeddedCipherObj = load_field_from_object(electronicCodeBook_object, &quot;embeddedCipher&quot;, &quot;Lcom/sun/crypto/provider/SymmetricCipher;&quot;, /*is_exact*/ false);</span>
<span class="udiff-line-added">+   if (embeddedCipherObj == NULL) return false;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // cast it to what we know it will be at runtime</span>
<span class="udiff-line-added">+   const TypeInstPtr* tinst = _gvn.type(electronicCodeBook_object)-&gt;isa_instptr();</span>
<span class="udiff-line-added">+   assert(tinst != NULL, &quot;ECB obj is null&quot;);</span>
<span class="udiff-line-added">+   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;ECB obj is not loaded&quot;);</span>
<span class="udiff-line-added">+   ciKlass* klass_AESCrypt = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(&quot;com/sun/crypto/provider/AESCrypt&quot;));</span>
<span class="udiff-line-added">+   assert(klass_AESCrypt-&gt;is_loaded(), &quot;predicate checks that this class is loaded&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();</span>
<span class="udiff-line-added">+   const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_AESCrypt);</span>
<span class="udiff-line-added">+   const TypeOopPtr* xtype = aklass-&gt;as_instance_type();</span>
<span class="udiff-line-added">+   Node* aescrypt_object = new CheckCastPPNode(control(), embeddedCipherObj, xtype);</span>
<span class="udiff-line-added">+   aescrypt_object = _gvn.transform(aescrypt_object);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // we need to get the start of the aescrypt_object&#39;s expanded key array</span>
<span class="udiff-line-added">+   Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);</span>
<span class="udiff-line-added">+   if (k_start == NULL) return false;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Node* ecbCrypt;</span>
<span class="udiff-line-added">+   if (Matcher::pass_original_key_for_aes()) {</span>
<span class="udiff-line-added">+     // no SPARC version for AES/ECB intrinsics now.</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   // Call the stub, passing src_start, dest_start, k_start, r_start and src_len</span>
<span class="udiff-line-added">+   ecbCrypt = make_runtime_call(RC_LEAF | RC_NO_FP,</span>
<span class="udiff-line-added">+                                OptoRuntime::electronicCodeBook_aescrypt_Type(),</span>
<span class="udiff-line-added">+                                stubAddr, stubName, TypePtr::BOTTOM,</span>
<span class="udiff-line-added">+                                src_start, dest_start, k_start, len);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // return cipher length (int)</span>
<span class="udiff-line-added">+   Node* retvalue = _gvn.transform(new ProjNode(ecbCrypt, TypeFunc::Parms));</span>
<span class="udiff-line-added">+   set_result(retvalue);</span>
<span class="udiff-line-added">+   return true;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  //------------------------------inline_counterMode_AESCrypt-----------------------
  bool LibraryCallKit::inline_counterMode_AESCrypt(vmIntrinsics::ID id) {
    assert(UseAES, &quot;need AES instruction support&quot;);
    if (!UseAESCTRIntrinsics) return false;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6000,14 +6062,10 @@</span>
    Node* src_offset = argument(2);
    Node* len = argument(3);
    Node* dest = argument(4);
    Node* dest_offset = argument(5);
  
<span class="udiff-line-removed">-   src = access_resolve(src, ACCESS_READ);</span>
<span class="udiff-line-removed">-   dest = access_resolve(dest, ACCESS_WRITE);</span>
<span class="udiff-line-removed">-   counterMode_object = access_resolve(counterMode_object, ACCESS_WRITE);</span>
<span class="udiff-line-removed">- </span>
    // (1) src and dest are arrays.
    const Type* src_type = src-&gt;Value(&amp;_gvn);
    const Type* dest_type = dest-&gt;Value(&amp;_gvn);
    const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
    const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6044,16 +6102,14 @@</span>
    Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);
    if (k_start == NULL) return false;
    // similarly, get the start address of the r vector
    Node* obj_counter = load_field_from_object(counterMode_object, &quot;counter&quot;, &quot;[B&quot;, /*is_exact*/ false);
    if (obj_counter == NULL) return false;
<span class="udiff-line-removed">-   obj_counter = access_resolve(obj_counter, ACCESS_WRITE);</span>
    Node* cnt_start = array_element_address(obj_counter, intcon(0), T_BYTE);
  
    Node* saved_encCounter = load_field_from_object(counterMode_object, &quot;encryptedCounter&quot;, &quot;[B&quot;, /*is_exact*/ false);
    if (saved_encCounter == NULL) return false;
<span class="udiff-line-removed">-   saved_encCounter = access_resolve(saved_encCounter, ACCESS_WRITE);</span>
    Node* saved_encCounter_start = array_element_address(saved_encCounter, intcon(0), T_BYTE);
    Node* used = field_address_from_object(counterMode_object, &quot;used&quot;, &quot;I&quot;, /*is_exact*/ false);
  
    Node* ctrCrypt;
    if (Matcher::pass_original_key_for_aes()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6090,11 +6146,10 @@</span>
  #endif // PPC64
    assert (objAESCryptKey != NULL, &quot;wrong version of com.sun.crypto.provider.AESCrypt&quot;);
    if (objAESCryptKey == NULL) return (Node *) NULL;
  
    // now have the array, need to get the start address of the K array
<span class="udiff-line-removed">-   objAESCryptKey = access_resolve(objAESCryptKey, ACCESS_READ);</span>
    Node* k_start = array_element_address(objAESCryptKey, intcon(0), T_INT);
    return k_start;
  }
  
  //------------------------------get_original_key_start_from_aescrypt_object-----------------------
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6102,11 +6157,10 @@</span>
    Node* objAESCryptKey = load_field_from_object(aescrypt_object, &quot;lastKey&quot;, &quot;[B&quot;, /*is_exact*/ false);
    assert (objAESCryptKey != NULL, &quot;wrong version of com.sun.crypto.provider.AESCrypt&quot;);
    if (objAESCryptKey == NULL) return (Node *) NULL;
  
    // now have the array, need to get the start address of the lastKey array
<span class="udiff-line-removed">-   objAESCryptKey = access_resolve(objAESCryptKey, ACCESS_READ);</span>
    Node* original_k_start = array_element_address(objAESCryptKey, intcon(0), T_BYTE);
    return original_k_start;
  }
  
  //----------------------------inline_cipherBlockChaining_AESCrypt_predicate----------------------------
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6146,13 +6200,10 @@</span>
  
    src = must_be_not_null(src, true);
    dest = must_be_not_null(dest, true);
  
    // Resolve oops to stable for CmpP below.
<span class="udiff-line-removed">-   src = access_resolve(src, 0);</span>
<span class="udiff-line-removed">-   dest = access_resolve(dest, 0);</span>
<span class="udiff-line-removed">- </span>
    ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();
  
    Node* instof = gen_instanceof(embeddedCipherObj, makecon(TypeKlassPtr::make(instklass_AESCrypt)));
    Node* cmp_instof  = _gvn.transform(new CmpINode(instof, intcon(1)));
    Node* bool_instof  = _gvn.transform(new BoolNode(cmp_instof, BoolTest::ne));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6176,10 +6227,69 @@</span>
  
    record_for_igvn(region);
    return _gvn.transform(region);
  }
  
<span class="udiff-line-added">+ //----------------------------inline_electronicCodeBook_AESCrypt_predicate----------------------------</span>
<span class="udiff-line-added">+ // Return node representing slow path of predicate check.</span>
<span class="udiff-line-added">+ // the pseudo code we want to emulate with this predicate is:</span>
<span class="udiff-line-added">+ // for encryption:</span>
<span class="udiff-line-added">+ //    if (embeddedCipherObj instanceof AESCrypt) do_intrinsic, else do_javapath</span>
<span class="udiff-line-added">+ // for decryption:</span>
<span class="udiff-line-added">+ //    if ((embeddedCipherObj instanceof AESCrypt) &amp;&amp; (cipher!=plain)) do_intrinsic, else do_javapath</span>
<span class="udiff-line-added">+ //    note cipher==plain is more conservative than the original java code but that&#39;s OK</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ Node* LibraryCallKit::inline_electronicCodeBook_AESCrypt_predicate(bool decrypting) {</span>
<span class="udiff-line-added">+   // The receiver was checked for NULL already.</span>
<span class="udiff-line-added">+   Node* objECB = argument(0);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Load embeddedCipher field of ElectronicCodeBook object.</span>
<span class="udiff-line-added">+   Node* embeddedCipherObj = load_field_from_object(objECB, &quot;embeddedCipher&quot;, &quot;Lcom/sun/crypto/provider/SymmetricCipher;&quot;, /*is_exact*/ false);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // get AESCrypt klass for instanceOf check</span>
<span class="udiff-line-added">+   // AESCrypt might not be loaded yet if some other SymmetricCipher got us to this compile point</span>
<span class="udiff-line-added">+   // will have same classloader as ElectronicCodeBook object</span>
<span class="udiff-line-added">+   const TypeInstPtr* tinst = _gvn.type(objECB)-&gt;isa_instptr();</span>
<span class="udiff-line-added">+   assert(tinst != NULL, &quot;ECBobj is null&quot;);</span>
<span class="udiff-line-added">+   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;ECBobj is not loaded&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // we want to do an instanceof comparison against the AESCrypt class</span>
<span class="udiff-line-added">+   ciKlass* klass_AESCrypt = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(&quot;com/sun/crypto/provider/AESCrypt&quot;));</span>
<span class="udiff-line-added">+   if (!klass_AESCrypt-&gt;is_loaded()) {</span>
<span class="udiff-line-added">+     // if AESCrypt is not even loaded, we never take the intrinsic fast path</span>
<span class="udiff-line-added">+     Node* ctrl = control();</span>
<span class="udiff-line-added">+     set_control(top()); // no regular fast path</span>
<span class="udiff-line-added">+     return ctrl;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Node* instof = gen_instanceof(embeddedCipherObj, makecon(TypeKlassPtr::make(instklass_AESCrypt)));</span>
<span class="udiff-line-added">+   Node* cmp_instof = _gvn.transform(new CmpINode(instof, intcon(1)));</span>
<span class="udiff-line-added">+   Node* bool_instof = _gvn.transform(new BoolNode(cmp_instof, BoolTest::ne));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // for encryption, we are done</span>
<span class="udiff-line-added">+   if (!decrypting)</span>
<span class="udiff-line-added">+     return instof_false;  // even if it is NULL</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // for decryption, we need to add a further check to avoid</span>
<span class="udiff-line-added">+   // taking the intrinsic path when cipher and plain are the same</span>
<span class="udiff-line-added">+   // see the original java code for why.</span>
<span class="udiff-line-added">+   RegionNode* region = new RegionNode(3);</span>
<span class="udiff-line-added">+   region-&gt;init_req(1, instof_false);</span>
<span class="udiff-line-added">+   Node* src = argument(1);</span>
<span class="udiff-line-added">+   Node* dest = argument(4);</span>
<span class="udiff-line-added">+   Node* cmp_src_dest = _gvn.transform(new CmpPNode(src, dest));</span>
<span class="udiff-line-added">+   Node* bool_src_dest = _gvn.transform(new BoolNode(cmp_src_dest, BoolTest::eq));</span>
<span class="udiff-line-added">+   Node* src_dest_conjoint = generate_guard(bool_src_dest, NULL, PROB_MIN);</span>
<span class="udiff-line-added">+   region-&gt;init_req(2, src_dest_conjoint);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   record_for_igvn(region);</span>
<span class="udiff-line-added">+   return _gvn.transform(region);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  //----------------------------inline_counterMode_AESCrypt_predicate----------------------------
  // Return node representing slow path of predicate check.
  // the pseudo code we want to emulate with this predicate is:
  // for encryption:
  //    if (embeddedCipherObj instanceof AESCrypt) do_intrinsic, else do_javapath
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6237,14 +6347,10 @@</span>
  
    state = must_be_not_null(state, true);
    subkeyH = must_be_not_null(subkeyH, true);
    data = must_be_not_null(data, true);
  
<span class="udiff-line-removed">-   state = access_resolve(state, ACCESS_WRITE);</span>
<span class="udiff-line-removed">-   subkeyH = access_resolve(subkeyH, ACCESS_READ);</span>
<span class="udiff-line-removed">-   data = access_resolve(data, ACCESS_READ);</span>
<span class="udiff-line-removed">- </span>
    Node* state_start  = array_element_address(state, intcon(0), T_LONG);
    assert(state_start, &quot;state is NULL&quot;);
    Node* subkeyH_start  = array_element_address(subkeyH, intcon(0), T_LONG);
    assert(subkeyH_start, &quot;subkeyH is NULL&quot;);
    Node* data_start  = array_element_address(data, offset, T_BYTE);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6273,13 +6379,11 @@</span>
    Node* dest = argument(4);
    Node* dp = argument(5);
    Node* isURL = argument(6);
  
    src = must_be_not_null(src, true);
<span class="udiff-line-removed">-   src = access_resolve(src, ACCESS_READ);</span>
    dest = must_be_not_null(dest, true);
<span class="udiff-line-removed">-   dest = access_resolve(dest, ACCESS_WRITE);</span>
  
    Node* src_start = array_element_address(src, intcon(0), T_BYTE);
    assert(src_start, &quot;source array is NULL&quot;);
    Node* dest_start = array_element_address(dest, intcon(0), T_BYTE);
    assert(dest_start, &quot;destination array is NULL&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6320,11 +6424,10 @@</span>
    if (src_elem != T_BYTE) {
      return false;
    }
    // &#39;src_start&#39; points to src array + offset
    src = must_be_not_null(src, true);
<span class="udiff-line-removed">-   src = access_resolve(src, ACCESS_READ);</span>
    Node* src_start = array_element_address(src, ofs, src_elem);
    Node* state = NULL;
    address stubAddr;
    const char *stubName;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6351,10 +6454,13 @@</span>
      fatal_unexpected_iid(id);
      return false;
    }
    if (state == NULL) return false;
  
<span class="udiff-line-added">+   assert(stubAddr != NULL, &quot;Stub is generated&quot;);</span>
<span class="udiff-line-added">+   if (stubAddr == NULL) return false;</span>
<span class="udiff-line-added">+ </span>
    // Call the stub.
    Node* call = make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::sha_implCompress_Type(),
                                   stubAddr, stubName, TypePtr::BOTTOM,
                                   src_start, state);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6388,11 +6494,10 @@</span>
    if (src_elem != T_BYTE) {
      return false;
    }
    // &#39;src_start&#39; points to src array + offset
    src = must_be_not_null(src, false);
<span class="udiff-line-removed">-   src = access_resolve(src, ACCESS_READ);</span>
    Node* src_start = array_element_address(src, ofs, src_elem);
  
    const char* klass_SHA_name = NULL;
    const char* stub_name = NULL;
    address     stub_addr = NULL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6423,10 +6528,13 @@</span>
      break;
    default:
      fatal(&quot;unknown SHA intrinsic predicate: %d&quot;, predicate);
    }
    if (klass_SHA_name != NULL) {
<span class="udiff-line-added">+     assert(stub_addr != NULL, &quot;Stub is generated&quot;);</span>
<span class="udiff-line-added">+     if (stub_addr == NULL) return false;</span>
<span class="udiff-line-added">+ </span>
      // get DigestBase klass to lookup for SHA klass
      const TypeInstPtr* tinst = _gvn.type(digestBase_obj)-&gt;isa_instptr();
      assert(tinst != NULL, &quot;digestBase_obj is not instance???&quot;);
      assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;DigestBase is not loaded&quot;);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6471,11 +6579,10 @@</span>
    Node* sha_state = load_field_from_object(sha_object, &quot;state&quot;, &quot;[I&quot;, /*is_exact*/ false);
    assert (sha_state != NULL, &quot;wrong version of sun.security.provider.SHA/SHA2&quot;);
    if (sha_state == NULL) return (Node *) NULL;
  
    // now have the array, need to get the start address of the state array
<span class="udiff-line-removed">-   sha_state = access_resolve(sha_state, ACCESS_WRITE);</span>
    Node* state = array_element_address(sha_state, intcon(0), T_INT);
    return state;
  }
  
  //------------------------------get_state_from_sha5_object-----------------------
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6483,11 +6590,10 @@</span>
    Node* sha_state = load_field_from_object(sha_object, &quot;state&quot;, &quot;[J&quot;, /*is_exact*/ false);
    assert (sha_state != NULL, &quot;wrong version of sun.security.provider.SHA5&quot;);
    if (sha_state == NULL) return (Node *) NULL;
  
    // now have the array, need to get the start address of the state array
<span class="udiff-line-removed">-   sha_state = access_resolve(sha_state, ACCESS_WRITE);</span>
    Node* state = array_element_address(sha_state, intcon(0), T_LONG);
    return state;
  }
  
  //----------------------------inline_digestBase_implCompressMB_predicate----------------------------
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6661,13 +6767,10 @@</span>
      break;
    default:
      fatal_unexpected_iid(id);
      break;
    }
<span class="udiff-line-removed">-   if (a-&gt;is_Con() || b-&gt;is_Con()) {</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-removed">-   }</span>
    switch (id) {
    case vmIntrinsics::_maxF:  n = new MaxFNode(a, b);  break;
    case vmIntrinsics::_minF:  n = new MinFNode(a, b);  break;
    case vmIntrinsics::_maxD:  n = new MaxDNode(a, b);  break;
    case vmIntrinsics::_minD:  n = new MinDNode(a, b);  break;
</pre>
<center><a href="lcm.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="live.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/opto/cfgnode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="cfgnode.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="chaitin.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/cfgnode.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -129,11 +129,11 @@</span>
    const int _inst_index;  // Alias index of the instance memory slice.
    // Array elements references have the same alias_idx but different offset.
    const int _inst_offset; // Offset of the instance memory slice.
    // Size is bigger to hold the _adr_type field.
    virtual uint hash() const;    // Check the type
<span class="udiff-line-modified-removed">-   virtual uint cmp( const Node &amp;n ) const;</span>
<span class="udiff-line-modified-added">+   virtual bool cmp( const Node &amp;n ) const;</span>
    virtual uint size_of() const { return sizeof(*this); }
  
    // Determine if CMoveNode::is_cmove_id can be used at this join point.
    Node* is_cmove_id(PhaseTransform* phase, int true_path);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -287,11 +287,11 @@</span>
    // change the semantics so it does not appear in the hash &amp; cmp functions.
    virtual uint size_of() const { return sizeof(*this); }
  
  private:
    // Helper methods for fold_compares
<span class="udiff-line-modified-removed">-   bool cmpi_folds(PhaseIterGVN* igvn);</span>
<span class="udiff-line-modified-added">+   bool cmpi_folds(PhaseIterGVN* igvn, bool fold_ne = false);</span>
    bool is_ctrl_folds(Node* ctrl, PhaseIterGVN* igvn);
    bool has_shared_region(ProjNode* proj, ProjNode*&amp; success, ProjNode*&amp; fail);
    bool has_only_uncommon_traps(ProjNode* proj, ProjNode*&amp; success, ProjNode*&amp; fail, PhaseIterGVN* igvn);
    Node* merge_uncommon_traps(ProjNode* proj, ProjNode* success, ProjNode* fail, PhaseIterGVN* igvn);
    static void improve_address_types(Node* l, Node* r, ProjNode* fail, PhaseIterGVN* igvn);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -306,10 +306,12 @@</span>
  protected:
    ProjNode* range_check_trap_proj(int&amp; flip, Node*&amp; l, Node*&amp; r);
    Node* Ideal_common(PhaseGVN *phase, bool can_reshape);
    Node* search_identical(int dist);
  
<span class="udiff-line-added">+   Node* simple_subsuming(PhaseIterGVN* igvn);</span>
<span class="udiff-line-added">+ </span>
  public:
  
    // Degrees of branch prediction probability by order of magnitude:
    // PROB_UNLIKELY_1e(N) is a 1 in 1eN chance.
    // PROB_LIKELY_1e(N) is a 1 - PROB_UNLIKELY_1e(N)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -463,11 +465,11 @@</span>
  // control is passed to the Projection matching the table index.  Used to
  // implement switch statements and exception-handling capabilities.
  // Undefined behavior if passed-in index is not inside the table.
  class PCTableNode : public MultiBranchNode {
    virtual uint hash() const;    // Target count; table size
<span class="udiff-line-modified-removed">-   virtual uint cmp( const Node &amp;n ) const;</span>
<span class="udiff-line-modified-added">+   virtual bool cmp( const Node &amp;n ) const;</span>
    virtual uint size_of() const { return sizeof(*this); }
  
  public:
    const uint _size;             // Number of targets
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -505,11 +507,11 @@</span>
  #endif
  };
  
  class JumpProjNode : public JProjNode {
    virtual uint hash() const;
<span class="udiff-line-modified-removed">-   virtual uint cmp( const Node &amp;n ) const;</span>
<span class="udiff-line-modified-added">+   virtual bool cmp( const Node &amp;n ) const;</span>
    virtual uint size_of() const { return sizeof(*this); }
  
   private:
    const int  _dest_bci;
    const uint _proj_no;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -548,11 +550,11 @@</span>
  // CatchProjNode controls which exception handler is targetted after a call.
  // It is passed in the bci of the target handler, or no_handler_bci in case
  // the projection doesn&#39;t lead to an exception handler.
  class CatchProjNode : public CProjNode {
    virtual uint hash() const;
<span class="udiff-line-modified-removed">-   virtual uint cmp( const Node &amp;n ) const;</span>
<span class="udiff-line-modified-added">+   virtual bool cmp( const Node &amp;n ) const;</span>
    virtual uint size_of() const { return sizeof(*this); }
  
  private:
    const int _handler_bci;
  
</pre>
<center><a href="cfgnode.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="chaitin.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
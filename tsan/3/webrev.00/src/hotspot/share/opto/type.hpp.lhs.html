<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/type.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OPTO_TYPE_HPP
  26 #define SHARE_OPTO_TYPE_HPP
  27 
  28 #include &quot;opto/adlcVMDeps.hpp&quot;
  29 #include &quot;runtime/handles.hpp&quot;
  30 
  31 // Portions of code courtesy of Clifford Click
  32 
  33 // Optimization - Graph Style
  34 
  35 
  36 // This class defines a Type lattice.  The lattice is used in the constant
  37 // propagation algorithms, and for some type-checking of the iloc code.
  38 // Basic types include RSD&#39;s (lower bound, upper bound, stride for integers),
  39 // float &amp; double precision constants, sets of data-labels and code-labels.
  40 // The complete lattice is described below.  Subtypes have no relationship to
  41 // up or down in the lattice; that is entirely determined by the behavior of
  42 // the MEET/JOIN functions.
  43 
  44 class Dict;
  45 class Type;
  46 class   TypeD;
  47 class   TypeF;
  48 class   TypeInt;
  49 class   TypeLong;
  50 class   TypeNarrowPtr;
  51 class     TypeNarrowOop;
  52 class     TypeNarrowKlass;
  53 class   TypeAry;
  54 class   TypeTuple;
  55 class   TypeVect;
  56 class     TypeVectS;
  57 class     TypeVectD;
  58 class     TypeVectX;
  59 class     TypeVectY;
  60 class     TypeVectZ;
  61 class   TypePtr;
  62 class     TypeRawPtr;
  63 class     TypeOopPtr;
  64 class       TypeInstPtr;
  65 class       TypeAryPtr;
  66 class     TypeKlassPtr;
  67 class     TypeMetadataPtr;
  68 
  69 //------------------------------Type-------------------------------------------
  70 // Basic Type object, represents a set of primitive Values.
  71 // Types are hash-cons&#39;d into a private class dictionary, so only one of each
  72 // different kind of Type exists.  Types are never modified after creation, so
  73 // all their interesting fields are constant.
  74 class Type {
  75   friend class VMStructs;
  76 
  77 public:
  78   enum TYPES {
  79     Bad=0,                      // Type check
  80     Control,                    // Control of code (not in lattice)
  81     Top,                        // Top of the lattice
  82     Int,                        // Integer range (lo-hi)
  83     Long,                       // Long integer range (lo-hi)
  84     Half,                       // Placeholder half of doubleword
  85     NarrowOop,                  // Compressed oop pointer
  86     NarrowKlass,                // Compressed klass pointer
  87 
  88     Tuple,                      // Method signature or object layout
  89     Array,                      // Array types
  90     VectorS,                    //  32bit Vector types
  91     VectorD,                    //  64bit Vector types
  92     VectorX,                    // 128bit Vector types
  93     VectorY,                    // 256bit Vector types
  94     VectorZ,                    // 512bit Vector types
  95 
  96     AnyPtr,                     // Any old raw, klass, inst, or array pointer
  97     RawPtr,                     // Raw (non-oop) pointers
  98     OopPtr,                     // Any and all Java heap entities
  99     InstPtr,                    // Instance pointers (non-array objects)
 100     AryPtr,                     // Array pointers
 101     // (Ptr order matters:  See is_ptr, isa_ptr, is_oopptr, isa_oopptr.)
 102 
 103     MetadataPtr,                // Generic metadata
 104     KlassPtr,                   // Klass pointers
 105 
 106     Function,                   // Function signature
 107     Abio,                       // Abstract I/O
 108     Return_Address,             // Subroutine return address
 109     Memory,                     // Abstract store
 110     FloatTop,                   // No float value
 111     FloatCon,                   // Floating point constant
 112     FloatBot,                   // Any float value
 113     DoubleTop,                  // No double value
 114     DoubleCon,                  // Double precision constant
 115     DoubleBot,                  // Any double value
 116     Bottom,                     // Bottom of lattice
 117     lastype                     // Bogus ending type (not in lattice)
 118   };
 119 
 120   // Signal values for offsets from a base pointer
 121   enum OFFSET_SIGNALS {
 122     OffsetTop = -2000000000,    // undefined offset
 123     OffsetBot = -2000000001     // any possible offset
 124   };
 125 
 126   // Min and max WIDEN values.
 127   enum WIDEN {
 128     WidenMin = 0,
 129     WidenMax = 3
 130   };
 131 
 132 private:
 133   typedef struct {
 134     TYPES                dual_type;
 135     BasicType            basic_type;
 136     const char*          msg;
 137     bool                 isa_oop;
 138     uint                 ideal_reg;
 139     relocInfo::relocType reloc;
 140   } TypeInfo;
 141 
 142   // Dictionary of types shared among compilations.
 143   static Dict* _shared_type_dict;
 144   static const TypeInfo _type_info[];
 145 
 146   static int uhash( const Type *const t );
 147   // Structural equality check.  Assumes that cmp() has already compared
 148   // the _base types and thus knows it can cast &#39;t&#39; appropriately.
 149   virtual bool eq( const Type *t ) const;
 150 
 151   // Top-level hash-table of types
 152   static Dict *type_dict() {
 153     return Compile::current()-&gt;type_dict();
 154   }
 155 
 156   // DUAL operation: reflect around lattice centerline.  Used instead of
 157   // join to ensure my lattice is symmetric up and down.  Dual is computed
 158   // lazily, on demand, and cached in _dual.
 159   const Type *_dual;            // Cached dual value
 160   // Table for efficient dualing of base types
 161   static const TYPES dual_type[lastype];
 162 
 163 #ifdef ASSERT
 164   // One type is interface, the other is oop
 165   virtual bool interface_vs_oop_helper(const Type *t) const;
 166 #endif
 167 
 168   const Type *meet_helper(const Type *t, bool include_speculative) const;
 169 
 170 protected:
 171   // Each class of type is also identified by its base.
 172   const TYPES _base;            // Enum of Types type
 173 
 174   Type( TYPES t ) : _dual(NULL),  _base(t) {} // Simple types
 175   // ~Type();                   // Use fast deallocation
 176   const Type *hashcons();       // Hash-cons the type
 177   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 178   const Type *join_helper(const Type *t, bool include_speculative) const {
 179     return dual()-&gt;meet_helper(t-&gt;dual(), include_speculative)-&gt;dual();
 180   }
 181 
 182 public:
 183 
 184   inline void* operator new( size_t x ) throw() {
 185     Compile* compile = Compile::current();
 186     compile-&gt;set_type_last_size(x);
<a name="1" id="anc1"></a><span class="line-modified"> 187     void *temp = compile-&gt;type_arena()-&gt;Amalloc_D(x);</span>
<span class="line-removed"> 188     compile-&gt;set_type_hwm(temp);</span>
<span class="line-removed"> 189     return temp;</span>
 190   }
 191   inline void operator delete( void* ptr ) {
 192     Compile* compile = Compile::current();
 193     compile-&gt;type_arena()-&gt;Afree(ptr,compile-&gt;type_last_size());
 194   }
 195 
 196   // Initialize the type system for a particular compilation.
 197   static void Initialize(Compile* compile);
 198 
 199   // Initialize the types shared by all compilations.
 200   static void Initialize_shared(Compile* compile);
 201 
 202   TYPES base() const {
 203     assert(_base &gt; Bad &amp;&amp; _base &lt; lastype, &quot;sanity&quot;);
 204     return _base;
 205   }
 206 
 207   // Create a new hash-consd type
 208   static const Type *make(enum TYPES);
 209   // Test for equivalence of types
 210   static int cmp( const Type *const t1, const Type *const t2 );
 211   // Test for higher or equal in lattice
 212   // Variant that drops the speculative part of the types
 213   bool higher_equal(const Type *t) const {
 214     return !cmp(meet(t),t-&gt;remove_speculative());
 215   }
 216   // Variant that keeps the speculative part of the types
 217   bool higher_equal_speculative(const Type *t) const {
 218     return !cmp(meet_speculative(t),t);
 219   }
 220 
 221   // MEET operation; lower in lattice.
 222   // Variant that drops the speculative part of the types
 223   const Type *meet(const Type *t) const {
 224     return meet_helper(t, false);
 225   }
 226   // Variant that keeps the speculative part of the types
 227   const Type *meet_speculative(const Type *t) const {
 228     return meet_helper(t, true)-&gt;cleanup_speculative();
 229   }
 230   // WIDEN: &#39;widens&#39; for Ints and other range types
 231   virtual const Type *widen( const Type *old, const Type* limit ) const { return this; }
 232   // NARROW: complement for widen, used by pessimistic phases
 233   virtual const Type *narrow( const Type *old ) const { return this; }
 234 
 235   // DUAL operation: reflect around lattice centerline.  Used instead of
 236   // join to ensure my lattice is symmetric up and down.
 237   const Type *dual() const { return _dual; }
 238 
 239   // Compute meet dependent on base type
 240   virtual const Type *xmeet( const Type *t ) const;
 241   virtual const Type *xdual() const;    // Compute dual right now.
 242 
 243   // JOIN operation; higher in lattice.  Done by finding the dual of the
 244   // meet of the dual of the 2 inputs.
 245   // Variant that drops the speculative part of the types
 246   const Type *join(const Type *t) const {
 247     return join_helper(t, false);
 248   }
 249   // Variant that keeps the speculative part of the types
 250   const Type *join_speculative(const Type *t) const {
 251     return join_helper(t, true)-&gt;cleanup_speculative();
 252   }
 253 
 254   // Modified version of JOIN adapted to the needs Node::Value.
 255   // Normalizes all empty values to TOP.  Does not kill _widen bits.
 256   // Currently, it also works around limitations involving interface types.
 257   // Variant that drops the speculative part of the types
 258   const Type *filter(const Type *kills) const {
 259     return filter_helper(kills, false);
 260   }
 261   // Variant that keeps the speculative part of the types
 262   const Type *filter_speculative(const Type *kills) const {
 263     return filter_helper(kills, true)-&gt;cleanup_speculative();
 264   }
 265 
 266 #ifdef ASSERT
 267   // One type is interface, the other is oop
 268   virtual bool interface_vs_oop(const Type *t) const;
 269 #endif
 270 
 271   // Returns true if this pointer points at memory which contains a
 272   // compressed oop references.
 273   bool is_ptr_to_narrowoop() const;
 274   bool is_ptr_to_narrowklass() const;
 275 
 276   bool is_ptr_to_boxing_obj() const;
 277 
 278 
 279   // Convenience access
 280   float getf() const;
 281   double getd() const;
 282 
 283   const TypeInt    *is_int() const;
 284   const TypeInt    *isa_int() const;             // Returns NULL if not an Int
 285   const TypeLong   *is_long() const;
 286   const TypeLong   *isa_long() const;            // Returns NULL if not a Long
 287   const TypeD      *isa_double() const;          // Returns NULL if not a Double{Top,Con,Bot}
 288   const TypeD      *is_double_constant() const;  // Asserts it is a DoubleCon
 289   const TypeD      *isa_double_constant() const; // Returns NULL if not a DoubleCon
 290   const TypeF      *isa_float() const;           // Returns NULL if not a Float{Top,Con,Bot}
 291   const TypeF      *is_float_constant() const;   // Asserts it is a FloatCon
 292   const TypeF      *isa_float_constant() const;  // Returns NULL if not a FloatCon
 293   const TypeTuple  *is_tuple() const;            // Collection of fields, NOT a pointer
 294   const TypeAry    *is_ary() const;              // Array, NOT array pointer
<a name="2" id="anc2"></a>
 295   const TypeVect   *is_vect() const;             // Vector
 296   const TypeVect   *isa_vect() const;            // Returns NULL if not a Vector
 297   const TypePtr    *is_ptr() const;              // Asserts it is a ptr type
 298   const TypePtr    *isa_ptr() const;             // Returns NULL if not ptr type
 299   const TypeRawPtr *isa_rawptr() const;          // NOT Java oop
 300   const TypeRawPtr *is_rawptr() const;           // Asserts is rawptr
 301   const TypeNarrowOop  *is_narrowoop() const;    // Java-style GC&#39;d pointer
 302   const TypeNarrowOop  *isa_narrowoop() const;   // Returns NULL if not oop ptr type
 303   const TypeNarrowKlass *is_narrowklass() const; // compressed klass pointer
 304   const TypeNarrowKlass *isa_narrowklass() const;// Returns NULL if not oop ptr type
 305   const TypeOopPtr   *isa_oopptr() const;        // Returns NULL if not oop ptr type
 306   const TypeOopPtr   *is_oopptr() const;         // Java-style GC&#39;d pointer
 307   const TypeInstPtr  *isa_instptr() const;       // Returns NULL if not InstPtr
 308   const TypeInstPtr  *is_instptr() const;        // Instance
 309   const TypeAryPtr   *isa_aryptr() const;        // Returns NULL if not AryPtr
 310   const TypeAryPtr   *is_aryptr() const;         // Array oop
 311 
 312   const TypeMetadataPtr   *isa_metadataptr() const;   // Returns NULL if not oop ptr type
 313   const TypeMetadataPtr   *is_metadataptr() const;    // Java-style GC&#39;d pointer
 314   const TypeKlassPtr      *isa_klassptr() const;      // Returns NULL if not KlassPtr
 315   const TypeKlassPtr      *is_klassptr() const;       // assert if not KlassPtr
 316 
 317   virtual bool      is_finite() const;           // Has a finite value
 318   virtual bool      is_nan()    const;           // Is not a number (NaN)
 319 
 320   // Returns this ptr type or the equivalent ptr type for this compressed pointer.
 321   const TypePtr* make_ptr() const;
 322 
 323   // Returns this oopptr type or the equivalent oopptr type for this compressed pointer.
 324   // Asserts if the underlying type is not an oopptr or narrowoop.
 325   const TypeOopPtr* make_oopptr() const;
 326 
 327   // Returns this compressed pointer or the equivalent compressed version
 328   // of this pointer type.
 329   const TypeNarrowOop* make_narrowoop() const;
 330 
 331   // Returns this compressed klass pointer or the equivalent
 332   // compressed version of this pointer type.
 333   const TypeNarrowKlass* make_narrowklass() const;
 334 
 335   // Special test for register pressure heuristic
 336   bool is_floatingpoint() const;        // True if Float or Double base type
 337 
 338   // Do you have memory, directly or through a tuple?
 339   bool has_memory( ) const;
 340 
 341   // TRUE if type is a singleton
 342   virtual bool singleton(void) const;
 343 
 344   // TRUE if type is above the lattice centerline, and is therefore vacuous
 345   virtual bool empty(void) const;
 346 
 347   // Return a hash for this type.  The hash function is public so ConNode
 348   // (constants) can hash on their constant, which is represented by a Type.
 349   virtual int hash() const;
 350 
 351   // Map ideal registers (machine types) to ideal types
 352   static const Type *mreg2type[];
 353 
 354   // Printing, statistics
 355 #ifndef PRODUCT
 356   void         dump_on(outputStream *st) const;
 357   void         dump() const {
 358     dump_on(tty);
 359   }
 360   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 361   static  void dump_stats();
 362 
 363   static const char* str(const Type* t);
 364 #endif
 365   void typerr(const Type *t) const; // Mixing types error
 366 
 367   // Create basic type
 368   static const Type* get_const_basic_type(BasicType type) {
 369     assert((uint)type &lt;= T_CONFLICT &amp;&amp; _const_basic_type[type] != NULL, &quot;bad type&quot;);
 370     return _const_basic_type[type];
 371   }
 372 
 373   // For two instance arrays of same dimension, return the base element types.
 374   // Otherwise or if the arrays have different dimensions, return NULL.
 375   static void get_arrays_base_elements(const Type *a1, const Type *a2,
 376                                        const TypeInstPtr **e1, const TypeInstPtr **e2);
 377 
 378   // Mapping to the array element&#39;s basic type.
 379   BasicType array_element_basic_type() const;
 380 
 381   // Create standard type for a ciType:
 382   static const Type* get_const_type(ciType* type);
 383 
 384   // Create standard zero value:
 385   static const Type* get_zero_type(BasicType type) {
 386     assert((uint)type &lt;= T_CONFLICT &amp;&amp; _zero_type[type] != NULL, &quot;bad type&quot;);
 387     return _zero_type[type];
 388   }
 389 
 390   // Report if this is a zero value (not top).
 391   bool is_zero_type() const {
 392     BasicType type = basic_type();
 393     if (type == T_VOID || type &gt;= T_CONFLICT)
 394       return false;
 395     else
 396       return (this == _zero_type[type]);
 397   }
 398 
 399   // Convenience common pre-built types.
 400   static const Type *ABIO;
 401   static const Type *BOTTOM;
 402   static const Type *CONTROL;
 403   static const Type *DOUBLE;
 404   static const Type *FLOAT;
 405   static const Type *HALF;
 406   static const Type *MEMORY;
 407   static const Type *MULTI;
 408   static const Type *RETURN_ADDRESS;
 409   static const Type *TOP;
 410 
 411   // Mapping from compiler type to VM BasicType
 412   BasicType basic_type() const       { return _type_info[_base].basic_type; }
 413   uint ideal_reg() const             { return _type_info[_base].ideal_reg; }
 414   const char* msg() const            { return _type_info[_base].msg; }
 415   bool isa_oop_ptr() const           { return _type_info[_base].isa_oop; }
 416   relocInfo::relocType reloc() const { return _type_info[_base].reloc; }
 417 
 418   // Mapping from CI type system to compiler type:
 419   static const Type* get_typeflow_type(ciType* type);
 420 
 421   static const Type* make_from_constant(ciConstant constant,
 422                                         bool require_constant = false,
 423                                         int stable_dimension = 0,
 424                                         bool is_narrow = false,
 425                                         bool is_autobox_cache = false);
 426 
 427   static const Type* make_constant_from_field(ciInstance* holder,
 428                                               int off,
 429                                               bool is_unsigned_load,
 430                                               BasicType loadbt);
 431 
 432   static const Type* make_constant_from_field(ciField* field,
 433                                               ciInstance* holder,
 434                                               BasicType loadbt,
 435                                               bool is_unsigned_load);
 436 
 437   static const Type* make_constant_from_array_element(ciArray* array,
 438                                                       int off,
 439                                                       int stable_dimension,
 440                                                       BasicType loadbt,
 441                                                       bool is_unsigned_load);
 442 
 443   // Speculative type helper methods. See TypePtr.
 444   virtual const TypePtr* speculative() const                                  { return NULL; }
 445   virtual ciKlass* speculative_type() const                                   { return NULL; }
 446   virtual ciKlass* speculative_type_not_null() const                          { return NULL; }
 447   virtual bool speculative_maybe_null() const                                 { return true; }
 448   virtual bool speculative_always_null() const                                { return true; }
 449   virtual const Type* remove_speculative() const                              { return this; }
 450   virtual const Type* cleanup_speculative() const                             { return this; }
 451   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const { return exact_kls != NULL; }
 452   virtual bool would_improve_ptr(ProfilePtrKind ptr_kind) const { return ptr_kind == ProfileAlwaysNull || ptr_kind == ProfileNeverNull; }
 453   const Type* maybe_remove_speculative(bool include_speculative) const;
 454 
 455   virtual bool maybe_null() const { return true; }
 456 
 457 private:
 458   // support arrays
<a name="3" id="anc3"></a><span class="line-removed"> 459   static const BasicType _basic_type[];</span>
 460   static const Type*        _zero_type[T_CONFLICT+1];
 461   static const Type* _const_basic_type[T_CONFLICT+1];
 462 };
 463 
 464 //------------------------------TypeF------------------------------------------
 465 // Class of Float-Constant Types.
 466 class TypeF : public Type {
 467   TypeF( float f ) : Type(FloatCon), _f(f) {};
 468 public:
 469   virtual bool eq( const Type *t ) const;
 470   virtual int  hash() const;             // Type specific hashing
 471   virtual bool singleton(void) const;    // TRUE if type is a singleton
 472   virtual bool empty(void) const;        // TRUE if type is vacuous
 473 public:
 474   const float _f;               // Float constant
 475 
 476   static const TypeF *make(float f);
 477 
 478   virtual bool        is_finite() const;  // Has a finite value
 479   virtual bool        is_nan()    const;  // Is not a number (NaN)
 480 
 481   virtual const Type *xmeet( const Type *t ) const;
 482   virtual const Type *xdual() const;    // Compute dual right now.
 483   // Convenience common pre-built types.
 484   static const TypeF *ZERO; // positive zero only
 485   static const TypeF *ONE;
 486   static const TypeF *POS_INF;
 487   static const TypeF *NEG_INF;
 488 #ifndef PRODUCT
 489   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 490 #endif
 491 };
 492 
 493 //------------------------------TypeD------------------------------------------
 494 // Class of Double-Constant Types.
 495 class TypeD : public Type {
 496   TypeD( double d ) : Type(DoubleCon), _d(d) {};
 497 public:
 498   virtual bool eq( const Type *t ) const;
 499   virtual int  hash() const;             // Type specific hashing
 500   virtual bool singleton(void) const;    // TRUE if type is a singleton
 501   virtual bool empty(void) const;        // TRUE if type is vacuous
 502 public:
 503   const double _d;              // Double constant
 504 
 505   static const TypeD *make(double d);
 506 
 507   virtual bool        is_finite() const;  // Has a finite value
 508   virtual bool        is_nan()    const;  // Is not a number (NaN)
 509 
 510   virtual const Type *xmeet( const Type *t ) const;
 511   virtual const Type *xdual() const;    // Compute dual right now.
 512   // Convenience common pre-built types.
 513   static const TypeD *ZERO; // positive zero only
 514   static const TypeD *ONE;
 515   static const TypeD *POS_INF;
 516   static const TypeD *NEG_INF;
 517 #ifndef PRODUCT
 518   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 519 #endif
 520 };
 521 
 522 //------------------------------TypeInt----------------------------------------
 523 // Class of integer ranges, the set of integers between a lower bound and an
 524 // upper bound, inclusive.
 525 class TypeInt : public Type {
 526   TypeInt( jint lo, jint hi, int w );
 527 protected:
 528   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 529 
 530 public:
 531   typedef jint NativeType;
 532   virtual bool eq( const Type *t ) const;
 533   virtual int  hash() const;             // Type specific hashing
 534   virtual bool singleton(void) const;    // TRUE if type is a singleton
 535   virtual bool empty(void) const;        // TRUE if type is vacuous
 536   const jint _lo, _hi;          // Lower bound, upper bound
 537   const short _widen;           // Limit on times we widen this sucker
 538 
 539   static const TypeInt *make(jint lo);
 540   // must always specify w
 541   static const TypeInt *make(jint lo, jint hi, int w);
 542 
 543   // Check for single integer
 544   int is_con() const { return _lo==_hi; }
 545   bool is_con(int i) const { return is_con() &amp;&amp; _lo == i; }
 546   jint get_con() const { assert( is_con(), &quot;&quot; );  return _lo; }
 547 
 548   virtual bool        is_finite() const;  // Has a finite value
 549 
 550   virtual const Type *xmeet( const Type *t ) const;
 551   virtual const Type *xdual() const;    // Compute dual right now.
 552   virtual const Type *widen( const Type *t, const Type* limit_type ) const;
 553   virtual const Type *narrow( const Type *t ) const;
 554   // Do not kill _widen bits.
 555   // Convenience common pre-built types.
 556   static const TypeInt *MINUS_1;
 557   static const TypeInt *ZERO;
 558   static const TypeInt *ONE;
 559   static const TypeInt *BOOL;
 560   static const TypeInt *CC;
 561   static const TypeInt *CC_LT;  // [-1]  == MINUS_1
 562   static const TypeInt *CC_GT;  // [1]   == ONE
 563   static const TypeInt *CC_EQ;  // [0]   == ZERO
 564   static const TypeInt *CC_LE;  // [-1,0]
 565   static const TypeInt *CC_GE;  // [0,1] == BOOL (!)
 566   static const TypeInt *BYTE;
 567   static const TypeInt *UBYTE;
 568   static const TypeInt *CHAR;
 569   static const TypeInt *SHORT;
 570   static const TypeInt *POS;
 571   static const TypeInt *POS1;
 572   static const TypeInt *INT;
 573   static const TypeInt *SYMINT; // symmetric range [-max_jint..max_jint]
 574   static const TypeInt *TYPE_DOMAIN; // alias for TypeInt::INT
 575 
 576   static const TypeInt *as_self(const Type *t) { return t-&gt;is_int(); }
 577 #ifndef PRODUCT
 578   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 579 #endif
 580 };
 581 
 582 
 583 //------------------------------TypeLong---------------------------------------
 584 // Class of long integer ranges, the set of integers between a lower bound and
 585 // an upper bound, inclusive.
 586 class TypeLong : public Type {
 587   TypeLong( jlong lo, jlong hi, int w );
 588 protected:
 589   // Do not kill _widen bits.
 590   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 591 public:
 592   typedef jlong NativeType;
 593   virtual bool eq( const Type *t ) const;
 594   virtual int  hash() const;             // Type specific hashing
 595   virtual bool singleton(void) const;    // TRUE if type is a singleton
 596   virtual bool empty(void) const;        // TRUE if type is vacuous
 597 public:
 598   const jlong _lo, _hi;         // Lower bound, upper bound
 599   const short _widen;           // Limit on times we widen this sucker
 600 
 601   static const TypeLong *make(jlong lo);
 602   // must always specify w
 603   static const TypeLong *make(jlong lo, jlong hi, int w);
 604 
 605   // Check for single integer
 606   int is_con() const { return _lo==_hi; }
 607   bool is_con(int i) const { return is_con() &amp;&amp; _lo == i; }
 608   jlong get_con() const { assert( is_con(), &quot;&quot; ); return _lo; }
 609 
 610   // Check for positive 32-bit value.
 611   int is_positive_int() const { return _lo &gt;= 0 &amp;&amp; _hi &lt;= (jlong)max_jint; }
 612 
 613   virtual bool        is_finite() const;  // Has a finite value
 614 
 615 
 616   virtual const Type *xmeet( const Type *t ) const;
 617   virtual const Type *xdual() const;    // Compute dual right now.
 618   virtual const Type *widen( const Type *t, const Type* limit_type ) const;
 619   virtual const Type *narrow( const Type *t ) const;
 620   // Convenience common pre-built types.
 621   static const TypeLong *MINUS_1;
 622   static const TypeLong *ZERO;
 623   static const TypeLong *ONE;
 624   static const TypeLong *POS;
 625   static const TypeLong *LONG;
 626   static const TypeLong *INT;    // 32-bit subrange [min_jint..max_jint]
 627   static const TypeLong *UINT;   // 32-bit unsigned [0..max_juint]
 628   static const TypeLong *TYPE_DOMAIN; // alias for TypeLong::LONG
 629 
 630   // static convenience methods.
 631   static const TypeLong *as_self(const Type *t) { return t-&gt;is_long(); }
 632 
 633 #ifndef PRODUCT
 634   virtual void dump2( Dict &amp;d, uint, outputStream *st  ) const;// Specialized per-Type dumping
 635 #endif
 636 };
 637 
 638 //------------------------------TypeTuple--------------------------------------
 639 // Class of Tuple Types, essentially type collections for function signatures
 640 // and class layouts.  It happens to also be a fast cache for the HotSpot
 641 // signature types.
 642 class TypeTuple : public Type {
 643   TypeTuple( uint cnt, const Type **fields ) : Type(Tuple), _cnt(cnt), _fields(fields) { }
 644 
 645   const uint          _cnt;              // Count of fields
 646   const Type ** const _fields;           // Array of field types
 647 
 648 public:
 649   virtual bool eq( const Type *t ) const;
 650   virtual int  hash() const;             // Type specific hashing
 651   virtual bool singleton(void) const;    // TRUE if type is a singleton
 652   virtual bool empty(void) const;        // TRUE if type is vacuous
 653 
 654   // Accessors:
 655   uint cnt() const { return _cnt; }
 656   const Type* field_at(uint i) const {
 657     assert(i &lt; _cnt, &quot;oob&quot;);
 658     return _fields[i];
 659   }
 660   void set_field_at(uint i, const Type* t) {
 661     assert(i &lt; _cnt, &quot;oob&quot;);
 662     _fields[i] = t;
 663   }
 664 
 665   static const TypeTuple *make( uint cnt, const Type **fields );
 666   static const TypeTuple *make_range(ciSignature *sig);
 667   static const TypeTuple *make_domain(ciInstanceKlass* recv, ciSignature *sig);
 668 
 669   // Subroutine call type with space allocated for argument types
 670   // Memory for Control, I_O, Memory, FramePtr, and ReturnAdr is allocated implicitly
 671   static const Type **fields( uint arg_cnt );
 672 
 673   virtual const Type *xmeet( const Type *t ) const;
 674   virtual const Type *xdual() const;    // Compute dual right now.
 675   // Convenience common pre-built types.
 676   static const TypeTuple *IFBOTH;
 677   static const TypeTuple *IFFALSE;
 678   static const TypeTuple *IFTRUE;
 679   static const TypeTuple *IFNEITHER;
 680   static const TypeTuple *LOOPBODY;
 681   static const TypeTuple *MEMBAR;
 682   static const TypeTuple *STORECONDITIONAL;
 683   static const TypeTuple *START_I2C;
 684   static const TypeTuple *INT_PAIR;
 685   static const TypeTuple *LONG_PAIR;
 686   static const TypeTuple *INT_CC_PAIR;
 687   static const TypeTuple *LONG_CC_PAIR;
 688 #ifndef PRODUCT
 689   virtual void dump2( Dict &amp;d, uint, outputStream *st  ) const; // Specialized per-Type dumping
 690 #endif
 691 };
 692 
 693 //------------------------------TypeAry----------------------------------------
 694 // Class of Array Types
 695 class TypeAry : public Type {
 696   TypeAry(const Type* elem, const TypeInt* size, bool stable) : Type(Array),
 697       _elem(elem), _size(size), _stable(stable) {}
 698 public:
 699   virtual bool eq( const Type *t ) const;
 700   virtual int  hash() const;             // Type specific hashing
 701   virtual bool singleton(void) const;    // TRUE if type is a singleton
 702   virtual bool empty(void) const;        // TRUE if type is vacuous
 703 
 704 private:
 705   const Type *_elem;            // Element type of array
 706   const TypeInt *_size;         // Elements in array
 707   const bool _stable;           // Are elements @Stable?
 708   friend class TypeAryPtr;
 709 
 710 public:
 711   static const TypeAry* make(const Type* elem, const TypeInt* size, bool stable = false);
 712 
 713   virtual const Type *xmeet( const Type *t ) const;
 714   virtual const Type *xdual() const;    // Compute dual right now.
 715   bool ary_must_be_exact() const;  // true if arrays of such are never generic
 716   virtual const Type* remove_speculative() const;
 717   virtual const Type* cleanup_speculative() const;
 718 #ifdef ASSERT
 719   // One type is interface, the other is oop
 720   virtual bool interface_vs_oop(const Type *t) const;
 721 #endif
 722 #ifndef PRODUCT
 723   virtual void dump2( Dict &amp;d, uint, outputStream *st  ) const; // Specialized per-Type dumping
 724 #endif
 725 };
 726 
 727 //------------------------------TypeVect---------------------------------------
 728 // Class of Vector Types
 729 class TypeVect : public Type {
 730   const Type*   _elem;  // Vector&#39;s element type
 731   const uint  _length;  // Elements in vector (power of 2)
 732 
 733 protected:
 734   TypeVect(TYPES t, const Type* elem, uint length) : Type(t),
 735     _elem(elem), _length(length) {}
 736 
 737 public:
 738   const Type* element_type() const { return _elem; }
 739   BasicType element_basic_type() const { return _elem-&gt;array_element_basic_type(); }
 740   uint length() const { return _length; }
 741   uint length_in_bytes() const {
 742    return _length * type2aelembytes(element_basic_type());
 743   }
 744 
 745   virtual bool eq(const Type *t) const;
 746   virtual int  hash() const;             // Type specific hashing
 747   virtual bool singleton(void) const;    // TRUE if type is a singleton
 748   virtual bool empty(void) const;        // TRUE if type is vacuous
 749 
 750   static const TypeVect *make(const BasicType elem_bt, uint length) {
 751     // Use bottom primitive type.
 752     return make(get_const_basic_type(elem_bt), length);
 753   }
 754   // Used directly by Replicate nodes to construct singleton vector.
 755   static const TypeVect *make(const Type* elem, uint length);
 756 
 757   virtual const Type *xmeet( const Type *t) const;
 758   virtual const Type *xdual() const;     // Compute dual right now.
 759 
 760   static const TypeVect *VECTS;
 761   static const TypeVect *VECTD;
 762   static const TypeVect *VECTX;
 763   static const TypeVect *VECTY;
 764   static const TypeVect *VECTZ;
 765 
 766 #ifndef PRODUCT
 767   virtual void dump2(Dict &amp;d, uint, outputStream *st) const; // Specialized per-Type dumping
 768 #endif
 769 };
 770 
 771 class TypeVectS : public TypeVect {
 772   friend class TypeVect;
 773   TypeVectS(const Type* elem, uint length) : TypeVect(VectorS, elem, length) {}
 774 };
 775 
 776 class TypeVectD : public TypeVect {
 777   friend class TypeVect;
 778   TypeVectD(const Type* elem, uint length) : TypeVect(VectorD, elem, length) {}
 779 };
 780 
 781 class TypeVectX : public TypeVect {
 782   friend class TypeVect;
 783   TypeVectX(const Type* elem, uint length) : TypeVect(VectorX, elem, length) {}
 784 };
 785 
 786 class TypeVectY : public TypeVect {
 787   friend class TypeVect;
 788   TypeVectY(const Type* elem, uint length) : TypeVect(VectorY, elem, length) {}
 789 };
 790 
 791 class TypeVectZ : public TypeVect {
 792   friend class TypeVect;
 793   TypeVectZ(const Type* elem, uint length) : TypeVect(VectorZ, elem, length) {}
 794 };
 795 
 796 //------------------------------TypePtr----------------------------------------
 797 // Class of machine Pointer Types: raw data, instances or arrays.
 798 // If the _base enum is AnyPtr, then this refers to all of the above.
 799 // Otherwise the _base will indicate which subset of pointers is affected,
 800 // and the class will be inherited from.
 801 class TypePtr : public Type {
 802   friend class TypeNarrowPtr;
 803 public:
 804   enum PTR { TopPTR, AnyNull, Constant, Null, NotNull, BotPTR, lastPTR };
 805 protected:
 806   TypePtr(TYPES t, PTR ptr, int offset,
 807           const TypePtr* speculative = NULL,
 808           int inline_depth = InlineDepthBottom) :
 809     Type(t), _speculative(speculative), _inline_depth(inline_depth), _offset(offset),
 810     _ptr(ptr) {}
 811   static const PTR ptr_meet[lastPTR][lastPTR];
 812   static const PTR ptr_dual[lastPTR];
 813   static const char * const ptr_msg[lastPTR];
 814 
 815   enum {
 816     InlineDepthBottom = INT_MAX,
 817     InlineDepthTop = -InlineDepthBottom
 818   };
 819 
 820   // Extra type information profiling gave us. We propagate it the
 821   // same way the rest of the type info is propagated. If we want to
 822   // use it, then we have to emit a guard: this part of the type is
 823   // not something we know but something we speculate about the type.
 824   const TypePtr*   _speculative;
 825   // For speculative types, we record at what inlining depth the
 826   // profiling point that provided the data is. We want to favor
 827   // profile data coming from outer scopes which are likely better for
 828   // the current compilation.
 829   int _inline_depth;
 830 
 831   // utility methods to work on the speculative part of the type
 832   const TypePtr* dual_speculative() const;
 833   const TypePtr* xmeet_speculative(const TypePtr* other) const;
 834   bool eq_speculative(const TypePtr* other) const;
 835   int hash_speculative() const;
 836   const TypePtr* add_offset_speculative(intptr_t offset) const;
 837 #ifndef PRODUCT
 838   void dump_speculative(outputStream *st) const;
 839 #endif
 840 
 841   // utility methods to work on the inline depth of the type
 842   int dual_inline_depth() const;
 843   int meet_inline_depth(int depth) const;
 844 #ifndef PRODUCT
 845   void dump_inline_depth(outputStream *st) const;
 846 #endif
 847 
 848 public:
 849   const int _offset;            // Offset into oop, with TOP &amp; BOT
 850   const PTR _ptr;               // Pointer equivalence class
 851 
 852   const int offset() const { return _offset; }
 853   const PTR ptr()    const { return _ptr; }
 854 
 855   static const TypePtr *make(TYPES t, PTR ptr, int offset,
 856                              const TypePtr* speculative = NULL,
 857                              int inline_depth = InlineDepthBottom);
 858 
 859   // Return a &#39;ptr&#39; version of this type
 860   virtual const Type *cast_to_ptr_type(PTR ptr) const;
 861 
 862   virtual intptr_t get_con() const;
 863 
 864   int xadd_offset( intptr_t offset ) const;
 865   virtual const TypePtr *add_offset( intptr_t offset ) const;
 866   virtual bool eq(const Type *t) const;
 867   virtual int  hash() const;             // Type specific hashing
 868 
 869   virtual bool singleton(void) const;    // TRUE if type is a singleton
 870   virtual bool empty(void) const;        // TRUE if type is vacuous
 871   virtual const Type *xmeet( const Type *t ) const;
 872   virtual const Type *xmeet_helper( const Type *t ) const;
 873   int meet_offset( int offset ) const;
 874   int dual_offset( ) const;
 875   virtual const Type *xdual() const;    // Compute dual right now.
 876 
 877   // meet, dual and join over pointer equivalence sets
 878   PTR meet_ptr( const PTR in_ptr ) const { return ptr_meet[in_ptr][ptr()]; }
 879   PTR dual_ptr()                   const { return ptr_dual[ptr()];      }
 880 
 881   // This is textually confusing unless one recalls that
 882   // join(t) == dual()-&gt;meet(t-&gt;dual())-&gt;dual().
 883   PTR join_ptr( const PTR in_ptr ) const {
 884     return ptr_dual[ ptr_meet[ ptr_dual[in_ptr] ] [ dual_ptr() ] ];
 885   }
 886 
 887   // Speculative type helper methods.
 888   virtual const TypePtr* speculative() const { return _speculative; }
 889   int inline_depth() const                   { return _inline_depth; }
 890   virtual ciKlass* speculative_type() const;
 891   virtual ciKlass* speculative_type_not_null() const;
 892   virtual bool speculative_maybe_null() const;
 893   virtual bool speculative_always_null() const;
 894   virtual const Type* remove_speculative() const;
 895   virtual const Type* cleanup_speculative() const;
 896   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const;
 897   virtual bool would_improve_ptr(ProfilePtrKind maybe_null) const;
 898   virtual const TypePtr* with_inline_depth(int depth) const;
 899 
 900   virtual bool maybe_null() const { return meet_ptr(Null) == ptr(); }
 901 
 902   // Tests for relation to centerline of type lattice:
 903   static bool above_centerline(PTR ptr) { return (ptr &lt;= AnyNull); }
 904   static bool below_centerline(PTR ptr) { return (ptr &gt;= NotNull); }
 905   // Convenience common pre-built types.
 906   static const TypePtr *NULL_PTR;
 907   static const TypePtr *NOTNULL;
 908   static const TypePtr *BOTTOM;
 909 #ifndef PRODUCT
 910   virtual void dump2( Dict &amp;d, uint depth, outputStream *st  ) const;
 911 #endif
 912 };
 913 
 914 //------------------------------TypeRawPtr-------------------------------------
 915 // Class of raw pointers, pointers to things other than Oops.  Examples
 916 // include the stack pointer, top of heap, card-marking area, handles, etc.
 917 class TypeRawPtr : public TypePtr {
 918 protected:
 919   TypeRawPtr( PTR ptr, address bits ) : TypePtr(RawPtr,ptr,0), _bits(bits){}
 920 public:
 921   virtual bool eq( const Type *t ) const;
 922   virtual int  hash() const;     // Type specific hashing
 923 
 924   const address _bits;          // Constant value, if applicable
 925 
 926   static const TypeRawPtr *make( PTR ptr );
 927   static const TypeRawPtr *make( address bits );
 928 
 929   // Return a &#39;ptr&#39; version of this type
 930   virtual const Type *cast_to_ptr_type(PTR ptr) const;
 931 
 932   virtual intptr_t get_con() const;
 933 
 934   virtual const TypePtr *add_offset( intptr_t offset ) const;
 935 
 936   virtual const Type *xmeet( const Type *t ) const;
 937   virtual const Type *xdual() const;    // Compute dual right now.
 938   // Convenience common pre-built types.
 939   static const TypeRawPtr *BOTTOM;
 940   static const TypeRawPtr *NOTNULL;
 941 #ifndef PRODUCT
 942   virtual void dump2( Dict &amp;d, uint depth, outputStream *st  ) const;
 943 #endif
 944 };
 945 
 946 //------------------------------TypeOopPtr-------------------------------------
 947 // Some kind of oop (Java pointer), either instance or array.
 948 class TypeOopPtr : public TypePtr {
 949 protected:
 950   TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset, int instance_id,
 951              const TypePtr* speculative, int inline_depth);
 952 public:
 953   virtual bool eq( const Type *t ) const;
 954   virtual int  hash() const;             // Type specific hashing
 955   virtual bool singleton(void) const;    // TRUE if type is a singleton
 956   enum {
 957    InstanceTop = -1,   // undefined instance
 958    InstanceBot = 0     // any possible instance
 959   };
 960 protected:
 961 
 962   // Oop is NULL, unless this is a constant oop.
 963   ciObject*     _const_oop;   // Constant oop
 964   // If _klass is NULL, then so is _sig.  This is an unloaded klass.
 965   ciKlass*      _klass;       // Klass object
 966   // Does the type exclude subclasses of the klass?  (Inexact == polymorphic.)
 967   bool          _klass_is_exact;
 968   bool          _is_ptr_to_narrowoop;
 969   bool          _is_ptr_to_narrowklass;
 970   bool          _is_ptr_to_boxed_value;
 971 
 972   // If not InstanceTop or InstanceBot, indicates that this is
 973   // a particular instance of this type which is distinct.
 974   // This is the node index of the allocation node creating this instance.
 975   int           _instance_id;
 976 
 977   static const TypeOopPtr* make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact);
 978 
 979   int dual_instance_id() const;
 980   int meet_instance_id(int uid) const;
 981 
 982   // Do not allow interface-vs.-noninterface joins to collapse to top.
 983   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 984 
 985 public:
 986   // Creates a type given a klass. Correctly handles multi-dimensional arrays
 987   // Respects UseUniqueSubclasses.
 988   // If the klass is final, the resulting type will be exact.
 989   static const TypeOopPtr* make_from_klass(ciKlass* klass) {
 990     return make_from_klass_common(klass, true, false);
 991   }
 992   // Same as before, but will produce an exact type, even if
 993   // the klass is not final, as long as it has exactly one implementation.
 994   static const TypeOopPtr* make_from_klass_unique(ciKlass* klass) {
 995     return make_from_klass_common(klass, true, true);
 996   }
 997   // Same as before, but does not respects UseUniqueSubclasses.
 998   // Use this only for creating array element types.
 999   static const TypeOopPtr* make_from_klass_raw(ciKlass* klass) {
1000     return make_from_klass_common(klass, false, false);
1001   }
1002   // Creates a singleton type given an object.
1003   // If the object cannot be rendered as a constant,
1004   // may return a non-singleton type.
1005   // If require_constant, produce a NULL if a singleton is not possible.
1006   static const TypeOopPtr* make_from_constant(ciObject* o,
1007                                               bool require_constant = false);
1008 
1009   // Make a generic (unclassed) pointer to an oop.
1010   static const TypeOopPtr* make(PTR ptr, int offset, int instance_id,
1011                                 const TypePtr* speculative = NULL,
1012                                 int inline_depth = InlineDepthBottom);
1013 
1014   ciObject* const_oop()    const { return _const_oop; }
1015   virtual ciKlass* klass() const { return _klass;     }
1016   bool klass_is_exact()    const { return _klass_is_exact; }
1017 
1018   // Returns true if this pointer points at memory which contains a
1019   // compressed oop references.
1020   bool is_ptr_to_narrowoop_nv() const { return _is_ptr_to_narrowoop; }
1021   bool is_ptr_to_narrowklass_nv() const { return _is_ptr_to_narrowklass; }
1022   bool is_ptr_to_boxed_value()   const { return _is_ptr_to_boxed_value; }
1023   bool is_known_instance()       const { return _instance_id &gt; 0; }
1024   int  instance_id()             const { return _instance_id; }
1025   bool is_known_instance_field() const { return is_known_instance() &amp;&amp; _offset &gt;= 0; }
1026 
1027   virtual intptr_t get_con() const;
1028 
1029   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1030 
1031   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1032 
1033   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1034 
<a name="4" id="anc4"></a><span class="line-removed">1035   virtual const TypeOopPtr *cast_to_nonconst() const;</span>
<span class="line-removed">1036 </span>
1037   // corresponding pointer to klass, for a given instance
1038   const TypeKlassPtr* as_klass_type() const;
1039 
1040   virtual const TypePtr *add_offset( intptr_t offset ) const;
1041 
1042   // Speculative type helper methods.
1043   virtual const Type* remove_speculative() const;
1044   virtual const Type* cleanup_speculative() const;
1045   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const;
1046   virtual const TypePtr* with_inline_depth(int depth) const;
1047 
1048   virtual const TypePtr* with_instance_id(int instance_id) const;
1049 
1050   virtual const Type *xdual() const;    // Compute dual right now.
1051   // the core of the computation of the meet for TypeOopPtr and for its subclasses
1052   virtual const Type *xmeet_helper(const Type *t) const;
1053 
1054   // Convenience common pre-built type.
1055   static const TypeOopPtr *BOTTOM;
1056 #ifndef PRODUCT
1057   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1058 #endif
1059 };
1060 
1061 //------------------------------TypeInstPtr------------------------------------
1062 // Class of Java object pointers, pointing either to non-array Java instances
1063 // or to a Klass* (including array klasses).
1064 class TypeInstPtr : public TypeOopPtr {
1065   TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset, int instance_id,
1066               const TypePtr* speculative, int inline_depth);
1067   virtual bool eq( const Type *t ) const;
1068   virtual int  hash() const;             // Type specific hashing
1069 
1070   ciSymbol*  _name;        // class name
1071 
1072  public:
1073   ciSymbol* name()         const { return _name; }
1074 
1075   bool  is_loaded() const { return _klass-&gt;is_loaded(); }
1076 
1077   // Make a pointer to a constant oop.
1078   static const TypeInstPtr *make(ciObject* o) {
1079     return make(TypePtr::Constant, o-&gt;klass(), true, o, 0, InstanceBot);
1080   }
1081   // Make a pointer to a constant oop with offset.
1082   static const TypeInstPtr *make(ciObject* o, int offset) {
1083     return make(TypePtr::Constant, o-&gt;klass(), true, o, offset, InstanceBot);
1084   }
1085 
1086   // Make a pointer to some value of type klass.
1087   static const TypeInstPtr *make(PTR ptr, ciKlass* klass) {
1088     return make(ptr, klass, false, NULL, 0, InstanceBot);
1089   }
1090 
1091   // Make a pointer to some non-polymorphic value of exactly type klass.
1092   static const TypeInstPtr *make_exact(PTR ptr, ciKlass* klass) {
1093     return make(ptr, klass, true, NULL, 0, InstanceBot);
1094   }
1095 
1096   // Make a pointer to some value of type klass with offset.
1097   static const TypeInstPtr *make(PTR ptr, ciKlass* klass, int offset) {
1098     return make(ptr, klass, false, NULL, offset, InstanceBot);
1099   }
1100 
1101   // Make a pointer to an oop.
1102   static const TypeInstPtr *make(PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset,
1103                                  int instance_id = InstanceBot,
1104                                  const TypePtr* speculative = NULL,
1105                                  int inline_depth = InlineDepthBottom);
1106 
1107   /** Create constant type for a constant boxed value */
1108   const Type* get_const_boxed_value() const;
1109 
1110   // If this is a java.lang.Class constant, return the type for it or NULL.
1111   // Pass to Type::get_const_type to turn it to a type, which will usually
1112   // be a TypeInstPtr, but may also be a TypeInt::INT for int.class, etc.
1113   ciType* java_mirror_type() const;
1114 
1115   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1116 
1117   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1118 
1119   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1120 
<a name="5" id="anc5"></a><span class="line-removed">1121   virtual const TypeOopPtr *cast_to_nonconst() const;</span>
<span class="line-removed">1122 </span>
1123   virtual const TypePtr *add_offset( intptr_t offset ) const;
1124 
1125   // Speculative type helper methods.
1126   virtual const Type* remove_speculative() const;
1127   virtual const TypePtr* with_inline_depth(int depth) const;
1128   virtual const TypePtr* with_instance_id(int instance_id) const;
1129 
1130   // the core of the computation of the meet of 2 types
1131   virtual const Type *xmeet_helper(const Type *t) const;
1132   virtual const TypeInstPtr *xmeet_unloaded( const TypeInstPtr *t ) const;
1133   virtual const Type *xdual() const;    // Compute dual right now.
1134 
1135   // Convenience common pre-built types.
1136   static const TypeInstPtr *NOTNULL;
1137   static const TypeInstPtr *BOTTOM;
1138   static const TypeInstPtr *MIRROR;
1139   static const TypeInstPtr *MARK;
1140   static const TypeInstPtr *KLASS;
1141 #ifndef PRODUCT
1142   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1143 #endif
1144 };
1145 
1146 //------------------------------TypeAryPtr-------------------------------------
1147 // Class of Java array pointers
1148 class TypeAryPtr : public TypeOopPtr {
1149   TypeAryPtr( PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk,
1150               int offset, int instance_id, bool is_autobox_cache,
1151               const TypePtr* speculative, int inline_depth)
1152     : TypeOopPtr(AryPtr,ptr,k,xk,o,offset, instance_id, speculative, inline_depth),
1153     _ary(ary),
1154     _is_autobox_cache(is_autobox_cache)
1155  {
1156 #ifdef ASSERT
1157     if (k != NULL) {
1158       // Verify that specified klass and TypeAryPtr::klass() follow the same rules.
1159       ciKlass* ck = compute_klass(true);
1160       if (k != ck) {
1161         this-&gt;dump(); tty-&gt;cr();
1162         tty-&gt;print(&quot; k: &quot;);
1163         k-&gt;print(); tty-&gt;cr();
1164         tty-&gt;print(&quot;ck: &quot;);
1165         if (ck != NULL) ck-&gt;print();
1166         else tty-&gt;print(&quot;&lt;NULL&gt;&quot;);
1167         tty-&gt;cr();
1168         assert(false, &quot;unexpected TypeAryPtr::_klass&quot;);
1169       }
1170     }
1171 #endif
1172   }
1173   virtual bool eq( const Type *t ) const;
1174   virtual int hash() const;     // Type specific hashing
1175   const TypeAry *_ary;          // Array we point into
1176   const bool     _is_autobox_cache;
1177 
1178   ciKlass* compute_klass(DEBUG_ONLY(bool verify = false)) const;
1179 
1180 public:
1181   // Accessors
1182   ciKlass* klass() const;
1183   const TypeAry* ary() const  { return _ary; }
1184   const Type*    elem() const { return _ary-&gt;_elem; }
1185   const TypeInt* size() const { return _ary-&gt;_size; }
1186   bool      is_stable() const { return _ary-&gt;_stable; }
1187 
1188   bool is_autobox_cache() const { return _is_autobox_cache; }
1189 
1190   static const TypeAryPtr *make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, int offset,
1191                                 int instance_id = InstanceBot,
1192                                 const TypePtr* speculative = NULL,
1193                                 int inline_depth = InlineDepthBottom);
1194   // Constant pointer to array
1195   static const TypeAryPtr *make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, int offset,
1196                                 int instance_id = InstanceBot,
1197                                 const TypePtr* speculative = NULL,
1198                                 int inline_depth = InlineDepthBottom, bool is_autobox_cache = false);
1199 
1200   // Return a &#39;ptr&#39; version of this type
1201   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1202 
1203   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1204 
1205   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1206 
<a name="6" id="anc6"></a><span class="line-removed">1207   virtual const TypeOopPtr *cast_to_nonconst() const;</span>
<span class="line-removed">1208 </span>
1209   virtual const TypeAryPtr* cast_to_size(const TypeInt* size) const;
1210   virtual const TypeInt* narrow_size_type(const TypeInt* size) const;
1211 
1212   virtual bool empty(void) const;        // TRUE if type is vacuous
1213   virtual const TypePtr *add_offset( intptr_t offset ) const;
1214 
1215   // Speculative type helper methods.
1216   virtual const Type* remove_speculative() const;
1217   virtual const TypePtr* with_inline_depth(int depth) const;
1218   virtual const TypePtr* with_instance_id(int instance_id) const;
1219 
1220   // the core of the computation of the meet of 2 types
1221   virtual const Type *xmeet_helper(const Type *t) const;
1222   virtual const Type *xdual() const;    // Compute dual right now.
1223 
1224   const TypeAryPtr* cast_to_stable(bool stable, int stable_dimension = 1) const;
1225   int stable_dimension() const;
1226 
1227   const TypeAryPtr* cast_to_autobox_cache(bool cache) const;
1228 
<a name="7" id="anc7"></a>

1229   // Convenience common pre-built types.
1230   static const TypeAryPtr *RANGE;
1231   static const TypeAryPtr *OOPS;
1232   static const TypeAryPtr *NARROWOOPS;
1233   static const TypeAryPtr *BYTES;
1234   static const TypeAryPtr *SHORTS;
1235   static const TypeAryPtr *CHARS;
1236   static const TypeAryPtr *INTS;
1237   static const TypeAryPtr *LONGS;
1238   static const TypeAryPtr *FLOATS;
1239   static const TypeAryPtr *DOUBLES;
1240   // selects one of the above:
1241   static const TypeAryPtr *get_array_body_type(BasicType elem) {
1242     assert((uint)elem &lt;= T_CONFLICT &amp;&amp; _array_body_type[elem] != NULL, &quot;bad elem type&quot;);
1243     return _array_body_type[elem];
1244   }
1245   static const TypeAryPtr *_array_body_type[T_CONFLICT+1];
1246   // sharpen the type of an int which is used as an array size
1247 #ifdef ASSERT
1248   // One type is interface, the other is oop
1249   virtual bool interface_vs_oop(const Type *t) const;
1250 #endif
1251 #ifndef PRODUCT
1252   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1253 #endif
1254 };
1255 
1256 //------------------------------TypeMetadataPtr-------------------------------------
1257 // Some kind of metadata, either Method*, MethodData* or CPCacheOop
1258 class TypeMetadataPtr : public TypePtr {
1259 protected:
1260   TypeMetadataPtr(PTR ptr, ciMetadata* metadata, int offset);
1261   // Do not allow interface-vs.-noninterface joins to collapse to top.
1262   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1263 public:
1264   virtual bool eq( const Type *t ) const;
1265   virtual int  hash() const;             // Type specific hashing
1266   virtual bool singleton(void) const;    // TRUE if type is a singleton
1267 
1268 private:
1269   ciMetadata*   _metadata;
1270 
1271 public:
1272   static const TypeMetadataPtr* make(PTR ptr, ciMetadata* m, int offset);
1273 
1274   static const TypeMetadataPtr* make(ciMethod* m);
1275   static const TypeMetadataPtr* make(ciMethodData* m);
1276 
1277   ciMetadata* metadata() const { return _metadata; }
1278 
1279   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1280 
1281   virtual const TypePtr *add_offset( intptr_t offset ) const;
1282 
1283   virtual const Type *xmeet( const Type *t ) const;
1284   virtual const Type *xdual() const;    // Compute dual right now.
1285 
1286   virtual intptr_t get_con() const;
1287 
1288   // Convenience common pre-built types.
1289   static const TypeMetadataPtr *BOTTOM;
1290 
1291 #ifndef PRODUCT
1292   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1293 #endif
1294 };
1295 
1296 //------------------------------TypeKlassPtr-----------------------------------
1297 // Class of Java Klass pointers
1298 class TypeKlassPtr : public TypePtr {
1299   TypeKlassPtr( PTR ptr, ciKlass* klass, int offset );
1300 
1301 protected:
1302   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1303  public:
1304   virtual bool eq( const Type *t ) const;
1305   virtual int hash() const;             // Type specific hashing
1306   virtual bool singleton(void) const;    // TRUE if type is a singleton
1307  private:
1308 
1309   static const TypeKlassPtr* make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact);
1310 
1311   ciKlass* _klass;
1312 
1313   // Does the type exclude subclasses of the klass?  (Inexact == polymorphic.)
1314   bool          _klass_is_exact;
1315 
1316 public:
1317   ciSymbol* name()  const { return klass()-&gt;name(); }
1318 
1319   ciKlass* klass() const { return  _klass; }
1320   bool klass_is_exact()    const { return _klass_is_exact; }
1321 
1322   bool  is_loaded() const { return klass()-&gt;is_loaded(); }
1323 
1324   // Creates a type given a klass. Correctly handles multi-dimensional arrays
1325   // Respects UseUniqueSubclasses.
1326   // If the klass is final, the resulting type will be exact.
1327   static const TypeKlassPtr* make_from_klass(ciKlass* klass) {
1328     return make_from_klass_common(klass, true, false);
1329   }
1330   // Same as before, but will produce an exact type, even if
1331   // the klass is not final, as long as it has exactly one implementation.
1332   static const TypeKlassPtr* make_from_klass_unique(ciKlass* klass) {
1333     return make_from_klass_common(klass, true, true);
1334   }
1335   // Same as before, but does not respects UseUniqueSubclasses.
1336   // Use this only for creating array element types.
1337   static const TypeKlassPtr* make_from_klass_raw(ciKlass* klass) {
1338     return make_from_klass_common(klass, false, false);
1339   }
1340 
1341   // Make a generic (unclassed) pointer to metadata.
1342   static const TypeKlassPtr* make(PTR ptr, int offset);
1343 
1344   // ptr to klass &#39;k&#39;
1345   static const TypeKlassPtr *make( ciKlass* k ) { return make( TypePtr::Constant, k, 0); }
1346   // ptr to klass &#39;k&#39; with offset
1347   static const TypeKlassPtr *make( ciKlass* k, int offset ) { return make( TypePtr::Constant, k, offset); }
1348   // ptr to klass &#39;k&#39; or sub-klass
1349   static const TypeKlassPtr *make( PTR ptr, ciKlass* k, int offset);
1350 
1351   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1352 
1353   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1354 
1355   // corresponding pointer to instance, for a given class
1356   const TypeOopPtr* as_instance_type() const;
1357 
1358   virtual const TypePtr *add_offset( intptr_t offset ) const;
1359   virtual const Type    *xmeet( const Type *t ) const;
1360   virtual const Type    *xdual() const;      // Compute dual right now.
1361 
1362   virtual intptr_t get_con() const;
1363 
1364   // Convenience common pre-built types.
1365   static const TypeKlassPtr* OBJECT; // Not-null object klass or below
1366   static const TypeKlassPtr* OBJECT_OR_NULL; // Maybe-null version of same
1367 #ifndef PRODUCT
1368   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1369 #endif
1370 };
1371 
1372 class TypeNarrowPtr : public Type {
1373 protected:
1374   const TypePtr* _ptrtype; // Could be TypePtr::NULL_PTR
1375 
1376   TypeNarrowPtr(TYPES t, const TypePtr* ptrtype): Type(t),
1377                                                   _ptrtype(ptrtype) {
1378     assert(ptrtype-&gt;offset() == 0 ||
1379            ptrtype-&gt;offset() == OffsetBot ||
1380            ptrtype-&gt;offset() == OffsetTop, &quot;no real offsets&quot;);
1381   }
1382 
1383   virtual const TypeNarrowPtr *isa_same_narrowptr(const Type *t) const = 0;
1384   virtual const TypeNarrowPtr *is_same_narrowptr(const Type *t) const = 0;
1385   virtual const TypeNarrowPtr *make_same_narrowptr(const TypePtr *t) const = 0;
1386   virtual const TypeNarrowPtr *make_hash_same_narrowptr(const TypePtr *t) const = 0;
1387   // Do not allow interface-vs.-noninterface joins to collapse to top.
1388   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1389 public:
1390   virtual bool eq( const Type *t ) const;
1391   virtual int  hash() const;             // Type specific hashing
1392   virtual bool singleton(void) const;    // TRUE if type is a singleton
1393 
1394   virtual const Type *xmeet( const Type *t ) const;
1395   virtual const Type *xdual() const;    // Compute dual right now.
1396 
1397   virtual intptr_t get_con() const;
1398 
1399   virtual bool empty(void) const;        // TRUE if type is vacuous
1400 
1401   // returns the equivalent ptr type for this compressed pointer
1402   const TypePtr *get_ptrtype() const {
1403     return _ptrtype;
1404   }
1405 
1406 #ifndef PRODUCT
1407   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1408 #endif
1409 };
1410 
1411 //------------------------------TypeNarrowOop----------------------------------
1412 // A compressed reference to some kind of Oop.  This type wraps around
1413 // a preexisting TypeOopPtr and forwards most of it&#39;s operations to
1414 // the underlying type.  It&#39;s only real purpose is to track the
1415 // oopness of the compressed oop value when we expose the conversion
1416 // between the normal and the compressed form.
1417 class TypeNarrowOop : public TypeNarrowPtr {
1418 protected:
1419   TypeNarrowOop( const TypePtr* ptrtype): TypeNarrowPtr(NarrowOop, ptrtype) {
1420   }
1421 
1422   virtual const TypeNarrowPtr *isa_same_narrowptr(const Type *t) const {
1423     return t-&gt;isa_narrowoop();
1424   }
1425 
1426   virtual const TypeNarrowPtr *is_same_narrowptr(const Type *t) const {
1427     return t-&gt;is_narrowoop();
1428   }
1429 
1430   virtual const TypeNarrowPtr *make_same_narrowptr(const TypePtr *t) const {
1431     return new TypeNarrowOop(t);
1432   }
1433 
1434   virtual const TypeNarrowPtr *make_hash_same_narrowptr(const TypePtr *t) const {
1435     return (const TypeNarrowPtr*)((new TypeNarrowOop(t))-&gt;hashcons());
1436   }
1437 
1438 public:
1439 
1440   static const TypeNarrowOop *make( const TypePtr* type);
1441 
1442   static const TypeNarrowOop* make_from_constant(ciObject* con, bool require_constant = false) {
1443     return make(TypeOopPtr::make_from_constant(con, require_constant));
1444   }
1445 
1446   static const TypeNarrowOop *BOTTOM;
1447   static const TypeNarrowOop *NULL_PTR;
1448 
1449   virtual const Type* remove_speculative() const;
1450   virtual const Type* cleanup_speculative() const;
1451 
1452 #ifndef PRODUCT
1453   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1454 #endif
1455 };
1456 
1457 //------------------------------TypeNarrowKlass----------------------------------
1458 // A compressed reference to klass pointer.  This type wraps around a
1459 // preexisting TypeKlassPtr and forwards most of it&#39;s operations to
1460 // the underlying type.
1461 class TypeNarrowKlass : public TypeNarrowPtr {
1462 protected:
1463   TypeNarrowKlass( const TypePtr* ptrtype): TypeNarrowPtr(NarrowKlass, ptrtype) {
1464   }
1465 
1466   virtual const TypeNarrowPtr *isa_same_narrowptr(const Type *t) const {
1467     return t-&gt;isa_narrowklass();
1468   }
1469 
1470   virtual const TypeNarrowPtr *is_same_narrowptr(const Type *t) const {
1471     return t-&gt;is_narrowklass();
1472   }
1473 
1474   virtual const TypeNarrowPtr *make_same_narrowptr(const TypePtr *t) const {
1475     return new TypeNarrowKlass(t);
1476   }
1477 
1478   virtual const TypeNarrowPtr *make_hash_same_narrowptr(const TypePtr *t) const {
1479     return (const TypeNarrowPtr*)((new TypeNarrowKlass(t))-&gt;hashcons());
1480   }
1481 
1482 public:
1483   static const TypeNarrowKlass *make( const TypePtr* type);
1484 
1485   // static const TypeNarrowKlass *BOTTOM;
1486   static const TypeNarrowKlass *NULL_PTR;
1487 
1488 #ifndef PRODUCT
1489   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1490 #endif
1491 };
1492 
1493 //------------------------------TypeFunc---------------------------------------
1494 // Class of Array Types
1495 class TypeFunc : public Type {
1496   TypeFunc( const TypeTuple *domain, const TypeTuple *range ) : Type(Function),  _domain(domain), _range(range) {}
1497   virtual bool eq( const Type *t ) const;
1498   virtual int  hash() const;             // Type specific hashing
1499   virtual bool singleton(void) const;    // TRUE if type is a singleton
1500   virtual bool empty(void) const;        // TRUE if type is vacuous
1501 
1502   const TypeTuple* const _domain;     // Domain of inputs
1503   const TypeTuple* const _range;      // Range of results
1504 
1505 public:
1506   // Constants are shared among ADLC and VM
1507   enum { Control    = AdlcVMDeps::Control,
1508          I_O        = AdlcVMDeps::I_O,
1509          Memory     = AdlcVMDeps::Memory,
1510          FramePtr   = AdlcVMDeps::FramePtr,
1511          ReturnAdr  = AdlcVMDeps::ReturnAdr,
1512          Parms      = AdlcVMDeps::Parms
1513   };
1514 
1515 
1516   // Accessors:
1517   const TypeTuple* domain() const { return _domain; }
1518   const TypeTuple* range()  const { return _range; }
1519 
1520   static const TypeFunc *make(ciMethod* method);
1521   static const TypeFunc *make(ciSignature signature, const Type* extra);
1522   static const TypeFunc *make(const TypeTuple* domain, const TypeTuple* range);
1523 
1524   virtual const Type *xmeet( const Type *t ) const;
1525   virtual const Type *xdual() const;    // Compute dual right now.
1526 
1527   BasicType return_type() const;
1528 
1529 #ifndef PRODUCT
1530   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1531 #endif
1532   // Convenience common pre-built types.
1533 };
1534 
1535 //------------------------------accessors--------------------------------------
1536 inline bool Type::is_ptr_to_narrowoop() const {
1537 #ifdef _LP64
1538   return (isa_oopptr() != NULL &amp;&amp; is_oopptr()-&gt;is_ptr_to_narrowoop_nv());
1539 #else
1540   return false;
1541 #endif
1542 }
1543 
1544 inline bool Type::is_ptr_to_narrowklass() const {
1545 #ifdef _LP64
1546   return (isa_oopptr() != NULL &amp;&amp; is_oopptr()-&gt;is_ptr_to_narrowklass_nv());
1547 #else
1548   return false;
1549 #endif
1550 }
1551 
1552 inline float Type::getf() const {
1553   assert( _base == FloatCon, &quot;Not a FloatCon&quot; );
1554   return ((TypeF*)this)-&gt;_f;
1555 }
1556 
1557 inline double Type::getd() const {
1558   assert( _base == DoubleCon, &quot;Not a DoubleCon&quot; );
1559   return ((TypeD*)this)-&gt;_d;
1560 }
1561 
1562 inline const TypeInt *Type::is_int() const {
1563   assert( _base == Int, &quot;Not an Int&quot; );
1564   return (TypeInt*)this;
1565 }
1566 
1567 inline const TypeInt *Type::isa_int() const {
1568   return ( _base == Int ? (TypeInt*)this : NULL);
1569 }
1570 
1571 inline const TypeLong *Type::is_long() const {
1572   assert( _base == Long, &quot;Not a Long&quot; );
1573   return (TypeLong*)this;
1574 }
1575 
1576 inline const TypeLong *Type::isa_long() const {
1577   return ( _base == Long ? (TypeLong*)this : NULL);
1578 }
1579 
1580 inline const TypeF *Type::isa_float() const {
1581   return ((_base == FloatTop ||
1582            _base == FloatCon ||
1583            _base == FloatBot) ? (TypeF*)this : NULL);
1584 }
1585 
1586 inline const TypeF *Type::is_float_constant() const {
1587   assert( _base == FloatCon, &quot;Not a Float&quot; );
1588   return (TypeF*)this;
1589 }
1590 
1591 inline const TypeF *Type::isa_float_constant() const {
1592   return ( _base == FloatCon ? (TypeF*)this : NULL);
1593 }
1594 
1595 inline const TypeD *Type::isa_double() const {
1596   return ((_base == DoubleTop ||
1597            _base == DoubleCon ||
1598            _base == DoubleBot) ? (TypeD*)this : NULL);
1599 }
1600 
1601 inline const TypeD *Type::is_double_constant() const {
1602   assert( _base == DoubleCon, &quot;Not a Double&quot; );
1603   return (TypeD*)this;
1604 }
1605 
1606 inline const TypeD *Type::isa_double_constant() const {
1607   return ( _base == DoubleCon ? (TypeD*)this : NULL);
1608 }
1609 
1610 inline const TypeTuple *Type::is_tuple() const {
1611   assert( _base == Tuple, &quot;Not a Tuple&quot; );
1612   return (TypeTuple*)this;
1613 }
1614 
1615 inline const TypeAry *Type::is_ary() const {
1616   assert( _base == Array , &quot;Not an Array&quot; );
1617   return (TypeAry*)this;
1618 }
1619 
<a name="8" id="anc8"></a>



1620 inline const TypeVect *Type::is_vect() const {
1621   assert( _base &gt;= VectorS &amp;&amp; _base &lt;= VectorZ, &quot;Not a Vector&quot; );
1622   return (TypeVect*)this;
1623 }
1624 
1625 inline const TypeVect *Type::isa_vect() const {
1626   return (_base &gt;= VectorS &amp;&amp; _base &lt;= VectorZ) ? (TypeVect*)this : NULL;
1627 }
1628 
1629 inline const TypePtr *Type::is_ptr() const {
1630   // AnyPtr is the first Ptr and KlassPtr the last, with no non-ptrs between.
1631   assert(_base &gt;= AnyPtr &amp;&amp; _base &lt;= KlassPtr, &quot;Not a pointer&quot;);
1632   return (TypePtr*)this;
1633 }
1634 
1635 inline const TypePtr *Type::isa_ptr() const {
1636   // AnyPtr is the first Ptr and KlassPtr the last, with no non-ptrs between.
1637   return (_base &gt;= AnyPtr &amp;&amp; _base &lt;= KlassPtr) ? (TypePtr*)this : NULL;
1638 }
1639 
1640 inline const TypeOopPtr *Type::is_oopptr() const {
1641   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1642   assert(_base &gt;= OopPtr &amp;&amp; _base &lt;= AryPtr, &quot;Not a Java pointer&quot; ) ;
1643   return (TypeOopPtr*)this;
1644 }
1645 
1646 inline const TypeOopPtr *Type::isa_oopptr() const {
1647   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1648   return (_base &gt;= OopPtr &amp;&amp; _base &lt;= AryPtr) ? (TypeOopPtr*)this : NULL;
1649 }
1650 
1651 inline const TypeRawPtr *Type::isa_rawptr() const {
1652   return (_base == RawPtr) ? (TypeRawPtr*)this : NULL;
1653 }
1654 
1655 inline const TypeRawPtr *Type::is_rawptr() const {
1656   assert( _base == RawPtr, &quot;Not a raw pointer&quot; );
1657   return (TypeRawPtr*)this;
1658 }
1659 
1660 inline const TypeInstPtr *Type::isa_instptr() const {
1661   return (_base == InstPtr) ? (TypeInstPtr*)this : NULL;
1662 }
1663 
1664 inline const TypeInstPtr *Type::is_instptr() const {
1665   assert( _base == InstPtr, &quot;Not an object pointer&quot; );
1666   return (TypeInstPtr*)this;
1667 }
1668 
1669 inline const TypeAryPtr *Type::isa_aryptr() const {
1670   return (_base == AryPtr) ? (TypeAryPtr*)this : NULL;
1671 }
1672 
1673 inline const TypeAryPtr *Type::is_aryptr() const {
1674   assert( _base == AryPtr, &quot;Not an array pointer&quot; );
1675   return (TypeAryPtr*)this;
1676 }
1677 
1678 inline const TypeNarrowOop *Type::is_narrowoop() const {
1679   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1680   assert(_base == NarrowOop, &quot;Not a narrow oop&quot; ) ;
1681   return (TypeNarrowOop*)this;
1682 }
1683 
1684 inline const TypeNarrowOop *Type::isa_narrowoop() const {
1685   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1686   return (_base == NarrowOop) ? (TypeNarrowOop*)this : NULL;
1687 }
1688 
1689 inline const TypeNarrowKlass *Type::is_narrowklass() const {
1690   assert(_base == NarrowKlass, &quot;Not a narrow oop&quot; ) ;
1691   return (TypeNarrowKlass*)this;
1692 }
1693 
1694 inline const TypeNarrowKlass *Type::isa_narrowklass() const {
1695   return (_base == NarrowKlass) ? (TypeNarrowKlass*)this : NULL;
1696 }
1697 
1698 inline const TypeMetadataPtr *Type::is_metadataptr() const {
1699   // MetadataPtr is the first and CPCachePtr the last
1700   assert(_base == MetadataPtr, &quot;Not a metadata pointer&quot; ) ;
1701   return (TypeMetadataPtr*)this;
1702 }
1703 
1704 inline const TypeMetadataPtr *Type::isa_metadataptr() const {
1705   return (_base == MetadataPtr) ? (TypeMetadataPtr*)this : NULL;
1706 }
1707 
1708 inline const TypeKlassPtr *Type::isa_klassptr() const {
1709   return (_base == KlassPtr) ? (TypeKlassPtr*)this : NULL;
1710 }
1711 
1712 inline const TypeKlassPtr *Type::is_klassptr() const {
1713   assert( _base == KlassPtr, &quot;Not a klass pointer&quot; );
1714   return (TypeKlassPtr*)this;
1715 }
1716 
1717 inline const TypePtr* Type::make_ptr() const {
1718   return (_base == NarrowOop) ? is_narrowoop()-&gt;get_ptrtype() :
1719                               ((_base == NarrowKlass) ? is_narrowklass()-&gt;get_ptrtype() :
1720                                                        isa_ptr());
1721 }
1722 
1723 inline const TypeOopPtr* Type::make_oopptr() const {
1724   return (_base == NarrowOop) ? is_narrowoop()-&gt;get_ptrtype()-&gt;isa_oopptr() : isa_oopptr();
1725 }
1726 
1727 inline const TypeNarrowOop* Type::make_narrowoop() const {
1728   return (_base == NarrowOop) ? is_narrowoop() :
1729                                 (isa_ptr() ? TypeNarrowOop::make(is_ptr()) : NULL);
1730 }
1731 
1732 inline const TypeNarrowKlass* Type::make_narrowklass() const {
1733   return (_base == NarrowKlass) ? is_narrowklass() :
1734                                   (isa_ptr() ? TypeNarrowKlass::make(is_ptr()) : NULL);
1735 }
1736 
1737 inline bool Type::is_floatingpoint() const {
1738   if( (_base == FloatCon)  || (_base == FloatBot) ||
1739       (_base == DoubleCon) || (_base == DoubleBot) )
1740     return true;
1741   return false;
1742 }
1743 
1744 inline bool Type::is_ptr_to_boxing_obj() const {
1745   const TypeInstPtr* tp = isa_instptr();
1746   return (tp != NULL) &amp;&amp; (tp-&gt;offset() == 0) &amp;&amp;
1747          tp-&gt;klass()-&gt;is_instance_klass()  &amp;&amp;
1748          tp-&gt;klass()-&gt;as_instance_klass()-&gt;is_box_klass();
1749 }
1750 
1751 
1752 // ===============================================================
1753 // Things that need to be 64-bits in the 64-bit build but
1754 // 32-bits in the 32-bit build.  Done this way to get full
1755 // optimization AND strong typing.
1756 #ifdef _LP64
1757 
1758 // For type queries and asserts
1759 #define is_intptr_t  is_long
1760 #define isa_intptr_t isa_long
1761 #define find_intptr_t_type find_long_type
1762 #define find_intptr_t_con  find_long_con
1763 #define TypeX        TypeLong
1764 #define Type_X       Type::Long
1765 #define TypeX_X      TypeLong::LONG
1766 #define TypeX_ZERO   TypeLong::ZERO
1767 // For &#39;ideal_reg&#39; machine registers
1768 #define Op_RegX      Op_RegL
1769 // For phase-&gt;intcon variants
1770 #define MakeConX     longcon
1771 #define ConXNode     ConLNode
1772 // For array index arithmetic
1773 #define MulXNode     MulLNode
1774 #define AndXNode     AndLNode
1775 #define OrXNode      OrLNode
1776 #define CmpXNode     CmpLNode
1777 #define SubXNode     SubLNode
1778 #define LShiftXNode  LShiftLNode
1779 // For object size computation:
1780 #define AddXNode     AddLNode
1781 #define RShiftXNode  RShiftLNode
1782 // For card marks and hashcodes
1783 #define URShiftXNode URShiftLNode
1784 // UseOptoBiasInlining
1785 #define XorXNode     XorLNode
1786 #define StoreXConditionalNode StoreLConditionalNode
1787 #define LoadXNode    LoadLNode
1788 #define StoreXNode   StoreLNode
1789 // Opcodes
1790 #define Op_LShiftX   Op_LShiftL
1791 #define Op_AndX      Op_AndL
1792 #define Op_AddX      Op_AddL
1793 #define Op_SubX      Op_SubL
1794 #define Op_XorX      Op_XorL
1795 #define Op_URShiftX  Op_URShiftL
<a name="9" id="anc9"></a>
1796 // conversions
1797 #define ConvI2X(x)   ConvI2L(x)
1798 #define ConvL2X(x)   (x)
1799 #define ConvX2I(x)   ConvL2I(x)
1800 #define ConvX2L(x)   (x)
1801 #define ConvX2UL(x)  (x)
1802 
1803 #else
1804 
1805 // For type queries and asserts
1806 #define is_intptr_t  is_int
1807 #define isa_intptr_t isa_int
1808 #define find_intptr_t_type find_int_type
1809 #define find_intptr_t_con  find_int_con
1810 #define TypeX        TypeInt
1811 #define Type_X       Type::Int
1812 #define TypeX_X      TypeInt::INT
1813 #define TypeX_ZERO   TypeInt::ZERO
1814 // For &#39;ideal_reg&#39; machine registers
1815 #define Op_RegX      Op_RegI
1816 // For phase-&gt;intcon variants
1817 #define MakeConX     intcon
1818 #define ConXNode     ConINode
1819 // For array index arithmetic
1820 #define MulXNode     MulINode
1821 #define AndXNode     AndINode
1822 #define OrXNode      OrINode
1823 #define CmpXNode     CmpINode
1824 #define SubXNode     SubINode
1825 #define LShiftXNode  LShiftINode
1826 // For object size computation:
1827 #define AddXNode     AddINode
1828 #define RShiftXNode  RShiftINode
1829 // For card marks and hashcodes
1830 #define URShiftXNode URShiftINode
1831 // UseOptoBiasInlining
1832 #define XorXNode     XorINode
1833 #define StoreXConditionalNode StoreIConditionalNode
1834 #define LoadXNode    LoadINode
1835 #define StoreXNode   StoreINode
1836 // Opcodes
1837 #define Op_LShiftX   Op_LShiftI
1838 #define Op_AndX      Op_AndI
1839 #define Op_AddX      Op_AddI
1840 #define Op_SubX      Op_SubI
1841 #define Op_XorX      Op_XorI
1842 #define Op_URShiftX  Op_URShiftI
<a name="10" id="anc10"></a>
1843 // conversions
1844 #define ConvI2X(x)   (x)
1845 #define ConvL2X(x)   ConvL2I(x)
1846 #define ConvX2I(x)   (x)
1847 #define ConvX2L(x)   ConvI2L(x)
1848 #define ConvX2UL(x)  ConvI2UL(x)
1849 
1850 #endif
1851 
1852 #endif // SHARE_OPTO_TYPE_HPP
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
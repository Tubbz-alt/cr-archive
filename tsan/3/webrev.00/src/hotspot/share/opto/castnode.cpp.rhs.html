<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/castnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;opto/addnode.hpp&quot;
 27 #include &quot;opto/callnode.hpp&quot;
 28 #include &quot;opto/castnode.hpp&quot;
 29 #include &quot;opto/connode.hpp&quot;
 30 #include &quot;opto/matcher.hpp&quot;
 31 #include &quot;opto/phaseX.hpp&quot;
 32 #include &quot;opto/subnode.hpp&quot;
 33 #include &quot;opto/type.hpp&quot;
 34 
 35 //=============================================================================
 36 // If input is already higher or equal to cast type, then this is an identity.
 37 Node* ConstraintCastNode::Identity(PhaseGVN* phase) {
 38   Node* dom = dominating_cast(phase, phase);
 39   if (dom != NULL) {
 40     return dom;
 41   }
 42   if (_carry_dependency) {
 43     return this;
 44   }
 45   return phase-&gt;type(in(1))-&gt;higher_equal_speculative(_type) ? in(1) : this;
 46 }
 47 
 48 //------------------------------Value------------------------------------------
 49 // Take &#39;join&#39; of input and cast-up type
 50 const Type* ConstraintCastNode::Value(PhaseGVN* phase) const {
 51   if (in(0) &amp;&amp; phase-&gt;type(in(0)) == Type::TOP) return Type::TOP;
 52   const Type* ft = phase-&gt;type(in(1))-&gt;filter_speculative(_type);
 53 
 54 #ifdef ASSERT
 55   // Previous versions of this function had some special case logic,
 56   // which is no longer necessary.  Make sure of the required effects.
 57   switch (Opcode()) {
 58     case Op_CastII:
 59     {
 60       const Type* t1 = phase-&gt;type(in(1));
 61       if( t1 == Type::TOP )  assert(ft == Type::TOP, &quot;special case #1&quot;);
 62       const Type* rt = t1-&gt;join_speculative(_type);
 63       if (rt-&gt;empty())       assert(ft == Type::TOP, &quot;special case #2&quot;);
 64       break;
 65     }
<a name="1" id="anc1"></a><span class="line-added"> 66     case Op_CastLL:</span>
<span class="line-added"> 67     {</span>
<span class="line-added"> 68       const Type* t1 = phase-&gt;type(in(1));</span>
<span class="line-added"> 69       if (t1 == Type::TOP)   assert(ft == Type::TOP, &quot;special case #1&quot;);</span>
<span class="line-added"> 70       const Type* rt = t1-&gt;join_speculative(_type);</span>
<span class="line-added"> 71       if (rt-&gt;empty())       assert(ft == Type::TOP, &quot;special case #2&quot;);</span>
<span class="line-added"> 72       break;</span>
<span class="line-added"> 73     }</span>
 74     case Op_CastPP:
 75     if (phase-&gt;type(in(1)) == TypePtr::NULL_PTR &amp;&amp;
 76         _type-&gt;isa_ptr() &amp;&amp; _type-&gt;is_ptr()-&gt;_ptr == TypePtr::NotNull)
 77     assert(ft == Type::TOP, &quot;special case #3&quot;);
 78     break;
 79   }
 80 #endif //ASSERT
 81 
 82   return ft;
 83 }
 84 
 85 //------------------------------Ideal------------------------------------------
 86 // Return a node which is more &quot;ideal&quot; than the current node.  Strip out
 87 // control copies
 88 Node *ConstraintCastNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 89   return (in(0) &amp;&amp; remove_dead_region(phase, can_reshape)) ? this : NULL;
 90 }
 91 
<a name="2" id="anc2"></a><span class="line-modified"> 92 bool ConstraintCastNode::cmp(const Node &amp;n) const {</span>
 93   return TypeNode::cmp(n) &amp;&amp; ((ConstraintCastNode&amp;)n)._carry_dependency == _carry_dependency;
 94 }
 95 
 96 uint ConstraintCastNode::size_of() const {
 97   return sizeof(*this);
 98 }
 99 
100 Node* ConstraintCastNode::make_cast(int opcode, Node* c, Node *n, const Type *t, bool carry_dependency) {
101   switch(opcode) {
102   case Op_CastII: {
103     Node* cast = new CastIINode(n, t, carry_dependency);
104     cast-&gt;set_req(0, c);
105     return cast;
106   }
<a name="3" id="anc3"></a><span class="line-added">107   case Op_CastLL: {</span>
<span class="line-added">108     Node* cast = new CastLLNode(n, t, carry_dependency);</span>
<span class="line-added">109     cast-&gt;set_req(0, c);</span>
<span class="line-added">110     return cast;</span>
<span class="line-added">111   }</span>
112   case Op_CastPP: {
113     Node* cast = new CastPPNode(n, t, carry_dependency);
114     cast-&gt;set_req(0, c);
115     return cast;
116   }
117   case Op_CheckCastPP: return new CheckCastPPNode(c, n, t, carry_dependency);
118   default:
119     fatal(&quot;Bad opcode %d&quot;, opcode);
120   }
121   return NULL;
122 }
123 
124 TypeNode* ConstraintCastNode::dominating_cast(PhaseGVN* gvn, PhaseTransform* pt) const {
125   Node* val = in(1);
126   Node* ctl = in(0);
127   int opc = Opcode();
128   if (ctl == NULL) {
129     return NULL;
130   }
131   // Range check CastIIs may all end up under a single range check and
132   // in that case only the narrower CastII would be kept by the code
133   // below which would be incorrect.
134   if (is_CastII() &amp;&amp; as_CastII()-&gt;has_range_check()) {
135     return NULL;
136   }
137   if (type()-&gt;isa_rawptr() &amp;&amp; (gvn-&gt;type_or_null(val) == NULL || gvn-&gt;type(val)-&gt;isa_oopptr())) {
138     return NULL;
139   }
140   for (DUIterator_Fast imax, i = val-&gt;fast_outs(imax); i &lt; imax; i++) {
141     Node* u = val-&gt;fast_out(i);
142     if (u != this &amp;&amp;
143         u-&gt;outcnt() &gt; 0 &amp;&amp;
144         u-&gt;Opcode() == opc &amp;&amp;
145         u-&gt;in(0) != NULL &amp;&amp;
146         u-&gt;bottom_type()-&gt;higher_equal(type())) {
147       if (pt-&gt;is_dominator(u-&gt;in(0), ctl)) {
148         return u-&gt;as_Type();
149       }
150       if (is_CheckCastPP() &amp;&amp; u-&gt;in(1)-&gt;is_Proj() &amp;&amp; u-&gt;in(1)-&gt;in(0)-&gt;is_Allocate() &amp;&amp;
151           u-&gt;in(0)-&gt;is_Proj() &amp;&amp; u-&gt;in(0)-&gt;in(0)-&gt;is_Initialize() &amp;&amp;
152           u-&gt;in(1)-&gt;in(0)-&gt;as_Allocate()-&gt;initialization() == u-&gt;in(0)-&gt;in(0)) {
153         // CheckCastPP following an allocation always dominates all
154         // use of the allocation result
155         return u-&gt;as_Type();
156       }
157     }
158   }
159   return NULL;
160 }
161 
162 #ifndef PRODUCT
163 void ConstraintCastNode::dump_spec(outputStream *st) const {
164   TypeNode::dump_spec(st);
165   if (_carry_dependency) {
166     st-&gt;print(&quot; carry dependency&quot;);
167   }
168 }
169 #endif
170 
171 const Type* CastIINode::Value(PhaseGVN* phase) const {
172   const Type *res = ConstraintCastNode::Value(phase);
173 
174   // Try to improve the type of the CastII if we recognize a CmpI/If
175   // pattern.
176   if (_carry_dependency) {
177     if (in(0) != NULL &amp;&amp; in(0)-&gt;in(0) != NULL &amp;&amp; in(0)-&gt;in(0)-&gt;is_If()) {
178       assert(in(0)-&gt;is_IfFalse() || in(0)-&gt;is_IfTrue(), &quot;should be If proj&quot;);
179       Node* proj = in(0);
180       if (proj-&gt;in(0)-&gt;in(1)-&gt;is_Bool()) {
181         Node* b = proj-&gt;in(0)-&gt;in(1);
182         if (b-&gt;in(1)-&gt;Opcode() == Op_CmpI) {
183           Node* cmp = b-&gt;in(1);
184           if (cmp-&gt;in(1) == in(1) &amp;&amp; phase-&gt;type(cmp-&gt;in(2))-&gt;isa_int()) {
185             const TypeInt* in2_t = phase-&gt;type(cmp-&gt;in(2))-&gt;is_int();
186             const Type* t = TypeInt::INT;
187             BoolTest test = b-&gt;as_Bool()-&gt;_test;
188             if (proj-&gt;is_IfFalse()) {
189               test = test.negate();
190             }
191             BoolTest::mask m = test._test;
192             jlong lo_long = min_jint;
193             jlong hi_long = max_jint;
194             if (m == BoolTest::le || m == BoolTest::lt) {
195               hi_long = in2_t-&gt;_hi;
196               if (m == BoolTest::lt) {
197                 hi_long -= 1;
198               }
199             } else if (m == BoolTest::ge || m == BoolTest::gt) {
200               lo_long = in2_t-&gt;_lo;
201               if (m == BoolTest::gt) {
202                 lo_long += 1;
203               }
204             } else if (m == BoolTest::eq) {
205               lo_long = in2_t-&gt;_lo;
206               hi_long = in2_t-&gt;_hi;
207             } else if (m == BoolTest::ne) {
208               // can&#39;t do any better
209             } else {
210               stringStream ss;
211               test.dump_on(&amp;ss);
212               fatal(&quot;unexpected comparison %s&quot;, ss.as_string());
213             }
214             int lo_int = (int)lo_long;
215             int hi_int = (int)hi_long;
216 
217             if (lo_long != (jlong)lo_int) {
218               lo_int = min_jint;
219             }
220             if (hi_long != (jlong)hi_int) {
221               hi_int = max_jint;
222             }
223 
224             t = TypeInt::make(lo_int, hi_int, Type::WidenMax);
225 
226             res = res-&gt;filter_speculative(t);
227 
228             return res;
229           }
230         }
231       }
232     }
233   }
234   return res;
235 }
236 
237 Node *CastIINode::Ideal(PhaseGVN *phase, bool can_reshape) {
238   Node* progress = ConstraintCastNode::Ideal(phase, can_reshape);
239   if (progress != NULL) {
240     return progress;
241   }
242 
243   // Similar to ConvI2LNode::Ideal() for the same reasons
244   // Do not narrow the type of range check dependent CastIINodes to
245   // avoid corruption of the graph if a CastII is replaced by TOP but
246   // the corresponding range check is not removed.
247   if (can_reshape &amp;&amp; !_range_check_dependency &amp;&amp; !phase-&gt;C-&gt;major_progress()) {
248     const TypeInt* this_type = this-&gt;type()-&gt;is_int();
249     const TypeInt* in_type = phase-&gt;type(in(1))-&gt;isa_int();
250     if (in_type != NULL &amp;&amp; this_type != NULL &amp;&amp;
251         (in_type-&gt;_lo != this_type-&gt;_lo ||
252          in_type-&gt;_hi != this_type-&gt;_hi)) {
253       jint lo1 = this_type-&gt;_lo;
254       jint hi1 = this_type-&gt;_hi;
255       int w1  = this_type-&gt;_widen;
256 
257       if (lo1 &gt;= 0) {
258         // Keep a range assertion of &gt;=0.
259         lo1 = 0;        hi1 = max_jint;
260       } else if (hi1 &lt; 0) {
261         // Keep a range assertion of &lt;0.
262         lo1 = min_jint; hi1 = -1;
263       } else {
264         lo1 = min_jint; hi1 = max_jint;
265       }
266       const TypeInt* wtype = TypeInt::make(MAX2(in_type-&gt;_lo, lo1),
267                                            MIN2(in_type-&gt;_hi, hi1),
268                                            MAX2((int)in_type-&gt;_widen, w1));
269       if (wtype != type()) {
270         set_type(wtype);
271         return this;
272       }
273     }
274   }
275   return NULL;
276 }
277 
<a name="4" id="anc4"></a><span class="line-modified">278 bool CastIINode::cmp(const Node &amp;n) const {</span>
279   return ConstraintCastNode::cmp(n) &amp;&amp; ((CastIINode&amp;)n)._range_check_dependency == _range_check_dependency;
280 }
281 
282 uint CastIINode::size_of() const {
283   return sizeof(*this);
284 }
285 
286 #ifndef PRODUCT
287 void CastIINode::dump_spec(outputStream* st) const {
288   ConstraintCastNode::dump_spec(st);
289   if (_range_check_dependency) {
290     st-&gt;print(&quot; range check dependency&quot;);
291   }
292 }
293 #endif
294 
<a name="5" id="anc5"></a><span class="line-added">295 Node* CastLLNode::Ideal(PhaseGVN* phase, bool can_reshape) {</span>
<span class="line-added">296   Node* progress = ConstraintCastNode::Ideal(phase, can_reshape);</span>
<span class="line-added">297   if (progress != NULL) {</span>
<span class="line-added">298     return progress;</span>
<span class="line-added">299   }</span>
<span class="line-added">300 </span>
<span class="line-added">301   // Same as in CastIINode::Ideal but for TypeLong instead of TypeInt</span>
<span class="line-added">302   if (can_reshape &amp;&amp; !phase-&gt;C-&gt;major_progress()) {</span>
<span class="line-added">303     const TypeLong* this_type = this-&gt;type()-&gt;is_long();</span>
<span class="line-added">304     const TypeLong* in_type = phase-&gt;type(in(1))-&gt;isa_long();</span>
<span class="line-added">305     if (in_type != NULL &amp;&amp; this_type != NULL &amp;&amp;</span>
<span class="line-added">306         (in_type-&gt;_lo != this_type-&gt;_lo ||</span>
<span class="line-added">307          in_type-&gt;_hi != this_type-&gt;_hi)) {</span>
<span class="line-added">308       jlong lo1 = this_type-&gt;_lo;</span>
<span class="line-added">309       jlong hi1 = this_type-&gt;_hi;</span>
<span class="line-added">310       int w1  = this_type-&gt;_widen;</span>
<span class="line-added">311 </span>
<span class="line-added">312       if (lo1 &gt;= 0) {</span>
<span class="line-added">313         // Keep a range assertion of &gt;=0.</span>
<span class="line-added">314         lo1 = 0;         hi1 = max_jlong;</span>
<span class="line-added">315       } else if (hi1 &lt; 0) {</span>
<span class="line-added">316         // Keep a range assertion of &lt;0.</span>
<span class="line-added">317         lo1 = min_jlong; hi1 = -1;</span>
<span class="line-added">318       } else {</span>
<span class="line-added">319         lo1 = min_jlong; hi1 = max_jlong;</span>
<span class="line-added">320       }</span>
<span class="line-added">321       const TypeLong* wtype = TypeLong::make(MAX2(in_type-&gt;_lo, lo1),</span>
<span class="line-added">322                                              MIN2(in_type-&gt;_hi, hi1),</span>
<span class="line-added">323                                              MAX2((int)in_type-&gt;_widen, w1));</span>
<span class="line-added">324       if (wtype != type()) {</span>
<span class="line-added">325         set_type(wtype);</span>
<span class="line-added">326         return this;</span>
<span class="line-added">327       }</span>
<span class="line-added">328     }</span>
<span class="line-added">329   }</span>
<span class="line-added">330   return NULL;</span>
<span class="line-added">331 }</span>
<span class="line-added">332 </span>
<span class="line-added">333 </span>
334 //=============================================================================
335 //------------------------------Identity---------------------------------------
336 // If input is already higher or equal to cast type, then this is an identity.
337 Node* CheckCastPPNode::Identity(PhaseGVN* phase) {
338   Node* dom = dominating_cast(phase, phase);
339   if (dom != NULL) {
340     return dom;
341   }
342   if (_carry_dependency) {
343     return this;
344   }
345   // Toned down to rescue meeting at a Phi 3 different oops all implementing
346   // the same interface.
347   return (phase-&gt;type(in(1)) == phase-&gt;type(this)) ? in(1) : this;
348 }
349 
350 //------------------------------Value------------------------------------------
351 // Take &#39;join&#39; of input and cast-up type, unless working with an Interface
352 const Type* CheckCastPPNode::Value(PhaseGVN* phase) const {
353   if( in(0) &amp;&amp; phase-&gt;type(in(0)) == Type::TOP ) return Type::TOP;
354 
355   const Type *inn = phase-&gt;type(in(1));
356   if( inn == Type::TOP ) return Type::TOP;  // No information yet
357 
358   const TypePtr *in_type   = inn-&gt;isa_ptr();
359   const TypePtr *my_type   = _type-&gt;isa_ptr();
360   const Type *result = _type;
361   if( in_type != NULL &amp;&amp; my_type != NULL ) {
362     TypePtr::PTR   in_ptr    = in_type-&gt;ptr();
363     if (in_ptr == TypePtr::Null) {
364       result = in_type;
365     } else if (in_ptr == TypePtr::Constant) {
366       if (my_type-&gt;isa_rawptr()) {
367         result = my_type;
368       } else {
369         const TypeOopPtr *jptr = my_type-&gt;isa_oopptr();
370         assert(jptr, &quot;&quot;);
371         result = !in_type-&gt;higher_equal(_type)
372           ? my_type-&gt;cast_to_ptr_type(TypePtr::NotNull)
373           : in_type;
374       }
375     } else {
376       result =  my_type-&gt;cast_to_ptr_type( my_type-&gt;join_ptr(in_ptr) );
377     }
378   }
379 
380   // This is the code from TypePtr::xmeet() that prevents us from
381   // having 2 ways to represent the same type. We have to replicate it
382   // here because we don&#39;t go through meet/join.
383   if (result-&gt;remove_speculative() == result-&gt;speculative()) {
384     result = result-&gt;remove_speculative();
385   }
386 
387   // Same as above: because we don&#39;t go through meet/join, remove the
388   // speculative type if we know we won&#39;t use it.
389   return result-&gt;cleanup_speculative();
390 
391   // JOIN NOT DONE HERE BECAUSE OF INTERFACE ISSUES.
392   // FIX THIS (DO THE JOIN) WHEN UNION TYPES APPEAR!
393 
394   //
395   // Remove this code after overnight run indicates no performance
396   // loss from not performing JOIN at CheckCastPPNode
397   //
398   // const TypeInstPtr *in_oop = in-&gt;isa_instptr();
399   // const TypeInstPtr *my_oop = _type-&gt;isa_instptr();
400   // // If either input is an &#39;interface&#39;, return destination type
401   // assert (in_oop == NULL || in_oop-&gt;klass() != NULL, &quot;&quot;);
402   // assert (my_oop == NULL || my_oop-&gt;klass() != NULL, &quot;&quot;);
403   // if( (in_oop &amp;&amp; in_oop-&gt;klass()-&gt;is_interface())
404   //   ||(my_oop &amp;&amp; my_oop-&gt;klass()-&gt;is_interface()) ) {
405   //   TypePtr::PTR  in_ptr = in-&gt;isa_ptr() ? in-&gt;is_ptr()-&gt;_ptr : TypePtr::BotPTR;
406   //   // Preserve cast away nullness for interfaces
407   //   if( in_ptr == TypePtr::NotNull &amp;&amp; my_oop &amp;&amp; my_oop-&gt;_ptr == TypePtr::BotPTR ) {
408   //     return my_oop-&gt;cast_to_ptr_type(TypePtr::NotNull);
409   //   }
410   //   return _type;
411   // }
412   //
413   // // Neither the input nor the destination type is an interface,
414   //
415   // // history: JOIN used to cause weird corner case bugs
416   // //          return (in == TypeOopPtr::NULL_PTR) ? in : _type;
417   // // JOIN picks up NotNull in common instance-of/check-cast idioms, both oops.
418   // // JOIN does not preserve NotNull in other cases, e.g. RawPtr vs InstPtr
419   // const Type *join = in-&gt;join(_type);
420   // // Check if join preserved NotNull&#39;ness for pointers
421   // if( join-&gt;isa_ptr() &amp;&amp; _type-&gt;isa_ptr() ) {
422   //   TypePtr::PTR join_ptr = join-&gt;is_ptr()-&gt;_ptr;
423   //   TypePtr::PTR type_ptr = _type-&gt;is_ptr()-&gt;_ptr;
424   //   // If there isn&#39;t any NotNull&#39;ness to preserve
425   //   // OR if join preserved NotNull&#39;ness then return it
426   //   if( type_ptr == TypePtr::BotPTR  || type_ptr == TypePtr::Null ||
427   //       join_ptr == TypePtr::NotNull || join_ptr == TypePtr::Constant ) {
428   //     return join;
429   //   }
430   //   // ELSE return same old type as before
431   //   return _type;
432   // }
433   // // Not joining two pointers
434   // return join;
435 }
436 
437 //=============================================================================
438 //------------------------------Value------------------------------------------
439 const Type* CastX2PNode::Value(PhaseGVN* phase) const {
440   const Type* t = phase-&gt;type(in(1));
441   if (t == Type::TOP) return Type::TOP;
442   if (t-&gt;base() == Type_X &amp;&amp; t-&gt;singleton()) {
443     uintptr_t bits = (uintptr_t) t-&gt;is_intptr_t()-&gt;get_con();
444     if (bits == 0)   return TypePtr::NULL_PTR;
445     return TypeRawPtr::make((address) bits);
446   }
447   return CastX2PNode::bottom_type();
448 }
449 
450 //------------------------------Idealize---------------------------------------
451 static inline bool fits_in_int(const Type* t, bool but_not_min_int = false) {
452   if (t == Type::TOP)  return false;
453   const TypeX* tl = t-&gt;is_intptr_t();
454   jint lo = min_jint;
455   jint hi = max_jint;
456   if (but_not_min_int)  ++lo;  // caller wants to negate the value w/o overflow
457   return (tl-&gt;_lo &gt;= lo) &amp;&amp; (tl-&gt;_hi &lt;= hi);
458 }
459 
460 static inline Node* addP_of_X2P(PhaseGVN *phase,
461                                 Node* base,
462                                 Node* dispX,
463                                 bool negate = false) {
464   if (negate) {
465     dispX = phase-&gt;transform(new SubXNode(phase-&gt;MakeConX(0), dispX));
466   }
467   return new AddPNode(phase-&gt;C-&gt;top(),
468                       phase-&gt;transform(new CastX2PNode(base)),
469                       dispX);
470 }
471 
472 Node *CastX2PNode::Ideal(PhaseGVN *phase, bool can_reshape) {
473   // convert CastX2P(AddX(x, y)) to AddP(CastX2P(x), y) if y fits in an int
474   int op = in(1)-&gt;Opcode();
475   Node* x;
476   Node* y;
477   switch (op) {
478     case Op_SubX:
479     x = in(1)-&gt;in(1);
480     // Avoid ideal transformations ping-pong between this and AddP for raw pointers.
481     if (phase-&gt;find_intptr_t_con(x, -1) == 0)
482     break;
483     y = in(1)-&gt;in(2);
484     if (fits_in_int(phase-&gt;type(y), true)) {
485       return addP_of_X2P(phase, x, y, true);
486     }
487     break;
488     case Op_AddX:
489     x = in(1)-&gt;in(1);
490     y = in(1)-&gt;in(2);
491     if (fits_in_int(phase-&gt;type(y))) {
492       return addP_of_X2P(phase, x, y);
493     }
494     if (fits_in_int(phase-&gt;type(x))) {
495       return addP_of_X2P(phase, y, x);
496     }
497     break;
498   }
499   return NULL;
500 }
501 
502 //------------------------------Identity---------------------------------------
503 Node* CastX2PNode::Identity(PhaseGVN* phase) {
504   if (in(1)-&gt;Opcode() == Op_CastP2X)  return in(1)-&gt;in(1);
505   return this;
506 }
507 
508 //=============================================================================
509 //------------------------------Value------------------------------------------
510 const Type* CastP2XNode::Value(PhaseGVN* phase) const {
511   const Type* t = phase-&gt;type(in(1));
512   if (t == Type::TOP) return Type::TOP;
513   if (t-&gt;base() == Type::RawPtr &amp;&amp; t-&gt;singleton()) {
514     uintptr_t bits = (uintptr_t) t-&gt;is_rawptr()-&gt;get_con();
515     return TypeX::make(bits);
516   }
517   return CastP2XNode::bottom_type();
518 }
519 
520 Node *CastP2XNode::Ideal(PhaseGVN *phase, bool can_reshape) {
521   return (in(0) &amp;&amp; remove_dead_region(phase, can_reshape)) ? this : NULL;
522 }
523 
524 //------------------------------Identity---------------------------------------
525 Node* CastP2XNode::Identity(PhaseGVN* phase) {
526   if (in(1)-&gt;Opcode() == Op_CastX2P)  return in(1)-&gt;in(1);
527   return this;
528 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
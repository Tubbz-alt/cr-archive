<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/arraycopynode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="addnode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="arraycopynode.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/arraycopynode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/barrierSet.hpp&quot;
 27 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
 28 #include &quot;gc/shared/c2/cardTableBarrierSetC2.hpp&quot;
 29 #include &quot;opto/arraycopynode.hpp&quot;
 30 #include &quot;opto/graphKit.hpp&quot;
 31 #include &quot;runtime/sharedRuntime.hpp&quot;
 32 #include &quot;utilities/macros.hpp&quot;

 33 
 34 ArrayCopyNode::ArrayCopyNode(Compile* C, bool alloc_tightly_coupled, bool has_negative_length_guard)
 35   : CallNode(arraycopy_type(), NULL, TypePtr::BOTTOM),
 36     _kind(None),
 37     _alloc_tightly_coupled(alloc_tightly_coupled),
 38     _has_negative_length_guard(has_negative_length_guard),
 39     _arguments_validated(false),
 40     _src_type(TypeOopPtr::BOTTOM),
 41     _dest_type(TypeOopPtr::BOTTOM) {
 42   init_class_id(Class_ArrayCopy);
 43   init_flags(Flag_is_macro);
 44   C-&gt;add_macro_node(this);
 45 }
 46 
 47 uint ArrayCopyNode::size_of() const { return sizeof(*this); }
 48 
 49 ArrayCopyNode* ArrayCopyNode::make(GraphKit* kit, bool may_throw,
 50                                    Node* src, Node* src_offset,
 51                                    Node* dest, Node* dest_offset,
 52                                    Node* length,
</pre>
<hr />
<pre>
119     if (src_type-&gt;isa_instptr()) {
120       const TypeInstPtr* inst_src = src_type-&gt;is_instptr();
121       ciInstanceKlass* ik = inst_src-&gt;klass()-&gt;as_instance_klass();
122       // ciInstanceKlass::nof_nonstatic_fields() doesn&#39;t take injected
123       // fields into account. They are rare anyway so easier to simply
124       // skip instances with injected fields.
125       if ((!inst_src-&gt;klass_is_exact() &amp;&amp; (ik-&gt;is_interface() || ik-&gt;has_subklass())) || ik-&gt;has_injected_fields()) {
126         return -1;
127       }
128       int nb_fields = ik-&gt;nof_nonstatic_fields();
129       return nb_fields;
130     } else {
131       const TypeAryPtr* ary_src = src_type-&gt;isa_aryptr();
132       assert (ary_src != NULL, &quot;not an array or instance?&quot;);
133       // clone passes a length as a rounded number of longs. If we&#39;re
134       // cloning an array we&#39;ll do it element by element. If the
135       // length input to ArrayCopyNode is constant, length of input
136       // array must be too.
137 
138       assert((get_length_if_constant(phase) == -1) == !ary_src-&gt;size()-&gt;is_con() ||
<span class="line-modified">139              phase-&gt;is_IterGVN(), &quot;inconsistent&quot;);</span>
140 
141       if (ary_src-&gt;size()-&gt;is_con()) {
142         return ary_src-&gt;size()-&gt;get_con();
143       }
144       return -1;
145     }
146   }
147 
148   return get_length_if_constant(phase);
149 }
150 
151 Node* ArrayCopyNode::load(BarrierSetC2* bs, PhaseGVN *phase, Node*&amp; ctl, MergeMemNode* mem, Node* adr, const TypePtr* adr_type, const Type *type, BasicType bt) {
152   DecoratorSet decorators = C2_READ_ACCESS | C2_CONTROL_DEPENDENT_LOAD | IN_HEAP | C2_ARRAY_COPY;
153   C2AccessValuePtr addr(adr, adr_type);
154   C2OptAccess access(*phase, ctl, mem, decorators, bt, adr-&gt;in(AddPNode::Base), addr);
155   Node* res = bs-&gt;load_at(access, type);
156   ctl = access.ctl();
157   return res;
158 }
159 
</pre>
<hr />
<pre>
251   const Type* src_type = phase-&gt;type(src);
252   const TypeAryPtr* ary_src = src_type-&gt;isa_aryptr();
253 
254   if (is_arraycopy() || is_copyofrange() || is_copyof()) {
255     const Type* dest_type = phase-&gt;type(dest);
256     const TypeAryPtr* ary_dest = dest_type-&gt;isa_aryptr();
257     Node* src_offset = in(ArrayCopyNode::SrcPos);
258     Node* dest_offset = in(ArrayCopyNode::DestPos);
259 
260     // newly allocated object is guaranteed to not overlap with source object
261     disjoint_bases = is_alloc_tightly_coupled();
262 
263     if (ary_src  == NULL || ary_src-&gt;klass()  == NULL ||
264         ary_dest == NULL || ary_dest-&gt;klass() == NULL) {
265       // We don&#39;t know if arguments are arrays
266       return false;
267     }
268 
269     BasicType src_elem  = ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
270     BasicType dest_elem = ary_dest-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
<span class="line-modified">271     if (src_elem  == T_ARRAY)  src_elem  = T_OBJECT;</span>
<span class="line-modified">272     if (dest_elem == T_ARRAY)  dest_elem = T_OBJECT;</span>
273 
274     if (src_elem != dest_elem || dest_elem == T_VOID) {
275       // We don&#39;t know if arguments are arrays of the same type
276       return false;
277     }
278 
279     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
280     if (bs-&gt;array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), dest_elem, false, BarrierSetC2::Optimization)) {
281       // It&#39;s an object array copy but we can&#39;t emit the card marking
282       // that is needed
283       return false;
284     }
285 
286     value_type = ary_src-&gt;elem();
287 
288     base_src = src;
289     base_dest = dest;
290 
291     uint shift  = exact_log2(type2aelembytes(dest_elem));
292     uint header = arrayOopDesc::base_offset_in_bytes(dest_elem);
293 
294     adr_src = src;
295     adr_dest = dest;
296 
297     src_offset = Compile::conv_I2X_index(phase, src_offset, ary_src-&gt;size());
298     dest_offset = Compile::conv_I2X_index(phase, dest_offset, ary_dest-&gt;size());




299 
300     Node* src_scale = phase-&gt;transform(new LShiftXNode(src_offset, phase-&gt;intcon(shift)));
301     Node* dest_scale = phase-&gt;transform(new LShiftXNode(dest_offset, phase-&gt;intcon(shift)));
302 
303     adr_src = phase-&gt;transform(new AddPNode(base_src, adr_src, src_scale));
304     adr_dest = phase-&gt;transform(new AddPNode(base_dest, adr_dest, dest_scale));
305 
306     adr_src = new AddPNode(base_src, adr_src, phase-&gt;MakeConX(header));
307     adr_dest = new AddPNode(base_dest, adr_dest, phase-&gt;MakeConX(header));
308 
309     adr_src = phase-&gt;transform(adr_src);
310     adr_dest = phase-&gt;transform(adr_dest);
311 
312     copy_type = dest_elem;
313   } else {
314     assert(ary_src != NULL, &quot;should be a clone&quot;);
315     assert(is_clonebasic(), &quot;should be&quot;);
316 
317     disjoint_bases = true;
318     assert(src-&gt;is_AddP(), &quot;should be base + off&quot;);
319     assert(dest-&gt;is_AddP(), &quot;should be base + off&quot;);
320     adr_src = src;
321     base_src = src-&gt;in(AddPNode::Base);
322     adr_dest = dest;
323     base_dest = dest-&gt;in(AddPNode::Base);
324 
325     assert(phase-&gt;type(src-&gt;in(AddPNode::Offset))-&gt;is_intptr_t()-&gt;get_con() == phase-&gt;type(dest-&gt;in(AddPNode::Offset))-&gt;is_intptr_t()-&gt;get_con(), &quot;same start offset?&quot;);
326     BasicType elem = ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
<span class="line-modified">327     if (elem == T_ARRAY)  elem = T_OBJECT;</span>
328 
329     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
330     if (bs-&gt;array_copy_requires_gc_barriers(true, elem, true, BarrierSetC2::Optimization)) {
331       return false;
332     }
333 
334     int diff = arrayOopDesc::base_offset_in_bytes(elem) - phase-&gt;type(src-&gt;in(AddPNode::Offset))-&gt;is_intptr_t()-&gt;get_con();
335     assert(diff &gt;= 0, &quot;clone should not start after 1st array element&quot;);
336     if (diff &gt; 0) {
337       adr_src = phase-&gt;transform(new AddPNode(base_src, adr_src, phase-&gt;MakeConX(diff)));
338       adr_dest = phase-&gt;transform(new AddPNode(base_dest, adr_dest, phase-&gt;MakeConX(diff)));
339     }
340 
341     copy_type = elem;
342     value_type = ary_src-&gt;elem();
343   }
344   return true;
345 }
346 
<span class="line-modified">347 const TypePtr* ArrayCopyNode::get_address_type(PhaseGVN *phase, Node* n) {</span>
<span class="line-modified">348   const Type* at = phase-&gt;type(n);</span>
<span class="line-modified">349   assert(at != Type::TOP, &quot;unexpected type&quot;);</span>
<span class="line-modified">350   const TypePtr* atp = at-&gt;isa_ptr();</span>
351   // adjust atp to be the correct array element address type
<span class="line-modified">352   atp = atp-&gt;add_offset(Type::OffsetBot);</span>
<span class="line-removed">353   return atp;</span>
354 }
355 
356 void ArrayCopyNode::array_copy_test_overlap(PhaseGVN *phase, bool can_reshape, bool disjoint_bases, int count, Node*&amp; forward_ctl, Node*&amp; backward_ctl) {
357   Node* ctl = in(TypeFunc::Control);
358   if (!disjoint_bases &amp;&amp; count &gt; 1) {
359     Node* src_offset = in(ArrayCopyNode::SrcPos);
360     Node* dest_offset = in(ArrayCopyNode::DestPos);
361     assert(src_offset != NULL &amp;&amp; dest_offset != NULL, &quot;should be&quot;);
362     Node* cmp = phase-&gt;transform(new CmpINode(src_offset, dest_offset));
363     Node *bol = phase-&gt;transform(new BoolNode(cmp, BoolTest::lt));
364     IfNode *iff = new IfNode(ctl, bol, PROB_FAIR, COUNT_UNKNOWN);
365 
366     phase-&gt;transform(iff);
367 
368     forward_ctl = phase-&gt;transform(new IfFalseNode(iff));
369     backward_ctl = phase-&gt;transform(new IfTrueNode(iff));
370   } else {
371     forward_ctl = ctl;
372   }
373 }
</pre>
<hr />
<pre>
553   if (mem != NULL) {
554     return (mem == NodeSentinel) ? NULL : mem;
555   }
556 
557   Node* adr_src = NULL;
558   Node* base_src = NULL;
559   Node* adr_dest = NULL;
560   Node* base_dest = NULL;
561   BasicType copy_type = T_ILLEGAL;
562   const Type* value_type = NULL;
563   bool disjoint_bases = false;
564 
565   if (!prepare_array_copy(phase, can_reshape,
566                           adr_src, base_src, adr_dest, base_dest,
567                           copy_type, value_type, disjoint_bases)) {
568     return NULL;
569   }
570 
571   Node* src = in(ArrayCopyNode::Src);
572   Node* dest = in(ArrayCopyNode::Dest);
<span class="line-modified">573   const TypePtr* atp_src = get_address_type(phase, src);</span>
<span class="line-modified">574   const TypePtr* atp_dest = get_address_type(phase, dest);</span>
575 
576   Node *in_mem = in(TypeFunc::Memory);
577   if (!in_mem-&gt;is_MergeMem()) {
578     in_mem = MergeMemNode::make(in_mem);
579   }
580 
581 
582   if (can_reshape) {
583     assert(!phase-&gt;is_IterGVN()-&gt;delay_transform(), &quot;cannot delay transforms&quot;);
584     phase-&gt;is_IterGVN()-&gt;set_delay_transform(true);
585   }
586 
587   Node* backward_ctl = phase-&gt;C-&gt;top();
588   Node* forward_ctl = phase-&gt;C-&gt;top();
589   array_copy_test_overlap(phase, can_reshape, disjoint_bases, count, forward_ctl, backward_ctl);
590 
591   Node* forward_mem = array_copy_forward(phase, can_reshape, forward_ctl,
592                                          in_mem-&gt;as_MergeMem(),
593                                          atp_src, atp_dest,
594                                          adr_src, base_src, adr_dest, base_dest,
</pre>
</td>
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/barrierSet.hpp&quot;
 27 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
 28 #include &quot;gc/shared/c2/cardTableBarrierSetC2.hpp&quot;
 29 #include &quot;opto/arraycopynode.hpp&quot;
 30 #include &quot;opto/graphKit.hpp&quot;
 31 #include &quot;runtime/sharedRuntime.hpp&quot;
 32 #include &quot;utilities/macros.hpp&quot;
<span class="line-added"> 33 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
 34 
 35 ArrayCopyNode::ArrayCopyNode(Compile* C, bool alloc_tightly_coupled, bool has_negative_length_guard)
 36   : CallNode(arraycopy_type(), NULL, TypePtr::BOTTOM),
 37     _kind(None),
 38     _alloc_tightly_coupled(alloc_tightly_coupled),
 39     _has_negative_length_guard(has_negative_length_guard),
 40     _arguments_validated(false),
 41     _src_type(TypeOopPtr::BOTTOM),
 42     _dest_type(TypeOopPtr::BOTTOM) {
 43   init_class_id(Class_ArrayCopy);
 44   init_flags(Flag_is_macro);
 45   C-&gt;add_macro_node(this);
 46 }
 47 
 48 uint ArrayCopyNode::size_of() const { return sizeof(*this); }
 49 
 50 ArrayCopyNode* ArrayCopyNode::make(GraphKit* kit, bool may_throw,
 51                                    Node* src, Node* src_offset,
 52                                    Node* dest, Node* dest_offset,
 53                                    Node* length,
</pre>
<hr />
<pre>
120     if (src_type-&gt;isa_instptr()) {
121       const TypeInstPtr* inst_src = src_type-&gt;is_instptr();
122       ciInstanceKlass* ik = inst_src-&gt;klass()-&gt;as_instance_klass();
123       // ciInstanceKlass::nof_nonstatic_fields() doesn&#39;t take injected
124       // fields into account. They are rare anyway so easier to simply
125       // skip instances with injected fields.
126       if ((!inst_src-&gt;klass_is_exact() &amp;&amp; (ik-&gt;is_interface() || ik-&gt;has_subklass())) || ik-&gt;has_injected_fields()) {
127         return -1;
128       }
129       int nb_fields = ik-&gt;nof_nonstatic_fields();
130       return nb_fields;
131     } else {
132       const TypeAryPtr* ary_src = src_type-&gt;isa_aryptr();
133       assert (ary_src != NULL, &quot;not an array or instance?&quot;);
134       // clone passes a length as a rounded number of longs. If we&#39;re
135       // cloning an array we&#39;ll do it element by element. If the
136       // length input to ArrayCopyNode is constant, length of input
137       // array must be too.
138 
139       assert((get_length_if_constant(phase) == -1) == !ary_src-&gt;size()-&gt;is_con() ||
<span class="line-modified">140              phase-&gt;is_IterGVN() || StressReflectiveCode, &quot;inconsistent&quot;);</span>
141 
142       if (ary_src-&gt;size()-&gt;is_con()) {
143         return ary_src-&gt;size()-&gt;get_con();
144       }
145       return -1;
146     }
147   }
148 
149   return get_length_if_constant(phase);
150 }
151 
152 Node* ArrayCopyNode::load(BarrierSetC2* bs, PhaseGVN *phase, Node*&amp; ctl, MergeMemNode* mem, Node* adr, const TypePtr* adr_type, const Type *type, BasicType bt) {
153   DecoratorSet decorators = C2_READ_ACCESS | C2_CONTROL_DEPENDENT_LOAD | IN_HEAP | C2_ARRAY_COPY;
154   C2AccessValuePtr addr(adr, adr_type);
155   C2OptAccess access(*phase, ctl, mem, decorators, bt, adr-&gt;in(AddPNode::Base), addr);
156   Node* res = bs-&gt;load_at(access, type);
157   ctl = access.ctl();
158   return res;
159 }
160 
</pre>
<hr />
<pre>
252   const Type* src_type = phase-&gt;type(src);
253   const TypeAryPtr* ary_src = src_type-&gt;isa_aryptr();
254 
255   if (is_arraycopy() || is_copyofrange() || is_copyof()) {
256     const Type* dest_type = phase-&gt;type(dest);
257     const TypeAryPtr* ary_dest = dest_type-&gt;isa_aryptr();
258     Node* src_offset = in(ArrayCopyNode::SrcPos);
259     Node* dest_offset = in(ArrayCopyNode::DestPos);
260 
261     // newly allocated object is guaranteed to not overlap with source object
262     disjoint_bases = is_alloc_tightly_coupled();
263 
264     if (ary_src  == NULL || ary_src-&gt;klass()  == NULL ||
265         ary_dest == NULL || ary_dest-&gt;klass() == NULL) {
266       // We don&#39;t know if arguments are arrays
267       return false;
268     }
269 
270     BasicType src_elem  = ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
271     BasicType dest_elem = ary_dest-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
<span class="line-modified">272     if (is_reference_type(src_elem))   src_elem  = T_OBJECT;</span>
<span class="line-modified">273     if (is_reference_type(dest_elem))  dest_elem = T_OBJECT;</span>
274 
275     if (src_elem != dest_elem || dest_elem == T_VOID) {
276       // We don&#39;t know if arguments are arrays of the same type
277       return false;
278     }
279 
280     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
281     if (bs-&gt;array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), dest_elem, false, BarrierSetC2::Optimization)) {
282       // It&#39;s an object array copy but we can&#39;t emit the card marking
283       // that is needed
284       return false;
285     }
286 
287     value_type = ary_src-&gt;elem();
288 
289     base_src = src;
290     base_dest = dest;
291 
292     uint shift  = exact_log2(type2aelembytes(dest_elem));
293     uint header = arrayOopDesc::base_offset_in_bytes(dest_elem);
294 
295     adr_src = src;
296     adr_dest = dest;
297 
298     src_offset = Compile::conv_I2X_index(phase, src_offset, ary_src-&gt;size());
299     dest_offset = Compile::conv_I2X_index(phase, dest_offset, ary_dest-&gt;size());
<span class="line-added">300     if (src_offset-&gt;is_top() || dest_offset-&gt;is_top()) {</span>
<span class="line-added">301       // Offset is out of bounds (the ArrayCopyNode will be removed)</span>
<span class="line-added">302       return false;</span>
<span class="line-added">303     }</span>
304 
305     Node* src_scale = phase-&gt;transform(new LShiftXNode(src_offset, phase-&gt;intcon(shift)));
306     Node* dest_scale = phase-&gt;transform(new LShiftXNode(dest_offset, phase-&gt;intcon(shift)));
307 
308     adr_src = phase-&gt;transform(new AddPNode(base_src, adr_src, src_scale));
309     adr_dest = phase-&gt;transform(new AddPNode(base_dest, adr_dest, dest_scale));
310 
311     adr_src = new AddPNode(base_src, adr_src, phase-&gt;MakeConX(header));
312     adr_dest = new AddPNode(base_dest, adr_dest, phase-&gt;MakeConX(header));
313 
314     adr_src = phase-&gt;transform(adr_src);
315     adr_dest = phase-&gt;transform(adr_dest);
316 
317     copy_type = dest_elem;
318   } else {
319     assert(ary_src != NULL, &quot;should be a clone&quot;);
320     assert(is_clonebasic(), &quot;should be&quot;);
321 
322     disjoint_bases = true;
323     assert(src-&gt;is_AddP(), &quot;should be base + off&quot;);
324     assert(dest-&gt;is_AddP(), &quot;should be base + off&quot;);
325     adr_src = src;
326     base_src = src-&gt;in(AddPNode::Base);
327     adr_dest = dest;
328     base_dest = dest-&gt;in(AddPNode::Base);
329 
330     assert(phase-&gt;type(src-&gt;in(AddPNode::Offset))-&gt;is_intptr_t()-&gt;get_con() == phase-&gt;type(dest-&gt;in(AddPNode::Offset))-&gt;is_intptr_t()-&gt;get_con(), &quot;same start offset?&quot;);
331     BasicType elem = ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
<span class="line-modified">332     if (is_reference_type(elem))  elem = T_OBJECT;</span>
333 
334     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
335     if (bs-&gt;array_copy_requires_gc_barriers(true, elem, true, BarrierSetC2::Optimization)) {
336       return false;
337     }
338 
339     int diff = arrayOopDesc::base_offset_in_bytes(elem) - phase-&gt;type(src-&gt;in(AddPNode::Offset))-&gt;is_intptr_t()-&gt;get_con();
340     assert(diff &gt;= 0, &quot;clone should not start after 1st array element&quot;);
341     if (diff &gt; 0) {
342       adr_src = phase-&gt;transform(new AddPNode(base_src, adr_src, phase-&gt;MakeConX(diff)));
343       adr_dest = phase-&gt;transform(new AddPNode(base_dest, adr_dest, phase-&gt;MakeConX(diff)));
344     }
345 
346     copy_type = elem;
347     value_type = ary_src-&gt;elem();
348   }
349   return true;
350 }
351 
<span class="line-modified">352 const TypePtr* ArrayCopyNode::get_address_type(PhaseGVN* phase, const TypePtr* atp, Node* n) {</span>
<span class="line-modified">353   if (atp == TypeOopPtr::BOTTOM) {</span>
<span class="line-modified">354     atp = phase-&gt;type(n)-&gt;isa_ptr();</span>
<span class="line-modified">355   }</span>
356   // adjust atp to be the correct array element address type
<span class="line-modified">357   return atp-&gt;add_offset(Type::OffsetBot);</span>

358 }
359 
360 void ArrayCopyNode::array_copy_test_overlap(PhaseGVN *phase, bool can_reshape, bool disjoint_bases, int count, Node*&amp; forward_ctl, Node*&amp; backward_ctl) {
361   Node* ctl = in(TypeFunc::Control);
362   if (!disjoint_bases &amp;&amp; count &gt; 1) {
363     Node* src_offset = in(ArrayCopyNode::SrcPos);
364     Node* dest_offset = in(ArrayCopyNode::DestPos);
365     assert(src_offset != NULL &amp;&amp; dest_offset != NULL, &quot;should be&quot;);
366     Node* cmp = phase-&gt;transform(new CmpINode(src_offset, dest_offset));
367     Node *bol = phase-&gt;transform(new BoolNode(cmp, BoolTest::lt));
368     IfNode *iff = new IfNode(ctl, bol, PROB_FAIR, COUNT_UNKNOWN);
369 
370     phase-&gt;transform(iff);
371 
372     forward_ctl = phase-&gt;transform(new IfFalseNode(iff));
373     backward_ctl = phase-&gt;transform(new IfTrueNode(iff));
374   } else {
375     forward_ctl = ctl;
376   }
377 }
</pre>
<hr />
<pre>
557   if (mem != NULL) {
558     return (mem == NodeSentinel) ? NULL : mem;
559   }
560 
561   Node* adr_src = NULL;
562   Node* base_src = NULL;
563   Node* adr_dest = NULL;
564   Node* base_dest = NULL;
565   BasicType copy_type = T_ILLEGAL;
566   const Type* value_type = NULL;
567   bool disjoint_bases = false;
568 
569   if (!prepare_array_copy(phase, can_reshape,
570                           adr_src, base_src, adr_dest, base_dest,
571                           copy_type, value_type, disjoint_bases)) {
572     return NULL;
573   }
574 
575   Node* src = in(ArrayCopyNode::Src);
576   Node* dest = in(ArrayCopyNode::Dest);
<span class="line-modified">577   const TypePtr* atp_src = get_address_type(phase, _src_type, src);</span>
<span class="line-modified">578   const TypePtr* atp_dest = get_address_type(phase, _dest_type, dest);</span>
579 
580   Node *in_mem = in(TypeFunc::Memory);
581   if (!in_mem-&gt;is_MergeMem()) {
582     in_mem = MergeMemNode::make(in_mem);
583   }
584 
585 
586   if (can_reshape) {
587     assert(!phase-&gt;is_IterGVN()-&gt;delay_transform(), &quot;cannot delay transforms&quot;);
588     phase-&gt;is_IterGVN()-&gt;set_delay_transform(true);
589   }
590 
591   Node* backward_ctl = phase-&gt;C-&gt;top();
592   Node* forward_ctl = phase-&gt;C-&gt;top();
593   array_copy_test_overlap(phase, can_reshape, disjoint_bases, count, forward_ctl, backward_ctl);
594 
595   Node* forward_mem = array_copy_forward(phase, can_reshape, forward_ctl,
596                                          in_mem-&gt;as_MergeMem(),
597                                          atp_src, atp_dest,
598                                          adr_src, base_src, adr_dest, base_dest,
</pre>
</td>
</tr>
</table>
<center><a href="addnode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="arraycopynode.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
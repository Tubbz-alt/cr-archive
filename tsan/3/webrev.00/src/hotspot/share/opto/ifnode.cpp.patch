diff a/src/hotspot/share/opto/ifnode.cpp b/src/hotspot/share/opto/ifnode.cpp
--- a/src/hotspot/share/opto/ifnode.cpp
+++ b/src/hotspot/share/opto/ifnode.cpp
@@ -115,11 +115,11 @@
   if( !t->singleton() ) return NULL;
 
   // No intervening control, like a simple Call
   Node *r = iff->in(0);
   if( !r->is_Region() ) return NULL;
-  if (r->is_Loop() && r->in(LoopNode::LoopBackControl)->is_top()) return NULL; // going away anyway
+  if (r->is_Loop()) return NULL;
   if( phi->region() != r ) return NULL;
   // No other users of the cmp/bool
   if (b->outcnt() != 1 || cmp->outcnt() != 1) {
     //tty->print_cr("many users of cmp/bool");
     return NULL;
@@ -236,72 +236,39 @@
   // likely 2 or more) will promptly constant fold away.
   PhaseGVN *phase = igvn;
 
   // Make a region merging constants and a region merging the rest
   uint req_c = 0;
-  Node* predicate_proj = NULL;
-  int nb_predicate_proj = 0;
   for (uint ii = 1; ii < r->req(); ii++) {
     if (phi->in(ii) == con1) {
       req_c++;
     }
     Node* proj = PhaseIdealLoop::find_predicate(r->in(ii));
     if (proj != NULL) {
-      nb_predicate_proj++;
-      predicate_proj = proj;
+      return NULL;
     }
   }
 
   // If all the defs of the phi are the same constant, we already have the desired end state.
   // Skip the split that would create empty phi and region nodes.
   if((r->req() - req_c) == 1) {
     return NULL;
   }
 
-  if (nb_predicate_proj > 1) {
-    // Can happen in case of loop unswitching and when the loop is
-    // optimized out: it's not a loop anymore so we don't care about
-    // predicates.
-    assert(!r->is_Loop(), "this must not be a loop anymore");
-    predicate_proj = NULL;
-  }
-  Node* predicate_c = NULL;
-  Node* predicate_x = NULL;
-  bool counted_loop = r->is_CountedLoop();
-  if (counted_loop) {
-    // Ignore counted loops for now because the split-if logic does not work
-    // in all the cases (for example, with strip mined loops). Also, above
-    // checks only pass for already degraded loops without a tripcount phi
-    // and these are essentially dead and will go away during igvn.
-    return NULL;
-  }
-
   Node *region_c = new RegionNode(req_c + 1);
   Node *phi_c    = con1;
   uint  len      = r->req();
   Node *region_x = new RegionNode(len - req_c);
   Node *phi_x    = PhiNode::make_blank(region_x, phi);
   for (uint i = 1, i_c = 1, i_x = 1; i < len; i++) {
     if (phi->in(i) == con1) {
       region_c->init_req( i_c++, r  ->in(i) );
-      if (r->in(i) == predicate_proj)
-        predicate_c = predicate_proj;
     } else {
       region_x->init_req( i_x,   r  ->in(i) );
       phi_x   ->init_req( i_x++, phi->in(i) );
-      if (r->in(i) == predicate_proj)
-        predicate_x = predicate_proj;
     }
   }
-  if (predicate_c != NULL && (req_c > 1)) {
-    assert(predicate_x == NULL, "only one predicate entry expected");
-    predicate_c = NULL; // Do not clone predicate below merge point
-  }
-  if (predicate_x != NULL && ((len - req_c) > 2)) {
-    assert(predicate_c == NULL, "only one predicate entry expected");
-    predicate_x = NULL; // Do not clone predicate below merge point
-  }
 
   // Register the new RegionNodes but do not transform them.  Cannot
   // transform until the entire Region/Phi conglomerate has been hacked
   // as a single huge transform.
   igvn->register_new_node_with_optimizer( region_c );
@@ -339,24 +306,12 @@
   hook->init_req(3, iff_x);
 
   // Make the true/false arms
   Node *iff_c_t = phase->transform(new IfTrueNode (iff_c));
   Node *iff_c_f = phase->transform(new IfFalseNode(iff_c));
-  if (predicate_c != NULL) {
-    assert(predicate_x == NULL, "only one predicate entry expected");
-    // Clone loop predicates to each path
-    iff_c_t = igvn->clone_loop_predicates(predicate_c, iff_c_t, !counted_loop);
-    iff_c_f = igvn->clone_loop_predicates(predicate_c, iff_c_f, !counted_loop);
-  }
   Node *iff_x_t = phase->transform(new IfTrueNode (iff_x));
   Node *iff_x_f = phase->transform(new IfFalseNode(iff_x));
-  if (predicate_x != NULL) {
-    assert(predicate_c == NULL, "only one predicate entry expected");
-    // Clone loop predicates to each path
-    iff_x_t = igvn->clone_loop_predicates(predicate_x, iff_x_t, !counted_loop);
-    iff_x_f = igvn->clone_loop_predicates(predicate_x, iff_x_f, !counted_loop);
-  }
 
   // Merge the TRUE paths
   Node *region_s = new RegionNode(3);
   igvn->_worklist.push(region_s);
   region_s->init_req(1, iff_c_t);
@@ -631,22 +586,22 @@
         (din3 = din3->in(0)) )
       din3 = din3->in(0);
     if( din4->is_Call() &&      // Handle a slow-path call on either arm
         (din4 = din4->in(0)) )
       din4 = din4->in(0);
-    if( din3 == din4 && din3->is_If() )
+    if (din3 != NULL && din3 == din4 && din3->is_If()) // Regions not degraded to a copy
       return din3;              // Skip around diamonds
   }
 
   // Give up the search at true merges
   return NULL;                  // Dead loop?  Or hit root?
 }
 
 
 //------------------------------filtered_int_type--------------------------------
 // Return a possibly more restrictive type for val based on condition control flow for an if
-const TypeInt* IfNode::filtered_int_type(PhaseGVN* gvn, Node *val, Node* if_proj) {
+const TypeInt* IfNode::filtered_int_type(PhaseGVN* gvn, Node* val, Node* if_proj) {
   assert(if_proj &&
          (if_proj->Opcode() == Op_IfTrue || if_proj->Opcode() == Op_IfFalse), "expecting an if projection");
   if (if_proj->in(0) && if_proj->in(0)->is_If()) {
     IfNode* iff = if_proj->in(0)->as_If();
     if (iff->in(1) && iff->in(1)->is_Bool()) {
@@ -658,13 +613,23 @@
           if (cmp2_t != NULL) {
             jint lo = cmp2_t->_lo;
             jint hi = cmp2_t->_hi;
             BoolTest::mask msk = if_proj->Opcode() == Op_IfTrue ? bol->_test._test : bol->_test.negate();
             switch (msk) {
-            case BoolTest::ne:
+            case BoolTest::ne: {
+              // If val is compared to its lower or upper bound, we can narrow the type
+              const TypeInt* val_t = gvn->type(val)->isa_int();
+              if (val_t != NULL && !val_t->singleton() && cmp2_t->is_con()) {
+                if (val_t->_lo == lo) {
+                  return TypeInt::make(val_t->_lo + 1, val_t->_hi, val_t->_widen);
+                } else if (val_t->_hi == hi) {
+                  return TypeInt::make(val_t->_lo, val_t->_hi - 1, val_t->_widen);
+                }
+              }
               // Can't refine type
               return NULL;
+            }
             case BoolTest::eq:
               return cmp2_t;
             case BoolTest::lt:
               lo = TypeInt::INT->_lo;
               if (hi - 1 < hi) {
@@ -734,29 +699,30 @@
 //            /    \
 //           /      unc
 //
 
 // Is the comparison for this If suitable for folding?
-bool IfNode::cmpi_folds(PhaseIterGVN* igvn) {
+bool IfNode::cmpi_folds(PhaseIterGVN* igvn, bool fold_ne) {
   return in(1) != NULL &&
     in(1)->is_Bool() &&
     in(1)->in(1) != NULL &&
     in(1)->in(1)->Opcode() == Op_CmpI &&
     in(1)->in(1)->in(2) != NULL &&
     in(1)->in(1)->in(2) != igvn->C->top() &&
     (in(1)->as_Bool()->_test.is_less() ||
-     in(1)->as_Bool()->_test.is_greater());
+     in(1)->as_Bool()->_test.is_greater() ||
+     (fold_ne && in(1)->as_Bool()->_test._test == BoolTest::ne));
 }
 
 // Is a dominating control suitable for folding with this if?
 bool IfNode::is_ctrl_folds(Node* ctrl, PhaseIterGVN* igvn) {
   return ctrl != NULL &&
     ctrl->is_Proj() &&
     ctrl->in(0) != NULL &&
     ctrl->in(0)->Opcode() == Op_If &&
     ctrl->in(0)->outcnt() == 2 &&
-    ctrl->in(0)->as_If()->cmpi_folds(igvn) &&
+    ctrl->in(0)->as_If()->cmpi_folds(igvn, true) &&
     // Must compare same value
     ctrl->in(0)->in(1)->in(1)->in(1) != NULL &&
     ctrl->in(0)->in(1)->in(1)->in(1) == in(1)->in(1)->in(1);
 }
 
@@ -914,11 +880,11 @@
 
   // Figure out which of the two tests sets the upper bound and which
   // sets the lower bound if any.
   Node* adjusted_lim = NULL;
   if (lo_type != NULL && hi_type != NULL && hi_type->_lo > lo_type->_hi &&
-      hi_type->_hi == max_jint && lo_type->_lo == min_jint) {
+      hi_type->_hi == max_jint && lo_type->_lo == min_jint && lo_test != BoolTest::ne) {
     assert((dom_bool->_test.is_less() && !proj->_con) ||
            (dom_bool->_test.is_greater() && proj->_con), "incorrect test");
     // this test was canonicalized
     assert(this_bool->_test.is_less() && fail->_con, "incorrect test");
 
@@ -955,11 +921,11 @@
         lo = igvn->transform(new AddINode(lo, igvn->intcon(1)));
         cond = BoolTest::lt;
       }
     }
   } else if (lo_type != NULL && hi_type != NULL && lo_type->_lo > hi_type->_hi &&
-             lo_type->_hi == max_jint && hi_type->_lo == min_jint) {
+             lo_type->_hi == max_jint && hi_type->_lo == min_jint && lo_test != BoolTest::ne) {
 
     // this_bool = <
     //   dom_bool = < (proj = True) or dom_bool = >= (proj = False)
     //     x in [b, a[ on the fail (= False) projection, a > b-1 (because of lo_type->_lo > hi_type->_hi above):
     //     lo = b, hi = a, adjusted_lim = a-b, cond = >=u
@@ -1006,11 +972,11 @@
         lo = igvn->transform(new AddINode(lo, igvn->intcon(1)));
         cond = BoolTest::ge;
       }
     }
   } else {
-    const TypeInt* failtype  = filtered_int_type(igvn, n, proj);
+    const TypeInt* failtype = filtered_int_type(igvn, n, proj);
     if (failtype != NULL) {
       const TypeInt* type2 = filtered_int_type(igvn, n, fail);
       if (type2 != NULL) {
         failtype = failtype->join(type2)->is_int();
         if (failtype->_lo > failtype->_hi) {
@@ -1282,12 +1248,11 @@
 Node* IfNode::fold_compares(PhaseIterGVN* igvn) {
   if (Opcode() != Op_If) return NULL;
 
   if (cmpi_folds(igvn)) {
     Node* ctrl = in(0);
-    if (is_ctrl_folds(ctrl, igvn) &&
-        ctrl->outcnt() == 1) {
+    if (is_ctrl_folds(ctrl, igvn) && ctrl->outcnt() == 1) {
       // A integer comparison immediately dominated by another integer
       // comparison
       ProjNode* success = NULL;
       ProjNode* fail = NULL;
       ProjNode* dom_cmp = ctrl->as_Proj();
@@ -1435,59 +1400,48 @@
   }
 
   // Check for people making a useless boolean: things like
   // if( (x < y ? true : false) ) { ... }
   // Replace with if( x < y ) { ... }
-  Node *bol2 = remove_useless_bool(this, phase);
-  if( bol2 ) return bol2;
+  Node* bol2 = remove_useless_bool(this, phase);
+  if (bol2) return bol2;
 
   if (in(0) == NULL) return NULL;     // Dead loop?
 
-  PhaseIterGVN *igvn = phase->is_IterGVN();
+  PhaseIterGVN* igvn = phase->is_IterGVN();
   Node* result = fold_compares(igvn);
   if (result != NULL) {
     return result;
   }
 
   // Scan for an equivalent test
-  Node *cmp;
-  int dist = 0;               // Cutoff limit for search
-  int op = Opcode();
-  if( op == Op_If &&
-      (cmp=in(1)->in(1))->Opcode() == Op_CmpP ) {
-    if( cmp->in(2) != NULL && // make sure cmp is not already dead
-        cmp->in(2)->bottom_type() == TypePtr::NULL_PTR ) {
+  int dist = 4;               // Cutoff limit for search
+  if (is_If() && in(1)->is_Bool()) {
+    Node* cmp = in(1)->in(1);
+    if (cmp->Opcode() == Op_CmpP &&
+        cmp->in(2) != NULL && // make sure cmp is not already dead
+        cmp->in(2)->bottom_type() == TypePtr::NULL_PTR) {
       dist = 64;              // Limit for null-pointer scans
-    } else {
-      dist = 4;               // Do not bother for random pointer tests
     }
-  } else {
-    dist = 4;                 // Limit for random junky scans
   }
 
   Node* prev_dom = search_identical(dist);
 
-  if (prev_dom == NULL) {
-    return NULL;
+  if (prev_dom != NULL) {
+    // Replace dominated IfNode
+    return dominated_by(prev_dom, igvn);
   }
 
-  // Replace dominated IfNode
-  return dominated_by(prev_dom, igvn);
+  return simple_subsuming(igvn);
 }
 
 //------------------------------dominated_by-----------------------------------
 Node* IfNode::dominated_by(Node* prev_dom, PhaseIterGVN *igvn) {
 #ifndef PRODUCT
   if (TraceIterativeGVN) {
     tty->print("   Removing IfNode: "); this->dump();
   }
-  if (VerifyOpto && !igvn->allow_progress()) {
-    // Found an equivalent dominating test,
-    // we can not guarantee reaching a fix-point for these during iterativeGVN
-    // since intervening nodes may not change.
-    return NULL;
-  }
 #endif
 
   igvn->hash_delete(this);      // Remove self to prevent spurious V-N
   Node *idom = in(0);
   // Need opcode to decide which way 'this' test goes
@@ -1572,10 +1526,118 @@
 #endif
 
   return prev_dom;
 }
 
+
+static int subsuming_bool_test_encode(Node*);
+
+// Check if dominating test is subsuming 'this' one.
+//
+//              cmp
+//              / \
+//     (r1)  bool  \
+//            /    bool (r2)
+//    (dom) if       \
+//            \       )
+//    (pre)  if[TF]  /
+//               \  /
+//                if (this)
+//   \r1
+//  r2\  eqT  eqF  neT  neF  ltT  ltF  leT  leF  gtT  gtF  geT  geF
+//  eq    t    f    f    t    f    -    -    f    f    -    -    f
+//  ne    f    t    t    f    t    -    -    t    t    -    -    t
+//  lt    f    -    -    f    t    f    -    f    f    -    f    t
+//  le    t    -    -    t    t    -    t    f    f    t    -    t
+//  gt    f    -    -    f    f    -    f    t    t    f    -    f
+//  ge    t    -    -    t    f    t    -    t    t    -    t    f
+//
+Node* IfNode::simple_subsuming(PhaseIterGVN* igvn) {
+  // Table encoding: N/A (na), True-branch (tb), False-branch (fb).
+  static enum { na, tb, fb } s_short_circuit_map[6][12] = {
+  /*rel: eq+T eq+F ne+T ne+F lt+T lt+F le+T le+F gt+T gt+F ge+T ge+F*/
+  /*eq*/{ tb,  fb,  fb,  tb,  fb,  na,  na,  fb,  fb,  na,  na,  fb },
+  /*ne*/{ fb,  tb,  tb,  fb,  tb,  na,  na,  tb,  tb,  na,  na,  tb },
+  /*lt*/{ fb,  na,  na,  fb,  tb,  fb,  na,  fb,  fb,  na,  fb,  tb },
+  /*le*/{ tb,  na,  na,  tb,  tb,  na,  tb,  fb,  fb,  tb,  na,  tb },
+  /*gt*/{ fb,  na,  na,  fb,  fb,  na,  fb,  tb,  tb,  fb,  na,  fb },
+  /*ge*/{ tb,  na,  na,  tb,  fb,  tb,  na,  tb,  tb,  na,  tb,  fb }};
+
+  Node* pre = in(0);
+  if (!pre->is_IfTrue() && !pre->is_IfFalse()) {
+    return NULL;
+  }
+  Node* dom = pre->in(0);
+  if (!dom->is_If()) {
+    return NULL;
+  }
+  Node* bol = in(1);
+  if (!bol->is_Bool()) {
+    return NULL;
+  }
+  Node* cmp = in(1)->in(1);
+  if (!cmp->is_Cmp()) {
+    return NULL;
+  }
+
+  if (!dom->in(1)->is_Bool()) {
+    return NULL;
+  }
+  if (dom->in(1)->in(1) != cmp) {  // Not same cond?
+    return NULL;
+  }
+
+  int drel = subsuming_bool_test_encode(dom->in(1));
+  int trel = subsuming_bool_test_encode(bol);
+  int bout = pre->is_IfFalse() ? 1 : 0;
+
+  if (drel < 0 || trel < 0) {
+    return NULL;
+  }
+  int br = s_short_circuit_map[trel][2*drel+bout];
+  if (br == na) {
+    return NULL;
+  }
+#ifndef PRODUCT
+  if (TraceIterativeGVN) {
+    tty->print("   Subsumed IfNode: "); dump();
+  }
+#endif
+  // Replace condition with constant True(1)/False(0).
+  set_req(1, igvn->intcon(br == tb ? 1 : 0));
+
+  if (bol->outcnt() == 0) {
+    igvn->remove_dead_node(bol);    // Kill the BoolNode.
+  }
+  return this;
+}
+
+// Map BoolTest to local table encoding. The BoolTest (e)numerals
+//   { eq = 0, ne = 4, le = 5, ge = 7, lt = 3, gt = 1 }
+// are mapped to table indices, while the remaining (e)numerals in BoolTest
+//   { overflow = 2, no_overflow = 6, never = 8, illegal = 9 }
+// are ignored (these are not modeled in the table).
+//
+static int subsuming_bool_test_encode(Node* node) {
+  precond(node->is_Bool());
+  BoolTest::mask x = node->as_Bool()->_test._test;
+  switch (x) {
+    case BoolTest::eq: return 0;
+    case BoolTest::ne: return 1;
+    case BoolTest::lt: return 2;
+    case BoolTest::le: return 3;
+    case BoolTest::gt: return 4;
+    case BoolTest::ge: return 5;
+    case BoolTest::overflow:
+    case BoolTest::no_overflow:
+    case BoolTest::never:
+    case BoolTest::illegal:
+    default:
+      return -1;
+  }
+}
+
 //------------------------------Identity---------------------------------------
 // If the test is constant & we match, then we are the input Control
 Node* IfProjNode::Identity(PhaseGVN* phase) {
   // Can only optimize if cannot go the other way
   const TypeTuple *t = phase->type(in(0))->is_tuple();
@@ -1717,11 +1779,11 @@
     // then we are guaranteed to fail, so just start interpreting there.
     // We 'expand' the top 3 range checks to include all post-dominating
     // checks.
 
     // The top 3 range checks seen
-    const int NRC =3;
+    const int NRC = 3;
     RangeCheck prev_checks[NRC];
     int nb_checks = 0;
 
     // Low and high offsets seen so far
     jint off_lo = offset1;

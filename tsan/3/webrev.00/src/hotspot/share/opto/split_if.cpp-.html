<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/split_if.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;memory/allocation.inline.hpp&quot;
 27 #include &quot;opto/callnode.hpp&quot;
 28 #include &quot;opto/loopnode.hpp&quot;
 29 #include &quot;opto/movenode.hpp&quot;
 30 
 31 
 32 //------------------------------split_thru_region------------------------------
 33 // Split Node &#39;n&#39; through merge point.
 34 Node *PhaseIdealLoop::split_thru_region( Node *n, Node *region ) {
 35   uint wins = 0;
 36   assert( n-&gt;is_CFG(), &quot;&quot; );
 37   assert( region-&gt;is_Region(), &quot;&quot; );
 38   Node *r = new RegionNode( region-&gt;req() );
 39   IdealLoopTree *loop = get_loop( n );
 40   for( uint i = 1; i &lt; region-&gt;req(); i++ ) {
 41     Node *x = n-&gt;clone();
 42     Node *in0 = n-&gt;in(0);
 43     if( in0-&gt;in(0) == region ) x-&gt;set_req( 0, in0-&gt;in(i) );
 44     for( uint j = 1; j &lt; n-&gt;req(); j++ ) {
 45       Node *in = n-&gt;in(j);
 46       if( get_ctrl(in) == region )
 47         x-&gt;set_req( j, in-&gt;in(i) );
 48     }
 49     _igvn.register_new_node_with_optimizer(x);
 50     set_loop(x, loop);
 51     set_idom(x, x-&gt;in(0), dom_depth(x-&gt;in(0))+1);
 52     r-&gt;init_req(i, x);
 53   }
 54 
 55   // Record region
 56   r-&gt;set_req(0,region);         // Not a TRUE RegionNode
 57   _igvn.register_new_node_with_optimizer(r);
 58   set_loop(r, loop);
 59   if( !loop-&gt;_child )
 60     loop-&gt;_body.push(r);
 61   return r;
 62 }
 63 
 64 //------------------------------split_up---------------------------------------
 65 // Split block-local op up through the phis to empty the current block
 66 bool PhaseIdealLoop::split_up( Node *n, Node *blk1, Node *blk2 ) {
 67   if( n-&gt;is_CFG() ) {
 68     assert( n-&gt;in(0) != blk1, &quot;Lousy candidate for split-if&quot; );
 69     return false;
 70   }
 71   if( get_ctrl(n) != blk1 &amp;&amp; get_ctrl(n) != blk2 )
 72     return false;               // Not block local
 73   if( n-&gt;is_Phi() ) return false; // Local PHIs are expected
 74 
 75   // Recursively split-up inputs
 76   for (uint i = 1; i &lt; n-&gt;req(); i++) {
 77     if( split_up( n-&gt;in(i), blk1, blk2 ) ) {
 78       // Got split recursively and self went dead?
 79       if (n-&gt;outcnt() == 0)
 80         _igvn.remove_dead_node(n);
 81       return true;
 82     }
 83   }
 84 
 85   // Check for needing to clone-up a compare.  Can&#39;t do that, it forces
 86   // another (nested) split-if transform.  Instead, clone it &quot;down&quot;.
 87   if( n-&gt;is_Cmp() ) {
 88     assert(get_ctrl(n) == blk2 || get_ctrl(n) == blk1, &quot;must be in block with IF&quot;);
 89     // Check for simple Cmp/Bool/CMove which we can clone-up.  Cmp/Bool/CMove
 90     // sequence can have no other users and it must all reside in the split-if
 91     // block.  Non-simple Cmp/Bool/CMove sequences are &#39;cloned-down&#39; below -
 92     // private, per-use versions of the Cmp and Bool are made.  These sink to
 93     // the CMove block.  If the CMove is in the split-if block, then in the
 94     // next iteration this will become a simple Cmp/Bool/CMove set to clone-up.
 95     Node *bol, *cmov;
 96     if( !(n-&gt;outcnt() == 1 &amp;&amp; n-&gt;unique_out()-&gt;is_Bool() &amp;&amp;
 97           (bol = n-&gt;unique_out()-&gt;as_Bool()) &amp;&amp;
 98           (get_ctrl(bol) == blk1 ||
 99            get_ctrl(bol) == blk2) &amp;&amp;
100           bol-&gt;outcnt() == 1 &amp;&amp;
101           bol-&gt;unique_out()-&gt;is_CMove() &amp;&amp;
102           (cmov = bol-&gt;unique_out()-&gt;as_CMove()) &amp;&amp;
103           (get_ctrl(cmov) == blk1 ||
104            get_ctrl(cmov) == blk2) ) ) {
105 
106       // Must clone down
107 #ifndef PRODUCT
108       if( PrintOpto &amp;&amp; VerifyLoopOptimizations ) {
109         tty-&gt;print(&quot;Cloning down: &quot;);
110         n-&gt;dump();
111       }
112 #endif
113       // Clone down any block-local BoolNode uses of this CmpNode
114       for (DUIterator i = n-&gt;outs(); n-&gt;has_out(i); i++) {
115         Node* bol = n-&gt;out(i);
116         assert( bol-&gt;is_Bool(), &quot;&quot; );
117         if (bol-&gt;outcnt() == 1) {
118           Node* use = bol-&gt;unique_out();
119           if (use-&gt;Opcode() == Op_Opaque4) {
120             if (use-&gt;outcnt() == 1) {
121               Node* iff = use-&gt;unique_out();
122               assert(iff-&gt;is_If(), &quot;unexpected node type&quot;);
123               Node *use_c = iff-&gt;in(0);
124               if (use_c == blk1 || use_c == blk2) {
125                 continue;
126               }
127             }
128           } else {
129             // We might see an Opaque1 from a loop limit check here
130             assert(use-&gt;is_If() || use-&gt;is_CMove() || use-&gt;Opcode() == Op_Opaque1, &quot;unexpected node type&quot;);
131             Node *use_c = use-&gt;is_If() ? use-&gt;in(0) : get_ctrl(use);
132             if (use_c == blk1 || use_c == blk2) {
133               assert(use-&gt;is_CMove(), &quot;unexpected node type&quot;);
134               continue;
135             }
136           }
137         }
138         if (get_ctrl(bol) == blk1 || get_ctrl(bol) == blk2) {
139           // Recursively sink any BoolNode
140 #ifndef PRODUCT
141           if( PrintOpto &amp;&amp; VerifyLoopOptimizations ) {
142             tty-&gt;print(&quot;Cloning down: &quot;);
143             bol-&gt;dump();
144           }
145 #endif
146           for (DUIterator j = bol-&gt;outs(); bol-&gt;has_out(j); j++) {
147             Node* u = bol-&gt;out(j);
148             // Uses are either IfNodes, CMoves or Opaque4
149             if (u-&gt;Opcode() == Op_Opaque4) {
150               assert(u-&gt;in(1) == bol, &quot;bad input&quot;);
151               for (DUIterator_Last kmin, k = u-&gt;last_outs(kmin); k &gt;= kmin; --k) {
152                 Node* iff = u-&gt;last_out(k);
153                 assert(iff-&gt;is_If() || iff-&gt;is_CMove(), &quot;unexpected node type&quot;);
154                 assert( iff-&gt;in(1) == u, &quot;&quot; );
155                 // Get control block of either the CMove or the If input
156                 Node *iff_ctrl = iff-&gt;is_If() ? iff-&gt;in(0) : get_ctrl(iff);
157                 Node *x1 = bol-&gt;clone();
158                 Node *x2 = u-&gt;clone();
159                 register_new_node(x1, iff_ctrl);
160                 register_new_node(x2, iff_ctrl);
161                 _igvn.replace_input_of(x2, 1, x1);
162                 _igvn.replace_input_of(iff, 1, x2);
163               }
164               _igvn.remove_dead_node(u);
165               --j;
166             } else {
167               // We might see an Opaque1 from a loop limit check here
168               assert(u-&gt;is_If() || u-&gt;is_CMove() || u-&gt;Opcode() == Op_Opaque1, &quot;unexpected node type&quot;);
169               assert(u-&gt;in(1) == bol, &quot;&quot;);
170               // Get control block of either the CMove or the If input
171               Node *u_ctrl = u-&gt;is_If() ? u-&gt;in(0) : get_ctrl(u);
172               assert((u_ctrl != blk1 &amp;&amp; u_ctrl != blk2) || u-&gt;is_CMove(), &quot;won&#39;t converge&quot;);
173               Node *x = bol-&gt;clone();
174               register_new_node(x, u_ctrl);
175               _igvn.replace_input_of(u, 1, x);
176               --j;
177             }
178           }
179           _igvn.remove_dead_node(bol);
180           --i;
181         }
182       }
183       // Clone down this CmpNode
184       for (DUIterator_Last jmin, j = n-&gt;last_outs(jmin); j &gt;= jmin; --j) {
185         Node* bol = n-&gt;last_out(j);
186         assert( bol-&gt;in(1) == n, &quot;&quot; );
187         Node *x = n-&gt;clone();
188         register_new_node(x, get_ctrl(bol));
189         _igvn.replace_input_of(bol, 1, x);
190       }
191       _igvn.remove_dead_node( n );
192 
193       return true;
194     }
195   }
196 
197   // See if splitting-up a Store.  Any anti-dep loads must go up as
198   // well.  An anti-dep load might be in the wrong block, because in
199   // this particular layout/schedule we ignored anti-deps and allow
200   // memory to be alive twice.  This only works if we do the same
201   // operations on anti-dep loads as we do their killing stores.
202   if( n-&gt;is_Store() &amp;&amp; n-&gt;in(MemNode::Memory)-&gt;in(0) == n-&gt;in(0) ) {
203     // Get store&#39;s memory slice
204     int alias_idx = C-&gt;get_alias_index(_igvn.type(n-&gt;in(MemNode::Address))-&gt;is_ptr());
205 
206     // Get memory-phi anti-dep loads will be using
207     Node *memphi = n-&gt;in(MemNode::Memory);
208     assert( memphi-&gt;is_Phi(), &quot;&quot; );
209     // Hoist any anti-dep load to the splitting block;
210     // it will then &quot;split-up&quot;.
211     for (DUIterator_Fast imax,i = memphi-&gt;fast_outs(imax); i &lt; imax; i++) {
212       Node *load = memphi-&gt;fast_out(i);
213       if( load-&gt;is_Load() &amp;&amp; alias_idx == C-&gt;get_alias_index(_igvn.type(load-&gt;in(MemNode::Address))-&gt;is_ptr()) )
214         set_ctrl(load,blk1);
215     }
216   }
217 
218   // Found some other Node; must clone it up
219 #ifndef PRODUCT
220   if( PrintOpto &amp;&amp; VerifyLoopOptimizations ) {
221     tty-&gt;print(&quot;Cloning up: &quot;);
222     n-&gt;dump();
223   }
224 #endif
225 
226   // ConvI2L may have type information on it which becomes invalid if
227   // it moves up in the graph so change any clones so widen the type
228   // to TypeLong::INT when pushing it up.
229   const Type* rtype = NULL;
230   if (n-&gt;Opcode() == Op_ConvI2L &amp;&amp; n-&gt;bottom_type() != TypeLong::INT) {
231     rtype = TypeLong::INT;
232   }
233 
234   // Now actually split-up this guy.  One copy per control path merging.
235   Node *phi = PhiNode::make_blank(blk1, n);
236   for( uint j = 1; j &lt; blk1-&gt;req(); j++ ) {
237     Node *x = n-&gt;clone();
238     // Widen the type of the ConvI2L when pushing up.
239     if (rtype != NULL) x-&gt;as_Type()-&gt;set_type(rtype);
240     if( n-&gt;in(0) &amp;&amp; n-&gt;in(0) == blk1 )
241       x-&gt;set_req( 0, blk1-&gt;in(j) );
242     for( uint i = 1; i &lt; n-&gt;req(); i++ ) {
243       Node *m = n-&gt;in(i);
244       if( get_ctrl(m) == blk1 ) {
245         assert( m-&gt;in(0) == blk1, &quot;&quot; );
246         x-&gt;set_req( i, m-&gt;in(j) );
247       }
248     }
249     register_new_node( x, blk1-&gt;in(j) );
250     phi-&gt;init_req( j, x );
251   }
252   // Announce phi to optimizer
253   register_new_node(phi, blk1);
254 
255   // Remove cloned-up value from optimizer; use phi instead
256   _igvn.replace_node( n, phi );
257 
258   // (There used to be a self-recursive call to split_up() here,
259   // but it is not needed.  All necessary forward walking is done
260   // by do_split_if() below.)
261 
262   return true;
263 }
264 
265 //------------------------------register_new_node------------------------------
266 void PhaseIdealLoop::register_new_node( Node *n, Node *blk ) {
267   assert(!n-&gt;is_CFG(), &quot;must be data node&quot;);
268   _igvn.register_new_node_with_optimizer(n);
269   set_ctrl(n, blk);
270   IdealLoopTree *loop = get_loop(blk);
271   if( !loop-&gt;_child )
272     loop-&gt;_body.push(n);
273 }
274 
275 //------------------------------small_cache------------------------------------
276 struct small_cache : public Dict {
277 
278   small_cache() : Dict( cmpkey, hashptr ) {}
279   Node *probe( Node *use_blk ) { return (Node*)((*this)[use_blk]); }
280   void lru_insert( Node *use_blk, Node *new_def ) { Insert(use_blk,new_def); }
281 };
282 
283 //------------------------------spinup-----------------------------------------
284 // &quot;Spin up&quot; the dominator tree, starting at the use site and stopping when we
285 // find the post-dominating point.
286 
287 // We must be at the merge point which post-dominates &#39;new_false&#39; and
288 // &#39;new_true&#39;.  Figure out which edges into the RegionNode eventually lead up
289 // to false and which to true.  Put in a PhiNode to merge values; plug in
290 // the appropriate false-arm or true-arm values.  If some path leads to the
291 // original IF, then insert a Phi recursively.
292 Node *PhaseIdealLoop::spinup( Node *iff_dom, Node *new_false, Node *new_true, Node *use_blk, Node *def, small_cache *cache ) {
293   if (use_blk-&gt;is_top())        // Handle dead uses
294     return use_blk;
295   Node *prior_n = (Node*)((intptr_t)0xdeadbeef);
296   Node *n = use_blk;            // Get path input
297   assert( use_blk != iff_dom, &quot;&quot; );
298   // Here&#39;s the &quot;spinup&quot; the dominator tree loop.  Do a cache-check
299   // along the way, in case we&#39;ve come this way before.
300   while( n != iff_dom ) {       // Found post-dominating point?
301     prior_n = n;
302     n = idom(n);                // Search higher
303     Node *s = cache-&gt;probe( prior_n ); // Check cache
304     if( s ) return s;           // Cache hit!
305   }
306 
307   Node *phi_post;
308   if( prior_n == new_false || prior_n == new_true ) {
309     phi_post = def-&gt;clone();
310     phi_post-&gt;set_req(0, prior_n );
311     register_new_node(phi_post, prior_n);
312   } else {
313     // This method handles both control uses (looking for Regions) or data
314     // uses (looking for Phis).  If looking for a control use, then we need
315     // to insert a Region instead of a Phi; however Regions always exist
316     // previously (the hash_find_insert below would always hit) so we can
317     // return the existing Region.
318     if( def-&gt;is_CFG() ) {
319       phi_post = prior_n;       // If looking for CFG, return prior
320     } else {
321       assert( def-&gt;is_Phi(), &quot;&quot; );
322       assert( prior_n-&gt;is_Region(), &quot;must be a post-dominating merge point&quot; );
323 
324       // Need a Phi here
325       phi_post = PhiNode::make_blank(prior_n, def);
326       // Search for both true and false on all paths till find one.
327       for( uint i = 1; i &lt; phi_post-&gt;req(); i++ ) // For all paths
328         phi_post-&gt;init_req( i, spinup( iff_dom, new_false, new_true, prior_n-&gt;in(i), def, cache ) );
329       Node *t = _igvn.hash_find_insert(phi_post);
330       if( t ) {                 // See if we already have this one
331         // phi_post will not be used, so kill it
332         _igvn.remove_dead_node(phi_post);
333         phi_post-&gt;destruct();
334         phi_post = t;
335       } else {
336         register_new_node( phi_post, prior_n );
337       }
338     }
339   }
340 
341   // Update cache everywhere
342   prior_n = (Node*)((intptr_t)0xdeadbeef);  // Reset IDOM walk
343   n = use_blk;                  // Get path input
344   // Spin-up the idom tree again, basically doing path-compression.
345   // Insert cache entries along the way, so that if we ever hit this
346   // point in the IDOM tree again we&#39;ll stop immediately on a cache hit.
347   while( n != iff_dom ) {       // Found post-dominating point?
348     prior_n = n;
349     n = idom(n);                // Search higher
350     cache-&gt;lru_insert( prior_n, phi_post ); // Fill cache
351   } // End of while not gone high enough
352 
353   return phi_post;
354 }
355 
356 //------------------------------find_use_block---------------------------------
357 // Find the block a USE is in.  Normally USE&#39;s are in the same block as the
358 // using instruction.  For Phi-USE&#39;s, the USE is in the predecessor block
359 // along the corresponding path.
360 Node *PhaseIdealLoop::find_use_block( Node *use, Node *def, Node *old_false, Node *new_false, Node *old_true, Node *new_true ) {
361   // CFG uses are their own block
362   if( use-&gt;is_CFG() )
363     return use;
364 
365   if( use-&gt;is_Phi() ) {         // Phi uses in prior block
366     // Grab the first Phi use; there may be many.
367     // Each will be handled as a separate iteration of
368     // the &quot;while( phi-&gt;outcnt() )&quot; loop.
369     uint j;
370     for( j = 1; j &lt; use-&gt;req(); j++ )
371       if( use-&gt;in(j) == def )
372         break;
373     assert( j &lt; use-&gt;req(), &quot;def should be among use&#39;s inputs&quot; );
374     return use-&gt;in(0)-&gt;in(j);
375   }
376   // Normal (non-phi) use
377   Node *use_blk = get_ctrl(use);
378   // Some uses are directly attached to the old (and going away)
379   // false and true branches.
380   if( use_blk == old_false ) {
381     use_blk = new_false;
382     set_ctrl(use, new_false);
383   }
384   if( use_blk == old_true ) {
385     use_blk = new_true;
386     set_ctrl(use, new_true);
387   }
388 
389   if (use_blk == NULL) {        // He&#39;s dead, Jim
390     _igvn.replace_node(use, C-&gt;top());
391   }
392 
393   return use_blk;
394 }
395 
396 //------------------------------handle_use-------------------------------------
397 // Handle uses of the merge point.  Basically, split-if makes the merge point
398 // go away so all uses of the merge point must go away as well.  Most block
399 // local uses have already been split-up, through the merge point.  Uses from
400 // far below the merge point can&#39;t always be split up (e.g., phi-uses are
401 // pinned) and it makes too much stuff live.  Instead we use a path-based
402 // solution to move uses down.
403 //
404 // If the use is along the pre-split-CFG true branch, then the new use will
405 // be from the post-split-CFG true merge point.  Vice-versa for the false
406 // path.  Some uses will be along both paths; then we sink the use to the
407 // post-dominating location; we may need to insert a Phi there.
408 void PhaseIdealLoop::handle_use( Node *use, Node *def, small_cache *cache, Node *region_dom, Node *new_false, Node *new_true, Node *old_false, Node *old_true ) {
409 
410   Node *use_blk = find_use_block(use,def,old_false,new_false,old_true,new_true);
411   if( !use_blk ) return;        // He&#39;s dead, Jim
412 
413   // Walk up the dominator tree until I hit either the old IfFalse, the old
414   // IfTrue or the old If.  Insert Phis where needed.
415   Node *new_def = spinup( region_dom, new_false, new_true, use_blk, def, cache );
416 
417   // Found where this USE goes.  Re-point him.
418   uint i;
419   for( i = 0; i &lt; use-&gt;req(); i++ )
420     if( use-&gt;in(i) == def )
421       break;
422   assert( i &lt; use-&gt;req(), &quot;def should be among use&#39;s inputs&quot; );
423   _igvn.replace_input_of(use, i, new_def);
424 }
425 
426 //------------------------------do_split_if------------------------------------
427 // Found an If getting its condition-code input from a Phi in the same block.
428 // Split thru the Region.
429 void PhaseIdealLoop::do_split_if( Node *iff ) {
430   if (PrintOpto &amp;&amp; VerifyLoopOptimizations) {
431     tty-&gt;print_cr(&quot;Split-if&quot;);
432   }
433   if (TraceLoopOpts) {
434     tty-&gt;print_cr(&quot;SplitIf&quot;);
435   }
436 
437   C-&gt;set_major_progress();
438   Node *region = iff-&gt;in(0);
439   Node *region_dom = idom(region);
440 
441   // We are going to clone this test (and the control flow with it) up through
442   // the incoming merge point.  We need to empty the current basic block.
443   // Clone any instructions which must be in this block up through the merge
444   // point.
445   DUIterator i, j;
446   bool progress = true;
447   while (progress) {
448     progress = false;
449     for (i = region-&gt;outs(); region-&gt;has_out(i); i++) {
450       Node* n = region-&gt;out(i);
451       if( n == region ) continue;
452       // The IF to be split is OK.
453       if( n == iff ) continue;
454       if( !n-&gt;is_Phi() ) {      // Found pinned memory op or such
455         if (split_up(n, region, iff)) {
456           i = region-&gt;refresh_out_pos(i);
457           progress = true;
458         }
459         continue;
460       }
461       assert( n-&gt;in(0) == region, &quot;&quot; );
462 
463       // Recursively split up all users of a Phi
464       for (j = n-&gt;outs(); n-&gt;has_out(j); j++) {
465         Node* m = n-&gt;out(j);
466         // If m is dead, throw it away, and declare progress
467         if (_nodes[m-&gt;_idx] == NULL) {
468           _igvn.remove_dead_node(m);
469           // fall through
470         }
471         else if (m != iff &amp;&amp; split_up(m, region, iff)) {
472           // fall through
473         } else {
474           continue;
475         }
476         // Something unpredictable changed.
477         // Tell the iterators to refresh themselves, and rerun the loop.
478         i = region-&gt;refresh_out_pos(i);
479         j = region-&gt;refresh_out_pos(j);
480         progress = true;
481       }
482     }
483   }
484 
485   // Now we have no instructions in the block containing the IF.
486   // Split the IF.
487   Node *new_iff = split_thru_region( iff, region );
488 
489   // Replace both uses of &#39;new_iff&#39; with Regions merging True/False
490   // paths.  This makes &#39;new_iff&#39; go dead.
491   Node *old_false = NULL, *old_true = NULL;
492   Node *new_false = NULL, *new_true = NULL;
493   for (DUIterator_Last j2min, j2 = iff-&gt;last_outs(j2min); j2 &gt;= j2min; --j2) {
494     Node *ifp = iff-&gt;last_out(j2);
495     assert( ifp-&gt;Opcode() == Op_IfFalse || ifp-&gt;Opcode() == Op_IfTrue, &quot;&quot; );
496     ifp-&gt;set_req(0, new_iff);
497     Node *ifpx = split_thru_region( ifp, region );
498 
499     // Replace &#39;If&#39; projection of a Region with a Region of
500     // &#39;If&#39; projections.
501     ifpx-&gt;set_req(0, ifpx);       // A TRUE RegionNode
502 
503     // Setup dominator info
504     set_idom(ifpx, region_dom, dom_depth(region_dom) + 1);
505 
506     // Check for splitting loop tails
507     if( get_loop(iff)-&gt;tail() == ifp )
508       get_loop(iff)-&gt;_tail = ifpx;
509 
510     // Replace in the graph with lazy-update mechanism
511     new_iff-&gt;set_req(0, new_iff); // hook self so it does not go dead
512     lazy_replace(ifp, ifpx);
513     new_iff-&gt;set_req(0, region);
514 
515     // Record bits for later xforms
516     if( ifp-&gt;Opcode() == Op_IfFalse ) {
517       old_false = ifp;
518       new_false = ifpx;
519     } else {
520       old_true = ifp;
521       new_true = ifpx;
522     }
523   }
524   _igvn.remove_dead_node(new_iff);
525   // Lazy replace IDOM info with the region&#39;s dominator
526   lazy_replace(iff, region_dom);
527   lazy_update(region, region_dom); // idom must be update before handle_uses
528   region-&gt;set_req(0, NULL);        // Break the self-cycle. Required for lazy_update to work on region
529 
530   // Now make the original merge point go dead, by handling all its uses.
531   small_cache region_cache;
532   // Preload some control flow in region-cache
533   region_cache.lru_insert( new_false, new_false );
534   region_cache.lru_insert( new_true , new_true  );
535   // Now handle all uses of the splitting block
536   for (DUIterator k = region-&gt;outs(); region-&gt;has_out(k); k++) {
537     Node* phi = region-&gt;out(k);
538     if (!phi-&gt;in(0)) {         // Dead phi?  Remove it
539       _igvn.remove_dead_node(phi);
540     } else if (phi == region) { // Found the self-reference
541       continue;                 // No roll-back of DUIterator
542     } else if (phi-&gt;is_Phi()) { // Expected common case: Phi hanging off of Region
543       assert(phi-&gt;in(0) == region, &quot;Inconsistent graph&quot;);
544       // Need a per-def cache.  Phi represents a def, so make a cache
545       small_cache phi_cache;
546 
547       // Inspect all Phi uses to make the Phi go dead
548       for (DUIterator_Last lmin, l = phi-&gt;last_outs(lmin); l &gt;= lmin; --l) {
549         Node* use = phi-&gt;last_out(l);
550         // Compute the new DEF for this USE.  New DEF depends on the path
551         // taken from the original DEF to the USE.  The new DEF may be some
552         // collection of PHI&#39;s merging values from different paths.  The Phis
553         // inserted depend only on the location of the USE.  We use a
554         // 2-element cache to handle multiple uses from the same block.
555         handle_use(use, phi, &amp;phi_cache, region_dom, new_false, new_true, old_false, old_true);
556       } // End of while phi has uses
557       // Remove the dead Phi
558       _igvn.remove_dead_node( phi );
559     } else {
560       assert(phi-&gt;in(0) == region, &quot;Inconsistent graph&quot;);
561       // Random memory op guarded by Region.  Compute new DEF for USE.
562       handle_use(phi, region, &amp;region_cache, region_dom, new_false, new_true, old_false, old_true);
563     }
564     // Every path above deletes a use of the region, except for the region
565     // self-cycle (which is needed by handle_use calling find_use_block
566     // calling get_ctrl calling get_ctrl_no_update looking for dead
567     // regions).  So roll back the DUIterator innards.
568     --k;
569   } // End of while merge point has phis
570 
571   _igvn.remove_dead_node(region);
572 
573 #ifndef PRODUCT
574   if( VerifyLoopOptimizations ) verify();
575 #endif
576 }
    </pre>
  </body>
</html>
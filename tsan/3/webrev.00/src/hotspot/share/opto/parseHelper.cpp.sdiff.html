<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/parseHelper.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="parse3.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="phase.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/parseHelper.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
218     }
219   }
220 
221   // Come here for polymorphic array klasses
222 
223   // Extract the array element class
224   int element_klass_offset = in_bytes(ObjArrayKlass::element_klass_offset());
225   Node *p2 = basic_plus_adr(array_klass, array_klass, element_klass_offset);
226   // We are allowed to use the constant type only if cast succeeded. If always_see_exact_class is true,
227   // we must set a control edge from the IfTrue node created by the uncommon_trap above to the
228   // LoadKlassNode.
229   Node* a_e_klass = _gvn.transform(LoadKlassNode::make(_gvn, always_see_exact_class ? control() : NULL,
230                                                        immutable_memory(), p2, tak));
231 
232   // Check (the hard way) and throw if not a subklass.
233   // Result is ignored, we just need the CFG effects.
234   gen_checkcast(obj, a_e_klass);
235 }
236 
237 
<span class="line-removed">238 void Parse::emit_guard_for_new(ciInstanceKlass* klass) {</span>
<span class="line-removed">239   // Emit guarded new</span>
<span class="line-removed">240   //   if (klass-&gt;_init_thread != current_thread ||</span>
<span class="line-removed">241   //       klass-&gt;_init_state != being_initialized)</span>
<span class="line-removed">242   //      uncommon_trap</span>
<span class="line-removed">243   Node* cur_thread = _gvn.transform( new ThreadLocalNode() );</span>
<span class="line-removed">244   Node* merge = new RegionNode(3);</span>
<span class="line-removed">245   _gvn.set_type(merge, Type::CONTROL);</span>
<span class="line-removed">246   Node* kls = makecon(TypeKlassPtr::make(klass));</span>
<span class="line-removed">247 </span>
<span class="line-removed">248   Node* init_thread_offset = _gvn.MakeConX(in_bytes(InstanceKlass::init_thread_offset()));</span>
<span class="line-removed">249   Node* adr_node = basic_plus_adr(kls, kls, init_thread_offset);</span>
<span class="line-removed">250   Node* init_thread = make_load(NULL, adr_node, TypeRawPtr::BOTTOM, T_ADDRESS, MemNode::unordered);</span>
<span class="line-removed">251   Node *tst   = Bool( CmpP( init_thread, cur_thread), BoolTest::eq);</span>
<span class="line-removed">252   IfNode* iff = create_and_map_if(control(), tst, PROB_ALWAYS, COUNT_UNKNOWN);</span>
<span class="line-removed">253   set_control(IfTrue(iff));</span>
<span class="line-removed">254   merge-&gt;set_req(1, IfFalse(iff));</span>
<span class="line-removed">255 </span>
<span class="line-removed">256   Node* init_state_offset = _gvn.MakeConX(in_bytes(InstanceKlass::init_state_offset()));</span>
<span class="line-removed">257   adr_node = basic_plus_adr(kls, kls, init_state_offset);</span>
<span class="line-removed">258   // Use T_BOOLEAN for InstanceKlass::_init_state so the compiler</span>
<span class="line-removed">259   // can generate code to load it as unsigned byte.</span>
<span class="line-removed">260   Node* init_state = make_load(NULL, adr_node, TypeInt::UBYTE, T_BOOLEAN, MemNode::unordered);</span>
<span class="line-removed">261   Node* being_init = _gvn.intcon(InstanceKlass::being_initialized);</span>
<span class="line-removed">262   tst   = Bool( CmpI( init_state, being_init), BoolTest::eq);</span>
<span class="line-removed">263   iff = create_and_map_if(control(), tst, PROB_ALWAYS, COUNT_UNKNOWN);</span>
<span class="line-removed">264   set_control(IfTrue(iff));</span>
<span class="line-removed">265   merge-&gt;set_req(2, IfFalse(iff));</span>
<span class="line-removed">266 </span>
<span class="line-removed">267   PreserveJVMState pjvms(this);</span>
<span class="line-removed">268   record_for_igvn(merge);</span>
<span class="line-removed">269   set_control(merge);</span>
<span class="line-removed">270 </span>
<span class="line-removed">271   uncommon_trap(Deoptimization::Reason_uninitialized,</span>
<span class="line-removed">272                 Deoptimization::Action_reinterpret,</span>
<span class="line-removed">273                 klass);</span>
<span class="line-removed">274 }</span>
<span class="line-removed">275 </span>
<span class="line-removed">276 </span>
277 //------------------------------do_new-----------------------------------------
278 void Parse::do_new() {
279   kill_dead_locals();
280 
281   bool will_link;
282   ciInstanceKlass* klass = iter().get_klass(will_link)-&gt;as_instance_klass();
283   assert(will_link, &quot;_new: typeflow responsibility&quot;);
284 
<span class="line-modified">285   // Should initialize, or throw an InstantiationError?</span>
<span class="line-modified">286   if ((!klass-&gt;is_initialized() &amp;&amp; !klass-&gt;is_being_initialized()) ||</span>
<span class="line-removed">287       klass-&gt;is_abstract() || klass-&gt;is_interface() ||</span>
288       klass-&gt;name() == ciSymbol::java_lang_Class() ||
289       iter().is_unresolved_klass()) {
<span class="line-modified">290     uncommon_trap(Deoptimization::Reason_uninitialized,</span>
<span class="line-modified">291                   Deoptimization::Action_reinterpret,</span>
292                   klass);
293     return;
294   }
<span class="line-modified">295   if (klass-&gt;is_being_initialized()) {</span>
<span class="line-modified">296     emit_guard_for_new(klass);</span>


297   }
298 
299   Node* kls = makecon(TypeKlassPtr::make(klass));
300   Node* obj = new_instance(kls);
301 
302   // Push resultant oop onto stack
303   push(obj);
304 
305   // Keep track of whether opportunities exist for StringBuilder
306   // optimizations.
307   if (OptimizeStringConcat &amp;&amp;
308       (klass == C-&gt;env()-&gt;StringBuilder_klass() ||
309        klass == C-&gt;env()-&gt;StringBuffer_klass())) {
310     C-&gt;set_has_stringbuilder(true);
311   }
312 
313   // Keep track of boxed values for EliminateAutoBox optimizations.
314   if (C-&gt;eliminate_boxing() &amp;&amp; klass-&gt;is_box_klass()) {
315     C-&gt;set_has_boxed_value(true);
316   }
</pre>
</td>
<td>
<hr />
<pre>
218     }
219   }
220 
221   // Come here for polymorphic array klasses
222 
223   // Extract the array element class
224   int element_klass_offset = in_bytes(ObjArrayKlass::element_klass_offset());
225   Node *p2 = basic_plus_adr(array_klass, array_klass, element_klass_offset);
226   // We are allowed to use the constant type only if cast succeeded. If always_see_exact_class is true,
227   // we must set a control edge from the IfTrue node created by the uncommon_trap above to the
228   // LoadKlassNode.
229   Node* a_e_klass = _gvn.transform(LoadKlassNode::make(_gvn, always_see_exact_class ? control() : NULL,
230                                                        immutable_memory(), p2, tak));
231 
232   // Check (the hard way) and throw if not a subklass.
233   // Result is ignored, we just need the CFG effects.
234   gen_checkcast(obj, a_e_klass);
235 }
236 
237 







































238 //------------------------------do_new-----------------------------------------
239 void Parse::do_new() {
240   kill_dead_locals();
241 
242   bool will_link;
243   ciInstanceKlass* klass = iter().get_klass(will_link)-&gt;as_instance_klass();
244   assert(will_link, &quot;_new: typeflow responsibility&quot;);
245 
<span class="line-modified">246   // Should throw an InstantiationError?</span>
<span class="line-modified">247   if (klass-&gt;is_abstract() || klass-&gt;is_interface() ||</span>

248       klass-&gt;name() == ciSymbol::java_lang_Class() ||
249       iter().is_unresolved_klass()) {
<span class="line-modified">250     uncommon_trap(Deoptimization::Reason_unhandled,</span>
<span class="line-modified">251                   Deoptimization::Action_none,</span>
252                   klass);
253     return;
254   }
<span class="line-modified">255 </span>
<span class="line-modified">256   if (C-&gt;needs_clinit_barrier(klass, method())) {</span>
<span class="line-added">257     clinit_barrier(klass, method());</span>
<span class="line-added">258     if (stopped())  return;</span>
259   }
260 
261   Node* kls = makecon(TypeKlassPtr::make(klass));
262   Node* obj = new_instance(kls);
263 
264   // Push resultant oop onto stack
265   push(obj);
266 
267   // Keep track of whether opportunities exist for StringBuilder
268   // optimizations.
269   if (OptimizeStringConcat &amp;&amp;
270       (klass == C-&gt;env()-&gt;StringBuilder_klass() ||
271        klass == C-&gt;env()-&gt;StringBuffer_klass())) {
272     C-&gt;set_has_stringbuilder(true);
273   }
274 
275   // Keep track of boxed values for EliminateAutoBox optimizations.
276   if (C-&gt;eliminate_boxing() &amp;&amp; klass-&gt;is_box_klass()) {
277     C-&gt;set_has_boxed_value(true);
278   }
</pre>
</td>
</tr>
</table>
<center><a href="parse3.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="phase.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/parse3.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;compiler/compileLog.hpp&quot;
 27 #include &quot;interpreter/linkResolver.hpp&quot;
 28 #include &quot;memory/universe.hpp&quot;
 29 #include &quot;oops/objArrayKlass.hpp&quot;
 30 #include &quot;opto/addnode.hpp&quot;
 31 #include &quot;opto/castnode.hpp&quot;
 32 #include &quot;opto/memnode.hpp&quot;
 33 #include &quot;opto/parse.hpp&quot;
 34 #include &quot;opto/rootnode.hpp&quot;
 35 #include &quot;opto/runtime.hpp&quot;
 36 #include &quot;opto/subnode.hpp&quot;
 37 #include &quot;runtime/deoptimization.hpp&quot;
 38 #include &quot;runtime/handles.inline.hpp&quot;
 39 
 40 //=============================================================================
 41 // Helper methods for _get* and _put* bytecodes
 42 //=============================================================================
<a name="2" id="anc2"></a><span class="line-removed"> 43 bool Parse::static_field_ok_in_clinit(ciField *field, ciMethod *method) {</span>
<span class="line-removed"> 44   // Could be the field_holder&#39;s &lt;clinit&gt; method, or &lt;clinit&gt; for a subklass.</span>
<span class="line-removed"> 45   // Better to check now than to Deoptimize as soon as we execute</span>
<span class="line-removed"> 46   assert( field-&gt;is_static(), &quot;Only check if field is static&quot;);</span>
<span class="line-removed"> 47   // is_being_initialized() is too generous.  It allows access to statics</span>
<span class="line-removed"> 48   // by threads that are not running the &lt;clinit&gt; before the &lt;clinit&gt; finishes.</span>
<span class="line-removed"> 49   // return field-&gt;holder()-&gt;is_being_initialized();</span>
<span class="line-removed"> 50 </span>
<span class="line-removed"> 51   // The following restriction is correct but conservative.</span>
<span class="line-removed"> 52   // It is also desirable to allow compilation of methods called from &lt;clinit&gt;</span>
<span class="line-removed"> 53   // but this generated code will need to be made safe for execution by</span>
<span class="line-removed"> 54   // other threads, or the transition from interpreted to compiled code would</span>
<span class="line-removed"> 55   // need to be guarded.</span>
<span class="line-removed"> 56   ciInstanceKlass *field_holder = field-&gt;holder();</span>
<span class="line-removed"> 57 </span>
<span class="line-removed"> 58   if (method-&gt;holder()-&gt;is_subclass_of(field_holder)) {</span>
<span class="line-removed"> 59     if (method-&gt;is_static_initializer()) {</span>
<span class="line-removed"> 60       // OK to access static fields inside initializer</span>
<span class="line-removed"> 61       return true;</span>
<span class="line-removed"> 62     } else if (method-&gt;is_object_initializer()) {</span>
<span class="line-removed"> 63       // It&#39;s also OK to access static fields inside a constructor,</span>
<span class="line-removed"> 64       // because any thread calling the constructor must first have</span>
<span class="line-removed"> 65       // synchronized on the class by executing a &#39;_new&#39; bytecode.</span>
<span class="line-removed"> 66       return true;</span>
<span class="line-removed"> 67     }</span>
<span class="line-removed"> 68   }</span>
<span class="line-removed"> 69   if (C-&gt;is_compiling_clinit_for(field_holder)) {</span>
<span class="line-removed"> 70     return true; // access in the context of static initializer</span>
<span class="line-removed"> 71   }</span>
<span class="line-removed"> 72   return false;</span>
<span class="line-removed"> 73 }</span>
<span class="line-removed"> 74 </span>
<span class="line-removed"> 75 </span>
 76 void Parse::do_field_access(bool is_get, bool is_field) {
 77   bool will_link;
 78   ciField* field = iter().get_field(will_link);
 79   assert(will_link, &quot;getfield: typeflow responsibility&quot;);
 80 
 81   ciInstanceKlass* field_holder = field-&gt;holder();
 82 
 83   if (is_field == field-&gt;is_static()) {
 84     // Interpreter will throw java_lang_IncompatibleClassChangeError
 85     // Check this before allowing &lt;clinit&gt; methods to access static fields
 86     uncommon_trap(Deoptimization::Reason_unhandled,
 87                   Deoptimization::Action_none);
 88     return;
 89   }
 90 
<a name="3" id="anc3"></a><span class="line-modified"> 91   if (!is_field &amp;&amp; !field_holder-&gt;is_initialized()) {</span>
<span class="line-modified"> 92     if (!static_field_ok_in_clinit(field, method())) {</span>
<span class="line-modified"> 93       uncommon_trap(Deoptimization::Reason_uninitialized,</span>
<span class="line-removed"> 94                     Deoptimization::Action_reinterpret,</span>
<span class="line-removed"> 95                     NULL, &quot;!static_field_ok_in_clinit&quot;);</span>
<span class="line-removed"> 96       return;</span>
<span class="line-removed"> 97     }</span>
<span class="line-removed"> 98   }</span>
<span class="line-removed"> 99 </span>
<span class="line-removed">100   // Deoptimize on putfield writes to call site target field.</span>
<span class="line-removed">101   if (!is_get &amp;&amp; field-&gt;is_call_site_target()) {</span>
102     uncommon_trap(Deoptimization::Reason_unhandled,
103                   Deoptimization::Action_reinterpret,
104                   NULL, &quot;put to call site target field&quot;);
105     return;
106   }
107 
<a name="4" id="anc4"></a>




108   assert(field-&gt;will_link(method(), bc()), &quot;getfield: typeflow responsibility&quot;);
109 
110   // Note:  We do not check for an unloaded field type here any more.
111 
112   // Generate code for the object pointer.
113   Node* obj;
114   if (is_field) {
115     int obj_depth = is_get ? 0 : field-&gt;type()-&gt;size();
116     obj = null_check(peek(obj_depth));
117     // Compile-time detect of null-exception?
118     if (stopped())  return;
119 
120 #ifdef ASSERT
121     const TypeInstPtr *tjp = TypeInstPtr::make(TypePtr::NotNull, iter().get_declared_field_holder());
122     assert(_gvn.type(obj)-&gt;higher_equal(tjp), &quot;cast_up is no longer needed&quot;);
123 #endif
124 
125     if (is_get) {
126       (void) pop();  // pop receiver before getting
127       do_get_xxx(obj, field, is_field);
128     } else {
129       do_put_xxx(obj, field, is_field);
130       (void) pop();  // pop receiver after putting
131     }
132   } else {
133     const TypeInstPtr* tip = TypeInstPtr::make(field_holder-&gt;java_mirror());
134     obj = _gvn.makecon(tip);
135     if (is_get) {
136       do_get_xxx(obj, field, is_field);
137     } else {
138       do_put_xxx(obj, field, is_field);
139     }
140   }
141 }
142 
143 
144 void Parse::do_get_xxx(Node* obj, ciField* field, bool is_field) {
145   BasicType bt = field-&gt;layout_type();
146 
147   // Does this field have a constant value?  If so, just push the value.
148   if (field-&gt;is_constant() &amp;&amp;
149       // Keep consistent with types found by ciTypeFlow: for an
150       // unloaded field type, ciTypeFlow::StateVector::do_getstatic()
151       // speculates the field is null. The code in the rest of this
152       // method does the same. We must not bypass it and use a non
153       // null constant here.
154       (bt != T_OBJECT || field-&gt;type()-&gt;is_loaded())) {
155     // final or stable field
156     Node* con = make_constant_from_field(field, obj);
157     if (con != NULL) {
158       push_node(field-&gt;layout_type(), con);
159       return;
160     }
161   }
162 
163   ciType* field_klass = field-&gt;type();
164   bool is_vol = field-&gt;is_volatile();
165 
166   // Compute address and memory type.
167   int offset = field-&gt;offset_in_bytes();
168   const TypePtr* adr_type = C-&gt;alias_type(field)-&gt;adr_type();
169   Node *adr = basic_plus_adr(obj, obj, offset);
170 
171   // Build the resultant type of the load
172   const Type *type;
173 
174   bool must_assert_null = false;
175 
176   DecoratorSet decorators = IN_HEAP;
177   decorators |= is_vol ? MO_SEQ_CST : MO_UNORDERED;
178 
<a name="5" id="anc5"></a><span class="line-modified">179   bool is_obj = bt == T_OBJECT || bt == T_ARRAY;</span>
180 
181   if (is_obj) {
182     if (!field-&gt;type()-&gt;is_loaded()) {
183       type = TypeInstPtr::BOTTOM;
184       must_assert_null = true;
185     } else if (field-&gt;is_static_constant()) {
186       // This can happen if the constant oop is non-perm.
187       ciObject* con = field-&gt;constant_value().as_object();
188       // Do not &quot;join&quot; in the previous type; it doesn&#39;t add value,
189       // and may yield a vacuous result if the field is of interface type.
190       if (con-&gt;is_null_object()) {
191         type = TypePtr::NULL_PTR;
192       } else {
193         type = TypeOopPtr::make_from_constant(con)-&gt;isa_oopptr();
194       }
195       assert(type != NULL, &quot;field singleton type must be consistent&quot;);
196     } else {
197       type = TypeOopPtr::make_from_klass(field_klass-&gt;as_klass());
198     }
199   } else {
200     type = Type::get_const_basic_type(bt);
201   }
202 
203   Node* ld = access_load_at(obj, adr, adr_type, type, bt, decorators);
204 
205   // Adjust Java stack
206   if (type2size[bt] == 1)
207     push(ld);
208   else
209     push_pair(ld);
210 
211   if (must_assert_null) {
212     // Do not take a trap here.  It&#39;s possible that the program
213     // will never load the field&#39;s class, and will happily see
214     // null values in this field forever.  Don&#39;t stumble into a
215     // trap for such a program, or we might get a long series
216     // of useless recompilations.  (Or, we might load a class
217     // which should not be loaded.)  If we ever see a non-null
218     // value, we will then trap and recompile.  (The trap will
219     // not need to mention the class index, since the class will
220     // already have been loaded if we ever see a non-null value.)
221     // uncommon_trap(iter().get_field_signature_index());
222     if (PrintOpto &amp;&amp; (Verbose || WizardMode)) {
223       method()-&gt;print_name(); tty-&gt;print_cr(&quot; asserting nullness of field at bci: %d&quot;, bci());
224     }
225     if (C-&gt;log() != NULL) {
226       C-&gt;log()-&gt;elem(&quot;assert_null reason=&#39;field&#39; klass=&#39;%d&#39;&quot;,
227                      C-&gt;log()-&gt;identify(field-&gt;type()));
228     }
229     // If there is going to be a trap, put it at the next bytecode:
230     set_bci(iter().next_bci());
231     null_assert(peek());
232     set_bci(iter().cur_bci()); // put it back
233   }
234 }
235 
236 void Parse::do_put_xxx(Node* obj, ciField* field, bool is_field) {
237   bool is_vol = field-&gt;is_volatile();
238 
239   // Compute address and memory type.
240   int offset = field-&gt;offset_in_bytes();
241   const TypePtr* adr_type = C-&gt;alias_type(field)-&gt;adr_type();
242   Node* adr = basic_plus_adr(obj, obj, offset);
243   BasicType bt = field-&gt;layout_type();
244   // Value to be stored
245   Node* val = type2size[bt] == 1 ? pop() : pop_pair();
246 
247   DecoratorSet decorators = IN_HEAP;
248   decorators |= is_vol ? MO_SEQ_CST : MO_UNORDERED;
249 
<a name="6" id="anc6"></a><span class="line-modified">250   bool is_obj = bt == T_OBJECT || bt == T_ARRAY;</span>
251 
252   // Store the value.
253   const Type* field_type;
254   if (!field-&gt;type()-&gt;is_loaded()) {
255     field_type = TypeInstPtr::BOTTOM;
256   } else {
257     if (is_obj) {
258       field_type = TypeOopPtr::make_from_klass(field-&gt;type()-&gt;as_klass());
259     } else {
260       field_type = Type::BOTTOM;
261     }
262   }
263   access_store_at(obj, adr, adr_type, val, field_type, bt, decorators);
264 
265   if (is_field) {
266     // Remember we wrote a volatile field.
267     // For not multiple copy atomic cpu (ppc64) a barrier should be issued
268     // in constructors which have such stores. See do_exits() in parse1.cpp.
269     if (is_vol) {
270       set_wrote_volatile(true);
271     }
272     set_wrote_fields(true);
273 
274     // If the field is final, the rules of Java say we are in &lt;init&gt; or &lt;clinit&gt;.
275     // Note the presence of writes to final non-static fields, so that we
276     // can insert a memory barrier later on to keep the writes from floating
277     // out of the constructor.
278     // Any method can write a @Stable field; insert memory barriers after those also.
279     if (field-&gt;is_final()) {
280       set_wrote_final(true);
281       if (AllocateNode::Ideal_allocation(obj, &amp;_gvn) != NULL) {
282         // Preserve allocation ptr to create precedent edge to it in membar
283         // generated on exit from constructor.
284         // Can&#39;t bind stable with its allocation, only record allocation for final field.
285         set_alloc_with_final(obj);
286       }
287     }
288     if (field-&gt;is_stable()) {
289       set_wrote_stable(true);
290     }
291   }
292 }
293 
294 //=============================================================================
295 void Parse::do_anewarray() {
296   bool will_link;
297   ciKlass* klass = iter().get_klass(will_link);
298 
299   // Uncommon Trap when class that array contains is not loaded
300   // we need the loaded class for the rest of graph; do not
301   // initialize the container class (see Java spec)!!!
302   assert(will_link, &quot;anewarray: typeflow responsibility&quot;);
303 
304   ciObjArrayKlass* array_klass = ciObjArrayKlass::make(klass);
305   // Check that array_klass object is loaded
306   if (!array_klass-&gt;is_loaded()) {
307     // Generate uncommon_trap for unloaded array_class
308     uncommon_trap(Deoptimization::Reason_unloaded,
309                   Deoptimization::Action_reinterpret,
310                   array_klass);
311     return;
312   }
313 
314   kill_dead_locals();
315 
316   const TypeKlassPtr* array_klass_type = TypeKlassPtr::make(array_klass);
317   Node* count_val = pop();
318   Node* obj = new_array(makecon(array_klass_type), count_val, 1);
319   push(obj);
320 }
321 
322 
323 void Parse::do_newarray(BasicType elem_type) {
324   kill_dead_locals();
325 
326   Node*   count_val = pop();
327   const TypeKlassPtr* array_klass = TypeKlassPtr::make(ciTypeArrayKlass::make(elem_type));
328   Node*   obj = new_array(makecon(array_klass), count_val, 1);
329   // Push resultant oop onto stack
330   push(obj);
331 }
332 
333 // Expand simple expressions like new int[3][5] and new Object[2][nonConLen].
334 // Also handle the degenerate 1-dimensional case of anewarray.
335 Node* Parse::expand_multianewarray(ciArrayKlass* array_klass, Node* *lengths, int ndimensions, int nargs) {
336   Node* length = lengths[0];
337   assert(length != NULL, &quot;&quot;);
338   Node* array = new_array(makecon(TypeKlassPtr::make(array_klass)), length, nargs);
339   if (ndimensions &gt; 1) {
340     jint length_con = find_int_con(length, -1);
341     guarantee(length_con &gt;= 0, &quot;non-constant multianewarray&quot;);
342     ciArrayKlass* array_klass_1 = array_klass-&gt;as_obj_array_klass()-&gt;element_klass()-&gt;as_array_klass();
343     const TypePtr* adr_type = TypeAryPtr::OOPS;
344     const TypeOopPtr*    elemtype = _gvn.type(array)-&gt;is_aryptr()-&gt;elem()-&gt;make_oopptr();
345     const intptr_t header   = arrayOopDesc::base_offset_in_bytes(T_OBJECT);
346     for (jint i = 0; i &lt; length_con; i++) {
347       Node*    elem   = expand_multianewarray(array_klass_1, &amp;lengths[1], ndimensions-1, nargs);
348       intptr_t offset = header + ((intptr_t)i &lt;&lt; LogBytesPerHeapOop);
349       Node*    eaddr  = basic_plus_adr(array, offset);
350       access_store_at(array, eaddr, adr_type, elem, elemtype, T_OBJECT, IN_HEAP | IS_ARRAY);
351     }
352   }
353   return array;
354 }
355 
356 void Parse::do_multianewarray() {
357   int ndimensions = iter().get_dimensions();
358 
359   // the m-dimensional array
360   bool will_link;
361   ciArrayKlass* array_klass = iter().get_klass(will_link)-&gt;as_array_klass();
362   assert(will_link, &quot;multianewarray: typeflow responsibility&quot;);
363 
364   // Note:  Array classes are always initialized; no is_initialized check.
365 
366   kill_dead_locals();
367 
368   // get the lengths from the stack (first dimension is on top)
369   Node** length = NEW_RESOURCE_ARRAY(Node*, ndimensions + 1);
370   length[ndimensions] = NULL;  // terminating null for make_runtime_call
371   int j;
372   for (j = ndimensions-1; j &gt;= 0 ; j--) length[j] = pop();
373 
374   // The original expression was of this form: new T[length0][length1]...
375   // It is often the case that the lengths are small (except the last).
376   // If that happens, use the fast 1-d creator a constant number of times.
377   const int expand_limit = MIN2((int)MultiArrayExpandLimit, 100);
378   int expand_count = 1;        // count of allocations in the expansion
379   int expand_fanout = 1;       // running total fanout
380   for (j = 0; j &lt; ndimensions-1; j++) {
381     int dim_con = find_int_con(length[j], -1);
382     expand_fanout *= dim_con;
383     expand_count  += expand_fanout; // count the level-J sub-arrays
384     if (dim_con &lt;= 0
385         || dim_con &gt; expand_limit
386         || expand_count &gt; expand_limit) {
387       expand_count = 0;
388       break;
389     }
390   }
391 
392   // Can use multianewarray instead of [a]newarray if only one dimension,
393   // or if all non-final dimensions are small constants.
394   if (ndimensions == 1 || (1 &lt;= expand_count &amp;&amp; expand_count &lt;= expand_limit)) {
395     Node* obj = NULL;
396     // Set the original stack and the reexecute bit for the interpreter
397     // to reexecute the multianewarray bytecode if deoptimization happens.
398     // Do it unconditionally even for one dimension multianewarray.
399     // Note: the reexecute bit will be set in GraphKit::add_safepoint_edges()
400     // when AllocateArray node for newarray is created.
401     { PreserveReexecuteState preexecs(this);
402       inc_sp(ndimensions);
403       // Pass 0 as nargs since uncommon trap code does not need to restore stack.
404       obj = expand_multianewarray(array_klass, &amp;length[0], ndimensions, 0);
405     } //original reexecute and sp are set back here
406     push(obj);
407     return;
408   }
409 
410   address fun = NULL;
411   switch (ndimensions) {
412   case 1: ShouldNotReachHere(); break;
413   case 2: fun = OptoRuntime::multianewarray2_Java(); break;
414   case 3: fun = OptoRuntime::multianewarray3_Java(); break;
415   case 4: fun = OptoRuntime::multianewarray4_Java(); break;
416   case 5: fun = OptoRuntime::multianewarray5_Java(); break;
417   };
418   Node* c = NULL;
419 
420   if (fun != NULL) {
421     c = make_runtime_call(RC_NO_LEAF | RC_NO_IO,
422                           OptoRuntime::multianewarray_Type(ndimensions),
423                           fun, NULL, TypeRawPtr::BOTTOM,
424                           makecon(TypeKlassPtr::make(array_klass)),
425                           length[0], length[1], length[2],
426                           (ndimensions &gt; 2) ? length[3] : NULL,
427                           (ndimensions &gt; 3) ? length[4] : NULL);
428   } else {
429     // Create a java array for dimension sizes
430     Node* dims = NULL;
431     { PreserveReexecuteState preexecs(this);
432       inc_sp(ndimensions);
433       Node* dims_array_klass = makecon(TypeKlassPtr::make(ciArrayKlass::make(ciType::make(T_INT))));
434       dims = new_array(dims_array_klass, intcon(ndimensions), 0);
435 
436       // Fill-in it with values
437       for (j = 0; j &lt; ndimensions; j++) {
438         Node *dims_elem = array_element_address(dims, intcon(j), T_INT);
439         store_to_memory(control(), dims_elem, length[j], T_INT, TypeAryPtr::INTS, MemNode::unordered);
440       }
441     }
442 
443     c = make_runtime_call(RC_NO_LEAF | RC_NO_IO,
444                           OptoRuntime::multianewarrayN_Type(),
445                           OptoRuntime::multianewarrayN_Java(), NULL, TypeRawPtr::BOTTOM,
446                           makecon(TypeKlassPtr::make(array_klass)),
447                           dims);
448   }
449   make_slow_call_ex(c, env()-&gt;Throwable_klass(), false);
450 
451   Node* res = _gvn.transform(new ProjNode(c, TypeFunc::Parms));
452 
453   const Type* type = TypeOopPtr::make_from_klass_raw(array_klass);
454 
455   // Improve the type:  We know it&#39;s not null, exact, and of a given length.
456   type = type-&gt;is_ptr()-&gt;cast_to_ptr_type(TypePtr::NotNull);
457   type = type-&gt;is_aryptr()-&gt;cast_to_exactness(true);
458 
459   const TypeInt* ltype = _gvn.find_int_type(length[0]);
460   if (ltype != NULL)
461     type = type-&gt;is_aryptr()-&gt;cast_to_size(ltype);
462 
463     // We cannot sharpen the nested sub-arrays, since the top level is mutable.
464 
465   Node* cast = _gvn.transform( new CheckCastPPNode(control(), res, type) );
466   push(cast);
467 
468   // Possible improvements:
469   // - Make a fast path for small multi-arrays.  (W/ implicit init. loops.)
470   // - Issue CastII against length[*] values, to TypeInt::POS.
471 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
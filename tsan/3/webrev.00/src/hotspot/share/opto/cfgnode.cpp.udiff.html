<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/opto/cfgnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="castnode.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="cfgnode.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/cfgnode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -881,11 +881,11 @@</span>
  // note that these functions assume that the _adr_type field is flattened
  uint PhiNode::hash() const {
    const Type* at = _adr_type;
    return TypeNode::hash() + (at ? at-&gt;hash() : 0);
  }
<span class="udiff-line-modified-removed">- uint PhiNode::cmp( const Node &amp;n ) const {</span>
<span class="udiff-line-modified-added">+ bool PhiNode::cmp( const Node &amp;n ) const {</span>
    return TypeNode::cmp(n) &amp;&amp; _adr_type == ((PhiNode&amp;)n)._adr_type;
  }
  static inline
  const TypePtr* flatten_phi_adr_type(const TypePtr* at) {
    if (at == NULL || at == TypePtr::BOTTOM)  return at;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1447,14 +1447,11 @@</span>
    } else if( b-&gt;_test._test == BoolTest::eq ) {
      flipped = 1-flipped;
    } else return NULL;
  
    // Build int-&gt;bool conversion
<span class="udiff-line-modified-removed">-   Node *in1 = cmp-&gt;in(1);</span>
<span class="udiff-line-removed">-   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="udiff-line-removed">-   in1 = bs-&gt;step_over_gc_barrier(in1);</span>
<span class="udiff-line-removed">-   Node *n = new Conv2BNode(in1);</span>
<span class="udiff-line-modified-added">+   Node *n = new Conv2BNode(cmp-&gt;in(1));</span>
    if( flipped )
      n = new XorINode( phase-&gt;transform(n), phase-&gt;intcon(1) );
  
    return n;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1876,16 +1873,17 @@</span>
      if (uncasted) {
        // Add cast nodes between the phi to be removed and its unique input.
        // Wait until after parsing for the type information to propagate from the casts.
        assert(can_reshape, &quot;Invalid during parsing&quot;);
        const Type* phi_type = bottom_type();
<span class="udiff-line-modified-removed">-       assert(phi_type-&gt;isa_int() || phi_type-&gt;isa_ptr(), &quot;bad phi type&quot;);</span>
<span class="udiff-line-modified-removed">-       // Add casts to carry the control dependency of the Phi that is</span>
<span class="udiff-line-removed">-       // going away</span>
<span class="udiff-line-modified-added">+       assert(phi_type-&gt;isa_int() || phi_type-&gt;isa_long() || phi_type-&gt;isa_ptr(), &quot;bad phi type&quot;);</span>
<span class="udiff-line-modified-added">+       // Add casts to carry the control dependency of the Phi that is going away</span>
        Node* cast = NULL;
        if (phi_type-&gt;isa_int()) {
          cast = ConstraintCastNode::make_cast(Op_CastII, r, uin, phi_type, true);
<span class="udiff-line-added">+       } else if (phi_type-&gt;isa_long()) {</span>
<span class="udiff-line-added">+         cast = ConstraintCastNode::make_cast(Op_CastLL, r, uin, phi_type, true);</span>
        } else {
          const Type* uin_type = phase-&gt;type(uin);
          if (!phi_type-&gt;isa_oopptr() &amp;&amp; !uin_type-&gt;isa_oopptr()) {
            cast = ConstraintCastNode::make_cast(Op_CastPP, r, uin, phi_type, true);
          } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1990,38 +1988,57 @@</span>
      if (opt != NULL)  return opt;
    }
  
    if (in(1) != NULL &amp;&amp; in(1)-&gt;Opcode() == Op_AddP &amp;&amp; can_reshape) {
      // Try to undo Phi of AddP:
<span class="udiff-line-modified-removed">-     // (Phi (AddP base base y) (AddP base2 base2 y))</span>
<span class="udiff-line-modified-added">+     // (Phi (AddP base address offset) (AddP base2 address2 offset2))</span>
      // becomes:
      // newbase := (Phi base base2)
<span class="udiff-line-modified-removed">-     // (AddP newbase newbase y)</span>
<span class="udiff-line-modified-added">+     // newaddress := (Phi address address2)</span>
<span class="udiff-line-added">+     // newoffset := (Phi offset offset2)</span>
<span class="udiff-line-added">+     // (AddP newbase newaddress newoffset)</span>
      //
      // This occurs as a result of unsuccessful split_thru_phi and
      // interferes with taking advantage of addressing modes. See the
      // clone_shift_expressions code in matcher.cpp
      Node* addp = in(1);
<span class="udiff-line-modified-removed">-     const Type* type = addp-&gt;in(AddPNode::Base)-&gt;bottom_type();</span>
<span class="udiff-line-modified-removed">-     Node* y = addp-&gt;in(AddPNode::Offset);</span>
<span class="udiff-line-modified-removed">-     if (y != NULL &amp;&amp; addp-&gt;in(AddPNode::Base) == addp-&gt;in(AddPNode::Address)) {</span>
<span class="udiff-line-modified-added">+     Node* base = addp-&gt;in(AddPNode::Base);</span>
<span class="udiff-line-modified-added">+     Node* address = addp-&gt;in(AddPNode::Address);</span>
<span class="udiff-line-modified-added">+     Node* offset = addp-&gt;in(AddPNode::Offset);</span>
<span class="udiff-line-added">+     if (base != NULL &amp;&amp; address != NULL &amp;&amp; offset != NULL &amp;&amp;</span>
<span class="udiff-line-added">+         !base-&gt;is_top() &amp;&amp; !address-&gt;is_top() &amp;&amp; !offset-&gt;is_top()) {</span>
<span class="udiff-line-added">+       const Type* base_type = base-&gt;bottom_type();</span>
<span class="udiff-line-added">+       const Type* address_type = address-&gt;bottom_type();</span>
        // make sure that all the inputs are similar to the first one,
        // i.e. AddP with base == address and same offset as first AddP
        bool doit = true;
        for (uint i = 2; i &lt; req(); i++) {
          if (in(i) == NULL ||
              in(i)-&gt;Opcode() != Op_AddP ||
<span class="udiff-line-modified-removed">-             in(i)-&gt;in(AddPNode::Base) != in(i)-&gt;in(AddPNode::Address) ||</span>
<span class="udiff-line-modified-removed">-             in(i)-&gt;in(AddPNode::Offset) != y) {</span>
<span class="udiff-line-modified-added">+             in(i)-&gt;in(AddPNode::Base) == NULL ||</span>
<span class="udiff-line-modified-added">+             in(i)-&gt;in(AddPNode::Address) == NULL ||</span>
<span class="udiff-line-added">+             in(i)-&gt;in(AddPNode::Offset) == NULL ||</span>
<span class="udiff-line-added">+             in(i)-&gt;in(AddPNode::Base)-&gt;is_top() ||</span>
<span class="udiff-line-added">+             in(i)-&gt;in(AddPNode::Address)-&gt;is_top() ||</span>
<span class="udiff-line-added">+             in(i)-&gt;in(AddPNode::Offset)-&gt;is_top()) {</span>
            doit = false;
            break;
          }
<span class="udiff-line-added">+         if (in(i)-&gt;in(AddPNode::Offset) != base) {</span>
<span class="udiff-line-added">+           base = NULL;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (in(i)-&gt;in(AddPNode::Offset) != offset) {</span>
<span class="udiff-line-added">+           offset = NULL;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (in(i)-&gt;in(AddPNode::Address) != address) {</span>
<span class="udiff-line-added">+           address = NULL;</span>
<span class="udiff-line-added">+         }</span>
          // Accumulate type for resulting Phi
<span class="udiff-line-modified-removed">-         type = type-&gt;meet_speculative(in(i)-&gt;in(AddPNode::Base)-&gt;bottom_type());</span>
<span class="udiff-line-modified-added">+         base_type = base_type-&gt;meet_speculative(in(i)-&gt;in(AddPNode::Base)-&gt;bottom_type());</span>
<span class="udiff-line-added">+         address_type = address_type-&gt;meet_speculative(in(i)-&gt;in(AddPNode::Base)-&gt;bottom_type());</span>
        }
<span class="udiff-line-modified-removed">-       Node* base = NULL;</span>
<span class="udiff-line-removed">-       if (doit) {</span>
<span class="udiff-line-modified-added">+       if (doit &amp;&amp; base == NULL) {</span>
          // Check for neighboring AddP nodes in a tree.
          // If they have a base, use that it.
          for (DUIterator_Fast kmax, k = this-&gt;fast_outs(kmax); k &lt; kmax; k++) {
            Node* u = this-&gt;fast_out(k);
            if (u-&gt;is_AddP()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2035,17 +2052,31 @@</span>
            }
          }
        }
        if (doit) {
          if (base == NULL) {
<span class="udiff-line-modified-removed">-           base = new PhiNode(in(0), type, NULL);</span>
<span class="udiff-line-modified-added">+           base = new PhiNode(in(0), base_type, NULL);</span>
            for (uint i = 1; i &lt; req(); i++) {
              base-&gt;init_req(i, in(i)-&gt;in(AddPNode::Base));
            }
            phase-&gt;is_IterGVN()-&gt;register_new_node_with_optimizer(base);
          }
<span class="udiff-line-modified-removed">-         return new AddPNode(base, base, y);</span>
<span class="udiff-line-modified-added">+         if (address == NULL) {</span>
<span class="udiff-line-added">+           address = new PhiNode(in(0), address_type, NULL);</span>
<span class="udiff-line-added">+           for (uint i = 1; i &lt; req(); i++) {</span>
<span class="udiff-line-added">+             address-&gt;init_req(i, in(i)-&gt;in(AddPNode::Address));</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+           phase-&gt;is_IterGVN()-&gt;register_new_node_with_optimizer(address);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (offset == NULL) {</span>
<span class="udiff-line-added">+           offset = new PhiNode(in(0), TypeX_X, NULL);</span>
<span class="udiff-line-added">+           for (uint i = 1; i &lt; req(); i++) {</span>
<span class="udiff-line-added">+             offset-&gt;init_req(i, in(i)-&gt;in(AddPNode::Offset));</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+           phase-&gt;is_IterGVN()-&gt;register_new_node_with_optimizer(offset);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return new AddPNode(base, address, offset);</span>
        }
      }
    }
  
    // Split phis through memory merges, so that the memory merges will go away.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2351,11 +2382,11 @@</span>
  
  
  //=============================================================================
  
  uint PCTableNode::hash() const { return Node::hash() + _size; }
<span class="udiff-line-modified-removed">- uint PCTableNode::cmp( const Node &amp;n ) const</span>
<span class="udiff-line-modified-added">+ bool PCTableNode::cmp( const Node &amp;n ) const</span>
  { return _size == ((PCTableNode&amp;)n)._size; }
  
  const Type *PCTableNode::bottom_type() const {
    const Type** f = TypeTuple::fields(_size);
    for( uint i = 0; i &lt; _size; i++ ) f[i] = Type::CONTROL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2381,11 +2412,11 @@</span>
  //=============================================================================
  uint JumpProjNode::hash() const {
    return Node::hash() + _dest_bci;
  }
  
<span class="udiff-line-modified-removed">- uint JumpProjNode::cmp( const Node &amp;n ) const {</span>
<span class="udiff-line-modified-added">+ bool JumpProjNode::cmp( const Node &amp;n ) const {</span>
    return ProjNode::cmp(n) &amp;&amp;
      _dest_bci == ((JumpProjNode&amp;)n)._dest_bci;
  }
  
  #ifndef PRODUCT
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2444,11 +2475,11 @@</span>
  uint CatchProjNode::hash() const {
    return Node::hash() + _handler_bci;
  }
  
  
<span class="udiff-line-modified-removed">- uint CatchProjNode::cmp( const Node &amp;n ) const {</span>
<span class="udiff-line-modified-added">+ bool CatchProjNode::cmp( const Node &amp;n ) const {</span>
    return ProjNode::cmp(n) &amp;&amp;
      _handler_bci == ((CatchProjNode&amp;)n)._handler_bci;
  }
  
  
</pre>
<center><a href="castnode.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="cfgnode.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/arraycopynode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="addnode.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="arraycopynode.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/arraycopynode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 28,10 ***</span>
<span class="line-new-header">--- 28,11 ---</span>
  #include &quot;gc/shared/c2/cardTableBarrierSetC2.hpp&quot;
  #include &quot;opto/arraycopynode.hpp&quot;
  #include &quot;opto/graphKit.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
<span class="line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  ArrayCopyNode::ArrayCopyNode(Compile* C, bool alloc_tightly_coupled, bool has_negative_length_guard)
    : CallNode(arraycopy_type(), NULL, TypePtr::BOTTOM),
      _kind(None),
      _alloc_tightly_coupled(alloc_tightly_coupled),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 134,11 ***</span>
        // cloning an array we&#39;ll do it element by element. If the
        // length input to ArrayCopyNode is constant, length of input
        // array must be too.
  
        assert((get_length_if_constant(phase) == -1) == !ary_src-&gt;size()-&gt;is_con() ||
<span class="line-modified">!              phase-&gt;is_IterGVN(), &quot;inconsistent&quot;);</span>
  
        if (ary_src-&gt;size()-&gt;is_con()) {
          return ary_src-&gt;size()-&gt;get_con();
        }
        return -1;
<span class="line-new-header">--- 135,11 ---</span>
        // cloning an array we&#39;ll do it element by element. If the
        // length input to ArrayCopyNode is constant, length of input
        // array must be too.
  
        assert((get_length_if_constant(phase) == -1) == !ary_src-&gt;size()-&gt;is_con() ||
<span class="line-modified">!              phase-&gt;is_IterGVN() || StressReflectiveCode, &quot;inconsistent&quot;);</span>
  
        if (ary_src-&gt;size()-&gt;is_con()) {
          return ary_src-&gt;size()-&gt;get_con();
        }
        return -1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 266,12 ***</span>
        return false;
      }
  
      BasicType src_elem  = ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
      BasicType dest_elem = ary_dest-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
<span class="line-modified">!     if (src_elem  == T_ARRAY)  src_elem  = T_OBJECT;</span>
<span class="line-modified">!     if (dest_elem == T_ARRAY)  dest_elem = T_OBJECT;</span>
  
      if (src_elem != dest_elem || dest_elem == T_VOID) {
        // We don&#39;t know if arguments are arrays of the same type
        return false;
      }
<span class="line-new-header">--- 267,12 ---</span>
        return false;
      }
  
      BasicType src_elem  = ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
      BasicType dest_elem = ary_dest-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
<span class="line-modified">!     if (is_reference_type(src_elem))   src_elem  = T_OBJECT;</span>
<span class="line-modified">!     if (is_reference_type(dest_elem))  dest_elem = T_OBJECT;</span>
  
      if (src_elem != dest_elem || dest_elem == T_VOID) {
        // We don&#39;t know if arguments are arrays of the same type
        return false;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 294,10 ***</span>
<span class="line-new-header">--- 295,14 ---</span>
      adr_src = src;
      adr_dest = dest;
  
      src_offset = Compile::conv_I2X_index(phase, src_offset, ary_src-&gt;size());
      dest_offset = Compile::conv_I2X_index(phase, dest_offset, ary_dest-&gt;size());
<span class="line-added">+     if (src_offset-&gt;is_top() || dest_offset-&gt;is_top()) {</span>
<span class="line-added">+       // Offset is out of bounds (the ArrayCopyNode will be removed)</span>
<span class="line-added">+       return false;</span>
<span class="line-added">+     }</span>
  
      Node* src_scale = phase-&gt;transform(new LShiftXNode(src_offset, phase-&gt;intcon(shift)));
      Node* dest_scale = phase-&gt;transform(new LShiftXNode(dest_offset, phase-&gt;intcon(shift)));
  
      adr_src = phase-&gt;transform(new AddPNode(base_src, adr_src, src_scale));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 322,11 ***</span>
      adr_dest = dest;
      base_dest = dest-&gt;in(AddPNode::Base);
  
      assert(phase-&gt;type(src-&gt;in(AddPNode::Offset))-&gt;is_intptr_t()-&gt;get_con() == phase-&gt;type(dest-&gt;in(AddPNode::Offset))-&gt;is_intptr_t()-&gt;get_con(), &quot;same start offset?&quot;);
      BasicType elem = ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
<span class="line-modified">!     if (elem == T_ARRAY)  elem = T_OBJECT;</span>
  
      BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
      if (bs-&gt;array_copy_requires_gc_barriers(true, elem, true, BarrierSetC2::Optimization)) {
        return false;
      }
<span class="line-new-header">--- 327,11 ---</span>
      adr_dest = dest;
      base_dest = dest-&gt;in(AddPNode::Base);
  
      assert(phase-&gt;type(src-&gt;in(AddPNode::Offset))-&gt;is_intptr_t()-&gt;get_con() == phase-&gt;type(dest-&gt;in(AddPNode::Offset))-&gt;is_intptr_t()-&gt;get_con(), &quot;same start offset?&quot;);
      BasicType elem = ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
<span class="line-modified">!     if (is_reference_type(elem))  elem = T_OBJECT;</span>
  
      BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
      if (bs-&gt;array_copy_requires_gc_barriers(true, elem, true, BarrierSetC2::Optimization)) {
        return false;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 342,17 ***</span>
      value_type = ary_src-&gt;elem();
    }
    return true;
  }
  
<span class="line-modified">! const TypePtr* ArrayCopyNode::get_address_type(PhaseGVN *phase, Node* n) {</span>
<span class="line-modified">!   const Type* at = phase-&gt;type(n);</span>
<span class="line-modified">!   assert(at != Type::TOP, &quot;unexpected type&quot;);</span>
<span class="line-modified">!   const TypePtr* atp = at-&gt;isa_ptr();</span>
    // adjust atp to be the correct array element address type
<span class="line-modified">!   atp = atp-&gt;add_offset(Type::OffsetBot);</span>
<span class="line-removed">-   return atp;</span>
  }
  
  void ArrayCopyNode::array_copy_test_overlap(PhaseGVN *phase, bool can_reshape, bool disjoint_bases, int count, Node*&amp; forward_ctl, Node*&amp; backward_ctl) {
    Node* ctl = in(TypeFunc::Control);
    if (!disjoint_bases &amp;&amp; count &gt; 1) {
<span class="line-new-header">--- 347,16 ---</span>
      value_type = ary_src-&gt;elem();
    }
    return true;
  }
  
<span class="line-modified">! const TypePtr* ArrayCopyNode::get_address_type(PhaseGVN* phase, const TypePtr* atp, Node* n) {</span>
<span class="line-modified">!   if (atp == TypeOopPtr::BOTTOM) {</span>
<span class="line-modified">!     atp = phase-&gt;type(n)-&gt;isa_ptr();</span>
<span class="line-modified">!   }</span>
    // adjust atp to be the correct array element address type
<span class="line-modified">!   return atp-&gt;add_offset(Type::OffsetBot);</span>
  }
  
  void ArrayCopyNode::array_copy_test_overlap(PhaseGVN *phase, bool can_reshape, bool disjoint_bases, int count, Node*&amp; forward_ctl, Node*&amp; backward_ctl) {
    Node* ctl = in(TypeFunc::Control);
    if (!disjoint_bases &amp;&amp; count &gt; 1) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 568,12 ***</span>
      return NULL;
    }
  
    Node* src = in(ArrayCopyNode::Src);
    Node* dest = in(ArrayCopyNode::Dest);
<span class="line-modified">!   const TypePtr* atp_src = get_address_type(phase, src);</span>
<span class="line-modified">!   const TypePtr* atp_dest = get_address_type(phase, dest);</span>
  
    Node *in_mem = in(TypeFunc::Memory);
    if (!in_mem-&gt;is_MergeMem()) {
      in_mem = MergeMemNode::make(in_mem);
    }
<span class="line-new-header">--- 572,12 ---</span>
      return NULL;
    }
  
    Node* src = in(ArrayCopyNode::Src);
    Node* dest = in(ArrayCopyNode::Dest);
<span class="line-modified">!   const TypePtr* atp_src = get_address_type(phase, _src_type, src);</span>
<span class="line-modified">!   const TypePtr* atp_dest = get_address_type(phase, _dest_type, dest);</span>
  
    Node *in_mem = in(TypeFunc::Memory);
    if (!in_mem-&gt;is_MergeMem()) {
      in_mem = MergeMemNode::make(in_mem);
    }
</pre>
<center><a href="addnode.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="arraycopynode.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/phaseX.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="phaseX.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="phasetype.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/phaseX.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 74   void   check_grow() {
 75     _inserts++;
 76     if( _inserts == _insert_limit ) { grow(); }
 77     assert( _inserts &lt;= _insert_limit, &quot;hash table overflow&quot;);
 78     assert( _inserts &lt; _max, &quot;hash table overflow&quot; );
 79   }
 80   static uint round_up(uint);   // Round up to nearest power of 2
 81   void   grow();                // Grow _table to next power of 2 and rehash
 82   // Return 75% of _max, rounded up.
 83   uint   insert_limit() const { return _max - (_max&gt;&gt;2); }
 84 
 85   void   clear();               // Set all entries to NULL, keep storage.
 86   // Size of hash table
 87   uint   size()         const { return _max; }
 88   // Return Node* at index in table
 89   Node  *at(uint table_index) {
 90     assert(table_index &lt; _max, &quot;Must be within table&quot;);
 91     return _table[table_index];
 92   }
 93 
<span class="line-modified"> 94   void   remove_useless_nodes(VectorSet &amp;useful); // replace with sentinel</span>
 95   void   replace_with(NodeHash* nh);
 96   void   check_no_speculative_types(); // Check no speculative part for type nodes in table
 97 
 98   Node  *sentinel() { return _sentinel; }
 99 
100 #ifndef PRODUCT
101   Node  *find_index(uint idx);  // For debugging
102   void   dump();                // For debugging, dump statistics
103   uint   _grows;                // For debugging, count of table grow()s
104   uint   _look_probes;          // For debugging, count of hash probes
105   uint   _lookup_hits;          // For debugging, count of hash_finds
106   uint   _lookup_misses;        // For debugging, count of hash_finds
107   uint   _insert_probes;        // For debugging, count of hash probes
108   uint   _delete_probes;        // For debugging, count of hash probes for deletes
109   uint   _delete_hits;          // For debugging, count of hash probes for deletes
110   uint   _delete_misses;        // For debugging, count of hash probes for deletes
111   uint   _total_inserts;        // For debugging, total inserts into hash table
112   uint   _total_insert_probes;  // For debugging, total probes while inserting
113 #endif
114 };
</pre>
<hr />
<pre>
360   uint   _count_transforms;     // For profiling, count transforms performed
361   void   set_transforms()      { ++_count_transforms; }
362   void   clear_transforms()    { _count_transforms = 0; }
363   uint   made_transforms() const{ return _count_transforms; }
364 
365   bool   _allow_progress;      // progress not allowed during verification pass
366   void   set_allow_progress(bool allow) { _allow_progress = allow; }
367   bool   allow_progress()               { return _allow_progress; }
368 #endif
369 };
370 
371 //------------------------------PhaseValues------------------------------------
372 // Phase infrastructure to support values
373 class PhaseValues : public PhaseTransform {
374 protected:
375   NodeHash  _table;             // Hash table for value-numbering
376 
377 public:
378   PhaseValues( Arena *arena, uint est_max_size );
379   PhaseValues( PhaseValues *pt );
<span class="line-removed">380   PhaseValues( PhaseValues *ptv, const char *dummy );</span>
381   NOT_PRODUCT( ~PhaseValues(); )
382   virtual PhaseIterGVN *is_IterGVN() { return 0; }
383 
384   // Some Ideal and other transforms delete --&gt; modify --&gt; insert values
385   bool   hash_delete(Node *n)     { return _table.hash_delete(n); }
386   void   hash_insert(Node *n)     { _table.hash_insert(n); }
387   Node  *hash_find_insert(Node *n){ return _table.hash_find_insert(n); }
388   Node  *hash_find(const Node *n) { return _table.hash_find(n); }
389 
390   // Used after parsing to eliminate values that are no longer in program
391   void   remove_useless_nodes(VectorSet &amp;useful) {
392     _table.remove_useless_nodes(useful);
393     // this may invalidate cached cons so reset the cache
394     init_con_caches();
395   }
396 
397   virtual ConNode* uncached_makecon(const Type* t);  // override from PhaseTransform
398 
399   virtual const Type* saturate(const Type* new_type, const Type* old_type,
400                                const Type* limit_type) const
401   { return new_type; }
402 
403 #ifndef PRODUCT
404   uint   _count_new_values;     // For profiling, count new values produced
405   void    inc_new_values()        { ++_count_new_values; }
406   void    clear_new_values()      { _count_new_values = 0; }
407   uint    made_new_values() const { return _count_new_values; }
408 #endif
409 };
410 
411 
412 //------------------------------PhaseGVN---------------------------------------
413 // Phase for performing local, pessimistic GVN-style optimizations.
414 class PhaseGVN : public PhaseValues {
415 protected:
416   bool is_dominator_helper(Node *d, Node *n, bool linear_only);
417 
418 public:
419   PhaseGVN( Arena *arena, uint est_max_size ) : PhaseValues( arena, est_max_size ) {}
420   PhaseGVN( PhaseGVN *gvn ) : PhaseValues( gvn ) {}
<span class="line-removed">421   PhaseGVN( PhaseGVN *gvn, const char *dummy ) : PhaseValues( gvn, dummy ) {}</span>
422 
423   // Return a node which computes the same function as this node, but
424   // in a faster or cheaper fashion.
425   Node  *transform( Node *n );
426   Node  *transform_no_reclaim( Node *n );
427   virtual void record_for_igvn(Node *n) {
428     C-&gt;record_for_igvn(n);
429   }
430 
431   void replace_with(PhaseGVN* gvn) {
432     _table.replace_with(&amp;gvn-&gt;_table);
433     _types = gvn-&gt;_types;
434   }
435 
436   bool is_dominator(Node *d, Node *n) { return is_dominator_helper(d, n, true); }
437 
438   // Helper to call Node::Ideal() and BarrierSetC2::ideal_node().
439   Node* apply_ideal(Node* i, bool can_reshape);
440 
<span class="line-removed">441   // Helper to call Node::Identity() and BarrierSetC2::identity_node().</span>
<span class="line-removed">442   Node* apply_identity(Node* n);</span>
<span class="line-removed">443 </span>
444   // Check for a simple dead loop when a data node references itself.
445   DEBUG_ONLY(void dead_loop_check(Node *n);)
446 };
447 
448 //------------------------------PhaseIterGVN-----------------------------------
449 // Phase for iteratively performing local, pessimistic GVN-style optimizations.
450 // and ideal transformations on the graph.
451 class PhaseIterGVN : public PhaseGVN {
452 private:
453   bool _delay_transform;  // When true simply register the node when calling transform
454                           // instead of actually optimizing it
455 
456   // Idealize old Node &#39;n&#39; with respect to its inputs and its value
457   virtual Node *transform_old( Node *a_node );
458 
459   // Subsume users of node &#39;old&#39; into node &#39;nn&#39;
460   void subsume_node( Node *old, Node *nn );
461 
462   Node_Stack _stack;      // Stack used to avoid recursion
463 
464 protected:
465 
466   // Warm up hash table, type table and initial worklist
467   void init_worklist( Node *a_root );
468 
469   virtual const Type* saturate(const Type* new_type, const Type* old_type,
470                                const Type* limit_type) const;
471   // Usually returns new_type.  Returns old_type if new_type is only a slight
472   // improvement, such that it would take many (&gt;&gt;10) steps to reach 2**32.
473 
474 public:
475   PhaseIterGVN( PhaseIterGVN *igvn ); // Used by CCP constructor
476   PhaseIterGVN( PhaseGVN *gvn ); // Used after Parser
<span class="line-removed">477   PhaseIterGVN( PhaseIterGVN *igvn, const char *dummy ); // Used after +VerifyOpto</span>
478 
479   // Idealize new Node &#39;n&#39; with respect to its inputs and its value
480   virtual Node *transform( Node *a_node );
481   virtual void record_for_igvn(Node *n) { }
482 
483   virtual PhaseIterGVN *is_IterGVN() { return this; }
484 
485   Unique_Node_List _worklist;       // Iterative worklist
486 
487   // Given def-use info and an initial worklist, apply Node::Ideal,
488   // Node::Value, Node::Identity, hash-based value numbering, Node::Ideal_DU
489   // and dominator info to a fixed point.
490   void optimize();
491 
492 #ifndef PRODUCT
493   void trace_PhaseIterGVN(Node* n, Node* nn, const Type* old_type);
494   void init_verifyPhaseIterGVN();
495   void verify_PhaseIterGVN();
496 #endif
497 
</pre>
</td>
<td>
<hr />
<pre>
 74   void   check_grow() {
 75     _inserts++;
 76     if( _inserts == _insert_limit ) { grow(); }
 77     assert( _inserts &lt;= _insert_limit, &quot;hash table overflow&quot;);
 78     assert( _inserts &lt; _max, &quot;hash table overflow&quot; );
 79   }
 80   static uint round_up(uint);   // Round up to nearest power of 2
 81   void   grow();                // Grow _table to next power of 2 and rehash
 82   // Return 75% of _max, rounded up.
 83   uint   insert_limit() const { return _max - (_max&gt;&gt;2); }
 84 
 85   void   clear();               // Set all entries to NULL, keep storage.
 86   // Size of hash table
 87   uint   size()         const { return _max; }
 88   // Return Node* at index in table
 89   Node  *at(uint table_index) {
 90     assert(table_index &lt; _max, &quot;Must be within table&quot;);
 91     return _table[table_index];
 92   }
 93 
<span class="line-modified"> 94   void   remove_useless_nodes(VectorSet&amp; useful); // replace with sentinel</span>
 95   void   replace_with(NodeHash* nh);
 96   void   check_no_speculative_types(); // Check no speculative part for type nodes in table
 97 
 98   Node  *sentinel() { return _sentinel; }
 99 
100 #ifndef PRODUCT
101   Node  *find_index(uint idx);  // For debugging
102   void   dump();                // For debugging, dump statistics
103   uint   _grows;                // For debugging, count of table grow()s
104   uint   _look_probes;          // For debugging, count of hash probes
105   uint   _lookup_hits;          // For debugging, count of hash_finds
106   uint   _lookup_misses;        // For debugging, count of hash_finds
107   uint   _insert_probes;        // For debugging, count of hash probes
108   uint   _delete_probes;        // For debugging, count of hash probes for deletes
109   uint   _delete_hits;          // For debugging, count of hash probes for deletes
110   uint   _delete_misses;        // For debugging, count of hash probes for deletes
111   uint   _total_inserts;        // For debugging, total inserts into hash table
112   uint   _total_insert_probes;  // For debugging, total probes while inserting
113 #endif
114 };
</pre>
<hr />
<pre>
360   uint   _count_transforms;     // For profiling, count transforms performed
361   void   set_transforms()      { ++_count_transforms; }
362   void   clear_transforms()    { _count_transforms = 0; }
363   uint   made_transforms() const{ return _count_transforms; }
364 
365   bool   _allow_progress;      // progress not allowed during verification pass
366   void   set_allow_progress(bool allow) { _allow_progress = allow; }
367   bool   allow_progress()               { return _allow_progress; }
368 #endif
369 };
370 
371 //------------------------------PhaseValues------------------------------------
372 // Phase infrastructure to support values
373 class PhaseValues : public PhaseTransform {
374 protected:
375   NodeHash  _table;             // Hash table for value-numbering
376 
377 public:
378   PhaseValues( Arena *arena, uint est_max_size );
379   PhaseValues( PhaseValues *pt );

380   NOT_PRODUCT( ~PhaseValues(); )
381   virtual PhaseIterGVN *is_IterGVN() { return 0; }
382 
383   // Some Ideal and other transforms delete --&gt; modify --&gt; insert values
384   bool   hash_delete(Node *n)     { return _table.hash_delete(n); }
385   void   hash_insert(Node *n)     { _table.hash_insert(n); }
386   Node  *hash_find_insert(Node *n){ return _table.hash_find_insert(n); }
387   Node  *hash_find(const Node *n) { return _table.hash_find(n); }
388 
389   // Used after parsing to eliminate values that are no longer in program
390   void   remove_useless_nodes(VectorSet &amp;useful) {
391     _table.remove_useless_nodes(useful);
392     // this may invalidate cached cons so reset the cache
393     init_con_caches();
394   }
395 
396   virtual ConNode* uncached_makecon(const Type* t);  // override from PhaseTransform
397 
398   virtual const Type* saturate(const Type* new_type, const Type* old_type,
399                                const Type* limit_type) const
400   { return new_type; }
401 
402 #ifndef PRODUCT
403   uint   _count_new_values;     // For profiling, count new values produced
404   void    inc_new_values()        { ++_count_new_values; }
405   void    clear_new_values()      { _count_new_values = 0; }
406   uint    made_new_values() const { return _count_new_values; }
407 #endif
408 };
409 
410 
411 //------------------------------PhaseGVN---------------------------------------
412 // Phase for performing local, pessimistic GVN-style optimizations.
413 class PhaseGVN : public PhaseValues {
414 protected:
415   bool is_dominator_helper(Node *d, Node *n, bool linear_only);
416 
417 public:
418   PhaseGVN( Arena *arena, uint est_max_size ) : PhaseValues( arena, est_max_size ) {}
419   PhaseGVN( PhaseGVN *gvn ) : PhaseValues( gvn ) {}

420 
421   // Return a node which computes the same function as this node, but
422   // in a faster or cheaper fashion.
423   Node  *transform( Node *n );
424   Node  *transform_no_reclaim( Node *n );
425   virtual void record_for_igvn(Node *n) {
426     C-&gt;record_for_igvn(n);
427   }
428 
429   void replace_with(PhaseGVN* gvn) {
430     _table.replace_with(&amp;gvn-&gt;_table);
431     _types = gvn-&gt;_types;
432   }
433 
434   bool is_dominator(Node *d, Node *n) { return is_dominator_helper(d, n, true); }
435 
436   // Helper to call Node::Ideal() and BarrierSetC2::ideal_node().
437   Node* apply_ideal(Node* i, bool can_reshape);
438 



439   // Check for a simple dead loop when a data node references itself.
440   DEBUG_ONLY(void dead_loop_check(Node *n);)
441 };
442 
443 //------------------------------PhaseIterGVN-----------------------------------
444 // Phase for iteratively performing local, pessimistic GVN-style optimizations.
445 // and ideal transformations on the graph.
446 class PhaseIterGVN : public PhaseGVN {
447 private:
448   bool _delay_transform;  // When true simply register the node when calling transform
449                           // instead of actually optimizing it
450 
451   // Idealize old Node &#39;n&#39; with respect to its inputs and its value
452   virtual Node *transform_old( Node *a_node );
453 
454   // Subsume users of node &#39;old&#39; into node &#39;nn&#39;
455   void subsume_node( Node *old, Node *nn );
456 
457   Node_Stack _stack;      // Stack used to avoid recursion
458 
459 protected:
460 
461   // Warm up hash table, type table and initial worklist
462   void init_worklist( Node *a_root );
463 
464   virtual const Type* saturate(const Type* new_type, const Type* old_type,
465                                const Type* limit_type) const;
466   // Usually returns new_type.  Returns old_type if new_type is only a slight
467   // improvement, such that it would take many (&gt;&gt;10) steps to reach 2**32.
468 
469 public:
470   PhaseIterGVN( PhaseIterGVN *igvn ); // Used by CCP constructor
471   PhaseIterGVN( PhaseGVN *gvn ); // Used after Parser

472 
473   // Idealize new Node &#39;n&#39; with respect to its inputs and its value
474   virtual Node *transform( Node *a_node );
475   virtual void record_for_igvn(Node *n) { }
476 
477   virtual PhaseIterGVN *is_IterGVN() { return this; }
478 
479   Unique_Node_List _worklist;       // Iterative worklist
480 
481   // Given def-use info and an initial worklist, apply Node::Ideal,
482   // Node::Value, Node::Identity, hash-based value numbering, Node::Ideal_DU
483   // and dominator info to a fixed point.
484   void optimize();
485 
486 #ifndef PRODUCT
487   void trace_PhaseIterGVN(Node* n, Node* nn, const Type* old_type);
488   void init_verifyPhaseIterGVN();
489   void verify_PhaseIterGVN();
490 #endif
491 
</pre>
</td>
</tr>
</table>
<center><a href="phaseX.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="phasetype.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
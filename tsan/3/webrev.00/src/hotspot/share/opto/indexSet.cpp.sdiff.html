<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/indexSet.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="ifnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="indexSet.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/indexSet.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 94   Compile *compile = Compile::current();
 95   BitBlock* free_list = (BitBlock*)compile-&gt;indexSet_free_block_list();
 96   if (free_list == NULL) {
 97     populate_free_list();
 98     free_list = (BitBlock*)compile-&gt;indexSet_free_block_list();
 99   }
100   BitBlock *block = free_list;
101   compile-&gt;set_indexSet_free_block_list(block-&gt;next());
102 
103   block-&gt;clear();
104   return block;
105 }
106 
107 //---------------------------- IndexSet::alloc_block_containing() -------------
108 // Allocate a new BitBlock and put it into the position in the _blocks array
109 // corresponding to element.
110 
111 IndexSet::BitBlock *IndexSet::alloc_block_containing(uint element) {
112   BitBlock *block = alloc_block();
113   uint bi = get_block_index(element);



114   _blocks[bi] = block;
115   return block;
116 }
117 
118 //---------------------------- IndexSet::free_block() -------------------------
119 // Add a BitBlock to the free list.
120 
121 void IndexSet::free_block(uint i) {
122   debug_only(check_watch(&quot;free block&quot;, i));
123   assert(i &lt; _max_blocks, &quot;block index too large&quot;);
124   BitBlock *block = _blocks[i];
125   assert(block != &amp;_empty_block, &quot;cannot free the empty block&quot;);
126   block-&gt;set_next((IndexSet::BitBlock*)Compile::current()-&gt;indexSet_free_block_list());
127   Compile::current()-&gt;set_indexSet_free_block_list(block);
<span class="line-modified">128   set_block(i,&amp;_empty_block);</span>
129 }
130 
131 //------------------------------lrg_union--------------------------------------
132 // Compute the union of all elements of one and two which interfere with
133 // the RegMask mask.  If the degree of the union becomes exceeds
134 // fail_degree, the union bails out.  The underlying set is cleared before
135 // the union is performed.
136 
137 uint IndexSet::lrg_union(uint lr1, uint lr2,
138                          const uint fail_degree,
139                          const PhaseIFG *ifg,
140                          const RegMask &amp;mask ) {
141   IndexSet *one = ifg-&gt;neighbors(lr1);
142   IndexSet *two = ifg-&gt;neighbors(lr2);
143   LRG &amp;lrg1 = ifg-&gt;lrgs(lr1);
144   LRG &amp;lrg2 = ifg-&gt;lrgs(lr2);
145 #ifdef ASSERT
146   assert(_max_elements == one-&gt;_max_elements, &quot;max element mismatch&quot;);
147   check_watch(&quot;union destination&quot;);
148   one-&gt;check_watch(&quot;union source&quot;);
</pre>
<hr />
<pre>
151 
152   // Compute the degree of the combined live-range.  The combined
153   // live-range has the union of the original live-ranges&#39; neighbors set as
154   // well as the neighbors of all intermediate copies, minus those neighbors
155   // that can not use the intersected allowed-register-set.
156 
157   // Copy the larger set.  Insert the smaller set into the larger.
158   if (two-&gt;count() &gt; one-&gt;count()) {
159     IndexSet *temp = one;
160     one = two;
161     two = temp;
162   }
163 
164   clear();
165 
166   // Used to compute degree of register-only interferences.  Infinite-stack
167   // neighbors do not alter colorability, as they can always color to some
168   // other color.  (A variant of the Briggs assertion)
169   uint reg_degree = 0;
170 
<span class="line-modified">171   uint element;</span>
172   // Load up the combined interference set with the neighbors of one
<span class="line-modified">173   IndexSetIterator elements(one);</span>
<span class="line-modified">174   while ((element = elements.next()) != 0) {</span>
<span class="line-modified">175     LRG &amp;lrg = ifg-&gt;lrgs(element);</span>
<span class="line-modified">176     if (mask.overlap(lrg.mask())) {</span>
<span class="line-modified">177       insert(element);</span>
<span class="line-modified">178       if( !lrg.mask().is_AllStack() ) {</span>
<span class="line-modified">179         reg_degree += lrg1.compute_degree(lrg);</span>
<span class="line-modified">180         if( reg_degree &gt;= fail_degree ) return reg_degree;</span>
<span class="line-modified">181       } else {</span>
<span class="line-removed">182         // !!!!! Danger!  No update to reg_degree despite having a neighbor.</span>
<span class="line-removed">183         // A variant of the Briggs assertion.</span>
<span class="line-removed">184         // Not needed if I simplify during coalesce, ala George/Appel.</span>
<span class="line-removed">185         assert( lrg.lo_degree(), &quot;&quot; );</span>
<span class="line-removed">186       }</span>
<span class="line-removed">187     }</span>
<span class="line-removed">188   }</span>
<span class="line-removed">189   // Add neighbors of two as well</span>
<span class="line-removed">190   IndexSetIterator elements2(two);</span>
<span class="line-removed">191   while ((element = elements2.next()) != 0) {</span>
<span class="line-removed">192     LRG &amp;lrg = ifg-&gt;lrgs(element);</span>
<span class="line-removed">193     if (mask.overlap(lrg.mask())) {</span>
<span class="line-removed">194       if (insert(element)) {</span>
<span class="line-removed">195         if( !lrg.mask().is_AllStack() ) {</span>
<span class="line-removed">196           reg_degree += lrg2.compute_degree(lrg);</span>
<span class="line-removed">197           if( reg_degree &gt;= fail_degree ) return reg_degree;</span>
198         } else {
199           // !!!!! Danger!  No update to reg_degree despite having a neighbor.
200           // A variant of the Briggs assertion.
201           // Not needed if I simplify during coalesce, ala George/Appel.
<span class="line-modified">202           assert( lrg.lo_degree(), &quot;&quot; );</span>





















203         }
204       }
205     }
206   }
207 
208   return reg_degree;
209 }
210 
211 //---------------------------- IndexSet() -----------------------------
212 // A deep copy constructor.  This is used when you need a scratch copy of this set.
213 
214 IndexSet::IndexSet (IndexSet *set) {
215 #ifdef ASSERT
216   _serial_number = _serial_count++;
217   set-&gt;check_watch(&quot;copied&quot;, _serial_number);
218   check_watch(&quot;initialized by copy&quot;, set-&gt;_serial_number);
219   _max_elements = set-&gt;_max_elements;
220 #endif
221   _count = set-&gt;_count;

222   _max_blocks = set-&gt;_max_blocks;
223   if (_max_blocks &lt;= preallocated_block_list_size) {
224     _blocks = _preallocated_block_list;
225   } else {
226     _blocks =
227       (IndexSet::BitBlock**) arena()-&gt;Amalloc_4(sizeof(IndexSet::BitBlock**) * _max_blocks);
228   }
229   for (uint i = 0; i &lt; _max_blocks; i++) {
230     BitBlock *block = set-&gt;_blocks[i];
231     if (block == &amp;_empty_block) {
232       set_block(i, &amp;_empty_block);
233     } else {
234       BitBlock *new_block = alloc_block();
235       memcpy(new_block-&gt;words(), block-&gt;words(), sizeof(uint32_t) * words_per_block);
236       set_block(i, new_block);
237     }
238   }
239 }
240 
241 //---------------------------- IndexSet::initialize() -----------------------------
242 // Prepare an IndexSet for use.
243 
244 void IndexSet::initialize(uint max_elements) {
245 #ifdef ASSERT
246   _serial_number = _serial_count++;
247   check_watch(&quot;initialized&quot;, max_elements);
248   _max_elements = max_elements;
249 #endif
250   _count = 0;

251   _max_blocks = (max_elements + bits_per_block - 1) / bits_per_block;
252 
253   if (_max_blocks &lt;= preallocated_block_list_size) {
254     _blocks = _preallocated_block_list;
255   } else {
256     _blocks = (IndexSet::BitBlock**) arena()-&gt;Amalloc_4(sizeof(IndexSet::BitBlock*) * _max_blocks);
257   }
258   for (uint i = 0; i &lt; _max_blocks; i++) {
259     set_block(i, &amp;_empty_block);
260   }
261 }
262 
263 //---------------------------- IndexSet::initialize()------------------------------
264 // Prepare an IndexSet for use.  If it needs to allocate its _blocks array, it does
265 // so from the Arena passed as a parameter.  BitBlock allocation is still done from
266 // the static Arena which was set with reset_memory().
267 
268 void IndexSet::initialize(uint max_elements, Arena *arena) {
269 #ifdef ASSERT
270   _serial_number = _serial_count++;
271   check_watch(&quot;initialized2&quot;, max_elements);
272   _max_elements = max_elements;
273 #endif // ASSERT
274   _count = 0;

275   _max_blocks = (max_elements + bits_per_block - 1) / bits_per_block;
276 
277   if (_max_blocks &lt;= preallocated_block_list_size) {
278     _blocks = _preallocated_block_list;
279   } else {
280     _blocks = (IndexSet::BitBlock**) arena-&gt;Amalloc_4(sizeof(IndexSet::BitBlock*) * _max_blocks);
281   }
282   for (uint i = 0; i &lt; _max_blocks; i++) {
283     set_block(i, &amp;_empty_block);
284   }
285 }
286 
287 //---------------------------- IndexSet::swap() -----------------------------
288 // Exchange two IndexSets.
289 
290 void IndexSet::swap(IndexSet *set) {
291 #ifdef ASSERT
292   assert(_max_elements == set-&gt;_max_elements, &quot;must have same universe size to swap&quot;);
293   check_watch(&quot;swap&quot;, set-&gt;_serial_number);
294   set-&gt;check_watch(&quot;swap&quot;, _serial_number);
295 #endif
296 
<span class="line-modified">297   for (uint i = 0; i &lt; _max_blocks; i++) {</span>

298     BitBlock *temp = _blocks[i];
299     set_block(i, set-&gt;_blocks[i]);
300     set-&gt;set_block(i, temp);
301   }
302   uint temp = _count;
303   _count = set-&gt;_count;
304   set-&gt;_count = temp;





305 }
306 
307 //---------------------------- IndexSet::dump() -----------------------------
308 // Print this set.  Used for debugging.
309 
310 #ifndef PRODUCT
311 void IndexSet::dump() const {
312   IndexSetIterator elements(this);
313 
314   tty-&gt;print(&quot;{&quot;);
315   uint i;
316   while ((i = elements.next()) != 0) {
317     tty-&gt;print(&quot;L%d &quot;, i);
318   }
319   tty-&gt;print_cr(&quot;}&quot;);
320 }
321 #endif
322 
323 #ifdef ASSERT
324 //---------------------------- IndexSet::tally_iteration_statistics() -----------------------------
</pre>
<hr />
<pre>
366     if (member(i)) {
367       count++;
368       assert(count &lt;= _count, &quot;_count is messed up&quot;);
369     }
370   }
371 
372   IndexSetIterator elements(this);
373   count = 0;
374   while ((i = elements.next()) != 0) {
375     count++;
376     assert(member(i), &quot;returned a non member&quot;);
377     assert(count &lt;= _count, &quot;iterator returned wrong number of elements&quot;);
378   }
379 }
380 #endif
381 
382 //---------------------------- IndexSetIterator() -----------------------------
383 // Create an iterator for a set.  If empty blocks are detected when iterating
384 // over the set, these blocks are replaced.
385 
<span class="line-removed">386 IndexSetIterator::IndexSetIterator(IndexSet *set) {</span>
<span class="line-removed">387 #ifdef ASSERT</span>
<span class="line-removed">388   if (CollectIndexSetStatistics) {</span>
<span class="line-removed">389     set-&gt;tally_iteration_statistics();</span>
<span class="line-removed">390   }</span>
<span class="line-removed">391   set-&gt;check_watch(&quot;traversed&quot;, set-&gt;count());</span>
<span class="line-removed">392 #endif</span>
<span class="line-removed">393   if (set-&gt;is_empty()) {</span>
<span class="line-removed">394     _current = 0;</span>
<span class="line-removed">395     _next_word = IndexSet::words_per_block;</span>
<span class="line-removed">396     _next_block = 1;</span>
<span class="line-removed">397     _max_blocks = 1;</span>
<span class="line-removed">398 </span>
<span class="line-removed">399     // We don&#39;t need the following values when we iterate over an empty set.</span>
<span class="line-removed">400     // The commented out code is left here to document that the omission</span>
<span class="line-removed">401     // is intentional.</span>
<span class="line-removed">402     //</span>
<span class="line-removed">403     //_value = 0;</span>
<span class="line-removed">404     //_words = NULL;</span>
<span class="line-removed">405     //_blocks = NULL;</span>
<span class="line-removed">406     //_set = NULL;</span>
<span class="line-removed">407   } else {</span>
<span class="line-removed">408     _current = 0;</span>
<span class="line-removed">409     _value = 0;</span>
<span class="line-removed">410     _next_block = 0;</span>
<span class="line-removed">411     _next_word = IndexSet::words_per_block;</span>
<span class="line-removed">412 </span>
<span class="line-removed">413     _max_blocks = set-&gt;_max_blocks;</span>
<span class="line-removed">414     _words = NULL;</span>
<span class="line-removed">415     _blocks = set-&gt;_blocks;</span>
<span class="line-removed">416     _set = set;</span>
<span class="line-removed">417   }</span>
<span class="line-removed">418 }</span>
<span class="line-removed">419 </span>
<span class="line-removed">420 //---------------------------- IndexSetIterator(const) -----------------------------</span>
<span class="line-removed">421 // Iterate over a constant IndexSet.</span>
<span class="line-removed">422 </span>
<span class="line-removed">423 IndexSetIterator::IndexSetIterator(const IndexSet *set) {</span>
<span class="line-removed">424 #ifdef ASSERT</span>
<span class="line-removed">425   if (CollectIndexSetStatistics) {</span>
<span class="line-removed">426     set-&gt;tally_iteration_statistics();</span>
<span class="line-removed">427   }</span>
<span class="line-removed">428   // We don&#39;t call check_watch from here to avoid bad recursion.</span>
<span class="line-removed">429   //   set-&gt;check_watch(&quot;traversed const&quot;, set-&gt;count());</span>
<span class="line-removed">430 #endif</span>
<span class="line-removed">431   if (set-&gt;is_empty()) {</span>
<span class="line-removed">432     _current = 0;</span>
<span class="line-removed">433     _next_word = IndexSet::words_per_block;</span>
<span class="line-removed">434     _next_block = 1;</span>
<span class="line-removed">435     _max_blocks = 1;</span>
<span class="line-removed">436 </span>
<span class="line-removed">437     // We don&#39;t need the following values when we iterate over an empty set.</span>
<span class="line-removed">438     // The commented out code is left here to document that the omission</span>
<span class="line-removed">439     // is intentional.</span>
<span class="line-removed">440     //</span>
<span class="line-removed">441     //_value = 0;</span>
<span class="line-removed">442     //_words = NULL;</span>
<span class="line-removed">443     //_blocks = NULL;</span>
<span class="line-removed">444     //_set = NULL;</span>
<span class="line-removed">445   } else {</span>
<span class="line-removed">446     _current = 0;</span>
<span class="line-removed">447     _value = 0;</span>
<span class="line-removed">448     _next_block = 0;</span>
<span class="line-removed">449     _next_word = IndexSet::words_per_block;</span>
<span class="line-removed">450 </span>
<span class="line-removed">451     _max_blocks = set-&gt;_max_blocks;</span>
<span class="line-removed">452     _words = NULL;</span>
<span class="line-removed">453     _blocks = set-&gt;_blocks;</span>
<span class="line-removed">454     _set = NULL;</span>
<span class="line-removed">455   }</span>
<span class="line-removed">456 }</span>
<span class="line-removed">457 </span>
458 //---------------------------- List16Iterator::advance_and_next() -----------------------------
459 // Advance to the next non-empty word in the set being iterated over.  Return the next element
460 // if there is one.  If we are done, return 0.  This method is called from the next() method
461 // when it gets done with a word.
462 
463 uint IndexSetIterator::advance_and_next() {
464   // See if there is another non-empty word in the current block.
465   for (uint wi = _next_word; wi &lt; (unsigned)IndexSet::words_per_block; wi++) {
466     if (_words[wi] != 0) {
467       // Found a non-empty word.
468       _value = ((_next_block - 1) * IndexSet::bits_per_block) + (wi * IndexSet::bits_per_word);
469       _current = _words[wi];
<span class="line-modified">470 </span>
<span class="line-modified">471       _next_word = wi+1;</span>
<span class="line-removed">472 </span>
<span class="line-removed">473       return next();</span>
474     }
475   }
476 
477   // We ran out of words in the current block.  Advance to next non-empty block.
478   for (uint bi = _next_block; bi &lt; _max_blocks; bi++) {
479     if (_blocks[bi] != &amp;IndexSet::_empty_block) {
480       // Found a non-empty block.
481 
482       _words = _blocks[bi]-&gt;words();
483       for (uint wi = 0; wi &lt; (unsigned)IndexSet::words_per_block; wi++) {
484         if (_words[wi] != 0) {
485           // Found a non-empty word.
486           _value = (bi * IndexSet::bits_per_block) + (wi * IndexSet::bits_per_word);
487           _current = _words[wi];
488 
489           _next_block = bi+1;
490           _next_word = wi+1;
<span class="line-modified">491 </span>
<span class="line-removed">492           return next();</span>
493         }
494       }
495 
496       // All of the words in the block were empty.  Replace
497       // the block with the empty block.
498       if (_set) {
499         _set-&gt;free_block(bi);
500       }
501     }
502   }
503 
<span class="line-removed">504   // These assignments make redundant calls to next on a finished iterator</span>
<span class="line-removed">505   // faster.  Probably not necessary.</span>
<span class="line-removed">506   _next_block = _max_blocks;</span>
<span class="line-removed">507   _next_word = IndexSet::words_per_block;</span>
<span class="line-removed">508 </span>
509   // No more words.
510   return 0;
511 }
</pre>
</td>
<td>
<hr />
<pre>
 94   Compile *compile = Compile::current();
 95   BitBlock* free_list = (BitBlock*)compile-&gt;indexSet_free_block_list();
 96   if (free_list == NULL) {
 97     populate_free_list();
 98     free_list = (BitBlock*)compile-&gt;indexSet_free_block_list();
 99   }
100   BitBlock *block = free_list;
101   compile-&gt;set_indexSet_free_block_list(block-&gt;next());
102 
103   block-&gt;clear();
104   return block;
105 }
106 
107 //---------------------------- IndexSet::alloc_block_containing() -------------
108 // Allocate a new BitBlock and put it into the position in the _blocks array
109 // corresponding to element.
110 
111 IndexSet::BitBlock *IndexSet::alloc_block_containing(uint element) {
112   BitBlock *block = alloc_block();
113   uint bi = get_block_index(element);
<span class="line-added">114   if (bi &gt;= _current_block_limit) {</span>
<span class="line-added">115     _current_block_limit = bi + 1;</span>
<span class="line-added">116   }</span>
117   _blocks[bi] = block;
118   return block;
119 }
120 
121 //---------------------------- IndexSet::free_block() -------------------------
122 // Add a BitBlock to the free list.
123 
124 void IndexSet::free_block(uint i) {
125   debug_only(check_watch(&quot;free block&quot;, i));
126   assert(i &lt; _max_blocks, &quot;block index too large&quot;);
127   BitBlock *block = _blocks[i];
128   assert(block != &amp;_empty_block, &quot;cannot free the empty block&quot;);
129   block-&gt;set_next((IndexSet::BitBlock*)Compile::current()-&gt;indexSet_free_block_list());
130   Compile::current()-&gt;set_indexSet_free_block_list(block);
<span class="line-modified">131   set_block(i, &amp;_empty_block);</span>
132 }
133 
134 //------------------------------lrg_union--------------------------------------
135 // Compute the union of all elements of one and two which interfere with
136 // the RegMask mask.  If the degree of the union becomes exceeds
137 // fail_degree, the union bails out.  The underlying set is cleared before
138 // the union is performed.
139 
140 uint IndexSet::lrg_union(uint lr1, uint lr2,
141                          const uint fail_degree,
142                          const PhaseIFG *ifg,
143                          const RegMask &amp;mask ) {
144   IndexSet *one = ifg-&gt;neighbors(lr1);
145   IndexSet *two = ifg-&gt;neighbors(lr2);
146   LRG &amp;lrg1 = ifg-&gt;lrgs(lr1);
147   LRG &amp;lrg2 = ifg-&gt;lrgs(lr2);
148 #ifdef ASSERT
149   assert(_max_elements == one-&gt;_max_elements, &quot;max element mismatch&quot;);
150   check_watch(&quot;union destination&quot;);
151   one-&gt;check_watch(&quot;union source&quot;);
</pre>
<hr />
<pre>
154 
155   // Compute the degree of the combined live-range.  The combined
156   // live-range has the union of the original live-ranges&#39; neighbors set as
157   // well as the neighbors of all intermediate copies, minus those neighbors
158   // that can not use the intersected allowed-register-set.
159 
160   // Copy the larger set.  Insert the smaller set into the larger.
161   if (two-&gt;count() &gt; one-&gt;count()) {
162     IndexSet *temp = one;
163     one = two;
164     two = temp;
165   }
166 
167   clear();
168 
169   // Used to compute degree of register-only interferences.  Infinite-stack
170   // neighbors do not alter colorability, as they can always color to some
171   // other color.  (A variant of the Briggs assertion)
172   uint reg_degree = 0;
173 
<span class="line-modified">174   uint element = 0;</span>
175   // Load up the combined interference set with the neighbors of one
<span class="line-modified">176   if (!one-&gt;is_empty()) {</span>
<span class="line-modified">177     IndexSetIterator elements(one);</span>
<span class="line-modified">178     while ((element = elements.next()) != 0) {</span>
<span class="line-modified">179       LRG &amp;lrg = ifg-&gt;lrgs(element);</span>
<span class="line-modified">180       if (mask.overlap(lrg.mask())) {</span>
<span class="line-modified">181         insert(element);</span>
<span class="line-modified">182         if (!lrg.mask().is_AllStack()) {</span>
<span class="line-modified">183           reg_degree += lrg1.compute_degree(lrg);</span>
<span class="line-modified">184           if (reg_degree &gt;= fail_degree) return reg_degree;</span>
















185         } else {
186           // !!!!! Danger!  No update to reg_degree despite having a neighbor.
187           // A variant of the Briggs assertion.
188           // Not needed if I simplify during coalesce, ala George/Appel.
<span class="line-modified">189           assert(lrg.lo_degree(), &quot;&quot;);</span>
<span class="line-added">190         }</span>
<span class="line-added">191       }</span>
<span class="line-added">192     }</span>
<span class="line-added">193   }</span>
<span class="line-added">194   // Add neighbors of two as well</span>
<span class="line-added">195 </span>
<span class="line-added">196   if (!two-&gt;is_empty()) {</span>
<span class="line-added">197     IndexSetIterator elements2(two);</span>
<span class="line-added">198     while ((element = elements2.next()) != 0) {</span>
<span class="line-added">199       LRG &amp;lrg = ifg-&gt;lrgs(element);</span>
<span class="line-added">200       if (mask.overlap(lrg.mask())) {</span>
<span class="line-added">201         if (insert(element)) {</span>
<span class="line-added">202           if (!lrg.mask().is_AllStack()) {</span>
<span class="line-added">203             reg_degree += lrg2.compute_degree(lrg);</span>
<span class="line-added">204             if (reg_degree &gt;= fail_degree) return reg_degree;</span>
<span class="line-added">205           } else {</span>
<span class="line-added">206             // !!!!! Danger!  No update to reg_degree despite having a neighbor.</span>
<span class="line-added">207             // A variant of the Briggs assertion.</span>
<span class="line-added">208             // Not needed if I simplify during coalesce, ala George/Appel.</span>
<span class="line-added">209             assert(lrg.lo_degree(), &quot;&quot;);</span>
<span class="line-added">210           }</span>
211         }
212       }
213     }
214   }
215 
216   return reg_degree;
217 }
218 
219 //---------------------------- IndexSet() -----------------------------
220 // A deep copy constructor.  This is used when you need a scratch copy of this set.
221 
222 IndexSet::IndexSet (IndexSet *set) {
223 #ifdef ASSERT
224   _serial_number = _serial_count++;
225   set-&gt;check_watch(&quot;copied&quot;, _serial_number);
226   check_watch(&quot;initialized by copy&quot;, set-&gt;_serial_number);
227   _max_elements = set-&gt;_max_elements;
228 #endif
229   _count = set-&gt;_count;
<span class="line-added">230   _current_block_limit = set-&gt;_current_block_limit;</span>
231   _max_blocks = set-&gt;_max_blocks;
232   if (_max_blocks &lt;= preallocated_block_list_size) {
233     _blocks = _preallocated_block_list;
234   } else {
235     _blocks =
236       (IndexSet::BitBlock**) arena()-&gt;Amalloc_4(sizeof(IndexSet::BitBlock**) * _max_blocks);
237   }
238   for (uint i = 0; i &lt; _max_blocks; i++) {
239     BitBlock *block = set-&gt;_blocks[i];
240     if (block == &amp;_empty_block) {
241       set_block(i, &amp;_empty_block);
242     } else {
243       BitBlock *new_block = alloc_block();
244       memcpy(new_block-&gt;words(), block-&gt;words(), sizeof(uint32_t) * words_per_block);
245       set_block(i, new_block);
246     }
247   }
248 }
249 
250 //---------------------------- IndexSet::initialize() -----------------------------
251 // Prepare an IndexSet for use.
252 
253 void IndexSet::initialize(uint max_elements) {
254 #ifdef ASSERT
255   _serial_number = _serial_count++;
256   check_watch(&quot;initialized&quot;, max_elements);
257   _max_elements = max_elements;
258 #endif
259   _count = 0;
<span class="line-added">260   _current_block_limit = 0;</span>
261   _max_blocks = (max_elements + bits_per_block - 1) / bits_per_block;
262 
263   if (_max_blocks &lt;= preallocated_block_list_size) {
264     _blocks = _preallocated_block_list;
265   } else {
266     _blocks = (IndexSet::BitBlock**) arena()-&gt;Amalloc_4(sizeof(IndexSet::BitBlock*) * _max_blocks);
267   }
268   for (uint i = 0; i &lt; _max_blocks; i++) {
269     set_block(i, &amp;_empty_block);
270   }
271 }
272 
273 //---------------------------- IndexSet::initialize()------------------------------
274 // Prepare an IndexSet for use.  If it needs to allocate its _blocks array, it does
275 // so from the Arena passed as a parameter.  BitBlock allocation is still done from
276 // the static Arena which was set with reset_memory().
277 
278 void IndexSet::initialize(uint max_elements, Arena *arena) {
279 #ifdef ASSERT
280   _serial_number = _serial_count++;
281   check_watch(&quot;initialized2&quot;, max_elements);
282   _max_elements = max_elements;
283 #endif // ASSERT
284   _count = 0;
<span class="line-added">285   _current_block_limit = 0;</span>
286   _max_blocks = (max_elements + bits_per_block - 1) / bits_per_block;
287 
288   if (_max_blocks &lt;= preallocated_block_list_size) {
289     _blocks = _preallocated_block_list;
290   } else {
291     _blocks = (IndexSet::BitBlock**) arena-&gt;Amalloc_4(sizeof(IndexSet::BitBlock*) * _max_blocks);
292   }
293   for (uint i = 0; i &lt; _max_blocks; i++) {
294     set_block(i, &amp;_empty_block);
295   }
296 }
297 
298 //---------------------------- IndexSet::swap() -----------------------------
299 // Exchange two IndexSets.
300 
301 void IndexSet::swap(IndexSet *set) {
302 #ifdef ASSERT
303   assert(_max_elements == set-&gt;_max_elements, &quot;must have same universe size to swap&quot;);
304   check_watch(&quot;swap&quot;, set-&gt;_serial_number);
305   set-&gt;check_watch(&quot;swap&quot;, _serial_number);
306 #endif
307 
<span class="line-modified">308   uint max = MAX2(_current_block_limit, set-&gt;_current_block_limit);</span>
<span class="line-added">309   for (uint i = 0; i &lt; max; i++) {</span>
310     BitBlock *temp = _blocks[i];
311     set_block(i, set-&gt;_blocks[i]);
312     set-&gt;set_block(i, temp);
313   }
314   uint temp = _count;
315   _count = set-&gt;_count;
316   set-&gt;_count = temp;
<span class="line-added">317 </span>
<span class="line-added">318   temp = _current_block_limit;</span>
<span class="line-added">319   _current_block_limit = set-&gt;_current_block_limit;</span>
<span class="line-added">320   set-&gt;_current_block_limit = temp;</span>
<span class="line-added">321 </span>
322 }
323 
324 //---------------------------- IndexSet::dump() -----------------------------
325 // Print this set.  Used for debugging.
326 
327 #ifndef PRODUCT
328 void IndexSet::dump() const {
329   IndexSetIterator elements(this);
330 
331   tty-&gt;print(&quot;{&quot;);
332   uint i;
333   while ((i = elements.next()) != 0) {
334     tty-&gt;print(&quot;L%d &quot;, i);
335   }
336   tty-&gt;print_cr(&quot;}&quot;);
337 }
338 #endif
339 
340 #ifdef ASSERT
341 //---------------------------- IndexSet::tally_iteration_statistics() -----------------------------
</pre>
<hr />
<pre>
383     if (member(i)) {
384       count++;
385       assert(count &lt;= _count, &quot;_count is messed up&quot;);
386     }
387   }
388 
389   IndexSetIterator elements(this);
390   count = 0;
391   while ((i = elements.next()) != 0) {
392     count++;
393     assert(member(i), &quot;returned a non member&quot;);
394     assert(count &lt;= _count, &quot;iterator returned wrong number of elements&quot;);
395   }
396 }
397 #endif
398 
399 //---------------------------- IndexSetIterator() -----------------------------
400 // Create an iterator for a set.  If empty blocks are detected when iterating
401 // over the set, these blocks are replaced.
402 








































































403 //---------------------------- List16Iterator::advance_and_next() -----------------------------
404 // Advance to the next non-empty word in the set being iterated over.  Return the next element
405 // if there is one.  If we are done, return 0.  This method is called from the next() method
406 // when it gets done with a word.
407 
408 uint IndexSetIterator::advance_and_next() {
409   // See if there is another non-empty word in the current block.
410   for (uint wi = _next_word; wi &lt; (unsigned)IndexSet::words_per_block; wi++) {
411     if (_words[wi] != 0) {
412       // Found a non-empty word.
413       _value = ((_next_block - 1) * IndexSet::bits_per_block) + (wi * IndexSet::bits_per_word);
414       _current = _words[wi];
<span class="line-modified">415       _next_word = wi + 1;</span>
<span class="line-modified">416       return next_value();</span>


417     }
418   }
419 
420   // We ran out of words in the current block.  Advance to next non-empty block.
421   for (uint bi = _next_block; bi &lt; _max_blocks; bi++) {
422     if (_blocks[bi] != &amp;IndexSet::_empty_block) {
423       // Found a non-empty block.
424 
425       _words = _blocks[bi]-&gt;words();
426       for (uint wi = 0; wi &lt; (unsigned)IndexSet::words_per_block; wi++) {
427         if (_words[wi] != 0) {
428           // Found a non-empty word.
429           _value = (bi * IndexSet::bits_per_block) + (wi * IndexSet::bits_per_word);
430           _current = _words[wi];
431 
432           _next_block = bi+1;
433           _next_word = wi+1;
<span class="line-modified">434           return next_value();</span>

435         }
436       }
437 
438       // All of the words in the block were empty.  Replace
439       // the block with the empty block.
440       if (_set) {
441         _set-&gt;free_block(bi);
442       }
443     }
444   }
445 





446   // No more words.
447   return 0;
448 }
</pre>
</td>
</tr>
</table>
<center><a href="ifnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="indexSet.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
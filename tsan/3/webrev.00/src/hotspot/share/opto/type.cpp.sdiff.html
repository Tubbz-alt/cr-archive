<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/type.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="superword.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="type.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/type.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciMethodData.hpp&quot;
  27 #include &quot;ci/ciTypeFlow.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;compiler/compileLog.hpp&quot;
  31 #include &quot;libadt/dict.hpp&quot;
  32 #include &quot;memory/oopFactory.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
  34 #include &quot;oops/instanceKlass.hpp&quot;
  35 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  36 #include &quot;oops/objArrayKlass.hpp&quot;
  37 #include &quot;oops/typeArrayKlass.hpp&quot;
  38 #include &quot;opto/matcher.hpp&quot;
  39 #include &quot;opto/node.hpp&quot;
  40 #include &quot;opto/opcodes.hpp&quot;
  41 #include &quot;opto/type.hpp&quot;

  42 
  43 // Portions of code courtesy of Clifford Click
  44 
  45 // Optimization - Graph Style
  46 
  47 // Dictionary of types shared among compilations.
  48 Dict* Type::_shared_type_dict = NULL;
  49 
  50 // Array which maps compiler types to Basic Types
  51 const Type::TypeInfo Type::_type_info[Type::lastype] = {
  52   { Bad,             T_ILLEGAL,    &quot;bad&quot;,           false, Node::NotAMachineReg, relocInfo::none          },  // Bad
  53   { Control,         T_ILLEGAL,    &quot;control&quot;,       false, 0,                    relocInfo::none          },  // Control
  54   { Bottom,          T_VOID,       &quot;top&quot;,           false, 0,                    relocInfo::none          },  // Top
  55   { Bad,             T_INT,        &quot;int:&quot;,          false, Op_RegI,              relocInfo::none          },  // Int
  56   { Bad,             T_LONG,       &quot;long:&quot;,         false, Op_RegL,              relocInfo::none          },  // Long
  57   { Half,            T_VOID,       &quot;half&quot;,          false, 0,                    relocInfo::none          },  // Half
  58   { Bad,             T_NARROWOOP,  &quot;narrowoop:&quot;,    false, Op_RegN,              relocInfo::none          },  // NarrowOop
  59   { Bad,             T_NARROWKLASS,&quot;narrowklass:&quot;,  false, Op_RegN,              relocInfo::none          },  // NarrowKlass
  60   { Bad,             T_ILLEGAL,    &quot;tuple:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // Tuple
  61   { Bad,             T_ARRAY,      &quot;array:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // Array
</pre>
<hr />
<pre>
 358     field_value = field-&gt;constant_value_of(holder);
 359   }
 360   if (!field_value.is_valid()) {
 361     return NULL; // Not a constant
 362   }
 363 
 364   ciConstant con = check_mismatched_access(field_value, loadbt, is_unsigned_load);
 365 
 366   assert(con.is_valid(), &quot;elembt=%s; loadbt=%s; unsigned=%d&quot;,
 367          type2name(field_value.basic_type()), type2name(loadbt), is_unsigned_load);
 368 
 369   bool is_stable_array = FoldStableValues &amp;&amp; field-&gt;is_stable() &amp;&amp; field-&gt;type()-&gt;is_array_klass();
 370   int stable_dimension = (is_stable_array ? field-&gt;type()-&gt;as_array_klass()-&gt;dimension() : 0);
 371   bool is_narrow_oop = (loadbt == T_NARROWOOP);
 372 
 373   const Type* con_type = make_from_constant(con, /*require_constant=*/ true,
 374                                             stable_dimension, is_narrow_oop,
 375                                             field-&gt;is_autobox_cache());
 376   if (con_type != NULL &amp;&amp; field-&gt;is_call_site_target()) {
 377     ciCallSite* call_site = holder-&gt;as_call_site();
<span class="line-modified"> 378     if (!call_site-&gt;is_constant_call_site()) {</span>
 379       ciMethodHandle* target = con.as_object()-&gt;as_method_handle();
 380       Compile::current()-&gt;dependencies()-&gt;assert_call_site_target_value(call_site, target);
 381     }
 382   }
 383   return con_type;
 384 }
 385 
 386 //------------------------------make-------------------------------------------
 387 // Create a simple Type, with default empty symbol sets.  Then hashcons it
 388 // and look for an existing copy in the type dictionary.
 389 const Type *Type::make( enum TYPES t ) {
 390   return (new Type(t))-&gt;hashcons();
 391 }
 392 
 393 //------------------------------cmp--------------------------------------------
 394 int Type::cmp( const Type *const t1, const Type *const t2 ) {
 395   if( t1-&gt;_base != t2-&gt;_base )
 396     return 1;                   // Missed badly
 397   assert(t1 != t2 || t1-&gt;eq(t2), &quot;eq must be reflexive&quot;);
 398   return !t1-&gt;eq(t2);           // Return ZERO if equal
 399 }
 400 
 401 const Type* Type::maybe_remove_speculative(bool include_speculative) const {
 402   if (!include_speculative) {
 403     return remove_speculative();
 404   }
 405   return this;
 406 }
 407 
 408 //------------------------------hash-------------------------------------------
 409 int Type::uhash( const Type *const t ) {
 410   return t-&gt;hash();
 411 }
 412 
 413 #define SMALLINT ((juint)3)  // a value too insignificant to consider widening
<span class="line-modified"> 414 </span>
<span class="line-modified"> 415 static double pos_dinf() {</span>
<span class="line-removed"> 416   union { int64_t i; double d; } v;</span>
<span class="line-removed"> 417   v.i = CONST64(0x7ff0000000000000);</span>
<span class="line-removed"> 418   return v.d;</span>
<span class="line-removed"> 419 }</span>
<span class="line-removed"> 420 </span>
<span class="line-removed"> 421 static float pos_finf() {</span>
<span class="line-removed"> 422   union { int32_t i; float f; } v;</span>
<span class="line-removed"> 423   v.i = 0x7f800000;</span>
<span class="line-removed"> 424   return v.f;</span>
<span class="line-removed"> 425 }</span>
 426 
 427 //--------------------------Initialize_shared----------------------------------
 428 void Type::Initialize_shared(Compile* current) {
 429   // This method does not need to be locked because the first system
 430   // compilations (stub compilations) occur serially.  If they are
 431   // changed to proceed in parallel, then this section will need
 432   // locking.
 433 
 434   Arena* save = current-&gt;type_arena();
 435   Arena* shared_type_arena = new (mtCompiler)Arena(mtCompiler);
 436 
 437   current-&gt;set_type_arena(shared_type_arena);
 438   _shared_type_dict =
 439     new (shared_type_arena) Dict( (CmpKey)Type::cmp, (Hash)Type::uhash,
 440                                   shared_type_arena, 128 );
 441   current-&gt;set_type_dict(_shared_type_dict);
 442 
 443   // Make shared pre-built types.
 444   CONTROL = make(Control);      // Control only
 445   TOP     = make(Top);          // No values in set
 446   MEMORY  = make(Memory);       // Abstract store only
 447   ABIO    = make(Abio);         // State-of-machine only
 448   RETURN_ADDRESS=make(Return_Address);
 449   FLOAT   = make(FloatBot);     // All floats
 450   DOUBLE  = make(DoubleBot);    // All doubles
 451   BOTTOM  = make(Bottom);       // Everything
 452   HALF    = make(Half);         // Placeholder half of doublewide type
 453 
 454   TypeF::ZERO = TypeF::make(0.0); // Float 0 (positive zero)
 455   TypeF::ONE  = TypeF::make(1.0); // Float 1
<span class="line-modified"> 456   TypeF::POS_INF = TypeF::make(pos_finf());</span>
<span class="line-modified"> 457   TypeF::NEG_INF = TypeF::make(-pos_finf());</span>
 458 
 459   TypeD::ZERO = TypeD::make(0.0); // Double 0 (positive zero)
 460   TypeD::ONE  = TypeD::make(1.0); // Double 1
<span class="line-modified"> 461   TypeD::POS_INF = TypeD::make(pos_dinf());</span>
<span class="line-modified"> 462   TypeD::NEG_INF = TypeD::make(-pos_dinf());</span>
 463 
 464   TypeInt::MINUS_1 = TypeInt::make(-1);  // -1
 465   TypeInt::ZERO    = TypeInt::make( 0);  //  0
 466   TypeInt::ONE     = TypeInt::make( 1);  //  1
 467   TypeInt::BOOL    = TypeInt::make(0,1,   WidenMin);  // 0 or 1, FALSE or TRUE.
 468   TypeInt::CC      = TypeInt::make(-1, 1, WidenMin);  // -1, 0 or 1, condition codes
 469   TypeInt::CC_LT   = TypeInt::make(-1,-1, WidenMin);  // == TypeInt::MINUS_1
 470   TypeInt::CC_GT   = TypeInt::make( 1, 1, WidenMin);  // == TypeInt::ONE
 471   TypeInt::CC_EQ   = TypeInt::make( 0, 0, WidenMin);  // == TypeInt::ZERO
 472   TypeInt::CC_LE   = TypeInt::make(-1, 0, WidenMin);
 473   TypeInt::CC_GE   = TypeInt::make( 0, 1, WidenMin);  // == TypeInt::BOOL
 474   TypeInt::BYTE    = TypeInt::make(-128,127,     WidenMin); // Bytes
 475   TypeInt::UBYTE   = TypeInt::make(0, 255,       WidenMin); // Unsigned Bytes
 476   TypeInt::CHAR    = TypeInt::make(0,65535,      WidenMin); // Java chars
 477   TypeInt::SHORT   = TypeInt::make(-32768,32767, WidenMin); // Java shorts
 478   TypeInt::POS     = TypeInt::make(0,max_jint,   WidenMin); // Non-neg values
 479   TypeInt::POS1    = TypeInt::make(1,max_jint,   WidenMin); // Positive values
 480   TypeInt::INT     = TypeInt::make(min_jint,max_jint, WidenMax); // 32-bit integers
 481   TypeInt::SYMINT  = TypeInt::make(-max_jint,max_jint,WidenMin); // symmetric range
 482   TypeInt::TYPE_DOMAIN  = TypeInt::INT;
</pre>
<hr />
<pre>
 713 //------------------------------hashcons---------------------------------------
 714 // Do the hash-cons trick.  If the Type already exists in the type table,
 715 // delete the current Type and return the existing Type.  Otherwise stick the
 716 // current Type in the Type table.
 717 const Type *Type::hashcons(void) {
 718   debug_only(base());           // Check the assertion in Type::base().
 719   // Look up the Type in the Type dictionary
 720   Dict *tdic = type_dict();
 721   Type* old = (Type*)(tdic-&gt;Insert(this, this, false));
 722   if( old ) {                   // Pre-existing Type?
 723     if( old != this )           // Yes, this guy is not the pre-existing?
 724       delete this;              // Yes, Nuke this guy
 725     assert( old-&gt;_dual, &quot;&quot; );
 726     return old;                 // Return pre-existing
 727   }
 728 
 729   // Every type has a dual (to make my lattice symmetric).
 730   // Since we just discovered a new Type, compute its dual right now.
 731   assert( !_dual, &quot;&quot; );         // No dual yet
 732   _dual = xdual();              // Compute the dual
<span class="line-modified"> 733   if( cmp(this,_dual)==0 ) {    // Handle self-symmetric</span>
<span class="line-modified"> 734     _dual = this;</span>



 735     return this;
 736   }
 737   assert( !_dual-&gt;_dual, &quot;&quot; );  // No reverse dual yet
 738   assert( !(*tdic)[_dual], &quot;&quot; ); // Dual not in type system either
 739   // New Type, insert into Type table
 740   tdic-&gt;Insert((void*)_dual,(void*)_dual);
 741   ((Type*)_dual)-&gt;_dual = this; // Finish up being symmetric
 742 #ifdef ASSERT
 743   Type *dual_dual = (Type*)_dual-&gt;xdual();
 744   assert( eq(dual_dual), &quot;xdual(xdual()) should be identity&quot; );
 745   delete dual_dual;
 746 #endif
 747   return this;                  // Return new Type
 748 }
 749 
 750 //------------------------------eq---------------------------------------------
 751 // Structural equality check for Type representations
 752 bool Type::eq( const Type * ) const {
 753   return true;                  // Nothing else can go wrong
 754 }
</pre>
<hr />
<pre>
2092 
2093 //------------------------------meet-------------------------------------------
2094 // Compute the MEET of two types.  It returns a new Type object.
2095 const Type *TypeAry::xmeet( const Type *t ) const {
2096   // Perform a fast test for common case; meeting the same types together.
2097   if( this == t ) return this;  // Meeting same type-rep?
2098 
2099   // Current &quot;this-&gt;_base&quot; is Ary
2100   switch (t-&gt;base()) {          // switch on original type
2101 
2102   case Bottom:                  // Ye Olde Default
2103     return t;
2104 
2105   default:                      // All else is a mistake
2106     typerr(t);
2107 
2108   case Array: {                 // Meeting 2 arrays?
2109     const TypeAry *a = t-&gt;is_ary();
2110     return TypeAry::make(_elem-&gt;meet_speculative(a-&gt;_elem),
2111                          _size-&gt;xmeet(a-&gt;_size)-&gt;is_int(),
<span class="line-modified">2112                          _stable &amp; a-&gt;_stable);</span>
2113   }
2114   case Top:
2115     break;
2116   }
2117   return this;                  // Return the double constant
2118 }
2119 
2120 //------------------------------xdual------------------------------------------
2121 // Dual: compute field-by-field dual
2122 const Type *TypeAry::xdual() const {
2123   const TypeInt* size_dual = _size-&gt;dual()-&gt;is_int();
2124   size_dual = normalize_array_size(size_dual);
2125   return new TypeAry(_elem-&gt;dual(), size_dual, !_stable);
2126 }
2127 
2128 //------------------------------eq---------------------------------------------
2129 // Structural equality check for Type representations
2130 bool TypeAry::eq( const Type *t ) const {
2131   const TypeAry *a = (const TypeAry*)t;
2132   return _elem == a-&gt;_elem &amp;&amp;
</pre>
<hr />
<pre>
2994       } else if (_offset == OffsetBot || _offset == OffsetTop) {
2995         // unsafe access
2996         _is_ptr_to_narrowoop = UseCompressedOops;
2997       } else { // exclude unsafe ops
2998         assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
2999 
3000         if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
3001             (_offset == java_lang_Class::klass_offset_in_bytes() ||
3002              _offset == java_lang_Class::array_klass_offset_in_bytes())) {
3003           // Special hidden fields from the Class.
3004           assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
3005           _is_ptr_to_narrowoop = false;
3006         } else if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
3007                    _offset &gt;= InstanceMirrorKlass::offset_of_static_fields()) {
3008           // Static fields
3009           assert(o != NULL, &quot;must be constant&quot;);
3010           ciInstanceKlass* k = o-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();
3011           ciField* field = k-&gt;get_field_by_offset(_offset, true);
3012           assert(field != NULL, &quot;missing field&quot;);
3013           BasicType basic_elem_type = field-&gt;layout_type();
<span class="line-modified">3014           _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; (basic_elem_type == T_OBJECT ||</span>
<span class="line-removed">3015                                                        basic_elem_type == T_ARRAY);</span>
3016         } else {
3017           // Instance fields which contains a compressed oop references.
3018           field = ik-&gt;get_field_by_offset(_offset, false);
3019           if (field != NULL) {
3020             BasicType basic_elem_type = field-&gt;layout_type();
<span class="line-modified">3021             _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; (basic_elem_type == T_OBJECT ||</span>
<span class="line-removed">3022                                                          basic_elem_type == T_ARRAY);</span>
3023           } else if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass())) {
3024             // Compile::find_alias_type() cast exactness on all types to verify
3025             // that it does not affect alias type.
3026             _is_ptr_to_narrowoop = UseCompressedOops;
3027           } else {
3028             // Type for the copy start in LibraryCallKit::inline_native_clone().
3029             _is_ptr_to_narrowoop = UseCompressedOops;
3030           }
3031         }
3032       }
3033     }
3034   }
3035 #endif
3036 }
3037 
3038 //------------------------------make-------------------------------------------
3039 const TypeOopPtr *TypeOopPtr::make(PTR ptr, int offset, int instance_id,
3040                                      const TypePtr* speculative, int inline_depth) {
3041   assert(ptr != Constant, &quot;no constant generic pointers&quot;);
3042   ciKlass*  k = Compile::current()-&gt;env()-&gt;Object_klass();
3043   bool      xk = false;
3044   ciObject* o = NULL;
3045   return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, xk, o, offset, instance_id, speculative, inline_depth))-&gt;hashcons();
3046 }
3047 
3048 
3049 //------------------------------cast_to_ptr_type-------------------------------
3050 const Type *TypeOopPtr::cast_to_ptr_type(PTR ptr) const {
3051   assert(_base == OopPtr, &quot;subclass must override cast_to_ptr_type&quot;);
3052   if( ptr == _ptr ) return this;
3053   return make(ptr, _offset, _instance_id, _speculative, _inline_depth);
3054 }
3055 
3056 //-----------------------------cast_to_instance_id----------------------------
3057 const TypeOopPtr *TypeOopPtr::cast_to_instance_id(int instance_id) const {
3058   // There are no instances of a general oop.
3059   // Return self unchanged.
3060   return this;
3061 }
3062 
<span class="line-removed">3063 const TypeOopPtr *TypeOopPtr::cast_to_nonconst() const {</span>
<span class="line-removed">3064   return this;</span>
<span class="line-removed">3065 }</span>
<span class="line-removed">3066 </span>
3067 //-----------------------------cast_to_exactness-------------------------------
3068 const Type *TypeOopPtr::cast_to_exactness(bool klass_is_exact) const {
3069   // There is no such thing as an exact general oop.
3070   // Return self unchanged.
3071   return this;
3072 }
3073 
3074 
3075 //------------------------------as_klass_type----------------------------------
3076 // Return the klass type corresponding to this instance or array type.
3077 // It is the type that is loaded from an object of this type.
3078 const TypeKlassPtr* TypeOopPtr::as_klass_type() const {
3079   ciKlass* k = klass();
3080   bool    xk = klass_is_exact();
3081   if (k == NULL)
3082     return TypeKlassPtr::OBJECT;
3083   else
3084     return TypeKlassPtr::make(xk? Constant: NotNull, k, 0);
3085 }
3086 
</pre>
<hr />
<pre>
3553 }
3554 
3555 
3556 //-----------------------------cast_to_exactness-------------------------------
3557 const Type *TypeInstPtr::cast_to_exactness(bool klass_is_exact) const {
3558   if( klass_is_exact == _klass_is_exact ) return this;
3559   if (!UseExactTypes)  return this;
3560   if (!_klass-&gt;is_loaded())  return this;
3561   ciInstanceKlass* ik = _klass-&gt;as_instance_klass();
3562   if( (ik-&gt;is_final() || _const_oop) )  return this;  // cannot clear xk
3563   if( ik-&gt;is_interface() )              return this;  // cannot set xk
3564   return make(ptr(), klass(), klass_is_exact, const_oop(), _offset, _instance_id, _speculative, _inline_depth);
3565 }
3566 
3567 //-----------------------------cast_to_instance_id----------------------------
3568 const TypeOopPtr *TypeInstPtr::cast_to_instance_id(int instance_id) const {
3569   if( instance_id == _instance_id ) return this;
3570   return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, instance_id, _speculative, _inline_depth);
3571 }
3572 
<span class="line-removed">3573 const TypeOopPtr *TypeInstPtr::cast_to_nonconst() const {</span>
<span class="line-removed">3574   if (const_oop() == NULL) return this;</span>
<span class="line-removed">3575   return make(NotNull, klass(), _klass_is_exact, NULL, _offset, _instance_id, _speculative, _inline_depth);</span>
<span class="line-removed">3576 }</span>
<span class="line-removed">3577 </span>
3578 //------------------------------xmeet_unloaded---------------------------------
3579 // Compute the MEET of two InstPtrs when at least one is unloaded.
3580 // Assume classes are different since called after check for same name/class-loader
3581 const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst) const {
3582     int off = meet_offset(tinst-&gt;offset());
3583     PTR ptr = meet_ptr(tinst-&gt;ptr());
3584     int instance_id = meet_instance_id(tinst-&gt;instance_id());
3585     const TypePtr* speculative = xmeet_speculative(tinst);
3586     int depth = meet_inline_depth(tinst-&gt;inline_depth());
3587 
3588     const TypeInstPtr *loaded    = is_loaded() ? this  : tinst;
3589     const TypeInstPtr *unloaded  = is_loaded() ? tinst : this;
3590     if( loaded-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) ) {
3591       //
3592       // Meet unloaded class with java/lang/Object
3593       //
3594       // Meet
3595       //          |                     Unloaded Class
3596       //  Object  |   TOP    |   AnyNull | Constant |   NotNull |  BOTTOM   |
3597       //  ===================================================================
</pre>
<hr />
<pre>
3862     // Now, reorder the above list; observe that both-down+subtype is also
3863     // &quot;fall hard&quot;; &quot;fall hard&quot; becomes the default case:
3864     // If we split one up &amp; one down AND they subtype, take the down man.
3865     // If both are up and they subtype, take the subtype class.
3866 
3867     // If both are down and they subtype, &quot;fall hard&quot;.
3868     // If both are down and they do NOT subtype, &quot;fall hard&quot;.
3869     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
3870     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
3871 
3872     // If a proper subtype is exact, and we return it, we return it exactly.
3873     // If a proper supertype is exact, there can be no subtyping relationship!
3874     // If both types are equal to the subtype, exactness is and-ed below the
3875     // centerline and or-ed above it.  (N.B. Constants are always exact.)
3876 
3877     // Check for subtyping:
3878     ciKlass *subtype = NULL;
3879     bool subtype_exact = false;
3880     if( tinst_klass-&gt;equals(this_klass) ) {
3881       subtype = this_klass;
<span class="line-modified">3882       subtype_exact = below_centerline(ptr) ? (this_xk &amp; tinst_xk) : (this_xk | tinst_xk);</span>
3883     } else if( !tinst_xk &amp;&amp; this_klass-&gt;is_subtype_of( tinst_klass ) ) {
3884       subtype = this_klass;     // Pick subtyping class
3885       subtype_exact = this_xk;
3886     } else if( !this_xk &amp;&amp; tinst_klass-&gt;is_subtype_of( this_klass ) ) {
3887       subtype = tinst_klass;    // Pick subtyping class
3888       subtype_exact = tinst_xk;
3889     }
3890 
3891     if( subtype ) {
3892       if( above_centerline(ptr) ) { // both are up?
3893         this_klass = tinst_klass = subtype;
3894         this_xk = tinst_xk = subtype_exact;
3895       } else if( above_centerline(this -&gt;_ptr) &amp;&amp; !above_centerline(tinst-&gt;_ptr) ) {
3896         this_klass = tinst_klass; // tinst is down; keep down man
3897         this_xk = tinst_xk;
3898       } else if( above_centerline(tinst-&gt;_ptr) &amp;&amp; !above_centerline(this -&gt;_ptr) ) {
3899         tinst_klass = this_klass; // this is down; keep down man
3900         tinst_xk = this_xk;
3901       } else {
3902         this_xk = subtype_exact;  // either they are equal, or we&#39;ll do an LCA
</pre>
<hr />
<pre>
4090 const Type *TypeAryPtr::cast_to_ptr_type(PTR ptr) const {
4091   if( ptr == _ptr ) return this;
4092   return make(ptr, const_oop(), _ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth);
4093 }
4094 
4095 
4096 //-----------------------------cast_to_exactness-------------------------------
4097 const Type *TypeAryPtr::cast_to_exactness(bool klass_is_exact) const {
4098   if( klass_is_exact == _klass_is_exact ) return this;
4099   if (!UseExactTypes)  return this;
4100   if (_ary-&gt;ary_must_be_exact())  return this;  // cannot clear xk
4101   return make(ptr(), const_oop(), _ary, klass(), klass_is_exact, _offset, _instance_id, _speculative, _inline_depth);
4102 }
4103 
4104 //-----------------------------cast_to_instance_id----------------------------
4105 const TypeOopPtr *TypeAryPtr::cast_to_instance_id(int instance_id) const {
4106   if( instance_id == _instance_id ) return this;
4107   return make(_ptr, const_oop(), _ary, klass(), _klass_is_exact, _offset, instance_id, _speculative, _inline_depth);
4108 }
4109 
<span class="line-removed">4110 const TypeOopPtr *TypeAryPtr::cast_to_nonconst() const {</span>
<span class="line-removed">4111   if (const_oop() == NULL) return this;</span>
<span class="line-removed">4112   return make(NotNull, NULL, _ary, klass(), _klass_is_exact, _offset, _instance_id, _speculative, _inline_depth);</span>
<span class="line-removed">4113 }</span>
4114 
<span class="line-modified">4115 </span>
<span class="line-modified">4116 //-----------------------------narrow_size_type-------------------------------</span>
<span class="line-modified">4117 // Local cache for arrayOopDesc::max_array_length(etype),</span>
<span class="line-modified">4118 // which is kind of slow (and cached elsewhere by other users).</span>
<span class="line-modified">4119 static jint max_array_length_cache[T_CONFLICT+1];</span>
<span class="line-removed">4120 static jint max_array_length(BasicType etype) {</span>
<span class="line-removed">4121   jint&amp; cache = max_array_length_cache[etype];</span>
<span class="line-removed">4122   jint res = cache;</span>
<span class="line-removed">4123   if (res == 0) {</span>
<span class="line-removed">4124     switch (etype) {</span>
<span class="line-removed">4125     case T_NARROWOOP:</span>
4126       etype = T_OBJECT;
<span class="line-modified">4127       break;</span>
<span class="line-modified">4128     case T_NARROWKLASS:</span>
<span class="line-modified">4129     case T_CONFLICT:</span>
<span class="line-modified">4130     case T_ILLEGAL:</span>
<span class="line-removed">4131     case T_VOID:</span>
<span class="line-removed">4132       etype = T_BYTE;           // will produce conservatively high value</span>
<span class="line-removed">4133       break;</span>
<span class="line-removed">4134     default:</span>
<span class="line-removed">4135       break;</span>
4136     }
<span class="line-removed">4137     cache = res = arrayOopDesc::max_array_length(etype);</span>
4138   }
<span class="line-modified">4139   return res;</span>
4140 }
4141 

4142 // Narrow the given size type to the index range for the given array base type.
4143 // Return NULL if the resulting int type becomes empty.
4144 const TypeInt* TypeAryPtr::narrow_size_type(const TypeInt* size) const {
4145   jint hi = size-&gt;_hi;
4146   jint lo = size-&gt;_lo;
4147   jint min_lo = 0;
4148   jint max_hi = max_array_length(elem()-&gt;basic_type());
4149   //if (index_not_size)  --max_hi;     // type of a valid array index, FTR
4150   bool chg = false;
4151   if (lo &lt; min_lo) {
4152     lo = min_lo;
4153     if (size-&gt;is_con()) {
4154       hi = lo;
4155     }
4156     chg = true;
4157   }
4158   if (hi &gt; max_hi) {
4159     hi = max_hi;
4160     if (size-&gt;is_con()) {
4161       lo = hi;
</pre>
<hr />
<pre>
4344           // both are exact and not equal:
4345           ((tap-&gt;_klass_is_exact &amp;&amp; this-&gt;_klass_is_exact) ||
4346            // &#39;tap&#39;  is exact and super or unrelated:
4347            (tap-&gt;_klass_is_exact &amp;&amp; !tap-&gt;klass()-&gt;is_subtype_of(klass())) ||
4348            // &#39;this&#39; is exact and super or unrelated:
4349            (this-&gt;_klass_is_exact &amp;&amp; !klass()-&gt;is_subtype_of(tap-&gt;klass())))) {
4350       if (above_centerline(ptr)) {
4351         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable);
4352       }
4353       return make(NotNull, NULL, tary, lazy_klass, false, off, InstanceBot, speculative, depth);
4354     }
4355 
4356     bool xk = false;
4357     switch (tap-&gt;ptr()) {
4358     case AnyNull:
4359     case TopPTR:
4360       // Compute new klass on demand, do not use tap-&gt;_klass
4361       if (below_centerline(this-&gt;_ptr)) {
4362         xk = this-&gt;_klass_is_exact;
4363       } else {
<span class="line-modified">4364         xk = (tap-&gt;_klass_is_exact | this-&gt;_klass_is_exact);</span>
4365       }
4366       return make(ptr, const_oop(), tary, lazy_klass, xk, off, instance_id, speculative, depth);
4367     case Constant: {
4368       ciObject* o = const_oop();
4369       if( _ptr == Constant ) {
4370         if( tap-&gt;const_oop() != NULL &amp;&amp; !o-&gt;equals(tap-&gt;const_oop()) ) {
4371           xk = (klass() == tap-&gt;klass());
4372           ptr = NotNull;
4373           o = NULL;
4374           instance_id = InstanceBot;
4375         } else {
4376           xk = true;
4377         }
4378       } else if(above_centerline(_ptr)) {
4379         o = tap-&gt;const_oop();
4380         xk = true;
4381       } else {
4382         // Only precise for identical arrays
4383         xk = this-&gt;_klass_is_exact &amp;&amp; (klass() == tap-&gt;klass());
4384       }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciMethodData.hpp&quot;
  27 #include &quot;ci/ciTypeFlow.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;compiler/compileLog.hpp&quot;
  31 #include &quot;libadt/dict.hpp&quot;
  32 #include &quot;memory/oopFactory.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
  34 #include &quot;oops/instanceKlass.hpp&quot;
  35 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  36 #include &quot;oops/objArrayKlass.hpp&quot;
  37 #include &quot;oops/typeArrayKlass.hpp&quot;
  38 #include &quot;opto/matcher.hpp&quot;
  39 #include &quot;opto/node.hpp&quot;
  40 #include &quot;opto/opcodes.hpp&quot;
  41 #include &quot;opto/type.hpp&quot;
<span class="line-added">  42 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  43 
  44 // Portions of code courtesy of Clifford Click
  45 
  46 // Optimization - Graph Style
  47 
  48 // Dictionary of types shared among compilations.
  49 Dict* Type::_shared_type_dict = NULL;
  50 
  51 // Array which maps compiler types to Basic Types
  52 const Type::TypeInfo Type::_type_info[Type::lastype] = {
  53   { Bad,             T_ILLEGAL,    &quot;bad&quot;,           false, Node::NotAMachineReg, relocInfo::none          },  // Bad
  54   { Control,         T_ILLEGAL,    &quot;control&quot;,       false, 0,                    relocInfo::none          },  // Control
  55   { Bottom,          T_VOID,       &quot;top&quot;,           false, 0,                    relocInfo::none          },  // Top
  56   { Bad,             T_INT,        &quot;int:&quot;,          false, Op_RegI,              relocInfo::none          },  // Int
  57   { Bad,             T_LONG,       &quot;long:&quot;,         false, Op_RegL,              relocInfo::none          },  // Long
  58   { Half,            T_VOID,       &quot;half&quot;,          false, 0,                    relocInfo::none          },  // Half
  59   { Bad,             T_NARROWOOP,  &quot;narrowoop:&quot;,    false, Op_RegN,              relocInfo::none          },  // NarrowOop
  60   { Bad,             T_NARROWKLASS,&quot;narrowklass:&quot;,  false, Op_RegN,              relocInfo::none          },  // NarrowKlass
  61   { Bad,             T_ILLEGAL,    &quot;tuple:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // Tuple
  62   { Bad,             T_ARRAY,      &quot;array:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // Array
</pre>
<hr />
<pre>
 359     field_value = field-&gt;constant_value_of(holder);
 360   }
 361   if (!field_value.is_valid()) {
 362     return NULL; // Not a constant
 363   }
 364 
 365   ciConstant con = check_mismatched_access(field_value, loadbt, is_unsigned_load);
 366 
 367   assert(con.is_valid(), &quot;elembt=%s; loadbt=%s; unsigned=%d&quot;,
 368          type2name(field_value.basic_type()), type2name(loadbt), is_unsigned_load);
 369 
 370   bool is_stable_array = FoldStableValues &amp;&amp; field-&gt;is_stable() &amp;&amp; field-&gt;type()-&gt;is_array_klass();
 371   int stable_dimension = (is_stable_array ? field-&gt;type()-&gt;as_array_klass()-&gt;dimension() : 0);
 372   bool is_narrow_oop = (loadbt == T_NARROWOOP);
 373 
 374   const Type* con_type = make_from_constant(con, /*require_constant=*/ true,
 375                                             stable_dimension, is_narrow_oop,
 376                                             field-&gt;is_autobox_cache());
 377   if (con_type != NULL &amp;&amp; field-&gt;is_call_site_target()) {
 378     ciCallSite* call_site = holder-&gt;as_call_site();
<span class="line-modified"> 379     if (!call_site-&gt;is_fully_initialized_constant_call_site()) {</span>
 380       ciMethodHandle* target = con.as_object()-&gt;as_method_handle();
 381       Compile::current()-&gt;dependencies()-&gt;assert_call_site_target_value(call_site, target);
 382     }
 383   }
 384   return con_type;
 385 }
 386 
 387 //------------------------------make-------------------------------------------
 388 // Create a simple Type, with default empty symbol sets.  Then hashcons it
 389 // and look for an existing copy in the type dictionary.
 390 const Type *Type::make( enum TYPES t ) {
 391   return (new Type(t))-&gt;hashcons();
 392 }
 393 
 394 //------------------------------cmp--------------------------------------------
 395 int Type::cmp( const Type *const t1, const Type *const t2 ) {
 396   if( t1-&gt;_base != t2-&gt;_base )
 397     return 1;                   // Missed badly
 398   assert(t1 != t2 || t1-&gt;eq(t2), &quot;eq must be reflexive&quot;);
 399   return !t1-&gt;eq(t2);           // Return ZERO if equal
 400 }
 401 
 402 const Type* Type::maybe_remove_speculative(bool include_speculative) const {
 403   if (!include_speculative) {
 404     return remove_speculative();
 405   }
 406   return this;
 407 }
 408 
 409 //------------------------------hash-------------------------------------------
 410 int Type::uhash( const Type *const t ) {
 411   return t-&gt;hash();
 412 }
 413 
 414 #define SMALLINT ((juint)3)  // a value too insignificant to consider widening
<span class="line-modified"> 415 #define POSITIVE_INFINITE_F 0x7f800000 // hex representation for IEEE 754 single precision positive infinite</span>
<span class="line-modified"> 416 #define POSITIVE_INFINITE_D 0x7ff0000000000000 // hex representation for IEEE 754 double precision positive infinite</span>










 417 
 418 //--------------------------Initialize_shared----------------------------------
 419 void Type::Initialize_shared(Compile* current) {
 420   // This method does not need to be locked because the first system
 421   // compilations (stub compilations) occur serially.  If they are
 422   // changed to proceed in parallel, then this section will need
 423   // locking.
 424 
 425   Arena* save = current-&gt;type_arena();
 426   Arena* shared_type_arena = new (mtCompiler)Arena(mtCompiler);
 427 
 428   current-&gt;set_type_arena(shared_type_arena);
 429   _shared_type_dict =
 430     new (shared_type_arena) Dict( (CmpKey)Type::cmp, (Hash)Type::uhash,
 431                                   shared_type_arena, 128 );
 432   current-&gt;set_type_dict(_shared_type_dict);
 433 
 434   // Make shared pre-built types.
 435   CONTROL = make(Control);      // Control only
 436   TOP     = make(Top);          // No values in set
 437   MEMORY  = make(Memory);       // Abstract store only
 438   ABIO    = make(Abio);         // State-of-machine only
 439   RETURN_ADDRESS=make(Return_Address);
 440   FLOAT   = make(FloatBot);     // All floats
 441   DOUBLE  = make(DoubleBot);    // All doubles
 442   BOTTOM  = make(Bottom);       // Everything
 443   HALF    = make(Half);         // Placeholder half of doublewide type
 444 
 445   TypeF::ZERO = TypeF::make(0.0); // Float 0 (positive zero)
 446   TypeF::ONE  = TypeF::make(1.0); // Float 1
<span class="line-modified"> 447   TypeF::POS_INF = TypeF::make(jfloat_cast(POSITIVE_INFINITE_F));</span>
<span class="line-modified"> 448   TypeF::NEG_INF = TypeF::make(-jfloat_cast(POSITIVE_INFINITE_F));</span>
 449 
 450   TypeD::ZERO = TypeD::make(0.0); // Double 0 (positive zero)
 451   TypeD::ONE  = TypeD::make(1.0); // Double 1
<span class="line-modified"> 452   TypeD::POS_INF = TypeD::make(jdouble_cast(POSITIVE_INFINITE_D));</span>
<span class="line-modified"> 453   TypeD::NEG_INF = TypeD::make(-jdouble_cast(POSITIVE_INFINITE_D));</span>
 454 
 455   TypeInt::MINUS_1 = TypeInt::make(-1);  // -1
 456   TypeInt::ZERO    = TypeInt::make( 0);  //  0
 457   TypeInt::ONE     = TypeInt::make( 1);  //  1
 458   TypeInt::BOOL    = TypeInt::make(0,1,   WidenMin);  // 0 or 1, FALSE or TRUE.
 459   TypeInt::CC      = TypeInt::make(-1, 1, WidenMin);  // -1, 0 or 1, condition codes
 460   TypeInt::CC_LT   = TypeInt::make(-1,-1, WidenMin);  // == TypeInt::MINUS_1
 461   TypeInt::CC_GT   = TypeInt::make( 1, 1, WidenMin);  // == TypeInt::ONE
 462   TypeInt::CC_EQ   = TypeInt::make( 0, 0, WidenMin);  // == TypeInt::ZERO
 463   TypeInt::CC_LE   = TypeInt::make(-1, 0, WidenMin);
 464   TypeInt::CC_GE   = TypeInt::make( 0, 1, WidenMin);  // == TypeInt::BOOL
 465   TypeInt::BYTE    = TypeInt::make(-128,127,     WidenMin); // Bytes
 466   TypeInt::UBYTE   = TypeInt::make(0, 255,       WidenMin); // Unsigned Bytes
 467   TypeInt::CHAR    = TypeInt::make(0,65535,      WidenMin); // Java chars
 468   TypeInt::SHORT   = TypeInt::make(-32768,32767, WidenMin); // Java shorts
 469   TypeInt::POS     = TypeInt::make(0,max_jint,   WidenMin); // Non-neg values
 470   TypeInt::POS1    = TypeInt::make(1,max_jint,   WidenMin); // Positive values
 471   TypeInt::INT     = TypeInt::make(min_jint,max_jint, WidenMax); // 32-bit integers
 472   TypeInt::SYMINT  = TypeInt::make(-max_jint,max_jint,WidenMin); // symmetric range
 473   TypeInt::TYPE_DOMAIN  = TypeInt::INT;
</pre>
<hr />
<pre>
 704 //------------------------------hashcons---------------------------------------
 705 // Do the hash-cons trick.  If the Type already exists in the type table,
 706 // delete the current Type and return the existing Type.  Otherwise stick the
 707 // current Type in the Type table.
 708 const Type *Type::hashcons(void) {
 709   debug_only(base());           // Check the assertion in Type::base().
 710   // Look up the Type in the Type dictionary
 711   Dict *tdic = type_dict();
 712   Type* old = (Type*)(tdic-&gt;Insert(this, this, false));
 713   if( old ) {                   // Pre-existing Type?
 714     if( old != this )           // Yes, this guy is not the pre-existing?
 715       delete this;              // Yes, Nuke this guy
 716     assert( old-&gt;_dual, &quot;&quot; );
 717     return old;                 // Return pre-existing
 718   }
 719 
 720   // Every type has a dual (to make my lattice symmetric).
 721   // Since we just discovered a new Type, compute its dual right now.
 722   assert( !_dual, &quot;&quot; );         // No dual yet
 723   _dual = xdual();              // Compute the dual
<span class="line-modified"> 724   if (cmp(this, _dual) == 0) {  // Handle self-symmetric</span>
<span class="line-modified"> 725     if (_dual != this) {</span>
<span class="line-added"> 726       delete _dual;</span>
<span class="line-added"> 727       _dual = this;</span>
<span class="line-added"> 728     }</span>
 729     return this;
 730   }
 731   assert( !_dual-&gt;_dual, &quot;&quot; );  // No reverse dual yet
 732   assert( !(*tdic)[_dual], &quot;&quot; ); // Dual not in type system either
 733   // New Type, insert into Type table
 734   tdic-&gt;Insert((void*)_dual,(void*)_dual);
 735   ((Type*)_dual)-&gt;_dual = this; // Finish up being symmetric
 736 #ifdef ASSERT
 737   Type *dual_dual = (Type*)_dual-&gt;xdual();
 738   assert( eq(dual_dual), &quot;xdual(xdual()) should be identity&quot; );
 739   delete dual_dual;
 740 #endif
 741   return this;                  // Return new Type
 742 }
 743 
 744 //------------------------------eq---------------------------------------------
 745 // Structural equality check for Type representations
 746 bool Type::eq( const Type * ) const {
 747   return true;                  // Nothing else can go wrong
 748 }
</pre>
<hr />
<pre>
2086 
2087 //------------------------------meet-------------------------------------------
2088 // Compute the MEET of two types.  It returns a new Type object.
2089 const Type *TypeAry::xmeet( const Type *t ) const {
2090   // Perform a fast test for common case; meeting the same types together.
2091   if( this == t ) return this;  // Meeting same type-rep?
2092 
2093   // Current &quot;this-&gt;_base&quot; is Ary
2094   switch (t-&gt;base()) {          // switch on original type
2095 
2096   case Bottom:                  // Ye Olde Default
2097     return t;
2098 
2099   default:                      // All else is a mistake
2100     typerr(t);
2101 
2102   case Array: {                 // Meeting 2 arrays?
2103     const TypeAry *a = t-&gt;is_ary();
2104     return TypeAry::make(_elem-&gt;meet_speculative(a-&gt;_elem),
2105                          _size-&gt;xmeet(a-&gt;_size)-&gt;is_int(),
<span class="line-modified">2106                          _stable &amp;&amp; a-&gt;_stable);</span>
2107   }
2108   case Top:
2109     break;
2110   }
2111   return this;                  // Return the double constant
2112 }
2113 
2114 //------------------------------xdual------------------------------------------
2115 // Dual: compute field-by-field dual
2116 const Type *TypeAry::xdual() const {
2117   const TypeInt* size_dual = _size-&gt;dual()-&gt;is_int();
2118   size_dual = normalize_array_size(size_dual);
2119   return new TypeAry(_elem-&gt;dual(), size_dual, !_stable);
2120 }
2121 
2122 //------------------------------eq---------------------------------------------
2123 // Structural equality check for Type representations
2124 bool TypeAry::eq( const Type *t ) const {
2125   const TypeAry *a = (const TypeAry*)t;
2126   return _elem == a-&gt;_elem &amp;&amp;
</pre>
<hr />
<pre>
2988       } else if (_offset == OffsetBot || _offset == OffsetTop) {
2989         // unsafe access
2990         _is_ptr_to_narrowoop = UseCompressedOops;
2991       } else { // exclude unsafe ops
2992         assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
2993 
2994         if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
2995             (_offset == java_lang_Class::klass_offset_in_bytes() ||
2996              _offset == java_lang_Class::array_klass_offset_in_bytes())) {
2997           // Special hidden fields from the Class.
2998           assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
2999           _is_ptr_to_narrowoop = false;
3000         } else if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
3001                    _offset &gt;= InstanceMirrorKlass::offset_of_static_fields()) {
3002           // Static fields
3003           assert(o != NULL, &quot;must be constant&quot;);
3004           ciInstanceKlass* k = o-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();
3005           ciField* field = k-&gt;get_field_by_offset(_offset, true);
3006           assert(field != NULL, &quot;missing field&quot;);
3007           BasicType basic_elem_type = field-&gt;layout_type();
<span class="line-modified">3008           _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);</span>

3009         } else {
3010           // Instance fields which contains a compressed oop references.
3011           field = ik-&gt;get_field_by_offset(_offset, false);
3012           if (field != NULL) {
3013             BasicType basic_elem_type = field-&gt;layout_type();
<span class="line-modified">3014             _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);</span>

3015           } else if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass())) {
3016             // Compile::find_alias_type() cast exactness on all types to verify
3017             // that it does not affect alias type.
3018             _is_ptr_to_narrowoop = UseCompressedOops;
3019           } else {
3020             // Type for the copy start in LibraryCallKit::inline_native_clone().
3021             _is_ptr_to_narrowoop = UseCompressedOops;
3022           }
3023         }
3024       }
3025     }
3026   }
3027 #endif
3028 }
3029 
3030 //------------------------------make-------------------------------------------
3031 const TypeOopPtr *TypeOopPtr::make(PTR ptr, int offset, int instance_id,
3032                                      const TypePtr* speculative, int inline_depth) {
3033   assert(ptr != Constant, &quot;no constant generic pointers&quot;);
3034   ciKlass*  k = Compile::current()-&gt;env()-&gt;Object_klass();
3035   bool      xk = false;
3036   ciObject* o = NULL;
3037   return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, xk, o, offset, instance_id, speculative, inline_depth))-&gt;hashcons();
3038 }
3039 
3040 
3041 //------------------------------cast_to_ptr_type-------------------------------
3042 const Type *TypeOopPtr::cast_to_ptr_type(PTR ptr) const {
3043   assert(_base == OopPtr, &quot;subclass must override cast_to_ptr_type&quot;);
3044   if( ptr == _ptr ) return this;
3045   return make(ptr, _offset, _instance_id, _speculative, _inline_depth);
3046 }
3047 
3048 //-----------------------------cast_to_instance_id----------------------------
3049 const TypeOopPtr *TypeOopPtr::cast_to_instance_id(int instance_id) const {
3050   // There are no instances of a general oop.
3051   // Return self unchanged.
3052   return this;
3053 }
3054 




3055 //-----------------------------cast_to_exactness-------------------------------
3056 const Type *TypeOopPtr::cast_to_exactness(bool klass_is_exact) const {
3057   // There is no such thing as an exact general oop.
3058   // Return self unchanged.
3059   return this;
3060 }
3061 
3062 
3063 //------------------------------as_klass_type----------------------------------
3064 // Return the klass type corresponding to this instance or array type.
3065 // It is the type that is loaded from an object of this type.
3066 const TypeKlassPtr* TypeOopPtr::as_klass_type() const {
3067   ciKlass* k = klass();
3068   bool    xk = klass_is_exact();
3069   if (k == NULL)
3070     return TypeKlassPtr::OBJECT;
3071   else
3072     return TypeKlassPtr::make(xk? Constant: NotNull, k, 0);
3073 }
3074 
</pre>
<hr />
<pre>
3541 }
3542 
3543 
3544 //-----------------------------cast_to_exactness-------------------------------
3545 const Type *TypeInstPtr::cast_to_exactness(bool klass_is_exact) const {
3546   if( klass_is_exact == _klass_is_exact ) return this;
3547   if (!UseExactTypes)  return this;
3548   if (!_klass-&gt;is_loaded())  return this;
3549   ciInstanceKlass* ik = _klass-&gt;as_instance_klass();
3550   if( (ik-&gt;is_final() || _const_oop) )  return this;  // cannot clear xk
3551   if( ik-&gt;is_interface() )              return this;  // cannot set xk
3552   return make(ptr(), klass(), klass_is_exact, const_oop(), _offset, _instance_id, _speculative, _inline_depth);
3553 }
3554 
3555 //-----------------------------cast_to_instance_id----------------------------
3556 const TypeOopPtr *TypeInstPtr::cast_to_instance_id(int instance_id) const {
3557   if( instance_id == _instance_id ) return this;
3558   return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, instance_id, _speculative, _inline_depth);
3559 }
3560 





3561 //------------------------------xmeet_unloaded---------------------------------
3562 // Compute the MEET of two InstPtrs when at least one is unloaded.
3563 // Assume classes are different since called after check for same name/class-loader
3564 const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst) const {
3565     int off = meet_offset(tinst-&gt;offset());
3566     PTR ptr = meet_ptr(tinst-&gt;ptr());
3567     int instance_id = meet_instance_id(tinst-&gt;instance_id());
3568     const TypePtr* speculative = xmeet_speculative(tinst);
3569     int depth = meet_inline_depth(tinst-&gt;inline_depth());
3570 
3571     const TypeInstPtr *loaded    = is_loaded() ? this  : tinst;
3572     const TypeInstPtr *unloaded  = is_loaded() ? tinst : this;
3573     if( loaded-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) ) {
3574       //
3575       // Meet unloaded class with java/lang/Object
3576       //
3577       // Meet
3578       //          |                     Unloaded Class
3579       //  Object  |   TOP    |   AnyNull | Constant |   NotNull |  BOTTOM   |
3580       //  ===================================================================
</pre>
<hr />
<pre>
3845     // Now, reorder the above list; observe that both-down+subtype is also
3846     // &quot;fall hard&quot;; &quot;fall hard&quot; becomes the default case:
3847     // If we split one up &amp; one down AND they subtype, take the down man.
3848     // If both are up and they subtype, take the subtype class.
3849 
3850     // If both are down and they subtype, &quot;fall hard&quot;.
3851     // If both are down and they do NOT subtype, &quot;fall hard&quot;.
3852     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
3853     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
3854 
3855     // If a proper subtype is exact, and we return it, we return it exactly.
3856     // If a proper supertype is exact, there can be no subtyping relationship!
3857     // If both types are equal to the subtype, exactness is and-ed below the
3858     // centerline and or-ed above it.  (N.B. Constants are always exact.)
3859 
3860     // Check for subtyping:
3861     ciKlass *subtype = NULL;
3862     bool subtype_exact = false;
3863     if( tinst_klass-&gt;equals(this_klass) ) {
3864       subtype = this_klass;
<span class="line-modified">3865       subtype_exact = below_centerline(ptr) ? (this_xk &amp;&amp; tinst_xk) : (this_xk || tinst_xk);</span>
3866     } else if( !tinst_xk &amp;&amp; this_klass-&gt;is_subtype_of( tinst_klass ) ) {
3867       subtype = this_klass;     // Pick subtyping class
3868       subtype_exact = this_xk;
3869     } else if( !this_xk &amp;&amp; tinst_klass-&gt;is_subtype_of( this_klass ) ) {
3870       subtype = tinst_klass;    // Pick subtyping class
3871       subtype_exact = tinst_xk;
3872     }
3873 
3874     if( subtype ) {
3875       if( above_centerline(ptr) ) { // both are up?
3876         this_klass = tinst_klass = subtype;
3877         this_xk = tinst_xk = subtype_exact;
3878       } else if( above_centerline(this -&gt;_ptr) &amp;&amp; !above_centerline(tinst-&gt;_ptr) ) {
3879         this_klass = tinst_klass; // tinst is down; keep down man
3880         this_xk = tinst_xk;
3881       } else if( above_centerline(tinst-&gt;_ptr) &amp;&amp; !above_centerline(this -&gt;_ptr) ) {
3882         tinst_klass = this_klass; // this is down; keep down man
3883         tinst_xk = this_xk;
3884       } else {
3885         this_xk = subtype_exact;  // either they are equal, or we&#39;ll do an LCA
</pre>
<hr />
<pre>
4073 const Type *TypeAryPtr::cast_to_ptr_type(PTR ptr) const {
4074   if( ptr == _ptr ) return this;
4075   return make(ptr, const_oop(), _ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth);
4076 }
4077 
4078 
4079 //-----------------------------cast_to_exactness-------------------------------
4080 const Type *TypeAryPtr::cast_to_exactness(bool klass_is_exact) const {
4081   if( klass_is_exact == _klass_is_exact ) return this;
4082   if (!UseExactTypes)  return this;
4083   if (_ary-&gt;ary_must_be_exact())  return this;  // cannot clear xk
4084   return make(ptr(), const_oop(), _ary, klass(), klass_is_exact, _offset, _instance_id, _speculative, _inline_depth);
4085 }
4086 
4087 //-----------------------------cast_to_instance_id----------------------------
4088 const TypeOopPtr *TypeAryPtr::cast_to_instance_id(int instance_id) const {
4089   if( instance_id == _instance_id ) return this;
4090   return make(_ptr, const_oop(), _ary, klass(), _klass_is_exact, _offset, instance_id, _speculative, _inline_depth);
4091 }
4092 




4093 
<span class="line-modified">4094 //-----------------------------max_array_length-------------------------------</span>
<span class="line-modified">4095 // A wrapper around arrayOopDesc::max_array_length(etype) with some input normalization.</span>
<span class="line-modified">4096 jint TypeAryPtr::max_array_length(BasicType etype) {</span>
<span class="line-modified">4097   if (!is_java_primitive(etype) &amp;&amp; !is_reference_type(etype)) {</span>
<span class="line-modified">4098     if (etype == T_NARROWOOP) {</span>






4099       etype = T_OBJECT;
<span class="line-modified">4100     } else if (etype == T_ILLEGAL) { // bottom[]</span>
<span class="line-modified">4101       etype = T_BYTE; // will produce conservatively high value</span>
<span class="line-modified">4102     } else {</span>
<span class="line-modified">4103       fatal(&quot;not an element type: %s&quot;, type2name(etype));</span>





4104     }

4105   }
<span class="line-modified">4106   return arrayOopDesc::max_array_length(etype);</span>
4107 }
4108 
<span class="line-added">4109 //-----------------------------narrow_size_type-------------------------------</span>
4110 // Narrow the given size type to the index range for the given array base type.
4111 // Return NULL if the resulting int type becomes empty.
4112 const TypeInt* TypeAryPtr::narrow_size_type(const TypeInt* size) const {
4113   jint hi = size-&gt;_hi;
4114   jint lo = size-&gt;_lo;
4115   jint min_lo = 0;
4116   jint max_hi = max_array_length(elem()-&gt;basic_type());
4117   //if (index_not_size)  --max_hi;     // type of a valid array index, FTR
4118   bool chg = false;
4119   if (lo &lt; min_lo) {
4120     lo = min_lo;
4121     if (size-&gt;is_con()) {
4122       hi = lo;
4123     }
4124     chg = true;
4125   }
4126   if (hi &gt; max_hi) {
4127     hi = max_hi;
4128     if (size-&gt;is_con()) {
4129       lo = hi;
</pre>
<hr />
<pre>
4312           // both are exact and not equal:
4313           ((tap-&gt;_klass_is_exact &amp;&amp; this-&gt;_klass_is_exact) ||
4314            // &#39;tap&#39;  is exact and super or unrelated:
4315            (tap-&gt;_klass_is_exact &amp;&amp; !tap-&gt;klass()-&gt;is_subtype_of(klass())) ||
4316            // &#39;this&#39; is exact and super or unrelated:
4317            (this-&gt;_klass_is_exact &amp;&amp; !klass()-&gt;is_subtype_of(tap-&gt;klass())))) {
4318       if (above_centerline(ptr)) {
4319         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable);
4320       }
4321       return make(NotNull, NULL, tary, lazy_klass, false, off, InstanceBot, speculative, depth);
4322     }
4323 
4324     bool xk = false;
4325     switch (tap-&gt;ptr()) {
4326     case AnyNull:
4327     case TopPTR:
4328       // Compute new klass on demand, do not use tap-&gt;_klass
4329       if (below_centerline(this-&gt;_ptr)) {
4330         xk = this-&gt;_klass_is_exact;
4331       } else {
<span class="line-modified">4332         xk = (tap-&gt;_klass_is_exact || this-&gt;_klass_is_exact);</span>
4333       }
4334       return make(ptr, const_oop(), tary, lazy_klass, xk, off, instance_id, speculative, depth);
4335     case Constant: {
4336       ciObject* o = const_oop();
4337       if( _ptr == Constant ) {
4338         if( tap-&gt;const_oop() != NULL &amp;&amp; !o-&gt;equals(tap-&gt;const_oop()) ) {
4339           xk = (klass() == tap-&gt;klass());
4340           ptr = NotNull;
4341           o = NULL;
4342           instance_id = InstanceBot;
4343         } else {
4344           xk = true;
4345         }
4346       } else if(above_centerline(_ptr)) {
4347         o = tap-&gt;const_oop();
4348         xk = true;
4349       } else {
4350         // Only precise for identical arrays
4351         xk = this-&gt;_klass_is_exact &amp;&amp; (klass() == tap-&gt;klass());
4352       }
</pre>
</td>
</tr>
</table>
<center><a href="superword.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="type.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
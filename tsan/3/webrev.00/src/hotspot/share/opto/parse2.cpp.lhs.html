<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/parse2.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciMethodData.hpp&quot;
  27 #include &quot;classfile/systemDictionary.hpp&quot;
  28 #include &quot;classfile/vmSymbols.hpp&quot;
  29 #include &quot;compiler/compileLog.hpp&quot;
  30 #include &quot;interpreter/linkResolver.hpp&quot;
  31 #include &quot;memory/resourceArea.hpp&quot;
  32 #include &quot;memory/universe.hpp&quot;
  33 #include &quot;oops/oop.inline.hpp&quot;
  34 #include &quot;opto/addnode.hpp&quot;
  35 #include &quot;opto/castnode.hpp&quot;
  36 #include &quot;opto/convertnode.hpp&quot;
  37 #include &quot;opto/divnode.hpp&quot;
  38 #include &quot;opto/idealGraphPrinter.hpp&quot;
  39 #include &quot;opto/matcher.hpp&quot;
  40 #include &quot;opto/memnode.hpp&quot;
  41 #include &quot;opto/mulnode.hpp&quot;
  42 #include &quot;opto/opaquenode.hpp&quot;
  43 #include &quot;opto/parse.hpp&quot;
  44 #include &quot;opto/runtime.hpp&quot;
  45 #include &quot;runtime/deoptimization.hpp&quot;
  46 #include &quot;runtime/sharedRuntime.hpp&quot;
  47 
  48 #ifndef PRODUCT
  49 extern int explicit_null_checks_inserted,
  50            explicit_null_checks_elided;
  51 #endif
  52 
  53 //---------------------------------array_load----------------------------------
  54 void Parse::array_load(BasicType bt) {
  55   const Type* elemtype = Type::TOP;
  56   bool big_val = bt == T_DOUBLE || bt == T_LONG;
<a name="1" id="anc1"></a><span class="line-modified">  57   Node* adr = array_addressing(bt, 0, &amp;elemtype);</span>
  58   if (stopped())  return;     // guaranteed null or range check
  59 
  60   pop();                      // index (already used)
  61   Node* array = pop();        // the array itself
  62 
  63   if (elemtype == TypeInt::BOOL) {
  64     bt = T_BOOLEAN;
<a name="2" id="anc2"></a><span class="line-removed">  65   } else if (bt == T_OBJECT) {</span>
<span class="line-removed">  66     elemtype = _gvn.type(array)-&gt;is_aryptr()-&gt;elem()-&gt;make_oopptr();</span>
  67   }
<a name="3" id="anc3"></a><span class="line-removed">  68 </span>
  69   const TypeAryPtr* adr_type = TypeAryPtr::get_array_body_type(bt);
  70 
  71   Node* ld = access_load_at(array, adr, adr_type, elemtype, bt,
  72                             IN_HEAP | IS_ARRAY | C2_CONTROL_DEPENDENT_LOAD);
  73   if (big_val) {
  74     push_pair(ld);
  75   } else {
  76     push(ld);
  77   }
  78 }
  79 
  80 
  81 //--------------------------------array_store----------------------------------
  82 void Parse::array_store(BasicType bt) {
  83   const Type* elemtype = Type::TOP;
  84   bool big_val = bt == T_DOUBLE || bt == T_LONG;
<a name="4" id="anc4"></a><span class="line-modified">  85   Node* adr = array_addressing(bt, big_val ? 2 : 1, &amp;elemtype);</span>
  86   if (stopped())  return;     // guaranteed null or range check
  87   if (bt == T_OBJECT) {
  88     array_store_check();
  89   }
  90   Node* val;                  // Oop to store
  91   if (big_val) {
  92     val = pop_pair();
  93   } else {
  94     val = pop();
  95   }
  96   pop();                      // index (already used)
  97   Node* array = pop();        // the array itself
  98 
  99   if (elemtype == TypeInt::BOOL) {
 100     bt = T_BOOLEAN;
<a name="5" id="anc5"></a><span class="line-removed"> 101   } else if (bt == T_OBJECT) {</span>
<span class="line-removed"> 102     elemtype = _gvn.type(array)-&gt;is_aryptr()-&gt;elem()-&gt;make_oopptr();</span>
 103   }
<a name="6" id="anc6"></a><span class="line-removed"> 104 </span>
 105   const TypeAryPtr* adr_type = TypeAryPtr::get_array_body_type(bt);
 106 
 107   access_store_at(array, adr, adr_type, val, elemtype, bt, MO_UNORDERED | IN_HEAP | IS_ARRAY);
 108 }
 109 
 110 
 111 //------------------------------array_addressing-------------------------------
 112 // Pull array and index from the stack.  Compute pointer-to-element.
<a name="7" id="anc7"></a><span class="line-modified"> 113 Node* Parse::array_addressing(BasicType type, int vals, const Type* *result2) {</span>
 114   Node *idx   = peek(0+vals);   // Get from stack without popping
 115   Node *ary   = peek(1+vals);   // in case of exception
 116 
 117   // Null check the array base, with correct stack contents
 118   ary = null_check(ary, T_ARRAY);
 119   // Compile-time detect of null-exception?
 120   if (stopped())  return top();
 121 
 122   const TypeAryPtr* arytype  = _gvn.type(ary)-&gt;is_aryptr();
 123   const TypeInt*    sizetype = arytype-&gt;size();
<a name="8" id="anc8"></a><span class="line-modified"> 124   const Type*       elemtype = arytype-&gt;elem();</span>
 125 
<a name="9" id="anc9"></a><span class="line-modified"> 126   if (UseUniqueSubclasses &amp;&amp; result2 != NULL) {</span>
 127     const Type* el = elemtype-&gt;make_ptr();
 128     if (el &amp;&amp; el-&gt;isa_instptr()) {
 129       const TypeInstPtr* toop = el-&gt;is_instptr();
 130       if (toop-&gt;klass()-&gt;as_instance_klass()-&gt;unique_concrete_subklass()) {
 131         // If we load from &quot;AbstractClass[]&quot; we must see &quot;ConcreteSubClass&quot;.
 132         const Type* subklass = Type::get_const_type(toop-&gt;klass());
 133         elemtype = subklass-&gt;join_speculative(el);
 134       }
 135     }
 136   }
 137 
 138   // Check for big class initializers with all constant offsets
 139   // feeding into a known-size array.
 140   const TypeInt* idxtype = _gvn.type(idx)-&gt;is_int();
 141   // See if the highest idx value is less than the lowest array bound,
 142   // and if the idx value cannot be negative:
 143   bool need_range_check = true;
 144   if (idxtype-&gt;_hi &lt; sizetype-&gt;_lo &amp;&amp; idxtype-&gt;_lo &gt;= 0) {
 145     need_range_check = false;
 146     if (C-&gt;log() != NULL)   C-&gt;log()-&gt;elem(&quot;observe that=&#39;!need_range_check&#39;&quot;);
 147   }
 148 
 149   ciKlass * arytype_klass = arytype-&gt;klass();
 150   if ((arytype_klass != NULL) &amp;&amp; (!arytype_klass-&gt;is_loaded())) {
 151     // Only fails for some -Xcomp runs
 152     // The class is unloaded.  We have to run this bytecode in the interpreter.
 153     uncommon_trap(Deoptimization::Reason_unloaded,
 154                   Deoptimization::Action_reinterpret,
 155                   arytype-&gt;klass(), &quot;!loaded array&quot;);
 156     return top();
 157   }
 158 
 159   // Do the range check
 160   if (GenerateRangeChecks &amp;&amp; need_range_check) {
 161     Node* tst;
 162     if (sizetype-&gt;_hi &lt;= 0) {
 163       // The greatest array bound is negative, so we can conclude that we&#39;re
 164       // compiling unreachable code, but the unsigned compare trick used below
 165       // only works with non-negative lengths.  Instead, hack &quot;tst&quot; to be zero so
 166       // the uncommon_trap path will always be taken.
 167       tst = _gvn.intcon(0);
 168     } else {
 169       // Range is constant in array-oop, so we can use the original state of mem
 170       Node* len = load_array_length(ary);
 171 
 172       // Test length vs index (standard trick using unsigned compare)
 173       Node* chk = _gvn.transform( new CmpUNode(idx, len) );
 174       BoolTest::mask btest = BoolTest::lt;
 175       tst = _gvn.transform( new BoolNode(chk, btest) );
 176     }
 177     RangeCheckNode* rc = new RangeCheckNode(control(), tst, PROB_MAX, COUNT_UNKNOWN);
 178     _gvn.set_type(rc, rc-&gt;Value(&amp;_gvn));
 179     if (!tst-&gt;is_Con()) {
 180       record_for_igvn(rc);
 181     }
 182     set_control(_gvn.transform(new IfTrueNode(rc)));
 183     // Branch to failure if out of bounds
 184     {
 185       PreserveJVMState pjvms(this);
 186       set_control(_gvn.transform(new IfFalseNode(rc)));
 187       if (C-&gt;allow_range_check_smearing()) {
 188         // Do not use builtin_throw, since range checks are sometimes
 189         // made more stringent by an optimistic transformation.
 190         // This creates &quot;tentative&quot; range checks at this point,
 191         // which are not guaranteed to throw exceptions.
 192         // See IfNode::Ideal, is_range_check, adjust_check.
 193         uncommon_trap(Deoptimization::Reason_range_check,
 194                       Deoptimization::Action_make_not_entrant,
 195                       NULL, &quot;range_check&quot;);
 196       } else {
 197         // If we have already recompiled with the range-check-widening
 198         // heroic optimization turned off, then we must really be throwing
 199         // range check exceptions.
 200         builtin_throw(Deoptimization::Reason_range_check, idx);
 201       }
 202     }
 203   }
 204   // Check for always knowing you are throwing a range-check exception
 205   if (stopped())  return top();
 206 
 207   // Make array address computation control dependent to prevent it
 208   // from floating above the range check during loop optimizations.
 209   Node* ptr = array_element_address(ary, idx, type, sizetype, control());
<a name="10" id="anc10"></a><span class="line-removed"> 210 </span>
<span class="line-removed"> 211   if (result2 != NULL)  *result2 = elemtype;</span>
<span class="line-removed"> 212 </span>
 213   assert(ptr != top(), &quot;top should go hand-in-hand with stopped&quot;);
 214 
 215   return ptr;
 216 }
 217 
 218 
 219 // returns IfNode
 220 IfNode* Parse::jump_if_fork_int(Node* a, Node* b, BoolTest::mask mask, float prob, float cnt) {
 221   Node   *cmp = _gvn.transform(new CmpINode(a, b)); // two cases: shiftcount &gt; 32 and shiftcount &lt;= 32
 222   Node   *tst = _gvn.transform(new BoolNode(cmp, mask));
 223   IfNode *iff = create_and_map_if(control(), tst, prob, cnt);
 224   return iff;
 225 }
 226 
 227 // return Region node
 228 Node* Parse::jump_if_join(Node* iffalse, Node* iftrue) {
 229   Node *region  = new RegionNode(3); // 2 results
 230   record_for_igvn(region);
 231   region-&gt;init_req(1, iffalse);
 232   region-&gt;init_req(2, iftrue );
 233   _gvn.set_type(region, Type::CONTROL);
 234   region = _gvn.transform(region);
 235   set_control (region);
 236   return region;
 237 }
 238 
 239 // sentinel value for the target bci to mark never taken branches
 240 // (according to profiling)
 241 static const int never_reached = INT_MAX;
 242 
 243 //------------------------------helper for tableswitch-------------------------
 244 void Parse::jump_if_true_fork(IfNode *iff, int dest_bci_if_true, int prof_table_index, bool unc) {
 245   // True branch, use existing map info
 246   { PreserveJVMState pjvms(this);
 247     Node *iftrue  = _gvn.transform( new IfTrueNode (iff) );
 248     set_control( iftrue );
 249     if (unc) {
 250       repush_if_args();
 251       uncommon_trap(Deoptimization::Reason_unstable_if,
 252                     Deoptimization::Action_reinterpret,
 253                     NULL,
 254                     &quot;taken always&quot;);
 255     } else {
 256       assert(dest_bci_if_true != never_reached, &quot;inconsistent dest&quot;);
 257       profile_switch_case(prof_table_index);
 258       merge_new_path(dest_bci_if_true);
 259     }
 260   }
 261 
 262   // False branch
 263   Node *iffalse = _gvn.transform( new IfFalseNode(iff) );
 264   set_control( iffalse );
 265 }
 266 
 267 void Parse::jump_if_false_fork(IfNode *iff, int dest_bci_if_true, int prof_table_index, bool unc) {
 268   // True branch, use existing map info
 269   { PreserveJVMState pjvms(this);
 270     Node *iffalse  = _gvn.transform( new IfFalseNode (iff) );
 271     set_control( iffalse );
 272     if (unc) {
 273       repush_if_args();
 274       uncommon_trap(Deoptimization::Reason_unstable_if,
 275                     Deoptimization::Action_reinterpret,
 276                     NULL,
 277                     &quot;taken never&quot;);
 278     } else {
 279       assert(dest_bci_if_true != never_reached, &quot;inconsistent dest&quot;);
 280       profile_switch_case(prof_table_index);
 281       merge_new_path(dest_bci_if_true);
 282     }
 283   }
 284 
 285   // False branch
 286   Node *iftrue = _gvn.transform( new IfTrueNode(iff) );
 287   set_control( iftrue );
 288 }
 289 
 290 void Parse::jump_if_always_fork(int dest_bci, int prof_table_index, bool unc) {
 291   // False branch, use existing map and control()
 292   if (unc) {
 293     repush_if_args();
 294     uncommon_trap(Deoptimization::Reason_unstable_if,
 295                   Deoptimization::Action_reinterpret,
 296                   NULL,
 297                   &quot;taken never&quot;);
 298   } else {
 299     assert(dest_bci != never_reached, &quot;inconsistent dest&quot;);
 300     profile_switch_case(prof_table_index);
 301     merge_new_path(dest_bci);
 302   }
 303 }
 304 
 305 
 306 extern &quot;C&quot; {
 307   static int jint_cmp(const void *i, const void *j) {
 308     int a = *(jint *)i;
 309     int b = *(jint *)j;
 310     return a &gt; b ? 1 : a &lt; b ? -1 : 0;
 311   }
 312 }
 313 
 314 
 315 // Default value for methodData switch indexing. Must be a negative value to avoid
 316 // conflict with any legal switch index.
 317 #define NullTableIndex -1
 318 
 319 class SwitchRange : public StackObj {
 320   // a range of integers coupled with a bci destination
 321   jint _lo;                     // inclusive lower limit
 322   jint _hi;                     // inclusive upper limit
 323   int _dest;
 324   int _table_index;             // index into method data table
 325   float _cnt;                   // how many times this range was hit according to profiling
 326 
 327 public:
 328   jint lo() const              { return _lo;   }
 329   jint hi() const              { return _hi;   }
 330   int  dest() const            { return _dest; }
 331   int  table_index() const     { return _table_index; }
 332   bool is_singleton() const    { return _lo == _hi; }
 333   float cnt() const            { return _cnt; }
 334 
 335   void setRange(jint lo, jint hi, int dest, int table_index, float cnt) {
 336     assert(lo &lt;= hi, &quot;must be a non-empty range&quot;);
 337     _lo = lo, _hi = hi; _dest = dest; _table_index = table_index; _cnt = cnt;
 338     assert(_cnt &gt;= 0, &quot;&quot;);
 339   }
 340   bool adjoinRange(jint lo, jint hi, int dest, int table_index, float cnt, bool trim_ranges) {
 341     assert(lo &lt;= hi, &quot;must be a non-empty range&quot;);
 342     if (lo == _hi+1 &amp;&amp; table_index == _table_index) {
 343       // see merge_ranges() comment below
 344       if (trim_ranges) {
 345         if (cnt == 0) {
 346           if (_cnt != 0) {
 347             return false;
 348           }
 349           if (dest != _dest) {
 350             _dest = never_reached;
 351           }
 352         } else {
 353           if (_cnt == 0) {
 354             return false;
 355           }
 356           if (dest != _dest) {
 357             return false;
 358           }
 359         }
 360       } else {
 361         if (dest != _dest) {
 362           return false;
 363         }
 364       }
 365       _hi = hi;
 366       _cnt += cnt;
 367       return true;
 368     }
 369     return false;
 370   }
 371 
 372   void set (jint value, int dest, int table_index, float cnt) {
 373     setRange(value, value, dest, table_index, cnt);
 374   }
 375   bool adjoin(jint value, int dest, int table_index, float cnt, bool trim_ranges) {
 376     return adjoinRange(value, value, dest, table_index, cnt, trim_ranges);
 377   }
 378   bool adjoin(SwitchRange&amp; other) {
 379     return adjoinRange(other._lo, other._hi, other._dest, other._table_index, other._cnt, false);
 380   }
 381 
 382   void print() {
 383     if (is_singleton())
 384       tty-&gt;print(&quot; {%d}=&gt;%d (cnt=%f)&quot;, lo(), dest(), cnt());
 385     else if (lo() == min_jint)
 386       tty-&gt;print(&quot; {..%d}=&gt;%d (cnt=%f)&quot;, hi(), dest(), cnt());
 387     else if (hi() == max_jint)
 388       tty-&gt;print(&quot; {%d..}=&gt;%d (cnt=%f)&quot;, lo(), dest(), cnt());
 389     else
 390       tty-&gt;print(&quot; {%d..%d}=&gt;%d (cnt=%f)&quot;, lo(), hi(), dest(), cnt());
 391   }
 392 };
 393 
 394 // We try to minimize the number of ranges and the size of the taken
 395 // ones using profiling data. When ranges are created,
 396 // SwitchRange::adjoinRange() only allows 2 adjoining ranges to merge
 397 // if both were never hit or both were hit to build longer unreached
 398 // ranges. Here, we now merge adjoining ranges with the same
 399 // destination and finally set destination of unreached ranges to the
 400 // special value never_reached because it can help minimize the number
 401 // of tests that are necessary.
 402 //
 403 // For instance:
 404 // [0, 1] to target1 sometimes taken
 405 // [1, 2] to target1 never taken
 406 // [2, 3] to target2 never taken
 407 // would lead to:
 408 // [0, 1] to target1 sometimes taken
 409 // [1, 3] never taken
 410 //
 411 // (first 2 ranges to target1 are not merged)
 412 static void merge_ranges(SwitchRange* ranges, int&amp; rp) {
 413   if (rp == 0) {
 414     return;
 415   }
 416   int shift = 0;
 417   for (int j = 0; j &lt; rp; j++) {
 418     SwitchRange&amp; r1 = ranges[j-shift];
 419     SwitchRange&amp; r2 = ranges[j+1];
 420     if (r1.adjoin(r2)) {
 421       shift++;
 422     } else if (shift &gt; 0) {
 423       ranges[j+1-shift] = r2;
 424     }
 425   }
 426   rp -= shift;
 427   for (int j = 0; j &lt;= rp; j++) {
 428     SwitchRange&amp; r = ranges[j];
 429     if (r.cnt() == 0 &amp;&amp; r.dest() != never_reached) {
 430       r.setRange(r.lo(), r.hi(), never_reached, r.table_index(), r.cnt());
 431     }
 432   }
 433 }
 434 
 435 //-------------------------------do_tableswitch--------------------------------
 436 void Parse::do_tableswitch() {
 437   Node* lookup = pop();
 438   // Get information about tableswitch
 439   int default_dest = iter().get_dest_table(0);
 440   int lo_index     = iter().get_int_table(1);
 441   int hi_index     = iter().get_int_table(2);
 442   int len          = hi_index - lo_index + 1;
 443 
 444   if (len &lt; 1) {
 445     // If this is a backward branch, add safepoint
 446     maybe_add_safepoint(default_dest);
 447     merge(default_dest);
 448     return;
 449   }
 450 
 451   ciMethodData* methodData = method()-&gt;method_data();
 452   ciMultiBranchData* profile = NULL;
 453   if (methodData-&gt;is_mature() &amp;&amp; UseSwitchProfiling) {
 454     ciProfileData* data = methodData-&gt;bci_to_data(bci());
 455     if (data != NULL &amp;&amp; data-&gt;is_MultiBranchData()) {
 456       profile = (ciMultiBranchData*)data;
 457     }
 458   }
 459   bool trim_ranges = !method_data_update() &amp;&amp; !C-&gt;too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if);
 460 
 461   // generate decision tree, using trichotomy when possible
 462   int rnum = len+2;
 463   bool makes_backward_branch = false;
 464   SwitchRange* ranges = NEW_RESOURCE_ARRAY(SwitchRange, rnum);
 465   int rp = -1;
 466   if (lo_index != min_jint) {
 467     uint cnt = 1;
 468     if (profile != NULL) {
 469       cnt = profile-&gt;default_count() / (hi_index != max_jint ? 2 : 1);
 470     }
 471     ranges[++rp].setRange(min_jint, lo_index-1, default_dest, NullTableIndex, cnt);
 472   }
 473   for (int j = 0; j &lt; len; j++) {
 474     jint match_int = lo_index+j;
 475     int  dest      = iter().get_dest_table(j+3);
 476     makes_backward_branch |= (dest &lt;= bci());
 477     int  table_index = method_data_update() ? j : NullTableIndex;
 478     uint cnt = 1;
 479     if (profile != NULL) {
 480       cnt = profile-&gt;count_at(j);
 481     }
 482     if (rp &lt; 0 || !ranges[rp].adjoin(match_int, dest, table_index, cnt, trim_ranges)) {
 483       ranges[++rp].set(match_int, dest, table_index, cnt);
 484     }
 485   }
 486   jint highest = lo_index+(len-1);
 487   assert(ranges[rp].hi() == highest, &quot;&quot;);
 488   if (highest != max_jint) {
 489     uint cnt = 1;
 490     if (profile != NULL) {
 491       cnt = profile-&gt;default_count() / (lo_index != min_jint ? 2 : 1);
 492     }
 493     if (!ranges[rp].adjoinRange(highest+1, max_jint, default_dest, NullTableIndex, cnt, trim_ranges)) {
 494       ranges[++rp].setRange(highest+1, max_jint, default_dest, NullTableIndex, cnt);
 495     }
 496   }
 497   assert(rp &lt; len+2, &quot;not too many ranges&quot;);
 498 
 499   if (trim_ranges) {
 500     merge_ranges(ranges, rp);
 501   }
 502 
 503   // Safepoint in case if backward branch observed
 504   if( makes_backward_branch &amp;&amp; UseLoopSafepoints )
 505     add_safepoint();
 506 
 507   jump_switch_ranges(lookup, &amp;ranges[0], &amp;ranges[rp]);
 508 }
 509 
 510 
 511 //------------------------------do_lookupswitch--------------------------------
 512 void Parse::do_lookupswitch() {
 513   Node *lookup = pop();         // lookup value
 514   // Get information about lookupswitch
 515   int default_dest = iter().get_dest_table(0);
 516   int len          = iter().get_int_table(1);
 517 
 518   if (len &lt; 1) {    // If this is a backward branch, add safepoint
 519     maybe_add_safepoint(default_dest);
 520     merge(default_dest);
 521     return;
 522   }
 523 
 524   ciMethodData* methodData = method()-&gt;method_data();
 525   ciMultiBranchData* profile = NULL;
 526   if (methodData-&gt;is_mature() &amp;&amp; UseSwitchProfiling) {
 527     ciProfileData* data = methodData-&gt;bci_to_data(bci());
 528     if (data != NULL &amp;&amp; data-&gt;is_MultiBranchData()) {
 529       profile = (ciMultiBranchData*)data;
 530     }
 531   }
 532   bool trim_ranges = !method_data_update() &amp;&amp; !C-&gt;too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if);
 533 
 534   // generate decision tree, using trichotomy when possible
 535   jint* table = NEW_RESOURCE_ARRAY(jint, len*3);
 536   {
 537     for (int j = 0; j &lt; len; j++) {
 538       table[3*j+0] = iter().get_int_table(2+2*j);
 539       table[3*j+1] = iter().get_dest_table(2+2*j+1);
 540       table[3*j+2] = profile == NULL ? 1 : profile-&gt;count_at(j);
 541     }
 542     qsort(table, len, 3*sizeof(table[0]), jint_cmp);
 543   }
 544 
 545   float defaults = 0;
 546   jint prev = min_jint;
 547   for (int j = 0; j &lt; len; j++) {
 548     jint match_int = table[3*j+0];
 549     if (match_int != prev) {
 550       defaults += (float)match_int - prev;
 551     }
 552     prev = match_int+1;
 553   }
 554   if (prev-1 != max_jint) {
 555     defaults += (float)max_jint - prev + 1;
 556   }
 557   float default_cnt = 1;
 558   if (profile != NULL) {
 559     default_cnt = profile-&gt;default_count()/defaults;
 560   }
 561 
 562   int rnum = len*2+1;
 563   bool makes_backward_branch = false;
 564   SwitchRange* ranges = NEW_RESOURCE_ARRAY(SwitchRange, rnum);
 565   int rp = -1;
 566   for (int j = 0; j &lt; len; j++) {
 567     jint match_int   = table[3*j+0];
 568     int  dest        = table[3*j+1];
 569     int  cnt         = table[3*j+2];
 570     int  next_lo     = rp &lt; 0 ? min_jint : ranges[rp].hi()+1;
 571     int  table_index = method_data_update() ? j : NullTableIndex;
 572     makes_backward_branch |= (dest &lt;= bci());
 573     float c = default_cnt * ((float)match_int - next_lo);
 574     if (match_int != next_lo &amp;&amp; (rp &lt; 0 || !ranges[rp].adjoinRange(next_lo, match_int-1, default_dest, NullTableIndex, c, trim_ranges))) {
 575       assert(default_dest != never_reached, &quot;sentinel value for dead destinations&quot;);
 576       ranges[++rp].setRange(next_lo, match_int-1, default_dest, NullTableIndex, c);
 577     }
 578     if (rp &lt; 0 || !ranges[rp].adjoin(match_int, dest, table_index, cnt, trim_ranges)) {
 579       assert(dest != never_reached, &quot;sentinel value for dead destinations&quot;);
 580       ranges[++rp].set(match_int, dest, table_index, cnt);
 581     }
 582   }
 583   jint highest = table[3*(len-1)];
 584   assert(ranges[rp].hi() == highest, &quot;&quot;);
 585   if (highest != max_jint &amp;&amp;
 586       !ranges[rp].adjoinRange(highest+1, max_jint, default_dest, NullTableIndex, default_cnt * ((float)max_jint - highest), trim_ranges)) {
 587     ranges[++rp].setRange(highest+1, max_jint, default_dest, NullTableIndex, default_cnt * ((float)max_jint - highest));
 588   }
 589   assert(rp &lt; rnum, &quot;not too many ranges&quot;);
 590 
 591   if (trim_ranges) {
 592     merge_ranges(ranges, rp);
 593   }
 594 
 595   // Safepoint in case backward branch observed
 596   if (makes_backward_branch &amp;&amp; UseLoopSafepoints)
 597     add_safepoint();
 598 
 599   jump_switch_ranges(lookup, &amp;ranges[0], &amp;ranges[rp]);
 600 }
 601 
 602 static float if_prob(float taken_cnt, float total_cnt) {
 603   assert(taken_cnt &lt;= total_cnt, &quot;&quot;);
 604   if (total_cnt == 0) {
 605     return PROB_FAIR;
 606   }
 607   float p = taken_cnt / total_cnt;
<a name="11" id="anc11"></a><span class="line-modified"> 608   return MIN2(MAX2(p, PROB_MIN), PROB_MAX);</span>
 609 }
 610 
 611 static float if_cnt(float cnt) {
 612   if (cnt == 0) {
 613     return COUNT_UNKNOWN;
 614   }
 615   return cnt;
 616 }
 617 
 618 static float sum_of_cnts(SwitchRange *lo, SwitchRange *hi) {
 619   float total_cnt = 0;
 620   for (SwitchRange* sr = lo; sr &lt;= hi; sr++) {
 621     total_cnt += sr-&gt;cnt();
 622   }
 623   return total_cnt;
 624 }
 625 
 626 class SwitchRanges : public ResourceObj {
 627 public:
 628   SwitchRange* _lo;
 629   SwitchRange* _hi;
 630   SwitchRange* _mid;
 631   float _cost;
 632 
 633   enum {
 634     Start,
 635     LeftDone,
 636     RightDone,
 637     Done
 638   } _state;
 639 
 640   SwitchRanges(SwitchRange *lo, SwitchRange *hi)
 641     : _lo(lo), _hi(hi), _mid(NULL),
 642       _cost(0), _state(Start) {
 643   }
 644 
 645   SwitchRanges()
 646     : _lo(NULL), _hi(NULL), _mid(NULL),
 647       _cost(0), _state(Start) {}
 648 };
 649 
 650 // Estimate cost of performing a binary search on lo..hi
 651 static float compute_tree_cost(SwitchRange *lo, SwitchRange *hi, float total_cnt) {
 652   GrowableArray&lt;SwitchRanges&gt; tree;
 653   SwitchRanges root(lo, hi);
 654   tree.push(root);
 655 
 656   float cost = 0;
 657   do {
 658     SwitchRanges&amp; r = *tree.adr_at(tree.length()-1);
 659     if (r._hi != r._lo) {
 660       if (r._mid == NULL) {
 661         float r_cnt = sum_of_cnts(r._lo, r._hi);
 662 
 663         if (r_cnt == 0) {
 664           tree.pop();
 665           cost = 0;
 666           continue;
 667         }
 668 
 669         SwitchRange* mid = NULL;
 670         mid = r._lo;
 671         for (float cnt = 0; ; ) {
 672           assert(mid &lt;= r._hi, &quot;out of bounds&quot;);
 673           cnt += mid-&gt;cnt();
 674           if (cnt &gt; r_cnt / 2) {
 675             break;
 676           }
 677           mid++;
 678         }
 679         assert(mid &lt;= r._hi, &quot;out of bounds&quot;);
 680         r._mid = mid;
 681         r._cost = r_cnt / total_cnt;
 682       }
 683       r._cost += cost;
 684       if (r._state &lt; SwitchRanges::LeftDone &amp;&amp; r._mid &gt; r._lo) {
 685         cost = 0;
 686         r._state = SwitchRanges::LeftDone;
 687         tree.push(SwitchRanges(r._lo, r._mid-1));
 688       } else if (r._state &lt; SwitchRanges::RightDone) {
 689         cost = 0;
 690         r._state = SwitchRanges::RightDone;
 691         tree.push(SwitchRanges(r._mid == r._lo ? r._mid+1 : r._mid, r._hi));
 692       } else {
 693         tree.pop();
 694         cost = r._cost;
 695       }
 696     } else {
 697       tree.pop();
 698       cost = r._cost;
 699     }
 700   } while (tree.length() &gt; 0);
 701 
 702 
 703   return cost;
 704 }
 705 
 706 // It sometimes pays off to test most common ranges before the binary search
 707 void Parse::linear_search_switch_ranges(Node* key_val, SwitchRange*&amp; lo, SwitchRange*&amp; hi) {
 708   uint nr = hi - lo + 1;
 709   float total_cnt = sum_of_cnts(lo, hi);
 710 
 711   float min = compute_tree_cost(lo, hi, total_cnt);
 712   float extra = 1;
 713   float sub = 0;
 714 
 715   SwitchRange* array1 = lo;
 716   SwitchRange* array2 = NEW_RESOURCE_ARRAY(SwitchRange, nr);
 717 
 718   SwitchRange* ranges = NULL;
 719 
 720   while (nr &gt;= 2) {
 721     assert(lo == array1 || lo == array2, &quot;one the 2 already allocated arrays&quot;);
 722     ranges = (lo == array1) ? array2 : array1;
 723 
 724     // Find highest frequency range
 725     SwitchRange* candidate = lo;
 726     for (SwitchRange* sr = lo+1; sr &lt;= hi; sr++) {
 727       if (sr-&gt;cnt() &gt; candidate-&gt;cnt()) {
 728         candidate = sr;
 729       }
 730     }
 731     SwitchRange most_freq = *candidate;
 732     if (most_freq.cnt() == 0) {
 733       break;
 734     }
 735 
 736     // Copy remaining ranges into another array
 737     int shift = 0;
 738     for (uint i = 0; i &lt; nr; i++) {
 739       SwitchRange* sr = &amp;lo[i];
 740       if (sr != candidate) {
 741         ranges[i-shift] = *sr;
 742       } else {
 743         shift++;
 744         if (i &gt; 0 &amp;&amp; i &lt; nr-1) {
 745           SwitchRange prev = lo[i-1];
 746           prev.setRange(prev.lo(), sr-&gt;hi(), prev.dest(), prev.table_index(), prev.cnt());
 747           if (prev.adjoin(lo[i+1])) {
 748             shift++;
 749             i++;
 750           }
 751           ranges[i-shift] = prev;
 752         }
 753       }
 754     }
 755     nr -= shift;
 756 
 757     // Evaluate cost of testing the most common range and performing a
 758     // binary search on the other ranges
 759     float cost = extra + compute_tree_cost(&amp;ranges[0], &amp;ranges[nr-1], total_cnt);
 760     if (cost &gt;= min) {
 761       break;
 762     }
 763     // swap arrays
 764     lo = &amp;ranges[0];
 765     hi = &amp;ranges[nr-1];
 766 
 767     // It pays off: emit the test for the most common range
 768     assert(most_freq.cnt() &gt; 0, &quot;must be taken&quot;);
 769     Node* val = _gvn.transform(new SubINode(key_val, _gvn.intcon(most_freq.lo())));
 770     Node* cmp = _gvn.transform(new CmpUNode(val, _gvn.intcon(most_freq.hi() - most_freq.lo())));
 771     Node* tst = _gvn.transform(new BoolNode(cmp, BoolTest::le));
 772     IfNode* iff = create_and_map_if(control(), tst, if_prob(most_freq.cnt(), total_cnt), if_cnt(most_freq.cnt()));
 773     jump_if_true_fork(iff, most_freq.dest(), most_freq.table_index(), false);
 774 
 775     sub += most_freq.cnt() / total_cnt;
 776     extra += 1 - sub;
 777     min = cost;
 778   }
 779 }
 780 
 781 //----------------------------create_jump_tables-------------------------------
 782 bool Parse::create_jump_tables(Node* key_val, SwitchRange* lo, SwitchRange* hi) {
 783   // Are jumptables enabled
 784   if (!UseJumpTables)  return false;
 785 
 786   // Are jumptables supported
 787   if (!Matcher::has_match_rule(Op_Jump))  return false;
 788 
 789   // Don&#39;t make jump table if profiling
 790   if (method_data_update())  return false;
 791 
 792   bool trim_ranges = !C-&gt;too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if);
 793 
 794   // Decide if a guard is needed to lop off big ranges at either (or
 795   // both) end(s) of the input set. We&#39;ll call this the default target
 796   // even though we can&#39;t be sure that it is the true &quot;default&quot;.
 797 
 798   bool needs_guard = false;
 799   int default_dest;
 800   int64_t total_outlier_size = 0;
 801   int64_t hi_size = ((int64_t)hi-&gt;hi()) - ((int64_t)hi-&gt;lo()) + 1;
 802   int64_t lo_size = ((int64_t)lo-&gt;hi()) - ((int64_t)lo-&gt;lo()) + 1;
 803 
 804   if (lo-&gt;dest() == hi-&gt;dest()) {
 805     total_outlier_size = hi_size + lo_size;
 806     default_dest = lo-&gt;dest();
 807   } else if (lo_size &gt; hi_size) {
 808     total_outlier_size = lo_size;
 809     default_dest = lo-&gt;dest();
 810   } else {
 811     total_outlier_size = hi_size;
 812     default_dest = hi-&gt;dest();
 813   }
 814 
 815   float total = sum_of_cnts(lo, hi);
 816   float cost = compute_tree_cost(lo, hi, total);
 817 
 818   // If a guard test will eliminate very sparse end ranges, then
 819   // it is worth the cost of an extra jump.
 820   float trimmed_cnt = 0;
 821   if (total_outlier_size &gt; (MaxJumpTableSparseness * 4)) {
 822     needs_guard = true;
 823     if (default_dest == lo-&gt;dest()) {
 824       trimmed_cnt += lo-&gt;cnt();
 825       lo++;
 826     }
 827     if (default_dest == hi-&gt;dest()) {
 828       trimmed_cnt += hi-&gt;cnt();
 829       hi--;
 830     }
 831   }
 832 
 833   // Find the total number of cases and ranges
 834   int64_t num_cases = ((int64_t)hi-&gt;hi()) - ((int64_t)lo-&gt;lo()) + 1;
 835   int num_range = hi - lo + 1;
 836 
 837   // Don&#39;t create table if: too large, too small, or too sparse.
 838   if (num_cases &gt; MaxJumpTableSize)
 839     return false;
 840   if (UseSwitchProfiling) {
 841     // MinJumpTableSize is set so with a well balanced binary tree,
 842     // when the number of ranges is MinJumpTableSize, it&#39;s cheaper to
 843     // go through a JumpNode that a tree of IfNodes. Average cost of a
 844     // tree of IfNodes with MinJumpTableSize is
 845     // log2f(MinJumpTableSize) comparisons. So if the cost computed
 846     // from profile data is less than log2f(MinJumpTableSize) then
 847     // going with the binary search is cheaper.
 848     if (cost &lt; log2f(MinJumpTableSize)) {
 849       return false;
 850     }
 851   } else {
 852     if (num_cases &lt; MinJumpTableSize)
 853       return false;
 854   }
 855   if (num_cases &gt; (MaxJumpTableSparseness * num_range))
 856     return false;
 857 
 858   // Normalize table lookups to zero
 859   int lowval = lo-&gt;lo();
 860   key_val = _gvn.transform( new SubINode(key_val, _gvn.intcon(lowval)) );
 861 
 862   // Generate a guard to protect against input keyvals that aren&#39;t
 863   // in the switch domain.
 864   if (needs_guard) {
 865     Node*   size = _gvn.intcon(num_cases);
 866     Node*   cmp = _gvn.transform(new CmpUNode(key_val, size));
 867     Node*   tst = _gvn.transform(new BoolNode(cmp, BoolTest::ge));
 868     IfNode* iff = create_and_map_if(control(), tst, if_prob(trimmed_cnt, total), if_cnt(trimmed_cnt));
 869     jump_if_true_fork(iff, default_dest, NullTableIndex, trim_ranges &amp;&amp; trimmed_cnt == 0);
 870 
 871     total -= trimmed_cnt;
 872   }
 873 
 874   // Create an ideal node JumpTable that has projections
 875   // of all possible ranges for a switch statement
 876   // The key_val input must be converted to a pointer offset and scaled.
 877   // Compare Parse::array_addressing above.
 878 
 879   // Clean the 32-bit int into a real 64-bit offset.
 880   // Otherwise, the jint value 0 might turn into an offset of 0x0800000000.
 881   const TypeInt* ikeytype = TypeInt::make(0, num_cases, Type::WidenMin);
 882   // Make I2L conversion control dependent to prevent it from
 883   // floating above the range check during loop optimizations.
 884   key_val = C-&gt;conv_I2X_index(&amp;_gvn, key_val, ikeytype, control());
 885 
 886   // Shift the value by wordsize so we have an index into the table, rather
 887   // than a switch value
 888   Node *shiftWord = _gvn.MakeConX(wordSize);
 889   key_val = _gvn.transform( new MulXNode( key_val, shiftWord));
 890 
 891   // Create the JumpNode
 892   Arena* arena = C-&gt;comp_arena();
 893   float* probs = (float*)arena-&gt;Amalloc(sizeof(float)*num_cases);
 894   int i = 0;
 895   if (total == 0) {
 896     for (SwitchRange* r = lo; r &lt;= hi; r++) {
 897       for (int64_t j = r-&gt;lo(); j &lt;= r-&gt;hi(); j++, i++) {
 898         probs[i] = 1.0F / num_cases;
 899       }
 900     }
 901   } else {
 902     for (SwitchRange* r = lo; r &lt;= hi; r++) {
 903       float prob = r-&gt;cnt()/total;
 904       for (int64_t j = r-&gt;lo(); j &lt;= r-&gt;hi(); j++, i++) {
 905         probs[i] = prob / (r-&gt;hi() - r-&gt;lo() + 1);
 906       }
 907     }
 908   }
 909 
 910   ciMethodData* methodData = method()-&gt;method_data();
 911   ciMultiBranchData* profile = NULL;
 912   if (methodData-&gt;is_mature()) {
 913     ciProfileData* data = methodData-&gt;bci_to_data(bci());
 914     if (data != NULL &amp;&amp; data-&gt;is_MultiBranchData()) {
 915       profile = (ciMultiBranchData*)data;
 916     }
 917   }
 918 
 919   Node* jtn = _gvn.transform(new JumpNode(control(), key_val, num_cases, probs, profile == NULL ? COUNT_UNKNOWN : total));
 920 
 921   // These are the switch destinations hanging off the jumpnode
 922   i = 0;
 923   for (SwitchRange* r = lo; r &lt;= hi; r++) {
 924     for (int64_t j = r-&gt;lo(); j &lt;= r-&gt;hi(); j++, i++) {
 925       Node* input = _gvn.transform(new JumpProjNode(jtn, i, r-&gt;dest(), (int)(j - lowval)));
 926       {
 927         PreserveJVMState pjvms(this);
 928         set_control(input);
 929         jump_if_always_fork(r-&gt;dest(), r-&gt;table_index(), trim_ranges &amp;&amp; r-&gt;cnt() == 0);
 930       }
 931     }
 932   }
 933   assert(i == num_cases, &quot;miscount of cases&quot;);
 934   stop_and_kill_map();  // no more uses for this JVMS
 935   return true;
 936 }
 937 
 938 //----------------------------jump_switch_ranges-------------------------------
 939 void Parse::jump_switch_ranges(Node* key_val, SwitchRange *lo, SwitchRange *hi, int switch_depth) {
 940   Block* switch_block = block();
 941   bool trim_ranges = !method_data_update() &amp;&amp; !C-&gt;too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if);
 942 
 943   if (switch_depth == 0) {
 944     // Do special processing for the top-level call.
 945     assert(lo-&gt;lo() == min_jint, &quot;initial range must exhaust Type::INT&quot;);
 946     assert(hi-&gt;hi() == max_jint, &quot;initial range must exhaust Type::INT&quot;);
 947 
 948     // Decrement pred-numbers for the unique set of nodes.
 949 #ifdef ASSERT
 950     if (!trim_ranges) {
 951       // Ensure that the block&#39;s successors are a (duplicate-free) set.
 952       int successors_counted = 0;  // block occurrences in [hi..lo]
 953       int unique_successors = switch_block-&gt;num_successors();
 954       for (int i = 0; i &lt; unique_successors; i++) {
 955         Block* target = switch_block-&gt;successor_at(i);
 956 
 957         // Check that the set of successors is the same in both places.
 958         int successors_found = 0;
 959         for (SwitchRange* p = lo; p &lt;= hi; p++) {
 960           if (p-&gt;dest() == target-&gt;start())  successors_found++;
 961         }
 962         assert(successors_found &gt; 0, &quot;successor must be known&quot;);
 963         successors_counted += successors_found;
 964       }
 965       assert(successors_counted == (hi-lo)+1, &quot;no unexpected successors&quot;);
 966     }
 967 #endif
 968 
 969     // Maybe prune the inputs, based on the type of key_val.
 970     jint min_val = min_jint;
 971     jint max_val = max_jint;
 972     const TypeInt* ti = key_val-&gt;bottom_type()-&gt;isa_int();
 973     if (ti != NULL) {
 974       min_val = ti-&gt;_lo;
 975       max_val = ti-&gt;_hi;
 976       assert(min_val &lt;= max_val, &quot;invalid int type&quot;);
 977     }
 978     while (lo-&gt;hi() &lt; min_val) {
 979       lo++;
 980     }
 981     if (lo-&gt;lo() &lt; min_val)  {
 982       lo-&gt;setRange(min_val, lo-&gt;hi(), lo-&gt;dest(), lo-&gt;table_index(), lo-&gt;cnt());
 983     }
 984     while (hi-&gt;lo() &gt; max_val) {
 985       hi--;
 986     }
 987     if (hi-&gt;hi() &gt; max_val) {
 988       hi-&gt;setRange(hi-&gt;lo(), max_val, hi-&gt;dest(), hi-&gt;table_index(), hi-&gt;cnt());
 989     }
 990 
 991     linear_search_switch_ranges(key_val, lo, hi);
 992   }
 993 
 994 #ifndef PRODUCT
 995   if (switch_depth == 0) {
 996     _max_switch_depth = 0;
 997     _est_switch_depth = log2_intptr((hi-lo+1)-1)+1;
 998   }
 999 #endif
1000 
1001   assert(lo &lt;= hi, &quot;must be a non-empty set of ranges&quot;);
1002   if (lo == hi) {
1003     jump_if_always_fork(lo-&gt;dest(), lo-&gt;table_index(), trim_ranges &amp;&amp; lo-&gt;cnt() == 0);
1004   } else {
1005     assert(lo-&gt;hi() == (lo+1)-&gt;lo()-1, &quot;contiguous ranges&quot;);
1006     assert(hi-&gt;lo() == (hi-1)-&gt;hi()+1, &quot;contiguous ranges&quot;);
1007 
1008     if (create_jump_tables(key_val, lo, hi)) return;
1009 
1010     SwitchRange* mid = NULL;
1011     float total_cnt = sum_of_cnts(lo, hi);
1012 
1013     int nr = hi - lo + 1;
1014     if (UseSwitchProfiling) {
1015       // Don&#39;t keep the binary search tree balanced: pick up mid point
1016       // that split frequencies in half.
1017       float cnt = 0;
1018       for (SwitchRange* sr = lo; sr &lt;= hi; sr++) {
1019         cnt += sr-&gt;cnt();
1020         if (cnt &gt;= total_cnt / 2) {
1021           mid = sr;
1022           break;
1023         }
1024       }
1025     } else {
1026       mid = lo + nr/2;
1027 
1028       // if there is an easy choice, pivot at a singleton:
1029       if (nr &gt; 3 &amp;&amp; !mid-&gt;is_singleton() &amp;&amp; (mid-1)-&gt;is_singleton())  mid--;
1030 
1031       assert(lo &lt; mid &amp;&amp; mid &lt;= hi, &quot;good pivot choice&quot;);
1032       assert(nr != 2 || mid == hi,   &quot;should pick higher of 2&quot;);
1033       assert(nr != 3 || mid == hi-1, &quot;should pick middle of 3&quot;);
1034     }
1035 
1036 
1037     Node *test_val = _gvn.intcon(mid == lo ? mid-&gt;hi() : mid-&gt;lo());
1038 
1039     if (mid-&gt;is_singleton()) {
1040       IfNode *iff_ne = jump_if_fork_int(key_val, test_val, BoolTest::ne, 1-if_prob(mid-&gt;cnt(), total_cnt), if_cnt(mid-&gt;cnt()));
1041       jump_if_false_fork(iff_ne, mid-&gt;dest(), mid-&gt;table_index(), trim_ranges &amp;&amp; mid-&gt;cnt() == 0);
1042 
1043       // Special Case:  If there are exactly three ranges, and the high
1044       // and low range each go to the same place, omit the &quot;gt&quot; test,
1045       // since it will not discriminate anything.
1046       bool eq_test_only = (hi == lo+2 &amp;&amp; hi-&gt;dest() == lo-&gt;dest() &amp;&amp; mid == hi-1) || mid == lo;
1047 
1048       // if there is a higher range, test for it and process it:
1049       if (mid &lt; hi &amp;&amp; !eq_test_only) {
1050         // two comparisons of same values--should enable 1 test for 2 branches
<a name="12" id="anc12"></a><span class="line-modified">1051         // Use BoolTest::le instead of BoolTest::gt</span>
1052         float cnt = sum_of_cnts(lo, mid-1);
<a name="13" id="anc13"></a><span class="line-modified">1053         IfNode *iff_le  = jump_if_fork_int(key_val, test_val, BoolTest::le, if_prob(cnt, total_cnt), if_cnt(cnt));</span>
<span class="line-modified">1054         Node   *iftrue  = _gvn.transform( new IfTrueNode(iff_le) );</span>
<span class="line-modified">1055         Node   *iffalse = _gvn.transform( new IfFalseNode(iff_le) );</span>
1056         { PreserveJVMState pjvms(this);
1057           set_control(iffalse);
1058           jump_switch_ranges(key_val, mid+1, hi, switch_depth+1);
1059         }
1060         set_control(iftrue);
1061       }
1062 
1063     } else {
1064       // mid is a range, not a singleton, so treat mid..hi as a unit
1065       float cnt = sum_of_cnts(mid == lo ? mid+1 : mid, hi);
1066       IfNode *iff_ge = jump_if_fork_int(key_val, test_val, mid == lo ? BoolTest::gt : BoolTest::ge, if_prob(cnt, total_cnt), if_cnt(cnt));
1067 
1068       // if there is a higher range, test for it and process it:
1069       if (mid == hi) {
1070         jump_if_true_fork(iff_ge, mid-&gt;dest(), mid-&gt;table_index(), trim_ranges &amp;&amp; cnt == 0);
1071       } else {
1072         Node *iftrue  = _gvn.transform( new IfTrueNode(iff_ge) );
1073         Node *iffalse = _gvn.transform( new IfFalseNode(iff_ge) );
1074         { PreserveJVMState pjvms(this);
1075           set_control(iftrue);
1076           jump_switch_ranges(key_val, mid == lo ? mid+1 : mid, hi, switch_depth+1);
1077         }
1078         set_control(iffalse);
1079       }
1080     }
1081 
1082     // in any case, process the lower range
1083     if (mid == lo) {
1084       if (mid-&gt;is_singleton()) {
1085         jump_switch_ranges(key_val, lo+1, hi, switch_depth+1);
1086       } else {
1087         jump_if_always_fork(lo-&gt;dest(), lo-&gt;table_index(), trim_ranges &amp;&amp; lo-&gt;cnt() == 0);
1088       }
1089     } else {
1090       jump_switch_ranges(key_val, lo, mid-1, switch_depth+1);
1091     }
1092   }
1093 
1094   // Decrease pred_count for each successor after all is done.
1095   if (switch_depth == 0) {
1096     int unique_successors = switch_block-&gt;num_successors();
1097     for (int i = 0; i &lt; unique_successors; i++) {
1098       Block* target = switch_block-&gt;successor_at(i);
1099       // Throw away the pre-allocated path for each unique successor.
1100       target-&gt;next_path_num();
1101     }
1102   }
1103 
1104 #ifndef PRODUCT
1105   _max_switch_depth = MAX2(switch_depth, _max_switch_depth);
1106   if (TraceOptoParse &amp;&amp; Verbose &amp;&amp; WizardMode &amp;&amp; switch_depth == 0) {
1107     SwitchRange* r;
1108     int nsing = 0;
1109     for( r = lo; r &lt;= hi; r++ ) {
1110       if( r-&gt;is_singleton() )  nsing++;
1111     }
1112     tty-&gt;print(&quot;&gt;&gt;&gt; &quot;);
1113     _method-&gt;print_short_name();
1114     tty-&gt;print_cr(&quot; switch decision tree&quot;);
1115     tty-&gt;print_cr(&quot;    %d ranges (%d singletons), max_depth=%d, est_depth=%d&quot;,
1116                   (int) (hi-lo+1), nsing, _max_switch_depth, _est_switch_depth);
1117     if (_max_switch_depth &gt; _est_switch_depth) {
1118       tty-&gt;print_cr(&quot;******** BAD SWITCH DEPTH ********&quot;);
1119     }
1120     tty-&gt;print(&quot;   &quot;);
1121     for( r = lo; r &lt;= hi; r++ ) {
1122       r-&gt;print();
1123     }
1124     tty-&gt;cr();
1125   }
1126 #endif
1127 }
1128 
1129 void Parse::modf() {
1130   Node *f2 = pop();
1131   Node *f1 = pop();
1132   Node* c = make_runtime_call(RC_LEAF, OptoRuntime::modf_Type(),
1133                               CAST_FROM_FN_PTR(address, SharedRuntime::frem),
1134                               &quot;frem&quot;, NULL, //no memory effects
1135                               f1, f2);
1136   Node* res = _gvn.transform(new ProjNode(c, TypeFunc::Parms + 0));
1137 
1138   push(res);
1139 }
1140 
1141 void Parse::modd() {
1142   Node *d2 = pop_pair();
1143   Node *d1 = pop_pair();
1144   Node* c = make_runtime_call(RC_LEAF, OptoRuntime::Math_DD_D_Type(),
1145                               CAST_FROM_FN_PTR(address, SharedRuntime::drem),
1146                               &quot;drem&quot;, NULL, //no memory effects
1147                               d1, top(), d2, top());
1148   Node* res_d   = _gvn.transform(new ProjNode(c, TypeFunc::Parms + 0));
1149 
1150 #ifdef ASSERT
1151   Node* res_top = _gvn.transform(new ProjNode(c, TypeFunc::Parms + 1));
1152   assert(res_top == top(), &quot;second value must be top&quot;);
1153 #endif
1154 
1155   push_pair(res_d);
1156 }
1157 
1158 void Parse::l2f() {
1159   Node* f2 = pop();
1160   Node* f1 = pop();
1161   Node* c = make_runtime_call(RC_LEAF, OptoRuntime::l2f_Type(),
1162                               CAST_FROM_FN_PTR(address, SharedRuntime::l2f),
1163                               &quot;l2f&quot;, NULL, //no memory effects
1164                               f1, f2);
1165   Node* res = _gvn.transform(new ProjNode(c, TypeFunc::Parms + 0));
1166 
1167   push(res);
1168 }
1169 
1170 void Parse::do_irem() {
1171   // Must keep both values on the expression-stack during null-check
1172   zero_check_int(peek());
1173   // Compile-time detect of null-exception?
1174   if (stopped())  return;
1175 
1176   Node* b = pop();
1177   Node* a = pop();
1178 
1179   const Type *t = _gvn.type(b);
1180   if (t != Type::TOP) {
1181     const TypeInt *ti = t-&gt;is_int();
1182     if (ti-&gt;is_con()) {
1183       int divisor = ti-&gt;get_con();
1184       // check for positive power of 2
1185       if (divisor &gt; 0 &amp;&amp;
1186           (divisor &amp; ~(divisor-1)) == divisor) {
1187         // yes !
1188         Node *mask = _gvn.intcon((divisor - 1));
1189         // Sigh, must handle negative dividends
1190         Node *zero = _gvn.intcon(0);
1191         IfNode *ifff = jump_if_fork_int(a, zero, BoolTest::lt, PROB_FAIR, COUNT_UNKNOWN);
1192         Node *iff = _gvn.transform( new IfFalseNode(ifff) );
1193         Node *ift = _gvn.transform( new IfTrueNode (ifff) );
1194         Node *reg = jump_if_join(ift, iff);
1195         Node *phi = PhiNode::make(reg, NULL, TypeInt::INT);
1196         // Negative path; negate/and/negate
1197         Node *neg = _gvn.transform( new SubINode(zero, a) );
1198         Node *andn= _gvn.transform( new AndINode(neg, mask) );
1199         Node *negn= _gvn.transform( new SubINode(zero, andn) );
1200         phi-&gt;init_req(1, negn);
1201         // Fast positive case
1202         Node *andx = _gvn.transform( new AndINode(a, mask) );
1203         phi-&gt;init_req(2, andx);
1204         // Push the merge
1205         push( _gvn.transform(phi) );
1206         return;
1207       }
1208     }
1209   }
1210   // Default case
1211   push( _gvn.transform( new ModINode(control(),a,b) ) );
1212 }
1213 
1214 // Handle jsr and jsr_w bytecode
1215 void Parse::do_jsr() {
1216   assert(bc() == Bytecodes::_jsr || bc() == Bytecodes::_jsr_w, &quot;wrong bytecode&quot;);
1217 
1218   // Store information about current state, tagged with new _jsr_bci
1219   int return_bci = iter().next_bci();
1220   int jsr_bci    = (bc() == Bytecodes::_jsr) ? iter().get_dest() : iter().get_far_dest();
1221 
1222   // Update method data
1223   profile_taken_branch(jsr_bci);
1224 
1225   // The way we do things now, there is only one successor block
1226   // for the jsr, because the target code is cloned by ciTypeFlow.
1227   Block* target = successor_for_bci(jsr_bci);
1228 
1229   // What got pushed?
1230   const Type* ret_addr = target-&gt;peek();
1231   assert(ret_addr-&gt;singleton(), &quot;must be a constant (cloned jsr body)&quot;);
1232 
1233   // Effect on jsr on stack
1234   push(_gvn.makecon(ret_addr));
1235 
1236   // Flow to the jsr.
1237   merge(jsr_bci);
1238 }
1239 
1240 // Handle ret bytecode
1241 void Parse::do_ret() {
1242   // Find to whom we return.
1243   assert(block()-&gt;num_successors() == 1, &quot;a ret can only go one place now&quot;);
1244   Block* target = block()-&gt;successor_at(0);
1245   assert(!target-&gt;is_ready(), &quot;our arrival must be expected&quot;);
1246   profile_ret(target-&gt;flow()-&gt;start());
1247   int pnum = target-&gt;next_path_num();
1248   merge_common(target, pnum);
1249 }
1250 
1251 static bool has_injected_profile(BoolTest::mask btest, Node* test, int&amp; taken, int&amp; not_taken) {
1252   if (btest != BoolTest::eq &amp;&amp; btest != BoolTest::ne) {
1253     // Only ::eq and ::ne are supported for profile injection.
1254     return false;
1255   }
1256   if (test-&gt;is_Cmp() &amp;&amp;
1257       test-&gt;in(1)-&gt;Opcode() == Op_ProfileBoolean) {
1258     ProfileBooleanNode* profile = (ProfileBooleanNode*)test-&gt;in(1);
1259     int false_cnt = profile-&gt;false_count();
1260     int  true_cnt = profile-&gt;true_count();
1261 
1262     // Counts matching depends on the actual test operation (::eq or ::ne).
1263     // No need to scale the counts because profile injection was designed
1264     // to feed exact counts into VM.
1265     taken     = (btest == BoolTest::eq) ? false_cnt :  true_cnt;
1266     not_taken = (btest == BoolTest::eq) ?  true_cnt : false_cnt;
1267 
1268     profile-&gt;consume();
1269     return true;
1270   }
1271   return false;
1272 }
1273 //--------------------------dynamic_branch_prediction--------------------------
1274 // Try to gather dynamic branch prediction behavior.  Return a probability
1275 // of the branch being taken and set the &quot;cnt&quot; field.  Returns a -1.0
1276 // if we need to use static prediction for some reason.
1277 float Parse::dynamic_branch_prediction(float &amp;cnt, BoolTest::mask btest, Node* test) {
1278   ResourceMark rm;
1279 
1280   cnt  = COUNT_UNKNOWN;
1281 
1282   int     taken = 0;
1283   int not_taken = 0;
1284 
1285   bool use_mdo = !has_injected_profile(btest, test, taken, not_taken);
1286 
1287   if (use_mdo) {
1288     // Use MethodData information if it is available
1289     // FIXME: free the ProfileData structure
1290     ciMethodData* methodData = method()-&gt;method_data();
1291     if (!methodData-&gt;is_mature())  return PROB_UNKNOWN;
1292     ciProfileData* data = methodData-&gt;bci_to_data(bci());
1293     if (data == NULL) {
1294       return PROB_UNKNOWN;
1295     }
1296     if (!data-&gt;is_JumpData())  return PROB_UNKNOWN;
1297 
1298     // get taken and not taken values
1299     taken = data-&gt;as_JumpData()-&gt;taken();
1300     not_taken = 0;
1301     if (data-&gt;is_BranchData()) {
1302       not_taken = data-&gt;as_BranchData()-&gt;not_taken();
1303     }
1304 
1305     // scale the counts to be commensurate with invocation counts:
1306     taken = method()-&gt;scale_count(taken);
1307     not_taken = method()-&gt;scale_count(not_taken);
1308   }
1309 
1310   // Give up if too few (or too many, in which case the sum will overflow) counts to be meaningful.
1311   // We also check that individual counters are positive first, otherwise the sum can become positive.
1312   if (taken &lt; 0 || not_taken &lt; 0 || taken + not_taken &lt; 40) {
1313     if (C-&gt;log() != NULL) {
1314       C-&gt;log()-&gt;elem(&quot;branch target_bci=&#39;%d&#39; taken=&#39;%d&#39; not_taken=&#39;%d&#39;&quot;, iter().get_dest(), taken, not_taken);
1315     }
1316     return PROB_UNKNOWN;
1317   }
1318 
1319   // Compute frequency that we arrive here
1320   float sum = taken + not_taken;
1321   // Adjust, if this block is a cloned private block but the
1322   // Jump counts are shared.  Taken the private counts for
1323   // just this path instead of the shared counts.
1324   if( block()-&gt;count() &gt; 0 )
1325     sum = block()-&gt;count();
1326   cnt = sum / FreqCountInvocations;
1327 
1328   // Pin probability to sane limits
1329   float prob;
1330   if( !taken )
1331     prob = (0+PROB_MIN) / 2;
1332   else if( !not_taken )
1333     prob = (1+PROB_MAX) / 2;
1334   else {                         // Compute probability of true path
1335     prob = (float)taken / (float)(taken + not_taken);
1336     if (prob &gt; PROB_MAX)  prob = PROB_MAX;
1337     if (prob &lt; PROB_MIN)   prob = PROB_MIN;
1338   }
1339 
1340   assert((cnt &gt; 0.0f) &amp;&amp; (prob &gt; 0.0f),
1341          &quot;Bad frequency assignment in if&quot;);
1342 
1343   if (C-&gt;log() != NULL) {
1344     const char* prob_str = NULL;
1345     if (prob &gt;= PROB_MAX)  prob_str = (prob == PROB_MAX) ? &quot;max&quot; : &quot;always&quot;;
1346     if (prob &lt;= PROB_MIN)  prob_str = (prob == PROB_MIN) ? &quot;min&quot; : &quot;never&quot;;
1347     char prob_str_buf[30];
1348     if (prob_str == NULL) {
1349       jio_snprintf(prob_str_buf, sizeof(prob_str_buf), &quot;%20.2f&quot;, prob);
1350       prob_str = prob_str_buf;
1351     }
1352     C-&gt;log()-&gt;elem(&quot;branch target_bci=&#39;%d&#39; taken=&#39;%d&#39; not_taken=&#39;%d&#39; cnt=&#39;%f&#39; prob=&#39;%s&#39;&quot;,
1353                    iter().get_dest(), taken, not_taken, cnt, prob_str);
1354   }
1355   return prob;
1356 }
1357 
1358 //-----------------------------branch_prediction-------------------------------
1359 float Parse::branch_prediction(float&amp; cnt,
1360                                BoolTest::mask btest,
1361                                int target_bci,
1362                                Node* test) {
1363   float prob = dynamic_branch_prediction(cnt, btest, test);
1364   // If prob is unknown, switch to static prediction
1365   if (prob != PROB_UNKNOWN)  return prob;
1366 
1367   prob = PROB_FAIR;                   // Set default value
1368   if (btest == BoolTest::eq)          // Exactly equal test?
1369     prob = PROB_STATIC_INFREQUENT;    // Assume its relatively infrequent
1370   else if (btest == BoolTest::ne)
1371     prob = PROB_STATIC_FREQUENT;      // Assume its relatively frequent
1372 
1373   // If this is a conditional test guarding a backwards branch,
1374   // assume its a loop-back edge.  Make it a likely taken branch.
1375   if (target_bci &lt; bci()) {
1376     if (is_osr_parse()) {    // Could be a hot OSR&#39;d loop; force deopt
1377       // Since it&#39;s an OSR, we probably have profile data, but since
1378       // branch_prediction returned PROB_UNKNOWN, the counts are too small.
1379       // Let&#39;s make a special check here for completely zero counts.
1380       ciMethodData* methodData = method()-&gt;method_data();
1381       if (!methodData-&gt;is_empty()) {
1382         ciProfileData* data = methodData-&gt;bci_to_data(bci());
1383         // Only stop for truly zero counts, which mean an unknown part
1384         // of the OSR-ed method, and we want to deopt to gather more stats.
1385         // If you have ANY counts, then this loop is simply &#39;cold&#39; relative
1386         // to the OSR loop.
1387         if (data == NULL ||
1388             (data-&gt;as_BranchData()-&gt;taken() +  data-&gt;as_BranchData()-&gt;not_taken() == 0)) {
1389           // This is the only way to return PROB_UNKNOWN:
1390           return PROB_UNKNOWN;
1391         }
1392       }
1393     }
1394     prob = PROB_STATIC_FREQUENT;     // Likely to take backwards branch
1395   }
1396 
1397   assert(prob != PROB_UNKNOWN, &quot;must have some guess at this point&quot;);
1398   return prob;
1399 }
1400 
1401 // The magic constants are chosen so as to match the output of
1402 // branch_prediction() when the profile reports a zero taken count.
1403 // It is important to distinguish zero counts unambiguously, because
1404 // some branches (e.g., _213_javac.Assembler.eliminate) validly produce
1405 // very small but nonzero probabilities, which if confused with zero
1406 // counts would keep the program recompiling indefinitely.
1407 bool Parse::seems_never_taken(float prob) const {
1408   return prob &lt; PROB_MIN;
1409 }
1410 
1411 // True if the comparison seems to be the kind that will not change its
1412 // statistics from true to false.  See comments in adjust_map_after_if.
1413 // This question is only asked along paths which are already
1414 // classifed as untaken (by seems_never_taken), so really,
1415 // if a path is never taken, its controlling comparison is
1416 // already acting in a stable fashion.  If the comparison
1417 // seems stable, we will put an expensive uncommon trap
1418 // on the untaken path.
1419 bool Parse::seems_stable_comparison() const {
1420   if (C-&gt;too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if)) {
1421     return false;
1422   }
1423   return true;
1424 }
1425 
1426 //-------------------------------repush_if_args--------------------------------
1427 // Push arguments of an &quot;if&quot; bytecode back onto the stack by adjusting _sp.
1428 inline int Parse::repush_if_args() {
1429   if (PrintOpto &amp;&amp; WizardMode) {
1430     tty-&gt;print(&quot;defending against excessive implicit null exceptions on %s @%d in &quot;,
1431                Bytecodes::name(iter().cur_bc()), iter().cur_bci());
1432     method()-&gt;print_name(); tty-&gt;cr();
1433   }
1434   int bc_depth = - Bytecodes::depth(iter().cur_bc());
1435   assert(bc_depth == 1 || bc_depth == 2, &quot;only two kinds of branches&quot;);
1436   DEBUG_ONLY(sync_jvms());   // argument(n) requires a synced jvms
1437   assert(argument(0) != NULL, &quot;must exist&quot;);
1438   assert(bc_depth == 1 || argument(1) != NULL, &quot;two must exist&quot;);
1439   inc_sp(bc_depth);
1440   return bc_depth;
1441 }
1442 
1443 //----------------------------------do_ifnull----------------------------------
1444 void Parse::do_ifnull(BoolTest::mask btest, Node *c) {
1445   int target_bci = iter().get_dest();
1446 
1447   Block* branch_block = successor_for_bci(target_bci);
1448   Block* next_block   = successor_for_bci(iter().next_bci());
1449 
1450   float cnt;
1451   float prob = branch_prediction(cnt, btest, target_bci, c);
1452   if (prob == PROB_UNKNOWN) {
1453     // (An earlier version of do_ifnull omitted this trap for OSR methods.)
1454     if (PrintOpto &amp;&amp; Verbose) {
1455       tty-&gt;print_cr(&quot;Never-taken edge stops compilation at bci %d&quot;, bci());
1456     }
1457     repush_if_args(); // to gather stats on loop
1458     // We need to mark this branch as taken so that if we recompile we will
1459     // see that it is possible. In the tiered system the interpreter doesn&#39;t
1460     // do profiling and by the time we get to the lower tier from the interpreter
1461     // the path may be cold again. Make sure it doesn&#39;t look untaken
1462     profile_taken_branch(target_bci, !ProfileInterpreter);
1463     uncommon_trap(Deoptimization::Reason_unreached,
1464                   Deoptimization::Action_reinterpret,
1465                   NULL, &quot;cold&quot;);
1466     if (C-&gt;eliminate_boxing()) {
1467       // Mark the successor blocks as parsed
1468       branch_block-&gt;next_path_num();
1469       next_block-&gt;next_path_num();
1470     }
1471     return;
1472   }
1473 
1474   NOT_PRODUCT(explicit_null_checks_inserted++);
1475 
1476   // Generate real control flow
1477   Node   *tst = _gvn.transform( new BoolNode( c, btest ) );
1478 
1479   // Sanity check the probability value
1480   assert(prob &gt; 0.0f,&quot;Bad probability in Parser&quot;);
1481  // Need xform to put node in hash table
1482   IfNode *iff = create_and_xform_if( control(), tst, prob, cnt );
1483   assert(iff-&gt;_prob &gt; 0.0f,&quot;Optimizer made bad probability in parser&quot;);
1484   // True branch
1485   { PreserveJVMState pjvms(this);
1486     Node* iftrue  = _gvn.transform( new IfTrueNode (iff) );
1487     set_control(iftrue);
1488 
1489     if (stopped()) {            // Path is dead?
1490       NOT_PRODUCT(explicit_null_checks_elided++);
1491       if (C-&gt;eliminate_boxing()) {
1492         // Mark the successor block as parsed
1493         branch_block-&gt;next_path_num();
1494       }
1495     } else {                    // Path is live.
1496       // Update method data
1497       profile_taken_branch(target_bci);
1498       adjust_map_after_if(btest, c, prob, branch_block, next_block);
1499       if (!stopped()) {
1500         merge(target_bci);
1501       }
1502     }
1503   }
1504 
1505   // False branch
1506   Node* iffalse = _gvn.transform( new IfFalseNode(iff) );
1507   set_control(iffalse);
1508 
1509   if (stopped()) {              // Path is dead?
1510     NOT_PRODUCT(explicit_null_checks_elided++);
1511     if (C-&gt;eliminate_boxing()) {
1512       // Mark the successor block as parsed
1513       next_block-&gt;next_path_num();
1514     }
1515   } else  {                     // Path is live.
1516     // Update method data
1517     profile_not_taken_branch();
1518     adjust_map_after_if(BoolTest(btest).negate(), c, 1.0-prob,
1519                         next_block, branch_block);
1520   }
1521 }
1522 
1523 //------------------------------------do_if------------------------------------
1524 void Parse::do_if(BoolTest::mask btest, Node* c) {
1525   int target_bci = iter().get_dest();
1526 
1527   Block* branch_block = successor_for_bci(target_bci);
1528   Block* next_block   = successor_for_bci(iter().next_bci());
1529 
1530   float cnt;
1531   float prob = branch_prediction(cnt, btest, target_bci, c);
1532   float untaken_prob = 1.0 - prob;
1533 
1534   if (prob == PROB_UNKNOWN) {
1535     if (PrintOpto &amp;&amp; Verbose) {
1536       tty-&gt;print_cr(&quot;Never-taken edge stops compilation at bci %d&quot;, bci());
1537     }
1538     repush_if_args(); // to gather stats on loop
1539     // We need to mark this branch as taken so that if we recompile we will
1540     // see that it is possible. In the tiered system the interpreter doesn&#39;t
1541     // do profiling and by the time we get to the lower tier from the interpreter
1542     // the path may be cold again. Make sure it doesn&#39;t look untaken
1543     profile_taken_branch(target_bci, !ProfileInterpreter);
1544     uncommon_trap(Deoptimization::Reason_unreached,
1545                   Deoptimization::Action_reinterpret,
1546                   NULL, &quot;cold&quot;);
1547     if (C-&gt;eliminate_boxing()) {
1548       // Mark the successor blocks as parsed
1549       branch_block-&gt;next_path_num();
1550       next_block-&gt;next_path_num();
1551     }
1552     return;
1553   }
1554 
1555   // Sanity check the probability value
1556   assert(0.0f &lt; prob &amp;&amp; prob &lt; 1.0f,&quot;Bad probability in Parser&quot;);
1557 
1558   bool taken_if_true = true;
1559   // Convert BoolTest to canonical form:
1560   if (!BoolTest(btest).is_canonical()) {
1561     btest         = BoolTest(btest).negate();
1562     taken_if_true = false;
1563     // prob is NOT updated here; it remains the probability of the taken
1564     // path (as opposed to the prob of the path guarded by an &#39;IfTrueNode&#39;).
1565   }
1566   assert(btest != BoolTest::eq, &quot;!= is the only canonical exact test&quot;);
1567 
1568   Node* tst0 = new BoolNode(c, btest);
1569   Node* tst = _gvn.transform(tst0);
1570   BoolTest::mask taken_btest   = BoolTest::illegal;
1571   BoolTest::mask untaken_btest = BoolTest::illegal;
1572 
1573   if (tst-&gt;is_Bool()) {
1574     // Refresh c from the transformed bool node, since it may be
1575     // simpler than the original c.  Also re-canonicalize btest.
1576     // This wins when (Bool ne (Conv2B p) 0) =&gt; (Bool ne (CmpP p NULL)).
1577     // That can arise from statements like: if (x instanceof C) ...
1578     if (tst != tst0) {
1579       // Canonicalize one more time since transform can change it.
1580       btest = tst-&gt;as_Bool()-&gt;_test._test;
1581       if (!BoolTest(btest).is_canonical()) {
1582         // Reverse edges one more time...
1583         tst   = _gvn.transform( tst-&gt;as_Bool()-&gt;negate(&amp;_gvn) );
1584         btest = tst-&gt;as_Bool()-&gt;_test._test;
1585         assert(BoolTest(btest).is_canonical(), &quot;sanity&quot;);
1586         taken_if_true = !taken_if_true;
1587       }
1588       c = tst-&gt;in(1);
1589     }
1590     BoolTest::mask neg_btest = BoolTest(btest).negate();
1591     taken_btest   = taken_if_true ?     btest : neg_btest;
1592     untaken_btest = taken_if_true ? neg_btest :     btest;
1593   }
1594 
1595   // Generate real control flow
1596   float true_prob = (taken_if_true ? prob : untaken_prob);
1597   IfNode* iff = create_and_map_if(control(), tst, true_prob, cnt);
1598   assert(iff-&gt;_prob &gt; 0.0f,&quot;Optimizer made bad probability in parser&quot;);
1599   Node* taken_branch   = new IfTrueNode(iff);
1600   Node* untaken_branch = new IfFalseNode(iff);
1601   if (!taken_if_true) {  // Finish conversion to canonical form
1602     Node* tmp      = taken_branch;
1603     taken_branch   = untaken_branch;
1604     untaken_branch = tmp;
1605   }
1606 
1607   // Branch is taken:
1608   { PreserveJVMState pjvms(this);
1609     taken_branch = _gvn.transform(taken_branch);
1610     set_control(taken_branch);
1611 
1612     if (stopped()) {
1613       if (C-&gt;eliminate_boxing()) {
1614         // Mark the successor block as parsed
1615         branch_block-&gt;next_path_num();
1616       }
1617     } else {
1618       // Update method data
1619       profile_taken_branch(target_bci);
1620       adjust_map_after_if(taken_btest, c, prob, branch_block, next_block);
1621       if (!stopped()) {
1622         merge(target_bci);
1623       }
1624     }
1625   }
1626 
1627   untaken_branch = _gvn.transform(untaken_branch);
1628   set_control(untaken_branch);
1629 
1630   // Branch not taken.
1631   if (stopped()) {
1632     if (C-&gt;eliminate_boxing()) {
1633       // Mark the successor block as parsed
1634       next_block-&gt;next_path_num();
1635     }
1636   } else {
1637     // Update method data
1638     profile_not_taken_branch();
1639     adjust_map_after_if(untaken_btest, c, untaken_prob,
1640                         next_block, branch_block);
1641   }
1642 }
1643 
1644 bool Parse::path_is_suitable_for_uncommon_trap(float prob) const {
1645   // Don&#39;t want to speculate on uncommon traps when running with -Xcomp
1646   if (!UseInterpreter) {
1647     return false;
1648   }
1649   return (seems_never_taken(prob) &amp;&amp; seems_stable_comparison());
1650 }
1651 
1652 void Parse::maybe_add_predicate_after_if(Block* path) {
1653   if (path-&gt;is_SEL_head() &amp;&amp; path-&gt;preds_parsed() == 0) {
1654     // Add predicates at bci of if dominating the loop so traps can be
1655     // recorded on the if&#39;s profile data
1656     int bc_depth = repush_if_args();
1657     add_predicate();
1658     dec_sp(bc_depth);
1659     path-&gt;set_has_predicates();
1660   }
1661 }
1662 
1663 
1664 //----------------------------adjust_map_after_if------------------------------
1665 // Adjust the JVM state to reflect the result of taking this path.
1666 // Basically, it means inspecting the CmpNode controlling this
1667 // branch, seeing how it constrains a tested value, and then
1668 // deciding if it&#39;s worth our while to encode this constraint
1669 // as graph nodes in the current abstract interpretation map.
1670 void Parse::adjust_map_after_if(BoolTest::mask btest, Node* c, float prob,
1671                                 Block* path, Block* other_path) {
1672   if (!c-&gt;is_Cmp()) {
1673     maybe_add_predicate_after_if(path);
1674     return;
1675   }
1676 
1677   if (stopped() || btest == BoolTest::illegal) {
1678     return;                             // nothing to do
1679   }
1680 
1681   bool is_fallthrough = (path == successor_for_bci(iter().next_bci()));
1682 
1683   if (path_is_suitable_for_uncommon_trap(prob)) {
1684     repush_if_args();
1685     uncommon_trap(Deoptimization::Reason_unstable_if,
1686                   Deoptimization::Action_reinterpret,
1687                   NULL,
1688                   (is_fallthrough ? &quot;taken always&quot; : &quot;taken never&quot;));
1689     return;
1690   }
1691 
1692   Node* val = c-&gt;in(1);
1693   Node* con = c-&gt;in(2);
1694   const Type* tcon = _gvn.type(con);
1695   const Type* tval = _gvn.type(val);
1696   bool have_con = tcon-&gt;singleton();
1697   if (tval-&gt;singleton()) {
1698     if (!have_con) {
1699       // Swap, so constant is in con.
1700       con  = val;
1701       tcon = tval;
1702       val  = c-&gt;in(2);
1703       tval = _gvn.type(val);
1704       btest = BoolTest(btest).commute();
1705       have_con = true;
1706     } else {
1707       // Do we have two constants?  Then leave well enough alone.
1708       have_con = false;
1709     }
1710   }
1711   if (!have_con) {                        // remaining adjustments need a con
1712     maybe_add_predicate_after_if(path);
1713     return;
1714   }
1715 
1716   sharpen_type_after_if(btest, con, tcon, val, tval);
1717   maybe_add_predicate_after_if(path);
1718 }
1719 
1720 
1721 static Node* extract_obj_from_klass_load(PhaseGVN* gvn, Node* n) {
1722   Node* ldk;
1723   if (n-&gt;is_DecodeNKlass()) {
1724     if (n-&gt;in(1)-&gt;Opcode() != Op_LoadNKlass) {
1725       return NULL;
1726     } else {
1727       ldk = n-&gt;in(1);
1728     }
1729   } else if (n-&gt;Opcode() != Op_LoadKlass) {
1730     return NULL;
1731   } else {
1732     ldk = n;
1733   }
1734   assert(ldk != NULL &amp;&amp; ldk-&gt;is_Load(), &quot;should have found a LoadKlass or LoadNKlass node&quot;);
1735 
1736   Node* adr = ldk-&gt;in(MemNode::Address);
1737   intptr_t off = 0;
1738   Node* obj = AddPNode::Ideal_base_and_offset(adr, gvn, off);
1739   if (obj == NULL || off != oopDesc::klass_offset_in_bytes()) // loading oopDesc::_klass?
1740     return NULL;
1741   const TypePtr* tp = gvn-&gt;type(obj)-&gt;is_ptr();
1742   if (tp == NULL || !(tp-&gt;isa_instptr() || tp-&gt;isa_aryptr())) // is obj a Java object ptr?
1743     return NULL;
1744 
1745   return obj;
1746 }
1747 
1748 void Parse::sharpen_type_after_if(BoolTest::mask btest,
1749                                   Node* con, const Type* tcon,
1750                                   Node* val, const Type* tval) {
1751   // Look for opportunities to sharpen the type of a node
1752   // whose klass is compared with a constant klass.
1753   if (btest == BoolTest::eq &amp;&amp; tcon-&gt;isa_klassptr()) {
1754     Node* obj = extract_obj_from_klass_load(&amp;_gvn, val);
1755     const TypeOopPtr* con_type = tcon-&gt;isa_klassptr()-&gt;as_instance_type();
1756     if (obj != NULL &amp;&amp; (con_type-&gt;isa_instptr() || con_type-&gt;isa_aryptr())) {
1757        // Found:
1758        //   Bool(CmpP(LoadKlass(obj._klass), ConP(Foo.klass)), [eq])
1759        // or the narrowOop equivalent.
1760        const Type* obj_type = _gvn.type(obj);
1761        const TypeOopPtr* tboth = obj_type-&gt;join_speculative(con_type)-&gt;isa_oopptr();
1762        if (tboth != NULL &amp;&amp; tboth-&gt;klass_is_exact() &amp;&amp; tboth != obj_type &amp;&amp;
1763            tboth-&gt;higher_equal(obj_type)) {
1764           // obj has to be of the exact type Foo if the CmpP succeeds.
1765           int obj_in_map = map()-&gt;find_edge(obj);
1766           JVMState* jvms = this-&gt;jvms();
1767           if (obj_in_map &gt;= 0 &amp;&amp;
1768               (jvms-&gt;is_loc(obj_in_map) || jvms-&gt;is_stk(obj_in_map))) {
1769             TypeNode* ccast = new CheckCastPPNode(control(), obj, tboth);
1770             const Type* tcc = ccast-&gt;as_Type()-&gt;type();
1771             assert(tcc != obj_type &amp;&amp; tcc-&gt;higher_equal(obj_type), &quot;must improve&quot;);
1772             // Delay transform() call to allow recovery of pre-cast value
1773             // at the control merge.
1774             _gvn.set_type_bottom(ccast);
1775             record_for_igvn(ccast);
1776             // Here&#39;s the payoff.
1777             replace_in_map(obj, ccast);
1778           }
1779        }
1780     }
1781   }
1782 
1783   int val_in_map = map()-&gt;find_edge(val);
1784   if (val_in_map &lt; 0)  return;          // replace_in_map would be useless
1785   {
1786     JVMState* jvms = this-&gt;jvms();
1787     if (!(jvms-&gt;is_loc(val_in_map) ||
1788           jvms-&gt;is_stk(val_in_map)))
1789       return;                           // again, it would be useless
1790   }
1791 
1792   // Check for a comparison to a constant, and &quot;know&quot; that the compared
1793   // value is constrained on this path.
1794   assert(tcon-&gt;singleton(), &quot;&quot;);
1795   ConstraintCastNode* ccast = NULL;
1796   Node* cast = NULL;
1797 
1798   switch (btest) {
1799   case BoolTest::eq:                    // Constant test?
1800     {
1801       const Type* tboth = tcon-&gt;join_speculative(tval);
1802       if (tboth == tval)  break;        // Nothing to gain.
1803       if (tcon-&gt;isa_int()) {
1804         ccast = new CastIINode(val, tboth);
1805       } else if (tcon == TypePtr::NULL_PTR) {
1806         // Cast to null, but keep the pointer identity temporarily live.
1807         ccast = new CastPPNode(val, tboth);
1808       } else {
1809         const TypeF* tf = tcon-&gt;isa_float_constant();
1810         const TypeD* td = tcon-&gt;isa_double_constant();
1811         // Exclude tests vs float/double 0 as these could be
1812         // either +0 or -0.  Just because you are equal to +0
1813         // doesn&#39;t mean you ARE +0!
1814         // Note, following code also replaces Long and Oop values.
1815         if ((!tf || tf-&gt;_f != 0.0) &amp;&amp;
1816             (!td || td-&gt;_d != 0.0))
1817           cast = con;                   // Replace non-constant val by con.
1818       }
1819     }
1820     break;
1821 
1822   case BoolTest::ne:
1823     if (tcon == TypePtr::NULL_PTR) {
1824       cast = cast_not_null(val, false);
1825     }
1826     break;
1827 
1828   default:
1829     // (At this point we could record int range types with CastII.)
1830     break;
1831   }
1832 
1833   if (ccast != NULL) {
1834     const Type* tcc = ccast-&gt;as_Type()-&gt;type();
1835     assert(tcc != tval &amp;&amp; tcc-&gt;higher_equal(tval), &quot;must improve&quot;);
1836     // Delay transform() call to allow recovery of pre-cast value
1837     // at the control merge.
1838     ccast-&gt;set_req(0, control());
1839     _gvn.set_type_bottom(ccast);
1840     record_for_igvn(ccast);
1841     cast = ccast;
1842   }
1843 
1844   if (cast != NULL) {                   // Here&#39;s the payoff.
1845     replace_in_map(val, cast);
1846   }
1847 }
1848 
1849 /**
1850  * Use speculative type to optimize CmpP node: if comparison is
1851  * against the low level class, cast the object to the speculative
1852  * type if any. CmpP should then go away.
1853  *
1854  * @param c  expected CmpP node
1855  * @return   result of CmpP on object casted to speculative type
1856  *
1857  */
1858 Node* Parse::optimize_cmp_with_klass(Node* c) {
1859   // If this is transformed by the _gvn to a comparison with the low
1860   // level klass then we may be able to use speculation
1861   if (c-&gt;Opcode() == Op_CmpP &amp;&amp;
1862       (c-&gt;in(1)-&gt;Opcode() == Op_LoadKlass || c-&gt;in(1)-&gt;Opcode() == Op_DecodeNKlass) &amp;&amp;
1863       c-&gt;in(2)-&gt;is_Con()) {
1864     Node* load_klass = NULL;
1865     Node* decode = NULL;
1866     if (c-&gt;in(1)-&gt;Opcode() == Op_DecodeNKlass) {
1867       decode = c-&gt;in(1);
1868       load_klass = c-&gt;in(1)-&gt;in(1);
1869     } else {
1870       load_klass = c-&gt;in(1);
1871     }
1872     if (load_klass-&gt;in(2)-&gt;is_AddP()) {
1873       Node* addp = load_klass-&gt;in(2);
1874       Node* obj = addp-&gt;in(AddPNode::Address);
1875       const TypeOopPtr* obj_type = _gvn.type(obj)-&gt;is_oopptr();
1876       if (obj_type-&gt;speculative_type_not_null() != NULL) {
1877         ciKlass* k = obj_type-&gt;speculative_type();
1878         inc_sp(2);
1879         obj = maybe_cast_profiled_obj(obj, k);
1880         dec_sp(2);
1881         // Make the CmpP use the casted obj
1882         addp = basic_plus_adr(obj, addp-&gt;in(AddPNode::Offset));
1883         load_klass = load_klass-&gt;clone();
1884         load_klass-&gt;set_req(2, addp);
1885         load_klass = _gvn.transform(load_klass);
1886         if (decode != NULL) {
1887           decode = decode-&gt;clone();
1888           decode-&gt;set_req(1, load_klass);
1889           load_klass = _gvn.transform(decode);
1890         }
1891         c = c-&gt;clone();
1892         c-&gt;set_req(1, load_klass);
1893         c = _gvn.transform(c);
1894       }
1895     }
1896   }
1897   return c;
1898 }
1899 
1900 //------------------------------do_one_bytecode--------------------------------
1901 // Parse this bytecode, and alter the Parsers JVM-&gt;Node mapping
1902 void Parse::do_one_bytecode() {
1903   Node *a, *b, *c, *d;          // Handy temps
1904   BoolTest::mask btest;
1905   int i;
1906 
1907   assert(!has_exceptions(), &quot;bytecode entry state must be clear of throws&quot;);
1908 
1909   if (C-&gt;check_node_count(NodeLimitFudgeFactor * 5,
1910                           &quot;out of nodes parsing method&quot;)) {
1911     return;
1912   }
1913 
1914 #ifdef ASSERT
1915   // for setting breakpoints
1916   if (TraceOptoParse) {
1917     tty-&gt;print(&quot; @&quot;);
1918     dump_bci(bci());
1919     tty-&gt;cr();
1920   }
1921 #endif
1922 
1923   switch (bc()) {
1924   case Bytecodes::_nop:
1925     // do nothing
1926     break;
1927   case Bytecodes::_lconst_0:
1928     push_pair(longcon(0));
1929     break;
1930 
1931   case Bytecodes::_lconst_1:
1932     push_pair(longcon(1));
1933     break;
1934 
1935   case Bytecodes::_fconst_0:
1936     push(zerocon(T_FLOAT));
1937     break;
1938 
1939   case Bytecodes::_fconst_1:
1940     push(makecon(TypeF::ONE));
1941     break;
1942 
1943   case Bytecodes::_fconst_2:
1944     push(makecon(TypeF::make(2.0f)));
1945     break;
1946 
1947   case Bytecodes::_dconst_0:
1948     push_pair(zerocon(T_DOUBLE));
1949     break;
1950 
1951   case Bytecodes::_dconst_1:
1952     push_pair(makecon(TypeD::ONE));
1953     break;
1954 
1955   case Bytecodes::_iconst_m1:push(intcon(-1)); break;
1956   case Bytecodes::_iconst_0: push(intcon( 0)); break;
1957   case Bytecodes::_iconst_1: push(intcon( 1)); break;
1958   case Bytecodes::_iconst_2: push(intcon( 2)); break;
1959   case Bytecodes::_iconst_3: push(intcon( 3)); break;
1960   case Bytecodes::_iconst_4: push(intcon( 4)); break;
1961   case Bytecodes::_iconst_5: push(intcon( 5)); break;
1962   case Bytecodes::_bipush:   push(intcon(iter().get_constant_u1())); break;
1963   case Bytecodes::_sipush:   push(intcon(iter().get_constant_u2())); break;
1964   case Bytecodes::_aconst_null: push(null());  break;
1965   case Bytecodes::_ldc:
1966   case Bytecodes::_ldc_w:
1967   case Bytecodes::_ldc2_w:
1968     // If the constant is unresolved, run this BC once in the interpreter.
1969     {
1970       ciConstant constant = iter().get_constant();
1971       if (!constant.is_valid() ||
1972           (constant.basic_type() == T_OBJECT &amp;&amp;
1973            !constant.as_object()-&gt;is_loaded())) {
1974         int index = iter().get_constant_pool_index();
1975         constantTag tag = iter().get_constant_pool_tag(index);
1976         uncommon_trap(Deoptimization::make_trap_request
1977                       (Deoptimization::Reason_unloaded,
1978                        Deoptimization::Action_reinterpret,
1979                        index),
1980                       NULL, tag.internal_name());
1981         break;
1982       }
1983       assert(constant.basic_type() != T_OBJECT || constant.as_object()-&gt;is_instance(),
1984              &quot;must be java_mirror of klass&quot;);
1985       const Type* con_type = Type::make_from_constant(constant);
1986       if (con_type != NULL) {
1987         push_node(con_type-&gt;basic_type(), makecon(con_type));
1988       }
1989     }
1990 
1991     break;
1992 
1993   case Bytecodes::_aload_0:
1994     push( local(0) );
1995     break;
1996   case Bytecodes::_aload_1:
1997     push( local(1) );
1998     break;
1999   case Bytecodes::_aload_2:
2000     push( local(2) );
2001     break;
2002   case Bytecodes::_aload_3:
2003     push( local(3) );
2004     break;
2005   case Bytecodes::_aload:
2006     push( local(iter().get_index()) );
2007     break;
2008 
2009   case Bytecodes::_fload_0:
2010   case Bytecodes::_iload_0:
2011     push( local(0) );
2012     break;
2013   case Bytecodes::_fload_1:
2014   case Bytecodes::_iload_1:
2015     push( local(1) );
2016     break;
2017   case Bytecodes::_fload_2:
2018   case Bytecodes::_iload_2:
2019     push( local(2) );
2020     break;
2021   case Bytecodes::_fload_3:
2022   case Bytecodes::_iload_3:
2023     push( local(3) );
2024     break;
2025   case Bytecodes::_fload:
2026   case Bytecodes::_iload:
2027     push( local(iter().get_index()) );
2028     break;
2029   case Bytecodes::_lload_0:
2030     push_pair_local( 0 );
2031     break;
2032   case Bytecodes::_lload_1:
2033     push_pair_local( 1 );
2034     break;
2035   case Bytecodes::_lload_2:
2036     push_pair_local( 2 );
2037     break;
2038   case Bytecodes::_lload_3:
2039     push_pair_local( 3 );
2040     break;
2041   case Bytecodes::_lload:
2042     push_pair_local( iter().get_index() );
2043     break;
2044 
2045   case Bytecodes::_dload_0:
2046     push_pair_local(0);
2047     break;
2048   case Bytecodes::_dload_1:
2049     push_pair_local(1);
2050     break;
2051   case Bytecodes::_dload_2:
2052     push_pair_local(2);
2053     break;
2054   case Bytecodes::_dload_3:
2055     push_pair_local(3);
2056     break;
2057   case Bytecodes::_dload:
2058     push_pair_local(iter().get_index());
2059     break;
2060   case Bytecodes::_fstore_0:
2061   case Bytecodes::_istore_0:
2062   case Bytecodes::_astore_0:
2063     set_local( 0, pop() );
2064     break;
2065   case Bytecodes::_fstore_1:
2066   case Bytecodes::_istore_1:
2067   case Bytecodes::_astore_1:
2068     set_local( 1, pop() );
2069     break;
2070   case Bytecodes::_fstore_2:
2071   case Bytecodes::_istore_2:
2072   case Bytecodes::_astore_2:
2073     set_local( 2, pop() );
2074     break;
2075   case Bytecodes::_fstore_3:
2076   case Bytecodes::_istore_3:
2077   case Bytecodes::_astore_3:
2078     set_local( 3, pop() );
2079     break;
2080   case Bytecodes::_fstore:
2081   case Bytecodes::_istore:
2082   case Bytecodes::_astore:
2083     set_local( iter().get_index(), pop() );
2084     break;
2085   // long stores
2086   case Bytecodes::_lstore_0:
2087     set_pair_local( 0, pop_pair() );
2088     break;
2089   case Bytecodes::_lstore_1:
2090     set_pair_local( 1, pop_pair() );
2091     break;
2092   case Bytecodes::_lstore_2:
2093     set_pair_local( 2, pop_pair() );
2094     break;
2095   case Bytecodes::_lstore_3:
2096     set_pair_local( 3, pop_pair() );
2097     break;
2098   case Bytecodes::_lstore:
2099     set_pair_local( iter().get_index(), pop_pair() );
2100     break;
2101 
2102   // double stores
2103   case Bytecodes::_dstore_0:
2104     set_pair_local( 0, dstore_rounding(pop_pair()) );
2105     break;
2106   case Bytecodes::_dstore_1:
2107     set_pair_local( 1, dstore_rounding(pop_pair()) );
2108     break;
2109   case Bytecodes::_dstore_2:
2110     set_pair_local( 2, dstore_rounding(pop_pair()) );
2111     break;
2112   case Bytecodes::_dstore_3:
2113     set_pair_local( 3, dstore_rounding(pop_pair()) );
2114     break;
2115   case Bytecodes::_dstore:
2116     set_pair_local( iter().get_index(), dstore_rounding(pop_pair()) );
2117     break;
2118 
2119   case Bytecodes::_pop:  dec_sp(1);   break;
2120   case Bytecodes::_pop2: dec_sp(2);   break;
2121   case Bytecodes::_swap:
2122     a = pop();
2123     b = pop();
2124     push(a);
2125     push(b);
2126     break;
2127   case Bytecodes::_dup:
2128     a = pop();
2129     push(a);
2130     push(a);
2131     break;
2132   case Bytecodes::_dup_x1:
2133     a = pop();
2134     b = pop();
2135     push( a );
2136     push( b );
2137     push( a );
2138     break;
2139   case Bytecodes::_dup_x2:
2140     a = pop();
2141     b = pop();
2142     c = pop();
2143     push( a );
2144     push( c );
2145     push( b );
2146     push( a );
2147     break;
2148   case Bytecodes::_dup2:
2149     a = pop();
2150     b = pop();
2151     push( b );
2152     push( a );
2153     push( b );
2154     push( a );
2155     break;
2156 
2157   case Bytecodes::_dup2_x1:
2158     // before: .. c, b, a
2159     // after:  .. b, a, c, b, a
2160     // not tested
2161     a = pop();
2162     b = pop();
2163     c = pop();
2164     push( b );
2165     push( a );
2166     push( c );
2167     push( b );
2168     push( a );
2169     break;
2170   case Bytecodes::_dup2_x2:
2171     // before: .. d, c, b, a
2172     // after:  .. b, a, d, c, b, a
2173     // not tested
2174     a = pop();
2175     b = pop();
2176     c = pop();
2177     d = pop();
2178     push( b );
2179     push( a );
2180     push( d );
2181     push( c );
2182     push( b );
2183     push( a );
2184     break;
2185 
2186   case Bytecodes::_arraylength: {
2187     // Must do null-check with value on expression stack
2188     Node *ary = null_check(peek(), T_ARRAY);
2189     // Compile-time detect of null-exception?
2190     if (stopped())  return;
2191     a = pop();
2192     push(load_array_length(a));
2193     break;
2194   }
2195 
2196   case Bytecodes::_baload:  array_load(T_BYTE);    break;
2197   case Bytecodes::_caload:  array_load(T_CHAR);    break;
2198   case Bytecodes::_iaload:  array_load(T_INT);     break;
2199   case Bytecodes::_saload:  array_load(T_SHORT);   break;
2200   case Bytecodes::_faload:  array_load(T_FLOAT);   break;
2201   case Bytecodes::_aaload:  array_load(T_OBJECT);  break;
2202   case Bytecodes::_laload:  array_load(T_LONG);    break;
2203   case Bytecodes::_daload:  array_load(T_DOUBLE);  break;
2204   case Bytecodes::_bastore: array_store(T_BYTE);   break;
2205   case Bytecodes::_castore: array_store(T_CHAR);   break;
2206   case Bytecodes::_iastore: array_store(T_INT);    break;
2207   case Bytecodes::_sastore: array_store(T_SHORT);  break;
2208   case Bytecodes::_fastore: array_store(T_FLOAT);  break;
2209   case Bytecodes::_aastore: array_store(T_OBJECT); break;
2210   case Bytecodes::_lastore: array_store(T_LONG);   break;
2211   case Bytecodes::_dastore: array_store(T_DOUBLE); break;
2212 
2213   case Bytecodes::_getfield:
2214     do_getfield();
2215     break;
2216 
2217   case Bytecodes::_getstatic:
2218     do_getstatic();
2219     break;
2220 
2221   case Bytecodes::_putfield:
2222     do_putfield();
2223     break;
2224 
2225   case Bytecodes::_putstatic:
2226     do_putstatic();
2227     break;
2228 
2229   case Bytecodes::_irem:
2230     do_irem();
2231     break;
2232   case Bytecodes::_idiv:
2233     // Must keep both values on the expression-stack during null-check
2234     zero_check_int(peek());
2235     // Compile-time detect of null-exception?
2236     if (stopped())  return;
2237     b = pop();
2238     a = pop();
2239     push( _gvn.transform( new DivINode(control(),a,b) ) );
2240     break;
2241   case Bytecodes::_imul:
2242     b = pop(); a = pop();
2243     push( _gvn.transform( new MulINode(a,b) ) );
2244     break;
2245   case Bytecodes::_iadd:
2246     b = pop(); a = pop();
2247     push( _gvn.transform( new AddINode(a,b) ) );
2248     break;
2249   case Bytecodes::_ineg:
2250     a = pop();
2251     push( _gvn.transform( new SubINode(_gvn.intcon(0),a)) );
2252     break;
2253   case Bytecodes::_isub:
2254     b = pop(); a = pop();
2255     push( _gvn.transform( new SubINode(a,b) ) );
2256     break;
2257   case Bytecodes::_iand:
2258     b = pop(); a = pop();
2259     push( _gvn.transform( new AndINode(a,b) ) );
2260     break;
2261   case Bytecodes::_ior:
2262     b = pop(); a = pop();
2263     push( _gvn.transform( new OrINode(a,b) ) );
2264     break;
2265   case Bytecodes::_ixor:
2266     b = pop(); a = pop();
2267     push( _gvn.transform( new XorINode(a,b) ) );
2268     break;
2269   case Bytecodes::_ishl:
2270     b = pop(); a = pop();
2271     push( _gvn.transform( new LShiftINode(a,b) ) );
2272     break;
2273   case Bytecodes::_ishr:
2274     b = pop(); a = pop();
2275     push( _gvn.transform( new RShiftINode(a,b) ) );
2276     break;
2277   case Bytecodes::_iushr:
2278     b = pop(); a = pop();
2279     push( _gvn.transform( new URShiftINode(a,b) ) );
2280     break;
2281 
2282   case Bytecodes::_fneg:
2283     a = pop();
2284     b = _gvn.transform(new NegFNode (a));
2285     push(b);
2286     break;
2287 
2288   case Bytecodes::_fsub:
2289     b = pop();
2290     a = pop();
2291     c = _gvn.transform( new SubFNode(a,b) );
2292     d = precision_rounding(c);
2293     push( d );
2294     break;
2295 
2296   case Bytecodes::_fadd:
2297     b = pop();
2298     a = pop();
2299     c = _gvn.transform( new AddFNode(a,b) );
2300     d = precision_rounding(c);
2301     push( d );
2302     break;
2303 
2304   case Bytecodes::_fmul:
2305     b = pop();
2306     a = pop();
2307     c = _gvn.transform( new MulFNode(a,b) );
2308     d = precision_rounding(c);
2309     push( d );
2310     break;
2311 
2312   case Bytecodes::_fdiv:
2313     b = pop();
2314     a = pop();
2315     c = _gvn.transform( new DivFNode(0,a,b) );
2316     d = precision_rounding(c);
2317     push( d );
2318     break;
2319 
2320   case Bytecodes::_frem:
2321     if (Matcher::has_match_rule(Op_ModF)) {
2322       // Generate a ModF node.
2323       b = pop();
2324       a = pop();
2325       c = _gvn.transform( new ModFNode(0,a,b) );
2326       d = precision_rounding(c);
2327       push( d );
2328     }
2329     else {
2330       // Generate a call.
2331       modf();
2332     }
2333     break;
2334 
2335   case Bytecodes::_fcmpl:
2336     b = pop();
2337     a = pop();
2338     c = _gvn.transform( new CmpF3Node( a, b));
2339     push(c);
2340     break;
2341   case Bytecodes::_fcmpg:
2342     b = pop();
2343     a = pop();
2344 
2345     // Same as fcmpl but need to flip the unordered case.  Swap the inputs,
2346     // which negates the result sign except for unordered.  Flip the unordered
2347     // as well by using CmpF3 which implements unordered-lesser instead of
2348     // unordered-greater semantics.  Finally, commute the result bits.  Result
2349     // is same as using a CmpF3Greater except we did it with CmpF3 alone.
2350     c = _gvn.transform( new CmpF3Node( b, a));
2351     c = _gvn.transform( new SubINode(_gvn.intcon(0),c) );
2352     push(c);
2353     break;
2354 
2355   case Bytecodes::_f2i:
2356     a = pop();
2357     push(_gvn.transform(new ConvF2INode(a)));
2358     break;
2359 
2360   case Bytecodes::_d2i:
2361     a = pop_pair();
2362     b = _gvn.transform(new ConvD2INode(a));
2363     push( b );
2364     break;
2365 
2366   case Bytecodes::_f2d:
2367     a = pop();
2368     b = _gvn.transform( new ConvF2DNode(a));
2369     push_pair( b );
2370     break;
2371 
2372   case Bytecodes::_d2f:
2373     a = pop_pair();
2374     b = _gvn.transform( new ConvD2FNode(a));
2375     // This breaks _227_mtrt (speed &amp; correctness) and _222_mpegaudio (speed)
2376     //b = _gvn.transform(new RoundFloatNode(0, b) );
2377     push( b );
2378     break;
2379 
2380   case Bytecodes::_l2f:
2381     if (Matcher::convL2FSupported()) {
2382       a = pop_pair();
2383       b = _gvn.transform( new ConvL2FNode(a));
2384       // For i486.ad, FILD doesn&#39;t restrict precision to 24 or 53 bits.
2385       // Rather than storing the result into an FP register then pushing
2386       // out to memory to round, the machine instruction that implements
2387       // ConvL2D is responsible for rounding.
2388       // c = precision_rounding(b);
2389       c = _gvn.transform(b);
2390       push(c);
2391     } else {
2392       l2f();
2393     }
2394     break;
2395 
2396   case Bytecodes::_l2d:
2397     a = pop_pair();
2398     b = _gvn.transform( new ConvL2DNode(a));
2399     // For i486.ad, rounding is always necessary (see _l2f above).
2400     // c = dprecision_rounding(b);
2401     c = _gvn.transform(b);
2402     push_pair(c);
2403     break;
2404 
2405   case Bytecodes::_f2l:
2406     a = pop();
2407     b = _gvn.transform( new ConvF2LNode(a));
2408     push_pair(b);
2409     break;
2410 
2411   case Bytecodes::_d2l:
2412     a = pop_pair();
2413     b = _gvn.transform( new ConvD2LNode(a));
2414     push_pair(b);
2415     break;
2416 
2417   case Bytecodes::_dsub:
2418     b = pop_pair();
2419     a = pop_pair();
2420     c = _gvn.transform( new SubDNode(a,b) );
2421     d = dprecision_rounding(c);
2422     push_pair( d );
2423     break;
2424 
2425   case Bytecodes::_dadd:
2426     b = pop_pair();
2427     a = pop_pair();
2428     c = _gvn.transform( new AddDNode(a,b) );
2429     d = dprecision_rounding(c);
2430     push_pair( d );
2431     break;
2432 
2433   case Bytecodes::_dmul:
2434     b = pop_pair();
2435     a = pop_pair();
2436     c = _gvn.transform( new MulDNode(a,b) );
2437     d = dprecision_rounding(c);
2438     push_pair( d );
2439     break;
2440 
2441   case Bytecodes::_ddiv:
2442     b = pop_pair();
2443     a = pop_pair();
2444     c = _gvn.transform( new DivDNode(0,a,b) );
2445     d = dprecision_rounding(c);
2446     push_pair( d );
2447     break;
2448 
2449   case Bytecodes::_dneg:
2450     a = pop_pair();
2451     b = _gvn.transform(new NegDNode (a));
2452     push_pair(b);
2453     break;
2454 
2455   case Bytecodes::_drem:
2456     if (Matcher::has_match_rule(Op_ModD)) {
2457       // Generate a ModD node.
2458       b = pop_pair();
2459       a = pop_pair();
2460       // a % b
2461 
2462       c = _gvn.transform( new ModDNode(0,a,b) );
2463       d = dprecision_rounding(c);
2464       push_pair( d );
2465     }
2466     else {
2467       // Generate a call.
2468       modd();
2469     }
2470     break;
2471 
2472   case Bytecodes::_dcmpl:
2473     b = pop_pair();
2474     a = pop_pair();
2475     c = _gvn.transform( new CmpD3Node( a, b));
2476     push(c);
2477     break;
2478 
2479   case Bytecodes::_dcmpg:
2480     b = pop_pair();
2481     a = pop_pair();
2482     // Same as dcmpl but need to flip the unordered case.
2483     // Commute the inputs, which negates the result sign except for unordered.
2484     // Flip the unordered as well by using CmpD3 which implements
2485     // unordered-lesser instead of unordered-greater semantics.
2486     // Finally, negate the result bits.  Result is same as using a
2487     // CmpD3Greater except we did it with CmpD3 alone.
2488     c = _gvn.transform( new CmpD3Node( b, a));
2489     c = _gvn.transform( new SubINode(_gvn.intcon(0),c) );
2490     push(c);
2491     break;
2492 
2493 
2494     // Note for longs -&gt; lo word is on TOS, hi word is on TOS - 1
2495   case Bytecodes::_land:
2496     b = pop_pair();
2497     a = pop_pair();
2498     c = _gvn.transform( new AndLNode(a,b) );
2499     push_pair(c);
2500     break;
2501   case Bytecodes::_lor:
2502     b = pop_pair();
2503     a = pop_pair();
2504     c = _gvn.transform( new OrLNode(a,b) );
2505     push_pair(c);
2506     break;
2507   case Bytecodes::_lxor:
2508     b = pop_pair();
2509     a = pop_pair();
2510     c = _gvn.transform( new XorLNode(a,b) );
2511     push_pair(c);
2512     break;
2513 
2514   case Bytecodes::_lshl:
2515     b = pop();                  // the shift count
2516     a = pop_pair();             // value to be shifted
2517     c = _gvn.transform( new LShiftLNode(a,b) );
2518     push_pair(c);
2519     break;
2520   case Bytecodes::_lshr:
2521     b = pop();                  // the shift count
2522     a = pop_pair();             // value to be shifted
2523     c = _gvn.transform( new RShiftLNode(a,b) );
2524     push_pair(c);
2525     break;
2526   case Bytecodes::_lushr:
2527     b = pop();                  // the shift count
2528     a = pop_pair();             // value to be shifted
2529     c = _gvn.transform( new URShiftLNode(a,b) );
2530     push_pair(c);
2531     break;
2532   case Bytecodes::_lmul:
2533     b = pop_pair();
2534     a = pop_pair();
2535     c = _gvn.transform( new MulLNode(a,b) );
2536     push_pair(c);
2537     break;
2538 
2539   case Bytecodes::_lrem:
2540     // Must keep both values on the expression-stack during null-check
2541     assert(peek(0) == top(), &quot;long word order&quot;);
2542     zero_check_long(peek(1));
2543     // Compile-time detect of null-exception?
2544     if (stopped())  return;
2545     b = pop_pair();
2546     a = pop_pair();
2547     c = _gvn.transform( new ModLNode(control(),a,b) );
2548     push_pair(c);
2549     break;
2550 
2551   case Bytecodes::_ldiv:
2552     // Must keep both values on the expression-stack during null-check
2553     assert(peek(0) == top(), &quot;long word order&quot;);
2554     zero_check_long(peek(1));
2555     // Compile-time detect of null-exception?
2556     if (stopped())  return;
2557     b = pop_pair();
2558     a = pop_pair();
2559     c = _gvn.transform( new DivLNode(control(),a,b) );
2560     push_pair(c);
2561     break;
2562 
2563   case Bytecodes::_ladd:
2564     b = pop_pair();
2565     a = pop_pair();
2566     c = _gvn.transform( new AddLNode(a,b) );
2567     push_pair(c);
2568     break;
2569   case Bytecodes::_lsub:
2570     b = pop_pair();
2571     a = pop_pair();
2572     c = _gvn.transform( new SubLNode(a,b) );
2573     push_pair(c);
2574     break;
2575   case Bytecodes::_lcmp:
2576     // Safepoints are now inserted _before_ branches.  The long-compare
2577     // bytecode painfully produces a 3-way value (-1,0,+1) which requires a
2578     // slew of control flow.  These are usually followed by a CmpI vs zero and
2579     // a branch; this pattern then optimizes to the obvious long-compare and
2580     // branch.  However, if the branch is backwards there&#39;s a Safepoint
2581     // inserted.  The inserted Safepoint captures the JVM state at the
2582     // pre-branch point, i.e. it captures the 3-way value.  Thus if a
2583     // long-compare is used to control a loop the debug info will force
2584     // computation of the 3-way value, even though the generated code uses a
2585     // long-compare and branch.  We try to rectify the situation by inserting
2586     // a SafePoint here and have it dominate and kill the safepoint added at a
2587     // following backwards branch.  At this point the JVM state merely holds 2
2588     // longs but not the 3-way value.
2589     if( UseLoopSafepoints ) {
2590       switch( iter().next_bc() ) {
2591       case Bytecodes::_ifgt:
2592       case Bytecodes::_iflt:
2593       case Bytecodes::_ifge:
2594       case Bytecodes::_ifle:
2595       case Bytecodes::_ifne:
2596       case Bytecodes::_ifeq:
2597         // If this is a backwards branch in the bytecodes, add Safepoint
2598         maybe_add_safepoint(iter().next_get_dest());
2599       default:
2600         break;
2601       }
2602     }
2603     b = pop_pair();
2604     a = pop_pair();
2605     c = _gvn.transform( new CmpL3Node( a, b ));
2606     push(c);
2607     break;
2608 
2609   case Bytecodes::_lneg:
2610     a = pop_pair();
2611     b = _gvn.transform( new SubLNode(longcon(0),a));
2612     push_pair(b);
2613     break;
2614   case Bytecodes::_l2i:
2615     a = pop_pair();
2616     push( _gvn.transform( new ConvL2INode(a)));
2617     break;
2618   case Bytecodes::_i2l:
2619     a = pop();
2620     b = _gvn.transform( new ConvI2LNode(a));
2621     push_pair(b);
2622     break;
2623   case Bytecodes::_i2b:
2624     // Sign extend
2625     a = pop();
2626     a = _gvn.transform( new LShiftINode(a,_gvn.intcon(24)) );
2627     a = _gvn.transform( new RShiftINode(a,_gvn.intcon(24)) );
2628     push( a );
2629     break;
2630   case Bytecodes::_i2s:
2631     a = pop();
2632     a = _gvn.transform( new LShiftINode(a,_gvn.intcon(16)) );
2633     a = _gvn.transform( new RShiftINode(a,_gvn.intcon(16)) );
2634     push( a );
2635     break;
2636   case Bytecodes::_i2c:
2637     a = pop();
2638     push( _gvn.transform( new AndINode(a,_gvn.intcon(0xFFFF)) ) );
2639     break;
2640 
2641   case Bytecodes::_i2f:
2642     a = pop();
2643     b = _gvn.transform( new ConvI2FNode(a) ) ;
2644     c = precision_rounding(b);
2645     push (b);
2646     break;
2647 
2648   case Bytecodes::_i2d:
2649     a = pop();
2650     b = _gvn.transform( new ConvI2DNode(a));
2651     push_pair(b);
2652     break;
2653 
2654   case Bytecodes::_iinc:        // Increment local
2655     i = iter().get_index();     // Get local index
2656     set_local( i, _gvn.transform( new AddINode( _gvn.intcon(iter().get_iinc_con()), local(i) ) ) );
2657     break;
2658 
2659   // Exit points of synchronized methods must have an unlock node
2660   case Bytecodes::_return:
2661     return_current(NULL);
2662     break;
2663 
2664   case Bytecodes::_ireturn:
2665   case Bytecodes::_areturn:
2666   case Bytecodes::_freturn:
2667     return_current(pop());
2668     break;
2669   case Bytecodes::_lreturn:
2670     return_current(pop_pair());
2671     break;
2672   case Bytecodes::_dreturn:
2673     return_current(pop_pair());
2674     break;
2675 
2676   case Bytecodes::_athrow:
2677     // null exception oop throws NULL pointer exception
2678     null_check(peek());
2679     if (stopped())  return;
2680     // Hook the thrown exception directly to subsequent handlers.
2681     if (BailoutToInterpreterForThrows) {
2682       // Keep method interpreted from now on.
2683       uncommon_trap(Deoptimization::Reason_unhandled,
2684                     Deoptimization::Action_make_not_compilable);
2685       return;
2686     }
2687     if (env()-&gt;jvmti_can_post_on_exceptions()) {
2688       // check if we must post exception events, take uncommon trap if so (with must_throw = false)
2689       uncommon_trap_if_should_post_on_exceptions(Deoptimization::Reason_unhandled, false);
2690     }
2691     // Here if either can_post_on_exceptions or should_post_on_exceptions is false
2692     add_exception_state(make_exception_state(peek()));
2693     break;
2694 
2695   case Bytecodes::_goto:   // fall through
2696   case Bytecodes::_goto_w: {
2697     int target_bci = (bc() == Bytecodes::_goto) ? iter().get_dest() : iter().get_far_dest();
2698 
2699     // If this is a backwards branch in the bytecodes, add Safepoint
2700     maybe_add_safepoint(target_bci);
2701 
2702     // Update method data
2703     profile_taken_branch(target_bci);
2704 
2705     // Merge the current control into the target basic block
2706     merge(target_bci);
2707 
2708     // See if we can get some profile data and hand it off to the next block
2709     Block *target_block = block()-&gt;successor_for_bci(target_bci);
2710     if (target_block-&gt;pred_count() != 1)  break;
2711     ciMethodData* methodData = method()-&gt;method_data();
2712     if (!methodData-&gt;is_mature())  break;
2713     ciProfileData* data = methodData-&gt;bci_to_data(bci());
2714     assert(data != NULL &amp;&amp; data-&gt;is_JumpData(), &quot;need JumpData for taken branch&quot;);
2715     int taken = ((ciJumpData*)data)-&gt;taken();
2716     taken = method()-&gt;scale_count(taken);
2717     target_block-&gt;set_count(taken);
2718     break;
2719   }
2720 
2721   case Bytecodes::_ifnull:    btest = BoolTest::eq; goto handle_if_null;
2722   case Bytecodes::_ifnonnull: btest = BoolTest::ne; goto handle_if_null;
2723   handle_if_null:
2724     // If this is a backwards branch in the bytecodes, add Safepoint
2725     maybe_add_safepoint(iter().get_dest());
2726     a = null();
2727     b = pop();
2728     if (!_gvn.type(b)-&gt;speculative_maybe_null() &amp;&amp;
2729         !too_many_traps(Deoptimization::Reason_speculate_null_check)) {
2730       inc_sp(1);
2731       Node* null_ctl = top();
2732       b = null_check_oop(b, &amp;null_ctl, true, true, true);
2733       assert(null_ctl-&gt;is_top(), &quot;no null control here&quot;);
2734       dec_sp(1);
2735     } else if (_gvn.type(b)-&gt;speculative_always_null() &amp;&amp;
2736                !too_many_traps(Deoptimization::Reason_speculate_null_assert)) {
2737       inc_sp(1);
2738       b = null_assert(b);
2739       dec_sp(1);
2740     }
2741     c = _gvn.transform( new CmpPNode(b, a) );
2742     do_ifnull(btest, c);
2743     break;
2744 
2745   case Bytecodes::_if_acmpeq: btest = BoolTest::eq; goto handle_if_acmp;
2746   case Bytecodes::_if_acmpne: btest = BoolTest::ne; goto handle_if_acmp;
2747   handle_if_acmp:
2748     // If this is a backwards branch in the bytecodes, add Safepoint
2749     maybe_add_safepoint(iter().get_dest());
<a name="14" id="anc14"></a><span class="line-modified">2750     a = access_resolve(pop(), 0);</span>
<span class="line-modified">2751     b = access_resolve(pop(), 0);</span>
2752     c = _gvn.transform( new CmpPNode(b, a) );
2753     c = optimize_cmp_with_klass(c);
2754     do_if(btest, c);
2755     break;
2756 
2757   case Bytecodes::_ifeq: btest = BoolTest::eq; goto handle_ifxx;
2758   case Bytecodes::_ifne: btest = BoolTest::ne; goto handle_ifxx;
2759   case Bytecodes::_iflt: btest = BoolTest::lt; goto handle_ifxx;
2760   case Bytecodes::_ifle: btest = BoolTest::le; goto handle_ifxx;
2761   case Bytecodes::_ifgt: btest = BoolTest::gt; goto handle_ifxx;
2762   case Bytecodes::_ifge: btest = BoolTest::ge; goto handle_ifxx;
2763   handle_ifxx:
2764     // If this is a backwards branch in the bytecodes, add Safepoint
2765     maybe_add_safepoint(iter().get_dest());
2766     a = _gvn.intcon(0);
2767     b = pop();
2768     c = _gvn.transform( new CmpINode(b, a) );
2769     do_if(btest, c);
2770     break;
2771 
2772   case Bytecodes::_if_icmpeq: btest = BoolTest::eq; goto handle_if_icmp;
2773   case Bytecodes::_if_icmpne: btest = BoolTest::ne; goto handle_if_icmp;
2774   case Bytecodes::_if_icmplt: btest = BoolTest::lt; goto handle_if_icmp;
2775   case Bytecodes::_if_icmple: btest = BoolTest::le; goto handle_if_icmp;
2776   case Bytecodes::_if_icmpgt: btest = BoolTest::gt; goto handle_if_icmp;
2777   case Bytecodes::_if_icmpge: btest = BoolTest::ge; goto handle_if_icmp;
2778   handle_if_icmp:
2779     // If this is a backwards branch in the bytecodes, add Safepoint
2780     maybe_add_safepoint(iter().get_dest());
2781     a = pop();
2782     b = pop();
2783     c = _gvn.transform( new CmpINode( b, a ) );
2784     do_if(btest, c);
2785     break;
2786 
2787   case Bytecodes::_tableswitch:
2788     do_tableswitch();
2789     break;
2790 
2791   case Bytecodes::_lookupswitch:
2792     do_lookupswitch();
2793     break;
2794 
2795   case Bytecodes::_invokestatic:
2796   case Bytecodes::_invokedynamic:
2797   case Bytecodes::_invokespecial:
2798   case Bytecodes::_invokevirtual:
2799   case Bytecodes::_invokeinterface:
2800     do_call();
2801     break;
2802   case Bytecodes::_checkcast:
2803     do_checkcast();
2804     break;
2805   case Bytecodes::_instanceof:
2806     do_instanceof();
2807     break;
2808   case Bytecodes::_anewarray:
2809     do_anewarray();
2810     break;
2811   case Bytecodes::_newarray:
2812     do_newarray((BasicType)iter().get_index());
2813     break;
2814   case Bytecodes::_multianewarray:
2815     do_multianewarray();
2816     break;
2817   case Bytecodes::_new:
2818     do_new();
2819     break;
2820 
2821   case Bytecodes::_jsr:
2822   case Bytecodes::_jsr_w:
2823     do_jsr();
2824     break;
2825 
2826   case Bytecodes::_ret:
2827     do_ret();
2828     break;
2829 
2830 
2831   case Bytecodes::_monitorenter:
2832     do_monitor_enter();
2833     break;
2834 
2835   case Bytecodes::_monitorexit:
2836     do_monitor_exit();
2837     break;
2838 
2839   case Bytecodes::_breakpoint:
2840     // Breakpoint set concurrently to compile
2841     // %%% use an uncommon trap?
2842     C-&gt;record_failure(&quot;breakpoint in method&quot;);
2843     return;
2844 
2845   default:
2846 #ifndef PRODUCT
2847     map()-&gt;dump(99);
2848 #endif
2849     tty-&gt;print(&quot;\nUnhandled bytecode %s\n&quot;, Bytecodes::name(bc()) );
2850     ShouldNotReachHere();
2851   }
2852 
2853 #ifndef PRODUCT
2854   IdealGraphPrinter *printer = C-&gt;printer();
2855   if (printer &amp;&amp; printer-&gt;should_print(1)) {
2856     char buffer[256];
2857     jio_snprintf(buffer, sizeof(buffer), &quot;Bytecode %d: %s&quot;, bci(), Bytecodes::name(bc()));
2858     bool old = printer-&gt;traverse_outs();
2859     printer-&gt;set_traverse_outs(true);
2860     printer-&gt;print_method(buffer, 4);
2861     printer-&gt;set_traverse_outs(old);
2862   }
2863 #endif
2864 }
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/macro.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;compiler/compileLog.hpp&quot;
  27 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  28 #include &quot;libadt/vectset.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added">  29 #include &quot;memory/universe.hpp&quot;</span>
  30 #include &quot;opto/addnode.hpp&quot;
  31 #include &quot;opto/arraycopynode.hpp&quot;
  32 #include &quot;opto/callnode.hpp&quot;
  33 #include &quot;opto/castnode.hpp&quot;
  34 #include &quot;opto/cfgnode.hpp&quot;
  35 #include &quot;opto/compile.hpp&quot;
  36 #include &quot;opto/convertnode.hpp&quot;
  37 #include &quot;opto/graphKit.hpp&quot;
<a name="3" id="anc3"></a><span class="line-added">  38 #include &quot;opto/intrinsicnode.hpp&quot;</span>
  39 #include &quot;opto/locknode.hpp&quot;
  40 #include &quot;opto/loopnode.hpp&quot;
  41 #include &quot;opto/macro.hpp&quot;
  42 #include &quot;opto/memnode.hpp&quot;
  43 #include &quot;opto/narrowptrnode.hpp&quot;
  44 #include &quot;opto/node.hpp&quot;
  45 #include &quot;opto/opaquenode.hpp&quot;
  46 #include &quot;opto/phaseX.hpp&quot;
  47 #include &quot;opto/rootnode.hpp&quot;
  48 #include &quot;opto/runtime.hpp&quot;
  49 #include &quot;opto/subnode.hpp&quot;
<a name="4" id="anc4"></a><span class="line-added">  50 #include &quot;opto/subtypenode.hpp&quot;</span>
  51 #include &quot;opto/type.hpp&quot;
  52 #include &quot;runtime/sharedRuntime.hpp&quot;
  53 #include &quot;utilities/macros.hpp&quot;
<a name="5" id="anc5"></a><span class="line-added">  54 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  55 #if INCLUDE_G1GC
  56 #include &quot;gc/g1/g1ThreadLocalData.hpp&quot;
  57 #endif // INCLUDE_G1GC
  58 #if INCLUDE_SHENANDOAHGC
  59 #include &quot;gc/shenandoah/c2/shenandoahBarrierSetC2.hpp&quot;
  60 #endif
  61 
  62 
  63 //
  64 // Replace any references to &quot;oldref&quot; in inputs to &quot;use&quot; with &quot;newref&quot;.
  65 // Returns the number of replacements made.
  66 //
  67 int PhaseMacroExpand::replace_input(Node *use, Node *oldref, Node *newref) {
  68   int nreplacements = 0;
  69   uint req = use-&gt;req();
  70   for (uint j = 0; j &lt; use-&gt;len(); j++) {
  71     Node *uin = use-&gt;in(j);
  72     if (uin == oldref) {
  73       if (j &lt; req)
  74         use-&gt;set_req(j, newref);
  75       else
  76         use-&gt;set_prec(j, newref);
  77       nreplacements++;
  78     } else if (j &gt;= req &amp;&amp; uin == NULL) {
  79       break;
  80     }
  81   }
  82   return nreplacements;
  83 }
  84 
<a name="6" id="anc6"></a><span class="line-added">  85 void PhaseMacroExpand::migrate_outs(Node *old, Node *target) {</span>
<span class="line-added">  86   assert(old != NULL, &quot;sanity&quot;);</span>
<span class="line-added">  87   for (DUIterator_Fast imax, i = old-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-added">  88     Node* use = old-&gt;fast_out(i);</span>
<span class="line-added">  89     _igvn.rehash_node_delayed(use);</span>
<span class="line-added">  90     imax -= replace_input(use, old, target);</span>
<span class="line-added">  91     // back up iterator</span>
<span class="line-added">  92     --i;</span>
<span class="line-added">  93   }</span>
<span class="line-added">  94   assert(old-&gt;outcnt() == 0, &quot;all uses must be deleted&quot;);</span>
<span class="line-added">  95 }</span>
<span class="line-added">  96 </span>
  97 void PhaseMacroExpand::copy_call_debug_info(CallNode *oldcall, CallNode * newcall) {
  98   // Copy debug information and adjust JVMState information
  99   uint old_dbg_start = oldcall-&gt;tf()-&gt;domain()-&gt;cnt();
 100   uint new_dbg_start = newcall-&gt;tf()-&gt;domain()-&gt;cnt();
 101   int jvms_adj  = new_dbg_start - old_dbg_start;
 102   assert (new_dbg_start == newcall-&gt;req(), &quot;argument count mismatch&quot;);
 103 
 104   // SafePointScalarObject node could be referenced several times in debug info.
 105   // Use Dict to record cloned nodes.
 106   Dict* sosn_map = new Dict(cmpkey,hashkey);
 107   for (uint i = old_dbg_start; i &lt; oldcall-&gt;req(); i++) {
 108     Node* old_in = oldcall-&gt;in(i);
 109     // Clone old SafePointScalarObjectNodes, adjusting their field contents.
 110     if (old_in != NULL &amp;&amp; old_in-&gt;is_SafePointScalarObject()) {
 111       SafePointScalarObjectNode* old_sosn = old_in-&gt;as_SafePointScalarObject();
 112       uint old_unique = C-&gt;unique();
 113       Node* new_in = old_sosn-&gt;clone(sosn_map);
 114       if (old_unique != C-&gt;unique()) { // New node?
 115         new_in-&gt;set_req(0, C-&gt;root()); // reset control edge
 116         new_in = transform_later(new_in); // Register new node.
 117       }
 118       old_in = new_in;
 119     }
 120     newcall-&gt;add_req(old_in);
 121   }
 122 
 123   // JVMS may be shared so clone it before we modify it
 124   newcall-&gt;set_jvms(oldcall-&gt;jvms() != NULL ? oldcall-&gt;jvms()-&gt;clone_deep(C) : NULL);
 125   for (JVMState *jvms = newcall-&gt;jvms(); jvms != NULL; jvms = jvms-&gt;caller()) {
 126     jvms-&gt;set_map(newcall);
 127     jvms-&gt;set_locoff(jvms-&gt;locoff()+jvms_adj);
 128     jvms-&gt;set_stkoff(jvms-&gt;stkoff()+jvms_adj);
 129     jvms-&gt;set_monoff(jvms-&gt;monoff()+jvms_adj);
 130     jvms-&gt;set_scloff(jvms-&gt;scloff()+jvms_adj);
 131     jvms-&gt;set_endoff(jvms-&gt;endoff()+jvms_adj);
 132   }
 133 }
 134 
 135 Node* PhaseMacroExpand::opt_bits_test(Node* ctrl, Node* region, int edge, Node* word, int mask, int bits, bool return_fast_path) {
 136   Node* cmp;
 137   if (mask != 0) {
 138     Node* and_node = transform_later(new AndXNode(word, MakeConX(mask)));
 139     cmp = transform_later(new CmpXNode(and_node, MakeConX(bits)));
 140   } else {
 141     cmp = word;
 142   }
 143   Node* bol = transform_later(new BoolNode(cmp, BoolTest::ne));
 144   IfNode* iff = new IfNode( ctrl, bol, PROB_MIN, COUNT_UNKNOWN );
 145   transform_later(iff);
 146 
 147   // Fast path taken.
 148   Node *fast_taken = transform_later(new IfFalseNode(iff));
 149 
 150   // Fast path not-taken, i.e. slow path
 151   Node *slow_taken = transform_later(new IfTrueNode(iff));
 152 
 153   if (return_fast_path) {
 154     region-&gt;init_req(edge, slow_taken); // Capture slow-control
 155     return fast_taken;
 156   } else {
 157     region-&gt;init_req(edge, fast_taken); // Capture fast-control
 158     return slow_taken;
 159   }
 160 }
 161 
 162 //--------------------copy_predefined_input_for_runtime_call--------------------
 163 void PhaseMacroExpand::copy_predefined_input_for_runtime_call(Node * ctrl, CallNode* oldcall, CallNode* call) {
 164   // Set fixed predefined input arguments
 165   call-&gt;init_req( TypeFunc::Control, ctrl );
 166   call-&gt;init_req( TypeFunc::I_O    , oldcall-&gt;in( TypeFunc::I_O) );
 167   call-&gt;init_req( TypeFunc::Memory , oldcall-&gt;in( TypeFunc::Memory ) ); // ?????
 168   call-&gt;init_req( TypeFunc::ReturnAdr, oldcall-&gt;in( TypeFunc::ReturnAdr ) );
 169   call-&gt;init_req( TypeFunc::FramePtr, oldcall-&gt;in( TypeFunc::FramePtr ) );
 170 }
 171 
 172 //------------------------------make_slow_call---------------------------------
 173 CallNode* PhaseMacroExpand::make_slow_call(CallNode *oldcall, const TypeFunc* slow_call_type,
 174                                            address slow_call, const char* leaf_name, Node* slow_path,
 175                                            Node* parm0, Node* parm1, Node* parm2) {
 176 
 177   // Slow-path call
 178  CallNode *call = leaf_name
 179    ? (CallNode*)new CallLeafNode      ( slow_call_type, slow_call, leaf_name, TypeRawPtr::BOTTOM )
 180    : (CallNode*)new CallStaticJavaNode( slow_call_type, slow_call, OptoRuntime::stub_name(slow_call), oldcall-&gt;jvms()-&gt;bci(), TypeRawPtr::BOTTOM );
 181 
 182   // Slow path call has no side-effects, uses few values
 183   copy_predefined_input_for_runtime_call(slow_path, oldcall, call );
 184   if (parm0 != NULL)  call-&gt;init_req(TypeFunc::Parms+0, parm0);
 185   if (parm1 != NULL)  call-&gt;init_req(TypeFunc::Parms+1, parm1);
 186   if (parm2 != NULL)  call-&gt;init_req(TypeFunc::Parms+2, parm2);
 187   copy_call_debug_info(oldcall, call);
 188   call-&gt;set_cnt(PROB_UNLIKELY_MAG(4));  // Same effect as RC_UNCOMMON.
 189   _igvn.replace_node(oldcall, call);
 190   transform_later(call);
 191 
 192   return call;
 193 }
 194 
 195 void PhaseMacroExpand::extract_call_projections(CallNode *call) {
 196   _fallthroughproj = NULL;
 197   _fallthroughcatchproj = NULL;
 198   _ioproj_fallthrough = NULL;
 199   _ioproj_catchall = NULL;
 200   _catchallcatchproj = NULL;
 201   _memproj_fallthrough = NULL;
 202   _memproj_catchall = NULL;
 203   _resproj = NULL;
 204   for (DUIterator_Fast imax, i = call-&gt;fast_outs(imax); i &lt; imax; i++) {
 205     ProjNode *pn = call-&gt;fast_out(i)-&gt;as_Proj();
 206     switch (pn-&gt;_con) {
 207       case TypeFunc::Control:
 208       {
 209         // For Control (fallthrough) and I_O (catch_all_index) we have CatchProj -&gt; Catch -&gt; Proj
 210         _fallthroughproj = pn;
 211         DUIterator_Fast jmax, j = pn-&gt;fast_outs(jmax);
 212         const Node *cn = pn-&gt;fast_out(j);
 213         if (cn-&gt;is_Catch()) {
 214           ProjNode *cpn = NULL;
 215           for (DUIterator_Fast kmax, k = cn-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 216             cpn = cn-&gt;fast_out(k)-&gt;as_Proj();
 217             assert(cpn-&gt;is_CatchProj(), &quot;must be a CatchProjNode&quot;);
 218             if (cpn-&gt;_con == CatchProjNode::fall_through_index)
 219               _fallthroughcatchproj = cpn;
 220             else {
 221               assert(cpn-&gt;_con == CatchProjNode::catch_all_index, &quot;must be correct index.&quot;);
 222               _catchallcatchproj = cpn;
 223             }
 224           }
 225         }
 226         break;
 227       }
 228       case TypeFunc::I_O:
 229         if (pn-&gt;_is_io_use)
 230           _ioproj_catchall = pn;
 231         else
 232           _ioproj_fallthrough = pn;
 233         break;
 234       case TypeFunc::Memory:
 235         if (pn-&gt;_is_io_use)
 236           _memproj_catchall = pn;
 237         else
 238           _memproj_fallthrough = pn;
 239         break;
 240       case TypeFunc::Parms:
 241         _resproj = pn;
 242         break;
 243       default:
 244         assert(false, &quot;unexpected projection from allocation node.&quot;);
 245     }
 246   }
 247 
 248 }
 249 
 250 void PhaseMacroExpand::eliminate_gc_barrier(Node* p2x) {
 251   BarrierSetC2 *bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 252   bs-&gt;eliminate_gc_barrier(this, p2x);
 253 }
 254 
 255 // Search for a memory operation for the specified memory slice.
 256 static Node *scan_mem_chain(Node *mem, int alias_idx, int offset, Node *start_mem, Node *alloc, PhaseGVN *phase) {
 257   Node *orig_mem = mem;
 258   Node *alloc_mem = alloc-&gt;in(TypeFunc::Memory);
 259   const TypeOopPtr *tinst = phase-&gt;C-&gt;get_adr_type(alias_idx)-&gt;isa_oopptr();
 260   while (true) {
 261     if (mem == alloc_mem || mem == start_mem ) {
 262       return mem;  // hit one of our sentinels
 263     } else if (mem-&gt;is_MergeMem()) {
 264       mem = mem-&gt;as_MergeMem()-&gt;memory_at(alias_idx);
 265     } else if (mem-&gt;is_Proj() &amp;&amp; mem-&gt;as_Proj()-&gt;_con == TypeFunc::Memory) {
 266       Node *in = mem-&gt;in(0);
 267       // we can safely skip over safepoints, calls, locks and membars because we
 268       // already know that the object is safe to eliminate.
 269       if (in-&gt;is_Initialize() &amp;&amp; in-&gt;as_Initialize()-&gt;allocation() == alloc) {
 270         return in;
 271       } else if (in-&gt;is_Call()) {
 272         CallNode *call = in-&gt;as_Call();
 273         if (call-&gt;may_modify(tinst, phase)) {
 274           assert(call-&gt;is_ArrayCopy(), &quot;ArrayCopy is the only call node that doesn&#39;t make allocation escape&quot;);
 275           if (call-&gt;as_ArrayCopy()-&gt;modifies(offset, offset, phase, false)) {
 276             return in;
 277           }
 278         }
 279         mem = in-&gt;in(TypeFunc::Memory);
 280       } else if (in-&gt;is_MemBar()) {
 281         ArrayCopyNode* ac = NULL;
 282         if (ArrayCopyNode::may_modify(tinst, in-&gt;as_MemBar(), phase, ac)) {
 283           assert(ac != NULL &amp;&amp; ac-&gt;is_clonebasic(), &quot;Only basic clone is a non escaping clone&quot;);
 284           return ac;
 285         }
 286         mem = in-&gt;in(TypeFunc::Memory);
 287       } else {
 288         assert(false, &quot;unexpected projection&quot;);
 289       }
 290     } else if (mem-&gt;is_Store()) {
 291       const TypePtr* atype = mem-&gt;as_Store()-&gt;adr_type();
 292       int adr_idx = phase-&gt;C-&gt;get_alias_index(atype);
 293       if (adr_idx == alias_idx) {
 294         assert(atype-&gt;isa_oopptr(), &quot;address type must be oopptr&quot;);
 295         int adr_offset = atype-&gt;offset();
 296         uint adr_iid = atype-&gt;is_oopptr()-&gt;instance_id();
 297         // Array elements references have the same alias_idx
 298         // but different offset and different instance_id.
 299         if (adr_offset == offset &amp;&amp; adr_iid == alloc-&gt;_idx)
 300           return mem;
 301       } else {
 302         assert(adr_idx == Compile::AliasIdxRaw, &quot;address must match or be raw&quot;);
 303       }
 304       mem = mem-&gt;in(MemNode::Memory);
 305     } else if (mem-&gt;is_ClearArray()) {
 306       if (!ClearArrayNode::step_through(&amp;mem, alloc-&gt;_idx, phase)) {
 307         // Can not bypass initialization of the instance
 308         // we are looking.
 309         debug_only(intptr_t offset;)
 310         assert(alloc == AllocateNode::Ideal_allocation(mem-&gt;in(3), phase, offset), &quot;sanity&quot;);
 311         InitializeNode* init = alloc-&gt;as_Allocate()-&gt;initialization();
 312         // We are looking for stored value, return Initialize node
 313         // or memory edge from Allocate node.
 314         if (init != NULL)
 315           return init;
 316         else
 317           return alloc-&gt;in(TypeFunc::Memory); // It will produce zero value (see callers).
 318       }
 319       // Otherwise skip it (the call updated &#39;mem&#39; value).
 320     } else if (mem-&gt;Opcode() == Op_SCMemProj) {
 321       mem = mem-&gt;in(0);
 322       Node* adr = NULL;
 323       if (mem-&gt;is_LoadStore()) {
 324         adr = mem-&gt;in(MemNode::Address);
 325       } else {
 326         assert(mem-&gt;Opcode() == Op_EncodeISOArray ||
 327                mem-&gt;Opcode() == Op_StrCompressedCopy, &quot;sanity&quot;);
 328         adr = mem-&gt;in(3); // Destination array
 329       }
 330       const TypePtr* atype = adr-&gt;bottom_type()-&gt;is_ptr();
 331       int adr_idx = phase-&gt;C-&gt;get_alias_index(atype);
 332       if (adr_idx == alias_idx) {
 333         DEBUG_ONLY(mem-&gt;dump();)
 334         assert(false, &quot;Object is not scalar replaceable if a LoadStore node accesses its field&quot;);
 335         return NULL;
 336       }
 337       mem = mem-&gt;in(MemNode::Memory);
 338    } else if (mem-&gt;Opcode() == Op_StrInflatedCopy) {
 339       Node* adr = mem-&gt;in(3); // Destination array
 340       const TypePtr* atype = adr-&gt;bottom_type()-&gt;is_ptr();
 341       int adr_idx = phase-&gt;C-&gt;get_alias_index(atype);
 342       if (adr_idx == alias_idx) {
 343         DEBUG_ONLY(mem-&gt;dump();)
 344         assert(false, &quot;Object is not scalar replaceable if a StrInflatedCopy node accesses its field&quot;);
 345         return NULL;
 346       }
 347       mem = mem-&gt;in(MemNode::Memory);
 348     } else {
 349       return mem;
 350     }
 351     assert(mem != orig_mem, &quot;dead memory loop&quot;);
 352   }
 353 }
 354 
 355 // Generate loads from source of the arraycopy for fields of
 356 // destination needed at a deoptimization point
 357 Node* PhaseMacroExpand::make_arraycopy_load(ArrayCopyNode* ac, intptr_t offset, Node* ctl, Node* mem, BasicType ft, const Type *ftype, AllocateNode *alloc) {
 358   BasicType bt = ft;
 359   const Type *type = ftype;
 360   if (ft == T_NARROWOOP) {
 361     bt = T_OBJECT;
 362     type = ftype-&gt;make_oopptr();
 363   }
 364   Node* res = NULL;
 365   if (ac-&gt;is_clonebasic()) {
<a name="7" id="anc7"></a><span class="line-added"> 366     assert(ac-&gt;in(ArrayCopyNode::Src) != ac-&gt;in(ArrayCopyNode::Dest), &quot;clone source equals destination&quot;);</span>
 367     Node* base = ac-&gt;in(ArrayCopyNode::Src)-&gt;in(AddPNode::Base);
 368     Node* adr = _igvn.transform(new AddPNode(base, base, MakeConX(offset)));
 369     const TypePtr* adr_type = _igvn.type(base)-&gt;is_ptr()-&gt;add_offset(offset);
<a name="8" id="anc8"></a><span class="line-modified"> 370     res = LoadNode::make(_igvn, ctl, mem, adr, adr_type, type, bt, MemNode::unordered, LoadNode::UnknownControl);</span>
 371   } else {
 372     if (ac-&gt;modifies(offset, offset, &amp;_igvn, true)) {
 373       assert(ac-&gt;in(ArrayCopyNode::Dest) == alloc-&gt;result_cast(), &quot;arraycopy destination should be allocation&#39;s result&quot;);
<a name="9" id="anc9"></a><span class="line-modified"> 374       uint shift = exact_log2(type2aelembytes(bt));</span>
<span class="line-modified"> 375       Node* src_pos = ac-&gt;in(ArrayCopyNode::SrcPos);</span>
<span class="line-added"> 376       Node* dest_pos = ac-&gt;in(ArrayCopyNode::DestPos);</span>
<span class="line-added"> 377       const TypeInt* src_pos_t = _igvn.type(src_pos)-&gt;is_int();</span>
<span class="line-added"> 378       const TypeInt* dest_pos_t = _igvn.type(dest_pos)-&gt;is_int();</span>
<span class="line-added"> 379 </span>
<span class="line-added"> 380       Node* adr = NULL;</span>
<span class="line-added"> 381       const TypePtr* adr_type = NULL;</span>
<span class="line-added"> 382       if (src_pos_t-&gt;is_con() &amp;&amp; dest_pos_t-&gt;is_con()) {</span>
<span class="line-added"> 383         intptr_t off = ((src_pos_t-&gt;get_con() - dest_pos_t-&gt;get_con()) &lt;&lt; shift) + offset;</span>
<span class="line-added"> 384         Node* base = ac-&gt;in(ArrayCopyNode::Src);</span>
<span class="line-added"> 385         adr = _igvn.transform(new AddPNode(base, base, MakeConX(off)));</span>
<span class="line-added"> 386         adr_type = _igvn.type(base)-&gt;is_ptr()-&gt;add_offset(off);</span>
<span class="line-added"> 387         if (ac-&gt;in(ArrayCopyNode::Src) == ac-&gt;in(ArrayCopyNode::Dest)) {</span>
<span class="line-added"> 388           // Don&#39;t emit a new load from src if src == dst but try to get the value from memory instead</span>
<span class="line-added"> 389           return value_from_mem(ac-&gt;in(TypeFunc::Memory), ctl, ft, ftype, adr_type-&gt;isa_oopptr(), alloc);</span>
<span class="line-added"> 390         }</span>
<span class="line-added"> 391       } else {</span>
<span class="line-added"> 392         Node* diff = _igvn.transform(new SubINode(ac-&gt;in(ArrayCopyNode::SrcPos), ac-&gt;in(ArrayCopyNode::DestPos)));</span>
 393 #ifdef _LP64
<a name="10" id="anc10"></a><span class="line-modified"> 394         diff = _igvn.transform(new ConvI2LNode(diff));</span>
 395 #endif
<a name="11" id="anc11"></a><span class="line-modified"> 396         diff = _igvn.transform(new LShiftXNode(diff, intcon(shift)));</span>
<span class="line-modified"> 397 </span>
<span class="line-modified"> 398         Node* off = _igvn.transform(new AddXNode(MakeConX(offset), diff));</span>
<span class="line-modified"> 399         Node* base = ac-&gt;in(ArrayCopyNode::Src);</span>
<span class="line-modified"> 400         adr = _igvn.transform(new AddPNode(base, base, off));</span>
<span class="line-modified"> 401         adr_type = _igvn.type(base)-&gt;is_ptr()-&gt;add_offset(Type::OffsetBot);</span>
<span class="line-modified"> 402         if (ac-&gt;in(ArrayCopyNode::Src) == ac-&gt;in(ArrayCopyNode::Dest)) {</span>
<span class="line-added"> 403           // Non constant offset in the array: we can&#39;t statically</span>
<span class="line-added"> 404           // determine the value</span>
<span class="line-added"> 405           return NULL;</span>
<span class="line-added"> 406         }</span>
<span class="line-added"> 407       }</span>
<span class="line-added"> 408       res = LoadNode::make(_igvn, ctl, mem, adr, adr_type, type, bt, MemNode::unordered, LoadNode::UnknownControl);</span>
 409     }
 410   }
 411   if (res != NULL) {
 412     res = _igvn.transform(res);
 413     if (ftype-&gt;isa_narrowoop()) {
 414       // PhaseMacroExpand::scalar_replacement adds DecodeN nodes
 415       res = _igvn.transform(new EncodePNode(res, ftype));
 416     }
 417     return res;
 418   }
 419   return NULL;
 420 }
 421 
 422 //
 423 // Given a Memory Phi, compute a value Phi containing the values from stores
 424 // on the input paths.
 425 // Note: this function is recursive, its depth is limited by the &quot;level&quot; argument
 426 // Returns the computed Phi, or NULL if it cannot compute it.
 427 Node *PhaseMacroExpand::value_from_mem_phi(Node *mem, BasicType ft, const Type *phi_type, const TypeOopPtr *adr_t, AllocateNode *alloc, Node_Stack *value_phis, int level) {
 428   assert(mem-&gt;is_Phi(), &quot;sanity&quot;);
 429   int alias_idx = C-&gt;get_alias_index(adr_t);
 430   int offset = adr_t-&gt;offset();
 431   int instance_id = adr_t-&gt;instance_id();
 432 
 433   // Check if an appropriate value phi already exists.
 434   Node* region = mem-&gt;in(0);
 435   for (DUIterator_Fast kmax, k = region-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 436     Node* phi = region-&gt;fast_out(k);
 437     if (phi-&gt;is_Phi() &amp;&amp; phi != mem &amp;&amp;
 438         phi-&gt;as_Phi()-&gt;is_same_inst_field(phi_type, (int)mem-&gt;_idx, instance_id, alias_idx, offset)) {
 439       return phi;
 440     }
 441   }
 442   // Check if an appropriate new value phi already exists.
 443   Node* new_phi = value_phis-&gt;find(mem-&gt;_idx);
 444   if (new_phi != NULL)
 445     return new_phi;
 446 
 447   if (level &lt;= 0) {
 448     return NULL; // Give up: phi tree too deep
 449   }
 450   Node *start_mem = C-&gt;start()-&gt;proj_out_or_null(TypeFunc::Memory);
 451   Node *alloc_mem = alloc-&gt;in(TypeFunc::Memory);
 452 
 453   uint length = mem-&gt;req();
 454   GrowableArray &lt;Node *&gt; values(length, length, NULL, false);
 455 
 456   // create a new Phi for the value
 457   PhiNode *phi = new PhiNode(mem-&gt;in(0), phi_type, NULL, mem-&gt;_idx, instance_id, alias_idx, offset);
 458   transform_later(phi);
 459   value_phis-&gt;push(phi, mem-&gt;_idx);
 460 
 461   for (uint j = 1; j &lt; length; j++) {
 462     Node *in = mem-&gt;in(j);
 463     if (in == NULL || in-&gt;is_top()) {
 464       values.at_put(j, in);
 465     } else  {
 466       Node *val = scan_mem_chain(in, alias_idx, offset, start_mem, alloc, &amp;_igvn);
 467       if (val == start_mem || val == alloc_mem) {
 468         // hit a sentinel, return appropriate 0 value
 469         values.at_put(j, _igvn.zerocon(ft));
 470         continue;
 471       }
 472       if (val-&gt;is_Initialize()) {
 473         val = val-&gt;as_Initialize()-&gt;find_captured_store(offset, type2aelembytes(ft), &amp;_igvn);
 474       }
 475       if (val == NULL) {
 476         return NULL;  // can&#39;t find a value on this path
 477       }
 478       if (val == mem) {
 479         values.at_put(j, mem);
 480       } else if (val-&gt;is_Store()) {
 481         Node* n = val-&gt;in(MemNode::ValueIn);
 482         BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 483         n = bs-&gt;step_over_gc_barrier(n);
 484         values.at_put(j, n);
 485       } else if(val-&gt;is_Proj() &amp;&amp; val-&gt;in(0) == alloc) {
 486         values.at_put(j, _igvn.zerocon(ft));
 487       } else if (val-&gt;is_Phi()) {
 488         val = value_from_mem_phi(val, ft, phi_type, adr_t, alloc, value_phis, level-1);
 489         if (val == NULL) {
 490           return NULL;
 491         }
 492         values.at_put(j, val);
 493       } else if (val-&gt;Opcode() == Op_SCMemProj) {
 494         assert(val-&gt;in(0)-&gt;is_LoadStore() ||
 495                val-&gt;in(0)-&gt;Opcode() == Op_EncodeISOArray ||
 496                val-&gt;in(0)-&gt;Opcode() == Op_StrCompressedCopy, &quot;sanity&quot;);
 497         assert(false, &quot;Object is not scalar replaceable if a LoadStore node accesses its field&quot;);
 498         return NULL;
 499       } else if (val-&gt;is_ArrayCopy()) {
 500         Node* res = make_arraycopy_load(val-&gt;as_ArrayCopy(), offset, val-&gt;in(0), val-&gt;in(TypeFunc::Memory), ft, phi_type, alloc);
 501         if (res == NULL) {
 502           return NULL;
 503         }
 504         values.at_put(j, res);
 505       } else {
 506 #ifdef ASSERT
 507         val-&gt;dump();
 508         assert(false, &quot;unknown node on this path&quot;);
 509 #endif
 510         return NULL;  // unknown node on this path
 511       }
 512     }
 513   }
 514   // Set Phi&#39;s inputs
 515   for (uint j = 1; j &lt; length; j++) {
 516     if (values.at(j) == mem) {
 517       phi-&gt;init_req(j, phi);
 518     } else {
 519       phi-&gt;init_req(j, values.at(j));
 520     }
 521   }
 522   return phi;
 523 }
 524 
 525 // Search the last value stored into the object&#39;s field.
 526 Node *PhaseMacroExpand::value_from_mem(Node *sfpt_mem, Node *sfpt_ctl, BasicType ft, const Type *ftype, const TypeOopPtr *adr_t, AllocateNode *alloc) {
 527   assert(adr_t-&gt;is_known_instance_field(), &quot;instance required&quot;);
 528   int instance_id = adr_t-&gt;instance_id();
 529   assert((uint)instance_id == alloc-&gt;_idx, &quot;wrong allocation&quot;);
 530 
 531   int alias_idx = C-&gt;get_alias_index(adr_t);
 532   int offset = adr_t-&gt;offset();
 533   Node *start_mem = C-&gt;start()-&gt;proj_out_or_null(TypeFunc::Memory);
 534   Node *alloc_ctrl = alloc-&gt;in(TypeFunc::Control);
 535   Node *alloc_mem = alloc-&gt;in(TypeFunc::Memory);
 536   Arena *a = Thread::current()-&gt;resource_area();
 537   VectorSet visited(a);
 538 
<a name="12" id="anc12"></a>
 539   bool done = sfpt_mem == alloc_mem;
 540   Node *mem = sfpt_mem;
 541   while (!done) {
 542     if (visited.test_set(mem-&gt;_idx)) {
 543       return NULL;  // found a loop, give up
 544     }
 545     mem = scan_mem_chain(mem, alias_idx, offset, start_mem, alloc, &amp;_igvn);
 546     if (mem == start_mem || mem == alloc_mem) {
 547       done = true;  // hit a sentinel, return appropriate 0 value
 548     } else if (mem-&gt;is_Initialize()) {
 549       mem = mem-&gt;as_Initialize()-&gt;find_captured_store(offset, type2aelembytes(ft), &amp;_igvn);
 550       if (mem == NULL) {
 551         done = true; // Something go wrong.
 552       } else if (mem-&gt;is_Store()) {
 553         const TypePtr* atype = mem-&gt;as_Store()-&gt;adr_type();
 554         assert(C-&gt;get_alias_index(atype) == Compile::AliasIdxRaw, &quot;store is correct memory slice&quot;);
 555         done = true;
 556       }
 557     } else if (mem-&gt;is_Store()) {
 558       const TypeOopPtr* atype = mem-&gt;as_Store()-&gt;adr_type()-&gt;isa_oopptr();
 559       assert(atype != NULL, &quot;address type must be oopptr&quot;);
 560       assert(C-&gt;get_alias_index(atype) == alias_idx &amp;&amp;
 561              atype-&gt;is_known_instance_field() &amp;&amp; atype-&gt;offset() == offset &amp;&amp;
 562              atype-&gt;instance_id() == instance_id, &quot;store is correct memory slice&quot;);
 563       done = true;
 564     } else if (mem-&gt;is_Phi()) {
 565       // try to find a phi&#39;s unique input
 566       Node *unique_input = NULL;
 567       Node *top = C-&gt;top();
 568       for (uint i = 1; i &lt; mem-&gt;req(); i++) {
 569         Node *n = scan_mem_chain(mem-&gt;in(i), alias_idx, offset, start_mem, alloc, &amp;_igvn);
 570         if (n == NULL || n == top || n == mem) {
 571           continue;
 572         } else if (unique_input == NULL) {
 573           unique_input = n;
 574         } else if (unique_input != n) {
 575           unique_input = top;
 576           break;
 577         }
 578       }
 579       if (unique_input != NULL &amp;&amp; unique_input != top) {
 580         mem = unique_input;
 581       } else {
 582         done = true;
 583       }
 584     } else if (mem-&gt;is_ArrayCopy()) {
 585       done = true;
 586     } else {
 587       assert(false, &quot;unexpected node&quot;);
 588     }
 589   }
 590   if (mem != NULL) {
 591     if (mem == start_mem || mem == alloc_mem) {
 592       // hit a sentinel, return appropriate 0 value
 593       return _igvn.zerocon(ft);
 594     } else if (mem-&gt;is_Store()) {
 595       Node* n = mem-&gt;in(MemNode::ValueIn);
 596       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 597       n = bs-&gt;step_over_gc_barrier(n);
 598       return n;
 599     } else if (mem-&gt;is_Phi()) {
 600       // attempt to produce a Phi reflecting the values on the input paths of the Phi
 601       Node_Stack value_phis(a, 8);
 602       Node * phi = value_from_mem_phi(mem, ft, ftype, adr_t, alloc, &amp;value_phis, ValueSearchLimit);
 603       if (phi != NULL) {
 604         return phi;
 605       } else {
 606         // Kill all new Phis
 607         while(value_phis.is_nonempty()) {
 608           Node* n = value_phis.node();
 609           _igvn.replace_node(n, C-&gt;top());
 610           value_phis.pop();
 611         }
 612       }
 613     } else if (mem-&gt;is_ArrayCopy()) {
 614       Node* ctl = mem-&gt;in(0);
 615       Node* m = mem-&gt;in(TypeFunc::Memory);
 616       if (sfpt_ctl-&gt;is_Proj() &amp;&amp; sfpt_ctl-&gt;as_Proj()-&gt;is_uncommon_trap_proj(Deoptimization::Reason_none)) {
 617         // pin the loads in the uncommon trap path
 618         ctl = sfpt_ctl;
 619         m = sfpt_mem;
 620       }
 621       return make_arraycopy_load(mem-&gt;as_ArrayCopy(), offset, ctl, m, ft, ftype, alloc);
 622     }
 623   }
 624   // Something go wrong.
 625   return NULL;
 626 }
 627 
 628 // Check the possibility of scalar replacement.
 629 bool PhaseMacroExpand::can_eliminate_allocation(AllocateNode *alloc, GrowableArray &lt;SafePointNode *&gt;&amp; safepoints) {
 630   //  Scan the uses of the allocation to check for anything that would
 631   //  prevent us from eliminating it.
 632   NOT_PRODUCT( const char* fail_eliminate = NULL; )
 633   DEBUG_ONLY( Node* disq_node = NULL; )
 634   bool  can_eliminate = true;
 635 
 636   Node* res = alloc-&gt;result_cast();
 637   const TypeOopPtr* res_type = NULL;
 638   if (res == NULL) {
 639     // All users were eliminated.
 640   } else if (!res-&gt;is_CheckCastPP()) {
 641     NOT_PRODUCT(fail_eliminate = &quot;Allocation does not have unique CheckCastPP&quot;;)
 642     can_eliminate = false;
 643   } else {
 644     res_type = _igvn.type(res)-&gt;isa_oopptr();
 645     if (res_type == NULL) {
 646       NOT_PRODUCT(fail_eliminate = &quot;Neither instance or array allocation&quot;;)
 647       can_eliminate = false;
 648     } else if (res_type-&gt;isa_aryptr()) {
 649       int length = alloc-&gt;in(AllocateNode::ALength)-&gt;find_int_con(-1);
 650       if (length &lt; 0) {
 651         NOT_PRODUCT(fail_eliminate = &quot;Array&#39;s size is not constant&quot;;)
 652         can_eliminate = false;
 653       }
 654     }
 655   }
 656 
 657   if (can_eliminate &amp;&amp; res != NULL) {
 658     for (DUIterator_Fast jmax, j = res-&gt;fast_outs(jmax);
 659                                j &lt; jmax &amp;&amp; can_eliminate; j++) {
 660       Node* use = res-&gt;fast_out(j);
 661 
 662       if (use-&gt;is_AddP()) {
 663         const TypePtr* addp_type = _igvn.type(use)-&gt;is_ptr();
 664         int offset = addp_type-&gt;offset();
 665 
 666         if (offset == Type::OffsetTop || offset == Type::OffsetBot) {
 667           NOT_PRODUCT(fail_eliminate = &quot;Undefined field referrence&quot;;)
 668           can_eliminate = false;
 669           break;
 670         }
 671         for (DUIterator_Fast kmax, k = use-&gt;fast_outs(kmax);
 672                                    k &lt; kmax &amp;&amp; can_eliminate; k++) {
 673           Node* n = use-&gt;fast_out(k);
 674           if (!n-&gt;is_Store() &amp;&amp; n-&gt;Opcode() != Op_CastP2X &amp;&amp;
 675               SHENANDOAHGC_ONLY((!UseShenandoahGC || !ShenandoahBarrierSetC2::is_shenandoah_wb_pre_call(n)) &amp;&amp;)
 676               !(n-&gt;is_ArrayCopy() &amp;&amp;
 677                 n-&gt;as_ArrayCopy()-&gt;is_clonebasic() &amp;&amp;
 678                 n-&gt;in(ArrayCopyNode::Dest) == use)) {
 679             DEBUG_ONLY(disq_node = n;)
 680             if (n-&gt;is_Load() || n-&gt;is_LoadStore()) {
 681               NOT_PRODUCT(fail_eliminate = &quot;Field load&quot;;)
 682             } else {
 683               NOT_PRODUCT(fail_eliminate = &quot;Not store field referrence&quot;;)
 684             }
 685             can_eliminate = false;
 686           }
 687         }
 688       } else if (use-&gt;is_ArrayCopy() &amp;&amp;
 689                  (use-&gt;as_ArrayCopy()-&gt;is_arraycopy_validated() ||
 690                   use-&gt;as_ArrayCopy()-&gt;is_copyof_validated() ||
 691                   use-&gt;as_ArrayCopy()-&gt;is_copyofrange_validated()) &amp;&amp;
 692                  use-&gt;in(ArrayCopyNode::Dest) == res) {
 693         // ok to eliminate
 694       } else if (use-&gt;is_SafePoint()) {
 695         SafePointNode* sfpt = use-&gt;as_SafePoint();
 696         if (sfpt-&gt;is_Call() &amp;&amp; sfpt-&gt;as_Call()-&gt;has_non_debug_use(res)) {
 697           // Object is passed as argument.
 698           DEBUG_ONLY(disq_node = use;)
 699           NOT_PRODUCT(fail_eliminate = &quot;Object is passed as argument&quot;;)
 700           can_eliminate = false;
 701         }
 702         Node* sfptMem = sfpt-&gt;memory();
 703         if (sfptMem == NULL || sfptMem-&gt;is_top()) {
 704           DEBUG_ONLY(disq_node = use;)
 705           NOT_PRODUCT(fail_eliminate = &quot;NULL or TOP memory&quot;;)
 706           can_eliminate = false;
 707         } else {
 708           safepoints.append_if_missing(sfpt);
 709         }
 710       } else if (use-&gt;Opcode() != Op_CastP2X) { // CastP2X is used by card mark
 711         if (use-&gt;is_Phi()) {
 712           if (use-&gt;outcnt() == 1 &amp;&amp; use-&gt;unique_out()-&gt;Opcode() == Op_Return) {
 713             NOT_PRODUCT(fail_eliminate = &quot;Object is return value&quot;;)
 714           } else {
 715             NOT_PRODUCT(fail_eliminate = &quot;Object is referenced by Phi&quot;;)
 716           }
 717           DEBUG_ONLY(disq_node = use;)
 718         } else {
 719           if (use-&gt;Opcode() == Op_Return) {
 720             NOT_PRODUCT(fail_eliminate = &quot;Object is return value&quot;;)
 721           }else {
 722             NOT_PRODUCT(fail_eliminate = &quot;Object is referenced by node&quot;;)
 723           }
 724           DEBUG_ONLY(disq_node = use;)
 725         }
 726         can_eliminate = false;
 727       }
 728     }
 729   }
 730 
 731 #ifndef PRODUCT
 732   if (PrintEliminateAllocations) {
 733     if (can_eliminate) {
 734       tty-&gt;print(&quot;Scalar &quot;);
 735       if (res == NULL)
 736         alloc-&gt;dump();
 737       else
 738         res-&gt;dump();
 739     } else if (alloc-&gt;_is_scalar_replaceable) {
 740       tty-&gt;print(&quot;NotScalar (%s)&quot;, fail_eliminate);
 741       if (res == NULL)
 742         alloc-&gt;dump();
 743       else
 744         res-&gt;dump();
 745 #ifdef ASSERT
 746       if (disq_node != NULL) {
 747           tty-&gt;print(&quot;  &gt;&gt;&gt;&gt; &quot;);
 748           disq_node-&gt;dump();
 749       }
 750 #endif /*ASSERT*/
 751     }
 752   }
 753 #endif
 754   return can_eliminate;
 755 }
 756 
 757 // Do scalar replacement.
 758 bool PhaseMacroExpand::scalar_replacement(AllocateNode *alloc, GrowableArray &lt;SafePointNode *&gt;&amp; safepoints) {
 759   GrowableArray &lt;SafePointNode *&gt; safepoints_done;
 760 
 761   ciKlass* klass = NULL;
 762   ciInstanceKlass* iklass = NULL;
 763   int nfields = 0;
 764   int array_base = 0;
 765   int element_size = 0;
 766   BasicType basic_elem_type = T_ILLEGAL;
 767   ciType* elem_type = NULL;
 768 
 769   Node* res = alloc-&gt;result_cast();
 770   assert(res == NULL || res-&gt;is_CheckCastPP(), &quot;unexpected AllocateNode result&quot;);
 771   const TypeOopPtr* res_type = NULL;
 772   if (res != NULL) { // Could be NULL when there are no users
 773     res_type = _igvn.type(res)-&gt;isa_oopptr();
 774   }
 775 
 776   if (res != NULL) {
 777     klass = res_type-&gt;klass();
 778     if (res_type-&gt;isa_instptr()) {
 779       // find the fields of the class which will be needed for safepoint debug information
 780       assert(klass-&gt;is_instance_klass(), &quot;must be an instance klass.&quot;);
 781       iklass = klass-&gt;as_instance_klass();
 782       nfields = iklass-&gt;nof_nonstatic_fields();
 783     } else {
 784       // find the array&#39;s elements which will be needed for safepoint debug information
 785       nfields = alloc-&gt;in(AllocateNode::ALength)-&gt;find_int_con(-1);
 786       assert(klass-&gt;is_array_klass() &amp;&amp; nfields &gt;= 0, &quot;must be an array klass.&quot;);
 787       elem_type = klass-&gt;as_array_klass()-&gt;element_type();
 788       basic_elem_type = elem_type-&gt;basic_type();
 789       array_base = arrayOopDesc::base_offset_in_bytes(basic_elem_type);
 790       element_size = type2aelembytes(basic_elem_type);
 791     }
 792   }
 793   //
 794   // Process the safepoint uses
 795   //
 796   while (safepoints.length() &gt; 0) {
 797     SafePointNode* sfpt = safepoints.pop();
 798     Node* mem = sfpt-&gt;memory();
 799     Node* ctl = sfpt-&gt;control();
 800     assert(sfpt-&gt;jvms() != NULL, &quot;missed JVMS&quot;);
 801     // Fields of scalar objs are referenced only at the end
 802     // of regular debuginfo at the last (youngest) JVMS.
 803     // Record relative start index.
 804     uint first_ind = (sfpt-&gt;req() - sfpt-&gt;jvms()-&gt;scloff());
 805     SafePointScalarObjectNode* sobj = new SafePointScalarObjectNode(res_type,
 806 #ifdef ASSERT
 807                                                  alloc,
 808 #endif
 809                                                  first_ind, nfields);
 810     sobj-&gt;init_req(0, C-&gt;root());
 811     transform_later(sobj);
 812 
 813     // Scan object&#39;s fields adding an input to the safepoint for each field.
 814     for (int j = 0; j &lt; nfields; j++) {
 815       intptr_t offset;
 816       ciField* field = NULL;
 817       if (iklass != NULL) {
 818         field = iklass-&gt;nonstatic_field_at(j);
 819         offset = field-&gt;offset();
 820         elem_type = field-&gt;type();
 821         basic_elem_type = field-&gt;layout_type();
 822       } else {
 823         offset = array_base + j * (intptr_t)element_size;
 824       }
 825 
 826       const Type *field_type;
 827       // The next code is taken from Parse::do_get_xxx().
<a name="13" id="anc13"></a><span class="line-modified"> 828       if (is_reference_type(basic_elem_type)) {</span>
 829         if (!elem_type-&gt;is_loaded()) {
 830           field_type = TypeInstPtr::BOTTOM;
 831         } else if (field != NULL &amp;&amp; field-&gt;is_static_constant()) {
 832           // This can happen if the constant oop is non-perm.
 833           ciObject* con = field-&gt;constant_value().as_object();
 834           // Do not &quot;join&quot; in the previous type; it doesn&#39;t add value,
 835           // and may yield a vacuous result if the field is of interface type.
 836           field_type = TypeOopPtr::make_from_constant(con)-&gt;isa_oopptr();
 837           assert(field_type != NULL, &quot;field singleton type must be consistent&quot;);
 838         } else {
 839           field_type = TypeOopPtr::make_from_klass(elem_type-&gt;as_klass());
 840         }
 841         if (UseCompressedOops) {
 842           field_type = field_type-&gt;make_narrowoop();
 843           basic_elem_type = T_NARROWOOP;
 844         }
 845       } else {
 846         field_type = Type::get_const_basic_type(basic_elem_type);
 847       }
 848 
 849       const TypeOopPtr *field_addr_type = res_type-&gt;add_offset(offset)-&gt;isa_oopptr();
 850 
 851       Node *field_val = value_from_mem(mem, ctl, basic_elem_type, field_type, field_addr_type, alloc);
 852       if (field_val == NULL) {
 853         // We weren&#39;t able to find a value for this field,
 854         // give up on eliminating this allocation.
 855 
 856         // Remove any extra entries we added to the safepoint.
 857         uint last = sfpt-&gt;req() - 1;
 858         for (int k = 0;  k &lt; j; k++) {
 859           sfpt-&gt;del_req(last--);
 860         }
 861         _igvn._worklist.push(sfpt);
 862         // rollback processed safepoints
 863         while (safepoints_done.length() &gt; 0) {
 864           SafePointNode* sfpt_done = safepoints_done.pop();
 865           // remove any extra entries we added to the safepoint
 866           last = sfpt_done-&gt;req() - 1;
 867           for (int k = 0;  k &lt; nfields; k++) {
 868             sfpt_done-&gt;del_req(last--);
 869           }
 870           JVMState *jvms = sfpt_done-&gt;jvms();
 871           jvms-&gt;set_endoff(sfpt_done-&gt;req());
 872           // Now make a pass over the debug information replacing any references
 873           // to SafePointScalarObjectNode with the allocated object.
 874           int start = jvms-&gt;debug_start();
 875           int end   = jvms-&gt;debug_end();
 876           for (int i = start; i &lt; end; i++) {
 877             if (sfpt_done-&gt;in(i)-&gt;is_SafePointScalarObject()) {
 878               SafePointScalarObjectNode* scobj = sfpt_done-&gt;in(i)-&gt;as_SafePointScalarObject();
 879               if (scobj-&gt;first_index(jvms) == sfpt_done-&gt;req() &amp;&amp;
 880                   scobj-&gt;n_fields() == (uint)nfields) {
 881                 assert(scobj-&gt;alloc() == alloc, &quot;sanity&quot;);
 882                 sfpt_done-&gt;set_req(i, res);
 883               }
 884             }
 885           }
 886           _igvn._worklist.push(sfpt_done);
 887         }
 888 #ifndef PRODUCT
 889         if (PrintEliminateAllocations) {
 890           if (field != NULL) {
 891             tty-&gt;print(&quot;=== At SafePoint node %d can&#39;t find value of Field: &quot;,
 892                        sfpt-&gt;_idx);
 893             field-&gt;print();
 894             int field_idx = C-&gt;get_alias_index(field_addr_type);
 895             tty-&gt;print(&quot; (alias_idx=%d)&quot;, field_idx);
 896           } else { // Array&#39;s element
 897             tty-&gt;print(&quot;=== At SafePoint node %d can&#39;t find value of array element [%d]&quot;,
 898                        sfpt-&gt;_idx, j);
 899           }
 900           tty-&gt;print(&quot;, which prevents elimination of: &quot;);
 901           if (res == NULL)
 902             alloc-&gt;dump();
 903           else
 904             res-&gt;dump();
 905         }
 906 #endif
 907         return false;
 908       }
 909       if (UseCompressedOops &amp;&amp; field_type-&gt;isa_narrowoop()) {
 910         // Enable &quot;DecodeN(EncodeP(Allocate)) --&gt; Allocate&quot; transformation
 911         // to be able scalar replace the allocation.
 912         if (field_val-&gt;is_EncodeP()) {
 913           field_val = field_val-&gt;in(1);
 914         } else {
 915           field_val = transform_later(new DecodeNNode(field_val, field_val-&gt;get_ptr_type()));
 916         }
 917       }
 918       sfpt-&gt;add_req(field_val);
 919     }
 920     JVMState *jvms = sfpt-&gt;jvms();
 921     jvms-&gt;set_endoff(sfpt-&gt;req());
 922     // Now make a pass over the debug information replacing any references
 923     // to the allocated object with &quot;sobj&quot;
 924     int start = jvms-&gt;debug_start();
 925     int end   = jvms-&gt;debug_end();
 926     sfpt-&gt;replace_edges_in_range(res, sobj, start, end);
 927     _igvn._worklist.push(sfpt);
 928     safepoints_done.append_if_missing(sfpt); // keep it for rollback
 929   }
 930   return true;
 931 }
 932 
 933 static void disconnect_projections(MultiNode* n, PhaseIterGVN&amp; igvn) {
 934   Node* ctl_proj = n-&gt;proj_out_or_null(TypeFunc::Control);
 935   Node* mem_proj = n-&gt;proj_out_or_null(TypeFunc::Memory);
 936   if (ctl_proj != NULL) {
 937     igvn.replace_node(ctl_proj, n-&gt;in(0));
 938   }
 939   if (mem_proj != NULL) {
 940     igvn.replace_node(mem_proj, n-&gt;in(TypeFunc::Memory));
 941   }
 942 }
 943 
 944 // Process users of eliminated allocation.
 945 void PhaseMacroExpand::process_users_of_allocation(CallNode *alloc) {
 946   Node* res = alloc-&gt;result_cast();
 947   if (res != NULL) {
 948     for (DUIterator_Last jmin, j = res-&gt;last_outs(jmin); j &gt;= jmin; ) {
 949       Node *use = res-&gt;last_out(j);
 950       uint oc1 = res-&gt;outcnt();
 951 
 952       if (use-&gt;is_AddP()) {
 953         for (DUIterator_Last kmin, k = use-&gt;last_outs(kmin); k &gt;= kmin; ) {
 954           Node *n = use-&gt;last_out(k);
 955           uint oc2 = use-&gt;outcnt();
 956           if (n-&gt;is_Store()) {
 957 #ifdef ASSERT
 958             // Verify that there is no dependent MemBarVolatile nodes,
 959             // they should be removed during IGVN, see MemBarNode::Ideal().
 960             for (DUIterator_Fast pmax, p = n-&gt;fast_outs(pmax);
 961                                        p &lt; pmax; p++) {
 962               Node* mb = n-&gt;fast_out(p);
 963               assert(mb-&gt;is_Initialize() || !mb-&gt;is_MemBar() ||
 964                      mb-&gt;req() &lt;= MemBarNode::Precedent ||
 965                      mb-&gt;in(MemBarNode::Precedent) != n,
 966                      &quot;MemBarVolatile should be eliminated for non-escaping object&quot;);
 967             }
 968 #endif
 969             _igvn.replace_node(n, n-&gt;in(MemNode::Memory));
 970           } else if (n-&gt;is_ArrayCopy()) {
 971             // Disconnect ArrayCopy node
 972             ArrayCopyNode* ac = n-&gt;as_ArrayCopy();
 973             assert(ac-&gt;is_clonebasic(), &quot;unexpected array copy kind&quot;);
 974             Node* membar_after = ac-&gt;proj_out(TypeFunc::Control)-&gt;unique_ctrl_out();
 975             disconnect_projections(ac, _igvn);
 976             assert(alloc-&gt;in(0)-&gt;is_Proj() &amp;&amp; alloc-&gt;in(0)-&gt;in(0)-&gt;Opcode() == Op_MemBarCPUOrder, &quot;mem barrier expected before allocation&quot;);
 977             Node* membar_before = alloc-&gt;in(0)-&gt;in(0);
 978             disconnect_projections(membar_before-&gt;as_MemBar(), _igvn);
 979             if (membar_after-&gt;is_MemBar()) {
 980               disconnect_projections(membar_after-&gt;as_MemBar(), _igvn);
 981             }
 982           } else {
 983             eliminate_gc_barrier(n);
 984           }
 985           k -= (oc2 - use-&gt;outcnt());
 986         }
 987         _igvn.remove_dead_node(use);
 988       } else if (use-&gt;is_ArrayCopy()) {
 989         // Disconnect ArrayCopy node
 990         ArrayCopyNode* ac = use-&gt;as_ArrayCopy();
 991         assert(ac-&gt;is_arraycopy_validated() ||
 992                ac-&gt;is_copyof_validated() ||
 993                ac-&gt;is_copyofrange_validated(), &quot;unsupported&quot;);
 994         CallProjections callprojs;
 995         ac-&gt;extract_projections(&amp;callprojs, true);
 996 
 997         _igvn.replace_node(callprojs.fallthrough_ioproj, ac-&gt;in(TypeFunc::I_O));
 998         _igvn.replace_node(callprojs.fallthrough_memproj, ac-&gt;in(TypeFunc::Memory));
 999         _igvn.replace_node(callprojs.fallthrough_catchproj, ac-&gt;in(TypeFunc::Control));
1000 
1001         // Set control to top. IGVN will remove the remaining projections
1002         ac-&gt;set_req(0, top());
1003         ac-&gt;replace_edge(res, top());
1004 
1005         // Disconnect src right away: it can help find new
1006         // opportunities for allocation elimination
1007         Node* src = ac-&gt;in(ArrayCopyNode::Src);
1008         ac-&gt;replace_edge(src, top());
1009         // src can be top at this point if src and dest of the
1010         // arraycopy were the same
1011         if (src-&gt;outcnt() == 0 &amp;&amp; !src-&gt;is_top()) {
1012           _igvn.remove_dead_node(src);
1013         }
1014 
1015         _igvn._worklist.push(ac);
1016       } else {
1017         eliminate_gc_barrier(use);
1018       }
1019       j -= (oc1 - res-&gt;outcnt());
1020     }
1021     assert(res-&gt;outcnt() == 0, &quot;all uses of allocated objects must be deleted&quot;);
1022     _igvn.remove_dead_node(res);
1023   }
1024 
1025   //
1026   // Process other users of allocation&#39;s projections
1027   //
1028   if (_resproj != NULL &amp;&amp; _resproj-&gt;outcnt() != 0) {
1029     // First disconnect stores captured by Initialize node.
1030     // If Initialize node is eliminated first in the following code,
1031     // it will kill such stores and DUIterator_Last will assert.
1032     for (DUIterator_Fast jmax, j = _resproj-&gt;fast_outs(jmax);  j &lt; jmax; j++) {
1033       Node *use = _resproj-&gt;fast_out(j);
1034       if (use-&gt;is_AddP()) {
1035         // raw memory addresses used only by the initialization
1036         _igvn.replace_node(use, C-&gt;top());
1037         --j; --jmax;
1038       }
1039     }
1040     for (DUIterator_Last jmin, j = _resproj-&gt;last_outs(jmin); j &gt;= jmin; ) {
1041       Node *use = _resproj-&gt;last_out(j);
1042       uint oc1 = _resproj-&gt;outcnt();
1043       if (use-&gt;is_Initialize()) {
1044         // Eliminate Initialize node.
1045         InitializeNode *init = use-&gt;as_Initialize();
1046         assert(init-&gt;outcnt() &lt;= 2, &quot;only a control and memory projection expected&quot;);
1047         Node *ctrl_proj = init-&gt;proj_out_or_null(TypeFunc::Control);
1048         if (ctrl_proj != NULL) {
<a name="14" id="anc14"></a><span class="line-modified">1049           _igvn.replace_node(ctrl_proj, init-&gt;in(TypeFunc::Control));</span>
<span class="line-modified">1050 #ifdef ASSERT</span>
<span class="line-added">1051           Node* tmp = init-&gt;in(TypeFunc::Control);</span>
<span class="line-added">1052           assert(tmp == _fallthroughcatchproj, &quot;allocation control projection&quot;);</span>
<span class="line-added">1053 #endif</span>
1054         }
1055         Node *mem_proj = init-&gt;proj_out_or_null(TypeFunc::Memory);
1056         if (mem_proj != NULL) {
1057           Node *mem = init-&gt;in(TypeFunc::Memory);
1058 #ifdef ASSERT
1059           if (mem-&gt;is_MergeMem()) {
1060             assert(mem-&gt;in(TypeFunc::Memory) == _memproj_fallthrough, &quot;allocation memory projection&quot;);
1061           } else {
1062             assert(mem == _memproj_fallthrough, &quot;allocation memory projection&quot;);
1063           }
1064 #endif
1065           _igvn.replace_node(mem_proj, mem);
1066         }
1067       } else  {
1068         assert(false, &quot;only Initialize or AddP expected&quot;);
1069       }
1070       j -= (oc1 - _resproj-&gt;outcnt());
1071     }
1072   }
1073   if (_fallthroughcatchproj != NULL) {
1074     _igvn.replace_node(_fallthroughcatchproj, alloc-&gt;in(TypeFunc::Control));
1075   }
1076   if (_memproj_fallthrough != NULL) {
1077     _igvn.replace_node(_memproj_fallthrough, alloc-&gt;in(TypeFunc::Memory));
1078   }
1079   if (_memproj_catchall != NULL) {
1080     _igvn.replace_node(_memproj_catchall, C-&gt;top());
1081   }
1082   if (_ioproj_fallthrough != NULL) {
1083     _igvn.replace_node(_ioproj_fallthrough, alloc-&gt;in(TypeFunc::I_O));
1084   }
1085   if (_ioproj_catchall != NULL) {
1086     _igvn.replace_node(_ioproj_catchall, C-&gt;top());
1087   }
1088   if (_catchallcatchproj != NULL) {
1089     _igvn.replace_node(_catchallcatchproj, C-&gt;top());
1090   }
1091 }
1092 
1093 bool PhaseMacroExpand::eliminate_allocate_node(AllocateNode *alloc) {
1094   // Don&#39;t do scalar replacement if the frame can be popped by JVMTI:
1095   // if reallocation fails during deoptimization we&#39;ll pop all
1096   // interpreter frames for this compiled frame and that won&#39;t play
1097   // nice with JVMTI popframe.
1098   if (!EliminateAllocations || JvmtiExport::can_pop_frame() || !alloc-&gt;_is_non_escaping) {
1099     return false;
1100   }
1101   Node* klass = alloc-&gt;in(AllocateNode::KlassNode);
1102   const TypeKlassPtr* tklass = _igvn.type(klass)-&gt;is_klassptr();
1103   Node* res = alloc-&gt;result_cast();
1104   // Eliminate boxing allocations which are not used
1105   // regardless scalar replacable status.
1106   bool boxing_alloc = C-&gt;eliminate_boxing() &amp;&amp;
1107                       tklass-&gt;klass()-&gt;is_instance_klass()  &amp;&amp;
1108                       tklass-&gt;klass()-&gt;as_instance_klass()-&gt;is_box_klass();
1109   if (!alloc-&gt;_is_scalar_replaceable &amp;&amp; (!boxing_alloc || (res != NULL))) {
1110     return false;
1111   }
1112 
1113   extract_call_projections(alloc);
1114 
1115   GrowableArray &lt;SafePointNode *&gt; safepoints;
1116   if (!can_eliminate_allocation(alloc, safepoints)) {
1117     return false;
1118   }
1119 
1120   if (!alloc-&gt;_is_scalar_replaceable) {
1121     assert(res == NULL, &quot;sanity&quot;);
1122     // We can only eliminate allocation if all debug info references
1123     // are already replaced with SafePointScalarObject because
1124     // we can&#39;t search for a fields value without instance_id.
1125     if (safepoints.length() &gt; 0) {
1126       return false;
1127     }
1128   }
1129 
1130   if (!scalar_replacement(alloc, safepoints)) {
1131     return false;
1132   }
1133 
1134   CompileLog* log = C-&gt;log();
1135   if (log != NULL) {
1136     log-&gt;head(&quot;eliminate_allocation type=&#39;%d&#39;&quot;,
1137               log-&gt;identify(tklass-&gt;klass()));
1138     JVMState* p = alloc-&gt;jvms();
1139     while (p != NULL) {
1140       log-&gt;elem(&quot;jvms bci=&#39;%d&#39; method=&#39;%d&#39;&quot;, p-&gt;bci(), log-&gt;identify(p-&gt;method()));
1141       p = p-&gt;caller();
1142     }
1143     log-&gt;tail(&quot;eliminate_allocation&quot;);
1144   }
1145 
1146   process_users_of_allocation(alloc);
1147 
1148 #ifndef PRODUCT
1149   if (PrintEliminateAllocations) {
1150     if (alloc-&gt;is_AllocateArray())
1151       tty-&gt;print_cr(&quot;++++ Eliminated: %d AllocateArray&quot;, alloc-&gt;_idx);
1152     else
1153       tty-&gt;print_cr(&quot;++++ Eliminated: %d Allocate&quot;, alloc-&gt;_idx);
1154   }
1155 #endif
1156 
1157   return true;
1158 }
1159 
1160 bool PhaseMacroExpand::eliminate_boxing_node(CallStaticJavaNode *boxing) {
1161   // EA should remove all uses of non-escaping boxing node.
1162   if (!C-&gt;eliminate_boxing() || boxing-&gt;proj_out_or_null(TypeFunc::Parms) != NULL) {
1163     return false;
1164   }
1165 
1166   assert(boxing-&gt;result_cast() == NULL, &quot;unexpected boxing node result&quot;);
1167 
1168   extract_call_projections(boxing);
1169 
1170   const TypeTuple* r = boxing-&gt;tf()-&gt;range();
1171   assert(r-&gt;cnt() &gt; TypeFunc::Parms, &quot;sanity&quot;);
1172   const TypeInstPtr* t = r-&gt;field_at(TypeFunc::Parms)-&gt;isa_instptr();
1173   assert(t != NULL, &quot;sanity&quot;);
1174 
1175   CompileLog* log = C-&gt;log();
1176   if (log != NULL) {
1177     log-&gt;head(&quot;eliminate_boxing type=&#39;%d&#39;&quot;,
1178               log-&gt;identify(t-&gt;klass()));
1179     JVMState* p = boxing-&gt;jvms();
1180     while (p != NULL) {
1181       log-&gt;elem(&quot;jvms bci=&#39;%d&#39; method=&#39;%d&#39;&quot;, p-&gt;bci(), log-&gt;identify(p-&gt;method()));
1182       p = p-&gt;caller();
1183     }
1184     log-&gt;tail(&quot;eliminate_boxing&quot;);
1185   }
1186 
1187   process_users_of_allocation(boxing);
1188 
1189 #ifndef PRODUCT
1190   if (PrintEliminateAllocations) {
1191     tty-&gt;print(&quot;++++ Eliminated: %d &quot;, boxing-&gt;_idx);
1192     boxing-&gt;method()-&gt;print_short_name(tty);
1193     tty-&gt;cr();
1194   }
1195 #endif
1196 
1197   return true;
1198 }
1199 
1200 //---------------------------set_eden_pointers-------------------------
1201 void PhaseMacroExpand::set_eden_pointers(Node* &amp;eden_top_adr, Node* &amp;eden_end_adr) {
1202   if (UseTLAB) {                // Private allocation: load from TLS
1203     Node* thread = transform_later(new ThreadLocalNode());
1204     int tlab_top_offset = in_bytes(JavaThread::tlab_top_offset());
1205     int tlab_end_offset = in_bytes(JavaThread::tlab_end_offset());
1206     eden_top_adr = basic_plus_adr(top()/*not oop*/, thread, tlab_top_offset);
1207     eden_end_adr = basic_plus_adr(top()/*not oop*/, thread, tlab_end_offset);
1208   } else {                      // Shared allocation: load from globals
1209     CollectedHeap* ch = Universe::heap();
1210     address top_adr = (address)ch-&gt;top_addr();
1211     address end_adr = (address)ch-&gt;end_addr();
1212     eden_top_adr = makecon(TypeRawPtr::make(top_adr));
1213     eden_end_adr = basic_plus_adr(eden_top_adr, end_adr - top_adr);
1214   }
1215 }
1216 
1217 
1218 Node* PhaseMacroExpand::make_load(Node* ctl, Node* mem, Node* base, int offset, const Type* value_type, BasicType bt) {
1219   Node* adr = basic_plus_adr(base, offset);
1220   const TypePtr* adr_type = adr-&gt;bottom_type()-&gt;is_ptr();
1221   Node* value = LoadNode::make(_igvn, ctl, mem, adr, adr_type, value_type, bt, MemNode::unordered);
1222   transform_later(value);
1223   return value;
1224 }
1225 
1226 
1227 Node* PhaseMacroExpand::make_store(Node* ctl, Node* mem, Node* base, int offset, Node* value, BasicType bt) {
1228   Node* adr = basic_plus_adr(base, offset);
1229   mem = StoreNode::make(_igvn, ctl, mem, adr, NULL, value, bt, MemNode::unordered);
1230   transform_later(mem);
1231   return mem;
1232 }
1233 
1234 //=============================================================================
1235 //
1236 //                              A L L O C A T I O N
1237 //
1238 // Allocation attempts to be fast in the case of frequent small objects.
1239 // It breaks down like this:
1240 //
1241 // 1) Size in doublewords is computed.  This is a constant for objects and
1242 // variable for most arrays.  Doubleword units are used to avoid size
1243 // overflow of huge doubleword arrays.  We need doublewords in the end for
1244 // rounding.
1245 //
1246 // 2) Size is checked for being &#39;too large&#39;.  Too-large allocations will go
1247 // the slow path into the VM.  The slow path can throw any required
1248 // exceptions, and does all the special checks for very large arrays.  The
1249 // size test can constant-fold away for objects.  For objects with
1250 // finalizers it constant-folds the otherway: you always go slow with
1251 // finalizers.
1252 //
1253 // 3) If NOT using TLABs, this is the contended loop-back point.
1254 // Load-Locked the heap top.  If using TLABs normal-load the heap top.
1255 //
1256 // 4) Check that heap top + size*8 &lt; max.  If we fail go the slow ` route.
1257 // NOTE: &quot;top+size*8&quot; cannot wrap the 4Gig line!  Here&#39;s why: for largish
1258 // &quot;size*8&quot; we always enter the VM, where &quot;largish&quot; is a constant picked small
1259 // enough that there&#39;s always space between the eden max and 4Gig (old space is
1260 // there so it&#39;s quite large) and large enough that the cost of entering the VM
1261 // is dwarfed by the cost to initialize the space.
1262 //
1263 // 5) If NOT using TLABs, Store-Conditional the adjusted heap top back
1264 // down.  If contended, repeat at step 3.  If using TLABs normal-store
1265 // adjusted heap top back down; there is no contention.
1266 //
1267 // 6) If !ZeroTLAB then Bulk-clear the object/array.  Fill in klass &amp; mark
1268 // fields.
1269 //
1270 // 7) Merge with the slow-path; cast the raw memory pointer to the correct
1271 // oop flavor.
1272 //
1273 //=============================================================================
1274 // FastAllocateSizeLimit value is in DOUBLEWORDS.
1275 // Allocations bigger than this always go the slow route.
1276 // This value must be small enough that allocation attempts that need to
1277 // trigger exceptions go the slow route.  Also, it must be small enough so
1278 // that heap_top + size_in_bytes does not wrap around the 4Gig limit.
1279 //=============================================================================j//
1280 // %%% Here is an old comment from parseHelper.cpp; is it outdated?
1281 // The allocator will coalesce int-&gt;oop copies away.  See comment in
1282 // coalesce.cpp about how this works.  It depends critically on the exact
1283 // code shape produced here, so if you are changing this code shape
1284 // make sure the GC info for the heap-top is correct in and around the
1285 // slow-path call.
1286 //
1287 
1288 void PhaseMacroExpand::expand_allocate_common(
1289             AllocateNode* alloc, // allocation node to be expanded
1290             Node* length,  // array length for an array allocation
1291             const TypeFunc* slow_call_type, // Type of slow call
1292             address slow_call_address  // Address of slow call
1293     )
1294 {
<a name="15" id="anc15"></a>
1295   Node* ctrl = alloc-&gt;in(TypeFunc::Control);
1296   Node* mem  = alloc-&gt;in(TypeFunc::Memory);
1297   Node* i_o  = alloc-&gt;in(TypeFunc::I_O);
1298   Node* size_in_bytes     = alloc-&gt;in(AllocateNode::AllocSize);
1299   Node* klass_node        = alloc-&gt;in(AllocateNode::KlassNode);
1300   Node* initial_slow_test = alloc-&gt;in(AllocateNode::InitialTest);
<a name="16" id="anc16"></a>
1301   assert(ctrl != NULL, &quot;must have control&quot;);
<a name="17" id="anc17"></a><span class="line-added">1302 </span>
1303   // We need a Region and corresponding Phi&#39;s to merge the slow-path and fast-path results.
1304   // they will not be used if &quot;always_slow&quot; is set
1305   enum { slow_result_path = 1, fast_result_path = 2 };
1306   Node *result_region = NULL;
1307   Node *result_phi_rawmem = NULL;
1308   Node *result_phi_rawoop = NULL;
1309   Node *result_phi_i_o = NULL;
1310 
1311   // The initial slow comparison is a size check, the comparison
1312   // we want to do is a BoolTest::gt
<a name="18" id="anc18"></a><span class="line-modified">1313   bool expand_fast_path = true;</span>
1314   int tv = _igvn.find_int_con(initial_slow_test, -1);
1315   if (tv &gt;= 0) {
<a name="19" id="anc19"></a><span class="line-modified">1316     // InitialTest has constant result</span>
<span class="line-added">1317     //   0 - can fit in TLAB</span>
<span class="line-added">1318     //   1 - always too big or negative</span>
<span class="line-added">1319     assert(tv &lt;= 1, &quot;0 or 1 if a constant&quot;);</span>
<span class="line-added">1320     expand_fast_path = (tv == 0);</span>
1321     initial_slow_test = NULL;
1322   } else {
1323     initial_slow_test = BoolNode::make_predicate(initial_slow_test, &amp;_igvn);
1324   }
1325 
1326   if (C-&gt;env()-&gt;dtrace_alloc_probes() ||
1327       (!UseTLAB &amp;&amp; !Universe::heap()-&gt;supports_inline_contig_alloc())) {
1328     // Force slow-path allocation
<a name="20" id="anc20"></a><span class="line-modified">1329     expand_fast_path = false;</span>
1330     initial_slow_test = NULL;
1331   }
1332 
<a name="21" id="anc21"></a><span class="line-added">1333   bool allocation_has_use = (alloc-&gt;result_cast() != NULL);</span>
<span class="line-added">1334   if (!allocation_has_use) {</span>
<span class="line-added">1335     InitializeNode* init = alloc-&gt;initialization();</span>
<span class="line-added">1336     if (init != NULL) {</span>
<span class="line-added">1337       yank_initalize_node(init);</span>
<span class="line-added">1338       assert(init-&gt;outcnt() == 0, &quot;all uses must be deleted&quot;);</span>
<span class="line-added">1339       _igvn.remove_dead_node(init);</span>
<span class="line-added">1340     }</span>
<span class="line-added">1341     if (expand_fast_path &amp;&amp; (initial_slow_test == NULL)) {</span>
<span class="line-added">1342       // Remove allocation node and return.</span>
<span class="line-added">1343       // Size is a non-negative constant -&gt; no initial check needed -&gt; directly to fast path.</span>
<span class="line-added">1344       // Also, no usages -&gt; empty fast path -&gt; no fall out to slow path -&gt; nothing left.</span>
<span class="line-added">1345       yank_alloc_node(alloc);</span>
<span class="line-added">1346       return;</span>
<span class="line-added">1347     }</span>
<span class="line-added">1348   }</span>
1349 
1350   enum { too_big_or_final_path = 1, need_gc_path = 2 };
1351   Node *slow_region = NULL;
1352   Node *toobig_false = ctrl;
1353 
<a name="22" id="anc22"></a>
1354   // generate the initial test if necessary
1355   if (initial_slow_test != NULL ) {
<a name="23" id="anc23"></a><span class="line-added">1356     assert (expand_fast_path, &quot;Only need test if there is a fast path&quot;);</span>
1357     slow_region = new RegionNode(3);
1358 
1359     // Now make the initial failure test.  Usually a too-big test but
1360     // might be a TRUE for finalizers or a fancy class check for
1361     // newInstance0.
1362     IfNode *toobig_iff = new IfNode(ctrl, initial_slow_test, PROB_MIN, COUNT_UNKNOWN);
1363     transform_later(toobig_iff);
1364     // Plug the failing-too-big test into the slow-path region
1365     Node *toobig_true = new IfTrueNode( toobig_iff );
1366     transform_later(toobig_true);
1367     slow_region    -&gt;init_req( too_big_or_final_path, toobig_true );
1368     toobig_false = new IfFalseNode( toobig_iff );
1369     transform_later(toobig_false);
<a name="24" id="anc24"></a><span class="line-modified">1370   } else {</span>
<span class="line-added">1371     // No initial test, just fall into next case</span>
<span class="line-added">1372     assert(allocation_has_use || !expand_fast_path, &quot;Should already have been handled&quot;);</span>
1373     toobig_false = ctrl;
1374     debug_only(slow_region = NodeSentinel);
1375   }
1376 
<a name="25" id="anc25"></a><span class="line-added">1377   // If we are here there are several possibilities</span>
<span class="line-added">1378   // - expand_fast_path is false - then only a slow path is expanded. That&#39;s it.</span>
<span class="line-added">1379   // no_initial_check means a constant allocation.</span>
<span class="line-added">1380   // - If check always evaluates to false -&gt; expand_fast_path is false (see above)</span>
<span class="line-added">1381   // - If check always evaluates to true -&gt; directly into fast path (but may bailout to slowpath)</span>
<span class="line-added">1382   // if !allocation_has_use the fast path is empty</span>
<span class="line-added">1383   // if !allocation_has_use &amp;&amp; no_initial_check</span>
<span class="line-added">1384   // - Then there are no fastpath that can fall out to slowpath -&gt; no allocation code at all.</span>
<span class="line-added">1385   //   removed by yank_alloc_node above.</span>
<span class="line-added">1386 </span>
1387   Node *slow_mem = mem;  // save the current memory state for slow path
1388   // generate the fast allocation code unless we know that the initial test will always go slow
<a name="26" id="anc26"></a><span class="line-modified">1389   if (expand_fast_path) {</span>
1390     // Fast path modifies only raw memory.
1391     if (mem-&gt;is_MergeMem()) {
1392       mem = mem-&gt;as_MergeMem()-&gt;memory_at(Compile::AliasIdxRaw);
1393     }
1394 
1395     // allocate the Region and Phi nodes for the result
1396     result_region = new RegionNode(3);
1397     result_phi_rawmem = new PhiNode(result_region, Type::MEMORY, TypeRawPtr::BOTTOM);
<a name="27" id="anc27"></a>
1398     result_phi_i_o    = new PhiNode(result_region, Type::ABIO); // I/O is used for Prefetch
1399 
1400     // Grab regular I/O before optional prefetch may change it.
1401     // Slow-path does no I/O so just set it to the original I/O.
1402     result_phi_i_o-&gt;init_req(slow_result_path, i_o);
1403 
<a name="28" id="anc28"></a>
1404     // Name successful fast-path variables
1405     Node* fast_oop_ctrl;
1406     Node* fast_oop_rawmem;
<a name="29" id="anc29"></a><span class="line-added">1407     if (allocation_has_use) {</span>
<span class="line-added">1408       Node* needgc_ctrl = NULL;</span>
<span class="line-added">1409       result_phi_rawoop = new PhiNode(result_region, TypeRawPtr::BOTTOM);</span>
1410 
<a name="30" id="anc30"></a><span class="line-modified">1411       intx prefetch_lines = length != NULL ? AllocatePrefetchLines : AllocateInstancePrefetchLines;</span>
<span class="line-modified">1412       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="line-modified">1413       Node* fast_oop = bs-&gt;obj_allocate(this, ctrl, mem, toobig_false, size_in_bytes, i_o, needgc_ctrl,</span>
<span class="line-modified">1414                                         fast_oop_ctrl, fast_oop_rawmem,</span>
<span class="line-modified">1415                                         prefetch_lines);</span>
<span class="line-modified">1416 </span>
<span class="line-modified">1417       if (initial_slow_test != NULL) {</span>
<span class="line-modified">1418         // This completes all paths into the slow merge point</span>
<span class="line-modified">1419         slow_region-&gt;init_req(need_gc_path, needgc_ctrl);</span>
<span class="line-modified">1420         transform_later(slow_region);</span>









































1421       } else {
<a name="31" id="anc31"></a><span class="line-modified">1422         // No initial slow path needed!</span>
<span class="line-modified">1423         // Just fall from the need-GC path straight into the VM call.</span>
<span class="line-modified">1424         slow_region = needgc_ctrl;</span>
































1425       }
<a name="32" id="anc32"></a>








1426 
<a name="33" id="anc33"></a><span class="line-modified">1427       InitializeNode* init = alloc-&gt;initialization();</span>
<span class="line-modified">1428       fast_oop_rawmem = initialize_object(alloc,</span>
<span class="line-modified">1429                                           fast_oop_ctrl, fast_oop_rawmem, fast_oop,</span>
<span class="line-added">1430                                           klass_node, length, size_in_bytes);</span>
<span class="line-added">1431       expand_initialize_membar(alloc, init, fast_oop_ctrl, fast_oop_rawmem);</span>
<span class="line-added">1432       expand_dtrace_alloc_probe(alloc, fast_oop, fast_oop_ctrl, fast_oop_rawmem);</span>
1433 
<a name="34" id="anc34"></a><span class="line-modified">1434       result_phi_rawoop-&gt;init_req(fast_result_path, fast_oop);</span>
<span class="line-modified">1435     } else {</span>
<span class="line-modified">1436       assert (initial_slow_test != NULL, &quot;sanity&quot;);</span>
<span class="line-modified">1437       fast_oop_ctrl   = toobig_false;</span>
<span class="line-modified">1438       fast_oop_rawmem = mem;</span>
<span class="line-modified">1439       transform_later(slow_region);</span>






1440     }
1441 
1442     // Plug in the successful fast-path into the result merge point
1443     result_region    -&gt;init_req(fast_result_path, fast_oop_ctrl);
<a name="35" id="anc35"></a>
1444     result_phi_i_o   -&gt;init_req(fast_result_path, i_o);
1445     result_phi_rawmem-&gt;init_req(fast_result_path, fast_oop_rawmem);
1446   } else {
1447     slow_region = ctrl;
1448     result_phi_i_o = i_o; // Rename it to use in the following code.
1449   }
1450 
1451   // Generate slow-path call
1452   CallNode *call = new CallStaticJavaNode(slow_call_type, slow_call_address,
1453                                OptoRuntime::stub_name(slow_call_address),
1454                                alloc-&gt;jvms()-&gt;bci(),
1455                                TypePtr::BOTTOM);
<a name="36" id="anc36"></a><span class="line-modified">1456   call-&gt;init_req(TypeFunc::Control,   slow_region);</span>
<span class="line-modified">1457   call-&gt;init_req(TypeFunc::I_O,       top());    // does no i/o</span>
<span class="line-modified">1458   call-&gt;init_req(TypeFunc::Memory,    slow_mem); // may gc ptrs</span>
<span class="line-modified">1459   call-&gt;init_req(TypeFunc::ReturnAdr, alloc-&gt;in(TypeFunc::ReturnAdr));</span>
<span class="line-modified">1460   call-&gt;init_req(TypeFunc::FramePtr,  alloc-&gt;in(TypeFunc::FramePtr));</span>
1461 
1462   call-&gt;init_req(TypeFunc::Parms+0, klass_node);
1463   if (length != NULL) {
1464     call-&gt;init_req(TypeFunc::Parms+1, length);
1465   }
1466 
1467   // Copy debug information and adjust JVMState information, then replace
1468   // allocate node with the call
1469   copy_call_debug_info((CallNode *) alloc,  call);
<a name="37" id="anc37"></a><span class="line-modified">1470   if (expand_fast_path) {</span>
1471     call-&gt;set_cnt(PROB_UNLIKELY_MAG(4));  // Same effect as RC_UNCOMMON.
1472   } else {
1473     // Hook i_o projection to avoid its elimination during allocation
1474     // replacement (when only a slow call is generated).
1475     call-&gt;set_req(TypeFunc::I_O, result_phi_i_o);
1476   }
1477   _igvn.replace_node(alloc, call);
1478   transform_later(call);
1479 
1480   // Identify the output projections from the allocate node and
1481   // adjust any references to them.
1482   // The control and io projections look like:
1483   //
1484   //        v---Proj(ctrl) &lt;-----+   v---CatchProj(ctrl)
1485   //  Allocate                   Catch
1486   //        ^---Proj(io) &lt;-------+   ^---CatchProj(io)
1487   //
1488   //  We are interested in the CatchProj nodes.
1489   //
1490   extract_call_projections(call);
1491 
1492   // An allocate node has separate memory projections for the uses on
1493   // the control and i_o paths. Replace the control memory projection with
1494   // result_phi_rawmem (unless we are only generating a slow call when
1495   // both memory projections are combined)
<a name="38" id="anc38"></a><span class="line-modified">1496   if (expand_fast_path &amp;&amp; _memproj_fallthrough != NULL) {</span>
<span class="line-modified">1497     migrate_outs(_memproj_fallthrough, result_phi_rawmem);</span>






1498   }
1499   // Now change uses of _memproj_catchall to use _memproj_fallthrough and delete
1500   // _memproj_catchall so we end up with a call that has only 1 memory projection.
1501   if (_memproj_catchall != NULL ) {
1502     if (_memproj_fallthrough == NULL) {
1503       _memproj_fallthrough = new ProjNode(call, TypeFunc::Memory);
1504       transform_later(_memproj_fallthrough);
1505     }
<a name="39" id="anc39"></a><span class="line-modified">1506     migrate_outs(_memproj_catchall, _memproj_fallthrough);</span>







1507     _igvn.remove_dead_node(_memproj_catchall);
1508   }
1509 
1510   // An allocate node has separate i_o projections for the uses on the control
1511   // and i_o paths. Always replace the control i_o projection with result i_o
1512   // otherwise incoming i_o become dead when only a slow call is generated
1513   // (it is different from memory projections where both projections are
1514   // combined in such case).
1515   if (_ioproj_fallthrough != NULL) {
<a name="40" id="anc40"></a><span class="line-modified">1516     migrate_outs(_ioproj_fallthrough, result_phi_i_o);</span>






1517   }
1518   // Now change uses of _ioproj_catchall to use _ioproj_fallthrough and delete
1519   // _ioproj_catchall so we end up with a call that has only 1 i_o projection.
1520   if (_ioproj_catchall != NULL ) {
1521     if (_ioproj_fallthrough == NULL) {
1522       _ioproj_fallthrough = new ProjNode(call, TypeFunc::I_O);
1523       transform_later(_ioproj_fallthrough);
1524     }
<a name="41" id="anc41"></a><span class="line-modified">1525     migrate_outs(_ioproj_catchall, _ioproj_fallthrough);</span>







1526     _igvn.remove_dead_node(_ioproj_catchall);
1527   }
1528 
1529   // if we generated only a slow call, we are done
<a name="42" id="anc42"></a><span class="line-modified">1530   if (!expand_fast_path) {</span>
1531     // Now we can unhook i_o.
1532     if (result_phi_i_o-&gt;outcnt() &gt; 1) {
1533       call-&gt;set_req(TypeFunc::I_O, top());
1534     } else {
<a name="43" id="anc43"></a><span class="line-modified">1535       assert(result_phi_i_o-&gt;unique_ctrl_out() == call, &quot;sanity&quot;);</span>
1536       // Case of new array with negative size known during compilation.
1537       // AllocateArrayNode::Ideal() optimization disconnect unreachable
1538       // following code since call to runtime will throw exception.
1539       // As result there will be no users of i_o after the call.
1540       // Leave i_o attached to this call to avoid problems in preceding graph.
1541     }
1542     return;
1543   }
1544 
<a name="44" id="anc44"></a>
1545   if (_fallthroughcatchproj != NULL) {
1546     ctrl = _fallthroughcatchproj-&gt;clone();
1547     transform_later(ctrl);
1548     _igvn.replace_node(_fallthroughcatchproj, result_region);
1549   } else {
1550     ctrl = top();
1551   }
1552   Node *slow_result;
1553   if (_resproj == NULL) {
1554     // no uses of the allocation result
1555     slow_result = top();
1556   } else {
1557     slow_result = _resproj-&gt;clone();
1558     transform_later(slow_result);
1559     _igvn.replace_node(_resproj, result_phi_rawoop);
1560   }
1561 
1562   // Plug slow-path into result merge point
<a name="45" id="anc45"></a><span class="line-modified">1563   result_region-&gt;init_req( slow_result_path, ctrl);</span>


1564   transform_later(result_region);
<a name="46" id="anc46"></a><span class="line-modified">1565   if (allocation_has_use) {</span>
<span class="line-added">1566     result_phi_rawoop-&gt;init_req(slow_result_path, slow_result);</span>
<span class="line-added">1567     transform_later(result_phi_rawoop);</span>
<span class="line-added">1568   }</span>
<span class="line-added">1569   result_phi_rawmem-&gt;init_req(slow_result_path, _memproj_fallthrough);</span>
1570   transform_later(result_phi_rawmem);
1571   transform_later(result_phi_i_o);
1572   // This completes all paths into the result merge point
1573 }
1574 
<a name="47" id="anc47"></a><span class="line-added">1575 // Remove alloc node that has no uses.</span>
<span class="line-added">1576 void PhaseMacroExpand::yank_alloc_node(AllocateNode* alloc) {</span>
<span class="line-added">1577   Node* ctrl = alloc-&gt;in(TypeFunc::Control);</span>
<span class="line-added">1578   Node* mem  = alloc-&gt;in(TypeFunc::Memory);</span>
<span class="line-added">1579   Node* i_o  = alloc-&gt;in(TypeFunc::I_O);</span>
<span class="line-added">1580 </span>
<span class="line-added">1581   extract_call_projections(alloc);</span>
<span class="line-added">1582   if (_fallthroughcatchproj != NULL) {</span>
<span class="line-added">1583     migrate_outs(_fallthroughcatchproj, ctrl);</span>
<span class="line-added">1584     _igvn.remove_dead_node(_fallthroughcatchproj);</span>
<span class="line-added">1585   }</span>
<span class="line-added">1586   if (_catchallcatchproj != NULL) {</span>
<span class="line-added">1587     _igvn.rehash_node_delayed(_catchallcatchproj);</span>
<span class="line-added">1588     _catchallcatchproj-&gt;set_req(0, top());</span>
<span class="line-added">1589   }</span>
<span class="line-added">1590   if (_fallthroughproj != NULL) {</span>
<span class="line-added">1591     Node* catchnode = _fallthroughproj-&gt;unique_ctrl_out();</span>
<span class="line-added">1592     _igvn.remove_dead_node(catchnode);</span>
<span class="line-added">1593     _igvn.remove_dead_node(_fallthroughproj);</span>
<span class="line-added">1594   }</span>
<span class="line-added">1595   if (_memproj_fallthrough != NULL) {</span>
<span class="line-added">1596     migrate_outs(_memproj_fallthrough, mem);</span>
<span class="line-added">1597     _igvn.remove_dead_node(_memproj_fallthrough);</span>
<span class="line-added">1598   }</span>
<span class="line-added">1599   if (_ioproj_fallthrough != NULL) {</span>
<span class="line-added">1600     migrate_outs(_ioproj_fallthrough, i_o);</span>
<span class="line-added">1601     _igvn.remove_dead_node(_ioproj_fallthrough);</span>
<span class="line-added">1602   }</span>
<span class="line-added">1603   if (_memproj_catchall != NULL) {</span>
<span class="line-added">1604     _igvn.rehash_node_delayed(_memproj_catchall);</span>
<span class="line-added">1605     _memproj_catchall-&gt;set_req(0, top());</span>
<span class="line-added">1606   }</span>
<span class="line-added">1607   if (_ioproj_catchall != NULL) {</span>
<span class="line-added">1608     _igvn.rehash_node_delayed(_ioproj_catchall);</span>
<span class="line-added">1609     _ioproj_catchall-&gt;set_req(0, top());</span>
<span class="line-added">1610   }</span>
<span class="line-added">1611   _igvn.remove_dead_node(alloc);</span>
<span class="line-added">1612 }</span>
<span class="line-added">1613 </span>
<span class="line-added">1614 void PhaseMacroExpand::expand_initialize_membar(AllocateNode* alloc, InitializeNode* init,</span>
<span class="line-added">1615                                                 Node*&amp; fast_oop_ctrl, Node*&amp; fast_oop_rawmem) {</span>
<span class="line-added">1616   // If initialization is performed by an array copy, any required</span>
<span class="line-added">1617   // MemBarStoreStore was already added. If the object does not</span>
<span class="line-added">1618   // escape no need for a MemBarStoreStore. If the object does not</span>
<span class="line-added">1619   // escape in its initializer and memory barrier (MemBarStoreStore or</span>
<span class="line-added">1620   // stronger) is already added at exit of initializer, also no need</span>
<span class="line-added">1621   // for a MemBarStoreStore. Otherwise we need a MemBarStoreStore</span>
<span class="line-added">1622   // so that stores that initialize this object can&#39;t be reordered</span>
<span class="line-added">1623   // with a subsequent store that makes this object accessible by</span>
<span class="line-added">1624   // other threads.</span>
<span class="line-added">1625   // Other threads include java threads and JVM internal threads</span>
<span class="line-added">1626   // (for example concurrent GC threads). Current concurrent GC</span>
<span class="line-added">1627   // implementation: G1 will not scan newly created object,</span>
<span class="line-added">1628   // so it&#39;s safe to skip storestore barrier when allocation does</span>
<span class="line-added">1629   // not escape.</span>
<span class="line-added">1630   if (!alloc-&gt;does_not_escape_thread() &amp;&amp;</span>
<span class="line-added">1631     !alloc-&gt;is_allocation_MemBar_redundant() &amp;&amp;</span>
<span class="line-added">1632     (init == NULL || !init-&gt;is_complete_with_arraycopy())) {</span>
<span class="line-added">1633     if (init == NULL || init-&gt;req() &lt; InitializeNode::RawStores) {</span>
<span class="line-added">1634       // No InitializeNode or no stores captured by zeroing</span>
<span class="line-added">1635       // elimination. Simply add the MemBarStoreStore after object</span>
<span class="line-added">1636       // initialization.</span>
<span class="line-added">1637       MemBarNode* mb = MemBarNode::make(C, Op_MemBarStoreStore, Compile::AliasIdxBot);</span>
<span class="line-added">1638       transform_later(mb);</span>
<span class="line-added">1639 </span>
<span class="line-added">1640       mb-&gt;init_req(TypeFunc::Memory, fast_oop_rawmem);</span>
<span class="line-added">1641       mb-&gt;init_req(TypeFunc::Control, fast_oop_ctrl);</span>
<span class="line-added">1642       fast_oop_ctrl = new ProjNode(mb, TypeFunc::Control);</span>
<span class="line-added">1643       transform_later(fast_oop_ctrl);</span>
<span class="line-added">1644       fast_oop_rawmem = new ProjNode(mb, TypeFunc::Memory);</span>
<span class="line-added">1645       transform_later(fast_oop_rawmem);</span>
<span class="line-added">1646     } else {</span>
<span class="line-added">1647       // Add the MemBarStoreStore after the InitializeNode so that</span>
<span class="line-added">1648       // all stores performing the initialization that were moved</span>
<span class="line-added">1649       // before the InitializeNode happen before the storestore</span>
<span class="line-added">1650       // barrier.</span>
<span class="line-added">1651 </span>
<span class="line-added">1652       Node* init_ctrl = init-&gt;proj_out_or_null(TypeFunc::Control);</span>
<span class="line-added">1653       Node* init_mem = init-&gt;proj_out_or_null(TypeFunc::Memory);</span>
<span class="line-added">1654 </span>
<span class="line-added">1655       MemBarNode* mb = MemBarNode::make(C, Op_MemBarStoreStore, Compile::AliasIdxBot);</span>
<span class="line-added">1656       transform_later(mb);</span>
<span class="line-added">1657 </span>
<span class="line-added">1658       Node* ctrl = new ProjNode(init, TypeFunc::Control);</span>
<span class="line-added">1659       transform_later(ctrl);</span>
<span class="line-added">1660       Node* mem = new ProjNode(init, TypeFunc::Memory);</span>
<span class="line-added">1661       transform_later(mem);</span>
<span class="line-added">1662 </span>
<span class="line-added">1663       // The MemBarStoreStore depends on control and memory coming</span>
<span class="line-added">1664       // from the InitializeNode</span>
<span class="line-added">1665       mb-&gt;init_req(TypeFunc::Memory, mem);</span>
<span class="line-added">1666       mb-&gt;init_req(TypeFunc::Control, ctrl);</span>
<span class="line-added">1667 </span>
<span class="line-added">1668       ctrl = new ProjNode(mb, TypeFunc::Control);</span>
<span class="line-added">1669       transform_later(ctrl);</span>
<span class="line-added">1670       mem = new ProjNode(mb, TypeFunc::Memory);</span>
<span class="line-added">1671       transform_later(mem);</span>
<span class="line-added">1672 </span>
<span class="line-added">1673       // All nodes that depended on the InitializeNode for control</span>
<span class="line-added">1674       // and memory must now depend on the MemBarNode that itself</span>
<span class="line-added">1675       // depends on the InitializeNode</span>
<span class="line-added">1676       if (init_ctrl != NULL) {</span>
<span class="line-added">1677         _igvn.replace_node(init_ctrl, ctrl);</span>
<span class="line-added">1678       }</span>
<span class="line-added">1679       if (init_mem != NULL) {</span>
<span class="line-added">1680         _igvn.replace_node(init_mem, mem);</span>
<span class="line-added">1681       }</span>
<span class="line-added">1682     }</span>
<span class="line-added">1683   }</span>
<span class="line-added">1684 }</span>
<span class="line-added">1685 </span>
<span class="line-added">1686 void PhaseMacroExpand::expand_dtrace_alloc_probe(AllocateNode* alloc, Node* oop,</span>
<span class="line-added">1687                                                 Node*&amp; ctrl, Node*&amp; rawmem) {</span>
<span class="line-added">1688   if (C-&gt;env()-&gt;dtrace_extended_probes()) {</span>
<span class="line-added">1689     // Slow-path call</span>
<span class="line-added">1690     int size = TypeFunc::Parms + 2;</span>
<span class="line-added">1691     CallLeafNode *call = new CallLeafNode(OptoRuntime::dtrace_object_alloc_Type(),</span>
<span class="line-added">1692                                           CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc_base),</span>
<span class="line-added">1693                                           &quot;dtrace_object_alloc&quot;,</span>
<span class="line-added">1694                                           TypeRawPtr::BOTTOM);</span>
<span class="line-added">1695 </span>
<span class="line-added">1696     // Get base of thread-local storage area</span>
<span class="line-added">1697     Node* thread = new ThreadLocalNode();</span>
<span class="line-added">1698     transform_later(thread);</span>
<span class="line-added">1699 </span>
<span class="line-added">1700     call-&gt;init_req(TypeFunc::Parms + 0, thread);</span>
<span class="line-added">1701     call-&gt;init_req(TypeFunc::Parms + 1, oop);</span>
<span class="line-added">1702     call-&gt;init_req(TypeFunc::Control, ctrl);</span>
<span class="line-added">1703     call-&gt;init_req(TypeFunc::I_O    , top()); // does no i/o</span>
<span class="line-added">1704     call-&gt;init_req(TypeFunc::Memory , ctrl);</span>
<span class="line-added">1705     call-&gt;init_req(TypeFunc::ReturnAdr, alloc-&gt;in(TypeFunc::ReturnAdr));</span>
<span class="line-added">1706     call-&gt;init_req(TypeFunc::FramePtr, alloc-&gt;in(TypeFunc::FramePtr));</span>
<span class="line-added">1707     transform_later(call);</span>
<span class="line-added">1708     ctrl = new ProjNode(call, TypeFunc::Control);</span>
<span class="line-added">1709     transform_later(ctrl);</span>
<span class="line-added">1710     rawmem = new ProjNode(call, TypeFunc::Memory);</span>
<span class="line-added">1711     transform_later(rawmem);</span>
<span class="line-added">1712   }</span>
<span class="line-added">1713 }</span>
<span class="line-added">1714 </span>
<span class="line-added">1715 // Remove InitializeNode without use</span>
<span class="line-added">1716 void PhaseMacroExpand::yank_initalize_node(InitializeNode* initnode) {</span>
<span class="line-added">1717   assert(initnode-&gt;proj_out_or_null(TypeFunc::Parms) == NULL, &quot;No uses allowed&quot;);</span>
<span class="line-added">1718 </span>
<span class="line-added">1719   Node* ctrl_out  = initnode-&gt;proj_out_or_null(TypeFunc::Control);</span>
<span class="line-added">1720   Node* mem_out   = initnode-&gt;proj_out_or_null(TypeFunc::Memory);</span>
<span class="line-added">1721 </span>
<span class="line-added">1722   // Move all uses of each to</span>
<span class="line-added">1723   if (ctrl_out != NULL ) {</span>
<span class="line-added">1724     migrate_outs(ctrl_out, initnode-&gt;in(TypeFunc::Control));</span>
<span class="line-added">1725     _igvn.remove_dead_node(ctrl_out);</span>
<span class="line-added">1726   }</span>
<span class="line-added">1727 </span>
<span class="line-added">1728   // Move all uses of each to</span>
<span class="line-added">1729   if (mem_out != NULL ) {</span>
<span class="line-added">1730     migrate_outs(mem_out, initnode-&gt;in(TypeFunc::Memory));</span>
<span class="line-added">1731     _igvn.remove_dead_node(mem_out);</span>
<span class="line-added">1732   }</span>
<span class="line-added">1733 }</span>
1734 
1735 // Helper for PhaseMacroExpand::expand_allocate_common.
1736 // Initializes the newly-allocated storage.
1737 Node*
1738 PhaseMacroExpand::initialize_object(AllocateNode* alloc,
1739                                     Node* control, Node* rawmem, Node* object,
1740                                     Node* klass_node, Node* length,
1741                                     Node* size_in_bytes) {
1742   InitializeNode* init = alloc-&gt;initialization();
1743   // Store the klass &amp; mark bits
<a name="48" id="anc48"></a><span class="line-modified">1744   Node* mark_node = alloc-&gt;make_ideal_mark(&amp;_igvn, object, control, rawmem);</span>
<span class="line-modified">1745   if (!mark_node-&gt;is_Con()) {</span>
<span class="line-modified">1746     transform_later(mark_node);</span>



1747   }
<a name="49" id="anc49"></a><span class="line-modified">1748   rawmem = make_store(control, rawmem, object, oopDesc::mark_offset_in_bytes(), mark_node, TypeX_X-&gt;basic_type());</span>
1749 
1750   rawmem = make_store(control, rawmem, object, oopDesc::klass_offset_in_bytes(), klass_node, T_METADATA);
1751   int header_size = alloc-&gt;minimum_header_size();  // conservatively small
1752 
1753   // Array length
1754   if (length != NULL) {         // Arrays need length field
1755     rawmem = make_store(control, rawmem, object, arrayOopDesc::length_offset_in_bytes(), length, T_INT);
1756     // conservatively small header size:
1757     header_size = arrayOopDesc::base_offset_in_bytes(T_BYTE);
1758     ciKlass* k = _igvn.type(klass_node)-&gt;is_klassptr()-&gt;klass();
1759     if (k-&gt;is_array_klass())    // we know the exact header size in most cases:
1760       header_size = Klass::layout_helper_header_size(k-&gt;layout_helper());
1761   }
1762 
1763   // Clear the object body, if necessary.
1764   if (init == NULL) {
1765     // The init has somehow disappeared; be cautious and clear everything.
1766     //
1767     // This can happen if a node is allocated but an uncommon trap occurs
1768     // immediately.  In this case, the Initialize gets associated with the
1769     // trap, and may be placed in a different (outer) loop, if the Allocate
1770     // is in a loop.  If (this is rare) the inner loop gets unrolled, then
1771     // there can be two Allocates to one Initialize.  The answer in all these
1772     // edge cases is safety first.  It is always safe to clear immediately
1773     // within an Allocate, and then (maybe or maybe not) clear some more later.
1774     if (!(UseTLAB &amp;&amp; ZeroTLAB)) {
1775       rawmem = ClearArrayNode::clear_memory(control, rawmem, object,
1776                                             header_size, size_in_bytes,
1777                                             &amp;_igvn);
1778     }
1779   } else {
1780     if (!init-&gt;is_complete()) {
1781       // Try to win by zeroing only what the init does not store.
1782       // We can also try to do some peephole optimizations,
1783       // such as combining some adjacent subword stores.
1784       rawmem = init-&gt;complete_stores(control, rawmem, object,
1785                                      header_size, size_in_bytes, &amp;_igvn);
1786     }
1787     // We have no more use for this link, since the AllocateNode goes away:
1788     init-&gt;set_req(InitializeNode::RawAddress, top());
1789     // (If we keep the link, it just confuses the register allocator,
1790     // who thinks he sees a real use of the address by the membar.)
1791   }
1792 
1793   return rawmem;
1794 }
1795 
1796 // Generate prefetch instructions for next allocations.
1797 Node* PhaseMacroExpand::prefetch_allocation(Node* i_o, Node*&amp; needgc_false,
1798                                         Node*&amp; contended_phi_rawmem,
1799                                         Node* old_eden_top, Node* new_eden_top,
1800                                         intx lines) {
1801    enum { fall_in_path = 1, pf_path = 2 };
1802    if( UseTLAB &amp;&amp; AllocatePrefetchStyle == 2 ) {
1803       // Generate prefetch allocation with watermark check.
1804       // As an allocation hits the watermark, we will prefetch starting
1805       // at a &quot;distance&quot; away from watermark.
1806 
1807       Node *pf_region = new RegionNode(3);
1808       Node *pf_phi_rawmem = new PhiNode( pf_region, Type::MEMORY,
1809                                                 TypeRawPtr::BOTTOM );
1810       // I/O is used for Prefetch
1811       Node *pf_phi_abio = new PhiNode( pf_region, Type::ABIO );
1812 
1813       Node *thread = new ThreadLocalNode();
1814       transform_later(thread);
1815 
1816       Node *eden_pf_adr = new AddPNode( top()/*not oop*/, thread,
1817                    _igvn.MakeConX(in_bytes(JavaThread::tlab_pf_top_offset())) );
1818       transform_later(eden_pf_adr);
1819 
1820       Node *old_pf_wm = new LoadPNode(needgc_false,
1821                                    contended_phi_rawmem, eden_pf_adr,
1822                                    TypeRawPtr::BOTTOM, TypeRawPtr::BOTTOM,
1823                                    MemNode::unordered);
1824       transform_later(old_pf_wm);
1825 
1826       // check against new_eden_top
1827       Node *need_pf_cmp = new CmpPNode( new_eden_top, old_pf_wm );
1828       transform_later(need_pf_cmp);
1829       Node *need_pf_bol = new BoolNode( need_pf_cmp, BoolTest::ge );
1830       transform_later(need_pf_bol);
1831       IfNode *need_pf_iff = new IfNode( needgc_false, need_pf_bol,
1832                                        PROB_UNLIKELY_MAG(4), COUNT_UNKNOWN );
1833       transform_later(need_pf_iff);
1834 
1835       // true node, add prefetchdistance
1836       Node *need_pf_true = new IfTrueNode( need_pf_iff );
1837       transform_later(need_pf_true);
1838 
1839       Node *need_pf_false = new IfFalseNode( need_pf_iff );
1840       transform_later(need_pf_false);
1841 
1842       Node *new_pf_wmt = new AddPNode( top(), old_pf_wm,
1843                                     _igvn.MakeConX(AllocatePrefetchDistance) );
1844       transform_later(new_pf_wmt );
1845       new_pf_wmt-&gt;set_req(0, need_pf_true);
1846 
1847       Node *store_new_wmt = new StorePNode(need_pf_true,
1848                                        contended_phi_rawmem, eden_pf_adr,
1849                                        TypeRawPtr::BOTTOM, new_pf_wmt,
1850                                        MemNode::unordered);
1851       transform_later(store_new_wmt);
1852 
1853       // adding prefetches
1854       pf_phi_abio-&gt;init_req( fall_in_path, i_o );
1855 
1856       Node *prefetch_adr;
1857       Node *prefetch;
1858       uint step_size = AllocatePrefetchStepSize;
1859       uint distance = 0;
1860 
1861       for ( intx i = 0; i &lt; lines; i++ ) {
1862         prefetch_adr = new AddPNode( old_pf_wm, new_pf_wmt,
1863                                             _igvn.MakeConX(distance) );
1864         transform_later(prefetch_adr);
1865         prefetch = new PrefetchAllocationNode( i_o, prefetch_adr );
1866         transform_later(prefetch);
1867         distance += step_size;
1868         i_o = prefetch;
1869       }
1870       pf_phi_abio-&gt;set_req( pf_path, i_o );
1871 
1872       pf_region-&gt;init_req( fall_in_path, need_pf_false );
1873       pf_region-&gt;init_req( pf_path, need_pf_true );
1874 
1875       pf_phi_rawmem-&gt;init_req( fall_in_path, contended_phi_rawmem );
1876       pf_phi_rawmem-&gt;init_req( pf_path, store_new_wmt );
1877 
1878       transform_later(pf_region);
1879       transform_later(pf_phi_rawmem);
1880       transform_later(pf_phi_abio);
1881 
1882       needgc_false = pf_region;
1883       contended_phi_rawmem = pf_phi_rawmem;
1884       i_o = pf_phi_abio;
1885    } else if( UseTLAB &amp;&amp; AllocatePrefetchStyle == 3 ) {
1886       // Insert a prefetch instruction for each allocation.
1887       // This code is used to generate 1 prefetch instruction per cache line.
1888 
1889       // Generate several prefetch instructions.
1890       uint step_size = AllocatePrefetchStepSize;
1891       uint distance = AllocatePrefetchDistance;
1892 
1893       // Next cache address.
1894       Node *cache_adr = new AddPNode(old_eden_top, old_eden_top,
1895                                      _igvn.MakeConX(step_size + distance));
1896       transform_later(cache_adr);
1897       cache_adr = new CastP2XNode(needgc_false, cache_adr);
1898       transform_later(cache_adr);
1899       // Address is aligned to execute prefetch to the beginning of cache line size
1900       // (it is important when BIS instruction is used on SPARC as prefetch).
1901       Node* mask = _igvn.MakeConX(~(intptr_t)(step_size-1));
1902       cache_adr = new AndXNode(cache_adr, mask);
1903       transform_later(cache_adr);
1904       cache_adr = new CastX2PNode(cache_adr);
1905       transform_later(cache_adr);
1906 
1907       // Prefetch
1908       Node *prefetch = new PrefetchAllocationNode( contended_phi_rawmem, cache_adr );
1909       prefetch-&gt;set_req(0, needgc_false);
1910       transform_later(prefetch);
1911       contended_phi_rawmem = prefetch;
1912       Node *prefetch_adr;
1913       distance = step_size;
1914       for ( intx i = 1; i &lt; lines; i++ ) {
1915         prefetch_adr = new AddPNode( cache_adr, cache_adr,
1916                                             _igvn.MakeConX(distance) );
1917         transform_later(prefetch_adr);
1918         prefetch = new PrefetchAllocationNode( contended_phi_rawmem, prefetch_adr );
1919         transform_later(prefetch);
1920         distance += step_size;
1921         contended_phi_rawmem = prefetch;
1922       }
1923    } else if( AllocatePrefetchStyle &gt; 0 ) {
1924       // Insert a prefetch for each allocation only on the fast-path
1925       Node *prefetch_adr;
1926       Node *prefetch;
1927       // Generate several prefetch instructions.
1928       uint step_size = AllocatePrefetchStepSize;
1929       uint distance = AllocatePrefetchDistance;
1930       for ( intx i = 0; i &lt; lines; i++ ) {
1931         prefetch_adr = new AddPNode( old_eden_top, new_eden_top,
1932                                             _igvn.MakeConX(distance) );
1933         transform_later(prefetch_adr);
1934         prefetch = new PrefetchAllocationNode( i_o, prefetch_adr );
1935         // Do not let it float too high, since if eden_top == eden_end,
1936         // both might be null.
1937         if( i == 0 ) { // Set control for first prefetch, next follows it
1938           prefetch-&gt;init_req(0, needgc_false);
1939         }
1940         transform_later(prefetch);
1941         distance += step_size;
1942         i_o = prefetch;
1943       }
1944    }
1945    return i_o;
1946 }
1947 
1948 
1949 void PhaseMacroExpand::expand_allocate(AllocateNode *alloc) {
1950   expand_allocate_common(alloc, NULL,
1951                          OptoRuntime::new_instance_Type(),
1952                          OptoRuntime::new_instance_Java());
1953 }
1954 
1955 void PhaseMacroExpand::expand_allocate_array(AllocateArrayNode *alloc) {
1956   Node* length = alloc-&gt;in(AllocateNode::ALength);
1957   InitializeNode* init = alloc-&gt;initialization();
1958   Node* klass_node = alloc-&gt;in(AllocateNode::KlassNode);
1959   ciKlass* k = _igvn.type(klass_node)-&gt;is_klassptr()-&gt;klass();
1960   address slow_call_address;  // Address of slow call
1961   if (init != NULL &amp;&amp; init-&gt;is_complete_with_arraycopy() &amp;&amp;
1962       k-&gt;is_type_array_klass()) {
1963     // Don&#39;t zero type array during slow allocation in VM since
1964     // it will be initialized later by arraycopy in compiled code.
1965     slow_call_address = OptoRuntime::new_array_nozero_Java();
1966   } else {
1967     slow_call_address = OptoRuntime::new_array_Java();
1968   }
1969   expand_allocate_common(alloc, length,
1970                          OptoRuntime::new_array_Type(),
1971                          slow_call_address);
1972 }
1973 
1974 //-------------------mark_eliminated_box----------------------------------
1975 //
1976 // During EA obj may point to several objects but after few ideal graph
1977 // transformations (CCP) it may point to only one non escaping object
1978 // (but still using phi), corresponding locks and unlocks will be marked
1979 // for elimination. Later obj could be replaced with a new node (new phi)
1980 // and which does not have escape information. And later after some graph
1981 // reshape other locks and unlocks (which were not marked for elimination
1982 // before) are connected to this new obj (phi) but they still will not be
1983 // marked for elimination since new obj has no escape information.
1984 // Mark all associated (same box and obj) lock and unlock nodes for
1985 // elimination if some of them marked already.
1986 void PhaseMacroExpand::mark_eliminated_box(Node* oldbox, Node* obj) {
1987   if (oldbox-&gt;as_BoxLock()-&gt;is_eliminated())
1988     return; // This BoxLock node was processed already.
1989 
1990   // New implementation (EliminateNestedLocks) has separate BoxLock
1991   // node for each locked region so mark all associated locks/unlocks as
1992   // eliminated even if different objects are referenced in one locked region
1993   // (for example, OSR compilation of nested loop inside locked scope).
1994   if (EliminateNestedLocks ||
1995       oldbox-&gt;as_BoxLock()-&gt;is_simple_lock_region(NULL, obj)) {
1996     // Box is used only in one lock region. Mark this box as eliminated.
1997     _igvn.hash_delete(oldbox);
1998     oldbox-&gt;as_BoxLock()-&gt;set_eliminated(); // This changes box&#39;s hash value
1999      _igvn.hash_insert(oldbox);
2000 
2001     for (uint i = 0; i &lt; oldbox-&gt;outcnt(); i++) {
2002       Node* u = oldbox-&gt;raw_out(i);
2003       if (u-&gt;is_AbstractLock() &amp;&amp; !u-&gt;as_AbstractLock()-&gt;is_non_esc_obj()) {
2004         AbstractLockNode* alock = u-&gt;as_AbstractLock();
2005         // Check lock&#39;s box since box could be referenced by Lock&#39;s debug info.
2006         if (alock-&gt;box_node() == oldbox) {
2007           // Mark eliminated all related locks and unlocks.
2008 #ifdef ASSERT
2009           alock-&gt;log_lock_optimization(C, &quot;eliminate_lock_set_non_esc4&quot;);
2010 #endif
2011           alock-&gt;set_non_esc_obj();
2012         }
2013       }
2014     }
2015     return;
2016   }
2017 
2018   // Create new &quot;eliminated&quot; BoxLock node and use it in monitor debug info
2019   // instead of oldbox for the same object.
2020   BoxLockNode* newbox = oldbox-&gt;clone()-&gt;as_BoxLock();
2021 
2022   // Note: BoxLock node is marked eliminated only here and it is used
2023   // to indicate that all associated lock and unlock nodes are marked
2024   // for elimination.
2025   newbox-&gt;set_eliminated();
2026   transform_later(newbox);
2027 
2028   // Replace old box node with new box for all users of the same object.
2029   for (uint i = 0; i &lt; oldbox-&gt;outcnt();) {
2030     bool next_edge = true;
2031 
2032     Node* u = oldbox-&gt;raw_out(i);
2033     if (u-&gt;is_AbstractLock()) {
2034       AbstractLockNode* alock = u-&gt;as_AbstractLock();
2035       if (alock-&gt;box_node() == oldbox &amp;&amp; alock-&gt;obj_node()-&gt;eqv_uncast(obj)) {
2036         // Replace Box and mark eliminated all related locks and unlocks.
2037 #ifdef ASSERT
2038         alock-&gt;log_lock_optimization(C, &quot;eliminate_lock_set_non_esc5&quot;);
2039 #endif
2040         alock-&gt;set_non_esc_obj();
2041         _igvn.rehash_node_delayed(alock);
2042         alock-&gt;set_box_node(newbox);
2043         next_edge = false;
2044       }
2045     }
2046     if (u-&gt;is_FastLock() &amp;&amp; u-&gt;as_FastLock()-&gt;obj_node()-&gt;eqv_uncast(obj)) {
2047       FastLockNode* flock = u-&gt;as_FastLock();
2048       assert(flock-&gt;box_node() == oldbox, &quot;sanity&quot;);
2049       _igvn.rehash_node_delayed(flock);
2050       flock-&gt;set_box_node(newbox);
2051       next_edge = false;
2052     }
2053 
2054     // Replace old box in monitor debug info.
2055     if (u-&gt;is_SafePoint() &amp;&amp; u-&gt;as_SafePoint()-&gt;jvms()) {
2056       SafePointNode* sfn = u-&gt;as_SafePoint();
2057       JVMState* youngest_jvms = sfn-&gt;jvms();
2058       int max_depth = youngest_jvms-&gt;depth();
2059       for (int depth = 1; depth &lt;= max_depth; depth++) {
2060         JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
2061         int num_mon  = jvms-&gt;nof_monitors();
2062         // Loop over monitors
2063         for (int idx = 0; idx &lt; num_mon; idx++) {
2064           Node* obj_node = sfn-&gt;monitor_obj(jvms, idx);
2065           Node* box_node = sfn-&gt;monitor_box(jvms, idx);
2066           if (box_node == oldbox &amp;&amp; obj_node-&gt;eqv_uncast(obj)) {
2067             int j = jvms-&gt;monitor_box_offset(idx);
2068             _igvn.replace_input_of(u, j, newbox);
2069             next_edge = false;
2070           }
2071         }
2072       }
2073     }
2074     if (next_edge) i++;
2075   }
2076 }
2077 
2078 //-----------------------mark_eliminated_locking_nodes-----------------------
2079 void PhaseMacroExpand::mark_eliminated_locking_nodes(AbstractLockNode *alock) {
2080   if (EliminateNestedLocks) {
2081     if (alock-&gt;is_nested()) {
2082        assert(alock-&gt;box_node()-&gt;as_BoxLock()-&gt;is_eliminated(), &quot;sanity&quot;);
2083        return;
2084     } else if (!alock-&gt;is_non_esc_obj()) { // Not eliminated or coarsened
2085       // Only Lock node has JVMState needed here.
2086       // Not that preceding claim is documented anywhere else.
2087       if (alock-&gt;jvms() != NULL) {
2088         if (alock-&gt;as_Lock()-&gt;is_nested_lock_region()) {
2089           // Mark eliminated related nested locks and unlocks.
2090           Node* obj = alock-&gt;obj_node();
2091           BoxLockNode* box_node = alock-&gt;box_node()-&gt;as_BoxLock();
2092           assert(!box_node-&gt;is_eliminated(), &quot;should not be marked yet&quot;);
2093           // Note: BoxLock node is marked eliminated only here
2094           // and it is used to indicate that all associated lock
2095           // and unlock nodes are marked for elimination.
2096           box_node-&gt;set_eliminated(); // Box&#39;s hash is always NO_HASH here
2097           for (uint i = 0; i &lt; box_node-&gt;outcnt(); i++) {
2098             Node* u = box_node-&gt;raw_out(i);
2099             if (u-&gt;is_AbstractLock()) {
2100               alock = u-&gt;as_AbstractLock();
2101               if (alock-&gt;box_node() == box_node) {
2102                 // Verify that this Box is referenced only by related locks.
2103                 assert(alock-&gt;obj_node()-&gt;eqv_uncast(obj), &quot;&quot;);
2104                 // Mark all related locks and unlocks.
2105 #ifdef ASSERT
2106                 alock-&gt;log_lock_optimization(C, &quot;eliminate_lock_set_nested&quot;);
2107 #endif
2108                 alock-&gt;set_nested();
2109               }
2110             }
2111           }
2112         } else {
2113 #ifdef ASSERT
2114           alock-&gt;log_lock_optimization(C, &quot;eliminate_lock_NOT_nested_lock_region&quot;);
2115           if (C-&gt;log() != NULL)
2116             alock-&gt;as_Lock()-&gt;is_nested_lock_region(C); // rerun for debugging output
2117 #endif
2118         }
2119       }
2120       return;
2121     }
2122     // Process locks for non escaping object
2123     assert(alock-&gt;is_non_esc_obj(), &quot;&quot;);
2124   } // EliminateNestedLocks
2125 
2126   if (alock-&gt;is_non_esc_obj()) { // Lock is used for non escaping object
2127     // Look for all locks of this object and mark them and
2128     // corresponding BoxLock nodes as eliminated.
2129     Node* obj = alock-&gt;obj_node();
2130     for (uint j = 0; j &lt; obj-&gt;outcnt(); j++) {
2131       Node* o = obj-&gt;raw_out(j);
2132       if (o-&gt;is_AbstractLock() &amp;&amp;
2133           o-&gt;as_AbstractLock()-&gt;obj_node()-&gt;eqv_uncast(obj)) {
2134         alock = o-&gt;as_AbstractLock();
2135         Node* box = alock-&gt;box_node();
2136         // Replace old box node with new eliminated box for all users
2137         // of the same object and mark related locks as eliminated.
2138         mark_eliminated_box(box, obj);
2139       }
2140     }
2141   }
2142 }
2143 
2144 // we have determined that this lock/unlock can be eliminated, we simply
2145 // eliminate the node without expanding it.
2146 //
2147 // Note:  The membar&#39;s associated with the lock/unlock are currently not
2148 //        eliminated.  This should be investigated as a future enhancement.
2149 //
2150 bool PhaseMacroExpand::eliminate_locking_node(AbstractLockNode *alock) {
2151 
2152   if (!alock-&gt;is_eliminated()) {
2153     return false;
2154   }
2155 #ifdef ASSERT
2156   if (!alock-&gt;is_coarsened()) {
2157     // Check that new &quot;eliminated&quot; BoxLock node is created.
2158     BoxLockNode* oldbox = alock-&gt;box_node()-&gt;as_BoxLock();
2159     assert(oldbox-&gt;is_eliminated(), &quot;should be done already&quot;);
2160   }
2161 #endif
2162 
2163   alock-&gt;log_lock_optimization(C, &quot;eliminate_lock&quot;);
2164 
2165 #ifndef PRODUCT
2166   if (PrintEliminateLocks) {
2167     if (alock-&gt;is_Lock()) {
2168       tty-&gt;print_cr(&quot;++++ Eliminated: %d Lock&quot;, alock-&gt;_idx);
2169     } else {
2170       tty-&gt;print_cr(&quot;++++ Eliminated: %d Unlock&quot;, alock-&gt;_idx);
2171     }
2172   }
2173 #endif
2174 
2175   Node* mem  = alock-&gt;in(TypeFunc::Memory);
2176   Node* ctrl = alock-&gt;in(TypeFunc::Control);
2177   guarantee(ctrl != NULL, &quot;missing control projection, cannot replace_node() with NULL&quot;);
2178 
2179   extract_call_projections(alock);
2180   // There are 2 projections from the lock.  The lock node will
2181   // be deleted when its last use is subsumed below.
2182   assert(alock-&gt;outcnt() == 2 &amp;&amp;
2183          _fallthroughproj != NULL &amp;&amp;
2184          _memproj_fallthrough != NULL,
2185          &quot;Unexpected projections from Lock/Unlock&quot;);
2186 
2187   Node* fallthroughproj = _fallthroughproj;
2188   Node* memproj_fallthrough = _memproj_fallthrough;
2189 
2190   // The memory projection from a lock/unlock is RawMem
2191   // The input to a Lock is merged memory, so extract its RawMem input
2192   // (unless the MergeMem has been optimized away.)
2193   if (alock-&gt;is_Lock()) {
2194     // Seach for MemBarAcquireLock node and delete it also.
2195     MemBarNode* membar = fallthroughproj-&gt;unique_ctrl_out()-&gt;as_MemBar();
2196     assert(membar != NULL &amp;&amp; membar-&gt;Opcode() == Op_MemBarAcquireLock, &quot;&quot;);
2197     Node* ctrlproj = membar-&gt;proj_out(TypeFunc::Control);
2198     Node* memproj = membar-&gt;proj_out(TypeFunc::Memory);
2199     _igvn.replace_node(ctrlproj, fallthroughproj);
2200     _igvn.replace_node(memproj, memproj_fallthrough);
2201 
2202     // Delete FastLock node also if this Lock node is unique user
2203     // (a loop peeling may clone a Lock node).
2204     Node* flock = alock-&gt;as_Lock()-&gt;fastlock_node();
2205     if (flock-&gt;outcnt() == 1) {
2206       assert(flock-&gt;unique_out() == alock, &quot;sanity&quot;);
2207       _igvn.replace_node(flock, top());
2208     }
2209   }
2210 
2211   // Seach for MemBarReleaseLock node and delete it also.
2212   if (alock-&gt;is_Unlock() &amp;&amp; ctrl-&gt;is_Proj() &amp;&amp; ctrl-&gt;in(0)-&gt;is_MemBar()) {
2213     MemBarNode* membar = ctrl-&gt;in(0)-&gt;as_MemBar();
2214     assert(membar-&gt;Opcode() == Op_MemBarReleaseLock &amp;&amp;
2215            mem-&gt;is_Proj() &amp;&amp; membar == mem-&gt;in(0), &quot;&quot;);
2216     _igvn.replace_node(fallthroughproj, ctrl);
2217     _igvn.replace_node(memproj_fallthrough, mem);
2218     fallthroughproj = ctrl;
2219     memproj_fallthrough = mem;
2220     ctrl = membar-&gt;in(TypeFunc::Control);
2221     mem  = membar-&gt;in(TypeFunc::Memory);
2222   }
2223 
2224   _igvn.replace_node(fallthroughproj, ctrl);
2225   _igvn.replace_node(memproj_fallthrough, mem);
2226   return true;
2227 }
2228 
2229 
2230 //------------------------------expand_lock_node----------------------
2231 void PhaseMacroExpand::expand_lock_node(LockNode *lock) {
2232 
2233   Node* ctrl = lock-&gt;in(TypeFunc::Control);
2234   Node* mem = lock-&gt;in(TypeFunc::Memory);
2235   Node* obj = lock-&gt;obj_node();
2236   Node* box = lock-&gt;box_node();
2237   Node* flock = lock-&gt;fastlock_node();
2238 
2239   assert(!box-&gt;as_BoxLock()-&gt;is_eliminated(), &quot;sanity&quot;);
2240 
2241   // Make the merge point
2242   Node *region;
2243   Node *mem_phi;
2244   Node *slow_path;
2245 
2246   if (UseOptoBiasInlining) {
2247     /*
2248      *  See the full description in MacroAssembler::biased_locking_enter().
2249      *
2250      *  if( (mark_word &amp; biased_lock_mask) == biased_lock_pattern ) {
2251      *    // The object is biased.
2252      *    proto_node = klass-&gt;prototype_header;
2253      *    o_node = thread | proto_node;
2254      *    x_node = o_node ^ mark_word;
2255      *    if( (x_node &amp; ~age_mask) == 0 ) { // Biased to the current thread ?
2256      *      // Done.
2257      *    } else {
2258      *      if( (x_node &amp; biased_lock_mask) != 0 ) {
2259      *        // The klass&#39;s prototype header is no longer biased.
2260      *        cas(&amp;mark_word, mark_word, proto_node)
2261      *        goto cas_lock;
2262      *      } else {
2263      *        // The klass&#39;s prototype header is still biased.
2264      *        if( (x_node &amp; epoch_mask) != 0 ) { // Expired epoch?
2265      *          old = mark_word;
2266      *          new = o_node;
2267      *        } else {
2268      *          // Different thread or anonymous biased.
2269      *          old = mark_word &amp; (epoch_mask | age_mask | biased_lock_mask);
2270      *          new = thread | old;
2271      *        }
2272      *        // Try to rebias.
2273      *        if( cas(&amp;mark_word, old, new) == 0 ) {
2274      *          // Done.
2275      *        } else {
2276      *          goto slow_path; // Failed.
2277      *        }
2278      *      }
2279      *    }
2280      *  } else {
2281      *    // The object is not biased.
2282      *    cas_lock:
2283      *    if( FastLock(obj) == 0 ) {
2284      *      // Done.
2285      *    } else {
2286      *      slow_path:
2287      *      OptoRuntime::complete_monitor_locking_Java(obj);
2288      *    }
2289      *  }
2290      */
2291 
2292     region  = new RegionNode(5);
2293     // create a Phi for the memory state
2294     mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);
2295 
2296     Node* fast_lock_region  = new RegionNode(3);
2297     Node* fast_lock_mem_phi = new PhiNode( fast_lock_region, Type::MEMORY, TypeRawPtr::BOTTOM);
2298 
2299     // First, check mark word for the biased lock pattern.
2300     Node* mark_node = make_load(ctrl, mem, obj, oopDesc::mark_offset_in_bytes(), TypeX_X, TypeX_X-&gt;basic_type());
2301 
2302     // Get fast path - mark word has the biased lock pattern.
2303     ctrl = opt_bits_test(ctrl, fast_lock_region, 1, mark_node,
<a name="50" id="anc50"></a><span class="line-modified">2304                          markWord::biased_lock_mask_in_place,</span>
<span class="line-modified">2305                          markWord::biased_lock_pattern, true);</span>
2306     // fast_lock_region-&gt;in(1) is set to slow path.
2307     fast_lock_mem_phi-&gt;init_req(1, mem);
2308 
2309     // Now check that the lock is biased to the current thread and has
2310     // the same epoch and bias as Klass::_prototype_header.
2311 
2312     // Special-case a fresh allocation to avoid building nodes:
2313     Node* klass_node = AllocateNode::Ideal_klass(obj, &amp;_igvn);
2314     if (klass_node == NULL) {
2315       Node* k_adr = basic_plus_adr(obj, oopDesc::klass_offset_in_bytes());
2316       klass_node = transform_later(LoadKlassNode::make(_igvn, NULL, mem, k_adr, _igvn.type(k_adr)-&gt;is_ptr()));
2317 #ifdef _LP64
2318       if (UseCompressedClassPointers &amp;&amp; klass_node-&gt;is_DecodeNKlass()) {
2319         assert(klass_node-&gt;in(1)-&gt;Opcode() == Op_LoadNKlass, &quot;sanity&quot;);
2320         klass_node-&gt;in(1)-&gt;init_req(0, ctrl);
2321       } else
2322 #endif
2323       klass_node-&gt;init_req(0, ctrl);
2324     }
2325     Node *proto_node = make_load(ctrl, mem, klass_node, in_bytes(Klass::prototype_header_offset()), TypeX_X, TypeX_X-&gt;basic_type());
2326 
2327     Node* thread = transform_later(new ThreadLocalNode());
2328     Node* cast_thread = transform_later(new CastP2XNode(ctrl, thread));
2329     Node* o_node = transform_later(new OrXNode(cast_thread, proto_node));
2330     Node* x_node = transform_later(new XorXNode(o_node, mark_node));
2331 
2332     // Get slow path - mark word does NOT match the value.
<a name="51" id="anc51"></a><span class="line-added">2333     STATIC_ASSERT(markWord::age_mask_in_place &lt;= INT_MAX);</span>
2334     Node* not_biased_ctrl =  opt_bits_test(ctrl, region, 3, x_node,
<a name="52" id="anc52"></a><span class="line-modified">2335                                       (~(int)markWord::age_mask_in_place), 0);</span>
2336     // region-&gt;in(3) is set to fast path - the object is biased to the current thread.
2337     mem_phi-&gt;init_req(3, mem);
2338 
2339 
2340     // Mark word does NOT match the value (thread | Klass::_prototype_header).
2341 
2342 
2343     // First, check biased pattern.
2344     // Get fast path - _prototype_header has the same biased lock pattern.
2345     ctrl =  opt_bits_test(not_biased_ctrl, fast_lock_region, 2, x_node,
<a name="53" id="anc53"></a><span class="line-modified">2346                           markWord::biased_lock_mask_in_place, 0, true);</span>
2347 
2348     not_biased_ctrl = fast_lock_region-&gt;in(2); // Slow path
2349     // fast_lock_region-&gt;in(2) - the prototype header is no longer biased
2350     // and we have to revoke the bias on this object.
2351     // We are going to try to reset the mark of this object to the prototype
2352     // value and fall through to the CAS-based locking scheme.
2353     Node* adr = basic_plus_adr(obj, oopDesc::mark_offset_in_bytes());
2354     Node* cas = new StoreXConditionalNode(not_biased_ctrl, mem, adr,
2355                                           proto_node, mark_node);
2356     transform_later(cas);
2357     Node* proj = transform_later(new SCMemProjNode(cas));
2358     fast_lock_mem_phi-&gt;init_req(2, proj);
2359 
2360 
2361     // Second, check epoch bits.
2362     Node* rebiased_region  = new RegionNode(3);
2363     Node* old_phi = new PhiNode( rebiased_region, TypeX_X);
2364     Node* new_phi = new PhiNode( rebiased_region, TypeX_X);
2365 
2366     // Get slow path - mark word does NOT match epoch bits.
2367     Node* epoch_ctrl =  opt_bits_test(ctrl, rebiased_region, 1, x_node,
<a name="54" id="anc54"></a><span class="line-modified">2368                                       markWord::epoch_mask_in_place, 0);</span>
2369     // The epoch of the current bias is not valid, attempt to rebias the object
2370     // toward the current thread.
2371     rebiased_region-&gt;init_req(2, epoch_ctrl);
2372     old_phi-&gt;init_req(2, mark_node);
2373     new_phi-&gt;init_req(2, o_node);
2374 
2375     // rebiased_region-&gt;in(1) is set to fast path.
2376     // The epoch of the current bias is still valid but we know
2377     // nothing about the owner; it might be set or it might be clear.
<a name="55" id="anc55"></a><span class="line-modified">2378     Node* cmask   = MakeConX(markWord::biased_lock_mask_in_place |</span>
<span class="line-modified">2379                              markWord::age_mask_in_place |</span>
<span class="line-modified">2380                              markWord::epoch_mask_in_place);</span>
2381     Node* old = transform_later(new AndXNode(mark_node, cmask));
2382     cast_thread = transform_later(new CastP2XNode(ctrl, thread));
2383     Node* new_mark = transform_later(new OrXNode(cast_thread, old));
2384     old_phi-&gt;init_req(1, old);
2385     new_phi-&gt;init_req(1, new_mark);
2386 
2387     transform_later(rebiased_region);
2388     transform_later(old_phi);
2389     transform_later(new_phi);
2390 
2391     // Try to acquire the bias of the object using an atomic operation.
2392     // If this fails we will go in to the runtime to revoke the object&#39;s bias.
2393     cas = new StoreXConditionalNode(rebiased_region, mem, adr, new_phi, old_phi);
2394     transform_later(cas);
2395     proj = transform_later(new SCMemProjNode(cas));
2396 
2397     // Get slow path - Failed to CAS.
2398     not_biased_ctrl = opt_bits_test(rebiased_region, region, 4, cas, 0, 0);
2399     mem_phi-&gt;init_req(4, proj);
2400     // region-&gt;in(4) is set to fast path - the object is rebiased to the current thread.
2401 
2402     // Failed to CAS.
2403     slow_path  = new RegionNode(3);
2404     Node *slow_mem = new PhiNode( slow_path, Type::MEMORY, TypeRawPtr::BOTTOM);
2405 
2406     slow_path-&gt;init_req(1, not_biased_ctrl); // Capture slow-control
2407     slow_mem-&gt;init_req(1, proj);
2408 
2409     // Call CAS-based locking scheme (FastLock node).
2410 
2411     transform_later(fast_lock_region);
2412     transform_later(fast_lock_mem_phi);
2413 
2414     // Get slow path - FastLock failed to lock the object.
2415     ctrl = opt_bits_test(fast_lock_region, region, 2, flock, 0, 0);
2416     mem_phi-&gt;init_req(2, fast_lock_mem_phi);
2417     // region-&gt;in(2) is set to fast path - the object is locked to the current thread.
2418 
2419     slow_path-&gt;init_req(2, ctrl); // Capture slow-control
2420     slow_mem-&gt;init_req(2, fast_lock_mem_phi);
2421 
2422     transform_later(slow_path);
2423     transform_later(slow_mem);
2424     // Reset lock&#39;s memory edge.
2425     lock-&gt;set_req(TypeFunc::Memory, slow_mem);
2426 
2427   } else {
2428     region  = new RegionNode(3);
2429     // create a Phi for the memory state
2430     mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);
2431 
2432     // Optimize test; set region slot 2
2433     slow_path = opt_bits_test(ctrl, region, 2, flock, 0, 0);
2434     mem_phi-&gt;init_req(2, mem);
2435   }
2436 
2437   // Make slow path call
2438   CallNode *call = make_slow_call((CallNode *) lock, OptoRuntime::complete_monitor_enter_Type(),
2439                                   OptoRuntime::complete_monitor_locking_Java(), NULL, slow_path,
2440                                   obj, box, NULL);
2441 
2442   extract_call_projections(call);
2443 
2444   // Slow path can only throw asynchronous exceptions, which are always
2445   // de-opted.  So the compiler thinks the slow-call can never throw an
2446   // exception.  If it DOES throw an exception we would need the debug
2447   // info removed first (since if it throws there is no monitor).
2448   assert ( _ioproj_fallthrough == NULL &amp;&amp; _ioproj_catchall == NULL &amp;&amp;
2449            _memproj_catchall == NULL &amp;&amp; _catchallcatchproj == NULL, &quot;Unexpected projection from Lock&quot;);
2450 
2451   // Capture slow path
2452   // disconnect fall-through projection from call and create a new one
2453   // hook up users of fall-through projection to region
2454   Node *slow_ctrl = _fallthroughproj-&gt;clone();
2455   transform_later(slow_ctrl);
2456   _igvn.hash_delete(_fallthroughproj);
2457   _fallthroughproj-&gt;disconnect_inputs(NULL, C);
2458   region-&gt;init_req(1, slow_ctrl);
2459   // region inputs are now complete
2460   transform_later(region);
2461   _igvn.replace_node(_fallthroughproj, region);
2462 
2463   Node *memproj = transform_later(new ProjNode(call, TypeFunc::Memory));
2464   mem_phi-&gt;init_req(1, memproj );
2465   transform_later(mem_phi);
2466   _igvn.replace_node(_memproj_fallthrough, mem_phi);
2467 }
2468 
2469 //------------------------------expand_unlock_node----------------------
2470 void PhaseMacroExpand::expand_unlock_node(UnlockNode *unlock) {
2471 
2472   Node* ctrl = unlock-&gt;in(TypeFunc::Control);
2473   Node* mem = unlock-&gt;in(TypeFunc::Memory);
2474   Node* obj = unlock-&gt;obj_node();
2475   Node* box = unlock-&gt;box_node();
2476 
2477   assert(!box-&gt;as_BoxLock()-&gt;is_eliminated(), &quot;sanity&quot;);
2478 
2479   // No need for a null check on unlock
2480 
2481   // Make the merge point
2482   Node *region;
2483   Node *mem_phi;
2484 
2485   if (UseOptoBiasInlining) {
2486     // Check for biased locking unlock case, which is a no-op.
2487     // See the full description in MacroAssembler::biased_locking_exit().
2488     region  = new RegionNode(4);
2489     // create a Phi for the memory state
2490     mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);
2491     mem_phi-&gt;init_req(3, mem);
2492 
2493     Node* mark_node = make_load(ctrl, mem, obj, oopDesc::mark_offset_in_bytes(), TypeX_X, TypeX_X-&gt;basic_type());
2494     ctrl = opt_bits_test(ctrl, region, 3, mark_node,
<a name="56" id="anc56"></a><span class="line-modified">2495                          markWord::biased_lock_mask_in_place,</span>
<span class="line-modified">2496                          markWord::biased_lock_pattern);</span>
2497   } else {
2498     region  = new RegionNode(3);
2499     // create a Phi for the memory state
2500     mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);
2501   }
2502 
2503   FastUnlockNode *funlock = new FastUnlockNode( ctrl, obj, box );
2504   funlock = transform_later( funlock )-&gt;as_FastUnlock();
2505   // Optimize test; set region slot 2
2506   Node *slow_path = opt_bits_test(ctrl, region, 2, funlock, 0, 0);
2507   Node *thread = transform_later(new ThreadLocalNode());
2508 
2509   CallNode *call = make_slow_call((CallNode *) unlock, OptoRuntime::complete_monitor_exit_Type(),
2510                                   CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_unlocking_C),
2511                                   &quot;complete_monitor_unlocking_C&quot;, slow_path, obj, box, thread);
2512 
2513   extract_call_projections(call);
2514 
2515   assert ( _ioproj_fallthrough == NULL &amp;&amp; _ioproj_catchall == NULL &amp;&amp;
2516            _memproj_catchall == NULL &amp;&amp; _catchallcatchproj == NULL, &quot;Unexpected projection from Lock&quot;);
2517 
2518   // No exceptions for unlocking
2519   // Capture slow path
2520   // disconnect fall-through projection from call and create a new one
2521   // hook up users of fall-through projection to region
2522   Node *slow_ctrl = _fallthroughproj-&gt;clone();
2523   transform_later(slow_ctrl);
2524   _igvn.hash_delete(_fallthroughproj);
2525   _fallthroughproj-&gt;disconnect_inputs(NULL, C);
2526   region-&gt;init_req(1, slow_ctrl);
2527   // region inputs are now complete
2528   transform_later(region);
2529   _igvn.replace_node(_fallthroughproj, region);
2530 
2531   Node *memproj = transform_later(new ProjNode(call, TypeFunc::Memory) );
2532   mem_phi-&gt;init_req(1, memproj );
2533   mem_phi-&gt;init_req(2, mem);
2534   transform_later(mem_phi);
2535   _igvn.replace_node(_memproj_fallthrough, mem_phi);
2536 }
2537 
<a name="57" id="anc57"></a><span class="line-added">2538 void PhaseMacroExpand::expand_subtypecheck_node(SubTypeCheckNode *check) {</span>
<span class="line-added">2539   assert(check-&gt;in(SubTypeCheckNode::Control) == NULL, &quot;should be pinned&quot;);</span>
<span class="line-added">2540   Node* bol = check-&gt;unique_out();</span>
<span class="line-added">2541   Node* obj_or_subklass = check-&gt;in(SubTypeCheckNode::ObjOrSubKlass);</span>
<span class="line-added">2542   Node* superklass = check-&gt;in(SubTypeCheckNode::SuperKlass);</span>
<span class="line-added">2543   assert(bol-&gt;is_Bool() &amp;&amp; bol-&gt;as_Bool()-&gt;_test._test == BoolTest::ne, &quot;unexpected bool node&quot;);</span>
<span class="line-added">2544 </span>
<span class="line-added">2545   for (DUIterator_Last imin, i = bol-&gt;last_outs(imin); i &gt;= imin; --i) {</span>
<span class="line-added">2546     Node* iff = bol-&gt;last_out(i);</span>
<span class="line-added">2547     assert(iff-&gt;is_If(), &quot;where&#39;s the if?&quot;);</span>
<span class="line-added">2548 </span>
<span class="line-added">2549     if (iff-&gt;in(0)-&gt;is_top()) {</span>
<span class="line-added">2550       _igvn.replace_input_of(iff, 1, C-&gt;top());</span>
<span class="line-added">2551       continue;</span>
<span class="line-added">2552     }</span>
<span class="line-added">2553 </span>
<span class="line-added">2554     Node* iftrue = iff-&gt;as_If()-&gt;proj_out(1);</span>
<span class="line-added">2555     Node* iffalse = iff-&gt;as_If()-&gt;proj_out(0);</span>
<span class="line-added">2556     Node* ctrl = iff-&gt;in(0);</span>
<span class="line-added">2557 </span>
<span class="line-added">2558     Node* subklass = NULL;</span>
<span class="line-added">2559     if (_igvn.type(obj_or_subklass)-&gt;isa_klassptr()) {</span>
<span class="line-added">2560       subklass = obj_or_subklass;</span>
<span class="line-added">2561     } else {</span>
<span class="line-added">2562       Node* k_adr = basic_plus_adr(obj_or_subklass, oopDesc::klass_offset_in_bytes());</span>
<span class="line-added">2563       subklass = _igvn.transform(LoadKlassNode::make(_igvn, NULL, C-&gt;immutable_memory(), k_adr, TypeInstPtr::KLASS));</span>
<span class="line-added">2564     }</span>
<span class="line-added">2565 </span>
<span class="line-added">2566     Node* not_subtype_ctrl = Phase::gen_subtype_check(subklass, superklass, &amp;ctrl, NULL, _igvn);</span>
<span class="line-added">2567 </span>
<span class="line-added">2568     _igvn.replace_input_of(iff, 0, C-&gt;top());</span>
<span class="line-added">2569     _igvn.replace_node(iftrue, not_subtype_ctrl);</span>
<span class="line-added">2570     _igvn.replace_node(iffalse, ctrl);</span>
<span class="line-added">2571   }</span>
<span class="line-added">2572   _igvn.replace_node(check, C-&gt;top());</span>
<span class="line-added">2573 }</span>
<span class="line-added">2574 </span>
2575 //---------------------------eliminate_macro_nodes----------------------
2576 // Eliminate scalar replaced allocations and associated locks.
2577 void PhaseMacroExpand::eliminate_macro_nodes() {
2578   if (C-&gt;macro_count() == 0)
2579     return;
2580 
2581   // First, attempt to eliminate locks
2582   int cnt = C-&gt;macro_count();
2583   for (int i=0; i &lt; cnt; i++) {
2584     Node *n = C-&gt;macro_node(i);
2585     if (n-&gt;is_AbstractLock()) { // Lock and Unlock nodes
2586       // Before elimination mark all associated (same box and obj)
2587       // lock and unlock nodes.
2588       mark_eliminated_locking_nodes(n-&gt;as_AbstractLock());
2589     }
2590   }
2591   bool progress = true;
2592   while (progress) {
2593     progress = false;
2594     for (int i = C-&gt;macro_count(); i &gt; 0; i--) {
2595       Node * n = C-&gt;macro_node(i-1);
2596       bool success = false;
2597       debug_only(int old_macro_count = C-&gt;macro_count(););
2598       if (n-&gt;is_AbstractLock()) {
2599         success = eliminate_locking_node(n-&gt;as_AbstractLock());
2600       }
2601       assert(success == (C-&gt;macro_count() &lt; old_macro_count), &quot;elimination reduces macro count&quot;);
2602       progress = progress || success;
2603     }
2604   }
2605   // Next, attempt to eliminate allocations
2606   _has_locks = false;
2607   progress = true;
2608   while (progress) {
2609     progress = false;
2610     for (int i = C-&gt;macro_count(); i &gt; 0; i--) {
2611       Node * n = C-&gt;macro_node(i-1);
2612       bool success = false;
2613       debug_only(int old_macro_count = C-&gt;macro_count(););
2614       switch (n-&gt;class_id()) {
2615       case Node::Class_Allocate:
2616       case Node::Class_AllocateArray:
2617         success = eliminate_allocate_node(n-&gt;as_Allocate());
2618         break;
2619       case Node::Class_CallStaticJava:
2620         success = eliminate_boxing_node(n-&gt;as_CallStaticJava());
2621         break;
2622       case Node::Class_Lock:
2623       case Node::Class_Unlock:
2624         assert(!n-&gt;as_AbstractLock()-&gt;is_eliminated(), &quot;sanity&quot;);
2625         _has_locks = true;
2626         break;
2627       case Node::Class_ArrayCopy:
2628         break;
2629       case Node::Class_OuterStripMinedLoop:
2630         break;
<a name="58" id="anc58"></a><span class="line-added">2631       case Node::Class_SubTypeCheck:</span>
<span class="line-added">2632         break;</span>
2633       default:
2634         assert(n-&gt;Opcode() == Op_LoopLimit ||
2635                n-&gt;Opcode() == Op_Opaque1   ||
2636                n-&gt;Opcode() == Op_Opaque2   ||
2637                n-&gt;Opcode() == Op_Opaque3   ||
2638                BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;is_gc_barrier_node(n),
2639                &quot;unknown node type in macro list&quot;);
2640       }
2641       assert(success == (C-&gt;macro_count() &lt; old_macro_count), &quot;elimination reduces macro count&quot;);
2642       progress = progress || success;
2643     }
2644   }
2645 }
2646 
2647 //------------------------------expand_macro_nodes----------------------
2648 //  Returns true if a failure occurred.
2649 bool PhaseMacroExpand::expand_macro_nodes() {
2650   // Last attempt to eliminate macro nodes.
2651   eliminate_macro_nodes();
2652 
2653   // Make sure expansion will not cause node limit to be exceeded.
2654   // Worst case is a macro node gets expanded into about 200 nodes.
2655   // Allow 50% more for optimization.
2656   if (C-&gt;check_node_count(C-&gt;macro_count() * 300, &quot;out of nodes before macro expansion&quot; ) )
2657     return true;
2658 
2659   // Eliminate Opaque and LoopLimit nodes. Do it after all loop optimizations.
2660   bool progress = true;
2661   while (progress) {
2662     progress = false;
2663     for (int i = C-&gt;macro_count(); i &gt; 0; i--) {
<a name="59" id="anc59"></a><span class="line-modified">2664       Node* n = C-&gt;macro_node(i-1);</span>
2665       bool success = false;
2666       debug_only(int old_macro_count = C-&gt;macro_count(););
2667       if (n-&gt;Opcode() == Op_LoopLimit) {
2668         // Remove it from macro list and put on IGVN worklist to optimize.
2669         C-&gt;remove_macro_node(n);
2670         _igvn._worklist.push(n);
2671         success = true;
2672       } else if (n-&gt;Opcode() == Op_CallStaticJava) {
2673         // Remove it from macro list and put on IGVN worklist to optimize.
2674         C-&gt;remove_macro_node(n);
2675         _igvn._worklist.push(n);
2676         success = true;
2677       } else if (n-&gt;Opcode() == Op_Opaque1 || n-&gt;Opcode() == Op_Opaque2) {
2678         _igvn.replace_node(n, n-&gt;in(1));
2679         success = true;
2680 #if INCLUDE_RTM_OPT
2681       } else if ((n-&gt;Opcode() == Op_Opaque3) &amp;&amp; ((Opaque3Node*)n)-&gt;rtm_opt()) {
2682         assert(C-&gt;profile_rtm(), &quot;should be used only in rtm deoptimization code&quot;);
2683         assert((n-&gt;outcnt() == 1) &amp;&amp; n-&gt;unique_out()-&gt;is_Cmp(), &quot;&quot;);
2684         Node* cmp = n-&gt;unique_out();
2685 #ifdef ASSERT
2686         // Validate graph.
2687         assert((cmp-&gt;outcnt() == 1) &amp;&amp; cmp-&gt;unique_out()-&gt;is_Bool(), &quot;&quot;);
2688         BoolNode* bol = cmp-&gt;unique_out()-&gt;as_Bool();
2689         assert((bol-&gt;outcnt() == 1) &amp;&amp; bol-&gt;unique_out()-&gt;is_If() &amp;&amp;
2690                (bol-&gt;_test._test == BoolTest::ne), &quot;&quot;);
2691         IfNode* ifn = bol-&gt;unique_out()-&gt;as_If();
2692         assert((ifn-&gt;outcnt() == 2) &amp;&amp;
2693                ifn-&gt;proj_out(1)-&gt;is_uncommon_trap_proj(Deoptimization::Reason_rtm_state_change) != NULL, &quot;&quot;);
2694 #endif
2695         Node* repl = n-&gt;in(1);
2696         if (!_has_locks) {
2697           // Remove RTM state check if there are no locks in the code.
2698           // Replace input to compare the same value.
2699           repl = (cmp-&gt;in(1) == n) ? cmp-&gt;in(2) : cmp-&gt;in(1);
2700         }
2701         _igvn.replace_node(n, repl);
2702         success = true;
2703 #endif
2704       } else if (n-&gt;Opcode() == Op_OuterStripMinedLoop) {
2705         n-&gt;as_OuterStripMinedLoop()-&gt;adjust_strip_mined_loop(&amp;_igvn);
2706         C-&gt;remove_macro_node(n);
2707         success = true;
2708       }
<a name="60" id="anc60"></a><span class="line-modified">2709       assert(!success || (C-&gt;macro_count() == (old_macro_count - 1)), &quot;elimination must have deleted one node from macro list&quot;);</span>
2710       progress = progress || success;
2711     }
2712   }
2713 
2714   // expand arraycopy &quot;macro&quot; nodes first
2715   // For ReduceBulkZeroing, we must first process all arraycopy nodes
2716   // before the allocate nodes are expanded.
<a name="61" id="anc61"></a><span class="line-modified">2717   for (int i = C-&gt;macro_count(); i &gt; 0; i--) {</span>
<span class="line-modified">2718     Node* n = C-&gt;macro_node(i-1);</span>

2719     assert(n-&gt;is_macro(), &quot;only macro nodes expected here&quot;);
2720     if (_igvn.type(n) == Type::TOP || (n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_top())) {
2721       // node is unreachable, so don&#39;t try to expand it
2722       C-&gt;remove_macro_node(n);
<a name="62" id="anc62"></a><span class="line-modified">2723       continue;</span>
<span class="line-modified">2724     }</span>
<span class="line-added">2725     debug_only(int old_macro_count = C-&gt;macro_count(););</span>
<span class="line-added">2726     switch (n-&gt;class_id()) {</span>
<span class="line-added">2727     case Node::Class_Lock:</span>
<span class="line-added">2728       expand_lock_node(n-&gt;as_Lock());</span>
<span class="line-added">2729       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);</span>
<span class="line-added">2730       break;</span>
<span class="line-added">2731     case Node::Class_Unlock:</span>
<span class="line-added">2732       expand_unlock_node(n-&gt;as_Unlock());</span>
<span class="line-added">2733       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);</span>
<span class="line-added">2734       break;</span>
<span class="line-added">2735     case Node::Class_ArrayCopy:</span>
2736       expand_arraycopy_node(n-&gt;as_ArrayCopy());
<a name="63" id="anc63"></a><span class="line-modified">2737       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);</span>
<span class="line-added">2738       break;</span>
<span class="line-added">2739     case Node::Class_SubTypeCheck:</span>
<span class="line-added">2740       expand_subtypecheck_node(n-&gt;as_SubTypeCheck());</span>
<span class="line-added">2741       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);</span>
<span class="line-added">2742       break;</span>
2743     }
2744     if (C-&gt;failing())  return true;
<a name="64" id="anc64"></a>
2745   }
2746 
<a name="65" id="anc65"></a><span class="line-added">2747   // All nodes except Allocate nodes are expanded now. There could be</span>
<span class="line-added">2748   // new optimization opportunities (such as folding newly created</span>
<span class="line-added">2749   // load from a just allocated object). Run IGVN.</span>
<span class="line-added">2750   _igvn.set_delay_transform(false);</span>
<span class="line-added">2751   _igvn.optimize();</span>
<span class="line-added">2752   if (C-&gt;failing())  return true;</span>
<span class="line-added">2753 </span>
<span class="line-added">2754   _igvn.set_delay_transform(true);</span>
<span class="line-added">2755 </span>
2756   // expand &quot;macro&quot; nodes
2757   // nodes are removed from the macro list as they are processed
2758   while (C-&gt;macro_count() &gt; 0) {
2759     int macro_count = C-&gt;macro_count();
2760     Node * n = C-&gt;macro_node(macro_count-1);
2761     assert(n-&gt;is_macro(), &quot;only macro nodes expected here&quot;);
2762     if (_igvn.type(n) == Type::TOP || (n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_top())) {
2763       // node is unreachable, so don&#39;t try to expand it
2764       C-&gt;remove_macro_node(n);
2765       continue;
2766     }
2767     switch (n-&gt;class_id()) {
2768     case Node::Class_Allocate:
2769       expand_allocate(n-&gt;as_Allocate());
2770       break;
2771     case Node::Class_AllocateArray:
2772       expand_allocate_array(n-&gt;as_AllocateArray());
2773       break;
<a name="66" id="anc66"></a>





2774     default:
2775       assert(false, &quot;unknown node type in macro list&quot;);
2776     }
2777     assert(C-&gt;macro_count() &lt; macro_count, &quot;must have deleted a node from macro list&quot;);
2778     if (C-&gt;failing())  return true;
2779   }
2780 
2781   _igvn.set_delay_transform(false);
2782   _igvn.optimize();
2783   if (C-&gt;failing())  return true;
2784   return false;
2785 }
<a name="67" id="anc67"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="67" type="hidden" />
</body>
</html>
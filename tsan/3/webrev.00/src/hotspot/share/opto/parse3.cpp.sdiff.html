<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/parse3.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="parse2.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="parseHelper.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/parse3.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;compiler/compileLog.hpp&quot;
 27 #include &quot;interpreter/linkResolver.hpp&quot;
 28 #include &quot;memory/universe.hpp&quot;
 29 #include &quot;oops/objArrayKlass.hpp&quot;
 30 #include &quot;opto/addnode.hpp&quot;
 31 #include &quot;opto/castnode.hpp&quot;
 32 #include &quot;opto/memnode.hpp&quot;
 33 #include &quot;opto/parse.hpp&quot;
 34 #include &quot;opto/rootnode.hpp&quot;
 35 #include &quot;opto/runtime.hpp&quot;
 36 #include &quot;opto/subnode.hpp&quot;
 37 #include &quot;runtime/deoptimization.hpp&quot;
 38 #include &quot;runtime/handles.inline.hpp&quot;
 39 
 40 //=============================================================================
 41 // Helper methods for _get* and _put* bytecodes
 42 //=============================================================================
<span class="line-removed"> 43 bool Parse::static_field_ok_in_clinit(ciField *field, ciMethod *method) {</span>
<span class="line-removed"> 44   // Could be the field_holder&#39;s &lt;clinit&gt; method, or &lt;clinit&gt; for a subklass.</span>
<span class="line-removed"> 45   // Better to check now than to Deoptimize as soon as we execute</span>
<span class="line-removed"> 46   assert( field-&gt;is_static(), &quot;Only check if field is static&quot;);</span>
<span class="line-removed"> 47   // is_being_initialized() is too generous.  It allows access to statics</span>
<span class="line-removed"> 48   // by threads that are not running the &lt;clinit&gt; before the &lt;clinit&gt; finishes.</span>
<span class="line-removed"> 49   // return field-&gt;holder()-&gt;is_being_initialized();</span>
<span class="line-removed"> 50 </span>
<span class="line-removed"> 51   // The following restriction is correct but conservative.</span>
<span class="line-removed"> 52   // It is also desirable to allow compilation of methods called from &lt;clinit&gt;</span>
<span class="line-removed"> 53   // but this generated code will need to be made safe for execution by</span>
<span class="line-removed"> 54   // other threads, or the transition from interpreted to compiled code would</span>
<span class="line-removed"> 55   // need to be guarded.</span>
<span class="line-removed"> 56   ciInstanceKlass *field_holder = field-&gt;holder();</span>
<span class="line-removed"> 57 </span>
<span class="line-removed"> 58   if (method-&gt;holder()-&gt;is_subclass_of(field_holder)) {</span>
<span class="line-removed"> 59     if (method-&gt;is_static_initializer()) {</span>
<span class="line-removed"> 60       // OK to access static fields inside initializer</span>
<span class="line-removed"> 61       return true;</span>
<span class="line-removed"> 62     } else if (method-&gt;is_object_initializer()) {</span>
<span class="line-removed"> 63       // It&#39;s also OK to access static fields inside a constructor,</span>
<span class="line-removed"> 64       // because any thread calling the constructor must first have</span>
<span class="line-removed"> 65       // synchronized on the class by executing a &#39;_new&#39; bytecode.</span>
<span class="line-removed"> 66       return true;</span>
<span class="line-removed"> 67     }</span>
<span class="line-removed"> 68   }</span>
<span class="line-removed"> 69   if (C-&gt;is_compiling_clinit_for(field_holder)) {</span>
<span class="line-removed"> 70     return true; // access in the context of static initializer</span>
<span class="line-removed"> 71   }</span>
<span class="line-removed"> 72   return false;</span>
<span class="line-removed"> 73 }</span>
<span class="line-removed"> 74 </span>
<span class="line-removed"> 75 </span>
 76 void Parse::do_field_access(bool is_get, bool is_field) {
 77   bool will_link;
 78   ciField* field = iter().get_field(will_link);
 79   assert(will_link, &quot;getfield: typeflow responsibility&quot;);
 80 
 81   ciInstanceKlass* field_holder = field-&gt;holder();
 82 
 83   if (is_field == field-&gt;is_static()) {
 84     // Interpreter will throw java_lang_IncompatibleClassChangeError
 85     // Check this before allowing &lt;clinit&gt; methods to access static fields
 86     uncommon_trap(Deoptimization::Reason_unhandled,
 87                   Deoptimization::Action_none);
 88     return;
 89   }
 90 
<span class="line-modified"> 91   if (!is_field &amp;&amp; !field_holder-&gt;is_initialized()) {</span>
<span class="line-modified"> 92     if (!static_field_ok_in_clinit(field, method())) {</span>
<span class="line-modified"> 93       uncommon_trap(Deoptimization::Reason_uninitialized,</span>
<span class="line-removed"> 94                     Deoptimization::Action_reinterpret,</span>
<span class="line-removed"> 95                     NULL, &quot;!static_field_ok_in_clinit&quot;);</span>
<span class="line-removed"> 96       return;</span>
<span class="line-removed"> 97     }</span>
<span class="line-removed"> 98   }</span>
<span class="line-removed"> 99 </span>
<span class="line-removed">100   // Deoptimize on putfield writes to call site target field.</span>
<span class="line-removed">101   if (!is_get &amp;&amp; field-&gt;is_call_site_target()) {</span>
102     uncommon_trap(Deoptimization::Reason_unhandled,
103                   Deoptimization::Action_reinterpret,
104                   NULL, &quot;put to call site target field&quot;);
105     return;
106   }
107 





108   assert(field-&gt;will_link(method(), bc()), &quot;getfield: typeflow responsibility&quot;);
109 
110   // Note:  We do not check for an unloaded field type here any more.
111 
112   // Generate code for the object pointer.
113   Node* obj;
114   if (is_field) {
115     int obj_depth = is_get ? 0 : field-&gt;type()-&gt;size();
116     obj = null_check(peek(obj_depth));
117     // Compile-time detect of null-exception?
118     if (stopped())  return;
119 
120 #ifdef ASSERT
121     const TypeInstPtr *tjp = TypeInstPtr::make(TypePtr::NotNull, iter().get_declared_field_holder());
122     assert(_gvn.type(obj)-&gt;higher_equal(tjp), &quot;cast_up is no longer needed&quot;);
123 #endif
124 
125     if (is_get) {
126       (void) pop();  // pop receiver before getting
127       do_get_xxx(obj, field, is_field);
</pre>
<hr />
<pre>
159       return;
160     }
161   }
162 
163   ciType* field_klass = field-&gt;type();
164   bool is_vol = field-&gt;is_volatile();
165 
166   // Compute address and memory type.
167   int offset = field-&gt;offset_in_bytes();
168   const TypePtr* adr_type = C-&gt;alias_type(field)-&gt;adr_type();
169   Node *adr = basic_plus_adr(obj, obj, offset);
170 
171   // Build the resultant type of the load
172   const Type *type;
173 
174   bool must_assert_null = false;
175 
176   DecoratorSet decorators = IN_HEAP;
177   decorators |= is_vol ? MO_SEQ_CST : MO_UNORDERED;
178 
<span class="line-modified">179   bool is_obj = bt == T_OBJECT || bt == T_ARRAY;</span>
180 
181   if (is_obj) {
182     if (!field-&gt;type()-&gt;is_loaded()) {
183       type = TypeInstPtr::BOTTOM;
184       must_assert_null = true;
185     } else if (field-&gt;is_static_constant()) {
186       // This can happen if the constant oop is non-perm.
187       ciObject* con = field-&gt;constant_value().as_object();
188       // Do not &quot;join&quot; in the previous type; it doesn&#39;t add value,
189       // and may yield a vacuous result if the field is of interface type.
190       if (con-&gt;is_null_object()) {
191         type = TypePtr::NULL_PTR;
192       } else {
193         type = TypeOopPtr::make_from_constant(con)-&gt;isa_oopptr();
194       }
195       assert(type != NULL, &quot;field singleton type must be consistent&quot;);
196     } else {
197       type = TypeOopPtr::make_from_klass(field_klass-&gt;as_klass());
198     }
199   } else {
</pre>
<hr />
<pre>
230     set_bci(iter().next_bci());
231     null_assert(peek());
232     set_bci(iter().cur_bci()); // put it back
233   }
234 }
235 
236 void Parse::do_put_xxx(Node* obj, ciField* field, bool is_field) {
237   bool is_vol = field-&gt;is_volatile();
238 
239   // Compute address and memory type.
240   int offset = field-&gt;offset_in_bytes();
241   const TypePtr* adr_type = C-&gt;alias_type(field)-&gt;adr_type();
242   Node* adr = basic_plus_adr(obj, obj, offset);
243   BasicType bt = field-&gt;layout_type();
244   // Value to be stored
245   Node* val = type2size[bt] == 1 ? pop() : pop_pair();
246 
247   DecoratorSet decorators = IN_HEAP;
248   decorators |= is_vol ? MO_SEQ_CST : MO_UNORDERED;
249 
<span class="line-modified">250   bool is_obj = bt == T_OBJECT || bt == T_ARRAY;</span>
251 
252   // Store the value.
253   const Type* field_type;
254   if (!field-&gt;type()-&gt;is_loaded()) {
255     field_type = TypeInstPtr::BOTTOM;
256   } else {
257     if (is_obj) {
258       field_type = TypeOopPtr::make_from_klass(field-&gt;type()-&gt;as_klass());
259     } else {
260       field_type = Type::BOTTOM;
261     }
262   }
263   access_store_at(obj, adr, adr_type, val, field_type, bt, decorators);
264 
265   if (is_field) {
266     // Remember we wrote a volatile field.
267     // For not multiple copy atomic cpu (ppc64) a barrier should be issued
268     // in constructors which have such stores. See do_exits() in parse1.cpp.
269     if (is_vol) {
270       set_wrote_volatile(true);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;compiler/compileLog.hpp&quot;
 27 #include &quot;interpreter/linkResolver.hpp&quot;
 28 #include &quot;memory/universe.hpp&quot;
 29 #include &quot;oops/objArrayKlass.hpp&quot;
 30 #include &quot;opto/addnode.hpp&quot;
 31 #include &quot;opto/castnode.hpp&quot;
 32 #include &quot;opto/memnode.hpp&quot;
 33 #include &quot;opto/parse.hpp&quot;
 34 #include &quot;opto/rootnode.hpp&quot;
 35 #include &quot;opto/runtime.hpp&quot;
 36 #include &quot;opto/subnode.hpp&quot;
 37 #include &quot;runtime/deoptimization.hpp&quot;
 38 #include &quot;runtime/handles.inline.hpp&quot;
 39 
 40 //=============================================================================
 41 // Helper methods for _get* and _put* bytecodes
 42 //=============================================================================

































 43 void Parse::do_field_access(bool is_get, bool is_field) {
 44   bool will_link;
 45   ciField* field = iter().get_field(will_link);
 46   assert(will_link, &quot;getfield: typeflow responsibility&quot;);
 47 
 48   ciInstanceKlass* field_holder = field-&gt;holder();
 49 
 50   if (is_field == field-&gt;is_static()) {
 51     // Interpreter will throw java_lang_IncompatibleClassChangeError
 52     // Check this before allowing &lt;clinit&gt; methods to access static fields
 53     uncommon_trap(Deoptimization::Reason_unhandled,
 54                   Deoptimization::Action_none);
 55     return;
 56   }
 57 
<span class="line-modified"> 58   // Deoptimize on putfield writes to call site target field outside of CallSite ctor.</span>
<span class="line-modified"> 59   if (!is_get &amp;&amp; field-&gt;is_call_site_target() &amp;&amp;</span>
<span class="line-modified"> 60       !(method()-&gt;holder() == field_holder &amp;&amp; method()-&gt;is_object_initializer())) {</span>








 61     uncommon_trap(Deoptimization::Reason_unhandled,
 62                   Deoptimization::Action_reinterpret,
 63                   NULL, &quot;put to call site target field&quot;);
 64     return;
 65   }
 66 
<span class="line-added"> 67   if (C-&gt;needs_clinit_barrier(field, method())) {</span>
<span class="line-added"> 68     clinit_barrier(field_holder, method());</span>
<span class="line-added"> 69     if (stopped())  return;</span>
<span class="line-added"> 70   }</span>
<span class="line-added"> 71 </span>
 72   assert(field-&gt;will_link(method(), bc()), &quot;getfield: typeflow responsibility&quot;);
 73 
 74   // Note:  We do not check for an unloaded field type here any more.
 75 
 76   // Generate code for the object pointer.
 77   Node* obj;
 78   if (is_field) {
 79     int obj_depth = is_get ? 0 : field-&gt;type()-&gt;size();
 80     obj = null_check(peek(obj_depth));
 81     // Compile-time detect of null-exception?
 82     if (stopped())  return;
 83 
 84 #ifdef ASSERT
 85     const TypeInstPtr *tjp = TypeInstPtr::make(TypePtr::NotNull, iter().get_declared_field_holder());
 86     assert(_gvn.type(obj)-&gt;higher_equal(tjp), &quot;cast_up is no longer needed&quot;);
 87 #endif
 88 
 89     if (is_get) {
 90       (void) pop();  // pop receiver before getting
 91       do_get_xxx(obj, field, is_field);
</pre>
<hr />
<pre>
123       return;
124     }
125   }
126 
127   ciType* field_klass = field-&gt;type();
128   bool is_vol = field-&gt;is_volatile();
129 
130   // Compute address and memory type.
131   int offset = field-&gt;offset_in_bytes();
132   const TypePtr* adr_type = C-&gt;alias_type(field)-&gt;adr_type();
133   Node *adr = basic_plus_adr(obj, obj, offset);
134 
135   // Build the resultant type of the load
136   const Type *type;
137 
138   bool must_assert_null = false;
139 
140   DecoratorSet decorators = IN_HEAP;
141   decorators |= is_vol ? MO_SEQ_CST : MO_UNORDERED;
142 
<span class="line-modified">143   bool is_obj = is_reference_type(bt);</span>
144 
145   if (is_obj) {
146     if (!field-&gt;type()-&gt;is_loaded()) {
147       type = TypeInstPtr::BOTTOM;
148       must_assert_null = true;
149     } else if (field-&gt;is_static_constant()) {
150       // This can happen if the constant oop is non-perm.
151       ciObject* con = field-&gt;constant_value().as_object();
152       // Do not &quot;join&quot; in the previous type; it doesn&#39;t add value,
153       // and may yield a vacuous result if the field is of interface type.
154       if (con-&gt;is_null_object()) {
155         type = TypePtr::NULL_PTR;
156       } else {
157         type = TypeOopPtr::make_from_constant(con)-&gt;isa_oopptr();
158       }
159       assert(type != NULL, &quot;field singleton type must be consistent&quot;);
160     } else {
161       type = TypeOopPtr::make_from_klass(field_klass-&gt;as_klass());
162     }
163   } else {
</pre>
<hr />
<pre>
194     set_bci(iter().next_bci());
195     null_assert(peek());
196     set_bci(iter().cur_bci()); // put it back
197   }
198 }
199 
200 void Parse::do_put_xxx(Node* obj, ciField* field, bool is_field) {
201   bool is_vol = field-&gt;is_volatile();
202 
203   // Compute address and memory type.
204   int offset = field-&gt;offset_in_bytes();
205   const TypePtr* adr_type = C-&gt;alias_type(field)-&gt;adr_type();
206   Node* adr = basic_plus_adr(obj, obj, offset);
207   BasicType bt = field-&gt;layout_type();
208   // Value to be stored
209   Node* val = type2size[bt] == 1 ? pop() : pop_pair();
210 
211   DecoratorSet decorators = IN_HEAP;
212   decorators |= is_vol ? MO_SEQ_CST : MO_UNORDERED;
213 
<span class="line-modified">214   bool is_obj = is_reference_type(bt);</span>
215 
216   // Store the value.
217   const Type* field_type;
218   if (!field-&gt;type()-&gt;is_loaded()) {
219     field_type = TypeInstPtr::BOTTOM;
220   } else {
221     if (is_obj) {
222       field_type = TypeOopPtr::make_from_klass(field-&gt;type()-&gt;as_klass());
223     } else {
224       field_type = Type::BOTTOM;
225     }
226   }
227   access_store_at(obj, adr, adr_type, val, field_type, bt, decorators);
228 
229   if (is_field) {
230     // Remember we wrote a volatile field.
231     // For not multiple copy atomic cpu (ppc64) a barrier should be issued
232     // in constructors which have such stores. See do_exits() in parse1.cpp.
233     if (is_vol) {
234       set_wrote_volatile(true);
</pre>
</td>
</tr>
</table>
<center><a href="parse2.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="parseHelper.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
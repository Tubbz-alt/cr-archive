<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/memory/arena.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;memory/allocation.hpp&quot;
 27 #include &quot;memory/allocation.inline.hpp&quot;
 28 #include &quot;memory/metaspaceShared.hpp&quot;
 29 #include &quot;memory/resourceArea.hpp&quot;
 30 #include &quot;memory/universe.hpp&quot;
 31 #include &quot;runtime/atomic.hpp&quot;
 32 #include &quot;runtime/os.hpp&quot;
 33 #include &quot;runtime/task.hpp&quot;
 34 #include &quot;runtime/threadCritical.hpp&quot;
 35 #include &quot;services/memTracker.hpp&quot;
 36 #include &quot;utilities/ostream.hpp&quot;
 37 
 38 //--------------------------------------------------------------------------------------
 39 // ChunkPool implementation
 40 
 41 // MT-safe pool of chunks to reduce malloc/free thrashing
 42 // NB: not using Mutex because pools are used before Threads are initialized
 43 class ChunkPool: public CHeapObj&lt;mtInternal&gt; {
 44   Chunk*       _first;        // first cached Chunk; its first word points to next chunk
 45   size_t       _num_chunks;   // number of unused chunks in pool
 46   size_t       _num_used;     // number of chunks currently checked out
 47   const size_t _size;         // size of each chunk (must be uniform)
 48 
 49   // Our four static pools
 50   static ChunkPool* _large_pool;
 51   static ChunkPool* _medium_pool;
 52   static ChunkPool* _small_pool;
 53   static ChunkPool* _tiny_pool;
 54 
 55   // return first element or null
 56   void* get_first() {
 57     Chunk* c = _first;
 58     if (_first) {
 59       _first = _first-&gt;next();
 60       _num_chunks--;
 61     }
 62     return c;
 63   }
 64 
 65  public:
 66   // All chunks in a ChunkPool has the same size
 67    ChunkPool(size_t size) : _size(size) { _first = NULL; _num_chunks = _num_used = 0; }
 68 
 69   // Allocate a new chunk from the pool (might expand the pool)
 70   NOINLINE void* allocate(size_t bytes, AllocFailType alloc_failmode) {
 71     assert(bytes == _size, &quot;bad size&quot;);
 72     void* p = NULL;
 73     // No VM lock can be taken inside ThreadCritical lock, so os::malloc
 74     // should be done outside ThreadCritical lock due to NMT
 75     { ThreadCritical tc;
 76       _num_used++;
 77       p = get_first();
 78     }
 79     if (p == NULL) p = os::malloc(bytes, mtChunk, CURRENT_PC);
 80     if (p == NULL &amp;&amp; alloc_failmode == AllocFailStrategy::EXIT_OOM) {
 81       vm_exit_out_of_memory(bytes, OOM_MALLOC_ERROR, &quot;ChunkPool::allocate&quot;);
 82     }
 83     return p;
 84   }
 85 
 86   // Return a chunk to the pool
 87   void free(Chunk* chunk) {
 88     assert(chunk-&gt;length() + Chunk::aligned_overhead_size() == _size, &quot;bad size&quot;);
 89     ThreadCritical tc;
 90     _num_used--;
 91 
 92     // Add chunk to list
 93     chunk-&gt;set_next(_first);
 94     _first = chunk;
 95     _num_chunks++;
 96   }
 97 
 98   // Prune the pool
 99   void free_all_but(size_t n) {
100     Chunk* cur = NULL;
101     Chunk* next;
102     {
103       // if we have more than n chunks, free all of them
104       ThreadCritical tc;
105       if (_num_chunks &gt; n) {
106         // free chunks at end of queue, for better locality
107         cur = _first;
108         for (size_t i = 0; i &lt; (n - 1) &amp;&amp; cur != NULL; i++) cur = cur-&gt;next();
109 
110         if (cur != NULL) {
111           next = cur-&gt;next();
112           cur-&gt;set_next(NULL);
113           cur = next;
114 
115           // Free all remaining chunks while in ThreadCritical lock
116           // so NMT adjustment is stable.
117           while(cur != NULL) {
118             next = cur-&gt;next();
119             os::free(cur);
120             _num_chunks--;
121             cur = next;
122           }
123         }
124       }
125     }
126   }
127 
128   // Accessors to preallocated pool&#39;s
129   static ChunkPool* large_pool()  { assert(_large_pool  != NULL, &quot;must be initialized&quot;); return _large_pool;  }
130   static ChunkPool* medium_pool() { assert(_medium_pool != NULL, &quot;must be initialized&quot;); return _medium_pool; }
131   static ChunkPool* small_pool()  { assert(_small_pool  != NULL, &quot;must be initialized&quot;); return _small_pool;  }
132   static ChunkPool* tiny_pool()   { assert(_tiny_pool   != NULL, &quot;must be initialized&quot;); return _tiny_pool;   }
133 
134   static void initialize() {
135     _large_pool  = new ChunkPool(Chunk::size        + Chunk::aligned_overhead_size());
136     _medium_pool = new ChunkPool(Chunk::medium_size + Chunk::aligned_overhead_size());
137     _small_pool  = new ChunkPool(Chunk::init_size   + Chunk::aligned_overhead_size());
138     _tiny_pool   = new ChunkPool(Chunk::tiny_size   + Chunk::aligned_overhead_size());
139   }
140 
141   static void clean() {
142     enum { BlocksToKeep = 5 };
143      _tiny_pool-&gt;free_all_but(BlocksToKeep);
144      _small_pool-&gt;free_all_but(BlocksToKeep);
145      _medium_pool-&gt;free_all_but(BlocksToKeep);
146      _large_pool-&gt;free_all_but(BlocksToKeep);
147   }
148 };
149 
150 ChunkPool* ChunkPool::_large_pool  = NULL;
151 ChunkPool* ChunkPool::_medium_pool = NULL;
152 ChunkPool* ChunkPool::_small_pool  = NULL;
153 ChunkPool* ChunkPool::_tiny_pool   = NULL;
154 
155 void chunkpool_init() {
156   ChunkPool::initialize();
157 }
158 
159 void
160 Chunk::clean_chunk_pool() {
161   ChunkPool::clean();
162 }
163 
164 
165 //--------------------------------------------------------------------------------------
166 // ChunkPoolCleaner implementation
167 //
168 
169 class ChunkPoolCleaner : public PeriodicTask {
170   enum { CleaningInterval = 5000 };      // cleaning interval in ms
171 
172  public:
173    ChunkPoolCleaner() : PeriodicTask(CleaningInterval) {}
174    void task() {
175      ChunkPool::clean();
176    }
177 };
178 
179 //--------------------------------------------------------------------------------------
180 // Chunk implementation
181 
182 void* Chunk::operator new (size_t requested_size, AllocFailType alloc_failmode, size_t length) throw() {
183   // requested_size is equal to sizeof(Chunk) but in order for the arena
184   // allocations to come out aligned as expected the size must be aligned
185   // to expected arena alignment.
186   // expect requested_size but if sizeof(Chunk) doesn&#39;t match isn&#39;t proper size we must align it.
187   assert(ARENA_ALIGN(requested_size) == aligned_overhead_size(), &quot;Bad alignment&quot;);
188   size_t bytes = ARENA_ALIGN(requested_size) + length;
189   switch (length) {
190    case Chunk::size:        return ChunkPool::large_pool()-&gt;allocate(bytes, alloc_failmode);
191    case Chunk::medium_size: return ChunkPool::medium_pool()-&gt;allocate(bytes, alloc_failmode);
192    case Chunk::init_size:   return ChunkPool::small_pool()-&gt;allocate(bytes, alloc_failmode);
193    case Chunk::tiny_size:   return ChunkPool::tiny_pool()-&gt;allocate(bytes, alloc_failmode);
194    default: {
195      void* p = os::malloc(bytes, mtChunk, CALLER_PC);
196      if (p == NULL &amp;&amp; alloc_failmode == AllocFailStrategy::EXIT_OOM) {
197        vm_exit_out_of_memory(bytes, OOM_MALLOC_ERROR, &quot;Chunk::new&quot;);
198      }
199      return p;
200    }
201   }
202 }
203 
204 void Chunk::operator delete(void* p) {
205   Chunk* c = (Chunk*)p;
206   switch (c-&gt;length()) {
207    case Chunk::size:        ChunkPool::large_pool()-&gt;free(c); break;
208    case Chunk::medium_size: ChunkPool::medium_pool()-&gt;free(c); break;
209    case Chunk::init_size:   ChunkPool::small_pool()-&gt;free(c); break;
210    case Chunk::tiny_size:   ChunkPool::tiny_pool()-&gt;free(c); break;
211    default:
212      ThreadCritical tc;  // Free chunks under TC lock so that NMT adjustment is stable.
213      os::free(c);
214   }
215 }
216 
217 Chunk::Chunk(size_t length) : _len(length) {
218   _next = NULL;         // Chain on the linked list
219 }
220 
221 void Chunk::chop() {
222   Chunk *k = this;
223   while( k ) {
224     Chunk *tmp = k-&gt;next();
225     // clear out this chunk (to detect allocation bugs)
226     if (ZapResourceArea) memset(k-&gt;bottom(), badResourceValue, k-&gt;length());
227     delete k;                   // Free chunk (was malloc&#39;d)
228     k = tmp;
229   }
230 }
231 
232 void Chunk::next_chop() {
233   _next-&gt;chop();
234   _next = NULL;
235 }
236 
237 void Chunk::start_chunk_pool_cleaner_task() {
238 #ifdef ASSERT
239   static bool task_created = false;
240   assert(!task_created, &quot;should not start chuck pool cleaner twice&quot;);
241   task_created = true;
242 #endif
243   ChunkPoolCleaner* cleaner = new ChunkPoolCleaner();
244   cleaner-&gt;enroll();
245 }
246 
247 //------------------------------Arena------------------------------------------
248 
249 Arena::Arena(MEMFLAGS flag, size_t init_size) : _flags(flag), _size_in_bytes(0)  {
250   size_t round_size = (sizeof (char *)) - 1;
251   init_size = (init_size+round_size) &amp; ~round_size;
252   _first = _chunk = new (AllocFailStrategy::EXIT_OOM, init_size) Chunk(init_size);
253   _hwm = _chunk-&gt;bottom();      // Save the cached hwm, max
254   _max = _chunk-&gt;top();
255   MemTracker::record_new_arena(flag);
256   set_size_in_bytes(init_size);
257 }
258 
259 Arena::Arena(MEMFLAGS flag) : _flags(flag), _size_in_bytes(0) {
260   _first = _chunk = new (AllocFailStrategy::EXIT_OOM, Chunk::init_size) Chunk(Chunk::init_size);
261   _hwm = _chunk-&gt;bottom();      // Save the cached hwm, max
262   _max = _chunk-&gt;top();
263   MemTracker::record_new_arena(flag);
264   set_size_in_bytes(Chunk::init_size);
265 }
266 
267 Arena *Arena::move_contents(Arena *copy) {
268   copy-&gt;destruct_contents();
269   copy-&gt;_chunk = _chunk;
270   copy-&gt;_hwm   = _hwm;
271   copy-&gt;_max   = _max;
272   copy-&gt;_first = _first;
273 
274   // workaround rare racing condition, which could double count
275   // the arena size by native memory tracking
276   size_t size = size_in_bytes();
277   set_size_in_bytes(0);
278   copy-&gt;set_size_in_bytes(size);
279   // Destroy original arena
280   reset();
281   return copy;            // Return Arena with contents
282 }
283 
284 Arena::~Arena() {
285   destruct_contents();
286   MemTracker::record_arena_free(_flags);
287 }
288 
289 void* Arena::operator new(size_t size) throw() {
290   assert(false, &quot;Use dynamic memory type binding&quot;);
291   return NULL;
292 }
293 
294 void* Arena::operator new (size_t size, const std::nothrow_t&amp;  nothrow_constant) throw() {
295   assert(false, &quot;Use dynamic memory type binding&quot;);
296   return NULL;
297 }
298 
299   // dynamic memory type binding
300 void* Arena::operator new(size_t size, MEMFLAGS flags) throw() {
301   return (void *) AllocateHeap(size, flags, CALLER_PC);
302 }
303 
304 void* Arena::operator new(size_t size, const std::nothrow_t&amp; nothrow_constant, MEMFLAGS flags) throw() {
305   return (void*)AllocateHeap(size, flags, CALLER_PC, AllocFailStrategy::RETURN_NULL);
306 }
307 
308 void Arena::operator delete(void* p) {
309   FreeHeap(p);
310 }
311 
312 // Destroy this arenas contents and reset to empty
313 void Arena::destruct_contents() {
314   if (UseMallocOnly &amp;&amp; _first != NULL) {
315     char* end = _first-&gt;next() ? _first-&gt;top() : _hwm;
316     free_malloced_objects(_first, _first-&gt;bottom(), end, _hwm);
317   }
318   // reset size before chop to avoid a rare racing condition
319   // that can have total arena memory exceed total chunk memory
320   set_size_in_bytes(0);
321   _first-&gt;chop();
322   reset();
323 }
324 
325 // This is high traffic method, but many calls actually don&#39;t
326 // change the size
327 void Arena::set_size_in_bytes(size_t size) {
328   if (_size_in_bytes != size) {
329     long delta = (long)(size - size_in_bytes());
330     _size_in_bytes = size;
331     MemTracker::record_arena_size_change(delta, _flags);
332   }
333 }
334 
335 // Total of all Chunks in arena
336 size_t Arena::used() const {
337   size_t sum = _chunk-&gt;length() - (_max-_hwm); // Size leftover in this Chunk
338   Chunk *k = _first;
339   while( k != _chunk) {         // Whilst have Chunks in a row
340     sum += k-&gt;length();         // Total size of this Chunk
341     k = k-&gt;next();              // Bump along to next Chunk
342   }
343   return sum;                   // Return total consumed space.
344 }
345 
346 void Arena::signal_out_of_memory(size_t sz, const char* whence) const {
347   vm_exit_out_of_memory(sz, OOM_MALLOC_ERROR, &quot;%s&quot;, whence);
348 }
349 
350 // Grow a new Chunk
351 void* Arena::grow(size_t x, AllocFailType alloc_failmode) {
352   // Get minimal required size.  Either real big, or even bigger for giant objs
353   size_t len = MAX2(x, (size_t) Chunk::size);
354 
355   Chunk *k = _chunk;            // Get filled-up chunk address
356   _chunk = new (alloc_failmode, len) Chunk(len);
357 
358   if (_chunk == NULL) {
359     _chunk = k;                 // restore the previous value of _chunk
360     return NULL;
361   }
362   if (k) k-&gt;set_next(_chunk);   // Append new chunk to end of linked list
363   else _first = _chunk;
364   _hwm  = _chunk-&gt;bottom();     // Save the cached hwm, max
365   _max =  _chunk-&gt;top();
366   set_size_in_bytes(size_in_bytes() + len);
367   void* result = _hwm;
368   _hwm += x;
369   return result;
370 }
371 
372 
373 
374 // Reallocate storage in Arena.
375 void *Arena::Arealloc(void* old_ptr, size_t old_size, size_t new_size, AllocFailType alloc_failmode) {
376   if (new_size == 0) return NULL;
377 #ifdef ASSERT
378   if (UseMallocOnly) {
379     // always allocate a new object  (otherwise we&#39;ll free this one twice)
380     char* copy = (char*)Amalloc(new_size, alloc_failmode);
381     if (copy == NULL) {
382       return NULL;
383     }
384     size_t n = MIN2(old_size, new_size);
385     if (n &gt; 0) memcpy(copy, old_ptr, n);
386     Afree(old_ptr,old_size);    // Mostly done to keep stats accurate
387     return copy;
388   }
389 #endif
390   char *c_old = (char*)old_ptr; // Handy name
391   // Stupid fast special case
392   if( new_size &lt;= old_size ) {  // Shrink in-place
393     if( c_old+old_size == _hwm) // Attempt to free the excess bytes
394       _hwm = c_old+new_size;    // Adjust hwm
395     return c_old;
396   }
397 
398   // make sure that new_size is legal
399   size_t corrected_new_size = ARENA_ALIGN(new_size);
400 
401   // See if we can resize in-place
402   if( (c_old+old_size == _hwm) &amp;&amp;       // Adjusting recent thing
403       (c_old+corrected_new_size &lt;= _max) ) {      // Still fits where it sits
404     _hwm = c_old+corrected_new_size;      // Adjust hwm
405     return c_old;               // Return old pointer
406   }
407 
408   // Oops, got to relocate guts
409   void *new_ptr = Amalloc(new_size, alloc_failmode);
410   if (new_ptr == NULL) {
411     return NULL;
412   }
413   memcpy( new_ptr, c_old, old_size );
414   Afree(c_old,old_size);        // Mostly done to keep stats accurate
415   return new_ptr;
416 }
417 
418 
419 // Determine if pointer belongs to this Arena or not.
420 bool Arena::contains( const void *ptr ) const {
421 #ifdef ASSERT
422   if (UseMallocOnly) {
423     // really slow, but not easy to make fast
424     if (_chunk == NULL) return false;
425     char** bottom = (char**)_chunk-&gt;bottom();
426     for (char** p = (char**)_hwm - 1; p &gt;= bottom; p--) {
427       if (*p == ptr) return true;
428     }
429     for (Chunk *c = _first; c != NULL; c = c-&gt;next()) {
430       if (c == _chunk) continue;  // current chunk has been processed
431       char** bottom = (char**)c-&gt;bottom();
432       for (char** p = (char**)c-&gt;top() - 1; p &gt;= bottom; p--) {
433         if (*p == ptr) return true;
434       }
435     }
436     return false;
437   }
438 #endif
439   if( (void*)_chunk-&gt;bottom() &lt;= ptr &amp;&amp; ptr &lt; (void*)_hwm )
440     return true;                // Check for in this chunk
441   for (Chunk *c = _first; c; c = c-&gt;next()) {
442     if (c == _chunk) continue;  // current chunk has been processed
443     if ((void*)c-&gt;bottom() &lt;= ptr &amp;&amp; ptr &lt; (void*)c-&gt;top()) {
444       return true;              // Check for every chunk in Arena
445     }
446   }
447   return false;                 // Not in any Chunk, so not in Arena
448 }
449 
450 
451 #ifdef ASSERT
452 void* Arena::malloc(size_t size) {
453   assert(UseMallocOnly, &quot;shouldn&#39;t call&quot;);
454   // use malloc, but save pointer in res. area for later freeing
455   char** save = (char**)internal_malloc_4(sizeof(char*));
456   return (*save = (char*)os::malloc(size, mtChunk));
457 }
458 
459 // for debugging with UseMallocOnly
460 void* Arena::internal_malloc_4(size_t x) {
461   assert( (x&amp;(sizeof(char*)-1)) == 0, &quot;misaligned size&quot; );
462   check_for_overflow(x, &quot;Arena::internal_malloc_4&quot;);
463   if (_hwm + x &gt; _max) {
464     return grow(x);
465   } else {
466     char *old = _hwm;
467     _hwm += x;
468     return old;
469   }
470 }
471 #endif
472 
473 
474 //--------------------------------------------------------------------------------------
475 // Non-product code
476 
477 #ifndef PRODUCT
478 
479 julong Arena::_bytes_allocated = 0;
480 
481 void Arena::inc_bytes_allocated(size_t x) { inc_stat_counter(&amp;_bytes_allocated, x); }
482 
483 // debugging code
484 inline void Arena::free_all(char** start, char** end) {
485   for (char** p = start; p &lt; end; p++) if (*p) os::free(*p);
486 }
487 
488 void Arena::free_malloced_objects(Chunk* chunk, char* hwm, char* max, char* hwm2) {
489   assert(UseMallocOnly, &quot;should not call&quot;);
490   // free all objects malloced since resource mark was created; resource area
491   // contains their addresses
492   if (chunk-&gt;next()) {
493     // this chunk is full, and some others too
494     for (Chunk* c = chunk-&gt;next(); c != NULL; c = c-&gt;next()) {
495       char* top = c-&gt;top();
496       if (c-&gt;next() == NULL) {
497         top = hwm2;     // last junk is only used up to hwm2
498         assert(c-&gt;contains(hwm2), &quot;bad hwm2&quot;);
499       }
500       free_all((char**)c-&gt;bottom(), (char**)top);
501     }
502     assert(chunk-&gt;contains(hwm), &quot;bad hwm&quot;);
503     assert(chunk-&gt;contains(max), &quot;bad max&quot;);
504     free_all((char**)hwm, (char**)max);
505   } else {
506     // this chunk was partially used
507     assert(chunk-&gt;contains(hwm), &quot;bad hwm&quot;);
508     assert(chunk-&gt;contains(hwm2), &quot;bad hwm2&quot;);
509     free_all((char**)hwm, (char**)hwm2);
510   }
511 }
512 
513 #endif // Non-product
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/arena.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="arena.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="filemap.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/arena.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_MEMORY_ARENA_HPP
 26 #define SHARE_MEMORY_ARENA_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;runtime/globals.hpp&quot;
 30 #include &quot;utilities/globalDefinitions.hpp&quot;

 31 
 32 #include &lt;new&gt;
 33 
 34 // The byte alignment to be used by Arena::Amalloc.  See bugid 4169348.
 35 // Note: this value must be a power of 2
 36 
 37 #define ARENA_AMALLOC_ALIGNMENT (2*BytesPerWord)
 38 
 39 #define ARENA_ALIGN_M1 (((size_t)(ARENA_AMALLOC_ALIGNMENT)) - 1)
 40 #define ARENA_ALIGN_MASK (~((size_t)ARENA_ALIGN_M1))
 41 #define ARENA_ALIGN(x) ((((size_t)(x)) + ARENA_ALIGN_M1) &amp; ARENA_ALIGN_MASK)
 42 
 43 //------------------------------Chunk------------------------------------------
 44 // Linked list of raw memory chunks
 45 class Chunk: CHeapObj&lt;mtChunk&gt; {
 46 
 47  private:
 48   Chunk*       _next;     // Next Chunk in list
 49   const size_t _len;      // Size of this Chunk
 50  public:
</pre>
<hr />
<pre>
 89 };
 90 
 91 //------------------------------Arena------------------------------------------
 92 // Fast allocation of memory
 93 class Arena : public CHeapObj&lt;mtNone&gt; {
 94 protected:
 95   friend class ResourceMark;
 96   friend class HandleMark;
 97   friend class NoHandleMark;
 98   friend class VMStructs;
 99 
100   MEMFLAGS    _flags;           // Memory tracking flags
101 
102   Chunk *_first;                // First chunk
103   Chunk *_chunk;                // current chunk
104   char *_hwm, *_max;            // High water mark and max in current chunk
105   // Get a new Chunk of at least size x
106   void* grow(size_t x, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);
107   size_t _size_in_bytes;        // Size of arena (used for native memory tracking)
108 
<span class="line-removed">109   NOT_PRODUCT(static julong _bytes_allocated;) // total #bytes allocated since start</span>
<span class="line-removed">110   friend class AllocStats;</span>
111   debug_only(void* malloc(size_t size);)
112   debug_only(void* internal_malloc_4(size_t x);)
<span class="line-removed">113   NOT_PRODUCT(void inc_bytes_allocated(size_t x);)</span>
114 
115   void signal_out_of_memory(size_t request, const char* whence) const;
116 
117   bool check_for_overflow(size_t request, const char* whence,
118       AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM) const {
119     if (UINTPTR_MAX - request &lt; (uintptr_t)_hwm) {
120       if (alloc_failmode == AllocFailStrategy::RETURN_NULL) {
121         return false;
122       }
123       signal_out_of_memory(request, whence);
124     }
125     return true;
126  }
127 
128  public:
129   Arena(MEMFLAGS memflag);
130   Arena(MEMFLAGS memflag, size_t init_size);
131   ~Arena();
132   void  destruct_contents();
133   char* hwm() const             { return _hwm; }
134 
135   // new operators
136   void* operator new (size_t size) throw();
137   void* operator new (size_t size, const std::nothrow_t&amp; nothrow_constant) throw();
138 
139   // dynamic memory type tagging
140   void* operator new(size_t size, MEMFLAGS flags) throw();
141   void* operator new(size_t size, const std::nothrow_t&amp; nothrow_constant, MEMFLAGS flags) throw();
142   void  operator delete(void* p);
143 
144   // Fast allocate in the arena.  Common case is: pointer test + increment.
145   void* Amalloc(size_t x, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM) {
146     assert(is_power_of_2(ARENA_AMALLOC_ALIGNMENT) , &quot;should be a power of 2&quot;);
147     x = ARENA_ALIGN(x);
148     debug_only(if (UseMallocOnly) return malloc(x);)
149     if (!check_for_overflow(x, &quot;Arena::Amalloc&quot;, alloc_failmode))
150       return NULL;
<span class="line-removed">151     NOT_PRODUCT(inc_bytes_allocated(x);)</span>
152     if (_hwm + x &gt; _max) {
153       return grow(x, alloc_failmode);
154     } else {
155       char *old = _hwm;
156       _hwm += x;
157       return old;
158     }
159   }
160   // Further assume size is padded out to words
161   void *Amalloc_4(size_t x, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM) {
162     assert( (x&amp;(sizeof(char*)-1)) == 0, &quot;misaligned size&quot; );
163     debug_only(if (UseMallocOnly) return malloc(x);)
164     if (!check_for_overflow(x, &quot;Arena::Amalloc_4&quot;, alloc_failmode))
165       return NULL;
<span class="line-removed">166     NOT_PRODUCT(inc_bytes_allocated(x);)</span>
167     if (_hwm + x &gt; _max) {
168       return grow(x, alloc_failmode);
169     } else {
170       char *old = _hwm;
171       _hwm += x;
172       return old;
173     }
174   }
175 
176   // Allocate with &#39;double&#39; alignment. It is 8 bytes on sparc.
177   // In other cases Amalloc_D() should be the same as Amalloc_4().
178   void* Amalloc_D(size_t x, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM) {
179     assert( (x&amp;(sizeof(char*)-1)) == 0, &quot;misaligned size&quot; );
180     debug_only(if (UseMallocOnly) return malloc(x);)
181 #if defined(SPARC) &amp;&amp; !defined(_LP64)
182 #define DALIGN_M1 7
183     size_t delta = (((size_t)_hwm + DALIGN_M1) &amp; ~DALIGN_M1) - (size_t)_hwm;
184     x += delta;
185 #endif
186     if (!check_for_overflow(x, &quot;Arena::Amalloc_D&quot;, alloc_failmode))
187       return NULL;
<span class="line-removed">188     NOT_PRODUCT(inc_bytes_allocated(x);)</span>
189     if (_hwm + x &gt; _max) {
190       return grow(x, alloc_failmode); // grow() returns a result aligned &gt;= 8 bytes.
191     } else {
192       char *old = _hwm;
193       _hwm += x;
194 #if defined(SPARC) &amp;&amp; !defined(_LP64)
195       old += delta; // align to 8-bytes
196 #endif
197       return old;
198     }
199   }
200 
201   // Fast delete in area.  Common case is: NOP (except for storage reclaimed)
202   bool Afree(void *ptr, size_t size) {
203 #ifdef ASSERT
204     if (ZapResourceArea) memset(ptr, badResourceValue, size); // zap freed memory
205     if (UseMallocOnly) return true;
206 #endif
207     if (((char*)ptr) + size == _hwm) {
208       _hwm = (char*)ptr;
</pre>
</td>
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_MEMORY_ARENA_HPP
 26 #define SHARE_MEMORY_ARENA_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;runtime/globals.hpp&quot;
 30 #include &quot;utilities/globalDefinitions.hpp&quot;
<span class="line-added"> 31 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
 32 
 33 #include &lt;new&gt;
 34 
 35 // The byte alignment to be used by Arena::Amalloc.  See bugid 4169348.
 36 // Note: this value must be a power of 2
 37 
 38 #define ARENA_AMALLOC_ALIGNMENT (2*BytesPerWord)
 39 
 40 #define ARENA_ALIGN_M1 (((size_t)(ARENA_AMALLOC_ALIGNMENT)) - 1)
 41 #define ARENA_ALIGN_MASK (~((size_t)ARENA_ALIGN_M1))
 42 #define ARENA_ALIGN(x) ((((size_t)(x)) + ARENA_ALIGN_M1) &amp; ARENA_ALIGN_MASK)
 43 
 44 //------------------------------Chunk------------------------------------------
 45 // Linked list of raw memory chunks
 46 class Chunk: CHeapObj&lt;mtChunk&gt; {
 47 
 48  private:
 49   Chunk*       _next;     // Next Chunk in list
 50   const size_t _len;      // Size of this Chunk
 51  public:
</pre>
<hr />
<pre>
 90 };
 91 
 92 //------------------------------Arena------------------------------------------
 93 // Fast allocation of memory
 94 class Arena : public CHeapObj&lt;mtNone&gt; {
 95 protected:
 96   friend class ResourceMark;
 97   friend class HandleMark;
 98   friend class NoHandleMark;
 99   friend class VMStructs;
100 
101   MEMFLAGS    _flags;           // Memory tracking flags
102 
103   Chunk *_first;                // First chunk
104   Chunk *_chunk;                // current chunk
105   char *_hwm, *_max;            // High water mark and max in current chunk
106   // Get a new Chunk of at least size x
107   void* grow(size_t x, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);
108   size_t _size_in_bytes;        // Size of arena (used for native memory tracking)
109 


110   debug_only(void* malloc(size_t size);)
111   debug_only(void* internal_malloc_4(size_t x);)

112 
113   void signal_out_of_memory(size_t request, const char* whence) const;
114 
115   bool check_for_overflow(size_t request, const char* whence,
116       AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM) const {
117     if (UINTPTR_MAX - request &lt; (uintptr_t)_hwm) {
118       if (alloc_failmode == AllocFailStrategy::RETURN_NULL) {
119         return false;
120       }
121       signal_out_of_memory(request, whence);
122     }
123     return true;
124  }
125 
126  public:
127   Arena(MEMFLAGS memflag);
128   Arena(MEMFLAGS memflag, size_t init_size);
129   ~Arena();
130   void  destruct_contents();
131   char* hwm() const             { return _hwm; }
132 
133   // new operators
134   void* operator new (size_t size) throw();
135   void* operator new (size_t size, const std::nothrow_t&amp; nothrow_constant) throw();
136 
137   // dynamic memory type tagging
138   void* operator new(size_t size, MEMFLAGS flags) throw();
139   void* operator new(size_t size, const std::nothrow_t&amp; nothrow_constant, MEMFLAGS flags) throw();
140   void  operator delete(void* p);
141 
142   // Fast allocate in the arena.  Common case is: pointer test + increment.
143   void* Amalloc(size_t x, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM) {
144     assert(is_power_of_2(ARENA_AMALLOC_ALIGNMENT) , &quot;should be a power of 2&quot;);
145     x = ARENA_ALIGN(x);
146     debug_only(if (UseMallocOnly) return malloc(x);)
147     if (!check_for_overflow(x, &quot;Arena::Amalloc&quot;, alloc_failmode))
148       return NULL;

149     if (_hwm + x &gt; _max) {
150       return grow(x, alloc_failmode);
151     } else {
152       char *old = _hwm;
153       _hwm += x;
154       return old;
155     }
156   }
157   // Further assume size is padded out to words
158   void *Amalloc_4(size_t x, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM) {
159     assert( (x&amp;(sizeof(char*)-1)) == 0, &quot;misaligned size&quot; );
160     debug_only(if (UseMallocOnly) return malloc(x);)
161     if (!check_for_overflow(x, &quot;Arena::Amalloc_4&quot;, alloc_failmode))
162       return NULL;

163     if (_hwm + x &gt; _max) {
164       return grow(x, alloc_failmode);
165     } else {
166       char *old = _hwm;
167       _hwm += x;
168       return old;
169     }
170   }
171 
172   // Allocate with &#39;double&#39; alignment. It is 8 bytes on sparc.
173   // In other cases Amalloc_D() should be the same as Amalloc_4().
174   void* Amalloc_D(size_t x, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM) {
175     assert( (x&amp;(sizeof(char*)-1)) == 0, &quot;misaligned size&quot; );
176     debug_only(if (UseMallocOnly) return malloc(x);)
177 #if defined(SPARC) &amp;&amp; !defined(_LP64)
178 #define DALIGN_M1 7
179     size_t delta = (((size_t)_hwm + DALIGN_M1) &amp; ~DALIGN_M1) - (size_t)_hwm;
180     x += delta;
181 #endif
182     if (!check_for_overflow(x, &quot;Arena::Amalloc_D&quot;, alloc_failmode))
183       return NULL;

184     if (_hwm + x &gt; _max) {
185       return grow(x, alloc_failmode); // grow() returns a result aligned &gt;= 8 bytes.
186     } else {
187       char *old = _hwm;
188       _hwm += x;
189 #if defined(SPARC) &amp;&amp; !defined(_LP64)
190       old += delta; // align to 8-bytes
191 #endif
192       return old;
193     }
194   }
195 
196   // Fast delete in area.  Common case is: NOP (except for storage reclaimed)
197   bool Afree(void *ptr, size_t size) {
198 #ifdef ASSERT
199     if (ZapResourceArea) memset(ptr, badResourceValue, size); // zap freed memory
200     if (UseMallocOnly) return true;
201 #endif
202     if (((char*)ptr) + size == _hwm) {
203       _hwm = (char*)ptr;
</pre>
</td>
</tr>
</table>
<center><a href="arena.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="filemap.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
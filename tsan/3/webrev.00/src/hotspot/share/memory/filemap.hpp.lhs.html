<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/memory/filemap.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_MEMORY_FILEMAP_HPP
 26 #define SHARE_MEMORY_FILEMAP_HPP
 27 
 28 #include &quot;classfile/classLoader.hpp&quot;
 29 #include &quot;include/cds.h&quot;
 30 #include &quot;memory/metaspaceShared.hpp&quot;
 31 #include &quot;memory/metaspace.hpp&quot;
<a name="2" id="anc2"></a><span class="line-modified"> 32 #include &quot;memory/universe.hpp&quot;</span>
 33 #include &quot;utilities/align.hpp&quot;
 34 
 35 // Layout of the file:
 36 //  header: dump of archive instance plus versioning info, datestamp, etc.
 37 //   [magic # = 0xF00BABA2]
 38 //  ... padding to align on page-boundary
 39 //  read-write space
 40 //  read-only space
 41 //  misc data (block offset table, string table, symbols, dictionary, etc.)
 42 //  tag(666)
 43 
 44 static const int JVM_IDENT_MAX = 256;
 45 
<a name="3" id="anc3"></a>

 46 class SharedClassPathEntry {
 47   enum {
 48     modules_image_entry,
 49     jar_entry,
 50     signed_jar_entry,
 51     dir_entry,
<a name="4" id="anc4"></a>
 52     unknown_entry
 53   };
<a name="5" id="anc5"></a><span class="line-modified"> 54 protected:</span>


 55   u1     _type;
<a name="6" id="anc6"></a>
 56   time_t _timestamp;          // jar timestamp,  0 if is directory, modules image or other
 57   long   _filesize;           // jar/jimage file size, -1 if is directory, -2 if other
 58   Array&lt;char&gt;* _name;
 59   Array&lt;u1&gt;*   _manifest;
 60 
 61 public:
<a name="7" id="anc7"></a><span class="line-modified"> 62   void init(const char* name, bool is_modules_image, TRAPS);</span>

 63   void metaspace_pointers_do(MetaspaceClosure* it);
<a name="8" id="anc8"></a><span class="line-modified"> 64   bool validate(bool is_class_path = true);</span>
 65 
 66   // The _timestamp only gets set for jar files.
<a name="9" id="anc9"></a><span class="line-modified"> 67   bool has_timestamp() {</span>
 68     return _timestamp != 0;
 69   }
<a name="10" id="anc10"></a><span class="line-modified"> 70   bool is_dir()            { return _type == dir_entry; }</span>
<span class="line-modified"> 71   bool is_modules_image()  { return _type == modules_image_entry; }</span>
<span class="line-modified"> 72   bool is_jar()            { return _type == jar_entry; }</span>
<span class="line-modified"> 73   bool is_signed()         { return _type == signed_jar_entry; }</span>
<span class="line-modified"> 74   void set_is_signed()     {</span>
 75     _type = signed_jar_entry;
 76   }
<a name="11" id="anc11"></a>
 77   time_t timestamp() const { return _timestamp; }
 78   long   filesize()  const { return _filesize; }
<a name="12" id="anc12"></a><span class="line-modified"> 79   const char* name() const { return _name-&gt;data(); }</span>
 80   const char* manifest() const {
 81     return (_manifest == NULL) ? NULL : (const char*)_manifest-&gt;data();
 82   }
 83   int manifest_size() const {
 84     return (_manifest == NULL) ? 0 : _manifest-&gt;length();
 85   }
 86   void set_manifest(Array&lt;u1&gt;* manifest) {
 87     _manifest = manifest;
 88   }
<a name="13" id="anc13"></a>
 89 };
 90 
 91 struct ArchiveHeapOopmapInfo {
 92   address _oopmap;               // bitmap for relocating embedded oops
 93   size_t  _oopmap_size_in_bits;
 94 };
 95 
<a name="14" id="anc14"></a><span class="line-modified"> 96 struct FileMapHeader : public CDSFileMapHeaderBase {</span>












































































 97   size_t _alignment;                // how shared archive should be aligned
 98   int    _obj_alignment;            // value of ObjectAlignmentInBytes
 99   address _narrow_oop_base;         // compressed oop encoding base
100   int    _narrow_oop_shift;         // compressed oop encoding shift
<a name="15" id="anc15"></a><span class="line-modified">101   bool    _compact_strings;         // value of CompactStrings</span>
102   uintx  _max_heap_size;            // java max heap size during dumping
<a name="16" id="anc16"></a><span class="line-modified">103   Universe::NARROW_OOP_MODE _narrow_oop_mode; // compressed oop encoding mode</span>
104   int     _narrow_klass_shift;      // save narrow klass base and shift
<a name="17" id="anc17"></a><span class="line-modified">105   address _narrow_klass_base;</span>
<span class="line-modified">106   char*   _misc_data_patching_start;</span>
<span class="line-modified">107   char*   _read_only_tables_start;</span>
<span class="line-modified">108   address _cds_i2i_entry_code_buffers;</span>
<span class="line-modified">109   size_t  _cds_i2i_entry_code_buffers_size;</span>
<span class="line-modified">110   size_t  _core_spaces_size;        // number of bytes allocated by the core spaces</span>
<span class="line-modified">111                                     // (mc, md, ro, rw and od).</span>
<span class="line-modified">112   MemRegion _heap_reserved;         // reserved region for the entire heap at dump time.</span>
113 
114   // The following fields are all sanity checks for whether this archive
115   // will function correctly with this JVM and the bootclasspath it&#39;s
116   // invoked with.
<a name="18" id="anc18"></a><span class="line-modified">117   char  _jvm_ident[JVM_IDENT_MAX];      // identifier for jvm</span>
<span class="line-modified">118 </span>
<span class="line-modified">119   // The _paths_misc_info is a variable-size structure that records &quot;miscellaneous&quot;</span>
<span class="line-modified">120   // information during dumping. It is generated and validated by the</span>
<span class="line-modified">121   // SharedPathsMiscInfo class. See SharedPathsMiscInfo.hpp for</span>
<span class="line-modified">122   // detailed description.</span>
<span class="line-modified">123   //</span>
<span class="line-modified">124   // The _paths_misc_info data is stored as a byte array in the archive file header,</span>
<span class="line-modified">125   // immediately after the _header field. This information is used only when</span>
<span class="line-modified">126   // checking the validity of the archive and is deallocated after the archive is loaded.</span>
<span class="line-modified">127   //</span>
<span class="line-modified">128   // Note that the _paths_misc_info does NOT include information for JAR files</span>
<span class="line-modified">129   // that existed during dump time. Their information is stored in _shared_path_table.</span>
<span class="line-removed">130   int _paths_misc_info_size;</span>
<span class="line-removed">131 </span>
<span class="line-removed">132   // The following is a table of all the class path entries that were used</span>
<span class="line-removed">133   // during dumping. At run time, we require these files to exist and have the same</span>
<span class="line-removed">134   // size/modification time, or else the archive will refuse to load.</span>
<span class="line-removed">135   //</span>
<span class="line-removed">136   // All of these entries must be JAR files. The dumping process would fail if a non-empty</span>
<span class="line-removed">137   // directory was specified in the classpaths. If an empty directory was specified</span>
<span class="line-removed">138   // it is checked by the _paths_misc_info as described above.</span>
<span class="line-removed">139   //</span>
<span class="line-removed">140   // FIXME -- if JAR files in the tail of the list were specified but not used during dumping,</span>
<span class="line-removed">141   // they should be removed from this table, to save space and to avoid spurious</span>
<span class="line-removed">142   // loading failures during runtime.</span>
<span class="line-removed">143   int _shared_path_table_size;</span>
<span class="line-removed">144   size_t _shared_path_entry_size;</span>
<span class="line-removed">145   Array&lt;u8&gt;* _shared_path_table;</span>
146 
147   jshort _app_class_paths_start_index;  // Index of first app classpath entry
148   jshort _app_module_paths_start_index; // Index of first module path entry
<a name="19" id="anc19"></a>
149   jshort _max_used_path_index;          // max path index referenced during CDS dump
150   bool   _verify_local;                 // BytecodeVerificationLocal setting
151   bool   _verify_remote;                // BytecodeVerificationRemote setting
152   bool   _has_platform_or_app_classes;  // Archive contains app classes
<a name="20" id="anc20"></a><span class="line-modified">153   size_t _shared_base_address;          // SharedBaseAddress used at dump time</span>


154   bool   _allow_archiving_with_java_agent; // setting of the AllowArchivingWithJavaAgent option
<a name="21" id="anc21"></a>
155 
<a name="22" id="anc22"></a><span class="line-modified">156   void set_has_platform_or_app_classes(bool v) {</span>
<span class="line-modified">157     _has_platform_or_app_classes = v;</span>








































































158   }
<a name="23" id="anc23"></a><span class="line-removed">159   bool has_platform_or_app_classes() { return _has_platform_or_app_classes; }</span>
<span class="line-removed">160   jshort max_used_path_index()       { return _max_used_path_index; }</span>
<span class="line-removed">161   jshort app_module_paths_start_index() { return _app_module_paths_start_index; }</span>
162 
163   bool validate();
<a name="24" id="anc24"></a><span class="line-removed">164   void populate(FileMapInfo* info, size_t alignment);</span>
165   int compute_crc();
166 
<a name="25" id="anc25"></a><span class="line-modified">167   CDSFileMapRegion* space_at(int i) {</span>
<span class="line-modified">168     assert(i &gt;= 0 &amp;&amp; i &lt; NUM_CDS_REGIONS, &quot;invalid region&quot;);</span>
<span class="line-modified">169     return &amp;_space[i];</span>






170   }
171 };
172 
173 class FileMapInfo : public CHeapObj&lt;mtInternal&gt; {
174 private:
175   friend class ManifestStream;
176   friend class VMStructs;
<a name="26" id="anc26"></a><span class="line-modified">177   friend struct FileMapHeader;</span>
<span class="line-modified">178 </span>
<span class="line-modified">179   bool    _file_open;</span>
<span class="line-modified">180   int     _fd;</span>
<span class="line-modified">181   size_t  _file_offset;</span>
<span class="line-modified">182 </span>
<span class="line-modified">183 private:</span>
<span class="line-modified">184   static Array&lt;u8&gt;*            _shared_path_table;</span>
<span class="line-modified">185   static int                   _shared_path_table_size;</span>
<span class="line-modified">186   static size_t                _shared_path_entry_size;</span>




187   static bool                  _validating_shared_path_table;
188 
189   // FileMapHeader describes the shared space data in the file to be
190   // mapped.  This structure gets written to a file.  It is not a class, so
191   // that the compilers don&#39;t add any compiler-private data to it.
192 
<a name="27" id="anc27"></a><span class="line-removed">193 public:</span>
<span class="line-removed">194   struct FileMapHeaderBase : public CHeapObj&lt;mtClass&gt; {</span>
<span class="line-removed">195     // Need to put something here. Otherwise, in product build, because CHeapObj has no virtual</span>
<span class="line-removed">196     // methods, we would get sizeof(FileMapHeaderBase) == 1 with gcc.</span>
<span class="line-removed">197     intx _dummy;</span>
<span class="line-removed">198   };</span>
<span class="line-removed">199 </span>
<span class="line-removed">200 </span>
<span class="line-removed">201   FileMapHeader * _header;</span>
<span class="line-removed">202 </span>
<span class="line-removed">203   const char* _full_path;</span>
<span class="line-removed">204   char* _paths_misc_info;</span>
<span class="line-removed">205 </span>
206   static FileMapInfo* _current_info;
<a name="28" id="anc28"></a>
207   static bool _heap_pointers_need_patching;
<a name="29" id="anc29"></a>

208 
<a name="30" id="anc30"></a><span class="line-modified">209   bool  init_from_file(int fd);</span>
<span class="line-removed">210   void  align_file_position();</span>
<span class="line-removed">211   bool  validate_header_impl();</span>
<span class="line-removed">212   static void metaspace_pointers_do(MetaspaceClosure* it);</span>
213 
214 public:
<a name="31" id="anc31"></a><span class="line-modified">215   FileMapInfo();</span>












216   ~FileMapInfo();
217 
<a name="32" id="anc32"></a><span class="line-modified">218   int    compute_header_crc()         { return _header-&gt;compute_crc(); }</span>
<span class="line-modified">219   void   set_header_crc(int crc)      { _header-&gt;_crc = crc; }</span>


220   void   populate_header(size_t alignment);
221   bool   validate_header();
222   void   invalidate();
<a name="33" id="anc33"></a><span class="line-modified">223   int    version()                    { return _header-&gt;_version; }</span>
<span class="line-modified">224   size_t alignment()                  { return _header-&gt;_alignment; }</span>
<span class="line-modified">225   Universe::NARROW_OOP_MODE narrow_oop_mode() { return _header-&gt;_narrow_oop_mode; }</span>
<span class="line-modified">226   address narrow_oop_base()    const  { return _header-&gt;_narrow_oop_base; }</span>
<span class="line-modified">227   int     narrow_oop_shift()   const  { return _header-&gt;_narrow_oop_shift; }</span>
<span class="line-modified">228   uintx   max_heap_size()      const  { return _header-&gt;_max_heap_size; }</span>
<span class="line-modified">229   address narrow_klass_base()  const  { return _header-&gt;_narrow_klass_base; }</span>
<span class="line-modified">230   int     narrow_klass_shift() const  { return _header-&gt;_narrow_klass_shift; }</span>
<span class="line-modified">231   struct  FileMapHeader* header()     { return _header; }</span>
<span class="line-modified">232   char*   misc_data_patching_start()          { return _header-&gt;_misc_data_patching_start; }</span>
<span class="line-modified">233   void set_misc_data_patching_start(char* p)  { _header-&gt;_misc_data_patching_start = p; }</span>
<span class="line-modified">234   char* read_only_tables_start()              { return _header-&gt;_read_only_tables_start; }</span>
<span class="line-modified">235   void set_read_only_tables_start(char* p)    { _header-&gt;_read_only_tables_start = p; }</span>
<span class="line-modified">236 </span>
<span class="line-modified">237   address cds_i2i_entry_code_buffers() {</span>
<span class="line-modified">238     return _header-&gt;_cds_i2i_entry_code_buffers;</span>
<span class="line-modified">239   }</span>
<span class="line-modified">240   void set_cds_i2i_entry_code_buffers(address addr) {</span>
<span class="line-modified">241     _header-&gt;_cds_i2i_entry_code_buffers = addr;</span>
<span class="line-modified">242   }</span>
<span class="line-modified">243   size_t cds_i2i_entry_code_buffers_size() {</span>
<span class="line-modified">244     return _header-&gt;_cds_i2i_entry_code_buffers_size;</span>
<span class="line-modified">245   }</span>
<span class="line-modified">246   void set_cds_i2i_entry_code_buffers_size(size_t s) {</span>
<span class="line-modified">247     _header-&gt;_cds_i2i_entry_code_buffers_size = s;</span>
<span class="line-modified">248   }</span>
<span class="line-modified">249   void set_core_spaces_size(size_t s)    {  _header-&gt;_core_spaces_size = s; }</span>
<span class="line-modified">250   size_t core_spaces_size()              { return _header-&gt;_core_spaces_size; }</span>



















251 
252   static FileMapInfo* current_info() {
253     CDS_ONLY(return _current_info;)
254     NOT_CDS(return NULL;)
255   }
256 
<a name="34" id="anc34"></a>








257   static void assert_mark(bool check);
258 
259   // File manipulation.
260   bool  initialize() NOT_CDS_RETURN_(false);
261   bool  open_for_read();
<a name="35" id="anc35"></a><span class="line-modified">262   void  open_for_write();</span>
263   void  write_header();
264   void  write_region(int region, char* base, size_t size,
265                      bool read_only, bool allow_exec);
<a name="36" id="anc36"></a>
266   size_t write_archive_heap_regions(GrowableArray&lt;MemRegion&gt; *heap_mem,
267                                     GrowableArray&lt;ArchiveHeapOopmapInfo&gt; *oopmaps,
<a name="37" id="anc37"></a><span class="line-modified">268                                     int first_region_id, int max_num_regions,</span>
<span class="line-removed">269                                     bool print_log);</span>
270   void  write_bytes(const void* buffer, size_t count);
271   void  write_bytes_aligned(const void* buffer, size_t count);
<a name="38" id="anc38"></a><span class="line-modified">272   char* map_region(int i, char** top_ret);</span>
<span class="line-modified">273   void  map_heap_regions_impl() NOT_CDS_JAVA_HEAP_RETURN;</span>

274   void  map_heap_regions() NOT_CDS_JAVA_HEAP_RETURN;
275   void  fixup_mapped_heap_regions() NOT_CDS_JAVA_HEAP_RETURN;
276   void  patch_archived_heap_embedded_pointers() NOT_CDS_JAVA_HEAP_RETURN;
277   void  patch_archived_heap_embedded_pointers(MemRegion* ranges, int num_ranges,
278                                               int first_region_idx) NOT_CDS_JAVA_HEAP_RETURN;
279   bool  has_heap_regions()  NOT_CDS_JAVA_HEAP_RETURN_(false);
280   MemRegion get_heap_regions_range_with_current_oop_encoding_mode() NOT_CDS_JAVA_HEAP_RETURN_(MemRegion());
281   void  unmap_region(int i);
282   bool  verify_region_checksum(int i);
283   void  close();
284   bool  is_open() { return _file_open; }
285   ReservedSpace reserve_shared_memory();
286 
287   // JVM/TI RedefineClasses() support:
288   // Remap the shared readonly space to shared readwrite, private.
289   bool  remap_shared_readonly_as_readwrite();
290 
291   // Errors.
292   static void fail_stop(const char *msg, ...) ATTRIBUTE_PRINTF(1, 2);
293   static void fail_continue(const char *msg, ...) ATTRIBUTE_PRINTF(1, 2);
<a name="39" id="anc39"></a><span class="line-modified">294 </span>



295   bool is_in_shared_region(const void* p, int idx) NOT_CDS_RETURN_(false);
296 
297   // Stop CDS sharing and unmap CDS regions.
298   static void stop_sharing_and_unmap(const char* msg);
299 
300   static void allocate_shared_path_table();
<a name="40" id="anc40"></a>
301   static void check_nonempty_dir_in_shared_path_table();
302   bool validate_shared_path_table();
<a name="41" id="anc41"></a><span class="line-modified">303   static void update_shared_classpath(ClassPathEntry *cpe, SharedClassPathEntry* ent, TRAPS);</span>






304 
305 #if INCLUDE_JVMTI
<a name="42" id="anc42"></a><span class="line-modified">306   static ClassFileStream* open_stream_for_jvmti(InstanceKlass* ik, TRAPS);</span>
307 #endif
308 
309   static SharedClassPathEntry* shared_path(int index) {
<a name="43" id="anc43"></a><span class="line-modified">310     if (index &lt; 0) {</span>
<span class="line-removed">311       return NULL;</span>
<span class="line-removed">312     }</span>
<span class="line-removed">313     assert(index &lt; _shared_path_table_size, &quot;sanity&quot;);</span>
<span class="line-removed">314     char* p = (char*)_shared_path_table-&gt;data();</span>
<span class="line-removed">315     p += _shared_path_entry_size * index;</span>
<span class="line-removed">316     return (SharedClassPathEntry*)p;</span>
317   }
318 
319   static const char* shared_path_name(int index) {
320     assert(index &gt;= 0, &quot;Sanity&quot;);
321     return shared_path(index)-&gt;name();
322   }
323 
324   static int get_number_of_shared_paths() {
<a name="44" id="anc44"></a><span class="line-modified">325     return _shared_path_table_size;</span>
326   }
327 
328   char* region_addr(int idx);
329 
<a name="45" id="anc45"></a>















330  private:
<a name="46" id="anc46"></a>








331   bool  map_heap_data(MemRegion **heap_mem, int first, int max, int* num,
332                       bool is_open = false) NOT_CDS_JAVA_HEAP_RETURN_(false);
<a name="47" id="anc47"></a><span class="line-modified">333   bool  verify_mapped_heap_regions(int first, int num) NOT_CDS_JAVA_HEAP_RETURN_(false);</span>
<span class="line-modified">334   void  dealloc_archive_heap_regions(MemRegion* regions, int num, bool is_open) NOT_CDS_JAVA_HEAP_RETURN;</span>
<span class="line-modified">335 </span>
<span class="line-modified">336   CDSFileMapRegion* space_at(int i) {</span>
<span class="line-modified">337     return _header-&gt;space_at(i);</span>
<span class="line-modified">338   }</span>

339 
<a name="48" id="anc48"></a><span class="line-modified">340   narrowOop offset_of_space(CDSFileMapRegion* spc) {</span>
<span class="line-modified">341     return (narrowOop)(spc-&gt;_addr._offset);</span>
342   }
343 
344   // The starting address of spc, as calculated with CompressedOop::decode_non_null()
<a name="49" id="anc49"></a><span class="line-modified">345   address start_address_as_decoded_with_current_oop_encoding_mode(CDSFileMapRegion* spc) {</span>
346     return decode_start_address(spc, true);
347   }
348 
349   // The starting address of spc, as calculated with HeapShared::decode_from_archive()
<a name="50" id="anc50"></a><span class="line-modified">350   address start_address_as_decoded_from_archive(CDSFileMapRegion* spc) {</span>
351     return decode_start_address(spc, false);
352   }
353 
<a name="51" id="anc51"></a><span class="line-modified">354   address decode_start_address(CDSFileMapRegion* spc, bool with_current_oop_encoding_mode);</span>
355 
356 #if INCLUDE_JVMTI
357   static ClassPathEntry** _classpath_entries_for_jvmti;
358   static ClassPathEntry* get_classpath_entry_for_jvmti(int i, TRAPS);
359 #endif
360 };
361 
362 #endif // SHARE_MEMORY_FILEMAP_HPP
<a name="52" id="anc52"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="52" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/heapInspection.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="heapInspection.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="heapShared.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/heapInspection.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 30 #include &quot;oops/oop.hpp&quot;
 31 #include &quot;oops/annotations.hpp&quot;
 32 #include &quot;utilities/macros.hpp&quot;
 33 
 34 #if INCLUDE_SERVICES
 35 
 36 
 37 // HeapInspection
 38 
 39 // KlassInfoTable is a bucket hash table that
 40 // maps Klass*s to extra information:
 41 //    instance count and instance word size.
 42 //
 43 // A KlassInfoBucket is the head of a link list
 44 // of KlassInfoEntry&#39;s
 45 //
 46 // KlassInfoHisto is a growable array of pointers
 47 // to KlassInfoEntry&#39;s and is used to sort
 48 // the entries.
 49 
<span class="line-removed"> 50 #define HEAP_INSPECTION_COLUMNS_DO(f) \</span>
<span class="line-removed"> 51     f(inst_size, InstSize, \</span>
<span class="line-removed"> 52         &quot;Size of each object instance of the Java class&quot;) \</span>
<span class="line-removed"> 53     f(inst_count, InstCount, \</span>
<span class="line-removed"> 54         &quot;Number of object instances of the Java class&quot;)  \</span>
<span class="line-removed"> 55     f(inst_bytes, InstBytes, \</span>
<span class="line-removed"> 56         &quot;This is usually (InstSize * InstNum). The only exception is &quot; \</span>
<span class="line-removed"> 57         &quot;java.lang.Class, whose InstBytes also includes the slots &quot; \</span>
<span class="line-removed"> 58         &quot;used to store static fields. InstBytes is not counted in &quot; \</span>
<span class="line-removed"> 59         &quot;ROAll, RWAll or Total&quot;) \</span>
<span class="line-removed"> 60     f(mirror_bytes, Mirror, \</span>
<span class="line-removed"> 61         &quot;Size of the Klass::java_mirror() object&quot;) \</span>
<span class="line-removed"> 62     f(klass_bytes, KlassBytes, \</span>
<span class="line-removed"> 63         &quot;Size of the InstanceKlass or ArrayKlass for this class. &quot; \</span>
<span class="line-removed"> 64         &quot;Note that this includes VTab, ITab, OopMap&quot;) \</span>
<span class="line-removed"> 65     f(secondary_supers_bytes, K_secondary_supers, \</span>
<span class="line-removed"> 66         &quot;Number of bytes used by the Klass::secondary_supers() array&quot;) \</span>
<span class="line-removed"> 67     f(vtab_bytes, VTab, \</span>
<span class="line-removed"> 68         &quot;Size of the embedded vtable in InstanceKlass&quot;) \</span>
<span class="line-removed"> 69     f(itab_bytes, ITab, \</span>
<span class="line-removed"> 70         &quot;Size of the embedded itable in InstanceKlass&quot;) \</span>
<span class="line-removed"> 71     f(nonstatic_oopmap_bytes, OopMap, \</span>
<span class="line-removed"> 72         &quot;Size of the embedded nonstatic_oop_map in InstanceKlass&quot;) \</span>
<span class="line-removed"> 73     f(methods_array_bytes, IK_methods, \</span>
<span class="line-removed"> 74         &quot;Number of bytes used by the InstanceKlass::methods() array&quot;) \</span>
<span class="line-removed"> 75     f(method_ordering_bytes, IK_method_ordering, \</span>
<span class="line-removed"> 76         &quot;Number of bytes used by the InstanceKlass::method_ordering() array&quot;) \</span>
<span class="line-removed"> 77     f(default_methods_array_bytes, IK_default_methods, \</span>
<span class="line-removed"> 78         &quot;Number of bytes used by the InstanceKlass::default_methods() array&quot;) \</span>
<span class="line-removed"> 79     f(default_vtable_indices_bytes, IK_default_vtable_indices, \</span>
<span class="line-removed"> 80         &quot;Number of bytes used by the InstanceKlass::default_vtable_indices() array&quot;) \</span>
<span class="line-removed"> 81     f(local_interfaces_bytes, IK_local_interfaces, \</span>
<span class="line-removed"> 82         &quot;Number of bytes used by the InstanceKlass::local_interfaces() array&quot;) \</span>
<span class="line-removed"> 83     f(transitive_interfaces_bytes, IK_transitive_interfaces, \</span>
<span class="line-removed"> 84         &quot;Number of bytes used by the InstanceKlass::transitive_interfaces() array&quot;) \</span>
<span class="line-removed"> 85     f(fields_bytes, IK_fields, \</span>
<span class="line-removed"> 86         &quot;Number of bytes used by the InstanceKlass::fields() array&quot;) \</span>
<span class="line-removed"> 87     f(inner_classes_bytes, IK_inner_classes, \</span>
<span class="line-removed"> 88         &quot;Number of bytes used by the InstanceKlass::inner_classes() array&quot;) \</span>
<span class="line-removed"> 89     f(nest_members_bytes, IK_nest_members, \</span>
<span class="line-removed"> 90         &quot;Number of bytes used by the InstanceKlass::nest_members() array&quot;) \</span>
<span class="line-removed"> 91     f(signers_bytes, IK_signers, \</span>
<span class="line-removed"> 92         &quot;Number of bytes used by the InstanceKlass::singers() array&quot;) \</span>
<span class="line-removed"> 93     f(class_annotations_bytes, class_annotations, \</span>
<span class="line-removed"> 94         &quot;Size of class annotations&quot;) \</span>
<span class="line-removed"> 95     f(class_type_annotations_bytes, class_type_annotations, \</span>
<span class="line-removed"> 96         &quot;Size of class type annotations&quot;) \</span>
<span class="line-removed"> 97     f(fields_annotations_bytes, fields_annotations, \</span>
<span class="line-removed"> 98         &quot;Size of field annotations&quot;) \</span>
<span class="line-removed"> 99     f(fields_type_annotations_bytes, fields_type_annotations, \</span>
<span class="line-removed">100         &quot;Size of field type annotations&quot;) \</span>
<span class="line-removed">101     f(methods_annotations_bytes, methods_annotations, \</span>
<span class="line-removed">102         &quot;Size of method annotations&quot;) \</span>
<span class="line-removed">103     f(methods_parameter_annotations_bytes, methods_parameter_annotations, \</span>
<span class="line-removed">104         &quot;Size of method parameter annotations&quot;) \</span>
<span class="line-removed">105     f(methods_type_annotations_bytes, methods_type_annotations, \</span>
<span class="line-removed">106         &quot;Size of methods type annotations&quot;) \</span>
<span class="line-removed">107     f(methods_default_annotations_bytes, methods_default_annotations, \</span>
<span class="line-removed">108         &quot;Size of methods default annotations&quot;) \</span>
<span class="line-removed">109     f(annotations_bytes, annotations, \</span>
<span class="line-removed">110         &quot;Size of all annotations&quot;) \</span>
<span class="line-removed">111     f(cp_bytes, Cp, \</span>
<span class="line-removed">112         &quot;Size of InstanceKlass::constants()&quot;) \</span>
<span class="line-removed">113     f(cp_tags_bytes, CpTags, \</span>
<span class="line-removed">114         &quot;Size of InstanceKlass::constants()-&gt;tags()&quot;) \</span>
<span class="line-removed">115     f(cp_cache_bytes, CpCache, \</span>
<span class="line-removed">116         &quot;Size of InstanceKlass::constants()-&gt;cache()&quot;) \</span>
<span class="line-removed">117     f(cp_operands_bytes, CpOperands, \</span>
<span class="line-removed">118         &quot;Size of InstanceKlass::constants()-&gt;operands()&quot;) \</span>
<span class="line-removed">119     f(cp_refmap_bytes, CpRefMap, \</span>
<span class="line-removed">120         &quot;Size of InstanceKlass::constants()-&gt;reference_map()&quot;) \</span>
<span class="line-removed">121     f(cp_all_bytes, CpAll, \</span>
<span class="line-removed">122         &quot;Sum of Cp + CpTags + CpCache + CpOperands + CpRefMap&quot;) \</span>
<span class="line-removed">123     f(method_count, MethodCount, \</span>
<span class="line-removed">124         &quot;Number of methods in this class&quot;) \</span>
<span class="line-removed">125     f(method_bytes, MethodBytes, \</span>
<span class="line-removed">126         &quot;Size of the Method object&quot;) \</span>
<span class="line-removed">127     f(const_method_bytes, ConstMethod, \</span>
<span class="line-removed">128         &quot;Size of the ConstMethod object&quot;) \</span>
<span class="line-removed">129     f(method_data_bytes, MethodData, \</span>
<span class="line-removed">130         &quot;Size of the MethodData object&quot;) \</span>
<span class="line-removed">131     f(stackmap_bytes, StackMap, \</span>
<span class="line-removed">132         &quot;Size of the stackmap_data&quot;) \</span>
<span class="line-removed">133     f(bytecode_bytes, Bytecodes, \</span>
<span class="line-removed">134         &quot;Of the MethodBytes column, how much are the space taken up by bytecodes&quot;) \</span>
<span class="line-removed">135     f(method_all_bytes, MethodAll, \</span>
<span class="line-removed">136         &quot;Sum of MethodBytes + Constmethod + Stackmap + Methoddata&quot;) \</span>
<span class="line-removed">137     f(ro_bytes, ROAll, \</span>
<span class="line-removed">138         &quot;Size of all class meta data that could (potentially) be placed &quot; \</span>
<span class="line-removed">139         &quot;in read-only memory. (This could change with CDS design)&quot;) \</span>
<span class="line-removed">140     f(rw_bytes, RWAll, \</span>
<span class="line-removed">141         &quot;Size of all class meta data that must be placed in read/write &quot; \</span>
<span class="line-removed">142         &quot;memory. (This could change with CDS design) &quot;) \</span>
<span class="line-removed">143     f(total_bytes, Total, \</span>
<span class="line-removed">144         &quot;ROAll + RWAll. Note that this does NOT include InstBytes.&quot;)</span>
<span class="line-removed">145 </span>
<span class="line-removed">146 // Size statistics for a Klass - filled in by Klass::collect_statistics()</span>
<span class="line-removed">147 class KlassSizeStats {</span>
<span class="line-removed">148 public:</span>
<span class="line-removed">149 #define COUNT_KLASS_SIZE_STATS_FIELD(field, name, help)   _index_ ## field,</span>
<span class="line-removed">150 #define DECLARE_KLASS_SIZE_STATS_FIELD(field, name, help) julong _ ## field;</span>
<span class="line-removed">151 </span>
<span class="line-removed">152   enum {</span>
<span class="line-removed">153     HEAP_INSPECTION_COLUMNS_DO(COUNT_KLASS_SIZE_STATS_FIELD)</span>
<span class="line-removed">154     _num_columns</span>
<span class="line-removed">155   };</span>
<span class="line-removed">156 </span>
<span class="line-removed">157   HEAP_INSPECTION_COLUMNS_DO(DECLARE_KLASS_SIZE_STATS_FIELD)</span>
<span class="line-removed">158 </span>
<span class="line-removed">159   static int count(oop x);</span>
<span class="line-removed">160 </span>
<span class="line-removed">161   static int count_array(objArrayOop x);</span>
<span class="line-removed">162 </span>
<span class="line-removed">163   template &lt;class T&gt; static int count(T* x) {</span>
<span class="line-removed">164     return (HeapWordSize * ((x) ? (x)-&gt;size() : 0));</span>
<span class="line-removed">165   }</span>
<span class="line-removed">166 </span>
<span class="line-removed">167   template &lt;class T&gt; static int count_array(T* x) {</span>
<span class="line-removed">168     if (x == NULL) {</span>
<span class="line-removed">169       return 0;</span>
<span class="line-removed">170     }</span>
<span class="line-removed">171     if (x-&gt;length() == 0) {</span>
<span class="line-removed">172       // This is a shared array, e.g., Universe::the_empty_int_array(). Don&#39;t</span>
<span class="line-removed">173       // count it to avoid double-counting.</span>
<span class="line-removed">174       return 0;</span>
<span class="line-removed">175     }</span>
<span class="line-removed">176     return HeapWordSize * x-&gt;size();</span>
<span class="line-removed">177   }</span>
<span class="line-removed">178 };</span>
<span class="line-removed">179 </span>
<span class="line-removed">180 </span>
<span class="line-removed">181 </span>
<span class="line-removed">182 </span>
183 class KlassInfoEntry: public CHeapObj&lt;mtInternal&gt; {
184  private:
185   KlassInfoEntry* _next;
186   Klass*          _klass;
187   long            _instance_count;
188   size_t          _instance_words;
189   long            _index;
190   bool            _do_print; // True if we should print this class when printing the class hierarchy.
191   GrowableArray&lt;KlassInfoEntry*&gt;* _subclasses;
192 
193  public:
194   KlassInfoEntry(Klass* k, KlassInfoEntry* next) :
195     _next(next), _klass(k), _instance_count(0), _instance_words(0), _index(-1),
196     _do_print(false), _subclasses(NULL)
197   {}
198   ~KlassInfoEntry();
199   KlassInfoEntry* next() const   { return _next; }
200   bool is_equal(const Klass* k)  { return k == _klass; }
201   Klass* klass()  const      { return _klass; }
202   long count()    const      { return _instance_count; }
</pre>
<hr />
<pre>
262 
263 class KlassHierarchy : AllStatic {
264  public:
265   static void print_class_hierarchy(outputStream* st, bool print_interfaces,  bool print_subclasses,
266                                     char* classname);
267 
268  private:
269   static void set_do_print_for_class_hierarchy(KlassInfoEntry* cie, KlassInfoTable* cit,
270                                                bool print_subclasse);
271   static void print_class(outputStream* st, KlassInfoEntry* cie, bool print_subclasses);
272 };
273 
274 class KlassInfoHisto : public StackObj {
275  private:
276   static const int _histo_initial_size = 1000;
277   KlassInfoTable *_cit;
278   GrowableArray&lt;KlassInfoEntry*&gt;* _elements;
279   GrowableArray&lt;KlassInfoEntry*&gt;* elements() const { return _elements; }
280   static int sort_helper(KlassInfoEntry** e1, KlassInfoEntry** e2);
281   void print_elements(outputStream* st) const;
<span class="line-removed">282   void print_class_stats(outputStream* st, bool csv_format, const char *columns);</span>
<span class="line-removed">283   julong annotations_bytes(Array&lt;AnnotationArray*&gt;* p) const;</span>
<span class="line-removed">284   const char *_selected_columns;</span>
285   bool is_selected(const char *col_name);
<span class="line-removed">286   void print_title(outputStream* st, bool csv_format,</span>
<span class="line-removed">287                    bool selected_columns_table[], int width_table[],</span>
<span class="line-removed">288                    const char *name_table[]);</span>
289 
290   template &lt;class T&gt; static int count_bytes(T* x) {
291     return (HeapWordSize * ((x) ? (x)-&gt;size() : 0));
292   }
293 
294   template &lt;class T&gt; static int count_bytes_array(T* x) {
295     if (x == NULL) {
296       return 0;
297     }
298     if (x-&gt;length() == 0) {
299       // This is a shared array, e.g., Universe::the_empty_int_array(). Don&#39;t
300       // count it to avoid double-counting.
301       return 0;
302     }
303     return HeapWordSize * x-&gt;size();
304   }
305 
306   static void print_julong(outputStream* st, int width, julong n) {
307     int num_spaces = width - julong_width(n);
308     if (num_spaces &gt; 0) {
</pre>
<hr />
<pre>
320       n /= 10;
321       w += 1;
322     }
323     return w;
324   }
325 
326   static int col_width(julong n, const char *name) {
327     int w = julong_width(n);
328     int min = (int)(strlen(name));
329     if (w &lt; min) {
330         w = min;
331     }
332     // add a leading space for separation.
333     return w + 1;
334   }
335 
336  public:
337   KlassInfoHisto(KlassInfoTable* cit);
338   ~KlassInfoHisto();
339   void add(KlassInfoEntry* cie);
<span class="line-modified">340   void print_histo_on(outputStream* st, bool print_class_stats, bool csv_format, const char *columns);</span>
341   void sort();
342 };
343 
344 #endif // INCLUDE_SERVICES
345 
346 // These declarations are needed since the declaration of KlassInfoTable and
347 // KlassInfoClosure are guarded by #if INLCUDE_SERVICES
348 class KlassInfoTable;
349 class KlassInfoClosure;
350 
351 class HeapInspection : public StackObj {
<span class="line-removed">352   bool _csv_format; // &quot;comma separated values&quot; format for spreadsheet.</span>
<span class="line-removed">353   bool _print_help;</span>
<span class="line-removed">354   bool _print_class_stats;</span>
<span class="line-removed">355   const char* _columns;</span>
356  public:
<span class="line-removed">357   HeapInspection(bool csv_format, bool print_help,</span>
<span class="line-removed">358                  bool print_class_stats, const char *columns) :</span>
<span class="line-removed">359       _csv_format(csv_format), _print_help(print_help),</span>
<span class="line-removed">360       _print_class_stats(print_class_stats), _columns(columns) {}</span>
361   void heap_inspection(outputStream* st) NOT_SERVICES_RETURN;
362   size_t populate_table(KlassInfoTable* cit, BoolObjectClosure* filter = NULL) NOT_SERVICES_RETURN_(0);
363   static void find_instances_at_safepoint(Klass* k, GrowableArray&lt;oop&gt;* result) NOT_SERVICES_RETURN;
364  private:
365   void iterate_over_heap(KlassInfoTable* cit, BoolObjectClosure* filter = NULL);
366 };
367 
368 #endif // SHARE_MEMORY_HEAPINSPECTION_HPP
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 30 #include &quot;oops/oop.hpp&quot;
 31 #include &quot;oops/annotations.hpp&quot;
 32 #include &quot;utilities/macros.hpp&quot;
 33 
 34 #if INCLUDE_SERVICES
 35 
 36 
 37 // HeapInspection
 38 
 39 // KlassInfoTable is a bucket hash table that
 40 // maps Klass*s to extra information:
 41 //    instance count and instance word size.
 42 //
 43 // A KlassInfoBucket is the head of a link list
 44 // of KlassInfoEntry&#39;s
 45 //
 46 // KlassInfoHisto is a growable array of pointers
 47 // to KlassInfoEntry&#39;s and is used to sort
 48 // the entries.
 49 





































































































































 50 class KlassInfoEntry: public CHeapObj&lt;mtInternal&gt; {
 51  private:
 52   KlassInfoEntry* _next;
 53   Klass*          _klass;
 54   long            _instance_count;
 55   size_t          _instance_words;
 56   long            _index;
 57   bool            _do_print; // True if we should print this class when printing the class hierarchy.
 58   GrowableArray&lt;KlassInfoEntry*&gt;* _subclasses;
 59 
 60  public:
 61   KlassInfoEntry(Klass* k, KlassInfoEntry* next) :
 62     _next(next), _klass(k), _instance_count(0), _instance_words(0), _index(-1),
 63     _do_print(false), _subclasses(NULL)
 64   {}
 65   ~KlassInfoEntry();
 66   KlassInfoEntry* next() const   { return _next; }
 67   bool is_equal(const Klass* k)  { return k == _klass; }
 68   Klass* klass()  const      { return _klass; }
 69   long count()    const      { return _instance_count; }
</pre>
<hr />
<pre>
129 
130 class KlassHierarchy : AllStatic {
131  public:
132   static void print_class_hierarchy(outputStream* st, bool print_interfaces,  bool print_subclasses,
133                                     char* classname);
134 
135  private:
136   static void set_do_print_for_class_hierarchy(KlassInfoEntry* cie, KlassInfoTable* cit,
137                                                bool print_subclasse);
138   static void print_class(outputStream* st, KlassInfoEntry* cie, bool print_subclasses);
139 };
140 
141 class KlassInfoHisto : public StackObj {
142  private:
143   static const int _histo_initial_size = 1000;
144   KlassInfoTable *_cit;
145   GrowableArray&lt;KlassInfoEntry*&gt;* _elements;
146   GrowableArray&lt;KlassInfoEntry*&gt;* elements() const { return _elements; }
147   static int sort_helper(KlassInfoEntry** e1, KlassInfoEntry** e2);
148   void print_elements(outputStream* st) const;



149   bool is_selected(const char *col_name);



150 
151   template &lt;class T&gt; static int count_bytes(T* x) {
152     return (HeapWordSize * ((x) ? (x)-&gt;size() : 0));
153   }
154 
155   template &lt;class T&gt; static int count_bytes_array(T* x) {
156     if (x == NULL) {
157       return 0;
158     }
159     if (x-&gt;length() == 0) {
160       // This is a shared array, e.g., Universe::the_empty_int_array(). Don&#39;t
161       // count it to avoid double-counting.
162       return 0;
163     }
164     return HeapWordSize * x-&gt;size();
165   }
166 
167   static void print_julong(outputStream* st, int width, julong n) {
168     int num_spaces = width - julong_width(n);
169     if (num_spaces &gt; 0) {
</pre>
<hr />
<pre>
181       n /= 10;
182       w += 1;
183     }
184     return w;
185   }
186 
187   static int col_width(julong n, const char *name) {
188     int w = julong_width(n);
189     int min = (int)(strlen(name));
190     if (w &lt; min) {
191         w = min;
192     }
193     // add a leading space for separation.
194     return w + 1;
195   }
196 
197  public:
198   KlassInfoHisto(KlassInfoTable* cit);
199   ~KlassInfoHisto();
200   void add(KlassInfoEntry* cie);
<span class="line-modified">201   void print_histo_on(outputStream* st);</span>
202   void sort();
203 };
204 
205 #endif // INCLUDE_SERVICES
206 
207 // These declarations are needed since the declaration of KlassInfoTable and
208 // KlassInfoClosure are guarded by #if INLCUDE_SERVICES
209 class KlassInfoTable;
210 class KlassInfoClosure;
211 
212 class HeapInspection : public StackObj {




213  public:




214   void heap_inspection(outputStream* st) NOT_SERVICES_RETURN;
215   size_t populate_table(KlassInfoTable* cit, BoolObjectClosure* filter = NULL) NOT_SERVICES_RETURN_(0);
216   static void find_instances_at_safepoint(Klass* k, GrowableArray&lt;oop&gt;* result) NOT_SERVICES_RETURN;
217  private:
218   void iterate_over_heap(KlassInfoTable* cit, BoolObjectClosure* filter = NULL);
219 };
220 
221 #endif // SHARE_MEMORY_HEAPINSPECTION_HPP
</pre>
</td>
</tr>
</table>
<center><a href="heapInspection.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="heapShared.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
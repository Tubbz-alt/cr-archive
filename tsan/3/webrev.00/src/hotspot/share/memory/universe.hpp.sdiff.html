<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/universe.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="universe.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="virtualspace.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/universe.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_MEMORY_UNIVERSE_HPP
 26 #define SHARE_MEMORY_UNIVERSE_HPP
 27 

 28 #include &quot;oops/array.hpp&quot;
 29 #include &quot;runtime/handles.hpp&quot;
 30 #include &quot;utilities/growableArray.hpp&quot;
 31 
 32 // Universe is a name space holding known system classes and objects in the VM.
 33 //
 34 // Loaded classes are accessible through the SystemDictionary.
 35 //
 36 // The object heap is allocated and accessed through Universe, and various allocation
 37 // support is provided. Allocation by the interpreter and compiled code is done inline
 38 // and bails out to Scavenge::invoke_and_allocate.
 39 
 40 class CollectedHeap;
 41 class DeferredObjAllocEvent;
 42 
 43 
 44 // A helper class for caching a Method* when the user of the cache
 45 // only cares about the latest version of the Method*.  This cache safely
 46 // interacts with the RedefineClasses API.
 47 
</pre>
<hr />
<pre>
 53   int                   _method_idnum;
 54 
 55  public:
 56   LatestMethodCache()   { _klass = NULL; _method_idnum = -1; }
 57   ~LatestMethodCache()  { _klass = NULL; _method_idnum = -1; }
 58 
 59   void   init(Klass* k, Method* m);
 60   Klass* klass() const           { return _klass; }
 61   int    method_idnum() const    { return _method_idnum; }
 62 
 63   Method* get_method();
 64 
 65   // CDS support.  Replace the klass in this with the archive version
 66   // could use this for Enhanced Class Redefinition also.
 67   void serialize(SerializeClosure* f) {
 68     f-&gt;do_ptr((void**)&amp;_klass);
 69   }
 70   void metaspace_pointers_do(MetaspaceClosure* it);
 71 };
 72 
<span class="line-removed"> 73 </span>
<span class="line-removed"> 74 // For UseCompressedOops.</span>
<span class="line-removed"> 75 struct NarrowPtrStruct {</span>
<span class="line-removed"> 76   // Base address for oop-within-java-object materialization.</span>
<span class="line-removed"> 77   // NULL if using wide oops or zero based narrow oops.</span>
<span class="line-removed"> 78   address _base;</span>
<span class="line-removed"> 79   // Number of shift bits for encoding/decoding narrow ptrs.</span>
<span class="line-removed"> 80   // 0 if using wide ptrs or zero based unscaled narrow ptrs,</span>
<span class="line-removed"> 81   // LogMinObjAlignmentInBytes/LogKlassAlignmentInBytes otherwise.</span>
<span class="line-removed"> 82   int     _shift;</span>
<span class="line-removed"> 83   // Generate code with implicit null checks for narrow ptrs.</span>
<span class="line-removed"> 84   bool    _use_implicit_null_checks;</span>
<span class="line-removed"> 85 };</span>
<span class="line-removed"> 86 </span>
<span class="line-removed"> 87 enum VerifyOption {</span>
<span class="line-removed"> 88       VerifyOption_Default = 0,</span>
<span class="line-removed"> 89 </span>
<span class="line-removed"> 90       // G1</span>
<span class="line-removed"> 91       VerifyOption_G1UsePrevMarking = VerifyOption_Default,</span>
<span class="line-removed"> 92       VerifyOption_G1UseNextMarking = VerifyOption_G1UsePrevMarking + 1,</span>
<span class="line-removed"> 93       VerifyOption_G1UseFullMarking = VerifyOption_G1UseNextMarking + 1</span>
<span class="line-removed"> 94 };</span>
<span class="line-removed"> 95 </span>
 96 class Universe: AllStatic {
 97   // Ugh.  Universe is much too friendly.
 98   friend class MarkSweep;
 99   friend class oopDesc;
100   friend class ClassLoader;
101   friend class SystemDictionary;
102   friend class ReservedHeapSpace;
103   friend class VMStructs;
104   friend class VM_PopulateDumpSharedSpace;
105   friend class Metaspace;
106   friend class MetaspaceShared;
107 
108   friend jint  universe_init();
109   friend void  universe2_init();
110   friend bool  universe_post_init();
111   friend void  universe_post_module_init();
112 
113  private:
114   // Known classes in the VM
115   static Klass* _typeArrayKlassObjs[T_LONG+1];
</pre>
<hr />
<pre>
165   static objArrayOop   _preallocated_out_of_memory_error_array;
166 
167   // number of preallocated error objects available for use
168   static volatile jint _preallocated_out_of_memory_error_avail_count;
169 
170   static oop          _null_ptr_exception_instance;   // preallocated exception object
171   static oop          _arithmetic_exception_instance; // preallocated exception object
172   static oop          _virtual_machine_error_instance; // preallocated exception object
173   // The object used as an exception dummy when exceptions are thrown for
174   // the vm thread.
175   static oop          _vm_exception;
176 
177   // References waiting to be transferred to the ReferenceHandler
178   static oop          _reference_pending_list;
179 
180   // The particular choice of collected heap.
181   static CollectedHeap* _collectedHeap;
182 
183   static intptr_t _non_oop_bits;
184 
<span class="line-removed">185   // For UseCompressedOops.</span>
<span class="line-removed">186   static struct NarrowPtrStruct _narrow_oop;</span>
<span class="line-removed">187   // For UseCompressedClassPointers.</span>
<span class="line-removed">188   static struct NarrowPtrStruct _narrow_klass;</span>
<span class="line-removed">189   static address _narrow_ptrs_base;</span>
<span class="line-removed">190   // CompressedClassSpaceSize set to 1GB, but appear 3GB away from _narrow_ptrs_base during CDS dump.</span>
<span class="line-removed">191   static uint64_t _narrow_klass_range;</span>
192   // array of dummy objects used with +FullGCAlot
193   debug_only(static objArrayOop _fullgc_alot_dummy_array;)
194   // index of next entry to clear
195   debug_only(static int         _fullgc_alot_dummy_next;)
196 
197   // Compiler/dispatch support
198   static int  _base_vtable_size;                      // Java vtbl size of klass Object (in words)
199 
200   // Initialization
201   static bool _bootstrapping;                         // true during genesis
202   static bool _module_initialized;                    // true after call_initPhase2 called
203   static bool _fully_initialized;                     // true after universe_init and initialize_vtables called
204 
205   // the array of preallocated errors with backtraces
206   static objArrayOop  preallocated_out_of_memory_errors()     { return _preallocated_out_of_memory_error_array; }
207 
208   // generate an out of memory error; if possible using an error with preallocated backtrace;
209   // otherwise return the given default error.
210   static oop        gen_out_of_memory_error(oop default_err);
211 
212   // Historic gc information
213   static size_t _heap_capacity_at_last_gc;
214   static size_t _heap_used_at_last_gc;
215 
<span class="line-removed">216   static CollectedHeap* create_heap();</span>
217   static jint initialize_heap();

218   static void initialize_basic_type_mirrors(TRAPS);
219   static void fixup_mirrors(TRAPS);
220 
221   static void reinitialize_vtable_of(Klass* k, TRAPS);
222   static void reinitialize_vtables(TRAPS);
223   static void reinitialize_itables(TRAPS);
224   static void compute_base_vtable_size();             // compute vtable size of class Object
225 
226   static void genesis(TRAPS);                         // Create the initial world
227 
228   // Mirrors for primitive classes (created eagerly)
229   static oop check_mirror(oop m) {
230     assert(m != NULL, &quot;mirror not initialized&quot;);
231     return m;
232   }
233 
<span class="line-removed">234   static void     set_narrow_oop_base(address base) {</span>
<span class="line-removed">235     assert(UseCompressedOops, &quot;no compressed oops?&quot;);</span>
<span class="line-removed">236     _narrow_oop._base    = base;</span>
<span class="line-removed">237   }</span>
<span class="line-removed">238   static void     set_narrow_klass_base(address base) {</span>
<span class="line-removed">239     assert(UseCompressedClassPointers, &quot;no compressed klass ptrs?&quot;);</span>
<span class="line-removed">240     _narrow_klass._base   = base;</span>
<span class="line-removed">241   }</span>
<span class="line-removed">242   static void     set_narrow_klass_range(uint64_t range) {</span>
<span class="line-removed">243      assert(UseCompressedClassPointers, &quot;no compressed klass ptrs?&quot;);</span>
<span class="line-removed">244      _narrow_klass_range = range;</span>
<span class="line-removed">245   }</span>
<span class="line-removed">246   static void     set_narrow_oop_use_implicit_null_checks(bool use) {</span>
<span class="line-removed">247     assert(UseCompressedOops, &quot;no compressed ptrs?&quot;);</span>
<span class="line-removed">248     _narrow_oop._use_implicit_null_checks   = use;</span>
<span class="line-removed">249   }</span>
<span class="line-removed">250 </span>
251   // Debugging
252   static int _verify_count;                           // number of verifies done
253 
254   // True during call to verify().  Should only be set/cleared in verify().
255   static bool _verify_in_progress;
256   static long verify_flags;
257 
258   static uintptr_t _verify_oop_mask;
259   static uintptr_t _verify_oop_bits;
260 

261   static void calculate_verify_data(HeapWord* low_boundary, HeapWord* high_boundary) PRODUCT_RETURN;
262 
<span class="line-removed">263  public:</span>
264   // Known classes in the VM
265   static Klass* boolArrayKlassObj()                 { return typeArrayKlassObj(T_BOOLEAN); }
266   static Klass* byteArrayKlassObj()                 { return typeArrayKlassObj(T_BYTE); }
267   static Klass* charArrayKlassObj()                 { return typeArrayKlassObj(T_CHAR); }
268   static Klass* intArrayKlassObj()                  { return typeArrayKlassObj(T_INT); }
269   static Klass* shortArrayKlassObj()                { return typeArrayKlassObj(T_SHORT); }
270   static Klass* longArrayKlassObj()                 { return typeArrayKlassObj(T_LONG); }
271   static Klass* floatArrayKlassObj()                { return typeArrayKlassObj(T_FLOAT); }
272   static Klass* doubleArrayKlassObj()               { return typeArrayKlassObj(T_DOUBLE); }
273 
274   static Klass* objectArrayKlassObj()               { return _objectArrayKlassObj; }
275 
276   static Klass* typeArrayKlassObj(BasicType t) {
277     assert((uint)t &gt;= T_BOOLEAN, &quot;range check for type: %s&quot;, type2name(t));
278     assert((uint)t &lt; T_LONG+1,   &quot;range check for type: %s&quot;, type2name(t));
279     assert(_typeArrayKlassObjs[t] != NULL, &quot;domain check&quot;);
280     return _typeArrayKlassObjs[t];
281   }
282 
283   // Known objects in the VM
</pre>
<hr />
<pre>
354   static Array&lt;Method*&gt;*         the_empty_method_array() { return _the_empty_method_array; }
355   static Array&lt;Klass*&gt;*          the_empty_klass_array()  { return _the_empty_klass_array; }
356   static Array&lt;InstanceKlass*&gt;*  the_empty_instance_klass_array() { return _the_empty_instance_klass_array; }
357 
358   // OutOfMemoryError support. Returns an error with the required message. The returned error
359   // may or may not have a backtrace. If error has a backtrace then the stack trace is already
360   // filled in.
361   static oop out_of_memory_error_java_heap()          { return gen_out_of_memory_error(_out_of_memory_error_java_heap);  }
362   static oop out_of_memory_error_metaspace()          { return gen_out_of_memory_error(_out_of_memory_error_metaspace);   }
363   static oop out_of_memory_error_class_metaspace()    { return gen_out_of_memory_error(_out_of_memory_error_class_metaspace);   }
364   static oop out_of_memory_error_array_size()         { return gen_out_of_memory_error(_out_of_memory_error_array_size); }
365   static oop out_of_memory_error_gc_overhead_limit()  { return gen_out_of_memory_error(_out_of_memory_error_gc_overhead_limit);  }
366   static oop out_of_memory_error_realloc_objects()    { return gen_out_of_memory_error(_out_of_memory_error_realloc_objects);  }
367   // Throw default _out_of_memory_error_retry object as it will never propagate out of the VM
368   static oop out_of_memory_error_retry()              { return _out_of_memory_error_retry;  }
369   static oop delayed_stack_overflow_error_message()   { return _delayed_stack_overflow_error_message; }
370 
371   // The particular choice of collected heap.
372   static CollectedHeap* heap() { return _collectedHeap; }
373 
<span class="line-removed">374   // For UseCompressedOops</span>
<span class="line-removed">375   // Narrow Oop encoding mode:</span>
<span class="line-removed">376   // 0 - Use 32-bits oops without encoding when</span>
<span class="line-removed">377   //     NarrowOopHeapBaseMin + heap_size &lt; 4Gb</span>
<span class="line-removed">378   // 1 - Use zero based compressed oops with encoding when</span>
<span class="line-removed">379   //     NarrowOopHeapBaseMin + heap_size &lt; 32Gb</span>
<span class="line-removed">380   // 2 - Use compressed oops with disjoint heap base if</span>
<span class="line-removed">381   //     base is 32G-aligned and base &gt; 0. This allows certain</span>
<span class="line-removed">382   //     optimizations in encoding/decoding.</span>
<span class="line-removed">383   //     Disjoint: Bits used in base are disjoint from bits used</span>
<span class="line-removed">384   //     for oops ==&gt; oop = (cOop &lt;&lt; 3) | base.  One can disjoint</span>
<span class="line-removed">385   //     the bits of an oop into base and compressed oop.</span>
<span class="line-removed">386   // 3 - Use compressed oops with heap base + encoding.</span>
<span class="line-removed">387   enum NARROW_OOP_MODE {</span>
<span class="line-removed">388     UnscaledNarrowOop  = 0,</span>
<span class="line-removed">389     ZeroBasedNarrowOop = 1,</span>
<span class="line-removed">390     DisjointBaseNarrowOop = 2,</span>
<span class="line-removed">391     HeapBasedNarrowOop = 3,</span>
<span class="line-removed">392     AnyNarrowOopMode = 4</span>
<span class="line-removed">393   };</span>
<span class="line-removed">394   static NARROW_OOP_MODE narrow_oop_mode();</span>
<span class="line-removed">395   static const char* narrow_oop_mode_to_string(NARROW_OOP_MODE mode);</span>
<span class="line-removed">396   static address  narrow_oop_base()                  { return  _narrow_oop._base; }</span>
<span class="line-removed">397   // Test whether bits of addr and possible offsets into the heap overlap.</span>
<span class="line-removed">398   static bool     is_disjoint_heap_base_address(address addr) {</span>
<span class="line-removed">399     return (((uint64_t)(intptr_t)addr) &amp;</span>
<span class="line-removed">400             (((uint64_t)UCONST64(0xFFFFffffFFFFffff)) &gt;&gt; (32-LogMinObjAlignmentInBytes))) == 0;</span>
<span class="line-removed">401   }</span>
<span class="line-removed">402   // Check for disjoint base compressed oops.</span>
<span class="line-removed">403   static bool     narrow_oop_base_disjoint()        {</span>
<span class="line-removed">404     return _narrow_oop._base != NULL &amp;&amp; is_disjoint_heap_base_address(_narrow_oop._base);</span>
<span class="line-removed">405   }</span>
<span class="line-removed">406   // Check for real heapbased compressed oops.</span>
<span class="line-removed">407   // We must subtract the base as the bits overlap.</span>
<span class="line-removed">408   // If we negate above function, we also get unscaled and zerobased.</span>
<span class="line-removed">409   static bool     narrow_oop_base_overlaps()          {</span>
<span class="line-removed">410     return _narrow_oop._base != NULL &amp;&amp; !is_disjoint_heap_base_address(_narrow_oop._base);</span>
<span class="line-removed">411   }</span>
<span class="line-removed">412   static bool  is_narrow_oop_base(void* addr)             { return (narrow_oop_base() == (address)addr); }</span>
<span class="line-removed">413   static int      narrow_oop_shift()                      { return  _narrow_oop._shift; }</span>
<span class="line-removed">414   static bool     narrow_oop_use_implicit_null_checks()   { return  _narrow_oop._use_implicit_null_checks; }</span>
<span class="line-removed">415 </span>
<span class="line-removed">416   // For UseCompressedClassPointers</span>
<span class="line-removed">417   static address  narrow_klass_base()                     { return  _narrow_klass._base; }</span>
<span class="line-removed">418   static uint64_t narrow_klass_range()                    { return  _narrow_klass_range; }</span>
<span class="line-removed">419   static int      narrow_klass_shift()                    { return  _narrow_klass._shift; }</span>
<span class="line-removed">420 </span>
<span class="line-removed">421   static address* narrow_ptrs_base_addr()                 { return &amp;_narrow_ptrs_base; }</span>
<span class="line-removed">422   static void     set_narrow_ptrs_base(address a)         { _narrow_ptrs_base = a; }</span>
<span class="line-removed">423   static address  narrow_ptrs_base()                      { return _narrow_ptrs_base; }</span>
<span class="line-removed">424 </span>
<span class="line-removed">425   static void     print_compressed_oops_mode(outputStream* st);</span>
<span class="line-removed">426 </span>
<span class="line-removed">427   // this is set in vm_version on sparc (and then reset in universe afaict)</span>
<span class="line-removed">428   static void     set_narrow_oop_shift(int shift)         {</span>
<span class="line-removed">429     _narrow_oop._shift   = shift;</span>
<span class="line-removed">430   }</span>
<span class="line-removed">431 </span>
<span class="line-removed">432   static void     set_narrow_klass_shift(int shift)       {</span>
<span class="line-removed">433     assert(shift == 0 || shift == LogKlassAlignmentInBytes, &quot;invalid shift for klass ptrs&quot;);</span>
<span class="line-removed">434     _narrow_klass._shift   = shift;</span>
<span class="line-removed">435   }</span>
<span class="line-removed">436 </span>
437   // Reserve Java heap and determine CompressedOops mode
<span class="line-modified">438   static ReservedSpace reserve_heap(size_t heap_size, size_t alignment);</span>
439 
440   // Historic gc information
441   static size_t get_heap_free_at_last_gc()             { return _heap_capacity_at_last_gc - _heap_used_at_last_gc; }
442   static size_t get_heap_used_at_last_gc()             { return _heap_used_at_last_gc; }
443   static void update_heap_info_at_gc();
444 
445   // Testers
446   static bool is_bootstrapping()                      { return _bootstrapping; }
447   static bool is_module_initialized()                 { return _module_initialized; }
448   static bool is_fully_initialized()                  { return _fully_initialized; }
449 
450   static bool        on_page_boundary(void* addr);
451   static bool        should_fill_in_stack_trace(Handle throwable);
452   static void check_alignment(uintx size, uintx alignment, const char* name);
453 
454   // Iteration
455 
456   // Apply &quot;f&quot; to the addresses of all the direct heap pointers maintained
457   // as static fields of &quot;Universe&quot;.
458   static void oops_do(OopClosure* f);
</pre>
<hr />
<pre>
461   static void serialize(SerializeClosure* f);
462 
463   // Apply &quot;f&quot; to all klasses for basic types (classes not present in
464   // SystemDictionary).
465   static void basic_type_classes_do(void f(Klass*));
466   static void basic_type_classes_do(KlassClosure* closure);
467   static void metaspace_pointers_do(MetaspaceClosure* it);
468 
469   // Debugging
470   enum VERIFY_FLAGS {
471     Verify_Threads = 1,
472     Verify_Heap = 2,
473     Verify_SymbolTable = 4,
474     Verify_StringTable = 8,
475     Verify_CodeCache = 16,
476     Verify_SystemDictionary = 32,
477     Verify_ClassLoaderDataGraph = 64,
478     Verify_MetaspaceUtils = 128,
479     Verify_JNIHandles = 256,
480     Verify_CodeCacheOops = 512,

481     Verify_All = -1
482   };
483   static void initialize_verify_flags();
484   static bool should_verify_subset(uint subset);
485   static bool verify_in_progress() { return _verify_in_progress; }
486   static void verify(VerifyOption option, const char* prefix);
487   static void verify(const char* prefix) {
488     verify(VerifyOption_Default, prefix);
489   }
490   static void verify() {
491     verify(&quot;&quot;);
492   }
493 
494   static int  verify_count()       { return _verify_count; }
495   static void print_on(outputStream* st);
496   static void print_heap_at_SIGBREAK();
497   static void print_heap_before_gc();
498   static void print_heap_after_gc();
499 
500   // Change the number of dummy objects kept reachable by the full gc dummy
</pre>
</td>
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_MEMORY_UNIVERSE_HPP
 26 #define SHARE_MEMORY_UNIVERSE_HPP
 27 
<span class="line-added"> 28 #include &quot;gc/shared/verifyOption.hpp&quot;</span>
 29 #include &quot;oops/array.hpp&quot;
 30 #include &quot;runtime/handles.hpp&quot;
 31 #include &quot;utilities/growableArray.hpp&quot;
 32 
 33 // Universe is a name space holding known system classes and objects in the VM.
 34 //
 35 // Loaded classes are accessible through the SystemDictionary.
 36 //
 37 // The object heap is allocated and accessed through Universe, and various allocation
 38 // support is provided. Allocation by the interpreter and compiled code is done inline
 39 // and bails out to Scavenge::invoke_and_allocate.
 40 
 41 class CollectedHeap;
 42 class DeferredObjAllocEvent;
 43 
 44 
 45 // A helper class for caching a Method* when the user of the cache
 46 // only cares about the latest version of the Method*.  This cache safely
 47 // interacts with the RedefineClasses API.
 48 
</pre>
<hr />
<pre>
 54   int                   _method_idnum;
 55 
 56  public:
 57   LatestMethodCache()   { _klass = NULL; _method_idnum = -1; }
 58   ~LatestMethodCache()  { _klass = NULL; _method_idnum = -1; }
 59 
 60   void   init(Klass* k, Method* m);
 61   Klass* klass() const           { return _klass; }
 62   int    method_idnum() const    { return _method_idnum; }
 63 
 64   Method* get_method();
 65 
 66   // CDS support.  Replace the klass in this with the archive version
 67   // could use this for Enhanced Class Redefinition also.
 68   void serialize(SerializeClosure* f) {
 69     f-&gt;do_ptr((void**)&amp;_klass);
 70   }
 71   void metaspace_pointers_do(MetaspaceClosure* it);
 72 };
 73 























 74 class Universe: AllStatic {
 75   // Ugh.  Universe is much too friendly.
 76   friend class MarkSweep;
 77   friend class oopDesc;
 78   friend class ClassLoader;
 79   friend class SystemDictionary;
 80   friend class ReservedHeapSpace;
 81   friend class VMStructs;
 82   friend class VM_PopulateDumpSharedSpace;
 83   friend class Metaspace;
 84   friend class MetaspaceShared;
 85 
 86   friend jint  universe_init();
 87   friend void  universe2_init();
 88   friend bool  universe_post_init();
 89   friend void  universe_post_module_init();
 90 
 91  private:
 92   // Known classes in the VM
 93   static Klass* _typeArrayKlassObjs[T_LONG+1];
</pre>
<hr />
<pre>
143   static objArrayOop   _preallocated_out_of_memory_error_array;
144 
145   // number of preallocated error objects available for use
146   static volatile jint _preallocated_out_of_memory_error_avail_count;
147 
148   static oop          _null_ptr_exception_instance;   // preallocated exception object
149   static oop          _arithmetic_exception_instance; // preallocated exception object
150   static oop          _virtual_machine_error_instance; // preallocated exception object
151   // The object used as an exception dummy when exceptions are thrown for
152   // the vm thread.
153   static oop          _vm_exception;
154 
155   // References waiting to be transferred to the ReferenceHandler
156   static oop          _reference_pending_list;
157 
158   // The particular choice of collected heap.
159   static CollectedHeap* _collectedHeap;
160 
161   static intptr_t _non_oop_bits;
162 







163   // array of dummy objects used with +FullGCAlot
164   debug_only(static objArrayOop _fullgc_alot_dummy_array;)
165   // index of next entry to clear
166   debug_only(static int         _fullgc_alot_dummy_next;)
167 
168   // Compiler/dispatch support
169   static int  _base_vtable_size;                      // Java vtbl size of klass Object (in words)
170 
171   // Initialization
172   static bool _bootstrapping;                         // true during genesis
173   static bool _module_initialized;                    // true after call_initPhase2 called
174   static bool _fully_initialized;                     // true after universe_init and initialize_vtables called
175 
176   // the array of preallocated errors with backtraces
177   static objArrayOop  preallocated_out_of_memory_errors()     { return _preallocated_out_of_memory_error_array; }
178 
179   // generate an out of memory error; if possible using an error with preallocated backtrace;
180   // otherwise return the given default error.
181   static oop        gen_out_of_memory_error(oop default_err);
182 
183   // Historic gc information
184   static size_t _heap_capacity_at_last_gc;
185   static size_t _heap_used_at_last_gc;
186 

187   static jint initialize_heap();
<span class="line-added">188   static void initialize_tlab();</span>
189   static void initialize_basic_type_mirrors(TRAPS);
190   static void fixup_mirrors(TRAPS);
191 
192   static void reinitialize_vtable_of(Klass* k, TRAPS);
193   static void reinitialize_vtables(TRAPS);
194   static void reinitialize_itables(TRAPS);
195   static void compute_base_vtable_size();             // compute vtable size of class Object
196 
197   static void genesis(TRAPS);                         // Create the initial world
198 
199   // Mirrors for primitive classes (created eagerly)
200   static oop check_mirror(oop m) {
201     assert(m != NULL, &quot;mirror not initialized&quot;);
202     return m;
203   }
204 

















205   // Debugging
206   static int _verify_count;                           // number of verifies done
207 
208   // True during call to verify().  Should only be set/cleared in verify().
209   static bool _verify_in_progress;
210   static long verify_flags;
211 
212   static uintptr_t _verify_oop_mask;
213   static uintptr_t _verify_oop_bits;
214 
<span class="line-added">215  public:</span>
216   static void calculate_verify_data(HeapWord* low_boundary, HeapWord* high_boundary) PRODUCT_RETURN;
217 

218   // Known classes in the VM
219   static Klass* boolArrayKlassObj()                 { return typeArrayKlassObj(T_BOOLEAN); }
220   static Klass* byteArrayKlassObj()                 { return typeArrayKlassObj(T_BYTE); }
221   static Klass* charArrayKlassObj()                 { return typeArrayKlassObj(T_CHAR); }
222   static Klass* intArrayKlassObj()                  { return typeArrayKlassObj(T_INT); }
223   static Klass* shortArrayKlassObj()                { return typeArrayKlassObj(T_SHORT); }
224   static Klass* longArrayKlassObj()                 { return typeArrayKlassObj(T_LONG); }
225   static Klass* floatArrayKlassObj()                { return typeArrayKlassObj(T_FLOAT); }
226   static Klass* doubleArrayKlassObj()               { return typeArrayKlassObj(T_DOUBLE); }
227 
228   static Klass* objectArrayKlassObj()               { return _objectArrayKlassObj; }
229 
230   static Klass* typeArrayKlassObj(BasicType t) {
231     assert((uint)t &gt;= T_BOOLEAN, &quot;range check for type: %s&quot;, type2name(t));
232     assert((uint)t &lt; T_LONG+1,   &quot;range check for type: %s&quot;, type2name(t));
233     assert(_typeArrayKlassObjs[t] != NULL, &quot;domain check&quot;);
234     return _typeArrayKlassObjs[t];
235   }
236 
237   // Known objects in the VM
</pre>
<hr />
<pre>
308   static Array&lt;Method*&gt;*         the_empty_method_array() { return _the_empty_method_array; }
309   static Array&lt;Klass*&gt;*          the_empty_klass_array()  { return _the_empty_klass_array; }
310   static Array&lt;InstanceKlass*&gt;*  the_empty_instance_klass_array() { return _the_empty_instance_klass_array; }
311 
312   // OutOfMemoryError support. Returns an error with the required message. The returned error
313   // may or may not have a backtrace. If error has a backtrace then the stack trace is already
314   // filled in.
315   static oop out_of_memory_error_java_heap()          { return gen_out_of_memory_error(_out_of_memory_error_java_heap);  }
316   static oop out_of_memory_error_metaspace()          { return gen_out_of_memory_error(_out_of_memory_error_metaspace);   }
317   static oop out_of_memory_error_class_metaspace()    { return gen_out_of_memory_error(_out_of_memory_error_class_metaspace);   }
318   static oop out_of_memory_error_array_size()         { return gen_out_of_memory_error(_out_of_memory_error_array_size); }
319   static oop out_of_memory_error_gc_overhead_limit()  { return gen_out_of_memory_error(_out_of_memory_error_gc_overhead_limit);  }
320   static oop out_of_memory_error_realloc_objects()    { return gen_out_of_memory_error(_out_of_memory_error_realloc_objects);  }
321   // Throw default _out_of_memory_error_retry object as it will never propagate out of the VM
322   static oop out_of_memory_error_retry()              { return _out_of_memory_error_retry;  }
323   static oop delayed_stack_overflow_error_message()   { return _delayed_stack_overflow_error_message; }
324 
325   // The particular choice of collected heap.
326   static CollectedHeap* heap() { return _collectedHeap; }
327 































































328   // Reserve Java heap and determine CompressedOops mode
<span class="line-modified">329   static ReservedHeapSpace reserve_heap(size_t heap_size, size_t alignment);</span>
330 
331   // Historic gc information
332   static size_t get_heap_free_at_last_gc()             { return _heap_capacity_at_last_gc - _heap_used_at_last_gc; }
333   static size_t get_heap_used_at_last_gc()             { return _heap_used_at_last_gc; }
334   static void update_heap_info_at_gc();
335 
336   // Testers
337   static bool is_bootstrapping()                      { return _bootstrapping; }
338   static bool is_module_initialized()                 { return _module_initialized; }
339   static bool is_fully_initialized()                  { return _fully_initialized; }
340 
341   static bool        on_page_boundary(void* addr);
342   static bool        should_fill_in_stack_trace(Handle throwable);
343   static void check_alignment(uintx size, uintx alignment, const char* name);
344 
345   // Iteration
346 
347   // Apply &quot;f&quot; to the addresses of all the direct heap pointers maintained
348   // as static fields of &quot;Universe&quot;.
349   static void oops_do(OopClosure* f);
</pre>
<hr />
<pre>
352   static void serialize(SerializeClosure* f);
353 
354   // Apply &quot;f&quot; to all klasses for basic types (classes not present in
355   // SystemDictionary).
356   static void basic_type_classes_do(void f(Klass*));
357   static void basic_type_classes_do(KlassClosure* closure);
358   static void metaspace_pointers_do(MetaspaceClosure* it);
359 
360   // Debugging
361   enum VERIFY_FLAGS {
362     Verify_Threads = 1,
363     Verify_Heap = 2,
364     Verify_SymbolTable = 4,
365     Verify_StringTable = 8,
366     Verify_CodeCache = 16,
367     Verify_SystemDictionary = 32,
368     Verify_ClassLoaderDataGraph = 64,
369     Verify_MetaspaceUtils = 128,
370     Verify_JNIHandles = 256,
371     Verify_CodeCacheOops = 512,
<span class="line-added">372     Verify_ResolvedMethodTable = 1024,</span>
373     Verify_All = -1
374   };
375   static void initialize_verify_flags();
376   static bool should_verify_subset(uint subset);
377   static bool verify_in_progress() { return _verify_in_progress; }
378   static void verify(VerifyOption option, const char* prefix);
379   static void verify(const char* prefix) {
380     verify(VerifyOption_Default, prefix);
381   }
382   static void verify() {
383     verify(&quot;&quot;);
384   }
385 
386   static int  verify_count()       { return _verify_count; }
387   static void print_on(outputStream* st);
388   static void print_heap_at_SIGBREAK();
389   static void print_heap_before_gc();
390   static void print_heap_after_gc();
391 
392   // Change the number of dummy objects kept reachable by the full gc dummy
</pre>
</td>
</tr>
</table>
<center><a href="universe.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="virtualspace.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/memory/heap.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;memory/heap.hpp&quot;
 27 #include &quot;oops/oop.inline.hpp&quot;
 28 #include &quot;runtime/os.hpp&quot;
 29 #include &quot;services/memTracker.hpp&quot;
 30 #include &quot;utilities/align.hpp&quot;
 31 
 32 size_t CodeHeap::header_size() {
 33   return sizeof(HeapBlock);
 34 }
 35 
 36 
 37 // Implementation of Heap
 38 
 39 CodeHeap::CodeHeap(const char* name, const int code_blob_type)
 40   : _code_blob_type(code_blob_type) {
 41   _name                         = name;
 42   _number_of_committed_segments = 0;
 43   _number_of_reserved_segments  = 0;
 44   _segment_size                 = 0;
 45   _log2_segment_size            = 0;
 46   _next_segment                 = 0;
 47   _freelist                     = NULL;
 48   _freelist_segments            = 0;
 49   _freelist_length              = 0;
 50   _max_allocated_capacity       = 0;
 51   _blob_count                   = 0;
 52   _nmethod_count                = 0;
 53   _adapter_count                = 0;
 54   _full_count                   = 0;
 55 }
 56 
 57 
 58 void CodeHeap::mark_segmap_as_free(size_t beg, size_t end) {
 59   assert(              beg &lt;  _number_of_committed_segments, &quot;interval begin out of bounds&quot;);
 60   assert(beg &lt;  end &amp;&amp; end &lt;= _number_of_committed_segments, &quot;interval end   out of bounds&quot;);
 61   // setup _segmap pointers for faster indexing
 62   address p = (address)_segmap.low() + beg;
 63   address q = (address)_segmap.low() + end;
 64   // initialize interval
 65   while (p &lt; q) *p++ = free_sentinel;
 66 }
 67 
 68 
 69 void CodeHeap::mark_segmap_as_used(size_t beg, size_t end) {
 70   assert(              beg &lt;  _number_of_committed_segments, &quot;interval begin out of bounds&quot;);
 71   assert(beg &lt;  end &amp;&amp; end &lt;= _number_of_committed_segments, &quot;interval end   out of bounds&quot;);
 72   // setup _segmap pointers for faster indexing
 73   address p = (address)_segmap.low() + beg;
 74   address q = (address)_segmap.low() + end;
 75   // initialize interval
 76   int i = 0;
 77   while (p &lt; q) {
 78     *p++ = i++;
 79     if (i == free_sentinel) i = 1;
 80   }
 81 }
 82 
 83 
 84 static size_t align_to_page_size(size_t size) {
 85   const size_t alignment = (size_t)os::vm_page_size();
 86   assert(is_power_of_2(alignment), &quot;no kidding ???&quot;);
 87   return (size + alignment - 1) &amp; ~(alignment - 1);
 88 }
 89 
 90 
 91 void CodeHeap::on_code_mapping(char* base, size_t size) {
 92 #ifdef LINUX
 93   extern void linux_wrap_code(char* base, size_t size);
 94   linux_wrap_code(base, size);
 95 #endif
 96 }
 97 
 98 
 99 bool CodeHeap::reserve(ReservedSpace rs, size_t committed_size, size_t segment_size) {
100   assert(rs.size() &gt;= committed_size, &quot;reserved &lt; committed&quot;);
101   assert(segment_size &gt;= sizeof(FreeBlock), &quot;segment size is too small&quot;);
102   assert(is_power_of_2(segment_size), &quot;segment_size must be a power of 2&quot;);
103 
104   _segment_size      = segment_size;
105   _log2_segment_size = exact_log2(segment_size);
106 
107   // Reserve and initialize space for _memory.
108   size_t page_size = os::vm_page_size();
109   if (os::can_execute_large_page_memory()) {
110     const size_t min_pages = 8;
111     page_size = MIN2(os::page_size_for_region_aligned(committed_size, min_pages),
112                      os::page_size_for_region_aligned(rs.size(), min_pages));
113   }
114 
115   const size_t granularity = os::vm_allocation_granularity();
116   const size_t c_size = align_up(committed_size, page_size);
117 
118   os::trace_page_sizes(_name, committed_size, rs.size(), page_size,
119                        rs.base(), rs.size());
120   if (!_memory.initialize(rs, c_size)) {
121     return false;
122   }
123 
124   on_code_mapping(_memory.low(), _memory.committed_size());
125   _number_of_committed_segments = size_to_segments(_memory.committed_size());
126   _number_of_reserved_segments  = size_to_segments(_memory.reserved_size());
127   assert(_number_of_reserved_segments &gt;= _number_of_committed_segments, &quot;just checking&quot;);
128   const size_t reserved_segments_alignment = MAX2((size_t)os::vm_page_size(), granularity);
129   const size_t reserved_segments_size = align_up(_number_of_reserved_segments, reserved_segments_alignment);
130   const size_t committed_segments_size = align_to_page_size(_number_of_committed_segments);
131 
132   // reserve space for _segmap
133   if (!_segmap.initialize(reserved_segments_size, committed_segments_size)) {
134     return false;
135   }
136 
137   MemTracker::record_virtual_memory_type((address)_segmap.low_boundary(), mtCode);
138 
139   assert(_segmap.committed_size() &gt;= (size_t) _number_of_committed_segments, &quot;could not commit  enough space for segment map&quot;);
140   assert(_segmap.reserved_size()  &gt;= (size_t) _number_of_reserved_segments , &quot;could not reserve enough space for segment map&quot;);
141   assert(_segmap.reserved_size()  &gt;= _segmap.committed_size()     , &quot;just checking&quot;);
142 
143   // initialize remaining instance variables
144   clear();
145   return true;
146 }
147 
148 
149 bool CodeHeap::expand_by(size_t size) {
150   // expand _memory space
151   size_t dm = align_to_page_size(_memory.committed_size() + size) - _memory.committed_size();
152   if (dm &gt; 0) {
153     // Use at least the available uncommitted space if &#39;size&#39; is larger
154     if (_memory.uncommitted_size() != 0 &amp;&amp; dm &gt; _memory.uncommitted_size()) {
155       dm = _memory.uncommitted_size();
156     }
157     char* base = _memory.low() + _memory.committed_size();
158     if (!_memory.expand_by(dm)) return false;
159     on_code_mapping(base, dm);
160     size_t i = _number_of_committed_segments;
161     _number_of_committed_segments = size_to_segments(_memory.committed_size());
162     assert(_number_of_reserved_segments == size_to_segments(_memory.reserved_size()), &quot;number of reserved segments should not change&quot;);
163     assert(_number_of_reserved_segments &gt;= _number_of_committed_segments, &quot;just checking&quot;);
164     // expand _segmap space
165     size_t ds = align_to_page_size(_number_of_committed_segments) - _segmap.committed_size();
166     if ((ds &gt; 0) &amp;&amp; !_segmap.expand_by(ds)) {
167       return false;
168     }
169     assert(_segmap.committed_size() &gt;= (size_t) _number_of_committed_segments, &quot;just checking&quot;);
170     // initialize additional segmap entries
171     mark_segmap_as_free(i, _number_of_committed_segments);
172   }
173   return true;
174 }
175 
176 void CodeHeap::clear() {
177   _next_segment = 0;
178   mark_segmap_as_free(0, _number_of_committed_segments);
179 }
180 
181 
182 void* CodeHeap::allocate(size_t instance_size) {
183   size_t number_of_segments = size_to_segments(instance_size + header_size());
184   assert(segments_to_size(number_of_segments) &gt;= sizeof(FreeBlock), &quot;not enough room for FreeList&quot;);
185 
186   // First check if we can satisfy request from freelist
187   NOT_PRODUCT(verify());
188   HeapBlock* block = search_freelist(number_of_segments);
189   NOT_PRODUCT(verify());
190 
191   if (block != NULL) {
192     assert(block-&gt;length() &gt;= number_of_segments &amp;&amp; block-&gt;length() &lt; number_of_segments + CodeCacheMinBlockLength, &quot;sanity check&quot;);
193     assert(!block-&gt;free(), &quot;must be marked free&quot;);
194     guarantee((char*) block &gt;= _memory.low_boundary() &amp;&amp; (char*) block &lt; _memory.high(),
195               &quot;The newly allocated block &quot; INTPTR_FORMAT &quot; is not within the heap &quot;
196               &quot;starting with &quot;  INTPTR_FORMAT &quot; and ending with &quot;  INTPTR_FORMAT,
197               p2i(block), p2i(_memory.low_boundary()), p2i(_memory.high()));
198     DEBUG_ONLY(memset((void*)block-&gt;allocated_space(), badCodeHeapNewVal, instance_size));
199     _max_allocated_capacity = MAX2(_max_allocated_capacity, allocated_capacity());
200     _blob_count++;
201     return block-&gt;allocated_space();
202   }
203 
204   // Ensure minimum size for allocation to the heap.
205   number_of_segments = MAX2((int)CodeCacheMinBlockLength, (int)number_of_segments);
206 
207   if (_next_segment + number_of_segments &lt;= _number_of_committed_segments) {
208     mark_segmap_as_used(_next_segment, _next_segment + number_of_segments);
209     HeapBlock* b =  block_at(_next_segment);
210     b-&gt;initialize(number_of_segments);
211     _next_segment += number_of_segments;
212     guarantee((char*) b &gt;= _memory.low_boundary() &amp;&amp; (char*) block &lt; _memory.high(),
213               &quot;The newly allocated block &quot; INTPTR_FORMAT &quot; is not within the heap &quot;
214               &quot;starting with &quot;  INTPTR_FORMAT &quot; and ending with &quot; INTPTR_FORMAT,
215               p2i(b), p2i(_memory.low_boundary()), p2i(_memory.high()));
216     DEBUG_ONLY(memset((void *)b-&gt;allocated_space(), badCodeHeapNewVal, instance_size));
217     _max_allocated_capacity = MAX2(_max_allocated_capacity, allocated_capacity());
218     _blob_count++;
219     return b-&gt;allocated_space();
220   } else {
221     return NULL;
222   }
223 }
224 
225 void CodeHeap::deallocate_tail(void* p, size_t used_size) {
226   assert(p == find_start(p), &quot;illegal deallocation&quot;);
227   // Find start of HeapBlock
228   HeapBlock* b = (((HeapBlock *)p) - 1);
229   assert(b-&gt;allocated_space() == p, &quot;sanity check&quot;);
230   size_t used_number_of_segments = size_to_segments(used_size + header_size());
231   size_t actual_number_of_segments = b-&gt;length();
232   guarantee(used_number_of_segments &lt;= actual_number_of_segments, &quot;Must be!&quot;);
233   guarantee(b == block_at(_next_segment - actual_number_of_segments), &quot;Intermediate allocation!&quot;);
234   size_t number_of_segments_to_deallocate = actual_number_of_segments - used_number_of_segments;
235   _next_segment -= number_of_segments_to_deallocate;
236   mark_segmap_as_free(_next_segment, _next_segment + number_of_segments_to_deallocate);
237   b-&gt;initialize(used_number_of_segments);
238 }
239 
240 void CodeHeap::deallocate(void* p) {
241   assert(p == find_start(p), &quot;illegal deallocation&quot;);
242   // Find start of HeapBlock
243   HeapBlock* b = (((HeapBlock *)p) - 1);
244   assert(b-&gt;allocated_space() == p, &quot;sanity check&quot;);
245   guarantee((char*) b &gt;= _memory.low_boundary() &amp;&amp; (char*) b &lt; _memory.high(),
246             &quot;The block to be deallocated &quot; INTPTR_FORMAT &quot; is not within the heap &quot;
247             &quot;starting with &quot;  INTPTR_FORMAT &quot; and ending with &quot; INTPTR_FORMAT,
248             p2i(b), p2i(_memory.low_boundary()), p2i(_memory.high()));
249   DEBUG_ONLY(memset((void *)b-&gt;allocated_space(), badCodeHeapFreeVal,
250              segments_to_size(b-&gt;length()) - sizeof(HeapBlock)));
251   add_to_freelist(b);
252   NOT_PRODUCT(verify());
253 }
254 
255 /**
256  * Uses segment map to find the the start (header) of a nmethod. This works as follows:
257  * The memory of the code cache is divided into &#39;segments&#39;. The size of a segment is
258  * determined by -XX:CodeCacheSegmentSize=XX. Allocation in the code cache can only
259  * happen at segment boundaries. A pointer in the code cache can be mapped to a segment
260  * by calling segment_for(addr). Each time memory is requested from the code cache,
261  * the segmap is updated accordingly. See the following example, which illustrates the
262  * state of code cache and the segment map: (seg -&gt; segment, nm -&gt;nmethod)
263  *
264  *          code cache          segmap
265  *         -----------        ---------
266  * seg 1   | nm 1    |   -&gt;   | 0     |
267  * seg 2   | nm 1    |   -&gt;   | 1     |
268  * ...     | nm 1    |   -&gt;   | ..    |
269  * seg m   | nm 2    |   -&gt;   | 0     |
270  * seg m+1 | nm 2    |   -&gt;   | 1     |
271  * ...     | nm 2    |   -&gt;   | 2     |
272  * ...     | nm 2    |   -&gt;   | ..    |
273  * ...     | nm 2    |   -&gt;   | 0xFE  |
274  * seg m+n | nm 2    |   -&gt;   | 1     |
275  * ...     | nm 2    |   -&gt;   |       |
276  *
277  * A value of &#39;0&#39; in the segmap indicates that this segment contains the beginning of
278  * an nmethod. Let&#39;s walk through a simple example: If we want to find the start of
279  * an nmethod that falls into seg 2, we read the value of the segmap[2]. The value
280  * is an offset that points to the segment that contains the start of the nmethod.
281  * Another example: If we want to get the start of nm 2, and we happen to get a pointer
282  * that points to seg m+n, we first read seg[n+m], which returns &#39;1&#39;. So we have to
283  * do one more read of the segmap[m+n-1] to finally get the segment header.
284  */
285 void* CodeHeap::find_start(void* p) const {
286   if (!contains(p)) {
287     return NULL;
288   }
289   size_t seg_idx = segment_for(p);
290   address seg_map = (address)_segmap.low();
291   if (is_segment_unused(seg_map[seg_idx])) {
292     return NULL;
293   }
294   while (seg_map[seg_idx] &gt; 0) {
295     seg_idx -= (int)seg_map[seg_idx];
296   }
297 
298   HeapBlock* h = block_at(seg_idx);
299   if (h-&gt;free()) {
300     return NULL;
301   }
302   return h-&gt;allocated_space();
303 }
304 
305 CodeBlob* CodeHeap::find_blob_unsafe(void* start) const {
306   CodeBlob* result = (CodeBlob*)CodeHeap::find_start(start);
307   if (result != NULL &amp;&amp; result-&gt;blob_contains((address)start)) {
308     return result;
309   }
310   return NULL;
311 }
312 
313 size_t CodeHeap::alignment_unit() const {
314   // this will be a power of two
315   return _segment_size;
316 }
317 
318 
319 size_t CodeHeap::alignment_offset() const {
320   // The lowest address in any allocated block will be
321   // equal to alignment_offset (mod alignment_unit).
322   return sizeof(HeapBlock) &amp; (_segment_size - 1);
323 }
324 
325 // Returns the current block if available and used.
326 // If not, it returns the subsequent block (if available), NULL otherwise.
327 // Free blocks are merged, therefore there is at most one free block
328 // between two used ones. As a result, the subsequent block (if available) is
329 // guaranteed to be used.
330 void* CodeHeap::next_used(HeapBlock* b) const {
331   if (b != NULL &amp;&amp; b-&gt;free()) b = next_block(b);
332   assert(b == NULL || !b-&gt;free(), &quot;must be in use or at end of heap&quot;);
333   return (b == NULL) ? NULL : b-&gt;allocated_space();
334 }
335 
336 // Returns the first used HeapBlock
337 HeapBlock* CodeHeap::first_block() const {
338   if (_next_segment &gt; 0)
339     return block_at(0);
340   return NULL;
341 }
342 
343 HeapBlock* CodeHeap::block_start(void* q) const {
344   HeapBlock* b = (HeapBlock*)find_start(q);
345   if (b == NULL) return NULL;
346   return b - 1;
347 }
348 
349 // Returns the next Heap block an offset into one
350 HeapBlock* CodeHeap::next_block(HeapBlock *b) const {
351   if (b == NULL) return NULL;
352   size_t i = segment_for(b) + b-&gt;length();
353   if (i &lt; _next_segment)
354     return block_at(i);
355   return NULL;
356 }
357 
358 
359 // Returns current capacity
360 size_t CodeHeap::capacity() const {
361   return _memory.committed_size();
362 }
363 
364 size_t CodeHeap::max_capacity() const {
365   return _memory.reserved_size();
366 }
367 
368 int CodeHeap::allocated_segments() const {
369   return (int)_next_segment;
370 }
371 
372 size_t CodeHeap::allocated_capacity() const {
373   // size of used heap - size on freelist
374   return segments_to_size(_next_segment - _freelist_segments);
375 }
376 
377 // Returns size of the unallocated heap block
378 size_t CodeHeap::heap_unallocated_capacity() const {
379   // Total number of segments - number currently used
380   return segments_to_size(_number_of_reserved_segments - _next_segment);
381 }
382 
383 // Free list management
384 
385 FreeBlock* CodeHeap::following_block(FreeBlock *b) {
386   return (FreeBlock*)(((address)b) + _segment_size * b-&gt;length());
387 }
388 
389 // Inserts block b after a
390 void CodeHeap::insert_after(FreeBlock* a, FreeBlock* b) {
391   assert(a != NULL &amp;&amp; b != NULL, &quot;must be real pointers&quot;);
392 
393   // Link b into the list after a
394   b-&gt;set_link(a-&gt;link());
395   a-&gt;set_link(b);
396 
397   // See if we can merge blocks
398   merge_right(b); // Try to make b bigger
399   merge_right(a); // Try to make a include b
400 }
401 
402 // Try to merge this block with the following block
403 bool CodeHeap::merge_right(FreeBlock* a) {
404   assert(a-&gt;free(), &quot;must be a free block&quot;);
405   if (following_block(a) == a-&gt;link()) {
406     assert(a-&gt;link() != NULL &amp;&amp; a-&gt;link()-&gt;free(), &quot;must be free too&quot;);
407     // Update block a to include the following block
408     a-&gt;set_length(a-&gt;length() + a-&gt;link()-&gt;length());
409     a-&gt;set_link(a-&gt;link()-&gt;link());
410     // Update find_start map
411     size_t beg = segment_for(a);
412     mark_segmap_as_used(beg, beg + a-&gt;length());
413     _freelist_length--;
414     return true;
415   }
416   return false;
417 }
418 
419 
420 void CodeHeap::add_to_freelist(HeapBlock* a) {
421   FreeBlock* b = (FreeBlock*)a;
422   _freelist_length++;
423 
424   assert(b != _freelist, &quot;cannot be removed twice&quot;);
425 
426 
427   // Mark as free and update free space count
428   _freelist_segments += b-&gt;length();
429   b-&gt;set_free();
430 
431   // First element in list?
432   if (_freelist == NULL) {
433     _freelist = b;
434     b-&gt;set_link(NULL);
435     return;
436   }
437 
438   // Since the freelist is ordered (smaller addresses -&gt; larger addresses) and the
439   // element we want to insert into the freelist has a smaller address than the first
440   // element, we can simply add &#39;b&#39; as the first element and we are done.
441   if (b &lt; _freelist) {
442     // Insert first in list
443     b-&gt;set_link(_freelist);
444     _freelist = b;
445     merge_right(_freelist);
446     return;
447   }
448 
449   // Scan for right place to put into list. List
450   // is sorted by increasing addresses
451   FreeBlock* prev = _freelist;
452   FreeBlock* cur  = _freelist-&gt;link();
453   while(cur != NULL &amp;&amp; cur &lt; b) {
454     assert(prev &lt; cur, &quot;Freelist must be ordered&quot;);
455     prev = cur;
456     cur  = cur-&gt;link();
457   }
458   assert((prev &lt; b) &amp;&amp; (cur == NULL || b &lt; cur), &quot;free-list must be ordered&quot;);
459   insert_after(prev, b);
460 }
461 
462 /**
463  * Search freelist for an entry on the list with the best fit.
464  * @return NULL, if no one was found
465  */
466 FreeBlock* CodeHeap::search_freelist(size_t length) {
467   FreeBlock* found_block = NULL;
468   FreeBlock* found_prev  = NULL;
469   size_t     found_length = 0;
470 
471   FreeBlock* prev = NULL;
472   FreeBlock* cur = _freelist;
473 
474   // Search for first block that fits
475   while(cur != NULL) {
476     if (cur-&gt;length() &gt;= length) {
477       // Remember block, its previous element, and its length
478       found_block = cur;
479       found_prev  = prev;
480       found_length = found_block-&gt;length();
481 
482       break;
483     }
484     // Next element in list
485     prev = cur;
486     cur  = cur-&gt;link();
487   }
488 
489   if (found_block == NULL) {
490     // None found
491     return NULL;
492   }
493 
494   // Exact (or at least good enough) fit. Remove from list.
495   // Don&#39;t leave anything on the freelist smaller than CodeCacheMinBlockLength.
496   if (found_length - length &lt; CodeCacheMinBlockLength) {
497     _freelist_length--;
498     length = found_length;
499     if (found_prev == NULL) {
500       assert(_freelist == found_block, &quot;sanity check&quot;);
501       _freelist = _freelist-&gt;link();
502     } else {
503       assert((found_prev-&gt;link() == found_block), &quot;sanity check&quot;);
504       // Unmap element
505       found_prev-&gt;set_link(found_block-&gt;link());
506     }
507   } else {
508     // Truncate block and return a pointer to the following block
509     // Set used bit and length on new block
510     found_block-&gt;set_length(found_length - length);
511     found_block = following_block(found_block);
512 
513     size_t beg = segment_for(found_block);
514     mark_segmap_as_used(beg, beg + length);
515     found_block-&gt;set_length(length);
516   }
517 
518   found_block-&gt;set_used();
519   _freelist_segments -= length;
520   return found_block;
521 }
522 
523 //----------------------------------------------------------------------------
524 // Non-product code
525 
526 #ifndef PRODUCT
527 
528 void CodeHeap::print() {
529   tty-&gt;print_cr(&quot;The Heap&quot;);
530 }
531 
532 void CodeHeap::verify() {
533   if (VerifyCodeCache) {
534     size_t len = 0;
535     int count = 0;
536     for(FreeBlock* b = _freelist; b != NULL; b = b-&gt;link()) {
537       len += b-&gt;length();
538       count++;
539       // Check if we have merged all free blocks
540       assert(merge_right(b) == false, &quot;Missed merging opportunity&quot;);
541     }
542     // Verify that freelist contains the right amount of free space
543     assert(len == _freelist_segments, &quot;wrong freelist&quot;);
544 
545     for(HeapBlock* h = first_block(); h != NULL; h = next_block(h)) {
546       if (h-&gt;free()) count--;
547     }
548     // Verify that the freelist contains the same number of blocks
549     // than free blocks found on the full list.
550     assert(count == 0, &quot;missing free blocks&quot;);
551 
552     // Verify that the number of free blocks is not out of hand.
553     static int free_block_threshold = 10000;
554     if (count &gt; free_block_threshold) {
555       warning(&quot;CodeHeap: # of free blocks &gt; %d&quot;, free_block_threshold);
556       // Double the warning limit
557       free_block_threshold *= 2;
558     }
559   }
560 }
561 
562 #endif
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/memory/metaspaceShared.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  28 #include &quot;classfile/classListParser.hpp&quot;
  29 #include &quot;classfile/classLoaderExt.hpp&quot;
  30 #include &quot;classfile/dictionary.hpp&quot;
  31 #include &quot;classfile/loaderConstraints.hpp&quot;
  32 #include &quot;classfile/javaClasses.inline.hpp&quot;
  33 #include &quot;classfile/placeholders.hpp&quot;
  34 #include &quot;classfile/symbolTable.hpp&quot;
  35 #include &quot;classfile/stringTable.hpp&quot;
  36 #include &quot;classfile/systemDictionary.hpp&quot;
  37 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  38 #include &quot;code/codeCache.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added">  39 #include &quot;gc/shared/softRefPolicy.hpp&quot;</span>
  40 #include &quot;interpreter/bytecodeStream.hpp&quot;
  41 #include &quot;interpreter/bytecodes.hpp&quot;
  42 #include &quot;logging/log.hpp&quot;
  43 #include &quot;logging/logMessage.hpp&quot;
<a name="3" id="anc3"></a><span class="line-added">  44 #include &quot;memory/archiveUtils.inline.hpp&quot;</span>
<span class="line-added">  45 #include &quot;memory/dynamicArchive.hpp&quot;</span>
  46 #include &quot;memory/filemap.hpp&quot;
  47 #include &quot;memory/heapShared.inline.hpp&quot;
  48 #include &quot;memory/metaspace.hpp&quot;
  49 #include &quot;memory/metaspaceClosure.hpp&quot;
  50 #include &quot;memory/metaspaceShared.hpp&quot;
  51 #include &quot;memory/resourceArea.hpp&quot;
<a name="4" id="anc4"></a><span class="line-added">  52 #include &quot;memory/universe.hpp&quot;</span>
  53 #include &quot;oops/compressedOops.inline.hpp&quot;
  54 #include &quot;oops/instanceClassLoaderKlass.hpp&quot;
  55 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  56 #include &quot;oops/instanceRefKlass.hpp&quot;
<a name="5" id="anc5"></a><span class="line-added">  57 #include &quot;oops/methodData.hpp&quot;</span>
  58 #include &quot;oops/objArrayKlass.hpp&quot;
  59 #include &quot;oops/objArrayOop.hpp&quot;
  60 #include &quot;oops/oop.inline.hpp&quot;
  61 #include &quot;oops/typeArrayKlass.hpp&quot;
  62 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  63 #include &quot;runtime/handles.inline.hpp&quot;
  64 #include &quot;runtime/os.hpp&quot;
  65 #include &quot;runtime/safepointVerifiers.hpp&quot;
  66 #include &quot;runtime/signature.hpp&quot;
  67 #include &quot;runtime/timerTrace.hpp&quot;
  68 #include &quot;runtime/vmThread.hpp&quot;
  69 #include &quot;runtime/vmOperations.hpp&quot;
  70 #include &quot;utilities/align.hpp&quot;
<a name="6" id="anc6"></a><span class="line-modified">  71 #include &quot;utilities/bitMap.inline.hpp&quot;</span>
  72 #include &quot;utilities/defaultStream.hpp&quot;
  73 #include &quot;utilities/hashtable.inline.hpp&quot;
  74 #if INCLUDE_G1GC
  75 #include &quot;gc/g1/g1CollectedHeap.hpp&quot;
  76 #endif
  77 
  78 ReservedSpace MetaspaceShared::_shared_rs;
  79 VirtualSpace MetaspaceShared::_shared_vs;
  80 MetaspaceSharedStats MetaspaceShared::_stats;
  81 bool MetaspaceShared::_has_error_classes;
  82 bool MetaspaceShared::_archive_loading_failed = false;
  83 bool MetaspaceShared::_remapped_readwrite = false;
<a name="7" id="anc7"></a><span class="line-modified">  84 address MetaspaceShared::_i2i_entry_code_buffers = NULL;</span>
<span class="line-modified">  85 size_t MetaspaceShared::_i2i_entry_code_buffers_size = 0;</span>
<span class="line-modified">  86 void* MetaspaceShared::_shared_metaspace_static_top = NULL;</span>
<span class="line-added">  87 intx MetaspaceShared::_relocation_delta;</span>
  88 
  89 // The CDS archive is divided into the following regions:
<a name="8" id="anc8"></a><span class="line-modified">  90 //     mc  - misc code (the method entry trampolines, c++ vtables)</span>
  91 //     rw  - read-write metadata
  92 //     ro  - read-only metadata and read-only tables
<a name="9" id="anc9"></a>

  93 //
  94 //     ca0 - closed archive heap space #0
  95 //     ca1 - closed archive heap space #1 (may be empty)
  96 //     oa0 - open archive heap space #0
  97 //     oa1 - open archive heap space #1 (may be empty)
  98 //
<a name="10" id="anc10"></a><span class="line-modified">  99 // The mc, rw, and ro regions are linearly allocated, starting from</span>
<span class="line-modified"> 100 // SharedBaseAddress, in the order of mc-&gt;rw-&gt;ro. The size of these 3 regions</span>
 101 // are page-aligned, and there&#39;s no gap between any consecutive regions.
 102 //
<a name="11" id="anc11"></a><span class="line-modified"> 103 // These 3 regions are populated in the following steps:</span>
 104 // [1] All classes are loaded in MetaspaceShared::preload_classes(). All metadata are
 105 //     temporarily allocated outside of the shared regions. Only the method entry
 106 //     trampolines are written into the mc region.
<a name="12" id="anc12"></a><span class="line-modified"> 107 // [2] C++ vtables are copied into the mc region.</span>
<span class="line-modified"> 108 // [3] ArchiveCompactor copies RW metadata into the rw region.</span>
<span class="line-modified"> 109 // [4] ArchiveCompactor copies RO metadata into the ro region.</span>
<span class="line-added"> 110 // [5] SymbolTable, StringTable, SystemDictionary, and a few other read-only data</span>
 111 //     are copied into the ro region as read-only tables.
<a name="13" id="anc13"></a>

 112 //
 113 // The s0/s1 and oa0/oa1 regions are populated inside HeapShared::archive_java_heap_objects.
<a name="14" id="anc14"></a><span class="line-modified"> 114 // Their layout is independent of the other 4 regions.</span>
<span class="line-added"> 115 </span>
<span class="line-added"> 116 char* DumpRegion::expand_top_to(char* newtop) {</span>
<span class="line-added"> 117   assert(is_allocatable(), &quot;must be initialized and not packed&quot;);</span>
<span class="line-added"> 118   assert(newtop &gt;= _top, &quot;must not grow backwards&quot;);</span>
<span class="line-added"> 119   if (newtop &gt; _end) {</span>
<span class="line-added"> 120     MetaspaceShared::report_out_of_space(_name, newtop - _top);</span>
<span class="line-added"> 121     ShouldNotReachHere();</span>
<span class="line-added"> 122   }</span>
<span class="line-added"> 123   uintx delta;</span>
<span class="line-added"> 124   if (DynamicDumpSharedSpaces) {</span>
<span class="line-added"> 125     delta = DynamicArchive::object_delta_uintx(newtop);</span>
<span class="line-added"> 126   } else {</span>
<span class="line-added"> 127     delta = MetaspaceShared::object_delta_uintx(newtop);</span>
<span class="line-added"> 128   }</span>
<span class="line-added"> 129   if (delta &gt; MAX_SHARED_DELTA) {</span>
<span class="line-added"> 130     // This is just a sanity check and should not appear in any real world usage. This</span>
<span class="line-added"> 131     // happens only if you allocate more than 2GB of shared objects and would require</span>
<span class="line-added"> 132     // millions of shared classes.</span>
<span class="line-added"> 133     vm_exit_during_initialization(&quot;Out of memory in the CDS archive&quot;,</span>
<span class="line-added"> 134                                   &quot;Please reduce the number of shared classes.&quot;);</span>
<span class="line-added"> 135   }</span>
 136 
<a name="15" id="anc15"></a><span class="line-modified"> 137   MetaspaceShared::commit_shared_space_to(newtop);</span>
<span class="line-modified"> 138   _top = newtop;</span>
<span class="line-modified"> 139   return _top;</span>
<span class="line-modified"> 140 }</span>



















 141 
<a name="16" id="anc16"></a><span class="line-modified"> 142 char* DumpRegion::allocate(size_t num_bytes, size_t alignment) {</span>
<span class="line-modified"> 143   char* p = (char*)align_up(_top, alignment);</span>
<span class="line-modified"> 144   char* newtop = p + align_up(num_bytes, alignment);</span>
<span class="line-modified"> 145   expand_top_to(newtop);</span>
<span class="line-added"> 146   memset(p, 0, newtop - p);</span>
<span class="line-added"> 147   return p;</span>
<span class="line-added"> 148 }</span>
 149 
<a name="17" id="anc17"></a><span class="line-modified"> 150 void DumpRegion::append_intptr_t(intptr_t n, bool need_to_mark) {</span>
<span class="line-modified"> 151   assert(is_aligned(_top, sizeof(intptr_t)), &quot;bad alignment&quot;);</span>
<span class="line-modified"> 152   intptr_t *p = (intptr_t*)_top;</span>
<span class="line-modified"> 153   char* newtop = _top + sizeof(intptr_t);</span>
<span class="line-modified"> 154   expand_top_to(newtop);</span>
<span class="line-modified"> 155   *p = n;</span>
<span class="line-modified"> 156   if (need_to_mark) {</span>
<span class="line-modified"> 157     ArchivePtrMarker::mark_pointer(p);</span>

































 158   }
<a name="18" id="anc18"></a><span class="line-added"> 159 }</span>
 160 
<a name="19" id="anc19"></a><span class="line-modified"> 161 void DumpRegion::print(size_t total_bytes) const {</span>
<span class="line-modified"> 162   log_debug(cds)(&quot;%-3s space: &quot; SIZE_FORMAT_W(9) &quot; [ %4.1f%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [%5.1f%% used] at &quot; INTPTR_FORMAT,</span>
<span class="line-modified"> 163                  _name, used(), percent_of(used(), total_bytes), reserved(), percent_of(used(), reserved()),</span>
<span class="line-modified"> 164                  p2i(_base + MetaspaceShared::final_delta()));</span>
<span class="line-modified"> 165 }</span>
<span class="line-modified"> 166 </span>
<span class="line-modified"> 167 void DumpRegion::print_out_of_space_msg(const char* failing_region, size_t needed_bytes) {</span>
<span class="line-modified"> 168   log_error(cds)(&quot;[%-8s] &quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot; capacity =%9d, allocated =%9d&quot;,</span>
<span class="line-added"> 169                  _name, p2i(_base), p2i(_top), int(_end - _base), int(_top - _base));</span>
<span class="line-added"> 170   if (strcmp(_name, failing_region) == 0) {</span>
<span class="line-added"> 171     log_error(cds)(&quot; required = %d&quot;, int(needed_bytes));</span>
 172   }
<a name="20" id="anc20"></a><span class="line-added"> 173 }</span>
 174 
<a name="21" id="anc21"></a><span class="line-modified"> 175 void DumpRegion::pack(DumpRegion* next) {</span>
<span class="line-modified"> 176   assert(!is_packed(), &quot;sanity&quot;);</span>
<span class="line-modified"> 177   _end = (char*)align_up(_top, Metaspace::reserve_alignment());</span>
<span class="line-modified"> 178   _is_packed = true;</span>
<span class="line-modified"> 179   if (next != NULL) {</span>
<span class="line-modified"> 180     next-&gt;_base = next-&gt;_top = this-&gt;_end;</span>
<span class="line-modified"> 181     next-&gt;_end = MetaspaceShared::shared_rs()-&gt;end();</span>

 182   }
<a name="22" id="anc22"></a><span class="line-modified"> 183 }</span>
<span class="line-modified"> 184 </span>
<span class="line-added"> 185 static DumpRegion _mc_region(&quot;mc&quot;), _ro_region(&quot;ro&quot;), _rw_region(&quot;rw&quot;);</span>
<span class="line-added"> 186 static size_t _total_closed_archive_region_size = 0, _total_open_archive_region_size = 0;</span>
<span class="line-added"> 187 </span>
<span class="line-added"> 188 void MetaspaceShared::init_shared_dump_space(DumpRegion* first_space, address first_space_bottom) {</span>
<span class="line-added"> 189   // Start with 0 committed bytes. The memory will be committed as needed by</span>
<span class="line-added"> 190   // MetaspaceShared::commit_shared_space_to().</span>
<span class="line-added"> 191   if (!_shared_vs.initialize(_shared_rs, 0)) {</span>
<span class="line-added"> 192     fatal(&quot;Unable to allocate memory for shared space&quot;);</span>
 193   }
<a name="23" id="anc23"></a><span class="line-modified"> 194   first_space-&gt;init(&amp;_shared_rs, (char*)first_space_bottom);</span>
<span class="line-added"> 195 }</span>
<span class="line-added"> 196 </span>
<span class="line-added"> 197 DumpRegion* MetaspaceShared::misc_code_dump_space() {</span>
<span class="line-added"> 198   return &amp;_mc_region;</span>
<span class="line-added"> 199 }</span>
<span class="line-added"> 200 </span>
<span class="line-added"> 201 DumpRegion* MetaspaceShared::read_write_dump_space() {</span>
<span class="line-added"> 202   return &amp;_rw_region;</span>
<span class="line-added"> 203 }</span>
 204 
<a name="24" id="anc24"></a><span class="line-added"> 205 DumpRegion* MetaspaceShared::read_only_dump_space() {</span>
<span class="line-added"> 206   return &amp;_ro_region;</span>
<span class="line-added"> 207 }</span>
 208 
<a name="25" id="anc25"></a><span class="line-modified"> 209 void MetaspaceShared::pack_dump_space(DumpRegion* current, DumpRegion* next,</span>
<span class="line-modified"> 210                                       ReservedSpace* rs) {</span>
<span class="line-added"> 211   current-&gt;pack(next);</span>
<span class="line-added"> 212 }</span>
 213 
 214 char* MetaspaceShared::misc_code_space_alloc(size_t num_bytes) {
 215   return _mc_region.allocate(num_bytes);
 216 }
 217 
 218 char* MetaspaceShared::read_only_space_alloc(size_t num_bytes) {
 219   return _ro_region.allocate(num_bytes);
 220 }
 221 
<a name="26" id="anc26"></a><span class="line-modified"> 222 // When reserving an address range using ReservedSpace, we need an alignment that satisfies both:</span>
<span class="line-modified"> 223 // os::vm_allocation_granularity() -- so that we can sub-divide this range into multiple mmap regions,</span>
<span class="line-modified"> 224 //                                    while keeping the first range at offset 0 of this range.</span>
<span class="line-modified"> 225 // Metaspace::reserve_alignment()  -- so we can pass the region to</span>
<span class="line-modified"> 226 //                                    Metaspace::allocate_metaspace_compressed_klass_ptrs.</span>
<span class="line-modified"> 227 size_t MetaspaceShared::reserved_space_alignment() {</span>
<span class="line-modified"> 228   size_t os_align = os::vm_allocation_granularity();</span>
<span class="line-modified"> 229   size_t ms_align = Metaspace::reserve_alignment();</span>
<span class="line-modified"> 230   if (os_align &gt;= ms_align) {</span>
<span class="line-modified"> 231     assert(os_align % ms_align == 0, &quot;must be a multiple&quot;);</span>
<span class="line-modified"> 232     return os_align;</span>


















 233   } else {
<a name="27" id="anc27"></a><span class="line-modified"> 234     assert(ms_align % os_align == 0, &quot;must be a multiple&quot;);</span>
<span class="line-modified"> 235     return ms_align;</span>
 236   }
 237 }
 238 
<a name="28" id="anc28"></a><span class="line-added"> 239 ReservedSpace MetaspaceShared::reserve_shared_space(size_t size, char* requested_address) {</span>
<span class="line-added"> 240   return Metaspace::reserve_space(size, reserved_space_alignment(),</span>
<span class="line-added"> 241                                   requested_address, requested_address != NULL);</span>
<span class="line-added"> 242 }</span>
<span class="line-added"> 243 </span>
 244 void MetaspaceShared::initialize_dumptime_shared_and_meta_spaces() {
 245   assert(DumpSharedSpaces, &quot;should be called for dump time only&quot;);
<a name="29" id="anc29"></a><span class="line-modified"> 246   const size_t reserve_alignment = reserved_space_alignment();</span>

 247   char* shared_base = (char*)align_up((char*)SharedBaseAddress, reserve_alignment);
 248 
 249 #ifdef _LP64
 250   // On 64-bit VM, the heap and class space layout will be the same as if
 251   // you&#39;re running in -Xshare:on mode:
 252   //
 253   //                              +-- SharedBaseAddress (default = 0x800000000)
 254   //                              v
<a name="30" id="anc30"></a><span class="line-modified"> 255   // +-..---------+---------+ ... +----+----+----+--------------------+</span>
<span class="line-modified"> 256   // |    Heap    | Archive |     | MC | RW | RO |    class space     |</span>
<span class="line-modified"> 257   // +-..---------+---------+ ... +----+----+----+--------------------+</span>
<span class="line-modified"> 258   // |&lt;--   MaxHeapSize  --&gt;|     |&lt;-- UnscaledClassSpaceMax = 4GB --&gt;|</span>
 259   //
 260   const uint64_t UnscaledClassSpaceMax = (uint64_t(max_juint) + 1);
 261   const size_t cds_total = align_down(UnscaledClassSpaceMax, reserve_alignment);
 262 #else
 263   // We don&#39;t support archives larger than 256MB on 32-bit due to limited virtual address space.
 264   size_t cds_total = align_down(256*M, reserve_alignment);
 265 #endif
 266 
<a name="31" id="anc31"></a><span class="line-added"> 267   bool use_requested_base = true;</span>
<span class="line-added"> 268   if (ArchiveRelocationMode == 1) {</span>
<span class="line-added"> 269     log_info(cds)(&quot;ArchiveRelocationMode == 1: always allocate class space at an alternative address&quot;);</span>
<span class="line-added"> 270     use_requested_base = false;</span>
<span class="line-added"> 271   }</span>
<span class="line-added"> 272 </span>
 273   // First try to reserve the space at the specified SharedBaseAddress.
<a name="32" id="anc32"></a><span class="line-modified"> 274   assert(!_shared_rs.is_reserved(), &quot;must be&quot;);</span>
<span class="line-added"> 275   if (use_requested_base) {</span>
<span class="line-added"> 276     _shared_rs = reserve_shared_space(cds_total, shared_base);</span>
<span class="line-added"> 277   }</span>
 278   if (_shared_rs.is_reserved()) {
 279     assert(shared_base == 0 || _shared_rs.base() == shared_base, &quot;should match&quot;);
 280   } else {
 281     // Get a mmap region anywhere if the SharedBaseAddress fails.
<a name="33" id="anc33"></a><span class="line-modified"> 282     _shared_rs = reserve_shared_space(cds_total);</span>
 283   }
 284   if (!_shared_rs.is_reserved()) {
 285     vm_exit_during_initialization(&quot;Unable to reserve memory for shared space&quot;,
 286                                   err_msg(SIZE_FORMAT &quot; bytes.&quot;, cds_total));
 287   }
 288 
 289 #ifdef _LP64
 290   // During dump time, we allocate 4GB (UnscaledClassSpaceMax) of space and split it up:
 291   // + The upper 1 GB is used as the &quot;temporary compressed class space&quot; -- preload_classes()
 292   //   will store Klasses into this space.
 293   // + The lower 3 GB is used for the archive -- when preload_classes() is done,
 294   //   ArchiveCompactor will copy the class metadata into this space, first the RW parts,
 295   //   then the RO parts.
 296 
<a name="34" id="anc34"></a>


 297   size_t max_archive_size = align_down(cds_total * 3 / 4, reserve_alignment);
 298   ReservedSpace tmp_class_space = _shared_rs.last_part(max_archive_size);
 299   CompressedClassSpaceSize = align_down(tmp_class_space.size(), reserve_alignment);
 300   _shared_rs = _shared_rs.first_part(max_archive_size);
 301 
<a name="35" id="anc35"></a><span class="line-modified"> 302   if (UseCompressedClassPointers) {</span>
<span class="line-modified"> 303     // Set up compress class pointers.</span>
<span class="line-modified"> 304     CompressedKlassPointers::set_base((address)_shared_rs.base());</span>
<span class="line-modified"> 305     // Set narrow_klass_shift to be LogKlassAlignmentInBytes. This is consistent</span>
<span class="line-modified"> 306     // with AOT.</span>
<span class="line-modified"> 307     CompressedKlassPointers::set_shift(LogKlassAlignmentInBytes);</span>
<span class="line-modified"> 308     // Set the range of klass addresses to 4GB.</span>
<span class="line-modified"> 309     CompressedKlassPointers::set_range(cds_total);</span>
<span class="line-modified"> 310     Metaspace::initialize_class_space(tmp_class_space);</span>
<span class="line-added"> 311   }</span>
 312   log_info(cds)(&quot;narrow_klass_base = &quot; PTR_FORMAT &quot;, narrow_klass_shift = %d&quot;,
<a name="36" id="anc36"></a><span class="line-modified"> 313                 p2i(CompressedKlassPointers::base()), CompressedKlassPointers::shift());</span>
 314 
 315   log_info(cds)(&quot;Allocated temporary class space: &quot; SIZE_FORMAT &quot; bytes at &quot; PTR_FORMAT,
 316                 CompressedClassSpaceSize, p2i(tmp_class_space.base()));
 317 #endif
 318 
<a name="37" id="anc37"></a><span class="line-modified"> 319   init_shared_dump_space(&amp;_mc_region);</span>






 320   SharedBaseAddress = (size_t)_shared_rs.base();
<a name="38" id="anc38"></a><span class="line-modified"> 321   log_info(cds)(&quot;Allocated shared space: &quot; SIZE_FORMAT &quot; bytes at &quot; PTR_FORMAT,</span>
 322                 _shared_rs.size(), p2i(_shared_rs.base()));
 323 }
 324 
 325 // Called by universe_post_init()
 326 void MetaspaceShared::post_initialize(TRAPS) {
 327   if (UseSharedSpaces) {
 328     int size = FileMapInfo::get_number_of_shared_paths();
 329     if (size &gt; 0) {
 330       SystemDictionaryShared::allocate_shared_data_arrays(size, THREAD);
<a name="39" id="anc39"></a><span class="line-modified"> 331       if (!DynamicDumpSharedSpaces) {</span>
<span class="line-modified"> 332         FileMapInfo* info;</span>
<span class="line-modified"> 333         if (FileMapInfo::dynamic_info() == NULL) {</span>
<span class="line-added"> 334           info = FileMapInfo::current_info();</span>
<span class="line-added"> 335         } else {</span>
<span class="line-added"> 336           info = FileMapInfo::dynamic_info();</span>
<span class="line-added"> 337         }</span>
<span class="line-added"> 338         ClassLoaderExt::init_paths_start_index(info-&gt;app_class_paths_start_index());</span>
<span class="line-added"> 339         ClassLoaderExt::init_app_module_paths_start_index(info-&gt;app_module_paths_start_index());</span>
<span class="line-added"> 340       }</span>
 341     }
 342   }
 343 }
 344 
 345 static GrowableArray&lt;Handle&gt;* _extra_interned_strings = NULL;
 346 
 347 void MetaspaceShared::read_extra_data(const char* filename, TRAPS) {
 348   _extra_interned_strings = new (ResourceObj::C_HEAP, mtInternal)GrowableArray&lt;Handle&gt;(10000, true);
 349 
 350   HashtableTextDump reader(filename);
 351   reader.check_version(&quot;VERSION: 1.0&quot;);
 352 
 353   while (reader.remain() &gt; 0) {
 354     int utf8_length;
 355     int prefix_type = reader.scan_prefix(&amp;utf8_length);
 356     ResourceMark rm(THREAD);
 357     if (utf8_length == 0x7fffffff) {
 358       // buf_len will overflown 32-bit value.
 359       vm_exit_during_initialization(err_msg(&quot;string length too large: %d&quot;, utf8_length));
 360     }
 361     int buf_len = utf8_length+1;
 362     char* utf8_buffer = NEW_RESOURCE_ARRAY(char, buf_len);
 363     reader.get_utf8(utf8_buffer, utf8_length);
 364     utf8_buffer[utf8_length] = &#39;\0&#39;;
 365 
 366     if (prefix_type == HashtableTextDump::SymbolPrefix) {
<a name="40" id="anc40"></a><span class="line-modified"> 367       SymbolTable::new_permanent_symbol(utf8_buffer);</span>
 368     } else{
 369       assert(prefix_type == HashtableTextDump::StringPrefix, &quot;Sanity&quot;);
 370       oop s = StringTable::intern(utf8_buffer, THREAD);
 371 
 372       if (HAS_PENDING_EXCEPTION) {
 373         log_warning(cds, heap)(&quot;[line %d] extra interned string allocation failed; size too large: %d&quot;,
 374                                reader.last_line_no(), utf8_length);
 375         CLEAR_PENDING_EXCEPTION;
 376       } else {
 377 #if INCLUDE_G1GC
 378         if (UseG1GC) {
 379           typeArrayOop body = java_lang_String::value(s);
 380           const HeapRegion* hr = G1CollectedHeap::heap()-&gt;heap_region_containing(body);
 381           if (hr-&gt;is_humongous()) {
 382             // Don&#39;t keep it alive, so it will be GC&#39;ed before we dump the strings, in order
 383             // to maximize free heap space and minimize fragmentation.
 384             log_warning(cds, heap)(&quot;[line %d] extra interned string ignored; size too large: %d&quot;,
 385                                 reader.last_line_no(), utf8_length);
 386             continue;
 387           }
 388         }
 389 #endif
 390         // Interned strings are GC&#39;ed if there are no references to it, so let&#39;s
 391         // add a reference to keep this string alive.
 392         assert(s != NULL, &quot;must succeed&quot;);
 393         Handle h(THREAD, s);
 394         _extra_interned_strings-&gt;append(h);
 395       }
 396     }
 397   }
 398 }
 399 
 400 void MetaspaceShared::commit_shared_space_to(char* newtop) {
<a name="41" id="anc41"></a><span class="line-modified"> 401   Arguments::assert_is_dumping_archive();</span>
 402   char* base = _shared_rs.base();
 403   size_t need_committed_size = newtop - base;
 404   size_t has_committed_size = _shared_vs.committed_size();
 405   if (need_committed_size &lt; has_committed_size) {
 406     return;
 407   }
 408 
 409   size_t min_bytes = need_committed_size - has_committed_size;
 410   size_t preferred_bytes = 1 * M;
 411   size_t uncommitted = _shared_vs.reserved_size() - has_committed_size;
 412 
<a name="42" id="anc42"></a><span class="line-modified"> 413   size_t commit =MAX2(min_bytes, preferred_bytes);</span>
<span class="line-added"> 414   commit = MIN2(commit, uncommitted);</span>
 415   assert(commit &lt;= uncommitted, &quot;sanity&quot;);
 416 
 417   bool result = _shared_vs.expand_by(commit, false);
<a name="43" id="anc43"></a><span class="line-added"> 418   ArchivePtrMarker::expand_ptr_end((address*)_shared_vs.high());</span>
<span class="line-added"> 419 </span>
 420   if (!result) {
 421     vm_exit_during_initialization(err_msg(&quot;Failed to expand shared space to &quot; SIZE_FORMAT &quot; bytes&quot;,
 422                                           need_committed_size));
 423   }
 424 
<a name="44" id="anc44"></a><span class="line-modified"> 425   log_debug(cds)(&quot;Expanding shared spaces by &quot; SIZE_FORMAT_W(7) &quot; bytes [total &quot; SIZE_FORMAT_W(9)  &quot; bytes ending at %p]&quot;,</span>
<span class="line-modified"> 426                  commit, _shared_vs.actual_committed_size(), _shared_vs.high());</span>
<span class="line-added"> 427 }</span>
<span class="line-added"> 428 </span>
<span class="line-added"> 429 void MetaspaceShared::initialize_ptr_marker(CHeapBitMap* ptrmap) {</span>
<span class="line-added"> 430   ArchivePtrMarker::initialize(ptrmap, (address*)_shared_vs.low(), (address*)_shared_vs.high());</span>
 431 }
 432 
 433 // Read/write a data stream for restoring/preserving metadata pointers and
 434 // miscellaneous data from/to the shared archive file.
 435 
 436 void MetaspaceShared::serialize(SerializeClosure* soc) {
 437   int tag = 0;
 438   soc-&gt;do_tag(--tag);
 439 
 440   // Verify the sizes of various metadata in the system.
 441   soc-&gt;do_tag(sizeof(Method));
 442   soc-&gt;do_tag(sizeof(ConstMethod));
 443   soc-&gt;do_tag(arrayOopDesc::base_offset_in_bytes(T_BYTE));
 444   soc-&gt;do_tag(sizeof(ConstantPool));
 445   soc-&gt;do_tag(sizeof(ConstantPoolCache));
 446   soc-&gt;do_tag(objArrayOopDesc::base_offset_in_bytes());
 447   soc-&gt;do_tag(typeArrayOopDesc::base_offset_in_bytes(T_BYTE));
 448   soc-&gt;do_tag(sizeof(Symbol));
 449 
 450   // Dump/restore miscellaneous metadata.
<a name="45" id="anc45"></a><span class="line-added"> 451   JavaClasses::serialize_offsets(soc);</span>
 452   Universe::serialize(soc);
 453   soc-&gt;do_tag(--tag);
 454 
 455   // Dump/restore references to commonly used names and signatures.
 456   vmSymbols::serialize(soc);
 457   soc-&gt;do_tag(--tag);
 458 
 459   // Dump/restore the symbol/string/subgraph_info tables
 460   SymbolTable::serialize_shared_table_header(soc);
 461   StringTable::serialize_shared_table_header(soc);
 462   HeapShared::serialize_subgraph_info_table_header(soc);
 463   SystemDictionaryShared::serialize_dictionary_headers(soc);
 464 
<a name="46" id="anc46"></a>
 465   InstanceMirrorKlass::serialize_offsets(soc);
 466   soc-&gt;do_tag(--tag);
 467 
<a name="47" id="anc47"></a><span class="line-added"> 468   serialize_cloned_cpp_vtptrs(soc);</span>
<span class="line-added"> 469   soc-&gt;do_tag(--tag);</span>
<span class="line-added"> 470 </span>
 471   soc-&gt;do_tag(666);
 472 }
 473 
<a name="48" id="anc48"></a><span class="line-modified"> 474 address MetaspaceShared::i2i_entry_code_buffers(size_t total_size) {</span>
 475   if (DumpSharedSpaces) {
<a name="49" id="anc49"></a><span class="line-modified"> 476     if (_i2i_entry_code_buffers == NULL) {</span>
<span class="line-modified"> 477       _i2i_entry_code_buffers = (address)misc_code_space_alloc(total_size);</span>
<span class="line-modified"> 478       _i2i_entry_code_buffers_size = total_size;</span>
 479     }
 480   } else if (UseSharedSpaces) {
<a name="50" id="anc50"></a><span class="line-modified"> 481     assert(_i2i_entry_code_buffers != NULL, &quot;must already been initialized&quot;);</span>
 482   } else {
 483     return NULL;
 484   }
 485 
<a name="51" id="anc51"></a><span class="line-modified"> 486   assert(_i2i_entry_code_buffers_size == total_size, &quot;must not change&quot;);</span>
<span class="line-modified"> 487   return _i2i_entry_code_buffers;</span>
<span class="line-added"> 488 }</span>
<span class="line-added"> 489 </span>
<span class="line-added"> 490 uintx MetaspaceShared::object_delta_uintx(void* obj) {</span>
<span class="line-added"> 491   Arguments::assert_is_dumping_archive();</span>
<span class="line-added"> 492   if (DumpSharedSpaces) {</span>
<span class="line-added"> 493     assert(shared_rs()-&gt;contains(obj), &quot;must be&quot;);</span>
<span class="line-added"> 494   } else {</span>
<span class="line-added"> 495     assert(is_in_shared_metaspace(obj) || DynamicArchive::is_in_target_space(obj), &quot;must be&quot;);</span>
<span class="line-added"> 496   }</span>
<span class="line-added"> 497   address base_address = address(SharedBaseAddress);</span>
<span class="line-added"> 498   uintx deltax = address(obj) - base_address;</span>
<span class="line-added"> 499   return deltax;</span>
 500 }
 501 
 502 // Global object for holding classes that have been loaded.  Since this
 503 // is run at a safepoint just before exit, this is the entire set of classes.
 504 static GrowableArray&lt;Klass*&gt;* _global_klass_objects;
 505 
 506 GrowableArray&lt;Klass*&gt;* MetaspaceShared::collected_klasses() {
 507   return _global_klass_objects;
 508 }
 509 
 510 static void collect_array_classes(Klass* k) {
 511   _global_klass_objects-&gt;append_if_missing(k);
 512   if (k-&gt;is_array_klass()) {
 513     // Add in the array classes too
 514     ArrayKlass* ak = ArrayKlass::cast(k);
 515     Klass* h = ak-&gt;higher_dimension();
 516     if (h != NULL) {
 517       h-&gt;array_klasses_do(collect_array_classes);
 518     }
 519   }
 520 }
 521 
 522 class CollectClassesClosure : public KlassClosure {
 523   void do_klass(Klass* k) {
 524     if (k-&gt;is_instance_klass() &amp;&amp;
 525         SystemDictionaryShared::is_excluded_class(InstanceKlass::cast(k))) {
 526       // Don&#39;t add to the _global_klass_objects
 527     } else {
 528       _global_klass_objects-&gt;append_if_missing(k);
 529     }
 530     if (k-&gt;is_array_klass()) {
 531       // Add in the array classes too
 532       ArrayKlass* ak = ArrayKlass::cast(k);
 533       Klass* h = ak-&gt;higher_dimension();
 534       if (h != NULL) {
 535         h-&gt;array_klasses_do(collect_array_classes);
 536       }
 537     }
 538   }
 539 };
 540 
 541 static void remove_unshareable_in_classes() {
 542   for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
 543     Klass* k = _global_klass_objects-&gt;at(i);
 544     if (!k-&gt;is_objArray_klass()) {
 545       // InstanceKlass and TypeArrayKlass will in turn call remove_unshareable_info
 546       // on their array classes.
 547       assert(k-&gt;is_instance_klass() || k-&gt;is_typeArray_klass(), &quot;must be&quot;);
 548       k-&gt;remove_unshareable_info();
 549     }
 550   }
 551 }
 552 
 553 static void remove_java_mirror_in_classes() {
 554   for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
 555     Klass* k = _global_klass_objects-&gt;at(i);
 556     if (!k-&gt;is_objArray_klass()) {
 557       // InstanceKlass and TypeArrayKlass will in turn call remove_unshareable_info
 558       // on their array classes.
 559       assert(k-&gt;is_instance_klass() || k-&gt;is_typeArray_klass(), &quot;must be&quot;);
 560       k-&gt;remove_java_mirror();
 561     }
 562   }
 563 }
 564 
 565 static void clear_basic_type_mirrors() {
 566   assert(!HeapShared::is_heap_object_archiving_allowed(), &quot;Sanity&quot;);
 567   Universe::set_int_mirror(NULL);
 568   Universe::set_float_mirror(NULL);
 569   Universe::set_double_mirror(NULL);
 570   Universe::set_byte_mirror(NULL);
 571   Universe::set_bool_mirror(NULL);
 572   Universe::set_char_mirror(NULL);
 573   Universe::set_long_mirror(NULL);
 574   Universe::set_short_mirror(NULL);
 575   Universe::set_void_mirror(NULL);
 576 }
 577 
<a name="52" id="anc52"></a><span class="line-modified"> 578 static void rewrite_nofast_bytecode(const methodHandle&amp; method) {</span>
 579   BytecodeStream bcs(method);
 580   while (!bcs.is_last_bytecode()) {
 581     Bytecodes::Code opcode = bcs.next();
 582     switch (opcode) {
 583     case Bytecodes::_getfield:      *bcs.bcp() = Bytecodes::_nofast_getfield;      break;
 584     case Bytecodes::_putfield:      *bcs.bcp() = Bytecodes::_nofast_putfield;      break;
 585     case Bytecodes::_aload_0:       *bcs.bcp() = Bytecodes::_nofast_aload_0;       break;
 586     case Bytecodes::_iload: {
 587       if (!bcs.is_wide()) {
 588         *bcs.bcp() = Bytecodes::_nofast_iload;
 589       }
 590       break;
 591     }
 592     default: break;
 593     }
 594   }
 595 }
 596 
 597 // Walk all methods in the class list to ensure that they won&#39;t be modified at
 598 // run time. This includes:
 599 // [1] Rewrite all bytecodes as needed, so that the ConstMethod* will not be modified
 600 //     at run time by RewriteBytecodes/RewriteFrequentPairs
 601 // [2] Assign a fingerprint, so one doesn&#39;t need to be assigned at run-time.
<a name="53" id="anc53"></a><span class="line-modified"> 602 static void rewrite_nofast_bytecodes_and_calculate_fingerprints(Thread* thread) {</span>
 603   for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
 604     Klass* k = _global_klass_objects-&gt;at(i);
 605     if (k-&gt;is_instance_klass()) {
 606       InstanceKlass* ik = InstanceKlass::cast(k);
<a name="54" id="anc54"></a><span class="line-modified"> 607       MetaspaceShared::rewrite_nofast_bytecodes_and_calculate_fingerprints(thread, ik);</span>






 608     }
 609   }
 610 }
 611 
<a name="55" id="anc55"></a><span class="line-added"> 612 void MetaspaceShared::rewrite_nofast_bytecodes_and_calculate_fingerprints(Thread* thread, InstanceKlass* ik) {</span>
<span class="line-added"> 613   for (int i = 0; i &lt; ik-&gt;methods()-&gt;length(); i++) {</span>
<span class="line-added"> 614     methodHandle m(thread, ik-&gt;methods()-&gt;at(i));</span>
<span class="line-added"> 615     rewrite_nofast_bytecode(m);</span>
<span class="line-added"> 616     Fingerprinter fp(m);</span>
<span class="line-added"> 617     // The side effect of this call sets method&#39;s fingerprint field.</span>
<span class="line-added"> 618     fp.fingerprint();</span>
<span class="line-added"> 619   }</span>
<span class="line-added"> 620 }</span>
<span class="line-added"> 621 </span>
 622 // Objects of the Metadata types (such as Klass and ConstantPool) have C++ vtables.
 623 // (In GCC this is the field &lt;Type&gt;::_vptr, i.e., first word in the object.)
 624 //
 625 // Addresses of the vtables and the methods may be different across JVM runs,
 626 // if libjvm.so is dynamically loaded at a different base address.
 627 //
 628 // To ensure that the Metadata objects in the CDS archive always have the correct vtable:
 629 //
 630 // + at dump time:  we redirect the _vptr to point to our own vtables inside
 631 //                  the CDS image
 632 // + at run time:   we clone the actual contents of the vtables from libjvm.so
 633 //                  into our own tables.
 634 
 635 // Currently, the archive contain ONLY the following types of objects that have C++ vtables.
 636 #define CPP_VTABLE_PATCH_TYPES_DO(f) \
 637   f(ConstantPool) \
 638   f(InstanceKlass) \
 639   f(InstanceClassLoaderKlass) \
 640   f(InstanceMirrorKlass) \
 641   f(InstanceRefKlass) \
 642   f(Method) \
 643   f(ObjArrayKlass) \
 644   f(TypeArrayKlass)
 645 
 646 class CppVtableInfo {
 647   intptr_t _vtable_size;
 648   intptr_t _cloned_vtable[1];
 649 public:
 650   static int num_slots(int vtable_size) {
 651     return 1 + vtable_size; // Need to add the space occupied by _vtable_size;
 652   }
 653   int vtable_size()           { return int(uintx(_vtable_size)); }
 654   void set_vtable_size(int n) { _vtable_size = intptr_t(n); }
 655   intptr_t* cloned_vtable()   { return &amp;_cloned_vtable[0]; }
 656   void zero()                 { memset(_cloned_vtable, 0, sizeof(intptr_t) * vtable_size()); }
 657   // Returns the address of the next CppVtableInfo that can be placed immediately after this CppVtableInfo
 658   static size_t byte_size(int vtable_size) {
 659     CppVtableInfo i;
 660     return pointer_delta(&amp;i._cloned_vtable[vtable_size], &amp;i, sizeof(u1));
 661   }
 662 };
 663 
 664 template &lt;class T&gt; class CppVtableCloner : public T {
 665   static intptr_t* vtable_of(Metadata&amp; m) {
 666     return *((intptr_t**)&amp;m);
 667   }
 668   static CppVtableInfo* _info;
 669 
 670   static int get_vtable_length(const char* name);
 671 
 672 public:
 673   // Allocate and initialize the C++ vtable, starting from top, but do not go past end.
 674   static intptr_t* allocate(const char* name);
 675 
 676   // Clone the vtable to ...
 677   static intptr_t* clone_vtable(const char* name, CppVtableInfo* info);
 678 
 679   static void zero_vtable_clone() {
 680     assert(DumpSharedSpaces, &quot;dump-time only&quot;);
 681     _info-&gt;zero();
 682   }
 683 
<a name="56" id="anc56"></a>





 684   static bool is_valid_shared_object(const T* obj) {
 685     intptr_t* vptr = *(intptr_t**)obj;
 686     return vptr == _info-&gt;cloned_vtable();
 687   }
 688 };
 689 
 690 template &lt;class T&gt; CppVtableInfo* CppVtableCloner&lt;T&gt;::_info = NULL;
 691 
 692 template &lt;class T&gt;
 693 intptr_t* CppVtableCloner&lt;T&gt;::allocate(const char* name) {
<a name="57" id="anc57"></a><span class="line-modified"> 694   assert(is_aligned(_mc_region.top(), sizeof(intptr_t)), &quot;bad alignment&quot;);</span>
 695   int n = get_vtable_length(name);
<a name="58" id="anc58"></a><span class="line-modified"> 696   _info = (CppVtableInfo*)_mc_region.allocate(CppVtableInfo::byte_size(n), sizeof(intptr_t));</span>
 697   _info-&gt;set_vtable_size(n);
 698 
 699   intptr_t* p = clone_vtable(name, _info);
<a name="59" id="anc59"></a><span class="line-modified"> 700   assert((char*)p == _mc_region.top(), &quot;must be&quot;);</span>
 701 
<a name="60" id="anc60"></a><span class="line-modified"> 702   return _info-&gt;cloned_vtable();</span>
 703 }
 704 
 705 template &lt;class T&gt;
 706 intptr_t* CppVtableCloner&lt;T&gt;::clone_vtable(const char* name, CppVtableInfo* info) {
 707   if (!DumpSharedSpaces) {
 708     assert(_info == 0, &quot;_info is initialized only at dump time&quot;);
 709     _info = info; // Remember it -- it will be used by MetaspaceShared::is_valid_shared_method()
 710   }
 711   T tmp; // Allocate temporary dummy metadata object to get to the original vtable.
 712   int n = info-&gt;vtable_size();
 713   intptr_t* srcvtable = vtable_of(tmp);
 714   intptr_t* dstvtable = info-&gt;cloned_vtable();
 715 
 716   // We already checked (and, if necessary, adjusted n) when the vtables were allocated, so we are
 717   // safe to do memcpy.
 718   log_debug(cds, vtables)(&quot;Copying %3d vtable entries for %s&quot;, n, name);
 719   memcpy(dstvtable, srcvtable, sizeof(intptr_t) * n);
 720   return dstvtable + n;
 721 }
 722 
 723 // To determine the size of the vtable for each type, we use the following
 724 // trick by declaring 2 subclasses:
 725 //
 726 //   class CppVtableTesterA: public InstanceKlass {virtual int   last_virtual_method() {return 1;}    };
 727 //   class CppVtableTesterB: public InstanceKlass {virtual void* last_virtual_method() {return NULL}; };
 728 //
 729 // CppVtableTesterA and CppVtableTesterB&#39;s vtables have the following properties:
 730 // - Their size (N+1) is exactly one more than the size of InstanceKlass&#39;s vtable (N)
 731 // - The first N entries have are exactly the same as in InstanceKlass&#39;s vtable.
 732 // - Their last entry is different.
 733 //
 734 // So to determine the value of N, we just walk CppVtableTesterA and CppVtableTesterB&#39;s tables
 735 // and find the first entry that&#39;s different.
 736 //
 737 // This works on all C++ compilers supported by Oracle, but you may need to tweak it for more
 738 // esoteric compilers.
 739 
 740 template &lt;class T&gt; class CppVtableTesterB: public T {
 741 public:
 742   virtual int last_virtual_method() {return 1;}
 743 };
 744 
 745 template &lt;class T&gt; class CppVtableTesterA : public T {
 746 public:
 747   virtual void* last_virtual_method() {
 748     // Make this different than CppVtableTesterB::last_virtual_method so the C++
 749     // compiler/linker won&#39;t alias the two functions.
 750     return NULL;
 751   }
 752 };
 753 
 754 template &lt;class T&gt;
 755 int CppVtableCloner&lt;T&gt;::get_vtable_length(const char* name) {
 756   CppVtableTesterA&lt;T&gt; a;
 757   CppVtableTesterB&lt;T&gt; b;
 758 
 759   intptr_t* avtable = vtable_of(a);
 760   intptr_t* bvtable = vtable_of(b);
 761 
 762   // Start at slot 1, because slot 0 may be RTTI (on Solaris/Sparc)
 763   int vtable_len = 1;
 764   for (; ; vtable_len++) {
 765     if (avtable[vtable_len] != bvtable[vtable_len]) {
 766       break;
 767     }
 768   }
 769   log_debug(cds, vtables)(&quot;Found   %3d vtable entries for %s&quot;, vtable_len, name);
 770 
 771   return vtable_len;
 772 }
 773 
 774 #define ALLOC_CPP_VTABLE_CLONE(c) \
<a name="61" id="anc61"></a><span class="line-modified"> 775   _cloned_cpp_vtptrs[c##_Kind] = CppVtableCloner&lt;c&gt;::allocate(#c); \</span>
<span class="line-added"> 776   ArchivePtrMarker::mark_pointer(&amp;_cloned_cpp_vtptrs[c##_Kind]);</span>
 777 
 778 #define CLONE_CPP_VTABLE(c) \
 779   p = CppVtableCloner&lt;c&gt;::clone_vtable(#c, (CppVtableInfo*)p);
 780 
 781 #define ZERO_CPP_VTABLE(c) \
 782  CppVtableCloner&lt;c&gt;::zero_vtable_clone();
 783 
<a name="62" id="anc62"></a><span class="line-modified"> 784 //------------------------------ for DynamicDumpSharedSpaces - start</span>
<span class="line-modified"> 785 #define DECLARE_CLONED_VTABLE_KIND(c) c ## _Kind,</span>
<span class="line-added"> 786 </span>
<span class="line-added"> 787 enum {</span>
<span class="line-added"> 788   // E.g., ConstantPool_Kind == 0, InstanceKlass == 1, etc.</span>
<span class="line-added"> 789   CPP_VTABLE_PATCH_TYPES_DO(DECLARE_CLONED_VTABLE_KIND)</span>
<span class="line-added"> 790   _num_cloned_vtable_kinds</span>
<span class="line-added"> 791 };</span>
<span class="line-added"> 792 </span>
<span class="line-added"> 793 // This is the index of all the cloned vtables. E.g., for</span>
<span class="line-added"> 794 //     ConstantPool* cp = ....; // an archived constant pool</span>
<span class="line-added"> 795 //     InstanceKlass* ik = ....;// an archived class</span>
<span class="line-added"> 796 // the following holds true:</span>
<span class="line-added"> 797 //     _cloned_cpp_vtptrs[ConstantPool_Kind]  == ((intptr_t**)cp)[0]</span>
<span class="line-added"> 798 //     _cloned_cpp_vtptrs[InstanceKlass_Kind] == ((intptr_t**)ik)[0]</span>
<span class="line-added"> 799 static intptr_t** _cloned_cpp_vtptrs = NULL;</span>
<span class="line-added"> 800 </span>
<span class="line-added"> 801 void MetaspaceShared::allocate_cloned_cpp_vtptrs() {</span>
<span class="line-added"> 802   assert(DumpSharedSpaces, &quot;must&quot;);</span>
<span class="line-added"> 803   size_t vtptrs_bytes = _num_cloned_vtable_kinds * sizeof(intptr_t*);</span>
<span class="line-added"> 804   _cloned_cpp_vtptrs = (intptr_t**)_mc_region.allocate(vtptrs_bytes, sizeof(intptr_t*));</span>
<span class="line-added"> 805 }</span>
<span class="line-added"> 806 </span>
<span class="line-added"> 807 void MetaspaceShared::serialize_cloned_cpp_vtptrs(SerializeClosure* soc) {</span>
<span class="line-added"> 808   soc-&gt;do_ptr((void**)&amp;_cloned_cpp_vtptrs);</span>
<span class="line-added"> 809 }</span>
<span class="line-added"> 810 </span>
<span class="line-added"> 811 intptr_t* MetaspaceShared::fix_cpp_vtable_for_dynamic_archive(MetaspaceObj::Type msotype, address obj) {</span>
<span class="line-added"> 812   Arguments::assert_is_dumping_archive();</span>
<span class="line-added"> 813   int kind = -1;</span>
<span class="line-added"> 814   switch (msotype) {</span>
<span class="line-added"> 815   case MetaspaceObj::SymbolType:</span>
<span class="line-added"> 816   case MetaspaceObj::TypeArrayU1Type:</span>
<span class="line-added"> 817   case MetaspaceObj::TypeArrayU2Type:</span>
<span class="line-added"> 818   case MetaspaceObj::TypeArrayU4Type:</span>
<span class="line-added"> 819   case MetaspaceObj::TypeArrayU8Type:</span>
<span class="line-added"> 820   case MetaspaceObj::TypeArrayOtherType:</span>
<span class="line-added"> 821   case MetaspaceObj::ConstMethodType:</span>
<span class="line-added"> 822   case MetaspaceObj::ConstantPoolCacheType:</span>
<span class="line-added"> 823   case MetaspaceObj::AnnotationsType:</span>
<span class="line-added"> 824   case MetaspaceObj::MethodCountersType:</span>
<span class="line-added"> 825   case MetaspaceObj::RecordComponentType:</span>
<span class="line-added"> 826     // These have no vtables.</span>
<span class="line-added"> 827     break;</span>
<span class="line-added"> 828   case MetaspaceObj::ClassType:</span>
<span class="line-added"> 829     {</span>
<span class="line-added"> 830       Klass* k = (Klass*)obj;</span>
<span class="line-added"> 831       assert(k-&gt;is_klass(), &quot;must be&quot;);</span>
<span class="line-added"> 832       if (k-&gt;is_instance_klass()) {</span>
<span class="line-added"> 833         InstanceKlass* ik = InstanceKlass::cast(k);</span>
<span class="line-added"> 834         if (ik-&gt;is_class_loader_instance_klass()) {</span>
<span class="line-added"> 835           kind = InstanceClassLoaderKlass_Kind;</span>
<span class="line-added"> 836         } else if (ik-&gt;is_reference_instance_klass()) {</span>
<span class="line-added"> 837           kind = InstanceRefKlass_Kind;</span>
<span class="line-added"> 838         } else if (ik-&gt;is_mirror_instance_klass()) {</span>
<span class="line-added"> 839           kind = InstanceMirrorKlass_Kind;</span>
<span class="line-added"> 840         } else {</span>
<span class="line-added"> 841           kind = InstanceKlass_Kind;</span>
<span class="line-added"> 842         }</span>
<span class="line-added"> 843       } else if (k-&gt;is_typeArray_klass()) {</span>
<span class="line-added"> 844         kind = TypeArrayKlass_Kind;</span>
<span class="line-added"> 845       } else {</span>
<span class="line-added"> 846         assert(k-&gt;is_objArray_klass(), &quot;must be&quot;);</span>
<span class="line-added"> 847         kind = ObjArrayKlass_Kind;</span>
<span class="line-added"> 848       }</span>
<span class="line-added"> 849     }</span>
<span class="line-added"> 850     break;</span>
<span class="line-added"> 851 </span>
<span class="line-added"> 852   case MetaspaceObj::MethodType:</span>
<span class="line-added"> 853     {</span>
<span class="line-added"> 854       Method* m = (Method*)obj;</span>
<span class="line-added"> 855       assert(m-&gt;is_method(), &quot;must be&quot;);</span>
<span class="line-added"> 856       kind = Method_Kind;</span>
<span class="line-added"> 857     }</span>
<span class="line-added"> 858     break;</span>
<span class="line-added"> 859 </span>
<span class="line-added"> 860   case MetaspaceObj::MethodDataType:</span>
<span class="line-added"> 861     // We don&#39;t archive MethodData &lt;-- should have been removed in removed_unsharable_info</span>
<span class="line-added"> 862     ShouldNotReachHere();</span>
<span class="line-added"> 863     break;</span>
<span class="line-added"> 864 </span>
<span class="line-added"> 865   case MetaspaceObj::ConstantPoolType:</span>
<span class="line-added"> 866     {</span>
<span class="line-added"> 867       ConstantPool *cp = (ConstantPool*)obj;</span>
<span class="line-added"> 868       assert(cp-&gt;is_constantPool(), &quot;must be&quot;);</span>
<span class="line-added"> 869       kind = ConstantPool_Kind;</span>
<span class="line-added"> 870     }</span>
<span class="line-added"> 871     break;</span>
<span class="line-added"> 872 </span>
<span class="line-added"> 873   default:</span>
<span class="line-added"> 874     ShouldNotReachHere();</span>
<span class="line-added"> 875   }</span>
<span class="line-added"> 876 </span>
<span class="line-added"> 877   if (kind &gt;= 0) {</span>
<span class="line-added"> 878     assert(kind &lt; _num_cloned_vtable_kinds, &quot;must be&quot;);</span>
<span class="line-added"> 879     return _cloned_cpp_vtptrs[kind];</span>
<span class="line-added"> 880   } else {</span>
<span class="line-added"> 881     return NULL;</span>
<span class="line-added"> 882   }</span>
<span class="line-added"> 883 }</span>
<span class="line-added"> 884 </span>
<span class="line-added"> 885 //------------------------------ for DynamicDumpSharedSpaces - end</span>
<span class="line-added"> 886 </span>
<span class="line-added"> 887 // This can be called at both dump time and run time:</span>
<span class="line-added"> 888 // - clone the contents of the c++ vtables into the space</span>
<span class="line-added"> 889 //   allocated by allocate_cpp_vtable_clones()</span>
<span class="line-added"> 890 void MetaspaceShared::clone_cpp_vtables(intptr_t* p) {</span>
 891   assert(DumpSharedSpaces || UseSharedSpaces, &quot;sanity&quot;);
 892   CPP_VTABLE_PATCH_TYPES_DO(CLONE_CPP_VTABLE);
<a name="63" id="anc63"></a>
 893 }
 894 
 895 void MetaspaceShared::zero_cpp_vtable_clones_for_writing() {
 896   assert(DumpSharedSpaces, &quot;dump-time only&quot;);
 897   CPP_VTABLE_PATCH_TYPES_DO(ZERO_CPP_VTABLE);
 898 }
 899 
 900 // Allocate and initialize the C++ vtables, starting from top, but do not go past end.
<a name="64" id="anc64"></a><span class="line-modified"> 901 char* MetaspaceShared::allocate_cpp_vtable_clones() {</span>
<span class="line-added"> 902   char* cloned_vtables = _mc_region.top(); // This is the beginning of all the cloned vtables</span>
<span class="line-added"> 903 </span>
 904   assert(DumpSharedSpaces, &quot;dump-time only&quot;);
 905   // Layout (each slot is a intptr_t):
 906   //   [number of slots in the first vtable = n1]
 907   //   [ &lt;n1&gt; slots for the first vtable]
 908   //   [number of slots in the first second = n2]
 909   //   [ &lt;n2&gt; slots for the second vtable]
 910   //   ...
 911   // The order of the vtables is the same as the CPP_VTAB_PATCH_TYPES_DO macro.
 912   CPP_VTABLE_PATCH_TYPES_DO(ALLOC_CPP_VTABLE_CLONE);
<a name="65" id="anc65"></a>
 913 
<a name="66" id="anc66"></a><span class="line-modified"> 914   return cloned_vtables;</span>






























 915 }
 916 
 917 bool MetaspaceShared::is_valid_shared_method(const Method* m) {
 918   assert(is_in_shared_metaspace(m), &quot;must be&quot;);
 919   return CppVtableCloner&lt;Method&gt;::is_valid_shared_object(m);
 920 }
 921 
<a name="67" id="anc67"></a><span class="line-modified"> 922 void WriteClosure::do_oop(oop* o) {</span>
<span class="line-modified"> 923   if (*o == NULL) {</span>
<span class="line-modified"> 924     _dump_region-&gt;append_intptr_t(0);</span>
<span class="line-modified"> 925   } else {</span>
<span class="line-modified"> 926     assert(HeapShared::is_heap_object_archiving_allowed(),</span>
<span class="line-modified"> 927            &quot;Archiving heap object is not allowed&quot;);</span>
<span class="line-modified"> 928     _dump_region-&gt;append_intptr_t(</span>
<span class="line-modified"> 929       (intptr_t)CompressedOops::encode_not_null(*o));</span>


























 930   }
<a name="68" id="anc68"></a><span class="line-added"> 931 }</span>
 932 
<a name="69" id="anc69"></a><span class="line-modified"> 933 void WriteClosure::do_region(u_char* start, size_t size) {</span>
<span class="line-modified"> 934   assert((intptr_t)start % sizeof(intptr_t) == 0, &quot;bad alignment&quot;);</span>
<span class="line-modified"> 935   assert(size % sizeof(intptr_t) == 0, &quot;bad size&quot;);</span>
<span class="line-modified"> 936   do_tag((int)size);</span>
<span class="line-modified"> 937   while (size &gt; 0) {</span>
<span class="line-modified"> 938     _dump_region-&gt;append_intptr_t(*(intptr_t*)start, true);</span>
<span class="line-modified"> 939     start += sizeof(intptr_t);</span>
<span class="line-modified"> 940     size -= sizeof(intptr_t);</span>

 941   }
<a name="70" id="anc70"></a><span class="line-modified"> 942 }</span>


 943 
 944 // This is for dumping detailed statistics for the allocations
 945 // in the shared spaces.
 946 class DumpAllocStats : public ResourceObj {
 947 public:
 948 
 949   // Here&#39;s poor man&#39;s enum inheritance
 950 #define SHAREDSPACE_OBJ_TYPES_DO(f) \
 951   METASPACE_OBJ_TYPES_DO(f) \
 952   f(SymbolHashentry) \
 953   f(SymbolBucket) \
 954   f(StringHashentry) \
 955   f(StringBucket) \
 956   f(Other)
 957 
 958   enum Type {
 959     // Types are MetaspaceObj::ClassType, MetaspaceObj::SymbolType, etc
 960     SHAREDSPACE_OBJ_TYPES_DO(METASPACE_OBJ_TYPE_DECLARE)
 961     _number_of_types
 962   };
 963 
 964   static const char * type_name(Type type) {
 965     switch(type) {
 966     SHAREDSPACE_OBJ_TYPES_DO(METASPACE_OBJ_TYPE_NAME_CASE)
 967     default:
 968       ShouldNotReachHere();
 969       return NULL;
 970     }
 971   }
 972 
 973 public:
 974   enum { RO = 0, RW = 1 };
 975 
 976   int _counts[2][_number_of_types];
 977   int _bytes [2][_number_of_types];
 978 
 979   DumpAllocStats() {
 980     memset(_counts, 0, sizeof(_counts));
 981     memset(_bytes,  0, sizeof(_bytes));
 982   };
 983 
 984   void record(MetaspaceObj::Type type, int byte_size, bool read_only) {
 985     assert(int(type) &gt;= 0 &amp;&amp; type &lt; MetaspaceObj::_number_of_types, &quot;sanity&quot;);
 986     int which = (read_only) ? RO : RW;
 987     _counts[which][type] ++;
 988     _bytes [which][type] += byte_size;
 989   }
 990 
 991   void record_other_type(int byte_size, bool read_only) {
 992     int which = (read_only) ? RO : RW;
 993     _bytes [which][OtherType] += byte_size;
 994   }
<a name="71" id="anc71"></a><span class="line-modified"> 995   void print_stats(int ro_all, int rw_all, int mc_all);</span>
 996 };
 997 
<a name="72" id="anc72"></a><span class="line-modified"> 998 void DumpAllocStats::print_stats(int ro_all, int rw_all, int mc_all) {</span>
 999   // Calculate size of data that was not allocated by Metaspace::allocate()
1000   MetaspaceSharedStats *stats = MetaspaceShared::stats();
1001 
1002   // symbols
1003   _counts[RO][SymbolHashentryType] = stats-&gt;symbol.hashentry_count;
1004   _bytes [RO][SymbolHashentryType] = stats-&gt;symbol.hashentry_bytes;
1005 
1006   _counts[RO][SymbolBucketType] = stats-&gt;symbol.bucket_count;
1007   _bytes [RO][SymbolBucketType] = stats-&gt;symbol.bucket_bytes;
1008 
1009   // strings
1010   _counts[RO][StringHashentryType] = stats-&gt;string.hashentry_count;
1011   _bytes [RO][StringHashentryType] = stats-&gt;string.hashentry_bytes;
1012 
1013   _counts[RO][StringBucketType] = stats-&gt;string.bucket_count;
1014   _bytes [RO][StringBucketType] = stats-&gt;string.bucket_bytes;
1015 
1016   // TODO: count things like dictionary, vtable, etc
<a name="73" id="anc73"></a><span class="line-modified">1017   _bytes[RW][OtherType] += mc_all;</span>
<span class="line-modified">1018   rw_all += mc_all; // mc is mapped Read/Write</span>
1019 
1020   // prevent divide-by-zero
1021   if (ro_all &lt; 1) {
1022     ro_all = 1;
1023   }
1024   if (rw_all &lt; 1) {
1025     rw_all = 1;
1026   }
1027 
1028   int all_ro_count = 0;
1029   int all_ro_bytes = 0;
1030   int all_rw_count = 0;
1031   int all_rw_bytes = 0;
1032 
1033 // To make fmt_stats be a syntactic constant (for format warnings), use #define.
1034 #define fmt_stats &quot;%-20s: %8d %10d %5.1f | %8d %10d %5.1f | %8d %10d %5.1f&quot;
1035   const char *sep = &quot;--------------------+---------------------------+---------------------------+--------------------------&quot;;
1036   const char *hdr = &quot;                        ro_cnt   ro_bytes     % |   rw_cnt   rw_bytes     % |  all_cnt  all_bytes     %&quot;;
1037 
1038   LogMessage(cds) msg;
1039 
<a name="74" id="anc74"></a><span class="line-modified">1040   msg.debug(&quot;Detailed metadata info (excluding st regions; rw stats include mc regions):&quot;);</span>
<span class="line-modified">1041   msg.debug(&quot;%s&quot;, hdr);</span>
<span class="line-modified">1042   msg.debug(&quot;%s&quot;, sep);</span>
1043   for (int type = 0; type &lt; int(_number_of_types); type ++) {
1044     const char *name = type_name((Type)type);
1045     int ro_count = _counts[RO][type];
1046     int ro_bytes = _bytes [RO][type];
1047     int rw_count = _counts[RW][type];
1048     int rw_bytes = _bytes [RW][type];
1049     int count = ro_count + rw_count;
1050     int bytes = ro_bytes + rw_bytes;
1051 
1052     double ro_perc = percent_of(ro_bytes, ro_all);
1053     double rw_perc = percent_of(rw_bytes, rw_all);
1054     double perc    = percent_of(bytes, ro_all + rw_all);
1055 
<a name="75" id="anc75"></a><span class="line-modified">1056     msg.debug(fmt_stats, name,</span>
1057                          ro_count, ro_bytes, ro_perc,
1058                          rw_count, rw_bytes, rw_perc,
1059                          count, bytes, perc);
1060 
1061     all_ro_count += ro_count;
1062     all_ro_bytes += ro_bytes;
1063     all_rw_count += rw_count;
1064     all_rw_bytes += rw_bytes;
1065   }
1066 
1067   int all_count = all_ro_count + all_rw_count;
1068   int all_bytes = all_ro_bytes + all_rw_bytes;
1069 
1070   double all_ro_perc = percent_of(all_ro_bytes, ro_all);
1071   double all_rw_perc = percent_of(all_rw_bytes, rw_all);
1072   double all_perc    = percent_of(all_bytes, ro_all + rw_all);
1073 
<a name="76" id="anc76"></a><span class="line-modified">1074   msg.debug(&quot;%s&quot;, sep);</span>
<span class="line-modified">1075   msg.debug(fmt_stats, &quot;Total&quot;,</span>
1076                        all_ro_count, all_ro_bytes, all_ro_perc,
1077                        all_rw_count, all_rw_bytes, all_rw_perc,
1078                        all_count, all_bytes, all_perc);
1079 
1080   assert(all_ro_bytes == ro_all, &quot;everything should have been counted&quot;);
1081   assert(all_rw_bytes == rw_all, &quot;everything should have been counted&quot;);
1082 
1083 #undef fmt_stats
1084 }
1085 
1086 // Populate the shared space.
1087 
1088 class VM_PopulateDumpSharedSpace: public VM_Operation {
1089 private:
1090   GrowableArray&lt;MemRegion&gt; *_closed_archive_heap_regions;
1091   GrowableArray&lt;MemRegion&gt; *_open_archive_heap_regions;
1092 
1093   GrowableArray&lt;ArchiveHeapOopmapInfo&gt; *_closed_archive_heap_oopmaps;
1094   GrowableArray&lt;ArchiveHeapOopmapInfo&gt; *_open_archive_heap_oopmaps;
1095 
1096   void dump_java_heap_objects() NOT_CDS_JAVA_HEAP_RETURN;
1097   void dump_archive_heap_oopmaps() NOT_CDS_JAVA_HEAP_RETURN;
1098   void dump_archive_heap_oopmaps(GrowableArray&lt;MemRegion&gt;* regions,
1099                                  GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* oopmaps);
1100   void dump_symbols();
1101   char* dump_read_only_tables();
<a name="77" id="anc77"></a><span class="line-added">1102   void print_class_stats();</span>
1103   void print_region_stats();
<a name="78" id="anc78"></a><span class="line-added">1104   void print_bitmap_region_stats(size_t size, size_t total_size);</span>
1105   void print_heap_region_stats(GrowableArray&lt;MemRegion&gt; *heap_mem,
<a name="79" id="anc79"></a><span class="line-modified">1106                                const char *name, size_t total_size);</span>
<span class="line-added">1107   void relocate_to_default_base_address(CHeapBitMap* ptrmap);</span>
<span class="line-added">1108 </span>
1109 public:
1110 
1111   VMOp_Type type() const { return VMOp_PopulateDumpSharedSpace; }
1112   void doit();   // outline because gdb sucks
<a name="80" id="anc80"></a>
1113   bool allow_nested_vm_operations() const { return true; }
1114 }; // class VM_PopulateDumpSharedSpace
1115 
1116 class SortedSymbolClosure: public SymbolClosure {
1117   GrowableArray&lt;Symbol*&gt; _symbols;
1118   virtual void do_symbol(Symbol** sym) {
1119     assert((*sym)-&gt;is_permanent(), &quot;archived symbols must be permanent&quot;);
1120     _symbols.append(*sym);
1121   }
1122   static int compare_symbols_by_address(Symbol** a, Symbol** b) {
1123     if (a[0] &lt; b[0]) {
1124       return -1;
1125     } else if (a[0] == b[0]) {
1126       return 0;
1127     } else {
1128       return 1;
1129     }
1130   }
1131 
1132 public:
1133   SortedSymbolClosure() {
1134     SymbolTable::symbols_do(this);
1135     _symbols.sort(compare_symbols_by_address);
1136   }
1137   GrowableArray&lt;Symbol*&gt;* get_sorted_symbols() {
1138     return &amp;_symbols;
1139   }
1140 };
1141 
1142 // ArchiveCompactor --
1143 //
1144 // This class is the central piece of shared archive compaction -- all metaspace data are
1145 // initially allocated outside of the shared regions. ArchiveCompactor copies the
1146 // metaspace data into their final location in the shared regions.
1147 
1148 class ArchiveCompactor : AllStatic {
1149   static const int INITIAL_TABLE_SIZE = 8087;
1150   static const int MAX_TABLE_SIZE     = 1000000;
1151 
1152   static DumpAllocStats* _alloc_stats;
1153   static SortedSymbolClosure* _ssc;
1154 
1155   typedef KVHashtable&lt;address, address, mtInternal&gt; RelocationTable;
1156   static RelocationTable* _new_loc_table;
1157 
1158 public:
1159   static void initialize() {
1160     _alloc_stats = new(ResourceObj::C_HEAP, mtInternal)DumpAllocStats;
1161     _new_loc_table = new RelocationTable(INITIAL_TABLE_SIZE);
1162   }
1163   static DumpAllocStats* alloc_stats() {
1164     return _alloc_stats;
1165   }
1166 
1167   // Use this when you allocate space with MetaspaceShare::read_only_space_alloc()
1168   // outside of ArchiveCompactor::allocate(). These are usually for misc tables
1169   // that are allocated in the RO space.
1170   class OtherROAllocMark {
1171     char* _oldtop;
1172   public:
1173     OtherROAllocMark() {
1174       _oldtop = _ro_region.top();
1175     }
1176     ~OtherROAllocMark() {
1177       char* newtop = _ro_region.top();
1178       ArchiveCompactor::alloc_stats()-&gt;record_other_type(int(newtop - _oldtop), true);
1179     }
1180   };
1181 
1182   static void allocate(MetaspaceClosure::Ref* ref, bool read_only) {
1183     address obj = ref-&gt;obj();
1184     int bytes = ref-&gt;size() * BytesPerWord;
1185     char* p;
1186     size_t alignment = BytesPerWord;
1187     char* oldtop;
1188     char* newtop;
1189 
1190     if (read_only) {
1191       oldtop = _ro_region.top();
1192       p = _ro_region.allocate(bytes, alignment);
1193       newtop = _ro_region.top();
1194     } else {
1195       oldtop = _rw_region.top();
1196       if (ref-&gt;msotype() == MetaspaceObj::ClassType) {
1197         // Save a pointer immediate in front of an InstanceKlass, so
1198         // we can do a quick lookup from InstanceKlass* -&gt; RunTimeSharedClassInfo*
1199         // without building another hashtable. See RunTimeSharedClassInfo::get_for()
1200         // in systemDictionaryShared.cpp.
1201         Klass* klass = (Klass*)obj;
1202         if (klass-&gt;is_instance_klass()) {
1203           SystemDictionaryShared::validate_before_archiving(InstanceKlass::cast(klass));
1204           _rw_region.allocate(sizeof(address), BytesPerWord);
1205         }
1206       }
1207       p = _rw_region.allocate(bytes, alignment);
1208       newtop = _rw_region.top();
1209     }
1210     memcpy(p, obj, bytes);
<a name="81" id="anc81"></a><span class="line-added">1211 </span>
<span class="line-added">1212     intptr_t* cloned_vtable = MetaspaceShared::fix_cpp_vtable_for_dynamic_archive(ref-&gt;msotype(), (address)p);</span>
<span class="line-added">1213     if (cloned_vtable != NULL) {</span>
<span class="line-added">1214       *(address*)p = (address)cloned_vtable;</span>
<span class="line-added">1215       ArchivePtrMarker::mark_pointer((address*)p);</span>
<span class="line-added">1216     }</span>
<span class="line-added">1217 </span>
1218     assert(_new_loc_table-&gt;lookup(obj) == NULL, &quot;each object can be relocated at most once&quot;);
1219     _new_loc_table-&gt;add(obj, (address)p);
1220     log_trace(cds)(&quot;Copy: &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT &quot; %d&quot;, p2i(obj), p2i(p), bytes);
1221     if (_new_loc_table-&gt;maybe_grow(MAX_TABLE_SIZE)) {
1222       log_info(cds, hashtables)(&quot;Expanded _new_loc_table to %d&quot;, _new_loc_table-&gt;table_size());
1223     }
1224     _alloc_stats-&gt;record(ref-&gt;msotype(), int(newtop - oldtop), read_only);
1225   }
1226 
1227   static address get_new_loc(MetaspaceClosure::Ref* ref) {
1228     address* pp = _new_loc_table-&gt;lookup(ref-&gt;obj());
1229     assert(pp != NULL, &quot;must be&quot;);
1230     return *pp;
1231   }
1232 
1233 private:
1234   // Makes a shallow copy of visited MetaspaceObj&#39;s
1235   class ShallowCopier: public UniqueMetaspaceClosure {
1236     bool _read_only;
1237   public:
1238     ShallowCopier(bool read_only) : _read_only(read_only) {}
1239 
<a name="82" id="anc82"></a><span class="line-modified">1240     virtual bool do_unique_ref(Ref* ref, bool read_only) {</span>
1241       if (read_only == _read_only) {
1242         allocate(ref, read_only);
1243       }
<a name="83" id="anc83"></a><span class="line-added">1244       return true; // recurse into ref.obj()</span>
1245     }
1246   };
1247 
1248   // Relocate embedded pointers within a MetaspaceObj&#39;s shallow copy
1249   class ShallowCopyEmbeddedRefRelocator: public UniqueMetaspaceClosure {
1250   public:
<a name="84" id="anc84"></a><span class="line-modified">1251     virtual bool do_unique_ref(Ref* ref, bool read_only) {</span>
1252       address new_loc = get_new_loc(ref);
1253       RefRelocator refer;
1254       ref-&gt;metaspace_pointers_do_at(&amp;refer, new_loc);
<a name="85" id="anc85"></a><span class="line-added">1255       return true; // recurse into ref.obj()</span>
<span class="line-added">1256     }</span>
<span class="line-added">1257     virtual void push_special(SpecialRef type, Ref* ref, intptr_t* p) {</span>
<span class="line-added">1258       assert(type == _method_entry_ref, &quot;only special type allowed for now&quot;);</span>
<span class="line-added">1259       address obj = ref-&gt;obj();</span>
<span class="line-added">1260       address new_obj = get_new_loc(ref);</span>
<span class="line-added">1261       size_t offset = pointer_delta(p, obj,  sizeof(u1));</span>
<span class="line-added">1262       intptr_t* new_p = (intptr_t*)(new_obj + offset);</span>
<span class="line-added">1263       assert(*p == *new_p, &quot;must be a copy&quot;);</span>
<span class="line-added">1264       ArchivePtrMarker::mark_pointer((address*)new_p);</span>
1265     }
1266   };
1267 
1268   // Relocate a reference to point to its shallow copy
1269   class RefRelocator: public MetaspaceClosure {
1270   public:
1271     virtual bool do_ref(Ref* ref, bool read_only) {
1272       if (ref-&gt;not_null()) {
1273         ref-&gt;update(get_new_loc(ref));
<a name="86" id="anc86"></a><span class="line-added">1274         ArchivePtrMarker::mark_pointer(ref-&gt;addr());</span>
1275       }
1276       return false; // Do not recurse.
1277     }
1278   };
1279 
1280 #ifdef ASSERT
1281   class IsRefInArchiveChecker: public MetaspaceClosure {
1282   public:
1283     virtual bool do_ref(Ref* ref, bool read_only) {
1284       if (ref-&gt;not_null()) {
1285         char* obj = (char*)ref-&gt;obj();
1286         assert(_ro_region.contains(obj) || _rw_region.contains(obj),
1287                &quot;must be relocated to point to CDS archive&quot;);
1288       }
1289       return false; // Do not recurse.
1290     }
1291   };
1292 #endif
1293 
1294 public:
1295   static void copy_and_compact() {
1296     ResourceMark rm;
1297     SortedSymbolClosure the_ssc; // StackObj
1298     _ssc = &amp;the_ssc;
1299 
<a name="87" id="anc87"></a><span class="line-modified">1300     log_info(cds)(&quot;Scanning all metaspace objects ... &quot;);</span>
1301     {
1302       // allocate and shallow-copy RW objects, immediately following the MC region
<a name="88" id="anc88"></a><span class="line-modified">1303       log_info(cds)(&quot;Allocating RW objects ... &quot;);</span>
1304       _mc_region.pack(&amp;_rw_region);
1305 
1306       ResourceMark rm;
1307       ShallowCopier rw_copier(false);
1308       iterate_roots(&amp;rw_copier);
1309     }
1310     {
1311       // allocate and shallow-copy of RO object, immediately following the RW region
<a name="89" id="anc89"></a><span class="line-modified">1312       log_info(cds)(&quot;Allocating RO objects ... &quot;);</span>
1313       _rw_region.pack(&amp;_ro_region);
1314 
1315       ResourceMark rm;
1316       ShallowCopier ro_copier(true);
1317       iterate_roots(&amp;ro_copier);
1318     }
1319     {
<a name="90" id="anc90"></a><span class="line-modified">1320       log_info(cds)(&quot;Relocating embedded pointers ... &quot;);</span>
1321       ResourceMark rm;
1322       ShallowCopyEmbeddedRefRelocator emb_reloc;
1323       iterate_roots(&amp;emb_reloc);
1324     }
1325     {
<a name="91" id="anc91"></a><span class="line-modified">1326       log_info(cds)(&quot;Relocating external roots ... &quot;);</span>
1327       ResourceMark rm;
1328       RefRelocator ext_reloc;
1329       iterate_roots(&amp;ext_reloc);
1330     }
1331 
1332 #ifdef ASSERT
1333     {
<a name="92" id="anc92"></a><span class="line-modified">1334       log_info(cds)(&quot;Verifying external roots ... &quot;);</span>
1335       ResourceMark rm;
1336       IsRefInArchiveChecker checker;
1337       iterate_roots(&amp;checker);
1338     }
1339 #endif
1340 
1341 
1342     // cleanup
1343     _ssc = NULL;
1344   }
1345 
1346   // We must relocate the System::_well_known_klasses only after we have copied the
1347   // java objects in during dump_java_heap_objects(): during the object copy, we operate on
1348   // old objects which assert that their klass is the original klass.
1349   static void relocate_well_known_klasses() {
1350     {
<a name="93" id="anc93"></a><span class="line-modified">1351       log_info(cds)(&quot;Relocating SystemDictionary::_well_known_klasses[] ... &quot;);</span>
1352       ResourceMark rm;
1353       RefRelocator ext_reloc;
1354       SystemDictionary::well_known_klasses_do(&amp;ext_reloc);
1355     }
1356     // NOTE: after this point, we shouldn&#39;t have any globals that can reach the old
1357     // objects.
1358 
1359     // We cannot use any of the objects in the heap anymore (except for the
1360     // shared strings) because their headers no longer point to valid Klasses.
1361   }
1362 
1363   static void iterate_roots(MetaspaceClosure* it) {
1364     GrowableArray&lt;Symbol*&gt;* symbols = _ssc-&gt;get_sorted_symbols();
1365     for (int i=0; i&lt;symbols-&gt;length(); i++) {
1366       it-&gt;push(symbols-&gt;adr_at(i));
1367     }
1368     if (_global_klass_objects != NULL) {
1369       // Need to fix up the pointers
1370       for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
1371         // NOTE -- this requires that the vtable is NOT yet patched, or else we are hosed.
1372         it-&gt;push(_global_klass_objects-&gt;adr_at(i));
1373       }
1374     }
1375     FileMapInfo::metaspace_pointers_do(it);
1376     SystemDictionaryShared::dumptime_classes_do(it);
1377     Universe::metaspace_pointers_do(it);
1378     SymbolTable::metaspace_pointers_do(it);
1379     vmSymbols::metaspace_pointers_do(it);
<a name="94" id="anc94"></a><span class="line-added">1380 </span>
<span class="line-added">1381     it-&gt;finish();</span>
1382   }
1383 
1384   static Klass* get_relocated_klass(Klass* orig_klass) {
1385     assert(DumpSharedSpaces, &quot;dump time only&quot;);
1386     address* pp = _new_loc_table-&gt;lookup((address)orig_klass);
1387     assert(pp != NULL, &quot;must be&quot;);
1388     Klass* klass = (Klass*)(*pp);
1389     assert(klass-&gt;is_klass(), &quot;must be&quot;);
1390     return klass;
1391   }
1392 };
1393 
1394 DumpAllocStats* ArchiveCompactor::_alloc_stats;
1395 SortedSymbolClosure* ArchiveCompactor::_ssc;
1396 ArchiveCompactor::RelocationTable* ArchiveCompactor::_new_loc_table;
1397 
<a name="95" id="anc95"></a>




1398 void VM_PopulateDumpSharedSpace::dump_symbols() {
<a name="96" id="anc96"></a><span class="line-modified">1399   log_info(cds)(&quot;Dumping symbol table ...&quot;);</span>
1400 
1401   NOT_PRODUCT(SymbolTable::verify());
1402   SymbolTable::write_to_archive();
1403 }
1404 
1405 char* VM_PopulateDumpSharedSpace::dump_read_only_tables() {
1406   ArchiveCompactor::OtherROAllocMark mark;
1407 
<a name="97" id="anc97"></a><span class="line-modified">1408   log_info(cds)(&quot;Removing java_mirror ... &quot;);</span>
1409   if (!HeapShared::is_heap_object_archiving_allowed()) {
1410     clear_basic_type_mirrors();
1411   }
1412   remove_java_mirror_in_classes();
<a name="98" id="anc98"></a><span class="line-modified">1413   log_info(cds)(&quot;done. &quot;);</span>
1414 
1415   SystemDictionaryShared::write_to_archive();
1416 
<a name="99" id="anc99"></a>

1417   // Write the other data to the output array.
<a name="100" id="anc100"></a><span class="line-added">1418   char* start = _ro_region.top();</span>
1419   WriteClosure wc(&amp;_ro_region);
1420   MetaspaceShared::serialize(&amp;wc);
1421 
1422   // Write the bitmaps for patching the archive heap regions
1423   dump_archive_heap_oopmaps();
1424 
1425   return start;
1426 }
1427 
<a name="101" id="anc101"></a><span class="line-added">1428 void VM_PopulateDumpSharedSpace::print_class_stats() {</span>
<span class="line-added">1429   log_info(cds)(&quot;Number of classes %d&quot;, _global_klass_objects-&gt;length());</span>
<span class="line-added">1430   {</span>
<span class="line-added">1431     int num_type_array = 0, num_obj_array = 0, num_inst = 0;</span>
<span class="line-added">1432     for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {</span>
<span class="line-added">1433       Klass* k = _global_klass_objects-&gt;at(i);</span>
<span class="line-added">1434       if (k-&gt;is_instance_klass()) {</span>
<span class="line-added">1435         num_inst ++;</span>
<span class="line-added">1436       } else if (k-&gt;is_objArray_klass()) {</span>
<span class="line-added">1437         num_obj_array ++;</span>
<span class="line-added">1438       } else {</span>
<span class="line-added">1439         assert(k-&gt;is_typeArray_klass(), &quot;sanity&quot;);</span>
<span class="line-added">1440         num_type_array ++;</span>
<span class="line-added">1441       }</span>
<span class="line-added">1442     }</span>
<span class="line-added">1443     log_info(cds)(&quot;    instance classes   = %5d&quot;, num_inst);</span>
<span class="line-added">1444     log_info(cds)(&quot;    obj array classes  = %5d&quot;, num_obj_array);</span>
<span class="line-added">1445     log_info(cds)(&quot;    type array classes = %5d&quot;, num_type_array);</span>
<span class="line-added">1446   }</span>
<span class="line-added">1447 }</span>
<span class="line-added">1448 </span>
<span class="line-added">1449 void VM_PopulateDumpSharedSpace::relocate_to_default_base_address(CHeapBitMap* ptrmap) {</span>
<span class="line-added">1450   intx addr_delta = MetaspaceShared::final_delta();</span>
<span class="line-added">1451   if (addr_delta == 0) {</span>
<span class="line-added">1452     ArchivePtrMarker::compact((address)SharedBaseAddress, (address)_ro_region.top());</span>
<span class="line-added">1453   } else {</span>
<span class="line-added">1454     // We are not able to reserve space at Arguments::default_SharedBaseAddress() (due to ASLR).</span>
<span class="line-added">1455     // This means that the current content of the archive is based on a random</span>
<span class="line-added">1456     // address. Let&#39;s relocate all the pointers, so that it can be mapped to</span>
<span class="line-added">1457     // Arguments::default_SharedBaseAddress() without runtime relocation.</span>
<span class="line-added">1458     //</span>
<span class="line-added">1459     // Note: both the base and dynamic archive are written with</span>
<span class="line-added">1460     // FileMapHeader::_shared_base_address == Arguments::default_SharedBaseAddress()</span>
<span class="line-added">1461 </span>
<span class="line-added">1462     // Patch all pointers that are marked by ptrmap within this region,</span>
<span class="line-added">1463     // where we have just dumped all the metaspace data.</span>
<span class="line-added">1464     address patch_base = (address)SharedBaseAddress;</span>
<span class="line-added">1465     address patch_end  = (address)_ro_region.top();</span>
<span class="line-added">1466     size_t size = patch_end - patch_base;</span>
<span class="line-added">1467 </span>
<span class="line-added">1468     // the current value of the pointers to be patched must be within this</span>
<span class="line-added">1469     // range (i.e., must point to valid metaspace objects)</span>
<span class="line-added">1470     address valid_old_base = patch_base;</span>
<span class="line-added">1471     address valid_old_end  = patch_end;</span>
<span class="line-added">1472 </span>
<span class="line-added">1473     // after patching, the pointers must point inside this range</span>
<span class="line-added">1474     // (the requested location of the archive, as mapped at runtime).</span>
<span class="line-added">1475     address valid_new_base = (address)Arguments::default_SharedBaseAddress();</span>
<span class="line-added">1476     address valid_new_end  = valid_new_base + size;</span>
<span class="line-added">1477 </span>
<span class="line-added">1478     log_debug(cds)(&quot;Relocating archive from [&quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot; ] to &quot;</span>
<span class="line-added">1479                    &quot;[&quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot; ]&quot;, p2i(patch_base), p2i(patch_end),</span>
<span class="line-added">1480                    p2i(valid_new_base), p2i(valid_new_end));</span>
<span class="line-added">1481 </span>
<span class="line-added">1482     SharedDataRelocator&lt;true&gt; patcher((address*)patch_base, (address*)patch_end, valid_old_base, valid_old_end,</span>
<span class="line-added">1483                                       valid_new_base, valid_new_end, addr_delta, ptrmap);</span>
<span class="line-added">1484     ptrmap-&gt;iterate(&amp;patcher);</span>
<span class="line-added">1485     ArchivePtrMarker::compact(patcher.max_non_null_offset());</span>
<span class="line-added">1486   }</span>
<span class="line-added">1487 }</span>
<span class="line-added">1488 </span>
1489 void VM_PopulateDumpSharedSpace::doit() {
<a name="102" id="anc102"></a><span class="line-added">1490   CHeapBitMap ptrmap;</span>
<span class="line-added">1491   MetaspaceShared::initialize_ptr_marker(&amp;ptrmap);</span>
<span class="line-added">1492 </span>
1493   // We should no longer allocate anything from the metaspace, so that:
1494   //
1495   // (1) Metaspace::allocate might trigger GC if we have run out of
1496   //     committed metaspace, but we can&#39;t GC because we&#39;re running
1497   //     in the VM thread.
1498   // (2) ArchiveCompactor needs to work with a stable set of MetaspaceObjs.
1499   Metaspace::freeze();
<a name="103" id="anc103"></a><span class="line-added">1500   DEBUG_ONLY(SystemDictionaryShared::NoClassLoadingMark nclm);</span>
1501 
1502   Thread* THREAD = VMThread::vm_thread();
1503 
1504   FileMapInfo::check_nonempty_dir_in_shared_path_table();
1505 
1506   NOT_PRODUCT(SystemDictionary::verify();)
1507   // The following guarantee is meant to ensure that no loader constraints
1508   // exist yet, since the constraints table is not shared.  This becomes
1509   // more important now that we don&#39;t re-initialize vtables/itables for
1510   // shared classes at runtime, where constraints were previously created.
1511   guarantee(SystemDictionary::constraints()-&gt;number_of_entries() == 0,
1512             &quot;loader constraints are not saved&quot;);
1513   guarantee(SystemDictionary::placeholders()-&gt;number_of_entries() == 0,
1514           &quot;placeholders are not saved&quot;);
1515 
1516   // At this point, many classes have been loaded.
1517   // Gather systemDictionary classes in a global array and do everything to
1518   // that so we don&#39;t have to walk the SystemDictionary again.
1519   SystemDictionaryShared::check_excluded_classes();
1520   _global_klass_objects = new GrowableArray&lt;Klass*&gt;(1000);
1521   CollectClassesClosure collect_classes;
1522   ClassLoaderDataGraph::loaded_classes_do(&amp;collect_classes);
1523 
<a name="104" id="anc104"></a><span class="line-modified">1524   print_class_stats();</span>

















1525 
1526   // Ensure the ConstMethods won&#39;t be modified at run-time
<a name="105" id="anc105"></a><span class="line-modified">1527   log_info(cds)(&quot;Updating ConstMethods ... &quot;);</span>
<span class="line-modified">1528   rewrite_nofast_bytecodes_and_calculate_fingerprints(THREAD);</span>
<span class="line-modified">1529   log_info(cds)(&quot;done. &quot;);</span>
1530 
1531   // Remove all references outside the metadata
<a name="106" id="anc106"></a><span class="line-modified">1532   log_info(cds)(&quot;Removing unshareable information ... &quot;);</span>
1533   remove_unshareable_in_classes();
<a name="107" id="anc107"></a><span class="line-modified">1534   log_info(cds)(&quot;done. &quot;);</span>
<span class="line-added">1535 </span>
<span class="line-added">1536   MetaspaceShared::allocate_cloned_cpp_vtptrs();</span>
<span class="line-added">1537   char* cloned_vtables = _mc_region.top();</span>
<span class="line-added">1538   MetaspaceShared::allocate_cpp_vtable_clones();</span>
1539 
1540   ArchiveCompactor::initialize();
1541   ArchiveCompactor::copy_and_compact();
1542 
1543   dump_symbols();
1544 
1545   // Dump supported java heap objects
1546   _closed_archive_heap_regions = NULL;
1547   _open_archive_heap_regions = NULL;
1548   dump_java_heap_objects();
1549 
1550   ArchiveCompactor::relocate_well_known_klasses();
1551 
<a name="108" id="anc108"></a><span class="line-modified">1552   char* serialized_data = dump_read_only_tables();</span>
<span class="line-modified">1553   _ro_region.pack();</span>














1554 
1555   // The vtable clones contain addresses of the current process.
1556   // We don&#39;t want to write these addresses into the archive.
1557   MetaspaceShared::zero_cpp_vtable_clones_for_writing();
1558 
<a name="109" id="anc109"></a><span class="line-added">1559   // relocate the data so that it can be mapped to Arguments::default_SharedBaseAddress()</span>
<span class="line-added">1560   // without runtime relocation.</span>
<span class="line-added">1561   relocate_to_default_base_address(&amp;ptrmap);</span>
<span class="line-added">1562 </span>
1563   // Create and write the archive file that maps the shared spaces.
1564 
<a name="110" id="anc110"></a><span class="line-modified">1565   FileMapInfo* mapinfo = new FileMapInfo(true);</span>
1566   mapinfo-&gt;populate_header(os::vm_allocation_granularity());
<a name="111" id="anc111"></a><span class="line-modified">1567   mapinfo-&gt;set_serialized_data(serialized_data);</span>
<span class="line-modified">1568   mapinfo-&gt;set_cloned_vtables(cloned_vtables);</span>
<span class="line-modified">1569   mapinfo-&gt;set_i2i_entry_code_buffers(MetaspaceShared::i2i_entry_code_buffers(),</span>
<span class="line-modified">1570                                       MetaspaceShared::i2i_entry_code_buffers_size());</span>
<span class="line-modified">1571   mapinfo-&gt;open_for_write();</span>
<span class="line-modified">1572   MetaspaceShared::write_core_archive_regions(mapinfo);</span>
<span class="line-modified">1573   _total_closed_archive_region_size = mapinfo-&gt;write_archive_heap_regions(</span>





















1574                                         _closed_archive_heap_regions,
1575                                         _closed_archive_heap_oopmaps,
1576                                         MetaspaceShared::first_closed_archive_heap_region,
<a name="112" id="anc112"></a><span class="line-modified">1577                                         MetaspaceShared::max_closed_archive_heap_region);</span>
<span class="line-modified">1578   _total_open_archive_region_size = mapinfo-&gt;write_archive_heap_regions(</span>

1579                                         _open_archive_heap_regions,
1580                                         _open_archive_heap_oopmaps,
1581                                         MetaspaceShared::first_open_archive_heap_region,
<a name="113" id="anc113"></a><span class="line-modified">1582                                         MetaspaceShared::max_open_archive_heap_region);</span>


1583 
<a name="114" id="anc114"></a><span class="line-added">1584   mapinfo-&gt;set_final_requested_base((char*)Arguments::default_SharedBaseAddress());</span>
<span class="line-added">1585   mapinfo-&gt;set_header_crc(mapinfo-&gt;compute_header_crc());</span>
<span class="line-added">1586   mapinfo-&gt;write_header();</span>
1587   mapinfo-&gt;close();
1588 
<a name="115" id="anc115"></a>


1589   print_region_stats();
1590 
1591   if (log_is_enabled(Info, cds)) {
1592     ArchiveCompactor::alloc_stats()-&gt;print_stats(int(_ro_region.used()), int(_rw_region.used()),
<a name="116" id="anc116"></a><span class="line-modified">1593                                                  int(_mc_region.used()));</span>
1594   }
1595 
1596   if (PrintSystemDictionaryAtExit) {
1597     SystemDictionary::print();
1598   }
1599 
1600   if (AllowArchivingWithJavaAgent) {
1601     warning(&quot;This archive was created with AllowArchivingWithJavaAgent. It should be used &quot;
1602             &quot;for testing purposes only and should not be used in a production environment&quot;);
1603   }
1604 
1605   // There may be other pending VM operations that operate on the InstanceKlasses,
1606   // which will fail because InstanceKlasses::remove_unshareable_info()
1607   // has been called. Forget these operations and exit the VM directly.
1608   vm_direct_exit(0);
1609 }
1610 
1611 void VM_PopulateDumpSharedSpace::print_region_stats() {
1612   // Print statistics of all the regions
<a name="117" id="anc117"></a><span class="line-added">1613   const size_t bitmap_used = ArchivePtrMarker::ptrmap()-&gt;size_in_bytes();</span>
<span class="line-added">1614   const size_t bitmap_reserved = align_up(bitmap_used, Metaspace::reserve_alignment());</span>
1615   const size_t total_reserved = _ro_region.reserved()  + _rw_region.reserved() +
<a name="118" id="anc118"></a><span class="line-modified">1616                                 _mc_region.reserved()  +</span>
<span class="line-added">1617                                 bitmap_reserved +</span>
1618                                 _total_closed_archive_region_size +
1619                                 _total_open_archive_region_size;
1620   const size_t total_bytes = _ro_region.used()  + _rw_region.used() +
<a name="119" id="anc119"></a><span class="line-modified">1621                              _mc_region.used()  +</span>
<span class="line-added">1622                              bitmap_used +</span>
1623                              _total_closed_archive_region_size +
1624                              _total_open_archive_region_size;
1625   const double total_u_perc = percent_of(total_bytes, total_reserved);
1626 
1627   _mc_region.print(total_reserved);
1628   _rw_region.print(total_reserved);
1629   _ro_region.print(total_reserved);
<a name="120" id="anc120"></a><span class="line-modified">1630   print_bitmap_region_stats(bitmap_reserved, total_reserved);</span>
1631   print_heap_region_stats(_closed_archive_heap_regions, &quot;ca&quot;, total_reserved);
1632   print_heap_region_stats(_open_archive_heap_regions, &quot;oa&quot;, total_reserved);
1633 
<a name="121" id="anc121"></a><span class="line-modified">1634   log_debug(cds)(&quot;total    : &quot; SIZE_FORMAT_W(9) &quot; [100.0%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [%5.1f%% used]&quot;,</span>
1635                  total_bytes, total_reserved, total_u_perc);
1636 }
1637 
<a name="122" id="anc122"></a><span class="line-added">1638 void VM_PopulateDumpSharedSpace::print_bitmap_region_stats(size_t size, size_t total_size) {</span>
<span class="line-added">1639   log_debug(cds)(&quot;bm  space: &quot; SIZE_FORMAT_W(9) &quot; [ %4.1f%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [100.0%% used] at &quot; INTPTR_FORMAT,</span>
<span class="line-added">1640                  size, size/double(total_size)*100.0, size, p2i(NULL));</span>
<span class="line-added">1641 }</span>
<span class="line-added">1642 </span>
1643 void VM_PopulateDumpSharedSpace::print_heap_region_stats(GrowableArray&lt;MemRegion&gt; *heap_mem,
<a name="123" id="anc123"></a><span class="line-modified">1644                                                          const char *name, size_t total_size) {</span>
1645   int arr_len = heap_mem == NULL ? 0 : heap_mem-&gt;length();
1646   for (int i = 0; i &lt; arr_len; i++) {
1647       char* start = (char*)heap_mem-&gt;at(i).start();
1648       size_t size = heap_mem-&gt;at(i).byte_size();
1649       char* top = start + size;
<a name="124" id="anc124"></a><span class="line-modified">1650       log_debug(cds)(&quot;%s%d space: &quot; SIZE_FORMAT_W(9) &quot; [ %4.1f%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [100.0%% used] at &quot; INTPTR_FORMAT,</span>
<span class="line-modified">1651                      name, i, size, size/double(total_size)*100.0, size, p2i(start));</span>
1652 
1653   }
1654 }
1655 
<a name="125" id="anc125"></a><span class="line-added">1656 void MetaspaceShared::write_core_archive_regions(FileMapInfo* mapinfo) {</span>
<span class="line-added">1657   // Make sure NUM_CDS_REGIONS (exported in cds.h) agrees with</span>
<span class="line-added">1658   // MetaspaceShared::n_regions (internal to hotspot).</span>
<span class="line-added">1659   assert(NUM_CDS_REGIONS == MetaspaceShared::n_regions, &quot;sanity&quot;);</span>
<span class="line-added">1660 </span>
<span class="line-added">1661   // mc contains the trampoline code for method entries, which are patched at run time,</span>
<span class="line-added">1662   // so it needs to be read/write.</span>
<span class="line-added">1663   write_region(mapinfo, mc, &amp;_mc_region, /*read_only=*/false,/*allow_exec=*/true);</span>
<span class="line-added">1664   write_region(mapinfo, rw, &amp;_rw_region, /*read_only=*/false,/*allow_exec=*/false);</span>
<span class="line-added">1665   write_region(mapinfo, ro, &amp;_ro_region, /*read_only=*/true, /*allow_exec=*/false);</span>
<span class="line-added">1666   mapinfo-&gt;write_bitmap_region(ArchivePtrMarker::ptrmap());</span>
<span class="line-added">1667 }</span>
<span class="line-added">1668 </span>
<span class="line-added">1669 void MetaspaceShared::write_region(FileMapInfo* mapinfo, int region_idx, DumpRegion* dump_region, bool read_only,  bool allow_exec) {</span>
<span class="line-added">1670   mapinfo-&gt;write_region(region_idx, dump_region-&gt;base(), dump_region-&gt;used(), read_only, allow_exec);</span>
<span class="line-added">1671 }</span>
<span class="line-added">1672 </span>
1673 // Update a Java object to point its Klass* to the new location after
1674 // shared archive has been compacted.
1675 void MetaspaceShared::relocate_klass_ptr(oop o) {
1676   assert(DumpSharedSpaces, &quot;sanity&quot;);
1677   Klass* k = ArchiveCompactor::get_relocated_klass(o-&gt;klass());
1678   o-&gt;set_klass(k);
1679 }
1680 
<a name="126" id="anc126"></a><span class="line-modified">1681 Klass* MetaspaceShared::get_relocated_klass(Klass *k, bool is_final) {</span>
1682   assert(DumpSharedSpaces, &quot;sanity&quot;);
<a name="127" id="anc127"></a><span class="line-modified">1683   k = ArchiveCompactor::get_relocated_klass(k);</span>
<span class="line-added">1684   if (is_final) {</span>
<span class="line-added">1685     k = (Klass*)(address(k) + final_delta());</span>
<span class="line-added">1686   }</span>
<span class="line-added">1687   return k;</span>
1688 }
1689 
1690 class LinkSharedClassesClosure : public KlassClosure {
1691   Thread* THREAD;
1692   bool    _made_progress;
1693  public:
1694   LinkSharedClassesClosure(Thread* thread) : THREAD(thread), _made_progress(false) {}
1695 
1696   void reset()               { _made_progress = false; }
1697   bool made_progress() const { return _made_progress; }
1698 
1699   void do_klass(Klass* k) {
1700     if (k-&gt;is_instance_klass()) {
1701       InstanceKlass* ik = InstanceKlass::cast(k);
1702       // Link the class to cause the bytecodes to be rewritten and the
1703       // cpcache to be created. Class verification is done according
1704       // to -Xverify setting.
1705       _made_progress |= MetaspaceShared::try_link_class(ik, THREAD);
1706       guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in link_class&quot;);
1707 
1708       ik-&gt;constants()-&gt;resolve_class_constants(THREAD);
1709     }
1710   }
1711 };
1712 
1713 class CheckSharedClassesClosure : public KlassClosure {
1714   bool    _made_progress;
1715  public:
1716   CheckSharedClassesClosure() : _made_progress(false) {}
1717 
1718   void reset()               { _made_progress = false; }
1719   bool made_progress() const { return _made_progress; }
1720   void do_klass(Klass* k) {
1721     if (k-&gt;is_instance_klass() &amp;&amp; InstanceKlass::cast(k)-&gt;check_sharing_error_state()) {
1722       _made_progress = true;
1723     }
1724   }
1725 };
1726 
1727 void MetaspaceShared::link_and_cleanup_shared_classes(TRAPS) {
1728   // We need to iterate because verification may cause additional classes
1729   // to be loaded.
1730   LinkSharedClassesClosure link_closure(THREAD);
1731   do {
1732     link_closure.reset();
1733     ClassLoaderDataGraph::unlocked_loaded_classes_do(&amp;link_closure);
1734     guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in link_class&quot;);
1735   } while (link_closure.made_progress());
1736 
1737   if (_has_error_classes) {
1738     // Mark all classes whose super class or interfaces failed verification.
1739     CheckSharedClassesClosure check_closure;
1740     do {
1741       // Not completely sure if we need to do this iteratively. Anyway,
1742       // we should come here only if there are unverifiable classes, which
1743       // shouldn&#39;t happen in normal cases. So better safe than sorry.
1744       check_closure.reset();
1745       ClassLoaderDataGraph::unlocked_loaded_classes_do(&amp;check_closure);
1746     } while (check_closure.made_progress());
1747   }
1748 }
1749 
1750 void MetaspaceShared::prepare_for_dumping() {
1751   Arguments::check_unsupported_dumping_properties();
1752   ClassLoader::initialize_shared_path();
1753 }
1754 
1755 // Preload classes from a list, populate the shared spaces and dump to a
1756 // file.
1757 void MetaspaceShared::preload_and_dump(TRAPS) {
1758   { TraceTime timer(&quot;Dump Shared Spaces&quot;, TRACETIME_LOG(Info, startuptime));
<a name="128" id="anc128"></a><span class="line-modified">1759     ResourceMark rm(THREAD);</span>
1760     char class_list_path_str[JVM_MAXPATHLEN];
1761     // Preload classes to be shared.
1762     const char* class_list_path;
1763     if (SharedClassListFile == NULL) {
1764       // Construct the path to the class list (in jre/lib)
1765       // Walk up two directories from the location of the VM and
1766       // optionally tack on &quot;lib&quot; (depending on platform)
1767       os::jvm_path(class_list_path_str, sizeof(class_list_path_str));
1768       for (int i = 0; i &lt; 3; i++) {
1769         char *end = strrchr(class_list_path_str, *os::file_separator());
1770         if (end != NULL) *end = &#39;\0&#39;;
1771       }
1772       int class_list_path_len = (int)strlen(class_list_path_str);
1773       if (class_list_path_len &gt;= 3) {
1774         if (strcmp(class_list_path_str + class_list_path_len - 3, &quot;lib&quot;) != 0) {
1775           if (class_list_path_len &lt; JVM_MAXPATHLEN - 4) {
1776             jio_snprintf(class_list_path_str + class_list_path_len,
1777                          sizeof(class_list_path_str) - class_list_path_len,
1778                          &quot;%slib&quot;, os::file_separator());
1779             class_list_path_len += 4;
1780           }
1781         }
1782       }
1783       if (class_list_path_len &lt; JVM_MAXPATHLEN - 10) {
1784         jio_snprintf(class_list_path_str + class_list_path_len,
1785                      sizeof(class_list_path_str) - class_list_path_len,
1786                      &quot;%sclasslist&quot;, os::file_separator());
1787       }
1788       class_list_path = class_list_path_str;
1789     } else {
1790       class_list_path = SharedClassListFile;
1791     }
1792 
<a name="129" id="anc129"></a><span class="line-modified">1793     log_info(cds)(&quot;Loading classes to share ...&quot;);</span>
1794     _has_error_classes = false;
1795     int class_count = preload_classes(class_list_path, THREAD);
1796     if (ExtraSharedClassListFile) {
1797       class_count += preload_classes(ExtraSharedClassListFile, THREAD);
1798     }
<a name="130" id="anc130"></a><span class="line-modified">1799     log_info(cds)(&quot;Loading classes to share: done.&quot;);</span>
1800 
1801     log_info(cds)(&quot;Shared spaces: preloaded %d classes&quot;, class_count);
1802 
1803     if (SharedArchiveConfigFile) {
<a name="131" id="anc131"></a><span class="line-modified">1804       log_info(cds)(&quot;Reading extra data from %s ...&quot;, SharedArchiveConfigFile);</span>
1805       read_extra_data(SharedArchiveConfigFile, THREAD);
1806     }
<a name="132" id="anc132"></a><span class="line-modified">1807     log_info(cds)(&quot;Reading extra data: done.&quot;);</span>
1808 
1809     HeapShared::init_subgraph_entry_fields(THREAD);
1810 
1811     // Rewrite and link classes
<a name="133" id="anc133"></a><span class="line-modified">1812     log_info(cds)(&quot;Rewriting and linking classes ...&quot;);</span>
1813 
1814     // Link any classes which got missed. This would happen if we have loaded classes that
1815     // were not explicitly specified in the classlist. E.g., if an interface implemented by class K
1816     // fails verification, all other interfaces that were not specified in the classlist but
1817     // are implemented by K are not verified.
1818     link_and_cleanup_shared_classes(CATCH);
<a name="134" id="anc134"></a><span class="line-modified">1819     log_info(cds)(&quot;Rewriting and linking classes: done&quot;);</span>
1820 
1821     if (HeapShared::is_heap_object_archiving_allowed()) {
1822       // Avoid fragmentation while archiving heap objects.
1823       Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(true);
1824       Universe::heap()-&gt;collect(GCCause::_archive_time_gc);
1825       Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(false);
1826     }
1827 
1828     VM_PopulateDumpSharedSpace op;
1829     VMThread::execute(&amp;op);
1830   }
1831 }
1832 
1833 
1834 int MetaspaceShared::preload_classes(const char* class_list_path, TRAPS) {
1835   ClassListParser parser(class_list_path);
1836   int class_count = 0;
1837 
1838   while (parser.parse_one_line()) {
1839     Klass* klass = parser.load_current_class(THREAD);
1840     if (HAS_PENDING_EXCEPTION) {
1841       if (klass == NULL &amp;&amp;
1842           (PENDING_EXCEPTION-&gt;klass()-&gt;name() == vmSymbols::java_lang_ClassNotFoundException())) {
1843         // print a warning only when the pending exception is class not found
<a name="135" id="anc135"></a><span class="line-modified">1844         log_warning(cds)(&quot;Preload Warning: Cannot find %s&quot;, parser.current_class_name());</span>
1845       }
1846       CLEAR_PENDING_EXCEPTION;
1847     }
1848     if (klass != NULL) {
1849       if (log_is_enabled(Trace, cds)) {
<a name="136" id="anc136"></a><span class="line-modified">1850         ResourceMark rm(THREAD);</span>
1851         log_trace(cds)(&quot;Shared spaces preloaded: %s&quot;, klass-&gt;external_name());
1852       }
1853 
1854       if (klass-&gt;is_instance_klass()) {
1855         InstanceKlass* ik = InstanceKlass::cast(klass);
1856 
1857         // Link the class to cause the bytecodes to be rewritten and the
1858         // cpcache to be created. The linking is done as soon as classes
1859         // are loaded in order that the related data structures (klass and
1860         // cpCache) are located together.
1861         try_link_class(ik, THREAD);
1862         guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in link_class&quot;);
1863       }
1864 
1865       class_count++;
1866     }
1867   }
1868 
1869   return class_count;
1870 }
1871 
1872 // Returns true if the class&#39;s status has changed
1873 bool MetaspaceShared::try_link_class(InstanceKlass* ik, TRAPS) {
1874   assert(DumpSharedSpaces, &quot;should only be called during dumping&quot;);
1875   if (ik-&gt;init_state() &lt; InstanceKlass::linked) {
1876     bool saved = BytecodeVerificationLocal;
1877     if (ik-&gt;loader_type() == 0 &amp;&amp; ik-&gt;class_loader() == NULL) {
1878       // The verification decision is based on BytecodeVerificationRemote
1879       // for non-system classes. Since we are using the NULL classloader
1880       // to load non-system classes for customized class loaders during dumping,
1881       // we need to temporarily change BytecodeVerificationLocal to be the same as
1882       // BytecodeVerificationRemote. Note this can cause the parent system
1883       // classes also being verified. The extra overhead is acceptable during
1884       // dumping.
1885       BytecodeVerificationLocal = BytecodeVerificationRemote;
1886     }
1887     ik-&gt;link_class(THREAD);
1888     if (HAS_PENDING_EXCEPTION) {
<a name="137" id="anc137"></a><span class="line-modified">1889       ResourceMark rm(THREAD);</span>
<span class="line-modified">1890       log_warning(cds)(&quot;Preload Warning: Verification failed for %s&quot;,</span>
1891                     ik-&gt;external_name());
1892       CLEAR_PENDING_EXCEPTION;
1893       ik-&gt;set_in_error_state();
1894       _has_error_classes = true;
1895     }
1896     BytecodeVerificationLocal = saved;
1897     return true;
1898   } else {
1899     return false;
1900   }
1901 }
1902 
1903 #if INCLUDE_CDS_JAVA_HEAP
1904 void VM_PopulateDumpSharedSpace::dump_java_heap_objects() {
1905   // The closed and open archive heap space has maximum two regions.
1906   // See FileMapInfo::write_archive_heap_regions() for details.
1907   _closed_archive_heap_regions = new GrowableArray&lt;MemRegion&gt;(2);
1908   _open_archive_heap_regions = new GrowableArray&lt;MemRegion&gt;(2);
1909   HeapShared::archive_java_heap_objects(_closed_archive_heap_regions,
1910                                         _open_archive_heap_regions);
1911   ArchiveCompactor::OtherROAllocMark mark;
1912   HeapShared::write_subgraph_info_table();
1913 }
1914 
1915 void VM_PopulateDumpSharedSpace::dump_archive_heap_oopmaps() {
1916   if (HeapShared::is_heap_object_archiving_allowed()) {
1917     _closed_archive_heap_oopmaps = new GrowableArray&lt;ArchiveHeapOopmapInfo&gt;(2);
1918     dump_archive_heap_oopmaps(_closed_archive_heap_regions, _closed_archive_heap_oopmaps);
1919 
1920     _open_archive_heap_oopmaps = new GrowableArray&lt;ArchiveHeapOopmapInfo&gt;(2);
1921     dump_archive_heap_oopmaps(_open_archive_heap_regions, _open_archive_heap_oopmaps);
1922   }
1923 }
1924 
1925 void VM_PopulateDumpSharedSpace::dump_archive_heap_oopmaps(GrowableArray&lt;MemRegion&gt;* regions,
1926                                                            GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* oopmaps) {
1927   for (int i=0; i&lt;regions-&gt;length(); i++) {
1928     ResourceBitMap oopmap = HeapShared::calculate_oopmap(regions-&gt;at(i));
1929     size_t size_in_bits = oopmap.size();
1930     size_t size_in_bytes = oopmap.size_in_bytes();
1931     uintptr_t* buffer = (uintptr_t*)_ro_region.allocate(size_in_bytes, sizeof(intptr_t));
1932     oopmap.write_to(buffer, size_in_bytes);
<a name="138" id="anc138"></a><span class="line-modified">1933     log_info(cds, heap)(&quot;Oopmap = &quot; INTPTR_FORMAT &quot; (&quot; SIZE_FORMAT_W(6) &quot; bytes) for heap region &quot;</span>
<span class="line-modified">1934                         INTPTR_FORMAT &quot; (&quot; SIZE_FORMAT_W(8) &quot; bytes)&quot;,</span>
<span class="line-modified">1935                         p2i(buffer), size_in_bytes,</span>
<span class="line-modified">1936                         p2i(regions-&gt;at(i).start()), regions-&gt;at(i).byte_size());</span>
1937 
1938     ArchiveHeapOopmapInfo info;
1939     info._oopmap = (address)buffer;
1940     info._oopmap_size_in_bits = size_in_bits;
1941     oopmaps-&gt;append(info);
1942   }
1943 }
1944 #endif // INCLUDE_CDS_JAVA_HEAP
1945 
<a name="139" id="anc139"></a><span class="line-modified">1946 void ReadClosure::do_ptr(void** p) {</span>
<span class="line-modified">1947   assert(*p == NULL, &quot;initializing previous initialized pointer.&quot;);</span>
<span class="line-added">1948   intptr_t obj = nextPtr();</span>
<span class="line-added">1949   assert((intptr_t)obj &gt;= 0 || (intptr_t)obj &lt; -100,</span>
<span class="line-added">1950          &quot;hit tag while initializing ptrs.&quot;);</span>
<span class="line-added">1951   *p = (void*)obj;</span>
<span class="line-added">1952 }</span>
1953 
<a name="140" id="anc140"></a><span class="line-modified">1954 void ReadClosure::do_u4(u4* p) {</span>
<span class="line-modified">1955   intptr_t obj = nextPtr();</span>
<span class="line-modified">1956   *p = (u4)(uintx(obj));</span>
<span class="line-added">1957 }</span>
1958 
<a name="141" id="anc141"></a><span class="line-modified">1959 void ReadClosure::do_bool(bool* p) {</span>
<span class="line-modified">1960   intptr_t obj = nextPtr();</span>
<span class="line-added">1961   *p = (bool)(uintx(obj));</span>
<span class="line-added">1962 }</span>
<span class="line-added">1963 </span>
<span class="line-added">1964 void ReadClosure::do_tag(int tag) {</span>
<span class="line-added">1965   int old_tag;</span>
<span class="line-added">1966   old_tag = (int)(intptr_t)nextPtr();</span>
<span class="line-added">1967   // do_int(&amp;old_tag);</span>
<span class="line-added">1968   assert(tag == old_tag, &quot;old tag doesn&#39;t match&quot;);</span>
<span class="line-added">1969   FileMapInfo::assert_mark(tag == old_tag);</span>
<span class="line-added">1970 }</span>
<span class="line-added">1971 </span>
<span class="line-added">1972 void ReadClosure::do_oop(oop *p) {</span>
<span class="line-added">1973   narrowOop o = (narrowOop)nextPtr();</span>
<span class="line-added">1974   if (o == 0 || !HeapShared::open_archive_heap_region_mapped()) {</span>
<span class="line-added">1975     p = NULL;</span>
<span class="line-added">1976   } else {</span>
<span class="line-added">1977     assert(HeapShared::is_heap_object_archiving_allowed(),</span>
<span class="line-added">1978            &quot;Archived heap object is not allowed&quot;);</span>
<span class="line-added">1979     assert(HeapShared::open_archive_heap_region_mapped(),</span>
<span class="line-added">1980            &quot;Open archive heap region is not mapped&quot;);</span>
<span class="line-added">1981     *p = HeapShared::decode_from_archive(o);</span>
1982   }
<a name="142" id="anc142"></a><span class="line-added">1983 }</span>
1984 
<a name="143" id="anc143"></a><span class="line-modified">1985 void ReadClosure::do_region(u_char* start, size_t size) {</span>
<span class="line-modified">1986   assert((intptr_t)start % sizeof(intptr_t) == 0, &quot;bad alignment&quot;);</span>
<span class="line-added">1987   assert(size % sizeof(intptr_t) == 0, &quot;bad size&quot;);</span>
<span class="line-added">1988   do_tag((int)size);</span>
<span class="line-added">1989   while (size &gt; 0) {</span>
<span class="line-added">1990     *(intptr_t*)start = nextPtr();</span>
<span class="line-added">1991     start += sizeof(intptr_t);</span>
<span class="line-added">1992     size -= sizeof(intptr_t);</span>
<span class="line-added">1993   }</span>
<span class="line-added">1994 }</span>
<span class="line-added">1995 </span>
<span class="line-added">1996 void MetaspaceShared::set_shared_metaspace_range(void* base, void *static_top, void* top) {</span>
<span class="line-added">1997   assert(base &lt;= static_top &amp;&amp; static_top &lt;= top, &quot;must be&quot;);</span>
<span class="line-added">1998   _shared_metaspace_static_top = static_top;</span>
<span class="line-added">1999   MetaspaceObj::set_shared_metaspace_range(base, top);</span>
<span class="line-added">2000 }</span>
<span class="line-added">2001 </span>
<span class="line-added">2002 // Return true if given address is in the misc data region</span>
<span class="line-added">2003 bool MetaspaceShared::is_in_shared_region(const void* p, int idx) {</span>
<span class="line-added">2004   return UseSharedSpaces &amp;&amp; FileMapInfo::current_info()-&gt;is_in_shared_region(p, idx);</span>
<span class="line-added">2005 }</span>
2006 
<a name="144" id="anc144"></a><span class="line-modified">2007 bool MetaspaceShared::is_in_trampoline_frame(address addr) {</span>
<span class="line-modified">2008   if (UseSharedSpaces &amp;&amp; is_in_shared_region(addr, MetaspaceShared::mc)) {</span>
<span class="line-modified">2009     return true;</span>



2010   }
<a name="145" id="anc145"></a><span class="line-added">2011   return false;</span>
<span class="line-added">2012 }</span>
2013 
<a name="146" id="anc146"></a><span class="line-modified">2014 bool MetaspaceShared::is_shared_dynamic(void* p) {</span>
<span class="line-modified">2015   if ((p &lt; MetaspaceObj::shared_metaspace_top()) &amp;&amp;</span>
<span class="line-modified">2016       (p &gt;= _shared_metaspace_static_top)) {</span>
<span class="line-added">2017     return true;</span>
<span class="line-added">2018   } else {</span>
<span class="line-added">2019     return false;</span>
2020   }
<a name="147" id="anc147"></a><span class="line-added">2021 }</span>
2022 
<a name="148" id="anc148"></a><span class="line-modified">2023 void MetaspaceShared::initialize_runtime_shared_and_meta_spaces() {</span>
<span class="line-modified">2024   assert(UseSharedSpaces, &quot;Must be called when UseSharedSpaces is enabled&quot;);</span>
<span class="line-modified">2025   MapArchiveResult result = MAP_ARCHIVE_OTHER_FAILURE;</span>
<span class="line-modified">2026   FileMapInfo* static_mapinfo = open_static_archive();</span>
<span class="line-modified">2027   FileMapInfo* dynamic_mapinfo = NULL;</span>
<span class="line-modified">2028 </span>
<span class="line-added">2029   if (static_mapinfo != NULL) {</span>
<span class="line-added">2030     dynamic_mapinfo = open_dynamic_archive();</span>
<span class="line-added">2031 </span>
<span class="line-added">2032     // First try to map at the requested address</span>
<span class="line-added">2033     result = map_archives(static_mapinfo, dynamic_mapinfo, true);</span>
<span class="line-added">2034     if (result == MAP_ARCHIVE_MMAP_FAILURE) {</span>
<span class="line-added">2035       // Mapping has failed (probably due to ASLR). Let&#39;s map at an address chosen</span>
<span class="line-added">2036       // by the OS.</span>
<span class="line-added">2037       log_info(cds)(&quot;Try to map archive(s) at an alternative address&quot;);</span>
<span class="line-added">2038       result = map_archives(static_mapinfo, dynamic_mapinfo, false);</span>
<span class="line-added">2039     }</span>
2040   }
2041 
<a name="149" id="anc149"></a><span class="line-modified">2042   if (result == MAP_ARCHIVE_SUCCESS) {</span>
<span class="line-modified">2043     bool dynamic_mapped = (dynamic_mapinfo != NULL &amp;&amp; dynamic_mapinfo-&gt;is_mapped());</span>
<span class="line-modified">2044     char* cds_base = static_mapinfo-&gt;mapped_base();</span>
<span class="line-modified">2045     char* cds_end =  dynamic_mapped ? dynamic_mapinfo-&gt;mapped_end() : static_mapinfo-&gt;mapped_end();</span>
<span class="line-added">2046     set_shared_metaspace_range(cds_base, static_mapinfo-&gt;mapped_end(), cds_end);</span>
<span class="line-added">2047     _relocation_delta = static_mapinfo-&gt;relocation_delta();</span>
<span class="line-added">2048     if (dynamic_mapped) {</span>
<span class="line-added">2049       FileMapInfo::set_shared_path_table(dynamic_mapinfo);</span>
2050     } else {
<a name="150" id="anc150"></a><span class="line-modified">2051       FileMapInfo::set_shared_path_table(static_mapinfo);</span>
<span class="line-modified">2052     }</span>
<span class="line-modified">2053   } else {</span>
<span class="line-modified">2054     set_shared_metaspace_range(NULL, NULL, NULL);</span>
<span class="line-modified">2055     UseSharedSpaces = false;</span>
<span class="line-added">2056     FileMapInfo::fail_continue(&quot;Unable to map shared spaces&quot;);</span>
<span class="line-added">2057     if (PrintSharedArchiveAndExit) {</span>
<span class="line-added">2058       vm_exit_during_initialization(&quot;Unable to use shared archive.&quot;);</span>
2059     }
2060   }
2061 
<a name="151" id="anc151"></a><span class="line-modified">2062   if (static_mapinfo != NULL &amp;&amp; !static_mapinfo-&gt;is_mapped()) {</span>
<span class="line-modified">2063     delete static_mapinfo;</span>
<span class="line-modified">2064   }</span>
<span class="line-modified">2065   if (dynamic_mapinfo != NULL &amp;&amp; !dynamic_mapinfo-&gt;is_mapped()) {</span>
<span class="line-modified">2066     delete dynamic_mapinfo;</span>




2067   }
<a name="152" id="anc152"></a><span class="line-added">2068 }</span>
2069 
<a name="153" id="anc153"></a><span class="line-modified">2070 FileMapInfo* MetaspaceShared::open_static_archive() {</span>
<span class="line-modified">2071   FileMapInfo* mapinfo = new FileMapInfo(true);</span>
<span class="line-added">2072   if (!mapinfo-&gt;initialize()) {</span>
<span class="line-added">2073     delete(mapinfo);</span>
<span class="line-added">2074     return NULL;</span>
<span class="line-added">2075   }</span>
<span class="line-added">2076   return mapinfo;</span>
<span class="line-added">2077 }</span>
2078 
<a name="154" id="anc154"></a><span class="line-modified">2079 FileMapInfo* MetaspaceShared::open_dynamic_archive() {</span>
<span class="line-modified">2080   if (DynamicDumpSharedSpaces) {</span>
<span class="line-modified">2081     return NULL;</span>
<span class="line-added">2082   }</span>
<span class="line-added">2083   if (Arguments::GetSharedDynamicArchivePath() == NULL) {</span>
<span class="line-added">2084     return NULL;</span>
<span class="line-added">2085   }</span>
<span class="line-added">2086 </span>
<span class="line-added">2087   FileMapInfo* mapinfo = new FileMapInfo(false);</span>
<span class="line-added">2088   if (!mapinfo-&gt;initialize()) {</span>
<span class="line-added">2089     delete(mapinfo);</span>
<span class="line-added">2090     return NULL;</span>
<span class="line-added">2091   }</span>
<span class="line-added">2092   return mapinfo;</span>
2093 }
2094 
<a name="155" id="anc155"></a><span class="line-modified">2095 // use_requested_addr:</span>
<span class="line-modified">2096 //  true  = map at FileMapHeader::_requested_base_address</span>
<span class="line-modified">2097 //  false = map at an alternative address picked by OS.</span>
<span class="line-added">2098 MapArchiveResult MetaspaceShared::map_archives(FileMapInfo* static_mapinfo, FileMapInfo* dynamic_mapinfo,</span>
<span class="line-added">2099                                                bool use_requested_addr) {</span>
<span class="line-added">2100   PRODUCT_ONLY(if (ArchiveRelocationMode == 1 &amp;&amp; use_requested_addr) {</span>
<span class="line-added">2101       // For product build only -- this is for benchmarking the cost of doing relocation.</span>
<span class="line-added">2102       // For debug builds, the check is done in FileMapInfo::map_regions for better test coverage.</span>
<span class="line-added">2103       log_info(cds)(&quot;ArchiveRelocationMode == 1: always map archive(s) at an alternative address&quot;);</span>
<span class="line-added">2104       return MAP_ARCHIVE_MMAP_FAILURE;</span>
<span class="line-added">2105     });</span>
<span class="line-added">2106 </span>
<span class="line-added">2107   if (ArchiveRelocationMode == 2 &amp;&amp; !use_requested_addr) {</span>
<span class="line-added">2108     log_info(cds)(&quot;ArchiveRelocationMode == 2: never map archive(s) at an alternative address&quot;);</span>
<span class="line-added">2109     return MAP_ARCHIVE_MMAP_FAILURE;</span>
<span class="line-added">2110   };</span>
<span class="line-added">2111 </span>
<span class="line-added">2112   if (dynamic_mapinfo != NULL) {</span>
<span class="line-added">2113     // Ensure that the OS won&#39;t be able to allocate new memory spaces between the two</span>
<span class="line-added">2114     // archives, or else it would mess up the simple comparision in MetaspaceObj::is_shared().</span>
<span class="line-added">2115     assert(static_mapinfo-&gt;mapping_end_offset() == dynamic_mapinfo-&gt;mapping_base_offset(), &quot;no gap&quot;);</span>
2116   }
<a name="156" id="anc156"></a><span class="line-modified">2117 </span>
<span class="line-added">2118   ReservedSpace main_rs, archive_space_rs, class_space_rs;</span>
<span class="line-added">2119   MapArchiveResult result = MAP_ARCHIVE_OTHER_FAILURE;</span>
<span class="line-added">2120   char* mapped_base_address = reserve_address_space_for_archives(static_mapinfo, dynamic_mapinfo,</span>
<span class="line-added">2121                                                                  use_requested_addr, main_rs, archive_space_rs,</span>
<span class="line-added">2122                                                                  class_space_rs);</span>
<span class="line-added">2123   if (mapped_base_address == NULL) {</span>
<span class="line-added">2124     result = MAP_ARCHIVE_MMAP_FAILURE;</span>
<span class="line-added">2125   } else {</span>
<span class="line-added">2126     log_debug(cds)(&quot;Reserved archive_space_rs     [&quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot;] (&quot; SIZE_FORMAT &quot;) bytes&quot;,</span>
<span class="line-added">2127                    p2i(archive_space_rs.base()), p2i(archive_space_rs.end()), archive_space_rs.size());</span>
<span class="line-added">2128     log_debug(cds)(&quot;Reserved class_space_rs [&quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot;] (&quot; SIZE_FORMAT &quot;) bytes&quot;,</span>
<span class="line-added">2129                    p2i(class_space_rs.base()), p2i(class_space_rs.end()), class_space_rs.size());</span>
<span class="line-added">2130     MapArchiveResult static_result = map_archive(static_mapinfo, mapped_base_address, archive_space_rs);</span>
<span class="line-added">2131     MapArchiveResult dynamic_result = (static_result == MAP_ARCHIVE_SUCCESS) ?</span>
<span class="line-added">2132                                      map_archive(dynamic_mapinfo, mapped_base_address, archive_space_rs) : MAP_ARCHIVE_OTHER_FAILURE;</span>
<span class="line-added">2133 </span>
<span class="line-added">2134     DEBUG_ONLY(if (ArchiveRelocationMode == 1 &amp;&amp; use_requested_addr) {</span>
<span class="line-added">2135       // This is for simulating mmap failures at the requested address. In debug builds, we do it</span>
<span class="line-added">2136       // here (after all archives have possibly been mapped), so we can thoroughly test the code for</span>
<span class="line-added">2137       // failure handling (releasing all allocated resource, etc).</span>
<span class="line-added">2138       log_info(cds)(&quot;ArchiveRelocationMode == 1: always map archive(s) at an alternative address&quot;);</span>
<span class="line-added">2139       if (static_result == MAP_ARCHIVE_SUCCESS) {</span>
<span class="line-added">2140         static_result = MAP_ARCHIVE_MMAP_FAILURE;</span>
<span class="line-added">2141       }</span>
<span class="line-added">2142       if (dynamic_result == MAP_ARCHIVE_SUCCESS) {</span>
<span class="line-added">2143         dynamic_result = MAP_ARCHIVE_MMAP_FAILURE;</span>
<span class="line-added">2144       }</span>
<span class="line-added">2145     });</span>
<span class="line-added">2146 </span>
<span class="line-added">2147     if (static_result == MAP_ARCHIVE_SUCCESS) {</span>
<span class="line-added">2148       if (dynamic_result == MAP_ARCHIVE_SUCCESS) {</span>
<span class="line-added">2149         result = MAP_ARCHIVE_SUCCESS;</span>
<span class="line-added">2150       } else if (dynamic_result == MAP_ARCHIVE_OTHER_FAILURE) {</span>
<span class="line-added">2151         assert(dynamic_mapinfo != NULL &amp;&amp; !dynamic_mapinfo-&gt;is_mapped(), &quot;must have failed&quot;);</span>
<span class="line-added">2152         // No need to retry mapping the dynamic archive again, as it will never succeed</span>
<span class="line-added">2153         // (bad file, etc) -- just keep the base archive.</span>
<span class="line-added">2154         log_warning(cds, dynamic)(&quot;Unable to use shared archive. The top archive failed to load: %s&quot;,</span>
<span class="line-added">2155                                   dynamic_mapinfo-&gt;full_path());</span>
<span class="line-added">2156         result = MAP_ARCHIVE_SUCCESS;</span>
<span class="line-added">2157         // TODO, we can give the unused space for the dynamic archive to class_space_rs, but there&#39;s no</span>
<span class="line-added">2158         // easy API to do that right now.</span>
<span class="line-added">2159       } else {</span>
<span class="line-added">2160         result = MAP_ARCHIVE_MMAP_FAILURE;</span>
<span class="line-added">2161       }</span>
<span class="line-added">2162     } else if (static_result == MAP_ARCHIVE_OTHER_FAILURE) {</span>
<span class="line-added">2163       result = MAP_ARCHIVE_OTHER_FAILURE;</span>
<span class="line-added">2164     } else {</span>
<span class="line-added">2165       result = MAP_ARCHIVE_MMAP_FAILURE;</span>
<span class="line-added">2166     }</span>
<span class="line-added">2167   }</span>
<span class="line-added">2168 </span>
<span class="line-added">2169   if (result == MAP_ARCHIVE_SUCCESS) {</span>
<span class="line-added">2170     if (!main_rs.is_reserved() &amp;&amp; class_space_rs.is_reserved()) {</span>
<span class="line-added">2171       MemTracker::record_virtual_memory_type((address)class_space_rs.base(), mtClass);</span>
<span class="line-added">2172     }</span>
<span class="line-added">2173     SharedBaseAddress = (size_t)mapped_base_address;</span>
<span class="line-added">2174     LP64_ONLY({</span>
<span class="line-added">2175         if (Metaspace::using_class_space()) {</span>
<span class="line-added">2176           assert(class_space_rs.is_reserved(), &quot;must be&quot;);</span>
<span class="line-added">2177           char* cds_base = static_mapinfo-&gt;mapped_base();</span>
<span class="line-added">2178           Metaspace::allocate_metaspace_compressed_klass_ptrs(class_space_rs, NULL, (address)cds_base);</span>
<span class="line-added">2179           // map_heap_regions() compares the current narrow oop and klass encodings</span>
<span class="line-added">2180           // with the archived ones, so it must be done after all encodings are determined.</span>
<span class="line-added">2181           static_mapinfo-&gt;map_heap_regions();</span>
<span class="line-added">2182           CompressedKlassPointers::set_range(CompressedClassSpaceSize);</span>
<span class="line-added">2183         }</span>
<span class="line-added">2184       });</span>
<span class="line-added">2185   } else {</span>
<span class="line-added">2186     unmap_archive(static_mapinfo);</span>
<span class="line-added">2187     unmap_archive(dynamic_mapinfo);</span>
<span class="line-added">2188     release_reserved_spaces(main_rs, archive_space_rs, class_space_rs);</span>
<span class="line-added">2189   }</span>
<span class="line-added">2190 </span>
<span class="line-added">2191   return result;</span>
2192 }
2193 
<a name="157" id="anc157"></a><span class="line-modified">2194 char* MetaspaceShared::reserve_address_space_for_archives(FileMapInfo* static_mapinfo,</span>
<span class="line-modified">2195                                                           FileMapInfo* dynamic_mapinfo,</span>
<span class="line-modified">2196                                                           bool use_requested_addr,</span>
<span class="line-added">2197                                                           ReservedSpace&amp; main_rs,</span>
<span class="line-added">2198                                                           ReservedSpace&amp; archive_space_rs,</span>
<span class="line-added">2199                                                           ReservedSpace&amp; class_space_rs) {</span>
<span class="line-added">2200   const bool use_klass_space = NOT_LP64(false) LP64_ONLY(Metaspace::using_class_space());</span>
<span class="line-added">2201   const size_t class_space_size = NOT_LP64(0) LP64_ONLY(Metaspace::compressed_class_space_size());</span>
2202 
<a name="158" id="anc158"></a><span class="line-modified">2203   if (use_klass_space) {</span>
<span class="line-modified">2204     assert(class_space_size &gt; 0, &quot;CompressedClassSpaceSize must have been validated&quot;);</span>
<span class="line-modified">2205   }</span>
<span class="line-modified">2206   if (use_requested_addr &amp;&amp; !is_aligned(static_mapinfo-&gt;requested_base_address(), reserved_space_alignment())) {</span>
<span class="line-modified">2207     return NULL;</span>
<span class="line-modified">2208   }</span>

2209 
<a name="159" id="anc159"></a><span class="line-modified">2210   // Size and requested location of the archive_space_rs (for both static and dynamic archives)</span>
<span class="line-modified">2211   size_t base_offset = static_mapinfo-&gt;mapping_base_offset();</span>
<span class="line-modified">2212   size_t end_offset  = (dynamic_mapinfo == NULL) ? static_mapinfo-&gt;mapping_end_offset() : dynamic_mapinfo-&gt;mapping_end_offset();</span>
<span class="line-modified">2213   assert(base_offset == 0, &quot;must be&quot;);</span>
<span class="line-modified">2214   assert(is_aligned(end_offset,  os::vm_allocation_granularity()), &quot;must be&quot;);</span>
<span class="line-modified">2215   assert(is_aligned(base_offset, os::vm_allocation_granularity()), &quot;must be&quot;);</span>
<span class="line-modified">2216 </span>
<span class="line-modified">2217   // In case reserved_space_alignment() != os::vm_allocation_granularity()</span>
<span class="line-modified">2218   assert((size_t)os::vm_allocation_granularity() &lt;= reserved_space_alignment(), &quot;must be&quot;);</span>
<span class="line-modified">2219   end_offset = align_up(end_offset, reserved_space_alignment());</span>
<span class="line-modified">2220 </span>
<span class="line-modified">2221   size_t archive_space_size = end_offset - base_offset;</span>
<span class="line-modified">2222 </span>
<span class="line-modified">2223   // Special handling for Windows because it cannot mmap into a reserved space:</span>
<span class="line-modified">2224   //    use_requested_addr: We just map each region individually, and give up if any one of them fails.</span>
<span class="line-modified">2225   //   !use_requested_addr: We reserve the space first, and then os::read in all the regions (instead of mmap).</span>
<span class="line-modified">2226   //                        We&#39;re going to patch all the pointers anyway so there&#39;s no benefit for mmap.</span>
<span class="line-modified">2227 </span>
<span class="line-modified">2228   if (use_requested_addr) {</span>
<span class="line-modified">2229     char* archive_space_base = static_mapinfo-&gt;requested_base_address() + base_offset;</span>
<span class="line-modified">2230     char* archive_space_end  = archive_space_base + archive_space_size;</span>
<span class="line-modified">2231     if (!MetaspaceShared::use_windows_memory_mapping()) {</span>
<span class="line-modified">2232       archive_space_rs = reserve_shared_space(archive_space_size, archive_space_base);</span>
<span class="line-modified">2233       if (!archive_space_rs.is_reserved()) {</span>
<span class="line-modified">2234         return NULL;</span>
<span class="line-modified">2235       }</span>
<span class="line-modified">2236     }</span>
<span class="line-modified">2237     if (use_klass_space) {</span>
<span class="line-modified">2238       // Make sure we can map the klass space immediately following the archive_space space</span>
<span class="line-modified">2239       // Don&#39;t call reserve_shared_space here as that may try to enforce platform-specific</span>
<span class="line-modified">2240       // alignment rules which only apply to the archive base address</span>
<span class="line-added">2241       char* class_space_base = archive_space_end;</span>
<span class="line-added">2242       class_space_rs = ReservedSpace(class_space_size, reserved_space_alignment(),</span>
<span class="line-added">2243                                      false /* large_pages */, class_space_base);</span>
<span class="line-added">2244       if (!class_space_rs.is_reserved()) {</span>
<span class="line-added">2245         return NULL;</span>
<span class="line-added">2246       }</span>
<span class="line-added">2247     }</span>
<span class="line-added">2248     return static_mapinfo-&gt;requested_base_address();</span>
2249   } else {
<a name="160" id="anc160"></a><span class="line-modified">2250     if (use_klass_space) {</span>
<span class="line-modified">2251       main_rs = reserve_shared_space(archive_space_size + class_space_size);</span>
<span class="line-modified">2252       if (main_rs.is_reserved()) {</span>
<span class="line-modified">2253         archive_space_rs = main_rs.first_part(archive_space_size, reserved_space_alignment(), /*split=*/true);</span>
<span class="line-modified">2254         class_space_rs = main_rs.last_part(archive_space_size);</span>
<span class="line-modified">2255       }</span>








2256     } else {
<a name="161" id="anc161"></a><span class="line-modified">2257       main_rs = reserve_shared_space(archive_space_size);</span>
<span class="line-added">2258       archive_space_rs = main_rs;</span>
2259     }
<a name="162" id="anc162"></a><span class="line-modified">2260     if (archive_space_rs.is_reserved()) {</span>
<span class="line-added">2261       return archive_space_rs.base();</span>
<span class="line-added">2262     } else {</span>
<span class="line-added">2263       return NULL;</span>
<span class="line-added">2264     }</span>
<span class="line-added">2265   }</span>
<span class="line-added">2266 }</span>
<span class="line-added">2267 </span>
<span class="line-added">2268 void MetaspaceShared::release_reserved_spaces(ReservedSpace&amp; main_rs,</span>
<span class="line-added">2269                                               ReservedSpace&amp; archive_space_rs,</span>
<span class="line-added">2270                                               ReservedSpace&amp; class_space_rs) {</span>
<span class="line-added">2271   if (main_rs.is_reserved()) {</span>
<span class="line-added">2272     assert(main_rs.contains(archive_space_rs.base()), &quot;must be&quot;);</span>
<span class="line-added">2273     assert(main_rs.contains(class_space_rs.base()), &quot;must be&quot;);</span>
<span class="line-added">2274     log_debug(cds)(&quot;Released shared space (archive+classes) &quot; INTPTR_FORMAT, p2i(main_rs.base()));</span>
<span class="line-added">2275     main_rs.release();</span>
<span class="line-added">2276   } else {</span>
<span class="line-added">2277     if (archive_space_rs.is_reserved()) {</span>
<span class="line-added">2278       log_debug(cds)(&quot;Released shared space (archive) &quot; INTPTR_FORMAT, p2i(archive_space_rs.base()));</span>
<span class="line-added">2279       archive_space_rs.release();</span>
<span class="line-added">2280     }</span>
<span class="line-added">2281     if (class_space_rs.is_reserved()) {</span>
<span class="line-added">2282       log_debug(cds)(&quot;Released shared space (classes) &quot; INTPTR_FORMAT, p2i(class_space_rs.base()));</span>
<span class="line-added">2283       class_space_rs.release();</span>
<span class="line-added">2284     }</span>
<span class="line-added">2285   }</span>
<span class="line-added">2286 }</span>
<span class="line-added">2287 </span>
<span class="line-added">2288 static int archive_regions[]  = {MetaspaceShared::mc,</span>
<span class="line-added">2289                                  MetaspaceShared::rw,</span>
<span class="line-added">2290                                  MetaspaceShared::ro};</span>
<span class="line-added">2291 static int archive_regions_count  = 3;</span>
<span class="line-added">2292 </span>
<span class="line-added">2293 MapArchiveResult MetaspaceShared::map_archive(FileMapInfo* mapinfo, char* mapped_base_address, ReservedSpace rs) {</span>
<span class="line-added">2294   assert(UseSharedSpaces, &quot;must be runtime&quot;);</span>
<span class="line-added">2295   if (mapinfo == NULL) {</span>
<span class="line-added">2296     return MAP_ARCHIVE_SUCCESS; // The dynamic archive has not been specified. No error has happened -- trivially succeeded.</span>
<span class="line-added">2297   }</span>
<span class="line-added">2298 </span>
<span class="line-added">2299   mapinfo-&gt;set_is_mapped(false);</span>
<span class="line-added">2300 </span>
<span class="line-added">2301   if (mapinfo-&gt;alignment() != (size_t)os::vm_allocation_granularity()) {</span>
<span class="line-added">2302     log_error(cds)(&quot;Unable to map CDS archive -- os::vm_allocation_granularity() expected: &quot; SIZE_FORMAT</span>
<span class="line-added">2303                    &quot; actual: %d&quot;, mapinfo-&gt;alignment(), os::vm_allocation_granularity());</span>
<span class="line-added">2304     return MAP_ARCHIVE_OTHER_FAILURE;</span>
<span class="line-added">2305   }</span>
<span class="line-added">2306 </span>
<span class="line-added">2307   MapArchiveResult result =</span>
<span class="line-added">2308     mapinfo-&gt;map_regions(archive_regions, archive_regions_count, mapped_base_address, rs);</span>
<span class="line-added">2309 </span>
<span class="line-added">2310   if (result != MAP_ARCHIVE_SUCCESS) {</span>
<span class="line-added">2311     unmap_archive(mapinfo);</span>
<span class="line-added">2312     return result;</span>
<span class="line-added">2313   }</span>
<span class="line-added">2314 </span>
<span class="line-added">2315   if (mapinfo-&gt;is_static()) {</span>
<span class="line-added">2316     if (!mapinfo-&gt;validate_shared_path_table()) {</span>
<span class="line-added">2317       unmap_archive(mapinfo);</span>
<span class="line-added">2318       return MAP_ARCHIVE_OTHER_FAILURE;</span>
<span class="line-added">2319     }</span>
<span class="line-added">2320   } else {</span>
<span class="line-added">2321     if (!DynamicArchive::validate(mapinfo)) {</span>
<span class="line-added">2322       unmap_archive(mapinfo);</span>
<span class="line-added">2323       return MAP_ARCHIVE_OTHER_FAILURE;</span>
<span class="line-added">2324     }</span>
<span class="line-added">2325   }</span>
<span class="line-added">2326 </span>
<span class="line-added">2327   mapinfo-&gt;set_is_mapped(true);</span>
<span class="line-added">2328   return MAP_ARCHIVE_SUCCESS;</span>
<span class="line-added">2329 }</span>
<span class="line-added">2330 </span>
<span class="line-added">2331 void MetaspaceShared::unmap_archive(FileMapInfo* mapinfo) {</span>
<span class="line-added">2332   assert(UseSharedSpaces, &quot;must be runtime&quot;);</span>
<span class="line-added">2333   if (mapinfo != NULL) {</span>
<span class="line-added">2334     mapinfo-&gt;unmap_regions(archive_regions, archive_regions_count);</span>
<span class="line-added">2335     mapinfo-&gt;set_is_mapped(false);</span>
2336   }
2337 }
2338 
2339 // Read the miscellaneous data from the shared file, and
2340 // serialize it out to its various destinations.
2341 
2342 void MetaspaceShared::initialize_shared_spaces() {
<a name="163" id="anc163"></a><span class="line-modified">2343   FileMapInfo *static_mapinfo = FileMapInfo::current_info();</span>
<span class="line-modified">2344   _i2i_entry_code_buffers = static_mapinfo-&gt;i2i_entry_code_buffers();</span>
<span class="line-modified">2345   _i2i_entry_code_buffers_size = static_mapinfo-&gt;i2i_entry_code_buffers_size();</span>
<span class="line-modified">2346   char* buffer = static_mapinfo-&gt;cloned_vtables();</span>


2347   clone_cpp_vtables((intptr_t*)buffer);
2348 
<a name="164" id="anc164"></a>


2349   // Verify various attributes of the archive, plus initialize the
2350   // shared string/symbol tables
<a name="165" id="anc165"></a><span class="line-added">2351   buffer = static_mapinfo-&gt;serialized_data();</span>
2352   intptr_t* array = (intptr_t*)buffer;
2353   ReadClosure rc(&amp;array);
2354   serialize(&amp;rc);
2355 
2356   // Initialize the run-time symbol table.
2357   SymbolTable::create_table();
2358 
<a name="166" id="anc166"></a><span class="line-modified">2359   static_mapinfo-&gt;patch_archived_heap_embedded_pointers();</span>
2360 
2361   // Close the mapinfo file
<a name="167" id="anc167"></a><span class="line-modified">2362   static_mapinfo-&gt;close();</span>
<span class="line-added">2363 </span>
<span class="line-added">2364   FileMapInfo *dynamic_mapinfo = FileMapInfo::dynamic_info();</span>
<span class="line-added">2365   if (dynamic_mapinfo != NULL) {</span>
<span class="line-added">2366     intptr_t* buffer = (intptr_t*)dynamic_mapinfo-&gt;serialized_data();</span>
<span class="line-added">2367     ReadClosure rc(&amp;buffer);</span>
<span class="line-added">2368     SymbolTable::serialize_shared_table_header(&amp;rc, false);</span>
<span class="line-added">2369     SystemDictionaryShared::serialize_dictionary_headers(&amp;rc, false);</span>
<span class="line-added">2370     dynamic_mapinfo-&gt;close();</span>
<span class="line-added">2371   }</span>
2372 
2373   if (PrintSharedArchiveAndExit) {
2374     if (PrintSharedDictionary) {
2375       tty-&gt;print_cr(&quot;\nShared classes:\n&quot;);
2376       SystemDictionaryShared::print_on(tty);
2377     }
<a name="168" id="anc168"></a><span class="line-modified">2378     if (FileMapInfo::current_info() == NULL || _archive_loading_failed) {</span>
2379       tty-&gt;print_cr(&quot;archive is invalid&quot;);
2380       vm_exit(1);
2381     } else {
2382       tty-&gt;print_cr(&quot;archive is valid&quot;);
2383       vm_exit(0);
2384     }
2385   }
2386 }
2387 
2388 // JVM/TI RedefineClasses() support:
2389 bool MetaspaceShared::remap_shared_readonly_as_readwrite() {
2390   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
2391 
2392   if (UseSharedSpaces) {
2393     // remap the shared readonly space to shared readwrite, private
2394     FileMapInfo* mapinfo = FileMapInfo::current_info();
2395     if (!mapinfo-&gt;remap_shared_readonly_as_readwrite()) {
2396       return false;
2397     }
<a name="169" id="anc169"></a><span class="line-added">2398     if (FileMapInfo::dynamic_info() != NULL) {</span>
<span class="line-added">2399       mapinfo = FileMapInfo::dynamic_info();</span>
<span class="line-added">2400       if (!mapinfo-&gt;remap_shared_readonly_as_readwrite()) {</span>
<span class="line-added">2401         return false;</span>
<span class="line-added">2402       }</span>
<span class="line-added">2403     }</span>
2404     _remapped_readwrite = true;
2405   }
2406   return true;
2407 }
2408 
2409 void MetaspaceShared::report_out_of_space(const char* name, size_t needed_bytes) {
2410   // This is highly unlikely to happen on 64-bits because we have reserved a 4GB space.
2411   // On 32-bit we reserve only 256MB so you could run out of space with 100,000 classes
2412   // or so.
2413   _mc_region.print_out_of_space_msg(name, needed_bytes);
2414   _rw_region.print_out_of_space_msg(name, needed_bytes);
2415   _ro_region.print_out_of_space_msg(name, needed_bytes);
<a name="170" id="anc170"></a>
2416 
2417   vm_exit_during_initialization(err_msg(&quot;Unable to allocate from &#39;%s&#39; region&quot;, name),
2418                                 &quot;Please reduce the number of shared classes.&quot;);
2419 }
<a name="171" id="anc171"></a><span class="line-added">2420 </span>
<span class="line-added">2421 // This is used to relocate the pointers so that the archive can be mapped at</span>
<span class="line-added">2422 // Arguments::default_SharedBaseAddress() without runtime relocation.</span>
<span class="line-added">2423 intx MetaspaceShared::final_delta() {</span>
<span class="line-added">2424   return intx(Arguments::default_SharedBaseAddress())  // We want the archive to be mapped to here at runtime</span>
<span class="line-added">2425        - intx(SharedBaseAddress);                      // .. but the archive is mapped at here at dump time</span>
<span class="line-added">2426 }</span>
<a name="172" id="anc172"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="172" type="hidden" />
</body>
</html>
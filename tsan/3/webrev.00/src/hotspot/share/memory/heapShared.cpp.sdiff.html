<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/heapShared.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="heapInspection.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="heapShared.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/heapShared.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/javaClasses.inline.hpp&quot;
  27 #include &quot;classfile/stringTable.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;

  29 #include &quot;classfile/vmSymbols.hpp&quot;
  30 #include &quot;logging/log.hpp&quot;
  31 #include &quot;logging/logMessage.hpp&quot;
  32 #include &quot;logging/logStream.hpp&quot;

  33 #include &quot;memory/filemap.hpp&quot;
  34 #include &quot;memory/heapShared.inline.hpp&quot;
  35 #include &quot;memory/iterator.inline.hpp&quot;
  36 #include &quot;memory/metadataFactory.hpp&quot;
  37 #include &quot;memory/metaspaceClosure.hpp&quot;

  38 #include &quot;memory/resourceArea.hpp&quot;

  39 #include &quot;oops/compressedOops.inline.hpp&quot;
<span class="line-modified">  40 #include &quot;oops/fieldStreams.hpp&quot;</span>
  41 #include &quot;oops/oop.inline.hpp&quot;
  42 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  43 #include &quot;runtime/safepointVerifiers.hpp&quot;
  44 #include &quot;utilities/bitMap.inline.hpp&quot;
  45 #if INCLUDE_G1GC
  46 #include &quot;gc/g1/g1CollectedHeap.hpp&quot;
  47 #endif
  48 
  49 #if INCLUDE_CDS_JAVA_HEAP
  50 
  51 bool HeapShared::_closed_archive_heap_region_mapped = false;
  52 bool HeapShared::_open_archive_heap_region_mapped = false;
  53 bool HeapShared::_archive_heap_region_fixed = false;
  54 
  55 address   HeapShared::_narrow_oop_base;
  56 int       HeapShared::_narrow_oop_shift;
  57 
  58 //
  59 // If you add new entries to the following tables, you should know what you&#39;re doing!
  60 //
  61 
  62 // Entry fields for shareable subgraphs archived in the closed archive heap
  63 // region. Warning: Objects in the subgraphs should not have reference fields
  64 // assigned at runtime.
  65 static ArchivableStaticFieldInfo closed_archive_subgraph_entry_fields[] = {
  66   {&quot;java/lang/Integer$IntegerCache&quot;,           &quot;archivedCache&quot;},
  67   {&quot;java/lang/Long$LongCache&quot;,                 &quot;archivedCache&quot;},
  68   {&quot;java/lang/Byte$ByteCache&quot;,                 &quot;archivedCache&quot;},
  69   {&quot;java/lang/Short$ShortCache&quot;,               &quot;archivedCache&quot;},
  70   {&quot;java/lang/Character$CharacterCache&quot;,       &quot;archivedCache&quot;},


  71 };
  72 // Entry fields for subgraphs archived in the open archive heap region.
  73 static ArchivableStaticFieldInfo open_archive_subgraph_entry_fields[] = {
  74   {&quot;jdk/internal/module/ArchivedModuleGraph&quot;,  &quot;archivedModuleGraph&quot;},
<span class="line-modified">  75   {&quot;java/util/ImmutableCollections$ListN&quot;,     &quot;EMPTY_LIST&quot;},</span>
<span class="line-removed">  76   {&quot;java/util/ImmutableCollections$MapN&quot;,      &quot;EMPTY_MAP&quot;},</span>
<span class="line-removed">  77   {&quot;java/util/ImmutableCollections$SetN&quot;,      &quot;EMPTY_SET&quot;},</span>
  78   {&quot;java/lang/module/Configuration&quot;,           &quot;EMPTY_CONFIGURATION&quot;},

  79 };
  80 
  81 const static int num_closed_archive_subgraph_entry_fields =
  82   sizeof(closed_archive_subgraph_entry_fields) / sizeof(ArchivableStaticFieldInfo);
  83 const static int num_open_archive_subgraph_entry_fields =
  84   sizeof(open_archive_subgraph_entry_fields) / sizeof(ArchivableStaticFieldInfo);
  85 
  86 ////////////////////////////////////////////////////////////////
  87 //
  88 // Java heap object archiving support
  89 //
  90 ////////////////////////////////////////////////////////////////
  91 void HeapShared::fixup_mapped_heap_regions() {
  92   FileMapInfo *mapinfo = FileMapInfo::current_info();
  93   mapinfo-&gt;fixup_mapped_heap_regions();
  94   set_archive_heap_region_fixed();
  95 }
  96 
  97 unsigned HeapShared::oop_hash(oop const&amp; p) {
<span class="line-modified">  98   assert(!p-&gt;mark()-&gt;has_bias_pattern(),</span>
  99          &quot;this object should never have been locked&quot;);  // so identity_hash won&#39;t safepoin
 100   unsigned hash = (unsigned)p-&gt;identity_hash();
 101   return hash;
 102 }
 103 
 104 HeapShared::ArchivedObjectCache* HeapShared::_archived_object_cache = NULL;
 105 oop HeapShared::find_archived_heap_object(oop obj) {
 106   assert(DumpSharedSpaces, &quot;dump-time only&quot;);
 107   ArchivedObjectCache* cache = archived_object_cache();
 108   oop* p = cache-&gt;get(obj);
 109   if (p != NULL) {
 110     return *p;
 111   } else {
 112     return NULL;
 113   }
 114 }
 115 
 116 oop HeapShared::archive_heap_object(oop obj, Thread* THREAD) {
 117   assert(DumpSharedSpaces, &quot;dump-time only&quot;);
 118 
 119   oop ao = find_archived_heap_object(obj);
 120   if (ao != NULL) {
 121     // already archived
 122     return ao;
 123   }
 124 
 125   int len = obj-&gt;size();
 126   if (G1CollectedHeap::heap()-&gt;is_archive_alloc_too_large(len)) {
 127     log_debug(cds, heap)(&quot;Cannot archive, object (&quot; PTR_FORMAT &quot;) is too large: &quot; SIZE_FORMAT,
 128                          p2i(obj), (size_t)obj-&gt;size());
 129     return NULL;
 130   }
 131 
 132   // Pre-compute object identity hash at CDS dump time.
 133   obj-&gt;identity_hash();
 134 
 135   oop archived_oop = (oop)G1CollectedHeap::heap()-&gt;archive_mem_allocate(len);
 136   if (archived_oop != NULL) {
<span class="line-modified"> 137     Copy::aligned_disjoint_words((HeapWord*)obj, (HeapWord*)archived_oop, len);</span>
 138     MetaspaceShared::relocate_klass_ptr(archived_oop);
 139     ArchivedObjectCache* cache = archived_object_cache();
 140     cache-&gt;put(obj, archived_oop);
 141     log_debug(cds, heap)(&quot;Archived heap object &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
 142                          p2i(obj), p2i(archived_oop));
 143   } else {
 144     log_error(cds, heap)(
 145       &quot;Cannot allocate space for object &quot; PTR_FORMAT &quot; in archived heap region&quot;,
 146       p2i(obj));
 147     vm_exit(1);
 148   }
 149   return archived_oop;
 150 }
 151 
 152 oop HeapShared::materialize_archived_object(narrowOop v) {
 153   assert(archive_heap_region_fixed(),
 154          &quot;must be called after archive heap regions are fixed&quot;);
 155   if (!CompressedOops::is_null(v)) {
 156     oop obj = HeapShared::decode_from_archive(v);
 157     return G1CollectedHeap::heap()-&gt;materialize_archived_object(obj);
</pre>
<hr />
<pre>
 162 void HeapShared::archive_klass_objects(Thread* THREAD) {
 163   GrowableArray&lt;Klass*&gt;* klasses = MetaspaceShared::collected_klasses();
 164   assert(klasses != NULL, &quot;sanity&quot;);
 165   for (int i = 0; i &lt; klasses-&gt;length(); i++) {
 166     Klass* k = klasses-&gt;at(i);
 167 
 168     // archive mirror object
 169     java_lang_Class::archive_mirror(k, CHECK);
 170 
 171     // archive the resolved_referenes array
 172     if (k-&gt;is_instance_klass()) {
 173       InstanceKlass* ik = InstanceKlass::cast(k);
 174       ik-&gt;constants()-&gt;archive_resolved_references(THREAD);
 175     }
 176   }
 177 }
 178 
 179 void HeapShared::archive_java_heap_objects(GrowableArray&lt;MemRegion&gt; *closed,
 180                                            GrowableArray&lt;MemRegion&gt; *open) {
 181   if (!is_heap_object_archiving_allowed()) {
<span class="line-modified"> 182     if (log_is_enabled(Info, cds)) {</span>
<span class="line-modified"> 183       log_info(cds)(</span>
<span class="line-modified"> 184         &quot;Archived java heap is not supported as UseG1GC, &quot;</span>
<span class="line-modified"> 185         &quot;UseCompressedOops and UseCompressedClassPointers are required.&quot;</span>
<span class="line-modified"> 186         &quot;Current settings: UseG1GC=%s, UseCompressedOops=%s, UseCompressedClassPointers=%s.&quot;,</span>
<span class="line-modified"> 187         BOOL_TO_STR(UseG1GC), BOOL_TO_STR(UseCompressedOops),</span>
<span class="line-removed"> 188         BOOL_TO_STR(UseCompressedClassPointers));</span>
<span class="line-removed"> 189     }</span>
 190     return;
 191   }
 192 
 193   G1HeapVerifier::verify_ready_for_archiving();
 194 
 195   {
 196     NoSafepointVerifier nsv;
 197 
 198     // Cache for recording where the archived objects are copied to
 199     create_archived_object_cache();
 200 
<span class="line-modified"> 201     tty-&gt;print_cr(&quot;Dumping objects to closed archive heap region ...&quot;);</span>
 202     NOT_PRODUCT(StringTable::verify());
 203     copy_closed_archive_heap_objects(closed);
 204 
<span class="line-modified"> 205     tty-&gt;print_cr(&quot;Dumping objects to open archive heap region ...&quot;);</span>
 206     copy_open_archive_heap_objects(open);
 207 
 208     destroy_archived_object_cache();
 209   }
 210 
 211   G1HeapVerifier::verify_archive_regions();
 212 }
 213 
 214 void HeapShared::copy_closed_archive_heap_objects(
 215                                     GrowableArray&lt;MemRegion&gt; * closed_archive) {
 216   assert(is_heap_object_archiving_allowed(), &quot;Cannot archive java heap objects&quot;);
 217 
 218   Thread* THREAD = Thread::current();
 219   G1CollectedHeap::heap()-&gt;begin_archive_alloc_range();
 220 
 221   // Archive interned string objects
 222   StringTable::write_to_archive();
 223 
 224   archive_object_subgraphs(closed_archive_subgraph_entry_fields,
 225                            num_closed_archive_subgraph_entry_fields,
</pre>
<hr />
<pre>
 362     for (int i = 0 ; i &lt; num_entry_fields; i++) {
 363       _entry_field_records-&gt;at_put(i, entry_fields-&gt;at(i));
 364     }
 365   }
 366 
 367   // the Klasses of the objects in the sub-graphs
 368   GrowableArray&lt;Klass*&gt;* subgraph_object_klasses = info-&gt;subgraph_object_klasses();
 369   if (subgraph_object_klasses != NULL) {
 370     int num_subgraphs_klasses = subgraph_object_klasses-&gt;length();
 371     _subgraph_object_klasses =
 372       MetaspaceShared::new_ro_array&lt;Klass*&gt;(num_subgraphs_klasses);
 373     for (int i = 0; i &lt; num_subgraphs_klasses; i++) {
 374       Klass* subgraph_k = subgraph_object_klasses-&gt;at(i);
 375       if (log_is_enabled(Info, cds, heap)) {
 376         ResourceMark rm;
 377         log_info(cds, heap)(
 378           &quot;Archived object klass %s (%2d) =&gt; %s&quot;,
 379           _k-&gt;external_name(), i, subgraph_k-&gt;external_name());
 380       }
 381       _subgraph_object_klasses-&gt;at_put(i, subgraph_k);

 382     }
 383   }




 384 }
 385 
 386 struct CopyKlassSubGraphInfoToArchive : StackObj {
 387   CompactHashtableWriter* _writer;
 388   CopyKlassSubGraphInfoToArchive(CompactHashtableWriter* writer) : _writer(writer) {}
 389 
 390   bool do_entry(Klass* klass, KlassSubGraphInfo&amp; info) {
 391     if (info.subgraph_object_klasses() != NULL || info.subgraph_entry_fields() != NULL) {
 392       ArchivedKlassSubGraphInfoRecord* record =
 393         (ArchivedKlassSubGraphInfoRecord*)MetaspaceShared::read_only_space_alloc(sizeof(ArchivedKlassSubGraphInfoRecord));
 394       record-&gt;init(&amp;info);
 395 
<span class="line-modified"> 396       unsigned int hash = primitive_hash&lt;Klass*&gt;(klass);</span>
 397       u4 delta = MetaspaceShared::object_delta_u4(record);
 398       _writer-&gt;add(hash, delta);
 399     }
 400     return true; // keep on iterating
 401   }
 402 };
 403 
 404 // Build the records of archived subgraph infos, which include:
 405 // - Entry points to all subgraphs from the containing class mirror. The entry
 406 //   points are static fields in the mirror. For each entry point, the field
 407 //   offset, value and is_closed_archive flag are recorded in the sub-graph
 408 //   info. The value is stored back to the corresponding field at runtime.
 409 // - A list of klasses that need to be loaded/initialized before archived
 410 //   java object sub-graph can be accessed at runtime.
 411 void HeapShared::write_subgraph_info_table() {
 412   // Allocate the contents of the hashtable(s) inside the RO region of the CDS archive.
 413   DumpTimeKlassSubGraphInfoTable* d_table = _dump_time_subgraph_info_table;
 414   CompactHashtableStats stats;
 415 
 416   _run_time_subgraph_info_table.reset();
 417 
<span class="line-modified"> 418   int num_buckets = CompactHashtableWriter::default_num_buckets(d_table-&gt;_count);</span>
<span class="line-removed"> 419   CompactHashtableWriter writer(num_buckets, &amp;stats);</span>
 420   CopyKlassSubGraphInfoToArchive copy(&amp;writer);
 421   d_table-&gt;iterate(&amp;copy);
 422 
 423   writer.dump(&amp;_run_time_subgraph_info_table, &quot;subgraphs&quot;);
 424 }
 425 
 426 void HeapShared::serialize_subgraph_info_table_header(SerializeClosure* soc) {
 427   _run_time_subgraph_info_table.serialize_header(soc);
 428 }
 429 
 430 void HeapShared::initialize_from_archived_subgraph(Klass* k) {
 431   if (!open_archive_heap_region_mapped()) {
 432     return; // nothing to do
 433   }
 434   assert(!DumpSharedSpaces, &quot;Should not be called with DumpSharedSpaces&quot;);
 435 
<span class="line-modified"> 436   unsigned int hash = primitive_hash&lt;Klass*&gt;(k);</span>
 437   const ArchivedKlassSubGraphInfoRecord* record = _run_time_subgraph_info_table.lookup(k, hash, 0);
 438 
 439   // Initialize from archived data. Currently this is done only
 440   // during VM initialization time. No lock is needed.
 441   if (record != NULL) {
 442     Thread* THREAD = Thread::current();
 443 
 444     int i;
 445     // Load/link/initialize the klasses of the objects in the subgraph.
 446     // NULL class loader is used.
 447     Array&lt;Klass*&gt;* klasses = record-&gt;subgraph_object_klasses();
 448     if (klasses != NULL) {
 449       for (i = 0; i &lt; klasses-&gt;length(); i++) {
 450         Klass* obj_k = klasses-&gt;at(i);
 451         Klass* resolved_k = SystemDictionary::resolve_or_null(
 452                                               (obj_k)-&gt;name(), THREAD);
 453         if (resolved_k != obj_k) {
 454           assert(!SystemDictionary::is_well_known_klass(resolved_k),
 455                  &quot;shared well-known classes must not be replaced by JVMTI ClassFileLoadHook&quot;);
 456           ResourceMark rm(THREAD);
</pre>
<hr />
<pre>
 529                            bool is_closed_archive,
 530                            bool record_klasses_only,
 531                            KlassSubGraphInfo* subgraph_info,
 532                            oop orig, oop archived, TRAPS) :
 533     _level(level), _is_closed_archive(is_closed_archive),
 534     _record_klasses_only(record_klasses_only),
 535     _subgraph_info(subgraph_info),
 536     _orig_referencing_obj(orig), _archived_referencing_obj(archived),
 537     _thread(THREAD) {}
 538   void do_oop(narrowOop *p) { WalkOopAndArchiveClosure::do_oop_work(p); }
 539   void do_oop(      oop *p) { WalkOopAndArchiveClosure::do_oop_work(p); }
 540 
 541  protected:
 542   template &lt;class T&gt; void do_oop_work(T *p) {
 543     oop obj = RawAccess&lt;&gt;::oop_load(p);
 544     if (!CompressedOops::is_null(obj)) {
 545       assert(!HeapShared::is_archived_object(obj),
 546              &quot;original objects must not point to archived objects&quot;);
 547 
 548       size_t field_delta = pointer_delta(p, _orig_referencing_obj, sizeof(char));
<span class="line-modified"> 549       T* new_p = (T*)(address(_archived_referencing_obj) + field_delta);</span>
 550       Thread* THREAD = _thread;
 551 
 552       if (!_record_klasses_only &amp;&amp; log_is_enabled(Debug, cds, heap)) {
 553         ResourceMark rm;
 554         log_debug(cds, heap)(&quot;(%d) %s[&quot; SIZE_FORMAT &quot;] ==&gt; &quot; PTR_FORMAT &quot; size %d %s&quot;, _level,
 555                              _orig_referencing_obj-&gt;klass()-&gt;external_name(), field_delta,
 556                              p2i(obj), obj-&gt;size() * HeapWordSize, obj-&gt;klass()-&gt;external_name());
 557         LogTarget(Trace, cds, heap) log;
 558         LogStream out(log);
 559         obj-&gt;print_on(&amp;out);
 560       }
 561 
 562       oop archived = HeapShared::archive_reachable_objects_from(
 563           _level + 1, _subgraph_info, obj, _is_closed_archive, THREAD);
 564       assert(archived != NULL, &quot;VM should have exited with unarchivable objects for _level &gt; 1&quot;);
 565       assert(HeapShared::is_archived_object(archived), &quot;must be&quot;);
 566 
 567       if (!_record_klasses_only) {
 568         // Update the reference in the archived copy of the referencing object.
 569         log_debug(cds, heap)(&quot;(%d) updating oop @[&quot; PTR_FORMAT &quot;] &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
 570                              _level, p2i(new_p), p2i(obj), p2i(archived));
 571         RawAccess&lt;IS_NOT_NULL&gt;::oop_store(new_p, archived);
 572       }
 573     }
 574   }
 575 };
 576 
 577 void HeapShared::check_closed_archive_heap_region_object(InstanceKlass* k,
 578                                                          Thread* THREAD) {
 579   // Check fields in the object
 580   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
 581     if (!fs.access_flags().is_static()) {
 582       BasicType ft = fs.field_descriptor().field_type();
<span class="line-modified"> 583       if (!fs.access_flags().is_final() &amp;&amp; (ft == T_ARRAY || ft == T_OBJECT)) {</span>
 584         ResourceMark rm(THREAD);
 585         log_warning(cds, heap)(
 586           &quot;Please check reference field in %s instance in closed archive heap region: %s %s&quot;,
 587           k-&gt;external_name(), (fs.name())-&gt;as_C_string(),
 588           (fs.signature())-&gt;as_C_string());
 589       }
 590     }
 591   }
 592 }
 593 
 594 // (1) If orig_obj has not been archived yet, archive it.
 595 // (2) If orig_obj has not been seen yet (since start_recording_subgraph() was called),
 596 //     trace all  objects that are reachable from it, and make sure these objects are archived.
 597 // (3) Record the klasses of all orig_obj and all reachable objects.
 598 oop HeapShared::archive_reachable_objects_from(int level,
 599                                                KlassSubGraphInfo* subgraph_info,
 600                                                oop orig_obj,
 601                                                bool is_closed_archive,
 602                                                TRAPS) {
 603   assert(orig_obj != NULL, &quot;must be&quot;);
 604   assert(!is_archived_object(orig_obj), &quot;sanity&quot;);
 605 
<span class="line-modified"> 606   // java.lang.Class instances cannot be included in an archived</span>
<span class="line-modified"> 607   // object sub-graph.</span>












 608   if (java_lang_Class::is_instance(orig_obj)) {
 609     log_error(cds, heap)(&quot;(%d) Unknown java.lang.Class object is in the archived sub-graph&quot;, level);
 610     vm_exit(1);
 611   }
 612 
 613   oop archived_obj = find_archived_heap_object(orig_obj);
 614   if (java_lang_String::is_instance(orig_obj) &amp;&amp; archived_obj != NULL) {
 615     // To save time, don&#39;t walk strings that are already archived. They just contain
 616     // pointers to a type array, whose klass doesn&#39;t need to be recorded.
 617     return archived_obj;
 618   }
 619 
 620   if (has_been_seen_during_subgraph_recording(orig_obj)) {
 621     // orig_obj has already been archived and traced. Nothing more to do.
 622     return archived_obj;
 623   } else {
 624     set_has_been_seen_during_subgraph_recording(orig_obj);
 625   }
 626 
 627   bool record_klasses_only = (archived_obj != NULL);
</pre>
<hr />
<pre>
 851   delete_seen_objects_table();
 852 
 853   _num_total_subgraph_recordings ++;
 854   _num_total_walked_objs      += _num_new_walked_objs;
 855   _num_total_archived_objs    += _num_new_archived_objs;
 856   _num_total_recorded_klasses +=  num_new_recorded_klasses;
 857 }
 858 
 859 class ArchivableStaticFieldFinder: public FieldClosure {
 860   InstanceKlass* _ik;
 861   Symbol* _field_name;
 862   bool _found;
 863   int _offset;
 864 public:
 865   ArchivableStaticFieldFinder(InstanceKlass* ik, Symbol* field_name) :
 866     _ik(ik), _field_name(field_name), _found(false), _offset(-1) {}
 867 
 868   virtual void do_field(fieldDescriptor* fd) {
 869     if (fd-&gt;name() == _field_name) {
 870       assert(!_found, &quot;fields cannot be overloaded&quot;);
<span class="line-modified"> 871       assert(fd-&gt;field_type() == T_OBJECT || fd-&gt;field_type() == T_ARRAY, &quot;can archive only obj or array fields&quot;);</span>
 872       _found = true;
 873       _offset = fd-&gt;offset();
 874     }
 875   }
 876   bool found()     { return _found;  }
 877   int offset()     { return _offset; }
 878 };
 879 
 880 void HeapShared::init_subgraph_entry_fields(ArchivableStaticFieldInfo fields[],
 881                                             int num, Thread* THREAD) {
 882   for (int i = 0; i &lt; num; i++) {
 883     ArchivableStaticFieldInfo* info = &amp;fields[i];
<span class="line-modified"> 884     TempNewSymbol klass_name =  SymbolTable::new_symbol(info-&gt;klass_name, THREAD);</span>
<span class="line-modified"> 885     TempNewSymbol field_name =  SymbolTable::new_symbol(info-&gt;field_name, THREAD);</span>
 886 
 887     Klass* k = SystemDictionary::resolve_or_null(klass_name, THREAD);
 888     assert(k != NULL &amp;&amp; !HAS_PENDING_EXCEPTION, &quot;class must exist&quot;);
 889     InstanceKlass* ik = InstanceKlass::cast(k);
 890     assert(InstanceKlass::cast(ik)-&gt;is_shared_boot_class(),
 891            &quot;Only support boot classes&quot;);
 892     ik-&gt;initialize(THREAD);
 893     guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in initialize&quot;);
 894 
 895     ArchivableStaticFieldFinder finder(ik, field_name);
 896     ik-&gt;do_local_static_fields(&amp;finder);
 897     assert(finder.found(), &quot;field must exist&quot;);
 898 
 899     info-&gt;klass = ik;
 900     info-&gt;offset = finder.offset();
 901   }
 902 }
 903 
 904 void HeapShared::init_subgraph_entry_fields(Thread* THREAD) {
 905   _dump_time_subgraph_info_table = new (ResourceObj::C_HEAP, mtClass)DumpTimeKlassSubGraphInfoTable();
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/javaClasses.inline.hpp&quot;
  27 #include &quot;classfile/stringTable.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
<span class="line-added">  29 #include &quot;classfile/systemDictionaryShared.hpp&quot;</span>
  30 #include &quot;classfile/vmSymbols.hpp&quot;
  31 #include &quot;logging/log.hpp&quot;
  32 #include &quot;logging/logMessage.hpp&quot;
  33 #include &quot;logging/logStream.hpp&quot;
<span class="line-added">  34 #include &quot;memory/archiveUtils.hpp&quot;</span>
  35 #include &quot;memory/filemap.hpp&quot;
  36 #include &quot;memory/heapShared.inline.hpp&quot;
  37 #include &quot;memory/iterator.inline.hpp&quot;
  38 #include &quot;memory/metadataFactory.hpp&quot;
  39 #include &quot;memory/metaspaceClosure.hpp&quot;
<span class="line-added">  40 #include &quot;memory/metaspaceShared.hpp&quot;</span>
  41 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">  42 #include &quot;memory/universe.hpp&quot;</span>
  43 #include &quot;oops/compressedOops.inline.hpp&quot;
<span class="line-modified">  44 #include &quot;oops/fieldStreams.inline.hpp&quot;</span>
  45 #include &quot;oops/oop.inline.hpp&quot;
  46 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  47 #include &quot;runtime/safepointVerifiers.hpp&quot;
  48 #include &quot;utilities/bitMap.inline.hpp&quot;
  49 #if INCLUDE_G1GC
  50 #include &quot;gc/g1/g1CollectedHeap.hpp&quot;
  51 #endif
  52 
  53 #if INCLUDE_CDS_JAVA_HEAP
  54 
  55 bool HeapShared::_closed_archive_heap_region_mapped = false;
  56 bool HeapShared::_open_archive_heap_region_mapped = false;
  57 bool HeapShared::_archive_heap_region_fixed = false;
  58 
  59 address   HeapShared::_narrow_oop_base;
  60 int       HeapShared::_narrow_oop_shift;
  61 
  62 //
  63 // If you add new entries to the following tables, you should know what you&#39;re doing!
  64 //
  65 
  66 // Entry fields for shareable subgraphs archived in the closed archive heap
  67 // region. Warning: Objects in the subgraphs should not have reference fields
  68 // assigned at runtime.
  69 static ArchivableStaticFieldInfo closed_archive_subgraph_entry_fields[] = {
  70   {&quot;java/lang/Integer$IntegerCache&quot;,           &quot;archivedCache&quot;},
  71   {&quot;java/lang/Long$LongCache&quot;,                 &quot;archivedCache&quot;},
  72   {&quot;java/lang/Byte$ByteCache&quot;,                 &quot;archivedCache&quot;},
  73   {&quot;java/lang/Short$ShortCache&quot;,               &quot;archivedCache&quot;},
  74   {&quot;java/lang/Character$CharacterCache&quot;,       &quot;archivedCache&quot;},
<span class="line-added">  75   {&quot;java/util/jar/Attributes$Name&quot;,            &quot;KNOWN_NAMES&quot;},</span>
<span class="line-added">  76   {&quot;sun/util/locale/BaseLocale&quot;,               &quot;constantBaseLocales&quot;},</span>
  77 };
  78 // Entry fields for subgraphs archived in the open archive heap region.
  79 static ArchivableStaticFieldInfo open_archive_subgraph_entry_fields[] = {
  80   {&quot;jdk/internal/module/ArchivedModuleGraph&quot;,  &quot;archivedModuleGraph&quot;},
<span class="line-modified">  81   {&quot;java/util/ImmutableCollections&quot;,           &quot;archivedObjects&quot;},</span>


  82   {&quot;java/lang/module/Configuration&quot;,           &quot;EMPTY_CONFIGURATION&quot;},
<span class="line-added">  83   {&quot;jdk/internal/math/FDBigInteger&quot;,           &quot;archivedCaches&quot;},</span>
  84 };
  85 
  86 const static int num_closed_archive_subgraph_entry_fields =
  87   sizeof(closed_archive_subgraph_entry_fields) / sizeof(ArchivableStaticFieldInfo);
  88 const static int num_open_archive_subgraph_entry_fields =
  89   sizeof(open_archive_subgraph_entry_fields) / sizeof(ArchivableStaticFieldInfo);
  90 
  91 ////////////////////////////////////////////////////////////////
  92 //
  93 // Java heap object archiving support
  94 //
  95 ////////////////////////////////////////////////////////////////
  96 void HeapShared::fixup_mapped_heap_regions() {
  97   FileMapInfo *mapinfo = FileMapInfo::current_info();
  98   mapinfo-&gt;fixup_mapped_heap_regions();
  99   set_archive_heap_region_fixed();
 100 }
 101 
 102 unsigned HeapShared::oop_hash(oop const&amp; p) {
<span class="line-modified"> 103   assert(!p-&gt;mark().has_bias_pattern(),</span>
 104          &quot;this object should never have been locked&quot;);  // so identity_hash won&#39;t safepoin
 105   unsigned hash = (unsigned)p-&gt;identity_hash();
 106   return hash;
 107 }
 108 
 109 HeapShared::ArchivedObjectCache* HeapShared::_archived_object_cache = NULL;
 110 oop HeapShared::find_archived_heap_object(oop obj) {
 111   assert(DumpSharedSpaces, &quot;dump-time only&quot;);
 112   ArchivedObjectCache* cache = archived_object_cache();
 113   oop* p = cache-&gt;get(obj);
 114   if (p != NULL) {
 115     return *p;
 116   } else {
 117     return NULL;
 118   }
 119 }
 120 
 121 oop HeapShared::archive_heap_object(oop obj, Thread* THREAD) {
 122   assert(DumpSharedSpaces, &quot;dump-time only&quot;);
 123 
 124   oop ao = find_archived_heap_object(obj);
 125   if (ao != NULL) {
 126     // already archived
 127     return ao;
 128   }
 129 
 130   int len = obj-&gt;size();
 131   if (G1CollectedHeap::heap()-&gt;is_archive_alloc_too_large(len)) {
 132     log_debug(cds, heap)(&quot;Cannot archive, object (&quot; PTR_FORMAT &quot;) is too large: &quot; SIZE_FORMAT,
 133                          p2i(obj), (size_t)obj-&gt;size());
 134     return NULL;
 135   }
 136 
 137   // Pre-compute object identity hash at CDS dump time.
 138   obj-&gt;identity_hash();
 139 
 140   oop archived_oop = (oop)G1CollectedHeap::heap()-&gt;archive_mem_allocate(len);
 141   if (archived_oop != NULL) {
<span class="line-modified"> 142     Copy::aligned_disjoint_words(cast_from_oop&lt;HeapWord*&gt;(obj), cast_from_oop&lt;HeapWord*&gt;(archived_oop), len);</span>
 143     MetaspaceShared::relocate_klass_ptr(archived_oop);
 144     ArchivedObjectCache* cache = archived_object_cache();
 145     cache-&gt;put(obj, archived_oop);
 146     log_debug(cds, heap)(&quot;Archived heap object &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
 147                          p2i(obj), p2i(archived_oop));
 148   } else {
 149     log_error(cds, heap)(
 150       &quot;Cannot allocate space for object &quot; PTR_FORMAT &quot; in archived heap region&quot;,
 151       p2i(obj));
 152     vm_exit(1);
 153   }
 154   return archived_oop;
 155 }
 156 
 157 oop HeapShared::materialize_archived_object(narrowOop v) {
 158   assert(archive_heap_region_fixed(),
 159          &quot;must be called after archive heap regions are fixed&quot;);
 160   if (!CompressedOops::is_null(v)) {
 161     oop obj = HeapShared::decode_from_archive(v);
 162     return G1CollectedHeap::heap()-&gt;materialize_archived_object(obj);
</pre>
<hr />
<pre>
 167 void HeapShared::archive_klass_objects(Thread* THREAD) {
 168   GrowableArray&lt;Klass*&gt;* klasses = MetaspaceShared::collected_klasses();
 169   assert(klasses != NULL, &quot;sanity&quot;);
 170   for (int i = 0; i &lt; klasses-&gt;length(); i++) {
 171     Klass* k = klasses-&gt;at(i);
 172 
 173     // archive mirror object
 174     java_lang_Class::archive_mirror(k, CHECK);
 175 
 176     // archive the resolved_referenes array
 177     if (k-&gt;is_instance_klass()) {
 178       InstanceKlass* ik = InstanceKlass::cast(k);
 179       ik-&gt;constants()-&gt;archive_resolved_references(THREAD);
 180     }
 181   }
 182 }
 183 
 184 void HeapShared::archive_java_heap_objects(GrowableArray&lt;MemRegion&gt; *closed,
 185                                            GrowableArray&lt;MemRegion&gt; *open) {
 186   if (!is_heap_object_archiving_allowed()) {
<span class="line-modified"> 187     log_info(cds)(</span>
<span class="line-modified"> 188       &quot;Archived java heap is not supported as UseG1GC, &quot;</span>
<span class="line-modified"> 189       &quot;UseCompressedOops and UseCompressedClassPointers are required.&quot;</span>
<span class="line-modified"> 190       &quot;Current settings: UseG1GC=%s, UseCompressedOops=%s, UseCompressedClassPointers=%s.&quot;,</span>
<span class="line-modified"> 191       BOOL_TO_STR(UseG1GC), BOOL_TO_STR(UseCompressedOops),</span>
<span class="line-modified"> 192       BOOL_TO_STR(UseCompressedClassPointers));</span>


 193     return;
 194   }
 195 
 196   G1HeapVerifier::verify_ready_for_archiving();
 197 
 198   {
 199     NoSafepointVerifier nsv;
 200 
 201     // Cache for recording where the archived objects are copied to
 202     create_archived_object_cache();
 203 
<span class="line-modified"> 204     log_info(cds)(&quot;Dumping objects to closed archive heap region ...&quot;);</span>
 205     NOT_PRODUCT(StringTable::verify());
 206     copy_closed_archive_heap_objects(closed);
 207 
<span class="line-modified"> 208     log_info(cds)(&quot;Dumping objects to open archive heap region ...&quot;);</span>
 209     copy_open_archive_heap_objects(open);
 210 
 211     destroy_archived_object_cache();
 212   }
 213 
 214   G1HeapVerifier::verify_archive_regions();
 215 }
 216 
 217 void HeapShared::copy_closed_archive_heap_objects(
 218                                     GrowableArray&lt;MemRegion&gt; * closed_archive) {
 219   assert(is_heap_object_archiving_allowed(), &quot;Cannot archive java heap objects&quot;);
 220 
 221   Thread* THREAD = Thread::current();
 222   G1CollectedHeap::heap()-&gt;begin_archive_alloc_range();
 223 
 224   // Archive interned string objects
 225   StringTable::write_to_archive();
 226 
 227   archive_object_subgraphs(closed_archive_subgraph_entry_fields,
 228                            num_closed_archive_subgraph_entry_fields,
</pre>
<hr />
<pre>
 365     for (int i = 0 ; i &lt; num_entry_fields; i++) {
 366       _entry_field_records-&gt;at_put(i, entry_fields-&gt;at(i));
 367     }
 368   }
 369 
 370   // the Klasses of the objects in the sub-graphs
 371   GrowableArray&lt;Klass*&gt;* subgraph_object_klasses = info-&gt;subgraph_object_klasses();
 372   if (subgraph_object_klasses != NULL) {
 373     int num_subgraphs_klasses = subgraph_object_klasses-&gt;length();
 374     _subgraph_object_klasses =
 375       MetaspaceShared::new_ro_array&lt;Klass*&gt;(num_subgraphs_klasses);
 376     for (int i = 0; i &lt; num_subgraphs_klasses; i++) {
 377       Klass* subgraph_k = subgraph_object_klasses-&gt;at(i);
 378       if (log_is_enabled(Info, cds, heap)) {
 379         ResourceMark rm;
 380         log_info(cds, heap)(
 381           &quot;Archived object klass %s (%2d) =&gt; %s&quot;,
 382           _k-&gt;external_name(), i, subgraph_k-&gt;external_name());
 383       }
 384       _subgraph_object_klasses-&gt;at_put(i, subgraph_k);
<span class="line-added"> 385       ArchivePtrMarker::mark_pointer(_subgraph_object_klasses-&gt;adr_at(i));</span>
 386     }
 387   }
<span class="line-added"> 388 </span>
<span class="line-added"> 389   ArchivePtrMarker::mark_pointer(&amp;_k);</span>
<span class="line-added"> 390   ArchivePtrMarker::mark_pointer(&amp;_entry_field_records);</span>
<span class="line-added"> 391   ArchivePtrMarker::mark_pointer(&amp;_subgraph_object_klasses);</span>
 392 }
 393 
 394 struct CopyKlassSubGraphInfoToArchive : StackObj {
 395   CompactHashtableWriter* _writer;
 396   CopyKlassSubGraphInfoToArchive(CompactHashtableWriter* writer) : _writer(writer) {}
 397 
 398   bool do_entry(Klass* klass, KlassSubGraphInfo&amp; info) {
 399     if (info.subgraph_object_klasses() != NULL || info.subgraph_entry_fields() != NULL) {
 400       ArchivedKlassSubGraphInfoRecord* record =
 401         (ArchivedKlassSubGraphInfoRecord*)MetaspaceShared::read_only_space_alloc(sizeof(ArchivedKlassSubGraphInfoRecord));
 402       record-&gt;init(&amp;info);
 403 
<span class="line-modified"> 404       unsigned int hash = SystemDictionaryShared::hash_for_shared_dictionary(klass);</span>
 405       u4 delta = MetaspaceShared::object_delta_u4(record);
 406       _writer-&gt;add(hash, delta);
 407     }
 408     return true; // keep on iterating
 409   }
 410 };
 411 
 412 // Build the records of archived subgraph infos, which include:
 413 // - Entry points to all subgraphs from the containing class mirror. The entry
 414 //   points are static fields in the mirror. For each entry point, the field
 415 //   offset, value and is_closed_archive flag are recorded in the sub-graph
 416 //   info. The value is stored back to the corresponding field at runtime.
 417 // - A list of klasses that need to be loaded/initialized before archived
 418 //   java object sub-graph can be accessed at runtime.
 419 void HeapShared::write_subgraph_info_table() {
 420   // Allocate the contents of the hashtable(s) inside the RO region of the CDS archive.
 421   DumpTimeKlassSubGraphInfoTable* d_table = _dump_time_subgraph_info_table;
 422   CompactHashtableStats stats;
 423 
 424   _run_time_subgraph_info_table.reset();
 425 
<span class="line-modified"> 426   CompactHashtableWriter writer(d_table-&gt;_count, &amp;stats);</span>

 427   CopyKlassSubGraphInfoToArchive copy(&amp;writer);
 428   d_table-&gt;iterate(&amp;copy);
 429 
 430   writer.dump(&amp;_run_time_subgraph_info_table, &quot;subgraphs&quot;);
 431 }
 432 
 433 void HeapShared::serialize_subgraph_info_table_header(SerializeClosure* soc) {
 434   _run_time_subgraph_info_table.serialize_header(soc);
 435 }
 436 
 437 void HeapShared::initialize_from_archived_subgraph(Klass* k) {
 438   if (!open_archive_heap_region_mapped()) {
 439     return; // nothing to do
 440   }
 441   assert(!DumpSharedSpaces, &quot;Should not be called with DumpSharedSpaces&quot;);
 442 
<span class="line-modified"> 443   unsigned int hash = SystemDictionaryShared::hash_for_shared_dictionary(k);</span>
 444   const ArchivedKlassSubGraphInfoRecord* record = _run_time_subgraph_info_table.lookup(k, hash, 0);
 445 
 446   // Initialize from archived data. Currently this is done only
 447   // during VM initialization time. No lock is needed.
 448   if (record != NULL) {
 449     Thread* THREAD = Thread::current();
 450 
 451     int i;
 452     // Load/link/initialize the klasses of the objects in the subgraph.
 453     // NULL class loader is used.
 454     Array&lt;Klass*&gt;* klasses = record-&gt;subgraph_object_klasses();
 455     if (klasses != NULL) {
 456       for (i = 0; i &lt; klasses-&gt;length(); i++) {
 457         Klass* obj_k = klasses-&gt;at(i);
 458         Klass* resolved_k = SystemDictionary::resolve_or_null(
 459                                               (obj_k)-&gt;name(), THREAD);
 460         if (resolved_k != obj_k) {
 461           assert(!SystemDictionary::is_well_known_klass(resolved_k),
 462                  &quot;shared well-known classes must not be replaced by JVMTI ClassFileLoadHook&quot;);
 463           ResourceMark rm(THREAD);
</pre>
<hr />
<pre>
 536                            bool is_closed_archive,
 537                            bool record_klasses_only,
 538                            KlassSubGraphInfo* subgraph_info,
 539                            oop orig, oop archived, TRAPS) :
 540     _level(level), _is_closed_archive(is_closed_archive),
 541     _record_klasses_only(record_klasses_only),
 542     _subgraph_info(subgraph_info),
 543     _orig_referencing_obj(orig), _archived_referencing_obj(archived),
 544     _thread(THREAD) {}
 545   void do_oop(narrowOop *p) { WalkOopAndArchiveClosure::do_oop_work(p); }
 546   void do_oop(      oop *p) { WalkOopAndArchiveClosure::do_oop_work(p); }
 547 
 548  protected:
 549   template &lt;class T&gt; void do_oop_work(T *p) {
 550     oop obj = RawAccess&lt;&gt;::oop_load(p);
 551     if (!CompressedOops::is_null(obj)) {
 552       assert(!HeapShared::is_archived_object(obj),
 553              &quot;original objects must not point to archived objects&quot;);
 554 
 555       size_t field_delta = pointer_delta(p, _orig_referencing_obj, sizeof(char));
<span class="line-modified"> 556       T* new_p = (T*)(cast_from_oop&lt;address&gt;(_archived_referencing_obj) + field_delta);</span>
 557       Thread* THREAD = _thread;
 558 
 559       if (!_record_klasses_only &amp;&amp; log_is_enabled(Debug, cds, heap)) {
 560         ResourceMark rm;
 561         log_debug(cds, heap)(&quot;(%d) %s[&quot; SIZE_FORMAT &quot;] ==&gt; &quot; PTR_FORMAT &quot; size %d %s&quot;, _level,
 562                              _orig_referencing_obj-&gt;klass()-&gt;external_name(), field_delta,
 563                              p2i(obj), obj-&gt;size() * HeapWordSize, obj-&gt;klass()-&gt;external_name());
 564         LogTarget(Trace, cds, heap) log;
 565         LogStream out(log);
 566         obj-&gt;print_on(&amp;out);
 567       }
 568 
 569       oop archived = HeapShared::archive_reachable_objects_from(
 570           _level + 1, _subgraph_info, obj, _is_closed_archive, THREAD);
 571       assert(archived != NULL, &quot;VM should have exited with unarchivable objects for _level &gt; 1&quot;);
 572       assert(HeapShared::is_archived_object(archived), &quot;must be&quot;);
 573 
 574       if (!_record_klasses_only) {
 575         // Update the reference in the archived copy of the referencing object.
 576         log_debug(cds, heap)(&quot;(%d) updating oop @[&quot; PTR_FORMAT &quot;] &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
 577                              _level, p2i(new_p), p2i(obj), p2i(archived));
 578         RawAccess&lt;IS_NOT_NULL&gt;::oop_store(new_p, archived);
 579       }
 580     }
 581   }
 582 };
 583 
 584 void HeapShared::check_closed_archive_heap_region_object(InstanceKlass* k,
 585                                                          Thread* THREAD) {
 586   // Check fields in the object
 587   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
 588     if (!fs.access_flags().is_static()) {
 589       BasicType ft = fs.field_descriptor().field_type();
<span class="line-modified"> 590       if (!fs.access_flags().is_final() &amp;&amp; is_reference_type(ft)) {</span>
 591         ResourceMark rm(THREAD);
 592         log_warning(cds, heap)(
 593           &quot;Please check reference field in %s instance in closed archive heap region: %s %s&quot;,
 594           k-&gt;external_name(), (fs.name())-&gt;as_C_string(),
 595           (fs.signature())-&gt;as_C_string());
 596       }
 597     }
 598   }
 599 }
 600 
 601 // (1) If orig_obj has not been archived yet, archive it.
 602 // (2) If orig_obj has not been seen yet (since start_recording_subgraph() was called),
 603 //     trace all  objects that are reachable from it, and make sure these objects are archived.
 604 // (3) Record the klasses of all orig_obj and all reachable objects.
 605 oop HeapShared::archive_reachable_objects_from(int level,
 606                                                KlassSubGraphInfo* subgraph_info,
 607                                                oop orig_obj,
 608                                                bool is_closed_archive,
 609                                                TRAPS) {
 610   assert(orig_obj != NULL, &quot;must be&quot;);
 611   assert(!is_archived_object(orig_obj), &quot;sanity&quot;);
 612 
<span class="line-modified"> 613   if (!JavaClasses::is_supported_for_archiving(orig_obj)) {</span>
<span class="line-modified"> 614     // This object has injected fields that cannot be supported easily, so we disallow them for now.</span>
<span class="line-added"> 615     // If you get an error here, you probably made a change in the JDK library that has added</span>
<span class="line-added"> 616     // these objects that are referenced (directly or indirectly) by static fields.</span>
<span class="line-added"> 617     ResourceMark rm;</span>
<span class="line-added"> 618     log_error(cds, heap)(&quot;Cannot archive object of class %s&quot;, orig_obj-&gt;klass()-&gt;external_name());</span>
<span class="line-added"> 619     vm_exit(1);</span>
<span class="line-added"> 620   }</span>
<span class="line-added"> 621 </span>
<span class="line-added"> 622   // java.lang.Class instances cannot be included in an archived object sub-graph. We only support</span>
<span class="line-added"> 623   // them as Klass::_archived_mirror because they need to be specially restored at run time.</span>
<span class="line-added"> 624   //</span>
<span class="line-added"> 625   // If you get an error here, you probably made a change in the JDK library that has added a Class</span>
<span class="line-added"> 626   // object that is referenced (directly or indirectly) by static fields.</span>
 627   if (java_lang_Class::is_instance(orig_obj)) {
 628     log_error(cds, heap)(&quot;(%d) Unknown java.lang.Class object is in the archived sub-graph&quot;, level);
 629     vm_exit(1);
 630   }
 631 
 632   oop archived_obj = find_archived_heap_object(orig_obj);
 633   if (java_lang_String::is_instance(orig_obj) &amp;&amp; archived_obj != NULL) {
 634     // To save time, don&#39;t walk strings that are already archived. They just contain
 635     // pointers to a type array, whose klass doesn&#39;t need to be recorded.
 636     return archived_obj;
 637   }
 638 
 639   if (has_been_seen_during_subgraph_recording(orig_obj)) {
 640     // orig_obj has already been archived and traced. Nothing more to do.
 641     return archived_obj;
 642   } else {
 643     set_has_been_seen_during_subgraph_recording(orig_obj);
 644   }
 645 
 646   bool record_klasses_only = (archived_obj != NULL);
</pre>
<hr />
<pre>
 870   delete_seen_objects_table();
 871 
 872   _num_total_subgraph_recordings ++;
 873   _num_total_walked_objs      += _num_new_walked_objs;
 874   _num_total_archived_objs    += _num_new_archived_objs;
 875   _num_total_recorded_klasses +=  num_new_recorded_klasses;
 876 }
 877 
 878 class ArchivableStaticFieldFinder: public FieldClosure {
 879   InstanceKlass* _ik;
 880   Symbol* _field_name;
 881   bool _found;
 882   int _offset;
 883 public:
 884   ArchivableStaticFieldFinder(InstanceKlass* ik, Symbol* field_name) :
 885     _ik(ik), _field_name(field_name), _found(false), _offset(-1) {}
 886 
 887   virtual void do_field(fieldDescriptor* fd) {
 888     if (fd-&gt;name() == _field_name) {
 889       assert(!_found, &quot;fields cannot be overloaded&quot;);
<span class="line-modified"> 890       assert(is_reference_type(fd-&gt;field_type()), &quot;can archive only fields that are references&quot;);</span>
 891       _found = true;
 892       _offset = fd-&gt;offset();
 893     }
 894   }
 895   bool found()     { return _found;  }
 896   int offset()     { return _offset; }
 897 };
 898 
 899 void HeapShared::init_subgraph_entry_fields(ArchivableStaticFieldInfo fields[],
 900                                             int num, Thread* THREAD) {
 901   for (int i = 0; i &lt; num; i++) {
 902     ArchivableStaticFieldInfo* info = &amp;fields[i];
<span class="line-modified"> 903     TempNewSymbol klass_name =  SymbolTable::new_symbol(info-&gt;klass_name);</span>
<span class="line-modified"> 904     TempNewSymbol field_name =  SymbolTable::new_symbol(info-&gt;field_name);</span>
 905 
 906     Klass* k = SystemDictionary::resolve_or_null(klass_name, THREAD);
 907     assert(k != NULL &amp;&amp; !HAS_PENDING_EXCEPTION, &quot;class must exist&quot;);
 908     InstanceKlass* ik = InstanceKlass::cast(k);
 909     assert(InstanceKlass::cast(ik)-&gt;is_shared_boot_class(),
 910            &quot;Only support boot classes&quot;);
 911     ik-&gt;initialize(THREAD);
 912     guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in initialize&quot;);
 913 
 914     ArchivableStaticFieldFinder finder(ik, field_name);
 915     ik-&gt;do_local_static_fields(&amp;finder);
 916     assert(finder.found(), &quot;field must exist&quot;);
 917 
 918     info-&gt;klass = ik;
 919     info-&gt;offset = finder.offset();
 920   }
 921 }
 922 
 923 void HeapShared::init_subgraph_entry_fields(Thread* THREAD) {
 924   _dump_time_subgraph_info_table = new (ResourceObj::C_HEAP, mtClass)DumpTimeKlassSubGraphInfoTable();
</pre>
</td>
</tr>
</table>
<center><a href="heapInspection.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="heapShared.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
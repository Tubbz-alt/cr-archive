<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/memory/heapShared.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="heapInspection.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="heapShared.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/heapShared.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -24,22 +24,26 @@</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;classfile/javaClasses.inline.hpp&quot;
  #include &quot;classfile/stringTable.hpp&quot;
  #include &quot;classfile/symbolTable.hpp&quot;
<span class="udiff-line-added">+ #include &quot;classfile/systemDictionaryShared.hpp&quot;</span>
  #include &quot;classfile/vmSymbols.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logMessage.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/archiveUtils.hpp&quot;</span>
  #include &quot;memory/filemap.hpp&quot;
  #include &quot;memory/heapShared.inline.hpp&quot;
  #include &quot;memory/iterator.inline.hpp&quot;
  #include &quot;memory/metadataFactory.hpp&quot;
  #include &quot;memory/metaspaceClosure.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/metaspaceShared.hpp&quot;</span>
  #include &quot;memory/resourceArea.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/compressedOops.inline.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;oops/fieldStreams.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;oops/fieldStreams.inline.hpp&quot;</span>
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  #include &quot;runtime/safepointVerifiers.hpp&quot;
  #include &quot;utilities/bitMap.inline.hpp&quot;
  #if INCLUDE_G1GC
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -66,18 +70,19 @@</span>
    {&quot;java/lang/Integer$IntegerCache&quot;,           &quot;archivedCache&quot;},
    {&quot;java/lang/Long$LongCache&quot;,                 &quot;archivedCache&quot;},
    {&quot;java/lang/Byte$ByteCache&quot;,                 &quot;archivedCache&quot;},
    {&quot;java/lang/Short$ShortCache&quot;,               &quot;archivedCache&quot;},
    {&quot;java/lang/Character$CharacterCache&quot;,       &quot;archivedCache&quot;},
<span class="udiff-line-added">+   {&quot;java/util/jar/Attributes$Name&quot;,            &quot;KNOWN_NAMES&quot;},</span>
<span class="udiff-line-added">+   {&quot;sun/util/locale/BaseLocale&quot;,               &quot;constantBaseLocales&quot;},</span>
  };
  // Entry fields for subgraphs archived in the open archive heap region.
  static ArchivableStaticFieldInfo open_archive_subgraph_entry_fields[] = {
    {&quot;jdk/internal/module/ArchivedModuleGraph&quot;,  &quot;archivedModuleGraph&quot;},
<span class="udiff-line-modified-removed">-   {&quot;java/util/ImmutableCollections$ListN&quot;,     &quot;EMPTY_LIST&quot;},</span>
<span class="udiff-line-removed">-   {&quot;java/util/ImmutableCollections$MapN&quot;,      &quot;EMPTY_MAP&quot;},</span>
<span class="udiff-line-removed">-   {&quot;java/util/ImmutableCollections$SetN&quot;,      &quot;EMPTY_SET&quot;},</span>
<span class="udiff-line-modified-added">+   {&quot;java/util/ImmutableCollections&quot;,           &quot;archivedObjects&quot;},</span>
    {&quot;java/lang/module/Configuration&quot;,           &quot;EMPTY_CONFIGURATION&quot;},
<span class="udiff-line-added">+   {&quot;jdk/internal/math/FDBigInteger&quot;,           &quot;archivedCaches&quot;},</span>
  };
  
  const static int num_closed_archive_subgraph_entry_fields =
    sizeof(closed_archive_subgraph_entry_fields) / sizeof(ArchivableStaticFieldInfo);
  const static int num_open_archive_subgraph_entry_fields =
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -93,11 +98,11 @@</span>
    mapinfo-&gt;fixup_mapped_heap_regions();
    set_archive_heap_region_fixed();
  }
  
  unsigned HeapShared::oop_hash(oop const&amp; p) {
<span class="udiff-line-modified-removed">-   assert(!p-&gt;mark()-&gt;has_bias_pattern(),</span>
<span class="udiff-line-modified-added">+   assert(!p-&gt;mark().has_bias_pattern(),</span>
           &quot;this object should never have been locked&quot;);  // so identity_hash won&#39;t safepoin
    unsigned hash = (unsigned)p-&gt;identity_hash();
    return hash;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -132,11 +137,11 @@</span>
    // Pre-compute object identity hash at CDS dump time.
    obj-&gt;identity_hash();
  
    oop archived_oop = (oop)G1CollectedHeap::heap()-&gt;archive_mem_allocate(len);
    if (archived_oop != NULL) {
<span class="udiff-line-modified-removed">-     Copy::aligned_disjoint_words((HeapWord*)obj, (HeapWord*)archived_oop, len);</span>
<span class="udiff-line-modified-added">+     Copy::aligned_disjoint_words(cast_from_oop&lt;HeapWord*&gt;(obj), cast_from_oop&lt;HeapWord*&gt;(archived_oop), len);</span>
      MetaspaceShared::relocate_klass_ptr(archived_oop);
      ArchivedObjectCache* cache = archived_object_cache();
      cache-&gt;put(obj, archived_oop);
      log_debug(cds, heap)(&quot;Archived heap object &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
                           p2i(obj), p2i(archived_oop));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -177,18 +182,16 @@</span>
  }
  
  void HeapShared::archive_java_heap_objects(GrowableArray&lt;MemRegion&gt; *closed,
                                             GrowableArray&lt;MemRegion&gt; *open) {
    if (!is_heap_object_archiving_allowed()) {
<span class="udiff-line-modified-removed">-     if (log_is_enabled(Info, cds)) {</span>
<span class="udiff-line-modified-removed">-       log_info(cds)(</span>
<span class="udiff-line-modified-removed">-         &quot;Archived java heap is not supported as UseG1GC, &quot;</span>
<span class="udiff-line-modified-removed">-         &quot;UseCompressedOops and UseCompressedClassPointers are required.&quot;</span>
<span class="udiff-line-modified-removed">-         &quot;Current settings: UseG1GC=%s, UseCompressedOops=%s, UseCompressedClassPointers=%s.&quot;,</span>
<span class="udiff-line-modified-removed">-         BOOL_TO_STR(UseG1GC), BOOL_TO_STR(UseCompressedOops),</span>
<span class="udiff-line-removed">-         BOOL_TO_STR(UseCompressedClassPointers));</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     log_info(cds)(</span>
<span class="udiff-line-modified-added">+       &quot;Archived java heap is not supported as UseG1GC, &quot;</span>
<span class="udiff-line-modified-added">+       &quot;UseCompressedOops and UseCompressedClassPointers are required.&quot;</span>
<span class="udiff-line-modified-added">+       &quot;Current settings: UseG1GC=%s, UseCompressedOops=%s, UseCompressedClassPointers=%s.&quot;,</span>
<span class="udiff-line-modified-added">+       BOOL_TO_STR(UseG1GC), BOOL_TO_STR(UseCompressedOops),</span>
<span class="udiff-line-modified-added">+       BOOL_TO_STR(UseCompressedClassPointers));</span>
      return;
    }
  
    G1HeapVerifier::verify_ready_for_archiving();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -196,15 +199,15 @@</span>
      NoSafepointVerifier nsv;
  
      // Cache for recording where the archived objects are copied to
      create_archived_object_cache();
  
<span class="udiff-line-modified-removed">-     tty-&gt;print_cr(&quot;Dumping objects to closed archive heap region ...&quot;);</span>
<span class="udiff-line-modified-added">+     log_info(cds)(&quot;Dumping objects to closed archive heap region ...&quot;);</span>
      NOT_PRODUCT(StringTable::verify());
      copy_closed_archive_heap_objects(closed);
  
<span class="udiff-line-modified-removed">-     tty-&gt;print_cr(&quot;Dumping objects to open archive heap region ...&quot;);</span>
<span class="udiff-line-modified-added">+     log_info(cds)(&quot;Dumping objects to open archive heap region ...&quot;);</span>
      copy_open_archive_heap_objects(open);
  
      destroy_archived_object_cache();
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -377,12 +380,17 @@</span>
          log_info(cds, heap)(
            &quot;Archived object klass %s (%2d) =&gt; %s&quot;,
            _k-&gt;external_name(), i, subgraph_k-&gt;external_name());
        }
        _subgraph_object_klasses-&gt;at_put(i, subgraph_k);
<span class="udiff-line-added">+       ArchivePtrMarker::mark_pointer(_subgraph_object_klasses-&gt;adr_at(i));</span>
      }
    }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ArchivePtrMarker::mark_pointer(&amp;_k);</span>
<span class="udiff-line-added">+   ArchivePtrMarker::mark_pointer(&amp;_entry_field_records);</span>
<span class="udiff-line-added">+   ArchivePtrMarker::mark_pointer(&amp;_subgraph_object_klasses);</span>
  }
  
  struct CopyKlassSubGraphInfoToArchive : StackObj {
    CompactHashtableWriter* _writer;
    CopyKlassSubGraphInfoToArchive(CompactHashtableWriter* writer) : _writer(writer) {}
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -391,11 +399,11 @@</span>
      if (info.subgraph_object_klasses() != NULL || info.subgraph_entry_fields() != NULL) {
        ArchivedKlassSubGraphInfoRecord* record =
          (ArchivedKlassSubGraphInfoRecord*)MetaspaceShared::read_only_space_alloc(sizeof(ArchivedKlassSubGraphInfoRecord));
        record-&gt;init(&amp;info);
  
<span class="udiff-line-modified-removed">-       unsigned int hash = primitive_hash&lt;Klass*&gt;(klass);</span>
<span class="udiff-line-modified-added">+       unsigned int hash = SystemDictionaryShared::hash_for_shared_dictionary(klass);</span>
        u4 delta = MetaspaceShared::object_delta_u4(record);
        _writer-&gt;add(hash, delta);
      }
      return true; // keep on iterating
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -413,12 +421,11 @@</span>
    DumpTimeKlassSubGraphInfoTable* d_table = _dump_time_subgraph_info_table;
    CompactHashtableStats stats;
  
    _run_time_subgraph_info_table.reset();
  
<span class="udiff-line-modified-removed">-   int num_buckets = CompactHashtableWriter::default_num_buckets(d_table-&gt;_count);</span>
<span class="udiff-line-removed">-   CompactHashtableWriter writer(num_buckets, &amp;stats);</span>
<span class="udiff-line-modified-added">+   CompactHashtableWriter writer(d_table-&gt;_count, &amp;stats);</span>
    CopyKlassSubGraphInfoToArchive copy(&amp;writer);
    d_table-&gt;iterate(&amp;copy);
  
    writer.dump(&amp;_run_time_subgraph_info_table, &quot;subgraphs&quot;);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -431,11 +438,11 @@</span>
    if (!open_archive_heap_region_mapped()) {
      return; // nothing to do
    }
    assert(!DumpSharedSpaces, &quot;Should not be called with DumpSharedSpaces&quot;);
  
<span class="udiff-line-modified-removed">-   unsigned int hash = primitive_hash&lt;Klass*&gt;(k);</span>
<span class="udiff-line-modified-added">+   unsigned int hash = SystemDictionaryShared::hash_for_shared_dictionary(k);</span>
    const ArchivedKlassSubGraphInfoRecord* record = _run_time_subgraph_info_table.lookup(k, hash, 0);
  
    // Initialize from archived data. Currently this is done only
    // during VM initialization time. No lock is needed.
    if (record != NULL) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -544,11 +551,11 @@</span>
      if (!CompressedOops::is_null(obj)) {
        assert(!HeapShared::is_archived_object(obj),
               &quot;original objects must not point to archived objects&quot;);
  
        size_t field_delta = pointer_delta(p, _orig_referencing_obj, sizeof(char));
<span class="udiff-line-modified-removed">-       T* new_p = (T*)(address(_archived_referencing_obj) + field_delta);</span>
<span class="udiff-line-modified-added">+       T* new_p = (T*)(cast_from_oop&lt;address&gt;(_archived_referencing_obj) + field_delta);</span>
        Thread* THREAD = _thread;
  
        if (!_record_klasses_only &amp;&amp; log_is_enabled(Debug, cds, heap)) {
          ResourceMark rm;
          log_debug(cds, heap)(&quot;(%d) %s[&quot; SIZE_FORMAT &quot;] ==&gt; &quot; PTR_FORMAT &quot; size %d %s&quot;, _level,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -578,11 +585,11 @@</span>
                                                           Thread* THREAD) {
    // Check fields in the object
    for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
      if (!fs.access_flags().is_static()) {
        BasicType ft = fs.field_descriptor().field_type();
<span class="udiff-line-modified-removed">-       if (!fs.access_flags().is_final() &amp;&amp; (ft == T_ARRAY || ft == T_OBJECT)) {</span>
<span class="udiff-line-modified-added">+       if (!fs.access_flags().is_final() &amp;&amp; is_reference_type(ft)) {</span>
          ResourceMark rm(THREAD);
          log_warning(cds, heap)(
            &quot;Please check reference field in %s instance in closed archive heap region: %s %s&quot;,
            k-&gt;external_name(), (fs.name())-&gt;as_C_string(),
            (fs.signature())-&gt;as_C_string());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -601,12 +608,24 @@</span>
                                                 bool is_closed_archive,
                                                 TRAPS) {
    assert(orig_obj != NULL, &quot;must be&quot;);
    assert(!is_archived_object(orig_obj), &quot;sanity&quot;);
  
<span class="udiff-line-modified-removed">-   // java.lang.Class instances cannot be included in an archived</span>
<span class="udiff-line-modified-removed">-   // object sub-graph.</span>
<span class="udiff-line-modified-added">+   if (!JavaClasses::is_supported_for_archiving(orig_obj)) {</span>
<span class="udiff-line-modified-added">+     // This object has injected fields that cannot be supported easily, so we disallow them for now.</span>
<span class="udiff-line-added">+     // If you get an error here, you probably made a change in the JDK library that has added</span>
<span class="udiff-line-added">+     // these objects that are referenced (directly or indirectly) by static fields.</span>
<span class="udiff-line-added">+     ResourceMark rm;</span>
<span class="udiff-line-added">+     log_error(cds, heap)(&quot;Cannot archive object of class %s&quot;, orig_obj-&gt;klass()-&gt;external_name());</span>
<span class="udiff-line-added">+     vm_exit(1);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // java.lang.Class instances cannot be included in an archived object sub-graph. We only support</span>
<span class="udiff-line-added">+   // them as Klass::_archived_mirror because they need to be specially restored at run time.</span>
<span class="udiff-line-added">+   //</span>
<span class="udiff-line-added">+   // If you get an error here, you probably made a change in the JDK library that has added a Class</span>
<span class="udiff-line-added">+   // object that is referenced (directly or indirectly) by static fields.</span>
    if (java_lang_Class::is_instance(orig_obj)) {
      log_error(cds, heap)(&quot;(%d) Unknown java.lang.Class object is in the archived sub-graph&quot;, level);
      vm_exit(1);
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -866,11 +885,11 @@</span>
      _ik(ik), _field_name(field_name), _found(false), _offset(-1) {}
  
    virtual void do_field(fieldDescriptor* fd) {
      if (fd-&gt;name() == _field_name) {
        assert(!_found, &quot;fields cannot be overloaded&quot;);
<span class="udiff-line-modified-removed">-       assert(fd-&gt;field_type() == T_OBJECT || fd-&gt;field_type() == T_ARRAY, &quot;can archive only obj or array fields&quot;);</span>
<span class="udiff-line-modified-added">+       assert(is_reference_type(fd-&gt;field_type()), &quot;can archive only fields that are references&quot;);</span>
        _found = true;
        _offset = fd-&gt;offset();
      }
    }
    bool found()     { return _found;  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -879,12 +898,12 @@</span>
  
  void HeapShared::init_subgraph_entry_fields(ArchivableStaticFieldInfo fields[],
                                              int num, Thread* THREAD) {
    for (int i = 0; i &lt; num; i++) {
      ArchivableStaticFieldInfo* info = &amp;fields[i];
<span class="udiff-line-modified-removed">-     TempNewSymbol klass_name =  SymbolTable::new_symbol(info-&gt;klass_name, THREAD);</span>
<span class="udiff-line-modified-removed">-     TempNewSymbol field_name =  SymbolTable::new_symbol(info-&gt;field_name, THREAD);</span>
<span class="udiff-line-modified-added">+     TempNewSymbol klass_name =  SymbolTable::new_symbol(info-&gt;klass_name);</span>
<span class="udiff-line-modified-added">+     TempNewSymbol field_name =  SymbolTable::new_symbol(info-&gt;field_name);</span>
  
      Klass* k = SystemDictionary::resolve_or_null(klass_name, THREAD);
      assert(k != NULL &amp;&amp; !HAS_PENDING_EXCEPTION, &quot;class must exist&quot;);
      InstanceKlass* ik = InstanceKlass::cast(k);
      assert(InstanceKlass::cast(ik)-&gt;is_shared_boot_class(),
</pre>
<center><a href="heapInspection.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="heapShared.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
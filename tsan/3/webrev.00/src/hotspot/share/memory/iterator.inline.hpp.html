<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/memory/iterator.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_MEMORY_ITERATOR_INLINE_HPP
 26 #define SHARE_MEMORY_ITERATOR_INLINE_HPP
 27 
 28 #include &quot;classfile/classLoaderData.hpp&quot;
 29 #include &quot;memory/iterator.hpp&quot;
 30 #include &quot;memory/universe.hpp&quot;
 31 #include &quot;oops/access.inline.hpp&quot;
 32 #include &quot;oops/compressedOops.inline.hpp&quot;
 33 #include &quot;oops/klass.hpp&quot;
 34 #include &quot;oops/instanceKlass.inline.hpp&quot;
 35 #include &quot;oops/instanceMirrorKlass.inline.hpp&quot;
 36 #include &quot;oops/instanceClassLoaderKlass.inline.hpp&quot;
 37 #include &quot;oops/instanceRefKlass.inline.hpp&quot;
 38 #include &quot;oops/objArrayKlass.inline.hpp&quot;
 39 #include &quot;oops/typeArrayKlass.inline.hpp&quot;
 40 #include &quot;utilities/debug.hpp&quot;
 41 
 42 // Defaults to strong claiming.
 43 inline MetadataVisitingOopIterateClosure::MetadataVisitingOopIterateClosure(ReferenceDiscoverer* rd) :
 44     ClaimMetadataVisitingOopIterateClosure(ClassLoaderData::_claim_strong, rd) {}
 45 
 46 inline void ClaimMetadataVisitingOopIterateClosure::do_cld(ClassLoaderData* cld) {
 47   cld-&gt;oops_do(this, _claim);
 48 }
 49 
 50 inline void ClaimMetadataVisitingOopIterateClosure::do_klass(Klass* k) {
 51   ClassLoaderData* cld = k-&gt;class_loader_data();
 52   ClaimMetadataVisitingOopIterateClosure::do_cld(cld);
 53 }
 54 
 55 #ifdef ASSERT
 56 // This verification is applied to all visited oops.
 57 // The closures can turn is off by overriding should_verify_oops().
 58 template &lt;typename T&gt;
 59 void OopIterateClosure::verify(T* p) {
 60   if (should_verify_oops()) {
 61     T heap_oop = RawAccess&lt;&gt;::oop_load(p);
 62     if (!CompressedOops::is_null(heap_oop)) {
 63       oop o = CompressedOops::decode_not_null(heap_oop);
 64       assert(Universe::heap()-&gt;is_in(o),
 65              &quot;should be in closed *p &quot; PTR_FORMAT &quot; &quot; PTR_FORMAT, p2i(p), p2i(o));
 66     }
 67   }
 68 }
 69 #endif
 70 
 71 // Implementation of the non-virtual do_oop dispatch.
 72 //
 73 // The same implementation is used for do_metadata, do_klass, and do_cld.
 74 //
 75 // Preconditions:
 76 //  - Base has a pure virtual do_oop
 77 //  - Only one of the classes in the inheritance chain from OopClosureType to
 78 //    Base implements do_oop.
 79 //
 80 // Given the preconditions:
 81 //  - If &amp;OopClosureType::do_oop is resolved to &amp;Base::do_oop, then there is no
 82 //    implementation of do_oop between Base and OopClosureType. However, there
 83 //    must be one implementation in one of the subclasses of OopClosureType.
 84 //    In this case we take the virtual call.
 85 //
 86 //  - Conversely, if &amp;OopClosureType::do_oop is not resolved to &amp;Base::do_oop,
 87 //    then we&#39;ve found the one and only concrete implementation. In this case we
 88 //    take a non-virtual call.
 89 //
 90 // Because of this it&#39;s clear when we should call the virtual call and
 91 //   when the non-virtual call should be made.
 92 //
 93 // The way we find if &amp;OopClosureType::do_oop is resolved to &amp;Base::do_oop is to
 94 //   check if the resulting type of the class of a member-function pointer to
 95 //   &amp;OopClosureType::do_oop is equal to the type of the class of a
 96 //   &amp;Base::do_oop member-function pointer. Template parameter deduction is used
 97 //   to find these types, and then the IsSame trait is used to check if they are
 98 //   equal. Finally, SFINAE is used to select the appropriate implementation.
 99 //
100 // Template parameters:
101 //   T              - narrowOop or oop
102 //   Receiver       - the resolved type of the class of the
103 //                    &amp;OopClosureType::do_oop member-function pointer. That is,
104 //                    the klass with the do_oop member function.
105 //   Base           - klass with the pure virtual do_oop member function.
106 //   OopClosureType - The dynamic closure type
107 //
108 // Parameters:
109 //   closure - The closure to call
110 //   p       - The oop (or narrowOop) field to pass to the closure
111 
112 template &lt;typename T, typename Receiver, typename Base, typename OopClosureType&gt;
113 static typename EnableIf&lt;IsSame&lt;Receiver, Base&gt;::value, void&gt;::type
114 call_do_oop(void (Receiver::*)(T*), void (Base::*)(T*), OopClosureType* closure, T* p) {
115   closure-&gt;do_oop(p);
116 }
117 
118 template &lt;typename T, typename Receiver, typename Base, typename OopClosureType&gt;
119 static typename EnableIf&lt;!IsSame&lt;Receiver, Base&gt;::value, void&gt;::type
120 call_do_oop(void (Receiver::*)(T*), void (Base::*)(T*), OopClosureType* closure, T* p) {
121   // Sanity check
122   STATIC_ASSERT((!IsSame&lt;OopClosureType, OopIterateClosure&gt;::value));
123   closure-&gt;OopClosureType::do_oop(p);
124 }
125 
126 template &lt;typename OopClosureType, typename T&gt;
127 inline void Devirtualizer::do_oop_no_verify(OopClosureType* closure, T* p) {
128   call_do_oop&lt;T&gt;(&amp;OopClosureType::do_oop, &amp;OopClosure::do_oop, closure, p);
129 }
130 
131 template &lt;typename OopClosureType, typename T&gt;
132 inline void Devirtualizer::do_oop(OopClosureType* closure, T* p) {
133   debug_only(closure-&gt;verify(p));
134 
135   do_oop_no_verify(closure, p);
136 }
137 
138 // Implementation of the non-virtual do_metadata dispatch.
139 
140 template &lt;typename Receiver, typename Base, typename OopClosureType&gt;
141 static typename EnableIf&lt;IsSame&lt;Receiver, Base&gt;::value, bool&gt;::type
142 call_do_metadata(bool (Receiver::*)(), bool (Base::*)(), OopClosureType* closure) {
143   return closure-&gt;do_metadata();
144 }
145 
146 template &lt;typename Receiver, typename Base, typename OopClosureType&gt;
147 static typename EnableIf&lt;!IsSame&lt;Receiver, Base&gt;::value, bool&gt;::type
148 call_do_metadata(bool (Receiver::*)(), bool (Base::*)(), OopClosureType* closure) {
149   return closure-&gt;OopClosureType::do_metadata();
150 }
151 
152 template &lt;typename OopClosureType&gt;
153 inline bool Devirtualizer::do_metadata(OopClosureType* closure) {
154   return call_do_metadata(&amp;OopClosureType::do_metadata, &amp;OopIterateClosure::do_metadata, closure);
155 }
156 
157 // Implementation of the non-virtual do_klass dispatch.
158 
159 template &lt;typename Receiver, typename Base, typename OopClosureType&gt;
160 static typename EnableIf&lt;IsSame&lt;Receiver, Base&gt;::value, void&gt;::type
161 call_do_klass(void (Receiver::*)(Klass*), void (Base::*)(Klass*), OopClosureType* closure, Klass* k) {
162   closure-&gt;do_klass(k);
163 }
164 
165 template &lt;typename Receiver, typename Base, typename OopClosureType&gt;
166 static typename EnableIf&lt;!IsSame&lt;Receiver, Base&gt;::value, void&gt;::type
167 call_do_klass(void (Receiver::*)(Klass*), void (Base::*)(Klass*), OopClosureType* closure, Klass* k) {
168   closure-&gt;OopClosureType::do_klass(k);
169 }
170 
171 template &lt;typename OopClosureType&gt;
172 inline void Devirtualizer::do_klass(OopClosureType* closure, Klass* k) {
173   call_do_klass(&amp;OopClosureType::do_klass, &amp;OopIterateClosure::do_klass, closure, k);
174 }
175 
176 // Implementation of the non-virtual do_cld dispatch.
177 
178 template &lt;typename Receiver, typename Base, typename OopClosureType&gt;
179 static typename EnableIf&lt;IsSame&lt;Receiver, Base&gt;::value, void&gt;::type
180 call_do_cld(void (Receiver::*)(ClassLoaderData*), void (Base::*)(ClassLoaderData*), OopClosureType* closure, ClassLoaderData* cld) {
181   closure-&gt;do_cld(cld);
182 }
183 
184 template &lt;typename Receiver, typename Base, typename OopClosureType&gt;
185 static typename EnableIf&lt;!IsSame&lt;Receiver, Base&gt;::value, void&gt;::type
186 call_do_cld(void (Receiver::*)(ClassLoaderData*), void (Base::*)(ClassLoaderData*), OopClosureType* closure, ClassLoaderData* cld) {
187   closure-&gt;OopClosureType::do_cld(cld);
188 }
189 
190 template &lt;typename OopClosureType&gt;
191 void Devirtualizer::do_cld(OopClosureType* closure, ClassLoaderData* cld) {
192   call_do_cld(&amp;OopClosureType::do_cld, &amp;OopIterateClosure::do_cld, closure, cld);
193 }
194 
195 // Dispatch table implementation for *Klass::oop_oop_iterate
196 //
197 // It allows for a single call to do a multi-dispatch to an optimized version
198 //   of oop_oop_iterate that statically know all these types:
199 //   - OopClosureType    : static type give at call site
200 //   - Klass*            : dynamic to static type through Klass::id() -&gt; table index
201 //   - UseCompressedOops : dynamic to static value determined once
202 //
203 // when users call obj-&gt;oop_iterate(&amp;cl).
204 //
205 // oopDesc::oop_iterate() calls OopOopIterateDispatch::function(klass)(cl, obj, klass),
206 //   which dispatches to an optimized version of
207 //   [Instance, ObjArry, etc]Klass::oop_oop_iterate(oop, OopClosureType)
208 //
209 // OopClosureType :
210 //   If OopClosureType has an implementation of do_oop (and do_metadata et.al.),
211 //   then the static type of OopClosureType will be used to allow inlining of
212 //   do_oop (even though do_oop is virtual). Otherwise, a virtual call will be
213 //   used when calling do_oop.
214 //
215 // Klass* :
216 //   A table mapping from *Klass::ID to function is setup. This happens once
217 //   when the program starts, when the static _table instance is initialized for
218 //   the OopOopIterateDispatch specialized with the OopClosureType.
219 //
220 // UseCompressedOops :
221 //   Initially the table is populated with an init function, and not the actual
222 //   oop_oop_iterate function. This is done, so that the first time we dispatch
223 //   through the init function we check what the value of UseCompressedOops
224 //   became, and use that to determine if we should install an optimized
225 //   narrowOop version or optimized oop version of oop_oop_iterate. The appropriate
226 //   oop_oop_iterate function replaces the init function in the table, and
227 //   succeeding calls will jump directly to oop_oop_iterate.
228 
229 
230 template &lt;typename OopClosureType&gt;
231 class OopOopIterateDispatch : public AllStatic {
232 private:
233   class Table {
234   private:
235     template &lt;typename KlassType, typename T&gt;
236     static void oop_oop_iterate(OopClosureType* cl, oop obj, Klass* k) {
237       ((KlassType*)k)-&gt;KlassType::template oop_oop_iterate&lt;T&gt;(obj, cl);
238     }
239 
240     template &lt;typename KlassType&gt;
241     static void init(OopClosureType* cl, oop obj, Klass* k) {
242       OopOopIterateDispatch&lt;OopClosureType&gt;::_table.set_resolve_function_and_execute&lt;KlassType&gt;(cl, obj, k);
243     }
244 
245     template &lt;typename KlassType&gt;
246     void set_init_function() {
247       _function[KlassType::ID] = &amp;init&lt;KlassType&gt;;
248     }
249 
250     template &lt;typename KlassType&gt;
251     void set_resolve_function() {
252       // Size requirement to prevent word tearing
253       // when functions pointers are updated.
254       STATIC_ASSERT(sizeof(_function[0]) == sizeof(void*));
255       if (UseCompressedOops) {
256         _function[KlassType::ID] = &amp;oop_oop_iterate&lt;KlassType, narrowOop&gt;;
257       } else {
258         _function[KlassType::ID] = &amp;oop_oop_iterate&lt;KlassType, oop&gt;;
259       }
260     }
261 
262     template &lt;typename KlassType&gt;
263     void set_resolve_function_and_execute(OopClosureType* cl, oop obj, Klass* k) {
264       set_resolve_function&lt;KlassType&gt;();
265       _function[KlassType::ID](cl, obj, k);
266     }
267 
268   public:
269     void (*_function[KLASS_ID_COUNT])(OopClosureType*, oop, Klass*);
270 
271     Table(){
272       set_init_function&lt;InstanceKlass&gt;();
273       set_init_function&lt;InstanceRefKlass&gt;();
274       set_init_function&lt;InstanceMirrorKlass&gt;();
275       set_init_function&lt;InstanceClassLoaderKlass&gt;();
276       set_init_function&lt;ObjArrayKlass&gt;();
277       set_init_function&lt;TypeArrayKlass&gt;();
278     }
279   };
280 
281   static Table _table;
282 public:
283 
284   static void (*function(Klass* klass))(OopClosureType*, oop, Klass*) {
285     return _table._function[klass-&gt;id()];
286   }
287 };
288 
289 template &lt;typename OopClosureType&gt;
290 typename OopOopIterateDispatch&lt;OopClosureType&gt;::Table OopOopIterateDispatch&lt;OopClosureType&gt;::_table;
291 
292 
293 template &lt;typename OopClosureType&gt;
294 class OopOopIterateBoundedDispatch {
295 private:
296   class Table {
297   private:
298     template &lt;typename KlassType, typename T&gt;
299     static void oop_oop_iterate_bounded(OopClosureType* cl, oop obj, Klass* k, MemRegion mr) {
300       ((KlassType*)k)-&gt;KlassType::template oop_oop_iterate_bounded&lt;T&gt;(obj, cl, mr);
301     }
302 
303     template &lt;typename KlassType&gt;
304     static void init(OopClosureType* cl, oop obj, Klass* k, MemRegion mr) {
305       OopOopIterateBoundedDispatch&lt;OopClosureType&gt;::_table.set_resolve_function_and_execute&lt;KlassType&gt;(cl, obj, k, mr);
306     }
307 
308     template &lt;typename KlassType&gt;
309     void set_init_function() {
310       _function[KlassType::ID] = &amp;init&lt;KlassType&gt;;
311     }
312 
313     template &lt;typename KlassType&gt;
314     void set_resolve_function() {
315       if (UseCompressedOops) {
316         _function[KlassType::ID] = &amp;oop_oop_iterate_bounded&lt;KlassType, narrowOop&gt;;
317       } else {
318         _function[KlassType::ID] = &amp;oop_oop_iterate_bounded&lt;KlassType, oop&gt;;
319       }
320     }
321 
322     template &lt;typename KlassType&gt;
323     void set_resolve_function_and_execute(OopClosureType* cl, oop obj, Klass* k, MemRegion mr) {
324       set_resolve_function&lt;KlassType&gt;();
325       _function[KlassType::ID](cl, obj, k, mr);
326     }
327 
328   public:
329     void (*_function[KLASS_ID_COUNT])(OopClosureType*, oop, Klass*, MemRegion);
330 
331     Table(){
332       set_init_function&lt;InstanceKlass&gt;();
333       set_init_function&lt;InstanceRefKlass&gt;();
334       set_init_function&lt;InstanceMirrorKlass&gt;();
335       set_init_function&lt;InstanceClassLoaderKlass&gt;();
336       set_init_function&lt;ObjArrayKlass&gt;();
337       set_init_function&lt;TypeArrayKlass&gt;();
338     }
339   };
340 
341   static Table _table;
342 public:
343 
344   static void (*function(Klass* klass))(OopClosureType*, oop, Klass*, MemRegion) {
345     return _table._function[klass-&gt;id()];
346   }
347 };
348 
349 template &lt;typename OopClosureType&gt;
350 typename OopOopIterateBoundedDispatch&lt;OopClosureType&gt;::Table OopOopIterateBoundedDispatch&lt;OopClosureType&gt;::_table;
351 
352 
353 template &lt;typename OopClosureType&gt;
354 class OopOopIterateBackwardsDispatch {
355 private:
356   class Table {
357   private:
358     template &lt;typename KlassType, typename T&gt;
359     static void oop_oop_iterate_backwards(OopClosureType* cl, oop obj, Klass* k) {
360       ((KlassType*)k)-&gt;KlassType::template oop_oop_iterate_reverse&lt;T&gt;(obj, cl);
361     }
362 
363     template &lt;typename KlassType&gt;
364     static void init(OopClosureType* cl, oop obj, Klass* k) {
365       OopOopIterateBackwardsDispatch&lt;OopClosureType&gt;::_table.set_resolve_function_and_execute&lt;KlassType&gt;(cl, obj, k);
366     }
367 
368     template &lt;typename KlassType&gt;
369     void set_init_function() {
370       _function[KlassType::ID] = &amp;init&lt;KlassType&gt;;
371     }
372 
373     template &lt;typename KlassType&gt;
374     void set_resolve_function() {
375       if (UseCompressedOops) {
376         _function[KlassType::ID] = &amp;oop_oop_iterate_backwards&lt;KlassType, narrowOop&gt;;
377       } else {
378         _function[KlassType::ID] = &amp;oop_oop_iterate_backwards&lt;KlassType, oop&gt;;
379       }
380     }
381 
382     template &lt;typename KlassType&gt;
383     void set_resolve_function_and_execute(OopClosureType* cl, oop obj, Klass* k) {
384       set_resolve_function&lt;KlassType&gt;();
385       _function[KlassType::ID](cl, obj, k);
386     }
387 
388   public:
389     void (*_function[KLASS_ID_COUNT])(OopClosureType*, oop, Klass*);
390 
391     Table(){
392       set_init_function&lt;InstanceKlass&gt;();
393       set_init_function&lt;InstanceRefKlass&gt;();
394       set_init_function&lt;InstanceMirrorKlass&gt;();
395       set_init_function&lt;InstanceClassLoaderKlass&gt;();
396       set_init_function&lt;ObjArrayKlass&gt;();
397       set_init_function&lt;TypeArrayKlass&gt;();
398     }
399   };
400 
401   static Table _table;
402 public:
403 
404   static void (*function(Klass* klass))(OopClosureType*, oop, Klass*) {
405     return _table._function[klass-&gt;id()];
406   }
407 };
408 
409 template &lt;typename OopClosureType&gt;
410 typename OopOopIterateBackwardsDispatch&lt;OopClosureType&gt;::Table OopOopIterateBackwardsDispatch&lt;OopClosureType&gt;::_table;
411 
412 
413 template &lt;typename OopClosureType&gt;
414 void OopIteratorClosureDispatch::oop_oop_iterate(OopClosureType* cl, oop obj, Klass* klass) {
415   OopOopIterateDispatch&lt;OopClosureType&gt;::function(klass)(cl, obj, klass);
416 }
417 
418 template &lt;typename OopClosureType&gt;
419 void OopIteratorClosureDispatch::oop_oop_iterate(OopClosureType* cl, oop obj, Klass* klass, MemRegion mr) {
420   OopOopIterateBoundedDispatch&lt;OopClosureType&gt;::function(klass)(cl, obj, klass, mr);
421 }
422 
423 template &lt;typename OopClosureType&gt;
424 void OopIteratorClosureDispatch::oop_oop_iterate_backwards(OopClosureType* cl, oop obj, Klass* klass) {
425   OopOopIterateBackwardsDispatch&lt;OopClosureType&gt;::function(klass)(cl, obj, klass);
426 }
427 
428 #endif // SHARE_MEMORY_ITERATOR_INLINE_HPP
    </pre>
  </body>
</html>
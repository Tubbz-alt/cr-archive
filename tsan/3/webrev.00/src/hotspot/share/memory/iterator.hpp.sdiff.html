<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/iterator.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="iterator.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="iterator.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/iterator.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_MEMORY_ITERATOR_HPP
 26 #define SHARE_MEMORY_ITERATOR_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;memory/memRegion.hpp&quot;
 30 #include &quot;oops/oopsHierarchy.hpp&quot;
 31 
 32 class CodeBlob;
 33 class nmethod;
 34 class ReferenceDiscoverer;
 35 class DataLayout;
 36 class KlassClosure;
 37 class ClassLoaderData;
 38 class Symbol;


 39 
 40 // The following classes are C++ `closures` for iterating over objects, roots and spaces
 41 
 42 class Closure : public StackObj { };
 43 






 44 // OopClosure is used for iterating through references to Java objects.
 45 class OopClosure : public Closure {
 46  public:
 47   virtual void do_oop(oop* o) = 0;
 48   virtual void do_oop(narrowOop* o) = 0;
 49 };
 50 
 51 class DoNothingClosure : public OopClosure {
 52  public:
 53   virtual void do_oop(oop* p)       {}
 54   virtual void do_oop(narrowOop* p) {}
 55 };
 56 extern DoNothingClosure do_nothing_cl;
 57 
 58 // OopIterateClosure adds extra code to be run during oop iterations.
 59 // This is needed by the GC and is extracted to a separate type to not
 60 // pollute the OopClosure interface.
 61 class OopIterateClosure : public OopClosure {
 62  private:
 63   ReferenceDiscoverer* _ref_discoverer;
</pre>
<hr />
<pre>
107 // An OopIterateClosure that can be used when there&#39;s no need to visit the Metadata.
108 class BasicOopIterateClosure : public OopIterateClosure {
109 public:
110   BasicOopIterateClosure(ReferenceDiscoverer* rd = NULL) : OopIterateClosure(rd) {}
111 
112   virtual bool do_metadata() { return false; }
113   virtual void do_klass(Klass* k) { ShouldNotReachHere(); }
114   virtual void do_cld(ClassLoaderData* cld) { ShouldNotReachHere(); }
115 };
116 
117 class KlassClosure : public Closure {
118  public:
119   virtual void do_klass(Klass* k) = 0;
120 };
121 
122 class CLDClosure : public Closure {
123  public:
124   virtual void do_cld(ClassLoaderData* cld) = 0;
125 };
126 





127 
128 class CLDToOopClosure : public CLDClosure {
129   OopClosure*       _oop_closure;
130   int               _cld_claim;
131 
132  public:
133   CLDToOopClosure(OopClosure* oop_closure,
134                   int cld_claim) :
135       _oop_closure(oop_closure),
136       _cld_claim(cld_claim) {}
137 
138   void do_cld(ClassLoaderData* cld);
139 };
140 
<span class="line-modified">141 // The base class for all concurrent marking closures,</span>
<span class="line-modified">142 // that participates in class unloading.</span>
<span class="line-modified">143 // It&#39;s used to proxy through the metadata to the oops defined in them.</span>
<span class="line-modified">144 class MetadataVisitingOopIterateClosure: public OopIterateClosure {</span>
145  public:
<span class="line-modified">146   MetadataVisitingOopIterateClosure(ReferenceDiscoverer* rd = NULL) : OopIterateClosure(rd) { }</span>


147 
148   virtual bool do_metadata() { return true; }
149   virtual void do_klass(Klass* k);
150   virtual void do_cld(ClassLoaderData* cld);
151 };
152 








153 // ObjectClosure is used for iterating through an object space
154 
155 class ObjectClosure : public Closure {
156  public:
157   // Called for each object.
158   virtual void do_object(oop obj) = 0;
159 };
160 
161 
162 class BoolObjectClosure : public Closure {
163  public:
164   virtual bool do_object_b(oop obj) = 0;
165 };
166 
167 class AlwaysTrueClosure: public BoolObjectClosure {
168  public:
169   bool do_object_b(oop p) { return true; }
170 };
171 
172 class AlwaysFalseClosure : public BoolObjectClosure {
173  public:
174   bool do_object_b(oop p) { return false; }
175 };
176 
177 // Applies an oop closure to all ref fields in objects iterated over in an
178 // object iteration.
179 class ObjectToOopClosure: public ObjectClosure {
180   OopIterateClosure* _cl;
181 public:
182   void do_object(oop obj);
183   ObjectToOopClosure(OopIterateClosure* cl) : _cl(cl) {}
184 };
185 
<span class="line-removed">186 // A version of ObjectClosure that is expected to be robust</span>
<span class="line-removed">187 // in the face of possibly uninitialized objects.</span>
<span class="line-removed">188 class ObjectClosureCareful : public ObjectClosure {</span>
<span class="line-removed">189  public:</span>
<span class="line-removed">190   virtual size_t do_object_careful_m(oop p, MemRegion mr) = 0;</span>
<span class="line-removed">191   virtual size_t do_object_careful(oop p) = 0;</span>
<span class="line-removed">192 };</span>
<span class="line-removed">193 </span>
<span class="line-removed">194 // The following are used in CompactibleFreeListSpace and</span>
<span class="line-removed">195 // ConcurrentMarkSweepGeneration.</span>
<span class="line-removed">196 </span>
<span class="line-removed">197 // Blk closure (abstract class)</span>
<span class="line-removed">198 class BlkClosure : public StackObj {</span>
<span class="line-removed">199  public:</span>
<span class="line-removed">200   virtual size_t do_blk(HeapWord* addr) = 0;</span>
<span class="line-removed">201 };</span>
<span class="line-removed">202 </span>
<span class="line-removed">203 // A version of BlkClosure that is expected to be robust</span>
<span class="line-removed">204 // in the face of possibly uninitialized objects.</span>
<span class="line-removed">205 class BlkClosureCareful : public BlkClosure {</span>
<span class="line-removed">206  public:</span>
<span class="line-removed">207   size_t do_blk(HeapWord* addr) {</span>
<span class="line-removed">208     guarantee(false, &quot;call do_blk_careful instead&quot;);</span>
<span class="line-removed">209     return 0;</span>
<span class="line-removed">210   }</span>
<span class="line-removed">211   virtual size_t do_blk_careful(HeapWord* addr) = 0;</span>
<span class="line-removed">212 };</span>
<span class="line-removed">213 </span>
214 // SpaceClosure is used for iterating over spaces
215 
216 class Space;
217 class CompactibleSpace;
218 
219 class SpaceClosure : public StackObj {
220  public:
221   // Called for each space
222   virtual void do_space(Space* s) = 0;
223 };
224 
225 class CompactibleSpaceClosure : public StackObj {
226  public:
227   // Called for each compactible space
228   virtual void do_space(CompactibleSpace* s) = 0;
229 };
230 
231 
232 // CodeBlobClosure is used for iterating through code blobs
233 // in the code cache or on thread stacks
</pre>
<hr />
<pre>
299 public:
300  virtual bool should_return() = 0;
301 
302  // Yield on a fine-grain level. The check in case of not yielding should be very fast.
303  virtual bool should_return_fine_grain() { return false; }
304 };
305 
306 // Abstract closure for serializing data (read or write).
307 
308 class SerializeClosure : public Closure {
309 public:
310   // Return bool indicating whether closure implements read or write.
311   virtual bool reading() const = 0;
312 
313   // Read/write the void pointer pointed to by p.
314   virtual void do_ptr(void** p) = 0;
315 
316   // Read/write the 32-bit unsigned integer pointed to by p.
317   virtual void do_u4(u4* p) = 0;
318 



319   // Read/write the region specified.
320   virtual void do_region(u_char* start, size_t size) = 0;
321 
322   // Check/write the tag.  If reading, then compare the tag against
323   // the passed in value and fail is they don&#39;t match.  This allows
324   // for verification that sections of the serialized data are of the
325   // correct length.
326   virtual void do_tag(int tag) = 0;
327 
328   // Read/write the oop
329   virtual void do_oop(oop* o) = 0;
330 
331   bool writing() {
332     return !reading();
333   }
334 };
335 
336 class SymbolClosure : public StackObj {
337  public:
338   virtual void do_symbol(Symbol**) = 0;
</pre>
</td>
<td>
<hr />
<pre>
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_MEMORY_ITERATOR_HPP
 26 #define SHARE_MEMORY_ITERATOR_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;memory/memRegion.hpp&quot;
 30 #include &quot;oops/oopsHierarchy.hpp&quot;
 31 
 32 class CodeBlob;
 33 class nmethod;
 34 class ReferenceDiscoverer;
 35 class DataLayout;
 36 class KlassClosure;
 37 class ClassLoaderData;
 38 class Symbol;
<span class="line-added"> 39 class Metadata;</span>
<span class="line-added"> 40 class Thread;</span>
 41 
 42 // The following classes are C++ `closures` for iterating over objects, roots and spaces
 43 
 44 class Closure : public StackObj { };
 45 
<span class="line-added"> 46 // Thread iterator</span>
<span class="line-added"> 47 class ThreadClosure: public Closure {</span>
<span class="line-added"> 48  public:</span>
<span class="line-added"> 49   virtual void do_thread(Thread* thread) = 0;</span>
<span class="line-added"> 50 };</span>
<span class="line-added"> 51 </span>
 52 // OopClosure is used for iterating through references to Java objects.
 53 class OopClosure : public Closure {
 54  public:
 55   virtual void do_oop(oop* o) = 0;
 56   virtual void do_oop(narrowOop* o) = 0;
 57 };
 58 
 59 class DoNothingClosure : public OopClosure {
 60  public:
 61   virtual void do_oop(oop* p)       {}
 62   virtual void do_oop(narrowOop* p) {}
 63 };
 64 extern DoNothingClosure do_nothing_cl;
 65 
 66 // OopIterateClosure adds extra code to be run during oop iterations.
 67 // This is needed by the GC and is extracted to a separate type to not
 68 // pollute the OopClosure interface.
 69 class OopIterateClosure : public OopClosure {
 70  private:
 71   ReferenceDiscoverer* _ref_discoverer;
</pre>
<hr />
<pre>
115 // An OopIterateClosure that can be used when there&#39;s no need to visit the Metadata.
116 class BasicOopIterateClosure : public OopIterateClosure {
117 public:
118   BasicOopIterateClosure(ReferenceDiscoverer* rd = NULL) : OopIterateClosure(rd) {}
119 
120   virtual bool do_metadata() { return false; }
121   virtual void do_klass(Klass* k) { ShouldNotReachHere(); }
122   virtual void do_cld(ClassLoaderData* cld) { ShouldNotReachHere(); }
123 };
124 
125 class KlassClosure : public Closure {
126  public:
127   virtual void do_klass(Klass* k) = 0;
128 };
129 
130 class CLDClosure : public Closure {
131  public:
132   virtual void do_cld(ClassLoaderData* cld) = 0;
133 };
134 
<span class="line-added">135 class MetadataClosure : public Closure {</span>
<span class="line-added">136  public:</span>
<span class="line-added">137   virtual void do_metadata(Metadata* md) = 0;</span>
<span class="line-added">138 };</span>
<span class="line-added">139 </span>
140 
141 class CLDToOopClosure : public CLDClosure {
142   OopClosure*       _oop_closure;
143   int               _cld_claim;
144 
145  public:
146   CLDToOopClosure(OopClosure* oop_closure,
147                   int cld_claim) :
148       _oop_closure(oop_closure),
149       _cld_claim(cld_claim) {}
150 
151   void do_cld(ClassLoaderData* cld);
152 };
153 
<span class="line-modified">154 class ClaimMetadataVisitingOopIterateClosure : public OopIterateClosure {</span>
<span class="line-modified">155  protected:</span>
<span class="line-modified">156   const int _claim;</span>
<span class="line-modified">157 </span>
158  public:
<span class="line-modified">159   ClaimMetadataVisitingOopIterateClosure(int claim, ReferenceDiscoverer* rd = NULL) :</span>
<span class="line-added">160       OopIterateClosure(rd),</span>
<span class="line-added">161       _claim(claim) { }</span>
162 
163   virtual bool do_metadata() { return true; }
164   virtual void do_klass(Klass* k);
165   virtual void do_cld(ClassLoaderData* cld);
166 };
167 
<span class="line-added">168 // The base class for all concurrent marking closures,</span>
<span class="line-added">169 // that participates in class unloading.</span>
<span class="line-added">170 // It&#39;s used to proxy through the metadata to the oops defined in them.</span>
<span class="line-added">171 class MetadataVisitingOopIterateClosure: public ClaimMetadataVisitingOopIterateClosure {</span>
<span class="line-added">172  public:</span>
<span class="line-added">173   MetadataVisitingOopIterateClosure(ReferenceDiscoverer* rd = NULL);</span>
<span class="line-added">174 };</span>
<span class="line-added">175 </span>
176 // ObjectClosure is used for iterating through an object space
177 
178 class ObjectClosure : public Closure {
179  public:
180   // Called for each object.
181   virtual void do_object(oop obj) = 0;
182 };
183 
184 
185 class BoolObjectClosure : public Closure {
186  public:
187   virtual bool do_object_b(oop obj) = 0;
188 };
189 
190 class AlwaysTrueClosure: public BoolObjectClosure {
191  public:
192   bool do_object_b(oop p) { return true; }
193 };
194 
195 class AlwaysFalseClosure : public BoolObjectClosure {
196  public:
197   bool do_object_b(oop p) { return false; }
198 };
199 
200 // Applies an oop closure to all ref fields in objects iterated over in an
201 // object iteration.
202 class ObjectToOopClosure: public ObjectClosure {
203   OopIterateClosure* _cl;
204 public:
205   void do_object(oop obj);
206   ObjectToOopClosure(OopIterateClosure* cl) : _cl(cl) {}
207 };
208 




























209 // SpaceClosure is used for iterating over spaces
210 
211 class Space;
212 class CompactibleSpace;
213 
214 class SpaceClosure : public StackObj {
215  public:
216   // Called for each space
217   virtual void do_space(Space* s) = 0;
218 };
219 
220 class CompactibleSpaceClosure : public StackObj {
221  public:
222   // Called for each compactible space
223   virtual void do_space(CompactibleSpace* s) = 0;
224 };
225 
226 
227 // CodeBlobClosure is used for iterating through code blobs
228 // in the code cache or on thread stacks
</pre>
<hr />
<pre>
294 public:
295  virtual bool should_return() = 0;
296 
297  // Yield on a fine-grain level. The check in case of not yielding should be very fast.
298  virtual bool should_return_fine_grain() { return false; }
299 };
300 
301 // Abstract closure for serializing data (read or write).
302 
303 class SerializeClosure : public Closure {
304 public:
305   // Return bool indicating whether closure implements read or write.
306   virtual bool reading() const = 0;
307 
308   // Read/write the void pointer pointed to by p.
309   virtual void do_ptr(void** p) = 0;
310 
311   // Read/write the 32-bit unsigned integer pointed to by p.
312   virtual void do_u4(u4* p) = 0;
313 
<span class="line-added">314   // Read/write the bool pointed to by p.</span>
<span class="line-added">315   virtual void do_bool(bool* p) = 0;</span>
<span class="line-added">316 </span>
317   // Read/write the region specified.
318   virtual void do_region(u_char* start, size_t size) = 0;
319 
320   // Check/write the tag.  If reading, then compare the tag against
321   // the passed in value and fail is they don&#39;t match.  This allows
322   // for verification that sections of the serialized data are of the
323   // correct length.
324   virtual void do_tag(int tag) = 0;
325 
326   // Read/write the oop
327   virtual void do_oop(oop* o) = 0;
328 
329   bool writing() {
330     return !reading();
331   }
332 };
333 
334 class SymbolClosure : public StackObj {
335  public:
336   virtual void do_symbol(Symbol**) = 0;
</pre>
</td>
</tr>
</table>
<center><a href="iterator.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="iterator.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
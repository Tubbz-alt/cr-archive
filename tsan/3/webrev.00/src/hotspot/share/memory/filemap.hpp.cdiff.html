<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/memory/filemap.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="filemap.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="freeList.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/filemap.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 27,11 ***</span>
  
  #include &quot;classfile/classLoader.hpp&quot;
  #include &quot;include/cds.h&quot;
  #include &quot;memory/metaspaceShared.hpp&quot;
  #include &quot;memory/metaspace.hpp&quot;
<span class="line-modified">! #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;utilities/align.hpp&quot;
  
  // Layout of the file:
  //  header: dump of archive instance plus versioning info, datestamp, etc.
  //   [magic # = 0xF00BABA2]
<span class="line-new-header">--- 27,11 ---</span>
  
  #include &quot;classfile/classLoader.hpp&quot;
  #include &quot;include/cds.h&quot;
  #include &quot;memory/metaspaceShared.hpp&quot;
  #include &quot;memory/metaspace.hpp&quot;
<span class="line-modified">! #include &quot;oops/compressedOops.hpp&quot;</span>
  #include &quot;utilities/align.hpp&quot;
  
  // Layout of the file:
  //  header: dump of archive instance plus versioning info, datestamp, etc.
  //   [magic # = 0xF00BABA2]
</pre>
<hr />
<pre>
<span class="line-old-header">*** 41,238 ***</span>
  //  misc data (block offset table, string table, symbols, dictionary, etc.)
  //  tag(666)
  
  static const int JVM_IDENT_MAX = 256;
  
  class SharedClassPathEntry {
    enum {
      modules_image_entry,
      jar_entry,
      signed_jar_entry,
      dir_entry,
      unknown_entry
    };
<span class="line-modified">! protected:</span>
    u1     _type;
    time_t _timestamp;          // jar timestamp,  0 if is directory, modules image or other
    long   _filesize;           // jar/jimage file size, -1 if is directory, -2 if other
    Array&lt;char&gt;* _name;
    Array&lt;u1&gt;*   _manifest;
  
  public:
<span class="line-modified">!   void init(const char* name, bool is_modules_image, TRAPS);</span>
    void metaspace_pointers_do(MetaspaceClosure* it);
<span class="line-modified">!   bool validate(bool is_class_path = true);</span>
  
    // The _timestamp only gets set for jar files.
<span class="line-modified">!   bool has_timestamp() {</span>
      return _timestamp != 0;
    }
<span class="line-modified">!   bool is_dir()            { return _type == dir_entry; }</span>
<span class="line-modified">!   bool is_modules_image()  { return _type == modules_image_entry; }</span>
<span class="line-modified">!   bool is_jar()            { return _type == jar_entry; }</span>
<span class="line-modified">!   bool is_signed()         { return _type == signed_jar_entry; }</span>
<span class="line-modified">!   void set_is_signed()     {</span>
      _type = signed_jar_entry;
    }
    time_t timestamp() const { return _timestamp; }
    long   filesize()  const { return _filesize; }
<span class="line-modified">!   const char* name() const { return _name-&gt;data(); }</span>
    const char* manifest() const {
      return (_manifest == NULL) ? NULL : (const char*)_manifest-&gt;data();
    }
    int manifest_size() const {
      return (_manifest == NULL) ? 0 : _manifest-&gt;length();
    }
    void set_manifest(Array&lt;u1&gt;* manifest) {
      _manifest = manifest;
    }
  };
  
  struct ArchiveHeapOopmapInfo {
    address _oopmap;               // bitmap for relocating embedded oops
    size_t  _oopmap_size_in_bits;
  };
  
<span class="line-modified">! struct FileMapHeader : public CDSFileMapHeaderBase {</span>
    size_t _alignment;                // how shared archive should be aligned
    int    _obj_alignment;            // value of ObjectAlignmentInBytes
    address _narrow_oop_base;         // compressed oop encoding base
    int    _narrow_oop_shift;         // compressed oop encoding shift
<span class="line-modified">!   bool    _compact_strings;         // value of CompactStrings</span>
    uintx  _max_heap_size;            // java max heap size during dumping
<span class="line-modified">!   Universe::NARROW_OOP_MODE _narrow_oop_mode; // compressed oop encoding mode</span>
    int     _narrow_klass_shift;      // save narrow klass base and shift
<span class="line-modified">!   address _narrow_klass_base;</span>
<span class="line-modified">!   char*   _misc_data_patching_start;</span>
<span class="line-modified">!   char*   _read_only_tables_start;</span>
<span class="line-modified">!   address _cds_i2i_entry_code_buffers;</span>
<span class="line-modified">!   size_t  _cds_i2i_entry_code_buffers_size;</span>
<span class="line-modified">!   size_t  _core_spaces_size;        // number of bytes allocated by the core spaces</span>
<span class="line-modified">!                                     // (mc, md, ro, rw and od).</span>
<span class="line-modified">!   MemRegion _heap_reserved;         // reserved region for the entire heap at dump time.</span>
  
    // The following fields are all sanity checks for whether this archive
    // will function correctly with this JVM and the bootclasspath it&#39;s
    // invoked with.
<span class="line-modified">!   char  _jvm_ident[JVM_IDENT_MAX];      // identifier for jvm</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // The _paths_misc_info is a variable-size structure that records &quot;miscellaneous&quot;</span>
<span class="line-modified">!   // information during dumping. It is generated and validated by the</span>
<span class="line-modified">!   // SharedPathsMiscInfo class. See SharedPathsMiscInfo.hpp for</span>
<span class="line-modified">!   // detailed description.</span>
<span class="line-modified">!   //</span>
<span class="line-modified">!   // The _paths_misc_info data is stored as a byte array in the archive file header,</span>
<span class="line-modified">!   // immediately after the _header field. This information is used only when</span>
<span class="line-modified">!   // checking the validity of the archive and is deallocated after the archive is loaded.</span>
<span class="line-modified">!   //</span>
<span class="line-modified">!   // Note that the _paths_misc_info does NOT include information for JAR files</span>
<span class="line-modified">!   // that existed during dump time. Their information is stored in _shared_path_table.</span>
<span class="line-removed">-   int _paths_misc_info_size;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // The following is a table of all the class path entries that were used</span>
<span class="line-removed">-   // during dumping. At run time, we require these files to exist and have the same</span>
<span class="line-removed">-   // size/modification time, or else the archive will refuse to load.</span>
<span class="line-removed">-   //</span>
<span class="line-removed">-   // All of these entries must be JAR files. The dumping process would fail if a non-empty</span>
<span class="line-removed">-   // directory was specified in the classpaths. If an empty directory was specified</span>
<span class="line-removed">-   // it is checked by the _paths_misc_info as described above.</span>
<span class="line-removed">-   //</span>
<span class="line-removed">-   // FIXME -- if JAR files in the tail of the list were specified but not used during dumping,</span>
<span class="line-removed">-   // they should be removed from this table, to save space and to avoid spurious</span>
<span class="line-removed">-   // loading failures during runtime.</span>
<span class="line-removed">-   int _shared_path_table_size;</span>
<span class="line-removed">-   size_t _shared_path_entry_size;</span>
<span class="line-removed">-   Array&lt;u8&gt;* _shared_path_table;</span>
  
    jshort _app_class_paths_start_index;  // Index of first app classpath entry
    jshort _app_module_paths_start_index; // Index of first module path entry
    jshort _max_used_path_index;          // max path index referenced during CDS dump
    bool   _verify_local;                 // BytecodeVerificationLocal setting
    bool   _verify_remote;                // BytecodeVerificationRemote setting
    bool   _has_platform_or_app_classes;  // Archive contains app classes
<span class="line-modified">!   size_t _shared_base_address;          // SharedBaseAddress used at dump time</span>
    bool   _allow_archiving_with_java_agent; // setting of the AllowArchivingWithJavaAgent option
  
<span class="line-modified">!   void set_has_platform_or_app_classes(bool v) {</span>
<span class="line-modified">!     _has_platform_or_app_classes = v;</span>
    }
<span class="line-removed">-   bool has_platform_or_app_classes() { return _has_platform_or_app_classes; }</span>
<span class="line-removed">-   jshort max_used_path_index()       { return _max_used_path_index; }</span>
<span class="line-removed">-   jshort app_module_paths_start_index() { return _app_module_paths_start_index; }</span>
  
    bool validate();
<span class="line-removed">-   void populate(FileMapInfo* info, size_t alignment);</span>
    int compute_crc();
  
<span class="line-modified">!   CDSFileMapRegion* space_at(int i) {</span>
<span class="line-modified">!     assert(i &gt;= 0 &amp;&amp; i &lt; NUM_CDS_REGIONS, &quot;invalid region&quot;);</span>
<span class="line-modified">!     return &amp;_space[i];</span>
    }
  };
  
  class FileMapInfo : public CHeapObj&lt;mtInternal&gt; {
  private:
    friend class ManifestStream;
    friend class VMStructs;
<span class="line-modified">!   friend struct FileMapHeader;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   bool    _file_open;</span>
<span class="line-modified">!   int     _fd;</span>
<span class="line-modified">!   size_t  _file_offset;</span>
<span class="line-modified">! </span>
<span class="line-modified">! private:</span>
<span class="line-modified">!   static Array&lt;u8&gt;*            _shared_path_table;</span>
<span class="line-modified">!   static int                   _shared_path_table_size;</span>
<span class="line-modified">!   static size_t                _shared_path_entry_size;</span>
    static bool                  _validating_shared_path_table;
  
    // FileMapHeader describes the shared space data in the file to be
    // mapped.  This structure gets written to a file.  It is not a class, so
    // that the compilers don&#39;t add any compiler-private data to it.
  
<span class="line-removed">- public:</span>
<span class="line-removed">-   struct FileMapHeaderBase : public CHeapObj&lt;mtClass&gt; {</span>
<span class="line-removed">-     // Need to put something here. Otherwise, in product build, because CHeapObj has no virtual</span>
<span class="line-removed">-     // methods, we would get sizeof(FileMapHeaderBase) == 1 with gcc.</span>
<span class="line-removed">-     intx _dummy;</span>
<span class="line-removed">-   };</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">-   FileMapHeader * _header;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   const char* _full_path;</span>
<span class="line-removed">-   char* _paths_misc_info;</span>
<span class="line-removed">- </span>
    static FileMapInfo* _current_info;
    static bool _heap_pointers_need_patching;
  
<span class="line-modified">!   bool  init_from_file(int fd);</span>
<span class="line-removed">-   void  align_file_position();</span>
<span class="line-removed">-   bool  validate_header_impl();</span>
<span class="line-removed">-   static void metaspace_pointers_do(MetaspaceClosure* it);</span>
  
  public:
<span class="line-modified">!   FileMapInfo();</span>
    ~FileMapInfo();
  
<span class="line-modified">!   int    compute_header_crc()         { return _header-&gt;compute_crc(); }</span>
<span class="line-modified">!   void   set_header_crc(int crc)      { _header-&gt;_crc = crc; }</span>
    void   populate_header(size_t alignment);
    bool   validate_header();
    void   invalidate();
<span class="line-modified">!   int    version()                    { return _header-&gt;_version; }</span>
<span class="line-modified">!   size_t alignment()                  { return _header-&gt;_alignment; }</span>
<span class="line-modified">!   Universe::NARROW_OOP_MODE narrow_oop_mode() { return _header-&gt;_narrow_oop_mode; }</span>
<span class="line-modified">!   address narrow_oop_base()    const  { return _header-&gt;_narrow_oop_base; }</span>
<span class="line-modified">!   int     narrow_oop_shift()   const  { return _header-&gt;_narrow_oop_shift; }</span>
<span class="line-modified">!   uintx   max_heap_size()      const  { return _header-&gt;_max_heap_size; }</span>
<span class="line-modified">!   address narrow_klass_base()  const  { return _header-&gt;_narrow_klass_base; }</span>
<span class="line-modified">!   int     narrow_klass_shift() const  { return _header-&gt;_narrow_klass_shift; }</span>
<span class="line-modified">!   struct  FileMapHeader* header()     { return _header; }</span>
<span class="line-modified">!   char*   misc_data_patching_start()          { return _header-&gt;_misc_data_patching_start; }</span>
<span class="line-modified">!   void set_misc_data_patching_start(char* p)  { _header-&gt;_misc_data_patching_start = p; }</span>
<span class="line-modified">!   char* read_only_tables_start()              { return _header-&gt;_read_only_tables_start; }</span>
<span class="line-modified">!   void set_read_only_tables_start(char* p)    { _header-&gt;_read_only_tables_start = p; }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   address cds_i2i_entry_code_buffers() {</span>
<span class="line-modified">!     return _header-&gt;_cds_i2i_entry_code_buffers;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   void set_cds_i2i_entry_code_buffers(address addr) {</span>
<span class="line-modified">!     _header-&gt;_cds_i2i_entry_code_buffers = addr;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   size_t cds_i2i_entry_code_buffers_size() {</span>
<span class="line-modified">!     return _header-&gt;_cds_i2i_entry_code_buffers_size;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   void set_cds_i2i_entry_code_buffers_size(size_t s) {</span>
<span class="line-modified">!     _header-&gt;_cds_i2i_entry_code_buffers_size = s;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   void set_core_spaces_size(size_t s)    {  _header-&gt;_core_spaces_size = s; }</span>
<span class="line-modified">!   size_t core_spaces_size()              { return _header-&gt;_core_spaces_size; }</span>
  
    static FileMapInfo* current_info() {
      CDS_ONLY(return _current_info;)
      NOT_CDS(return NULL;)
    }
  
    static void assert_mark(bool check);
  
    // File manipulation.
    bool  initialize() NOT_CDS_RETURN_(false);
    bool  open_for_read();
<span class="line-modified">!   void  open_for_write();</span>
    void  write_header();
    void  write_region(int region, char* base, size_t size,
                       bool read_only, bool allow_exec);
    size_t write_archive_heap_regions(GrowableArray&lt;MemRegion&gt; *heap_mem,
                                      GrowableArray&lt;ArchiveHeapOopmapInfo&gt; *oopmaps,
<span class="line-modified">!                                     int first_region_id, int max_num_regions,</span>
<span class="line-removed">-                                     bool print_log);</span>
    void  write_bytes(const void* buffer, size_t count);
    void  write_bytes_aligned(const void* buffer, size_t count);
<span class="line-modified">!   char* map_region(int i, char** top_ret);</span>
<span class="line-modified">!   void  map_heap_regions_impl() NOT_CDS_JAVA_HEAP_RETURN;</span>
    void  map_heap_regions() NOT_CDS_JAVA_HEAP_RETURN;
    void  fixup_mapped_heap_regions() NOT_CDS_JAVA_HEAP_RETURN;
    void  patch_archived_heap_embedded_pointers() NOT_CDS_JAVA_HEAP_RETURN;
    void  patch_archived_heap_embedded_pointers(MemRegion* ranges, int num_ranges,
                                                int first_region_idx) NOT_CDS_JAVA_HEAP_RETURN;
<span class="line-new-header">--- 41,419 ---</span>
  //  misc data (block offset table, string table, symbols, dictionary, etc.)
  //  tag(666)
  
  static const int JVM_IDENT_MAX = 256;
  
<span class="line-added">+ class CHeapBitMap;</span>
<span class="line-added">+ </span>
  class SharedClassPathEntry {
    enum {
      modules_image_entry,
      jar_entry,
      signed_jar_entry,
      dir_entry,
<span class="line-added">+     non_existent_entry,</span>
      unknown_entry
    };
<span class="line-modified">! </span>
<span class="line-added">+   void set_name(const char* name, TRAPS);</span>
<span class="line-added">+ </span>
    u1     _type;
<span class="line-added">+   bool   _from_class_path_attr;</span>
    time_t _timestamp;          // jar timestamp,  0 if is directory, modules image or other
    long   _filesize;           // jar/jimage file size, -1 if is directory, -2 if other
    Array&lt;char&gt;* _name;
    Array&lt;u1&gt;*   _manifest;
  
  public:
<span class="line-modified">!   void init(bool is_modules_image, ClassPathEntry* cpe, TRAPS);</span>
<span class="line-added">+   void init_as_non_existent(const char* path, TRAPS);</span>
    void metaspace_pointers_do(MetaspaceClosure* it);
<span class="line-modified">!   bool validate(bool is_class_path = true) const;</span>
  
    // The _timestamp only gets set for jar files.
<span class="line-modified">!   bool has_timestamp() const {</span>
      return _timestamp != 0;
    }
<span class="line-modified">!   bool is_dir()           const { return _type == dir_entry; }</span>
<span class="line-modified">!   bool is_modules_image() const { return _type == modules_image_entry; }</span>
<span class="line-modified">!   bool is_jar()           const { return _type == jar_entry; }</span>
<span class="line-modified">!   bool is_signed()        const { return _type == signed_jar_entry; }</span>
<span class="line-modified">!   void set_is_signed() {</span>
      _type = signed_jar_entry;
    }
<span class="line-added">+   bool from_class_path_attr() { return _from_class_path_attr; }</span>
    time_t timestamp() const { return _timestamp; }
    long   filesize()  const { return _filesize; }
<span class="line-modified">!   const char* name() const;</span>
    const char* manifest() const {
      return (_manifest == NULL) ? NULL : (const char*)_manifest-&gt;data();
    }
    int manifest_size() const {
      return (_manifest == NULL) ? 0 : _manifest-&gt;length();
    }
    void set_manifest(Array&lt;u1&gt;* manifest) {
      _manifest = manifest;
    }
<span class="line-added">+   bool check_non_existent() const;</span>
  };
  
  struct ArchiveHeapOopmapInfo {
    address _oopmap;               // bitmap for relocating embedded oops
    size_t  _oopmap_size_in_bits;
  };
  
<span class="line-modified">! class SharedPathTable {</span>
<span class="line-added">+   Array&lt;u8&gt;* _table;</span>
<span class="line-added">+   int _size;</span>
<span class="line-added">+ public:</span>
<span class="line-added">+   SharedPathTable() : _table(NULL), _size(0) {}</span>
<span class="line-added">+   SharedPathTable(Array&lt;u8&gt;* table, int size) : _table(table), _size(size) {}</span>
<span class="line-added">+ </span>
<span class="line-added">+   void dumptime_init(ClassLoaderData* loader_data, Thread* THREAD);</span>
<span class="line-added">+   void metaspace_pointers_do(MetaspaceClosure* it);</span>
<span class="line-added">+ </span>
<span class="line-added">+   int size() {</span>
<span class="line-added">+     return _size;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   SharedClassPathEntry* path_at(int index) {</span>
<span class="line-added">+     if (index &lt; 0) {</span>
<span class="line-added">+       return NULL;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     assert(index &lt; _size, &quot;sanity&quot;);</span>
<span class="line-added">+     char* p = (char*)_table-&gt;data();</span>
<span class="line-added">+     p += sizeof(SharedClassPathEntry) * index;</span>
<span class="line-added">+     return (SharedClassPathEntry*)p;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   Array&lt;u8&gt;* table() {return _table;}</span>
<span class="line-added">+   void set_table(Array&lt;u8&gt;* table) {_table = table;}</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ class FileMapRegion: private CDSFileMapRegion {</span>
<span class="line-added">+   void assert_is_heap_region() const {</span>
<span class="line-added">+     assert(_is_heap_region, &quot;must be heap region&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   void assert_is_not_heap_region() const {</span>
<span class="line-added">+     assert(!_is_heap_region, &quot;must not be heap region&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+ public:</span>
<span class="line-added">+   static FileMapRegion* cast(CDSFileMapRegion* p) {</span>
<span class="line-added">+     return (FileMapRegion*)p;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Accessors</span>
<span class="line-added">+   int crc()                         const { return _crc; }</span>
<span class="line-added">+   size_t file_offset()              const { return _file_offset; }</span>
<span class="line-added">+   size_t mapping_offset()           const { return _mapping_offset; }</span>
<span class="line-added">+   size_t mapping_end_offset()       const { return _mapping_offset + used_aligned(); }</span>
<span class="line-added">+   size_t used()                     const { return _used; }</span>
<span class="line-added">+   size_t used_aligned()             const; // aligned up to os::vm_allocation_granularity()</span>
<span class="line-added">+   char*  mapped_base()              const { assert_is_not_heap_region(); return _mapped_base; }</span>
<span class="line-added">+   char*  mapped_end()               const { return mapped_base()        + used_aligned(); }</span>
<span class="line-added">+   bool   read_only()                const { return _read_only != 0; }</span>
<span class="line-added">+   bool   allow_exec()               const { return _allow_exec != 0; }</span>
<span class="line-added">+   bool   mapped_from_file()         const { return _mapped_from_file != 0; }</span>
<span class="line-added">+   size_t oopmap_offset()            const { assert_is_heap_region();     return _oopmap_offset; }</span>
<span class="line-added">+   size_t oopmap_size_in_bits()      const { assert_is_heap_region();     return _oopmap_size_in_bits; }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void set_file_offset(size_t s)     { _file_offset = s; }</span>
<span class="line-added">+   void set_read_only(bool v)         { _read_only = v; }</span>
<span class="line-added">+   void set_mapped_base(char* p)      { _mapped_base = p; }</span>
<span class="line-added">+   void set_mapped_from_file(bool v)  { _mapped_from_file = v; }</span>
<span class="line-added">+   void init(int region_index, char* base, size_t size, bool read_only,</span>
<span class="line-added">+             bool allow_exec, int crc);</span>
<span class="line-added">+ </span>
<span class="line-added">+   void init_oopmap(size_t oopmap_offset, size_t size_in_bits) {</span>
<span class="line-added">+     _oopmap_offset = oopmap_offset;</span>
<span class="line-added">+     _oopmap_size_in_bits = size_in_bits;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ class FileMapHeader: private CDSFileMapHeaderBase {</span>
<span class="line-added">+   friend class CDSOffsets;</span>
<span class="line-added">+   friend class VMStructs;</span>
<span class="line-added">+ </span>
<span class="line-added">+   size_t _header_size;</span>
<span class="line-added">+ </span>
<span class="line-added">+   // The following fields record the states of the VM during dump time.</span>
<span class="line-added">+   // They are compared with the runtime states to see if the archive</span>
<span class="line-added">+   // can be used.</span>
    size_t _alignment;                // how shared archive should be aligned
    int    _obj_alignment;            // value of ObjectAlignmentInBytes
    address _narrow_oop_base;         // compressed oop encoding base
    int    _narrow_oop_shift;         // compressed oop encoding shift
<span class="line-modified">!   bool   _compact_strings;          // value of CompactStrings</span>
    uintx  _max_heap_size;            // java max heap size during dumping
<span class="line-modified">!   CompressedOops::Mode _narrow_oop_mode; // compressed oop encoding mode</span>
    int     _narrow_klass_shift;      // save narrow klass base and shift
<span class="line-modified">!   bool    _compressed_oops;         // save the flag UseCompressedOops</span>
<span class="line-modified">!   bool    _compressed_class_ptrs;   // save the flag UseCompressedClassPointers</span>
<span class="line-modified">!   size_t  _cloned_vtables_offset;   // The address of the first cloned vtable</span>
<span class="line-modified">!   size_t  _serialized_data_offset;  // Data accessed using {ReadClosure,WriteClosure}::serialize()</span>
<span class="line-modified">!   size_t  _i2i_entry_code_buffers_offset;</span>
<span class="line-modified">!   size_t  _i2i_entry_code_buffers_size;</span>
<span class="line-modified">!   address _heap_end;                // heap end at dump time.</span>
<span class="line-modified">!   bool _base_archive_is_default;    // indicates if the base archive is the system default one</span>
  
    // The following fields are all sanity checks for whether this archive
    // will function correctly with this JVM and the bootclasspath it&#39;s
    // invoked with.
<span class="line-modified">!   char  _jvm_ident[JVM_IDENT_MAX];  // identifier string of the jvm that created this dump</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // size of the base archive name including NULL terminator</span>
<span class="line-modified">!   size_t _base_archive_name_size;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // The following is a table of all the boot/app/module path entries that were used</span>
<span class="line-modified">!   // during dumping. At run time, we validate these entries according to their</span>
<span class="line-modified">!   // SharedClassPathEntry::_type. See:</span>
<span class="line-modified">!   //      check_nonempty_dir_in_shared_path_table()</span>
<span class="line-modified">!   //      validate_shared_path_table()</span>
<span class="line-modified">!   //      validate_non_existent_class_paths()</span>
<span class="line-modified">!   size_t _shared_path_table_offset;</span>
<span class="line-modified">!   int    _shared_path_table_size;</span>
  
    jshort _app_class_paths_start_index;  // Index of first app classpath entry
    jshort _app_module_paths_start_index; // Index of first module path entry
<span class="line-added">+   jshort _num_module_paths;             // number of module path entries</span>
    jshort _max_used_path_index;          // max path index referenced during CDS dump
    bool   _verify_local;                 // BytecodeVerificationLocal setting
    bool   _verify_remote;                // BytecodeVerificationRemote setting
    bool   _has_platform_or_app_classes;  // Archive contains app classes
<span class="line-modified">!   char*  _requested_base_address;       // Archive relocation is not necessary if we map with this base address.</span>
<span class="line-added">+   char*  _mapped_base_address;          // Actual base address where archive is mapped.</span>
<span class="line-added">+ </span>
    bool   _allow_archiving_with_java_agent; // setting of the AllowArchivingWithJavaAgent option
<span class="line-added">+   size_t _ptrmap_size_in_bits;          // Size of pointer relocation bitmap</span>
  
<span class="line-modified">!   char* from_mapped_offset(size_t offset) const {</span>
<span class="line-modified">!     return mapped_base_address() + offset;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   void set_mapped_offset(char* p, size_t *offset) {</span>
<span class="line-added">+     assert(p &gt;= mapped_base_address(), &quot;sanity&quot;);</span>
<span class="line-added">+     *offset = p - mapped_base_address();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ public:</span>
<span class="line-added">+   // Accessors -- fields declared in CDSFileMapHeaderBase</span>
<span class="line-added">+   unsigned int magic() const {return _magic;}</span>
<span class="line-added">+   int crc()                               const { return _crc; }</span>
<span class="line-added">+   int version()                           const { return _version; }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void set_crc(int crc_value)                   { _crc = crc_value; }</span>
<span class="line-added">+   void set_version(int v)                       { _version = v; }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Accessors -- fields declared in FileMapHeader</span>
<span class="line-added">+ </span>
<span class="line-added">+   size_t header_size()                     const { return _header_size; }</span>
<span class="line-added">+   size_t alignment()                       const { return _alignment; }</span>
<span class="line-added">+   int obj_alignment()                      const { return _obj_alignment; }</span>
<span class="line-added">+   address narrow_oop_base()                const { return _narrow_oop_base; }</span>
<span class="line-added">+   int narrow_oop_shift()                   const { return _narrow_oop_shift; }</span>
<span class="line-added">+   bool compact_strings()                   const { return _compact_strings; }</span>
<span class="line-added">+   uintx max_heap_size()                    const { return _max_heap_size; }</span>
<span class="line-added">+   CompressedOops::Mode narrow_oop_mode()   const { return _narrow_oop_mode; }</span>
<span class="line-added">+   int narrow_klass_shift()                 const { return _narrow_klass_shift; }</span>
<span class="line-added">+   address narrow_klass_base()              const { return (address)mapped_base_address(); }</span>
<span class="line-added">+   char* cloned_vtables()                   const { return from_mapped_offset(_cloned_vtables_offset); }</span>
<span class="line-added">+   char* serialized_data()                  const { return from_mapped_offset(_serialized_data_offset); }</span>
<span class="line-added">+   address i2i_entry_code_buffers()         const { return (address)from_mapped_offset(_i2i_entry_code_buffers_offset); }</span>
<span class="line-added">+   size_t i2i_entry_code_buffers_size()     const { return _i2i_entry_code_buffers_size; }</span>
<span class="line-added">+   address heap_end()                       const { return _heap_end; }</span>
<span class="line-added">+   bool base_archive_is_default()           const { return _base_archive_is_default; }</span>
<span class="line-added">+   const char* jvm_ident()                  const { return _jvm_ident; }</span>
<span class="line-added">+   size_t base_archive_name_size()          const { return _base_archive_name_size; }</span>
<span class="line-added">+   char* requested_base_address()           const { return _requested_base_address; }</span>
<span class="line-added">+   char* mapped_base_address()              const { return _mapped_base_address; }</span>
<span class="line-added">+   bool has_platform_or_app_classes()       const { return _has_platform_or_app_classes; }</span>
<span class="line-added">+   size_t ptrmap_size_in_bits()             const { return _ptrmap_size_in_bits; }</span>
<span class="line-added">+   bool compressed_oops()                   const { return _compressed_oops; }</span>
<span class="line-added">+   bool compressed_class_pointers()         const { return _compressed_class_ptrs; }</span>
<span class="line-added">+   // FIXME: These should really return int</span>
<span class="line-added">+   jshort max_used_path_index()             const { return _max_used_path_index; }</span>
<span class="line-added">+   jshort app_module_paths_start_index()    const { return _app_module_paths_start_index; }</span>
<span class="line-added">+   jshort app_class_paths_start_index()     const { return _app_class_paths_start_index; }</span>
<span class="line-added">+   jshort num_module_paths()                const { return _num_module_paths; }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void set_has_platform_or_app_classes(bool v)   { _has_platform_or_app_classes = v; }</span>
<span class="line-added">+   void set_cloned_vtables(char* p)               { set_mapped_offset(p, &amp;_cloned_vtables_offset); }</span>
<span class="line-added">+   void set_serialized_data(char* p)              { set_mapped_offset(p, &amp;_serialized_data_offset); }</span>
<span class="line-added">+   void set_base_archive_name_size(size_t s)      { _base_archive_name_size = s; }</span>
<span class="line-added">+   void set_base_archive_is_default(bool b)       { _base_archive_is_default = b; }</span>
<span class="line-added">+   void set_header_size(size_t s)                 { _header_size = s; }</span>
<span class="line-added">+   void set_ptrmap_size_in_bits(size_t s)         { _ptrmap_size_in_bits = s; }</span>
<span class="line-added">+   void set_mapped_base_address(char* p)          { _mapped_base_address = p; }</span>
<span class="line-added">+   void set_i2i_entry_code_buffers(address p, size_t s) {</span>
<span class="line-added">+     set_mapped_offset((char*)p, &amp;_i2i_entry_code_buffers_offset);</span>
<span class="line-added">+     _i2i_entry_code_buffers_size = s;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void set_shared_path_table(SharedPathTable table) {</span>
<span class="line-added">+     set_mapped_offset((char*)table.table(), &amp;_shared_path_table_offset);</span>
<span class="line-added">+     _shared_path_table_size = table.size();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void set_final_requested_base(char* b) {</span>
<span class="line-added">+     _requested_base_address = b;</span>
<span class="line-added">+     _mapped_base_address = 0;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   SharedPathTable shared_path_table() const {</span>
<span class="line-added">+     return SharedPathTable((Array&lt;u8&gt;*)from_mapped_offset(_shared_path_table_offset),</span>
<span class="line-added">+                            _shared_path_table_size);</span>
    }
  
    bool validate();
    int compute_crc();
  
<span class="line-modified">!   FileMapRegion* space_at(int i) {</span>
<span class="line-modified">!     assert(is_valid_region(i), &quot;invalid region&quot;);</span>
<span class="line-modified">!     return FileMapRegion::cast(&amp;_space[i]);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void populate(FileMapInfo* info, size_t alignment);</span>
<span class="line-added">+ </span>
<span class="line-added">+   static bool is_valid_region(int region) {</span>
<span class="line-added">+     return (0 &lt;= region &amp;&amp; region &lt; NUM_CDS_REGIONS);</span>
    }
  };
  
  class FileMapInfo : public CHeapObj&lt;mtInternal&gt; {
  private:
    friend class ManifestStream;
    friend class VMStructs;
<span class="line-modified">!   friend class CDSOffsets;</span>
<span class="line-modified">!   friend class FileMapHeader;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   bool           _is_static;</span>
<span class="line-modified">!   bool           _file_open;</span>
<span class="line-modified">!   bool           _is_mapped;</span>
<span class="line-modified">!   int            _fd;</span>
<span class="line-modified">!   size_t         _file_offset;</span>
<span class="line-modified">!   const char*    _full_path;</span>
<span class="line-modified">!   const char*    _base_archive_name;</span>
<span class="line-added">+   FileMapHeader* _header;</span>
<span class="line-added">+ </span>
<span class="line-added">+   // TODO: Probably change the following to be non-static</span>
<span class="line-added">+   static SharedPathTable       _shared_path_table;</span>
    static bool                  _validating_shared_path_table;
  
    // FileMapHeader describes the shared space data in the file to be
    // mapped.  This structure gets written to a file.  It is not a class, so
    // that the compilers don&#39;t add any compiler-private data to it.
  
    static FileMapInfo* _current_info;
<span class="line-added">+   static FileMapInfo* _dynamic_archive_info;</span>
    static bool _heap_pointers_need_patching;
<span class="line-added">+   static bool _memory_mapping_failed;</span>
<span class="line-added">+   static GrowableArray&lt;const char*&gt;* _non_existent_class_paths;</span>
  
<span class="line-modified">!   FileMapHeader *header() const       { return _header; }</span>
  
  public:
<span class="line-modified">!   static bool get_base_archive_name_from_header(const char* archive_name,</span>
<span class="line-added">+                                                 int* size, char** base_archive_name);</span>
<span class="line-added">+   static bool check_archive(const char* archive_name, bool is_static);</span>
<span class="line-added">+   static SharedPathTable shared_path_table() {</span>
<span class="line-added">+     return _shared_path_table;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   void restore_shared_path_table();</span>
<span class="line-added">+   bool init_from_file(int fd);</span>
<span class="line-added">+   static void metaspace_pointers_do(MetaspaceClosure* it);</span>
<span class="line-added">+ </span>
<span class="line-added">+   void log_paths(const char* msg, int start_idx, int end_idx);</span>
<span class="line-added">+ </span>
<span class="line-added">+   FileMapInfo(bool is_static);</span>
    ~FileMapInfo();
  
<span class="line-modified">!   // Accessors</span>
<span class="line-modified">!   int    compute_header_crc()  const { return header()-&gt;compute_crc(); }</span>
<span class="line-added">+   void   set_header_crc(int crc)     { header()-&gt;set_crc(crc); }</span>
<span class="line-added">+   int    space_crc(int i)      const { return space_at(i)-&gt;crc(); }</span>
    void   populate_header(size_t alignment);
    bool   validate_header();
    void   invalidate();
<span class="line-modified">!   int    crc()                 const { return header()-&gt;crc(); }</span>
<span class="line-modified">!   int    version()             const { return header()-&gt;version(); }</span>
<span class="line-modified">!   size_t alignment()           const { return header()-&gt;alignment(); }</span>
<span class="line-modified">!   address narrow_oop_base()    const { return header()-&gt;narrow_oop_base(); }</span>
<span class="line-modified">!   int     narrow_oop_shift()   const { return header()-&gt;narrow_oop_shift(); }</span>
<span class="line-modified">!   uintx   max_heap_size()      const { return header()-&gt;max_heap_size(); }</span>
<span class="line-modified">!   address narrow_klass_base()  const { return header()-&gt;narrow_klass_base(); }</span>
<span class="line-modified">!   int     narrow_klass_shift() const { return header()-&gt;narrow_klass_shift(); }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   CompressedOops::Mode narrow_oop_mode()      const { return header()-&gt;narrow_oop_mode(); }</span>
<span class="line-modified">!   jshort app_module_paths_start_index()       const { return header()-&gt;app_module_paths_start_index(); }</span>
<span class="line-modified">!   jshort app_class_paths_start_index()        const { return header()-&gt;app_class_paths_start_index(); }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   char* cloned_vtables()                      const { return header()-&gt;cloned_vtables(); }</span>
<span class="line-modified">!   void  set_cloned_vtables(char* p)           const { header()-&gt;set_cloned_vtables(p); }</span>
<span class="line-modified">!   char* serialized_data()                     const { return header()-&gt;serialized_data(); }</span>
<span class="line-modified">!   void  set_serialized_data(char* p)          const { header()-&gt;set_serialized_data(p); }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   bool  is_file_position_aligned() const;</span>
<span class="line-modified">!   void  align_file_position();</span>
<span class="line-modified">! </span>
<span class="line-modified">!   address i2i_entry_code_buffers()            const { return header()-&gt;i2i_entry_code_buffers();  }</span>
<span class="line-modified">!   size_t i2i_entry_code_buffers_size()        const { return header()-&gt;i2i_entry_code_buffers_size(); }</span>
<span class="line-modified">!   void set_i2i_entry_code_buffers(address addr, size_t s) const {</span>
<span class="line-modified">!     header()-&gt;set_i2i_entry_code_buffers(addr, s);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   bool is_static()                            const { return _is_static; }</span>
<span class="line-added">+   bool is_mapped()                            const { return _is_mapped; }</span>
<span class="line-added">+   void set_is_mapped(bool v)                        { _is_mapped = v; }</span>
<span class="line-added">+   const char* full_path()                     const { return _full_path; }</span>
<span class="line-added">+   void set_final_requested_base(char* b);</span>
<span class="line-added">+ </span>
<span class="line-added">+   char* requested_base_address()           const { return header()-&gt;requested_base_address(); }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+   class DynamicArchiveHeader* dynamic_header() const {</span>
<span class="line-added">+     assert(!is_static(), &quot;must be&quot;);</span>
<span class="line-added">+     return (DynamicArchiveHeader*)header();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void set_has_platform_or_app_classes(bool v) {</span>
<span class="line-added">+     header()-&gt;set_has_platform_or_app_classes(v);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   bool has_platform_or_app_classes() const {</span>
<span class="line-added">+     return header()-&gt;has_platform_or_app_classes();</span>
<span class="line-added">+   }</span>
  
    static FileMapInfo* current_info() {
      CDS_ONLY(return _current_info;)
      NOT_CDS(return NULL;)
    }
  
<span class="line-added">+   static void set_current_info(FileMapInfo* info) {</span>
<span class="line-added">+     CDS_ONLY(_current_info = info;)</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   static FileMapInfo* dynamic_info() {</span>
<span class="line-added">+     CDS_ONLY(return _dynamic_archive_info;)</span>
<span class="line-added">+     NOT_CDS(return NULL;)</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    static void assert_mark(bool check);
  
    // File manipulation.
    bool  initialize() NOT_CDS_RETURN_(false);
    bool  open_for_read();
<span class="line-modified">!   void  open_for_write(const char* path = NULL);</span>
    void  write_header();
    void  write_region(int region, char* base, size_t size,
                       bool read_only, bool allow_exec);
<span class="line-added">+   void  write_bitmap_region(const CHeapBitMap* ptrmap);</span>
    size_t write_archive_heap_regions(GrowableArray&lt;MemRegion&gt; *heap_mem,
                                      GrowableArray&lt;ArchiveHeapOopmapInfo&gt; *oopmaps,
<span class="line-modified">!                                     int first_region_id, int max_num_regions);</span>
    void  write_bytes(const void* buffer, size_t count);
    void  write_bytes_aligned(const void* buffer, size_t count);
<span class="line-modified">!   size_t  read_bytes(void* buffer, size_t count);</span>
<span class="line-modified">!   MapArchiveResult map_regions(int regions[], int num_regions, char* mapped_base_address, ReservedSpace rs);</span>
<span class="line-added">+   void  unmap_regions(int regions[], int num_regions);</span>
    void  map_heap_regions() NOT_CDS_JAVA_HEAP_RETURN;
    void  fixup_mapped_heap_regions() NOT_CDS_JAVA_HEAP_RETURN;
    void  patch_archived_heap_embedded_pointers() NOT_CDS_JAVA_HEAP_RETURN;
    void  patch_archived_heap_embedded_pointers(MemRegion* ranges, int num_ranges,
                                                int first_region_idx) NOT_CDS_JAVA_HEAP_RETURN;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 289,71 ***</span>
    bool  remap_shared_readonly_as_readwrite();
  
    // Errors.
    static void fail_stop(const char *msg, ...) ATTRIBUTE_PRINTF(1, 2);
    static void fail_continue(const char *msg, ...) ATTRIBUTE_PRINTF(1, 2);
<span class="line-modified">! </span>
    bool is_in_shared_region(const void* p, int idx) NOT_CDS_RETURN_(false);
  
    // Stop CDS sharing and unmap CDS regions.
    static void stop_sharing_and_unmap(const char* msg);
  
    static void allocate_shared_path_table();
    static void check_nonempty_dir_in_shared_path_table();
    bool validate_shared_path_table();
<span class="line-modified">!   static void update_shared_classpath(ClassPathEntry *cpe, SharedClassPathEntry* ent, TRAPS);</span>
  
  #if INCLUDE_JVMTI
<span class="line-modified">!   static ClassFileStream* open_stream_for_jvmti(InstanceKlass* ik, TRAPS);</span>
  #endif
  
    static SharedClassPathEntry* shared_path(int index) {
<span class="line-modified">!     if (index &lt; 0) {</span>
<span class="line-removed">-       return NULL;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     assert(index &lt; _shared_path_table_size, &quot;sanity&quot;);</span>
<span class="line-removed">-     char* p = (char*)_shared_path_table-&gt;data();</span>
<span class="line-removed">-     p += _shared_path_entry_size * index;</span>
<span class="line-removed">-     return (SharedClassPathEntry*)p;</span>
    }
  
    static const char* shared_path_name(int index) {
      assert(index &gt;= 0, &quot;Sanity&quot;);
      return shared_path(index)-&gt;name();
    }
  
    static int get_number_of_shared_paths() {
<span class="line-modified">!     return _shared_path_table_size;</span>
    }
  
    char* region_addr(int idx);
  
   private:
    bool  map_heap_data(MemRegion **heap_mem, int first, int max, int* num,
                        bool is_open = false) NOT_CDS_JAVA_HEAP_RETURN_(false);
<span class="line-modified">!   bool  verify_mapped_heap_regions(int first, int num) NOT_CDS_JAVA_HEAP_RETURN_(false);</span>
<span class="line-modified">!   void  dealloc_archive_heap_regions(MemRegion* regions, int num, bool is_open) NOT_CDS_JAVA_HEAP_RETURN;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   CDSFileMapRegion* space_at(int i) {</span>
<span class="line-modified">!     return _header-&gt;space_at(i);</span>
<span class="line-modified">!   }</span>
  
<span class="line-modified">!   narrowOop offset_of_space(CDSFileMapRegion* spc) {</span>
<span class="line-modified">!     return (narrowOop)(spc-&gt;_addr._offset);</span>
    }
  
    // The starting address of spc, as calculated with CompressedOop::decode_non_null()
<span class="line-modified">!   address start_address_as_decoded_with_current_oop_encoding_mode(CDSFileMapRegion* spc) {</span>
      return decode_start_address(spc, true);
    }
  
    // The starting address of spc, as calculated with HeapShared::decode_from_archive()
<span class="line-modified">!   address start_address_as_decoded_from_archive(CDSFileMapRegion* spc) {</span>
      return decode_start_address(spc, false);
    }
  
<span class="line-modified">!   address decode_start_address(CDSFileMapRegion* spc, bool with_current_oop_encoding_mode);</span>
  
  #if INCLUDE_JVMTI
    static ClassPathEntry** _classpath_entries_for_jvmti;
    static ClassPathEntry* get_classpath_entry_for_jvmti(int i, TRAPS);
  #endif
<span class="line-new-header">--- 470,101 ---</span>
    bool  remap_shared_readonly_as_readwrite();
  
    // Errors.
    static void fail_stop(const char *msg, ...) ATTRIBUTE_PRINTF(1, 2);
    static void fail_continue(const char *msg, ...) ATTRIBUTE_PRINTF(1, 2);
<span class="line-modified">!   static bool memory_mapping_failed() {</span>
<span class="line-added">+     CDS_ONLY(return _memory_mapping_failed;)</span>
<span class="line-added">+     NOT_CDS(return false;)</span>
<span class="line-added">+   }</span>
    bool is_in_shared_region(const void* p, int idx) NOT_CDS_RETURN_(false);
  
    // Stop CDS sharing and unmap CDS regions.
    static void stop_sharing_and_unmap(const char* msg);
  
    static void allocate_shared_path_table();
<span class="line-added">+   static int add_shared_classpaths(int i, const char* which, ClassPathEntry *cpe, TRAPS);</span>
    static void check_nonempty_dir_in_shared_path_table();
    bool validate_shared_path_table();
<span class="line-modified">!   void validate_non_existent_class_paths();</span>
<span class="line-added">+   static void set_shared_path_table(FileMapInfo* info) {</span>
<span class="line-added">+     _shared_path_table = info-&gt;header()-&gt;shared_path_table();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   static void update_jar_manifest(ClassPathEntry *cpe, SharedClassPathEntry* ent, TRAPS);</span>
<span class="line-added">+   static int num_non_existent_class_paths();</span>
<span class="line-added">+   static void record_non_existent_class_path_entry(const char* path);</span>
  
  #if INCLUDE_JVMTI
<span class="line-modified">!   static ClassFileStream* open_stream_for_jvmti(InstanceKlass* ik, Handle class_loader, TRAPS);</span>
  #endif
  
    static SharedClassPathEntry* shared_path(int index) {
<span class="line-modified">!     return _shared_path_table.path_at(index);</span>
    }
  
    static const char* shared_path_name(int index) {
      assert(index &gt;= 0, &quot;Sanity&quot;);
      return shared_path(index)-&gt;name();
    }
  
    static int get_number_of_shared_paths() {
<span class="line-modified">!     return _shared_path_table.size();</span>
    }
  
    char* region_addr(int idx);
  
<span class="line-added">+   // The offset of the first core region in the archive, relative to SharedBaseAddress</span>
<span class="line-added">+   size_t mapping_base_offset() const { return first_core_space()-&gt;mapping_offset(); }</span>
<span class="line-added">+   // The offset of the (exclusive) end of the last core region in this archive, relative to SharedBaseAddress</span>
<span class="line-added">+   size_t mapping_end_offset()  const { return last_core_space()-&gt;mapping_end_offset(); }</span>
<span class="line-added">+ </span>
<span class="line-added">+   char* mapped_base()    const { return first_core_space()-&gt;mapped_base(); }</span>
<span class="line-added">+   char* mapped_end()     const { return last_core_space()-&gt;mapped_end();   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Non-zero if the archive needs to be mapped a non-default location due to ASLR.</span>
<span class="line-added">+   intx relocation_delta() const {</span>
<span class="line-added">+     return header()-&gt;mapped_base_address() - header()-&gt;requested_base_address();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   FileMapRegion* first_core_space() const;</span>
<span class="line-added">+   FileMapRegion* last_core_space() const;</span>
<span class="line-added">+ </span>
   private:
<span class="line-added">+   void  seek_to_position(size_t pos);</span>
<span class="line-added">+   char* skip_first_path_entry(const char* path) NOT_CDS_RETURN_(NULL);</span>
<span class="line-added">+   int   num_paths(const char* path) NOT_CDS_RETURN_(0);</span>
<span class="line-added">+   GrowableArray&lt;const char*&gt;* create_path_array(const char* path) NOT_CDS_RETURN_(NULL);</span>
<span class="line-added">+   bool  classpath_failure(const char* msg, const char* name) NOT_CDS_RETURN_(false);</span>
<span class="line-added">+   bool  check_paths(int shared_path_start_idx, int num_paths,</span>
<span class="line-added">+                     GrowableArray&lt;const char*&gt;* rp_array) NOT_CDS_RETURN_(false);</span>
<span class="line-added">+   bool  validate_boot_class_paths() NOT_CDS_RETURN_(false);</span>
<span class="line-added">+   bool  validate_app_class_paths(int shared_app_paths_len) NOT_CDS_RETURN_(false);</span>
    bool  map_heap_data(MemRegion **heap_mem, int first, int max, int* num,
                        bool is_open = false) NOT_CDS_JAVA_HEAP_RETURN_(false);
<span class="line-modified">!   bool  region_crc_check(char* buf, size_t size, int expected_crc) NOT_CDS_RETURN_(false);</span>
<span class="line-modified">!   void  dealloc_archive_heap_regions(MemRegion* regions, int num) NOT_CDS_JAVA_HEAP_RETURN;</span>
<span class="line-modified">!   void  map_heap_regions_impl() NOT_CDS_JAVA_HEAP_RETURN;</span>
<span class="line-modified">!   char* map_relocation_bitmap(size_t&amp; bitmap_size);</span>
<span class="line-modified">!   MapArchiveResult map_region(int i, intx addr_delta, char* mapped_base_address, ReservedSpace rs);</span>
<span class="line-modified">!   bool  read_region(int i, char* base, size_t size);</span>
<span class="line-added">+   bool  relocate_pointers(intx addr_delta);</span>
  
<span class="line-modified">!   FileMapRegion* space_at(int i) const {</span>
<span class="line-modified">!     return header()-&gt;space_at(i);</span>
    }
  
    // The starting address of spc, as calculated with CompressedOop::decode_non_null()
<span class="line-modified">!   address start_address_as_decoded_with_current_oop_encoding_mode(FileMapRegion* spc) {</span>
      return decode_start_address(spc, true);
    }
  
    // The starting address of spc, as calculated with HeapShared::decode_from_archive()
<span class="line-modified">!   address start_address_as_decoded_from_archive(FileMapRegion* spc) {</span>
      return decode_start_address(spc, false);
    }
  
<span class="line-modified">!   address decode_start_address(FileMapRegion* spc, bool with_current_oop_encoding_mode);</span>
  
  #if INCLUDE_JVMTI
    static ClassPathEntry** _classpath_entries_for_jvmti;
    static ClassPathEntry* get_classpath_entry_for_jvmti(int i, TRAPS);
  #endif
</pre>
<center><a href="filemap.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="freeList.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
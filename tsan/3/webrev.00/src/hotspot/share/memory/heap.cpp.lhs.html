<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/memory/heap.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1997, 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;memory/heap.hpp&quot;
 27 #include &quot;oops/oop.inline.hpp&quot;
 28 #include &quot;runtime/os.hpp&quot;
 29 #include &quot;services/memTracker.hpp&quot;
 30 #include &quot;utilities/align.hpp&quot;
<a name="2" id="anc2"></a>
 31 
 32 size_t CodeHeap::header_size() {
 33   return sizeof(HeapBlock);
 34 }
 35 
 36 
 37 // Implementation of Heap
 38 
 39 CodeHeap::CodeHeap(const char* name, const int code_blob_type)
 40   : _code_blob_type(code_blob_type) {
 41   _name                         = name;
 42   _number_of_committed_segments = 0;
 43   _number_of_reserved_segments  = 0;
 44   _segment_size                 = 0;
 45   _log2_segment_size            = 0;
 46   _next_segment                 = 0;
 47   _freelist                     = NULL;
<a name="3" id="anc3"></a>
 48   _freelist_segments            = 0;
 49   _freelist_length              = 0;
 50   _max_allocated_capacity       = 0;
 51   _blob_count                   = 0;
 52   _nmethod_count                = 0;
 53   _adapter_count                = 0;
 54   _full_count                   = 0;
<a name="4" id="anc4"></a>
 55 }
 56 
<a name="5" id="anc5"></a>

 57 
<a name="6" id="anc6"></a>














 58 void CodeHeap::mark_segmap_as_free(size_t beg, size_t end) {
<a name="7" id="anc7"></a><span class="line-modified"> 59   assert(              beg &lt;  _number_of_committed_segments, &quot;interval begin out of bounds&quot;);</span>
<span class="line-modified"> 60   assert(beg &lt;  end &amp;&amp; end &lt;= _number_of_committed_segments, &quot;interval end   out of bounds&quot;);</span>
<span class="line-modified"> 61   // setup _segmap pointers for faster indexing</span>
<span class="line-modified"> 62   address p = (address)_segmap.low() + beg;</span>
<span class="line-modified"> 63   address q = (address)_segmap.low() + end;</span>
<span class="line-modified"> 64   // initialize interval</span>
<span class="line-modified"> 65   while (p &lt; q) *p++ = free_sentinel;</span>
<span class="line-modified"> 66 }</span>
<span class="line-modified"> 67 </span>
<span class="line-modified"> 68 </span>
<span class="line-modified"> 69 void CodeHeap::mark_segmap_as_used(size_t beg, size_t end) {</span>
<span class="line-modified"> 70   assert(              beg &lt;  _number_of_committed_segments, &quot;interval begin out of bounds&quot;);</span>
<span class="line-modified"> 71   assert(beg &lt;  end &amp;&amp; end &lt;= _number_of_committed_segments, &quot;interval end   out of bounds&quot;);</span>
<span class="line-modified"> 72   // setup _segmap pointers for faster indexing</span>
<span class="line-modified"> 73   address p = (address)_segmap.low() + beg;</span>
<span class="line-modified"> 74   address q = (address)_segmap.low() + end;</span>
<span class="line-modified"> 75   // initialize interval</span>
<span class="line-modified"> 76   int i = 0;</span>
<span class="line-modified"> 77   while (p &lt; q) {</span>
<span class="line-modified"> 78     *p++ = i++;</span>
<span class="line-modified"> 79     if (i == free_sentinel) i = 1;</span>

































































 80   }
 81 }
 82 
<a name="8" id="anc8"></a>



















 83 
 84 static size_t align_to_page_size(size_t size) {
 85   const size_t alignment = (size_t)os::vm_page_size();
 86   assert(is_power_of_2(alignment), &quot;no kidding ???&quot;);
 87   return (size + alignment - 1) &amp; ~(alignment - 1);
 88 }
 89 
 90 
 91 void CodeHeap::on_code_mapping(char* base, size_t size) {
 92 #ifdef LINUX
 93   extern void linux_wrap_code(char* base, size_t size);
 94   linux_wrap_code(base, size);
 95 #endif
 96 }
 97 
 98 
 99 bool CodeHeap::reserve(ReservedSpace rs, size_t committed_size, size_t segment_size) {
100   assert(rs.size() &gt;= committed_size, &quot;reserved &lt; committed&quot;);
101   assert(segment_size &gt;= sizeof(FreeBlock), &quot;segment size is too small&quot;);
102   assert(is_power_of_2(segment_size), &quot;segment_size must be a power of 2&quot;);
103 
104   _segment_size      = segment_size;
105   _log2_segment_size = exact_log2(segment_size);
106 
107   // Reserve and initialize space for _memory.
108   size_t page_size = os::vm_page_size();
109   if (os::can_execute_large_page_memory()) {
110     const size_t min_pages = 8;
111     page_size = MIN2(os::page_size_for_region_aligned(committed_size, min_pages),
112                      os::page_size_for_region_aligned(rs.size(), min_pages));
113   }
114 
115   const size_t granularity = os::vm_allocation_granularity();
116   const size_t c_size = align_up(committed_size, page_size);
117 
118   os::trace_page_sizes(_name, committed_size, rs.size(), page_size,
119                        rs.base(), rs.size());
120   if (!_memory.initialize(rs, c_size)) {
121     return false;
122   }
123 
124   on_code_mapping(_memory.low(), _memory.committed_size());
125   _number_of_committed_segments = size_to_segments(_memory.committed_size());
126   _number_of_reserved_segments  = size_to_segments(_memory.reserved_size());
127   assert(_number_of_reserved_segments &gt;= _number_of_committed_segments, &quot;just checking&quot;);
128   const size_t reserved_segments_alignment = MAX2((size_t)os::vm_page_size(), granularity);
129   const size_t reserved_segments_size = align_up(_number_of_reserved_segments, reserved_segments_alignment);
130   const size_t committed_segments_size = align_to_page_size(_number_of_committed_segments);
131 
132   // reserve space for _segmap
133   if (!_segmap.initialize(reserved_segments_size, committed_segments_size)) {
134     return false;
135   }
136 
137   MemTracker::record_virtual_memory_type((address)_segmap.low_boundary(), mtCode);
138 
139   assert(_segmap.committed_size() &gt;= (size_t) _number_of_committed_segments, &quot;could not commit  enough space for segment map&quot;);
140   assert(_segmap.reserved_size()  &gt;= (size_t) _number_of_reserved_segments , &quot;could not reserve enough space for segment map&quot;);
141   assert(_segmap.reserved_size()  &gt;= _segmap.committed_size()     , &quot;just checking&quot;);
142 
<a name="9" id="anc9"></a><span class="line-modified">143   // initialize remaining instance variables</span>
144   clear();
<a name="10" id="anc10"></a>
145   return true;
146 }
147 
148 
149 bool CodeHeap::expand_by(size_t size) {
150   // expand _memory space
151   size_t dm = align_to_page_size(_memory.committed_size() + size) - _memory.committed_size();
152   if (dm &gt; 0) {
153     // Use at least the available uncommitted space if &#39;size&#39; is larger
154     if (_memory.uncommitted_size() != 0 &amp;&amp; dm &gt; _memory.uncommitted_size()) {
155       dm = _memory.uncommitted_size();
156     }
157     char* base = _memory.low() + _memory.committed_size();
158     if (!_memory.expand_by(dm)) return false;
159     on_code_mapping(base, dm);
160     size_t i = _number_of_committed_segments;
161     _number_of_committed_segments = size_to_segments(_memory.committed_size());
162     assert(_number_of_reserved_segments == size_to_segments(_memory.reserved_size()), &quot;number of reserved segments should not change&quot;);
163     assert(_number_of_reserved_segments &gt;= _number_of_committed_segments, &quot;just checking&quot;);
164     // expand _segmap space
165     size_t ds = align_to_page_size(_number_of_committed_segments) - _segmap.committed_size();
166     if ((ds &gt; 0) &amp;&amp; !_segmap.expand_by(ds)) {
167       return false;
168     }
169     assert(_segmap.committed_size() &gt;= (size_t) _number_of_committed_segments, &quot;just checking&quot;);
<a name="11" id="anc11"></a><span class="line-modified">170     // initialize additional segmap entries</span>
<span class="line-modified">171     mark_segmap_as_free(i, _number_of_committed_segments);</span>
172   }
173   return true;
174 }
175 
<a name="12" id="anc12"></a><span class="line-removed">176 void CodeHeap::clear() {</span>
<span class="line-removed">177   _next_segment = 0;</span>
<span class="line-removed">178   mark_segmap_as_free(0, _number_of_committed_segments);</span>
<span class="line-removed">179 }</span>
<span class="line-removed">180 </span>
181 
182 void* CodeHeap::allocate(size_t instance_size) {
183   size_t number_of_segments = size_to_segments(instance_size + header_size());
184   assert(segments_to_size(number_of_segments) &gt;= sizeof(FreeBlock), &quot;not enough room for FreeList&quot;);
185 
186   // First check if we can satisfy request from freelist
187   NOT_PRODUCT(verify());
188   HeapBlock* block = search_freelist(number_of_segments);
189   NOT_PRODUCT(verify());
190 
191   if (block != NULL) {
<a name="13" id="anc13"></a><span class="line-modified">192     assert(block-&gt;length() &gt;= number_of_segments &amp;&amp; block-&gt;length() &lt; number_of_segments + CodeCacheMinBlockLength, &quot;sanity check&quot;);</span>
<span class="line-removed">193     assert(!block-&gt;free(), &quot;must be marked free&quot;);</span>
194     guarantee((char*) block &gt;= _memory.low_boundary() &amp;&amp; (char*) block &lt; _memory.high(),
195               &quot;The newly allocated block &quot; INTPTR_FORMAT &quot; is not within the heap &quot;
196               &quot;starting with &quot;  INTPTR_FORMAT &quot; and ending with &quot;  INTPTR_FORMAT,
197               p2i(block), p2i(_memory.low_boundary()), p2i(_memory.high()));
<a name="14" id="anc14"></a><span class="line-removed">198     DEBUG_ONLY(memset((void*)block-&gt;allocated_space(), badCodeHeapNewVal, instance_size));</span>
199     _max_allocated_capacity = MAX2(_max_allocated_capacity, allocated_capacity());
200     _blob_count++;
201     return block-&gt;allocated_space();
202   }
203 
204   // Ensure minimum size for allocation to the heap.
205   number_of_segments = MAX2((int)CodeCacheMinBlockLength, (int)number_of_segments);
206 
207   if (_next_segment + number_of_segments &lt;= _number_of_committed_segments) {
<a name="15" id="anc15"></a><span class="line-modified">208     mark_segmap_as_used(_next_segment, _next_segment + number_of_segments);</span>
<span class="line-modified">209     HeapBlock* b =  block_at(_next_segment);</span>
<span class="line-modified">210     b-&gt;initialize(number_of_segments);</span>
211     _next_segment += number_of_segments;
<a name="16" id="anc16"></a><span class="line-modified">212     guarantee((char*) b &gt;= _memory.low_boundary() &amp;&amp; (char*) block &lt; _memory.high(),</span>
213               &quot;The newly allocated block &quot; INTPTR_FORMAT &quot; is not within the heap &quot;
214               &quot;starting with &quot;  INTPTR_FORMAT &quot; and ending with &quot; INTPTR_FORMAT,
<a name="17" id="anc17"></a><span class="line-modified">215               p2i(b), p2i(_memory.low_boundary()), p2i(_memory.high()));</span>
<span class="line-removed">216     DEBUG_ONLY(memset((void *)b-&gt;allocated_space(), badCodeHeapNewVal, instance_size));</span>
217     _max_allocated_capacity = MAX2(_max_allocated_capacity, allocated_capacity());
218     _blob_count++;
<a name="18" id="anc18"></a><span class="line-modified">219     return b-&gt;allocated_space();</span>
220   } else {
221     return NULL;
222   }
223 }
224 
<a name="19" id="anc19"></a>
























225 void CodeHeap::deallocate_tail(void* p, size_t used_size) {
226   assert(p == find_start(p), &quot;illegal deallocation&quot;);
227   // Find start of HeapBlock
228   HeapBlock* b = (((HeapBlock *)p) - 1);
229   assert(b-&gt;allocated_space() == p, &quot;sanity check&quot;);
<a name="20" id="anc20"></a><span class="line-modified">230   size_t used_number_of_segments = size_to_segments(used_size + header_size());</span>
231   size_t actual_number_of_segments = b-&gt;length();
<a name="21" id="anc21"></a>

232   guarantee(used_number_of_segments &lt;= actual_number_of_segments, &quot;Must be!&quot;);
<a name="22" id="anc22"></a><span class="line-modified">233   guarantee(b == block_at(_next_segment - actual_number_of_segments), &quot;Intermediate allocation!&quot;);</span>
<span class="line-modified">234   size_t number_of_segments_to_deallocate = actual_number_of_segments - used_number_of_segments;</span>
<span class="line-modified">235   _next_segment -= number_of_segments_to_deallocate;</span>
<span class="line-modified">236   mark_segmap_as_free(_next_segment, _next_segment + number_of_segments_to_deallocate);</span>
<span class="line-removed">237   b-&gt;initialize(used_number_of_segments);</span>
238 }
239 
240 void CodeHeap::deallocate(void* p) {
241   assert(p == find_start(p), &quot;illegal deallocation&quot;);
242   // Find start of HeapBlock
243   HeapBlock* b = (((HeapBlock *)p) - 1);
244   assert(b-&gt;allocated_space() == p, &quot;sanity check&quot;);
245   guarantee((char*) b &gt;= _memory.low_boundary() &amp;&amp; (char*) b &lt; _memory.high(),
246             &quot;The block to be deallocated &quot; INTPTR_FORMAT &quot; is not within the heap &quot;
247             &quot;starting with &quot;  INTPTR_FORMAT &quot; and ending with &quot; INTPTR_FORMAT,
248             p2i(b), p2i(_memory.low_boundary()), p2i(_memory.high()));
<a name="23" id="anc23"></a><span class="line-removed">249   DEBUG_ONLY(memset((void *)b-&gt;allocated_space(), badCodeHeapFreeVal,</span>
<span class="line-removed">250              segments_to_size(b-&gt;length()) - sizeof(HeapBlock)));</span>
251   add_to_freelist(b);
252   NOT_PRODUCT(verify());
253 }
254 
255 /**
<a name="24" id="anc24"></a><span class="line-modified">256  * Uses segment map to find the the start (header) of a nmethod. This works as follows:</span>
<span class="line-modified">257  * The memory of the code cache is divided into &#39;segments&#39;. The size of a segment is</span>
<span class="line-modified">258  * determined by -XX:CodeCacheSegmentSize=XX. Allocation in the code cache can only</span>
<span class="line-modified">259  * happen at segment boundaries. A pointer in the code cache can be mapped to a segment</span>
<span class="line-modified">260  * by calling segment_for(addr). Each time memory is requested from the code cache,</span>
<span class="line-modified">261  * the segmap is updated accordingly. See the following example, which illustrates the</span>
<span class="line-modified">262  * state of code cache and the segment map: (seg -&gt; segment, nm -&gt;nmethod)</span>






























263  *
264  *          code cache          segmap
265  *         -----------        ---------
266  * seg 1   | nm 1    |   -&gt;   | 0     |
267  * seg 2   | nm 1    |   -&gt;   | 1     |
268  * ...     | nm 1    |   -&gt;   | ..    |
<a name="25" id="anc25"></a>
269  * seg m   | nm 2    |   -&gt;   | 0     |
270  * seg m+1 | nm 2    |   -&gt;   | 1     |
271  * ...     | nm 2    |   -&gt;   | 2     |
272  * ...     | nm 2    |   -&gt;   | ..    |
<a name="26" id="anc26"></a><span class="line-modified">273  * ...     | nm 2    |   -&gt;   | 0xFE  |</span>
<span class="line-modified">274  * seg m+n | nm 2    |   -&gt;   | 1     |</span>

275  * ...     | nm 2    |   -&gt;   |       |
276  *
<a name="27" id="anc27"></a><span class="line-modified">277  * A value of &#39;0&#39; in the segmap indicates that this segment contains the beginning of</span>
<span class="line-modified">278  * an nmethod. Let&#39;s walk through a simple example: If we want to find the start of</span>
<span class="line-modified">279  * an nmethod that falls into seg 2, we read the value of the segmap[2]. The value</span>
<span class="line-modified">280  * is an offset that points to the segment that contains the start of the nmethod.</span>
<span class="line-modified">281  * Another example: If we want to get the start of nm 2, and we happen to get a pointer</span>
<span class="line-modified">282  * that points to seg m+n, we first read seg[n+m], which returns &#39;1&#39;. So we have to</span>
<span class="line-modified">283  * do one more read of the segmap[m+n-1] to finally get the segment header.</span>






284  */
<a name="28" id="anc28"></a><span class="line-modified">285 void* CodeHeap::find_start(void* p) const {</span>





286   if (!contains(p)) {
287     return NULL;
288   }
<a name="29" id="anc29"></a><span class="line-modified">289   size_t seg_idx = segment_for(p);</span>
290   address seg_map = (address)_segmap.low();
<a name="30" id="anc30"></a>



291   if (is_segment_unused(seg_map[seg_idx])) {
292     return NULL;
293   }
<a name="31" id="anc31"></a>

294   while (seg_map[seg_idx] &gt; 0) {
<a name="32" id="anc32"></a>



295     seg_idx -= (int)seg_map[seg_idx];
296   }
297 
<a name="33" id="anc33"></a><span class="line-modified">298   HeapBlock* h = block_at(seg_idx);</span>
<span class="line-modified">299   if (h-&gt;free()) {</span>
<span class="line-modified">300     return NULL;</span>
<span class="line-modified">301   }</span>
<span class="line-modified">302   return h-&gt;allocated_space();</span>




303 }
304 
<a name="34" id="anc34"></a>

305 CodeBlob* CodeHeap::find_blob_unsafe(void* start) const {
306   CodeBlob* result = (CodeBlob*)CodeHeap::find_start(start);
<a name="35" id="anc35"></a><span class="line-modified">307   if (result != NULL &amp;&amp; result-&gt;blob_contains((address)start)) {</span>
<span class="line-removed">308     return result;</span>
<span class="line-removed">309   }</span>
<span class="line-removed">310   return NULL;</span>
311 }
312 
313 size_t CodeHeap::alignment_unit() const {
314   // this will be a power of two
315   return _segment_size;
316 }
317 
318 
319 size_t CodeHeap::alignment_offset() const {
320   // The lowest address in any allocated block will be
321   // equal to alignment_offset (mod alignment_unit).
322   return sizeof(HeapBlock) &amp; (_segment_size - 1);
323 }
324 
325 // Returns the current block if available and used.
326 // If not, it returns the subsequent block (if available), NULL otherwise.
327 // Free blocks are merged, therefore there is at most one free block
328 // between two used ones. As a result, the subsequent block (if available) is
329 // guaranteed to be used.
<a name="36" id="anc36"></a>
330 void* CodeHeap::next_used(HeapBlock* b) const {
331   if (b != NULL &amp;&amp; b-&gt;free()) b = next_block(b);
332   assert(b == NULL || !b-&gt;free(), &quot;must be in use or at end of heap&quot;);
333   return (b == NULL) ? NULL : b-&gt;allocated_space();
334 }
335 
336 // Returns the first used HeapBlock
<a name="37" id="anc37"></a>
337 HeapBlock* CodeHeap::first_block() const {
338   if (_next_segment &gt; 0)
339     return block_at(0);
340   return NULL;
341 }
342 
<a name="38" id="anc38"></a>
343 HeapBlock* CodeHeap::block_start(void* q) const {
344   HeapBlock* b = (HeapBlock*)find_start(q);
345   if (b == NULL) return NULL;
346   return b - 1;
347 }
348 
<a name="39" id="anc39"></a><span class="line-modified">349 // Returns the next Heap block an offset into one</span>

350 HeapBlock* CodeHeap::next_block(HeapBlock *b) const {
351   if (b == NULL) return NULL;
352   size_t i = segment_for(b) + b-&gt;length();
353   if (i &lt; _next_segment)
354     return block_at(i);
355   return NULL;
356 }
357 
358 
359 // Returns current capacity
360 size_t CodeHeap::capacity() const {
361   return _memory.committed_size();
362 }
363 
364 size_t CodeHeap::max_capacity() const {
365   return _memory.reserved_size();
366 }
367 
368 int CodeHeap::allocated_segments() const {
369   return (int)_next_segment;
370 }
371 
372 size_t CodeHeap::allocated_capacity() const {
373   // size of used heap - size on freelist
374   return segments_to_size(_next_segment - _freelist_segments);
375 }
376 
377 // Returns size of the unallocated heap block
378 size_t CodeHeap::heap_unallocated_capacity() const {
379   // Total number of segments - number currently used
380   return segments_to_size(_number_of_reserved_segments - _next_segment);
381 }
382 
383 // Free list management
384 
385 FreeBlock* CodeHeap::following_block(FreeBlock *b) {
386   return (FreeBlock*)(((address)b) + _segment_size * b-&gt;length());
387 }
388 
389 // Inserts block b after a
390 void CodeHeap::insert_after(FreeBlock* a, FreeBlock* b) {
391   assert(a != NULL &amp;&amp; b != NULL, &quot;must be real pointers&quot;);
392 
393   // Link b into the list after a
394   b-&gt;set_link(a-&gt;link());
395   a-&gt;set_link(b);
396 
397   // See if we can merge blocks
398   merge_right(b); // Try to make b bigger
399   merge_right(a); // Try to make a include b
400 }
401 
402 // Try to merge this block with the following block
403 bool CodeHeap::merge_right(FreeBlock* a) {
404   assert(a-&gt;free(), &quot;must be a free block&quot;);
405   if (following_block(a) == a-&gt;link()) {
406     assert(a-&gt;link() != NULL &amp;&amp; a-&gt;link()-&gt;free(), &quot;must be free too&quot;);
<a name="40" id="anc40"></a><span class="line-modified">407     // Update block a to include the following block</span>



408     a-&gt;set_length(a-&gt;length() + a-&gt;link()-&gt;length());
409     a-&gt;set_link(a-&gt;link()-&gt;link());
<a name="41" id="anc41"></a><span class="line-modified">410     // Update find_start map</span>
<span class="line-modified">411     size_t beg = segment_for(a);</span>
<span class="line-modified">412     mark_segmap_as_used(beg, beg + a-&gt;length());</span>





413     _freelist_length--;
414     return true;
415   }
416   return false;
417 }
418 
419 
420 void CodeHeap::add_to_freelist(HeapBlock* a) {
421   FreeBlock* b = (FreeBlock*)a;
<a name="42" id="anc42"></a>
422   _freelist_length++;
423 
<a name="43" id="anc43"></a><span class="line-modified">424   assert(b != _freelist, &quot;cannot be removed twice&quot;);</span>

425 
<a name="44" id="anc44"></a>
426 
427   // Mark as free and update free space count
428   _freelist_segments += b-&gt;length();
429   b-&gt;set_free();
<a name="45" id="anc45"></a>
430 
431   // First element in list?
432   if (_freelist == NULL) {
<a name="46" id="anc46"></a><span class="line-removed">433     _freelist = b;</span>
434     b-&gt;set_link(NULL);
<a name="47" id="anc47"></a>
435     return;
436   }
437 
438   // Since the freelist is ordered (smaller addresses -&gt; larger addresses) and the
439   // element we want to insert into the freelist has a smaller address than the first
440   // element, we can simply add &#39;b&#39; as the first element and we are done.
441   if (b &lt; _freelist) {
442     // Insert first in list
443     b-&gt;set_link(_freelist);
444     _freelist = b;
445     merge_right(_freelist);
446     return;
447   }
448 
<a name="48" id="anc48"></a><span class="line-modified">449   // Scan for right place to put into list. List</span>
<span class="line-modified">450   // is sorted by increasing addresses</span>
451   FreeBlock* prev = _freelist;
452   FreeBlock* cur  = _freelist-&gt;link();
<a name="49" id="anc49"></a>






453   while(cur != NULL &amp;&amp; cur &lt; b) {
454     assert(prev &lt; cur, &quot;Freelist must be ordered&quot;);
455     prev = cur;
456     cur  = cur-&gt;link();
457   }
458   assert((prev &lt; b) &amp;&amp; (cur == NULL || b &lt; cur), &quot;free-list must be ordered&quot;);
459   insert_after(prev, b);
<a name="50" id="anc50"></a>
460 }
461 
462 /**
463  * Search freelist for an entry on the list with the best fit.
464  * @return NULL, if no one was found
465  */
<a name="51" id="anc51"></a><span class="line-modified">466 FreeBlock* CodeHeap::search_freelist(size_t length) {</span>
<span class="line-modified">467   FreeBlock* found_block = NULL;</span>
<span class="line-modified">468   FreeBlock* found_prev  = NULL;</span>
<span class="line-modified">469   size_t     found_length = 0;</span>
470 
<a name="52" id="anc52"></a>
471   FreeBlock* prev = NULL;
<a name="53" id="anc53"></a><span class="line-modified">472   FreeBlock* cur = _freelist;</span>
473 
<a name="54" id="anc54"></a><span class="line-modified">474   // Search for first block that fits</span>
<span class="line-removed">475   while(cur != NULL) {</span>
<span class="line-removed">476     if (cur-&gt;length() &gt;= length) {</span>
<span class="line-removed">477       // Remember block, its previous element, and its length</span>
<span class="line-removed">478       found_block = cur;</span>
<span class="line-removed">479       found_prev  = prev;</span>
<span class="line-removed">480       found_length = found_block-&gt;length();</span>
481 
<a name="55" id="anc55"></a>







482       break;
<a name="56" id="anc56"></a>




483     }
484     // Next element in list
485     prev = cur;
486     cur  = cur-&gt;link();
487   }
488 
489   if (found_block == NULL) {
490     // None found
491     return NULL;
492   }
493 
494   // Exact (or at least good enough) fit. Remove from list.
495   // Don&#39;t leave anything on the freelist smaller than CodeCacheMinBlockLength.
496   if (found_length - length &lt; CodeCacheMinBlockLength) {
497     _freelist_length--;
498     length = found_length;
499     if (found_prev == NULL) {
500       assert(_freelist == found_block, &quot;sanity check&quot;);
501       _freelist = _freelist-&gt;link();
502     } else {
503       assert((found_prev-&gt;link() == found_block), &quot;sanity check&quot;);
504       // Unmap element
505       found_prev-&gt;set_link(found_block-&gt;link());
506     }
<a name="57" id="anc57"></a>






507   } else {
<a name="58" id="anc58"></a><span class="line-modified">508     // Truncate block and return a pointer to the following block</span>
<span class="line-modified">509     // Set used bit and length on new block</span>
<span class="line-modified">510     found_block-&gt;set_length(found_length - length);</span>
<span class="line-modified">511     found_block = following_block(found_block);</span>
<span class="line-modified">512 </span>
<span class="line-removed">513     size_t beg = segment_for(found_block);</span>
<span class="line-removed">514     mark_segmap_as_used(beg, beg + length);</span>
<span class="line-removed">515     found_block-&gt;set_length(length);</span>
516   }
517 
<a name="59" id="anc59"></a><span class="line-modified">518   found_block-&gt;set_used();</span>
519   _freelist_segments -= length;
<a name="60" id="anc60"></a><span class="line-modified">520   return found_block;</span>













































521 }
522 
523 //----------------------------------------------------------------------------
524 // Non-product code
525 
526 #ifndef PRODUCT
527 
528 void CodeHeap::print() {
529   tty-&gt;print_cr(&quot;The Heap&quot;);
530 }
531 
532 void CodeHeap::verify() {
533   if (VerifyCodeCache) {
534     size_t len = 0;
535     int count = 0;
536     for(FreeBlock* b = _freelist; b != NULL; b = b-&gt;link()) {
537       len += b-&gt;length();
538       count++;
539       // Check if we have merged all free blocks
540       assert(merge_right(b) == false, &quot;Missed merging opportunity&quot;);
541     }
542     // Verify that freelist contains the right amount of free space
543     assert(len == _freelist_segments, &quot;wrong freelist&quot;);
544 
545     for(HeapBlock* h = first_block(); h != NULL; h = next_block(h)) {
546       if (h-&gt;free()) count--;
547     }
548     // Verify that the freelist contains the same number of blocks
549     // than free blocks found on the full list.
550     assert(count == 0, &quot;missing free blocks&quot;);
551 
<a name="61" id="anc61"></a>



























552     // Verify that the number of free blocks is not out of hand.
553     static int free_block_threshold = 10000;
554     if (count &gt; free_block_threshold) {
555       warning(&quot;CodeHeap: # of free blocks &gt; %d&quot;, free_block_threshold);
556       // Double the warning limit
557       free_block_threshold *= 2;
558     }
559   }
560 }
561 
562 #endif
<a name="62" id="anc62"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="62" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/allocation.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="allocation.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="allocation.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/allocation.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_MEMORY_ALLOCATION_HPP
 26 #define SHARE_MEMORY_ALLOCATION_HPP
 27 
<span class="line-removed"> 28 #include &quot;runtime/globals.hpp&quot;</span>
 29 #include &quot;utilities/globalDefinitions.hpp&quot;
 30 #include &quot;utilities/macros.hpp&quot;
 31 
 32 #include &lt;new&gt;
 33 

 34 class Thread;
 35 
 36 class AllocFailStrategy {
 37 public:
 38   enum AllocFailEnum { EXIT_OOM, RETURN_NULL };
 39 };
 40 typedef AllocFailStrategy::AllocFailEnum AllocFailType;
 41 
 42 // The virtual machine must never call one of the implicitly declared
 43 // global allocation or deletion functions.  (Such calls may result in
 44 // link-time or run-time errors.)  For convenience and documentation of
 45 // intended use, classes in the virtual machine may be derived from one
 46 // of the following allocation classes, some of which define allocation
 47 // and deletion functions.
 48 // Note: std::malloc and std::free should never called directly.
 49 
 50 //
 51 // For objects allocated in the resource area (see resourceArea.hpp).
 52 // - ResourceObj
 53 //
</pre>
<hr />
<pre>
 63 // For classes in Metaspace (class data)
 64 // - MetaspaceObj
 65 //
 66 // The printable subclasses are used for debugging and define virtual
 67 // member functions for printing. Classes that avoid allocating the
 68 // vtbl entries in the objects should therefore not be the printable
 69 // subclasses.
 70 //
 71 // The following macros and function should be used to allocate memory
 72 // directly in the resource area or in the C-heap, The _OBJ variants
 73 // of the NEW/FREE_C_HEAP macros are used for alloc/dealloc simple
 74 // objects which are not inherited from CHeapObj, note constructor and
 75 // destructor are not called. The preferable way to allocate objects
 76 // is using the new operator.
 77 //
 78 // WARNING: The array variant must only be used for a homogenous array
 79 // where all objects are of the exact type specified. If subtypes are
 80 // stored in the array then must pay attention to calling destructors
 81 // at needed.
 82 //
<span class="line-modified"> 83 //   NEW_RESOURCE_ARRAY(type, size)</span>
<span class="line-modified"> 84 //   NEW_RESOURCE_OBJ(type)</span>
<span class="line-modified"> 85 //   NEW_C_HEAP_ARRAY(type, size)</span>
<span class="line-modified"> 86 //   NEW_C_HEAP_OBJ(type, memflags)</span>
<span class="line-modified"> 87 //   FREE_C_HEAP_ARRAY(type, old)</span>
<span class="line-modified"> 88 //   FREE_C_HEAP_OBJ(objname, type, memflags)</span>
<span class="line-modified"> 89 //   char* AllocateHeap(size_t size, const char* name);</span>
<span class="line-modified"> 90 //   void  FreeHeap(void* p);</span>






 91 //
<span class="line-removed"> 92 </span>
 93 // In non product mode we introduce a super class for all allocation classes
 94 // that supports printing.
 95 // We avoid the superclass in product mode to save space.
 96 
 97 #ifdef PRODUCT
 98 #define ALLOCATION_SUPER_CLASS_SPEC
 99 #else
100 #define ALLOCATION_SUPER_CLASS_SPEC : public AllocatedObj
101 class AllocatedObj {
102  public:
103   // Printing support
104   void print() const;
105   void print_value() const;
106 
107   virtual void print_on(outputStream* st) const;
108   virtual void print_value_on(outputStream* st) const;
109 };
110 #endif
111 
112 #define MEMORY_TYPES_DO(f) \
113   /* Memory type by sub systems. It occupies lower byte. */  \
114   f(mtJavaHeap,      &quot;Java Heap&quot;)   /* Java heap                                 */ \
115   f(mtClass,         &quot;Class&quot;)       /* Java classes                              */ \
116   f(mtThread,        &quot;Thread&quot;)      /* thread objects                            */ \
117   f(mtThreadStack,   &quot;Thread Stack&quot;)                                                \
118   f(mtCode,          &quot;Code&quot;)        /* generated code                            */ \
119   f(mtGC,            &quot;GC&quot;)                                                          \
120   f(mtCompiler,      &quot;Compiler&quot;)                                                    \

121   f(mtInternal,      &quot;Internal&quot;)    /* memory used by VM, but does not belong to */ \
122                                     /* any of above categories, and not used by  */ \
123                                     /* NMT                                       */ \
124   f(mtOther,         &quot;Other&quot;)       /* memory not used by VM                     */ \
125   f(mtSymbol,        &quot;Symbol&quot;)                                                      \
126   f(mtNMT,           &quot;Native Memory Tracking&quot;)  /* memory used by NMT            */ \
127   f(mtClassShared,   &quot;Shared class space&quot;)      /* class data sharing            */ \
128   f(mtChunk,         &quot;Arena Chunk&quot;) /* chunk that holds content of arenas        */ \
129   f(mtTest,          &quot;Test&quot;)        /* Test type for verifying NMT               */ \
130   f(mtTracing,       &quot;Tracing&quot;)                                                     \
131   f(mtLogging,       &quot;Logging&quot;)                                                     \

132   f(mtArguments,     &quot;Arguments&quot;)                                                   \
133   f(mtModule,        &quot;Module&quot;)                                                      \
134   f(mtSafepoint,     &quot;Safepoint&quot;)                                                   \
135   f(mtSynchronizer,  &quot;Synchronization&quot;)                                             \
136   f(mtNone,          &quot;Unknown&quot;)                                                     \
137   //end
138 
139 #define MEMORY_TYPE_DECLARE_ENUM(type, human_readable) \
140   type,
141 
142 /*
143  * Memory types
144  */
145 enum MemoryType {
146   MEMORY_TYPES_DO(MEMORY_TYPE_DECLARE_ENUM)
147   mt_number_of_types   // number of memory types (mtDontTrack
148                        // is not included as validate type)
149 };
150 
151 typedef MemoryType MEMFLAGS;
</pre>
<hr />
<pre>
160 const bool NMT_track_callsite = false;
161 
162 #endif // INCLUDE_NMT
163 
164 class NativeCallStack;
165 
166 
167 char* AllocateHeap(size_t size,
168                    MEMFLAGS flags,
169                    const NativeCallStack&amp; stack,
170                    AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);
171 char* AllocateHeap(size_t size,
172                    MEMFLAGS flags,
173                    AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);
174 
175 char* ReallocateHeap(char *old,
176                      size_t size,
177                      MEMFLAGS flag,
178                      AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);
179 

180 void FreeHeap(void* p);
181 
182 template &lt;MEMFLAGS F&gt; class CHeapObj ALLOCATION_SUPER_CLASS_SPEC {
183  public:
184   ALWAYSINLINE void* operator new(size_t size) throw() {
185     return (void*)AllocateHeap(size, F);
186   }
187 
188   ALWAYSINLINE void* operator new(size_t size,
189                                   const NativeCallStack&amp; stack) throw() {
190     return (void*)AllocateHeap(size, F, stack);
191   }
192 
193   ALWAYSINLINE void* operator new(size_t size, const std::nothrow_t&amp;,
194                                   const NativeCallStack&amp; stack) throw() {
195     return (void*)AllocateHeap(size, F, stack, AllocFailStrategy::RETURN_NULL);
196   }
197 
198   ALWAYSINLINE void* operator new(size_t size, const std::nothrow_t&amp;) throw() {
199     return (void*)AllocateHeap(size, F, AllocFailStrategy::RETURN_NULL);
</pre>
<hr />
<pre>
211   ALWAYSINLINE void* operator new[](size_t size, const std::nothrow_t&amp;,
212                                     const NativeCallStack&amp; stack) throw() {
213     return (void*)AllocateHeap(size, F, stack, AllocFailStrategy::RETURN_NULL);
214   }
215 
216   ALWAYSINLINE void* operator new[](size_t size, const std::nothrow_t&amp;) throw() {
217     return (void*)AllocateHeap(size, F, AllocFailStrategy::RETURN_NULL);
218   }
219 
220   void  operator delete(void* p)     { FreeHeap(p); }
221   void  operator delete [] (void* p) { FreeHeap(p); }
222 };
223 
224 // Base class for objects allocated on the stack only.
225 // Calling new or delete will result in fatal error.
226 
227 class StackObj ALLOCATION_SUPER_CLASS_SPEC {
228  private:
229   void* operator new(size_t size) throw();
230   void* operator new [](size_t size) throw();
<span class="line-removed">231 #ifdef __IBMCPP__</span>
<span class="line-removed">232  public:</span>
<span class="line-removed">233 #endif</span>
234   void  operator delete(void* p);
235   void  operator delete [](void* p);
236 };
237 
238 // Base class for objects stored in Metaspace.
239 // Calling delete will result in fatal error.
240 //
241 // Do not inherit from something with a vptr because this class does
242 // not introduce one.  This class is used to allocate both shared read-only
243 // and shared read-write classes.
244 //
245 
246 class ClassLoaderData;
247 class MetaspaceClosure;
248 
249 class MetaspaceObj {
250   friend class VMStructs;
251   // When CDS is enabled, all shared metaspace objects are mapped
252   // into a single contiguous memory block, so we can use these
253   // two pointers to quickly determine if something is in the
254   // shared metaspace.
<span class="line-removed">255   //</span>
256   // When CDS is not enabled, both pointers are set to NULL.
<span class="line-modified">257   static void* _shared_metaspace_base; // (inclusive) low address</span>
<span class="line-modified">258   static void* _shared_metaspace_top;  // (exclusive) high address</span>
259 
260  public:
<span class="line-modified">261   bool is_metaspace_object() const;</span>
<span class="line-modified">262   bool is_shared() const {</span>





263     // If no shared metaspace regions are mapped, _shared_metaspace_{base,top} will
264     // both be NULL and all values of p will be rejected quickly.
<span class="line-modified">265     return (((void*)this) &lt; _shared_metaspace_top &amp;&amp; ((void*)this) &gt;= _shared_metaspace_base);</span>

266   }


267   void print_address_on(outputStream* st) const;  // nonvirtual address printing
268 
269   static void set_shared_metaspace_range(void* base, void* top) {
270     _shared_metaspace_base = base;
271     _shared_metaspace_top = top;
272   }

273   static void* shared_metaspace_base() { return _shared_metaspace_base; }
274   static void* shared_metaspace_top()  { return _shared_metaspace_top;  }
275 
276 #define METASPACE_OBJ_TYPES_DO(f) \
277   f(Class) \
278   f(Symbol) \
279   f(TypeArrayU1) \
280   f(TypeArrayU2) \
281   f(TypeArrayU4) \
282   f(TypeArrayU8) \
283   f(TypeArrayOther) \
284   f(Method) \
285   f(ConstMethod) \
286   f(MethodData) \
287   f(ConstantPool) \
288   f(ConstantPoolCache) \
289   f(Annotations) \
<span class="line-modified">290   f(MethodCounters)</span>

291 
292 #define METASPACE_OBJ_TYPE_DECLARE(name) name ## Type,
293 #define METASPACE_OBJ_TYPE_NAME_CASE(name) case name ## Type: return #name;
294 
295   enum Type {
296     // Types are MetaspaceObj::ClassType, MetaspaceObj::SymbolType, etc
297     METASPACE_OBJ_TYPES_DO(METASPACE_OBJ_TYPE_DECLARE)
298     _number_of_types
299   };
300 
301   static const char * type_name(Type type) {
302     switch(type) {
303     METASPACE_OBJ_TYPES_DO(METASPACE_OBJ_TYPE_NAME_CASE)
304     default:
305       ShouldNotReachHere();
306       return NULL;
307     }
308   }
309 
310   static MetaspaceObj::Type array_type(size_t elem_size) {
</pre>
<hr />
<pre>
475 #define REALLOC_C_HEAP_ARRAY(type, old, size, memflags)\
476   (type*) (ReallocateHeap((char*)(old), (size) * sizeof(type), memflags))
477 
478 #define REALLOC_C_HEAP_ARRAY_RETURN_NULL(type, old, size, memflags)\
479   (type*) (ReallocateHeap((char*)(old), (size) * sizeof(type), memflags, AllocFailStrategy::RETURN_NULL))
480 
481 #define FREE_C_HEAP_ARRAY(type, old) \
482   FreeHeap((char*)(old))
483 
484 // allocate type in heap without calling ctor
485 #define NEW_C_HEAP_OBJ(type, memflags)\
486   NEW_C_HEAP_ARRAY(type, 1, memflags)
487 
488 #define NEW_C_HEAP_OBJ_RETURN_NULL(type, memflags)\
489   NEW_C_HEAP_ARRAY_RETURN_NULL(type, 1, memflags)
490 
491 // deallocate obj of type in heap without calling dtor
492 #define FREE_C_HEAP_OBJ(objname)\
493   FreeHeap((char*)objname);
494 
<span class="line-removed">495 // for statistics</span>
<span class="line-removed">496 #ifndef PRODUCT</span>
<span class="line-removed">497 class AllocStats : StackObj {</span>
<span class="line-removed">498   julong start_mallocs, start_frees;</span>
<span class="line-removed">499   julong start_malloc_bytes, start_mfree_bytes, start_res_bytes;</span>
<span class="line-removed">500  public:</span>
<span class="line-removed">501   AllocStats();</span>
<span class="line-removed">502 </span>
<span class="line-removed">503   julong num_mallocs();    // since creation of receiver</span>
<span class="line-removed">504   julong alloc_bytes();</span>
<span class="line-removed">505   julong num_frees();</span>
<span class="line-removed">506   julong free_bytes();</span>
<span class="line-removed">507   julong resource_bytes();</span>
<span class="line-removed">508   void   print();</span>
<span class="line-removed">509 };</span>
<span class="line-removed">510 #endif</span>
<span class="line-removed">511 </span>
512 
513 //------------------------------ReallocMark---------------------------------
514 // Code which uses REALLOC_RESOURCE_ARRAY should check an associated
515 // ReallocMark, which is declared in the same scope as the reallocated
516 // pointer.  Any operation that could __potentially__ cause a reallocation
517 // should check the ReallocMark.
518 class ReallocMark: public StackObj {
519 protected:
520   NOT_PRODUCT(int _nesting;)
521 
522 public:
523   ReallocMark()   PRODUCT_RETURN;
524   void check()    PRODUCT_RETURN;
525 };
526 
527 // Helper class to allocate arrays that may become large.
528 // Uses the OS malloc for allocations smaller than ArrayAllocatorMallocLimit
529 // and uses mapped memory for larger allocations.
530 // Most OS mallocs do something similar but Solaris malloc does not revert
531 // to mapped memory for large allocations. By default ArrayAllocatorMallocLimit
</pre>
</td>
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_MEMORY_ALLOCATION_HPP
 26 #define SHARE_MEMORY_ALLOCATION_HPP
 27 

 28 #include &quot;utilities/globalDefinitions.hpp&quot;
 29 #include &quot;utilities/macros.hpp&quot;
 30 
 31 #include &lt;new&gt;
 32 
<span class="line-added"> 33 class outputStream;</span>
 34 class Thread;
 35 
 36 class AllocFailStrategy {
 37 public:
 38   enum AllocFailEnum { EXIT_OOM, RETURN_NULL };
 39 };
 40 typedef AllocFailStrategy::AllocFailEnum AllocFailType;
 41 
 42 // The virtual machine must never call one of the implicitly declared
 43 // global allocation or deletion functions.  (Such calls may result in
 44 // link-time or run-time errors.)  For convenience and documentation of
 45 // intended use, classes in the virtual machine may be derived from one
 46 // of the following allocation classes, some of which define allocation
 47 // and deletion functions.
 48 // Note: std::malloc and std::free should never called directly.
 49 
 50 //
 51 // For objects allocated in the resource area (see resourceArea.hpp).
 52 // - ResourceObj
 53 //
</pre>
<hr />
<pre>
 63 // For classes in Metaspace (class data)
 64 // - MetaspaceObj
 65 //
 66 // The printable subclasses are used for debugging and define virtual
 67 // member functions for printing. Classes that avoid allocating the
 68 // vtbl entries in the objects should therefore not be the printable
 69 // subclasses.
 70 //
 71 // The following macros and function should be used to allocate memory
 72 // directly in the resource area or in the C-heap, The _OBJ variants
 73 // of the NEW/FREE_C_HEAP macros are used for alloc/dealloc simple
 74 // objects which are not inherited from CHeapObj, note constructor and
 75 // destructor are not called. The preferable way to allocate objects
 76 // is using the new operator.
 77 //
 78 // WARNING: The array variant must only be used for a homogenous array
 79 // where all objects are of the exact type specified. If subtypes are
 80 // stored in the array then must pay attention to calling destructors
 81 // at needed.
 82 //
<span class="line-modified"> 83 // NEW_RESOURCE_ARRAY*</span>
<span class="line-modified"> 84 // REALLOC_RESOURCE_ARRAY*</span>
<span class="line-modified"> 85 // FREE_RESOURCE_ARRAY*</span>
<span class="line-modified"> 86 // NEW_RESOURCE_OBJ*</span>
<span class="line-modified"> 87 // NEW_C_HEAP_ARRAY*</span>
<span class="line-modified"> 88 // REALLOC_C_HEAP_ARRAY*</span>
<span class="line-modified"> 89 // FREE_C_HEAP_ARRAY*</span>
<span class="line-modified"> 90 // NEW_C_HEAP_OBJ*</span>
<span class="line-added"> 91 // FREE_C_HEAP_OBJ</span>
<span class="line-added"> 92 //</span>
<span class="line-added"> 93 // char* AllocateHeap(size_t size, MEMFLAGS flags, const NativeCallStack&amp; stack, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);</span>
<span class="line-added"> 94 // char* AllocateHeap(size_t size, MEMFLAGS flags, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);</span>
<span class="line-added"> 95 // char* ReallocateHeap(char *old, size_t size, MEMFLAGS flag, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);</span>
<span class="line-added"> 96 // void FreeHeap(void* p);</span>
 97 //

 98 // In non product mode we introduce a super class for all allocation classes
 99 // that supports printing.
100 // We avoid the superclass in product mode to save space.
101 
102 #ifdef PRODUCT
103 #define ALLOCATION_SUPER_CLASS_SPEC
104 #else
105 #define ALLOCATION_SUPER_CLASS_SPEC : public AllocatedObj
106 class AllocatedObj {
107  public:
108   // Printing support
109   void print() const;
110   void print_value() const;
111 
112   virtual void print_on(outputStream* st) const;
113   virtual void print_value_on(outputStream* st) const;
114 };
115 #endif
116 
117 #define MEMORY_TYPES_DO(f) \
118   /* Memory type by sub systems. It occupies lower byte. */  \
119   f(mtJavaHeap,      &quot;Java Heap&quot;)   /* Java heap                                 */ \
120   f(mtClass,         &quot;Class&quot;)       /* Java classes                              */ \
121   f(mtThread,        &quot;Thread&quot;)      /* thread objects                            */ \
122   f(mtThreadStack,   &quot;Thread Stack&quot;)                                                \
123   f(mtCode,          &quot;Code&quot;)        /* generated code                            */ \
124   f(mtGC,            &quot;GC&quot;)                                                          \
125   f(mtCompiler,      &quot;Compiler&quot;)                                                    \
<span class="line-added">126   f(mtJVMCI,         &quot;JVMCI&quot;)                                                       \</span>
127   f(mtInternal,      &quot;Internal&quot;)    /* memory used by VM, but does not belong to */ \
128                                     /* any of above categories, and not used by  */ \
129                                     /* NMT                                       */ \
130   f(mtOther,         &quot;Other&quot;)       /* memory not used by VM                     */ \
131   f(mtSymbol,        &quot;Symbol&quot;)                                                      \
132   f(mtNMT,           &quot;Native Memory Tracking&quot;)  /* memory used by NMT            */ \
133   f(mtClassShared,   &quot;Shared class space&quot;)      /* class data sharing            */ \
134   f(mtChunk,         &quot;Arena Chunk&quot;) /* chunk that holds content of arenas        */ \
135   f(mtTest,          &quot;Test&quot;)        /* Test type for verifying NMT               */ \
136   f(mtTracing,       &quot;Tracing&quot;)                                                     \
137   f(mtLogging,       &quot;Logging&quot;)                                                     \
<span class="line-added">138   f(mtStatistics,    &quot;Statistics&quot;)                                                  \</span>
139   f(mtArguments,     &quot;Arguments&quot;)                                                   \
140   f(mtModule,        &quot;Module&quot;)                                                      \
141   f(mtSafepoint,     &quot;Safepoint&quot;)                                                   \
142   f(mtSynchronizer,  &quot;Synchronization&quot;)                                             \
143   f(mtNone,          &quot;Unknown&quot;)                                                     \
144   //end
145 
146 #define MEMORY_TYPE_DECLARE_ENUM(type, human_readable) \
147   type,
148 
149 /*
150  * Memory types
151  */
152 enum MemoryType {
153   MEMORY_TYPES_DO(MEMORY_TYPE_DECLARE_ENUM)
154   mt_number_of_types   // number of memory types (mtDontTrack
155                        // is not included as validate type)
156 };
157 
158 typedef MemoryType MEMFLAGS;
</pre>
<hr />
<pre>
167 const bool NMT_track_callsite = false;
168 
169 #endif // INCLUDE_NMT
170 
171 class NativeCallStack;
172 
173 
174 char* AllocateHeap(size_t size,
175                    MEMFLAGS flags,
176                    const NativeCallStack&amp; stack,
177                    AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);
178 char* AllocateHeap(size_t size,
179                    MEMFLAGS flags,
180                    AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);
181 
182 char* ReallocateHeap(char *old,
183                      size_t size,
184                      MEMFLAGS flag,
185                      AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);
186 
<span class="line-added">187 // handles NULL pointers</span>
188 void FreeHeap(void* p);
189 
190 template &lt;MEMFLAGS F&gt; class CHeapObj ALLOCATION_SUPER_CLASS_SPEC {
191  public:
192   ALWAYSINLINE void* operator new(size_t size) throw() {
193     return (void*)AllocateHeap(size, F);
194   }
195 
196   ALWAYSINLINE void* operator new(size_t size,
197                                   const NativeCallStack&amp; stack) throw() {
198     return (void*)AllocateHeap(size, F, stack);
199   }
200 
201   ALWAYSINLINE void* operator new(size_t size, const std::nothrow_t&amp;,
202                                   const NativeCallStack&amp; stack) throw() {
203     return (void*)AllocateHeap(size, F, stack, AllocFailStrategy::RETURN_NULL);
204   }
205 
206   ALWAYSINLINE void* operator new(size_t size, const std::nothrow_t&amp;) throw() {
207     return (void*)AllocateHeap(size, F, AllocFailStrategy::RETURN_NULL);
</pre>
<hr />
<pre>
219   ALWAYSINLINE void* operator new[](size_t size, const std::nothrow_t&amp;,
220                                     const NativeCallStack&amp; stack) throw() {
221     return (void*)AllocateHeap(size, F, stack, AllocFailStrategy::RETURN_NULL);
222   }
223 
224   ALWAYSINLINE void* operator new[](size_t size, const std::nothrow_t&amp;) throw() {
225     return (void*)AllocateHeap(size, F, AllocFailStrategy::RETURN_NULL);
226   }
227 
228   void  operator delete(void* p)     { FreeHeap(p); }
229   void  operator delete [] (void* p) { FreeHeap(p); }
230 };
231 
232 // Base class for objects allocated on the stack only.
233 // Calling new or delete will result in fatal error.
234 
235 class StackObj ALLOCATION_SUPER_CLASS_SPEC {
236  private:
237   void* operator new(size_t size) throw();
238   void* operator new [](size_t size) throw();



239   void  operator delete(void* p);
240   void  operator delete [](void* p);
241 };
242 
243 // Base class for objects stored in Metaspace.
244 // Calling delete will result in fatal error.
245 //
246 // Do not inherit from something with a vptr because this class does
247 // not introduce one.  This class is used to allocate both shared read-only
248 // and shared read-write classes.
249 //
250 
251 class ClassLoaderData;
252 class MetaspaceClosure;
253 
254 class MetaspaceObj {
255   friend class VMStructs;
256   // When CDS is enabled, all shared metaspace objects are mapped
257   // into a single contiguous memory block, so we can use these
258   // two pointers to quickly determine if something is in the
259   // shared metaspace.

260   // When CDS is not enabled, both pointers are set to NULL.
<span class="line-modified">261   static void* _shared_metaspace_base;  // (inclusive) low address</span>
<span class="line-modified">262   static void* _shared_metaspace_top;   // (exclusive) high address</span>
263 
264  public:
<span class="line-modified">265 </span>
<span class="line-modified">266   // Returns true if the pointer points to a valid MetaspaceObj. A valid</span>
<span class="line-added">267   // MetaspaceObj is MetaWord-aligned and contained within either</span>
<span class="line-added">268   // non-shared or shared metaspace.</span>
<span class="line-added">269   static bool is_valid(const MetaspaceObj* p);</span>
<span class="line-added">270 </span>
<span class="line-added">271   static bool is_shared(const MetaspaceObj* p) {</span>
272     // If no shared metaspace regions are mapped, _shared_metaspace_{base,top} will
273     // both be NULL and all values of p will be rejected quickly.
<span class="line-modified">274     return (((void*)p) &lt; _shared_metaspace_top &amp;&amp;</span>
<span class="line-added">275             ((void*)p) &gt;= _shared_metaspace_base);</span>
276   }
<span class="line-added">277   bool is_shared() const { return MetaspaceObj::is_shared(this); }</span>
<span class="line-added">278 </span>
279   void print_address_on(outputStream* st) const;  // nonvirtual address printing
280 
281   static void set_shared_metaspace_range(void* base, void* top) {
282     _shared_metaspace_base = base;
283     _shared_metaspace_top = top;
284   }
<span class="line-added">285 </span>
286   static void* shared_metaspace_base() { return _shared_metaspace_base; }
287   static void* shared_metaspace_top()  { return _shared_metaspace_top;  }
288 
289 #define METASPACE_OBJ_TYPES_DO(f) \
290   f(Class) \
291   f(Symbol) \
292   f(TypeArrayU1) \
293   f(TypeArrayU2) \
294   f(TypeArrayU4) \
295   f(TypeArrayU8) \
296   f(TypeArrayOther) \
297   f(Method) \
298   f(ConstMethod) \
299   f(MethodData) \
300   f(ConstantPool) \
301   f(ConstantPoolCache) \
302   f(Annotations) \
<span class="line-modified">303   f(MethodCounters) \</span>
<span class="line-added">304   f(RecordComponent)</span>
305 
306 #define METASPACE_OBJ_TYPE_DECLARE(name) name ## Type,
307 #define METASPACE_OBJ_TYPE_NAME_CASE(name) case name ## Type: return #name;
308 
309   enum Type {
310     // Types are MetaspaceObj::ClassType, MetaspaceObj::SymbolType, etc
311     METASPACE_OBJ_TYPES_DO(METASPACE_OBJ_TYPE_DECLARE)
312     _number_of_types
313   };
314 
315   static const char * type_name(Type type) {
316     switch(type) {
317     METASPACE_OBJ_TYPES_DO(METASPACE_OBJ_TYPE_NAME_CASE)
318     default:
319       ShouldNotReachHere();
320       return NULL;
321     }
322   }
323 
324   static MetaspaceObj::Type array_type(size_t elem_size) {
</pre>
<hr />
<pre>
489 #define REALLOC_C_HEAP_ARRAY(type, old, size, memflags)\
490   (type*) (ReallocateHeap((char*)(old), (size) * sizeof(type), memflags))
491 
492 #define REALLOC_C_HEAP_ARRAY_RETURN_NULL(type, old, size, memflags)\
493   (type*) (ReallocateHeap((char*)(old), (size) * sizeof(type), memflags, AllocFailStrategy::RETURN_NULL))
494 
495 #define FREE_C_HEAP_ARRAY(type, old) \
496   FreeHeap((char*)(old))
497 
498 // allocate type in heap without calling ctor
499 #define NEW_C_HEAP_OBJ(type, memflags)\
500   NEW_C_HEAP_ARRAY(type, 1, memflags)
501 
502 #define NEW_C_HEAP_OBJ_RETURN_NULL(type, memflags)\
503   NEW_C_HEAP_ARRAY_RETURN_NULL(type, 1, memflags)
504 
505 // deallocate obj of type in heap without calling dtor
506 #define FREE_C_HEAP_OBJ(objname)\
507   FreeHeap((char*)objname);
508 

















509 
510 //------------------------------ReallocMark---------------------------------
511 // Code which uses REALLOC_RESOURCE_ARRAY should check an associated
512 // ReallocMark, which is declared in the same scope as the reallocated
513 // pointer.  Any operation that could __potentially__ cause a reallocation
514 // should check the ReallocMark.
515 class ReallocMark: public StackObj {
516 protected:
517   NOT_PRODUCT(int _nesting;)
518 
519 public:
520   ReallocMark()   PRODUCT_RETURN;
521   void check()    PRODUCT_RETURN;
522 };
523 
524 // Helper class to allocate arrays that may become large.
525 // Uses the OS malloc for allocations smaller than ArrayAllocatorMallocLimit
526 // and uses mapped memory for larger allocations.
527 // Most OS mallocs do something similar but Solaris malloc does not revert
528 // to mapped memory for large allocations. By default ArrayAllocatorMallocLimit
</pre>
</td>
</tr>
</table>
<center><a href="allocation.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="allocation.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/metaspaceClosure.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="metaspaceClosure.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="metaspaceShared.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/metaspaceClosure.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_MEMORY_METASPACECLOSURE_HPP
 26 #define SHARE_MEMORY_METASPACECLOSURE_HPP
 27 
 28 #include &quot;logging/log.hpp&quot;
 29 #include &quot;memory/allocation.hpp&quot;
 30 #include &quot;oops/array.hpp&quot;

 31 #include &quot;utilities/growableArray.hpp&quot;
 32 #include &quot;utilities/hashtable.inline.hpp&quot;
 33 
 34 // The metadata hierarchy is separate from the oop hierarchy
 35   class MetaspaceObj;        // no C++ vtable
 36 //class   Array;             // no C++ vtable
 37   class   Annotations;       // no C++ vtable
 38   class   ConstantPoolCache; // no C++ vtable
 39   class   ConstMethod;       // no C++ vtable
 40   class   MethodCounters;    // no C++ vtable
 41   class   Symbol;            // no C++ vtable
 42   class   Metadata;          // has C++ vtable (so do all subclasses)
 43   class     ConstantPool;
 44   class     MethodData;
 45   class     Method;
 46   class     Klass;
 47   class       InstanceKlass;
 48   class         InstanceMirrorKlass;
 49   class         InstanceClassLoaderKlass;
 50   class         InstanceRefKlass;
</pre>
<hr />
<pre>
 58 // provides an API to walk all the reachable objects starting from a set of
 59 // root references (such as all Klass&#39;es in the SystemDictionary).
 60 //
 61 // Currently it is used for compacting the CDS archive by eliminate temporary
 62 // objects allocated during archive creation time. See ArchiveCompactor in
 63 // metaspaceShared.cpp for an example.
 64 //
 65 // To support MetaspaceClosure, each subclass of MetaspaceObj must provide
 66 // a method of the type void metaspace_pointers_do(MetaspaceClosure*). This method
 67 // should call MetaspaceClosure::push() on every pointer fields of this
 68 // class that points to a MetaspaceObj. See Annotations::metaspace_pointers_do()
 69 // for an example.
 70 class MetaspaceClosure {
 71 public:
 72   enum Writability {
 73     _writable,
 74     _not_writable,
 75     _default
 76   };
 77 




 78   // class MetaspaceClosure::Ref --
 79   //
 80   // MetaspaceClosure can be viewed as a very simple type of copying garbage
 81   // collector. For it to function properly, it requires each subclass of
 82   // MetaspaceObj to provide two methods:
 83   //
 84   //  size_t size();                                 -- to determine how much data to copy
 85   //  void metaspace_pointers_do(MetaspaceClosure*); -- to locate all the embedded pointers
 86   //
 87   // Calling these methods would be trivial if these two were virtual methods.
 88   // However, to save space, MetaspaceObj has NO vtable. The vtable is introduced
 89   // only in the Metadata class.
 90   //
 91   // To work around the lack of a vtable, we use Ref class with templates
 92   // (see ObjectRef, PrimitiveArrayRef and PointerArrayRef)
 93   // so that we can statically discover the type of a object. The use of Ref
 94   // depends on the fact that:
 95   //
 96   // [1] We don&#39;t use polymorphic pointers for MetaspaceObj&#39;s that are not subclasses
 97   //     of Metadata. I.e., we don&#39;t do this:
 98   //     class Klass {
 99   //         MetaspaceObj *_obj;
100   //         Array&lt;int&gt;* foo() { return (Array&lt;int&gt;*)_obj; }
101   //         Symbol*     bar() { return (Symbol*)    _obj; }
102   //
103   // [2] All Array&lt;T&gt; dimensions are statically declared.
<span class="line-modified">104   class Ref {</span>




105   protected:
106     virtual void** mpp() const = 0;

107   public:
108     virtual bool not_null() const = 0;
109     virtual int size() const = 0;
110     virtual void metaspace_pointers_do(MetaspaceClosure *it) const = 0;
111     virtual void metaspace_pointers_do_at(MetaspaceClosure *it, address new_loc) const = 0;
112     virtual MetaspaceObj::Type msotype() const = 0;
113     virtual bool is_read_only_by_default() const = 0;

114 
115     address obj() const {
116       // In some rare cases (see CPSlot in constantPool.hpp) we store some flags in the lowest
117       // 2 bits of a MetaspaceObj pointer. Unmask these when manipulating the pointer.
118       uintx p = (uintx)*mpp();
119       return (address)(p &amp; (~FLAG_MASK));
120     }
121 




122     void update(address new_loc) const;
123 




124   private:
125     static const uintx FLAG_MASK = 0x03;
126 
127     int flag_bits() const {
128       uintx p = (uintx)*mpp();
129       return (int)(p &amp; FLAG_MASK);
130     }
131   };
132 
133 private:
134   // -------------------------------------------------- ObjectRef
135   template &lt;class T&gt; class ObjectRef : public Ref {
136     T** _mpp;
137     T* dereference() const {
138       return *_mpp;
139     }
140   protected:
141     virtual void** mpp() const {
142       return (void**)_mpp;
143     }
144 
145   public:
<span class="line-modified">146     ObjectRef(T** mpp) : _mpp(mpp) {}</span>
147 
148     virtual bool is_read_only_by_default() const { return T::is_read_only_by_default(); }
149     virtual bool not_null()                const { return dereference() != NULL; }
150     virtual int size()                     const { return dereference()-&gt;size(); }
151     virtual MetaspaceObj::Type msotype()   const { return dereference()-&gt;type(); }
152 
153     virtual void metaspace_pointers_do(MetaspaceClosure *it) const {
154       dereference()-&gt;metaspace_pointers_do(it);
155     }
156     virtual void metaspace_pointers_do_at(MetaspaceClosure *it, address new_loc) const {
157       ((T*)new_loc)-&gt;metaspace_pointers_do(it);
158     }
159   };
160 
161   // -------------------------------------------------- PrimitiveArrayRef
162   template &lt;class T&gt; class PrimitiveArrayRef : public Ref {
163     Array&lt;T&gt;** _mpp;
164     Array&lt;T&gt;* dereference() const {
165       return *_mpp;
166     }
167   protected:
168     virtual void** mpp() const {
169       return (void**)_mpp;
170     }
171 
172   public:
<span class="line-modified">173     PrimitiveArrayRef(Array&lt;T&gt;** mpp) : _mpp(mpp) {}</span>
174 
175     // all Arrays are read-only by default
176     virtual bool is_read_only_by_default() const { return true; }
177     virtual bool not_null()                const { return dereference() != NULL;  }
178     virtual int size()                     const { return dereference()-&gt;size(); }
179     virtual MetaspaceObj::Type msotype()   const { return MetaspaceObj::array_type(sizeof(T)); }
180 
181     virtual void metaspace_pointers_do(MetaspaceClosure *it) const {
182       Array&lt;T&gt;* array = dereference();
183       log_trace(cds)(&quot;Iter(PrimitiveArray): %p [%d]&quot;, array, array-&gt;length());
184     }
185     virtual void metaspace_pointers_do_at(MetaspaceClosure *it, address new_loc) const {
186       Array&lt;T&gt;* array = (Array&lt;T&gt;*)new_loc;
187       log_trace(cds)(&quot;Iter(PrimitiveArray): %p [%d]&quot;, array, array-&gt;length());
188     }
189   };
190 
191   // -------------------------------------------------- PointerArrayRef
192   template &lt;class T&gt; class PointerArrayRef : public Ref {
193     Array&lt;T*&gt;** _mpp;
194     Array&lt;T*&gt;* dereference() const {
195       return *_mpp;
196     }
197   protected:
198     virtual void** mpp() const {
199       return (void**)_mpp;
200     }
201 
202   public:
<span class="line-modified">203     PointerArrayRef(Array&lt;T*&gt;** mpp) : _mpp(mpp) {}</span>
204 
205     // all Arrays are read-only by default
206     virtual bool is_read_only_by_default() const { return true; }
207     virtual bool not_null()                const { return dereference() != NULL; }
208     virtual int size()                     const { return dereference()-&gt;size(); }
209     virtual MetaspaceObj::Type msotype()   const { return MetaspaceObj::array_type(sizeof(T*)); }
210 
211     virtual void metaspace_pointers_do(MetaspaceClosure *it) const {
212       metaspace_pointers_do_at_impl(it, dereference());
213     }
214     virtual void metaspace_pointers_do_at(MetaspaceClosure *it, address new_loc) const {
215       metaspace_pointers_do_at_impl(it, (Array&lt;T*&gt;*)new_loc);
216     }
217   private:
218     void metaspace_pointers_do_at_impl(MetaspaceClosure *it, Array&lt;T*&gt;* array) const {
219       log_trace(cds)(&quot;Iter(ObjectArray): %p [%d]&quot;, array, array-&gt;length());
220       for (int i = 0; i &lt; array-&gt;length(); i++) {
221         T** mpp = array-&gt;adr_at(i);
222         it-&gt;push(mpp);
223       }
224     }
225   };
226 
<span class="line-modified">227   void push_impl(Ref* ref, Writability w);</span>







228 
229 public:





230   // returns true if we want to keep iterating the pointers embedded inside &lt;ref&gt;
231   virtual bool do_ref(Ref* ref, bool read_only) = 0;
232 
233   // When you do:
234   //     void MyType::metaspace_pointers_do(MetaspaceClosure* it) {
235   //       it-&gt;push(_my_field)
236   //
237   // C++ will try to match the &quot;most specific&quot; template function. This one will
238   // will be matched if possible (if mpp is an Array&lt;&gt; of any pointer type).
239   template &lt;typename T&gt; void push(Array&lt;T*&gt;** mpp, Writability w = _default) {
<span class="line-modified">240     PointerArrayRef&lt;T&gt; ref(mpp);</span>
<span class="line-removed">241     push_impl(&amp;ref, w);</span>
242   }
243 
244   // If the above function doesn&#39;t match (mpp is an Array&lt;&gt;, but T is not a pointer type), then
245   // this is the second choice.
246   template &lt;typename T&gt; void push(Array&lt;T&gt;** mpp, Writability w = _default) {
<span class="line-modified">247     PrimitiveArrayRef&lt;T&gt; ref(mpp);</span>
<span class="line-removed">248     push_impl(&amp;ref, w);</span>
249   }
250 
251   // If the above function doesn&#39;t match (mpp is not an Array&lt;&gt; type), then
252   // this will be matched by default.
253   template &lt;class T&gt; void push(T** mpp, Writability w = _default) {
<span class="line-modified">254     ObjectRef&lt;T&gt; ref(mpp);</span>
<span class="line-modified">255     push_impl(&amp;ref, w);</span>









256   }
257 };
258 
259 // This is a special MetaspaceClosure that visits each unique MetaspaceObj once.
260 class UniqueMetaspaceClosure : public MetaspaceClosure {
261   static const int INITIAL_TABLE_SIZE = 15889;
262   static const int MAX_TABLE_SIZE     = 1000000;
263 
264   // Do not override. Returns true if we are discovering ref-&gt;obj() for the first time.
265   virtual bool do_ref(Ref* ref, bool read_only);
266 
267 public:
268   // Gets called the first time we discover an object.
<span class="line-modified">269   virtual void do_unique_ref(Ref* ref, bool read_only) = 0;</span>
270   UniqueMetaspaceClosure() : _has_been_visited(INITIAL_TABLE_SIZE) {}
271 
272 private:
273   KVHashtable&lt;address, bool, mtInternal&gt; _has_been_visited;
274 };
275 
276 #endif // SHARE_MEMORY_METASPACECLOSURE_HPP
</pre>
</td>
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_MEMORY_METASPACECLOSURE_HPP
 26 #define SHARE_MEMORY_METASPACECLOSURE_HPP
 27 
 28 #include &quot;logging/log.hpp&quot;
 29 #include &quot;memory/allocation.hpp&quot;
 30 #include &quot;oops/array.hpp&quot;
<span class="line-added"> 31 #include &quot;utilities/globalDefinitions.hpp&quot;</span>
 32 #include &quot;utilities/growableArray.hpp&quot;
 33 #include &quot;utilities/hashtable.inline.hpp&quot;
 34 
 35 // The metadata hierarchy is separate from the oop hierarchy
 36   class MetaspaceObj;        // no C++ vtable
 37 //class   Array;             // no C++ vtable
 38   class   Annotations;       // no C++ vtable
 39   class   ConstantPoolCache; // no C++ vtable
 40   class   ConstMethod;       // no C++ vtable
 41   class   MethodCounters;    // no C++ vtable
 42   class   Symbol;            // no C++ vtable
 43   class   Metadata;          // has C++ vtable (so do all subclasses)
 44   class     ConstantPool;
 45   class     MethodData;
 46   class     Method;
 47   class     Klass;
 48   class       InstanceKlass;
 49   class         InstanceMirrorKlass;
 50   class         InstanceClassLoaderKlass;
 51   class         InstanceRefKlass;
</pre>
<hr />
<pre>
 59 // provides an API to walk all the reachable objects starting from a set of
 60 // root references (such as all Klass&#39;es in the SystemDictionary).
 61 //
 62 // Currently it is used for compacting the CDS archive by eliminate temporary
 63 // objects allocated during archive creation time. See ArchiveCompactor in
 64 // metaspaceShared.cpp for an example.
 65 //
 66 // To support MetaspaceClosure, each subclass of MetaspaceObj must provide
 67 // a method of the type void metaspace_pointers_do(MetaspaceClosure*). This method
 68 // should call MetaspaceClosure::push() on every pointer fields of this
 69 // class that points to a MetaspaceObj. See Annotations::metaspace_pointers_do()
 70 // for an example.
 71 class MetaspaceClosure {
 72 public:
 73   enum Writability {
 74     _writable,
 75     _not_writable,
 76     _default
 77   };
 78 
<span class="line-added"> 79   enum SpecialRef {</span>
<span class="line-added"> 80     _method_entry_ref</span>
<span class="line-added"> 81   };</span>
<span class="line-added"> 82 </span>
 83   // class MetaspaceClosure::Ref --
 84   //
 85   // MetaspaceClosure can be viewed as a very simple type of copying garbage
 86   // collector. For it to function properly, it requires each subclass of
 87   // MetaspaceObj to provide two methods:
 88   //
 89   //  size_t size();                                 -- to determine how much data to copy
 90   //  void metaspace_pointers_do(MetaspaceClosure*); -- to locate all the embedded pointers
 91   //
 92   // Calling these methods would be trivial if these two were virtual methods.
 93   // However, to save space, MetaspaceObj has NO vtable. The vtable is introduced
 94   // only in the Metadata class.
 95   //
 96   // To work around the lack of a vtable, we use Ref class with templates
 97   // (see ObjectRef, PrimitiveArrayRef and PointerArrayRef)
 98   // so that we can statically discover the type of a object. The use of Ref
 99   // depends on the fact that:
100   //
101   // [1] We don&#39;t use polymorphic pointers for MetaspaceObj&#39;s that are not subclasses
102   //     of Metadata. I.e., we don&#39;t do this:
103   //     class Klass {
104   //         MetaspaceObj *_obj;
105   //         Array&lt;int&gt;* foo() { return (Array&lt;int&gt;*)_obj; }
106   //         Symbol*     bar() { return (Symbol*)    _obj; }
107   //
108   // [2] All Array&lt;T&gt; dimensions are statically declared.
<span class="line-modified">109   class Ref : public CHeapObj&lt;mtInternal&gt; {</span>
<span class="line-added">110     Writability _writability;</span>
<span class="line-added">111     Ref* _next;</span>
<span class="line-added">112     NONCOPYABLE(Ref);</span>
<span class="line-added">113 </span>
114   protected:
115     virtual void** mpp() const = 0;
<span class="line-added">116     Ref(Writability w) : _writability(w), _next(NULL) {}</span>
117   public:
118     virtual bool not_null() const = 0;
119     virtual int size() const = 0;
120     virtual void metaspace_pointers_do(MetaspaceClosure *it) const = 0;
121     virtual void metaspace_pointers_do_at(MetaspaceClosure *it, address new_loc) const = 0;
122     virtual MetaspaceObj::Type msotype() const = 0;
123     virtual bool is_read_only_by_default() const = 0;
<span class="line-added">124     virtual ~Ref() {}</span>
125 
126     address obj() const {
127       // In some rare cases (see CPSlot in constantPool.hpp) we store some flags in the lowest
128       // 2 bits of a MetaspaceObj pointer. Unmask these when manipulating the pointer.
129       uintx p = (uintx)*mpp();
130       return (address)(p &amp; (~FLAG_MASK));
131     }
132 
<span class="line-added">133     address* addr() const {</span>
<span class="line-added">134       return (address*)mpp();</span>
<span class="line-added">135     }</span>
<span class="line-added">136 </span>
137     void update(address new_loc) const;
138 
<span class="line-added">139     Writability writability() const { return _writability; };</span>
<span class="line-added">140     void set_next(Ref* n)           { _next = n; }</span>
<span class="line-added">141     Ref* next() const               { return _next; }</span>
<span class="line-added">142 </span>
143   private:
144     static const uintx FLAG_MASK = 0x03;
145 
146     int flag_bits() const {
147       uintx p = (uintx)*mpp();
148       return (int)(p &amp; FLAG_MASK);
149     }
150   };
151 
152 private:
153   // -------------------------------------------------- ObjectRef
154   template &lt;class T&gt; class ObjectRef : public Ref {
155     T** _mpp;
156     T* dereference() const {
157       return *_mpp;
158     }
159   protected:
160     virtual void** mpp() const {
161       return (void**)_mpp;
162     }
163 
164   public:
<span class="line-modified">165     ObjectRef(T** mpp, Writability w) : Ref(w), _mpp(mpp) {}</span>
166 
167     virtual bool is_read_only_by_default() const { return T::is_read_only_by_default(); }
168     virtual bool not_null()                const { return dereference() != NULL; }
169     virtual int size()                     const { return dereference()-&gt;size(); }
170     virtual MetaspaceObj::Type msotype()   const { return dereference()-&gt;type(); }
171 
172     virtual void metaspace_pointers_do(MetaspaceClosure *it) const {
173       dereference()-&gt;metaspace_pointers_do(it);
174     }
175     virtual void metaspace_pointers_do_at(MetaspaceClosure *it, address new_loc) const {
176       ((T*)new_loc)-&gt;metaspace_pointers_do(it);
177     }
178   };
179 
180   // -------------------------------------------------- PrimitiveArrayRef
181   template &lt;class T&gt; class PrimitiveArrayRef : public Ref {
182     Array&lt;T&gt;** _mpp;
183     Array&lt;T&gt;* dereference() const {
184       return *_mpp;
185     }
186   protected:
187     virtual void** mpp() const {
188       return (void**)_mpp;
189     }
190 
191   public:
<span class="line-modified">192     PrimitiveArrayRef(Array&lt;T&gt;** mpp, Writability w) : Ref(w), _mpp(mpp) {}</span>
193 
194     // all Arrays are read-only by default
195     virtual bool is_read_only_by_default() const { return true; }
196     virtual bool not_null()                const { return dereference() != NULL;  }
197     virtual int size()                     const { return dereference()-&gt;size(); }
198     virtual MetaspaceObj::Type msotype()   const { return MetaspaceObj::array_type(sizeof(T)); }
199 
200     virtual void metaspace_pointers_do(MetaspaceClosure *it) const {
201       Array&lt;T&gt;* array = dereference();
202       log_trace(cds)(&quot;Iter(PrimitiveArray): %p [%d]&quot;, array, array-&gt;length());
203     }
204     virtual void metaspace_pointers_do_at(MetaspaceClosure *it, address new_loc) const {
205       Array&lt;T&gt;* array = (Array&lt;T&gt;*)new_loc;
206       log_trace(cds)(&quot;Iter(PrimitiveArray): %p [%d]&quot;, array, array-&gt;length());
207     }
208   };
209 
210   // -------------------------------------------------- PointerArrayRef
211   template &lt;class T&gt; class PointerArrayRef : public Ref {
212     Array&lt;T*&gt;** _mpp;
213     Array&lt;T*&gt;* dereference() const {
214       return *_mpp;
215     }
216   protected:
217     virtual void** mpp() const {
218       return (void**)_mpp;
219     }
220 
221   public:
<span class="line-modified">222     PointerArrayRef(Array&lt;T*&gt;** mpp, Writability w) : Ref(w), _mpp(mpp) {}</span>
223 
224     // all Arrays are read-only by default
225     virtual bool is_read_only_by_default() const { return true; }
226     virtual bool not_null()                const { return dereference() != NULL; }
227     virtual int size()                     const { return dereference()-&gt;size(); }
228     virtual MetaspaceObj::Type msotype()   const { return MetaspaceObj::array_type(sizeof(T*)); }
229 
230     virtual void metaspace_pointers_do(MetaspaceClosure *it) const {
231       metaspace_pointers_do_at_impl(it, dereference());
232     }
233     virtual void metaspace_pointers_do_at(MetaspaceClosure *it, address new_loc) const {
234       metaspace_pointers_do_at_impl(it, (Array&lt;T*&gt;*)new_loc);
235     }
236   private:
237     void metaspace_pointers_do_at_impl(MetaspaceClosure *it, Array&lt;T*&gt;* array) const {
238       log_trace(cds)(&quot;Iter(ObjectArray): %p [%d]&quot;, array, array-&gt;length());
239       for (int i = 0; i &lt; array-&gt;length(); i++) {
240         T** mpp = array-&gt;adr_at(i);
241         it-&gt;push(mpp);
242       }
243     }
244   };
245 
<span class="line-modified">246   // If recursion is too deep, save the Refs in _pending_refs, and push them later using</span>
<span class="line-added">247   // MetaspaceClosure::finish()</span>
<span class="line-added">248   static const int MAX_NEST_LEVEL = 5;</span>
<span class="line-added">249   Ref* _pending_refs;</span>
<span class="line-added">250   int _nest_level;</span>
<span class="line-added">251 </span>
<span class="line-added">252   void push_impl(Ref* ref);</span>
<span class="line-added">253   void do_push(Ref* ref);</span>
254 
255 public:
<span class="line-added">256   MetaspaceClosure(): _pending_refs(NULL), _nest_level(0) {}</span>
<span class="line-added">257   ~MetaspaceClosure();</span>
<span class="line-added">258 </span>
<span class="line-added">259   void finish();</span>
<span class="line-added">260 </span>
261   // returns true if we want to keep iterating the pointers embedded inside &lt;ref&gt;
262   virtual bool do_ref(Ref* ref, bool read_only) = 0;
263 
264   // When you do:
265   //     void MyType::metaspace_pointers_do(MetaspaceClosure* it) {
266   //       it-&gt;push(_my_field)
267   //
268   // C++ will try to match the &quot;most specific&quot; template function. This one will
269   // will be matched if possible (if mpp is an Array&lt;&gt; of any pointer type).
270   template &lt;typename T&gt; void push(Array&lt;T*&gt;** mpp, Writability w = _default) {
<span class="line-modified">271     push_impl(new PointerArrayRef&lt;T&gt;(mpp, w));</span>

272   }
273 
274   // If the above function doesn&#39;t match (mpp is an Array&lt;&gt;, but T is not a pointer type), then
275   // this is the second choice.
276   template &lt;typename T&gt; void push(Array&lt;T&gt;** mpp, Writability w = _default) {
<span class="line-modified">277     push_impl(new PrimitiveArrayRef&lt;T&gt;(mpp, w));</span>

278   }
279 
280   // If the above function doesn&#39;t match (mpp is not an Array&lt;&gt; type), then
281   // this will be matched by default.
282   template &lt;class T&gt; void push(T** mpp, Writability w = _default) {
<span class="line-modified">283     push_impl(new ObjectRef&lt;T&gt;(mpp, w));</span>
<span class="line-modified">284   }</span>
<span class="line-added">285 </span>
<span class="line-added">286   template &lt;class T&gt; void push_method_entry(T** mpp, intptr_t* p) {</span>
<span class="line-added">287     push_special(_method_entry_ref, new ObjectRef&lt;T&gt;(mpp, _default), (intptr_t*)p);</span>
<span class="line-added">288   }</span>
<span class="line-added">289 </span>
<span class="line-added">290   // This is for tagging special pointers that are not a reference to MetaspaceObj. It&#39;s currently</span>
<span class="line-added">291   // used to mark the method entry points in Method/ConstMethod.</span>
<span class="line-added">292   virtual void push_special(SpecialRef type, Ref* obj, intptr_t* p) {</span>
<span class="line-added">293     assert(type == _method_entry_ref, &quot;only special type allowed for now&quot;);</span>
294   }
295 };
296 
297 // This is a special MetaspaceClosure that visits each unique MetaspaceObj once.
298 class UniqueMetaspaceClosure : public MetaspaceClosure {
299   static const int INITIAL_TABLE_SIZE = 15889;
300   static const int MAX_TABLE_SIZE     = 1000000;
301 
302   // Do not override. Returns true if we are discovering ref-&gt;obj() for the first time.
303   virtual bool do_ref(Ref* ref, bool read_only);
304 
305 public:
306   // Gets called the first time we discover an object.
<span class="line-modified">307   virtual bool do_unique_ref(Ref* ref, bool read_only) = 0;</span>
308   UniqueMetaspaceClosure() : _has_been_visited(INITIAL_TABLE_SIZE) {}
309 
310 private:
311   KVHashtable&lt;address, bool, mtInternal&gt; _has_been_visited;
312 };
313 
314 #endif // SHARE_MEMORY_METASPACECLOSURE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="metaspaceClosure.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="metaspaceShared.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
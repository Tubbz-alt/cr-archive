<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/metaspace.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="memRegion.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="metaspace.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/metaspace.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  28 #include &quot;gc/shared/collectedHeap.hpp&quot;
  29 #include &quot;logging/log.hpp&quot;
  30 #include &quot;logging/logStream.hpp&quot;
  31 #include &quot;memory/filemap.hpp&quot;
  32 #include &quot;memory/metaspace.hpp&quot;
  33 #include &quot;memory/metaspace/chunkManager.hpp&quot;
  34 #include &quot;memory/metaspace/metachunk.hpp&quot;
  35 #include &quot;memory/metaspace/metaspaceCommon.hpp&quot;
  36 #include &quot;memory/metaspace/printCLDMetaspaceInfoClosure.hpp&quot;
  37 #include &quot;memory/metaspace/spaceManager.hpp&quot;
  38 #include &quot;memory/metaspace/virtualSpaceList.hpp&quot;
  39 #include &quot;memory/metaspaceShared.hpp&quot;
  40 #include &quot;memory/metaspaceTracer.hpp&quot;
  41 #include &quot;memory/universe.hpp&quot;


  42 #include &quot;runtime/init.hpp&quot;
<span class="line-removed">  43 #include &quot;runtime/orderAccess.hpp&quot;</span>
  44 #include &quot;services/memTracker.hpp&quot;
  45 #include &quot;utilities/copy.hpp&quot;
  46 #include &quot;utilities/debug.hpp&quot;
  47 #include &quot;utilities/formatBuffer.hpp&quot;
  48 #include &quot;utilities/globalDefinitions.hpp&quot;

  49 
  50 
  51 using namespace metaspace;
  52 
  53 MetaWord* last_allocated = 0;
  54 
  55 size_t Metaspace::_compressed_class_space_size;
  56 const MetaspaceTracer* Metaspace::_tracer = NULL;
  57 
  58 DEBUG_ONLY(bool Metaspace::_frozen = false;)
  59 
  60 static const char* space_type_name(Metaspace::MetaspaceType t) {
  61   const char* s = NULL;
  62   switch (t) {
  63     case Metaspace::StandardMetaspaceType: s = &quot;Standard&quot;; break;
  64     case Metaspace::BootMetaspaceType: s = &quot;Boot&quot;; break;
  65     case Metaspace::UnsafeAnonymousMetaspaceType: s = &quot;UnsafeAnonymous&quot;; break;
  66     case Metaspace::ReflectionMetaspaceType: s = &quot;Reflection&quot;; break;
  67     default: ShouldNotReachHere();
  68   }
  69   return s;
  70 }
  71 
  72 volatile size_t MetaspaceGC::_capacity_until_GC = 0;
  73 uint MetaspaceGC::_shrink_factor = 0;
<span class="line-removed">  74 bool MetaspaceGC::_should_concurrent_collect = false;</span>
  75 
  76 // BlockFreelist methods
  77 
  78 // VirtualSpaceNode methods
  79 
  80 // MetaspaceGC methods
  81 
  82 // VM_CollectForMetadataAllocation is the vm operation used to GC.
  83 // Within the VM operation after the GC the attempt to allocate the metadata
  84 // should succeed.  If the GC did not free enough space for the metaspace
  85 // allocation, the HWM is increased so that another virtualspace will be
  86 // allocated for the metadata.  With perm gen the increase in the perm
  87 // gen had bounds, MinMetaspaceExpansion and MaxMetaspaceExpansion.  The
  88 // metaspace policy uses those as the small and large steps for the HWM.
  89 //
  90 // After the GC the compute_new_size() for MetaspaceGC is called to
  91 // resize the capacity of the metaspaces.  The current implementation
  92 // is based on the flags MinMetaspaceFreeRatio and MaxMetaspaceFreeRatio used
  93 // to resize the Java heap by some GC&#39;s.  New flags can be implemented
  94 // if really needed.  MinMetaspaceFreeRatio is used to calculate how much
</pre>
<hr />
<pre>
 110 
 111   if (delta &lt;= min_delta) {
 112     delta = min_delta;
 113   } else if (delta &lt;= max_delta) {
 114     // Don&#39;t want to hit the high water mark on the next
 115     // allocation so make the delta greater than just enough
 116     // for this allocation.
 117     delta = max_delta;
 118   } else {
 119     // This allocation is large but the next ones are probably not
 120     // so increase by the minimum.
 121     delta = delta + min_delta;
 122   }
 123 
 124   assert_is_aligned(delta, Metaspace::commit_alignment());
 125 
 126   return delta;
 127 }
 128 
 129 size_t MetaspaceGC::capacity_until_GC() {
<span class="line-modified"> 130   size_t value = OrderAccess::load_acquire(&amp;_capacity_until_GC);</span>
 131   assert(value &gt;= MetaspaceSize, &quot;Not initialized properly?&quot;);
 132   return value;
 133 }
 134 
 135 // Try to increase the _capacity_until_GC limit counter by v bytes.
 136 // Returns true if it succeeded. It may fail if either another thread
 137 // concurrently increased the limit or the new limit would be larger
 138 // than MaxMetaspaceSize.
 139 // On success, optionally returns new and old metaspace capacity in
 140 // new_cap_until_GC and old_cap_until_GC respectively.
 141 // On error, optionally sets can_retry to indicate whether if there is
 142 // actually enough space remaining to satisfy the request.
 143 bool MetaspaceGC::inc_capacity_until_GC(size_t v, size_t* new_cap_until_GC, size_t* old_cap_until_GC, bool* can_retry) {
 144   assert_is_aligned(v, Metaspace::commit_alignment());
 145 
 146   size_t old_capacity_until_GC = _capacity_until_GC;
 147   size_t new_value = old_capacity_until_GC + v;
 148 
 149   if (new_value &lt; old_capacity_until_GC) {
 150     // The addition wrapped around, set new_value to aligned max value.
 151     new_value = align_down(max_uintx, Metaspace::commit_alignment());
 152   }
 153 
 154   if (new_value &gt; MaxMetaspaceSize) {
 155     if (can_retry != NULL) {
 156       *can_retry = false;
 157     }
 158     return false;
 159   }
 160 
 161   if (can_retry != NULL) {
 162     *can_retry = true;
 163   }
<span class="line-modified"> 164   size_t prev_value = Atomic::cmpxchg(new_value, &amp;_capacity_until_GC, old_capacity_until_GC);</span>
 165 
 166   if (old_capacity_until_GC != prev_value) {
 167     return false;
 168   }
 169 
 170   if (new_cap_until_GC != NULL) {
 171     *new_cap_until_GC = new_value;
 172   }
 173   if (old_cap_until_GC != NULL) {
 174     *old_cap_until_GC = old_capacity_until_GC;
 175   }
 176   return true;
 177 }
 178 
 179 size_t MetaspaceGC::dec_capacity_until_GC(size_t v) {
 180   assert_is_aligned(v, Metaspace::commit_alignment());
 181 
<span class="line-modified"> 182   return Atomic::sub(v, &amp;_capacity_until_GC);</span>
 183 }
 184 
 185 void MetaspaceGC::initialize() {
 186   // Set the high-water mark to MaxMetapaceSize during VM initializaton since
 187   // we can&#39;t do a GC during initialization.
 188   _capacity_until_GC = MaxMetaspaceSize;
 189 }
 190 
 191 void MetaspaceGC::post_initialize() {
 192   // Reset the high-water mark once the VM initialization is done.
 193   _capacity_until_GC = MAX2(MetaspaceUtils::committed_bytes(), MetaspaceSize);
 194 }
 195 
 196 bool MetaspaceGC::can_expand(size_t word_size, bool is_class) {
 197   // Check if the compressed class space is full.
 198   if (is_class &amp;&amp; Metaspace::using_class_space()) {
 199     size_t class_committed = MetaspaceUtils::committed_bytes(Metaspace::ClassType);
 200     if (class_committed + word_size * BytesPerWord &gt; CompressedClassSpaceSize) {
 201       log_trace(gc, metaspace, freelist)(&quot;Cannot expand %s metaspace by &quot; SIZE_FORMAT &quot; words (CompressedClassSpaceSize = &quot; SIZE_FORMAT &quot; words)&quot;,
 202                 (is_class ? &quot;class&quot; : &quot;non-class&quot;), word_size, CompressedClassSpaceSize / sizeof(MetaWord));
</pre>
<hr />
<pre>
 376 
 377 size_t MetaspaceUtils::free_in_vs_bytes() {
 378   return free_in_vs_bytes(Metaspace::ClassType) + free_in_vs_bytes(Metaspace::NonClassType);
 379 }
 380 
 381 static void inc_stat_nonatomically(size_t* pstat, size_t words) {
 382   assert_lock_strong(MetaspaceExpand_lock);
 383   (*pstat) += words;
 384 }
 385 
 386 static void dec_stat_nonatomically(size_t* pstat, size_t words) {
 387   assert_lock_strong(MetaspaceExpand_lock);
 388   const size_t size_now = *pstat;
 389   assert(size_now &gt;= words, &quot;About to decrement counter below zero &quot;
 390          &quot;(current value: &quot; SIZE_FORMAT &quot;, decrement value: &quot; SIZE_FORMAT &quot;.&quot;,
 391          size_now, words);
 392   *pstat = size_now - words;
 393 }
 394 
 395 static void inc_stat_atomically(volatile size_t* pstat, size_t words) {
<span class="line-modified"> 396   Atomic::add(words, pstat);</span>
 397 }
 398 
 399 static void dec_stat_atomically(volatile size_t* pstat, size_t words) {
 400   const size_t size_now = *pstat;
 401   assert(size_now &gt;= words, &quot;About to decrement counter below zero &quot;
 402          &quot;(current value: &quot; SIZE_FORMAT &quot;, decrement value: &quot; SIZE_FORMAT &quot;.&quot;,
 403          size_now, words);
<span class="line-modified"> 404   Atomic::sub(words, pstat);</span>
 405 }
 406 
 407 void MetaspaceUtils::dec_capacity(Metaspace::MetadataType mdtype, size_t words) {
 408   dec_stat_nonatomically(&amp;_capacity_words[mdtype], words);
 409 }
 410 void MetaspaceUtils::inc_capacity(Metaspace::MetadataType mdtype, size_t words) {
 411   inc_stat_nonatomically(&amp;_capacity_words[mdtype], words);
 412 }
 413 void MetaspaceUtils::dec_used(Metaspace::MetadataType mdtype, size_t words) {
 414   dec_stat_atomically(&amp;_used_words[mdtype], words);
 415 }
 416 void MetaspaceUtils::inc_used(Metaspace::MetadataType mdtype, size_t words) {
 417   inc_stat_atomically(&amp;_used_words[mdtype], words);
 418 }
 419 void MetaspaceUtils::dec_overhead(Metaspace::MetadataType mdtype, size_t words) {
 420   dec_stat_nonatomically(&amp;_overhead_words[mdtype], words);
 421 }
 422 void MetaspaceUtils::inc_overhead(Metaspace::MetadataType mdtype, size_t words) {
 423   inc_stat_nonatomically(&amp;_overhead_words[mdtype], words);
 424 }
</pre>
<hr />
<pre>
 452          free_chunks_total_words(Metaspace::NonClassType);
 453 }
 454 
 455 size_t MetaspaceUtils::free_chunks_total_bytes() {
 456   return free_chunks_total_words() * BytesPerWord;
 457 }
 458 
 459 bool MetaspaceUtils::has_chunk_free_list(Metaspace::MetadataType mdtype) {
 460   return Metaspace::get_chunk_manager(mdtype) != NULL;
 461 }
 462 
 463 MetaspaceChunkFreeListSummary MetaspaceUtils::chunk_free_list_summary(Metaspace::MetadataType mdtype) {
 464   if (!has_chunk_free_list(mdtype)) {
 465     return MetaspaceChunkFreeListSummary();
 466   }
 467 
 468   const ChunkManager* cm = Metaspace::get_chunk_manager(mdtype);
 469   return cm-&gt;chunk_free_list_summary();
 470 }
 471 
<span class="line-modified"> 472 void MetaspaceUtils::print_metaspace_change(size_t prev_metadata_used) {</span>
<span class="line-modified"> 473   log_info(gc, metaspace)(&quot;Metaspace: &quot;  SIZE_FORMAT &quot;K-&gt;&quot; SIZE_FORMAT &quot;K(&quot;  SIZE_FORMAT &quot;K)&quot;,</span>
<span class="line-modified"> 474                           prev_metadata_used/K, used_bytes()/K, reserved_bytes()/K);</span>



























 475 }
 476 
 477 void MetaspaceUtils::print_on(outputStream* out) {
 478   Metaspace::MetadataType nct = Metaspace::NonClassType;
 479 
 480   out-&gt;print_cr(&quot; Metaspace       &quot;
 481                 &quot;used &quot;      SIZE_FORMAT &quot;K, &quot;
 482                 &quot;capacity &quot;  SIZE_FORMAT &quot;K, &quot;
 483                 &quot;committed &quot; SIZE_FORMAT &quot;K, &quot;
 484                 &quot;reserved &quot;  SIZE_FORMAT &quot;K&quot;,
 485                 used_bytes()/K,
 486                 capacity_bytes()/K,
 487                 committed_bytes()/K,
 488                 reserved_bytes()/K);
 489 
 490   if (Metaspace::using_class_space()) {
 491     Metaspace::MetadataType ct = Metaspace::ClassType;
 492     out-&gt;print_cr(&quot;  class space    &quot;
 493                   &quot;used &quot;      SIZE_FORMAT &quot;K, &quot;
 494                   &quot;capacity &quot;  SIZE_FORMAT &quot;K, &quot;
</pre>
<hr />
<pre>
 517     if (Metaspace::using_class_space()) {
 518       const size_t reserved_class_words = reserved_bytes(Metaspace::ClassType) / sizeof(MetaWord);
 519       const size_t committed_class_words = committed_bytes(Metaspace::ClassType) / sizeof(MetaWord);
 520       out-&gt;print(&quot;      Class space:  &quot;);
 521       print_scaled_words(out, reserved_class_words, scale, 7);
 522       out-&gt;print(&quot; reserved, &quot;);
 523       print_scaled_words_and_percentage(out, committed_class_words, reserved_class_words, scale, 7);
 524       out-&gt;print_cr(&quot; committed &quot;);
 525 
 526       const size_t reserved_words = reserved_nonclass_words + reserved_class_words;
 527       const size_t committed_words = committed_nonclass_words + committed_class_words;
 528       out-&gt;print(&quot;             Both:  &quot;);
 529       print_scaled_words(out, reserved_words, scale, 7);
 530       out-&gt;print(&quot; reserved, &quot;);
 531       print_scaled_words_and_percentage(out, committed_words, reserved_words, scale, 7);
 532       out-&gt;print_cr(&quot; committed &quot;);
 533     }
 534   }
 535 }
 536 

















 537 // This will print out a basic metaspace usage report but
 538 // unlike print_report() is guaranteed not to lock or to walk the CLDG.
 539 void MetaspaceUtils::print_basic_report(outputStream* out, size_t scale) {
 540 





 541   out-&gt;cr();
 542   out-&gt;print_cr(&quot;Usage:&quot;);
 543 
 544   if (Metaspace::using_class_space()) {
 545     out-&gt;print(&quot;  Non-class:  &quot;);
 546   }
 547 
 548   // In its most basic form, we do not require walking the CLDG. Instead, just print the running totals from
 549   // MetaspaceUtils.
 550   const size_t cap_nc = MetaspaceUtils::capacity_words(Metaspace::NonClassType);
 551   const size_t overhead_nc = MetaspaceUtils::overhead_words(Metaspace::NonClassType);
 552   const size_t used_nc = MetaspaceUtils::used_words(Metaspace::NonClassType);
 553   const size_t free_and_waste_nc = cap_nc - overhead_nc - used_nc;
 554 
 555   print_scaled_words(out, cap_nc, scale, 5);
 556   out-&gt;print(&quot; capacity, &quot;);
 557   print_scaled_words_and_percentage(out, used_nc, cap_nc, scale, 5);
 558   out-&gt;print(&quot; used, &quot;);
 559   print_scaled_words_and_percentage(out, free_and_waste_nc, cap_nc, scale, 5);
 560   out-&gt;print(&quot; free+waste, &quot;);
</pre>
<hr />
<pre>
 597 
 598   print_vs(out, scale);
 599 
 600   out-&gt;cr();
 601   out-&gt;print_cr(&quot;Chunk freelists:&quot;);
 602 
 603   if (Metaspace::using_class_space()) {
 604     out-&gt;print(&quot;   Non-Class:  &quot;);
 605   }
 606   print_human_readable_size(out, Metaspace::chunk_manager_metadata()-&gt;free_chunks_total_bytes(), scale);
 607   out-&gt;cr();
 608   if (Metaspace::using_class_space()) {
 609     out-&gt;print(&quot;       Class:  &quot;);
 610     print_human_readable_size(out, Metaspace::chunk_manager_class()-&gt;free_chunks_total_bytes(), scale);
 611     out-&gt;cr();
 612     out-&gt;print(&quot;        Both:  &quot;);
 613     print_human_readable_size(out, Metaspace::chunk_manager_class()-&gt;free_chunks_total_bytes() +
 614                               Metaspace::chunk_manager_metadata()-&gt;free_chunks_total_bytes(), scale);
 615     out-&gt;cr();
 616   }






 617   out-&gt;cr();
 618 
 619 }
 620 
 621 void MetaspaceUtils::print_report(outputStream* out, size_t scale, int flags) {
 622 





 623   const bool print_loaders = (flags &amp; rf_show_loaders) &gt; 0;
 624   const bool print_classes = (flags &amp; rf_show_classes) &gt; 0;
 625   const bool print_by_chunktype = (flags &amp; rf_break_down_by_chunktype) &gt; 0;
 626   const bool print_by_spacetype = (flags &amp; rf_break_down_by_spacetype) &gt; 0;
 627 
 628   // Some report options require walking the class loader data graph.
 629   PrintCLDMetaspaceInfoClosure cl(out, scale, print_loaders, print_classes, print_by_chunktype);
 630   if (print_loaders) {
 631     out-&gt;cr();
 632     out-&gt;print_cr(&quot;Usage per loader:&quot;);
 633     out-&gt;cr();
 634   }
 635 
 636   ClassLoaderDataGraph::loaded_cld_do(&amp;cl); // collect data and optionally print
 637 
 638   // Print totals, broken up by space type.
 639   if (print_by_spacetype) {
 640     out-&gt;cr();
 641     out-&gt;print_cr(&quot;Usage per space type:&quot;);
 642     out-&gt;cr();
 643     for (int space_type = (int)Metaspace::ZeroMetaspaceType;
 644          space_type &lt; (int)Metaspace::MetaspaceTypeCount; space_type ++)
 645     {
<span class="line-modified"> 646       uintx num = cl._num_loaders_by_spacetype[space_type];</span>
<span class="line-modified"> 647       out-&gt;print(&quot;%s (&quot; UINTX_FORMAT &quot; loader%s)%c&quot;,</span>

 648         space_type_name((Metaspace::MetaspaceType)space_type),
<span class="line-modified"> 649         num, (num == 1 ? &quot;&quot; : &quot;s&quot;), (num &gt; 0 ? &#39;:&#39; : &#39;.&#39;));</span>
<span class="line-modified"> 650       if (num &gt; 0) {</span>



 651         cl._stats_by_spacetype[space_type].print_on(out, scale, print_by_chunktype);



 652       }
 653       out-&gt;cr();
 654     }
 655   }
 656 
 657   // Print totals for in-use data:
 658   out-&gt;cr();
<span class="line-modified"> 659   out-&gt;print_cr(&quot;Total Usage ( &quot; UINTX_FORMAT &quot; loader%s)%c&quot;,</span>
<span class="line-modified"> 660       cl._num_loaders, (cl._num_loaders == 1 ? &quot;&quot; : &quot;s&quot;), (cl._num_loaders &gt; 0 ? &#39;:&#39; : &#39;.&#39;));</span>
<span class="line-modified"> 661 </span>
<span class="line-modified"> 662   cl._stats_total.print_on(out, scale, print_by_chunktype);</span>





 663 
 664   // -- Print Virtual space.
 665   out-&gt;cr();
 666   out-&gt;print_cr(&quot;Virtual space:&quot;);
 667 
 668   print_vs(out, scale);
 669 
 670   // -- Print VirtualSpaceList details.
 671   if ((flags &amp; rf_show_vslist) &gt; 0) {
 672     out-&gt;cr();
 673     out-&gt;print_cr(&quot;Virtual space list%s:&quot;, Metaspace::using_class_space() ? &quot;s&quot; : &quot;&quot;);
 674 
 675     if (Metaspace::using_class_space()) {
 676       out-&gt;print_cr(&quot;   Non-Class:&quot;);
 677     }
 678     Metaspace::space_list()-&gt;print_on(out, scale);
 679     if (Metaspace::using_class_space()) {
 680       out-&gt;print_cr(&quot;       Class:&quot;);
 681       Metaspace::class_space_list()-&gt;print_on(out, scale);
 682     }
</pre>
<hr />
<pre>
 788   out-&gt;print_cr(&quot;Number of space births: &quot; UINTX_FORMAT &quot;.&quot;, g_internal_statistics.num_metaspace_births);
 789   out-&gt;print_cr(&quot;Number of space deaths: &quot; UINTX_FORMAT &quot;.&quot;, g_internal_statistics.num_metaspace_deaths);
 790   out-&gt;print_cr(&quot;Number of virtual space node births: &quot; UINTX_FORMAT &quot;.&quot;, g_internal_statistics.num_vsnodes_created);
 791   out-&gt;print_cr(&quot;Number of virtual space node deaths: &quot; UINTX_FORMAT &quot;.&quot;, g_internal_statistics.num_vsnodes_purged);
 792   out-&gt;print_cr(&quot;Number of times virtual space nodes were expanded: &quot; UINTX_FORMAT &quot;.&quot;, g_internal_statistics.num_committed_space_expanded);
 793   out-&gt;print_cr(&quot;Number of deallocations: &quot; UINTX_FORMAT &quot; (&quot; UINTX_FORMAT &quot; external).&quot;, g_internal_statistics.num_deallocs, g_internal_statistics.num_external_deallocs);
 794   out-&gt;print_cr(&quot;Allocations from deallocated blocks: &quot; UINTX_FORMAT &quot;.&quot;, g_internal_statistics.num_allocs_from_deallocated_blocks);
 795   out-&gt;print_cr(&quot;Number of chunks added to freelist: &quot; UINTX_FORMAT &quot;.&quot;,
 796                 g_internal_statistics.num_chunks_added_to_freelist);
 797   out-&gt;print_cr(&quot;Number of chunks removed from freelist: &quot; UINTX_FORMAT &quot;.&quot;,
 798                 g_internal_statistics.num_chunks_removed_from_freelist);
 799   out-&gt;print_cr(&quot;Number of chunk merges: &quot; UINTX_FORMAT &quot;, split-ups: &quot; UINTX_FORMAT &quot;.&quot;,
 800                 g_internal_statistics.num_chunk_merges, g_internal_statistics.num_chunk_splits);
 801 
 802   out-&gt;cr();
 803 #endif
 804 
 805   // Print some interesting settings
 806   out-&gt;cr();
 807   out-&gt;cr();
<span class="line-modified"> 808   out-&gt;print(&quot;MaxMetaspaceSize: &quot;);</span>
<span class="line-modified"> 809   print_human_readable_size(out, MaxMetaspaceSize, scale);</span>
 810   out-&gt;cr();
 811   out-&gt;print(&quot;InitialBootClassLoaderMetaspaceSize: &quot;);
 812   print_human_readable_size(out, InitialBootClassLoaderMetaspaceSize, scale);
<span class="line-removed"> 813   out-&gt;cr();</span>
<span class="line-removed"> 814 </span>
<span class="line-removed"> 815   out-&gt;print(&quot;UseCompressedClassPointers: %s&quot;, UseCompressedClassPointers ? &quot;true&quot; : &quot;false&quot;);</span>
<span class="line-removed"> 816   out-&gt;cr();</span>
<span class="line-removed"> 817   if (Metaspace::using_class_space()) {</span>
<span class="line-removed"> 818     out-&gt;print(&quot;CompressedClassSpaceSize: &quot;);</span>
<span class="line-removed"> 819     print_human_readable_size(out, CompressedClassSpaceSize, scale);</span>
<span class="line-removed"> 820   }</span>
 821 
 822   out-&gt;cr();
 823   out-&gt;cr();
 824 
 825 } // MetaspaceUtils::print_report()
 826 
 827 // Prints an ASCII representation of the given space.
 828 void MetaspaceUtils::print_metaspace_map(outputStream* out, Metaspace::MetadataType mdtype) {
<span class="line-modified"> 829   MutexLockerEx cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
 830   const bool for_class = mdtype == Metaspace::ClassType ? true : false;
 831   VirtualSpaceList* const vsl = for_class ? Metaspace::class_space_list() : Metaspace::space_list();
 832   if (vsl != NULL) {
 833     if (for_class) {
 834       if (!Metaspace::using_class_space()) {
 835         out-&gt;print_cr(&quot;No Class Space.&quot;);
 836         return;
 837       }
 838       out-&gt;print_raw(&quot;---- Metaspace Map (Class Space) ----&quot;);
 839     } else {
 840       out-&gt;print_raw(&quot;---- Metaspace Map (Non-Class Space) ----&quot;);
 841     }
 842     // Print legend:
 843     out-&gt;cr();
 844     out-&gt;print_cr(&quot;Chunk Types (uppercase chunks are in use): x-specialized, s-small, m-medium, h-humongous.&quot;);
 845     out-&gt;cr();
 846     VirtualSpaceList* const vsl = for_class ? Metaspace::class_space_list() : Metaspace::space_list();
 847     vsl-&gt;print_map(out);
 848     out-&gt;cr();
 849   }
</pre>
<hr />
<pre>
 872   bool mismatch = false;
 873   for (int i = 0; i &lt; Metaspace::MetadataTypeCount; i ++) {
 874     Metaspace::MetadataType mdtype = (Metaspace::MetadataType)i;
 875     UsedChunksStatistics chunk_stat = total_stat.sm_stats(mdtype).totals();
 876     if (capacity_words(mdtype) != chunk_stat.cap() ||
 877         used_words(mdtype) != chunk_stat.used() ||
 878         overhead_words(mdtype) != chunk_stat.overhead()) {
 879       mismatch = true;
 880       tty-&gt;print_cr(&quot;MetaspaceUtils::verify_metrics: counter mismatch for mdtype=%u:&quot;, mdtype);
 881       tty-&gt;print_cr(&quot;Expected cap &quot; SIZE_FORMAT &quot;, used &quot; SIZE_FORMAT &quot;, overhead &quot; SIZE_FORMAT &quot;.&quot;,
 882                     capacity_words(mdtype), used_words(mdtype), overhead_words(mdtype));
 883       tty-&gt;print_cr(&quot;Got cap &quot; SIZE_FORMAT &quot;, used &quot; SIZE_FORMAT &quot;, overhead &quot; SIZE_FORMAT &quot;.&quot;,
 884                     chunk_stat.cap(), chunk_stat.used(), chunk_stat.overhead());
 885       tty-&gt;flush();
 886     }
 887   }
 888   assert(mismatch == false, &quot;MetaspaceUtils::verify_metrics: counter mismatch.&quot;);
 889 #endif
 890 }
 891 
<span class="line-removed"> 892 // Utils to check if a pointer or range is part of a committed metaspace region.</span>
<span class="line-removed"> 893 metaspace::VirtualSpaceNode* MetaspaceUtils::find_enclosing_virtual_space(const void* p) {</span>
<span class="line-removed"> 894   MutexLockerEx cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed"> 895   VirtualSpaceNode* vsn = Metaspace::space_list()-&gt;find_enclosing_space(p);</span>
<span class="line-removed"> 896   if (Metaspace::using_class_space() &amp;&amp; vsn == NULL) {</span>
<span class="line-removed"> 897     vsn = Metaspace::class_space_list()-&gt;find_enclosing_space(p);</span>
<span class="line-removed"> 898   }</span>
<span class="line-removed"> 899   return vsn;</span>
<span class="line-removed"> 900 }</span>
<span class="line-removed"> 901 </span>
<span class="line-removed"> 902 bool MetaspaceUtils::is_range_in_committed(const void* from, const void* to) {</span>
<span class="line-removed"> 903 #if INCLUDE_CDS</span>
<span class="line-removed"> 904   if (UseSharedSpaces) {</span>
<span class="line-removed"> 905     for (int idx = MetaspaceShared::ro; idx &lt;= MetaspaceShared::mc; idx++) {</span>
<span class="line-removed"> 906       if (FileMapInfo::current_info()-&gt;is_in_shared_region(from, idx)) {</span>
<span class="line-removed"> 907         return FileMapInfo::current_info()-&gt;is_in_shared_region(to, idx);</span>
<span class="line-removed"> 908       }</span>
<span class="line-removed"> 909     }</span>
<span class="line-removed"> 910   }</span>
<span class="line-removed"> 911 #endif</span>
<span class="line-removed"> 912   VirtualSpaceNode* vsn = find_enclosing_virtual_space(from);</span>
<span class="line-removed"> 913   return (vsn != NULL) &amp;&amp; vsn-&gt;contains(to);</span>
<span class="line-removed"> 914 }</span>
<span class="line-removed"> 915 </span>
<span class="line-removed"> 916 </span>
 917 // Metaspace methods
 918 
 919 size_t Metaspace::_first_chunk_word_size = 0;
 920 size_t Metaspace::_first_class_chunk_word_size = 0;
 921 
 922 size_t Metaspace::_commit_alignment = 0;
 923 size_t Metaspace::_reserve_alignment = 0;
 924 
 925 VirtualSpaceList* Metaspace::_space_list = NULL;
 926 VirtualSpaceList* Metaspace::_class_space_list = NULL;
 927 
 928 ChunkManager* Metaspace::_chunk_manager_metadata = NULL;
 929 ChunkManager* Metaspace::_chunk_manager_class = NULL;
 930 


 931 #define VIRTUALSPACEMULTIPLIER 2
 932 
 933 #ifdef _LP64
 934 static const uint64_t UnscaledClassSpaceMax = (uint64_t(max_juint) + 1);
 935 
<span class="line-modified"> 936 void Metaspace::set_narrow_klass_base_and_shift(address metaspace_base, address cds_base) {</span>
 937   assert(!DumpSharedSpaces, &quot;narrow_klass is set by MetaspaceShared class.&quot;);
 938   // Figure out the narrow_klass_base and the narrow_klass_shift.  The
 939   // narrow_klass_base is the lower of the metaspace base and the cds base
 940   // (if cds is enabled).  The narrow_klass_shift depends on the distance
 941   // between the lower base and higher address.
<span class="line-modified"> 942   address lower_base;</span>
<span class="line-modified"> 943   address higher_address;</span>
<span class="line-modified"> 944 #if INCLUDE_CDS</span>
<span class="line-modified"> 945   if (UseSharedSpaces) {</span>
<span class="line-modified"> 946     higher_address = MAX2((address)(cds_base + MetaspaceShared::core_spaces_size()),</span>
<span class="line-modified"> 947                           (address)(metaspace_base + compressed_class_space_size()));</span>
<span class="line-removed"> 948     lower_base = MIN2(metaspace_base, cds_base);</span>
<span class="line-removed"> 949   } else</span>
<span class="line-removed"> 950 #endif</span>
<span class="line-removed"> 951   {</span>
<span class="line-removed"> 952     higher_address = metaspace_base + compressed_class_space_size();</span>
<span class="line-removed"> 953     lower_base = metaspace_base;</span>
<span class="line-removed"> 954 </span>
 955     uint64_t klass_encoding_max = UnscaledClassSpaceMax &lt;&lt; LogKlassAlignmentInBytes;
 956     // If compressed class space fits in lower 32G, we don&#39;t need a base.
 957     if (higher_address &lt;= (address)klass_encoding_max) {
 958       lower_base = 0; // Effectively lower base is zero.
 959     }
 960   }
 961 
<span class="line-modified"> 962   Universe::set_narrow_klass_base(lower_base);</span>
 963 
 964   // CDS uses LogKlassAlignmentInBytes for narrow_klass_shift. See
 965   // MetaspaceShared::initialize_dumptime_shared_and_meta_spaces() for
 966   // how dump time narrow_klass_shift is set. Although, CDS can work
 967   // with zero-shift mode also, to be consistent with AOT it uses
 968   // LogKlassAlignmentInBytes for klass shift so archived java heap objects
 969   // can be used at same time as AOT code.
 970   if (!UseSharedSpaces
 971       &amp;&amp; (uint64_t)(higher_address - lower_base) &lt;= UnscaledClassSpaceMax) {
<span class="line-modified"> 972     Universe::set_narrow_klass_shift(0);</span>
 973   } else {
<span class="line-modified"> 974     Universe::set_narrow_klass_shift(LogKlassAlignmentInBytes);</span>
 975   }
 976   AOTLoader::set_narrow_klass_shift();
 977 }
 978 
<span class="line-removed"> 979 #if INCLUDE_CDS</span>
<span class="line-removed"> 980 // Return TRUE if the specified metaspace_base and cds_base are close enough</span>
<span class="line-removed"> 981 // to work with compressed klass pointers.</span>
<span class="line-removed"> 982 bool Metaspace::can_use_cds_with_metaspace_addr(char* metaspace_base, address cds_base) {</span>
<span class="line-removed"> 983   assert(cds_base != 0 &amp;&amp; UseSharedSpaces, &quot;Only use with CDS&quot;);</span>
<span class="line-removed"> 984   assert(UseCompressedClassPointers, &quot;Only use with CompressedKlassPtrs&quot;);</span>
<span class="line-removed"> 985   address lower_base = MIN2((address)metaspace_base, cds_base);</span>
<span class="line-removed"> 986   address higher_address = MAX2((address)(cds_base + MetaspaceShared::core_spaces_size()),</span>
<span class="line-removed"> 987                                 (address)(metaspace_base + compressed_class_space_size()));</span>
<span class="line-removed"> 988   return ((uint64_t)(higher_address - lower_base) &lt;= UnscaledClassSpaceMax);</span>
<span class="line-removed"> 989 }</span>
<span class="line-removed"> 990 #endif</span>
<span class="line-removed"> 991 </span>
 992 // Try to allocate the metaspace at the requested addr.
<span class="line-modified"> 993 void Metaspace::allocate_metaspace_compressed_klass_ptrs(char* requested_addr, address cds_base) {</span>
 994   assert(!DumpSharedSpaces, &quot;compress klass space is allocated by MetaspaceShared class.&quot;);
 995   assert(using_class_space(), &quot;called improperly&quot;);
 996   assert(UseCompressedClassPointers, &quot;Only use with CompressedKlassPtrs&quot;);
 997   assert(compressed_class_space_size() &lt; KlassEncodingMetaspaceMax,
 998          &quot;Metaspace size is too big&quot;);
 999   assert_is_aligned(requested_addr, _reserve_alignment);
1000   assert_is_aligned(cds_base, _reserve_alignment);
1001   assert_is_aligned(compressed_class_space_size(), _reserve_alignment);
1002 
<span class="line-modified">1003   // Don&#39;t use large pages for the class space.</span>
<span class="line-modified">1004   bool large_pages = false;</span>
<span class="line-modified">1005 </span>
<span class="line-modified">1006 #if !(defined(AARCH64) || defined(AIX))</span>
<span class="line-modified">1007   ReservedSpace metaspace_rs = ReservedSpace(compressed_class_space_size(),</span>
<span class="line-modified">1008                                              _reserve_alignment,</span>
<span class="line-modified">1009                                              large_pages,</span>
<span class="line-modified">1010                                              requested_addr);</span>
<span class="line-modified">1011 #else // AARCH64</span>
<span class="line-removed">1012   ReservedSpace metaspace_rs;</span>
<span class="line-removed">1013 </span>
<span class="line-removed">1014   // Our compressed klass pointers may fit nicely into the lower 32</span>
<span class="line-removed">1015   // bits.</span>
<span class="line-removed">1016   if ((uint64_t)requested_addr + compressed_class_space_size() &lt; 4*G) {</span>
<span class="line-removed">1017     metaspace_rs = ReservedSpace(compressed_class_space_size(),</span>
<span class="line-removed">1018                                  _reserve_alignment,</span>
<span class="line-removed">1019                                  large_pages,</span>
<span class="line-removed">1020                                  requested_addr);</span>
<span class="line-removed">1021   }</span>
<span class="line-removed">1022 </span>
<span class="line-removed">1023   if (! metaspace_rs.is_reserved()) {</span>
<span class="line-removed">1024     // Aarch64: Try to align metaspace so that we can decode a compressed</span>
<span class="line-removed">1025     // klass with a single MOVK instruction.  We can do this iff the</span>
<span class="line-removed">1026     // compressed class base is a multiple of 4G.</span>
<span class="line-removed">1027     // Aix: Search for a place where we can find memory. If we need to load</span>
<span class="line-removed">1028     // the base, 4G alignment is helpful, too.</span>
<span class="line-removed">1029     size_t increment = AARCH64_ONLY(4*)G;</span>
<span class="line-removed">1030     for (char *a = align_up(requested_addr, increment);</span>
<span class="line-removed">1031          a &lt; (char*)(1024*G);</span>
<span class="line-removed">1032          a += increment) {</span>
<span class="line-removed">1033       if (a == (char *)(32*G)) {</span>
<span class="line-removed">1034         // Go faster from here on. Zero-based is no longer possible.</span>
<span class="line-removed">1035         increment = 4*G;</span>
<span class="line-removed">1036       }</span>
<span class="line-removed">1037 </span>
<span class="line-removed">1038 #if INCLUDE_CDS</span>
<span class="line-removed">1039       if (UseSharedSpaces</span>
<span class="line-removed">1040           &amp;&amp; ! can_use_cds_with_metaspace_addr(a, cds_base)) {</span>
<span class="line-removed">1041         // We failed to find an aligned base that will reach.  Fall</span>
<span class="line-removed">1042         // back to using our requested addr.</span>
<span class="line-removed">1043         metaspace_rs = ReservedSpace(compressed_class_space_size(),</span>
<span class="line-removed">1044                                      _reserve_alignment,</span>
<span class="line-removed">1045                                      large_pages,</span>
<span class="line-removed">1046                                      requested_addr);</span>
<span class="line-removed">1047         break;</span>
<span class="line-removed">1048       }</span>
<span class="line-removed">1049 #endif</span>
<span class="line-removed">1050 </span>
<span class="line-removed">1051       metaspace_rs = ReservedSpace(compressed_class_space_size(),</span>
<span class="line-removed">1052                                    _reserve_alignment,</span>
<span class="line-removed">1053                                    large_pages,</span>
<span class="line-removed">1054                                    a);</span>
<span class="line-removed">1055       if (metaspace_rs.is_reserved())</span>
<span class="line-removed">1056         break;</span>
<span class="line-removed">1057     }</span>
1058   }
1059 
<span class="line-removed">1060 #endif // AARCH64</span>
<span class="line-removed">1061 </span>
1062   if (!metaspace_rs.is_reserved()) {
<span class="line-modified">1063 #if INCLUDE_CDS</span>
<span class="line-removed">1064     if (UseSharedSpaces) {</span>
<span class="line-removed">1065       size_t increment = align_up(1*G, _reserve_alignment);</span>
<span class="line-removed">1066 </span>
<span class="line-removed">1067       // Keep trying to allocate the metaspace, increasing the requested_addr</span>
<span class="line-removed">1068       // by 1GB each time, until we reach an address that will no longer allow</span>
<span class="line-removed">1069       // use of CDS with compressed klass pointers.</span>
<span class="line-removed">1070       char *addr = requested_addr;</span>
<span class="line-removed">1071       while (!metaspace_rs.is_reserved() &amp;&amp; (addr + increment &gt; addr) &amp;&amp;</span>
<span class="line-removed">1072              can_use_cds_with_metaspace_addr(addr + increment, cds_base)) {</span>
<span class="line-removed">1073         addr = addr + increment;</span>
<span class="line-removed">1074         metaspace_rs = ReservedSpace(compressed_class_space_size(),</span>
<span class="line-removed">1075                                      _reserve_alignment, large_pages, addr);</span>
<span class="line-removed">1076       }</span>
<span class="line-removed">1077     }</span>
<span class="line-removed">1078 #endif</span>
1079     // If no successful allocation then try to allocate the space anywhere.  If
1080     // that fails then OOM doom.  At this point we cannot try allocating the
1081     // metaspace as if UseCompressedClassPointers is off because too much
1082     // initialization has happened that depends on UseCompressedClassPointers.
1083     // So, UseCompressedClassPointers cannot be turned off at this point.


1084     if (!metaspace_rs.is_reserved()) {
<span class="line-modified">1085       metaspace_rs = ReservedSpace(compressed_class_space_size(),</span>
<span class="line-modified">1086                                    _reserve_alignment, large_pages);</span>
<span class="line-removed">1087       if (!metaspace_rs.is_reserved()) {</span>
<span class="line-removed">1088         vm_exit_during_initialization(err_msg(&quot;Could not allocate metaspace: &quot; SIZE_FORMAT &quot; bytes&quot;,</span>
<span class="line-removed">1089                                               compressed_class_space_size()));</span>
<span class="line-removed">1090       }</span>
1091     }
1092   }
1093 
<span class="line-modified">1094   // If we got here then the metaspace got allocated.</span>
<span class="line-modified">1095   MemTracker::record_virtual_memory_type((address)metaspace_rs.base(), mtClass);</span>
<span class="line-modified">1096 </span>
<span class="line-removed">1097 #if INCLUDE_CDS</span>
<span class="line-removed">1098   // Verify that we can use shared spaces.  Otherwise, turn off CDS.</span>
<span class="line-removed">1099   if (UseSharedSpaces &amp;&amp; !can_use_cds_with_metaspace_addr(metaspace_rs.base(), cds_base)) {</span>
<span class="line-removed">1100     FileMapInfo::stop_sharing_and_unmap(</span>
<span class="line-removed">1101         &quot;Could not allocate metaspace at a compatible address&quot;);</span>
1102   }
<span class="line-modified">1103 #endif</span>
<span class="line-modified">1104   set_narrow_klass_base_and_shift((address)metaspace_rs.base(),</span>
<span class="line-removed">1105                                   UseSharedSpaces ? (address)cds_base : 0);</span>
1106 
1107   initialize_class_space(metaspace_rs);
1108 
1109   LogTarget(Trace, gc, metaspace) lt;
1110   if (lt.is_enabled()) {
1111     ResourceMark rm;
1112     LogStream ls(lt);
1113     print_compressed_class_space(&amp;ls, requested_addr);
1114   }
1115 }
1116 
1117 void Metaspace::print_compressed_class_space(outputStream* st, const char* requested_addr) {
1118   st-&gt;print_cr(&quot;Narrow klass base: &quot; PTR_FORMAT &quot;, Narrow klass shift: %d&quot;,
<span class="line-modified">1119                p2i(Universe::narrow_klass_base()), Universe::narrow_klass_shift());</span>
1120   if (_class_space_list != NULL) {
1121     address base = (address)_class_space_list-&gt;current_virtual_space()-&gt;bottom();
1122     st-&gt;print(&quot;Compressed class space size: &quot; SIZE_FORMAT &quot; Address: &quot; PTR_FORMAT,
1123                  compressed_class_space_size(), p2i(base));
1124     if (requested_addr != 0) {
1125       st-&gt;print(&quot; Req Addr: &quot; PTR_FORMAT, p2i(requested_addr));
1126     }
1127     st-&gt;cr();
1128   }
1129 }
1130 
1131 // For UseCompressedClassPointers the class space is reserved above the top of
1132 // the Java heap.  The argument passed in is at the base of the compressed space.
1133 void Metaspace::initialize_class_space(ReservedSpace rs) {
1134   // The reserved space size may be bigger because of alignment, esp with UseLargePages
1135   assert(rs.size() &gt;= CompressedClassSpaceSize,
1136          SIZE_FORMAT &quot; != &quot; SIZE_FORMAT, rs.size(), CompressedClassSpaceSize);
1137   assert(using_class_space(), &quot;Must be using class space&quot;);
1138   _class_space_list = new VirtualSpaceList(rs);
1139   _chunk_manager_class = new ChunkManager(true/*is_class*/);
1140 
1141   if (!_class_space_list-&gt;initialization_succeeded()) {
1142     vm_exit_during_initialization(&quot;Failed to setup compressed class space virtual space list.&quot;);
1143   }
1144 }
1145 








































































1146 #endif

1147 
1148 void Metaspace::ergo_initialize() {
1149   if (DumpSharedSpaces) {
1150     // Using large pages when dumping the shared archive is currently not implemented.
<span class="line-modified">1151     FLAG_SET_ERGO(bool, UseLargePagesInMetaspace, false);</span>
1152   }
1153 
1154   size_t page_size = os::vm_page_size();
1155   if (UseLargePages &amp;&amp; UseLargePagesInMetaspace) {
1156     page_size = os::large_page_size();
1157   }
1158 
1159   _commit_alignment  = page_size;
1160   _reserve_alignment = MAX2(page_size, (size_t)os::vm_allocation_granularity());
1161 
1162   // Do not use FLAG_SET_ERGO to update MaxMetaspaceSize, since this will
1163   // override if MaxMetaspaceSize was set on the command line or not.
1164   // This information is needed later to conform to the specification of the
1165   // java.lang.management.MemoryUsage API.
1166   //
1167   // Ideally, we would be able to set the default value of MaxMetaspaceSize in
1168   // globals.hpp to the aligned value, but this is not possible, since the
1169   // alignment depends on other flags being parsed.
1170   MaxMetaspaceSize = align_down_bounded(MaxMetaspaceSize, _reserve_alignment);
1171 
</pre>
<hr />
<pre>
1173     MetaspaceSize = MaxMetaspaceSize;
1174   }
1175 
1176   MetaspaceSize = align_down_bounded(MetaspaceSize, _commit_alignment);
1177 
1178   assert(MetaspaceSize &lt;= MaxMetaspaceSize, &quot;MetaspaceSize should be limited by MaxMetaspaceSize&quot;);
1179 
1180   MinMetaspaceExpansion = align_down_bounded(MinMetaspaceExpansion, _commit_alignment);
1181   MaxMetaspaceExpansion = align_down_bounded(MaxMetaspaceExpansion, _commit_alignment);
1182 
1183   CompressedClassSpaceSize = align_down_bounded(CompressedClassSpaceSize, _reserve_alignment);
1184 
1185   // Initial virtual space size will be calculated at global_initialize()
1186   size_t min_metaspace_sz =
1187       VIRTUALSPACEMULTIPLIER * InitialBootClassLoaderMetaspaceSize;
1188   if (UseCompressedClassPointers) {
1189     if ((min_metaspace_sz + CompressedClassSpaceSize) &gt;  MaxMetaspaceSize) {
1190       if (min_metaspace_sz &gt;= MaxMetaspaceSize) {
1191         vm_exit_during_initialization(&quot;MaxMetaspaceSize is too small.&quot;);
1192       } else {
<span class="line-modified">1193         FLAG_SET_ERGO(size_t, CompressedClassSpaceSize,</span>
1194                       MaxMetaspaceSize - min_metaspace_sz);
1195       }
1196     }
1197   } else if (min_metaspace_sz &gt;= MaxMetaspaceSize) {
<span class="line-modified">1198     FLAG_SET_ERGO(size_t, InitialBootClassLoaderMetaspaceSize,</span>
1199                   min_metaspace_sz);
1200   }
1201 
1202   set_compressed_class_space_size(CompressedClassSpaceSize);
1203 }
1204 
1205 void Metaspace::global_initialize() {
1206   MetaspaceGC::initialize();
1207 

1208 #if INCLUDE_CDS
1209   if (DumpSharedSpaces) {
1210     MetaspaceShared::initialize_dumptime_shared_and_meta_spaces();

1211   } else if (UseSharedSpaces) {
1212     // If any of the archived space fails to map, UseSharedSpaces
<span class="line-modified">1213     // is reset to false. Fall through to the</span>
<span class="line-removed">1214     // (!DumpSharedSpaces &amp;&amp; !UseSharedSpaces) case to set up class</span>
<span class="line-removed">1215     // metaspace.</span>
1216     MetaspaceShared::initialize_runtime_shared_and_meta_spaces();

1217   }
1218 
<span class="line-modified">1219   if (!DumpSharedSpaces &amp;&amp; !UseSharedSpaces)</span>


1220 #endif // INCLUDE_CDS
<span class="line-modified">1221   {</span>
1222 #ifdef _LP64
<span class="line-modified">1223     if (using_class_space()) {</span>
<span class="line-modified">1224       char* base = (char*)align_up(Universe::heap()-&gt;reserved_region().end(), _reserve_alignment);</span>
<span class="line-modified">1225       allocate_metaspace_compressed_klass_ptrs(base, 0);</span>
<span class="line-modified">1226     }</span>
<span class="line-removed">1227 #endif // _LP64</span>
1228   }

1229 
1230   // Initialize these before initializing the VirtualSpaceList
1231   _first_chunk_word_size = InitialBootClassLoaderMetaspaceSize / BytesPerWord;
1232   _first_chunk_word_size = align_word_size_up(_first_chunk_word_size);
1233   // Make the first class chunk bigger than a medium chunk so it&#39;s not put
1234   // on the medium chunk list.   The next chunk will be small and progress
1235   // from there.  This size calculated by -version.
1236   _first_class_chunk_word_size = MIN2((size_t)MediumChunk*6,
1237                                      (CompressedClassSpaceSize/BytesPerWord)*2);
1238   _first_class_chunk_word_size = align_word_size_up(_first_class_chunk_word_size);
1239   // Arbitrarily set the initial virtual space to a multiple
1240   // of the boot class loader size.
1241   size_t word_size = VIRTUALSPACEMULTIPLIER * _first_chunk_word_size;
1242   word_size = align_up(word_size, Metaspace::reserve_alignment_words());
1243 
1244   // Initialize the list of virtual spaces.
1245   _space_list = new VirtualSpaceList(word_size);
1246   _chunk_manager_metadata = new ChunkManager(false/*metaspace*/);
1247 
1248   if (!_space_list-&gt;initialization_succeeded()) {
1249     vm_exit_during_initialization(&quot;Unable to setup metadata virtual space list.&quot;, NULL);
1250   }
1251 
1252   _tracer = new MetaspaceTracer();



1253 }
1254 
1255 void Metaspace::post_initialize() {
1256   MetaspaceGC::post_initialize();
1257 }
1258 
1259 void Metaspace::verify_global_initialization() {
1260   assert(space_list() != NULL, &quot;Metadata VirtualSpaceList has not been initialized&quot;);
1261   assert(chunk_manager_metadata() != NULL, &quot;Metadata ChunkManager has not been initialized&quot;);
1262 
1263   if (using_class_space()) {
1264     assert(class_space_list() != NULL, &quot;Class VirtualSpaceList has not been initialized&quot;);
1265     assert(chunk_manager_class() != NULL, &quot;Class ChunkManager has not been initialized&quot;);
1266   }
1267 }
1268 
1269 size_t Metaspace::align_word_size_up(size_t word_size) {
1270   size_t byte_size = word_size * wordSize;
1271   return ReservedSpace::allocation_align_size_up(byte_size) / wordSize;
1272 }
</pre>
<hr />
<pre>
1370   } else {
1371     THROW_OOP(Universe::out_of_memory_error_metaspace());
1372   }
1373 }
1374 
1375 const char* Metaspace::metadata_type_name(Metaspace::MetadataType mdtype) {
1376   switch (mdtype) {
1377     case Metaspace::ClassType: return &quot;Class&quot;;
1378     case Metaspace::NonClassType: return &quot;Metadata&quot;;
1379     default:
1380       assert(false, &quot;Got bad mdtype: %d&quot;, (int) mdtype);
1381       return NULL;
1382   }
1383 }
1384 
1385 void Metaspace::purge(MetadataType mdtype) {
1386   get_space_list(mdtype)-&gt;purge(get_chunk_manager(mdtype));
1387 }
1388 
1389 void Metaspace::purge() {
<span class="line-modified">1390   MutexLockerEx cl(MetaspaceExpand_lock,</span>
<span class="line-modified">1391                    Mutex::_no_safepoint_check_flag);</span>
1392   purge(NonClassType);
1393   if (using_class_space()) {
1394     purge(ClassType);
1395   }
1396 }
1397 
1398 bool Metaspace::contains(const void* ptr) {
1399   if (MetaspaceShared::is_in_shared_metaspace(ptr)) {
1400     return true;
1401   }
1402   return contains_non_shared(ptr);
1403 }
1404 
1405 bool Metaspace::contains_non_shared(const void* ptr) {
1406   if (using_class_space() &amp;&amp; get_space_list(ClassType)-&gt;contains(ptr)) {
1407      return true;
1408   }
1409 
1410   return get_space_list(NonClassType)-&gt;contains(ptr);
1411 }
</pre>
<hr />
<pre>
1448     chunk = Metaspace::get_space_list(mdtype)-&gt;get_new_chunk(chunk_word_size,
1449                                                   get_space_manager(mdtype)-&gt;medium_chunk_bunch());
1450   }
1451 
1452   return chunk;
1453 }
1454 
1455 void ClassLoaderMetaspace::initialize(Mutex* lock, Metaspace::MetaspaceType type) {
1456   Metaspace::verify_global_initialization();
1457 
1458   DEBUG_ONLY(Atomic::inc(&amp;g_internal_statistics.num_metaspace_births));
1459 
1460   // Allocate SpaceManager for metadata objects.
1461   _vsm = new SpaceManager(Metaspace::NonClassType, type, lock);
1462 
1463   if (Metaspace::using_class_space()) {
1464     // Allocate SpaceManager for classes.
1465     _class_vsm = new SpaceManager(Metaspace::ClassType, type, lock);
1466   }
1467 
<span class="line-modified">1468   MutexLockerEx cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
1469 
1470   // Allocate chunk for metadata objects
1471   initialize_first_chunk(type, Metaspace::NonClassType);
1472 
1473   // Allocate chunk for class metadata objects
1474   if (Metaspace::using_class_space()) {
1475     initialize_first_chunk(type, Metaspace::ClassType);
1476   }
1477 }
1478 
1479 MetaWord* ClassLoaderMetaspace::allocate(size_t word_size, Metaspace::MetadataType mdtype) {
1480   Metaspace::assert_not_frozen();
1481 
1482   DEBUG_ONLY(Atomic::inc(&amp;g_internal_statistics.num_allocs));
1483 
1484   // Don&#39;t use class_vsm() unless UseCompressedClassPointers is true.
1485   if (Metaspace::is_class_space_allocation(mdtype)) {
1486     return  class_vsm()-&gt;allocate(word_size);
1487   } else {
1488     return  vsm()-&gt;allocate(word_size);
</pre>
<hr />
<pre>
1517   return res;
1518 }
1519 
1520 size_t ClassLoaderMetaspace::allocated_blocks_bytes() const {
1521   return (vsm()-&gt;used_words() +
1522       (Metaspace::using_class_space() ? class_vsm()-&gt;used_words() : 0)) * BytesPerWord;
1523 }
1524 
1525 size_t ClassLoaderMetaspace::allocated_chunks_bytes() const {
1526   return (vsm()-&gt;capacity_words() +
1527       (Metaspace::using_class_space() ? class_vsm()-&gt;capacity_words() : 0)) * BytesPerWord;
1528 }
1529 
1530 void ClassLoaderMetaspace::deallocate(MetaWord* ptr, size_t word_size, bool is_class) {
1531   Metaspace::assert_not_frozen();
1532   assert(!SafepointSynchronize::is_at_safepoint()
1533          || Thread::current()-&gt;is_VM_thread(), &quot;should be the VM thread&quot;);
1534 
1535   DEBUG_ONLY(Atomic::inc(&amp;g_internal_statistics.num_external_deallocs));
1536 
<span class="line-modified">1537   MutexLockerEx ml(vsm()-&gt;lock(), Mutex::_no_safepoint_check_flag);</span>
1538 
1539   if (is_class &amp;&amp; Metaspace::using_class_space()) {
1540     class_vsm()-&gt;deallocate(ptr, word_size);
1541   } else {
1542     vsm()-&gt;deallocate(ptr, word_size);
1543   }
1544 }
1545 
1546 size_t ClassLoaderMetaspace::class_chunk_size(size_t word_size) {
1547   assert(Metaspace::using_class_space(), &quot;Has to use class space&quot;);
1548   return class_vsm()-&gt;calc_chunk_size(word_size);
1549 }
1550 
1551 void ClassLoaderMetaspace::print_on(outputStream* out) const {
1552   // Print both class virtual space counts and metaspace.
1553   if (Verbose) {
1554     vsm()-&gt;print_on(out);
1555     if (Metaspace::using_class_space()) {
1556       class_vsm()-&gt;print_on(out);
1557     }
1558   }
1559 }
1560 
1561 void ClassLoaderMetaspace::verify() {
1562   vsm()-&gt;verify();
1563   if (Metaspace::using_class_space()) {
1564     class_vsm()-&gt;verify();
1565   }
1566 }
1567 
1568 void ClassLoaderMetaspace::add_to_statistics_locked(ClassLoaderMetaspaceStatistics* out) const {
1569   assert_lock_strong(lock());
1570   vsm()-&gt;add_to_statistics_locked(&amp;out-&gt;nonclass_sm_stats());
1571   if (Metaspace::using_class_space()) {
1572     class_vsm()-&gt;add_to_statistics_locked(&amp;out-&gt;class_sm_stats());
1573   }
1574 }
1575 
1576 void ClassLoaderMetaspace::add_to_statistics(ClassLoaderMetaspaceStatistics* out) const {
<span class="line-modified">1577   MutexLockerEx cl(lock(), Mutex::_no_safepoint_check_flag);</span>
1578   add_to_statistics_locked(out);
1579 }
1580 
1581 /////////////// Unit tests ///////////////
1582 
<span class="line-removed">1583 #ifndef PRODUCT</span>
<span class="line-removed">1584 </span>
<span class="line-removed">1585 class TestMetaspaceUtilsTest : AllStatic {</span>
<span class="line-removed">1586  public:</span>
<span class="line-removed">1587   static void test_reserved() {</span>
<span class="line-removed">1588     size_t reserved = MetaspaceUtils::reserved_bytes();</span>
<span class="line-removed">1589 </span>
<span class="line-removed">1590     assert(reserved &gt; 0, &quot;assert&quot;);</span>
<span class="line-removed">1591 </span>
<span class="line-removed">1592     size_t committed  = MetaspaceUtils::committed_bytes();</span>
<span class="line-removed">1593     assert(committed &lt;= reserved, &quot;assert&quot;);</span>
<span class="line-removed">1594 </span>
<span class="line-removed">1595     size_t reserved_metadata = MetaspaceUtils::reserved_bytes(Metaspace::NonClassType);</span>
<span class="line-removed">1596     assert(reserved_metadata &gt; 0, &quot;assert&quot;);</span>
<span class="line-removed">1597     assert(reserved_metadata &lt;= reserved, &quot;assert&quot;);</span>
<span class="line-removed">1598 </span>
<span class="line-removed">1599     if (UseCompressedClassPointers) {</span>
<span class="line-removed">1600       size_t reserved_class    = MetaspaceUtils::reserved_bytes(Metaspace::ClassType);</span>
<span class="line-removed">1601       assert(reserved_class &gt; 0, &quot;assert&quot;);</span>
<span class="line-removed">1602       assert(reserved_class &lt; reserved, &quot;assert&quot;);</span>
<span class="line-removed">1603     }</span>
<span class="line-removed">1604   }</span>
<span class="line-removed">1605 </span>
<span class="line-removed">1606   static void test_committed() {</span>
<span class="line-removed">1607     size_t committed = MetaspaceUtils::committed_bytes();</span>
<span class="line-removed">1608 </span>
<span class="line-removed">1609     assert(committed &gt; 0, &quot;assert&quot;);</span>
<span class="line-removed">1610 </span>
<span class="line-removed">1611     size_t reserved  = MetaspaceUtils::reserved_bytes();</span>
<span class="line-removed">1612     assert(committed &lt;= reserved, &quot;assert&quot;);</span>
<span class="line-removed">1613 </span>
<span class="line-removed">1614     size_t committed_metadata = MetaspaceUtils::committed_bytes(Metaspace::NonClassType);</span>
<span class="line-removed">1615     assert(committed_metadata &gt; 0, &quot;assert&quot;);</span>
<span class="line-removed">1616     assert(committed_metadata &lt;= committed, &quot;assert&quot;);</span>
<span class="line-removed">1617 </span>
<span class="line-removed">1618     if (UseCompressedClassPointers) {</span>
<span class="line-removed">1619       size_t committed_class    = MetaspaceUtils::committed_bytes(Metaspace::ClassType);</span>
<span class="line-removed">1620       assert(committed_class &gt; 0, &quot;assert&quot;);</span>
<span class="line-removed">1621       assert(committed_class &lt; committed, &quot;assert&quot;);</span>
<span class="line-removed">1622     }</span>
<span class="line-removed">1623   }</span>
<span class="line-removed">1624 </span>
<span class="line-removed">1625   static void test_virtual_space_list_large_chunk() {</span>
<span class="line-removed">1626     VirtualSpaceList* vs_list = new VirtualSpaceList(os::vm_allocation_granularity());</span>
<span class="line-removed">1627     MutexLockerEx cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed">1628     // A size larger than VirtualSpaceSize (256k) and add one page to make it _not_ be</span>
<span class="line-removed">1629     // vm_allocation_granularity aligned on Windows.</span>
<span class="line-removed">1630     size_t large_size = (size_t)(2*256*K + (os::vm_page_size()/BytesPerWord));</span>
<span class="line-removed">1631     large_size += (os::vm_page_size()/BytesPerWord);</span>
<span class="line-removed">1632     vs_list-&gt;get_new_chunk(large_size, 0);</span>
<span class="line-removed">1633   }</span>
<span class="line-removed">1634 </span>
<span class="line-removed">1635   static void test() {</span>
<span class="line-removed">1636     test_reserved();</span>
<span class="line-removed">1637     test_committed();</span>
<span class="line-removed">1638     test_virtual_space_list_large_chunk();</span>
<span class="line-removed">1639   }</span>
<span class="line-removed">1640 };</span>
<span class="line-removed">1641 </span>
<span class="line-removed">1642 void TestMetaspaceUtils_test() {</span>
<span class="line-removed">1643   TestMetaspaceUtilsTest::test();</span>
<span class="line-removed">1644 }</span>
<span class="line-removed">1645 </span>
<span class="line-removed">1646 #endif // !PRODUCT</span>
<span class="line-removed">1647 </span>
1648 struct chunkmanager_statistics_t {
1649   int num_specialized_chunks;
1650   int num_small_chunks;
1651   int num_medium_chunks;
1652   int num_humongous_chunks;
1653 };
1654 
1655 extern void test_metaspace_retrieve_chunkmanager_statistics(Metaspace::MetadataType mdType, chunkmanager_statistics_t* out) {
1656   ChunkManager* const chunk_manager = Metaspace::get_chunk_manager(mdType);
1657   ChunkManagerStatistics stat;
1658   chunk_manager-&gt;collect_statistics(&amp;stat);
1659   out-&gt;num_specialized_chunks = (int)stat.chunk_stats(SpecializedIndex).num();
1660   out-&gt;num_small_chunks = (int)stat.chunk_stats(SmallIndex).num();
1661   out-&gt;num_medium_chunks = (int)stat.chunk_stats(MediumIndex).num();
1662   out-&gt;num_humongous_chunks = (int)stat.chunk_stats(HumongousIndex).num();
1663 }
1664 
1665 struct chunk_geometry_t {
1666   size_t specialized_chunk_word_size;
1667   size_t small_chunk_word_size;
</pre>
</td>
<td>
<hr />
<pre>
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  28 #include &quot;gc/shared/collectedHeap.hpp&quot;
  29 #include &quot;logging/log.hpp&quot;
  30 #include &quot;logging/logStream.hpp&quot;
  31 #include &quot;memory/filemap.hpp&quot;
  32 #include &quot;memory/metaspace.hpp&quot;
  33 #include &quot;memory/metaspace/chunkManager.hpp&quot;
  34 #include &quot;memory/metaspace/metachunk.hpp&quot;
  35 #include &quot;memory/metaspace/metaspaceCommon.hpp&quot;
  36 #include &quot;memory/metaspace/printCLDMetaspaceInfoClosure.hpp&quot;
  37 #include &quot;memory/metaspace/spaceManager.hpp&quot;
  38 #include &quot;memory/metaspace/virtualSpaceList.hpp&quot;
  39 #include &quot;memory/metaspaceShared.hpp&quot;
  40 #include &quot;memory/metaspaceTracer.hpp&quot;
  41 #include &quot;memory/universe.hpp&quot;
<span class="line-added">  42 #include &quot;oops/compressedOops.hpp&quot;</span>
<span class="line-added">  43 #include &quot;runtime/atomic.hpp&quot;</span>
  44 #include &quot;runtime/init.hpp&quot;

  45 #include &quot;services/memTracker.hpp&quot;
  46 #include &quot;utilities/copy.hpp&quot;
  47 #include &quot;utilities/debug.hpp&quot;
  48 #include &quot;utilities/formatBuffer.hpp&quot;
  49 #include &quot;utilities/globalDefinitions.hpp&quot;
<span class="line-added">  50 #include &quot;utilities/vmError.hpp&quot;</span>
  51 
  52 
  53 using namespace metaspace;
  54 
  55 MetaWord* last_allocated = 0;
  56 
  57 size_t Metaspace::_compressed_class_space_size;
  58 const MetaspaceTracer* Metaspace::_tracer = NULL;
  59 
  60 DEBUG_ONLY(bool Metaspace::_frozen = false;)
  61 
  62 static const char* space_type_name(Metaspace::MetaspaceType t) {
  63   const char* s = NULL;
  64   switch (t) {
  65     case Metaspace::StandardMetaspaceType: s = &quot;Standard&quot;; break;
  66     case Metaspace::BootMetaspaceType: s = &quot;Boot&quot;; break;
  67     case Metaspace::UnsafeAnonymousMetaspaceType: s = &quot;UnsafeAnonymous&quot;; break;
  68     case Metaspace::ReflectionMetaspaceType: s = &quot;Reflection&quot;; break;
  69     default: ShouldNotReachHere();
  70   }
  71   return s;
  72 }
  73 
  74 volatile size_t MetaspaceGC::_capacity_until_GC = 0;
  75 uint MetaspaceGC::_shrink_factor = 0;

  76 
  77 // BlockFreelist methods
  78 
  79 // VirtualSpaceNode methods
  80 
  81 // MetaspaceGC methods
  82 
  83 // VM_CollectForMetadataAllocation is the vm operation used to GC.
  84 // Within the VM operation after the GC the attempt to allocate the metadata
  85 // should succeed.  If the GC did not free enough space for the metaspace
  86 // allocation, the HWM is increased so that another virtualspace will be
  87 // allocated for the metadata.  With perm gen the increase in the perm
  88 // gen had bounds, MinMetaspaceExpansion and MaxMetaspaceExpansion.  The
  89 // metaspace policy uses those as the small and large steps for the HWM.
  90 //
  91 // After the GC the compute_new_size() for MetaspaceGC is called to
  92 // resize the capacity of the metaspaces.  The current implementation
  93 // is based on the flags MinMetaspaceFreeRatio and MaxMetaspaceFreeRatio used
  94 // to resize the Java heap by some GC&#39;s.  New flags can be implemented
  95 // if really needed.  MinMetaspaceFreeRatio is used to calculate how much
</pre>
<hr />
<pre>
 111 
 112   if (delta &lt;= min_delta) {
 113     delta = min_delta;
 114   } else if (delta &lt;= max_delta) {
 115     // Don&#39;t want to hit the high water mark on the next
 116     // allocation so make the delta greater than just enough
 117     // for this allocation.
 118     delta = max_delta;
 119   } else {
 120     // This allocation is large but the next ones are probably not
 121     // so increase by the minimum.
 122     delta = delta + min_delta;
 123   }
 124 
 125   assert_is_aligned(delta, Metaspace::commit_alignment());
 126 
 127   return delta;
 128 }
 129 
 130 size_t MetaspaceGC::capacity_until_GC() {
<span class="line-modified"> 131   size_t value = Atomic::load_acquire(&amp;_capacity_until_GC);</span>
 132   assert(value &gt;= MetaspaceSize, &quot;Not initialized properly?&quot;);
 133   return value;
 134 }
 135 
 136 // Try to increase the _capacity_until_GC limit counter by v bytes.
 137 // Returns true if it succeeded. It may fail if either another thread
 138 // concurrently increased the limit or the new limit would be larger
 139 // than MaxMetaspaceSize.
 140 // On success, optionally returns new and old metaspace capacity in
 141 // new_cap_until_GC and old_cap_until_GC respectively.
 142 // On error, optionally sets can_retry to indicate whether if there is
 143 // actually enough space remaining to satisfy the request.
 144 bool MetaspaceGC::inc_capacity_until_GC(size_t v, size_t* new_cap_until_GC, size_t* old_cap_until_GC, bool* can_retry) {
 145   assert_is_aligned(v, Metaspace::commit_alignment());
 146 
 147   size_t old_capacity_until_GC = _capacity_until_GC;
 148   size_t new_value = old_capacity_until_GC + v;
 149 
 150   if (new_value &lt; old_capacity_until_GC) {
 151     // The addition wrapped around, set new_value to aligned max value.
 152     new_value = align_down(max_uintx, Metaspace::commit_alignment());
 153   }
 154 
 155   if (new_value &gt; MaxMetaspaceSize) {
 156     if (can_retry != NULL) {
 157       *can_retry = false;
 158     }
 159     return false;
 160   }
 161 
 162   if (can_retry != NULL) {
 163     *can_retry = true;
 164   }
<span class="line-modified"> 165   size_t prev_value = Atomic::cmpxchg(&amp;_capacity_until_GC, old_capacity_until_GC, new_value);</span>
 166 
 167   if (old_capacity_until_GC != prev_value) {
 168     return false;
 169   }
 170 
 171   if (new_cap_until_GC != NULL) {
 172     *new_cap_until_GC = new_value;
 173   }
 174   if (old_cap_until_GC != NULL) {
 175     *old_cap_until_GC = old_capacity_until_GC;
 176   }
 177   return true;
 178 }
 179 
 180 size_t MetaspaceGC::dec_capacity_until_GC(size_t v) {
 181   assert_is_aligned(v, Metaspace::commit_alignment());
 182 
<span class="line-modified"> 183   return Atomic::sub(&amp;_capacity_until_GC, v);</span>
 184 }
 185 
 186 void MetaspaceGC::initialize() {
 187   // Set the high-water mark to MaxMetapaceSize during VM initializaton since
 188   // we can&#39;t do a GC during initialization.
 189   _capacity_until_GC = MaxMetaspaceSize;
 190 }
 191 
 192 void MetaspaceGC::post_initialize() {
 193   // Reset the high-water mark once the VM initialization is done.
 194   _capacity_until_GC = MAX2(MetaspaceUtils::committed_bytes(), MetaspaceSize);
 195 }
 196 
 197 bool MetaspaceGC::can_expand(size_t word_size, bool is_class) {
 198   // Check if the compressed class space is full.
 199   if (is_class &amp;&amp; Metaspace::using_class_space()) {
 200     size_t class_committed = MetaspaceUtils::committed_bytes(Metaspace::ClassType);
 201     if (class_committed + word_size * BytesPerWord &gt; CompressedClassSpaceSize) {
 202       log_trace(gc, metaspace, freelist)(&quot;Cannot expand %s metaspace by &quot; SIZE_FORMAT &quot; words (CompressedClassSpaceSize = &quot; SIZE_FORMAT &quot; words)&quot;,
 203                 (is_class ? &quot;class&quot; : &quot;non-class&quot;), word_size, CompressedClassSpaceSize / sizeof(MetaWord));
</pre>
<hr />
<pre>
 377 
 378 size_t MetaspaceUtils::free_in_vs_bytes() {
 379   return free_in_vs_bytes(Metaspace::ClassType) + free_in_vs_bytes(Metaspace::NonClassType);
 380 }
 381 
 382 static void inc_stat_nonatomically(size_t* pstat, size_t words) {
 383   assert_lock_strong(MetaspaceExpand_lock);
 384   (*pstat) += words;
 385 }
 386 
 387 static void dec_stat_nonatomically(size_t* pstat, size_t words) {
 388   assert_lock_strong(MetaspaceExpand_lock);
 389   const size_t size_now = *pstat;
 390   assert(size_now &gt;= words, &quot;About to decrement counter below zero &quot;
 391          &quot;(current value: &quot; SIZE_FORMAT &quot;, decrement value: &quot; SIZE_FORMAT &quot;.&quot;,
 392          size_now, words);
 393   *pstat = size_now - words;
 394 }
 395 
 396 static void inc_stat_atomically(volatile size_t* pstat, size_t words) {
<span class="line-modified"> 397   Atomic::add(pstat, words);</span>
 398 }
 399 
 400 static void dec_stat_atomically(volatile size_t* pstat, size_t words) {
 401   const size_t size_now = *pstat;
 402   assert(size_now &gt;= words, &quot;About to decrement counter below zero &quot;
 403          &quot;(current value: &quot; SIZE_FORMAT &quot;, decrement value: &quot; SIZE_FORMAT &quot;.&quot;,
 404          size_now, words);
<span class="line-modified"> 405   Atomic::sub(pstat, words);</span>
 406 }
 407 
 408 void MetaspaceUtils::dec_capacity(Metaspace::MetadataType mdtype, size_t words) {
 409   dec_stat_nonatomically(&amp;_capacity_words[mdtype], words);
 410 }
 411 void MetaspaceUtils::inc_capacity(Metaspace::MetadataType mdtype, size_t words) {
 412   inc_stat_nonatomically(&amp;_capacity_words[mdtype], words);
 413 }
 414 void MetaspaceUtils::dec_used(Metaspace::MetadataType mdtype, size_t words) {
 415   dec_stat_atomically(&amp;_used_words[mdtype], words);
 416 }
 417 void MetaspaceUtils::inc_used(Metaspace::MetadataType mdtype, size_t words) {
 418   inc_stat_atomically(&amp;_used_words[mdtype], words);
 419 }
 420 void MetaspaceUtils::dec_overhead(Metaspace::MetadataType mdtype, size_t words) {
 421   dec_stat_nonatomically(&amp;_overhead_words[mdtype], words);
 422 }
 423 void MetaspaceUtils::inc_overhead(Metaspace::MetadataType mdtype, size_t words) {
 424   inc_stat_nonatomically(&amp;_overhead_words[mdtype], words);
 425 }
</pre>
<hr />
<pre>
 453          free_chunks_total_words(Metaspace::NonClassType);
 454 }
 455 
 456 size_t MetaspaceUtils::free_chunks_total_bytes() {
 457   return free_chunks_total_words() * BytesPerWord;
 458 }
 459 
 460 bool MetaspaceUtils::has_chunk_free_list(Metaspace::MetadataType mdtype) {
 461   return Metaspace::get_chunk_manager(mdtype) != NULL;
 462 }
 463 
 464 MetaspaceChunkFreeListSummary MetaspaceUtils::chunk_free_list_summary(Metaspace::MetadataType mdtype) {
 465   if (!has_chunk_free_list(mdtype)) {
 466     return MetaspaceChunkFreeListSummary();
 467   }
 468 
 469   const ChunkManager* cm = Metaspace::get_chunk_manager(mdtype);
 470   return cm-&gt;chunk_free_list_summary();
 471 }
 472 
<span class="line-modified"> 473 void MetaspaceUtils::print_metaspace_change(const metaspace::MetaspaceSizesSnapshot&amp; pre_meta_values) {</span>
<span class="line-modified"> 474   const metaspace::MetaspaceSizesSnapshot meta_values;</span>
<span class="line-modified"> 475 </span>
<span class="line-added"> 476   if (Metaspace::using_class_space()) {</span>
<span class="line-added"> 477     log_info(gc, metaspace)(HEAP_CHANGE_FORMAT&quot; &quot;</span>
<span class="line-added"> 478                             HEAP_CHANGE_FORMAT&quot; &quot;</span>
<span class="line-added"> 479                             HEAP_CHANGE_FORMAT,</span>
<span class="line-added"> 480                             HEAP_CHANGE_FORMAT_ARGS(&quot;Metaspace&quot;,</span>
<span class="line-added"> 481                                                     pre_meta_values.used(),</span>
<span class="line-added"> 482                                                     pre_meta_values.committed(),</span>
<span class="line-added"> 483                                                     meta_values.used(),</span>
<span class="line-added"> 484                                                     meta_values.committed()),</span>
<span class="line-added"> 485                             HEAP_CHANGE_FORMAT_ARGS(&quot;NonClass&quot;,</span>
<span class="line-added"> 486                                                     pre_meta_values.non_class_used(),</span>
<span class="line-added"> 487                                                     pre_meta_values.non_class_committed(),</span>
<span class="line-added"> 488                                                     meta_values.non_class_used(),</span>
<span class="line-added"> 489                                                     meta_values.non_class_committed()),</span>
<span class="line-added"> 490                             HEAP_CHANGE_FORMAT_ARGS(&quot;Class&quot;,</span>
<span class="line-added"> 491                                                     pre_meta_values.class_used(),</span>
<span class="line-added"> 492                                                     pre_meta_values.class_committed(),</span>
<span class="line-added"> 493                                                     meta_values.class_used(),</span>
<span class="line-added"> 494                                                     meta_values.class_committed()));</span>
<span class="line-added"> 495   } else {</span>
<span class="line-added"> 496     log_info(gc, metaspace)(HEAP_CHANGE_FORMAT,</span>
<span class="line-added"> 497                             HEAP_CHANGE_FORMAT_ARGS(&quot;Metaspace&quot;,</span>
<span class="line-added"> 498                                                     pre_meta_values.used(),</span>
<span class="line-added"> 499                                                     pre_meta_values.committed(),</span>
<span class="line-added"> 500                                                     meta_values.used(),</span>
<span class="line-added"> 501                                                     meta_values.committed()));</span>
<span class="line-added"> 502   }</span>
 503 }
 504 
 505 void MetaspaceUtils::print_on(outputStream* out) {
 506   Metaspace::MetadataType nct = Metaspace::NonClassType;
 507 
 508   out-&gt;print_cr(&quot; Metaspace       &quot;
 509                 &quot;used &quot;      SIZE_FORMAT &quot;K, &quot;
 510                 &quot;capacity &quot;  SIZE_FORMAT &quot;K, &quot;
 511                 &quot;committed &quot; SIZE_FORMAT &quot;K, &quot;
 512                 &quot;reserved &quot;  SIZE_FORMAT &quot;K&quot;,
 513                 used_bytes()/K,
 514                 capacity_bytes()/K,
 515                 committed_bytes()/K,
 516                 reserved_bytes()/K);
 517 
 518   if (Metaspace::using_class_space()) {
 519     Metaspace::MetadataType ct = Metaspace::ClassType;
 520     out-&gt;print_cr(&quot;  class space    &quot;
 521                   &quot;used &quot;      SIZE_FORMAT &quot;K, &quot;
 522                   &quot;capacity &quot;  SIZE_FORMAT &quot;K, &quot;
</pre>
<hr />
<pre>
 545     if (Metaspace::using_class_space()) {
 546       const size_t reserved_class_words = reserved_bytes(Metaspace::ClassType) / sizeof(MetaWord);
 547       const size_t committed_class_words = committed_bytes(Metaspace::ClassType) / sizeof(MetaWord);
 548       out-&gt;print(&quot;      Class space:  &quot;);
 549       print_scaled_words(out, reserved_class_words, scale, 7);
 550       out-&gt;print(&quot; reserved, &quot;);
 551       print_scaled_words_and_percentage(out, committed_class_words, reserved_class_words, scale, 7);
 552       out-&gt;print_cr(&quot; committed &quot;);
 553 
 554       const size_t reserved_words = reserved_nonclass_words + reserved_class_words;
 555       const size_t committed_words = committed_nonclass_words + committed_class_words;
 556       out-&gt;print(&quot;             Both:  &quot;);
 557       print_scaled_words(out, reserved_words, scale, 7);
 558       out-&gt;print(&quot; reserved, &quot;);
 559       print_scaled_words_and_percentage(out, committed_words, reserved_words, scale, 7);
 560       out-&gt;print_cr(&quot; committed &quot;);
 561     }
 562   }
 563 }
 564 
<span class="line-added"> 565 static void print_basic_switches(outputStream* out, size_t scale) {</span>
<span class="line-added"> 566   out-&gt;print(&quot;MaxMetaspaceSize: &quot;);</span>
<span class="line-added"> 567   if (MaxMetaspaceSize &gt;= (max_uintx) - (2 * os::vm_page_size())) {</span>
<span class="line-added"> 568     // aka &quot;very big&quot;. Default is max_uintx, but due to rounding in arg parsing the real</span>
<span class="line-added"> 569     // value is smaller.</span>
<span class="line-added"> 570     out-&gt;print(&quot;unlimited&quot;);</span>
<span class="line-added"> 571   } else {</span>
<span class="line-added"> 572     print_human_readable_size(out, MaxMetaspaceSize, scale);</span>
<span class="line-added"> 573   }</span>
<span class="line-added"> 574   out-&gt;cr();</span>
<span class="line-added"> 575   if (Metaspace::using_class_space()) {</span>
<span class="line-added"> 576     out-&gt;print(&quot;CompressedClassSpaceSize: &quot;);</span>
<span class="line-added"> 577     print_human_readable_size(out, CompressedClassSpaceSize, scale);</span>
<span class="line-added"> 578   }</span>
<span class="line-added"> 579   out-&gt;cr();</span>
<span class="line-added"> 580 }</span>
<span class="line-added"> 581 </span>
 582 // This will print out a basic metaspace usage report but
 583 // unlike print_report() is guaranteed not to lock or to walk the CLDG.
 584 void MetaspaceUtils::print_basic_report(outputStream* out, size_t scale) {
 585 
<span class="line-added"> 586   if (!Metaspace::initialized()) {</span>
<span class="line-added"> 587     out-&gt;print_cr(&quot;Metaspace not yet initialized.&quot;);</span>
<span class="line-added"> 588     return;</span>
<span class="line-added"> 589   }</span>
<span class="line-added"> 590 </span>
 591   out-&gt;cr();
 592   out-&gt;print_cr(&quot;Usage:&quot;);
 593 
 594   if (Metaspace::using_class_space()) {
 595     out-&gt;print(&quot;  Non-class:  &quot;);
 596   }
 597 
 598   // In its most basic form, we do not require walking the CLDG. Instead, just print the running totals from
 599   // MetaspaceUtils.
 600   const size_t cap_nc = MetaspaceUtils::capacity_words(Metaspace::NonClassType);
 601   const size_t overhead_nc = MetaspaceUtils::overhead_words(Metaspace::NonClassType);
 602   const size_t used_nc = MetaspaceUtils::used_words(Metaspace::NonClassType);
 603   const size_t free_and_waste_nc = cap_nc - overhead_nc - used_nc;
 604 
 605   print_scaled_words(out, cap_nc, scale, 5);
 606   out-&gt;print(&quot; capacity, &quot;);
 607   print_scaled_words_and_percentage(out, used_nc, cap_nc, scale, 5);
 608   out-&gt;print(&quot; used, &quot;);
 609   print_scaled_words_and_percentage(out, free_and_waste_nc, cap_nc, scale, 5);
 610   out-&gt;print(&quot; free+waste, &quot;);
</pre>
<hr />
<pre>
 647 
 648   print_vs(out, scale);
 649 
 650   out-&gt;cr();
 651   out-&gt;print_cr(&quot;Chunk freelists:&quot;);
 652 
 653   if (Metaspace::using_class_space()) {
 654     out-&gt;print(&quot;   Non-Class:  &quot;);
 655   }
 656   print_human_readable_size(out, Metaspace::chunk_manager_metadata()-&gt;free_chunks_total_bytes(), scale);
 657   out-&gt;cr();
 658   if (Metaspace::using_class_space()) {
 659     out-&gt;print(&quot;       Class:  &quot;);
 660     print_human_readable_size(out, Metaspace::chunk_manager_class()-&gt;free_chunks_total_bytes(), scale);
 661     out-&gt;cr();
 662     out-&gt;print(&quot;        Both:  &quot;);
 663     print_human_readable_size(out, Metaspace::chunk_manager_class()-&gt;free_chunks_total_bytes() +
 664                               Metaspace::chunk_manager_metadata()-&gt;free_chunks_total_bytes(), scale);
 665     out-&gt;cr();
 666   }
<span class="line-added"> 667 </span>
<span class="line-added"> 668   out-&gt;cr();</span>
<span class="line-added"> 669 </span>
<span class="line-added"> 670   // Print basic settings</span>
<span class="line-added"> 671   print_basic_switches(out, scale);</span>
<span class="line-added"> 672 </span>
 673   out-&gt;cr();
 674 
 675 }
 676 
 677 void MetaspaceUtils::print_report(outputStream* out, size_t scale, int flags) {
 678 
<span class="line-added"> 679   if (!Metaspace::initialized()) {</span>
<span class="line-added"> 680     out-&gt;print_cr(&quot;Metaspace not yet initialized.&quot;);</span>
<span class="line-added"> 681     return;</span>
<span class="line-added"> 682   }</span>
<span class="line-added"> 683 </span>
 684   const bool print_loaders = (flags &amp; rf_show_loaders) &gt; 0;
 685   const bool print_classes = (flags &amp; rf_show_classes) &gt; 0;
 686   const bool print_by_chunktype = (flags &amp; rf_break_down_by_chunktype) &gt; 0;
 687   const bool print_by_spacetype = (flags &amp; rf_break_down_by_spacetype) &gt; 0;
 688 
 689   // Some report options require walking the class loader data graph.
 690   PrintCLDMetaspaceInfoClosure cl(out, scale, print_loaders, print_classes, print_by_chunktype);
 691   if (print_loaders) {
 692     out-&gt;cr();
 693     out-&gt;print_cr(&quot;Usage per loader:&quot;);
 694     out-&gt;cr();
 695   }
 696 
 697   ClassLoaderDataGraph::loaded_cld_do(&amp;cl); // collect data and optionally print
 698 
 699   // Print totals, broken up by space type.
 700   if (print_by_spacetype) {
 701     out-&gt;cr();
 702     out-&gt;print_cr(&quot;Usage per space type:&quot;);
 703     out-&gt;cr();
 704     for (int space_type = (int)Metaspace::ZeroMetaspaceType;
 705          space_type &lt; (int)Metaspace::MetaspaceTypeCount; space_type ++)
 706     {
<span class="line-modified"> 707       uintx num_loaders = cl._num_loaders_by_spacetype[space_type];</span>
<span class="line-modified"> 708       uintx num_classes = cl._num_classes_by_spacetype[space_type];</span>
<span class="line-added"> 709       out-&gt;print(&quot;%s - &quot; UINTX_FORMAT &quot; %s&quot;,</span>
 710         space_type_name((Metaspace::MetaspaceType)space_type),
<span class="line-modified"> 711         num_loaders, loaders_plural(num_loaders));</span>
<span class="line-modified"> 712       if (num_classes &gt; 0) {</span>
<span class="line-added"> 713         out-&gt;print(&quot;, &quot;);</span>
<span class="line-added"> 714         print_number_of_classes(out, num_classes, cl._num_classes_shared_by_spacetype[space_type]);</span>
<span class="line-added"> 715         out-&gt;print(&quot;:&quot;);</span>
 716         cl._stats_by_spacetype[space_type].print_on(out, scale, print_by_chunktype);
<span class="line-added"> 717       } else {</span>
<span class="line-added"> 718         out-&gt;print(&quot;.&quot;);</span>
<span class="line-added"> 719         out-&gt;cr();</span>
 720       }
 721       out-&gt;cr();
 722     }
 723   }
 724 
 725   // Print totals for in-use data:
 726   out-&gt;cr();
<span class="line-modified"> 727   {</span>
<span class="line-modified"> 728     uintx num_loaders = cl._num_loaders;</span>
<span class="line-modified"> 729     out-&gt;print(&quot;Total Usage - &quot; UINTX_FORMAT &quot; %s, &quot;,</span>
<span class="line-modified"> 730       num_loaders, loaders_plural(num_loaders));</span>
<span class="line-added"> 731     print_number_of_classes(out, cl._num_classes, cl._num_classes_shared);</span>
<span class="line-added"> 732     out-&gt;print(&quot;:&quot;);</span>
<span class="line-added"> 733     cl._stats_total.print_on(out, scale, print_by_chunktype);</span>
<span class="line-added"> 734     out-&gt;cr();</span>
<span class="line-added"> 735   }</span>
 736 
 737   // -- Print Virtual space.
 738   out-&gt;cr();
 739   out-&gt;print_cr(&quot;Virtual space:&quot;);
 740 
 741   print_vs(out, scale);
 742 
 743   // -- Print VirtualSpaceList details.
 744   if ((flags &amp; rf_show_vslist) &gt; 0) {
 745     out-&gt;cr();
 746     out-&gt;print_cr(&quot;Virtual space list%s:&quot;, Metaspace::using_class_space() ? &quot;s&quot; : &quot;&quot;);
 747 
 748     if (Metaspace::using_class_space()) {
 749       out-&gt;print_cr(&quot;   Non-Class:&quot;);
 750     }
 751     Metaspace::space_list()-&gt;print_on(out, scale);
 752     if (Metaspace::using_class_space()) {
 753       out-&gt;print_cr(&quot;       Class:&quot;);
 754       Metaspace::class_space_list()-&gt;print_on(out, scale);
 755     }
</pre>
<hr />
<pre>
 861   out-&gt;print_cr(&quot;Number of space births: &quot; UINTX_FORMAT &quot;.&quot;, g_internal_statistics.num_metaspace_births);
 862   out-&gt;print_cr(&quot;Number of space deaths: &quot; UINTX_FORMAT &quot;.&quot;, g_internal_statistics.num_metaspace_deaths);
 863   out-&gt;print_cr(&quot;Number of virtual space node births: &quot; UINTX_FORMAT &quot;.&quot;, g_internal_statistics.num_vsnodes_created);
 864   out-&gt;print_cr(&quot;Number of virtual space node deaths: &quot; UINTX_FORMAT &quot;.&quot;, g_internal_statistics.num_vsnodes_purged);
 865   out-&gt;print_cr(&quot;Number of times virtual space nodes were expanded: &quot; UINTX_FORMAT &quot;.&quot;, g_internal_statistics.num_committed_space_expanded);
 866   out-&gt;print_cr(&quot;Number of deallocations: &quot; UINTX_FORMAT &quot; (&quot; UINTX_FORMAT &quot; external).&quot;, g_internal_statistics.num_deallocs, g_internal_statistics.num_external_deallocs);
 867   out-&gt;print_cr(&quot;Allocations from deallocated blocks: &quot; UINTX_FORMAT &quot;.&quot;, g_internal_statistics.num_allocs_from_deallocated_blocks);
 868   out-&gt;print_cr(&quot;Number of chunks added to freelist: &quot; UINTX_FORMAT &quot;.&quot;,
 869                 g_internal_statistics.num_chunks_added_to_freelist);
 870   out-&gt;print_cr(&quot;Number of chunks removed from freelist: &quot; UINTX_FORMAT &quot;.&quot;,
 871                 g_internal_statistics.num_chunks_removed_from_freelist);
 872   out-&gt;print_cr(&quot;Number of chunk merges: &quot; UINTX_FORMAT &quot;, split-ups: &quot; UINTX_FORMAT &quot;.&quot;,
 873                 g_internal_statistics.num_chunk_merges, g_internal_statistics.num_chunk_splits);
 874 
 875   out-&gt;cr();
 876 #endif
 877 
 878   // Print some interesting settings
 879   out-&gt;cr();
 880   out-&gt;cr();
<span class="line-modified"> 881   print_basic_switches(out, scale);</span>
<span class="line-modified"> 882 </span>
 883   out-&gt;cr();
 884   out-&gt;print(&quot;InitialBootClassLoaderMetaspaceSize: &quot;);
 885   print_human_readable_size(out, InitialBootClassLoaderMetaspaceSize, scale);








 886 
 887   out-&gt;cr();
 888   out-&gt;cr();
 889 
 890 } // MetaspaceUtils::print_report()
 891 
 892 // Prints an ASCII representation of the given space.
 893 void MetaspaceUtils::print_metaspace_map(outputStream* out, Metaspace::MetadataType mdtype) {
<span class="line-modified"> 894   MutexLocker cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
 895   const bool for_class = mdtype == Metaspace::ClassType ? true : false;
 896   VirtualSpaceList* const vsl = for_class ? Metaspace::class_space_list() : Metaspace::space_list();
 897   if (vsl != NULL) {
 898     if (for_class) {
 899       if (!Metaspace::using_class_space()) {
 900         out-&gt;print_cr(&quot;No Class Space.&quot;);
 901         return;
 902       }
 903       out-&gt;print_raw(&quot;---- Metaspace Map (Class Space) ----&quot;);
 904     } else {
 905       out-&gt;print_raw(&quot;---- Metaspace Map (Non-Class Space) ----&quot;);
 906     }
 907     // Print legend:
 908     out-&gt;cr();
 909     out-&gt;print_cr(&quot;Chunk Types (uppercase chunks are in use): x-specialized, s-small, m-medium, h-humongous.&quot;);
 910     out-&gt;cr();
 911     VirtualSpaceList* const vsl = for_class ? Metaspace::class_space_list() : Metaspace::space_list();
 912     vsl-&gt;print_map(out);
 913     out-&gt;cr();
 914   }
</pre>
<hr />
<pre>
 937   bool mismatch = false;
 938   for (int i = 0; i &lt; Metaspace::MetadataTypeCount; i ++) {
 939     Metaspace::MetadataType mdtype = (Metaspace::MetadataType)i;
 940     UsedChunksStatistics chunk_stat = total_stat.sm_stats(mdtype).totals();
 941     if (capacity_words(mdtype) != chunk_stat.cap() ||
 942         used_words(mdtype) != chunk_stat.used() ||
 943         overhead_words(mdtype) != chunk_stat.overhead()) {
 944       mismatch = true;
 945       tty-&gt;print_cr(&quot;MetaspaceUtils::verify_metrics: counter mismatch for mdtype=%u:&quot;, mdtype);
 946       tty-&gt;print_cr(&quot;Expected cap &quot; SIZE_FORMAT &quot;, used &quot; SIZE_FORMAT &quot;, overhead &quot; SIZE_FORMAT &quot;.&quot;,
 947                     capacity_words(mdtype), used_words(mdtype), overhead_words(mdtype));
 948       tty-&gt;print_cr(&quot;Got cap &quot; SIZE_FORMAT &quot;, used &quot; SIZE_FORMAT &quot;, overhead &quot; SIZE_FORMAT &quot;.&quot;,
 949                     chunk_stat.cap(), chunk_stat.used(), chunk_stat.overhead());
 950       tty-&gt;flush();
 951     }
 952   }
 953   assert(mismatch == false, &quot;MetaspaceUtils::verify_metrics: counter mismatch.&quot;);
 954 #endif
 955 }
 956 

























 957 // Metaspace methods
 958 
 959 size_t Metaspace::_first_chunk_word_size = 0;
 960 size_t Metaspace::_first_class_chunk_word_size = 0;
 961 
 962 size_t Metaspace::_commit_alignment = 0;
 963 size_t Metaspace::_reserve_alignment = 0;
 964 
 965 VirtualSpaceList* Metaspace::_space_list = NULL;
 966 VirtualSpaceList* Metaspace::_class_space_list = NULL;
 967 
 968 ChunkManager* Metaspace::_chunk_manager_metadata = NULL;
 969 ChunkManager* Metaspace::_chunk_manager_class = NULL;
 970 
<span class="line-added"> 971 bool Metaspace::_initialized = false;</span>
<span class="line-added"> 972 </span>
 973 #define VIRTUALSPACEMULTIPLIER 2
 974 
 975 #ifdef _LP64
 976 static const uint64_t UnscaledClassSpaceMax = (uint64_t(max_juint) + 1);
 977 
<span class="line-modified"> 978 void Metaspace::set_narrow_klass_base_and_shift(ReservedSpace metaspace_rs, address cds_base) {</span>
 979   assert(!DumpSharedSpaces, &quot;narrow_klass is set by MetaspaceShared class.&quot;);
 980   // Figure out the narrow_klass_base and the narrow_klass_shift.  The
 981   // narrow_klass_base is the lower of the metaspace base and the cds base
 982   // (if cds is enabled).  The narrow_klass_shift depends on the distance
 983   // between the lower base and higher address.
<span class="line-modified"> 984   address lower_base = (address)metaspace_rs.base();</span>
<span class="line-modified"> 985   address higher_address = (address)metaspace_rs.end();</span>
<span class="line-modified"> 986   if (cds_base != NULL) {</span>
<span class="line-modified"> 987     assert(UseSharedSpaces, &quot;must be&quot;);</span>
<span class="line-modified"> 988     lower_base = MIN2(lower_base, cds_base);</span>
<span class="line-modified"> 989   } else {</span>







 990     uint64_t klass_encoding_max = UnscaledClassSpaceMax &lt;&lt; LogKlassAlignmentInBytes;
 991     // If compressed class space fits in lower 32G, we don&#39;t need a base.
 992     if (higher_address &lt;= (address)klass_encoding_max) {
 993       lower_base = 0; // Effectively lower base is zero.
 994     }
 995   }
 996 
<span class="line-modified"> 997   CompressedKlassPointers::set_base(lower_base);</span>
 998 
 999   // CDS uses LogKlassAlignmentInBytes for narrow_klass_shift. See
1000   // MetaspaceShared::initialize_dumptime_shared_and_meta_spaces() for
1001   // how dump time narrow_klass_shift is set. Although, CDS can work
1002   // with zero-shift mode also, to be consistent with AOT it uses
1003   // LogKlassAlignmentInBytes for klass shift so archived java heap objects
1004   // can be used at same time as AOT code.
1005   if (!UseSharedSpaces
1006       &amp;&amp; (uint64_t)(higher_address - lower_base) &lt;= UnscaledClassSpaceMax) {
<span class="line-modified">1007     CompressedKlassPointers::set_shift(0);</span>
1008   } else {
<span class="line-modified">1009     CompressedKlassPointers::set_shift(LogKlassAlignmentInBytes);</span>
1010   }
1011   AOTLoader::set_narrow_klass_shift();
1012 }
1013 













1014 // Try to allocate the metaspace at the requested addr.
<span class="line-modified">1015 void Metaspace::allocate_metaspace_compressed_klass_ptrs(ReservedSpace metaspace_rs, char* requested_addr, address cds_base) {</span>
1016   assert(!DumpSharedSpaces, &quot;compress klass space is allocated by MetaspaceShared class.&quot;);
1017   assert(using_class_space(), &quot;called improperly&quot;);
1018   assert(UseCompressedClassPointers, &quot;Only use with CompressedKlassPtrs&quot;);
1019   assert(compressed_class_space_size() &lt; KlassEncodingMetaspaceMax,
1020          &quot;Metaspace size is too big&quot;);
1021   assert_is_aligned(requested_addr, _reserve_alignment);
1022   assert_is_aligned(cds_base, _reserve_alignment);
1023   assert_is_aligned(compressed_class_space_size(), _reserve_alignment);
1024 
<span class="line-modified">1025   if (metaspace_rs.is_reserved()) {</span>
<span class="line-modified">1026     // CDS should have already reserved the space.</span>
<span class="line-modified">1027     assert(requested_addr == NULL, &quot;not used&quot;);</span>
<span class="line-modified">1028     assert(cds_base != NULL, &quot;CDS should have already reserved the memory space&quot;);</span>
<span class="line-modified">1029   } else {</span>
<span class="line-modified">1030     assert(cds_base == NULL, &quot;must be&quot;);</span>
<span class="line-modified">1031     metaspace_rs = reserve_space(compressed_class_space_size(),</span>
<span class="line-modified">1032                                  _reserve_alignment, requested_addr,</span>
<span class="line-modified">1033                                  false /* use_requested_addr */);</span>














































1034   }
1035 


1036   if (!metaspace_rs.is_reserved()) {
<span class="line-modified">1037     assert(cds_base == NULL, &quot;CDS should have already reserved the memory space&quot;);</span>















1038     // If no successful allocation then try to allocate the space anywhere.  If
1039     // that fails then OOM doom.  At this point we cannot try allocating the
1040     // metaspace as if UseCompressedClassPointers is off because too much
1041     // initialization has happened that depends on UseCompressedClassPointers.
1042     // So, UseCompressedClassPointers cannot be turned off at this point.
<span class="line-added">1043     metaspace_rs = reserve_space(compressed_class_space_size(),</span>
<span class="line-added">1044                                  _reserve_alignment, NULL, false);</span>
1045     if (!metaspace_rs.is_reserved()) {
<span class="line-modified">1046       vm_exit_during_initialization(err_msg(&quot;Could not allocate metaspace: &quot; SIZE_FORMAT &quot; bytes&quot;,</span>
<span class="line-modified">1047                                             compressed_class_space_size()));</span>




1048     }
1049   }
1050 
<span class="line-modified">1051   if (cds_base == NULL) {</span>
<span class="line-modified">1052     // If we got here then the metaspace got allocated.</span>
<span class="line-modified">1053     MemTracker::record_virtual_memory_type((address)metaspace_rs.base(), mtClass);</span>





1054   }
<span class="line-modified">1055 </span>
<span class="line-modified">1056   set_narrow_klass_base_and_shift(metaspace_rs, cds_base);</span>

1057 
1058   initialize_class_space(metaspace_rs);
1059 
1060   LogTarget(Trace, gc, metaspace) lt;
1061   if (lt.is_enabled()) {
1062     ResourceMark rm;
1063     LogStream ls(lt);
1064     print_compressed_class_space(&amp;ls, requested_addr);
1065   }
1066 }
1067 
1068 void Metaspace::print_compressed_class_space(outputStream* st, const char* requested_addr) {
1069   st-&gt;print_cr(&quot;Narrow klass base: &quot; PTR_FORMAT &quot;, Narrow klass shift: %d&quot;,
<span class="line-modified">1070                p2i(CompressedKlassPointers::base()), CompressedKlassPointers::shift());</span>
1071   if (_class_space_list != NULL) {
1072     address base = (address)_class_space_list-&gt;current_virtual_space()-&gt;bottom();
1073     st-&gt;print(&quot;Compressed class space size: &quot; SIZE_FORMAT &quot; Address: &quot; PTR_FORMAT,
1074                  compressed_class_space_size(), p2i(base));
1075     if (requested_addr != 0) {
1076       st-&gt;print(&quot; Req Addr: &quot; PTR_FORMAT, p2i(requested_addr));
1077     }
1078     st-&gt;cr();
1079   }
1080 }
1081 
1082 // For UseCompressedClassPointers the class space is reserved above the top of
1083 // the Java heap.  The argument passed in is at the base of the compressed space.
1084 void Metaspace::initialize_class_space(ReservedSpace rs) {
1085   // The reserved space size may be bigger because of alignment, esp with UseLargePages
1086   assert(rs.size() &gt;= CompressedClassSpaceSize,
1087          SIZE_FORMAT &quot; != &quot; SIZE_FORMAT, rs.size(), CompressedClassSpaceSize);
1088   assert(using_class_space(), &quot;Must be using class space&quot;);
1089   _class_space_list = new VirtualSpaceList(rs);
1090   _chunk_manager_class = new ChunkManager(true/*is_class*/);
1091 
1092   if (!_class_space_list-&gt;initialization_succeeded()) {
1093     vm_exit_during_initialization(&quot;Failed to setup compressed class space virtual space list.&quot;);
1094   }
1095 }
1096 
<span class="line-added">1097 #endif // _LP64</span>
<span class="line-added">1098 </span>
<span class="line-added">1099 #ifdef PREFERRED_METASPACE_ALIGNMENT</span>
<span class="line-added">1100 ReservedSpace Metaspace::reserve_preferred_space(size_t size, size_t alignment,</span>
<span class="line-added">1101                                                  bool large_pages, char *requested_addr,</span>
<span class="line-added">1102                                                  bool use_requested_addr) {</span>
<span class="line-added">1103   // Our compressed klass pointers may fit nicely into the lower 32 bits.</span>
<span class="line-added">1104   if (requested_addr != NULL &amp;&amp; (uint64_t)requested_addr + size &lt; 4*G) {</span>
<span class="line-added">1105     ReservedSpace rs(size, alignment, large_pages, requested_addr);</span>
<span class="line-added">1106     if (rs.is_reserved() || use_requested_addr) {</span>
<span class="line-added">1107       return rs;</span>
<span class="line-added">1108     }</span>
<span class="line-added">1109   }</span>
<span class="line-added">1110 </span>
<span class="line-added">1111   struct SearchParams { uintptr_t limit; size_t increment; };</span>
<span class="line-added">1112 </span>
<span class="line-added">1113   // AArch64: Try to align metaspace so that we can decode a compressed</span>
<span class="line-added">1114   // klass with a single MOVK instruction. We can do this iff the</span>
<span class="line-added">1115   // compressed class base is a multiple of 4G.</span>
<span class="line-added">1116   // Aix: Search for a place where we can find memory. If we need to load</span>
<span class="line-added">1117   // the base, 4G alignment is helpful, too.</span>
<span class="line-added">1118 </span>
<span class="line-added">1119   // Go faster above 32G as it is no longer possible to use a zero base.</span>
<span class="line-added">1120   // AArch64: Additionally, ensure the lower LogKlassAlignmentInBytes</span>
<span class="line-added">1121   // bits of the upper 32-bits of the address are zero so we can handle</span>
<span class="line-added">1122   // a shift when decoding.</span>
<span class="line-added">1123 </span>
<span class="line-added">1124   static const SearchParams search_params[] = {</span>
<span class="line-added">1125     // Limit    Increment</span>
<span class="line-added">1126     {  32*G,    AARCH64_ONLY(4*)G,                               },</span>
<span class="line-added">1127     {  1024*G,  (4 AARCH64_ONLY(&lt;&lt; LogKlassAlignmentInBytes))*G  },</span>
<span class="line-added">1128   };</span>
<span class="line-added">1129 </span>
<span class="line-added">1130   // Null requested_addr means allocate anywhere so ensure the search</span>
<span class="line-added">1131   // begins from a non-null address.</span>
<span class="line-added">1132   char *a = MAX2(requested_addr, (char *)search_params[0].increment);</span>
<span class="line-added">1133 </span>
<span class="line-added">1134   for (const SearchParams *p = search_params;</span>
<span class="line-added">1135        p &lt; search_params + ARRAY_SIZE(search_params);</span>
<span class="line-added">1136        ++p) {</span>
<span class="line-added">1137     a = align_up(a, p-&gt;increment);</span>
<span class="line-added">1138     if (use_requested_addr &amp;&amp; a != requested_addr)</span>
<span class="line-added">1139       return ReservedSpace();</span>
<span class="line-added">1140 </span>
<span class="line-added">1141     for (; a &lt; (char *)p-&gt;limit; a += p-&gt;increment) {</span>
<span class="line-added">1142       ReservedSpace rs(size, alignment, large_pages, a);</span>
<span class="line-added">1143       if (rs.is_reserved() || use_requested_addr) {</span>
<span class="line-added">1144         return rs;</span>
<span class="line-added">1145       }</span>
<span class="line-added">1146     }</span>
<span class="line-added">1147   }</span>
<span class="line-added">1148 </span>
<span class="line-added">1149   return ReservedSpace();</span>
<span class="line-added">1150 }</span>
<span class="line-added">1151 #endif // PREFERRED_METASPACE_ALIGNMENT</span>
<span class="line-added">1152 </span>
<span class="line-added">1153 // Try to reserve a region for the metaspace at the requested address. Some</span>
<span class="line-added">1154 // platforms have particular alignment requirements to allow efficient decode of</span>
<span class="line-added">1155 // compressed class pointers in which case requested_addr is treated as hint for</span>
<span class="line-added">1156 // where to start looking unless use_requested_addr is true.</span>
<span class="line-added">1157 ReservedSpace Metaspace::reserve_space(size_t size, size_t alignment,</span>
<span class="line-added">1158                                        char* requested_addr, bool use_requested_addr) {</span>
<span class="line-added">1159   bool large_pages = false; // Don&#39;t use large pages for the class space.</span>
<span class="line-added">1160   assert(is_aligned(requested_addr, alignment), &quot;must be&quot;);</span>
<span class="line-added">1161   assert(requested_addr != NULL || !use_requested_addr,</span>
<span class="line-added">1162          &quot;cannot set use_requested_addr with NULL address&quot;);</span>
<span class="line-added">1163 </span>
<span class="line-added">1164 #ifdef PREFERRED_METASPACE_ALIGNMENT</span>
<span class="line-added">1165   return reserve_preferred_space(size, alignment, large_pages,</span>
<span class="line-added">1166                                  requested_addr, use_requested_addr);</span>
<span class="line-added">1167 #else</span>
<span class="line-added">1168   return ReservedSpace(size, alignment, large_pages, requested_addr);</span>
1169 #endif
<span class="line-added">1170 }</span>
1171 
1172 void Metaspace::ergo_initialize() {
1173   if (DumpSharedSpaces) {
1174     // Using large pages when dumping the shared archive is currently not implemented.
<span class="line-modified">1175     FLAG_SET_ERGO(UseLargePagesInMetaspace, false);</span>
1176   }
1177 
1178   size_t page_size = os::vm_page_size();
1179   if (UseLargePages &amp;&amp; UseLargePagesInMetaspace) {
1180     page_size = os::large_page_size();
1181   }
1182 
1183   _commit_alignment  = page_size;
1184   _reserve_alignment = MAX2(page_size, (size_t)os::vm_allocation_granularity());
1185 
1186   // Do not use FLAG_SET_ERGO to update MaxMetaspaceSize, since this will
1187   // override if MaxMetaspaceSize was set on the command line or not.
1188   // This information is needed later to conform to the specification of the
1189   // java.lang.management.MemoryUsage API.
1190   //
1191   // Ideally, we would be able to set the default value of MaxMetaspaceSize in
1192   // globals.hpp to the aligned value, but this is not possible, since the
1193   // alignment depends on other flags being parsed.
1194   MaxMetaspaceSize = align_down_bounded(MaxMetaspaceSize, _reserve_alignment);
1195 
</pre>
<hr />
<pre>
1197     MetaspaceSize = MaxMetaspaceSize;
1198   }
1199 
1200   MetaspaceSize = align_down_bounded(MetaspaceSize, _commit_alignment);
1201 
1202   assert(MetaspaceSize &lt;= MaxMetaspaceSize, &quot;MetaspaceSize should be limited by MaxMetaspaceSize&quot;);
1203 
1204   MinMetaspaceExpansion = align_down_bounded(MinMetaspaceExpansion, _commit_alignment);
1205   MaxMetaspaceExpansion = align_down_bounded(MaxMetaspaceExpansion, _commit_alignment);
1206 
1207   CompressedClassSpaceSize = align_down_bounded(CompressedClassSpaceSize, _reserve_alignment);
1208 
1209   // Initial virtual space size will be calculated at global_initialize()
1210   size_t min_metaspace_sz =
1211       VIRTUALSPACEMULTIPLIER * InitialBootClassLoaderMetaspaceSize;
1212   if (UseCompressedClassPointers) {
1213     if ((min_metaspace_sz + CompressedClassSpaceSize) &gt;  MaxMetaspaceSize) {
1214       if (min_metaspace_sz &gt;= MaxMetaspaceSize) {
1215         vm_exit_during_initialization(&quot;MaxMetaspaceSize is too small.&quot;);
1216       } else {
<span class="line-modified">1217         FLAG_SET_ERGO(CompressedClassSpaceSize,</span>
1218                       MaxMetaspaceSize - min_metaspace_sz);
1219       }
1220     }
1221   } else if (min_metaspace_sz &gt;= MaxMetaspaceSize) {
<span class="line-modified">1222     FLAG_SET_ERGO(InitialBootClassLoaderMetaspaceSize,</span>
1223                   min_metaspace_sz);
1224   }
1225 
1226   set_compressed_class_space_size(CompressedClassSpaceSize);
1227 }
1228 
1229 void Metaspace::global_initialize() {
1230   MetaspaceGC::initialize();
1231 
<span class="line-added">1232   bool class_space_inited = false;</span>
1233 #if INCLUDE_CDS
1234   if (DumpSharedSpaces) {
1235     MetaspaceShared::initialize_dumptime_shared_and_meta_spaces();
<span class="line-added">1236     class_space_inited = true;</span>
1237   } else if (UseSharedSpaces) {
1238     // If any of the archived space fails to map, UseSharedSpaces
<span class="line-modified">1239     // is reset to false.</span>


1240     MetaspaceShared::initialize_runtime_shared_and_meta_spaces();
<span class="line-added">1241     class_space_inited = UseSharedSpaces;</span>
1242   }
1243 
<span class="line-modified">1244   if (DynamicDumpSharedSpaces &amp;&amp; !UseSharedSpaces) {</span>
<span class="line-added">1245     vm_exit_during_initialization(&quot;DynamicDumpSharedSpaces is unsupported when base CDS archive is not loaded&quot;, NULL);</span>
<span class="line-added">1246   }</span>
1247 #endif // INCLUDE_CDS
<span class="line-modified">1248 </span>
1249 #ifdef _LP64
<span class="line-modified">1250   if (using_class_space() &amp;&amp; !class_space_inited) {</span>
<span class="line-modified">1251     char* base = (char*)align_up(CompressedOops::end(), _reserve_alignment);</span>
<span class="line-modified">1252     ReservedSpace dummy;</span>
<span class="line-modified">1253     allocate_metaspace_compressed_klass_ptrs(dummy, base, 0);</span>

1254   }
<span class="line-added">1255 #endif</span>
1256 
1257   // Initialize these before initializing the VirtualSpaceList
1258   _first_chunk_word_size = InitialBootClassLoaderMetaspaceSize / BytesPerWord;
1259   _first_chunk_word_size = align_word_size_up(_first_chunk_word_size);
1260   // Make the first class chunk bigger than a medium chunk so it&#39;s not put
1261   // on the medium chunk list.   The next chunk will be small and progress
1262   // from there.  This size calculated by -version.
1263   _first_class_chunk_word_size = MIN2((size_t)MediumChunk*6,
1264                                      (CompressedClassSpaceSize/BytesPerWord)*2);
1265   _first_class_chunk_word_size = align_word_size_up(_first_class_chunk_word_size);
1266   // Arbitrarily set the initial virtual space to a multiple
1267   // of the boot class loader size.
1268   size_t word_size = VIRTUALSPACEMULTIPLIER * _first_chunk_word_size;
1269   word_size = align_up(word_size, Metaspace::reserve_alignment_words());
1270 
1271   // Initialize the list of virtual spaces.
1272   _space_list = new VirtualSpaceList(word_size);
1273   _chunk_manager_metadata = new ChunkManager(false/*metaspace*/);
1274 
1275   if (!_space_list-&gt;initialization_succeeded()) {
1276     vm_exit_during_initialization(&quot;Unable to setup metadata virtual space list.&quot;, NULL);
1277   }
1278 
1279   _tracer = new MetaspaceTracer();
<span class="line-added">1280 </span>
<span class="line-added">1281   _initialized = true;</span>
<span class="line-added">1282 </span>
1283 }
1284 
1285 void Metaspace::post_initialize() {
1286   MetaspaceGC::post_initialize();
1287 }
1288 
1289 void Metaspace::verify_global_initialization() {
1290   assert(space_list() != NULL, &quot;Metadata VirtualSpaceList has not been initialized&quot;);
1291   assert(chunk_manager_metadata() != NULL, &quot;Metadata ChunkManager has not been initialized&quot;);
1292 
1293   if (using_class_space()) {
1294     assert(class_space_list() != NULL, &quot;Class VirtualSpaceList has not been initialized&quot;);
1295     assert(chunk_manager_class() != NULL, &quot;Class ChunkManager has not been initialized&quot;);
1296   }
1297 }
1298 
1299 size_t Metaspace::align_word_size_up(size_t word_size) {
1300   size_t byte_size = word_size * wordSize;
1301   return ReservedSpace::allocation_align_size_up(byte_size) / wordSize;
1302 }
</pre>
<hr />
<pre>
1400   } else {
1401     THROW_OOP(Universe::out_of_memory_error_metaspace());
1402   }
1403 }
1404 
1405 const char* Metaspace::metadata_type_name(Metaspace::MetadataType mdtype) {
1406   switch (mdtype) {
1407     case Metaspace::ClassType: return &quot;Class&quot;;
1408     case Metaspace::NonClassType: return &quot;Metadata&quot;;
1409     default:
1410       assert(false, &quot;Got bad mdtype: %d&quot;, (int) mdtype);
1411       return NULL;
1412   }
1413 }
1414 
1415 void Metaspace::purge(MetadataType mdtype) {
1416   get_space_list(mdtype)-&gt;purge(get_chunk_manager(mdtype));
1417 }
1418 
1419 void Metaspace::purge() {
<span class="line-modified">1420   MutexLocker cl(MetaspaceExpand_lock,</span>
<span class="line-modified">1421                  Mutex::_no_safepoint_check_flag);</span>
1422   purge(NonClassType);
1423   if (using_class_space()) {
1424     purge(ClassType);
1425   }
1426 }
1427 
1428 bool Metaspace::contains(const void* ptr) {
1429   if (MetaspaceShared::is_in_shared_metaspace(ptr)) {
1430     return true;
1431   }
1432   return contains_non_shared(ptr);
1433 }
1434 
1435 bool Metaspace::contains_non_shared(const void* ptr) {
1436   if (using_class_space() &amp;&amp; get_space_list(ClassType)-&gt;contains(ptr)) {
1437      return true;
1438   }
1439 
1440   return get_space_list(NonClassType)-&gt;contains(ptr);
1441 }
</pre>
<hr />
<pre>
1478     chunk = Metaspace::get_space_list(mdtype)-&gt;get_new_chunk(chunk_word_size,
1479                                                   get_space_manager(mdtype)-&gt;medium_chunk_bunch());
1480   }
1481 
1482   return chunk;
1483 }
1484 
1485 void ClassLoaderMetaspace::initialize(Mutex* lock, Metaspace::MetaspaceType type) {
1486   Metaspace::verify_global_initialization();
1487 
1488   DEBUG_ONLY(Atomic::inc(&amp;g_internal_statistics.num_metaspace_births));
1489 
1490   // Allocate SpaceManager for metadata objects.
1491   _vsm = new SpaceManager(Metaspace::NonClassType, type, lock);
1492 
1493   if (Metaspace::using_class_space()) {
1494     // Allocate SpaceManager for classes.
1495     _class_vsm = new SpaceManager(Metaspace::ClassType, type, lock);
1496   }
1497 
<span class="line-modified">1498   MutexLocker cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
1499 
1500   // Allocate chunk for metadata objects
1501   initialize_first_chunk(type, Metaspace::NonClassType);
1502 
1503   // Allocate chunk for class metadata objects
1504   if (Metaspace::using_class_space()) {
1505     initialize_first_chunk(type, Metaspace::ClassType);
1506   }
1507 }
1508 
1509 MetaWord* ClassLoaderMetaspace::allocate(size_t word_size, Metaspace::MetadataType mdtype) {
1510   Metaspace::assert_not_frozen();
1511 
1512   DEBUG_ONLY(Atomic::inc(&amp;g_internal_statistics.num_allocs));
1513 
1514   // Don&#39;t use class_vsm() unless UseCompressedClassPointers is true.
1515   if (Metaspace::is_class_space_allocation(mdtype)) {
1516     return  class_vsm()-&gt;allocate(word_size);
1517   } else {
1518     return  vsm()-&gt;allocate(word_size);
</pre>
<hr />
<pre>
1547   return res;
1548 }
1549 
1550 size_t ClassLoaderMetaspace::allocated_blocks_bytes() const {
1551   return (vsm()-&gt;used_words() +
1552       (Metaspace::using_class_space() ? class_vsm()-&gt;used_words() : 0)) * BytesPerWord;
1553 }
1554 
1555 size_t ClassLoaderMetaspace::allocated_chunks_bytes() const {
1556   return (vsm()-&gt;capacity_words() +
1557       (Metaspace::using_class_space() ? class_vsm()-&gt;capacity_words() : 0)) * BytesPerWord;
1558 }
1559 
1560 void ClassLoaderMetaspace::deallocate(MetaWord* ptr, size_t word_size, bool is_class) {
1561   Metaspace::assert_not_frozen();
1562   assert(!SafepointSynchronize::is_at_safepoint()
1563          || Thread::current()-&gt;is_VM_thread(), &quot;should be the VM thread&quot;);
1564 
1565   DEBUG_ONLY(Atomic::inc(&amp;g_internal_statistics.num_external_deallocs));
1566 
<span class="line-modified">1567   MutexLocker ml(vsm()-&gt;lock(), Mutex::_no_safepoint_check_flag);</span>
1568 
1569   if (is_class &amp;&amp; Metaspace::using_class_space()) {
1570     class_vsm()-&gt;deallocate(ptr, word_size);
1571   } else {
1572     vsm()-&gt;deallocate(ptr, word_size);
1573   }
1574 }
1575 
1576 size_t ClassLoaderMetaspace::class_chunk_size(size_t word_size) {
1577   assert(Metaspace::using_class_space(), &quot;Has to use class space&quot;);
1578   return class_vsm()-&gt;calc_chunk_size(word_size);
1579 }
1580 
1581 void ClassLoaderMetaspace::print_on(outputStream* out) const {
1582   // Print both class virtual space counts and metaspace.
1583   if (Verbose) {
1584     vsm()-&gt;print_on(out);
1585     if (Metaspace::using_class_space()) {
1586       class_vsm()-&gt;print_on(out);
1587     }
1588   }
1589 }
1590 
1591 void ClassLoaderMetaspace::verify() {
1592   vsm()-&gt;verify();
1593   if (Metaspace::using_class_space()) {
1594     class_vsm()-&gt;verify();
1595   }
1596 }
1597 
1598 void ClassLoaderMetaspace::add_to_statistics_locked(ClassLoaderMetaspaceStatistics* out) const {
1599   assert_lock_strong(lock());
1600   vsm()-&gt;add_to_statistics_locked(&amp;out-&gt;nonclass_sm_stats());
1601   if (Metaspace::using_class_space()) {
1602     class_vsm()-&gt;add_to_statistics_locked(&amp;out-&gt;class_sm_stats());
1603   }
1604 }
1605 
1606 void ClassLoaderMetaspace::add_to_statistics(ClassLoaderMetaspaceStatistics* out) const {
<span class="line-modified">1607   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);</span>
1608   add_to_statistics_locked(out);
1609 }
1610 
1611 /////////////// Unit tests ///////////////
1612 

































































1613 struct chunkmanager_statistics_t {
1614   int num_specialized_chunks;
1615   int num_small_chunks;
1616   int num_medium_chunks;
1617   int num_humongous_chunks;
1618 };
1619 
1620 extern void test_metaspace_retrieve_chunkmanager_statistics(Metaspace::MetadataType mdType, chunkmanager_statistics_t* out) {
1621   ChunkManager* const chunk_manager = Metaspace::get_chunk_manager(mdType);
1622   ChunkManagerStatistics stat;
1623   chunk_manager-&gt;collect_statistics(&amp;stat);
1624   out-&gt;num_specialized_chunks = (int)stat.chunk_stats(SpecializedIndex).num();
1625   out-&gt;num_small_chunks = (int)stat.chunk_stats(SmallIndex).num();
1626   out-&gt;num_medium_chunks = (int)stat.chunk_stats(MediumIndex).num();
1627   out-&gt;num_humongous_chunks = (int)stat.chunk_stats(HumongousIndex).num();
1628 }
1629 
1630 struct chunk_geometry_t {
1631   size_t specialized_chunk_word_size;
1632   size_t small_chunk_word_size;
</pre>
</td>
</tr>
</table>
<center><a href="memRegion.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="metaspace.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/memory/allocation.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;memory/allocation.hpp&quot;
 27 #include &quot;memory/allocation.inline.hpp&quot;
 28 #include &quot;memory/arena.hpp&quot;
 29 #include &quot;memory/metaspaceShared.hpp&quot;
 30 #include &quot;memory/resourceArea.hpp&quot;
<a name="1" id="anc1"></a>

 31 #include &quot;runtime/os.hpp&quot;
 32 #include &quot;runtime/task.hpp&quot;
 33 #include &quot;runtime/threadCritical.hpp&quot;
 34 #include &quot;services/memTracker.hpp&quot;
 35 #include &quot;utilities/ostream.hpp&quot;
 36 
 37 // allocate using malloc; will fail if no memory available
 38 char* AllocateHeap(size_t size,
 39                    MEMFLAGS flags,
 40                    const NativeCallStack&amp; stack,
 41                    AllocFailType alloc_failmode /* = AllocFailStrategy::EXIT_OOM*/) {
 42   char* p = (char*) os::malloc(size, flags, stack);
 43   if (p == NULL &amp;&amp; alloc_failmode == AllocFailStrategy::EXIT_OOM) {
 44     vm_exit_out_of_memory(size, OOM_MALLOC_ERROR, &quot;AllocateHeap&quot;);
 45   }
 46   return p;
 47 }
 48 
 49 char* AllocateHeap(size_t size,
 50                    MEMFLAGS flags,
 51                    AllocFailType alloc_failmode /* = AllocFailStrategy::EXIT_OOM*/) {
 52   return AllocateHeap(size, flags, CALLER_PC);
 53 }
 54 
 55 char* ReallocateHeap(char *old,
 56                      size_t size,
 57                      MEMFLAGS flag,
 58                      AllocFailType alloc_failmode) {
 59   char* p = (char*) os::realloc(old, size, flag, CALLER_PC);
 60   if (p == NULL &amp;&amp; alloc_failmode == AllocFailStrategy::EXIT_OOM) {
 61     vm_exit_out_of_memory(size, OOM_MALLOC_ERROR, &quot;ReallocateHeap&quot;);
 62   }
 63   return p;
 64 }
 65 
<a name="2" id="anc2"></a><span class="line-added"> 66 // handles NULL pointers</span>
 67 void FreeHeap(void* p) {
 68   os::free(p);
 69 }
 70 
 71 void* MetaspaceObj::_shared_metaspace_base = NULL;
 72 void* MetaspaceObj::_shared_metaspace_top  = NULL;
 73 
 74 void* StackObj::operator new(size_t size)     throw() { ShouldNotCallThis(); return 0; }
 75 void  StackObj::operator delete(void* p)              { ShouldNotCallThis(); }
 76 void* StackObj::operator new [](size_t size)  throw() { ShouldNotCallThis(); return 0; }
 77 void  StackObj::operator delete [](void* p)           { ShouldNotCallThis(); }
 78 
 79 void* MetaspaceObj::operator new(size_t size, ClassLoaderData* loader_data,
 80                                  size_t word_size,
 81                                  MetaspaceObj::Type type, TRAPS) throw() {
 82   // Klass has it&#39;s own operator new
 83   return Metaspace::allocate(loader_data, word_size, type, THREAD);
 84 }
 85 
<a name="3" id="anc3"></a><span class="line-modified"> 86 bool MetaspaceObj::is_valid(const MetaspaceObj* p) {</span>
<span class="line-modified"> 87   // Weed out obvious bogus values first without traversing metaspace</span>
<span class="line-added"> 88   if ((size_t)p &lt; os::min_page_size()) {</span>
<span class="line-added"> 89     return false;</span>
<span class="line-added"> 90   } else if (!is_aligned((address)p, sizeof(MetaWord))) {</span>
<span class="line-added"> 91     return false;</span>
<span class="line-added"> 92   }</span>
<span class="line-added"> 93   return Metaspace::contains((void*)p);</span>
 94 }
 95 
 96 void MetaspaceObj::print_address_on(outputStream* st) const {
 97   st-&gt;print(&quot; {&quot; INTPTR_FORMAT &quot;}&quot;, p2i(this));
 98 }
 99 
100 void* ResourceObj::operator new(size_t size, Arena *arena) throw() {
101   address res = (address)arena-&gt;Amalloc(size);
102   DEBUG_ONLY(set_allocation_type(res, ARENA);)
103   return res;
104 }
105 
106 void* ResourceObj::operator new [](size_t size, Arena *arena) throw() {
107   address res = (address)arena-&gt;Amalloc(size);
108   DEBUG_ONLY(set_allocation_type(res, ARENA);)
109   return res;
110 }
111 
112 void* ResourceObj::operator new(size_t size, allocation_type type, MEMFLAGS flags) throw() {
113   address res = NULL;
114   switch (type) {
115    case C_HEAP:
116     res = (address)AllocateHeap(size, flags, CALLER_PC);
117     DEBUG_ONLY(set_allocation_type(res, C_HEAP);)
118     break;
119    case RESOURCE_AREA:
120     // new(size) sets allocation type RESOURCE_AREA.
121     res = (address)operator new(size);
122     break;
123    default:
124     ShouldNotReachHere();
125   }
126   return res;
127 }
128 
129 void* ResourceObj::operator new [](size_t size, allocation_type type, MEMFLAGS flags) throw() {
130   return (address) operator new(size, type, flags);
131 }
132 
133 void* ResourceObj::operator new(size_t size, const std::nothrow_t&amp;  nothrow_constant,
134     allocation_type type, MEMFLAGS flags) throw() {
135   // should only call this with std::nothrow, use other operator new() otherwise
136   address res = NULL;
137   switch (type) {
138    case C_HEAP:
139     res = (address)AllocateHeap(size, flags, CALLER_PC, AllocFailStrategy::RETURN_NULL);
140     DEBUG_ONLY(if (res!= NULL) set_allocation_type(res, C_HEAP);)
141     break;
142    case RESOURCE_AREA:
143     // new(size) sets allocation type RESOURCE_AREA.
144     res = (address)operator new(size, std::nothrow);
145     break;
146    default:
147     ShouldNotReachHere();
148   }
149   return res;
150 }
151 
152 void* ResourceObj::operator new [](size_t size, const std::nothrow_t&amp;  nothrow_constant,
153     allocation_type type, MEMFLAGS flags) throw() {
154   return (address)operator new(size, nothrow_constant, type, flags);
155 }
156 
157 void ResourceObj::operator delete(void* p) {
158   assert(((ResourceObj *)p)-&gt;allocated_on_C_heap(),
159          &quot;delete only allowed for C_HEAP objects&quot;);
160   DEBUG_ONLY(((ResourceObj *)p)-&gt;_allocation_t[0] = (uintptr_t)badHeapOopVal;)
161   FreeHeap(p);
162 }
163 
164 void ResourceObj::operator delete [](void* p) {
165   operator delete(p);
166 }
167 
168 #ifdef ASSERT
169 void ResourceObj::set_allocation_type(address res, allocation_type type) {
170   // Set allocation type in the resource object
171   uintptr_t allocation = (uintptr_t)res;
172   assert((allocation &amp; allocation_mask) == 0, &quot;address should be aligned to 4 bytes at least: &quot; INTPTR_FORMAT, p2i(res));
173   assert(type &lt;= allocation_mask, &quot;incorrect allocation type&quot;);
174   ResourceObj* resobj = (ResourceObj *)res;
175   resobj-&gt;_allocation_t[0] = ~(allocation + type);
176   if (type != STACK_OR_EMBEDDED) {
177     // Called from operator new(), set verification value.
178     resobj-&gt;_allocation_t[1] = (uintptr_t)&amp;(resobj-&gt;_allocation_t[1]) + type;
179   }
180 }
181 
182 ResourceObj::allocation_type ResourceObj::get_allocation_type() const {
183   assert(~(_allocation_t[0] | allocation_mask) == (uintptr_t)this, &quot;lost resource object&quot;);
184   return (allocation_type)((~_allocation_t[0]) &amp; allocation_mask);
185 }
186 
187 bool ResourceObj::is_type_set() const {
188   allocation_type type = (allocation_type)(_allocation_t[1] &amp; allocation_mask);
189   return get_allocation_type()  == type &amp;&amp;
190          (_allocation_t[1] - type) == (uintptr_t)(&amp;_allocation_t[1]);
191 }
192 
193 // This whole business of passing information from ResourceObj::operator new
194 // to the ResourceObj constructor via fields in the &quot;object&quot; is technically UB.
195 // But it seems to work within the limitations of HotSpot usage (such as no
196 // multiple inheritance) with the compilers and compiler options we&#39;re using.
197 // And it gives some possibly useful checking for misuse of ResourceObj.
198 void ResourceObj::initialize_allocation_info() {
199   if (~(_allocation_t[0] | allocation_mask) != (uintptr_t)this) {
200     // Operator new() is not called for allocations
201     // on stack and for embedded objects.
202     set_allocation_type((address)this, STACK_OR_EMBEDDED);
203   } else if (allocated_on_stack()) { // STACK_OR_EMBEDDED
204     // For some reason we got a value which resembles
205     // an embedded or stack object (operator new() does not
206     // set such type). Keep it since it is valid value
207     // (even if it was garbage).
208     // Ignore garbage in other fields.
209   } else if (is_type_set()) {
210     // Operator new() was called and type was set.
211     assert(!allocated_on_stack(),
212            &quot;not embedded or stack, this(&quot; PTR_FORMAT &quot;) type %d a[0]=(&quot; PTR_FORMAT &quot;) a[1]=(&quot; PTR_FORMAT &quot;)&quot;,
213            p2i(this), get_allocation_type(), _allocation_t[0], _allocation_t[1]);
214   } else {
215     // Operator new() was not called.
216     // Assume that it is embedded or stack object.
217     set_allocation_type((address)this, STACK_OR_EMBEDDED);
218   }
219   _allocation_t[1] = 0; // Zap verification value
220 }
221 
222 ResourceObj::ResourceObj() {
223   initialize_allocation_info();
224 }
225 
226 ResourceObj::ResourceObj(const ResourceObj&amp;) {
227   // Initialize _allocation_t as a new object, ignoring object being copied.
228   initialize_allocation_info();
229 }
230 
231 ResourceObj&amp; ResourceObj::operator=(const ResourceObj&amp; r) {
232   assert(allocated_on_stack(),
233          &quot;copy only into local, this(&quot; PTR_FORMAT &quot;) type %d a[0]=(&quot; PTR_FORMAT &quot;) a[1]=(&quot; PTR_FORMAT &quot;)&quot;,
234          p2i(this), get_allocation_type(), _allocation_t[0], _allocation_t[1]);
235   // Keep current _allocation_t value;
236   return *this;
237 }
238 
239 ResourceObj::~ResourceObj() {
240   // allocated_on_C_heap() also checks that encoded (in _allocation) address == this.
241   if (!allocated_on_C_heap()) { // ResourceObj::delete() will zap _allocation for C_heap.
242     _allocation_t[0] = (uintptr_t)badHeapOopVal; // zap type
243   }
244 }
245 #endif // ASSERT
246 
247 //--------------------------------------------------------------------------------------
248 // Non-product code
249 
250 #ifndef PRODUCT
251 void AllocatedObj::print() const       { print_on(tty); }
252 void AllocatedObj::print_value() const { print_value_on(tty); }
253 
254 void AllocatedObj::print_on(outputStream* st) const {
255   st-&gt;print_cr(&quot;AllocatedObj(&quot; INTPTR_FORMAT &quot;)&quot;, p2i(this));
256 }
257 
258 void AllocatedObj::print_value_on(outputStream* st) const {
259   st-&gt;print(&quot;AllocatedObj(&quot; INTPTR_FORMAT &quot;)&quot;, p2i(this));
260 }
261 
<a name="4" id="anc4"></a>


















262 ReallocMark::ReallocMark() {
263 #ifdef ASSERT
264   Thread *thread = Thread::current();
265   _nesting = thread-&gt;resource_area()-&gt;nesting();
266 #endif
267 }
268 
269 void ReallocMark::check() {
270 #ifdef ASSERT
271   if (_nesting != Thread::current()-&gt;resource_area()-&gt;nesting()) {
272     fatal(&quot;allocation bug: array could grow within nested ResourceMark&quot;);
273   }
274 #endif
275 }
276 
277 #endif // Non-product
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
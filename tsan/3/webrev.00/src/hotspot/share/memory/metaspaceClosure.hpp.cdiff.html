<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/memory/metaspaceClosure.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="metaspaceClosure.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="metaspaceShared.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/metaspaceClosure.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,10 ***</span>
<span class="line-new-header">--- 26,11 ---</span>
  #define SHARE_MEMORY_METASPACECLOSURE_HPP
  
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;oops/array.hpp&quot;
<span class="line-added">+ #include &quot;utilities/globalDefinitions.hpp&quot;</span>
  #include &quot;utilities/growableArray.hpp&quot;
  #include &quot;utilities/hashtable.inline.hpp&quot;
  
  // The metadata hierarchy is separate from the oop hierarchy
    class MetaspaceObj;        // no C++ vtable
</pre>
<hr />
<pre>
<span class="line-old-header">*** 73,10 ***</span>
<span class="line-new-header">--- 74,14 ---</span>
      _writable,
      _not_writable,
      _default
    };
  
<span class="line-added">+   enum SpecialRef {</span>
<span class="line-added">+     _method_entry_ref</span>
<span class="line-added">+   };</span>
<span class="line-added">+ </span>
    // class MetaspaceClosure::Ref --
    //
    // MetaspaceClosure can be viewed as a very simple type of copying garbage
    // collector. For it to function properly, it requires each subclass of
    // MetaspaceObj to provide two methods:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 99,30 ***</span>
    //         MetaspaceObj *_obj;
    //         Array&lt;int&gt;* foo() { return (Array&lt;int&gt;*)_obj; }
    //         Symbol*     bar() { return (Symbol*)    _obj; }
    //
    // [2] All Array&lt;T&gt; dimensions are statically declared.
<span class="line-modified">!   class Ref {</span>
    protected:
      virtual void** mpp() const = 0;
    public:
      virtual bool not_null() const = 0;
      virtual int size() const = 0;
      virtual void metaspace_pointers_do(MetaspaceClosure *it) const = 0;
      virtual void metaspace_pointers_do_at(MetaspaceClosure *it, address new_loc) const = 0;
      virtual MetaspaceObj::Type msotype() const = 0;
      virtual bool is_read_only_by_default() const = 0;
  
      address obj() const {
        // In some rare cases (see CPSlot in constantPool.hpp) we store some flags in the lowest
        // 2 bits of a MetaspaceObj pointer. Unmask these when manipulating the pointer.
        uintx p = (uintx)*mpp();
        return (address)(p &amp; (~FLAG_MASK));
      }
  
      void update(address new_loc) const;
  
    private:
      static const uintx FLAG_MASK = 0x03;
  
      int flag_bits() const {
        uintx p = (uintx)*mpp();
<span class="line-new-header">--- 104,44 ---</span>
    //         MetaspaceObj *_obj;
    //         Array&lt;int&gt;* foo() { return (Array&lt;int&gt;*)_obj; }
    //         Symbol*     bar() { return (Symbol*)    _obj; }
    //
    // [2] All Array&lt;T&gt; dimensions are statically declared.
<span class="line-modified">!   class Ref : public CHeapObj&lt;mtInternal&gt; {</span>
<span class="line-added">+     Writability _writability;</span>
<span class="line-added">+     Ref* _next;</span>
<span class="line-added">+     NONCOPYABLE(Ref);</span>
<span class="line-added">+ </span>
    protected:
      virtual void** mpp() const = 0;
<span class="line-added">+     Ref(Writability w) : _writability(w), _next(NULL) {}</span>
    public:
      virtual bool not_null() const = 0;
      virtual int size() const = 0;
      virtual void metaspace_pointers_do(MetaspaceClosure *it) const = 0;
      virtual void metaspace_pointers_do_at(MetaspaceClosure *it, address new_loc) const = 0;
      virtual MetaspaceObj::Type msotype() const = 0;
      virtual bool is_read_only_by_default() const = 0;
<span class="line-added">+     virtual ~Ref() {}</span>
  
      address obj() const {
        // In some rare cases (see CPSlot in constantPool.hpp) we store some flags in the lowest
        // 2 bits of a MetaspaceObj pointer. Unmask these when manipulating the pointer.
        uintx p = (uintx)*mpp();
        return (address)(p &amp; (~FLAG_MASK));
      }
  
<span class="line-added">+     address* addr() const {</span>
<span class="line-added">+       return (address*)mpp();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      void update(address new_loc) const;
  
<span class="line-added">+     Writability writability() const { return _writability; };</span>
<span class="line-added">+     void set_next(Ref* n)           { _next = n; }</span>
<span class="line-added">+     Ref* next() const               { return _next; }</span>
<span class="line-added">+ </span>
    private:
      static const uintx FLAG_MASK = 0x03;
  
      int flag_bits() const {
        uintx p = (uintx)*mpp();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 141,11 ***</span>
      virtual void** mpp() const {
        return (void**)_mpp;
      }
  
    public:
<span class="line-modified">!     ObjectRef(T** mpp) : _mpp(mpp) {}</span>
  
      virtual bool is_read_only_by_default() const { return T::is_read_only_by_default(); }
      virtual bool not_null()                const { return dereference() != NULL; }
      virtual int size()                     const { return dereference()-&gt;size(); }
      virtual MetaspaceObj::Type msotype()   const { return dereference()-&gt;type(); }
<span class="line-new-header">--- 160,11 ---</span>
      virtual void** mpp() const {
        return (void**)_mpp;
      }
  
    public:
<span class="line-modified">!     ObjectRef(T** mpp, Writability w) : Ref(w), _mpp(mpp) {}</span>
  
      virtual bool is_read_only_by_default() const { return T::is_read_only_by_default(); }
      virtual bool not_null()                const { return dereference() != NULL; }
      virtual int size()                     const { return dereference()-&gt;size(); }
      virtual MetaspaceObj::Type msotype()   const { return dereference()-&gt;type(); }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 168,11 ***</span>
      virtual void** mpp() const {
        return (void**)_mpp;
      }
  
    public:
<span class="line-modified">!     PrimitiveArrayRef(Array&lt;T&gt;** mpp) : _mpp(mpp) {}</span>
  
      // all Arrays are read-only by default
      virtual bool is_read_only_by_default() const { return true; }
      virtual bool not_null()                const { return dereference() != NULL;  }
      virtual int size()                     const { return dereference()-&gt;size(); }
<span class="line-new-header">--- 187,11 ---</span>
      virtual void** mpp() const {
        return (void**)_mpp;
      }
  
    public:
<span class="line-modified">!     PrimitiveArrayRef(Array&lt;T&gt;** mpp, Writability w) : Ref(w), _mpp(mpp) {}</span>
  
      // all Arrays are read-only by default
      virtual bool is_read_only_by_default() const { return true; }
      virtual bool not_null()                const { return dereference() != NULL;  }
      virtual int size()                     const { return dereference()-&gt;size(); }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 198,11 ***</span>
      virtual void** mpp() const {
        return (void**)_mpp;
      }
  
    public:
<span class="line-modified">!     PointerArrayRef(Array&lt;T*&gt;** mpp) : _mpp(mpp) {}</span>
  
      // all Arrays are read-only by default
      virtual bool is_read_only_by_default() const { return true; }
      virtual bool not_null()                const { return dereference() != NULL; }
      virtual int size()                     const { return dereference()-&gt;size(); }
<span class="line-new-header">--- 217,11 ---</span>
      virtual void** mpp() const {
        return (void**)_mpp;
      }
  
    public:
<span class="line-modified">!     PointerArrayRef(Array&lt;T*&gt;** mpp, Writability w) : Ref(w), _mpp(mpp) {}</span>
  
      // all Arrays are read-only by default
      virtual bool is_read_only_by_default() const { return true; }
      virtual bool not_null()                const { return dereference() != NULL; }
      virtual int size()                     const { return dereference()-&gt;size(); }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 222,39 ***</span>
          it-&gt;push(mpp);
        }
      }
    };
  
<span class="line-modified">!   void push_impl(Ref* ref, Writability w);</span>
  
  public:
    // returns true if we want to keep iterating the pointers embedded inside &lt;ref&gt;
    virtual bool do_ref(Ref* ref, bool read_only) = 0;
  
    // When you do:
    //     void MyType::metaspace_pointers_do(MetaspaceClosure* it) {
    //       it-&gt;push(_my_field)
    //
    // C++ will try to match the &quot;most specific&quot; template function. This one will
    // will be matched if possible (if mpp is an Array&lt;&gt; of any pointer type).
    template &lt;typename T&gt; void push(Array&lt;T*&gt;** mpp, Writability w = _default) {
<span class="line-modified">!     PointerArrayRef&lt;T&gt; ref(mpp);</span>
<span class="line-removed">-     push_impl(&amp;ref, w);</span>
    }
  
    // If the above function doesn&#39;t match (mpp is an Array&lt;&gt;, but T is not a pointer type), then
    // this is the second choice.
    template &lt;typename T&gt; void push(Array&lt;T&gt;** mpp, Writability w = _default) {
<span class="line-modified">!     PrimitiveArrayRef&lt;T&gt; ref(mpp);</span>
<span class="line-removed">-     push_impl(&amp;ref, w);</span>
    }
  
    // If the above function doesn&#39;t match (mpp is not an Array&lt;&gt; type), then
    // this will be matched by default.
    template &lt;class T&gt; void push(T** mpp, Writability w = _default) {
<span class="line-modified">!     ObjectRef&lt;T&gt; ref(mpp);</span>
<span class="line-modified">!     push_impl(&amp;ref, w);</span>
    }
  };
  
  // This is a special MetaspaceClosure that visits each unique MetaspaceObj once.
  class UniqueMetaspaceClosure : public MetaspaceClosure {
<span class="line-new-header">--- 241,58 ---</span>
          it-&gt;push(mpp);
        }
      }
    };
  
<span class="line-modified">!   // If recursion is too deep, save the Refs in _pending_refs, and push them later using</span>
<span class="line-added">+   // MetaspaceClosure::finish()</span>
<span class="line-added">+   static const int MAX_NEST_LEVEL = 5;</span>
<span class="line-added">+   Ref* _pending_refs;</span>
<span class="line-added">+   int _nest_level;</span>
<span class="line-added">+ </span>
<span class="line-added">+   void push_impl(Ref* ref);</span>
<span class="line-added">+   void do_push(Ref* ref);</span>
  
  public:
<span class="line-added">+   MetaspaceClosure(): _pending_refs(NULL), _nest_level(0) {}</span>
<span class="line-added">+   ~MetaspaceClosure();</span>
<span class="line-added">+ </span>
<span class="line-added">+   void finish();</span>
<span class="line-added">+ </span>
    // returns true if we want to keep iterating the pointers embedded inside &lt;ref&gt;
    virtual bool do_ref(Ref* ref, bool read_only) = 0;
  
    // When you do:
    //     void MyType::metaspace_pointers_do(MetaspaceClosure* it) {
    //       it-&gt;push(_my_field)
    //
    // C++ will try to match the &quot;most specific&quot; template function. This one will
    // will be matched if possible (if mpp is an Array&lt;&gt; of any pointer type).
    template &lt;typename T&gt; void push(Array&lt;T*&gt;** mpp, Writability w = _default) {
<span class="line-modified">!     push_impl(new PointerArrayRef&lt;T&gt;(mpp, w));</span>
    }
  
    // If the above function doesn&#39;t match (mpp is an Array&lt;&gt;, but T is not a pointer type), then
    // this is the second choice.
    template &lt;typename T&gt; void push(Array&lt;T&gt;** mpp, Writability w = _default) {
<span class="line-modified">!     push_impl(new PrimitiveArrayRef&lt;T&gt;(mpp, w));</span>
    }
  
    // If the above function doesn&#39;t match (mpp is not an Array&lt;&gt; type), then
    // this will be matched by default.
    template &lt;class T&gt; void push(T** mpp, Writability w = _default) {
<span class="line-modified">!     push_impl(new ObjectRef&lt;T&gt;(mpp, w));</span>
<span class="line-modified">!   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   template &lt;class T&gt; void push_method_entry(T** mpp, intptr_t* p) {</span>
<span class="line-added">+     push_special(_method_entry_ref, new ObjectRef&lt;T&gt;(mpp, _default), (intptr_t*)p);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // This is for tagging special pointers that are not a reference to MetaspaceObj. It&#39;s currently</span>
<span class="line-added">+   // used to mark the method entry points in Method/ConstMethod.</span>
<span class="line-added">+   virtual void push_special(SpecialRef type, Ref* obj, intptr_t* p) {</span>
<span class="line-added">+     assert(type == _method_entry_ref, &quot;only special type allowed for now&quot;);</span>
    }
  };
  
  // This is a special MetaspaceClosure that visits each unique MetaspaceObj once.
  class UniqueMetaspaceClosure : public MetaspaceClosure {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 264,11 ***</span>
    // Do not override. Returns true if we are discovering ref-&gt;obj() for the first time.
    virtual bool do_ref(Ref* ref, bool read_only);
  
  public:
    // Gets called the first time we discover an object.
<span class="line-modified">!   virtual void do_unique_ref(Ref* ref, bool read_only) = 0;</span>
    UniqueMetaspaceClosure() : _has_been_visited(INITIAL_TABLE_SIZE) {}
  
  private:
    KVHashtable&lt;address, bool, mtInternal&gt; _has_been_visited;
  };
<span class="line-new-header">--- 302,11 ---</span>
    // Do not override. Returns true if we are discovering ref-&gt;obj() for the first time.
    virtual bool do_ref(Ref* ref, bool read_only);
  
  public:
    // Gets called the first time we discover an object.
<span class="line-modified">!   virtual bool do_unique_ref(Ref* ref, bool read_only) = 0;</span>
    UniqueMetaspaceClosure() : _has_been_visited(INITIAL_TABLE_SIZE) {}
  
  private:
    KVHashtable&lt;address, bool, mtInternal&gt; _has_been_visited;
  };
</pre>
<center><a href="metaspaceClosure.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="metaspaceShared.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
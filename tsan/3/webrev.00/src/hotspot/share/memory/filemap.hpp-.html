<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/memory/filemap.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_MEMORY_FILEMAP_HPP
 26 #define SHARE_MEMORY_FILEMAP_HPP
 27 
 28 #include &quot;classfile/classLoader.hpp&quot;
 29 #include &quot;include/cds.h&quot;
 30 #include &quot;memory/metaspaceShared.hpp&quot;
 31 #include &quot;memory/metaspace.hpp&quot;
 32 #include &quot;memory/universe.hpp&quot;
 33 #include &quot;utilities/align.hpp&quot;
 34 
 35 // Layout of the file:
 36 //  header: dump of archive instance plus versioning info, datestamp, etc.
 37 //   [magic # = 0xF00BABA2]
 38 //  ... padding to align on page-boundary
 39 //  read-write space
 40 //  read-only space
 41 //  misc data (block offset table, string table, symbols, dictionary, etc.)
 42 //  tag(666)
 43 
 44 static const int JVM_IDENT_MAX = 256;
 45 
 46 class SharedClassPathEntry {
 47   enum {
 48     modules_image_entry,
 49     jar_entry,
 50     signed_jar_entry,
 51     dir_entry,
 52     unknown_entry
 53   };
 54 protected:
 55   u1     _type;
 56   time_t _timestamp;          // jar timestamp,  0 if is directory, modules image or other
 57   long   _filesize;           // jar/jimage file size, -1 if is directory, -2 if other
 58   Array&lt;char&gt;* _name;
 59   Array&lt;u1&gt;*   _manifest;
 60 
 61 public:
 62   void init(const char* name, bool is_modules_image, TRAPS);
 63   void metaspace_pointers_do(MetaspaceClosure* it);
 64   bool validate(bool is_class_path = true);
 65 
 66   // The _timestamp only gets set for jar files.
 67   bool has_timestamp() {
 68     return _timestamp != 0;
 69   }
 70   bool is_dir()            { return _type == dir_entry; }
 71   bool is_modules_image()  { return _type == modules_image_entry; }
 72   bool is_jar()            { return _type == jar_entry; }
 73   bool is_signed()         { return _type == signed_jar_entry; }
 74   void set_is_signed()     {
 75     _type = signed_jar_entry;
 76   }
 77   time_t timestamp() const { return _timestamp; }
 78   long   filesize()  const { return _filesize; }
 79   const char* name() const { return _name-&gt;data(); }
 80   const char* manifest() const {
 81     return (_manifest == NULL) ? NULL : (const char*)_manifest-&gt;data();
 82   }
 83   int manifest_size() const {
 84     return (_manifest == NULL) ? 0 : _manifest-&gt;length();
 85   }
 86   void set_manifest(Array&lt;u1&gt;* manifest) {
 87     _manifest = manifest;
 88   }
 89 };
 90 
 91 struct ArchiveHeapOopmapInfo {
 92   address _oopmap;               // bitmap for relocating embedded oops
 93   size_t  _oopmap_size_in_bits;
 94 };
 95 
 96 struct FileMapHeader : public CDSFileMapHeaderBase {
 97   size_t _alignment;                // how shared archive should be aligned
 98   int    _obj_alignment;            // value of ObjectAlignmentInBytes
 99   address _narrow_oop_base;         // compressed oop encoding base
100   int    _narrow_oop_shift;         // compressed oop encoding shift
101   bool    _compact_strings;         // value of CompactStrings
102   uintx  _max_heap_size;            // java max heap size during dumping
103   Universe::NARROW_OOP_MODE _narrow_oop_mode; // compressed oop encoding mode
104   int     _narrow_klass_shift;      // save narrow klass base and shift
105   address _narrow_klass_base;
106   char*   _misc_data_patching_start;
107   char*   _read_only_tables_start;
108   address _cds_i2i_entry_code_buffers;
109   size_t  _cds_i2i_entry_code_buffers_size;
110   size_t  _core_spaces_size;        // number of bytes allocated by the core spaces
111                                     // (mc, md, ro, rw and od).
112   MemRegion _heap_reserved;         // reserved region for the entire heap at dump time.
113 
114   // The following fields are all sanity checks for whether this archive
115   // will function correctly with this JVM and the bootclasspath it&#39;s
116   // invoked with.
117   char  _jvm_ident[JVM_IDENT_MAX];      // identifier for jvm
118 
119   // The _paths_misc_info is a variable-size structure that records &quot;miscellaneous&quot;
120   // information during dumping. It is generated and validated by the
121   // SharedPathsMiscInfo class. See SharedPathsMiscInfo.hpp for
122   // detailed description.
123   //
124   // The _paths_misc_info data is stored as a byte array in the archive file header,
125   // immediately after the _header field. This information is used only when
126   // checking the validity of the archive and is deallocated after the archive is loaded.
127   //
128   // Note that the _paths_misc_info does NOT include information for JAR files
129   // that existed during dump time. Their information is stored in _shared_path_table.
130   int _paths_misc_info_size;
131 
132   // The following is a table of all the class path entries that were used
133   // during dumping. At run time, we require these files to exist and have the same
134   // size/modification time, or else the archive will refuse to load.
135   //
136   // All of these entries must be JAR files. The dumping process would fail if a non-empty
137   // directory was specified in the classpaths. If an empty directory was specified
138   // it is checked by the _paths_misc_info as described above.
139   //
140   // FIXME -- if JAR files in the tail of the list were specified but not used during dumping,
141   // they should be removed from this table, to save space and to avoid spurious
142   // loading failures during runtime.
143   int _shared_path_table_size;
144   size_t _shared_path_entry_size;
145   Array&lt;u8&gt;* _shared_path_table;
146 
147   jshort _app_class_paths_start_index;  // Index of first app classpath entry
148   jshort _app_module_paths_start_index; // Index of first module path entry
149   jshort _max_used_path_index;          // max path index referenced during CDS dump
150   bool   _verify_local;                 // BytecodeVerificationLocal setting
151   bool   _verify_remote;                // BytecodeVerificationRemote setting
152   bool   _has_platform_or_app_classes;  // Archive contains app classes
153   size_t _shared_base_address;          // SharedBaseAddress used at dump time
154   bool   _allow_archiving_with_java_agent; // setting of the AllowArchivingWithJavaAgent option
155 
156   void set_has_platform_or_app_classes(bool v) {
157     _has_platform_or_app_classes = v;
158   }
159   bool has_platform_or_app_classes() { return _has_platform_or_app_classes; }
160   jshort max_used_path_index()       { return _max_used_path_index; }
161   jshort app_module_paths_start_index() { return _app_module_paths_start_index; }
162 
163   bool validate();
164   void populate(FileMapInfo* info, size_t alignment);
165   int compute_crc();
166 
167   CDSFileMapRegion* space_at(int i) {
168     assert(i &gt;= 0 &amp;&amp; i &lt; NUM_CDS_REGIONS, &quot;invalid region&quot;);
169     return &amp;_space[i];
170   }
171 };
172 
173 class FileMapInfo : public CHeapObj&lt;mtInternal&gt; {
174 private:
175   friend class ManifestStream;
176   friend class VMStructs;
177   friend struct FileMapHeader;
178 
179   bool    _file_open;
180   int     _fd;
181   size_t  _file_offset;
182 
183 private:
184   static Array&lt;u8&gt;*            _shared_path_table;
185   static int                   _shared_path_table_size;
186   static size_t                _shared_path_entry_size;
187   static bool                  _validating_shared_path_table;
188 
189   // FileMapHeader describes the shared space data in the file to be
190   // mapped.  This structure gets written to a file.  It is not a class, so
191   // that the compilers don&#39;t add any compiler-private data to it.
192 
193 public:
194   struct FileMapHeaderBase : public CHeapObj&lt;mtClass&gt; {
195     // Need to put something here. Otherwise, in product build, because CHeapObj has no virtual
196     // methods, we would get sizeof(FileMapHeaderBase) == 1 with gcc.
197     intx _dummy;
198   };
199 
200 
201   FileMapHeader * _header;
202 
203   const char* _full_path;
204   char* _paths_misc_info;
205 
206   static FileMapInfo* _current_info;
207   static bool _heap_pointers_need_patching;
208 
209   bool  init_from_file(int fd);
210   void  align_file_position();
211   bool  validate_header_impl();
212   static void metaspace_pointers_do(MetaspaceClosure* it);
213 
214 public:
215   FileMapInfo();
216   ~FileMapInfo();
217 
218   int    compute_header_crc()         { return _header-&gt;compute_crc(); }
219   void   set_header_crc(int crc)      { _header-&gt;_crc = crc; }
220   void   populate_header(size_t alignment);
221   bool   validate_header();
222   void   invalidate();
223   int    version()                    { return _header-&gt;_version; }
224   size_t alignment()                  { return _header-&gt;_alignment; }
225   Universe::NARROW_OOP_MODE narrow_oop_mode() { return _header-&gt;_narrow_oop_mode; }
226   address narrow_oop_base()    const  { return _header-&gt;_narrow_oop_base; }
227   int     narrow_oop_shift()   const  { return _header-&gt;_narrow_oop_shift; }
228   uintx   max_heap_size()      const  { return _header-&gt;_max_heap_size; }
229   address narrow_klass_base()  const  { return _header-&gt;_narrow_klass_base; }
230   int     narrow_klass_shift() const  { return _header-&gt;_narrow_klass_shift; }
231   struct  FileMapHeader* header()     { return _header; }
232   char*   misc_data_patching_start()          { return _header-&gt;_misc_data_patching_start; }
233   void set_misc_data_patching_start(char* p)  { _header-&gt;_misc_data_patching_start = p; }
234   char* read_only_tables_start()              { return _header-&gt;_read_only_tables_start; }
235   void set_read_only_tables_start(char* p)    { _header-&gt;_read_only_tables_start = p; }
236 
237   address cds_i2i_entry_code_buffers() {
238     return _header-&gt;_cds_i2i_entry_code_buffers;
239   }
240   void set_cds_i2i_entry_code_buffers(address addr) {
241     _header-&gt;_cds_i2i_entry_code_buffers = addr;
242   }
243   size_t cds_i2i_entry_code_buffers_size() {
244     return _header-&gt;_cds_i2i_entry_code_buffers_size;
245   }
246   void set_cds_i2i_entry_code_buffers_size(size_t s) {
247     _header-&gt;_cds_i2i_entry_code_buffers_size = s;
248   }
249   void set_core_spaces_size(size_t s)    {  _header-&gt;_core_spaces_size = s; }
250   size_t core_spaces_size()              { return _header-&gt;_core_spaces_size; }
251 
252   static FileMapInfo* current_info() {
253     CDS_ONLY(return _current_info;)
254     NOT_CDS(return NULL;)
255   }
256 
257   static void assert_mark(bool check);
258 
259   // File manipulation.
260   bool  initialize() NOT_CDS_RETURN_(false);
261   bool  open_for_read();
262   void  open_for_write();
263   void  write_header();
264   void  write_region(int region, char* base, size_t size,
265                      bool read_only, bool allow_exec);
266   size_t write_archive_heap_regions(GrowableArray&lt;MemRegion&gt; *heap_mem,
267                                     GrowableArray&lt;ArchiveHeapOopmapInfo&gt; *oopmaps,
268                                     int first_region_id, int max_num_regions,
269                                     bool print_log);
270   void  write_bytes(const void* buffer, size_t count);
271   void  write_bytes_aligned(const void* buffer, size_t count);
272   char* map_region(int i, char** top_ret);
273   void  map_heap_regions_impl() NOT_CDS_JAVA_HEAP_RETURN;
274   void  map_heap_regions() NOT_CDS_JAVA_HEAP_RETURN;
275   void  fixup_mapped_heap_regions() NOT_CDS_JAVA_HEAP_RETURN;
276   void  patch_archived_heap_embedded_pointers() NOT_CDS_JAVA_HEAP_RETURN;
277   void  patch_archived_heap_embedded_pointers(MemRegion* ranges, int num_ranges,
278                                               int first_region_idx) NOT_CDS_JAVA_HEAP_RETURN;
279   bool  has_heap_regions()  NOT_CDS_JAVA_HEAP_RETURN_(false);
280   MemRegion get_heap_regions_range_with_current_oop_encoding_mode() NOT_CDS_JAVA_HEAP_RETURN_(MemRegion());
281   void  unmap_region(int i);
282   bool  verify_region_checksum(int i);
283   void  close();
284   bool  is_open() { return _file_open; }
285   ReservedSpace reserve_shared_memory();
286 
287   // JVM/TI RedefineClasses() support:
288   // Remap the shared readonly space to shared readwrite, private.
289   bool  remap_shared_readonly_as_readwrite();
290 
291   // Errors.
292   static void fail_stop(const char *msg, ...) ATTRIBUTE_PRINTF(1, 2);
293   static void fail_continue(const char *msg, ...) ATTRIBUTE_PRINTF(1, 2);
294 
295   bool is_in_shared_region(const void* p, int idx) NOT_CDS_RETURN_(false);
296 
297   // Stop CDS sharing and unmap CDS regions.
298   static void stop_sharing_and_unmap(const char* msg);
299 
300   static void allocate_shared_path_table();
301   static void check_nonempty_dir_in_shared_path_table();
302   bool validate_shared_path_table();
303   static void update_shared_classpath(ClassPathEntry *cpe, SharedClassPathEntry* ent, TRAPS);
304 
305 #if INCLUDE_JVMTI
306   static ClassFileStream* open_stream_for_jvmti(InstanceKlass* ik, TRAPS);
307 #endif
308 
309   static SharedClassPathEntry* shared_path(int index) {
310     if (index &lt; 0) {
311       return NULL;
312     }
313     assert(index &lt; _shared_path_table_size, &quot;sanity&quot;);
314     char* p = (char*)_shared_path_table-&gt;data();
315     p += _shared_path_entry_size * index;
316     return (SharedClassPathEntry*)p;
317   }
318 
319   static const char* shared_path_name(int index) {
320     assert(index &gt;= 0, &quot;Sanity&quot;);
321     return shared_path(index)-&gt;name();
322   }
323 
324   static int get_number_of_shared_paths() {
325     return _shared_path_table_size;
326   }
327 
328   char* region_addr(int idx);
329 
330  private:
331   bool  map_heap_data(MemRegion **heap_mem, int first, int max, int* num,
332                       bool is_open = false) NOT_CDS_JAVA_HEAP_RETURN_(false);
333   bool  verify_mapped_heap_regions(int first, int num) NOT_CDS_JAVA_HEAP_RETURN_(false);
334   void  dealloc_archive_heap_regions(MemRegion* regions, int num, bool is_open) NOT_CDS_JAVA_HEAP_RETURN;
335 
336   CDSFileMapRegion* space_at(int i) {
337     return _header-&gt;space_at(i);
338   }
339 
340   narrowOop offset_of_space(CDSFileMapRegion* spc) {
341     return (narrowOop)(spc-&gt;_addr._offset);
342   }
343 
344   // The starting address of spc, as calculated with CompressedOop::decode_non_null()
345   address start_address_as_decoded_with_current_oop_encoding_mode(CDSFileMapRegion* spc) {
346     return decode_start_address(spc, true);
347   }
348 
349   // The starting address of spc, as calculated with HeapShared::decode_from_archive()
350   address start_address_as_decoded_from_archive(CDSFileMapRegion* spc) {
351     return decode_start_address(spc, false);
352   }
353 
354   address decode_start_address(CDSFileMapRegion* spc, bool with_current_oop_encoding_mode);
355 
356 #if INCLUDE_JVMTI
357   static ClassPathEntry** _classpath_entries_for_jvmti;
358   static ClassPathEntry* get_classpath_entry_for_jvmti(int i, TRAPS);
359 #endif
360 };
361 
362 #endif // SHARE_MEMORY_FILEMAP_HPP
    </pre>
  </body>
</html>
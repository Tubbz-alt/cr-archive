diff a/src/hotspot/share/memory/heap.hpp b/src/hotspot/share/memory/heap.hpp
--- a/src/hotspot/share/memory/heap.hpp
+++ b/src/hotspot/share/memory/heap.hpp
@@ -49,10 +49,12 @@
   };
 
  public:
   // Initialization
   void initialize(size_t length)                 { _header._length = length; set_used(); }
+  // Merging/splitting
+  void set_length(size_t length)                 { _header._length = length; }
 
   // Accessors
   void* allocated_space() const                  { return (void*)(this + 1); }
   size_t length() const                          { return _header._length; }
 
@@ -69,13 +71,10 @@
 
  public:
   // Initialization
   void initialize(size_t length)             { HeapBlock::initialize(length); _link= NULL; }
 
-  // Merging
-  void set_length(size_t l)                  { _header._length = l; }
-
   // Accessors
   FreeBlock* link() const                    { return _link; }
   void set_link(FreeBlock* link)             { _link = link; }
 };
 
@@ -91,51 +90,61 @@
   int          _log2_segment_size;
 
   size_t       _next_segment;
 
   FreeBlock*   _freelist;
+  FreeBlock*   _last_insert_point;               // last insert point in add_to_freelist
   size_t       _freelist_segments;               // No. of segments in freelist
   int          _freelist_length;
   size_t       _max_allocated_capacity;          // Peak capacity that was allocated during lifetime of the heap
 
   const char*  _name;                            // Name of the CodeHeap
   const int    _code_blob_type;                  // CodeBlobType it contains
   int          _blob_count;                      // Number of CodeBlobs
   int          _nmethod_count;                   // Number of nmethods
   int          _adapter_count;                   // Number of adapters
   int          _full_count;                      // Number of times the code heap was full
-
+  int          _fragmentation_count;             // #FreeBlock joins without fully initializing segment map elements.
 
   enum { free_sentinel = 0xFF };
+  static const int fragmentation_limit = 10000;  // defragment after that many potential fragmentations.
+  static const int freelist_limit = 100;         // improve insert point search if list is longer than this limit.
+  static char  segmap_template[free_sentinel+1];
 
   // Helper functions
   size_t   size_to_segments(size_t size) const { return (size + _segment_size - 1) >> _log2_segment_size; }
   size_t   segments_to_size(size_t number_of_segments) const { return number_of_segments << _log2_segment_size; }
 
   size_t   segment_for(void* p) const            { return ((char*)p - _memory.low()) >> _log2_segment_size; }
   bool     is_segment_unused(int val) const      { return val == free_sentinel; }
-  HeapBlock* block_at(size_t i) const            { return (HeapBlock*)(_memory.low() + (i << _log2_segment_size)); }
-
-  void  mark_segmap_as_free(size_t beg, size_t end);
-  void  mark_segmap_as_used(size_t beg, size_t end);
+  void*    address_for(size_t i) const           { return (void*)(_memory.low() + segments_to_size(i)); }
+  void*    find_block_for(void* p) const;
+  HeapBlock* block_at(size_t i) const            { return (HeapBlock*)address_for(i); }
+
+  // These methods take segment map indices as range boundaries
+  void mark_segmap_as_free(size_t beg, size_t end);
+  void mark_segmap_as_used(size_t beg, size_t end, bool is_FreeBlock_join);
+  void invalidate(size_t beg, size_t end, size_t header_bytes);
+  void clear(size_t beg, size_t end);
+  void clear();                                 // clears all heap contents
+  static void init_segmap_template();
 
   // Freelist management helpers
   FreeBlock* following_block(FreeBlock* b);
   void insert_after(FreeBlock* a, FreeBlock* b);
   bool merge_right (FreeBlock* a);
 
   // Toplevel freelist management
   void add_to_freelist(HeapBlock* b);
-  FreeBlock* search_freelist(size_t length);
+  HeapBlock* search_freelist(size_t length);
 
   // Iteration helpers
   void*      next_used(HeapBlock* b) const;
   HeapBlock* block_start(void* p) const;
 
   // to perform additional actions on creation of executable code
   void on_code_mapping(char* base, size_t size);
-  void clear();                                 // clears all heap contents
 
  public:
   CodeHeap(const char* name, const int code_blob_type);
 
   // Heap extents
@@ -150,16 +159,19 @@
   //            'p' was allocated. Only intended for freeing memory which would be otherwise
   //            wasted after the interpreter generation because we don't know the interpreter size
   //            beforehand and we also can't easily relocate the interpreter to a new location.
   void  deallocate_tail(void* p, size_t used_size);
 
-  // Attributes
-  char* low_boundary() const                     { return _memory.low_boundary(); }
+  // Boundaries of committed space.
+  char* low()  const                             { return _memory.low(); }
   char* high() const                             { return _memory.high(); }
+  // Boundaries of reserved space.
+  char* low_boundary() const                     { return _memory.low_boundary(); }
   char* high_boundary() const                    { return _memory.high_boundary(); }
 
-  bool contains(const void* p) const             { return low_boundary() <= p && p < high(); }
+  // Containment means "contained in committed space".
+  bool contains(const void* p) const             { return low() <= p && p < high(); }
   bool contains_blob(const CodeBlob* blob) const {
     // AOT CodeBlobs (i.e. AOTCompiledMethod) objects aren't allocated in the AOTCodeHeap but on the C-Heap.
     // Only the code they are pointing to is located in the AOTCodeHeap. All other CodeBlobs are allocated
     // directly in their corresponding CodeHeap with their code appended to the actual C++ object.
     // So all CodeBlobs except AOTCompiledMethod are continuous in memory with their data and code while
@@ -178,10 +190,11 @@
   static size_t header_size();                   // returns the header size for each heap block
 
   size_t segment_size()         const { return _segment_size; }  // for CodeHeapState
   HeapBlock* first_block() const;                                // for CodeHeapState
   HeapBlock* next_block(HeapBlock* b) const;                     // for CodeHeapState
+  HeapBlock* split_block(HeapBlock* b, size_t split_seg);        // split one block into two
 
   FreeBlock* freelist()         const { return _freelist; }      // for CodeHeapState
 
   size_t allocated_in_freelist() const           { return _freelist_segments * CodeCacheSegmentSize; }
   int    freelist_length()       const           { return _freelist_length; } // number of elements in the freelist
@@ -214,10 +227,12 @@
   int         full_count()                       { return _full_count; }
   void        report_full()                      {        _full_count++; }
 
 private:
   size_t heap_unallocated_capacity() const;
+  int defrag_segmap(bool do_defrag);
+  int segmap_hops(size_t beg, size_t end);
 
 public:
   // Debugging
   void verify() PRODUCT_RETURN;
   void print()  PRODUCT_RETURN;

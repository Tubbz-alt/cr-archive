<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/heapInspection.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="heap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="heapInspection.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/heapInspection.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/classLoaderData.inline.hpp&quot;
 27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
 28 #include &quot;classfile/moduleEntry.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;gc/shared/collectedHeap.hpp&quot;


 31 #include &quot;memory/heapInspection.hpp&quot;
 32 #include &quot;memory/resourceArea.hpp&quot;

 33 #include &quot;oops/oop.inline.hpp&quot;
 34 #include &quot;oops/reflectionAccessorImplKlassHelper.hpp&quot;
 35 #include &quot;runtime/os.hpp&quot;
 36 #include &quot;utilities/globalDefinitions.hpp&quot;
 37 #include &quot;utilities/macros.hpp&quot;
 38 #include &quot;utilities/stack.inline.hpp&quot;
 39 
 40 // HeapInspection
 41 
<span class="line-removed"> 42 int KlassSizeStats::count(oop x) {</span>
<span class="line-removed"> 43   return (HeapWordSize * (((x) != NULL) ? (x)-&gt;size() : 0));</span>
<span class="line-removed"> 44 }</span>
<span class="line-removed"> 45 </span>
<span class="line-removed"> 46 int KlassSizeStats::count_array(objArrayOop x) {</span>
<span class="line-removed"> 47   return (HeapWordSize * (((x) != NULL) ? (x)-&gt;size() : 0));</span>
<span class="line-removed"> 48 }</span>
<span class="line-removed"> 49 </span>
 50 inline KlassInfoEntry::~KlassInfoEntry() {
 51   if (_subclasses != NULL) {
 52     delete _subclasses;
 53   }
 54 }
 55 
 56 inline void KlassInfoEntry::add_subclass(KlassInfoEntry* cie) {
 57   if (_subclasses == NULL) {
 58     _subclasses = new  (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;KlassInfoEntry*&gt;(4, true);
 59   }
 60   _subclasses-&gt;append(cie);
 61 }
 62 
 63 int KlassInfoEntry::compare(KlassInfoEntry* e1, KlassInfoEntry* e2) {
 64   if(e1-&gt;_instance_words &gt; e2-&gt;_instance_words) {
 65     return -1;
 66   } else if(e1-&gt;_instance_words &lt; e2-&gt;_instance_words) {
 67     return 1;
 68   }
 69   // Sort alphabetically, note &#39;Z&#39; &lt; &#39;[&#39; &lt; &#39;a&#39;, but it&#39;s better to group
 70   // the array classes before all the instance classes.
 71   ResourceMark rm;
 72   const char* name1 = e1-&gt;klass()-&gt;external_name();
 73   const char* name2 = e2-&gt;klass()-&gt;external_name();
<span class="line-modified"> 74   bool d1 = (name1[0] == &#39;[&#39;);</span>
<span class="line-modified"> 75   bool d2 = (name2[0] == &#39;[&#39;);</span>
 76   if (d1 &amp;&amp; !d2) {
 77     return -1;
 78   } else if (d2 &amp;&amp; !d1) {
 79     return 1;
 80   } else {
 81     return strcmp(name1, name2);
 82   }
 83 }
 84 
 85 const char* KlassInfoEntry::name() const {
 86   const char* name;
 87   if (_klass-&gt;name() != NULL) {
 88     name = _klass-&gt;external_name();
 89   } else {
 90     if (_klass == Universe::boolArrayKlassObj())         name = &quot;&lt;boolArrayKlass&gt;&quot;;         else
 91     if (_klass == Universe::charArrayKlassObj())         name = &quot;&lt;charArrayKlass&gt;&quot;;         else
 92     if (_klass == Universe::floatArrayKlassObj())        name = &quot;&lt;floatArrayKlass&gt;&quot;;        else
 93     if (_klass == Universe::doubleArrayKlassObj())       name = &quot;&lt;doubleArrayKlass&gt;&quot;;       else
 94     if (_klass == Universe::byteArrayKlassObj())         name = &quot;&lt;byteArrayKlass&gt;&quot;;         else
 95     if (_klass == Universe::shortArrayKlassObj())        name = &quot;&lt;shortArrayKlass&gt;&quot;;        else
</pre>
<hr />
<pre>
104   ResourceMark rm;
105 
106   // simplify the formatting (ILP32 vs LP64) - always cast the numbers to 64-bit
107   ModuleEntry* module = _klass-&gt;module();
108   if (module-&gt;is_named()) {
109     st-&gt;print_cr(INT64_FORMAT_W(13) &quot;  &quot; UINT64_FORMAT_W(13) &quot;  %s (%s@%s)&quot;,
110                  (int64_t)_instance_count,
111                  (uint64_t)_instance_words * HeapWordSize,
112                  name(),
113                  module-&gt;name()-&gt;as_C_string(),
114                  module-&gt;version() != NULL ? module-&gt;version()-&gt;as_C_string() : &quot;&quot;);
115   } else {
116     st-&gt;print_cr(INT64_FORMAT_W(13) &quot;  &quot; UINT64_FORMAT_W(13) &quot;  %s&quot;,
117                  (int64_t)_instance_count,
118                  (uint64_t)_instance_words * HeapWordSize,
119                  name());
120   }
121 }
122 
123 KlassInfoEntry* KlassInfoBucket::lookup(Klass* const k) {





124   KlassInfoEntry* elt = _list;
125   while (elt != NULL) {
126     if (elt-&gt;is_equal(k)) {
127       return elt;
128     }
129     elt = elt-&gt;next();
130   }
131   elt = new (std::nothrow) KlassInfoEntry(k, list());
132   // We may be out of space to allocate the new entry.
133   if (elt != NULL) {
134     set_list(elt);
135   }
136   return elt;
137 }
138 
139 void KlassInfoBucket::iterate(KlassInfoClosure* cic) {
140   KlassInfoEntry* elt = _list;
141   while (elt != NULL) {
142     cic-&gt;do_cinfo(elt);
143     elt = elt-&gt;next();
</pre>
<hr />
<pre>
185 
186 KlassInfoTable::~KlassInfoTable() {
187   if (_buckets != NULL) {
188     for (int index = 0; index &lt; _num_buckets; index++) {
189       _buckets[index].empty();
190     }
191     FREE_C_HEAP_ARRAY(KlassInfoBucket, _buckets);
192     _buckets = NULL;
193   }
194 }
195 
196 uint KlassInfoTable::hash(const Klass* p) {
197   return (uint)(((uintptr_t)p - (uintptr_t)_ref) &gt;&gt; 2);
198 }
199 
200 KlassInfoEntry* KlassInfoTable::lookup(Klass* k) {
201   uint         idx = hash(k) % _num_buckets;
202   assert(_buckets != NULL, &quot;Allocation failure should have been caught&quot;);
203   KlassInfoEntry*  e   = _buckets[idx].lookup(k);
204   // Lookup may fail if this is a new klass for which we
<span class="line-modified">205   // could not allocate space for an new entry.</span>

206   assert(e == NULL || k == e-&gt;klass(), &quot;must be equal&quot;);
207   return e;
208 }
209 
210 // Return false if the entry could not be recorded on account
211 // of running out of space required to create a new entry.
212 bool KlassInfoTable::record_instance(const oop obj) {
213   Klass*        k = obj-&gt;klass();
214   KlassInfoEntry* elt = lookup(k);
215   // elt may be NULL if it&#39;s a new klass for which we
216   // could not allocate space for a new entry in the hashtable.
217   if (elt != NULL) {
218     elt-&gt;set_count(elt-&gt;count() + 1);
219     elt-&gt;set_words(elt-&gt;words() + obj-&gt;size());
220     _size_of_instances_in_words += obj-&gt;size();
221     return true;
222   } else {
223     return false;
224   }
225 }
</pre>
<hr />
<pre>
253 }
254 
255 void KlassInfoHisto::sort() {
256   elements()-&gt;sort(KlassInfoHisto::sort_helper);
257 }
258 
259 void KlassInfoHisto::print_elements(outputStream* st) const {
260   // simplify the formatting (ILP32 vs LP64) - store the sum in 64-bit
261   int64_t total = 0;
262   uint64_t totalw = 0;
263   for(int i=0; i &lt; elements()-&gt;length(); i++) {
264     st-&gt;print(&quot;%4d: &quot;, i+1);
265     elements()-&gt;at(i)-&gt;print_on(st);
266     total += elements()-&gt;at(i)-&gt;count();
267     totalw += elements()-&gt;at(i)-&gt;words();
268   }
269   st-&gt;print_cr(&quot;Total &quot; INT64_FORMAT_W(13) &quot;  &quot; UINT64_FORMAT_W(13),
270                total, totalw * HeapWordSize);
271 }
272 
<span class="line-removed">273 #define MAKE_COL_NAME(field, name, help)     #name,</span>
<span class="line-removed">274 #define MAKE_COL_HELP(field, name, help)     help,</span>
<span class="line-removed">275 </span>
<span class="line-removed">276 static const char *name_table[] = {</span>
<span class="line-removed">277   HEAP_INSPECTION_COLUMNS_DO(MAKE_COL_NAME)</span>
<span class="line-removed">278 };</span>
<span class="line-removed">279 </span>
<span class="line-removed">280 static const char *help_table[] = {</span>
<span class="line-removed">281   HEAP_INSPECTION_COLUMNS_DO(MAKE_COL_HELP)</span>
<span class="line-removed">282 };</span>
<span class="line-removed">283 </span>
<span class="line-removed">284 bool KlassInfoHisto::is_selected(const char *col_name) {</span>
<span class="line-removed">285   if (_selected_columns == NULL) {</span>
<span class="line-removed">286     return true;</span>
<span class="line-removed">287   }</span>
<span class="line-removed">288   if (strcmp(_selected_columns, col_name) == 0) {</span>
<span class="line-removed">289     return true;</span>
<span class="line-removed">290   }</span>
<span class="line-removed">291 </span>
<span class="line-removed">292   const char *start = strstr(_selected_columns, col_name);</span>
<span class="line-removed">293   if (start == NULL) {</span>
<span class="line-removed">294     return false;</span>
<span class="line-removed">295   }</span>
<span class="line-removed">296 </span>
<span class="line-removed">297   // The following must be true, because _selected_columns != col_name</span>
<span class="line-removed">298   if (start &gt; _selected_columns &amp;&amp; start[-1] != &#39;,&#39;) {</span>
<span class="line-removed">299     return false;</span>
<span class="line-removed">300   }</span>
<span class="line-removed">301   char x = start[strlen(col_name)];</span>
<span class="line-removed">302   if (x != &#39;,&#39; &amp;&amp; x != &#39;\0&#39;) {</span>
<span class="line-removed">303     return false;</span>
<span class="line-removed">304   }</span>
<span class="line-removed">305 </span>
<span class="line-removed">306   return true;</span>
<span class="line-removed">307 }</span>
<span class="line-removed">308 </span>
<span class="line-removed">309 void KlassInfoHisto::print_title(outputStream* st, bool csv_format,</span>
<span class="line-removed">310                                  bool selected[], int width_table[],</span>
<span class="line-removed">311                                  const char *name_table[]) {</span>
<span class="line-removed">312   if (csv_format) {</span>
<span class="line-removed">313     st-&gt;print(&quot;Index,Super&quot;);</span>
<span class="line-removed">314     for (int c=0; c&lt;KlassSizeStats::_num_columns; c++) {</span>
<span class="line-removed">315        if (selected[c]) {st-&gt;print(&quot;,%s&quot;, name_table[c]);}</span>
<span class="line-removed">316     }</span>
<span class="line-removed">317     st-&gt;print(&quot;,ClassName&quot;);</span>
<span class="line-removed">318   } else {</span>
<span class="line-removed">319     st-&gt;print(&quot;Index Super&quot;);</span>
<span class="line-removed">320     for (int c = 0; c &lt; KlassSizeStats::_num_columns; c++) {</span>
<span class="line-removed">321       if (selected[c]) {</span>
<span class="line-removed">322         st-&gt;print(&quot;%*s&quot;, width_table[c], name_table[c]);</span>
<span class="line-removed">323       }</span>
<span class="line-removed">324     }</span>
<span class="line-removed">325     st-&gt;print(&quot; ClassName&quot;);</span>
<span class="line-removed">326   }</span>
<span class="line-removed">327 </span>
<span class="line-removed">328   if (is_selected(&quot;ClassLoader&quot;)) {</span>
<span class="line-removed">329     st-&gt;print(&quot;,ClassLoader&quot;);</span>
<span class="line-removed">330   }</span>
<span class="line-removed">331   st-&gt;cr();</span>
<span class="line-removed">332 }</span>
<span class="line-removed">333 </span>
334 class HierarchyClosure : public KlassInfoClosure {
335 private:
336   GrowableArray&lt;KlassInfoEntry*&gt; *_elements;
337 public:
338   HierarchyClosure(GrowableArray&lt;KlassInfoEntry*&gt; *_elements) : _elements(_elements) {}
339 
340   void do_cinfo(KlassInfoEntry* cie) {
341     // ignore array classes
342     if (cie-&gt;klass()-&gt;is_instance_klass()) {
343       _elements-&gt;append(cie);
344     }
345   }
346 };
347 
348 void KlassHierarchy::print_class_hierarchy(outputStream* st, bool print_interfaces,
349                                            bool print_subclasses, char* classname) {
350   ResourceMark rm;
351   Stack &lt;KlassInfoEntry*, mtClass&gt; class_stack;
352   GrowableArray&lt;KlassInfoEntry*&gt; elements;
353 
</pre>
<hr />
<pre>
504   }
505   st-&gt;print(&quot;\n&quot;);
506 
507   // Print any interfaces the class has.
508   if (print_interfaces) {
509     Array&lt;InstanceKlass*&gt;* local_intfs = klass-&gt;local_interfaces();
510     Array&lt;InstanceKlass*&gt;* trans_intfs = klass-&gt;transitive_interfaces();
511     for (int i = 0; i &lt; local_intfs-&gt;length(); i++) {
512       print_interface(st, local_intfs-&gt;at(i), &quot;declared&quot;, indent);
513     }
514     for (int i = 0; i &lt; trans_intfs-&gt;length(); i++) {
515       InstanceKlass* trans_interface = trans_intfs-&gt;at(i);
516       // Only print transitive interfaces if they are not also declared.
517       if (!local_intfs-&gt;contains(trans_interface)) {
518         print_interface(st, trans_interface, &quot;inherited&quot;, indent);
519       }
520     }
521   }
522 }
523 
<span class="line-modified">524 void KlassInfoHisto::print_class_stats(outputStream* st,</span>
<span class="line-modified">525                                       bool csv_format, const char *columns) {</span>
<span class="line-modified">526   ResourceMark rm;</span>
<span class="line-modified">527   KlassSizeStats sz, sz_sum;</span>
<span class="line-removed">528   int i;</span>
<span class="line-removed">529   julong *col_table = (julong*)(&amp;sz);</span>
<span class="line-removed">530   julong *colsum_table = (julong*)(&amp;sz_sum);</span>
<span class="line-removed">531   int width_table[KlassSizeStats::_num_columns];</span>
<span class="line-removed">532   bool selected[KlassSizeStats::_num_columns];</span>
<span class="line-removed">533 </span>
<span class="line-removed">534   _selected_columns = columns;</span>
<span class="line-removed">535 </span>
<span class="line-removed">536   memset(&amp;sz_sum, 0, sizeof(sz_sum));</span>
<span class="line-removed">537   for (int c=0; c&lt;KlassSizeStats::_num_columns; c++) {</span>
<span class="line-removed">538     selected[c] = is_selected(name_table[c]);</span>
<span class="line-removed">539   }</span>
<span class="line-removed">540 </span>
<span class="line-removed">541   for(i=0; i &lt; elements()-&gt;length(); i++) {</span>
<span class="line-removed">542     elements()-&gt;at(i)-&gt;set_index(i+1);</span>
<span class="line-removed">543   }</span>
<span class="line-removed">544 </span>
<span class="line-removed">545   // First iteration is for accumulating stats totals in colsum_table[].</span>
<span class="line-removed">546   // Second iteration is for printing stats for each class.</span>
<span class="line-removed">547   for (int pass=1; pass&lt;=2; pass++) {</span>
<span class="line-removed">548     if (pass == 2) {</span>
<span class="line-removed">549       print_title(st, csv_format, selected, width_table, name_table);</span>
<span class="line-removed">550     }</span>
<span class="line-removed">551     for(i=0; i &lt; elements()-&gt;length(); i++) {</span>
<span class="line-removed">552       KlassInfoEntry* e = (KlassInfoEntry*)elements()-&gt;at(i);</span>
<span class="line-removed">553       const Klass* k = e-&gt;klass();</span>
<span class="line-removed">554 </span>
<span class="line-removed">555       // Get the stats for this class.</span>
<span class="line-removed">556       memset(&amp;sz, 0, sizeof(sz));</span>
<span class="line-removed">557       sz._inst_count = e-&gt;count();</span>
<span class="line-removed">558       sz._inst_bytes = HeapWordSize * e-&gt;words();</span>
<span class="line-removed">559       k-&gt;collect_statistics(&amp;sz);</span>
<span class="line-removed">560       sz._total_bytes = sz._ro_bytes + sz._rw_bytes;</span>
<span class="line-removed">561 </span>
<span class="line-removed">562       if (pass == 1) {</span>
<span class="line-removed">563         // Add the stats for this class to the overall totals.</span>
<span class="line-removed">564         for (int c=0; c&lt;KlassSizeStats::_num_columns; c++) {</span>
<span class="line-removed">565           colsum_table[c] += col_table[c];</span>
<span class="line-removed">566         }</span>
<span class="line-removed">567       } else {</span>
<span class="line-removed">568         int super_index = -1;</span>
<span class="line-removed">569         // Print the stats for this class.</span>
<span class="line-removed">570         if (k-&gt;is_instance_klass()) {</span>
<span class="line-removed">571           Klass* super = k-&gt;super();</span>
<span class="line-removed">572           if (super) {</span>
<span class="line-removed">573             KlassInfoEntry* super_e = _cit-&gt;lookup(super);</span>
<span class="line-removed">574             if (super_e) {</span>
<span class="line-removed">575               super_index = super_e-&gt;index();</span>
<span class="line-removed">576             }</span>
<span class="line-removed">577           }</span>
<span class="line-removed">578         }</span>
<span class="line-removed">579 </span>
<span class="line-removed">580         if (csv_format) {</span>
<span class="line-removed">581           st-&gt;print(&quot;%ld,%d&quot;, e-&gt;index(), super_index);</span>
<span class="line-removed">582           for (int c=0; c&lt;KlassSizeStats::_num_columns; c++) {</span>
<span class="line-removed">583             if (selected[c]) {st-&gt;print(&quot;,&quot; JULONG_FORMAT, col_table[c]);}</span>
<span class="line-removed">584           }</span>
<span class="line-removed">585           st-&gt;print(&quot;,%s&quot;,e-&gt;name());</span>
<span class="line-removed">586         } else {</span>
<span class="line-removed">587           st-&gt;print(&quot;%5ld %5d&quot;, e-&gt;index(), super_index);</span>
<span class="line-removed">588           for (int c=0; c&lt;KlassSizeStats::_num_columns; c++) {</span>
<span class="line-removed">589             if (selected[c]) {print_julong(st, width_table[c], col_table[c]);}</span>
<span class="line-removed">590           }</span>
<span class="line-removed">591           st-&gt;print(&quot; %s&quot;, e-&gt;name());</span>
<span class="line-removed">592         }</span>
<span class="line-removed">593         if (is_selected(&quot;ClassLoader&quot;)) {</span>
<span class="line-removed">594           ClassLoaderData* loader_data = k-&gt;class_loader_data();</span>
<span class="line-removed">595           st-&gt;print(&quot;,&quot;);</span>
<span class="line-removed">596           loader_data-&gt;print_value_on(st);</span>
<span class="line-removed">597         }</span>
<span class="line-removed">598         st-&gt;cr();</span>
<span class="line-removed">599       }</span>
<span class="line-removed">600     }</span>
<span class="line-removed">601 </span>
<span class="line-removed">602     if (pass == 1) {</span>
<span class="line-removed">603       // Calculate the minimum width needed for the column by accounting for the</span>
<span class="line-removed">604       // column header width and the width of the largest value in the column.</span>
<span class="line-removed">605       for (int c=0; c&lt;KlassSizeStats::_num_columns; c++) {</span>
<span class="line-removed">606         width_table[c] = col_width(colsum_table[c], name_table[c]);</span>
<span class="line-removed">607       }</span>
<span class="line-removed">608     }</span>
<span class="line-removed">609   }</span>
<span class="line-removed">610 </span>
<span class="line-removed">611   sz_sum._inst_size = 0;</span>
<span class="line-removed">612 </span>
<span class="line-removed">613   // Print the column totals.</span>
<span class="line-removed">614   if (csv_format) {</span>
<span class="line-removed">615     st-&gt;print(&quot;,&quot;);</span>
<span class="line-removed">616     for (int c=0; c&lt;KlassSizeStats::_num_columns; c++) {</span>
<span class="line-removed">617       if (selected[c]) {st-&gt;print(&quot;,&quot; JULONG_FORMAT, colsum_table[c]);}</span>
<span class="line-removed">618     }</span>
<span class="line-removed">619   } else {</span>
<span class="line-removed">620     st-&gt;print(&quot;           &quot;);</span>
<span class="line-removed">621     for (int c=0; c&lt;KlassSizeStats::_num_columns; c++) {</span>
<span class="line-removed">622       if (selected[c]) {print_julong(st, width_table[c], colsum_table[c]);}</span>
<span class="line-removed">623     }</span>
<span class="line-removed">624     st-&gt;print(&quot; Total&quot;);</span>
<span class="line-removed">625     if (sz_sum._total_bytes &gt; 0) {</span>
<span class="line-removed">626       st-&gt;cr();</span>
<span class="line-removed">627       st-&gt;print(&quot;           &quot;);</span>
<span class="line-removed">628       for (int c=0; c&lt;KlassSizeStats::_num_columns; c++) {</span>
<span class="line-removed">629         if (selected[c]) {</span>
<span class="line-removed">630           switch (c) {</span>
<span class="line-removed">631           case KlassSizeStats::_index_inst_size:</span>
<span class="line-removed">632           case KlassSizeStats::_index_inst_count:</span>
<span class="line-removed">633           case KlassSizeStats::_index_method_count:</span>
<span class="line-removed">634             st-&gt;print(&quot;%*s&quot;, width_table[c], &quot;-&quot;);</span>
<span class="line-removed">635             break;</span>
<span class="line-removed">636           default:</span>
<span class="line-removed">637             {</span>
<span class="line-removed">638               double perc = (double)(100) * (double)(colsum_table[c]) / (double)sz_sum._total_bytes;</span>
<span class="line-removed">639               st-&gt;print(&quot;%*.1f%%&quot;, width_table[c]-1, perc);</span>
<span class="line-removed">640             }</span>
<span class="line-removed">641           }</span>
<span class="line-removed">642         }</span>
<span class="line-removed">643       }</span>
<span class="line-removed">644     }</span>
<span class="line-removed">645   }</span>
<span class="line-removed">646   st-&gt;cr();</span>
<span class="line-removed">647 </span>
<span class="line-removed">648   if (!csv_format) {</span>
<span class="line-removed">649     print_title(st, csv_format, selected, width_table, name_table);</span>
<span class="line-removed">650   }</span>
<span class="line-removed">651 }</span>
<span class="line-removed">652 </span>
<span class="line-removed">653 julong KlassInfoHisto::annotations_bytes(Array&lt;AnnotationArray*&gt;* p) const {</span>
<span class="line-removed">654   julong bytes = 0;</span>
<span class="line-removed">655   if (p != NULL) {</span>
<span class="line-removed">656     for (int i = 0; i &lt; p-&gt;length(); i++) {</span>
<span class="line-removed">657       bytes += count_bytes_array(p-&gt;at(i));</span>
<span class="line-removed">658     }</span>
<span class="line-removed">659     bytes += count_bytes_array(p);</span>
<span class="line-removed">660   }</span>
<span class="line-removed">661   return bytes;</span>
<span class="line-removed">662 }</span>
<span class="line-removed">663 </span>
<span class="line-removed">664 void KlassInfoHisto::print_histo_on(outputStream* st, bool print_stats,</span>
<span class="line-removed">665                                     bool csv_format, const char *columns) {</span>
<span class="line-removed">666   if (print_stats) {</span>
<span class="line-removed">667     print_class_stats(st, csv_format, columns);</span>
<span class="line-removed">668   } else {</span>
<span class="line-removed">669     st-&gt;print_cr(&quot; num     #instances         #bytes  class name (module)&quot;);</span>
<span class="line-removed">670     st-&gt;print_cr(&quot;-------------------------------------------------------&quot;);</span>
<span class="line-removed">671     print_elements(st);</span>
<span class="line-removed">672   }</span>
673 }
674 
675 class HistoClosure : public KlassInfoClosure {
676  private:
677   KlassInfoHisto* _cih;
678  public:
679   HistoClosure(KlassInfoHisto* cih) : _cih(cih) {}
680 
681   void do_cinfo(KlassInfoEntry* cie) {
682     _cih-&gt;add(cie);
683   }
684 };
685 
686 class RecordInstanceClosure : public ObjectClosure {
687  private:
688   KlassInfoTable* _cit;
689   size_t _missed_count;
690   BoolObjectClosure* _filter;
691  public:
692   RecordInstanceClosure(KlassInfoTable* cit, BoolObjectClosure* filter) :
</pre>
<hr />
<pre>
702 
703   size_t missed_count() { return _missed_count; }
704 
705  private:
706   bool should_visit(oop obj) {
707     return _filter == NULL || _filter-&gt;do_object_b(obj);
708   }
709 };
710 
711 size_t HeapInspection::populate_table(KlassInfoTable* cit, BoolObjectClosure *filter) {
712   ResourceMark rm;
713 
714   RecordInstanceClosure ric(cit, filter);
715   Universe::heap()-&gt;object_iterate(&amp;ric);
716   return ric.missed_count();
717 }
718 
719 void HeapInspection::heap_inspection(outputStream* st) {
720   ResourceMark rm;
721 
<span class="line-modified">722   if (_print_help) {</span>
<span class="line-removed">723     for (int c=0; c&lt;KlassSizeStats::_num_columns; c++) {</span>
<span class="line-removed">724       st-&gt;print(&quot;%s:\n\t&quot;, name_table[c]);</span>
<span class="line-removed">725       const int max_col = 60;</span>
<span class="line-removed">726       int col = 0;</span>
<span class="line-removed">727       for (const char *p = help_table[c]; *p; p++,col++) {</span>
<span class="line-removed">728         if (col &gt;= max_col &amp;&amp; *p == &#39; &#39;) {</span>
<span class="line-removed">729           st-&gt;print(&quot;\n\t&quot;);</span>
<span class="line-removed">730           col = 0;</span>
<span class="line-removed">731         } else {</span>
<span class="line-removed">732           st-&gt;print(&quot;%c&quot;, *p);</span>
<span class="line-removed">733         }</span>
<span class="line-removed">734       }</span>
<span class="line-removed">735       st-&gt;print_cr(&quot;.\n&quot;);</span>
<span class="line-removed">736     }</span>
<span class="line-removed">737     return;</span>
<span class="line-removed">738   }</span>
<span class="line-removed">739 </span>
<span class="line-removed">740   KlassInfoTable cit(_print_class_stats);</span>
741   if (!cit.allocation_failed()) {
742     // populate table with object allocation info
743     size_t missed_count = populate_table(&amp;cit);
744     if (missed_count != 0) {
<span class="line-modified">745       st-&gt;print_cr(&quot;WARNING: Ran out of C-heap; undercounted &quot; SIZE_FORMAT</span>
<span class="line-modified">746                    &quot; total instances in data below&quot;,</span>
<span class="line-modified">747                    missed_count);</span>
748     }
749 
750     // Sort and print klass instance info
751     KlassInfoHisto histo(&amp;cit);
752     HistoClosure hc(&amp;histo);
753 
754     cit.iterate(&amp;hc);
755 
756     histo.sort();
<span class="line-modified">757     histo.print_histo_on(st, _print_class_stats, _csv_format, _columns);</span>
758   } else {
759     st-&gt;print_cr(&quot;ERROR: Ran out of C-heap; histogram not generated&quot;);
760   }
761   st-&gt;flush();
762 }
763 
764 class FindInstanceClosure : public ObjectClosure {
765  private:
766   Klass* _klass;
767   GrowableArray&lt;oop&gt;* _result;
768 
769  public:
770   FindInstanceClosure(Klass* k, GrowableArray&lt;oop&gt;* result) : _klass(k), _result(result) {};
771 
772   void do_object(oop obj) {
773     if (obj-&gt;is_a(_klass)) {




774       _result-&gt;append(obj);
775     }
776   }
777 };
778 
779 void HeapInspection::find_instances_at_safepoint(Klass* k, GrowableArray&lt;oop&gt;* result) {
780   assert(SafepointSynchronize::is_at_safepoint(), &quot;all threads are stopped&quot;);
781   assert(Heap_lock-&gt;is_locked(), &quot;should have the Heap_lock&quot;);
782 
783   // Ensure that the heap is parsable
784   Universe::heap()-&gt;ensure_parsability(false);  // no need to retire TALBs
785 
786   // Iterate over objects in the heap
787   FindInstanceClosure fic(k, result);
<span class="line-removed">788   // If this operation encounters a bad object when using CMS,</span>
<span class="line-removed">789   // consider using safe_object_iterate() which avoids metadata</span>
<span class="line-removed">790   // objects that may contain bad references.</span>
791   Universe::heap()-&gt;object_iterate(&amp;fic);
792 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/classLoaderData.inline.hpp&quot;
 27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
 28 #include &quot;classfile/moduleEntry.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;gc/shared/collectedHeap.hpp&quot;
<span class="line-added"> 31 #include &quot;logging/log.hpp&quot;</span>
<span class="line-added"> 32 #include &quot;logging/logTag.hpp&quot;</span>
 33 #include &quot;memory/heapInspection.hpp&quot;
 34 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added"> 35 #include &quot;memory/universe.hpp&quot;</span>
 36 #include &quot;oops/oop.inline.hpp&quot;
 37 #include &quot;oops/reflectionAccessorImplKlassHelper.hpp&quot;
 38 #include &quot;runtime/os.hpp&quot;
 39 #include &quot;utilities/globalDefinitions.hpp&quot;
 40 #include &quot;utilities/macros.hpp&quot;
 41 #include &quot;utilities/stack.inline.hpp&quot;
 42 
 43 // HeapInspection
 44 








 45 inline KlassInfoEntry::~KlassInfoEntry() {
 46   if (_subclasses != NULL) {
 47     delete _subclasses;
 48   }
 49 }
 50 
 51 inline void KlassInfoEntry::add_subclass(KlassInfoEntry* cie) {
 52   if (_subclasses == NULL) {
 53     _subclasses = new  (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;KlassInfoEntry*&gt;(4, true);
 54   }
 55   _subclasses-&gt;append(cie);
 56 }
 57 
 58 int KlassInfoEntry::compare(KlassInfoEntry* e1, KlassInfoEntry* e2) {
 59   if(e1-&gt;_instance_words &gt; e2-&gt;_instance_words) {
 60     return -1;
 61   } else if(e1-&gt;_instance_words &lt; e2-&gt;_instance_words) {
 62     return 1;
 63   }
 64   // Sort alphabetically, note &#39;Z&#39; &lt; &#39;[&#39; &lt; &#39;a&#39;, but it&#39;s better to group
 65   // the array classes before all the instance classes.
 66   ResourceMark rm;
 67   const char* name1 = e1-&gt;klass()-&gt;external_name();
 68   const char* name2 = e2-&gt;klass()-&gt;external_name();
<span class="line-modified"> 69   bool d1 = (name1[0] == JVM_SIGNATURE_ARRAY);</span>
<span class="line-modified"> 70   bool d2 = (name2[0] == JVM_SIGNATURE_ARRAY);</span>
 71   if (d1 &amp;&amp; !d2) {
 72     return -1;
 73   } else if (d2 &amp;&amp; !d1) {
 74     return 1;
 75   } else {
 76     return strcmp(name1, name2);
 77   }
 78 }
 79 
 80 const char* KlassInfoEntry::name() const {
 81   const char* name;
 82   if (_klass-&gt;name() != NULL) {
 83     name = _klass-&gt;external_name();
 84   } else {
 85     if (_klass == Universe::boolArrayKlassObj())         name = &quot;&lt;boolArrayKlass&gt;&quot;;         else
 86     if (_klass == Universe::charArrayKlassObj())         name = &quot;&lt;charArrayKlass&gt;&quot;;         else
 87     if (_klass == Universe::floatArrayKlassObj())        name = &quot;&lt;floatArrayKlass&gt;&quot;;        else
 88     if (_klass == Universe::doubleArrayKlassObj())       name = &quot;&lt;doubleArrayKlass&gt;&quot;;       else
 89     if (_klass == Universe::byteArrayKlassObj())         name = &quot;&lt;byteArrayKlass&gt;&quot;;         else
 90     if (_klass == Universe::shortArrayKlassObj())        name = &quot;&lt;shortArrayKlass&gt;&quot;;        else
</pre>
<hr />
<pre>
 99   ResourceMark rm;
100 
101   // simplify the formatting (ILP32 vs LP64) - always cast the numbers to 64-bit
102   ModuleEntry* module = _klass-&gt;module();
103   if (module-&gt;is_named()) {
104     st-&gt;print_cr(INT64_FORMAT_W(13) &quot;  &quot; UINT64_FORMAT_W(13) &quot;  %s (%s@%s)&quot;,
105                  (int64_t)_instance_count,
106                  (uint64_t)_instance_words * HeapWordSize,
107                  name(),
108                  module-&gt;name()-&gt;as_C_string(),
109                  module-&gt;version() != NULL ? module-&gt;version()-&gt;as_C_string() : &quot;&quot;);
110   } else {
111     st-&gt;print_cr(INT64_FORMAT_W(13) &quot;  &quot; UINT64_FORMAT_W(13) &quot;  %s&quot;,
112                  (int64_t)_instance_count,
113                  (uint64_t)_instance_words * HeapWordSize,
114                  name());
115   }
116 }
117 
118 KlassInfoEntry* KlassInfoBucket::lookup(Klass* const k) {
<span class="line-added">119   // Can happen if k is an archived class that we haven&#39;t loaded yet.</span>
<span class="line-added">120   if (k-&gt;java_mirror_no_keepalive() == NULL) {</span>
<span class="line-added">121     return NULL;</span>
<span class="line-added">122   }</span>
<span class="line-added">123 </span>
124   KlassInfoEntry* elt = _list;
125   while (elt != NULL) {
126     if (elt-&gt;is_equal(k)) {
127       return elt;
128     }
129     elt = elt-&gt;next();
130   }
131   elt = new (std::nothrow) KlassInfoEntry(k, list());
132   // We may be out of space to allocate the new entry.
133   if (elt != NULL) {
134     set_list(elt);
135   }
136   return elt;
137 }
138 
139 void KlassInfoBucket::iterate(KlassInfoClosure* cic) {
140   KlassInfoEntry* elt = _list;
141   while (elt != NULL) {
142     cic-&gt;do_cinfo(elt);
143     elt = elt-&gt;next();
</pre>
<hr />
<pre>
185 
186 KlassInfoTable::~KlassInfoTable() {
187   if (_buckets != NULL) {
188     for (int index = 0; index &lt; _num_buckets; index++) {
189       _buckets[index].empty();
190     }
191     FREE_C_HEAP_ARRAY(KlassInfoBucket, _buckets);
192     _buckets = NULL;
193   }
194 }
195 
196 uint KlassInfoTable::hash(const Klass* p) {
197   return (uint)(((uintptr_t)p - (uintptr_t)_ref) &gt;&gt; 2);
198 }
199 
200 KlassInfoEntry* KlassInfoTable::lookup(Klass* k) {
201   uint         idx = hash(k) % _num_buckets;
202   assert(_buckets != NULL, &quot;Allocation failure should have been caught&quot;);
203   KlassInfoEntry*  e   = _buckets[idx].lookup(k);
204   // Lookup may fail if this is a new klass for which we
<span class="line-modified">205   // could not allocate space for an new entry, or if it&#39;s</span>
<span class="line-added">206   // an archived class that we haven&#39;t loaded yet.</span>
207   assert(e == NULL || k == e-&gt;klass(), &quot;must be equal&quot;);
208   return e;
209 }
210 
211 // Return false if the entry could not be recorded on account
212 // of running out of space required to create a new entry.
213 bool KlassInfoTable::record_instance(const oop obj) {
214   Klass*        k = obj-&gt;klass();
215   KlassInfoEntry* elt = lookup(k);
216   // elt may be NULL if it&#39;s a new klass for which we
217   // could not allocate space for a new entry in the hashtable.
218   if (elt != NULL) {
219     elt-&gt;set_count(elt-&gt;count() + 1);
220     elt-&gt;set_words(elt-&gt;words() + obj-&gt;size());
221     _size_of_instances_in_words += obj-&gt;size();
222     return true;
223   } else {
224     return false;
225   }
226 }
</pre>
<hr />
<pre>
254 }
255 
256 void KlassInfoHisto::sort() {
257   elements()-&gt;sort(KlassInfoHisto::sort_helper);
258 }
259 
260 void KlassInfoHisto::print_elements(outputStream* st) const {
261   // simplify the formatting (ILP32 vs LP64) - store the sum in 64-bit
262   int64_t total = 0;
263   uint64_t totalw = 0;
264   for(int i=0; i &lt; elements()-&gt;length(); i++) {
265     st-&gt;print(&quot;%4d: &quot;, i+1);
266     elements()-&gt;at(i)-&gt;print_on(st);
267     total += elements()-&gt;at(i)-&gt;count();
268     totalw += elements()-&gt;at(i)-&gt;words();
269   }
270   st-&gt;print_cr(&quot;Total &quot; INT64_FORMAT_W(13) &quot;  &quot; UINT64_FORMAT_W(13),
271                total, totalw * HeapWordSize);
272 }
273 





























































274 class HierarchyClosure : public KlassInfoClosure {
275 private:
276   GrowableArray&lt;KlassInfoEntry*&gt; *_elements;
277 public:
278   HierarchyClosure(GrowableArray&lt;KlassInfoEntry*&gt; *_elements) : _elements(_elements) {}
279 
280   void do_cinfo(KlassInfoEntry* cie) {
281     // ignore array classes
282     if (cie-&gt;klass()-&gt;is_instance_klass()) {
283       _elements-&gt;append(cie);
284     }
285   }
286 };
287 
288 void KlassHierarchy::print_class_hierarchy(outputStream* st, bool print_interfaces,
289                                            bool print_subclasses, char* classname) {
290   ResourceMark rm;
291   Stack &lt;KlassInfoEntry*, mtClass&gt; class_stack;
292   GrowableArray&lt;KlassInfoEntry*&gt; elements;
293 
</pre>
<hr />
<pre>
444   }
445   st-&gt;print(&quot;\n&quot;);
446 
447   // Print any interfaces the class has.
448   if (print_interfaces) {
449     Array&lt;InstanceKlass*&gt;* local_intfs = klass-&gt;local_interfaces();
450     Array&lt;InstanceKlass*&gt;* trans_intfs = klass-&gt;transitive_interfaces();
451     for (int i = 0; i &lt; local_intfs-&gt;length(); i++) {
452       print_interface(st, local_intfs-&gt;at(i), &quot;declared&quot;, indent);
453     }
454     for (int i = 0; i &lt; trans_intfs-&gt;length(); i++) {
455       InstanceKlass* trans_interface = trans_intfs-&gt;at(i);
456       // Only print transitive interfaces if they are not also declared.
457       if (!local_intfs-&gt;contains(trans_interface)) {
458         print_interface(st, trans_interface, &quot;inherited&quot;, indent);
459       }
460     }
461   }
462 }
463 
<span class="line-modified">464 void KlassInfoHisto::print_histo_on(outputStream* st) {</span>
<span class="line-modified">465   st-&gt;print_cr(&quot; num     #instances         #bytes  class name (module)&quot;);</span>
<span class="line-modified">466   st-&gt;print_cr(&quot;-------------------------------------------------------&quot;);</span>
<span class="line-modified">467   print_elements(st);</span>

















































































































































468 }
469 
470 class HistoClosure : public KlassInfoClosure {
471  private:
472   KlassInfoHisto* _cih;
473  public:
474   HistoClosure(KlassInfoHisto* cih) : _cih(cih) {}
475 
476   void do_cinfo(KlassInfoEntry* cie) {
477     _cih-&gt;add(cie);
478   }
479 };
480 
481 class RecordInstanceClosure : public ObjectClosure {
482  private:
483   KlassInfoTable* _cit;
484   size_t _missed_count;
485   BoolObjectClosure* _filter;
486  public:
487   RecordInstanceClosure(KlassInfoTable* cit, BoolObjectClosure* filter) :
</pre>
<hr />
<pre>
497 
498   size_t missed_count() { return _missed_count; }
499 
500  private:
501   bool should_visit(oop obj) {
502     return _filter == NULL || _filter-&gt;do_object_b(obj);
503   }
504 };
505 
506 size_t HeapInspection::populate_table(KlassInfoTable* cit, BoolObjectClosure *filter) {
507   ResourceMark rm;
508 
509   RecordInstanceClosure ric(cit, filter);
510   Universe::heap()-&gt;object_iterate(&amp;ric);
511   return ric.missed_count();
512 }
513 
514 void HeapInspection::heap_inspection(outputStream* st) {
515   ResourceMark rm;
516 
<span class="line-modified">517   KlassInfoTable cit(false);</span>


















518   if (!cit.allocation_failed()) {
519     // populate table with object allocation info
520     size_t missed_count = populate_table(&amp;cit);
521     if (missed_count != 0) {
<span class="line-modified">522       log_info(gc, classhisto)(&quot;WARNING: Ran out of C-heap; undercounted &quot; SIZE_FORMAT</span>
<span class="line-modified">523                                &quot; total instances in data below&quot;,</span>
<span class="line-modified">524                                missed_count);</span>
525     }
526 
527     // Sort and print klass instance info
528     KlassInfoHisto histo(&amp;cit);
529     HistoClosure hc(&amp;histo);
530 
531     cit.iterate(&amp;hc);
532 
533     histo.sort();
<span class="line-modified">534     histo.print_histo_on(st);</span>
535   } else {
536     st-&gt;print_cr(&quot;ERROR: Ran out of C-heap; histogram not generated&quot;);
537   }
538   st-&gt;flush();
539 }
540 
541 class FindInstanceClosure : public ObjectClosure {
542  private:
543   Klass* _klass;
544   GrowableArray&lt;oop&gt;* _result;
545 
546  public:
547   FindInstanceClosure(Klass* k, GrowableArray&lt;oop&gt;* result) : _klass(k), _result(result) {};
548 
549   void do_object(oop obj) {
550     if (obj-&gt;is_a(_klass)) {
<span class="line-added">551       // obj was read with AS_NO_KEEPALIVE, or equivalent.</span>
<span class="line-added">552       // The object needs to be kept alive when it is published.</span>
<span class="line-added">553       Universe::heap()-&gt;keep_alive(obj);</span>
<span class="line-added">554 </span>
555       _result-&gt;append(obj);
556     }
557   }
558 };
559 
560 void HeapInspection::find_instances_at_safepoint(Klass* k, GrowableArray&lt;oop&gt;* result) {
561   assert(SafepointSynchronize::is_at_safepoint(), &quot;all threads are stopped&quot;);
562   assert(Heap_lock-&gt;is_locked(), &quot;should have the Heap_lock&quot;);
563 
564   // Ensure that the heap is parsable
565   Universe::heap()-&gt;ensure_parsability(false);  // no need to retire TALBs
566 
567   // Iterate over objects in the heap
568   FindInstanceClosure fic(k, result);



569   Universe::heap()-&gt;object_iterate(&amp;fic);
570 }
</pre>
</td>
</tr>
</table>
<center><a href="heap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="heapInspection.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
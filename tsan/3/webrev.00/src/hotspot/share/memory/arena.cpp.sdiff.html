<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/arena.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="allocation.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="arena.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/arena.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;memory/allocation.hpp&quot;
 27 #include &quot;memory/allocation.inline.hpp&quot;
 28 #include &quot;memory/metaspaceShared.hpp&quot;
 29 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-removed"> 30 #include &quot;memory/universe.hpp&quot;</span>
<span class="line-removed"> 31 #include &quot;runtime/atomic.hpp&quot;</span>
 32 #include &quot;runtime/os.hpp&quot;
 33 #include &quot;runtime/task.hpp&quot;
 34 #include &quot;runtime/threadCritical.hpp&quot;
 35 #include &quot;services/memTracker.hpp&quot;
 36 #include &quot;utilities/ostream.hpp&quot;
 37 
 38 //--------------------------------------------------------------------------------------
 39 // ChunkPool implementation
 40 
 41 // MT-safe pool of chunks to reduce malloc/free thrashing
 42 // NB: not using Mutex because pools are used before Threads are initialized
 43 class ChunkPool: public CHeapObj&lt;mtInternal&gt; {
 44   Chunk*       _first;        // first cached Chunk; its first word points to next chunk
 45   size_t       _num_chunks;   // number of unused chunks in pool
 46   size_t       _num_used;     // number of chunks currently checked out
 47   const size_t _size;         // size of each chunk (must be uniform)
 48 
 49   // Our four static pools
 50   static ChunkPool* _large_pool;
 51   static ChunkPool* _medium_pool;
</pre>
<hr />
<pre>
309   FreeHeap(p);
310 }
311 
312 // Destroy this arenas contents and reset to empty
313 void Arena::destruct_contents() {
314   if (UseMallocOnly &amp;&amp; _first != NULL) {
315     char* end = _first-&gt;next() ? _first-&gt;top() : _hwm;
316     free_malloced_objects(_first, _first-&gt;bottom(), end, _hwm);
317   }
318   // reset size before chop to avoid a rare racing condition
319   // that can have total arena memory exceed total chunk memory
320   set_size_in_bytes(0);
321   _first-&gt;chop();
322   reset();
323 }
324 
325 // This is high traffic method, but many calls actually don&#39;t
326 // change the size
327 void Arena::set_size_in_bytes(size_t size) {
328   if (_size_in_bytes != size) {
<span class="line-modified">329     long delta = (long)(size - size_in_bytes());</span>
330     _size_in_bytes = size;
331     MemTracker::record_arena_size_change(delta, _flags);
332   }
333 }
334 
335 // Total of all Chunks in arena
336 size_t Arena::used() const {
337   size_t sum = _chunk-&gt;length() - (_max-_hwm); // Size leftover in this Chunk
338   Chunk *k = _first;
339   while( k != _chunk) {         // Whilst have Chunks in a row
340     sum += k-&gt;length();         // Total size of this Chunk
341     k = k-&gt;next();              // Bump along to next Chunk
342   }
343   return sum;                   // Return total consumed space.
344 }
345 
346 void Arena::signal_out_of_memory(size_t sz, const char* whence) const {
347   vm_exit_out_of_memory(sz, OOM_MALLOC_ERROR, &quot;%s&quot;, whence);
348 }
349 
</pre>
<hr />
<pre>
459 // for debugging with UseMallocOnly
460 void* Arena::internal_malloc_4(size_t x) {
461   assert( (x&amp;(sizeof(char*)-1)) == 0, &quot;misaligned size&quot; );
462   check_for_overflow(x, &quot;Arena::internal_malloc_4&quot;);
463   if (_hwm + x &gt; _max) {
464     return grow(x);
465   } else {
466     char *old = _hwm;
467     _hwm += x;
468     return old;
469   }
470 }
471 #endif
472 
473 
474 //--------------------------------------------------------------------------------------
475 // Non-product code
476 
477 #ifndef PRODUCT
478 
<span class="line-removed">479 julong Arena::_bytes_allocated = 0;</span>
<span class="line-removed">480 </span>
<span class="line-removed">481 void Arena::inc_bytes_allocated(size_t x) { inc_stat_counter(&amp;_bytes_allocated, x); }</span>
<span class="line-removed">482 </span>
483 // debugging code
484 inline void Arena::free_all(char** start, char** end) {
485   for (char** p = start; p &lt; end; p++) if (*p) os::free(*p);
486 }
487 
488 void Arena::free_malloced_objects(Chunk* chunk, char* hwm, char* max, char* hwm2) {
489   assert(UseMallocOnly, &quot;should not call&quot;);
490   // free all objects malloced since resource mark was created; resource area
491   // contains their addresses
492   if (chunk-&gt;next()) {
493     // this chunk is full, and some others too
494     for (Chunk* c = chunk-&gt;next(); c != NULL; c = c-&gt;next()) {
495       char* top = c-&gt;top();
496       if (c-&gt;next() == NULL) {
497         top = hwm2;     // last junk is only used up to hwm2
498         assert(c-&gt;contains(hwm2), &quot;bad hwm2&quot;);
499       }
500       free_all((char**)c-&gt;bottom(), (char**)top);
501     }
502     assert(chunk-&gt;contains(hwm), &quot;bad hwm&quot;);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;memory/allocation.hpp&quot;
 27 #include &quot;memory/allocation.inline.hpp&quot;
 28 #include &quot;memory/metaspaceShared.hpp&quot;
 29 #include &quot;memory/resourceArea.hpp&quot;


 30 #include &quot;runtime/os.hpp&quot;
 31 #include &quot;runtime/task.hpp&quot;
 32 #include &quot;runtime/threadCritical.hpp&quot;
 33 #include &quot;services/memTracker.hpp&quot;
 34 #include &quot;utilities/ostream.hpp&quot;
 35 
 36 //--------------------------------------------------------------------------------------
 37 // ChunkPool implementation
 38 
 39 // MT-safe pool of chunks to reduce malloc/free thrashing
 40 // NB: not using Mutex because pools are used before Threads are initialized
 41 class ChunkPool: public CHeapObj&lt;mtInternal&gt; {
 42   Chunk*       _first;        // first cached Chunk; its first word points to next chunk
 43   size_t       _num_chunks;   // number of unused chunks in pool
 44   size_t       _num_used;     // number of chunks currently checked out
 45   const size_t _size;         // size of each chunk (must be uniform)
 46 
 47   // Our four static pools
 48   static ChunkPool* _large_pool;
 49   static ChunkPool* _medium_pool;
</pre>
<hr />
<pre>
307   FreeHeap(p);
308 }
309 
310 // Destroy this arenas contents and reset to empty
311 void Arena::destruct_contents() {
312   if (UseMallocOnly &amp;&amp; _first != NULL) {
313     char* end = _first-&gt;next() ? _first-&gt;top() : _hwm;
314     free_malloced_objects(_first, _first-&gt;bottom(), end, _hwm);
315   }
316   // reset size before chop to avoid a rare racing condition
317   // that can have total arena memory exceed total chunk memory
318   set_size_in_bytes(0);
319   _first-&gt;chop();
320   reset();
321 }
322 
323 // This is high traffic method, but many calls actually don&#39;t
324 // change the size
325 void Arena::set_size_in_bytes(size_t size) {
326   if (_size_in_bytes != size) {
<span class="line-modified">327     ssize_t delta = size - size_in_bytes();</span>
328     _size_in_bytes = size;
329     MemTracker::record_arena_size_change(delta, _flags);
330   }
331 }
332 
333 // Total of all Chunks in arena
334 size_t Arena::used() const {
335   size_t sum = _chunk-&gt;length() - (_max-_hwm); // Size leftover in this Chunk
336   Chunk *k = _first;
337   while( k != _chunk) {         // Whilst have Chunks in a row
338     sum += k-&gt;length();         // Total size of this Chunk
339     k = k-&gt;next();              // Bump along to next Chunk
340   }
341   return sum;                   // Return total consumed space.
342 }
343 
344 void Arena::signal_out_of_memory(size_t sz, const char* whence) const {
345   vm_exit_out_of_memory(sz, OOM_MALLOC_ERROR, &quot;%s&quot;, whence);
346 }
347 
</pre>
<hr />
<pre>
457 // for debugging with UseMallocOnly
458 void* Arena::internal_malloc_4(size_t x) {
459   assert( (x&amp;(sizeof(char*)-1)) == 0, &quot;misaligned size&quot; );
460   check_for_overflow(x, &quot;Arena::internal_malloc_4&quot;);
461   if (_hwm + x &gt; _max) {
462     return grow(x);
463   } else {
464     char *old = _hwm;
465     _hwm += x;
466     return old;
467   }
468 }
469 #endif
470 
471 
472 //--------------------------------------------------------------------------------------
473 // Non-product code
474 
475 #ifndef PRODUCT
476 




477 // debugging code
478 inline void Arena::free_all(char** start, char** end) {
479   for (char** p = start; p &lt; end; p++) if (*p) os::free(*p);
480 }
481 
482 void Arena::free_malloced_objects(Chunk* chunk, char* hwm, char* max, char* hwm2) {
483   assert(UseMallocOnly, &quot;should not call&quot;);
484   // free all objects malloced since resource mark was created; resource area
485   // contains their addresses
486   if (chunk-&gt;next()) {
487     // this chunk is full, and some others too
488     for (Chunk* c = chunk-&gt;next(); c != NULL; c = c-&gt;next()) {
489       char* top = c-&gt;top();
490       if (c-&gt;next() == NULL) {
491         top = hwm2;     // last junk is only used up to hwm2
492         assert(c-&gt;contains(hwm2), &quot;bad hwm2&quot;);
493       }
494       free_all((char**)c-&gt;bottom(), (char**)top);
495     }
496     assert(chunk-&gt;contains(hwm), &quot;bad hwm&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="allocation.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="arena.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
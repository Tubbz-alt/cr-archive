<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/memory/filemap.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="arena.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="filemap.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/filemap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -22,25 +22,31 @@</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;jvm.h&quot;
<span class="udiff-line-added">+ #include &quot;classfile/classFileStream.hpp&quot;</span>
  #include &quot;classfile/classLoader.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;classfile/classLoaderData.inline.hpp&quot;</span>
  #include &quot;classfile/classLoaderExt.hpp&quot;
  #include &quot;classfile/symbolTable.hpp&quot;
  #include &quot;classfile/systemDictionaryShared.hpp&quot;
  #include &quot;classfile/altHashing.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;logging/logMessage.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/archiveUtils.inline.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;memory/dynamicArchive.hpp&quot;</span>
  #include &quot;memory/filemap.hpp&quot;
  #include &quot;memory/heapShared.inline.hpp&quot;
  #include &quot;memory/iterator.inline.hpp&quot;
  #include &quot;memory/metadataFactory.hpp&quot;
  #include &quot;memory/metaspaceClosure.hpp&quot;
  #include &quot;memory/metaspaceShared.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/universe.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;oops/compressedOops.hpp&quot;</span>
  #include &quot;oops/compressedOops.inline.hpp&quot;
  #include &quot;oops/objArrayOop.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;prims/jvmtiExport.hpp&quot;
  #include &quot;runtime/arguments.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -48,10 +54,12 @@</span>
  #include &quot;runtime/mutexLocker.hpp&quot;
  #include &quot;runtime/os.inline.hpp&quot;
  #include &quot;runtime/vm_version.hpp&quot;
  #include &quot;services/memTracker.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
<span class="udiff-line-added">+ #include &quot;utilities/bitMap.inline.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;utilities/classpathStream.hpp&quot;</span>
  #include &quot;utilities/defaultStream.hpp&quot;
  #if INCLUDE_G1GC
  #include &quot;gc/g1/g1CollectedHeap.hpp&quot;
  #include &quot;gc/g1/heapRegion.hpp&quot;
  #endif
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -61,18 +69,15 @@</span>
  
  #ifndef O_BINARY       // if defined (Win32) use binary files.
  #define O_BINARY 0     // otherwise do nothing.
  #endif
  
<span class="udiff-line-removed">- extern address JVM_FunctionAtStart();</span>
<span class="udiff-line-removed">- extern address JVM_FunctionAtEnd();</span>
<span class="udiff-line-removed">- </span>
  // Complain and stop. All error conditions occurring during the writing of
  // an archive file should stop the process.  Unrecoverable errors during
  // the reading of the archive file should stop the process.
  
<span class="udiff-line-modified-removed">- static void fail(const char *msg, va_list ap) {</span>
<span class="udiff-line-modified-added">+ static void fail_exit(const char *msg, va_list ap) {</span>
    // This occurs very early during initialization: tty is not initialized.
    jio_fprintf(defaultStream::error_stream(),
                &quot;An error has occurred while processing the&quot;
                &quot; shared archive file.\n&quot;);
    jio_vfprintf(defaultStream::error_stream(), msg, ap);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -83,11 +88,11 @@</span>
  
  
  void FileMapInfo::fail_stop(const char *msg, ...) {
          va_list ap;
    va_start(ap, msg);
<span class="udiff-line-modified-removed">-   fail(msg, ap);        // Never returns.</span>
<span class="udiff-line-modified-added">+   fail_exit(msg, ap);   // Never returns.</span>
    va_end(ap);           // for completeness.
  }
  
  
  // Complain and continue.  Recoverable errors during the reading of the
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -96,32 +101,28 @@</span>
  // If we continue, then disable shared spaces and close the file.
  
  void FileMapInfo::fail_continue(const char *msg, ...) {
    va_list ap;
    va_start(ap, msg);
<span class="udiff-line-removed">-   MetaspaceShared::set_archive_loading_failed();</span>
    if (PrintSharedArchiveAndExit &amp;&amp; _validating_shared_path_table) {
      // If we are doing PrintSharedArchiveAndExit and some of the classpath entries
      // do not validate, we can still continue &quot;limping&quot; to validate the remaining
      // entries. No need to quit.
      tty-&gt;print(&quot;[&quot;);
      tty-&gt;vprint(msg, ap);
      tty-&gt;print_cr(&quot;]&quot;);
    } else {
      if (RequireSharedSpaces) {
<span class="udiff-line-modified-removed">-       fail(msg, ap);</span>
<span class="udiff-line-modified-added">+       fail_exit(msg, ap);</span>
      } else {
        if (log_is_enabled(Info, cds)) {
          ResourceMark rm;
          LogStream ls(Log(cds)::info());
          ls.print(&quot;UseSharedSpaces: &quot;);
          ls.vprint_cr(msg, ap);
        }
      }
<span class="udiff-line-removed">-     UseSharedSpaces = false;</span>
<span class="udiff-line-removed">-     assert(current_info() != NULL, &quot;singleton must be registered&quot;);</span>
<span class="udiff-line-removed">-     current_info()-&gt;close();</span>
    }
    va_end(ap);
  }
  
  // Fill in the fileMapInfo structure with data about this VM instance.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -137,10 +138,12 @@</span>
    assert(N == JVM_IDENT_MAX, &quot;Bad header_version size&quot;);
  
    const char *vm_version = VM_Version::internal_vm_info_string();
    const int version_len = (int)strlen(vm_version);
  
<span class="udiff-line-added">+   memset(header_version, 0, JVM_IDENT_MAX);</span>
<span class="udiff-line-added">+ </span>
    if (version_len &lt; (JVM_IDENT_MAX-1)) {
      strcpy(header_version, vm_version);
  
    } else {
      // Get the hash value.  Use a static seed because the hash needs to return the same
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -152,118 +155,163 @@</span>
  
      // Append the hash code as eight hex digits.
      sprintf(&amp;header_version[JVM_IDENT_MAX-9], &quot;%08x&quot;, hash);
      header_version[JVM_IDENT_MAX-1] = 0;  // Null terminate.
    }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   assert(header_version[JVM_IDENT_MAX-1] == 0, &quot;must be&quot;);</span>
  }
  
<span class="udiff-line-modified-removed">- FileMapInfo::FileMapInfo() {</span>
<span class="udiff-line-removed">-   assert(_current_info == NULL, &quot;must be singleton&quot;); // not thread safe</span>
<span class="udiff-line-removed">-   _current_info = this;</span>
<span class="udiff-line-modified-added">+ FileMapInfo::FileMapInfo(bool is_static) {</span>
    memset((void*)this, 0, sizeof(FileMapInfo));
<span class="udiff-line-added">+   _is_static = is_static;</span>
<span class="udiff-line-added">+   size_t header_size;</span>
<span class="udiff-line-added">+   if (is_static) {</span>
<span class="udiff-line-added">+     assert(_current_info == NULL, &quot;must be singleton&quot;); // not thread safe</span>
<span class="udiff-line-added">+     _current_info = this;</span>
<span class="udiff-line-added">+     header_size = sizeof(FileMapHeader);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     assert(_dynamic_archive_info == NULL, &quot;must be singleton&quot;); // not thread safe</span>
<span class="udiff-line-added">+     _dynamic_archive_info = this;</span>
<span class="udiff-line-added">+     header_size = sizeof(DynamicArchiveHeader);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   _header = (FileMapHeader*)os::malloc(header_size, mtInternal);</span>
<span class="udiff-line-added">+   memset((void*)_header, 0, header_size);</span>
<span class="udiff-line-added">+   _header-&gt;set_header_size(header_size);</span>
<span class="udiff-line-added">+   _header-&gt;set_version(INVALID_CDS_ARCHIVE_VERSION);</span>
<span class="udiff-line-added">+   _header-&gt;set_has_platform_or_app_classes(true);</span>
    _file_offset = 0;
    _file_open = false;
<span class="udiff-line-removed">-   _header = (FileMapHeader*)os::malloc(sizeof(FileMapHeader), mtInternal);</span>
<span class="udiff-line-removed">-   _header-&gt;_version = INVALID_CDS_ARCHIVE_VERSION;</span>
<span class="udiff-line-removed">-   _header-&gt;_has_platform_or_app_classes = true;</span>
  }
  
  FileMapInfo::~FileMapInfo() {
<span class="udiff-line-modified-removed">-   assert(_current_info == this, &quot;must be singleton&quot;); // not thread safe</span>
<span class="udiff-line-modified-removed">-   _current_info = NULL;</span>
<span class="udiff-line-modified-added">+   if (_is_static) {</span>
<span class="udiff-line-modified-added">+     assert(_current_info == this, &quot;must be singleton&quot;); // not thread safe</span>
<span class="udiff-line-added">+     _current_info = NULL;</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     assert(_dynamic_archive_info == this, &quot;must be singleton&quot;); // not thread safe</span>
<span class="udiff-line-added">+     _dynamic_archive_info = NULL;</span>
<span class="udiff-line-added">+   }</span>
  }
  
  void FileMapInfo::populate_header(size_t alignment) {
<span class="udiff-line-modified-removed">-   _header-&gt;populate(this, alignment);</span>
<span class="udiff-line-modified-added">+   header()-&gt;populate(this, alignment);</span>
  }
  
  void FileMapHeader::populate(FileMapInfo* mapinfo, size_t alignment) {
<span class="udiff-line-modified-removed">-   _magic = CDS_ARCHIVE_MAGIC;</span>
<span class="udiff-line-modified-added">+   if (DynamicDumpSharedSpaces) {</span>
<span class="udiff-line-added">+     _magic = CDS_DYNAMIC_ARCHIVE_MAGIC;</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     _magic = CDS_ARCHIVE_MAGIC;</span>
<span class="udiff-line-added">+   }</span>
    _version = CURRENT_CDS_ARCHIVE_VERSION;
    _alignment = alignment;
    _obj_alignment = ObjectAlignmentInBytes;
    _compact_strings = CompactStrings;
<span class="udiff-line-modified-removed">-   _narrow_oop_mode = Universe::narrow_oop_mode();</span>
<span class="udiff-line-modified-removed">-   _narrow_oop_base = Universe::narrow_oop_base();</span>
<span class="udiff-line-modified-removed">-   _narrow_oop_shift = Universe::narrow_oop_shift();</span>
<span class="udiff-line-modified-added">+   _narrow_oop_mode = CompressedOops::mode();</span>
<span class="udiff-line-modified-added">+   _narrow_oop_base = CompressedOops::base();</span>
<span class="udiff-line-modified-added">+   _narrow_oop_shift = CompressedOops::shift();</span>
<span class="udiff-line-added">+   _compressed_oops = UseCompressedOops;</span>
<span class="udiff-line-added">+   _compressed_class_ptrs = UseCompressedClassPointers;</span>
    _max_heap_size = MaxHeapSize;
<span class="udiff-line-modified-removed">-   _narrow_klass_base = Universe::narrow_klass_base();</span>
<span class="udiff-line-removed">-   _narrow_klass_shift = Universe::narrow_klass_shift();</span>
<span class="udiff-line-removed">-   _shared_path_table_size = mapinfo-&gt;_shared_path_table_size;</span>
<span class="udiff-line-removed">-   _shared_path_table = mapinfo-&gt;_shared_path_table;</span>
<span class="udiff-line-removed">-   _shared_path_entry_size = mapinfo-&gt;_shared_path_entry_size;</span>
<span class="udiff-line-modified-added">+   _narrow_klass_shift = CompressedKlassPointers::shift();</span>
    if (HeapShared::is_heap_object_archiving_allowed()) {
<span class="udiff-line-modified-removed">-     _heap_reserved = Universe::heap()-&gt;reserved_region();</span>
<span class="udiff-line-modified-added">+     _heap_end = CompressedOops::end();</span>
    }
  
    // The following fields are for sanity checks for whether this archive
    // will function correctly with this JVM and the bootclasspath it&#39;s
    // invoked with.
  
    // JVM version string ... changes on each build.
    get_header_version(_jvm_ident);
  
<span class="udiff-line-removed">-   ClassLoaderExt::finalize_shared_paths_misc_info();</span>
    _app_class_paths_start_index = ClassLoaderExt::app_class_paths_start_index();
    _app_module_paths_start_index = ClassLoaderExt::app_module_paths_start_index();
<span class="udiff-line-added">+   _num_module_paths = ClassLoader::num_module_path_entries();</span>
    _max_used_path_index = ClassLoaderExt::max_used_path_index();
  
    _verify_local = BytecodeVerificationLocal;
    _verify_remote = BytecodeVerificationRemote;
    _has_platform_or_app_classes = ClassLoaderExt::has_platform_or_app_classes();
<span class="udiff-line-modified-removed">-   _shared_base_address = SharedBaseAddress;</span>
<span class="udiff-line-modified-added">+   _requested_base_address = (char*)SharedBaseAddress;</span>
<span class="udiff-line-added">+   _mapped_base_address = (char*)SharedBaseAddress;</span>
    _allow_archiving_with_java_agent = AllowArchivingWithJavaAgent;
<span class="udiff-line-added">+   // the following 2 fields will be set in write_header for dynamic archive header</span>
<span class="udiff-line-added">+   _base_archive_name_size = 0;</span>
<span class="udiff-line-added">+   _base_archive_is_default = false;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (!DynamicDumpSharedSpaces) {</span>
<span class="udiff-line-added">+     set_shared_path_table(mapinfo-&gt;_shared_path_table);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void SharedClassPathEntry::init_as_non_existent(const char* path, TRAPS) {</span>
<span class="udiff-line-added">+   _type = non_existent_entry;</span>
<span class="udiff-line-added">+   set_name(path, THREAD);</span>
  }
  
<span class="udiff-line-modified-removed">- void SharedClassPathEntry::init(const char* name, bool is_modules_image, TRAPS) {</span>
<span class="udiff-line-modified-removed">-   assert(DumpSharedSpaces, &quot;dump time only&quot;);</span>
<span class="udiff-line-modified-added">+ void SharedClassPathEntry::init(bool is_modules_image,</span>
<span class="udiff-line-modified-added">+                                 ClassPathEntry* cpe, TRAPS) {</span>
<span class="udiff-line-added">+   Arguments::assert_is_dumping_archive();</span>
    _timestamp = 0;
    _filesize  = 0;
<span class="udiff-line-added">+   _from_class_path_attr = false;</span>
  
    struct stat st;
<span class="udiff-line-modified-removed">-   if (os::stat(name, &amp;st) == 0) {</span>
<span class="udiff-line-modified-added">+   if (os::stat(cpe-&gt;name(), &amp;st) == 0) {</span>
      if ((st.st_mode &amp; S_IFMT) == S_IFDIR) {
        _type = dir_entry;
      } else {
        // The timestamp of the modules_image is not checked at runtime.
        if (is_modules_image) {
          _type = modules_image_entry;
        } else {
          _type = jar_entry;
          _timestamp = st.st_mtime;
<span class="udiff-line-added">+         _from_class_path_attr = cpe-&gt;from_class_path_attr();</span>
        }
        _filesize = st.st_size;
      }
    } else {
      // The file/dir must exist, or it would not have been added
      // into ClassLoader::classpath_entry().
      //
      // If we can&#39;t access a jar file in the boot path, then we can&#39;t
      // make assumptions about where classes get loaded from.
<span class="udiff-line-modified-removed">-     FileMapInfo::fail_stop(&quot;Unable to open file %s.&quot;, name);</span>
<span class="udiff-line-modified-added">+     FileMapInfo::fail_stop(&quot;Unable to open file %s.&quot;, cpe-&gt;name());</span>
    }
  
<span class="udiff-line-added">+   // No need to save the name of the module file, as it will be computed at run time</span>
<span class="udiff-line-added">+   // to allow relocation of the JDK directory.</span>
<span class="udiff-line-added">+   const char* name = is_modules_image  ? &quot;&quot; : cpe-&gt;name();</span>
<span class="udiff-line-added">+   set_name(name, THREAD);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void SharedClassPathEntry::set_name(const char* name, TRAPS) {</span>
    size_t len = strlen(name) + 1;
    _name = MetadataFactory::new_array&lt;char&gt;(ClassLoaderData::the_null_class_loader_data(), (int)len, THREAD);
    strcpy(_name-&gt;data(), name);
  }
  
<span class="udiff-line-modified-removed">- bool SharedClassPathEntry::validate(bool is_class_path) {</span>
<span class="udiff-line-modified-added">+ const char* SharedClassPathEntry::name() const {</span>
<span class="udiff-line-added">+   if (UseSharedSpaces &amp;&amp; is_modules_image()) {</span>
<span class="udiff-line-added">+     // In order to validate the runtime modules image file size against the archived</span>
<span class="udiff-line-added">+     // size information, we need to obtain the runtime modules image path. The recorded</span>
<span class="udiff-line-added">+     // dump time modules image path in the archive may be different from the runtime path</span>
<span class="udiff-line-added">+     // if the JDK image has beed moved after generating the archive.</span>
<span class="udiff-line-added">+     return ClassLoader::get_jrt_entry()-&gt;name();</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     return _name-&gt;data();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool SharedClassPathEntry::validate(bool is_class_path) const {</span>
    assert(UseSharedSpaces, &quot;runtime only&quot;);
  
    struct stat st;
<span class="udiff-line-modified-removed">-   const char* name;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // In order to validate the runtime modules image file size against the archived</span>
<span class="udiff-line-removed">-   // size information, we need to obtain the runtime modules image path. The recorded</span>
<span class="udiff-line-removed">-   // dump time modules image path in the archive may be different from the runtime path</span>
<span class="udiff-line-removed">-   // if the JDK image has beed moved after generating the archive.</span>
<span class="udiff-line-removed">-   if (is_modules_image()) {</span>
<span class="udiff-line-removed">-     name = ClassLoader::get_jrt_entry()-&gt;name();</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     name = this-&gt;name();</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   const char* name = this-&gt;name();</span>
  
    bool ok = true;
    log_info(class, path)(&quot;checking shared classpath entry: %s&quot;, name);
    if (os::stat(name, &amp;st) != 0 &amp;&amp; is_class_path) {
      // If the archived module path entry does not exist at runtime, it is not fatal
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -292,112 +340,145 @@</span>
  
    if (PrintSharedArchiveAndExit &amp;&amp; !ok) {
      // If PrintSharedArchiveAndExit is enabled, don&#39;t report failure to the
      // caller. Please see above comments for more details.
      ok = true;
<span class="udiff-line-added">+     MetaspaceShared::set_archive_loading_failed();</span>
    }
    return ok;
  }
  
<span class="udiff-line-added">+ bool SharedClassPathEntry::check_non_existent() const {</span>
<span class="udiff-line-added">+   assert(_type == non_existent_entry, &quot;must be&quot;);</span>
<span class="udiff-line-added">+   log_info(class, path)(&quot;should be non-existent: %s&quot;, name());</span>
<span class="udiff-line-added">+   struct stat st;</span>
<span class="udiff-line-added">+   if (os::stat(name(), &amp;st) != 0) {</span>
<span class="udiff-line-added">+     log_info(class, path)(&quot;ok&quot;);</span>
<span class="udiff-line-added">+     return true; // file doesn&#39;t exist</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
  void SharedClassPathEntry::metaspace_pointers_do(MetaspaceClosure* it) {
    it-&gt;push(&amp;_name);
    it-&gt;push(&amp;_manifest);
  }
  
<span class="udiff-line-added">+ void SharedPathTable::metaspace_pointers_do(MetaspaceClosure* it) {</span>
<span class="udiff-line-added">+   it-&gt;push(&amp;_table);</span>
<span class="udiff-line-added">+   for (int i=0; i&lt;_size; i++) {</span>
<span class="udiff-line-added">+     path_at(i)-&gt;metaspace_pointers_do(it);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void SharedPathTable::dumptime_init(ClassLoaderData* loader_data, Thread* THREAD) {</span>
<span class="udiff-line-added">+   size_t entry_size = sizeof(SharedClassPathEntry);</span>
<span class="udiff-line-added">+   int num_entries = 0;</span>
<span class="udiff-line-added">+   num_entries += ClassLoader::num_boot_classpath_entries();</span>
<span class="udiff-line-added">+   num_entries += ClassLoader::num_app_classpath_entries();</span>
<span class="udiff-line-added">+   num_entries += ClassLoader::num_module_path_entries();</span>
<span class="udiff-line-added">+   num_entries += FileMapInfo::num_non_existent_class_paths();</span>
<span class="udiff-line-added">+   size_t bytes = entry_size * num_entries;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   _table = MetadataFactory::new_array&lt;u8&gt;(loader_data, (int)(bytes + 7 / 8), THREAD);</span>
<span class="udiff-line-added">+   _size = num_entries;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void FileMapInfo::allocate_shared_path_table() {
<span class="udiff-line-modified-removed">-   assert(DumpSharedSpaces, &quot;Sanity&quot;);</span>
<span class="udiff-line-modified-added">+   Arguments::assert_is_dumping_archive();</span>
  
<span class="udiff-line-modified-removed">-   Thread* THREAD = Thread::current();</span>
<span class="udiff-line-modified-added">+   EXCEPTION_MARK; // The following calls should never throw, but would exit VM on error.</span>
    ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
    ClassPathEntry* jrt = ClassLoader::get_jrt_entry();
  
    assert(jrt != NULL,
           &quot;No modular java runtime image present when allocating the CDS classpath entry table&quot;);
  
<span class="udiff-line-modified-removed">-   size_t entry_size = sizeof(SharedClassPathEntry); // assert ( should be 8 byte aligned??)</span>
<span class="udiff-line-removed">-   int num_boot_classpath_entries = ClassLoader::num_boot_classpath_entries();</span>
<span class="udiff-line-removed">-   int num_app_classpath_entries = ClassLoader::num_app_classpath_entries();</span>
<span class="udiff-line-removed">-   int num_module_path_entries = ClassLoader::num_module_path_entries();</span>
<span class="udiff-line-removed">-   int num_entries = num_boot_classpath_entries + num_app_classpath_entries + num_module_path_entries;</span>
<span class="udiff-line-removed">-   size_t bytes = entry_size * num_entries;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   _shared_path_table = MetadataFactory::new_array&lt;u8&gt;(loader_data, (int)(bytes + 7 / 8), THREAD);</span>
<span class="udiff-line-removed">-   _shared_path_table_size = num_entries;</span>
<span class="udiff-line-removed">-   _shared_path_entry_size = entry_size;</span>
<span class="udiff-line-modified-added">+   _shared_path_table.dumptime_init(loader_data, THREAD);</span>
  
    // 1. boot class path
    int i = 0;
<span class="udiff-line-modified-removed">-   ClassPathEntry* cpe = jrt;</span>
<span class="udiff-line-modified-added">+   i = add_shared_classpaths(i, &quot;boot&quot;,   jrt, THREAD);</span>
<span class="udiff-line-added">+   i = add_shared_classpaths(i, &quot;app&quot;,    ClassLoader::app_classpath_entries(), THREAD);</span>
<span class="udiff-line-added">+   i = add_shared_classpaths(i, &quot;module&quot;, ClassLoader::module_path_entries(), THREAD);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   for (int x = 0; x &lt; num_non_existent_class_paths(); x++, i++) {</span>
<span class="udiff-line-added">+     const char* path = _non_existent_class_paths-&gt;at(x);</span>
<span class="udiff-line-added">+     shared_path(i)-&gt;init_as_non_existent(path, THREAD);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   assert(i == _shared_path_table.size(), &quot;number of shared path entry mismatch&quot;);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ int FileMapInfo::add_shared_classpaths(int i, const char* which, ClassPathEntry *cpe, TRAPS) {</span>
    while (cpe != NULL) {
<span class="udiff-line-modified-removed">-     bool is_jrt = (cpe == jrt);</span>
<span class="udiff-line-modified-added">+     bool is_jrt = (cpe == ClassLoader::get_jrt_entry());</span>
      const char* type = (is_jrt ? &quot;jrt&quot; : (cpe-&gt;is_jar_file() ? &quot;jar&quot; : &quot;dir&quot;));
<span class="udiff-line-modified-removed">-     log_info(class, path)(&quot;add main shared path (%s) %s&quot;, type, cpe-&gt;name());</span>
<span class="udiff-line-modified-added">+     log_info(class, path)(&quot;add %s shared path (%s) %s&quot;, which, type, cpe-&gt;name());</span>
      SharedClassPathEntry* ent = shared_path(i);
<span class="udiff-line-modified-removed">-     ent-&gt;init(cpe-&gt;name(), is_jrt, THREAD);</span>
<span class="udiff-line-modified-removed">-     if (!is_jrt) {    // No need to do the modules image.</span>
<span class="udiff-line-modified-removed">-       EXCEPTION_MARK; // The following call should never throw, but would exit VM on error.</span>
<span class="udiff-line-modified-removed">-       update_shared_classpath(cpe, ent, THREAD);</span>
<span class="udiff-line-modified-added">+     ent-&gt;init(is_jrt, cpe, THREAD);</span>
<span class="udiff-line-modified-added">+     if (cpe-&gt;is_jar_file()) {</span>
<span class="udiff-line-modified-added">+       update_jar_manifest(cpe, ent, THREAD);</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-added">+     if (is_jrt) {</span>
<span class="udiff-line-added">+       cpe = ClassLoader::get_next_boot_classpath_entry(cpe);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       cpe = cpe-&gt;next();</span>
      }
<span class="udiff-line-removed">-     cpe = ClassLoader::get_next_boot_classpath_entry(cpe);</span>
<span class="udiff-line-removed">-     i++;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   assert(i == num_boot_classpath_entries,</span>
<span class="udiff-line-removed">-          &quot;number of boot class path entry mismatch&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // 2. app class path</span>
<span class="udiff-line-removed">-   ClassPathEntry *acpe = ClassLoader::app_classpath_entries();</span>
<span class="udiff-line-removed">-   while (acpe != NULL) {</span>
<span class="udiff-line-removed">-     log_info(class, path)(&quot;add app shared path %s&quot;, acpe-&gt;name());</span>
<span class="udiff-line-removed">-     SharedClassPathEntry* ent = shared_path(i);</span>
<span class="udiff-line-removed">-     ent-&gt;init(acpe-&gt;name(), false, THREAD);</span>
<span class="udiff-line-removed">-     EXCEPTION_MARK;</span>
<span class="udiff-line-removed">-     update_shared_classpath(acpe, ent, THREAD);</span>
<span class="udiff-line-removed">-     acpe = acpe-&gt;next();</span>
      i++;
    }
  
<span class="udiff-line-modified-removed">-   // 3. module path</span>
<span class="udiff-line-removed">-   ClassPathEntry *mpe = ClassLoader::module_path_entries();</span>
<span class="udiff-line-removed">-   while (mpe != NULL) {</span>
<span class="udiff-line-removed">-     log_info(class, path)(&quot;add module path %s&quot;,mpe-&gt;name());</span>
<span class="udiff-line-removed">-     SharedClassPathEntry* ent = shared_path(i);</span>
<span class="udiff-line-removed">-     ent-&gt;init(mpe-&gt;name(), false, THREAD);</span>
<span class="udiff-line-removed">-     EXCEPTION_MARK;</span>
<span class="udiff-line-removed">-     update_shared_classpath(mpe, ent, THREAD);</span>
<span class="udiff-line-removed">-     mpe = mpe-&gt;next();</span>
<span class="udiff-line-removed">-     i++;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   assert(i == num_entries, &quot;number of shared path entry mismatch&quot;);</span>
<span class="udiff-line-modified-added">+   return i;</span>
  }
  
  void FileMapInfo::check_nonempty_dir_in_shared_path_table() {
<span class="udiff-line-modified-removed">-   assert(DumpSharedSpaces, &quot;dump time only&quot;);</span>
<span class="udiff-line-modified-added">+   Arguments::assert_is_dumping_archive();</span>
  
    bool has_nonempty_dir = false;
  
<span class="udiff-line-modified-removed">-   int last = _shared_path_table_size - 1;</span>
<span class="udiff-line-modified-added">+   int last = _shared_path_table.size() - 1;</span>
    if (last &gt; ClassLoaderExt::max_used_path_index()) {
       // no need to check any path beyond max_used_path_index
       last = ClassLoaderExt::max_used_path_index();
    }
  
    for (int i = 0; i &lt;= last; i++) {
      SharedClassPathEntry *e = shared_path(i);
      if (e-&gt;is_dir()) {
        const char* path = e-&gt;name();
        if (!os::dir_is_empty(path)) {
<span class="udiff-line-modified-removed">-         tty-&gt;print_cr(&quot;Error: non-empty directory &#39;%s&#39;&quot;, path);</span>
<span class="udiff-line-modified-added">+         log_error(cds)(&quot;Error: non-empty directory &#39;%s&#39;&quot;, path);</span>
          has_nonempty_dir = true;
        }
      }
    }
  
    if (has_nonempty_dir) {
      ClassLoader::exit_with_path_failure(&quot;Cannot have non-empty directory in paths&quot;, NULL);
    }
  }
  
<span class="udiff-line-added">+ void FileMapInfo::record_non_existent_class_path_entry(const char* path) {</span>
<span class="udiff-line-added">+   Arguments::assert_is_dumping_archive();</span>
<span class="udiff-line-added">+   log_info(class, path)(&quot;non-existent Class-Path entry %s&quot;, path);</span>
<span class="udiff-line-added">+   if (_non_existent_class_paths == NULL) {</span>
<span class="udiff-line-added">+     _non_existent_class_paths = new (ResourceObj::C_HEAP, mtInternal)GrowableArray&lt;const char*&gt;(10, true);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   _non_existent_class_paths-&gt;append(os::strdup(path));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ int FileMapInfo::num_non_existent_class_paths() {</span>
<span class="udiff-line-added">+   Arguments::assert_is_dumping_archive();</span>
<span class="udiff-line-added">+   if (_non_existent_class_paths != NULL) {</span>
<span class="udiff-line-added">+     return _non_existent_class_paths-&gt;length();</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     return 0;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  class ManifestStream: public ResourceObj {
    private:
    u1*   _buffer_start; // Buffer bottom
    u1*   _buffer_end;   // Buffer top (one past last element)
    u1*   _current;      // Current buffer position
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -442,132 +523,527 @@</span>
      }
      return isSigned;
    }
  };
  
<span class="udiff-line-modified-removed">- void FileMapInfo::update_shared_classpath(ClassPathEntry *cpe, SharedClassPathEntry* ent, TRAPS) {</span>
<span class="udiff-line-modified-added">+ void FileMapInfo::update_jar_manifest(ClassPathEntry *cpe, SharedClassPathEntry* ent, TRAPS) {</span>
    ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
    ResourceMark rm(THREAD);
    jint manifest_size;
  
<span class="udiff-line-modified-removed">-   if (cpe-&gt;is_jar_file()) {</span>
<span class="udiff-line-modified-removed">-     assert(ent-&gt;is_jar(), &quot;the shared class path entry is not a JAR file&quot;);</span>
<span class="udiff-line-modified-removed">-     char* manifest = ClassLoaderExt::read_manifest(cpe, &amp;manifest_size, CHECK);</span>
<span class="udiff-line-modified-removed">-     if (manifest != NULL) {</span>
<span class="udiff-line-modified-removed">-       ManifestStream* stream = new ManifestStream((u1*)manifest,</span>
<span class="udiff-line-modified-removed">-                                                   manifest_size);</span>
<span class="udiff-line-modified-removed">-       if (stream-&gt;check_is_signed()) {</span>
<span class="udiff-line-modified-removed">-         ent-&gt;set_is_signed();</span>
<span class="udiff-line-modified-added">+   assert(cpe-&gt;is_jar_file() &amp;&amp; ent-&gt;is_jar(), &quot;the shared class path entry is not a JAR file&quot;);</span>
<span class="udiff-line-modified-added">+   char* manifest = ClassLoaderExt::read_manifest(cpe, &amp;manifest_size, CHECK);</span>
<span class="udiff-line-modified-added">+   if (manifest != NULL) {</span>
<span class="udiff-line-modified-added">+     ManifestStream* stream = new ManifestStream((u1*)manifest,</span>
<span class="udiff-line-modified-added">+                                                 manifest_size);</span>
<span class="udiff-line-modified-added">+     if (stream-&gt;check_is_signed()) {</span>
<span class="udiff-line-modified-added">+       ent-&gt;set_is_signed();</span>
<span class="udiff-line-modified-added">+     } else {</span>
<span class="udiff-line-added">+       // Copy the manifest into the shared archive</span>
<span class="udiff-line-added">+       manifest = ClassLoaderExt::read_raw_manifest(cpe, &amp;manifest_size, CHECK);</span>
<span class="udiff-line-added">+       Array&lt;u1&gt;* buf = MetadataFactory::new_array&lt;u1&gt;(loader_data,</span>
<span class="udiff-line-added">+                                                       manifest_size,</span>
<span class="udiff-line-added">+                                                       THREAD);</span>
<span class="udiff-line-added">+       char* p = (char*)(buf-&gt;data());</span>
<span class="udiff-line-added">+       memcpy(p, manifest, manifest_size);</span>
<span class="udiff-line-added">+       ent-&gt;set_manifest(buf);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ char* FileMapInfo::skip_first_path_entry(const char* path) {</span>
<span class="udiff-line-added">+   size_t path_sep_len = strlen(os::path_separator());</span>
<span class="udiff-line-added">+   char* p = strstr((char*)path, os::path_separator());</span>
<span class="udiff-line-added">+   if (p != NULL) {</span>
<span class="udiff-line-added">+     debug_only( {</span>
<span class="udiff-line-added">+       size_t image_name_len = strlen(MODULES_IMAGE_NAME);</span>
<span class="udiff-line-added">+       assert(strncmp(p - image_name_len, MODULES_IMAGE_NAME, image_name_len) == 0,</span>
<span class="udiff-line-added">+              &quot;first entry must be the modules image&quot;);</span>
<span class="udiff-line-added">+     } );</span>
<span class="udiff-line-added">+     p += path_sep_len;</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     debug_only( {</span>
<span class="udiff-line-added">+       assert(ClassLoader::string_ends_with(path, MODULES_IMAGE_NAME),</span>
<span class="udiff-line-added">+              &quot;first entry must be the modules image&quot;);</span>
<span class="udiff-line-added">+     } );</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return p;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ int FileMapInfo::num_paths(const char* path) {</span>
<span class="udiff-line-added">+   if (path == NULL) {</span>
<span class="udiff-line-added">+     return 0;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   int npaths = 1;</span>
<span class="udiff-line-added">+   char* p = (char*)path;</span>
<span class="udiff-line-added">+   while (p != NULL) {</span>
<span class="udiff-line-added">+     char* prev = p;</span>
<span class="udiff-line-added">+     p = strstr((char*)p, os::path_separator());</span>
<span class="udiff-line-added">+     if (p != NULL) {</span>
<span class="udiff-line-added">+       p++;</span>
<span class="udiff-line-added">+       // don&#39;t count empty path</span>
<span class="udiff-line-added">+       if ((p - prev) &gt; 1) {</span>
<span class="udiff-line-added">+        npaths++;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return npaths;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ GrowableArray&lt;const char*&gt;* FileMapInfo::create_path_array(const char* paths) {</span>
<span class="udiff-line-added">+   GrowableArray&lt;const char*&gt;* path_array =  new(ResourceObj::RESOURCE_AREA, mtInternal)</span>
<span class="udiff-line-added">+       GrowableArray&lt;const char*&gt;(10);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ClasspathStream cp_stream(paths);</span>
<span class="udiff-line-added">+   while (cp_stream.has_next()) {</span>
<span class="udiff-line-added">+     const char* path = cp_stream.get_next();</span>
<span class="udiff-line-added">+     struct stat st;</span>
<span class="udiff-line-added">+     if (os::stat(path, &amp;st) == 0) {</span>
<span class="udiff-line-added">+       path_array-&gt;append(path);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return path_array;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool FileMapInfo::classpath_failure(const char* msg, const char* name) {</span>
<span class="udiff-line-added">+   ClassLoader::trace_class_path(msg, name);</span>
<span class="udiff-line-added">+   if (PrintSharedArchiveAndExit) {</span>
<span class="udiff-line-added">+     MetaspaceShared::set_archive_loading_failed();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return false;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool FileMapInfo::check_paths(int shared_path_start_idx, int num_paths, GrowableArray&lt;const char*&gt;* rp_array) {</span>
<span class="udiff-line-added">+   int i = 0;</span>
<span class="udiff-line-added">+   int j = shared_path_start_idx;</span>
<span class="udiff-line-added">+   bool mismatch = false;</span>
<span class="udiff-line-added">+   while (i &lt; num_paths &amp;&amp; !mismatch) {</span>
<span class="udiff-line-added">+     while (shared_path(j)-&gt;from_class_path_attr()) {</span>
<span class="udiff-line-added">+       // shared_path(j) was expanded from the JAR file attribute &quot;Class-Path:&quot;</span>
<span class="udiff-line-added">+       // during dump time. It&#39;s not included in the -classpath VM argument.</span>
<span class="udiff-line-added">+       j++;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if (!os::same_files(shared_path(j)-&gt;name(), rp_array-&gt;at(i))) {</span>
<span class="udiff-line-added">+       mismatch = true;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     i++;</span>
<span class="udiff-line-added">+     j++;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return mismatch;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool FileMapInfo::validate_boot_class_paths() {</span>
<span class="udiff-line-added">+   //</span>
<span class="udiff-line-added">+   // - Archive contains boot classes only - relaxed boot path check:</span>
<span class="udiff-line-added">+   //   Extra path elements appended to the boot path at runtime are allowed.</span>
<span class="udiff-line-added">+   //</span>
<span class="udiff-line-added">+   // - Archive contains application or platform classes - strict boot path check:</span>
<span class="udiff-line-added">+   //   Validate the entire runtime boot path, which must be compatible</span>
<span class="udiff-line-added">+   //   with the dump time boot path. Appending boot path at runtime is not</span>
<span class="udiff-line-added">+   //   allowed.</span>
<span class="udiff-line-added">+   //</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // The first entry in boot path is the modules_image (guaranteed by</span>
<span class="udiff-line-added">+   // ClassLoader::setup_boot_search_path()). Skip the first entry. The</span>
<span class="udiff-line-added">+   // path of the runtime modules_image may be different from the dump</span>
<span class="udiff-line-added">+   // time path (e.g. the JDK image is copied to a different location</span>
<span class="udiff-line-added">+   // after generating the shared archive), which is acceptable. For most</span>
<span class="udiff-line-added">+   // common cases, the dump time boot path might contain modules_image only.</span>
<span class="udiff-line-added">+   char* runtime_boot_path = Arguments::get_sysclasspath();</span>
<span class="udiff-line-added">+   char* rp = skip_first_path_entry(runtime_boot_path);</span>
<span class="udiff-line-added">+   assert(shared_path(0)-&gt;is_modules_image(), &quot;first shared_path must be the modules image&quot;);</span>
<span class="udiff-line-added">+   int dp_len = header()-&gt;app_class_paths_start_index() - 1; // ignore the first path to the module image</span>
<span class="udiff-line-added">+   bool mismatch = false;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   bool relaxed_check = !header()-&gt;has_platform_or_app_classes();</span>
<span class="udiff-line-added">+   if (dp_len == 0 &amp;&amp; rp == NULL) {</span>
<span class="udiff-line-added">+     return true;   // ok, both runtime and dump time boot paths have modules_images only</span>
<span class="udiff-line-added">+   } else if (dp_len == 0 &amp;&amp; rp != NULL) {</span>
<span class="udiff-line-added">+     if (relaxed_check) {</span>
<span class="udiff-line-added">+       return true;   // ok, relaxed check, runtime has extra boot append path entries</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       mismatch = true;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   } else if (dp_len &gt; 0 &amp;&amp; rp != NULL) {</span>
<span class="udiff-line-added">+     int num;</span>
<span class="udiff-line-added">+     ResourceMark rm;</span>
<span class="udiff-line-added">+     GrowableArray&lt;const char*&gt;* rp_array = create_path_array(rp);</span>
<span class="udiff-line-added">+     int rp_len = rp_array-&gt;length();</span>
<span class="udiff-line-added">+     if (rp_len &gt;= dp_len) {</span>
<span class="udiff-line-added">+       if (relaxed_check) {</span>
<span class="udiff-line-added">+         // only check the leading entries in the runtime boot path, up to</span>
<span class="udiff-line-added">+         // the length of the dump time boot path</span>
<span class="udiff-line-added">+         num = dp_len;</span>
        } else {
<span class="udiff-line-modified-removed">-         // Copy the manifest into the shared archive</span>
<span class="udiff-line-modified-removed">-         manifest = ClassLoaderExt::read_raw_manifest(cpe, &amp;manifest_size, CHECK);</span>
<span class="udiff-line-removed">-         Array&lt;u1&gt;* buf = MetadataFactory::new_array&lt;u1&gt;(loader_data,</span>
<span class="udiff-line-removed">-                                                         manifest_size,</span>
<span class="udiff-line-removed">-                                                         THREAD);</span>
<span class="udiff-line-removed">-         char* p = (char*)(buf-&gt;data());</span>
<span class="udiff-line-removed">-         memcpy(p, manifest, manifest_size);</span>
<span class="udiff-line-removed">-         ent-&gt;set_manifest(buf);</span>
<span class="udiff-line-modified-added">+         // check the full runtime boot path, must match with dump time</span>
<span class="udiff-line-modified-added">+         num = rp_len;</span>
        }
<span class="udiff-line-added">+       mismatch = check_paths(1, num, rp_array);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (mismatch) {</span>
<span class="udiff-line-added">+     // The paths are different</span>
<span class="udiff-line-added">+     return classpath_failure(&quot;[BOOT classpath mismatch, actual =&quot;, runtime_boot_path);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return true;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool FileMapInfo::validate_app_class_paths(int shared_app_paths_len) {</span>
<span class="udiff-line-added">+   const char *appcp = Arguments::get_appclasspath();</span>
<span class="udiff-line-added">+   assert(appcp != NULL, &quot;NULL app classpath&quot;);</span>
<span class="udiff-line-added">+   int rp_len = num_paths(appcp);</span>
<span class="udiff-line-added">+   bool mismatch = false;</span>
<span class="udiff-line-added">+   if (rp_len &lt; shared_app_paths_len) {</span>
<span class="udiff-line-added">+     return classpath_failure(&quot;Run time APP classpath is shorter than the one at dump time: &quot;, appcp);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (shared_app_paths_len != 0 &amp;&amp; rp_len != 0) {</span>
<span class="udiff-line-added">+     // Prefix is OK: E.g., dump with -cp foo.jar, but run with -cp foo.jar:bar.jar.</span>
<span class="udiff-line-added">+     ResourceMark rm;</span>
<span class="udiff-line-added">+     GrowableArray&lt;const char*&gt;* rp_array = create_path_array(appcp);</span>
<span class="udiff-line-added">+     if (rp_array-&gt;length() == 0) {</span>
<span class="udiff-line-added">+       // None of the jar file specified in the runtime -cp exists.</span>
<span class="udiff-line-added">+       return classpath_failure(&quot;None of the jar file specified in the runtime -cp exists: -Djava.class.path=&quot;, appcp);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Handling of non-existent entries in the classpath: we eliminate all the non-existent</span>
<span class="udiff-line-added">+     // entries from both the dump time classpath (ClassLoader::update_class_path_entry_list)</span>
<span class="udiff-line-added">+     // and the runtime classpath (FileMapInfo::create_path_array), and check the remaining</span>
<span class="udiff-line-added">+     // entries. E.g.:</span>
<span class="udiff-line-added">+     //</span>
<span class="udiff-line-added">+     // dump : -cp a.jar:NE1:NE2:b.jar  -&gt; a.jar:b.jar -&gt; recorded in archive.</span>
<span class="udiff-line-added">+     // run 1: -cp NE3:a.jar:NE4:b.jar  -&gt; a.jar:b.jar -&gt; matched</span>
<span class="udiff-line-added">+     // run 2: -cp x.jar:NE4:b.jar      -&gt; x.jar:b.jar -&gt; mismatched</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     int j = header()-&gt;app_class_paths_start_index();</span>
<span class="udiff-line-added">+     mismatch = check_paths(j, shared_app_paths_len, rp_array);</span>
<span class="udiff-line-added">+     if (mismatch) {</span>
<span class="udiff-line-added">+       return classpath_failure(&quot;[APP classpath mismatch, actual: -Djava.class.path=&quot;, appcp);</span>
      }
    }
<span class="udiff-line-added">+   return true;</span>
  }
  
<span class="udiff-line-added">+ void FileMapInfo::log_paths(const char* msg, int start_idx, int end_idx) {</span>
<span class="udiff-line-added">+   LogTarget(Info, class, path) lt;</span>
<span class="udiff-line-added">+   if (lt.is_enabled()) {</span>
<span class="udiff-line-added">+     LogStream ls(lt);</span>
<span class="udiff-line-added">+     ls.print(&quot;%s&quot;, msg);</span>
<span class="udiff-line-added">+     const char* prefix = &quot;&quot;;</span>
<span class="udiff-line-added">+     for (int i = start_idx; i &lt; end_idx; i++) {</span>
<span class="udiff-line-added">+       ls.print(&quot;%s%s&quot;, prefix, shared_path(i)-&gt;name());</span>
<span class="udiff-line-added">+       prefix = os::path_separator();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     ls.cr();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
  
  bool FileMapInfo::validate_shared_path_table() {
    assert(UseSharedSpaces, &quot;runtime only&quot;);
  
    _validating_shared_path_table = true;
<span class="udiff-line-removed">-   _shared_path_table = _header-&gt;_shared_path_table;</span>
<span class="udiff-line-removed">-   _shared_path_entry_size = _header-&gt;_shared_path_entry_size;</span>
<span class="udiff-line-removed">-   _shared_path_table_size = _header-&gt;_shared_path_table_size;</span>
  
<span class="udiff-line-modified-removed">-   int module_paths_start_index = _header-&gt;_app_module_paths_start_index;</span>
<span class="udiff-line-modified-added">+   // Load the shared path table info from the archive header</span>
<span class="udiff-line-added">+   _shared_path_table = header()-&gt;shared_path_table();</span>
<span class="udiff-line-added">+   if (DynamicDumpSharedSpaces) {</span>
<span class="udiff-line-added">+     // Only support dynamic dumping with the usage of the default CDS archive</span>
<span class="udiff-line-added">+     // or a simple base archive.</span>
<span class="udiff-line-added">+     // If the base layer archive contains additional path component besides</span>
<span class="udiff-line-added">+     // the runtime image and the -cp, dynamic dumping is disabled.</span>
<span class="udiff-line-added">+     //</span>
<span class="udiff-line-added">+     // When dynamic archiving is enabled, the _shared_path_table is overwritten</span>
<span class="udiff-line-added">+     // to include the application path and stored in the top layer archive.</span>
<span class="udiff-line-added">+     assert(shared_path(0)-&gt;is_modules_image(), &quot;first shared_path must be the modules image&quot;);</span>
<span class="udiff-line-added">+     if (header()-&gt;app_class_paths_start_index() &gt; 1) {</span>
<span class="udiff-line-added">+       DynamicDumpSharedSpaces = false;</span>
<span class="udiff-line-added">+       warning(</span>
<span class="udiff-line-added">+         &quot;Dynamic archiving is disabled because base layer archive has appended boot classpath&quot;);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if (header()-&gt;num_module_paths() &gt; 0) {</span>
<span class="udiff-line-added">+       DynamicDumpSharedSpaces = false;</span>
<span class="udiff-line-added">+       warning(</span>
<span class="udiff-line-added">+         &quot;Dynamic archiving is disabled because base layer archive has module path&quot;);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   log_paths(&quot;Expecting BOOT path=&quot;, 0, header()-&gt;app_class_paths_start_index());</span>
<span class="udiff-line-added">+   log_paths(&quot;Expecting -Djava.class.path=&quot;, header()-&gt;app_class_paths_start_index(), header()-&gt;app_module_paths_start_index());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   int module_paths_start_index = header()-&gt;app_module_paths_start_index();</span>
<span class="udiff-line-added">+   int shared_app_paths_len = 0;</span>
  
    // validate the path entries up to the _max_used_path_index
<span class="udiff-line-modified-removed">-   for (int i=0; i &lt; _header-&gt;_max_used_path_index + 1; i++) {</span>
<span class="udiff-line-modified-added">+   for (int i=0; i &lt; header()-&gt;max_used_path_index() + 1; i++) {</span>
      if (i &lt; module_paths_start_index) {
        if (shared_path(i)-&gt;validate()) {
<span class="udiff-line-added">+         // Only count the app class paths not from the &quot;Class-path&quot; attribute of a jar manifest.</span>
<span class="udiff-line-added">+         if (!shared_path(i)-&gt;from_class_path_attr() &amp;&amp; i &gt;= header()-&gt;app_class_paths_start_index()) {</span>
<span class="udiff-line-added">+           shared_app_paths_len++;</span>
<span class="udiff-line-added">+         }</span>
          log_info(class, path)(&quot;ok&quot;);
        } else {
<span class="udiff-line-modified-removed">-         assert(!UseSharedSpaces, &quot;UseSharedSpaces should be disabled&quot;);</span>
<span class="udiff-line-modified-added">+         if (_dynamic_archive_info != NULL &amp;&amp; _dynamic_archive_info-&gt;_is_static) {</span>
<span class="udiff-line-added">+           assert(!UseSharedSpaces, &quot;UseSharedSpaces should be disabled&quot;);</span>
<span class="udiff-line-added">+         }</span>
          return false;
        }
      } else if (i &gt;= module_paths_start_index) {
        if (shared_path(i)-&gt;validate(false /* not a class path entry */)) {
          log_info(class, path)(&quot;ok&quot;);
        } else {
<span class="udiff-line-modified-removed">-         assert(!UseSharedSpaces, &quot;UseSharedSpaces should be disabled&quot;);</span>
<span class="udiff-line-modified-added">+         if (_dynamic_archive_info != NULL &amp;&amp; _dynamic_archive_info-&gt;_is_static) {</span>
<span class="udiff-line-added">+           assert(!UseSharedSpaces, &quot;UseSharedSpaces should be disabled&quot;);</span>
<span class="udiff-line-added">+         }</span>
          return false;
        }
      }
    }
  
<span class="udiff-line-added">+   if (header()-&gt;max_used_path_index() == 0) {</span>
<span class="udiff-line-added">+     // default archive only contains the module image in the bootclasspath</span>
<span class="udiff-line-added">+     assert(shared_path(0)-&gt;is_modules_image(), &quot;first shared_path must be the modules image&quot;);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     if (!validate_boot_class_paths() || !validate_app_class_paths(shared_app_paths_len)) {</span>
<span class="udiff-line-added">+       fail_continue(&quot;shared class paths mismatch (hint: enable -Xlog:class+path=info to diagnose the failure)&quot;);</span>
<span class="udiff-line-added">+       return false;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   validate_non_existent_class_paths();</span>
<span class="udiff-line-added">+ </span>
    _validating_shared_path_table = false;
  
  #if INCLUDE_JVMTI
    if (_classpath_entries_for_jvmti != NULL) {
      os::free(_classpath_entries_for_jvmti);
    }
<span class="udiff-line-modified-removed">-   size_t sz = sizeof(ClassPathEntry*) *  _shared_path_table_size;</span>
<span class="udiff-line-modified-added">+   size_t sz = sizeof(ClassPathEntry*) * get_number_of_shared_paths();</span>
    _classpath_entries_for_jvmti = (ClassPathEntry**)os::malloc(sz, mtClass);
<span class="udiff-line-modified-removed">-   memset(_classpath_entries_for_jvmti, 0, sz);</span>
<span class="udiff-line-modified-added">+   memset((void*)_classpath_entries_for_jvmti, 0, sz);</span>
  #endif
  
    return true;
  }
  
<span class="udiff-line-added">+ void FileMapInfo::validate_non_existent_class_paths() {</span>
<span class="udiff-line-added">+   // All of the recorded non-existent paths came from the Class-Path: attribute from the JAR</span>
<span class="udiff-line-added">+   // files on the app classpath. If any of these are found to exist during runtime,</span>
<span class="udiff-line-added">+   // it will change how classes are loading for the app loader. For safety, disable</span>
<span class="udiff-line-added">+   // loading of archived platform/app classes (currently there&#39;s no way to disable just the</span>
<span class="udiff-line-added">+   // app classes).</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   assert(UseSharedSpaces, &quot;runtime only&quot;);</span>
<span class="udiff-line-added">+   for (int i = header()-&gt;app_module_paths_start_index() + header()-&gt;num_module_paths();</span>
<span class="udiff-line-added">+        i &lt; get_number_of_shared_paths();</span>
<span class="udiff-line-added">+        i++) {</span>
<span class="udiff-line-added">+     SharedClassPathEntry* ent = shared_path(i);</span>
<span class="udiff-line-added">+     if (!ent-&gt;check_non_existent()) {</span>
<span class="udiff-line-added">+       warning(&quot;Archived non-system classes are disabled because the &quot;</span>
<span class="udiff-line-added">+               &quot;file %s exists&quot;, ent-&gt;name());</span>
<span class="udiff-line-added">+       header()-&gt;set_has_platform_or_app_classes(false);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool FileMapInfo::check_archive(const char* archive_name, bool is_static) {</span>
<span class="udiff-line-added">+   int fd = os::open(archive_name, O_RDONLY | O_BINARY, 0);</span>
<span class="udiff-line-added">+   if (fd &lt; 0) {</span>
<span class="udiff-line-added">+     // do not vm_exit_during_initialization here because Arguments::init_shared_archive_paths()</span>
<span class="udiff-line-added">+     // requires a shared archive name. The open_for_read() function will log a message regarding</span>
<span class="udiff-line-added">+     // failure in opening a shared archive.</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   size_t sz = is_static ? sizeof(FileMapHeader) : sizeof(DynamicArchiveHeader);</span>
<span class="udiff-line-added">+   void* header = os::malloc(sz, mtInternal);</span>
<span class="udiff-line-added">+   memset(header, 0, sz);</span>
<span class="udiff-line-added">+   size_t n = os::read(fd, header, (unsigned int)sz);</span>
<span class="udiff-line-added">+   if (n != sz) {</span>
<span class="udiff-line-added">+     os::free(header);</span>
<span class="udiff-line-added">+     os::close(fd);</span>
<span class="udiff-line-added">+     vm_exit_during_initialization(&quot;Unable to read header from shared archive&quot;, archive_name);</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (is_static) {</span>
<span class="udiff-line-added">+     FileMapHeader* static_header = (FileMapHeader*)header;</span>
<span class="udiff-line-added">+     if (static_header-&gt;magic() != CDS_ARCHIVE_MAGIC) {</span>
<span class="udiff-line-added">+       os::free(header);</span>
<span class="udiff-line-added">+       os::close(fd);</span>
<span class="udiff-line-added">+       vm_exit_during_initialization(&quot;Not a base shared archive&quot;, archive_name);</span>
<span class="udiff-line-added">+       return false;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     DynamicArchiveHeader* dynamic_header = (DynamicArchiveHeader*)header;</span>
<span class="udiff-line-added">+     if (dynamic_header-&gt;magic() != CDS_DYNAMIC_ARCHIVE_MAGIC) {</span>
<span class="udiff-line-added">+       os::free(header);</span>
<span class="udiff-line-added">+       os::close(fd);</span>
<span class="udiff-line-added">+       vm_exit_during_initialization(&quot;Not a top shared archive&quot;, archive_name);</span>
<span class="udiff-line-added">+       return false;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   os::free(header);</span>
<span class="udiff-line-added">+   os::close(fd);</span>
<span class="udiff-line-added">+   return true;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool FileMapInfo::get_base_archive_name_from_header(const char* archive_name,</span>
<span class="udiff-line-added">+                                                     int* size, char** base_archive_name) {</span>
<span class="udiff-line-added">+   int fd = os::open(archive_name, O_RDONLY | O_BINARY, 0);</span>
<span class="udiff-line-added">+   if (fd &lt; 0) {</span>
<span class="udiff-line-added">+     *size = 0;</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // read the header as a dynamic archive header</span>
<span class="udiff-line-added">+   size_t sz = sizeof(DynamicArchiveHeader);</span>
<span class="udiff-line-added">+   DynamicArchiveHeader* dynamic_header = (DynamicArchiveHeader*)os::malloc(sz, mtInternal);</span>
<span class="udiff-line-added">+   size_t n = os::read(fd, dynamic_header, (unsigned int)sz);</span>
<span class="udiff-line-added">+   if (n != sz) {</span>
<span class="udiff-line-added">+     fail_continue(&quot;Unable to read the file header.&quot;);</span>
<span class="udiff-line-added">+     os::free(dynamic_header);</span>
<span class="udiff-line-added">+     os::close(fd);</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (dynamic_header-&gt;magic() != CDS_DYNAMIC_ARCHIVE_MAGIC) {</span>
<span class="udiff-line-added">+     // Not a dynamic header, no need to proceed further.</span>
<span class="udiff-line-added">+     *size = 0;</span>
<span class="udiff-line-added">+     os::free(dynamic_header);</span>
<span class="udiff-line-added">+     os::close(fd);</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (dynamic_header-&gt;base_archive_is_default()) {</span>
<span class="udiff-line-added">+     *base_archive_name = Arguments::get_default_shared_archive_path();</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     // read the base archive name</span>
<span class="udiff-line-added">+     size_t name_size = dynamic_header-&gt;base_archive_name_size();</span>
<span class="udiff-line-added">+     if (name_size == 0) {</span>
<span class="udiff-line-added">+       os::free(dynamic_header);</span>
<span class="udiff-line-added">+       os::close(fd);</span>
<span class="udiff-line-added">+       return false;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     *base_archive_name = NEW_C_HEAP_ARRAY(char, name_size, mtInternal);</span>
<span class="udiff-line-added">+     n = os::read(fd, *base_archive_name, (unsigned int)name_size);</span>
<span class="udiff-line-added">+     if (n != name_size) {</span>
<span class="udiff-line-added">+       fail_continue(&quot;Unable to read the base archive name from the header.&quot;);</span>
<span class="udiff-line-added">+       FREE_C_HEAP_ARRAY(char, *base_archive_name);</span>
<span class="udiff-line-added">+       *base_archive_name = NULL;</span>
<span class="udiff-line-added">+       os::free(dynamic_header);</span>
<span class="udiff-line-added">+       os::close(fd);</span>
<span class="udiff-line-added">+       return false;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   os::free(dynamic_header);</span>
<span class="udiff-line-added">+   os::close(fd);</span>
<span class="udiff-line-added">+   return true;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void FileMapInfo::restore_shared_path_table() {</span>
<span class="udiff-line-added">+   _shared_path_table = _current_info-&gt;header()-&gt;shared_path_table();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  // Read the FileMapInfo information from the file.
  
  bool FileMapInfo::init_from_file(int fd) {
<span class="udiff-line-modified-removed">-   size_t sz = sizeof(FileMapHeader);</span>
<span class="udiff-line-modified-removed">-   size_t n = os::read(fd, _header, (unsigned int)sz);</span>
<span class="udiff-line-modified-added">+   size_t sz = is_static() ? sizeof(FileMapHeader) : sizeof(DynamicArchiveHeader);</span>
<span class="udiff-line-modified-added">+   size_t n = os::read(fd, header(), (unsigned int)sz);</span>
    if (n != sz) {
      fail_continue(&quot;Unable to read the file header.&quot;);
      return false;
    }
<span class="udiff-line-modified-removed">-   if (_header-&gt;_version != CURRENT_CDS_ARCHIVE_VERSION) {</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   if (!Arguments::has_jimage()) {</span>
<span class="udiff-line-added">+     FileMapInfo::fail_continue(&quot;The shared archive file cannot be used with an exploded module build.&quot;);</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   unsigned int expected_magic = is_static() ? CDS_ARCHIVE_MAGIC : CDS_DYNAMIC_ARCHIVE_MAGIC;</span>
<span class="udiff-line-added">+   if (header()-&gt;magic() != expected_magic) {</span>
<span class="udiff-line-added">+     log_info(cds)(&quot;_magic expected: 0x%08x&quot;, expected_magic);</span>
<span class="udiff-line-added">+     log_info(cds)(&quot;         actual: 0x%08x&quot;, header()-&gt;magic());</span>
<span class="udiff-line-added">+     FileMapInfo::fail_continue(&quot;The shared archive file has a bad magic number.&quot;);</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (header()-&gt;version() != CURRENT_CDS_ARCHIVE_VERSION) {</span>
<span class="udiff-line-added">+     log_info(cds)(&quot;_version expected: %d&quot;, CURRENT_CDS_ARCHIVE_VERSION);</span>
<span class="udiff-line-added">+     log_info(cds)(&quot;           actual: %d&quot;, header()-&gt;version());</span>
      fail_continue(&quot;The shared archive file has the wrong version.&quot;);
      return false;
    }
<span class="udiff-line-removed">-   _file_offset = (long)n;</span>
  
<span class="udiff-line-modified-removed">-   size_t info_size = _header-&gt;_paths_misc_info_size;</span>
<span class="udiff-line-modified-removed">-   _paths_misc_info = NEW_C_HEAP_ARRAY_RETURN_NULL(char, info_size, mtClass);</span>
<span class="udiff-line-modified-removed">-   if (_paths_misc_info == NULL) {</span>
<span class="udiff-line-modified-removed">-     fail_continue(&quot;Unable to read the file header.&quot;);</span>
<span class="udiff-line-modified-added">+   if (header()-&gt;header_size() != sz) {</span>
<span class="udiff-line-modified-added">+     log_info(cds)(&quot;_header_size expected: &quot; SIZE_FORMAT, sz);</span>
<span class="udiff-line-modified-added">+     log_info(cds)(&quot;               actual: &quot; SIZE_FORMAT, header()-&gt;header_size());</span>
<span class="udiff-line-modified-added">+     FileMapInfo::fail_continue(&quot;The shared archive file has an incorrect header size.&quot;);</span>
      return false;
    }
<span class="udiff-line-modified-removed">-   n = os::read(fd, _paths_misc_info, (unsigned int)info_size);</span>
<span class="udiff-line-modified-removed">-   if (n != info_size) {</span>
<span class="udiff-line-modified-removed">-     fail_continue(&quot;Unable to read the shared path info header.&quot;);</span>
<span class="udiff-line-modified-removed">-     FREE_C_HEAP_ARRAY(char, _paths_misc_info);</span>
<span class="udiff-line-modified-removed">-     _paths_misc_info = NULL;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   const char* actual_ident = header()-&gt;jvm_ident();</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   if (actual_ident[JVM_IDENT_MAX-1] != 0) {</span>
<span class="udiff-line-modified-added">+     FileMapInfo::fail_continue(&quot;JVM version identifier is corrupted.&quot;);</span>
      return false;
    }
  
<span class="udiff-line-modified-removed">-   size_t len = lseek(fd, 0, SEEK_END);</span>
<span class="udiff-line-modified-removed">-   CDSFileMapRegion* si = space_at(MetaspaceShared::last_valid_region);</span>
<span class="udiff-line-modified-removed">-   // The last space might be empty</span>
<span class="udiff-line-modified-removed">-   if (si-&gt;_file_offset &gt; len || len - si-&gt;_file_offset &lt; si-&gt;_used) {</span>
<span class="udiff-line-modified-removed">-     fail_continue(&quot;The shared archive file has been truncated.&quot;);</span>
<span class="udiff-line-modified-added">+   char expected_ident[JVM_IDENT_MAX];</span>
<span class="udiff-line-modified-added">+   get_header_version(expected_ident);</span>
<span class="udiff-line-modified-added">+   if (strncmp(actual_ident, expected_ident, JVM_IDENT_MAX-1) != 0) {</span>
<span class="udiff-line-modified-added">+     log_info(cds)(&quot;_jvm_ident expected: %s&quot;, expected_ident);</span>
<span class="udiff-line-modified-added">+     log_info(cds)(&quot;             actual: %s&quot;, actual_ident);</span>
<span class="udiff-line-added">+     FileMapInfo::fail_continue(&quot;The shared archive file was created by a different&quot;</span>
<span class="udiff-line-added">+                   &quot; version or build of HotSpot&quot;);</span>
      return false;
    }
  
<span class="udiff-line-modified-removed">-   _file_offset += (long)n;</span>
<span class="udiff-line-modified-removed">-   SharedBaseAddress = _header-&gt;_shared_base_address;</span>
<span class="udiff-line-modified-added">+   if (VerifySharedSpaces) {</span>
<span class="udiff-line-modified-added">+     int expected_crc = header()-&gt;compute_crc();</span>
<span class="udiff-line-added">+     if (expected_crc != header()-&gt;crc()) {</span>
<span class="udiff-line-added">+       log_info(cds)(&quot;_crc expected: %d&quot;, expected_crc);</span>
<span class="udiff-line-added">+       log_info(cds)(&quot;       actual: %d&quot;, header()-&gt;crc());</span>
<span class="udiff-line-added">+       FileMapInfo::fail_continue(&quot;Header checksum verification failed.&quot;);</span>
<span class="udiff-line-added">+       return false;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   _file_offset = n + header()-&gt;base_archive_name_size(); // accounts for the size of _base_archive_name</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (is_static()) {</span>
<span class="udiff-line-added">+     // just checking the last region is sufficient since the archive is written</span>
<span class="udiff-line-added">+     // in sequential order</span>
<span class="udiff-line-added">+     size_t len = lseek(fd, 0, SEEK_END);</span>
<span class="udiff-line-added">+     FileMapRegion* si = space_at(MetaspaceShared::last_valid_region);</span>
<span class="udiff-line-added">+     // The last space might be empty</span>
<span class="udiff-line-added">+     if (si-&gt;file_offset() &gt; len || len - si-&gt;file_offset() &lt; si-&gt;used()) {</span>
<span class="udiff-line-added">+       fail_continue(&quot;The shared archive file has been truncated.&quot;);</span>
<span class="udiff-line-added">+       return false;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    return true;
  }
  
<span class="udiff-line-added">+ void FileMapInfo::seek_to_position(size_t pos) {</span>
<span class="udiff-line-added">+   if (lseek(_fd, (long)pos, SEEK_SET) &lt; 0) {</span>
<span class="udiff-line-added">+     fail_stop(&quot;Unable to seek to position &quot; SIZE_FORMAT, pos);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
  
  // Read the FileMapInfo information from the file.
  bool FileMapInfo::open_for_read() {
<span class="udiff-line-modified-removed">-   _full_path = Arguments::GetSharedArchivePath();</span>
<span class="udiff-line-modified-added">+   if (_file_open) {</span>
<span class="udiff-line-added">+     return true;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (is_static()) {</span>
<span class="udiff-line-added">+     _full_path = Arguments::GetSharedArchivePath();</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     _full_path = Arguments::GetSharedDynamicArchivePath();</span>
<span class="udiff-line-added">+   }</span>
    int fd = os::open(_full_path, O_RDONLY | O_BINARY, 0);
    if (fd &lt; 0) {
      if (errno == ENOENT) {
<span class="udiff-line-modified-removed">-       // Not locating the shared archive is ok.</span>
<span class="udiff-line-removed">-       fail_continue(&quot;Specified shared archive not found.&quot;);</span>
<span class="udiff-line-modified-added">+       fail_continue(&quot;Specified shared archive not found (%s).&quot;, _full_path);</span>
      } else {
        fail_continue(&quot;Failed to open shared archive file (%s).&quot;,
                      os::strerror(errno));
      }
      return false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -576,23 +1052,26 @@</span>
    _fd = fd;
    _file_open = true;
    return true;
  }
  
<span class="udiff-line-removed">- </span>
  // Write the FileMapInfo information to the file.
  
<span class="udiff-line-modified-removed">- void FileMapInfo::open_for_write() {</span>
<span class="udiff-line-modified-removed">-   _full_path = Arguments::GetSharedArchivePath();</span>
<span class="udiff-line-modified-added">+ void FileMapInfo::open_for_write(const char* path) {</span>
<span class="udiff-line-modified-added">+   if (path == NULL) {</span>
<span class="udiff-line-added">+     _full_path = Arguments::GetSharedArchivePath();</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     _full_path = path;</span>
<span class="udiff-line-added">+   }</span>
    LogMessage(cds) msg;
    if (msg.is_info()) {
      msg.info(&quot;Dumping shared data to file: &quot;);
      msg.info(&quot;   %s&quot;, _full_path);
    }
  
  #ifdef _WINDOWS  // On Windows, need WRITE permission to remove the file.
<span class="udiff-line-modified-removed">-   chmod(_full_path, _S_IREAD | _S_IWRITE);</span>
<span class="udiff-line-modified-added">+     chmod(_full_path, _S_IREAD | _S_IWRITE);</span>
  #endif
  
    // Use remove() to delete the existing file because, on Unix, this will
    // allow processes that have it open continued access to the file.
    remove(_full_path);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -600,62 +1079,121 @@</span>
    if (fd &lt; 0) {
      fail_stop(&quot;Unable to create shared archive file %s: (%s).&quot;, _full_path,
                os::strerror(errno));
    }
    _fd = fd;
<span class="udiff-line-removed">-   _file_offset = 0;</span>
    _file_open = true;
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Seek past the header. We will write the header after all regions are written</span>
<span class="udiff-line-added">+   // and their CRCs computed.</span>
<span class="udiff-line-added">+   size_t header_bytes = header()-&gt;header_size();</span>
<span class="udiff-line-added">+   if (header()-&gt;magic() == CDS_DYNAMIC_ARCHIVE_MAGIC) {</span>
<span class="udiff-line-added">+     header_bytes += strlen(Arguments::GetSharedArchivePath()) + 1;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   header_bytes = align_up(header_bytes, os::vm_allocation_granularity());</span>
<span class="udiff-line-added">+   _file_offset = header_bytes;</span>
<span class="udiff-line-added">+   seek_to_position(_file_offset);</span>
  }
  
  
  // Write the header to the file, seek to the next allocation boundary.
  
  void FileMapInfo::write_header() {
<span class="udiff-line-modified-removed">-   int info_size = ClassLoader::get_shared_paths_misc_info_size();</span>
<span class="udiff-line-modified-added">+   _file_offset = 0;</span>
<span class="udiff-line-added">+   seek_to_position(_file_offset);</span>
<span class="udiff-line-added">+   char* base_archive_name = NULL;</span>
<span class="udiff-line-added">+   if (header()-&gt;magic() == CDS_DYNAMIC_ARCHIVE_MAGIC) {</span>
<span class="udiff-line-added">+     base_archive_name = (char*)Arguments::GetSharedArchivePath();</span>
<span class="udiff-line-added">+     header()-&gt;set_base_archive_name_size(strlen(base_archive_name) + 1);</span>
<span class="udiff-line-added">+     header()-&gt;set_base_archive_is_default(FLAG_IS_DEFAULT(SharedArchiveFile));</span>
<span class="udiff-line-added">+   }</span>
  
<span class="udiff-line-modified-removed">-   _header-&gt;_paths_misc_info_size = info_size;</span>
<span class="udiff-line-modified-added">+   assert(is_file_position_aligned(), &quot;must be&quot;);</span>
<span class="udiff-line-added">+   write_bytes(header(), header()-&gt;header_size());</span>
<span class="udiff-line-added">+   if (base_archive_name != NULL) {</span>
<span class="udiff-line-added">+     write_bytes(base_archive_name, header()-&gt;base_archive_name_size());</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-   align_file_position();</span>
<span class="udiff-line-modified-removed">-   write_bytes(_header, sizeof(FileMapHeader));</span>
<span class="udiff-line-removed">-   write_bytes(ClassLoader::get_shared_paths_misc_info(), (size_t)info_size);</span>
<span class="udiff-line-removed">-   align_file_position();</span>
<span class="udiff-line-modified-added">+ size_t FileMapRegion::used_aligned() const {</span>
<span class="udiff-line-modified-added">+   return align_up(used(), os::vm_allocation_granularity());</span>
  }
  
<span class="udiff-line-added">+ void FileMapRegion::init(int region_index, char* base, size_t size, bool read_only,</span>
<span class="udiff-line-added">+                          bool allow_exec, int crc) {</span>
<span class="udiff-line-added">+   _is_heap_region = HeapShared::is_heap_region(region_index);</span>
<span class="udiff-line-added">+   _is_bitmap_region = (region_index == MetaspaceShared::bm);</span>
<span class="udiff-line-added">+   _mapping_offset = 0;</span>
  
<span class="udiff-line-modified-removed">- // Dump region to file.</span>
<span class="udiff-line-modified-added">+   if (_is_heap_region) {</span>
<span class="udiff-line-added">+     assert(!DynamicDumpSharedSpaces, &quot;must be&quot;);</span>
<span class="udiff-line-added">+     assert((base - (char*)CompressedKlassPointers::base()) % HeapWordSize == 0, &quot;Sanity&quot;);</span>
<span class="udiff-line-added">+     if (base != NULL) {</span>
<span class="udiff-line-added">+       _mapping_offset = (size_t)CompressedOops::encode_not_null((oop)base);</span>
<span class="udiff-line-added">+       assert(_mapping_offset == (size_t)(uint32_t)_mapping_offset, &quot;must be 32-bit only&quot;);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     if (base != NULL) {</span>
<span class="udiff-line-added">+       assert(base &gt;= (char*)SharedBaseAddress, &quot;must be&quot;);</span>
<span class="udiff-line-added">+       _mapping_offset = base - (char*)SharedBaseAddress;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   _used = size;</span>
<span class="udiff-line-added">+   _read_only = read_only;</span>
<span class="udiff-line-added">+   _allow_exec = allow_exec;</span>
<span class="udiff-line-added">+   _crc = crc;</span>
<span class="udiff-line-added">+   _mapped_from_file = false;</span>
<span class="udiff-line-added">+   _mapped_base = NULL;</span>
<span class="udiff-line-added">+ }</span>
  
  void FileMapInfo::write_region(int region, char* base, size_t size,
                                 bool read_only, bool allow_exec) {
<span class="udiff-line-modified-removed">-   CDSFileMapRegion* si = space_at(region);</span>
<span class="udiff-line-modified-added">+   Arguments::assert_is_dumping_archive();</span>
  
<span class="udiff-line-modified-removed">-   if (_file_open) {</span>
<span class="udiff-line-modified-removed">-     guarantee(si-&gt;_file_offset == _file_offset, &quot;file offset mismatch.&quot;);</span>
<span class="udiff-line-modified-removed">-     log_info(cds)(&quot;Shared file region %d: &quot; SIZE_FORMAT_HEX_W(08)</span>
<span class="udiff-line-modified-removed">-                   &quot; bytes, addr &quot; INTPTR_FORMAT &quot; file offset &quot; SIZE_FORMAT_HEX_W(08),</span>
<span class="udiff-line-modified-removed">-                   region, size, p2i(base), _file_offset);</span>
<span class="udiff-line-modified-added">+   FileMapRegion* si = space_at(region);</span>
<span class="udiff-line-modified-added">+   char* target_base;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   if (region == MetaspaceShared::bm) {</span>
<span class="udiff-line-modified-added">+     target_base = NULL; // always NULL for bm region.</span>
    } else {
<span class="udiff-line-modified-removed">-     si-&gt;_file_offset = _file_offset;</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">-   if (HeapShared::is_heap_region(region)) {</span>
<span class="udiff-line-removed">-     assert((base - (char*)Universe::narrow_oop_base()) % HeapWordSize == 0, &quot;Sanity&quot;);</span>
<span class="udiff-line-removed">-     if (base != NULL) {</span>
<span class="udiff-line-removed">-       si-&gt;_addr._offset = (intx)CompressedOops::encode_not_null((oop)base);</span>
<span class="udiff-line-modified-added">+     if (DynamicDumpSharedSpaces) {</span>
<span class="udiff-line-modified-added">+       assert(!HeapShared::is_heap_region(region), &quot;dynamic archive doesn&#39;t support heap regions&quot;);</span>
<span class="udiff-line-modified-added">+       target_base = DynamicArchive::buffer_to_target(base);</span>
      } else {
<span class="udiff-line-modified-removed">-       si-&gt;_addr._offset = 0;</span>
<span class="udiff-line-modified-added">+       target_base = base;</span>
      }
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     si-&gt;_addr._base = base;</span>
    }
<span class="udiff-line-modified-removed">-   si-&gt;_used = size;</span>
<span class="udiff-line-modified-removed">-   si-&gt;_read_only = read_only;</span>
<span class="udiff-line-modified-removed">-   si-&gt;_allow_exec = allow_exec;</span>
<span class="udiff-line-modified-removed">-   si-&gt;_crc = ClassLoader::crc32(0, base, (jint)size);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   si-&gt;set_file_offset(_file_offset);</span>
<span class="udiff-line-modified-added">+   char* requested_base = (target_base == NULL) ? NULL : target_base + MetaspaceShared::final_delta();</span>
<span class="udiff-line-modified-added">+   log_debug(cds)(&quot;Shared file region  %d: &quot; SIZE_FORMAT_HEX_W(08)</span>
<span class="udiff-line-added">+                  &quot; bytes, addr &quot; INTPTR_FORMAT &quot; file offset &quot; SIZE_FORMAT_HEX_W(08),</span>
<span class="udiff-line-added">+                  region, size, p2i(requested_base), _file_offset);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   int crc = ClassLoader::crc32(0, base, (jint)size);</span>
<span class="udiff-line-added">+   si-&gt;init(region, target_base, size, read_only, allow_exec, crc);</span>
<span class="udiff-line-added">+ </span>
    if (base != NULL) {
      write_bytes_aligned(base, size);
    }
  }
  
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void FileMapInfo::write_bitmap_region(const CHeapBitMap* ptrmap) {</span>
<span class="udiff-line-added">+   ResourceMark rm;</span>
<span class="udiff-line-added">+   size_t size_in_bits = ptrmap-&gt;size();</span>
<span class="udiff-line-added">+   size_t size_in_bytes = ptrmap-&gt;size_in_bytes();</span>
<span class="udiff-line-added">+   uintptr_t* buffer = (uintptr_t*)NEW_RESOURCE_ARRAY(char, size_in_bytes);</span>
<span class="udiff-line-added">+   ptrmap-&gt;write_to(buffer, size_in_bytes);</span>
<span class="udiff-line-added">+   header()-&gt;set_ptrmap_size_in_bits(size_in_bits);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   log_debug(cds)(&quot;ptrmap = &quot; INTPTR_FORMAT &quot; (&quot; SIZE_FORMAT &quot; bytes)&quot;,</span>
<span class="udiff-line-added">+                  p2i(buffer), size_in_bytes);</span>
<span class="udiff-line-added">+   write_region(MetaspaceShared::bm, (char*)buffer, size_in_bytes, /*read_only=*/true, /*allow_exec=*/false);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  // Write out the given archive heap memory regions.  GC code combines multiple
  // consecutive archive GC regions into one MemRegion whenever possible and
  // produces the &#39;heap_mem&#39; array.
  //
  // If the archive heap memory size is smaller than a single dump time GC region
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -685,12 +1223,11 @@</span>
  //            ^^^
  //             |
  //             +-- gap
  size_t FileMapInfo::write_archive_heap_regions(GrowableArray&lt;MemRegion&gt; *heap_mem,
                                                 GrowableArray&lt;ArchiveHeapOopmapInfo&gt; *oopmaps,
<span class="udiff-line-modified-removed">-                                                int first_region_id, int max_num_regions,</span>
<span class="udiff-line-removed">-                                                bool print_log) {</span>
<span class="udiff-line-modified-added">+                                                int first_region_id, int max_num_regions) {</span>
    assert(max_num_regions &lt;= 2, &quot;Only support maximum 2 memory regions&quot;);
  
    int arr_len = heap_mem == NULL ? 0 : heap_mem-&gt;length();
    if(arr_len &gt; max_num_regions) {
      fail_stop(&quot;Unable to write archive heap memory regions: &quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -710,57 +1247,56 @@</span>
        start = (char*)heap_mem-&gt;at(arr_idx).start();
        size = heap_mem-&gt;at(arr_idx).byte_size();
        total_size += size;
      }
  
<span class="udiff-line-modified-removed">-     if (print_log) {</span>
<span class="udiff-line-modified-removed">-       log_info(cds)(&quot;Archive heap region %d &quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot; = &quot; SIZE_FORMAT_W(8) &quot; bytes&quot;,</span>
<span class="udiff-line-removed">-                     i, p2i(start), p2i(start + size), size);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     log_debug(cds)(&quot;Archive heap region %d: &quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot; = &quot; SIZE_FORMAT_W(8) &quot; bytes&quot;,</span>
<span class="udiff-line-modified-added">+                    i, p2i(start), p2i(start + size), size);</span>
      write_region(i, start, size, false, false);
      if (size &gt; 0) {
<span class="udiff-line-modified-removed">-       space_at(i)-&gt;_oopmap = oopmaps-&gt;at(arr_idx)._oopmap;</span>
<span class="udiff-line-modified-removed">-       space_at(i)-&gt;_oopmap_size_in_bits = oopmaps-&gt;at(arr_idx)._oopmap_size_in_bits;</span>
<span class="udiff-line-modified-added">+       address oopmap = oopmaps-&gt;at(arr_idx)._oopmap;</span>
<span class="udiff-line-modified-added">+       assert(oopmap &gt;= (address)SharedBaseAddress, &quot;must be&quot;);</span>
<span class="udiff-line-added">+       space_at(i)-&gt;init_oopmap(oopmap - (address)SharedBaseAddress,</span>
<span class="udiff-line-added">+                                oopmaps-&gt;at(arr_idx)._oopmap_size_in_bits);</span>
      }
    }
    return total_size;
  }
  
  // Dump bytes to file -- at the current file position.
  
  void FileMapInfo::write_bytes(const void* buffer, size_t nbytes) {
<span class="udiff-line-modified-removed">-   if (_file_open) {</span>
<span class="udiff-line-modified-removed">-     size_t n = os::write(_fd, buffer, (unsigned int)nbytes);</span>
<span class="udiff-line-modified-removed">-     if (n != nbytes) {</span>
<span class="udiff-line-modified-removed">-       // It is dangerous to leave the corrupted shared archive file around,</span>
<span class="udiff-line-modified-removed">-       // close and remove the file. See bug 6372906.</span>
<span class="udiff-line-modified-removed">-       close();</span>
<span class="udiff-line-modified-removed">-       remove(_full_path);</span>
<span class="udiff-line-removed">-       fail_stop(&quot;Unable to write to shared archive file.&quot;);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+   assert(_file_open, &quot;must be&quot;);</span>
<span class="udiff-line-modified-added">+   size_t n = os::write(_fd, buffer, (unsigned int)nbytes);</span>
<span class="udiff-line-modified-added">+   if (n != nbytes) {</span>
<span class="udiff-line-modified-added">+     // If the shared archive is corrupted, close it and remove it.</span>
<span class="udiff-line-modified-added">+     close();</span>
<span class="udiff-line-modified-added">+     remove(_full_path);</span>
<span class="udiff-line-modified-added">+     fail_stop(&quot;Unable to write to shared archive file.&quot;);</span>
    }
    _file_offset += nbytes;
  }
  
<span class="udiff-line-added">+ bool FileMapInfo::is_file_position_aligned() const {</span>
<span class="udiff-line-added">+   return _file_offset == align_up(_file_offset,</span>
<span class="udiff-line-added">+                                   os::vm_allocation_granularity());</span>
<span class="udiff-line-added">+ }</span>
  
  // Align file position to an allocation unit boundary.
  
  void FileMapInfo::align_file_position() {
<span class="udiff-line-added">+   assert(_file_open, &quot;must be&quot;);</span>
    size_t new_file_offset = align_up(_file_offset,
<span class="udiff-line-modified-removed">-                                          os::vm_allocation_granularity());</span>
<span class="udiff-line-modified-added">+                                     os::vm_allocation_granularity());</span>
    if (new_file_offset != _file_offset) {
      _file_offset = new_file_offset;
<span class="udiff-line-modified-removed">-     if (_file_open) {</span>
<span class="udiff-line-modified-removed">-       // Seek one byte back from the target and write a byte to insure</span>
<span class="udiff-line-modified-removed">-       // that the written file is the correct length.</span>
<span class="udiff-line-modified-removed">-       _file_offset -= 1;</span>
<span class="udiff-line-modified-removed">-       if (lseek(_fd, (long)_file_offset, SEEK_SET) &lt; 0) {</span>
<span class="udiff-line-modified-removed">-         fail_stop(&quot;Unable to seek.&quot;);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       char zero = 0;</span>
<span class="udiff-line-removed">-       write_bytes(&amp;zero, 1);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     // Seek one byte back from the target and write a byte to insure</span>
<span class="udiff-line-modified-added">+     // that the written file is the correct length.</span>
<span class="udiff-line-modified-added">+     _file_offset -= 1;</span>
<span class="udiff-line-modified-added">+     seek_to_position(_file_offset);</span>
<span class="udiff-line-modified-added">+     char zero = 0;</span>
<span class="udiff-line-modified-added">+     write_bytes(&amp;zero, 1);</span>
    }
  }
  
  
  // Dump bytes to file -- at the current file position.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -769,10 +1305,13 @@</span>
    align_file_position();
    write_bytes(buffer, nbytes);
    align_file_position();
  }
  
<span class="udiff-line-added">+ void FileMapInfo::set_final_requested_base(char* b) {</span>
<span class="udiff-line-added">+   header()-&gt;set_final_requested_base(b);</span>
<span class="udiff-line-added">+ }</span>
  
  // Close the shared archive file.  This does NOT unmap mapped regions.
  
  void FileMapInfo::close() {
    if (_file_open) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -787,112 +1326,257 @@</span>
  
  // JVM/TI RedefineClasses() support:
  // Remap the shared readonly space to shared readwrite, private.
  bool FileMapInfo::remap_shared_readonly_as_readwrite() {
    int idx = MetaspaceShared::ro;
<span class="udiff-line-modified-removed">-   CDSFileMapRegion* si = space_at(idx);</span>
<span class="udiff-line-modified-removed">-   if (!si-&gt;_read_only) {</span>
<span class="udiff-line-modified-added">+   FileMapRegion* si = space_at(idx);</span>
<span class="udiff-line-modified-added">+   if (!si-&gt;read_only()) {</span>
      // the space is already readwrite so we are done
      return true;
    }
<span class="udiff-line-modified-removed">-   size_t used = si-&gt;_used;</span>
<span class="udiff-line-modified-added">+   size_t used = si-&gt;used();</span>
    size_t size = align_up(used, os::vm_allocation_granularity());
    if (!open_for_read()) {
      return false;
    }
    char *addr = region_addr(idx);
<span class="udiff-line-modified-removed">-   char *base = os::remap_memory(_fd, _full_path, si-&gt;_file_offset,</span>
<span class="udiff-line-modified-added">+   char *base = os::remap_memory(_fd, _full_path, si-&gt;file_offset(),</span>
                                  addr, size, false /* !read_only */,
<span class="udiff-line-modified-removed">-                                 si-&gt;_allow_exec);</span>
<span class="udiff-line-modified-added">+                                 si-&gt;allow_exec());</span>
    close();
<span class="udiff-line-added">+   // These have to be errors because the shared region is now unmapped.</span>
    if (base == NULL) {
<span class="udiff-line-modified-removed">-     fail_continue(&quot;Unable to remap shared readonly space (errno=%d).&quot;, errno);</span>
<span class="udiff-line-modified-removed">-     return false;</span>
<span class="udiff-line-modified-added">+     log_error(cds)(&quot;Unable to remap shared readonly space (errno=%d).&quot;, errno);</span>
<span class="udiff-line-modified-added">+     vm_exit(1);</span>
    }
    if (base != addr) {
<span class="udiff-line-modified-removed">-     fail_continue(&quot;Unable to remap shared readonly space at required address.&quot;);</span>
<span class="udiff-line-modified-added">+     log_error(cds)(&quot;Unable to remap shared readonly space (errno=%d).&quot;, errno);</span>
<span class="udiff-line-added">+     vm_exit(1);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   si-&gt;set_read_only(false);</span>
<span class="udiff-line-added">+   return true;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Memory map a region in the address space.</span>
<span class="udiff-line-added">+ static const char* shared_region_name[] = { &quot;MiscCode&quot;, &quot;ReadWrite&quot;, &quot;ReadOnly&quot;, &quot;Bitmap&quot;,</span>
<span class="udiff-line-added">+                                             &quot;String1&quot;, &quot;String2&quot;, &quot;OpenArchive1&quot;, &quot;OpenArchive2&quot; };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ MapArchiveResult FileMapInfo::map_regions(int regions[], int num_regions, char* mapped_base_address, ReservedSpace rs) {</span>
<span class="udiff-line-added">+   DEBUG_ONLY(FileMapRegion* last_region = NULL);</span>
<span class="udiff-line-added">+   intx addr_delta = mapped_base_address - header()-&gt;requested_base_address();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Make sure we don&#39;t attempt to use header()-&gt;mapped_base_address() unless</span>
<span class="udiff-line-added">+   // it&#39;s been successfully mapped.</span>
<span class="udiff-line-added">+   DEBUG_ONLY(header()-&gt;set_mapped_base_address((char*)(uintptr_t)0xdeadbeef);)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   for (int r = 0; r &lt; num_regions; r++) {</span>
<span class="udiff-line-added">+     int idx = regions[r];</span>
<span class="udiff-line-added">+     MapArchiveResult result = map_region(idx, addr_delta, mapped_base_address, rs);</span>
<span class="udiff-line-added">+     if (result != MAP_ARCHIVE_SUCCESS) {</span>
<span class="udiff-line-added">+       return result;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     FileMapRegion* si = space_at(idx);</span>
<span class="udiff-line-added">+     DEBUG_ONLY(if (last_region != NULL) {</span>
<span class="udiff-line-added">+         // Ensure that the OS won&#39;t be able to allocate new memory spaces between any mapped</span>
<span class="udiff-line-added">+         // regions, or else it would mess up the simple comparision in MetaspaceObj::is_shared().</span>
<span class="udiff-line-added">+         assert(si-&gt;mapped_base() == last_region-&gt;mapped_end(), &quot;must have no gaps&quot;);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       last_region = si;)</span>
<span class="udiff-line-added">+     log_info(cds)(&quot;Mapped %s region #%d at base &quot; INTPTR_FORMAT &quot; top &quot; INTPTR_FORMAT &quot; (%s)&quot;, is_static() ? &quot;static &quot; : &quot;dynamic&quot;,</span>
<span class="udiff-line-added">+                   idx, p2i(si-&gt;mapped_base()), p2i(si-&gt;mapped_end()),</span>
<span class="udiff-line-added">+                   shared_region_name[idx]);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   header()-&gt;set_mapped_base_address(header()-&gt;requested_base_address() + addr_delta);</span>
<span class="udiff-line-added">+   if (addr_delta != 0 &amp;&amp; !relocate_pointers(addr_delta)) {</span>
<span class="udiff-line-added">+     return MAP_ARCHIVE_OTHER_FAILURE;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return MAP_ARCHIVE_SUCCESS;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool FileMapInfo::read_region(int i, char* base, size_t size) {</span>
<span class="udiff-line-added">+   assert(MetaspaceShared::use_windows_memory_mapping(), &quot;used by windows only&quot;);</span>
<span class="udiff-line-added">+   FileMapRegion* si = space_at(i);</span>
<span class="udiff-line-added">+   log_info(cds)(&quot;Commit %s region #%d at base &quot; INTPTR_FORMAT &quot; top &quot; INTPTR_FORMAT &quot; (%s)%s&quot;,</span>
<span class="udiff-line-added">+                 is_static() ? &quot;static &quot; : &quot;dynamic&quot;, i, p2i(base), p2i(base + size),</span>
<span class="udiff-line-added">+                 shared_region_name[i], si-&gt;allow_exec() ? &quot; exec&quot; : &quot;&quot;);</span>
<span class="udiff-line-added">+   if (!os::commit_memory(base, size, si-&gt;allow_exec())) {</span>
<span class="udiff-line-added">+     log_error(cds)(&quot;Failed to commit %s region #%d (%s)&quot;, is_static() ? &quot;static &quot; : &quot;dynamic&quot;,</span>
<span class="udiff-line-added">+                    i, shared_region_name[i]);</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (lseek(_fd, (long)si-&gt;file_offset(), SEEK_SET) != (int)si-&gt;file_offset() ||</span>
<span class="udiff-line-added">+       read_bytes(base, size) != size) {</span>
      return false;
    }
<span class="udiff-line-removed">-   si-&gt;_read_only = false;</span>
    return true;
  }
  
<span class="udiff-line-modified-removed">- // Map the whole region at once, assumed to be allocated contiguously.</span>
<span class="udiff-line-modified-removed">- ReservedSpace FileMapInfo::reserve_shared_memory() {</span>
<span class="udiff-line-modified-removed">-   char* requested_addr = region_addr(0);</span>
<span class="udiff-line-modified-removed">-   size_t size = FileMapInfo::core_spaces_size();</span>
<span class="udiff-line-modified-added">+ MapArchiveResult FileMapInfo::map_region(int i, intx addr_delta, char* mapped_base_address, ReservedSpace rs) {</span>
<span class="udiff-line-modified-added">+   assert(!HeapShared::is_heap_region(i), &quot;sanity&quot;);</span>
<span class="udiff-line-modified-added">+   FileMapRegion* si = space_at(i);</span>
<span class="udiff-line-modified-added">+   size_t size = si-&gt;used_aligned();</span>
<span class="udiff-line-added">+   char *requested_addr = mapped_base_address + si-&gt;mapping_offset();</span>
<span class="udiff-line-added">+   assert(si-&gt;mapped_base() == NULL, &quot;must be not mapped yet&quot;);</span>
<span class="udiff-line-added">+   assert(requested_addr != NULL, &quot;must be specified&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   si-&gt;set_mapped_from_file(false);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (MetaspaceShared::use_windows_memory_mapping()) {</span>
<span class="udiff-line-added">+     // Windows cannot remap read-only shared memory to read-write when required for</span>
<span class="udiff-line-added">+     // RedefineClasses, which is also used by JFR.  Always map windows regions as RW.</span>
<span class="udiff-line-added">+     si-&gt;set_read_only(false);</span>
<span class="udiff-line-added">+   } else if (JvmtiExport::can_modify_any_class() || JvmtiExport::can_walk_any_space() ||</span>
<span class="udiff-line-added">+              Arguments::has_jfr_option()) {</span>
<span class="udiff-line-added">+     // If a tool agent is in use (debugging enabled), or JFR, we must map the address space RW</span>
<span class="udiff-line-added">+     si-&gt;set_read_only(false);</span>
<span class="udiff-line-added">+   } else if (addr_delta != 0) {</span>
<span class="udiff-line-added">+     si-&gt;set_read_only(false); // Need to patch the pointers</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (rs.is_reserved()) {</span>
<span class="udiff-line-added">+     assert(rs.contains(requested_addr) &amp;&amp; rs.contains(requested_addr + size - 1), &quot;must be&quot;);</span>
<span class="udiff-line-added">+     MemTracker::record_virtual_memory_type((address)requested_addr, mtClassShared);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (MetaspaceShared::use_windows_memory_mapping() &amp;&amp; rs.is_reserved()) {</span>
<span class="udiff-line-added">+     // This is the second time we try to map the archive(s). We have already created a ReservedSpace</span>
<span class="udiff-line-added">+     // that covers all the FileMapRegions to ensure all regions can be mapped. However, Windows</span>
<span class="udiff-line-added">+     // can&#39;t mmap into a ReservedSpace, so we just os::read() the data. We&#39;re going to patch all the</span>
<span class="udiff-line-added">+     // regions anyway, so there&#39;s no benefit for mmap anyway.</span>
<span class="udiff-line-added">+     if (!read_region(i, requested_addr, size)) {</span>
<span class="udiff-line-added">+       log_info(cds)(&quot;Failed to read %s shared space into reserved space at &quot; INTPTR_FORMAT,</span>
<span class="udiff-line-added">+                     shared_region_name[i], p2i(requested_addr));</span>
<span class="udiff-line-added">+       return MAP_ARCHIVE_OTHER_FAILURE; // oom or I/O error.</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     char* base = os::map_memory(_fd, _full_path, si-&gt;file_offset(),</span>
<span class="udiff-line-added">+                                 requested_addr, size, si-&gt;read_only(),</span>
<span class="udiff-line-added">+                                 si-&gt;allow_exec());</span>
<span class="udiff-line-added">+     if (base != requested_addr) {</span>
<span class="udiff-line-added">+       log_info(cds)(&quot;Unable to map %s shared space at &quot; INTPTR_FORMAT,</span>
<span class="udiff-line-added">+                     shared_region_name[i], p2i(requested_addr));</span>
<span class="udiff-line-added">+       _memory_mapping_failed = true;</span>
<span class="udiff-line-added">+       return MAP_ARCHIVE_MMAP_FAILURE;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     si-&gt;set_mapped_from_file(true);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   si-&gt;set_mapped_base(requested_addr);</span>
  
<span class="udiff-line-removed">-   // Reserve the space first, then map otherwise map will go right over some</span>
<span class="udiff-line-removed">-   // other reserved memory (like the code cache).</span>
<span class="udiff-line-removed">-   ReservedSpace rs(size, os::vm_allocation_granularity(), false, requested_addr);</span>
    if (!rs.is_reserved()) {
<span class="udiff-line-modified-removed">-     fail_continue(&quot;Unable to reserve shared space at required address &quot;</span>
<span class="udiff-line-modified-removed">-                   INTPTR_FORMAT, p2i(requested_addr));</span>
<span class="udiff-line-modified-removed">-     return rs;</span>
<span class="udiff-line-modified-added">+     // When mapping on Windows for the first attempt, we don&#39;t reserve the address space for the regions</span>
<span class="udiff-line-modified-added">+     // (Windows can&#39;t mmap into a ReservedSpace). In this case, NMT requires we call it after</span>
<span class="udiff-line-modified-added">+     // os::map_memory has succeeded.</span>
<span class="udiff-line-added">+     assert(MetaspaceShared::use_windows_memory_mapping(), &quot;Windows memory mapping only&quot;);</span>
<span class="udiff-line-added">+     MemTracker::record_virtual_memory_type((address)requested_addr, mtClassShared);</span>
    }
<span class="udiff-line-removed">-   // the reserved virtual memory is for mapping class data sharing archive</span>
<span class="udiff-line-removed">-   MemTracker::record_virtual_memory_type((address)rs.base(), mtClassShared);</span>
  
<span class="udiff-line-modified-removed">-   return rs;</span>
<span class="udiff-line-modified-added">+   if (VerifySharedSpaces &amp;&amp; !verify_region_checksum(i)) {</span>
<span class="udiff-line-added">+     return MAP_ARCHIVE_OTHER_FAILURE;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return MAP_ARCHIVE_SUCCESS;</span>
  }
  
<span class="udiff-line-modified-removed">- // Memory map a region in the address space.</span>
<span class="udiff-line-modified-removed">- static const char* shared_region_name[] = { &quot;MiscData&quot;, &quot;ReadWrite&quot;, &quot;ReadOnly&quot;, &quot;MiscCode&quot;, &quot;OptionalData&quot;,</span>
<span class="udiff-line-modified-removed">-                                             &quot;String1&quot;, &quot;String2&quot;, &quot;OpenArchive1&quot;, &quot;OpenArchive2&quot; };</span>
<span class="udiff-line-modified-added">+ char* FileMapInfo::map_relocation_bitmap(size_t&amp; bitmap_size) {</span>
<span class="udiff-line-modified-added">+   FileMapRegion* si = space_at(MetaspaceShared::bm);</span>
<span class="udiff-line-modified-added">+   bitmap_size = si-&gt;used_aligned();</span>
<span class="udiff-line-added">+   bool read_only = true, allow_exec = false;</span>
<span class="udiff-line-added">+   char* requested_addr = NULL; // allow OS to pick any location</span>
<span class="udiff-line-added">+   char* bitmap_base = os::map_memory(_fd, _full_path, si-&gt;file_offset(),</span>
<span class="udiff-line-added">+                                      requested_addr, bitmap_size, read_only, allow_exec);</span>
<span class="udiff-line-added">+   if (bitmap_base == NULL) {</span>
<span class="udiff-line-added">+     log_error(cds)(&quot;failed to map relocation bitmap&quot;);</span>
<span class="udiff-line-added">+     return NULL;</span>
<span class="udiff-line-added">+   }</span>
  
<span class="udiff-line-modified-removed">- char* FileMapInfo::map_region(int i, char** top_ret) {</span>
<span class="udiff-line-modified-removed">-   assert(!HeapShared::is_heap_region(i), &quot;sanity&quot;);</span>
<span class="udiff-line-modified-removed">-   CDSFileMapRegion* si = space_at(i);</span>
<span class="udiff-line-modified-removed">-   size_t used = si-&gt;_used;</span>
<span class="udiff-line-modified-removed">-   size_t alignment = os::vm_allocation_granularity();</span>
<span class="udiff-line-removed">-   size_t size = align_up(used, alignment);</span>
<span class="udiff-line-removed">-   char *requested_addr = region_addr(i);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // If a tool agent is in use (debugging enabled), we must map the address space RW</span>
<span class="udiff-line-removed">-   if (JvmtiExport::can_modify_any_class() || JvmtiExport::can_walk_any_space()) {</span>
<span class="udiff-line-removed">-     si-&gt;_read_only = false;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // map the contents of the CDS archive in this memory</span>
<span class="udiff-line-removed">-   char *base = os::map_memory(_fd, _full_path, si-&gt;_file_offset,</span>
<span class="udiff-line-removed">-                               requested_addr, size, si-&gt;_read_only,</span>
<span class="udiff-line-removed">-                               si-&gt;_allow_exec);</span>
<span class="udiff-line-removed">-   if (base == NULL || base != requested_addr) {</span>
<span class="udiff-line-removed">-     fail_continue(&quot;Unable to map %s shared space at required address.&quot;, shared_region_name[i]);</span>
<span class="udiff-line-modified-added">+   if (VerifySharedSpaces &amp;&amp; !region_crc_check(bitmap_base, bitmap_size, si-&gt;crc())) {</span>
<span class="udiff-line-modified-added">+     log_error(cds)(&quot;relocation bitmap CRC error&quot;);</span>
<span class="udiff-line-modified-added">+     if (!os::unmap_memory(bitmap_base, bitmap_size)) {</span>
<span class="udiff-line-modified-added">+       fatal(&quot;os::unmap_memory of relocation bitmap failed&quot;);</span>
<span class="udiff-line-modified-added">+     }</span>
      return NULL;
    }
<span class="udiff-line-removed">- #ifdef _WINDOWS</span>
<span class="udiff-line-removed">-   // This call is Windows-only because the memory_type gets recorded for the other platforms</span>
<span class="udiff-line-removed">-   // in method FileMapInfo::reserve_shared_memory(), which is not called on Windows.</span>
<span class="udiff-line-removed">-   MemTracker::record_virtual_memory_type((address)base, mtClassShared);</span>
<span class="udiff-line-removed">- #endif</span>
  
<span class="udiff-line-added">+   return bitmap_base;</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-   if (!verify_region_checksum(i)) {</span>
<span class="udiff-line-modified-removed">-     return NULL;</span>
<span class="udiff-line-modified-added">+ bool FileMapInfo::relocate_pointers(intx addr_delta) {</span>
<span class="udiff-line-modified-added">+   log_debug(cds, reloc)(&quot;runtime archive relocation start&quot;);</span>
<span class="udiff-line-added">+   size_t bitmap_size;</span>
<span class="udiff-line-added">+   char* bitmap_base = map_relocation_bitmap(bitmap_size);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (bitmap_base == NULL) {</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     size_t ptrmap_size_in_bits = header()-&gt;ptrmap_size_in_bits();</span>
<span class="udiff-line-added">+     log_debug(cds, reloc)(&quot;mapped relocation bitmap @ &quot; INTPTR_FORMAT &quot; (&quot; SIZE_FORMAT</span>
<span class="udiff-line-added">+                           &quot; bytes = &quot; SIZE_FORMAT &quot; bits)&quot;,</span>
<span class="udiff-line-added">+                           p2i(bitmap_base), bitmap_size, ptrmap_size_in_bits);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     BitMapView ptrmap((BitMap::bm_word_t*)bitmap_base, ptrmap_size_in_bits);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Patch all pointers in the the mapped region that are marked by ptrmap.</span>
<span class="udiff-line-added">+     address patch_base = (address)mapped_base();</span>
<span class="udiff-line-added">+     address patch_end  = (address)mapped_end();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // the current value of the pointers to be patched must be within this</span>
<span class="udiff-line-added">+     // range (i.e., must be between the requesed base address, and the of the current archive).</span>
<span class="udiff-line-added">+     // Note: top archive may point to objects in the base archive, but not the other way around.</span>
<span class="udiff-line-added">+     address valid_old_base = (address)header()-&gt;requested_base_address();</span>
<span class="udiff-line-added">+     address valid_old_end  = valid_old_base + mapping_end_offset();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // after patching, the pointers must point inside this range</span>
<span class="udiff-line-added">+     // (the requested location of the archive, as mapped at runtime).</span>
<span class="udiff-line-added">+     address valid_new_base = (address)header()-&gt;mapped_base_address();</span>
<span class="udiff-line-added">+     address valid_new_end  = (address)mapped_end();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     SharedDataRelocator&lt;false&gt; patcher((address*)patch_base, (address*)patch_end, valid_old_base, valid_old_end,</span>
<span class="udiff-line-added">+                                        valid_new_base, valid_new_end, addr_delta);</span>
<span class="udiff-line-added">+     ptrmap.iterate(&amp;patcher);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (!os::unmap_memory(bitmap_base, bitmap_size)) {</span>
<span class="udiff-line-added">+       fatal(&quot;os::unmap_memory of relocation bitmap failed&quot;);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     log_debug(cds, reloc)(&quot;runtime archive relocation done&quot;);</span>
<span class="udiff-line-added">+     return true;</span>
    }
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-   *top_ret = base + size;</span>
<span class="udiff-line-modified-removed">-   return base;</span>
<span class="udiff-line-modified-added">+ size_t FileMapInfo::read_bytes(void* buffer, size_t count) {</span>
<span class="udiff-line-modified-added">+   assert(_file_open, &quot;Archive file is not open&quot;);</span>
<span class="udiff-line-added">+   size_t n = os::read(_fd, buffer, (unsigned int)count);</span>
<span class="udiff-line-added">+   if (n != count) {</span>
<span class="udiff-line-added">+     // Close the file if there&#39;s a problem reading it.</span>
<span class="udiff-line-added">+     close();</span>
<span class="udiff-line-added">+     return 0;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   _file_offset += count;</span>
<span class="udiff-line-added">+   return count;</span>
  }
  
<span class="udiff-line-modified-removed">- address FileMapInfo::decode_start_address(CDSFileMapRegion* spc, bool with_current_oop_encoding_mode) {</span>
<span class="udiff-line-modified-added">+ address FileMapInfo::decode_start_address(FileMapRegion* spc, bool with_current_oop_encoding_mode) {</span>
<span class="udiff-line-added">+   size_t offset = spc-&gt;mapping_offset();</span>
<span class="udiff-line-added">+   assert(offset == (size_t)(uint32_t)offset, &quot;must be 32-bit only&quot;);</span>
<span class="udiff-line-added">+   uint n = (uint)offset;</span>
    if (with_current_oop_encoding_mode) {
<span class="udiff-line-modified-removed">-     return (address)CompressedOops::decode_not_null(offset_of_space(spc));</span>
<span class="udiff-line-modified-added">+     return cast_from_oop&lt;address&gt;(CompressedOops::decode_not_null(n));</span>
    } else {
<span class="udiff-line-modified-removed">-     return (address)HeapShared::decode_from_archive(offset_of_space(spc));</span>
<span class="udiff-line-modified-added">+     return cast_from_oop&lt;address&gt;(HeapShared::decode_from_archive(n));</span>
    }
  }
  
  static MemRegion *closed_archive_heap_ranges = NULL;
  static MemRegion *open_archive_heap_ranges = NULL;
  static int num_closed_archive_heap_ranges = 0;
  static int num_open_archive_heap_ranges = 0;
  
  #if INCLUDE_CDS_JAVA_HEAP
  bool FileMapInfo::has_heap_regions() {
<span class="udiff-line-modified-removed">-   return (_header-&gt;_space[MetaspaceShared::first_closed_archive_heap_region]._used &gt; 0);</span>
<span class="udiff-line-modified-added">+   return (space_at(MetaspaceShared::first_closed_archive_heap_region)-&gt;used() &gt; 0);</span>
  }
  
  // Returns the address range of the archived heap regions computed using the
  // current oop encoding mode. This range may be different than the one seen at
  // dump time due to encoding mode differences. The result is used in determining
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -902,12 +1586,12 @@</span>
    address end   = NULL;
  
    for (int i = MetaspaceShared::first_closed_archive_heap_region;
             i &lt;= MetaspaceShared::last_valid_region;
             i++) {
<span class="udiff-line-modified-removed">-     CDSFileMapRegion* si = space_at(i);</span>
<span class="udiff-line-modified-removed">-     size_t size = si-&gt;_used;</span>
<span class="udiff-line-modified-added">+     FileMapRegion* si = space_at(i);</span>
<span class="udiff-line-modified-added">+     size_t size = si-&gt;used();</span>
      if (size &gt; 0) {
        address s = start_address_as_decoded_with_current_oop_encoding_mode(si);
        address e = s + size;
        if (start &gt; s) {
          start = s;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -953,43 +1637,41 @@</span>
      // in the archived subgraphs may be replaced by the ClassFileLoadHook. But that&#39;s OK
      // because we won&#39;t install an archived object subgraph if the klass of any of the
      // referenced objects are replaced. See HeapShared::initialize_from_archived_subgraph().
    }
  
<span class="udiff-line-removed">-   MemRegion heap_reserved = Universe::heap()-&gt;reserved_region();</span>
<span class="udiff-line-removed">- </span>
    log_info(cds)(&quot;CDS archive was created with max heap size = &quot; SIZE_FORMAT &quot;M, and the following configuration:&quot;,
                  max_heap_size()/M);
    log_info(cds)(&quot;    narrow_klass_base = &quot; PTR_FORMAT &quot;, narrow_klass_shift = %d&quot;,
                  p2i(narrow_klass_base()), narrow_klass_shift());
    log_info(cds)(&quot;    narrow_oop_mode = %d, narrow_oop_base = &quot; PTR_FORMAT &quot;, narrow_oop_shift = %d&quot;,
                  narrow_oop_mode(), p2i(narrow_oop_base()), narrow_oop_shift());
  
    log_info(cds)(&quot;The current max heap size = &quot; SIZE_FORMAT &quot;M, HeapRegion::GrainBytes = &quot; SIZE_FORMAT,
<span class="udiff-line-modified-removed">-                 heap_reserved.byte_size()/M, HeapRegion::GrainBytes);</span>
<span class="udiff-line-modified-added">+                 MaxHeapSize/M, HeapRegion::GrainBytes);</span>
    log_info(cds)(&quot;    narrow_klass_base = &quot; PTR_FORMAT &quot;, narrow_klass_shift = %d&quot;,
<span class="udiff-line-modified-removed">-                 p2i(Universe::narrow_klass_base()), Universe::narrow_klass_shift());</span>
<span class="udiff-line-modified-added">+                 p2i(CompressedKlassPointers::base()), CompressedKlassPointers::shift());</span>
    log_info(cds)(&quot;    narrow_oop_mode = %d, narrow_oop_base = &quot; PTR_FORMAT &quot;, narrow_oop_shift = %d&quot;,
<span class="udiff-line-modified-removed">-                 Universe::narrow_oop_mode(), p2i(Universe::narrow_oop_base()), Universe::narrow_oop_shift());</span>
<span class="udiff-line-modified-added">+                 CompressedOops::mode(), p2i(CompressedOops::base()), CompressedOops::shift());</span>
  
<span class="udiff-line-modified-removed">-   if (narrow_klass_base() != Universe::narrow_klass_base() ||</span>
<span class="udiff-line-modified-removed">-       narrow_klass_shift() != Universe::narrow_klass_shift()) {</span>
<span class="udiff-line-modified-added">+   if (narrow_klass_base() != CompressedKlassPointers::base() ||</span>
<span class="udiff-line-modified-added">+       narrow_klass_shift() != CompressedKlassPointers::shift()) {</span>
      log_info(cds)(&quot;CDS heap data cannot be used because the archive was created with an incompatible narrow klass encoding mode.&quot;);
      return;
    }
  
<span class="udiff-line-modified-removed">-   if (narrow_oop_mode() != Universe::narrow_oop_mode() ||</span>
<span class="udiff-line-modified-removed">-       narrow_oop_base() != Universe::narrow_oop_base() ||</span>
<span class="udiff-line-modified-removed">-       narrow_oop_shift() != Universe::narrow_oop_shift()) {</span>
<span class="udiff-line-modified-added">+   if (narrow_oop_mode() != CompressedOops::mode() ||</span>
<span class="udiff-line-modified-added">+       narrow_oop_base() != CompressedOops::base() ||</span>
<span class="udiff-line-modified-added">+       narrow_oop_shift() != CompressedOops::shift()) {</span>
      log_info(cds)(&quot;CDS heap data need to be relocated because the archive was created with an incompatible oop encoding mode.&quot;);
      _heap_pointers_need_patching = true;
    } else {
      MemRegion range = get_heap_regions_range_with_current_oop_encoding_mode();
<span class="udiff-line-modified-removed">-     if (!heap_reserved.contains(range)) {</span>
<span class="udiff-line-modified-added">+     if (!CompressedOops::is_in(range)) {</span>
        log_info(cds)(&quot;CDS heap data need to be relocated because&quot;);
        log_info(cds)(&quot;the desired range &quot; PTR_FORMAT &quot; - &quot;  PTR_FORMAT, p2i(range.start()), p2i(range.end()));
<span class="udiff-line-modified-removed">-       log_info(cds)(&quot;is outside of the heap &quot; PTR_FORMAT &quot; - &quot;  PTR_FORMAT, p2i(heap_reserved.start()), p2i(heap_reserved.end()));</span>
<span class="udiff-line-modified-added">+       log_info(cds)(&quot;is outside of the heap &quot; PTR_FORMAT &quot; - &quot;  PTR_FORMAT, p2i(CompressedOops::begin()), p2i(CompressedOops::end()));</span>
        _heap_pointers_need_patching = true;
      }
    }
  
    ptrdiff_t delta = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1001,19 +1683,19 @@</span>
      //
      // At dump time, the archived heap regions were near the top of the heap.
      // At run time, they may not be inside the heap, so we move them so
      // that they are now near the top of the runtime time. This can be done by
      // the simple math of adding the delta as shown above.
<span class="udiff-line-modified-removed">-     address dumptime_heap_end = (address)_header-&gt;_heap_reserved.end();</span>
<span class="udiff-line-modified-removed">-     address runtime_heap_end = (address)heap_reserved.end();</span>
<span class="udiff-line-modified-added">+     address dumptime_heap_end = header()-&gt;heap_end();</span>
<span class="udiff-line-modified-added">+     address runtime_heap_end = (address)CompressedOops::end();</span>
      delta = runtime_heap_end - dumptime_heap_end;
    }
  
    log_info(cds)(&quot;CDS heap data relocation delta = &quot; INTX_FORMAT &quot; bytes&quot;, delta);
    HeapShared::init_narrow_oop_decoding(narrow_oop_base() + delta, narrow_oop_shift());
  
<span class="udiff-line-modified-removed">-   CDSFileMapRegion* si = space_at(MetaspaceShared::first_closed_archive_heap_region);</span>
<span class="udiff-line-modified-added">+   FileMapRegion* si = space_at(MetaspaceShared::first_closed_archive_heap_region);</span>
    address relocated_closed_heap_region_bottom = start_address_as_decoded_from_archive(si);
    if (!is_aligned(relocated_closed_heap_region_bottom, HeapRegion::GrainBytes)) {
      // Align the bottom of the closed archive heap regions at G1 region boundary.
      // This will avoid the situation where the highest open region and the lowest
      // closed region sharing the same G1 region. Otherwise we will fail to map the
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1063,18 +1745,26 @@</span>
    }
  }
  
  bool FileMapInfo::map_heap_data(MemRegion **heap_mem, int first,
                                  int max, int* num, bool is_open_archive) {
<span class="udiff-line-modified-removed">-   MemRegion * regions = new MemRegion[max];</span>
<span class="udiff-line-modified-removed">-   CDSFileMapRegion* si;</span>
<span class="udiff-line-modified-added">+   MemRegion* regions = MemRegion::create_array(max, mtInternal);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   struct Cleanup {</span>
<span class="udiff-line-added">+     MemRegion* _regions;</span>
<span class="udiff-line-added">+     bool _aborted;</span>
<span class="udiff-line-added">+     Cleanup(MemRegion* regions) : _regions(regions), _aborted(true) { }</span>
<span class="udiff-line-added">+     ~Cleanup() { if (_aborted) { FREE_C_HEAP_ARRAY(MemRegion, _regions); } }</span>
<span class="udiff-line-added">+   } cleanup(regions);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   FileMapRegion* si;</span>
    int region_num = 0;
  
    for (int i = first;
             i &lt; first + max; i++) {
      si = space_at(i);
<span class="udiff-line-modified-removed">-     size_t size = si-&gt;_used;</span>
<span class="udiff-line-modified-added">+     size_t size = si-&gt;used();</span>
      if (size &gt; 0) {
        HeapWord* start = (HeapWord*)start_address_as_decoded_from_archive(si);
        regions[region_num] = MemRegion(start, size / HeapWordSize);
        region_num ++;
        log_info(cds)(&quot;Trying to map heap data: region[%d] at &quot; INTPTR_FORMAT &quot;, size = &quot; SIZE_FORMAT_W(8) &quot; bytes&quot;,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1103,46 +1793,37 @@</span>
    // for mapped regions as they are part of the reserved java heap, which is
    // already recorded.
    for (int i = 0; i &lt; region_num; i++) {
      si = space_at(first + i);
      char* addr = (char*)regions[i].start();
<span class="udiff-line-modified-removed">-     char* base = os::map_memory(_fd, _full_path, si-&gt;_file_offset,</span>
<span class="udiff-line-modified-removed">-                                 addr, regions[i].byte_size(), si-&gt;_read_only,</span>
<span class="udiff-line-modified-removed">-                                 si-&gt;_allow_exec);</span>
<span class="udiff-line-modified-added">+     char* base = os::map_memory(_fd, _full_path, si-&gt;file_offset(),</span>
<span class="udiff-line-modified-added">+                                 addr, regions[i].byte_size(), si-&gt;read_only(),</span>
<span class="udiff-line-modified-added">+                                 si-&gt;allow_exec());</span>
      if (base == NULL || base != addr) {
        // dealloc the regions from java heap
<span class="udiff-line-modified-removed">-       dealloc_archive_heap_regions(regions, region_num, is_open_archive);</span>
<span class="udiff-line-modified-added">+       dealloc_archive_heap_regions(regions, region_num);</span>
        log_info(cds)(&quot;UseSharedSpaces: Unable to map at required address in java heap. &quot;
                      INTPTR_FORMAT &quot;, size = &quot; SIZE_FORMAT &quot; bytes&quot;,
                      p2i(addr), regions[i].byte_size());
        return false;
      }
<span class="udiff-line-removed">-   }</span>
  
<span class="udiff-line-modified-removed">-   if (!verify_mapped_heap_regions(first, region_num)) {</span>
<span class="udiff-line-modified-removed">-     // dealloc the regions from java heap</span>
<span class="udiff-line-modified-removed">-     dealloc_archive_heap_regions(regions, region_num, is_open_archive);</span>
<span class="udiff-line-modified-removed">-     log_info(cds)(&quot;UseSharedSpaces: mapped heap regions are corrupt&quot;);</span>
<span class="udiff-line-modified-removed">-     return false;</span>
<span class="udiff-line-modified-added">+     if (VerifySharedSpaces &amp;&amp; !region_crc_check(addr, regions[i].byte_size(), si-&gt;crc())) {</span>
<span class="udiff-line-modified-added">+       // dealloc the regions from java heap</span>
<span class="udiff-line-modified-added">+       dealloc_archive_heap_regions(regions, region_num);</span>
<span class="udiff-line-modified-added">+       log_info(cds)(&quot;UseSharedSpaces: mapped heap regions are corrupt&quot;);</span>
<span class="udiff-line-modified-added">+       return false;</span>
<span class="udiff-line-added">+     }</span>
    }
  
<span class="udiff-line-added">+   cleanup._aborted = false;</span>
    // the shared heap data is mapped successfully
    *heap_mem = regions;
    *num = region_num;
    return true;
  }
  
<span class="udiff-line-removed">- bool FileMapInfo::verify_mapped_heap_regions(int first, int num) {</span>
<span class="udiff-line-removed">-   assert(num &gt; 0, &quot;sanity&quot;);</span>
<span class="udiff-line-removed">-   for (int i = first; i &lt; first + num; i++) {</span>
<span class="udiff-line-removed">-     if (!verify_region_checksum(i)) {</span>
<span class="udiff-line-removed">-       return false;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return true;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  void FileMapInfo::patch_archived_heap_embedded_pointers() {
    if (!_heap_pointers_need_patching) {
      return;
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1156,13 +1837,13 @@</span>
  }
  
  void FileMapInfo::patch_archived_heap_embedded_pointers(MemRegion* ranges, int num_ranges,
                                                          int first_region_idx) {
    for (int i=0; i&lt;num_ranges; i++) {
<span class="udiff-line-modified-removed">-     CDSFileMapRegion* si = space_at(i + first_region_idx);</span>
<span class="udiff-line-modified-removed">-     HeapShared::patch_archived_heap_embedded_pointers(ranges[i], (address)si-&gt;_oopmap,</span>
<span class="udiff-line-modified-removed">-                                                       si-&gt;_oopmap_size_in_bits);</span>
<span class="udiff-line-modified-added">+     FileMapRegion* si = space_at(i + first_region_idx);</span>
<span class="udiff-line-modified-added">+     HeapShared::patch_archived_heap_embedded_pointers(ranges[i], (address)(SharedBaseAddress + si-&gt;oopmap_offset()),</span>
<span class="udiff-line-modified-added">+                                                       si-&gt;oopmap_size_in_bits());</span>
    }
  }
  
  // This internally allocates objects using SystemDictionary::Object_klass(), so it
  // must be called after the well-known classes are resolved.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1183,90 +1864,90 @@</span>
                                                    num_open_archive_heap_ranges);
    }
  }
  
  // dealloc the archive regions from java heap
<span class="udiff-line-modified-removed">- void FileMapInfo::dealloc_archive_heap_regions(MemRegion* regions, int num, bool is_open) {</span>
<span class="udiff-line-modified-added">+ void FileMapInfo::dealloc_archive_heap_regions(MemRegion* regions, int num) {</span>
    if (num &gt; 0) {
      assert(regions != NULL, &quot;Null archive ranges array with non-zero count&quot;);
<span class="udiff-line-modified-removed">-     G1CollectedHeap::heap()-&gt;dealloc_archive_regions(regions, num, is_open);</span>
<span class="udiff-line-modified-added">+     G1CollectedHeap::heap()-&gt;dealloc_archive_regions(regions, num);</span>
    }
  }
  #endif // INCLUDE_CDS_JAVA_HEAP
  
<span class="udiff-line-modified-removed">- bool FileMapInfo::verify_region_checksum(int i) {</span>
<span class="udiff-line-modified-removed">-   if (!VerifySharedSpaces) {</span>
<span class="udiff-line-modified-removed">-     return true;</span>
<span class="udiff-line-modified-added">+ bool FileMapInfo::region_crc_check(char* buf, size_t size, int expected_crc) {</span>
<span class="udiff-line-modified-added">+   int crc = ClassLoader::crc32(0, buf, (jint)size);</span>
<span class="udiff-line-modified-added">+   if (crc != expected_crc) {</span>
<span class="udiff-line-added">+     fail_continue(&quot;Checksum verification failed.&quot;);</span>
<span class="udiff-line-added">+     return false;</span>
    }
<span class="udiff-line-added">+   return true;</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-   size_t sz = space_at(i)-&gt;_used;</span>
<span class="udiff-line-modified-added">+ bool FileMapInfo::verify_region_checksum(int i) {</span>
<span class="udiff-line-added">+   assert(VerifySharedSpaces, &quot;sanity&quot;);</span>
<span class="udiff-line-added">+   size_t sz = space_at(i)-&gt;used();</span>
  
    if (sz == 0) {
      return true; // no data
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     return region_crc_check(region_addr(i), sz, space_at(i)-&gt;crc());</span>
    }
<span class="udiff-line-modified-removed">-   if ((HeapShared::is_closed_archive_heap_region(i) &amp;&amp;</span>
<span class="udiff-line-modified-removed">-        !HeapShared::closed_archive_heap_region_mapped()) ||</span>
<span class="udiff-line-modified-removed">-       (HeapShared::is_open_archive_heap_region(i) &amp;&amp;</span>
<span class="udiff-line-modified-removed">-        !HeapShared::open_archive_heap_region_mapped())) {</span>
<span class="udiff-line-modified-removed">-     return true; // archived heap data is not mapped</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-removed">-   const char* buf = region_addr(i);</span>
<span class="udiff-line-removed">-   int crc = ClassLoader::crc32(0, buf, (jint)sz);</span>
<span class="udiff-line-removed">-   if (crc != space_at(i)-&gt;_crc) {</span>
<span class="udiff-line-removed">-     fail_continue(&quot;Checksum verification failed.&quot;);</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ void FileMapInfo::unmap_regions(int regions[], int num_regions) {</span>
<span class="udiff-line-modified-added">+   for (int r = 0; r &lt; num_regions; r++) {</span>
<span class="udiff-line-modified-added">+     int idx = regions[r];</span>
<span class="udiff-line-modified-added">+     unmap_region(idx);</span>
    }
<span class="udiff-line-removed">-   return true;</span>
  }
  
  // Unmap a memory region in the address space.
  
  void FileMapInfo::unmap_region(int i) {
    assert(!HeapShared::is_heap_region(i), &quot;sanity&quot;);
<span class="udiff-line-modified-removed">-   CDSFileMapRegion* si = space_at(i);</span>
<span class="udiff-line-modified-removed">-   size_t used = si-&gt;_used;</span>
<span class="udiff-line-modified-added">+   FileMapRegion* si = space_at(i);</span>
<span class="udiff-line-modified-added">+   char* mapped_base = si-&gt;mapped_base();</span>
<span class="udiff-line-added">+   size_t used = si-&gt;used();</span>
    size_t size = align_up(used, os::vm_allocation_granularity());
  
<span class="udiff-line-modified-removed">-   if (used == 0) {</span>
<span class="udiff-line-modified-removed">-     return;</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   char* addr = region_addr(i);</span>
<span class="udiff-line-modified-removed">-   if (!os::unmap_memory(addr, size)) {</span>
<span class="udiff-line-modified-removed">-     fail_stop(&quot;Unable to unmap shared space.&quot;);</span>
<span class="udiff-line-modified-added">+   if (mapped_base != NULL &amp;&amp; size &gt; 0 &amp;&amp; si-&gt;mapped_from_file()) {</span>
<span class="udiff-line-modified-added">+     log_info(cds)(&quot;Unmapping region #%d at base &quot; INTPTR_FORMAT &quot; (%s)&quot;, i, p2i(mapped_base),</span>
<span class="udiff-line-modified-added">+                   shared_region_name[i]);</span>
<span class="udiff-line-modified-added">+     if (!os::unmap_memory(mapped_base, size)) {</span>
<span class="udiff-line-modified-added">+       fatal(&quot;os::unmap_memory failed&quot;);</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+     si-&gt;set_mapped_base(NULL);</span>
    }
  }
  
  void FileMapInfo::assert_mark(bool check) {
    if (!check) {
      fail_stop(&quot;Mark mismatch while restoring from shared file.&quot;);
    }
  }
  
  void FileMapInfo::metaspace_pointers_do(MetaspaceClosure* it) {
<span class="udiff-line-modified-removed">-   it-&gt;push(&amp;_shared_path_table);</span>
<span class="udiff-line-removed">-   for (int i=0; i&lt;_shared_path_table_size; i++) {</span>
<span class="udiff-line-removed">-     shared_path(i)-&gt;metaspace_pointers_do(it);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   _shared_path_table.metaspace_pointers_do(it);</span>
  }
  
<span class="udiff-line-removed">- </span>
  FileMapInfo* FileMapInfo::_current_info = NULL;
<span class="udiff-line-added">+ FileMapInfo* FileMapInfo::_dynamic_archive_info = NULL;</span>
  bool FileMapInfo::_heap_pointers_need_patching = false;
<span class="udiff-line-modified-removed">- Array&lt;u8&gt;* FileMapInfo::_shared_path_table = NULL;</span>
<span class="udiff-line-removed">- int FileMapInfo::_shared_path_table_size = 0;</span>
<span class="udiff-line-removed">- size_t FileMapInfo::_shared_path_entry_size = 0x1234baad;</span>
<span class="udiff-line-modified-added">+ SharedPathTable FileMapInfo::_shared_path_table;</span>
  bool FileMapInfo::_validating_shared_path_table = false;
<span class="udiff-line-added">+ bool FileMapInfo::_memory_mapping_failed = false;</span>
<span class="udiff-line-added">+ GrowableArray&lt;const char*&gt;* FileMapInfo::_non_existent_class_paths = NULL;</span>
  
  // Open the shared archive file, read and validate the header
  // information (version, boot classpath, etc.).  If initialization
  // fails, shared spaces are disabled and the file is closed. [See
  // fail_continue.]
  //
  // Validation of the archive is done in two steps:
  //
<span class="udiff-line-modified-removed">- // [1] validate_header() - done here. This checks the header, including _paths_misc_info.</span>
<span class="udiff-line-modified-added">+ // [1] validate_header() - done here.</span>
  // [2] validate_shared_path_table - this is done later, because the table is in the RW
  //     region of the archive, which is not mapped yet.
  bool FileMapInfo::initialize() {
    assert(UseSharedSpaces, &quot;UseSharedSpaces expected.&quot;);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1280,67 +1961,50 @@</span>
    }
  
    if (!open_for_read()) {
      return false;
    }
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   init_from_file(_fd);</span>
<span class="udiff-line-modified-added">+   if (!init_from_file(_fd)) {</span>
<span class="udiff-line-modified-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
    if (!validate_header()) {
      return false;
    }
    return true;
  }
  
  char* FileMapInfo::region_addr(int idx) {
<span class="udiff-line-modified-removed">-   CDSFileMapRegion* si = space_at(idx);</span>
<span class="udiff-line-modified-added">+   FileMapRegion* si = space_at(idx);</span>
    if (HeapShared::is_heap_region(idx)) {
      assert(DumpSharedSpaces, &quot;The following doesn&#39;t work at runtime&quot;);
<span class="udiff-line-modified-removed">-     return si-&gt;_used &gt; 0 ?</span>
<span class="udiff-line-modified-added">+     return si-&gt;used() &gt; 0 ?</span>
            (char*)start_address_as_decoded_with_current_oop_encoding_mode(si) : NULL;
    } else {
<span class="udiff-line-modified-removed">-     return si-&gt;_addr._base;</span>
<span class="udiff-line-modified-added">+     return si-&gt;mapped_base();</span>
    }
  }
  
<span class="udiff-line-added">+ // The 3 core spaces are MC-&gt;RW-&gt;RO</span>
<span class="udiff-line-added">+ FileMapRegion* FileMapInfo::first_core_space() const {</span>
<span class="udiff-line-added">+   return space_at(MetaspaceShared::mc);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ FileMapRegion* FileMapInfo::last_core_space() const {</span>
<span class="udiff-line-added">+   return space_at(MetaspaceShared::ro);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  int FileMapHeader::compute_crc() {
    char* start = (char*)this;
    // start computing from the field after _crc
    char* buf = (char*)&amp;_crc + sizeof(_crc);
<span class="udiff-line-modified-removed">-   size_t sz = sizeof(FileMapHeader) - (buf - start);</span>
<span class="udiff-line-modified-added">+   size_t sz = _header_size - (buf - start);</span>
    int crc = ClassLoader::crc32(0, buf, (jint)sz);
    return crc;
  }
  
  // This function should only be called during run time with UseSharedSpaces enabled.
  bool FileMapHeader::validate() {
<span class="udiff-line-removed">-   if (VerifySharedSpaces &amp;&amp; compute_crc() != _crc) {</span>
<span class="udiff-line-removed">-     FileMapInfo::fail_continue(&quot;Header checksum verification failed.&quot;);</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (!Arguments::has_jimage()) {</span>
<span class="udiff-line-removed">-     FileMapInfo::fail_continue(&quot;The shared archive file cannot be used with an exploded module build.&quot;);</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (_version != CURRENT_CDS_ARCHIVE_VERSION) {</span>
<span class="udiff-line-removed">-     FileMapInfo::fail_continue(&quot;The shared archive file is the wrong version.&quot;);</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   if (_magic != CDS_ARCHIVE_MAGIC) {</span>
<span class="udiff-line-removed">-     FileMapInfo::fail_continue(&quot;The shared archive file has a bad magic number.&quot;);</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   char header_version[JVM_IDENT_MAX];</span>
<span class="udiff-line-removed">-   get_header_version(header_version);</span>
<span class="udiff-line-removed">-   if (strncmp(_jvm_ident, header_version, JVM_IDENT_MAX-1) != 0) {</span>
<span class="udiff-line-removed">-     log_info(class, path)(&quot;expected: %s&quot;, header_version);</span>
<span class="udiff-line-removed">-     log_info(class, path)(&quot;actual:   %s&quot;, _jvm_ident);</span>
<span class="udiff-line-removed">-     FileMapInfo::fail_continue(&quot;The shared archive file was created by a different&quot;</span>
<span class="udiff-line-removed">-                   &quot; version or build of HotSpot&quot;);</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-removed">-   }</span>
    if (_obj_alignment != ObjectAlignmentInBytes) {
      FileMapInfo::fail_continue(&quot;The shared archive file&#39;s ObjectAlignmentInBytes of %d&quot;
                    &quot; does not equal the current ObjectAlignmentInBytes of &quot; INTX_FORMAT &quot;.&quot;,
                    _obj_alignment, ObjectAlignmentInBytes);
      return false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1386,69 +2050,55 @@</span>
    if (_allow_archiving_with_java_agent) {
      warning(&quot;This archive was created with AllowArchivingWithJavaAgent. It should be used &quot;
              &quot;for testing purposes only and should not be used in a production environment&quot;);
    }
  
<span class="udiff-line-added">+   log_info(cds)(&quot;Archive was created with UseCompressedOops = %d, UseCompressedClassPointers = %d&quot;,</span>
<span class="udiff-line-added">+                           compressed_oops(), compressed_class_pointers());</span>
<span class="udiff-line-added">+   if (compressed_oops() != UseCompressedOops || compressed_class_pointers() != UseCompressedClassPointers) {</span>
<span class="udiff-line-added">+     FileMapInfo::fail_continue(&quot;Unable to use shared archive.\nThe saved state of UseCompressedOops and UseCompressedClassPointers is &quot;</span>
<span class="udiff-line-added">+                                &quot;different from runtime, CDS will be disabled.&quot;);</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    return true;
  }
  
  bool FileMapInfo::validate_header() {
<span class="udiff-line-modified-removed">-   bool status = _header-&gt;validate();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (status) {</span>
<span class="udiff-line-removed">-     if (!ClassLoader::check_shared_paths_misc_info(_paths_misc_info, _header-&gt;_paths_misc_info_size)) {</span>
<span class="udiff-line-removed">-       if (!PrintSharedArchiveAndExit) {</span>
<span class="udiff-line-removed">-         fail_continue(&quot;shared class paths mismatch (hint: enable -Xlog:class+path=info to diagnose the failure)&quot;);</span>
<span class="udiff-line-removed">-         status = false;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (_paths_misc_info != NULL) {</span>
<span class="udiff-line-removed">-     FREE_C_HEAP_ARRAY(char, _paths_misc_info);</span>
<span class="udiff-line-removed">-     _paths_misc_info = NULL;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return status;</span>
<span class="udiff-line-modified-added">+   return header()-&gt;validate();</span>
  }
  
  // Check if a given address is within one of the shared regions
  bool FileMapInfo::is_in_shared_region(const void* p, int idx) {
    assert(idx == MetaspaceShared::ro ||
           idx == MetaspaceShared::rw ||
<span class="udiff-line-modified-removed">-          idx == MetaspaceShared::mc ||</span>
<span class="udiff-line-removed">-          idx == MetaspaceShared::md, &quot;invalid region index&quot;);</span>
<span class="udiff-line-modified-added">+          idx == MetaspaceShared::mc, &quot;invalid region index&quot;);</span>
    char* base = region_addr(idx);
<span class="udiff-line-modified-removed">-   if (p &gt;= base &amp;&amp; p &lt; base + space_at(idx)-&gt;_used) {</span>
<span class="udiff-line-modified-added">+   if (p &gt;= base &amp;&amp; p &lt; base + space_at(idx)-&gt;used()) {</span>
      return true;
    }
    return false;
  }
  
  // Unmap mapped regions of shared space.
  void FileMapInfo::stop_sharing_and_unmap(const char* msg) {
<span class="udiff-line-modified-removed">-   MetaspaceObj::set_shared_metaspace_range(NULL, NULL);</span>
<span class="udiff-line-modified-added">+   MetaspaceShared::set_shared_metaspace_range(NULL, NULL, NULL);</span>
  
    FileMapInfo *map_info = FileMapInfo::current_info();
    if (map_info) {
      map_info-&gt;fail_continue(&quot;%s&quot;, msg);
      for (int i = 0; i &lt; MetaspaceShared::num_non_heap_spaces; i++) {
        if (!HeapShared::is_heap_region(i)) {
<span class="udiff-line-modified-removed">-         char *addr = map_info-&gt;region_addr(i);</span>
<span class="udiff-line-removed">-         if (addr != NULL) {</span>
<span class="udiff-line-removed">-           map_info-&gt;unmap_region(i);</span>
<span class="udiff-line-removed">-           map_info-&gt;space_at(i)-&gt;_addr._base = NULL;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         map_info-&gt;unmap_region(i);</span>
        }
      }
      // Dealloc the archive heap regions only without unmapping. The regions are part
      // of the java heap. Unmapping of the heap regions are managed by GC.
      map_info-&gt;dealloc_archive_heap_regions(open_archive_heap_ranges,
<span class="udiff-line-modified-removed">-                                            num_open_archive_heap_ranges,</span>
<span class="udiff-line-removed">-                                            true);</span>
<span class="udiff-line-modified-added">+                                            num_open_archive_heap_ranges);</span>
      map_info-&gt;dealloc_archive_heap_regions(closed_archive_heap_ranges,
<span class="udiff-line-modified-removed">-                                            num_closed_archive_heap_ranges,</span>
<span class="udiff-line-removed">-                                            false);</span>
<span class="udiff-line-modified-added">+                                            num_closed_archive_heap_ranges);</span>
    } else if (DumpSharedSpaces) {
      fail_stop(&quot;%s&quot;, msg);
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1457,11 +2107,11 @@</span>
  
  ClassPathEntry* FileMapInfo::get_classpath_entry_for_jvmti(int i, TRAPS) {
    ClassPathEntry* ent = _classpath_entries_for_jvmti[i];
    if (ent == NULL) {
      if (i == 0) {
<span class="udiff-line-modified-removed">-       ent = ClassLoader:: get_jrt_entry();</span>
<span class="udiff-line-modified-added">+       ent = ClassLoader::get_jrt_entry();</span>
        assert(ent != NULL, &quot;must be&quot;);
      } else {
        SharedClassPathEntry* scpe = shared_path(i);
        assert(scpe-&gt;is_jar(), &quot;must be&quot;); // other types of scpe will not produce archived classes
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1470,15 +2120,15 @@</span>
        if (os::stat(path, &amp;st) != 0) {
          char *msg = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, strlen(path) + 128); ;
          jio_snprintf(msg, strlen(path) + 127, &quot;error in opening JAR file %s&quot;, path);
          THROW_MSG_(vmSymbols::java_io_IOException(), msg, NULL);
        } else {
<span class="udiff-line-modified-removed">-         ent = ClassLoader::create_class_path_entry(path, &amp;st, /*throw_exception=*/true, false, CHECK_NULL);</span>
<span class="udiff-line-modified-added">+         ent = ClassLoader::create_class_path_entry(path, &amp;st, /*throw_exception=*/true, false, false, CHECK_NULL);</span>
        }
      }
  
<span class="udiff-line-modified-removed">-     MutexLocker mu(CDSClassFileStream_lock, THREAD);</span>
<span class="udiff-line-modified-added">+     MutexLocker mu(THREAD, CDSClassFileStream_lock);</span>
      if (_classpath_entries_for_jvmti[i] == NULL) {
        _classpath_entries_for_jvmti[i] = ent;
      } else {
        // Another thread has beat me to creating this entry
        delete ent;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1487,21 +2137,26 @@</span>
    }
  
    return ent;
  }
  
<span class="udiff-line-modified-removed">- ClassFileStream* FileMapInfo::open_stream_for_jvmti(InstanceKlass* ik, TRAPS) {</span>
<span class="udiff-line-modified-added">+ ClassFileStream* FileMapInfo::open_stream_for_jvmti(InstanceKlass* ik, Handle class_loader, TRAPS) {</span>
    int path_index = ik-&gt;shared_classpath_index();
    assert(path_index &gt;= 0, &quot;should be called for shared built-in classes only&quot;);
<span class="udiff-line-modified-removed">-   assert(path_index &lt; (int)_shared_path_table_size, &quot;sanity&quot;);</span>
<span class="udiff-line-modified-added">+   assert(path_index &lt; (int)get_number_of_shared_paths(), &quot;sanity&quot;);</span>
  
    ClassPathEntry* cpe = get_classpath_entry_for_jvmti(path_index, CHECK_NULL);
    assert(cpe != NULL, &quot;must be&quot;);
  
    Symbol* name = ik-&gt;name();
    const char* const class_name = name-&gt;as_C_string();
    const char* const file_name = ClassLoader::file_name_for_class_name(class_name,
                                                                        name-&gt;utf8_length());
<span class="udiff-line-modified-removed">-   return cpe-&gt;open_stream(file_name, THREAD);</span>
<span class="udiff-line-modified-added">+   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());</span>
<span class="udiff-line-added">+   ClassFileStream* cfs = cpe-&gt;open_stream_for_loader(file_name, loader_data, THREAD);</span>
<span class="udiff-line-added">+   assert(cfs != NULL, &quot;must be able to read the classfile data of shared classes for built-in loaders.&quot;);</span>
<span class="udiff-line-added">+   log_debug(cds, jvmti)(&quot;classfile data for %s [%d: %s] = %d bytes&quot;, class_name, path_index,</span>
<span class="udiff-line-added">+                         cfs-&gt;source(), cfs-&gt;length());</span>
<span class="udiff-line-added">+   return cfs;</span>
  }
  
  #endif
</pre>
<center><a href="arena.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="filemap.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
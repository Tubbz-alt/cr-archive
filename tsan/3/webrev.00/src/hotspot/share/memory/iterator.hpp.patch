diff a/src/hotspot/share/memory/iterator.hpp b/src/hotspot/share/memory/iterator.hpp
--- a/src/hotspot/share/memory/iterator.hpp
+++ b/src/hotspot/share/memory/iterator.hpp
@@ -34,15 +34,23 @@
 class ReferenceDiscoverer;
 class DataLayout;
 class KlassClosure;
 class ClassLoaderData;
 class Symbol;
+class Metadata;
+class Thread;
 
 // The following classes are C++ `closures` for iterating over objects, roots and spaces
 
 class Closure : public StackObj { };
 
+// Thread iterator
+class ThreadClosure: public Closure {
+ public:
+  virtual void do_thread(Thread* thread) = 0;
+};
+
 // OopClosure is used for iterating through references to Java objects.
 class OopClosure : public Closure {
  public:
   virtual void do_oop(oop* o) = 0;
   virtual void do_oop(narrowOop* o) = 0;
@@ -122,10 +130,15 @@
 class CLDClosure : public Closure {
  public:
   virtual void do_cld(ClassLoaderData* cld) = 0;
 };
 
+class MetadataClosure : public Closure {
+ public:
+  virtual void do_metadata(Metadata* md) = 0;
+};
+
 
 class CLDToOopClosure : public CLDClosure {
   OopClosure*       _oop_closure;
   int               _cld_claim;
 
@@ -136,22 +149,32 @@
       _cld_claim(cld_claim) {}
 
   void do_cld(ClassLoaderData* cld);
 };
 
-// The base class for all concurrent marking closures,
-// that participates in class unloading.
-// It's used to proxy through the metadata to the oops defined in them.
-class MetadataVisitingOopIterateClosure: public OopIterateClosure {
+class ClaimMetadataVisitingOopIterateClosure : public OopIterateClosure {
+ protected:
+  const int _claim;
+
  public:
-  MetadataVisitingOopIterateClosure(ReferenceDiscoverer* rd = NULL) : OopIterateClosure(rd) { }
+  ClaimMetadataVisitingOopIterateClosure(int claim, ReferenceDiscoverer* rd = NULL) :
+      OopIterateClosure(rd),
+      _claim(claim) { }
 
   virtual bool do_metadata() { return true; }
   virtual void do_klass(Klass* k);
   virtual void do_cld(ClassLoaderData* cld);
 };
 
+// The base class for all concurrent marking closures,
+// that participates in class unloading.
+// It's used to proxy through the metadata to the oops defined in them.
+class MetadataVisitingOopIterateClosure: public ClaimMetadataVisitingOopIterateClosure {
+ public:
+  MetadataVisitingOopIterateClosure(ReferenceDiscoverer* rd = NULL);
+};
+
 // ObjectClosure is used for iterating through an object space
 
 class ObjectClosure : public Closure {
  public:
   // Called for each object.
@@ -181,38 +204,10 @@
 public:
   void do_object(oop obj);
   ObjectToOopClosure(OopIterateClosure* cl) : _cl(cl) {}
 };
 
-// A version of ObjectClosure that is expected to be robust
-// in the face of possibly uninitialized objects.
-class ObjectClosureCareful : public ObjectClosure {
- public:
-  virtual size_t do_object_careful_m(oop p, MemRegion mr) = 0;
-  virtual size_t do_object_careful(oop p) = 0;
-};
-
-// The following are used in CompactibleFreeListSpace and
-// ConcurrentMarkSweepGeneration.
-
-// Blk closure (abstract class)
-class BlkClosure : public StackObj {
- public:
-  virtual size_t do_blk(HeapWord* addr) = 0;
-};
-
-// A version of BlkClosure that is expected to be robust
-// in the face of possibly uninitialized objects.
-class BlkClosureCareful : public BlkClosure {
- public:
-  size_t do_blk(HeapWord* addr) {
-    guarantee(false, "call do_blk_careful instead");
-    return 0;
-  }
-  virtual size_t do_blk_careful(HeapWord* addr) = 0;
-};
-
 // SpaceClosure is used for iterating over spaces
 
 class Space;
 class CompactibleSpace;
 
@@ -314,10 +309,13 @@
   virtual void do_ptr(void** p) = 0;
 
   // Read/write the 32-bit unsigned integer pointed to by p.
   virtual void do_u4(u4* p) = 0;
 
+  // Read/write the bool pointed to by p.
+  virtual void do_bool(bool* p) = 0;
+
   // Read/write the region specified.
   virtual void do_region(u_char* start, size_t size) = 0;
 
   // Check/write the tag.  If reading, then compare the tag against
   // the passed in value and fail is they don't match.  This allows

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/heap.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="freeList.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="heap.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/heap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;memory/heap.hpp&quot;
 27 #include &quot;oops/oop.inline.hpp&quot;
 28 #include &quot;runtime/os.hpp&quot;
 29 #include &quot;services/memTracker.hpp&quot;
 30 #include &quot;utilities/align.hpp&quot;

 31 
 32 size_t CodeHeap::header_size() {
 33   return sizeof(HeapBlock);
 34 }
 35 
 36 
 37 // Implementation of Heap
 38 
 39 CodeHeap::CodeHeap(const char* name, const int code_blob_type)
 40   : _code_blob_type(code_blob_type) {
 41   _name                         = name;
 42   _number_of_committed_segments = 0;
 43   _number_of_reserved_segments  = 0;
 44   _segment_size                 = 0;
 45   _log2_segment_size            = 0;
 46   _next_segment                 = 0;
 47   _freelist                     = NULL;

 48   _freelist_segments            = 0;
 49   _freelist_length              = 0;
 50   _max_allocated_capacity       = 0;
 51   _blob_count                   = 0;
 52   _nmethod_count                = 0;
 53   _adapter_count                = 0;
 54   _full_count                   = 0;

 55 }
 56 


 57 















 58 void CodeHeap::mark_segmap_as_free(size_t beg, size_t end) {
<span class="line-modified"> 59   assert(              beg &lt;  _number_of_committed_segments, &quot;interval begin out of bounds&quot;);</span>
<span class="line-modified"> 60   assert(beg &lt;  end &amp;&amp; end &lt;= _number_of_committed_segments, &quot;interval end   out of bounds&quot;);</span>
<span class="line-modified"> 61   // setup _segmap pointers for faster indexing</span>
<span class="line-modified"> 62   address p = (address)_segmap.low() + beg;</span>
<span class="line-modified"> 63   address q = (address)_segmap.low() + end;</span>
<span class="line-modified"> 64   // initialize interval</span>
<span class="line-modified"> 65   while (p &lt; q) *p++ = free_sentinel;</span>
<span class="line-modified"> 66 }</span>
<span class="line-modified"> 67 </span>
<span class="line-modified"> 68 </span>
<span class="line-modified"> 69 void CodeHeap::mark_segmap_as_used(size_t beg, size_t end) {</span>
<span class="line-modified"> 70   assert(              beg &lt;  _number_of_committed_segments, &quot;interval begin out of bounds&quot;);</span>
<span class="line-modified"> 71   assert(beg &lt;  end &amp;&amp; end &lt;= _number_of_committed_segments, &quot;interval end   out of bounds&quot;);</span>
<span class="line-modified"> 72   // setup _segmap pointers for faster indexing</span>
<span class="line-modified"> 73   address p = (address)_segmap.low() + beg;</span>
<span class="line-modified"> 74   address q = (address)_segmap.low() + end;</span>
<span class="line-modified"> 75   // initialize interval</span>
<span class="line-modified"> 76   int i = 0;</span>
<span class="line-modified"> 77   while (p &lt; q) {</span>
<span class="line-modified"> 78     *p++ = i++;</span>
<span class="line-modified"> 79     if (i == free_sentinel) i = 1;</span>

































































 80   }
 81 }
 82 




















 83 
 84 static size_t align_to_page_size(size_t size) {
 85   const size_t alignment = (size_t)os::vm_page_size();
 86   assert(is_power_of_2(alignment), &quot;no kidding ???&quot;);
 87   return (size + alignment - 1) &amp; ~(alignment - 1);
 88 }
 89 
 90 
 91 void CodeHeap::on_code_mapping(char* base, size_t size) {
 92 #ifdef LINUX
 93   extern void linux_wrap_code(char* base, size_t size);
 94   linux_wrap_code(base, size);
 95 #endif
 96 }
 97 
 98 
 99 bool CodeHeap::reserve(ReservedSpace rs, size_t committed_size, size_t segment_size) {
100   assert(rs.size() &gt;= committed_size, &quot;reserved &lt; committed&quot;);
101   assert(segment_size &gt;= sizeof(FreeBlock), &quot;segment size is too small&quot;);
102   assert(is_power_of_2(segment_size), &quot;segment_size must be a power of 2&quot;);
</pre>
<hr />
<pre>
123 
124   on_code_mapping(_memory.low(), _memory.committed_size());
125   _number_of_committed_segments = size_to_segments(_memory.committed_size());
126   _number_of_reserved_segments  = size_to_segments(_memory.reserved_size());
127   assert(_number_of_reserved_segments &gt;= _number_of_committed_segments, &quot;just checking&quot;);
128   const size_t reserved_segments_alignment = MAX2((size_t)os::vm_page_size(), granularity);
129   const size_t reserved_segments_size = align_up(_number_of_reserved_segments, reserved_segments_alignment);
130   const size_t committed_segments_size = align_to_page_size(_number_of_committed_segments);
131 
132   // reserve space for _segmap
133   if (!_segmap.initialize(reserved_segments_size, committed_segments_size)) {
134     return false;
135   }
136 
137   MemTracker::record_virtual_memory_type((address)_segmap.low_boundary(), mtCode);
138 
139   assert(_segmap.committed_size() &gt;= (size_t) _number_of_committed_segments, &quot;could not commit  enough space for segment map&quot;);
140   assert(_segmap.reserved_size()  &gt;= (size_t) _number_of_reserved_segments , &quot;could not reserve enough space for segment map&quot;);
141   assert(_segmap.reserved_size()  &gt;= _segmap.committed_size()     , &quot;just checking&quot;);
142 
<span class="line-modified">143   // initialize remaining instance variables</span>
144   clear();

145   return true;
146 }
147 
148 
149 bool CodeHeap::expand_by(size_t size) {
150   // expand _memory space
151   size_t dm = align_to_page_size(_memory.committed_size() + size) - _memory.committed_size();
152   if (dm &gt; 0) {
153     // Use at least the available uncommitted space if &#39;size&#39; is larger
154     if (_memory.uncommitted_size() != 0 &amp;&amp; dm &gt; _memory.uncommitted_size()) {
155       dm = _memory.uncommitted_size();
156     }
157     char* base = _memory.low() + _memory.committed_size();
158     if (!_memory.expand_by(dm)) return false;
159     on_code_mapping(base, dm);
160     size_t i = _number_of_committed_segments;
161     _number_of_committed_segments = size_to_segments(_memory.committed_size());
162     assert(_number_of_reserved_segments == size_to_segments(_memory.reserved_size()), &quot;number of reserved segments should not change&quot;);
163     assert(_number_of_reserved_segments &gt;= _number_of_committed_segments, &quot;just checking&quot;);
164     // expand _segmap space
165     size_t ds = align_to_page_size(_number_of_committed_segments) - _segmap.committed_size();
166     if ((ds &gt; 0) &amp;&amp; !_segmap.expand_by(ds)) {
167       return false;
168     }
169     assert(_segmap.committed_size() &gt;= (size_t) _number_of_committed_segments, &quot;just checking&quot;);
<span class="line-modified">170     // initialize additional segmap entries</span>
<span class="line-modified">171     mark_segmap_as_free(i, _number_of_committed_segments);</span>
172   }
173   return true;
174 }
175 
<span class="line-removed">176 void CodeHeap::clear() {</span>
<span class="line-removed">177   _next_segment = 0;</span>
<span class="line-removed">178   mark_segmap_as_free(0, _number_of_committed_segments);</span>
<span class="line-removed">179 }</span>
<span class="line-removed">180 </span>
181 
182 void* CodeHeap::allocate(size_t instance_size) {
183   size_t number_of_segments = size_to_segments(instance_size + header_size());
184   assert(segments_to_size(number_of_segments) &gt;= sizeof(FreeBlock), &quot;not enough room for FreeList&quot;);
185 
186   // First check if we can satisfy request from freelist
187   NOT_PRODUCT(verify());
188   HeapBlock* block = search_freelist(number_of_segments);
189   NOT_PRODUCT(verify());
190 
191   if (block != NULL) {
<span class="line-modified">192     assert(block-&gt;length() &gt;= number_of_segments &amp;&amp; block-&gt;length() &lt; number_of_segments + CodeCacheMinBlockLength, &quot;sanity check&quot;);</span>
<span class="line-removed">193     assert(!block-&gt;free(), &quot;must be marked free&quot;);</span>
194     guarantee((char*) block &gt;= _memory.low_boundary() &amp;&amp; (char*) block &lt; _memory.high(),
195               &quot;The newly allocated block &quot; INTPTR_FORMAT &quot; is not within the heap &quot;
196               &quot;starting with &quot;  INTPTR_FORMAT &quot; and ending with &quot;  INTPTR_FORMAT,
197               p2i(block), p2i(_memory.low_boundary()), p2i(_memory.high()));
<span class="line-removed">198     DEBUG_ONLY(memset((void*)block-&gt;allocated_space(), badCodeHeapNewVal, instance_size));</span>
199     _max_allocated_capacity = MAX2(_max_allocated_capacity, allocated_capacity());
200     _blob_count++;
201     return block-&gt;allocated_space();
202   }
203 
204   // Ensure minimum size for allocation to the heap.
205   number_of_segments = MAX2((int)CodeCacheMinBlockLength, (int)number_of_segments);
206 
207   if (_next_segment + number_of_segments &lt;= _number_of_committed_segments) {
<span class="line-modified">208     mark_segmap_as_used(_next_segment, _next_segment + number_of_segments);</span>
<span class="line-modified">209     HeapBlock* b =  block_at(_next_segment);</span>
<span class="line-modified">210     b-&gt;initialize(number_of_segments);</span>
211     _next_segment += number_of_segments;
<span class="line-modified">212     guarantee((char*) b &gt;= _memory.low_boundary() &amp;&amp; (char*) block &lt; _memory.high(),</span>
213               &quot;The newly allocated block &quot; INTPTR_FORMAT &quot; is not within the heap &quot;
214               &quot;starting with &quot;  INTPTR_FORMAT &quot; and ending with &quot; INTPTR_FORMAT,
<span class="line-modified">215               p2i(b), p2i(_memory.low_boundary()), p2i(_memory.high()));</span>
<span class="line-removed">216     DEBUG_ONLY(memset((void *)b-&gt;allocated_space(), badCodeHeapNewVal, instance_size));</span>
217     _max_allocated_capacity = MAX2(_max_allocated_capacity, allocated_capacity());
218     _blob_count++;
<span class="line-modified">219     return b-&gt;allocated_space();</span>
220   } else {
221     return NULL;
222   }
223 }
224 

























225 void CodeHeap::deallocate_tail(void* p, size_t used_size) {
226   assert(p == find_start(p), &quot;illegal deallocation&quot;);
227   // Find start of HeapBlock
228   HeapBlock* b = (((HeapBlock *)p) - 1);
229   assert(b-&gt;allocated_space() == p, &quot;sanity check&quot;);
<span class="line-modified">230   size_t used_number_of_segments = size_to_segments(used_size + header_size());</span>
231   size_t actual_number_of_segments = b-&gt;length();


232   guarantee(used_number_of_segments &lt;= actual_number_of_segments, &quot;Must be!&quot;);
<span class="line-modified">233   guarantee(b == block_at(_next_segment - actual_number_of_segments), &quot;Intermediate allocation!&quot;);</span>
<span class="line-modified">234   size_t number_of_segments_to_deallocate = actual_number_of_segments - used_number_of_segments;</span>
<span class="line-modified">235   _next_segment -= number_of_segments_to_deallocate;</span>
<span class="line-modified">236   mark_segmap_as_free(_next_segment, _next_segment + number_of_segments_to_deallocate);</span>
<span class="line-removed">237   b-&gt;initialize(used_number_of_segments);</span>
238 }
239 
240 void CodeHeap::deallocate(void* p) {
241   assert(p == find_start(p), &quot;illegal deallocation&quot;);
242   // Find start of HeapBlock
243   HeapBlock* b = (((HeapBlock *)p) - 1);
244   assert(b-&gt;allocated_space() == p, &quot;sanity check&quot;);
245   guarantee((char*) b &gt;= _memory.low_boundary() &amp;&amp; (char*) b &lt; _memory.high(),
246             &quot;The block to be deallocated &quot; INTPTR_FORMAT &quot; is not within the heap &quot;
247             &quot;starting with &quot;  INTPTR_FORMAT &quot; and ending with &quot; INTPTR_FORMAT,
248             p2i(b), p2i(_memory.low_boundary()), p2i(_memory.high()));
<span class="line-removed">249   DEBUG_ONLY(memset((void *)b-&gt;allocated_space(), badCodeHeapFreeVal,</span>
<span class="line-removed">250              segments_to_size(b-&gt;length()) - sizeof(HeapBlock)));</span>
251   add_to_freelist(b);
252   NOT_PRODUCT(verify());
253 }
254 
255 /**
<span class="line-modified">256  * Uses segment map to find the the start (header) of a nmethod. This works as follows:</span>
<span class="line-modified">257  * The memory of the code cache is divided into &#39;segments&#39;. The size of a segment is</span>
<span class="line-modified">258  * determined by -XX:CodeCacheSegmentSize=XX. Allocation in the code cache can only</span>
<span class="line-modified">259  * happen at segment boundaries. A pointer in the code cache can be mapped to a segment</span>
<span class="line-modified">260  * by calling segment_for(addr). Each time memory is requested from the code cache,</span>
<span class="line-modified">261  * the segmap is updated accordingly. See the following example, which illustrates the</span>
<span class="line-modified">262  * state of code cache and the segment map: (seg -&gt; segment, nm -&gt;nmethod)</span>






























263  *
264  *          code cache          segmap
265  *         -----------        ---------
266  * seg 1   | nm 1    |   -&gt;   | 0     |
267  * seg 2   | nm 1    |   -&gt;   | 1     |
268  * ...     | nm 1    |   -&gt;   | ..    |

269  * seg m   | nm 2    |   -&gt;   | 0     |
270  * seg m+1 | nm 2    |   -&gt;   | 1     |
271  * ...     | nm 2    |   -&gt;   | 2     |
272  * ...     | nm 2    |   -&gt;   | ..    |
<span class="line-modified">273  * ...     | nm 2    |   -&gt;   | 0xFE  |</span>
<span class="line-modified">274  * seg m+n | nm 2    |   -&gt;   | 1     |</span>

275  * ...     | nm 2    |   -&gt;   |       |
276  *
<span class="line-modified">277  * A value of &#39;0&#39; in the segmap indicates that this segment contains the beginning of</span>
<span class="line-modified">278  * an nmethod. Let&#39;s walk through a simple example: If we want to find the start of</span>
<span class="line-modified">279  * an nmethod that falls into seg 2, we read the value of the segmap[2]. The value</span>
<span class="line-modified">280  * is an offset that points to the segment that contains the start of the nmethod.</span>
<span class="line-modified">281  * Another example: If we want to get the start of nm 2, and we happen to get a pointer</span>
<span class="line-modified">282  * that points to seg m+n, we first read seg[n+m], which returns &#39;1&#39;. So we have to</span>
<span class="line-modified">283  * do one more read of the segmap[m+n-1] to finally get the segment header.</span>






284  */
<span class="line-modified">285 void* CodeHeap::find_start(void* p) const {</span>





286   if (!contains(p)) {
287     return NULL;
288   }
<span class="line-modified">289   size_t seg_idx = segment_for(p);</span>
290   address seg_map = (address)_segmap.low();




291   if (is_segment_unused(seg_map[seg_idx])) {
292     return NULL;
293   }


294   while (seg_map[seg_idx] &gt; 0) {




295     seg_idx -= (int)seg_map[seg_idx];
296   }
297 
<span class="line-modified">298   HeapBlock* h = block_at(seg_idx);</span>
<span class="line-modified">299   if (h-&gt;free()) {</span>
<span class="line-modified">300     return NULL;</span>
<span class="line-modified">301   }</span>
<span class="line-modified">302   return h-&gt;allocated_space();</span>




303 }
304 


305 CodeBlob* CodeHeap::find_blob_unsafe(void* start) const {
306   CodeBlob* result = (CodeBlob*)CodeHeap::find_start(start);
<span class="line-modified">307   if (result != NULL &amp;&amp; result-&gt;blob_contains((address)start)) {</span>
<span class="line-removed">308     return result;</span>
<span class="line-removed">309   }</span>
<span class="line-removed">310   return NULL;</span>
311 }
312 
313 size_t CodeHeap::alignment_unit() const {
314   // this will be a power of two
315   return _segment_size;
316 }
317 
318 
319 size_t CodeHeap::alignment_offset() const {
320   // The lowest address in any allocated block will be
321   // equal to alignment_offset (mod alignment_unit).
322   return sizeof(HeapBlock) &amp; (_segment_size - 1);
323 }
324 
325 // Returns the current block if available and used.
326 // If not, it returns the subsequent block (if available), NULL otherwise.
327 // Free blocks are merged, therefore there is at most one free block
328 // between two used ones. As a result, the subsequent block (if available) is
329 // guaranteed to be used.

330 void* CodeHeap::next_used(HeapBlock* b) const {
331   if (b != NULL &amp;&amp; b-&gt;free()) b = next_block(b);
332   assert(b == NULL || !b-&gt;free(), &quot;must be in use or at end of heap&quot;);
333   return (b == NULL) ? NULL : b-&gt;allocated_space();
334 }
335 
336 // Returns the first used HeapBlock

337 HeapBlock* CodeHeap::first_block() const {
338   if (_next_segment &gt; 0)
339     return block_at(0);
340   return NULL;
341 }
342 

343 HeapBlock* CodeHeap::block_start(void* q) const {
344   HeapBlock* b = (HeapBlock*)find_start(q);
345   if (b == NULL) return NULL;
346   return b - 1;
347 }
348 
<span class="line-modified">349 // Returns the next Heap block an offset into one</span>

350 HeapBlock* CodeHeap::next_block(HeapBlock *b) const {
351   if (b == NULL) return NULL;
352   size_t i = segment_for(b) + b-&gt;length();
353   if (i &lt; _next_segment)
354     return block_at(i);
355   return NULL;
356 }
357 
358 
359 // Returns current capacity
360 size_t CodeHeap::capacity() const {
361   return _memory.committed_size();
362 }
363 
364 size_t CodeHeap::max_capacity() const {
365   return _memory.reserved_size();
366 }
367 
368 int CodeHeap::allocated_segments() const {
369   return (int)_next_segment;
</pre>
<hr />
<pre>
387 }
388 
389 // Inserts block b after a
390 void CodeHeap::insert_after(FreeBlock* a, FreeBlock* b) {
391   assert(a != NULL &amp;&amp; b != NULL, &quot;must be real pointers&quot;);
392 
393   // Link b into the list after a
394   b-&gt;set_link(a-&gt;link());
395   a-&gt;set_link(b);
396 
397   // See if we can merge blocks
398   merge_right(b); // Try to make b bigger
399   merge_right(a); // Try to make a include b
400 }
401 
402 // Try to merge this block with the following block
403 bool CodeHeap::merge_right(FreeBlock* a) {
404   assert(a-&gt;free(), &quot;must be a free block&quot;);
405   if (following_block(a) == a-&gt;link()) {
406     assert(a-&gt;link() != NULL &amp;&amp; a-&gt;link()-&gt;free(), &quot;must be free too&quot;);
<span class="line-modified">407     // Update block a to include the following block</span>



408     a-&gt;set_length(a-&gt;length() + a-&gt;link()-&gt;length());
409     a-&gt;set_link(a-&gt;link()-&gt;link());
<span class="line-modified">410     // Update find_start map</span>
<span class="line-modified">411     size_t beg = segment_for(a);</span>
<span class="line-modified">412     mark_segmap_as_used(beg, beg + a-&gt;length());</span>





413     _freelist_length--;
414     return true;
415   }
416   return false;
417 }
418 
419 
420 void CodeHeap::add_to_freelist(HeapBlock* a) {
421   FreeBlock* b = (FreeBlock*)a;

422   _freelist_length++;
423 
<span class="line-modified">424   assert(b != _freelist, &quot;cannot be removed twice&quot;);</span>

425 

426 
427   // Mark as free and update free space count
428   _freelist_segments += b-&gt;length();
429   b-&gt;set_free();

430 
431   // First element in list?
432   if (_freelist == NULL) {
<span class="line-removed">433     _freelist = b;</span>
434     b-&gt;set_link(NULL);

435     return;
436   }
437 
438   // Since the freelist is ordered (smaller addresses -&gt; larger addresses) and the
439   // element we want to insert into the freelist has a smaller address than the first
440   // element, we can simply add &#39;b&#39; as the first element and we are done.
441   if (b &lt; _freelist) {
442     // Insert first in list
443     b-&gt;set_link(_freelist);
444     _freelist = b;
445     merge_right(_freelist);
446     return;
447   }
448 
<span class="line-modified">449   // Scan for right place to put into list. List</span>
<span class="line-modified">450   // is sorted by increasing addresses</span>
451   FreeBlock* prev = _freelist;
452   FreeBlock* cur  = _freelist-&gt;link();







453   while(cur != NULL &amp;&amp; cur &lt; b) {
454     assert(prev &lt; cur, &quot;Freelist must be ordered&quot;);
455     prev = cur;
456     cur  = cur-&gt;link();
457   }
458   assert((prev &lt; b) &amp;&amp; (cur == NULL || b &lt; cur), &quot;free-list must be ordered&quot;);
459   insert_after(prev, b);

460 }
461 
462 /**
463  * Search freelist for an entry on the list with the best fit.
464  * @return NULL, if no one was found
465  */
<span class="line-modified">466 FreeBlock* CodeHeap::search_freelist(size_t length) {</span>
<span class="line-modified">467   FreeBlock* found_block = NULL;</span>
<span class="line-modified">468   FreeBlock* found_prev  = NULL;</span>
<span class="line-modified">469   size_t     found_length = 0;</span>
470 

471   FreeBlock* prev = NULL;
<span class="line-modified">472   FreeBlock* cur = _freelist;</span>
473 
<span class="line-modified">474   // Search for first block that fits</span>
<span class="line-removed">475   while(cur != NULL) {</span>
<span class="line-removed">476     if (cur-&gt;length() &gt;= length) {</span>
<span class="line-removed">477       // Remember block, its previous element, and its length</span>
<span class="line-removed">478       found_block = cur;</span>
<span class="line-removed">479       found_prev  = prev;</span>
<span class="line-removed">480       found_length = found_block-&gt;length();</span>
481 








482       break;





483     }
484     // Next element in list
485     prev = cur;
486     cur  = cur-&gt;link();
487   }
488 
489   if (found_block == NULL) {
490     // None found
491     return NULL;
492   }
493 
494   // Exact (or at least good enough) fit. Remove from list.
495   // Don&#39;t leave anything on the freelist smaller than CodeCacheMinBlockLength.
496   if (found_length - length &lt; CodeCacheMinBlockLength) {
497     _freelist_length--;
498     length = found_length;
499     if (found_prev == NULL) {
500       assert(_freelist == found_block, &quot;sanity check&quot;);
501       _freelist = _freelist-&gt;link();
502     } else {
503       assert((found_prev-&gt;link() == found_block), &quot;sanity check&quot;);
504       // Unmap element
505       found_prev-&gt;set_link(found_block-&gt;link());
506     }







507   } else {
<span class="line-modified">508     // Truncate block and return a pointer to the following block</span>
<span class="line-modified">509     // Set used bit and length on new block</span>
<span class="line-modified">510     found_block-&gt;set_length(found_length - length);</span>
<span class="line-modified">511     found_block = following_block(found_block);</span>
<span class="line-modified">512 </span>
<span class="line-removed">513     size_t beg = segment_for(found_block);</span>
<span class="line-removed">514     mark_segmap_as_used(beg, beg + length);</span>
<span class="line-removed">515     found_block-&gt;set_length(length);</span>
516   }
517 
<span class="line-modified">518   found_block-&gt;set_used();</span>
519   _freelist_segments -= length;
<span class="line-modified">520   return found_block;</span>













































521 }
522 
523 //----------------------------------------------------------------------------
524 // Non-product code
525 
526 #ifndef PRODUCT
527 
528 void CodeHeap::print() {
529   tty-&gt;print_cr(&quot;The Heap&quot;);
530 }
531 
532 void CodeHeap::verify() {
533   if (VerifyCodeCache) {
534     size_t len = 0;
535     int count = 0;
536     for(FreeBlock* b = _freelist; b != NULL; b = b-&gt;link()) {
537       len += b-&gt;length();
538       count++;
539       // Check if we have merged all free blocks
540       assert(merge_right(b) == false, &quot;Missed merging opportunity&quot;);
541     }
542     // Verify that freelist contains the right amount of free space
543     assert(len == _freelist_segments, &quot;wrong freelist&quot;);
544 
545     for(HeapBlock* h = first_block(); h != NULL; h = next_block(h)) {
546       if (h-&gt;free()) count--;
547     }
548     // Verify that the freelist contains the same number of blocks
549     // than free blocks found on the full list.
550     assert(count == 0, &quot;missing free blocks&quot;);
551 




























552     // Verify that the number of free blocks is not out of hand.
553     static int free_block_threshold = 10000;
554     if (count &gt; free_block_threshold) {
555       warning(&quot;CodeHeap: # of free blocks &gt; %d&quot;, free_block_threshold);
556       // Double the warning limit
557       free_block_threshold *= 2;
558     }
559   }
560 }
561 
562 #endif
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;memory/heap.hpp&quot;
 27 #include &quot;oops/oop.inline.hpp&quot;
 28 #include &quot;runtime/os.hpp&quot;
 29 #include &quot;services/memTracker.hpp&quot;
 30 #include &quot;utilities/align.hpp&quot;
<span class="line-added"> 31 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
 32 
 33 size_t CodeHeap::header_size() {
 34   return sizeof(HeapBlock);
 35 }
 36 
 37 
 38 // Implementation of Heap
 39 
 40 CodeHeap::CodeHeap(const char* name, const int code_blob_type)
 41   : _code_blob_type(code_blob_type) {
 42   _name                         = name;
 43   _number_of_committed_segments = 0;
 44   _number_of_reserved_segments  = 0;
 45   _segment_size                 = 0;
 46   _log2_segment_size            = 0;
 47   _next_segment                 = 0;
 48   _freelist                     = NULL;
<span class="line-added"> 49   _last_insert_point            = NULL;</span>
 50   _freelist_segments            = 0;
 51   _freelist_length              = 0;
 52   _max_allocated_capacity       = 0;
 53   _blob_count                   = 0;
 54   _nmethod_count                = 0;
 55   _adapter_count                = 0;
 56   _full_count                   = 0;
<span class="line-added"> 57   _fragmentation_count          = 0;</span>
 58 }
 59 
<span class="line-added"> 60 // Dummy initialization of template array.</span>
<span class="line-added"> 61 char CodeHeap::segmap_template[] = {0};</span>
 62 
<span class="line-added"> 63 // This template array is used to (re)initialize the segmap,</span>
<span class="line-added"> 64 // replacing a 1..254 loop.</span>
<span class="line-added"> 65 void CodeHeap::init_segmap_template() {</span>
<span class="line-added"> 66   assert(free_sentinel == 255, &quot;Segment map logic changed!&quot;);</span>
<span class="line-added"> 67   for (int i = 0; i &lt;= free_sentinel; i++) {</span>
<span class="line-added"> 68     segmap_template[i] = i;</span>
<span class="line-added"> 69   }</span>
<span class="line-added"> 70 }</span>
<span class="line-added"> 71 </span>
<span class="line-added"> 72 // The segmap is marked free for that part of the heap</span>
<span class="line-added"> 73 // which has not been allocated yet (beyond _next_segment).</span>
<span class="line-added"> 74 // The range of segments to be marked is given by [beg..end).</span>
<span class="line-added"> 75 // &quot;Allocated&quot; space in this context means there exists a</span>
<span class="line-added"> 76 // HeapBlock or a FreeBlock describing this space.</span>
<span class="line-added"> 77 // This method takes segment map indices as range boundaries</span>
 78 void CodeHeap::mark_segmap_as_free(size_t beg, size_t end) {
<span class="line-modified"> 79   assert(             beg &lt;  _number_of_committed_segments, &quot;interval begin out of bounds&quot;);</span>
<span class="line-modified"> 80   assert(beg &lt; end &amp;&amp; end &lt;= _number_of_committed_segments, &quot;interval end   out of bounds&quot;);</span>
<span class="line-modified"> 81   // Don&#39;t do unpredictable things in PRODUCT build</span>
<span class="line-modified"> 82   if (beg &lt; end) {</span>
<span class="line-modified"> 83     // setup _segmap pointers for faster indexing</span>
<span class="line-modified"> 84     address p = (address)_segmap.low() + beg;</span>
<span class="line-modified"> 85     address q = (address)_segmap.low() + end;</span>
<span class="line-modified"> 86     // initialize interval</span>
<span class="line-modified"> 87     memset(p, free_sentinel, q-p);</span>
<span class="line-modified"> 88   }</span>
<span class="line-modified"> 89 }</span>
<span class="line-modified"> 90 </span>
<span class="line-modified"> 91 // Don&#39;t get confused here.</span>
<span class="line-modified"> 92 // All existing blocks, no matter if they are used() or free(),</span>
<span class="line-modified"> 93 // have their segmap marked as used. This allows to find the</span>
<span class="line-modified"> 94 // block header (HeapBlock or FreeBlock) for any pointer</span>
<span class="line-modified"> 95 // within the allocated range (upper limit: _next_segment).</span>
<span class="line-modified"> 96 // This method takes segment map indices as range boundaries.</span>
<span class="line-modified"> 97 // The range of segments to be marked is given by [beg..end).</span>
<span class="line-modified"> 98 void CodeHeap::mark_segmap_as_used(size_t beg, size_t end, bool is_FreeBlock_join) {</span>
<span class="line-modified"> 99   assert(             beg &lt;  _number_of_committed_segments, &quot;interval begin out of bounds&quot;);</span>
<span class="line-added">100   assert(beg &lt; end &amp;&amp; end &lt;= _number_of_committed_segments, &quot;interval end   out of bounds&quot;);</span>
<span class="line-added">101   // Don&#39;t do unpredictable things in PRODUCT build</span>
<span class="line-added">102   if (beg &lt; end) {</span>
<span class="line-added">103     // setup _segmap pointers for faster indexing</span>
<span class="line-added">104     address p = (address)_segmap.low() + beg;</span>
<span class="line-added">105     address q = (address)_segmap.low() + end;</span>
<span class="line-added">106     // initialize interval</span>
<span class="line-added">107     // If we are joining two free blocks, the segmap range for each</span>
<span class="line-added">108     // block is consistent. To create a consistent segmap range for</span>
<span class="line-added">109     // the blocks combined, we have three choices:</span>
<span class="line-added">110     //  1 - Do a full init from beg to end. Not very efficient because</span>
<span class="line-added">111     //      the segmap range for the left block is potentially initialized</span>
<span class="line-added">112     //      over and over again.</span>
<span class="line-added">113     //  2 - Carry over the last segmap element value of the left block</span>
<span class="line-added">114     //      and initialize the segmap range of the right block starting</span>
<span class="line-added">115     //      with that value. Saves initializing the left block&#39;s segmap</span>
<span class="line-added">116     //      over and over again. Very efficient if FreeBlocks mostly</span>
<span class="line-added">117     //      are appended to the right.</span>
<span class="line-added">118     //  3 - Take full advantage of the segmap being almost correct with</span>
<span class="line-added">119     //      the two blocks combined. Lets assume the left block consists</span>
<span class="line-added">120     //      of m segments. The the segmap looks like</span>
<span class="line-added">121     //        ... (m-2) (m-1) (m) 0  1  2  3 ...</span>
<span class="line-added">122     //      By substituting the &#39;0&#39; by &#39;1&#39;, we create a valid, but</span>
<span class="line-added">123     //      suboptimal, segmap range covering the two blocks combined.</span>
<span class="line-added">124     //      We introduced an extra hop for the find_block_for() iteration.</span>
<span class="line-added">125     //</span>
<span class="line-added">126     // When this method is called with is_FreeBlock_join == true, the</span>
<span class="line-added">127     // segmap index beg must select the first segment of the right block.</span>
<span class="line-added">128     // Otherwise, it has to select the first segment of the left block.</span>
<span class="line-added">129     // Variant 3 is used for all FreeBlock joins.</span>
<span class="line-added">130     if (is_FreeBlock_join &amp;&amp; (beg &gt; 0)) {</span>
<span class="line-added">131 #ifndef PRODUCT</span>
<span class="line-added">132       FreeBlock* pBlock = (FreeBlock*)block_at(beg);</span>
<span class="line-added">133       assert(beg + pBlock-&gt;length() == end, &quot;Internal error: (%d - %d) != %d&quot;, (unsigned int)end, (unsigned int)beg, (unsigned int)(pBlock-&gt;length()));</span>
<span class="line-added">134       assert(*p == 0, &quot;Begin index does not select a block start segment, *p = %2.2x&quot;, *p);</span>
<span class="line-added">135 #endif</span>
<span class="line-added">136       // If possible, extend the previous hop.</span>
<span class="line-added">137       if (*(p-1) &lt; (free_sentinel-1)) {</span>
<span class="line-added">138         *p = *(p-1) + 1;</span>
<span class="line-added">139       } else {</span>
<span class="line-added">140         *p = 1;</span>
<span class="line-added">141       }</span>
<span class="line-added">142       if (_fragmentation_count++ &gt;= fragmentation_limit) {</span>
<span class="line-added">143         defrag_segmap(true);</span>
<span class="line-added">144         _fragmentation_count = 0;</span>
<span class="line-added">145       }</span>
<span class="line-added">146     } else {</span>
<span class="line-added">147       size_t n_bulk = free_sentinel-1; // bulk processing uses template indices [1..254].</span>
<span class="line-added">148       // Use shortcut for blocks &lt;= 255 segments.</span>
<span class="line-added">149       // Special case bulk processing: [0..254].</span>
<span class="line-added">150       if ((end - beg) &lt;= n_bulk) {</span>
<span class="line-added">151         memcpy(p, &amp;segmap_template[0], end - beg);</span>
<span class="line-added">152       } else {</span>
<span class="line-added">153         *p++  = 0;  // block header marker</span>
<span class="line-added">154         while (p &lt; q) {</span>
<span class="line-added">155           if ((p+n_bulk) &lt;= q) {</span>
<span class="line-added">156             memcpy(p, &amp;segmap_template[1], n_bulk);</span>
<span class="line-added">157             p += n_bulk;</span>
<span class="line-added">158           } else {</span>
<span class="line-added">159             memcpy(p, &amp;segmap_template[1], q-p);</span>
<span class="line-added">160             p = q;</span>
<span class="line-added">161           }</span>
<span class="line-added">162         }</span>
<span class="line-added">163       }</span>
<span class="line-added">164     }</span>
165   }
166 }
167 
<span class="line-added">168 void CodeHeap::invalidate(size_t beg, size_t end, size_t hdr_size) {</span>
<span class="line-added">169 #ifndef PRODUCT</span>
<span class="line-added">170   // Fill the given range with some bad value.</span>
<span class="line-added">171   // length is expected to be in segment_size units.</span>
<span class="line-added">172   // This prevents inadvertent execution of code leftover from previous use.</span>
<span class="line-added">173   char* p = low_boundary() + segments_to_size(beg) + hdr_size;</span>
<span class="line-added">174   memset(p, badCodeHeapNewVal, segments_to_size(end-beg)-hdr_size);</span>
<span class="line-added">175 #endif</span>
<span class="line-added">176 }</span>
<span class="line-added">177 </span>
<span class="line-added">178 void CodeHeap::clear(size_t beg, size_t end) {</span>
<span class="line-added">179   mark_segmap_as_free(beg, end);</span>
<span class="line-added">180   invalidate(beg, end, 0);</span>
<span class="line-added">181 }</span>
<span class="line-added">182 </span>
<span class="line-added">183 void CodeHeap::clear() {</span>
<span class="line-added">184   _next_segment = 0;</span>
<span class="line-added">185   clear(_next_segment, _number_of_committed_segments);</span>
<span class="line-added">186 }</span>
<span class="line-added">187 </span>
188 
189 static size_t align_to_page_size(size_t size) {
190   const size_t alignment = (size_t)os::vm_page_size();
191   assert(is_power_of_2(alignment), &quot;no kidding ???&quot;);
192   return (size + alignment - 1) &amp; ~(alignment - 1);
193 }
194 
195 
196 void CodeHeap::on_code_mapping(char* base, size_t size) {
197 #ifdef LINUX
198   extern void linux_wrap_code(char* base, size_t size);
199   linux_wrap_code(base, size);
200 #endif
201 }
202 
203 
204 bool CodeHeap::reserve(ReservedSpace rs, size_t committed_size, size_t segment_size) {
205   assert(rs.size() &gt;= committed_size, &quot;reserved &lt; committed&quot;);
206   assert(segment_size &gt;= sizeof(FreeBlock), &quot;segment size is too small&quot;);
207   assert(is_power_of_2(segment_size), &quot;segment_size must be a power of 2&quot;);
</pre>
<hr />
<pre>
228 
229   on_code_mapping(_memory.low(), _memory.committed_size());
230   _number_of_committed_segments = size_to_segments(_memory.committed_size());
231   _number_of_reserved_segments  = size_to_segments(_memory.reserved_size());
232   assert(_number_of_reserved_segments &gt;= _number_of_committed_segments, &quot;just checking&quot;);
233   const size_t reserved_segments_alignment = MAX2((size_t)os::vm_page_size(), granularity);
234   const size_t reserved_segments_size = align_up(_number_of_reserved_segments, reserved_segments_alignment);
235   const size_t committed_segments_size = align_to_page_size(_number_of_committed_segments);
236 
237   // reserve space for _segmap
238   if (!_segmap.initialize(reserved_segments_size, committed_segments_size)) {
239     return false;
240   }
241 
242   MemTracker::record_virtual_memory_type((address)_segmap.low_boundary(), mtCode);
243 
244   assert(_segmap.committed_size() &gt;= (size_t) _number_of_committed_segments, &quot;could not commit  enough space for segment map&quot;);
245   assert(_segmap.reserved_size()  &gt;= (size_t) _number_of_reserved_segments , &quot;could not reserve enough space for segment map&quot;);
246   assert(_segmap.reserved_size()  &gt;= _segmap.committed_size()     , &quot;just checking&quot;);
247 
<span class="line-modified">248   // initialize remaining instance variables, heap memory and segmap</span>
249   clear();
<span class="line-added">250   init_segmap_template();</span>
251   return true;
252 }
253 
254 
255 bool CodeHeap::expand_by(size_t size) {
256   // expand _memory space
257   size_t dm = align_to_page_size(_memory.committed_size() + size) - _memory.committed_size();
258   if (dm &gt; 0) {
259     // Use at least the available uncommitted space if &#39;size&#39; is larger
260     if (_memory.uncommitted_size() != 0 &amp;&amp; dm &gt; _memory.uncommitted_size()) {
261       dm = _memory.uncommitted_size();
262     }
263     char* base = _memory.low() + _memory.committed_size();
264     if (!_memory.expand_by(dm)) return false;
265     on_code_mapping(base, dm);
266     size_t i = _number_of_committed_segments;
267     _number_of_committed_segments = size_to_segments(_memory.committed_size());
268     assert(_number_of_reserved_segments == size_to_segments(_memory.reserved_size()), &quot;number of reserved segments should not change&quot;);
269     assert(_number_of_reserved_segments &gt;= _number_of_committed_segments, &quot;just checking&quot;);
270     // expand _segmap space
271     size_t ds = align_to_page_size(_number_of_committed_segments) - _segmap.committed_size();
272     if ((ds &gt; 0) &amp;&amp; !_segmap.expand_by(ds)) {
273       return false;
274     }
275     assert(_segmap.committed_size() &gt;= (size_t) _number_of_committed_segments, &quot;just checking&quot;);
<span class="line-modified">276     // initialize additional space (heap memory and segmap)</span>
<span class="line-modified">277     clear(i, _number_of_committed_segments);</span>
278   }
279   return true;
280 }
281 





282 
283 void* CodeHeap::allocate(size_t instance_size) {
284   size_t number_of_segments = size_to_segments(instance_size + header_size());
285   assert(segments_to_size(number_of_segments) &gt;= sizeof(FreeBlock), &quot;not enough room for FreeList&quot;);
286 
287   // First check if we can satisfy request from freelist
288   NOT_PRODUCT(verify());
289   HeapBlock* block = search_freelist(number_of_segments);
290   NOT_PRODUCT(verify());
291 
292   if (block != NULL) {
<span class="line-modified">293     assert(!block-&gt;free(), &quot;must not be marked free&quot;);</span>

294     guarantee((char*) block &gt;= _memory.low_boundary() &amp;&amp; (char*) block &lt; _memory.high(),
295               &quot;The newly allocated block &quot; INTPTR_FORMAT &quot; is not within the heap &quot;
296               &quot;starting with &quot;  INTPTR_FORMAT &quot; and ending with &quot;  INTPTR_FORMAT,
297               p2i(block), p2i(_memory.low_boundary()), p2i(_memory.high()));

298     _max_allocated_capacity = MAX2(_max_allocated_capacity, allocated_capacity());
299     _blob_count++;
300     return block-&gt;allocated_space();
301   }
302 
303   // Ensure minimum size for allocation to the heap.
304   number_of_segments = MAX2((int)CodeCacheMinBlockLength, (int)number_of_segments);
305 
306   if (_next_segment + number_of_segments &lt;= _number_of_committed_segments) {
<span class="line-modified">307     mark_segmap_as_used(_next_segment, _next_segment + number_of_segments, false);</span>
<span class="line-modified">308     block = block_at(_next_segment);</span>
<span class="line-modified">309     block-&gt;initialize(number_of_segments);</span>
310     _next_segment += number_of_segments;
<span class="line-modified">311     guarantee((char*) block &gt;= _memory.low_boundary() &amp;&amp; (char*) block &lt; _memory.high(),</span>
312               &quot;The newly allocated block &quot; INTPTR_FORMAT &quot; is not within the heap &quot;
313               &quot;starting with &quot;  INTPTR_FORMAT &quot; and ending with &quot; INTPTR_FORMAT,
<span class="line-modified">314               p2i(block), p2i(_memory.low_boundary()), p2i(_memory.high()));</span>

315     _max_allocated_capacity = MAX2(_max_allocated_capacity, allocated_capacity());
316     _blob_count++;
<span class="line-modified">317     return block-&gt;allocated_space();</span>
318   } else {
319     return NULL;
320   }
321 }
322 
<span class="line-added">323 // Split the given block into two at the given segment.</span>
<span class="line-added">324 // This is helpful when a block was allocated too large</span>
<span class="line-added">325 // to trim off the unused space at the end (interpreter).</span>
<span class="line-added">326 // It also helps with splitting a large free block during allocation.</span>
<span class="line-added">327 // Usage state (used or free) must be set by caller since</span>
<span class="line-added">328 // we don&#39;t know if the resulting blocks will be used or free.</span>
<span class="line-added">329 // split_at is the segment number (relative to segment_for(b))</span>
<span class="line-added">330 //          where the split happens. The segment with relative</span>
<span class="line-added">331 //          number split_at is the first segment of the split-off block.</span>
<span class="line-added">332 HeapBlock* CodeHeap::split_block(HeapBlock *b, size_t split_at) {</span>
<span class="line-added">333   if (b == NULL) return NULL;</span>
<span class="line-added">334   // After the split, both blocks must have a size of at least CodeCacheMinBlockLength</span>
<span class="line-added">335   assert((split_at &gt;= CodeCacheMinBlockLength) &amp;&amp; (split_at + CodeCacheMinBlockLength &lt;= b-&gt;length()),</span>
<span class="line-added">336          &quot;split position(%d) out of range [0..%d]&quot;, (int)split_at, (int)b-&gt;length());</span>
<span class="line-added">337   size_t split_segment = segment_for(b) + split_at;</span>
<span class="line-added">338   size_t b_size        = b-&gt;length();</span>
<span class="line-added">339   size_t newb_size     = b_size - split_at;</span>
<span class="line-added">340 </span>
<span class="line-added">341   HeapBlock* newb = block_at(split_segment);</span>
<span class="line-added">342   newb-&gt;set_length(newb_size);</span>
<span class="line-added">343   mark_segmap_as_used(segment_for(newb), segment_for(newb) + newb_size, false);</span>
<span class="line-added">344   b-&gt;set_length(split_at);</span>
<span class="line-added">345   return newb;</span>
<span class="line-added">346 }</span>
<span class="line-added">347 </span>
348 void CodeHeap::deallocate_tail(void* p, size_t used_size) {
349   assert(p == find_start(p), &quot;illegal deallocation&quot;);
350   // Find start of HeapBlock
351   HeapBlock* b = (((HeapBlock *)p) - 1);
352   assert(b-&gt;allocated_space() == p, &quot;sanity check&quot;);
<span class="line-modified">353 </span>
354   size_t actual_number_of_segments = b-&gt;length();
<span class="line-added">355   size_t used_number_of_segments   = size_to_segments(used_size + header_size());</span>
<span class="line-added">356   size_t unused_number_of_segments = actual_number_of_segments - used_number_of_segments;</span>
357   guarantee(used_number_of_segments &lt;= actual_number_of_segments, &quot;Must be!&quot;);
<span class="line-modified">358 </span>
<span class="line-modified">359   HeapBlock* f = split_block(b, used_number_of_segments);</span>
<span class="line-modified">360   add_to_freelist(f);</span>
<span class="line-modified">361   NOT_PRODUCT(verify());</span>

362 }
363 
364 void CodeHeap::deallocate(void* p) {
365   assert(p == find_start(p), &quot;illegal deallocation&quot;);
366   // Find start of HeapBlock
367   HeapBlock* b = (((HeapBlock *)p) - 1);
368   assert(b-&gt;allocated_space() == p, &quot;sanity check&quot;);
369   guarantee((char*) b &gt;= _memory.low_boundary() &amp;&amp; (char*) b &lt; _memory.high(),
370             &quot;The block to be deallocated &quot; INTPTR_FORMAT &quot; is not within the heap &quot;
371             &quot;starting with &quot;  INTPTR_FORMAT &quot; and ending with &quot; INTPTR_FORMAT,
372             p2i(b), p2i(_memory.low_boundary()), p2i(_memory.high()));


373   add_to_freelist(b);
374   NOT_PRODUCT(verify());
375 }
376 
377 /**
<span class="line-modified">378  * The segment map is used to quickly find the the start (header) of a</span>
<span class="line-modified">379  * code block (e.g. nmethod) when only a pointer to a location inside the</span>
<span class="line-modified">380  * code block is known. This works as follows:</span>
<span class="line-modified">381  *  - The storage reserved for the code heap is divided into &#39;segments&#39;.</span>
<span class="line-modified">382  *  - The size of a segment is determined by -XX:CodeCacheSegmentSize=&lt;#bytes&gt;.</span>
<span class="line-modified">383  *  - The size must be a power of two to allow the use of shift operations</span>
<span class="line-modified">384  *    to quickly convert between segment index and segment address.</span>
<span class="line-added">385  *  - Segment start addresses should be aligned to be multiples of CodeCacheSegmentSize.</span>
<span class="line-added">386  *  - It seems beneficial for CodeCacheSegmentSize to be equal to os::page_size().</span>
<span class="line-added">387  *  - Allocation in the code cache can only happen at segment start addresses.</span>
<span class="line-added">388  *  - Allocation in the code cache is in units of CodeCacheSegmentSize.</span>
<span class="line-added">389  *  - A pointer in the code cache can be mapped to a segment by calling</span>
<span class="line-added">390  *    segment_for(addr).</span>
<span class="line-added">391  *  - The segment map is a byte array where array element [i] is related</span>
<span class="line-added">392  *    to the i-th segment in the code heap.</span>
<span class="line-added">393  *  - Each time memory is allocated/deallocated from the code cache,</span>
<span class="line-added">394  *    the segment map is updated accordingly.</span>
<span class="line-added">395  *    Note: deallocation does not cause the memory to become &quot;free&quot;, as</span>
<span class="line-added">396  *          indicated by the segment map state &quot;free_sentinel&quot;. Deallocation</span>
<span class="line-added">397  *          just changes the block state from &quot;used&quot; to &quot;free&quot;.</span>
<span class="line-added">398  *  - Elements of the segment map (byte) array are interpreted</span>
<span class="line-added">399  *    as unsigned integer.</span>
<span class="line-added">400  *  - Element values normally identify an offset backwards (in segment</span>
<span class="line-added">401  *    size units) from the associated segment towards the start of</span>
<span class="line-added">402  *    the block.</span>
<span class="line-added">403  *  - Some values have a special meaning:</span>
<span class="line-added">404  *       0 - This segment is the start of a block (HeapBlock or FreeBlock).</span>
<span class="line-added">405  *     255 - The free_sentinel value. This is a free segment, i.e. it is</span>
<span class="line-added">406  *           not yet allocated and thus does not belong to any block.</span>
<span class="line-added">407  *  - The value of the current element has to be subtracted from the</span>
<span class="line-added">408  *    current index to get closer to the start.</span>
<span class="line-added">409  *  - If the value of the then current element is zero, the block start</span>
<span class="line-added">410  *    segment is found and iteration stops. Otherwise, start over with the</span>
<span class="line-added">411  *    previous step.</span>
<span class="line-added">412  *</span>
<span class="line-added">413  *    The following example illustrates a possible state of code cache</span>
<span class="line-added">414  *    and the segment map: (seg -&gt; segment, nm -&gt;nmethod)</span>
415  *
416  *          code cache          segmap
417  *         -----------        ---------
418  * seg 1   | nm 1    |   -&gt;   | 0     |
419  * seg 2   | nm 1    |   -&gt;   | 1     |
420  * ...     | nm 1    |   -&gt;   | ..    |
<span class="line-added">421  * seg m-1 | nm 1    |   -&gt;   | m-1   |</span>
422  * seg m   | nm 2    |   -&gt;   | 0     |
423  * seg m+1 | nm 2    |   -&gt;   | 1     |
424  * ...     | nm 2    |   -&gt;   | 2     |
425  * ...     | nm 2    |   -&gt;   | ..    |
<span class="line-modified">426  * ...     | nm 2    |   -&gt;   | 0xFE  | (free_sentinel-1)</span>
<span class="line-modified">427  * ...     | nm 2    |   -&gt;   | 1     |</span>
<span class="line-added">428  * seg m+n | nm 2    |   -&gt;   | 2     |</span>
429  * ...     | nm 2    |   -&gt;   |       |
430  *
<span class="line-modified">431  * How to read:</span>
<span class="line-modified">432  * A value of &#39;0&#39; in the segmap indicates that this segment contains the</span>
<span class="line-modified">433  * beginning of a CodeHeap block. Let&#39;s walk through a simple example:</span>
<span class="line-modified">434  *</span>
<span class="line-modified">435  * We want to find the start of the block that contains nm 1, and we are</span>
<span class="line-modified">436  * given a pointer that points into segment m-2. We then read the value</span>
<span class="line-modified">437  * of segmap[m-2]. The value is an offset that points to the segment</span>
<span class="line-added">438  * which contains the start of the block.</span>
<span class="line-added">439  *</span>
<span class="line-added">440  * Another example: We want to locate the start of nm 2, and we happen to</span>
<span class="line-added">441  * get a pointer that points into seg m+n. We first read seg[n+m], which</span>
<span class="line-added">442  * returns &#39;2&#39;. So we have to update our segment map index (ix -= segmap[n+m])</span>
<span class="line-added">443  * and start over.</span>
444  */
<span class="line-modified">445 </span>
<span class="line-added">446 // Find block which contains the passed pointer,</span>
<span class="line-added">447 // regardless of the block being used or free.</span>
<span class="line-added">448 // NULL is returned if anything invalid is detected.</span>
<span class="line-added">449 void* CodeHeap::find_block_for(void* p) const {</span>
<span class="line-added">450   // Check the pointer to be in committed range.</span>
451   if (!contains(p)) {
452     return NULL;
453   }
<span class="line-modified">454 </span>
455   address seg_map = (address)_segmap.low();
<span class="line-added">456   size_t  seg_idx = segment_for(p);</span>
<span class="line-added">457 </span>
<span class="line-added">458   // This may happen in special cases. Just ignore.</span>
<span class="line-added">459   // Example: PPC ICache stub generation.</span>
460   if (is_segment_unused(seg_map[seg_idx])) {
461     return NULL;
462   }
<span class="line-added">463 </span>
<span class="line-added">464   // Iterate the segment map chain to find the start of the block.</span>
465   while (seg_map[seg_idx] &gt; 0) {
<span class="line-added">466     // Don&#39;t check each segment index to refer to a used segment.</span>
<span class="line-added">467     // This method is called extremely often. Therefore, any checking</span>
<span class="line-added">468     // has a significant impact on performance. Rely on CodeHeap::verify()</span>
<span class="line-added">469     // to do the job on request.</span>
470     seg_idx -= (int)seg_map[seg_idx];
471   }
472 
<span class="line-modified">473   return address_for(seg_idx);</span>
<span class="line-modified">474 }</span>
<span class="line-modified">475 </span>
<span class="line-modified">476 // Find block which contains the passed pointer.</span>
<span class="line-modified">477 // The block must be used, i.e. must not be a FreeBlock.</span>
<span class="line-added">478 // Return a pointer that points past the block header.</span>
<span class="line-added">479 void* CodeHeap::find_start(void* p) const {</span>
<span class="line-added">480   HeapBlock* h = (HeapBlock*)find_block_for(p);</span>
<span class="line-added">481   return ((h == NULL) || h-&gt;free()) ? NULL : h-&gt;allocated_space();</span>
482 }
483 
<span class="line-added">484 // Find block which contains the passed pointer.</span>
<span class="line-added">485 // Same as find_start(p), but with additional safety net.</span>
486 CodeBlob* CodeHeap::find_blob_unsafe(void* start) const {
487   CodeBlob* result = (CodeBlob*)CodeHeap::find_start(start);
<span class="line-modified">488   return (result != NULL &amp;&amp; result-&gt;blob_contains((address)start)) ? result : NULL;</span>



489 }
490 
491 size_t CodeHeap::alignment_unit() const {
492   // this will be a power of two
493   return _segment_size;
494 }
495 
496 
497 size_t CodeHeap::alignment_offset() const {
498   // The lowest address in any allocated block will be
499   // equal to alignment_offset (mod alignment_unit).
500   return sizeof(HeapBlock) &amp; (_segment_size - 1);
501 }
502 
503 // Returns the current block if available and used.
504 // If not, it returns the subsequent block (if available), NULL otherwise.
505 // Free blocks are merged, therefore there is at most one free block
506 // between two used ones. As a result, the subsequent block (if available) is
507 // guaranteed to be used.
<span class="line-added">508 // The returned pointer points past the block header.</span>
509 void* CodeHeap::next_used(HeapBlock* b) const {
510   if (b != NULL &amp;&amp; b-&gt;free()) b = next_block(b);
511   assert(b == NULL || !b-&gt;free(), &quot;must be in use or at end of heap&quot;);
512   return (b == NULL) ? NULL : b-&gt;allocated_space();
513 }
514 
515 // Returns the first used HeapBlock
<span class="line-added">516 // The returned pointer points to the block header.</span>
517 HeapBlock* CodeHeap::first_block() const {
518   if (_next_segment &gt; 0)
519     return block_at(0);
520   return NULL;
521 }
522 
<span class="line-added">523 // The returned pointer points to the block header.</span>
524 HeapBlock* CodeHeap::block_start(void* q) const {
525   HeapBlock* b = (HeapBlock*)find_start(q);
526   if (b == NULL) return NULL;
527   return b - 1;
528 }
529 
<span class="line-modified">530 // Returns the next Heap block.</span>
<span class="line-added">531 // The returned pointer points to the block header.</span>
532 HeapBlock* CodeHeap::next_block(HeapBlock *b) const {
533   if (b == NULL) return NULL;
534   size_t i = segment_for(b) + b-&gt;length();
535   if (i &lt; _next_segment)
536     return block_at(i);
537   return NULL;
538 }
539 
540 
541 // Returns current capacity
542 size_t CodeHeap::capacity() const {
543   return _memory.committed_size();
544 }
545 
546 size_t CodeHeap::max_capacity() const {
547   return _memory.reserved_size();
548 }
549 
550 int CodeHeap::allocated_segments() const {
551   return (int)_next_segment;
</pre>
<hr />
<pre>
569 }
570 
571 // Inserts block b after a
572 void CodeHeap::insert_after(FreeBlock* a, FreeBlock* b) {
573   assert(a != NULL &amp;&amp; b != NULL, &quot;must be real pointers&quot;);
574 
575   // Link b into the list after a
576   b-&gt;set_link(a-&gt;link());
577   a-&gt;set_link(b);
578 
579   // See if we can merge blocks
580   merge_right(b); // Try to make b bigger
581   merge_right(a); // Try to make a include b
582 }
583 
584 // Try to merge this block with the following block
585 bool CodeHeap::merge_right(FreeBlock* a) {
586   assert(a-&gt;free(), &quot;must be a free block&quot;);
587   if (following_block(a) == a-&gt;link()) {
588     assert(a-&gt;link() != NULL &amp;&amp; a-&gt;link()-&gt;free(), &quot;must be free too&quot;);
<span class="line-modified">589 </span>
<span class="line-added">590     // Remember linked (following) block. invalidate should only zap header of this block.</span>
<span class="line-added">591     size_t follower = segment_for(a-&gt;link());</span>
<span class="line-added">592     // Merge block a to include the following block.</span>
593     a-&gt;set_length(a-&gt;length() + a-&gt;link()-&gt;length());
594     a-&gt;set_link(a-&gt;link()-&gt;link());
<span class="line-modified">595 </span>
<span class="line-modified">596     // Update the segment map and invalidate block contents.</span>
<span class="line-modified">597     mark_segmap_as_used(follower, segment_for(a) + a-&gt;length(), true);</span>
<span class="line-added">598     // Block contents has already been invalidated by add_to_freelist.</span>
<span class="line-added">599     // What&#39;s left is the header of the following block which now is</span>
<span class="line-added">600     // in the middle of the merged block. Just zap one segment.</span>
<span class="line-added">601     invalidate(follower, follower + 1, 0);</span>
<span class="line-added">602 </span>
603     _freelist_length--;
604     return true;
605   }
606   return false;
607 }
608 
609 
610 void CodeHeap::add_to_freelist(HeapBlock* a) {
611   FreeBlock* b = (FreeBlock*)a;
<span class="line-added">612   size_t  bseg = segment_for(b);</span>
613   _freelist_length++;
614 
<span class="line-modified">615   _blob_count--;</span>
<span class="line-added">616   assert(_blob_count &gt;= 0, &quot;sanity&quot;);</span>
617 
<span class="line-added">618   assert(b != _freelist, &quot;cannot be removed twice&quot;);</span>
619 
620   // Mark as free and update free space count
621   _freelist_segments += b-&gt;length();
622   b-&gt;set_free();
<span class="line-added">623   invalidate(bseg, bseg + b-&gt;length(), sizeof(FreeBlock));</span>
624 
625   // First element in list?
626   if (_freelist == NULL) {

627     b-&gt;set_link(NULL);
<span class="line-added">628     _freelist = b;</span>
629     return;
630   }
631 
632   // Since the freelist is ordered (smaller addresses -&gt; larger addresses) and the
633   // element we want to insert into the freelist has a smaller address than the first
634   // element, we can simply add &#39;b&#39; as the first element and we are done.
635   if (b &lt; _freelist) {
636     // Insert first in list
637     b-&gt;set_link(_freelist);
638     _freelist = b;
639     merge_right(_freelist);
640     return;
641   }
642 
<span class="line-modified">643   // Scan for right place to put into list.</span>
<span class="line-modified">644   // List is sorted by increasing addresses.</span>
645   FreeBlock* prev = _freelist;
646   FreeBlock* cur  = _freelist-&gt;link();
<span class="line-added">647   if ((_freelist_length &gt; freelist_limit) &amp;&amp; (_last_insert_point != NULL)) {</span>
<span class="line-added">648     _last_insert_point = (FreeBlock*)find_block_for(_last_insert_point);</span>
<span class="line-added">649     if ((_last_insert_point != NULL) &amp;&amp; _last_insert_point-&gt;free() &amp;&amp; (_last_insert_point &lt; b)) {</span>
<span class="line-added">650       prev = _last_insert_point;</span>
<span class="line-added">651       cur  = prev-&gt;link();</span>
<span class="line-added">652     }</span>
<span class="line-added">653   }</span>
654   while(cur != NULL &amp;&amp; cur &lt; b) {
655     assert(prev &lt; cur, &quot;Freelist must be ordered&quot;);
656     prev = cur;
657     cur  = cur-&gt;link();
658   }
659   assert((prev &lt; b) &amp;&amp; (cur == NULL || b &lt; cur), &quot;free-list must be ordered&quot;);
660   insert_after(prev, b);
<span class="line-added">661   _last_insert_point = prev;</span>
662 }
663 
664 /**
665  * Search freelist for an entry on the list with the best fit.
666  * @return NULL, if no one was found
667  */
<span class="line-modified">668 HeapBlock* CodeHeap::search_freelist(size_t length) {</span>
<span class="line-modified">669   FreeBlock* found_block  = NULL;</span>
<span class="line-modified">670   FreeBlock* found_prev   = NULL;</span>
<span class="line-modified">671   size_t     found_length = _next_segment; // max it out to begin with</span>
672 
<span class="line-added">673   HeapBlock* res  = NULL;</span>
674   FreeBlock* prev = NULL;
<span class="line-modified">675   FreeBlock* cur  = _freelist;</span>
676 
<span class="line-modified">677   length = length &lt; CodeCacheMinBlockLength ? CodeCacheMinBlockLength : length;</span>






678 
<span class="line-added">679   // Search for best-fitting block</span>
<span class="line-added">680   while(cur != NULL) {</span>
<span class="line-added">681     size_t cur_length = cur-&gt;length();</span>
<span class="line-added">682     if (cur_length == length) {</span>
<span class="line-added">683       // We have a perfect fit</span>
<span class="line-added">684       found_block  = cur;</span>
<span class="line-added">685       found_prev   = prev;</span>
<span class="line-added">686       found_length = cur_length;</span>
687       break;
<span class="line-added">688     } else if ((cur_length &gt; length) &amp;&amp; (cur_length &lt; found_length)) {</span>
<span class="line-added">689       // This is a new, closer fit. Remember block, its previous element, and its length</span>
<span class="line-added">690       found_block  = cur;</span>
<span class="line-added">691       found_prev   = prev;</span>
<span class="line-added">692       found_length = cur_length;</span>
693     }
694     // Next element in list
695     prev = cur;
696     cur  = cur-&gt;link();
697   }
698 
699   if (found_block == NULL) {
700     // None found
701     return NULL;
702   }
703 
704   // Exact (or at least good enough) fit. Remove from list.
705   // Don&#39;t leave anything on the freelist smaller than CodeCacheMinBlockLength.
706   if (found_length - length &lt; CodeCacheMinBlockLength) {
707     _freelist_length--;
708     length = found_length;
709     if (found_prev == NULL) {
710       assert(_freelist == found_block, &quot;sanity check&quot;);
711       _freelist = _freelist-&gt;link();
712     } else {
713       assert((found_prev-&gt;link() == found_block), &quot;sanity check&quot;);
714       // Unmap element
715       found_prev-&gt;set_link(found_block-&gt;link());
716     }
<span class="line-added">717     res = (HeapBlock*)found_block;</span>
<span class="line-added">718     // sizeof(HeapBlock) &lt; sizeof(FreeBlock).</span>
<span class="line-added">719     // Invalidate the additional space that FreeBlock occupies.</span>
<span class="line-added">720     // The rest of the block should already be invalidated.</span>
<span class="line-added">721     // This is necessary due to a dubious assert in nmethod.cpp(PcDescCache::reset_to()).</span>
<span class="line-added">722     // Can&#39;t use invalidate() here because it works on segment_size units (too coarse).</span>
<span class="line-added">723     DEBUG_ONLY(memset((void*)res-&gt;allocated_space(), badCodeHeapNewVal, sizeof(FreeBlock) - sizeof(HeapBlock)));</span>
724   } else {
<span class="line-modified">725     // Truncate the free block and return the truncated part</span>
<span class="line-modified">726     // as new HeapBlock. The remaining free block does not</span>
<span class="line-modified">727     // need to be updated, except for it&#39;s length. Truncating</span>
<span class="line-modified">728     // the segment map does not invalidate the leading part.</span>
<span class="line-modified">729     res = split_block(found_block, found_length - length);</span>



730   }
731 
<span class="line-modified">732   res-&gt;set_used();</span>
733   _freelist_segments -= length;
<span class="line-modified">734   return res;</span>
<span class="line-added">735 }</span>
<span class="line-added">736 </span>
<span class="line-added">737 int CodeHeap::defrag_segmap(bool do_defrag) {</span>
<span class="line-added">738   int extra_hops_used = 0;</span>
<span class="line-added">739   int extra_hops_free = 0;</span>
<span class="line-added">740   int blocks_used     = 0;</span>
<span class="line-added">741   int blocks_free     = 0;</span>
<span class="line-added">742   for(HeapBlock* h = first_block(); h != NULL; h = next_block(h)) {</span>
<span class="line-added">743     size_t beg = segment_for(h);</span>
<span class="line-added">744     size_t end = segment_for(h) + h-&gt;length();</span>
<span class="line-added">745     int extra_hops = segmap_hops(beg, end);</span>
<span class="line-added">746     if (h-&gt;free()) {</span>
<span class="line-added">747       extra_hops_free += extra_hops;</span>
<span class="line-added">748       blocks_free++;</span>
<span class="line-added">749     } else {</span>
<span class="line-added">750       extra_hops_used += extra_hops;</span>
<span class="line-added">751       blocks_used++;</span>
<span class="line-added">752     }</span>
<span class="line-added">753     if (do_defrag &amp;&amp; (extra_hops &gt; 0)) {</span>
<span class="line-added">754       mark_segmap_as_used(beg, end, false);</span>
<span class="line-added">755     }</span>
<span class="line-added">756   }</span>
<span class="line-added">757   return extra_hops_used + extra_hops_free;</span>
<span class="line-added">758 }</span>
<span class="line-added">759 </span>
<span class="line-added">760 // Count the hops required to get from the last segment of a</span>
<span class="line-added">761 // heap block to the block header segment. For the optimal case,</span>
<span class="line-added">762 //   #hops = ((#segments-1)+(free_sentinel-2))/(free_sentinel-1)</span>
<span class="line-added">763 // The range of segments to be checked is given by [beg..end).</span>
<span class="line-added">764 // Return the number of extra hops required. There may be extra hops</span>
<span class="line-added">765 // due to the is_FreeBlock_join optimization in mark_segmap_as_used().</span>
<span class="line-added">766 int CodeHeap::segmap_hops(size_t beg, size_t end) {</span>
<span class="line-added">767   if (beg &lt; end) {</span>
<span class="line-added">768     // setup _segmap pointers for faster indexing</span>
<span class="line-added">769     address p = (address)_segmap.low() + beg;</span>
<span class="line-added">770     int hops_expected = (int)(((end-beg-1)+(free_sentinel-2))/(free_sentinel-1));</span>
<span class="line-added">771     int nhops = 0;</span>
<span class="line-added">772     size_t ix = end-beg-1;</span>
<span class="line-added">773     while (p[ix] &gt; 0) {</span>
<span class="line-added">774       ix -= p[ix];</span>
<span class="line-added">775       nhops++;</span>
<span class="line-added">776     }</span>
<span class="line-added">777     return (nhops &gt; hops_expected) ? nhops - hops_expected : 0;</span>
<span class="line-added">778   }</span>
<span class="line-added">779   return 0;</span>
780 }
781 
782 //----------------------------------------------------------------------------
783 // Non-product code
784 
785 #ifndef PRODUCT
786 
787 void CodeHeap::print() {
788   tty-&gt;print_cr(&quot;The Heap&quot;);
789 }
790 
791 void CodeHeap::verify() {
792   if (VerifyCodeCache) {
793     size_t len = 0;
794     int count = 0;
795     for(FreeBlock* b = _freelist; b != NULL; b = b-&gt;link()) {
796       len += b-&gt;length();
797       count++;
798       // Check if we have merged all free blocks
799       assert(merge_right(b) == false, &quot;Missed merging opportunity&quot;);
800     }
801     // Verify that freelist contains the right amount of free space
802     assert(len == _freelist_segments, &quot;wrong freelist&quot;);
803 
804     for(HeapBlock* h = first_block(); h != NULL; h = next_block(h)) {
805       if (h-&gt;free()) count--;
806     }
807     // Verify that the freelist contains the same number of blocks
808     // than free blocks found on the full list.
809     assert(count == 0, &quot;missing free blocks&quot;);
810 
<span class="line-added">811     //---&lt;  all free block memory must have been invalidated  &gt;---</span>
<span class="line-added">812     for(FreeBlock* b = _freelist; b != NULL; b = b-&gt;link()) {</span>
<span class="line-added">813       for (char* c = (char*)b + sizeof(FreeBlock); c &lt; (char*)b + segments_to_size(b-&gt;length()); c++) {</span>
<span class="line-added">814         assert(*c == (char)badCodeHeapNewVal, &quot;FreeBlock@&quot; PTR_FORMAT &quot;(&quot; PTR_FORMAT &quot;) not invalidated @byte %d&quot;, p2i(b), b-&gt;length(), (int)(c - (char*)b));</span>
<span class="line-added">815       }</span>
<span class="line-added">816     }</span>
<span class="line-added">817 </span>
<span class="line-added">818     address seg_map = (address)_segmap.low();</span>
<span class="line-added">819     size_t  nseg       = 0;</span>
<span class="line-added">820     int     extra_hops = 0;</span>
<span class="line-added">821     count = 0;</span>
<span class="line-added">822     for(HeapBlock* b = first_block(); b != NULL; b = next_block(b)) {</span>
<span class="line-added">823       size_t seg1 = segment_for(b);</span>
<span class="line-added">824       size_t segn = seg1 + b-&gt;length();</span>
<span class="line-added">825       extra_hops += segmap_hops(seg1, segn);</span>
<span class="line-added">826       count++;</span>
<span class="line-added">827       for (size_t i = seg1; i &lt; segn; i++) {</span>
<span class="line-added">828         nseg++;</span>
<span class="line-added">829         //---&lt;  Verify segment map marking  &gt;---</span>
<span class="line-added">830         // All allocated segments, no matter if in a free or used block,</span>
<span class="line-added">831         // must be marked &quot;in use&quot;.</span>
<span class="line-added">832         assert(!is_segment_unused(seg_map[i]), &quot;CodeHeap: unused segment. seg_map[%d]([%d..%d]) = %d, %s block&quot;,    (int)i, (int)seg1, (int)segn, seg_map[i], b-&gt;free()? &quot;free&quot;:&quot;used&quot;);</span>
<span class="line-added">833         assert((unsigned char)seg_map[i] &lt; free_sentinel, &quot;CodeHeap: seg_map[%d]([%d..%d]) = %d (out of range)&quot;,    (int)i, (int)seg1, (int)segn, seg_map[i]);</span>
<span class="line-added">834       }</span>
<span class="line-added">835     }</span>
<span class="line-added">836     assert(nseg == _next_segment, &quot;CodeHeap: segment count mismatch. found %d, expected %d.&quot;, (int)nseg, (int)_next_segment);</span>
<span class="line-added">837     assert((count == 0) || (extra_hops &lt; (16 + 2*count)), &quot;CodeHeap: many extra hops due to optimization. blocks: %d, extra hops: %d.&quot;, count, extra_hops);</span>
<span class="line-added">838 </span>
839     // Verify that the number of free blocks is not out of hand.
840     static int free_block_threshold = 10000;
841     if (count &gt; free_block_threshold) {
842       warning(&quot;CodeHeap: # of free blocks &gt; %d&quot;, free_block_threshold);
843       // Double the warning limit
844       free_block_threshold *= 2;
845     }
846   }
847 }
848 
849 #endif
</pre>
</td>
</tr>
</table>
<center><a href="freeList.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="heap.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/memory/heap.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="heap.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="heapInspection.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/heap.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -49,10 +49,12 @@</span>
    };
  
   public:
    // Initialization
    void initialize(size_t length)                 { _header._length = length; set_used(); }
<span class="udiff-line-added">+   // Merging/splitting</span>
<span class="udiff-line-added">+   void set_length(size_t length)                 { _header._length = length; }</span>
  
    // Accessors
    void* allocated_space() const                  { return (void*)(this + 1); }
    size_t length() const                          { return _header._length; }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -69,13 +71,10 @@</span>
  
   public:
    // Initialization
    void initialize(size_t length)             { HeapBlock::initialize(length); _link= NULL; }
  
<span class="udiff-line-removed">-   // Merging</span>
<span class="udiff-line-removed">-   void set_length(size_t l)                  { _header._length = l; }</span>
<span class="udiff-line-removed">- </span>
    // Accessors
    FreeBlock* link() const                    { return _link; }
    void set_link(FreeBlock* link)             { _link = link; }
  };
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -91,51 +90,61 @@</span>
    int          _log2_segment_size;
  
    size_t       _next_segment;
  
    FreeBlock*   _freelist;
<span class="udiff-line-added">+   FreeBlock*   _last_insert_point;               // last insert point in add_to_freelist</span>
    size_t       _freelist_segments;               // No. of segments in freelist
    int          _freelist_length;
    size_t       _max_allocated_capacity;          // Peak capacity that was allocated during lifetime of the heap
  
    const char*  _name;                            // Name of the CodeHeap
    const int    _code_blob_type;                  // CodeBlobType it contains
    int          _blob_count;                      // Number of CodeBlobs
    int          _nmethod_count;                   // Number of nmethods
    int          _adapter_count;                   // Number of adapters
    int          _full_count;                      // Number of times the code heap was full
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+   int          _fragmentation_count;             // #FreeBlock joins without fully initializing segment map elements.</span>
  
    enum { free_sentinel = 0xFF };
<span class="udiff-line-added">+   static const int fragmentation_limit = 10000;  // defragment after that many potential fragmentations.</span>
<span class="udiff-line-added">+   static const int freelist_limit = 100;         // improve insert point search if list is longer than this limit.</span>
<span class="udiff-line-added">+   static char  segmap_template[free_sentinel+1];</span>
  
    // Helper functions
    size_t   size_to_segments(size_t size) const { return (size + _segment_size - 1) &gt;&gt; _log2_segment_size; }
    size_t   segments_to_size(size_t number_of_segments) const { return number_of_segments &lt;&lt; _log2_segment_size; }
  
    size_t   segment_for(void* p) const            { return ((char*)p - _memory.low()) &gt;&gt; _log2_segment_size; }
    bool     is_segment_unused(int val) const      { return val == free_sentinel; }
<span class="udiff-line-modified-removed">-   HeapBlock* block_at(size_t i) const            { return (HeapBlock*)(_memory.low() + (i &lt;&lt; _log2_segment_size)); }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   void  mark_segmap_as_free(size_t beg, size_t end);</span>
<span class="udiff-line-modified-removed">-   void  mark_segmap_as_used(size_t beg, size_t end);</span>
<span class="udiff-line-modified-added">+   void*    address_for(size_t i) const           { return (void*)(_memory.low() + segments_to_size(i)); }</span>
<span class="udiff-line-modified-added">+   void*    find_block_for(void* p) const;</span>
<span class="udiff-line-modified-added">+   HeapBlock* block_at(size_t i) const            { return (HeapBlock*)address_for(i); }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   // These methods take segment map indices as range boundaries</span>
<span class="udiff-line-added">+   void mark_segmap_as_free(size_t beg, size_t end);</span>
<span class="udiff-line-added">+   void mark_segmap_as_used(size_t beg, size_t end, bool is_FreeBlock_join);</span>
<span class="udiff-line-added">+   void invalidate(size_t beg, size_t end, size_t header_bytes);</span>
<span class="udiff-line-added">+   void clear(size_t beg, size_t end);</span>
<span class="udiff-line-added">+   void clear();                                 // clears all heap contents</span>
<span class="udiff-line-added">+   static void init_segmap_template();</span>
  
    // Freelist management helpers
    FreeBlock* following_block(FreeBlock* b);
    void insert_after(FreeBlock* a, FreeBlock* b);
    bool merge_right (FreeBlock* a);
  
    // Toplevel freelist management
    void add_to_freelist(HeapBlock* b);
<span class="udiff-line-modified-removed">-   FreeBlock* search_freelist(size_t length);</span>
<span class="udiff-line-modified-added">+   HeapBlock* search_freelist(size_t length);</span>
  
    // Iteration helpers
    void*      next_used(HeapBlock* b) const;
    HeapBlock* block_start(void* p) const;
  
    // to perform additional actions on creation of executable code
    void on_code_mapping(char* base, size_t size);
<span class="udiff-line-removed">-   void clear();                                 // clears all heap contents</span>
  
   public:
    CodeHeap(const char* name, const int code_blob_type);
  
    // Heap extents
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -150,16 +159,19 @@</span>
    //            &#39;p&#39; was allocated. Only intended for freeing memory which would be otherwise
    //            wasted after the interpreter generation because we don&#39;t know the interpreter size
    //            beforehand and we also can&#39;t easily relocate the interpreter to a new location.
    void  deallocate_tail(void* p, size_t used_size);
  
<span class="udiff-line-modified-removed">-   // Attributes</span>
<span class="udiff-line-modified-removed">-   char* low_boundary() const                     { return _memory.low_boundary(); }</span>
<span class="udiff-line-modified-added">+   // Boundaries of committed space.</span>
<span class="udiff-line-modified-added">+   char* low()  const                             { return _memory.low(); }</span>
    char* high() const                             { return _memory.high(); }
<span class="udiff-line-added">+   // Boundaries of reserved space.</span>
<span class="udiff-line-added">+   char* low_boundary() const                     { return _memory.low_boundary(); }</span>
    char* high_boundary() const                    { return _memory.high_boundary(); }
  
<span class="udiff-line-modified-removed">-   bool contains(const void* p) const             { return low_boundary() &lt;= p &amp;&amp; p &lt; high(); }</span>
<span class="udiff-line-modified-added">+   // Containment means &quot;contained in committed space&quot;.</span>
<span class="udiff-line-added">+   bool contains(const void* p) const             { return low() &lt;= p &amp;&amp; p &lt; high(); }</span>
    bool contains_blob(const CodeBlob* blob) const {
      // AOT CodeBlobs (i.e. AOTCompiledMethod) objects aren&#39;t allocated in the AOTCodeHeap but on the C-Heap.
      // Only the code they are pointing to is located in the AOTCodeHeap. All other CodeBlobs are allocated
      // directly in their corresponding CodeHeap with their code appended to the actual C++ object.
      // So all CodeBlobs except AOTCompiledMethod are continuous in memory with their data and code while
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -178,10 +190,11 @@</span>
    static size_t header_size();                   // returns the header size for each heap block
  
    size_t segment_size()         const { return _segment_size; }  // for CodeHeapState
    HeapBlock* first_block() const;                                // for CodeHeapState
    HeapBlock* next_block(HeapBlock* b) const;                     // for CodeHeapState
<span class="udiff-line-added">+   HeapBlock* split_block(HeapBlock* b, size_t split_seg);        // split one block into two</span>
  
    FreeBlock* freelist()         const { return _freelist; }      // for CodeHeapState
  
    size_t allocated_in_freelist() const           { return _freelist_segments * CodeCacheSegmentSize; }
    int    freelist_length()       const           { return _freelist_length; } // number of elements in the freelist
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -214,10 +227,12 @@</span>
    int         full_count()                       { return _full_count; }
    void        report_full()                      {        _full_count++; }
  
  private:
    size_t heap_unallocated_capacity() const;
<span class="udiff-line-added">+   int defrag_segmap(bool do_defrag);</span>
<span class="udiff-line-added">+   int segmap_hops(size_t beg, size_t end);</span>
  
  public:
    // Debugging
    void verify() PRODUCT_RETURN;
    void print()  PRODUCT_RETURN;
</pre>
<center><a href="heap.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="heapInspection.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
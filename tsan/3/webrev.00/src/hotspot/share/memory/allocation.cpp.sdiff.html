<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/allocation.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../logging/logTag.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="allocation.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/allocation.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;memory/allocation.hpp&quot;
 27 #include &quot;memory/allocation.inline.hpp&quot;
 28 #include &quot;memory/arena.hpp&quot;
 29 #include &quot;memory/metaspaceShared.hpp&quot;
 30 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-removed"> 31 #include &quot;memory/universe.hpp&quot;</span>
<span class="line-removed"> 32 #include &quot;runtime/atomic.hpp&quot;</span>
 33 #include &quot;runtime/os.hpp&quot;
 34 #include &quot;runtime/task.hpp&quot;
 35 #include &quot;runtime/threadCritical.hpp&quot;
 36 #include &quot;services/memTracker.hpp&quot;
 37 #include &quot;utilities/ostream.hpp&quot;
 38 
 39 // allocate using malloc; will fail if no memory available
 40 char* AllocateHeap(size_t size,
 41                    MEMFLAGS flags,
 42                    const NativeCallStack&amp; stack,
 43                    AllocFailType alloc_failmode /* = AllocFailStrategy::EXIT_OOM*/) {
 44   char* p = (char*) os::malloc(size, flags, stack);
 45   if (p == NULL &amp;&amp; alloc_failmode == AllocFailStrategy::EXIT_OOM) {
 46     vm_exit_out_of_memory(size, OOM_MALLOC_ERROR, &quot;AllocateHeap&quot;);
 47   }
 48   return p;
 49 }
 50 
 51 char* AllocateHeap(size_t size,
 52                    MEMFLAGS flags,
 53                    AllocFailType alloc_failmode /* = AllocFailStrategy::EXIT_OOM*/) {
 54   return AllocateHeap(size, flags, CALLER_PC);
 55 }
 56 
 57 char* ReallocateHeap(char *old,
 58                      size_t size,
 59                      MEMFLAGS flag,
 60                      AllocFailType alloc_failmode) {
 61   char* p = (char*) os::realloc(old, size, flag, CALLER_PC);
 62   if (p == NULL &amp;&amp; alloc_failmode == AllocFailStrategy::EXIT_OOM) {
 63     vm_exit_out_of_memory(size, OOM_MALLOC_ERROR, &quot;ReallocateHeap&quot;);
 64   }
 65   return p;
 66 }
 67 

 68 void FreeHeap(void* p) {
 69   os::free(p);
 70 }
 71 
 72 void* MetaspaceObj::_shared_metaspace_base = NULL;
 73 void* MetaspaceObj::_shared_metaspace_top  = NULL;
 74 
 75 void* StackObj::operator new(size_t size)     throw() { ShouldNotCallThis(); return 0; }
 76 void  StackObj::operator delete(void* p)              { ShouldNotCallThis(); }
 77 void* StackObj::operator new [](size_t size)  throw() { ShouldNotCallThis(); return 0; }
 78 void  StackObj::operator delete [](void* p)           { ShouldNotCallThis(); }
 79 
 80 void* MetaspaceObj::operator new(size_t size, ClassLoaderData* loader_data,
 81                                  size_t word_size,
 82                                  MetaspaceObj::Type type, TRAPS) throw() {
 83   // Klass has it&#39;s own operator new
 84   return Metaspace::allocate(loader_data, word_size, type, THREAD);
 85 }
 86 
<span class="line-modified"> 87 bool MetaspaceObj::is_metaspace_object() const {</span>
<span class="line-modified"> 88   return Metaspace::contains((void*)this);</span>






 89 }
 90 
 91 void MetaspaceObj::print_address_on(outputStream* st) const {
 92   st-&gt;print(&quot; {&quot; INTPTR_FORMAT &quot;}&quot;, p2i(this));
 93 }
 94 
 95 void* ResourceObj::operator new(size_t size, Arena *arena) throw() {
 96   address res = (address)arena-&gt;Amalloc(size);
 97   DEBUG_ONLY(set_allocation_type(res, ARENA);)
 98   return res;
 99 }
100 
101 void* ResourceObj::operator new [](size_t size, Arena *arena) throw() {
102   address res = (address)arena-&gt;Amalloc(size);
103   DEBUG_ONLY(set_allocation_type(res, ARENA);)
104   return res;
105 }
106 
107 void* ResourceObj::operator new(size_t size, allocation_type type, MEMFLAGS flags) throw() {
108   address res = NULL;
</pre>
<hr />
<pre>
237     _allocation_t[0] = (uintptr_t)badHeapOopVal; // zap type
238   }
239 }
240 #endif // ASSERT
241 
242 //--------------------------------------------------------------------------------------
243 // Non-product code
244 
245 #ifndef PRODUCT
246 void AllocatedObj::print() const       { print_on(tty); }
247 void AllocatedObj::print_value() const { print_value_on(tty); }
248 
249 void AllocatedObj::print_on(outputStream* st) const {
250   st-&gt;print_cr(&quot;AllocatedObj(&quot; INTPTR_FORMAT &quot;)&quot;, p2i(this));
251 }
252 
253 void AllocatedObj::print_value_on(outputStream* st) const {
254   st-&gt;print(&quot;AllocatedObj(&quot; INTPTR_FORMAT &quot;)&quot;, p2i(this));
255 }
256 
<span class="line-removed">257 AllocStats::AllocStats() {</span>
<span class="line-removed">258   start_mallocs      = os::num_mallocs;</span>
<span class="line-removed">259   start_frees        = os::num_frees;</span>
<span class="line-removed">260   start_malloc_bytes = os::alloc_bytes;</span>
<span class="line-removed">261   start_mfree_bytes  = os::free_bytes;</span>
<span class="line-removed">262   start_res_bytes    = Arena::_bytes_allocated;</span>
<span class="line-removed">263 }</span>
<span class="line-removed">264 </span>
<span class="line-removed">265 julong  AllocStats::num_mallocs() { return os::num_mallocs - start_mallocs; }</span>
<span class="line-removed">266 julong  AllocStats::alloc_bytes() { return os::alloc_bytes - start_malloc_bytes; }</span>
<span class="line-removed">267 julong  AllocStats::num_frees()   { return os::num_frees - start_frees; }</span>
<span class="line-removed">268 julong  AllocStats::free_bytes()  { return os::free_bytes - start_mfree_bytes; }</span>
<span class="line-removed">269 julong  AllocStats::resource_bytes() { return Arena::_bytes_allocated - start_res_bytes; }</span>
<span class="line-removed">270 void    AllocStats::print() {</span>
<span class="line-removed">271   tty-&gt;print_cr(UINT64_FORMAT &quot; mallocs (&quot; UINT64_FORMAT &quot;MB), &quot;</span>
<span class="line-removed">272                 UINT64_FORMAT &quot; frees (&quot; UINT64_FORMAT &quot;MB), &quot; UINT64_FORMAT &quot;MB resrc&quot;,</span>
<span class="line-removed">273                 num_mallocs(), alloc_bytes()/M, num_frees(), free_bytes()/M, resource_bytes()/M);</span>
<span class="line-removed">274 }</span>
<span class="line-removed">275 </span>
276 ReallocMark::ReallocMark() {
277 #ifdef ASSERT
278   Thread *thread = Thread::current();
279   _nesting = thread-&gt;resource_area()-&gt;nesting();
280 #endif
281 }
282 
283 void ReallocMark::check() {
284 #ifdef ASSERT
285   if (_nesting != Thread::current()-&gt;resource_area()-&gt;nesting()) {
286     fatal(&quot;allocation bug: array could grow within nested ResourceMark&quot;);
287   }
288 #endif
289 }
290 
291 #endif // Non-product
</pre>
</td>
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;memory/allocation.hpp&quot;
 27 #include &quot;memory/allocation.inline.hpp&quot;
 28 #include &quot;memory/arena.hpp&quot;
 29 #include &quot;memory/metaspaceShared.hpp&quot;
 30 #include &quot;memory/resourceArea.hpp&quot;


 31 #include &quot;runtime/os.hpp&quot;
 32 #include &quot;runtime/task.hpp&quot;
 33 #include &quot;runtime/threadCritical.hpp&quot;
 34 #include &quot;services/memTracker.hpp&quot;
 35 #include &quot;utilities/ostream.hpp&quot;
 36 
 37 // allocate using malloc; will fail if no memory available
 38 char* AllocateHeap(size_t size,
 39                    MEMFLAGS flags,
 40                    const NativeCallStack&amp; stack,
 41                    AllocFailType alloc_failmode /* = AllocFailStrategy::EXIT_OOM*/) {
 42   char* p = (char*) os::malloc(size, flags, stack);
 43   if (p == NULL &amp;&amp; alloc_failmode == AllocFailStrategy::EXIT_OOM) {
 44     vm_exit_out_of_memory(size, OOM_MALLOC_ERROR, &quot;AllocateHeap&quot;);
 45   }
 46   return p;
 47 }
 48 
 49 char* AllocateHeap(size_t size,
 50                    MEMFLAGS flags,
 51                    AllocFailType alloc_failmode /* = AllocFailStrategy::EXIT_OOM*/) {
 52   return AllocateHeap(size, flags, CALLER_PC);
 53 }
 54 
 55 char* ReallocateHeap(char *old,
 56                      size_t size,
 57                      MEMFLAGS flag,
 58                      AllocFailType alloc_failmode) {
 59   char* p = (char*) os::realloc(old, size, flag, CALLER_PC);
 60   if (p == NULL &amp;&amp; alloc_failmode == AllocFailStrategy::EXIT_OOM) {
 61     vm_exit_out_of_memory(size, OOM_MALLOC_ERROR, &quot;ReallocateHeap&quot;);
 62   }
 63   return p;
 64 }
 65 
<span class="line-added"> 66 // handles NULL pointers</span>
 67 void FreeHeap(void* p) {
 68   os::free(p);
 69 }
 70 
 71 void* MetaspaceObj::_shared_metaspace_base = NULL;
 72 void* MetaspaceObj::_shared_metaspace_top  = NULL;
 73 
 74 void* StackObj::operator new(size_t size)     throw() { ShouldNotCallThis(); return 0; }
 75 void  StackObj::operator delete(void* p)              { ShouldNotCallThis(); }
 76 void* StackObj::operator new [](size_t size)  throw() { ShouldNotCallThis(); return 0; }
 77 void  StackObj::operator delete [](void* p)           { ShouldNotCallThis(); }
 78 
 79 void* MetaspaceObj::operator new(size_t size, ClassLoaderData* loader_data,
 80                                  size_t word_size,
 81                                  MetaspaceObj::Type type, TRAPS) throw() {
 82   // Klass has it&#39;s own operator new
 83   return Metaspace::allocate(loader_data, word_size, type, THREAD);
 84 }
 85 
<span class="line-modified"> 86 bool MetaspaceObj::is_valid(const MetaspaceObj* p) {</span>
<span class="line-modified"> 87   // Weed out obvious bogus values first without traversing metaspace</span>
<span class="line-added"> 88   if ((size_t)p &lt; os::min_page_size()) {</span>
<span class="line-added"> 89     return false;</span>
<span class="line-added"> 90   } else if (!is_aligned((address)p, sizeof(MetaWord))) {</span>
<span class="line-added"> 91     return false;</span>
<span class="line-added"> 92   }</span>
<span class="line-added"> 93   return Metaspace::contains((void*)p);</span>
 94 }
 95 
 96 void MetaspaceObj::print_address_on(outputStream* st) const {
 97   st-&gt;print(&quot; {&quot; INTPTR_FORMAT &quot;}&quot;, p2i(this));
 98 }
 99 
100 void* ResourceObj::operator new(size_t size, Arena *arena) throw() {
101   address res = (address)arena-&gt;Amalloc(size);
102   DEBUG_ONLY(set_allocation_type(res, ARENA);)
103   return res;
104 }
105 
106 void* ResourceObj::operator new [](size_t size, Arena *arena) throw() {
107   address res = (address)arena-&gt;Amalloc(size);
108   DEBUG_ONLY(set_allocation_type(res, ARENA);)
109   return res;
110 }
111 
112 void* ResourceObj::operator new(size_t size, allocation_type type, MEMFLAGS flags) throw() {
113   address res = NULL;
</pre>
<hr />
<pre>
242     _allocation_t[0] = (uintptr_t)badHeapOopVal; // zap type
243   }
244 }
245 #endif // ASSERT
246 
247 //--------------------------------------------------------------------------------------
248 // Non-product code
249 
250 #ifndef PRODUCT
251 void AllocatedObj::print() const       { print_on(tty); }
252 void AllocatedObj::print_value() const { print_value_on(tty); }
253 
254 void AllocatedObj::print_on(outputStream* st) const {
255   st-&gt;print_cr(&quot;AllocatedObj(&quot; INTPTR_FORMAT &quot;)&quot;, p2i(this));
256 }
257 
258 void AllocatedObj::print_value_on(outputStream* st) const {
259   st-&gt;print(&quot;AllocatedObj(&quot; INTPTR_FORMAT &quot;)&quot;, p2i(this));
260 }
261 



















262 ReallocMark::ReallocMark() {
263 #ifdef ASSERT
264   Thread *thread = Thread::current();
265   _nesting = thread-&gt;resource_area()-&gt;nesting();
266 #endif
267 }
268 
269 void ReallocMark::check() {
270 #ifdef ASSERT
271   if (_nesting != Thread::current()-&gt;resource_area()-&gt;nesting()) {
272     fatal(&quot;allocation bug: array could grow within nested ResourceMark&quot;);
273   }
274 #endif
275 }
276 
277 #endif // Non-product
</pre>
</td>
</tr>
</table>
<center><a href="../logging/logTag.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="allocation.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
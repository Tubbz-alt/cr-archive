<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/memory/virtualspace.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;logging/log.hpp&quot;
  27 #include &quot;memory/resourceArea.hpp&quot;
  28 #include &quot;memory/virtualspace.hpp&quot;
  29 #include &quot;oops/markOop.hpp&quot;
  30 #include &quot;oops/oop.inline.hpp&quot;
  31 #include &quot;runtime/os.inline.hpp&quot;
  32 #include &quot;services/memTracker.hpp&quot;
  33 #include &quot;utilities/align.hpp&quot;
  34 
  35 // ReservedSpace
  36 
  37 // Dummy constructor
  38 ReservedSpace::ReservedSpace() : _base(NULL), _size(0), _noaccess_prefix(0),
  39     _alignment(0), _special(false), _fd_for_heap(-1), _executable(false) {
  40 }
  41 
  42 ReservedSpace::ReservedSpace(size_t size, size_t preferred_page_size) : _fd_for_heap(-1) {
  43   bool has_preferred_page_size = preferred_page_size != 0;
  44   // Want to use large pages where possible and pad with small pages.
  45   size_t page_size = has_preferred_page_size ? preferred_page_size : os::page_size_for_region_unaligned(size, 1);
  46   bool large_pages = page_size != (size_t)os::vm_page_size();
  47   size_t alignment;
  48   if (large_pages &amp;&amp; has_preferred_page_size) {
  49     alignment = MAX2(page_size, (size_t)os::vm_allocation_granularity());
  50     // ReservedSpace initialization requires size to be aligned to the given
  51     // alignment. Align the size up.
  52     size = align_up(size, alignment);
  53   } else {
  54     // Don&#39;t force the alignment to be large page aligned,
  55     // since that will waste memory.
  56     alignment = os::vm_allocation_granularity();
  57   }
  58   initialize(size, alignment, large_pages, NULL, false);
  59 }
  60 
  61 ReservedSpace::ReservedSpace(size_t size, size_t alignment,
  62                              bool large,
  63                              char* requested_address) : _fd_for_heap(-1) {
  64   initialize(size, alignment, large, requested_address, false);
  65 }
  66 
  67 ReservedSpace::ReservedSpace(size_t size, size_t alignment,
  68                              bool large,
  69                              bool executable) : _fd_for_heap(-1) {
  70   initialize(size, alignment, large, NULL, executable);
  71 }
  72 
  73 ReservedSpace::ReservedSpace(char* base, size_t size, size_t alignment,
  74                              bool special, bool executable) : _fd_for_heap(-1) {
  75   assert((size % os::vm_allocation_granularity()) == 0,
  76          &quot;size not allocation aligned&quot;);
  77   _base = base;
  78   _size = size;
  79   _alignment = alignment;
  80   _noaccess_prefix = 0;
  81   _special = special;
  82   _executable = executable;
  83 }
  84 
  85 // Helper method
  86 static void unmap_or_release_memory(char* base, size_t size, bool is_file_mapped) {
  87   if (is_file_mapped) {
  88     if (!os::unmap_memory(base, size)) {
  89       fatal(&quot;os::unmap_memory failed&quot;);
  90     }
  91   } else if (!os::release_memory(base, size)) {
  92     fatal(&quot;os::release_memory failed&quot;);
  93   }
  94 }
  95 
  96 // Helper method.
  97 static bool failed_to_reserve_as_requested(char* base, char* requested_address,
  98                                            const size_t size, bool special, bool is_file_mapped = false)
  99 {
 100   if (base == requested_address || requested_address == NULL)
 101     return false; // did not fail
 102 
 103   if (base != NULL) {
 104     // Different reserve address may be acceptable in other cases
 105     // but for compressed oops heap should be at requested address.
 106     assert(UseCompressedOops, &quot;currently requested address used only for compressed oops&quot;);
 107     log_debug(gc, heap, coops)(&quot;Reserved memory not at requested address: &quot; PTR_FORMAT &quot; vs &quot; PTR_FORMAT, p2i(base), p2i(requested_address));
 108     // OS ignored requested address. Try different address.
 109     if (special) {
 110       if (!os::release_memory_special(base, size)) {
 111         fatal(&quot;os::release_memory_special failed&quot;);
 112       }
 113     } else {
 114       unmap_or_release_memory(base, size, is_file_mapped);
 115     }
 116   }
 117   return true;
 118 }
 119 
 120 void ReservedSpace::initialize(size_t size, size_t alignment, bool large,
 121                                char* requested_address,
 122                                bool executable) {
 123   const size_t granularity = os::vm_allocation_granularity();
 124   assert((size &amp; (granularity - 1)) == 0,
 125          &quot;size not aligned to os::vm_allocation_granularity()&quot;);
 126   assert((alignment &amp; (granularity - 1)) == 0,
 127          &quot;alignment not aligned to os::vm_allocation_granularity()&quot;);
 128   assert(alignment == 0 || is_power_of_2((intptr_t)alignment),
 129          &quot;not a power of 2&quot;);
 130 
 131   alignment = MAX2(alignment, (size_t)os::vm_page_size());
 132 
 133   _base = NULL;
 134   _size = 0;
 135   _special = false;
 136   _executable = executable;
 137   _alignment = 0;
 138   _noaccess_prefix = 0;
 139   if (size == 0) {
 140     return;
 141   }
 142 
 143   // If OS doesn&#39;t support demand paging for large page memory, we need
 144   // to use reserve_memory_special() to reserve and pin the entire region.
 145   // If there is a backing file directory for this space then whether
 146   // large pages are allocated is up to the filesystem of the backing file.
 147   // So we ignore the UseLargePages flag in this case.
 148   bool special = large &amp;&amp; !os::can_commit_large_page_memory();
 149   if (special &amp;&amp; _fd_for_heap != -1) {
 150     special = false;
 151     if (UseLargePages &amp;&amp; (!FLAG_IS_DEFAULT(UseLargePages) ||
 152       !FLAG_IS_DEFAULT(LargePageSizeInBytes))) {
 153       log_debug(gc, heap)(&quot;Ignoring UseLargePages since large page support is up to the file system of the backing file for Java heap&quot;);
 154     }
 155   }
 156 
 157   char* base = NULL;
 158 
 159   if (special) {
 160 
 161     base = os::reserve_memory_special(size, alignment, requested_address, executable);
 162 
 163     if (base != NULL) {
 164       if (failed_to_reserve_as_requested(base, requested_address, size, true)) {
 165         // OS ignored requested address. Try different address.
 166         return;
 167       }
 168       // Check alignment constraints.
 169       assert((uintptr_t) base % alignment == 0,
 170              &quot;Large pages returned a non-aligned address, base: &quot;
 171              PTR_FORMAT &quot; alignment: &quot; SIZE_FORMAT_HEX,
 172              p2i(base), alignment);
 173       _special = true;
 174     } else {
 175       // failed; try to reserve regular memory below
 176       if (UseLargePages &amp;&amp; (!FLAG_IS_DEFAULT(UseLargePages) ||
 177                             !FLAG_IS_DEFAULT(LargePageSizeInBytes))) {
 178         log_debug(gc, heap, coops)(&quot;Reserve regular memory without large pages&quot;);
 179       }
 180     }
 181   }
 182 
 183   if (base == NULL) {
 184     // Optimistically assume that the OSes returns an aligned base pointer.
 185     // When reserving a large address range, most OSes seem to align to at
 186     // least 64K.
 187 
 188     // If the memory was requested at a particular address, use
 189     // os::attempt_reserve_memory_at() to avoid over mapping something
 190     // important.  If available space is not detected, return NULL.
 191 
 192     if (requested_address != 0) {
 193       base = os::attempt_reserve_memory_at(size, requested_address, _fd_for_heap);
 194       if (failed_to_reserve_as_requested(base, requested_address, size, false, _fd_for_heap != -1)) {
 195         // OS ignored requested address. Try different address.
 196         base = NULL;
 197       }
 198     } else {
 199       base = os::reserve_memory(size, NULL, alignment, _fd_for_heap);
 200     }
 201 
 202     if (base == NULL) return;
 203 
 204     // Check alignment constraints
 205     if ((((size_t)base) &amp; (alignment - 1)) != 0) {
 206       // Base not aligned, retry
 207       unmap_or_release_memory(base, size, _fd_for_heap != -1 /*is_file_mapped*/);
 208 
 209       // Make sure that size is aligned
 210       size = align_up(size, alignment);
 211       base = os::reserve_memory_aligned(size, alignment, _fd_for_heap);
 212 
 213       if (requested_address != 0 &amp;&amp;
 214           failed_to_reserve_as_requested(base, requested_address, size, false, _fd_for_heap != -1)) {
 215         // As a result of the alignment constraints, the allocated base differs
 216         // from the requested address. Return back to the caller who can
 217         // take remedial action (like try again without a requested address).
 218         assert(_base == NULL, &quot;should be&quot;);
 219         return;
 220       }
 221     }
 222   }
 223   // Done
 224   _base = base;
 225   _size = size;
 226   _alignment = alignment;
 227   // If heap is reserved with a backing file, the entire space has been committed. So set the _special flag to true
 228   if (_fd_for_heap != -1) {
 229     _special = true;
 230   }
 231 }
 232 
 233 ReservedSpace ReservedSpace::first_part(size_t partition_size, size_t alignment,
 234                                         bool split, bool realloc) {
 235   assert(partition_size &lt;= size(), &quot;partition failed&quot;);
 236   if (split) {
 237     os::split_reserved_memory(base(), size(), partition_size, realloc);
 238   }
 239   ReservedSpace result(base(), partition_size, alignment, special(),
 240                        executable());
 241   return result;
 242 }
 243 
 244 
 245 ReservedSpace
 246 ReservedSpace::last_part(size_t partition_size, size_t alignment) {
 247   assert(partition_size &lt;= size(), &quot;partition failed&quot;);
 248   ReservedSpace result(base() + partition_size, size() - partition_size,
 249                        alignment, special(), executable());
 250   return result;
 251 }
 252 
 253 
 254 size_t ReservedSpace::page_align_size_up(size_t size) {
 255   return align_up(size, os::vm_page_size());
 256 }
 257 
 258 
 259 size_t ReservedSpace::page_align_size_down(size_t size) {
 260   return align_down(size, os::vm_page_size());
 261 }
 262 
 263 
 264 size_t ReservedSpace::allocation_align_size_up(size_t size) {
 265   return align_up(size, os::vm_allocation_granularity());
 266 }
 267 
 268 
 269 void ReservedSpace::release() {
 270   if (is_reserved()) {
 271     char *real_base = _base - _noaccess_prefix;
 272     const size_t real_size = _size + _noaccess_prefix;
 273     if (special()) {
 274       if (_fd_for_heap != -1) {
 275         os::unmap_memory(real_base, real_size);
 276       } else {
 277         os::release_memory_special(real_base, real_size);
 278       }
 279     } else{
 280       os::release_memory(real_base, real_size);
 281     }
 282     _base = NULL;
 283     _size = 0;
 284     _noaccess_prefix = 0;
 285     _alignment = 0;
 286     _special = false;
 287     _executable = false;
 288   }
 289 }
 290 
 291 static size_t noaccess_prefix_size(size_t alignment) {
 292   return lcm(os::vm_page_size(), alignment);
 293 }
 294 
 295 void ReservedHeapSpace::establish_noaccess_prefix() {
 296   assert(_alignment &gt;= (size_t)os::vm_page_size(), &quot;must be at least page size big&quot;);
 297   _noaccess_prefix = noaccess_prefix_size(_alignment);
 298 
 299   if (base() &amp;&amp; base() + _size &gt; (char *)OopEncodingHeapMax) {
 300     if (true
 301         WIN64_ONLY(&amp;&amp; !UseLargePages)
 302         AIX_ONLY(&amp;&amp; os::vm_page_size() != 64*K)) {
 303       // Protect memory at the base of the allocated region.
 304       // If special, the page was committed (only matters on windows)
 305       if (!os::protect_memory(_base, _noaccess_prefix, os::MEM_PROT_NONE, _special)) {
 306         fatal(&quot;cannot protect protection page&quot;);
 307       }
 308       log_debug(gc, heap, coops)(&quot;Protected page at the reserved heap base: &quot;
 309                                  PTR_FORMAT &quot; / &quot; INTX_FORMAT &quot; bytes&quot;,
 310                                  p2i(_base),
 311                                  _noaccess_prefix);
 312       assert(Universe::narrow_oop_use_implicit_null_checks() == true, &quot;not initialized?&quot;);
 313     } else {
 314       Universe::set_narrow_oop_use_implicit_null_checks(false);
 315     }
 316   }
 317 
 318   _base += _noaccess_prefix;
 319   _size -= _noaccess_prefix;
 320   assert(((uintptr_t)_base % _alignment == 0), &quot;must be exactly of required alignment&quot;);
 321 }
 322 
 323 // Tries to allocate memory of size &#39;size&#39; at address requested_address with alignment &#39;alignment&#39;.
 324 // Does not check whether the reserved memory actually is at requested_address, as the memory returned
 325 // might still fulfill the wishes of the caller.
 326 // Assures the memory is aligned to &#39;alignment&#39;.
 327 // NOTE: If ReservedHeapSpace already points to some reserved memory this is freed, first.
 328 void ReservedHeapSpace::try_reserve_heap(size_t size,
 329                                          size_t alignment,
 330                                          bool large,
 331                                          char* requested_address) {
 332   if (_base != NULL) {
 333     // We tried before, but we didn&#39;t like the address delivered.
 334     release();
 335   }
 336 
 337   // If OS doesn&#39;t support demand paging for large page memory, we need
 338   // to use reserve_memory_special() to reserve and pin the entire region.
 339   // If there is a backing file directory for this space then whether
 340   // large pages are allocated is up to the filesystem of the backing file.
 341   // So we ignore the UseLargePages flag in this case.
 342   bool special = large &amp;&amp; !os::can_commit_large_page_memory();
 343   if (special &amp;&amp; _fd_for_heap != -1) {
 344     special = false;
 345     if (UseLargePages &amp;&amp; (!FLAG_IS_DEFAULT(UseLargePages) ||
 346                           !FLAG_IS_DEFAULT(LargePageSizeInBytes))) {
 347       log_debug(gc, heap)(&quot;Cannot allocate large pages for Java Heap when AllocateHeapAt option is set.&quot;);
 348     }
 349   }
 350   char* base = NULL;
 351 
 352   log_trace(gc, heap, coops)(&quot;Trying to allocate at address &quot; PTR_FORMAT
 353                              &quot; heap of size &quot; SIZE_FORMAT_HEX,
 354                              p2i(requested_address),
 355                              size);
 356 
 357   if (special) {
 358     base = os::reserve_memory_special(size, alignment, requested_address, false);
 359 
 360     if (base != NULL) {
 361       // Check alignment constraints.
 362       assert((uintptr_t) base % alignment == 0,
 363              &quot;Large pages returned a non-aligned address, base: &quot;
 364              PTR_FORMAT &quot; alignment: &quot; SIZE_FORMAT_HEX,
 365              p2i(base), alignment);
 366       _special = true;
 367     }
 368   }
 369 
 370   if (base == NULL) {
 371     // Failed; try to reserve regular memory below
 372     if (UseLargePages &amp;&amp; (!FLAG_IS_DEFAULT(UseLargePages) ||
 373                           !FLAG_IS_DEFAULT(LargePageSizeInBytes))) {
 374       log_debug(gc, heap, coops)(&quot;Reserve regular memory without large pages&quot;);
 375     }
 376 
 377     // Optimistically assume that the OSes returns an aligned base pointer.
 378     // When reserving a large address range, most OSes seem to align to at
 379     // least 64K.
 380 
 381     // If the memory was requested at a particular address, use
 382     // os::attempt_reserve_memory_at() to avoid over mapping something
 383     // important.  If available space is not detected, return NULL.
 384 
 385     if (requested_address != 0) {
 386       base = os::attempt_reserve_memory_at(size, requested_address, _fd_for_heap);
 387     } else {
 388       base = os::reserve_memory(size, NULL, alignment, _fd_for_heap);
 389     }
 390   }
 391   if (base == NULL) { return; }
 392 
 393   // Done
 394   _base = base;
 395   _size = size;
 396   _alignment = alignment;
 397 
 398   // If heap is reserved with a backing file, the entire space has been committed. So set the _special flag to true
 399   if (_fd_for_heap != -1) {
 400     _special = true;
 401   }
 402 
 403   // Check alignment constraints
 404   if ((((size_t)base) &amp; (alignment - 1)) != 0) {
 405     // Base not aligned, retry.
 406     release();
 407   }
 408 }
 409 
 410 void ReservedHeapSpace::try_reserve_range(char *highest_start,
 411                                           char *lowest_start,
 412                                           size_t attach_point_alignment,
 413                                           char *aligned_heap_base_min_address,
 414                                           char *upper_bound,
 415                                           size_t size,
 416                                           size_t alignment,
 417                                           bool large) {
 418   const size_t attach_range = highest_start - lowest_start;
 419   // Cap num_attempts at possible number.
 420   // At least one is possible even for 0 sized attach range.
 421   const uint64_t num_attempts_possible = (attach_range / attach_point_alignment) + 1;
 422   const uint64_t num_attempts_to_try   = MIN2((uint64_t)HeapSearchSteps, num_attempts_possible);
 423 
 424   const size_t stepsize = (attach_range == 0) ? // Only one try.
 425     (size_t) highest_start : align_up(attach_range / num_attempts_to_try, attach_point_alignment);
 426 
 427   // Try attach points from top to bottom.
 428   char* attach_point = highest_start;
 429   while (attach_point &gt;= lowest_start  &amp;&amp;
 430          attach_point &lt;= highest_start &amp;&amp;  // Avoid wrap around.
 431          ((_base == NULL) ||
 432           (_base &lt; aligned_heap_base_min_address || _base + size &gt; upper_bound))) {
 433     try_reserve_heap(size, alignment, large, attach_point);
 434     attach_point -= stepsize;
 435   }
 436 }
 437 
 438 #define SIZE_64K  ((uint64_t) UCONST64(      0x10000))
 439 #define SIZE_256M ((uint64_t) UCONST64(   0x10000000))
 440 #define SIZE_32G  ((uint64_t) UCONST64(  0x800000000))
 441 
 442 // Helper for heap allocation. Returns an array with addresses
 443 // (OS-specific) which are suited for disjoint base mode. Array is
 444 // NULL terminated.
 445 static char** get_attach_addresses_for_disjoint_mode() {
 446   static uint64_t addresses[] = {
 447      2 * SIZE_32G,
 448      3 * SIZE_32G,
 449      4 * SIZE_32G,
 450      8 * SIZE_32G,
 451     10 * SIZE_32G,
 452      1 * SIZE_64K * SIZE_32G,
 453      2 * SIZE_64K * SIZE_32G,
 454      3 * SIZE_64K * SIZE_32G,
 455      4 * SIZE_64K * SIZE_32G,
 456     16 * SIZE_64K * SIZE_32G,
 457     32 * SIZE_64K * SIZE_32G,
 458     34 * SIZE_64K * SIZE_32G,
 459     0
 460   };
 461 
 462   // Sort out addresses smaller than HeapBaseMinAddress. This assumes
 463   // the array is sorted.
 464   uint i = 0;
 465   while (addresses[i] != 0 &amp;&amp;
 466          (addresses[i] &lt; OopEncodingHeapMax || addresses[i] &lt; HeapBaseMinAddress)) {
 467     i++;
 468   }
 469   uint start = i;
 470 
 471   // Avoid more steps than requested.
 472   i = 0;
 473   while (addresses[start+i] != 0) {
 474     if (i == HeapSearchSteps) {
 475       addresses[start+i] = 0;
 476       break;
 477     }
 478     i++;
 479   }
 480 
 481   return (char**) &amp;addresses[start];
 482 }
 483 
 484 void ReservedHeapSpace::initialize_compressed_heap(const size_t size, size_t alignment, bool large) {
 485   guarantee(size + noaccess_prefix_size(alignment) &lt;= OopEncodingHeapMax,
 486             &quot;can not allocate compressed oop heap for this size&quot;);
 487   guarantee(alignment == MAX2(alignment, (size_t)os::vm_page_size()), &quot;alignment too small&quot;);
 488 
 489   const size_t granularity = os::vm_allocation_granularity();
 490   assert((size &amp; (granularity - 1)) == 0,
 491          &quot;size not aligned to os::vm_allocation_granularity()&quot;);
 492   assert((alignment &amp; (granularity - 1)) == 0,
 493          &quot;alignment not aligned to os::vm_allocation_granularity()&quot;);
 494   assert(alignment == 0 || is_power_of_2((intptr_t)alignment),
 495          &quot;not a power of 2&quot;);
 496 
 497   // The necessary attach point alignment for generated wish addresses.
 498   // This is needed to increase the chance of attaching for mmap and shmat.
 499   const size_t os_attach_point_alignment =
 500     AIX_ONLY(SIZE_256M)  // Known shm boundary alignment.
 501     NOT_AIX(os::vm_allocation_granularity());
 502   const size_t attach_point_alignment = lcm(alignment, os_attach_point_alignment);
 503 
 504   char *aligned_heap_base_min_address = (char *)align_up((void *)HeapBaseMinAddress, alignment);
 505   size_t noaccess_prefix = ((aligned_heap_base_min_address + size) &gt; (char*)OopEncodingHeapMax) ?
 506     noaccess_prefix_size(alignment) : 0;
 507 
 508   // Attempt to alloc at user-given address.
 509   if (!FLAG_IS_DEFAULT(HeapBaseMinAddress)) {
 510     try_reserve_heap(size + noaccess_prefix, alignment, large, aligned_heap_base_min_address);
 511     if (_base != aligned_heap_base_min_address) { // Enforce this exact address.
 512       release();
 513     }
 514   }
 515 
 516   // Keep heap at HeapBaseMinAddress.
 517   if (_base == NULL) {
 518 
 519     // Try to allocate the heap at addresses that allow efficient oop compression.
 520     // Different schemes are tried, in order of decreasing optimization potential.
 521     //
 522     // For this, try_reserve_heap() is called with the desired heap base addresses.
 523     // A call into the os layer to allocate at a given address can return memory
 524     // at a different address than requested.  Still, this might be memory at a useful
 525     // address. try_reserve_heap() always returns this allocated memory, as only here
 526     // the criteria for a good heap are checked.
 527 
 528     // Attempt to allocate so that we can run without base and scale (32-Bit unscaled compressed oops).
 529     // Give it several tries from top of range to bottom.
 530     if (aligned_heap_base_min_address + size &lt;= (char *)UnscaledOopHeapMax) {
 531 
 532       // Calc address range within we try to attach (range of possible start addresses).
 533       char* const highest_start = align_down((char *)UnscaledOopHeapMax - size, attach_point_alignment);
 534       char* const lowest_start  = align_up(aligned_heap_base_min_address, attach_point_alignment);
 535       try_reserve_range(highest_start, lowest_start, attach_point_alignment,
 536                         aligned_heap_base_min_address, (char *)UnscaledOopHeapMax, size, alignment, large);
 537     }
 538 
 539     // zerobased: Attempt to allocate in the lower 32G.
 540     // But leave room for the compressed class pointers, which is allocated above
 541     // the heap.
 542     char *zerobased_max = (char *)OopEncodingHeapMax;
 543     const size_t class_space = align_up(CompressedClassSpaceSize, alignment);
 544     // For small heaps, save some space for compressed class pointer
 545     // space so it can be decoded with no base.
 546     if (UseCompressedClassPointers &amp;&amp; !UseSharedSpaces &amp;&amp;
 547         OopEncodingHeapMax &lt;= KlassEncodingMetaspaceMax &amp;&amp;
 548         (uint64_t)(aligned_heap_base_min_address + size + class_space) &lt;= KlassEncodingMetaspaceMax) {
 549       zerobased_max = (char *)OopEncodingHeapMax - class_space;
 550     }
 551 
 552     // Give it several tries from top of range to bottom.
 553     if (aligned_heap_base_min_address + size &lt;= zerobased_max &amp;&amp;    // Zerobased theoretical possible.
 554         ((_base == NULL) ||                        // No previous try succeeded.
 555          (_base + size &gt; zerobased_max))) {        // Unscaled delivered an arbitrary address.
 556 
 557       // Calc address range within we try to attach (range of possible start addresses).
 558       char *const highest_start = align_down(zerobased_max - size, attach_point_alignment);
 559       // Need to be careful about size being guaranteed to be less
 560       // than UnscaledOopHeapMax due to type constraints.
 561       char *lowest_start = aligned_heap_base_min_address;
 562       uint64_t unscaled_end = UnscaledOopHeapMax - size;
 563       if (unscaled_end &lt; UnscaledOopHeapMax) { // unscaled_end wrapped if size is large
 564         lowest_start = MAX2(lowest_start, (char*)unscaled_end);
 565       }
 566       lowest_start = align_up(lowest_start, attach_point_alignment);
 567       try_reserve_range(highest_start, lowest_start, attach_point_alignment,
 568                         aligned_heap_base_min_address, zerobased_max, size, alignment, large);
 569     }
 570 
 571     // Now we go for heaps with base != 0.  We need a noaccess prefix to efficiently
 572     // implement null checks.
 573     noaccess_prefix = noaccess_prefix_size(alignment);
 574 
 575     // Try to attach at addresses that are aligned to OopEncodingHeapMax. Disjointbase mode.
 576     char** addresses = get_attach_addresses_for_disjoint_mode();
 577     int i = 0;
 578     while (addresses[i] &amp;&amp;                                 // End of array not yet reached.
 579            ((_base == NULL) ||                             // No previous try succeeded.
 580             (_base + size &gt;  (char *)OopEncodingHeapMax &amp;&amp; // Not zerobased or unscaled address.
 581              !Universe::is_disjoint_heap_base_address((address)_base)))) {  // Not disjoint address.
 582       char* const attach_point = addresses[i];
 583       assert(attach_point &gt;= aligned_heap_base_min_address, &quot;Flag support broken&quot;);
 584       try_reserve_heap(size + noaccess_prefix, alignment, large, attach_point);
 585       i++;
 586     }
 587 
 588     // Last, desperate try without any placement.
 589     if (_base == NULL) {
 590       log_trace(gc, heap, coops)(&quot;Trying to allocate at address NULL heap of size &quot; SIZE_FORMAT_HEX, size + noaccess_prefix);
 591       initialize(size + noaccess_prefix, alignment, large, NULL, false);
 592     }
 593   }
 594 }
 595 
 596 ReservedHeapSpace::ReservedHeapSpace(size_t size, size_t alignment, bool large, const char* heap_allocation_directory) : ReservedSpace() {
 597 
 598   if (size == 0) {
 599     return;
 600   }
 601 
 602   if (heap_allocation_directory != NULL) {
 603     _fd_for_heap = os::create_file_for_heap(heap_allocation_directory);
 604     if (_fd_for_heap == -1) {
 605       vm_exit_during_initialization(
 606         err_msg(&quot;Could not create file for Heap at location %s&quot;, heap_allocation_directory));
 607     }
 608   }
 609 
 610   // Heap size should be aligned to alignment, too.
 611   guarantee(is_aligned(size, alignment), &quot;set by caller&quot;);
 612 
 613   if (UseCompressedOops) {
 614     initialize_compressed_heap(size, alignment, large);
 615     if (_size &gt; size) {
 616       // We allocated heap with noaccess prefix.
 617       // It can happen we get a zerobased/unscaled heap with noaccess prefix,
 618       // if we had to try at arbitrary address.
 619       establish_noaccess_prefix();
 620     }
 621   } else {
 622     initialize(size, alignment, large, NULL, false);
 623   }
 624 
 625   assert(markOopDesc::encode_pointer_as_mark(_base)-&gt;decode_pointer() == _base,
 626          &quot;area must be distinguishable from marks for mark-sweep&quot;);
 627   assert(markOopDesc::encode_pointer_as_mark(&amp;_base[size])-&gt;decode_pointer() == &amp;_base[size],
 628          &quot;area must be distinguishable from marks for mark-sweep&quot;);
 629 
 630   if (base() != NULL) {
 631     MemTracker::record_virtual_memory_type((address)base(), mtJavaHeap);
 632   }
 633 
 634   if (_fd_for_heap != -1) {
 635     os::close(_fd_for_heap);
 636   }
 637 }
 638 
 639 // Reserve space for code segment.  Same as Java heap only we mark this as
 640 // executable.
 641 ReservedCodeSpace::ReservedCodeSpace(size_t r_size,
 642                                      size_t rs_align,
 643                                      bool large) :
 644   ReservedSpace(r_size, rs_align, large, /*executable*/ true) {
 645   MemTracker::record_virtual_memory_type((address)base(), mtCode);
 646 }
 647 
 648 // VirtualSpace
 649 
 650 VirtualSpace::VirtualSpace() {
 651   _low_boundary           = NULL;
 652   _high_boundary          = NULL;
 653   _low                    = NULL;
 654   _high                   = NULL;
 655   _lower_high             = NULL;
 656   _middle_high            = NULL;
 657   _upper_high             = NULL;
 658   _lower_high_boundary    = NULL;
 659   _middle_high_boundary   = NULL;
 660   _upper_high_boundary    = NULL;
 661   _lower_alignment        = 0;
 662   _middle_alignment       = 0;
 663   _upper_alignment        = 0;
 664   _special                = false;
 665   _executable             = false;
 666 }
 667 
 668 
 669 bool VirtualSpace::initialize(ReservedSpace rs, size_t committed_size) {
 670   const size_t max_commit_granularity = os::page_size_for_region_unaligned(rs.size(), 1);
 671   return initialize_with_granularity(rs, committed_size, max_commit_granularity);
 672 }
 673 
 674 bool VirtualSpace::initialize_with_granularity(ReservedSpace rs, size_t committed_size, size_t max_commit_granularity) {
 675   if(!rs.is_reserved()) return false;  // allocation failed.
 676   assert(_low_boundary == NULL, &quot;VirtualSpace already initialized&quot;);
 677   assert(max_commit_granularity &gt; 0, &quot;Granularity must be non-zero.&quot;);
 678 
 679   _low_boundary  = rs.base();
 680   _high_boundary = low_boundary() + rs.size();
 681 
 682   _low = low_boundary();
 683   _high = low();
 684 
 685   _special = rs.special();
 686   _executable = rs.executable();
 687 
 688   // When a VirtualSpace begins life at a large size, make all future expansion
 689   // and shrinking occur aligned to a granularity of large pages.  This avoids
 690   // fragmentation of physical addresses that inhibits the use of large pages
 691   // by the OS virtual memory system.  Empirically,  we see that with a 4MB
 692   // page size, the only spaces that get handled this way are codecache and
 693   // the heap itself, both of which provide a substantial performance
 694   // boost in many benchmarks when covered by large pages.
 695   //
 696   // No attempt is made to force large page alignment at the very top and
 697   // bottom of the space if they are not aligned so already.
 698   _lower_alignment  = os::vm_page_size();
 699   _middle_alignment = max_commit_granularity;
 700   _upper_alignment  = os::vm_page_size();
 701 
 702   // End of each region
 703   _lower_high_boundary = align_up(low_boundary(), middle_alignment());
 704   _middle_high_boundary = align_down(high_boundary(), middle_alignment());
 705   _upper_high_boundary = high_boundary();
 706 
 707   // High address of each region
 708   _lower_high = low_boundary();
 709   _middle_high = lower_high_boundary();
 710   _upper_high = middle_high_boundary();
 711 
 712   // commit to initial size
 713   if (committed_size &gt; 0) {
 714     if (!expand_by(committed_size)) {
 715       return false;
 716     }
 717   }
 718   return true;
 719 }
 720 
 721 
 722 VirtualSpace::~VirtualSpace() {
 723   release();
 724 }
 725 
 726 
 727 void VirtualSpace::release() {
 728   // This does not release memory it reserved.
 729   // Caller must release via rs.release();
 730   _low_boundary           = NULL;
 731   _high_boundary          = NULL;
 732   _low                    = NULL;
 733   _high                   = NULL;
 734   _lower_high             = NULL;
 735   _middle_high            = NULL;
 736   _upper_high             = NULL;
 737   _lower_high_boundary    = NULL;
 738   _middle_high_boundary   = NULL;
 739   _upper_high_boundary    = NULL;
 740   _lower_alignment        = 0;
 741   _middle_alignment       = 0;
 742   _upper_alignment        = 0;
 743   _special                = false;
 744   _executable             = false;
 745 }
 746 
 747 
 748 size_t VirtualSpace::committed_size() const {
 749   return pointer_delta(high(), low(), sizeof(char));
 750 }
 751 
 752 
 753 size_t VirtualSpace::reserved_size() const {
 754   return pointer_delta(high_boundary(), low_boundary(), sizeof(char));
 755 }
 756 
 757 
 758 size_t VirtualSpace::uncommitted_size()  const {
 759   return reserved_size() - committed_size();
 760 }
 761 
 762 size_t VirtualSpace::actual_committed_size() const {
 763   // Special VirtualSpaces commit all reserved space up front.
 764   if (special()) {
 765     return reserved_size();
 766   }
 767 
 768   size_t committed_low    = pointer_delta(_lower_high,  _low_boundary,         sizeof(char));
 769   size_t committed_middle = pointer_delta(_middle_high, _lower_high_boundary,  sizeof(char));
 770   size_t committed_high   = pointer_delta(_upper_high,  _middle_high_boundary, sizeof(char));
 771 
 772 #ifdef ASSERT
 773   size_t lower  = pointer_delta(_lower_high_boundary,  _low_boundary,         sizeof(char));
 774   size_t middle = pointer_delta(_middle_high_boundary, _lower_high_boundary,  sizeof(char));
 775   size_t upper  = pointer_delta(_upper_high_boundary,  _middle_high_boundary, sizeof(char));
 776 
 777   if (committed_high &gt; 0) {
 778     assert(committed_low == lower, &quot;Must be&quot;);
 779     assert(committed_middle == middle, &quot;Must be&quot;);
 780   }
 781 
 782   if (committed_middle &gt; 0) {
 783     assert(committed_low == lower, &quot;Must be&quot;);
 784   }
 785   if (committed_middle &lt; middle) {
 786     assert(committed_high == 0, &quot;Must be&quot;);
 787   }
 788 
 789   if (committed_low &lt; lower) {
 790     assert(committed_high == 0, &quot;Must be&quot;);
 791     assert(committed_middle == 0, &quot;Must be&quot;);
 792   }
 793 #endif
 794 
 795   return committed_low + committed_middle + committed_high;
 796 }
 797 
 798 
 799 bool VirtualSpace::contains(const void* p) const {
 800   return low() &lt;= (const char*) p &amp;&amp; (const char*) p &lt; high();
 801 }
 802 
 803 static void pretouch_expanded_memory(void* start, void* end) {
 804   assert(is_aligned(start, os::vm_page_size()), &quot;Unexpected alignment&quot;);
 805   assert(is_aligned(end,   os::vm_page_size()), &quot;Unexpected alignment&quot;);
 806 
 807   os::pretouch_memory(start, end);
 808 }
 809 
 810 static bool commit_expanded(char* start, size_t size, size_t alignment, bool pre_touch, bool executable) {
 811   if (os::commit_memory(start, size, alignment, executable)) {
 812     if (pre_touch || AlwaysPreTouch) {
 813       pretouch_expanded_memory(start, start + size);
 814     }
 815     return true;
 816   }
 817 
 818   debug_only(warning(
 819       &quot;INFO: os::commit_memory(&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT
 820       &quot; size=&quot; SIZE_FORMAT &quot;, executable=%d) failed&quot;,
 821       p2i(start), p2i(start + size), size, executable);)
 822 
 823   return false;
 824 }
 825 
 826 /*
 827    First we need to determine if a particular virtual space is using large
 828    pages.  This is done at the initialize function and only virtual spaces
 829    that are larger than LargePageSizeInBytes use large pages.  Once we
 830    have determined this, all expand_by and shrink_by calls must grow and
 831    shrink by large page size chunks.  If a particular request
 832    is within the current large page, the call to commit and uncommit memory
 833    can be ignored.  In the case that the low and high boundaries of this
 834    space is not large page aligned, the pages leading to the first large
 835    page address and the pages after the last large page address must be
 836    allocated with default pages.
 837 */
 838 bool VirtualSpace::expand_by(size_t bytes, bool pre_touch) {
 839   if (uncommitted_size() &lt; bytes) {
 840     return false;
 841   }
 842 
 843   if (special()) {
 844     // don&#39;t commit memory if the entire space is pinned in memory
 845     _high += bytes;
 846     return true;
 847   }
 848 
 849   char* previous_high = high();
 850   char* unaligned_new_high = high() + bytes;
 851   assert(unaligned_new_high &lt;= high_boundary(), &quot;cannot expand by more than upper boundary&quot;);
 852 
 853   // Calculate where the new high for each of the regions should be.  If
 854   // the low_boundary() and high_boundary() are LargePageSizeInBytes aligned
 855   // then the unaligned lower and upper new highs would be the
 856   // lower_high() and upper_high() respectively.
 857   char* unaligned_lower_new_high =  MIN2(unaligned_new_high, lower_high_boundary());
 858   char* unaligned_middle_new_high = MIN2(unaligned_new_high, middle_high_boundary());
 859   char* unaligned_upper_new_high =  MIN2(unaligned_new_high, upper_high_boundary());
 860 
 861   // Align the new highs based on the regions alignment.  lower and upper
 862   // alignment will always be default page size.  middle alignment will be
 863   // LargePageSizeInBytes if the actual size of the virtual space is in
 864   // fact larger than LargePageSizeInBytes.
 865   char* aligned_lower_new_high =  align_up(unaligned_lower_new_high, lower_alignment());
 866   char* aligned_middle_new_high = align_up(unaligned_middle_new_high, middle_alignment());
 867   char* aligned_upper_new_high =  align_up(unaligned_upper_new_high, upper_alignment());
 868 
 869   // Determine which regions need to grow in this expand_by call.
 870   // If you are growing in the lower region, high() must be in that
 871   // region so calculate the size based on high().  For the middle and
 872   // upper regions, determine the starting point of growth based on the
 873   // location of high().  By getting the MAX of the region&#39;s low address
 874   // (or the previous region&#39;s high address) and high(), we can tell if it
 875   // is an intra or inter region growth.
 876   size_t lower_needs = 0;
 877   if (aligned_lower_new_high &gt; lower_high()) {
 878     lower_needs = pointer_delta(aligned_lower_new_high, lower_high(), sizeof(char));
 879   }
 880   size_t middle_needs = 0;
 881   if (aligned_middle_new_high &gt; middle_high()) {
 882     middle_needs = pointer_delta(aligned_middle_new_high, middle_high(), sizeof(char));
 883   }
 884   size_t upper_needs = 0;
 885   if (aligned_upper_new_high &gt; upper_high()) {
 886     upper_needs = pointer_delta(aligned_upper_new_high, upper_high(), sizeof(char));
 887   }
 888 
 889   // Check contiguity.
 890   assert(low_boundary() &lt;= lower_high() &amp;&amp; lower_high() &lt;= lower_high_boundary(),
 891          &quot;high address must be contained within the region&quot;);
 892   assert(lower_high_boundary() &lt;= middle_high() &amp;&amp; middle_high() &lt;= middle_high_boundary(),
 893          &quot;high address must be contained within the region&quot;);
 894   assert(middle_high_boundary() &lt;= upper_high() &amp;&amp; upper_high() &lt;= upper_high_boundary(),
 895          &quot;high address must be contained within the region&quot;);
 896 
 897   // Commit regions
 898   if (lower_needs &gt; 0) {
 899     assert(lower_high() + lower_needs &lt;= lower_high_boundary(), &quot;must not expand beyond region&quot;);
 900     if (!commit_expanded(lower_high(), lower_needs, _lower_alignment, pre_touch, _executable)) {
 901       return false;
 902     }
 903     _lower_high += lower_needs;
 904   }
 905 
 906   if (middle_needs &gt; 0) {
 907     assert(middle_high() + middle_needs &lt;= middle_high_boundary(), &quot;must not expand beyond region&quot;);
 908     if (!commit_expanded(middle_high(), middle_needs, _middle_alignment, pre_touch, _executable)) {
 909       return false;
 910     }
 911     _middle_high += middle_needs;
 912   }
 913 
 914   if (upper_needs &gt; 0) {
 915     assert(upper_high() + upper_needs &lt;= upper_high_boundary(), &quot;must not expand beyond region&quot;);
 916     if (!commit_expanded(upper_high(), upper_needs, _upper_alignment, pre_touch, _executable)) {
 917       return false;
 918     }
 919     _upper_high += upper_needs;
 920   }
 921 
 922   _high += bytes;
 923   return true;
 924 }
 925 
 926 // A page is uncommitted if the contents of the entire page is deemed unusable.
 927 // Continue to decrement the high() pointer until it reaches a page boundary
 928 // in which case that particular page can now be uncommitted.
 929 void VirtualSpace::shrink_by(size_t size) {
 930   if (committed_size() &lt; size)
 931     fatal(&quot;Cannot shrink virtual space to negative size&quot;);
 932 
 933   if (special()) {
 934     // don&#39;t uncommit if the entire space is pinned in memory
 935     _high -= size;
 936     return;
 937   }
 938 
 939   char* unaligned_new_high = high() - size;
 940   assert(unaligned_new_high &gt;= low_boundary(), &quot;cannot shrink past lower boundary&quot;);
 941 
 942   // Calculate new unaligned address
 943   char* unaligned_upper_new_high =
 944     MAX2(unaligned_new_high, middle_high_boundary());
 945   char* unaligned_middle_new_high =
 946     MAX2(unaligned_new_high, lower_high_boundary());
 947   char* unaligned_lower_new_high =
 948     MAX2(unaligned_new_high, low_boundary());
 949 
 950   // Align address to region&#39;s alignment
 951   char* aligned_upper_new_high =  align_up(unaligned_upper_new_high, upper_alignment());
 952   char* aligned_middle_new_high = align_up(unaligned_middle_new_high, middle_alignment());
 953   char* aligned_lower_new_high =  align_up(unaligned_lower_new_high, lower_alignment());
 954 
 955   // Determine which regions need to shrink
 956   size_t upper_needs = 0;
 957   if (aligned_upper_new_high &lt; upper_high()) {
 958     upper_needs =
 959       pointer_delta(upper_high(), aligned_upper_new_high, sizeof(char));
 960   }
 961   size_t middle_needs = 0;
 962   if (aligned_middle_new_high &lt; middle_high()) {
 963     middle_needs =
 964       pointer_delta(middle_high(), aligned_middle_new_high, sizeof(char));
 965   }
 966   size_t lower_needs = 0;
 967   if (aligned_lower_new_high &lt; lower_high()) {
 968     lower_needs =
 969       pointer_delta(lower_high(), aligned_lower_new_high, sizeof(char));
 970   }
 971 
 972   // Check contiguity.
 973   assert(middle_high_boundary() &lt;= upper_high() &amp;&amp;
 974          upper_high() &lt;= upper_high_boundary(),
 975          &quot;high address must be contained within the region&quot;);
 976   assert(lower_high_boundary() &lt;= middle_high() &amp;&amp;
 977          middle_high() &lt;= middle_high_boundary(),
 978          &quot;high address must be contained within the region&quot;);
 979   assert(low_boundary() &lt;= lower_high() &amp;&amp;
 980          lower_high() &lt;= lower_high_boundary(),
 981          &quot;high address must be contained within the region&quot;);
 982 
 983   // Uncommit
 984   if (upper_needs &gt; 0) {
 985     assert(middle_high_boundary() &lt;= aligned_upper_new_high &amp;&amp;
 986            aligned_upper_new_high + upper_needs &lt;= upper_high_boundary(),
 987            &quot;must not shrink beyond region&quot;);
 988     if (!os::uncommit_memory(aligned_upper_new_high, upper_needs)) {
 989       debug_only(warning(&quot;os::uncommit_memory failed&quot;));
 990       return;
 991     } else {
 992       _upper_high -= upper_needs;
 993     }
 994   }
 995   if (middle_needs &gt; 0) {
 996     assert(lower_high_boundary() &lt;= aligned_middle_new_high &amp;&amp;
 997            aligned_middle_new_high + middle_needs &lt;= middle_high_boundary(),
 998            &quot;must not shrink beyond region&quot;);
 999     if (!os::uncommit_memory(aligned_middle_new_high, middle_needs)) {
1000       debug_only(warning(&quot;os::uncommit_memory failed&quot;));
1001       return;
1002     } else {
1003       _middle_high -= middle_needs;
1004     }
1005   }
1006   if (lower_needs &gt; 0) {
1007     assert(low_boundary() &lt;= aligned_lower_new_high &amp;&amp;
1008            aligned_lower_new_high + lower_needs &lt;= lower_high_boundary(),
1009            &quot;must not shrink beyond region&quot;);
1010     if (!os::uncommit_memory(aligned_lower_new_high, lower_needs)) {
1011       debug_only(warning(&quot;os::uncommit_memory failed&quot;));
1012       return;
1013     } else {
1014       _lower_high -= lower_needs;
1015     }
1016   }
1017 
1018   _high -= size;
1019 }
1020 
1021 #ifndef PRODUCT
1022 void VirtualSpace::check_for_contiguity() {
1023   // Check contiguity.
1024   assert(low_boundary() &lt;= lower_high() &amp;&amp;
1025          lower_high() &lt;= lower_high_boundary(),
1026          &quot;high address must be contained within the region&quot;);
1027   assert(lower_high_boundary() &lt;= middle_high() &amp;&amp;
1028          middle_high() &lt;= middle_high_boundary(),
1029          &quot;high address must be contained within the region&quot;);
1030   assert(middle_high_boundary() &lt;= upper_high() &amp;&amp;
1031          upper_high() &lt;= upper_high_boundary(),
1032          &quot;high address must be contained within the region&quot;);
1033   assert(low() &gt;= low_boundary(), &quot;low&quot;);
1034   assert(low_boundary() &lt;= lower_high_boundary(), &quot;lower high boundary&quot;);
1035   assert(upper_high_boundary() &lt;= high_boundary(), &quot;upper high boundary&quot;);
1036   assert(high() &lt;= upper_high(), &quot;upper high&quot;);
1037 }
1038 
1039 void VirtualSpace::print_on(outputStream* out) {
1040   out-&gt;print   (&quot;Virtual space:&quot;);
1041   if (special()) out-&gt;print(&quot; (pinned in memory)&quot;);
1042   out-&gt;cr();
1043   out-&gt;print_cr(&quot; - committed: &quot; SIZE_FORMAT, committed_size());
1044   out-&gt;print_cr(&quot; - reserved:  &quot; SIZE_FORMAT, reserved_size());
1045   out-&gt;print_cr(&quot; - [low, high]:     [&quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;]&quot;,  p2i(low()), p2i(high()));
1046   out-&gt;print_cr(&quot; - [low_b, high_b]: [&quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;]&quot;,  p2i(low_boundary()), p2i(high_boundary()));
1047 }
1048 
1049 void VirtualSpace::print() {
1050   print_on(tty);
1051 }
1052 
1053 /////////////// Unit tests ///////////////
1054 
1055 #ifndef PRODUCT
1056 
1057 class TestReservedSpace : AllStatic {
1058  public:
1059   static void small_page_write(void* addr, size_t size) {
1060     size_t page_size = os::vm_page_size();
1061 
1062     char* end = (char*)addr + size;
1063     for (char* p = (char*)addr; p &lt; end; p += page_size) {
1064       *p = 1;
1065     }
1066   }
1067 
1068   static void release_memory_for_test(ReservedSpace rs) {
1069     if (rs.special()) {
1070       guarantee(os::release_memory_special(rs.base(), rs.size()), &quot;Shouldn&#39;t fail&quot;);
1071     } else {
1072       guarantee(os::release_memory(rs.base(), rs.size()), &quot;Shouldn&#39;t fail&quot;);
1073     }
1074   }
1075 
1076   static void test_reserved_space1(size_t size, size_t alignment) {
1077     assert(is_aligned(size, alignment), &quot;Incorrect input parameters&quot;);
1078 
1079     ReservedSpace rs(size,          // size
1080                      alignment,     // alignment
1081                      UseLargePages, // large
1082                      (char *)NULL); // requested_address
1083 
1084     assert(rs.base() != NULL, &quot;Must be&quot;);
1085     assert(rs.size() == size, &quot;Must be&quot;);
1086 
1087     assert(is_aligned(rs.base(), alignment), &quot;aligned sizes should always give aligned addresses&quot;);
1088     assert(is_aligned(rs.size(), alignment), &quot;aligned sizes should always give aligned addresses&quot;);
1089 
1090     if (rs.special()) {
1091       small_page_write(rs.base(), size);
1092     }
1093 
1094     release_memory_for_test(rs);
1095   }
1096 
1097   static void test_reserved_space2(size_t size) {
1098     assert(is_aligned(size, os::vm_allocation_granularity()), &quot;Must be at least AG aligned&quot;);
1099 
1100     ReservedSpace rs(size);
1101 
1102     assert(rs.base() != NULL, &quot;Must be&quot;);
1103     assert(rs.size() == size, &quot;Must be&quot;);
1104 
1105     if (rs.special()) {
1106       small_page_write(rs.base(), size);
1107     }
1108 
1109     release_memory_for_test(rs);
1110   }
1111 
1112   static void test_reserved_space3(size_t size, size_t alignment, bool maybe_large) {
1113     if (size &lt; alignment) {
1114       // Tests might set -XX:LargePageSizeInBytes=&lt;small pages&gt; and cause unexpected input arguments for this test.
1115       assert((size_t)os::vm_page_size() == os::large_page_size(), &quot;Test needs further refinement&quot;);
1116       return;
1117     }
1118 
1119     assert(is_aligned(size, os::vm_allocation_granularity()), &quot;Must be at least AG aligned&quot;);
1120     assert(is_aligned(size, alignment), &quot;Must be at least aligned against alignment&quot;);
1121 
1122     bool large = maybe_large &amp;&amp; UseLargePages &amp;&amp; size &gt;= os::large_page_size();
1123 
1124     ReservedSpace rs(size, alignment, large, false);
1125 
1126     assert(rs.base() != NULL, &quot;Must be&quot;);
1127     assert(rs.size() == size, &quot;Must be&quot;);
1128 
1129     if (rs.special()) {
1130       small_page_write(rs.base(), size);
1131     }
1132 
1133     release_memory_for_test(rs);
1134   }
1135 
1136 
1137   static void test_reserved_space1() {
1138     size_t size = 2 * 1024 * 1024;
1139     size_t ag   = os::vm_allocation_granularity();
1140 
1141     test_reserved_space1(size,      ag);
1142     test_reserved_space1(size * 2,  ag);
1143     test_reserved_space1(size * 10, ag);
1144   }
1145 
1146   static void test_reserved_space2() {
1147     size_t size = 2 * 1024 * 1024;
1148     size_t ag = os::vm_allocation_granularity();
1149 
1150     test_reserved_space2(size * 1);
1151     test_reserved_space2(size * 2);
1152     test_reserved_space2(size * 10);
1153     test_reserved_space2(ag);
1154     test_reserved_space2(size - ag);
1155     test_reserved_space2(size);
1156     test_reserved_space2(size + ag);
1157     test_reserved_space2(size * 2);
1158     test_reserved_space2(size * 2 - ag);
1159     test_reserved_space2(size * 2 + ag);
1160     test_reserved_space2(size * 3);
1161     test_reserved_space2(size * 3 - ag);
1162     test_reserved_space2(size * 3 + ag);
1163     test_reserved_space2(size * 10);
1164     test_reserved_space2(size * 10 + size / 2);
1165   }
1166 
1167   static void test_reserved_space3() {
1168     size_t ag = os::vm_allocation_granularity();
1169 
1170     test_reserved_space3(ag,      ag    , false);
1171     test_reserved_space3(ag * 2,  ag    , false);
1172     test_reserved_space3(ag * 3,  ag    , false);
1173     test_reserved_space3(ag * 2,  ag * 2, false);
1174     test_reserved_space3(ag * 4,  ag * 2, false);
1175     test_reserved_space3(ag * 8,  ag * 2, false);
1176     test_reserved_space3(ag * 4,  ag * 4, false);
1177     test_reserved_space3(ag * 8,  ag * 4, false);
1178     test_reserved_space3(ag * 16, ag * 4, false);
1179 
1180     if (UseLargePages) {
1181       size_t lp = os::large_page_size();
1182 
1183       // Without large pages
1184       test_reserved_space3(lp,     ag * 4, false);
1185       test_reserved_space3(lp * 2, ag * 4, false);
1186       test_reserved_space3(lp * 4, ag * 4, false);
1187       test_reserved_space3(lp,     lp    , false);
1188       test_reserved_space3(lp * 2, lp    , false);
1189       test_reserved_space3(lp * 3, lp    , false);
1190       test_reserved_space3(lp * 2, lp * 2, false);
1191       test_reserved_space3(lp * 4, lp * 2, false);
1192       test_reserved_space3(lp * 8, lp * 2, false);
1193 
1194       // With large pages
1195       test_reserved_space3(lp, ag * 4    , true);
1196       test_reserved_space3(lp * 2, ag * 4, true);
1197       test_reserved_space3(lp * 4, ag * 4, true);
1198       test_reserved_space3(lp, lp        , true);
1199       test_reserved_space3(lp * 2, lp    , true);
1200       test_reserved_space3(lp * 3, lp    , true);
1201       test_reserved_space3(lp * 2, lp * 2, true);
1202       test_reserved_space3(lp * 4, lp * 2, true);
1203       test_reserved_space3(lp * 8, lp * 2, true);
1204     }
1205   }
1206 
1207   static void test_reserved_space() {
1208     test_reserved_space1();
1209     test_reserved_space2();
1210     test_reserved_space3();
1211   }
1212 };
1213 
1214 void TestReservedSpace_test() {
1215   TestReservedSpace::test_reserved_space();
1216 }
1217 
1218 #define assert_equals(actual, expected)  \
1219   assert(actual == expected,             \
1220          &quot;Got &quot; SIZE_FORMAT &quot; expected &quot; \
1221          SIZE_FORMAT, actual, expected);
1222 
1223 #define assert_ge(value1, value2)                  \
1224   assert(value1 &gt;= value2,                         \
1225          &quot;&#39;&quot; #value1 &quot;&#39;: &quot; SIZE_FORMAT &quot; &#39;&quot;        \
1226          #value2 &quot;&#39;: &quot; SIZE_FORMAT, value1, value2);
1227 
1228 #define assert_lt(value1, value2)                  \
1229   assert(value1 &lt; value2,                          \
1230          &quot;&#39;&quot; #value1 &quot;&#39;: &quot; SIZE_FORMAT &quot; &#39;&quot;        \
1231          #value2 &quot;&#39;: &quot; SIZE_FORMAT, value1, value2);
1232 
1233 
1234 class TestVirtualSpace : AllStatic {
1235   enum TestLargePages {
1236     Default,
1237     Disable,
1238     Reserve,
1239     Commit
1240   };
1241 
1242   static ReservedSpace reserve_memory(size_t reserve_size_aligned, TestLargePages mode) {
1243     switch(mode) {
1244     default:
1245     case Default:
1246     case Reserve:
1247       return ReservedSpace(reserve_size_aligned);
1248     case Disable:
1249     case Commit:
1250       return ReservedSpace(reserve_size_aligned,
1251                            os::vm_allocation_granularity(),
1252                            /* large */ false, /* exec */ false);
1253     }
1254   }
1255 
1256   static bool initialize_virtual_space(VirtualSpace&amp; vs, ReservedSpace rs, TestLargePages mode) {
1257     switch(mode) {
1258     default:
1259     case Default:
1260     case Reserve:
1261       return vs.initialize(rs, 0);
1262     case Disable:
1263       return vs.initialize_with_granularity(rs, 0, os::vm_page_size());
1264     case Commit:
1265       return vs.initialize_with_granularity(rs, 0, os::page_size_for_region_unaligned(rs.size(), 1));
1266     }
1267   }
1268 
1269  public:
1270   static void test_virtual_space_actual_committed_space(size_t reserve_size, size_t commit_size,
1271                                                         TestLargePages mode = Default) {
1272     size_t granularity = os::vm_allocation_granularity();
1273     size_t reserve_size_aligned = align_up(reserve_size, granularity);
1274 
1275     ReservedSpace reserved = reserve_memory(reserve_size_aligned, mode);
1276 
1277     assert(reserved.is_reserved(), &quot;Must be&quot;);
1278 
1279     VirtualSpace vs;
1280     bool initialized = initialize_virtual_space(vs, reserved, mode);
1281     assert(initialized, &quot;Failed to initialize VirtualSpace&quot;);
1282 
1283     vs.expand_by(commit_size, false);
1284 
1285     if (vs.special()) {
1286       assert_equals(vs.actual_committed_size(), reserve_size_aligned);
1287     } else {
1288       assert_ge(vs.actual_committed_size(), commit_size);
1289       // Approximate the commit granularity.
1290       // Make sure that we don&#39;t commit using large pages
1291       // if large pages has been disabled for this VirtualSpace.
1292       size_t commit_granularity = (mode == Disable || !UseLargePages) ?
1293                                    os::vm_page_size() : os::large_page_size();
1294       assert_lt(vs.actual_committed_size(), commit_size + commit_granularity);
1295     }
1296 
1297     reserved.release();
1298   }
1299 
1300   static void test_virtual_space_actual_committed_space_one_large_page() {
1301     if (!UseLargePages) {
1302       return;
1303     }
1304 
1305     size_t large_page_size = os::large_page_size();
1306 
1307     ReservedSpace reserved(large_page_size, large_page_size, true, false);
1308 
1309     assert(reserved.is_reserved(), &quot;Must be&quot;);
1310 
1311     VirtualSpace vs;
1312     bool initialized = vs.initialize(reserved, 0);
1313     assert(initialized, &quot;Failed to initialize VirtualSpace&quot;);
1314 
1315     vs.expand_by(large_page_size, false);
1316 
1317     assert_equals(vs.actual_committed_size(), large_page_size);
1318 
1319     reserved.release();
1320   }
1321 
1322   static void test_virtual_space_actual_committed_space() {
1323     test_virtual_space_actual_committed_space(4 * K, 0);
1324     test_virtual_space_actual_committed_space(4 * K, 4 * K);
1325     test_virtual_space_actual_committed_space(8 * K, 0);
1326     test_virtual_space_actual_committed_space(8 * K, 4 * K);
1327     test_virtual_space_actual_committed_space(8 * K, 8 * K);
1328     test_virtual_space_actual_committed_space(12 * K, 0);
1329     test_virtual_space_actual_committed_space(12 * K, 4 * K);
1330     test_virtual_space_actual_committed_space(12 * K, 8 * K);
1331     test_virtual_space_actual_committed_space(12 * K, 12 * K);
1332     test_virtual_space_actual_committed_space(64 * K, 0);
1333     test_virtual_space_actual_committed_space(64 * K, 32 * K);
1334     test_virtual_space_actual_committed_space(64 * K, 64 * K);
1335     test_virtual_space_actual_committed_space(2 * M, 0);
1336     test_virtual_space_actual_committed_space(2 * M, 4 * K);
1337     test_virtual_space_actual_committed_space(2 * M, 64 * K);
1338     test_virtual_space_actual_committed_space(2 * M, 1 * M);
1339     test_virtual_space_actual_committed_space(2 * M, 2 * M);
1340     test_virtual_space_actual_committed_space(10 * M, 0);
1341     test_virtual_space_actual_committed_space(10 * M, 4 * K);
1342     test_virtual_space_actual_committed_space(10 * M, 8 * K);
1343     test_virtual_space_actual_committed_space(10 * M, 1 * M);
1344     test_virtual_space_actual_committed_space(10 * M, 2 * M);
1345     test_virtual_space_actual_committed_space(10 * M, 5 * M);
1346     test_virtual_space_actual_committed_space(10 * M, 10 * M);
1347   }
1348 
1349   static void test_virtual_space_disable_large_pages() {
1350     if (!UseLargePages) {
1351       return;
1352     }
1353     // These test cases verify that if we force VirtualSpace to disable large pages
1354     test_virtual_space_actual_committed_space(10 * M, 0, Disable);
1355     test_virtual_space_actual_committed_space(10 * M, 4 * K, Disable);
1356     test_virtual_space_actual_committed_space(10 * M, 8 * K, Disable);
1357     test_virtual_space_actual_committed_space(10 * M, 1 * M, Disable);
1358     test_virtual_space_actual_committed_space(10 * M, 2 * M, Disable);
1359     test_virtual_space_actual_committed_space(10 * M, 5 * M, Disable);
1360     test_virtual_space_actual_committed_space(10 * M, 10 * M, Disable);
1361 
1362     test_virtual_space_actual_committed_space(10 * M, 0, Reserve);
1363     test_virtual_space_actual_committed_space(10 * M, 4 * K, Reserve);
1364     test_virtual_space_actual_committed_space(10 * M, 8 * K, Reserve);
1365     test_virtual_space_actual_committed_space(10 * M, 1 * M, Reserve);
1366     test_virtual_space_actual_committed_space(10 * M, 2 * M, Reserve);
1367     test_virtual_space_actual_committed_space(10 * M, 5 * M, Reserve);
1368     test_virtual_space_actual_committed_space(10 * M, 10 * M, Reserve);
1369 
1370     test_virtual_space_actual_committed_space(10 * M, 0, Commit);
1371     test_virtual_space_actual_committed_space(10 * M, 4 * K, Commit);
1372     test_virtual_space_actual_committed_space(10 * M, 8 * K, Commit);
1373     test_virtual_space_actual_committed_space(10 * M, 1 * M, Commit);
1374     test_virtual_space_actual_committed_space(10 * M, 2 * M, Commit);
1375     test_virtual_space_actual_committed_space(10 * M, 5 * M, Commit);
1376     test_virtual_space_actual_committed_space(10 * M, 10 * M, Commit);
1377   }
1378 
1379   static void test_virtual_space() {
1380     test_virtual_space_actual_committed_space();
1381     test_virtual_space_actual_committed_space_one_large_page();
1382     test_virtual_space_disable_large_pages();
1383   }
1384 };
1385 
1386 void TestVirtualSpace_test() {
1387   TestVirtualSpace::test_virtual_space();
1388 }
1389 
1390 #endif // PRODUCT
1391 
1392 #endif
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/filemap.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="filemap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="freeList.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/filemap.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_MEMORY_FILEMAP_HPP
 26 #define SHARE_MEMORY_FILEMAP_HPP
 27 
 28 #include &quot;classfile/classLoader.hpp&quot;
 29 #include &quot;include/cds.h&quot;
 30 #include &quot;memory/metaspaceShared.hpp&quot;
 31 #include &quot;memory/metaspace.hpp&quot;
<span class="line-modified"> 32 #include &quot;memory/universe.hpp&quot;</span>
 33 #include &quot;utilities/align.hpp&quot;
 34 
 35 // Layout of the file:
 36 //  header: dump of archive instance plus versioning info, datestamp, etc.
 37 //   [magic # = 0xF00BABA2]
 38 //  ... padding to align on page-boundary
 39 //  read-write space
 40 //  read-only space
 41 //  misc data (block offset table, string table, symbols, dictionary, etc.)
 42 //  tag(666)
 43 
 44 static const int JVM_IDENT_MAX = 256;
 45 


 46 class SharedClassPathEntry {
 47   enum {
 48     modules_image_entry,
 49     jar_entry,
 50     signed_jar_entry,
 51     dir_entry,

 52     unknown_entry
 53   };
<span class="line-modified"> 54 protected:</span>


 55   u1     _type;

 56   time_t _timestamp;          // jar timestamp,  0 if is directory, modules image or other
 57   long   _filesize;           // jar/jimage file size, -1 if is directory, -2 if other
 58   Array&lt;char&gt;* _name;
 59   Array&lt;u1&gt;*   _manifest;
 60 
 61 public:
<span class="line-modified"> 62   void init(const char* name, bool is_modules_image, TRAPS);</span>

 63   void metaspace_pointers_do(MetaspaceClosure* it);
<span class="line-modified"> 64   bool validate(bool is_class_path = true);</span>
 65 
 66   // The _timestamp only gets set for jar files.
<span class="line-modified"> 67   bool has_timestamp() {</span>
 68     return _timestamp != 0;
 69   }
<span class="line-modified"> 70   bool is_dir()            { return _type == dir_entry; }</span>
<span class="line-modified"> 71   bool is_modules_image()  { return _type == modules_image_entry; }</span>
<span class="line-modified"> 72   bool is_jar()            { return _type == jar_entry; }</span>
<span class="line-modified"> 73   bool is_signed()         { return _type == signed_jar_entry; }</span>
<span class="line-modified"> 74   void set_is_signed()     {</span>
 75     _type = signed_jar_entry;
 76   }

 77   time_t timestamp() const { return _timestamp; }
 78   long   filesize()  const { return _filesize; }
<span class="line-modified"> 79   const char* name() const { return _name-&gt;data(); }</span>
 80   const char* manifest() const {
 81     return (_manifest == NULL) ? NULL : (const char*)_manifest-&gt;data();
 82   }
 83   int manifest_size() const {
 84     return (_manifest == NULL) ? 0 : _manifest-&gt;length();
 85   }
 86   void set_manifest(Array&lt;u1&gt;* manifest) {
 87     _manifest = manifest;
 88   }

 89 };
 90 
 91 struct ArchiveHeapOopmapInfo {
 92   address _oopmap;               // bitmap for relocating embedded oops
 93   size_t  _oopmap_size_in_bits;
 94 };
 95 
<span class="line-modified"> 96 struct FileMapHeader : public CDSFileMapHeaderBase {</span>












































































 97   size_t _alignment;                // how shared archive should be aligned
 98   int    _obj_alignment;            // value of ObjectAlignmentInBytes
 99   address _narrow_oop_base;         // compressed oop encoding base
100   int    _narrow_oop_shift;         // compressed oop encoding shift
<span class="line-modified">101   bool    _compact_strings;         // value of CompactStrings</span>
102   uintx  _max_heap_size;            // java max heap size during dumping
<span class="line-modified">103   Universe::NARROW_OOP_MODE _narrow_oop_mode; // compressed oop encoding mode</span>
104   int     _narrow_klass_shift;      // save narrow klass base and shift
<span class="line-modified">105   address _narrow_klass_base;</span>
<span class="line-modified">106   char*   _misc_data_patching_start;</span>
<span class="line-modified">107   char*   _read_only_tables_start;</span>
<span class="line-modified">108   address _cds_i2i_entry_code_buffers;</span>
<span class="line-modified">109   size_t  _cds_i2i_entry_code_buffers_size;</span>
<span class="line-modified">110   size_t  _core_spaces_size;        // number of bytes allocated by the core spaces</span>
<span class="line-modified">111                                     // (mc, md, ro, rw and od).</span>
<span class="line-modified">112   MemRegion _heap_reserved;         // reserved region for the entire heap at dump time.</span>
113 
114   // The following fields are all sanity checks for whether this archive
115   // will function correctly with this JVM and the bootclasspath it&#39;s
116   // invoked with.
<span class="line-modified">117   char  _jvm_ident[JVM_IDENT_MAX];      // identifier for jvm</span>
<span class="line-modified">118 </span>
<span class="line-modified">119   // The _paths_misc_info is a variable-size structure that records &quot;miscellaneous&quot;</span>
<span class="line-modified">120   // information during dumping. It is generated and validated by the</span>
<span class="line-modified">121   // SharedPathsMiscInfo class. See SharedPathsMiscInfo.hpp for</span>
<span class="line-modified">122   // detailed description.</span>
<span class="line-modified">123   //</span>
<span class="line-modified">124   // The _paths_misc_info data is stored as a byte array in the archive file header,</span>
<span class="line-modified">125   // immediately after the _header field. This information is used only when</span>
<span class="line-modified">126   // checking the validity of the archive and is deallocated after the archive is loaded.</span>
<span class="line-modified">127   //</span>
<span class="line-modified">128   // Note that the _paths_misc_info does NOT include information for JAR files</span>
<span class="line-modified">129   // that existed during dump time. Their information is stored in _shared_path_table.</span>
<span class="line-removed">130   int _paths_misc_info_size;</span>
<span class="line-removed">131 </span>
<span class="line-removed">132   // The following is a table of all the class path entries that were used</span>
<span class="line-removed">133   // during dumping. At run time, we require these files to exist and have the same</span>
<span class="line-removed">134   // size/modification time, or else the archive will refuse to load.</span>
<span class="line-removed">135   //</span>
<span class="line-removed">136   // All of these entries must be JAR files. The dumping process would fail if a non-empty</span>
<span class="line-removed">137   // directory was specified in the classpaths. If an empty directory was specified</span>
<span class="line-removed">138   // it is checked by the _paths_misc_info as described above.</span>
<span class="line-removed">139   //</span>
<span class="line-removed">140   // FIXME -- if JAR files in the tail of the list were specified but not used during dumping,</span>
<span class="line-removed">141   // they should be removed from this table, to save space and to avoid spurious</span>
<span class="line-removed">142   // loading failures during runtime.</span>
<span class="line-removed">143   int _shared_path_table_size;</span>
<span class="line-removed">144   size_t _shared_path_entry_size;</span>
<span class="line-removed">145   Array&lt;u8&gt;* _shared_path_table;</span>
146 
147   jshort _app_class_paths_start_index;  // Index of first app classpath entry
148   jshort _app_module_paths_start_index; // Index of first module path entry

149   jshort _max_used_path_index;          // max path index referenced during CDS dump
150   bool   _verify_local;                 // BytecodeVerificationLocal setting
151   bool   _verify_remote;                // BytecodeVerificationRemote setting
152   bool   _has_platform_or_app_classes;  // Archive contains app classes
<span class="line-modified">153   size_t _shared_base_address;          // SharedBaseAddress used at dump time</span>


154   bool   _allow_archiving_with_java_agent; // setting of the AllowArchivingWithJavaAgent option

155 
<span class="line-modified">156   void set_has_platform_or_app_classes(bool v) {</span>
<span class="line-modified">157     _has_platform_or_app_classes = v;</span>








































































158   }
<span class="line-removed">159   bool has_platform_or_app_classes() { return _has_platform_or_app_classes; }</span>
<span class="line-removed">160   jshort max_used_path_index()       { return _max_used_path_index; }</span>
<span class="line-removed">161   jshort app_module_paths_start_index() { return _app_module_paths_start_index; }</span>
162 
163   bool validate();
<span class="line-removed">164   void populate(FileMapInfo* info, size_t alignment);</span>
165   int compute_crc();
166 
<span class="line-modified">167   CDSFileMapRegion* space_at(int i) {</span>
<span class="line-modified">168     assert(i &gt;= 0 &amp;&amp; i &lt; NUM_CDS_REGIONS, &quot;invalid region&quot;);</span>
<span class="line-modified">169     return &amp;_space[i];</span>






170   }
171 };
172 
173 class FileMapInfo : public CHeapObj&lt;mtInternal&gt; {
174 private:
175   friend class ManifestStream;
176   friend class VMStructs;
<span class="line-modified">177   friend struct FileMapHeader;</span>
<span class="line-modified">178 </span>
<span class="line-modified">179   bool    _file_open;</span>
<span class="line-modified">180   int     _fd;</span>
<span class="line-modified">181   size_t  _file_offset;</span>
<span class="line-modified">182 </span>
<span class="line-modified">183 private:</span>
<span class="line-modified">184   static Array&lt;u8&gt;*            _shared_path_table;</span>
<span class="line-modified">185   static int                   _shared_path_table_size;</span>
<span class="line-modified">186   static size_t                _shared_path_entry_size;</span>




187   static bool                  _validating_shared_path_table;
188 
189   // FileMapHeader describes the shared space data in the file to be
190   // mapped.  This structure gets written to a file.  It is not a class, so
191   // that the compilers don&#39;t add any compiler-private data to it.
192 
<span class="line-removed">193 public:</span>
<span class="line-removed">194   struct FileMapHeaderBase : public CHeapObj&lt;mtClass&gt; {</span>
<span class="line-removed">195     // Need to put something here. Otherwise, in product build, because CHeapObj has no virtual</span>
<span class="line-removed">196     // methods, we would get sizeof(FileMapHeaderBase) == 1 with gcc.</span>
<span class="line-removed">197     intx _dummy;</span>
<span class="line-removed">198   };</span>
<span class="line-removed">199 </span>
<span class="line-removed">200 </span>
<span class="line-removed">201   FileMapHeader * _header;</span>
<span class="line-removed">202 </span>
<span class="line-removed">203   const char* _full_path;</span>
<span class="line-removed">204   char* _paths_misc_info;</span>
<span class="line-removed">205 </span>
206   static FileMapInfo* _current_info;

207   static bool _heap_pointers_need_patching;


208 
<span class="line-modified">209   bool  init_from_file(int fd);</span>
<span class="line-removed">210   void  align_file_position();</span>
<span class="line-removed">211   bool  validate_header_impl();</span>
<span class="line-removed">212   static void metaspace_pointers_do(MetaspaceClosure* it);</span>
213 
214 public:
<span class="line-modified">215   FileMapInfo();</span>












216   ~FileMapInfo();
217 
<span class="line-modified">218   int    compute_header_crc()         { return _header-&gt;compute_crc(); }</span>
<span class="line-modified">219   void   set_header_crc(int crc)      { _header-&gt;_crc = crc; }</span>


220   void   populate_header(size_t alignment);
221   bool   validate_header();
222   void   invalidate();
<span class="line-modified">223   int    version()                    { return _header-&gt;_version; }</span>
<span class="line-modified">224   size_t alignment()                  { return _header-&gt;_alignment; }</span>
<span class="line-modified">225   Universe::NARROW_OOP_MODE narrow_oop_mode() { return _header-&gt;_narrow_oop_mode; }</span>
<span class="line-modified">226   address narrow_oop_base()    const  { return _header-&gt;_narrow_oop_base; }</span>
<span class="line-modified">227   int     narrow_oop_shift()   const  { return _header-&gt;_narrow_oop_shift; }</span>
<span class="line-modified">228   uintx   max_heap_size()      const  { return _header-&gt;_max_heap_size; }</span>
<span class="line-modified">229   address narrow_klass_base()  const  { return _header-&gt;_narrow_klass_base; }</span>
<span class="line-modified">230   int     narrow_klass_shift() const  { return _header-&gt;_narrow_klass_shift; }</span>
<span class="line-modified">231   struct  FileMapHeader* header()     { return _header; }</span>
<span class="line-modified">232   char*   misc_data_patching_start()          { return _header-&gt;_misc_data_patching_start; }</span>
<span class="line-modified">233   void set_misc_data_patching_start(char* p)  { _header-&gt;_misc_data_patching_start = p; }</span>
<span class="line-modified">234   char* read_only_tables_start()              { return _header-&gt;_read_only_tables_start; }</span>
<span class="line-modified">235   void set_read_only_tables_start(char* p)    { _header-&gt;_read_only_tables_start = p; }</span>
<span class="line-modified">236 </span>
<span class="line-modified">237   address cds_i2i_entry_code_buffers() {</span>
<span class="line-modified">238     return _header-&gt;_cds_i2i_entry_code_buffers;</span>
<span class="line-modified">239   }</span>
<span class="line-modified">240   void set_cds_i2i_entry_code_buffers(address addr) {</span>
<span class="line-modified">241     _header-&gt;_cds_i2i_entry_code_buffers = addr;</span>
<span class="line-modified">242   }</span>
<span class="line-modified">243   size_t cds_i2i_entry_code_buffers_size() {</span>
<span class="line-modified">244     return _header-&gt;_cds_i2i_entry_code_buffers_size;</span>
<span class="line-modified">245   }</span>
<span class="line-modified">246   void set_cds_i2i_entry_code_buffers_size(size_t s) {</span>
<span class="line-modified">247     _header-&gt;_cds_i2i_entry_code_buffers_size = s;</span>
<span class="line-modified">248   }</span>
<span class="line-modified">249   void set_core_spaces_size(size_t s)    {  _header-&gt;_core_spaces_size = s; }</span>
<span class="line-modified">250   size_t core_spaces_size()              { return _header-&gt;_core_spaces_size; }</span>



















251 
252   static FileMapInfo* current_info() {
253     CDS_ONLY(return _current_info;)
254     NOT_CDS(return NULL;)
255   }
256 









257   static void assert_mark(bool check);
258 
259   // File manipulation.
260   bool  initialize() NOT_CDS_RETURN_(false);
261   bool  open_for_read();
<span class="line-modified">262   void  open_for_write();</span>
263   void  write_header();
264   void  write_region(int region, char* base, size_t size,
265                      bool read_only, bool allow_exec);

266   size_t write_archive_heap_regions(GrowableArray&lt;MemRegion&gt; *heap_mem,
267                                     GrowableArray&lt;ArchiveHeapOopmapInfo&gt; *oopmaps,
<span class="line-modified">268                                     int first_region_id, int max_num_regions,</span>
<span class="line-removed">269                                     bool print_log);</span>
270   void  write_bytes(const void* buffer, size_t count);
271   void  write_bytes_aligned(const void* buffer, size_t count);
<span class="line-modified">272   char* map_region(int i, char** top_ret);</span>
<span class="line-modified">273   void  map_heap_regions_impl() NOT_CDS_JAVA_HEAP_RETURN;</span>

274   void  map_heap_regions() NOT_CDS_JAVA_HEAP_RETURN;
275   void  fixup_mapped_heap_regions() NOT_CDS_JAVA_HEAP_RETURN;
276   void  patch_archived_heap_embedded_pointers() NOT_CDS_JAVA_HEAP_RETURN;
277   void  patch_archived_heap_embedded_pointers(MemRegion* ranges, int num_ranges,
278                                               int first_region_idx) NOT_CDS_JAVA_HEAP_RETURN;
279   bool  has_heap_regions()  NOT_CDS_JAVA_HEAP_RETURN_(false);
280   MemRegion get_heap_regions_range_with_current_oop_encoding_mode() NOT_CDS_JAVA_HEAP_RETURN_(MemRegion());
281   void  unmap_region(int i);
282   bool  verify_region_checksum(int i);
283   void  close();
284   bool  is_open() { return _file_open; }
285   ReservedSpace reserve_shared_memory();
286 
287   // JVM/TI RedefineClasses() support:
288   // Remap the shared readonly space to shared readwrite, private.
289   bool  remap_shared_readonly_as_readwrite();
290 
291   // Errors.
292   static void fail_stop(const char *msg, ...) ATTRIBUTE_PRINTF(1, 2);
293   static void fail_continue(const char *msg, ...) ATTRIBUTE_PRINTF(1, 2);
<span class="line-modified">294 </span>



295   bool is_in_shared_region(const void* p, int idx) NOT_CDS_RETURN_(false);
296 
297   // Stop CDS sharing and unmap CDS regions.
298   static void stop_sharing_and_unmap(const char* msg);
299 
300   static void allocate_shared_path_table();

301   static void check_nonempty_dir_in_shared_path_table();
302   bool validate_shared_path_table();
<span class="line-modified">303   static void update_shared_classpath(ClassPathEntry *cpe, SharedClassPathEntry* ent, TRAPS);</span>






304 
305 #if INCLUDE_JVMTI
<span class="line-modified">306   static ClassFileStream* open_stream_for_jvmti(InstanceKlass* ik, TRAPS);</span>
307 #endif
308 
309   static SharedClassPathEntry* shared_path(int index) {
<span class="line-modified">310     if (index &lt; 0) {</span>
<span class="line-removed">311       return NULL;</span>
<span class="line-removed">312     }</span>
<span class="line-removed">313     assert(index &lt; _shared_path_table_size, &quot;sanity&quot;);</span>
<span class="line-removed">314     char* p = (char*)_shared_path_table-&gt;data();</span>
<span class="line-removed">315     p += _shared_path_entry_size * index;</span>
<span class="line-removed">316     return (SharedClassPathEntry*)p;</span>
317   }
318 
319   static const char* shared_path_name(int index) {
320     assert(index &gt;= 0, &quot;Sanity&quot;);
321     return shared_path(index)-&gt;name();
322   }
323 
324   static int get_number_of_shared_paths() {
<span class="line-modified">325     return _shared_path_table_size;</span>
326   }
327 
328   char* region_addr(int idx);
329 
















330  private:









331   bool  map_heap_data(MemRegion **heap_mem, int first, int max, int* num,
332                       bool is_open = false) NOT_CDS_JAVA_HEAP_RETURN_(false);
<span class="line-modified">333   bool  verify_mapped_heap_regions(int first, int num) NOT_CDS_JAVA_HEAP_RETURN_(false);</span>
<span class="line-modified">334   void  dealloc_archive_heap_regions(MemRegion* regions, int num, bool is_open) NOT_CDS_JAVA_HEAP_RETURN;</span>
<span class="line-modified">335 </span>
<span class="line-modified">336   CDSFileMapRegion* space_at(int i) {</span>
<span class="line-modified">337     return _header-&gt;space_at(i);</span>
<span class="line-modified">338   }</span>

339 
<span class="line-modified">340   narrowOop offset_of_space(CDSFileMapRegion* spc) {</span>
<span class="line-modified">341     return (narrowOop)(spc-&gt;_addr._offset);</span>
342   }
343 
344   // The starting address of spc, as calculated with CompressedOop::decode_non_null()
<span class="line-modified">345   address start_address_as_decoded_with_current_oop_encoding_mode(CDSFileMapRegion* spc) {</span>
346     return decode_start_address(spc, true);
347   }
348 
349   // The starting address of spc, as calculated with HeapShared::decode_from_archive()
<span class="line-modified">350   address start_address_as_decoded_from_archive(CDSFileMapRegion* spc) {</span>
351     return decode_start_address(spc, false);
352   }
353 
<span class="line-modified">354   address decode_start_address(CDSFileMapRegion* spc, bool with_current_oop_encoding_mode);</span>
355 
356 #if INCLUDE_JVMTI
357   static ClassPathEntry** _classpath_entries_for_jvmti;
358   static ClassPathEntry* get_classpath_entry_for_jvmti(int i, TRAPS);
359 #endif
360 };
361 
362 #endif // SHARE_MEMORY_FILEMAP_HPP
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_MEMORY_FILEMAP_HPP
 26 #define SHARE_MEMORY_FILEMAP_HPP
 27 
 28 #include &quot;classfile/classLoader.hpp&quot;
 29 #include &quot;include/cds.h&quot;
 30 #include &quot;memory/metaspaceShared.hpp&quot;
 31 #include &quot;memory/metaspace.hpp&quot;
<span class="line-modified"> 32 #include &quot;oops/compressedOops.hpp&quot;</span>
 33 #include &quot;utilities/align.hpp&quot;
 34 
 35 // Layout of the file:
 36 //  header: dump of archive instance plus versioning info, datestamp, etc.
 37 //   [magic # = 0xF00BABA2]
 38 //  ... padding to align on page-boundary
 39 //  read-write space
 40 //  read-only space
 41 //  misc data (block offset table, string table, symbols, dictionary, etc.)
 42 //  tag(666)
 43 
 44 static const int JVM_IDENT_MAX = 256;
 45 
<span class="line-added"> 46 class CHeapBitMap;</span>
<span class="line-added"> 47 </span>
 48 class SharedClassPathEntry {
 49   enum {
 50     modules_image_entry,
 51     jar_entry,
 52     signed_jar_entry,
 53     dir_entry,
<span class="line-added"> 54     non_existent_entry,</span>
 55     unknown_entry
 56   };
<span class="line-modified"> 57 </span>
<span class="line-added"> 58   void set_name(const char* name, TRAPS);</span>
<span class="line-added"> 59 </span>
 60   u1     _type;
<span class="line-added"> 61   bool   _from_class_path_attr;</span>
 62   time_t _timestamp;          // jar timestamp,  0 if is directory, modules image or other
 63   long   _filesize;           // jar/jimage file size, -1 if is directory, -2 if other
 64   Array&lt;char&gt;* _name;
 65   Array&lt;u1&gt;*   _manifest;
 66 
 67 public:
<span class="line-modified"> 68   void init(bool is_modules_image, ClassPathEntry* cpe, TRAPS);</span>
<span class="line-added"> 69   void init_as_non_existent(const char* path, TRAPS);</span>
 70   void metaspace_pointers_do(MetaspaceClosure* it);
<span class="line-modified"> 71   bool validate(bool is_class_path = true) const;</span>
 72 
 73   // The _timestamp only gets set for jar files.
<span class="line-modified"> 74   bool has_timestamp() const {</span>
 75     return _timestamp != 0;
 76   }
<span class="line-modified"> 77   bool is_dir()           const { return _type == dir_entry; }</span>
<span class="line-modified"> 78   bool is_modules_image() const { return _type == modules_image_entry; }</span>
<span class="line-modified"> 79   bool is_jar()           const { return _type == jar_entry; }</span>
<span class="line-modified"> 80   bool is_signed()        const { return _type == signed_jar_entry; }</span>
<span class="line-modified"> 81   void set_is_signed() {</span>
 82     _type = signed_jar_entry;
 83   }
<span class="line-added"> 84   bool from_class_path_attr() { return _from_class_path_attr; }</span>
 85   time_t timestamp() const { return _timestamp; }
 86   long   filesize()  const { return _filesize; }
<span class="line-modified"> 87   const char* name() const;</span>
 88   const char* manifest() const {
 89     return (_manifest == NULL) ? NULL : (const char*)_manifest-&gt;data();
 90   }
 91   int manifest_size() const {
 92     return (_manifest == NULL) ? 0 : _manifest-&gt;length();
 93   }
 94   void set_manifest(Array&lt;u1&gt;* manifest) {
 95     _manifest = manifest;
 96   }
<span class="line-added"> 97   bool check_non_existent() const;</span>
 98 };
 99 
100 struct ArchiveHeapOopmapInfo {
101   address _oopmap;               // bitmap for relocating embedded oops
102   size_t  _oopmap_size_in_bits;
103 };
104 
<span class="line-modified">105 class SharedPathTable {</span>
<span class="line-added">106   Array&lt;u8&gt;* _table;</span>
<span class="line-added">107   int _size;</span>
<span class="line-added">108 public:</span>
<span class="line-added">109   SharedPathTable() : _table(NULL), _size(0) {}</span>
<span class="line-added">110   SharedPathTable(Array&lt;u8&gt;* table, int size) : _table(table), _size(size) {}</span>
<span class="line-added">111 </span>
<span class="line-added">112   void dumptime_init(ClassLoaderData* loader_data, Thread* THREAD);</span>
<span class="line-added">113   void metaspace_pointers_do(MetaspaceClosure* it);</span>
<span class="line-added">114 </span>
<span class="line-added">115   int size() {</span>
<span class="line-added">116     return _size;</span>
<span class="line-added">117   }</span>
<span class="line-added">118   SharedClassPathEntry* path_at(int index) {</span>
<span class="line-added">119     if (index &lt; 0) {</span>
<span class="line-added">120       return NULL;</span>
<span class="line-added">121     }</span>
<span class="line-added">122     assert(index &lt; _size, &quot;sanity&quot;);</span>
<span class="line-added">123     char* p = (char*)_table-&gt;data();</span>
<span class="line-added">124     p += sizeof(SharedClassPathEntry) * index;</span>
<span class="line-added">125     return (SharedClassPathEntry*)p;</span>
<span class="line-added">126   }</span>
<span class="line-added">127   Array&lt;u8&gt;* table() {return _table;}</span>
<span class="line-added">128   void set_table(Array&lt;u8&gt;* table) {_table = table;}</span>
<span class="line-added">129 };</span>
<span class="line-added">130 </span>
<span class="line-added">131 </span>
<span class="line-added">132 class FileMapRegion: private CDSFileMapRegion {</span>
<span class="line-added">133   void assert_is_heap_region() const {</span>
<span class="line-added">134     assert(_is_heap_region, &quot;must be heap region&quot;);</span>
<span class="line-added">135   }</span>
<span class="line-added">136   void assert_is_not_heap_region() const {</span>
<span class="line-added">137     assert(!_is_heap_region, &quot;must not be heap region&quot;);</span>
<span class="line-added">138   }</span>
<span class="line-added">139 </span>
<span class="line-added">140 public:</span>
<span class="line-added">141   static FileMapRegion* cast(CDSFileMapRegion* p) {</span>
<span class="line-added">142     return (FileMapRegion*)p;</span>
<span class="line-added">143   }</span>
<span class="line-added">144 </span>
<span class="line-added">145   // Accessors</span>
<span class="line-added">146   int crc()                         const { return _crc; }</span>
<span class="line-added">147   size_t file_offset()              const { return _file_offset; }</span>
<span class="line-added">148   size_t mapping_offset()           const { return _mapping_offset; }</span>
<span class="line-added">149   size_t mapping_end_offset()       const { return _mapping_offset + used_aligned(); }</span>
<span class="line-added">150   size_t used()                     const { return _used; }</span>
<span class="line-added">151   size_t used_aligned()             const; // aligned up to os::vm_allocation_granularity()</span>
<span class="line-added">152   char*  mapped_base()              const { assert_is_not_heap_region(); return _mapped_base; }</span>
<span class="line-added">153   char*  mapped_end()               const { return mapped_base()        + used_aligned(); }</span>
<span class="line-added">154   bool   read_only()                const { return _read_only != 0; }</span>
<span class="line-added">155   bool   allow_exec()               const { return _allow_exec != 0; }</span>
<span class="line-added">156   bool   mapped_from_file()         const { return _mapped_from_file != 0; }</span>
<span class="line-added">157   size_t oopmap_offset()            const { assert_is_heap_region();     return _oopmap_offset; }</span>
<span class="line-added">158   size_t oopmap_size_in_bits()      const { assert_is_heap_region();     return _oopmap_size_in_bits; }</span>
<span class="line-added">159 </span>
<span class="line-added">160   void set_file_offset(size_t s)     { _file_offset = s; }</span>
<span class="line-added">161   void set_read_only(bool v)         { _read_only = v; }</span>
<span class="line-added">162   void set_mapped_base(char* p)      { _mapped_base = p; }</span>
<span class="line-added">163   void set_mapped_from_file(bool v)  { _mapped_from_file = v; }</span>
<span class="line-added">164   void init(int region_index, char* base, size_t size, bool read_only,</span>
<span class="line-added">165             bool allow_exec, int crc);</span>
<span class="line-added">166 </span>
<span class="line-added">167   void init_oopmap(size_t oopmap_offset, size_t size_in_bits) {</span>
<span class="line-added">168     _oopmap_offset = oopmap_offset;</span>
<span class="line-added">169     _oopmap_size_in_bits = size_in_bits;</span>
<span class="line-added">170   }</span>
<span class="line-added">171 };</span>
<span class="line-added">172 </span>
<span class="line-added">173 class FileMapHeader: private CDSFileMapHeaderBase {</span>
<span class="line-added">174   friend class CDSOffsets;</span>
<span class="line-added">175   friend class VMStructs;</span>
<span class="line-added">176 </span>
<span class="line-added">177   size_t _header_size;</span>
<span class="line-added">178 </span>
<span class="line-added">179   // The following fields record the states of the VM during dump time.</span>
<span class="line-added">180   // They are compared with the runtime states to see if the archive</span>
<span class="line-added">181   // can be used.</span>
182   size_t _alignment;                // how shared archive should be aligned
183   int    _obj_alignment;            // value of ObjectAlignmentInBytes
184   address _narrow_oop_base;         // compressed oop encoding base
185   int    _narrow_oop_shift;         // compressed oop encoding shift
<span class="line-modified">186   bool   _compact_strings;          // value of CompactStrings</span>
187   uintx  _max_heap_size;            // java max heap size during dumping
<span class="line-modified">188   CompressedOops::Mode _narrow_oop_mode; // compressed oop encoding mode</span>
189   int     _narrow_klass_shift;      // save narrow klass base and shift
<span class="line-modified">190   bool    _compressed_oops;         // save the flag UseCompressedOops</span>
<span class="line-modified">191   bool    _compressed_class_ptrs;   // save the flag UseCompressedClassPointers</span>
<span class="line-modified">192   size_t  _cloned_vtables_offset;   // The address of the first cloned vtable</span>
<span class="line-modified">193   size_t  _serialized_data_offset;  // Data accessed using {ReadClosure,WriteClosure}::serialize()</span>
<span class="line-modified">194   size_t  _i2i_entry_code_buffers_offset;</span>
<span class="line-modified">195   size_t  _i2i_entry_code_buffers_size;</span>
<span class="line-modified">196   address _heap_end;                // heap end at dump time.</span>
<span class="line-modified">197   bool _base_archive_is_default;    // indicates if the base archive is the system default one</span>
198 
199   // The following fields are all sanity checks for whether this archive
200   // will function correctly with this JVM and the bootclasspath it&#39;s
201   // invoked with.
<span class="line-modified">202   char  _jvm_ident[JVM_IDENT_MAX];  // identifier string of the jvm that created this dump</span>
<span class="line-modified">203 </span>
<span class="line-modified">204   // size of the base archive name including NULL terminator</span>
<span class="line-modified">205   size_t _base_archive_name_size;</span>
<span class="line-modified">206 </span>
<span class="line-modified">207   // The following is a table of all the boot/app/module path entries that were used</span>
<span class="line-modified">208   // during dumping. At run time, we validate these entries according to their</span>
<span class="line-modified">209   // SharedClassPathEntry::_type. See:</span>
<span class="line-modified">210   //      check_nonempty_dir_in_shared_path_table()</span>
<span class="line-modified">211   //      validate_shared_path_table()</span>
<span class="line-modified">212   //      validate_non_existent_class_paths()</span>
<span class="line-modified">213   size_t _shared_path_table_offset;</span>
<span class="line-modified">214   int    _shared_path_table_size;</span>
















215 
216   jshort _app_class_paths_start_index;  // Index of first app classpath entry
217   jshort _app_module_paths_start_index; // Index of first module path entry
<span class="line-added">218   jshort _num_module_paths;             // number of module path entries</span>
219   jshort _max_used_path_index;          // max path index referenced during CDS dump
220   bool   _verify_local;                 // BytecodeVerificationLocal setting
221   bool   _verify_remote;                // BytecodeVerificationRemote setting
222   bool   _has_platform_or_app_classes;  // Archive contains app classes
<span class="line-modified">223   char*  _requested_base_address;       // Archive relocation is not necessary if we map with this base address.</span>
<span class="line-added">224   char*  _mapped_base_address;          // Actual base address where archive is mapped.</span>
<span class="line-added">225 </span>
226   bool   _allow_archiving_with_java_agent; // setting of the AllowArchivingWithJavaAgent option
<span class="line-added">227   size_t _ptrmap_size_in_bits;          // Size of pointer relocation bitmap</span>
228 
<span class="line-modified">229   char* from_mapped_offset(size_t offset) const {</span>
<span class="line-modified">230     return mapped_base_address() + offset;</span>
<span class="line-added">231   }</span>
<span class="line-added">232   void set_mapped_offset(char* p, size_t *offset) {</span>
<span class="line-added">233     assert(p &gt;= mapped_base_address(), &quot;sanity&quot;);</span>
<span class="line-added">234     *offset = p - mapped_base_address();</span>
<span class="line-added">235   }</span>
<span class="line-added">236 public:</span>
<span class="line-added">237   // Accessors -- fields declared in CDSFileMapHeaderBase</span>
<span class="line-added">238   unsigned int magic() const {return _magic;}</span>
<span class="line-added">239   int crc()                               const { return _crc; }</span>
<span class="line-added">240   int version()                           const { return _version; }</span>
<span class="line-added">241 </span>
<span class="line-added">242   void set_crc(int crc_value)                   { _crc = crc_value; }</span>
<span class="line-added">243   void set_version(int v)                       { _version = v; }</span>
<span class="line-added">244 </span>
<span class="line-added">245   // Accessors -- fields declared in FileMapHeader</span>
<span class="line-added">246 </span>
<span class="line-added">247   size_t header_size()                     const { return _header_size; }</span>
<span class="line-added">248   size_t alignment()                       const { return _alignment; }</span>
<span class="line-added">249   int obj_alignment()                      const { return _obj_alignment; }</span>
<span class="line-added">250   address narrow_oop_base()                const { return _narrow_oop_base; }</span>
<span class="line-added">251   int narrow_oop_shift()                   const { return _narrow_oop_shift; }</span>
<span class="line-added">252   bool compact_strings()                   const { return _compact_strings; }</span>
<span class="line-added">253   uintx max_heap_size()                    const { return _max_heap_size; }</span>
<span class="line-added">254   CompressedOops::Mode narrow_oop_mode()   const { return _narrow_oop_mode; }</span>
<span class="line-added">255   int narrow_klass_shift()                 const { return _narrow_klass_shift; }</span>
<span class="line-added">256   address narrow_klass_base()              const { return (address)mapped_base_address(); }</span>
<span class="line-added">257   char* cloned_vtables()                   const { return from_mapped_offset(_cloned_vtables_offset); }</span>
<span class="line-added">258   char* serialized_data()                  const { return from_mapped_offset(_serialized_data_offset); }</span>
<span class="line-added">259   address i2i_entry_code_buffers()         const { return (address)from_mapped_offset(_i2i_entry_code_buffers_offset); }</span>
<span class="line-added">260   size_t i2i_entry_code_buffers_size()     const { return _i2i_entry_code_buffers_size; }</span>
<span class="line-added">261   address heap_end()                       const { return _heap_end; }</span>
<span class="line-added">262   bool base_archive_is_default()           const { return _base_archive_is_default; }</span>
<span class="line-added">263   const char* jvm_ident()                  const { return _jvm_ident; }</span>
<span class="line-added">264   size_t base_archive_name_size()          const { return _base_archive_name_size; }</span>
<span class="line-added">265   char* requested_base_address()           const { return _requested_base_address; }</span>
<span class="line-added">266   char* mapped_base_address()              const { return _mapped_base_address; }</span>
<span class="line-added">267   bool has_platform_or_app_classes()       const { return _has_platform_or_app_classes; }</span>
<span class="line-added">268   size_t ptrmap_size_in_bits()             const { return _ptrmap_size_in_bits; }</span>
<span class="line-added">269   bool compressed_oops()                   const { return _compressed_oops; }</span>
<span class="line-added">270   bool compressed_class_pointers()         const { return _compressed_class_ptrs; }</span>
<span class="line-added">271   // FIXME: These should really return int</span>
<span class="line-added">272   jshort max_used_path_index()             const { return _max_used_path_index; }</span>
<span class="line-added">273   jshort app_module_paths_start_index()    const { return _app_module_paths_start_index; }</span>
<span class="line-added">274   jshort app_class_paths_start_index()     const { return _app_class_paths_start_index; }</span>
<span class="line-added">275   jshort num_module_paths()                const { return _num_module_paths; }</span>
<span class="line-added">276 </span>
<span class="line-added">277   void set_has_platform_or_app_classes(bool v)   { _has_platform_or_app_classes = v; }</span>
<span class="line-added">278   void set_cloned_vtables(char* p)               { set_mapped_offset(p, &amp;_cloned_vtables_offset); }</span>
<span class="line-added">279   void set_serialized_data(char* p)              { set_mapped_offset(p, &amp;_serialized_data_offset); }</span>
<span class="line-added">280   void set_base_archive_name_size(size_t s)      { _base_archive_name_size = s; }</span>
<span class="line-added">281   void set_base_archive_is_default(bool b)       { _base_archive_is_default = b; }</span>
<span class="line-added">282   void set_header_size(size_t s)                 { _header_size = s; }</span>
<span class="line-added">283   void set_ptrmap_size_in_bits(size_t s)         { _ptrmap_size_in_bits = s; }</span>
<span class="line-added">284   void set_mapped_base_address(char* p)          { _mapped_base_address = p; }</span>
<span class="line-added">285   void set_i2i_entry_code_buffers(address p, size_t s) {</span>
<span class="line-added">286     set_mapped_offset((char*)p, &amp;_i2i_entry_code_buffers_offset);</span>
<span class="line-added">287     _i2i_entry_code_buffers_size = s;</span>
<span class="line-added">288   }</span>
<span class="line-added">289 </span>
<span class="line-added">290   void set_shared_path_table(SharedPathTable table) {</span>
<span class="line-added">291     set_mapped_offset((char*)table.table(), &amp;_shared_path_table_offset);</span>
<span class="line-added">292     _shared_path_table_size = table.size();</span>
<span class="line-added">293   }</span>
<span class="line-added">294 </span>
<span class="line-added">295   void set_final_requested_base(char* b) {</span>
<span class="line-added">296     _requested_base_address = b;</span>
<span class="line-added">297     _mapped_base_address = 0;</span>
<span class="line-added">298   }</span>
<span class="line-added">299 </span>
<span class="line-added">300   SharedPathTable shared_path_table() const {</span>
<span class="line-added">301     return SharedPathTable((Array&lt;u8&gt;*)from_mapped_offset(_shared_path_table_offset),</span>
<span class="line-added">302                            _shared_path_table_size);</span>
303   }



304 
305   bool validate();

306   int compute_crc();
307 
<span class="line-modified">308   FileMapRegion* space_at(int i) {</span>
<span class="line-modified">309     assert(is_valid_region(i), &quot;invalid region&quot;);</span>
<span class="line-modified">310     return FileMapRegion::cast(&amp;_space[i]);</span>
<span class="line-added">311   }</span>
<span class="line-added">312 </span>
<span class="line-added">313   void populate(FileMapInfo* info, size_t alignment);</span>
<span class="line-added">314 </span>
<span class="line-added">315   static bool is_valid_region(int region) {</span>
<span class="line-added">316     return (0 &lt;= region &amp;&amp; region &lt; NUM_CDS_REGIONS);</span>
317   }
318 };
319 
320 class FileMapInfo : public CHeapObj&lt;mtInternal&gt; {
321 private:
322   friend class ManifestStream;
323   friend class VMStructs;
<span class="line-modified">324   friend class CDSOffsets;</span>
<span class="line-modified">325   friend class FileMapHeader;</span>
<span class="line-modified">326 </span>
<span class="line-modified">327   bool           _is_static;</span>
<span class="line-modified">328   bool           _file_open;</span>
<span class="line-modified">329   bool           _is_mapped;</span>
<span class="line-modified">330   int            _fd;</span>
<span class="line-modified">331   size_t         _file_offset;</span>
<span class="line-modified">332   const char*    _full_path;</span>
<span class="line-modified">333   const char*    _base_archive_name;</span>
<span class="line-added">334   FileMapHeader* _header;</span>
<span class="line-added">335 </span>
<span class="line-added">336   // TODO: Probably change the following to be non-static</span>
<span class="line-added">337   static SharedPathTable       _shared_path_table;</span>
338   static bool                  _validating_shared_path_table;
339 
340   // FileMapHeader describes the shared space data in the file to be
341   // mapped.  This structure gets written to a file.  It is not a class, so
342   // that the compilers don&#39;t add any compiler-private data to it.
343 













344   static FileMapInfo* _current_info;
<span class="line-added">345   static FileMapInfo* _dynamic_archive_info;</span>
346   static bool _heap_pointers_need_patching;
<span class="line-added">347   static bool _memory_mapping_failed;</span>
<span class="line-added">348   static GrowableArray&lt;const char*&gt;* _non_existent_class_paths;</span>
349 
<span class="line-modified">350   FileMapHeader *header() const       { return _header; }</span>



351 
352 public:
<span class="line-modified">353   static bool get_base_archive_name_from_header(const char* archive_name,</span>
<span class="line-added">354                                                 int* size, char** base_archive_name);</span>
<span class="line-added">355   static bool check_archive(const char* archive_name, bool is_static);</span>
<span class="line-added">356   static SharedPathTable shared_path_table() {</span>
<span class="line-added">357     return _shared_path_table;</span>
<span class="line-added">358   }</span>
<span class="line-added">359   void restore_shared_path_table();</span>
<span class="line-added">360   bool init_from_file(int fd);</span>
<span class="line-added">361   static void metaspace_pointers_do(MetaspaceClosure* it);</span>
<span class="line-added">362 </span>
<span class="line-added">363   void log_paths(const char* msg, int start_idx, int end_idx);</span>
<span class="line-added">364 </span>
<span class="line-added">365   FileMapInfo(bool is_static);</span>
366   ~FileMapInfo();
367 
<span class="line-modified">368   // Accessors</span>
<span class="line-modified">369   int    compute_header_crc()  const { return header()-&gt;compute_crc(); }</span>
<span class="line-added">370   void   set_header_crc(int crc)     { header()-&gt;set_crc(crc); }</span>
<span class="line-added">371   int    space_crc(int i)      const { return space_at(i)-&gt;crc(); }</span>
372   void   populate_header(size_t alignment);
373   bool   validate_header();
374   void   invalidate();
<span class="line-modified">375   int    crc()                 const { return header()-&gt;crc(); }</span>
<span class="line-modified">376   int    version()             const { return header()-&gt;version(); }</span>
<span class="line-modified">377   size_t alignment()           const { return header()-&gt;alignment(); }</span>
<span class="line-modified">378   address narrow_oop_base()    const { return header()-&gt;narrow_oop_base(); }</span>
<span class="line-modified">379   int     narrow_oop_shift()   const { return header()-&gt;narrow_oop_shift(); }</span>
<span class="line-modified">380   uintx   max_heap_size()      const { return header()-&gt;max_heap_size(); }</span>
<span class="line-modified">381   address narrow_klass_base()  const { return header()-&gt;narrow_klass_base(); }</span>
<span class="line-modified">382   int     narrow_klass_shift() const { return header()-&gt;narrow_klass_shift(); }</span>
<span class="line-modified">383 </span>
<span class="line-modified">384   CompressedOops::Mode narrow_oop_mode()      const { return header()-&gt;narrow_oop_mode(); }</span>
<span class="line-modified">385   jshort app_module_paths_start_index()       const { return header()-&gt;app_module_paths_start_index(); }</span>
<span class="line-modified">386   jshort app_class_paths_start_index()        const { return header()-&gt;app_class_paths_start_index(); }</span>
<span class="line-modified">387 </span>
<span class="line-modified">388   char* cloned_vtables()                      const { return header()-&gt;cloned_vtables(); }</span>
<span class="line-modified">389   void  set_cloned_vtables(char* p)           const { header()-&gt;set_cloned_vtables(p); }</span>
<span class="line-modified">390   char* serialized_data()                     const { return header()-&gt;serialized_data(); }</span>
<span class="line-modified">391   void  set_serialized_data(char* p)          const { header()-&gt;set_serialized_data(p); }</span>
<span class="line-modified">392 </span>
<span class="line-modified">393   bool  is_file_position_aligned() const;</span>
<span class="line-modified">394   void  align_file_position();</span>
<span class="line-modified">395 </span>
<span class="line-modified">396   address i2i_entry_code_buffers()            const { return header()-&gt;i2i_entry_code_buffers();  }</span>
<span class="line-modified">397   size_t i2i_entry_code_buffers_size()        const { return header()-&gt;i2i_entry_code_buffers_size(); }</span>
<span class="line-modified">398   void set_i2i_entry_code_buffers(address addr, size_t s) const {</span>
<span class="line-modified">399     header()-&gt;set_i2i_entry_code_buffers(addr, s);</span>
<span class="line-modified">400   }</span>
<span class="line-modified">401 </span>
<span class="line-modified">402   bool is_static()                            const { return _is_static; }</span>
<span class="line-added">403   bool is_mapped()                            const { return _is_mapped; }</span>
<span class="line-added">404   void set_is_mapped(bool v)                        { _is_mapped = v; }</span>
<span class="line-added">405   const char* full_path()                     const { return _full_path; }</span>
<span class="line-added">406   void set_final_requested_base(char* b);</span>
<span class="line-added">407 </span>
<span class="line-added">408   char* requested_base_address()           const { return header()-&gt;requested_base_address(); }</span>
<span class="line-added">409 </span>
<span class="line-added">410 </span>
<span class="line-added">411   class DynamicArchiveHeader* dynamic_header() const {</span>
<span class="line-added">412     assert(!is_static(), &quot;must be&quot;);</span>
<span class="line-added">413     return (DynamicArchiveHeader*)header();</span>
<span class="line-added">414   }</span>
<span class="line-added">415 </span>
<span class="line-added">416   void set_has_platform_or_app_classes(bool v) {</span>
<span class="line-added">417     header()-&gt;set_has_platform_or_app_classes(v);</span>
<span class="line-added">418   }</span>
<span class="line-added">419   bool has_platform_or_app_classes() const {</span>
<span class="line-added">420     return header()-&gt;has_platform_or_app_classes();</span>
<span class="line-added">421   }</span>
422 
423   static FileMapInfo* current_info() {
424     CDS_ONLY(return _current_info;)
425     NOT_CDS(return NULL;)
426   }
427 
<span class="line-added">428   static void set_current_info(FileMapInfo* info) {</span>
<span class="line-added">429     CDS_ONLY(_current_info = info;)</span>
<span class="line-added">430   }</span>
<span class="line-added">431 </span>
<span class="line-added">432   static FileMapInfo* dynamic_info() {</span>
<span class="line-added">433     CDS_ONLY(return _dynamic_archive_info;)</span>
<span class="line-added">434     NOT_CDS(return NULL;)</span>
<span class="line-added">435   }</span>
<span class="line-added">436 </span>
437   static void assert_mark(bool check);
438 
439   // File manipulation.
440   bool  initialize() NOT_CDS_RETURN_(false);
441   bool  open_for_read();
<span class="line-modified">442   void  open_for_write(const char* path = NULL);</span>
443   void  write_header();
444   void  write_region(int region, char* base, size_t size,
445                      bool read_only, bool allow_exec);
<span class="line-added">446   void  write_bitmap_region(const CHeapBitMap* ptrmap);</span>
447   size_t write_archive_heap_regions(GrowableArray&lt;MemRegion&gt; *heap_mem,
448                                     GrowableArray&lt;ArchiveHeapOopmapInfo&gt; *oopmaps,
<span class="line-modified">449                                     int first_region_id, int max_num_regions);</span>

450   void  write_bytes(const void* buffer, size_t count);
451   void  write_bytes_aligned(const void* buffer, size_t count);
<span class="line-modified">452   size_t  read_bytes(void* buffer, size_t count);</span>
<span class="line-modified">453   MapArchiveResult map_regions(int regions[], int num_regions, char* mapped_base_address, ReservedSpace rs);</span>
<span class="line-added">454   void  unmap_regions(int regions[], int num_regions);</span>
455   void  map_heap_regions() NOT_CDS_JAVA_HEAP_RETURN;
456   void  fixup_mapped_heap_regions() NOT_CDS_JAVA_HEAP_RETURN;
457   void  patch_archived_heap_embedded_pointers() NOT_CDS_JAVA_HEAP_RETURN;
458   void  patch_archived_heap_embedded_pointers(MemRegion* ranges, int num_ranges,
459                                               int first_region_idx) NOT_CDS_JAVA_HEAP_RETURN;
460   bool  has_heap_regions()  NOT_CDS_JAVA_HEAP_RETURN_(false);
461   MemRegion get_heap_regions_range_with_current_oop_encoding_mode() NOT_CDS_JAVA_HEAP_RETURN_(MemRegion());
462   void  unmap_region(int i);
463   bool  verify_region_checksum(int i);
464   void  close();
465   bool  is_open() { return _file_open; }
466   ReservedSpace reserve_shared_memory();
467 
468   // JVM/TI RedefineClasses() support:
469   // Remap the shared readonly space to shared readwrite, private.
470   bool  remap_shared_readonly_as_readwrite();
471 
472   // Errors.
473   static void fail_stop(const char *msg, ...) ATTRIBUTE_PRINTF(1, 2);
474   static void fail_continue(const char *msg, ...) ATTRIBUTE_PRINTF(1, 2);
<span class="line-modified">475   static bool memory_mapping_failed() {</span>
<span class="line-added">476     CDS_ONLY(return _memory_mapping_failed;)</span>
<span class="line-added">477     NOT_CDS(return false;)</span>
<span class="line-added">478   }</span>
479   bool is_in_shared_region(const void* p, int idx) NOT_CDS_RETURN_(false);
480 
481   // Stop CDS sharing and unmap CDS regions.
482   static void stop_sharing_and_unmap(const char* msg);
483 
484   static void allocate_shared_path_table();
<span class="line-added">485   static int add_shared_classpaths(int i, const char* which, ClassPathEntry *cpe, TRAPS);</span>
486   static void check_nonempty_dir_in_shared_path_table();
487   bool validate_shared_path_table();
<span class="line-modified">488   void validate_non_existent_class_paths();</span>
<span class="line-added">489   static void set_shared_path_table(FileMapInfo* info) {</span>
<span class="line-added">490     _shared_path_table = info-&gt;header()-&gt;shared_path_table();</span>
<span class="line-added">491   }</span>
<span class="line-added">492   static void update_jar_manifest(ClassPathEntry *cpe, SharedClassPathEntry* ent, TRAPS);</span>
<span class="line-added">493   static int num_non_existent_class_paths();</span>
<span class="line-added">494   static void record_non_existent_class_path_entry(const char* path);</span>
495 
496 #if INCLUDE_JVMTI
<span class="line-modified">497   static ClassFileStream* open_stream_for_jvmti(InstanceKlass* ik, Handle class_loader, TRAPS);</span>
498 #endif
499 
500   static SharedClassPathEntry* shared_path(int index) {
<span class="line-modified">501     return _shared_path_table.path_at(index);</span>






502   }
503 
504   static const char* shared_path_name(int index) {
505     assert(index &gt;= 0, &quot;Sanity&quot;);
506     return shared_path(index)-&gt;name();
507   }
508 
509   static int get_number_of_shared_paths() {
<span class="line-modified">510     return _shared_path_table.size();</span>
511   }
512 
513   char* region_addr(int idx);
514 
<span class="line-added">515   // The offset of the first core region in the archive, relative to SharedBaseAddress</span>
<span class="line-added">516   size_t mapping_base_offset() const { return first_core_space()-&gt;mapping_offset(); }</span>
<span class="line-added">517   // The offset of the (exclusive) end of the last core region in this archive, relative to SharedBaseAddress</span>
<span class="line-added">518   size_t mapping_end_offset()  const { return last_core_space()-&gt;mapping_end_offset(); }</span>
<span class="line-added">519 </span>
<span class="line-added">520   char* mapped_base()    const { return first_core_space()-&gt;mapped_base(); }</span>
<span class="line-added">521   char* mapped_end()     const { return last_core_space()-&gt;mapped_end();   }</span>
<span class="line-added">522 </span>
<span class="line-added">523   // Non-zero if the archive needs to be mapped a non-default location due to ASLR.</span>
<span class="line-added">524   intx relocation_delta() const {</span>
<span class="line-added">525     return header()-&gt;mapped_base_address() - header()-&gt;requested_base_address();</span>
<span class="line-added">526   }</span>
<span class="line-added">527 </span>
<span class="line-added">528   FileMapRegion* first_core_space() const;</span>
<span class="line-added">529   FileMapRegion* last_core_space() const;</span>
<span class="line-added">530 </span>
531  private:
<span class="line-added">532   void  seek_to_position(size_t pos);</span>
<span class="line-added">533   char* skip_first_path_entry(const char* path) NOT_CDS_RETURN_(NULL);</span>
<span class="line-added">534   int   num_paths(const char* path) NOT_CDS_RETURN_(0);</span>
<span class="line-added">535   GrowableArray&lt;const char*&gt;* create_path_array(const char* path) NOT_CDS_RETURN_(NULL);</span>
<span class="line-added">536   bool  classpath_failure(const char* msg, const char* name) NOT_CDS_RETURN_(false);</span>
<span class="line-added">537   bool  check_paths(int shared_path_start_idx, int num_paths,</span>
<span class="line-added">538                     GrowableArray&lt;const char*&gt;* rp_array) NOT_CDS_RETURN_(false);</span>
<span class="line-added">539   bool  validate_boot_class_paths() NOT_CDS_RETURN_(false);</span>
<span class="line-added">540   bool  validate_app_class_paths(int shared_app_paths_len) NOT_CDS_RETURN_(false);</span>
541   bool  map_heap_data(MemRegion **heap_mem, int first, int max, int* num,
542                       bool is_open = false) NOT_CDS_JAVA_HEAP_RETURN_(false);
<span class="line-modified">543   bool  region_crc_check(char* buf, size_t size, int expected_crc) NOT_CDS_RETURN_(false);</span>
<span class="line-modified">544   void  dealloc_archive_heap_regions(MemRegion* regions, int num) NOT_CDS_JAVA_HEAP_RETURN;</span>
<span class="line-modified">545   void  map_heap_regions_impl() NOT_CDS_JAVA_HEAP_RETURN;</span>
<span class="line-modified">546   char* map_relocation_bitmap(size_t&amp; bitmap_size);</span>
<span class="line-modified">547   MapArchiveResult map_region(int i, intx addr_delta, char* mapped_base_address, ReservedSpace rs);</span>
<span class="line-modified">548   bool  read_region(int i, char* base, size_t size);</span>
<span class="line-added">549   bool  relocate_pointers(intx addr_delta);</span>
550 
<span class="line-modified">551   FileMapRegion* space_at(int i) const {</span>
<span class="line-modified">552     return header()-&gt;space_at(i);</span>
553   }
554 
555   // The starting address of spc, as calculated with CompressedOop::decode_non_null()
<span class="line-modified">556   address start_address_as_decoded_with_current_oop_encoding_mode(FileMapRegion* spc) {</span>
557     return decode_start_address(spc, true);
558   }
559 
560   // The starting address of spc, as calculated with HeapShared::decode_from_archive()
<span class="line-modified">561   address start_address_as_decoded_from_archive(FileMapRegion* spc) {</span>
562     return decode_start_address(spc, false);
563   }
564 
<span class="line-modified">565   address decode_start_address(FileMapRegion* spc, bool with_current_oop_encoding_mode);</span>
566 
567 #if INCLUDE_JVMTI
568   static ClassPathEntry** _classpath_entries_for_jvmti;
569   static ClassPathEntry* get_classpath_entry_for_jvmti(int i, TRAPS);
570 #endif
571 };
572 
573 #endif // SHARE_MEMORY_FILEMAP_HPP
</pre>
</td>
</tr>
</table>
<center><a href="filemap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="freeList.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
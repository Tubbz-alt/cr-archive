<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/memory/heap.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="freeList.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="heap.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/heap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2015, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 26,10 ***</span>
<span class="line-new-header">--- 26,11 ---</span>
  #include &quot;memory/heap.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
  #include &quot;services/memTracker.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
<span class="line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  size_t CodeHeap::header_size() {
    return sizeof(HeapBlock);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 43,45 ***</span>
    _number_of_reserved_segments  = 0;
    _segment_size                 = 0;
    _log2_segment_size            = 0;
    _next_segment                 = 0;
    _freelist                     = NULL;
    _freelist_segments            = 0;
    _freelist_length              = 0;
    _max_allocated_capacity       = 0;
    _blob_count                   = 0;
    _nmethod_count                = 0;
    _adapter_count                = 0;
    _full_count                   = 0;
  }
  
  
  void CodeHeap::mark_segmap_as_free(size_t beg, size_t end) {
<span class="line-modified">!   assert(              beg &lt;  _number_of_committed_segments, &quot;interval begin out of bounds&quot;);</span>
<span class="line-modified">!   assert(beg &lt;  end &amp;&amp; end &lt;= _number_of_committed_segments, &quot;interval end   out of bounds&quot;);</span>
<span class="line-modified">!   // setup _segmap pointers for faster indexing</span>
<span class="line-modified">!   address p = (address)_segmap.low() + beg;</span>
<span class="line-modified">!   address q = (address)_segmap.low() + end;</span>
<span class="line-modified">!   // initialize interval</span>
<span class="line-modified">!   while (p &lt; q) *p++ = free_sentinel;</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! </span>
<span class="line-modified">! void CodeHeap::mark_segmap_as_used(size_t beg, size_t end) {</span>
<span class="line-modified">!   assert(              beg &lt;  _number_of_committed_segments, &quot;interval begin out of bounds&quot;);</span>
<span class="line-modified">!   assert(beg &lt;  end &amp;&amp; end &lt;= _number_of_committed_segments, &quot;interval end   out of bounds&quot;);</span>
<span class="line-modified">!   // setup _segmap pointers for faster indexing</span>
<span class="line-modified">!   address p = (address)_segmap.low() + beg;</span>
<span class="line-modified">!   address q = (address)_segmap.low() + end;</span>
<span class="line-modified">!   // initialize interval</span>
<span class="line-modified">!   int i = 0;</span>
<span class="line-modified">!   while (p &lt; q) {</span>
<span class="line-modified">!     *p++ = i++;</span>
<span class="line-modified">!     if (i == free_sentinel) i = 1;</span>
    }
  }
  
  
  static size_t align_to_page_size(size_t size) {
    const size_t alignment = (size_t)os::vm_page_size();
    assert(is_power_of_2(alignment), &quot;no kidding ???&quot;);
    return (size + alignment - 1) &amp; ~(alignment - 1);
<span class="line-new-header">--- 44,149 ---</span>
    _number_of_reserved_segments  = 0;
    _segment_size                 = 0;
    _log2_segment_size            = 0;
    _next_segment                 = 0;
    _freelist                     = NULL;
<span class="line-added">+   _last_insert_point            = NULL;</span>
    _freelist_segments            = 0;
    _freelist_length              = 0;
    _max_allocated_capacity       = 0;
    _blob_count                   = 0;
    _nmethod_count                = 0;
    _adapter_count                = 0;
    _full_count                   = 0;
<span class="line-added">+   _fragmentation_count          = 0;</span>
  }
  
<span class="line-added">+ // Dummy initialization of template array.</span>
<span class="line-added">+ char CodeHeap::segmap_template[] = {0};</span>
  
<span class="line-added">+ // This template array is used to (re)initialize the segmap,</span>
<span class="line-added">+ // replacing a 1..254 loop.</span>
<span class="line-added">+ void CodeHeap::init_segmap_template() {</span>
<span class="line-added">+   assert(free_sentinel == 255, &quot;Segment map logic changed!&quot;);</span>
<span class="line-added">+   for (int i = 0; i &lt;= free_sentinel; i++) {</span>
<span class="line-added">+     segmap_template[i] = i;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // The segmap is marked free for that part of the heap</span>
<span class="line-added">+ // which has not been allocated yet (beyond _next_segment).</span>
<span class="line-added">+ // The range of segments to be marked is given by [beg..end).</span>
<span class="line-added">+ // &quot;Allocated&quot; space in this context means there exists a</span>
<span class="line-added">+ // HeapBlock or a FreeBlock describing this space.</span>
<span class="line-added">+ // This method takes segment map indices as range boundaries</span>
  void CodeHeap::mark_segmap_as_free(size_t beg, size_t end) {
<span class="line-modified">!   assert(             beg &lt;  _number_of_committed_segments, &quot;interval begin out of bounds&quot;);</span>
<span class="line-modified">!   assert(beg &lt; end &amp;&amp; end &lt;= _number_of_committed_segments, &quot;interval end   out of bounds&quot;);</span>
<span class="line-modified">!   // Don&#39;t do unpredictable things in PRODUCT build</span>
<span class="line-modified">!   if (beg &lt; end) {</span>
<span class="line-modified">!     // setup _segmap pointers for faster indexing</span>
<span class="line-modified">!     address p = (address)_segmap.low() + beg;</span>
<span class="line-modified">!     address q = (address)_segmap.low() + end;</span>
<span class="line-modified">!     // initialize interval</span>
<span class="line-modified">!     memset(p, free_sentinel, q-p);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! // Don&#39;t get confused here.</span>
<span class="line-modified">! // All existing blocks, no matter if they are used() or free(),</span>
<span class="line-modified">! // have their segmap marked as used. This allows to find the</span>
<span class="line-modified">! // block header (HeapBlock or FreeBlock) for any pointer</span>
<span class="line-modified">! // within the allocated range (upper limit: _next_segment).</span>
<span class="line-modified">! // This method takes segment map indices as range boundaries.</span>
<span class="line-modified">! // The range of segments to be marked is given by [beg..end).</span>
<span class="line-modified">! void CodeHeap::mark_segmap_as_used(size_t beg, size_t end, bool is_FreeBlock_join) {</span>
<span class="line-modified">!   assert(             beg &lt;  _number_of_committed_segments, &quot;interval begin out of bounds&quot;);</span>
<span class="line-added">+   assert(beg &lt; end &amp;&amp; end &lt;= _number_of_committed_segments, &quot;interval end   out of bounds&quot;);</span>
<span class="line-added">+   // Don&#39;t do unpredictable things in PRODUCT build</span>
<span class="line-added">+   if (beg &lt; end) {</span>
<span class="line-added">+     // setup _segmap pointers for faster indexing</span>
<span class="line-added">+     address p = (address)_segmap.low() + beg;</span>
<span class="line-added">+     address q = (address)_segmap.low() + end;</span>
<span class="line-added">+     // initialize interval</span>
<span class="line-added">+     // If we are joining two free blocks, the segmap range for each</span>
<span class="line-added">+     // block is consistent. To create a consistent segmap range for</span>
<span class="line-added">+     // the blocks combined, we have three choices:</span>
<span class="line-added">+     //  1 - Do a full init from beg to end. Not very efficient because</span>
<span class="line-added">+     //      the segmap range for the left block is potentially initialized</span>
<span class="line-added">+     //      over and over again.</span>
<span class="line-added">+     //  2 - Carry over the last segmap element value of the left block</span>
<span class="line-added">+     //      and initialize the segmap range of the right block starting</span>
<span class="line-added">+     //      with that value. Saves initializing the left block&#39;s segmap</span>
<span class="line-added">+     //      over and over again. Very efficient if FreeBlocks mostly</span>
<span class="line-added">+     //      are appended to the right.</span>
<span class="line-added">+     //  3 - Take full advantage of the segmap being almost correct with</span>
<span class="line-added">+     //      the two blocks combined. Lets assume the left block consists</span>
<span class="line-added">+     //      of m segments. The the segmap looks like</span>
<span class="line-added">+     //        ... (m-2) (m-1) (m) 0  1  2  3 ...</span>
<span class="line-added">+     //      By substituting the &#39;0&#39; by &#39;1&#39;, we create a valid, but</span>
<span class="line-added">+     //      suboptimal, segmap range covering the two blocks combined.</span>
<span class="line-added">+     //      We introduced an extra hop for the find_block_for() iteration.</span>
<span class="line-added">+     //</span>
<span class="line-added">+     // When this method is called with is_FreeBlock_join == true, the</span>
<span class="line-added">+     // segmap index beg must select the first segment of the right block.</span>
<span class="line-added">+     // Otherwise, it has to select the first segment of the left block.</span>
<span class="line-added">+     // Variant 3 is used for all FreeBlock joins.</span>
<span class="line-added">+     if (is_FreeBlock_join &amp;&amp; (beg &gt; 0)) {</span>
<span class="line-added">+ #ifndef PRODUCT</span>
<span class="line-added">+       FreeBlock* pBlock = (FreeBlock*)block_at(beg);</span>
<span class="line-added">+       assert(beg + pBlock-&gt;length() == end, &quot;Internal error: (%d - %d) != %d&quot;, (unsigned int)end, (unsigned int)beg, (unsigned int)(pBlock-&gt;length()));</span>
<span class="line-added">+       assert(*p == 0, &quot;Begin index does not select a block start segment, *p = %2.2x&quot;, *p);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+       // If possible, extend the previous hop.</span>
<span class="line-added">+       if (*(p-1) &lt; (free_sentinel-1)) {</span>
<span class="line-added">+         *p = *(p-1) + 1;</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         *p = 1;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       if (_fragmentation_count++ &gt;= fragmentation_limit) {</span>
<span class="line-added">+         defrag_segmap(true);</span>
<span class="line-added">+         _fragmentation_count = 0;</span>
<span class="line-added">+       }</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       size_t n_bulk = free_sentinel-1; // bulk processing uses template indices [1..254].</span>
<span class="line-added">+       // Use shortcut for blocks &lt;= 255 segments.</span>
<span class="line-added">+       // Special case bulk processing: [0..254].</span>
<span class="line-added">+       if ((end - beg) &lt;= n_bulk) {</span>
<span class="line-added">+         memcpy(p, &amp;segmap_template[0], end - beg);</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         *p++  = 0;  // block header marker</span>
<span class="line-added">+         while (p &lt; q) {</span>
<span class="line-added">+           if ((p+n_bulk) &lt;= q) {</span>
<span class="line-added">+             memcpy(p, &amp;segmap_template[1], n_bulk);</span>
<span class="line-added">+             p += n_bulk;</span>
<span class="line-added">+           } else {</span>
<span class="line-added">+             memcpy(p, &amp;segmap_template[1], q-p);</span>
<span class="line-added">+             p = q;</span>
<span class="line-added">+           }</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
    }
  }
  
<span class="line-added">+ void CodeHeap::invalidate(size_t beg, size_t end, size_t hdr_size) {</span>
<span class="line-added">+ #ifndef PRODUCT</span>
<span class="line-added">+   // Fill the given range with some bad value.</span>
<span class="line-added">+   // length is expected to be in segment_size units.</span>
<span class="line-added">+   // This prevents inadvertent execution of code leftover from previous use.</span>
<span class="line-added">+   char* p = low_boundary() + segments_to_size(beg) + hdr_size;</span>
<span class="line-added">+   memset(p, badCodeHeapNewVal, segments_to_size(end-beg)-hdr_size);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void CodeHeap::clear(size_t beg, size_t end) {</span>
<span class="line-added">+   mark_segmap_as_free(beg, end);</span>
<span class="line-added">+   invalidate(beg, end, 0);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void CodeHeap::clear() {</span>
<span class="line-added">+   _next_segment = 0;</span>
<span class="line-added">+   clear(_next_segment, _number_of_committed_segments);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  
  static size_t align_to_page_size(size_t size) {
    const size_t alignment = (size_t)os::vm_page_size();
    assert(is_power_of_2(alignment), &quot;no kidding ???&quot;);
    return (size + alignment - 1) &amp; ~(alignment - 1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 138,12 ***</span>
  
    assert(_segmap.committed_size() &gt;= (size_t) _number_of_committed_segments, &quot;could not commit  enough space for segment map&quot;);
    assert(_segmap.reserved_size()  &gt;= (size_t) _number_of_reserved_segments , &quot;could not reserve enough space for segment map&quot;);
    assert(_segmap.reserved_size()  &gt;= _segmap.committed_size()     , &quot;just checking&quot;);
  
<span class="line-modified">!   // initialize remaining instance variables</span>
    clear();
    return true;
  }
  
  
  bool CodeHeap::expand_by(size_t size) {
<span class="line-new-header">--- 243,13 ---</span>
  
    assert(_segmap.committed_size() &gt;= (size_t) _number_of_committed_segments, &quot;could not commit  enough space for segment map&quot;);
    assert(_segmap.reserved_size()  &gt;= (size_t) _number_of_reserved_segments , &quot;could not reserve enough space for segment map&quot;);
    assert(_segmap.reserved_size()  &gt;= _segmap.committed_size()     , &quot;just checking&quot;);
  
<span class="line-modified">!   // initialize remaining instance variables, heap memory and segmap</span>
    clear();
<span class="line-added">+   init_segmap_template();</span>
    return true;
  }
  
  
  bool CodeHeap::expand_by(size_t size) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 165,21 ***</span>
      size_t ds = align_to_page_size(_number_of_committed_segments) - _segmap.committed_size();
      if ((ds &gt; 0) &amp;&amp; !_segmap.expand_by(ds)) {
        return false;
      }
      assert(_segmap.committed_size() &gt;= (size_t) _number_of_committed_segments, &quot;just checking&quot;);
<span class="line-modified">!     // initialize additional segmap entries</span>
<span class="line-modified">!     mark_segmap_as_free(i, _number_of_committed_segments);</span>
    }
    return true;
  }
  
<span class="line-removed">- void CodeHeap::clear() {</span>
<span class="line-removed">-   _next_segment = 0;</span>
<span class="line-removed">-   mark_segmap_as_free(0, _number_of_committed_segments);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  
  void* CodeHeap::allocate(size_t instance_size) {
    size_t number_of_segments = size_to_segments(instance_size + header_size());
    assert(segments_to_size(number_of_segments) &gt;= sizeof(FreeBlock), &quot;not enough room for FreeList&quot;);
  
<span class="line-new-header">--- 271,16 ---</span>
      size_t ds = align_to_page_size(_number_of_committed_segments) - _segmap.committed_size();
      if ((ds &gt; 0) &amp;&amp; !_segmap.expand_by(ds)) {
        return false;
      }
      assert(_segmap.committed_size() &gt;= (size_t) _number_of_committed_segments, &quot;just checking&quot;);
<span class="line-modified">!     // initialize additional space (heap memory and segmap)</span>
<span class="line-modified">!     clear(i, _number_of_committed_segments);</span>
    }
    return true;
  }
  
  
  void* CodeHeap::allocate(size_t instance_size) {
    size_t number_of_segments = size_to_segments(instance_size + header_size());
    assert(segments_to_size(number_of_segments) &gt;= sizeof(FreeBlock), &quot;not enough room for FreeList&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 187,56 ***</span>
    NOT_PRODUCT(verify());
    HeapBlock* block = search_freelist(number_of_segments);
    NOT_PRODUCT(verify());
  
    if (block != NULL) {
<span class="line-modified">!     assert(block-&gt;length() &gt;= number_of_segments &amp;&amp; block-&gt;length() &lt; number_of_segments + CodeCacheMinBlockLength, &quot;sanity check&quot;);</span>
<span class="line-removed">-     assert(!block-&gt;free(), &quot;must be marked free&quot;);</span>
      guarantee((char*) block &gt;= _memory.low_boundary() &amp;&amp; (char*) block &lt; _memory.high(),
                &quot;The newly allocated block &quot; INTPTR_FORMAT &quot; is not within the heap &quot;
                &quot;starting with &quot;  INTPTR_FORMAT &quot; and ending with &quot;  INTPTR_FORMAT,
                p2i(block), p2i(_memory.low_boundary()), p2i(_memory.high()));
<span class="line-removed">-     DEBUG_ONLY(memset((void*)block-&gt;allocated_space(), badCodeHeapNewVal, instance_size));</span>
      _max_allocated_capacity = MAX2(_max_allocated_capacity, allocated_capacity());
      _blob_count++;
      return block-&gt;allocated_space();
    }
  
    // Ensure minimum size for allocation to the heap.
    number_of_segments = MAX2((int)CodeCacheMinBlockLength, (int)number_of_segments);
  
    if (_next_segment + number_of_segments &lt;= _number_of_committed_segments) {
<span class="line-modified">!     mark_segmap_as_used(_next_segment, _next_segment + number_of_segments);</span>
<span class="line-modified">!     HeapBlock* b =  block_at(_next_segment);</span>
<span class="line-modified">!     b-&gt;initialize(number_of_segments);</span>
      _next_segment += number_of_segments;
<span class="line-modified">!     guarantee((char*) b &gt;= _memory.low_boundary() &amp;&amp; (char*) block &lt; _memory.high(),</span>
                &quot;The newly allocated block &quot; INTPTR_FORMAT &quot; is not within the heap &quot;
                &quot;starting with &quot;  INTPTR_FORMAT &quot; and ending with &quot; INTPTR_FORMAT,
<span class="line-modified">!               p2i(b), p2i(_memory.low_boundary()), p2i(_memory.high()));</span>
<span class="line-removed">-     DEBUG_ONLY(memset((void *)b-&gt;allocated_space(), badCodeHeapNewVal, instance_size));</span>
      _max_allocated_capacity = MAX2(_max_allocated_capacity, allocated_capacity());
      _blob_count++;
<span class="line-modified">!     return b-&gt;allocated_space();</span>
    } else {
      return NULL;
    }
  }
  
  void CodeHeap::deallocate_tail(void* p, size_t used_size) {
    assert(p == find_start(p), &quot;illegal deallocation&quot;);
    // Find start of HeapBlock
    HeapBlock* b = (((HeapBlock *)p) - 1);
    assert(b-&gt;allocated_space() == p, &quot;sanity check&quot;);
<span class="line-modified">!   size_t used_number_of_segments = size_to_segments(used_size + header_size());</span>
    size_t actual_number_of_segments = b-&gt;length();
    guarantee(used_number_of_segments &lt;= actual_number_of_segments, &quot;Must be!&quot;);
<span class="line-modified">!   guarantee(b == block_at(_next_segment - actual_number_of_segments), &quot;Intermediate allocation!&quot;);</span>
<span class="line-modified">!   size_t number_of_segments_to_deallocate = actual_number_of_segments - used_number_of_segments;</span>
<span class="line-modified">!   _next_segment -= number_of_segments_to_deallocate;</span>
<span class="line-modified">!   mark_segmap_as_free(_next_segment, _next_segment + number_of_segments_to_deallocate);</span>
<span class="line-removed">-   b-&gt;initialize(used_number_of_segments);</span>
  }
  
  void CodeHeap::deallocate(void* p) {
    assert(p == find_start(p), &quot;illegal deallocation&quot;);
    // Find start of HeapBlock
<span class="line-new-header">--- 288,79 ---</span>
    NOT_PRODUCT(verify());
    HeapBlock* block = search_freelist(number_of_segments);
    NOT_PRODUCT(verify());
  
    if (block != NULL) {
<span class="line-modified">!     assert(!block-&gt;free(), &quot;must not be marked free&quot;);</span>
      guarantee((char*) block &gt;= _memory.low_boundary() &amp;&amp; (char*) block &lt; _memory.high(),
                &quot;The newly allocated block &quot; INTPTR_FORMAT &quot; is not within the heap &quot;
                &quot;starting with &quot;  INTPTR_FORMAT &quot; and ending with &quot;  INTPTR_FORMAT,
                p2i(block), p2i(_memory.low_boundary()), p2i(_memory.high()));
      _max_allocated_capacity = MAX2(_max_allocated_capacity, allocated_capacity());
      _blob_count++;
      return block-&gt;allocated_space();
    }
  
    // Ensure minimum size for allocation to the heap.
    number_of_segments = MAX2((int)CodeCacheMinBlockLength, (int)number_of_segments);
  
    if (_next_segment + number_of_segments &lt;= _number_of_committed_segments) {
<span class="line-modified">!     mark_segmap_as_used(_next_segment, _next_segment + number_of_segments, false);</span>
<span class="line-modified">!     block = block_at(_next_segment);</span>
<span class="line-modified">!     block-&gt;initialize(number_of_segments);</span>
      _next_segment += number_of_segments;
<span class="line-modified">!     guarantee((char*) block &gt;= _memory.low_boundary() &amp;&amp; (char*) block &lt; _memory.high(),</span>
                &quot;The newly allocated block &quot; INTPTR_FORMAT &quot; is not within the heap &quot;
                &quot;starting with &quot;  INTPTR_FORMAT &quot; and ending with &quot; INTPTR_FORMAT,
<span class="line-modified">!               p2i(block), p2i(_memory.low_boundary()), p2i(_memory.high()));</span>
      _max_allocated_capacity = MAX2(_max_allocated_capacity, allocated_capacity());
      _blob_count++;
<span class="line-modified">!     return block-&gt;allocated_space();</span>
    } else {
      return NULL;
    }
  }
  
<span class="line-added">+ // Split the given block into two at the given segment.</span>
<span class="line-added">+ // This is helpful when a block was allocated too large</span>
<span class="line-added">+ // to trim off the unused space at the end (interpreter).</span>
<span class="line-added">+ // It also helps with splitting a large free block during allocation.</span>
<span class="line-added">+ // Usage state (used or free) must be set by caller since</span>
<span class="line-added">+ // we don&#39;t know if the resulting blocks will be used or free.</span>
<span class="line-added">+ // split_at is the segment number (relative to segment_for(b))</span>
<span class="line-added">+ //          where the split happens. The segment with relative</span>
<span class="line-added">+ //          number split_at is the first segment of the split-off block.</span>
<span class="line-added">+ HeapBlock* CodeHeap::split_block(HeapBlock *b, size_t split_at) {</span>
<span class="line-added">+   if (b == NULL) return NULL;</span>
<span class="line-added">+   // After the split, both blocks must have a size of at least CodeCacheMinBlockLength</span>
<span class="line-added">+   assert((split_at &gt;= CodeCacheMinBlockLength) &amp;&amp; (split_at + CodeCacheMinBlockLength &lt;= b-&gt;length()),</span>
<span class="line-added">+          &quot;split position(%d) out of range [0..%d]&quot;, (int)split_at, (int)b-&gt;length());</span>
<span class="line-added">+   size_t split_segment = segment_for(b) + split_at;</span>
<span class="line-added">+   size_t b_size        = b-&gt;length();</span>
<span class="line-added">+   size_t newb_size     = b_size - split_at;</span>
<span class="line-added">+ </span>
<span class="line-added">+   HeapBlock* newb = block_at(split_segment);</span>
<span class="line-added">+   newb-&gt;set_length(newb_size);</span>
<span class="line-added">+   mark_segmap_as_used(segment_for(newb), segment_for(newb) + newb_size, false);</span>
<span class="line-added">+   b-&gt;set_length(split_at);</span>
<span class="line-added">+   return newb;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void CodeHeap::deallocate_tail(void* p, size_t used_size) {
    assert(p == find_start(p), &quot;illegal deallocation&quot;);
    // Find start of HeapBlock
    HeapBlock* b = (((HeapBlock *)p) - 1);
    assert(b-&gt;allocated_space() == p, &quot;sanity check&quot;);
<span class="line-modified">! </span>
    size_t actual_number_of_segments = b-&gt;length();
<span class="line-added">+   size_t used_number_of_segments   = size_to_segments(used_size + header_size());</span>
<span class="line-added">+   size_t unused_number_of_segments = actual_number_of_segments - used_number_of_segments;</span>
    guarantee(used_number_of_segments &lt;= actual_number_of_segments, &quot;Must be!&quot;);
<span class="line-modified">! </span>
<span class="line-modified">!   HeapBlock* f = split_block(b, used_number_of_segments);</span>
<span class="line-modified">!   add_to_freelist(f);</span>
<span class="line-modified">!   NOT_PRODUCT(verify());</span>
  }
  
  void CodeHeap::deallocate(void* p) {
    assert(p == find_start(p), &quot;illegal deallocation&quot;);
    // Find start of HeapBlock
</pre>
<hr />
<pre>
<span class="line-old-header">*** 244,72 ***</span>
    assert(b-&gt;allocated_space() == p, &quot;sanity check&quot;);
    guarantee((char*) b &gt;= _memory.low_boundary() &amp;&amp; (char*) b &lt; _memory.high(),
              &quot;The block to be deallocated &quot; INTPTR_FORMAT &quot; is not within the heap &quot;
              &quot;starting with &quot;  INTPTR_FORMAT &quot; and ending with &quot; INTPTR_FORMAT,
              p2i(b), p2i(_memory.low_boundary()), p2i(_memory.high()));
<span class="line-removed">-   DEBUG_ONLY(memset((void *)b-&gt;allocated_space(), badCodeHeapFreeVal,</span>
<span class="line-removed">-              segments_to_size(b-&gt;length()) - sizeof(HeapBlock)));</span>
    add_to_freelist(b);
    NOT_PRODUCT(verify());
  }
  
  /**
<span class="line-modified">!  * Uses segment map to find the the start (header) of a nmethod. This works as follows:</span>
<span class="line-modified">!  * The memory of the code cache is divided into &#39;segments&#39;. The size of a segment is</span>
<span class="line-modified">!  * determined by -XX:CodeCacheSegmentSize=XX. Allocation in the code cache can only</span>
<span class="line-modified">!  * happen at segment boundaries. A pointer in the code cache can be mapped to a segment</span>
<span class="line-modified">!  * by calling segment_for(addr). Each time memory is requested from the code cache,</span>
<span class="line-modified">!  * the segmap is updated accordingly. See the following example, which illustrates the</span>
<span class="line-modified">!  * state of code cache and the segment map: (seg -&gt; segment, nm -&gt;nmethod)</span>
   *
   *          code cache          segmap
   *         -----------        ---------
   * seg 1   | nm 1    |   -&gt;   | 0     |
   * seg 2   | nm 1    |   -&gt;   | 1     |
   * ...     | nm 1    |   -&gt;   | ..    |
   * seg m   | nm 2    |   -&gt;   | 0     |
   * seg m+1 | nm 2    |   -&gt;   | 1     |
   * ...     | nm 2    |   -&gt;   | 2     |
   * ...     | nm 2    |   -&gt;   | ..    |
<span class="line-modified">!  * ...     | nm 2    |   -&gt;   | 0xFE  |</span>
<span class="line-modified">!  * seg m+n | nm 2    |   -&gt;   | 1     |</span>
   * ...     | nm 2    |   -&gt;   |       |
   *
<span class="line-modified">!  * A value of &#39;0&#39; in the segmap indicates that this segment contains the beginning of</span>
<span class="line-modified">!  * an nmethod. Let&#39;s walk through a simple example: If we want to find the start of</span>
<span class="line-modified">!  * an nmethod that falls into seg 2, we read the value of the segmap[2]. The value</span>
<span class="line-modified">!  * is an offset that points to the segment that contains the start of the nmethod.</span>
<span class="line-modified">!  * Another example: If we want to get the start of nm 2, and we happen to get a pointer</span>
<span class="line-modified">!  * that points to seg m+n, we first read seg[n+m], which returns &#39;1&#39;. So we have to</span>
<span class="line-modified">!  * do one more read of the segmap[m+n-1] to finally get the segment header.</span>
   */
<span class="line-modified">! void* CodeHeap::find_start(void* p) const {</span>
    if (!contains(p)) {
      return NULL;
    }
<span class="line-modified">!   size_t seg_idx = segment_for(p);</span>
    address seg_map = (address)_segmap.low();
    if (is_segment_unused(seg_map[seg_idx])) {
      return NULL;
    }
    while (seg_map[seg_idx] &gt; 0) {
      seg_idx -= (int)seg_map[seg_idx];
    }
  
<span class="line-modified">!   HeapBlock* h = block_at(seg_idx);</span>
<span class="line-modified">!   if (h-&gt;free()) {</span>
<span class="line-modified">!     return NULL;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   return h-&gt;allocated_space();</span>
  }
  
  CodeBlob* CodeHeap::find_blob_unsafe(void* start) const {
    CodeBlob* result = (CodeBlob*)CodeHeap::find_start(start);
<span class="line-modified">!   if (result != NULL &amp;&amp; result-&gt;blob_contains((address)start)) {</span>
<span class="line-removed">-     return result;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return NULL;</span>
  }
  
  size_t CodeHeap::alignment_unit() const {
    // this will be a power of two
    return _segment_size;
<span class="line-new-header">--- 368,126 ---</span>
    assert(b-&gt;allocated_space() == p, &quot;sanity check&quot;);
    guarantee((char*) b &gt;= _memory.low_boundary() &amp;&amp; (char*) b &lt; _memory.high(),
              &quot;The block to be deallocated &quot; INTPTR_FORMAT &quot; is not within the heap &quot;
              &quot;starting with &quot;  INTPTR_FORMAT &quot; and ending with &quot; INTPTR_FORMAT,
              p2i(b), p2i(_memory.low_boundary()), p2i(_memory.high()));
    add_to_freelist(b);
    NOT_PRODUCT(verify());
  }
  
  /**
<span class="line-modified">!  * The segment map is used to quickly find the the start (header) of a</span>
<span class="line-modified">!  * code block (e.g. nmethod) when only a pointer to a location inside the</span>
<span class="line-modified">!  * code block is known. This works as follows:</span>
<span class="line-modified">!  *  - The storage reserved for the code heap is divided into &#39;segments&#39;.</span>
<span class="line-modified">!  *  - The size of a segment is determined by -XX:CodeCacheSegmentSize=&lt;#bytes&gt;.</span>
<span class="line-modified">!  *  - The size must be a power of two to allow the use of shift operations</span>
<span class="line-modified">!  *    to quickly convert between segment index and segment address.</span>
<span class="line-added">+  *  - Segment start addresses should be aligned to be multiples of CodeCacheSegmentSize.</span>
<span class="line-added">+  *  - It seems beneficial for CodeCacheSegmentSize to be equal to os::page_size().</span>
<span class="line-added">+  *  - Allocation in the code cache can only happen at segment start addresses.</span>
<span class="line-added">+  *  - Allocation in the code cache is in units of CodeCacheSegmentSize.</span>
<span class="line-added">+  *  - A pointer in the code cache can be mapped to a segment by calling</span>
<span class="line-added">+  *    segment_for(addr).</span>
<span class="line-added">+  *  - The segment map is a byte array where array element [i] is related</span>
<span class="line-added">+  *    to the i-th segment in the code heap.</span>
<span class="line-added">+  *  - Each time memory is allocated/deallocated from the code cache,</span>
<span class="line-added">+  *    the segment map is updated accordingly.</span>
<span class="line-added">+  *    Note: deallocation does not cause the memory to become &quot;free&quot;, as</span>
<span class="line-added">+  *          indicated by the segment map state &quot;free_sentinel&quot;. Deallocation</span>
<span class="line-added">+  *          just changes the block state from &quot;used&quot; to &quot;free&quot;.</span>
<span class="line-added">+  *  - Elements of the segment map (byte) array are interpreted</span>
<span class="line-added">+  *    as unsigned integer.</span>
<span class="line-added">+  *  - Element values normally identify an offset backwards (in segment</span>
<span class="line-added">+  *    size units) from the associated segment towards the start of</span>
<span class="line-added">+  *    the block.</span>
<span class="line-added">+  *  - Some values have a special meaning:</span>
<span class="line-added">+  *       0 - This segment is the start of a block (HeapBlock or FreeBlock).</span>
<span class="line-added">+  *     255 - The free_sentinel value. This is a free segment, i.e. it is</span>
<span class="line-added">+  *           not yet allocated and thus does not belong to any block.</span>
<span class="line-added">+  *  - The value of the current element has to be subtracted from the</span>
<span class="line-added">+  *    current index to get closer to the start.</span>
<span class="line-added">+  *  - If the value of the then current element is zero, the block start</span>
<span class="line-added">+  *    segment is found and iteration stops. Otherwise, start over with the</span>
<span class="line-added">+  *    previous step.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  *    The following example illustrates a possible state of code cache</span>
<span class="line-added">+  *    and the segment map: (seg -&gt; segment, nm -&gt;nmethod)</span>
   *
   *          code cache          segmap
   *         -----------        ---------
   * seg 1   | nm 1    |   -&gt;   | 0     |
   * seg 2   | nm 1    |   -&gt;   | 1     |
   * ...     | nm 1    |   -&gt;   | ..    |
<span class="line-added">+  * seg m-1 | nm 1    |   -&gt;   | m-1   |</span>
   * seg m   | nm 2    |   -&gt;   | 0     |
   * seg m+1 | nm 2    |   -&gt;   | 1     |
   * ...     | nm 2    |   -&gt;   | 2     |
   * ...     | nm 2    |   -&gt;   | ..    |
<span class="line-modified">!  * ...     | nm 2    |   -&gt;   | 0xFE  | (free_sentinel-1)</span>
<span class="line-modified">!  * ...     | nm 2    |   -&gt;   | 1     |</span>
<span class="line-added">+  * seg m+n | nm 2    |   -&gt;   | 2     |</span>
   * ...     | nm 2    |   -&gt;   |       |
   *
<span class="line-modified">!  * How to read:</span>
<span class="line-modified">!  * A value of &#39;0&#39; in the segmap indicates that this segment contains the</span>
<span class="line-modified">!  * beginning of a CodeHeap block. Let&#39;s walk through a simple example:</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * We want to find the start of the block that contains nm 1, and we are</span>
<span class="line-modified">!  * given a pointer that points into segment m-2. We then read the value</span>
<span class="line-modified">!  * of segmap[m-2]. The value is an offset that points to the segment</span>
<span class="line-added">+  * which contains the start of the block.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Another example: We want to locate the start of nm 2, and we happen to</span>
<span class="line-added">+  * get a pointer that points into seg m+n. We first read seg[n+m], which</span>
<span class="line-added">+  * returns &#39;2&#39;. So we have to update our segment map index (ix -= segmap[n+m])</span>
<span class="line-added">+  * and start over.</span>
   */
<span class="line-modified">! </span>
<span class="line-added">+ // Find block which contains the passed pointer,</span>
<span class="line-added">+ // regardless of the block being used or free.</span>
<span class="line-added">+ // NULL is returned if anything invalid is detected.</span>
<span class="line-added">+ void* CodeHeap::find_block_for(void* p) const {</span>
<span class="line-added">+   // Check the pointer to be in committed range.</span>
    if (!contains(p)) {
      return NULL;
    }
<span class="line-modified">! </span>
    address seg_map = (address)_segmap.low();
<span class="line-added">+   size_t  seg_idx = segment_for(p);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // This may happen in special cases. Just ignore.</span>
<span class="line-added">+   // Example: PPC ICache stub generation.</span>
    if (is_segment_unused(seg_map[seg_idx])) {
      return NULL;
    }
<span class="line-added">+ </span>
<span class="line-added">+   // Iterate the segment map chain to find the start of the block.</span>
    while (seg_map[seg_idx] &gt; 0) {
<span class="line-added">+     // Don&#39;t check each segment index to refer to a used segment.</span>
<span class="line-added">+     // This method is called extremely often. Therefore, any checking</span>
<span class="line-added">+     // has a significant impact on performance. Rely on CodeHeap::verify()</span>
<span class="line-added">+     // to do the job on request.</span>
      seg_idx -= (int)seg_map[seg_idx];
    }
  
<span class="line-modified">!   return address_for(seg_idx);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! // Find block which contains the passed pointer.</span>
<span class="line-modified">! // The block must be used, i.e. must not be a FreeBlock.</span>
<span class="line-added">+ // Return a pointer that points past the block header.</span>
<span class="line-added">+ void* CodeHeap::find_start(void* p) const {</span>
<span class="line-added">+   HeapBlock* h = (HeapBlock*)find_block_for(p);</span>
<span class="line-added">+   return ((h == NULL) || h-&gt;free()) ? NULL : h-&gt;allocated_space();</span>
  }
  
<span class="line-added">+ // Find block which contains the passed pointer.</span>
<span class="line-added">+ // Same as find_start(p), but with additional safety net.</span>
  CodeBlob* CodeHeap::find_blob_unsafe(void* start) const {
    CodeBlob* result = (CodeBlob*)CodeHeap::find_start(start);
<span class="line-modified">!   return (result != NULL &amp;&amp; result-&gt;blob_contains((address)start)) ? result : NULL;</span>
  }
  
  size_t CodeHeap::alignment_unit() const {
    // this will be a power of two
    return _segment_size;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 325,30 ***</span>
  // Returns the current block if available and used.
  // If not, it returns the subsequent block (if available), NULL otherwise.
  // Free blocks are merged, therefore there is at most one free block
  // between two used ones. As a result, the subsequent block (if available) is
  // guaranteed to be used.
  void* CodeHeap::next_used(HeapBlock* b) const {
    if (b != NULL &amp;&amp; b-&gt;free()) b = next_block(b);
    assert(b == NULL || !b-&gt;free(), &quot;must be in use or at end of heap&quot;);
    return (b == NULL) ? NULL : b-&gt;allocated_space();
  }
  
  // Returns the first used HeapBlock
  HeapBlock* CodeHeap::first_block() const {
    if (_next_segment &gt; 0)
      return block_at(0);
    return NULL;
  }
  
  HeapBlock* CodeHeap::block_start(void* q) const {
    HeapBlock* b = (HeapBlock*)find_start(q);
    if (b == NULL) return NULL;
    return b - 1;
  }
  
<span class="line-modified">! // Returns the next Heap block an offset into one</span>
  HeapBlock* CodeHeap::next_block(HeapBlock *b) const {
    if (b == NULL) return NULL;
    size_t i = segment_for(b) + b-&gt;length();
    if (i &lt; _next_segment)
      return block_at(i);
<span class="line-new-header">--- 503,34 ---</span>
  // Returns the current block if available and used.
  // If not, it returns the subsequent block (if available), NULL otherwise.
  // Free blocks are merged, therefore there is at most one free block
  // between two used ones. As a result, the subsequent block (if available) is
  // guaranteed to be used.
<span class="line-added">+ // The returned pointer points past the block header.</span>
  void* CodeHeap::next_used(HeapBlock* b) const {
    if (b != NULL &amp;&amp; b-&gt;free()) b = next_block(b);
    assert(b == NULL || !b-&gt;free(), &quot;must be in use or at end of heap&quot;);
    return (b == NULL) ? NULL : b-&gt;allocated_space();
  }
  
  // Returns the first used HeapBlock
<span class="line-added">+ // The returned pointer points to the block header.</span>
  HeapBlock* CodeHeap::first_block() const {
    if (_next_segment &gt; 0)
      return block_at(0);
    return NULL;
  }
  
<span class="line-added">+ // The returned pointer points to the block header.</span>
  HeapBlock* CodeHeap::block_start(void* q) const {
    HeapBlock* b = (HeapBlock*)find_start(q);
    if (b == NULL) return NULL;
    return b - 1;
  }
  
<span class="line-modified">! // Returns the next Heap block.</span>
<span class="line-added">+ // The returned pointer points to the block header.</span>
  HeapBlock* CodeHeap::next_block(HeapBlock *b) const {
    if (b == NULL) return NULL;
    size_t i = segment_for(b) + b-&gt;length();
    if (i &lt; _next_segment)
      return block_at(i);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 402,38 ***</span>
  // Try to merge this block with the following block
  bool CodeHeap::merge_right(FreeBlock* a) {
    assert(a-&gt;free(), &quot;must be a free block&quot;);
    if (following_block(a) == a-&gt;link()) {
      assert(a-&gt;link() != NULL &amp;&amp; a-&gt;link()-&gt;free(), &quot;must be free too&quot;);
<span class="line-modified">!     // Update block a to include the following block</span>
      a-&gt;set_length(a-&gt;length() + a-&gt;link()-&gt;length());
      a-&gt;set_link(a-&gt;link()-&gt;link());
<span class="line-modified">!     // Update find_start map</span>
<span class="line-modified">!     size_t beg = segment_for(a);</span>
<span class="line-modified">!     mark_segmap_as_used(beg, beg + a-&gt;length());</span>
      _freelist_length--;
      return true;
    }
    return false;
  }
  
  
  void CodeHeap::add_to_freelist(HeapBlock* a) {
    FreeBlock* b = (FreeBlock*)a;
    _freelist_length++;
  
<span class="line-modified">!   assert(b != _freelist, &quot;cannot be removed twice&quot;);</span>
  
  
    // Mark as free and update free space count
    _freelist_segments += b-&gt;length();
    b-&gt;set_free();
  
    // First element in list?
    if (_freelist == NULL) {
<span class="line-removed">-     _freelist = b;</span>
      b-&gt;set_link(NULL);
      return;
    }
  
    // Since the freelist is ordered (smaller addresses -&gt; larger addresses) and the
    // element we want to insert into the freelist has a smaller address than the first
<span class="line-new-header">--- 584,50 ---</span>
  // Try to merge this block with the following block
  bool CodeHeap::merge_right(FreeBlock* a) {
    assert(a-&gt;free(), &quot;must be a free block&quot;);
    if (following_block(a) == a-&gt;link()) {
      assert(a-&gt;link() != NULL &amp;&amp; a-&gt;link()-&gt;free(), &quot;must be free too&quot;);
<span class="line-modified">! </span>
<span class="line-added">+     // Remember linked (following) block. invalidate should only zap header of this block.</span>
<span class="line-added">+     size_t follower = segment_for(a-&gt;link());</span>
<span class="line-added">+     // Merge block a to include the following block.</span>
      a-&gt;set_length(a-&gt;length() + a-&gt;link()-&gt;length());
      a-&gt;set_link(a-&gt;link()-&gt;link());
<span class="line-modified">! </span>
<span class="line-modified">!     // Update the segment map and invalidate block contents.</span>
<span class="line-modified">!     mark_segmap_as_used(follower, segment_for(a) + a-&gt;length(), true);</span>
<span class="line-added">+     // Block contents has already been invalidated by add_to_freelist.</span>
<span class="line-added">+     // What&#39;s left is the header of the following block which now is</span>
<span class="line-added">+     // in the middle of the merged block. Just zap one segment.</span>
<span class="line-added">+     invalidate(follower, follower + 1, 0);</span>
<span class="line-added">+ </span>
      _freelist_length--;
      return true;
    }
    return false;
  }
  
  
  void CodeHeap::add_to_freelist(HeapBlock* a) {
    FreeBlock* b = (FreeBlock*)a;
<span class="line-added">+   size_t  bseg = segment_for(b);</span>
    _freelist_length++;
  
<span class="line-modified">!   _blob_count--;</span>
<span class="line-added">+   assert(_blob_count &gt;= 0, &quot;sanity&quot;);</span>
  
<span class="line-added">+   assert(b != _freelist, &quot;cannot be removed twice&quot;);</span>
  
    // Mark as free and update free space count
    _freelist_segments += b-&gt;length();
    b-&gt;set_free();
<span class="line-added">+   invalidate(bseg, bseg + b-&gt;length(), sizeof(FreeBlock));</span>
  
    // First element in list?
    if (_freelist == NULL) {
      b-&gt;set_link(NULL);
<span class="line-added">+     _freelist = b;</span>
      return;
    }
  
    // Since the freelist is ordered (smaller addresses -&gt; larger addresses) and the
    // element we want to insert into the freelist has a smaller address than the first
</pre>
<hr />
<pre>
<span class="line-old-header">*** 444,44 ***</span>
      _freelist = b;
      merge_right(_freelist);
      return;
    }
  
<span class="line-modified">!   // Scan for right place to put into list. List</span>
<span class="line-modified">!   // is sorted by increasing addresses</span>
    FreeBlock* prev = _freelist;
    FreeBlock* cur  = _freelist-&gt;link();
    while(cur != NULL &amp;&amp; cur &lt; b) {
      assert(prev &lt; cur, &quot;Freelist must be ordered&quot;);
      prev = cur;
      cur  = cur-&gt;link();
    }
    assert((prev &lt; b) &amp;&amp; (cur == NULL || b &lt; cur), &quot;free-list must be ordered&quot;);
    insert_after(prev, b);
  }
  
  /**
   * Search freelist for an entry on the list with the best fit.
   * @return NULL, if no one was found
   */
<span class="line-modified">! FreeBlock* CodeHeap::search_freelist(size_t length) {</span>
<span class="line-modified">!   FreeBlock* found_block = NULL;</span>
<span class="line-modified">!   FreeBlock* found_prev  = NULL;</span>
<span class="line-modified">!   size_t     found_length = 0;</span>
  
    FreeBlock* prev = NULL;
<span class="line-modified">!   FreeBlock* cur = _freelist;</span>
  
<span class="line-modified">!   // Search for first block that fits</span>
<span class="line-removed">-   while(cur != NULL) {</span>
<span class="line-removed">-     if (cur-&gt;length() &gt;= length) {</span>
<span class="line-removed">-       // Remember block, its previous element, and its length</span>
<span class="line-removed">-       found_block = cur;</span>
<span class="line-removed">-       found_prev  = prev;</span>
<span class="line-removed">-       found_length = found_block-&gt;length();</span>
  
        break;
      }
      // Next element in list
      prev = cur;
      cur  = cur-&gt;link();
    }
<span class="line-new-header">--- 638,60 ---</span>
      _freelist = b;
      merge_right(_freelist);
      return;
    }
  
<span class="line-modified">!   // Scan for right place to put into list.</span>
<span class="line-modified">!   // List is sorted by increasing addresses.</span>
    FreeBlock* prev = _freelist;
    FreeBlock* cur  = _freelist-&gt;link();
<span class="line-added">+   if ((_freelist_length &gt; freelist_limit) &amp;&amp; (_last_insert_point != NULL)) {</span>
<span class="line-added">+     _last_insert_point = (FreeBlock*)find_block_for(_last_insert_point);</span>
<span class="line-added">+     if ((_last_insert_point != NULL) &amp;&amp; _last_insert_point-&gt;free() &amp;&amp; (_last_insert_point &lt; b)) {</span>
<span class="line-added">+       prev = _last_insert_point;</span>
<span class="line-added">+       cur  = prev-&gt;link();</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
    while(cur != NULL &amp;&amp; cur &lt; b) {
      assert(prev &lt; cur, &quot;Freelist must be ordered&quot;);
      prev = cur;
      cur  = cur-&gt;link();
    }
    assert((prev &lt; b) &amp;&amp; (cur == NULL || b &lt; cur), &quot;free-list must be ordered&quot;);
    insert_after(prev, b);
<span class="line-added">+   _last_insert_point = prev;</span>
  }
  
  /**
   * Search freelist for an entry on the list with the best fit.
   * @return NULL, if no one was found
   */
<span class="line-modified">! HeapBlock* CodeHeap::search_freelist(size_t length) {</span>
<span class="line-modified">!   FreeBlock* found_block  = NULL;</span>
<span class="line-modified">!   FreeBlock* found_prev   = NULL;</span>
<span class="line-modified">!   size_t     found_length = _next_segment; // max it out to begin with</span>
  
<span class="line-added">+   HeapBlock* res  = NULL;</span>
    FreeBlock* prev = NULL;
<span class="line-modified">!   FreeBlock* cur  = _freelist;</span>
  
<span class="line-modified">!   length = length &lt; CodeCacheMinBlockLength ? CodeCacheMinBlockLength : length;</span>
  
<span class="line-added">+   // Search for best-fitting block</span>
<span class="line-added">+   while(cur != NULL) {</span>
<span class="line-added">+     size_t cur_length = cur-&gt;length();</span>
<span class="line-added">+     if (cur_length == length) {</span>
<span class="line-added">+       // We have a perfect fit</span>
<span class="line-added">+       found_block  = cur;</span>
<span class="line-added">+       found_prev   = prev;</span>
<span class="line-added">+       found_length = cur_length;</span>
        break;
<span class="line-added">+     } else if ((cur_length &gt; length) &amp;&amp; (cur_length &lt; found_length)) {</span>
<span class="line-added">+       // This is a new, closer fit. Remember block, its previous element, and its length</span>
<span class="line-added">+       found_block  = cur;</span>
<span class="line-added">+       found_prev   = prev;</span>
<span class="line-added">+       found_length = cur_length;</span>
      }
      // Next element in list
      prev = cur;
      cur  = cur-&gt;link();
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 502,24 ***</span>
      } else {
        assert((found_prev-&gt;link() == found_block), &quot;sanity check&quot;);
        // Unmap element
        found_prev-&gt;set_link(found_block-&gt;link());
      }
    } else {
<span class="line-modified">!     // Truncate block and return a pointer to the following block</span>
<span class="line-modified">!     // Set used bit and length on new block</span>
<span class="line-modified">!     found_block-&gt;set_length(found_length - length);</span>
<span class="line-modified">!     found_block = following_block(found_block);</span>
<span class="line-modified">! </span>
<span class="line-removed">-     size_t beg = segment_for(found_block);</span>
<span class="line-removed">-     mark_segmap_as_used(beg, beg + length);</span>
<span class="line-removed">-     found_block-&gt;set_length(length);</span>
    }
  
<span class="line-modified">!   found_block-&gt;set_used();</span>
    _freelist_segments -= length;
<span class="line-modified">!   return found_block;</span>
  }
  
  //----------------------------------------------------------------------------
  // Non-product code
  
<span class="line-new-header">--- 712,73 ---</span>
      } else {
        assert((found_prev-&gt;link() == found_block), &quot;sanity check&quot;);
        // Unmap element
        found_prev-&gt;set_link(found_block-&gt;link());
      }
<span class="line-added">+     res = (HeapBlock*)found_block;</span>
<span class="line-added">+     // sizeof(HeapBlock) &lt; sizeof(FreeBlock).</span>
<span class="line-added">+     // Invalidate the additional space that FreeBlock occupies.</span>
<span class="line-added">+     // The rest of the block should already be invalidated.</span>
<span class="line-added">+     // This is necessary due to a dubious assert in nmethod.cpp(PcDescCache::reset_to()).</span>
<span class="line-added">+     // Can&#39;t use invalidate() here because it works on segment_size units (too coarse).</span>
<span class="line-added">+     DEBUG_ONLY(memset((void*)res-&gt;allocated_space(), badCodeHeapNewVal, sizeof(FreeBlock) - sizeof(HeapBlock)));</span>
    } else {
<span class="line-modified">!     // Truncate the free block and return the truncated part</span>
<span class="line-modified">!     // as new HeapBlock. The remaining free block does not</span>
<span class="line-modified">!     // need to be updated, except for it&#39;s length. Truncating</span>
<span class="line-modified">!     // the segment map does not invalidate the leading part.</span>
<span class="line-modified">!     res = split_block(found_block, found_length - length);</span>
    }
  
<span class="line-modified">!   res-&gt;set_used();</span>
    _freelist_segments -= length;
<span class="line-modified">!   return res;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ int CodeHeap::defrag_segmap(bool do_defrag) {</span>
<span class="line-added">+   int extra_hops_used = 0;</span>
<span class="line-added">+   int extra_hops_free = 0;</span>
<span class="line-added">+   int blocks_used     = 0;</span>
<span class="line-added">+   int blocks_free     = 0;</span>
<span class="line-added">+   for(HeapBlock* h = first_block(); h != NULL; h = next_block(h)) {</span>
<span class="line-added">+     size_t beg = segment_for(h);</span>
<span class="line-added">+     size_t end = segment_for(h) + h-&gt;length();</span>
<span class="line-added">+     int extra_hops = segmap_hops(beg, end);</span>
<span class="line-added">+     if (h-&gt;free()) {</span>
<span class="line-added">+       extra_hops_free += extra_hops;</span>
<span class="line-added">+       blocks_free++;</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       extra_hops_used += extra_hops;</span>
<span class="line-added">+       blocks_used++;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (do_defrag &amp;&amp; (extra_hops &gt; 0)) {</span>
<span class="line-added">+       mark_segmap_as_used(beg, end, false);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return extra_hops_used + extra_hops_free;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Count the hops required to get from the last segment of a</span>
<span class="line-added">+ // heap block to the block header segment. For the optimal case,</span>
<span class="line-added">+ //   #hops = ((#segments-1)+(free_sentinel-2))/(free_sentinel-1)</span>
<span class="line-added">+ // The range of segments to be checked is given by [beg..end).</span>
<span class="line-added">+ // Return the number of extra hops required. There may be extra hops</span>
<span class="line-added">+ // due to the is_FreeBlock_join optimization in mark_segmap_as_used().</span>
<span class="line-added">+ int CodeHeap::segmap_hops(size_t beg, size_t end) {</span>
<span class="line-added">+   if (beg &lt; end) {</span>
<span class="line-added">+     // setup _segmap pointers for faster indexing</span>
<span class="line-added">+     address p = (address)_segmap.low() + beg;</span>
<span class="line-added">+     int hops_expected = (int)(((end-beg-1)+(free_sentinel-2))/(free_sentinel-1));</span>
<span class="line-added">+     int nhops = 0;</span>
<span class="line-added">+     size_t ix = end-beg-1;</span>
<span class="line-added">+     while (p[ix] &gt; 0) {</span>
<span class="line-added">+       ix -= p[ix];</span>
<span class="line-added">+       nhops++;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return (nhops &gt; hops_expected) ? nhops - hops_expected : 0;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return 0;</span>
  }
  
  //----------------------------------------------------------------------------
  // Non-product code
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 547,10 ***</span>
<span class="line-new-header">--- 806,38 ---</span>
      }
      // Verify that the freelist contains the same number of blocks
      // than free blocks found on the full list.
      assert(count == 0, &quot;missing free blocks&quot;);
  
<span class="line-added">+     //---&lt;  all free block memory must have been invalidated  &gt;---</span>
<span class="line-added">+     for(FreeBlock* b = _freelist; b != NULL; b = b-&gt;link()) {</span>
<span class="line-added">+       for (char* c = (char*)b + sizeof(FreeBlock); c &lt; (char*)b + segments_to_size(b-&gt;length()); c++) {</span>
<span class="line-added">+         assert(*c == (char)badCodeHeapNewVal, &quot;FreeBlock@&quot; PTR_FORMAT &quot;(&quot; PTR_FORMAT &quot;) not invalidated @byte %d&quot;, p2i(b), b-&gt;length(), (int)(c - (char*)b));</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     address seg_map = (address)_segmap.low();</span>
<span class="line-added">+     size_t  nseg       = 0;</span>
<span class="line-added">+     int     extra_hops = 0;</span>
<span class="line-added">+     count = 0;</span>
<span class="line-added">+     for(HeapBlock* b = first_block(); b != NULL; b = next_block(b)) {</span>
<span class="line-added">+       size_t seg1 = segment_for(b);</span>
<span class="line-added">+       size_t segn = seg1 + b-&gt;length();</span>
<span class="line-added">+       extra_hops += segmap_hops(seg1, segn);</span>
<span class="line-added">+       count++;</span>
<span class="line-added">+       for (size_t i = seg1; i &lt; segn; i++) {</span>
<span class="line-added">+         nseg++;</span>
<span class="line-added">+         //---&lt;  Verify segment map marking  &gt;---</span>
<span class="line-added">+         // All allocated segments, no matter if in a free or used block,</span>
<span class="line-added">+         // must be marked &quot;in use&quot;.</span>
<span class="line-added">+         assert(!is_segment_unused(seg_map[i]), &quot;CodeHeap: unused segment. seg_map[%d]([%d..%d]) = %d, %s block&quot;,    (int)i, (int)seg1, (int)segn, seg_map[i], b-&gt;free()? &quot;free&quot;:&quot;used&quot;);</span>
<span class="line-added">+         assert((unsigned char)seg_map[i] &lt; free_sentinel, &quot;CodeHeap: seg_map[%d]([%d..%d]) = %d (out of range)&quot;,    (int)i, (int)seg1, (int)segn, seg_map[i]);</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+     assert(nseg == _next_segment, &quot;CodeHeap: segment count mismatch. found %d, expected %d.&quot;, (int)nseg, (int)_next_segment);</span>
<span class="line-added">+     assert((count == 0) || (extra_hops &lt; (16 + 2*count)), &quot;CodeHeap: many extra hops due to optimization. blocks: %d, extra hops: %d.&quot;, count, extra_hops);</span>
<span class="line-added">+ </span>
      // Verify that the number of free blocks is not out of hand.
      static int free_block_threshold = 10000;
      if (count &gt; free_block_threshold) {
        warning(&quot;CodeHeap: # of free blocks &gt; %d&quot;, free_block_threshold);
        // Double the warning limit
</pre>
<center><a href="freeList.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="heap.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
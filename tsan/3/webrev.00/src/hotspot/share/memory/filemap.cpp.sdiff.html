<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/filemap.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="arena.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="filemap.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/filemap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;

  27 #include &quot;classfile/classLoader.inline.hpp&quot;

  28 #include &quot;classfile/classLoaderExt.hpp&quot;
  29 #include &quot;classfile/symbolTable.hpp&quot;
  30 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  31 #include &quot;classfile/altHashing.hpp&quot;
  32 #include &quot;logging/log.hpp&quot;
  33 #include &quot;logging/logStream.hpp&quot;
  34 #include &quot;logging/logMessage.hpp&quot;


  35 #include &quot;memory/filemap.hpp&quot;
  36 #include &quot;memory/heapShared.inline.hpp&quot;
  37 #include &quot;memory/iterator.inline.hpp&quot;
  38 #include &quot;memory/metadataFactory.hpp&quot;
  39 #include &quot;memory/metaspaceClosure.hpp&quot;
  40 #include &quot;memory/metaspaceShared.hpp&quot;
  41 #include &quot;memory/oopFactory.hpp&quot;


  42 #include &quot;oops/compressedOops.inline.hpp&quot;
  43 #include &quot;oops/objArrayOop.hpp&quot;
  44 #include &quot;oops/oop.inline.hpp&quot;
  45 #include &quot;prims/jvmtiExport.hpp&quot;
  46 #include &quot;runtime/arguments.hpp&quot;
  47 #include &quot;runtime/java.hpp&quot;
  48 #include &quot;runtime/mutexLocker.hpp&quot;
  49 #include &quot;runtime/os.inline.hpp&quot;
  50 #include &quot;runtime/vm_version.hpp&quot;
  51 #include &quot;services/memTracker.hpp&quot;
  52 #include &quot;utilities/align.hpp&quot;


  53 #include &quot;utilities/defaultStream.hpp&quot;
  54 #if INCLUDE_G1GC
  55 #include &quot;gc/g1/g1CollectedHeap.hpp&quot;
  56 #include &quot;gc/g1/heapRegion.hpp&quot;
  57 #endif
  58 
  59 # include &lt;sys/stat.h&gt;
  60 # include &lt;errno.h&gt;
  61 
  62 #ifndef O_BINARY       // if defined (Win32) use binary files.
  63 #define O_BINARY 0     // otherwise do nothing.
  64 #endif
  65 
<span class="line-removed">  66 extern address JVM_FunctionAtStart();</span>
<span class="line-removed">  67 extern address JVM_FunctionAtEnd();</span>
<span class="line-removed">  68 </span>
  69 // Complain and stop. All error conditions occurring during the writing of
  70 // an archive file should stop the process.  Unrecoverable errors during
  71 // the reading of the archive file should stop the process.
  72 
<span class="line-modified">  73 static void fail(const char *msg, va_list ap) {</span>
  74   // This occurs very early during initialization: tty is not initialized.
  75   jio_fprintf(defaultStream::error_stream(),
  76               &quot;An error has occurred while processing the&quot;
  77               &quot; shared archive file.\n&quot;);
  78   jio_vfprintf(defaultStream::error_stream(), msg, ap);
  79   jio_fprintf(defaultStream::error_stream(), &quot;\n&quot;);
  80   // Do not change the text of the below message because some tests check for it.
  81   vm_exit_during_initialization(&quot;Unable to use shared archive.&quot;, NULL);
  82 }
  83 
  84 
  85 void FileMapInfo::fail_stop(const char *msg, ...) {
  86         va_list ap;
  87   va_start(ap, msg);
<span class="line-modified">  88   fail(msg, ap);        // Never returns.</span>
  89   va_end(ap);           // for completeness.
  90 }
  91 
  92 
  93 // Complain and continue.  Recoverable errors during the reading of the
  94 // archive file may continue (with sharing disabled).
  95 //
  96 // If we continue, then disable shared spaces and close the file.
  97 
  98 void FileMapInfo::fail_continue(const char *msg, ...) {
  99   va_list ap;
 100   va_start(ap, msg);
<span class="line-removed"> 101   MetaspaceShared::set_archive_loading_failed();</span>
 102   if (PrintSharedArchiveAndExit &amp;&amp; _validating_shared_path_table) {
 103     // If we are doing PrintSharedArchiveAndExit and some of the classpath entries
 104     // do not validate, we can still continue &quot;limping&quot; to validate the remaining
 105     // entries. No need to quit.
 106     tty-&gt;print(&quot;[&quot;);
 107     tty-&gt;vprint(msg, ap);
 108     tty-&gt;print_cr(&quot;]&quot;);
 109   } else {
 110     if (RequireSharedSpaces) {
<span class="line-modified"> 111       fail(msg, ap);</span>
 112     } else {
 113       if (log_is_enabled(Info, cds)) {
 114         ResourceMark rm;
 115         LogStream ls(Log(cds)::info());
 116         ls.print(&quot;UseSharedSpaces: &quot;);
 117         ls.vprint_cr(msg, ap);
 118       }
 119     }
<span class="line-removed"> 120     UseSharedSpaces = false;</span>
<span class="line-removed"> 121     assert(current_info() != NULL, &quot;singleton must be registered&quot;);</span>
<span class="line-removed"> 122     current_info()-&gt;close();</span>
 123   }
 124   va_end(ap);
 125 }
 126 
 127 // Fill in the fileMapInfo structure with data about this VM instance.
 128 
 129 // This method copies the vm version info into header_version.  If the version is too
 130 // long then a truncated version, which has a hash code appended to it, is copied.
 131 //
 132 // Using a template enables this method to verify that header_version is an array of
 133 // length JVM_IDENT_MAX.  This ensures that the code that writes to the CDS file and
 134 // the code that reads the CDS file will both use the same size buffer.  Hence, will
 135 // use identical truncation.  This is necessary for matching of truncated versions.
 136 template &lt;int N&gt; static void get_header_version(char (&amp;header_version) [N]) {
 137   assert(N == JVM_IDENT_MAX, &quot;Bad header_version size&quot;);
 138 
 139   const char *vm_version = VM_Version::internal_vm_info_string();
 140   const int version_len = (int)strlen(vm_version);
 141 


 142   if (version_len &lt; (JVM_IDENT_MAX-1)) {
 143     strcpy(header_version, vm_version);
 144 
 145   } else {
 146     // Get the hash value.  Use a static seed because the hash needs to return the same
 147     // value over multiple jvm invocations.
 148     unsigned int hash = AltHashing::murmur3_32(8191, (const jbyte*)vm_version, version_len);
 149 
 150     // Truncate the ident, saving room for the 8 hex character hash value.
 151     strncpy(header_version, vm_version, JVM_IDENT_MAX-9);
 152 
 153     // Append the hash code as eight hex digits.
 154     sprintf(&amp;header_version[JVM_IDENT_MAX-9], &quot;%08x&quot;, hash);
 155     header_version[JVM_IDENT_MAX-1] = 0;  // Null terminate.
 156   }


 157 }
 158 
<span class="line-modified"> 159 FileMapInfo::FileMapInfo() {</span>
<span class="line-removed"> 160   assert(_current_info == NULL, &quot;must be singleton&quot;); // not thread safe</span>
<span class="line-removed"> 161   _current_info = this;</span>
 162   memset((void*)this, 0, sizeof(FileMapInfo));
















 163   _file_offset = 0;
 164   _file_open = false;
<span class="line-removed"> 165   _header = (FileMapHeader*)os::malloc(sizeof(FileMapHeader), mtInternal);</span>
<span class="line-removed"> 166   _header-&gt;_version = INVALID_CDS_ARCHIVE_VERSION;</span>
<span class="line-removed"> 167   _header-&gt;_has_platform_or_app_classes = true;</span>
 168 }
 169 
 170 FileMapInfo::~FileMapInfo() {
<span class="line-modified"> 171   assert(_current_info == this, &quot;must be singleton&quot;); // not thread safe</span>
<span class="line-modified"> 172   _current_info = NULL;</span>





 173 }
 174 
 175 void FileMapInfo::populate_header(size_t alignment) {
<span class="line-modified"> 176   _header-&gt;populate(this, alignment);</span>
 177 }
 178 
 179 void FileMapHeader::populate(FileMapInfo* mapinfo, size_t alignment) {
<span class="line-modified"> 180   _magic = CDS_ARCHIVE_MAGIC;</span>




 181   _version = CURRENT_CDS_ARCHIVE_VERSION;
 182   _alignment = alignment;
 183   _obj_alignment = ObjectAlignmentInBytes;
 184   _compact_strings = CompactStrings;
<span class="line-modified"> 185   _narrow_oop_mode = Universe::narrow_oop_mode();</span>
<span class="line-modified"> 186   _narrow_oop_base = Universe::narrow_oop_base();</span>
<span class="line-modified"> 187   _narrow_oop_shift = Universe::narrow_oop_shift();</span>


 188   _max_heap_size = MaxHeapSize;
<span class="line-modified"> 189   _narrow_klass_base = Universe::narrow_klass_base();</span>
<span class="line-removed"> 190   _narrow_klass_shift = Universe::narrow_klass_shift();</span>
<span class="line-removed"> 191   _shared_path_table_size = mapinfo-&gt;_shared_path_table_size;</span>
<span class="line-removed"> 192   _shared_path_table = mapinfo-&gt;_shared_path_table;</span>
<span class="line-removed"> 193   _shared_path_entry_size = mapinfo-&gt;_shared_path_entry_size;</span>
 194   if (HeapShared::is_heap_object_archiving_allowed()) {
<span class="line-modified"> 195     _heap_reserved = Universe::heap()-&gt;reserved_region();</span>
 196   }
 197 
 198   // The following fields are for sanity checks for whether this archive
 199   // will function correctly with this JVM and the bootclasspath it&#39;s
 200   // invoked with.
 201 
 202   // JVM version string ... changes on each build.
 203   get_header_version(_jvm_ident);
 204 
<span class="line-removed"> 205   ClassLoaderExt::finalize_shared_paths_misc_info();</span>
 206   _app_class_paths_start_index = ClassLoaderExt::app_class_paths_start_index();
 207   _app_module_paths_start_index = ClassLoaderExt::app_module_paths_start_index();

 208   _max_used_path_index = ClassLoaderExt::max_used_path_index();
 209 
 210   _verify_local = BytecodeVerificationLocal;
 211   _verify_remote = BytecodeVerificationRemote;
 212   _has_platform_or_app_classes = ClassLoaderExt::has_platform_or_app_classes();
<span class="line-modified"> 213   _shared_base_address = SharedBaseAddress;</span>

 214   _allow_archiving_with_java_agent = AllowArchivingWithJavaAgent;












 215 }
 216 
<span class="line-modified"> 217 void SharedClassPathEntry::init(const char* name, bool is_modules_image, TRAPS) {</span>
<span class="line-modified"> 218   assert(DumpSharedSpaces, &quot;dump time only&quot;);</span>

 219   _timestamp = 0;
 220   _filesize  = 0;

 221 
 222   struct stat st;
<span class="line-modified"> 223   if (os::stat(name, &amp;st) == 0) {</span>
 224     if ((st.st_mode &amp; S_IFMT) == S_IFDIR) {
 225       _type = dir_entry;
 226     } else {
 227       // The timestamp of the modules_image is not checked at runtime.
 228       if (is_modules_image) {
 229         _type = modules_image_entry;
 230       } else {
 231         _type = jar_entry;
 232         _timestamp = st.st_mtime;

 233       }
 234       _filesize = st.st_size;
 235     }
 236   } else {
 237     // The file/dir must exist, or it would not have been added
 238     // into ClassLoader::classpath_entry().
 239     //
 240     // If we can&#39;t access a jar file in the boot path, then we can&#39;t
 241     // make assumptions about where classes get loaded from.
<span class="line-modified"> 242     FileMapInfo::fail_stop(&quot;Unable to open file %s.&quot;, name);</span>
 243   }
 244 







 245   size_t len = strlen(name) + 1;
 246   _name = MetadataFactory::new_array&lt;char&gt;(ClassLoaderData::the_null_class_loader_data(), (int)len, THREAD);
 247   strcpy(_name-&gt;data(), name);
 248 }
 249 
<span class="line-modified"> 250 bool SharedClassPathEntry::validate(bool is_class_path) {</span>












 251   assert(UseSharedSpaces, &quot;runtime only&quot;);
 252 
 253   struct stat st;
<span class="line-modified"> 254   const char* name;</span>
<span class="line-removed"> 255 </span>
<span class="line-removed"> 256   // In order to validate the runtime modules image file size against the archived</span>
<span class="line-removed"> 257   // size information, we need to obtain the runtime modules image path. The recorded</span>
<span class="line-removed"> 258   // dump time modules image path in the archive may be different from the runtime path</span>
<span class="line-removed"> 259   // if the JDK image has beed moved after generating the archive.</span>
<span class="line-removed"> 260   if (is_modules_image()) {</span>
<span class="line-removed"> 261     name = ClassLoader::get_jrt_entry()-&gt;name();</span>
<span class="line-removed"> 262   } else {</span>
<span class="line-removed"> 263     name = this-&gt;name();</span>
<span class="line-removed"> 264   }</span>
 265 
 266   bool ok = true;
 267   log_info(class, path)(&quot;checking shared classpath entry: %s&quot;, name);
 268   if (os::stat(name, &amp;st) != 0 &amp;&amp; is_class_path) {
 269     // If the archived module path entry does not exist at runtime, it is not fatal
 270     // (no need to invalid the shared archive) because the shared runtime visibility check
 271     // filters out any archived module classes that do not have a matching runtime
 272     // module path location.
 273     FileMapInfo::fail_continue(&quot;Required classpath entry does not exist: %s&quot;, name);
 274     ok = false;
 275   } else if (is_dir()) {
 276     if (!os::dir_is_empty(name)) {
 277       FileMapInfo::fail_continue(&quot;directory is not empty: %s&quot;, name);
 278       ok = false;
 279     }
 280   } else if ((has_timestamp() &amp;&amp; _timestamp != st.st_mtime) ||
 281              _filesize != st.st_size) {
 282     ok = false;
 283     if (PrintSharedArchiveAndExit) {
 284       FileMapInfo::fail_continue(_timestamp != st.st_mtime ?
 285                                  &quot;Timestamp mismatch&quot; :
 286                                  &quot;File size mismatch&quot;);
 287     } else {
 288       FileMapInfo::fail_continue(&quot;A jar file is not the one used while building&quot;
 289                                  &quot; the shared archive file: %s&quot;, name);
 290     }
 291   }
 292 
 293   if (PrintSharedArchiveAndExit &amp;&amp; !ok) {
 294     // If PrintSharedArchiveAndExit is enabled, don&#39;t report failure to the
 295     // caller. Please see above comments for more details.
 296     ok = true;

 297   }
 298   return ok;
 299 }
 300 













 301 void SharedClassPathEntry::metaspace_pointers_do(MetaspaceClosure* it) {
 302   it-&gt;push(&amp;_name);
 303   it-&gt;push(&amp;_manifest);
 304 }
 305 




















 306 void FileMapInfo::allocate_shared_path_table() {
<span class="line-modified"> 307   assert(DumpSharedSpaces, &quot;Sanity&quot;);</span>
 308 
<span class="line-modified"> 309   Thread* THREAD = Thread::current();</span>
 310   ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
 311   ClassPathEntry* jrt = ClassLoader::get_jrt_entry();
 312 
 313   assert(jrt != NULL,
 314          &quot;No modular java runtime image present when allocating the CDS classpath entry table&quot;);
 315 
<span class="line-modified"> 316   size_t entry_size = sizeof(SharedClassPathEntry); // assert ( should be 8 byte aligned??)</span>
<span class="line-removed"> 317   int num_boot_classpath_entries = ClassLoader::num_boot_classpath_entries();</span>
<span class="line-removed"> 318   int num_app_classpath_entries = ClassLoader::num_app_classpath_entries();</span>
<span class="line-removed"> 319   int num_module_path_entries = ClassLoader::num_module_path_entries();</span>
<span class="line-removed"> 320   int num_entries = num_boot_classpath_entries + num_app_classpath_entries + num_module_path_entries;</span>
<span class="line-removed"> 321   size_t bytes = entry_size * num_entries;</span>
<span class="line-removed"> 322 </span>
<span class="line-removed"> 323   _shared_path_table = MetadataFactory::new_array&lt;u8&gt;(loader_data, (int)(bytes + 7 / 8), THREAD);</span>
<span class="line-removed"> 324   _shared_path_table_size = num_entries;</span>
<span class="line-removed"> 325   _shared_path_entry_size = entry_size;</span>
 326 
 327   // 1. boot class path
 328   int i = 0;
<span class="line-modified"> 329   ClassPathEntry* cpe = jrt;</span>












 330   while (cpe != NULL) {
<span class="line-modified"> 331     bool is_jrt = (cpe == jrt);</span>
 332     const char* type = (is_jrt ? &quot;jrt&quot; : (cpe-&gt;is_jar_file() ? &quot;jar&quot; : &quot;dir&quot;));
<span class="line-modified"> 333     log_info(class, path)(&quot;add main shared path (%s) %s&quot;, type, cpe-&gt;name());</span>
 334     SharedClassPathEntry* ent = shared_path(i);
<span class="line-modified"> 335     ent-&gt;init(cpe-&gt;name(), is_jrt, THREAD);</span>
<span class="line-modified"> 336     if (!is_jrt) {    // No need to do the modules image.</span>
<span class="line-modified"> 337       EXCEPTION_MARK; // The following call should never throw, but would exit VM on error.</span>
<span class="line-modified"> 338       update_shared_classpath(cpe, ent, THREAD);</span>




 339     }
<span class="line-removed"> 340     cpe = ClassLoader::get_next_boot_classpath_entry(cpe);</span>
<span class="line-removed"> 341     i++;</span>
<span class="line-removed"> 342   }</span>
<span class="line-removed"> 343   assert(i == num_boot_classpath_entries,</span>
<span class="line-removed"> 344          &quot;number of boot class path entry mismatch&quot;);</span>
<span class="line-removed"> 345 </span>
<span class="line-removed"> 346   // 2. app class path</span>
<span class="line-removed"> 347   ClassPathEntry *acpe = ClassLoader::app_classpath_entries();</span>
<span class="line-removed"> 348   while (acpe != NULL) {</span>
<span class="line-removed"> 349     log_info(class, path)(&quot;add app shared path %s&quot;, acpe-&gt;name());</span>
<span class="line-removed"> 350     SharedClassPathEntry* ent = shared_path(i);</span>
<span class="line-removed"> 351     ent-&gt;init(acpe-&gt;name(), false, THREAD);</span>
<span class="line-removed"> 352     EXCEPTION_MARK;</span>
<span class="line-removed"> 353     update_shared_classpath(acpe, ent, THREAD);</span>
<span class="line-removed"> 354     acpe = acpe-&gt;next();</span>
 355     i++;
 356   }
 357 
<span class="line-modified"> 358   // 3. module path</span>
<span class="line-removed"> 359   ClassPathEntry *mpe = ClassLoader::module_path_entries();</span>
<span class="line-removed"> 360   while (mpe != NULL) {</span>
<span class="line-removed"> 361     log_info(class, path)(&quot;add module path %s&quot;,mpe-&gt;name());</span>
<span class="line-removed"> 362     SharedClassPathEntry* ent = shared_path(i);</span>
<span class="line-removed"> 363     ent-&gt;init(mpe-&gt;name(), false, THREAD);</span>
<span class="line-removed"> 364     EXCEPTION_MARK;</span>
<span class="line-removed"> 365     update_shared_classpath(mpe, ent, THREAD);</span>
<span class="line-removed"> 366     mpe = mpe-&gt;next();</span>
<span class="line-removed"> 367     i++;</span>
<span class="line-removed"> 368   }</span>
<span class="line-removed"> 369   assert(i == num_entries, &quot;number of shared path entry mismatch&quot;);</span>
 370 }
 371 
 372 void FileMapInfo::check_nonempty_dir_in_shared_path_table() {
<span class="line-modified"> 373   assert(DumpSharedSpaces, &quot;dump time only&quot;);</span>
 374 
 375   bool has_nonempty_dir = false;
 376 
<span class="line-modified"> 377   int last = _shared_path_table_size - 1;</span>
 378   if (last &gt; ClassLoaderExt::max_used_path_index()) {
 379      // no need to check any path beyond max_used_path_index
 380      last = ClassLoaderExt::max_used_path_index();
 381   }
 382 
 383   for (int i = 0; i &lt;= last; i++) {
 384     SharedClassPathEntry *e = shared_path(i);
 385     if (e-&gt;is_dir()) {
 386       const char* path = e-&gt;name();
 387       if (!os::dir_is_empty(path)) {
<span class="line-modified"> 388         tty-&gt;print_cr(&quot;Error: non-empty directory &#39;%s&#39;&quot;, path);</span>
 389         has_nonempty_dir = true;
 390       }
 391     }
 392   }
 393 
 394   if (has_nonempty_dir) {
 395     ClassLoader::exit_with_path_failure(&quot;Cannot have non-empty directory in paths&quot;, NULL);
 396   }
 397 }
 398 


















 399 class ManifestStream: public ResourceObj {
 400   private:
 401   u1*   _buffer_start; // Buffer bottom
 402   u1*   _buffer_end;   // Buffer top (one past last element)
 403   u1*   _current;      // Current buffer position
 404 
 405  public:
 406   // Constructor
 407   ManifestStream(u1* buffer, int length) : _buffer_start(buffer),
 408                                            _current(buffer) {
 409     _buffer_end = buffer + length;
 410   }
 411 
 412   static bool is_attr(u1* attr, const char* name) {
 413     return strncmp((const char*)attr, name, strlen(name)) == 0;
 414   }
 415 
 416   static char* copy_attr(u1* value, size_t len) {
 417     char* buf = NEW_RESOURCE_ARRAY(char, len + 1);
 418     strncpy(buf, (char*)value, len);
</pre>
<hr />
<pre>
 427     while (_current &lt; _buffer_end) {
 428       if (*_current == &#39;\n&#39;) {
 429         *_current = &#39;\0&#39;;
 430         u1* value = (u1*)strchr((char*)attr, &#39;:&#39;);
 431         if (value != NULL) {
 432           assert(*(value+1) == &#39; &#39;, &quot;Unrecognized format&quot; );
 433           if (strstr((char*)attr, &quot;-Digest&quot;) != NULL) {
 434             isSigned = true;
 435             break;
 436           }
 437         }
 438         *_current = &#39;\n&#39;; // restore
 439         attr = _current + 1;
 440       }
 441       _current ++;
 442     }
 443     return isSigned;
 444   }
 445 };
 446 
<span class="line-modified"> 447 void FileMapInfo::update_shared_classpath(ClassPathEntry *cpe, SharedClassPathEntry* ent, TRAPS) {</span>
 448   ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
 449   ResourceMark rm(THREAD);
 450   jint manifest_size;
 451 
<span class="line-modified"> 452   if (cpe-&gt;is_jar_file()) {</span>
<span class="line-modified"> 453     assert(ent-&gt;is_jar(), &quot;the shared class path entry is not a JAR file&quot;);</span>
<span class="line-modified"> 454     char* manifest = ClassLoaderExt::read_manifest(cpe, &amp;manifest_size, CHECK);</span>
<span class="line-modified"> 455     if (manifest != NULL) {</span>
<span class="line-modified"> 456       ManifestStream* stream = new ManifestStream((u1*)manifest,</span>
<span class="line-modified"> 457                                                   manifest_size);</span>
<span class="line-modified"> 458       if (stream-&gt;check_is_signed()) {</span>
<span class="line-modified"> 459         ent-&gt;set_is_signed();</span>







































































































































 460       } else {
<span class="line-modified"> 461         // Copy the manifest into the shared archive</span>
<span class="line-modified"> 462         manifest = ClassLoaderExt::read_raw_manifest(cpe, &amp;manifest_size, CHECK);</span>
<span class="line-removed"> 463         Array&lt;u1&gt;* buf = MetadataFactory::new_array&lt;u1&gt;(loader_data,</span>
<span class="line-removed"> 464                                                         manifest_size,</span>
<span class="line-removed"> 465                                                         THREAD);</span>
<span class="line-removed"> 466         char* p = (char*)(buf-&gt;data());</span>
<span class="line-removed"> 467         memcpy(p, manifest, manifest_size);</span>
<span class="line-removed"> 468         ent-&gt;set_manifest(buf);</span>
 469       }









































 470     }
 471   }

 472 }
 473 













 474 
 475 bool FileMapInfo::validate_shared_path_table() {
 476   assert(UseSharedSpaces, &quot;runtime only&quot;);
 477 
 478   _validating_shared_path_table = true;
<span class="line-removed"> 479   _shared_path_table = _header-&gt;_shared_path_table;</span>
<span class="line-removed"> 480   _shared_path_entry_size = _header-&gt;_shared_path_entry_size;</span>
<span class="line-removed"> 481   _shared_path_table_size = _header-&gt;_shared_path_table_size;</span>
 482 
<span class="line-modified"> 483   int module_paths_start_index = _header-&gt;_app_module_paths_start_index;</span>



























 484 
 485   // validate the path entries up to the _max_used_path_index
<span class="line-modified"> 486   for (int i=0; i &lt; _header-&gt;_max_used_path_index + 1; i++) {</span>
 487     if (i &lt; module_paths_start_index) {
 488       if (shared_path(i)-&gt;validate()) {




 489         log_info(class, path)(&quot;ok&quot;);
 490       } else {
<span class="line-modified"> 491         assert(!UseSharedSpaces, &quot;UseSharedSpaces should be disabled&quot;);</span>


 492         return false;
 493       }
 494     } else if (i &gt;= module_paths_start_index) {
 495       if (shared_path(i)-&gt;validate(false /* not a class path entry */)) {
 496         log_info(class, path)(&quot;ok&quot;);
 497       } else {
<span class="line-modified"> 498         assert(!UseSharedSpaces, &quot;UseSharedSpaces should be disabled&quot;);</span>


 499         return false;
 500       }
 501     }
 502   }
 503 












 504   _validating_shared_path_table = false;
 505 
 506 #if INCLUDE_JVMTI
 507   if (_classpath_entries_for_jvmti != NULL) {
 508     os::free(_classpath_entries_for_jvmti);
 509   }
<span class="line-modified"> 510   size_t sz = sizeof(ClassPathEntry*) *  _shared_path_table_size;</span>
 511   _classpath_entries_for_jvmti = (ClassPathEntry**)os::malloc(sz, mtClass);
<span class="line-modified"> 512   memset(_classpath_entries_for_jvmti, 0, sz);</span>
 513 #endif
 514 
 515   return true;
 516 }
 517 





















































































































 518 // Read the FileMapInfo information from the file.
 519 
 520 bool FileMapInfo::init_from_file(int fd) {
<span class="line-modified"> 521   size_t sz = sizeof(FileMapHeader);</span>
<span class="line-modified"> 522   size_t n = os::read(fd, _header, (unsigned int)sz);</span>
 523   if (n != sz) {
 524     fail_continue(&quot;Unable to read the file header.&quot;);
 525     return false;
 526   }
<span class="line-modified"> 527   if (_header-&gt;_version != CURRENT_CDS_ARCHIVE_VERSION) {</span>
















 528     fail_continue(&quot;The shared archive file has the wrong version.&quot;);
 529     return false;
 530   }
<span class="line-removed"> 531   _file_offset = (long)n;</span>
 532 
<span class="line-modified"> 533   size_t info_size = _header-&gt;_paths_misc_info_size;</span>
<span class="line-modified"> 534   _paths_misc_info = NEW_C_HEAP_ARRAY_RETURN_NULL(char, info_size, mtClass);</span>
<span class="line-modified"> 535   if (_paths_misc_info == NULL) {</span>
<span class="line-modified"> 536     fail_continue(&quot;Unable to read the file header.&quot;);</span>
 537     return false;
 538   }
<span class="line-modified"> 539   n = os::read(fd, _paths_misc_info, (unsigned int)info_size);</span>
<span class="line-modified"> 540   if (n != info_size) {</span>
<span class="line-modified"> 541     fail_continue(&quot;Unable to read the shared path info header.&quot;);</span>
<span class="line-modified"> 542     FREE_C_HEAP_ARRAY(char, _paths_misc_info);</span>
<span class="line-modified"> 543     _paths_misc_info = NULL;</span>
 544     return false;
 545   }
 546 
<span class="line-modified"> 547   size_t len = lseek(fd, 0, SEEK_END);</span>
<span class="line-modified"> 548   CDSFileMapRegion* si = space_at(MetaspaceShared::last_valid_region);</span>
<span class="line-modified"> 549   // The last space might be empty</span>
<span class="line-modified"> 550   if (si-&gt;_file_offset &gt; len || len - si-&gt;_file_offset &lt; si-&gt;_used) {</span>
<span class="line-modified"> 551     fail_continue(&quot;The shared archive file has been truncated.&quot;);</span>


 552     return false;
 553   }
 554 
<span class="line-modified"> 555   _file_offset += (long)n;</span>
<span class="line-modified"> 556   SharedBaseAddress = _header-&gt;_shared_base_address;</span>






















 557   return true;
 558 }
 559 





 560 
 561 // Read the FileMapInfo information from the file.
 562 bool FileMapInfo::open_for_read() {
<span class="line-modified"> 563   _full_path = Arguments::GetSharedArchivePath();</span>







 564   int fd = os::open(_full_path, O_RDONLY | O_BINARY, 0);
 565   if (fd &lt; 0) {
 566     if (errno == ENOENT) {
<span class="line-modified"> 567       // Not locating the shared archive is ok.</span>
<span class="line-removed"> 568       fail_continue(&quot;Specified shared archive not found.&quot;);</span>
 569     } else {
 570       fail_continue(&quot;Failed to open shared archive file (%s).&quot;,
 571                     os::strerror(errno));
 572     }
 573     return false;
 574   }
 575 
 576   _fd = fd;
 577   _file_open = true;
 578   return true;
 579 }
 580 
<span class="line-removed"> 581 </span>
 582 // Write the FileMapInfo information to the file.
 583 
<span class="line-modified"> 584 void FileMapInfo::open_for_write() {</span>
<span class="line-modified"> 585   _full_path = Arguments::GetSharedArchivePath();</span>




 586   LogMessage(cds) msg;
 587   if (msg.is_info()) {
 588     msg.info(&quot;Dumping shared data to file: &quot;);
 589     msg.info(&quot;   %s&quot;, _full_path);
 590   }
 591 
 592 #ifdef _WINDOWS  // On Windows, need WRITE permission to remove the file.
<span class="line-modified"> 593   chmod(_full_path, _S_IREAD | _S_IWRITE);</span>
 594 #endif
 595 
 596   // Use remove() to delete the existing file because, on Unix, this will
 597   // allow processes that have it open continued access to the file.
 598   remove(_full_path);
 599   int fd = os::open(_full_path, O_RDWR | O_CREAT | O_TRUNC | O_BINARY, 0444);
 600   if (fd &lt; 0) {
 601     fail_stop(&quot;Unable to create shared archive file %s: (%s).&quot;, _full_path,
 602               os::strerror(errno));
 603   }
 604   _fd = fd;
<span class="line-removed"> 605   _file_offset = 0;</span>
 606   _file_open = true;











 607 }
 608 
 609 
 610 // Write the header to the file, seek to the next allocation boundary.
 611 
 612 void FileMapInfo::write_header() {
<span class="line-modified"> 613   int info_size = ClassLoader::get_shared_paths_misc_info_size();</span>







 614 
<span class="line-modified"> 615   _header-&gt;_paths_misc_info_size = info_size;</span>





 616 
<span class="line-modified"> 617   align_file_position();</span>
<span class="line-modified"> 618   write_bytes(_header, sizeof(FileMapHeader));</span>
<span class="line-removed"> 619   write_bytes(ClassLoader::get_shared_paths_misc_info(), (size_t)info_size);</span>
<span class="line-removed"> 620   align_file_position();</span>
 621 }
 622 





 623 
<span class="line-modified"> 624 // Dump region to file.</span>



















 625 
 626 void FileMapInfo::write_region(int region, char* base, size_t size,
 627                                bool read_only, bool allow_exec) {
<span class="line-modified"> 628   CDSFileMapRegion* si = space_at(region);</span>
 629 
<span class="line-modified"> 630   if (_file_open) {</span>
<span class="line-modified"> 631     guarantee(si-&gt;_file_offset == _file_offset, &quot;file offset mismatch.&quot;);</span>
<span class="line-modified"> 632     log_info(cds)(&quot;Shared file region %d: &quot; SIZE_FORMAT_HEX_W(08)</span>
<span class="line-modified"> 633                   &quot; bytes, addr &quot; INTPTR_FORMAT &quot; file offset &quot; SIZE_FORMAT_HEX_W(08),</span>
<span class="line-modified"> 634                   region, size, p2i(base), _file_offset);</span>
 635   } else {
<span class="line-modified"> 636     si-&gt;_file_offset = _file_offset;</span>
<span class="line-modified"> 637   }</span>
<span class="line-modified"> 638   if (HeapShared::is_heap_region(region)) {</span>
<span class="line-removed"> 639     assert((base - (char*)Universe::narrow_oop_base()) % HeapWordSize == 0, &quot;Sanity&quot;);</span>
<span class="line-removed"> 640     if (base != NULL) {</span>
<span class="line-removed"> 641       si-&gt;_addr._offset = (intx)CompressedOops::encode_not_null((oop)base);</span>
 642     } else {
<span class="line-modified"> 643       si-&gt;_addr._offset = 0;</span>
 644     }
<span class="line-removed"> 645   } else {</span>
<span class="line-removed"> 646     si-&gt;_addr._base = base;</span>
 647   }
<span class="line-modified"> 648   si-&gt;_used = size;</span>
<span class="line-modified"> 649   si-&gt;_read_only = read_only;</span>
<span class="line-modified"> 650   si-&gt;_allow_exec = allow_exec;</span>
<span class="line-modified"> 651   si-&gt;_crc = ClassLoader::crc32(0, base, (jint)size);</span>






 652   if (base != NULL) {
 653     write_bytes_aligned(base, size);
 654   }
 655 }
 656 














 657 // Write out the given archive heap memory regions.  GC code combines multiple
 658 // consecutive archive GC regions into one MemRegion whenever possible and
 659 // produces the &#39;heap_mem&#39; array.
 660 //
 661 // If the archive heap memory size is smaller than a single dump time GC region
 662 // size, there is only one MemRegion in the array.
 663 //
 664 // If the archive heap memory size is bigger than one dump time GC region size,
 665 // the &#39;heap_mem&#39; array may contain more than one consolidated MemRegions. When
 666 // the first/bottom archive GC region is a partial GC region (with the empty
 667 // portion at the higher address within the region), one MemRegion is used for
 668 // the bottom partial archive GC region. The rest of the consecutive archive
 669 // GC regions are combined into another MemRegion.
 670 //
 671 // Here&#39;s the mapping from (archive heap GC regions) -&gt; (GrowableArray&lt;MemRegion&gt; *regions).
 672 //   + We have 1 or more archive heap regions: ah0, ah1, ah2 ..... ahn
 673 //   + We have 1 or 2 consolidated heap memory regions: r0 and r1
 674 //
 675 // If there&#39;s a single archive GC region (ah0), then r0 == ah0, and r1 is empty.
 676 // Otherwise:
 677 //
 678 // &quot;X&quot; represented space that&#39;s occupied by heap objects.
 679 // &quot;_&quot; represented unused spaced in the heap region.
 680 //
 681 //
 682 //    |ah0       | ah1 | ah2| ...... | ahn|
 683 //    |XXXXXX|__ |XXXXX|XXXX|XXXXXXXX|XXXX|
 684 //    |&lt;-r0-&gt;|   |&lt;- r1 -----------------&gt;|
 685 //            ^^^
 686 //             |
 687 //             +-- gap
 688 size_t FileMapInfo::write_archive_heap_regions(GrowableArray&lt;MemRegion&gt; *heap_mem,
 689                                                GrowableArray&lt;ArchiveHeapOopmapInfo&gt; *oopmaps,
<span class="line-modified"> 690                                                int first_region_id, int max_num_regions,</span>
<span class="line-removed"> 691                                                bool print_log) {</span>
 692   assert(max_num_regions &lt;= 2, &quot;Only support maximum 2 memory regions&quot;);
 693 
 694   int arr_len = heap_mem == NULL ? 0 : heap_mem-&gt;length();
 695   if(arr_len &gt; max_num_regions) {
 696     fail_stop(&quot;Unable to write archive heap memory regions: &quot;
 697               &quot;number of memory regions exceeds maximum due to fragmentation. &quot;
 698               &quot;Please increase java heap size &quot;
 699               &quot;(current MaxHeapSize is &quot; SIZE_FORMAT &quot;, InitialHeapSize is &quot; SIZE_FORMAT &quot;).&quot;,
 700               MaxHeapSize, InitialHeapSize);
 701   }
 702 
 703   size_t total_size = 0;
 704   for (int i = first_region_id, arr_idx = 0;
 705            i &lt; first_region_id + max_num_regions;
 706            i++, arr_idx++) {
 707     char* start = NULL;
 708     size_t size = 0;
 709     if (arr_idx &lt; arr_len) {
 710       start = (char*)heap_mem-&gt;at(arr_idx).start();
 711       size = heap_mem-&gt;at(arr_idx).byte_size();
 712       total_size += size;
 713     }
 714 
<span class="line-modified"> 715     if (print_log) {</span>
<span class="line-modified"> 716       log_info(cds)(&quot;Archive heap region %d &quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot; = &quot; SIZE_FORMAT_W(8) &quot; bytes&quot;,</span>
<span class="line-removed"> 717                     i, p2i(start), p2i(start + size), size);</span>
<span class="line-removed"> 718     }</span>
 719     write_region(i, start, size, false, false);
 720     if (size &gt; 0) {
<span class="line-modified"> 721       space_at(i)-&gt;_oopmap = oopmaps-&gt;at(arr_idx)._oopmap;</span>
<span class="line-modified"> 722       space_at(i)-&gt;_oopmap_size_in_bits = oopmaps-&gt;at(arr_idx)._oopmap_size_in_bits;</span>


 723     }
 724   }
 725   return total_size;
 726 }
 727 
 728 // Dump bytes to file -- at the current file position.
 729 
 730 void FileMapInfo::write_bytes(const void* buffer, size_t nbytes) {
<span class="line-modified"> 731   if (_file_open) {</span>
<span class="line-modified"> 732     size_t n = os::write(_fd, buffer, (unsigned int)nbytes);</span>
<span class="line-modified"> 733     if (n != nbytes) {</span>
<span class="line-modified"> 734       // It is dangerous to leave the corrupted shared archive file around,</span>
<span class="line-modified"> 735       // close and remove the file. See bug 6372906.</span>
<span class="line-modified"> 736       close();</span>
<span class="line-modified"> 737       remove(_full_path);</span>
<span class="line-removed"> 738       fail_stop(&quot;Unable to write to shared archive file.&quot;);</span>
<span class="line-removed"> 739     }</span>
 740   }
 741   _file_offset += nbytes;
 742 }
 743 




 744 
 745 // Align file position to an allocation unit boundary.
 746 
 747 void FileMapInfo::align_file_position() {

 748   size_t new_file_offset = align_up(_file_offset,
<span class="line-modified"> 749                                          os::vm_allocation_granularity());</span>
 750   if (new_file_offset != _file_offset) {
 751     _file_offset = new_file_offset;
<span class="line-modified"> 752     if (_file_open) {</span>
<span class="line-modified"> 753       // Seek one byte back from the target and write a byte to insure</span>
<span class="line-modified"> 754       // that the written file is the correct length.</span>
<span class="line-modified"> 755       _file_offset -= 1;</span>
<span class="line-modified"> 756       if (lseek(_fd, (long)_file_offset, SEEK_SET) &lt; 0) {</span>
<span class="line-modified"> 757         fail_stop(&quot;Unable to seek.&quot;);</span>
<span class="line-removed"> 758       }</span>
<span class="line-removed"> 759       char zero = 0;</span>
<span class="line-removed"> 760       write_bytes(&amp;zero, 1);</span>
<span class="line-removed"> 761     }</span>
 762   }
 763 }
 764 
 765 
 766 // Dump bytes to file -- at the current file position.
 767 
 768 void FileMapInfo::write_bytes_aligned(const void* buffer, size_t nbytes) {
 769   align_file_position();
 770   write_bytes(buffer, nbytes);
 771   align_file_position();
 772 }
 773 



 774 
 775 // Close the shared archive file.  This does NOT unmap mapped regions.
 776 
 777 void FileMapInfo::close() {
 778   if (_file_open) {
 779     if (::close(_fd) &lt; 0) {
 780       fail_stop(&quot;Unable to close the shared archive file.&quot;);
 781     }
 782     _file_open = false;
 783     _fd = -1;
 784   }
 785 }
 786 
 787 
 788 // JVM/TI RedefineClasses() support:
 789 // Remap the shared readonly space to shared readwrite, private.
 790 bool FileMapInfo::remap_shared_readonly_as_readwrite() {
 791   int idx = MetaspaceShared::ro;
<span class="line-modified"> 792   CDSFileMapRegion* si = space_at(idx);</span>
<span class="line-modified"> 793   if (!si-&gt;_read_only) {</span>
 794     // the space is already readwrite so we are done
 795     return true;
 796   }
<span class="line-modified"> 797   size_t used = si-&gt;_used;</span>
 798   size_t size = align_up(used, os::vm_allocation_granularity());
 799   if (!open_for_read()) {
 800     return false;
 801   }
 802   char *addr = region_addr(idx);
<span class="line-modified"> 803   char *base = os::remap_memory(_fd, _full_path, si-&gt;_file_offset,</span>
 804                                 addr, size, false /* !read_only */,
<span class="line-modified"> 805                                 si-&gt;_allow_exec);</span>
 806   close();

 807   if (base == NULL) {
<span class="line-modified"> 808     fail_continue(&quot;Unable to remap shared readonly space (errno=%d).&quot;, errno);</span>
<span class="line-modified"> 809     return false;</span>
 810   }
 811   if (base != addr) {
<span class="line-modified"> 812     fail_continue(&quot;Unable to remap shared readonly space at required address.&quot;);</span>


























































 813     return false;
 814   }
<span class="line-removed"> 815   si-&gt;_read_only = false;</span>
 816   return true;
 817 }
 818 
<span class="line-modified"> 819 // Map the whole region at once, assumed to be allocated contiguously.</span>
<span class="line-modified"> 820 ReservedSpace FileMapInfo::reserve_shared_memory() {</span>
<span class="line-modified"> 821   char* requested_addr = region_addr(0);</span>
<span class="line-modified"> 822   size_t size = FileMapInfo::core_spaces_size();</span>














































 823 
<span class="line-removed"> 824   // Reserve the space first, then map otherwise map will go right over some</span>
<span class="line-removed"> 825   // other reserved memory (like the code cache).</span>
<span class="line-removed"> 826   ReservedSpace rs(size, os::vm_allocation_granularity(), false, requested_addr);</span>
 827   if (!rs.is_reserved()) {
<span class="line-modified"> 828     fail_continue(&quot;Unable to reserve shared space at required address &quot;</span>
<span class="line-modified"> 829                   INTPTR_FORMAT, p2i(requested_addr));</span>
<span class="line-modified"> 830     return rs;</span>


 831   }
<span class="line-removed"> 832   // the reserved virtual memory is for mapping class data sharing archive</span>
<span class="line-removed"> 833   MemTracker::record_virtual_memory_type((address)rs.base(), mtClassShared);</span>
 834 
<span class="line-modified"> 835   return rs;</span>




 836 }
 837 
<span class="line-modified"> 838 // Memory map a region in the address space.</span>
<span class="line-modified"> 839 static const char* shared_region_name[] = { &quot;MiscData&quot;, &quot;ReadWrite&quot;, &quot;ReadOnly&quot;, &quot;MiscCode&quot;, &quot;OptionalData&quot;,</span>
<span class="line-modified"> 840                                             &quot;String1&quot;, &quot;String2&quot;, &quot;OpenArchive1&quot;, &quot;OpenArchive2&quot; };</span>








 841 
<span class="line-modified"> 842 char* FileMapInfo::map_region(int i, char** top_ret) {</span>
<span class="line-modified"> 843   assert(!HeapShared::is_heap_region(i), &quot;sanity&quot;);</span>
<span class="line-modified"> 844   CDSFileMapRegion* si = space_at(i);</span>
<span class="line-modified"> 845   size_t used = si-&gt;_used;</span>
<span class="line-modified"> 846   size_t alignment = os::vm_allocation_granularity();</span>
<span class="line-removed"> 847   size_t size = align_up(used, alignment);</span>
<span class="line-removed"> 848   char *requested_addr = region_addr(i);</span>
<span class="line-removed"> 849 </span>
<span class="line-removed"> 850   // If a tool agent is in use (debugging enabled), we must map the address space RW</span>
<span class="line-removed"> 851   if (JvmtiExport::can_modify_any_class() || JvmtiExport::can_walk_any_space()) {</span>
<span class="line-removed"> 852     si-&gt;_read_only = false;</span>
<span class="line-removed"> 853   }</span>
<span class="line-removed"> 854 </span>
<span class="line-removed"> 855   // map the contents of the CDS archive in this memory</span>
<span class="line-removed"> 856   char *base = os::map_memory(_fd, _full_path, si-&gt;_file_offset,</span>
<span class="line-removed"> 857                               requested_addr, size, si-&gt;_read_only,</span>
<span class="line-removed"> 858                               si-&gt;_allow_exec);</span>
<span class="line-removed"> 859   if (base == NULL || base != requested_addr) {</span>
<span class="line-removed"> 860     fail_continue(&quot;Unable to map %s shared space at required address.&quot;, shared_region_name[i]);</span>
 861     return NULL;
 862   }
<span class="line-removed"> 863 #ifdef _WINDOWS</span>
<span class="line-removed"> 864   // This call is Windows-only because the memory_type gets recorded for the other platforms</span>
<span class="line-removed"> 865   // in method FileMapInfo::reserve_shared_memory(), which is not called on Windows.</span>
<span class="line-removed"> 866   MemTracker::record_virtual_memory_type((address)base, mtClassShared);</span>
<span class="line-removed"> 867 #endif</span>
 868 


 869 
<span class="line-modified"> 870   if (!verify_region_checksum(i)) {</span>
<span class="line-modified"> 871     return NULL;</span>





































 872   }

 873 
<span class="line-modified"> 874   *top_ret = base + size;</span>
<span class="line-modified"> 875   return base;</span>








 876 }
 877 
<span class="line-modified"> 878 address FileMapInfo::decode_start_address(CDSFileMapRegion* spc, bool with_current_oop_encoding_mode) {</span>



 879   if (with_current_oop_encoding_mode) {
<span class="line-modified"> 880     return (address)CompressedOops::decode_not_null(offset_of_space(spc));</span>
 881   } else {
<span class="line-modified"> 882     return (address)HeapShared::decode_from_archive(offset_of_space(spc));</span>
 883   }
 884 }
 885 
 886 static MemRegion *closed_archive_heap_ranges = NULL;
 887 static MemRegion *open_archive_heap_ranges = NULL;
 888 static int num_closed_archive_heap_ranges = 0;
 889 static int num_open_archive_heap_ranges = 0;
 890 
 891 #if INCLUDE_CDS_JAVA_HEAP
 892 bool FileMapInfo::has_heap_regions() {
<span class="line-modified"> 893   return (_header-&gt;_space[MetaspaceShared::first_closed_archive_heap_region]._used &gt; 0);</span>
 894 }
 895 
 896 // Returns the address range of the archived heap regions computed using the
 897 // current oop encoding mode. This range may be different than the one seen at
 898 // dump time due to encoding mode differences. The result is used in determining
 899 // if/how these regions should be relocated at run time.
 900 MemRegion FileMapInfo::get_heap_regions_range_with_current_oop_encoding_mode() {
 901   address start = (address) max_uintx;
 902   address end   = NULL;
 903 
 904   for (int i = MetaspaceShared::first_closed_archive_heap_region;
 905            i &lt;= MetaspaceShared::last_valid_region;
 906            i++) {
<span class="line-modified"> 907     CDSFileMapRegion* si = space_at(i);</span>
<span class="line-modified"> 908     size_t size = si-&gt;_used;</span>
 909     if (size &gt; 0) {
 910       address s = start_address_as_decoded_with_current_oop_encoding_mode(si);
 911       address e = s + size;
 912       if (start &gt; s) {
 913         start = s;
 914       }
 915       if (end &lt; e) {
 916         end = e;
 917       }
 918     }
 919   }
 920   assert(end != NULL, &quot;must have at least one used heap region&quot;);
 921   return MemRegion((HeapWord*)start, (HeapWord*)end);
 922 }
 923 
 924 //
 925 // Map the closed and open archive heap objects to the runtime java heap.
 926 //
 927 // The shared objects are mapped at (or close to ) the java heap top in
 928 // closed archive regions. The mapped objects contain no out-going
</pre>
<hr />
<pre>
 938 void FileMapInfo::map_heap_regions_impl() {
 939   if (!HeapShared::is_heap_object_archiving_allowed()) {
 940     log_info(cds)(&quot;CDS heap data is being ignored. UseG1GC, &quot;
 941                   &quot;UseCompressedOops and UseCompressedClassPointers are required.&quot;);
 942     return;
 943   }
 944 
 945   if (JvmtiExport::should_post_class_file_load_hook() &amp;&amp; JvmtiExport::has_early_class_hook_env()) {
 946     ShouldNotReachHere(); // CDS should have been disabled.
 947     // The archived objects are mapped at JVM start-up, but we don&#39;t know if
 948     // j.l.String or j.l.Class might be replaced by the ClassFileLoadHook,
 949     // which would make the archived String or mirror objects invalid. Let&#39;s be safe and not
 950     // use the archived objects. These 2 classes are loaded during the JVMTI &quot;early&quot; stage.
 951     //
 952     // If JvmtiExport::has_early_class_hook_env() is false, the classes of some objects
 953     // in the archived subgraphs may be replaced by the ClassFileLoadHook. But that&#39;s OK
 954     // because we won&#39;t install an archived object subgraph if the klass of any of the
 955     // referenced objects are replaced. See HeapShared::initialize_from_archived_subgraph().
 956   }
 957 
<span class="line-removed"> 958   MemRegion heap_reserved = Universe::heap()-&gt;reserved_region();</span>
<span class="line-removed"> 959 </span>
 960   log_info(cds)(&quot;CDS archive was created with max heap size = &quot; SIZE_FORMAT &quot;M, and the following configuration:&quot;,
 961                 max_heap_size()/M);
 962   log_info(cds)(&quot;    narrow_klass_base = &quot; PTR_FORMAT &quot;, narrow_klass_shift = %d&quot;,
 963                 p2i(narrow_klass_base()), narrow_klass_shift());
 964   log_info(cds)(&quot;    narrow_oop_mode = %d, narrow_oop_base = &quot; PTR_FORMAT &quot;, narrow_oop_shift = %d&quot;,
 965                 narrow_oop_mode(), p2i(narrow_oop_base()), narrow_oop_shift());
 966 
 967   log_info(cds)(&quot;The current max heap size = &quot; SIZE_FORMAT &quot;M, HeapRegion::GrainBytes = &quot; SIZE_FORMAT,
<span class="line-modified"> 968                 heap_reserved.byte_size()/M, HeapRegion::GrainBytes);</span>
 969   log_info(cds)(&quot;    narrow_klass_base = &quot; PTR_FORMAT &quot;, narrow_klass_shift = %d&quot;,
<span class="line-modified"> 970                 p2i(Universe::narrow_klass_base()), Universe::narrow_klass_shift());</span>
 971   log_info(cds)(&quot;    narrow_oop_mode = %d, narrow_oop_base = &quot; PTR_FORMAT &quot;, narrow_oop_shift = %d&quot;,
<span class="line-modified"> 972                 Universe::narrow_oop_mode(), p2i(Universe::narrow_oop_base()), Universe::narrow_oop_shift());</span>
 973 
<span class="line-modified"> 974   if (narrow_klass_base() != Universe::narrow_klass_base() ||</span>
<span class="line-modified"> 975       narrow_klass_shift() != Universe::narrow_klass_shift()) {</span>
 976     log_info(cds)(&quot;CDS heap data cannot be used because the archive was created with an incompatible narrow klass encoding mode.&quot;);
 977     return;
 978   }
 979 
<span class="line-modified"> 980   if (narrow_oop_mode() != Universe::narrow_oop_mode() ||</span>
<span class="line-modified"> 981       narrow_oop_base() != Universe::narrow_oop_base() ||</span>
<span class="line-modified"> 982       narrow_oop_shift() != Universe::narrow_oop_shift()) {</span>
 983     log_info(cds)(&quot;CDS heap data need to be relocated because the archive was created with an incompatible oop encoding mode.&quot;);
 984     _heap_pointers_need_patching = true;
 985   } else {
 986     MemRegion range = get_heap_regions_range_with_current_oop_encoding_mode();
<span class="line-modified"> 987     if (!heap_reserved.contains(range)) {</span>
 988       log_info(cds)(&quot;CDS heap data need to be relocated because&quot;);
 989       log_info(cds)(&quot;the desired range &quot; PTR_FORMAT &quot; - &quot;  PTR_FORMAT, p2i(range.start()), p2i(range.end()));
<span class="line-modified"> 990       log_info(cds)(&quot;is outside of the heap &quot; PTR_FORMAT &quot; - &quot;  PTR_FORMAT, p2i(heap_reserved.start()), p2i(heap_reserved.end()));</span>
 991       _heap_pointers_need_patching = true;
 992     }
 993   }
 994 
 995   ptrdiff_t delta = 0;
 996   if (_heap_pointers_need_patching) {
 997     //   dumptime heap end  ------------v
 998     //   [      |archived heap regions| ]         runtime heap end ------v
 999     //                                       [   |archived heap regions| ]
1000     //                                  |&lt;-----delta--------------------&gt;|
1001     //
1002     // At dump time, the archived heap regions were near the top of the heap.
1003     // At run time, they may not be inside the heap, so we move them so
1004     // that they are now near the top of the runtime time. This can be done by
1005     // the simple math of adding the delta as shown above.
<span class="line-modified">1006     address dumptime_heap_end = (address)_header-&gt;_heap_reserved.end();</span>
<span class="line-modified">1007     address runtime_heap_end = (address)heap_reserved.end();</span>
1008     delta = runtime_heap_end - dumptime_heap_end;
1009   }
1010 
1011   log_info(cds)(&quot;CDS heap data relocation delta = &quot; INTX_FORMAT &quot; bytes&quot;, delta);
1012   HeapShared::init_narrow_oop_decoding(narrow_oop_base() + delta, narrow_oop_shift());
1013 
<span class="line-modified">1014   CDSFileMapRegion* si = space_at(MetaspaceShared::first_closed_archive_heap_region);</span>
1015   address relocated_closed_heap_region_bottom = start_address_as_decoded_from_archive(si);
1016   if (!is_aligned(relocated_closed_heap_region_bottom, HeapRegion::GrainBytes)) {
1017     // Align the bottom of the closed archive heap regions at G1 region boundary.
1018     // This will avoid the situation where the highest open region and the lowest
1019     // closed region sharing the same G1 region. Otherwise we will fail to map the
1020     // open regions.
1021     size_t align = size_t(relocated_closed_heap_region_bottom) % HeapRegion::GrainBytes;
1022     delta -= align;
1023     log_info(cds)(&quot;CDS heap data need to be relocated lower by a further &quot; SIZE_FORMAT
1024                   &quot; bytes to &quot; INTX_FORMAT &quot; to be aligned with HeapRegion::GrainBytes&quot;,
1025                   align, delta);
1026     HeapShared::init_narrow_oop_decoding(narrow_oop_base() + delta, narrow_oop_shift());
1027     _heap_pointers_need_patching = true;
1028     relocated_closed_heap_region_bottom = start_address_as_decoded_from_archive(si);
1029   }
1030   assert(is_aligned(relocated_closed_heap_region_bottom, HeapRegion::GrainBytes),
1031          &quot;must be&quot;);
1032 
1033   // Map the closed_archive_heap regions, GC does not write into the regions.
1034   if (map_heap_data(&amp;closed_archive_heap_ranges,
</pre>
<hr />
<pre>
1048   }
1049 }
1050 
1051 void FileMapInfo::map_heap_regions() {
1052   if (has_heap_regions()) {
1053     map_heap_regions_impl();
1054   }
1055 
1056   if (!HeapShared::closed_archive_heap_region_mapped()) {
1057     assert(closed_archive_heap_ranges == NULL &amp;&amp;
1058            num_closed_archive_heap_ranges == 0, &quot;sanity&quot;);
1059   }
1060 
1061   if (!HeapShared::open_archive_heap_region_mapped()) {
1062     assert(open_archive_heap_ranges == NULL &amp;&amp; num_open_archive_heap_ranges == 0, &quot;sanity&quot;);
1063   }
1064 }
1065 
1066 bool FileMapInfo::map_heap_data(MemRegion **heap_mem, int first,
1067                                 int max, int* num, bool is_open_archive) {
<span class="line-modified">1068   MemRegion * regions = new MemRegion[max];</span>
<span class="line-modified">1069   CDSFileMapRegion* si;</span>








1070   int region_num = 0;
1071 
1072   for (int i = first;
1073            i &lt; first + max; i++) {
1074     si = space_at(i);
<span class="line-modified">1075     size_t size = si-&gt;_used;</span>
1076     if (size &gt; 0) {
1077       HeapWord* start = (HeapWord*)start_address_as_decoded_from_archive(si);
1078       regions[region_num] = MemRegion(start, size / HeapWordSize);
1079       region_num ++;
1080       log_info(cds)(&quot;Trying to map heap data: region[%d] at &quot; INTPTR_FORMAT &quot;, size = &quot; SIZE_FORMAT_W(8) &quot; bytes&quot;,
1081                     i, p2i(start), size);
1082     }
1083   }
1084 
1085   if (region_num == 0) {
1086     return false; // no archived java heap data
1087   }
1088 
1089   // Check that ranges are within the java heap
1090   if (!G1CollectedHeap::heap()-&gt;check_archive_addresses(regions, region_num)) {
1091     log_info(cds)(&quot;UseSharedSpaces: Unable to allocate region, range is not within java heap.&quot;);
1092     return false;
1093   }
1094 
1095   // allocate from java heap
1096   if (!G1CollectedHeap::heap()-&gt;alloc_archive_regions(
1097              regions, region_num, is_open_archive)) {
1098     log_info(cds)(&quot;UseSharedSpaces: Unable to allocate region, java heap range is already in use.&quot;);
1099     return false;
1100   }
1101 
1102   // Map the archived heap data. No need to call MemTracker::record_virtual_memory_type()
1103   // for mapped regions as they are part of the reserved java heap, which is
1104   // already recorded.
1105   for (int i = 0; i &lt; region_num; i++) {
1106     si = space_at(first + i);
1107     char* addr = (char*)regions[i].start();
<span class="line-modified">1108     char* base = os::map_memory(_fd, _full_path, si-&gt;_file_offset,</span>
<span class="line-modified">1109                                 addr, regions[i].byte_size(), si-&gt;_read_only,</span>
<span class="line-modified">1110                                 si-&gt;_allow_exec);</span>
1111     if (base == NULL || base != addr) {
1112       // dealloc the regions from java heap
<span class="line-modified">1113       dealloc_archive_heap_regions(regions, region_num, is_open_archive);</span>
1114       log_info(cds)(&quot;UseSharedSpaces: Unable to map at required address in java heap. &quot;
1115                     INTPTR_FORMAT &quot;, size = &quot; SIZE_FORMAT &quot; bytes&quot;,
1116                     p2i(addr), regions[i].byte_size());
1117       return false;
1118     }
<span class="line-removed">1119   }</span>
1120 
<span class="line-modified">1121   if (!verify_mapped_heap_regions(first, region_num)) {</span>
<span class="line-modified">1122     // dealloc the regions from java heap</span>
<span class="line-modified">1123     dealloc_archive_heap_regions(regions, region_num, is_open_archive);</span>
<span class="line-modified">1124     log_info(cds)(&quot;UseSharedSpaces: mapped heap regions are corrupt&quot;);</span>
<span class="line-modified">1125     return false;</span>

1126   }
1127 

1128   // the shared heap data is mapped successfully
1129   *heap_mem = regions;
1130   *num = region_num;
1131   return true;
1132 }
1133 
<span class="line-removed">1134 bool FileMapInfo::verify_mapped_heap_regions(int first, int num) {</span>
<span class="line-removed">1135   assert(num &gt; 0, &quot;sanity&quot;);</span>
<span class="line-removed">1136   for (int i = first; i &lt; first + num; i++) {</span>
<span class="line-removed">1137     if (!verify_region_checksum(i)) {</span>
<span class="line-removed">1138       return false;</span>
<span class="line-removed">1139     }</span>
<span class="line-removed">1140   }</span>
<span class="line-removed">1141   return true;</span>
<span class="line-removed">1142 }</span>
<span class="line-removed">1143 </span>
1144 void FileMapInfo::patch_archived_heap_embedded_pointers() {
1145   if (!_heap_pointers_need_patching) {
1146     return;
1147   }
1148 
1149   patch_archived_heap_embedded_pointers(closed_archive_heap_ranges,
1150                                         num_closed_archive_heap_ranges,
1151                                         MetaspaceShared::first_closed_archive_heap_region);
1152 
1153   patch_archived_heap_embedded_pointers(open_archive_heap_ranges,
1154                                         num_open_archive_heap_ranges,
1155                                         MetaspaceShared::first_open_archive_heap_region);
1156 }
1157 
1158 void FileMapInfo::patch_archived_heap_embedded_pointers(MemRegion* ranges, int num_ranges,
1159                                                         int first_region_idx) {
1160   for (int i=0; i&lt;num_ranges; i++) {
<span class="line-modified">1161     CDSFileMapRegion* si = space_at(i + first_region_idx);</span>
<span class="line-modified">1162     HeapShared::patch_archived_heap_embedded_pointers(ranges[i], (address)si-&gt;_oopmap,</span>
<span class="line-modified">1163                                                       si-&gt;_oopmap_size_in_bits);</span>
1164   }
1165 }
1166 
1167 // This internally allocates objects using SystemDictionary::Object_klass(), so it
1168 // must be called after the well-known classes are resolved.
1169 void FileMapInfo::fixup_mapped_heap_regions() {
1170   // If any closed regions were found, call the fill routine to make them parseable.
1171   // Note that closed_archive_heap_ranges may be non-NULL even if no ranges were found.
1172   if (num_closed_archive_heap_ranges != 0) {
1173     assert(closed_archive_heap_ranges != NULL,
1174            &quot;Null closed_archive_heap_ranges array with non-zero count&quot;);
1175     G1CollectedHeap::heap()-&gt;fill_archive_regions(closed_archive_heap_ranges,
1176                                                   num_closed_archive_heap_ranges);
1177   }
1178 
1179   // do the same for mapped open archive heap regions
1180   if (num_open_archive_heap_ranges != 0) {
1181     assert(open_archive_heap_ranges != NULL, &quot;NULL open_archive_heap_ranges array with non-zero count&quot;);
1182     G1CollectedHeap::heap()-&gt;fill_archive_regions(open_archive_heap_ranges,
1183                                                   num_open_archive_heap_ranges);
1184   }
1185 }
1186 
1187 // dealloc the archive regions from java heap
<span class="line-modified">1188 void FileMapInfo::dealloc_archive_heap_regions(MemRegion* regions, int num, bool is_open) {</span>
1189   if (num &gt; 0) {
1190     assert(regions != NULL, &quot;Null archive ranges array with non-zero count&quot;);
<span class="line-modified">1191     G1CollectedHeap::heap()-&gt;dealloc_archive_regions(regions, num, is_open);</span>
1192   }
1193 }
1194 #endif // INCLUDE_CDS_JAVA_HEAP
1195 
<span class="line-modified">1196 bool FileMapInfo::verify_region_checksum(int i) {</span>
<span class="line-modified">1197   if (!VerifySharedSpaces) {</span>
<span class="line-modified">1198     return true;</span>


1199   }


1200 
<span class="line-modified">1201   size_t sz = space_at(i)-&gt;_used;</span>


1202 
1203   if (sz == 0) {
1204     return true; // no data


1205   }
<span class="line-modified">1206   if ((HeapShared::is_closed_archive_heap_region(i) &amp;&amp;</span>
<span class="line-modified">1207        !HeapShared::closed_archive_heap_region_mapped()) ||</span>
<span class="line-modified">1208       (HeapShared::is_open_archive_heap_region(i) &amp;&amp;</span>
<span class="line-modified">1209        !HeapShared::open_archive_heap_region_mapped())) {</span>
<span class="line-modified">1210     return true; // archived heap data is not mapped</span>
<span class="line-modified">1211   }</span>
<span class="line-removed">1212   const char* buf = region_addr(i);</span>
<span class="line-removed">1213   int crc = ClassLoader::crc32(0, buf, (jint)sz);</span>
<span class="line-removed">1214   if (crc != space_at(i)-&gt;_crc) {</span>
<span class="line-removed">1215     fail_continue(&quot;Checksum verification failed.&quot;);</span>
<span class="line-removed">1216     return false;</span>
1217   }
<span class="line-removed">1218   return true;</span>
1219 }
1220 
1221 // Unmap a memory region in the address space.
1222 
1223 void FileMapInfo::unmap_region(int i) {
1224   assert(!HeapShared::is_heap_region(i), &quot;sanity&quot;);
<span class="line-modified">1225   CDSFileMapRegion* si = space_at(i);</span>
<span class="line-modified">1226   size_t used = si-&gt;_used;</span>

1227   size_t size = align_up(used, os::vm_allocation_granularity());
1228 
<span class="line-modified">1229   if (used == 0) {</span>
<span class="line-modified">1230     return;</span>
<span class="line-modified">1231   }</span>
<span class="line-modified">1232 </span>
<span class="line-modified">1233   char* addr = region_addr(i);</span>
<span class="line-modified">1234   if (!os::unmap_memory(addr, size)) {</span>
<span class="line-modified">1235     fail_stop(&quot;Unable to unmap shared space.&quot;);</span>
1236   }
1237 }
1238 
1239 void FileMapInfo::assert_mark(bool check) {
1240   if (!check) {
1241     fail_stop(&quot;Mark mismatch while restoring from shared file.&quot;);
1242   }
1243 }
1244 
1245 void FileMapInfo::metaspace_pointers_do(MetaspaceClosure* it) {
<span class="line-modified">1246   it-&gt;push(&amp;_shared_path_table);</span>
<span class="line-removed">1247   for (int i=0; i&lt;_shared_path_table_size; i++) {</span>
<span class="line-removed">1248     shared_path(i)-&gt;metaspace_pointers_do(it);</span>
<span class="line-removed">1249   }</span>
1250 }
1251 
<span class="line-removed">1252 </span>
1253 FileMapInfo* FileMapInfo::_current_info = NULL;

1254 bool FileMapInfo::_heap_pointers_need_patching = false;
<span class="line-modified">1255 Array&lt;u8&gt;* FileMapInfo::_shared_path_table = NULL;</span>
<span class="line-removed">1256 int FileMapInfo::_shared_path_table_size = 0;</span>
<span class="line-removed">1257 size_t FileMapInfo::_shared_path_entry_size = 0x1234baad;</span>
1258 bool FileMapInfo::_validating_shared_path_table = false;


1259 
1260 // Open the shared archive file, read and validate the header
1261 // information (version, boot classpath, etc.).  If initialization
1262 // fails, shared spaces are disabled and the file is closed. [See
1263 // fail_continue.]
1264 //
1265 // Validation of the archive is done in two steps:
1266 //
<span class="line-modified">1267 // [1] validate_header() - done here. This checks the header, including _paths_misc_info.</span>
1268 // [2] validate_shared_path_table - this is done later, because the table is in the RW
1269 //     region of the archive, which is not mapped yet.
1270 bool FileMapInfo::initialize() {
1271   assert(UseSharedSpaces, &quot;UseSharedSpaces expected.&quot;);
1272 
1273   if (JvmtiExport::should_post_class_file_load_hook() &amp;&amp; JvmtiExport::has_early_class_hook_env()) {
1274     // CDS assumes that no classes resolved in SystemDictionary::resolve_well_known_classes
1275     // are replaced at runtime by JVMTI ClassFileLoadHook. All of those classes are resolved
1276     // during the JVMTI &quot;early&quot; stage, so we can still use CDS if
1277     // JvmtiExport::has_early_class_hook_env() is false.
1278     FileMapInfo::fail_continue(&quot;CDS is disabled because early JVMTI ClassFileLoadHook is in use.&quot;);
1279     return false;
1280   }
1281 
1282   if (!open_for_read()) {
1283     return false;
1284   }
<span class="line-modified">1285 </span>
<span class="line-modified">1286   init_from_file(_fd);</span>

1287   if (!validate_header()) {
1288     return false;
1289   }
1290   return true;
1291 }
1292 
1293 char* FileMapInfo::region_addr(int idx) {
<span class="line-modified">1294   CDSFileMapRegion* si = space_at(idx);</span>
1295   if (HeapShared::is_heap_region(idx)) {
1296     assert(DumpSharedSpaces, &quot;The following doesn&#39;t work at runtime&quot;);
<span class="line-modified">1297     return si-&gt;_used &gt; 0 ?</span>
1298           (char*)start_address_as_decoded_with_current_oop_encoding_mode(si) : NULL;
1299   } else {
<span class="line-modified">1300     return si-&gt;_addr._base;</span>
1301   }
1302 }
1303 









1304 int FileMapHeader::compute_crc() {
1305   char* start = (char*)this;
1306   // start computing from the field after _crc
1307   char* buf = (char*)&amp;_crc + sizeof(_crc);
<span class="line-modified">1308   size_t sz = sizeof(FileMapHeader) - (buf - start);</span>
1309   int crc = ClassLoader::crc32(0, buf, (jint)sz);
1310   return crc;
1311 }
1312 
1313 // This function should only be called during run time with UseSharedSpaces enabled.
1314 bool FileMapHeader::validate() {
<span class="line-removed">1315   if (VerifySharedSpaces &amp;&amp; compute_crc() != _crc) {</span>
<span class="line-removed">1316     FileMapInfo::fail_continue(&quot;Header checksum verification failed.&quot;);</span>
<span class="line-removed">1317     return false;</span>
<span class="line-removed">1318   }</span>
<span class="line-removed">1319 </span>
<span class="line-removed">1320   if (!Arguments::has_jimage()) {</span>
<span class="line-removed">1321     FileMapInfo::fail_continue(&quot;The shared archive file cannot be used with an exploded module build.&quot;);</span>
<span class="line-removed">1322     return false;</span>
<span class="line-removed">1323   }</span>
<span class="line-removed">1324 </span>
<span class="line-removed">1325   if (_version != CURRENT_CDS_ARCHIVE_VERSION) {</span>
<span class="line-removed">1326     FileMapInfo::fail_continue(&quot;The shared archive file is the wrong version.&quot;);</span>
<span class="line-removed">1327     return false;</span>
<span class="line-removed">1328   }</span>
<span class="line-removed">1329   if (_magic != CDS_ARCHIVE_MAGIC) {</span>
<span class="line-removed">1330     FileMapInfo::fail_continue(&quot;The shared archive file has a bad magic number.&quot;);</span>
<span class="line-removed">1331     return false;</span>
<span class="line-removed">1332   }</span>
<span class="line-removed">1333   char header_version[JVM_IDENT_MAX];</span>
<span class="line-removed">1334   get_header_version(header_version);</span>
<span class="line-removed">1335   if (strncmp(_jvm_ident, header_version, JVM_IDENT_MAX-1) != 0) {</span>
<span class="line-removed">1336     log_info(class, path)(&quot;expected: %s&quot;, header_version);</span>
<span class="line-removed">1337     log_info(class, path)(&quot;actual:   %s&quot;, _jvm_ident);</span>
<span class="line-removed">1338     FileMapInfo::fail_continue(&quot;The shared archive file was created by a different&quot;</span>
<span class="line-removed">1339                   &quot; version or build of HotSpot&quot;);</span>
<span class="line-removed">1340     return false;</span>
<span class="line-removed">1341   }</span>
1342   if (_obj_alignment != ObjectAlignmentInBytes) {
1343     FileMapInfo::fail_continue(&quot;The shared archive file&#39;s ObjectAlignmentInBytes of %d&quot;
1344                   &quot; does not equal the current ObjectAlignmentInBytes of &quot; INTX_FORMAT &quot;.&quot;,
1345                   _obj_alignment, ObjectAlignmentInBytes);
1346     return false;
1347   }
1348   if (_compact_strings != CompactStrings) {
1349     FileMapInfo::fail_continue(&quot;The shared archive file&#39;s CompactStrings setting (%s)&quot;
1350                   &quot; does not equal the current CompactStrings setting (%s).&quot;,
1351                   _compact_strings ? &quot;enabled&quot; : &quot;disabled&quot;,
1352                   CompactStrings   ? &quot;enabled&quot; : &quot;disabled&quot;);
1353     return false;
1354   }
1355 
1356   // This must be done after header validation because it might change the
1357   // header data
1358   const char* prop = Arguments::get_property(&quot;java.system.class.loader&quot;);
1359   if (prop != NULL) {
1360     warning(&quot;Archived non-system classes are disabled because the &quot;
1361             &quot;java.system.class.loader property is specified (value = \&quot;%s\&quot;). &quot;
</pre>
<hr />
<pre>
1371     FileMapInfo::fail_continue(&quot;The shared archive file was created with less restrictive &quot;
1372                   &quot;verification setting than the current setting.&quot;);
1373     return false;
1374   }
1375 
1376   // Java agents are allowed during run time. Therefore, the following condition is not
1377   // checked: (!_allow_archiving_with_java_agent &amp;&amp; AllowArchivingWithJavaAgent)
1378   // Note: _allow_archiving_with_java_agent is set in the shared archive during dump time
1379   // while AllowArchivingWithJavaAgent is set during the current run.
1380   if (_allow_archiving_with_java_agent &amp;&amp; !AllowArchivingWithJavaAgent) {
1381     FileMapInfo::fail_continue(&quot;The setting of the AllowArchivingWithJavaAgent is different &quot;
1382                                &quot;from the setting in the shared archive.&quot;);
1383     return false;
1384   }
1385 
1386   if (_allow_archiving_with_java_agent) {
1387     warning(&quot;This archive was created with AllowArchivingWithJavaAgent. It should be used &quot;
1388             &quot;for testing purposes only and should not be used in a production environment&quot;);
1389   }
1390 








1391   return true;
1392 }
1393 
1394 bool FileMapInfo::validate_header() {
<span class="line-modified">1395   bool status = _header-&gt;validate();</span>
<span class="line-removed">1396 </span>
<span class="line-removed">1397   if (status) {</span>
<span class="line-removed">1398     if (!ClassLoader::check_shared_paths_misc_info(_paths_misc_info, _header-&gt;_paths_misc_info_size)) {</span>
<span class="line-removed">1399       if (!PrintSharedArchiveAndExit) {</span>
<span class="line-removed">1400         fail_continue(&quot;shared class paths mismatch (hint: enable -Xlog:class+path=info to diagnose the failure)&quot;);</span>
<span class="line-removed">1401         status = false;</span>
<span class="line-removed">1402       }</span>
<span class="line-removed">1403     }</span>
<span class="line-removed">1404   }</span>
<span class="line-removed">1405 </span>
<span class="line-removed">1406   if (_paths_misc_info != NULL) {</span>
<span class="line-removed">1407     FREE_C_HEAP_ARRAY(char, _paths_misc_info);</span>
<span class="line-removed">1408     _paths_misc_info = NULL;</span>
<span class="line-removed">1409   }</span>
<span class="line-removed">1410   return status;</span>
1411 }
1412 
1413 // Check if a given address is within one of the shared regions
1414 bool FileMapInfo::is_in_shared_region(const void* p, int idx) {
1415   assert(idx == MetaspaceShared::ro ||
1416          idx == MetaspaceShared::rw ||
<span class="line-modified">1417          idx == MetaspaceShared::mc ||</span>
<span class="line-removed">1418          idx == MetaspaceShared::md, &quot;invalid region index&quot;);</span>
1419   char* base = region_addr(idx);
<span class="line-modified">1420   if (p &gt;= base &amp;&amp; p &lt; base + space_at(idx)-&gt;_used) {</span>
1421     return true;
1422   }
1423   return false;
1424 }
1425 
1426 // Unmap mapped regions of shared space.
1427 void FileMapInfo::stop_sharing_and_unmap(const char* msg) {
<span class="line-modified">1428   MetaspaceObj::set_shared_metaspace_range(NULL, NULL);</span>
1429 
1430   FileMapInfo *map_info = FileMapInfo::current_info();
1431   if (map_info) {
1432     map_info-&gt;fail_continue(&quot;%s&quot;, msg);
1433     for (int i = 0; i &lt; MetaspaceShared::num_non_heap_spaces; i++) {
1434       if (!HeapShared::is_heap_region(i)) {
<span class="line-modified">1435         char *addr = map_info-&gt;region_addr(i);</span>
<span class="line-removed">1436         if (addr != NULL) {</span>
<span class="line-removed">1437           map_info-&gt;unmap_region(i);</span>
<span class="line-removed">1438           map_info-&gt;space_at(i)-&gt;_addr._base = NULL;</span>
<span class="line-removed">1439         }</span>
1440       }
1441     }
1442     // Dealloc the archive heap regions only without unmapping. The regions are part
1443     // of the java heap. Unmapping of the heap regions are managed by GC.
1444     map_info-&gt;dealloc_archive_heap_regions(open_archive_heap_ranges,
<span class="line-modified">1445                                            num_open_archive_heap_ranges,</span>
<span class="line-removed">1446                                            true);</span>
1447     map_info-&gt;dealloc_archive_heap_regions(closed_archive_heap_ranges,
<span class="line-modified">1448                                            num_closed_archive_heap_ranges,</span>
<span class="line-removed">1449                                            false);</span>
1450   } else if (DumpSharedSpaces) {
1451     fail_stop(&quot;%s&quot;, msg);
1452   }
1453 }
1454 
1455 #if INCLUDE_JVMTI
1456 ClassPathEntry** FileMapInfo::_classpath_entries_for_jvmti = NULL;
1457 
1458 ClassPathEntry* FileMapInfo::get_classpath_entry_for_jvmti(int i, TRAPS) {
1459   ClassPathEntry* ent = _classpath_entries_for_jvmti[i];
1460   if (ent == NULL) {
1461     if (i == 0) {
<span class="line-modified">1462       ent = ClassLoader:: get_jrt_entry();</span>
1463       assert(ent != NULL, &quot;must be&quot;);
1464     } else {
1465       SharedClassPathEntry* scpe = shared_path(i);
1466       assert(scpe-&gt;is_jar(), &quot;must be&quot;); // other types of scpe will not produce archived classes
1467 
1468       const char* path = scpe-&gt;name();
1469       struct stat st;
1470       if (os::stat(path, &amp;st) != 0) {
1471         char *msg = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, strlen(path) + 128); ;
1472         jio_snprintf(msg, strlen(path) + 127, &quot;error in opening JAR file %s&quot;, path);
1473         THROW_MSG_(vmSymbols::java_io_IOException(), msg, NULL);
1474       } else {
<span class="line-modified">1475         ent = ClassLoader::create_class_path_entry(path, &amp;st, /*throw_exception=*/true, false, CHECK_NULL);</span>
1476       }
1477     }
1478 
<span class="line-modified">1479     MutexLocker mu(CDSClassFileStream_lock, THREAD);</span>
1480     if (_classpath_entries_for_jvmti[i] == NULL) {
1481       _classpath_entries_for_jvmti[i] = ent;
1482     } else {
1483       // Another thread has beat me to creating this entry
1484       delete ent;
1485       ent = _classpath_entries_for_jvmti[i];
1486     }
1487   }
1488 
1489   return ent;
1490 }
1491 
<span class="line-modified">1492 ClassFileStream* FileMapInfo::open_stream_for_jvmti(InstanceKlass* ik, TRAPS) {</span>
1493   int path_index = ik-&gt;shared_classpath_index();
1494   assert(path_index &gt;= 0, &quot;should be called for shared built-in classes only&quot;);
<span class="line-modified">1495   assert(path_index &lt; (int)_shared_path_table_size, &quot;sanity&quot;);</span>
1496 
1497   ClassPathEntry* cpe = get_classpath_entry_for_jvmti(path_index, CHECK_NULL);
1498   assert(cpe != NULL, &quot;must be&quot;);
1499 
1500   Symbol* name = ik-&gt;name();
1501   const char* const class_name = name-&gt;as_C_string();
1502   const char* const file_name = ClassLoader::file_name_for_class_name(class_name,
1503                                                                       name-&gt;utf8_length());
<span class="line-modified">1504   return cpe-&gt;open_stream(file_name, THREAD);</span>





1505 }
1506 
1507 #endif
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
<span class="line-added">  27 #include &quot;classfile/classFileStream.hpp&quot;</span>
  28 #include &quot;classfile/classLoader.inline.hpp&quot;
<span class="line-added">  29 #include &quot;classfile/classLoaderData.inline.hpp&quot;</span>
  30 #include &quot;classfile/classLoaderExt.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  33 #include &quot;classfile/altHashing.hpp&quot;
  34 #include &quot;logging/log.hpp&quot;
  35 #include &quot;logging/logStream.hpp&quot;
  36 #include &quot;logging/logMessage.hpp&quot;
<span class="line-added">  37 #include &quot;memory/archiveUtils.inline.hpp&quot;</span>
<span class="line-added">  38 #include &quot;memory/dynamicArchive.hpp&quot;</span>
  39 #include &quot;memory/filemap.hpp&quot;
  40 #include &quot;memory/heapShared.inline.hpp&quot;
  41 #include &quot;memory/iterator.inline.hpp&quot;
  42 #include &quot;memory/metadataFactory.hpp&quot;
  43 #include &quot;memory/metaspaceClosure.hpp&quot;
  44 #include &quot;memory/metaspaceShared.hpp&quot;
  45 #include &quot;memory/oopFactory.hpp&quot;
<span class="line-added">  46 #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added">  47 #include &quot;oops/compressedOops.hpp&quot;</span>
  48 #include &quot;oops/compressedOops.inline.hpp&quot;
  49 #include &quot;oops/objArrayOop.hpp&quot;
  50 #include &quot;oops/oop.inline.hpp&quot;
  51 #include &quot;prims/jvmtiExport.hpp&quot;
  52 #include &quot;runtime/arguments.hpp&quot;
  53 #include &quot;runtime/java.hpp&quot;
  54 #include &quot;runtime/mutexLocker.hpp&quot;
  55 #include &quot;runtime/os.inline.hpp&quot;
  56 #include &quot;runtime/vm_version.hpp&quot;
  57 #include &quot;services/memTracker.hpp&quot;
  58 #include &quot;utilities/align.hpp&quot;
<span class="line-added">  59 #include &quot;utilities/bitMap.inline.hpp&quot;</span>
<span class="line-added">  60 #include &quot;utilities/classpathStream.hpp&quot;</span>
  61 #include &quot;utilities/defaultStream.hpp&quot;
  62 #if INCLUDE_G1GC
  63 #include &quot;gc/g1/g1CollectedHeap.hpp&quot;
  64 #include &quot;gc/g1/heapRegion.hpp&quot;
  65 #endif
  66 
  67 # include &lt;sys/stat.h&gt;
  68 # include &lt;errno.h&gt;
  69 
  70 #ifndef O_BINARY       // if defined (Win32) use binary files.
  71 #define O_BINARY 0     // otherwise do nothing.
  72 #endif
  73 



  74 // Complain and stop. All error conditions occurring during the writing of
  75 // an archive file should stop the process.  Unrecoverable errors during
  76 // the reading of the archive file should stop the process.
  77 
<span class="line-modified">  78 static void fail_exit(const char *msg, va_list ap) {</span>
  79   // This occurs very early during initialization: tty is not initialized.
  80   jio_fprintf(defaultStream::error_stream(),
  81               &quot;An error has occurred while processing the&quot;
  82               &quot; shared archive file.\n&quot;);
  83   jio_vfprintf(defaultStream::error_stream(), msg, ap);
  84   jio_fprintf(defaultStream::error_stream(), &quot;\n&quot;);
  85   // Do not change the text of the below message because some tests check for it.
  86   vm_exit_during_initialization(&quot;Unable to use shared archive.&quot;, NULL);
  87 }
  88 
  89 
  90 void FileMapInfo::fail_stop(const char *msg, ...) {
  91         va_list ap;
  92   va_start(ap, msg);
<span class="line-modified">  93   fail_exit(msg, ap);   // Never returns.</span>
  94   va_end(ap);           // for completeness.
  95 }
  96 
  97 
  98 // Complain and continue.  Recoverable errors during the reading of the
  99 // archive file may continue (with sharing disabled).
 100 //
 101 // If we continue, then disable shared spaces and close the file.
 102 
 103 void FileMapInfo::fail_continue(const char *msg, ...) {
 104   va_list ap;
 105   va_start(ap, msg);

 106   if (PrintSharedArchiveAndExit &amp;&amp; _validating_shared_path_table) {
 107     // If we are doing PrintSharedArchiveAndExit and some of the classpath entries
 108     // do not validate, we can still continue &quot;limping&quot; to validate the remaining
 109     // entries. No need to quit.
 110     tty-&gt;print(&quot;[&quot;);
 111     tty-&gt;vprint(msg, ap);
 112     tty-&gt;print_cr(&quot;]&quot;);
 113   } else {
 114     if (RequireSharedSpaces) {
<span class="line-modified"> 115       fail_exit(msg, ap);</span>
 116     } else {
 117       if (log_is_enabled(Info, cds)) {
 118         ResourceMark rm;
 119         LogStream ls(Log(cds)::info());
 120         ls.print(&quot;UseSharedSpaces: &quot;);
 121         ls.vprint_cr(msg, ap);
 122       }
 123     }



 124   }
 125   va_end(ap);
 126 }
 127 
 128 // Fill in the fileMapInfo structure with data about this VM instance.
 129 
 130 // This method copies the vm version info into header_version.  If the version is too
 131 // long then a truncated version, which has a hash code appended to it, is copied.
 132 //
 133 // Using a template enables this method to verify that header_version is an array of
 134 // length JVM_IDENT_MAX.  This ensures that the code that writes to the CDS file and
 135 // the code that reads the CDS file will both use the same size buffer.  Hence, will
 136 // use identical truncation.  This is necessary for matching of truncated versions.
 137 template &lt;int N&gt; static void get_header_version(char (&amp;header_version) [N]) {
 138   assert(N == JVM_IDENT_MAX, &quot;Bad header_version size&quot;);
 139 
 140   const char *vm_version = VM_Version::internal_vm_info_string();
 141   const int version_len = (int)strlen(vm_version);
 142 
<span class="line-added"> 143   memset(header_version, 0, JVM_IDENT_MAX);</span>
<span class="line-added"> 144 </span>
 145   if (version_len &lt; (JVM_IDENT_MAX-1)) {
 146     strcpy(header_version, vm_version);
 147 
 148   } else {
 149     // Get the hash value.  Use a static seed because the hash needs to return the same
 150     // value over multiple jvm invocations.
 151     unsigned int hash = AltHashing::murmur3_32(8191, (const jbyte*)vm_version, version_len);
 152 
 153     // Truncate the ident, saving room for the 8 hex character hash value.
 154     strncpy(header_version, vm_version, JVM_IDENT_MAX-9);
 155 
 156     // Append the hash code as eight hex digits.
 157     sprintf(&amp;header_version[JVM_IDENT_MAX-9], &quot;%08x&quot;, hash);
 158     header_version[JVM_IDENT_MAX-1] = 0;  // Null terminate.
 159   }
<span class="line-added"> 160 </span>
<span class="line-added"> 161   assert(header_version[JVM_IDENT_MAX-1] == 0, &quot;must be&quot;);</span>
 162 }
 163 
<span class="line-modified"> 164 FileMapInfo::FileMapInfo(bool is_static) {</span>


 165   memset((void*)this, 0, sizeof(FileMapInfo));
<span class="line-added"> 166   _is_static = is_static;</span>
<span class="line-added"> 167   size_t header_size;</span>
<span class="line-added"> 168   if (is_static) {</span>
<span class="line-added"> 169     assert(_current_info == NULL, &quot;must be singleton&quot;); // not thread safe</span>
<span class="line-added"> 170     _current_info = this;</span>
<span class="line-added"> 171     header_size = sizeof(FileMapHeader);</span>
<span class="line-added"> 172   } else {</span>
<span class="line-added"> 173     assert(_dynamic_archive_info == NULL, &quot;must be singleton&quot;); // not thread safe</span>
<span class="line-added"> 174     _dynamic_archive_info = this;</span>
<span class="line-added"> 175     header_size = sizeof(DynamicArchiveHeader);</span>
<span class="line-added"> 176   }</span>
<span class="line-added"> 177   _header = (FileMapHeader*)os::malloc(header_size, mtInternal);</span>
<span class="line-added"> 178   memset((void*)_header, 0, header_size);</span>
<span class="line-added"> 179   _header-&gt;set_header_size(header_size);</span>
<span class="line-added"> 180   _header-&gt;set_version(INVALID_CDS_ARCHIVE_VERSION);</span>
<span class="line-added"> 181   _header-&gt;set_has_platform_or_app_classes(true);</span>
 182   _file_offset = 0;
 183   _file_open = false;



 184 }
 185 
 186 FileMapInfo::~FileMapInfo() {
<span class="line-modified"> 187   if (_is_static) {</span>
<span class="line-modified"> 188     assert(_current_info == this, &quot;must be singleton&quot;); // not thread safe</span>
<span class="line-added"> 189     _current_info = NULL;</span>
<span class="line-added"> 190   } else {</span>
<span class="line-added"> 191     assert(_dynamic_archive_info == this, &quot;must be singleton&quot;); // not thread safe</span>
<span class="line-added"> 192     _dynamic_archive_info = NULL;</span>
<span class="line-added"> 193   }</span>
 194 }
 195 
 196 void FileMapInfo::populate_header(size_t alignment) {
<span class="line-modified"> 197   header()-&gt;populate(this, alignment);</span>
 198 }
 199 
 200 void FileMapHeader::populate(FileMapInfo* mapinfo, size_t alignment) {
<span class="line-modified"> 201   if (DynamicDumpSharedSpaces) {</span>
<span class="line-added"> 202     _magic = CDS_DYNAMIC_ARCHIVE_MAGIC;</span>
<span class="line-added"> 203   } else {</span>
<span class="line-added"> 204     _magic = CDS_ARCHIVE_MAGIC;</span>
<span class="line-added"> 205   }</span>
 206   _version = CURRENT_CDS_ARCHIVE_VERSION;
 207   _alignment = alignment;
 208   _obj_alignment = ObjectAlignmentInBytes;
 209   _compact_strings = CompactStrings;
<span class="line-modified"> 210   _narrow_oop_mode = CompressedOops::mode();</span>
<span class="line-modified"> 211   _narrow_oop_base = CompressedOops::base();</span>
<span class="line-modified"> 212   _narrow_oop_shift = CompressedOops::shift();</span>
<span class="line-added"> 213   _compressed_oops = UseCompressedOops;</span>
<span class="line-added"> 214   _compressed_class_ptrs = UseCompressedClassPointers;</span>
 215   _max_heap_size = MaxHeapSize;
<span class="line-modified"> 216   _narrow_klass_shift = CompressedKlassPointers::shift();</span>




 217   if (HeapShared::is_heap_object_archiving_allowed()) {
<span class="line-modified"> 218     _heap_end = CompressedOops::end();</span>
 219   }
 220 
 221   // The following fields are for sanity checks for whether this archive
 222   // will function correctly with this JVM and the bootclasspath it&#39;s
 223   // invoked with.
 224 
 225   // JVM version string ... changes on each build.
 226   get_header_version(_jvm_ident);
 227 

 228   _app_class_paths_start_index = ClassLoaderExt::app_class_paths_start_index();
 229   _app_module_paths_start_index = ClassLoaderExt::app_module_paths_start_index();
<span class="line-added"> 230   _num_module_paths = ClassLoader::num_module_path_entries();</span>
 231   _max_used_path_index = ClassLoaderExt::max_used_path_index();
 232 
 233   _verify_local = BytecodeVerificationLocal;
 234   _verify_remote = BytecodeVerificationRemote;
 235   _has_platform_or_app_classes = ClassLoaderExt::has_platform_or_app_classes();
<span class="line-modified"> 236   _requested_base_address = (char*)SharedBaseAddress;</span>
<span class="line-added"> 237   _mapped_base_address = (char*)SharedBaseAddress;</span>
 238   _allow_archiving_with_java_agent = AllowArchivingWithJavaAgent;
<span class="line-added"> 239   // the following 2 fields will be set in write_header for dynamic archive header</span>
<span class="line-added"> 240   _base_archive_name_size = 0;</span>
<span class="line-added"> 241   _base_archive_is_default = false;</span>
<span class="line-added"> 242 </span>
<span class="line-added"> 243   if (!DynamicDumpSharedSpaces) {</span>
<span class="line-added"> 244     set_shared_path_table(mapinfo-&gt;_shared_path_table);</span>
<span class="line-added"> 245   }</span>
<span class="line-added"> 246 }</span>
<span class="line-added"> 247 </span>
<span class="line-added"> 248 void SharedClassPathEntry::init_as_non_existent(const char* path, TRAPS) {</span>
<span class="line-added"> 249   _type = non_existent_entry;</span>
<span class="line-added"> 250   set_name(path, THREAD);</span>
 251 }
 252 
<span class="line-modified"> 253 void SharedClassPathEntry::init(bool is_modules_image,</span>
<span class="line-modified"> 254                                 ClassPathEntry* cpe, TRAPS) {</span>
<span class="line-added"> 255   Arguments::assert_is_dumping_archive();</span>
 256   _timestamp = 0;
 257   _filesize  = 0;
<span class="line-added"> 258   _from_class_path_attr = false;</span>
 259 
 260   struct stat st;
<span class="line-modified"> 261   if (os::stat(cpe-&gt;name(), &amp;st) == 0) {</span>
 262     if ((st.st_mode &amp; S_IFMT) == S_IFDIR) {
 263       _type = dir_entry;
 264     } else {
 265       // The timestamp of the modules_image is not checked at runtime.
 266       if (is_modules_image) {
 267         _type = modules_image_entry;
 268       } else {
 269         _type = jar_entry;
 270         _timestamp = st.st_mtime;
<span class="line-added"> 271         _from_class_path_attr = cpe-&gt;from_class_path_attr();</span>
 272       }
 273       _filesize = st.st_size;
 274     }
 275   } else {
 276     // The file/dir must exist, or it would not have been added
 277     // into ClassLoader::classpath_entry().
 278     //
 279     // If we can&#39;t access a jar file in the boot path, then we can&#39;t
 280     // make assumptions about where classes get loaded from.
<span class="line-modified"> 281     FileMapInfo::fail_stop(&quot;Unable to open file %s.&quot;, cpe-&gt;name());</span>
 282   }
 283 
<span class="line-added"> 284   // No need to save the name of the module file, as it will be computed at run time</span>
<span class="line-added"> 285   // to allow relocation of the JDK directory.</span>
<span class="line-added"> 286   const char* name = is_modules_image  ? &quot;&quot; : cpe-&gt;name();</span>
<span class="line-added"> 287   set_name(name, THREAD);</span>
<span class="line-added"> 288 }</span>
<span class="line-added"> 289 </span>
<span class="line-added"> 290 void SharedClassPathEntry::set_name(const char* name, TRAPS) {</span>
 291   size_t len = strlen(name) + 1;
 292   _name = MetadataFactory::new_array&lt;char&gt;(ClassLoaderData::the_null_class_loader_data(), (int)len, THREAD);
 293   strcpy(_name-&gt;data(), name);
 294 }
 295 
<span class="line-modified"> 296 const char* SharedClassPathEntry::name() const {</span>
<span class="line-added"> 297   if (UseSharedSpaces &amp;&amp; is_modules_image()) {</span>
<span class="line-added"> 298     // In order to validate the runtime modules image file size against the archived</span>
<span class="line-added"> 299     // size information, we need to obtain the runtime modules image path. The recorded</span>
<span class="line-added"> 300     // dump time modules image path in the archive may be different from the runtime path</span>
<span class="line-added"> 301     // if the JDK image has beed moved after generating the archive.</span>
<span class="line-added"> 302     return ClassLoader::get_jrt_entry()-&gt;name();</span>
<span class="line-added"> 303   } else {</span>
<span class="line-added"> 304     return _name-&gt;data();</span>
<span class="line-added"> 305   }</span>
<span class="line-added"> 306 }</span>
<span class="line-added"> 307 </span>
<span class="line-added"> 308 bool SharedClassPathEntry::validate(bool is_class_path) const {</span>
 309   assert(UseSharedSpaces, &quot;runtime only&quot;);
 310 
 311   struct stat st;
<span class="line-modified"> 312   const char* name = this-&gt;name();</span>










 313 
 314   bool ok = true;
 315   log_info(class, path)(&quot;checking shared classpath entry: %s&quot;, name);
 316   if (os::stat(name, &amp;st) != 0 &amp;&amp; is_class_path) {
 317     // If the archived module path entry does not exist at runtime, it is not fatal
 318     // (no need to invalid the shared archive) because the shared runtime visibility check
 319     // filters out any archived module classes that do not have a matching runtime
 320     // module path location.
 321     FileMapInfo::fail_continue(&quot;Required classpath entry does not exist: %s&quot;, name);
 322     ok = false;
 323   } else if (is_dir()) {
 324     if (!os::dir_is_empty(name)) {
 325       FileMapInfo::fail_continue(&quot;directory is not empty: %s&quot;, name);
 326       ok = false;
 327     }
 328   } else if ((has_timestamp() &amp;&amp; _timestamp != st.st_mtime) ||
 329              _filesize != st.st_size) {
 330     ok = false;
 331     if (PrintSharedArchiveAndExit) {
 332       FileMapInfo::fail_continue(_timestamp != st.st_mtime ?
 333                                  &quot;Timestamp mismatch&quot; :
 334                                  &quot;File size mismatch&quot;);
 335     } else {
 336       FileMapInfo::fail_continue(&quot;A jar file is not the one used while building&quot;
 337                                  &quot; the shared archive file: %s&quot;, name);
 338     }
 339   }
 340 
 341   if (PrintSharedArchiveAndExit &amp;&amp; !ok) {
 342     // If PrintSharedArchiveAndExit is enabled, don&#39;t report failure to the
 343     // caller. Please see above comments for more details.
 344     ok = true;
<span class="line-added"> 345     MetaspaceShared::set_archive_loading_failed();</span>
 346   }
 347   return ok;
 348 }
 349 
<span class="line-added"> 350 bool SharedClassPathEntry::check_non_existent() const {</span>
<span class="line-added"> 351   assert(_type == non_existent_entry, &quot;must be&quot;);</span>
<span class="line-added"> 352   log_info(class, path)(&quot;should be non-existent: %s&quot;, name());</span>
<span class="line-added"> 353   struct stat st;</span>
<span class="line-added"> 354   if (os::stat(name(), &amp;st) != 0) {</span>
<span class="line-added"> 355     log_info(class, path)(&quot;ok&quot;);</span>
<span class="line-added"> 356     return true; // file doesn&#39;t exist</span>
<span class="line-added"> 357   } else {</span>
<span class="line-added"> 358     return false;</span>
<span class="line-added"> 359   }</span>
<span class="line-added"> 360 }</span>
<span class="line-added"> 361 </span>
<span class="line-added"> 362 </span>
 363 void SharedClassPathEntry::metaspace_pointers_do(MetaspaceClosure* it) {
 364   it-&gt;push(&amp;_name);
 365   it-&gt;push(&amp;_manifest);
 366 }
 367 
<span class="line-added"> 368 void SharedPathTable::metaspace_pointers_do(MetaspaceClosure* it) {</span>
<span class="line-added"> 369   it-&gt;push(&amp;_table);</span>
<span class="line-added"> 370   for (int i=0; i&lt;_size; i++) {</span>
<span class="line-added"> 371     path_at(i)-&gt;metaspace_pointers_do(it);</span>
<span class="line-added"> 372   }</span>
<span class="line-added"> 373 }</span>
<span class="line-added"> 374 </span>
<span class="line-added"> 375 void SharedPathTable::dumptime_init(ClassLoaderData* loader_data, Thread* THREAD) {</span>
<span class="line-added"> 376   size_t entry_size = sizeof(SharedClassPathEntry);</span>
<span class="line-added"> 377   int num_entries = 0;</span>
<span class="line-added"> 378   num_entries += ClassLoader::num_boot_classpath_entries();</span>
<span class="line-added"> 379   num_entries += ClassLoader::num_app_classpath_entries();</span>
<span class="line-added"> 380   num_entries += ClassLoader::num_module_path_entries();</span>
<span class="line-added"> 381   num_entries += FileMapInfo::num_non_existent_class_paths();</span>
<span class="line-added"> 382   size_t bytes = entry_size * num_entries;</span>
<span class="line-added"> 383 </span>
<span class="line-added"> 384   _table = MetadataFactory::new_array&lt;u8&gt;(loader_data, (int)(bytes + 7 / 8), THREAD);</span>
<span class="line-added"> 385   _size = num_entries;</span>
<span class="line-added"> 386 }</span>
<span class="line-added"> 387 </span>
 388 void FileMapInfo::allocate_shared_path_table() {
<span class="line-modified"> 389   Arguments::assert_is_dumping_archive();</span>
 390 
<span class="line-modified"> 391   EXCEPTION_MARK; // The following calls should never throw, but would exit VM on error.</span>
 392   ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
 393   ClassPathEntry* jrt = ClassLoader::get_jrt_entry();
 394 
 395   assert(jrt != NULL,
 396          &quot;No modular java runtime image present when allocating the CDS classpath entry table&quot;);
 397 
<span class="line-modified"> 398   _shared_path_table.dumptime_init(loader_data, THREAD);</span>









 399 
 400   // 1. boot class path
 401   int i = 0;
<span class="line-modified"> 402   i = add_shared_classpaths(i, &quot;boot&quot;,   jrt, THREAD);</span>
<span class="line-added"> 403   i = add_shared_classpaths(i, &quot;app&quot;,    ClassLoader::app_classpath_entries(), THREAD);</span>
<span class="line-added"> 404   i = add_shared_classpaths(i, &quot;module&quot;, ClassLoader::module_path_entries(), THREAD);</span>
<span class="line-added"> 405 </span>
<span class="line-added"> 406   for (int x = 0; x &lt; num_non_existent_class_paths(); x++, i++) {</span>
<span class="line-added"> 407     const char* path = _non_existent_class_paths-&gt;at(x);</span>
<span class="line-added"> 408     shared_path(i)-&gt;init_as_non_existent(path, THREAD);</span>
<span class="line-added"> 409   }</span>
<span class="line-added"> 410 </span>
<span class="line-added"> 411   assert(i == _shared_path_table.size(), &quot;number of shared path entry mismatch&quot;);</span>
<span class="line-added"> 412 }</span>
<span class="line-added"> 413 </span>
<span class="line-added"> 414 int FileMapInfo::add_shared_classpaths(int i, const char* which, ClassPathEntry *cpe, TRAPS) {</span>
 415   while (cpe != NULL) {
<span class="line-modified"> 416     bool is_jrt = (cpe == ClassLoader::get_jrt_entry());</span>
 417     const char* type = (is_jrt ? &quot;jrt&quot; : (cpe-&gt;is_jar_file() ? &quot;jar&quot; : &quot;dir&quot;));
<span class="line-modified"> 418     log_info(class, path)(&quot;add %s shared path (%s) %s&quot;, which, type, cpe-&gt;name());</span>
 419     SharedClassPathEntry* ent = shared_path(i);
<span class="line-modified"> 420     ent-&gt;init(is_jrt, cpe, THREAD);</span>
<span class="line-modified"> 421     if (cpe-&gt;is_jar_file()) {</span>
<span class="line-modified"> 422       update_jar_manifest(cpe, ent, THREAD);</span>
<span class="line-modified"> 423     }</span>
<span class="line-added"> 424     if (is_jrt) {</span>
<span class="line-added"> 425       cpe = ClassLoader::get_next_boot_classpath_entry(cpe);</span>
<span class="line-added"> 426     } else {</span>
<span class="line-added"> 427       cpe = cpe-&gt;next();</span>
 428     }















 429     i++;
 430   }
 431 
<span class="line-modified"> 432   return i;</span>











 433 }
 434 
 435 void FileMapInfo::check_nonempty_dir_in_shared_path_table() {
<span class="line-modified"> 436   Arguments::assert_is_dumping_archive();</span>
 437 
 438   bool has_nonempty_dir = false;
 439 
<span class="line-modified"> 440   int last = _shared_path_table.size() - 1;</span>
 441   if (last &gt; ClassLoaderExt::max_used_path_index()) {
 442      // no need to check any path beyond max_used_path_index
 443      last = ClassLoaderExt::max_used_path_index();
 444   }
 445 
 446   for (int i = 0; i &lt;= last; i++) {
 447     SharedClassPathEntry *e = shared_path(i);
 448     if (e-&gt;is_dir()) {
 449       const char* path = e-&gt;name();
 450       if (!os::dir_is_empty(path)) {
<span class="line-modified"> 451         log_error(cds)(&quot;Error: non-empty directory &#39;%s&#39;&quot;, path);</span>
 452         has_nonempty_dir = true;
 453       }
 454     }
 455   }
 456 
 457   if (has_nonempty_dir) {
 458     ClassLoader::exit_with_path_failure(&quot;Cannot have non-empty directory in paths&quot;, NULL);
 459   }
 460 }
 461 
<span class="line-added"> 462 void FileMapInfo::record_non_existent_class_path_entry(const char* path) {</span>
<span class="line-added"> 463   Arguments::assert_is_dumping_archive();</span>
<span class="line-added"> 464   log_info(class, path)(&quot;non-existent Class-Path entry %s&quot;, path);</span>
<span class="line-added"> 465   if (_non_existent_class_paths == NULL) {</span>
<span class="line-added"> 466     _non_existent_class_paths = new (ResourceObj::C_HEAP, mtInternal)GrowableArray&lt;const char*&gt;(10, true);</span>
<span class="line-added"> 467   }</span>
<span class="line-added"> 468   _non_existent_class_paths-&gt;append(os::strdup(path));</span>
<span class="line-added"> 469 }</span>
<span class="line-added"> 470 </span>
<span class="line-added"> 471 int FileMapInfo::num_non_existent_class_paths() {</span>
<span class="line-added"> 472   Arguments::assert_is_dumping_archive();</span>
<span class="line-added"> 473   if (_non_existent_class_paths != NULL) {</span>
<span class="line-added"> 474     return _non_existent_class_paths-&gt;length();</span>
<span class="line-added"> 475   } else {</span>
<span class="line-added"> 476     return 0;</span>
<span class="line-added"> 477   }</span>
<span class="line-added"> 478 }</span>
<span class="line-added"> 479 </span>
 480 class ManifestStream: public ResourceObj {
 481   private:
 482   u1*   _buffer_start; // Buffer bottom
 483   u1*   _buffer_end;   // Buffer top (one past last element)
 484   u1*   _current;      // Current buffer position
 485 
 486  public:
 487   // Constructor
 488   ManifestStream(u1* buffer, int length) : _buffer_start(buffer),
 489                                            _current(buffer) {
 490     _buffer_end = buffer + length;
 491   }
 492 
 493   static bool is_attr(u1* attr, const char* name) {
 494     return strncmp((const char*)attr, name, strlen(name)) == 0;
 495   }
 496 
 497   static char* copy_attr(u1* value, size_t len) {
 498     char* buf = NEW_RESOURCE_ARRAY(char, len + 1);
 499     strncpy(buf, (char*)value, len);
</pre>
<hr />
<pre>
 508     while (_current &lt; _buffer_end) {
 509       if (*_current == &#39;\n&#39;) {
 510         *_current = &#39;\0&#39;;
 511         u1* value = (u1*)strchr((char*)attr, &#39;:&#39;);
 512         if (value != NULL) {
 513           assert(*(value+1) == &#39; &#39;, &quot;Unrecognized format&quot; );
 514           if (strstr((char*)attr, &quot;-Digest&quot;) != NULL) {
 515             isSigned = true;
 516             break;
 517           }
 518         }
 519         *_current = &#39;\n&#39;; // restore
 520         attr = _current + 1;
 521       }
 522       _current ++;
 523     }
 524     return isSigned;
 525   }
 526 };
 527 
<span class="line-modified"> 528 void FileMapInfo::update_jar_manifest(ClassPathEntry *cpe, SharedClassPathEntry* ent, TRAPS) {</span>
 529   ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
 530   ResourceMark rm(THREAD);
 531   jint manifest_size;
 532 
<span class="line-modified"> 533   assert(cpe-&gt;is_jar_file() &amp;&amp; ent-&gt;is_jar(), &quot;the shared class path entry is not a JAR file&quot;);</span>
<span class="line-modified"> 534   char* manifest = ClassLoaderExt::read_manifest(cpe, &amp;manifest_size, CHECK);</span>
<span class="line-modified"> 535   if (manifest != NULL) {</span>
<span class="line-modified"> 536     ManifestStream* stream = new ManifestStream((u1*)manifest,</span>
<span class="line-modified"> 537                                                 manifest_size);</span>
<span class="line-modified"> 538     if (stream-&gt;check_is_signed()) {</span>
<span class="line-modified"> 539       ent-&gt;set_is_signed();</span>
<span class="line-modified"> 540     } else {</span>
<span class="line-added"> 541       // Copy the manifest into the shared archive</span>
<span class="line-added"> 542       manifest = ClassLoaderExt::read_raw_manifest(cpe, &amp;manifest_size, CHECK);</span>
<span class="line-added"> 543       Array&lt;u1&gt;* buf = MetadataFactory::new_array&lt;u1&gt;(loader_data,</span>
<span class="line-added"> 544                                                       manifest_size,</span>
<span class="line-added"> 545                                                       THREAD);</span>
<span class="line-added"> 546       char* p = (char*)(buf-&gt;data());</span>
<span class="line-added"> 547       memcpy(p, manifest, manifest_size);</span>
<span class="line-added"> 548       ent-&gt;set_manifest(buf);</span>
<span class="line-added"> 549     }</span>
<span class="line-added"> 550   }</span>
<span class="line-added"> 551 }</span>
<span class="line-added"> 552 </span>
<span class="line-added"> 553 char* FileMapInfo::skip_first_path_entry(const char* path) {</span>
<span class="line-added"> 554   size_t path_sep_len = strlen(os::path_separator());</span>
<span class="line-added"> 555   char* p = strstr((char*)path, os::path_separator());</span>
<span class="line-added"> 556   if (p != NULL) {</span>
<span class="line-added"> 557     debug_only( {</span>
<span class="line-added"> 558       size_t image_name_len = strlen(MODULES_IMAGE_NAME);</span>
<span class="line-added"> 559       assert(strncmp(p - image_name_len, MODULES_IMAGE_NAME, image_name_len) == 0,</span>
<span class="line-added"> 560              &quot;first entry must be the modules image&quot;);</span>
<span class="line-added"> 561     } );</span>
<span class="line-added"> 562     p += path_sep_len;</span>
<span class="line-added"> 563   } else {</span>
<span class="line-added"> 564     debug_only( {</span>
<span class="line-added"> 565       assert(ClassLoader::string_ends_with(path, MODULES_IMAGE_NAME),</span>
<span class="line-added"> 566              &quot;first entry must be the modules image&quot;);</span>
<span class="line-added"> 567     } );</span>
<span class="line-added"> 568   }</span>
<span class="line-added"> 569   return p;</span>
<span class="line-added"> 570 }</span>
<span class="line-added"> 571 </span>
<span class="line-added"> 572 int FileMapInfo::num_paths(const char* path) {</span>
<span class="line-added"> 573   if (path == NULL) {</span>
<span class="line-added"> 574     return 0;</span>
<span class="line-added"> 575   }</span>
<span class="line-added"> 576   int npaths = 1;</span>
<span class="line-added"> 577   char* p = (char*)path;</span>
<span class="line-added"> 578   while (p != NULL) {</span>
<span class="line-added"> 579     char* prev = p;</span>
<span class="line-added"> 580     p = strstr((char*)p, os::path_separator());</span>
<span class="line-added"> 581     if (p != NULL) {</span>
<span class="line-added"> 582       p++;</span>
<span class="line-added"> 583       // don&#39;t count empty path</span>
<span class="line-added"> 584       if ((p - prev) &gt; 1) {</span>
<span class="line-added"> 585        npaths++;</span>
<span class="line-added"> 586       }</span>
<span class="line-added"> 587     }</span>
<span class="line-added"> 588   }</span>
<span class="line-added"> 589   return npaths;</span>
<span class="line-added"> 590 }</span>
<span class="line-added"> 591 </span>
<span class="line-added"> 592 GrowableArray&lt;const char*&gt;* FileMapInfo::create_path_array(const char* paths) {</span>
<span class="line-added"> 593   GrowableArray&lt;const char*&gt;* path_array =  new(ResourceObj::RESOURCE_AREA, mtInternal)</span>
<span class="line-added"> 594       GrowableArray&lt;const char*&gt;(10);</span>
<span class="line-added"> 595 </span>
<span class="line-added"> 596   ClasspathStream cp_stream(paths);</span>
<span class="line-added"> 597   while (cp_stream.has_next()) {</span>
<span class="line-added"> 598     const char* path = cp_stream.get_next();</span>
<span class="line-added"> 599     struct stat st;</span>
<span class="line-added"> 600     if (os::stat(path, &amp;st) == 0) {</span>
<span class="line-added"> 601       path_array-&gt;append(path);</span>
<span class="line-added"> 602     }</span>
<span class="line-added"> 603   }</span>
<span class="line-added"> 604   return path_array;</span>
<span class="line-added"> 605 }</span>
<span class="line-added"> 606 </span>
<span class="line-added"> 607 bool FileMapInfo::classpath_failure(const char* msg, const char* name) {</span>
<span class="line-added"> 608   ClassLoader::trace_class_path(msg, name);</span>
<span class="line-added"> 609   if (PrintSharedArchiveAndExit) {</span>
<span class="line-added"> 610     MetaspaceShared::set_archive_loading_failed();</span>
<span class="line-added"> 611   }</span>
<span class="line-added"> 612   return false;</span>
<span class="line-added"> 613 }</span>
<span class="line-added"> 614 </span>
<span class="line-added"> 615 bool FileMapInfo::check_paths(int shared_path_start_idx, int num_paths, GrowableArray&lt;const char*&gt;* rp_array) {</span>
<span class="line-added"> 616   int i = 0;</span>
<span class="line-added"> 617   int j = shared_path_start_idx;</span>
<span class="line-added"> 618   bool mismatch = false;</span>
<span class="line-added"> 619   while (i &lt; num_paths &amp;&amp; !mismatch) {</span>
<span class="line-added"> 620     while (shared_path(j)-&gt;from_class_path_attr()) {</span>
<span class="line-added"> 621       // shared_path(j) was expanded from the JAR file attribute &quot;Class-Path:&quot;</span>
<span class="line-added"> 622       // during dump time. It&#39;s not included in the -classpath VM argument.</span>
<span class="line-added"> 623       j++;</span>
<span class="line-added"> 624     }</span>
<span class="line-added"> 625     if (!os::same_files(shared_path(j)-&gt;name(), rp_array-&gt;at(i))) {</span>
<span class="line-added"> 626       mismatch = true;</span>
<span class="line-added"> 627     }</span>
<span class="line-added"> 628     i++;</span>
<span class="line-added"> 629     j++;</span>
<span class="line-added"> 630   }</span>
<span class="line-added"> 631   return mismatch;</span>
<span class="line-added"> 632 }</span>
<span class="line-added"> 633 </span>
<span class="line-added"> 634 bool FileMapInfo::validate_boot_class_paths() {</span>
<span class="line-added"> 635   //</span>
<span class="line-added"> 636   // - Archive contains boot classes only - relaxed boot path check:</span>
<span class="line-added"> 637   //   Extra path elements appended to the boot path at runtime are allowed.</span>
<span class="line-added"> 638   //</span>
<span class="line-added"> 639   // - Archive contains application or platform classes - strict boot path check:</span>
<span class="line-added"> 640   //   Validate the entire runtime boot path, which must be compatible</span>
<span class="line-added"> 641   //   with the dump time boot path. Appending boot path at runtime is not</span>
<span class="line-added"> 642   //   allowed.</span>
<span class="line-added"> 643   //</span>
<span class="line-added"> 644 </span>
<span class="line-added"> 645   // The first entry in boot path is the modules_image (guaranteed by</span>
<span class="line-added"> 646   // ClassLoader::setup_boot_search_path()). Skip the first entry. The</span>
<span class="line-added"> 647   // path of the runtime modules_image may be different from the dump</span>
<span class="line-added"> 648   // time path (e.g. the JDK image is copied to a different location</span>
<span class="line-added"> 649   // after generating the shared archive), which is acceptable. For most</span>
<span class="line-added"> 650   // common cases, the dump time boot path might contain modules_image only.</span>
<span class="line-added"> 651   char* runtime_boot_path = Arguments::get_sysclasspath();</span>
<span class="line-added"> 652   char* rp = skip_first_path_entry(runtime_boot_path);</span>
<span class="line-added"> 653   assert(shared_path(0)-&gt;is_modules_image(), &quot;first shared_path must be the modules image&quot;);</span>
<span class="line-added"> 654   int dp_len = header()-&gt;app_class_paths_start_index() - 1; // ignore the first path to the module image</span>
<span class="line-added"> 655   bool mismatch = false;</span>
<span class="line-added"> 656 </span>
<span class="line-added"> 657   bool relaxed_check = !header()-&gt;has_platform_or_app_classes();</span>
<span class="line-added"> 658   if (dp_len == 0 &amp;&amp; rp == NULL) {</span>
<span class="line-added"> 659     return true;   // ok, both runtime and dump time boot paths have modules_images only</span>
<span class="line-added"> 660   } else if (dp_len == 0 &amp;&amp; rp != NULL) {</span>
<span class="line-added"> 661     if (relaxed_check) {</span>
<span class="line-added"> 662       return true;   // ok, relaxed check, runtime has extra boot append path entries</span>
<span class="line-added"> 663     } else {</span>
<span class="line-added"> 664       mismatch = true;</span>
<span class="line-added"> 665     }</span>
<span class="line-added"> 666   } else if (dp_len &gt; 0 &amp;&amp; rp != NULL) {</span>
<span class="line-added"> 667     int num;</span>
<span class="line-added"> 668     ResourceMark rm;</span>
<span class="line-added"> 669     GrowableArray&lt;const char*&gt;* rp_array = create_path_array(rp);</span>
<span class="line-added"> 670     int rp_len = rp_array-&gt;length();</span>
<span class="line-added"> 671     if (rp_len &gt;= dp_len) {</span>
<span class="line-added"> 672       if (relaxed_check) {</span>
<span class="line-added"> 673         // only check the leading entries in the runtime boot path, up to</span>
<span class="line-added"> 674         // the length of the dump time boot path</span>
<span class="line-added"> 675         num = dp_len;</span>
 676       } else {
<span class="line-modified"> 677         // check the full runtime boot path, must match with dump time</span>
<span class="line-modified"> 678         num = rp_len;</span>






 679       }
<span class="line-added"> 680       mismatch = check_paths(1, num, rp_array);</span>
<span class="line-added"> 681     }</span>
<span class="line-added"> 682   }</span>
<span class="line-added"> 683 </span>
<span class="line-added"> 684   if (mismatch) {</span>
<span class="line-added"> 685     // The paths are different</span>
<span class="line-added"> 686     return classpath_failure(&quot;[BOOT classpath mismatch, actual =&quot;, runtime_boot_path);</span>
<span class="line-added"> 687   }</span>
<span class="line-added"> 688   return true;</span>
<span class="line-added"> 689 }</span>
<span class="line-added"> 690 </span>
<span class="line-added"> 691 bool FileMapInfo::validate_app_class_paths(int shared_app_paths_len) {</span>
<span class="line-added"> 692   const char *appcp = Arguments::get_appclasspath();</span>
<span class="line-added"> 693   assert(appcp != NULL, &quot;NULL app classpath&quot;);</span>
<span class="line-added"> 694   int rp_len = num_paths(appcp);</span>
<span class="line-added"> 695   bool mismatch = false;</span>
<span class="line-added"> 696   if (rp_len &lt; shared_app_paths_len) {</span>
<span class="line-added"> 697     return classpath_failure(&quot;Run time APP classpath is shorter than the one at dump time: &quot;, appcp);</span>
<span class="line-added"> 698   }</span>
<span class="line-added"> 699   if (shared_app_paths_len != 0 &amp;&amp; rp_len != 0) {</span>
<span class="line-added"> 700     // Prefix is OK: E.g., dump with -cp foo.jar, but run with -cp foo.jar:bar.jar.</span>
<span class="line-added"> 701     ResourceMark rm;</span>
<span class="line-added"> 702     GrowableArray&lt;const char*&gt;* rp_array = create_path_array(appcp);</span>
<span class="line-added"> 703     if (rp_array-&gt;length() == 0) {</span>
<span class="line-added"> 704       // None of the jar file specified in the runtime -cp exists.</span>
<span class="line-added"> 705       return classpath_failure(&quot;None of the jar file specified in the runtime -cp exists: -Djava.class.path=&quot;, appcp);</span>
<span class="line-added"> 706     }</span>
<span class="line-added"> 707 </span>
<span class="line-added"> 708     // Handling of non-existent entries in the classpath: we eliminate all the non-existent</span>
<span class="line-added"> 709     // entries from both the dump time classpath (ClassLoader::update_class_path_entry_list)</span>
<span class="line-added"> 710     // and the runtime classpath (FileMapInfo::create_path_array), and check the remaining</span>
<span class="line-added"> 711     // entries. E.g.:</span>
<span class="line-added"> 712     //</span>
<span class="line-added"> 713     // dump : -cp a.jar:NE1:NE2:b.jar  -&gt; a.jar:b.jar -&gt; recorded in archive.</span>
<span class="line-added"> 714     // run 1: -cp NE3:a.jar:NE4:b.jar  -&gt; a.jar:b.jar -&gt; matched</span>
<span class="line-added"> 715     // run 2: -cp x.jar:NE4:b.jar      -&gt; x.jar:b.jar -&gt; mismatched</span>
<span class="line-added"> 716 </span>
<span class="line-added"> 717     int j = header()-&gt;app_class_paths_start_index();</span>
<span class="line-added"> 718     mismatch = check_paths(j, shared_app_paths_len, rp_array);</span>
<span class="line-added"> 719     if (mismatch) {</span>
<span class="line-added"> 720       return classpath_failure(&quot;[APP classpath mismatch, actual: -Djava.class.path=&quot;, appcp);</span>
 721     }
 722   }
<span class="line-added"> 723   return true;</span>
 724 }
 725 
<span class="line-added"> 726 void FileMapInfo::log_paths(const char* msg, int start_idx, int end_idx) {</span>
<span class="line-added"> 727   LogTarget(Info, class, path) lt;</span>
<span class="line-added"> 728   if (lt.is_enabled()) {</span>
<span class="line-added"> 729     LogStream ls(lt);</span>
<span class="line-added"> 730     ls.print(&quot;%s&quot;, msg);</span>
<span class="line-added"> 731     const char* prefix = &quot;&quot;;</span>
<span class="line-added"> 732     for (int i = start_idx; i &lt; end_idx; i++) {</span>
<span class="line-added"> 733       ls.print(&quot;%s%s&quot;, prefix, shared_path(i)-&gt;name());</span>
<span class="line-added"> 734       prefix = os::path_separator();</span>
<span class="line-added"> 735     }</span>
<span class="line-added"> 736     ls.cr();</span>
<span class="line-added"> 737   }</span>
<span class="line-added"> 738 }</span>
 739 
 740 bool FileMapInfo::validate_shared_path_table() {
 741   assert(UseSharedSpaces, &quot;runtime only&quot;);
 742 
 743   _validating_shared_path_table = true;



 744 
<span class="line-modified"> 745   // Load the shared path table info from the archive header</span>
<span class="line-added"> 746   _shared_path_table = header()-&gt;shared_path_table();</span>
<span class="line-added"> 747   if (DynamicDumpSharedSpaces) {</span>
<span class="line-added"> 748     // Only support dynamic dumping with the usage of the default CDS archive</span>
<span class="line-added"> 749     // or a simple base archive.</span>
<span class="line-added"> 750     // If the base layer archive contains additional path component besides</span>
<span class="line-added"> 751     // the runtime image and the -cp, dynamic dumping is disabled.</span>
<span class="line-added"> 752     //</span>
<span class="line-added"> 753     // When dynamic archiving is enabled, the _shared_path_table is overwritten</span>
<span class="line-added"> 754     // to include the application path and stored in the top layer archive.</span>
<span class="line-added"> 755     assert(shared_path(0)-&gt;is_modules_image(), &quot;first shared_path must be the modules image&quot;);</span>
<span class="line-added"> 756     if (header()-&gt;app_class_paths_start_index() &gt; 1) {</span>
<span class="line-added"> 757       DynamicDumpSharedSpaces = false;</span>
<span class="line-added"> 758       warning(</span>
<span class="line-added"> 759         &quot;Dynamic archiving is disabled because base layer archive has appended boot classpath&quot;);</span>
<span class="line-added"> 760     }</span>
<span class="line-added"> 761     if (header()-&gt;num_module_paths() &gt; 0) {</span>
<span class="line-added"> 762       DynamicDumpSharedSpaces = false;</span>
<span class="line-added"> 763       warning(</span>
<span class="line-added"> 764         &quot;Dynamic archiving is disabled because base layer archive has module path&quot;);</span>
<span class="line-added"> 765     }</span>
<span class="line-added"> 766   }</span>
<span class="line-added"> 767 </span>
<span class="line-added"> 768   log_paths(&quot;Expecting BOOT path=&quot;, 0, header()-&gt;app_class_paths_start_index());</span>
<span class="line-added"> 769   log_paths(&quot;Expecting -Djava.class.path=&quot;, header()-&gt;app_class_paths_start_index(), header()-&gt;app_module_paths_start_index());</span>
<span class="line-added"> 770 </span>
<span class="line-added"> 771   int module_paths_start_index = header()-&gt;app_module_paths_start_index();</span>
<span class="line-added"> 772   int shared_app_paths_len = 0;</span>
 773 
 774   // validate the path entries up to the _max_used_path_index
<span class="line-modified"> 775   for (int i=0; i &lt; header()-&gt;max_used_path_index() + 1; i++) {</span>
 776     if (i &lt; module_paths_start_index) {
 777       if (shared_path(i)-&gt;validate()) {
<span class="line-added"> 778         // Only count the app class paths not from the &quot;Class-path&quot; attribute of a jar manifest.</span>
<span class="line-added"> 779         if (!shared_path(i)-&gt;from_class_path_attr() &amp;&amp; i &gt;= header()-&gt;app_class_paths_start_index()) {</span>
<span class="line-added"> 780           shared_app_paths_len++;</span>
<span class="line-added"> 781         }</span>
 782         log_info(class, path)(&quot;ok&quot;);
 783       } else {
<span class="line-modified"> 784         if (_dynamic_archive_info != NULL &amp;&amp; _dynamic_archive_info-&gt;_is_static) {</span>
<span class="line-added"> 785           assert(!UseSharedSpaces, &quot;UseSharedSpaces should be disabled&quot;);</span>
<span class="line-added"> 786         }</span>
 787         return false;
 788       }
 789     } else if (i &gt;= module_paths_start_index) {
 790       if (shared_path(i)-&gt;validate(false /* not a class path entry */)) {
 791         log_info(class, path)(&quot;ok&quot;);
 792       } else {
<span class="line-modified"> 793         if (_dynamic_archive_info != NULL &amp;&amp; _dynamic_archive_info-&gt;_is_static) {</span>
<span class="line-added"> 794           assert(!UseSharedSpaces, &quot;UseSharedSpaces should be disabled&quot;);</span>
<span class="line-added"> 795         }</span>
 796         return false;
 797       }
 798     }
 799   }
 800 
<span class="line-added"> 801   if (header()-&gt;max_used_path_index() == 0) {</span>
<span class="line-added"> 802     // default archive only contains the module image in the bootclasspath</span>
<span class="line-added"> 803     assert(shared_path(0)-&gt;is_modules_image(), &quot;first shared_path must be the modules image&quot;);</span>
<span class="line-added"> 804   } else {</span>
<span class="line-added"> 805     if (!validate_boot_class_paths() || !validate_app_class_paths(shared_app_paths_len)) {</span>
<span class="line-added"> 806       fail_continue(&quot;shared class paths mismatch (hint: enable -Xlog:class+path=info to diagnose the failure)&quot;);</span>
<span class="line-added"> 807       return false;</span>
<span class="line-added"> 808     }</span>
<span class="line-added"> 809   }</span>
<span class="line-added"> 810 </span>
<span class="line-added"> 811   validate_non_existent_class_paths();</span>
<span class="line-added"> 812 </span>
 813   _validating_shared_path_table = false;
 814 
 815 #if INCLUDE_JVMTI
 816   if (_classpath_entries_for_jvmti != NULL) {
 817     os::free(_classpath_entries_for_jvmti);
 818   }
<span class="line-modified"> 819   size_t sz = sizeof(ClassPathEntry*) * get_number_of_shared_paths();</span>
 820   _classpath_entries_for_jvmti = (ClassPathEntry**)os::malloc(sz, mtClass);
<span class="line-modified"> 821   memset((void*)_classpath_entries_for_jvmti, 0, sz);</span>
 822 #endif
 823 
 824   return true;
 825 }
 826 
<span class="line-added"> 827 void FileMapInfo::validate_non_existent_class_paths() {</span>
<span class="line-added"> 828   // All of the recorded non-existent paths came from the Class-Path: attribute from the JAR</span>
<span class="line-added"> 829   // files on the app classpath. If any of these are found to exist during runtime,</span>
<span class="line-added"> 830   // it will change how classes are loading for the app loader. For safety, disable</span>
<span class="line-added"> 831   // loading of archived platform/app classes (currently there&#39;s no way to disable just the</span>
<span class="line-added"> 832   // app classes).</span>
<span class="line-added"> 833 </span>
<span class="line-added"> 834   assert(UseSharedSpaces, &quot;runtime only&quot;);</span>
<span class="line-added"> 835   for (int i = header()-&gt;app_module_paths_start_index() + header()-&gt;num_module_paths();</span>
<span class="line-added"> 836        i &lt; get_number_of_shared_paths();</span>
<span class="line-added"> 837        i++) {</span>
<span class="line-added"> 838     SharedClassPathEntry* ent = shared_path(i);</span>
<span class="line-added"> 839     if (!ent-&gt;check_non_existent()) {</span>
<span class="line-added"> 840       warning(&quot;Archived non-system classes are disabled because the &quot;</span>
<span class="line-added"> 841               &quot;file %s exists&quot;, ent-&gt;name());</span>
<span class="line-added"> 842       header()-&gt;set_has_platform_or_app_classes(false);</span>
<span class="line-added"> 843     }</span>
<span class="line-added"> 844   }</span>
<span class="line-added"> 845 }</span>
<span class="line-added"> 846 </span>
<span class="line-added"> 847 bool FileMapInfo::check_archive(const char* archive_name, bool is_static) {</span>
<span class="line-added"> 848   int fd = os::open(archive_name, O_RDONLY | O_BINARY, 0);</span>
<span class="line-added"> 849   if (fd &lt; 0) {</span>
<span class="line-added"> 850     // do not vm_exit_during_initialization here because Arguments::init_shared_archive_paths()</span>
<span class="line-added"> 851     // requires a shared archive name. The open_for_read() function will log a message regarding</span>
<span class="line-added"> 852     // failure in opening a shared archive.</span>
<span class="line-added"> 853     return false;</span>
<span class="line-added"> 854   }</span>
<span class="line-added"> 855 </span>
<span class="line-added"> 856   size_t sz = is_static ? sizeof(FileMapHeader) : sizeof(DynamicArchiveHeader);</span>
<span class="line-added"> 857   void* header = os::malloc(sz, mtInternal);</span>
<span class="line-added"> 858   memset(header, 0, sz);</span>
<span class="line-added"> 859   size_t n = os::read(fd, header, (unsigned int)sz);</span>
<span class="line-added"> 860   if (n != sz) {</span>
<span class="line-added"> 861     os::free(header);</span>
<span class="line-added"> 862     os::close(fd);</span>
<span class="line-added"> 863     vm_exit_during_initialization(&quot;Unable to read header from shared archive&quot;, archive_name);</span>
<span class="line-added"> 864     return false;</span>
<span class="line-added"> 865   }</span>
<span class="line-added"> 866   if (is_static) {</span>
<span class="line-added"> 867     FileMapHeader* static_header = (FileMapHeader*)header;</span>
<span class="line-added"> 868     if (static_header-&gt;magic() != CDS_ARCHIVE_MAGIC) {</span>
<span class="line-added"> 869       os::free(header);</span>
<span class="line-added"> 870       os::close(fd);</span>
<span class="line-added"> 871       vm_exit_during_initialization(&quot;Not a base shared archive&quot;, archive_name);</span>
<span class="line-added"> 872       return false;</span>
<span class="line-added"> 873     }</span>
<span class="line-added"> 874   } else {</span>
<span class="line-added"> 875     DynamicArchiveHeader* dynamic_header = (DynamicArchiveHeader*)header;</span>
<span class="line-added"> 876     if (dynamic_header-&gt;magic() != CDS_DYNAMIC_ARCHIVE_MAGIC) {</span>
<span class="line-added"> 877       os::free(header);</span>
<span class="line-added"> 878       os::close(fd);</span>
<span class="line-added"> 879       vm_exit_during_initialization(&quot;Not a top shared archive&quot;, archive_name);</span>
<span class="line-added"> 880       return false;</span>
<span class="line-added"> 881     }</span>
<span class="line-added"> 882   }</span>
<span class="line-added"> 883   os::free(header);</span>
<span class="line-added"> 884   os::close(fd);</span>
<span class="line-added"> 885   return true;</span>
<span class="line-added"> 886 }</span>
<span class="line-added"> 887 </span>
<span class="line-added"> 888 bool FileMapInfo::get_base_archive_name_from_header(const char* archive_name,</span>
<span class="line-added"> 889                                                     int* size, char** base_archive_name) {</span>
<span class="line-added"> 890   int fd = os::open(archive_name, O_RDONLY | O_BINARY, 0);</span>
<span class="line-added"> 891   if (fd &lt; 0) {</span>
<span class="line-added"> 892     *size = 0;</span>
<span class="line-added"> 893     return false;</span>
<span class="line-added"> 894   }</span>
<span class="line-added"> 895 </span>
<span class="line-added"> 896   // read the header as a dynamic archive header</span>
<span class="line-added"> 897   size_t sz = sizeof(DynamicArchiveHeader);</span>
<span class="line-added"> 898   DynamicArchiveHeader* dynamic_header = (DynamicArchiveHeader*)os::malloc(sz, mtInternal);</span>
<span class="line-added"> 899   size_t n = os::read(fd, dynamic_header, (unsigned int)sz);</span>
<span class="line-added"> 900   if (n != sz) {</span>
<span class="line-added"> 901     fail_continue(&quot;Unable to read the file header.&quot;);</span>
<span class="line-added"> 902     os::free(dynamic_header);</span>
<span class="line-added"> 903     os::close(fd);</span>
<span class="line-added"> 904     return false;</span>
<span class="line-added"> 905   }</span>
<span class="line-added"> 906   if (dynamic_header-&gt;magic() != CDS_DYNAMIC_ARCHIVE_MAGIC) {</span>
<span class="line-added"> 907     // Not a dynamic header, no need to proceed further.</span>
<span class="line-added"> 908     *size = 0;</span>
<span class="line-added"> 909     os::free(dynamic_header);</span>
<span class="line-added"> 910     os::close(fd);</span>
<span class="line-added"> 911     return false;</span>
<span class="line-added"> 912   }</span>
<span class="line-added"> 913   if (dynamic_header-&gt;base_archive_is_default()) {</span>
<span class="line-added"> 914     *base_archive_name = Arguments::get_default_shared_archive_path();</span>
<span class="line-added"> 915   } else {</span>
<span class="line-added"> 916     // read the base archive name</span>
<span class="line-added"> 917     size_t name_size = dynamic_header-&gt;base_archive_name_size();</span>
<span class="line-added"> 918     if (name_size == 0) {</span>
<span class="line-added"> 919       os::free(dynamic_header);</span>
<span class="line-added"> 920       os::close(fd);</span>
<span class="line-added"> 921       return false;</span>
<span class="line-added"> 922     }</span>
<span class="line-added"> 923     *base_archive_name = NEW_C_HEAP_ARRAY(char, name_size, mtInternal);</span>
<span class="line-added"> 924     n = os::read(fd, *base_archive_name, (unsigned int)name_size);</span>
<span class="line-added"> 925     if (n != name_size) {</span>
<span class="line-added"> 926       fail_continue(&quot;Unable to read the base archive name from the header.&quot;);</span>
<span class="line-added"> 927       FREE_C_HEAP_ARRAY(char, *base_archive_name);</span>
<span class="line-added"> 928       *base_archive_name = NULL;</span>
<span class="line-added"> 929       os::free(dynamic_header);</span>
<span class="line-added"> 930       os::close(fd);</span>
<span class="line-added"> 931       return false;</span>
<span class="line-added"> 932     }</span>
<span class="line-added"> 933   }</span>
<span class="line-added"> 934 </span>
<span class="line-added"> 935   os::free(dynamic_header);</span>
<span class="line-added"> 936   os::close(fd);</span>
<span class="line-added"> 937   return true;</span>
<span class="line-added"> 938 }</span>
<span class="line-added"> 939 </span>
<span class="line-added"> 940 void FileMapInfo::restore_shared_path_table() {</span>
<span class="line-added"> 941   _shared_path_table = _current_info-&gt;header()-&gt;shared_path_table();</span>
<span class="line-added"> 942 }</span>
<span class="line-added"> 943 </span>
 944 // Read the FileMapInfo information from the file.
 945 
 946 bool FileMapInfo::init_from_file(int fd) {
<span class="line-modified"> 947   size_t sz = is_static() ? sizeof(FileMapHeader) : sizeof(DynamicArchiveHeader);</span>
<span class="line-modified"> 948   size_t n = os::read(fd, header(), (unsigned int)sz);</span>
 949   if (n != sz) {
 950     fail_continue(&quot;Unable to read the file header.&quot;);
 951     return false;
 952   }
<span class="line-modified"> 953 </span>
<span class="line-added"> 954   if (!Arguments::has_jimage()) {</span>
<span class="line-added"> 955     FileMapInfo::fail_continue(&quot;The shared archive file cannot be used with an exploded module build.&quot;);</span>
<span class="line-added"> 956     return false;</span>
<span class="line-added"> 957   }</span>
<span class="line-added"> 958 </span>
<span class="line-added"> 959   unsigned int expected_magic = is_static() ? CDS_ARCHIVE_MAGIC : CDS_DYNAMIC_ARCHIVE_MAGIC;</span>
<span class="line-added"> 960   if (header()-&gt;magic() != expected_magic) {</span>
<span class="line-added"> 961     log_info(cds)(&quot;_magic expected: 0x%08x&quot;, expected_magic);</span>
<span class="line-added"> 962     log_info(cds)(&quot;         actual: 0x%08x&quot;, header()-&gt;magic());</span>
<span class="line-added"> 963     FileMapInfo::fail_continue(&quot;The shared archive file has a bad magic number.&quot;);</span>
<span class="line-added"> 964     return false;</span>
<span class="line-added"> 965   }</span>
<span class="line-added"> 966 </span>
<span class="line-added"> 967   if (header()-&gt;version() != CURRENT_CDS_ARCHIVE_VERSION) {</span>
<span class="line-added"> 968     log_info(cds)(&quot;_version expected: %d&quot;, CURRENT_CDS_ARCHIVE_VERSION);</span>
<span class="line-added"> 969     log_info(cds)(&quot;           actual: %d&quot;, header()-&gt;version());</span>
 970     fail_continue(&quot;The shared archive file has the wrong version.&quot;);
 971     return false;
 972   }

 973 
<span class="line-modified"> 974   if (header()-&gt;header_size() != sz) {</span>
<span class="line-modified"> 975     log_info(cds)(&quot;_header_size expected: &quot; SIZE_FORMAT, sz);</span>
<span class="line-modified"> 976     log_info(cds)(&quot;               actual: &quot; SIZE_FORMAT, header()-&gt;header_size());</span>
<span class="line-modified"> 977     FileMapInfo::fail_continue(&quot;The shared archive file has an incorrect header size.&quot;);</span>
 978     return false;
 979   }
<span class="line-modified"> 980 </span>
<span class="line-modified"> 981   const char* actual_ident = header()-&gt;jvm_ident();</span>
<span class="line-modified"> 982 </span>
<span class="line-modified"> 983   if (actual_ident[JVM_IDENT_MAX-1] != 0) {</span>
<span class="line-modified"> 984     FileMapInfo::fail_continue(&quot;JVM version identifier is corrupted.&quot;);</span>
 985     return false;
 986   }
 987 
<span class="line-modified"> 988   char expected_ident[JVM_IDENT_MAX];</span>
<span class="line-modified"> 989   get_header_version(expected_ident);</span>
<span class="line-modified"> 990   if (strncmp(actual_ident, expected_ident, JVM_IDENT_MAX-1) != 0) {</span>
<span class="line-modified"> 991     log_info(cds)(&quot;_jvm_ident expected: %s&quot;, expected_ident);</span>
<span class="line-modified"> 992     log_info(cds)(&quot;             actual: %s&quot;, actual_ident);</span>
<span class="line-added"> 993     FileMapInfo::fail_continue(&quot;The shared archive file was created by a different&quot;</span>
<span class="line-added"> 994                   &quot; version or build of HotSpot&quot;);</span>
 995     return false;
 996   }
 997 
<span class="line-modified"> 998   if (VerifySharedSpaces) {</span>
<span class="line-modified"> 999     int expected_crc = header()-&gt;compute_crc();</span>
<span class="line-added">1000     if (expected_crc != header()-&gt;crc()) {</span>
<span class="line-added">1001       log_info(cds)(&quot;_crc expected: %d&quot;, expected_crc);</span>
<span class="line-added">1002       log_info(cds)(&quot;       actual: %d&quot;, header()-&gt;crc());</span>
<span class="line-added">1003       FileMapInfo::fail_continue(&quot;Header checksum verification failed.&quot;);</span>
<span class="line-added">1004       return false;</span>
<span class="line-added">1005     }</span>
<span class="line-added">1006   }</span>
<span class="line-added">1007 </span>
<span class="line-added">1008   _file_offset = n + header()-&gt;base_archive_name_size(); // accounts for the size of _base_archive_name</span>
<span class="line-added">1009 </span>
<span class="line-added">1010   if (is_static()) {</span>
<span class="line-added">1011     // just checking the last region is sufficient since the archive is written</span>
<span class="line-added">1012     // in sequential order</span>
<span class="line-added">1013     size_t len = lseek(fd, 0, SEEK_END);</span>
<span class="line-added">1014     FileMapRegion* si = space_at(MetaspaceShared::last_valid_region);</span>
<span class="line-added">1015     // The last space might be empty</span>
<span class="line-added">1016     if (si-&gt;file_offset() &gt; len || len - si-&gt;file_offset() &lt; si-&gt;used()) {</span>
<span class="line-added">1017       fail_continue(&quot;The shared archive file has been truncated.&quot;);</span>
<span class="line-added">1018       return false;</span>
<span class="line-added">1019     }</span>
<span class="line-added">1020   }</span>
<span class="line-added">1021 </span>
1022   return true;
1023 }
1024 
<span class="line-added">1025 void FileMapInfo::seek_to_position(size_t pos) {</span>
<span class="line-added">1026   if (lseek(_fd, (long)pos, SEEK_SET) &lt; 0) {</span>
<span class="line-added">1027     fail_stop(&quot;Unable to seek to position &quot; SIZE_FORMAT, pos);</span>
<span class="line-added">1028   }</span>
<span class="line-added">1029 }</span>
1030 
1031 // Read the FileMapInfo information from the file.
1032 bool FileMapInfo::open_for_read() {
<span class="line-modified">1033   if (_file_open) {</span>
<span class="line-added">1034     return true;</span>
<span class="line-added">1035   }</span>
<span class="line-added">1036   if (is_static()) {</span>
<span class="line-added">1037     _full_path = Arguments::GetSharedArchivePath();</span>
<span class="line-added">1038   } else {</span>
<span class="line-added">1039     _full_path = Arguments::GetSharedDynamicArchivePath();</span>
<span class="line-added">1040   }</span>
1041   int fd = os::open(_full_path, O_RDONLY | O_BINARY, 0);
1042   if (fd &lt; 0) {
1043     if (errno == ENOENT) {
<span class="line-modified">1044       fail_continue(&quot;Specified shared archive not found (%s).&quot;, _full_path);</span>

1045     } else {
1046       fail_continue(&quot;Failed to open shared archive file (%s).&quot;,
1047                     os::strerror(errno));
1048     }
1049     return false;
1050   }
1051 
1052   _fd = fd;
1053   _file_open = true;
1054   return true;
1055 }
1056 

1057 // Write the FileMapInfo information to the file.
1058 
<span class="line-modified">1059 void FileMapInfo::open_for_write(const char* path) {</span>
<span class="line-modified">1060   if (path == NULL) {</span>
<span class="line-added">1061     _full_path = Arguments::GetSharedArchivePath();</span>
<span class="line-added">1062   } else {</span>
<span class="line-added">1063     _full_path = path;</span>
<span class="line-added">1064   }</span>
1065   LogMessage(cds) msg;
1066   if (msg.is_info()) {
1067     msg.info(&quot;Dumping shared data to file: &quot;);
1068     msg.info(&quot;   %s&quot;, _full_path);
1069   }
1070 
1071 #ifdef _WINDOWS  // On Windows, need WRITE permission to remove the file.
<span class="line-modified">1072     chmod(_full_path, _S_IREAD | _S_IWRITE);</span>
1073 #endif
1074 
1075   // Use remove() to delete the existing file because, on Unix, this will
1076   // allow processes that have it open continued access to the file.
1077   remove(_full_path);
1078   int fd = os::open(_full_path, O_RDWR | O_CREAT | O_TRUNC | O_BINARY, 0444);
1079   if (fd &lt; 0) {
1080     fail_stop(&quot;Unable to create shared archive file %s: (%s).&quot;, _full_path,
1081               os::strerror(errno));
1082   }
1083   _fd = fd;

1084   _file_open = true;
<span class="line-added">1085 </span>
<span class="line-added">1086   // Seek past the header. We will write the header after all regions are written</span>
<span class="line-added">1087   // and their CRCs computed.</span>
<span class="line-added">1088   size_t header_bytes = header()-&gt;header_size();</span>
<span class="line-added">1089   if (header()-&gt;magic() == CDS_DYNAMIC_ARCHIVE_MAGIC) {</span>
<span class="line-added">1090     header_bytes += strlen(Arguments::GetSharedArchivePath()) + 1;</span>
<span class="line-added">1091   }</span>
<span class="line-added">1092 </span>
<span class="line-added">1093   header_bytes = align_up(header_bytes, os::vm_allocation_granularity());</span>
<span class="line-added">1094   _file_offset = header_bytes;</span>
<span class="line-added">1095   seek_to_position(_file_offset);</span>
1096 }
1097 
1098 
1099 // Write the header to the file, seek to the next allocation boundary.
1100 
1101 void FileMapInfo::write_header() {
<span class="line-modified">1102   _file_offset = 0;</span>
<span class="line-added">1103   seek_to_position(_file_offset);</span>
<span class="line-added">1104   char* base_archive_name = NULL;</span>
<span class="line-added">1105   if (header()-&gt;magic() == CDS_DYNAMIC_ARCHIVE_MAGIC) {</span>
<span class="line-added">1106     base_archive_name = (char*)Arguments::GetSharedArchivePath();</span>
<span class="line-added">1107     header()-&gt;set_base_archive_name_size(strlen(base_archive_name) + 1);</span>
<span class="line-added">1108     header()-&gt;set_base_archive_is_default(FLAG_IS_DEFAULT(SharedArchiveFile));</span>
<span class="line-added">1109   }</span>
1110 
<span class="line-modified">1111   assert(is_file_position_aligned(), &quot;must be&quot;);</span>
<span class="line-added">1112   write_bytes(header(), header()-&gt;header_size());</span>
<span class="line-added">1113   if (base_archive_name != NULL) {</span>
<span class="line-added">1114     write_bytes(base_archive_name, header()-&gt;base_archive_name_size());</span>
<span class="line-added">1115   }</span>
<span class="line-added">1116 }</span>
1117 
<span class="line-modified">1118 size_t FileMapRegion::used_aligned() const {</span>
<span class="line-modified">1119   return align_up(used(), os::vm_allocation_granularity());</span>


1120 }
1121 
<span class="line-added">1122 void FileMapRegion::init(int region_index, char* base, size_t size, bool read_only,</span>
<span class="line-added">1123                          bool allow_exec, int crc) {</span>
<span class="line-added">1124   _is_heap_region = HeapShared::is_heap_region(region_index);</span>
<span class="line-added">1125   _is_bitmap_region = (region_index == MetaspaceShared::bm);</span>
<span class="line-added">1126   _mapping_offset = 0;</span>
1127 
<span class="line-modified">1128   if (_is_heap_region) {</span>
<span class="line-added">1129     assert(!DynamicDumpSharedSpaces, &quot;must be&quot;);</span>
<span class="line-added">1130     assert((base - (char*)CompressedKlassPointers::base()) % HeapWordSize == 0, &quot;Sanity&quot;);</span>
<span class="line-added">1131     if (base != NULL) {</span>
<span class="line-added">1132       _mapping_offset = (size_t)CompressedOops::encode_not_null((oop)base);</span>
<span class="line-added">1133       assert(_mapping_offset == (size_t)(uint32_t)_mapping_offset, &quot;must be 32-bit only&quot;);</span>
<span class="line-added">1134     }</span>
<span class="line-added">1135   } else {</span>
<span class="line-added">1136     if (base != NULL) {</span>
<span class="line-added">1137       assert(base &gt;= (char*)SharedBaseAddress, &quot;must be&quot;);</span>
<span class="line-added">1138       _mapping_offset = base - (char*)SharedBaseAddress;</span>
<span class="line-added">1139     }</span>
<span class="line-added">1140   }</span>
<span class="line-added">1141   _used = size;</span>
<span class="line-added">1142   _read_only = read_only;</span>
<span class="line-added">1143   _allow_exec = allow_exec;</span>
<span class="line-added">1144   _crc = crc;</span>
<span class="line-added">1145   _mapped_from_file = false;</span>
<span class="line-added">1146   _mapped_base = NULL;</span>
<span class="line-added">1147 }</span>
1148 
1149 void FileMapInfo::write_region(int region, char* base, size_t size,
1150                                bool read_only, bool allow_exec) {
<span class="line-modified">1151   Arguments::assert_is_dumping_archive();</span>
1152 
<span class="line-modified">1153   FileMapRegion* si = space_at(region);</span>
<span class="line-modified">1154   char* target_base;</span>
<span class="line-modified">1155 </span>
<span class="line-modified">1156   if (region == MetaspaceShared::bm) {</span>
<span class="line-modified">1157     target_base = NULL; // always NULL for bm region.</span>
1158   } else {
<span class="line-modified">1159     if (DynamicDumpSharedSpaces) {</span>
<span class="line-modified">1160       assert(!HeapShared::is_heap_region(region), &quot;dynamic archive doesn&#39;t support heap regions&quot;);</span>
<span class="line-modified">1161       target_base = DynamicArchive::buffer_to_target(base);</span>



1162     } else {
<span class="line-modified">1163       target_base = base;</span>
1164     }


1165   }
<span class="line-modified">1166 </span>
<span class="line-modified">1167   si-&gt;set_file_offset(_file_offset);</span>
<span class="line-modified">1168   char* requested_base = (target_base == NULL) ? NULL : target_base + MetaspaceShared::final_delta();</span>
<span class="line-modified">1169   log_debug(cds)(&quot;Shared file region  %d: &quot; SIZE_FORMAT_HEX_W(08)</span>
<span class="line-added">1170                  &quot; bytes, addr &quot; INTPTR_FORMAT &quot; file offset &quot; SIZE_FORMAT_HEX_W(08),</span>
<span class="line-added">1171                  region, size, p2i(requested_base), _file_offset);</span>
<span class="line-added">1172 </span>
<span class="line-added">1173   int crc = ClassLoader::crc32(0, base, (jint)size);</span>
<span class="line-added">1174   si-&gt;init(region, target_base, size, read_only, allow_exec, crc);</span>
<span class="line-added">1175 </span>
1176   if (base != NULL) {
1177     write_bytes_aligned(base, size);
1178   }
1179 }
1180 
<span class="line-added">1181 </span>
<span class="line-added">1182 void FileMapInfo::write_bitmap_region(const CHeapBitMap* ptrmap) {</span>
<span class="line-added">1183   ResourceMark rm;</span>
<span class="line-added">1184   size_t size_in_bits = ptrmap-&gt;size();</span>
<span class="line-added">1185   size_t size_in_bytes = ptrmap-&gt;size_in_bytes();</span>
<span class="line-added">1186   uintptr_t* buffer = (uintptr_t*)NEW_RESOURCE_ARRAY(char, size_in_bytes);</span>
<span class="line-added">1187   ptrmap-&gt;write_to(buffer, size_in_bytes);</span>
<span class="line-added">1188   header()-&gt;set_ptrmap_size_in_bits(size_in_bits);</span>
<span class="line-added">1189 </span>
<span class="line-added">1190   log_debug(cds)(&quot;ptrmap = &quot; INTPTR_FORMAT &quot; (&quot; SIZE_FORMAT &quot; bytes)&quot;,</span>
<span class="line-added">1191                  p2i(buffer), size_in_bytes);</span>
<span class="line-added">1192   write_region(MetaspaceShared::bm, (char*)buffer, size_in_bytes, /*read_only=*/true, /*allow_exec=*/false);</span>
<span class="line-added">1193 }</span>
<span class="line-added">1194 </span>
1195 // Write out the given archive heap memory regions.  GC code combines multiple
1196 // consecutive archive GC regions into one MemRegion whenever possible and
1197 // produces the &#39;heap_mem&#39; array.
1198 //
1199 // If the archive heap memory size is smaller than a single dump time GC region
1200 // size, there is only one MemRegion in the array.
1201 //
1202 // If the archive heap memory size is bigger than one dump time GC region size,
1203 // the &#39;heap_mem&#39; array may contain more than one consolidated MemRegions. When
1204 // the first/bottom archive GC region is a partial GC region (with the empty
1205 // portion at the higher address within the region), one MemRegion is used for
1206 // the bottom partial archive GC region. The rest of the consecutive archive
1207 // GC regions are combined into another MemRegion.
1208 //
1209 // Here&#39;s the mapping from (archive heap GC regions) -&gt; (GrowableArray&lt;MemRegion&gt; *regions).
1210 //   + We have 1 or more archive heap regions: ah0, ah1, ah2 ..... ahn
1211 //   + We have 1 or 2 consolidated heap memory regions: r0 and r1
1212 //
1213 // If there&#39;s a single archive GC region (ah0), then r0 == ah0, and r1 is empty.
1214 // Otherwise:
1215 //
1216 // &quot;X&quot; represented space that&#39;s occupied by heap objects.
1217 // &quot;_&quot; represented unused spaced in the heap region.
1218 //
1219 //
1220 //    |ah0       | ah1 | ah2| ...... | ahn|
1221 //    |XXXXXX|__ |XXXXX|XXXX|XXXXXXXX|XXXX|
1222 //    |&lt;-r0-&gt;|   |&lt;- r1 -----------------&gt;|
1223 //            ^^^
1224 //             |
1225 //             +-- gap
1226 size_t FileMapInfo::write_archive_heap_regions(GrowableArray&lt;MemRegion&gt; *heap_mem,
1227                                                GrowableArray&lt;ArchiveHeapOopmapInfo&gt; *oopmaps,
<span class="line-modified">1228                                                int first_region_id, int max_num_regions) {</span>

1229   assert(max_num_regions &lt;= 2, &quot;Only support maximum 2 memory regions&quot;);
1230 
1231   int arr_len = heap_mem == NULL ? 0 : heap_mem-&gt;length();
1232   if(arr_len &gt; max_num_regions) {
1233     fail_stop(&quot;Unable to write archive heap memory regions: &quot;
1234               &quot;number of memory regions exceeds maximum due to fragmentation. &quot;
1235               &quot;Please increase java heap size &quot;
1236               &quot;(current MaxHeapSize is &quot; SIZE_FORMAT &quot;, InitialHeapSize is &quot; SIZE_FORMAT &quot;).&quot;,
1237               MaxHeapSize, InitialHeapSize);
1238   }
1239 
1240   size_t total_size = 0;
1241   for (int i = first_region_id, arr_idx = 0;
1242            i &lt; first_region_id + max_num_regions;
1243            i++, arr_idx++) {
1244     char* start = NULL;
1245     size_t size = 0;
1246     if (arr_idx &lt; arr_len) {
1247       start = (char*)heap_mem-&gt;at(arr_idx).start();
1248       size = heap_mem-&gt;at(arr_idx).byte_size();
1249       total_size += size;
1250     }
1251 
<span class="line-modified">1252     log_debug(cds)(&quot;Archive heap region %d: &quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot; = &quot; SIZE_FORMAT_W(8) &quot; bytes&quot;,</span>
<span class="line-modified">1253                    i, p2i(start), p2i(start + size), size);</span>


1254     write_region(i, start, size, false, false);
1255     if (size &gt; 0) {
<span class="line-modified">1256       address oopmap = oopmaps-&gt;at(arr_idx)._oopmap;</span>
<span class="line-modified">1257       assert(oopmap &gt;= (address)SharedBaseAddress, &quot;must be&quot;);</span>
<span class="line-added">1258       space_at(i)-&gt;init_oopmap(oopmap - (address)SharedBaseAddress,</span>
<span class="line-added">1259                                oopmaps-&gt;at(arr_idx)._oopmap_size_in_bits);</span>
1260     }
1261   }
1262   return total_size;
1263 }
1264 
1265 // Dump bytes to file -- at the current file position.
1266 
1267 void FileMapInfo::write_bytes(const void* buffer, size_t nbytes) {
<span class="line-modified">1268   assert(_file_open, &quot;must be&quot;);</span>
<span class="line-modified">1269   size_t n = os::write(_fd, buffer, (unsigned int)nbytes);</span>
<span class="line-modified">1270   if (n != nbytes) {</span>
<span class="line-modified">1271     // If the shared archive is corrupted, close it and remove it.</span>
<span class="line-modified">1272     close();</span>
<span class="line-modified">1273     remove(_full_path);</span>
<span class="line-modified">1274     fail_stop(&quot;Unable to write to shared archive file.&quot;);</span>


1275   }
1276   _file_offset += nbytes;
1277 }
1278 
<span class="line-added">1279 bool FileMapInfo::is_file_position_aligned() const {</span>
<span class="line-added">1280   return _file_offset == align_up(_file_offset,</span>
<span class="line-added">1281                                   os::vm_allocation_granularity());</span>
<span class="line-added">1282 }</span>
1283 
1284 // Align file position to an allocation unit boundary.
1285 
1286 void FileMapInfo::align_file_position() {
<span class="line-added">1287   assert(_file_open, &quot;must be&quot;);</span>
1288   size_t new_file_offset = align_up(_file_offset,
<span class="line-modified">1289                                     os::vm_allocation_granularity());</span>
1290   if (new_file_offset != _file_offset) {
1291     _file_offset = new_file_offset;
<span class="line-modified">1292     // Seek one byte back from the target and write a byte to insure</span>
<span class="line-modified">1293     // that the written file is the correct length.</span>
<span class="line-modified">1294     _file_offset -= 1;</span>
<span class="line-modified">1295     seek_to_position(_file_offset);</span>
<span class="line-modified">1296     char zero = 0;</span>
<span class="line-modified">1297     write_bytes(&amp;zero, 1);</span>




1298   }
1299 }
1300 
1301 
1302 // Dump bytes to file -- at the current file position.
1303 
1304 void FileMapInfo::write_bytes_aligned(const void* buffer, size_t nbytes) {
1305   align_file_position();
1306   write_bytes(buffer, nbytes);
1307   align_file_position();
1308 }
1309 
<span class="line-added">1310 void FileMapInfo::set_final_requested_base(char* b) {</span>
<span class="line-added">1311   header()-&gt;set_final_requested_base(b);</span>
<span class="line-added">1312 }</span>
1313 
1314 // Close the shared archive file.  This does NOT unmap mapped regions.
1315 
1316 void FileMapInfo::close() {
1317   if (_file_open) {
1318     if (::close(_fd) &lt; 0) {
1319       fail_stop(&quot;Unable to close the shared archive file.&quot;);
1320     }
1321     _file_open = false;
1322     _fd = -1;
1323   }
1324 }
1325 
1326 
1327 // JVM/TI RedefineClasses() support:
1328 // Remap the shared readonly space to shared readwrite, private.
1329 bool FileMapInfo::remap_shared_readonly_as_readwrite() {
1330   int idx = MetaspaceShared::ro;
<span class="line-modified">1331   FileMapRegion* si = space_at(idx);</span>
<span class="line-modified">1332   if (!si-&gt;read_only()) {</span>
1333     // the space is already readwrite so we are done
1334     return true;
1335   }
<span class="line-modified">1336   size_t used = si-&gt;used();</span>
1337   size_t size = align_up(used, os::vm_allocation_granularity());
1338   if (!open_for_read()) {
1339     return false;
1340   }
1341   char *addr = region_addr(idx);
<span class="line-modified">1342   char *base = os::remap_memory(_fd, _full_path, si-&gt;file_offset(),</span>
1343                                 addr, size, false /* !read_only */,
<span class="line-modified">1344                                 si-&gt;allow_exec());</span>
1345   close();
<span class="line-added">1346   // These have to be errors because the shared region is now unmapped.</span>
1347   if (base == NULL) {
<span class="line-modified">1348     log_error(cds)(&quot;Unable to remap shared readonly space (errno=%d).&quot;, errno);</span>
<span class="line-modified">1349     vm_exit(1);</span>
1350   }
1351   if (base != addr) {
<span class="line-modified">1352     log_error(cds)(&quot;Unable to remap shared readonly space (errno=%d).&quot;, errno);</span>
<span class="line-added">1353     vm_exit(1);</span>
<span class="line-added">1354   }</span>
<span class="line-added">1355   si-&gt;set_read_only(false);</span>
<span class="line-added">1356   return true;</span>
<span class="line-added">1357 }</span>
<span class="line-added">1358 </span>
<span class="line-added">1359 // Memory map a region in the address space.</span>
<span class="line-added">1360 static const char* shared_region_name[] = { &quot;MiscCode&quot;, &quot;ReadWrite&quot;, &quot;ReadOnly&quot;, &quot;Bitmap&quot;,</span>
<span class="line-added">1361                                             &quot;String1&quot;, &quot;String2&quot;, &quot;OpenArchive1&quot;, &quot;OpenArchive2&quot; };</span>
<span class="line-added">1362 </span>
<span class="line-added">1363 MapArchiveResult FileMapInfo::map_regions(int regions[], int num_regions, char* mapped_base_address, ReservedSpace rs) {</span>
<span class="line-added">1364   DEBUG_ONLY(FileMapRegion* last_region = NULL);</span>
<span class="line-added">1365   intx addr_delta = mapped_base_address - header()-&gt;requested_base_address();</span>
<span class="line-added">1366 </span>
<span class="line-added">1367   // Make sure we don&#39;t attempt to use header()-&gt;mapped_base_address() unless</span>
<span class="line-added">1368   // it&#39;s been successfully mapped.</span>
<span class="line-added">1369   DEBUG_ONLY(header()-&gt;set_mapped_base_address((char*)(uintptr_t)0xdeadbeef);)</span>
<span class="line-added">1370 </span>
<span class="line-added">1371   for (int r = 0; r &lt; num_regions; r++) {</span>
<span class="line-added">1372     int idx = regions[r];</span>
<span class="line-added">1373     MapArchiveResult result = map_region(idx, addr_delta, mapped_base_address, rs);</span>
<span class="line-added">1374     if (result != MAP_ARCHIVE_SUCCESS) {</span>
<span class="line-added">1375       return result;</span>
<span class="line-added">1376     }</span>
<span class="line-added">1377     FileMapRegion* si = space_at(idx);</span>
<span class="line-added">1378     DEBUG_ONLY(if (last_region != NULL) {</span>
<span class="line-added">1379         // Ensure that the OS won&#39;t be able to allocate new memory spaces between any mapped</span>
<span class="line-added">1380         // regions, or else it would mess up the simple comparision in MetaspaceObj::is_shared().</span>
<span class="line-added">1381         assert(si-&gt;mapped_base() == last_region-&gt;mapped_end(), &quot;must have no gaps&quot;);</span>
<span class="line-added">1382       }</span>
<span class="line-added">1383       last_region = si;)</span>
<span class="line-added">1384     log_info(cds)(&quot;Mapped %s region #%d at base &quot; INTPTR_FORMAT &quot; top &quot; INTPTR_FORMAT &quot; (%s)&quot;, is_static() ? &quot;static &quot; : &quot;dynamic&quot;,</span>
<span class="line-added">1385                   idx, p2i(si-&gt;mapped_base()), p2i(si-&gt;mapped_end()),</span>
<span class="line-added">1386                   shared_region_name[idx]);</span>
<span class="line-added">1387 </span>
<span class="line-added">1388   }</span>
<span class="line-added">1389 </span>
<span class="line-added">1390   header()-&gt;set_mapped_base_address(header()-&gt;requested_base_address() + addr_delta);</span>
<span class="line-added">1391   if (addr_delta != 0 &amp;&amp; !relocate_pointers(addr_delta)) {</span>
<span class="line-added">1392     return MAP_ARCHIVE_OTHER_FAILURE;</span>
<span class="line-added">1393   }</span>
<span class="line-added">1394 </span>
<span class="line-added">1395   return MAP_ARCHIVE_SUCCESS;</span>
<span class="line-added">1396 }</span>
<span class="line-added">1397 </span>
<span class="line-added">1398 bool FileMapInfo::read_region(int i, char* base, size_t size) {</span>
<span class="line-added">1399   assert(MetaspaceShared::use_windows_memory_mapping(), &quot;used by windows only&quot;);</span>
<span class="line-added">1400   FileMapRegion* si = space_at(i);</span>
<span class="line-added">1401   log_info(cds)(&quot;Commit %s region #%d at base &quot; INTPTR_FORMAT &quot; top &quot; INTPTR_FORMAT &quot; (%s)%s&quot;,</span>
<span class="line-added">1402                 is_static() ? &quot;static &quot; : &quot;dynamic&quot;, i, p2i(base), p2i(base + size),</span>
<span class="line-added">1403                 shared_region_name[i], si-&gt;allow_exec() ? &quot; exec&quot; : &quot;&quot;);</span>
<span class="line-added">1404   if (!os::commit_memory(base, size, si-&gt;allow_exec())) {</span>
<span class="line-added">1405     log_error(cds)(&quot;Failed to commit %s region #%d (%s)&quot;, is_static() ? &quot;static &quot; : &quot;dynamic&quot;,</span>
<span class="line-added">1406                    i, shared_region_name[i]);</span>
<span class="line-added">1407     return false;</span>
<span class="line-added">1408   }</span>
<span class="line-added">1409   if (lseek(_fd, (long)si-&gt;file_offset(), SEEK_SET) != (int)si-&gt;file_offset() ||</span>
<span class="line-added">1410       read_bytes(base, size) != size) {</span>
1411     return false;
1412   }

1413   return true;
1414 }
1415 
<span class="line-modified">1416 MapArchiveResult FileMapInfo::map_region(int i, intx addr_delta, char* mapped_base_address, ReservedSpace rs) {</span>
<span class="line-modified">1417   assert(!HeapShared::is_heap_region(i), &quot;sanity&quot;);</span>
<span class="line-modified">1418   FileMapRegion* si = space_at(i);</span>
<span class="line-modified">1419   size_t size = si-&gt;used_aligned();</span>
<span class="line-added">1420   char *requested_addr = mapped_base_address + si-&gt;mapping_offset();</span>
<span class="line-added">1421   assert(si-&gt;mapped_base() == NULL, &quot;must be not mapped yet&quot;);</span>
<span class="line-added">1422   assert(requested_addr != NULL, &quot;must be specified&quot;);</span>
<span class="line-added">1423 </span>
<span class="line-added">1424   si-&gt;set_mapped_from_file(false);</span>
<span class="line-added">1425 </span>
<span class="line-added">1426   if (MetaspaceShared::use_windows_memory_mapping()) {</span>
<span class="line-added">1427     // Windows cannot remap read-only shared memory to read-write when required for</span>
<span class="line-added">1428     // RedefineClasses, which is also used by JFR.  Always map windows regions as RW.</span>
<span class="line-added">1429     si-&gt;set_read_only(false);</span>
<span class="line-added">1430   } else if (JvmtiExport::can_modify_any_class() || JvmtiExport::can_walk_any_space() ||</span>
<span class="line-added">1431              Arguments::has_jfr_option()) {</span>
<span class="line-added">1432     // If a tool agent is in use (debugging enabled), or JFR, we must map the address space RW</span>
<span class="line-added">1433     si-&gt;set_read_only(false);</span>
<span class="line-added">1434   } else if (addr_delta != 0) {</span>
<span class="line-added">1435     si-&gt;set_read_only(false); // Need to patch the pointers</span>
<span class="line-added">1436   }</span>
<span class="line-added">1437 </span>
<span class="line-added">1438   if (rs.is_reserved()) {</span>
<span class="line-added">1439     assert(rs.contains(requested_addr) &amp;&amp; rs.contains(requested_addr + size - 1), &quot;must be&quot;);</span>
<span class="line-added">1440     MemTracker::record_virtual_memory_type((address)requested_addr, mtClassShared);</span>
<span class="line-added">1441   }</span>
<span class="line-added">1442 </span>
<span class="line-added">1443   if (MetaspaceShared::use_windows_memory_mapping() &amp;&amp; rs.is_reserved()) {</span>
<span class="line-added">1444     // This is the second time we try to map the archive(s). We have already created a ReservedSpace</span>
<span class="line-added">1445     // that covers all the FileMapRegions to ensure all regions can be mapped. However, Windows</span>
<span class="line-added">1446     // can&#39;t mmap into a ReservedSpace, so we just os::read() the data. We&#39;re going to patch all the</span>
<span class="line-added">1447     // regions anyway, so there&#39;s no benefit for mmap anyway.</span>
<span class="line-added">1448     if (!read_region(i, requested_addr, size)) {</span>
<span class="line-added">1449       log_info(cds)(&quot;Failed to read %s shared space into reserved space at &quot; INTPTR_FORMAT,</span>
<span class="line-added">1450                     shared_region_name[i], p2i(requested_addr));</span>
<span class="line-added">1451       return MAP_ARCHIVE_OTHER_FAILURE; // oom or I/O error.</span>
<span class="line-added">1452     }</span>
<span class="line-added">1453   } else {</span>
<span class="line-added">1454     char* base = os::map_memory(_fd, _full_path, si-&gt;file_offset(),</span>
<span class="line-added">1455                                 requested_addr, size, si-&gt;read_only(),</span>
<span class="line-added">1456                                 si-&gt;allow_exec());</span>
<span class="line-added">1457     if (base != requested_addr) {</span>
<span class="line-added">1458       log_info(cds)(&quot;Unable to map %s shared space at &quot; INTPTR_FORMAT,</span>
<span class="line-added">1459                     shared_region_name[i], p2i(requested_addr));</span>
<span class="line-added">1460       _memory_mapping_failed = true;</span>
<span class="line-added">1461       return MAP_ARCHIVE_MMAP_FAILURE;</span>
<span class="line-added">1462     }</span>
<span class="line-added">1463     si-&gt;set_mapped_from_file(true);</span>
<span class="line-added">1464   }</span>
<span class="line-added">1465   si-&gt;set_mapped_base(requested_addr);</span>
1466 



1467   if (!rs.is_reserved()) {
<span class="line-modified">1468     // When mapping on Windows for the first attempt, we don&#39;t reserve the address space for the regions</span>
<span class="line-modified">1469     // (Windows can&#39;t mmap into a ReservedSpace). In this case, NMT requires we call it after</span>
<span class="line-modified">1470     // os::map_memory has succeeded.</span>
<span class="line-added">1471     assert(MetaspaceShared::use_windows_memory_mapping(), &quot;Windows memory mapping only&quot;);</span>
<span class="line-added">1472     MemTracker::record_virtual_memory_type((address)requested_addr, mtClassShared);</span>
1473   }


1474 
<span class="line-modified">1475   if (VerifySharedSpaces &amp;&amp; !verify_region_checksum(i)) {</span>
<span class="line-added">1476     return MAP_ARCHIVE_OTHER_FAILURE;</span>
<span class="line-added">1477   }</span>
<span class="line-added">1478 </span>
<span class="line-added">1479   return MAP_ARCHIVE_SUCCESS;</span>
1480 }
1481 
<span class="line-modified">1482 char* FileMapInfo::map_relocation_bitmap(size_t&amp; bitmap_size) {</span>
<span class="line-modified">1483   FileMapRegion* si = space_at(MetaspaceShared::bm);</span>
<span class="line-modified">1484   bitmap_size = si-&gt;used_aligned();</span>
<span class="line-added">1485   bool read_only = true, allow_exec = false;</span>
<span class="line-added">1486   char* requested_addr = NULL; // allow OS to pick any location</span>
<span class="line-added">1487   char* bitmap_base = os::map_memory(_fd, _full_path, si-&gt;file_offset(),</span>
<span class="line-added">1488                                      requested_addr, bitmap_size, read_only, allow_exec);</span>
<span class="line-added">1489   if (bitmap_base == NULL) {</span>
<span class="line-added">1490     log_error(cds)(&quot;failed to map relocation bitmap&quot;);</span>
<span class="line-added">1491     return NULL;</span>
<span class="line-added">1492   }</span>
1493 
<span class="line-modified">1494   if (VerifySharedSpaces &amp;&amp; !region_crc_check(bitmap_base, bitmap_size, si-&gt;crc())) {</span>
<span class="line-modified">1495     log_error(cds)(&quot;relocation bitmap CRC error&quot;);</span>
<span class="line-modified">1496     if (!os::unmap_memory(bitmap_base, bitmap_size)) {</span>
<span class="line-modified">1497       fatal(&quot;os::unmap_memory of relocation bitmap failed&quot;);</span>
<span class="line-modified">1498     }</span>














1499     return NULL;
1500   }





1501 
<span class="line-added">1502   return bitmap_base;</span>
<span class="line-added">1503 }</span>
1504 
<span class="line-modified">1505 bool FileMapInfo::relocate_pointers(intx addr_delta) {</span>
<span class="line-modified">1506   log_debug(cds, reloc)(&quot;runtime archive relocation start&quot;);</span>
<span class="line-added">1507   size_t bitmap_size;</span>
<span class="line-added">1508   char* bitmap_base = map_relocation_bitmap(bitmap_size);</span>
<span class="line-added">1509 </span>
<span class="line-added">1510   if (bitmap_base == NULL) {</span>
<span class="line-added">1511     return false;</span>
<span class="line-added">1512   } else {</span>
<span class="line-added">1513     size_t ptrmap_size_in_bits = header()-&gt;ptrmap_size_in_bits();</span>
<span class="line-added">1514     log_debug(cds, reloc)(&quot;mapped relocation bitmap @ &quot; INTPTR_FORMAT &quot; (&quot; SIZE_FORMAT</span>
<span class="line-added">1515                           &quot; bytes = &quot; SIZE_FORMAT &quot; bits)&quot;,</span>
<span class="line-added">1516                           p2i(bitmap_base), bitmap_size, ptrmap_size_in_bits);</span>
<span class="line-added">1517 </span>
<span class="line-added">1518     BitMapView ptrmap((BitMap::bm_word_t*)bitmap_base, ptrmap_size_in_bits);</span>
<span class="line-added">1519 </span>
<span class="line-added">1520     // Patch all pointers in the the mapped region that are marked by ptrmap.</span>
<span class="line-added">1521     address patch_base = (address)mapped_base();</span>
<span class="line-added">1522     address patch_end  = (address)mapped_end();</span>
<span class="line-added">1523 </span>
<span class="line-added">1524     // the current value of the pointers to be patched must be within this</span>
<span class="line-added">1525     // range (i.e., must be between the requesed base address, and the of the current archive).</span>
<span class="line-added">1526     // Note: top archive may point to objects in the base archive, but not the other way around.</span>
<span class="line-added">1527     address valid_old_base = (address)header()-&gt;requested_base_address();</span>
<span class="line-added">1528     address valid_old_end  = valid_old_base + mapping_end_offset();</span>
<span class="line-added">1529 </span>
<span class="line-added">1530     // after patching, the pointers must point inside this range</span>
<span class="line-added">1531     // (the requested location of the archive, as mapped at runtime).</span>
<span class="line-added">1532     address valid_new_base = (address)header()-&gt;mapped_base_address();</span>
<span class="line-added">1533     address valid_new_end  = (address)mapped_end();</span>
<span class="line-added">1534 </span>
<span class="line-added">1535     SharedDataRelocator&lt;false&gt; patcher((address*)patch_base, (address*)patch_end, valid_old_base, valid_old_end,</span>
<span class="line-added">1536                                        valid_new_base, valid_new_end, addr_delta);</span>
<span class="line-added">1537     ptrmap.iterate(&amp;patcher);</span>
<span class="line-added">1538 </span>
<span class="line-added">1539     if (!os::unmap_memory(bitmap_base, bitmap_size)) {</span>
<span class="line-added">1540       fatal(&quot;os::unmap_memory of relocation bitmap failed&quot;);</span>
<span class="line-added">1541     }</span>
<span class="line-added">1542     log_debug(cds, reloc)(&quot;runtime archive relocation done&quot;);</span>
<span class="line-added">1543     return true;</span>
1544   }
<span class="line-added">1545 }</span>
1546 
<span class="line-modified">1547 size_t FileMapInfo::read_bytes(void* buffer, size_t count) {</span>
<span class="line-modified">1548   assert(_file_open, &quot;Archive file is not open&quot;);</span>
<span class="line-added">1549   size_t n = os::read(_fd, buffer, (unsigned int)count);</span>
<span class="line-added">1550   if (n != count) {</span>
<span class="line-added">1551     // Close the file if there&#39;s a problem reading it.</span>
<span class="line-added">1552     close();</span>
<span class="line-added">1553     return 0;</span>
<span class="line-added">1554   }</span>
<span class="line-added">1555   _file_offset += count;</span>
<span class="line-added">1556   return count;</span>
1557 }
1558 
<span class="line-modified">1559 address FileMapInfo::decode_start_address(FileMapRegion* spc, bool with_current_oop_encoding_mode) {</span>
<span class="line-added">1560   size_t offset = spc-&gt;mapping_offset();</span>
<span class="line-added">1561   assert(offset == (size_t)(uint32_t)offset, &quot;must be 32-bit only&quot;);</span>
<span class="line-added">1562   uint n = (uint)offset;</span>
1563   if (with_current_oop_encoding_mode) {
<span class="line-modified">1564     return cast_from_oop&lt;address&gt;(CompressedOops::decode_not_null(n));</span>
1565   } else {
<span class="line-modified">1566     return cast_from_oop&lt;address&gt;(HeapShared::decode_from_archive(n));</span>
1567   }
1568 }
1569 
1570 static MemRegion *closed_archive_heap_ranges = NULL;
1571 static MemRegion *open_archive_heap_ranges = NULL;
1572 static int num_closed_archive_heap_ranges = 0;
1573 static int num_open_archive_heap_ranges = 0;
1574 
1575 #if INCLUDE_CDS_JAVA_HEAP
1576 bool FileMapInfo::has_heap_regions() {
<span class="line-modified">1577   return (space_at(MetaspaceShared::first_closed_archive_heap_region)-&gt;used() &gt; 0);</span>
1578 }
1579 
1580 // Returns the address range of the archived heap regions computed using the
1581 // current oop encoding mode. This range may be different than the one seen at
1582 // dump time due to encoding mode differences. The result is used in determining
1583 // if/how these regions should be relocated at run time.
1584 MemRegion FileMapInfo::get_heap_regions_range_with_current_oop_encoding_mode() {
1585   address start = (address) max_uintx;
1586   address end   = NULL;
1587 
1588   for (int i = MetaspaceShared::first_closed_archive_heap_region;
1589            i &lt;= MetaspaceShared::last_valid_region;
1590            i++) {
<span class="line-modified">1591     FileMapRegion* si = space_at(i);</span>
<span class="line-modified">1592     size_t size = si-&gt;used();</span>
1593     if (size &gt; 0) {
1594       address s = start_address_as_decoded_with_current_oop_encoding_mode(si);
1595       address e = s + size;
1596       if (start &gt; s) {
1597         start = s;
1598       }
1599       if (end &lt; e) {
1600         end = e;
1601       }
1602     }
1603   }
1604   assert(end != NULL, &quot;must have at least one used heap region&quot;);
1605   return MemRegion((HeapWord*)start, (HeapWord*)end);
1606 }
1607 
1608 //
1609 // Map the closed and open archive heap objects to the runtime java heap.
1610 //
1611 // The shared objects are mapped at (or close to ) the java heap top in
1612 // closed archive regions. The mapped objects contain no out-going
</pre>
<hr />
<pre>
1622 void FileMapInfo::map_heap_regions_impl() {
1623   if (!HeapShared::is_heap_object_archiving_allowed()) {
1624     log_info(cds)(&quot;CDS heap data is being ignored. UseG1GC, &quot;
1625                   &quot;UseCompressedOops and UseCompressedClassPointers are required.&quot;);
1626     return;
1627   }
1628 
1629   if (JvmtiExport::should_post_class_file_load_hook() &amp;&amp; JvmtiExport::has_early_class_hook_env()) {
1630     ShouldNotReachHere(); // CDS should have been disabled.
1631     // The archived objects are mapped at JVM start-up, but we don&#39;t know if
1632     // j.l.String or j.l.Class might be replaced by the ClassFileLoadHook,
1633     // which would make the archived String or mirror objects invalid. Let&#39;s be safe and not
1634     // use the archived objects. These 2 classes are loaded during the JVMTI &quot;early&quot; stage.
1635     //
1636     // If JvmtiExport::has_early_class_hook_env() is false, the classes of some objects
1637     // in the archived subgraphs may be replaced by the ClassFileLoadHook. But that&#39;s OK
1638     // because we won&#39;t install an archived object subgraph if the klass of any of the
1639     // referenced objects are replaced. See HeapShared::initialize_from_archived_subgraph().
1640   }
1641 


1642   log_info(cds)(&quot;CDS archive was created with max heap size = &quot; SIZE_FORMAT &quot;M, and the following configuration:&quot;,
1643                 max_heap_size()/M);
1644   log_info(cds)(&quot;    narrow_klass_base = &quot; PTR_FORMAT &quot;, narrow_klass_shift = %d&quot;,
1645                 p2i(narrow_klass_base()), narrow_klass_shift());
1646   log_info(cds)(&quot;    narrow_oop_mode = %d, narrow_oop_base = &quot; PTR_FORMAT &quot;, narrow_oop_shift = %d&quot;,
1647                 narrow_oop_mode(), p2i(narrow_oop_base()), narrow_oop_shift());
1648 
1649   log_info(cds)(&quot;The current max heap size = &quot; SIZE_FORMAT &quot;M, HeapRegion::GrainBytes = &quot; SIZE_FORMAT,
<span class="line-modified">1650                 MaxHeapSize/M, HeapRegion::GrainBytes);</span>
1651   log_info(cds)(&quot;    narrow_klass_base = &quot; PTR_FORMAT &quot;, narrow_klass_shift = %d&quot;,
<span class="line-modified">1652                 p2i(CompressedKlassPointers::base()), CompressedKlassPointers::shift());</span>
1653   log_info(cds)(&quot;    narrow_oop_mode = %d, narrow_oop_base = &quot; PTR_FORMAT &quot;, narrow_oop_shift = %d&quot;,
<span class="line-modified">1654                 CompressedOops::mode(), p2i(CompressedOops::base()), CompressedOops::shift());</span>
1655 
<span class="line-modified">1656   if (narrow_klass_base() != CompressedKlassPointers::base() ||</span>
<span class="line-modified">1657       narrow_klass_shift() != CompressedKlassPointers::shift()) {</span>
1658     log_info(cds)(&quot;CDS heap data cannot be used because the archive was created with an incompatible narrow klass encoding mode.&quot;);
1659     return;
1660   }
1661 
<span class="line-modified">1662   if (narrow_oop_mode() != CompressedOops::mode() ||</span>
<span class="line-modified">1663       narrow_oop_base() != CompressedOops::base() ||</span>
<span class="line-modified">1664       narrow_oop_shift() != CompressedOops::shift()) {</span>
1665     log_info(cds)(&quot;CDS heap data need to be relocated because the archive was created with an incompatible oop encoding mode.&quot;);
1666     _heap_pointers_need_patching = true;
1667   } else {
1668     MemRegion range = get_heap_regions_range_with_current_oop_encoding_mode();
<span class="line-modified">1669     if (!CompressedOops::is_in(range)) {</span>
1670       log_info(cds)(&quot;CDS heap data need to be relocated because&quot;);
1671       log_info(cds)(&quot;the desired range &quot; PTR_FORMAT &quot; - &quot;  PTR_FORMAT, p2i(range.start()), p2i(range.end()));
<span class="line-modified">1672       log_info(cds)(&quot;is outside of the heap &quot; PTR_FORMAT &quot; - &quot;  PTR_FORMAT, p2i(CompressedOops::begin()), p2i(CompressedOops::end()));</span>
1673       _heap_pointers_need_patching = true;
1674     }
1675   }
1676 
1677   ptrdiff_t delta = 0;
1678   if (_heap_pointers_need_patching) {
1679     //   dumptime heap end  ------------v
1680     //   [      |archived heap regions| ]         runtime heap end ------v
1681     //                                       [   |archived heap regions| ]
1682     //                                  |&lt;-----delta--------------------&gt;|
1683     //
1684     // At dump time, the archived heap regions were near the top of the heap.
1685     // At run time, they may not be inside the heap, so we move them so
1686     // that they are now near the top of the runtime time. This can be done by
1687     // the simple math of adding the delta as shown above.
<span class="line-modified">1688     address dumptime_heap_end = header()-&gt;heap_end();</span>
<span class="line-modified">1689     address runtime_heap_end = (address)CompressedOops::end();</span>
1690     delta = runtime_heap_end - dumptime_heap_end;
1691   }
1692 
1693   log_info(cds)(&quot;CDS heap data relocation delta = &quot; INTX_FORMAT &quot; bytes&quot;, delta);
1694   HeapShared::init_narrow_oop_decoding(narrow_oop_base() + delta, narrow_oop_shift());
1695 
<span class="line-modified">1696   FileMapRegion* si = space_at(MetaspaceShared::first_closed_archive_heap_region);</span>
1697   address relocated_closed_heap_region_bottom = start_address_as_decoded_from_archive(si);
1698   if (!is_aligned(relocated_closed_heap_region_bottom, HeapRegion::GrainBytes)) {
1699     // Align the bottom of the closed archive heap regions at G1 region boundary.
1700     // This will avoid the situation where the highest open region and the lowest
1701     // closed region sharing the same G1 region. Otherwise we will fail to map the
1702     // open regions.
1703     size_t align = size_t(relocated_closed_heap_region_bottom) % HeapRegion::GrainBytes;
1704     delta -= align;
1705     log_info(cds)(&quot;CDS heap data need to be relocated lower by a further &quot; SIZE_FORMAT
1706                   &quot; bytes to &quot; INTX_FORMAT &quot; to be aligned with HeapRegion::GrainBytes&quot;,
1707                   align, delta);
1708     HeapShared::init_narrow_oop_decoding(narrow_oop_base() + delta, narrow_oop_shift());
1709     _heap_pointers_need_patching = true;
1710     relocated_closed_heap_region_bottom = start_address_as_decoded_from_archive(si);
1711   }
1712   assert(is_aligned(relocated_closed_heap_region_bottom, HeapRegion::GrainBytes),
1713          &quot;must be&quot;);
1714 
1715   // Map the closed_archive_heap regions, GC does not write into the regions.
1716   if (map_heap_data(&amp;closed_archive_heap_ranges,
</pre>
<hr />
<pre>
1730   }
1731 }
1732 
1733 void FileMapInfo::map_heap_regions() {
1734   if (has_heap_regions()) {
1735     map_heap_regions_impl();
1736   }
1737 
1738   if (!HeapShared::closed_archive_heap_region_mapped()) {
1739     assert(closed_archive_heap_ranges == NULL &amp;&amp;
1740            num_closed_archive_heap_ranges == 0, &quot;sanity&quot;);
1741   }
1742 
1743   if (!HeapShared::open_archive_heap_region_mapped()) {
1744     assert(open_archive_heap_ranges == NULL &amp;&amp; num_open_archive_heap_ranges == 0, &quot;sanity&quot;);
1745   }
1746 }
1747 
1748 bool FileMapInfo::map_heap_data(MemRegion **heap_mem, int first,
1749                                 int max, int* num, bool is_open_archive) {
<span class="line-modified">1750   MemRegion* regions = MemRegion::create_array(max, mtInternal);</span>
<span class="line-modified">1751 </span>
<span class="line-added">1752   struct Cleanup {</span>
<span class="line-added">1753     MemRegion* _regions;</span>
<span class="line-added">1754     bool _aborted;</span>
<span class="line-added">1755     Cleanup(MemRegion* regions) : _regions(regions), _aborted(true) { }</span>
<span class="line-added">1756     ~Cleanup() { if (_aborted) { FREE_C_HEAP_ARRAY(MemRegion, _regions); } }</span>
<span class="line-added">1757   } cleanup(regions);</span>
<span class="line-added">1758 </span>
<span class="line-added">1759   FileMapRegion* si;</span>
1760   int region_num = 0;
1761 
1762   for (int i = first;
1763            i &lt; first + max; i++) {
1764     si = space_at(i);
<span class="line-modified">1765     size_t size = si-&gt;used();</span>
1766     if (size &gt; 0) {
1767       HeapWord* start = (HeapWord*)start_address_as_decoded_from_archive(si);
1768       regions[region_num] = MemRegion(start, size / HeapWordSize);
1769       region_num ++;
1770       log_info(cds)(&quot;Trying to map heap data: region[%d] at &quot; INTPTR_FORMAT &quot;, size = &quot; SIZE_FORMAT_W(8) &quot; bytes&quot;,
1771                     i, p2i(start), size);
1772     }
1773   }
1774 
1775   if (region_num == 0) {
1776     return false; // no archived java heap data
1777   }
1778 
1779   // Check that ranges are within the java heap
1780   if (!G1CollectedHeap::heap()-&gt;check_archive_addresses(regions, region_num)) {
1781     log_info(cds)(&quot;UseSharedSpaces: Unable to allocate region, range is not within java heap.&quot;);
1782     return false;
1783   }
1784 
1785   // allocate from java heap
1786   if (!G1CollectedHeap::heap()-&gt;alloc_archive_regions(
1787              regions, region_num, is_open_archive)) {
1788     log_info(cds)(&quot;UseSharedSpaces: Unable to allocate region, java heap range is already in use.&quot;);
1789     return false;
1790   }
1791 
1792   // Map the archived heap data. No need to call MemTracker::record_virtual_memory_type()
1793   // for mapped regions as they are part of the reserved java heap, which is
1794   // already recorded.
1795   for (int i = 0; i &lt; region_num; i++) {
1796     si = space_at(first + i);
1797     char* addr = (char*)regions[i].start();
<span class="line-modified">1798     char* base = os::map_memory(_fd, _full_path, si-&gt;file_offset(),</span>
<span class="line-modified">1799                                 addr, regions[i].byte_size(), si-&gt;read_only(),</span>
<span class="line-modified">1800                                 si-&gt;allow_exec());</span>
1801     if (base == NULL || base != addr) {
1802       // dealloc the regions from java heap
<span class="line-modified">1803       dealloc_archive_heap_regions(regions, region_num);</span>
1804       log_info(cds)(&quot;UseSharedSpaces: Unable to map at required address in java heap. &quot;
1805                     INTPTR_FORMAT &quot;, size = &quot; SIZE_FORMAT &quot; bytes&quot;,
1806                     p2i(addr), regions[i].byte_size());
1807       return false;
1808     }

1809 
<span class="line-modified">1810     if (VerifySharedSpaces &amp;&amp; !region_crc_check(addr, regions[i].byte_size(), si-&gt;crc())) {</span>
<span class="line-modified">1811       // dealloc the regions from java heap</span>
<span class="line-modified">1812       dealloc_archive_heap_regions(regions, region_num);</span>
<span class="line-modified">1813       log_info(cds)(&quot;UseSharedSpaces: mapped heap regions are corrupt&quot;);</span>
<span class="line-modified">1814       return false;</span>
<span class="line-added">1815     }</span>
1816   }
1817 
<span class="line-added">1818   cleanup._aborted = false;</span>
1819   // the shared heap data is mapped successfully
1820   *heap_mem = regions;
1821   *num = region_num;
1822   return true;
1823 }
1824 










1825 void FileMapInfo::patch_archived_heap_embedded_pointers() {
1826   if (!_heap_pointers_need_patching) {
1827     return;
1828   }
1829 
1830   patch_archived_heap_embedded_pointers(closed_archive_heap_ranges,
1831                                         num_closed_archive_heap_ranges,
1832                                         MetaspaceShared::first_closed_archive_heap_region);
1833 
1834   patch_archived_heap_embedded_pointers(open_archive_heap_ranges,
1835                                         num_open_archive_heap_ranges,
1836                                         MetaspaceShared::first_open_archive_heap_region);
1837 }
1838 
1839 void FileMapInfo::patch_archived_heap_embedded_pointers(MemRegion* ranges, int num_ranges,
1840                                                         int first_region_idx) {
1841   for (int i=0; i&lt;num_ranges; i++) {
<span class="line-modified">1842     FileMapRegion* si = space_at(i + first_region_idx);</span>
<span class="line-modified">1843     HeapShared::patch_archived_heap_embedded_pointers(ranges[i], (address)(SharedBaseAddress + si-&gt;oopmap_offset()),</span>
<span class="line-modified">1844                                                       si-&gt;oopmap_size_in_bits());</span>
1845   }
1846 }
1847 
1848 // This internally allocates objects using SystemDictionary::Object_klass(), so it
1849 // must be called after the well-known classes are resolved.
1850 void FileMapInfo::fixup_mapped_heap_regions() {
1851   // If any closed regions were found, call the fill routine to make them parseable.
1852   // Note that closed_archive_heap_ranges may be non-NULL even if no ranges were found.
1853   if (num_closed_archive_heap_ranges != 0) {
1854     assert(closed_archive_heap_ranges != NULL,
1855            &quot;Null closed_archive_heap_ranges array with non-zero count&quot;);
1856     G1CollectedHeap::heap()-&gt;fill_archive_regions(closed_archive_heap_ranges,
1857                                                   num_closed_archive_heap_ranges);
1858   }
1859 
1860   // do the same for mapped open archive heap regions
1861   if (num_open_archive_heap_ranges != 0) {
1862     assert(open_archive_heap_ranges != NULL, &quot;NULL open_archive_heap_ranges array with non-zero count&quot;);
1863     G1CollectedHeap::heap()-&gt;fill_archive_regions(open_archive_heap_ranges,
1864                                                   num_open_archive_heap_ranges);
1865   }
1866 }
1867 
1868 // dealloc the archive regions from java heap
<span class="line-modified">1869 void FileMapInfo::dealloc_archive_heap_regions(MemRegion* regions, int num) {</span>
1870   if (num &gt; 0) {
1871     assert(regions != NULL, &quot;Null archive ranges array with non-zero count&quot;);
<span class="line-modified">1872     G1CollectedHeap::heap()-&gt;dealloc_archive_regions(regions, num);</span>
1873   }
1874 }
1875 #endif // INCLUDE_CDS_JAVA_HEAP
1876 
<span class="line-modified">1877 bool FileMapInfo::region_crc_check(char* buf, size_t size, int expected_crc) {</span>
<span class="line-modified">1878   int crc = ClassLoader::crc32(0, buf, (jint)size);</span>
<span class="line-modified">1879   if (crc != expected_crc) {</span>
<span class="line-added">1880     fail_continue(&quot;Checksum verification failed.&quot;);</span>
<span class="line-added">1881     return false;</span>
1882   }
<span class="line-added">1883   return true;</span>
<span class="line-added">1884 }</span>
1885 
<span class="line-modified">1886 bool FileMapInfo::verify_region_checksum(int i) {</span>
<span class="line-added">1887   assert(VerifySharedSpaces, &quot;sanity&quot;);</span>
<span class="line-added">1888   size_t sz = space_at(i)-&gt;used();</span>
1889 
1890   if (sz == 0) {
1891     return true; // no data
<span class="line-added">1892   } else {</span>
<span class="line-added">1893     return region_crc_check(region_addr(i), sz, space_at(i)-&gt;crc());</span>
1894   }
<span class="line-modified">1895 }</span>
<span class="line-modified">1896 </span>
<span class="line-modified">1897 void FileMapInfo::unmap_regions(int regions[], int num_regions) {</span>
<span class="line-modified">1898   for (int r = 0; r &lt; num_regions; r++) {</span>
<span class="line-modified">1899     int idx = regions[r];</span>
<span class="line-modified">1900     unmap_region(idx);</span>





1901   }

1902 }
1903 
1904 // Unmap a memory region in the address space.
1905 
1906 void FileMapInfo::unmap_region(int i) {
1907   assert(!HeapShared::is_heap_region(i), &quot;sanity&quot;);
<span class="line-modified">1908   FileMapRegion* si = space_at(i);</span>
<span class="line-modified">1909   char* mapped_base = si-&gt;mapped_base();</span>
<span class="line-added">1910   size_t used = si-&gt;used();</span>
1911   size_t size = align_up(used, os::vm_allocation_granularity());
1912 
<span class="line-modified">1913   if (mapped_base != NULL &amp;&amp; size &gt; 0 &amp;&amp; si-&gt;mapped_from_file()) {</span>
<span class="line-modified">1914     log_info(cds)(&quot;Unmapping region #%d at base &quot; INTPTR_FORMAT &quot; (%s)&quot;, i, p2i(mapped_base),</span>
<span class="line-modified">1915                   shared_region_name[i]);</span>
<span class="line-modified">1916     if (!os::unmap_memory(mapped_base, size)) {</span>
<span class="line-modified">1917       fatal(&quot;os::unmap_memory failed&quot;);</span>
<span class="line-modified">1918     }</span>
<span class="line-modified">1919     si-&gt;set_mapped_base(NULL);</span>
1920   }
1921 }
1922 
1923 void FileMapInfo::assert_mark(bool check) {
1924   if (!check) {
1925     fail_stop(&quot;Mark mismatch while restoring from shared file.&quot;);
1926   }
1927 }
1928 
1929 void FileMapInfo::metaspace_pointers_do(MetaspaceClosure* it) {
<span class="line-modified">1930   _shared_path_table.metaspace_pointers_do(it);</span>



1931 }
1932 

1933 FileMapInfo* FileMapInfo::_current_info = NULL;
<span class="line-added">1934 FileMapInfo* FileMapInfo::_dynamic_archive_info = NULL;</span>
1935 bool FileMapInfo::_heap_pointers_need_patching = false;
<span class="line-modified">1936 SharedPathTable FileMapInfo::_shared_path_table;</span>


1937 bool FileMapInfo::_validating_shared_path_table = false;
<span class="line-added">1938 bool FileMapInfo::_memory_mapping_failed = false;</span>
<span class="line-added">1939 GrowableArray&lt;const char*&gt;* FileMapInfo::_non_existent_class_paths = NULL;</span>
1940 
1941 // Open the shared archive file, read and validate the header
1942 // information (version, boot classpath, etc.).  If initialization
1943 // fails, shared spaces are disabled and the file is closed. [See
1944 // fail_continue.]
1945 //
1946 // Validation of the archive is done in two steps:
1947 //
<span class="line-modified">1948 // [1] validate_header() - done here.</span>
1949 // [2] validate_shared_path_table - this is done later, because the table is in the RW
1950 //     region of the archive, which is not mapped yet.
1951 bool FileMapInfo::initialize() {
1952   assert(UseSharedSpaces, &quot;UseSharedSpaces expected.&quot;);
1953 
1954   if (JvmtiExport::should_post_class_file_load_hook() &amp;&amp; JvmtiExport::has_early_class_hook_env()) {
1955     // CDS assumes that no classes resolved in SystemDictionary::resolve_well_known_classes
1956     // are replaced at runtime by JVMTI ClassFileLoadHook. All of those classes are resolved
1957     // during the JVMTI &quot;early&quot; stage, so we can still use CDS if
1958     // JvmtiExport::has_early_class_hook_env() is false.
1959     FileMapInfo::fail_continue(&quot;CDS is disabled because early JVMTI ClassFileLoadHook is in use.&quot;);
1960     return false;
1961   }
1962 
1963   if (!open_for_read()) {
1964     return false;
1965   }
<span class="line-modified">1966   if (!init_from_file(_fd)) {</span>
<span class="line-modified">1967     return false;</span>
<span class="line-added">1968   }</span>
1969   if (!validate_header()) {
1970     return false;
1971   }
1972   return true;
1973 }
1974 
1975 char* FileMapInfo::region_addr(int idx) {
<span class="line-modified">1976   FileMapRegion* si = space_at(idx);</span>
1977   if (HeapShared::is_heap_region(idx)) {
1978     assert(DumpSharedSpaces, &quot;The following doesn&#39;t work at runtime&quot;);
<span class="line-modified">1979     return si-&gt;used() &gt; 0 ?</span>
1980           (char*)start_address_as_decoded_with_current_oop_encoding_mode(si) : NULL;
1981   } else {
<span class="line-modified">1982     return si-&gt;mapped_base();</span>
1983   }
1984 }
1985 
<span class="line-added">1986 // The 3 core spaces are MC-&gt;RW-&gt;RO</span>
<span class="line-added">1987 FileMapRegion* FileMapInfo::first_core_space() const {</span>
<span class="line-added">1988   return space_at(MetaspaceShared::mc);</span>
<span class="line-added">1989 }</span>
<span class="line-added">1990 </span>
<span class="line-added">1991 FileMapRegion* FileMapInfo::last_core_space() const {</span>
<span class="line-added">1992   return space_at(MetaspaceShared::ro);</span>
<span class="line-added">1993 }</span>
<span class="line-added">1994 </span>
1995 int FileMapHeader::compute_crc() {
1996   char* start = (char*)this;
1997   // start computing from the field after _crc
1998   char* buf = (char*)&amp;_crc + sizeof(_crc);
<span class="line-modified">1999   size_t sz = _header_size - (buf - start);</span>
2000   int crc = ClassLoader::crc32(0, buf, (jint)sz);
2001   return crc;
2002 }
2003 
2004 // This function should only be called during run time with UseSharedSpaces enabled.
2005 bool FileMapHeader::validate() {



























2006   if (_obj_alignment != ObjectAlignmentInBytes) {
2007     FileMapInfo::fail_continue(&quot;The shared archive file&#39;s ObjectAlignmentInBytes of %d&quot;
2008                   &quot; does not equal the current ObjectAlignmentInBytes of &quot; INTX_FORMAT &quot;.&quot;,
2009                   _obj_alignment, ObjectAlignmentInBytes);
2010     return false;
2011   }
2012   if (_compact_strings != CompactStrings) {
2013     FileMapInfo::fail_continue(&quot;The shared archive file&#39;s CompactStrings setting (%s)&quot;
2014                   &quot; does not equal the current CompactStrings setting (%s).&quot;,
2015                   _compact_strings ? &quot;enabled&quot; : &quot;disabled&quot;,
2016                   CompactStrings   ? &quot;enabled&quot; : &quot;disabled&quot;);
2017     return false;
2018   }
2019 
2020   // This must be done after header validation because it might change the
2021   // header data
2022   const char* prop = Arguments::get_property(&quot;java.system.class.loader&quot;);
2023   if (prop != NULL) {
2024     warning(&quot;Archived non-system classes are disabled because the &quot;
2025             &quot;java.system.class.loader property is specified (value = \&quot;%s\&quot;). &quot;
</pre>
<hr />
<pre>
2035     FileMapInfo::fail_continue(&quot;The shared archive file was created with less restrictive &quot;
2036                   &quot;verification setting than the current setting.&quot;);
2037     return false;
2038   }
2039 
2040   // Java agents are allowed during run time. Therefore, the following condition is not
2041   // checked: (!_allow_archiving_with_java_agent &amp;&amp; AllowArchivingWithJavaAgent)
2042   // Note: _allow_archiving_with_java_agent is set in the shared archive during dump time
2043   // while AllowArchivingWithJavaAgent is set during the current run.
2044   if (_allow_archiving_with_java_agent &amp;&amp; !AllowArchivingWithJavaAgent) {
2045     FileMapInfo::fail_continue(&quot;The setting of the AllowArchivingWithJavaAgent is different &quot;
2046                                &quot;from the setting in the shared archive.&quot;);
2047     return false;
2048   }
2049 
2050   if (_allow_archiving_with_java_agent) {
2051     warning(&quot;This archive was created with AllowArchivingWithJavaAgent. It should be used &quot;
2052             &quot;for testing purposes only and should not be used in a production environment&quot;);
2053   }
2054 
<span class="line-added">2055   log_info(cds)(&quot;Archive was created with UseCompressedOops = %d, UseCompressedClassPointers = %d&quot;,</span>
<span class="line-added">2056                           compressed_oops(), compressed_class_pointers());</span>
<span class="line-added">2057   if (compressed_oops() != UseCompressedOops || compressed_class_pointers() != UseCompressedClassPointers) {</span>
<span class="line-added">2058     FileMapInfo::fail_continue(&quot;Unable to use shared archive.\nThe saved state of UseCompressedOops and UseCompressedClassPointers is &quot;</span>
<span class="line-added">2059                                &quot;different from runtime, CDS will be disabled.&quot;);</span>
<span class="line-added">2060     return false;</span>
<span class="line-added">2061   }</span>
<span class="line-added">2062 </span>
2063   return true;
2064 }
2065 
2066 bool FileMapInfo::validate_header() {
<span class="line-modified">2067   return header()-&gt;validate();</span>















2068 }
2069 
2070 // Check if a given address is within one of the shared regions
2071 bool FileMapInfo::is_in_shared_region(const void* p, int idx) {
2072   assert(idx == MetaspaceShared::ro ||
2073          idx == MetaspaceShared::rw ||
<span class="line-modified">2074          idx == MetaspaceShared::mc, &quot;invalid region index&quot;);</span>

2075   char* base = region_addr(idx);
<span class="line-modified">2076   if (p &gt;= base &amp;&amp; p &lt; base + space_at(idx)-&gt;used()) {</span>
2077     return true;
2078   }
2079   return false;
2080 }
2081 
2082 // Unmap mapped regions of shared space.
2083 void FileMapInfo::stop_sharing_and_unmap(const char* msg) {
<span class="line-modified">2084   MetaspaceShared::set_shared_metaspace_range(NULL, NULL, NULL);</span>
2085 
2086   FileMapInfo *map_info = FileMapInfo::current_info();
2087   if (map_info) {
2088     map_info-&gt;fail_continue(&quot;%s&quot;, msg);
2089     for (int i = 0; i &lt; MetaspaceShared::num_non_heap_spaces; i++) {
2090       if (!HeapShared::is_heap_region(i)) {
<span class="line-modified">2091         map_info-&gt;unmap_region(i);</span>




2092       }
2093     }
2094     // Dealloc the archive heap regions only without unmapping. The regions are part
2095     // of the java heap. Unmapping of the heap regions are managed by GC.
2096     map_info-&gt;dealloc_archive_heap_regions(open_archive_heap_ranges,
<span class="line-modified">2097                                            num_open_archive_heap_ranges);</span>

2098     map_info-&gt;dealloc_archive_heap_regions(closed_archive_heap_ranges,
<span class="line-modified">2099                                            num_closed_archive_heap_ranges);</span>

2100   } else if (DumpSharedSpaces) {
2101     fail_stop(&quot;%s&quot;, msg);
2102   }
2103 }
2104 
2105 #if INCLUDE_JVMTI
2106 ClassPathEntry** FileMapInfo::_classpath_entries_for_jvmti = NULL;
2107 
2108 ClassPathEntry* FileMapInfo::get_classpath_entry_for_jvmti(int i, TRAPS) {
2109   ClassPathEntry* ent = _classpath_entries_for_jvmti[i];
2110   if (ent == NULL) {
2111     if (i == 0) {
<span class="line-modified">2112       ent = ClassLoader::get_jrt_entry();</span>
2113       assert(ent != NULL, &quot;must be&quot;);
2114     } else {
2115       SharedClassPathEntry* scpe = shared_path(i);
2116       assert(scpe-&gt;is_jar(), &quot;must be&quot;); // other types of scpe will not produce archived classes
2117 
2118       const char* path = scpe-&gt;name();
2119       struct stat st;
2120       if (os::stat(path, &amp;st) != 0) {
2121         char *msg = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, strlen(path) + 128); ;
2122         jio_snprintf(msg, strlen(path) + 127, &quot;error in opening JAR file %s&quot;, path);
2123         THROW_MSG_(vmSymbols::java_io_IOException(), msg, NULL);
2124       } else {
<span class="line-modified">2125         ent = ClassLoader::create_class_path_entry(path, &amp;st, /*throw_exception=*/true, false, false, CHECK_NULL);</span>
2126       }
2127     }
2128 
<span class="line-modified">2129     MutexLocker mu(THREAD, CDSClassFileStream_lock);</span>
2130     if (_classpath_entries_for_jvmti[i] == NULL) {
2131       _classpath_entries_for_jvmti[i] = ent;
2132     } else {
2133       // Another thread has beat me to creating this entry
2134       delete ent;
2135       ent = _classpath_entries_for_jvmti[i];
2136     }
2137   }
2138 
2139   return ent;
2140 }
2141 
<span class="line-modified">2142 ClassFileStream* FileMapInfo::open_stream_for_jvmti(InstanceKlass* ik, Handle class_loader, TRAPS) {</span>
2143   int path_index = ik-&gt;shared_classpath_index();
2144   assert(path_index &gt;= 0, &quot;should be called for shared built-in classes only&quot;);
<span class="line-modified">2145   assert(path_index &lt; (int)get_number_of_shared_paths(), &quot;sanity&quot;);</span>
2146 
2147   ClassPathEntry* cpe = get_classpath_entry_for_jvmti(path_index, CHECK_NULL);
2148   assert(cpe != NULL, &quot;must be&quot;);
2149 
2150   Symbol* name = ik-&gt;name();
2151   const char* const class_name = name-&gt;as_C_string();
2152   const char* const file_name = ClassLoader::file_name_for_class_name(class_name,
2153                                                                       name-&gt;utf8_length());
<span class="line-modified">2154   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());</span>
<span class="line-added">2155   ClassFileStream* cfs = cpe-&gt;open_stream_for_loader(file_name, loader_data, THREAD);</span>
<span class="line-added">2156   assert(cfs != NULL, &quot;must be able to read the classfile data of shared classes for built-in loaders.&quot;);</span>
<span class="line-added">2157   log_debug(cds, jvmti)(&quot;classfile data for %s [%d: %s] = %d bytes&quot;, class_name, path_index,</span>
<span class="line-added">2158                         cfs-&gt;source(), cfs-&gt;length());</span>
<span class="line-added">2159   return cfs;</span>
2160 }
2161 
2162 #endif
</pre>
</td>
</tr>
</table>
<center><a href="arena.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="filemap.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
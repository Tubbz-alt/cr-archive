<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/memory/heap.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_MEMORY_HEAP_HPP
 26 #define SHARE_MEMORY_HEAP_HPP
 27 
 28 #include &quot;code/codeBlob.hpp&quot;
 29 #include &quot;memory/allocation.hpp&quot;
 30 #include &quot;memory/virtualspace.hpp&quot;
 31 #include &quot;utilities/macros.hpp&quot;
 32 
 33 // Blocks
 34 
 35 class HeapBlock {
 36   friend class VMStructs;
 37 
 38  public:
 39   struct Header {
 40     size_t  _length;                             // the length in segments
 41     bool    _used;                               // Used bit
 42   };
 43 
 44  protected:
 45   union {
 46     Header _header;
 47     int64_t _padding[ (sizeof(Header) + sizeof(int64_t)-1) / sizeof(int64_t) ];
 48                         // pad to 0 mod 8
 49   };
 50 
 51  public:
 52   // Initialization
 53   void initialize(size_t length)                 { _header._length = length; set_used(); }
<a name="1" id="anc1"></a><span class="line-added"> 54   // Merging/splitting</span>
<span class="line-added"> 55   void set_length(size_t length)                 { _header._length = length; }</span>
 56 
 57   // Accessors
 58   void* allocated_space() const                  { return (void*)(this + 1); }
 59   size_t length() const                          { return _header._length; }
 60 
 61   // Used/free
 62   void set_used()                                { _header._used = true; }
 63   void set_free()                                { _header._used = false; }
 64   bool free()                                    { return !_header._used; }
 65 };
 66 
 67 class FreeBlock: public HeapBlock {
 68   friend class VMStructs;
 69  protected:
 70   FreeBlock* _link;
 71 
 72  public:
 73   // Initialization
 74   void initialize(size_t length)             { HeapBlock::initialize(length); _link= NULL; }
 75 
<a name="2" id="anc2"></a>


 76   // Accessors
 77   FreeBlock* link() const                    { return _link; }
 78   void set_link(FreeBlock* link)             { _link = link; }
 79 };
 80 
 81 class CodeHeap : public CHeapObj&lt;mtCode&gt; {
 82   friend class VMStructs;
 83  protected:
 84   VirtualSpace _memory;                          // the memory holding the blocks
 85   VirtualSpace _segmap;                          // the memory holding the segment map
 86 
 87   size_t       _number_of_committed_segments;
 88   size_t       _number_of_reserved_segments;
 89   size_t       _segment_size;
 90   int          _log2_segment_size;
 91 
 92   size_t       _next_segment;
 93 
 94   FreeBlock*   _freelist;
<a name="3" id="anc3"></a><span class="line-added"> 95   FreeBlock*   _last_insert_point;               // last insert point in add_to_freelist</span>
 96   size_t       _freelist_segments;               // No. of segments in freelist
 97   int          _freelist_length;
 98   size_t       _max_allocated_capacity;          // Peak capacity that was allocated during lifetime of the heap
 99 
100   const char*  _name;                            // Name of the CodeHeap
101   const int    _code_blob_type;                  // CodeBlobType it contains
102   int          _blob_count;                      // Number of CodeBlobs
103   int          _nmethod_count;                   // Number of nmethods
104   int          _adapter_count;                   // Number of adapters
105   int          _full_count;                      // Number of times the code heap was full
<a name="4" id="anc4"></a><span class="line-modified">106   int          _fragmentation_count;             // #FreeBlock joins without fully initializing segment map elements.</span>
107 
108   enum { free_sentinel = 0xFF };
<a name="5" id="anc5"></a><span class="line-added">109   static const int fragmentation_limit = 10000;  // defragment after that many potential fragmentations.</span>
<span class="line-added">110   static const int freelist_limit = 100;         // improve insert point search if list is longer than this limit.</span>
<span class="line-added">111   static char  segmap_template[free_sentinel+1];</span>
112 
113   // Helper functions
114   size_t   size_to_segments(size_t size) const { return (size + _segment_size - 1) &gt;&gt; _log2_segment_size; }
115   size_t   segments_to_size(size_t number_of_segments) const { return number_of_segments &lt;&lt; _log2_segment_size; }
116 
117   size_t   segment_for(void* p) const            { return ((char*)p - _memory.low()) &gt;&gt; _log2_segment_size; }
118   bool     is_segment_unused(int val) const      { return val == free_sentinel; }
<a name="6" id="anc6"></a><span class="line-modified">119   void*    address_for(size_t i) const           { return (void*)(_memory.low() + segments_to_size(i)); }</span>
<span class="line-modified">120   void*    find_block_for(void* p) const;</span>
<span class="line-modified">121   HeapBlock* block_at(size_t i) const            { return (HeapBlock*)address_for(i); }</span>
<span class="line-modified">122 </span>
<span class="line-added">123   // These methods take segment map indices as range boundaries</span>
<span class="line-added">124   void mark_segmap_as_free(size_t beg, size_t end);</span>
<span class="line-added">125   void mark_segmap_as_used(size_t beg, size_t end, bool is_FreeBlock_join);</span>
<span class="line-added">126   void invalidate(size_t beg, size_t end, size_t header_bytes);</span>
<span class="line-added">127   void clear(size_t beg, size_t end);</span>
<span class="line-added">128   void clear();                                 // clears all heap contents</span>
<span class="line-added">129   static void init_segmap_template();</span>
130 
131   // Freelist management helpers
132   FreeBlock* following_block(FreeBlock* b);
133   void insert_after(FreeBlock* a, FreeBlock* b);
134   bool merge_right (FreeBlock* a);
135 
136   // Toplevel freelist management
137   void add_to_freelist(HeapBlock* b);
<a name="7" id="anc7"></a><span class="line-modified">138   HeapBlock* search_freelist(size_t length);</span>
139 
140   // Iteration helpers
141   void*      next_used(HeapBlock* b) const;
142   HeapBlock* block_start(void* p) const;
143 
144   // to perform additional actions on creation of executable code
145   void on_code_mapping(char* base, size_t size);
<a name="8" id="anc8"></a>
146 
147  public:
148   CodeHeap(const char* name, const int code_blob_type);
149 
150   // Heap extents
151   bool  reserve(ReservedSpace rs, size_t committed_size, size_t segment_size);
152   bool  expand_by(size_t size);                  // expands committed memory by size
153 
154   // Memory allocation
155   void* allocate (size_t size); // Allocate &#39;size&#39; bytes in the code cache or return NULL
156   void  deallocate(void* p);    // Deallocate memory
157   // Free the tail of segments allocated by the last call to &#39;allocate()&#39; which exceed &#39;used_size&#39;.
158   // ATTENTION: this is only safe to use if there was no other call to &#39;allocate()&#39; after
159   //            &#39;p&#39; was allocated. Only intended for freeing memory which would be otherwise
160   //            wasted after the interpreter generation because we don&#39;t know the interpreter size
161   //            beforehand and we also can&#39;t easily relocate the interpreter to a new location.
162   void  deallocate_tail(void* p, size_t used_size);
163 
<a name="9" id="anc9"></a><span class="line-modified">164   // Boundaries of committed space.</span>
<span class="line-modified">165   char* low()  const                             { return _memory.low(); }</span>
166   char* high() const                             { return _memory.high(); }
<a name="10" id="anc10"></a><span class="line-added">167   // Boundaries of reserved space.</span>
<span class="line-added">168   char* low_boundary() const                     { return _memory.low_boundary(); }</span>
169   char* high_boundary() const                    { return _memory.high_boundary(); }
170 
<a name="11" id="anc11"></a><span class="line-modified">171   // Containment means &quot;contained in committed space&quot;.</span>
<span class="line-added">172   bool contains(const void* p) const             { return low() &lt;= p &amp;&amp; p &lt; high(); }</span>
173   bool contains_blob(const CodeBlob* blob) const {
174     // AOT CodeBlobs (i.e. AOTCompiledMethod) objects aren&#39;t allocated in the AOTCodeHeap but on the C-Heap.
175     // Only the code they are pointing to is located in the AOTCodeHeap. All other CodeBlobs are allocated
176     // directly in their corresponding CodeHeap with their code appended to the actual C++ object.
177     // So all CodeBlobs except AOTCompiledMethod are continuous in memory with their data and code while
178     // AOTCompiledMethod and their code/data is distributed in the C-Heap. This means we can use the
179     // address of a CodeBlob object in order to locate it in its heap while we have to use the address
180     // of the actual code an AOTCompiledMethod object is pointing to in order to locate it.
181     // Notice that for an ordinary CodeBlob with code size zero, code_begin() may point beyond the object!
182     const void* start = AOT_ONLY( (code_blob_type() == CodeBlobType::AOT) ? blob-&gt;code_begin() : ) (void*)blob;
183     return contains(start);
184   }
185 
186   virtual void* find_start(void* p)     const;   // returns the block containing p or NULL
187   virtual CodeBlob* find_blob_unsafe(void* start) const;
188   size_t alignment_unit()       const;           // alignment of any block
189   size_t alignment_offset()     const;           // offset of first byte of any block, within the enclosing alignment unit
190   static size_t header_size();                   // returns the header size for each heap block
191 
192   size_t segment_size()         const { return _segment_size; }  // for CodeHeapState
193   HeapBlock* first_block() const;                                // for CodeHeapState
194   HeapBlock* next_block(HeapBlock* b) const;                     // for CodeHeapState
<a name="12" id="anc12"></a><span class="line-added">195   HeapBlock* split_block(HeapBlock* b, size_t split_seg);        // split one block into two</span>
196 
197   FreeBlock* freelist()         const { return _freelist; }      // for CodeHeapState
198 
199   size_t allocated_in_freelist() const           { return _freelist_segments * CodeCacheSegmentSize; }
200   int    freelist_length()       const           { return _freelist_length; } // number of elements in the freelist
201 
202   // returns the first block or NULL
203   virtual void* first() const                    { return next_used(first_block()); }
204   // returns the next block given a block p or NULL
205   virtual void* next(void* p) const              { return next_used(next_block(block_start(p))); }
206 
207   // Statistics
208   size_t capacity() const;
209   size_t max_capacity() const;
210   int    allocated_segments() const;
211   size_t allocated_capacity() const;
212   size_t max_allocated_capacity() const          { return _max_allocated_capacity; }
213   size_t unallocated_capacity() const            { return max_capacity() - allocated_capacity(); }
214 
215   // Returns true if the CodeHeap contains CodeBlobs of the given type
216   bool accepts(int code_blob_type) const         { return (_code_blob_type == CodeBlobType::All) ||
217                                                           (_code_blob_type == code_blob_type); }
218   int code_blob_type() const                     { return _code_blob_type; }
219 
220   // Debugging / Profiling
221   const char* name() const                       { return _name; }
222   int         blob_count()                       { return _blob_count; }
223   int         nmethod_count()                    { return _nmethod_count; }
224   void    set_nmethod_count(int count)           {        _nmethod_count = count; }
225   int         adapter_count()                    { return _adapter_count; }
226   void    set_adapter_count(int count)           {        _adapter_count = count; }
227   int         full_count()                       { return _full_count; }
228   void        report_full()                      {        _full_count++; }
229 
230 private:
231   size_t heap_unallocated_capacity() const;
<a name="13" id="anc13"></a><span class="line-added">232   int defrag_segmap(bool do_defrag);</span>
<span class="line-added">233   int segmap_hops(size_t beg, size_t end);</span>
234 
235 public:
236   // Debugging
237   void verify() PRODUCT_RETURN;
238   void print()  PRODUCT_RETURN;
239 };
240 
241 #endif // SHARE_MEMORY_HEAP_HPP
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/memory/arena.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;memory/allocation.hpp&quot;
 27 #include &quot;memory/allocation.inline.hpp&quot;
 28 #include &quot;memory/metaspaceShared.hpp&quot;
 29 #include &quot;memory/resourceArea.hpp&quot;
 30 #include &quot;runtime/os.hpp&quot;
 31 #include &quot;runtime/task.hpp&quot;
 32 #include &quot;runtime/threadCritical.hpp&quot;
 33 #include &quot;services/memTracker.hpp&quot;
 34 #include &quot;utilities/ostream.hpp&quot;
 35 
 36 //--------------------------------------------------------------------------------------
 37 // ChunkPool implementation
 38 
 39 // MT-safe pool of chunks to reduce malloc/free thrashing
 40 // NB: not using Mutex because pools are used before Threads are initialized
 41 class ChunkPool: public CHeapObj&lt;mtInternal&gt; {
 42   Chunk*       _first;        // first cached Chunk; its first word points to next chunk
 43   size_t       _num_chunks;   // number of unused chunks in pool
 44   size_t       _num_used;     // number of chunks currently checked out
 45   const size_t _size;         // size of each chunk (must be uniform)
 46 
 47   // Our four static pools
 48   static ChunkPool* _large_pool;
 49   static ChunkPool* _medium_pool;
 50   static ChunkPool* _small_pool;
 51   static ChunkPool* _tiny_pool;
 52 
 53   // return first element or null
 54   void* get_first() {
 55     Chunk* c = _first;
 56     if (_first) {
 57       _first = _first-&gt;next();
 58       _num_chunks--;
 59     }
 60     return c;
 61   }
 62 
 63  public:
 64   // All chunks in a ChunkPool has the same size
 65    ChunkPool(size_t size) : _size(size) { _first = NULL; _num_chunks = _num_used = 0; }
 66 
 67   // Allocate a new chunk from the pool (might expand the pool)
 68   NOINLINE void* allocate(size_t bytes, AllocFailType alloc_failmode) {
 69     assert(bytes == _size, &quot;bad size&quot;);
 70     void* p = NULL;
 71     // No VM lock can be taken inside ThreadCritical lock, so os::malloc
 72     // should be done outside ThreadCritical lock due to NMT
 73     { ThreadCritical tc;
 74       _num_used++;
 75       p = get_first();
 76     }
 77     if (p == NULL) p = os::malloc(bytes, mtChunk, CURRENT_PC);
 78     if (p == NULL &amp;&amp; alloc_failmode == AllocFailStrategy::EXIT_OOM) {
 79       vm_exit_out_of_memory(bytes, OOM_MALLOC_ERROR, &quot;ChunkPool::allocate&quot;);
 80     }
 81     return p;
 82   }
 83 
 84   // Return a chunk to the pool
 85   void free(Chunk* chunk) {
 86     assert(chunk-&gt;length() + Chunk::aligned_overhead_size() == _size, &quot;bad size&quot;);
 87     ThreadCritical tc;
 88     _num_used--;
 89 
 90     // Add chunk to list
 91     chunk-&gt;set_next(_first);
 92     _first = chunk;
 93     _num_chunks++;
 94   }
 95 
 96   // Prune the pool
 97   void free_all_but(size_t n) {
 98     Chunk* cur = NULL;
 99     Chunk* next;
100     {
101       // if we have more than n chunks, free all of them
102       ThreadCritical tc;
103       if (_num_chunks &gt; n) {
104         // free chunks at end of queue, for better locality
105         cur = _first;
106         for (size_t i = 0; i &lt; (n - 1) &amp;&amp; cur != NULL; i++) cur = cur-&gt;next();
107 
108         if (cur != NULL) {
109           next = cur-&gt;next();
110           cur-&gt;set_next(NULL);
111           cur = next;
112 
113           // Free all remaining chunks while in ThreadCritical lock
114           // so NMT adjustment is stable.
115           while(cur != NULL) {
116             next = cur-&gt;next();
117             os::free(cur);
118             _num_chunks--;
119             cur = next;
120           }
121         }
122       }
123     }
124   }
125 
126   // Accessors to preallocated pool&#39;s
127   static ChunkPool* large_pool()  { assert(_large_pool  != NULL, &quot;must be initialized&quot;); return _large_pool;  }
128   static ChunkPool* medium_pool() { assert(_medium_pool != NULL, &quot;must be initialized&quot;); return _medium_pool; }
129   static ChunkPool* small_pool()  { assert(_small_pool  != NULL, &quot;must be initialized&quot;); return _small_pool;  }
130   static ChunkPool* tiny_pool()   { assert(_tiny_pool   != NULL, &quot;must be initialized&quot;); return _tiny_pool;   }
131 
132   static void initialize() {
133     _large_pool  = new ChunkPool(Chunk::size        + Chunk::aligned_overhead_size());
134     _medium_pool = new ChunkPool(Chunk::medium_size + Chunk::aligned_overhead_size());
135     _small_pool  = new ChunkPool(Chunk::init_size   + Chunk::aligned_overhead_size());
136     _tiny_pool   = new ChunkPool(Chunk::tiny_size   + Chunk::aligned_overhead_size());
137   }
138 
139   static void clean() {
140     enum { BlocksToKeep = 5 };
141      _tiny_pool-&gt;free_all_but(BlocksToKeep);
142      _small_pool-&gt;free_all_but(BlocksToKeep);
143      _medium_pool-&gt;free_all_but(BlocksToKeep);
144      _large_pool-&gt;free_all_but(BlocksToKeep);
145   }
146 };
147 
148 ChunkPool* ChunkPool::_large_pool  = NULL;
149 ChunkPool* ChunkPool::_medium_pool = NULL;
150 ChunkPool* ChunkPool::_small_pool  = NULL;
151 ChunkPool* ChunkPool::_tiny_pool   = NULL;
152 
153 void chunkpool_init() {
154   ChunkPool::initialize();
155 }
156 
157 void
158 Chunk::clean_chunk_pool() {
159   ChunkPool::clean();
160 }
161 
162 
163 //--------------------------------------------------------------------------------------
164 // ChunkPoolCleaner implementation
165 //
166 
167 class ChunkPoolCleaner : public PeriodicTask {
168   enum { CleaningInterval = 5000 };      // cleaning interval in ms
169 
170  public:
171    ChunkPoolCleaner() : PeriodicTask(CleaningInterval) {}
172    void task() {
173      ChunkPool::clean();
174    }
175 };
176 
177 //--------------------------------------------------------------------------------------
178 // Chunk implementation
179 
180 void* Chunk::operator new (size_t requested_size, AllocFailType alloc_failmode, size_t length) throw() {
181   // requested_size is equal to sizeof(Chunk) but in order for the arena
182   // allocations to come out aligned as expected the size must be aligned
183   // to expected arena alignment.
184   // expect requested_size but if sizeof(Chunk) doesn&#39;t match isn&#39;t proper size we must align it.
185   assert(ARENA_ALIGN(requested_size) == aligned_overhead_size(), &quot;Bad alignment&quot;);
186   size_t bytes = ARENA_ALIGN(requested_size) + length;
187   switch (length) {
188    case Chunk::size:        return ChunkPool::large_pool()-&gt;allocate(bytes, alloc_failmode);
189    case Chunk::medium_size: return ChunkPool::medium_pool()-&gt;allocate(bytes, alloc_failmode);
190    case Chunk::init_size:   return ChunkPool::small_pool()-&gt;allocate(bytes, alloc_failmode);
191    case Chunk::tiny_size:   return ChunkPool::tiny_pool()-&gt;allocate(bytes, alloc_failmode);
192    default: {
193      void* p = os::malloc(bytes, mtChunk, CALLER_PC);
194      if (p == NULL &amp;&amp; alloc_failmode == AllocFailStrategy::EXIT_OOM) {
195        vm_exit_out_of_memory(bytes, OOM_MALLOC_ERROR, &quot;Chunk::new&quot;);
196      }
197      return p;
198    }
199   }
200 }
201 
202 void Chunk::operator delete(void* p) {
203   Chunk* c = (Chunk*)p;
204   switch (c-&gt;length()) {
205    case Chunk::size:        ChunkPool::large_pool()-&gt;free(c); break;
206    case Chunk::medium_size: ChunkPool::medium_pool()-&gt;free(c); break;
207    case Chunk::init_size:   ChunkPool::small_pool()-&gt;free(c); break;
208    case Chunk::tiny_size:   ChunkPool::tiny_pool()-&gt;free(c); break;
209    default:
210      ThreadCritical tc;  // Free chunks under TC lock so that NMT adjustment is stable.
211      os::free(c);
212   }
213 }
214 
215 Chunk::Chunk(size_t length) : _len(length) {
216   _next = NULL;         // Chain on the linked list
217 }
218 
219 void Chunk::chop() {
220   Chunk *k = this;
221   while( k ) {
222     Chunk *tmp = k-&gt;next();
223     // clear out this chunk (to detect allocation bugs)
224     if (ZapResourceArea) memset(k-&gt;bottom(), badResourceValue, k-&gt;length());
225     delete k;                   // Free chunk (was malloc&#39;d)
226     k = tmp;
227   }
228 }
229 
230 void Chunk::next_chop() {
231   _next-&gt;chop();
232   _next = NULL;
233 }
234 
235 void Chunk::start_chunk_pool_cleaner_task() {
236 #ifdef ASSERT
237   static bool task_created = false;
238   assert(!task_created, &quot;should not start chuck pool cleaner twice&quot;);
239   task_created = true;
240 #endif
241   ChunkPoolCleaner* cleaner = new ChunkPoolCleaner();
242   cleaner-&gt;enroll();
243 }
244 
245 //------------------------------Arena------------------------------------------
246 
247 Arena::Arena(MEMFLAGS flag, size_t init_size) : _flags(flag), _size_in_bytes(0)  {
248   size_t round_size = (sizeof (char *)) - 1;
249   init_size = (init_size+round_size) &amp; ~round_size;
250   _first = _chunk = new (AllocFailStrategy::EXIT_OOM, init_size) Chunk(init_size);
251   _hwm = _chunk-&gt;bottom();      // Save the cached hwm, max
252   _max = _chunk-&gt;top();
253   MemTracker::record_new_arena(flag);
254   set_size_in_bytes(init_size);
255 }
256 
257 Arena::Arena(MEMFLAGS flag) : _flags(flag), _size_in_bytes(0) {
258   _first = _chunk = new (AllocFailStrategy::EXIT_OOM, Chunk::init_size) Chunk(Chunk::init_size);
259   _hwm = _chunk-&gt;bottom();      // Save the cached hwm, max
260   _max = _chunk-&gt;top();
261   MemTracker::record_new_arena(flag);
262   set_size_in_bytes(Chunk::init_size);
263 }
264 
265 Arena *Arena::move_contents(Arena *copy) {
266   copy-&gt;destruct_contents();
267   copy-&gt;_chunk = _chunk;
268   copy-&gt;_hwm   = _hwm;
269   copy-&gt;_max   = _max;
270   copy-&gt;_first = _first;
271 
272   // workaround rare racing condition, which could double count
273   // the arena size by native memory tracking
274   size_t size = size_in_bytes();
275   set_size_in_bytes(0);
276   copy-&gt;set_size_in_bytes(size);
277   // Destroy original arena
278   reset();
279   return copy;            // Return Arena with contents
280 }
281 
282 Arena::~Arena() {
283   destruct_contents();
284   MemTracker::record_arena_free(_flags);
285 }
286 
287 void* Arena::operator new(size_t size) throw() {
288   assert(false, &quot;Use dynamic memory type binding&quot;);
289   return NULL;
290 }
291 
292 void* Arena::operator new (size_t size, const std::nothrow_t&amp;  nothrow_constant) throw() {
293   assert(false, &quot;Use dynamic memory type binding&quot;);
294   return NULL;
295 }
296 
297   // dynamic memory type binding
298 void* Arena::operator new(size_t size, MEMFLAGS flags) throw() {
299   return (void *) AllocateHeap(size, flags, CALLER_PC);
300 }
301 
302 void* Arena::operator new(size_t size, const std::nothrow_t&amp; nothrow_constant, MEMFLAGS flags) throw() {
303   return (void*)AllocateHeap(size, flags, CALLER_PC, AllocFailStrategy::RETURN_NULL);
304 }
305 
306 void Arena::operator delete(void* p) {
307   FreeHeap(p);
308 }
309 
310 // Destroy this arenas contents and reset to empty
311 void Arena::destruct_contents() {
312   if (UseMallocOnly &amp;&amp; _first != NULL) {
313     char* end = _first-&gt;next() ? _first-&gt;top() : _hwm;
314     free_malloced_objects(_first, _first-&gt;bottom(), end, _hwm);
315   }
316   // reset size before chop to avoid a rare racing condition
317   // that can have total arena memory exceed total chunk memory
318   set_size_in_bytes(0);
319   _first-&gt;chop();
320   reset();
321 }
322 
323 // This is high traffic method, but many calls actually don&#39;t
324 // change the size
325 void Arena::set_size_in_bytes(size_t size) {
326   if (_size_in_bytes != size) {
327     ssize_t delta = size - size_in_bytes();
328     _size_in_bytes = size;
329     MemTracker::record_arena_size_change(delta, _flags);
330   }
331 }
332 
333 // Total of all Chunks in arena
334 size_t Arena::used() const {
335   size_t sum = _chunk-&gt;length() - (_max-_hwm); // Size leftover in this Chunk
336   Chunk *k = _first;
337   while( k != _chunk) {         // Whilst have Chunks in a row
338     sum += k-&gt;length();         // Total size of this Chunk
339     k = k-&gt;next();              // Bump along to next Chunk
340   }
341   return sum;                   // Return total consumed space.
342 }
343 
344 void Arena::signal_out_of_memory(size_t sz, const char* whence) const {
345   vm_exit_out_of_memory(sz, OOM_MALLOC_ERROR, &quot;%s&quot;, whence);
346 }
347 
348 // Grow a new Chunk
349 void* Arena::grow(size_t x, AllocFailType alloc_failmode) {
350   // Get minimal required size.  Either real big, or even bigger for giant objs
351   size_t len = MAX2(x, (size_t) Chunk::size);
352 
353   Chunk *k = _chunk;            // Get filled-up chunk address
354   _chunk = new (alloc_failmode, len) Chunk(len);
355 
356   if (_chunk == NULL) {
357     _chunk = k;                 // restore the previous value of _chunk
358     return NULL;
359   }
360   if (k) k-&gt;set_next(_chunk);   // Append new chunk to end of linked list
361   else _first = _chunk;
362   _hwm  = _chunk-&gt;bottom();     // Save the cached hwm, max
363   _max =  _chunk-&gt;top();
364   set_size_in_bytes(size_in_bytes() + len);
365   void* result = _hwm;
366   _hwm += x;
367   return result;
368 }
369 
370 
371 
372 // Reallocate storage in Arena.
373 void *Arena::Arealloc(void* old_ptr, size_t old_size, size_t new_size, AllocFailType alloc_failmode) {
374   if (new_size == 0) return NULL;
375 #ifdef ASSERT
376   if (UseMallocOnly) {
377     // always allocate a new object  (otherwise we&#39;ll free this one twice)
378     char* copy = (char*)Amalloc(new_size, alloc_failmode);
379     if (copy == NULL) {
380       return NULL;
381     }
382     size_t n = MIN2(old_size, new_size);
383     if (n &gt; 0) memcpy(copy, old_ptr, n);
384     Afree(old_ptr,old_size);    // Mostly done to keep stats accurate
385     return copy;
386   }
387 #endif
388   char *c_old = (char*)old_ptr; // Handy name
389   // Stupid fast special case
390   if( new_size &lt;= old_size ) {  // Shrink in-place
391     if( c_old+old_size == _hwm) // Attempt to free the excess bytes
392       _hwm = c_old+new_size;    // Adjust hwm
393     return c_old;
394   }
395 
396   // make sure that new_size is legal
397   size_t corrected_new_size = ARENA_ALIGN(new_size);
398 
399   // See if we can resize in-place
400   if( (c_old+old_size == _hwm) &amp;&amp;       // Adjusting recent thing
401       (c_old+corrected_new_size &lt;= _max) ) {      // Still fits where it sits
402     _hwm = c_old+corrected_new_size;      // Adjust hwm
403     return c_old;               // Return old pointer
404   }
405 
406   // Oops, got to relocate guts
407   void *new_ptr = Amalloc(new_size, alloc_failmode);
408   if (new_ptr == NULL) {
409     return NULL;
410   }
411   memcpy( new_ptr, c_old, old_size );
412   Afree(c_old,old_size);        // Mostly done to keep stats accurate
413   return new_ptr;
414 }
415 
416 
417 // Determine if pointer belongs to this Arena or not.
418 bool Arena::contains( const void *ptr ) const {
419 #ifdef ASSERT
420   if (UseMallocOnly) {
421     // really slow, but not easy to make fast
422     if (_chunk == NULL) return false;
423     char** bottom = (char**)_chunk-&gt;bottom();
424     for (char** p = (char**)_hwm - 1; p &gt;= bottom; p--) {
425       if (*p == ptr) return true;
426     }
427     for (Chunk *c = _first; c != NULL; c = c-&gt;next()) {
428       if (c == _chunk) continue;  // current chunk has been processed
429       char** bottom = (char**)c-&gt;bottom();
430       for (char** p = (char**)c-&gt;top() - 1; p &gt;= bottom; p--) {
431         if (*p == ptr) return true;
432       }
433     }
434     return false;
435   }
436 #endif
437   if( (void*)_chunk-&gt;bottom() &lt;= ptr &amp;&amp; ptr &lt; (void*)_hwm )
438     return true;                // Check for in this chunk
439   for (Chunk *c = _first; c; c = c-&gt;next()) {
440     if (c == _chunk) continue;  // current chunk has been processed
441     if ((void*)c-&gt;bottom() &lt;= ptr &amp;&amp; ptr &lt; (void*)c-&gt;top()) {
442       return true;              // Check for every chunk in Arena
443     }
444   }
445   return false;                 // Not in any Chunk, so not in Arena
446 }
447 
448 
449 #ifdef ASSERT
450 void* Arena::malloc(size_t size) {
451   assert(UseMallocOnly, &quot;shouldn&#39;t call&quot;);
452   // use malloc, but save pointer in res. area for later freeing
453   char** save = (char**)internal_malloc_4(sizeof(char*));
454   return (*save = (char*)os::malloc(size, mtChunk));
455 }
456 
457 // for debugging with UseMallocOnly
458 void* Arena::internal_malloc_4(size_t x) {
459   assert( (x&amp;(sizeof(char*)-1)) == 0, &quot;misaligned size&quot; );
460   check_for_overflow(x, &quot;Arena::internal_malloc_4&quot;);
461   if (_hwm + x &gt; _max) {
462     return grow(x);
463   } else {
464     char *old = _hwm;
465     _hwm += x;
466     return old;
467   }
468 }
469 #endif
470 
471 
472 //--------------------------------------------------------------------------------------
473 // Non-product code
474 
475 #ifndef PRODUCT
476 
477 // debugging code
478 inline void Arena::free_all(char** start, char** end) {
479   for (char** p = start; p &lt; end; p++) if (*p) os::free(*p);
480 }
481 
482 void Arena::free_malloced_objects(Chunk* chunk, char* hwm, char* max, char* hwm2) {
483   assert(UseMallocOnly, &quot;should not call&quot;);
484   // free all objects malloced since resource mark was created; resource area
485   // contains their addresses
486   if (chunk-&gt;next()) {
487     // this chunk is full, and some others too
488     for (Chunk* c = chunk-&gt;next(); c != NULL; c = c-&gt;next()) {
489       char* top = c-&gt;top();
490       if (c-&gt;next() == NULL) {
491         top = hwm2;     // last junk is only used up to hwm2
492         assert(c-&gt;contains(hwm2), &quot;bad hwm2&quot;);
493       }
494       free_all((char**)c-&gt;bottom(), (char**)top);
495     }
496     assert(chunk-&gt;contains(hwm), &quot;bad hwm&quot;);
497     assert(chunk-&gt;contains(max), &quot;bad max&quot;);
498     free_all((char**)hwm, (char**)max);
499   } else {
500     // this chunk was partially used
501     assert(chunk-&gt;contains(hwm), &quot;bad hwm&quot;);
502     assert(chunk-&gt;contains(hwm2), &quot;bad hwm2&quot;);
503     free_all((char**)hwm, (char**)hwm2);
504   }
505 }
506 
507 #endif // Non-product
    </pre>
  </body>
</html>
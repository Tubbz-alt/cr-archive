<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/memory/universe.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classLoader.hpp&quot;
  28 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  29 #include &quot;classfile/javaClasses.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
<a name="2" id="anc2"></a>
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;code/codeBehaviours.hpp&quot;
  34 #include &quot;code/codeCache.hpp&quot;
  35 #include &quot;code/dependencies.hpp&quot;
  36 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  37 #include &quot;gc/shared/gcArguments.hpp&quot;
  38 #include &quot;gc/shared/gcConfig.hpp&quot;
  39 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  40 #include &quot;interpreter/interpreter.hpp&quot;
  41 #include &quot;logging/log.hpp&quot;
  42 #include &quot;logging/logStream.hpp&quot;
  43 #include &quot;memory/heapShared.hpp&quot;
  44 #include &quot;memory/filemap.hpp&quot;
  45 #include &quot;memory/metadataFactory.hpp&quot;
  46 #include &quot;memory/metaspaceClosure.hpp&quot;
  47 #include &quot;memory/metaspaceCounters.hpp&quot;
  48 #include &quot;memory/metaspaceShared.hpp&quot;
  49 #include &quot;memory/oopFactory.hpp&quot;
  50 #include &quot;memory/resourceArea.hpp&quot;
  51 #include &quot;memory/universe.hpp&quot;
<a name="3" id="anc3"></a><span class="line-modified">  52 #include &quot;memory/universe.hpp&quot;</span>
  53 #include &quot;oops/constantPool.hpp&quot;
  54 #include &quot;oops/instanceClassLoaderKlass.hpp&quot;
  55 #include &quot;oops/instanceKlass.hpp&quot;
  56 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  57 #include &quot;oops/instanceRefKlass.hpp&quot;
  58 #include &quot;oops/objArrayOop.inline.hpp&quot;
  59 #include &quot;oops/oop.inline.hpp&quot;
  60 #include &quot;oops/typeArrayKlass.hpp&quot;
  61 #include &quot;prims/resolvedMethodTable.hpp&quot;
  62 #include &quot;runtime/arguments.hpp&quot;
  63 #include &quot;runtime/atomic.hpp&quot;
  64 #include &quot;runtime/deoptimization.hpp&quot;
  65 #include &quot;runtime/flags/flagSetting.hpp&quot;
  66 #include &quot;runtime/flags/jvmFlagConstraintList.hpp&quot;
  67 #include &quot;runtime/handles.inline.hpp&quot;
  68 #include &quot;runtime/init.hpp&quot;
  69 #include &quot;runtime/java.hpp&quot;
  70 #include &quot;runtime/javaCalls.hpp&quot;
  71 #include &quot;runtime/sharedRuntime.hpp&quot;
  72 #include &quot;runtime/synchronizer.hpp&quot;
  73 #include &quot;runtime/thread.inline.hpp&quot;
  74 #include &quot;runtime/timerTrace.hpp&quot;
  75 #include &quot;runtime/vmOperations.hpp&quot;
  76 #include &quot;services/memoryService.hpp&quot;
  77 #include &quot;utilities/align.hpp&quot;
  78 #include &quot;utilities/copy.hpp&quot;
  79 #include &quot;utilities/debug.hpp&quot;
  80 #include &quot;utilities/events.hpp&quot;
  81 #include &quot;utilities/formatBuffer.hpp&quot;
  82 #include &quot;utilities/hashtable.inline.hpp&quot;
  83 #include &quot;utilities/macros.hpp&quot;
  84 #include &quot;utilities/ostream.hpp&quot;
  85 #include &quot;utilities/preserveException.hpp&quot;
  86 
<a name="4" id="anc4"></a>













  87 // Known objects
<a name="5" id="anc5"></a>
  88 Klass* Universe::_typeArrayKlassObjs[T_LONG+1]        = { NULL /*, NULL...*/ };
  89 Klass* Universe::_objectArrayKlassObj                 = NULL;
<a name="6" id="anc6"></a><span class="line-removed">  90 oop Universe::_int_mirror                             = NULL;</span>
<span class="line-removed">  91 oop Universe::_float_mirror                           = NULL;</span>
<span class="line-removed">  92 oop Universe::_double_mirror                          = NULL;</span>
<span class="line-removed">  93 oop Universe::_byte_mirror                            = NULL;</span>
<span class="line-removed">  94 oop Universe::_bool_mirror                            = NULL;</span>
<span class="line-removed">  95 oop Universe::_char_mirror                            = NULL;</span>
<span class="line-removed">  96 oop Universe::_long_mirror                            = NULL;</span>
<span class="line-removed">  97 oop Universe::_short_mirror                           = NULL;</span>
<span class="line-removed">  98 oop Universe::_void_mirror                            = NULL;</span>
  99 oop Universe::_mirrors[T_VOID+1]                      = { NULL /*, NULL...*/ };
 100 oop Universe::_main_thread_group                      = NULL;
 101 oop Universe::_system_thread_group                    = NULL;
 102 objArrayOop Universe::_the_empty_class_klass_array    = NULL;
 103 Array&lt;Klass*&gt;* Universe::_the_array_interfaces_array = NULL;
 104 oop Universe::_the_null_sentinel                      = NULL;
 105 oop Universe::_the_null_string                        = NULL;
 106 oop Universe::_the_min_jint_string                   = NULL;
 107 LatestMethodCache* Universe::_finalizer_register_cache = NULL;
 108 LatestMethodCache* Universe::_loader_addClass_cache    = NULL;
 109 LatestMethodCache* Universe::_throw_illegal_access_error_cache = NULL;
 110 LatestMethodCache* Universe::_throw_no_such_method_error_cache = NULL;
 111 LatestMethodCache* Universe::_do_stack_walk_cache     = NULL;
 112 oop Universe::_out_of_memory_error_java_heap          = NULL;
 113 oop Universe::_out_of_memory_error_metaspace          = NULL;
 114 oop Universe::_out_of_memory_error_class_metaspace    = NULL;
 115 oop Universe::_out_of_memory_error_array_size         = NULL;
 116 oop Universe::_out_of_memory_error_gc_overhead_limit  = NULL;
 117 oop Universe::_out_of_memory_error_realloc_objects    = NULL;
 118 oop Universe::_out_of_memory_error_retry              = NULL;
 119 oop Universe::_delayed_stack_overflow_error_message   = NULL;
 120 objArrayOop Universe::_preallocated_out_of_memory_error_array = NULL;
 121 volatile jint Universe::_preallocated_out_of_memory_error_avail_count = 0;
 122 bool Universe::_verify_in_progress                    = false;
 123 long Universe::verify_flags                           = Universe::Verify_All;
 124 oop Universe::_null_ptr_exception_instance            = NULL;
 125 oop Universe::_arithmetic_exception_instance          = NULL;
 126 oop Universe::_virtual_machine_error_instance         = NULL;
 127 oop Universe::_vm_exception                           = NULL;
 128 oop Universe::_reference_pending_list                 = NULL;
 129 
 130 Array&lt;int&gt;* Universe::_the_empty_int_array            = NULL;
 131 Array&lt;u2&gt;* Universe::_the_empty_short_array           = NULL;
 132 Array&lt;Klass*&gt;* Universe::_the_empty_klass_array     = NULL;
 133 Array&lt;InstanceKlass*&gt;* Universe::_the_empty_instance_klass_array  = NULL;
 134 Array&lt;Method*&gt;* Universe::_the_empty_method_array   = NULL;
 135 
 136 // These variables are guarded by FullGCALot_lock.
 137 debug_only(objArrayOop Universe::_fullgc_alot_dummy_array = NULL;)
 138 debug_only(int Universe::_fullgc_alot_dummy_next      = 0;)
 139 
 140 // Heap
 141 int             Universe::_verify_count = 0;
 142 
 143 // Oop verification (see MacroAssembler::verify_oop)
 144 uintptr_t       Universe::_verify_oop_mask = 0;
 145 uintptr_t       Universe::_verify_oop_bits = (uintptr_t) -1;
 146 
 147 int             Universe::_base_vtable_size = 0;
 148 bool            Universe::_bootstrapping = false;
 149 bool            Universe::_module_initialized = false;
 150 bool            Universe::_fully_initialized = false;
 151 
 152 size_t          Universe::_heap_capacity_at_last_gc;
 153 size_t          Universe::_heap_used_at_last_gc = 0;
 154 
 155 CollectedHeap*  Universe::_collectedHeap = NULL;
 156 
<a name="7" id="anc7"></a><span class="line-removed"> 157 NarrowPtrStruct Universe::_narrow_oop = { NULL, 0, true };</span>
<span class="line-removed"> 158 NarrowPtrStruct Universe::_narrow_klass = { NULL, 0, true };</span>
<span class="line-removed"> 159 address Universe::_narrow_ptrs_base;</span>
<span class="line-removed"> 160 uint64_t Universe::_narrow_klass_range = (uint64_t(max_juint)+1);</span>
<span class="line-removed"> 161 </span>
 162 void Universe::basic_type_classes_do(void f(Klass*)) {
 163   for (int i = T_BOOLEAN; i &lt; T_LONG+1; i++) {
 164     f(_typeArrayKlassObjs[i]);
 165   }
 166 }
 167 
 168 void Universe::basic_type_classes_do(KlassClosure *closure) {
 169   for (int i = T_BOOLEAN; i &lt; T_LONG+1; i++) {
 170     closure-&gt;do_klass(_typeArrayKlassObjs[i]);
 171   }
 172 }
 173 
<a name="8" id="anc8"></a><span class="line-modified"> 174 void Universe::oops_do(OopClosure* f) {</span>

 175 
<a name="9" id="anc9"></a><span class="line-modified"> 176   f-&gt;do_oop((oop*) &amp;_int_mirror);</span>
<span class="line-modified"> 177   f-&gt;do_oop((oop*) &amp;_float_mirror);</span>
<span class="line-removed"> 178   f-&gt;do_oop((oop*) &amp;_double_mirror);</span>
<span class="line-removed"> 179   f-&gt;do_oop((oop*) &amp;_byte_mirror);</span>
<span class="line-removed"> 180   f-&gt;do_oop((oop*) &amp;_bool_mirror);</span>
<span class="line-removed"> 181   f-&gt;do_oop((oop*) &amp;_char_mirror);</span>
<span class="line-removed"> 182   f-&gt;do_oop((oop*) &amp;_long_mirror);</span>
<span class="line-removed"> 183   f-&gt;do_oop((oop*) &amp;_short_mirror);</span>
<span class="line-removed"> 184   f-&gt;do_oop((oop*) &amp;_void_mirror);</span>
 185 
 186   for (int i = T_BOOLEAN; i &lt; T_VOID+1; i++) {
 187     f-&gt;do_oop((oop*) &amp;_mirrors[i]);
 188   }
 189   assert(_mirrors[0] == NULL &amp;&amp; _mirrors[T_BOOLEAN - 1] == NULL, &quot;checking&quot;);
 190 
 191   f-&gt;do_oop((oop*)&amp;_the_empty_class_klass_array);
 192   f-&gt;do_oop((oop*)&amp;_the_null_sentinel);
 193   f-&gt;do_oop((oop*)&amp;_the_null_string);
 194   f-&gt;do_oop((oop*)&amp;_the_min_jint_string);
 195   f-&gt;do_oop((oop*)&amp;_out_of_memory_error_java_heap);
 196   f-&gt;do_oop((oop*)&amp;_out_of_memory_error_metaspace);
 197   f-&gt;do_oop((oop*)&amp;_out_of_memory_error_class_metaspace);
 198   f-&gt;do_oop((oop*)&amp;_out_of_memory_error_array_size);
 199   f-&gt;do_oop((oop*)&amp;_out_of_memory_error_gc_overhead_limit);
 200   f-&gt;do_oop((oop*)&amp;_out_of_memory_error_realloc_objects);
 201   f-&gt;do_oop((oop*)&amp;_out_of_memory_error_retry);
 202   f-&gt;do_oop((oop*)&amp;_delayed_stack_overflow_error_message);
 203   f-&gt;do_oop((oop*)&amp;_preallocated_out_of_memory_error_array);
 204   f-&gt;do_oop((oop*)&amp;_null_ptr_exception_instance);
 205   f-&gt;do_oop((oop*)&amp;_arithmetic_exception_instance);
 206   f-&gt;do_oop((oop*)&amp;_virtual_machine_error_instance);
 207   f-&gt;do_oop((oop*)&amp;_main_thread_group);
 208   f-&gt;do_oop((oop*)&amp;_system_thread_group);
 209   f-&gt;do_oop((oop*)&amp;_vm_exception);
 210   f-&gt;do_oop((oop*)&amp;_reference_pending_list);
 211   debug_only(f-&gt;do_oop((oop*)&amp;_fullgc_alot_dummy_array);)
 212 }
 213 
 214 void LatestMethodCache::metaspace_pointers_do(MetaspaceClosure* it) {
 215   it-&gt;push(&amp;_klass);
 216 }
 217 
 218 void Universe::metaspace_pointers_do(MetaspaceClosure* it) {
 219   for (int i = 0; i &lt; T_LONG+1; i++) {
 220     it-&gt;push(&amp;_typeArrayKlassObjs[i]);
 221   }
 222   it-&gt;push(&amp;_objectArrayKlassObj);
 223 
 224   it-&gt;push(&amp;_the_empty_int_array);
 225   it-&gt;push(&amp;_the_empty_short_array);
 226   it-&gt;push(&amp;_the_empty_klass_array);
 227   it-&gt;push(&amp;_the_empty_instance_klass_array);
 228   it-&gt;push(&amp;_the_empty_method_array);
 229   it-&gt;push(&amp;_the_array_interfaces_array);
 230 
 231   _finalizer_register_cache-&gt;metaspace_pointers_do(it);
 232   _loader_addClass_cache-&gt;metaspace_pointers_do(it);
 233   _throw_illegal_access_error_cache-&gt;metaspace_pointers_do(it);
 234   _throw_no_such_method_error_cache-&gt;metaspace_pointers_do(it);
 235   _do_stack_walk_cache-&gt;metaspace_pointers_do(it);
 236 }
 237 
<a name="10" id="anc10"></a>






 238 // Serialize metadata and pointers to primitive type mirrors in and out of CDS archive
 239 void Universe::serialize(SerializeClosure* f) {
 240 
 241   for (int i = 0; i &lt; T_LONG+1; i++) {
 242     f-&gt;do_ptr((void**)&amp;_typeArrayKlassObjs[i]);
 243   }
 244 
 245   f-&gt;do_ptr((void**)&amp;_objectArrayKlassObj);
<a name="11" id="anc11"></a>
 246 #if INCLUDE_CDS_JAVA_HEAP
<a name="12" id="anc12"></a><span class="line-modified"> 247 #ifdef ASSERT</span>
<span class="line-modified"> 248   if (DumpSharedSpaces &amp;&amp; !HeapShared::is_heap_object_archiving_allowed()) {</span>
<span class="line-modified"> 249     assert(_int_mirror == NULL    &amp;&amp; _float_mirror == NULL &amp;&amp;</span>
<span class="line-modified"> 250            _double_mirror == NULL &amp;&amp; _byte_mirror == NULL  &amp;&amp;</span>
<span class="line-removed"> 251            _bool_mirror == NULL   &amp;&amp; _char_mirror == NULL  &amp;&amp;</span>
<span class="line-removed"> 252            _long_mirror == NULL   &amp;&amp; _short_mirror == NULL &amp;&amp;</span>
<span class="line-removed"> 253            _void_mirror == NULL, &quot;mirrors should be NULL&quot;);</span>
<span class="line-removed"> 254   }</span>
<span class="line-removed"> 255 #endif</span>
<span class="line-removed"> 256   f-&gt;do_oop(&amp;_int_mirror);</span>
<span class="line-removed"> 257   f-&gt;do_oop(&amp;_float_mirror);</span>
<span class="line-removed"> 258   f-&gt;do_oop(&amp;_double_mirror);</span>
<span class="line-removed"> 259   f-&gt;do_oop(&amp;_byte_mirror);</span>
<span class="line-removed"> 260   f-&gt;do_oop(&amp;_bool_mirror);</span>
<span class="line-removed"> 261   f-&gt;do_oop(&amp;_char_mirror);</span>
<span class="line-removed"> 262   f-&gt;do_oop(&amp;_long_mirror);</span>
<span class="line-removed"> 263   f-&gt;do_oop(&amp;_short_mirror);</span>
<span class="line-removed"> 264   f-&gt;do_oop(&amp;_void_mirror);</span>
 265 #endif
 266 
 267   f-&gt;do_ptr((void**)&amp;_the_array_interfaces_array);
 268   f-&gt;do_ptr((void**)&amp;_the_empty_int_array);
 269   f-&gt;do_ptr((void**)&amp;_the_empty_short_array);
 270   f-&gt;do_ptr((void**)&amp;_the_empty_method_array);
 271   f-&gt;do_ptr((void**)&amp;_the_empty_klass_array);
 272   f-&gt;do_ptr((void**)&amp;_the_empty_instance_klass_array);
 273   _finalizer_register_cache-&gt;serialize(f);
 274   _loader_addClass_cache-&gt;serialize(f);
 275   _throw_illegal_access_error_cache-&gt;serialize(f);
 276   _throw_no_such_method_error_cache-&gt;serialize(f);
 277   _do_stack_walk_cache-&gt;serialize(f);
 278 }
 279 
 280 void Universe::check_alignment(uintx size, uintx alignment, const char* name) {
 281   if (size &lt; alignment || size % alignment != 0) {
 282     vm_exit_during_initialization(
 283       err_msg(&quot;Size of %s (&quot; UINTX_FORMAT &quot; bytes) must be aligned to &quot; UINTX_FORMAT &quot; bytes&quot;, name, size, alignment));
 284   }
 285 }
 286 
 287 void initialize_basic_type_klass(Klass* k, TRAPS) {
 288   Klass* ok = SystemDictionary::Object_klass();
 289 #if INCLUDE_CDS
 290   if (UseSharedSpaces) {
 291     ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
 292     assert(k-&gt;super() == ok, &quot;u3&quot;);
 293     k-&gt;restore_unshareable_info(loader_data, Handle(), CHECK);
 294   } else
 295 #endif
 296   {
 297     k-&gt;initialize_supers(ok, NULL, CHECK);
 298   }
 299   k-&gt;append_to_sibling_list();
 300 }
 301 
 302 void Universe::genesis(TRAPS) {
<a name="13" id="anc13"></a><span class="line-modified"> 303   ResourceMark rm;</span>
 304 
 305   { FlagSetting fs(_bootstrapping, true);
 306 
<a name="14" id="anc14"></a><span class="line-modified"> 307     { MutexLocker mc(Compile_lock);</span>
 308 
 309       java_lang_Class::allocate_fixup_lists();
 310 
 311       // determine base vtable size; without that we cannot create the array klasses
 312       compute_base_vtable_size();
 313 
 314       if (!UseSharedSpaces) {
 315         for (int i = T_BOOLEAN; i &lt; T_LONG+1; i++) {
 316           _typeArrayKlassObjs[i] = TypeArrayKlass::create_klass((BasicType)i, CHECK);
 317         }
 318 
 319         ClassLoaderData* null_cld = ClassLoaderData::the_null_class_loader_data();
 320 
 321         _the_array_interfaces_array     = MetadataFactory::new_array&lt;Klass*&gt;(null_cld, 2, NULL, CHECK);
 322         _the_empty_int_array            = MetadataFactory::new_array&lt;int&gt;(null_cld, 0, CHECK);
 323         _the_empty_short_array          = MetadataFactory::new_array&lt;u2&gt;(null_cld, 0, CHECK);
 324         _the_empty_method_array         = MetadataFactory::new_array&lt;Method*&gt;(null_cld, 0, CHECK);
 325         _the_empty_klass_array          = MetadataFactory::new_array&lt;Klass*&gt;(null_cld, 0, CHECK);
 326         _the_empty_instance_klass_array = MetadataFactory::new_array&lt;InstanceKlass*&gt;(null_cld, 0, CHECK);
 327       }
 328     }
 329 
 330     vmSymbols::initialize(CHECK);
 331 
 332     SystemDictionary::initialize(CHECK);
 333 
 334     Klass* ok = SystemDictionary::Object_klass();
 335 
 336     _the_null_string            = StringTable::intern(&quot;null&quot;, CHECK);
 337     _the_min_jint_string       = StringTable::intern(&quot;-2147483648&quot;, CHECK);
 338 
 339 #if INCLUDE_CDS
 340     if (UseSharedSpaces) {
 341       // Verify shared interfaces array.
 342       assert(_the_array_interfaces_array-&gt;at(0) ==
 343              SystemDictionary::Cloneable_klass(), &quot;u3&quot;);
 344       assert(_the_array_interfaces_array-&gt;at(1) ==
 345              SystemDictionary::Serializable_klass(), &quot;u3&quot;);
 346     } else
 347 #endif
 348     {
 349       // Set up shared interfaces array.  (Do this before supers are set up.)
 350       _the_array_interfaces_array-&gt;at_put(0, SystemDictionary::Cloneable_klass());
 351       _the_array_interfaces_array-&gt;at_put(1, SystemDictionary::Serializable_klass());
 352     }
 353 
 354     initialize_basic_type_klass(boolArrayKlassObj(), CHECK);
 355     initialize_basic_type_klass(charArrayKlassObj(), CHECK);
 356     initialize_basic_type_klass(floatArrayKlassObj(), CHECK);
 357     initialize_basic_type_klass(doubleArrayKlassObj(), CHECK);
 358     initialize_basic_type_klass(byteArrayKlassObj(), CHECK);
 359     initialize_basic_type_klass(shortArrayKlassObj(), CHECK);
 360     initialize_basic_type_klass(intArrayKlassObj(), CHECK);
 361     initialize_basic_type_klass(longArrayKlassObj(), CHECK);
 362   } // end of core bootstrapping
 363 
 364   {
 365     Handle tns = java_lang_String::create_from_str(&quot;&lt;null_sentinel&gt;&quot;, CHECK);
 366     _the_null_sentinel = tns();
 367   }
 368 
 369   // Maybe this could be lifted up now that object array can be initialized
 370   // during the bootstrapping.
 371 
 372   // OLD
 373   // Initialize _objectArrayKlass after core bootstraping to make
 374   // sure the super class is set up properly for _objectArrayKlass.
 375   // ---
 376   // NEW
 377   // Since some of the old system object arrays have been converted to
 378   // ordinary object arrays, _objectArrayKlass will be loaded when
 379   // SystemDictionary::initialize(CHECK); is run. See the extra check
 380   // for Object_klass_loaded in objArrayKlassKlass::allocate_objArray_klass_impl.
 381   _objectArrayKlassObj = InstanceKlass::
 382     cast(SystemDictionary::Object_klass())-&gt;array_klass(1, CHECK);
 383   // OLD
 384   // Add the class to the class hierarchy manually to make sure that
 385   // its vtable is initialized after core bootstrapping is completed.
 386   // ---
 387   // New
 388   // Have already been initialized.
 389   _objectArrayKlassObj-&gt;append_to_sibling_list();
 390 
 391   #ifdef ASSERT
 392   if (FullGCALot) {
 393     // Allocate an array of dummy objects.
 394     // We&#39;d like these to be at the bottom of the old generation,
 395     // so that when we free one and then collect,
 396     // (almost) the whole heap moves
 397     // and we find out if we actually update all the oops correctly.
 398     // But we can&#39;t allocate directly in the old generation,
 399     // so we allocate wherever, and hope that the first collection
 400     // moves these objects to the bottom of the old generation.
 401     // We can allocate directly in the permanent generation, so we do.
<a name="15" id="anc15"></a><span class="line-modified"> 402     int size;</span>
<span class="line-modified"> 403     if (UseConcMarkSweepGC) {</span>
<span class="line-removed"> 404       log_warning(gc)(&quot;Using +FullGCALot with concurrent mark sweep gc will not force all objects to relocate&quot;);</span>
<span class="line-removed"> 405       size = FullGCALotDummies;</span>
<span class="line-removed"> 406     } else {</span>
<span class="line-removed"> 407       size = FullGCALotDummies * 2;</span>
<span class="line-removed"> 408     }</span>
 409     objArrayOop    naked_array = oopFactory::new_objArray(SystemDictionary::Object_klass(), size, CHECK);
 410     objArrayHandle dummy_array(THREAD, naked_array);
 411     int i = 0;
 412     while (i &lt; size) {
 413         // Allocate dummy in old generation
 414       oop dummy = SystemDictionary::Object_klass()-&gt;allocate_instance(CHECK);
 415       dummy_array-&gt;obj_at_put(i++, dummy);
 416     }
 417     {
 418       // Only modify the global variable inside the mutex.
 419       // If we had a race to here, the other dummy_array instances
 420       // and their elements just get dropped on the floor, which is fine.
<a name="16" id="anc16"></a><span class="line-modified"> 421       MutexLocker ml(FullGCALot_lock);</span>
 422       if (_fullgc_alot_dummy_array == NULL) {
 423         _fullgc_alot_dummy_array = dummy_array();
 424       }
 425     }
 426     assert(i == _fullgc_alot_dummy_array-&gt;length(), &quot;just checking&quot;);
 427   }
 428   #endif
 429 }
 430 
<a name="17" id="anc17"></a>


 431 void Universe::initialize_basic_type_mirrors(TRAPS) {
 432 #if INCLUDE_CDS_JAVA_HEAP
 433     if (UseSharedSpaces &amp;&amp;
 434         HeapShared::open_archive_heap_region_mapped() &amp;&amp;
 435         _int_mirror != NULL) {
 436       assert(HeapShared::is_heap_object_archiving_allowed(), &quot;Sanity&quot;);
<a name="18" id="anc18"></a><span class="line-modified"> 437       assert(_float_mirror != NULL &amp;&amp; _double_mirror != NULL &amp;&amp;</span>
<span class="line-removed"> 438              _byte_mirror  != NULL &amp;&amp; _byte_mirror   != NULL &amp;&amp;</span>
<span class="line-removed"> 439              _bool_mirror  != NULL &amp;&amp; _char_mirror   != NULL &amp;&amp;</span>
<span class="line-removed"> 440              _long_mirror  != NULL &amp;&amp; _short_mirror  != NULL &amp;&amp;</span>
<span class="line-removed"> 441              _void_mirror  != NULL, &quot;Sanity&quot;);</span>
 442     } else
<a name="19" id="anc19"></a>
 443 #endif
 444     {
 445       _int_mirror     =
 446         java_lang_Class::create_basic_type_mirror(&quot;int&quot;,    T_INT, CHECK);
 447       _float_mirror   =
 448         java_lang_Class::create_basic_type_mirror(&quot;float&quot;,  T_FLOAT,   CHECK);
 449       _double_mirror  =
 450         java_lang_Class::create_basic_type_mirror(&quot;double&quot;, T_DOUBLE,  CHECK);
 451       _byte_mirror    =
 452         java_lang_Class::create_basic_type_mirror(&quot;byte&quot;,   T_BYTE, CHECK);
 453       _bool_mirror    =
 454         java_lang_Class::create_basic_type_mirror(&quot;boolean&quot;,T_BOOLEAN, CHECK);
 455       _char_mirror    =
 456         java_lang_Class::create_basic_type_mirror(&quot;char&quot;,   T_CHAR, CHECK);
 457       _long_mirror    =
 458         java_lang_Class::create_basic_type_mirror(&quot;long&quot;,   T_LONG, CHECK);
 459       _short_mirror   =
 460         java_lang_Class::create_basic_type_mirror(&quot;short&quot;,  T_SHORT,   CHECK);
 461       _void_mirror    =
 462         java_lang_Class::create_basic_type_mirror(&quot;void&quot;,   T_VOID, CHECK);
 463     }
 464 
 465     _mirrors[T_INT]     = _int_mirror;
 466     _mirrors[T_FLOAT]   = _float_mirror;
 467     _mirrors[T_DOUBLE]  = _double_mirror;
 468     _mirrors[T_BYTE]    = _byte_mirror;
 469     _mirrors[T_BOOLEAN] = _bool_mirror;
 470     _mirrors[T_CHAR]    = _char_mirror;
 471     _mirrors[T_LONG]    = _long_mirror;
 472     _mirrors[T_SHORT]   = _short_mirror;
 473     _mirrors[T_VOID]    = _void_mirror;
 474   //_mirrors[T_OBJECT]  = _object_klass-&gt;java_mirror();
 475   //_mirrors[T_ARRAY]   = _object_klass-&gt;java_mirror();
 476 }
 477 
 478 void Universe::fixup_mirrors(TRAPS) {
 479   // Bootstrap problem: all classes gets a mirror (java.lang.Class instance) assigned eagerly,
 480   // but we cannot do that for classes created before java.lang.Class is loaded. Here we simply
 481   // walk over permanent objects created so far (mostly classes) and fixup their mirrors. Note
 482   // that the number of objects allocated at this point is very small.
 483   assert(SystemDictionary::Class_klass_loaded(), &quot;java.lang.Class should be loaded&quot;);
 484   HandleMark hm(THREAD);
 485 
 486   if (!UseSharedSpaces) {
 487     // Cache the start of the static fields
 488     InstanceMirrorKlass::init_offset_of_static_fields();
 489   }
 490 
 491   GrowableArray &lt;Klass*&gt;* list = java_lang_Class::fixup_mirror_list();
 492   int list_length = list-&gt;length();
 493   for (int i = 0; i &lt; list_length; i++) {
 494     Klass* k = list-&gt;at(i);
 495     assert(k-&gt;is_klass(), &quot;List should only hold classes&quot;);
 496     EXCEPTION_MARK;
 497     java_lang_Class::fixup_mirror(k, CATCH);
 498   }
 499   delete java_lang_Class::fixup_mirror_list();
 500   java_lang_Class::set_fixup_mirror_list(NULL);
 501 }
 502 
 503 #define assert_pll_locked(test) \
 504   assert(Heap_lock-&gt;test(), &quot;Reference pending list access requires lock&quot;)
 505 
 506 #define assert_pll_ownership() assert_pll_locked(owned_by_self)
 507 
 508 oop Universe::reference_pending_list() {
 509   if (Thread::current()-&gt;is_VM_thread()) {
 510     assert_pll_locked(is_locked);
 511   } else {
 512     assert_pll_ownership();
 513   }
 514   return _reference_pending_list;
 515 }
 516 
 517 void Universe::set_reference_pending_list(oop list) {
 518   assert_pll_ownership();
 519   _reference_pending_list = list;
 520 }
 521 
 522 bool Universe::has_reference_pending_list() {
 523   assert_pll_ownership();
 524   return _reference_pending_list != NULL;
 525 }
 526 
 527 oop Universe::swap_reference_pending_list(oop list) {
 528   assert_pll_locked(is_locked);
<a name="20" id="anc20"></a><span class="line-modified"> 529   return Atomic::xchg(list, &amp;_reference_pending_list);</span>
 530 }
 531 
 532 #undef assert_pll_locked
 533 #undef assert_pll_ownership
 534 
 535 void Universe::reinitialize_vtable_of(Klass* ko, TRAPS) {
 536   // init vtable of k and all subclasses
 537   ko-&gt;vtable().initialize_vtable(false, CHECK);
 538   if (ko-&gt;is_instance_klass()) {
 539     for (Klass* sk = ko-&gt;subklass();
 540          sk != NULL;
 541          sk = sk-&gt;next_sibling()) {
 542       reinitialize_vtable_of(sk, CHECK);
 543     }
 544   }
 545 }
 546 
 547 void Universe::reinitialize_vtables(TRAPS) {
 548   // The vtables are initialized by starting at java.lang.Object and
 549   // initializing through the subclass links, so that the super
 550   // classes are always initialized first.
 551   Klass* ok = SystemDictionary::Object_klass();
 552   Universe::reinitialize_vtable_of(ok, THREAD);
 553 }
 554 
 555 
 556 void initialize_itable_for_klass(InstanceKlass* k, TRAPS) {
 557   k-&gt;itable().initialize_itable(false, CHECK);
 558 }
 559 
 560 
 561 void Universe::reinitialize_itables(TRAPS) {
<a name="21" id="anc21"></a><span class="line-modified"> 562   MutexLocker mcld(ClassLoaderDataGraph_lock);</span>
 563   ClassLoaderDataGraph::dictionary_classes_do(initialize_itable_for_klass, CHECK);
 564 }
 565 
 566 
 567 bool Universe::on_page_boundary(void* addr) {
 568   return is_aligned(addr, os::vm_page_size());
 569 }
 570 
 571 
 572 bool Universe::should_fill_in_stack_trace(Handle throwable) {
 573   // never attempt to fill in the stack trace of preallocated errors that do not have
 574   // backtrace. These errors are kept alive forever and may be &quot;re-used&quot; when all
 575   // preallocated errors with backtrace have been consumed. Also need to avoid
 576   // a potential loop which could happen if an out of memory occurs when attempting
 577   // to allocate the backtrace.
<a name="22" id="anc22"></a><span class="line-modified"> 578   return ((!oopDesc::equals(throwable(), Universe::_out_of_memory_error_java_heap)) &amp;&amp;</span>
<span class="line-modified"> 579           (!oopDesc::equals(throwable(), Universe::_out_of_memory_error_metaspace))  &amp;&amp;</span>
<span class="line-modified"> 580           (!oopDesc::equals(throwable(), Universe::_out_of_memory_error_class_metaspace))  &amp;&amp;</span>
<span class="line-modified"> 581           (!oopDesc::equals(throwable(), Universe::_out_of_memory_error_array_size)) &amp;&amp;</span>
<span class="line-modified"> 582           (!oopDesc::equals(throwable(), Universe::_out_of_memory_error_gc_overhead_limit)) &amp;&amp;</span>
<span class="line-modified"> 583           (!oopDesc::equals(throwable(), Universe::_out_of_memory_error_realloc_objects)) &amp;&amp;</span>
<span class="line-modified"> 584           (!oopDesc::equals(throwable(), Universe::_out_of_memory_error_retry)));</span>
 585 }
 586 
 587 
 588 oop Universe::gen_out_of_memory_error(oop default_err) {
 589   // generate an out of memory error:
 590   // - if there is a preallocated error and stack traces are available
 591   //   (j.l.Throwable is initialized), then return the preallocated
 592   //   error with a filled in stack trace, and with the message
 593   //   provided by the default error.
 594   // - otherwise, return the default error, without a stack trace.
 595   int next;
 596   if ((_preallocated_out_of_memory_error_avail_count &gt; 0) &amp;&amp;
 597       SystemDictionary::Throwable_klass()-&gt;is_initialized()) {
<a name="23" id="anc23"></a><span class="line-modified"> 598     next = (int)Atomic::add(-1, &amp;_preallocated_out_of_memory_error_avail_count);</span>
 599     assert(next &lt; (int)PreallocatedOutOfMemoryErrorCount, &quot;avail count is corrupt&quot;);
 600   } else {
 601     next = -1;
 602   }
 603   if (next &lt; 0) {
 604     // all preallocated errors have been used.
 605     // return default
 606     return default_err;
 607   } else {
 608     Thread* THREAD = Thread::current();
 609     Handle default_err_h(THREAD, default_err);
 610     // get the error object at the slot and set set it to NULL so that the
 611     // array isn&#39;t keeping it alive anymore.
 612     Handle exc(THREAD, preallocated_out_of_memory_errors()-&gt;obj_at(next));
 613     assert(exc() != NULL, &quot;slot has been used already&quot;);
 614     preallocated_out_of_memory_errors()-&gt;obj_at_put(next, NULL);
 615 
 616     // use the message from the default error
 617     oop msg = java_lang_Throwable::message(default_err_h());
 618     assert(msg != NULL, &quot;no message&quot;);
 619     java_lang_Throwable::set_message(exc(), msg);
 620 
 621     // populate the stack trace and return it.
 622     java_lang_Throwable::fill_in_stack_trace_of_preallocated_backtrace(exc);
 623     return exc();
 624   }
 625 }
 626 
 627 intptr_t Universe::_non_oop_bits = 0;
 628 
 629 void* Universe::non_oop_word() {
 630   // Neither the high bits nor the low bits of this value is allowed
 631   // to look like (respectively) the high or low bits of a real oop.
 632   //
 633   // High and low are CPU-specific notions, but low always includes
 634   // the low-order bit.  Since oops are always aligned at least mod 4,
 635   // setting the low-order bit will ensure that the low half of the
 636   // word will never look like that of a real oop.
 637   //
 638   // Using the OS-supplied non-memory-address word (usually 0 or -1)
 639   // will take care of the high bits, however many there are.
 640 
 641   if (_non_oop_bits == 0) {
 642     _non_oop_bits = (intptr_t)os::non_memory_address_word() | 1;
 643   }
 644 
 645   return (void*)_non_oop_bits;
 646 }
 647 
 648 static void initialize_global_behaviours() {
 649   CompiledICProtectionBehaviour::set_current(new DefaultICProtectionBehaviour());
 650 }
 651 
 652 jint universe_init() {
 653   assert(!Universe::_fully_initialized, &quot;called after initialize_vtables&quot;);
 654   guarantee(1 &lt;&lt; LogHeapWordSize == sizeof(HeapWord),
 655          &quot;LogHeapWordSize is incorrect.&quot;);
 656   guarantee(sizeof(oop) &gt;= sizeof(HeapWord), &quot;HeapWord larger than oop?&quot;);
 657   guarantee(sizeof(oop) % sizeof(HeapWord) == 0,
 658             &quot;oop size is not not a multiple of HeapWord size&quot;);
 659 
 660   TraceTime timer(&quot;Genesis&quot;, TRACETIME_LOG(Info, startuptime));
 661 
 662   JavaClasses::compute_hard_coded_offsets();
 663 
 664   initialize_global_behaviours();
 665 
<a name="24" id="anc24"></a>

 666   jint status = Universe::initialize_heap();
 667   if (status != JNI_OK) {
 668     return status;
 669   }
 670 
<a name="25" id="anc25"></a><span class="line-modified"> 671   SystemDictionary::initialize_oop_storage();</span>
 672 
 673   Metaspace::global_initialize();
 674 
 675   // Initialize performance counters for metaspaces
 676   MetaspaceCounters::initialize_performance_counters();
 677   CompressedClassSpaceCounters::initialize_performance_counters();
 678 
 679   AOTLoader::universe_init();
 680 
 681   // Checks &#39;AfterMemoryInit&#39; constraints.
 682   if (!JVMFlagConstraintList::check_constraints(JVMFlagConstraint::AfterMemoryInit)) {
 683     return JNI_EINVAL;
 684   }
 685 
 686   // Create memory for metadata.  Must be after initializing heap for
 687   // DumpSharedSpaces.
 688   ClassLoaderData::init_null_class_loader_data();
 689 
 690   // We have a heap so create the Method* caches before
 691   // Metaspace::initialize_shared_spaces() tries to populate them.
 692   Universe::_finalizer_register_cache = new LatestMethodCache();
 693   Universe::_loader_addClass_cache    = new LatestMethodCache();
 694   Universe::_throw_illegal_access_error_cache = new LatestMethodCache();
 695   Universe::_throw_no_such_method_error_cache = new LatestMethodCache();
 696   Universe::_do_stack_walk_cache = new LatestMethodCache();
 697 
 698 #if INCLUDE_CDS
 699   if (UseSharedSpaces) {
 700     // Read the data structures supporting the shared spaces (shared
 701     // system dictionary, symbol table, etc.).  After that, access to
 702     // the file (other than the mapped regions) is no longer needed, and
 703     // the file is closed. Closing the file does not affect the
 704     // currently mapped regions.
 705     MetaspaceShared::initialize_shared_spaces();
 706     StringTable::create_table();
 707   } else
 708 #endif
 709   {
 710     SymbolTable::create_table();
 711     StringTable::create_table();
<a name="26" id="anc26"></a>
 712 
 713 #if INCLUDE_CDS
<a name="27" id="anc27"></a><span class="line-modified"> 714     if (DumpSharedSpaces) {</span>
<span class="line-modified"> 715       MetaspaceShared::prepare_for_dumping();</span>
<span class="line-removed"> 716     }</span>
<span class="line-removed"> 717 #endif</span>
 718   }
<a name="28" id="anc28"></a>

 719   if (strlen(VerifySubSet) &gt; 0) {
 720     Universe::initialize_verify_flags();
 721   }
 722 
 723   ResolvedMethodTable::create_table();
 724 
 725   return JNI_OK;
 726 }
 727 
<a name="29" id="anc29"></a><span class="line-removed"> 728 CollectedHeap* Universe::create_heap() {</span>
<span class="line-removed"> 729   assert(_collectedHeap == NULL, &quot;Heap already created&quot;);</span>
<span class="line-removed"> 730   return GCConfig::arguments()-&gt;create_heap();</span>
<span class="line-removed"> 731 }</span>
<span class="line-removed"> 732 </span>
<span class="line-removed"> 733 // Choose the heap base address and oop encoding mode</span>
<span class="line-removed"> 734 // when compressed oops are used:</span>
<span class="line-removed"> 735 // Unscaled  - Use 32-bits oops without encoding when</span>
<span class="line-removed"> 736 //     NarrowOopHeapBaseMin + heap_size &lt; 4Gb</span>
<span class="line-removed"> 737 // ZeroBased - Use zero based compressed oops with encoding when</span>
<span class="line-removed"> 738 //     NarrowOopHeapBaseMin + heap_size &lt; 32Gb</span>
<span class="line-removed"> 739 // HeapBased - Use compressed oops with heap base + encoding.</span>
<span class="line-removed"> 740 </span>
 741 jint Universe::initialize_heap() {
<a name="30" id="anc30"></a><span class="line-modified"> 742   _collectedHeap = create_heap();</span>

 743   jint status = _collectedHeap-&gt;initialize();
<a name="31" id="anc31"></a><span class="line-removed"> 744   if (status != JNI_OK) {</span>
<span class="line-removed"> 745     return status;</span>
<span class="line-removed"> 746   }</span>
<span class="line-removed"> 747   log_info(gc)(&quot;Using %s&quot;, _collectedHeap-&gt;name());</span>
<span class="line-removed"> 748 </span>
<span class="line-removed"> 749   ThreadLocalAllocBuffer::set_max_size(Universe::heap()-&gt;max_tlab_size());</span>
<span class="line-removed"> 750 </span>
<span class="line-removed"> 751 #ifdef _LP64</span>
<span class="line-removed"> 752   if (UseCompressedOops) {</span>
<span class="line-removed"> 753     // Subtract a page because something can get allocated at heap base.</span>
<span class="line-removed"> 754     // This also makes implicit null checking work, because the</span>
<span class="line-removed"> 755     // memory+1 page below heap_base needs to cause a signal.</span>
<span class="line-removed"> 756     // See needs_explicit_null_check.</span>
<span class="line-removed"> 757     // Only set the heap base for compressed oops because it indicates</span>
<span class="line-removed"> 758     // compressed oops for pstack code.</span>
<span class="line-removed"> 759     if ((uint64_t)Universe::heap()-&gt;reserved_region().end() &gt; UnscaledOopHeapMax) {</span>
<span class="line-removed"> 760       // Didn&#39;t reserve heap below 4Gb.  Must shift.</span>
<span class="line-removed"> 761       Universe::set_narrow_oop_shift(LogMinObjAlignmentInBytes);</span>
<span class="line-removed"> 762     }</span>
<span class="line-removed"> 763     if ((uint64_t)Universe::heap()-&gt;reserved_region().end() &lt;= OopEncodingHeapMax) {</span>
<span class="line-removed"> 764       // Did reserve heap below 32Gb. Can use base == 0;</span>
<span class="line-removed"> 765       Universe::set_narrow_oop_base(0);</span>
<span class="line-removed"> 766     }</span>
<span class="line-removed"> 767     AOTLoader::set_narrow_oop_shift();</span>
<span class="line-removed"> 768 </span>
<span class="line-removed"> 769     Universe::set_narrow_ptrs_base(Universe::narrow_oop_base());</span>
<span class="line-removed"> 770 </span>
<span class="line-removed"> 771     LogTarget(Info, gc, heap, coops) lt;</span>
<span class="line-removed"> 772     if (lt.is_enabled()) {</span>
<span class="line-removed"> 773       ResourceMark rm;</span>
<span class="line-removed"> 774       LogStream ls(lt);</span>
<span class="line-removed"> 775       Universe::print_compressed_oops_mode(&amp;ls);</span>
<span class="line-removed"> 776     }</span>
 777 
<a name="32" id="anc32"></a><span class="line-modified"> 778     // Tell tests in which mode we run.</span>
<span class="line-modified"> 779     Arguments::PropertyList_add(new SystemProperty(&quot;java.vm.compressedOopsMode&quot;,</span>
<span class="line-removed"> 780                                                    narrow_oop_mode_to_string(narrow_oop_mode()),</span>
<span class="line-removed"> 781                                                    false));</span>
 782   }
<a name="33" id="anc33"></a><span class="line-removed"> 783   // Universe::narrow_oop_base() is one page below the heap.</span>
<span class="line-removed"> 784   assert((intptr_t)Universe::narrow_oop_base() &lt;= (intptr_t)(Universe::heap()-&gt;base() -</span>
<span class="line-removed"> 785          os::vm_page_size()) ||</span>
<span class="line-removed"> 786          Universe::narrow_oop_base() == NULL, &quot;invalid value&quot;);</span>
<span class="line-removed"> 787   assert(Universe::narrow_oop_shift() == LogMinObjAlignmentInBytes ||</span>
<span class="line-removed"> 788          Universe::narrow_oop_shift() == 0, &quot;invalid value&quot;);</span>
<span class="line-removed"> 789 #endif</span>
 790 
<a name="34" id="anc34"></a><span class="line-modified"> 791   // We will never reach the CATCH below since Exceptions::_throw will cause</span>
<span class="line-modified"> 792   // the VM to exit if an exception is thrown during initialization</span>
 793 
<a name="35" id="anc35"></a>

 794   if (UseTLAB) {
 795     assert(Universe::heap()-&gt;supports_tlab_allocation(),
 796            &quot;Should support thread-local allocation buffers&quot;);
 797     ThreadLocalAllocBuffer::startup_initialization();
 798   }
<a name="36" id="anc36"></a><span class="line-removed"> 799   return JNI_OK;</span>
<span class="line-removed"> 800 }</span>
<span class="line-removed"> 801 </span>
<span class="line-removed"> 802 void Universe::print_compressed_oops_mode(outputStream* st) {</span>
<span class="line-removed"> 803   st-&gt;print(&quot;Heap address: &quot; PTR_FORMAT &quot;, size: &quot; SIZE_FORMAT &quot; MB&quot;,</span>
<span class="line-removed"> 804             p2i(Universe::heap()-&gt;base()), Universe::heap()-&gt;reserved_region().byte_size()/M);</span>
<span class="line-removed"> 805 </span>
<span class="line-removed"> 806   st-&gt;print(&quot;, Compressed Oops mode: %s&quot;, narrow_oop_mode_to_string(narrow_oop_mode()));</span>
<span class="line-removed"> 807 </span>
<span class="line-removed"> 808   if (Universe::narrow_oop_base() != 0) {</span>
<span class="line-removed"> 809     st-&gt;print(&quot;: &quot; PTR_FORMAT, p2i(Universe::narrow_oop_base()));</span>
<span class="line-removed"> 810   }</span>
<span class="line-removed"> 811 </span>
<span class="line-removed"> 812   if (Universe::narrow_oop_shift() != 0) {</span>
<span class="line-removed"> 813     st-&gt;print(&quot;, Oop shift amount: %d&quot;, Universe::narrow_oop_shift());</span>
<span class="line-removed"> 814   }</span>
<span class="line-removed"> 815 </span>
<span class="line-removed"> 816   if (!Universe::narrow_oop_use_implicit_null_checks()) {</span>
<span class="line-removed"> 817     st-&gt;print(&quot;, no protected page in front of the heap&quot;);</span>
<span class="line-removed"> 818   }</span>
<span class="line-removed"> 819   st-&gt;cr();</span>
 820 }
 821 
<a name="37" id="anc37"></a><span class="line-modified"> 822 ReservedSpace Universe::reserve_heap(size_t heap_size, size_t alignment) {</span>
 823 
 824   assert(alignment &lt;= Arguments::conservative_max_heap_alignment(),
 825          &quot;actual alignment &quot; SIZE_FORMAT &quot; must be within maximum heap alignment &quot; SIZE_FORMAT,
 826          alignment, Arguments::conservative_max_heap_alignment());
 827 
 828   size_t total_reserved = align_up(heap_size, alignment);
 829   assert(!UseCompressedOops || (total_reserved &lt;= (OopEncodingHeapMax - os::vm_page_size())),
 830       &quot;heap size is too big for compressed oops&quot;);
 831 
 832   bool use_large_pages = UseLargePages &amp;&amp; is_aligned(alignment, os::large_page_size());
 833   assert(!UseLargePages
 834       || UseParallelGC
 835       || use_large_pages, &quot;Wrong alignment to use large pages&quot;);
 836 
 837   // Now create the space.
 838   ReservedHeapSpace total_rs(total_reserved, alignment, use_large_pages, AllocateHeapAt);
 839 
 840   if (total_rs.is_reserved()) {
 841     assert((total_reserved == total_rs.size()) &amp;&amp; ((uintptr_t)total_rs.base() % alignment == 0),
 842            &quot;must be exactly of required size and alignment&quot;);
 843     // We are good.
 844 
<a name="38" id="anc38"></a><span class="line-removed"> 845     if (UseCompressedOops) {</span>
<span class="line-removed"> 846       // Universe::initialize_heap() will reset this to NULL if unscaled</span>
<span class="line-removed"> 847       // or zero-based narrow oops are actually used.</span>
<span class="line-removed"> 848       // Else heap start and base MUST differ, so that NULL can be encoded nonambigous.</span>
<span class="line-removed"> 849       Universe::set_narrow_oop_base((address)total_rs.compressed_oop_base());</span>
<span class="line-removed"> 850     }</span>
<span class="line-removed"> 851 </span>
 852     if (AllocateHeapAt != NULL) {
 853       log_info(gc,heap)(&quot;Successfully allocated Java heap at location %s&quot;, AllocateHeapAt);
 854     }
<a name="39" id="anc39"></a>






 855     return total_rs;
 856   }
 857 
 858   vm_exit_during_initialization(
 859     err_msg(&quot;Could not reserve enough space for &quot; SIZE_FORMAT &quot;KB object heap&quot;,
 860             total_reserved/K));
 861 
 862   // satisfy compiler
 863   ShouldNotReachHere();
 864   return ReservedHeapSpace(0, 0, false);
 865 }
 866 
 867 
 868 // It&#39;s the caller&#39;s responsibility to ensure glitch-freedom
 869 // (if required).
 870 void Universe::update_heap_info_at_gc() {
 871   _heap_capacity_at_last_gc = heap()-&gt;capacity();
 872   _heap_used_at_last_gc     = heap()-&gt;used();
 873 }
 874 
<a name="40" id="anc40"></a><span class="line-removed"> 875 </span>
<span class="line-removed"> 876 const char* Universe::narrow_oop_mode_to_string(Universe::NARROW_OOP_MODE mode) {</span>
<span class="line-removed"> 877   switch (mode) {</span>
<span class="line-removed"> 878     case UnscaledNarrowOop:</span>
<span class="line-removed"> 879       return &quot;32-bit&quot;;</span>
<span class="line-removed"> 880     case ZeroBasedNarrowOop:</span>
<span class="line-removed"> 881       return &quot;Zero based&quot;;</span>
<span class="line-removed"> 882     case DisjointBaseNarrowOop:</span>
<span class="line-removed"> 883       return &quot;Non-zero disjoint base&quot;;</span>
<span class="line-removed"> 884     case HeapBasedNarrowOop:</span>
<span class="line-removed"> 885       return &quot;Non-zero based&quot;;</span>
<span class="line-removed"> 886     default:</span>
<span class="line-removed"> 887       ShouldNotReachHere();</span>
<span class="line-removed"> 888       return &quot;&quot;;</span>
<span class="line-removed"> 889   }</span>
<span class="line-removed"> 890 }</span>
<span class="line-removed"> 891 </span>
<span class="line-removed"> 892 </span>
<span class="line-removed"> 893 Universe::NARROW_OOP_MODE Universe::narrow_oop_mode() {</span>
<span class="line-removed"> 894   if (narrow_oop_base_disjoint()) {</span>
<span class="line-removed"> 895     return DisjointBaseNarrowOop;</span>
<span class="line-removed"> 896   }</span>
<span class="line-removed"> 897 </span>
<span class="line-removed"> 898   if (narrow_oop_base() != 0) {</span>
<span class="line-removed"> 899     return HeapBasedNarrowOop;</span>
<span class="line-removed"> 900   }</span>
<span class="line-removed"> 901 </span>
<span class="line-removed"> 902   if (narrow_oop_shift() != 0) {</span>
<span class="line-removed"> 903     return ZeroBasedNarrowOop;</span>
<span class="line-removed"> 904   }</span>
<span class="line-removed"> 905 </span>
<span class="line-removed"> 906   return UnscaledNarrowOop;</span>
<span class="line-removed"> 907 }</span>
<span class="line-removed"> 908 </span>
 909 void initialize_known_method(LatestMethodCache* method_cache,
 910                              InstanceKlass* ik,
 911                              const char* method,
 912                              Symbol* signature,
 913                              bool is_static, TRAPS)
 914 {
<a name="41" id="anc41"></a><span class="line-modified"> 915   TempNewSymbol name = SymbolTable::new_symbol(method, CHECK);</span>
 916   Method* m = NULL;
 917   // The klass must be linked before looking up the method.
 918   if (!ik-&gt;link_class_or_fail(THREAD) ||
 919       ((m = ik-&gt;find_method(name, signature)) == NULL) ||
 920       is_static != m-&gt;is_static()) {
 921     ResourceMark rm(THREAD);
 922     // NoSuchMethodException doesn&#39;t actually work because it tries to run the
 923     // &lt;init&gt; function before java_lang_Class is linked. Print error and exit.
 924     vm_exit_during_initialization(err_msg(&quot;Unable to link/verify %s.%s method&quot;,
 925                                  ik-&gt;name()-&gt;as_C_string(), method));
 926   }
 927   method_cache-&gt;init(ik, m);
 928 }
 929 
 930 void Universe::initialize_known_methods(TRAPS) {
 931   // Set up static method for registering finalizers
 932   initialize_known_method(_finalizer_register_cache,
 933                           SystemDictionary::Finalizer_klass(),
 934                           &quot;register&quot;,
 935                           vmSymbols::object_void_signature(), true, CHECK);
 936 
 937   initialize_known_method(_throw_illegal_access_error_cache,
 938                           SystemDictionary::internal_Unsafe_klass(),
 939                           &quot;throwIllegalAccessError&quot;,
 940                           vmSymbols::void_method_signature(), true, CHECK);
 941 
 942   initialize_known_method(_throw_no_such_method_error_cache,
 943                           SystemDictionary::internal_Unsafe_klass(),
 944                           &quot;throwNoSuchMethodError&quot;,
 945                           vmSymbols::void_method_signature(), true, CHECK);
 946 
 947   // Set up method for registering loaded classes in class loader vector
 948   initialize_known_method(_loader_addClass_cache,
 949                           SystemDictionary::ClassLoader_klass(),
 950                           &quot;addClass&quot;,
 951                           vmSymbols::class_void_signature(), false, CHECK);
 952 
 953   // Set up method for stack walking
 954   initialize_known_method(_do_stack_walk_cache,
 955                           SystemDictionary::AbstractStackWalker_klass(),
 956                           &quot;doStackWalk&quot;,
 957                           vmSymbols::doStackWalk_signature(), false, CHECK);
 958 }
 959 
 960 void universe2_init() {
 961   EXCEPTION_MARK;
 962   Universe::genesis(CATCH);
 963 }
 964 
 965 // Set after initialization of the module runtime, call_initModuleRuntime
 966 void universe_post_module_init() {
 967   Universe::_module_initialized = true;
 968 }
 969 
 970 bool universe_post_init() {
 971   assert(!is_init_completed(), &quot;Error: initialization not yet completed!&quot;);
 972   Universe::_fully_initialized = true;
 973   EXCEPTION_MARK;
 974   { ResourceMark rm;
 975     Interpreter::initialize();      // needed for interpreter entry points
 976     if (!UseSharedSpaces) {
 977       Universe::reinitialize_vtables(CHECK_false);
 978       Universe::reinitialize_itables(CHECK_false);
 979     }
 980   }
 981 
 982   HandleMark hm(THREAD);
 983   // Setup preallocated empty java.lang.Class array
 984   Universe::_the_empty_class_klass_array = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_false);
 985 
 986   // Setup preallocated OutOfMemoryError errors
 987   Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_OutOfMemoryError(), true, CHECK_false);
 988   InstanceKlass* ik = InstanceKlass::cast(k);
 989   Universe::_out_of_memory_error_java_heap = ik-&gt;allocate_instance(CHECK_false);
 990   Universe::_out_of_memory_error_metaspace = ik-&gt;allocate_instance(CHECK_false);
 991   Universe::_out_of_memory_error_class_metaspace = ik-&gt;allocate_instance(CHECK_false);
 992   Universe::_out_of_memory_error_array_size = ik-&gt;allocate_instance(CHECK_false);
 993   Universe::_out_of_memory_error_gc_overhead_limit =
 994     ik-&gt;allocate_instance(CHECK_false);
 995   Universe::_out_of_memory_error_realloc_objects = ik-&gt;allocate_instance(CHECK_false);
 996   Universe::_out_of_memory_error_retry = ik-&gt;allocate_instance(CHECK_false);
 997 
 998   // Setup preallocated cause message for delayed StackOverflowError
 999   if (StackReservedPages &gt; 0) {
1000     Universe::_delayed_stack_overflow_error_message =
1001       java_lang_String::create_oop_from_str(&quot;Delayed StackOverflowError due to ReservedStackAccess annotated method&quot;, CHECK_false);
1002   }
1003 
1004   // Setup preallocated NullPointerException
1005   // (this is currently used for a cheap &amp; dirty solution in compiler exception handling)
1006   k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_NullPointerException(), true, CHECK_false);
1007   Universe::_null_ptr_exception_instance = InstanceKlass::cast(k)-&gt;allocate_instance(CHECK_false);
1008   // Setup preallocated ArithmeticException
1009   // (this is currently used for a cheap &amp; dirty solution in compiler exception handling)
1010   k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_ArithmeticException(), true, CHECK_false);
1011   Universe::_arithmetic_exception_instance = InstanceKlass::cast(k)-&gt;allocate_instance(CHECK_false);
1012   // Virtual Machine Error for when we get into a situation we can&#39;t resolve
1013   k = SystemDictionary::resolve_or_fail(
1014     vmSymbols::java_lang_VirtualMachineError(), true, CHECK_false);
1015   bool linked = InstanceKlass::cast(k)-&gt;link_class_or_fail(CHECK_false);
1016   if (!linked) {
1017      tty-&gt;print_cr(&quot;Unable to link/verify VirtualMachineError class&quot;);
1018      return false; // initialization failed
1019   }
1020   Universe::_virtual_machine_error_instance =
1021     InstanceKlass::cast(k)-&gt;allocate_instance(CHECK_false);
1022 
1023   Universe::_vm_exception = InstanceKlass::cast(k)-&gt;allocate_instance(CHECK_false);
1024 
1025   Handle msg = java_lang_String::create_from_str(&quot;Java heap space&quot;, CHECK_false);
1026   java_lang_Throwable::set_message(Universe::_out_of_memory_error_java_heap, msg());
1027 
1028   msg = java_lang_String::create_from_str(&quot;Metaspace&quot;, CHECK_false);
1029   java_lang_Throwable::set_message(Universe::_out_of_memory_error_metaspace, msg());
1030   msg = java_lang_String::create_from_str(&quot;Compressed class space&quot;, CHECK_false);
1031   java_lang_Throwable::set_message(Universe::_out_of_memory_error_class_metaspace, msg());
1032 
1033   msg = java_lang_String::create_from_str(&quot;Requested array size exceeds VM limit&quot;, CHECK_false);
1034   java_lang_Throwable::set_message(Universe::_out_of_memory_error_array_size, msg());
1035 
1036   msg = java_lang_String::create_from_str(&quot;GC overhead limit exceeded&quot;, CHECK_false);
1037   java_lang_Throwable::set_message(Universe::_out_of_memory_error_gc_overhead_limit, msg());
1038 
1039   msg = java_lang_String::create_from_str(&quot;Java heap space: failed reallocation of scalar replaced objects&quot;, CHECK_false);
1040   java_lang_Throwable::set_message(Universe::_out_of_memory_error_realloc_objects, msg());
1041 
1042   msg = java_lang_String::create_from_str(&quot;Java heap space: failed retryable allocation&quot;, CHECK_false);
1043   java_lang_Throwable::set_message(Universe::_out_of_memory_error_retry, msg());
1044 
1045   msg = java_lang_String::create_from_str(&quot;/ by zero&quot;, CHECK_false);
1046   java_lang_Throwable::set_message(Universe::_arithmetic_exception_instance, msg());
1047 
1048   // Setup the array of errors that have preallocated backtrace
1049   k = Universe::_out_of_memory_error_java_heap-&gt;klass();
1050   assert(k-&gt;name() == vmSymbols::java_lang_OutOfMemoryError(), &quot;should be out of memory error&quot;);
1051   ik = InstanceKlass::cast(k);
1052 
1053   int len = (StackTraceInThrowable) ? (int)PreallocatedOutOfMemoryErrorCount : 0;
1054   Universe::_preallocated_out_of_memory_error_array = oopFactory::new_objArray(ik, len, CHECK_false);
1055   for (int i=0; i&lt;len; i++) {
1056     oop err = ik-&gt;allocate_instance(CHECK_false);
1057     Handle err_h = Handle(THREAD, err);
1058     java_lang_Throwable::allocate_backtrace(err_h, CHECK_false);
1059     Universe::preallocated_out_of_memory_errors()-&gt;obj_at_put(i, err_h());
1060   }
1061   Universe::_preallocated_out_of_memory_error_avail_count = (jint)len;
1062 
1063   Universe::initialize_known_methods(CHECK_false);
1064 
1065   // This needs to be done before the first scavenge/gc, since
1066   // it&#39;s an input to soft ref clearing policy.
1067   {
<a name="42" id="anc42"></a><span class="line-modified">1068     MutexLocker x(Heap_lock);</span>
1069     Universe::update_heap_info_at_gc();
1070   }
1071 
1072   // (&quot;weak&quot;) refs processing infrastructure initialization
1073   Universe::heap()-&gt;post_initialize();
1074 
1075   MemoryService::add_metaspace_memory_pools();
1076 
1077   MemoryService::set_universe_heap(Universe::heap());
1078 #if INCLUDE_CDS
1079   MetaspaceShared::post_initialize(CHECK_false);
1080 #endif
1081   return true;
1082 }
1083 
1084 
1085 void Universe::compute_base_vtable_size() {
1086   _base_vtable_size = ClassLoader::compute_Object_vtable();
1087 }
1088 
1089 void Universe::print_on(outputStream* st) {
1090   GCMutexLocker hl(Heap_lock); // Heap_lock might be locked by caller thread.
1091   st-&gt;print_cr(&quot;Heap&quot;);
1092   heap()-&gt;print_on(st);
1093 }
1094 
1095 void Universe::print_heap_at_SIGBREAK() {
1096   if (PrintHeapAtSIGBREAK) {
1097     print_on(tty);
1098     tty-&gt;cr();
1099     tty-&gt;flush();
1100   }
1101 }
1102 
1103 void Universe::print_heap_before_gc() {
1104   LogTarget(Debug, gc, heap) lt;
1105   if (lt.is_enabled()) {
1106     LogStream ls(lt);
1107     ls.print(&quot;Heap before GC invocations=%u (full %u):&quot;, heap()-&gt;total_collections(), heap()-&gt;total_full_collections());
1108     ResourceMark rm;
1109     heap()-&gt;print_on(&amp;ls);
1110   }
1111 }
1112 
1113 void Universe::print_heap_after_gc() {
1114   LogTarget(Debug, gc, heap) lt;
1115   if (lt.is_enabled()) {
1116     LogStream ls(lt);
1117     ls.print(&quot;Heap after GC invocations=%u (full %u):&quot;, heap()-&gt;total_collections(), heap()-&gt;total_full_collections());
1118     ResourceMark rm;
1119     heap()-&gt;print_on(&amp;ls);
1120   }
1121 }
1122 
1123 void Universe::initialize_verify_flags() {
1124   verify_flags = 0;
1125   const char delimiter[] = &quot; ,&quot;;
1126 
1127   size_t length = strlen(VerifySubSet);
1128   char* subset_list = NEW_C_HEAP_ARRAY(char, length + 1, mtInternal);
1129   strncpy(subset_list, VerifySubSet, length + 1);
1130   char* save_ptr;
1131 
1132   char* token = strtok_r(subset_list, delimiter, &amp;save_ptr);
1133   while (token != NULL) {
1134     if (strcmp(token, &quot;threads&quot;) == 0) {
1135       verify_flags |= Verify_Threads;
1136     } else if (strcmp(token, &quot;heap&quot;) == 0) {
1137       verify_flags |= Verify_Heap;
1138     } else if (strcmp(token, &quot;symbol_table&quot;) == 0) {
1139       verify_flags |= Verify_SymbolTable;
1140     } else if (strcmp(token, &quot;string_table&quot;) == 0) {
1141       verify_flags |= Verify_StringTable;
1142     } else if (strcmp(token, &quot;codecache&quot;) == 0) {
1143       verify_flags |= Verify_CodeCache;
1144     } else if (strcmp(token, &quot;dictionary&quot;) == 0) {
1145       verify_flags |= Verify_SystemDictionary;
1146     } else if (strcmp(token, &quot;classloader_data_graph&quot;) == 0) {
1147       verify_flags |= Verify_ClassLoaderDataGraph;
1148     } else if (strcmp(token, &quot;metaspace&quot;) == 0) {
1149       verify_flags |= Verify_MetaspaceUtils;
1150     } else if (strcmp(token, &quot;jni_handles&quot;) == 0) {
1151       verify_flags |= Verify_JNIHandles;
1152     } else if (strcmp(token, &quot;codecache_oops&quot;) == 0) {
1153       verify_flags |= Verify_CodeCacheOops;
<a name="43" id="anc43"></a>

1154     } else {
1155       vm_exit_during_initialization(err_msg(&quot;VerifySubSet: \&#39;%s\&#39; memory sub-system is unknown, please correct it&quot;, token));
1156     }
1157     token = strtok_r(NULL, delimiter, &amp;save_ptr);
1158   }
1159   FREE_C_HEAP_ARRAY(char, subset_list);
1160 }
1161 
1162 bool Universe::should_verify_subset(uint subset) {
1163   if (verify_flags &amp; subset) {
1164     return true;
1165   }
1166   return false;
1167 }
1168 
1169 void Universe::verify(VerifyOption option, const char* prefix) {
1170   // The use of _verify_in_progress is a temporary work around for
1171   // 6320749.  Don&#39;t bother with a creating a class to set and clear
1172   // it since it is only used in this method and the control flow is
1173   // straight forward.
1174   _verify_in_progress = true;
1175 
1176   COMPILER2_PRESENT(
1177     assert(!DerivedPointerTable::is_active(),
1178          &quot;DPT should not be active during verification &quot;
1179          &quot;(of thread stacks below)&quot;);
1180   )
1181 
1182   ResourceMark rm;
1183   HandleMark hm;  // Handles created during verification can be zapped
1184   _verify_count++;
1185 
1186   FormatBuffer&lt;&gt; title(&quot;Verifying %s&quot;, prefix);
1187   GCTraceTime(Info, gc, verify) tm(title.buffer());
1188   if (should_verify_subset(Verify_Threads)) {
1189     log_debug(gc, verify)(&quot;Threads&quot;);
1190     Threads::verify();
1191   }
1192   if (should_verify_subset(Verify_Heap)) {
1193     log_debug(gc, verify)(&quot;Heap&quot;);
1194     heap()-&gt;verify(option);
1195   }
1196   if (should_verify_subset(Verify_SymbolTable)) {
1197     log_debug(gc, verify)(&quot;SymbolTable&quot;);
1198     SymbolTable::verify();
1199   }
1200   if (should_verify_subset(Verify_StringTable)) {
1201     log_debug(gc, verify)(&quot;StringTable&quot;);
1202     StringTable::verify();
1203   }
1204   if (should_verify_subset(Verify_CodeCache)) {
1205   {
<a name="44" id="anc44"></a><span class="line-modified">1206     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
1207     log_debug(gc, verify)(&quot;CodeCache&quot;);
1208     CodeCache::verify();
1209   }
1210   }
1211   if (should_verify_subset(Verify_SystemDictionary)) {
1212     log_debug(gc, verify)(&quot;SystemDictionary&quot;);
1213     SystemDictionary::verify();
1214   }
1215 #ifndef PRODUCT
1216   if (should_verify_subset(Verify_ClassLoaderDataGraph)) {
1217     log_debug(gc, verify)(&quot;ClassLoaderDataGraph&quot;);
1218     ClassLoaderDataGraph::verify();
1219   }
1220 #endif
1221   if (should_verify_subset(Verify_MetaspaceUtils)) {
1222     log_debug(gc, verify)(&quot;MetaspaceUtils&quot;);
1223     MetaspaceUtils::verify_free_chunks();
1224   }
1225   if (should_verify_subset(Verify_JNIHandles)) {
1226     log_debug(gc, verify)(&quot;JNIHandles&quot;);
1227     JNIHandles::verify();
1228   }
1229   if (should_verify_subset(Verify_CodeCacheOops)) {
1230     log_debug(gc, verify)(&quot;CodeCache Oops&quot;);
1231     CodeCache::verify_oops();
1232   }
<a name="45" id="anc45"></a>



1233 
1234   _verify_in_progress = false;
1235 }
1236 
1237 
1238 #ifndef PRODUCT
1239 void Universe::calculate_verify_data(HeapWord* low_boundary, HeapWord* high_boundary) {
1240   assert(low_boundary &lt; high_boundary, &quot;bad interval&quot;);
1241 
1242   // decide which low-order bits we require to be clear:
1243   size_t alignSize = MinObjAlignmentInBytes;
1244   size_t min_object_size = CollectedHeap::min_fill_size();
1245 
1246   // make an inclusive limit:
1247   uintptr_t max = (uintptr_t)high_boundary - min_object_size*wordSize;
1248   uintptr_t min = (uintptr_t)low_boundary;
1249   assert(min &lt; max, &quot;bad interval&quot;);
1250   uintptr_t diff = max ^ min;
1251 
1252   // throw away enough low-order bits to make the diff vanish
1253   uintptr_t mask = (uintptr_t)(-1);
1254   while ((mask &amp; diff) != 0)
1255     mask &lt;&lt;= 1;
1256   uintptr_t bits = (min &amp; mask);
1257   assert(bits == (max &amp; mask), &quot;correct mask&quot;);
1258   // check an intermediate value between min and max, just to make sure:
1259   assert(bits == ((min + (max-min)/2) &amp; mask), &quot;correct mask&quot;);
1260 
1261   // require address alignment, too:
1262   mask |= (alignSize - 1);
1263 
1264   if (!(_verify_oop_mask == 0 &amp;&amp; _verify_oop_bits == (uintptr_t)-1)) {
1265     assert(_verify_oop_mask == mask &amp;&amp; _verify_oop_bits == bits, &quot;mask stability&quot;);
1266   }
1267   _verify_oop_mask = mask;
1268   _verify_oop_bits = bits;
1269 }
1270 
1271 // Oop verification (see MacroAssembler::verify_oop)
1272 
1273 uintptr_t Universe::verify_oop_mask() {
<a name="46" id="anc46"></a><span class="line-removed">1274   MemRegion m = heap()-&gt;reserved_region();</span>
<span class="line-removed">1275   calculate_verify_data(m.start(), m.end());</span>
1276   return _verify_oop_mask;
1277 }
1278 
1279 uintptr_t Universe::verify_oop_bits() {
<a name="47" id="anc47"></a><span class="line-removed">1280   MemRegion m = heap()-&gt;reserved_region();</span>
<span class="line-removed">1281   calculate_verify_data(m.start(), m.end());</span>
1282   return _verify_oop_bits;
1283 }
1284 
1285 uintptr_t Universe::verify_mark_mask() {
<a name="48" id="anc48"></a><span class="line-modified">1286   return markOopDesc::lock_mask_in_place;</span>
1287 }
1288 
1289 uintptr_t Universe::verify_mark_bits() {
1290   intptr_t mask = verify_mark_mask();
<a name="49" id="anc49"></a><span class="line-modified">1291   intptr_t bits = (intptr_t)markOopDesc::prototype();</span>
1292   assert((bits &amp; ~mask) == 0, &quot;no stray header bits&quot;);
1293   return bits;
1294 }
1295 #endif // PRODUCT
1296 
1297 
1298 void LatestMethodCache::init(Klass* k, Method* m) {
1299   if (!UseSharedSpaces) {
1300     _klass = k;
1301   }
1302 #ifndef PRODUCT
1303   else {
1304     // sharing initilization should have already set up _klass
1305     assert(_klass != NULL, &quot;just checking&quot;);
1306   }
1307 #endif
1308 
1309   _method_idnum = m-&gt;method_idnum();
1310   assert(_method_idnum &gt;= 0, &quot;sanity check&quot;);
1311 }
1312 
1313 
1314 Method* LatestMethodCache::get_method() {
1315   if (klass() == NULL) return NULL;
1316   InstanceKlass* ik = InstanceKlass::cast(klass());
1317   Method* m = ik-&gt;method_with_idnum(method_idnum());
1318   assert(m != NULL, &quot;sanity check&quot;);
1319   return m;
1320 }
1321 
1322 
1323 #ifdef ASSERT
1324 // Release dummy object(s) at bottom of heap
1325 bool Universe::release_fullgc_alot_dummy() {
1326   MutexLocker ml(FullGCALot_lock);
1327   if (_fullgc_alot_dummy_array != NULL) {
1328     if (_fullgc_alot_dummy_next &gt;= _fullgc_alot_dummy_array-&gt;length()) {
1329       // No more dummies to release, release entire array instead
1330       _fullgc_alot_dummy_array = NULL;
1331       return false;
1332     }
<a name="50" id="anc50"></a><span class="line-modified">1333     if (!UseConcMarkSweepGC) {</span>
<span class="line-modified">1334       // Release dummy at bottom of old generation</span>
<span class="line-modified">1335       _fullgc_alot_dummy_array-&gt;obj_at_put(_fullgc_alot_dummy_next++, NULL);</span>
<span class="line-modified">1336     }</span>
1337     // Release dummy at bottom of permanent generation
1338     _fullgc_alot_dummy_array-&gt;obj_at_put(_fullgc_alot_dummy_next++, NULL);
1339   }
1340   return true;
1341 }
1342 
1343 #endif // ASSERT
<a name="51" id="anc51"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="51" type="hidden" />
</body>
</html>
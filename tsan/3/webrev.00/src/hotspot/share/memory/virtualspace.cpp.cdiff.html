<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/memory/virtualspace.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="universe.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="virtualspace.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/virtualspace.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,15 ***</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;memory/virtualspace.hpp&quot;
<span class="line-modified">! #include &quot;oops/markOop.hpp&quot;</span>
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/os.inline.hpp&quot;
  #include &quot;services/memTracker.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  
  // ReservedSpace
  
  // Dummy constructor
  ReservedSpace::ReservedSpace() : _base(NULL), _size(0), _noaccess_prefix(0),
<span class="line-new-header">--- 24,17 ---</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;memory/virtualspace.hpp&quot;
<span class="line-modified">! #include &quot;oops/compressedOops.hpp&quot;</span>
<span class="line-added">+ #include &quot;oops/markWord.hpp&quot;</span>
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/os.inline.hpp&quot;
  #include &quot;services/memTracker.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
<span class="line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  // ReservedSpace
  
  // Dummy constructor
  ReservedSpace::ReservedSpace() : _base(NULL), _size(0), _noaccess_prefix(0),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 307,13 ***</span>
        }
        log_debug(gc, heap, coops)(&quot;Protected page at the reserved heap base: &quot;
                                   PTR_FORMAT &quot; / &quot; INTX_FORMAT &quot; bytes&quot;,
                                   p2i(_base),
                                   _noaccess_prefix);
<span class="line-modified">!       assert(Universe::narrow_oop_use_implicit_null_checks() == true, &quot;not initialized?&quot;);</span>
      } else {
<span class="line-modified">!       Universe::set_narrow_oop_use_implicit_null_checks(false);</span>
      }
    }
  
    _base += _noaccess_prefix;
    _size -= _noaccess_prefix;
<span class="line-new-header">--- 309,13 ---</span>
        }
        log_debug(gc, heap, coops)(&quot;Protected page at the reserved heap base: &quot;
                                   PTR_FORMAT &quot; / &quot; INTX_FORMAT &quot; bytes&quot;,
                                   p2i(_base),
                                   _noaccess_prefix);
<span class="line-modified">!       assert(CompressedOops::use_implicit_null_checks() == true, &quot;not initialized?&quot;);</span>
      } else {
<span class="line-modified">!       CompressedOops::set_use_implicit_null_checks(false);</span>
      }
    }
  
    _base += _noaccess_prefix;
    _size -= _noaccess_prefix;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 576,11 ***</span>
      char** addresses = get_attach_addresses_for_disjoint_mode();
      int i = 0;
      while (addresses[i] &amp;&amp;                                 // End of array not yet reached.
             ((_base == NULL) ||                             // No previous try succeeded.
              (_base + size &gt;  (char *)OopEncodingHeapMax &amp;&amp; // Not zerobased or unscaled address.
<span class="line-modified">!              !Universe::is_disjoint_heap_base_address((address)_base)))) {  // Not disjoint address.</span>
        char* const attach_point = addresses[i];
        assert(attach_point &gt;= aligned_heap_base_min_address, &quot;Flag support broken&quot;);
        try_reserve_heap(size + noaccess_prefix, alignment, large, attach_point);
        i++;
      }
<span class="line-new-header">--- 578,11 ---</span>
      char** addresses = get_attach_addresses_for_disjoint_mode();
      int i = 0;
      while (addresses[i] &amp;&amp;                                 // End of array not yet reached.
             ((_base == NULL) ||                             // No previous try succeeded.
              (_base + size &gt;  (char *)OopEncodingHeapMax &amp;&amp; // Not zerobased or unscaled address.
<span class="line-modified">!              !CompressedOops::is_disjoint_heap_base_address((address)_base)))) {  // Not disjoint address.</span>
        char* const attach_point = addresses[i];
        assert(attach_point &gt;= aligned_heap_base_min_address, &quot;Flag support broken&quot;);
        try_reserve_heap(size + noaccess_prefix, alignment, large, attach_point);
        i++;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 620,13 ***</span>
      }
    } else {
      initialize(size, alignment, large, NULL, false);
    }
  
<span class="line-modified">!   assert(markOopDesc::encode_pointer_as_mark(_base)-&gt;decode_pointer() == _base,</span>
           &quot;area must be distinguishable from marks for mark-sweep&quot;);
<span class="line-modified">!   assert(markOopDesc::encode_pointer_as_mark(&amp;_base[size])-&gt;decode_pointer() == &amp;_base[size],</span>
           &quot;area must be distinguishable from marks for mark-sweep&quot;);
  
    if (base() != NULL) {
      MemTracker::record_virtual_memory_type((address)base(), mtJavaHeap);
    }
<span class="line-new-header">--- 622,13 ---</span>
      }
    } else {
      initialize(size, alignment, large, NULL, false);
    }
  
<span class="line-modified">!   assert(markWord::encode_pointer_as_mark(_base).decode_pointer() == _base,</span>
           &quot;area must be distinguishable from marks for mark-sweep&quot;);
<span class="line-modified">!   assert(markWord::encode_pointer_as_mark(&amp;_base[size]).decode_pointer() == &amp;_base[size],</span>
           &quot;area must be distinguishable from marks for mark-sweep&quot;);
  
    if (base() != NULL) {
      MemTracker::record_virtual_memory_type((address)base(), mtJavaHeap);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 634,10 ***</span>
<span class="line-new-header">--- 636,14 ---</span>
    if (_fd_for_heap != -1) {
      os::close(_fd_for_heap);
    }
  }
  
<span class="line-added">+ MemRegion ReservedHeapSpace::region() const {</span>
<span class="line-added">+   return MemRegion((HeapWord*)base(), (HeapWord*)end());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Reserve space for code segment.  Same as Java heap only we mark this as
  // executable.
  ReservedCodeSpace::ReservedCodeSpace(size_t r_size,
                                       size_t rs_align,
                                       bool large) :
</pre>
<center><a href="universe.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="virtualspace.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
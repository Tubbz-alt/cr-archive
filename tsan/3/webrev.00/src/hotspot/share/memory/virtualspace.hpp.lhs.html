<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/memory/virtualspace.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_MEMORY_VIRTUALSPACE_HPP
 26 #define SHARE_MEMORY_VIRTUALSPACE_HPP
 27 
<a name="1" id="anc1"></a>
 28 #include &quot;utilities/globalDefinitions.hpp&quot;
 29 
 30 class outputStream;
 31 
 32 // ReservedSpace is a data structure for reserving a contiguous address range.
 33 
 34 class ReservedSpace {
 35   friend class VMStructs;
 36  protected:
 37   char*  _base;
 38   size_t _size;
 39   size_t _noaccess_prefix;
 40   size_t _alignment;
 41   bool   _special;
 42   int    _fd_for_heap;
 43  private:
 44   bool   _executable;
 45 
 46   // ReservedSpace
 47   ReservedSpace(char* base, size_t size, size_t alignment, bool special,
 48                 bool executable);
 49  protected:
 50   void initialize(size_t size, size_t alignment, bool large,
 51                   char* requested_address,
 52                   bool executable);
 53 
 54  public:
 55   // Constructor
 56   ReservedSpace();
 57   // Initialize the reserved space with the given size. If preferred_page_size
 58   // is set, use this as minimum page size/alignment. This may waste some space
 59   // if the given size is not aligned to that value, as the reservation will be
 60   // aligned up to the final alignment in this case.
 61   ReservedSpace(size_t size, size_t preferred_page_size = 0);
 62   ReservedSpace(size_t size, size_t alignment, bool large,
 63                 char* requested_address = NULL);
 64   ReservedSpace(size_t size, size_t alignment, bool large, bool executable);
 65 
 66   // Accessors
 67   char*  base()            const { return _base;      }
 68   size_t size()            const { return _size;      }
 69   char*  end()             const { return _base + _size; }
 70   size_t alignment()       const { return _alignment; }
 71   bool   special()         const { return _special;   }
 72   bool   executable()      const { return _executable;   }
 73   size_t noaccess_prefix() const { return _noaccess_prefix;   }
 74   bool is_reserved()       const { return _base != NULL; }
 75   void release();
 76 
 77   // Splitting
 78   ReservedSpace first_part(size_t partition_size, size_t alignment,
 79                            bool split = false, bool realloc = true);
 80   ReservedSpace last_part (size_t partition_size, size_t alignment);
 81 
 82   // These simply call the above using the default alignment.
 83   inline ReservedSpace first_part(size_t partition_size,
 84                                   bool split = false, bool realloc = true);
 85   inline ReservedSpace last_part (size_t partition_size);
 86 
 87   // Alignment
 88   static size_t page_align_size_up(size_t size);
 89   static size_t page_align_size_down(size_t size);
 90   static size_t allocation_align_size_up(size_t size);
 91   bool contains(const void* p) const {
 92     return (base() &lt;= ((char*)p)) &amp;&amp; (((char*)p) &lt; (base() + size()));
 93   }
 94 };
 95 
 96 ReservedSpace
 97 ReservedSpace::first_part(size_t partition_size, bool split, bool realloc)
 98 {
 99   return first_part(partition_size, alignment(), split, realloc);
100 }
101 
102 ReservedSpace ReservedSpace::last_part(size_t partition_size)
103 {
104   return last_part(partition_size, alignment());
105 }
106 
107 // Class encapsulating behavior specific of memory space reserved for Java heap.
108 class ReservedHeapSpace : public ReservedSpace {
109  private:
110   void try_reserve_heap(size_t size, size_t alignment, bool large,
111                         char *requested_address);
112   void try_reserve_range(char *highest_start, char *lowest_start,
113                          size_t attach_point_alignment, char *aligned_HBMA,
114                          char *upper_bound, size_t size, size_t alignment, bool large);
115   void initialize_compressed_heap(const size_t size, size_t alignment, bool large);
116   // Create protection page at the beginning of the space.
117   void establish_noaccess_prefix();
118  public:
119   // Constructor. Tries to find a heap that is good for compressed oops.
120   // heap_allocation_directory is the path to the backing memory for Java heap. When set, Java heap will be allocated
121   // on the device which is managed by the file system where the directory resides.
122   ReservedHeapSpace(size_t size, size_t forced_base_alignment, bool large, const char* heap_allocation_directory = NULL);
123   // Returns the base to be used for compression, i.e. so that null can be
124   // encoded safely and implicit null checks can work.
<a name="2" id="anc2"></a><span class="line-modified">125   char *compressed_oop_base() { return _base - _noaccess_prefix; }</span>

126 };
127 
128 // Class encapsulating behavior specific memory space for Code
129 class ReservedCodeSpace : public ReservedSpace {
130  public:
131   // Constructor
132   ReservedCodeSpace(size_t r_size, size_t rs_align, bool large);
133 };
134 
135 // VirtualSpace is data structure for committing a previously reserved address range in smaller chunks.
136 
137 class VirtualSpace {
138   friend class VMStructs;
139  private:
140   // Reserved area
141   char* _low_boundary;
142   char* _high_boundary;
143 
144   // Committed area
145   char* _low;
146   char* _high;
147 
148   // The entire space has been committed and pinned in memory, no
149   // os::commit_memory() or os::uncommit_memory().
150   bool _special;
151 
152   // Need to know if commit should be executable.
153   bool   _executable;
154 
155   // MPSS Support
156   // Each virtualspace region has a lower, middle, and upper region.
157   // Each region has an end boundary and a high pointer which is the
158   // high water mark for the last allocated byte.
159   // The lower and upper unaligned to LargePageSizeInBytes uses default page.
160   // size.  The middle region uses large page size.
161   char* _lower_high;
162   char* _middle_high;
163   char* _upper_high;
164 
165   char* _lower_high_boundary;
166   char* _middle_high_boundary;
167   char* _upper_high_boundary;
168 
169   size_t _lower_alignment;
170   size_t _middle_alignment;
171   size_t _upper_alignment;
172 
173   // MPSS Accessors
174   char* lower_high() const { return _lower_high; }
175   char* middle_high() const { return _middle_high; }
176   char* upper_high() const { return _upper_high; }
177 
178   char* lower_high_boundary() const { return _lower_high_boundary; }
179   char* middle_high_boundary() const { return _middle_high_boundary; }
180   char* upper_high_boundary() const { return _upper_high_boundary; }
181 
182   size_t lower_alignment() const { return _lower_alignment; }
183   size_t middle_alignment() const { return _middle_alignment; }
184   size_t upper_alignment() const { return _upper_alignment; }
185 
186  public:
187   // Committed area
188   char* low()  const { return _low; }
189   char* high() const { return _high; }
190 
191   // Reserved area
192   char* low_boundary()  const { return _low_boundary; }
193   char* high_boundary() const { return _high_boundary; }
194 
195 #if INCLUDE_AOT
196   // Set boundaries for code section in AOT library.
197   void set_low_boundary(char *p)  { _low_boundary = p; }
198   void set_high_boundary(char *p) { _high_boundary = p; }
199   void set_low(char *p)           { _low = p; }
200   void set_high(char *p)          { _high = p; }
201 #endif
202 
203   bool special() const { return _special; }
204 
205  public:
206   // Initialization
207   VirtualSpace();
208   bool initialize_with_granularity(ReservedSpace rs, size_t committed_byte_size, size_t max_commit_ganularity);
209   bool initialize(ReservedSpace rs, size_t committed_byte_size);
210 
211   // Destruction
212   ~VirtualSpace();
213 
214   // Reserved memory
215   size_t reserved_size() const;
216   // Actually committed OS memory
217   size_t actual_committed_size() const;
218   // Memory used/expanded in this virtual space
219   size_t committed_size() const;
220   // Memory left to use/expand in this virtual space
221   size_t uncommitted_size() const;
222 
223   bool   contains(const void* p) const;
224 
225   // Operations
226   // returns true on success, false otherwise
227   bool expand_by(size_t bytes, bool pre_touch = false);
228   void shrink_by(size_t bytes);
229   void release();
230 
231   void check_for_contiguity() PRODUCT_RETURN;
232 
233   // Debugging
234   void print_on(outputStream* out) PRODUCT_RETURN;
235   void print();
236 };
237 
238 #endif // SHARE_MEMORY_VIRTUALSPACE_HPP
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/memory/metaspaceShared.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  28 #include &quot;classfile/classListParser.hpp&quot;
  29 #include &quot;classfile/classLoaderExt.hpp&quot;
  30 #include &quot;classfile/dictionary.hpp&quot;
  31 #include &quot;classfile/loaderConstraints.hpp&quot;
  32 #include &quot;classfile/javaClasses.inline.hpp&quot;
  33 #include &quot;classfile/placeholders.hpp&quot;
  34 #include &quot;classfile/symbolTable.hpp&quot;
  35 #include &quot;classfile/stringTable.hpp&quot;
  36 #include &quot;classfile/systemDictionary.hpp&quot;
  37 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  38 #include &quot;code/codeCache.hpp&quot;
<a name="2" id="anc2"></a>
  39 #include &quot;interpreter/bytecodeStream.hpp&quot;
  40 #include &quot;interpreter/bytecodes.hpp&quot;
  41 #include &quot;logging/log.hpp&quot;
  42 #include &quot;logging/logMessage.hpp&quot;
<a name="3" id="anc3"></a>

  43 #include &quot;memory/filemap.hpp&quot;
  44 #include &quot;memory/heapShared.inline.hpp&quot;
  45 #include &quot;memory/metaspace.hpp&quot;
  46 #include &quot;memory/metaspaceClosure.hpp&quot;
  47 #include &quot;memory/metaspaceShared.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
<a name="4" id="anc4"></a>
  49 #include &quot;oops/compressedOops.inline.hpp&quot;
  50 #include &quot;oops/instanceClassLoaderKlass.hpp&quot;
  51 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  52 #include &quot;oops/instanceRefKlass.hpp&quot;
<a name="5" id="anc5"></a>
  53 #include &quot;oops/objArrayKlass.hpp&quot;
  54 #include &quot;oops/objArrayOop.hpp&quot;
  55 #include &quot;oops/oop.inline.hpp&quot;
  56 #include &quot;oops/typeArrayKlass.hpp&quot;
  57 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  58 #include &quot;runtime/handles.inline.hpp&quot;
  59 #include &quot;runtime/os.hpp&quot;
  60 #include &quot;runtime/safepointVerifiers.hpp&quot;
  61 #include &quot;runtime/signature.hpp&quot;
  62 #include &quot;runtime/timerTrace.hpp&quot;
  63 #include &quot;runtime/vmThread.hpp&quot;
  64 #include &quot;runtime/vmOperations.hpp&quot;
  65 #include &quot;utilities/align.hpp&quot;
<a name="6" id="anc6"></a><span class="line-modified">  66 #include &quot;utilities/bitMap.hpp&quot;</span>
  67 #include &quot;utilities/defaultStream.hpp&quot;
  68 #include &quot;utilities/hashtable.inline.hpp&quot;
  69 #if INCLUDE_G1GC
  70 #include &quot;gc/g1/g1CollectedHeap.hpp&quot;
  71 #endif
  72 
  73 ReservedSpace MetaspaceShared::_shared_rs;
  74 VirtualSpace MetaspaceShared::_shared_vs;
  75 MetaspaceSharedStats MetaspaceShared::_stats;
  76 bool MetaspaceShared::_has_error_classes;
  77 bool MetaspaceShared::_archive_loading_failed = false;
  78 bool MetaspaceShared::_remapped_readwrite = false;
<a name="7" id="anc7"></a><span class="line-modified">  79 address MetaspaceShared::_cds_i2i_entry_code_buffers = NULL;</span>
<span class="line-modified">  80 size_t MetaspaceShared::_cds_i2i_entry_code_buffers_size = 0;</span>
<span class="line-modified">  81 size_t MetaspaceShared::_core_spaces_size = 0;</span>

  82 
  83 // The CDS archive is divided into the following regions:
<a name="8" id="anc8"></a><span class="line-modified">  84 //     mc  - misc code (the method entry trampolines)</span>
  85 //     rw  - read-write metadata
  86 //     ro  - read-only metadata and read-only tables
<a name="9" id="anc9"></a><span class="line-removed">  87 //     md  - misc data (the c++ vtables)</span>
<span class="line-removed">  88 //     od  - optional data (original class files)</span>
  89 //
  90 //     ca0 - closed archive heap space #0
  91 //     ca1 - closed archive heap space #1 (may be empty)
  92 //     oa0 - open archive heap space #0
  93 //     oa1 - open archive heap space #1 (may be empty)
  94 //
<a name="10" id="anc10"></a><span class="line-modified">  95 // The mc, rw, ro, md and od regions are linearly allocated, starting from</span>
<span class="line-modified">  96 // SharedBaseAddress, in the order of mc-&gt;rw-&gt;ro-&gt;md-&gt;od. The size of these 5 regions</span>
  97 // are page-aligned, and there&#39;s no gap between any consecutive regions.
  98 //
<a name="11" id="anc11"></a><span class="line-modified">  99 // These 5 regions are populated in the following steps:</span>
 100 // [1] All classes are loaded in MetaspaceShared::preload_classes(). All metadata are
 101 //     temporarily allocated outside of the shared regions. Only the method entry
 102 //     trampolines are written into the mc region.
<a name="12" id="anc12"></a><span class="line-modified"> 103 // [2] ArchiveCompactor copies RW metadata into the rw region.</span>
<span class="line-modified"> 104 // [3] ArchiveCompactor copies RO metadata into the ro region.</span>
<span class="line-modified"> 105 // [4] SymbolTable, StringTable, SystemDictionary, and a few other read-only data</span>

 106 //     are copied into the ro region as read-only tables.
<a name="13" id="anc13"></a><span class="line-removed"> 107 // [5] C++ vtables are copied into the md region.</span>
<span class="line-removed"> 108 // [6] Original class files are copied into the od region.</span>
 109 //
 110 // The s0/s1 and oa0/oa1 regions are populated inside HeapShared::archive_java_heap_objects.
<a name="14" id="anc14"></a><span class="line-modified"> 111 // Their layout is independent of the other 5 regions.</span>





















 112 
<a name="15" id="anc15"></a><span class="line-modified"> 113 class DumpRegion {</span>
<span class="line-modified"> 114 private:</span>
<span class="line-modified"> 115   const char* _name;</span>
<span class="line-modified"> 116   char* _base;</span>
<span class="line-removed"> 117   char* _top;</span>
<span class="line-removed"> 118   char* _end;</span>
<span class="line-removed"> 119   bool _is_packed;</span>
<span class="line-removed"> 120 </span>
<span class="line-removed"> 121   char* expand_top_to(char* newtop) {</span>
<span class="line-removed"> 122     assert(is_allocatable(), &quot;must be initialized and not packed&quot;);</span>
<span class="line-removed"> 123     assert(newtop &gt;= _top, &quot;must not grow backwards&quot;);</span>
<span class="line-removed"> 124     if (newtop &gt; _end) {</span>
<span class="line-removed"> 125       MetaspaceShared::report_out_of_space(_name, newtop - _top);</span>
<span class="line-removed"> 126       ShouldNotReachHere();</span>
<span class="line-removed"> 127     }</span>
<span class="line-removed"> 128     uintx delta = MetaspaceShared::object_delta_uintx(newtop);</span>
<span class="line-removed"> 129     if (delta &gt; MAX_SHARED_DELTA) {</span>
<span class="line-removed"> 130       // This is just a sanity check and should not appear in any real world usage. This</span>
<span class="line-removed"> 131       // happens only if you allocate more than 2GB of shared objects and would require</span>
<span class="line-removed"> 132       // millions of shared classes.</span>
<span class="line-removed"> 133       vm_exit_during_initialization(&quot;Out of memory in the CDS archive&quot;,</span>
<span class="line-removed"> 134                                     &quot;Please reduce the number of shared classes.&quot;);</span>
<span class="line-removed"> 135     }</span>
 136 
<a name="16" id="anc16"></a><span class="line-modified"> 137     MetaspaceShared::commit_shared_space_to(newtop);</span>
<span class="line-modified"> 138     _top = newtop;</span>
<span class="line-modified"> 139     return _top;</span>
<span class="line-modified"> 140   }</span>



 141 
<a name="17" id="anc17"></a><span class="line-modified"> 142 public:</span>
<span class="line-modified"> 143   DumpRegion(const char* name) : _name(name), _base(NULL), _top(NULL), _end(NULL), _is_packed(false) {}</span>
<span class="line-modified"> 144 </span>
<span class="line-modified"> 145   char* allocate(size_t num_bytes, size_t alignment=BytesPerWord) {</span>
<span class="line-modified"> 146     char* p = (char*)align_up(_top, alignment);</span>
<span class="line-modified"> 147     char* newtop = p + align_up(num_bytes, alignment);</span>
<span class="line-modified"> 148     expand_top_to(newtop);</span>
<span class="line-modified"> 149     memset(p, 0, newtop - p);</span>
<span class="line-removed"> 150     return p;</span>
<span class="line-removed"> 151   }</span>
<span class="line-removed"> 152 </span>
<span class="line-removed"> 153   void append_intptr_t(intptr_t n) {</span>
<span class="line-removed"> 154     assert(is_aligned(_top, sizeof(intptr_t)), &quot;bad alignment&quot;);</span>
<span class="line-removed"> 155     intptr_t *p = (intptr_t*)_top;</span>
<span class="line-removed"> 156     char* newtop = _top + sizeof(intptr_t);</span>
<span class="line-removed"> 157     expand_top_to(newtop);</span>
<span class="line-removed"> 158     *p = n;</span>
<span class="line-removed"> 159   }</span>
<span class="line-removed"> 160 </span>
<span class="line-removed"> 161   char* base()      const { return _base;        }</span>
<span class="line-removed"> 162   char* top()       const { return _top;         }</span>
<span class="line-removed"> 163   char* end()       const { return _end;         }</span>
<span class="line-removed"> 164   size_t reserved() const { return _end - _base; }</span>
<span class="line-removed"> 165   size_t used()     const { return _top - _base; }</span>
<span class="line-removed"> 166   bool is_packed()  const { return _is_packed;   }</span>
<span class="line-removed"> 167   bool is_allocatable() const {</span>
<span class="line-removed"> 168     return !is_packed() &amp;&amp; _base != NULL;</span>
<span class="line-removed"> 169   }</span>
<span class="line-removed"> 170 </span>
<span class="line-removed"> 171   void print(size_t total_bytes) const {</span>
<span class="line-removed"> 172     tty-&gt;print_cr(&quot;%-3s space: &quot; SIZE_FORMAT_W(9) &quot; [ %4.1f%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [%5.1f%% used] at &quot; INTPTR_FORMAT,</span>
<span class="line-removed"> 173                   _name, used(), percent_of(used(), total_bytes), reserved(), percent_of(used(), reserved()), p2i(_base));</span>
<span class="line-removed"> 174   }</span>
<span class="line-removed"> 175   void print_out_of_space_msg(const char* failing_region, size_t needed_bytes) {</span>
<span class="line-removed"> 176     tty-&gt;print(&quot;[%-8s] &quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot; capacity =%9d, allocated =%9d&quot;,</span>
<span class="line-removed"> 177                _name, p2i(_base), p2i(_top), int(_end - _base), int(_top - _base));</span>
<span class="line-removed"> 178     if (strcmp(_name, failing_region) == 0) {</span>
<span class="line-removed"> 179       tty-&gt;print_cr(&quot; required = %d&quot;, int(needed_bytes));</span>
<span class="line-removed"> 180     } else {</span>
<span class="line-removed"> 181       tty-&gt;cr();</span>
<span class="line-removed"> 182     }</span>
 183   }
<a name="18" id="anc18"></a>
 184 
<a name="19" id="anc19"></a><span class="line-modified"> 185   void init(const ReservedSpace* rs) {</span>
<span class="line-modified"> 186     _base = _top = rs-&gt;base();</span>
<span class="line-modified"> 187     _end = rs-&gt;end();</span>
<span class="line-modified"> 188   }</span>
<span class="line-modified"> 189   void init(char* b, char* t, char* e) {</span>
<span class="line-modified"> 190     _base = b;</span>
<span class="line-modified"> 191     _top = t;</span>
<span class="line-modified"> 192     _end = e;</span>



 193   }
<a name="20" id="anc20"></a>
 194 
<a name="21" id="anc21"></a><span class="line-modified"> 195   void pack(DumpRegion* next = NULL) {</span>
<span class="line-modified"> 196     assert(!is_packed(), &quot;sanity&quot;);</span>
<span class="line-modified"> 197     _end = (char*)align_up(_top, Metaspace::reserve_alignment());</span>
<span class="line-modified"> 198     _is_packed = true;</span>
<span class="line-modified"> 199     if (next != NULL) {</span>
<span class="line-modified"> 200       next-&gt;_base = next-&gt;_top = this-&gt;_end;</span>
<span class="line-modified"> 201       next-&gt;_end = MetaspaceShared::shared_rs()-&gt;end();</span>
<span class="line-removed"> 202     }</span>
 203   }
<a name="22" id="anc22"></a><span class="line-modified"> 204   bool contains(char* p) {</span>
<span class="line-modified"> 205     return base() &lt;= p &amp;&amp; p &lt; top();</span>








 206   }
<a name="23" id="anc23"></a><span class="line-modified"> 207 };</span>









 208 
<a name="24" id="anc24"></a>


 209 
<a name="25" id="anc25"></a><span class="line-modified"> 210 DumpRegion _mc_region(&quot;mc&quot;), _ro_region(&quot;ro&quot;), _rw_region(&quot;rw&quot;), _md_region(&quot;md&quot;);</span>
<span class="line-modified"> 211 size_t _total_closed_archive_region_size = 0, _total_open_archive_region_size = 0;</span>


 212 
 213 char* MetaspaceShared::misc_code_space_alloc(size_t num_bytes) {
 214   return _mc_region.allocate(num_bytes);
 215 }
 216 
 217 char* MetaspaceShared::read_only_space_alloc(size_t num_bytes) {
 218   return _ro_region.allocate(num_bytes);
 219 }
 220 
<a name="26" id="anc26"></a><span class="line-modified"> 221 void MetaspaceShared::initialize_runtime_shared_and_meta_spaces() {</span>
<span class="line-modified"> 222   assert(UseSharedSpaces, &quot;Must be called when UseSharedSpaces is enabled&quot;);</span>
<span class="line-modified"> 223 </span>
<span class="line-modified"> 224   // If using shared space, open the file that contains the shared space</span>
<span class="line-modified"> 225   // and map in the memory before initializing the rest of metaspace (so</span>
<span class="line-modified"> 226   // the addresses don&#39;t conflict)</span>
<span class="line-modified"> 227   address cds_address = NULL;</span>
<span class="line-modified"> 228   FileMapInfo* mapinfo = new FileMapInfo();</span>
<span class="line-modified"> 229 </span>
<span class="line-modified"> 230   // Open the shared archive file, read and validate the header. If</span>
<span class="line-modified"> 231   // initialization fails, shared spaces [UseSharedSpaces] are</span>
<span class="line-removed"> 232   // disabled and the file is closed.</span>
<span class="line-removed"> 233   // Map in spaces now also</span>
<span class="line-removed"> 234   if (mapinfo-&gt;initialize() &amp;&amp; map_shared_spaces(mapinfo)) {</span>
<span class="line-removed"> 235     size_t cds_total = core_spaces_size();</span>
<span class="line-removed"> 236     cds_address = (address)mapinfo-&gt;region_addr(0);</span>
<span class="line-removed"> 237 #ifdef _LP64</span>
<span class="line-removed"> 238     if (Metaspace::using_class_space()) {</span>
<span class="line-removed"> 239       char* cds_end = (char*)(cds_address + cds_total);</span>
<span class="line-removed"> 240       cds_end = (char *)align_up(cds_end, Metaspace::reserve_alignment());</span>
<span class="line-removed"> 241       // If UseCompressedClassPointers is set then allocate the metaspace area</span>
<span class="line-removed"> 242       // above the heap and above the CDS area (if it exists).</span>
<span class="line-removed"> 243       Metaspace::allocate_metaspace_compressed_klass_ptrs(cds_end, cds_address);</span>
<span class="line-removed"> 244       // map_heap_regions() compares the current narrow oop and klass encodings</span>
<span class="line-removed"> 245       // with the archived ones, so it must be done after all encodings are determined.</span>
<span class="line-removed"> 246       mapinfo-&gt;map_heap_regions();</span>
<span class="line-removed"> 247     }</span>
<span class="line-removed"> 248     Universe::set_narrow_klass_range(CompressedClassSpaceSize);</span>
<span class="line-removed"> 249 #endif // _LP64</span>
 250   } else {
<a name="27" id="anc27"></a><span class="line-modified"> 251     assert(!mapinfo-&gt;is_open() &amp;&amp; !UseSharedSpaces,</span>
<span class="line-modified"> 252            &quot;archive file not closed or shared spaces not disabled.&quot;);</span>
 253   }
 254 }
 255 
<a name="28" id="anc28"></a>




 256 void MetaspaceShared::initialize_dumptime_shared_and_meta_spaces() {
 257   assert(DumpSharedSpaces, &quot;should be called for dump time only&quot;);
<a name="29" id="anc29"></a><span class="line-modified"> 258   const size_t reserve_alignment = Metaspace::reserve_alignment();</span>
<span class="line-removed"> 259   bool large_pages = false; // No large pages when dumping the CDS archive.</span>
 260   char* shared_base = (char*)align_up((char*)SharedBaseAddress, reserve_alignment);
 261 
 262 #ifdef _LP64
 263   // On 64-bit VM, the heap and class space layout will be the same as if
 264   // you&#39;re running in -Xshare:on mode:
 265   //
 266   //                              +-- SharedBaseAddress (default = 0x800000000)
 267   //                              v
<a name="30" id="anc30"></a><span class="line-modified"> 268   // +-..---------+---------+ ... +----+----+----+----+----+---------------+</span>
<span class="line-modified"> 269   // |    Heap    | Archive |     | MC | RW | RO | MD | OD | class space   |</span>
<span class="line-modified"> 270   // +-..---------+---------+ ... +----+----+----+----+----+---------------+</span>
<span class="line-modified"> 271   // |&lt;--   MaxHeapSize  --&gt;|     |&lt;-- UnscaledClassSpaceMax = 4GB -------&gt;|</span>
 272   //
 273   const uint64_t UnscaledClassSpaceMax = (uint64_t(max_juint) + 1);
 274   const size_t cds_total = align_down(UnscaledClassSpaceMax, reserve_alignment);
 275 #else
 276   // We don&#39;t support archives larger than 256MB on 32-bit due to limited virtual address space.
 277   size_t cds_total = align_down(256*M, reserve_alignment);
 278 #endif
 279 
<a name="31" id="anc31"></a>





 280   // First try to reserve the space at the specified SharedBaseAddress.
<a name="32" id="anc32"></a><span class="line-modified"> 281   _shared_rs = ReservedSpace(cds_total, reserve_alignment, large_pages, shared_base);</span>



 282   if (_shared_rs.is_reserved()) {
 283     assert(shared_base == 0 || _shared_rs.base() == shared_base, &quot;should match&quot;);
 284   } else {
 285     // Get a mmap region anywhere if the SharedBaseAddress fails.
<a name="33" id="anc33"></a><span class="line-modified"> 286     _shared_rs = ReservedSpace(cds_total, reserve_alignment, large_pages);</span>
 287   }
 288   if (!_shared_rs.is_reserved()) {
 289     vm_exit_during_initialization(&quot;Unable to reserve memory for shared space&quot;,
 290                                   err_msg(SIZE_FORMAT &quot; bytes.&quot;, cds_total));
 291   }
 292 
 293 #ifdef _LP64
 294   // During dump time, we allocate 4GB (UnscaledClassSpaceMax) of space and split it up:
 295   // + The upper 1 GB is used as the &quot;temporary compressed class space&quot; -- preload_classes()
 296   //   will store Klasses into this space.
 297   // + The lower 3 GB is used for the archive -- when preload_classes() is done,
 298   //   ArchiveCompactor will copy the class metadata into this space, first the RW parts,
 299   //   then the RO parts.
 300 
<a name="34" id="anc34"></a><span class="line-removed"> 301   assert(UseCompressedOops &amp;&amp; UseCompressedClassPointers,</span>
<span class="line-removed"> 302       &quot;UseCompressedOops and UseCompressedClassPointers must be set&quot;);</span>
<span class="line-removed"> 303 </span>
 304   size_t max_archive_size = align_down(cds_total * 3 / 4, reserve_alignment);
 305   ReservedSpace tmp_class_space = _shared_rs.last_part(max_archive_size);
 306   CompressedClassSpaceSize = align_down(tmp_class_space.size(), reserve_alignment);
 307   _shared_rs = _shared_rs.first_part(max_archive_size);
 308 
<a name="35" id="anc35"></a><span class="line-modified"> 309   // Set up compress class pointers.</span>
<span class="line-modified"> 310   Universe::set_narrow_klass_base((address)_shared_rs.base());</span>
<span class="line-modified"> 311   // Set narrow_klass_shift to be LogKlassAlignmentInBytes. This is consistent</span>
<span class="line-modified"> 312   // with AOT.</span>
<span class="line-modified"> 313   Universe::set_narrow_klass_shift(LogKlassAlignmentInBytes);</span>
<span class="line-modified"> 314   // Set the range of klass addresses to 4GB.</span>
<span class="line-modified"> 315   Universe::set_narrow_klass_range(cds_total);</span>
<span class="line-modified"> 316 </span>
<span class="line-modified"> 317   Metaspace::initialize_class_space(tmp_class_space);</span>

 318   log_info(cds)(&quot;narrow_klass_base = &quot; PTR_FORMAT &quot;, narrow_klass_shift = %d&quot;,
<a name="36" id="anc36"></a><span class="line-modified"> 319                 p2i(Universe::narrow_klass_base()), Universe::narrow_klass_shift());</span>
 320 
 321   log_info(cds)(&quot;Allocated temporary class space: &quot; SIZE_FORMAT &quot; bytes at &quot; PTR_FORMAT,
 322                 CompressedClassSpaceSize, p2i(tmp_class_space.base()));
 323 #endif
 324 
<a name="37" id="anc37"></a><span class="line-modified"> 325   // Start with 0 committed bytes. The memory will be committed as needed by</span>
<span class="line-removed"> 326   // MetaspaceShared::commit_shared_space_to().</span>
<span class="line-removed"> 327   if (!_shared_vs.initialize(_shared_rs, 0)) {</span>
<span class="line-removed"> 328     vm_exit_during_initialization(&quot;Unable to allocate memory for shared space&quot;);</span>
<span class="line-removed"> 329   }</span>
<span class="line-removed"> 330 </span>
<span class="line-removed"> 331   _mc_region.init(&amp;_shared_rs);</span>
 332   SharedBaseAddress = (size_t)_shared_rs.base();
<a name="38" id="anc38"></a><span class="line-modified"> 333   tty-&gt;print_cr(&quot;Allocated shared space: &quot; SIZE_FORMAT &quot; bytes at &quot; PTR_FORMAT,</span>
 334                 _shared_rs.size(), p2i(_shared_rs.base()));
 335 }
 336 
 337 // Called by universe_post_init()
 338 void MetaspaceShared::post_initialize(TRAPS) {
 339   if (UseSharedSpaces) {
 340     int size = FileMapInfo::get_number_of_shared_paths();
 341     if (size &gt; 0) {
 342       SystemDictionaryShared::allocate_shared_data_arrays(size, THREAD);
<a name="39" id="anc39"></a><span class="line-modified"> 343       FileMapHeader* header = FileMapInfo::current_info()-&gt;header();</span>
<span class="line-modified"> 344       ClassLoaderExt::init_paths_start_index(header-&gt;_app_class_paths_start_index);</span>
<span class="line-modified"> 345       ClassLoaderExt::init_app_module_paths_start_index(header-&gt;_app_module_paths_start_index);</span>







 346     }
 347   }
 348 }
 349 
 350 static GrowableArray&lt;Handle&gt;* _extra_interned_strings = NULL;
 351 
 352 void MetaspaceShared::read_extra_data(const char* filename, TRAPS) {
 353   _extra_interned_strings = new (ResourceObj::C_HEAP, mtInternal)GrowableArray&lt;Handle&gt;(10000, true);
 354 
 355   HashtableTextDump reader(filename);
 356   reader.check_version(&quot;VERSION: 1.0&quot;);
 357 
 358   while (reader.remain() &gt; 0) {
 359     int utf8_length;
 360     int prefix_type = reader.scan_prefix(&amp;utf8_length);
 361     ResourceMark rm(THREAD);
 362     if (utf8_length == 0x7fffffff) {
 363       // buf_len will overflown 32-bit value.
 364       vm_exit_during_initialization(err_msg(&quot;string length too large: %d&quot;, utf8_length));
 365     }
 366     int buf_len = utf8_length+1;
 367     char* utf8_buffer = NEW_RESOURCE_ARRAY(char, buf_len);
 368     reader.get_utf8(utf8_buffer, utf8_length);
 369     utf8_buffer[utf8_length] = &#39;\0&#39;;
 370 
 371     if (prefix_type == HashtableTextDump::SymbolPrefix) {
<a name="40" id="anc40"></a><span class="line-modified"> 372       SymbolTable::new_permanent_symbol(utf8_buffer, THREAD);</span>
 373     } else{
 374       assert(prefix_type == HashtableTextDump::StringPrefix, &quot;Sanity&quot;);
 375       oop s = StringTable::intern(utf8_buffer, THREAD);
 376 
 377       if (HAS_PENDING_EXCEPTION) {
 378         log_warning(cds, heap)(&quot;[line %d] extra interned string allocation failed; size too large: %d&quot;,
 379                                reader.last_line_no(), utf8_length);
 380         CLEAR_PENDING_EXCEPTION;
 381       } else {
 382 #if INCLUDE_G1GC
 383         if (UseG1GC) {
 384           typeArrayOop body = java_lang_String::value(s);
 385           const HeapRegion* hr = G1CollectedHeap::heap()-&gt;heap_region_containing(body);
 386           if (hr-&gt;is_humongous()) {
 387             // Don&#39;t keep it alive, so it will be GC&#39;ed before we dump the strings, in order
 388             // to maximize free heap space and minimize fragmentation.
 389             log_warning(cds, heap)(&quot;[line %d] extra interned string ignored; size too large: %d&quot;,
 390                                 reader.last_line_no(), utf8_length);
 391             continue;
 392           }
 393         }
 394 #endif
 395         // Interned strings are GC&#39;ed if there are no references to it, so let&#39;s
 396         // add a reference to keep this string alive.
 397         assert(s != NULL, &quot;must succeed&quot;);
 398         Handle h(THREAD, s);
 399         _extra_interned_strings-&gt;append(h);
 400       }
 401     }
 402   }
 403 }
 404 
 405 void MetaspaceShared::commit_shared_space_to(char* newtop) {
<a name="41" id="anc41"></a><span class="line-modified"> 406   assert(DumpSharedSpaces, &quot;dump-time only&quot;);</span>
 407   char* base = _shared_rs.base();
 408   size_t need_committed_size = newtop - base;
 409   size_t has_committed_size = _shared_vs.committed_size();
 410   if (need_committed_size &lt; has_committed_size) {
 411     return;
 412   }
 413 
 414   size_t min_bytes = need_committed_size - has_committed_size;
 415   size_t preferred_bytes = 1 * M;
 416   size_t uncommitted = _shared_vs.reserved_size() - has_committed_size;
 417 
<a name="42" id="anc42"></a><span class="line-modified"> 418   size_t commit = MAX2(min_bytes, preferred_bytes);</span>

 419   assert(commit &lt;= uncommitted, &quot;sanity&quot;);
 420 
 421   bool result = _shared_vs.expand_by(commit, false);
<a name="43" id="anc43"></a>

 422   if (!result) {
 423     vm_exit_during_initialization(err_msg(&quot;Failed to expand shared space to &quot; SIZE_FORMAT &quot; bytes&quot;,
 424                                           need_committed_size));
 425   }
 426 
<a name="44" id="anc44"></a><span class="line-modified"> 427   log_info(cds)(&quot;Expanding shared spaces by &quot; SIZE_FORMAT_W(7) &quot; bytes [total &quot; SIZE_FORMAT_W(9)  &quot; bytes ending at %p]&quot;,</span>
<span class="line-modified"> 428                 commit, _shared_vs.actual_committed_size(), _shared_vs.high());</span>




 429 }
 430 
 431 // Read/write a data stream for restoring/preserving metadata pointers and
 432 // miscellaneous data from/to the shared archive file.
 433 
 434 void MetaspaceShared::serialize(SerializeClosure* soc) {
 435   int tag = 0;
 436   soc-&gt;do_tag(--tag);
 437 
 438   // Verify the sizes of various metadata in the system.
 439   soc-&gt;do_tag(sizeof(Method));
 440   soc-&gt;do_tag(sizeof(ConstMethod));
 441   soc-&gt;do_tag(arrayOopDesc::base_offset_in_bytes(T_BYTE));
 442   soc-&gt;do_tag(sizeof(ConstantPool));
 443   soc-&gt;do_tag(sizeof(ConstantPoolCache));
 444   soc-&gt;do_tag(objArrayOopDesc::base_offset_in_bytes());
 445   soc-&gt;do_tag(typeArrayOopDesc::base_offset_in_bytes(T_BYTE));
 446   soc-&gt;do_tag(sizeof(Symbol));
 447 
 448   // Dump/restore miscellaneous metadata.
<a name="45" id="anc45"></a>
 449   Universe::serialize(soc);
 450   soc-&gt;do_tag(--tag);
 451 
 452   // Dump/restore references to commonly used names and signatures.
 453   vmSymbols::serialize(soc);
 454   soc-&gt;do_tag(--tag);
 455 
 456   // Dump/restore the symbol/string/subgraph_info tables
 457   SymbolTable::serialize_shared_table_header(soc);
 458   StringTable::serialize_shared_table_header(soc);
 459   HeapShared::serialize_subgraph_info_table_header(soc);
 460   SystemDictionaryShared::serialize_dictionary_headers(soc);
 461 
<a name="46" id="anc46"></a><span class="line-removed"> 462   JavaClasses::serialize_offsets(soc);</span>
 463   InstanceMirrorKlass::serialize_offsets(soc);
 464   soc-&gt;do_tag(--tag);
 465 
<a name="47" id="anc47"></a>


 466   soc-&gt;do_tag(666);
 467 }
 468 
<a name="48" id="anc48"></a><span class="line-modified"> 469 address MetaspaceShared::cds_i2i_entry_code_buffers(size_t total_size) {</span>
 470   if (DumpSharedSpaces) {
<a name="49" id="anc49"></a><span class="line-modified"> 471     if (_cds_i2i_entry_code_buffers == NULL) {</span>
<span class="line-modified"> 472       _cds_i2i_entry_code_buffers = (address)misc_code_space_alloc(total_size);</span>
<span class="line-modified"> 473       _cds_i2i_entry_code_buffers_size = total_size;</span>
 474     }
 475   } else if (UseSharedSpaces) {
<a name="50" id="anc50"></a><span class="line-modified"> 476     assert(_cds_i2i_entry_code_buffers != NULL, &quot;must already been initialized&quot;);</span>
 477   } else {
 478     return NULL;
 479   }
 480 
<a name="51" id="anc51"></a><span class="line-modified"> 481   assert(_cds_i2i_entry_code_buffers_size == total_size, &quot;must not change&quot;);</span>
<span class="line-modified"> 482   return _cds_i2i_entry_code_buffers;</span>












 483 }
 484 
 485 // Global object for holding classes that have been loaded.  Since this
 486 // is run at a safepoint just before exit, this is the entire set of classes.
 487 static GrowableArray&lt;Klass*&gt;* _global_klass_objects;
 488 
 489 GrowableArray&lt;Klass*&gt;* MetaspaceShared::collected_klasses() {
 490   return _global_klass_objects;
 491 }
 492 
 493 static void collect_array_classes(Klass* k) {
 494   _global_klass_objects-&gt;append_if_missing(k);
 495   if (k-&gt;is_array_klass()) {
 496     // Add in the array classes too
 497     ArrayKlass* ak = ArrayKlass::cast(k);
 498     Klass* h = ak-&gt;higher_dimension();
 499     if (h != NULL) {
 500       h-&gt;array_klasses_do(collect_array_classes);
 501     }
 502   }
 503 }
 504 
 505 class CollectClassesClosure : public KlassClosure {
 506   void do_klass(Klass* k) {
 507     if (k-&gt;is_instance_klass() &amp;&amp;
 508         SystemDictionaryShared::is_excluded_class(InstanceKlass::cast(k))) {
 509       // Don&#39;t add to the _global_klass_objects
 510     } else {
 511       _global_klass_objects-&gt;append_if_missing(k);
 512     }
 513     if (k-&gt;is_array_klass()) {
 514       // Add in the array classes too
 515       ArrayKlass* ak = ArrayKlass::cast(k);
 516       Klass* h = ak-&gt;higher_dimension();
 517       if (h != NULL) {
 518         h-&gt;array_klasses_do(collect_array_classes);
 519       }
 520     }
 521   }
 522 };
 523 
 524 static void remove_unshareable_in_classes() {
 525   for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
 526     Klass* k = _global_klass_objects-&gt;at(i);
 527     if (!k-&gt;is_objArray_klass()) {
 528       // InstanceKlass and TypeArrayKlass will in turn call remove_unshareable_info
 529       // on their array classes.
 530       assert(k-&gt;is_instance_klass() || k-&gt;is_typeArray_klass(), &quot;must be&quot;);
 531       k-&gt;remove_unshareable_info();
 532     }
 533   }
 534 }
 535 
 536 static void remove_java_mirror_in_classes() {
 537   for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
 538     Klass* k = _global_klass_objects-&gt;at(i);
 539     if (!k-&gt;is_objArray_klass()) {
 540       // InstanceKlass and TypeArrayKlass will in turn call remove_unshareable_info
 541       // on their array classes.
 542       assert(k-&gt;is_instance_klass() || k-&gt;is_typeArray_klass(), &quot;must be&quot;);
 543       k-&gt;remove_java_mirror();
 544     }
 545   }
 546 }
 547 
 548 static void clear_basic_type_mirrors() {
 549   assert(!HeapShared::is_heap_object_archiving_allowed(), &quot;Sanity&quot;);
 550   Universe::set_int_mirror(NULL);
 551   Universe::set_float_mirror(NULL);
 552   Universe::set_double_mirror(NULL);
 553   Universe::set_byte_mirror(NULL);
 554   Universe::set_bool_mirror(NULL);
 555   Universe::set_char_mirror(NULL);
 556   Universe::set_long_mirror(NULL);
 557   Universe::set_short_mirror(NULL);
 558   Universe::set_void_mirror(NULL);
 559 }
 560 
<a name="52" id="anc52"></a><span class="line-modified"> 561 static void rewrite_nofast_bytecode(Method* method) {</span>
 562   BytecodeStream bcs(method);
 563   while (!bcs.is_last_bytecode()) {
 564     Bytecodes::Code opcode = bcs.next();
 565     switch (opcode) {
 566     case Bytecodes::_getfield:      *bcs.bcp() = Bytecodes::_nofast_getfield;      break;
 567     case Bytecodes::_putfield:      *bcs.bcp() = Bytecodes::_nofast_putfield;      break;
 568     case Bytecodes::_aload_0:       *bcs.bcp() = Bytecodes::_nofast_aload_0;       break;
 569     case Bytecodes::_iload: {
 570       if (!bcs.is_wide()) {
 571         *bcs.bcp() = Bytecodes::_nofast_iload;
 572       }
 573       break;
 574     }
 575     default: break;
 576     }
 577   }
 578 }
 579 
 580 // Walk all methods in the class list to ensure that they won&#39;t be modified at
 581 // run time. This includes:
 582 // [1] Rewrite all bytecodes as needed, so that the ConstMethod* will not be modified
 583 //     at run time by RewriteBytecodes/RewriteFrequentPairs
 584 // [2] Assign a fingerprint, so one doesn&#39;t need to be assigned at run-time.
<a name="53" id="anc53"></a><span class="line-modified"> 585 static void rewrite_nofast_bytecodes_and_calculate_fingerprints() {</span>
 586   for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
 587     Klass* k = _global_klass_objects-&gt;at(i);
 588     if (k-&gt;is_instance_klass()) {
 589       InstanceKlass* ik = InstanceKlass::cast(k);
<a name="54" id="anc54"></a><span class="line-modified"> 590       for (int i = 0; i &lt; ik-&gt;methods()-&gt;length(); i++) {</span>
<span class="line-removed"> 591         Method* m = ik-&gt;methods()-&gt;at(i);</span>
<span class="line-removed"> 592         rewrite_nofast_bytecode(m);</span>
<span class="line-removed"> 593         Fingerprinter fp(m);</span>
<span class="line-removed"> 594         // The side effect of this call sets method&#39;s fingerprint field.</span>
<span class="line-removed"> 595         fp.fingerprint();</span>
<span class="line-removed"> 596       }</span>
 597     }
 598   }
 599 }
 600 
<a name="55" id="anc55"></a>









 601 // Objects of the Metadata types (such as Klass and ConstantPool) have C++ vtables.
 602 // (In GCC this is the field &lt;Type&gt;::_vptr, i.e., first word in the object.)
 603 //
 604 // Addresses of the vtables and the methods may be different across JVM runs,
 605 // if libjvm.so is dynamically loaded at a different base address.
 606 //
 607 // To ensure that the Metadata objects in the CDS archive always have the correct vtable:
 608 //
 609 // + at dump time:  we redirect the _vptr to point to our own vtables inside
 610 //                  the CDS image
 611 // + at run time:   we clone the actual contents of the vtables from libjvm.so
 612 //                  into our own tables.
 613 
 614 // Currently, the archive contain ONLY the following types of objects that have C++ vtables.
 615 #define CPP_VTABLE_PATCH_TYPES_DO(f) \
 616   f(ConstantPool) \
 617   f(InstanceKlass) \
 618   f(InstanceClassLoaderKlass) \
 619   f(InstanceMirrorKlass) \
 620   f(InstanceRefKlass) \
 621   f(Method) \
 622   f(ObjArrayKlass) \
 623   f(TypeArrayKlass)
 624 
 625 class CppVtableInfo {
 626   intptr_t _vtable_size;
 627   intptr_t _cloned_vtable[1];
 628 public:
 629   static int num_slots(int vtable_size) {
 630     return 1 + vtable_size; // Need to add the space occupied by _vtable_size;
 631   }
 632   int vtable_size()           { return int(uintx(_vtable_size)); }
 633   void set_vtable_size(int n) { _vtable_size = intptr_t(n); }
 634   intptr_t* cloned_vtable()   { return &amp;_cloned_vtable[0]; }
 635   void zero()                 { memset(_cloned_vtable, 0, sizeof(intptr_t) * vtable_size()); }
 636   // Returns the address of the next CppVtableInfo that can be placed immediately after this CppVtableInfo
 637   static size_t byte_size(int vtable_size) {
 638     CppVtableInfo i;
 639     return pointer_delta(&amp;i._cloned_vtable[vtable_size], &amp;i, sizeof(u1));
 640   }
 641 };
 642 
 643 template &lt;class T&gt; class CppVtableCloner : public T {
 644   static intptr_t* vtable_of(Metadata&amp; m) {
 645     return *((intptr_t**)&amp;m);
 646   }
 647   static CppVtableInfo* _info;
 648 
 649   static int get_vtable_length(const char* name);
 650 
 651 public:
 652   // Allocate and initialize the C++ vtable, starting from top, but do not go past end.
 653   static intptr_t* allocate(const char* name);
 654 
 655   // Clone the vtable to ...
 656   static intptr_t* clone_vtable(const char* name, CppVtableInfo* info);
 657 
 658   static void zero_vtable_clone() {
 659     assert(DumpSharedSpaces, &quot;dump-time only&quot;);
 660     _info-&gt;zero();
 661   }
 662 
<a name="56" id="anc56"></a><span class="line-removed"> 663   // Switch the vtable pointer to point to the cloned vtable.</span>
<span class="line-removed"> 664   static void patch(Metadata* obj) {</span>
<span class="line-removed"> 665     assert(DumpSharedSpaces, &quot;dump-time only&quot;);</span>
<span class="line-removed"> 666     *(void**)obj = (void*)(_info-&gt;cloned_vtable());</span>
<span class="line-removed"> 667   }</span>
<span class="line-removed"> 668 </span>
 669   static bool is_valid_shared_object(const T* obj) {
 670     intptr_t* vptr = *(intptr_t**)obj;
 671     return vptr == _info-&gt;cloned_vtable();
 672   }
 673 };
 674 
 675 template &lt;class T&gt; CppVtableInfo* CppVtableCloner&lt;T&gt;::_info = NULL;
 676 
 677 template &lt;class T&gt;
 678 intptr_t* CppVtableCloner&lt;T&gt;::allocate(const char* name) {
<a name="57" id="anc57"></a><span class="line-modified"> 679   assert(is_aligned(_md_region.top(), sizeof(intptr_t)), &quot;bad alignment&quot;);</span>
 680   int n = get_vtable_length(name);
<a name="58" id="anc58"></a><span class="line-modified"> 681   _info = (CppVtableInfo*)_md_region.allocate(CppVtableInfo::byte_size(n), sizeof(intptr_t));</span>
 682   _info-&gt;set_vtable_size(n);
 683 
 684   intptr_t* p = clone_vtable(name, _info);
<a name="59" id="anc59"></a><span class="line-modified"> 685   assert((char*)p == _md_region.top(), &quot;must be&quot;);</span>
 686 
<a name="60" id="anc60"></a><span class="line-modified"> 687   return p;</span>
 688 }
 689 
 690 template &lt;class T&gt;
 691 intptr_t* CppVtableCloner&lt;T&gt;::clone_vtable(const char* name, CppVtableInfo* info) {
 692   if (!DumpSharedSpaces) {
 693     assert(_info == 0, &quot;_info is initialized only at dump time&quot;);
 694     _info = info; // Remember it -- it will be used by MetaspaceShared::is_valid_shared_method()
 695   }
 696   T tmp; // Allocate temporary dummy metadata object to get to the original vtable.
 697   int n = info-&gt;vtable_size();
 698   intptr_t* srcvtable = vtable_of(tmp);
 699   intptr_t* dstvtable = info-&gt;cloned_vtable();
 700 
 701   // We already checked (and, if necessary, adjusted n) when the vtables were allocated, so we are
 702   // safe to do memcpy.
 703   log_debug(cds, vtables)(&quot;Copying %3d vtable entries for %s&quot;, n, name);
 704   memcpy(dstvtable, srcvtable, sizeof(intptr_t) * n);
 705   return dstvtable + n;
 706 }
 707 
 708 // To determine the size of the vtable for each type, we use the following
 709 // trick by declaring 2 subclasses:
 710 //
 711 //   class CppVtableTesterA: public InstanceKlass {virtual int   last_virtual_method() {return 1;}    };
 712 //   class CppVtableTesterB: public InstanceKlass {virtual void* last_virtual_method() {return NULL}; };
 713 //
 714 // CppVtableTesterA and CppVtableTesterB&#39;s vtables have the following properties:
 715 // - Their size (N+1) is exactly one more than the size of InstanceKlass&#39;s vtable (N)
 716 // - The first N entries have are exactly the same as in InstanceKlass&#39;s vtable.
 717 // - Their last entry is different.
 718 //
 719 // So to determine the value of N, we just walk CppVtableTesterA and CppVtableTesterB&#39;s tables
 720 // and find the first entry that&#39;s different.
 721 //
 722 // This works on all C++ compilers supported by Oracle, but you may need to tweak it for more
 723 // esoteric compilers.
 724 
 725 template &lt;class T&gt; class CppVtableTesterB: public T {
 726 public:
 727   virtual int last_virtual_method() {return 1;}
 728 };
 729 
 730 template &lt;class T&gt; class CppVtableTesterA : public T {
 731 public:
 732   virtual void* last_virtual_method() {
 733     // Make this different than CppVtableTesterB::last_virtual_method so the C++
 734     // compiler/linker won&#39;t alias the two functions.
 735     return NULL;
 736   }
 737 };
 738 
 739 template &lt;class T&gt;
 740 int CppVtableCloner&lt;T&gt;::get_vtable_length(const char* name) {
 741   CppVtableTesterA&lt;T&gt; a;
 742   CppVtableTesterB&lt;T&gt; b;
 743 
 744   intptr_t* avtable = vtable_of(a);
 745   intptr_t* bvtable = vtable_of(b);
 746 
 747   // Start at slot 1, because slot 0 may be RTTI (on Solaris/Sparc)
 748   int vtable_len = 1;
 749   for (; ; vtable_len++) {
 750     if (avtable[vtable_len] != bvtable[vtable_len]) {
 751       break;
 752     }
 753   }
 754   log_debug(cds, vtables)(&quot;Found   %3d vtable entries for %s&quot;, vtable_len, name);
 755 
 756   return vtable_len;
 757 }
 758 
 759 #define ALLOC_CPP_VTABLE_CLONE(c) \
<a name="61" id="anc61"></a><span class="line-modified"> 760   CppVtableCloner&lt;c&gt;::allocate(#c);</span>

 761 
 762 #define CLONE_CPP_VTABLE(c) \
 763   p = CppVtableCloner&lt;c&gt;::clone_vtable(#c, (CppVtableInfo*)p);
 764 
 765 #define ZERO_CPP_VTABLE(c) \
 766  CppVtableCloner&lt;c&gt;::zero_vtable_clone();
 767 
<a name="62" id="anc62"></a><span class="line-modified"> 768 // This can be called at both dump time and run time.</span>
<span class="line-modified"> 769 intptr_t* MetaspaceShared::clone_cpp_vtables(intptr_t* p) {</span>









































































































 770   assert(DumpSharedSpaces || UseSharedSpaces, &quot;sanity&quot;);
 771   CPP_VTABLE_PATCH_TYPES_DO(CLONE_CPP_VTABLE);
<a name="63" id="anc63"></a><span class="line-removed"> 772   return p;</span>
 773 }
 774 
 775 void MetaspaceShared::zero_cpp_vtable_clones_for_writing() {
 776   assert(DumpSharedSpaces, &quot;dump-time only&quot;);
 777   CPP_VTABLE_PATCH_TYPES_DO(ZERO_CPP_VTABLE);
 778 }
 779 
 780 // Allocate and initialize the C++ vtables, starting from top, but do not go past end.
<a name="64" id="anc64"></a><span class="line-modified"> 781 void MetaspaceShared::allocate_cpp_vtable_clones() {</span>


 782   assert(DumpSharedSpaces, &quot;dump-time only&quot;);
 783   // Layout (each slot is a intptr_t):
 784   //   [number of slots in the first vtable = n1]
 785   //   [ &lt;n1&gt; slots for the first vtable]
 786   //   [number of slots in the first second = n2]
 787   //   [ &lt;n2&gt; slots for the second vtable]
 788   //   ...
 789   // The order of the vtables is the same as the CPP_VTAB_PATCH_TYPES_DO macro.
 790   CPP_VTABLE_PATCH_TYPES_DO(ALLOC_CPP_VTABLE_CLONE);
<a name="65" id="anc65"></a><span class="line-removed"> 791 }</span>
 792 
<a name="66" id="anc66"></a><span class="line-modified"> 793 // Switch the vtable pointer to point to the cloned vtable. We assume the</span>
<span class="line-removed"> 794 // vtable pointer is in first slot in object.</span>
<span class="line-removed"> 795 void MetaspaceShared::patch_cpp_vtable_pointers() {</span>
<span class="line-removed"> 796   int n = _global_klass_objects-&gt;length();</span>
<span class="line-removed"> 797   for (int i = 0; i &lt; n; i++) {</span>
<span class="line-removed"> 798     Klass* obj = _global_klass_objects-&gt;at(i);</span>
<span class="line-removed"> 799     if (obj-&gt;is_instance_klass()) {</span>
<span class="line-removed"> 800       InstanceKlass* ik = InstanceKlass::cast(obj);</span>
<span class="line-removed"> 801       if (ik-&gt;is_class_loader_instance_klass()) {</span>
<span class="line-removed"> 802         CppVtableCloner&lt;InstanceClassLoaderKlass&gt;::patch(ik);</span>
<span class="line-removed"> 803       } else if (ik-&gt;is_reference_instance_klass()) {</span>
<span class="line-removed"> 804         CppVtableCloner&lt;InstanceRefKlass&gt;::patch(ik);</span>
<span class="line-removed"> 805       } else if (ik-&gt;is_mirror_instance_klass()) {</span>
<span class="line-removed"> 806         CppVtableCloner&lt;InstanceMirrorKlass&gt;::patch(ik);</span>
<span class="line-removed"> 807       } else {</span>
<span class="line-removed"> 808         CppVtableCloner&lt;InstanceKlass&gt;::patch(ik);</span>
<span class="line-removed"> 809       }</span>
<span class="line-removed"> 810       ConstantPool* cp = ik-&gt;constants();</span>
<span class="line-removed"> 811       CppVtableCloner&lt;ConstantPool&gt;::patch(cp);</span>
<span class="line-removed"> 812       for (int j = 0; j &lt; ik-&gt;methods()-&gt;length(); j++) {</span>
<span class="line-removed"> 813         Method* m = ik-&gt;methods()-&gt;at(j);</span>
<span class="line-removed"> 814         CppVtableCloner&lt;Method&gt;::patch(m);</span>
<span class="line-removed"> 815         assert(CppVtableCloner&lt;Method&gt;::is_valid_shared_object(m), &quot;must be&quot;);</span>
<span class="line-removed"> 816       }</span>
<span class="line-removed"> 817     } else if (obj-&gt;is_objArray_klass()) {</span>
<span class="line-removed"> 818       CppVtableCloner&lt;ObjArrayKlass&gt;::patch(obj);</span>
<span class="line-removed"> 819     } else {</span>
<span class="line-removed"> 820       assert(obj-&gt;is_typeArray_klass(), &quot;sanity&quot;);</span>
<span class="line-removed"> 821       CppVtableCloner&lt;TypeArrayKlass&gt;::patch(obj);</span>
<span class="line-removed"> 822     }</span>
<span class="line-removed"> 823   }</span>
 824 }
 825 
 826 bool MetaspaceShared::is_valid_shared_method(const Method* m) {
 827   assert(is_in_shared_metaspace(m), &quot;must be&quot;);
 828   return CppVtableCloner&lt;Method&gt;::is_valid_shared_object(m);
 829 }
 830 
<a name="67" id="anc67"></a><span class="line-modified"> 831 // Closure for serializing initialization data out to a data area to be</span>
<span class="line-modified"> 832 // written to the shared file.</span>
<span class="line-modified"> 833 </span>
<span class="line-modified"> 834 class WriteClosure : public SerializeClosure {</span>
<span class="line-modified"> 835 private:</span>
<span class="line-modified"> 836   DumpRegion* _dump_region;</span>
<span class="line-modified"> 837 </span>
<span class="line-modified"> 838 public:</span>
<span class="line-removed"> 839   WriteClosure(DumpRegion* r) {</span>
<span class="line-removed"> 840     _dump_region = r;</span>
<span class="line-removed"> 841   }</span>
<span class="line-removed"> 842 </span>
<span class="line-removed"> 843   void do_ptr(void** p) {</span>
<span class="line-removed"> 844     _dump_region-&gt;append_intptr_t((intptr_t)*p);</span>
<span class="line-removed"> 845   }</span>
<span class="line-removed"> 846 </span>
<span class="line-removed"> 847   void do_u4(u4* p) {</span>
<span class="line-removed"> 848     void* ptr = (void*)(uintx(*p));</span>
<span class="line-removed"> 849     do_ptr(&amp;ptr);</span>
<span class="line-removed"> 850   }</span>
<span class="line-removed"> 851 </span>
<span class="line-removed"> 852   void do_tag(int tag) {</span>
<span class="line-removed"> 853     _dump_region-&gt;append_intptr_t((intptr_t)tag);</span>
<span class="line-removed"> 854   }</span>
<span class="line-removed"> 855 </span>
<span class="line-removed"> 856   void do_oop(oop* o) {</span>
<span class="line-removed"> 857     if (*o == NULL) {</span>
<span class="line-removed"> 858       _dump_region-&gt;append_intptr_t(0);</span>
<span class="line-removed"> 859     } else {</span>
<span class="line-removed"> 860       assert(HeapShared::is_heap_object_archiving_allowed(),</span>
<span class="line-removed"> 861              &quot;Archiving heap object is not allowed&quot;);</span>
<span class="line-removed"> 862       _dump_region-&gt;append_intptr_t(</span>
<span class="line-removed"> 863         (intptr_t)CompressedOops::encode_not_null(*o));</span>
<span class="line-removed"> 864     }</span>
 865   }
<a name="68" id="anc68"></a>
 866 
<a name="69" id="anc69"></a><span class="line-modified"> 867   void do_region(u_char* start, size_t size) {</span>
<span class="line-modified"> 868     assert((intptr_t)start % sizeof(intptr_t) == 0, &quot;bad alignment&quot;);</span>
<span class="line-modified"> 869     assert(size % sizeof(intptr_t) == 0, &quot;bad size&quot;);</span>
<span class="line-modified"> 870     do_tag((int)size);</span>
<span class="line-modified"> 871     while (size &gt; 0) {</span>
<span class="line-modified"> 872       _dump_region-&gt;append_intptr_t(*(intptr_t*)start);</span>
<span class="line-modified"> 873       start += sizeof(intptr_t);</span>
<span class="line-modified"> 874       size -= sizeof(intptr_t);</span>
<span class="line-removed"> 875     }</span>
 876   }
<a name="70" id="anc70"></a><span class="line-modified"> 877 </span>
<span class="line-removed"> 878   bool reading() const { return false; }</span>
<span class="line-removed"> 879 };</span>
 880 
 881 // This is for dumping detailed statistics for the allocations
 882 // in the shared spaces.
 883 class DumpAllocStats : public ResourceObj {
 884 public:
 885 
 886   // Here&#39;s poor man&#39;s enum inheritance
 887 #define SHAREDSPACE_OBJ_TYPES_DO(f) \
 888   METASPACE_OBJ_TYPES_DO(f) \
 889   f(SymbolHashentry) \
 890   f(SymbolBucket) \
 891   f(StringHashentry) \
 892   f(StringBucket) \
 893   f(Other)
 894 
 895   enum Type {
 896     // Types are MetaspaceObj::ClassType, MetaspaceObj::SymbolType, etc
 897     SHAREDSPACE_OBJ_TYPES_DO(METASPACE_OBJ_TYPE_DECLARE)
 898     _number_of_types
 899   };
 900 
 901   static const char * type_name(Type type) {
 902     switch(type) {
 903     SHAREDSPACE_OBJ_TYPES_DO(METASPACE_OBJ_TYPE_NAME_CASE)
 904     default:
 905       ShouldNotReachHere();
 906       return NULL;
 907     }
 908   }
 909 
 910 public:
 911   enum { RO = 0, RW = 1 };
 912 
 913   int _counts[2][_number_of_types];
 914   int _bytes [2][_number_of_types];
 915 
 916   DumpAllocStats() {
 917     memset(_counts, 0, sizeof(_counts));
 918     memset(_bytes,  0, sizeof(_bytes));
 919   };
 920 
 921   void record(MetaspaceObj::Type type, int byte_size, bool read_only) {
 922     assert(int(type) &gt;= 0 &amp;&amp; type &lt; MetaspaceObj::_number_of_types, &quot;sanity&quot;);
 923     int which = (read_only) ? RO : RW;
 924     _counts[which][type] ++;
 925     _bytes [which][type] += byte_size;
 926   }
 927 
 928   void record_other_type(int byte_size, bool read_only) {
 929     int which = (read_only) ? RO : RW;
 930     _bytes [which][OtherType] += byte_size;
 931   }
<a name="71" id="anc71"></a><span class="line-modified"> 932   void print_stats(int ro_all, int rw_all, int mc_all, int md_all);</span>
 933 };
 934 
<a name="72" id="anc72"></a><span class="line-modified"> 935 void DumpAllocStats::print_stats(int ro_all, int rw_all, int mc_all, int md_all) {</span>
 936   // Calculate size of data that was not allocated by Metaspace::allocate()
 937   MetaspaceSharedStats *stats = MetaspaceShared::stats();
 938 
 939   // symbols
 940   _counts[RO][SymbolHashentryType] = stats-&gt;symbol.hashentry_count;
 941   _bytes [RO][SymbolHashentryType] = stats-&gt;symbol.hashentry_bytes;
 942 
 943   _counts[RO][SymbolBucketType] = stats-&gt;symbol.bucket_count;
 944   _bytes [RO][SymbolBucketType] = stats-&gt;symbol.bucket_bytes;
 945 
 946   // strings
 947   _counts[RO][StringHashentryType] = stats-&gt;string.hashentry_count;
 948   _bytes [RO][StringHashentryType] = stats-&gt;string.hashentry_bytes;
 949 
 950   _counts[RO][StringBucketType] = stats-&gt;string.bucket_count;
 951   _bytes [RO][StringBucketType] = stats-&gt;string.bucket_bytes;
 952 
 953   // TODO: count things like dictionary, vtable, etc
<a name="73" id="anc73"></a><span class="line-modified"> 954   _bytes[RW][OtherType] += mc_all + md_all;</span>
<span class="line-modified"> 955   rw_all += mc_all + md_all; // mc/md are mapped Read/Write</span>
 956 
 957   // prevent divide-by-zero
 958   if (ro_all &lt; 1) {
 959     ro_all = 1;
 960   }
 961   if (rw_all &lt; 1) {
 962     rw_all = 1;
 963   }
 964 
 965   int all_ro_count = 0;
 966   int all_ro_bytes = 0;
 967   int all_rw_count = 0;
 968   int all_rw_bytes = 0;
 969 
 970 // To make fmt_stats be a syntactic constant (for format warnings), use #define.
 971 #define fmt_stats &quot;%-20s: %8d %10d %5.1f | %8d %10d %5.1f | %8d %10d %5.1f&quot;
 972   const char *sep = &quot;--------------------+---------------------------+---------------------------+--------------------------&quot;;
 973   const char *hdr = &quot;                        ro_cnt   ro_bytes     % |   rw_cnt   rw_bytes     % |  all_cnt  all_bytes     %&quot;;
 974 
 975   LogMessage(cds) msg;
 976 
<a name="74" id="anc74"></a><span class="line-modified"> 977   msg.info(&quot;Detailed metadata info (excluding od/st regions; rw stats include md/mc regions):&quot;);</span>
<span class="line-modified"> 978   msg.info(&quot;%s&quot;, hdr);</span>
<span class="line-modified"> 979   msg.info(&quot;%s&quot;, sep);</span>
 980   for (int type = 0; type &lt; int(_number_of_types); type ++) {
 981     const char *name = type_name((Type)type);
 982     int ro_count = _counts[RO][type];
 983     int ro_bytes = _bytes [RO][type];
 984     int rw_count = _counts[RW][type];
 985     int rw_bytes = _bytes [RW][type];
 986     int count = ro_count + rw_count;
 987     int bytes = ro_bytes + rw_bytes;
 988 
 989     double ro_perc = percent_of(ro_bytes, ro_all);
 990     double rw_perc = percent_of(rw_bytes, rw_all);
 991     double perc    = percent_of(bytes, ro_all + rw_all);
 992 
<a name="75" id="anc75"></a><span class="line-modified"> 993     msg.info(fmt_stats, name,</span>
 994                          ro_count, ro_bytes, ro_perc,
 995                          rw_count, rw_bytes, rw_perc,
 996                          count, bytes, perc);
 997 
 998     all_ro_count += ro_count;
 999     all_ro_bytes += ro_bytes;
1000     all_rw_count += rw_count;
1001     all_rw_bytes += rw_bytes;
1002   }
1003 
1004   int all_count = all_ro_count + all_rw_count;
1005   int all_bytes = all_ro_bytes + all_rw_bytes;
1006 
1007   double all_ro_perc = percent_of(all_ro_bytes, ro_all);
1008   double all_rw_perc = percent_of(all_rw_bytes, rw_all);
1009   double all_perc    = percent_of(all_bytes, ro_all + rw_all);
1010 
<a name="76" id="anc76"></a><span class="line-modified">1011   msg.info(&quot;%s&quot;, sep);</span>
<span class="line-modified">1012   msg.info(fmt_stats, &quot;Total&quot;,</span>
1013                        all_ro_count, all_ro_bytes, all_ro_perc,
1014                        all_rw_count, all_rw_bytes, all_rw_perc,
1015                        all_count, all_bytes, all_perc);
1016 
1017   assert(all_ro_bytes == ro_all, &quot;everything should have been counted&quot;);
1018   assert(all_rw_bytes == rw_all, &quot;everything should have been counted&quot;);
1019 
1020 #undef fmt_stats
1021 }
1022 
1023 // Populate the shared space.
1024 
1025 class VM_PopulateDumpSharedSpace: public VM_Operation {
1026 private:
1027   GrowableArray&lt;MemRegion&gt; *_closed_archive_heap_regions;
1028   GrowableArray&lt;MemRegion&gt; *_open_archive_heap_regions;
1029 
1030   GrowableArray&lt;ArchiveHeapOopmapInfo&gt; *_closed_archive_heap_oopmaps;
1031   GrowableArray&lt;ArchiveHeapOopmapInfo&gt; *_open_archive_heap_oopmaps;
1032 
1033   void dump_java_heap_objects() NOT_CDS_JAVA_HEAP_RETURN;
1034   void dump_archive_heap_oopmaps() NOT_CDS_JAVA_HEAP_RETURN;
1035   void dump_archive_heap_oopmaps(GrowableArray&lt;MemRegion&gt;* regions,
1036                                  GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* oopmaps);
1037   void dump_symbols();
1038   char* dump_read_only_tables();
<a name="77" id="anc77"></a>
1039   void print_region_stats();
<a name="78" id="anc78"></a>
1040   void print_heap_region_stats(GrowableArray&lt;MemRegion&gt; *heap_mem,
<a name="79" id="anc79"></a><span class="line-modified">1041                                const char *name, const size_t total_size);</span>


1042 public:
1043 
1044   VMOp_Type type() const { return VMOp_PopulateDumpSharedSpace; }
1045   void doit();   // outline because gdb sucks
<a name="80" id="anc80"></a><span class="line-removed">1046   static void write_region(FileMapInfo* mapinfo, int region, DumpRegion* space, bool read_only,  bool allow_exec);</span>
1047   bool allow_nested_vm_operations() const { return true; }
1048 }; // class VM_PopulateDumpSharedSpace
1049 
1050 class SortedSymbolClosure: public SymbolClosure {
1051   GrowableArray&lt;Symbol*&gt; _symbols;
1052   virtual void do_symbol(Symbol** sym) {
1053     assert((*sym)-&gt;is_permanent(), &quot;archived symbols must be permanent&quot;);
1054     _symbols.append(*sym);
1055   }
1056   static int compare_symbols_by_address(Symbol** a, Symbol** b) {
1057     if (a[0] &lt; b[0]) {
1058       return -1;
1059     } else if (a[0] == b[0]) {
1060       return 0;
1061     } else {
1062       return 1;
1063     }
1064   }
1065 
1066 public:
1067   SortedSymbolClosure() {
1068     SymbolTable::symbols_do(this);
1069     _symbols.sort(compare_symbols_by_address);
1070   }
1071   GrowableArray&lt;Symbol*&gt;* get_sorted_symbols() {
1072     return &amp;_symbols;
1073   }
1074 };
1075 
1076 // ArchiveCompactor --
1077 //
1078 // This class is the central piece of shared archive compaction -- all metaspace data are
1079 // initially allocated outside of the shared regions. ArchiveCompactor copies the
1080 // metaspace data into their final location in the shared regions.
1081 
1082 class ArchiveCompactor : AllStatic {
1083   static const int INITIAL_TABLE_SIZE = 8087;
1084   static const int MAX_TABLE_SIZE     = 1000000;
1085 
1086   static DumpAllocStats* _alloc_stats;
1087   static SortedSymbolClosure* _ssc;
1088 
1089   typedef KVHashtable&lt;address, address, mtInternal&gt; RelocationTable;
1090   static RelocationTable* _new_loc_table;
1091 
1092 public:
1093   static void initialize() {
1094     _alloc_stats = new(ResourceObj::C_HEAP, mtInternal)DumpAllocStats;
1095     _new_loc_table = new RelocationTable(INITIAL_TABLE_SIZE);
1096   }
1097   static DumpAllocStats* alloc_stats() {
1098     return _alloc_stats;
1099   }
1100 
1101   // Use this when you allocate space with MetaspaceShare::read_only_space_alloc()
1102   // outside of ArchiveCompactor::allocate(). These are usually for misc tables
1103   // that are allocated in the RO space.
1104   class OtherROAllocMark {
1105     char* _oldtop;
1106   public:
1107     OtherROAllocMark() {
1108       _oldtop = _ro_region.top();
1109     }
1110     ~OtherROAllocMark() {
1111       char* newtop = _ro_region.top();
1112       ArchiveCompactor::alloc_stats()-&gt;record_other_type(int(newtop - _oldtop), true);
1113     }
1114   };
1115 
1116   static void allocate(MetaspaceClosure::Ref* ref, bool read_only) {
1117     address obj = ref-&gt;obj();
1118     int bytes = ref-&gt;size() * BytesPerWord;
1119     char* p;
1120     size_t alignment = BytesPerWord;
1121     char* oldtop;
1122     char* newtop;
1123 
1124     if (read_only) {
1125       oldtop = _ro_region.top();
1126       p = _ro_region.allocate(bytes, alignment);
1127       newtop = _ro_region.top();
1128     } else {
1129       oldtop = _rw_region.top();
1130       if (ref-&gt;msotype() == MetaspaceObj::ClassType) {
1131         // Save a pointer immediate in front of an InstanceKlass, so
1132         // we can do a quick lookup from InstanceKlass* -&gt; RunTimeSharedClassInfo*
1133         // without building another hashtable. See RunTimeSharedClassInfo::get_for()
1134         // in systemDictionaryShared.cpp.
1135         Klass* klass = (Klass*)obj;
1136         if (klass-&gt;is_instance_klass()) {
1137           SystemDictionaryShared::validate_before_archiving(InstanceKlass::cast(klass));
1138           _rw_region.allocate(sizeof(address), BytesPerWord);
1139         }
1140       }
1141       p = _rw_region.allocate(bytes, alignment);
1142       newtop = _rw_region.top();
1143     }
1144     memcpy(p, obj, bytes);
<a name="81" id="anc81"></a>






1145     assert(_new_loc_table-&gt;lookup(obj) == NULL, &quot;each object can be relocated at most once&quot;);
1146     _new_loc_table-&gt;add(obj, (address)p);
1147     log_trace(cds)(&quot;Copy: &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT &quot; %d&quot;, p2i(obj), p2i(p), bytes);
1148     if (_new_loc_table-&gt;maybe_grow(MAX_TABLE_SIZE)) {
1149       log_info(cds, hashtables)(&quot;Expanded _new_loc_table to %d&quot;, _new_loc_table-&gt;table_size());
1150     }
1151     _alloc_stats-&gt;record(ref-&gt;msotype(), int(newtop - oldtop), read_only);
1152   }
1153 
1154   static address get_new_loc(MetaspaceClosure::Ref* ref) {
1155     address* pp = _new_loc_table-&gt;lookup(ref-&gt;obj());
1156     assert(pp != NULL, &quot;must be&quot;);
1157     return *pp;
1158   }
1159 
1160 private:
1161   // Makes a shallow copy of visited MetaspaceObj&#39;s
1162   class ShallowCopier: public UniqueMetaspaceClosure {
1163     bool _read_only;
1164   public:
1165     ShallowCopier(bool read_only) : _read_only(read_only) {}
1166 
<a name="82" id="anc82"></a><span class="line-modified">1167     virtual void do_unique_ref(Ref* ref, bool read_only) {</span>
1168       if (read_only == _read_only) {
1169         allocate(ref, read_only);
1170       }
<a name="83" id="anc83"></a>
1171     }
1172   };
1173 
1174   // Relocate embedded pointers within a MetaspaceObj&#39;s shallow copy
1175   class ShallowCopyEmbeddedRefRelocator: public UniqueMetaspaceClosure {
1176   public:
<a name="84" id="anc84"></a><span class="line-modified">1177     virtual void do_unique_ref(Ref* ref, bool read_only) {</span>
1178       address new_loc = get_new_loc(ref);
1179       RefRelocator refer;
1180       ref-&gt;metaspace_pointers_do_at(&amp;refer, new_loc);
<a name="85" id="anc85"></a>









1181     }
1182   };
1183 
1184   // Relocate a reference to point to its shallow copy
1185   class RefRelocator: public MetaspaceClosure {
1186   public:
1187     virtual bool do_ref(Ref* ref, bool read_only) {
1188       if (ref-&gt;not_null()) {
1189         ref-&gt;update(get_new_loc(ref));
<a name="86" id="anc86"></a>
1190       }
1191       return false; // Do not recurse.
1192     }
1193   };
1194 
1195 #ifdef ASSERT
1196   class IsRefInArchiveChecker: public MetaspaceClosure {
1197   public:
1198     virtual bool do_ref(Ref* ref, bool read_only) {
1199       if (ref-&gt;not_null()) {
1200         char* obj = (char*)ref-&gt;obj();
1201         assert(_ro_region.contains(obj) || _rw_region.contains(obj),
1202                &quot;must be relocated to point to CDS archive&quot;);
1203       }
1204       return false; // Do not recurse.
1205     }
1206   };
1207 #endif
1208 
1209 public:
1210   static void copy_and_compact() {
1211     ResourceMark rm;
1212     SortedSymbolClosure the_ssc; // StackObj
1213     _ssc = &amp;the_ssc;
1214 
<a name="87" id="anc87"></a><span class="line-modified">1215     tty-&gt;print_cr(&quot;Scanning all metaspace objects ... &quot;);</span>
1216     {
1217       // allocate and shallow-copy RW objects, immediately following the MC region
<a name="88" id="anc88"></a><span class="line-modified">1218       tty-&gt;print_cr(&quot;Allocating RW objects ... &quot;);</span>
1219       _mc_region.pack(&amp;_rw_region);
1220 
1221       ResourceMark rm;
1222       ShallowCopier rw_copier(false);
1223       iterate_roots(&amp;rw_copier);
1224     }
1225     {
1226       // allocate and shallow-copy of RO object, immediately following the RW region
<a name="89" id="anc89"></a><span class="line-modified">1227       tty-&gt;print_cr(&quot;Allocating RO objects ... &quot;);</span>
1228       _rw_region.pack(&amp;_ro_region);
1229 
1230       ResourceMark rm;
1231       ShallowCopier ro_copier(true);
1232       iterate_roots(&amp;ro_copier);
1233     }
1234     {
<a name="90" id="anc90"></a><span class="line-modified">1235       tty-&gt;print_cr(&quot;Relocating embedded pointers ... &quot;);</span>
1236       ResourceMark rm;
1237       ShallowCopyEmbeddedRefRelocator emb_reloc;
1238       iterate_roots(&amp;emb_reloc);
1239     }
1240     {
<a name="91" id="anc91"></a><span class="line-modified">1241       tty-&gt;print_cr(&quot;Relocating external roots ... &quot;);</span>
1242       ResourceMark rm;
1243       RefRelocator ext_reloc;
1244       iterate_roots(&amp;ext_reloc);
1245     }
1246 
1247 #ifdef ASSERT
1248     {
<a name="92" id="anc92"></a><span class="line-modified">1249       tty-&gt;print_cr(&quot;Verifying external roots ... &quot;);</span>
1250       ResourceMark rm;
1251       IsRefInArchiveChecker checker;
1252       iterate_roots(&amp;checker);
1253     }
1254 #endif
1255 
1256 
1257     // cleanup
1258     _ssc = NULL;
1259   }
1260 
1261   // We must relocate the System::_well_known_klasses only after we have copied the
1262   // java objects in during dump_java_heap_objects(): during the object copy, we operate on
1263   // old objects which assert that their klass is the original klass.
1264   static void relocate_well_known_klasses() {
1265     {
<a name="93" id="anc93"></a><span class="line-modified">1266       tty-&gt;print_cr(&quot;Relocating SystemDictionary::_well_known_klasses[] ... &quot;);</span>
1267       ResourceMark rm;
1268       RefRelocator ext_reloc;
1269       SystemDictionary::well_known_klasses_do(&amp;ext_reloc);
1270     }
1271     // NOTE: after this point, we shouldn&#39;t have any globals that can reach the old
1272     // objects.
1273 
1274     // We cannot use any of the objects in the heap anymore (except for the
1275     // shared strings) because their headers no longer point to valid Klasses.
1276   }
1277 
1278   static void iterate_roots(MetaspaceClosure* it) {
1279     GrowableArray&lt;Symbol*&gt;* symbols = _ssc-&gt;get_sorted_symbols();
1280     for (int i=0; i&lt;symbols-&gt;length(); i++) {
1281       it-&gt;push(symbols-&gt;adr_at(i));
1282     }
1283     if (_global_klass_objects != NULL) {
1284       // Need to fix up the pointers
1285       for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
1286         // NOTE -- this requires that the vtable is NOT yet patched, or else we are hosed.
1287         it-&gt;push(_global_klass_objects-&gt;adr_at(i));
1288       }
1289     }
1290     FileMapInfo::metaspace_pointers_do(it);
1291     SystemDictionaryShared::dumptime_classes_do(it);
1292     Universe::metaspace_pointers_do(it);
1293     SymbolTable::metaspace_pointers_do(it);
1294     vmSymbols::metaspace_pointers_do(it);
<a name="94" id="anc94"></a>

1295   }
1296 
1297   static Klass* get_relocated_klass(Klass* orig_klass) {
1298     assert(DumpSharedSpaces, &quot;dump time only&quot;);
1299     address* pp = _new_loc_table-&gt;lookup((address)orig_klass);
1300     assert(pp != NULL, &quot;must be&quot;);
1301     Klass* klass = (Klass*)(*pp);
1302     assert(klass-&gt;is_klass(), &quot;must be&quot;);
1303     return klass;
1304   }
1305 };
1306 
1307 DumpAllocStats* ArchiveCompactor::_alloc_stats;
1308 SortedSymbolClosure* ArchiveCompactor::_ssc;
1309 ArchiveCompactor::RelocationTable* ArchiveCompactor::_new_loc_table;
1310 
<a name="95" id="anc95"></a><span class="line-removed">1311 void VM_PopulateDumpSharedSpace::write_region(FileMapInfo* mapinfo, int region_idx,</span>
<span class="line-removed">1312                                               DumpRegion* dump_region, bool read_only,  bool allow_exec) {</span>
<span class="line-removed">1313   mapinfo-&gt;write_region(region_idx, dump_region-&gt;base(), dump_region-&gt;used(), read_only, allow_exec);</span>
<span class="line-removed">1314 }</span>
<span class="line-removed">1315 </span>
1316 void VM_PopulateDumpSharedSpace::dump_symbols() {
<a name="96" id="anc96"></a><span class="line-modified">1317   tty-&gt;print_cr(&quot;Dumping symbol table ...&quot;);</span>
1318 
1319   NOT_PRODUCT(SymbolTable::verify());
1320   SymbolTable::write_to_archive();
1321 }
1322 
1323 char* VM_PopulateDumpSharedSpace::dump_read_only_tables() {
1324   ArchiveCompactor::OtherROAllocMark mark;
1325 
<a name="97" id="anc97"></a><span class="line-modified">1326   tty-&gt;print(&quot;Removing java_mirror ... &quot;);</span>
1327   if (!HeapShared::is_heap_object_archiving_allowed()) {
1328     clear_basic_type_mirrors();
1329   }
1330   remove_java_mirror_in_classes();
<a name="98" id="anc98"></a><span class="line-modified">1331   tty-&gt;print_cr(&quot;done. &quot;);</span>
1332 
1333   SystemDictionaryShared::write_to_archive();
1334 
<a name="99" id="anc99"></a><span class="line-removed">1335   char* start = _ro_region.top();</span>
<span class="line-removed">1336 </span>
1337   // Write the other data to the output array.
<a name="100" id="anc100"></a>
1338   WriteClosure wc(&amp;_ro_region);
1339   MetaspaceShared::serialize(&amp;wc);
1340 
1341   // Write the bitmaps for patching the archive heap regions
1342   dump_archive_heap_oopmaps();
1343 
1344   return start;
1345 }
1346 
<a name="101" id="anc101"></a>




























































1347 void VM_PopulateDumpSharedSpace::doit() {
<a name="102" id="anc102"></a>


1348   // We should no longer allocate anything from the metaspace, so that:
1349   //
1350   // (1) Metaspace::allocate might trigger GC if we have run out of
1351   //     committed metaspace, but we can&#39;t GC because we&#39;re running
1352   //     in the VM thread.
1353   // (2) ArchiveCompactor needs to work with a stable set of MetaspaceObjs.
1354   Metaspace::freeze();
<a name="103" id="anc103"></a>
1355 
1356   Thread* THREAD = VMThread::vm_thread();
1357 
1358   FileMapInfo::check_nonempty_dir_in_shared_path_table();
1359 
1360   NOT_PRODUCT(SystemDictionary::verify();)
1361   // The following guarantee is meant to ensure that no loader constraints
1362   // exist yet, since the constraints table is not shared.  This becomes
1363   // more important now that we don&#39;t re-initialize vtables/itables for
1364   // shared classes at runtime, where constraints were previously created.
1365   guarantee(SystemDictionary::constraints()-&gt;number_of_entries() == 0,
1366             &quot;loader constraints are not saved&quot;);
1367   guarantee(SystemDictionary::placeholders()-&gt;number_of_entries() == 0,
1368           &quot;placeholders are not saved&quot;);
1369 
1370   // At this point, many classes have been loaded.
1371   // Gather systemDictionary classes in a global array and do everything to
1372   // that so we don&#39;t have to walk the SystemDictionary again.
1373   SystemDictionaryShared::check_excluded_classes();
1374   _global_klass_objects = new GrowableArray&lt;Klass*&gt;(1000);
1375   CollectClassesClosure collect_classes;
1376   ClassLoaderDataGraph::loaded_classes_do(&amp;collect_classes);
1377 
<a name="104" id="anc104"></a><span class="line-modified">1378   tty-&gt;print_cr(&quot;Number of classes %d&quot;, _global_klass_objects-&gt;length());</span>
<span class="line-removed">1379   {</span>
<span class="line-removed">1380     int num_type_array = 0, num_obj_array = 0, num_inst = 0;</span>
<span class="line-removed">1381     for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {</span>
<span class="line-removed">1382       Klass* k = _global_klass_objects-&gt;at(i);</span>
<span class="line-removed">1383       if (k-&gt;is_instance_klass()) {</span>
<span class="line-removed">1384         num_inst ++;</span>
<span class="line-removed">1385       } else if (k-&gt;is_objArray_klass()) {</span>
<span class="line-removed">1386         num_obj_array ++;</span>
<span class="line-removed">1387       } else {</span>
<span class="line-removed">1388         assert(k-&gt;is_typeArray_klass(), &quot;sanity&quot;);</span>
<span class="line-removed">1389         num_type_array ++;</span>
<span class="line-removed">1390       }</span>
<span class="line-removed">1391     }</span>
<span class="line-removed">1392     tty-&gt;print_cr(&quot;    instance classes   = %5d&quot;, num_inst);</span>
<span class="line-removed">1393     tty-&gt;print_cr(&quot;    obj array classes  = %5d&quot;, num_obj_array);</span>
<span class="line-removed">1394     tty-&gt;print_cr(&quot;    type array classes = %5d&quot;, num_type_array);</span>
<span class="line-removed">1395   }</span>
1396 
1397   // Ensure the ConstMethods won&#39;t be modified at run-time
<a name="105" id="anc105"></a><span class="line-modified">1398   tty-&gt;print(&quot;Updating ConstMethods ... &quot;);</span>
<span class="line-modified">1399   rewrite_nofast_bytecodes_and_calculate_fingerprints();</span>
<span class="line-modified">1400   tty-&gt;print_cr(&quot;done. &quot;);</span>
1401 
1402   // Remove all references outside the metadata
<a name="106" id="anc106"></a><span class="line-modified">1403   tty-&gt;print(&quot;Removing unshareable information ... &quot;);</span>
1404   remove_unshareable_in_classes();
<a name="107" id="anc107"></a><span class="line-modified">1405   tty-&gt;print_cr(&quot;done. &quot;);</span>




1406 
1407   ArchiveCompactor::initialize();
1408   ArchiveCompactor::copy_and_compact();
1409 
1410   dump_symbols();
1411 
1412   // Dump supported java heap objects
1413   _closed_archive_heap_regions = NULL;
1414   _open_archive_heap_regions = NULL;
1415   dump_java_heap_objects();
1416 
1417   ArchiveCompactor::relocate_well_known_klasses();
1418 
<a name="108" id="anc108"></a><span class="line-modified">1419   char* read_only_tables_start = dump_read_only_tables();</span>
<span class="line-modified">1420   _ro_region.pack(&amp;_md_region);</span>
<span class="line-removed">1421 </span>
<span class="line-removed">1422   char* vtbl_list = _md_region.top();</span>
<span class="line-removed">1423   MetaspaceShared::allocate_cpp_vtable_clones();</span>
<span class="line-removed">1424   _md_region.pack();</span>
<span class="line-removed">1425 </span>
<span class="line-removed">1426   // The 4 core spaces are allocated consecutively mc-&gt;rw-&gt;ro-&gt;md, so there total size</span>
<span class="line-removed">1427   // is just the spaces between the two ends.</span>
<span class="line-removed">1428   size_t core_spaces_size = _md_region.end() - _mc_region.base();</span>
<span class="line-removed">1429   assert(core_spaces_size == (size_t)align_up(core_spaces_size, Metaspace::reserve_alignment()),</span>
<span class="line-removed">1430          &quot;should already be aligned&quot;);</span>
<span class="line-removed">1431 </span>
<span class="line-removed">1432   // During patching, some virtual methods may be called, so at this point</span>
<span class="line-removed">1433   // the vtables must contain valid methods (as filled in by CppVtableCloner::allocate).</span>
<span class="line-removed">1434   MetaspaceShared::patch_cpp_vtable_pointers();</span>
1435 
1436   // The vtable clones contain addresses of the current process.
1437   // We don&#39;t want to write these addresses into the archive.
1438   MetaspaceShared::zero_cpp_vtable_clones_for_writing();
1439 
<a name="109" id="anc109"></a>



1440   // Create and write the archive file that maps the shared spaces.
1441 
<a name="110" id="anc110"></a><span class="line-modified">1442   FileMapInfo* mapinfo = new FileMapInfo();</span>
1443   mapinfo-&gt;populate_header(os::vm_allocation_granularity());
<a name="111" id="anc111"></a><span class="line-modified">1444   mapinfo-&gt;set_read_only_tables_start(read_only_tables_start);</span>
<span class="line-modified">1445   mapinfo-&gt;set_misc_data_patching_start(vtbl_list);</span>
<span class="line-modified">1446   mapinfo-&gt;set_cds_i2i_entry_code_buffers(MetaspaceShared::cds_i2i_entry_code_buffers());</span>
<span class="line-modified">1447   mapinfo-&gt;set_cds_i2i_entry_code_buffers_size(MetaspaceShared::cds_i2i_entry_code_buffers_size());</span>
<span class="line-modified">1448   mapinfo-&gt;set_core_spaces_size(core_spaces_size);</span>
<span class="line-modified">1449 </span>
<span class="line-modified">1450   for (int pass=1; pass&lt;=2; pass++) {</span>
<span class="line-removed">1451     bool print_archive_log = (pass==1);</span>
<span class="line-removed">1452     if (pass == 1) {</span>
<span class="line-removed">1453       // The first pass doesn&#39;t actually write the data to disk. All it</span>
<span class="line-removed">1454       // does is to update the fields in the mapinfo-&gt;_header.</span>
<span class="line-removed">1455     } else {</span>
<span class="line-removed">1456       // After the first pass, the contents of mapinfo-&gt;_header are finalized,</span>
<span class="line-removed">1457       // so we can compute the header&#39;s CRC, and write the contents of the header</span>
<span class="line-removed">1458       // and the regions into disk.</span>
<span class="line-removed">1459       mapinfo-&gt;open_for_write();</span>
<span class="line-removed">1460       mapinfo-&gt;set_header_crc(mapinfo-&gt;compute_header_crc());</span>
<span class="line-removed">1461     }</span>
<span class="line-removed">1462     mapinfo-&gt;write_header();</span>
<span class="line-removed">1463 </span>
<span class="line-removed">1464     // NOTE: md contains the trampoline code for method entries, which are patched at run time,</span>
<span class="line-removed">1465     // so it needs to be read/write.</span>
<span class="line-removed">1466     write_region(mapinfo, MetaspaceShared::mc, &amp;_mc_region, /*read_only=*/false,/*allow_exec=*/true);</span>
<span class="line-removed">1467     write_region(mapinfo, MetaspaceShared::rw, &amp;_rw_region, /*read_only=*/false,/*allow_exec=*/false);</span>
<span class="line-removed">1468     write_region(mapinfo, MetaspaceShared::ro, &amp;_ro_region, /*read_only=*/true, /*allow_exec=*/false);</span>
<span class="line-removed">1469     write_region(mapinfo, MetaspaceShared::md, &amp;_md_region, /*read_only=*/false,/*allow_exec=*/false);</span>
<span class="line-removed">1470 </span>
<span class="line-removed">1471     _total_closed_archive_region_size = mapinfo-&gt;write_archive_heap_regions(</span>
1472                                         _closed_archive_heap_regions,
1473                                         _closed_archive_heap_oopmaps,
1474                                         MetaspaceShared::first_closed_archive_heap_region,
<a name="112" id="anc112"></a><span class="line-modified">1475                                         MetaspaceShared::max_closed_archive_heap_region,</span>
<span class="line-modified">1476                                         print_archive_log);</span>
<span class="line-removed">1477     _total_open_archive_region_size = mapinfo-&gt;write_archive_heap_regions(</span>
1478                                         _open_archive_heap_regions,
1479                                         _open_archive_heap_oopmaps,
1480                                         MetaspaceShared::first_open_archive_heap_region,
<a name="113" id="anc113"></a><span class="line-modified">1481                                         MetaspaceShared::max_open_archive_heap_region,</span>
<span class="line-removed">1482                                         print_archive_log);</span>
<span class="line-removed">1483   }</span>
1484 
<a name="114" id="anc114"></a>


1485   mapinfo-&gt;close();
1486 
<a name="115" id="anc115"></a><span class="line-removed">1487   // Restore the vtable in case we invoke any virtual methods.</span>
<span class="line-removed">1488   MetaspaceShared::clone_cpp_vtables((intptr_t*)vtbl_list);</span>
<span class="line-removed">1489 </span>
1490   print_region_stats();
1491 
1492   if (log_is_enabled(Info, cds)) {
1493     ArchiveCompactor::alloc_stats()-&gt;print_stats(int(_ro_region.used()), int(_rw_region.used()),
<a name="116" id="anc116"></a><span class="line-modified">1494                                                  int(_mc_region.used()), int(_md_region.used()));</span>
1495   }
1496 
1497   if (PrintSystemDictionaryAtExit) {
1498     SystemDictionary::print();
1499   }
1500 
1501   if (AllowArchivingWithJavaAgent) {
1502     warning(&quot;This archive was created with AllowArchivingWithJavaAgent. It should be used &quot;
1503             &quot;for testing purposes only and should not be used in a production environment&quot;);
1504   }
1505 
1506   // There may be other pending VM operations that operate on the InstanceKlasses,
1507   // which will fail because InstanceKlasses::remove_unshareable_info()
1508   // has been called. Forget these operations and exit the VM directly.
1509   vm_direct_exit(0);
1510 }
1511 
1512 void VM_PopulateDumpSharedSpace::print_region_stats() {
1513   // Print statistics of all the regions
<a name="117" id="anc117"></a>

1514   const size_t total_reserved = _ro_region.reserved()  + _rw_region.reserved() +
<a name="118" id="anc118"></a><span class="line-modified">1515                                 _mc_region.reserved()  + _md_region.reserved() +</span>

1516                                 _total_closed_archive_region_size +
1517                                 _total_open_archive_region_size;
1518   const size_t total_bytes = _ro_region.used()  + _rw_region.used() +
<a name="119" id="anc119"></a><span class="line-modified">1519                              _mc_region.used()  + _md_region.used() +</span>

1520                              _total_closed_archive_region_size +
1521                              _total_open_archive_region_size;
1522   const double total_u_perc = percent_of(total_bytes, total_reserved);
1523 
1524   _mc_region.print(total_reserved);
1525   _rw_region.print(total_reserved);
1526   _ro_region.print(total_reserved);
<a name="120" id="anc120"></a><span class="line-modified">1527   _md_region.print(total_reserved);</span>
1528   print_heap_region_stats(_closed_archive_heap_regions, &quot;ca&quot;, total_reserved);
1529   print_heap_region_stats(_open_archive_heap_regions, &quot;oa&quot;, total_reserved);
1530 
<a name="121" id="anc121"></a><span class="line-modified">1531   tty-&gt;print_cr(&quot;total    : &quot; SIZE_FORMAT_W(9) &quot; [100.0%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [%5.1f%% used]&quot;,</span>
1532                  total_bytes, total_reserved, total_u_perc);
1533 }
1534 
<a name="122" id="anc122"></a>




1535 void VM_PopulateDumpSharedSpace::print_heap_region_stats(GrowableArray&lt;MemRegion&gt; *heap_mem,
<a name="123" id="anc123"></a><span class="line-modified">1536                                                          const char *name, const size_t total_size) {</span>
1537   int arr_len = heap_mem == NULL ? 0 : heap_mem-&gt;length();
1538   for (int i = 0; i &lt; arr_len; i++) {
1539       char* start = (char*)heap_mem-&gt;at(i).start();
1540       size_t size = heap_mem-&gt;at(i).byte_size();
1541       char* top = start + size;
<a name="124" id="anc124"></a><span class="line-modified">1542       tty-&gt;print_cr(&quot;%s%d space: &quot; SIZE_FORMAT_W(9) &quot; [ %4.1f%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [100.0%% used] at &quot; INTPTR_FORMAT,</span>
<span class="line-modified">1543                     name, i, size, size/double(total_size)*100.0, size, p2i(start));</span>
1544 
1545   }
1546 }
1547 
<a name="125" id="anc125"></a>
















1548 // Update a Java object to point its Klass* to the new location after
1549 // shared archive has been compacted.
1550 void MetaspaceShared::relocate_klass_ptr(oop o) {
1551   assert(DumpSharedSpaces, &quot;sanity&quot;);
1552   Klass* k = ArchiveCompactor::get_relocated_klass(o-&gt;klass());
1553   o-&gt;set_klass(k);
1554 }
1555 
<a name="126" id="anc126"></a><span class="line-modified">1556 Klass* MetaspaceShared::get_relocated_klass(Klass *k) {</span>
1557   assert(DumpSharedSpaces, &quot;sanity&quot;);
<a name="127" id="anc127"></a><span class="line-modified">1558   return ArchiveCompactor::get_relocated_klass(k);</span>




1559 }
1560 
1561 class LinkSharedClassesClosure : public KlassClosure {
1562   Thread* THREAD;
1563   bool    _made_progress;
1564  public:
1565   LinkSharedClassesClosure(Thread* thread) : THREAD(thread), _made_progress(false) {}
1566 
1567   void reset()               { _made_progress = false; }
1568   bool made_progress() const { return _made_progress; }
1569 
1570   void do_klass(Klass* k) {
1571     if (k-&gt;is_instance_klass()) {
1572       InstanceKlass* ik = InstanceKlass::cast(k);
1573       // Link the class to cause the bytecodes to be rewritten and the
1574       // cpcache to be created. Class verification is done according
1575       // to -Xverify setting.
1576       _made_progress |= MetaspaceShared::try_link_class(ik, THREAD);
1577       guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in link_class&quot;);
1578 
1579       ik-&gt;constants()-&gt;resolve_class_constants(THREAD);
1580     }
1581   }
1582 };
1583 
1584 class CheckSharedClassesClosure : public KlassClosure {
1585   bool    _made_progress;
1586  public:
1587   CheckSharedClassesClosure() : _made_progress(false) {}
1588 
1589   void reset()               { _made_progress = false; }
1590   bool made_progress() const { return _made_progress; }
1591   void do_klass(Klass* k) {
1592     if (k-&gt;is_instance_klass() &amp;&amp; InstanceKlass::cast(k)-&gt;check_sharing_error_state()) {
1593       _made_progress = true;
1594     }
1595   }
1596 };
1597 
1598 void MetaspaceShared::link_and_cleanup_shared_classes(TRAPS) {
1599   // We need to iterate because verification may cause additional classes
1600   // to be loaded.
1601   LinkSharedClassesClosure link_closure(THREAD);
1602   do {
1603     link_closure.reset();
1604     ClassLoaderDataGraph::unlocked_loaded_classes_do(&amp;link_closure);
1605     guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in link_class&quot;);
1606   } while (link_closure.made_progress());
1607 
1608   if (_has_error_classes) {
1609     // Mark all classes whose super class or interfaces failed verification.
1610     CheckSharedClassesClosure check_closure;
1611     do {
1612       // Not completely sure if we need to do this iteratively. Anyway,
1613       // we should come here only if there are unverifiable classes, which
1614       // shouldn&#39;t happen in normal cases. So better safe than sorry.
1615       check_closure.reset();
1616       ClassLoaderDataGraph::unlocked_loaded_classes_do(&amp;check_closure);
1617     } while (check_closure.made_progress());
1618   }
1619 }
1620 
1621 void MetaspaceShared::prepare_for_dumping() {
1622   Arguments::check_unsupported_dumping_properties();
1623   ClassLoader::initialize_shared_path();
1624 }
1625 
1626 // Preload classes from a list, populate the shared spaces and dump to a
1627 // file.
1628 void MetaspaceShared::preload_and_dump(TRAPS) {
1629   { TraceTime timer(&quot;Dump Shared Spaces&quot;, TRACETIME_LOG(Info, startuptime));
<a name="128" id="anc128"></a><span class="line-modified">1630     ResourceMark rm;</span>
1631     char class_list_path_str[JVM_MAXPATHLEN];
1632     // Preload classes to be shared.
1633     const char* class_list_path;
1634     if (SharedClassListFile == NULL) {
1635       // Construct the path to the class list (in jre/lib)
1636       // Walk up two directories from the location of the VM and
1637       // optionally tack on &quot;lib&quot; (depending on platform)
1638       os::jvm_path(class_list_path_str, sizeof(class_list_path_str));
1639       for (int i = 0; i &lt; 3; i++) {
1640         char *end = strrchr(class_list_path_str, *os::file_separator());
1641         if (end != NULL) *end = &#39;\0&#39;;
1642       }
1643       int class_list_path_len = (int)strlen(class_list_path_str);
1644       if (class_list_path_len &gt;= 3) {
1645         if (strcmp(class_list_path_str + class_list_path_len - 3, &quot;lib&quot;) != 0) {
1646           if (class_list_path_len &lt; JVM_MAXPATHLEN - 4) {
1647             jio_snprintf(class_list_path_str + class_list_path_len,
1648                          sizeof(class_list_path_str) - class_list_path_len,
1649                          &quot;%slib&quot;, os::file_separator());
1650             class_list_path_len += 4;
1651           }
1652         }
1653       }
1654       if (class_list_path_len &lt; JVM_MAXPATHLEN - 10) {
1655         jio_snprintf(class_list_path_str + class_list_path_len,
1656                      sizeof(class_list_path_str) - class_list_path_len,
1657                      &quot;%sclasslist&quot;, os::file_separator());
1658       }
1659       class_list_path = class_list_path_str;
1660     } else {
1661       class_list_path = SharedClassListFile;
1662     }
1663 
<a name="129" id="anc129"></a><span class="line-modified">1664     tty-&gt;print_cr(&quot;Loading classes to share ...&quot;);</span>
1665     _has_error_classes = false;
1666     int class_count = preload_classes(class_list_path, THREAD);
1667     if (ExtraSharedClassListFile) {
1668       class_count += preload_classes(ExtraSharedClassListFile, THREAD);
1669     }
<a name="130" id="anc130"></a><span class="line-modified">1670     tty-&gt;print_cr(&quot;Loading classes to share: done.&quot;);</span>
1671 
1672     log_info(cds)(&quot;Shared spaces: preloaded %d classes&quot;, class_count);
1673 
1674     if (SharedArchiveConfigFile) {
<a name="131" id="anc131"></a><span class="line-modified">1675       tty-&gt;print_cr(&quot;Reading extra data from %s ...&quot;, SharedArchiveConfigFile);</span>
1676       read_extra_data(SharedArchiveConfigFile, THREAD);
1677     }
<a name="132" id="anc132"></a><span class="line-modified">1678     tty-&gt;print_cr(&quot;Reading extra data: done.&quot;);</span>
1679 
1680     HeapShared::init_subgraph_entry_fields(THREAD);
1681 
1682     // Rewrite and link classes
<a name="133" id="anc133"></a><span class="line-modified">1683     tty-&gt;print_cr(&quot;Rewriting and linking classes ...&quot;);</span>
1684 
1685     // Link any classes which got missed. This would happen if we have loaded classes that
1686     // were not explicitly specified in the classlist. E.g., if an interface implemented by class K
1687     // fails verification, all other interfaces that were not specified in the classlist but
1688     // are implemented by K are not verified.
1689     link_and_cleanup_shared_classes(CATCH);
<a name="134" id="anc134"></a><span class="line-modified">1690     tty-&gt;print_cr(&quot;Rewriting and linking classes: done&quot;);</span>
1691 
1692     if (HeapShared::is_heap_object_archiving_allowed()) {
1693       // Avoid fragmentation while archiving heap objects.
1694       Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(true);
1695       Universe::heap()-&gt;collect(GCCause::_archive_time_gc);
1696       Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(false);
1697     }
1698 
1699     VM_PopulateDumpSharedSpace op;
1700     VMThread::execute(&amp;op);
1701   }
1702 }
1703 
1704 
1705 int MetaspaceShared::preload_classes(const char* class_list_path, TRAPS) {
1706   ClassListParser parser(class_list_path);
1707   int class_count = 0;
1708 
1709   while (parser.parse_one_line()) {
1710     Klass* klass = parser.load_current_class(THREAD);
1711     if (HAS_PENDING_EXCEPTION) {
1712       if (klass == NULL &amp;&amp;
1713           (PENDING_EXCEPTION-&gt;klass()-&gt;name() == vmSymbols::java_lang_ClassNotFoundException())) {
1714         // print a warning only when the pending exception is class not found
<a name="135" id="anc135"></a><span class="line-modified">1715         tty-&gt;print_cr(&quot;Preload Warning: Cannot find %s&quot;, parser.current_class_name());</span>
1716       }
1717       CLEAR_PENDING_EXCEPTION;
1718     }
1719     if (klass != NULL) {
1720       if (log_is_enabled(Trace, cds)) {
<a name="136" id="anc136"></a><span class="line-modified">1721         ResourceMark rm;</span>
1722         log_trace(cds)(&quot;Shared spaces preloaded: %s&quot;, klass-&gt;external_name());
1723       }
1724 
1725       if (klass-&gt;is_instance_klass()) {
1726         InstanceKlass* ik = InstanceKlass::cast(klass);
1727 
1728         // Link the class to cause the bytecodes to be rewritten and the
1729         // cpcache to be created. The linking is done as soon as classes
1730         // are loaded in order that the related data structures (klass and
1731         // cpCache) are located together.
1732         try_link_class(ik, THREAD);
1733         guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in link_class&quot;);
1734       }
1735 
1736       class_count++;
1737     }
1738   }
1739 
1740   return class_count;
1741 }
1742 
1743 // Returns true if the class&#39;s status has changed
1744 bool MetaspaceShared::try_link_class(InstanceKlass* ik, TRAPS) {
1745   assert(DumpSharedSpaces, &quot;should only be called during dumping&quot;);
1746   if (ik-&gt;init_state() &lt; InstanceKlass::linked) {
1747     bool saved = BytecodeVerificationLocal;
1748     if (ik-&gt;loader_type() == 0 &amp;&amp; ik-&gt;class_loader() == NULL) {
1749       // The verification decision is based on BytecodeVerificationRemote
1750       // for non-system classes. Since we are using the NULL classloader
1751       // to load non-system classes for customized class loaders during dumping,
1752       // we need to temporarily change BytecodeVerificationLocal to be the same as
1753       // BytecodeVerificationRemote. Note this can cause the parent system
1754       // classes also being verified. The extra overhead is acceptable during
1755       // dumping.
1756       BytecodeVerificationLocal = BytecodeVerificationRemote;
1757     }
1758     ik-&gt;link_class(THREAD);
1759     if (HAS_PENDING_EXCEPTION) {
<a name="137" id="anc137"></a><span class="line-modified">1760       ResourceMark rm;</span>
<span class="line-modified">1761       tty-&gt;print_cr(&quot;Preload Warning: Verification failed for %s&quot;,</span>
1762                     ik-&gt;external_name());
1763       CLEAR_PENDING_EXCEPTION;
1764       ik-&gt;set_in_error_state();
1765       _has_error_classes = true;
1766     }
1767     BytecodeVerificationLocal = saved;
1768     return true;
1769   } else {
1770     return false;
1771   }
1772 }
1773 
1774 #if INCLUDE_CDS_JAVA_HEAP
1775 void VM_PopulateDumpSharedSpace::dump_java_heap_objects() {
1776   // The closed and open archive heap space has maximum two regions.
1777   // See FileMapInfo::write_archive_heap_regions() for details.
1778   _closed_archive_heap_regions = new GrowableArray&lt;MemRegion&gt;(2);
1779   _open_archive_heap_regions = new GrowableArray&lt;MemRegion&gt;(2);
1780   HeapShared::archive_java_heap_objects(_closed_archive_heap_regions,
1781                                         _open_archive_heap_regions);
1782   ArchiveCompactor::OtherROAllocMark mark;
1783   HeapShared::write_subgraph_info_table();
1784 }
1785 
1786 void VM_PopulateDumpSharedSpace::dump_archive_heap_oopmaps() {
1787   if (HeapShared::is_heap_object_archiving_allowed()) {
1788     _closed_archive_heap_oopmaps = new GrowableArray&lt;ArchiveHeapOopmapInfo&gt;(2);
1789     dump_archive_heap_oopmaps(_closed_archive_heap_regions, _closed_archive_heap_oopmaps);
1790 
1791     _open_archive_heap_oopmaps = new GrowableArray&lt;ArchiveHeapOopmapInfo&gt;(2);
1792     dump_archive_heap_oopmaps(_open_archive_heap_regions, _open_archive_heap_oopmaps);
1793   }
1794 }
1795 
1796 void VM_PopulateDumpSharedSpace::dump_archive_heap_oopmaps(GrowableArray&lt;MemRegion&gt;* regions,
1797                                                            GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* oopmaps) {
1798   for (int i=0; i&lt;regions-&gt;length(); i++) {
1799     ResourceBitMap oopmap = HeapShared::calculate_oopmap(regions-&gt;at(i));
1800     size_t size_in_bits = oopmap.size();
1801     size_t size_in_bytes = oopmap.size_in_bytes();
1802     uintptr_t* buffer = (uintptr_t*)_ro_region.allocate(size_in_bytes, sizeof(intptr_t));
1803     oopmap.write_to(buffer, size_in_bytes);
<a name="138" id="anc138"></a><span class="line-modified">1804     log_info(cds)(&quot;Oopmap = &quot; INTPTR_FORMAT &quot; (&quot; SIZE_FORMAT_W(6) &quot; bytes) for heap region &quot;</span>
<span class="line-modified">1805                   INTPTR_FORMAT &quot; (&quot; SIZE_FORMAT_W(8) &quot; bytes)&quot;,</span>
<span class="line-modified">1806                   p2i(buffer), size_in_bytes,</span>
<span class="line-modified">1807                   p2i(regions-&gt;at(i).start()), regions-&gt;at(i).byte_size());</span>
1808 
1809     ArchiveHeapOopmapInfo info;
1810     info._oopmap = (address)buffer;
1811     info._oopmap_size_in_bits = size_in_bits;
1812     oopmaps-&gt;append(info);
1813   }
1814 }
1815 #endif // INCLUDE_CDS_JAVA_HEAP
1816 
<a name="139" id="anc139"></a><span class="line-modified">1817 // Closure for serializing initialization data in from a data area</span>
<span class="line-modified">1818 // (ptr_array) read from the shared file.</span>





1819 
<a name="140" id="anc140"></a><span class="line-modified">1820 class ReadClosure : public SerializeClosure {</span>
<span class="line-modified">1821 private:</span>
<span class="line-modified">1822   intptr_t** _ptr_array;</span>

1823 
<a name="141" id="anc141"></a><span class="line-modified">1824   inline intptr_t nextPtr() {</span>
<span class="line-modified">1825     return *(*_ptr_array)++;</span>





















1826   }
<a name="142" id="anc142"></a>
1827 
<a name="143" id="anc143"></a><span class="line-modified">1828 public:</span>
<span class="line-modified">1829   ReadClosure(intptr_t** ptr_array) { _ptr_array = ptr_array; }</span>



















1830 
<a name="144" id="anc144"></a><span class="line-modified">1831   void do_ptr(void** p) {</span>
<span class="line-modified">1832     assert(*p == NULL, &quot;initializing previous initialized pointer.&quot;);</span>
<span class="line-modified">1833     intptr_t obj = nextPtr();</span>
<span class="line-removed">1834     assert((intptr_t)obj &gt;= 0 || (intptr_t)obj &lt; -100,</span>
<span class="line-removed">1835            &quot;hit tag while initializing ptrs.&quot;);</span>
<span class="line-removed">1836     *p = (void*)obj;</span>
1837   }
<a name="145" id="anc145"></a>

1838 
<a name="146" id="anc146"></a><span class="line-modified">1839   void do_u4(u4* p) {</span>
<span class="line-modified">1840     intptr_t obj = nextPtr();</span>
<span class="line-modified">1841     *p = (u4)(uintx(obj));</span>



1842   }
<a name="147" id="anc147"></a>
1843 
<a name="148" id="anc148"></a><span class="line-modified">1844   void do_tag(int tag) {</span>
<span class="line-modified">1845     int old_tag;</span>
<span class="line-modified">1846     old_tag = (int)(intptr_t)nextPtr();</span>
<span class="line-modified">1847     // do_int(&amp;old_tag);</span>
<span class="line-modified">1848     assert(tag == old_tag, &quot;old tag doesn&#39;t match&quot;);</span>
<span class="line-modified">1849     FileMapInfo::assert_mark(tag == old_tag);</span>











1850   }
1851 
<a name="149" id="anc149"></a><span class="line-modified">1852   void do_oop(oop *p) {</span>
<span class="line-modified">1853     narrowOop o = (narrowOop)nextPtr();</span>
<span class="line-modified">1854     if (o == 0 || !HeapShared::open_archive_heap_region_mapped()) {</span>
<span class="line-modified">1855       p = NULL;</span>




1856     } else {
<a name="150" id="anc150"></a><span class="line-modified">1857       assert(HeapShared::is_heap_object_archiving_allowed(),</span>
<span class="line-modified">1858              &quot;Archived heap object is not allowed&quot;);</span>
<span class="line-modified">1859       assert(HeapShared::open_archive_heap_region_mapped(),</span>
<span class="line-modified">1860              &quot;Open archive heap region is not mapped&quot;);</span>
<span class="line-modified">1861       *p = HeapShared::decode_from_archive(o);</span>



1862     }
1863   }
1864 
<a name="151" id="anc151"></a><span class="line-modified">1865   void do_region(u_char* start, size_t size) {</span>
<span class="line-modified">1866     assert((intptr_t)start % sizeof(intptr_t) == 0, &quot;bad alignment&quot;);</span>
<span class="line-modified">1867     assert(size % sizeof(intptr_t) == 0, &quot;bad size&quot;);</span>
<span class="line-modified">1868     do_tag((int)size);</span>
<span class="line-modified">1869     while (size &gt; 0) {</span>
<span class="line-removed">1870       *(intptr_t*)start = nextPtr();</span>
<span class="line-removed">1871       start += sizeof(intptr_t);</span>
<span class="line-removed">1872       size -= sizeof(intptr_t);</span>
<span class="line-removed">1873     }</span>
1874   }
<a name="152" id="anc152"></a>
1875 
<a name="153" id="anc153"></a><span class="line-modified">1876   bool reading() const { return true; }</span>
<span class="line-modified">1877 };</span>






1878 
<a name="154" id="anc154"></a><span class="line-modified">1879 // Return true if given address is in the misc data region</span>
<span class="line-modified">1880 bool MetaspaceShared::is_in_shared_region(const void* p, int idx) {</span>
<span class="line-modified">1881   return UseSharedSpaces &amp;&amp; FileMapInfo::current_info()-&gt;is_in_shared_region(p, idx);</span>











1882 }
1883 
<a name="155" id="anc155"></a><span class="line-modified">1884 bool MetaspaceShared::is_in_trampoline_frame(address addr) {</span>
<span class="line-modified">1885   if (UseSharedSpaces &amp;&amp; is_in_shared_region(addr, MetaspaceShared::mc)) {</span>
<span class="line-modified">1886     return true;</span>


















1887   }
<a name="156" id="anc156"></a><span class="line-modified">1888   return false;</span>










































































1889 }
1890 
<a name="157" id="anc157"></a><span class="line-modified">1891 // Map shared spaces at requested addresses and return if succeeded.</span>
<span class="line-modified">1892 bool MetaspaceShared::map_shared_spaces(FileMapInfo* mapinfo) {</span>
<span class="line-modified">1893   size_t image_alignment = mapinfo-&gt;alignment();</span>





1894 
<a name="158" id="anc158"></a><span class="line-modified">1895 #ifndef _WINDOWS</span>
<span class="line-modified">1896   // Map in the shared memory and then map the regions on top of it.</span>
<span class="line-modified">1897   // On Windows, don&#39;t map the memory here because it will cause the</span>
<span class="line-modified">1898   // mappings of the regions to fail.</span>
<span class="line-modified">1899   ReservedSpace shared_rs = mapinfo-&gt;reserve_shared_memory();</span>
<span class="line-modified">1900   if (!shared_rs.is_reserved()) return false;</span>
<span class="line-removed">1901 #endif</span>
1902 
<a name="159" id="anc159"></a><span class="line-modified">1903   assert(!DumpSharedSpaces, &quot;Should not be called with DumpSharedSpaces&quot;);</span>
<span class="line-modified">1904 </span>
<span class="line-modified">1905   char* ro_base = NULL; char* ro_top;</span>
<span class="line-modified">1906   char* rw_base = NULL; char* rw_top;</span>
<span class="line-modified">1907   char* mc_base = NULL; char* mc_top;</span>
<span class="line-modified">1908   char* md_base = NULL; char* md_top;</span>
<span class="line-modified">1909 </span>
<span class="line-modified">1910   // Map each shared region</span>
<span class="line-modified">1911   if ((mc_base = mapinfo-&gt;map_region(mc, &amp;mc_top)) != NULL &amp;&amp;</span>
<span class="line-modified">1912       (rw_base = mapinfo-&gt;map_region(rw, &amp;rw_top)) != NULL &amp;&amp;</span>
<span class="line-modified">1913       (ro_base = mapinfo-&gt;map_region(ro, &amp;ro_top)) != NULL &amp;&amp;</span>
<span class="line-modified">1914       (md_base = mapinfo-&gt;map_region(md, &amp;md_top)) != NULL &amp;&amp;</span>
<span class="line-modified">1915       (image_alignment == (size_t)os::vm_allocation_granularity()) &amp;&amp;</span>
<span class="line-modified">1916       mapinfo-&gt;validate_shared_path_table()) {</span>
<span class="line-modified">1917     // Success -- set up MetaspaceObj::_shared_metaspace_{base,top} for</span>
<span class="line-modified">1918     // fast checking in MetaspaceShared::is_in_shared_metaspace() and</span>
<span class="line-modified">1919     // MetaspaceObj::is_shared().</span>
<span class="line-modified">1920     //</span>
<span class="line-modified">1921     // We require that mc-&gt;rw-&gt;ro-&gt;md to be laid out consecutively, with no</span>
<span class="line-modified">1922     // gaps between them. That way, we can ensure that the OS won&#39;t be able to</span>
<span class="line-modified">1923     // allocate any new memory spaces inside _shared_metaspace_{base,top}, which</span>
<span class="line-modified">1924     // would mess up the simple comparision in MetaspaceShared::is_in_shared_metaspace().</span>
<span class="line-modified">1925     assert(mc_base &lt; ro_base &amp;&amp; mc_base &lt; rw_base &amp;&amp; mc_base &lt; md_base, &quot;must be&quot;);</span>
<span class="line-modified">1926     assert(md_top  &gt; ro_top  &amp;&amp; md_top  &gt; rw_top  &amp;&amp; md_top  &gt; mc_top , &quot;must be&quot;);</span>
<span class="line-modified">1927     assert(mc_top == rw_base, &quot;must be&quot;);</span>
<span class="line-modified">1928     assert(rw_top == ro_base, &quot;must be&quot;);</span>
<span class="line-modified">1929     assert(ro_top == md_base, &quot;must be&quot;);</span>
<span class="line-modified">1930 </span>
<span class="line-modified">1931     _core_spaces_size = mapinfo-&gt;core_spaces_size();</span>
<span class="line-modified">1932     MetaspaceObj::set_shared_metaspace_range((void*)mc_base, (void*)md_top);</span>
<span class="line-modified">1933     return true;</span>








1934   } else {
<a name="160" id="anc160"></a><span class="line-modified">1935     // If there was a failure in mapping any of the spaces, unmap the ones</span>
<span class="line-modified">1936     // that succeeded</span>
<span class="line-modified">1937     if (ro_base != NULL) mapinfo-&gt;unmap_region(ro);</span>
<span class="line-modified">1938     if (rw_base != NULL) mapinfo-&gt;unmap_region(rw);</span>
<span class="line-modified">1939     if (mc_base != NULL) mapinfo-&gt;unmap_region(mc);</span>
<span class="line-modified">1940     if (md_base != NULL) mapinfo-&gt;unmap_region(md);</span>
<span class="line-removed">1941 #ifndef _WINDOWS</span>
<span class="line-removed">1942     // Release the entire mapped region</span>
<span class="line-removed">1943     shared_rs.release();</span>
<span class="line-removed">1944 #endif</span>
<span class="line-removed">1945     // If -Xshare:on is specified, print out the error message and exit VM,</span>
<span class="line-removed">1946     // otherwise, set UseSharedSpaces to false and continue.</span>
<span class="line-removed">1947     if (RequireSharedSpaces || PrintSharedArchiveAndExit) {</span>
<span class="line-removed">1948       vm_exit_during_initialization(&quot;Unable to use shared archive.&quot;, &quot;Failed map_region for using -Xshare:on.&quot;);</span>
1949     } else {
<a name="161" id="anc161"></a><span class="line-modified">1950       FLAG_SET_DEFAULT(UseSharedSpaces, false);</span>

1951     }
<a name="162" id="anc162"></a><span class="line-modified">1952     return false;</span>











































































1953   }
1954 }
1955 
1956 // Read the miscellaneous data from the shared file, and
1957 // serialize it out to its various destinations.
1958 
1959 void MetaspaceShared::initialize_shared_spaces() {
<a name="163" id="anc163"></a><span class="line-modified">1960   FileMapInfo *mapinfo = FileMapInfo::current_info();</span>
<span class="line-modified">1961   _cds_i2i_entry_code_buffers = mapinfo-&gt;cds_i2i_entry_code_buffers();</span>
<span class="line-modified">1962   _cds_i2i_entry_code_buffers_size = mapinfo-&gt;cds_i2i_entry_code_buffers_size();</span>
<span class="line-modified">1963   // _core_spaces_size is loaded from the shared archive immediatelly after mapping</span>
<span class="line-removed">1964   assert(_core_spaces_size == mapinfo-&gt;core_spaces_size(), &quot;sanity&quot;);</span>
<span class="line-removed">1965   char* buffer = mapinfo-&gt;misc_data_patching_start();</span>
1966   clone_cpp_vtables((intptr_t*)buffer);
1967 
<a name="164" id="anc164"></a><span class="line-removed">1968   // The rest of the data is now stored in the RW region</span>
<span class="line-removed">1969   buffer = mapinfo-&gt;read_only_tables_start();</span>
<span class="line-removed">1970 </span>
1971   // Verify various attributes of the archive, plus initialize the
1972   // shared string/symbol tables
<a name="165" id="anc165"></a>
1973   intptr_t* array = (intptr_t*)buffer;
1974   ReadClosure rc(&amp;array);
1975   serialize(&amp;rc);
1976 
1977   // Initialize the run-time symbol table.
1978   SymbolTable::create_table();
1979 
<a name="166" id="anc166"></a><span class="line-modified">1980   mapinfo-&gt;patch_archived_heap_embedded_pointers();</span>
1981 
1982   // Close the mapinfo file
<a name="167" id="anc167"></a><span class="line-modified">1983   mapinfo-&gt;close();</span>









1984 
1985   if (PrintSharedArchiveAndExit) {
1986     if (PrintSharedDictionary) {
1987       tty-&gt;print_cr(&quot;\nShared classes:\n&quot;);
1988       SystemDictionaryShared::print_on(tty);
1989     }
<a name="168" id="anc168"></a><span class="line-modified">1990     if (_archive_loading_failed) {</span>
1991       tty-&gt;print_cr(&quot;archive is invalid&quot;);
1992       vm_exit(1);
1993     } else {
1994       tty-&gt;print_cr(&quot;archive is valid&quot;);
1995       vm_exit(0);
1996     }
1997   }
1998 }
1999 
2000 // JVM/TI RedefineClasses() support:
2001 bool MetaspaceShared::remap_shared_readonly_as_readwrite() {
2002   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
2003 
2004   if (UseSharedSpaces) {
2005     // remap the shared readonly space to shared readwrite, private
2006     FileMapInfo* mapinfo = FileMapInfo::current_info();
2007     if (!mapinfo-&gt;remap_shared_readonly_as_readwrite()) {
2008       return false;
2009     }
<a name="169" id="anc169"></a>





2010     _remapped_readwrite = true;
2011   }
2012   return true;
2013 }
2014 
2015 void MetaspaceShared::report_out_of_space(const char* name, size_t needed_bytes) {
2016   // This is highly unlikely to happen on 64-bits because we have reserved a 4GB space.
2017   // On 32-bit we reserve only 256MB so you could run out of space with 100,000 classes
2018   // or so.
2019   _mc_region.print_out_of_space_msg(name, needed_bytes);
2020   _rw_region.print_out_of_space_msg(name, needed_bytes);
2021   _ro_region.print_out_of_space_msg(name, needed_bytes);
<a name="170" id="anc170"></a><span class="line-removed">2022   _md_region.print_out_of_space_msg(name, needed_bytes);</span>
2023 
2024   vm_exit_during_initialization(err_msg(&quot;Unable to allocate from &#39;%s&#39; region&quot;, name),
2025                                 &quot;Please reduce the number of shared classes.&quot;);
2026 }
<a name="171" id="anc171"></a>






<a name="172" id="anc172"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="172" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/memory/allocation.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_MEMORY_ALLOCATION_HPP
 26 #define SHARE_MEMORY_ALLOCATION_HPP
 27 
 28 #include &quot;utilities/globalDefinitions.hpp&quot;
 29 #include &quot;utilities/macros.hpp&quot;
 30 
 31 #include &lt;new&gt;
 32 
 33 class outputStream;
 34 class Thread;
 35 
 36 class AllocFailStrategy {
 37 public:
 38   enum AllocFailEnum { EXIT_OOM, RETURN_NULL };
 39 };
 40 typedef AllocFailStrategy::AllocFailEnum AllocFailType;
 41 
 42 // The virtual machine must never call one of the implicitly declared
 43 // global allocation or deletion functions.  (Such calls may result in
 44 // link-time or run-time errors.)  For convenience and documentation of
 45 // intended use, classes in the virtual machine may be derived from one
 46 // of the following allocation classes, some of which define allocation
 47 // and deletion functions.
 48 // Note: std::malloc and std::free should never called directly.
 49 
 50 //
 51 // For objects allocated in the resource area (see resourceArea.hpp).
 52 // - ResourceObj
 53 //
 54 // For objects allocated in the C-heap (managed by: free &amp; malloc and tracked with NMT)
 55 // - CHeapObj
 56 //
 57 // For objects allocated on the stack.
 58 // - StackObj
 59 //
 60 // For classes used as name spaces.
 61 // - AllStatic
 62 //
 63 // For classes in Metaspace (class data)
 64 // - MetaspaceObj
 65 //
 66 // The printable subclasses are used for debugging and define virtual
 67 // member functions for printing. Classes that avoid allocating the
 68 // vtbl entries in the objects should therefore not be the printable
 69 // subclasses.
 70 //
 71 // The following macros and function should be used to allocate memory
 72 // directly in the resource area or in the C-heap, The _OBJ variants
 73 // of the NEW/FREE_C_HEAP macros are used for alloc/dealloc simple
 74 // objects which are not inherited from CHeapObj, note constructor and
 75 // destructor are not called. The preferable way to allocate objects
 76 // is using the new operator.
 77 //
 78 // WARNING: The array variant must only be used for a homogenous array
 79 // where all objects are of the exact type specified. If subtypes are
 80 // stored in the array then must pay attention to calling destructors
 81 // at needed.
 82 //
 83 // NEW_RESOURCE_ARRAY*
 84 // REALLOC_RESOURCE_ARRAY*
 85 // FREE_RESOURCE_ARRAY*
 86 // NEW_RESOURCE_OBJ*
 87 // NEW_C_HEAP_ARRAY*
 88 // REALLOC_C_HEAP_ARRAY*
 89 // FREE_C_HEAP_ARRAY*
 90 // NEW_C_HEAP_OBJ*
 91 // FREE_C_HEAP_OBJ
 92 //
 93 // char* AllocateHeap(size_t size, MEMFLAGS flags, const NativeCallStack&amp; stack, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);
 94 // char* AllocateHeap(size_t size, MEMFLAGS flags, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);
 95 // char* ReallocateHeap(char *old, size_t size, MEMFLAGS flag, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);
 96 // void FreeHeap(void* p);
 97 //
 98 // In non product mode we introduce a super class for all allocation classes
 99 // that supports printing.
100 // We avoid the superclass in product mode to save space.
101 
102 #ifdef PRODUCT
103 #define ALLOCATION_SUPER_CLASS_SPEC
104 #else
105 #define ALLOCATION_SUPER_CLASS_SPEC : public AllocatedObj
106 class AllocatedObj {
107  public:
108   // Printing support
109   void print() const;
110   void print_value() const;
111 
112   virtual void print_on(outputStream* st) const;
113   virtual void print_value_on(outputStream* st) const;
114 };
115 #endif
116 
117 #define MEMORY_TYPES_DO(f) \
118   /* Memory type by sub systems. It occupies lower byte. */  \
119   f(mtJavaHeap,      &quot;Java Heap&quot;)   /* Java heap                                 */ \
120   f(mtClass,         &quot;Class&quot;)       /* Java classes                              */ \
121   f(mtThread,        &quot;Thread&quot;)      /* thread objects                            */ \
122   f(mtThreadStack,   &quot;Thread Stack&quot;)                                                \
123   f(mtCode,          &quot;Code&quot;)        /* generated code                            */ \
124   f(mtGC,            &quot;GC&quot;)                                                          \
125   f(mtCompiler,      &quot;Compiler&quot;)                                                    \
126   f(mtJVMCI,         &quot;JVMCI&quot;)                                                       \
127   f(mtInternal,      &quot;Internal&quot;)    /* memory used by VM, but does not belong to */ \
128                                     /* any of above categories, and not used by  */ \
129                                     /* NMT                                       */ \
130   f(mtOther,         &quot;Other&quot;)       /* memory not used by VM                     */ \
131   f(mtSymbol,        &quot;Symbol&quot;)                                                      \
132   f(mtNMT,           &quot;Native Memory Tracking&quot;)  /* memory used by NMT            */ \
133   f(mtClassShared,   &quot;Shared class space&quot;)      /* class data sharing            */ \
134   f(mtChunk,         &quot;Arena Chunk&quot;) /* chunk that holds content of arenas        */ \
135   f(mtTest,          &quot;Test&quot;)        /* Test type for verifying NMT               */ \
136   f(mtTracing,       &quot;Tracing&quot;)                                                     \
137   f(mtLogging,       &quot;Logging&quot;)                                                     \
138   f(mtStatistics,    &quot;Statistics&quot;)                                                  \
139   f(mtArguments,     &quot;Arguments&quot;)                                                   \
140   f(mtModule,        &quot;Module&quot;)                                                      \
141   f(mtSafepoint,     &quot;Safepoint&quot;)                                                   \
142   f(mtSynchronizer,  &quot;Synchronization&quot;)                                             \
143   f(mtNone,          &quot;Unknown&quot;)                                                     \
144   //end
145 
146 #define MEMORY_TYPE_DECLARE_ENUM(type, human_readable) \
147   type,
148 
149 /*
150  * Memory types
151  */
152 enum MemoryType {
153   MEMORY_TYPES_DO(MEMORY_TYPE_DECLARE_ENUM)
154   mt_number_of_types   // number of memory types (mtDontTrack
155                        // is not included as validate type)
156 };
157 
158 typedef MemoryType MEMFLAGS;
159 
160 
161 #if INCLUDE_NMT
162 
163 extern bool NMT_track_callsite;
164 
165 #else
166 
167 const bool NMT_track_callsite = false;
168 
169 #endif // INCLUDE_NMT
170 
171 class NativeCallStack;
172 
173 
174 char* AllocateHeap(size_t size,
175                    MEMFLAGS flags,
176                    const NativeCallStack&amp; stack,
177                    AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);
178 char* AllocateHeap(size_t size,
179                    MEMFLAGS flags,
180                    AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);
181 
182 char* ReallocateHeap(char *old,
183                      size_t size,
184                      MEMFLAGS flag,
185                      AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);
186 
187 // handles NULL pointers
188 void FreeHeap(void* p);
189 
190 template &lt;MEMFLAGS F&gt; class CHeapObj ALLOCATION_SUPER_CLASS_SPEC {
191  public:
192   ALWAYSINLINE void* operator new(size_t size) throw() {
193     return (void*)AllocateHeap(size, F);
194   }
195 
196   ALWAYSINLINE void* operator new(size_t size,
197                                   const NativeCallStack&amp; stack) throw() {
198     return (void*)AllocateHeap(size, F, stack);
199   }
200 
201   ALWAYSINLINE void* operator new(size_t size, const std::nothrow_t&amp;,
202                                   const NativeCallStack&amp; stack) throw() {
203     return (void*)AllocateHeap(size, F, stack, AllocFailStrategy::RETURN_NULL);
204   }
205 
206   ALWAYSINLINE void* operator new(size_t size, const std::nothrow_t&amp;) throw() {
207     return (void*)AllocateHeap(size, F, AllocFailStrategy::RETURN_NULL);
208   }
209 
210   ALWAYSINLINE void* operator new[](size_t size) throw() {
211     return (void*)AllocateHeap(size, F);
212   }
213 
214   ALWAYSINLINE void* operator new[](size_t size,
215                                   const NativeCallStack&amp; stack) throw() {
216     return (void*)AllocateHeap(size, F, stack);
217   }
218 
219   ALWAYSINLINE void* operator new[](size_t size, const std::nothrow_t&amp;,
220                                     const NativeCallStack&amp; stack) throw() {
221     return (void*)AllocateHeap(size, F, stack, AllocFailStrategy::RETURN_NULL);
222   }
223 
224   ALWAYSINLINE void* operator new[](size_t size, const std::nothrow_t&amp;) throw() {
225     return (void*)AllocateHeap(size, F, AllocFailStrategy::RETURN_NULL);
226   }
227 
228   void  operator delete(void* p)     { FreeHeap(p); }
229   void  operator delete [] (void* p) { FreeHeap(p); }
230 };
231 
232 // Base class for objects allocated on the stack only.
233 // Calling new or delete will result in fatal error.
234 
235 class StackObj ALLOCATION_SUPER_CLASS_SPEC {
236  private:
237   void* operator new(size_t size) throw();
238   void* operator new [](size_t size) throw();
239   void  operator delete(void* p);
240   void  operator delete [](void* p);
241 };
242 
243 // Base class for objects stored in Metaspace.
244 // Calling delete will result in fatal error.
245 //
246 // Do not inherit from something with a vptr because this class does
247 // not introduce one.  This class is used to allocate both shared read-only
248 // and shared read-write classes.
249 //
250 
251 class ClassLoaderData;
252 class MetaspaceClosure;
253 
254 class MetaspaceObj {
255   friend class VMStructs;
256   // When CDS is enabled, all shared metaspace objects are mapped
257   // into a single contiguous memory block, so we can use these
258   // two pointers to quickly determine if something is in the
259   // shared metaspace.
260   // When CDS is not enabled, both pointers are set to NULL.
261   static void* _shared_metaspace_base;  // (inclusive) low address
262   static void* _shared_metaspace_top;   // (exclusive) high address
263 
264  public:
265 
266   // Returns true if the pointer points to a valid MetaspaceObj. A valid
267   // MetaspaceObj is MetaWord-aligned and contained within either
268   // non-shared or shared metaspace.
269   static bool is_valid(const MetaspaceObj* p);
270 
271   static bool is_shared(const MetaspaceObj* p) {
272     // If no shared metaspace regions are mapped, _shared_metaspace_{base,top} will
273     // both be NULL and all values of p will be rejected quickly.
274     return (((void*)p) &lt; _shared_metaspace_top &amp;&amp;
275             ((void*)p) &gt;= _shared_metaspace_base);
276   }
277   bool is_shared() const { return MetaspaceObj::is_shared(this); }
278 
279   void print_address_on(outputStream* st) const;  // nonvirtual address printing
280 
281   static void set_shared_metaspace_range(void* base, void* top) {
282     _shared_metaspace_base = base;
283     _shared_metaspace_top = top;
284   }
285 
286   static void* shared_metaspace_base() { return _shared_metaspace_base; }
287   static void* shared_metaspace_top()  { return _shared_metaspace_top;  }
288 
289 #define METASPACE_OBJ_TYPES_DO(f) \
290   f(Class) \
291   f(Symbol) \
292   f(TypeArrayU1) \
293   f(TypeArrayU2) \
294   f(TypeArrayU4) \
295   f(TypeArrayU8) \
296   f(TypeArrayOther) \
297   f(Method) \
298   f(ConstMethod) \
299   f(MethodData) \
300   f(ConstantPool) \
301   f(ConstantPoolCache) \
302   f(Annotations) \
303   f(MethodCounters) \
304   f(RecordComponent)
305 
306 #define METASPACE_OBJ_TYPE_DECLARE(name) name ## Type,
307 #define METASPACE_OBJ_TYPE_NAME_CASE(name) case name ## Type: return #name;
308 
309   enum Type {
310     // Types are MetaspaceObj::ClassType, MetaspaceObj::SymbolType, etc
311     METASPACE_OBJ_TYPES_DO(METASPACE_OBJ_TYPE_DECLARE)
312     _number_of_types
313   };
314 
315   static const char * type_name(Type type) {
316     switch(type) {
317     METASPACE_OBJ_TYPES_DO(METASPACE_OBJ_TYPE_NAME_CASE)
318     default:
319       ShouldNotReachHere();
320       return NULL;
321     }
322   }
323 
324   static MetaspaceObj::Type array_type(size_t elem_size) {
325     switch (elem_size) {
326     case 1: return TypeArrayU1Type;
327     case 2: return TypeArrayU2Type;
328     case 4: return TypeArrayU4Type;
329     case 8: return TypeArrayU8Type;
330     default:
331       return TypeArrayOtherType;
332     }
333   }
334 
335   void* operator new(size_t size, ClassLoaderData* loader_data,
336                      size_t word_size,
337                      Type type, Thread* thread) throw();
338                      // can&#39;t use TRAPS from this header file.
339   void operator delete(void* p) { ShouldNotCallThis(); }
340 
341   // Declare a *static* method with the same signature in any subclass of MetaspaceObj
342   // that should be read-only by default. See symbol.hpp for an example. This function
343   // is used by the templates in metaspaceClosure.hpp
344   static bool is_read_only_by_default() { return false; }
345 };
346 
347 // Base class for classes that constitute name spaces.
348 
349 class Arena;
350 
351 class AllStatic {
352  public:
353   AllStatic()  { ShouldNotCallThis(); }
354   ~AllStatic() { ShouldNotCallThis(); }
355 };
356 
357 
358 extern char* resource_allocate_bytes(size_t size,
359     AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);
360 extern char* resource_allocate_bytes(Thread* thread, size_t size,
361     AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);
362 extern char* resource_reallocate_bytes( char *old, size_t old_size, size_t new_size,
363     AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);
364 extern void resource_free_bytes( char *old, size_t size );
365 
366 //----------------------------------------------------------------------
367 // Base class for objects allocated in the resource area per default.
368 // Optionally, objects may be allocated on the C heap with
369 // new(ResourceObj::C_HEAP) Foo(...) or in an Arena with new (&amp;arena)
370 // ResourceObj&#39;s can be allocated within other objects, but don&#39;t use
371 // new or delete (allocation_type is unknown).  If new is used to allocate,
372 // use delete to deallocate.
373 class ResourceObj ALLOCATION_SUPER_CLASS_SPEC {
374  public:
375   enum allocation_type { STACK_OR_EMBEDDED = 0, RESOURCE_AREA, C_HEAP, ARENA, allocation_mask = 0x3 };
376   static void set_allocation_type(address res, allocation_type type) NOT_DEBUG_RETURN;
377 #ifdef ASSERT
378  private:
379   // When this object is allocated on stack the new() operator is not
380   // called but garbage on stack may look like a valid allocation_type.
381   // Store negated &#39;this&#39; pointer when new() is called to distinguish cases.
382   // Use second array&#39;s element for verification value to distinguish garbage.
383   uintptr_t _allocation_t[2];
384   bool is_type_set() const;
385   void initialize_allocation_info();
386  public:
387   allocation_type get_allocation_type() const;
388   bool allocated_on_stack()    const { return get_allocation_type() == STACK_OR_EMBEDDED; }
389   bool allocated_on_res_area() const { return get_allocation_type() == RESOURCE_AREA; }
390   bool allocated_on_C_heap()   const { return get_allocation_type() == C_HEAP; }
391   bool allocated_on_arena()    const { return get_allocation_type() == ARENA; }
392 protected:
393   ResourceObj(); // default constructor
394   ResourceObj(const ResourceObj&amp; r); // default copy constructor
395   ResourceObj&amp; operator=(const ResourceObj&amp; r); // default copy assignment
396   ~ResourceObj();
397 #endif // ASSERT
398 
399  public:
400   void* operator new(size_t size, allocation_type type, MEMFLAGS flags) throw();
401   void* operator new [](size_t size, allocation_type type, MEMFLAGS flags) throw();
402   void* operator new(size_t size, const std::nothrow_t&amp;  nothrow_constant,
403       allocation_type type, MEMFLAGS flags) throw();
404   void* operator new [](size_t size, const std::nothrow_t&amp;  nothrow_constant,
405       allocation_type type, MEMFLAGS flags) throw();
406 
407   void* operator new(size_t size, Arena *arena) throw();
408 
409   void* operator new [](size_t size, Arena *arena) throw();
410 
411   void* operator new(size_t size) throw() {
412       address res = (address)resource_allocate_bytes(size);
413       DEBUG_ONLY(set_allocation_type(res, RESOURCE_AREA);)
414       return res;
415   }
416 
417   void* operator new(size_t size, const std::nothrow_t&amp; nothrow_constant) throw() {
418       address res = (address)resource_allocate_bytes(size, AllocFailStrategy::RETURN_NULL);
419       DEBUG_ONLY(if (res != NULL) set_allocation_type(res, RESOURCE_AREA);)
420       return res;
421   }
422 
423   void* operator new [](size_t size) throw() {
424       address res = (address)resource_allocate_bytes(size);
425       DEBUG_ONLY(set_allocation_type(res, RESOURCE_AREA);)
426       return res;
427   }
428 
429   void* operator new [](size_t size, const std::nothrow_t&amp; nothrow_constant) throw() {
430       address res = (address)resource_allocate_bytes(size, AllocFailStrategy::RETURN_NULL);
431       DEBUG_ONLY(if (res != NULL) set_allocation_type(res, RESOURCE_AREA);)
432       return res;
433   }
434 
435   void  operator delete(void* p);
436   void  operator delete [](void* p);
437 };
438 
439 // One of the following macros must be used when allocating an array
440 // or object to determine whether it should reside in the C heap on in
441 // the resource area.
442 
443 #define NEW_RESOURCE_ARRAY(type, size)\
444   (type*) resource_allocate_bytes((size) * sizeof(type))
445 
446 #define NEW_RESOURCE_ARRAY_RETURN_NULL(type, size)\
447   (type*) resource_allocate_bytes((size) * sizeof(type), AllocFailStrategy::RETURN_NULL)
448 
449 #define NEW_RESOURCE_ARRAY_IN_THREAD(thread, type, size)\
450   (type*) resource_allocate_bytes(thread, (size) * sizeof(type))
451 
452 #define NEW_RESOURCE_ARRAY_IN_THREAD_RETURN_NULL(thread, type, size)\
453   (type*) resource_allocate_bytes(thread, (size) * sizeof(type), AllocFailStrategy::RETURN_NULL)
454 
455 #define REALLOC_RESOURCE_ARRAY(type, old, old_size, new_size)\
456   (type*) resource_reallocate_bytes((char*)(old), (old_size) * sizeof(type), (new_size) * sizeof(type))
457 
458 #define REALLOC_RESOURCE_ARRAY_RETURN_NULL(type, old, old_size, new_size)\
459   (type*) resource_reallocate_bytes((char*)(old), (old_size) * sizeof(type),\
460                                     (new_size) * sizeof(type), AllocFailStrategy::RETURN_NULL)
461 
462 #define FREE_RESOURCE_ARRAY(type, old, size)\
463   resource_free_bytes((char*)(old), (size) * sizeof(type))
464 
465 #define FREE_FAST(old)\
466     /* nop */
467 
468 #define NEW_RESOURCE_OBJ(type)\
469   NEW_RESOURCE_ARRAY(type, 1)
470 
471 #define NEW_RESOURCE_OBJ_RETURN_NULL(type)\
472   NEW_RESOURCE_ARRAY_RETURN_NULL(type, 1)
473 
474 #define NEW_C_HEAP_ARRAY3(type, size, memflags, pc, allocfail)\
475   (type*) AllocateHeap((size) * sizeof(type), memflags, pc, allocfail)
476 
477 #define NEW_C_HEAP_ARRAY2(type, size, memflags, pc)\
478   (type*) (AllocateHeap((size) * sizeof(type), memflags, pc))
479 
480 #define NEW_C_HEAP_ARRAY(type, size, memflags)\
481   (type*) (AllocateHeap((size) * sizeof(type), memflags))
482 
483 #define NEW_C_HEAP_ARRAY2_RETURN_NULL(type, size, memflags, pc)\
484   NEW_C_HEAP_ARRAY3(type, (size), memflags, pc, AllocFailStrategy::RETURN_NULL)
485 
486 #define NEW_C_HEAP_ARRAY_RETURN_NULL(type, size, memflags)\
487   NEW_C_HEAP_ARRAY3(type, (size), memflags, CURRENT_PC, AllocFailStrategy::RETURN_NULL)
488 
489 #define REALLOC_C_HEAP_ARRAY(type, old, size, memflags)\
490   (type*) (ReallocateHeap((char*)(old), (size) * sizeof(type), memflags))
491 
492 #define REALLOC_C_HEAP_ARRAY_RETURN_NULL(type, old, size, memflags)\
493   (type*) (ReallocateHeap((char*)(old), (size) * sizeof(type), memflags, AllocFailStrategy::RETURN_NULL))
494 
495 #define FREE_C_HEAP_ARRAY(type, old) \
496   FreeHeap((char*)(old))
497 
498 // allocate type in heap without calling ctor
499 #define NEW_C_HEAP_OBJ(type, memflags)\
500   NEW_C_HEAP_ARRAY(type, 1, memflags)
501 
502 #define NEW_C_HEAP_OBJ_RETURN_NULL(type, memflags)\
503   NEW_C_HEAP_ARRAY_RETURN_NULL(type, 1, memflags)
504 
505 // deallocate obj of type in heap without calling dtor
506 #define FREE_C_HEAP_OBJ(objname)\
507   FreeHeap((char*)objname);
508 
509 
510 //------------------------------ReallocMark---------------------------------
511 // Code which uses REALLOC_RESOURCE_ARRAY should check an associated
512 // ReallocMark, which is declared in the same scope as the reallocated
513 // pointer.  Any operation that could __potentially__ cause a reallocation
514 // should check the ReallocMark.
515 class ReallocMark: public StackObj {
516 protected:
517   NOT_PRODUCT(int _nesting;)
518 
519 public:
520   ReallocMark()   PRODUCT_RETURN;
521   void check()    PRODUCT_RETURN;
522 };
523 
524 // Helper class to allocate arrays that may become large.
525 // Uses the OS malloc for allocations smaller than ArrayAllocatorMallocLimit
526 // and uses mapped memory for larger allocations.
527 // Most OS mallocs do something similar but Solaris malloc does not revert
528 // to mapped memory for large allocations. By default ArrayAllocatorMallocLimit
529 // is set so that we always use malloc except for Solaris where we set the
530 // limit to get mapped memory.
531 template &lt;class E&gt;
532 class ArrayAllocator : public AllStatic {
533  private:
534   static bool should_use_malloc(size_t length);
535 
536   static E* allocate_malloc(size_t length, MEMFLAGS flags);
537   static E* allocate_mmap(size_t length, MEMFLAGS flags);
538 
539   static void free_malloc(E* addr, size_t length);
540   static void free_mmap(E* addr, size_t length);
541 
542  public:
543   static E* allocate(size_t length, MEMFLAGS flags);
544   static E* reallocate(E* old_addr, size_t old_length, size_t new_length, MEMFLAGS flags);
545   static void free(E* addr, size_t length);
546 };
547 
548 // Uses mmaped memory for all allocations. All allocations are initially
549 // zero-filled. No pre-touching.
550 template &lt;class E&gt;
551 class MmapArrayAllocator : public AllStatic {
552  private:
553   static size_t size_for(size_t length);
554 
555  public:
556   static E* allocate_or_null(size_t length, MEMFLAGS flags);
557   static E* allocate(size_t length, MEMFLAGS flags);
558   static void free(E* addr, size_t length);
559 };
560 
561 // Uses malloc:ed memory for all allocations.
562 template &lt;class E&gt;
563 class MallocArrayAllocator : public AllStatic {
564  public:
565   static size_t size_for(size_t length);
566 
567   static E* allocate(size_t length, MEMFLAGS flags);
568   static void free(E* addr);
569 };
570 
571 #endif // SHARE_MEMORY_ALLOCATION_HPP
    </pre>
  </body>
</html>
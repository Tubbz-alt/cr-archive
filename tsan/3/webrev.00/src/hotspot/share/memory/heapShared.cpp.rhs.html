<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/memory/heapShared.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/javaClasses.inline.hpp&quot;
  27 #include &quot;classfile/stringTable.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added">  29 #include &quot;classfile/systemDictionaryShared.hpp&quot;</span>
  30 #include &quot;classfile/vmSymbols.hpp&quot;
  31 #include &quot;logging/log.hpp&quot;
  32 #include &quot;logging/logMessage.hpp&quot;
  33 #include &quot;logging/logStream.hpp&quot;
<a name="3" id="anc3"></a><span class="line-added">  34 #include &quot;memory/archiveUtils.hpp&quot;</span>
  35 #include &quot;memory/filemap.hpp&quot;
  36 #include &quot;memory/heapShared.inline.hpp&quot;
  37 #include &quot;memory/iterator.inline.hpp&quot;
  38 #include &quot;memory/metadataFactory.hpp&quot;
  39 #include &quot;memory/metaspaceClosure.hpp&quot;
<a name="4" id="anc4"></a><span class="line-added">  40 #include &quot;memory/metaspaceShared.hpp&quot;</span>
  41 #include &quot;memory/resourceArea.hpp&quot;
<a name="5" id="anc5"></a><span class="line-added">  42 #include &quot;memory/universe.hpp&quot;</span>
  43 #include &quot;oops/compressedOops.inline.hpp&quot;
<a name="6" id="anc6"></a><span class="line-modified">  44 #include &quot;oops/fieldStreams.inline.hpp&quot;</span>
  45 #include &quot;oops/oop.inline.hpp&quot;
  46 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  47 #include &quot;runtime/safepointVerifiers.hpp&quot;
  48 #include &quot;utilities/bitMap.inline.hpp&quot;
  49 #if INCLUDE_G1GC
  50 #include &quot;gc/g1/g1CollectedHeap.hpp&quot;
  51 #endif
  52 
  53 #if INCLUDE_CDS_JAVA_HEAP
  54 
  55 bool HeapShared::_closed_archive_heap_region_mapped = false;
  56 bool HeapShared::_open_archive_heap_region_mapped = false;
  57 bool HeapShared::_archive_heap_region_fixed = false;
  58 
  59 address   HeapShared::_narrow_oop_base;
  60 int       HeapShared::_narrow_oop_shift;
  61 
  62 //
  63 // If you add new entries to the following tables, you should know what you&#39;re doing!
  64 //
  65 
  66 // Entry fields for shareable subgraphs archived in the closed archive heap
  67 // region. Warning: Objects in the subgraphs should not have reference fields
  68 // assigned at runtime.
  69 static ArchivableStaticFieldInfo closed_archive_subgraph_entry_fields[] = {
  70   {&quot;java/lang/Integer$IntegerCache&quot;,           &quot;archivedCache&quot;},
  71   {&quot;java/lang/Long$LongCache&quot;,                 &quot;archivedCache&quot;},
  72   {&quot;java/lang/Byte$ByteCache&quot;,                 &quot;archivedCache&quot;},
  73   {&quot;java/lang/Short$ShortCache&quot;,               &quot;archivedCache&quot;},
  74   {&quot;java/lang/Character$CharacterCache&quot;,       &quot;archivedCache&quot;},
<a name="7" id="anc7"></a><span class="line-added">  75   {&quot;java/util/jar/Attributes$Name&quot;,            &quot;KNOWN_NAMES&quot;},</span>
<span class="line-added">  76   {&quot;sun/util/locale/BaseLocale&quot;,               &quot;constantBaseLocales&quot;},</span>
  77 };
  78 // Entry fields for subgraphs archived in the open archive heap region.
  79 static ArchivableStaticFieldInfo open_archive_subgraph_entry_fields[] = {
  80   {&quot;jdk/internal/module/ArchivedModuleGraph&quot;,  &quot;archivedModuleGraph&quot;},
<a name="8" id="anc8"></a><span class="line-modified">  81   {&quot;java/util/ImmutableCollections&quot;,           &quot;archivedObjects&quot;},</span>


  82   {&quot;java/lang/module/Configuration&quot;,           &quot;EMPTY_CONFIGURATION&quot;},
<a name="9" id="anc9"></a><span class="line-added">  83   {&quot;jdk/internal/math/FDBigInteger&quot;,           &quot;archivedCaches&quot;},</span>
  84 };
  85 
  86 const static int num_closed_archive_subgraph_entry_fields =
  87   sizeof(closed_archive_subgraph_entry_fields) / sizeof(ArchivableStaticFieldInfo);
  88 const static int num_open_archive_subgraph_entry_fields =
  89   sizeof(open_archive_subgraph_entry_fields) / sizeof(ArchivableStaticFieldInfo);
  90 
  91 ////////////////////////////////////////////////////////////////
  92 //
  93 // Java heap object archiving support
  94 //
  95 ////////////////////////////////////////////////////////////////
  96 void HeapShared::fixup_mapped_heap_regions() {
  97   FileMapInfo *mapinfo = FileMapInfo::current_info();
  98   mapinfo-&gt;fixup_mapped_heap_regions();
  99   set_archive_heap_region_fixed();
 100 }
 101 
 102 unsigned HeapShared::oop_hash(oop const&amp; p) {
<a name="10" id="anc10"></a><span class="line-modified"> 103   assert(!p-&gt;mark().has_bias_pattern(),</span>
 104          &quot;this object should never have been locked&quot;);  // so identity_hash won&#39;t safepoin
 105   unsigned hash = (unsigned)p-&gt;identity_hash();
 106   return hash;
 107 }
 108 
 109 HeapShared::ArchivedObjectCache* HeapShared::_archived_object_cache = NULL;
 110 oop HeapShared::find_archived_heap_object(oop obj) {
 111   assert(DumpSharedSpaces, &quot;dump-time only&quot;);
 112   ArchivedObjectCache* cache = archived_object_cache();
 113   oop* p = cache-&gt;get(obj);
 114   if (p != NULL) {
 115     return *p;
 116   } else {
 117     return NULL;
 118   }
 119 }
 120 
 121 oop HeapShared::archive_heap_object(oop obj, Thread* THREAD) {
 122   assert(DumpSharedSpaces, &quot;dump-time only&quot;);
 123 
 124   oop ao = find_archived_heap_object(obj);
 125   if (ao != NULL) {
 126     // already archived
 127     return ao;
 128   }
 129 
 130   int len = obj-&gt;size();
 131   if (G1CollectedHeap::heap()-&gt;is_archive_alloc_too_large(len)) {
 132     log_debug(cds, heap)(&quot;Cannot archive, object (&quot; PTR_FORMAT &quot;) is too large: &quot; SIZE_FORMAT,
 133                          p2i(obj), (size_t)obj-&gt;size());
 134     return NULL;
 135   }
 136 
 137   // Pre-compute object identity hash at CDS dump time.
 138   obj-&gt;identity_hash();
 139 
 140   oop archived_oop = (oop)G1CollectedHeap::heap()-&gt;archive_mem_allocate(len);
 141   if (archived_oop != NULL) {
<a name="11" id="anc11"></a><span class="line-modified"> 142     Copy::aligned_disjoint_words(cast_from_oop&lt;HeapWord*&gt;(obj), cast_from_oop&lt;HeapWord*&gt;(archived_oop), len);</span>
 143     MetaspaceShared::relocate_klass_ptr(archived_oop);
 144     ArchivedObjectCache* cache = archived_object_cache();
 145     cache-&gt;put(obj, archived_oop);
 146     log_debug(cds, heap)(&quot;Archived heap object &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
 147                          p2i(obj), p2i(archived_oop));
 148   } else {
 149     log_error(cds, heap)(
 150       &quot;Cannot allocate space for object &quot; PTR_FORMAT &quot; in archived heap region&quot;,
 151       p2i(obj));
 152     vm_exit(1);
 153   }
 154   return archived_oop;
 155 }
 156 
 157 oop HeapShared::materialize_archived_object(narrowOop v) {
 158   assert(archive_heap_region_fixed(),
 159          &quot;must be called after archive heap regions are fixed&quot;);
 160   if (!CompressedOops::is_null(v)) {
 161     oop obj = HeapShared::decode_from_archive(v);
 162     return G1CollectedHeap::heap()-&gt;materialize_archived_object(obj);
 163   }
 164   return NULL;
 165 }
 166 
 167 void HeapShared::archive_klass_objects(Thread* THREAD) {
 168   GrowableArray&lt;Klass*&gt;* klasses = MetaspaceShared::collected_klasses();
 169   assert(klasses != NULL, &quot;sanity&quot;);
 170   for (int i = 0; i &lt; klasses-&gt;length(); i++) {
 171     Klass* k = klasses-&gt;at(i);
 172 
 173     // archive mirror object
 174     java_lang_Class::archive_mirror(k, CHECK);
 175 
 176     // archive the resolved_referenes array
 177     if (k-&gt;is_instance_klass()) {
 178       InstanceKlass* ik = InstanceKlass::cast(k);
 179       ik-&gt;constants()-&gt;archive_resolved_references(THREAD);
 180     }
 181   }
 182 }
 183 
 184 void HeapShared::archive_java_heap_objects(GrowableArray&lt;MemRegion&gt; *closed,
 185                                            GrowableArray&lt;MemRegion&gt; *open) {
 186   if (!is_heap_object_archiving_allowed()) {
<a name="12" id="anc12"></a><span class="line-modified"> 187     log_info(cds)(</span>
<span class="line-modified"> 188       &quot;Archived java heap is not supported as UseG1GC, &quot;</span>
<span class="line-modified"> 189       &quot;UseCompressedOops and UseCompressedClassPointers are required.&quot;</span>
<span class="line-modified"> 190       &quot;Current settings: UseG1GC=%s, UseCompressedOops=%s, UseCompressedClassPointers=%s.&quot;,</span>
<span class="line-modified"> 191       BOOL_TO_STR(UseG1GC), BOOL_TO_STR(UseCompressedOops),</span>
<span class="line-modified"> 192       BOOL_TO_STR(UseCompressedClassPointers));</span>


 193     return;
 194   }
 195 
 196   G1HeapVerifier::verify_ready_for_archiving();
 197 
 198   {
 199     NoSafepointVerifier nsv;
 200 
 201     // Cache for recording where the archived objects are copied to
 202     create_archived_object_cache();
 203 
<a name="13" id="anc13"></a><span class="line-modified"> 204     log_info(cds)(&quot;Dumping objects to closed archive heap region ...&quot;);</span>
 205     NOT_PRODUCT(StringTable::verify());
 206     copy_closed_archive_heap_objects(closed);
 207 
<a name="14" id="anc14"></a><span class="line-modified"> 208     log_info(cds)(&quot;Dumping objects to open archive heap region ...&quot;);</span>
 209     copy_open_archive_heap_objects(open);
 210 
 211     destroy_archived_object_cache();
 212   }
 213 
 214   G1HeapVerifier::verify_archive_regions();
 215 }
 216 
 217 void HeapShared::copy_closed_archive_heap_objects(
 218                                     GrowableArray&lt;MemRegion&gt; * closed_archive) {
 219   assert(is_heap_object_archiving_allowed(), &quot;Cannot archive java heap objects&quot;);
 220 
 221   Thread* THREAD = Thread::current();
 222   G1CollectedHeap::heap()-&gt;begin_archive_alloc_range();
 223 
 224   // Archive interned string objects
 225   StringTable::write_to_archive();
 226 
 227   archive_object_subgraphs(closed_archive_subgraph_entry_fields,
 228                            num_closed_archive_subgraph_entry_fields,
 229                            true /* is_closed_archive */, THREAD);
 230 
 231   G1CollectedHeap::heap()-&gt;end_archive_alloc_range(closed_archive,
 232                                                    os::vm_allocation_granularity());
 233 }
 234 
 235 void HeapShared::copy_open_archive_heap_objects(
 236                                     GrowableArray&lt;MemRegion&gt; * open_archive) {
 237   assert(is_heap_object_archiving_allowed(), &quot;Cannot archive java heap objects&quot;);
 238 
 239   Thread* THREAD = Thread::current();
 240   G1CollectedHeap::heap()-&gt;begin_archive_alloc_range(true /* open */);
 241 
 242   java_lang_Class::archive_basic_type_mirrors(THREAD);
 243 
 244   archive_klass_objects(THREAD);
 245 
 246   archive_object_subgraphs(open_archive_subgraph_entry_fields,
 247                            num_open_archive_subgraph_entry_fields,
 248                            false /* is_closed_archive */,
 249                            THREAD);
 250 
 251   G1CollectedHeap::heap()-&gt;end_archive_alloc_range(open_archive,
 252                                                    os::vm_allocation_granularity());
 253 }
 254 
 255 void HeapShared::init_narrow_oop_decoding(address base, int shift) {
 256   _narrow_oop_base = base;
 257   _narrow_oop_shift = shift;
 258 }
 259 
 260 //
 261 // Subgraph archiving support
 262 //
 263 HeapShared::DumpTimeKlassSubGraphInfoTable* HeapShared::_dump_time_subgraph_info_table = NULL;
 264 HeapShared::RunTimeKlassSubGraphInfoTable   HeapShared::_run_time_subgraph_info_table;
 265 
 266 // Get the subgraph_info for Klass k. A new subgraph_info is created if
 267 // there is no existing one for k. The subgraph_info records the relocated
 268 // Klass* of the original k.
 269 KlassSubGraphInfo* HeapShared::get_subgraph_info(Klass* k) {
 270   assert(DumpSharedSpaces, &quot;dump time only&quot;);
 271   Klass* relocated_k = MetaspaceShared::get_relocated_klass(k);
 272   KlassSubGraphInfo* info = _dump_time_subgraph_info_table-&gt;get(relocated_k);
 273   if (info == NULL) {
 274     _dump_time_subgraph_info_table-&gt;put(relocated_k, KlassSubGraphInfo(relocated_k));
 275     info = _dump_time_subgraph_info_table-&gt;get(relocated_k);
 276     ++ _dump_time_subgraph_info_table-&gt;_count;
 277   }
 278   return info;
 279 }
 280 
 281 // Add an entry field to the current KlassSubGraphInfo.
 282 void KlassSubGraphInfo::add_subgraph_entry_field(
 283       int static_field_offset, oop v, bool is_closed_archive) {
 284   assert(DumpSharedSpaces, &quot;dump time only&quot;);
 285   if (_subgraph_entry_fields == NULL) {
 286     _subgraph_entry_fields =
 287       new(ResourceObj::C_HEAP, mtClass) GrowableArray&lt;juint&gt;(10, true);
 288   }
 289   _subgraph_entry_fields-&gt;append((juint)static_field_offset);
 290   _subgraph_entry_fields-&gt;append(CompressedOops::encode(v));
 291   _subgraph_entry_fields-&gt;append(is_closed_archive ? 1 : 0);
 292 }
 293 
 294 // Add the Klass* for an object in the current KlassSubGraphInfo&#39;s subgraphs.
 295 // Only objects of boot classes can be included in sub-graph.
 296 void KlassSubGraphInfo::add_subgraph_object_klass(Klass* orig_k, Klass *relocated_k) {
 297   assert(DumpSharedSpaces, &quot;dump time only&quot;);
 298   assert(relocated_k == MetaspaceShared::get_relocated_klass(orig_k),
 299          &quot;must be the relocated Klass in the shared space&quot;);
 300 
 301   if (_subgraph_object_klasses == NULL) {
 302     _subgraph_object_klasses =
 303       new(ResourceObj::C_HEAP, mtClass) GrowableArray&lt;Klass*&gt;(50, true);
 304   }
 305 
 306   assert(relocated_k-&gt;is_shared(), &quot;must be a shared class&quot;);
 307 
 308   if (_k == relocated_k) {
 309     // Don&#39;t add the Klass containing the sub-graph to it&#39;s own klass
 310     // initialization list.
 311     return;
 312   }
 313 
 314   if (relocated_k-&gt;is_instance_klass()) {
 315     assert(InstanceKlass::cast(relocated_k)-&gt;is_shared_boot_class(),
 316           &quot;must be boot class&quot;);
 317     // SystemDictionary::xxx_klass() are not updated, need to check
 318     // the original Klass*
 319     if (orig_k == SystemDictionary::String_klass() ||
 320         orig_k == SystemDictionary::Object_klass()) {
 321       // Initialized early during VM initialization. No need to be added
 322       // to the sub-graph object class list.
 323       return;
 324     }
 325   } else if (relocated_k-&gt;is_objArray_klass()) {
 326     Klass* abk = ObjArrayKlass::cast(relocated_k)-&gt;bottom_klass();
 327     if (abk-&gt;is_instance_klass()) {
 328       assert(InstanceKlass::cast(abk)-&gt;is_shared_boot_class(),
 329             &quot;must be boot class&quot;);
 330     }
 331     if (relocated_k == Universe::objectArrayKlassObj()) {
 332       // Initialized early during Universe::genesis. No need to be added
 333       // to the list.
 334       return;
 335     }
 336   } else {
 337     assert(relocated_k-&gt;is_typeArray_klass(), &quot;must be&quot;);
 338     // Primitive type arrays are created early during Universe::genesis.
 339     return;
 340   }
 341 
 342   if (log_is_enabled(Debug, cds, heap)) {
 343     if (!_subgraph_object_klasses-&gt;contains(relocated_k)) {
 344       ResourceMark rm;
 345       log_debug(cds, heap)(&quot;Adding klass %s&quot;, orig_k-&gt;external_name());
 346     }
 347   }
 348 
 349   _subgraph_object_klasses-&gt;append_if_missing(relocated_k);
 350 }
 351 
 352 // Initialize an archived subgraph_info_record from the given KlassSubGraphInfo.
 353 void ArchivedKlassSubGraphInfoRecord::init(KlassSubGraphInfo* info) {
 354   _k = info-&gt;klass();
 355   _entry_field_records = NULL;
 356   _subgraph_object_klasses = NULL;
 357 
 358   // populate the entry fields
 359   GrowableArray&lt;juint&gt;* entry_fields = info-&gt;subgraph_entry_fields();
 360   if (entry_fields != NULL) {
 361     int num_entry_fields = entry_fields-&gt;length();
 362     assert(num_entry_fields % 3 == 0, &quot;sanity&quot;);
 363     _entry_field_records =
 364       MetaspaceShared::new_ro_array&lt;juint&gt;(num_entry_fields);
 365     for (int i = 0 ; i &lt; num_entry_fields; i++) {
 366       _entry_field_records-&gt;at_put(i, entry_fields-&gt;at(i));
 367     }
 368   }
 369 
 370   // the Klasses of the objects in the sub-graphs
 371   GrowableArray&lt;Klass*&gt;* subgraph_object_klasses = info-&gt;subgraph_object_klasses();
 372   if (subgraph_object_klasses != NULL) {
 373     int num_subgraphs_klasses = subgraph_object_klasses-&gt;length();
 374     _subgraph_object_klasses =
 375       MetaspaceShared::new_ro_array&lt;Klass*&gt;(num_subgraphs_klasses);
 376     for (int i = 0; i &lt; num_subgraphs_klasses; i++) {
 377       Klass* subgraph_k = subgraph_object_klasses-&gt;at(i);
 378       if (log_is_enabled(Info, cds, heap)) {
 379         ResourceMark rm;
 380         log_info(cds, heap)(
 381           &quot;Archived object klass %s (%2d) =&gt; %s&quot;,
 382           _k-&gt;external_name(), i, subgraph_k-&gt;external_name());
 383       }
 384       _subgraph_object_klasses-&gt;at_put(i, subgraph_k);
<a name="15" id="anc15"></a><span class="line-added"> 385       ArchivePtrMarker::mark_pointer(_subgraph_object_klasses-&gt;adr_at(i));</span>
 386     }
 387   }
<a name="16" id="anc16"></a><span class="line-added"> 388 </span>
<span class="line-added"> 389   ArchivePtrMarker::mark_pointer(&amp;_k);</span>
<span class="line-added"> 390   ArchivePtrMarker::mark_pointer(&amp;_entry_field_records);</span>
<span class="line-added"> 391   ArchivePtrMarker::mark_pointer(&amp;_subgraph_object_klasses);</span>
 392 }
 393 
 394 struct CopyKlassSubGraphInfoToArchive : StackObj {
 395   CompactHashtableWriter* _writer;
 396   CopyKlassSubGraphInfoToArchive(CompactHashtableWriter* writer) : _writer(writer) {}
 397 
 398   bool do_entry(Klass* klass, KlassSubGraphInfo&amp; info) {
 399     if (info.subgraph_object_klasses() != NULL || info.subgraph_entry_fields() != NULL) {
 400       ArchivedKlassSubGraphInfoRecord* record =
 401         (ArchivedKlassSubGraphInfoRecord*)MetaspaceShared::read_only_space_alloc(sizeof(ArchivedKlassSubGraphInfoRecord));
 402       record-&gt;init(&amp;info);
 403 
<a name="17" id="anc17"></a><span class="line-modified"> 404       unsigned int hash = SystemDictionaryShared::hash_for_shared_dictionary(klass);</span>
 405       u4 delta = MetaspaceShared::object_delta_u4(record);
 406       _writer-&gt;add(hash, delta);
 407     }
 408     return true; // keep on iterating
 409   }
 410 };
 411 
 412 // Build the records of archived subgraph infos, which include:
 413 // - Entry points to all subgraphs from the containing class mirror. The entry
 414 //   points are static fields in the mirror. For each entry point, the field
 415 //   offset, value and is_closed_archive flag are recorded in the sub-graph
 416 //   info. The value is stored back to the corresponding field at runtime.
 417 // - A list of klasses that need to be loaded/initialized before archived
 418 //   java object sub-graph can be accessed at runtime.
 419 void HeapShared::write_subgraph_info_table() {
 420   // Allocate the contents of the hashtable(s) inside the RO region of the CDS archive.
 421   DumpTimeKlassSubGraphInfoTable* d_table = _dump_time_subgraph_info_table;
 422   CompactHashtableStats stats;
 423 
 424   _run_time_subgraph_info_table.reset();
 425 
<a name="18" id="anc18"></a><span class="line-modified"> 426   CompactHashtableWriter writer(d_table-&gt;_count, &amp;stats);</span>

 427   CopyKlassSubGraphInfoToArchive copy(&amp;writer);
 428   d_table-&gt;iterate(&amp;copy);
 429 
 430   writer.dump(&amp;_run_time_subgraph_info_table, &quot;subgraphs&quot;);
 431 }
 432 
 433 void HeapShared::serialize_subgraph_info_table_header(SerializeClosure* soc) {
 434   _run_time_subgraph_info_table.serialize_header(soc);
 435 }
 436 
 437 void HeapShared::initialize_from_archived_subgraph(Klass* k) {
 438   if (!open_archive_heap_region_mapped()) {
 439     return; // nothing to do
 440   }
 441   assert(!DumpSharedSpaces, &quot;Should not be called with DumpSharedSpaces&quot;);
 442 
<a name="19" id="anc19"></a><span class="line-modified"> 443   unsigned int hash = SystemDictionaryShared::hash_for_shared_dictionary(k);</span>
 444   const ArchivedKlassSubGraphInfoRecord* record = _run_time_subgraph_info_table.lookup(k, hash, 0);
 445 
 446   // Initialize from archived data. Currently this is done only
 447   // during VM initialization time. No lock is needed.
 448   if (record != NULL) {
 449     Thread* THREAD = Thread::current();
 450 
 451     int i;
 452     // Load/link/initialize the klasses of the objects in the subgraph.
 453     // NULL class loader is used.
 454     Array&lt;Klass*&gt;* klasses = record-&gt;subgraph_object_klasses();
 455     if (klasses != NULL) {
 456       for (i = 0; i &lt; klasses-&gt;length(); i++) {
 457         Klass* obj_k = klasses-&gt;at(i);
 458         Klass* resolved_k = SystemDictionary::resolve_or_null(
 459                                               (obj_k)-&gt;name(), THREAD);
 460         if (resolved_k != obj_k) {
 461           assert(!SystemDictionary::is_well_known_klass(resolved_k),
 462                  &quot;shared well-known classes must not be replaced by JVMTI ClassFileLoadHook&quot;);
 463           ResourceMark rm(THREAD);
 464           log_info(cds, heap)(&quot;Failed to load subgraph because %s was not loaded from archive&quot;,
 465                               resolved_k-&gt;external_name());
 466           return;
 467         }
 468         if ((obj_k)-&gt;is_instance_klass()) {
 469           InstanceKlass* ik = InstanceKlass::cast(obj_k);
 470           ik-&gt;initialize(THREAD);
 471         } else if ((obj_k)-&gt;is_objArray_klass()) {
 472           ObjArrayKlass* oak = ObjArrayKlass::cast(obj_k);
 473           oak-&gt;initialize(THREAD);
 474         }
 475       }
 476     }
 477 
 478     if (HAS_PENDING_EXCEPTION) {
 479       CLEAR_PENDING_EXCEPTION;
 480       // None of the field value will be set if there was an exception.
 481       // The java code will not see any of the archived objects in the
 482       // subgraphs referenced from k in this case.
 483       return;
 484     }
 485 
 486     // Load the subgraph entry fields from the record and store them back to
 487     // the corresponding fields within the mirror.
 488     oop m = k-&gt;java_mirror();
 489     Array&lt;juint&gt;* entry_field_records = record-&gt;entry_field_records();
 490     if (entry_field_records != NULL) {
 491       int efr_len = entry_field_records-&gt;length();
 492       assert(efr_len % 3 == 0, &quot;sanity&quot;);
 493       for (i = 0; i &lt; efr_len;) {
 494         int field_offset = entry_field_records-&gt;at(i);
 495         narrowOop nv = entry_field_records-&gt;at(i+1);
 496         int is_closed_archive = entry_field_records-&gt;at(i+2);
 497         oop v;
 498         if (is_closed_archive == 0) {
 499           // It&#39;s an archived object in the open archive heap regions, not shared.
 500           // The object refereced by the field becomes &#39;known&#39; by GC from this
 501           // point. All objects in the subgraph reachable from the object are
 502           // also &#39;known&#39; by GC.
 503           v = materialize_archived_object(nv);
 504         } else {
 505           // Shared object in the closed archive heap regions. Decode directly.
 506           assert(!CompressedOops::is_null(nv), &quot;shared object is null&quot;);
 507           v = HeapShared::decode_from_archive(nv);
 508         }
 509         m-&gt;obj_field_put(field_offset, v);
 510         i += 3;
 511 
 512         log_debug(cds, heap)(&quot;  &quot; PTR_FORMAT &quot; init field @ %2d = &quot; PTR_FORMAT, p2i(k), field_offset, p2i(v));
 513       }
 514 
 515       // Done. Java code can see the archived sub-graphs referenced from k&#39;s
 516       // mirror after this point.
 517       if (log_is_enabled(Info, cds, heap)) {
 518         ResourceMark rm;
 519         log_info(cds, heap)(&quot;initialize_from_archived_subgraph %s &quot; PTR_FORMAT,
 520                             k-&gt;external_name(), p2i(k));
 521       }
 522     }
 523   }
 524 }
 525 
 526 class WalkOopAndArchiveClosure: public BasicOopIterateClosure {
 527   int _level;
 528   bool _is_closed_archive;
 529   bool _record_klasses_only;
 530   KlassSubGraphInfo* _subgraph_info;
 531   oop _orig_referencing_obj;
 532   oop _archived_referencing_obj;
 533   Thread* _thread;
 534  public:
 535   WalkOopAndArchiveClosure(int level,
 536                            bool is_closed_archive,
 537                            bool record_klasses_only,
 538                            KlassSubGraphInfo* subgraph_info,
 539                            oop orig, oop archived, TRAPS) :
 540     _level(level), _is_closed_archive(is_closed_archive),
 541     _record_klasses_only(record_klasses_only),
 542     _subgraph_info(subgraph_info),
 543     _orig_referencing_obj(orig), _archived_referencing_obj(archived),
 544     _thread(THREAD) {}
 545   void do_oop(narrowOop *p) { WalkOopAndArchiveClosure::do_oop_work(p); }
 546   void do_oop(      oop *p) { WalkOopAndArchiveClosure::do_oop_work(p); }
 547 
 548  protected:
 549   template &lt;class T&gt; void do_oop_work(T *p) {
 550     oop obj = RawAccess&lt;&gt;::oop_load(p);
 551     if (!CompressedOops::is_null(obj)) {
 552       assert(!HeapShared::is_archived_object(obj),
 553              &quot;original objects must not point to archived objects&quot;);
 554 
 555       size_t field_delta = pointer_delta(p, _orig_referencing_obj, sizeof(char));
<a name="20" id="anc20"></a><span class="line-modified"> 556       T* new_p = (T*)(cast_from_oop&lt;address&gt;(_archived_referencing_obj) + field_delta);</span>
 557       Thread* THREAD = _thread;
 558 
 559       if (!_record_klasses_only &amp;&amp; log_is_enabled(Debug, cds, heap)) {
 560         ResourceMark rm;
 561         log_debug(cds, heap)(&quot;(%d) %s[&quot; SIZE_FORMAT &quot;] ==&gt; &quot; PTR_FORMAT &quot; size %d %s&quot;, _level,
 562                              _orig_referencing_obj-&gt;klass()-&gt;external_name(), field_delta,
 563                              p2i(obj), obj-&gt;size() * HeapWordSize, obj-&gt;klass()-&gt;external_name());
 564         LogTarget(Trace, cds, heap) log;
 565         LogStream out(log);
 566         obj-&gt;print_on(&amp;out);
 567       }
 568 
 569       oop archived = HeapShared::archive_reachable_objects_from(
 570           _level + 1, _subgraph_info, obj, _is_closed_archive, THREAD);
 571       assert(archived != NULL, &quot;VM should have exited with unarchivable objects for _level &gt; 1&quot;);
 572       assert(HeapShared::is_archived_object(archived), &quot;must be&quot;);
 573 
 574       if (!_record_klasses_only) {
 575         // Update the reference in the archived copy of the referencing object.
 576         log_debug(cds, heap)(&quot;(%d) updating oop @[&quot; PTR_FORMAT &quot;] &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
 577                              _level, p2i(new_p), p2i(obj), p2i(archived));
 578         RawAccess&lt;IS_NOT_NULL&gt;::oop_store(new_p, archived);
 579       }
 580     }
 581   }
 582 };
 583 
 584 void HeapShared::check_closed_archive_heap_region_object(InstanceKlass* k,
 585                                                          Thread* THREAD) {
 586   // Check fields in the object
 587   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
 588     if (!fs.access_flags().is_static()) {
 589       BasicType ft = fs.field_descriptor().field_type();
<a name="21" id="anc21"></a><span class="line-modified"> 590       if (!fs.access_flags().is_final() &amp;&amp; is_reference_type(ft)) {</span>
 591         ResourceMark rm(THREAD);
 592         log_warning(cds, heap)(
 593           &quot;Please check reference field in %s instance in closed archive heap region: %s %s&quot;,
 594           k-&gt;external_name(), (fs.name())-&gt;as_C_string(),
 595           (fs.signature())-&gt;as_C_string());
 596       }
 597     }
 598   }
 599 }
 600 
 601 // (1) If orig_obj has not been archived yet, archive it.
 602 // (2) If orig_obj has not been seen yet (since start_recording_subgraph() was called),
 603 //     trace all  objects that are reachable from it, and make sure these objects are archived.
 604 // (3) Record the klasses of all orig_obj and all reachable objects.
 605 oop HeapShared::archive_reachable_objects_from(int level,
 606                                                KlassSubGraphInfo* subgraph_info,
 607                                                oop orig_obj,
 608                                                bool is_closed_archive,
 609                                                TRAPS) {
 610   assert(orig_obj != NULL, &quot;must be&quot;);
 611   assert(!is_archived_object(orig_obj), &quot;sanity&quot;);
 612 
<a name="22" id="anc22"></a><span class="line-modified"> 613   if (!JavaClasses::is_supported_for_archiving(orig_obj)) {</span>
<span class="line-modified"> 614     // This object has injected fields that cannot be supported easily, so we disallow them for now.</span>
<span class="line-added"> 615     // If you get an error here, you probably made a change in the JDK library that has added</span>
<span class="line-added"> 616     // these objects that are referenced (directly or indirectly) by static fields.</span>
<span class="line-added"> 617     ResourceMark rm;</span>
<span class="line-added"> 618     log_error(cds, heap)(&quot;Cannot archive object of class %s&quot;, orig_obj-&gt;klass()-&gt;external_name());</span>
<span class="line-added"> 619     vm_exit(1);</span>
<span class="line-added"> 620   }</span>
<span class="line-added"> 621 </span>
<span class="line-added"> 622   // java.lang.Class instances cannot be included in an archived object sub-graph. We only support</span>
<span class="line-added"> 623   // them as Klass::_archived_mirror because they need to be specially restored at run time.</span>
<span class="line-added"> 624   //</span>
<span class="line-added"> 625   // If you get an error here, you probably made a change in the JDK library that has added a Class</span>
<span class="line-added"> 626   // object that is referenced (directly or indirectly) by static fields.</span>
 627   if (java_lang_Class::is_instance(orig_obj)) {
 628     log_error(cds, heap)(&quot;(%d) Unknown java.lang.Class object is in the archived sub-graph&quot;, level);
 629     vm_exit(1);
 630   }
 631 
 632   oop archived_obj = find_archived_heap_object(orig_obj);
 633   if (java_lang_String::is_instance(orig_obj) &amp;&amp; archived_obj != NULL) {
 634     // To save time, don&#39;t walk strings that are already archived. They just contain
 635     // pointers to a type array, whose klass doesn&#39;t need to be recorded.
 636     return archived_obj;
 637   }
 638 
 639   if (has_been_seen_during_subgraph_recording(orig_obj)) {
 640     // orig_obj has already been archived and traced. Nothing more to do.
 641     return archived_obj;
 642   } else {
 643     set_has_been_seen_during_subgraph_recording(orig_obj);
 644   }
 645 
 646   bool record_klasses_only = (archived_obj != NULL);
 647   if (archived_obj == NULL) {
 648     ++_num_new_archived_objs;
 649     archived_obj = archive_heap_object(orig_obj, THREAD);
 650     if (archived_obj == NULL) {
 651       // Skip archiving the sub-graph referenced from the current entry field.
 652       ResourceMark rm;
 653       log_error(cds, heap)(
 654         &quot;Cannot archive the sub-graph referenced from %s object (&quot;
 655         PTR_FORMAT &quot;) size %d, skipped.&quot;,
 656         orig_obj-&gt;klass()-&gt;external_name(), p2i(orig_obj), orig_obj-&gt;size() * HeapWordSize);
 657       if (level == 1) {
 658         // Don&#39;t archive a subgraph root that&#39;s too big. For archives static fields, that&#39;s OK
 659         // as the Java code will take care of initializing this field dynamically.
 660         return NULL;
 661       } else {
 662         // We don&#39;t know how to handle an object that has been archived, but some of its reachable
 663         // objects cannot be archived. Bail out for now. We might need to fix this in the future if
 664         // we have a real use case.
 665         vm_exit(1);
 666       }
 667     }
 668   }
 669 
 670   assert(archived_obj != NULL, &quot;must be&quot;);
 671   Klass *orig_k = orig_obj-&gt;klass();
 672   Klass *relocated_k = archived_obj-&gt;klass();
 673   subgraph_info-&gt;add_subgraph_object_klass(orig_k, relocated_k);
 674 
 675   WalkOopAndArchiveClosure walker(level, is_closed_archive, record_klasses_only,
 676                                   subgraph_info, orig_obj, archived_obj, THREAD);
 677   orig_obj-&gt;oop_iterate(&amp;walker);
 678   if (is_closed_archive &amp;&amp; orig_k-&gt;is_instance_klass()) {
 679     check_closed_archive_heap_region_object(InstanceKlass::cast(orig_k), THREAD);
 680   }
 681   return archived_obj;
 682 }
 683 
 684 //
 685 // Start from the given static field in a java mirror and archive the
 686 // complete sub-graph of java heap objects that are reached directly
 687 // or indirectly from the starting object by following references.
 688 // Sub-graph archiving restrictions (current):
 689 //
 690 // - All classes of objects in the archived sub-graph (including the
 691 //   entry class) must be boot class only.
 692 // - No java.lang.Class instance (java mirror) can be included inside
 693 //   an archived sub-graph. Mirror can only be the sub-graph entry object.
 694 //
 695 // The Java heap object sub-graph archiving process (see
 696 // WalkOopAndArchiveClosure):
 697 //
 698 // 1) Java object sub-graph archiving starts from a given static field
 699 // within a Class instance (java mirror). If the static field is a
 700 // refererence field and points to a non-null java object, proceed to
 701 // the next step.
 702 //
 703 // 2) Archives the referenced java object. If an archived copy of the
 704 // current object already exists, updates the pointer in the archived
 705 // copy of the referencing object to point to the current archived object.
 706 // Otherwise, proceed to the next step.
 707 //
 708 // 3) Follows all references within the current java object and recursively
 709 // archive the sub-graph of objects starting from each reference.
 710 //
 711 // 4) Updates the pointer in the archived copy of referencing object to
 712 // point to the current archived object.
 713 //
 714 // 5) The Klass of the current java object is added to the list of Klasses
 715 // for loading and initialzing before any object in the archived graph can
 716 // be accessed at runtime.
 717 //
 718 void HeapShared::archive_reachable_objects_from_static_field(InstanceKlass *k,
 719                                                              const char* klass_name,
 720                                                              int field_offset,
 721                                                              const char* field_name,
 722                                                              bool is_closed_archive,
 723                                                              TRAPS) {
 724   assert(DumpSharedSpaces, &quot;dump time only&quot;);
 725   assert(k-&gt;is_shared_boot_class(), &quot;must be boot class&quot;);
 726 
 727   oop m = k-&gt;java_mirror();
 728 
 729   KlassSubGraphInfo* subgraph_info = get_subgraph_info(k);
 730   oop f = m-&gt;obj_field(field_offset);
 731 
 732   log_debug(cds, heap)(&quot;Start archiving from: %s::%s (&quot; PTR_FORMAT &quot;)&quot;, klass_name, field_name, p2i(f));
 733 
 734   if (!CompressedOops::is_null(f)) {
 735     if (log_is_enabled(Trace, cds, heap)) {
 736       LogTarget(Trace, cds, heap) log;
 737       LogStream out(log);
 738       f-&gt;print_on(&amp;out);
 739     }
 740 
 741     oop af = archive_reachable_objects_from(1, subgraph_info, f,
 742                                             is_closed_archive, CHECK);
 743 
 744     if (af == NULL) {
 745       log_error(cds, heap)(&quot;Archiving failed %s::%s (some reachable objects cannot be archived)&quot;,
 746                            klass_name, field_name);
 747     } else {
 748       // Note: the field value is not preserved in the archived mirror.
 749       // Record the field as a new subGraph entry point. The recorded
 750       // information is restored from the archive at runtime.
 751       subgraph_info-&gt;add_subgraph_entry_field(field_offset, af, is_closed_archive);
 752       log_info(cds, heap)(&quot;Archived field %s::%s =&gt; &quot; PTR_FORMAT, klass_name, field_name, p2i(af));
 753     }
 754   } else {
 755     // The field contains null, we still need to record the entry point,
 756     // so it can be restored at runtime.
 757     subgraph_info-&gt;add_subgraph_entry_field(field_offset, NULL, false);
 758   }
 759 }
 760 
 761 #ifndef PRODUCT
 762 class VerifySharedOopClosure: public BasicOopIterateClosure {
 763  private:
 764   bool _is_archived;
 765 
 766  public:
 767   VerifySharedOopClosure(bool is_archived) : _is_archived(is_archived) {}
 768 
 769   void do_oop(narrowOop *p) { VerifySharedOopClosure::do_oop_work(p); }
 770   void do_oop(      oop *p) { VerifySharedOopClosure::do_oop_work(p); }
 771 
 772  protected:
 773   template &lt;class T&gt; void do_oop_work(T *p) {
 774     oop obj = RawAccess&lt;&gt;::oop_load(p);
 775     if (!CompressedOops::is_null(obj)) {
 776       HeapShared::verify_reachable_objects_from(obj, _is_archived);
 777     }
 778   }
 779 };
 780 
 781 void HeapShared::verify_subgraph_from_static_field(InstanceKlass* k, int field_offset) {
 782   assert(DumpSharedSpaces, &quot;dump time only&quot;);
 783   assert(k-&gt;is_shared_boot_class(), &quot;must be boot class&quot;);
 784 
 785   oop m = k-&gt;java_mirror();
 786   oop f = m-&gt;obj_field(field_offset);
 787   if (!CompressedOops::is_null(f)) {
 788     verify_subgraph_from(f);
 789   }
 790 }
 791 
 792 void HeapShared::verify_subgraph_from(oop orig_obj) {
 793   oop archived_obj = find_archived_heap_object(orig_obj);
 794   if (archived_obj == NULL) {
 795     // It&#39;s OK for the root of a subgraph to be not archived. See comments in
 796     // archive_reachable_objects_from().
 797     return;
 798   }
 799 
 800   // Verify that all objects reachable from orig_obj are archived.
 801   init_seen_objects_table();
 802   verify_reachable_objects_from(orig_obj, false);
 803   delete_seen_objects_table();
 804 
 805   // Note: we could also verify that all objects reachable from the archived
 806   // copy of orig_obj can only point to archived objects, with:
 807   //      init_seen_objects_table();
 808   //      verify_reachable_objects_from(archived_obj, true);
 809   //      init_seen_objects_table();
 810   // but that&#39;s already done in G1HeapVerifier::verify_archive_regions so we
 811   // won&#39;t do it here.
 812 }
 813 
 814 void HeapShared::verify_reachable_objects_from(oop obj, bool is_archived) {
 815   _num_total_verifications ++;
 816   if (!has_been_seen_during_subgraph_recording(obj)) {
 817     set_has_been_seen_during_subgraph_recording(obj);
 818 
 819     if (is_archived) {
 820       assert(is_archived_object(obj), &quot;must be&quot;);
 821       assert(find_archived_heap_object(obj) == NULL, &quot;must be&quot;);
 822     } else {
 823       assert(!is_archived_object(obj), &quot;must be&quot;);
 824       assert(find_archived_heap_object(obj) != NULL, &quot;must be&quot;);
 825     }
 826 
 827     VerifySharedOopClosure walker(is_archived);
 828     obj-&gt;oop_iterate(&amp;walker);
 829   }
 830 }
 831 #endif
 832 
 833 HeapShared::SeenObjectsTable* HeapShared::_seen_objects_table = NULL;
 834 int HeapShared::_num_new_walked_objs;
 835 int HeapShared::_num_new_archived_objs;
 836 int HeapShared::_num_old_recorded_klasses;
 837 
 838 int HeapShared::_num_total_subgraph_recordings = 0;
 839 int HeapShared::_num_total_walked_objs = 0;
 840 int HeapShared::_num_total_archived_objs = 0;
 841 int HeapShared::_num_total_recorded_klasses = 0;
 842 int HeapShared::_num_total_verifications = 0;
 843 
 844 bool HeapShared::has_been_seen_during_subgraph_recording(oop obj) {
 845   return _seen_objects_table-&gt;get(obj) != NULL;
 846 }
 847 
 848 void HeapShared::set_has_been_seen_during_subgraph_recording(oop obj) {
 849   assert(!has_been_seen_during_subgraph_recording(obj), &quot;sanity&quot;);
 850   _seen_objects_table-&gt;put(obj, true);
 851   ++ _num_new_walked_objs;
 852 }
 853 
 854 void HeapShared::start_recording_subgraph(InstanceKlass *k, const char* class_name) {
 855   log_info(cds, heap)(&quot;Start recording subgraph(s) for archived fields in %s&quot;, class_name);
 856   init_seen_objects_table();
 857   _num_new_walked_objs = 0;
 858   _num_new_archived_objs = 0;
 859   _num_old_recorded_klasses = get_subgraph_info(k)-&gt;num_subgraph_object_klasses();
 860 }
 861 
 862 void HeapShared::done_recording_subgraph(InstanceKlass *k, const char* class_name) {
 863   int num_new_recorded_klasses = get_subgraph_info(k)-&gt;num_subgraph_object_klasses() -
 864     _num_old_recorded_klasses;
 865   log_info(cds, heap)(&quot;Done recording subgraph(s) for archived fields in %s: &quot;
 866                       &quot;walked %d objs, archived %d new objs, recorded %d classes&quot;,
 867                       class_name, _num_new_walked_objs, _num_new_archived_objs,
 868                       num_new_recorded_klasses);
 869 
 870   delete_seen_objects_table();
 871 
 872   _num_total_subgraph_recordings ++;
 873   _num_total_walked_objs      += _num_new_walked_objs;
 874   _num_total_archived_objs    += _num_new_archived_objs;
 875   _num_total_recorded_klasses +=  num_new_recorded_klasses;
 876 }
 877 
 878 class ArchivableStaticFieldFinder: public FieldClosure {
 879   InstanceKlass* _ik;
 880   Symbol* _field_name;
 881   bool _found;
 882   int _offset;
 883 public:
 884   ArchivableStaticFieldFinder(InstanceKlass* ik, Symbol* field_name) :
 885     _ik(ik), _field_name(field_name), _found(false), _offset(-1) {}
 886 
 887   virtual void do_field(fieldDescriptor* fd) {
 888     if (fd-&gt;name() == _field_name) {
 889       assert(!_found, &quot;fields cannot be overloaded&quot;);
<a name="23" id="anc23"></a><span class="line-modified"> 890       assert(is_reference_type(fd-&gt;field_type()), &quot;can archive only fields that are references&quot;);</span>
 891       _found = true;
 892       _offset = fd-&gt;offset();
 893     }
 894   }
 895   bool found()     { return _found;  }
 896   int offset()     { return _offset; }
 897 };
 898 
 899 void HeapShared::init_subgraph_entry_fields(ArchivableStaticFieldInfo fields[],
 900                                             int num, Thread* THREAD) {
 901   for (int i = 0; i &lt; num; i++) {
 902     ArchivableStaticFieldInfo* info = &amp;fields[i];
<a name="24" id="anc24"></a><span class="line-modified"> 903     TempNewSymbol klass_name =  SymbolTable::new_symbol(info-&gt;klass_name);</span>
<span class="line-modified"> 904     TempNewSymbol field_name =  SymbolTable::new_symbol(info-&gt;field_name);</span>
 905 
 906     Klass* k = SystemDictionary::resolve_or_null(klass_name, THREAD);
 907     assert(k != NULL &amp;&amp; !HAS_PENDING_EXCEPTION, &quot;class must exist&quot;);
 908     InstanceKlass* ik = InstanceKlass::cast(k);
 909     assert(InstanceKlass::cast(ik)-&gt;is_shared_boot_class(),
 910            &quot;Only support boot classes&quot;);
 911     ik-&gt;initialize(THREAD);
 912     guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in initialize&quot;);
 913 
 914     ArchivableStaticFieldFinder finder(ik, field_name);
 915     ik-&gt;do_local_static_fields(&amp;finder);
 916     assert(finder.found(), &quot;field must exist&quot;);
 917 
 918     info-&gt;klass = ik;
 919     info-&gt;offset = finder.offset();
 920   }
 921 }
 922 
 923 void HeapShared::init_subgraph_entry_fields(Thread* THREAD) {
 924   _dump_time_subgraph_info_table = new (ResourceObj::C_HEAP, mtClass)DumpTimeKlassSubGraphInfoTable();
 925 
 926   init_subgraph_entry_fields(closed_archive_subgraph_entry_fields,
 927                              num_closed_archive_subgraph_entry_fields,
 928                              THREAD);
 929   init_subgraph_entry_fields(open_archive_subgraph_entry_fields,
 930                              num_open_archive_subgraph_entry_fields,
 931                              THREAD);
 932 }
 933 
 934 void HeapShared::archive_object_subgraphs(ArchivableStaticFieldInfo fields[],
 935                                           int num, bool is_closed_archive,
 936                                           Thread* THREAD) {
 937   _num_total_subgraph_recordings = 0;
 938   _num_total_walked_objs = 0;
 939   _num_total_archived_objs = 0;
 940   _num_total_recorded_klasses = 0;
 941   _num_total_verifications = 0;
 942 
 943   // For each class X that has one or more archived fields:
 944   // [1] Dump the subgraph of each archived field
 945   // [2] Create a list of all the class of the objects that can be reached
 946   //     by any of these static fields.
 947   //     At runtime, these classes are initialized before X&#39;s archived fields
 948   //     are restored by HeapShared::initialize_from_archived_subgraph().
 949   int i;
 950   for (i = 0; i &lt; num; ) {
 951     ArchivableStaticFieldInfo* info = &amp;fields[i];
 952     const char* klass_name = info-&gt;klass_name;
 953     start_recording_subgraph(info-&gt;klass, klass_name);
 954 
 955     // If you have specified consecutive fields of the same klass in
 956     // fields[], these will be archived in the same
 957     // {start_recording_subgraph ... done_recording_subgraph} pass to
 958     // save time.
 959     for (; i &lt; num; i++) {
 960       ArchivableStaticFieldInfo* f = &amp;fields[i];
 961       if (f-&gt;klass_name != klass_name) {
 962         break;
 963       }
 964       archive_reachable_objects_from_static_field(f-&gt;klass, f-&gt;klass_name,
 965                                                   f-&gt;offset, f-&gt;field_name,
 966                                                   is_closed_archive, CHECK);
 967     }
 968     done_recording_subgraph(info-&gt;klass, klass_name);
 969   }
 970 
 971   log_info(cds, heap)(&quot;Archived subgraph records in %s archive heap region = %d&quot;,
 972                       is_closed_archive ? &quot;closed&quot; : &quot;open&quot;,
 973                       _num_total_subgraph_recordings);
 974   log_info(cds, heap)(&quot;  Walked %d objects&quot;, _num_total_walked_objs);
 975   log_info(cds, heap)(&quot;  Archived %d objects&quot;, _num_total_archived_objs);
 976   log_info(cds, heap)(&quot;  Recorded %d klasses&quot;, _num_total_recorded_klasses);
 977 
 978 #ifndef PRODUCT
 979   for (int i = 0; i &lt; num; i++) {
 980     ArchivableStaticFieldInfo* f = &amp;fields[i];
 981     verify_subgraph_from_static_field(f-&gt;klass, f-&gt;offset);
 982   }
 983   log_info(cds, heap)(&quot;  Verified %d references&quot;, _num_total_verifications);
 984 #endif
 985 }
 986 
 987 // At dump-time, find the location of all the non-null oop pointers in an archived heap
 988 // region. This way we can quickly relocate all the pointers without using
 989 // BasicOopIterateClosure at runtime.
 990 class FindEmbeddedNonNullPointers: public BasicOopIterateClosure {
 991   narrowOop* _start;
 992   BitMap *_oopmap;
 993   int _num_total_oops;
 994   int _num_null_oops;
 995  public:
 996   FindEmbeddedNonNullPointers(narrowOop* start, BitMap* oopmap)
 997     : _start(start), _oopmap(oopmap), _num_total_oops(0),  _num_null_oops(0) {}
 998 
 999   virtual bool should_verify_oops(void) {
1000     return false;
1001   }
1002   virtual void do_oop(narrowOop* p) {
1003     _num_total_oops ++;
1004     narrowOop v = *p;
1005     if (!CompressedOops::is_null(v)) {
1006       size_t idx = p - _start;
1007       _oopmap-&gt;set_bit(idx);
1008     } else {
1009       _num_null_oops ++;
1010     }
1011   }
1012   virtual void do_oop(oop *p) {
1013     ShouldNotReachHere();
1014   }
1015   int num_total_oops() const { return _num_total_oops; }
1016   int num_null_oops()  const { return _num_null_oops; }
1017 };
1018 
1019 ResourceBitMap HeapShared::calculate_oopmap(MemRegion region) {
1020   assert(UseCompressedOops, &quot;must be&quot;);
1021   size_t num_bits = region.byte_size() / sizeof(narrowOop);
1022   ResourceBitMap oopmap(num_bits);
1023 
1024   HeapWord* p   = region.start();
1025   HeapWord* end = region.end();
1026   FindEmbeddedNonNullPointers finder((narrowOop*)p, &amp;oopmap);
1027 
1028   int num_objs = 0;
1029   while (p &lt; end) {
1030     oop o = (oop)p;
1031     o-&gt;oop_iterate(&amp;finder);
1032     p += o-&gt;size();
1033     ++ num_objs;
1034   }
1035 
1036   log_info(cds, heap)(&quot;calculate_oopmap: objects = %6d, embedded oops = %7d, nulls = %7d&quot;,
1037                       num_objs, finder.num_total_oops(), finder.num_null_oops());
1038   return oopmap;
1039 }
1040 
1041 // Patch all the embedded oop pointers inside an archived heap region,
1042 // to be consistent with the runtime oop encoding.
1043 class PatchEmbeddedPointers: public BitMapClosure {
1044   narrowOop* _start;
1045 
1046  public:
1047   PatchEmbeddedPointers(narrowOop* start) : _start(start) {}
1048 
1049   bool do_bit(size_t offset) {
1050     narrowOop* p = _start + offset;
1051     narrowOop v = *p;
1052     assert(!CompressedOops::is_null(v), &quot;null oops should have been filtered out at dump time&quot;);
1053     oop o = HeapShared::decode_from_archive(v);
1054     RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, o);
1055     return true;
1056   }
1057 };
1058 
1059 void HeapShared::patch_archived_heap_embedded_pointers(MemRegion region, address oopmap,
1060                                                        size_t oopmap_size_in_bits) {
1061   BitMapView bm((BitMap::bm_word_t*)oopmap, oopmap_size_in_bits);
1062 
1063 #ifndef PRODUCT
1064   ResourceMark rm;
1065   ResourceBitMap checkBm = calculate_oopmap(region);
1066   assert(bm.is_same(checkBm), &quot;sanity&quot;);
1067 #endif
1068 
1069   PatchEmbeddedPointers patcher((narrowOop*)region.start());
1070   bm.iterate(&amp;patcher);
1071 }
1072 
1073 #endif // INCLUDE_CDS_JAVA_HEAP
<a name="25" id="anc25"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="25" type="hidden" />
</body>
</html>
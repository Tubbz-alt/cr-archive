<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/memory/iterator.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_MEMORY_ITERATOR_HPP
 26 #define SHARE_MEMORY_ITERATOR_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;memory/memRegion.hpp&quot;
 30 #include &quot;oops/oopsHierarchy.hpp&quot;
 31 
 32 class CodeBlob;
 33 class nmethod;
 34 class ReferenceDiscoverer;
 35 class DataLayout;
 36 class KlassClosure;
 37 class ClassLoaderData;
 38 class Symbol;
<a name="1" id="anc1"></a>

 39 
 40 // The following classes are C++ `closures` for iterating over objects, roots and spaces
 41 
 42 class Closure : public StackObj { };
 43 
<a name="2" id="anc2"></a>





 44 // OopClosure is used for iterating through references to Java objects.
 45 class OopClosure : public Closure {
 46  public:
 47   virtual void do_oop(oop* o) = 0;
 48   virtual void do_oop(narrowOop* o) = 0;
 49 };
 50 
 51 class DoNothingClosure : public OopClosure {
 52  public:
 53   virtual void do_oop(oop* p)       {}
 54   virtual void do_oop(narrowOop* p) {}
 55 };
 56 extern DoNothingClosure do_nothing_cl;
 57 
 58 // OopIterateClosure adds extra code to be run during oop iterations.
 59 // This is needed by the GC and is extracted to a separate type to not
 60 // pollute the OopClosure interface.
 61 class OopIterateClosure : public OopClosure {
 62  private:
 63   ReferenceDiscoverer* _ref_discoverer;
 64 
 65  protected:
 66   OopIterateClosure(ReferenceDiscoverer* rd) : _ref_discoverer(rd) { }
 67   OopIterateClosure() : _ref_discoverer(NULL) { }
 68   ~OopIterateClosure() { }
 69 
 70   void set_ref_discoverer_internal(ReferenceDiscoverer* rd) { _ref_discoverer = rd; }
 71 
 72  public:
 73   ReferenceDiscoverer* ref_discoverer() const { return _ref_discoverer; }
 74 
 75   // Iteration of InstanceRefKlasses differ depending on the closure,
 76   // the below enum describes the different alternatives.
 77   enum ReferenceIterationMode {
 78     DO_DISCOVERY,                // Apply closure and discover references
 79     DO_DISCOVERED_AND_DISCOVERY, // Apply closure to discovered field and do discovery
 80     DO_FIELDS,                   // Apply closure to all fields
 81     DO_FIELDS_EXCEPT_REFERENT    // Apply closure to all fields except the referent field
 82   };
 83 
 84   // The default iteration mode is to do discovery.
 85   virtual ReferenceIterationMode reference_iteration_mode() { return DO_DISCOVERY; }
 86 
 87   // If the do_metadata functions return &quot;true&quot;,
 88   // we invoke the following when running oop_iterate():
 89   //
 90   // 1) do_klass on the header klass pointer.
 91   // 2) do_klass on the klass pointer in the mirrors.
 92   // 3) do_cld   on the class loader data in class loaders.
 93 
 94   virtual bool do_metadata() = 0;
 95   virtual void do_klass(Klass* k) = 0;
 96   virtual void do_cld(ClassLoaderData* cld) = 0;
 97 
 98 #ifdef ASSERT
 99   // Default verification of each visited oop field.
100   template &lt;typename T&gt; void verify(T* p);
101 
102   // Can be used by subclasses to turn off the default verification of oop fields.
103   virtual bool should_verify_oops() { return true; }
104 #endif
105 };
106 
107 // An OopIterateClosure that can be used when there&#39;s no need to visit the Metadata.
108 class BasicOopIterateClosure : public OopIterateClosure {
109 public:
110   BasicOopIterateClosure(ReferenceDiscoverer* rd = NULL) : OopIterateClosure(rd) {}
111 
112   virtual bool do_metadata() { return false; }
113   virtual void do_klass(Klass* k) { ShouldNotReachHere(); }
114   virtual void do_cld(ClassLoaderData* cld) { ShouldNotReachHere(); }
115 };
116 
117 class KlassClosure : public Closure {
118  public:
119   virtual void do_klass(Klass* k) = 0;
120 };
121 
122 class CLDClosure : public Closure {
123  public:
124   virtual void do_cld(ClassLoaderData* cld) = 0;
125 };
126 
<a name="3" id="anc3"></a>




127 
128 class CLDToOopClosure : public CLDClosure {
129   OopClosure*       _oop_closure;
130   int               _cld_claim;
131 
132  public:
133   CLDToOopClosure(OopClosure* oop_closure,
134                   int cld_claim) :
135       _oop_closure(oop_closure),
136       _cld_claim(cld_claim) {}
137 
138   void do_cld(ClassLoaderData* cld);
139 };
140 
<a name="4" id="anc4"></a><span class="line-modified">141 // The base class for all concurrent marking closures,</span>
<span class="line-modified">142 // that participates in class unloading.</span>
<span class="line-modified">143 // It&#39;s used to proxy through the metadata to the oops defined in them.</span>
<span class="line-modified">144 class MetadataVisitingOopIterateClosure: public OopIterateClosure {</span>
145  public:
<a name="5" id="anc5"></a><span class="line-modified">146   MetadataVisitingOopIterateClosure(ReferenceDiscoverer* rd = NULL) : OopIterateClosure(rd) { }</span>


147 
148   virtual bool do_metadata() { return true; }
149   virtual void do_klass(Klass* k);
150   virtual void do_cld(ClassLoaderData* cld);
151 };
152 
<a name="6" id="anc6"></a>







153 // ObjectClosure is used for iterating through an object space
154 
155 class ObjectClosure : public Closure {
156  public:
157   // Called for each object.
158   virtual void do_object(oop obj) = 0;
159 };
160 
161 
162 class BoolObjectClosure : public Closure {
163  public:
164   virtual bool do_object_b(oop obj) = 0;
165 };
166 
167 class AlwaysTrueClosure: public BoolObjectClosure {
168  public:
169   bool do_object_b(oop p) { return true; }
170 };
171 
172 class AlwaysFalseClosure : public BoolObjectClosure {
173  public:
174   bool do_object_b(oop p) { return false; }
175 };
176 
177 // Applies an oop closure to all ref fields in objects iterated over in an
178 // object iteration.
179 class ObjectToOopClosure: public ObjectClosure {
180   OopIterateClosure* _cl;
181 public:
182   void do_object(oop obj);
183   ObjectToOopClosure(OopIterateClosure* cl) : _cl(cl) {}
184 };
185 
<a name="7" id="anc7"></a><span class="line-removed">186 // A version of ObjectClosure that is expected to be robust</span>
<span class="line-removed">187 // in the face of possibly uninitialized objects.</span>
<span class="line-removed">188 class ObjectClosureCareful : public ObjectClosure {</span>
<span class="line-removed">189  public:</span>
<span class="line-removed">190   virtual size_t do_object_careful_m(oop p, MemRegion mr) = 0;</span>
<span class="line-removed">191   virtual size_t do_object_careful(oop p) = 0;</span>
<span class="line-removed">192 };</span>
<span class="line-removed">193 </span>
<span class="line-removed">194 // The following are used in CompactibleFreeListSpace and</span>
<span class="line-removed">195 // ConcurrentMarkSweepGeneration.</span>
<span class="line-removed">196 </span>
<span class="line-removed">197 // Blk closure (abstract class)</span>
<span class="line-removed">198 class BlkClosure : public StackObj {</span>
<span class="line-removed">199  public:</span>
<span class="line-removed">200   virtual size_t do_blk(HeapWord* addr) = 0;</span>
<span class="line-removed">201 };</span>
<span class="line-removed">202 </span>
<span class="line-removed">203 // A version of BlkClosure that is expected to be robust</span>
<span class="line-removed">204 // in the face of possibly uninitialized objects.</span>
<span class="line-removed">205 class BlkClosureCareful : public BlkClosure {</span>
<span class="line-removed">206  public:</span>
<span class="line-removed">207   size_t do_blk(HeapWord* addr) {</span>
<span class="line-removed">208     guarantee(false, &quot;call do_blk_careful instead&quot;);</span>
<span class="line-removed">209     return 0;</span>
<span class="line-removed">210   }</span>
<span class="line-removed">211   virtual size_t do_blk_careful(HeapWord* addr) = 0;</span>
<span class="line-removed">212 };</span>
<span class="line-removed">213 </span>
214 // SpaceClosure is used for iterating over spaces
215 
216 class Space;
217 class CompactibleSpace;
218 
219 class SpaceClosure : public StackObj {
220  public:
221   // Called for each space
222   virtual void do_space(Space* s) = 0;
223 };
224 
225 class CompactibleSpaceClosure : public StackObj {
226  public:
227   // Called for each compactible space
228   virtual void do_space(CompactibleSpace* s) = 0;
229 };
230 
231 
232 // CodeBlobClosure is used for iterating through code blobs
233 // in the code cache or on thread stacks
234 
235 class CodeBlobClosure : public Closure {
236  public:
237   // Called for each code blob.
238   virtual void do_code_blob(CodeBlob* cb) = 0;
239 };
240 
241 // Applies an oop closure to all ref fields in code blobs
242 // iterated over in an object iteration.
243 class CodeBlobToOopClosure : public CodeBlobClosure {
244   OopClosure* _cl;
245   bool _fix_relocations;
246  protected:
247   void do_nmethod(nmethod* nm);
248  public:
249   // If fix_relocations(), then cl must copy objects to their new location immediately to avoid
250   // patching nmethods with the old locations.
251   CodeBlobToOopClosure(OopClosure* cl, bool fix_relocations) : _cl(cl), _fix_relocations(fix_relocations) {}
252   virtual void do_code_blob(CodeBlob* cb);
253 
254   bool fix_relocations() const { return _fix_relocations; }
255   const static bool FixRelocations = true;
256 };
257 
258 class MarkingCodeBlobClosure : public CodeBlobToOopClosure {
259  public:
260   MarkingCodeBlobClosure(OopClosure* cl, bool fix_relocations) : CodeBlobToOopClosure(cl, fix_relocations) {}
261   // Called for each code blob, but at most once per unique blob.
262 
263   virtual void do_code_blob(CodeBlob* cb);
264 };
265 
266 class NMethodClosure : public Closure {
267  public:
268   virtual void do_nmethod(nmethod* n) = 0;
269 };
270 
271 // MonitorClosure is used for iterating over monitors in the monitors cache
272 
273 class ObjectMonitor;
274 
275 class MonitorClosure : public StackObj {
276  public:
277   // called for each monitor in cache
278   virtual void do_monitor(ObjectMonitor* m) = 0;
279 };
280 
281 // A closure that is applied without any arguments.
282 class VoidClosure : public StackObj {
283  public:
284   // I would have liked to declare this a pure virtual, but that breaks
285   // in mysterious ways, for unknown reasons.
286   virtual void do_void();
287 };
288 
289 
290 // YieldClosure is intended for use by iteration loops
291 // to incrementalize their work, allowing interleaving
292 // of an interruptable task so as to allow other
293 // threads to run (which may not otherwise be able to access
294 // exclusive resources, for instance). Additionally, the
295 // closure also allows for aborting an ongoing iteration
296 // by means of checking the return value from the polling
297 // call.
298 class YieldClosure : public StackObj {
299 public:
300  virtual bool should_return() = 0;
301 
302  // Yield on a fine-grain level. The check in case of not yielding should be very fast.
303  virtual bool should_return_fine_grain() { return false; }
304 };
305 
306 // Abstract closure for serializing data (read or write).
307 
308 class SerializeClosure : public Closure {
309 public:
310   // Return bool indicating whether closure implements read or write.
311   virtual bool reading() const = 0;
312 
313   // Read/write the void pointer pointed to by p.
314   virtual void do_ptr(void** p) = 0;
315 
316   // Read/write the 32-bit unsigned integer pointed to by p.
317   virtual void do_u4(u4* p) = 0;
318 
<a name="8" id="anc8"></a>


319   // Read/write the region specified.
320   virtual void do_region(u_char* start, size_t size) = 0;
321 
322   // Check/write the tag.  If reading, then compare the tag against
323   // the passed in value and fail is they don&#39;t match.  This allows
324   // for verification that sections of the serialized data are of the
325   // correct length.
326   virtual void do_tag(int tag) = 0;
327 
328   // Read/write the oop
329   virtual void do_oop(oop* o) = 0;
330 
331   bool writing() {
332     return !reading();
333   }
334 };
335 
336 class SymbolClosure : public StackObj {
337  public:
338   virtual void do_symbol(Symbol**) = 0;
339 
340   // Clear LSB in symbol address; it can be set by CPSlot.
341   static Symbol* load_symbol(Symbol** p) {
342     return (Symbol*)(intptr_t(*p) &amp; ~1);
343   }
344 
345   // Store symbol, adjusting new pointer if the original pointer was adjusted
346   // (symbol references in constant pool slots have their LSB set to 1).
347   static void store_symbol(Symbol** p, Symbol* sym) {
348     *p = (Symbol*)(intptr_t(sym) | (intptr_t(*p) &amp; 1));
349   }
350 };
351 
352 // Dispatches to the non-virtual functions if OopClosureType has
353 // a concrete implementation, otherwise a virtual call is taken.
354 class Devirtualizer {
355  public:
356   template &lt;typename OopClosureType, typename T&gt; static void do_oop_no_verify(OopClosureType* closure, T* p);
357   template &lt;typename OopClosureType, typename T&gt; static void do_oop(OopClosureType* closure, T* p);
358   template &lt;typename OopClosureType&gt;             static void do_klass(OopClosureType* closure, Klass* k);
359   template &lt;typename OopClosureType&gt;             static void do_cld(OopClosureType* closure, ClassLoaderData* cld);
360   template &lt;typename OopClosureType&gt;             static bool do_metadata(OopClosureType* closure);
361 };
362 
363 class OopIteratorClosureDispatch {
364  public:
365   template &lt;typename OopClosureType&gt; static void oop_oop_iterate(OopClosureType* cl, oop obj, Klass* klass);
366   template &lt;typename OopClosureType&gt; static void oop_oop_iterate(OopClosureType* cl, oop obj, Klass* klass, MemRegion mr);
367   template &lt;typename OopClosureType&gt; static void oop_oop_iterate_backwards(OopClosureType* cl, oop obj, Klass* klass);
368 };
369 
370 #endif // SHARE_MEMORY_ITERATOR_HPP
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
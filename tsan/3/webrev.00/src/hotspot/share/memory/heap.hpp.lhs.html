<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/memory/heap.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_MEMORY_HEAP_HPP
 26 #define SHARE_MEMORY_HEAP_HPP
 27 
 28 #include &quot;code/codeBlob.hpp&quot;
 29 #include &quot;memory/allocation.hpp&quot;
 30 #include &quot;memory/virtualspace.hpp&quot;
 31 #include &quot;utilities/macros.hpp&quot;
 32 
 33 // Blocks
 34 
 35 class HeapBlock {
 36   friend class VMStructs;
 37 
 38  public:
 39   struct Header {
 40     size_t  _length;                             // the length in segments
 41     bool    _used;                               // Used bit
 42   };
 43 
 44  protected:
 45   union {
 46     Header _header;
 47     int64_t _padding[ (sizeof(Header) + sizeof(int64_t)-1) / sizeof(int64_t) ];
 48                         // pad to 0 mod 8
 49   };
 50 
 51  public:
 52   // Initialization
 53   void initialize(size_t length)                 { _header._length = length; set_used(); }
<a name="1" id="anc1"></a>

 54 
 55   // Accessors
 56   void* allocated_space() const                  { return (void*)(this + 1); }
 57   size_t length() const                          { return _header._length; }
 58 
 59   // Used/free
 60   void set_used()                                { _header._used = true; }
 61   void set_free()                                { _header._used = false; }
 62   bool free()                                    { return !_header._used; }
 63 };
 64 
 65 class FreeBlock: public HeapBlock {
 66   friend class VMStructs;
 67  protected:
 68   FreeBlock* _link;
 69 
 70  public:
 71   // Initialization
 72   void initialize(size_t length)             { HeapBlock::initialize(length); _link= NULL; }
 73 
<a name="2" id="anc2"></a><span class="line-removed"> 74   // Merging</span>
<span class="line-removed"> 75   void set_length(size_t l)                  { _header._length = l; }</span>
<span class="line-removed"> 76 </span>
 77   // Accessors
 78   FreeBlock* link() const                    { return _link; }
 79   void set_link(FreeBlock* link)             { _link = link; }
 80 };
 81 
 82 class CodeHeap : public CHeapObj&lt;mtCode&gt; {
 83   friend class VMStructs;
 84  protected:
 85   VirtualSpace _memory;                          // the memory holding the blocks
 86   VirtualSpace _segmap;                          // the memory holding the segment map
 87 
 88   size_t       _number_of_committed_segments;
 89   size_t       _number_of_reserved_segments;
 90   size_t       _segment_size;
 91   int          _log2_segment_size;
 92 
 93   size_t       _next_segment;
 94 
 95   FreeBlock*   _freelist;
<a name="3" id="anc3"></a>
 96   size_t       _freelist_segments;               // No. of segments in freelist
 97   int          _freelist_length;
 98   size_t       _max_allocated_capacity;          // Peak capacity that was allocated during lifetime of the heap
 99 
100   const char*  _name;                            // Name of the CodeHeap
101   const int    _code_blob_type;                  // CodeBlobType it contains
102   int          _blob_count;                      // Number of CodeBlobs
103   int          _nmethod_count;                   // Number of nmethods
104   int          _adapter_count;                   // Number of adapters
105   int          _full_count;                      // Number of times the code heap was full
<a name="4" id="anc4"></a><span class="line-modified">106 </span>
107 
108   enum { free_sentinel = 0xFF };
<a name="5" id="anc5"></a>


109 
110   // Helper functions
111   size_t   size_to_segments(size_t size) const { return (size + _segment_size - 1) &gt;&gt; _log2_segment_size; }
112   size_t   segments_to_size(size_t number_of_segments) const { return number_of_segments &lt;&lt; _log2_segment_size; }
113 
114   size_t   segment_for(void* p) const            { return ((char*)p - _memory.low()) &gt;&gt; _log2_segment_size; }
115   bool     is_segment_unused(int val) const      { return val == free_sentinel; }
<a name="6" id="anc6"></a><span class="line-modified">116   HeapBlock* block_at(size_t i) const            { return (HeapBlock*)(_memory.low() + (i &lt;&lt; _log2_segment_size)); }</span>
<span class="line-modified">117 </span>
<span class="line-modified">118   void  mark_segmap_as_free(size_t beg, size_t end);</span>
<span class="line-modified">119   void  mark_segmap_as_used(size_t beg, size_t end);</span>







120 
121   // Freelist management helpers
122   FreeBlock* following_block(FreeBlock* b);
123   void insert_after(FreeBlock* a, FreeBlock* b);
124   bool merge_right (FreeBlock* a);
125 
126   // Toplevel freelist management
127   void add_to_freelist(HeapBlock* b);
<a name="7" id="anc7"></a><span class="line-modified">128   FreeBlock* search_freelist(size_t length);</span>
129 
130   // Iteration helpers
131   void*      next_used(HeapBlock* b) const;
132   HeapBlock* block_start(void* p) const;
133 
134   // to perform additional actions on creation of executable code
135   void on_code_mapping(char* base, size_t size);
<a name="8" id="anc8"></a><span class="line-removed">136   void clear();                                 // clears all heap contents</span>
137 
138  public:
139   CodeHeap(const char* name, const int code_blob_type);
140 
141   // Heap extents
142   bool  reserve(ReservedSpace rs, size_t committed_size, size_t segment_size);
143   bool  expand_by(size_t size);                  // expands committed memory by size
144 
145   // Memory allocation
146   void* allocate (size_t size); // Allocate &#39;size&#39; bytes in the code cache or return NULL
147   void  deallocate(void* p);    // Deallocate memory
148   // Free the tail of segments allocated by the last call to &#39;allocate()&#39; which exceed &#39;used_size&#39;.
149   // ATTENTION: this is only safe to use if there was no other call to &#39;allocate()&#39; after
150   //            &#39;p&#39; was allocated. Only intended for freeing memory which would be otherwise
151   //            wasted after the interpreter generation because we don&#39;t know the interpreter size
152   //            beforehand and we also can&#39;t easily relocate the interpreter to a new location.
153   void  deallocate_tail(void* p, size_t used_size);
154 
<a name="9" id="anc9"></a><span class="line-modified">155   // Attributes</span>
<span class="line-modified">156   char* low_boundary() const                     { return _memory.low_boundary(); }</span>
157   char* high() const                             { return _memory.high(); }
<a name="10" id="anc10"></a>

158   char* high_boundary() const                    { return _memory.high_boundary(); }
159 
<a name="11" id="anc11"></a><span class="line-modified">160   bool contains(const void* p) const             { return low_boundary() &lt;= p &amp;&amp; p &lt; high(); }</span>

161   bool contains_blob(const CodeBlob* blob) const {
162     // AOT CodeBlobs (i.e. AOTCompiledMethod) objects aren&#39;t allocated in the AOTCodeHeap but on the C-Heap.
163     // Only the code they are pointing to is located in the AOTCodeHeap. All other CodeBlobs are allocated
164     // directly in their corresponding CodeHeap with their code appended to the actual C++ object.
165     // So all CodeBlobs except AOTCompiledMethod are continuous in memory with their data and code while
166     // AOTCompiledMethod and their code/data is distributed in the C-Heap. This means we can use the
167     // address of a CodeBlob object in order to locate it in its heap while we have to use the address
168     // of the actual code an AOTCompiledMethod object is pointing to in order to locate it.
169     // Notice that for an ordinary CodeBlob with code size zero, code_begin() may point beyond the object!
170     const void* start = AOT_ONLY( (code_blob_type() == CodeBlobType::AOT) ? blob-&gt;code_begin() : ) (void*)blob;
171     return contains(start);
172   }
173 
174   virtual void* find_start(void* p)     const;   // returns the block containing p or NULL
175   virtual CodeBlob* find_blob_unsafe(void* start) const;
176   size_t alignment_unit()       const;           // alignment of any block
177   size_t alignment_offset()     const;           // offset of first byte of any block, within the enclosing alignment unit
178   static size_t header_size();                   // returns the header size for each heap block
179 
180   size_t segment_size()         const { return _segment_size; }  // for CodeHeapState
181   HeapBlock* first_block() const;                                // for CodeHeapState
182   HeapBlock* next_block(HeapBlock* b) const;                     // for CodeHeapState
<a name="12" id="anc12"></a>
183 
184   FreeBlock* freelist()         const { return _freelist; }      // for CodeHeapState
185 
186   size_t allocated_in_freelist() const           { return _freelist_segments * CodeCacheSegmentSize; }
187   int    freelist_length()       const           { return _freelist_length; } // number of elements in the freelist
188 
189   // returns the first block or NULL
190   virtual void* first() const                    { return next_used(first_block()); }
191   // returns the next block given a block p or NULL
192   virtual void* next(void* p) const              { return next_used(next_block(block_start(p))); }
193 
194   // Statistics
195   size_t capacity() const;
196   size_t max_capacity() const;
197   int    allocated_segments() const;
198   size_t allocated_capacity() const;
199   size_t max_allocated_capacity() const          { return _max_allocated_capacity; }
200   size_t unallocated_capacity() const            { return max_capacity() - allocated_capacity(); }
201 
202   // Returns true if the CodeHeap contains CodeBlobs of the given type
203   bool accepts(int code_blob_type) const         { return (_code_blob_type == CodeBlobType::All) ||
204                                                           (_code_blob_type == code_blob_type); }
205   int code_blob_type() const                     { return _code_blob_type; }
206 
207   // Debugging / Profiling
208   const char* name() const                       { return _name; }
209   int         blob_count()                       { return _blob_count; }
210   int         nmethod_count()                    { return _nmethod_count; }
211   void    set_nmethod_count(int count)           {        _nmethod_count = count; }
212   int         adapter_count()                    { return _adapter_count; }
213   void    set_adapter_count(int count)           {        _adapter_count = count; }
214   int         full_count()                       { return _full_count; }
215   void        report_full()                      {        _full_count++; }
216 
217 private:
218   size_t heap_unallocated_capacity() const;
<a name="13" id="anc13"></a>

219 
220 public:
221   // Debugging
222   void verify() PRODUCT_RETURN;
223   void print()  PRODUCT_RETURN;
224 };
225 
226 #endif // SHARE_MEMORY_HEAP_HPP
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
diff a/src/hotspot/share/memory/virtualspace.cpp b/src/hotspot/share/memory/virtualspace.cpp
--- a/src/hotspot/share/memory/virtualspace.cpp
+++ b/src/hotspot/share/memory/virtualspace.cpp
@@ -24,15 +24,17 @@
 
 #include "precompiled.hpp"
 #include "logging/log.hpp"
 #include "memory/resourceArea.hpp"
 #include "memory/virtualspace.hpp"
-#include "oops/markOop.hpp"
+#include "oops/compressedOops.hpp"
+#include "oops/markWord.hpp"
 #include "oops/oop.inline.hpp"
 #include "runtime/os.inline.hpp"
 #include "services/memTracker.hpp"
 #include "utilities/align.hpp"
+#include "utilities/powerOfTwo.hpp"
 
 // ReservedSpace
 
 // Dummy constructor
 ReservedSpace::ReservedSpace() : _base(NULL), _size(0), _noaccess_prefix(0),
@@ -307,13 +309,13 @@
       }
       log_debug(gc, heap, coops)("Protected page at the reserved heap base: "
                                  PTR_FORMAT " / " INTX_FORMAT " bytes",
                                  p2i(_base),
                                  _noaccess_prefix);
-      assert(Universe::narrow_oop_use_implicit_null_checks() == true, "not initialized?");
+      assert(CompressedOops::use_implicit_null_checks() == true, "not initialized?");
     } else {
-      Universe::set_narrow_oop_use_implicit_null_checks(false);
+      CompressedOops::set_use_implicit_null_checks(false);
     }
   }
 
   _base += _noaccess_prefix;
   _size -= _noaccess_prefix;
@@ -576,11 +578,11 @@
     char** addresses = get_attach_addresses_for_disjoint_mode();
     int i = 0;
     while (addresses[i] &&                                 // End of array not yet reached.
            ((_base == NULL) ||                             // No previous try succeeded.
             (_base + size >  (char *)OopEncodingHeapMax && // Not zerobased or unscaled address.
-             !Universe::is_disjoint_heap_base_address((address)_base)))) {  // Not disjoint address.
+             !CompressedOops::is_disjoint_heap_base_address((address)_base)))) {  // Not disjoint address.
       char* const attach_point = addresses[i];
       assert(attach_point >= aligned_heap_base_min_address, "Flag support broken");
       try_reserve_heap(size + noaccess_prefix, alignment, large, attach_point);
       i++;
     }
@@ -620,13 +622,13 @@
     }
   } else {
     initialize(size, alignment, large, NULL, false);
   }
 
-  assert(markOopDesc::encode_pointer_as_mark(_base)->decode_pointer() == _base,
+  assert(markWord::encode_pointer_as_mark(_base).decode_pointer() == _base,
          "area must be distinguishable from marks for mark-sweep");
-  assert(markOopDesc::encode_pointer_as_mark(&_base[size])->decode_pointer() == &_base[size],
+  assert(markWord::encode_pointer_as_mark(&_base[size]).decode_pointer() == &_base[size],
          "area must be distinguishable from marks for mark-sweep");
 
   if (base() != NULL) {
     MemTracker::record_virtual_memory_type((address)base(), mtJavaHeap);
   }
@@ -634,10 +636,14 @@
   if (_fd_for_heap != -1) {
     os::close(_fd_for_heap);
   }
 }
 
+MemRegion ReservedHeapSpace::region() const {
+  return MemRegion((HeapWord*)base(), (HeapWord*)end());
+}
+
 // Reserve space for code segment.  Same as Java heap only we mark this as
 // executable.
 ReservedCodeSpace::ReservedCodeSpace(size_t r_size,
                                      size_t rs_align,
                                      bool large) :

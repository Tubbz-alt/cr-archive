<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/memory/heapInspection.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/classLoaderData.inline.hpp&quot;
 27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
 28 #include &quot;classfile/moduleEntry.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;gc/shared/collectedHeap.hpp&quot;
<a name="2" id="anc2"></a>

 31 #include &quot;memory/heapInspection.hpp&quot;
 32 #include &quot;memory/resourceArea.hpp&quot;
<a name="3" id="anc3"></a>
 33 #include &quot;oops/oop.inline.hpp&quot;
 34 #include &quot;oops/reflectionAccessorImplKlassHelper.hpp&quot;
 35 #include &quot;runtime/os.hpp&quot;
 36 #include &quot;utilities/globalDefinitions.hpp&quot;
 37 #include &quot;utilities/macros.hpp&quot;
 38 #include &quot;utilities/stack.inline.hpp&quot;
 39 
 40 // HeapInspection
 41 
<a name="4" id="anc4"></a><span class="line-removed"> 42 int KlassSizeStats::count(oop x) {</span>
<span class="line-removed"> 43   return (HeapWordSize * (((x) != NULL) ? (x)-&gt;size() : 0));</span>
<span class="line-removed"> 44 }</span>
<span class="line-removed"> 45 </span>
<span class="line-removed"> 46 int KlassSizeStats::count_array(objArrayOop x) {</span>
<span class="line-removed"> 47   return (HeapWordSize * (((x) != NULL) ? (x)-&gt;size() : 0));</span>
<span class="line-removed"> 48 }</span>
<span class="line-removed"> 49 </span>
 50 inline KlassInfoEntry::~KlassInfoEntry() {
 51   if (_subclasses != NULL) {
 52     delete _subclasses;
 53   }
 54 }
 55 
 56 inline void KlassInfoEntry::add_subclass(KlassInfoEntry* cie) {
 57   if (_subclasses == NULL) {
 58     _subclasses = new  (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;KlassInfoEntry*&gt;(4, true);
 59   }
 60   _subclasses-&gt;append(cie);
 61 }
 62 
 63 int KlassInfoEntry::compare(KlassInfoEntry* e1, KlassInfoEntry* e2) {
 64   if(e1-&gt;_instance_words &gt; e2-&gt;_instance_words) {
 65     return -1;
 66   } else if(e1-&gt;_instance_words &lt; e2-&gt;_instance_words) {
 67     return 1;
 68   }
 69   // Sort alphabetically, note &#39;Z&#39; &lt; &#39;[&#39; &lt; &#39;a&#39;, but it&#39;s better to group
 70   // the array classes before all the instance classes.
 71   ResourceMark rm;
 72   const char* name1 = e1-&gt;klass()-&gt;external_name();
 73   const char* name2 = e2-&gt;klass()-&gt;external_name();
<a name="5" id="anc5"></a><span class="line-modified"> 74   bool d1 = (name1[0] == &#39;[&#39;);</span>
<span class="line-modified"> 75   bool d2 = (name2[0] == &#39;[&#39;);</span>
 76   if (d1 &amp;&amp; !d2) {
 77     return -1;
 78   } else if (d2 &amp;&amp; !d1) {
 79     return 1;
 80   } else {
 81     return strcmp(name1, name2);
 82   }
 83 }
 84 
 85 const char* KlassInfoEntry::name() const {
 86   const char* name;
 87   if (_klass-&gt;name() != NULL) {
 88     name = _klass-&gt;external_name();
 89   } else {
 90     if (_klass == Universe::boolArrayKlassObj())         name = &quot;&lt;boolArrayKlass&gt;&quot;;         else
 91     if (_klass == Universe::charArrayKlassObj())         name = &quot;&lt;charArrayKlass&gt;&quot;;         else
 92     if (_klass == Universe::floatArrayKlassObj())        name = &quot;&lt;floatArrayKlass&gt;&quot;;        else
 93     if (_klass == Universe::doubleArrayKlassObj())       name = &quot;&lt;doubleArrayKlass&gt;&quot;;       else
 94     if (_klass == Universe::byteArrayKlassObj())         name = &quot;&lt;byteArrayKlass&gt;&quot;;         else
 95     if (_klass == Universe::shortArrayKlassObj())        name = &quot;&lt;shortArrayKlass&gt;&quot;;        else
 96     if (_klass == Universe::intArrayKlassObj())          name = &quot;&lt;intArrayKlass&gt;&quot;;          else
 97     if (_klass == Universe::longArrayKlassObj())         name = &quot;&lt;longArrayKlass&gt;&quot;;         else
 98       name = &quot;&lt;no name&gt;&quot;;
 99   }
100   return name;
101 }
102 
103 void KlassInfoEntry::print_on(outputStream* st) const {
104   ResourceMark rm;
105 
106   // simplify the formatting (ILP32 vs LP64) - always cast the numbers to 64-bit
107   ModuleEntry* module = _klass-&gt;module();
108   if (module-&gt;is_named()) {
109     st-&gt;print_cr(INT64_FORMAT_W(13) &quot;  &quot; UINT64_FORMAT_W(13) &quot;  %s (%s@%s)&quot;,
110                  (int64_t)_instance_count,
111                  (uint64_t)_instance_words * HeapWordSize,
112                  name(),
113                  module-&gt;name()-&gt;as_C_string(),
114                  module-&gt;version() != NULL ? module-&gt;version()-&gt;as_C_string() : &quot;&quot;);
115   } else {
116     st-&gt;print_cr(INT64_FORMAT_W(13) &quot;  &quot; UINT64_FORMAT_W(13) &quot;  %s&quot;,
117                  (int64_t)_instance_count,
118                  (uint64_t)_instance_words * HeapWordSize,
119                  name());
120   }
121 }
122 
123 KlassInfoEntry* KlassInfoBucket::lookup(Klass* const k) {
<a name="6" id="anc6"></a>




124   KlassInfoEntry* elt = _list;
125   while (elt != NULL) {
126     if (elt-&gt;is_equal(k)) {
127       return elt;
128     }
129     elt = elt-&gt;next();
130   }
131   elt = new (std::nothrow) KlassInfoEntry(k, list());
132   // We may be out of space to allocate the new entry.
133   if (elt != NULL) {
134     set_list(elt);
135   }
136   return elt;
137 }
138 
139 void KlassInfoBucket::iterate(KlassInfoClosure* cic) {
140   KlassInfoEntry* elt = _list;
141   while (elt != NULL) {
142     cic-&gt;do_cinfo(elt);
143     elt = elt-&gt;next();
144   }
145 }
146 
147 void KlassInfoBucket::empty() {
148   KlassInfoEntry* elt = _list;
149   _list = NULL;
150   while (elt != NULL) {
151     KlassInfoEntry* next = elt-&gt;next();
152     delete elt;
153     elt = next;
154   }
155 }
156 
157 class KlassInfoTable::AllClassesFinder : public LockedClassesDo {
158   KlassInfoTable *_table;
159 public:
160   AllClassesFinder(KlassInfoTable* table) : _table(table) {}
161   virtual void do_klass(Klass* k) {
162     // This has the SIDE EFFECT of creating a KlassInfoEntry
163     // for &lt;k&gt;, if one doesn&#39;t exist yet.
164     _table-&gt;lookup(k);
165   }
166 };
167 
168 
169 KlassInfoTable::KlassInfoTable(bool add_all_classes) {
170   _size_of_instances_in_words = 0;
171   _ref = (HeapWord*) Universe::boolArrayKlassObj();
172   _buckets =
173     (KlassInfoBucket*)  AllocateHeap(sizeof(KlassInfoBucket) * _num_buckets,
174        mtInternal, CURRENT_PC, AllocFailStrategy::RETURN_NULL);
175   if (_buckets != NULL) {
176     for (int index = 0; index &lt; _num_buckets; index++) {
177       _buckets[index].initialize();
178     }
179     if (add_all_classes) {
180       AllClassesFinder finder(this);
181       ClassLoaderDataGraph::classes_do(&amp;finder);
182     }
183   }
184 }
185 
186 KlassInfoTable::~KlassInfoTable() {
187   if (_buckets != NULL) {
188     for (int index = 0; index &lt; _num_buckets; index++) {
189       _buckets[index].empty();
190     }
191     FREE_C_HEAP_ARRAY(KlassInfoBucket, _buckets);
192     _buckets = NULL;
193   }
194 }
195 
196 uint KlassInfoTable::hash(const Klass* p) {
197   return (uint)(((uintptr_t)p - (uintptr_t)_ref) &gt;&gt; 2);
198 }
199 
200 KlassInfoEntry* KlassInfoTable::lookup(Klass* k) {
201   uint         idx = hash(k) % _num_buckets;
202   assert(_buckets != NULL, &quot;Allocation failure should have been caught&quot;);
203   KlassInfoEntry*  e   = _buckets[idx].lookup(k);
204   // Lookup may fail if this is a new klass for which we
<a name="7" id="anc7"></a><span class="line-modified">205   // could not allocate space for an new entry.</span>

206   assert(e == NULL || k == e-&gt;klass(), &quot;must be equal&quot;);
207   return e;
208 }
209 
210 // Return false if the entry could not be recorded on account
211 // of running out of space required to create a new entry.
212 bool KlassInfoTable::record_instance(const oop obj) {
213   Klass*        k = obj-&gt;klass();
214   KlassInfoEntry* elt = lookup(k);
215   // elt may be NULL if it&#39;s a new klass for which we
216   // could not allocate space for a new entry in the hashtable.
217   if (elt != NULL) {
218     elt-&gt;set_count(elt-&gt;count() + 1);
219     elt-&gt;set_words(elt-&gt;words() + obj-&gt;size());
220     _size_of_instances_in_words += obj-&gt;size();
221     return true;
222   } else {
223     return false;
224   }
225 }
226 
227 void KlassInfoTable::iterate(KlassInfoClosure* cic) {
228   assert(_buckets != NULL, &quot;Allocation failure should have been caught&quot;);
229   for (int index = 0; index &lt; _num_buckets; index++) {
230     _buckets[index].iterate(cic);
231   }
232 }
233 
234 size_t KlassInfoTable::size_of_instances_in_words() const {
235   return _size_of_instances_in_words;
236 }
237 
238 int KlassInfoHisto::sort_helper(KlassInfoEntry** e1, KlassInfoEntry** e2) {
239   return (*e1)-&gt;compare(*e1,*e2);
240 }
241 
242 KlassInfoHisto::KlassInfoHisto(KlassInfoTable* cit) :
243   _cit(cit) {
244   _elements = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;KlassInfoEntry*&gt;(_histo_initial_size, true);
245 }
246 
247 KlassInfoHisto::~KlassInfoHisto() {
248   delete _elements;
249 }
250 
251 void KlassInfoHisto::add(KlassInfoEntry* cie) {
252   elements()-&gt;append(cie);
253 }
254 
255 void KlassInfoHisto::sort() {
256   elements()-&gt;sort(KlassInfoHisto::sort_helper);
257 }
258 
259 void KlassInfoHisto::print_elements(outputStream* st) const {
260   // simplify the formatting (ILP32 vs LP64) - store the sum in 64-bit
261   int64_t total = 0;
262   uint64_t totalw = 0;
263   for(int i=0; i &lt; elements()-&gt;length(); i++) {
264     st-&gt;print(&quot;%4d: &quot;, i+1);
265     elements()-&gt;at(i)-&gt;print_on(st);
266     total += elements()-&gt;at(i)-&gt;count();
267     totalw += elements()-&gt;at(i)-&gt;words();
268   }
269   st-&gt;print_cr(&quot;Total &quot; INT64_FORMAT_W(13) &quot;  &quot; UINT64_FORMAT_W(13),
270                total, totalw * HeapWordSize);
271 }
272 
<a name="8" id="anc8"></a><span class="line-removed">273 #define MAKE_COL_NAME(field, name, help)     #name,</span>
<span class="line-removed">274 #define MAKE_COL_HELP(field, name, help)     help,</span>
<span class="line-removed">275 </span>
<span class="line-removed">276 static const char *name_table[] = {</span>
<span class="line-removed">277   HEAP_INSPECTION_COLUMNS_DO(MAKE_COL_NAME)</span>
<span class="line-removed">278 };</span>
<span class="line-removed">279 </span>
<span class="line-removed">280 static const char *help_table[] = {</span>
<span class="line-removed">281   HEAP_INSPECTION_COLUMNS_DO(MAKE_COL_HELP)</span>
<span class="line-removed">282 };</span>
<span class="line-removed">283 </span>
<span class="line-removed">284 bool KlassInfoHisto::is_selected(const char *col_name) {</span>
<span class="line-removed">285   if (_selected_columns == NULL) {</span>
<span class="line-removed">286     return true;</span>
<span class="line-removed">287   }</span>
<span class="line-removed">288   if (strcmp(_selected_columns, col_name) == 0) {</span>
<span class="line-removed">289     return true;</span>
<span class="line-removed">290   }</span>
<span class="line-removed">291 </span>
<span class="line-removed">292   const char *start = strstr(_selected_columns, col_name);</span>
<span class="line-removed">293   if (start == NULL) {</span>
<span class="line-removed">294     return false;</span>
<span class="line-removed">295   }</span>
<span class="line-removed">296 </span>
<span class="line-removed">297   // The following must be true, because _selected_columns != col_name</span>
<span class="line-removed">298   if (start &gt; _selected_columns &amp;&amp; start[-1] != &#39;,&#39;) {</span>
<span class="line-removed">299     return false;</span>
<span class="line-removed">300   }</span>
<span class="line-removed">301   char x = start[strlen(col_name)];</span>
<span class="line-removed">302   if (x != &#39;,&#39; &amp;&amp; x != &#39;\0&#39;) {</span>
<span class="line-removed">303     return false;</span>
<span class="line-removed">304   }</span>
<span class="line-removed">305 </span>
<span class="line-removed">306   return true;</span>
<span class="line-removed">307 }</span>
<span class="line-removed">308 </span>
<span class="line-removed">309 void KlassInfoHisto::print_title(outputStream* st, bool csv_format,</span>
<span class="line-removed">310                                  bool selected[], int width_table[],</span>
<span class="line-removed">311                                  const char *name_table[]) {</span>
<span class="line-removed">312   if (csv_format) {</span>
<span class="line-removed">313     st-&gt;print(&quot;Index,Super&quot;);</span>
<span class="line-removed">314     for (int c=0; c&lt;KlassSizeStats::_num_columns; c++) {</span>
<span class="line-removed">315        if (selected[c]) {st-&gt;print(&quot;,%s&quot;, name_table[c]);}</span>
<span class="line-removed">316     }</span>
<span class="line-removed">317     st-&gt;print(&quot;,ClassName&quot;);</span>
<span class="line-removed">318   } else {</span>
<span class="line-removed">319     st-&gt;print(&quot;Index Super&quot;);</span>
<span class="line-removed">320     for (int c = 0; c &lt; KlassSizeStats::_num_columns; c++) {</span>
<span class="line-removed">321       if (selected[c]) {</span>
<span class="line-removed">322         st-&gt;print(&quot;%*s&quot;, width_table[c], name_table[c]);</span>
<span class="line-removed">323       }</span>
<span class="line-removed">324     }</span>
<span class="line-removed">325     st-&gt;print(&quot; ClassName&quot;);</span>
<span class="line-removed">326   }</span>
<span class="line-removed">327 </span>
<span class="line-removed">328   if (is_selected(&quot;ClassLoader&quot;)) {</span>
<span class="line-removed">329     st-&gt;print(&quot;,ClassLoader&quot;);</span>
<span class="line-removed">330   }</span>
<span class="line-removed">331   st-&gt;cr();</span>
<span class="line-removed">332 }</span>
<span class="line-removed">333 </span>
334 class HierarchyClosure : public KlassInfoClosure {
335 private:
336   GrowableArray&lt;KlassInfoEntry*&gt; *_elements;
337 public:
338   HierarchyClosure(GrowableArray&lt;KlassInfoEntry*&gt; *_elements) : _elements(_elements) {}
339 
340   void do_cinfo(KlassInfoEntry* cie) {
341     // ignore array classes
342     if (cie-&gt;klass()-&gt;is_instance_klass()) {
343       _elements-&gt;append(cie);
344     }
345   }
346 };
347 
348 void KlassHierarchy::print_class_hierarchy(outputStream* st, bool print_interfaces,
349                                            bool print_subclasses, char* classname) {
350   ResourceMark rm;
351   Stack &lt;KlassInfoEntry*, mtClass&gt; class_stack;
352   GrowableArray&lt;KlassInfoEntry*&gt; elements;
353 
354   // Add all classes to the KlassInfoTable, which allows for quick lookup.
355   // A KlassInfoEntry will be created for each class.
356   KlassInfoTable cit(true);
357   if (cit.allocation_failed()) {
358     st-&gt;print_cr(&quot;ERROR: Ran out of C-heap; hierarchy not generated&quot;);
359     return;
360   }
361 
362   // Add all created KlassInfoEntry instances to the elements array for easy
363   // iteration, and to allow each KlassInfoEntry instance to have a unique index.
364   HierarchyClosure hc(&amp;elements);
365   cit.iterate(&amp;hc);
366 
367   for(int i = 0; i &lt; elements.length(); i++) {
368     KlassInfoEntry* cie = elements.at(i);
369     Klass* super = cie-&gt;klass()-&gt;super();
370 
371     // Set the index for the class.
372     cie-&gt;set_index(i + 1);
373 
374     // Add the class to the subclass array of its superclass.
375     if (super != NULL) {
376       KlassInfoEntry* super_cie = cit.lookup(super);
377       assert(super_cie != NULL, &quot;could not lookup superclass&quot;);
378       super_cie-&gt;add_subclass(cie);
379     }
380   }
381 
382   // Set the do_print flag for each class that should be printed.
383   for(int i = 0; i &lt; elements.length(); i++) {
384     KlassInfoEntry* cie = elements.at(i);
385     if (classname == NULL) {
386       // We are printing all classes.
387       cie-&gt;set_do_print(true);
388     } else {
389       // We are only printing the hierarchy of a specific class.
390       if (strcmp(classname, cie-&gt;klass()-&gt;external_name()) == 0) {
391         KlassHierarchy::set_do_print_for_class_hierarchy(cie, &amp;cit, print_subclasses);
392       }
393     }
394   }
395 
396   // Now we do a depth first traversal of the class hierachry. The class_stack will
397   // maintain the list of classes we still need to process. Start things off
398   // by priming it with java.lang.Object.
399   KlassInfoEntry* jlo_cie = cit.lookup(SystemDictionary::Object_klass());
400   assert(jlo_cie != NULL, &quot;could not lookup java.lang.Object&quot;);
401   class_stack.push(jlo_cie);
402 
403   // Repeatedly pop the top item off the stack, print its class info,
404   // and push all of its subclasses on to the stack. Do this until there
405   // are no classes left on the stack.
406   while (!class_stack.is_empty()) {
407     KlassInfoEntry* curr_cie = class_stack.pop();
408     if (curr_cie-&gt;do_print()) {
409       print_class(st, curr_cie, print_interfaces);
410       if (curr_cie-&gt;subclasses() != NULL) {
411         // Current class has subclasses, so push all of them onto the stack.
412         for (int i = 0; i &lt; curr_cie-&gt;subclasses()-&gt;length(); i++) {
413           KlassInfoEntry* cie = curr_cie-&gt;subclasses()-&gt;at(i);
414           if (cie-&gt;do_print()) {
415             class_stack.push(cie);
416           }
417         }
418       }
419     }
420   }
421 
422   st-&gt;flush();
423 }
424 
425 // Sets the do_print flag for every superclass and subclass of the specified class.
426 void KlassHierarchy::set_do_print_for_class_hierarchy(KlassInfoEntry* cie, KlassInfoTable* cit,
427                                                       bool print_subclasses) {
428   // Set do_print for all superclasses of this class.
429   Klass* super = ((InstanceKlass*)cie-&gt;klass())-&gt;java_super();
430   while (super != NULL) {
431     KlassInfoEntry* super_cie = cit-&gt;lookup(super);
432     super_cie-&gt;set_do_print(true);
433     super = super-&gt;super();
434   }
435 
436   // Set do_print for this class and all of its subclasses.
437   Stack &lt;KlassInfoEntry*, mtClass&gt; class_stack;
438   class_stack.push(cie);
439   while (!class_stack.is_empty()) {
440     KlassInfoEntry* curr_cie = class_stack.pop();
441     curr_cie-&gt;set_do_print(true);
442     if (print_subclasses &amp;&amp; curr_cie-&gt;subclasses() != NULL) {
443       // Current class has subclasses, so push all of them onto the stack.
444       for (int i = 0; i &lt; curr_cie-&gt;subclasses()-&gt;length(); i++) {
445         KlassInfoEntry* cie = curr_cie-&gt;subclasses()-&gt;at(i);
446         class_stack.push(cie);
447       }
448     }
449   }
450 }
451 
452 static void print_indent(outputStream* st, int indent) {
453   while (indent != 0) {
454     st-&gt;print(&quot;|&quot;);
455     indent--;
456     if (indent != 0) {
457       st-&gt;print(&quot;  &quot;);
458     }
459   }
460 }
461 
462 // Print the class name and its unique ClassLoader identifer.
463 static void print_classname(outputStream* st, Klass* klass) {
464   oop loader_oop = klass-&gt;class_loader_data()-&gt;class_loader();
465   st-&gt;print(&quot;%s/&quot;, klass-&gt;external_name());
466   if (loader_oop == NULL) {
467     st-&gt;print(&quot;null&quot;);
468   } else {
469     st-&gt;print(INTPTR_FORMAT, p2i(klass-&gt;class_loader_data()));
470   }
471 }
472 
473 static void print_interface(outputStream* st, InstanceKlass* intf_klass, const char* intf_type, int indent) {
474   print_indent(st, indent);
475   st-&gt;print(&quot;  implements &quot;);
476   print_classname(st, intf_klass);
477   st-&gt;print(&quot; (%s intf)\n&quot;, intf_type);
478 }
479 
480 void KlassHierarchy::print_class(outputStream* st, KlassInfoEntry* cie, bool print_interfaces) {
481   ResourceMark rm;
482   InstanceKlass* klass = (InstanceKlass*)cie-&gt;klass();
483   int indent = 0;
484 
485   // Print indentation with proper indicators of superclass.
486   Klass* super = klass-&gt;super();
487   while (super != NULL) {
488     super = super-&gt;super();
489     indent++;
490   }
491   print_indent(st, indent);
492   if (indent != 0) st-&gt;print(&quot;--&quot;);
493 
494   // Print the class name, its unique ClassLoader identifer, and if it is an interface.
495   print_classname(st, klass);
496   if (klass-&gt;is_interface()) {
497     st-&gt;print(&quot; (intf)&quot;);
498   }
499   // Special treatment for generated core reflection accessor classes: print invocation target.
500   if (ReflectionAccessorImplKlassHelper::is_generated_accessor(klass)) {
501     st-&gt;print(&quot; (invokes: &quot;);
502     ReflectionAccessorImplKlassHelper::print_invocation_target(st, klass);
503     st-&gt;print(&quot;)&quot;);
504   }
505   st-&gt;print(&quot;\n&quot;);
506 
507   // Print any interfaces the class has.
508   if (print_interfaces) {
509     Array&lt;InstanceKlass*&gt;* local_intfs = klass-&gt;local_interfaces();
510     Array&lt;InstanceKlass*&gt;* trans_intfs = klass-&gt;transitive_interfaces();
511     for (int i = 0; i &lt; local_intfs-&gt;length(); i++) {
512       print_interface(st, local_intfs-&gt;at(i), &quot;declared&quot;, indent);
513     }
514     for (int i = 0; i &lt; trans_intfs-&gt;length(); i++) {
515       InstanceKlass* trans_interface = trans_intfs-&gt;at(i);
516       // Only print transitive interfaces if they are not also declared.
517       if (!local_intfs-&gt;contains(trans_interface)) {
518         print_interface(st, trans_interface, &quot;inherited&quot;, indent);
519       }
520     }
521   }
522 }
523 
<a name="9" id="anc9"></a><span class="line-modified">524 void KlassInfoHisto::print_class_stats(outputStream* st,</span>
<span class="line-modified">525                                       bool csv_format, const char *columns) {</span>
<span class="line-modified">526   ResourceMark rm;</span>
<span class="line-modified">527   KlassSizeStats sz, sz_sum;</span>
<span class="line-removed">528   int i;</span>
<span class="line-removed">529   julong *col_table = (julong*)(&amp;sz);</span>
<span class="line-removed">530   julong *colsum_table = (julong*)(&amp;sz_sum);</span>
<span class="line-removed">531   int width_table[KlassSizeStats::_num_columns];</span>
<span class="line-removed">532   bool selected[KlassSizeStats::_num_columns];</span>
<span class="line-removed">533 </span>
<span class="line-removed">534   _selected_columns = columns;</span>
<span class="line-removed">535 </span>
<span class="line-removed">536   memset(&amp;sz_sum, 0, sizeof(sz_sum));</span>
<span class="line-removed">537   for (int c=0; c&lt;KlassSizeStats::_num_columns; c++) {</span>
<span class="line-removed">538     selected[c] = is_selected(name_table[c]);</span>
<span class="line-removed">539   }</span>
<span class="line-removed">540 </span>
<span class="line-removed">541   for(i=0; i &lt; elements()-&gt;length(); i++) {</span>
<span class="line-removed">542     elements()-&gt;at(i)-&gt;set_index(i+1);</span>
<span class="line-removed">543   }</span>
<span class="line-removed">544 </span>
<span class="line-removed">545   // First iteration is for accumulating stats totals in colsum_table[].</span>
<span class="line-removed">546   // Second iteration is for printing stats for each class.</span>
<span class="line-removed">547   for (int pass=1; pass&lt;=2; pass++) {</span>
<span class="line-removed">548     if (pass == 2) {</span>
<span class="line-removed">549       print_title(st, csv_format, selected, width_table, name_table);</span>
<span class="line-removed">550     }</span>
<span class="line-removed">551     for(i=0; i &lt; elements()-&gt;length(); i++) {</span>
<span class="line-removed">552       KlassInfoEntry* e = (KlassInfoEntry*)elements()-&gt;at(i);</span>
<span class="line-removed">553       const Klass* k = e-&gt;klass();</span>
<span class="line-removed">554 </span>
<span class="line-removed">555       // Get the stats for this class.</span>
<span class="line-removed">556       memset(&amp;sz, 0, sizeof(sz));</span>
<span class="line-removed">557       sz._inst_count = e-&gt;count();</span>
<span class="line-removed">558       sz._inst_bytes = HeapWordSize * e-&gt;words();</span>
<span class="line-removed">559       k-&gt;collect_statistics(&amp;sz);</span>
<span class="line-removed">560       sz._total_bytes = sz._ro_bytes + sz._rw_bytes;</span>
<span class="line-removed">561 </span>
<span class="line-removed">562       if (pass == 1) {</span>
<span class="line-removed">563         // Add the stats for this class to the overall totals.</span>
<span class="line-removed">564         for (int c=0; c&lt;KlassSizeStats::_num_columns; c++) {</span>
<span class="line-removed">565           colsum_table[c] += col_table[c];</span>
<span class="line-removed">566         }</span>
<span class="line-removed">567       } else {</span>
<span class="line-removed">568         int super_index = -1;</span>
<span class="line-removed">569         // Print the stats for this class.</span>
<span class="line-removed">570         if (k-&gt;is_instance_klass()) {</span>
<span class="line-removed">571           Klass* super = k-&gt;super();</span>
<span class="line-removed">572           if (super) {</span>
<span class="line-removed">573             KlassInfoEntry* super_e = _cit-&gt;lookup(super);</span>
<span class="line-removed">574             if (super_e) {</span>
<span class="line-removed">575               super_index = super_e-&gt;index();</span>
<span class="line-removed">576             }</span>
<span class="line-removed">577           }</span>
<span class="line-removed">578         }</span>
<span class="line-removed">579 </span>
<span class="line-removed">580         if (csv_format) {</span>
<span class="line-removed">581           st-&gt;print(&quot;%ld,%d&quot;, e-&gt;index(), super_index);</span>
<span class="line-removed">582           for (int c=0; c&lt;KlassSizeStats::_num_columns; c++) {</span>
<span class="line-removed">583             if (selected[c]) {st-&gt;print(&quot;,&quot; JULONG_FORMAT, col_table[c]);}</span>
<span class="line-removed">584           }</span>
<span class="line-removed">585           st-&gt;print(&quot;,%s&quot;,e-&gt;name());</span>
<span class="line-removed">586         } else {</span>
<span class="line-removed">587           st-&gt;print(&quot;%5ld %5d&quot;, e-&gt;index(), super_index);</span>
<span class="line-removed">588           for (int c=0; c&lt;KlassSizeStats::_num_columns; c++) {</span>
<span class="line-removed">589             if (selected[c]) {print_julong(st, width_table[c], col_table[c]);}</span>
<span class="line-removed">590           }</span>
<span class="line-removed">591           st-&gt;print(&quot; %s&quot;, e-&gt;name());</span>
<span class="line-removed">592         }</span>
<span class="line-removed">593         if (is_selected(&quot;ClassLoader&quot;)) {</span>
<span class="line-removed">594           ClassLoaderData* loader_data = k-&gt;class_loader_data();</span>
<span class="line-removed">595           st-&gt;print(&quot;,&quot;);</span>
<span class="line-removed">596           loader_data-&gt;print_value_on(st);</span>
<span class="line-removed">597         }</span>
<span class="line-removed">598         st-&gt;cr();</span>
<span class="line-removed">599       }</span>
<span class="line-removed">600     }</span>
<span class="line-removed">601 </span>
<span class="line-removed">602     if (pass == 1) {</span>
<span class="line-removed">603       // Calculate the minimum width needed for the column by accounting for the</span>
<span class="line-removed">604       // column header width and the width of the largest value in the column.</span>
<span class="line-removed">605       for (int c=0; c&lt;KlassSizeStats::_num_columns; c++) {</span>
<span class="line-removed">606         width_table[c] = col_width(colsum_table[c], name_table[c]);</span>
<span class="line-removed">607       }</span>
<span class="line-removed">608     }</span>
<span class="line-removed">609   }</span>
<span class="line-removed">610 </span>
<span class="line-removed">611   sz_sum._inst_size = 0;</span>
<span class="line-removed">612 </span>
<span class="line-removed">613   // Print the column totals.</span>
<span class="line-removed">614   if (csv_format) {</span>
<span class="line-removed">615     st-&gt;print(&quot;,&quot;);</span>
<span class="line-removed">616     for (int c=0; c&lt;KlassSizeStats::_num_columns; c++) {</span>
<span class="line-removed">617       if (selected[c]) {st-&gt;print(&quot;,&quot; JULONG_FORMAT, colsum_table[c]);}</span>
<span class="line-removed">618     }</span>
<span class="line-removed">619   } else {</span>
<span class="line-removed">620     st-&gt;print(&quot;           &quot;);</span>
<span class="line-removed">621     for (int c=0; c&lt;KlassSizeStats::_num_columns; c++) {</span>
<span class="line-removed">622       if (selected[c]) {print_julong(st, width_table[c], colsum_table[c]);}</span>
<span class="line-removed">623     }</span>
<span class="line-removed">624     st-&gt;print(&quot; Total&quot;);</span>
<span class="line-removed">625     if (sz_sum._total_bytes &gt; 0) {</span>
<span class="line-removed">626       st-&gt;cr();</span>
<span class="line-removed">627       st-&gt;print(&quot;           &quot;);</span>
<span class="line-removed">628       for (int c=0; c&lt;KlassSizeStats::_num_columns; c++) {</span>
<span class="line-removed">629         if (selected[c]) {</span>
<span class="line-removed">630           switch (c) {</span>
<span class="line-removed">631           case KlassSizeStats::_index_inst_size:</span>
<span class="line-removed">632           case KlassSizeStats::_index_inst_count:</span>
<span class="line-removed">633           case KlassSizeStats::_index_method_count:</span>
<span class="line-removed">634             st-&gt;print(&quot;%*s&quot;, width_table[c], &quot;-&quot;);</span>
<span class="line-removed">635             break;</span>
<span class="line-removed">636           default:</span>
<span class="line-removed">637             {</span>
<span class="line-removed">638               double perc = (double)(100) * (double)(colsum_table[c]) / (double)sz_sum._total_bytes;</span>
<span class="line-removed">639               st-&gt;print(&quot;%*.1f%%&quot;, width_table[c]-1, perc);</span>
<span class="line-removed">640             }</span>
<span class="line-removed">641           }</span>
<span class="line-removed">642         }</span>
<span class="line-removed">643       }</span>
<span class="line-removed">644     }</span>
<span class="line-removed">645   }</span>
<span class="line-removed">646   st-&gt;cr();</span>
<span class="line-removed">647 </span>
<span class="line-removed">648   if (!csv_format) {</span>
<span class="line-removed">649     print_title(st, csv_format, selected, width_table, name_table);</span>
<span class="line-removed">650   }</span>
<span class="line-removed">651 }</span>
<span class="line-removed">652 </span>
<span class="line-removed">653 julong KlassInfoHisto::annotations_bytes(Array&lt;AnnotationArray*&gt;* p) const {</span>
<span class="line-removed">654   julong bytes = 0;</span>
<span class="line-removed">655   if (p != NULL) {</span>
<span class="line-removed">656     for (int i = 0; i &lt; p-&gt;length(); i++) {</span>
<span class="line-removed">657       bytes += count_bytes_array(p-&gt;at(i));</span>
<span class="line-removed">658     }</span>
<span class="line-removed">659     bytes += count_bytes_array(p);</span>
<span class="line-removed">660   }</span>
<span class="line-removed">661   return bytes;</span>
<span class="line-removed">662 }</span>
<span class="line-removed">663 </span>
<span class="line-removed">664 void KlassInfoHisto::print_histo_on(outputStream* st, bool print_stats,</span>
<span class="line-removed">665                                     bool csv_format, const char *columns) {</span>
<span class="line-removed">666   if (print_stats) {</span>
<span class="line-removed">667     print_class_stats(st, csv_format, columns);</span>
<span class="line-removed">668   } else {</span>
<span class="line-removed">669     st-&gt;print_cr(&quot; num     #instances         #bytes  class name (module)&quot;);</span>
<span class="line-removed">670     st-&gt;print_cr(&quot;-------------------------------------------------------&quot;);</span>
<span class="line-removed">671     print_elements(st);</span>
<span class="line-removed">672   }</span>
673 }
674 
675 class HistoClosure : public KlassInfoClosure {
676  private:
677   KlassInfoHisto* _cih;
678  public:
679   HistoClosure(KlassInfoHisto* cih) : _cih(cih) {}
680 
681   void do_cinfo(KlassInfoEntry* cie) {
682     _cih-&gt;add(cie);
683   }
684 };
685 
686 class RecordInstanceClosure : public ObjectClosure {
687  private:
688   KlassInfoTable* _cit;
689   size_t _missed_count;
690   BoolObjectClosure* _filter;
691  public:
692   RecordInstanceClosure(KlassInfoTable* cit, BoolObjectClosure* filter) :
693     _cit(cit), _missed_count(0), _filter(filter) {}
694 
695   void do_object(oop obj) {
696     if (should_visit(obj)) {
697       if (!_cit-&gt;record_instance(obj)) {
698         _missed_count++;
699       }
700     }
701   }
702 
703   size_t missed_count() { return _missed_count; }
704 
705  private:
706   bool should_visit(oop obj) {
707     return _filter == NULL || _filter-&gt;do_object_b(obj);
708   }
709 };
710 
711 size_t HeapInspection::populate_table(KlassInfoTable* cit, BoolObjectClosure *filter) {
712   ResourceMark rm;
713 
714   RecordInstanceClosure ric(cit, filter);
715   Universe::heap()-&gt;object_iterate(&amp;ric);
716   return ric.missed_count();
717 }
718 
719 void HeapInspection::heap_inspection(outputStream* st) {
720   ResourceMark rm;
721 
<a name="10" id="anc10"></a><span class="line-modified">722   if (_print_help) {</span>
<span class="line-removed">723     for (int c=0; c&lt;KlassSizeStats::_num_columns; c++) {</span>
<span class="line-removed">724       st-&gt;print(&quot;%s:\n\t&quot;, name_table[c]);</span>
<span class="line-removed">725       const int max_col = 60;</span>
<span class="line-removed">726       int col = 0;</span>
<span class="line-removed">727       for (const char *p = help_table[c]; *p; p++,col++) {</span>
<span class="line-removed">728         if (col &gt;= max_col &amp;&amp; *p == &#39; &#39;) {</span>
<span class="line-removed">729           st-&gt;print(&quot;\n\t&quot;);</span>
<span class="line-removed">730           col = 0;</span>
<span class="line-removed">731         } else {</span>
<span class="line-removed">732           st-&gt;print(&quot;%c&quot;, *p);</span>
<span class="line-removed">733         }</span>
<span class="line-removed">734       }</span>
<span class="line-removed">735       st-&gt;print_cr(&quot;.\n&quot;);</span>
<span class="line-removed">736     }</span>
<span class="line-removed">737     return;</span>
<span class="line-removed">738   }</span>
<span class="line-removed">739 </span>
<span class="line-removed">740   KlassInfoTable cit(_print_class_stats);</span>
741   if (!cit.allocation_failed()) {
742     // populate table with object allocation info
743     size_t missed_count = populate_table(&amp;cit);
744     if (missed_count != 0) {
<a name="11" id="anc11"></a><span class="line-modified">745       st-&gt;print_cr(&quot;WARNING: Ran out of C-heap; undercounted &quot; SIZE_FORMAT</span>
<span class="line-modified">746                    &quot; total instances in data below&quot;,</span>
<span class="line-modified">747                    missed_count);</span>
748     }
749 
750     // Sort and print klass instance info
751     KlassInfoHisto histo(&amp;cit);
752     HistoClosure hc(&amp;histo);
753 
754     cit.iterate(&amp;hc);
755 
756     histo.sort();
<a name="12" id="anc12"></a><span class="line-modified">757     histo.print_histo_on(st, _print_class_stats, _csv_format, _columns);</span>
758   } else {
759     st-&gt;print_cr(&quot;ERROR: Ran out of C-heap; histogram not generated&quot;);
760   }
761   st-&gt;flush();
762 }
763 
764 class FindInstanceClosure : public ObjectClosure {
765  private:
766   Klass* _klass;
767   GrowableArray&lt;oop&gt;* _result;
768 
769  public:
770   FindInstanceClosure(Klass* k, GrowableArray&lt;oop&gt;* result) : _klass(k), _result(result) {};
771 
772   void do_object(oop obj) {
773     if (obj-&gt;is_a(_klass)) {
<a name="13" id="anc13"></a>



774       _result-&gt;append(obj);
775     }
776   }
777 };
778 
779 void HeapInspection::find_instances_at_safepoint(Klass* k, GrowableArray&lt;oop&gt;* result) {
780   assert(SafepointSynchronize::is_at_safepoint(), &quot;all threads are stopped&quot;);
781   assert(Heap_lock-&gt;is_locked(), &quot;should have the Heap_lock&quot;);
782 
783   // Ensure that the heap is parsable
784   Universe::heap()-&gt;ensure_parsability(false);  // no need to retire TALBs
785 
786   // Iterate over objects in the heap
787   FindInstanceClosure fic(k, result);
<a name="14" id="anc14"></a><span class="line-removed">788   // If this operation encounters a bad object when using CMS,</span>
<span class="line-removed">789   // consider using safe_object_iterate() which avoids metadata</span>
<span class="line-removed">790   // objects that may contain bad references.</span>
791   Universe::heap()-&gt;object_iterate(&amp;fic);
792 }
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
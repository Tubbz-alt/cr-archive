<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/memory/virtualspace.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_MEMORY_VIRTUALSPACE_HPP
 26 #define SHARE_MEMORY_VIRTUALSPACE_HPP
 27 
<a name="1" id="anc1"></a><span class="line-added"> 28 #include &quot;memory/memRegion.hpp&quot;</span>
 29 #include &quot;utilities/globalDefinitions.hpp&quot;
 30 
 31 class outputStream;
 32 
 33 // ReservedSpace is a data structure for reserving a contiguous address range.
 34 
 35 class ReservedSpace {
 36   friend class VMStructs;
 37  protected:
 38   char*  _base;
 39   size_t _size;
 40   size_t _noaccess_prefix;
 41   size_t _alignment;
 42   bool   _special;
 43   int    _fd_for_heap;
 44  private:
 45   bool   _executable;
 46 
 47   // ReservedSpace
 48   ReservedSpace(char* base, size_t size, size_t alignment, bool special,
 49                 bool executable);
 50  protected:
 51   void initialize(size_t size, size_t alignment, bool large,
 52                   char* requested_address,
 53                   bool executable);
 54 
 55  public:
 56   // Constructor
 57   ReservedSpace();
 58   // Initialize the reserved space with the given size. If preferred_page_size
 59   // is set, use this as minimum page size/alignment. This may waste some space
 60   // if the given size is not aligned to that value, as the reservation will be
 61   // aligned up to the final alignment in this case.
 62   ReservedSpace(size_t size, size_t preferred_page_size = 0);
 63   ReservedSpace(size_t size, size_t alignment, bool large,
 64                 char* requested_address = NULL);
 65   ReservedSpace(size_t size, size_t alignment, bool large, bool executable);
 66 
 67   // Accessors
 68   char*  base()            const { return _base;      }
 69   size_t size()            const { return _size;      }
 70   char*  end()             const { return _base + _size; }
 71   size_t alignment()       const { return _alignment; }
 72   bool   special()         const { return _special;   }
 73   bool   executable()      const { return _executable;   }
 74   size_t noaccess_prefix() const { return _noaccess_prefix;   }
 75   bool is_reserved()       const { return _base != NULL; }
 76   void release();
 77 
 78   // Splitting
 79   ReservedSpace first_part(size_t partition_size, size_t alignment,
 80                            bool split = false, bool realloc = true);
 81   ReservedSpace last_part (size_t partition_size, size_t alignment);
 82 
 83   // These simply call the above using the default alignment.
 84   inline ReservedSpace first_part(size_t partition_size,
 85                                   bool split = false, bool realloc = true);
 86   inline ReservedSpace last_part (size_t partition_size);
 87 
 88   // Alignment
 89   static size_t page_align_size_up(size_t size);
 90   static size_t page_align_size_down(size_t size);
 91   static size_t allocation_align_size_up(size_t size);
 92   bool contains(const void* p) const {
 93     return (base() &lt;= ((char*)p)) &amp;&amp; (((char*)p) &lt; (base() + size()));
 94   }
 95 };
 96 
 97 ReservedSpace
 98 ReservedSpace::first_part(size_t partition_size, bool split, bool realloc)
 99 {
100   return first_part(partition_size, alignment(), split, realloc);
101 }
102 
103 ReservedSpace ReservedSpace::last_part(size_t partition_size)
104 {
105   return last_part(partition_size, alignment());
106 }
107 
108 // Class encapsulating behavior specific of memory space reserved for Java heap.
109 class ReservedHeapSpace : public ReservedSpace {
110  private:
111   void try_reserve_heap(size_t size, size_t alignment, bool large,
112                         char *requested_address);
113   void try_reserve_range(char *highest_start, char *lowest_start,
114                          size_t attach_point_alignment, char *aligned_HBMA,
115                          char *upper_bound, size_t size, size_t alignment, bool large);
116   void initialize_compressed_heap(const size_t size, size_t alignment, bool large);
117   // Create protection page at the beginning of the space.
118   void establish_noaccess_prefix();
119  public:
120   // Constructor. Tries to find a heap that is good for compressed oops.
121   // heap_allocation_directory is the path to the backing memory for Java heap. When set, Java heap will be allocated
122   // on the device which is managed by the file system where the directory resides.
123   ReservedHeapSpace(size_t size, size_t forced_base_alignment, bool large, const char* heap_allocation_directory = NULL);
124   // Returns the base to be used for compression, i.e. so that null can be
125   // encoded safely and implicit null checks can work.
<a name="2" id="anc2"></a><span class="line-modified">126   char *compressed_oop_base() const { return _base - _noaccess_prefix; }</span>
<span class="line-added">127   MemRegion region() const;</span>
128 };
129 
130 // Class encapsulating behavior specific memory space for Code
131 class ReservedCodeSpace : public ReservedSpace {
132  public:
133   // Constructor
134   ReservedCodeSpace(size_t r_size, size_t rs_align, bool large);
135 };
136 
137 // VirtualSpace is data structure for committing a previously reserved address range in smaller chunks.
138 
139 class VirtualSpace {
140   friend class VMStructs;
141  private:
142   // Reserved area
143   char* _low_boundary;
144   char* _high_boundary;
145 
146   // Committed area
147   char* _low;
148   char* _high;
149 
150   // The entire space has been committed and pinned in memory, no
151   // os::commit_memory() or os::uncommit_memory().
152   bool _special;
153 
154   // Need to know if commit should be executable.
155   bool   _executable;
156 
157   // MPSS Support
158   // Each virtualspace region has a lower, middle, and upper region.
159   // Each region has an end boundary and a high pointer which is the
160   // high water mark for the last allocated byte.
161   // The lower and upper unaligned to LargePageSizeInBytes uses default page.
162   // size.  The middle region uses large page size.
163   char* _lower_high;
164   char* _middle_high;
165   char* _upper_high;
166 
167   char* _lower_high_boundary;
168   char* _middle_high_boundary;
169   char* _upper_high_boundary;
170 
171   size_t _lower_alignment;
172   size_t _middle_alignment;
173   size_t _upper_alignment;
174 
175   // MPSS Accessors
176   char* lower_high() const { return _lower_high; }
177   char* middle_high() const { return _middle_high; }
178   char* upper_high() const { return _upper_high; }
179 
180   char* lower_high_boundary() const { return _lower_high_boundary; }
181   char* middle_high_boundary() const { return _middle_high_boundary; }
182   char* upper_high_boundary() const { return _upper_high_boundary; }
183 
184   size_t lower_alignment() const { return _lower_alignment; }
185   size_t middle_alignment() const { return _middle_alignment; }
186   size_t upper_alignment() const { return _upper_alignment; }
187 
188  public:
189   // Committed area
190   char* low()  const { return _low; }
191   char* high() const { return _high; }
192 
193   // Reserved area
194   char* low_boundary()  const { return _low_boundary; }
195   char* high_boundary() const { return _high_boundary; }
196 
197 #if INCLUDE_AOT
198   // Set boundaries for code section in AOT library.
199   void set_low_boundary(char *p)  { _low_boundary = p; }
200   void set_high_boundary(char *p) { _high_boundary = p; }
201   void set_low(char *p)           { _low = p; }
202   void set_high(char *p)          { _high = p; }
203 #endif
204 
205   bool special() const { return _special; }
206 
207  public:
208   // Initialization
209   VirtualSpace();
210   bool initialize_with_granularity(ReservedSpace rs, size_t committed_byte_size, size_t max_commit_ganularity);
211   bool initialize(ReservedSpace rs, size_t committed_byte_size);
212 
213   // Destruction
214   ~VirtualSpace();
215 
216   // Reserved memory
217   size_t reserved_size() const;
218   // Actually committed OS memory
219   size_t actual_committed_size() const;
220   // Memory used/expanded in this virtual space
221   size_t committed_size() const;
222   // Memory left to use/expand in this virtual space
223   size_t uncommitted_size() const;
224 
225   bool   contains(const void* p) const;
226 
227   // Operations
228   // returns true on success, false otherwise
229   bool expand_by(size_t bytes, bool pre_touch = false);
230   void shrink_by(size_t bytes);
231   void release();
232 
233   void check_for_contiguity() PRODUCT_RETURN;
234 
235   // Debugging
236   void print_on(outputStream* out) PRODUCT_RETURN;
237   void print();
238 };
239 
240 #endif // SHARE_MEMORY_VIRTUALSPACE_HPP
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
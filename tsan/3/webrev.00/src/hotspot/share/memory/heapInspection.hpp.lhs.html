<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/memory/heapInspection.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_MEMORY_HEAPINSPECTION_HPP
 26 #define SHARE_MEMORY_HEAPINSPECTION_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;oops/objArrayOop.hpp&quot;
 30 #include &quot;oops/oop.hpp&quot;
 31 #include &quot;oops/annotations.hpp&quot;
 32 #include &quot;utilities/macros.hpp&quot;
 33 
 34 #if INCLUDE_SERVICES
 35 
 36 
 37 // HeapInspection
 38 
 39 // KlassInfoTable is a bucket hash table that
 40 // maps Klass*s to extra information:
 41 //    instance count and instance word size.
 42 //
 43 // A KlassInfoBucket is the head of a link list
 44 // of KlassInfoEntry&#39;s
 45 //
 46 // KlassInfoHisto is a growable array of pointers
 47 // to KlassInfoEntry&#39;s and is used to sort
 48 // the entries.
 49 
<a name="2" id="anc2"></a><span class="line-removed"> 50 #define HEAP_INSPECTION_COLUMNS_DO(f) \</span>
<span class="line-removed"> 51     f(inst_size, InstSize, \</span>
<span class="line-removed"> 52         &quot;Size of each object instance of the Java class&quot;) \</span>
<span class="line-removed"> 53     f(inst_count, InstCount, \</span>
<span class="line-removed"> 54         &quot;Number of object instances of the Java class&quot;)  \</span>
<span class="line-removed"> 55     f(inst_bytes, InstBytes, \</span>
<span class="line-removed"> 56         &quot;This is usually (InstSize * InstNum). The only exception is &quot; \</span>
<span class="line-removed"> 57         &quot;java.lang.Class, whose InstBytes also includes the slots &quot; \</span>
<span class="line-removed"> 58         &quot;used to store static fields. InstBytes is not counted in &quot; \</span>
<span class="line-removed"> 59         &quot;ROAll, RWAll or Total&quot;) \</span>
<span class="line-removed"> 60     f(mirror_bytes, Mirror, \</span>
<span class="line-removed"> 61         &quot;Size of the Klass::java_mirror() object&quot;) \</span>
<span class="line-removed"> 62     f(klass_bytes, KlassBytes, \</span>
<span class="line-removed"> 63         &quot;Size of the InstanceKlass or ArrayKlass for this class. &quot; \</span>
<span class="line-removed"> 64         &quot;Note that this includes VTab, ITab, OopMap&quot;) \</span>
<span class="line-removed"> 65     f(secondary_supers_bytes, K_secondary_supers, \</span>
<span class="line-removed"> 66         &quot;Number of bytes used by the Klass::secondary_supers() array&quot;) \</span>
<span class="line-removed"> 67     f(vtab_bytes, VTab, \</span>
<span class="line-removed"> 68         &quot;Size of the embedded vtable in InstanceKlass&quot;) \</span>
<span class="line-removed"> 69     f(itab_bytes, ITab, \</span>
<span class="line-removed"> 70         &quot;Size of the embedded itable in InstanceKlass&quot;) \</span>
<span class="line-removed"> 71     f(nonstatic_oopmap_bytes, OopMap, \</span>
<span class="line-removed"> 72         &quot;Size of the embedded nonstatic_oop_map in InstanceKlass&quot;) \</span>
<span class="line-removed"> 73     f(methods_array_bytes, IK_methods, \</span>
<span class="line-removed"> 74         &quot;Number of bytes used by the InstanceKlass::methods() array&quot;) \</span>
<span class="line-removed"> 75     f(method_ordering_bytes, IK_method_ordering, \</span>
<span class="line-removed"> 76         &quot;Number of bytes used by the InstanceKlass::method_ordering() array&quot;) \</span>
<span class="line-removed"> 77     f(default_methods_array_bytes, IK_default_methods, \</span>
<span class="line-removed"> 78         &quot;Number of bytes used by the InstanceKlass::default_methods() array&quot;) \</span>
<span class="line-removed"> 79     f(default_vtable_indices_bytes, IK_default_vtable_indices, \</span>
<span class="line-removed"> 80         &quot;Number of bytes used by the InstanceKlass::default_vtable_indices() array&quot;) \</span>
<span class="line-removed"> 81     f(local_interfaces_bytes, IK_local_interfaces, \</span>
<span class="line-removed"> 82         &quot;Number of bytes used by the InstanceKlass::local_interfaces() array&quot;) \</span>
<span class="line-removed"> 83     f(transitive_interfaces_bytes, IK_transitive_interfaces, \</span>
<span class="line-removed"> 84         &quot;Number of bytes used by the InstanceKlass::transitive_interfaces() array&quot;) \</span>
<span class="line-removed"> 85     f(fields_bytes, IK_fields, \</span>
<span class="line-removed"> 86         &quot;Number of bytes used by the InstanceKlass::fields() array&quot;) \</span>
<span class="line-removed"> 87     f(inner_classes_bytes, IK_inner_classes, \</span>
<span class="line-removed"> 88         &quot;Number of bytes used by the InstanceKlass::inner_classes() array&quot;) \</span>
<span class="line-removed"> 89     f(nest_members_bytes, IK_nest_members, \</span>
<span class="line-removed"> 90         &quot;Number of bytes used by the InstanceKlass::nest_members() array&quot;) \</span>
<span class="line-removed"> 91     f(signers_bytes, IK_signers, \</span>
<span class="line-removed"> 92         &quot;Number of bytes used by the InstanceKlass::singers() array&quot;) \</span>
<span class="line-removed"> 93     f(class_annotations_bytes, class_annotations, \</span>
<span class="line-removed"> 94         &quot;Size of class annotations&quot;) \</span>
<span class="line-removed"> 95     f(class_type_annotations_bytes, class_type_annotations, \</span>
<span class="line-removed"> 96         &quot;Size of class type annotations&quot;) \</span>
<span class="line-removed"> 97     f(fields_annotations_bytes, fields_annotations, \</span>
<span class="line-removed"> 98         &quot;Size of field annotations&quot;) \</span>
<span class="line-removed"> 99     f(fields_type_annotations_bytes, fields_type_annotations, \</span>
<span class="line-removed">100         &quot;Size of field type annotations&quot;) \</span>
<span class="line-removed">101     f(methods_annotations_bytes, methods_annotations, \</span>
<span class="line-removed">102         &quot;Size of method annotations&quot;) \</span>
<span class="line-removed">103     f(methods_parameter_annotations_bytes, methods_parameter_annotations, \</span>
<span class="line-removed">104         &quot;Size of method parameter annotations&quot;) \</span>
<span class="line-removed">105     f(methods_type_annotations_bytes, methods_type_annotations, \</span>
<span class="line-removed">106         &quot;Size of methods type annotations&quot;) \</span>
<span class="line-removed">107     f(methods_default_annotations_bytes, methods_default_annotations, \</span>
<span class="line-removed">108         &quot;Size of methods default annotations&quot;) \</span>
<span class="line-removed">109     f(annotations_bytes, annotations, \</span>
<span class="line-removed">110         &quot;Size of all annotations&quot;) \</span>
<span class="line-removed">111     f(cp_bytes, Cp, \</span>
<span class="line-removed">112         &quot;Size of InstanceKlass::constants()&quot;) \</span>
<span class="line-removed">113     f(cp_tags_bytes, CpTags, \</span>
<span class="line-removed">114         &quot;Size of InstanceKlass::constants()-&gt;tags()&quot;) \</span>
<span class="line-removed">115     f(cp_cache_bytes, CpCache, \</span>
<span class="line-removed">116         &quot;Size of InstanceKlass::constants()-&gt;cache()&quot;) \</span>
<span class="line-removed">117     f(cp_operands_bytes, CpOperands, \</span>
<span class="line-removed">118         &quot;Size of InstanceKlass::constants()-&gt;operands()&quot;) \</span>
<span class="line-removed">119     f(cp_refmap_bytes, CpRefMap, \</span>
<span class="line-removed">120         &quot;Size of InstanceKlass::constants()-&gt;reference_map()&quot;) \</span>
<span class="line-removed">121     f(cp_all_bytes, CpAll, \</span>
<span class="line-removed">122         &quot;Sum of Cp + CpTags + CpCache + CpOperands + CpRefMap&quot;) \</span>
<span class="line-removed">123     f(method_count, MethodCount, \</span>
<span class="line-removed">124         &quot;Number of methods in this class&quot;) \</span>
<span class="line-removed">125     f(method_bytes, MethodBytes, \</span>
<span class="line-removed">126         &quot;Size of the Method object&quot;) \</span>
<span class="line-removed">127     f(const_method_bytes, ConstMethod, \</span>
<span class="line-removed">128         &quot;Size of the ConstMethod object&quot;) \</span>
<span class="line-removed">129     f(method_data_bytes, MethodData, \</span>
<span class="line-removed">130         &quot;Size of the MethodData object&quot;) \</span>
<span class="line-removed">131     f(stackmap_bytes, StackMap, \</span>
<span class="line-removed">132         &quot;Size of the stackmap_data&quot;) \</span>
<span class="line-removed">133     f(bytecode_bytes, Bytecodes, \</span>
<span class="line-removed">134         &quot;Of the MethodBytes column, how much are the space taken up by bytecodes&quot;) \</span>
<span class="line-removed">135     f(method_all_bytes, MethodAll, \</span>
<span class="line-removed">136         &quot;Sum of MethodBytes + Constmethod + Stackmap + Methoddata&quot;) \</span>
<span class="line-removed">137     f(ro_bytes, ROAll, \</span>
<span class="line-removed">138         &quot;Size of all class meta data that could (potentially) be placed &quot; \</span>
<span class="line-removed">139         &quot;in read-only memory. (This could change with CDS design)&quot;) \</span>
<span class="line-removed">140     f(rw_bytes, RWAll, \</span>
<span class="line-removed">141         &quot;Size of all class meta data that must be placed in read/write &quot; \</span>
<span class="line-removed">142         &quot;memory. (This could change with CDS design) &quot;) \</span>
<span class="line-removed">143     f(total_bytes, Total, \</span>
<span class="line-removed">144         &quot;ROAll + RWAll. Note that this does NOT include InstBytes.&quot;)</span>
<span class="line-removed">145 </span>
<span class="line-removed">146 // Size statistics for a Klass - filled in by Klass::collect_statistics()</span>
<span class="line-removed">147 class KlassSizeStats {</span>
<span class="line-removed">148 public:</span>
<span class="line-removed">149 #define COUNT_KLASS_SIZE_STATS_FIELD(field, name, help)   _index_ ## field,</span>
<span class="line-removed">150 #define DECLARE_KLASS_SIZE_STATS_FIELD(field, name, help) julong _ ## field;</span>
<span class="line-removed">151 </span>
<span class="line-removed">152   enum {</span>
<span class="line-removed">153     HEAP_INSPECTION_COLUMNS_DO(COUNT_KLASS_SIZE_STATS_FIELD)</span>
<span class="line-removed">154     _num_columns</span>
<span class="line-removed">155   };</span>
<span class="line-removed">156 </span>
<span class="line-removed">157   HEAP_INSPECTION_COLUMNS_DO(DECLARE_KLASS_SIZE_STATS_FIELD)</span>
<span class="line-removed">158 </span>
<span class="line-removed">159   static int count(oop x);</span>
<span class="line-removed">160 </span>
<span class="line-removed">161   static int count_array(objArrayOop x);</span>
<span class="line-removed">162 </span>
<span class="line-removed">163   template &lt;class T&gt; static int count(T* x) {</span>
<span class="line-removed">164     return (HeapWordSize * ((x) ? (x)-&gt;size() : 0));</span>
<span class="line-removed">165   }</span>
<span class="line-removed">166 </span>
<span class="line-removed">167   template &lt;class T&gt; static int count_array(T* x) {</span>
<span class="line-removed">168     if (x == NULL) {</span>
<span class="line-removed">169       return 0;</span>
<span class="line-removed">170     }</span>
<span class="line-removed">171     if (x-&gt;length() == 0) {</span>
<span class="line-removed">172       // This is a shared array, e.g., Universe::the_empty_int_array(). Don&#39;t</span>
<span class="line-removed">173       // count it to avoid double-counting.</span>
<span class="line-removed">174       return 0;</span>
<span class="line-removed">175     }</span>
<span class="line-removed">176     return HeapWordSize * x-&gt;size();</span>
<span class="line-removed">177   }</span>
<span class="line-removed">178 };</span>
<span class="line-removed">179 </span>
<span class="line-removed">180 </span>
<span class="line-removed">181 </span>
<span class="line-removed">182 </span>
183 class KlassInfoEntry: public CHeapObj&lt;mtInternal&gt; {
184  private:
185   KlassInfoEntry* _next;
186   Klass*          _klass;
187   long            _instance_count;
188   size_t          _instance_words;
189   long            _index;
190   bool            _do_print; // True if we should print this class when printing the class hierarchy.
191   GrowableArray&lt;KlassInfoEntry*&gt;* _subclasses;
192 
193  public:
194   KlassInfoEntry(Klass* k, KlassInfoEntry* next) :
195     _next(next), _klass(k), _instance_count(0), _instance_words(0), _index(-1),
196     _do_print(false), _subclasses(NULL)
197   {}
198   ~KlassInfoEntry();
199   KlassInfoEntry* next() const   { return _next; }
200   bool is_equal(const Klass* k)  { return k == _klass; }
201   Klass* klass()  const      { return _klass; }
202   long count()    const      { return _instance_count; }
203   void set_count(long ct)    { _instance_count = ct; }
204   size_t words()  const      { return _instance_words; }
205   void set_words(size_t wds) { _instance_words = wds; }
206   void set_index(long index) { _index = index; }
207   long index()    const      { return _index; }
208   GrowableArray&lt;KlassInfoEntry*&gt;* subclasses() const { return _subclasses; }
209   void add_subclass(KlassInfoEntry* cie);
210   void set_do_print(bool do_print) { _do_print = do_print; }
211   bool do_print() const      { return _do_print; }
212   int compare(KlassInfoEntry* e1, KlassInfoEntry* e2);
213   void print_on(outputStream* st) const;
214   const char* name() const;
215 };
216 
217 class KlassInfoClosure : public StackObj {
218  public:
219   // Called for each KlassInfoEntry.
220   virtual void do_cinfo(KlassInfoEntry* cie) = 0;
221 };
222 
223 class KlassInfoBucket: public CHeapObj&lt;mtInternal&gt; {
224  private:
225   KlassInfoEntry* _list;
226   KlassInfoEntry* list()           { return _list; }
227   void set_list(KlassInfoEntry* l) { _list = l; }
228  public:
229   KlassInfoEntry* lookup(Klass* k);
230   void initialize() { _list = NULL; }
231   void empty();
232   void iterate(KlassInfoClosure* cic);
233 };
234 
235 class KlassInfoTable: public StackObj {
236  private:
237   static const int _num_buckets = 20011;
238   size_t _size_of_instances_in_words;
239 
240   // An aligned reference address (typically the least
241   // address in the perm gen) used for hashing klass
242   // objects.
243   HeapWord* _ref;
244 
245   KlassInfoBucket* _buckets;
246   uint hash(const Klass* p);
247   KlassInfoEntry* lookup(Klass* k); // allocates if not found!
248 
249   class AllClassesFinder;
250 
251  public:
252   KlassInfoTable(bool add_all_classes);
253   ~KlassInfoTable();
254   bool record_instance(const oop obj);
255   void iterate(KlassInfoClosure* cic);
256   bool allocation_failed() { return _buckets == NULL; }
257   size_t size_of_instances_in_words() const;
258 
259   friend class KlassInfoHisto;
260   friend class KlassHierarchy;
261 };
262 
263 class KlassHierarchy : AllStatic {
264  public:
265   static void print_class_hierarchy(outputStream* st, bool print_interfaces,  bool print_subclasses,
266                                     char* classname);
267 
268  private:
269   static void set_do_print_for_class_hierarchy(KlassInfoEntry* cie, KlassInfoTable* cit,
270                                                bool print_subclasse);
271   static void print_class(outputStream* st, KlassInfoEntry* cie, bool print_subclasses);
272 };
273 
274 class KlassInfoHisto : public StackObj {
275  private:
276   static const int _histo_initial_size = 1000;
277   KlassInfoTable *_cit;
278   GrowableArray&lt;KlassInfoEntry*&gt;* _elements;
279   GrowableArray&lt;KlassInfoEntry*&gt;* elements() const { return _elements; }
280   static int sort_helper(KlassInfoEntry** e1, KlassInfoEntry** e2);
281   void print_elements(outputStream* st) const;
<a name="3" id="anc3"></a><span class="line-removed">282   void print_class_stats(outputStream* st, bool csv_format, const char *columns);</span>
<span class="line-removed">283   julong annotations_bytes(Array&lt;AnnotationArray*&gt;* p) const;</span>
<span class="line-removed">284   const char *_selected_columns;</span>
285   bool is_selected(const char *col_name);
<a name="4" id="anc4"></a><span class="line-removed">286   void print_title(outputStream* st, bool csv_format,</span>
<span class="line-removed">287                    bool selected_columns_table[], int width_table[],</span>
<span class="line-removed">288                    const char *name_table[]);</span>
289 
290   template &lt;class T&gt; static int count_bytes(T* x) {
291     return (HeapWordSize * ((x) ? (x)-&gt;size() : 0));
292   }
293 
294   template &lt;class T&gt; static int count_bytes_array(T* x) {
295     if (x == NULL) {
296       return 0;
297     }
298     if (x-&gt;length() == 0) {
299       // This is a shared array, e.g., Universe::the_empty_int_array(). Don&#39;t
300       // count it to avoid double-counting.
301       return 0;
302     }
303     return HeapWordSize * x-&gt;size();
304   }
305 
306   static void print_julong(outputStream* st, int width, julong n) {
307     int num_spaces = width - julong_width(n);
308     if (num_spaces &gt; 0) {
309       st-&gt;print(&quot;%*s&quot;, num_spaces, &quot;&quot;);
310     }
311     st-&gt;print(JULONG_FORMAT, n);
312   }
313 
314   static int julong_width(julong n) {
315     if (n == 0) {
316       return 1;
317     }
318     int w = 0;
319     while (n &gt; 0) {
320       n /= 10;
321       w += 1;
322     }
323     return w;
324   }
325 
326   static int col_width(julong n, const char *name) {
327     int w = julong_width(n);
328     int min = (int)(strlen(name));
329     if (w &lt; min) {
330         w = min;
331     }
332     // add a leading space for separation.
333     return w + 1;
334   }
335 
336  public:
337   KlassInfoHisto(KlassInfoTable* cit);
338   ~KlassInfoHisto();
339   void add(KlassInfoEntry* cie);
<a name="5" id="anc5"></a><span class="line-modified">340   void print_histo_on(outputStream* st, bool print_class_stats, bool csv_format, const char *columns);</span>
341   void sort();
342 };
343 
344 #endif // INCLUDE_SERVICES
345 
346 // These declarations are needed since the declaration of KlassInfoTable and
347 // KlassInfoClosure are guarded by #if INLCUDE_SERVICES
348 class KlassInfoTable;
349 class KlassInfoClosure;
350 
351 class HeapInspection : public StackObj {
<a name="6" id="anc6"></a><span class="line-removed">352   bool _csv_format; // &quot;comma separated values&quot; format for spreadsheet.</span>
<span class="line-removed">353   bool _print_help;</span>
<span class="line-removed">354   bool _print_class_stats;</span>
<span class="line-removed">355   const char* _columns;</span>
356  public:
<a name="7" id="anc7"></a><span class="line-removed">357   HeapInspection(bool csv_format, bool print_help,</span>
<span class="line-removed">358                  bool print_class_stats, const char *columns) :</span>
<span class="line-removed">359       _csv_format(csv_format), _print_help(print_help),</span>
<span class="line-removed">360       _print_class_stats(print_class_stats), _columns(columns) {}</span>
361   void heap_inspection(outputStream* st) NOT_SERVICES_RETURN;
362   size_t populate_table(KlassInfoTable* cit, BoolObjectClosure* filter = NULL) NOT_SERVICES_RETURN_(0);
363   static void find_instances_at_safepoint(Klass* k, GrowableArray&lt;oop&gt;* result) NOT_SERVICES_RETURN;
364  private:
365   void iterate_over_heap(KlassInfoTable* cit, BoolObjectClosure* filter = NULL);
366 };
367 
368 #endif // SHARE_MEMORY_HEAPINSPECTION_HPP
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
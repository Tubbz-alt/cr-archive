<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/memory/universe.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="resourceArea.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="universe.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/universe.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -26,10 +26,11 @@</span>
  #include &quot;aot/aotLoader.hpp&quot;
  #include &quot;classfile/classLoader.hpp&quot;
  #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  #include &quot;classfile/javaClasses.hpp&quot;
  #include &quot;classfile/stringTable.hpp&quot;
<span class="udiff-line-added">+ #include &quot;classfile/symbolTable.hpp&quot;</span>
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;classfile/vmSymbols.hpp&quot;
  #include &quot;code/codeBehaviours.hpp&quot;
  #include &quot;code/codeCache.hpp&quot;
  #include &quot;code/dependencies.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -47,11 +48,11 @@</span>
  #include &quot;memory/metaspaceCounters.hpp&quot;
  #include &quot;memory/metaspaceShared.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;memory/universe.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;oops/compressedOops.hpp&quot;</span>
  #include &quot;oops/constantPool.hpp&quot;
  #include &quot;oops/instanceClassLoaderKlass.hpp&quot;
  #include &quot;oops/instanceKlass.hpp&quot;
  #include &quot;oops/instanceMirrorKlass.hpp&quot;
  #include &quot;oops/instanceRefKlass.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -82,22 +83,28 @@</span>
  #include &quot;utilities/hashtable.inline.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  #include &quot;utilities/ostream.hpp&quot;
  #include &quot;utilities/preserveException.hpp&quot;
  
<span class="udiff-line-added">+ #define PRIMITIVE_MIRRORS_DO(func) \</span>
<span class="udiff-line-added">+   func(_int_mirror)    \</span>
<span class="udiff-line-added">+   func(_float_mirror)  \</span>
<span class="udiff-line-added">+   func(_double_mirror) \</span>
<span class="udiff-line-added">+   func(_byte_mirror)   \</span>
<span class="udiff-line-added">+   func(_bool_mirror)   \</span>
<span class="udiff-line-added">+   func(_char_mirror)   \</span>
<span class="udiff-line-added">+   func(_long_mirror)   \</span>
<span class="udiff-line-added">+   func(_short_mirror)  \</span>
<span class="udiff-line-added">+   func(_void_mirror)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #define DEFINE_PRIMITIVE_MIRROR(m) \</span>
<span class="udiff-line-added">+     oop Universe::m  = NULL;</span>
<span class="udiff-line-added">+ </span>
  // Known objects
<span class="udiff-line-added">+ PRIMITIVE_MIRRORS_DO(DEFINE_PRIMITIVE_MIRROR)</span>
  Klass* Universe::_typeArrayKlassObjs[T_LONG+1]        = { NULL /*, NULL...*/ };
  Klass* Universe::_objectArrayKlassObj                 = NULL;
<span class="udiff-line-removed">- oop Universe::_int_mirror                             = NULL;</span>
<span class="udiff-line-removed">- oop Universe::_float_mirror                           = NULL;</span>
<span class="udiff-line-removed">- oop Universe::_double_mirror                          = NULL;</span>
<span class="udiff-line-removed">- oop Universe::_byte_mirror                            = NULL;</span>
<span class="udiff-line-removed">- oop Universe::_bool_mirror                            = NULL;</span>
<span class="udiff-line-removed">- oop Universe::_char_mirror                            = NULL;</span>
<span class="udiff-line-removed">- oop Universe::_long_mirror                            = NULL;</span>
<span class="udiff-line-removed">- oop Universe::_short_mirror                           = NULL;</span>
<span class="udiff-line-removed">- oop Universe::_void_mirror                            = NULL;</span>
  oop Universe::_mirrors[T_VOID+1]                      = { NULL /*, NULL...*/ };
  oop Universe::_main_thread_group                      = NULL;
  oop Universe::_system_thread_group                    = NULL;
  objArrayOop Universe::_the_empty_class_klass_array    = NULL;
  Array&lt;Klass*&gt;* Universe::_the_array_interfaces_array = NULL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -152,15 +159,10 @@</span>
  size_t          Universe::_heap_capacity_at_last_gc;
  size_t          Universe::_heap_used_at_last_gc = 0;
  
  CollectedHeap*  Universe::_collectedHeap = NULL;
  
<span class="udiff-line-removed">- NarrowPtrStruct Universe::_narrow_oop = { NULL, 0, true };</span>
<span class="udiff-line-removed">- NarrowPtrStruct Universe::_narrow_klass = { NULL, 0, true };</span>
<span class="udiff-line-removed">- address Universe::_narrow_ptrs_base;</span>
<span class="udiff-line-removed">- uint64_t Universe::_narrow_klass_range = (uint64_t(max_juint)+1);</span>
<span class="udiff-line-removed">- </span>
  void Universe::basic_type_classes_do(void f(Klass*)) {
    for (int i = T_BOOLEAN; i &lt; T_LONG+1; i++) {
      f(_typeArrayKlassObjs[i]);
    }
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -169,21 +171,15 @@</span>
    for (int i = T_BOOLEAN; i &lt; T_LONG+1; i++) {
      closure-&gt;do_klass(_typeArrayKlassObjs[i]);
    }
  }
  
<span class="udiff-line-modified-removed">- void Universe::oops_do(OopClosure* f) {</span>
<span class="udiff-line-modified-added">+ #define DO_PRIMITIVE_MIRROR(m) \</span>
<span class="udiff-line-added">+   f-&gt;do_oop((oop*) &amp;m);</span>
  
<span class="udiff-line-modified-removed">-   f-&gt;do_oop((oop*) &amp;_int_mirror);</span>
<span class="udiff-line-modified-removed">-   f-&gt;do_oop((oop*) &amp;_float_mirror);</span>
<span class="udiff-line-removed">-   f-&gt;do_oop((oop*) &amp;_double_mirror);</span>
<span class="udiff-line-removed">-   f-&gt;do_oop((oop*) &amp;_byte_mirror);</span>
<span class="udiff-line-removed">-   f-&gt;do_oop((oop*) &amp;_bool_mirror);</span>
<span class="udiff-line-removed">-   f-&gt;do_oop((oop*) &amp;_char_mirror);</span>
<span class="udiff-line-removed">-   f-&gt;do_oop((oop*) &amp;_long_mirror);</span>
<span class="udiff-line-removed">-   f-&gt;do_oop((oop*) &amp;_short_mirror);</span>
<span class="udiff-line-removed">-   f-&gt;do_oop((oop*) &amp;_void_mirror);</span>
<span class="udiff-line-modified-added">+ void Universe::oops_do(OopClosure* f) {</span>
<span class="udiff-line-modified-added">+   PRIMITIVE_MIRRORS_DO(DO_PRIMITIVE_MIRROR);</span>
  
    for (int i = T_BOOLEAN; i &lt; T_VOID+1; i++) {
      f-&gt;do_oop((oop*) &amp;_mirrors[i]);
    }
    assert(_mirrors[0] == NULL &amp;&amp; _mirrors[T_BOOLEAN - 1] == NULL, &quot;checking&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -233,37 +229,31 @@</span>
    _throw_illegal_access_error_cache-&gt;metaspace_pointers_do(it);
    _throw_no_such_method_error_cache-&gt;metaspace_pointers_do(it);
    _do_stack_walk_cache-&gt;metaspace_pointers_do(it);
  }
  
<span class="udiff-line-added">+ #define ASSERT_MIRROR_NULL(m) \</span>
<span class="udiff-line-added">+   assert(m == NULL, &quot;archived mirrors should be NULL&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #define SERIALIZE_MIRROR(m) \</span>
<span class="udiff-line-added">+   f-&gt;do_oop(&amp;m); \</span>
<span class="udiff-line-added">+   if (m != NULL) { java_lang_Class::update_archived_primitive_mirror_native_pointers(m); }</span>
<span class="udiff-line-added">+ </span>
  // Serialize metadata and pointers to primitive type mirrors in and out of CDS archive
  void Universe::serialize(SerializeClosure* f) {
  
    for (int i = 0; i &lt; T_LONG+1; i++) {
      f-&gt;do_ptr((void**)&amp;_typeArrayKlassObjs[i]);
    }
  
    f-&gt;do_ptr((void**)&amp;_objectArrayKlassObj);
<span class="udiff-line-added">+ </span>
  #if INCLUDE_CDS_JAVA_HEAP
<span class="udiff-line-modified-removed">- #ifdef ASSERT</span>
<span class="udiff-line-modified-removed">-   if (DumpSharedSpaces &amp;&amp; !HeapShared::is_heap_object_archiving_allowed()) {</span>
<span class="udiff-line-modified-removed">-     assert(_int_mirror == NULL    &amp;&amp; _float_mirror == NULL &amp;&amp;</span>
<span class="udiff-line-modified-removed">-            _double_mirror == NULL &amp;&amp; _byte_mirror == NULL  &amp;&amp;</span>
<span class="udiff-line-removed">-            _bool_mirror == NULL   &amp;&amp; _char_mirror == NULL  &amp;&amp;</span>
<span class="udiff-line-removed">-            _long_mirror == NULL   &amp;&amp; _short_mirror == NULL &amp;&amp;</span>
<span class="udiff-line-removed">-            _void_mirror == NULL, &quot;mirrors should be NULL&quot;);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-   f-&gt;do_oop(&amp;_int_mirror);</span>
<span class="udiff-line-removed">-   f-&gt;do_oop(&amp;_float_mirror);</span>
<span class="udiff-line-removed">-   f-&gt;do_oop(&amp;_double_mirror);</span>
<span class="udiff-line-removed">-   f-&gt;do_oop(&amp;_byte_mirror);</span>
<span class="udiff-line-removed">-   f-&gt;do_oop(&amp;_bool_mirror);</span>
<span class="udiff-line-removed">-   f-&gt;do_oop(&amp;_char_mirror);</span>
<span class="udiff-line-removed">-   f-&gt;do_oop(&amp;_long_mirror);</span>
<span class="udiff-line-removed">-   f-&gt;do_oop(&amp;_short_mirror);</span>
<span class="udiff-line-removed">-   f-&gt;do_oop(&amp;_void_mirror);</span>
<span class="udiff-line-modified-added">+   DEBUG_ONLY(if (DumpSharedSpaces &amp;&amp; !HeapShared::is_heap_object_archiving_allowed()) {</span>
<span class="udiff-line-modified-added">+       PRIMITIVE_MIRRORS_DO(ASSERT_MIRROR_NULL);</span>
<span class="udiff-line-modified-added">+     });</span>
<span class="udiff-line-modified-added">+   PRIMITIVE_MIRRORS_DO(SERIALIZE_MIRROR);</span>
  #endif
  
    f-&gt;do_ptr((void**)&amp;_the_array_interfaces_array);
    f-&gt;do_ptr((void**)&amp;_the_empty_int_array);
    f-&gt;do_ptr((void**)&amp;_the_empty_short_array);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -298,15 +288,15 @@</span>
    }
    k-&gt;append_to_sibling_list();
  }
  
  void Universe::genesis(TRAPS) {
<span class="udiff-line-modified-removed">-   ResourceMark rm;</span>
<span class="udiff-line-modified-added">+   ResourceMark rm(THREAD);</span>
  
    { FlagSetting fs(_bootstrapping, true);
  
<span class="udiff-line-modified-removed">-     { MutexLocker mc(Compile_lock);</span>
<span class="udiff-line-modified-added">+     { MutexLocker mc(THREAD, Compile_lock);</span>
  
        java_lang_Class::allocate_fixup_lists();
  
        // determine base vtable size; without that we cannot create the array klasses
        compute_base_vtable_size();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -397,17 +387,12 @@</span>
      // and we find out if we actually update all the oops correctly.
      // But we can&#39;t allocate directly in the old generation,
      // so we allocate wherever, and hope that the first collection
      // moves these objects to the bottom of the old generation.
      // We can allocate directly in the permanent generation, so we do.
<span class="udiff-line-modified-removed">-     int size;</span>
<span class="udiff-line-modified-removed">-     if (UseConcMarkSweepGC) {</span>
<span class="udiff-line-removed">-       log_warning(gc)(&quot;Using +FullGCALot with concurrent mark sweep gc will not force all objects to relocate&quot;);</span>
<span class="udiff-line-removed">-       size = FullGCALotDummies;</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       size = FullGCALotDummies * 2;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     int size = FullGCALotDummies * 2;</span>
<span class="udiff-line-modified-added">+ </span>
      objArrayOop    naked_array = oopFactory::new_objArray(SystemDictionary::Object_klass(), size, CHECK);
      objArrayHandle dummy_array(THREAD, naked_array);
      int i = 0;
      while (i &lt; size) {
          // Allocate dummy in old generation
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -416,32 +401,32 @@</span>
      }
      {
        // Only modify the global variable inside the mutex.
        // If we had a race to here, the other dummy_array instances
        // and their elements just get dropped on the floor, which is fine.
<span class="udiff-line-modified-removed">-       MutexLocker ml(FullGCALot_lock);</span>
<span class="udiff-line-modified-added">+       MutexLocker ml(THREAD, FullGCALot_lock);</span>
        if (_fullgc_alot_dummy_array == NULL) {
          _fullgc_alot_dummy_array = dummy_array();
        }
      }
      assert(i == _fullgc_alot_dummy_array-&gt;length(), &quot;just checking&quot;);
    }
    #endif
  }
  
<span class="udiff-line-added">+ #define ASSERT_MIRROR_NOT_NULL(m) \</span>
<span class="udiff-line-added">+   assert(m != NULL, &quot;archived mirrors should not be NULL&quot;);</span>
<span class="udiff-line-added">+ </span>
  void Universe::initialize_basic_type_mirrors(TRAPS) {
  #if INCLUDE_CDS_JAVA_HEAP
      if (UseSharedSpaces &amp;&amp;
          HeapShared::open_archive_heap_region_mapped() &amp;&amp;
          _int_mirror != NULL) {
        assert(HeapShared::is_heap_object_archiving_allowed(), &quot;Sanity&quot;);
<span class="udiff-line-modified-removed">-       assert(_float_mirror != NULL &amp;&amp; _double_mirror != NULL &amp;&amp;</span>
<span class="udiff-line-removed">-              _byte_mirror  != NULL &amp;&amp; _byte_mirror   != NULL &amp;&amp;</span>
<span class="udiff-line-removed">-              _bool_mirror  != NULL &amp;&amp; _char_mirror   != NULL &amp;&amp;</span>
<span class="udiff-line-removed">-              _long_mirror  != NULL &amp;&amp; _short_mirror  != NULL &amp;&amp;</span>
<span class="udiff-line-removed">-              _void_mirror  != NULL, &quot;Sanity&quot;);</span>
<span class="udiff-line-modified-added">+       PRIMITIVE_MIRRORS_DO(ASSERT_MIRROR_NOT_NULL);</span>
      } else
<span class="udiff-line-added">+       // _int_mirror could be NULL if archived heap is not mapped.</span>
  #endif
      {
        _int_mirror     =
          java_lang_Class::create_basic_type_mirror(&quot;int&quot;,    T_INT, CHECK);
        _float_mirror   =
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -524,11 +509,11 @@</span>
    return _reference_pending_list != NULL;
  }
  
  oop Universe::swap_reference_pending_list(oop list) {
    assert_pll_locked(is_locked);
<span class="udiff-line-modified-removed">-   return Atomic::xchg(list, &amp;_reference_pending_list);</span>
<span class="udiff-line-modified-added">+   return Atomic::xchg(&amp;_reference_pending_list, list);</span>
  }
  
  #undef assert_pll_locked
  #undef assert_pll_ownership
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -557,11 +542,11 @@</span>
    k-&gt;itable().initialize_itable(false, CHECK);
  }
  
  
  void Universe::reinitialize_itables(TRAPS) {
<span class="udiff-line-modified-removed">-   MutexLocker mcld(ClassLoaderDataGraph_lock);</span>
<span class="udiff-line-modified-added">+   MutexLocker mcld(THREAD, ClassLoaderDataGraph_lock);</span>
    ClassLoaderDataGraph::dictionary_classes_do(initialize_itable_for_klass, CHECK);
  }
  
  
  bool Universe::on_page_boundary(void* addr) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -573,17 +558,17 @@</span>
    // never attempt to fill in the stack trace of preallocated errors that do not have
    // backtrace. These errors are kept alive forever and may be &quot;re-used&quot; when all
    // preallocated errors with backtrace have been consumed. Also need to avoid
    // a potential loop which could happen if an out of memory occurs when attempting
    // to allocate the backtrace.
<span class="udiff-line-modified-removed">-   return ((!oopDesc::equals(throwable(), Universe::_out_of_memory_error_java_heap)) &amp;&amp;</span>
<span class="udiff-line-modified-removed">-           (!oopDesc::equals(throwable(), Universe::_out_of_memory_error_metaspace))  &amp;&amp;</span>
<span class="udiff-line-modified-removed">-           (!oopDesc::equals(throwable(), Universe::_out_of_memory_error_class_metaspace))  &amp;&amp;</span>
<span class="udiff-line-modified-removed">-           (!oopDesc::equals(throwable(), Universe::_out_of_memory_error_array_size)) &amp;&amp;</span>
<span class="udiff-line-modified-removed">-           (!oopDesc::equals(throwable(), Universe::_out_of_memory_error_gc_overhead_limit)) &amp;&amp;</span>
<span class="udiff-line-modified-removed">-           (!oopDesc::equals(throwable(), Universe::_out_of_memory_error_realloc_objects)) &amp;&amp;</span>
<span class="udiff-line-modified-removed">-           (!oopDesc::equals(throwable(), Universe::_out_of_memory_error_retry)));</span>
<span class="udiff-line-modified-added">+   return ((throwable() != Universe::_out_of_memory_error_java_heap) &amp;&amp;</span>
<span class="udiff-line-modified-added">+           (throwable() != Universe::_out_of_memory_error_metaspace)  &amp;&amp;</span>
<span class="udiff-line-modified-added">+           (throwable() != Universe::_out_of_memory_error_class_metaspace)  &amp;&amp;</span>
<span class="udiff-line-modified-added">+           (throwable() != Universe::_out_of_memory_error_array_size) &amp;&amp;</span>
<span class="udiff-line-modified-added">+           (throwable() != Universe::_out_of_memory_error_gc_overhead_limit) &amp;&amp;</span>
<span class="udiff-line-modified-added">+           (throwable() != Universe::_out_of_memory_error_realloc_objects) &amp;&amp;</span>
<span class="udiff-line-modified-added">+           (throwable() != Universe::_out_of_memory_error_retry));</span>
  }
  
  
  oop Universe::gen_out_of_memory_error(oop default_err) {
    // generate an out of memory error:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -593,11 +578,11 @@</span>
    //   provided by the default error.
    // - otherwise, return the default error, without a stack trace.
    int next;
    if ((_preallocated_out_of_memory_error_avail_count &gt; 0) &amp;&amp;
        SystemDictionary::Throwable_klass()-&gt;is_initialized()) {
<span class="udiff-line-modified-removed">-     next = (int)Atomic::add(-1, &amp;_preallocated_out_of_memory_error_avail_count);</span>
<span class="udiff-line-modified-added">+     next = (int)Atomic::add(&amp;_preallocated_out_of_memory_error_avail_count, -1);</span>
      assert(next &lt; (int)PreallocatedOutOfMemoryErrorCount, &quot;avail count is corrupt&quot;);
    } else {
      next = -1;
    }
    if (next &lt; 0) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -661,16 +646,18 @@</span>
  
    JavaClasses::compute_hard_coded_offsets();
  
    initialize_global_behaviours();
  
<span class="udiff-line-added">+   GCConfig::arguments()-&gt;initialize_heap_sizes();</span>
<span class="udiff-line-added">+ </span>
    jint status = Universe::initialize_heap();
    if (status != JNI_OK) {
      return status;
    }
  
<span class="udiff-line-modified-removed">-   SystemDictionary::initialize_oop_storage();</span>
<span class="udiff-line-modified-added">+   Universe::initialize_tlab();</span>
  
    Metaspace::global_initialize();
  
    // Initialize performance counters for metaspaces
    MetaspaceCounters::initialize_performance_counters();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -707,121 +694,49 @@</span>
    } else
  #endif
    {
      SymbolTable::create_table();
      StringTable::create_table();
<span class="udiff-line-added">+   }</span>
  
  #if INCLUDE_CDS
<span class="udiff-line-modified-removed">-     if (DumpSharedSpaces) {</span>
<span class="udiff-line-modified-removed">-       MetaspaceShared::prepare_for_dumping();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-modified-added">+   if (Arguments::is_dumping_archive()) {</span>
<span class="udiff-line-modified-added">+     MetaspaceShared::prepare_for_dumping();</span>
    }
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
    if (strlen(VerifySubSet) &gt; 0) {
      Universe::initialize_verify_flags();
    }
  
    ResolvedMethodTable::create_table();
  
    return JNI_OK;
  }
  
<span class="udiff-line-removed">- CollectedHeap* Universe::create_heap() {</span>
<span class="udiff-line-removed">-   assert(_collectedHeap == NULL, &quot;Heap already created&quot;);</span>
<span class="udiff-line-removed">-   return GCConfig::arguments()-&gt;create_heap();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // Choose the heap base address and oop encoding mode</span>
<span class="udiff-line-removed">- // when compressed oops are used:</span>
<span class="udiff-line-removed">- // Unscaled  - Use 32-bits oops without encoding when</span>
<span class="udiff-line-removed">- //     NarrowOopHeapBaseMin + heap_size &lt; 4Gb</span>
<span class="udiff-line-removed">- // ZeroBased - Use zero based compressed oops with encoding when</span>
<span class="udiff-line-removed">- //     NarrowOopHeapBaseMin + heap_size &lt; 32Gb</span>
<span class="udiff-line-removed">- // HeapBased - Use compressed oops with heap base + encoding.</span>
<span class="udiff-line-removed">- </span>
  jint Universe::initialize_heap() {
<span class="udiff-line-modified-removed">-   _collectedHeap = create_heap();</span>
<span class="udiff-line-modified-added">+   assert(_collectedHeap == NULL, &quot;Heap already created&quot;);</span>
<span class="udiff-line-added">+   _collectedHeap = GCConfig::arguments()-&gt;create_heap();</span>
    jint status = _collectedHeap-&gt;initialize();
<span class="udiff-line-removed">-   if (status != JNI_OK) {</span>
<span class="udiff-line-removed">-     return status;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   log_info(gc)(&quot;Using %s&quot;, _collectedHeap-&gt;name());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   ThreadLocalAllocBuffer::set_max_size(Universe::heap()-&gt;max_tlab_size());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifdef _LP64</span>
<span class="udiff-line-removed">-   if (UseCompressedOops) {</span>
<span class="udiff-line-removed">-     // Subtract a page because something can get allocated at heap base.</span>
<span class="udiff-line-removed">-     // This also makes implicit null checking work, because the</span>
<span class="udiff-line-removed">-     // memory+1 page below heap_base needs to cause a signal.</span>
<span class="udiff-line-removed">-     // See needs_explicit_null_check.</span>
<span class="udiff-line-removed">-     // Only set the heap base for compressed oops because it indicates</span>
<span class="udiff-line-removed">-     // compressed oops for pstack code.</span>
<span class="udiff-line-removed">-     if ((uint64_t)Universe::heap()-&gt;reserved_region().end() &gt; UnscaledOopHeapMax) {</span>
<span class="udiff-line-removed">-       // Didn&#39;t reserve heap below 4Gb.  Must shift.</span>
<span class="udiff-line-removed">-       Universe::set_narrow_oop_shift(LogMinObjAlignmentInBytes);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     if ((uint64_t)Universe::heap()-&gt;reserved_region().end() &lt;= OopEncodingHeapMax) {</span>
<span class="udiff-line-removed">-       // Did reserve heap below 32Gb. Can use base == 0;</span>
<span class="udiff-line-removed">-       Universe::set_narrow_oop_base(0);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     AOTLoader::set_narrow_oop_shift();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     Universe::set_narrow_ptrs_base(Universe::narrow_oop_base());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     LogTarget(Info, gc, heap, coops) lt;</span>
<span class="udiff-line-removed">-     if (lt.is_enabled()) {</span>
<span class="udiff-line-removed">-       ResourceMark rm;</span>
<span class="udiff-line-removed">-       LogStream ls(lt);</span>
<span class="udiff-line-removed">-       Universe::print_compressed_oops_mode(&amp;ls);</span>
<span class="udiff-line-removed">-     }</span>
  
<span class="udiff-line-modified-removed">-     // Tell tests in which mode we run.</span>
<span class="udiff-line-modified-removed">-     Arguments::PropertyList_add(new SystemProperty(&quot;java.vm.compressedOopsMode&quot;,</span>
<span class="udiff-line-removed">-                                                    narrow_oop_mode_to_string(narrow_oop_mode()),</span>
<span class="udiff-line-removed">-                                                    false));</span>
<span class="udiff-line-modified-added">+   if (status == JNI_OK) {</span>
<span class="udiff-line-modified-added">+     log_info(gc)(&quot;Using %s&quot;, _collectedHeap-&gt;name());</span>
    }
<span class="udiff-line-removed">-   // Universe::narrow_oop_base() is one page below the heap.</span>
<span class="udiff-line-removed">-   assert((intptr_t)Universe::narrow_oop_base() &lt;= (intptr_t)(Universe::heap()-&gt;base() -</span>
<span class="udiff-line-removed">-          os::vm_page_size()) ||</span>
<span class="udiff-line-removed">-          Universe::narrow_oop_base() == NULL, &quot;invalid value&quot;);</span>
<span class="udiff-line-removed">-   assert(Universe::narrow_oop_shift() == LogMinObjAlignmentInBytes ||</span>
<span class="udiff-line-removed">-          Universe::narrow_oop_shift() == 0, &quot;invalid value&quot;);</span>
<span class="udiff-line-removed">- #endif</span>
  
<span class="udiff-line-modified-removed">-   // We will never reach the CATCH below since Exceptions::_throw will cause</span>
<span class="udiff-line-modified-removed">-   // the VM to exit if an exception is thrown during initialization</span>
<span class="udiff-line-modified-added">+   return status;</span>
<span class="udiff-line-modified-added">+ }</span>
  
<span class="udiff-line-added">+ void Universe::initialize_tlab() {</span>
<span class="udiff-line-added">+   ThreadLocalAllocBuffer::set_max_size(Universe::heap()-&gt;max_tlab_size());</span>
    if (UseTLAB) {
      assert(Universe::heap()-&gt;supports_tlab_allocation(),
             &quot;Should support thread-local allocation buffers&quot;);
      ThreadLocalAllocBuffer::startup_initialization();
    }
<span class="udiff-line-removed">-   return JNI_OK;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void Universe::print_compressed_oops_mode(outputStream* st) {</span>
<span class="udiff-line-removed">-   st-&gt;print(&quot;Heap address: &quot; PTR_FORMAT &quot;, size: &quot; SIZE_FORMAT &quot; MB&quot;,</span>
<span class="udiff-line-removed">-             p2i(Universe::heap()-&gt;base()), Universe::heap()-&gt;reserved_region().byte_size()/M);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   st-&gt;print(&quot;, Compressed Oops mode: %s&quot;, narrow_oop_mode_to_string(narrow_oop_mode()));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (Universe::narrow_oop_base() != 0) {</span>
<span class="udiff-line-removed">-     st-&gt;print(&quot;: &quot; PTR_FORMAT, p2i(Universe::narrow_oop_base()));</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (Universe::narrow_oop_shift() != 0) {</span>
<span class="udiff-line-removed">-     st-&gt;print(&quot;, Oop shift amount: %d&quot;, Universe::narrow_oop_shift());</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (!Universe::narrow_oop_use_implicit_null_checks()) {</span>
<span class="udiff-line-removed">-     st-&gt;print(&quot;, no protected page in front of the heap&quot;);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   st-&gt;cr();</span>
  }
  
<span class="udiff-line-modified-removed">- ReservedSpace Universe::reserve_heap(size_t heap_size, size_t alignment) {</span>
<span class="udiff-line-modified-added">+ ReservedHeapSpace Universe::reserve_heap(size_t heap_size, size_t alignment) {</span>
  
    assert(alignment &lt;= Arguments::conservative_max_heap_alignment(),
           &quot;actual alignment &quot; SIZE_FORMAT &quot; must be within maximum heap alignment &quot; SIZE_FORMAT,
           alignment, Arguments::conservative_max_heap_alignment());
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -840,20 +755,20 @@</span>
    if (total_rs.is_reserved()) {
      assert((total_reserved == total_rs.size()) &amp;&amp; ((uintptr_t)total_rs.base() % alignment == 0),
             &quot;must be exactly of required size and alignment&quot;);
      // We are good.
  
<span class="udiff-line-removed">-     if (UseCompressedOops) {</span>
<span class="udiff-line-removed">-       // Universe::initialize_heap() will reset this to NULL if unscaled</span>
<span class="udiff-line-removed">-       // or zero-based narrow oops are actually used.</span>
<span class="udiff-line-removed">-       // Else heap start and base MUST differ, so that NULL can be encoded nonambigous.</span>
<span class="udiff-line-removed">-       Universe::set_narrow_oop_base((address)total_rs.compressed_oop_base());</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      if (AllocateHeapAt != NULL) {
        log_info(gc,heap)(&quot;Successfully allocated Java heap at location %s&quot;, AllocateHeapAt);
      }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (UseCompressedOops) {</span>
<span class="udiff-line-added">+       CompressedOops::initialize(total_rs);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Universe::calculate_verify_data((HeapWord*)total_rs.base(), (HeapWord*)total_rs.end());</span>
<span class="udiff-line-added">+ </span>
      return total_rs;
    }
  
    vm_exit_during_initialization(
      err_msg(&quot;Could not reserve enough space for &quot; SIZE_FORMAT &quot;KB object heap&quot;,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -870,51 +785,17 @@</span>
  void Universe::update_heap_info_at_gc() {
    _heap_capacity_at_last_gc = heap()-&gt;capacity();
    _heap_used_at_last_gc     = heap()-&gt;used();
  }
  
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- const char* Universe::narrow_oop_mode_to_string(Universe::NARROW_OOP_MODE mode) {</span>
<span class="udiff-line-removed">-   switch (mode) {</span>
<span class="udiff-line-removed">-     case UnscaledNarrowOop:</span>
<span class="udiff-line-removed">-       return &quot;32-bit&quot;;</span>
<span class="udiff-line-removed">-     case ZeroBasedNarrowOop:</span>
<span class="udiff-line-removed">-       return &quot;Zero based&quot;;</span>
<span class="udiff-line-removed">-     case DisjointBaseNarrowOop:</span>
<span class="udiff-line-removed">-       return &quot;Non-zero disjoint base&quot;;</span>
<span class="udiff-line-removed">-     case HeapBasedNarrowOop:</span>
<span class="udiff-line-removed">-       return &quot;Non-zero based&quot;;</span>
<span class="udiff-line-removed">-     default:</span>
<span class="udiff-line-removed">-       ShouldNotReachHere();</span>
<span class="udiff-line-removed">-       return &quot;&quot;;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- Universe::NARROW_OOP_MODE Universe::narrow_oop_mode() {</span>
<span class="udiff-line-removed">-   if (narrow_oop_base_disjoint()) {</span>
<span class="udiff-line-removed">-     return DisjointBaseNarrowOop;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (narrow_oop_base() != 0) {</span>
<span class="udiff-line-removed">-     return HeapBasedNarrowOop;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (narrow_oop_shift() != 0) {</span>
<span class="udiff-line-removed">-     return ZeroBasedNarrowOop;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   return UnscaledNarrowOop;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  void initialize_known_method(LatestMethodCache* method_cache,
                               InstanceKlass* ik,
                               const char* method,
                               Symbol* signature,
                               bool is_static, TRAPS)
  {
<span class="udiff-line-modified-removed">-   TempNewSymbol name = SymbolTable::new_symbol(method, CHECK);</span>
<span class="udiff-line-modified-added">+   TempNewSymbol name = SymbolTable::new_symbol(method);</span>
    Method* m = NULL;
    // The klass must be linked before looking up the method.
    if (!ik-&gt;link_class_or_fail(THREAD) ||
        ((m = ik-&gt;find_method(name, signature)) == NULL) ||
        is_static != m-&gt;is_static()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1063,11 +944,11 @@</span>
    Universe::initialize_known_methods(CHECK_false);
  
    // This needs to be done before the first scavenge/gc, since
    // it&#39;s an input to soft ref clearing policy.
    {
<span class="udiff-line-modified-removed">-     MutexLocker x(Heap_lock);</span>
<span class="udiff-line-modified-added">+     MutexLocker x(THREAD, Heap_lock);</span>
      Universe::update_heap_info_at_gc();
    }
  
    // (&quot;weak&quot;) refs processing infrastructure initialization
    Universe::heap()-&gt;post_initialize();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1149,10 +1030,12 @@</span>
        verify_flags |= Verify_MetaspaceUtils;
      } else if (strcmp(token, &quot;jni_handles&quot;) == 0) {
        verify_flags |= Verify_JNIHandles;
      } else if (strcmp(token, &quot;codecache_oops&quot;) == 0) {
        verify_flags |= Verify_CodeCacheOops;
<span class="udiff-line-added">+     } else if (strcmp(token, &quot;resolved_method_table&quot;) == 0) {</span>
<span class="udiff-line-added">+       verify_flags |= Verify_ResolvedMethodTable;</span>
      } else {
        vm_exit_during_initialization(err_msg(&quot;VerifySubSet: \&#39;%s\&#39; memory sub-system is unknown, please correct it&quot;, token));
      }
      token = strtok_r(NULL, delimiter, &amp;save_ptr);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1201,11 +1084,11 @@</span>
      log_debug(gc, verify)(&quot;StringTable&quot;);
      StringTable::verify();
    }
    if (should_verify_subset(Verify_CodeCache)) {
    {
<span class="udiff-line-modified-removed">-     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
      log_debug(gc, verify)(&quot;CodeCache&quot;);
      CodeCache::verify();
    }
    }
    if (should_verify_subset(Verify_SystemDictionary)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1228,10 +1111,14 @@</span>
    }
    if (should_verify_subset(Verify_CodeCacheOops)) {
      log_debug(gc, verify)(&quot;CodeCache Oops&quot;);
      CodeCache::verify_oops();
    }
<span class="udiff-line-added">+   if (should_verify_subset(Verify_ResolvedMethodTable)) {</span>
<span class="udiff-line-added">+     log_debug(gc, verify)(&quot;ResolvedMethodTable Oops&quot;);</span>
<span class="udiff-line-added">+     ResolvedMethodTable::verify();</span>
<span class="udiff-line-added">+   }</span>
  
    _verify_in_progress = false;
  }
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1269,28 +1156,24 @@</span>
  }
  
  // Oop verification (see MacroAssembler::verify_oop)
  
  uintptr_t Universe::verify_oop_mask() {
<span class="udiff-line-removed">-   MemRegion m = heap()-&gt;reserved_region();</span>
<span class="udiff-line-removed">-   calculate_verify_data(m.start(), m.end());</span>
    return _verify_oop_mask;
  }
  
  uintptr_t Universe::verify_oop_bits() {
<span class="udiff-line-removed">-   MemRegion m = heap()-&gt;reserved_region();</span>
<span class="udiff-line-removed">-   calculate_verify_data(m.start(), m.end());</span>
    return _verify_oop_bits;
  }
  
  uintptr_t Universe::verify_mark_mask() {
<span class="udiff-line-modified-removed">-   return markOopDesc::lock_mask_in_place;</span>
<span class="udiff-line-modified-added">+   return markWord::lock_mask_in_place;</span>
  }
  
  uintptr_t Universe::verify_mark_bits() {
    intptr_t mask = verify_mark_mask();
<span class="udiff-line-modified-removed">-   intptr_t bits = (intptr_t)markOopDesc::prototype();</span>
<span class="udiff-line-modified-added">+   intptr_t bits = (intptr_t)markWord::prototype().value();</span>
    assert((bits &amp; ~mask) == 0, &quot;no stray header bits&quot;);
    return bits;
  }
  #endif // PRODUCT
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1328,14 +1211,14 @@</span>
      if (_fullgc_alot_dummy_next &gt;= _fullgc_alot_dummy_array-&gt;length()) {
        // No more dummies to release, release entire array instead
        _fullgc_alot_dummy_array = NULL;
        return false;
      }
<span class="udiff-line-modified-removed">-     if (!UseConcMarkSweepGC) {</span>
<span class="udiff-line-modified-removed">-       // Release dummy at bottom of old generation</span>
<span class="udiff-line-modified-removed">-       _fullgc_alot_dummy_array-&gt;obj_at_put(_fullgc_alot_dummy_next++, NULL);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     // Release dummy at bottom of old generation</span>
<span class="udiff-line-modified-added">+     _fullgc_alot_dummy_array-&gt;obj_at_put(_fullgc_alot_dummy_next++, NULL);</span>
<span class="udiff-line-modified-added">+ </span>
      // Release dummy at bottom of permanent generation
      _fullgc_alot_dummy_array-&gt;obj_at_put(_fullgc_alot_dummy_next++, NULL);
    }
    return true;
  }
</pre>
<center><a href="resourceArea.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="universe.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/memory/metaspaceClosure.hpp b/src/hotspot/share/memory/metaspaceClosure.hpp
--- a/src/hotspot/share/memory/metaspaceClosure.hpp
+++ b/src/hotspot/share/memory/metaspaceClosure.hpp
@@ -26,10 +26,11 @@
 #define SHARE_MEMORY_METASPACECLOSURE_HPP
 
 #include "logging/log.hpp"
 #include "memory/allocation.hpp"
 #include "oops/array.hpp"
+#include "utilities/globalDefinitions.hpp"
 #include "utilities/growableArray.hpp"
 #include "utilities/hashtable.inline.hpp"
 
 // The metadata hierarchy is separate from the oop hierarchy
   class MetaspaceObj;        // no C++ vtable
@@ -73,10 +74,14 @@
     _writable,
     _not_writable,
     _default
   };
 
+  enum SpecialRef {
+    _method_entry_ref
+  };
+
   // class MetaspaceClosure::Ref --
   //
   // MetaspaceClosure can be viewed as a very simple type of copying garbage
   // collector. For it to function properly, it requires each subclass of
   // MetaspaceObj to provide two methods:
@@ -99,30 +104,44 @@
   //         MetaspaceObj *_obj;
   //         Array<int>* foo() { return (Array<int>*)_obj; }
   //         Symbol*     bar() { return (Symbol*)    _obj; }
   //
   // [2] All Array<T> dimensions are statically declared.
-  class Ref {
+  class Ref : public CHeapObj<mtInternal> {
+    Writability _writability;
+    Ref* _next;
+    NONCOPYABLE(Ref);
+
   protected:
     virtual void** mpp() const = 0;
+    Ref(Writability w) : _writability(w), _next(NULL) {}
   public:
     virtual bool not_null() const = 0;
     virtual int size() const = 0;
     virtual void metaspace_pointers_do(MetaspaceClosure *it) const = 0;
     virtual void metaspace_pointers_do_at(MetaspaceClosure *it, address new_loc) const = 0;
     virtual MetaspaceObj::Type msotype() const = 0;
     virtual bool is_read_only_by_default() const = 0;
+    virtual ~Ref() {}
 
     address obj() const {
       // In some rare cases (see CPSlot in constantPool.hpp) we store some flags in the lowest
       // 2 bits of a MetaspaceObj pointer. Unmask these when manipulating the pointer.
       uintx p = (uintx)*mpp();
       return (address)(p & (~FLAG_MASK));
     }
 
+    address* addr() const {
+      return (address*)mpp();
+    }
+
     void update(address new_loc) const;
 
+    Writability writability() const { return _writability; };
+    void set_next(Ref* n)           { _next = n; }
+    Ref* next() const               { return _next; }
+
   private:
     static const uintx FLAG_MASK = 0x03;
 
     int flag_bits() const {
       uintx p = (uintx)*mpp();
@@ -141,11 +160,11 @@
     virtual void** mpp() const {
       return (void**)_mpp;
     }
 
   public:
-    ObjectRef(T** mpp) : _mpp(mpp) {}
+    ObjectRef(T** mpp, Writability w) : Ref(w), _mpp(mpp) {}
 
     virtual bool is_read_only_by_default() const { return T::is_read_only_by_default(); }
     virtual bool not_null()                const { return dereference() != NULL; }
     virtual int size()                     const { return dereference()->size(); }
     virtual MetaspaceObj::Type msotype()   const { return dereference()->type(); }
@@ -168,11 +187,11 @@
     virtual void** mpp() const {
       return (void**)_mpp;
     }
 
   public:
-    PrimitiveArrayRef(Array<T>** mpp) : _mpp(mpp) {}
+    PrimitiveArrayRef(Array<T>** mpp, Writability w) : Ref(w), _mpp(mpp) {}
 
     // all Arrays are read-only by default
     virtual bool is_read_only_by_default() const { return true; }
     virtual bool not_null()                const { return dereference() != NULL;  }
     virtual int size()                     const { return dereference()->size(); }
@@ -198,11 +217,11 @@
     virtual void** mpp() const {
       return (void**)_mpp;
     }
 
   public:
-    PointerArrayRef(Array<T*>** mpp) : _mpp(mpp) {}
+    PointerArrayRef(Array<T*>** mpp, Writability w) : Ref(w), _mpp(mpp) {}
 
     // all Arrays are read-only by default
     virtual bool is_read_only_by_default() const { return true; }
     virtual bool not_null()                const { return dereference() != NULL; }
     virtual int size()                     const { return dereference()->size(); }
@@ -222,39 +241,58 @@
         it->push(mpp);
       }
     }
   };
 
-  void push_impl(Ref* ref, Writability w);
+  // If recursion is too deep, save the Refs in _pending_refs, and push them later using
+  // MetaspaceClosure::finish()
+  static const int MAX_NEST_LEVEL = 5;
+  Ref* _pending_refs;
+  int _nest_level;
+
+  void push_impl(Ref* ref);
+  void do_push(Ref* ref);
 
 public:
+  MetaspaceClosure(): _pending_refs(NULL), _nest_level(0) {}
+  ~MetaspaceClosure();
+
+  void finish();
+
   // returns true if we want to keep iterating the pointers embedded inside <ref>
   virtual bool do_ref(Ref* ref, bool read_only) = 0;
 
   // When you do:
   //     void MyType::metaspace_pointers_do(MetaspaceClosure* it) {
   //       it->push(_my_field)
   //
   // C++ will try to match the "most specific" template function. This one will
   // will be matched if possible (if mpp is an Array<> of any pointer type).
   template <typename T> void push(Array<T*>** mpp, Writability w = _default) {
-    PointerArrayRef<T> ref(mpp);
-    push_impl(&ref, w);
+    push_impl(new PointerArrayRef<T>(mpp, w));
   }
 
   // If the above function doesn't match (mpp is an Array<>, but T is not a pointer type), then
   // this is the second choice.
   template <typename T> void push(Array<T>** mpp, Writability w = _default) {
-    PrimitiveArrayRef<T> ref(mpp);
-    push_impl(&ref, w);
+    push_impl(new PrimitiveArrayRef<T>(mpp, w));
   }
 
   // If the above function doesn't match (mpp is not an Array<> type), then
   // this will be matched by default.
   template <class T> void push(T** mpp, Writability w = _default) {
-    ObjectRef<T> ref(mpp);
-    push_impl(&ref, w);
+    push_impl(new ObjectRef<T>(mpp, w));
+  }
+
+  template <class T> void push_method_entry(T** mpp, intptr_t* p) {
+    push_special(_method_entry_ref, new ObjectRef<T>(mpp, _default), (intptr_t*)p);
+  }
+
+  // This is for tagging special pointers that are not a reference to MetaspaceObj. It's currently
+  // used to mark the method entry points in Method/ConstMethod.
+  virtual void push_special(SpecialRef type, Ref* obj, intptr_t* p) {
+    assert(type == _method_entry_ref, "only special type allowed for now");
   }
 };
 
 // This is a special MetaspaceClosure that visits each unique MetaspaceObj once.
 class UniqueMetaspaceClosure : public MetaspaceClosure {
@@ -264,11 +302,11 @@
   // Do not override. Returns true if we are discovering ref->obj() for the first time.
   virtual bool do_ref(Ref* ref, bool read_only);
 
 public:
   // Gets called the first time we discover an object.
-  virtual void do_unique_ref(Ref* ref, bool read_only) = 0;
+  virtual bool do_unique_ref(Ref* ref, bool read_only) = 0;
   UniqueMetaspaceClosure() : _has_been_visited(INITIAL_TABLE_SIZE) {}
 
 private:
   KVHashtable<address, bool, mtInternal> _has_been_visited;
 };

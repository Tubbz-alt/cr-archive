<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/memory/universe.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="universe.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="virtualspace.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/universe.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -23,10 +23,11 @@</span>
   */
  
  #ifndef SHARE_MEMORY_UNIVERSE_HPP
  #define SHARE_MEMORY_UNIVERSE_HPP
  
<span class="udiff-line-added">+ #include &quot;gc/shared/verifyOption.hpp&quot;</span>
  #include &quot;oops/array.hpp&quot;
  #include &quot;runtime/handles.hpp&quot;
  #include &quot;utilities/growableArray.hpp&quot;
  
  // Universe is a name space holding known system classes and objects in the VM.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -68,33 +69,10 @@</span>
      f-&gt;do_ptr((void**)&amp;_klass);
    }
    void metaspace_pointers_do(MetaspaceClosure* it);
  };
  
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // For UseCompressedOops.</span>
<span class="udiff-line-removed">- struct NarrowPtrStruct {</span>
<span class="udiff-line-removed">-   // Base address for oop-within-java-object materialization.</span>
<span class="udiff-line-removed">-   // NULL if using wide oops or zero based narrow oops.</span>
<span class="udiff-line-removed">-   address _base;</span>
<span class="udiff-line-removed">-   // Number of shift bits for encoding/decoding narrow ptrs.</span>
<span class="udiff-line-removed">-   // 0 if using wide ptrs or zero based unscaled narrow ptrs,</span>
<span class="udiff-line-removed">-   // LogMinObjAlignmentInBytes/LogKlassAlignmentInBytes otherwise.</span>
<span class="udiff-line-removed">-   int     _shift;</span>
<span class="udiff-line-removed">-   // Generate code with implicit null checks for narrow ptrs.</span>
<span class="udiff-line-removed">-   bool    _use_implicit_null_checks;</span>
<span class="udiff-line-removed">- };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- enum VerifyOption {</span>
<span class="udiff-line-removed">-       VerifyOption_Default = 0,</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       // G1</span>
<span class="udiff-line-removed">-       VerifyOption_G1UsePrevMarking = VerifyOption_Default,</span>
<span class="udiff-line-removed">-       VerifyOption_G1UseNextMarking = VerifyOption_G1UsePrevMarking + 1,</span>
<span class="udiff-line-removed">-       VerifyOption_G1UseFullMarking = VerifyOption_G1UseNextMarking + 1</span>
<span class="udiff-line-removed">- };</span>
<span class="udiff-line-removed">- </span>
  class Universe: AllStatic {
    // Ugh.  Universe is much too friendly.
    friend class MarkSweep;
    friend class oopDesc;
    friend class ClassLoader;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -180,17 +158,10 @@</span>
    // The particular choice of collected heap.
    static CollectedHeap* _collectedHeap;
  
    static intptr_t _non_oop_bits;
  
<span class="udiff-line-removed">-   // For UseCompressedOops.</span>
<span class="udiff-line-removed">-   static struct NarrowPtrStruct _narrow_oop;</span>
<span class="udiff-line-removed">-   // For UseCompressedClassPointers.</span>
<span class="udiff-line-removed">-   static struct NarrowPtrStruct _narrow_klass;</span>
<span class="udiff-line-removed">-   static address _narrow_ptrs_base;</span>
<span class="udiff-line-removed">-   // CompressedClassSpaceSize set to 1GB, but appear 3GB away from _narrow_ptrs_base during CDS dump.</span>
<span class="udiff-line-removed">-   static uint64_t _narrow_klass_range;</span>
    // array of dummy objects used with +FullGCAlot
    debug_only(static objArrayOop _fullgc_alot_dummy_array;)
    // index of next entry to clear
    debug_only(static int         _fullgc_alot_dummy_next;)
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -211,12 +182,12 @@</span>
  
    // Historic gc information
    static size_t _heap_capacity_at_last_gc;
    static size_t _heap_used_at_last_gc;
  
<span class="udiff-line-removed">-   static CollectedHeap* create_heap();</span>
    static jint initialize_heap();
<span class="udiff-line-added">+   static void initialize_tlab();</span>
    static void initialize_basic_type_mirrors(TRAPS);
    static void fixup_mirrors(TRAPS);
  
    static void reinitialize_vtable_of(Klass* k, TRAPS);
    static void reinitialize_vtables(TRAPS);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -229,40 +200,23 @@</span>
    static oop check_mirror(oop m) {
      assert(m != NULL, &quot;mirror not initialized&quot;);
      return m;
    }
  
<span class="udiff-line-removed">-   static void     set_narrow_oop_base(address base) {</span>
<span class="udiff-line-removed">-     assert(UseCompressedOops, &quot;no compressed oops?&quot;);</span>
<span class="udiff-line-removed">-     _narrow_oop._base    = base;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   static void     set_narrow_klass_base(address base) {</span>
<span class="udiff-line-removed">-     assert(UseCompressedClassPointers, &quot;no compressed klass ptrs?&quot;);</span>
<span class="udiff-line-removed">-     _narrow_klass._base   = base;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   static void     set_narrow_klass_range(uint64_t range) {</span>
<span class="udiff-line-removed">-      assert(UseCompressedClassPointers, &quot;no compressed klass ptrs?&quot;);</span>
<span class="udiff-line-removed">-      _narrow_klass_range = range;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   static void     set_narrow_oop_use_implicit_null_checks(bool use) {</span>
<span class="udiff-line-removed">-     assert(UseCompressedOops, &quot;no compressed ptrs?&quot;);</span>
<span class="udiff-line-removed">-     _narrow_oop._use_implicit_null_checks   = use;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
    // Debugging
    static int _verify_count;                           // number of verifies done
  
    // True during call to verify().  Should only be set/cleared in verify().
    static bool _verify_in_progress;
    static long verify_flags;
  
    static uintptr_t _verify_oop_mask;
    static uintptr_t _verify_oop_bits;
  
<span class="udiff-line-added">+  public:</span>
    static void calculate_verify_data(HeapWord* low_boundary, HeapWord* high_boundary) PRODUCT_RETURN;
  
<span class="udiff-line-removed">-  public:</span>
    // Known classes in the VM
    static Klass* boolArrayKlassObj()                 { return typeArrayKlassObj(T_BOOLEAN); }
    static Klass* byteArrayKlassObj()                 { return typeArrayKlassObj(T_BYTE); }
    static Klass* charArrayKlassObj()                 { return typeArrayKlassObj(T_CHAR); }
    static Klass* intArrayKlassObj()                  { return typeArrayKlassObj(T_INT); }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -369,75 +323,12 @@</span>
    static oop delayed_stack_overflow_error_message()   { return _delayed_stack_overflow_error_message; }
  
    // The particular choice of collected heap.
    static CollectedHeap* heap() { return _collectedHeap; }
  
<span class="udiff-line-removed">-   // For UseCompressedOops</span>
<span class="udiff-line-removed">-   // Narrow Oop encoding mode:</span>
<span class="udiff-line-removed">-   // 0 - Use 32-bits oops without encoding when</span>
<span class="udiff-line-removed">-   //     NarrowOopHeapBaseMin + heap_size &lt; 4Gb</span>
<span class="udiff-line-removed">-   // 1 - Use zero based compressed oops with encoding when</span>
<span class="udiff-line-removed">-   //     NarrowOopHeapBaseMin + heap_size &lt; 32Gb</span>
<span class="udiff-line-removed">-   // 2 - Use compressed oops with disjoint heap base if</span>
<span class="udiff-line-removed">-   //     base is 32G-aligned and base &gt; 0. This allows certain</span>
<span class="udiff-line-removed">-   //     optimizations in encoding/decoding.</span>
<span class="udiff-line-removed">-   //     Disjoint: Bits used in base are disjoint from bits used</span>
<span class="udiff-line-removed">-   //     for oops ==&gt; oop = (cOop &lt;&lt; 3) | base.  One can disjoint</span>
<span class="udiff-line-removed">-   //     the bits of an oop into base and compressed oop.</span>
<span class="udiff-line-removed">-   // 3 - Use compressed oops with heap base + encoding.</span>
<span class="udiff-line-removed">-   enum NARROW_OOP_MODE {</span>
<span class="udiff-line-removed">-     UnscaledNarrowOop  = 0,</span>
<span class="udiff-line-removed">-     ZeroBasedNarrowOop = 1,</span>
<span class="udiff-line-removed">-     DisjointBaseNarrowOop = 2,</span>
<span class="udiff-line-removed">-     HeapBasedNarrowOop = 3,</span>
<span class="udiff-line-removed">-     AnyNarrowOopMode = 4</span>
<span class="udiff-line-removed">-   };</span>
<span class="udiff-line-removed">-   static NARROW_OOP_MODE narrow_oop_mode();</span>
<span class="udiff-line-removed">-   static const char* narrow_oop_mode_to_string(NARROW_OOP_MODE mode);</span>
<span class="udiff-line-removed">-   static address  narrow_oop_base()                  { return  _narrow_oop._base; }</span>
<span class="udiff-line-removed">-   // Test whether bits of addr and possible offsets into the heap overlap.</span>
<span class="udiff-line-removed">-   static bool     is_disjoint_heap_base_address(address addr) {</span>
<span class="udiff-line-removed">-     return (((uint64_t)(intptr_t)addr) &amp;</span>
<span class="udiff-line-removed">-             (((uint64_t)UCONST64(0xFFFFffffFFFFffff)) &gt;&gt; (32-LogMinObjAlignmentInBytes))) == 0;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   // Check for disjoint base compressed oops.</span>
<span class="udiff-line-removed">-   static bool     narrow_oop_base_disjoint()        {</span>
<span class="udiff-line-removed">-     return _narrow_oop._base != NULL &amp;&amp; is_disjoint_heap_base_address(_narrow_oop._base);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   // Check for real heapbased compressed oops.</span>
<span class="udiff-line-removed">-   // We must subtract the base as the bits overlap.</span>
<span class="udiff-line-removed">-   // If we negate above function, we also get unscaled and zerobased.</span>
<span class="udiff-line-removed">-   static bool     narrow_oop_base_overlaps()          {</span>
<span class="udiff-line-removed">-     return _narrow_oop._base != NULL &amp;&amp; !is_disjoint_heap_base_address(_narrow_oop._base);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   static bool  is_narrow_oop_base(void* addr)             { return (narrow_oop_base() == (address)addr); }</span>
<span class="udiff-line-removed">-   static int      narrow_oop_shift()                      { return  _narrow_oop._shift; }</span>
<span class="udiff-line-removed">-   static bool     narrow_oop_use_implicit_null_checks()   { return  _narrow_oop._use_implicit_null_checks; }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // For UseCompressedClassPointers</span>
<span class="udiff-line-removed">-   static address  narrow_klass_base()                     { return  _narrow_klass._base; }</span>
<span class="udiff-line-removed">-   static uint64_t narrow_klass_range()                    { return  _narrow_klass_range; }</span>
<span class="udiff-line-removed">-   static int      narrow_klass_shift()                    { return  _narrow_klass._shift; }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   static address* narrow_ptrs_base_addr()                 { return &amp;_narrow_ptrs_base; }</span>
<span class="udiff-line-removed">-   static void     set_narrow_ptrs_base(address a)         { _narrow_ptrs_base = a; }</span>
<span class="udiff-line-removed">-   static address  narrow_ptrs_base()                      { return _narrow_ptrs_base; }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   static void     print_compressed_oops_mode(outputStream* st);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // this is set in vm_version on sparc (and then reset in universe afaict)</span>
<span class="udiff-line-removed">-   static void     set_narrow_oop_shift(int shift)         {</span>
<span class="udiff-line-removed">-     _narrow_oop._shift   = shift;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   static void     set_narrow_klass_shift(int shift)       {</span>
<span class="udiff-line-removed">-     assert(shift == 0 || shift == LogKlassAlignmentInBytes, &quot;invalid shift for klass ptrs&quot;);</span>
<span class="udiff-line-removed">-     _narrow_klass._shift   = shift;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
    // Reserve Java heap and determine CompressedOops mode
<span class="udiff-line-modified-removed">-   static ReservedSpace reserve_heap(size_t heap_size, size_t alignment);</span>
<span class="udiff-line-modified-added">+   static ReservedHeapSpace reserve_heap(size_t heap_size, size_t alignment);</span>
  
    // Historic gc information
    static size_t get_heap_free_at_last_gc()             { return _heap_capacity_at_last_gc - _heap_used_at_last_gc; }
    static size_t get_heap_used_at_last_gc()             { return _heap_used_at_last_gc; }
    static void update_heap_info_at_gc();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -476,10 +367,11 @@</span>
      Verify_SystemDictionary = 32,
      Verify_ClassLoaderDataGraph = 64,
      Verify_MetaspaceUtils = 128,
      Verify_JNIHandles = 256,
      Verify_CodeCacheOops = 512,
<span class="udiff-line-added">+     Verify_ResolvedMethodTable = 1024,</span>
      Verify_All = -1
    };
    static void initialize_verify_flags();
    static bool should_verify_subset(uint subset);
    static bool verify_in_progress() { return _verify_in_progress; }
</pre>
<center><a href="universe.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="virtualspace.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
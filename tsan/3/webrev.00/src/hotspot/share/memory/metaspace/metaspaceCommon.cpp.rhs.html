<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/memory/metaspace/metaspaceCommon.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 
 27 #include &quot;memory/metaspace/metaspaceCommon.hpp&quot;
 28 #include &quot;memory/metaspace/virtualSpaceNode.hpp&quot;
 29 #include &quot;utilities/debug.hpp&quot;
 30 #include &quot;utilities/globalDefinitions.hpp&quot;
 31 #include &quot;utilities/ostream.hpp&quot;
 32 
 33 namespace metaspace {
 34 
 35 DEBUG_ONLY(internal_statistics_t g_internal_statistics;)
 36 
 37 // Print a size, in words, scaled.
 38 void print_scaled_words(outputStream* st, size_t word_size, size_t scale, int width) {
 39   print_human_readable_size(st, word_size * sizeof(MetaWord), scale, width);
 40 }
 41 
 42 // Convenience helper: prints a size value and a percentage.
 43 void print_scaled_words_and_percentage(outputStream* st, size_t word_size, size_t compare_word_size, size_t scale, int width) {
 44   print_scaled_words(st, word_size, scale, width);
 45   st-&gt;print(&quot; (&quot;);
 46   print_percentage(st, compare_word_size, word_size);
 47   st-&gt;print(&quot;)&quot;);
 48 }
 49 
 50 
 51 // Print a human readable size.
 52 // byte_size: size, in bytes, to be printed.
 53 // scale: one of 1 (byte-wise printing), sizeof(word) (word-size printing), K, M, G (scaled by KB, MB, GB respectively,
 54 //         or 0, which means the best scale is choosen dynamically.
 55 // width: printing width.
 56 void print_human_readable_size(outputStream* st, size_t byte_size, size_t scale, int width)  {
 57   if (scale == 0) {
 58     // Dynamic mode. Choose scale for this value.
 59     if (byte_size == 0) {
 60       // Zero values are printed as bytes.
 61       scale = 1;
 62     } else {
 63       if (byte_size &gt;= G) {
 64         scale = G;
 65       } else if (byte_size &gt;= M) {
 66         scale = M;
 67       } else if (byte_size &gt;= K) {
 68         scale = K;
 69       } else {
 70         scale = 1;
 71       }
 72     }
 73     return print_human_readable_size(st, byte_size, scale, width);
 74   }
 75 
 76 #ifdef ASSERT
 77   assert(scale == 1 || scale == BytesPerWord || scale == K || scale == M || scale == G, &quot;Invalid scale&quot;);
 78   // Special case: printing wordsize should only be done with word-sized values
 79   if (scale == BytesPerWord) {
 80     assert(byte_size % BytesPerWord == 0, &quot;not word sized&quot;);
 81   }
 82 #endif
 83 
 84   if (scale == 1) {
 85     st-&gt;print(&quot;%*&quot; PRIuPTR &quot; bytes&quot;, width, byte_size);
 86   } else if (scale == BytesPerWord) {
 87     st-&gt;print(&quot;%*&quot; PRIuPTR &quot; words&quot;, width, byte_size / BytesPerWord);
 88   } else {
 89     const char* display_unit = &quot;&quot;;
 90     switch(scale) {
 91       case 1: display_unit = &quot;bytes&quot;; break;
 92       case BytesPerWord: display_unit = &quot;words&quot;; break;
 93       case K: display_unit = &quot;KB&quot;; break;
 94       case M: display_unit = &quot;MB&quot;; break;
 95       case G: display_unit = &quot;GB&quot;; break;
 96       default:
 97         ShouldNotReachHere();
 98     }
 99     float display_value = (float) byte_size / scale;
100     // Since we use width to display a number with two trailing digits, increase it a bit.
101     width += 3;
102     // Prevent very small but non-null values showing up as 0.00.
103     if (byte_size &gt; 0 &amp;&amp; display_value &lt; 0.01f) {
104       st-&gt;print(&quot;%*s %s&quot;, width, &quot;&lt;0.01&quot;, display_unit);
105     } else {
106       st-&gt;print(&quot;%*.2f %s&quot;, width, display_value, display_unit);
107     }
108   }
109 }
110 
111 // Prints a percentage value. Values smaller than 1% but not 0 are displayed as &quot;&lt;1%&quot;, values
112 // larger than 99% but not 100% are displayed as &quot;&gt;100%&quot;.
113 void print_percentage(outputStream* st, size_t total, size_t part) {
114   if (total == 0) {
115     st-&gt;print(&quot;  ?%%&quot;);
116   } else if (part == 0) {
117     st-&gt;print(&quot;  0%%&quot;);
118   } else if (part == total) {
119     st-&gt;print(&quot;100%%&quot;);
120   } else {
121     // Note: clearly print very-small-but-not-0% and very-large-but-not-100% percentages.
122     float p = ((float)part / total) * 100.0f;
123     if (p &lt; 1.0f) {
124       st-&gt;print(&quot; &lt;1%%&quot;);
125     } else if (p &gt; 99.0f){
126       st-&gt;print(&quot;&gt;99%%&quot;);
127     } else {
128       st-&gt;print(&quot;%3.0f%%&quot;, p);
129     }
130   }
131 }
132 
133 // Returns size of this chunk type.
134 size_t get_size_for_nonhumongous_chunktype(ChunkIndex chunktype, bool is_class) {
135   assert(is_valid_nonhumongous_chunktype(chunktype), &quot;invalid chunk type.&quot;);
136   size_t size = 0;
137   if (is_class) {
138     switch(chunktype) {
139       case SpecializedIndex: size = ClassSpecializedChunk; break;
140       case SmallIndex: size = ClassSmallChunk; break;
141       case MediumIndex: size = ClassMediumChunk; break;
142       default:
143         ShouldNotReachHere();
144     }
145   } else {
146     switch(chunktype) {
147       case SpecializedIndex: size = SpecializedChunk; break;
148       case SmallIndex: size = SmallChunk; break;
149       case MediumIndex: size = MediumChunk; break;
150       default:
151         ShouldNotReachHere();
152     }
153   }
154   return size;
155 }
156 
157 ChunkIndex get_chunk_type_by_size(size_t size, bool is_class) {
158   if (is_class) {
159     if (size == ClassSpecializedChunk) {
160       return SpecializedIndex;
161     } else if (size == ClassSmallChunk) {
162       return SmallIndex;
163     } else if (size == ClassMediumChunk) {
164       return MediumIndex;
165     } else if (size &gt; ClassMediumChunk) {
166       // A valid humongous chunk size is a multiple of the smallest chunk size.
167       assert(is_aligned(size, ClassSpecializedChunk), &quot;Invalid chunk size&quot;);
168       return HumongousIndex;
169     }
170   } else {
171     if (size == SpecializedChunk) {
172       return SpecializedIndex;
173     } else if (size == SmallChunk) {
174       return SmallIndex;
175     } else if (size == MediumChunk) {
176       return MediumIndex;
177     } else if (size &gt; MediumChunk) {
178       // A valid humongous chunk size is a multiple of the smallest chunk size.
179       assert(is_aligned(size, SpecializedChunk), &quot;Invalid chunk size&quot;);
180       return HumongousIndex;
181     }
182   }
183   ShouldNotReachHere();
184   return (ChunkIndex)-1;
185 }
186 
187 ChunkIndex next_chunk_index(ChunkIndex i) {
188   assert(i &lt; NumberOfInUseLists, &quot;Out of bound&quot;);
189   return (ChunkIndex) (i+1);
190 }
191 
192 ChunkIndex prev_chunk_index(ChunkIndex i) {
193   assert(i &gt; ZeroIndex, &quot;Out of bound&quot;);
194   return (ChunkIndex) (i-1);
195 }
196 
<a name="1" id="anc1"></a><span class="line-added">197 const char* loaders_plural(uintx num) {</span>
<span class="line-added">198   return num == 1 ? &quot;loader&quot; : &quot;loaders&quot;;</span>
<span class="line-added">199 }</span>
<span class="line-added">200 </span>
<span class="line-added">201 const char* classes_plural(uintx num) {</span>
<span class="line-added">202   return num == 1 ? &quot;class&quot; : &quot;classes&quot;;</span>
<span class="line-added">203 }</span>
<span class="line-added">204 </span>
<span class="line-added">205 void print_number_of_classes(outputStream* out, uintx classes, uintx classes_shared) {</span>
<span class="line-added">206   out-&gt;print(UINTX_FORMAT &quot; %s&quot;, classes, classes_plural(classes));</span>
<span class="line-added">207   if (classes_shared &gt; 0) {</span>
<span class="line-added">208     out-&gt;print(&quot; (&quot; UINTX_FORMAT &quot; shared)&quot;, classes_shared);</span>
<span class="line-added">209   }</span>
<span class="line-added">210 }</span>
211 
212 } // namespace metaspace
213 
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
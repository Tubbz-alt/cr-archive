<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/metaspace/virtualSpaceList.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="virtualSpaceList.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="virtualSpaceNode.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/metaspace/virtualSpaceList.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 41 
 42   enum VirtualSpaceSizes {
 43     VirtualSpaceSize = 256 * K
 44   };
 45 
 46   // Head of the list
 47   VirtualSpaceNode* _virtual_space_list;
 48   // virtual space currently being used for allocations
 49   VirtualSpaceNode* _current_virtual_space;
 50 
 51   // Is this VirtualSpaceList used for the compressed class space
 52   bool _is_class;
 53 
 54   // Sum of reserved and committed memory in the virtual spaces
 55   size_t _reserved_words;
 56   size_t _committed_words;
 57 
 58   // Number of virtual spaces
 59   size_t _virtual_space_count;
 60 













 61   ~VirtualSpaceList();
 62 
 63   VirtualSpaceNode* virtual_space_list() const { return _virtual_space_list; }
 64 
 65   void set_virtual_space_list(VirtualSpaceNode* v) {
 66     _virtual_space_list = v;
 67   }
 68   void set_current_virtual_space(VirtualSpaceNode* v) {
 69     _current_virtual_space = v;
 70   }
 71 
 72   void link_vs(VirtualSpaceNode* new_entry);
 73 
 74   // Get another virtual space and add it to the list.  This
 75   // is typically prompted by a failed attempt to allocate a chunk
 76   // and is typically followed by the allocation of a chunk.
 77   bool create_new_virtual_space(size_t vs_word_size);
 78 
 79   // Chunk up the unused committed space in the current
 80   // virtual space and add the chunks to the free list.
 81   void retire_current_virtual_space();
 82 


 83  public:
 84   VirtualSpaceList(size_t word_size);
 85   VirtualSpaceList(ReservedSpace rs);
 86 
 87   size_t free_bytes();
 88 
 89   Metachunk* get_new_chunk(size_t chunk_word_size,
 90                            size_t suggested_commit_granularity);
 91 
 92   bool expand_node_by(VirtualSpaceNode* node,
 93                       size_t min_words,
 94                       size_t preferred_words);
 95 
 96   bool expand_by(size_t min_words,
 97                  size_t preferred_words);
 98 
 99   VirtualSpaceNode* current_virtual_space() {
100     return _current_virtual_space;
101   }
102 
</pre>
<hr />
<pre>
109   size_t committed_words() { return _committed_words; }
110   size_t committed_bytes() { return committed_words() * BytesPerWord; }
111 
112   void inc_reserved_words(size_t v);
113   void dec_reserved_words(size_t v);
114   void inc_committed_words(size_t v);
115   void dec_committed_words(size_t v);
116   void inc_virtual_space_count();
117   void dec_virtual_space_count();
118 
119   VirtualSpaceNode* find_enclosing_space(const void* ptr);
120   bool contains(const void* ptr) { return find_enclosing_space(ptr) != NULL; }
121 
122   // Unlink empty VirtualSpaceNodes and free it.
123   void purge(ChunkManager* chunk_manager);
124 
125   void print_on(outputStream* st) const                 { print_on(st, K); }
126   void print_on(outputStream* st, size_t scale) const;
127   void print_map(outputStream* st) const;
128 


129   class VirtualSpaceListIterator : public StackObj {
130     VirtualSpaceNode* _virtual_spaces;
131    public:
132     VirtualSpaceListIterator(VirtualSpaceNode* virtual_spaces) :
133       _virtual_spaces(virtual_spaces) {}
134 
135     bool repeat() {
136       return _virtual_spaces != NULL;
137     }
138 
139     VirtualSpaceNode* get_next() {
140       VirtualSpaceNode* result = _virtual_spaces;
141       if (_virtual_spaces != NULL) {
142         _virtual_spaces = _virtual_spaces-&gt;next();
143       }
144       return result;
145     }
146   };
147 };
148 
</pre>
</td>
<td>
<hr />
<pre>
 41 
 42   enum VirtualSpaceSizes {
 43     VirtualSpaceSize = 256 * K
 44   };
 45 
 46   // Head of the list
 47   VirtualSpaceNode* _virtual_space_list;
 48   // virtual space currently being used for allocations
 49   VirtualSpaceNode* _current_virtual_space;
 50 
 51   // Is this VirtualSpaceList used for the compressed class space
 52   bool _is_class;
 53 
 54   // Sum of reserved and committed memory in the virtual spaces
 55   size_t _reserved_words;
 56   size_t _committed_words;
 57 
 58   // Number of virtual spaces
 59   size_t _virtual_space_count;
 60 
<span class="line-added"> 61   // Optimization: we keep an address range to quickly exclude pointers</span>
<span class="line-added"> 62   // which are clearly not pointing into metaspace. This is an optimization for</span>
<span class="line-added"> 63   // VirtualSpaceList::contains().</span>
<span class="line-added"> 64   address _envelope_lo;</span>
<span class="line-added"> 65   address _envelope_hi;</span>
<span class="line-added"> 66 </span>
<span class="line-added"> 67   bool is_within_envelope(address p) const {</span>
<span class="line-added"> 68     return p &gt;= _envelope_lo &amp;&amp; p &lt; _envelope_hi;</span>
<span class="line-added"> 69   }</span>
<span class="line-added"> 70 </span>
<span class="line-added"> 71   // Given a node, expand range such that it includes the node.</span>
<span class="line-added"> 72   void expand_envelope_to_include_node(const VirtualSpaceNode* node);</span>
<span class="line-added"> 73 </span>
 74   ~VirtualSpaceList();
 75 
 76   VirtualSpaceNode* virtual_space_list() const { return _virtual_space_list; }
 77 
 78   void set_virtual_space_list(VirtualSpaceNode* v) {
 79     _virtual_space_list = v;
 80   }
 81   void set_current_virtual_space(VirtualSpaceNode* v) {
 82     _current_virtual_space = v;
 83   }
 84 
 85   void link_vs(VirtualSpaceNode* new_entry);
 86 
 87   // Get another virtual space and add it to the list.  This
 88   // is typically prompted by a failed attempt to allocate a chunk
 89   // and is typically followed by the allocation of a chunk.
 90   bool create_new_virtual_space(size_t vs_word_size);
 91 
 92   // Chunk up the unused committed space in the current
 93   // virtual space and add the chunks to the free list.
 94   void retire_current_virtual_space();
 95 
<span class="line-added"> 96   DEBUG_ONLY(bool contains_node(const VirtualSpaceNode* node) const;)</span>
<span class="line-added"> 97 </span>
 98  public:
 99   VirtualSpaceList(size_t word_size);
100   VirtualSpaceList(ReservedSpace rs);
101 
102   size_t free_bytes();
103 
104   Metachunk* get_new_chunk(size_t chunk_word_size,
105                            size_t suggested_commit_granularity);
106 
107   bool expand_node_by(VirtualSpaceNode* node,
108                       size_t min_words,
109                       size_t preferred_words);
110 
111   bool expand_by(size_t min_words,
112                  size_t preferred_words);
113 
114   VirtualSpaceNode* current_virtual_space() {
115     return _current_virtual_space;
116   }
117 
</pre>
<hr />
<pre>
124   size_t committed_words() { return _committed_words; }
125   size_t committed_bytes() { return committed_words() * BytesPerWord; }
126 
127   void inc_reserved_words(size_t v);
128   void dec_reserved_words(size_t v);
129   void inc_committed_words(size_t v);
130   void dec_committed_words(size_t v);
131   void inc_virtual_space_count();
132   void dec_virtual_space_count();
133 
134   VirtualSpaceNode* find_enclosing_space(const void* ptr);
135   bool contains(const void* ptr) { return find_enclosing_space(ptr) != NULL; }
136 
137   // Unlink empty VirtualSpaceNodes and free it.
138   void purge(ChunkManager* chunk_manager);
139 
140   void print_on(outputStream* st) const                 { print_on(st, K); }
141   void print_on(outputStream* st, size_t scale) const;
142   void print_map(outputStream* st) const;
143 
<span class="line-added">144   DEBUG_ONLY(void verify(bool slow);)</span>
<span class="line-added">145 </span>
146   class VirtualSpaceListIterator : public StackObj {
147     VirtualSpaceNode* _virtual_spaces;
148    public:
149     VirtualSpaceListIterator(VirtualSpaceNode* virtual_spaces) :
150       _virtual_spaces(virtual_spaces) {}
151 
152     bool repeat() {
153       return _virtual_spaces != NULL;
154     }
155 
156     VirtualSpaceNode* get_next() {
157       VirtualSpaceNode* result = _virtual_spaces;
158       if (_virtual_spaces != NULL) {
159         _virtual_spaces = _virtual_spaces-&gt;next();
160       }
161       return result;
162     }
163   };
164 };
165 
</pre>
</td>
</tr>
</table>
<center><a href="virtualSpaceList.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="virtualSpaceNode.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
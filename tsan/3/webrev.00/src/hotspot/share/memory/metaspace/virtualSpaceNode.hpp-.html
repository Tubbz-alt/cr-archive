<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/memory/metaspace/virtualSpaceNode.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_MEMORY_METASPACE_VIRTUALSPACENODE_HPP
 26 #define SHARE_MEMORY_METASPACE_VIRTUALSPACENODE_HPP
 27 
 28 #include &quot;memory/virtualspace.hpp&quot;
 29 #include &quot;memory/memRegion.hpp&quot;
 30 #include &quot;utilities/debug.hpp&quot;
 31 #include &quot;utilities/globalDefinitions.hpp&quot;
 32 
 33 class outputStream;
 34 
 35 namespace metaspace {
 36 
 37 class Metachunk;
 38 class ChunkManager;
 39 class OccupancyMap;
 40 
 41 // A VirtualSpaceList node.
 42 class VirtualSpaceNode : public CHeapObj&lt;mtClass&gt; {
 43   friend class VirtualSpaceList;
 44 
 45   // Link to next VirtualSpaceNode
 46   VirtualSpaceNode* _next;
 47 
 48   // Whether this node is contained in class or metaspace.
 49   const bool _is_class;
 50 
 51   // total in the VirtualSpace
 52   ReservedSpace _rs;
 53   VirtualSpace _virtual_space;
 54   MetaWord* _top;
 55   // count of chunks contained in this VirtualSpace
 56   uintx _container_count;
 57 
 58   OccupancyMap* _occupancy_map;
 59 
 60   // Convenience functions to access the _virtual_space
 61   char* low()  const { return virtual_space()-&gt;low(); }
 62   char* high() const { return virtual_space()-&gt;high(); }
 63 
 64   // The first Metachunk will be allocated at the bottom of the
 65   // VirtualSpace
 66   Metachunk* first_chunk() { return (Metachunk*) bottom(); }
 67 
 68   // Committed but unused space in the virtual space
 69   size_t free_words_in_vs() const;
 70 
 71   // True if this node belongs to class metaspace.
 72   bool is_class() const { return _is_class; }
 73 
 74   // Helper function for take_from_committed: allocate padding chunks
 75   // until top is at the given address.
 76   void allocate_padding_chunks_until_top_is_at(MetaWord* target_top);
 77 
 78  public:
 79 
 80   VirtualSpaceNode(bool is_class, size_t byte_size);
 81   VirtualSpaceNode(bool is_class, ReservedSpace rs) :
 82     _next(NULL), _is_class(is_class), _rs(rs), _top(NULL), _container_count(0), _occupancy_map(NULL) {}
 83   ~VirtualSpaceNode();
 84 
 85   // Convenience functions for logical bottom and end
 86   MetaWord* bottom() const { return (MetaWord*) _virtual_space.low(); }
 87   MetaWord* end() const { return (MetaWord*) _virtual_space.high(); }
 88 
 89   const OccupancyMap* occupancy_map() const { return _occupancy_map; }
 90   OccupancyMap* occupancy_map() { return _occupancy_map; }
 91 
 92   bool contains(const void* ptr) { return ptr &gt;= low() &amp;&amp; ptr &lt; high(); }
 93 
 94   size_t reserved_words() const  { return _virtual_space.reserved_size() / BytesPerWord; }
 95   size_t committed_words() const { return _virtual_space.actual_committed_size() / BytesPerWord; }
 96 
 97   bool is_pre_committed() const { return _virtual_space.special(); }
 98 
 99   // address of next available space in _virtual_space;
100   // Accessors
101   VirtualSpaceNode* next() { return _next; }
102   void set_next(VirtualSpaceNode* v) { _next = v; }
103 
104   void set_top(MetaWord* v) { _top = v; }
105 
106   // Accessors
107   VirtualSpace* virtual_space() const { return (VirtualSpace*) &amp;_virtual_space; }
108 
109   // Returns true if &quot;word_size&quot; is available in the VirtualSpace
110   bool is_available(size_t word_size) { return word_size &lt;= pointer_delta(end(), _top, sizeof(MetaWord)); }
111 
112   MetaWord* top() const { return _top; }
113   void inc_top(size_t word_size) { _top += word_size; }
114 
115   uintx container_count() { return _container_count; }
116   void inc_container_count();
117   void dec_container_count();
118 
119   // used and capacity in this single entry in the list
120   size_t used_words_in_vs() const;
121   size_t capacity_words_in_vs() const;
122 
123   bool initialize();
124 
125   // get space from the virtual space
126   Metachunk* take_from_committed(size_t chunk_word_size);
127 
128   // Allocate a chunk from the virtual space and return it.
129   Metachunk* get_chunk_vs(size_t chunk_word_size);
130 
131   // Expands the committed space by at least min_words words.
132   bool expand_by(size_t min_words, size_t preferred_words);
133 
134   // In preparation for deleting this node, remove all the chunks
135   // in the node from any freelist.
136   void purge(ChunkManager* chunk_manager);
137 
138   // If an allocation doesn&#39;t fit in the current node a new node is created.
139   // Allocate chunks out of the remaining committed space in this node
140   // to avoid wasting that memory.
141   // This always adds up because all the chunk sizes are multiples of
142   // the smallest chunk size.
143   void retire(ChunkManager* chunk_manager);
144 
145   void print_on(outputStream* st) const                 { print_on(st, K); }
146   void print_on(outputStream* st, size_t scale) const;
147   void print_map(outputStream* st, bool is_class) const;
148 
149   // Debug support
150   DEBUG_ONLY(void mangle();)
151   // Verify counters and basic structure. Slow mode: verify all chunks in depth and occupancy map.
152   DEBUG_ONLY(void verify(bool slow);)
153   // Verify that all free chunks in this node are ideally merged
154   // (there should not be multiple small chunks where a large chunk could exist.)
155   DEBUG_ONLY(void verify_free_chunks_are_ideally_merged();)
156 
157 };
158 
159 } // namespace metaspace
160 
161 #endif // SHARE_MEMORY_METASPACE_VIRTUALSPACENODE_HPP
    </pre>
  </body>
</html>
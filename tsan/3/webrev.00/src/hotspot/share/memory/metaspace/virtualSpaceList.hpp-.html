<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/memory/metaspace/virtualSpaceList.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_MEMORY_METASPACE_VIRTUALSPACELIST_HPP
 26 #define SHARE_MEMORY_METASPACE_VIRTUALSPACELIST_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;memory/metaspace/virtualSpaceNode.hpp&quot;
 30 #include &quot;utilities/globalDefinitions.hpp&quot;
 31 
 32 
 33 namespace metaspace {
 34 
 35 class Metachunk;
 36 class ChunkManager;
 37 
 38 // List of VirtualSpaces for metadata allocation.
 39 class VirtualSpaceList : public CHeapObj&lt;mtClass&gt; {
 40   friend class VirtualSpaceNode;
 41 
 42   enum VirtualSpaceSizes {
 43     VirtualSpaceSize = 256 * K
 44   };
 45 
 46   // Head of the list
 47   VirtualSpaceNode* _virtual_space_list;
 48   // virtual space currently being used for allocations
 49   VirtualSpaceNode* _current_virtual_space;
 50 
 51   // Is this VirtualSpaceList used for the compressed class space
 52   bool _is_class;
 53 
 54   // Sum of reserved and committed memory in the virtual spaces
 55   size_t _reserved_words;
 56   size_t _committed_words;
 57 
 58   // Number of virtual spaces
 59   size_t _virtual_space_count;
 60 
 61   ~VirtualSpaceList();
 62 
 63   VirtualSpaceNode* virtual_space_list() const { return _virtual_space_list; }
 64 
 65   void set_virtual_space_list(VirtualSpaceNode* v) {
 66     _virtual_space_list = v;
 67   }
 68   void set_current_virtual_space(VirtualSpaceNode* v) {
 69     _current_virtual_space = v;
 70   }
 71 
 72   void link_vs(VirtualSpaceNode* new_entry);
 73 
 74   // Get another virtual space and add it to the list.  This
 75   // is typically prompted by a failed attempt to allocate a chunk
 76   // and is typically followed by the allocation of a chunk.
 77   bool create_new_virtual_space(size_t vs_word_size);
 78 
 79   // Chunk up the unused committed space in the current
 80   // virtual space and add the chunks to the free list.
 81   void retire_current_virtual_space();
 82 
 83  public:
 84   VirtualSpaceList(size_t word_size);
 85   VirtualSpaceList(ReservedSpace rs);
 86 
 87   size_t free_bytes();
 88 
 89   Metachunk* get_new_chunk(size_t chunk_word_size,
 90                            size_t suggested_commit_granularity);
 91 
 92   bool expand_node_by(VirtualSpaceNode* node,
 93                       size_t min_words,
 94                       size_t preferred_words);
 95 
 96   bool expand_by(size_t min_words,
 97                  size_t preferred_words);
 98 
 99   VirtualSpaceNode* current_virtual_space() {
100     return _current_virtual_space;
101   }
102 
103   bool is_class() const { return _is_class; }
104 
105   bool initialization_succeeded() { return _virtual_space_list != NULL; }
106 
107   size_t reserved_words()  { return _reserved_words; }
108   size_t reserved_bytes()  { return reserved_words() * BytesPerWord; }
109   size_t committed_words() { return _committed_words; }
110   size_t committed_bytes() { return committed_words() * BytesPerWord; }
111 
112   void inc_reserved_words(size_t v);
113   void dec_reserved_words(size_t v);
114   void inc_committed_words(size_t v);
115   void dec_committed_words(size_t v);
116   void inc_virtual_space_count();
117   void dec_virtual_space_count();
118 
119   VirtualSpaceNode* find_enclosing_space(const void* ptr);
120   bool contains(const void* ptr) { return find_enclosing_space(ptr) != NULL; }
121 
122   // Unlink empty VirtualSpaceNodes and free it.
123   void purge(ChunkManager* chunk_manager);
124 
125   void print_on(outputStream* st) const                 { print_on(st, K); }
126   void print_on(outputStream* st, size_t scale) const;
127   void print_map(outputStream* st) const;
128 
129   class VirtualSpaceListIterator : public StackObj {
130     VirtualSpaceNode* _virtual_spaces;
131    public:
132     VirtualSpaceListIterator(VirtualSpaceNode* virtual_spaces) :
133       _virtual_spaces(virtual_spaces) {}
134 
135     bool repeat() {
136       return _virtual_spaces != NULL;
137     }
138 
139     VirtualSpaceNode* get_next() {
140       VirtualSpaceNode* result = _virtual_spaces;
141       if (_virtual_spaces != NULL) {
142         _virtual_spaces = _virtual_spaces-&gt;next();
143       }
144       return result;
145     }
146   };
147 };
148 
149 } // namespace metaspace
150 
151 #endif // SHARE_MEMORY_METASPACE_VIRTUALSPACELIST_HPP
    </pre>
  </body>
</html>
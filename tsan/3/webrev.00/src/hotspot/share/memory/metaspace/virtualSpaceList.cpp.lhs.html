<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/memory/metaspace/virtualSpaceList.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;logging/log.hpp&quot;
 28 #include &quot;logging/logStream.hpp&quot;
 29 #include &quot;memory/metaspace.hpp&quot;
 30 #include &quot;memory/metaspace/chunkManager.hpp&quot;
 31 #include &quot;memory/metaspace/metachunk.hpp&quot;
 32 #include &quot;memory/metaspace/metaspaceCommon.hpp&quot;
 33 #include &quot;memory/metaspace/virtualSpaceList.hpp&quot;
 34 #include &quot;memory/metaspace/virtualSpaceNode.hpp&quot;
<a name="2" id="anc2"></a>
 35 #include &quot;runtime/orderAccess.hpp&quot;
 36 #include &quot;runtime/mutexLocker.hpp&quot;
 37 #include &quot;runtime/safepoint.hpp&quot;
 38 
 39 namespace metaspace {
 40 
 41 
 42 VirtualSpaceList::~VirtualSpaceList() {
 43   VirtualSpaceListIterator iter(virtual_space_list());
 44   while (iter.repeat()) {
 45     VirtualSpaceNode* vsl = iter.get_next();
 46     delete vsl;
 47   }
 48 }
 49 
 50 void VirtualSpaceList::inc_reserved_words(size_t v) {
 51   assert_lock_strong(MetaspaceExpand_lock);
 52   _reserved_words = _reserved_words + v;
 53 }
 54 void VirtualSpaceList::dec_reserved_words(size_t v) {
 55   assert_lock_strong(MetaspaceExpand_lock);
 56   _reserved_words = _reserved_words - v;
 57 }
 58 
 59 #define assert_committed_below_limit()                        \
 60   assert(MetaspaceUtils::committed_bytes() &lt;= MaxMetaspaceSize, \
 61          &quot;Too much committed memory. Committed: &quot; SIZE_FORMAT \
 62          &quot; limit (MaxMetaspaceSize): &quot; SIZE_FORMAT,           \
 63           MetaspaceUtils::committed_bytes(), MaxMetaspaceSize);
 64 
 65 void VirtualSpaceList::inc_committed_words(size_t v) {
 66   assert_lock_strong(MetaspaceExpand_lock);
 67   _committed_words = _committed_words + v;
 68 
 69   assert_committed_below_limit();
 70 }
 71 void VirtualSpaceList::dec_committed_words(size_t v) {
 72   assert_lock_strong(MetaspaceExpand_lock);
 73   _committed_words = _committed_words - v;
 74 
 75   assert_committed_below_limit();
 76 }
 77 
 78 void VirtualSpaceList::inc_virtual_space_count() {
 79   assert_lock_strong(MetaspaceExpand_lock);
 80   _virtual_space_count++;
 81 }
 82 
 83 void VirtualSpaceList::dec_virtual_space_count() {
 84   assert_lock_strong(MetaspaceExpand_lock);
 85   _virtual_space_count--;
 86 }
 87 
 88 // Walk the list of VirtualSpaceNodes and delete
 89 // nodes with a 0 container_count.  Remove Metachunks in
 90 // the node from their respective freelists.
 91 void VirtualSpaceList::purge(ChunkManager* chunk_manager) {
 92   assert_lock_strong(MetaspaceExpand_lock);
 93   // Don&#39;t use a VirtualSpaceListIterator because this
 94   // list is being changed and a straightforward use of an iterator is not safe.
<a name="3" id="anc3"></a><span class="line-removed"> 95   VirtualSpaceNode* purged_vsl = NULL;</span>
 96   VirtualSpaceNode* prev_vsl = virtual_space_list();
 97   VirtualSpaceNode* next_vsl = prev_vsl;
<a name="4" id="anc4"></a>
 98   while (next_vsl != NULL) {
 99     VirtualSpaceNode* vsl = next_vsl;
100     DEBUG_ONLY(vsl-&gt;verify(false);)
101     next_vsl = vsl-&gt;next();
102     // Don&#39;t free the current virtual space since it will likely
103     // be needed soon.
104     if (vsl-&gt;container_count() == 0 &amp;&amp; vsl != current_virtual_space()) {
105       log_trace(gc, metaspace, freelist)(&quot;Purging VirtualSpaceNode &quot; PTR_FORMAT &quot; (capacity: &quot; SIZE_FORMAT
106                                          &quot;, used: &quot; SIZE_FORMAT &quot;).&quot;, p2i(vsl), vsl-&gt;capacity_words_in_vs(), vsl-&gt;used_words_in_vs());
107       DEBUG_ONLY(Atomic::inc(&amp;g_internal_statistics.num_vsnodes_purged));
108       // Unlink it from the list
109       if (prev_vsl == vsl) {
110         // This is the case of the current node being the first node.
111         assert(vsl == virtual_space_list(), &quot;Expected to be the first node&quot;);
112         set_virtual_space_list(vsl-&gt;next());
113       } else {
114         prev_vsl-&gt;set_next(vsl-&gt;next());
115       }
116 
117       vsl-&gt;purge(chunk_manager);
118       dec_reserved_words(vsl-&gt;reserved_words());
119       dec_committed_words(vsl-&gt;committed_words());
120       dec_virtual_space_count();
<a name="5" id="anc5"></a><span class="line-removed">121       purged_vsl = vsl;</span>
122       delete vsl;
<a name="6" id="anc6"></a>
123     } else {
124       prev_vsl = vsl;
125     }
126   }
<a name="7" id="anc7"></a>

127 #ifdef ASSERT
<a name="8" id="anc8"></a><span class="line-modified">128   if (purged_vsl != NULL) {</span>
<span class="line-modified">129     // List should be stable enough to use an iterator here.</span>
<span class="line-removed">130     VirtualSpaceListIterator iter(virtual_space_list());</span>
<span class="line-removed">131     while (iter.repeat()) {</span>
<span class="line-removed">132       VirtualSpaceNode* vsl = iter.get_next();</span>
<span class="line-removed">133       assert(vsl != purged_vsl, &quot;Purge of vsl failed&quot;);</span>
<span class="line-removed">134     }</span>
135   }
136 #endif
137 }
138 
139 
140 // This function looks at the mmap regions in the metaspace without locking.
141 // The chunks are added with store ordering and not deleted except for at
142 // unloading time during a safepoint.
143 VirtualSpaceNode* VirtualSpaceList::find_enclosing_space(const void* ptr) {
144   // List should be stable enough to use an iterator here because removing virtual
145   // space nodes is only allowed at a safepoint.
<a name="9" id="anc9"></a><span class="line-modified">146   VirtualSpaceListIterator iter(virtual_space_list());</span>
<span class="line-modified">147   while (iter.repeat()) {</span>
<span class="line-modified">148     VirtualSpaceNode* vsn = iter.get_next();</span>
<span class="line-modified">149     if (vsn-&gt;contains(ptr)) {</span>
<span class="line-modified">150       return vsn;</span>


151     }
152   }
153   return NULL;
154 }
155 
156 void VirtualSpaceList::retire_current_virtual_space() {
157   assert_lock_strong(MetaspaceExpand_lock);
158 
159   VirtualSpaceNode* vsn = current_virtual_space();
160 
161   ChunkManager* cm = is_class() ? Metaspace::chunk_manager_class() :
162                                   Metaspace::chunk_manager_metadata();
163 
164   vsn-&gt;retire(cm);
165 }
166 
167 VirtualSpaceList::VirtualSpaceList(size_t word_size) :
168                                    _virtual_space_list(NULL),
169                                    _current_virtual_space(NULL),
170                                    _is_class(false),
171                                    _reserved_words(0),
172                                    _committed_words(0),
<a name="10" id="anc10"></a><span class="line-modified">173                                    _virtual_space_count(0) {</span>
<span class="line-modified">174   MutexLockerEx cl(MetaspaceExpand_lock,</span>
<span class="line-modified">175                    Mutex::_no_safepoint_check_flag);</span>

176   create_new_virtual_space(word_size);
177 }
178 
179 VirtualSpaceList::VirtualSpaceList(ReservedSpace rs) :
180                                    _virtual_space_list(NULL),
181                                    _current_virtual_space(NULL),
182                                    _is_class(true),
183                                    _reserved_words(0),
184                                    _committed_words(0),
<a name="11" id="anc11"></a><span class="line-modified">185                                    _virtual_space_count(0) {</span>
<span class="line-modified">186   MutexLockerEx cl(MetaspaceExpand_lock,</span>
<span class="line-modified">187                    Mutex::_no_safepoint_check_flag);</span>

188   VirtualSpaceNode* class_entry = new VirtualSpaceNode(is_class(), rs);
189   bool succeeded = class_entry-&gt;initialize();
190   if (succeeded) {
<a name="12" id="anc12"></a>


191     link_vs(class_entry);
192   }
193 }
194 
195 size_t VirtualSpaceList::free_bytes() {
196   return current_virtual_space()-&gt;free_words_in_vs() * BytesPerWord;
197 }
198 
199 // Allocate another meta virtual space and add it to the list.
200 bool VirtualSpaceList::create_new_virtual_space(size_t vs_word_size) {
201   assert_lock_strong(MetaspaceExpand_lock);
202 
203   if (is_class()) {
204     assert(false, &quot;We currently don&#39;t support more than one VirtualSpace for&quot;
205                   &quot; the compressed class space. The initialization of the&quot;
206                   &quot; CCS uses another code path and should not hit this path.&quot;);
207     return false;
208   }
209 
210   if (vs_word_size == 0) {
211     assert(false, &quot;vs_word_size should always be at least _reserve_alignment large.&quot;);
212     return false;
213   }
214 
215   // Reserve the space
216   size_t vs_byte_size = vs_word_size * BytesPerWord;
217   assert_is_aligned(vs_byte_size, Metaspace::reserve_alignment());
218 
219   // Allocate the meta virtual space and initialize it.
220   VirtualSpaceNode* new_entry = new VirtualSpaceNode(is_class(), vs_byte_size);
221   if (!new_entry-&gt;initialize()) {
222     delete new_entry;
223     return false;
224   } else {
225     assert(new_entry-&gt;reserved_words() == vs_word_size,
226         &quot;Reserved memory size differs from requested memory size&quot;);
<a name="13" id="anc13"></a>
227     // ensure lock-free iteration sees fully initialized node
228     OrderAccess::storestore();
229     link_vs(new_entry);
230     DEBUG_ONLY(Atomic::inc(&amp;g_internal_statistics.num_vsnodes_created));
231     return true;
232   }
<a name="14" id="anc14"></a>


233 }
234 
235 void VirtualSpaceList::link_vs(VirtualSpaceNode* new_entry) {
236   if (virtual_space_list() == NULL) {
237       set_virtual_space_list(new_entry);
238   } else {
239     current_virtual_space()-&gt;set_next(new_entry);
240   }
241   set_current_virtual_space(new_entry);
242   inc_reserved_words(new_entry-&gt;reserved_words());
243   inc_committed_words(new_entry-&gt;committed_words());
244   inc_virtual_space_count();
245 #ifdef ASSERT
246   new_entry-&gt;mangle();
247 #endif
248   LogTarget(Trace, gc, metaspace) lt;
249   if (lt.is_enabled()) {
250     LogStream ls(lt);
251     VirtualSpaceNode* vsl = current_virtual_space();
252     ResourceMark rm;
253     vsl-&gt;print_on(&amp;ls);
254   }
255 }
256 
257 bool VirtualSpaceList::expand_node_by(VirtualSpaceNode* node,
258                                       size_t min_words,
259                                       size_t preferred_words) {
260   size_t before = node-&gt;committed_words();
261 
262   bool result = node-&gt;expand_by(min_words, preferred_words);
263 
264   size_t after = node-&gt;committed_words();
265 
266   // after and before can be the same if the memory was pre-committed.
267   assert(after &gt;= before, &quot;Inconsistency&quot;);
268   inc_committed_words(after - before);
269 
270   return result;
271 }
272 
273 bool VirtualSpaceList::expand_by(size_t min_words, size_t preferred_words) {
274   assert_is_aligned(min_words,       Metaspace::commit_alignment_words());
275   assert_is_aligned(preferred_words, Metaspace::commit_alignment_words());
276   assert(min_words &lt;= preferred_words, &quot;Invalid arguments&quot;);
277 
278   const char* const class_or_not = (is_class() ? &quot;class&quot; : &quot;non-class&quot;);
279 
280   if (!MetaspaceGC::can_expand(min_words, this-&gt;is_class())) {
281     log_trace(gc, metaspace, freelist)(&quot;Cannot expand %s virtual space list.&quot;,
282               class_or_not);
283     return  false;
284   }
285 
286   size_t allowed_expansion_words = MetaspaceGC::allowed_expansion();
287   if (allowed_expansion_words &lt; min_words) {
288     log_trace(gc, metaspace, freelist)(&quot;Cannot expand %s virtual space list (must try gc first).&quot;,
289               class_or_not);
290     return false;
291   }
292 
293   size_t max_expansion_words = MIN2(preferred_words, allowed_expansion_words);
294 
295   // Commit more memory from the the current virtual space.
296   bool vs_expanded = expand_node_by(current_virtual_space(),
297                                     min_words,
298                                     max_expansion_words);
299   if (vs_expanded) {
300      log_trace(gc, metaspace, freelist)(&quot;Expanded %s virtual space list.&quot;,
301                class_or_not);
302      return true;
303   }
304   log_trace(gc, metaspace, freelist)(&quot;%s virtual space list: retire current node.&quot;,
305             class_or_not);
306   retire_current_virtual_space();
307 
308   // Get another virtual space.
309   size_t grow_vs_words = MAX2((size_t)VirtualSpaceSize, preferred_words);
310   grow_vs_words = align_up(grow_vs_words, Metaspace::reserve_alignment_words());
311 
312   if (create_new_virtual_space(grow_vs_words)) {
313     if (current_virtual_space()-&gt;is_pre_committed()) {
314       // The memory was pre-committed, so we are done here.
315       assert(min_words &lt;= current_virtual_space()-&gt;committed_words(),
316           &quot;The new VirtualSpace was pre-committed, so it&quot;
317           &quot;should be large enough to fit the alloc request.&quot;);
318       return true;
319     }
320 
321     return expand_node_by(current_virtual_space(),
322                           min_words,
323                           max_expansion_words);
324   }
325 
326   return false;
327 }
328 
329 // Given a chunk, calculate the largest possible padding space which
330 // could be required when allocating it.
331 static size_t largest_possible_padding_size_for_chunk(size_t chunk_word_size, bool is_class) {
332   const ChunkIndex chunk_type = get_chunk_type_by_size(chunk_word_size, is_class);
333   if (chunk_type != HumongousIndex) {
334     // Normal, non-humongous chunks are allocated at chunk size
335     // boundaries, so the largest padding space required would be that
336     // minus the smallest chunk size.
337     const size_t smallest_chunk_size = is_class ? ClassSpecializedChunk : SpecializedChunk;
338     return chunk_word_size - smallest_chunk_size;
339   } else {
340     // Humongous chunks are allocated at smallest-chunksize
341     // boundaries, so there is no padding required.
342     return 0;
343   }
344 }
345 
346 
347 Metachunk* VirtualSpaceList::get_new_chunk(size_t chunk_word_size, size_t suggested_commit_granularity) {
348 
349   // Allocate a chunk out of the current virtual space.
350   Metachunk* next = current_virtual_space()-&gt;get_chunk_vs(chunk_word_size);
351 
352   if (next != NULL) {
353     return next;
354   }
355 
356   // The expand amount is currently only determined by the requested sizes
357   // and not how much committed memory is left in the current virtual space.
358 
359   // We must have enough space for the requested size and any
360   // additional reqired padding chunks.
361   const size_t size_for_padding = largest_possible_padding_size_for_chunk(chunk_word_size, this-&gt;is_class());
362 
363   size_t min_word_size       = align_up(chunk_word_size + size_for_padding, Metaspace::commit_alignment_words());
364   size_t preferred_word_size = align_up(suggested_commit_granularity, Metaspace::commit_alignment_words());
365   if (min_word_size &gt;= preferred_word_size) {
366     // Can happen when humongous chunks are allocated.
367     preferred_word_size = min_word_size;
368   }
369 
370   bool expanded = expand_by(min_word_size, preferred_word_size);
371   if (expanded) {
372     next = current_virtual_space()-&gt;get_chunk_vs(chunk_word_size);
373     assert(next != NULL, &quot;The allocation was expected to succeed after the expansion&quot;);
374   }
375 
376    return next;
377 }
378 
379 void VirtualSpaceList::print_on(outputStream* st, size_t scale) const {
380   st-&gt;print_cr(SIZE_FORMAT &quot; nodes, current node: &quot; PTR_FORMAT,
381       _virtual_space_count, p2i(_current_virtual_space));
382   VirtualSpaceListIterator iter(virtual_space_list());
383   while (iter.repeat()) {
384     st-&gt;cr();
385     VirtualSpaceNode* node = iter.get_next();
386     node-&gt;print_on(st, scale);
387   }
388 }
389 
390 void VirtualSpaceList::print_map(outputStream* st) const {
391   VirtualSpaceNode* list = virtual_space_list();
392   VirtualSpaceListIterator iter(list);
393   unsigned i = 0;
394   while (iter.repeat()) {
395     st-&gt;print_cr(&quot;Node %u:&quot;, i);
396     VirtualSpaceNode* node = iter.get_next();
397     node-&gt;print_map(st, this-&gt;is_class());
398     i ++;
399   }
400 }
401 
<a name="15" id="anc15"></a><span class="line-modified">402 } // namespace metaspace</span>




403 
<a name="16" id="anc16"></a>






























<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
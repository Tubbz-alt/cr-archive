<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/metaspace/spaceManager.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="printMetaspaceInfoKlassClosure.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="virtualSpaceList.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/metaspace/spaceManager.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
162   }
163   return chunk_word_size;
164 }
165 
166 void SpaceManager::track_metaspace_memory_usage() {
167   if (is_init_completed()) {
168     if (is_class()) {
169       MemoryService::track_compressed_class_memory_usage();
170     }
171     MemoryService::track_metaspace_memory_usage();
172   }
173 }
174 
175 MetaWord* SpaceManager::grow_and_allocate(size_t word_size) {
176   assert_lock_strong(_lock);
177   assert(vs_list()-&gt;current_virtual_space() != NULL,
178          &quot;Should have been set&quot;);
179   assert(current_chunk() == NULL ||
180          current_chunk()-&gt;allocate(word_size) == NULL,
181          &quot;Don&#39;t need to expand&quot;);
<span class="line-modified">182   MutexLockerEx cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
183 
184   if (log_is_enabled(Trace, gc, metaspace, freelist)) {
185     size_t words_left = 0;
186     size_t words_used = 0;
187     if (current_chunk() != NULL) {
188       words_left = current_chunk()-&gt;free_word_size();
189       words_used = current_chunk()-&gt;used_word_size();
190     }
191     log_trace(gc, metaspace, freelist)(&quot;SpaceManager::grow_and_allocate for &quot; SIZE_FORMAT &quot; words &quot; SIZE_FORMAT &quot; words used &quot; SIZE_FORMAT &quot; words left&quot;,
192                                        word_size, words_used, words_left);
193   }
194 
195   // Get another chunk
196   size_t chunk_word_size = calc_chunk_size(word_size);
197   Metachunk* next = get_new_chunk(chunk_word_size);
198 
199   MetaWord* mem = NULL;
200 
201   // If a chunk was available, add it to the in-use chunk list
202   // and do an allocation from it.
</pre>
<hr />
<pre>
267   _used_words += words;
268 
269   // Adjust global counters. This will be done atomically.
270   MetaspaceUtils::inc_used(mdtype(), words);
271 }
272 
273 void SpaceManager::account_for_spacemanager_death() {
274 
275   assert_lock_strong(MetaspaceExpand_lock);
276 
277   MetaspaceUtils::dec_capacity(mdtype(), _capacity_words);
278   MetaspaceUtils::dec_overhead(mdtype(), _overhead_words);
279   MetaspaceUtils::dec_used(mdtype(), _used_words);
280 }
281 
282 SpaceManager::~SpaceManager() {
283 
284   // This call this-&gt;_lock which can&#39;t be done while holding MetaspaceExpand_lock
285   DEBUG_ONLY(verify_metrics());
286 
<span class="line-modified">287   MutexLockerEx fcl(MetaspaceExpand_lock,</span>
<span class="line-removed">288                     Mutex::_no_safepoint_check_flag);</span>
289 
290   account_for_spacemanager_death();
291 
292   Log(gc, metaspace, freelist) log;
293   if (log.is_trace()) {
294     log.trace(&quot;~SpaceManager(): &quot; PTR_FORMAT, p2i(this));
295     ResourceMark rm;
296     LogStream ls(log.trace());
297     locked_print_chunks_in_use_on(&amp;ls);
298     if (block_freelists() != NULL) {
299       block_freelists()-&gt;print_on(&amp;ls);
300     }
301   }
302 
303   // Add all the chunks in use by this space manager
304   // to the global list of free chunks.
305 
306   // Follow each list of chunks-in-use and add them to the
307   // free lists.  Each list is NULL terminated.
308   chunk_manager()-&gt;return_chunk_list(chunk_list());
</pre>
<hr />
<pre>
385 
386 Metachunk* SpaceManager::get_new_chunk(size_t chunk_word_size) {
387   // Get a chunk from the chunk freelist
388   Metachunk* next = chunk_manager()-&gt;chunk_freelist_allocate(chunk_word_size);
389 
390   if (next == NULL) {
391     next = vs_list()-&gt;get_new_chunk(chunk_word_size,
392                                     medium_chunk_bunch());
393   }
394 
395   Log(gc, metaspace, alloc) log;
396   if (log.is_trace() &amp;&amp; next != NULL &amp;&amp;
397       SpaceManager::is_humongous(next-&gt;word_size())) {
398     log.trace(&quot;  new humongous chunk word size &quot; PTR_FORMAT, next-&gt;word_size());
399   }
400 
401   return next;
402 }
403 
404 MetaWord* SpaceManager::allocate(size_t word_size) {
<span class="line-modified">405   MutexLockerEx cl(lock(), Mutex::_no_safepoint_check_flag);</span>
406   size_t raw_word_size = get_allocation_word_size(word_size);
407   BlockFreelist* fl =  block_freelists();
408   MetaWord* p = NULL;
409 
410   // Allocation from the dictionary is expensive in the sense that
411   // the dictionary has to be searched for a size.  Don&#39;t allocate
412   // from the dictionary until it starts to get fat.  Is this
413   // a reasonable policy?  Maybe an skinny dictionary is fast enough
414   // for allocations.  Do some profiling.  JJJ
415   if (fl != NULL &amp;&amp; fl-&gt;total_size() &gt; allocation_from_dictionary_limit) {
416     p = fl-&gt;get_block(raw_word_size);
417     if (p != NULL) {
418       DEBUG_ONLY(Atomic::inc(&amp;g_internal_statistics.num_allocs_from_deallocated_blocks));
419     }
420   }
421   if (p == NULL) {
422     p = allocate_work(raw_word_size);
423   }
424 
425 #ifdef ASSERT
</pre>
<hr />
<pre>
481   Metachunk* chunk = chunk_list();
482   while (chunk != NULL) {
483     UsedChunksStatistics&amp; chunk_stat = out-&gt;chunk_stats(chunk-&gt;get_chunk_type());
484     chunk_stat.add_num(1);
485     chunk_stat.add_cap(chunk-&gt;word_size());
486     chunk_stat.add_overhead(Metachunk::overhead());
487     chunk_stat.add_used(chunk-&gt;used_word_size() - Metachunk::overhead());
488     if (chunk != current_chunk()) {
489       chunk_stat.add_waste(chunk-&gt;free_word_size());
490     } else {
491       chunk_stat.add_free(chunk-&gt;free_word_size());
492     }
493     chunk = chunk-&gt;next();
494   }
495   if (block_freelists() != NULL) {
496     out-&gt;add_free_blocks_info(block_freelists()-&gt;num_blocks(), block_freelists()-&gt;total_size());
497   }
498 }
499 
500 void SpaceManager::add_to_statistics(SpaceManagerStatistics* out) const {
<span class="line-modified">501   MutexLockerEx cl(lock(), Mutex::_no_safepoint_check_flag);</span>
502   add_to_statistics_locked(out);
503 }
504 
505 #ifdef ASSERT
506 void SpaceManager::verify_metrics_locked() const {
507   assert_lock_strong(lock());
508 
509   SpaceManagerStatistics stat;
510   add_to_statistics_locked(&amp;stat);
511 
512   UsedChunksStatistics chunk_stats = stat.totals();
513 
514   DEBUG_ONLY(chunk_stats.check_sanity());
515 
516   assert_counter(_capacity_words, chunk_stats.cap(), &quot;SpaceManager::_capacity_words&quot;);
517   assert_counter(_used_words, chunk_stats.used(), &quot;SpaceManager::_used_words&quot;);
518   assert_counter(_overhead_words, chunk_stats.overhead(), &quot;SpaceManager::_overhead_words&quot;);
519 }
520 
521 void SpaceManager::verify_metrics() const {
<span class="line-modified">522   MutexLockerEx cl(lock(), Mutex::_no_safepoint_check_flag);</span>
523   verify_metrics_locked();
524 }
525 #endif // ASSERT
526 
527 
528 } // namespace metaspace
529 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
162   }
163   return chunk_word_size;
164 }
165 
166 void SpaceManager::track_metaspace_memory_usage() {
167   if (is_init_completed()) {
168     if (is_class()) {
169       MemoryService::track_compressed_class_memory_usage();
170     }
171     MemoryService::track_metaspace_memory_usage();
172   }
173 }
174 
175 MetaWord* SpaceManager::grow_and_allocate(size_t word_size) {
176   assert_lock_strong(_lock);
177   assert(vs_list()-&gt;current_virtual_space() != NULL,
178          &quot;Should have been set&quot;);
179   assert(current_chunk() == NULL ||
180          current_chunk()-&gt;allocate(word_size) == NULL,
181          &quot;Don&#39;t need to expand&quot;);
<span class="line-modified">182   MutexLocker cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
183 
184   if (log_is_enabled(Trace, gc, metaspace, freelist)) {
185     size_t words_left = 0;
186     size_t words_used = 0;
187     if (current_chunk() != NULL) {
188       words_left = current_chunk()-&gt;free_word_size();
189       words_used = current_chunk()-&gt;used_word_size();
190     }
191     log_trace(gc, metaspace, freelist)(&quot;SpaceManager::grow_and_allocate for &quot; SIZE_FORMAT &quot; words &quot; SIZE_FORMAT &quot; words used &quot; SIZE_FORMAT &quot; words left&quot;,
192                                        word_size, words_used, words_left);
193   }
194 
195   // Get another chunk
196   size_t chunk_word_size = calc_chunk_size(word_size);
197   Metachunk* next = get_new_chunk(chunk_word_size);
198 
199   MetaWord* mem = NULL;
200 
201   // If a chunk was available, add it to the in-use chunk list
202   // and do an allocation from it.
</pre>
<hr />
<pre>
267   _used_words += words;
268 
269   // Adjust global counters. This will be done atomically.
270   MetaspaceUtils::inc_used(mdtype(), words);
271 }
272 
273 void SpaceManager::account_for_spacemanager_death() {
274 
275   assert_lock_strong(MetaspaceExpand_lock);
276 
277   MetaspaceUtils::dec_capacity(mdtype(), _capacity_words);
278   MetaspaceUtils::dec_overhead(mdtype(), _overhead_words);
279   MetaspaceUtils::dec_used(mdtype(), _used_words);
280 }
281 
282 SpaceManager::~SpaceManager() {
283 
284   // This call this-&gt;_lock which can&#39;t be done while holding MetaspaceExpand_lock
285   DEBUG_ONLY(verify_metrics());
286 
<span class="line-modified">287   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>

288 
289   account_for_spacemanager_death();
290 
291   Log(gc, metaspace, freelist) log;
292   if (log.is_trace()) {
293     log.trace(&quot;~SpaceManager(): &quot; PTR_FORMAT, p2i(this));
294     ResourceMark rm;
295     LogStream ls(log.trace());
296     locked_print_chunks_in_use_on(&amp;ls);
297     if (block_freelists() != NULL) {
298       block_freelists()-&gt;print_on(&amp;ls);
299     }
300   }
301 
302   // Add all the chunks in use by this space manager
303   // to the global list of free chunks.
304 
305   // Follow each list of chunks-in-use and add them to the
306   // free lists.  Each list is NULL terminated.
307   chunk_manager()-&gt;return_chunk_list(chunk_list());
</pre>
<hr />
<pre>
384 
385 Metachunk* SpaceManager::get_new_chunk(size_t chunk_word_size) {
386   // Get a chunk from the chunk freelist
387   Metachunk* next = chunk_manager()-&gt;chunk_freelist_allocate(chunk_word_size);
388 
389   if (next == NULL) {
390     next = vs_list()-&gt;get_new_chunk(chunk_word_size,
391                                     medium_chunk_bunch());
392   }
393 
394   Log(gc, metaspace, alloc) log;
395   if (log.is_trace() &amp;&amp; next != NULL &amp;&amp;
396       SpaceManager::is_humongous(next-&gt;word_size())) {
397     log.trace(&quot;  new humongous chunk word size &quot; PTR_FORMAT, next-&gt;word_size());
398   }
399 
400   return next;
401 }
402 
403 MetaWord* SpaceManager::allocate(size_t word_size) {
<span class="line-modified">404   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);</span>
405   size_t raw_word_size = get_allocation_word_size(word_size);
406   BlockFreelist* fl =  block_freelists();
407   MetaWord* p = NULL;
408 
409   // Allocation from the dictionary is expensive in the sense that
410   // the dictionary has to be searched for a size.  Don&#39;t allocate
411   // from the dictionary until it starts to get fat.  Is this
412   // a reasonable policy?  Maybe an skinny dictionary is fast enough
413   // for allocations.  Do some profiling.  JJJ
414   if (fl != NULL &amp;&amp; fl-&gt;total_size() &gt; allocation_from_dictionary_limit) {
415     p = fl-&gt;get_block(raw_word_size);
416     if (p != NULL) {
417       DEBUG_ONLY(Atomic::inc(&amp;g_internal_statistics.num_allocs_from_deallocated_blocks));
418     }
419   }
420   if (p == NULL) {
421     p = allocate_work(raw_word_size);
422   }
423 
424 #ifdef ASSERT
</pre>
<hr />
<pre>
480   Metachunk* chunk = chunk_list();
481   while (chunk != NULL) {
482     UsedChunksStatistics&amp; chunk_stat = out-&gt;chunk_stats(chunk-&gt;get_chunk_type());
483     chunk_stat.add_num(1);
484     chunk_stat.add_cap(chunk-&gt;word_size());
485     chunk_stat.add_overhead(Metachunk::overhead());
486     chunk_stat.add_used(chunk-&gt;used_word_size() - Metachunk::overhead());
487     if (chunk != current_chunk()) {
488       chunk_stat.add_waste(chunk-&gt;free_word_size());
489     } else {
490       chunk_stat.add_free(chunk-&gt;free_word_size());
491     }
492     chunk = chunk-&gt;next();
493   }
494   if (block_freelists() != NULL) {
495     out-&gt;add_free_blocks_info(block_freelists()-&gt;num_blocks(), block_freelists()-&gt;total_size());
496   }
497 }
498 
499 void SpaceManager::add_to_statistics(SpaceManagerStatistics* out) const {
<span class="line-modified">500   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);</span>
501   add_to_statistics_locked(out);
502 }
503 
504 #ifdef ASSERT
505 void SpaceManager::verify_metrics_locked() const {
506   assert_lock_strong(lock());
507 
508   SpaceManagerStatistics stat;
509   add_to_statistics_locked(&amp;stat);
510 
511   UsedChunksStatistics chunk_stats = stat.totals();
512 
513   DEBUG_ONLY(chunk_stats.check_sanity());
514 
515   assert_counter(_capacity_words, chunk_stats.cap(), &quot;SpaceManager::_capacity_words&quot;);
516   assert_counter(_used_words, chunk_stats.used(), &quot;SpaceManager::_used_words&quot;);
517   assert_counter(_overhead_words, chunk_stats.overhead(), &quot;SpaceManager::_overhead_words&quot;);
518 }
519 
520 void SpaceManager::verify_metrics() const {
<span class="line-modified">521   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);</span>
522   verify_metrics_locked();
523 }
524 #endif // ASSERT
525 
526 
527 } // namespace metaspace
528 
</pre>
</td>
</tr>
</table>
<center><a href="printMetaspaceInfoKlassClosure.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="virtualSpaceList.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
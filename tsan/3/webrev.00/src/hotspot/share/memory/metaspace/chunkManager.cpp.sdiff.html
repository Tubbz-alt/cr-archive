<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/metaspace/chunkManager.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../metaspace.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="metaspaceCommon.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/metaspace/chunkManager.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
210     &quot;ChunkManager::_free_chunks_count: about to go negative (&quot; SIZE_FORMAT &quot;).&quot;, _free_chunks_count);
211   assert(_free_chunks_total &gt;= c-&gt;word_size(),
212     &quot;ChunkManager::_free_chunks_total: about to go negative&quot;
213      &quot;(now: &quot; SIZE_FORMAT &quot;, decrement value: &quot; SIZE_FORMAT &quot;).&quot;, _free_chunks_total, c-&gt;word_size());
214   _free_chunks_count --;
215   _free_chunks_total -= c-&gt;word_size();
216 }
217 
218 ChunkIndex ChunkManager::list_index(size_t size) {
219   return get_chunk_type_by_size(size, is_class());
220 }
221 
222 size_t ChunkManager::size_by_index(ChunkIndex index) const {
223   index_bounds_check(index);
224   assert(index != HumongousIndex, &quot;Do not call for humongous chunks.&quot;);
225   return get_size_for_nonhumongous_chunktype(index, is_class());
226 }
227 
228 #ifdef ASSERT
229 void ChunkManager::verify(bool slow) const {
<span class="line-modified">230   MutexLockerEx cl(MetaspaceExpand_lock,</span>
231                      Mutex::_no_safepoint_check_flag);
232   locked_verify(slow);
233 }
234 
235 void ChunkManager::locked_verify(bool slow) const {
236   log_trace(gc, metaspace, freelist)(&quot;verifying %s chunkmanager (%s).&quot;,
237     (is_class() ? &quot;class space&quot; : &quot;metaspace&quot;), (slow ? &quot;slow&quot; : &quot;quick&quot;));
238 
239   assert_lock_strong(MetaspaceExpand_lock);
240 
241   size_t chunks_counted = 0;
242   size_t wordsize_chunks_counted = 0;
243   for (ChunkIndex i = ZeroIndex; i &lt; NumberOfFreeLists; i = next_chunk_index(i)) {
244     const ChunkList* list = _free_chunks + i;
245     if (list != NULL) {
246       Metachunk* chunk = list-&gt;head();
247       while (chunk) {
248         if (slow) {
249           do_verify_chunk(chunk);
250         }
</pre>
<hr />
<pre>
613   size_t size_chunks_returned = 0;
614   Metachunk* cur = chunks;
615   while (cur != NULL) {
616     // Capture the next link before it is changed
617     // by the call to return_chunk_at_head();
618     Metachunk* next = cur-&gt;next();
619     if (log.is_enabled()) { // tracing
620       num_chunks_returned ++;
621       size_chunks_returned += cur-&gt;word_size();
622     }
623     return_single_chunk(cur);
624     cur = next;
625   }
626   if (log.is_enabled()) { // tracing
627     log.print(&quot;returned %u chunks to freelist, total word size &quot; SIZE_FORMAT &quot;.&quot;,
628         num_chunks_returned, size_chunks_returned);
629   }
630 }
631 
632 void ChunkManager::collect_statistics(ChunkManagerStatistics* out) const {
<span class="line-modified">633   MutexLockerEx cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
634   for (ChunkIndex i = ZeroIndex; i &lt; NumberOfInUseLists; i = next_chunk_index(i)) {
635     out-&gt;chunk_stats(i).add(num_free_chunks(i), size_free_chunks_in_bytes(i) / sizeof(MetaWord));
636   }
637 }
638 
639 } // namespace metaspace
640 
641 
642 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
210     &quot;ChunkManager::_free_chunks_count: about to go negative (&quot; SIZE_FORMAT &quot;).&quot;, _free_chunks_count);
211   assert(_free_chunks_total &gt;= c-&gt;word_size(),
212     &quot;ChunkManager::_free_chunks_total: about to go negative&quot;
213      &quot;(now: &quot; SIZE_FORMAT &quot;, decrement value: &quot; SIZE_FORMAT &quot;).&quot;, _free_chunks_total, c-&gt;word_size());
214   _free_chunks_count --;
215   _free_chunks_total -= c-&gt;word_size();
216 }
217 
218 ChunkIndex ChunkManager::list_index(size_t size) {
219   return get_chunk_type_by_size(size, is_class());
220 }
221 
222 size_t ChunkManager::size_by_index(ChunkIndex index) const {
223   index_bounds_check(index);
224   assert(index != HumongousIndex, &quot;Do not call for humongous chunks.&quot;);
225   return get_size_for_nonhumongous_chunktype(index, is_class());
226 }
227 
228 #ifdef ASSERT
229 void ChunkManager::verify(bool slow) const {
<span class="line-modified">230   MutexLocker cl(MetaspaceExpand_lock,</span>
231                      Mutex::_no_safepoint_check_flag);
232   locked_verify(slow);
233 }
234 
235 void ChunkManager::locked_verify(bool slow) const {
236   log_trace(gc, metaspace, freelist)(&quot;verifying %s chunkmanager (%s).&quot;,
237     (is_class() ? &quot;class space&quot; : &quot;metaspace&quot;), (slow ? &quot;slow&quot; : &quot;quick&quot;));
238 
239   assert_lock_strong(MetaspaceExpand_lock);
240 
241   size_t chunks_counted = 0;
242   size_t wordsize_chunks_counted = 0;
243   for (ChunkIndex i = ZeroIndex; i &lt; NumberOfFreeLists; i = next_chunk_index(i)) {
244     const ChunkList* list = _free_chunks + i;
245     if (list != NULL) {
246       Metachunk* chunk = list-&gt;head();
247       while (chunk) {
248         if (slow) {
249           do_verify_chunk(chunk);
250         }
</pre>
<hr />
<pre>
613   size_t size_chunks_returned = 0;
614   Metachunk* cur = chunks;
615   while (cur != NULL) {
616     // Capture the next link before it is changed
617     // by the call to return_chunk_at_head();
618     Metachunk* next = cur-&gt;next();
619     if (log.is_enabled()) { // tracing
620       num_chunks_returned ++;
621       size_chunks_returned += cur-&gt;word_size();
622     }
623     return_single_chunk(cur);
624     cur = next;
625   }
626   if (log.is_enabled()) { // tracing
627     log.print(&quot;returned %u chunks to freelist, total word size &quot; SIZE_FORMAT &quot;.&quot;,
628         num_chunks_returned, size_chunks_returned);
629   }
630 }
631 
632 void ChunkManager::collect_statistics(ChunkManagerStatistics* out) const {
<span class="line-modified">633   MutexLocker cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
634   for (ChunkIndex i = ZeroIndex; i &lt; NumberOfInUseLists; i = next_chunk_index(i)) {
635     out-&gt;chunk_stats(i).add(num_free_chunks(i), size_free_chunks_in_bytes(i) / sizeof(MetaWord));
636   }
637 }
638 
639 } // namespace metaspace
640 
641 
642 
</pre>
</td>
</tr>
</table>
<center><a href="../metaspace.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="metaspaceCommon.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
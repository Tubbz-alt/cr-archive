<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/memory/allocation.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="allocation.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="allocation.inline.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/allocation.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -23,16 +23,16 @@</span>
   */
  
  #ifndef SHARE_MEMORY_ALLOCATION_HPP
  #define SHARE_MEMORY_ALLOCATION_HPP
  
<span class="udiff-line-removed">- #include &quot;runtime/globals.hpp&quot;</span>
  #include &quot;utilities/globalDefinitions.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  
  #include &lt;new&gt;
  
<span class="udiff-line-added">+ class outputStream;</span>
  class Thread;
  
  class AllocFailStrategy {
  public:
    enum AllocFailEnum { EXIT_OOM, RETURN_NULL };
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -78,20 +78,25 @@</span>
  // WARNING: The array variant must only be used for a homogenous array
  // where all objects are of the exact type specified. If subtypes are
  // stored in the array then must pay attention to calling destructors
  // at needed.
  //
<span class="udiff-line-modified-removed">- //   NEW_RESOURCE_ARRAY(type, size)</span>
<span class="udiff-line-modified-removed">- //   NEW_RESOURCE_OBJ(type)</span>
<span class="udiff-line-modified-removed">- //   NEW_C_HEAP_ARRAY(type, size)</span>
<span class="udiff-line-modified-removed">- //   NEW_C_HEAP_OBJ(type, memflags)</span>
<span class="udiff-line-modified-removed">- //   FREE_C_HEAP_ARRAY(type, old)</span>
<span class="udiff-line-modified-removed">- //   FREE_C_HEAP_OBJ(objname, type, memflags)</span>
<span class="udiff-line-modified-removed">- //   char* AllocateHeap(size_t size, const char* name);</span>
<span class="udiff-line-modified-removed">- //   void  FreeHeap(void* p);</span>
<span class="udiff-line-modified-added">+ // NEW_RESOURCE_ARRAY*</span>
<span class="udiff-line-modified-added">+ // REALLOC_RESOURCE_ARRAY*</span>
<span class="udiff-line-modified-added">+ // FREE_RESOURCE_ARRAY*</span>
<span class="udiff-line-modified-added">+ // NEW_RESOURCE_OBJ*</span>
<span class="udiff-line-modified-added">+ // NEW_C_HEAP_ARRAY*</span>
<span class="udiff-line-modified-added">+ // REALLOC_C_HEAP_ARRAY*</span>
<span class="udiff-line-modified-added">+ // FREE_C_HEAP_ARRAY*</span>
<span class="udiff-line-modified-added">+ // NEW_C_HEAP_OBJ*</span>
<span class="udiff-line-added">+ // FREE_C_HEAP_OBJ</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ // char* AllocateHeap(size_t size, MEMFLAGS flags, const NativeCallStack&amp; stack, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);</span>
<span class="udiff-line-added">+ // char* AllocateHeap(size_t size, MEMFLAGS flags, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);</span>
<span class="udiff-line-added">+ // char* ReallocateHeap(char *old, size_t size, MEMFLAGS flag, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);</span>
<span class="udiff-line-added">+ // void FreeHeap(void* p);</span>
  //
<span class="udiff-line-removed">- </span>
  // In non product mode we introduce a super class for all allocation classes
  // that supports printing.
  // We avoid the superclass in product mode to save space.
  
  #ifdef PRODUCT
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -116,10 +121,11 @@</span>
    f(mtThread,        &quot;Thread&quot;)      /* thread objects                            */ \
    f(mtThreadStack,   &quot;Thread Stack&quot;)                                                \
    f(mtCode,          &quot;Code&quot;)        /* generated code                            */ \
    f(mtGC,            &quot;GC&quot;)                                                          \
    f(mtCompiler,      &quot;Compiler&quot;)                                                    \
<span class="udiff-line-added">+   f(mtJVMCI,         &quot;JVMCI&quot;)                                                       \</span>
    f(mtInternal,      &quot;Internal&quot;)    /* memory used by VM, but does not belong to */ \
                                      /* any of above categories, and not used by  */ \
                                      /* NMT                                       */ \
    f(mtOther,         &quot;Other&quot;)       /* memory not used by VM                     */ \
    f(mtSymbol,        &quot;Symbol&quot;)                                                      \
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -127,10 +133,11 @@</span>
    f(mtClassShared,   &quot;Shared class space&quot;)      /* class data sharing            */ \
    f(mtChunk,         &quot;Arena Chunk&quot;) /* chunk that holds content of arenas        */ \
    f(mtTest,          &quot;Test&quot;)        /* Test type for verifying NMT               */ \
    f(mtTracing,       &quot;Tracing&quot;)                                                     \
    f(mtLogging,       &quot;Logging&quot;)                                                     \
<span class="udiff-line-added">+   f(mtStatistics,    &quot;Statistics&quot;)                                                  \</span>
    f(mtArguments,     &quot;Arguments&quot;)                                                   \
    f(mtModule,        &quot;Module&quot;)                                                      \
    f(mtSafepoint,     &quot;Safepoint&quot;)                                                   \
    f(mtSynchronizer,  &quot;Synchronization&quot;)                                             \
    f(mtNone,          &quot;Unknown&quot;)                                                     \
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -175,10 +182,11 @@</span>
  char* ReallocateHeap(char *old,
                       size_t size,
                       MEMFLAGS flag,
                       AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);
  
<span class="udiff-line-added">+ // handles NULL pointers</span>
  void FreeHeap(void* p);
  
  template &lt;MEMFLAGS F&gt; class CHeapObj ALLOCATION_SUPER_CLASS_SPEC {
   public:
    ALWAYSINLINE void* operator new(size_t size) throw() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -226,13 +234,10 @@</span>
  
  class StackObj ALLOCATION_SUPER_CLASS_SPEC {
   private:
    void* operator new(size_t size) throw();
    void* operator new [](size_t size) throw();
<span class="udiff-line-removed">- #ifdef __IBMCPP__</span>
<span class="udiff-line-removed">-  public:</span>
<span class="udiff-line-removed">- #endif</span>
    void  operator delete(void* p);
    void  operator delete [](void* p);
  };
  
  // Base class for objects stored in Metaspace.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -250,28 +255,36 @@</span>
    friend class VMStructs;
    // When CDS is enabled, all shared metaspace objects are mapped
    // into a single contiguous memory block, so we can use these
    // two pointers to quickly determine if something is in the
    // shared metaspace.
<span class="udiff-line-removed">-   //</span>
    // When CDS is not enabled, both pointers are set to NULL.
<span class="udiff-line-modified-removed">-   static void* _shared_metaspace_base; // (inclusive) low address</span>
<span class="udiff-line-modified-removed">-   static void* _shared_metaspace_top;  // (exclusive) high address</span>
<span class="udiff-line-modified-added">+   static void* _shared_metaspace_base;  // (inclusive) low address</span>
<span class="udiff-line-modified-added">+   static void* _shared_metaspace_top;   // (exclusive) high address</span>
  
   public:
<span class="udiff-line-modified-removed">-   bool is_metaspace_object() const;</span>
<span class="udiff-line-modified-removed">-   bool is_shared() const {</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   // Returns true if the pointer points to a valid MetaspaceObj. A valid</span>
<span class="udiff-line-added">+   // MetaspaceObj is MetaWord-aligned and contained within either</span>
<span class="udiff-line-added">+   // non-shared or shared metaspace.</span>
<span class="udiff-line-added">+   static bool is_valid(const MetaspaceObj* p);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   static bool is_shared(const MetaspaceObj* p) {</span>
      // If no shared metaspace regions are mapped, _shared_metaspace_{base,top} will
      // both be NULL and all values of p will be rejected quickly.
<span class="udiff-line-modified-removed">-     return (((void*)this) &lt; _shared_metaspace_top &amp;&amp; ((void*)this) &gt;= _shared_metaspace_base);</span>
<span class="udiff-line-modified-added">+     return (((void*)p) &lt; _shared_metaspace_top &amp;&amp;</span>
<span class="udiff-line-added">+             ((void*)p) &gt;= _shared_metaspace_base);</span>
    }
<span class="udiff-line-added">+   bool is_shared() const { return MetaspaceObj::is_shared(this); }</span>
<span class="udiff-line-added">+ </span>
    void print_address_on(outputStream* st) const;  // nonvirtual address printing
  
    static void set_shared_metaspace_range(void* base, void* top) {
      _shared_metaspace_base = base;
      _shared_metaspace_top = top;
    }
<span class="udiff-line-added">+ </span>
    static void* shared_metaspace_base() { return _shared_metaspace_base; }
    static void* shared_metaspace_top()  { return _shared_metaspace_top;  }
  
  #define METASPACE_OBJ_TYPES_DO(f) \
    f(Class) \
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -285,11 +298,12 @@</span>
    f(ConstMethod) \
    f(MethodData) \
    f(ConstantPool) \
    f(ConstantPoolCache) \
    f(Annotations) \
<span class="udiff-line-modified-removed">-   f(MethodCounters)</span>
<span class="udiff-line-modified-added">+   f(MethodCounters) \</span>
<span class="udiff-line-added">+   f(RecordComponent)</span>
  
  #define METASPACE_OBJ_TYPE_DECLARE(name) name ## Type,
  #define METASPACE_OBJ_TYPE_NAME_CASE(name) case name ## Type: return #name;
  
    enum Type {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -490,27 +504,10 @@</span>
  
  // deallocate obj of type in heap without calling dtor
  #define FREE_C_HEAP_OBJ(objname)\
    FreeHeap((char*)objname);
  
<span class="udiff-line-removed">- // for statistics</span>
<span class="udiff-line-removed">- #ifndef PRODUCT</span>
<span class="udiff-line-removed">- class AllocStats : StackObj {</span>
<span class="udiff-line-removed">-   julong start_mallocs, start_frees;</span>
<span class="udiff-line-removed">-   julong start_malloc_bytes, start_mfree_bytes, start_res_bytes;</span>
<span class="udiff-line-removed">-  public:</span>
<span class="udiff-line-removed">-   AllocStats();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   julong num_mallocs();    // since creation of receiver</span>
<span class="udiff-line-removed">-   julong alloc_bytes();</span>
<span class="udiff-line-removed">-   julong num_frees();</span>
<span class="udiff-line-removed">-   julong free_bytes();</span>
<span class="udiff-line-removed">-   julong resource_bytes();</span>
<span class="udiff-line-removed">-   void   print();</span>
<span class="udiff-line-removed">- };</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
  
  //------------------------------ReallocMark---------------------------------
  // Code which uses REALLOC_RESOURCE_ARRAY should check an associated
  // ReallocMark, which is declared in the same scope as the reallocated
  // pointer.  Any operation that could __potentially__ cause a reallocation
</pre>
<center><a href="allocation.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="allocation.inline.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
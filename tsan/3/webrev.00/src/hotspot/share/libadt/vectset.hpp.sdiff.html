<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/libadt/vectset.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="vectset.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../logging/logConfiguration.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/libadt/vectset.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_LIBADT_VECTSET_HPP
 26 #define SHARE_LIBADT_VECTSET_HPP
 27 
<span class="line-modified"> 28 #include &quot;libadt/set.hpp&quot;</span>

 29 
<span class="line-modified"> 30 #define BITS_IN_BYTE_ARRAY_SIZE 256</span>
<span class="line-removed"> 31 </span>
<span class="line-removed"> 32 // Vector Sets - An Abstract Data Type</span>
<span class="line-removed"> 33 //INTERFACE</span>
 34 
 35 // These sets can grow or shrink, based on the initial size and the largest
<span class="line-modified"> 36 // element currently in them.  Slow and bulky for sparse sets, these sets</span>
<span class="line-removed"> 37 // are super for dense sets.  They are fast and compact when dense.</span>
<span class="line-removed"> 38 </span>
<span class="line-removed"> 39 // TIME:</span>
<span class="line-removed"> 40 // O(1) - Insert, Delete, Member, Sort</span>
<span class="line-removed"> 41 // O(max_element) - Create, Clear, Size, Copy, Union, Intersect, Difference,</span>
<span class="line-removed"> 42 //                  Equal, ChooseMember, Forall</span>
<span class="line-removed"> 43 </span>
<span class="line-removed"> 44 // SPACE: (max_element)/(8*sizeof(int))</span>
<span class="line-removed"> 45 </span>
 46 
 47 //------------------------------VectorSet--------------------------------------
<span class="line-modified"> 48 class VectorSet : public Set {</span>
<span class="line-modified"> 49 friend class VectorSetI;        // Friendly iterator class</span>
<span class="line-modified"> 50 protected:</span>
<span class="line-modified"> 51   uint size;                    // Size of data IN LONGWORDS (32bits)</span>
<span class="line-modified"> 52   uint32_t* data;               // The data, bit packed</span>
 53 
<span class="line-modified"> 54   void slamin( const VectorSet&amp; s );     // Initialize one set with another</span>
<span class="line-modified"> 55   int compare(const VectorSet &amp;s) const; // Compare set contents</span>
<span class="line-modified"> 56   void grow(uint newsize);               // Grow vector to required bitsize</span>



 57 


 58 public:
<span class="line-modified"> 59   VectorSet(Arena *arena);                      // Creates a new, empty set.</span>
<span class="line-removed"> 60   VectorSet(const VectorSet &amp;s) : Set(s._set_arena) {slamin(s);} // Set clone; deep-copy guts</span>
<span class="line-removed"> 61   Set &amp;operator =(const Set &amp;s);                // Set clone; deep-copy guts</span>
<span class="line-removed"> 62   VectorSet &amp;operator =(const VectorSet &amp;s)     // Set clone; deep-copy guts</span>
<span class="line-removed"> 63   { if( &amp;s != this ) { slamin(s); } return *this; }</span>
 64   ~VectorSet() {}
<span class="line-removed"> 65   Set &amp;clone(void) const { return *(new VectorSet(*this)); }</span>
<span class="line-removed"> 66 </span>
<span class="line-removed"> 67   Set &amp;operator &lt;&lt;=(uint elem);          // Add member to set</span>
<span class="line-removed"> 68   VectorSet operator &lt;&lt; (uint elem)      // Add member to new set</span>
<span class="line-removed"> 69   { VectorSet foo(*this); foo &lt;&lt;= elem; return foo; }</span>
<span class="line-removed"> 70   Set &amp;operator &gt;&gt;=(uint elem);          // Delete member from set</span>
<span class="line-removed"> 71   VectorSet operator &gt;&gt; (uint elem)      // Delete member from new set</span>
<span class="line-removed"> 72   { VectorSet foo(*this); foo &gt;&gt;= elem; return foo; }</span>
<span class="line-removed"> 73 </span>
<span class="line-removed"> 74   VectorSet &amp;operator &amp;=(const VectorSet &amp;s); // Intersect sets into first set</span>
<span class="line-removed"> 75   Set       &amp;operator &amp;=(const Set       &amp;s); // Intersect sets into first set</span>
<span class="line-removed"> 76   VectorSet operator &amp; (const VectorSet &amp;s) const</span>
<span class="line-removed"> 77   { VectorSet foo(*this); foo &amp;= s; return foo; }</span>
 78 
<span class="line-modified"> 79   VectorSet &amp;operator |=(const VectorSet &amp;s); // Intersect sets into first set</span>
<span class="line-modified"> 80   Set       &amp;operator |=(const Set       &amp;s); // Intersect sets into first set</span>
<span class="line-modified"> 81   VectorSet operator | (const VectorSet &amp;s) const</span>
<span class="line-modified"> 82   { VectorSet foo(*this); foo |= s; return foo; }</span>
<span class="line-modified"> 83 </span>
<span class="line-modified"> 84   VectorSet &amp;operator -=(const VectorSet &amp;s); // Intersect sets into first set</span>
<span class="line-modified"> 85   Set       &amp;operator -=(const Set       &amp;s); // Intersect sets into first set</span>
<span class="line-removed"> 86   VectorSet operator - (const VectorSet &amp;s) const</span>
<span class="line-removed"> 87   { VectorSet foo(*this); foo -= s; return foo; }</span>
<span class="line-removed"> 88 </span>
<span class="line-removed"> 89   int operator ==(const VectorSet &amp;s) const;  // True if sets are equal</span>
<span class="line-removed"> 90   int operator ==(const Set       &amp;s) const;  // True if sets are equal</span>
<span class="line-removed"> 91   int operator &lt; (const VectorSet &amp;s) const;  // True if strict subset</span>
<span class="line-removed"> 92   int operator &lt; (const Set       &amp;s) const;  // True if strict subset</span>
<span class="line-removed"> 93   int operator &lt;=(const VectorSet &amp;s) const;  // True if subset relation holds.</span>
<span class="line-removed"> 94   int operator &lt;=(const Set       &amp;s) const;  // True if subset relation holds.</span>
<span class="line-removed"> 95   int disjoint   (const Set       &amp;s) const;  // True if sets are disjoint</span>
<span class="line-removed"> 96 </span>
<span class="line-removed"> 97   int operator [](uint elem) const; // Test for membership</span>
<span class="line-removed"> 98   void Clear(void);                 // Clear a set</span>
<span class="line-removed"> 99   uint Size(void) const;            // Number of elements in the Set.</span>
<span class="line-removed">100   void Sort(void);                  // Sort before iterating</span>
<span class="line-removed">101   int hash() const;                 // Hash function</span>
<span class="line-removed">102   void Reset(void) {                // Reset a set</span>
<span class="line-removed">103     memset( data, 0, size*sizeof(uint32_t) );</span>
104   }
<span class="line-removed">105 </span>
<span class="line-removed">106   /* Removed for MCC BUG</span>
<span class="line-removed">107      operator const VectorSet* (void) const { return this; } */</span>
<span class="line-removed">108   const VectorSet *asVectorSet() const { return this; }</span>
<span class="line-removed">109 </span>
<span class="line-removed">110   // Expose internals for speed-critical fast iterators</span>
<span class="line-removed">111   uint word_size() const { return size; }</span>
112 
113   // Fast inlined &quot;test and set&quot;.  Replaces the idiom:
<span class="line-modified">114   //     if( visited[idx] ) return;</span>
<span class="line-modified">115   //     visited &lt;&lt;= idx;</span>
116   // With:
<span class="line-modified">117   //     if( visited.test_set(idx) ) return;</span>
118   //
<span class="line-modified">119   int test_set( uint elem ) {</span>
<span class="line-modified">120     uint word = elem &gt;&gt; 5;           // Get the longword offset</span>
<span class="line-modified">121     if( word &gt;= size )               // Beyond the last?</span>
<span class="line-modified">122       return test_set_grow(elem);    // Then grow; set; return 0;</span>
<span class="line-modified">123     uint32_t mask = 1L &lt;&lt; (elem &amp; 31); // Get bit mask</span>
<span class="line-modified">124     uint32_t datum = data[word] &amp; mask;// Get bit</span>
<span class="line-modified">125     data[word] |= mask;              // Set bit</span>
<span class="line-modified">126     return datum;                    // Return bit</span>
<span class="line-modified">127   }</span>
<span class="line-modified">128   int test_set_grow( uint elem ) {    // Insert &amp; return 0;</span>
<span class="line-removed">129     (*this) &lt;&lt;= elem;                 // Insert into set</span>
<span class="line-removed">130     return 0;                         // Return 0!</span>
131   }
132 
133   // Fast inlined test
<span class="line-modified">134   int test( uint elem ) const {</span>
<span class="line-modified">135     uint word = elem &gt;&gt; 5;      // Get the longword offset</span>
<span class="line-modified">136     if( word &gt;= size ) return 0; // Beyond the last?</span>
<span class="line-modified">137     uint32_t mask = 1L &lt;&lt; (elem &amp; 31); // Get bit mask</span>
<span class="line-modified">138     return data[word] &amp; mask;   // Get bit</span>


139   }
140 
<span class="line-modified">141   // Fast inlined set</span>
<span class="line-modified">142   void set( uint elem ) {</span>
<span class="line-modified">143     uint word = elem &gt;&gt; 5;      // Get the longword offset</span>
<span class="line-modified">144     if( word &gt;= size ) {        // Beyond the last?</span>
<span class="line-removed">145       test_set_grow(elem);      // Then grow and set</span>
<span class="line-removed">146     } else {</span>
<span class="line-removed">147       uint32_t mask = 1L &lt;&lt; (elem &amp; 31); // Get bit mask</span>
<span class="line-removed">148       data[word] |= mask;       // Set bit</span>
149     }


150   }
151 
<span class="line-modified">152 </span>
<span class="line-modified">153 private:</span>
<span class="line-modified">154   SetI_ *iterate(uint&amp;) const;</span>
<span class="line-modified">155 };</span>
<span class="line-modified">156 </span>
<span class="line-modified">157 //------------------------------Iteration--------------------------------------</span>
<span class="line-modified">158 // Loop thru all elements of the set, setting &quot;elem&quot; to the element numbers</span>
<span class="line-modified">159 // in random order.  Inserted or deleted elements during this operation may</span>
<span class="line-removed">160 // or may not be iterated over; untouched elements will be affected once.</span>
<span class="line-removed">161 // Usage:  for( VectorSetI i(s); i.test(); i++ ) { body = i.elem; }</span>
<span class="line-removed">162 </span>
<span class="line-removed">163 class VectorSetI : public StackObj {</span>
<span class="line-removed">164   friend class VectorSet;</span>
<span class="line-removed">165   const VectorSet *s;</span>
<span class="line-removed">166   uint i, j;</span>
<span class="line-removed">167   uint32_t mask;</span>
<span class="line-removed">168   uint next(void);</span>
<span class="line-removed">169 </span>
<span class="line-removed">170 public:</span>
<span class="line-removed">171   uint elem;                    // The publically accessible element</span>
<span class="line-removed">172 </span>
<span class="line-removed">173   VectorSetI( const VectorSet *vset ) :</span>
<span class="line-removed">174     s(vset),</span>
<span class="line-removed">175     i((uint)-1L),</span>
<span class="line-removed">176     j((uint)-1L),</span>
<span class="line-removed">177     mask((unsigned)(1L&lt;&lt;31)) {</span>
<span class="line-removed">178     elem = next();</span>
179   }
<span class="line-removed">180 </span>
<span class="line-removed">181   void operator ++(void) { elem = next(); }</span>
<span class="line-removed">182   int test(void) { return i &lt; s-&gt;size; }</span>
183 };
184 
185 #endif // SHARE_LIBADT_VECTSET_HPP
</pre>
</td>
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_LIBADT_VECTSET_HPP
 26 #define SHARE_LIBADT_VECTSET_HPP
 27 
<span class="line-modified"> 28 #include &quot;memory/allocation.hpp&quot;</span>
<span class="line-added"> 29 #include &quot;utilities/copy.hpp&quot;</span>
 30 
<span class="line-modified"> 31 // Vector Sets</span>



 32 
 33 // These sets can grow or shrink, based on the initial size and the largest
<span class="line-modified"> 34 // element currently in them.</span>









 35 
 36 //------------------------------VectorSet--------------------------------------
<span class="line-modified"> 37 class VectorSet : public ResourceObj {</span>
<span class="line-modified"> 38 private:</span>
<span class="line-modified"> 39 </span>
<span class="line-modified"> 40   static const uint word_bits = 5;</span>
<span class="line-modified"> 41   static const uint bit_mask  = 31;</span>
 42 
<span class="line-modified"> 43   // Used 32-bit words</span>
<span class="line-modified"> 44   uint       _size;</span>
<span class="line-modified"> 45   uint32_t*  _data;</span>
<span class="line-added"> 46   // Allocated words</span>
<span class="line-added"> 47   uint       _data_size;</span>
<span class="line-added"> 48   Arena*     _set_arena;</span>
 49 
<span class="line-added"> 50   // Grow vector to required word capacity</span>
<span class="line-added"> 51   void grow(uint new_word_capacity);</span>
 52 public:
<span class="line-modified"> 53   VectorSet(Arena *arena);</span>




 54   ~VectorSet() {}













 55 
<span class="line-modified"> 56   void insert(uint elem);</span>
<span class="line-modified"> 57   bool is_empty() const;</span>
<span class="line-modified"> 58   void reset() {</span>
<span class="line-modified"> 59     _size = 0;</span>
<span class="line-modified"> 60   }</span>
<span class="line-modified"> 61   void clear() {</span>
<span class="line-modified"> 62     reset();</span>


















 63   }







 64 
 65   // Fast inlined &quot;test and set&quot;.  Replaces the idiom:
<span class="line-modified"> 66   //     if (visited.test(idx)) return;</span>
<span class="line-modified"> 67   //     visited.set(idx);</span>
 68   // With:
<span class="line-modified"> 69   //     if (visited.test_set(idx)) return;</span>
 70   //
<span class="line-modified"> 71   bool test_set(uint elem) {</span>
<span class="line-modified"> 72     uint32_t word = elem &gt;&gt; word_bits;</span>
<span class="line-modified"> 73     if (word &gt;= _size) {</span>
<span class="line-modified"> 74       // Then grow</span>
<span class="line-modified"> 75       grow(word);</span>
<span class="line-modified"> 76     }</span>
<span class="line-modified"> 77     uint32_t mask = 1U &lt;&lt; (elem &amp; bit_mask);</span>
<span class="line-modified"> 78     uint32_t data = _data[word];</span>
<span class="line-modified"> 79     _data[word] = data | mask;</span>
<span class="line-modified"> 80     return (data &amp; mask) != 0;</span>


 81   }
 82 
 83   // Fast inlined test
<span class="line-modified"> 84   bool test(uint elem) const {</span>
<span class="line-modified"> 85     uint32_t word = elem &gt;&gt; word_bits;</span>
<span class="line-modified"> 86     if (word &gt;= _size) {</span>
<span class="line-modified"> 87       return false;</span>
<span class="line-modified"> 88     }</span>
<span class="line-added"> 89     uint32_t mask = 1U &lt;&lt; (elem &amp; bit_mask);</span>
<span class="line-added"> 90     return (_data[word] &amp; mask) != 0;</span>
 91   }
 92 
<span class="line-modified"> 93   void remove(uint elem) {</span>
<span class="line-modified"> 94     uint32_t word = elem &gt;&gt; word_bits;</span>
<span class="line-modified"> 95     if (word &gt;= _size) {</span>
<span class="line-modified"> 96       return;</span>




 97     }
<span class="line-added"> 98     uint32_t mask = 1U &lt;&lt; (elem &amp; bit_mask);</span>
<span class="line-added"> 99     _data[word] &amp;= ~mask; // Clear bit</span>
100   }
101 
<span class="line-modified">102   // Fast inlined set</span>
<span class="line-modified">103   void set(uint elem) {</span>
<span class="line-modified">104     uint32_t word = elem &gt;&gt; word_bits;</span>
<span class="line-modified">105     if (word &gt;= _size) {</span>
<span class="line-modified">106       grow(word);</span>
<span class="line-modified">107     }</span>
<span class="line-modified">108     uint32_t mask = 1U &lt;&lt; (elem &amp; bit_mask);</span>
<span class="line-modified">109     _data[word] |= mask;</span>



















110   }



111 };
112 
113 #endif // SHARE_LIBADT_VECTSET_HPP
</pre>
</td>
</tr>
</table>
<center><a href="vectset.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../logging/logConfiguration.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
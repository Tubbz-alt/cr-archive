<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/libadt/vectset.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="vectset.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../logging/logConfiguration.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/libadt/vectset.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -23,163 +23,91 @@</span>
   */
  
  #ifndef SHARE_LIBADT_VECTSET_HPP
  #define SHARE_LIBADT_VECTSET_HPP
  
<span class="udiff-line-modified-removed">- #include &quot;libadt/set.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;memory/allocation.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;utilities/copy.hpp&quot;</span>
  
<span class="udiff-line-modified-removed">- #define BITS_IN_BYTE_ARRAY_SIZE 256</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // Vector Sets - An Abstract Data Type</span>
<span class="udiff-line-removed">- //INTERFACE</span>
<span class="udiff-line-modified-added">+ // Vector Sets</span>
  
  // These sets can grow or shrink, based on the initial size and the largest
<span class="udiff-line-modified-removed">- // element currently in them.  Slow and bulky for sparse sets, these sets</span>
<span class="udiff-line-removed">- // are super for dense sets.  They are fast and compact when dense.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // TIME:</span>
<span class="udiff-line-removed">- // O(1) - Insert, Delete, Member, Sort</span>
<span class="udiff-line-removed">- // O(max_element) - Create, Clear, Size, Copy, Union, Intersect, Difference,</span>
<span class="udiff-line-removed">- //                  Equal, ChooseMember, Forall</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // SPACE: (max_element)/(8*sizeof(int))</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+ // element currently in them.</span>
  
  //------------------------------VectorSet--------------------------------------
<span class="udiff-line-modified-removed">- class VectorSet : public Set {</span>
<span class="udiff-line-modified-removed">- friend class VectorSetI;        // Friendly iterator class</span>
<span class="udiff-line-modified-removed">- protected:</span>
<span class="udiff-line-modified-removed">-   uint size;                    // Size of data IN LONGWORDS (32bits)</span>
<span class="udiff-line-modified-removed">-   uint32_t* data;               // The data, bit packed</span>
<span class="udiff-line-modified-added">+ class VectorSet : public ResourceObj {</span>
<span class="udiff-line-modified-added">+ private:</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   static const uint word_bits = 5;</span>
<span class="udiff-line-modified-added">+   static const uint bit_mask  = 31;</span>
  
<span class="udiff-line-modified-removed">-   void slamin( const VectorSet&amp; s );     // Initialize one set with another</span>
<span class="udiff-line-modified-removed">-   int compare(const VectorSet &amp;s) const; // Compare set contents</span>
<span class="udiff-line-modified-removed">-   void grow(uint newsize);               // Grow vector to required bitsize</span>
<span class="udiff-line-modified-added">+   // Used 32-bit words</span>
<span class="udiff-line-modified-added">+   uint       _size;</span>
<span class="udiff-line-modified-added">+   uint32_t*  _data;</span>
<span class="udiff-line-added">+   // Allocated words</span>
<span class="udiff-line-added">+   uint       _data_size;</span>
<span class="udiff-line-added">+   Arena*     _set_arena;</span>
  
<span class="udiff-line-added">+   // Grow vector to required word capacity</span>
<span class="udiff-line-added">+   void grow(uint new_word_capacity);</span>
  public:
<span class="udiff-line-modified-removed">-   VectorSet(Arena *arena);                      // Creates a new, empty set.</span>
<span class="udiff-line-removed">-   VectorSet(const VectorSet &amp;s) : Set(s._set_arena) {slamin(s);} // Set clone; deep-copy guts</span>
<span class="udiff-line-removed">-   Set &amp;operator =(const Set &amp;s);                // Set clone; deep-copy guts</span>
<span class="udiff-line-removed">-   VectorSet &amp;operator =(const VectorSet &amp;s)     // Set clone; deep-copy guts</span>
<span class="udiff-line-removed">-   { if( &amp;s != this ) { slamin(s); } return *this; }</span>
<span class="udiff-line-modified-added">+   VectorSet(Arena *arena);</span>
    ~VectorSet() {}
<span class="udiff-line-removed">-   Set &amp;clone(void) const { return *(new VectorSet(*this)); }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   Set &amp;operator &lt;&lt;=(uint elem);          // Add member to set</span>
<span class="udiff-line-removed">-   VectorSet operator &lt;&lt; (uint elem)      // Add member to new set</span>
<span class="udiff-line-removed">-   { VectorSet foo(*this); foo &lt;&lt;= elem; return foo; }</span>
<span class="udiff-line-removed">-   Set &amp;operator &gt;&gt;=(uint elem);          // Delete member from set</span>
<span class="udiff-line-removed">-   VectorSet operator &gt;&gt; (uint elem)      // Delete member from new set</span>
<span class="udiff-line-removed">-   { VectorSet foo(*this); foo &gt;&gt;= elem; return foo; }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   VectorSet &amp;operator &amp;=(const VectorSet &amp;s); // Intersect sets into first set</span>
<span class="udiff-line-removed">-   Set       &amp;operator &amp;=(const Set       &amp;s); // Intersect sets into first set</span>
<span class="udiff-line-removed">-   VectorSet operator &amp; (const VectorSet &amp;s) const</span>
<span class="udiff-line-removed">-   { VectorSet foo(*this); foo &amp;= s; return foo; }</span>
  
<span class="udiff-line-modified-removed">-   VectorSet &amp;operator |=(const VectorSet &amp;s); // Intersect sets into first set</span>
<span class="udiff-line-modified-removed">-   Set       &amp;operator |=(const Set       &amp;s); // Intersect sets into first set</span>
<span class="udiff-line-modified-removed">-   VectorSet operator | (const VectorSet &amp;s) const</span>
<span class="udiff-line-modified-removed">-   { VectorSet foo(*this); foo |= s; return foo; }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   VectorSet &amp;operator -=(const VectorSet &amp;s); // Intersect sets into first set</span>
<span class="udiff-line-modified-removed">-   Set       &amp;operator -=(const Set       &amp;s); // Intersect sets into first set</span>
<span class="udiff-line-removed">-   VectorSet operator - (const VectorSet &amp;s) const</span>
<span class="udiff-line-removed">-   { VectorSet foo(*this); foo -= s; return foo; }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   int operator ==(const VectorSet &amp;s) const;  // True if sets are equal</span>
<span class="udiff-line-removed">-   int operator ==(const Set       &amp;s) const;  // True if sets are equal</span>
<span class="udiff-line-removed">-   int operator &lt; (const VectorSet &amp;s) const;  // True if strict subset</span>
<span class="udiff-line-removed">-   int operator &lt; (const Set       &amp;s) const;  // True if strict subset</span>
<span class="udiff-line-removed">-   int operator &lt;=(const VectorSet &amp;s) const;  // True if subset relation holds.</span>
<span class="udiff-line-removed">-   int operator &lt;=(const Set       &amp;s) const;  // True if subset relation holds.</span>
<span class="udiff-line-removed">-   int disjoint   (const Set       &amp;s) const;  // True if sets are disjoint</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   int operator [](uint elem) const; // Test for membership</span>
<span class="udiff-line-removed">-   void Clear(void);                 // Clear a set</span>
<span class="udiff-line-removed">-   uint Size(void) const;            // Number of elements in the Set.</span>
<span class="udiff-line-removed">-   void Sort(void);                  // Sort before iterating</span>
<span class="udiff-line-removed">-   int hash() const;                 // Hash function</span>
<span class="udiff-line-removed">-   void Reset(void) {                // Reset a set</span>
<span class="udiff-line-removed">-     memset( data, 0, size*sizeof(uint32_t) );</span>
<span class="udiff-line-modified-added">+   void insert(uint elem);</span>
<span class="udiff-line-modified-added">+   bool is_empty() const;</span>
<span class="udiff-line-modified-added">+   void reset() {</span>
<span class="udiff-line-modified-added">+     _size = 0;</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   void clear() {</span>
<span class="udiff-line-modified-added">+     reset();</span>
    }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   /* Removed for MCC BUG</span>
<span class="udiff-line-removed">-      operator const VectorSet* (void) const { return this; } */</span>
<span class="udiff-line-removed">-   const VectorSet *asVectorSet() const { return this; }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Expose internals for speed-critical fast iterators</span>
<span class="udiff-line-removed">-   uint word_size() const { return size; }</span>
  
    // Fast inlined &quot;test and set&quot;.  Replaces the idiom:
<span class="udiff-line-modified-removed">-   //     if( visited[idx] ) return;</span>
<span class="udiff-line-modified-removed">-   //     visited &lt;&lt;= idx;</span>
<span class="udiff-line-modified-added">+   //     if (visited.test(idx)) return;</span>
<span class="udiff-line-modified-added">+   //     visited.set(idx);</span>
    // With:
<span class="udiff-line-modified-removed">-   //     if( visited.test_set(idx) ) return;</span>
<span class="udiff-line-modified-added">+   //     if (visited.test_set(idx)) return;</span>
    //
<span class="udiff-line-modified-removed">-   int test_set( uint elem ) {</span>
<span class="udiff-line-modified-removed">-     uint word = elem &gt;&gt; 5;           // Get the longword offset</span>
<span class="udiff-line-modified-removed">-     if( word &gt;= size )               // Beyond the last?</span>
<span class="udiff-line-modified-removed">-       return test_set_grow(elem);    // Then grow; set; return 0;</span>
<span class="udiff-line-modified-removed">-     uint32_t mask = 1L &lt;&lt; (elem &amp; 31); // Get bit mask</span>
<span class="udiff-line-modified-removed">-     uint32_t datum = data[word] &amp; mask;// Get bit</span>
<span class="udiff-line-modified-removed">-     data[word] |= mask;              // Set bit</span>
<span class="udiff-line-modified-removed">-     return datum;                    // Return bit</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">-   int test_set_grow( uint elem ) {    // Insert &amp; return 0;</span>
<span class="udiff-line-removed">-     (*this) &lt;&lt;= elem;                 // Insert into set</span>
<span class="udiff-line-removed">-     return 0;                         // Return 0!</span>
<span class="udiff-line-modified-added">+   bool test_set(uint elem) {</span>
<span class="udiff-line-modified-added">+     uint32_t word = elem &gt;&gt; word_bits;</span>
<span class="udiff-line-modified-added">+     if (word &gt;= _size) {</span>
<span class="udiff-line-modified-added">+       // Then grow</span>
<span class="udiff-line-modified-added">+       grow(word);</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+     uint32_t mask = 1U &lt;&lt; (elem &amp; bit_mask);</span>
<span class="udiff-line-modified-added">+     uint32_t data = _data[word];</span>
<span class="udiff-line-modified-added">+     _data[word] = data | mask;</span>
<span class="udiff-line-modified-added">+     return (data &amp; mask) != 0;</span>
    }
  
    // Fast inlined test
<span class="udiff-line-modified-removed">-   int test( uint elem ) const {</span>
<span class="udiff-line-modified-removed">-     uint word = elem &gt;&gt; 5;      // Get the longword offset</span>
<span class="udiff-line-modified-removed">-     if( word &gt;= size ) return 0; // Beyond the last?</span>
<span class="udiff-line-modified-removed">-     uint32_t mask = 1L &lt;&lt; (elem &amp; 31); // Get bit mask</span>
<span class="udiff-line-modified-removed">-     return data[word] &amp; mask;   // Get bit</span>
<span class="udiff-line-modified-added">+   bool test(uint elem) const {</span>
<span class="udiff-line-modified-added">+     uint32_t word = elem &gt;&gt; word_bits;</span>
<span class="udiff-line-modified-added">+     if (word &gt;= _size) {</span>
<span class="udiff-line-modified-added">+       return false;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-added">+     uint32_t mask = 1U &lt;&lt; (elem &amp; bit_mask);</span>
<span class="udiff-line-added">+     return (_data[word] &amp; mask) != 0;</span>
    }
  
<span class="udiff-line-modified-removed">-   // Fast inlined set</span>
<span class="udiff-line-modified-removed">-   void set( uint elem ) {</span>
<span class="udiff-line-modified-removed">-     uint word = elem &gt;&gt; 5;      // Get the longword offset</span>
<span class="udiff-line-modified-removed">-     if( word &gt;= size ) {        // Beyond the last?</span>
<span class="udiff-line-removed">-       test_set_grow(elem);      // Then grow and set</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       uint32_t mask = 1L &lt;&lt; (elem &amp; 31); // Get bit mask</span>
<span class="udiff-line-removed">-       data[word] |= mask;       // Set bit</span>
<span class="udiff-line-modified-added">+   void remove(uint elem) {</span>
<span class="udiff-line-modified-added">+     uint32_t word = elem &gt;&gt; word_bits;</span>
<span class="udiff-line-modified-added">+     if (word &gt;= _size) {</span>
<span class="udiff-line-modified-added">+       return;</span>
      }
<span class="udiff-line-added">+     uint32_t mask = 1U &lt;&lt; (elem &amp; bit_mask);</span>
<span class="udiff-line-added">+     _data[word] &amp;= ~mask; // Clear bit</span>
    }
  
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- private:</span>
<span class="udiff-line-modified-removed">-   SetI_ *iterate(uint&amp;) const;</span>
<span class="udiff-line-modified-removed">- };</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- //------------------------------Iteration--------------------------------------</span>
<span class="udiff-line-modified-removed">- // Loop thru all elements of the set, setting &quot;elem&quot; to the element numbers</span>
<span class="udiff-line-modified-removed">- // in random order.  Inserted or deleted elements during this operation may</span>
<span class="udiff-line-removed">- // or may not be iterated over; untouched elements will be affected once.</span>
<span class="udiff-line-removed">- // Usage:  for( VectorSetI i(s); i.test(); i++ ) { body = i.elem; }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- class VectorSetI : public StackObj {</span>
<span class="udiff-line-removed">-   friend class VectorSet;</span>
<span class="udiff-line-removed">-   const VectorSet *s;</span>
<span class="udiff-line-removed">-   uint i, j;</span>
<span class="udiff-line-removed">-   uint32_t mask;</span>
<span class="udiff-line-removed">-   uint next(void);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- public:</span>
<span class="udiff-line-removed">-   uint elem;                    // The publically accessible element</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   VectorSetI( const VectorSet *vset ) :</span>
<span class="udiff-line-removed">-     s(vset),</span>
<span class="udiff-line-removed">-     i((uint)-1L),</span>
<span class="udiff-line-removed">-     j((uint)-1L),</span>
<span class="udiff-line-removed">-     mask((unsigned)(1L&lt;&lt;31)) {</span>
<span class="udiff-line-removed">-     elem = next();</span>
<span class="udiff-line-modified-added">+   // Fast inlined set</span>
<span class="udiff-line-modified-added">+   void set(uint elem) {</span>
<span class="udiff-line-modified-added">+     uint32_t word = elem &gt;&gt; word_bits;</span>
<span class="udiff-line-modified-added">+     if (word &gt;= _size) {</span>
<span class="udiff-line-modified-added">+       grow(word);</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+     uint32_t mask = 1U &lt;&lt; (elem &amp; bit_mask);</span>
<span class="udiff-line-modified-added">+     _data[word] |= mask;</span>
    }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   void operator ++(void) { elem = next(); }</span>
<span class="udiff-line-removed">-   int test(void) { return i &lt; s-&gt;size; }</span>
  };
  
  #endif // SHARE_LIBADT_VECTSET_HPP
</pre>
<center><a href="vectset.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../logging/logConfiguration.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
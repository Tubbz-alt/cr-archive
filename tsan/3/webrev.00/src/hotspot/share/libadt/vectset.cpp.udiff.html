<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/libadt/vectset.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="dict.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vectset.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/libadt/vectset.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -24,342 +24,47 @@</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;libadt/vectset.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/arena.hpp&quot;
<span class="udiff-line-added">+ #include &quot;utilities/count_leading_zeros.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
<span class="udiff-line-modified-removed">- // Vector Sets - An Abstract Data Type</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- // BitsInByte is a lookup table which tells the number of bits that</span>
<span class="udiff-line-modified-removed">- // are in the looked-up number.  It is very useful in VectorSet_Size.</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- uint8_t bitsInByte[BITS_IN_BYTE_ARRAY_SIZE] = {</span>
<span class="udiff-line-removed">-   0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,</span>
<span class="udiff-line-removed">-   1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,</span>
<span class="udiff-line-removed">-   1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,</span>
<span class="udiff-line-removed">-   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,</span>
<span class="udiff-line-removed">-   1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,</span>
<span class="udiff-line-removed">-   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,</span>
<span class="udiff-line-removed">-   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,</span>
<span class="udiff-line-removed">-   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,</span>
<span class="udiff-line-removed">-   1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,</span>
<span class="udiff-line-removed">-   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,</span>
<span class="udiff-line-removed">-   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,</span>
<span class="udiff-line-removed">-   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,</span>
<span class="udiff-line-removed">-   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,</span>
<span class="udiff-line-removed">-   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,</span>
<span class="udiff-line-removed">-   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,</span>
<span class="udiff-line-removed">-   4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8</span>
<span class="udiff-line-removed">- };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- //------------------------------VectorSet--------------------------------------</span>
<span class="udiff-line-removed">- // Create a new, empty Set.</span>
<span class="udiff-line-removed">- VectorSet::VectorSet(Arena *arena) : Set(arena) {</span>
<span class="udiff-line-removed">-   size = 2;                     // Small initial size</span>
<span class="udiff-line-removed">-   data = (uint32_t *)_set_arena-&gt;Amalloc(size*sizeof(uint32_t));</span>
<span class="udiff-line-removed">-   data[0] = 0;                  // No elements</span>
<span class="udiff-line-removed">-   data[1] = 0;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- //------------------------------operator=--------------------------------------</span>
<span class="udiff-line-removed">- Set &amp;VectorSet::operator = (const Set &amp;set)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   if( &amp;set == this ) return *this;</span>
<span class="udiff-line-removed">-   FREE_FAST(data);</span>
<span class="udiff-line-removed">-   // The cast is a virtual function that checks that &quot;set&quot; is a VectorSet.</span>
<span class="udiff-line-removed">-   slamin(*(set.asVectorSet()));</span>
<span class="udiff-line-removed">-   return *this;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- //------------------------------slamin-----------------------------------------</span>
<span class="udiff-line-removed">- // Initialize one set with another.  No regard is made to the existing Set.</span>
<span class="udiff-line-removed">- void VectorSet::slamin(const VectorSet&amp; s)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   size = s.size;                // Use new size</span>
<span class="udiff-line-removed">-   data = (uint32_t*)s._set_arena-&gt;Amalloc(size*sizeof(uint32_t)); // Make array of required size</span>
<span class="udiff-line-removed">-   memcpy( data, s.data, size*sizeof(uint32_t) ); // Fill the array</span>
<span class="udiff-line-modified-added">+ VectorSet::VectorSet(Arena *arena) : _size(2),</span>
<span class="udiff-line-modified-added">+     _data(NEW_ARENA_ARRAY(arena, uint32_t, 2)),</span>
<span class="udiff-line-modified-added">+     _data_size(2),</span>
<span class="udiff-line-modified-added">+     _set_arena(arena) {</span>
<span class="udiff-line-modified-added">+   _data[0] = 0;</span>
<span class="udiff-line-modified-added">+   _data[1] = 0;</span>
  }
  
<span class="udiff-line-removed">- //------------------------------grow-------------------------------------------</span>
  // Expand the existing set to a bigger size
<span class="udiff-line-modified-removed">- void VectorSet::grow( uint newsize )</span>
<span class="udiff-line-modified-removed">- {</span>
<span class="udiff-line-modified-removed">-   newsize = (newsize+31) &gt;&gt; 5;  // Convert to longwords</span>
<span class="udiff-line-modified-removed">-   uint x = size;</span>
<span class="udiff-line-modified-removed">-   while( x &lt; newsize ) x &lt;&lt;= 1;</span>
<span class="udiff-line-modified-removed">-   data = (uint32_t *)_set_arena-&gt;Arealloc(data, size*sizeof(uint32_t), x*sizeof(uint32_t));</span>
<span class="udiff-line-removed">-   memset((char *)(data + size), 0, (x - size)*sizeof(uint32_t));</span>
<span class="udiff-line-removed">-   size = x;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- //------------------------------operator&lt;&lt;=------------------------------------</span>
<span class="udiff-line-removed">- // Insert a member into an existing Set.</span>
<span class="udiff-line-removed">- Set &amp;VectorSet::operator &lt;&lt;= (uint elem)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   uint word = elem &gt;&gt; 5;            // Get the longword offset</span>
<span class="udiff-line-removed">-   uint32_t mask = 1L &lt;&lt; (elem &amp; 31);  // Get bit mask</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if( word &gt;= size )            // Need to grow set?</span>
<span class="udiff-line-removed">-     grow(elem+1);               // Then grow it</span>
<span class="udiff-line-removed">-   data[word] |= mask;           // Set new bit</span>
<span class="udiff-line-removed">-   return *this;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- //------------------------------operator&gt;&gt;=------------------------------------</span>
<span class="udiff-line-removed">- // Delete a member from an existing Set.</span>
<span class="udiff-line-removed">- Set &amp;VectorSet::operator &gt;&gt;= (uint elem)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   uint word = elem &gt;&gt; 5;          // Get the longword offset</span>
<span class="udiff-line-removed">-   if( word &gt;= size )              // Beyond the last?</span>
<span class="udiff-line-removed">-     return *this;                 // Then it&#39;s clear &amp; return clear</span>
<span class="udiff-line-removed">-   uint32_t mask = 1L &lt;&lt; (elem &amp; 31);     // Get bit mask</span>
<span class="udiff-line-removed">-   data[word] &amp;= ~mask;            // Clear bit</span>
<span class="udiff-line-removed">-   return *this;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- //------------------------------operator&amp;=-------------------------------------</span>
<span class="udiff-line-removed">- // Intersect one set into another.</span>
<span class="udiff-line-removed">- VectorSet &amp;VectorSet::operator &amp;= (const VectorSet &amp;s)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   // NOTE: The intersection is never any larger than the smallest set.</span>
<span class="udiff-line-removed">-   if( s.size &lt; size ) size = s.size; // Get smaller size</span>
<span class="udiff-line-removed">-   uint32_t *u1 = data;          // Pointer to the destination data</span>
<span class="udiff-line-removed">-   uint32_t *u2 = s.data;        // Pointer to the source data</span>
<span class="udiff-line-removed">-   for( uint i=0; i&lt;size; i++)   // For data in set</span>
<span class="udiff-line-removed">-     *u1++ &amp;= *u2++;             // Copy and AND longwords</span>
<span class="udiff-line-removed">-   return *this;                 // Return set</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- //------------------------------operator&amp;=-------------------------------------</span>
<span class="udiff-line-removed">- Set &amp;VectorSet::operator &amp;= (const Set &amp;set)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   // The cast is a virtual function that checks that &quot;set&quot; is a VectorSet.</span>
<span class="udiff-line-removed">-   return (*this) &amp;= *(set.asVectorSet());</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- //------------------------------operator|=-------------------------------------</span>
<span class="udiff-line-removed">- // Union one set into another.</span>
<span class="udiff-line-removed">- VectorSet &amp;VectorSet::operator |= (const VectorSet &amp;s)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   // This many words must be unioned</span>
<span class="udiff-line-removed">-   uint cnt = ((size&lt;s.size)?size:s.size);</span>
<span class="udiff-line-removed">-   uint32_t *u1 = data;          // Pointer to the destination data</span>
<span class="udiff-line-removed">-   uint32_t *u2 = s.data;        // Pointer to the source data</span>
<span class="udiff-line-removed">-   for( uint i=0; i&lt;cnt; i++)    // Copy and OR the two sets</span>
<span class="udiff-line-removed">-     *u1++ |= *u2++;</span>
<span class="udiff-line-removed">-   if( size &lt; s.size ) {         // Is set 2 larger than set 1?</span>
<span class="udiff-line-removed">-     // Extend result by larger set</span>
<span class="udiff-line-removed">-     grow(s.size*sizeof(uint32_t)*8);</span>
<span class="udiff-line-removed">-     memcpy(&amp;data[cnt], u2, (s.size - cnt)*sizeof(uint32_t));</span>
<span class="udiff-line-modified-added">+ void VectorSet::grow(uint new_word_capacity) {</span>
<span class="udiff-line-modified-added">+   assert(new_word_capacity &lt; (1U &lt;&lt; 30), &quot;&quot;);</span>
<span class="udiff-line-modified-added">+   uint x = next_power_of_2(new_word_capacity);</span>
<span class="udiff-line-modified-added">+   if (x &gt; _data_size) {</span>
<span class="udiff-line-modified-added">+     _data = REALLOC_ARENA_ARRAY(_set_arena, uint32_t, _data, _size, x);</span>
<span class="udiff-line-modified-added">+     _data_size = x;</span>
    }
<span class="udiff-line-modified-removed">-   return *this;                 // Return result set</span>
<span class="udiff-line-modified-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- //------------------------------operator|=-------------------------------------</span>
<span class="udiff-line-removed">- Set &amp;VectorSet::operator |= (const Set &amp;set)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   // The cast is a virtual function that checks that &quot;set&quot; is a VectorSet.</span>
<span class="udiff-line-removed">-   return (*this) |= *(set.asVectorSet());</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- //------------------------------operator-=-------------------------------------</span>
<span class="udiff-line-removed">- // Difference one set from another.</span>
<span class="udiff-line-removed">- VectorSet &amp;VectorSet::operator -= (const VectorSet &amp;s)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   // This many words must be unioned</span>
<span class="udiff-line-removed">-   uint cnt = ((size&lt;s.size)?size:s.size);</span>
<span class="udiff-line-removed">-   uint32_t *u1 = data;          // Pointer to the destination data</span>
<span class="udiff-line-removed">-   uint32_t *u2 = s.data;        // Pointer to the source data</span>
<span class="udiff-line-removed">-   for( uint i=0; i&lt;cnt; i++ )   // For data in set</span>
<span class="udiff-line-removed">-     *u1++ &amp;= ~(*u2++);          // A &lt;-- A &amp; ~B  with longwords</span>
<span class="udiff-line-removed">-   return *this;                 // Return new set</span>
<span class="udiff-line-modified-added">+   Copy::zero_to_bytes(_data + _size, (x - _size) * sizeof(uint32_t));</span>
<span class="udiff-line-modified-added">+   _size = x;</span>
  }
  
<span class="udiff-line-modified-removed">- //------------------------------operator-=-------------------------------------</span>
<span class="udiff-line-modified-removed">- Set &amp;VectorSet::operator -= (const Set &amp;set)</span>
<span class="udiff-line-modified-removed">- {</span>
<span class="udiff-line-modified-removed">-   // The cast is a virtual function that checks that &quot;set&quot; is a VectorSet.</span>
<span class="udiff-line-modified-removed">-   return (*this) -= *(set.asVectorSet());</span>
<span class="udiff-line-modified-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- //------------------------------compare----------------------------------------</span>
<span class="udiff-line-removed">- // Compute 2 booleans: bits in A not B, bits in B not A.</span>
<span class="udiff-line-removed">- // Return X0 --  A is not a subset of B</span>
<span class="udiff-line-removed">- //        X1 --  A is a subset of B</span>
<span class="udiff-line-removed">- //        0X --  B is not a subset of A</span>
<span class="udiff-line-removed">- //        1X --  B is a subset of A</span>
<span class="udiff-line-removed">- int VectorSet::compare (const VectorSet &amp;s) const</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   uint32_t *u1 = data;          // Pointer to the destination data</span>
<span class="udiff-line-removed">-   uint32_t *u2 = s.data;        // Pointer to the source data</span>
<span class="udiff-line-removed">-   uint32_t AnotB = 0, BnotA = 0;</span>
<span class="udiff-line-removed">-   // This many words must be unioned</span>
<span class="udiff-line-removed">-   uint cnt = ((size&lt;s.size)?size:s.size);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Get bits for both sets</span>
<span class="udiff-line-removed">-   uint i;                       // Exit value of loop</span>
<span class="udiff-line-removed">-   for( i=0; i&lt;cnt; i++ ) {      // For data in BOTH sets</span>
<span class="udiff-line-removed">-     uint32_t A = *u1++;         // Data from one guy</span>
<span class="udiff-line-removed">-     uint32_t B = *u2++;         // Data from other guy</span>
<span class="udiff-line-removed">-     AnotB |= (A &amp; ~B);          // Compute bits in A not B</span>
<span class="udiff-line-removed">-     BnotA |= (B &amp; ~A);          // Compute bits in B not A</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Get bits from bigger set</span>
<span class="udiff-line-removed">-   if( size &lt; s.size ) {</span>
<span class="udiff-line-removed">-     for( ; i&lt;s.size; i++ )      // For data in larger set</span>
<span class="udiff-line-removed">-       BnotA |= *u2++;           // These bits are in B not A</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     for( ; i&lt;size; i++ )        // For data in larger set</span>
<span class="udiff-line-removed">-       AnotB |= *u1++;           // These bits are in A not B</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Set &amp; return boolean flags</span>
<span class="udiff-line-removed">-   return ((!BnotA)&lt;&lt;1) + (!AnotB);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- //------------------------------operator==-------------------------------------</span>
<span class="udiff-line-removed">- // Test for set equality</span>
<span class="udiff-line-removed">- int VectorSet::operator == (const VectorSet &amp;s) const</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   return compare(s) == 3;       // TRUE if A and B are mutual subsets</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- //------------------------------operator==-------------------------------------</span>
<span class="udiff-line-removed">- int VectorSet::operator == (const Set &amp;set) const</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   // The cast is a virtual function that checks that &quot;set&quot; is a VectorSet.</span>
<span class="udiff-line-removed">-   return (*this) == *(set.asVectorSet());</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- //------------------------------disjoint---------------------------------------</span>
<span class="udiff-line-removed">- // Check for sets being disjoint.</span>
<span class="udiff-line-removed">- int VectorSet::disjoint(const Set &amp;set) const</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   // The cast is a virtual function that checks that &quot;set&quot; is a VectorSet.</span>
<span class="udiff-line-removed">-   const VectorSet &amp;s = *(set.asVectorSet());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // NOTE: The intersection is never any larger than the smallest set.</span>
<span class="udiff-line-removed">-   uint small_size = ((size&lt;s.size)?size:s.size);</span>
<span class="udiff-line-removed">-   uint32_t *u1 = data;               // Pointer to the destination data</span>
<span class="udiff-line-removed">-   uint32_t *u2 = s.data;             // Pointer to the source data</span>
<span class="udiff-line-removed">-   for( uint i=0; i&lt;small_size; i++)  // For data in set</span>
<span class="udiff-line-removed">-     if( *u1++ &amp; *u2++ )              // If any elements in common</span>
<span class="udiff-line-removed">-       return 0;                      // Then not disjoint</span>
<span class="udiff-line-removed">-   return 1;                          // Else disjoint</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- //------------------------------operator&lt;--------------------------------------</span>
<span class="udiff-line-removed">- // Test for strict subset</span>
<span class="udiff-line-removed">- int VectorSet::operator &lt; (const VectorSet &amp;s) const</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   return compare(s) == 1;       // A subset B, B not subset A</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- //------------------------------operator&lt;--------------------------------------</span>
<span class="udiff-line-removed">- int VectorSet::operator &lt; (const Set &amp;set) const</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   // The cast is a virtual function that checks that &quot;set&quot; is a VectorSet.</span>
<span class="udiff-line-removed">-   return (*this) &lt; *(set.asVectorSet());</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- //------------------------------operator&lt;=-------------------------------------</span>
<span class="udiff-line-removed">- // Test for subset</span>
<span class="udiff-line-removed">- int VectorSet::operator &lt;= (const VectorSet &amp;s) const</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   return compare(s) &amp; 1;        // A subset B</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- //------------------------------operator&lt;=-------------------------------------</span>
<span class="udiff-line-removed">- int VectorSet::operator &lt;= (const Set &amp;set) const</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   // The cast is a virtual function that checks that &quot;set&quot; is a VectorSet.</span>
<span class="udiff-line-removed">-   return (*this) &lt;= *(set.asVectorSet());</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- //------------------------------operator[]-------------------------------------</span>
<span class="udiff-line-removed">- // Test for membership.  A Zero/Non-Zero value is returned!</span>
<span class="udiff-line-removed">- int VectorSet::operator[](uint elem) const</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   uint word = elem &gt;&gt; 5;              // Get the longword offset</span>
<span class="udiff-line-removed">-   if( word &gt;= size )                  // Beyond the last?</span>
<span class="udiff-line-removed">-     return 0;                         // Then it&#39;s clear</span>
<span class="udiff-line-removed">-   uint32_t mask = 1L &lt;&lt; (elem &amp; 31);  // Get bit mask</span>
<span class="udiff-line-removed">-   return ((data[word] &amp; mask))!=0;    // Return the sense of the bit</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- //------------------------------Clear------------------------------------------</span>
<span class="udiff-line-removed">- // Clear a set</span>
<span class="udiff-line-removed">- void VectorSet::Clear(void)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   if( size &gt; 100 ) {            // Reclaim storage only if huge</span>
<span class="udiff-line-removed">-     FREE_RESOURCE_ARRAY(uint32_t,data,size);</span>
<span class="udiff-line-removed">-     size = 2;                   // Small initial size</span>
<span class="udiff-line-removed">-     data = NEW_RESOURCE_ARRAY(uint32_t,size);</span>
<span class="udiff-line-modified-added">+ // Insert a member into an existing Set.</span>
<span class="udiff-line-modified-added">+ void VectorSet::insert(uint elem) {</span>
<span class="udiff-line-modified-added">+   uint32_t word = elem &gt;&gt; word_bits;</span>
<span class="udiff-line-modified-added">+   uint32_t mask = 1U &lt;&lt; (elem &amp; bit_mask);</span>
<span class="udiff-line-modified-added">+   if (word &gt;= _size) {</span>
<span class="udiff-line-modified-added">+     grow(word);</span>
    }
<span class="udiff-line-modified-removed">-   memset( data, 0, size*sizeof(uint32_t) );</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- //------------------------------Size-------------------------------------------</span>
<span class="udiff-line-removed">- // Return number of elements in a Set</span>
<span class="udiff-line-removed">- uint VectorSet::Size(void) const</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   uint sum = 0;                 // Cumulative size so far.</span>
<span class="udiff-line-removed">-   uint8_t* currByte = (uint8_t*) data;</span>
<span class="udiff-line-removed">-   for( uint32_t i = 0; i &lt; (size&lt;&lt;2); i++) // While have bytes to process</span>
<span class="udiff-line-removed">-     sum += bitsInByte[*currByte++];      // Add bits in current byte to size.</span>
<span class="udiff-line-removed">-   return sum;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- //------------------------------Sort-------------------------------------------</span>
<span class="udiff-line-removed">- // Sort the elements for the next forall statement</span>
<span class="udiff-line-removed">- void VectorSet::Sort(void)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-modified-added">+   _data[word] |= mask;</span>
  }
  
<span class="udiff-line-modified-removed">- //------------------------------hash-------------------------------------------</span>
<span class="udiff-line-modified-removed">- int VectorSet::hash() const</span>
<span class="udiff-line-modified-removed">- {</span>
<span class="udiff-line-modified-removed">-   uint32_t _xor = 0;</span>
<span class="udiff-line-modified-removed">-   uint lim = ((size&lt;4)?size:4);</span>
<span class="udiff-line-removed">-   for( uint i = 0; i &lt; lim; i++ )</span>
<span class="udiff-line-removed">-     _xor ^= data[i];</span>
<span class="udiff-line-removed">-   return (int)_xor;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- //------------------------------iterate----------------------------------------</span>
<span class="udiff-line-removed">- // Used by Set::print().</span>
<span class="udiff-line-removed">- class VSetI_ : public SetI_ {</span>
<span class="udiff-line-removed">-   VectorSetI vsi;</span>
<span class="udiff-line-removed">- public:</span>
<span class="udiff-line-removed">-   VSetI_( const VectorSet *vset, uint &amp;elem ) : vsi(vset) { elem = vsi.elem; }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   uint next(void) { ++vsi; return vsi.elem; }</span>
<span class="udiff-line-removed">-   int  test(void) { return vsi.test(); }</span>
<span class="udiff-line-removed">- };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- SetI_ *VectorSet::iterate(uint &amp;elem) const {</span>
<span class="udiff-line-removed">-   return new(ResourceObj::C_HEAP, mtInternal) VSetI_(this, elem);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- //=============================================================================</span>
<span class="udiff-line-removed">- //------------------------------next-------------------------------------------</span>
<span class="udiff-line-removed">- // Find and return the next element of a vector set, or return garbage and</span>
<span class="udiff-line-removed">- // make &quot;VectorSetI::test()&quot; fail.</span>
<span class="udiff-line-removed">- uint VectorSetI::next(void)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   j++;                          // Next element in word</span>
<span class="udiff-line-removed">-   mask = (mask &amp; max_jint) &lt;&lt; 1;// Next bit in word</span>
<span class="udiff-line-removed">-   do {                          // Do While still have words</span>
<span class="udiff-line-removed">-     while( mask ) {             // While have bits in word</span>
<span class="udiff-line-removed">-       if( s-&gt;data[i] &amp; mask ) { // If found a bit</span>
<span class="udiff-line-removed">-         return (i&lt;&lt;5)+j;        // Return the bit address</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       j++;                      // Skip to next bit</span>
<span class="udiff-line-removed">-       mask = (mask &amp; max_jint) &lt;&lt; 1;</span>
<span class="udiff-line-modified-added">+ // Return true if the set is empty</span>
<span class="udiff-line-modified-added">+ bool VectorSet::is_empty() const {</span>
<span class="udiff-line-modified-added">+   for (uint32_t i = 0; i &lt; _size; i++) {</span>
<span class="udiff-line-modified-added">+     if (_data[i] != 0) {</span>
<span class="udiff-line-modified-added">+       return false;</span>
      }
<span class="udiff-line-modified-removed">-     j = 0;                      // No more bits in word; setup for next word</span>
<span class="udiff-line-modified-removed">-     mask = 1;</span>
<span class="udiff-line-removed">-     for( i++; (i&lt;s-&gt;size) &amp;&amp; (!s-&gt;data[i]); i++ ); // Skip to non-zero word</span>
<span class="udiff-line-removed">-   } while( i&lt;s-&gt;size );</span>
<span class="udiff-line-removed">-   return max_juint;             // No element, iterated them all</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   return true;</span>
  }
</pre>
<center><a href="dict.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vectset.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
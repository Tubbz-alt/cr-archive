<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/libadt/dict.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../jvmci/vmSymbols_jvmci.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vectset.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/libadt/dict.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;libadt/dict.hpp&quot;

 27 
 28 // Dictionaries - An Abstract Data Type
 29 
 30 // %%%%% includes not needed with AVM framework - Ungar
 31 
 32 #include &lt;assert.h&gt;
 33 
 34 //------------------------------data-----------------------------------------
 35 // String hash tables
 36 #define MAXID 20
<span class="line-removed"> 37 static uint8_t initflag = 0;       // True after 1st initialization</span>
 38 static const char shft[MAXID] = {1,2,3,4,5,6,7,1,2,3,4,5,6,7,1,2,3,4,5,6};
<span class="line-modified"> 39 static short xsum[MAXID];</span>





 40 
 41 //------------------------------bucket---------------------------------------
 42 class bucket : public ResourceObj {
 43 public:
 44   uint _cnt, _max;              // Size of bucket
 45   void **_keyvals;              // Array of keys and values
 46 };
 47 
 48 //------------------------------Dict-----------------------------------------
 49 // The dictionary is kept has a hash table.  The hash table is a even power
 50 // of two, for nice modulo operations.  Each bucket in the hash table points
 51 // to a linear list of key-value pairs; each key &amp; value is just a (void *).
 52 // The list starts with a count.  A hash lookup finds the list head, then a
 53 // simple linear scan finds the key.  If the table gets too full, it&#39;s
 54 // doubled in size; the total amount of EXTRA times all hash functions are
 55 // computed for the doubling is no more than the current size - thus the
 56 // doubling in size costs no more than a constant factor in speed.
 57 Dict::Dict(CmpKey initcmp, Hash inithash) : _arena(Thread::current()-&gt;resource_area()),
 58   _hash(inithash), _cmp(initcmp) {
<span class="line-removed"> 59   int i;</span>
<span class="line-removed"> 60 </span>
<span class="line-removed"> 61   // Precompute table of null character hashes</span>
<span class="line-removed"> 62   if( !initflag ) {             // Not initializated yet?</span>
<span class="line-removed"> 63     xsum[0] = (1&lt;&lt;shft[0])+1;   // Initialize</span>
<span class="line-removed"> 64     for(i=1; i&lt;MAXID; i++) {</span>
<span class="line-removed"> 65       xsum[i] = (1&lt;&lt;shft[i])+1+xsum[i-1];</span>
<span class="line-removed"> 66     }</span>
<span class="line-removed"> 67     initflag = 1;               // Never again</span>
<span class="line-removed"> 68   }</span>
 69 
 70   _size = 16;                   // Size is a power of 2
 71   _cnt = 0;                     // Dictionary is empty
 72   _bin = (bucket*)_arena-&gt;Amalloc_4(sizeof(bucket)*_size);
 73   memset((void*)_bin,0,sizeof(bucket)*_size);
 74 }
 75 
 76 Dict::Dict(CmpKey initcmp, Hash inithash, Arena *arena, int size)
 77 : _arena(arena), _hash(inithash), _cmp(initcmp) {
<span class="line-modified"> 78   int i;</span>
<span class="line-modified"> 79 </span>
<span class="line-removed"> 80   // Precompute table of null character hashes</span>
<span class="line-removed"> 81   if( !initflag ) {             // Not initializated yet?</span>
<span class="line-removed"> 82     xsum[0] = (1&lt;&lt;shft[0])+1;   // Initialize</span>
<span class="line-removed"> 83     for(i=1; i&lt;MAXID; i++) {</span>
<span class="line-removed"> 84       xsum[i] = (1&lt;&lt;shft[i])+1+xsum[i-1];</span>
<span class="line-removed"> 85     }</span>
<span class="line-removed"> 86     initflag = 1;               // Never again</span>
<span class="line-removed"> 87   }</span>
 88 
<span class="line-removed"> 89   i=16;</span>
<span class="line-removed"> 90   while( i &lt; size ) i &lt;&lt;= 1;</span>
<span class="line-removed"> 91   _size = i;                    // Size is a power of 2</span>
 92   _cnt = 0;                     // Dictionary is empty
 93   _bin = (bucket*)_arena-&gt;Amalloc_4(sizeof(bucket)*_size);
 94   memset((void*)_bin,0,sizeof(bucket)*_size);
 95 }
 96 
 97 //------------------------------~Dict------------------------------------------
 98 // Delete an existing dictionary.
 99 Dict::~Dict() {
100   /*
101   tty-&gt;print(&quot;~Dict %d/%d: &quot;,_cnt,_size);
102   for( uint i=0; i &lt; _size; i++) // For complete new table do
103     tty-&gt;print(&quot;%d &quot;,_bin[i]._cnt);
104   tty-&gt;print(&quot;\n&quot;);*/
105   /*for( uint i=0; i&lt;_size; i++ ) {
106     FREE_FAST( _bin[i]._keyvals );
107     } */
108 }
109 
110 //------------------------------Clear----------------------------------------
111 // Zap to empty; ready for re-use
</pre>
<hr />
<pre>
293   tty-&gt;print_cr(&quot;}&quot;);
294 }
295 
296 //------------------------------Hashing Functions----------------------------
297 // Convert string to hash key.  This algorithm implements a universal hash
298 // function with the multipliers frozen (ok, so it&#39;s not universal).  The
299 // multipliers (and allowable characters) are all odd, so the resultant sum
300 // is odd - guaranteed not divisible by any power of two, so the hash tables
301 // can be any power of two with good results.  Also, I choose multipliers
302 // that have only 2 bits set (the low is always set to be odd) so
303 // multiplication requires only shifts and adds.  Characters are required to
304 // be in the range 0-127 (I double &amp; add 1 to force oddness).  Keys are
305 // limited to MAXID characters in length.  Experimental evidence on 150K of
306 // C text shows excellent spreading of values for any size hash table.
307 int hashstr(const void *t) {
308   char c, k = 0;
309   int32_t sum = 0;
310   const char *s = (const char *)t;
311 
312   while( ((c = *s++) != &#39;\0&#39;) &amp;&amp; (k &lt; MAXID-1) ) { // Get characters till null or MAXID-1
<span class="line-modified">313     c = (c&lt;&lt;1)+1;               // Characters are always odd!</span>
<span class="line-modified">314     sum += c + (c&lt;&lt;shft[k++]);  // Universal hash function</span>
315   }
<span class="line-modified">316   return (int)((sum+xsum[k]) &gt;&gt; 1); // Hash key, un-modulo&#39;d table size</span>
317 }
318 
319 //------------------------------hashptr--------------------------------------
320 // Slimey cheap hash function; no guaranteed performance.  Better than the
321 // default for pointers, especially on MS-DOS machines.
322 int hashptr(const void *key) {
323   return ((intptr_t)key &gt;&gt; 2);
324 }
325 
326 // Slimey cheap hash function; no guaranteed performance.
327 int hashkey(const void *key) {
328   return (intptr_t)key;
329 }
330 
331 //------------------------------Key Comparator Functions---------------------
332 int32_t cmpstr(const void *k1, const void *k2) {
333   return strcmp((const char *)k1,(const char *)k2);
334 }
335 
336 // Cheap key comparator.
</pre>
</td>
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;libadt/dict.hpp&quot;
<span class="line-added"> 27 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
 28 
 29 // Dictionaries - An Abstract Data Type
 30 
 31 // %%%%% includes not needed with AVM framework - Ungar
 32 
 33 #include &lt;assert.h&gt;
 34 
 35 //------------------------------data-----------------------------------------
 36 // String hash tables
 37 #define MAXID 20

 38 static const char shft[MAXID] = {1,2,3,4,5,6,7,1,2,3,4,5,6,7,1,2,3,4,5,6};
<span class="line-modified"> 39 // Precomputed table of null character hashes</span>
<span class="line-added"> 40 // xsum[0] = (1 &lt;&lt; shft[0]) + 1;</span>
<span class="line-added"> 41 // for(int i = 1; i &lt; MAXID; i++) {</span>
<span class="line-added"> 42 //   xsum[i] = (1 &lt;&lt; shft[i]) + 1 + xsum[i - 1];</span>
<span class="line-added"> 43 // }</span>
<span class="line-added"> 44 static const short xsum[MAXID] = {3,8,17,34,67,132,261,264,269,278,295,328,393,522,525,530,539,556,589,654};</span>
 45 
 46 //------------------------------bucket---------------------------------------
 47 class bucket : public ResourceObj {
 48 public:
 49   uint _cnt, _max;              // Size of bucket
 50   void **_keyvals;              // Array of keys and values
 51 };
 52 
 53 //------------------------------Dict-----------------------------------------
 54 // The dictionary is kept has a hash table.  The hash table is a even power
 55 // of two, for nice modulo operations.  Each bucket in the hash table points
 56 // to a linear list of key-value pairs; each key &amp; value is just a (void *).
 57 // The list starts with a count.  A hash lookup finds the list head, then a
 58 // simple linear scan finds the key.  If the table gets too full, it&#39;s
 59 // doubled in size; the total amount of EXTRA times all hash functions are
 60 // computed for the doubling is no more than the current size - thus the
 61 // doubling in size costs no more than a constant factor in speed.
 62 Dict::Dict(CmpKey initcmp, Hash inithash) : _arena(Thread::current()-&gt;resource_area()),
 63   _hash(inithash), _cmp(initcmp) {










 64 
 65   _size = 16;                   // Size is a power of 2
 66   _cnt = 0;                     // Dictionary is empty
 67   _bin = (bucket*)_arena-&gt;Amalloc_4(sizeof(bucket)*_size);
 68   memset((void*)_bin,0,sizeof(bucket)*_size);
 69 }
 70 
 71 Dict::Dict(CmpKey initcmp, Hash inithash, Arena *arena, int size)
 72 : _arena(arena), _hash(inithash), _cmp(initcmp) {
<span class="line-modified"> 73   // Size is a power of 2</span>
<span class="line-modified"> 74   _size = MAX2(16, round_up_power_of_2(size));</span>








 75 



 76   _cnt = 0;                     // Dictionary is empty
 77   _bin = (bucket*)_arena-&gt;Amalloc_4(sizeof(bucket)*_size);
 78   memset((void*)_bin,0,sizeof(bucket)*_size);
 79 }
 80 
 81 //------------------------------~Dict------------------------------------------
 82 // Delete an existing dictionary.
 83 Dict::~Dict() {
 84   /*
 85   tty-&gt;print(&quot;~Dict %d/%d: &quot;,_cnt,_size);
 86   for( uint i=0; i &lt; _size; i++) // For complete new table do
 87     tty-&gt;print(&quot;%d &quot;,_bin[i]._cnt);
 88   tty-&gt;print(&quot;\n&quot;);*/
 89   /*for( uint i=0; i&lt;_size; i++ ) {
 90     FREE_FAST( _bin[i]._keyvals );
 91     } */
 92 }
 93 
 94 //------------------------------Clear----------------------------------------
 95 // Zap to empty; ready for re-use
</pre>
<hr />
<pre>
277   tty-&gt;print_cr(&quot;}&quot;);
278 }
279 
280 //------------------------------Hashing Functions----------------------------
281 // Convert string to hash key.  This algorithm implements a universal hash
282 // function with the multipliers frozen (ok, so it&#39;s not universal).  The
283 // multipliers (and allowable characters) are all odd, so the resultant sum
284 // is odd - guaranteed not divisible by any power of two, so the hash tables
285 // can be any power of two with good results.  Also, I choose multipliers
286 // that have only 2 bits set (the low is always set to be odd) so
287 // multiplication requires only shifts and adds.  Characters are required to
288 // be in the range 0-127 (I double &amp; add 1 to force oddness).  Keys are
289 // limited to MAXID characters in length.  Experimental evidence on 150K of
290 // C text shows excellent spreading of values for any size hash table.
291 int hashstr(const void *t) {
292   char c, k = 0;
293   int32_t sum = 0;
294   const char *s = (const char *)t;
295 
296   while( ((c = *s++) != &#39;\0&#39;) &amp;&amp; (k &lt; MAXID-1) ) { // Get characters till null or MAXID-1
<span class="line-modified">297     c = (c &lt;&lt; 1) + 1;             // Characters are always odd!</span>
<span class="line-modified">298     sum += c + (c &lt;&lt; shft[k++]);  // Universal hash function</span>
299   }
<span class="line-modified">300   return (int)((sum + xsum[k]) &gt;&gt; 1); // Hash key, un-modulo&#39;d table size</span>
301 }
302 
303 //------------------------------hashptr--------------------------------------
304 // Slimey cheap hash function; no guaranteed performance.  Better than the
305 // default for pointers, especially on MS-DOS machines.
306 int hashptr(const void *key) {
307   return ((intptr_t)key &gt;&gt; 2);
308 }
309 
310 // Slimey cheap hash function; no guaranteed performance.
311 int hashkey(const void *key) {
312   return (intptr_t)key;
313 }
314 
315 //------------------------------Key Comparator Functions---------------------
316 int32_t cmpstr(const void *k1, const void *k2) {
317   return strcmp((const char *)k1,(const char *)k2);
318 }
319 
320 // Cheap key comparator.
</pre>
</td>
</tr>
</table>
<center><a href="../jvmci/vmSymbols_jvmci.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vectset.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
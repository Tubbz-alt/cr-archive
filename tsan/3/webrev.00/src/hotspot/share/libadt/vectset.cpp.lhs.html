<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/libadt/vectset.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;libadt/vectset.hpp&quot;
 27 #include &quot;memory/allocation.inline.hpp&quot;
 28 #include &quot;memory/arena.hpp&quot;
<a name="1" id="anc1"></a>

 29 
<a name="2" id="anc2"></a><span class="line-modified"> 30 // Vector Sets - An Abstract Data Type</span>
<span class="line-modified"> 31 </span>
<span class="line-modified"> 32 // BitsInByte is a lookup table which tells the number of bits that</span>
<span class="line-modified"> 33 // are in the looked-up number.  It is very useful in VectorSet_Size.</span>
<span class="line-modified"> 34 </span>
<span class="line-modified"> 35 uint8_t bitsInByte[BITS_IN_BYTE_ARRAY_SIZE] = {</span>
<span class="line-removed"> 36   0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,</span>
<span class="line-removed"> 37   1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,</span>
<span class="line-removed"> 38   1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,</span>
<span class="line-removed"> 39   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,</span>
<span class="line-removed"> 40   1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,</span>
<span class="line-removed"> 41   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,</span>
<span class="line-removed"> 42   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,</span>
<span class="line-removed"> 43   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,</span>
<span class="line-removed"> 44   1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,</span>
<span class="line-removed"> 45   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,</span>
<span class="line-removed"> 46   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,</span>
<span class="line-removed"> 47   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,</span>
<span class="line-removed"> 48   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,</span>
<span class="line-removed"> 49   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,</span>
<span class="line-removed"> 50   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,</span>
<span class="line-removed"> 51   4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8</span>
<span class="line-removed"> 52 };</span>
<span class="line-removed"> 53 </span>
<span class="line-removed"> 54 //------------------------------VectorSet--------------------------------------</span>
<span class="line-removed"> 55 // Create a new, empty Set.</span>
<span class="line-removed"> 56 VectorSet::VectorSet(Arena *arena) : Set(arena) {</span>
<span class="line-removed"> 57   size = 2;                     // Small initial size</span>
<span class="line-removed"> 58   data = (uint32_t *)_set_arena-&gt;Amalloc(size*sizeof(uint32_t));</span>
<span class="line-removed"> 59   data[0] = 0;                  // No elements</span>
<span class="line-removed"> 60   data[1] = 0;</span>
<span class="line-removed"> 61 }</span>
<span class="line-removed"> 62 </span>
<span class="line-removed"> 63 //------------------------------operator=--------------------------------------</span>
<span class="line-removed"> 64 Set &amp;VectorSet::operator = (const Set &amp;set)</span>
<span class="line-removed"> 65 {</span>
<span class="line-removed"> 66   if( &amp;set == this ) return *this;</span>
<span class="line-removed"> 67   FREE_FAST(data);</span>
<span class="line-removed"> 68   // The cast is a virtual function that checks that &quot;set&quot; is a VectorSet.</span>
<span class="line-removed"> 69   slamin(*(set.asVectorSet()));</span>
<span class="line-removed"> 70   return *this;</span>
<span class="line-removed"> 71 }</span>
<span class="line-removed"> 72 </span>
<span class="line-removed"> 73 //------------------------------slamin-----------------------------------------</span>
<span class="line-removed"> 74 // Initialize one set with another.  No regard is made to the existing Set.</span>
<span class="line-removed"> 75 void VectorSet::slamin(const VectorSet&amp; s)</span>
<span class="line-removed"> 76 {</span>
<span class="line-removed"> 77   size = s.size;                // Use new size</span>
<span class="line-removed"> 78   data = (uint32_t*)s._set_arena-&gt;Amalloc(size*sizeof(uint32_t)); // Make array of required size</span>
<span class="line-removed"> 79   memcpy( data, s.data, size*sizeof(uint32_t) ); // Fill the array</span>
 80 }
 81 
<a name="3" id="anc3"></a><span class="line-removed"> 82 //------------------------------grow-------------------------------------------</span>
 83 // Expand the existing set to a bigger size
<a name="4" id="anc4"></a><span class="line-modified"> 84 void VectorSet::grow( uint newsize )</span>
<span class="line-modified"> 85 {</span>
<span class="line-modified"> 86   newsize = (newsize+31) &gt;&gt; 5;  // Convert to longwords</span>
<span class="line-modified"> 87   uint x = size;</span>
<span class="line-modified"> 88   while( x &lt; newsize ) x &lt;&lt;= 1;</span>
<span class="line-modified"> 89   data = (uint32_t *)_set_arena-&gt;Arealloc(data, size*sizeof(uint32_t), x*sizeof(uint32_t));</span>
<span class="line-removed"> 90   memset((char *)(data + size), 0, (x - size)*sizeof(uint32_t));</span>
<span class="line-removed"> 91   size = x;</span>
<span class="line-removed"> 92 }</span>
<span class="line-removed"> 93 </span>
<span class="line-removed"> 94 //------------------------------operator&lt;&lt;=------------------------------------</span>
<span class="line-removed"> 95 // Insert a member into an existing Set.</span>
<span class="line-removed"> 96 Set &amp;VectorSet::operator &lt;&lt;= (uint elem)</span>
<span class="line-removed"> 97 {</span>
<span class="line-removed"> 98   uint word = elem &gt;&gt; 5;            // Get the longword offset</span>
<span class="line-removed"> 99   uint32_t mask = 1L &lt;&lt; (elem &amp; 31);  // Get bit mask</span>
<span class="line-removed">100 </span>
<span class="line-removed">101   if( word &gt;= size )            // Need to grow set?</span>
<span class="line-removed">102     grow(elem+1);               // Then grow it</span>
<span class="line-removed">103   data[word] |= mask;           // Set new bit</span>
<span class="line-removed">104   return *this;</span>
<span class="line-removed">105 }</span>
<span class="line-removed">106 </span>
<span class="line-removed">107 //------------------------------operator&gt;&gt;=------------------------------------</span>
<span class="line-removed">108 // Delete a member from an existing Set.</span>
<span class="line-removed">109 Set &amp;VectorSet::operator &gt;&gt;= (uint elem)</span>
<span class="line-removed">110 {</span>
<span class="line-removed">111   uint word = elem &gt;&gt; 5;          // Get the longword offset</span>
<span class="line-removed">112   if( word &gt;= size )              // Beyond the last?</span>
<span class="line-removed">113     return *this;                 // Then it&#39;s clear &amp; return clear</span>
<span class="line-removed">114   uint32_t mask = 1L &lt;&lt; (elem &amp; 31);     // Get bit mask</span>
<span class="line-removed">115   data[word] &amp;= ~mask;            // Clear bit</span>
<span class="line-removed">116   return *this;</span>
<span class="line-removed">117 }</span>
<span class="line-removed">118 </span>
<span class="line-removed">119 //------------------------------operator&amp;=-------------------------------------</span>
<span class="line-removed">120 // Intersect one set into another.</span>
<span class="line-removed">121 VectorSet &amp;VectorSet::operator &amp;= (const VectorSet &amp;s)</span>
<span class="line-removed">122 {</span>
<span class="line-removed">123   // NOTE: The intersection is never any larger than the smallest set.</span>
<span class="line-removed">124   if( s.size &lt; size ) size = s.size; // Get smaller size</span>
<span class="line-removed">125   uint32_t *u1 = data;          // Pointer to the destination data</span>
<span class="line-removed">126   uint32_t *u2 = s.data;        // Pointer to the source data</span>
<span class="line-removed">127   for( uint i=0; i&lt;size; i++)   // For data in set</span>
<span class="line-removed">128     *u1++ &amp;= *u2++;             // Copy and AND longwords</span>
<span class="line-removed">129   return *this;                 // Return set</span>
<span class="line-removed">130 }</span>
<span class="line-removed">131 </span>
<span class="line-removed">132 //------------------------------operator&amp;=-------------------------------------</span>
<span class="line-removed">133 Set &amp;VectorSet::operator &amp;= (const Set &amp;set)</span>
<span class="line-removed">134 {</span>
<span class="line-removed">135   // The cast is a virtual function that checks that &quot;set&quot; is a VectorSet.</span>
<span class="line-removed">136   return (*this) &amp;= *(set.asVectorSet());</span>
<span class="line-removed">137 }</span>
<span class="line-removed">138 </span>
<span class="line-removed">139 //------------------------------operator|=-------------------------------------</span>
<span class="line-removed">140 // Union one set into another.</span>
<span class="line-removed">141 VectorSet &amp;VectorSet::operator |= (const VectorSet &amp;s)</span>
<span class="line-removed">142 {</span>
<span class="line-removed">143   // This many words must be unioned</span>
<span class="line-removed">144   uint cnt = ((size&lt;s.size)?size:s.size);</span>
<span class="line-removed">145   uint32_t *u1 = data;          // Pointer to the destination data</span>
<span class="line-removed">146   uint32_t *u2 = s.data;        // Pointer to the source data</span>
<span class="line-removed">147   for( uint i=0; i&lt;cnt; i++)    // Copy and OR the two sets</span>
<span class="line-removed">148     *u1++ |= *u2++;</span>
<span class="line-removed">149   if( size &lt; s.size ) {         // Is set 2 larger than set 1?</span>
<span class="line-removed">150     // Extend result by larger set</span>
<span class="line-removed">151     grow(s.size*sizeof(uint32_t)*8);</span>
<span class="line-removed">152     memcpy(&amp;data[cnt], u2, (s.size - cnt)*sizeof(uint32_t));</span>
153   }
<a name="5" id="anc5"></a><span class="line-modified">154   return *this;                 // Return result set</span>
<span class="line-modified">155 }</span>
<span class="line-removed">156 </span>
<span class="line-removed">157 //------------------------------operator|=-------------------------------------</span>
<span class="line-removed">158 Set &amp;VectorSet::operator |= (const Set &amp;set)</span>
<span class="line-removed">159 {</span>
<span class="line-removed">160   // The cast is a virtual function that checks that &quot;set&quot; is a VectorSet.</span>
<span class="line-removed">161   return (*this) |= *(set.asVectorSet());</span>
<span class="line-removed">162 }</span>
<span class="line-removed">163 </span>
<span class="line-removed">164 //------------------------------operator-=-------------------------------------</span>
<span class="line-removed">165 // Difference one set from another.</span>
<span class="line-removed">166 VectorSet &amp;VectorSet::operator -= (const VectorSet &amp;s)</span>
<span class="line-removed">167 {</span>
<span class="line-removed">168   // This many words must be unioned</span>
<span class="line-removed">169   uint cnt = ((size&lt;s.size)?size:s.size);</span>
<span class="line-removed">170   uint32_t *u1 = data;          // Pointer to the destination data</span>
<span class="line-removed">171   uint32_t *u2 = s.data;        // Pointer to the source data</span>
<span class="line-removed">172   for( uint i=0; i&lt;cnt; i++ )   // For data in set</span>
<span class="line-removed">173     *u1++ &amp;= ~(*u2++);          // A &lt;-- A &amp; ~B  with longwords</span>
<span class="line-removed">174   return *this;                 // Return new set</span>
175 }
176 
<a name="6" id="anc6"></a><span class="line-modified">177 //------------------------------operator-=-------------------------------------</span>
<span class="line-modified">178 Set &amp;VectorSet::operator -= (const Set &amp;set)</span>
<span class="line-modified">179 {</span>
<span class="line-modified">180   // The cast is a virtual function that checks that &quot;set&quot; is a VectorSet.</span>
<span class="line-modified">181   return (*this) -= *(set.asVectorSet());</span>
<span class="line-modified">182 }</span>
<span class="line-removed">183 </span>
<span class="line-removed">184 //------------------------------compare----------------------------------------</span>
<span class="line-removed">185 // Compute 2 booleans: bits in A not B, bits in B not A.</span>
<span class="line-removed">186 // Return X0 --  A is not a subset of B</span>
<span class="line-removed">187 //        X1 --  A is a subset of B</span>
<span class="line-removed">188 //        0X --  B is not a subset of A</span>
<span class="line-removed">189 //        1X --  B is a subset of A</span>
<span class="line-removed">190 int VectorSet::compare (const VectorSet &amp;s) const</span>
<span class="line-removed">191 {</span>
<span class="line-removed">192   uint32_t *u1 = data;          // Pointer to the destination data</span>
<span class="line-removed">193   uint32_t *u2 = s.data;        // Pointer to the source data</span>
<span class="line-removed">194   uint32_t AnotB = 0, BnotA = 0;</span>
<span class="line-removed">195   // This many words must be unioned</span>
<span class="line-removed">196   uint cnt = ((size&lt;s.size)?size:s.size);</span>
<span class="line-removed">197 </span>
<span class="line-removed">198   // Get bits for both sets</span>
<span class="line-removed">199   uint i;                       // Exit value of loop</span>
<span class="line-removed">200   for( i=0; i&lt;cnt; i++ ) {      // For data in BOTH sets</span>
<span class="line-removed">201     uint32_t A = *u1++;         // Data from one guy</span>
<span class="line-removed">202     uint32_t B = *u2++;         // Data from other guy</span>
<span class="line-removed">203     AnotB |= (A &amp; ~B);          // Compute bits in A not B</span>
<span class="line-removed">204     BnotA |= (B &amp; ~A);          // Compute bits in B not A</span>
<span class="line-removed">205   }</span>
<span class="line-removed">206 </span>
<span class="line-removed">207   // Get bits from bigger set</span>
<span class="line-removed">208   if( size &lt; s.size ) {</span>
<span class="line-removed">209     for( ; i&lt;s.size; i++ )      // For data in larger set</span>
<span class="line-removed">210       BnotA |= *u2++;           // These bits are in B not A</span>
<span class="line-removed">211   } else {</span>
<span class="line-removed">212     for( ; i&lt;size; i++ )        // For data in larger set</span>
<span class="line-removed">213       AnotB |= *u1++;           // These bits are in A not B</span>
<span class="line-removed">214   }</span>
<span class="line-removed">215 </span>
<span class="line-removed">216   // Set &amp; return boolean flags</span>
<span class="line-removed">217   return ((!BnotA)&lt;&lt;1) + (!AnotB);</span>
<span class="line-removed">218 }</span>
<span class="line-removed">219 </span>
<span class="line-removed">220 //------------------------------operator==-------------------------------------</span>
<span class="line-removed">221 // Test for set equality</span>
<span class="line-removed">222 int VectorSet::operator == (const VectorSet &amp;s) const</span>
<span class="line-removed">223 {</span>
<span class="line-removed">224   return compare(s) == 3;       // TRUE if A and B are mutual subsets</span>
<span class="line-removed">225 }</span>
<span class="line-removed">226 </span>
<span class="line-removed">227 //------------------------------operator==-------------------------------------</span>
<span class="line-removed">228 int VectorSet::operator == (const Set &amp;set) const</span>
<span class="line-removed">229 {</span>
<span class="line-removed">230   // The cast is a virtual function that checks that &quot;set&quot; is a VectorSet.</span>
<span class="line-removed">231   return (*this) == *(set.asVectorSet());</span>
<span class="line-removed">232 }</span>
<span class="line-removed">233 </span>
<span class="line-removed">234 //------------------------------disjoint---------------------------------------</span>
<span class="line-removed">235 // Check for sets being disjoint.</span>
<span class="line-removed">236 int VectorSet::disjoint(const Set &amp;set) const</span>
<span class="line-removed">237 {</span>
<span class="line-removed">238   // The cast is a virtual function that checks that &quot;set&quot; is a VectorSet.</span>
<span class="line-removed">239   const VectorSet &amp;s = *(set.asVectorSet());</span>
<span class="line-removed">240 </span>
<span class="line-removed">241   // NOTE: The intersection is never any larger than the smallest set.</span>
<span class="line-removed">242   uint small_size = ((size&lt;s.size)?size:s.size);</span>
<span class="line-removed">243   uint32_t *u1 = data;               // Pointer to the destination data</span>
<span class="line-removed">244   uint32_t *u2 = s.data;             // Pointer to the source data</span>
<span class="line-removed">245   for( uint i=0; i&lt;small_size; i++)  // For data in set</span>
<span class="line-removed">246     if( *u1++ &amp; *u2++ )              // If any elements in common</span>
<span class="line-removed">247       return 0;                      // Then not disjoint</span>
<span class="line-removed">248   return 1;                          // Else disjoint</span>
<span class="line-removed">249 }</span>
<span class="line-removed">250 </span>
<span class="line-removed">251 //------------------------------operator&lt;--------------------------------------</span>
<span class="line-removed">252 // Test for strict subset</span>
<span class="line-removed">253 int VectorSet::operator &lt; (const VectorSet &amp;s) const</span>
<span class="line-removed">254 {</span>
<span class="line-removed">255   return compare(s) == 1;       // A subset B, B not subset A</span>
<span class="line-removed">256 }</span>
<span class="line-removed">257 </span>
<span class="line-removed">258 //------------------------------operator&lt;--------------------------------------</span>
<span class="line-removed">259 int VectorSet::operator &lt; (const Set &amp;set) const</span>
<span class="line-removed">260 {</span>
<span class="line-removed">261   // The cast is a virtual function that checks that &quot;set&quot; is a VectorSet.</span>
<span class="line-removed">262   return (*this) &lt; *(set.asVectorSet());</span>
<span class="line-removed">263 }</span>
<span class="line-removed">264 </span>
<span class="line-removed">265 //------------------------------operator&lt;=-------------------------------------</span>
<span class="line-removed">266 // Test for subset</span>
<span class="line-removed">267 int VectorSet::operator &lt;= (const VectorSet &amp;s) const</span>
<span class="line-removed">268 {</span>
<span class="line-removed">269   return compare(s) &amp; 1;        // A subset B</span>
<span class="line-removed">270 }</span>
<span class="line-removed">271 </span>
<span class="line-removed">272 //------------------------------operator&lt;=-------------------------------------</span>
<span class="line-removed">273 int VectorSet::operator &lt;= (const Set &amp;set) const</span>
<span class="line-removed">274 {</span>
<span class="line-removed">275   // The cast is a virtual function that checks that &quot;set&quot; is a VectorSet.</span>
<span class="line-removed">276   return (*this) &lt;= *(set.asVectorSet());</span>
<span class="line-removed">277 }</span>
<span class="line-removed">278 </span>
<span class="line-removed">279 //------------------------------operator[]-------------------------------------</span>
<span class="line-removed">280 // Test for membership.  A Zero/Non-Zero value is returned!</span>
<span class="line-removed">281 int VectorSet::operator[](uint elem) const</span>
<span class="line-removed">282 {</span>
<span class="line-removed">283   uint word = elem &gt;&gt; 5;              // Get the longword offset</span>
<span class="line-removed">284   if( word &gt;= size )                  // Beyond the last?</span>
<span class="line-removed">285     return 0;                         // Then it&#39;s clear</span>
<span class="line-removed">286   uint32_t mask = 1L &lt;&lt; (elem &amp; 31);  // Get bit mask</span>
<span class="line-removed">287   return ((data[word] &amp; mask))!=0;    // Return the sense of the bit</span>
<span class="line-removed">288 }</span>
<span class="line-removed">289 </span>
<span class="line-removed">290 //------------------------------Clear------------------------------------------</span>
<span class="line-removed">291 // Clear a set</span>
<span class="line-removed">292 void VectorSet::Clear(void)</span>
<span class="line-removed">293 {</span>
<span class="line-removed">294   if( size &gt; 100 ) {            // Reclaim storage only if huge</span>
<span class="line-removed">295     FREE_RESOURCE_ARRAY(uint32_t,data,size);</span>
<span class="line-removed">296     size = 2;                   // Small initial size</span>
<span class="line-removed">297     data = NEW_RESOURCE_ARRAY(uint32_t,size);</span>
298   }
<a name="7" id="anc7"></a><span class="line-modified">299   memset( data, 0, size*sizeof(uint32_t) );</span>
<span class="line-removed">300 }</span>
<span class="line-removed">301 </span>
<span class="line-removed">302 //------------------------------Size-------------------------------------------</span>
<span class="line-removed">303 // Return number of elements in a Set</span>
<span class="line-removed">304 uint VectorSet::Size(void) const</span>
<span class="line-removed">305 {</span>
<span class="line-removed">306   uint sum = 0;                 // Cumulative size so far.</span>
<span class="line-removed">307   uint8_t* currByte = (uint8_t*) data;</span>
<span class="line-removed">308   for( uint32_t i = 0; i &lt; (size&lt;&lt;2); i++) // While have bytes to process</span>
<span class="line-removed">309     sum += bitsInByte[*currByte++];      // Add bits in current byte to size.</span>
<span class="line-removed">310   return sum;</span>
<span class="line-removed">311 }</span>
<span class="line-removed">312 </span>
<span class="line-removed">313 //------------------------------Sort-------------------------------------------</span>
<span class="line-removed">314 // Sort the elements for the next forall statement</span>
<span class="line-removed">315 void VectorSet::Sort(void)</span>
<span class="line-removed">316 {</span>
317 }
318 
<a name="8" id="anc8"></a><span class="line-modified">319 //------------------------------hash-------------------------------------------</span>
<span class="line-modified">320 int VectorSet::hash() const</span>
<span class="line-modified">321 {</span>
<span class="line-modified">322   uint32_t _xor = 0;</span>
<span class="line-modified">323   uint lim = ((size&lt;4)?size:4);</span>
<span class="line-removed">324   for( uint i = 0; i &lt; lim; i++ )</span>
<span class="line-removed">325     _xor ^= data[i];</span>
<span class="line-removed">326   return (int)_xor;</span>
<span class="line-removed">327 }</span>
<span class="line-removed">328 </span>
<span class="line-removed">329 //------------------------------iterate----------------------------------------</span>
<span class="line-removed">330 // Used by Set::print().</span>
<span class="line-removed">331 class VSetI_ : public SetI_ {</span>
<span class="line-removed">332   VectorSetI vsi;</span>
<span class="line-removed">333 public:</span>
<span class="line-removed">334   VSetI_( const VectorSet *vset, uint &amp;elem ) : vsi(vset) { elem = vsi.elem; }</span>
<span class="line-removed">335 </span>
<span class="line-removed">336   uint next(void) { ++vsi; return vsi.elem; }</span>
<span class="line-removed">337   int  test(void) { return vsi.test(); }</span>
<span class="line-removed">338 };</span>
<span class="line-removed">339 </span>
<span class="line-removed">340 SetI_ *VectorSet::iterate(uint &amp;elem) const {</span>
<span class="line-removed">341   return new(ResourceObj::C_HEAP, mtInternal) VSetI_(this, elem);</span>
<span class="line-removed">342 }</span>
<span class="line-removed">343 </span>
<span class="line-removed">344 //=============================================================================</span>
<span class="line-removed">345 //------------------------------next-------------------------------------------</span>
<span class="line-removed">346 // Find and return the next element of a vector set, or return garbage and</span>
<span class="line-removed">347 // make &quot;VectorSetI::test()&quot; fail.</span>
<span class="line-removed">348 uint VectorSetI::next(void)</span>
<span class="line-removed">349 {</span>
<span class="line-removed">350   j++;                          // Next element in word</span>
<span class="line-removed">351   mask = (mask &amp; max_jint) &lt;&lt; 1;// Next bit in word</span>
<span class="line-removed">352   do {                          // Do While still have words</span>
<span class="line-removed">353     while( mask ) {             // While have bits in word</span>
<span class="line-removed">354       if( s-&gt;data[i] &amp; mask ) { // If found a bit</span>
<span class="line-removed">355         return (i&lt;&lt;5)+j;        // Return the bit address</span>
<span class="line-removed">356       }</span>
<span class="line-removed">357       j++;                      // Skip to next bit</span>
<span class="line-removed">358       mask = (mask &amp; max_jint) &lt;&lt; 1;</span>
359     }
<a name="9" id="anc9"></a><span class="line-modified">360     j = 0;                      // No more bits in word; setup for next word</span>
<span class="line-modified">361     mask = 1;</span>
<span class="line-removed">362     for( i++; (i&lt;s-&gt;size) &amp;&amp; (!s-&gt;data[i]); i++ ); // Skip to non-zero word</span>
<span class="line-removed">363   } while( i&lt;s-&gt;size );</span>
<span class="line-removed">364   return max_juint;             // No element, iterated them all</span>
365 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
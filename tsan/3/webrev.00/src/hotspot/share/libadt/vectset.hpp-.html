<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/libadt/vectset.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_LIBADT_VECTSET_HPP
 26 #define SHARE_LIBADT_VECTSET_HPP
 27 
 28 #include &quot;libadt/set.hpp&quot;
 29 
 30 #define BITS_IN_BYTE_ARRAY_SIZE 256
 31 
 32 // Vector Sets - An Abstract Data Type
 33 //INTERFACE
 34 
 35 // These sets can grow or shrink, based on the initial size and the largest
 36 // element currently in them.  Slow and bulky for sparse sets, these sets
 37 // are super for dense sets.  They are fast and compact when dense.
 38 
 39 // TIME:
 40 // O(1) - Insert, Delete, Member, Sort
 41 // O(max_element) - Create, Clear, Size, Copy, Union, Intersect, Difference,
 42 //                  Equal, ChooseMember, Forall
 43 
 44 // SPACE: (max_element)/(8*sizeof(int))
 45 
 46 
 47 //------------------------------VectorSet--------------------------------------
 48 class VectorSet : public Set {
 49 friend class VectorSetI;        // Friendly iterator class
 50 protected:
 51   uint size;                    // Size of data IN LONGWORDS (32bits)
 52   uint32_t* data;               // The data, bit packed
 53 
 54   void slamin( const VectorSet&amp; s );     // Initialize one set with another
 55   int compare(const VectorSet &amp;s) const; // Compare set contents
 56   void grow(uint newsize);               // Grow vector to required bitsize
 57 
 58 public:
 59   VectorSet(Arena *arena);                      // Creates a new, empty set.
 60   VectorSet(const VectorSet &amp;s) : Set(s._set_arena) {slamin(s);} // Set clone; deep-copy guts
 61   Set &amp;operator =(const Set &amp;s);                // Set clone; deep-copy guts
 62   VectorSet &amp;operator =(const VectorSet &amp;s)     // Set clone; deep-copy guts
 63   { if( &amp;s != this ) { slamin(s); } return *this; }
 64   ~VectorSet() {}
 65   Set &amp;clone(void) const { return *(new VectorSet(*this)); }
 66 
 67   Set &amp;operator &lt;&lt;=(uint elem);          // Add member to set
 68   VectorSet operator &lt;&lt; (uint elem)      // Add member to new set
 69   { VectorSet foo(*this); foo &lt;&lt;= elem; return foo; }
 70   Set &amp;operator &gt;&gt;=(uint elem);          // Delete member from set
 71   VectorSet operator &gt;&gt; (uint elem)      // Delete member from new set
 72   { VectorSet foo(*this); foo &gt;&gt;= elem; return foo; }
 73 
 74   VectorSet &amp;operator &amp;=(const VectorSet &amp;s); // Intersect sets into first set
 75   Set       &amp;operator &amp;=(const Set       &amp;s); // Intersect sets into first set
 76   VectorSet operator &amp; (const VectorSet &amp;s) const
 77   { VectorSet foo(*this); foo &amp;= s; return foo; }
 78 
 79   VectorSet &amp;operator |=(const VectorSet &amp;s); // Intersect sets into first set
 80   Set       &amp;operator |=(const Set       &amp;s); // Intersect sets into first set
 81   VectorSet operator | (const VectorSet &amp;s) const
 82   { VectorSet foo(*this); foo |= s; return foo; }
 83 
 84   VectorSet &amp;operator -=(const VectorSet &amp;s); // Intersect sets into first set
 85   Set       &amp;operator -=(const Set       &amp;s); // Intersect sets into first set
 86   VectorSet operator - (const VectorSet &amp;s) const
 87   { VectorSet foo(*this); foo -= s; return foo; }
 88 
 89   int operator ==(const VectorSet &amp;s) const;  // True if sets are equal
 90   int operator ==(const Set       &amp;s) const;  // True if sets are equal
 91   int operator &lt; (const VectorSet &amp;s) const;  // True if strict subset
 92   int operator &lt; (const Set       &amp;s) const;  // True if strict subset
 93   int operator &lt;=(const VectorSet &amp;s) const;  // True if subset relation holds.
 94   int operator &lt;=(const Set       &amp;s) const;  // True if subset relation holds.
 95   int disjoint   (const Set       &amp;s) const;  // True if sets are disjoint
 96 
 97   int operator [](uint elem) const; // Test for membership
 98   void Clear(void);                 // Clear a set
 99   uint Size(void) const;            // Number of elements in the Set.
100   void Sort(void);                  // Sort before iterating
101   int hash() const;                 // Hash function
102   void Reset(void) {                // Reset a set
103     memset( data, 0, size*sizeof(uint32_t) );
104   }
105 
106   /* Removed for MCC BUG
107      operator const VectorSet* (void) const { return this; } */
108   const VectorSet *asVectorSet() const { return this; }
109 
110   // Expose internals for speed-critical fast iterators
111   uint word_size() const { return size; }
112 
113   // Fast inlined &quot;test and set&quot;.  Replaces the idiom:
114   //     if( visited[idx] ) return;
115   //     visited &lt;&lt;= idx;
116   // With:
117   //     if( visited.test_set(idx) ) return;
118   //
119   int test_set( uint elem ) {
120     uint word = elem &gt;&gt; 5;           // Get the longword offset
121     if( word &gt;= size )               // Beyond the last?
122       return test_set_grow(elem);    // Then grow; set; return 0;
123     uint32_t mask = 1L &lt;&lt; (elem &amp; 31); // Get bit mask
124     uint32_t datum = data[word] &amp; mask;// Get bit
125     data[word] |= mask;              // Set bit
126     return datum;                    // Return bit
127   }
128   int test_set_grow( uint elem ) {    // Insert &amp; return 0;
129     (*this) &lt;&lt;= elem;                 // Insert into set
130     return 0;                         // Return 0!
131   }
132 
133   // Fast inlined test
134   int test( uint elem ) const {
135     uint word = elem &gt;&gt; 5;      // Get the longword offset
136     if( word &gt;= size ) return 0; // Beyond the last?
137     uint32_t mask = 1L &lt;&lt; (elem &amp; 31); // Get bit mask
138     return data[word] &amp; mask;   // Get bit
139   }
140 
141   // Fast inlined set
142   void set( uint elem ) {
143     uint word = elem &gt;&gt; 5;      // Get the longword offset
144     if( word &gt;= size ) {        // Beyond the last?
145       test_set_grow(elem);      // Then grow and set
146     } else {
147       uint32_t mask = 1L &lt;&lt; (elem &amp; 31); // Get bit mask
148       data[word] |= mask;       // Set bit
149     }
150   }
151 
152 
153 private:
154   SetI_ *iterate(uint&amp;) const;
155 };
156 
157 //------------------------------Iteration--------------------------------------
158 // Loop thru all elements of the set, setting &quot;elem&quot; to the element numbers
159 // in random order.  Inserted or deleted elements during this operation may
160 // or may not be iterated over; untouched elements will be affected once.
161 // Usage:  for( VectorSetI i(s); i.test(); i++ ) { body = i.elem; }
162 
163 class VectorSetI : public StackObj {
164   friend class VectorSet;
165   const VectorSet *s;
166   uint i, j;
167   uint32_t mask;
168   uint next(void);
169 
170 public:
171   uint elem;                    // The publically accessible element
172 
173   VectorSetI( const VectorSet *vset ) :
174     s(vset),
175     i((uint)-1L),
176     j((uint)-1L),
177     mask((unsigned)(1L&lt;&lt;31)) {
178     elem = next();
179   }
180 
181   void operator ++(void) { elem = next(); }
182   int test(void) { return i &lt; s-&gt;size; }
183 };
184 
185 #endif // SHARE_LIBADT_VECTSET_HPP
    </pre>
  </body>
</html>
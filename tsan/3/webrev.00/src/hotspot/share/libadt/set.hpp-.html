<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/libadt/set.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_LIBADT_SET_HPP
 26 #define SHARE_LIBADT_SET_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 
 30 // Sets - An Abstract Data Type
 31 
 32 class SparseSet;
 33 class VectorSet;
 34 class ListSet;
 35 class CoSet;
 36 
 37 class ostream;
 38 class SetI_;
 39 
 40 // These sets can grow or shrink, based on the initial size and the largest
 41 // element currently in them.  Basically, they allow a bunch of bits to be
 42 // grouped together, tested, set &amp; cleared, intersected, etc.  The basic
 43 // Set class is an abstract class, and cannot be constructed.  Instead,
 44 // one of VectorSet, SparseSet, or ListSet is created.  Each variation has
 45 // different asymptotic running times for different operations, and different
 46 // constants of proportionality as well.
 47 // {n = number of elements, N = largest element}
 48 
 49 //              VectorSet       SparseSet       ListSet
 50 // Create       O(N)            O(1)            O(1)
 51 // Clear        O(N)            O(1)            O(1)
 52 // Insert       O(1)            O(1)            O(log n)
 53 // Delete       O(1)            O(1)            O(log n)
 54 // Member       O(1)            O(1)            O(log n)
 55 // Size         O(N)            O(1)            O(1)
 56 // Copy         O(N)            O(n)            O(n)
 57 // Union        O(N)            O(n)            O(n log n)
 58 // Intersect    O(N)            O(n)            O(n log n)
 59 // Difference   O(N)            O(n)            O(n log n)
 60 // Equal        O(N)            O(n)            O(n log n)
 61 // ChooseMember O(N)            O(1)            O(1)
 62 // Sort         O(1)            O(n log n)      O(1)
 63 // Forall       O(N)            O(n)            O(n)
 64 // Complement   O(1)            O(1)            O(1)
 65 
 66 // TIME:        N/32            n               8*n     Accesses
 67 // SPACE:       N/8             4*N+4*n         8*n     Bytes
 68 
 69 // Create:      Make an empty set
 70 // Clear:       Remove all the elements of a Set
 71 // Insert:      Insert an element into a Set; duplicates are ignored
 72 // Delete:      Removes an element from a Set
 73 // Member:      Tests for membership in a Set
 74 // Size:        Returns the number of members of a Set
 75 // Copy:        Copy or assign one Set to another
 76 // Union:       Union 2 sets together
 77 // Intersect:   Intersect 2 sets together
 78 // Difference:  Compute A &amp; !B; remove from set A those elements in set B
 79 // Equal:       Test for equality between 2 sets
 80 // ChooseMember Pick a random member
 81 // Sort:        If no other operation changes the set membership, a following
 82 //              Forall will iterate the members in ascending order.
 83 // Forall:      Iterate over the elements of a Set.  Operations that modify
 84 //              the set membership during iteration work, but the iterator may
 85 //              skip any member or duplicate any member.
 86 // Complement:  Only supported in the Co-Set variations.  It adds a small
 87 //              constant-time test to every Set operation.
 88 //
 89 // PERFORMANCE ISSUES:
 90 // If you &quot;cast away&quot; the specific set variation you are using, and then do
 91 // operations on the basic &quot;Set&quot; object you will pay a virtual function call
 92 // to get back the specific set variation.  On the other hand, using the
 93 // generic Set means you can change underlying implementations by just
 94 // changing the initial declaration.  Examples:
 95 //      void foo(VectorSet vs1, VectorSet vs2) { vs1 |= vs2; }
 96 // &quot;foo&quot; must be called with a VectorSet.  The vector set union operation
 97 // is called directly.
 98 //      void foo(Set vs1, Set vs2) { vs1 |= vs2; }
 99 // &quot;foo&quot; may be called with *any* kind of sets; suppose it is called with
100 // VectorSets.  Two virtual function calls are used to figure out the that vs1
101 // and vs2 are VectorSets.  In addition, if vs2 is not a VectorSet then a
102 // temporary VectorSet copy of vs2 will be made before the union proceeds.
103 //
104 // VectorSets have a small constant.  Time and space are proportional to the
105 //   largest element.  Fine for dense sets and largest element &lt; 10,000.
106 // SparseSets have a medium constant.  Time is proportional to the number of
107 //   elements, space is proportional to the largest element.
108 //   Fine (but big) with the largest element &lt; 100,000.
109 // ListSets have a big constant.  Time *and space* are proportional to the
110 //   number of elements.  They work well for a few elements of *any* size
111 //   (i.e. sets of pointers)!
112 
113 //------------------------------Set--------------------------------------------
114 class Set : public ResourceObj {
115  protected:
116 
117   // Creates a new, empty set.
118   Set(Arena *arena) : _set_arena(arena) {};
119 
120   // Creates a new set from an existing set
121   Set(const Set &amp; s) : ResourceObj(s) {};
122 
123  public:
124   // Set assignment; deep-copy guts
125   virtual Set &amp;operator =(const Set &amp;s)=0;
126   virtual Set &amp;clone(void) const=0;
127 
128   // Virtual destructor
129   virtual ~Set() {};
130 
131   // Add member to set
132   virtual Set &amp;operator &lt;&lt;=(uint elem)=0;
133   // virtual Set  operator &lt;&lt; (uint elem);
134 
135   // Delete member from set
136   virtual Set &amp;operator &gt;&gt;=(uint elem)=0;
137   // virtual Set  operator &gt;&gt; (uint elem);
138 
139   // Membership test.  Result is Zero (absent)/ Non-Zero (present)
140   virtual int operator [](uint elem) const=0;
141 
142   // Intersect sets
143   virtual Set &amp;operator &amp;=(const Set &amp;s)=0;
144   // virtual Set  operator &amp; (const Set &amp;s) const;
145 
146   // Union sets
147   virtual Set &amp;operator |=(const Set &amp;s)=0;
148   // virtual Set  operator | (const Set &amp;s) const;
149 
150   // Difference sets
151   virtual Set &amp;operator -=(const Set &amp;s)=0;
152   // virtual Set  operator - (const Set &amp;s) const;
153 
154   // Tests for equality.  Result is Zero (false)/ Non-Zero (true)
155   virtual int operator ==(const Set &amp;s) const=0;
156   int operator !=(const Set &amp;s) const { return !(*this == s); }
157   virtual int disjoint(const Set &amp;s) const=0;
158 
159   // Tests for strict subset.  Result is Zero (false)/ Non-Zero (true)
160   virtual int operator &lt; (const Set &amp;s) const=0;
161   int operator &gt; (const Set &amp;s) const { return s &lt; *this; }
162 
163   // Tests for subset.  Result is Zero (false)/ Non-Zero (true)
164   virtual int operator &lt;=(const Set &amp;s) const=0;
165   int operator &gt;=(const Set &amp;s) const { return s &lt;= *this; }
166 
167   // Clear all the elements in the Set
168   virtual void Clear(void)=0;
169 
170   // Return the number of members in the Set
171   virtual uint Size(void) const=0;
172 
173   // If an iterator follows a &quot;Sort()&quot; without any Set-modifying operations
174   // inbetween then the iterator will visit the elements in ascending order.
175   virtual void Sort(void)=0;
176 
177   // Convert a set to printable string in an allocated buffer.
178   // The caller must deallocate the string.
179   virtual char *setstr(void) const;
180 
181   // Print the Set on &quot;stdout&quot;.  Can be conveniently called in the debugger
182   void print() const;
183 
184   // Parse text from the string into the Set.  Return length parsed.
185   virtual int parse(const char *s);
186 
187   // Convert a generic Set to a specific Set
188   virtual const VectorSet *asVectorSet(void) const;
189 
190   // Hash the set.  Sets of different types but identical elements will NOT
191   // hash the same.  Same set type, same elements WILL hash the same.
192   virtual int hash() const = 0;
193 
194 protected:
195   friend class SetI;
196   virtual class SetI_ *iterate(uint&amp;) const=0;
197 
198   // Need storeage for the set
199   Arena *_set_arena;
200 };
201 
202 //------------------------------Iteration--------------------------------------
203 // Loop thru all elements of the set, setting &quot;elem&quot; to the element numbers
204 // in random order.  Inserted or deleted elements during this operation may
205 // or may not be iterated over; untouched elements will be affected once.
206 
207 // Usage:  for( SetI  i(s); i.test(); i++ ) { body = i.elem; }   ...OR...
208 //         for( i.reset(s); i.test(); i++ ) { body = i.elem; }
209 
210 class SetI_ : public ResourceObj {
211 protected:
212   friend class SetI;
213   virtual ~SetI_();
214   virtual uint next(void)=0;
215   virtual int test(void)=0;
216 };
217 
218 class SetI {
219 protected:
220   SetI_ *impl;
221 public:
222   uint elem;                    // The publically accessible element
223 
224   SetI( const Set *s ) { impl = s-&gt;iterate(elem); }
225   ~SetI() { delete impl; }
226   void reset( const Set *s ) { delete impl; impl = s-&gt;iterate(elem); }
227   void operator ++(void) { elem = impl-&gt;next(); }
228   int test(void) { return impl-&gt;test(); }
229 };
230 
231 #endif // SHARE_LIBADT_SET_HPP
    </pre>
  </body>
</html>
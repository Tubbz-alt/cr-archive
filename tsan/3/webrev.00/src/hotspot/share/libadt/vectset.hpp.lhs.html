<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/libadt/vectset.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_LIBADT_VECTSET_HPP
 26 #define SHARE_LIBADT_VECTSET_HPP
 27 
<a name="1" id="anc1"></a><span class="line-modified"> 28 #include &quot;libadt/set.hpp&quot;</span>

 29 
<a name="2" id="anc2"></a><span class="line-modified"> 30 #define BITS_IN_BYTE_ARRAY_SIZE 256</span>
<span class="line-removed"> 31 </span>
<span class="line-removed"> 32 // Vector Sets - An Abstract Data Type</span>
<span class="line-removed"> 33 //INTERFACE</span>
 34 
 35 // These sets can grow or shrink, based on the initial size and the largest
<a name="3" id="anc3"></a><span class="line-modified"> 36 // element currently in them.  Slow and bulky for sparse sets, these sets</span>
<span class="line-removed"> 37 // are super for dense sets.  They are fast and compact when dense.</span>
<span class="line-removed"> 38 </span>
<span class="line-removed"> 39 // TIME:</span>
<span class="line-removed"> 40 // O(1) - Insert, Delete, Member, Sort</span>
<span class="line-removed"> 41 // O(max_element) - Create, Clear, Size, Copy, Union, Intersect, Difference,</span>
<span class="line-removed"> 42 //                  Equal, ChooseMember, Forall</span>
<span class="line-removed"> 43 </span>
<span class="line-removed"> 44 // SPACE: (max_element)/(8*sizeof(int))</span>
<span class="line-removed"> 45 </span>
 46 
 47 //------------------------------VectorSet--------------------------------------
<a name="4" id="anc4"></a><span class="line-modified"> 48 class VectorSet : public Set {</span>
<span class="line-modified"> 49 friend class VectorSetI;        // Friendly iterator class</span>
<span class="line-modified"> 50 protected:</span>
<span class="line-modified"> 51   uint size;                    // Size of data IN LONGWORDS (32bits)</span>
<span class="line-modified"> 52   uint32_t* data;               // The data, bit packed</span>
 53 
<a name="5" id="anc5"></a><span class="line-modified"> 54   void slamin( const VectorSet&amp; s );     // Initialize one set with another</span>
<span class="line-modified"> 55   int compare(const VectorSet &amp;s) const; // Compare set contents</span>
<span class="line-modified"> 56   void grow(uint newsize);               // Grow vector to required bitsize</span>



 57 
<a name="6" id="anc6"></a>

 58 public:
<a name="7" id="anc7"></a><span class="line-modified"> 59   VectorSet(Arena *arena);                      // Creates a new, empty set.</span>
<span class="line-removed"> 60   VectorSet(const VectorSet &amp;s) : Set(s._set_arena) {slamin(s);} // Set clone; deep-copy guts</span>
<span class="line-removed"> 61   Set &amp;operator =(const Set &amp;s);                // Set clone; deep-copy guts</span>
<span class="line-removed"> 62   VectorSet &amp;operator =(const VectorSet &amp;s)     // Set clone; deep-copy guts</span>
<span class="line-removed"> 63   { if( &amp;s != this ) { slamin(s); } return *this; }</span>
 64   ~VectorSet() {}
<a name="8" id="anc8"></a><span class="line-removed"> 65   Set &amp;clone(void) const { return *(new VectorSet(*this)); }</span>
<span class="line-removed"> 66 </span>
<span class="line-removed"> 67   Set &amp;operator &lt;&lt;=(uint elem);          // Add member to set</span>
<span class="line-removed"> 68   VectorSet operator &lt;&lt; (uint elem)      // Add member to new set</span>
<span class="line-removed"> 69   { VectorSet foo(*this); foo &lt;&lt;= elem; return foo; }</span>
<span class="line-removed"> 70   Set &amp;operator &gt;&gt;=(uint elem);          // Delete member from set</span>
<span class="line-removed"> 71   VectorSet operator &gt;&gt; (uint elem)      // Delete member from new set</span>
<span class="line-removed"> 72   { VectorSet foo(*this); foo &gt;&gt;= elem; return foo; }</span>
<span class="line-removed"> 73 </span>
<span class="line-removed"> 74   VectorSet &amp;operator &amp;=(const VectorSet &amp;s); // Intersect sets into first set</span>
<span class="line-removed"> 75   Set       &amp;operator &amp;=(const Set       &amp;s); // Intersect sets into first set</span>
<span class="line-removed"> 76   VectorSet operator &amp; (const VectorSet &amp;s) const</span>
<span class="line-removed"> 77   { VectorSet foo(*this); foo &amp;= s; return foo; }</span>
 78 
<a name="9" id="anc9"></a><span class="line-modified"> 79   VectorSet &amp;operator |=(const VectorSet &amp;s); // Intersect sets into first set</span>
<span class="line-modified"> 80   Set       &amp;operator |=(const Set       &amp;s); // Intersect sets into first set</span>
<span class="line-modified"> 81   VectorSet operator | (const VectorSet &amp;s) const</span>
<span class="line-modified"> 82   { VectorSet foo(*this); foo |= s; return foo; }</span>
<span class="line-modified"> 83 </span>
<span class="line-modified"> 84   VectorSet &amp;operator -=(const VectorSet &amp;s); // Intersect sets into first set</span>
<span class="line-modified"> 85   Set       &amp;operator -=(const Set       &amp;s); // Intersect sets into first set</span>
<span class="line-removed"> 86   VectorSet operator - (const VectorSet &amp;s) const</span>
<span class="line-removed"> 87   { VectorSet foo(*this); foo -= s; return foo; }</span>
<span class="line-removed"> 88 </span>
<span class="line-removed"> 89   int operator ==(const VectorSet &amp;s) const;  // True if sets are equal</span>
<span class="line-removed"> 90   int operator ==(const Set       &amp;s) const;  // True if sets are equal</span>
<span class="line-removed"> 91   int operator &lt; (const VectorSet &amp;s) const;  // True if strict subset</span>
<span class="line-removed"> 92   int operator &lt; (const Set       &amp;s) const;  // True if strict subset</span>
<span class="line-removed"> 93   int operator &lt;=(const VectorSet &amp;s) const;  // True if subset relation holds.</span>
<span class="line-removed"> 94   int operator &lt;=(const Set       &amp;s) const;  // True if subset relation holds.</span>
<span class="line-removed"> 95   int disjoint   (const Set       &amp;s) const;  // True if sets are disjoint</span>
<span class="line-removed"> 96 </span>
<span class="line-removed"> 97   int operator [](uint elem) const; // Test for membership</span>
<span class="line-removed"> 98   void Clear(void);                 // Clear a set</span>
<span class="line-removed"> 99   uint Size(void) const;            // Number of elements in the Set.</span>
<span class="line-removed">100   void Sort(void);                  // Sort before iterating</span>
<span class="line-removed">101   int hash() const;                 // Hash function</span>
<span class="line-removed">102   void Reset(void) {                // Reset a set</span>
<span class="line-removed">103     memset( data, 0, size*sizeof(uint32_t) );</span>
104   }
<a name="10" id="anc10"></a><span class="line-removed">105 </span>
<span class="line-removed">106   /* Removed for MCC BUG</span>
<span class="line-removed">107      operator const VectorSet* (void) const { return this; } */</span>
<span class="line-removed">108   const VectorSet *asVectorSet() const { return this; }</span>
<span class="line-removed">109 </span>
<span class="line-removed">110   // Expose internals for speed-critical fast iterators</span>
<span class="line-removed">111   uint word_size() const { return size; }</span>
112 
113   // Fast inlined &quot;test and set&quot;.  Replaces the idiom:
<a name="11" id="anc11"></a><span class="line-modified">114   //     if( visited[idx] ) return;</span>
<span class="line-modified">115   //     visited &lt;&lt;= idx;</span>
116   // With:
<a name="12" id="anc12"></a><span class="line-modified">117   //     if( visited.test_set(idx) ) return;</span>
118   //
<a name="13" id="anc13"></a><span class="line-modified">119   int test_set( uint elem ) {</span>
<span class="line-modified">120     uint word = elem &gt;&gt; 5;           // Get the longword offset</span>
<span class="line-modified">121     if( word &gt;= size )               // Beyond the last?</span>
<span class="line-modified">122       return test_set_grow(elem);    // Then grow; set; return 0;</span>
<span class="line-modified">123     uint32_t mask = 1L &lt;&lt; (elem &amp; 31); // Get bit mask</span>
<span class="line-modified">124     uint32_t datum = data[word] &amp; mask;// Get bit</span>
<span class="line-modified">125     data[word] |= mask;              // Set bit</span>
<span class="line-modified">126     return datum;                    // Return bit</span>
<span class="line-modified">127   }</span>
<span class="line-modified">128   int test_set_grow( uint elem ) {    // Insert &amp; return 0;</span>
<span class="line-removed">129     (*this) &lt;&lt;= elem;                 // Insert into set</span>
<span class="line-removed">130     return 0;                         // Return 0!</span>
131   }
132 
133   // Fast inlined test
<a name="14" id="anc14"></a><span class="line-modified">134   int test( uint elem ) const {</span>
<span class="line-modified">135     uint word = elem &gt;&gt; 5;      // Get the longword offset</span>
<span class="line-modified">136     if( word &gt;= size ) return 0; // Beyond the last?</span>
<span class="line-modified">137     uint32_t mask = 1L &lt;&lt; (elem &amp; 31); // Get bit mask</span>
<span class="line-modified">138     return data[word] &amp; mask;   // Get bit</span>


139   }
140 
<a name="15" id="anc15"></a><span class="line-modified">141   // Fast inlined set</span>
<span class="line-modified">142   void set( uint elem ) {</span>
<span class="line-modified">143     uint word = elem &gt;&gt; 5;      // Get the longword offset</span>
<span class="line-modified">144     if( word &gt;= size ) {        // Beyond the last?</span>
<span class="line-removed">145       test_set_grow(elem);      // Then grow and set</span>
<span class="line-removed">146     } else {</span>
<span class="line-removed">147       uint32_t mask = 1L &lt;&lt; (elem &amp; 31); // Get bit mask</span>
<span class="line-removed">148       data[word] |= mask;       // Set bit</span>
149     }
<a name="16" id="anc16"></a>

150   }
151 
<a name="17" id="anc17"></a><span class="line-modified">152 </span>
<span class="line-modified">153 private:</span>
<span class="line-modified">154   SetI_ *iterate(uint&amp;) const;</span>
<span class="line-modified">155 };</span>
<span class="line-modified">156 </span>
<span class="line-modified">157 //------------------------------Iteration--------------------------------------</span>
<span class="line-modified">158 // Loop thru all elements of the set, setting &quot;elem&quot; to the element numbers</span>
<span class="line-modified">159 // in random order.  Inserted or deleted elements during this operation may</span>
<span class="line-removed">160 // or may not be iterated over; untouched elements will be affected once.</span>
<span class="line-removed">161 // Usage:  for( VectorSetI i(s); i.test(); i++ ) { body = i.elem; }</span>
<span class="line-removed">162 </span>
<span class="line-removed">163 class VectorSetI : public StackObj {</span>
<span class="line-removed">164   friend class VectorSet;</span>
<span class="line-removed">165   const VectorSet *s;</span>
<span class="line-removed">166   uint i, j;</span>
<span class="line-removed">167   uint32_t mask;</span>
<span class="line-removed">168   uint next(void);</span>
<span class="line-removed">169 </span>
<span class="line-removed">170 public:</span>
<span class="line-removed">171   uint elem;                    // The publically accessible element</span>
<span class="line-removed">172 </span>
<span class="line-removed">173   VectorSetI( const VectorSet *vset ) :</span>
<span class="line-removed">174     s(vset),</span>
<span class="line-removed">175     i((uint)-1L),</span>
<span class="line-removed">176     j((uint)-1L),</span>
<span class="line-removed">177     mask((unsigned)(1L&lt;&lt;31)) {</span>
<span class="line-removed">178     elem = next();</span>
179   }
<a name="18" id="anc18"></a><span class="line-removed">180 </span>
<span class="line-removed">181   void operator ++(void) { elem = next(); }</span>
<span class="line-removed">182   int test(void) { return i &lt; s-&gt;size; }</span>
183 };
184 
185 #endif // SHARE_LIBADT_VECTSET_HPP
<a name="19" id="anc19"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="19" type="hidden" />
</body>
</html>
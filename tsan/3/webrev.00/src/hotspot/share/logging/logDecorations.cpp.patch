diff a/src/hotspot/share/logging/logDecorations.cpp b/src/hotspot/share/logging/logDecorations.cpp
--- a/src/hotspot/share/logging/logDecorations.cpp
+++ b/src/hotspot/share/logging/logDecorations.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -23,48 +23,51 @@
  */
 #include "precompiled.hpp"
 #include "jvm.h"
 #include "logging/logConfiguration.hpp"
 #include "logging/logDecorations.hpp"
+#include "runtime/atomic.hpp"
 #include "runtime/os.inline.hpp"
 #include "runtime/thread.inline.hpp"
 #include "services/management.hpp"
 
-jlong LogDecorations::_vm_start_time_millis = 0;
-const char* LogDecorations::_host_name = "";
+const char* volatile LogDecorations::_host_name = NULL;
 
 LogDecorations::LogDecorations(LogLevelType level, const LogTagSet &tagset, const LogDecorators &decorators)
-    : _level(level), _tagset(tagset), _millis(-1) {
+    : _level(level), _tagset(tagset) {
   create_decorations(decorators);
 }
 
-void LogDecorations::initialize(jlong vm_start_time) {
-  char buffer[1024];
-  if (os::get_host_name(buffer, sizeof(buffer))){
-    _host_name = os::strdup_check_oom(buffer);
+const char* LogDecorations::host_name() {
+  const char* host_name = Atomic::load_acquire(&_host_name);
+  if (host_name == NULL) {
+    char buffer[1024];
+    if (os::get_host_name(buffer, sizeof(buffer))) {
+      host_name = os::strdup_check_oom(buffer);
+      const char* old_value = Atomic::cmpxchg(&_host_name, (const char*)NULL, host_name);
+      if (old_value != NULL) {
+        os::free((void *) host_name);
+        host_name = old_value;
+      }
+    }
   }
-  _vm_start_time_millis = vm_start_time;
+  return host_name;
 }
 
 void LogDecorations::create_decorations(const LogDecorators &decorators) {
   char* position = _decorations_buffer;
   #define DECORATOR(full_name, abbr) \
   if (decorators.is_decorator(LogDecorators::full_name##_decorator)) { \
     _decoration_offset[LogDecorators::full_name##_decorator] = position; \
     position = create_##full_name##_decoration(position) + 1; \
+  } else { \
+    _decoration_offset[LogDecorators::full_name##_decorator] = NULL; \
   }
   DECORATOR_LIST
 #undef DECORATOR
 }
 
-jlong LogDecorations::java_millis() {
-  if (_millis < 0) {
-    _millis = os::javaTimeMillis();
-  }
-  return _millis;
-}
-
 #define ASSERT_AND_RETURN(written, pos) \
     assert(written >= 0, "Decorations buffer overflow"); \
     return pos + written;
 
 char* LogDecorations::create_time_decoration(char* pos) {
@@ -83,27 +86,32 @@
   int written = jio_snprintf(pos, DecorationsBufferSize - (pos - _decorations_buffer), "%.3fs", os::elapsedTime());
   ASSERT_AND_RETURN(written, pos)
 }
 
 char * LogDecorations::create_timemillis_decoration(char* pos) {
-  int written = jio_snprintf(pos, DecorationsBufferSize - (pos - _decorations_buffer), INT64_FORMAT "ms", java_millis());
+  int written = jio_snprintf(pos, DecorationsBufferSize - (pos - _decorations_buffer), INT64_FORMAT "ms", os::javaTimeMillis());
   ASSERT_AND_RETURN(written, pos)
 }
 
+// Small helper for uptime conversion
+static jlong elapsed_time(int unit_multiplier) {
+  return (jlong)(os::elapsedTime() * unit_multiplier);
+}
+
 char * LogDecorations::create_uptimemillis_decoration(char* pos) {
   int written = jio_snprintf(pos, DecorationsBufferSize - (pos - _decorations_buffer),
-                             INT64_FORMAT "ms", java_millis() - _vm_start_time_millis);
+                             INT64_FORMAT "ms", elapsed_time(MILLIUNITS));
   ASSERT_AND_RETURN(written, pos)
 }
 
 char * LogDecorations::create_timenanos_decoration(char* pos) {
   int written = jio_snprintf(pos, DecorationsBufferSize - (pos - _decorations_buffer), INT64_FORMAT "ns", os::javaTimeNanos());
   ASSERT_AND_RETURN(written, pos)
 }
 
 char * LogDecorations::create_uptimenanos_decoration(char* pos) {
-  int written = jio_snprintf(pos, DecorationsBufferSize - (pos - _decorations_buffer), INT64_FORMAT "ns", os::elapsed_counter());
+  int written = jio_snprintf(pos, DecorationsBufferSize - (pos - _decorations_buffer), INT64_FORMAT "ns", elapsed_time(NANOUNITS));
   ASSERT_AND_RETURN(written, pos)
 }
 
 char * LogDecorations::create_pid_decoration(char* pos) {
   int written = jio_snprintf(pos, DecorationsBufferSize - (pos - _decorations_buffer), "%d", os::current_process_id());
@@ -126,9 +134,8 @@
   int written = _tagset.label(pos, DecorationsBufferSize - (pos - _decorations_buffer));
   ASSERT_AND_RETURN(written, pos)
 }
 
 char* LogDecorations::create_hostname_decoration(char* pos) {
-  int written = jio_snprintf(pos, DecorationsBufferSize - (pos - _decorations_buffer), "%s", _host_name);
+  int written = jio_snprintf(pos, DecorationsBufferSize - (pos - _decorations_buffer), "%s", host_name());
   ASSERT_AND_RETURN(written, pos)
 }
-

diff a/src/hotspot/share/aot/aotCompiledMethod.cpp b/src/hotspot/share/aot/aotCompiledMethod.cpp
--- a/src/hotspot/share/aot/aotCompiledMethod.cpp
+++ b/src/hotspot/share/aot/aotCompiledMethod.cpp
@@ -30,16 +30,16 @@
 #include "code/compiledIC.hpp"
 #include "code/nativeInst.hpp"
 #include "compiler/compilerOracle.hpp"
 #include "gc/shared/cardTableBarrierSet.hpp"
 #include "gc/shared/collectedHeap.hpp"
-#include "jvmci/compilerRuntime.hpp"
-#include "jvmci/jvmciRuntime.hpp"
+#include "oops/klass.inline.hpp"
 #include "oops/method.inline.hpp"
 #include "runtime/frame.inline.hpp"
 #include "runtime/handles.inline.hpp"
 #include "runtime/java.hpp"
+#include "runtime/orderAccess.hpp"
 #include "runtime/os.hpp"
 #include "runtime/safepointVerifiers.hpp"
 #include "runtime/sharedRuntime.hpp"
 #include "utilities/sizes.hpp"
 #include "utilities/xmlstream.hpp"
@@ -159,17 +159,15 @@
 void AOTCompiledMethod::do_unloading(bool unloading_occurred) {
   unload_nmethod_caches(unloading_occurred);
 }
 
 bool AOTCompiledMethod::make_not_entrant_helper(int new_state) {
-  // Make sure the method is not flushed in case of a safepoint in code below.
-  methodHandle the_method(method());
   NoSafepointVerifier nsv;
 
   {
     // Enter critical section.  Does not block for safepoint.
-    MutexLockerEx pl(Patching_lock, Mutex::_no_safepoint_check_flag);
+    MutexLocker pl(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);
 
     if (*_state_adr == new_state) {
       // another thread already performed this transition so nothing
       // to do, but return false to indicate this.
       return false;
@@ -188,16 +186,14 @@
         method()->set_aot_code(NULL);
     }
 #endif
 
     // Remove AOTCompiledMethod from method.
-    if (method() != NULL && (method()->code() == this ||
-                             method()->from_compiled_entry() == verified_entry_point())) {
-      HandleMark hm;
-      method()->clear_code(false /* already owns Patching_lock */);
+    if (method() != NULL) {
+      method()->unlink_code(this);
     }
-  } // leave critical region under Patching_lock
+  } // leave critical region under CompiledMethod_lock
 
 
   if (TraceCreateZombies) {
     ResourceMark m;
     const char *new_state_str = (new_state == not_entrant) ? "not entrant" : "not used";
@@ -208,21 +204,17 @@
 }
 
 #ifdef TIERED
 bool AOTCompiledMethod::make_entrant() {
   assert(!method()->is_old(), "reviving evolved method!");
-  assert(*_state_adr != not_entrant, "%s", method()->has_aot_code() ? "has_aot_code() not cleared" : "caller didn't check has_aot_code()");
 
-  // Make sure the method is not flushed in case of a safepoint in code below.
-  methodHandle the_method(method());
   NoSafepointVerifier nsv;
-
   {
     // Enter critical section.  Does not block for safepoint.
-    MutexLockerEx pl(Patching_lock, Mutex::_no_safepoint_check_flag);
+    MutexLocker pl(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);
 
-    if (*_state_adr == in_use) {
+    if (*_state_adr == in_use || *_state_adr == not_entrant) {
       // another thread already performed this transition so nothing
       // to do, but return false to indicate this.
       return false;
     }
 
@@ -230,11 +222,11 @@
     OrderAccess::storestore();
     *_state_adr = in_use;
 
     // Log the transition once
     log_state_change();
-  } // leave critical region under Patching_lock
+  } // leave critical region under CompiledMethod_lock
 
 
   if (TraceCreateZombies) {
     ResourceMark m;
     tty->print_cr("aot method <" INTPTR_FORMAT "> %s code made entrant", p2i(this), this->method() ? this->method()->name_and_sig_as_C_string() : "null");
@@ -244,11 +236,11 @@
 }
 #endif // TIERED
 
 // Iterate over metadata calling this function.   Used by RedefineClasses
 // Copied from nmethod::metadata_do
-void AOTCompiledMethod::metadata_do(void f(Metadata*)) {
+void AOTCompiledMethod::metadata_do(MetadataClosure* f) {
   address low_boundary = verified_entry_point();
   {
     // Visit all immediate references that are embedded in the instruction stream.
     RelocIterator iter(this, low_boundary);
     while (iter.next()) {
@@ -260,33 +252,33 @@
         assert(1 == (r->metadata_is_immediate()) +
                (r->metadata_addr() >= metadata_begin() && r->metadata_addr() < metadata_end()),
                "metadata must be found in exactly one place");
         if (r->metadata_is_immediate() && r->metadata_value() != NULL) {
           Metadata* md = r->metadata_value();
-          if (md != _method) f(md);
+          if (md != _method) f->do_metadata(md);
         }
       } else if (iter.type() == relocInfo::virtual_call_type) {
         ResourceMark rm;
         // Check compiledIC holders associated with this nmethod
         CompiledIC *ic = CompiledIC_at(&iter);
         if (ic->is_icholder_call()) {
           CompiledICHolder* cichk = ic->cached_icholder();
-          f(cichk->holder_metadata());
-          f(cichk->holder_klass());
+          f->do_metadata(cichk->holder_metadata());
+          f->do_metadata(cichk->holder_klass());
         } else {
           // Get Klass* or NULL (if value is -1) from GOT cell of virtual call PLT stub.
           Metadata* ic_oop = ic->cached_metadata();
           if (ic_oop != NULL) {
-            f(ic_oop);
+            f->do_metadata(ic_oop);
           }
         }
       } else if (iter.type() == relocInfo::static_call_type ||
-                 iter.type() == relocInfo::opt_virtual_call_type){
+                 iter.type() == relocInfo::opt_virtual_call_type) {
         // Check Method* in AOT c2i stub for other calls.
         Metadata* meta = (Metadata*)nativeLoadGot_at(nativePltCall_at(iter.addr())->plt_c2i_stub())->data();
         if (meta != NULL) {
-          f(meta);
+          f->do_metadata(meta);
         }
       }
     }
   }
 
@@ -300,15 +292,15 @@
       m = (Metadata*)(meta & ~1);
     } else {
       continue;
     }
     assert(Metaspace::contains(m), "");
-    f(m);
+    f->do_metadata(m);
   }
 
   // Visit metadata not embedded in the other places.
-  if (_method != NULL) f(_method);
+  if (_method != NULL) f->do_metadata(_method);
 }
 
 void AOTCompiledMethod::print() const {
   print_on(tty, "AOTCompiledMethod");
 }

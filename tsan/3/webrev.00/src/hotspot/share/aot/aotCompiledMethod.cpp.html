<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/aot/aotCompiledMethod.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 
 26 #include &quot;aot/aotCodeHeap.hpp&quot;
 27 #include &quot;aot/aotLoader.hpp&quot;
 28 #include &quot;aot/compiledIC_aot.hpp&quot;
 29 #include &quot;code/codeCache.hpp&quot;
 30 #include &quot;code/compiledIC.hpp&quot;
 31 #include &quot;code/nativeInst.hpp&quot;
 32 #include &quot;compiler/compilerOracle.hpp&quot;
 33 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
 34 #include &quot;gc/shared/collectedHeap.hpp&quot;
 35 #include &quot;oops/klass.inline.hpp&quot;
 36 #include &quot;oops/method.inline.hpp&quot;
 37 #include &quot;runtime/frame.inline.hpp&quot;
 38 #include &quot;runtime/handles.inline.hpp&quot;
 39 #include &quot;runtime/java.hpp&quot;
 40 #include &quot;runtime/orderAccess.hpp&quot;
 41 #include &quot;runtime/os.hpp&quot;
 42 #include &quot;runtime/safepointVerifiers.hpp&quot;
 43 #include &quot;runtime/sharedRuntime.hpp&quot;
 44 #include &quot;utilities/sizes.hpp&quot;
 45 #include &quot;utilities/xmlstream.hpp&quot;
 46 
 47 #include &lt;stdio.h&gt;
 48 
 49 #if 0
 50 static void metadata_oops_do(Metadata** metadata_begin, Metadata **metadata_end, OopClosure* f) {
 51   // Visit the metadata/oops section
 52   for (Metadata** p = metadata_begin; p &lt; metadata_end; p++) {
 53     Metadata* m = *p;
 54 
 55     intptr_t meta = (intptr_t)m;
 56     if ((meta &amp; 1) == 1) {
 57       // already resolved
 58       m = (Metadata*)(meta &amp; ~1);
 59     } else {
 60       continue;
 61     }
 62     assert(Metaspace::contains(m), &quot;&quot;);
 63     if (m-&gt;is_method()) {
 64       m = ((Method*)m)-&gt;method_holder();
 65     }
 66     assert(m-&gt;is_klass(), &quot;must be&quot;);
 67     oop o = ((Klass*)m)-&gt;klass_holder();
 68     if (o != NULL) {
 69       f-&gt;do_oop(&amp;o);
 70     }
 71   }
 72 }
 73 #endif
 74 
 75 address* AOTCompiledMethod::orig_pc_addr(const frame* fr) {
 76   return (address*) ((address)fr-&gt;unextended_sp() + _meta-&gt;orig_pc_offset());
 77 }
 78 
 79 oop AOTCompiledMethod::oop_at(int index) const {
 80   if (index == 0) { // 0 is reserved
 81     return NULL;
 82   }
 83   Metadata** entry = _metadata_got + (index - 1);
 84   intptr_t meta = (intptr_t)*entry;
 85   if ((meta &amp; 1) == 1) {
 86     // already resolved
 87     Klass* k = (Klass*)(meta &amp; ~1);
 88     return k-&gt;java_mirror();
 89   }
 90   // The entry is string which we need to resolve.
 91   const char* meta_name = _heap-&gt;get_name_at((int)meta);
 92   int klass_len = Bytes::get_Java_u2((address)meta_name);
 93   const char* klass_name = meta_name + 2;
 94   // Quick check the current method&#39;s holder.
 95   Klass* k = _method-&gt;method_holder();
 96 
 97   ResourceMark rm; // for signature_name()
 98   if (strncmp(k-&gt;signature_name(), klass_name, klass_len) != 0) { // Does not match?
 99     // Search klass in got cells in DSO which have this compiled method.
100     k = _heap-&gt;get_klass_from_got(klass_name, klass_len, _method);
101   }
102   int method_name_len = Bytes::get_Java_u2((address)klass_name + klass_len);
103   guarantee(method_name_len == 0, &quot;only klass is expected here&quot;);
104   meta = ((intptr_t)k) | 1;
105   *entry = (Metadata*)meta; // Should be atomic on x64
106   return k-&gt;java_mirror();
107 }
108 
109 Metadata* AOTCompiledMethod::metadata_at(int index) const {
110   if (index == 0) { // 0 is reserved
111     return NULL;
112   }
113   assert(index - 1 &lt; _metadata_size, &quot;&quot;);
114   {
115     Metadata** entry = _metadata_got + (index - 1);
116     intptr_t meta = (intptr_t)*entry;
117     if ((meta &amp; 1) == 1) {
118       // already resolved
119       Metadata *m = (Metadata*)(meta &amp; ~1);
120       return m;
121     }
122     // The entry is string which we need to resolve.
123     const char* meta_name = _heap-&gt;get_name_at((int)meta);
124     int klass_len = Bytes::get_Java_u2((address)meta_name);
125     const char* klass_name = meta_name + 2;
126     // Quick check the current method&#39;s holder.
127     Klass* k = _method-&gt;method_holder();
128     bool klass_matched = true;
129 
130     ResourceMark rm; // for signature_name() and find_method()
131     if (strncmp(k-&gt;signature_name(), klass_name, klass_len) != 0) { // Does not match?
132       // Search klass in got cells in DSO which have this compiled method.
133       k = _heap-&gt;get_klass_from_got(klass_name, klass_len, _method);
134       klass_matched = false;
135     }
136     int method_name_len = Bytes::get_Java_u2((address)klass_name + klass_len);
137     if (method_name_len == 0) { // Array or Klass name only?
138       meta = ((intptr_t)k) | 1;
139       *entry = (Metadata*)meta; // Should be atomic on x64
140       return (Metadata*)k;
141     } else { // Method
142       // Quick check the current method&#39;s name.
143       Method* m = _method;
144       int signature_len = Bytes::get_Java_u2((address)klass_name + klass_len + 2 + method_name_len);
145       int full_len = 2 + klass_len + 2 + method_name_len + 2 + signature_len;
146       if (!klass_matched || memcmp(_name, meta_name, full_len) != 0) { // Does not match?
147         Thread* thread = Thread::current();
148         const char* method_name = klass_name + klass_len;
149         m = AOTCodeHeap::find_method(k, thread, method_name);
150       }
151       meta = ((intptr_t)m) | 1;
152       *entry = (Metadata*)meta; // Should be atomic on x64
153       return (Metadata*)m;
154     }
155   }
156   ShouldNotReachHere(); return NULL;
157 }
158 
159 void AOTCompiledMethod::do_unloading(bool unloading_occurred) {
160   unload_nmethod_caches(unloading_occurred);
161 }
162 
163 bool AOTCompiledMethod::make_not_entrant_helper(int new_state) {
164   NoSafepointVerifier nsv;
165 
166   {
167     // Enter critical section.  Does not block for safepoint.
168     MutexLocker pl(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);
169 
170     if (*_state_adr == new_state) {
171       // another thread already performed this transition so nothing
172       // to do, but return false to indicate this.
173       return false;
174     }
175 
176     // Change state
177     OrderAccess::storestore();
178     *_state_adr = new_state;
179 
180     // Log the transition once
181     log_state_change();
182 
183 #ifdef TIERED
184     // Remain non-entrant forever
185     if (new_state == not_entrant &amp;&amp; method() != NULL) {
186         method()-&gt;set_aot_code(NULL);
187     }
188 #endif
189 
190     // Remove AOTCompiledMethod from method.
191     if (method() != NULL) {
192       method()-&gt;unlink_code(this);
193     }
194   } // leave critical region under CompiledMethod_lock
195 
196 
197   if (TraceCreateZombies) {
198     ResourceMark m;
199     const char *new_state_str = (new_state == not_entrant) ? &quot;not entrant&quot; : &quot;not used&quot;;
200     tty-&gt;print_cr(&quot;aot method &lt;&quot; INTPTR_FORMAT &quot;&gt; %s code made %s&quot;, p2i(this), this-&gt;method() ? this-&gt;method()-&gt;name_and_sig_as_C_string() : &quot;null&quot;, new_state_str);
201   }
202 
203   return true;
204 }
205 
206 #ifdef TIERED
207 bool AOTCompiledMethod::make_entrant() {
208   assert(!method()-&gt;is_old(), &quot;reviving evolved method!&quot;);
209 
210   NoSafepointVerifier nsv;
211   {
212     // Enter critical section.  Does not block for safepoint.
213     MutexLocker pl(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);
214 
215     if (*_state_adr == in_use || *_state_adr == not_entrant) {
216       // another thread already performed this transition so nothing
217       // to do, but return false to indicate this.
218       return false;
219     }
220 
221     // Change state
222     OrderAccess::storestore();
223     *_state_adr = in_use;
224 
225     // Log the transition once
226     log_state_change();
227   } // leave critical region under CompiledMethod_lock
228 
229 
230   if (TraceCreateZombies) {
231     ResourceMark m;
232     tty-&gt;print_cr(&quot;aot method &lt;&quot; INTPTR_FORMAT &quot;&gt; %s code made entrant&quot;, p2i(this), this-&gt;method() ? this-&gt;method()-&gt;name_and_sig_as_C_string() : &quot;null&quot;);
233   }
234 
235   return true;
236 }
237 #endif // TIERED
238 
239 // Iterate over metadata calling this function.   Used by RedefineClasses
240 // Copied from nmethod::metadata_do
241 void AOTCompiledMethod::metadata_do(MetadataClosure* f) {
242   address low_boundary = verified_entry_point();
243   {
244     // Visit all immediate references that are embedded in the instruction stream.
245     RelocIterator iter(this, low_boundary);
246     while (iter.next()) {
247       if (iter.type() == relocInfo::metadata_type ) {
248         metadata_Relocation* r = iter.metadata_reloc();
249         // In this metadata, we must only follow those metadatas directly embedded in
250         // the code.  Other metadatas (oop_index&gt;0) are seen as part of
251         // the metadata section below.
252         assert(1 == (r-&gt;metadata_is_immediate()) +
253                (r-&gt;metadata_addr() &gt;= metadata_begin() &amp;&amp; r-&gt;metadata_addr() &lt; metadata_end()),
254                &quot;metadata must be found in exactly one place&quot;);
255         if (r-&gt;metadata_is_immediate() &amp;&amp; r-&gt;metadata_value() != NULL) {
256           Metadata* md = r-&gt;metadata_value();
257           if (md != _method) f-&gt;do_metadata(md);
258         }
259       } else if (iter.type() == relocInfo::virtual_call_type) {
260         ResourceMark rm;
261         // Check compiledIC holders associated with this nmethod
262         CompiledIC *ic = CompiledIC_at(&amp;iter);
263         if (ic-&gt;is_icholder_call()) {
264           CompiledICHolder* cichk = ic-&gt;cached_icholder();
265           f-&gt;do_metadata(cichk-&gt;holder_metadata());
266           f-&gt;do_metadata(cichk-&gt;holder_klass());
267         } else {
268           // Get Klass* or NULL (if value is -1) from GOT cell of virtual call PLT stub.
269           Metadata* ic_oop = ic-&gt;cached_metadata();
270           if (ic_oop != NULL) {
271             f-&gt;do_metadata(ic_oop);
272           }
273         }
274       } else if (iter.type() == relocInfo::static_call_type ||
275                  iter.type() == relocInfo::opt_virtual_call_type) {
276         // Check Method* in AOT c2i stub for other calls.
277         Metadata* meta = (Metadata*)nativeLoadGot_at(nativePltCall_at(iter.addr())-&gt;plt_c2i_stub())-&gt;data();
278         if (meta != NULL) {
279           f-&gt;do_metadata(meta);
280         }
281       }
282     }
283   }
284 
285   // Visit the metadata section
286   for (Metadata** p = metadata_begin(); p &lt; metadata_end(); p++) {
287     Metadata* m = *p;
288 
289     intptr_t meta = (intptr_t)m;
290     if ((meta &amp; 1) == 1) {
291       // already resolved
292       m = (Metadata*)(meta &amp; ~1);
293     } else {
294       continue;
295     }
296     assert(Metaspace::contains(m), &quot;&quot;);
297     f-&gt;do_metadata(m);
298   }
299 
300   // Visit metadata not embedded in the other places.
301   if (_method != NULL) f-&gt;do_metadata(_method);
302 }
303 
304 void AOTCompiledMethod::print() const {
305   print_on(tty, &quot;AOTCompiledMethod&quot;);
306 }
307 
308 void AOTCompiledMethod::print_on(outputStream* st) const {
309   print_on(st, &quot;AOTCompiledMethod&quot;);
310 }
311 
312 // Print out more verbose output usually for a newly created aot method.
313 void AOTCompiledMethod::print_on(outputStream* st, const char* msg) const {
314   if (st != NULL) {
315     ttyLocker ttyl;
316     st-&gt;print(&quot;%7d &quot;, (int) st-&gt;time_stamp().milliseconds());
317     st-&gt;print(&quot;%4d &quot;, _aot_id);    // print compilation number
318     st-&gt;print(&quot;    aot[%2d]&quot;, _heap-&gt;dso_id());
319     // Stubs have _method == NULL
320     if (_method == NULL) {
321       st-&gt;print(&quot;   %s&quot;, _name);
322     } else {
323       ResourceMark m;
324       st-&gt;print(&quot;   %s&quot;, _method-&gt;name_and_sig_as_C_string());
325     }
326     if (Verbose) {
327       st-&gt;print(&quot; entry at &quot; INTPTR_FORMAT, p2i(_code));
328     }
329     if (msg != NULL) {
330       st-&gt;print(&quot;   %s&quot;, msg);
331     }
332     st-&gt;cr();
333   }
334 }
335 
336 void AOTCompiledMethod::print_value_on(outputStream* st) const {
337   st-&gt;print(&quot;AOTCompiledMethod &quot;);
338   print_on(st, NULL);
339 }
340 
341 // Print a short set of xml attributes to identify this aot method.  The
342 // output should be embedded in some other element.
343 void AOTCompiledMethod::log_identity(xmlStream* log) const {
344   log-&gt;print(&quot; aot_id=&#39;%d&#39;&quot;, _aot_id);
345   log-&gt;print(&quot; aot=&#39;%2d&#39;&quot;, _heap-&gt;dso_id());
346 }
347 
348 void AOTCompiledMethod::log_state_change() const {
349   if (LogCompilation) {
350     ResourceMark m;
351     if (xtty != NULL) {
352       ttyLocker ttyl;  // keep the following output all in one block
353       if (*_state_adr == not_entrant) {
354         xtty-&gt;begin_elem(&quot;make_not_entrant thread=&#39;&quot; UINTX_FORMAT &quot;&#39;&quot;,
355                          os::current_thread_id());
356       } else if (*_state_adr == not_used) {
357         xtty-&gt;begin_elem(&quot;make_not_used thread=&#39;&quot; UINTX_FORMAT &quot;&#39;&quot;,
358                          os::current_thread_id());
359       } else if (*_state_adr == in_use) {
360         xtty-&gt;begin_elem(&quot;make_entrant thread=&#39;&quot; UINTX_FORMAT &quot;&#39;&quot;,
361                          os::current_thread_id());
362       }
363       log_identity(xtty);
364       xtty-&gt;stamp();
365       xtty-&gt;end_elem();
366     }
367   }
368   if (PrintCompilation) {
369     ResourceMark m;
370     if (*_state_adr == not_entrant) {
371       print_on(tty, &quot;made not entrant&quot;);
372     } else if (*_state_adr == not_used) {
373       print_on(tty, &quot;made not used&quot;);
374     } else if (*_state_adr == in_use) {
375       print_on(tty, &quot;made entrant&quot;);
376     }
377   }
378 }
379 
380 
381 NativeInstruction* PltNativeCallWrapper::get_load_instruction(virtual_call_Relocation* r) const {
382   return nativeLoadGot_at(_call-&gt;plt_load_got());
383 }
384 
385 void PltNativeCallWrapper::verify_resolve_call(address dest) const {
386   CodeBlob* db = CodeCache::find_blob_unsafe(dest);
387   if (db == NULL) {
388     assert(dest == _call-&gt;plt_resolve_call(), &quot;sanity&quot;);
389   }
390 }
391 
392 void PltNativeCallWrapper::set_to_interpreted(const methodHandle&amp; method, CompiledICInfo&amp; info) {
393   assert(!info.to_aot(), &quot;only for nmethod&quot;);
394   CompiledPltStaticCall* csc = CompiledPltStaticCall::at(instruction_address());
395   csc-&gt;set_to_interpreted(method, info.entry());
396 }
397 
398 NativeCallWrapper* AOTCompiledMethod::call_wrapper_at(address call) const {
399   return new PltNativeCallWrapper((NativePltCall*) call);
400 }
401 
402 NativeCallWrapper* AOTCompiledMethod::call_wrapper_before(address return_pc) const {
403   return new PltNativeCallWrapper(nativePltCall_before(return_pc));
404 }
405 
406 CompiledStaticCall* AOTCompiledMethod::compiledStaticCall_at(Relocation* call_site) const {
407   return CompiledPltStaticCall::at(call_site);
408 }
409 
410 CompiledStaticCall* AOTCompiledMethod::compiledStaticCall_at(address call_site) const {
411   return CompiledPltStaticCall::at(call_site);
412 }
413 
414 CompiledStaticCall* AOTCompiledMethod::compiledStaticCall_before(address return_addr) const {
415   return CompiledPltStaticCall::before(return_addr);
416 }
417 
418 address AOTCompiledMethod::call_instruction_address(address pc) const {
419   NativePltCall* pltcall = nativePltCall_before(pc);
420   return pltcall-&gt;instruction_address();
421 }
422 
423 void AOTCompiledMethod::clear_inline_caches() {
424   assert(SafepointSynchronize::is_at_safepoint(), &quot;cleaning of IC&#39;s only allowed at safepoint&quot;);
425   if (is_zombie()) {
426     return;
427   }
428 
429   ResourceMark rm;
430   RelocIterator iter(this);
431   while (iter.next()) {
432     iter.reloc()-&gt;clear_inline_cache();
433     if (iter.type() == relocInfo::opt_virtual_call_type) {
434       CompiledIC* cic = CompiledIC_at(&amp;iter);
435       assert(cic-&gt;is_clean(), &quot;!&quot;);
436       nativePltCall_at(iter.addr())-&gt;set_stub_to_clean();
437     }
438   }
439 }
    </pre>
  </body>
</html>
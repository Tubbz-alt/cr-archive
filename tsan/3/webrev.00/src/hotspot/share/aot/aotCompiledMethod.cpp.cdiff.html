<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/aot/aotCompiledMethod.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="aotCodeHeap.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="aotCompiledMethod.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/aot/aotCompiledMethod.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 30,16 ***</span>
  #include &quot;code/compiledIC.hpp&quot;
  #include &quot;code/nativeInst.hpp&quot;
  #include &quot;compiler/compilerOracle.hpp&quot;
  #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  #include &quot;gc/shared/collectedHeap.hpp&quot;
<span class="line-modified">! #include &quot;jvmci/compilerRuntime.hpp&quot;</span>
<span class="line-removed">- #include &quot;jvmci/jvmciRuntime.hpp&quot;</span>
  #include &quot;oops/method.inline.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
  #include &quot;runtime/safepointVerifiers.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;utilities/sizes.hpp&quot;
  #include &quot;utilities/xmlstream.hpp&quot;
<span class="line-new-header">--- 30,16 ---</span>
  #include &quot;code/compiledIC.hpp&quot;
  #include &quot;code/nativeInst.hpp&quot;
  #include &quot;compiler/compilerOracle.hpp&quot;
  #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  #include &quot;gc/shared/collectedHeap.hpp&quot;
<span class="line-modified">! #include &quot;oops/klass.inline.hpp&quot;</span>
  #include &quot;oops/method.inline.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
<span class="line-added">+ #include &quot;runtime/orderAccess.hpp&quot;</span>
  #include &quot;runtime/os.hpp&quot;
  #include &quot;runtime/safepointVerifiers.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;utilities/sizes.hpp&quot;
  #include &quot;utilities/xmlstream.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 159,17 ***</span>
  void AOTCompiledMethod::do_unloading(bool unloading_occurred) {
    unload_nmethod_caches(unloading_occurred);
  }
  
  bool AOTCompiledMethod::make_not_entrant_helper(int new_state) {
<span class="line-removed">-   // Make sure the method is not flushed in case of a safepoint in code below.</span>
<span class="line-removed">-   methodHandle the_method(method());</span>
    NoSafepointVerifier nsv;
  
    {
      // Enter critical section.  Does not block for safepoint.
<span class="line-modified">!     MutexLockerEx pl(Patching_lock, Mutex::_no_safepoint_check_flag);</span>
  
      if (*_state_adr == new_state) {
        // another thread already performed this transition so nothing
        // to do, but return false to indicate this.
        return false;
<span class="line-new-header">--- 159,15 ---</span>
  void AOTCompiledMethod::do_unloading(bool unloading_occurred) {
    unload_nmethod_caches(unloading_occurred);
  }
  
  bool AOTCompiledMethod::make_not_entrant_helper(int new_state) {
    NoSafepointVerifier nsv;
  
    {
      // Enter critical section.  Does not block for safepoint.
<span class="line-modified">!     MutexLocker pl(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);</span>
  
      if (*_state_adr == new_state) {
        // another thread already performed this transition so nothing
        // to do, but return false to indicate this.
        return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 188,16 ***</span>
          method()-&gt;set_aot_code(NULL);
      }
  #endif
  
      // Remove AOTCompiledMethod from method.
<span class="line-modified">!     if (method() != NULL &amp;&amp; (method()-&gt;code() == this ||</span>
<span class="line-modified">!                              method()-&gt;from_compiled_entry() == verified_entry_point())) {</span>
<span class="line-removed">-       HandleMark hm;</span>
<span class="line-removed">-       method()-&gt;clear_code(false /* already owns Patching_lock */);</span>
      }
<span class="line-modified">!   } // leave critical region under Patching_lock</span>
  
  
    if (TraceCreateZombies) {
      ResourceMark m;
      const char *new_state_str = (new_state == not_entrant) ? &quot;not entrant&quot; : &quot;not used&quot;;
<span class="line-new-header">--- 186,14 ---</span>
          method()-&gt;set_aot_code(NULL);
      }
  #endif
  
      // Remove AOTCompiledMethod from method.
<span class="line-modified">!     if (method() != NULL) {</span>
<span class="line-modified">!       method()-&gt;unlink_code(this);</span>
      }
<span class="line-modified">!   } // leave critical region under CompiledMethod_lock</span>
  
  
    if (TraceCreateZombies) {
      ResourceMark m;
      const char *new_state_str = (new_state == not_entrant) ? &quot;not entrant&quot; : &quot;not used&quot;;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 208,21 ***</span>
  }
  
  #ifdef TIERED
  bool AOTCompiledMethod::make_entrant() {
    assert(!method()-&gt;is_old(), &quot;reviving evolved method!&quot;);
<span class="line-removed">-   assert(*_state_adr != not_entrant, &quot;%s&quot;, method()-&gt;has_aot_code() ? &quot;has_aot_code() not cleared&quot; : &quot;caller didn&#39;t check has_aot_code()&quot;);</span>
  
<span class="line-removed">-   // Make sure the method is not flushed in case of a safepoint in code below.</span>
<span class="line-removed">-   methodHandle the_method(method());</span>
    NoSafepointVerifier nsv;
<span class="line-removed">- </span>
    {
      // Enter critical section.  Does not block for safepoint.
<span class="line-modified">!     MutexLockerEx pl(Patching_lock, Mutex::_no_safepoint_check_flag);</span>
  
<span class="line-modified">!     if (*_state_adr == in_use) {</span>
        // another thread already performed this transition so nothing
        // to do, but return false to indicate this.
        return false;
      }
  
<span class="line-new-header">--- 204,17 ---</span>
  }
  
  #ifdef TIERED
  bool AOTCompiledMethod::make_entrant() {
    assert(!method()-&gt;is_old(), &quot;reviving evolved method!&quot;);
  
    NoSafepointVerifier nsv;
    {
      // Enter critical section.  Does not block for safepoint.
<span class="line-modified">!     MutexLocker pl(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);</span>
  
<span class="line-modified">!     if (*_state_adr == in_use || *_state_adr == not_entrant) {</span>
        // another thread already performed this transition so nothing
        // to do, but return false to indicate this.
        return false;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 230,11 ***</span>
      OrderAccess::storestore();
      *_state_adr = in_use;
  
      // Log the transition once
      log_state_change();
<span class="line-modified">!   } // leave critical region under Patching_lock</span>
  
  
    if (TraceCreateZombies) {
      ResourceMark m;
      tty-&gt;print_cr(&quot;aot method &lt;&quot; INTPTR_FORMAT &quot;&gt; %s code made entrant&quot;, p2i(this), this-&gt;method() ? this-&gt;method()-&gt;name_and_sig_as_C_string() : &quot;null&quot;);
<span class="line-new-header">--- 222,11 ---</span>
      OrderAccess::storestore();
      *_state_adr = in_use;
  
      // Log the transition once
      log_state_change();
<span class="line-modified">!   } // leave critical region under CompiledMethod_lock</span>
  
  
    if (TraceCreateZombies) {
      ResourceMark m;
      tty-&gt;print_cr(&quot;aot method &lt;&quot; INTPTR_FORMAT &quot;&gt; %s code made entrant&quot;, p2i(this), this-&gt;method() ? this-&gt;method()-&gt;name_and_sig_as_C_string() : &quot;null&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 244,11 ***</span>
  }
  #endif // TIERED
  
  // Iterate over metadata calling this function.   Used by RedefineClasses
  // Copied from nmethod::metadata_do
<span class="line-modified">! void AOTCompiledMethod::metadata_do(void f(Metadata*)) {</span>
    address low_boundary = verified_entry_point();
    {
      // Visit all immediate references that are embedded in the instruction stream.
      RelocIterator iter(this, low_boundary);
      while (iter.next()) {
<span class="line-new-header">--- 236,11 ---</span>
  }
  #endif // TIERED
  
  // Iterate over metadata calling this function.   Used by RedefineClasses
  // Copied from nmethod::metadata_do
<span class="line-modified">! void AOTCompiledMethod::metadata_do(MetadataClosure* f) {</span>
    address low_boundary = verified_entry_point();
    {
      // Visit all immediate references that are embedded in the instruction stream.
      RelocIterator iter(this, low_boundary);
      while (iter.next()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 260,33 ***</span>
          assert(1 == (r-&gt;metadata_is_immediate()) +
                 (r-&gt;metadata_addr() &gt;= metadata_begin() &amp;&amp; r-&gt;metadata_addr() &lt; metadata_end()),
                 &quot;metadata must be found in exactly one place&quot;);
          if (r-&gt;metadata_is_immediate() &amp;&amp; r-&gt;metadata_value() != NULL) {
            Metadata* md = r-&gt;metadata_value();
<span class="line-modified">!           if (md != _method) f(md);</span>
          }
        } else if (iter.type() == relocInfo::virtual_call_type) {
          ResourceMark rm;
          // Check compiledIC holders associated with this nmethod
          CompiledIC *ic = CompiledIC_at(&amp;iter);
          if (ic-&gt;is_icholder_call()) {
            CompiledICHolder* cichk = ic-&gt;cached_icholder();
<span class="line-modified">!           f(cichk-&gt;holder_metadata());</span>
<span class="line-modified">!           f(cichk-&gt;holder_klass());</span>
          } else {
            // Get Klass* or NULL (if value is -1) from GOT cell of virtual call PLT stub.
            Metadata* ic_oop = ic-&gt;cached_metadata();
            if (ic_oop != NULL) {
<span class="line-modified">!             f(ic_oop);</span>
            }
          }
        } else if (iter.type() == relocInfo::static_call_type ||
<span class="line-modified">!                  iter.type() == relocInfo::opt_virtual_call_type){</span>
          // Check Method* in AOT c2i stub for other calls.
          Metadata* meta = (Metadata*)nativeLoadGot_at(nativePltCall_at(iter.addr())-&gt;plt_c2i_stub())-&gt;data();
          if (meta != NULL) {
<span class="line-modified">!           f(meta);</span>
          }
        }
      }
    }
  
<span class="line-new-header">--- 252,33 ---</span>
          assert(1 == (r-&gt;metadata_is_immediate()) +
                 (r-&gt;metadata_addr() &gt;= metadata_begin() &amp;&amp; r-&gt;metadata_addr() &lt; metadata_end()),
                 &quot;metadata must be found in exactly one place&quot;);
          if (r-&gt;metadata_is_immediate() &amp;&amp; r-&gt;metadata_value() != NULL) {
            Metadata* md = r-&gt;metadata_value();
<span class="line-modified">!           if (md != _method) f-&gt;do_metadata(md);</span>
          }
        } else if (iter.type() == relocInfo::virtual_call_type) {
          ResourceMark rm;
          // Check compiledIC holders associated with this nmethod
          CompiledIC *ic = CompiledIC_at(&amp;iter);
          if (ic-&gt;is_icholder_call()) {
            CompiledICHolder* cichk = ic-&gt;cached_icholder();
<span class="line-modified">!           f-&gt;do_metadata(cichk-&gt;holder_metadata());</span>
<span class="line-modified">!           f-&gt;do_metadata(cichk-&gt;holder_klass());</span>
          } else {
            // Get Klass* or NULL (if value is -1) from GOT cell of virtual call PLT stub.
            Metadata* ic_oop = ic-&gt;cached_metadata();
            if (ic_oop != NULL) {
<span class="line-modified">!             f-&gt;do_metadata(ic_oop);</span>
            }
          }
        } else if (iter.type() == relocInfo::static_call_type ||
<span class="line-modified">!                  iter.type() == relocInfo::opt_virtual_call_type) {</span>
          // Check Method* in AOT c2i stub for other calls.
          Metadata* meta = (Metadata*)nativeLoadGot_at(nativePltCall_at(iter.addr())-&gt;plt_c2i_stub())-&gt;data();
          if (meta != NULL) {
<span class="line-modified">!           f-&gt;do_metadata(meta);</span>
          }
        }
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 300,15 ***</span>
        m = (Metadata*)(meta &amp; ~1);
      } else {
        continue;
      }
      assert(Metaspace::contains(m), &quot;&quot;);
<span class="line-modified">!     f(m);</span>
    }
  
    // Visit metadata not embedded in the other places.
<span class="line-modified">!   if (_method != NULL) f(_method);</span>
  }
  
  void AOTCompiledMethod::print() const {
    print_on(tty, &quot;AOTCompiledMethod&quot;);
  }
<span class="line-new-header">--- 292,15 ---</span>
        m = (Metadata*)(meta &amp; ~1);
      } else {
        continue;
      }
      assert(Metaspace::contains(m), &quot;&quot;);
<span class="line-modified">!     f-&gt;do_metadata(m);</span>
    }
  
    // Visit metadata not embedded in the other places.
<span class="line-modified">!   if (_method != NULL) f-&gt;do_metadata(_method);</span>
  }
  
  void AOTCompiledMethod::print() const {
    print_on(tty, &quot;AOTCompiledMethod&quot;);
  }
</pre>
<center><a href="aotCodeHeap.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="aotCompiledMethod.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/aot/aotCompiledMethod.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="aotCodeHeap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="aotCompiledMethod.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/aot/aotCompiledMethod.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 
 26 #include &quot;aot/aotCodeHeap.hpp&quot;
 27 #include &quot;aot/aotLoader.hpp&quot;
 28 #include &quot;aot/compiledIC_aot.hpp&quot;
 29 #include &quot;code/codeCache.hpp&quot;
 30 #include &quot;code/compiledIC.hpp&quot;
 31 #include &quot;code/nativeInst.hpp&quot;
 32 #include &quot;compiler/compilerOracle.hpp&quot;
 33 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
 34 #include &quot;gc/shared/collectedHeap.hpp&quot;
<span class="line-modified"> 35 #include &quot;jvmci/compilerRuntime.hpp&quot;</span>
<span class="line-removed"> 36 #include &quot;jvmci/jvmciRuntime.hpp&quot;</span>
 37 #include &quot;oops/method.inline.hpp&quot;
 38 #include &quot;runtime/frame.inline.hpp&quot;
 39 #include &quot;runtime/handles.inline.hpp&quot;
 40 #include &quot;runtime/java.hpp&quot;

 41 #include &quot;runtime/os.hpp&quot;
 42 #include &quot;runtime/safepointVerifiers.hpp&quot;
 43 #include &quot;runtime/sharedRuntime.hpp&quot;
 44 #include &quot;utilities/sizes.hpp&quot;
 45 #include &quot;utilities/xmlstream.hpp&quot;
 46 
 47 #include &lt;stdio.h&gt;
 48 
 49 #if 0
 50 static void metadata_oops_do(Metadata** metadata_begin, Metadata **metadata_end, OopClosure* f) {
 51   // Visit the metadata/oops section
 52   for (Metadata** p = metadata_begin; p &lt; metadata_end; p++) {
 53     Metadata* m = *p;
 54 
 55     intptr_t meta = (intptr_t)m;
 56     if ((meta &amp; 1) == 1) {
 57       // already resolved
 58       m = (Metadata*)(meta &amp; ~1);
 59     } else {
 60       continue;
</pre>
<hr />
<pre>
144       int signature_len = Bytes::get_Java_u2((address)klass_name + klass_len + 2 + method_name_len);
145       int full_len = 2 + klass_len + 2 + method_name_len + 2 + signature_len;
146       if (!klass_matched || memcmp(_name, meta_name, full_len) != 0) { // Does not match?
147         Thread* thread = Thread::current();
148         const char* method_name = klass_name + klass_len;
149         m = AOTCodeHeap::find_method(k, thread, method_name);
150       }
151       meta = ((intptr_t)m) | 1;
152       *entry = (Metadata*)meta; // Should be atomic on x64
153       return (Metadata*)m;
154     }
155   }
156   ShouldNotReachHere(); return NULL;
157 }
158 
159 void AOTCompiledMethod::do_unloading(bool unloading_occurred) {
160   unload_nmethod_caches(unloading_occurred);
161 }
162 
163 bool AOTCompiledMethod::make_not_entrant_helper(int new_state) {
<span class="line-removed">164   // Make sure the method is not flushed in case of a safepoint in code below.</span>
<span class="line-removed">165   methodHandle the_method(method());</span>
166   NoSafepointVerifier nsv;
167 
168   {
169     // Enter critical section.  Does not block for safepoint.
<span class="line-modified">170     MutexLockerEx pl(Patching_lock, Mutex::_no_safepoint_check_flag);</span>
171 
172     if (*_state_adr == new_state) {
173       // another thread already performed this transition so nothing
174       // to do, but return false to indicate this.
175       return false;
176     }
177 
178     // Change state
179     OrderAccess::storestore();
180     *_state_adr = new_state;
181 
182     // Log the transition once
183     log_state_change();
184 
185 #ifdef TIERED
186     // Remain non-entrant forever
187     if (new_state == not_entrant &amp;&amp; method() != NULL) {
188         method()-&gt;set_aot_code(NULL);
189     }
190 #endif
191 
192     // Remove AOTCompiledMethod from method.
<span class="line-modified">193     if (method() != NULL &amp;&amp; (method()-&gt;code() == this ||</span>
<span class="line-modified">194                              method()-&gt;from_compiled_entry() == verified_entry_point())) {</span>
<span class="line-removed">195       HandleMark hm;</span>
<span class="line-removed">196       method()-&gt;clear_code(false /* already owns Patching_lock */);</span>
197     }
<span class="line-modified">198   } // leave critical region under Patching_lock</span>
199 
200 
201   if (TraceCreateZombies) {
202     ResourceMark m;
203     const char *new_state_str = (new_state == not_entrant) ? &quot;not entrant&quot; : &quot;not used&quot;;
204     tty-&gt;print_cr(&quot;aot method &lt;&quot; INTPTR_FORMAT &quot;&gt; %s code made %s&quot;, p2i(this), this-&gt;method() ? this-&gt;method()-&gt;name_and_sig_as_C_string() : &quot;null&quot;, new_state_str);
205   }
206 
207   return true;
208 }
209 
210 #ifdef TIERED
211 bool AOTCompiledMethod::make_entrant() {
212   assert(!method()-&gt;is_old(), &quot;reviving evolved method!&quot;);
<span class="line-removed">213   assert(*_state_adr != not_entrant, &quot;%s&quot;, method()-&gt;has_aot_code() ? &quot;has_aot_code() not cleared&quot; : &quot;caller didn&#39;t check has_aot_code()&quot;);</span>
214 
<span class="line-removed">215   // Make sure the method is not flushed in case of a safepoint in code below.</span>
<span class="line-removed">216   methodHandle the_method(method());</span>
217   NoSafepointVerifier nsv;
<span class="line-removed">218 </span>
219   {
220     // Enter critical section.  Does not block for safepoint.
<span class="line-modified">221     MutexLockerEx pl(Patching_lock, Mutex::_no_safepoint_check_flag);</span>
222 
<span class="line-modified">223     if (*_state_adr == in_use) {</span>
224       // another thread already performed this transition so nothing
225       // to do, but return false to indicate this.
226       return false;
227     }
228 
229     // Change state
230     OrderAccess::storestore();
231     *_state_adr = in_use;
232 
233     // Log the transition once
234     log_state_change();
<span class="line-modified">235   } // leave critical region under Patching_lock</span>
236 
237 
238   if (TraceCreateZombies) {
239     ResourceMark m;
240     tty-&gt;print_cr(&quot;aot method &lt;&quot; INTPTR_FORMAT &quot;&gt; %s code made entrant&quot;, p2i(this), this-&gt;method() ? this-&gt;method()-&gt;name_and_sig_as_C_string() : &quot;null&quot;);
241   }
242 
243   return true;
244 }
245 #endif // TIERED
246 
247 // Iterate over metadata calling this function.   Used by RedefineClasses
248 // Copied from nmethod::metadata_do
<span class="line-modified">249 void AOTCompiledMethod::metadata_do(void f(Metadata*)) {</span>
250   address low_boundary = verified_entry_point();
251   {
252     // Visit all immediate references that are embedded in the instruction stream.
253     RelocIterator iter(this, low_boundary);
254     while (iter.next()) {
255       if (iter.type() == relocInfo::metadata_type ) {
256         metadata_Relocation* r = iter.metadata_reloc();
257         // In this metadata, we must only follow those metadatas directly embedded in
258         // the code.  Other metadatas (oop_index&gt;0) are seen as part of
259         // the metadata section below.
260         assert(1 == (r-&gt;metadata_is_immediate()) +
261                (r-&gt;metadata_addr() &gt;= metadata_begin() &amp;&amp; r-&gt;metadata_addr() &lt; metadata_end()),
262                &quot;metadata must be found in exactly one place&quot;);
263         if (r-&gt;metadata_is_immediate() &amp;&amp; r-&gt;metadata_value() != NULL) {
264           Metadata* md = r-&gt;metadata_value();
<span class="line-modified">265           if (md != _method) f(md);</span>
266         }
267       } else if (iter.type() == relocInfo::virtual_call_type) {
268         ResourceMark rm;
269         // Check compiledIC holders associated with this nmethod
270         CompiledIC *ic = CompiledIC_at(&amp;iter);
271         if (ic-&gt;is_icholder_call()) {
272           CompiledICHolder* cichk = ic-&gt;cached_icholder();
<span class="line-modified">273           f(cichk-&gt;holder_metadata());</span>
<span class="line-modified">274           f(cichk-&gt;holder_klass());</span>
275         } else {
276           // Get Klass* or NULL (if value is -1) from GOT cell of virtual call PLT stub.
277           Metadata* ic_oop = ic-&gt;cached_metadata();
278           if (ic_oop != NULL) {
<span class="line-modified">279             f(ic_oop);</span>
280           }
281         }
282       } else if (iter.type() == relocInfo::static_call_type ||
<span class="line-modified">283                  iter.type() == relocInfo::opt_virtual_call_type){</span>
284         // Check Method* in AOT c2i stub for other calls.
285         Metadata* meta = (Metadata*)nativeLoadGot_at(nativePltCall_at(iter.addr())-&gt;plt_c2i_stub())-&gt;data();
286         if (meta != NULL) {
<span class="line-modified">287           f(meta);</span>
288         }
289       }
290     }
291   }
292 
293   // Visit the metadata section
294   for (Metadata** p = metadata_begin(); p &lt; metadata_end(); p++) {
295     Metadata* m = *p;
296 
297     intptr_t meta = (intptr_t)m;
298     if ((meta &amp; 1) == 1) {
299       // already resolved
300       m = (Metadata*)(meta &amp; ~1);
301     } else {
302       continue;
303     }
304     assert(Metaspace::contains(m), &quot;&quot;);
<span class="line-modified">305     f(m);</span>
306   }
307 
308   // Visit metadata not embedded in the other places.
<span class="line-modified">309   if (_method != NULL) f(_method);</span>
310 }
311 
312 void AOTCompiledMethod::print() const {
313   print_on(tty, &quot;AOTCompiledMethod&quot;);
314 }
315 
316 void AOTCompiledMethod::print_on(outputStream* st) const {
317   print_on(st, &quot;AOTCompiledMethod&quot;);
318 }
319 
320 // Print out more verbose output usually for a newly created aot method.
321 void AOTCompiledMethod::print_on(outputStream* st, const char* msg) const {
322   if (st != NULL) {
323     ttyLocker ttyl;
324     st-&gt;print(&quot;%7d &quot;, (int) st-&gt;time_stamp().milliseconds());
325     st-&gt;print(&quot;%4d &quot;, _aot_id);    // print compilation number
326     st-&gt;print(&quot;    aot[%2d]&quot;, _heap-&gt;dso_id());
327     // Stubs have _method == NULL
328     if (_method == NULL) {
329       st-&gt;print(&quot;   %s&quot;, _name);
</pre>
</td>
<td>
<hr />
<pre>
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 
 26 #include &quot;aot/aotCodeHeap.hpp&quot;
 27 #include &quot;aot/aotLoader.hpp&quot;
 28 #include &quot;aot/compiledIC_aot.hpp&quot;
 29 #include &quot;code/codeCache.hpp&quot;
 30 #include &quot;code/compiledIC.hpp&quot;
 31 #include &quot;code/nativeInst.hpp&quot;
 32 #include &quot;compiler/compilerOracle.hpp&quot;
 33 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
 34 #include &quot;gc/shared/collectedHeap.hpp&quot;
<span class="line-modified"> 35 #include &quot;oops/klass.inline.hpp&quot;</span>

 36 #include &quot;oops/method.inline.hpp&quot;
 37 #include &quot;runtime/frame.inline.hpp&quot;
 38 #include &quot;runtime/handles.inline.hpp&quot;
 39 #include &quot;runtime/java.hpp&quot;
<span class="line-added"> 40 #include &quot;runtime/orderAccess.hpp&quot;</span>
 41 #include &quot;runtime/os.hpp&quot;
 42 #include &quot;runtime/safepointVerifiers.hpp&quot;
 43 #include &quot;runtime/sharedRuntime.hpp&quot;
 44 #include &quot;utilities/sizes.hpp&quot;
 45 #include &quot;utilities/xmlstream.hpp&quot;
 46 
 47 #include &lt;stdio.h&gt;
 48 
 49 #if 0
 50 static void metadata_oops_do(Metadata** metadata_begin, Metadata **metadata_end, OopClosure* f) {
 51   // Visit the metadata/oops section
 52   for (Metadata** p = metadata_begin; p &lt; metadata_end; p++) {
 53     Metadata* m = *p;
 54 
 55     intptr_t meta = (intptr_t)m;
 56     if ((meta &amp; 1) == 1) {
 57       // already resolved
 58       m = (Metadata*)(meta &amp; ~1);
 59     } else {
 60       continue;
</pre>
<hr />
<pre>
144       int signature_len = Bytes::get_Java_u2((address)klass_name + klass_len + 2 + method_name_len);
145       int full_len = 2 + klass_len + 2 + method_name_len + 2 + signature_len;
146       if (!klass_matched || memcmp(_name, meta_name, full_len) != 0) { // Does not match?
147         Thread* thread = Thread::current();
148         const char* method_name = klass_name + klass_len;
149         m = AOTCodeHeap::find_method(k, thread, method_name);
150       }
151       meta = ((intptr_t)m) | 1;
152       *entry = (Metadata*)meta; // Should be atomic on x64
153       return (Metadata*)m;
154     }
155   }
156   ShouldNotReachHere(); return NULL;
157 }
158 
159 void AOTCompiledMethod::do_unloading(bool unloading_occurred) {
160   unload_nmethod_caches(unloading_occurred);
161 }
162 
163 bool AOTCompiledMethod::make_not_entrant_helper(int new_state) {


164   NoSafepointVerifier nsv;
165 
166   {
167     // Enter critical section.  Does not block for safepoint.
<span class="line-modified">168     MutexLocker pl(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);</span>
169 
170     if (*_state_adr == new_state) {
171       // another thread already performed this transition so nothing
172       // to do, but return false to indicate this.
173       return false;
174     }
175 
176     // Change state
177     OrderAccess::storestore();
178     *_state_adr = new_state;
179 
180     // Log the transition once
181     log_state_change();
182 
183 #ifdef TIERED
184     // Remain non-entrant forever
185     if (new_state == not_entrant &amp;&amp; method() != NULL) {
186         method()-&gt;set_aot_code(NULL);
187     }
188 #endif
189 
190     // Remove AOTCompiledMethod from method.
<span class="line-modified">191     if (method() != NULL) {</span>
<span class="line-modified">192       method()-&gt;unlink_code(this);</span>


193     }
<span class="line-modified">194   } // leave critical region under CompiledMethod_lock</span>
195 
196 
197   if (TraceCreateZombies) {
198     ResourceMark m;
199     const char *new_state_str = (new_state == not_entrant) ? &quot;not entrant&quot; : &quot;not used&quot;;
200     tty-&gt;print_cr(&quot;aot method &lt;&quot; INTPTR_FORMAT &quot;&gt; %s code made %s&quot;, p2i(this), this-&gt;method() ? this-&gt;method()-&gt;name_and_sig_as_C_string() : &quot;null&quot;, new_state_str);
201   }
202 
203   return true;
204 }
205 
206 #ifdef TIERED
207 bool AOTCompiledMethod::make_entrant() {
208   assert(!method()-&gt;is_old(), &quot;reviving evolved method!&quot;);

209 


210   NoSafepointVerifier nsv;

211   {
212     // Enter critical section.  Does not block for safepoint.
<span class="line-modified">213     MutexLocker pl(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);</span>
214 
<span class="line-modified">215     if (*_state_adr == in_use || *_state_adr == not_entrant) {</span>
216       // another thread already performed this transition so nothing
217       // to do, but return false to indicate this.
218       return false;
219     }
220 
221     // Change state
222     OrderAccess::storestore();
223     *_state_adr = in_use;
224 
225     // Log the transition once
226     log_state_change();
<span class="line-modified">227   } // leave critical region under CompiledMethod_lock</span>
228 
229 
230   if (TraceCreateZombies) {
231     ResourceMark m;
232     tty-&gt;print_cr(&quot;aot method &lt;&quot; INTPTR_FORMAT &quot;&gt; %s code made entrant&quot;, p2i(this), this-&gt;method() ? this-&gt;method()-&gt;name_and_sig_as_C_string() : &quot;null&quot;);
233   }
234 
235   return true;
236 }
237 #endif // TIERED
238 
239 // Iterate over metadata calling this function.   Used by RedefineClasses
240 // Copied from nmethod::metadata_do
<span class="line-modified">241 void AOTCompiledMethod::metadata_do(MetadataClosure* f) {</span>
242   address low_boundary = verified_entry_point();
243   {
244     // Visit all immediate references that are embedded in the instruction stream.
245     RelocIterator iter(this, low_boundary);
246     while (iter.next()) {
247       if (iter.type() == relocInfo::metadata_type ) {
248         metadata_Relocation* r = iter.metadata_reloc();
249         // In this metadata, we must only follow those metadatas directly embedded in
250         // the code.  Other metadatas (oop_index&gt;0) are seen as part of
251         // the metadata section below.
252         assert(1 == (r-&gt;metadata_is_immediate()) +
253                (r-&gt;metadata_addr() &gt;= metadata_begin() &amp;&amp; r-&gt;metadata_addr() &lt; metadata_end()),
254                &quot;metadata must be found in exactly one place&quot;);
255         if (r-&gt;metadata_is_immediate() &amp;&amp; r-&gt;metadata_value() != NULL) {
256           Metadata* md = r-&gt;metadata_value();
<span class="line-modified">257           if (md != _method) f-&gt;do_metadata(md);</span>
258         }
259       } else if (iter.type() == relocInfo::virtual_call_type) {
260         ResourceMark rm;
261         // Check compiledIC holders associated with this nmethod
262         CompiledIC *ic = CompiledIC_at(&amp;iter);
263         if (ic-&gt;is_icholder_call()) {
264           CompiledICHolder* cichk = ic-&gt;cached_icholder();
<span class="line-modified">265           f-&gt;do_metadata(cichk-&gt;holder_metadata());</span>
<span class="line-modified">266           f-&gt;do_metadata(cichk-&gt;holder_klass());</span>
267         } else {
268           // Get Klass* or NULL (if value is -1) from GOT cell of virtual call PLT stub.
269           Metadata* ic_oop = ic-&gt;cached_metadata();
270           if (ic_oop != NULL) {
<span class="line-modified">271             f-&gt;do_metadata(ic_oop);</span>
272           }
273         }
274       } else if (iter.type() == relocInfo::static_call_type ||
<span class="line-modified">275                  iter.type() == relocInfo::opt_virtual_call_type) {</span>
276         // Check Method* in AOT c2i stub for other calls.
277         Metadata* meta = (Metadata*)nativeLoadGot_at(nativePltCall_at(iter.addr())-&gt;plt_c2i_stub())-&gt;data();
278         if (meta != NULL) {
<span class="line-modified">279           f-&gt;do_metadata(meta);</span>
280         }
281       }
282     }
283   }
284 
285   // Visit the metadata section
286   for (Metadata** p = metadata_begin(); p &lt; metadata_end(); p++) {
287     Metadata* m = *p;
288 
289     intptr_t meta = (intptr_t)m;
290     if ((meta &amp; 1) == 1) {
291       // already resolved
292       m = (Metadata*)(meta &amp; ~1);
293     } else {
294       continue;
295     }
296     assert(Metaspace::contains(m), &quot;&quot;);
<span class="line-modified">297     f-&gt;do_metadata(m);</span>
298   }
299 
300   // Visit metadata not embedded in the other places.
<span class="line-modified">301   if (_method != NULL) f-&gt;do_metadata(_method);</span>
302 }
303 
304 void AOTCompiledMethod::print() const {
305   print_on(tty, &quot;AOTCompiledMethod&quot;);
306 }
307 
308 void AOTCompiledMethod::print_on(outputStream* st) const {
309   print_on(st, &quot;AOTCompiledMethod&quot;);
310 }
311 
312 // Print out more verbose output usually for a newly created aot method.
313 void AOTCompiledMethod::print_on(outputStream* st, const char* msg) const {
314   if (st != NULL) {
315     ttyLocker ttyl;
316     st-&gt;print(&quot;%7d &quot;, (int) st-&gt;time_stamp().milliseconds());
317     st-&gt;print(&quot;%4d &quot;, _aot_id);    // print compilation number
318     st-&gt;print(&quot;    aot[%2d]&quot;, _heap-&gt;dso_id());
319     // Stubs have _method == NULL
320     if (_method == NULL) {
321       st-&gt;print(&quot;   %s&quot;, _name);
</pre>
</td>
</tr>
</table>
<center><a href="aotCodeHeap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="aotCompiledMethod.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
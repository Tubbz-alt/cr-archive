<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/aot/aotLoader.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;aot/aotCodeHeap.hpp&quot;
 26 #include &quot;aot/aotLoader.inline.hpp&quot;
 27 #include &quot;classfile/javaClasses.hpp&quot;
 28 #include &quot;jvm.h&quot;
 29 #include &quot;memory/allocation.inline.hpp&quot;
 30 #include &quot;memory/resourceArea.hpp&quot;
 31 #include &quot;oops/compressedOops.hpp&quot;
 32 #include &quot;oops/method.hpp&quot;
 33 #include &quot;runtime/handles.inline.hpp&quot;
 34 #include &quot;runtime/os.inline.hpp&quot;
 35 #include &quot;runtime/timerTrace.hpp&quot;
 36 
 37 GrowableArray&lt;AOTCodeHeap*&gt;* AOTLoader::_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray&lt;AOTCodeHeap*&gt; (2, true);
 38 GrowableArray&lt;AOTLib*&gt;* AOTLoader::_libraries = new(ResourceObj::C_HEAP, mtCode) GrowableArray&lt;AOTLib*&gt; (2, true);
 39 
 40 // Iterate over all AOT CodeHeaps
 41 #define FOR_ALL_AOT_HEAPS(heap) for (GrowableArrayIterator&lt;AOTCodeHeap*&gt; heap = heaps()-&gt;begin(); heap != heaps()-&gt;end(); ++heap)
 42 // Iterate over all AOT Libraries
 43 #define FOR_ALL_AOT_LIBRARIES(lib) for (GrowableArrayIterator&lt;AOTLib*&gt; lib = libraries()-&gt;begin(); lib != libraries()-&gt;end(); ++lib)
 44 
 45 void AOTLoader::load_for_klass(InstanceKlass* ik, Thread* thread) {
 46   if (ik-&gt;is_unsafe_anonymous()) {
 47     // don&#39;t even bother
 48     return;
 49   }
 50   if (UseAOT) {
 51     // We allow hotswap to be enabled after the onload phase, but not breakpoints
 52     assert(!JvmtiExport::can_post_breakpoint(), &quot;AOT should have been disabled.&quot;);
 53     FOR_ALL_AOT_HEAPS(heap) {
 54       (*heap)-&gt;load_klass_data(ik, thread);
 55     }
 56   }
 57 }
 58 
 59 uint64_t AOTLoader::get_saved_fingerprint(InstanceKlass* ik) {
 60   assert(UseAOT, &quot;called only when AOT is enabled&quot;);
 61   if (ik-&gt;is_unsafe_anonymous()) {
 62     // don&#39;t even bother
 63     return 0;
 64   }
 65   FOR_ALL_AOT_HEAPS(heap) {
 66     AOTKlassData* klass_data = (*heap)-&gt;find_klass(ik);
 67     if (klass_data != NULL) {
 68       return klass_data-&gt;_fingerprint;
 69     }
 70   }
 71   return 0;
 72 }
 73 
 74 void AOTLoader::oops_do(OopClosure* f) {
 75   if (UseAOT) {
 76     FOR_ALL_AOT_HEAPS(heap) {
 77       (*heap)-&gt;oops_do(f);
 78     }
 79   }
 80 }
 81 
 82 void AOTLoader::metadata_do(MetadataClosure* f) {
 83   if (UseAOT) {
 84     FOR_ALL_AOT_HEAPS(heap) {
 85       (*heap)-&gt;metadata_do(f);
 86     }
 87   }
 88 }
 89 
 90 void AOTLoader::mark_evol_dependent_methods(InstanceKlass* dependee) {
 91   if (UseAOT) {
 92     FOR_ALL_AOT_HEAPS(heap) {
 93       (*heap)-&gt;mark_evol_dependent_methods(dependee);
 94     }
 95   }
 96 }
 97 
 98 /**
 99  * List of core modules for which we search for shared libraries.
100  */
101 static const char* modules[] = {
102   &quot;java.base&quot;,
103   &quot;java.logging&quot;,
104   &quot;jdk.compiler&quot;,
105   &quot;jdk.scripting.nashorn&quot;,
106   &quot;jdk.internal.vm.ci&quot;,
107   &quot;jdk.internal.vm.compiler&quot;
108 };
109 
110 void AOTLoader::initialize() {
111   TraceTime timer(&quot;AOT initialization&quot;, TRACETIME_LOG(Info, aot, startuptime));
112 
113   if (FLAG_IS_DEFAULT(UseAOT) &amp;&amp; AOTLibrary != NULL) {
114     // Don&#39;t need to set UseAOT on command line when AOTLibrary is specified
115     FLAG_SET_DEFAULT(UseAOT, true);
116   }
117   if (UseAOT) {
118     // EagerInitialization is not compatible with AOT
119     if (EagerInitialization) {
120       if (PrintAOT) {
121         warning(&quot;EagerInitialization is not compatible with AOT (switching AOT off)&quot;);
122       }
123       FLAG_SET_DEFAULT(UseAOT, false);
124       return;
125     }
126 
127     if (JvmtiExport::can_post_breakpoint()) {
128       if (PrintAOT) {
129         warning(&quot;JVMTI capability to post breakpoint is not compatible with AOT (switching AOT off)&quot;);
130       }
131       FLAG_SET_DEFAULT(UseAOT, false);
132       return;
133     }
134 
135     // -Xint is not compatible with AOT
136     if (Arguments::is_interpreter_only()) {
137       if (PrintAOT) {
138         warning(&quot;-Xint is not compatible with AOT (switching AOT off)&quot;);
139       }
140       FLAG_SET_DEFAULT(UseAOT, false);
141       return;
142     }
143 
144 #ifdef _WINDOWS
145     const char pathSep = &#39;;&#39;;
146 #else
147     const char pathSep = &#39;:&#39;;
148 #endif
149 
150     // Scan the AOTLibrary option.
151     if (AOTLibrary != NULL) {
152       const int len = (int)strlen(AOTLibrary);
153       char* cp  = NEW_C_HEAP_ARRAY(char, len+1, mtCode);
154       memcpy(cp, AOTLibrary, len);
155       cp[len] = &#39;\0&#39;;
156       char* end = cp + len;
157       while (cp &lt; end) {
158         const char* name = cp;
159         while ((*cp) != &#39;\0&#39; &amp;&amp; (*cp) != &#39;\n&#39; &amp;&amp; (*cp) != &#39;,&#39; &amp;&amp; (*cp) != pathSep) cp++;
160         cp[0] = &#39;\0&#39;;  // Terminate name
161         cp++;
162         load_library(name, true);
163       }
164     }
165 
166     // Load well-know AOT libraries from Java installation directory.
167     const char* home = Arguments::get_java_home();
168     const char* file_separator = os::file_separator();
169 
170     for (int i = 0; i &lt; (int) (sizeof(modules) / sizeof(const char*)); i++) {
171       char library[JVM_MAXPATHLEN];
172       jio_snprintf(library, sizeof(library), &quot;%s%slib%slib%s%s%s%s&quot;, home, file_separator, file_separator, modules[i], UseCompressedOops ? &quot;-coop&quot; : &quot;&quot;, UseG1GC ? &quot;&quot; : &quot;-nong1&quot;, os::dll_file_extension());
173       load_library(library, false);
174     }
175   }
176 }
177 
178 void AOTLoader::universe_init() {
179   if (UseAOT &amp;&amp; libraries_count() &gt; 0) {
180     // Shifts are static values which initialized by 0 until java heap initialization.
181     // AOT libs are loaded before heap initialized so shift values are not set.
182     // It is okay since ObjectAlignmentInBytes flag which defines shifts value is set before AOT libs are loaded.
183     // AOT sets shift values during heap and metaspace initialization.
184     // Check shifts value to make sure thay did not change.
185     if (UseCompressedOops &amp;&amp; AOTLib::narrow_oop_shift_initialized()) {
186       int oop_shift = CompressedOops::shift();
187       FOR_ALL_AOT_LIBRARIES(lib) {
188         (*lib)-&gt;verify_flag((*lib)-&gt;config()-&gt;_narrowOopShift, oop_shift, &quot;CompressedOops::shift&quot;);
189       }
190       if (UseCompressedClassPointers) { // It is set only if UseCompressedOops is set
191         int klass_shift = CompressedKlassPointers::shift();
192         FOR_ALL_AOT_LIBRARIES(lib) {
193           (*lib)-&gt;verify_flag((*lib)-&gt;config()-&gt;_narrowKlassShift, klass_shift, &quot;CompressedKlassPointers::shift&quot;);
194         }
195       }
196     }
197     // Create heaps for all valid libraries
198     FOR_ALL_AOT_LIBRARIES(lib) {
199       if ((*lib)-&gt;is_valid()) {
200         AOTCodeHeap* heap = new AOTCodeHeap(*lib);
201         {
202           MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
203           add_heap(heap);
204           CodeCache::add_heap(heap);
205         }
206       } else {
207         // Unload invalid libraries
208         os::dll_unload((*lib)-&gt;dl_handle());
209       }
210     }
211   }
212   if (heaps_count() == 0) {
213     if (FLAG_IS_DEFAULT(UseAOT)) {
214       FLAG_SET_DEFAULT(UseAOT, false);
215     }
216   }
217 }
218 
219 // Set shift value for compressed oops and classes based on first AOT library config.
220 // AOTLoader::universe_init(), which is called later, will check the shift value again to make sure nobody change it.
221 // This code is not executed during CDS dump because it runs in Interpreter mode and AOT is disabled in this mode.
222 
223 void AOTLoader::set_narrow_oop_shift() {
224   // This method is called from Universe::initialize_heap().
225   if (UseAOT &amp;&amp; libraries_count() &gt; 0 &amp;&amp;
226       UseCompressedOops &amp;&amp; AOTLib::narrow_oop_shift_initialized()) {
227     if (CompressedOops::shift() == 0) {
228       // 0 is valid shift value for small heap but we can safely increase it
229       // at this point when nobody used it yet.
230       CompressedOops::set_shift(AOTLib::narrow_oop_shift());
231     }
232   }
233 }
234 
235 void AOTLoader::set_narrow_klass_shift() {
236   // This method is called from Metaspace::set_narrow_klass_base_and_shift().
237   if (UseAOT &amp;&amp; libraries_count() &gt; 0 &amp;&amp;
238       UseCompressedOops &amp;&amp; AOTLib::narrow_oop_shift_initialized() &amp;&amp;
239       UseCompressedClassPointers) {
240     if (CompressedKlassPointers::shift() == 0) {
241       CompressedKlassPointers::set_shift(AOTLib::narrow_klass_shift());
242     }
243   }
244 }
245 
246 void AOTLoader::load_library(const char* name, bool exit_on_error) {
247   // Skip library if a library with the same name is already loaded.
248   const int file_separator = *os::file_separator();
249   const char* start = strrchr(name, file_separator);
250   const char* new_name = (start == NULL) ? name : (start + 1);
251   FOR_ALL_AOT_LIBRARIES(lib) {
252     const char* lib_name = (*lib)-&gt;name();
253     start = strrchr(lib_name, file_separator);
254     const char* old_name = (start == NULL) ? lib_name : (start + 1);
255     if (strcmp(old_name, new_name) == 0) {
256       if (PrintAOT) {
257         warning(&quot;AOT library %s is already loaded as %s.&quot;, name, lib_name);
258       }
259       return;
260     }
261   }
262   char ebuf[1024];
263   void* handle = os::dll_load(name, ebuf, sizeof ebuf);
264   if (handle == NULL) {
265     if (exit_on_error) {
266       tty-&gt;print_cr(&quot;error opening file: %s&quot;, ebuf);
267       vm_exit(1);
268     }
269     return;
270   }
271   const int dso_id = libraries_count() + 1;
272   AOTLib* lib = new AOTLib(handle, name, dso_id);
273   if (!lib-&gt;is_valid()) {
274     delete lib;
275     os::dll_unload(handle);
276     return;
277   }
278   add_library(lib);
279 }
280 
281 #ifndef PRODUCT
282 void AOTLoader::print_statistics() {
283   { ttyLocker ttyl;
284     tty-&gt;print_cr(&quot;--- AOT Statistics ---&quot;);
285     tty-&gt;print_cr(&quot;AOT libraries loaded: %d&quot;, heaps_count());
286     AOTCodeHeap::print_statistics();
287   }
288 }
289 #endif
290 
291 
292 bool AOTLoader::reconcile_dynamic_invoke(InstanceKlass* holder, int index, Method* adapter_method, Klass* appendix_klass) {
293   if (!UseAOT) {
294     return true;
295   }
296   JavaThread* thread = JavaThread::current();
297   ResourceMark rm(thread);
298   RegisterMap map(thread, false);
299   frame caller_frame = thread-&gt;last_frame().sender(&amp;map); // Skip stub
300   CodeBlob* caller_cb = caller_frame.cb();
301   guarantee(caller_cb != NULL &amp;&amp; caller_cb-&gt;is_compiled(), &quot;must be called from compiled method&quot;);
302   CompiledMethod* cm = caller_cb-&gt;as_compiled_method();
303 
304   if (!cm-&gt;is_aot()) {
305     return true;
306   }
307   AOTCompiledMethod* aot = (AOTCompiledMethod*)cm;
308 
309   AOTCodeHeap* caller_heap = NULL;
310   FOR_ALL_AOT_HEAPS(heap) {
311     if ((*heap)-&gt;contains_blob(aot)) {
312       caller_heap = *heap;
313       break;
314     }
315   }
316   guarantee(caller_heap != NULL, &quot;CodeHeap not found&quot;);
317   bool success = caller_heap-&gt;reconcile_dynamic_invoke(aot, holder, index, adapter_method, appendix_klass);
318   vmassert(success || thread-&gt;last_frame().sender(&amp;map).is_deoptimized_frame(), &quot;caller not deoptimized on failure&quot;);
319   return success;
320 }
321 
322 
323 // This should be called very early during startup before any of the AOTed methods that use boxes can deoptimize.
324 // Deoptimization machinery expects the caches to be present and populated.
325 void AOTLoader::initialize_box_caches(TRAPS) {
326   if (!UseAOT || libraries_count() == 0) {
327     return;
328   }
329   TraceTime timer(&quot;AOT initialization of box caches&quot;, TRACETIME_LOG(Info, aot, startuptime));
330   Symbol* box_classes[] = { java_lang_Boolean::symbol(), java_lang_Byte_ByteCache::symbol(),
331     java_lang_Short_ShortCache::symbol(), java_lang_Character_CharacterCache::symbol(),
332     java_lang_Integer_IntegerCache::symbol(), java_lang_Long_LongCache::symbol() };
333 
334   for (unsigned i = 0; i &lt; sizeof(box_classes) / sizeof(Symbol*); i++) {
335     Klass* k = SystemDictionary::resolve_or_fail(box_classes[i], true, CHECK);
336     InstanceKlass* ik = InstanceKlass::cast(k);
337     if (ik-&gt;is_not_initialized()) {
338       ik-&gt;initialize(CHECK);
339     }
340   }
341 }
    </pre>
  </body>
</html>
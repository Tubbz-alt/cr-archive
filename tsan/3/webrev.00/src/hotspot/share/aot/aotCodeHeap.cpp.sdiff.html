<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/aot/aotCodeHeap.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../adlc/output_h.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="aotCodeHeap.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/aot/aotCodeHeap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 
  26 #include &quot;aot/aotCodeHeap.hpp&quot;
  27 #include &quot;aot/aotLoader.hpp&quot;
  28 #include &quot;ci/ciUtilities.inline.hpp&quot;
  29 #include &quot;classfile/javaAssertions.hpp&quot;
  30 #include &quot;gc/shared/cardTable.hpp&quot;
  31 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  32 #include &quot;gc/shared/gcConfig.hpp&quot;
  33 #include &quot;gc/g1/heapRegion.hpp&quot;
  34 #include &quot;interpreter/abstractInterpreter.hpp&quot;
  35 #include &quot;jvmci/compilerRuntime.hpp&quot;
  36 #include &quot;jvmci/jvmciRuntime.hpp&quot;

  37 #include &quot;memory/allocation.inline.hpp&quot;



  38 #include &quot;oops/method.inline.hpp&quot;


  39 #include &quot;runtime/handles.inline.hpp&quot;
  40 #include &quot;runtime/os.hpp&quot;
  41 #include &quot;runtime/safepointVerifiers.hpp&quot;
  42 #include &quot;runtime/sharedRuntime.hpp&quot;
  43 #include &quot;runtime/vmOperations.hpp&quot;

  44 #include &quot;utilities/sizes.hpp&quot;
  45 
  46 bool AOTLib::_narrow_oop_shift_initialized = false;
  47 int  AOTLib::_narrow_oop_shift = 0;
  48 int  AOTLib::_narrow_klass_shift = 0;
  49 
  50 address AOTLib::load_symbol(const char *name) {
  51   address symbol = (address) os::dll_lookup(_dl_handle, name);
  52   if (symbol == NULL) {
  53     tty-&gt;print_cr(&quot;Shared file %s error: missing %s&quot;, _name, name);
  54     vm_exit(1);
  55   }
  56   return symbol;
  57 }
  58 
  59 Klass* AOTCodeHeap::get_klass_from_got(const char* klass_name, int klass_len, const Method* method) {
  60   AOTKlassData* klass_data = (AOTKlassData*)_lib-&gt;load_symbol(klass_name);
  61   Klass* k = (Klass*)_klasses_got[klass_data-&gt;_got_index];
  62   if (k == NULL) {
  63     Thread* thread = Thread::current();
</pre>
<hr />
<pre>
  72     if (k-&gt;is_instance_klass()) {
  73       InstanceKlass* ik = InstanceKlass::cast(k);
  74       if (ik-&gt;is_initialized()) {
  75         _klasses_got[klass_data-&gt;_got_index - 1] = ik;
  76       }
  77     }
  78   }
  79   return k;
  80 }
  81 
  82 Klass* AOTCodeHeap::lookup_klass(const char* name, int len, const Method* method, Thread* thread) {
  83   ResourceMark rm(thread);
  84   assert(method != NULL, &quot;incorrect call parameter&quot;);
  85   methodHandle caller(thread, (Method*)method);
  86 
  87   // Use class loader of aot method.
  88   Handle loader(thread, caller-&gt;method_holder()-&gt;class_loader());
  89   Handle protection_domain(thread, caller-&gt;method_holder()-&gt;protection_domain());
  90 
  91   // Ignore wrapping L and ;
<span class="line-modified">  92   if (name[0] == &#39;L&#39;) {</span>
  93     assert(len &gt; 2, &quot;small name %s&quot;, name);
  94     name++;
  95     len -= 2;
  96   }
  97   TempNewSymbol sym = SymbolTable::probe(name, len);
  98   if (sym == NULL) {
  99     log_debug(aot, class, resolve)(&quot;Probe failed for AOT class %s&quot;, name);
 100     return NULL;
 101   }
 102   Klass* k = SystemDictionary::find_instance_or_array_klass(sym, loader, protection_domain, thread);
 103   assert(!thread-&gt;has_pending_exception(), &quot;should not throw&quot;);
 104 
 105   if (k != NULL) {
 106     log_info(aot, class, resolve)(&quot;%s %s (lookup)&quot;, caller-&gt;method_holder()-&gt;external_name(), k-&gt;external_name());
 107   }
 108   return k;
 109 }
 110 
 111 void AOTLib::handle_config_error(const char* format, ...) {
 112   if (PrintAOT) {
</pre>
<hr />
<pre>
 158   verify_flag(_config-&gt;_debug_VM, true, &quot;Debug VM version&quot;);
 159 #else
 160   verify_flag(!(_config-&gt;_debug_VM), true, &quot;Product VM version&quot;);
 161 #endif
 162   // Check configuration size
 163   verify_flag(_config-&gt;_config_size, AOTConfiguration::CONFIG_SIZE, &quot;AOT configuration size&quot;);
 164 
 165   // Check GC
 166   CollectedHeap::Name gc = (CollectedHeap::Name)_config-&gt;_gc;
 167   if (_valid &amp;&amp; !GCConfig::is_gc_selected(gc)) {
 168     handle_config_error(&quot;Shared file %s error: used &#39;%s&#39; is different from current &#39;%s&#39;&quot;, _name, GCConfig::hs_err_name(gc), GCConfig::hs_err_name());
 169   }
 170 
 171   // Check flags
 172   verify_flag(_config-&gt;_useCompressedOops, UseCompressedOops, &quot;UseCompressedOops&quot;);
 173   verify_flag(_config-&gt;_useCompressedClassPointers, UseCompressedClassPointers, &quot;UseCompressedClassPointers&quot;);
 174   verify_flag(_config-&gt;_useTLAB, UseTLAB, &quot;UseTLAB&quot;);
 175   verify_flag(_config-&gt;_useBiasedLocking, UseBiasedLocking, &quot;UseBiasedLocking&quot;);
 176   verify_flag(_config-&gt;_objectAlignment, ObjectAlignmentInBytes, &quot;ObjectAlignmentInBytes&quot;);
 177   verify_flag(_config-&gt;_contendedPaddingWidth, ContendedPaddingWidth, &quot;ContendedPaddingWidth&quot;);
<span class="line-removed"> 178   verify_flag(_config-&gt;_fieldsAllocationStyle, FieldsAllocationStyle, &quot;FieldsAllocationStyle&quot;);</span>
<span class="line-removed"> 179   verify_flag(_config-&gt;_compactFields, CompactFields, &quot;CompactFields&quot;);</span>
 180   verify_flag(_config-&gt;_enableContended, EnableContended, &quot;EnableContended&quot;);
 181   verify_flag(_config-&gt;_restrictContended, RestrictContended, &quot;RestrictContended&quot;);
<span class="line-removed"> 182   verify_flag(_config-&gt;_threadLocalHandshakes, ThreadLocalHandshakes, &quot;ThreadLocalHandshakes&quot;);</span>
 183 
 184   if (!TieredCompilation &amp;&amp; _config-&gt;_tieredAOT) {
 185     handle_config_error(&quot;Shared file %s error: Expected to run with tiered compilation on&quot;, _name);
 186   }
 187 
 188   // Shifts are static values which initialized by 0 until java heap initialization.
 189   // AOT libs are loaded before heap initialized so shift values are not set.
 190   // It is okay since ObjectAlignmentInBytes flag which defines shifts value is set before AOT libs are loaded.
 191   // Set shifts value based on first AOT library config.
 192   if (UseCompressedOops &amp;&amp; _valid) {
 193     if (!_narrow_oop_shift_initialized) {
 194       _narrow_oop_shift = _config-&gt;_narrowOopShift;
 195       if (UseCompressedClassPointers) { // It is set only if UseCompressedOops is set
 196         _narrow_klass_shift = _config-&gt;_narrowKlassShift;
 197       }
 198       _narrow_oop_shift_initialized = true;
 199     } else {
 200       verify_flag(_config-&gt;_narrowOopShift, _narrow_oop_shift, &quot;aot_config-&gt;_narrowOopShift&quot;);
 201       if (UseCompressedClassPointers) { // It is set only if UseCompressedOops is set
 202         verify_flag(_config-&gt;_narrowKlassShift, _narrow_klass_shift, &quot;aot_config-&gt;_narrowKlassShift&quot;);
 203       }
 204     }
 205   }
 206 }
 207 
 208 AOTLib::~AOTLib() {
 209   os::free((void*) _name);
 210 }
 211 
 212 AOTCodeHeap::~AOTCodeHeap() {
<span class="line-modified"> 213   if (_classes != NULL) {</span>
<span class="line-modified"> 214     FREE_C_HEAP_ARRAY(AOTClass, _classes);</span>
<span class="line-removed"> 215   }</span>
<span class="line-removed"> 216   if (_code_to_aot != NULL) {</span>
<span class="line-removed"> 217     FREE_C_HEAP_ARRAY(CodeToAMethod, _code_to_aot);</span>
<span class="line-removed"> 218   }</span>
 219 }
 220 
 221 AOTLib::AOTLib(void* handle, const char* name, int dso_id) : _valid(true), _dl_handle(handle), _dso_id(dso_id) {
 222   _name = (const char*) os::strdup(name);
 223 
 224   // Verify that VM runs with the same parameters as AOT tool.
 225   _config = (AOTConfiguration*) load_symbol(&quot;A.config&quot;);
 226   _header = (AOTHeader*) load_symbol(&quot;A.header&quot;);
 227 
 228   verify_config();
 229 
 230   if (!_valid &amp;&amp; PrintAOT) {
 231       tty-&gt;print(&quot;%7d &quot;, (int) tty-&gt;time_stamp().milliseconds());
 232       tty-&gt;print_cr(&quot;%4d     skipped %s  aot library&quot;, _dso_id, _name);
 233   }
 234 }
 235 
 236 AOTCodeHeap::AOTCodeHeap(AOTLib* lib) :
 237     CodeHeap(&quot;CodeHeap &#39;AOT&#39;&quot;, CodeBlobType::AOT), _lib(lib), _classes(NULL), _code_to_aot(NULL) {
 238   assert(_lib-&gt;is_valid(), &quot;invalid library&quot;);
</pre>
<hr />
<pre>
 329 
 330   jlong* state_adr = &amp;_method_state[code_id];
 331   address metadata_table = method_data-&gt;_metadata_table;
 332   int metadata_size = method_data-&gt;_metadata_size;
 333   assert(code_id &lt; _method_count, &quot;sanity&quot;);
 334   _aot_id++;
 335 
 336 #ifdef ASSERT
 337   if (_aot_id &gt; CIStop || _aot_id &lt; CIStart) {
 338     // Skip compilation
 339     return;
 340   }
 341 #endif
 342   // Check one more time.
 343   if (_code_to_aot[code_id]._state == invalid) {
 344     return;
 345   }
 346   AOTCompiledMethod *aot = new AOTCompiledMethod(code, mh(), meta, metadata_table, metadata_size, state_adr, this, name, code_id, _aot_id);
 347   assert(_code_to_aot[code_id]._aot == NULL, &quot;should be not initialized&quot;);
 348   _code_to_aot[code_id]._aot = aot; // Should set this first
<span class="line-modified"> 349   if (Atomic::cmpxchg(in_use, &amp;_code_to_aot[code_id]._state, not_set) != not_set) {</span>
 350     _code_to_aot[code_id]._aot = NULL; // Clean
 351   } else { // success
 352     // Publish method
 353 #ifdef TIERED
 354     mh-&gt;set_aot_code(aot);
 355 #endif
<span class="line-modified"> 356     Method::set_code(mh, aot);</span>



 357     if (PrintAOT || (PrintCompilation &amp;&amp; PrintAOT)) {
 358       PauseNoSafepointVerifier pnsv(&amp;nsv); // aot code is registered already
 359       aot-&gt;print_on(tty, NULL);
 360     }
 361     // Publish oop only after we are visible to CompiledMethodIterator
 362     aot-&gt;set_oop(mh()-&gt;method_holder()-&gt;klass_holder());
 363   }
 364 }
 365 
 366 void AOTCodeHeap::link_primitive_array_klasses() {
 367   ResourceMark rm;
 368   for (int i = T_BOOLEAN; i &lt;= T_CONFLICT; i++) {
 369     BasicType t = (BasicType)i;
 370     if (is_java_primitive(t)) {
 371       const Klass* arr_klass = Universe::typeArrayKlassObj(t);
 372       AOTKlassData* klass_data = (AOTKlassData*) os::dll_lookup(_lib-&gt;dl_handle(), arr_klass-&gt;signature_name());
 373       if (klass_data != NULL) {
 374         // Set both GOT cells, resolved and initialized klass pointers.
 375         // _got_index points to second cell - resolved klass pointer.
 376         _klasses_got[klass_data-&gt;_got_index-1] = (Metadata*)arr_klass; // Initialized
</pre>
<hr />
<pre>
 382     }
 383   }
 384 }
 385 
 386 void AOTCodeHeap::register_stubs() {
 387   int stubs_count = _stubs_offsets[0]; // contains number
 388   _stubs_offsets++;
 389   AOTMethodOffsets* stub_offsets = (AOTMethodOffsets*)_stubs_offsets;
 390   for (int i = 0; i &lt; stubs_count; ++i) {
 391     const char* stub_name = _metaspace_names + stub_offsets[i]._name_offset;
 392     address entry = _code_space  + stub_offsets[i]._code_offset;
 393     aot_metadata* meta = (aot_metadata *) (_method_metadata + stub_offsets[i]._meta_offset);
 394     address metadata_table = (address)_metadata_got + stub_offsets[i]._metadata_got_offset;
 395     int metadata_size = stub_offsets[i]._metadata_got_size;
 396     int code_id = stub_offsets[i]._code_id;
 397     assert(code_id &lt; _method_count, &quot;sanity&quot;);
 398     jlong* state_adr = &amp;_method_state[code_id];
 399     int len = Bytes::get_Java_u2((address)stub_name);
 400     stub_name += 2;
 401     char* full_name = NEW_C_HEAP_ARRAY(char, len+5, mtCode);
<span class="line-removed"> 402     if (full_name == NULL) { // No memory?</span>
<span class="line-removed"> 403       break;</span>
<span class="line-removed"> 404     }</span>
 405     memcpy(full_name, &quot;AOT &quot;, 4);
 406     memcpy(full_name+4, stub_name, len);
 407     full_name[len+4] = 0;
 408     guarantee(_code_to_aot[code_id]._state != invalid, &quot;stub %s can&#39;t be invalidated&quot;, full_name);
 409     AOTCompiledMethod* aot = new AOTCompiledMethod(entry, NULL, meta, metadata_table, metadata_size, state_adr, this, full_name, code_id, i);
 410     assert(_code_to_aot[code_id]._aot  == NULL, &quot;should be not initialized&quot;);
 411     _code_to_aot[code_id]._aot  = aot;
<span class="line-modified"> 412     if (Atomic::cmpxchg(in_use, &amp;_code_to_aot[code_id]._state, not_set) != not_set) {</span>
 413       fatal(&quot;stab &#39;%s&#39; code state is %d&quot;, full_name, _code_to_aot[code_id]._state);
 414     }
 415     // Adjust code buffer boundaries only for stubs because they are last in the buffer.
 416     adjust_boundaries(aot);
 417     if (PrintAOT &amp;&amp; Verbose) {
 418       aot-&gt;print_on(tty, NULL);
 419     }
 420   }
 421 }
 422 
 423 #define SET_AOT_GLOBAL_SYMBOL_VALUE(AOTSYMNAME, AOTSYMTYPE, VMSYMVAL) \
 424   {                                                                   \
 425     AOTSYMTYPE * adr = (AOTSYMTYPE *) os::dll_lookup(_lib-&gt;dl_handle(), AOTSYMNAME);  \
 426     /* Check for a lookup error */                                    \
 427     guarantee(adr != NULL, &quot;AOT Symbol not found %s&quot;, AOTSYMNAME);    \
 428     *adr = (AOTSYMTYPE) VMSYMVAL;                                     \
 429   }
 430 
 431 void AOTCodeHeap::link_graal_runtime_symbols()  {
 432     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_monitorenter&quot;, address, JVMCIRuntime::monitorenter);
 433     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_monitorexit&quot;, address, JVMCIRuntime::monitorexit);
 434     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_log_object&quot;, address, JVMCIRuntime::log_object);
 435     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_log_printf&quot;, address, JVMCIRuntime::log_printf);
 436     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_log_primitive&quot;, address, JVMCIRuntime::log_primitive);
 437     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_new_instance&quot;, address, JVMCIRuntime::new_instance);
 438     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_new_array&quot;, address, JVMCIRuntime::new_array);
 439     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_new_multi_array&quot;, address, JVMCIRuntime::new_multi_array);
 440     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_dynamic_new_instance&quot;, address, JVMCIRuntime::dynamic_new_instance);
 441     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_dynamic_new_array&quot;, address, JVMCIRuntime::dynamic_new_array);
 442     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_new_instance_or_null&quot;, address, JVMCIRuntime::new_instance_or_null);
 443     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_new_array_or_null&quot;, address, JVMCIRuntime::new_array_or_null);
 444     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_new_multi_array_or_null&quot;, address, JVMCIRuntime::new_multi_array_or_null);
 445     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_dynamic_new_instance_or_null&quot;, address, JVMCIRuntime::dynamic_new_instance_or_null);
 446     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_dynamic_new_array_or_null&quot;, address, JVMCIRuntime::dynamic_new_array_or_null);
 447     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_validate_object&quot;, address, JVMCIRuntime::validate_object);
 448 #if INCLUDE_G1GC
 449     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_write_barrier_pre&quot;, address, JVMCIRuntime::write_barrier_pre);
 450     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_write_barrier_post&quot;, address, JVMCIRuntime::write_barrier_post);
 451 #endif
 452     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_identity_hash_code&quot;, address, JVMCIRuntime::identity_hash_code);
<span class="line-removed"> 453     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_thread_is_interrupted&quot;, address, JVMCIRuntime::thread_is_interrupted);</span>
 454     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_exception_handler_for_pc&quot;, address, JVMCIRuntime::exception_handler_for_pc);
 455     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_test_deoptimize_call_int&quot;, address, JVMCIRuntime::test_deoptimize_call_int);
 456     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_throw_and_post_jvmti_exception&quot;, address, JVMCIRuntime::throw_and_post_jvmti_exception);
 457     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_throw_klass_external_name_exception&quot;, address, JVMCIRuntime::throw_klass_external_name_exception);
 458     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_throw_class_cast_exception&quot;, address, JVMCIRuntime::throw_class_cast_exception);
 459     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_vm_message&quot;, address, JVMCIRuntime::vm_message);
 460     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_vm_error&quot;, address, JVMCIRuntime::vm_error);
 461 }
 462 
 463 void AOTCodeHeap::link_shared_runtime_symbols() {
 464     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_resolve_static_entry&quot;, address, SharedRuntime::get_resolve_static_call_stub());
 465     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_resolve_virtual_entry&quot;, address, SharedRuntime::get_resolve_virtual_call_stub());
 466     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_resolve_opt_virtual_entry&quot;, address, SharedRuntime::get_resolve_opt_virtual_call_stub());
 467     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_deopt_blob_unpack&quot;, address, SharedRuntime::deopt_blob()-&gt;unpack());

 468     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_deopt_blob_uncommon_trap&quot;, address, SharedRuntime::deopt_blob()-&gt;uncommon_trap());
 469     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_ic_miss_stub&quot;, address, SharedRuntime::get_ic_miss_stub());
 470     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_handle_wrong_method_stub&quot;, address, SharedRuntime::get_handle_wrong_method_stub());
 471     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_exception_handler_for_return_address&quot;, address, SharedRuntime::exception_handler_for_return_address);
 472     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_register_finalizer&quot;, address, SharedRuntime::register_finalizer);
 473     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_object_notify&quot;, address, JVMCIRuntime::object_notify);
 474     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_object_notifyAll&quot;, address, JVMCIRuntime::object_notifyAll);
 475     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_OSR_migration_end&quot;, address, SharedRuntime::OSR_migration_end);
 476     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_enable_stack_reserved_zone&quot;, address, SharedRuntime::enable_stack_reserved_zone);
 477     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_resolve_dynamic_invoke&quot;, address, CompilerRuntime::resolve_dynamic_invoke);
 478     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_resolve_string_by_symbol&quot;, address, CompilerRuntime::resolve_string_by_symbol);
 479     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_resolve_klass_by_symbol&quot;, address, CompilerRuntime::resolve_klass_by_symbol);
 480     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_resolve_method_by_symbol_and_load_counters&quot;, address, CompilerRuntime::resolve_method_by_symbol_and_load_counters);
 481     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_initialize_klass_by_symbol&quot;, address, CompilerRuntime::initialize_klass_by_symbol);
 482     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_invocation_event&quot;, address, CompilerRuntime::invocation_event);
 483     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_backedge_event&quot;, address, CompilerRuntime::backedge_event);
 484 
 485     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_shared_runtime_dpow&quot;, address, SharedRuntime::dpow);
 486     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_shared_runtime_dexp&quot;, address, SharedRuntime::dexp);
 487     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_shared_runtime_dcos&quot;, address, SharedRuntime::dcos);
</pre>
<hr />
<pre>
 513     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_arrayof_oop_arraycopy&quot;, address, StubRoutines::_arrayof_oop_arraycopy);
 514     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_arrayof_oop_arraycopy_uninit&quot;, address, StubRoutines::_arrayof_oop_arraycopy_uninit);
 515 
 516     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_arrayof_jbyte_disjoint_arraycopy&quot;, address, StubRoutines::_arrayof_jbyte_disjoint_arraycopy);
 517     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_arrayof_jshort_disjoint_arraycopy&quot;, address, StubRoutines::_arrayof_jshort_disjoint_arraycopy);
 518     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_arrayof_jint_disjoint_arraycopy&quot;, address, StubRoutines::_arrayof_jint_disjoint_arraycopy);
 519     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_arrayof_jlong_disjoint_arraycopy&quot;, address, StubRoutines::_arrayof_jlong_disjoint_arraycopy);
 520     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_arrayof_oop_disjoint_arraycopy&quot;, address, StubRoutines::_arrayof_oop_disjoint_arraycopy);
 521     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_arrayof_oop_disjoint_arraycopy_uninit&quot;, address, StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit);
 522 
 523     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_unsafe_arraycopy&quot;, address, StubRoutines::_unsafe_arraycopy);
 524 
 525     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_checkcast_arraycopy&quot;, address, StubRoutines::_checkcast_arraycopy);
 526 
 527     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_generic_arraycopy&quot;, address, StubRoutines::_generic_arraycopy);
 528 
 529     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_aescrypt_encryptBlock&quot;, address, StubRoutines::_aescrypt_encryptBlock);
 530     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_aescrypt_decryptBlock&quot;, address, StubRoutines::_aescrypt_decryptBlock);
 531     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_cipherBlockChaining_encryptAESCrypt&quot;, address, StubRoutines::_cipherBlockChaining_encryptAESCrypt);
 532     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_cipherBlockChaining_decryptAESCrypt&quot;, address, StubRoutines::_cipherBlockChaining_decryptAESCrypt);


 533     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_update_bytes_crc32&quot;, address, StubRoutines::_updateBytesCRC32);
 534     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_crc_table_adr&quot;, address, StubRoutines::_crc_table_adr);
 535 
 536 
 537     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_sha1_implCompress&quot;, address, StubRoutines::_sha1_implCompress);
 538     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_sha1_implCompressMB&quot;, address, StubRoutines::_sha1_implCompressMB);
 539     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_sha256_implCompress&quot;, address, StubRoutines::_sha256_implCompress);
 540     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_sha256_implCompressMB&quot;, address, StubRoutines::_sha256_implCompressMB);
 541     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_sha512_implCompress&quot;, address, StubRoutines::_sha512_implCompress);
 542     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_sha512_implCompressMB&quot;, address, StubRoutines::_sha512_implCompressMB);
 543     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_multiplyToLen&quot;, address, StubRoutines::_multiplyToLen);
 544 
 545     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_counterMode_AESCrypt&quot;, address, StubRoutines::_counterMode_AESCrypt);
 546     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_ghash_processBlocks&quot;, address, StubRoutines::_ghash_processBlocks);
 547     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_base64_encodeBlock&quot;, address, StubRoutines::_base64_encodeBlock);
 548     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_crc32c_table_addr&quot;, address, StubRoutines::_crc32c_table_addr);
 549     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_updateBytesCRC32C&quot;, address, StubRoutines::_updateBytesCRC32C);
 550     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_updateBytesAdler32&quot;, address, StubRoutines::_updateBytesAdler32);
 551     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_squareToLen&quot;, address, StubRoutines::_squareToLen);
 552     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_mulAdd&quot;, address, StubRoutines::_mulAdd);
 553     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_montgomeryMultiply&quot;,  address, StubRoutines::_montgomeryMultiply);
 554     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_montgomerySquare&quot;, address, StubRoutines::_montgomerySquare);
 555     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_vectorizedMismatch&quot;, address, StubRoutines::_vectorizedMismatch);


 556 
 557     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_throw_delayed_StackOverflowError_entry&quot;, address, StubRoutines::_throw_delayed_StackOverflowError_entry);
 558 
 559 }
 560 
 561 void AOTCodeHeap::link_os_symbols() {
 562     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_os_javaTimeMillis&quot;, address, os::javaTimeMillis);
 563     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_os_javaTimeNanos&quot;, address, os::javaTimeNanos);
 564 }
 565 
 566 /*
 567  * Link any global symbols in precompiled DSO with dlopen() _dl_handle
 568  * dso_handle.
 569  */
 570 
 571 void AOTCodeHeap::link_global_lib_symbols() {
 572   if (!_lib_symbols_initialized) {
 573     _lib_symbols_initialized = true;
 574 
 575     CollectedHeap* heap = Universe::heap();
 576     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_card_table_address&quot;, address, (BarrierSet::barrier_set()-&gt;is_a(BarrierSet::CardTableBarrierSet) ? ci_card_table_address() : NULL));
 577     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_heap_top_address&quot;, address, (heap-&gt;supports_inline_contig_alloc() ? heap-&gt;top_addr() : NULL));
 578     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_heap_end_address&quot;, address, (heap-&gt;supports_inline_contig_alloc() ? heap-&gt;end_addr() : NULL));
 579     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_polling_page&quot;, address, os::get_polling_page());
<span class="line-modified"> 580     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_narrow_klass_base_address&quot;, address, Universe::narrow_klass_base());</span>
<span class="line-modified"> 581     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_narrow_oop_base_address&quot;, address, Universe::narrow_oop_base());</span>
 582 #if INCLUDE_G1GC
 583     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_log_of_heap_region_grain_bytes&quot;, int, HeapRegion::LogOfHRGrainBytes);
 584 #endif
 585     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_inline_contiguous_allocation_supported&quot;, bool, heap-&gt;supports_inline_contig_alloc());
 586     link_shared_runtime_symbols();
 587     link_stub_routines_symbols();
 588     link_os_symbols();
 589     link_graal_runtime_symbols();
 590 
 591     // Link primitive array klasses.
 592     link_primitive_array_klasses();
 593   }
 594 }
 595 
 596 #ifndef PRODUCT
 597 int AOTCodeHeap::klasses_seen = 0;
 598 int AOTCodeHeap::aot_klasses_found = 0;
 599 int AOTCodeHeap::aot_klasses_fp_miss = 0;
 600 int AOTCodeHeap::aot_klasses_cl_miss = 0;
 601 int AOTCodeHeap::aot_methods_found = 0;
</pre>
<hr />
<pre>
 702   int methods_offset = klass_data-&gt;_dependent_methods_offset;
 703   if (methods_offset &gt;= 0) {
 704     address methods_cnt_adr = _dependencies + methods_offset;
 705     int methods_cnt = *(int*)methods_cnt_adr;
 706     int* indexes = (int*)(methods_cnt_adr + 4);
 707     for (int i = 0; i &lt; methods_cnt; ++i) {
 708       int code_id = indexes[i];
 709       AOTCompiledMethod* aot = _code_to_aot[code_id]._aot;
 710       if (aot != NULL) {
 711         aot-&gt;mark_for_deoptimization(false);
 712       }
 713     }
 714   }
 715 }
 716 
 717 void AOTCodeHeap::sweep_dependent_methods(int* indexes, int methods_cnt) {
 718   int marked = 0;
 719   for (int i = 0; i &lt; methods_cnt; ++i) {
 720     int code_id = indexes[i];
 721     // Invalidate aot code.
<span class="line-modified"> 722     if (Atomic::cmpxchg(invalid, &amp;_code_to_aot[code_id]._state, not_set) != not_set) {</span>
 723       if (_code_to_aot[code_id]._state == in_use) {
 724         AOTCompiledMethod* aot = _code_to_aot[code_id]._aot;
 725         assert(aot != NULL, &quot;aot should be set&quot;);
 726         if (!aot-&gt;is_runtime_stub()) { // Something is wrong - should not invalidate stubs.
 727           aot-&gt;mark_for_deoptimization(false);
 728           marked++;
 729         }
 730       }
 731     }
 732   }
 733   if (marked &gt; 0) {
<span class="line-modified"> 734     VM_Deoptimize op;</span>
<span class="line-removed"> 735     VMThread::execute(&amp;op);</span>
 736   }
 737 }
 738 
 739 void AOTCodeHeap::sweep_dependent_methods(AOTKlassData* klass_data) {
 740   // Make dependent methods non_entrant forever.
 741   int methods_offset = klass_data-&gt;_dependent_methods_offset;
 742   if (methods_offset &gt;= 0) {
 743     address methods_cnt_adr = _dependencies + methods_offset;
 744     int methods_cnt = *(int*)methods_cnt_adr;
 745     int* indexes = (int*)(methods_cnt_adr + 4);
 746     sweep_dependent_methods(indexes, methods_cnt);
 747   }
 748 }
 749 
 750 void AOTCodeHeap::sweep_dependent_methods(InstanceKlass* ik) {
 751   AOTKlassData* klass_data = find_klass(ik);
 752   vmassert(klass_data != NULL, &quot;dependency data missing&quot;);
 753   sweep_dependent_methods(klass_data);
 754 }
 755 
</pre>
<hr />
<pre>
 914 }
 915 
 916 void AOTCodeHeap::oops_do(OopClosure* f) {
 917   for (int i = 0; i &lt; _oop_got_size; i++) {
 918     oop* p = &amp;_oop_got[i];
 919     if (*p == NULL)  continue;  // skip non-oops
 920     f-&gt;do_oop(p);
 921   }
 922   for (int index = 0; index &lt; _method_count; index++) {
 923     if (_code_to_aot[index]._state != in_use) {
 924       continue; // Skip uninitialized entries.
 925     }
 926     AOTCompiledMethod* aot = _code_to_aot[index]._aot;
 927     aot-&gt;do_oops(f);
 928   }
 929 }
 930 
 931 // Scan only klasses_got cells which should have only Klass*,
 932 // metadata_got cells are scanned only for alive AOT methods
 933 // by AOTCompiledMethod::metadata_do().
<span class="line-modified"> 934 void AOTCodeHeap::got_metadata_do(void f(Metadata*)) {</span>
 935   for (int i = 1; i &lt; _klasses_got_size; i++) {
 936     Metadata** p = &amp;_klasses_got[i];
 937     Metadata* md = *p;
 938     if (md == NULL)  continue;  // skip non-oops
 939     if (Metaspace::contains(md)) {
<span class="line-modified"> 940       f(md);</span>
 941     } else {
 942       intptr_t meta = (intptr_t)md;
 943       fatal(&quot;Invalid value in _klasses_got[%d] = &quot; INTPTR_FORMAT, i, meta);
 944     }
 945   }
 946 }
 947 
 948 void AOTCodeHeap::cleanup_inline_caches() {
 949   for (int index = 0; index &lt; _method_count; index++) {
 950     if (_code_to_aot[index]._state != in_use) {
 951       continue; // Skip uninitialized entries.
 952     }
 953     AOTCompiledMethod* aot = _code_to_aot[index]._aot;
 954     aot-&gt;cleanup_inline_caches(false);
 955   }
 956 }
 957 
 958 #ifdef ASSERT
 959 int AOTCodeHeap::verify_icholder_relocations() {
 960   int count = 0;
 961   for (int index = 0; index &lt; _method_count; index++) {
 962     if (_code_to_aot[index]._state != in_use) {
 963       continue; // Skip uninitialized entries.
 964     }
 965     AOTCompiledMethod* aot = _code_to_aot[index]._aot;
 966     count += aot-&gt;verify_icholder_relocations();
 967   }
 968   return count;
 969 }
 970 #endif
 971 
<span class="line-modified"> 972 void AOTCodeHeap::metadata_do(void f(Metadata*)) {</span>
 973   for (int index = 0; index &lt; _method_count; index++) {
 974     if (_code_to_aot[index]._state != in_use) {
 975       continue; // Skip uninitialized entries.
 976     }
 977     AOTCompiledMethod* aot = _code_to_aot[index]._aot;
 978     if (aot-&gt;_is_alive()) {
 979       aot-&gt;metadata_do(f);
 980     }
 981   }
 982   // Scan klasses_got cells.
 983   got_metadata_do(f);
 984 }
 985 
 986 bool AOTCodeHeap::reconcile_dynamic_klass(AOTCompiledMethod *caller, InstanceKlass* holder, int index, Klass *dyno_klass, const char *descriptor1, const char *descriptor2) {
 987   const char * const descriptors[2] = {descriptor1, descriptor2};
 988   JavaThread *thread = JavaThread::current();
 989   ResourceMark rm(thread);
 990 
 991   AOTKlassData* holder_data = find_klass(holder);
 992   vmassert(holder_data != NULL, &quot;klass %s not found&quot;, holder-&gt;signature_name());
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 
  26 #include &quot;aot/aotCodeHeap.hpp&quot;
  27 #include &quot;aot/aotLoader.hpp&quot;
  28 #include &quot;ci/ciUtilities.inline.hpp&quot;
  29 #include &quot;classfile/javaAssertions.hpp&quot;
  30 #include &quot;gc/shared/cardTable.hpp&quot;
  31 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  32 #include &quot;gc/shared/gcConfig.hpp&quot;
  33 #include &quot;gc/g1/heapRegion.hpp&quot;
  34 #include &quot;interpreter/abstractInterpreter.hpp&quot;
  35 #include &quot;jvmci/compilerRuntime.hpp&quot;
  36 #include &quot;jvmci/jvmciRuntime.hpp&quot;
<span class="line-added">  37 #include &quot;logging/log.hpp&quot;</span>
  38 #include &quot;memory/allocation.inline.hpp&quot;
<span class="line-added">  39 #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added">  40 #include &quot;oops/compressedOops.hpp&quot;</span>
<span class="line-added">  41 #include &quot;oops/klass.inline.hpp&quot;</span>
  42 #include &quot;oops/method.inline.hpp&quot;
<span class="line-added">  43 #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-added">  44 #include &quot;runtime/deoptimization.hpp&quot;</span>
  45 #include &quot;runtime/handles.inline.hpp&quot;
  46 #include &quot;runtime/os.hpp&quot;
  47 #include &quot;runtime/safepointVerifiers.hpp&quot;
  48 #include &quot;runtime/sharedRuntime.hpp&quot;
  49 #include &quot;runtime/vmOperations.hpp&quot;
<span class="line-added">  50 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  51 #include &quot;utilities/sizes.hpp&quot;
  52 
  53 bool AOTLib::_narrow_oop_shift_initialized = false;
  54 int  AOTLib::_narrow_oop_shift = 0;
  55 int  AOTLib::_narrow_klass_shift = 0;
  56 
  57 address AOTLib::load_symbol(const char *name) {
  58   address symbol = (address) os::dll_lookup(_dl_handle, name);
  59   if (symbol == NULL) {
  60     tty-&gt;print_cr(&quot;Shared file %s error: missing %s&quot;, _name, name);
  61     vm_exit(1);
  62   }
  63   return symbol;
  64 }
  65 
  66 Klass* AOTCodeHeap::get_klass_from_got(const char* klass_name, int klass_len, const Method* method) {
  67   AOTKlassData* klass_data = (AOTKlassData*)_lib-&gt;load_symbol(klass_name);
  68   Klass* k = (Klass*)_klasses_got[klass_data-&gt;_got_index];
  69   if (k == NULL) {
  70     Thread* thread = Thread::current();
</pre>
<hr />
<pre>
  79     if (k-&gt;is_instance_klass()) {
  80       InstanceKlass* ik = InstanceKlass::cast(k);
  81       if (ik-&gt;is_initialized()) {
  82         _klasses_got[klass_data-&gt;_got_index - 1] = ik;
  83       }
  84     }
  85   }
  86   return k;
  87 }
  88 
  89 Klass* AOTCodeHeap::lookup_klass(const char* name, int len, const Method* method, Thread* thread) {
  90   ResourceMark rm(thread);
  91   assert(method != NULL, &quot;incorrect call parameter&quot;);
  92   methodHandle caller(thread, (Method*)method);
  93 
  94   // Use class loader of aot method.
  95   Handle loader(thread, caller-&gt;method_holder()-&gt;class_loader());
  96   Handle protection_domain(thread, caller-&gt;method_holder()-&gt;protection_domain());
  97 
  98   // Ignore wrapping L and ;
<span class="line-modified">  99   if (name[0] == JVM_SIGNATURE_CLASS) {</span>
 100     assert(len &gt; 2, &quot;small name %s&quot;, name);
 101     name++;
 102     len -= 2;
 103   }
 104   TempNewSymbol sym = SymbolTable::probe(name, len);
 105   if (sym == NULL) {
 106     log_debug(aot, class, resolve)(&quot;Probe failed for AOT class %s&quot;, name);
 107     return NULL;
 108   }
 109   Klass* k = SystemDictionary::find_instance_or_array_klass(sym, loader, protection_domain, thread);
 110   assert(!thread-&gt;has_pending_exception(), &quot;should not throw&quot;);
 111 
 112   if (k != NULL) {
 113     log_info(aot, class, resolve)(&quot;%s %s (lookup)&quot;, caller-&gt;method_holder()-&gt;external_name(), k-&gt;external_name());
 114   }
 115   return k;
 116 }
 117 
 118 void AOTLib::handle_config_error(const char* format, ...) {
 119   if (PrintAOT) {
</pre>
<hr />
<pre>
 165   verify_flag(_config-&gt;_debug_VM, true, &quot;Debug VM version&quot;);
 166 #else
 167   verify_flag(!(_config-&gt;_debug_VM), true, &quot;Product VM version&quot;);
 168 #endif
 169   // Check configuration size
 170   verify_flag(_config-&gt;_config_size, AOTConfiguration::CONFIG_SIZE, &quot;AOT configuration size&quot;);
 171 
 172   // Check GC
 173   CollectedHeap::Name gc = (CollectedHeap::Name)_config-&gt;_gc;
 174   if (_valid &amp;&amp; !GCConfig::is_gc_selected(gc)) {
 175     handle_config_error(&quot;Shared file %s error: used &#39;%s&#39; is different from current &#39;%s&#39;&quot;, _name, GCConfig::hs_err_name(gc), GCConfig::hs_err_name());
 176   }
 177 
 178   // Check flags
 179   verify_flag(_config-&gt;_useCompressedOops, UseCompressedOops, &quot;UseCompressedOops&quot;);
 180   verify_flag(_config-&gt;_useCompressedClassPointers, UseCompressedClassPointers, &quot;UseCompressedClassPointers&quot;);
 181   verify_flag(_config-&gt;_useTLAB, UseTLAB, &quot;UseTLAB&quot;);
 182   verify_flag(_config-&gt;_useBiasedLocking, UseBiasedLocking, &quot;UseBiasedLocking&quot;);
 183   verify_flag(_config-&gt;_objectAlignment, ObjectAlignmentInBytes, &quot;ObjectAlignmentInBytes&quot;);
 184   verify_flag(_config-&gt;_contendedPaddingWidth, ContendedPaddingWidth, &quot;ContendedPaddingWidth&quot;);


 185   verify_flag(_config-&gt;_enableContended, EnableContended, &quot;EnableContended&quot;);
 186   verify_flag(_config-&gt;_restrictContended, RestrictContended, &quot;RestrictContended&quot;);

 187 
 188   if (!TieredCompilation &amp;&amp; _config-&gt;_tieredAOT) {
 189     handle_config_error(&quot;Shared file %s error: Expected to run with tiered compilation on&quot;, _name);
 190   }
 191 
 192   // Shifts are static values which initialized by 0 until java heap initialization.
 193   // AOT libs are loaded before heap initialized so shift values are not set.
 194   // It is okay since ObjectAlignmentInBytes flag which defines shifts value is set before AOT libs are loaded.
 195   // Set shifts value based on first AOT library config.
 196   if (UseCompressedOops &amp;&amp; _valid) {
 197     if (!_narrow_oop_shift_initialized) {
 198       _narrow_oop_shift = _config-&gt;_narrowOopShift;
 199       if (UseCompressedClassPointers) { // It is set only if UseCompressedOops is set
 200         _narrow_klass_shift = _config-&gt;_narrowKlassShift;
 201       }
 202       _narrow_oop_shift_initialized = true;
 203     } else {
 204       verify_flag(_config-&gt;_narrowOopShift, _narrow_oop_shift, &quot;aot_config-&gt;_narrowOopShift&quot;);
 205       if (UseCompressedClassPointers) { // It is set only if UseCompressedOops is set
 206         verify_flag(_config-&gt;_narrowKlassShift, _narrow_klass_shift, &quot;aot_config-&gt;_narrowKlassShift&quot;);
 207       }
 208     }
 209   }
 210 }
 211 
 212 AOTLib::~AOTLib() {
 213   os::free((void*) _name);
 214 }
 215 
 216 AOTCodeHeap::~AOTCodeHeap() {
<span class="line-modified"> 217   FREE_C_HEAP_ARRAY(AOTClass, _classes);</span>
<span class="line-modified"> 218   FREE_C_HEAP_ARRAY(CodeToAMethod, _code_to_aot);</span>




 219 }
 220 
 221 AOTLib::AOTLib(void* handle, const char* name, int dso_id) : _valid(true), _dl_handle(handle), _dso_id(dso_id) {
 222   _name = (const char*) os::strdup(name);
 223 
 224   // Verify that VM runs with the same parameters as AOT tool.
 225   _config = (AOTConfiguration*) load_symbol(&quot;A.config&quot;);
 226   _header = (AOTHeader*) load_symbol(&quot;A.header&quot;);
 227 
 228   verify_config();
 229 
 230   if (!_valid &amp;&amp; PrintAOT) {
 231       tty-&gt;print(&quot;%7d &quot;, (int) tty-&gt;time_stamp().milliseconds());
 232       tty-&gt;print_cr(&quot;%4d     skipped %s  aot library&quot;, _dso_id, _name);
 233   }
 234 }
 235 
 236 AOTCodeHeap::AOTCodeHeap(AOTLib* lib) :
 237     CodeHeap(&quot;CodeHeap &#39;AOT&#39;&quot;, CodeBlobType::AOT), _lib(lib), _classes(NULL), _code_to_aot(NULL) {
 238   assert(_lib-&gt;is_valid(), &quot;invalid library&quot;);
</pre>
<hr />
<pre>
 329 
 330   jlong* state_adr = &amp;_method_state[code_id];
 331   address metadata_table = method_data-&gt;_metadata_table;
 332   int metadata_size = method_data-&gt;_metadata_size;
 333   assert(code_id &lt; _method_count, &quot;sanity&quot;);
 334   _aot_id++;
 335 
 336 #ifdef ASSERT
 337   if (_aot_id &gt; CIStop || _aot_id &lt; CIStart) {
 338     // Skip compilation
 339     return;
 340   }
 341 #endif
 342   // Check one more time.
 343   if (_code_to_aot[code_id]._state == invalid) {
 344     return;
 345   }
 346   AOTCompiledMethod *aot = new AOTCompiledMethod(code, mh(), meta, metadata_table, metadata_size, state_adr, this, name, code_id, _aot_id);
 347   assert(_code_to_aot[code_id]._aot == NULL, &quot;should be not initialized&quot;);
 348   _code_to_aot[code_id]._aot = aot; // Should set this first
<span class="line-modified"> 349   if (Atomic::cmpxchg(&amp;_code_to_aot[code_id]._state, not_set, in_use) != not_set) {</span>
 350     _code_to_aot[code_id]._aot = NULL; // Clean
 351   } else { // success
 352     // Publish method
 353 #ifdef TIERED
 354     mh-&gt;set_aot_code(aot);
 355 #endif
<span class="line-modified"> 356     {</span>
<span class="line-added"> 357       MutexLocker pl(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added"> 358       Method::set_code(mh, aot);</span>
<span class="line-added"> 359     }</span>
 360     if (PrintAOT || (PrintCompilation &amp;&amp; PrintAOT)) {
 361       PauseNoSafepointVerifier pnsv(&amp;nsv); // aot code is registered already
 362       aot-&gt;print_on(tty, NULL);
 363     }
 364     // Publish oop only after we are visible to CompiledMethodIterator
 365     aot-&gt;set_oop(mh()-&gt;method_holder()-&gt;klass_holder());
 366   }
 367 }
 368 
 369 void AOTCodeHeap::link_primitive_array_klasses() {
 370   ResourceMark rm;
 371   for (int i = T_BOOLEAN; i &lt;= T_CONFLICT; i++) {
 372     BasicType t = (BasicType)i;
 373     if (is_java_primitive(t)) {
 374       const Klass* arr_klass = Universe::typeArrayKlassObj(t);
 375       AOTKlassData* klass_data = (AOTKlassData*) os::dll_lookup(_lib-&gt;dl_handle(), arr_klass-&gt;signature_name());
 376       if (klass_data != NULL) {
 377         // Set both GOT cells, resolved and initialized klass pointers.
 378         // _got_index points to second cell - resolved klass pointer.
 379         _klasses_got[klass_data-&gt;_got_index-1] = (Metadata*)arr_klass; // Initialized
</pre>
<hr />
<pre>
 385     }
 386   }
 387 }
 388 
 389 void AOTCodeHeap::register_stubs() {
 390   int stubs_count = _stubs_offsets[0]; // contains number
 391   _stubs_offsets++;
 392   AOTMethodOffsets* stub_offsets = (AOTMethodOffsets*)_stubs_offsets;
 393   for (int i = 0; i &lt; stubs_count; ++i) {
 394     const char* stub_name = _metaspace_names + stub_offsets[i]._name_offset;
 395     address entry = _code_space  + stub_offsets[i]._code_offset;
 396     aot_metadata* meta = (aot_metadata *) (_method_metadata + stub_offsets[i]._meta_offset);
 397     address metadata_table = (address)_metadata_got + stub_offsets[i]._metadata_got_offset;
 398     int metadata_size = stub_offsets[i]._metadata_got_size;
 399     int code_id = stub_offsets[i]._code_id;
 400     assert(code_id &lt; _method_count, &quot;sanity&quot;);
 401     jlong* state_adr = &amp;_method_state[code_id];
 402     int len = Bytes::get_Java_u2((address)stub_name);
 403     stub_name += 2;
 404     char* full_name = NEW_C_HEAP_ARRAY(char, len+5, mtCode);



 405     memcpy(full_name, &quot;AOT &quot;, 4);
 406     memcpy(full_name+4, stub_name, len);
 407     full_name[len+4] = 0;
 408     guarantee(_code_to_aot[code_id]._state != invalid, &quot;stub %s can&#39;t be invalidated&quot;, full_name);
 409     AOTCompiledMethod* aot = new AOTCompiledMethod(entry, NULL, meta, metadata_table, metadata_size, state_adr, this, full_name, code_id, i);
 410     assert(_code_to_aot[code_id]._aot  == NULL, &quot;should be not initialized&quot;);
 411     _code_to_aot[code_id]._aot  = aot;
<span class="line-modified"> 412     if (Atomic::cmpxchg(&amp;_code_to_aot[code_id]._state, not_set, in_use) != not_set) {</span>
 413       fatal(&quot;stab &#39;%s&#39; code state is %d&quot;, full_name, _code_to_aot[code_id]._state);
 414     }
 415     // Adjust code buffer boundaries only for stubs because they are last in the buffer.
 416     adjust_boundaries(aot);
 417     if (PrintAOT &amp;&amp; Verbose) {
 418       aot-&gt;print_on(tty, NULL);
 419     }
 420   }
 421 }
 422 
 423 #define SET_AOT_GLOBAL_SYMBOL_VALUE(AOTSYMNAME, AOTSYMTYPE, VMSYMVAL) \
 424   {                                                                   \
 425     AOTSYMTYPE * adr = (AOTSYMTYPE *) os::dll_lookup(_lib-&gt;dl_handle(), AOTSYMNAME);  \
 426     /* Check for a lookup error */                                    \
 427     guarantee(adr != NULL, &quot;AOT Symbol not found %s&quot;, AOTSYMNAME);    \
 428     *adr = (AOTSYMTYPE) VMSYMVAL;                                     \
 429   }
 430 
 431 void AOTCodeHeap::link_graal_runtime_symbols()  {
 432     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_monitorenter&quot;, address, JVMCIRuntime::monitorenter);
 433     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_monitorexit&quot;, address, JVMCIRuntime::monitorexit);
 434     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_log_object&quot;, address, JVMCIRuntime::log_object);
 435     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_log_printf&quot;, address, JVMCIRuntime::log_printf);
 436     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_log_primitive&quot;, address, JVMCIRuntime::log_primitive);
 437     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_new_instance&quot;, address, JVMCIRuntime::new_instance);
 438     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_new_array&quot;, address, JVMCIRuntime::new_array);
 439     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_new_multi_array&quot;, address, JVMCIRuntime::new_multi_array);
 440     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_dynamic_new_instance&quot;, address, JVMCIRuntime::dynamic_new_instance);
 441     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_dynamic_new_array&quot;, address, JVMCIRuntime::dynamic_new_array);
 442     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_new_instance_or_null&quot;, address, JVMCIRuntime::new_instance_or_null);
 443     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_new_array_or_null&quot;, address, JVMCIRuntime::new_array_or_null);
 444     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_new_multi_array_or_null&quot;, address, JVMCIRuntime::new_multi_array_or_null);
 445     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_dynamic_new_instance_or_null&quot;, address, JVMCIRuntime::dynamic_new_instance_or_null);
 446     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_dynamic_new_array_or_null&quot;, address, JVMCIRuntime::dynamic_new_array_or_null);
 447     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_validate_object&quot;, address, JVMCIRuntime::validate_object);
 448 #if INCLUDE_G1GC
 449     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_write_barrier_pre&quot;, address, JVMCIRuntime::write_barrier_pre);
 450     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_write_barrier_post&quot;, address, JVMCIRuntime::write_barrier_post);
 451 #endif
 452     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_identity_hash_code&quot;, address, JVMCIRuntime::identity_hash_code);

 453     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_exception_handler_for_pc&quot;, address, JVMCIRuntime::exception_handler_for_pc);
 454     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_test_deoptimize_call_int&quot;, address, JVMCIRuntime::test_deoptimize_call_int);
 455     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_throw_and_post_jvmti_exception&quot;, address, JVMCIRuntime::throw_and_post_jvmti_exception);
 456     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_throw_klass_external_name_exception&quot;, address, JVMCIRuntime::throw_klass_external_name_exception);
 457     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_throw_class_cast_exception&quot;, address, JVMCIRuntime::throw_class_cast_exception);
 458     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_vm_message&quot;, address, JVMCIRuntime::vm_message);
 459     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_vm_error&quot;, address, JVMCIRuntime::vm_error);
 460 }
 461 
 462 void AOTCodeHeap::link_shared_runtime_symbols() {
 463     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_resolve_static_entry&quot;, address, SharedRuntime::get_resolve_static_call_stub());
 464     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_resolve_virtual_entry&quot;, address, SharedRuntime::get_resolve_virtual_call_stub());
 465     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_resolve_opt_virtual_entry&quot;, address, SharedRuntime::get_resolve_opt_virtual_call_stub());
 466     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_deopt_blob_unpack&quot;, address, SharedRuntime::deopt_blob()-&gt;unpack());
<span class="line-added"> 467     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_deopt_blob_unpack_with_exception_in_tls&quot;, address, SharedRuntime::deopt_blob()-&gt;unpack_with_exception_in_tls());</span>
 468     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_deopt_blob_uncommon_trap&quot;, address, SharedRuntime::deopt_blob()-&gt;uncommon_trap());
 469     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_ic_miss_stub&quot;, address, SharedRuntime::get_ic_miss_stub());
 470     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_handle_wrong_method_stub&quot;, address, SharedRuntime::get_handle_wrong_method_stub());
 471     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_exception_handler_for_return_address&quot;, address, SharedRuntime::exception_handler_for_return_address);
 472     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_register_finalizer&quot;, address, SharedRuntime::register_finalizer);
 473     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_object_notify&quot;, address, JVMCIRuntime::object_notify);
 474     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_object_notifyAll&quot;, address, JVMCIRuntime::object_notifyAll);
 475     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_OSR_migration_end&quot;, address, SharedRuntime::OSR_migration_end);
 476     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_enable_stack_reserved_zone&quot;, address, SharedRuntime::enable_stack_reserved_zone);
 477     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_resolve_dynamic_invoke&quot;, address, CompilerRuntime::resolve_dynamic_invoke);
 478     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_resolve_string_by_symbol&quot;, address, CompilerRuntime::resolve_string_by_symbol);
 479     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_resolve_klass_by_symbol&quot;, address, CompilerRuntime::resolve_klass_by_symbol);
 480     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_resolve_method_by_symbol_and_load_counters&quot;, address, CompilerRuntime::resolve_method_by_symbol_and_load_counters);
 481     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_initialize_klass_by_symbol&quot;, address, CompilerRuntime::initialize_klass_by_symbol);
 482     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_invocation_event&quot;, address, CompilerRuntime::invocation_event);
 483     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_backedge_event&quot;, address, CompilerRuntime::backedge_event);
 484 
 485     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_shared_runtime_dpow&quot;, address, SharedRuntime::dpow);
 486     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_shared_runtime_dexp&quot;, address, SharedRuntime::dexp);
 487     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_shared_runtime_dcos&quot;, address, SharedRuntime::dcos);
</pre>
<hr />
<pre>
 513     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_arrayof_oop_arraycopy&quot;, address, StubRoutines::_arrayof_oop_arraycopy);
 514     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_arrayof_oop_arraycopy_uninit&quot;, address, StubRoutines::_arrayof_oop_arraycopy_uninit);
 515 
 516     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_arrayof_jbyte_disjoint_arraycopy&quot;, address, StubRoutines::_arrayof_jbyte_disjoint_arraycopy);
 517     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_arrayof_jshort_disjoint_arraycopy&quot;, address, StubRoutines::_arrayof_jshort_disjoint_arraycopy);
 518     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_arrayof_jint_disjoint_arraycopy&quot;, address, StubRoutines::_arrayof_jint_disjoint_arraycopy);
 519     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_arrayof_jlong_disjoint_arraycopy&quot;, address, StubRoutines::_arrayof_jlong_disjoint_arraycopy);
 520     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_arrayof_oop_disjoint_arraycopy&quot;, address, StubRoutines::_arrayof_oop_disjoint_arraycopy);
 521     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_arrayof_oop_disjoint_arraycopy_uninit&quot;, address, StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit);
 522 
 523     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_unsafe_arraycopy&quot;, address, StubRoutines::_unsafe_arraycopy);
 524 
 525     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_checkcast_arraycopy&quot;, address, StubRoutines::_checkcast_arraycopy);
 526 
 527     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_generic_arraycopy&quot;, address, StubRoutines::_generic_arraycopy);
 528 
 529     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_aescrypt_encryptBlock&quot;, address, StubRoutines::_aescrypt_encryptBlock);
 530     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_aescrypt_decryptBlock&quot;, address, StubRoutines::_aescrypt_decryptBlock);
 531     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_cipherBlockChaining_encryptAESCrypt&quot;, address, StubRoutines::_cipherBlockChaining_encryptAESCrypt);
 532     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_cipherBlockChaining_decryptAESCrypt&quot;, address, StubRoutines::_cipherBlockChaining_decryptAESCrypt);
<span class="line-added"> 533     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_electronicCodeBook_encryptAESCrypt&quot;, address, StubRoutines::_electronicCodeBook_encryptAESCrypt);</span>
<span class="line-added"> 534     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_electronicCodeBook_decryptAESCrypt&quot;, address, StubRoutines::_electronicCodeBook_decryptAESCrypt);</span>
 535     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_update_bytes_crc32&quot;, address, StubRoutines::_updateBytesCRC32);
 536     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_crc_table_adr&quot;, address, StubRoutines::_crc_table_adr);
 537 
 538 
 539     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_sha1_implCompress&quot;, address, StubRoutines::_sha1_implCompress);
 540     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_sha1_implCompressMB&quot;, address, StubRoutines::_sha1_implCompressMB);
 541     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_sha256_implCompress&quot;, address, StubRoutines::_sha256_implCompress);
 542     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_sha256_implCompressMB&quot;, address, StubRoutines::_sha256_implCompressMB);
 543     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_sha512_implCompress&quot;, address, StubRoutines::_sha512_implCompress);
 544     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_sha512_implCompressMB&quot;, address, StubRoutines::_sha512_implCompressMB);
 545     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_multiplyToLen&quot;, address, StubRoutines::_multiplyToLen);
 546 
 547     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_counterMode_AESCrypt&quot;, address, StubRoutines::_counterMode_AESCrypt);
 548     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_ghash_processBlocks&quot;, address, StubRoutines::_ghash_processBlocks);
 549     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_base64_encodeBlock&quot;, address, StubRoutines::_base64_encodeBlock);
 550     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_crc32c_table_addr&quot;, address, StubRoutines::_crc32c_table_addr);
 551     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_updateBytesCRC32C&quot;, address, StubRoutines::_updateBytesCRC32C);
 552     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_updateBytesAdler32&quot;, address, StubRoutines::_updateBytesAdler32);
 553     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_squareToLen&quot;, address, StubRoutines::_squareToLen);
 554     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_mulAdd&quot;, address, StubRoutines::_mulAdd);
 555     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_montgomeryMultiply&quot;,  address, StubRoutines::_montgomeryMultiply);
 556     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_montgomerySquare&quot;, address, StubRoutines::_montgomerySquare);
 557     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_vectorizedMismatch&quot;, address, StubRoutines::_vectorizedMismatch);
<span class="line-added"> 558     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_bigIntegerRightShiftWorker&quot;, address, StubRoutines::_bigIntegerRightShiftWorker);</span>
<span class="line-added"> 559     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_bigIntegerLeftShiftWorker&quot;, address, StubRoutines::_bigIntegerLeftShiftWorker);</span>
 560 
 561     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_throw_delayed_StackOverflowError_entry&quot;, address, StubRoutines::_throw_delayed_StackOverflowError_entry);
 562 
 563 }
 564 
 565 void AOTCodeHeap::link_os_symbols() {
 566     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_os_javaTimeMillis&quot;, address, os::javaTimeMillis);
 567     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_os_javaTimeNanos&quot;, address, os::javaTimeNanos);
 568 }
 569 
 570 /*
 571  * Link any global symbols in precompiled DSO with dlopen() _dl_handle
 572  * dso_handle.
 573  */
 574 
 575 void AOTCodeHeap::link_global_lib_symbols() {
 576   if (!_lib_symbols_initialized) {
 577     _lib_symbols_initialized = true;
 578 
 579     CollectedHeap* heap = Universe::heap();
 580     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_card_table_address&quot;, address, (BarrierSet::barrier_set()-&gt;is_a(BarrierSet::CardTableBarrierSet) ? ci_card_table_address() : NULL));
 581     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_heap_top_address&quot;, address, (heap-&gt;supports_inline_contig_alloc() ? heap-&gt;top_addr() : NULL));
 582     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_heap_end_address&quot;, address, (heap-&gt;supports_inline_contig_alloc() ? heap-&gt;end_addr() : NULL));
 583     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_polling_page&quot;, address, os::get_polling_page());
<span class="line-modified"> 584     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_narrow_klass_base_address&quot;, address, CompressedKlassPointers::base());</span>
<span class="line-modified"> 585     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_narrow_oop_base_address&quot;, address, CompressedOops::base());</span>
 586 #if INCLUDE_G1GC
 587     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_log_of_heap_region_grain_bytes&quot;, int, HeapRegion::LogOfHRGrainBytes);
 588 #endif
 589     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_inline_contiguous_allocation_supported&quot;, bool, heap-&gt;supports_inline_contig_alloc());
 590     link_shared_runtime_symbols();
 591     link_stub_routines_symbols();
 592     link_os_symbols();
 593     link_graal_runtime_symbols();
 594 
 595     // Link primitive array klasses.
 596     link_primitive_array_klasses();
 597   }
 598 }
 599 
 600 #ifndef PRODUCT
 601 int AOTCodeHeap::klasses_seen = 0;
 602 int AOTCodeHeap::aot_klasses_found = 0;
 603 int AOTCodeHeap::aot_klasses_fp_miss = 0;
 604 int AOTCodeHeap::aot_klasses_cl_miss = 0;
 605 int AOTCodeHeap::aot_methods_found = 0;
</pre>
<hr />
<pre>
 706   int methods_offset = klass_data-&gt;_dependent_methods_offset;
 707   if (methods_offset &gt;= 0) {
 708     address methods_cnt_adr = _dependencies + methods_offset;
 709     int methods_cnt = *(int*)methods_cnt_adr;
 710     int* indexes = (int*)(methods_cnt_adr + 4);
 711     for (int i = 0; i &lt; methods_cnt; ++i) {
 712       int code_id = indexes[i];
 713       AOTCompiledMethod* aot = _code_to_aot[code_id]._aot;
 714       if (aot != NULL) {
 715         aot-&gt;mark_for_deoptimization(false);
 716       }
 717     }
 718   }
 719 }
 720 
 721 void AOTCodeHeap::sweep_dependent_methods(int* indexes, int methods_cnt) {
 722   int marked = 0;
 723   for (int i = 0; i &lt; methods_cnt; ++i) {
 724     int code_id = indexes[i];
 725     // Invalidate aot code.
<span class="line-modified"> 726     if (Atomic::cmpxchg(&amp;_code_to_aot[code_id]._state, not_set, invalid) != not_set) {</span>
 727       if (_code_to_aot[code_id]._state == in_use) {
 728         AOTCompiledMethod* aot = _code_to_aot[code_id]._aot;
 729         assert(aot != NULL, &quot;aot should be set&quot;);
 730         if (!aot-&gt;is_runtime_stub()) { // Something is wrong - should not invalidate stubs.
 731           aot-&gt;mark_for_deoptimization(false);
 732           marked++;
 733         }
 734       }
 735     }
 736   }
 737   if (marked &gt; 0) {
<span class="line-modified"> 738     Deoptimization::deoptimize_all_marked();</span>

 739   }
 740 }
 741 
 742 void AOTCodeHeap::sweep_dependent_methods(AOTKlassData* klass_data) {
 743   // Make dependent methods non_entrant forever.
 744   int methods_offset = klass_data-&gt;_dependent_methods_offset;
 745   if (methods_offset &gt;= 0) {
 746     address methods_cnt_adr = _dependencies + methods_offset;
 747     int methods_cnt = *(int*)methods_cnt_adr;
 748     int* indexes = (int*)(methods_cnt_adr + 4);
 749     sweep_dependent_methods(indexes, methods_cnt);
 750   }
 751 }
 752 
 753 void AOTCodeHeap::sweep_dependent_methods(InstanceKlass* ik) {
 754   AOTKlassData* klass_data = find_klass(ik);
 755   vmassert(klass_data != NULL, &quot;dependency data missing&quot;);
 756   sweep_dependent_methods(klass_data);
 757 }
 758 
</pre>
<hr />
<pre>
 917 }
 918 
 919 void AOTCodeHeap::oops_do(OopClosure* f) {
 920   for (int i = 0; i &lt; _oop_got_size; i++) {
 921     oop* p = &amp;_oop_got[i];
 922     if (*p == NULL)  continue;  // skip non-oops
 923     f-&gt;do_oop(p);
 924   }
 925   for (int index = 0; index &lt; _method_count; index++) {
 926     if (_code_to_aot[index]._state != in_use) {
 927       continue; // Skip uninitialized entries.
 928     }
 929     AOTCompiledMethod* aot = _code_to_aot[index]._aot;
 930     aot-&gt;do_oops(f);
 931   }
 932 }
 933 
 934 // Scan only klasses_got cells which should have only Klass*,
 935 // metadata_got cells are scanned only for alive AOT methods
 936 // by AOTCompiledMethod::metadata_do().
<span class="line-modified"> 937 void AOTCodeHeap::got_metadata_do(MetadataClosure* f) {</span>
 938   for (int i = 1; i &lt; _klasses_got_size; i++) {
 939     Metadata** p = &amp;_klasses_got[i];
 940     Metadata* md = *p;
 941     if (md == NULL)  continue;  // skip non-oops
 942     if (Metaspace::contains(md)) {
<span class="line-modified"> 943       f-&gt;do_metadata(md);</span>
 944     } else {
 945       intptr_t meta = (intptr_t)md;
 946       fatal(&quot;Invalid value in _klasses_got[%d] = &quot; INTPTR_FORMAT, i, meta);
 947     }
 948   }
 949 }
 950 
 951 void AOTCodeHeap::cleanup_inline_caches() {
 952   for (int index = 0; index &lt; _method_count; index++) {
 953     if (_code_to_aot[index]._state != in_use) {
 954       continue; // Skip uninitialized entries.
 955     }
 956     AOTCompiledMethod* aot = _code_to_aot[index]._aot;
 957     aot-&gt;cleanup_inline_caches(false);
 958   }
 959 }
 960 
 961 #ifdef ASSERT
 962 int AOTCodeHeap::verify_icholder_relocations() {
 963   int count = 0;
 964   for (int index = 0; index &lt; _method_count; index++) {
 965     if (_code_to_aot[index]._state != in_use) {
 966       continue; // Skip uninitialized entries.
 967     }
 968     AOTCompiledMethod* aot = _code_to_aot[index]._aot;
 969     count += aot-&gt;verify_icholder_relocations();
 970   }
 971   return count;
 972 }
 973 #endif
 974 
<span class="line-modified"> 975 void AOTCodeHeap::metadata_do(MetadataClosure* f) {</span>
 976   for (int index = 0; index &lt; _method_count; index++) {
 977     if (_code_to_aot[index]._state != in_use) {
 978       continue; // Skip uninitialized entries.
 979     }
 980     AOTCompiledMethod* aot = _code_to_aot[index]._aot;
 981     if (aot-&gt;_is_alive()) {
 982       aot-&gt;metadata_do(f);
 983     }
 984   }
 985   // Scan klasses_got cells.
 986   got_metadata_do(f);
 987 }
 988 
 989 bool AOTCodeHeap::reconcile_dynamic_klass(AOTCompiledMethod *caller, InstanceKlass* holder, int index, Klass *dyno_klass, const char *descriptor1, const char *descriptor2) {
 990   const char * const descriptors[2] = {descriptor1, descriptor2};
 991   JavaThread *thread = JavaThread::current();
 992   ResourceMark rm(thread);
 993 
 994   AOTKlassData* holder_data = find_klass(holder);
 995   vmassert(holder_data != NULL, &quot;klass %s not found&quot;, holder-&gt;signature_name());
</pre>
</td>
</tr>
</table>
<center><a href="../adlc/output_h.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="aotCodeHeap.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
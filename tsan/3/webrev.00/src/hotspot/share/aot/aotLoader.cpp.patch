diff a/src/hotspot/share/aot/aotLoader.cpp b/src/hotspot/share/aot/aotLoader.cpp
--- a/src/hotspot/share/aot/aotLoader.cpp
+++ b/src/hotspot/share/aot/aotLoader.cpp
@@ -20,16 +20,17 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 #include "precompiled.hpp"
-#include "jvm.h"
-
 #include "aot/aotCodeHeap.hpp"
 #include "aot/aotLoader.inline.hpp"
-#include "jvmci/jvmciRuntime.hpp"
+#include "classfile/javaClasses.hpp"
+#include "jvm.h"
 #include "memory/allocation.inline.hpp"
+#include "memory/resourceArea.hpp"
+#include "oops/compressedOops.hpp"
 #include "oops/method.hpp"
 #include "runtime/handles.inline.hpp"
 #include "runtime/os.inline.hpp"
 #include "runtime/timerTrace.hpp"
 
@@ -76,11 +77,11 @@
       (*heap)->oops_do(f);
     }
   }
 }
 
-void AOTLoader::metadata_do(void f(Metadata*)) {
+void AOTLoader::metadata_do(MetadataClosure* f) {
   if (UseAOT) {
     FOR_ALL_AOT_HEAPS(heap) {
       (*heap)->metadata_do(f);
     }
   }
@@ -148,21 +149,19 @@
 
     // Scan the AOTLibrary option.
     if (AOTLibrary != NULL) {
       const int len = (int)strlen(AOTLibrary);
       char* cp  = NEW_C_HEAP_ARRAY(char, len+1, mtCode);
-      if (cp != NULL) { // No memory?
-        memcpy(cp, AOTLibrary, len);
-        cp[len] = '\0';
-        char* end = cp + len;
-        while (cp < end) {
-          const char* name = cp;
-          while ((*cp) != '\0' && (*cp) != '\n' && (*cp) != ',' && (*cp) != pathSep) cp++;
-          cp[0] = '\0';  // Terminate name
-          cp++;
-          load_library(name, true);
-        }
+      memcpy(cp, AOTLibrary, len);
+      cp[len] = '\0';
+      char* end = cp + len;
+      while (cp < end) {
+        const char* name = cp;
+        while ((*cp) != '\0' && (*cp) != '\n' && (*cp) != ',' && (*cp) != pathSep) cp++;
+        cp[0] = '\0';  // Terminate name
+        cp++;
+        load_library(name, true);
       }
     }
 
     // Load well-know AOT libraries from Java installation directory.
     const char* home = Arguments::get_java_home();
@@ -182,27 +181,27 @@
     // AOT libs are loaded before heap initialized so shift values are not set.
     // It is okay since ObjectAlignmentInBytes flag which defines shifts value is set before AOT libs are loaded.
     // AOT sets shift values during heap and metaspace initialization.
     // Check shifts value to make sure thay did not change.
     if (UseCompressedOops && AOTLib::narrow_oop_shift_initialized()) {
-      int oop_shift = Universe::narrow_oop_shift();
+      int oop_shift = CompressedOops::shift();
       FOR_ALL_AOT_LIBRARIES(lib) {
-        (*lib)->verify_flag((*lib)->config()->_narrowOopShift, oop_shift, "Universe::narrow_oop_shift");
+        (*lib)->verify_flag((*lib)->config()->_narrowOopShift, oop_shift, "CompressedOops::shift");
       }
       if (UseCompressedClassPointers) { // It is set only if UseCompressedOops is set
-        int klass_shift = Universe::narrow_klass_shift();
+        int klass_shift = CompressedKlassPointers::shift();
         FOR_ALL_AOT_LIBRARIES(lib) {
-          (*lib)->verify_flag((*lib)->config()->_narrowKlassShift, klass_shift, "Universe::narrow_klass_shift");
+          (*lib)->verify_flag((*lib)->config()->_narrowKlassShift, klass_shift, "CompressedKlassPointers::shift");
         }
       }
     }
     // Create heaps for all valid libraries
     FOR_ALL_AOT_LIBRARIES(lib) {
       if ((*lib)->is_valid()) {
         AOTCodeHeap* heap = new AOTCodeHeap(*lib);
         {
-          MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
+          MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
           add_heap(heap);
           CodeCache::add_heap(heap);
         }
       } else {
         // Unload invalid libraries
@@ -223,25 +222,25 @@
 
 void AOTLoader::set_narrow_oop_shift() {
   // This method is called from Universe::initialize_heap().
   if (UseAOT && libraries_count() > 0 &&
       UseCompressedOops && AOTLib::narrow_oop_shift_initialized()) {
-    if (Universe::narrow_oop_shift() == 0) {
+    if (CompressedOops::shift() == 0) {
       // 0 is valid shift value for small heap but we can safely increase it
       // at this point when nobody used it yet.
-      Universe::set_narrow_oop_shift(AOTLib::narrow_oop_shift());
+      CompressedOops::set_shift(AOTLib::narrow_oop_shift());
     }
   }
 }
 
 void AOTLoader::set_narrow_klass_shift() {
   // This method is called from Metaspace::set_narrow_klass_base_and_shift().
   if (UseAOT && libraries_count() > 0 &&
       UseCompressedOops && AOTLib::narrow_oop_shift_initialized() &&
       UseCompressedClassPointers) {
-    if (Universe::narrow_klass_shift() == 0) {
-      Universe::set_narrow_klass_shift(AOTLib::narrow_klass_shift());
+    if (CompressedKlassPointers::shift() == 0) {
+      CompressedKlassPointers::set_shift(AOTLib::narrow_klass_shift());
     }
   }
 }
 
 void AOTLoader::load_library(const char* name, bool exit_on_error) {
@@ -317,5 +316,26 @@
   guarantee(caller_heap != NULL, "CodeHeap not found");
   bool success = caller_heap->reconcile_dynamic_invoke(aot, holder, index, adapter_method, appendix_klass);
   vmassert(success || thread->last_frame().sender(&map).is_deoptimized_frame(), "caller not deoptimized on failure");
   return success;
 }
+
+
+// This should be called very early during startup before any of the AOTed methods that use boxes can deoptimize.
+// Deoptimization machinery expects the caches to be present and populated.
+void AOTLoader::initialize_box_caches(TRAPS) {
+  if (!UseAOT || libraries_count() == 0) {
+    return;
+  }
+  TraceTime timer("AOT initialization of box caches", TRACETIME_LOG(Info, aot, startuptime));
+  Symbol* box_classes[] = { java_lang_Boolean::symbol(), java_lang_Byte_ByteCache::symbol(),
+    java_lang_Short_ShortCache::symbol(), java_lang_Character_CharacterCache::symbol(),
+    java_lang_Integer_IntegerCache::symbol(), java_lang_Long_LongCache::symbol() };
+
+  for (unsigned i = 0; i < sizeof(box_classes) / sizeof(Symbol*); i++) {
+    Klass* k = SystemDictionary::resolve_or_fail(box_classes[i], true, CHECK);
+    InstanceKlass* ik = InstanceKlass::cast(k);
+    if (ik->is_not_initialized()) {
+      ik->initialize(CHECK);
+    }
+  }
+}

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/aot/aotCompiledMethod.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 
 26 #include &quot;aot/aotCodeHeap.hpp&quot;
 27 #include &quot;aot/aotLoader.hpp&quot;
 28 #include &quot;aot/compiledIC_aot.hpp&quot;
 29 #include &quot;code/codeCache.hpp&quot;
 30 #include &quot;code/compiledIC.hpp&quot;
 31 #include &quot;code/nativeInst.hpp&quot;
 32 #include &quot;compiler/compilerOracle.hpp&quot;
 33 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
 34 #include &quot;gc/shared/collectedHeap.hpp&quot;
<a name="1" id="anc1"></a><span class="line-modified"> 35 #include &quot;jvmci/compilerRuntime.hpp&quot;</span>
<span class="line-removed"> 36 #include &quot;jvmci/jvmciRuntime.hpp&quot;</span>
 37 #include &quot;oops/method.inline.hpp&quot;
 38 #include &quot;runtime/frame.inline.hpp&quot;
 39 #include &quot;runtime/handles.inline.hpp&quot;
 40 #include &quot;runtime/java.hpp&quot;
<a name="2" id="anc2"></a>
 41 #include &quot;runtime/os.hpp&quot;
 42 #include &quot;runtime/safepointVerifiers.hpp&quot;
 43 #include &quot;runtime/sharedRuntime.hpp&quot;
 44 #include &quot;utilities/sizes.hpp&quot;
 45 #include &quot;utilities/xmlstream.hpp&quot;
 46 
 47 #include &lt;stdio.h&gt;
 48 
 49 #if 0
 50 static void metadata_oops_do(Metadata** metadata_begin, Metadata **metadata_end, OopClosure* f) {
 51   // Visit the metadata/oops section
 52   for (Metadata** p = metadata_begin; p &lt; metadata_end; p++) {
 53     Metadata* m = *p;
 54 
 55     intptr_t meta = (intptr_t)m;
 56     if ((meta &amp; 1) == 1) {
 57       // already resolved
 58       m = (Metadata*)(meta &amp; ~1);
 59     } else {
 60       continue;
 61     }
 62     assert(Metaspace::contains(m), &quot;&quot;);
 63     if (m-&gt;is_method()) {
 64       m = ((Method*)m)-&gt;method_holder();
 65     }
 66     assert(m-&gt;is_klass(), &quot;must be&quot;);
 67     oop o = ((Klass*)m)-&gt;klass_holder();
 68     if (o != NULL) {
 69       f-&gt;do_oop(&amp;o);
 70     }
 71   }
 72 }
 73 #endif
 74 
 75 address* AOTCompiledMethod::orig_pc_addr(const frame* fr) {
 76   return (address*) ((address)fr-&gt;unextended_sp() + _meta-&gt;orig_pc_offset());
 77 }
 78 
 79 oop AOTCompiledMethod::oop_at(int index) const {
 80   if (index == 0) { // 0 is reserved
 81     return NULL;
 82   }
 83   Metadata** entry = _metadata_got + (index - 1);
 84   intptr_t meta = (intptr_t)*entry;
 85   if ((meta &amp; 1) == 1) {
 86     // already resolved
 87     Klass* k = (Klass*)(meta &amp; ~1);
 88     return k-&gt;java_mirror();
 89   }
 90   // The entry is string which we need to resolve.
 91   const char* meta_name = _heap-&gt;get_name_at((int)meta);
 92   int klass_len = Bytes::get_Java_u2((address)meta_name);
 93   const char* klass_name = meta_name + 2;
 94   // Quick check the current method&#39;s holder.
 95   Klass* k = _method-&gt;method_holder();
 96 
 97   ResourceMark rm; // for signature_name()
 98   if (strncmp(k-&gt;signature_name(), klass_name, klass_len) != 0) { // Does not match?
 99     // Search klass in got cells in DSO which have this compiled method.
100     k = _heap-&gt;get_klass_from_got(klass_name, klass_len, _method);
101   }
102   int method_name_len = Bytes::get_Java_u2((address)klass_name + klass_len);
103   guarantee(method_name_len == 0, &quot;only klass is expected here&quot;);
104   meta = ((intptr_t)k) | 1;
105   *entry = (Metadata*)meta; // Should be atomic on x64
106   return k-&gt;java_mirror();
107 }
108 
109 Metadata* AOTCompiledMethod::metadata_at(int index) const {
110   if (index == 0) { // 0 is reserved
111     return NULL;
112   }
113   assert(index - 1 &lt; _metadata_size, &quot;&quot;);
114   {
115     Metadata** entry = _metadata_got + (index - 1);
116     intptr_t meta = (intptr_t)*entry;
117     if ((meta &amp; 1) == 1) {
118       // already resolved
119       Metadata *m = (Metadata*)(meta &amp; ~1);
120       return m;
121     }
122     // The entry is string which we need to resolve.
123     const char* meta_name = _heap-&gt;get_name_at((int)meta);
124     int klass_len = Bytes::get_Java_u2((address)meta_name);
125     const char* klass_name = meta_name + 2;
126     // Quick check the current method&#39;s holder.
127     Klass* k = _method-&gt;method_holder();
128     bool klass_matched = true;
129 
130     ResourceMark rm; // for signature_name() and find_method()
131     if (strncmp(k-&gt;signature_name(), klass_name, klass_len) != 0) { // Does not match?
132       // Search klass in got cells in DSO which have this compiled method.
133       k = _heap-&gt;get_klass_from_got(klass_name, klass_len, _method);
134       klass_matched = false;
135     }
136     int method_name_len = Bytes::get_Java_u2((address)klass_name + klass_len);
137     if (method_name_len == 0) { // Array or Klass name only?
138       meta = ((intptr_t)k) | 1;
139       *entry = (Metadata*)meta; // Should be atomic on x64
140       return (Metadata*)k;
141     } else { // Method
142       // Quick check the current method&#39;s name.
143       Method* m = _method;
144       int signature_len = Bytes::get_Java_u2((address)klass_name + klass_len + 2 + method_name_len);
145       int full_len = 2 + klass_len + 2 + method_name_len + 2 + signature_len;
146       if (!klass_matched || memcmp(_name, meta_name, full_len) != 0) { // Does not match?
147         Thread* thread = Thread::current();
148         const char* method_name = klass_name + klass_len;
149         m = AOTCodeHeap::find_method(k, thread, method_name);
150       }
151       meta = ((intptr_t)m) | 1;
152       *entry = (Metadata*)meta; // Should be atomic on x64
153       return (Metadata*)m;
154     }
155   }
156   ShouldNotReachHere(); return NULL;
157 }
158 
159 void AOTCompiledMethod::do_unloading(bool unloading_occurred) {
160   unload_nmethod_caches(unloading_occurred);
161 }
162 
163 bool AOTCompiledMethod::make_not_entrant_helper(int new_state) {
<a name="3" id="anc3"></a><span class="line-removed">164   // Make sure the method is not flushed in case of a safepoint in code below.</span>
<span class="line-removed">165   methodHandle the_method(method());</span>
166   NoSafepointVerifier nsv;
167 
168   {
169     // Enter critical section.  Does not block for safepoint.
<a name="4" id="anc4"></a><span class="line-modified">170     MutexLockerEx pl(Patching_lock, Mutex::_no_safepoint_check_flag);</span>
171 
172     if (*_state_adr == new_state) {
173       // another thread already performed this transition so nothing
174       // to do, but return false to indicate this.
175       return false;
176     }
177 
178     // Change state
179     OrderAccess::storestore();
180     *_state_adr = new_state;
181 
182     // Log the transition once
183     log_state_change();
184 
185 #ifdef TIERED
186     // Remain non-entrant forever
187     if (new_state == not_entrant &amp;&amp; method() != NULL) {
188         method()-&gt;set_aot_code(NULL);
189     }
190 #endif
191 
192     // Remove AOTCompiledMethod from method.
<a name="5" id="anc5"></a><span class="line-modified">193     if (method() != NULL &amp;&amp; (method()-&gt;code() == this ||</span>
<span class="line-modified">194                              method()-&gt;from_compiled_entry() == verified_entry_point())) {</span>
<span class="line-removed">195       HandleMark hm;</span>
<span class="line-removed">196       method()-&gt;clear_code(false /* already owns Patching_lock */);</span>
197     }
<a name="6" id="anc6"></a><span class="line-modified">198   } // leave critical region under Patching_lock</span>
199 
200 
201   if (TraceCreateZombies) {
202     ResourceMark m;
203     const char *new_state_str = (new_state == not_entrant) ? &quot;not entrant&quot; : &quot;not used&quot;;
204     tty-&gt;print_cr(&quot;aot method &lt;&quot; INTPTR_FORMAT &quot;&gt; %s code made %s&quot;, p2i(this), this-&gt;method() ? this-&gt;method()-&gt;name_and_sig_as_C_string() : &quot;null&quot;, new_state_str);
205   }
206 
207   return true;
208 }
209 
210 #ifdef TIERED
211 bool AOTCompiledMethod::make_entrant() {
212   assert(!method()-&gt;is_old(), &quot;reviving evolved method!&quot;);
<a name="7" id="anc7"></a><span class="line-removed">213   assert(*_state_adr != not_entrant, &quot;%s&quot;, method()-&gt;has_aot_code() ? &quot;has_aot_code() not cleared&quot; : &quot;caller didn&#39;t check has_aot_code()&quot;);</span>
214 
<a name="8" id="anc8"></a><span class="line-removed">215   // Make sure the method is not flushed in case of a safepoint in code below.</span>
<span class="line-removed">216   methodHandle the_method(method());</span>
217   NoSafepointVerifier nsv;
<a name="9" id="anc9"></a><span class="line-removed">218 </span>
219   {
220     // Enter critical section.  Does not block for safepoint.
<a name="10" id="anc10"></a><span class="line-modified">221     MutexLockerEx pl(Patching_lock, Mutex::_no_safepoint_check_flag);</span>
222 
<a name="11" id="anc11"></a><span class="line-modified">223     if (*_state_adr == in_use) {</span>
224       // another thread already performed this transition so nothing
225       // to do, but return false to indicate this.
226       return false;
227     }
228 
229     // Change state
230     OrderAccess::storestore();
231     *_state_adr = in_use;
232 
233     // Log the transition once
234     log_state_change();
<a name="12" id="anc12"></a><span class="line-modified">235   } // leave critical region under Patching_lock</span>
236 
237 
238   if (TraceCreateZombies) {
239     ResourceMark m;
240     tty-&gt;print_cr(&quot;aot method &lt;&quot; INTPTR_FORMAT &quot;&gt; %s code made entrant&quot;, p2i(this), this-&gt;method() ? this-&gt;method()-&gt;name_and_sig_as_C_string() : &quot;null&quot;);
241   }
242 
243   return true;
244 }
245 #endif // TIERED
246 
247 // Iterate over metadata calling this function.   Used by RedefineClasses
248 // Copied from nmethod::metadata_do
<a name="13" id="anc13"></a><span class="line-modified">249 void AOTCompiledMethod::metadata_do(void f(Metadata*)) {</span>
250   address low_boundary = verified_entry_point();
251   {
252     // Visit all immediate references that are embedded in the instruction stream.
253     RelocIterator iter(this, low_boundary);
254     while (iter.next()) {
255       if (iter.type() == relocInfo::metadata_type ) {
256         metadata_Relocation* r = iter.metadata_reloc();
257         // In this metadata, we must only follow those metadatas directly embedded in
258         // the code.  Other metadatas (oop_index&gt;0) are seen as part of
259         // the metadata section below.
260         assert(1 == (r-&gt;metadata_is_immediate()) +
261                (r-&gt;metadata_addr() &gt;= metadata_begin() &amp;&amp; r-&gt;metadata_addr() &lt; metadata_end()),
262                &quot;metadata must be found in exactly one place&quot;);
263         if (r-&gt;metadata_is_immediate() &amp;&amp; r-&gt;metadata_value() != NULL) {
264           Metadata* md = r-&gt;metadata_value();
<a name="14" id="anc14"></a><span class="line-modified">265           if (md != _method) f(md);</span>
266         }
267       } else if (iter.type() == relocInfo::virtual_call_type) {
268         ResourceMark rm;
269         // Check compiledIC holders associated with this nmethod
270         CompiledIC *ic = CompiledIC_at(&amp;iter);
271         if (ic-&gt;is_icholder_call()) {
272           CompiledICHolder* cichk = ic-&gt;cached_icholder();
<a name="15" id="anc15"></a><span class="line-modified">273           f(cichk-&gt;holder_metadata());</span>
<span class="line-modified">274           f(cichk-&gt;holder_klass());</span>
275         } else {
276           // Get Klass* or NULL (if value is -1) from GOT cell of virtual call PLT stub.
277           Metadata* ic_oop = ic-&gt;cached_metadata();
278           if (ic_oop != NULL) {
<a name="16" id="anc16"></a><span class="line-modified">279             f(ic_oop);</span>
280           }
281         }
282       } else if (iter.type() == relocInfo::static_call_type ||
<a name="17" id="anc17"></a><span class="line-modified">283                  iter.type() == relocInfo::opt_virtual_call_type){</span>
284         // Check Method* in AOT c2i stub for other calls.
285         Metadata* meta = (Metadata*)nativeLoadGot_at(nativePltCall_at(iter.addr())-&gt;plt_c2i_stub())-&gt;data();
286         if (meta != NULL) {
<a name="18" id="anc18"></a><span class="line-modified">287           f(meta);</span>
288         }
289       }
290     }
291   }
292 
293   // Visit the metadata section
294   for (Metadata** p = metadata_begin(); p &lt; metadata_end(); p++) {
295     Metadata* m = *p;
296 
297     intptr_t meta = (intptr_t)m;
298     if ((meta &amp; 1) == 1) {
299       // already resolved
300       m = (Metadata*)(meta &amp; ~1);
301     } else {
302       continue;
303     }
304     assert(Metaspace::contains(m), &quot;&quot;);
<a name="19" id="anc19"></a><span class="line-modified">305     f(m);</span>
306   }
307 
308   // Visit metadata not embedded in the other places.
<a name="20" id="anc20"></a><span class="line-modified">309   if (_method != NULL) f(_method);</span>
310 }
311 
312 void AOTCompiledMethod::print() const {
313   print_on(tty, &quot;AOTCompiledMethod&quot;);
314 }
315 
316 void AOTCompiledMethod::print_on(outputStream* st) const {
317   print_on(st, &quot;AOTCompiledMethod&quot;);
318 }
319 
320 // Print out more verbose output usually for a newly created aot method.
321 void AOTCompiledMethod::print_on(outputStream* st, const char* msg) const {
322   if (st != NULL) {
323     ttyLocker ttyl;
324     st-&gt;print(&quot;%7d &quot;, (int) st-&gt;time_stamp().milliseconds());
325     st-&gt;print(&quot;%4d &quot;, _aot_id);    // print compilation number
326     st-&gt;print(&quot;    aot[%2d]&quot;, _heap-&gt;dso_id());
327     // Stubs have _method == NULL
328     if (_method == NULL) {
329       st-&gt;print(&quot;   %s&quot;, _name);
330     } else {
331       ResourceMark m;
332       st-&gt;print(&quot;   %s&quot;, _method-&gt;name_and_sig_as_C_string());
333     }
334     if (Verbose) {
335       st-&gt;print(&quot; entry at &quot; INTPTR_FORMAT, p2i(_code));
336     }
337     if (msg != NULL) {
338       st-&gt;print(&quot;   %s&quot;, msg);
339     }
340     st-&gt;cr();
341   }
342 }
343 
344 void AOTCompiledMethod::print_value_on(outputStream* st) const {
345   st-&gt;print(&quot;AOTCompiledMethod &quot;);
346   print_on(st, NULL);
347 }
348 
349 // Print a short set of xml attributes to identify this aot method.  The
350 // output should be embedded in some other element.
351 void AOTCompiledMethod::log_identity(xmlStream* log) const {
352   log-&gt;print(&quot; aot_id=&#39;%d&#39;&quot;, _aot_id);
353   log-&gt;print(&quot; aot=&#39;%2d&#39;&quot;, _heap-&gt;dso_id());
354 }
355 
356 void AOTCompiledMethod::log_state_change() const {
357   if (LogCompilation) {
358     ResourceMark m;
359     if (xtty != NULL) {
360       ttyLocker ttyl;  // keep the following output all in one block
361       if (*_state_adr == not_entrant) {
362         xtty-&gt;begin_elem(&quot;make_not_entrant thread=&#39;&quot; UINTX_FORMAT &quot;&#39;&quot;,
363                          os::current_thread_id());
364       } else if (*_state_adr == not_used) {
365         xtty-&gt;begin_elem(&quot;make_not_used thread=&#39;&quot; UINTX_FORMAT &quot;&#39;&quot;,
366                          os::current_thread_id());
367       } else if (*_state_adr == in_use) {
368         xtty-&gt;begin_elem(&quot;make_entrant thread=&#39;&quot; UINTX_FORMAT &quot;&#39;&quot;,
369                          os::current_thread_id());
370       }
371       log_identity(xtty);
372       xtty-&gt;stamp();
373       xtty-&gt;end_elem();
374     }
375   }
376   if (PrintCompilation) {
377     ResourceMark m;
378     if (*_state_adr == not_entrant) {
379       print_on(tty, &quot;made not entrant&quot;);
380     } else if (*_state_adr == not_used) {
381       print_on(tty, &quot;made not used&quot;);
382     } else if (*_state_adr == in_use) {
383       print_on(tty, &quot;made entrant&quot;);
384     }
385   }
386 }
387 
388 
389 NativeInstruction* PltNativeCallWrapper::get_load_instruction(virtual_call_Relocation* r) const {
390   return nativeLoadGot_at(_call-&gt;plt_load_got());
391 }
392 
393 void PltNativeCallWrapper::verify_resolve_call(address dest) const {
394   CodeBlob* db = CodeCache::find_blob_unsafe(dest);
395   if (db == NULL) {
396     assert(dest == _call-&gt;plt_resolve_call(), &quot;sanity&quot;);
397   }
398 }
399 
400 void PltNativeCallWrapper::set_to_interpreted(const methodHandle&amp; method, CompiledICInfo&amp; info) {
401   assert(!info.to_aot(), &quot;only for nmethod&quot;);
402   CompiledPltStaticCall* csc = CompiledPltStaticCall::at(instruction_address());
403   csc-&gt;set_to_interpreted(method, info.entry());
404 }
405 
406 NativeCallWrapper* AOTCompiledMethod::call_wrapper_at(address call) const {
407   return new PltNativeCallWrapper((NativePltCall*) call);
408 }
409 
410 NativeCallWrapper* AOTCompiledMethod::call_wrapper_before(address return_pc) const {
411   return new PltNativeCallWrapper(nativePltCall_before(return_pc));
412 }
413 
414 CompiledStaticCall* AOTCompiledMethod::compiledStaticCall_at(Relocation* call_site) const {
415   return CompiledPltStaticCall::at(call_site);
416 }
417 
418 CompiledStaticCall* AOTCompiledMethod::compiledStaticCall_at(address call_site) const {
419   return CompiledPltStaticCall::at(call_site);
420 }
421 
422 CompiledStaticCall* AOTCompiledMethod::compiledStaticCall_before(address return_addr) const {
423   return CompiledPltStaticCall::before(return_addr);
424 }
425 
426 address AOTCompiledMethod::call_instruction_address(address pc) const {
427   NativePltCall* pltcall = nativePltCall_before(pc);
428   return pltcall-&gt;instruction_address();
429 }
430 
431 void AOTCompiledMethod::clear_inline_caches() {
432   assert(SafepointSynchronize::is_at_safepoint(), &quot;cleaning of IC&#39;s only allowed at safepoint&quot;);
433   if (is_zombie()) {
434     return;
435   }
436 
437   ResourceMark rm;
438   RelocIterator iter(this);
439   while (iter.next()) {
440     iter.reloc()-&gt;clear_inline_cache();
441     if (iter.type() == relocInfo::opt_virtual_call_type) {
442       CompiledIC* cic = CompiledIC_at(&amp;iter);
443       assert(cic-&gt;is_clean(), &quot;!&quot;);
444       nativePltCall_at(iter.addr())-&gt;set_stub_to_clean();
445     }
446   }
447 }
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/aot/aotCodeHeap.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../adlc/output_h.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="aotCodeHeap.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/aot/aotCodeHeap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -32,17 +32,24 @@</span>
  #include &quot;gc/shared/gcConfig.hpp&quot;
  #include &quot;gc/g1/heapRegion.hpp&quot;
  #include &quot;interpreter/abstractInterpreter.hpp&quot;
  #include &quot;jvmci/compilerRuntime.hpp&quot;
  #include &quot;jvmci/jvmciRuntime.hpp&quot;
<span class="udiff-line-added">+ #include &quot;logging/log.hpp&quot;</span>
  #include &quot;memory/allocation.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/universe.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;oops/compressedOops.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;oops/klass.inline.hpp&quot;</span>
  #include &quot;oops/method.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;runtime/deoptimization.hpp&quot;</span>
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
  #include &quot;runtime/safepointVerifiers.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/vmOperations.hpp&quot;
<span class="udiff-line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  #include &quot;utilities/sizes.hpp&quot;
  
  bool AOTLib::_narrow_oop_shift_initialized = false;
  int  AOTLib::_narrow_oop_shift = 0;
  int  AOTLib::_narrow_klass_shift = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -87,11 +94,11 @@</span>
    // Use class loader of aot method.
    Handle loader(thread, caller-&gt;method_holder()-&gt;class_loader());
    Handle protection_domain(thread, caller-&gt;method_holder()-&gt;protection_domain());
  
    // Ignore wrapping L and ;
<span class="udiff-line-modified-removed">-   if (name[0] == &#39;L&#39;) {</span>
<span class="udiff-line-modified-added">+   if (name[0] == JVM_SIGNATURE_CLASS) {</span>
      assert(len &gt; 2, &quot;small name %s&quot;, name);
      name++;
      len -= 2;
    }
    TempNewSymbol sym = SymbolTable::probe(name, len);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -173,15 +180,12 @@</span>
    verify_flag(_config-&gt;_useCompressedClassPointers, UseCompressedClassPointers, &quot;UseCompressedClassPointers&quot;);
    verify_flag(_config-&gt;_useTLAB, UseTLAB, &quot;UseTLAB&quot;);
    verify_flag(_config-&gt;_useBiasedLocking, UseBiasedLocking, &quot;UseBiasedLocking&quot;);
    verify_flag(_config-&gt;_objectAlignment, ObjectAlignmentInBytes, &quot;ObjectAlignmentInBytes&quot;);
    verify_flag(_config-&gt;_contendedPaddingWidth, ContendedPaddingWidth, &quot;ContendedPaddingWidth&quot;);
<span class="udiff-line-removed">-   verify_flag(_config-&gt;_fieldsAllocationStyle, FieldsAllocationStyle, &quot;FieldsAllocationStyle&quot;);</span>
<span class="udiff-line-removed">-   verify_flag(_config-&gt;_compactFields, CompactFields, &quot;CompactFields&quot;);</span>
    verify_flag(_config-&gt;_enableContended, EnableContended, &quot;EnableContended&quot;);
    verify_flag(_config-&gt;_restrictContended, RestrictContended, &quot;RestrictContended&quot;);
<span class="udiff-line-removed">-   verify_flag(_config-&gt;_threadLocalHandshakes, ThreadLocalHandshakes, &quot;ThreadLocalHandshakes&quot;);</span>
  
    if (!TieredCompilation &amp;&amp; _config-&gt;_tieredAOT) {
      handle_config_error(&quot;Shared file %s error: Expected to run with tiered compilation on&quot;, _name);
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -208,16 +212,12 @@</span>
  AOTLib::~AOTLib() {
    os::free((void*) _name);
  }
  
  AOTCodeHeap::~AOTCodeHeap() {
<span class="udiff-line-modified-removed">-   if (_classes != NULL) {</span>
<span class="udiff-line-modified-removed">-     FREE_C_HEAP_ARRAY(AOTClass, _classes);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   if (_code_to_aot != NULL) {</span>
<span class="udiff-line-removed">-     FREE_C_HEAP_ARRAY(CodeToAMethod, _code_to_aot);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   FREE_C_HEAP_ARRAY(AOTClass, _classes);</span>
<span class="udiff-line-modified-added">+   FREE_C_HEAP_ARRAY(CodeToAMethod, _code_to_aot);</span>
  }
  
  AOTLib::AOTLib(void* handle, const char* name, int dso_id) : _valid(true), _dl_handle(handle), _dso_id(dso_id) {
    _name = (const char*) os::strdup(name);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -344,18 +344,21 @@</span>
      return;
    }
    AOTCompiledMethod *aot = new AOTCompiledMethod(code, mh(), meta, metadata_table, metadata_size, state_adr, this, name, code_id, _aot_id);
    assert(_code_to_aot[code_id]._aot == NULL, &quot;should be not initialized&quot;);
    _code_to_aot[code_id]._aot = aot; // Should set this first
<span class="udiff-line-modified-removed">-   if (Atomic::cmpxchg(in_use, &amp;_code_to_aot[code_id]._state, not_set) != not_set) {</span>
<span class="udiff-line-modified-added">+   if (Atomic::cmpxchg(&amp;_code_to_aot[code_id]._state, not_set, in_use) != not_set) {</span>
      _code_to_aot[code_id]._aot = NULL; // Clean
    } else { // success
      // Publish method
  #ifdef TIERED
      mh-&gt;set_aot_code(aot);
  #endif
<span class="udiff-line-modified-removed">-     Method::set_code(mh, aot);</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-added">+       MutexLocker pl(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-added">+       Method::set_code(mh, aot);</span>
<span class="udiff-line-added">+     }</span>
      if (PrintAOT || (PrintCompilation &amp;&amp; PrintAOT)) {
        PauseNoSafepointVerifier pnsv(&amp;nsv); // aot code is registered already
        aot-&gt;print_on(tty, NULL);
      }
      // Publish oop only after we are visible to CompiledMethodIterator
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -397,21 +400,18 @@</span>
      assert(code_id &lt; _method_count, &quot;sanity&quot;);
      jlong* state_adr = &amp;_method_state[code_id];
      int len = Bytes::get_Java_u2((address)stub_name);
      stub_name += 2;
      char* full_name = NEW_C_HEAP_ARRAY(char, len+5, mtCode);
<span class="udiff-line-removed">-     if (full_name == NULL) { // No memory?</span>
<span class="udiff-line-removed">-       break;</span>
<span class="udiff-line-removed">-     }</span>
      memcpy(full_name, &quot;AOT &quot;, 4);
      memcpy(full_name+4, stub_name, len);
      full_name[len+4] = 0;
      guarantee(_code_to_aot[code_id]._state != invalid, &quot;stub %s can&#39;t be invalidated&quot;, full_name);
      AOTCompiledMethod* aot = new AOTCompiledMethod(entry, NULL, meta, metadata_table, metadata_size, state_adr, this, full_name, code_id, i);
      assert(_code_to_aot[code_id]._aot  == NULL, &quot;should be not initialized&quot;);
      _code_to_aot[code_id]._aot  = aot;
<span class="udiff-line-modified-removed">-     if (Atomic::cmpxchg(in_use, &amp;_code_to_aot[code_id]._state, not_set) != not_set) {</span>
<span class="udiff-line-modified-added">+     if (Atomic::cmpxchg(&amp;_code_to_aot[code_id]._state, not_set, in_use) != not_set) {</span>
        fatal(&quot;stab &#39;%s&#39; code state is %d&quot;, full_name, _code_to_aot[code_id]._state);
      }
      // Adjust code buffer boundaries only for stubs because they are last in the buffer.
      adjust_boundaries(aot);
      if (PrintAOT &amp;&amp; Verbose) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -448,11 +448,10 @@</span>
  #if INCLUDE_G1GC
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_write_barrier_pre&quot;, address, JVMCIRuntime::write_barrier_pre);
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_write_barrier_post&quot;, address, JVMCIRuntime::write_barrier_post);
  #endif
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_identity_hash_code&quot;, address, JVMCIRuntime::identity_hash_code);
<span class="udiff-line-removed">-     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_thread_is_interrupted&quot;, address, JVMCIRuntime::thread_is_interrupted);</span>
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_exception_handler_for_pc&quot;, address, JVMCIRuntime::exception_handler_for_pc);
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_test_deoptimize_call_int&quot;, address, JVMCIRuntime::test_deoptimize_call_int);
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_throw_and_post_jvmti_exception&quot;, address, JVMCIRuntime::throw_and_post_jvmti_exception);
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_throw_klass_external_name_exception&quot;, address, JVMCIRuntime::throw_klass_external_name_exception);
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_throw_class_cast_exception&quot;, address, JVMCIRuntime::throw_class_cast_exception);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -463,10 +462,11 @@</span>
  void AOTCodeHeap::link_shared_runtime_symbols() {
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_resolve_static_entry&quot;, address, SharedRuntime::get_resolve_static_call_stub());
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_resolve_virtual_entry&quot;, address, SharedRuntime::get_resolve_virtual_call_stub());
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_resolve_opt_virtual_entry&quot;, address, SharedRuntime::get_resolve_opt_virtual_call_stub());
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_deopt_blob_unpack&quot;, address, SharedRuntime::deopt_blob()-&gt;unpack());
<span class="udiff-line-added">+     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_deopt_blob_unpack_with_exception_in_tls&quot;, address, SharedRuntime::deopt_blob()-&gt;unpack_with_exception_in_tls());</span>
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_deopt_blob_uncommon_trap&quot;, address, SharedRuntime::deopt_blob()-&gt;uncommon_trap());
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_ic_miss_stub&quot;, address, SharedRuntime::get_ic_miss_stub());
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_handle_wrong_method_stub&quot;, address, SharedRuntime::get_handle_wrong_method_stub());
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_exception_handler_for_return_address&quot;, address, SharedRuntime::exception_handler_for_return_address);
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_register_finalizer&quot;, address, SharedRuntime::register_finalizer);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -528,10 +528,12 @@</span>
  
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_aescrypt_encryptBlock&quot;, address, StubRoutines::_aescrypt_encryptBlock);
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_aescrypt_decryptBlock&quot;, address, StubRoutines::_aescrypt_decryptBlock);
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_cipherBlockChaining_encryptAESCrypt&quot;, address, StubRoutines::_cipherBlockChaining_encryptAESCrypt);
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_cipherBlockChaining_decryptAESCrypt&quot;, address, StubRoutines::_cipherBlockChaining_decryptAESCrypt);
<span class="udiff-line-added">+     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_electronicCodeBook_encryptAESCrypt&quot;, address, StubRoutines::_electronicCodeBook_encryptAESCrypt);</span>
<span class="udiff-line-added">+     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_electronicCodeBook_decryptAESCrypt&quot;, address, StubRoutines::_electronicCodeBook_decryptAESCrypt);</span>
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_update_bytes_crc32&quot;, address, StubRoutines::_updateBytesCRC32);
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_crc_table_adr&quot;, address, StubRoutines::_crc_table_adr);
  
  
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_sha1_implCompress&quot;, address, StubRoutines::_sha1_implCompress);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -551,10 +553,12 @@</span>
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_squareToLen&quot;, address, StubRoutines::_squareToLen);
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_mulAdd&quot;, address, StubRoutines::_mulAdd);
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_montgomeryMultiply&quot;,  address, StubRoutines::_montgomeryMultiply);
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_montgomerySquare&quot;, address, StubRoutines::_montgomerySquare);
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_vectorizedMismatch&quot;, address, StubRoutines::_vectorizedMismatch);
<span class="udiff-line-added">+     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_bigIntegerRightShiftWorker&quot;, address, StubRoutines::_bigIntegerRightShiftWorker);</span>
<span class="udiff-line-added">+     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_bigIntegerLeftShiftWorker&quot;, address, StubRoutines::_bigIntegerLeftShiftWorker);</span>
  
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_throw_delayed_StackOverflowError_entry&quot;, address, StubRoutines::_throw_delayed_StackOverflowError_entry);
  
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -575,12 +579,12 @@</span>
      CollectedHeap* heap = Universe::heap();
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_card_table_address&quot;, address, (BarrierSet::barrier_set()-&gt;is_a(BarrierSet::CardTableBarrierSet) ? ci_card_table_address() : NULL));
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_heap_top_address&quot;, address, (heap-&gt;supports_inline_contig_alloc() ? heap-&gt;top_addr() : NULL));
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_heap_end_address&quot;, address, (heap-&gt;supports_inline_contig_alloc() ? heap-&gt;end_addr() : NULL));
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_polling_page&quot;, address, os::get_polling_page());
<span class="udiff-line-modified-removed">-     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_narrow_klass_base_address&quot;, address, Universe::narrow_klass_base());</span>
<span class="udiff-line-modified-removed">-     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_narrow_oop_base_address&quot;, address, Universe::narrow_oop_base());</span>
<span class="udiff-line-modified-added">+     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_narrow_klass_base_address&quot;, address, CompressedKlassPointers::base());</span>
<span class="udiff-line-modified-added">+     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_narrow_oop_base_address&quot;, address, CompressedOops::base());</span>
  #if INCLUDE_G1GC
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_log_of_heap_region_grain_bytes&quot;, int, HeapRegion::LogOfHRGrainBytes);
  #endif
      SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_inline_contiguous_allocation_supported&quot;, bool, heap-&gt;supports_inline_contig_alloc());
      link_shared_runtime_symbols();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -717,11 +721,11 @@</span>
  void AOTCodeHeap::sweep_dependent_methods(int* indexes, int methods_cnt) {
    int marked = 0;
    for (int i = 0; i &lt; methods_cnt; ++i) {
      int code_id = indexes[i];
      // Invalidate aot code.
<span class="udiff-line-modified-removed">-     if (Atomic::cmpxchg(invalid, &amp;_code_to_aot[code_id]._state, not_set) != not_set) {</span>
<span class="udiff-line-modified-added">+     if (Atomic::cmpxchg(&amp;_code_to_aot[code_id]._state, not_set, invalid) != not_set) {</span>
        if (_code_to_aot[code_id]._state == in_use) {
          AOTCompiledMethod* aot = _code_to_aot[code_id]._aot;
          assert(aot != NULL, &quot;aot should be set&quot;);
          if (!aot-&gt;is_runtime_stub()) { // Something is wrong - should not invalidate stubs.
            aot-&gt;mark_for_deoptimization(false);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -729,12 +733,11 @@</span>
          }
        }
      }
    }
    if (marked &gt; 0) {
<span class="udiff-line-modified-removed">-     VM_Deoptimize op;</span>
<span class="udiff-line-removed">-     VMThread::execute(&amp;op);</span>
<span class="udiff-line-modified-added">+     Deoptimization::deoptimize_all_marked();</span>
    }
  }
  
  void AOTCodeHeap::sweep_dependent_methods(AOTKlassData* klass_data) {
    // Make dependent methods non_entrant forever.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -929,17 +932,17 @@</span>
  }
  
  // Scan only klasses_got cells which should have only Klass*,
  // metadata_got cells are scanned only for alive AOT methods
  // by AOTCompiledMethod::metadata_do().
<span class="udiff-line-modified-removed">- void AOTCodeHeap::got_metadata_do(void f(Metadata*)) {</span>
<span class="udiff-line-modified-added">+ void AOTCodeHeap::got_metadata_do(MetadataClosure* f) {</span>
    for (int i = 1; i &lt; _klasses_got_size; i++) {
      Metadata** p = &amp;_klasses_got[i];
      Metadata* md = *p;
      if (md == NULL)  continue;  // skip non-oops
      if (Metaspace::contains(md)) {
<span class="udiff-line-modified-removed">-       f(md);</span>
<span class="udiff-line-modified-added">+       f-&gt;do_metadata(md);</span>
      } else {
        intptr_t meta = (intptr_t)md;
        fatal(&quot;Invalid value in _klasses_got[%d] = &quot; INTPTR_FORMAT, i, meta);
      }
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -967,11 +970,11 @@</span>
    }
    return count;
  }
  #endif
  
<span class="udiff-line-modified-removed">- void AOTCodeHeap::metadata_do(void f(Metadata*)) {</span>
<span class="udiff-line-modified-added">+ void AOTCodeHeap::metadata_do(MetadataClosure* f) {</span>
    for (int index = 0; index &lt; _method_count; index++) {
      if (_code_to_aot[index]._state != in_use) {
        continue; // Skip uninitialized entries.
      }
      AOTCompiledMethod* aot = _code_to_aot[index]._aot;
</pre>
<center><a href="../adlc/output_h.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="aotCodeHeap.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
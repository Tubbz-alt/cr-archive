<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/aot/aotLoader.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="aotCompiledMethod.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="aotLoader.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/aot/aotLoader.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
<span class="line-removed"> 25 #include &quot;jvm.h&quot;</span>
<span class="line-removed"> 26 </span>
 27 #include &quot;aot/aotCodeHeap.hpp&quot;
 28 #include &quot;aot/aotLoader.inline.hpp&quot;
<span class="line-modified"> 29 #include &quot;jvmci/jvmciRuntime.hpp&quot;</span>

 30 #include &quot;memory/allocation.inline.hpp&quot;


 31 #include &quot;oops/method.hpp&quot;
 32 #include &quot;runtime/handles.inline.hpp&quot;
 33 #include &quot;runtime/os.inline.hpp&quot;
 34 #include &quot;runtime/timerTrace.hpp&quot;
 35 
 36 GrowableArray&lt;AOTCodeHeap*&gt;* AOTLoader::_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray&lt;AOTCodeHeap*&gt; (2, true);
 37 GrowableArray&lt;AOTLib*&gt;* AOTLoader::_libraries = new(ResourceObj::C_HEAP, mtCode) GrowableArray&lt;AOTLib*&gt; (2, true);
 38 
 39 // Iterate over all AOT CodeHeaps
 40 #define FOR_ALL_AOT_HEAPS(heap) for (GrowableArrayIterator&lt;AOTCodeHeap*&gt; heap = heaps()-&gt;begin(); heap != heaps()-&gt;end(); ++heap)
 41 // Iterate over all AOT Libraries
 42 #define FOR_ALL_AOT_LIBRARIES(lib) for (GrowableArrayIterator&lt;AOTLib*&gt; lib = libraries()-&gt;begin(); lib != libraries()-&gt;end(); ++lib)
 43 
 44 void AOTLoader::load_for_klass(InstanceKlass* ik, Thread* thread) {
 45   if (ik-&gt;is_unsafe_anonymous()) {
 46     // don&#39;t even bother
 47     return;
 48   }
 49   if (UseAOT) {
 50     // We allow hotswap to be enabled after the onload phase, but not breakpoints
</pre>
<hr />
<pre>
 61     // don&#39;t even bother
 62     return 0;
 63   }
 64   FOR_ALL_AOT_HEAPS(heap) {
 65     AOTKlassData* klass_data = (*heap)-&gt;find_klass(ik);
 66     if (klass_data != NULL) {
 67       return klass_data-&gt;_fingerprint;
 68     }
 69   }
 70   return 0;
 71 }
 72 
 73 void AOTLoader::oops_do(OopClosure* f) {
 74   if (UseAOT) {
 75     FOR_ALL_AOT_HEAPS(heap) {
 76       (*heap)-&gt;oops_do(f);
 77     }
 78   }
 79 }
 80 
<span class="line-modified"> 81 void AOTLoader::metadata_do(void f(Metadata*)) {</span>
 82   if (UseAOT) {
 83     FOR_ALL_AOT_HEAPS(heap) {
 84       (*heap)-&gt;metadata_do(f);
 85     }
 86   }
 87 }
 88 
 89 void AOTLoader::mark_evol_dependent_methods(InstanceKlass* dependee) {
 90   if (UseAOT) {
 91     FOR_ALL_AOT_HEAPS(heap) {
 92       (*heap)-&gt;mark_evol_dependent_methods(dependee);
 93     }
 94   }
 95 }
 96 
 97 /**
 98  * List of core modules for which we search for shared libraries.
 99  */
100 static const char* modules[] = {
101   &quot;java.base&quot;,
</pre>
<hr />
<pre>
133 
134     // -Xint is not compatible with AOT
135     if (Arguments::is_interpreter_only()) {
136       if (PrintAOT) {
137         warning(&quot;-Xint is not compatible with AOT (switching AOT off)&quot;);
138       }
139       FLAG_SET_DEFAULT(UseAOT, false);
140       return;
141     }
142 
143 #ifdef _WINDOWS
144     const char pathSep = &#39;;&#39;;
145 #else
146     const char pathSep = &#39;:&#39;;
147 #endif
148 
149     // Scan the AOTLibrary option.
150     if (AOTLibrary != NULL) {
151       const int len = (int)strlen(AOTLibrary);
152       char* cp  = NEW_C_HEAP_ARRAY(char, len+1, mtCode);
<span class="line-modified">153       if (cp != NULL) { // No memory?</span>
<span class="line-modified">154         memcpy(cp, AOTLibrary, len);</span>
<span class="line-modified">155         cp[len] = &#39;\0&#39;;</span>
<span class="line-modified">156         char* end = cp + len;</span>
<span class="line-modified">157         while (cp &lt; end) {</span>
<span class="line-modified">158           const char* name = cp;</span>
<span class="line-modified">159           while ((*cp) != &#39;\0&#39; &amp;&amp; (*cp) != &#39;\n&#39; &amp;&amp; (*cp) != &#39;,&#39; &amp;&amp; (*cp) != pathSep) cp++;</span>
<span class="line-modified">160           cp[0] = &#39;\0&#39;;  // Terminate name</span>
<span class="line-modified">161           cp++;</span>
<span class="line-removed">162           load_library(name, true);</span>
<span class="line-removed">163         }</span>
164       }
165     }
166 
167     // Load well-know AOT libraries from Java installation directory.
168     const char* home = Arguments::get_java_home();
169     const char* file_separator = os::file_separator();
170 
171     for (int i = 0; i &lt; (int) (sizeof(modules) / sizeof(const char*)); i++) {
172       char library[JVM_MAXPATHLEN];
173       jio_snprintf(library, sizeof(library), &quot;%s%slib%slib%s%s%s%s&quot;, home, file_separator, file_separator, modules[i], UseCompressedOops ? &quot;-coop&quot; : &quot;&quot;, UseG1GC ? &quot;&quot; : &quot;-nong1&quot;, os::dll_file_extension());
174       load_library(library, false);
175     }
176   }
177 }
178 
179 void AOTLoader::universe_init() {
180   if (UseAOT &amp;&amp; libraries_count() &gt; 0) {
181     // Shifts are static values which initialized by 0 until java heap initialization.
182     // AOT libs are loaded before heap initialized so shift values are not set.
183     // It is okay since ObjectAlignmentInBytes flag which defines shifts value is set before AOT libs are loaded.
184     // AOT sets shift values during heap and metaspace initialization.
185     // Check shifts value to make sure thay did not change.
186     if (UseCompressedOops &amp;&amp; AOTLib::narrow_oop_shift_initialized()) {
<span class="line-modified">187       int oop_shift = Universe::narrow_oop_shift();</span>
188       FOR_ALL_AOT_LIBRARIES(lib) {
<span class="line-modified">189         (*lib)-&gt;verify_flag((*lib)-&gt;config()-&gt;_narrowOopShift, oop_shift, &quot;Universe::narrow_oop_shift&quot;);</span>
190       }
191       if (UseCompressedClassPointers) { // It is set only if UseCompressedOops is set
<span class="line-modified">192         int klass_shift = Universe::narrow_klass_shift();</span>
193         FOR_ALL_AOT_LIBRARIES(lib) {
<span class="line-modified">194           (*lib)-&gt;verify_flag((*lib)-&gt;config()-&gt;_narrowKlassShift, klass_shift, &quot;Universe::narrow_klass_shift&quot;);</span>
195         }
196       }
197     }
198     // Create heaps for all valid libraries
199     FOR_ALL_AOT_LIBRARIES(lib) {
200       if ((*lib)-&gt;is_valid()) {
201         AOTCodeHeap* heap = new AOTCodeHeap(*lib);
202         {
<span class="line-modified">203           MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
204           add_heap(heap);
205           CodeCache::add_heap(heap);
206         }
207       } else {
208         // Unload invalid libraries
209         os::dll_unload((*lib)-&gt;dl_handle());
210       }
211     }
212   }
213   if (heaps_count() == 0) {
214     if (FLAG_IS_DEFAULT(UseAOT)) {
215       FLAG_SET_DEFAULT(UseAOT, false);
216     }
217   }
218 }
219 
220 // Set shift value for compressed oops and classes based on first AOT library config.
221 // AOTLoader::universe_init(), which is called later, will check the shift value again to make sure nobody change it.
222 // This code is not executed during CDS dump because it runs in Interpreter mode and AOT is disabled in this mode.
223 
224 void AOTLoader::set_narrow_oop_shift() {
225   // This method is called from Universe::initialize_heap().
226   if (UseAOT &amp;&amp; libraries_count() &gt; 0 &amp;&amp;
227       UseCompressedOops &amp;&amp; AOTLib::narrow_oop_shift_initialized()) {
<span class="line-modified">228     if (Universe::narrow_oop_shift() == 0) {</span>
229       // 0 is valid shift value for small heap but we can safely increase it
230       // at this point when nobody used it yet.
<span class="line-modified">231       Universe::set_narrow_oop_shift(AOTLib::narrow_oop_shift());</span>
232     }
233   }
234 }
235 
236 void AOTLoader::set_narrow_klass_shift() {
237   // This method is called from Metaspace::set_narrow_klass_base_and_shift().
238   if (UseAOT &amp;&amp; libraries_count() &gt; 0 &amp;&amp;
239       UseCompressedOops &amp;&amp; AOTLib::narrow_oop_shift_initialized() &amp;&amp;
240       UseCompressedClassPointers) {
<span class="line-modified">241     if (Universe::narrow_klass_shift() == 0) {</span>
<span class="line-modified">242       Universe::set_narrow_klass_shift(AOTLib::narrow_klass_shift());</span>
243     }
244   }
245 }
246 
247 void AOTLoader::load_library(const char* name, bool exit_on_error) {
248   // Skip library if a library with the same name is already loaded.
249   const int file_separator = *os::file_separator();
250   const char* start = strrchr(name, file_separator);
251   const char* new_name = (start == NULL) ? name : (start + 1);
252   FOR_ALL_AOT_LIBRARIES(lib) {
253     const char* lib_name = (*lib)-&gt;name();
254     start = strrchr(lib_name, file_separator);
255     const char* old_name = (start == NULL) ? lib_name : (start + 1);
256     if (strcmp(old_name, new_name) == 0) {
257       if (PrintAOT) {
258         warning(&quot;AOT library %s is already loaded as %s.&quot;, name, lib_name);
259       }
260       return;
261     }
262   }
</pre>
<hr />
<pre>
302   guarantee(caller_cb != NULL &amp;&amp; caller_cb-&gt;is_compiled(), &quot;must be called from compiled method&quot;);
303   CompiledMethod* cm = caller_cb-&gt;as_compiled_method();
304 
305   if (!cm-&gt;is_aot()) {
306     return true;
307   }
308   AOTCompiledMethod* aot = (AOTCompiledMethod*)cm;
309 
310   AOTCodeHeap* caller_heap = NULL;
311   FOR_ALL_AOT_HEAPS(heap) {
312     if ((*heap)-&gt;contains_blob(aot)) {
313       caller_heap = *heap;
314       break;
315     }
316   }
317   guarantee(caller_heap != NULL, &quot;CodeHeap not found&quot;);
318   bool success = caller_heap-&gt;reconcile_dynamic_invoke(aot, holder, index, adapter_method, appendix_klass);
319   vmassert(success || thread-&gt;last_frame().sender(&amp;map).is_deoptimized_frame(), &quot;caller not deoptimized on failure&quot;);
320   return success;
321 }





















</pre>
</td>
<td>
<hr />
<pre>
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;


 25 #include &quot;aot/aotCodeHeap.hpp&quot;
 26 #include &quot;aot/aotLoader.inline.hpp&quot;
<span class="line-modified"> 27 #include &quot;classfile/javaClasses.hpp&quot;</span>
<span class="line-added"> 28 #include &quot;jvm.h&quot;</span>
 29 #include &quot;memory/allocation.inline.hpp&quot;
<span class="line-added"> 30 #include &quot;memory/resourceArea.hpp&quot;</span>
<span class="line-added"> 31 #include &quot;oops/compressedOops.hpp&quot;</span>
 32 #include &quot;oops/method.hpp&quot;
 33 #include &quot;runtime/handles.inline.hpp&quot;
 34 #include &quot;runtime/os.inline.hpp&quot;
 35 #include &quot;runtime/timerTrace.hpp&quot;
 36 
 37 GrowableArray&lt;AOTCodeHeap*&gt;* AOTLoader::_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray&lt;AOTCodeHeap*&gt; (2, true);
 38 GrowableArray&lt;AOTLib*&gt;* AOTLoader::_libraries = new(ResourceObj::C_HEAP, mtCode) GrowableArray&lt;AOTLib*&gt; (2, true);
 39 
 40 // Iterate over all AOT CodeHeaps
 41 #define FOR_ALL_AOT_HEAPS(heap) for (GrowableArrayIterator&lt;AOTCodeHeap*&gt; heap = heaps()-&gt;begin(); heap != heaps()-&gt;end(); ++heap)
 42 // Iterate over all AOT Libraries
 43 #define FOR_ALL_AOT_LIBRARIES(lib) for (GrowableArrayIterator&lt;AOTLib*&gt; lib = libraries()-&gt;begin(); lib != libraries()-&gt;end(); ++lib)
 44 
 45 void AOTLoader::load_for_klass(InstanceKlass* ik, Thread* thread) {
 46   if (ik-&gt;is_unsafe_anonymous()) {
 47     // don&#39;t even bother
 48     return;
 49   }
 50   if (UseAOT) {
 51     // We allow hotswap to be enabled after the onload phase, but not breakpoints
</pre>
<hr />
<pre>
 62     // don&#39;t even bother
 63     return 0;
 64   }
 65   FOR_ALL_AOT_HEAPS(heap) {
 66     AOTKlassData* klass_data = (*heap)-&gt;find_klass(ik);
 67     if (klass_data != NULL) {
 68       return klass_data-&gt;_fingerprint;
 69     }
 70   }
 71   return 0;
 72 }
 73 
 74 void AOTLoader::oops_do(OopClosure* f) {
 75   if (UseAOT) {
 76     FOR_ALL_AOT_HEAPS(heap) {
 77       (*heap)-&gt;oops_do(f);
 78     }
 79   }
 80 }
 81 
<span class="line-modified"> 82 void AOTLoader::metadata_do(MetadataClosure* f) {</span>
 83   if (UseAOT) {
 84     FOR_ALL_AOT_HEAPS(heap) {
 85       (*heap)-&gt;metadata_do(f);
 86     }
 87   }
 88 }
 89 
 90 void AOTLoader::mark_evol_dependent_methods(InstanceKlass* dependee) {
 91   if (UseAOT) {
 92     FOR_ALL_AOT_HEAPS(heap) {
 93       (*heap)-&gt;mark_evol_dependent_methods(dependee);
 94     }
 95   }
 96 }
 97 
 98 /**
 99  * List of core modules for which we search for shared libraries.
100  */
101 static const char* modules[] = {
102   &quot;java.base&quot;,
</pre>
<hr />
<pre>
134 
135     // -Xint is not compatible with AOT
136     if (Arguments::is_interpreter_only()) {
137       if (PrintAOT) {
138         warning(&quot;-Xint is not compatible with AOT (switching AOT off)&quot;);
139       }
140       FLAG_SET_DEFAULT(UseAOT, false);
141       return;
142     }
143 
144 #ifdef _WINDOWS
145     const char pathSep = &#39;;&#39;;
146 #else
147     const char pathSep = &#39;:&#39;;
148 #endif
149 
150     // Scan the AOTLibrary option.
151     if (AOTLibrary != NULL) {
152       const int len = (int)strlen(AOTLibrary);
153       char* cp  = NEW_C_HEAP_ARRAY(char, len+1, mtCode);
<span class="line-modified">154       memcpy(cp, AOTLibrary, len);</span>
<span class="line-modified">155       cp[len] = &#39;\0&#39;;</span>
<span class="line-modified">156       char* end = cp + len;</span>
<span class="line-modified">157       while (cp &lt; end) {</span>
<span class="line-modified">158         const char* name = cp;</span>
<span class="line-modified">159         while ((*cp) != &#39;\0&#39; &amp;&amp; (*cp) != &#39;\n&#39; &amp;&amp; (*cp) != &#39;,&#39; &amp;&amp; (*cp) != pathSep) cp++;</span>
<span class="line-modified">160         cp[0] = &#39;\0&#39;;  // Terminate name</span>
<span class="line-modified">161         cp++;</span>
<span class="line-modified">162         load_library(name, true);</span>


163       }
164     }
165 
166     // Load well-know AOT libraries from Java installation directory.
167     const char* home = Arguments::get_java_home();
168     const char* file_separator = os::file_separator();
169 
170     for (int i = 0; i &lt; (int) (sizeof(modules) / sizeof(const char*)); i++) {
171       char library[JVM_MAXPATHLEN];
172       jio_snprintf(library, sizeof(library), &quot;%s%slib%slib%s%s%s%s&quot;, home, file_separator, file_separator, modules[i], UseCompressedOops ? &quot;-coop&quot; : &quot;&quot;, UseG1GC ? &quot;&quot; : &quot;-nong1&quot;, os::dll_file_extension());
173       load_library(library, false);
174     }
175   }
176 }
177 
178 void AOTLoader::universe_init() {
179   if (UseAOT &amp;&amp; libraries_count() &gt; 0) {
180     // Shifts are static values which initialized by 0 until java heap initialization.
181     // AOT libs are loaded before heap initialized so shift values are not set.
182     // It is okay since ObjectAlignmentInBytes flag which defines shifts value is set before AOT libs are loaded.
183     // AOT sets shift values during heap and metaspace initialization.
184     // Check shifts value to make sure thay did not change.
185     if (UseCompressedOops &amp;&amp; AOTLib::narrow_oop_shift_initialized()) {
<span class="line-modified">186       int oop_shift = CompressedOops::shift();</span>
187       FOR_ALL_AOT_LIBRARIES(lib) {
<span class="line-modified">188         (*lib)-&gt;verify_flag((*lib)-&gt;config()-&gt;_narrowOopShift, oop_shift, &quot;CompressedOops::shift&quot;);</span>
189       }
190       if (UseCompressedClassPointers) { // It is set only if UseCompressedOops is set
<span class="line-modified">191         int klass_shift = CompressedKlassPointers::shift();</span>
192         FOR_ALL_AOT_LIBRARIES(lib) {
<span class="line-modified">193           (*lib)-&gt;verify_flag((*lib)-&gt;config()-&gt;_narrowKlassShift, klass_shift, &quot;CompressedKlassPointers::shift&quot;);</span>
194         }
195       }
196     }
197     // Create heaps for all valid libraries
198     FOR_ALL_AOT_LIBRARIES(lib) {
199       if ((*lib)-&gt;is_valid()) {
200         AOTCodeHeap* heap = new AOTCodeHeap(*lib);
201         {
<span class="line-modified">202           MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
203           add_heap(heap);
204           CodeCache::add_heap(heap);
205         }
206       } else {
207         // Unload invalid libraries
208         os::dll_unload((*lib)-&gt;dl_handle());
209       }
210     }
211   }
212   if (heaps_count() == 0) {
213     if (FLAG_IS_DEFAULT(UseAOT)) {
214       FLAG_SET_DEFAULT(UseAOT, false);
215     }
216   }
217 }
218 
219 // Set shift value for compressed oops and classes based on first AOT library config.
220 // AOTLoader::universe_init(), which is called later, will check the shift value again to make sure nobody change it.
221 // This code is not executed during CDS dump because it runs in Interpreter mode and AOT is disabled in this mode.
222 
223 void AOTLoader::set_narrow_oop_shift() {
224   // This method is called from Universe::initialize_heap().
225   if (UseAOT &amp;&amp; libraries_count() &gt; 0 &amp;&amp;
226       UseCompressedOops &amp;&amp; AOTLib::narrow_oop_shift_initialized()) {
<span class="line-modified">227     if (CompressedOops::shift() == 0) {</span>
228       // 0 is valid shift value for small heap but we can safely increase it
229       // at this point when nobody used it yet.
<span class="line-modified">230       CompressedOops::set_shift(AOTLib::narrow_oop_shift());</span>
231     }
232   }
233 }
234 
235 void AOTLoader::set_narrow_klass_shift() {
236   // This method is called from Metaspace::set_narrow_klass_base_and_shift().
237   if (UseAOT &amp;&amp; libraries_count() &gt; 0 &amp;&amp;
238       UseCompressedOops &amp;&amp; AOTLib::narrow_oop_shift_initialized() &amp;&amp;
239       UseCompressedClassPointers) {
<span class="line-modified">240     if (CompressedKlassPointers::shift() == 0) {</span>
<span class="line-modified">241       CompressedKlassPointers::set_shift(AOTLib::narrow_klass_shift());</span>
242     }
243   }
244 }
245 
246 void AOTLoader::load_library(const char* name, bool exit_on_error) {
247   // Skip library if a library with the same name is already loaded.
248   const int file_separator = *os::file_separator();
249   const char* start = strrchr(name, file_separator);
250   const char* new_name = (start == NULL) ? name : (start + 1);
251   FOR_ALL_AOT_LIBRARIES(lib) {
252     const char* lib_name = (*lib)-&gt;name();
253     start = strrchr(lib_name, file_separator);
254     const char* old_name = (start == NULL) ? lib_name : (start + 1);
255     if (strcmp(old_name, new_name) == 0) {
256       if (PrintAOT) {
257         warning(&quot;AOT library %s is already loaded as %s.&quot;, name, lib_name);
258       }
259       return;
260     }
261   }
</pre>
<hr />
<pre>
301   guarantee(caller_cb != NULL &amp;&amp; caller_cb-&gt;is_compiled(), &quot;must be called from compiled method&quot;);
302   CompiledMethod* cm = caller_cb-&gt;as_compiled_method();
303 
304   if (!cm-&gt;is_aot()) {
305     return true;
306   }
307   AOTCompiledMethod* aot = (AOTCompiledMethod*)cm;
308 
309   AOTCodeHeap* caller_heap = NULL;
310   FOR_ALL_AOT_HEAPS(heap) {
311     if ((*heap)-&gt;contains_blob(aot)) {
312       caller_heap = *heap;
313       break;
314     }
315   }
316   guarantee(caller_heap != NULL, &quot;CodeHeap not found&quot;);
317   bool success = caller_heap-&gt;reconcile_dynamic_invoke(aot, holder, index, adapter_method, appendix_klass);
318   vmassert(success || thread-&gt;last_frame().sender(&amp;map).is_deoptimized_frame(), &quot;caller not deoptimized on failure&quot;);
319   return success;
320 }
<span class="line-added">321 </span>
<span class="line-added">322 </span>
<span class="line-added">323 // This should be called very early during startup before any of the AOTed methods that use boxes can deoptimize.</span>
<span class="line-added">324 // Deoptimization machinery expects the caches to be present and populated.</span>
<span class="line-added">325 void AOTLoader::initialize_box_caches(TRAPS) {</span>
<span class="line-added">326   if (!UseAOT || libraries_count() == 0) {</span>
<span class="line-added">327     return;</span>
<span class="line-added">328   }</span>
<span class="line-added">329   TraceTime timer(&quot;AOT initialization of box caches&quot;, TRACETIME_LOG(Info, aot, startuptime));</span>
<span class="line-added">330   Symbol* box_classes[] = { java_lang_Boolean::symbol(), java_lang_Byte_ByteCache::symbol(),</span>
<span class="line-added">331     java_lang_Short_ShortCache::symbol(), java_lang_Character_CharacterCache::symbol(),</span>
<span class="line-added">332     java_lang_Integer_IntegerCache::symbol(), java_lang_Long_LongCache::symbol() };</span>
<span class="line-added">333 </span>
<span class="line-added">334   for (unsigned i = 0; i &lt; sizeof(box_classes) / sizeof(Symbol*); i++) {</span>
<span class="line-added">335     Klass* k = SystemDictionary::resolve_or_fail(box_classes[i], true, CHECK);</span>
<span class="line-added">336     InstanceKlass* ik = InstanceKlass::cast(k);</span>
<span class="line-added">337     if (ik-&gt;is_not_initialized()) {</span>
<span class="line-added">338       ik-&gt;initialize(CHECK);</span>
<span class="line-added">339     }</span>
<span class="line-added">340   }</span>
<span class="line-added">341 }</span>
</pre>
</td>
</tr>
</table>
<center><a href="aotCompiledMethod.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="aotLoader.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
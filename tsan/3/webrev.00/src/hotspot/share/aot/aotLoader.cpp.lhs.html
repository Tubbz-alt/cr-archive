<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/aot/aotLoader.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
<a name="1" id="anc1"></a><span class="line-removed"> 25 #include &quot;jvm.h&quot;</span>
<span class="line-removed"> 26 </span>
 27 #include &quot;aot/aotCodeHeap.hpp&quot;
 28 #include &quot;aot/aotLoader.inline.hpp&quot;
<a name="2" id="anc2"></a><span class="line-modified"> 29 #include &quot;jvmci/jvmciRuntime.hpp&quot;</span>

 30 #include &quot;memory/allocation.inline.hpp&quot;
<a name="3" id="anc3"></a>

 31 #include &quot;oops/method.hpp&quot;
 32 #include &quot;runtime/handles.inline.hpp&quot;
 33 #include &quot;runtime/os.inline.hpp&quot;
 34 #include &quot;runtime/timerTrace.hpp&quot;
 35 
 36 GrowableArray&lt;AOTCodeHeap*&gt;* AOTLoader::_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray&lt;AOTCodeHeap*&gt; (2, true);
 37 GrowableArray&lt;AOTLib*&gt;* AOTLoader::_libraries = new(ResourceObj::C_HEAP, mtCode) GrowableArray&lt;AOTLib*&gt; (2, true);
 38 
 39 // Iterate over all AOT CodeHeaps
 40 #define FOR_ALL_AOT_HEAPS(heap) for (GrowableArrayIterator&lt;AOTCodeHeap*&gt; heap = heaps()-&gt;begin(); heap != heaps()-&gt;end(); ++heap)
 41 // Iterate over all AOT Libraries
 42 #define FOR_ALL_AOT_LIBRARIES(lib) for (GrowableArrayIterator&lt;AOTLib*&gt; lib = libraries()-&gt;begin(); lib != libraries()-&gt;end(); ++lib)
 43 
 44 void AOTLoader::load_for_klass(InstanceKlass* ik, Thread* thread) {
 45   if (ik-&gt;is_unsafe_anonymous()) {
 46     // don&#39;t even bother
 47     return;
 48   }
 49   if (UseAOT) {
 50     // We allow hotswap to be enabled after the onload phase, but not breakpoints
 51     assert(!JvmtiExport::can_post_breakpoint(), &quot;AOT should have been disabled.&quot;);
 52     FOR_ALL_AOT_HEAPS(heap) {
 53       (*heap)-&gt;load_klass_data(ik, thread);
 54     }
 55   }
 56 }
 57 
 58 uint64_t AOTLoader::get_saved_fingerprint(InstanceKlass* ik) {
 59   assert(UseAOT, &quot;called only when AOT is enabled&quot;);
 60   if (ik-&gt;is_unsafe_anonymous()) {
 61     // don&#39;t even bother
 62     return 0;
 63   }
 64   FOR_ALL_AOT_HEAPS(heap) {
 65     AOTKlassData* klass_data = (*heap)-&gt;find_klass(ik);
 66     if (klass_data != NULL) {
 67       return klass_data-&gt;_fingerprint;
 68     }
 69   }
 70   return 0;
 71 }
 72 
 73 void AOTLoader::oops_do(OopClosure* f) {
 74   if (UseAOT) {
 75     FOR_ALL_AOT_HEAPS(heap) {
 76       (*heap)-&gt;oops_do(f);
 77     }
 78   }
 79 }
 80 
<a name="4" id="anc4"></a><span class="line-modified"> 81 void AOTLoader::metadata_do(void f(Metadata*)) {</span>
 82   if (UseAOT) {
 83     FOR_ALL_AOT_HEAPS(heap) {
 84       (*heap)-&gt;metadata_do(f);
 85     }
 86   }
 87 }
 88 
 89 void AOTLoader::mark_evol_dependent_methods(InstanceKlass* dependee) {
 90   if (UseAOT) {
 91     FOR_ALL_AOT_HEAPS(heap) {
 92       (*heap)-&gt;mark_evol_dependent_methods(dependee);
 93     }
 94   }
 95 }
 96 
 97 /**
 98  * List of core modules for which we search for shared libraries.
 99  */
100 static const char* modules[] = {
101   &quot;java.base&quot;,
102   &quot;java.logging&quot;,
103   &quot;jdk.compiler&quot;,
104   &quot;jdk.scripting.nashorn&quot;,
105   &quot;jdk.internal.vm.ci&quot;,
106   &quot;jdk.internal.vm.compiler&quot;
107 };
108 
109 void AOTLoader::initialize() {
110   TraceTime timer(&quot;AOT initialization&quot;, TRACETIME_LOG(Info, aot, startuptime));
111 
112   if (FLAG_IS_DEFAULT(UseAOT) &amp;&amp; AOTLibrary != NULL) {
113     // Don&#39;t need to set UseAOT on command line when AOTLibrary is specified
114     FLAG_SET_DEFAULT(UseAOT, true);
115   }
116   if (UseAOT) {
117     // EagerInitialization is not compatible with AOT
118     if (EagerInitialization) {
119       if (PrintAOT) {
120         warning(&quot;EagerInitialization is not compatible with AOT (switching AOT off)&quot;);
121       }
122       FLAG_SET_DEFAULT(UseAOT, false);
123       return;
124     }
125 
126     if (JvmtiExport::can_post_breakpoint()) {
127       if (PrintAOT) {
128         warning(&quot;JVMTI capability to post breakpoint is not compatible with AOT (switching AOT off)&quot;);
129       }
130       FLAG_SET_DEFAULT(UseAOT, false);
131       return;
132     }
133 
134     // -Xint is not compatible with AOT
135     if (Arguments::is_interpreter_only()) {
136       if (PrintAOT) {
137         warning(&quot;-Xint is not compatible with AOT (switching AOT off)&quot;);
138       }
139       FLAG_SET_DEFAULT(UseAOT, false);
140       return;
141     }
142 
143 #ifdef _WINDOWS
144     const char pathSep = &#39;;&#39;;
145 #else
146     const char pathSep = &#39;:&#39;;
147 #endif
148 
149     // Scan the AOTLibrary option.
150     if (AOTLibrary != NULL) {
151       const int len = (int)strlen(AOTLibrary);
152       char* cp  = NEW_C_HEAP_ARRAY(char, len+1, mtCode);
<a name="5" id="anc5"></a><span class="line-modified">153       if (cp != NULL) { // No memory?</span>
<span class="line-modified">154         memcpy(cp, AOTLibrary, len);</span>
<span class="line-modified">155         cp[len] = &#39;\0&#39;;</span>
<span class="line-modified">156         char* end = cp + len;</span>
<span class="line-modified">157         while (cp &lt; end) {</span>
<span class="line-modified">158           const char* name = cp;</span>
<span class="line-modified">159           while ((*cp) != &#39;\0&#39; &amp;&amp; (*cp) != &#39;\n&#39; &amp;&amp; (*cp) != &#39;,&#39; &amp;&amp; (*cp) != pathSep) cp++;</span>
<span class="line-modified">160           cp[0] = &#39;\0&#39;;  // Terminate name</span>
<span class="line-modified">161           cp++;</span>
<span class="line-removed">162           load_library(name, true);</span>
<span class="line-removed">163         }</span>
164       }
165     }
166 
167     // Load well-know AOT libraries from Java installation directory.
168     const char* home = Arguments::get_java_home();
169     const char* file_separator = os::file_separator();
170 
171     for (int i = 0; i &lt; (int) (sizeof(modules) / sizeof(const char*)); i++) {
172       char library[JVM_MAXPATHLEN];
173       jio_snprintf(library, sizeof(library), &quot;%s%slib%slib%s%s%s%s&quot;, home, file_separator, file_separator, modules[i], UseCompressedOops ? &quot;-coop&quot; : &quot;&quot;, UseG1GC ? &quot;&quot; : &quot;-nong1&quot;, os::dll_file_extension());
174       load_library(library, false);
175     }
176   }
177 }
178 
179 void AOTLoader::universe_init() {
180   if (UseAOT &amp;&amp; libraries_count() &gt; 0) {
181     // Shifts are static values which initialized by 0 until java heap initialization.
182     // AOT libs are loaded before heap initialized so shift values are not set.
183     // It is okay since ObjectAlignmentInBytes flag which defines shifts value is set before AOT libs are loaded.
184     // AOT sets shift values during heap and metaspace initialization.
185     // Check shifts value to make sure thay did not change.
186     if (UseCompressedOops &amp;&amp; AOTLib::narrow_oop_shift_initialized()) {
<a name="6" id="anc6"></a><span class="line-modified">187       int oop_shift = Universe::narrow_oop_shift();</span>
188       FOR_ALL_AOT_LIBRARIES(lib) {
<a name="7" id="anc7"></a><span class="line-modified">189         (*lib)-&gt;verify_flag((*lib)-&gt;config()-&gt;_narrowOopShift, oop_shift, &quot;Universe::narrow_oop_shift&quot;);</span>
190       }
191       if (UseCompressedClassPointers) { // It is set only if UseCompressedOops is set
<a name="8" id="anc8"></a><span class="line-modified">192         int klass_shift = Universe::narrow_klass_shift();</span>
193         FOR_ALL_AOT_LIBRARIES(lib) {
<a name="9" id="anc9"></a><span class="line-modified">194           (*lib)-&gt;verify_flag((*lib)-&gt;config()-&gt;_narrowKlassShift, klass_shift, &quot;Universe::narrow_klass_shift&quot;);</span>
195         }
196       }
197     }
198     // Create heaps for all valid libraries
199     FOR_ALL_AOT_LIBRARIES(lib) {
200       if ((*lib)-&gt;is_valid()) {
201         AOTCodeHeap* heap = new AOTCodeHeap(*lib);
202         {
<a name="10" id="anc10"></a><span class="line-modified">203           MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
204           add_heap(heap);
205           CodeCache::add_heap(heap);
206         }
207       } else {
208         // Unload invalid libraries
209         os::dll_unload((*lib)-&gt;dl_handle());
210       }
211     }
212   }
213   if (heaps_count() == 0) {
214     if (FLAG_IS_DEFAULT(UseAOT)) {
215       FLAG_SET_DEFAULT(UseAOT, false);
216     }
217   }
218 }
219 
220 // Set shift value for compressed oops and classes based on first AOT library config.
221 // AOTLoader::universe_init(), which is called later, will check the shift value again to make sure nobody change it.
222 // This code is not executed during CDS dump because it runs in Interpreter mode and AOT is disabled in this mode.
223 
224 void AOTLoader::set_narrow_oop_shift() {
225   // This method is called from Universe::initialize_heap().
226   if (UseAOT &amp;&amp; libraries_count() &gt; 0 &amp;&amp;
227       UseCompressedOops &amp;&amp; AOTLib::narrow_oop_shift_initialized()) {
<a name="11" id="anc11"></a><span class="line-modified">228     if (Universe::narrow_oop_shift() == 0) {</span>
229       // 0 is valid shift value for small heap but we can safely increase it
230       // at this point when nobody used it yet.
<a name="12" id="anc12"></a><span class="line-modified">231       Universe::set_narrow_oop_shift(AOTLib::narrow_oop_shift());</span>
232     }
233   }
234 }
235 
236 void AOTLoader::set_narrow_klass_shift() {
237   // This method is called from Metaspace::set_narrow_klass_base_and_shift().
238   if (UseAOT &amp;&amp; libraries_count() &gt; 0 &amp;&amp;
239       UseCompressedOops &amp;&amp; AOTLib::narrow_oop_shift_initialized() &amp;&amp;
240       UseCompressedClassPointers) {
<a name="13" id="anc13"></a><span class="line-modified">241     if (Universe::narrow_klass_shift() == 0) {</span>
<span class="line-modified">242       Universe::set_narrow_klass_shift(AOTLib::narrow_klass_shift());</span>
243     }
244   }
245 }
246 
247 void AOTLoader::load_library(const char* name, bool exit_on_error) {
248   // Skip library if a library with the same name is already loaded.
249   const int file_separator = *os::file_separator();
250   const char* start = strrchr(name, file_separator);
251   const char* new_name = (start == NULL) ? name : (start + 1);
252   FOR_ALL_AOT_LIBRARIES(lib) {
253     const char* lib_name = (*lib)-&gt;name();
254     start = strrchr(lib_name, file_separator);
255     const char* old_name = (start == NULL) ? lib_name : (start + 1);
256     if (strcmp(old_name, new_name) == 0) {
257       if (PrintAOT) {
258         warning(&quot;AOT library %s is already loaded as %s.&quot;, name, lib_name);
259       }
260       return;
261     }
262   }
263   char ebuf[1024];
264   void* handle = os::dll_load(name, ebuf, sizeof ebuf);
265   if (handle == NULL) {
266     if (exit_on_error) {
267       tty-&gt;print_cr(&quot;error opening file: %s&quot;, ebuf);
268       vm_exit(1);
269     }
270     return;
271   }
272   const int dso_id = libraries_count() + 1;
273   AOTLib* lib = new AOTLib(handle, name, dso_id);
274   if (!lib-&gt;is_valid()) {
275     delete lib;
276     os::dll_unload(handle);
277     return;
278   }
279   add_library(lib);
280 }
281 
282 #ifndef PRODUCT
283 void AOTLoader::print_statistics() {
284   { ttyLocker ttyl;
285     tty-&gt;print_cr(&quot;--- AOT Statistics ---&quot;);
286     tty-&gt;print_cr(&quot;AOT libraries loaded: %d&quot;, heaps_count());
287     AOTCodeHeap::print_statistics();
288   }
289 }
290 #endif
291 
292 
293 bool AOTLoader::reconcile_dynamic_invoke(InstanceKlass* holder, int index, Method* adapter_method, Klass* appendix_klass) {
294   if (!UseAOT) {
295     return true;
296   }
297   JavaThread* thread = JavaThread::current();
298   ResourceMark rm(thread);
299   RegisterMap map(thread, false);
300   frame caller_frame = thread-&gt;last_frame().sender(&amp;map); // Skip stub
301   CodeBlob* caller_cb = caller_frame.cb();
302   guarantee(caller_cb != NULL &amp;&amp; caller_cb-&gt;is_compiled(), &quot;must be called from compiled method&quot;);
303   CompiledMethod* cm = caller_cb-&gt;as_compiled_method();
304 
305   if (!cm-&gt;is_aot()) {
306     return true;
307   }
308   AOTCompiledMethod* aot = (AOTCompiledMethod*)cm;
309 
310   AOTCodeHeap* caller_heap = NULL;
311   FOR_ALL_AOT_HEAPS(heap) {
312     if ((*heap)-&gt;contains_blob(aot)) {
313       caller_heap = *heap;
314       break;
315     }
316   }
317   guarantee(caller_heap != NULL, &quot;CodeHeap not found&quot;);
318   bool success = caller_heap-&gt;reconcile_dynamic_invoke(aot, holder, index, adapter_method, appendix_klass);
319   vmassert(success || thread-&gt;last_frame().sender(&amp;map).is_deoptimized_frame(), &quot;caller not deoptimized on failure&quot;);
320   return success;
321 }
<a name="14" id="anc14"></a>




















<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/jfr/writers/jfrWriterHost.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_JFR_WRITERS_JFRWRITERHOST_INLINE_HPP
 26 #define SHARE_JFR_WRITERS_JFRWRITERHOST_INLINE_HPP
 27 
 28 #include &quot;classfile/javaClasses.hpp&quot;
 29 #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceId.inline.hpp&quot;
 30 #include &quot;jfr/recorder/service/jfrOptionSet.hpp&quot;
 31 #include &quot;jfr/writers/jfrEncoding.hpp&quot;
 32 #include &quot;jfr/writers/jfrWriterHost.hpp&quot;
 33 #include &quot;memory/resourceArea.hpp&quot;
 34 #include &quot;oops/oop.hpp&quot;
 35 #include &quot;oops/symbol.hpp&quot;
 36 #include &quot;oops/typeArrayOop.inline.hpp&quot;
 37 
 38 inline bool compressed_integers() {
 39   static const bool comp_integers = JfrOptionSet::compressed_integers();
 40   return comp_integers;
 41 }
 42 
 43 template &lt;typename BE, typename IE, typename WriterPolicyImpl &gt;
 44 template &lt;typename T&gt;
 45 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write_padded(T value) {
 46   write_padded(&amp;value, 1);
 47 }
 48 
 49 template &lt;typename BE, typename IE, typename WriterPolicyImpl &gt;
 50 template &lt;typename T&gt;
 51 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write_padded(const T* value, size_t len) {
 52   assert(value != NULL, &quot;invariant&quot;);
 53   assert(len &gt; 0, &quot;invariant&quot;);
 54   u1* const pos = ensure_size(sizeof(T) * len);
 55   if (pos) {
 56     this-&gt;set_current_pos(write_padded(value, len, pos));
 57   }
 58 }
 59 
 60 template &lt;typename BE, typename IE, typename WriterPolicyImpl &gt;
 61 template &lt;typename T&gt;
 62 inline u1* WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write_padded(const T* value, size_t len, u1* pos) {
 63   assert(value != NULL, &quot;invariant&quot;);
 64   assert(len &gt; 0, &quot;invariant&quot;);
 65   assert(pos != NULL, &quot;invariant&quot;);
 66   return _compressed_integers ? IE::write_padded(value, len, pos) : BE::write_padded(value, len, pos);
 67 }
 68 
 69 template &lt;typename BE, typename IE, typename WriterPolicyImpl &gt;
 70 template &lt;typename T&gt;
 71 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(const T* value, size_t len) {
 72   assert(value != NULL, &quot;invariant&quot;);
 73   assert(len &gt; 0, &quot;invariant&quot;);
 74   u1* const pos = ensure_size(sizeof(T) * len);
 75   if (pos) {
 76     this-&gt;set_current_pos(write(value, len, pos));
 77   }
 78 }
 79 
 80 template &lt;typename BE, typename IE, typename WriterPolicyImpl &gt;
 81 template &lt;typename T&gt;
 82 inline u1* WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(const T* value, size_t len, u1* pos) {
 83   assert(value != NULL, &quot;invariant&quot;);
 84   assert(len &gt; 0, &quot;invariant&quot;);
 85   assert(pos != NULL, &quot;invariant&quot;);
 86   return _compressed_integers ? IE::write(value, len, pos) : BE::write(value, len, pos);
 87 }
 88 
 89 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
 90 void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write_utf8(const char* value) {
 91   if (NULL == value) {
 92     // only write encoding byte indicating NULL string
 93     write&lt;u1&gt;(NULL_STRING);
 94     return;
 95   }
 96   write&lt;u1&gt;(UTF8); // designate encoding
 97   const jint len = MIN2&lt;jint&gt;(max_jint, (jint)strlen(value));
 98   write(len);
 99   if (len &gt; 0) {
100     be_write(value, len);
101   }
102 }
103 
104 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
105 void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write_utf16(const jchar* value, jint len) {
106   assert(value != NULL, &quot;invariant&quot;);
107   write((u1)UTF16); // designate encoding
108   write(len);
109   if (len &gt; 0) {
110     write(value, len);
111   }
112 }
113 
114 template &lt;typename BE, typename IE, typename WriterPolicyImpl &gt;
115 template &lt;typename T&gt;
116 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::be_write(T value) {
117   be_write(&amp;value, 1);
118 }
119 
120 template &lt;typename BE, typename IE, typename WriterPolicyImpl &gt;
121 template &lt;typename T&gt;
122 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::be_write(const T* value, size_t len) {
123   assert(value != NULL, &quot;invariant&quot;);
124   assert(len &gt; 0, &quot;invariant&quot;);
125   u1* const pos = ensure_size(sizeof(T) * len);
126   if (pos) {
127     this-&gt;set_current_pos(BE::be_write(value, len, pos));
128   }
129 }
130 
131 template &lt;typename BE, typename IE, typename WriterPolicyImpl &gt;
132 template &lt;typename StorageType&gt;
133 inline WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::WriterHost(StorageType* storage, Thread* thread) :
134   WriterPolicyImpl(storage, thread),
135   _compressed_integers(compressed_integers()) {
136 }
137 
138 template &lt;typename BE, typename IE, typename WriterPolicyImpl &gt;
139 template &lt;typename StorageType&gt;
140 inline WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::WriterHost(StorageType* storage, size_t size) :
141   WriterPolicyImpl(storage, size),
142   _compressed_integers(compressed_integers()) {
143 }
144 
145 template &lt;typename BE, typename IE, typename WriterPolicyImpl &gt;
146 inline WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::WriterHost(Thread* thread) :
147   WriterPolicyImpl(thread),
148   _compressed_integers(compressed_integers()) {
149 }
150 
151 // Extra size added as a safety cushion when dimensioning memory.
152 // With varint encoding, the worst case is
153 // associated with writing negative values.
154 // For example, writing a negative s1 (-1)
155 // will encode as 0xff 0x0f (2 bytes).
156 // In this example, the sizeof(T) == 1 and length == 1,
157 // but the implementation will need to dimension
158 // 2 bytes for the encoding.
159 // Hopefully, negative values should be relatively rare.
160 static const size_t size_safety_cushion = 1;
161 
162 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
163 inline u1* WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::ensure_size(size_t requested) {
164   if (!this-&gt;is_valid()) {
165     // cancelled
166     return NULL;
167   }
168   if (this-&gt;available_size() &lt; requested + size_safety_cushion) {
169     if (!this-&gt;accommodate(this-&gt;used_size(), requested + size_safety_cushion)) {
170       assert(!this-&gt;is_valid(), &quot;invariant&quot;);
171       return NULL;
172     }
173   }
174   assert(requested + size_safety_cushion &lt;= this-&gt;available_size(), &quot;invariant&quot;);
175   return this-&gt;current_pos();
176 }
177 
178 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
179 template &lt;typename T&gt;
180 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(T value) {
181   write(&amp;value, 1);
182 }
183 
184 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
185 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(bool value) {
186   be_write((u1)value);
187 }
188 
189 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
190 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(float value) {
191   be_write(*(u4*)&amp;(value));
192 }
193 
194 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
195 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(double value) {
196   be_write(*(u8*)&amp;(value));
197 }
198 
199 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
200 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(const char* value) {
201   // UTF-8, max_jint len
202   write_utf8(value);
203 }
204 
205 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
206 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(char* value) {
207   write(const_cast&lt;const char*&gt;(value));
208 }
209 
210 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
211 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(jstring string) {
212   if (string == NULL) {
213     write&lt;u1&gt;(NULL_STRING);
214     return;
215   }
216   const oop string_oop = JNIHandles::resolve_external_guard(string);
217   assert(string_oop != NULL, &quot;invariant&quot;);
218   const size_t length = (size_t)java_lang_String::length(string_oop);
219   if (0 == length) {
220     write&lt;u1&gt;(EMPTY_STRING);
221     return;
222   }
223   const bool is_latin1_encoded = java_lang_String::is_latin1(string_oop);
224   const typeArrayOop value = java_lang_String::value(string_oop);
225   assert(value != NULL, &quot;invariant&quot;);
226   if (is_latin1_encoded) {
227     write&lt;u1&gt;(LATIN1);
228     write&lt;u4&gt;((u4)length);
229     be_write(value-&gt;byte_at_addr(0), length);
230   } else {
231     write&lt;u1&gt;(UTF16);
232     write&lt;u4&gt;((u4)length);
233     write(value-&gt;char_at_addr(0), length);
234   }
235 }
236 
237 template &lt;typename Writer, typename T&gt;
238 inline void tag_write(Writer* w, const T* t) {
239   assert(w != NULL, &quot;invariant&quot;);
240   const traceid id = t == NULL ? 0 : JfrTraceId::use(t);
241   w-&gt;write(id);
242 }
243 
244 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
245 void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(const ClassLoaderData* cld) {
246   tag_write(this, cld);
247 }
248 
249 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
250 void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(const Klass* klass) {
251   tag_write(this, klass);
252 }
253 
254 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
255 void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(const Method* method) {
256   tag_write(this, method);
257 }
258 
259 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
260 void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(const ModuleEntry* module) {
261   tag_write(this, module);
262 }
263 
264 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
265 void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(const PackageEntry* package) {
266   tag_write(this, package);
267 }
268 
269 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
270 void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(const Symbol* symbol) {
271   ResourceMark rm;
272   write_utf8(symbol != NULL ? symbol-&gt;as_C_string() : NULL);
273 }
274 
275 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
276 void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(const Ticks&amp; time) {
277   write((uintptr_t)JfrTime::is_ft_enabled() ? time.ft_value() : time.value());
278 }
279 
280 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
281 void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(const Tickspan&amp; time) {
282   write((uintptr_t)JfrTime::is_ft_enabled() ? time.ft_value() : time.value());
283 }
284 
285 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
286 void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(const JfrTicks&amp; time) {
287   write((uintptr_t)time.value());
288 }
289 
290 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
291 void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(const JfrTickspan&amp; time) {
292   write((uintptr_t)time.value());
293 }
294 
295 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
296 void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::bytes(const void* buf, size_t len) {
297   u1* const pos = this-&gt;ensure_size(len);
298   if (pos != NULL) {
299     WriterPolicyImpl::bytes(pos, buf, len); // WriterPolicyImpl responsible for position update
300   }
301 }
302 
303 // UTF-8 for use with classfile/bytecodes
304 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
305 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write_utf8_u2_len(const char* value) {
306   u2 len = 0;
307   if (value != NULL) {
308     len = MIN2&lt;u2&gt;(max_jushort, (u2)strlen(value));
309   }
310   write(len);
311   if (len &gt; 0) {
312     be_write(value, len);
313   }
314 }
315 
316 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
317 inline int64_t WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::reserve(size_t size) {
318   if (ensure_size(size) != NULL) {
319     const int64_t reserved_offset = this-&gt;current_offset();
320     this-&gt;set_current_pos(size);
321     return reserved_offset;
322   }
323   this-&gt;cancel();
324   return 0;
325 }
326 
327 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
328 template &lt;typename T&gt;
329 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write_padded_at_offset(T value, int64_t offset) {
330   if (this-&gt;is_valid()) {
331     const int64_t current = this-&gt;current_offset();
332     this-&gt;seek(offset);
333     write_padded(value);
334     this-&gt;seek(current); // restore
335   }
336 }
337 
338 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
339 template &lt;typename T&gt;
340 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write_at_offset(T value, int64_t offset) {
341   if (this-&gt;is_valid()) {
342     const int64_t current = this-&gt;current_offset();
343     this-&gt;seek(offset);
344     write(value);
345     this-&gt;seek(current); // restore
346   }
347 }
348 
349 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
350 template &lt;typename T&gt;
351 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write_be_at_offset(T value, int64_t offset) {
352   if (this-&gt;is_valid()) {
353     const int64_t current = this-&gt;current_offset();
354     this-&gt;seek(offset);
355     be_write(value);
356     this-&gt;seek(current); // restore
357   }
358 }
359 
360 #endif // SHARE_JFR_WRITERS_JFRWRITERHOST_INLINE_HPP
    </pre>
  </body>
</html>
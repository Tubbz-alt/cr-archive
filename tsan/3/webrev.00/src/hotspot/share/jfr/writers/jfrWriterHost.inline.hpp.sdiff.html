<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/writers/jfrWriterHost.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="jfrStorageAdapter.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../jvmci/compilerRuntime.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/writers/jfrWriterHost.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 97   const jint len = MIN2&lt;jint&gt;(max_jint, (jint)strlen(value));
 98   write(len);
 99   if (len &gt; 0) {
100     be_write(value, len);
101   }
102 }
103 
104 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
105 void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write_utf16(const jchar* value, jint len) {
106   assert(value != NULL, &quot;invariant&quot;);
107   write((u1)UTF16); // designate encoding
108   write(len);
109   if (len &gt; 0) {
110     write(value, len);
111   }
112 }
113 
114 template &lt;typename BE, typename IE, typename WriterPolicyImpl &gt;
115 template &lt;typename T&gt;
116 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::be_write(T value) {
<span class="line-modified">117   u1* const pos = ensure_size(sizeof(T));</span>
<span class="line-removed">118   if (pos) {</span>
<span class="line-removed">119     this-&gt;set_current_pos(BE::be_write(&amp;value, 1, pos));</span>
<span class="line-removed">120   }</span>
121 }
122 
123 template &lt;typename BE, typename IE, typename WriterPolicyImpl &gt;
124 template &lt;typename T&gt;
125 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::be_write(const T* value, size_t len) {
126   assert(value != NULL, &quot;invariant&quot;);
127   assert(len &gt; 0, &quot;invariant&quot;);
128   u1* const pos = ensure_size(sizeof(T) * len);
129   if (pos) {
130     this-&gt;set_current_pos(BE::be_write(value, len, pos));
131   }
132 }
133 
134 template &lt;typename BE, typename IE, typename WriterPolicyImpl &gt;
135 template &lt;typename StorageType&gt;
136 inline WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::WriterHost(StorageType* storage, Thread* thread) :
137   WriterPolicyImpl(storage, thread),
138   _compressed_integers(compressed_integers()) {
139 }
140 
</pre>
<hr />
<pre>
153 
154 // Extra size added as a safety cushion when dimensioning memory.
155 // With varint encoding, the worst case is
156 // associated with writing negative values.
157 // For example, writing a negative s1 (-1)
158 // will encode as 0xff 0x0f (2 bytes).
159 // In this example, the sizeof(T) == 1 and length == 1,
160 // but the implementation will need to dimension
161 // 2 bytes for the encoding.
162 // Hopefully, negative values should be relatively rare.
163 static const size_t size_safety_cushion = 1;
164 
165 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
166 inline u1* WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::ensure_size(size_t requested) {
167   if (!this-&gt;is_valid()) {
168     // cancelled
169     return NULL;
170   }
171   if (this-&gt;available_size() &lt; requested + size_safety_cushion) {
172     if (!this-&gt;accommodate(this-&gt;used_size(), requested + size_safety_cushion)) {
<span class="line-modified">173       this-&gt;cancel();</span>
174       return NULL;
175     }
176   }
177   assert(requested + size_safety_cushion &lt;= this-&gt;available_size(), &quot;invariant&quot;);
178   return this-&gt;current_pos();
179 }
180 
181 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
182 template &lt;typename T&gt;
183 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(T value) {
184   write(&amp;value, 1);
185 }
186 
187 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
188 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(bool value) {
189   be_write((u1)value);
190 }
191 
192 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
193 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(float value) {
</pre>
</td>
<td>
<hr />
<pre>
 97   const jint len = MIN2&lt;jint&gt;(max_jint, (jint)strlen(value));
 98   write(len);
 99   if (len &gt; 0) {
100     be_write(value, len);
101   }
102 }
103 
104 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
105 void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write_utf16(const jchar* value, jint len) {
106   assert(value != NULL, &quot;invariant&quot;);
107   write((u1)UTF16); // designate encoding
108   write(len);
109   if (len &gt; 0) {
110     write(value, len);
111   }
112 }
113 
114 template &lt;typename BE, typename IE, typename WriterPolicyImpl &gt;
115 template &lt;typename T&gt;
116 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::be_write(T value) {
<span class="line-modified">117   be_write(&amp;value, 1);</span>



118 }
119 
120 template &lt;typename BE, typename IE, typename WriterPolicyImpl &gt;
121 template &lt;typename T&gt;
122 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::be_write(const T* value, size_t len) {
123   assert(value != NULL, &quot;invariant&quot;);
124   assert(len &gt; 0, &quot;invariant&quot;);
125   u1* const pos = ensure_size(sizeof(T) * len);
126   if (pos) {
127     this-&gt;set_current_pos(BE::be_write(value, len, pos));
128   }
129 }
130 
131 template &lt;typename BE, typename IE, typename WriterPolicyImpl &gt;
132 template &lt;typename StorageType&gt;
133 inline WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::WriterHost(StorageType* storage, Thread* thread) :
134   WriterPolicyImpl(storage, thread),
135   _compressed_integers(compressed_integers()) {
136 }
137 
</pre>
<hr />
<pre>
150 
151 // Extra size added as a safety cushion when dimensioning memory.
152 // With varint encoding, the worst case is
153 // associated with writing negative values.
154 // For example, writing a negative s1 (-1)
155 // will encode as 0xff 0x0f (2 bytes).
156 // In this example, the sizeof(T) == 1 and length == 1,
157 // but the implementation will need to dimension
158 // 2 bytes for the encoding.
159 // Hopefully, negative values should be relatively rare.
160 static const size_t size_safety_cushion = 1;
161 
162 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
163 inline u1* WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::ensure_size(size_t requested) {
164   if (!this-&gt;is_valid()) {
165     // cancelled
166     return NULL;
167   }
168   if (this-&gt;available_size() &lt; requested + size_safety_cushion) {
169     if (!this-&gt;accommodate(this-&gt;used_size(), requested + size_safety_cushion)) {
<span class="line-modified">170       assert(!this-&gt;is_valid(), &quot;invariant&quot;);</span>
171       return NULL;
172     }
173   }
174   assert(requested + size_safety_cushion &lt;= this-&gt;available_size(), &quot;invariant&quot;);
175   return this-&gt;current_pos();
176 }
177 
178 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
179 template &lt;typename T&gt;
180 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(T value) {
181   write(&amp;value, 1);
182 }
183 
184 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
185 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(bool value) {
186   be_write((u1)value);
187 }
188 
189 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
190 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(float value) {
</pre>
</td>
</tr>
</table>
<center><a href="jfrStorageAdapter.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../jvmci/compilerRuntime.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
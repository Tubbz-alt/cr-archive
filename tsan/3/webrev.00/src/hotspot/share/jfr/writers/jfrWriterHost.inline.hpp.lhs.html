<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jfr/writers/jfrWriterHost.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_JFR_WRITERS_JFRWRITERHOST_INLINE_HPP
 26 #define SHARE_JFR_WRITERS_JFRWRITERHOST_INLINE_HPP
 27 
 28 #include &quot;classfile/javaClasses.hpp&quot;
 29 #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceId.inline.hpp&quot;
 30 #include &quot;jfr/recorder/service/jfrOptionSet.hpp&quot;
 31 #include &quot;jfr/writers/jfrEncoding.hpp&quot;
 32 #include &quot;jfr/writers/jfrWriterHost.hpp&quot;
 33 #include &quot;memory/resourceArea.hpp&quot;
 34 #include &quot;oops/oop.hpp&quot;
 35 #include &quot;oops/symbol.hpp&quot;
 36 #include &quot;oops/typeArrayOop.inline.hpp&quot;
 37 
 38 inline bool compressed_integers() {
 39   static const bool comp_integers = JfrOptionSet::compressed_integers();
 40   return comp_integers;
 41 }
 42 
 43 template &lt;typename BE, typename IE, typename WriterPolicyImpl &gt;
 44 template &lt;typename T&gt;
 45 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write_padded(T value) {
 46   write_padded(&amp;value, 1);
 47 }
 48 
 49 template &lt;typename BE, typename IE, typename WriterPolicyImpl &gt;
 50 template &lt;typename T&gt;
 51 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write_padded(const T* value, size_t len) {
 52   assert(value != NULL, &quot;invariant&quot;);
 53   assert(len &gt; 0, &quot;invariant&quot;);
 54   u1* const pos = ensure_size(sizeof(T) * len);
 55   if (pos) {
 56     this-&gt;set_current_pos(write_padded(value, len, pos));
 57   }
 58 }
 59 
 60 template &lt;typename BE, typename IE, typename WriterPolicyImpl &gt;
 61 template &lt;typename T&gt;
 62 inline u1* WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write_padded(const T* value, size_t len, u1* pos) {
 63   assert(value != NULL, &quot;invariant&quot;);
 64   assert(len &gt; 0, &quot;invariant&quot;);
 65   assert(pos != NULL, &quot;invariant&quot;);
 66   return _compressed_integers ? IE::write_padded(value, len, pos) : BE::write_padded(value, len, pos);
 67 }
 68 
 69 template &lt;typename BE, typename IE, typename WriterPolicyImpl &gt;
 70 template &lt;typename T&gt;
 71 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(const T* value, size_t len) {
 72   assert(value != NULL, &quot;invariant&quot;);
 73   assert(len &gt; 0, &quot;invariant&quot;);
 74   u1* const pos = ensure_size(sizeof(T) * len);
 75   if (pos) {
 76     this-&gt;set_current_pos(write(value, len, pos));
 77   }
 78 }
 79 
 80 template &lt;typename BE, typename IE, typename WriterPolicyImpl &gt;
 81 template &lt;typename T&gt;
 82 inline u1* WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(const T* value, size_t len, u1* pos) {
 83   assert(value != NULL, &quot;invariant&quot;);
 84   assert(len &gt; 0, &quot;invariant&quot;);
 85   assert(pos != NULL, &quot;invariant&quot;);
 86   return _compressed_integers ? IE::write(value, len, pos) : BE::write(value, len, pos);
 87 }
 88 
 89 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
 90 void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write_utf8(const char* value) {
 91   if (NULL == value) {
 92     // only write encoding byte indicating NULL string
 93     write&lt;u1&gt;(NULL_STRING);
 94     return;
 95   }
 96   write&lt;u1&gt;(UTF8); // designate encoding
 97   const jint len = MIN2&lt;jint&gt;(max_jint, (jint)strlen(value));
 98   write(len);
 99   if (len &gt; 0) {
100     be_write(value, len);
101   }
102 }
103 
104 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
105 void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write_utf16(const jchar* value, jint len) {
106   assert(value != NULL, &quot;invariant&quot;);
107   write((u1)UTF16); // designate encoding
108   write(len);
109   if (len &gt; 0) {
110     write(value, len);
111   }
112 }
113 
114 template &lt;typename BE, typename IE, typename WriterPolicyImpl &gt;
115 template &lt;typename T&gt;
116 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::be_write(T value) {
<a name="1" id="anc1"></a><span class="line-modified">117   u1* const pos = ensure_size(sizeof(T));</span>
<span class="line-removed">118   if (pos) {</span>
<span class="line-removed">119     this-&gt;set_current_pos(BE::be_write(&amp;value, 1, pos));</span>
<span class="line-removed">120   }</span>
121 }
122 
123 template &lt;typename BE, typename IE, typename WriterPolicyImpl &gt;
124 template &lt;typename T&gt;
125 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::be_write(const T* value, size_t len) {
126   assert(value != NULL, &quot;invariant&quot;);
127   assert(len &gt; 0, &quot;invariant&quot;);
128   u1* const pos = ensure_size(sizeof(T) * len);
129   if (pos) {
130     this-&gt;set_current_pos(BE::be_write(value, len, pos));
131   }
132 }
133 
134 template &lt;typename BE, typename IE, typename WriterPolicyImpl &gt;
135 template &lt;typename StorageType&gt;
136 inline WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::WriterHost(StorageType* storage, Thread* thread) :
137   WriterPolicyImpl(storage, thread),
138   _compressed_integers(compressed_integers()) {
139 }
140 
141 template &lt;typename BE, typename IE, typename WriterPolicyImpl &gt;
142 template &lt;typename StorageType&gt;
143 inline WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::WriterHost(StorageType* storage, size_t size) :
144   WriterPolicyImpl(storage, size),
145   _compressed_integers(compressed_integers()) {
146 }
147 
148 template &lt;typename BE, typename IE, typename WriterPolicyImpl &gt;
149 inline WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::WriterHost(Thread* thread) :
150   WriterPolicyImpl(thread),
151   _compressed_integers(compressed_integers()) {
152 }
153 
154 // Extra size added as a safety cushion when dimensioning memory.
155 // With varint encoding, the worst case is
156 // associated with writing negative values.
157 // For example, writing a negative s1 (-1)
158 // will encode as 0xff 0x0f (2 bytes).
159 // In this example, the sizeof(T) == 1 and length == 1,
160 // but the implementation will need to dimension
161 // 2 bytes for the encoding.
162 // Hopefully, negative values should be relatively rare.
163 static const size_t size_safety_cushion = 1;
164 
165 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
166 inline u1* WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::ensure_size(size_t requested) {
167   if (!this-&gt;is_valid()) {
168     // cancelled
169     return NULL;
170   }
171   if (this-&gt;available_size() &lt; requested + size_safety_cushion) {
172     if (!this-&gt;accommodate(this-&gt;used_size(), requested + size_safety_cushion)) {
<a name="2" id="anc2"></a><span class="line-modified">173       this-&gt;cancel();</span>
174       return NULL;
175     }
176   }
177   assert(requested + size_safety_cushion &lt;= this-&gt;available_size(), &quot;invariant&quot;);
178   return this-&gt;current_pos();
179 }
180 
181 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
182 template &lt;typename T&gt;
183 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(T value) {
184   write(&amp;value, 1);
185 }
186 
187 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
188 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(bool value) {
189   be_write((u1)value);
190 }
191 
192 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
193 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(float value) {
194   be_write(*(u4*)&amp;(value));
195 }
196 
197 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
198 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(double value) {
199   be_write(*(u8*)&amp;(value));
200 }
201 
202 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
203 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(const char* value) {
204   // UTF-8, max_jint len
205   write_utf8(value);
206 }
207 
208 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
209 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(char* value) {
210   write(const_cast&lt;const char*&gt;(value));
211 }
212 
213 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
214 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(jstring string) {
215   if (string == NULL) {
216     write&lt;u1&gt;(NULL_STRING);
217     return;
218   }
219   const oop string_oop = JNIHandles::resolve_external_guard(string);
220   assert(string_oop != NULL, &quot;invariant&quot;);
221   const size_t length = (size_t)java_lang_String::length(string_oop);
222   if (0 == length) {
223     write&lt;u1&gt;(EMPTY_STRING);
224     return;
225   }
226   const bool is_latin1_encoded = java_lang_String::is_latin1(string_oop);
227   const typeArrayOop value = java_lang_String::value(string_oop);
228   assert(value != NULL, &quot;invariant&quot;);
229   if (is_latin1_encoded) {
230     write&lt;u1&gt;(LATIN1);
231     write&lt;u4&gt;((u4)length);
232     be_write(value-&gt;byte_at_addr(0), length);
233   } else {
234     write&lt;u1&gt;(UTF16);
235     write&lt;u4&gt;((u4)length);
236     write(value-&gt;char_at_addr(0), length);
237   }
238 }
239 
240 template &lt;typename Writer, typename T&gt;
241 inline void tag_write(Writer* w, const T* t) {
242   assert(w != NULL, &quot;invariant&quot;);
243   const traceid id = t == NULL ? 0 : JfrTraceId::use(t);
244   w-&gt;write(id);
245 }
246 
247 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
248 void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(const ClassLoaderData* cld) {
249   tag_write(this, cld);
250 }
251 
252 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
253 void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(const Klass* klass) {
254   tag_write(this, klass);
255 }
256 
257 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
258 void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(const Method* method) {
259   tag_write(this, method);
260 }
261 
262 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
263 void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(const ModuleEntry* module) {
264   tag_write(this, module);
265 }
266 
267 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
268 void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(const PackageEntry* package) {
269   tag_write(this, package);
270 }
271 
272 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
273 void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(const Symbol* symbol) {
274   ResourceMark rm;
275   write_utf8(symbol != NULL ? symbol-&gt;as_C_string() : NULL);
276 }
277 
278 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
279 void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(const Ticks&amp; time) {
280   write((uintptr_t)JfrTime::is_ft_enabled() ? time.ft_value() : time.value());
281 }
282 
283 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
284 void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(const Tickspan&amp; time) {
285   write((uintptr_t)JfrTime::is_ft_enabled() ? time.ft_value() : time.value());
286 }
287 
288 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
289 void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(const JfrTicks&amp; time) {
290   write((uintptr_t)time.value());
291 }
292 
293 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
294 void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write(const JfrTickspan&amp; time) {
295   write((uintptr_t)time.value());
296 }
297 
298 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
299 void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::bytes(const void* buf, size_t len) {
300   u1* const pos = this-&gt;ensure_size(len);
301   if (pos != NULL) {
302     WriterPolicyImpl::bytes(pos, buf, len); // WriterPolicyImpl responsible for position update
303   }
304 }
305 
306 // UTF-8 for use with classfile/bytecodes
307 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
308 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write_utf8_u2_len(const char* value) {
309   u2 len = 0;
310   if (value != NULL) {
311     len = MIN2&lt;u2&gt;(max_jushort, (u2)strlen(value));
312   }
313   write(len);
314   if (len &gt; 0) {
315     be_write(value, len);
316   }
317 }
318 
319 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
320 inline int64_t WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::reserve(size_t size) {
321   if (ensure_size(size) != NULL) {
322     const int64_t reserved_offset = this-&gt;current_offset();
323     this-&gt;set_current_pos(size);
324     return reserved_offset;
325   }
326   this-&gt;cancel();
327   return 0;
328 }
329 
330 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
331 template &lt;typename T&gt;
332 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write_padded_at_offset(T value, int64_t offset) {
333   if (this-&gt;is_valid()) {
334     const int64_t current = this-&gt;current_offset();
335     this-&gt;seek(offset);
336     write_padded(value);
337     this-&gt;seek(current); // restore
338   }
339 }
340 
341 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
342 template &lt;typename T&gt;
343 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write_at_offset(T value, int64_t offset) {
344   if (this-&gt;is_valid()) {
345     const int64_t current = this-&gt;current_offset();
346     this-&gt;seek(offset);
347     write(value);
348     this-&gt;seek(current); // restore
349   }
350 }
351 
352 template &lt;typename BE, typename IE, typename WriterPolicyImpl&gt;
353 template &lt;typename T&gt;
354 inline void WriterHost&lt;BE, IE, WriterPolicyImpl&gt;::write_be_at_offset(T value, int64_t offset) {
355   if (this-&gt;is_valid()) {
356     const int64_t current = this-&gt;current_offset();
357     this-&gt;seek(offset);
358     be_write(value);
359     this-&gt;seek(current); // restore
360   }
361 }
362 
363 #endif // SHARE_JFR_WRITERS_JFRWRITERHOST_INLINE_HPP
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
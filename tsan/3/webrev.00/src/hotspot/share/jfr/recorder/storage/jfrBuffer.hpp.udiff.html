<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/jfr/recorder/storage/jfrBuffer.hpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="jfrBuffer.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrMemorySpace.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/storage/jfrBuffer.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -24,49 +24,61 @@</span>
  
  #ifndef SHARE_JFR_RECORDER_STORAGE_JFRBUFFER_HPP
  #define SHARE_JFR_RECORDER_STORAGE_JFRBUFFER_HPP
  
  #include &quot;memory/allocation.hpp&quot;
<span class="udiff-line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
  
  //
  // Represents a piece of committed memory.
  //
<span class="udiff-line-removed">- // u1* _pos &lt;-- next store position</span>
<span class="udiff-line-removed">- // u1* _top &lt;-- next unflushed position</span>
<span class="udiff-line-removed">- //</span>
<span class="udiff-line-removed">- // const void* _identity &lt;-- acquired by</span>
<span class="udiff-line-removed">- //</span>
<span class="udiff-line-removed">- // Must be the owner before attempting stores.</span>
  // Use acquire() and/or try_acquire() for exclusive access
<span class="udiff-line-modified-removed">- // to the (entire) buffer (cas identity).</span>
<span class="udiff-line-modified-added">+ // to the buffer (cas identity). This is a precondition</span>
<span class="udiff-line-added">+ // for attempting stores.</span>
  //
<span class="udiff-line-modified-removed">- // Stores to the buffer should uphold transactional semantics.</span>
<span class="udiff-line-modified-removed">- // A new _pos must be updated only after all intended stores have completed.</span>
<span class="udiff-line-modified-added">+ // u1* _pos &lt;-- last committed position</span>
<span class="udiff-line-modified-added">+ // u1* _top &lt;-- next unflushed position</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ // Stores must uphold transactional semantics. This means that _pos</span>
<span class="udiff-line-added">+ // must be updated only after all intended stores have completed already.</span>
  // The relation between _pos and _top must hold atomically,
  // e.g. the delta must always be fully parsable.
  // _top can move concurrently by other threads but is always &lt;= _pos.
  //
<span class="udiff-line-added">+ // Memory ordering:</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ //  Method                 Owner thread             Other threads</span>
<span class="udiff-line-added">+ //  ---------------------------------------------------------------</span>
<span class="udiff-line-added">+ //  acquire()              Acquire semantics (cas)  Acquire semantics (cas)</span>
<span class="udiff-line-added">+ //  try_acquire()          Acquire semantics (cas)  Acquire semantics (cas)</span>
<span class="udiff-line-added">+ //  release()              Release semantics        Release semantics</span>
<span class="udiff-line-added">+ //  pos()                  Plain load               Acquire semantics needed at call sites</span>
<span class="udiff-line-added">+ //  set_pos()              Release semantics        N/A</span>
<span class="udiff-line-added">+ //  top()                  Acquire semantics        Acquire semantics</span>
<span class="udiff-line-added">+ //  set_top()              Release semantics        Release semantics</span>
<span class="udiff-line-added">+ //  acquire_crit_sec_top() Acquire semantics (cas)  Acquire semantics (cas)</span>
<span class="udiff-line-added">+ //  release_crit_sec_top() Release semantics        Release semantics</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ </span>
  class JfrBuffer {
   private:
    JfrBuffer* _next;
    JfrBuffer* _prev;
<span class="udiff-line-modified-removed">-   const void* volatile _identity;</span>
<span class="udiff-line-modified-added">+   const void* _identity;</span>
    u1* _pos;
<span class="udiff-line-modified-removed">-   mutable const u1* volatile _top;</span>
<span class="udiff-line-modified-added">+   mutable const u1* _top;</span>
    u2 _flags;
    u2 _header_size;
    u4 _size;
  
    const u1* stable_top() const;
<span class="udiff-line-removed">-   void clear_flags();</span>
  
   public:
    JfrBuffer();
<span class="udiff-line-modified-removed">-   bool initialize(size_t header_size, size_t size, const void* id = NULL);</span>
<span class="udiff-line-modified-removed">-   void reinitialize();</span>
<span class="udiff-line-modified-removed">-   void concurrent_reinitialization();</span>
<span class="udiff-line-removed">-   size_t discard();</span>
<span class="udiff-line-modified-added">+   bool initialize(size_t header_size, size_t size);</span>
<span class="udiff-line-modified-added">+   void reinitialize(bool exclusion = false);</span>
<span class="udiff-line-modified-added">+ </span>
    JfrBuffer* next() const {
      return _next;
    }
  
    JfrBuffer* prev() const {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -91,71 +103,70 @@</span>
  
    const u1* end() const {
      return start() + size();
    }
  
<span class="udiff-line-added">+   // If pos() methods are invoked by a thread that is not the owner,</span>
<span class="udiff-line-added">+   // then acquire semantics must be ensured at the call site.</span>
    const u1* pos() const {
      return _pos;
    }
  
    u1* pos() {
      return _pos;
    }
  
    u1** pos_address() {
<span class="udiff-line-modified-removed">-     return (u1**)&amp;_pos;</span>
<span class="udiff-line-modified-added">+     return &amp;_pos;</span>
    }
  
    void set_pos(u1* new_pos) {
      assert(new_pos &lt;= end(), &quot;invariant&quot;);
<span class="udiff-line-modified-removed">-     _pos = new_pos;</span>
<span class="udiff-line-modified-added">+     Atomic::release_store(&amp;_pos, new_pos);</span>
    }
  
    void set_pos(size_t size) {
<span class="udiff-line-modified-removed">-     assert(_pos + size &lt;= end(), &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-     _pos += size;</span>
<span class="udiff-line-modified-added">+     set_pos(pos() + size);</span>
    }
  
    const u1* top() const;
    void set_top(const u1* new_top);
<span class="udiff-line-removed">-   const u1* concurrent_top() const;</span>
<span class="udiff-line-removed">-   void set_concurrent_top(const u1* new_top);</span>
  
<span class="udiff-line-modified-removed">-   size_t header_size() const {</span>
<span class="udiff-line-modified-removed">-     return _header_size;</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-added">+   // mutual exclusion</span>
<span class="udiff-line-modified-added">+   const u1* acquire_critical_section_top() const;</span>
<span class="udiff-line-modified-added">+   void release_critical_section_top(const u1* new_top);</span>
  
    size_t size() const {
      return _size * BytesPerWord;
    }
  
    size_t total_size() const {
<span class="udiff-line-modified-removed">-     return header_size() + size();</span>
<span class="udiff-line-modified-added">+     return _header_size + size();</span>
    }
  
    size_t free_size() const {
<span class="udiff-line-modified-removed">-     return end() - pos();</span>
<span class="udiff-line-modified-added">+     return end() - Atomic::load_acquire(&amp;_pos);</span>
    }
  
    size_t unflushed_size() const;
  
    bool empty() const {
<span class="udiff-line-modified-removed">-     return pos() == start();</span>
<span class="udiff-line-modified-added">+     return Atomic::load_acquire(&amp;_pos) == start();</span>
    }
  
    const void* identity() const {
<span class="udiff-line-modified-removed">-     return _identity;</span>
<span class="udiff-line-modified-added">+     return Atomic::load_acquire(&amp;_identity);</span>
    }
  
<span class="udiff-line-removed">-   void clear_identity();</span>
<span class="udiff-line-removed">- </span>
    void acquire(const void* id);
    bool try_acquire(const void* id);
<span class="udiff-line-added">+   bool acquired_by(const void* id) const;</span>
<span class="udiff-line-added">+   bool acquired_by_self() const;</span>
    void release();
  
<span class="udiff-line-added">+   size_t discard();</span>
    void move(JfrBuffer* const to, size_t size);
<span class="udiff-line-removed">-   void concurrent_move_and_reinitialize(JfrBuffer* const to, size_t size);</span>
  
    bool transient() const;
    void set_transient();
    void clear_transient();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -165,17 +176,18 @@</span>
  
    bool retired() const;
    void set_retired();
    void clear_retired();
  
<span class="udiff-line-modified-removed">-   debug_only(bool acquired_by_self() const;)</span>
<span class="udiff-line-modified-added">+   bool excluded() const;</span>
<span class="udiff-line-added">+   void set_excluded();</span>
<span class="udiff-line-added">+   void clear_excluded();</span>
  };
  
  class JfrAgeNode : public JfrBuffer {
   private:
    JfrBuffer* _retired;
<span class="udiff-line-removed">- </span>
   public:
    JfrAgeNode() : _retired(NULL) {}
    void set_retired_buffer(JfrBuffer* retired) {
      _retired = retired;
    }
</pre>
<center><a href="jfrBuffer.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrMemorySpace.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeSet.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="jfrTypeManager.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="jfrTypeSet.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeSet.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  27 #include &quot;classfile/javaClasses.inline.hpp&quot;
  28 #include &quot;classfile/moduleEntry.hpp&quot;
  29 #include &quot;classfile/packageEntry.hpp&quot;
  30 #include &quot;classfile/symbolTable.hpp&quot;
<span class="line-removed">  31 #include &quot;classfile/systemDictionary.hpp&quot;</span>
  32 #include &quot;jfr/jfr.hpp&quot;
  33 #include &quot;jfr/jni/jfrGetAllEventClasses.hpp&quot;
<span class="line-modified">  34 #include &quot;jfr/recorder/checkpoint/jfrCheckpointWriter.hpp&quot;</span>
  35 #include &quot;jfr/recorder/checkpoint/types/jfrTypeSet.hpp&quot;
  36 #include &quot;jfr/recorder/checkpoint/types/jfrTypeSetUtils.hpp&quot;
<span class="line-removed">  37 #include &quot;jfr/recorder/checkpoint/types/jfrTypeSetWriter.hpp&quot;</span>
  38 #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceId.inline.hpp&quot;
<span class="line-removed">  39 #include &quot;jfr/recorder/storage/jfrBuffer.hpp&quot;</span>
  40 #include &quot;jfr/utilities/jfrHashtable.hpp&quot;
  41 #include &quot;jfr/utilities/jfrTypes.hpp&quot;

  42 #include &quot;memory/iterator.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;oops/instanceKlass.hpp&quot;
  45 #include &quot;oops/objArrayKlass.hpp&quot;
  46 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-removed">  47 #include &quot;memory/resourceArea.hpp&quot;</span>
  48 #include &quot;utilities/accessFlags.hpp&quot;
<span class="line-modified">  49 </span>
<span class="line-removed">  50 // incremented on each checkpoint</span>
<span class="line-removed">  51 static u8 checkpoint_id = 0;</span>
<span class="line-removed">  52 </span>
<span class="line-removed">  53 // creates a unique id by combining a checkpoint relative symbol id (2^24)</span>
<span class="line-removed">  54 // with the current checkpoint id (2^40)</span>
<span class="line-removed">  55 #define CREATE_SYMBOL_ID(sym_id) (((u8)((checkpoint_id &lt;&lt; 24) | sym_id)))</span>
  56 
  57 typedef const Klass* KlassPtr;
  58 typedef const PackageEntry* PkgPtr;
  59 typedef const ModuleEntry* ModPtr;
  60 typedef const ClassLoaderData* CldPtr;
  61 typedef const Method* MethodPtr;
  62 typedef const Symbol* SymbolPtr;
  63 typedef const JfrSymbolId::SymbolEntry* SymbolEntryPtr;
  64 typedef const JfrSymbolId::CStringEntry* CStringEntryPtr;
  65 
<span class="line-modified">  66 static traceid module_id(PkgPtr pkg) {</span>
<span class="line-modified">  67   assert(pkg != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">  68   ModPtr module_entry = pkg-&gt;module();</span>
<span class="line-modified">  69   return module_entry != NULL &amp;&amp; module_entry-&gt;is_named() ? TRACE_ID(module_entry) : 0;</span>












  70 }
  71 
<span class="line-modified">  72 static traceid package_id(KlassPtr klass) {</span>
<span class="line-modified">  73   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">  74   PkgPtr pkg_entry = klass-&gt;package();</span>
<span class="line-removed">  75   return pkg_entry == NULL ? 0 : TRACE_ID(pkg_entry);</span>
  76 }
  77 
<span class="line-modified">  78 static traceid cld_id(CldPtr cld) {</span>
<span class="line-modified">  79   assert(cld != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">  80   return cld-&gt;is_unsafe_anonymous() ? 0 : TRACE_ID(cld);</span>
  81 }
  82 
<span class="line-modified">  83 static void tag_leakp_klass_artifacts(KlassPtr k, bool class_unload) {</span>
<span class="line-modified">  84   assert(k != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">  85   PkgPtr pkg = k-&gt;package();</span>
<span class="line-removed">  86   if (pkg != NULL) {</span>
<span class="line-removed">  87     tag_leakp_artifact(pkg, class_unload);</span>
<span class="line-removed">  88     ModPtr module = pkg-&gt;module();</span>
<span class="line-removed">  89     if (module != NULL) {</span>
<span class="line-removed">  90       tag_leakp_artifact(module, class_unload);</span>
<span class="line-removed">  91     }</span>
<span class="line-removed">  92   }</span>
<span class="line-removed">  93   CldPtr cld = k-&gt;class_loader_data();</span>
<span class="line-removed">  94   assert(cld != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">  95   if (!cld-&gt;is_unsafe_anonymous()) {</span>
<span class="line-removed">  96     tag_leakp_artifact(cld, class_unload);</span>
<span class="line-removed">  97   }</span>
  98 }
  99 
<span class="line-modified"> 100 class TagLeakpKlassArtifact {</span>
<span class="line-modified"> 101   bool _class_unload;</span>
<span class="line-modified"> 102  public:</span>
<span class="line-removed"> 103   TagLeakpKlassArtifact(bool class_unload) : _class_unload(class_unload) {}</span>
<span class="line-removed"> 104   bool operator()(KlassPtr klass) {</span>
<span class="line-removed"> 105     if (_class_unload) {</span>
<span class="line-removed"> 106       if (LEAKP_USED_THIS_EPOCH(klass)) {</span>
<span class="line-removed"> 107         tag_leakp_klass_artifacts(klass, _class_unload);</span>
<span class="line-removed"> 108       }</span>
<span class="line-removed"> 109     } else {</span>
<span class="line-removed"> 110       if (LEAKP_USED_PREV_EPOCH(klass)) {</span>
<span class="line-removed"> 111         tag_leakp_klass_artifacts(klass, _class_unload);</span>
<span class="line-removed"> 112       }</span>
<span class="line-removed"> 113     }</span>
<span class="line-removed"> 114     return true;</span>
<span class="line-removed"> 115   }</span>
<span class="line-removed"> 116 };</span>
 117 
<span class="line-modified"> 118 /*</span>
<span class="line-modified"> 119  * In C++03, functions used as template parameters must have external linkage;</span>
<span class="line-modified"> 120  * this restriction was removed in C++11. Change back to &quot;static&quot; and</span>
<span class="line-removed"> 121  * rename functions when C++11 becomes available.</span>
<span class="line-removed"> 122  *</span>
<span class="line-removed"> 123  * The weird naming is an effort to decrease the risk of name clashes.</span>
<span class="line-removed"> 124  */</span>
 125 
<span class="line-modified"> 126 int write__artifact__klass(JfrCheckpointWriter* writer, JfrArtifactSet* artifacts, const void* k) {</span>
<span class="line-modified"> 127   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 128   assert(artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 129   assert(k != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 130   KlassPtr klass = (KlassPtr)k;</span>
<span class="line-removed"> 131   traceid pkg_id = 0;</span>
<span class="line-removed"> 132   KlassPtr theklass = klass;</span>
<span class="line-removed"> 133   if (theklass-&gt;is_objArray_klass()) {</span>
<span class="line-removed"> 134     const ObjArrayKlass* obj_arr_klass = ObjArrayKlass::cast(klass);</span>
<span class="line-removed"> 135     theklass = obj_arr_klass-&gt;bottom_klass();</span>
<span class="line-removed"> 136   }</span>
<span class="line-removed"> 137   if (theklass-&gt;is_instance_klass()) {</span>
<span class="line-removed"> 138     pkg_id = package_id(theklass);</span>
<span class="line-removed"> 139   } else {</span>
<span class="line-removed"> 140     assert(theklass-&gt;is_typeArray_klass(), &quot;invariant&quot;);</span>
<span class="line-removed"> 141   }</span>
<span class="line-removed"> 142   const traceid symbol_id = artifacts-&gt;mark(klass);</span>
<span class="line-removed"> 143   assert(symbol_id &gt; 0, &quot;need to have an address for symbol!&quot;);</span>
<span class="line-removed"> 144   writer-&gt;write(TRACE_ID(klass));</span>
<span class="line-removed"> 145   writer-&gt;write(cld_id(klass-&gt;class_loader_data()));</span>
<span class="line-removed"> 146   writer-&gt;write((traceid)CREATE_SYMBOL_ID(symbol_id));</span>
<span class="line-removed"> 147   writer-&gt;write(pkg_id);</span>
<span class="line-removed"> 148   writer-&gt;write((s4)klass-&gt;access_flags().get_flags());</span>
<span class="line-removed"> 149   return 1;</span>
 150 }
 151 
<span class="line-modified"> 152 typedef LeakPredicate&lt;KlassPtr&gt; LeakKlassPredicate;</span>
<span class="line-modified"> 153 typedef JfrPredicatedArtifactWriterImplHost&lt;KlassPtr, LeakKlassPredicate, write__artifact__klass&gt; LeakKlassWriterImpl;</span>
<span class="line-modified"> 154 typedef JfrArtifactWriterHost&lt;LeakKlassWriterImpl, TYPE_CLASS&gt; LeakKlassWriter;</span>
<span class="line-modified"> 155 typedef JfrArtifactWriterImplHost&lt;KlassPtr, write__artifact__klass&gt; KlassWriterImpl;</span>
<span class="line-modified"> 156 typedef JfrArtifactWriterHost&lt;KlassWriterImpl, TYPE_CLASS&gt; KlassWriter;</span>
 157 
<span class="line-modified"> 158 int write__artifact__method(JfrCheckpointWriter* writer, JfrArtifactSet* artifacts, const void* m) {</span>
<span class="line-removed"> 159   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 160   assert(artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 161   assert(m != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 162   MethodPtr method = (MethodPtr)m;</span>
<span class="line-removed"> 163   const traceid method_name_symbol_id = artifacts-&gt;mark(method-&gt;name());</span>
<span class="line-removed"> 164   assert(method_name_symbol_id &gt; 0, &quot;invariant&quot;);</span>
<span class="line-removed"> 165   const traceid method_sig_symbol_id = artifacts-&gt;mark(method-&gt;signature());</span>
<span class="line-removed"> 166   assert(method_sig_symbol_id &gt; 0, &quot;invariant&quot;);</span>
<span class="line-removed"> 167   KlassPtr klass = method-&gt;method_holder();</span>
 168   assert(klass != NULL, &quot;invariant&quot;);
<span class="line-modified"> 169   assert(METHOD_USED_ANY_EPOCH(klass), &quot;invariant&quot;);</span>
<span class="line-modified"> 170   writer-&gt;write((u8)METHOD_ID(klass, method));</span>
<span class="line-modified"> 171   writer-&gt;write((u8)TRACE_ID(klass));</span>
<span class="line-modified"> 172   writer-&gt;write((u8)CREATE_SYMBOL_ID(method_name_symbol_id));</span>
<span class="line-modified"> 173   writer-&gt;write((u8)CREATE_SYMBOL_ID(method_sig_symbol_id));</span>
<span class="line-modified"> 174   writer-&gt;write((u2)method-&gt;access_flags().get_flags());</span>
<span class="line-modified"> 175   writer-&gt;write(const_cast&lt;Method*&gt;(method)-&gt;is_hidden() ? (u1)1 : (u1)0);</span>
<span class="line-modified"> 176   return 1;</span>

 177 }
 178 
<span class="line-modified"> 179 typedef JfrArtifactWriterImplHost&lt;MethodPtr, write__artifact__method&gt; MethodWriterImplTarget;</span>
<span class="line-modified"> 180 typedef JfrArtifactWriterHost&lt;MethodWriterImplTarget, TYPE_METHOD&gt; MethodWriterImpl;</span>
<span class="line-modified"> 181 </span>
<span class="line-modified"> 182 int write__artifact__package(JfrCheckpointWriter* writer, JfrArtifactSet* artifacts, const void* p) {</span>
<span class="line-modified"> 183   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 184   assert(artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 185   assert(p != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 186   PkgPtr pkg = (PkgPtr)p;</span>
<span class="line-modified"> 187   Symbol* const pkg_name = pkg-&gt;name();</span>
<span class="line-modified"> 188   const traceid package_name_symbol_id = pkg_name != NULL ? artifacts-&gt;mark(pkg_name) : 0;</span>
<span class="line-modified"> 189   assert(package_name_symbol_id &gt; 0, &quot;invariant&quot;);</span>
<span class="line-modified"> 190   writer-&gt;write((traceid)TRACE_ID(pkg));</span>
<span class="line-removed"> 191   writer-&gt;write((traceid)CREATE_SYMBOL_ID(package_name_symbol_id));</span>
<span class="line-removed"> 192   writer-&gt;write(module_id(pkg));</span>
<span class="line-removed"> 193   writer-&gt;write((bool)pkg-&gt;is_exported());</span>
<span class="line-removed"> 194   return 1;</span>
 195 }
 196 
<span class="line-modified"> 197 typedef LeakPredicate&lt;PkgPtr&gt; LeakPackagePredicate;</span>
<span class="line-modified"> 198 int _compare_pkg_ptr_(PkgPtr const&amp; lhs, PkgPtr const&amp; rhs) { return lhs &gt; rhs ? 1 : (lhs &lt; rhs) ? -1 : 0; }</span>
<span class="line-modified"> 199 typedef UniquePredicate&lt;PkgPtr, _compare_pkg_ptr_&gt; PackagePredicate;</span>
<span class="line-modified"> 200 typedef JfrPredicatedArtifactWriterImplHost&lt;PkgPtr, LeakPackagePredicate, write__artifact__package&gt; LeakPackageWriterImpl;</span>
<span class="line-removed"> 201 typedef JfrPredicatedArtifactWriterImplHost&lt;PkgPtr, PackagePredicate, write__artifact__package&gt; PackageWriterImpl;</span>
<span class="line-removed"> 202 typedef JfrArtifactWriterHost&lt;LeakPackageWriterImpl, TYPE_PACKAGE&gt; LeakPackageWriter;</span>
<span class="line-removed"> 203 typedef JfrArtifactWriterHost&lt;PackageWriterImpl, TYPE_PACKAGE&gt; PackageWriter;</span>
<span class="line-removed"> 204 </span>
<span class="line-removed"> 205 int write__artifact__module(JfrCheckpointWriter* writer, JfrArtifactSet* artifacts, const void* m) {</span>
<span class="line-removed"> 206   assert( m != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 207   ModPtr entry = (ModPtr)m;</span>
<span class="line-removed"> 208   Symbol* const module_name = entry-&gt;name();</span>
<span class="line-removed"> 209   const traceid module_name_symbol_id = module_name != NULL ? artifacts-&gt;mark(module_name) : 0;</span>
<span class="line-removed"> 210   Symbol* const module_version = entry-&gt;version();</span>
<span class="line-removed"> 211   const traceid module_version_symbol_id = module_version != NULL ? artifacts-&gt;mark(module_version) : 0;</span>
<span class="line-removed"> 212   Symbol* const module_location = entry-&gt;location();</span>
<span class="line-removed"> 213   const traceid module_location_symbol_id = module_location != NULL ? artifacts-&gt;mark(module_location) : 0;</span>
<span class="line-removed"> 214   writer-&gt;write((traceid)TRACE_ID(entry));</span>
<span class="line-removed"> 215   writer-&gt;write(module_name_symbol_id == 0 ? (traceid)0 : (traceid)CREATE_SYMBOL_ID(module_name_symbol_id));</span>
<span class="line-removed"> 216   writer-&gt;write(module_version_symbol_id == 0 ? (traceid)0 : (traceid)CREATE_SYMBOL_ID(module_version_symbol_id));</span>
<span class="line-removed"> 217   writer-&gt;write(module_location_symbol_id == 0 ? (traceid)0 : (traceid)CREATE_SYMBOL_ID(module_location_symbol_id));</span>
<span class="line-removed"> 218   writer-&gt;write(cld_id(entry-&gt;loader_data()));</span>
<span class="line-removed"> 219   return 1;</span>
 220 }
 221 
<span class="line-modified"> 222 typedef LeakPredicate&lt;ModPtr&gt; LeakModulePredicate;</span>
<span class="line-modified"> 223 int _compare_mod_ptr_(ModPtr const&amp; lhs, ModPtr const&amp; rhs) { return lhs &gt; rhs ? 1 : (lhs &lt; rhs) ? -1 : 0; }</span>
<span class="line-removed"> 224 typedef UniquePredicate&lt;ModPtr, _compare_mod_ptr_&gt; ModulePredicate;</span>
<span class="line-removed"> 225 typedef JfrPredicatedArtifactWriterImplHost&lt;ModPtr, LeakModulePredicate, write__artifact__module&gt; LeakModuleWriterImpl;</span>
<span class="line-removed"> 226 typedef JfrPredicatedArtifactWriterImplHost&lt;ModPtr, ModulePredicate, write__artifact__module&gt; ModuleWriterImpl;</span>
<span class="line-removed"> 227 typedef JfrArtifactWriterHost&lt;LeakModuleWriterImpl, TYPE_MODULE&gt; LeakModuleWriter;</span>
<span class="line-removed"> 228 typedef JfrArtifactWriterHost&lt;ModuleWriterImpl, TYPE_MODULE&gt; ModuleWriter;</span>
<span class="line-removed"> 229 </span>
<span class="line-removed"> 230 int write__artifact__classloader(JfrCheckpointWriter* writer, JfrArtifactSet* artifacts, const void* c) {</span>
<span class="line-removed"> 231   assert(c != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 232   CldPtr cld = (CldPtr)c;</span>
 233   assert(!cld-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);
<span class="line-modified"> 234   const traceid cld_id = TRACE_ID(cld);</span>
<span class="line-modified"> 235   // class loader type</span>
<span class="line-removed"> 236   const Klass* class_loader_klass = cld-&gt;class_loader_klass();</span>
<span class="line-removed"> 237   if (class_loader_klass == NULL) {</span>
<span class="line-removed"> 238     // (primordial) boot class loader</span>
<span class="line-removed"> 239     writer-&gt;write(cld_id); // class loader instance id</span>
<span class="line-removed"> 240     writer-&gt;write((traceid)0);  // class loader type id (absence of)</span>
<span class="line-removed"> 241     writer-&gt;write((traceid)CREATE_SYMBOL_ID(1)); // 1 maps to synthetic name -&gt; &quot;bootstrap&quot;</span>
 242   } else {
<span class="line-modified"> 243     Symbol* symbol_name = cld-&gt;name();</span>
<span class="line-removed"> 244     const traceid symbol_name_id = symbol_name != NULL ? artifacts-&gt;mark(symbol_name) : 0;</span>
<span class="line-removed"> 245     writer-&gt;write(cld_id); // class loader instance id</span>
<span class="line-removed"> 246     writer-&gt;write(TRACE_ID(class_loader_klass)); // class loader type id</span>
<span class="line-removed"> 247     writer-&gt;write(symbol_name_id == 0 ? (traceid)0 :</span>
<span class="line-removed"> 248       (traceid)CREATE_SYMBOL_ID(symbol_name_id)); // class loader instance name</span>
 249   }
<span class="line-modified"> 250   return 1;</span>
 251 }
 252 
<span class="line-modified"> 253 typedef LeakPredicate&lt;CldPtr&gt; LeakCldPredicate;</span>
<span class="line-modified"> 254 int _compare_cld_ptr_(CldPtr const&amp; lhs, CldPtr const&amp; rhs) { return lhs &gt; rhs ? 1 : (lhs &lt; rhs) ? -1 : 0; }</span>
<span class="line-modified"> 255 typedef UniquePredicate&lt;CldPtr, _compare_cld_ptr_&gt; CldPredicate;</span>
<span class="line-modified"> 256 typedef JfrPredicatedArtifactWriterImplHost&lt;CldPtr, LeakCldPredicate, write__artifact__classloader&gt; LeakCldWriterImpl;</span>
<span class="line-modified"> 257 typedef JfrPredicatedArtifactWriterImplHost&lt;CldPtr, CldPredicate, write__artifact__classloader&gt; CldWriterImpl;</span>
<span class="line-removed"> 258 typedef JfrArtifactWriterHost&lt;LeakCldWriterImpl, TYPE_CLASSLOADER&gt; LeakCldWriter;</span>
<span class="line-removed"> 259 typedef JfrArtifactWriterHost&lt;CldWriterImpl, TYPE_CLASSLOADER&gt; CldWriter;</span>
<span class="line-removed"> 260 </span>
<span class="line-removed"> 261 typedef const JfrSymbolId::SymbolEntry* SymbolEntryPtr;</span>
 262 
<span class="line-modified"> 263 static int write__artifact__symbol__entry__(JfrCheckpointWriter* writer,</span>
<span class="line-modified"> 264                                             SymbolEntryPtr entry) {</span>
<span class="line-modified"> 265   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 266   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 267   ResourceMark rm;</span>
<span class="line-removed"> 268   writer-&gt;write(CREATE_SYMBOL_ID(entry-&gt;id()));</span>
<span class="line-removed"> 269   writer-&gt;write(entry-&gt;value()-&gt;as_C_string());</span>
<span class="line-removed"> 270   return 1;</span>
 271 }
 272 
<span class="line-modified"> 273 int write__artifact__symbol__entry(JfrCheckpointWriter* writer, JfrArtifactSet* artifacts, const void* e) {</span>
<span class="line-modified"> 274   assert(e != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 275   return write__artifact__symbol__entry__(writer, (SymbolEntryPtr)e);</span>

 276 }
 277 
<span class="line-modified"> 278 typedef JfrArtifactWriterImplHost&lt;SymbolEntryPtr, write__artifact__symbol__entry&gt; SymbolEntryWriterImpl;</span>
<span class="line-modified"> 279 typedef JfrArtifactWriterHost&lt;SymbolEntryWriterImpl, TYPE_SYMBOL&gt; SymbolEntryWriter;</span>





 280 
<span class="line-modified"> 281 typedef const JfrSymbolId::CStringEntry* CStringEntryPtr;</span>






 282 
<span class="line-modified"> 283 static int write__artifact__cstring__entry__(JfrCheckpointWriter* writer, CStringEntryPtr entry) {</span>
 284   assert(writer != NULL, &quot;invariant&quot;);
<span class="line-modified"> 285   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 286   writer-&gt;write(CREATE_SYMBOL_ID(entry-&gt;id()));</span>
<span class="line-modified"> 287   writer-&gt;write(entry-&gt;value());</span>















 288   return 1;
 289 }
 290 
<span class="line-modified"> 291 int write__artifact__cstring__entry(JfrCheckpointWriter* writer, JfrArtifactSet* artifacts, const void* e) {</span>
<span class="line-modified"> 292   assert(e != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 293   return write__artifact__cstring__entry__(writer, (CStringEntryPtr)e);</span>


 294 }
 295 
<span class="line-modified"> 296 typedef JfrArtifactWriterImplHost&lt;CStringEntryPtr, write__artifact__cstring__entry&gt; CStringEntryWriterImpl;</span>
<span class="line-removed"> 297 typedef JfrArtifactWriterHost&lt;CStringEntryWriterImpl, TYPE_SYMBOL&gt; CStringEntryWriter;</span>
<span class="line-removed"> 298 </span>
<span class="line-removed"> 299 int write__artifact__klass__symbol(JfrCheckpointWriter* writer, JfrArtifactSet* artifacts, const void* k) {</span>
<span class="line-removed"> 300   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 301   assert(artifacts != NULL, &quot;invaiant&quot;);</span>
 302   assert(k != NULL, &quot;invariant&quot;);
<span class="line-modified"> 303   const InstanceKlass* const ik = (const InstanceKlass*)k;</span>
<span class="line-modified"> 304   if (ik-&gt;is_unsafe_anonymous()) {</span>
<span class="line-removed"> 305     CStringEntryPtr entry =</span>
<span class="line-removed"> 306       artifacts-&gt;map_cstring(JfrSymbolId::unsafe_anonymous_klass_name_hash_code(ik));</span>
<span class="line-removed"> 307     assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 308     return write__artifact__cstring__entry__(writer, entry);</span>
<span class="line-removed"> 309   }</span>
<span class="line-removed"> 310 </span>
<span class="line-removed"> 311   SymbolEntryPtr entry = artifacts-&gt;map_symbol(JfrSymbolId::regular_klass_name_hash_code(ik));</span>
<span class="line-removed"> 312   return write__artifact__symbol__entry__(writer, entry);</span>
 313 }
 314 
<span class="line-modified"> 315 int _compare_traceid_(const traceid&amp; lhs, const traceid&amp; rhs) {</span>
<span class="line-modified"> 316   return lhs &gt; rhs ? 1 : (lhs &lt; rhs) ? -1 : 0;</span>

 317 }
 318 
<span class="line-modified"> 319 template &lt;template &lt;typename&gt; class Predicate&gt;</span>
<span class="line-modified"> 320 class KlassSymbolWriterImpl {</span>
<span class="line-modified"> 321  private:</span>
<span class="line-modified"> 322   JfrCheckpointWriter* _writer;</span>
<span class="line-modified"> 323   JfrArtifactSet* _artifacts;</span>
<span class="line-removed"> 324   Predicate&lt;KlassPtr&gt; _predicate;</span>
<span class="line-removed"> 325   MethodUsedPredicate&lt;true&gt; _method_used_predicate;</span>
<span class="line-removed"> 326   MethodFlagPredicate _method_flag_predicate;</span>
<span class="line-removed"> 327   UniquePredicate&lt;traceid, _compare_traceid_&gt; _unique_predicate;</span>
<span class="line-removed"> 328 </span>
<span class="line-removed"> 329   int klass_symbols(KlassPtr klass);</span>
<span class="line-removed"> 330   int package_symbols(PkgPtr pkg);</span>
<span class="line-removed"> 331   int module_symbols(ModPtr module);</span>
<span class="line-removed"> 332   int class_loader_symbols(CldPtr cld);</span>
<span class="line-removed"> 333   int method_symbols(KlassPtr klass);</span>
<span class="line-removed"> 334 </span>
<span class="line-removed"> 335  public:</span>
<span class="line-removed"> 336   typedef KlassPtr Type;</span>
<span class="line-removed"> 337   KlassSymbolWriterImpl(JfrCheckpointWriter* writer,</span>
<span class="line-removed"> 338                         JfrArtifactSet* artifacts,</span>
<span class="line-removed"> 339                         bool class_unload) : _writer(writer),</span>
<span class="line-removed"> 340                                              _artifacts(artifacts),</span>
<span class="line-removed"> 341                                              _predicate(class_unload),</span>
<span class="line-removed"> 342                                              _method_used_predicate(class_unload),</span>
<span class="line-removed"> 343                                              _method_flag_predicate(class_unload),</span>
<span class="line-removed"> 344                                              _unique_predicate(class_unload) {}</span>
<span class="line-removed"> 345 </span>
<span class="line-removed"> 346   int operator()(KlassPtr klass) {</span>
<span class="line-removed"> 347     assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 348     int count = 0;</span>
<span class="line-removed"> 349     if (_predicate(klass)) {</span>
<span class="line-removed"> 350       count += klass_symbols(klass);</span>
<span class="line-removed"> 351       PkgPtr pkg = klass-&gt;package();</span>
<span class="line-removed"> 352       if (pkg != NULL) {</span>
<span class="line-removed"> 353         count += package_symbols(pkg);</span>
<span class="line-removed"> 354         ModPtr module = pkg-&gt;module();</span>
<span class="line-removed"> 355         if (module != NULL &amp;&amp; module-&gt;is_named()) {</span>
<span class="line-removed"> 356           count += module_symbols(module);</span>
<span class="line-removed"> 357         }</span>
<span class="line-removed"> 358       }</span>
<span class="line-removed"> 359       CldPtr cld = klass-&gt;class_loader_data();</span>
<span class="line-removed"> 360       assert(cld != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 361       if (!cld-&gt;is_unsafe_anonymous()) {</span>
<span class="line-removed"> 362         count += class_loader_symbols(cld);</span>
<span class="line-removed"> 363       }</span>
<span class="line-removed"> 364       if (_method_used_predicate(klass)) {</span>
<span class="line-removed"> 365         count += method_symbols(klass);</span>
<span class="line-removed"> 366       }</span>
 367     }
<span class="line-modified"> 368     return count;</span>
 369   }
<span class="line-removed"> 370 };</span>
<span class="line-removed"> 371 </span>
<span class="line-removed"> 372 template &lt;template &lt;typename&gt; class Predicate&gt;</span>
<span class="line-removed"> 373 int KlassSymbolWriterImpl&lt;Predicate&gt;::klass_symbols(KlassPtr klass) {</span>
<span class="line-removed"> 374   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 375   assert(_predicate(klass), &quot;invariant&quot;);</span>
<span class="line-removed"> 376   const InstanceKlass* const ik = (const InstanceKlass*)klass;</span>
<span class="line-removed"> 377   if (ik-&gt;is_unsafe_anonymous()) {</span>
<span class="line-removed"> 378     CStringEntryPtr entry =</span>
<span class="line-removed"> 379       this-&gt;_artifacts-&gt;map_cstring(JfrSymbolId::unsafe_anonymous_klass_name_hash_code(ik));</span>
<span class="line-removed"> 380     assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 381     return _unique_predicate(entry-&gt;id()) ? write__artifact__cstring__entry__(this-&gt;_writer, entry) : 0;</span>
<span class="line-removed"> 382   }</span>
<span class="line-removed"> 383   SymbolEntryPtr entry = this-&gt;_artifacts-&gt;map_symbol(ik-&gt;name());</span>
<span class="line-removed"> 384   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 385   return _unique_predicate(entry-&gt;id()) ? write__artifact__symbol__entry__(this-&gt;_writer, entry) : 0;</span>
 386 }
 387 
<span class="line-modified"> 388 template &lt;template &lt;typename&gt; class Predicate&gt;</span>
<span class="line-modified"> 389 int KlassSymbolWriterImpl&lt;Predicate&gt;::package_symbols(PkgPtr pkg) {</span>
<span class="line-modified"> 390   assert(pkg != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 391   SymbolPtr pkg_name = pkg-&gt;name();</span>
<span class="line-modified"> 392   assert(pkg_name != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 393   SymbolEntryPtr package_symbol = this-&gt;_artifacts-&gt;map_symbol(pkg_name);</span>
<span class="line-removed"> 394   assert(package_symbol != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 395   return _unique_predicate(package_symbol-&gt;id()) ?</span>
<span class="line-removed"> 396     write__artifact__symbol__entry__(this-&gt;_writer, package_symbol) : 0;</span>
<span class="line-removed"> 397 }</span>
<span class="line-removed"> 398 </span>
<span class="line-removed"> 399 template &lt;template &lt;typename&gt; class Predicate&gt;</span>
<span class="line-removed"> 400 int KlassSymbolWriterImpl&lt;Predicate&gt;::module_symbols(ModPtr module) {</span>
<span class="line-removed"> 401   assert(module != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 402   assert(module-&gt;is_named(), &quot;invariant&quot;);</span>
<span class="line-removed"> 403   int count = 0;</span>
<span class="line-removed"> 404   SymbolPtr sym = module-&gt;name();</span>
<span class="line-removed"> 405   SymbolEntryPtr entry = NULL;</span>
<span class="line-removed"> 406   if (sym != NULL) {</span>
<span class="line-removed"> 407     entry = this-&gt;_artifacts-&gt;map_symbol(sym);</span>
<span class="line-removed"> 408     assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 409     if (_unique_predicate(entry-&gt;id())) {</span>
<span class="line-removed"> 410       count += write__artifact__symbol__entry__(this-&gt;_writer, entry);</span>
<span class="line-removed"> 411     }</span>
<span class="line-removed"> 412   }</span>
<span class="line-removed"> 413   sym = module-&gt;version();</span>
<span class="line-removed"> 414   if (sym != NULL) {</span>
<span class="line-removed"> 415     entry = this-&gt;_artifacts-&gt;map_symbol(sym);</span>
<span class="line-removed"> 416     assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 417     if (_unique_predicate(entry-&gt;id())) {</span>
<span class="line-removed"> 418       count += write__artifact__symbol__entry__(this-&gt;_writer, entry);</span>
<span class="line-removed"> 419     }</span>
 420   }
<span class="line-modified"> 421   sym = module-&gt;location();</span>
<span class="line-modified"> 422   if (sym != NULL) {</span>
<span class="line-modified"> 423     entry = this-&gt;_artifacts-&gt;map_symbol(sym);</span>
<span class="line-modified"> 424     assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 425     if (_unique_predicate(entry-&gt;id())) {</span>
<span class="line-removed"> 426       count += write__artifact__symbol__entry__(this-&gt;_writer, entry);</span>
<span class="line-removed"> 427     }</span>
 428   }
<span class="line-modified"> 429   return count;</span>
 430 }
 431 
<span class="line-modified"> 432 template &lt;template &lt;typename&gt; class Predicate&gt;</span>
<span class="line-modified"> 433 int KlassSymbolWriterImpl&lt;Predicate&gt;::class_loader_symbols(CldPtr cld) {</span>
<span class="line-modified"> 434   assert(cld != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 435   assert(!cld-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);</span>
<span class="line-modified"> 436   int count = 0;</span>
<span class="line-modified"> 437   // class loader type</span>
<span class="line-modified"> 438   const Klass* class_loader_klass = cld-&gt;class_loader_klass();</span>
<span class="line-removed"> 439   if (class_loader_klass == NULL) {</span>
<span class="line-removed"> 440     // (primordial) boot class loader</span>
<span class="line-removed"> 441     CStringEntryPtr entry = this-&gt;_artifacts-&gt;map_cstring(0);</span>
<span class="line-removed"> 442     assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 443     assert(strncmp(entry-&gt;literal(),</span>
<span class="line-removed"> 444       BOOTSTRAP_LOADER_NAME,</span>
<span class="line-removed"> 445       BOOTSTRAP_LOADER_NAME_LEN) == 0, &quot;invariant&quot;);</span>
<span class="line-removed"> 446     if (_unique_predicate(entry-&gt;id())) {</span>
<span class="line-removed"> 447       count += write__artifact__cstring__entry__(this-&gt;_writer, entry);</span>
 448     }
 449   } else {
<span class="line-modified"> 450     const Symbol* class_loader_name = cld-&gt;name();</span>
<span class="line-modified"> 451     if (class_loader_name != NULL) {</span>
<span class="line-modified"> 452       SymbolEntryPtr entry = this-&gt;_artifacts-&gt;map_symbol(class_loader_name);</span>
<span class="line-removed"> 453       assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 454       if (_unique_predicate(entry-&gt;id())) {</span>
<span class="line-removed"> 455         count += write__artifact__symbol__entry__(this-&gt;_writer, entry);</span>
<span class="line-removed"> 456       }</span>
<span class="line-removed"> 457     }</span>
<span class="line-removed"> 458   }</span>
<span class="line-removed"> 459   return count;</span>
<span class="line-removed"> 460 }</span>
<span class="line-removed"> 461 </span>
<span class="line-removed"> 462 template &lt;template &lt;typename&gt; class Predicate&gt;</span>
<span class="line-removed"> 463 int KlassSymbolWriterImpl&lt;Predicate&gt;::method_symbols(KlassPtr klass) {</span>
<span class="line-removed"> 464   assert(_predicate(klass), &quot;invariant&quot;);</span>
<span class="line-removed"> 465   assert(_method_used_predicate(klass), &quot;invariant&quot;);</span>
<span class="line-removed"> 466   assert(METHOD_AND_CLASS_USED_ANY_EPOCH(klass), &quot;invariant&quot;);</span>
<span class="line-removed"> 467   int count = 0;</span>
<span class="line-removed"> 468   const InstanceKlass* const ik = InstanceKlass::cast(klass);</span>
<span class="line-removed"> 469   const int len = ik-&gt;methods()-&gt;length();</span>
<span class="line-removed"> 470   for (int i = 0; i &lt; len; ++i) {</span>
<span class="line-removed"> 471     MethodPtr method = ik-&gt;methods()-&gt;at(i);</span>
<span class="line-removed"> 472     if (_method_flag_predicate(method)) {</span>
<span class="line-removed"> 473       SymbolEntryPtr entry = this-&gt;_artifacts-&gt;map_symbol(method-&gt;name());</span>
<span class="line-removed"> 474       assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 475       if (_unique_predicate(entry-&gt;id())) {</span>
<span class="line-removed"> 476         count += write__artifact__symbol__entry__(this-&gt;_writer, entry);</span>
<span class="line-removed"> 477       }</span>
<span class="line-removed"> 478       entry = this-&gt;_artifacts-&gt;map_symbol(method-&gt;signature());</span>
<span class="line-removed"> 479       assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 480       if (_unique_predicate(entry-&gt;id())) {</span>
<span class="line-removed"> 481         count += write__artifact__symbol__entry__(this-&gt;_writer, entry);</span>
<span class="line-removed"> 482       }</span>
 483     }
 484   }
<span class="line-modified"> 485   return count;</span>
 486 }
 487 
<span class="line-modified"> 488 typedef KlassSymbolWriterImpl&lt;LeakPredicate&gt; LeakKlassSymbolWriterImpl;</span>
<span class="line-modified"> 489 typedef JfrArtifactWriterHost&lt;LeakKlassSymbolWriterImpl, TYPE_SYMBOL&gt; LeakKlassSymbolWriter;</span>





 490 
<span class="line-modified"> 491 class ClearKlassAndMethods {</span>
<span class="line-modified"> 492  private:</span>
<span class="line-modified"> 493   ClearArtifact&lt;KlassPtr&gt; _clear_klass_tag_bits;</span>
<span class="line-modified"> 494   ClearArtifact&lt;MethodPtr&gt; _clear_method_flag;</span>
<span class="line-modified"> 495   MethodUsedPredicate&lt;false&gt; _method_used_predicate;</span>
 496 
<span class="line-modified"> 497  public:</span>
<span class="line-modified"> 498   ClearKlassAndMethods(bool class_unload) : _clear_klass_tag_bits(class_unload),</span>
<span class="line-modified"> 499                                             _clear_method_flag(class_unload),</span>
<span class="line-modified"> 500                                             _method_used_predicate(class_unload) {}</span>
<span class="line-modified"> 501   bool operator()(KlassPtr klass) {</span>
<span class="line-modified"> 502     if (_method_used_predicate(klass)) {</span>
<span class="line-modified"> 503       const InstanceKlass* ik = InstanceKlass::cast(klass);</span>
<span class="line-removed"> 504       const int len = ik-&gt;methods()-&gt;length();</span>
<span class="line-removed"> 505       for (int i = 0; i &lt; len; ++i) {</span>
<span class="line-removed"> 506         MethodPtr method = ik-&gt;methods()-&gt;at(i);</span>
<span class="line-removed"> 507         _clear_method_flag(method);</span>
<span class="line-removed"> 508       }</span>
<span class="line-removed"> 509     }</span>
<span class="line-removed"> 510     _clear_klass_tag_bits(klass);</span>
<span class="line-removed"> 511     return true;</span>
 512   }
 513 };
 514 
<span class="line-modified"> 515 typedef CompositeFunctor&lt;KlassPtr,</span>
<span class="line-modified"> 516                          TagLeakpKlassArtifact,</span>
<span class="line-modified"> 517                          LeakKlassWriter&gt; LeakpKlassArtifactTagging;</span>
<span class="line-removed"> 518 </span>
<span class="line-removed"> 519 typedef CompositeFunctor&lt;KlassPtr,</span>
<span class="line-removed"> 520                          LeakpKlassArtifactTagging,</span>
<span class="line-removed"> 521                          KlassWriter&gt; CompositeKlassWriter;</span>
<span class="line-removed"> 522 </span>
<span class="line-removed"> 523 typedef CompositeFunctor&lt;KlassPtr,</span>
<span class="line-removed"> 524                          CompositeKlassWriter,</span>
<span class="line-removed"> 525                          KlassArtifactRegistrator&gt; CompositeKlassWriterRegistration;</span>
<span class="line-removed"> 526 </span>
<span class="line-removed"> 527 typedef CompositeFunctor&lt;KlassPtr,</span>
<span class="line-removed"> 528                          KlassWriter,</span>
<span class="line-removed"> 529                          KlassArtifactRegistrator&gt; KlassWriterRegistration;</span>
 530 
<span class="line-modified"> 531 typedef JfrArtifactCallbackHost&lt;KlassPtr, KlassWriterRegistration&gt; KlassCallback;</span>

 532 typedef JfrArtifactCallbackHost&lt;KlassPtr, CompositeKlassWriterRegistration&gt; CompositeKlassCallback;
 533 
<span class="line-modified"> 534 /*</span>
<span class="line-removed"> 535  * Composite operation</span>
<span class="line-removed"> 536  *</span>
<span class="line-removed"> 537  * TagLeakpKlassArtifact -&gt;</span>
<span class="line-removed"> 538  *   LeakpPredicate -&gt;</span>
<span class="line-removed"> 539  *     LeakpKlassWriter -&gt;</span>
<span class="line-removed"> 540  *       KlassPredicate -&gt;</span>
<span class="line-removed"> 541  *         KlassWriter -&gt;</span>
<span class="line-removed"> 542  *           KlassWriterRegistration</span>
<span class="line-removed"> 543  */</span>
<span class="line-removed"> 544 void JfrTypeSet::write_klass_constants(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer) {</span>
 545   assert(!_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);

 546   KlassArtifactRegistrator reg(_artifacts);
<span class="line-modified"> 547   KlassWriter kw(writer, _artifacts, _class_unload);</span>
 548   KlassWriterRegistration kwr(&amp;kw, &amp;reg);
<span class="line-modified"> 549   if (leakp_writer == NULL) {</span>
 550     KlassCallback callback(&amp;kwr);
 551     _subsystem_callback = &amp;callback;
 552     do_klasses();






















 553     return;
 554   }
<span class="line-modified"> 555   TagLeakpKlassArtifact tagging(_class_unload);</span>
<span class="line-modified"> 556   LeakKlassWriter lkw(leakp_writer, _artifacts, _class_unload);</span>
<span class="line-modified"> 557   LeakpKlassArtifactTagging lpkat(&amp;tagging, &amp;lkw);</span>
<span class="line-modified"> 558   CompositeKlassWriter ckw(&amp;lpkat, &amp;kw);</span>
<span class="line-modified"> 559   CompositeKlassWriterRegistration ckwr(&amp;ckw, &amp;reg);</span>
<span class="line-modified"> 560   CompositeKlassCallback callback(&amp;ckwr);</span>
















 561   _subsystem_callback = &amp;callback;
<span class="line-modified"> 562   do_klasses();</span>


















 563 }
 564 
<span class="line-modified"> 565 typedef CompositeFunctor&lt;PkgPtr,</span>
<span class="line-modified"> 566                          PackageWriter,</span>
<span class="line-modified"> 567                          ClearArtifact&lt;PkgPtr&gt; &gt; PackageWriterWithClear;</span>



 568 
<span class="line-modified"> 569 typedef CompositeFunctor&lt;PkgPtr,</span>
<span class="line-modified"> 570                          LeakPackageWriter,</span>
<span class="line-modified"> 571                          PackageWriter&gt; CompositePackageWriter;</span>
 572 
<span class="line-modified"> 573 typedef CompositeFunctor&lt;PkgPtr,</span>
<span class="line-modified"> 574                          CompositePackageWriter,</span>
<span class="line-modified"> 575                          ClearArtifact&lt;PkgPtr&gt; &gt; CompositePackageWriterWithClear;</span>
 576 
 577 class PackageFieldSelector {
 578  public:
 579   typedef PkgPtr TypePtr;
 580   static TypePtr select(KlassPtr klass) {
 581     assert(klass != NULL, &quot;invariant&quot;);
 582     return ((InstanceKlass*)klass)-&gt;package();
 583   }
 584 };
 585 
<span class="line-modified"> 586 typedef KlassToFieldEnvelope&lt;PackageFieldSelector,</span>
<span class="line-modified"> 587                              PackageWriterWithClear&gt; KlassPackageWriterWithClear;</span>




 588 
<span class="line-modified"> 589 typedef KlassToFieldEnvelope&lt;PackageFieldSelector,</span>
<span class="line-modified"> 590                              CompositePackageWriterWithClear&gt; KlassCompositePackageWriterWithClear;</span>

 591 
<span class="line-modified"> 592 typedef JfrArtifactCallbackHost&lt;PkgPtr, PackageWriterWithClear&gt; PackageCallback;</span>



 593 typedef JfrArtifactCallbackHost&lt;PkgPtr, CompositePackageWriterWithClear&gt; CompositePackageCallback;
 594 
<span class="line-modified"> 595 /*</span>
<span class="line-modified"> 596  * Composite operation</span>
<span class="line-modified"> 597  *</span>
<span class="line-modified"> 598  * LeakpPackageWriter -&gt;</span>
<span class="line-modified"> 599  *   PackageWriter -&gt;</span>
<span class="line-modified"> 600  *     ClearArtifact&lt;PackageEntry&gt;</span>
<span class="line-modified"> 601  *</span>
<span class="line-modified"> 602  */</span>
<span class="line-modified"> 603 void JfrTypeSet::write_package_constants(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer) {</span>
<span class="line-modified"> 604   assert(_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);</span>
<span class="line-modified"> 605   ClearArtifact&lt;PkgPtr&gt; clear(_class_unload);</span>
<span class="line-modified"> 606   PackageWriter pw(writer, _artifacts, _class_unload);</span>
<span class="line-modified"> 607   if (leakp_writer == NULL) {</span>
 608     PackageWriterWithClear pwwc(&amp;pw, &amp;clear);
<span class="line-removed"> 609     KlassPackageWriterWithClear kpwwc(&amp;pwwc);</span>
<span class="line-removed"> 610     _artifacts-&gt;iterate_klasses(kpwwc);</span>
 611     PackageCallback callback(&amp;pwwc);
 612     _subsystem_callback = &amp;callback;
 613     do_packages();
<span class="line-modified"> 614     return;</span>









 615   }
<span class="line-modified"> 616   LeakPackageWriter lpw(leakp_writer, _artifacts, _class_unload);</span>
<span class="line-modified"> 617   CompositePackageWriter cpw(&amp;lpw, &amp;pw);</span>
<span class="line-modified"> 618   CompositePackageWriterWithClear cpwwc(&amp;cpw, &amp;clear);</span>
<span class="line-modified"> 619   KlassCompositePackageWriterWithClear ckpw(&amp;cpwwc);</span>
<span class="line-modified"> 620   _artifacts-&gt;iterate_klasses(ckpw);</span>
<span class="line-modified"> 621   CompositePackageCallback callback(&amp;cpwwc);</span>


 622   _subsystem_callback = &amp;callback;
 623   do_packages();
 624 }
 625 
<span class="line-modified"> 626 typedef CompositeFunctor&lt;ModPtr,</span>
<span class="line-modified"> 627                          ModuleWriter,</span>
<span class="line-modified"> 628                          ClearArtifact&lt;ModPtr&gt; &gt; ModuleWriterWithClear;</span>







 629 
<span class="line-modified"> 630 typedef CompositeFunctor&lt;ModPtr,</span>
<span class="line-modified"> 631                          LeakModuleWriter,</span>
<span class="line-modified"> 632                          ModuleWriter&gt; CompositeModuleWriter;</span>



 633 
<span class="line-modified"> 634 typedef CompositeFunctor&lt;ModPtr,</span>
<span class="line-modified"> 635                          CompositeModuleWriter,</span>
<span class="line-modified"> 636                          ClearArtifact&lt;ModPtr&gt; &gt; CompositeModuleWriterWithClear;</span>



 637 
<span class="line-modified"> 638 typedef JfrArtifactCallbackHost&lt;ModPtr, ModuleWriterWithClear&gt; ModuleCallback;</span>
<span class="line-modified"> 639 typedef JfrArtifactCallbackHost&lt;ModPtr, CompositeModuleWriterWithClear&gt; CompositeModuleCallback;</span>





 640 
 641 class ModuleFieldSelector {
 642  public:
 643   typedef ModPtr TypePtr;
 644   static TypePtr select(KlassPtr klass) {
 645     assert(klass != NULL, &quot;invariant&quot;);
 646     PkgPtr pkg = klass-&gt;package();
 647     return pkg != NULL ? pkg-&gt;module() : NULL;
 648   }
 649 };
 650 
<span class="line-modified"> 651 typedef KlassToFieldEnvelope&lt;ModuleFieldSelector,</span>
<span class="line-modified"> 652                              ModuleWriterWithClear&gt; KlassModuleWriterWithClear;</span>




 653 
<span class="line-modified"> 654 typedef KlassToFieldEnvelope&lt;ModuleFieldSelector,</span>
<span class="line-modified"> 655                              CompositeModuleWriterWithClear&gt; KlassCompositeModuleWriterWithClear;</span>

 656 
<span class="line-modified"> 657 /*</span>
<span class="line-modified"> 658  * Composite operation</span>
<span class="line-modified"> 659  *</span>
<span class="line-modified"> 660  * LeakpModuleWriter -&gt;</span>
<span class="line-modified"> 661  *   ModuleWriter -&gt;</span>
<span class="line-modified"> 662  *     ClearArtifact&lt;ModuleEntry&gt;</span>
<span class="line-modified"> 663  */</span>
<span class="line-modified"> 664 void JfrTypeSet::write_module_constants(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer) {</span>
<span class="line-modified"> 665   assert(_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);</span>
<span class="line-modified"> 666   ClearArtifact&lt;ModPtr&gt; clear(_class_unload);</span>
<span class="line-modified"> 667   ModuleWriter mw(writer, _artifacts, _class_unload);</span>
<span class="line-modified"> 668   if (leakp_writer == NULL) {</span>






 669     ModuleWriterWithClear mwwc(&amp;mw, &amp;clear);
<span class="line-removed"> 670     KlassModuleWriterWithClear kmwwc(&amp;mwwc);</span>
<span class="line-removed"> 671     _artifacts-&gt;iterate_klasses(kmwwc);</span>
 672     ModuleCallback callback(&amp;mwwc);
 673     _subsystem_callback = &amp;callback;
 674     do_modules();
<span class="line-modified"> 675     return;</span>









 676   }
<span class="line-modified"> 677   LeakModuleWriter lmw(leakp_writer, _artifacts, _class_unload);</span>
<span class="line-modified"> 678   CompositeModuleWriter cmw(&amp;lmw, &amp;mw);</span>
<span class="line-modified"> 679   CompositeModuleWriterWithClear cmwwc(&amp;cmw, &amp;clear);</span>
<span class="line-modified"> 680   KlassCompositeModuleWriterWithClear kmwwc(&amp;cmwwc);</span>
<span class="line-modified"> 681   _artifacts-&gt;iterate_klasses(kmwwc);</span>
<span class="line-modified"> 682   CompositeModuleCallback callback(&amp;cmwwc);</span>


 683   _subsystem_callback = &amp;callback;
 684   do_modules();
 685 }
 686 
<span class="line-modified"> 687 typedef CompositeFunctor&lt;CldPtr, CldWriter, ClearArtifact&lt;CldPtr&gt; &gt; CldWriterWithClear;</span>
<span class="line-modified"> 688 typedef CompositeFunctor&lt;CldPtr, LeakCldWriter, CldWriter&gt; CompositeCldWriter;</span>
<span class="line-modified"> 689 typedef CompositeFunctor&lt;CldPtr, CompositeCldWriter, ClearArtifact&lt;CldPtr&gt; &gt; CompositeCldWriterWithClear;</span>
<span class="line-modified"> 690 typedef JfrArtifactCallbackHost&lt;CldPtr, CldWriterWithClear&gt; CldCallback;</span>
<span class="line-modified"> 691 typedef JfrArtifactCallbackHost&lt;CldPtr, CompositeCldWriterWithClear&gt; CompositeCldCallback;</span>


























 692 
<span class="line-modified"> 693 class CldFieldSelector {</span>




 694  public:
 695   typedef CldPtr TypePtr;
 696   static TypePtr select(KlassPtr klass) {
 697     assert(klass != NULL, &quot;invariant&quot;);
<span class="line-modified"> 698     CldPtr cld = klass-&gt;class_loader_data();</span>
<span class="line-removed"> 699     return cld-&gt;is_unsafe_anonymous() ? NULL : cld;</span>
 700   }
 701 };
 702 
<span class="line-modified"> 703 typedef KlassToFieldEnvelope&lt;CldFieldSelector, CldWriterWithClear&gt; KlassCldWriterWithClear;</span>
<span class="line-modified"> 704 typedef KlassToFieldEnvelope&lt;CldFieldSelector, CompositeCldWriterWithClear&gt; KlassCompositeCldWriterWithClear;</span>







 705 
<span class="line-modified"> 706 /*</span>
<span class="line-modified"> 707  * Composite operation</span>
<span class="line-modified"> 708  *</span>
<span class="line-modified"> 709  * LeakpClassLoaderWriter -&gt;</span>
<span class="line-modified"> 710  *   ClassLoaderWriter -&gt;</span>
<span class="line-modified"> 711  *     ClearArtifact&lt;ClassLoaderData&gt;</span>
<span class="line-modified"> 712  */</span>
<span class="line-modified"> 713 void JfrTypeSet::write_class_loader_constants(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer) {</span>
<span class="line-modified"> 714   assert(_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);</span>
<span class="line-modified"> 715   ClearArtifact&lt;CldPtr&gt; clear(_class_unload);</span>
<span class="line-modified"> 716   CldWriter cldw(writer, _artifacts, _class_unload);</span>
<span class="line-modified"> 717   if (leakp_writer == NULL) {</span>








































 718     CldWriterWithClear cldwwc(&amp;cldw, &amp;clear);
<span class="line-removed"> 719     KlassCldWriterWithClear kcldwwc(&amp;cldwwc);</span>
<span class="line-removed"> 720     _artifacts-&gt;iterate_klasses(kcldwwc);</span>
 721     CldCallback callback(&amp;cldwwc);
 722     _subsystem_callback = &amp;callback;
 723     do_class_loaders();
<span class="line-modified"> 724     return;</span>











 725   }
<span class="line-modified"> 726   LeakCldWriter lcldw(leakp_writer, _artifacts, _class_unload);</span>
<span class="line-modified"> 727   CompositeCldWriter ccldw(&amp;lcldw, &amp;cldw);</span>
<span class="line-modified"> 728   CompositeCldWriterWithClear ccldwwc(&amp;ccldw, &amp;clear);</span>
<span class="line-modified"> 729   KlassCompositeCldWriterWithClear kcclwwc(&amp;ccldwwc);</span>
<span class="line-modified"> 730   _artifacts-&gt;iterate_klasses(kcclwwc);</span>
<span class="line-modified"> 731   CompositeCldCallback callback(&amp;ccldwwc);</span>


 732   _subsystem_callback = &amp;callback;
 733   do_class_loaders();
 734 }
 735 
<span class="line-modified"> 736 template &lt;bool predicate_bool, typename MethodFunctor&gt;</span>

































































 737 class MethodIteratorHost {
 738  private:
<span class="line-modified"> 739   MethodFunctor _method_functor;</span>
<span class="line-modified"> 740   MethodUsedPredicate&lt;predicate_bool&gt; _method_used_predicate;</span>
<span class="line-modified"> 741   MethodFlagPredicate _method_flag_predicate;</span>
<span class="line-modified"> 742 </span>
 743  public:
 744   MethodIteratorHost(JfrCheckpointWriter* writer,
<span class="line-modified"> 745                      JfrArtifactSet* artifacts,</span>
<span class="line-modified"> 746                      bool class_unload,</span>
 747                      bool skip_header = false) :
<span class="line-modified"> 748     _method_functor(writer, artifacts, class_unload, skip_header),</span>
<span class="line-modified"> 749     _method_used_predicate(class_unload),</span>
<span class="line-modified"> 750     _method_flag_predicate(class_unload) {}</span>

 751 
 752   bool operator()(KlassPtr klass) {
 753     if (_method_used_predicate(klass)) {
<span class="line-removed"> 754       assert(METHOD_AND_CLASS_USED_ANY_EPOCH(klass), &quot;invariant&quot;);</span>
 755       const InstanceKlass* ik = InstanceKlass::cast(klass);
 756       const int len = ik-&gt;methods()-&gt;length();
<span class="line-modified"> 757       for (int i = 0; i &lt; len; ++i) {</span>
<span class="line-modified"> 758         MethodPtr method = ik-&gt;methods()-&gt;at(i);</span>
<span class="line-modified"> 759         if (_method_flag_predicate(method)) {</span>
<span class="line-modified"> 760           _method_functor(method);</span>



 761         }



 762       }
 763     }
<span class="line-modified"> 764     return true;</span>
 765   }
 766 
<span class="line-modified"> 767   int count() const { return _method_functor.count(); }</span>
<span class="line-modified"> 768   void add(int count) { _method_functor.add(count); }</span>
 769 };
 770 
<span class="line-modified"> 771 typedef MethodIteratorHost&lt;true /*leakp */,  MethodWriterImpl&gt; LeakMethodWriter;</span>
<span class="line-modified"> 772 typedef MethodIteratorHost&lt;false, MethodWriterImpl&gt; MethodWriter;</span>
<span class="line-modified"> 773 typedef CompositeFunctor&lt;KlassPtr, LeakMethodWriter, MethodWriter&gt; CompositeMethodWriter;</span>
<span class="line-modified"> 774 </span>
<span class="line-modified"> 775 /*</span>
<span class="line-modified"> 776  * Composite operation</span>
<span class="line-modified"> 777  *</span>
<span class="line-removed"> 778  * LeakpMethodWriter -&gt;</span>
<span class="line-removed"> 779  *   MethodWriter</span>
<span class="line-removed"> 780  */</span>
<span class="line-removed"> 781 void JfrTypeSet::write_method_constants(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer) {</span>
<span class="line-removed"> 782   assert(_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);</span>
<span class="line-removed"> 783   MethodWriter mw(writer, _artifacts, _class_unload);</span>
<span class="line-removed"> 784   if (leakp_writer == NULL) {</span>
<span class="line-removed"> 785     _artifacts-&gt;iterate_klasses(mw);</span>
<span class="line-removed"> 786     return;</span>
<span class="line-removed"> 787   }</span>
<span class="line-removed"> 788   LeakMethodWriter lpmw(leakp_writer, _artifacts, _class_unload);</span>
<span class="line-removed"> 789   CompositeMethodWriter cmw(&amp;lpmw, &amp;mw);</span>
<span class="line-removed"> 790   _artifacts-&gt;iterate_klasses(cmw);</span>
<span class="line-removed"> 791 }</span>
<span class="line-removed"> 792 static void write_symbols_leakp(JfrCheckpointWriter* leakp_writer, JfrArtifactSet* artifacts, bool class_unload) {</span>
<span class="line-removed"> 793   assert(leakp_writer != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 794   assert(artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 795   LeakKlassSymbolWriter lpksw(leakp_writer, artifacts, class_unload);</span>
<span class="line-removed"> 796   artifacts-&gt;iterate_klasses(lpksw);</span>
<span class="line-removed"> 797 }</span>
<span class="line-removed"> 798 static void write_symbols(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer, JfrArtifactSet* artifacts, bool class_unload) {</span>
<span class="line-removed"> 799   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 800   assert(artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 801   if (leakp_writer != NULL) {</span>
<span class="line-removed"> 802     write_symbols_leakp(leakp_writer, artifacts, class_unload);</span>
 803   }
<span class="line-modified"> 804   // iterate all registered symbols</span>
<span class="line-removed"> 805   SymbolEntryWriter symbol_writer(writer, artifacts, class_unload);</span>
<span class="line-removed"> 806   artifacts-&gt;iterate_symbols(symbol_writer);</span>
<span class="line-removed"> 807   CStringEntryWriter cstring_writer(writer, artifacts, class_unload, true); // skip header</span>
<span class="line-removed"> 808   artifacts-&gt;iterate_cstrings(cstring_writer);</span>
<span class="line-removed"> 809   symbol_writer.add(cstring_writer.count());</span>
<span class="line-removed"> 810 }</span>
 811 
<span class="line-modified"> 812 bool JfrTypeSet::_class_unload = false;</span>
<span class="line-modified"> 813 JfrArtifactSet* JfrTypeSet::_artifacts = NULL;</span>
<span class="line-modified"> 814 JfrArtifactClosure* JfrTypeSet::_subsystem_callback = NULL;</span>


 815 
<span class="line-modified"> 816 void JfrTypeSet::write_symbol_constants(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer) {</span>
<span class="line-modified"> 817   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 818   assert(_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);</span>
<span class="line-modified"> 819   write_symbols(writer, leakp_writer, _artifacts, _class_unload);</span>
<span class="line-modified"> 820 }</span>







 821 
<span class="line-modified"> 822 void JfrTypeSet::do_unloaded_klass(Klass* klass) {</span>
<span class="line-modified"> 823   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 824   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 825   if (IS_JDK_JFR_EVENT_SUBKLASS(klass)) {</span>
<span class="line-modified"> 826     JfrEventClasses::increment_unloaded_event_class();</span>
<span class="line-modified"> 827   }</span>
<span class="line-modified"> 828   if (USED_THIS_EPOCH(klass)) { // includes leakp subset</span>
<span class="line-modified"> 829     _subsystem_callback-&gt;do_artifact(klass);</span>
<span class="line-modified"> 830     return;</span>
<span class="line-removed"> 831   }</span>
<span class="line-removed"> 832   if (klass-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass()) || klass == SystemDictionary::Object_klass()) {</span>
<span class="line-removed"> 833     SET_LEAKP_USED_THIS_EPOCH(klass); // tag leakp &quot;safe byte&quot; for subset inclusion</span>
<span class="line-removed"> 834     _subsystem_callback-&gt;do_artifact(klass);</span>
 835   }

 836 }
 837 
<span class="line-modified"> 838 void JfrTypeSet::do_klass(Klass* klass) {</span>
<span class="line-modified"> 839   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 840   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 841   if (USED_PREV_EPOCH(klass)) { // includes leakp subset</span>
<span class="line-modified"> 842     _subsystem_callback-&gt;do_artifact(klass);</span>
<span class="line-removed"> 843     return;</span>
<span class="line-removed"> 844   }</span>
<span class="line-removed"> 845   if (klass-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass()) || klass == SystemDictionary::Object_klass()) {</span>
<span class="line-removed"> 846     SET_LEAKP_USED_PREV_EPOCH(klass); // tag leakp &quot;safe byte&quot; for subset inclusion</span>
<span class="line-removed"> 847     _subsystem_callback-&gt;do_artifact(klass);</span>
<span class="line-removed"> 848   }</span>
 849 }
 850 
<span class="line-modified"> 851 void JfrTypeSet::do_klasses() {</span>
<span class="line-modified"> 852   if (_class_unload) {</span>
<span class="line-modified"> 853     ClassLoaderDataGraph::classes_unloading_do(&amp;do_unloaded_klass);</span>
<span class="line-modified"> 854     return;</span>
<span class="line-modified"> 855   }</span>
<span class="line-removed"> 856   ClassLoaderDataGraph::classes_do(&amp;do_klass);</span>
 857 }
 858 
<span class="line-modified"> 859 void JfrTypeSet::do_unloaded_package(PackageEntry* entry) {</span>

 860   assert(entry != NULL, &quot;invariant&quot;);
<span class="line-modified"> 861   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 862   if (ANY_USED_THIS_EPOCH(entry)) { // includes leakp subset</span>
<span class="line-modified"> 863     _subsystem_callback-&gt;do_artifact(entry);</span>
<span class="line-modified"> 864   }</span>
 865 }
 866 
<span class="line-modified"> 867 void JfrTypeSet::do_package(PackageEntry* entry) {</span>
<span class="line-modified"> 868   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 869   if (ANY_USED_PREV_EPOCH(entry)) { // includes leakp subset</span>
<span class="line-modified"> 870     _subsystem_callback-&gt;do_artifact(entry);</span>
<span class="line-modified"> 871   }</span>
 872 }
 873 
<span class="line-modified"> 874 void JfrTypeSet::do_packages() {</span>
<span class="line-modified"> 875   if (_class_unload) {</span>
<span class="line-modified"> 876     ClassLoaderDataGraph::packages_unloading_do(&amp;do_unloaded_package);</span>
<span class="line-modified"> 877     return;</span>
<span class="line-removed"> 878   }</span>
<span class="line-removed"> 879   ClassLoaderDataGraph::packages_do(&amp;do_package);</span>
 880 }
<span class="line-modified"> 881 void JfrTypeSet::do_unloaded_module(ModuleEntry* entry) {</span>


 882   assert(entry != NULL, &quot;invariant&quot;);
<span class="line-modified"> 883   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 884   if (ANY_USED_THIS_EPOCH(entry)) { // includes leakp subset</span>
<span class="line-modified"> 885     _subsystem_callback-&gt;do_artifact(entry);</span>
<span class="line-removed"> 886   }</span>
 887 }
 888 
<span class="line-modified"> 889 void JfrTypeSet::do_module(ModuleEntry* entry) {</span>
<span class="line-modified"> 890   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 891   if (ANY_USED_PREV_EPOCH(entry)) { // includes leakp subset</span>
<span class="line-modified"> 892     _subsystem_callback-&gt;do_artifact(entry);</span>
<span class="line-modified"> 893   }</span>
 894 }
 895 
<span class="line-modified"> 896 void JfrTypeSet::do_modules() {</span>
<span class="line-modified"> 897   if (_class_unload) {</span>
<span class="line-modified"> 898     ClassLoaderDataGraph::modules_unloading_do(&amp;do_unloaded_module);</span>






































 899     return;
 900   }
<span class="line-modified"> 901   ClassLoaderDataGraph::modules_do(&amp;do_module);</span>





 902 }
 903 
<span class="line-modified"> 904 void JfrTypeSet::do_unloaded_class_loader_data(ClassLoaderData* cld) {</span>
<span class="line-modified"> 905   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 906   if (ANY_USED_THIS_EPOCH(cld)) { // includes leakp subset</span>
<span class="line-removed"> 907     _subsystem_callback-&gt;do_artifact(cld);</span>
<span class="line-removed"> 908   }</span>
<span class="line-removed"> 909 }</span>
 910 
<span class="line-modified"> 911 void JfrTypeSet::do_class_loader_data(ClassLoaderData* cld) {</span>
<span class="line-removed"> 912   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 913   if (ANY_USED_PREV_EPOCH(cld)) { // includes leakp subset</span>
<span class="line-removed"> 914     _subsystem_callback-&gt;do_artifact(cld);</span>
<span class="line-removed"> 915   }</span>
<span class="line-removed"> 916 }</span>
<span class="line-removed"> 917 </span>
<span class="line-removed"> 918 class CLDCallback : public CLDClosure {</span>
<span class="line-removed"> 919  private:</span>
<span class="line-removed"> 920   bool _class_unload;</span>
<span class="line-removed"> 921  public:</span>
<span class="line-removed"> 922   CLDCallback(bool class_unload) : _class_unload(class_unload) {}</span>
<span class="line-removed"> 923   void do_cld(ClassLoaderData* cld) {</span>
<span class="line-removed"> 924      assert(cld != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 925     if (cld-&gt;is_unsafe_anonymous()) {</span>
<span class="line-removed"> 926       return;</span>
<span class="line-removed"> 927     }</span>
<span class="line-removed"> 928     if (_class_unload) {</span>
<span class="line-removed"> 929       JfrTypeSet::do_unloaded_class_loader_data(cld);</span>
<span class="line-removed"> 930       return;</span>
<span class="line-removed"> 931     }</span>
<span class="line-removed"> 932     JfrTypeSet::do_class_loader_data(cld);</span>
<span class="line-removed"> 933   }</span>
<span class="line-removed"> 934 };</span>
 935 
<span class="line-modified"> 936 void JfrTypeSet::do_class_loaders() {</span>
<span class="line-modified"> 937   CLDCallback cld_cb(_class_unload);</span>
<span class="line-modified"> 938   if (_class_unload) {</span>
<span class="line-removed"> 939     ClassLoaderDataGraph::cld_unloading_do(&amp;cld_cb);</span>
<span class="line-removed"> 940     return;</span>
<span class="line-removed"> 941   }</span>
<span class="line-removed"> 942   ClassLoaderDataGraph::loaded_cld_do(&amp;cld_cb);</span>
 943 }
 944 
<span class="line-modified"> 945 static void clear_artifacts(JfrArtifactSet* artifacts,</span>
<span class="line-modified"> 946                             bool class_unload) {</span>
<span class="line-modified"> 947   assert(artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 948   assert(artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);</span>
<span class="line-modified"> 949 </span>
<span class="line-modified"> 950   // untag</span>
<span class="line-modified"> 951   ClearKlassAndMethods clear(class_unload);</span>
<span class="line-modified"> 952   artifacts-&gt;iterate_klasses(clear);</span>
<span class="line-modified"> 953   artifacts-&gt;clear();</span>
 954 }
 955 
<span class="line-modified"> 956 /**</span>
<span class="line-modified"> 957  * Write all &quot;tagged&quot; (in-use) constant artifacts and their dependencies.</span>
<span class="line-modified"> 958  */</span>
<span class="line-removed"> 959 void JfrTypeSet::serialize(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer, bool class_unload) {</span>
<span class="line-removed"> 960   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 961   ResourceMark rm;</span>
<span class="line-removed"> 962   // initialization begin</span>
 963   _class_unload = class_unload;
<span class="line-modified"> 964   ++checkpoint_id;</span>
 965   if (_artifacts == NULL) {
 966     _artifacts = new JfrArtifactSet(class_unload);
<span class="line-removed"> 967     _subsystem_callback = NULL;</span>
 968   } else {
<span class="line-modified"> 969     _artifacts-&gt;initialize(class_unload);</span>
<span class="line-removed"> 970     _subsystem_callback = NULL;</span>
 971   }

 972   assert(_artifacts != NULL, &quot;invariant&quot;);
 973   assert(!_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);
<span class="line-modified"> 974   assert(_subsystem_callback == NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 975   // initialization complete</span>
 976 







 977   // write order is important because an individual write step
 978   // might tag an artifact to be written in a subsequent step
<span class="line-modified"> 979   write_klass_constants(writer, leakp_writer);</span>
<span class="line-modified"> 980   if (_artifacts-&gt;has_klass_entries()) {</span>
<span class="line-removed"> 981     write_package_constants(writer, leakp_writer);</span>
<span class="line-removed"> 982     write_module_constants(writer, leakp_writer);</span>
<span class="line-removed"> 983     write_class_loader_constants(writer, leakp_writer);</span>
<span class="line-removed"> 984     write_method_constants(writer, leakp_writer);</span>
<span class="line-removed"> 985     write_symbol_constants(writer, leakp_writer);</span>
<span class="line-removed"> 986     clear_artifacts(_artifacts, class_unload);</span>
 987   }



















 988 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  27 #include &quot;classfile/javaClasses.inline.hpp&quot;
  28 #include &quot;classfile/moduleEntry.hpp&quot;
  29 #include &quot;classfile/packageEntry.hpp&quot;
  30 #include &quot;classfile/symbolTable.hpp&quot;

  31 #include &quot;jfr/jfr.hpp&quot;
  32 #include &quot;jfr/jni/jfrGetAllEventClasses.hpp&quot;
<span class="line-modified">  33 #include &quot;jfr/leakprofiler/checkpoint/objectSampleCheckpoint.hpp&quot;</span>
  34 #include &quot;jfr/recorder/checkpoint/types/jfrTypeSet.hpp&quot;
  35 #include &quot;jfr/recorder/checkpoint/types/jfrTypeSetUtils.hpp&quot;

  36 #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceId.inline.hpp&quot;

  37 #include &quot;jfr/utilities/jfrHashtable.hpp&quot;
  38 #include &quot;jfr/utilities/jfrTypes.hpp&quot;
<span class="line-added">  39 #include &quot;jfr/writers/jfrTypeWriterHost.hpp&quot;</span>
  40 #include &quot;memory/iterator.hpp&quot;
  41 #include &quot;memory/resourceArea.hpp&quot;
  42 #include &quot;oops/instanceKlass.hpp&quot;
  43 #include &quot;oops/objArrayKlass.hpp&quot;
  44 #include &quot;oops/oop.inline.hpp&quot;

  45 #include &quot;utilities/accessFlags.hpp&quot;
<span class="line-modified">  46 #include &quot;utilities/bitMap.inline.hpp&quot;</span>






  47 
  48 typedef const Klass* KlassPtr;
  49 typedef const PackageEntry* PkgPtr;
  50 typedef const ModuleEntry* ModPtr;
  51 typedef const ClassLoaderData* CldPtr;
  52 typedef const Method* MethodPtr;
  53 typedef const Symbol* SymbolPtr;
  54 typedef const JfrSymbolId::SymbolEntry* SymbolEntryPtr;
  55 typedef const JfrSymbolId::CStringEntry* CStringEntryPtr;
  56 
<span class="line-modified">  57 static JfrCheckpointWriter* _writer = NULL;</span>
<span class="line-modified">  58 static JfrCheckpointWriter* _leakp_writer = NULL;</span>
<span class="line-modified">  59 static JfrArtifactSet* _artifacts = NULL;</span>
<span class="line-modified">  60 static JfrArtifactClosure* _subsystem_callback = NULL;</span>
<span class="line-added">  61 static bool _class_unload = false;</span>
<span class="line-added">  62 static bool _flushpoint = false;</span>
<span class="line-added">  63 </span>
<span class="line-added">  64 // incremented on each rotation</span>
<span class="line-added">  65 static u8 checkpoint_id = 1;</span>
<span class="line-added">  66 </span>
<span class="line-added">  67 // creates a unique id by combining a checkpoint relative symbol id (2^24)</span>
<span class="line-added">  68 // with the current checkpoint id (2^40)</span>
<span class="line-added">  69 #define CREATE_SYMBOL_ID(sym_id) (((u8)((checkpoint_id &lt;&lt; 24) | sym_id)))</span>
<span class="line-added">  70 </span>
<span class="line-added">  71 static traceid create_symbol_id(traceid artifact_id) {</span>
<span class="line-added">  72   return artifact_id != 0 ? CREATE_SYMBOL_ID(artifact_id) : 0;</span>
  73 }
  74 
<span class="line-modified">  75 static bool current_epoch() {</span>
<span class="line-modified">  76   return _class_unload || _flushpoint;</span>


  77 }
  78 
<span class="line-modified">  79 static bool previous_epoch() {</span>
<span class="line-modified">  80   return !current_epoch();</span>

  81 }
  82 
<span class="line-modified">  83 static bool is_complete() {</span>
<span class="line-modified">  84   return !_artifacts-&gt;has_klass_entries() &amp;&amp; current_epoch();</span>













  85 }
  86 
<span class="line-modified">  87 static traceid mark_symbol(KlassPtr klass, bool leakp) {</span>
<span class="line-modified">  88   return klass != NULL ? create_symbol_id(_artifacts-&gt;mark(klass, leakp)) : 0;</span>
<span class="line-modified">  89 }</span>














  90 
<span class="line-modified">  91 static traceid mark_symbol(Symbol* symbol, bool leakp) {</span>
<span class="line-modified">  92   return symbol != NULL ? create_symbol_id(_artifacts-&gt;mark(symbol, leakp)) : 0;</span>
<span class="line-modified">  93 }</span>




  94 
<span class="line-modified">  95 static traceid get_bootstrap_name(bool leakp) {</span>
<span class="line-modified">  96   return create_symbol_id(_artifacts-&gt;bootstrap_name(leakp));</span>






















  97 }
  98 
<span class="line-modified">  99 template &lt;typename T&gt;</span>
<span class="line-modified"> 100 static traceid artifact_id(const T* ptr) {</span>
<span class="line-modified"> 101   assert(ptr != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 102   return TRACE_ID(ptr);</span>
<span class="line-modified"> 103 }</span>
 104 
<span class="line-modified"> 105 static traceid package_id(KlassPtr klass, bool leakp) {</span>









 106   assert(klass != NULL, &quot;invariant&quot;);
<span class="line-modified"> 107   PkgPtr pkg_entry = klass-&gt;package();</span>
<span class="line-modified"> 108   if (pkg_entry == NULL) {</span>
<span class="line-modified"> 109     return 0;</span>
<span class="line-modified"> 110   }</span>
<span class="line-modified"> 111   if (leakp) {</span>
<span class="line-modified"> 112     SET_LEAKP(pkg_entry);</span>
<span class="line-modified"> 113   }</span>
<span class="line-modified"> 114   // package implicitly tagged already</span>
<span class="line-added"> 115   return artifact_id(pkg_entry);</span>
 116 }
 117 
<span class="line-modified"> 118 static traceid module_id(PkgPtr pkg, bool leakp) {</span>
<span class="line-modified"> 119   assert(pkg != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 120   ModPtr module_entry = pkg-&gt;module();</span>
<span class="line-modified"> 121   if (module_entry == NULL) {</span>
<span class="line-modified"> 122     return 0;</span>
<span class="line-modified"> 123   }</span>
<span class="line-modified"> 124   if (leakp) {</span>
<span class="line-modified"> 125     SET_LEAKP(module_entry);</span>
<span class="line-modified"> 126   } else {</span>
<span class="line-modified"> 127     SET_TRANSIENT(module_entry);</span>
<span class="line-modified"> 128   }</span>
<span class="line-modified"> 129   return artifact_id(module_entry);</span>




 130 }
 131 
<span class="line-modified"> 132 static traceid method_id(KlassPtr klass, MethodPtr method) {</span>
<span class="line-modified"> 133   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 134   assert(method != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 135   return METHOD_ID(klass, method);</span>



















 136 }
 137 
<span class="line-modified"> 138 static traceid cld_id(CldPtr cld, bool leakp) {</span>
<span class="line-modified"> 139   assert(cld != NULL, &quot;invariant&quot;);</span>









 140   assert(!cld-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);
<span class="line-modified"> 141   if (leakp) {</span>
<span class="line-modified"> 142     SET_LEAKP(cld);</span>






 143   } else {
<span class="line-modified"> 144     SET_TRANSIENT(cld);</span>





 145   }
<span class="line-modified"> 146   return artifact_id(cld);</span>
 147 }
 148 
<span class="line-modified"> 149 template &lt;typename T&gt;</span>
<span class="line-modified"> 150 static s4 get_flags(const T* ptr) {</span>
<span class="line-modified"> 151   assert(ptr != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 152   return ptr-&gt;access_flags().get_flags();</span>
<span class="line-modified"> 153 }</span>




 154 
<span class="line-modified"> 155 static bool is_unsafe_anonymous(const Klass* klass) {</span>
<span class="line-modified"> 156   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 157   return klass-&gt;is_instance_klass() &amp;&amp; ((const InstanceKlass*)klass)-&gt;is_unsafe_anonymous();</span>





 158 }
 159 
<span class="line-modified"> 160 static ClassLoaderData* get_cld(const Klass* klass) {</span>
<span class="line-modified"> 161   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 162   return is_unsafe_anonymous(klass) ?</span>
<span class="line-added"> 163     InstanceKlass::cast(klass)-&gt;unsafe_anonymous_host()-&gt;class_loader_data() : klass-&gt;class_loader_data();</span>
 164 }
 165 
<span class="line-modified"> 166 template &lt;typename T&gt;</span>
<span class="line-modified"> 167 static void set_serialized(const T* ptr) {</span>
<span class="line-added"> 168   assert(ptr != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 169   SET_SERIALIZED(ptr);</span>
<span class="line-added"> 170   assert(IS_SERIALIZED(ptr), &quot;invariant&quot;);</span>
<span class="line-added"> 171   CLEAR_THIS_EPOCH_CLEARED_BIT(ptr);</span>
<span class="line-added"> 172 }</span>
 173 
<span class="line-modified"> 174 /*</span>
<span class="line-added"> 175  * In C++03, functions used as template parameters must have external linkage;</span>
<span class="line-added"> 176  * this restriction was removed in C++11. Change back to &quot;static&quot; and</span>
<span class="line-added"> 177  * rename functions when C++11 becomes available.</span>
<span class="line-added"> 178  *</span>
<span class="line-added"> 179  * The weird naming is an effort to decrease the risk of name clashes.</span>
<span class="line-added"> 180  */</span>
 181 
<span class="line-modified"> 182 static int write_klass(JfrCheckpointWriter* writer, KlassPtr klass, bool leakp) {</span>
 183   assert(writer != NULL, &quot;invariant&quot;);
<span class="line-modified"> 184   assert(_artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 185   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 186   traceid pkg_id = 0;</span>
<span class="line-added"> 187   KlassPtr theklass = klass;</span>
<span class="line-added"> 188   if (theklass-&gt;is_objArray_klass()) {</span>
<span class="line-added"> 189     const ObjArrayKlass* obj_arr_klass = ObjArrayKlass::cast(klass);</span>
<span class="line-added"> 190     theklass = obj_arr_klass-&gt;bottom_klass();</span>
<span class="line-added"> 191   }</span>
<span class="line-added"> 192   if (theklass-&gt;is_instance_klass()) {</span>
<span class="line-added"> 193     pkg_id = package_id(theklass, leakp);</span>
<span class="line-added"> 194   } else {</span>
<span class="line-added"> 195     assert(theklass-&gt;is_typeArray_klass(), &quot;invariant&quot;);</span>
<span class="line-added"> 196   }</span>
<span class="line-added"> 197   writer-&gt;write(artifact_id(klass));</span>
<span class="line-added"> 198   writer-&gt;write(cld_id(get_cld(klass), leakp));</span>
<span class="line-added"> 199   writer-&gt;write(mark_symbol(klass, leakp));</span>
<span class="line-added"> 200   writer-&gt;write(pkg_id);</span>
<span class="line-added"> 201   writer-&gt;write(get_flags(klass));</span>
 202   return 1;
 203 }
 204 
<span class="line-modified"> 205 int write__klass(JfrCheckpointWriter* writer, const void* k) {</span>
<span class="line-modified"> 206   assert(k != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 207   KlassPtr klass = (KlassPtr)k;</span>
<span class="line-added"> 208   set_serialized(klass);</span>
<span class="line-added"> 209   return write_klass(writer, klass, false);</span>
 210 }
 211 
<span class="line-modified"> 212 int write__klass__leakp(JfrCheckpointWriter* writer, const void* k) {</span>





 213   assert(k != NULL, &quot;invariant&quot;);
<span class="line-modified"> 214   KlassPtr klass = (KlassPtr)k;</span>
<span class="line-modified"> 215   return write_klass(writer, klass, true);</span>








 216 }
 217 
<span class="line-modified"> 218 static bool is_implied(const Klass* klass) {</span>
<span class="line-modified"> 219   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 220   return klass-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass()) || klass == SystemDictionary::Object_klass();</span>
 221 }
 222 
<span class="line-modified"> 223 static void do_implied(Klass* klass) {</span>
<span class="line-modified"> 224   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 225   if (is_implied(klass)) {</span>
<span class="line-modified"> 226     if (_leakp_writer != NULL) {</span>
<span class="line-modified"> 227       SET_LEAKP(klass);</span>











































 228     }
<span class="line-modified"> 229     _subsystem_callback-&gt;do_artifact(klass);</span>
 230   }
















 231 }
 232 
<span class="line-modified"> 233 static void do_unloaded_klass(Klass* klass) {</span>
<span class="line-modified"> 234   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 235   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 236   if (IS_JDK_JFR_EVENT_SUBKLASS(klass)) {</span>
<span class="line-modified"> 237     JfrEventClasses::increment_unloaded_event_class();</span>



























 238   }
<span class="line-modified"> 239   if (USED_THIS_EPOCH(klass)) {</span>
<span class="line-modified"> 240     ObjectSampleCheckpoint::on_klass_unload(klass);</span>
<span class="line-modified"> 241     _subsystem_callback-&gt;do_artifact(klass);</span>
<span class="line-modified"> 242     return;</span>



 243   }
<span class="line-modified"> 244   do_implied(klass);</span>
 245 }
 246 
<span class="line-modified"> 247 static void do_klass(Klass* klass) {</span>
<span class="line-modified"> 248   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 249   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 250   if (_flushpoint) {</span>
<span class="line-modified"> 251     if (USED_THIS_EPOCH(klass)) {</span>
<span class="line-modified"> 252       _subsystem_callback-&gt;do_artifact(klass);</span>
<span class="line-modified"> 253       return;</span>









 254     }
 255   } else {
<span class="line-modified"> 256     if (USED_PREV_EPOCH(klass)) {</span>
<span class="line-modified"> 257       _subsystem_callback-&gt;do_artifact(klass);</span>
<span class="line-modified"> 258       return;</span>






























 259     }
 260   }
<span class="line-modified"> 261   do_implied(klass);</span>
 262 }
 263 
<span class="line-modified"> 264 static void do_klasses() {</span>
<span class="line-modified"> 265   if (_class_unload) {</span>
<span class="line-added"> 266     ClassLoaderDataGraph::classes_unloading_do(&amp;do_unloaded_klass);</span>
<span class="line-added"> 267     return;</span>
<span class="line-added"> 268   }</span>
<span class="line-added"> 269   ClassLoaderDataGraph::classes_do(&amp;do_klass);</span>
<span class="line-added"> 270 }</span>
 271 
<span class="line-modified"> 272 typedef SerializePredicate&lt;KlassPtr&gt; KlassPredicate;</span>
<span class="line-modified"> 273 typedef JfrPredicatedTypeWriterImplHost&lt;KlassPtr, KlassPredicate, write__klass&gt; KlassWriterImpl;</span>
<span class="line-modified"> 274 typedef JfrTypeWriterHost&lt;KlassWriterImpl, TYPE_CLASS&gt; KlassWriter;</span>
<span class="line-modified"> 275 typedef CompositeFunctor&lt;KlassPtr, KlassWriter, KlassArtifactRegistrator&gt; KlassWriterRegistration;</span>
<span class="line-modified"> 276 typedef JfrArtifactCallbackHost&lt;KlassPtr, KlassWriterRegistration&gt; KlassCallback;</span>
 277 
<span class="line-modified"> 278 template &lt;&gt;</span>
<span class="line-modified"> 279 class LeakPredicate&lt;const Klass*&gt; {</span>
<span class="line-modified"> 280 public:</span>
<span class="line-modified"> 281   LeakPredicate(bool class_unload) {}</span>
<span class="line-modified"> 282   bool operator()(const Klass* klass) {</span>
<span class="line-modified"> 283     assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 284     return IS_LEAKP(klass) || is_implied(klass);</span>








 285   }
 286 };
 287 
<span class="line-modified"> 288 typedef LeakPredicate&lt;KlassPtr&gt; LeakKlassPredicate;</span>
<span class="line-modified"> 289 typedef JfrPredicatedTypeWriterImplHost&lt;KlassPtr, LeakKlassPredicate, write__klass__leakp&gt; LeakKlassWriterImpl;</span>
<span class="line-modified"> 290 typedef JfrTypeWriterHost&lt;LeakKlassWriterImpl, TYPE_CLASS&gt; LeakKlassWriter;</span>












 291 
<span class="line-modified"> 292 typedef CompositeFunctor&lt;KlassPtr, LeakKlassWriter, KlassWriter&gt; CompositeKlassWriter;</span>
<span class="line-added"> 293 typedef CompositeFunctor&lt;KlassPtr, CompositeKlassWriter, KlassArtifactRegistrator&gt; CompositeKlassWriterRegistration;</span>
 294 typedef JfrArtifactCallbackHost&lt;KlassPtr, CompositeKlassWriterRegistration&gt; CompositeKlassCallback;
 295 
<span class="line-modified"> 296 static bool write_klasses() {</span>










 297   assert(!_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);
<span class="line-added"> 298   assert(_writer != NULL, &quot;invariant&quot;);</span>
 299   KlassArtifactRegistrator reg(_artifacts);
<span class="line-modified"> 300   KlassWriter kw(_writer, _class_unload);</span>
 301   KlassWriterRegistration kwr(&amp;kw, &amp;reg);
<span class="line-modified"> 302   if (_leakp_writer == NULL) {</span>
 303     KlassCallback callback(&amp;kwr);
 304     _subsystem_callback = &amp;callback;
 305     do_klasses();
<span class="line-added"> 306   } else {</span>
<span class="line-added"> 307     LeakKlassWriter lkw(_leakp_writer, _class_unload);</span>
<span class="line-added"> 308     CompositeKlassWriter ckw(&amp;lkw, &amp;kw);</span>
<span class="line-added"> 309     CompositeKlassWriterRegistration ckwr(&amp;ckw, &amp;reg);</span>
<span class="line-added"> 310     CompositeKlassCallback callback(&amp;ckwr);</span>
<span class="line-added"> 311     _subsystem_callback = &amp;callback;</span>
<span class="line-added"> 312     do_klasses();</span>
<span class="line-added"> 313   }</span>
<span class="line-added"> 314   if (is_complete()) {</span>
<span class="line-added"> 315     return false;</span>
<span class="line-added"> 316   }</span>
<span class="line-added"> 317   _artifacts-&gt;tally(kw);</span>
<span class="line-added"> 318   return true;</span>
<span class="line-added"> 319 }</span>
<span class="line-added"> 320 </span>
<span class="line-added"> 321 template &lt;typename T&gt;</span>
<span class="line-added"> 322 static void do_previous_epoch_artifact(JfrArtifactClosure* callback, T* value) {</span>
<span class="line-added"> 323   assert(callback != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 324   assert(value != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 325   if (USED_PREV_EPOCH(value)) {</span>
<span class="line-added"> 326     callback-&gt;do_artifact(value);</span>
<span class="line-added"> 327     assert(IS_NOT_SERIALIZED(value), &quot;invariant&quot;);</span>
 328     return;
 329   }
<span class="line-modified"> 330   if (IS_SERIALIZED(value)) {</span>
<span class="line-modified"> 331     CLEAR_SERIALIZED(value);</span>
<span class="line-modified"> 332   }</span>
<span class="line-modified"> 333   assert(IS_NOT_SERIALIZED(value), &quot;invariant&quot;);</span>
<span class="line-modified"> 334 }</span>
<span class="line-modified"> 335 </span>
<span class="line-added"> 336 typedef JfrArtifactCallbackHost&lt;KlassPtr, KlassArtifactRegistrator&gt; RegistrationCallback;</span>
<span class="line-added"> 337 </span>
<span class="line-added"> 338 static void register_klass(Klass* klass) {</span>
<span class="line-added"> 339   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 340   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 341   do_previous_epoch_artifact(_subsystem_callback, klass);</span>
<span class="line-added"> 342 }</span>
<span class="line-added"> 343 </span>
<span class="line-added"> 344 static void do_register_klasses() {</span>
<span class="line-added"> 345   ClassLoaderDataGraph::classes_do(&amp;register_klass);</span>
<span class="line-added"> 346 }</span>
<span class="line-added"> 347 </span>
<span class="line-added"> 348 static void register_klasses() {</span>
<span class="line-added"> 349   assert(!_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);</span>
<span class="line-added"> 350   KlassArtifactRegistrator reg(_artifacts);</span>
<span class="line-added"> 351   RegistrationCallback callback(&amp;reg);</span>
 352   _subsystem_callback = &amp;callback;
<span class="line-modified"> 353   do_register_klasses();</span>
<span class="line-added"> 354 }</span>
<span class="line-added"> 355 </span>
<span class="line-added"> 356 static int write_package(JfrCheckpointWriter* writer, PkgPtr pkg, bool leakp) {</span>
<span class="line-added"> 357   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 358   assert(_artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 359   assert(pkg != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 360   writer-&gt;write(artifact_id(pkg));</span>
<span class="line-added"> 361   writer-&gt;write(mark_symbol(pkg-&gt;name(), leakp));</span>
<span class="line-added"> 362   writer-&gt;write(module_id(pkg, leakp));</span>
<span class="line-added"> 363   writer-&gt;write((bool)pkg-&gt;is_exported());</span>
<span class="line-added"> 364   return 1;</span>
<span class="line-added"> 365 }</span>
<span class="line-added"> 366 </span>
<span class="line-added"> 367 int write__package(JfrCheckpointWriter* writer, const void* p) {</span>
<span class="line-added"> 368   assert(p != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 369   PkgPtr pkg = (PkgPtr)p;</span>
<span class="line-added"> 370   set_serialized(pkg);</span>
<span class="line-added"> 371   return write_package(writer, pkg, false);</span>
 372 }
 373 
<span class="line-modified"> 374 int write__package__leakp(JfrCheckpointWriter* writer, const void* p) {</span>
<span class="line-modified"> 375   assert(p != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 376   PkgPtr pkg = (PkgPtr)p;</span>
<span class="line-added"> 377   CLEAR_LEAKP(pkg);</span>
<span class="line-added"> 378   return write_package(writer, pkg, true);</span>
<span class="line-added"> 379 }</span>
 380 
<span class="line-modified"> 381 static void do_package(PackageEntry* entry) {</span>
<span class="line-modified"> 382   do_previous_epoch_artifact(_subsystem_callback, entry);</span>
<span class="line-modified"> 383 }</span>
 384 
<span class="line-modified"> 385 static void do_packages() {</span>
<span class="line-modified"> 386   ClassLoaderDataGraph::packages_do(&amp;do_package);</span>
<span class="line-modified"> 387 }</span>
 388 
 389 class PackageFieldSelector {
 390  public:
 391   typedef PkgPtr TypePtr;
 392   static TypePtr select(KlassPtr klass) {
 393     assert(klass != NULL, &quot;invariant&quot;);
 394     return ((InstanceKlass*)klass)-&gt;package();
 395   }
 396 };
 397 
<span class="line-modified"> 398 typedef SerializePredicate&lt;PkgPtr&gt; PackagePredicate;</span>
<span class="line-modified"> 399 typedef JfrPredicatedTypeWriterImplHost&lt;PkgPtr, PackagePredicate, write__package&gt; PackageWriterImpl;</span>
<span class="line-added"> 400 typedef JfrTypeWriterHost&lt;PackageWriterImpl, TYPE_PACKAGE&gt; PackageWriter;</span>
<span class="line-added"> 401 typedef CompositeFunctor&lt;PkgPtr, PackageWriter, ClearArtifact&lt;PkgPtr&gt; &gt; PackageWriterWithClear;</span>
<span class="line-added"> 402 typedef KlassToFieldEnvelope&lt;PackageFieldSelector, PackageWriter&gt; KlassPackageWriter;</span>
<span class="line-added"> 403 typedef JfrArtifactCallbackHost&lt;PkgPtr, PackageWriterWithClear&gt; PackageCallback;</span>
 404 
<span class="line-modified"> 405 typedef LeakPredicate&lt;PkgPtr&gt; LeakPackagePredicate;</span>
<span class="line-modified"> 406 typedef JfrPredicatedTypeWriterImplHost&lt;PkgPtr, LeakPackagePredicate, write__package__leakp&gt; LeakPackageWriterImpl;</span>
<span class="line-added"> 407 typedef JfrTypeWriterHost&lt;LeakPackageWriterImpl, TYPE_PACKAGE&gt; LeakPackageWriter;</span>
 408 
<span class="line-modified"> 409 typedef CompositeFunctor&lt;PkgPtr, LeakPackageWriter, PackageWriter&gt; CompositePackageWriter;</span>
<span class="line-added"> 410 typedef KlassToFieldEnvelope&lt;PackageFieldSelector, CompositePackageWriter&gt; KlassCompositePackageWriter;</span>
<span class="line-added"> 411 typedef KlassToFieldEnvelope&lt;PackageFieldSelector, PackageWriterWithClear&gt; KlassPackageWriterWithClear;</span>
<span class="line-added"> 412 typedef CompositeFunctor&lt;PkgPtr, CompositePackageWriter, ClearArtifact&lt;PkgPtr&gt; &gt; CompositePackageWriterWithClear;</span>
 413 typedef JfrArtifactCallbackHost&lt;PkgPtr, CompositePackageWriterWithClear&gt; CompositePackageCallback;
 414 
<span class="line-modified"> 415 static void write_packages() {</span>
<span class="line-modified"> 416   assert(_writer != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 417   PackageWriter pw(_writer, _class_unload);</span>
<span class="line-modified"> 418   KlassPackageWriter kpw(&amp;pw);</span>
<span class="line-modified"> 419   if (current_epoch()) {</span>
<span class="line-modified"> 420     _artifacts-&gt;iterate_klasses(kpw);</span>
<span class="line-modified"> 421     _artifacts-&gt;tally(pw);</span>
<span class="line-modified"> 422     return;</span>
<span class="line-modified"> 423   }</span>
<span class="line-modified"> 424   assert(previous_epoch(), &quot;invariant&quot;);</span>
<span class="line-modified"> 425   if (_leakp_writer == NULL) {</span>
<span class="line-modified"> 426     _artifacts-&gt;iterate_klasses(kpw);</span>
<span class="line-modified"> 427     ClearArtifact&lt;PkgPtr&gt; clear;</span>
 428     PackageWriterWithClear pwwc(&amp;pw, &amp;clear);


 429     PackageCallback callback(&amp;pwwc);
 430     _subsystem_callback = &amp;callback;
 431     do_packages();
<span class="line-modified"> 432   } else {</span>
<span class="line-added"> 433     LeakPackageWriter lpw(_leakp_writer, _class_unload);</span>
<span class="line-added"> 434     CompositePackageWriter cpw(&amp;lpw, &amp;pw);</span>
<span class="line-added"> 435     KlassCompositePackageWriter kcpw(&amp;cpw);</span>
<span class="line-added"> 436     _artifacts-&gt;iterate_klasses(kcpw);</span>
<span class="line-added"> 437     ClearArtifact&lt;PkgPtr&gt; clear;</span>
<span class="line-added"> 438     CompositePackageWriterWithClear cpwwc(&amp;cpw, &amp;clear);</span>
<span class="line-added"> 439     CompositePackageCallback callback(&amp;cpwwc);</span>
<span class="line-added"> 440     _subsystem_callback = &amp;callback;</span>
<span class="line-added"> 441     do_packages();</span>
 442   }
<span class="line-modified"> 443   _artifacts-&gt;tally(pw);</span>
<span class="line-modified"> 444 }</span>
<span class="line-modified"> 445 </span>
<span class="line-modified"> 446 typedef JfrArtifactCallbackHost&lt;PkgPtr, ClearArtifact&lt;PkgPtr&gt; &gt; ClearPackageCallback;</span>
<span class="line-modified"> 447 </span>
<span class="line-modified"> 448 static void clear_packages() {</span>
<span class="line-added"> 449   ClearArtifact&lt;PkgPtr&gt; clear;</span>
<span class="line-added"> 450   ClearPackageCallback callback(&amp;clear);</span>
 451   _subsystem_callback = &amp;callback;
 452   do_packages();
 453 }
 454 
<span class="line-modified"> 455 static int write_module(JfrCheckpointWriter* writer, ModPtr mod, bool leakp) {</span>
<span class="line-modified"> 456   assert(mod != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 457   assert(_artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 458   writer-&gt;write(artifact_id(mod));</span>
<span class="line-added"> 459   writer-&gt;write(mark_symbol(mod-&gt;name(), leakp));</span>
<span class="line-added"> 460   writer-&gt;write(mark_symbol(mod-&gt;version(), leakp));</span>
<span class="line-added"> 461   writer-&gt;write(mark_symbol(mod-&gt;location(), leakp));</span>
<span class="line-added"> 462   writer-&gt;write(cld_id(mod-&gt;loader_data(), leakp));</span>
<span class="line-added"> 463   return 1;</span>
<span class="line-added"> 464 }</span>
 465 
<span class="line-modified"> 466 int write__module(JfrCheckpointWriter* writer, const void* m) {</span>
<span class="line-modified"> 467   assert(m != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 468   ModPtr mod = (ModPtr)m;</span>
<span class="line-added"> 469   set_serialized(mod);</span>
<span class="line-added"> 470   return write_module(writer, mod, false);</span>
<span class="line-added"> 471 }</span>
 472 
<span class="line-modified"> 473 int write__module__leakp(JfrCheckpointWriter* writer, const void* m) {</span>
<span class="line-modified"> 474   assert(m != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 475   ModPtr mod = (ModPtr)m;</span>
<span class="line-added"> 476   CLEAR_LEAKP(mod);</span>
<span class="line-added"> 477   return write_module(writer, mod, true);</span>
<span class="line-added"> 478 }</span>
 479 
<span class="line-modified"> 480 static void do_module(ModuleEntry* entry) {</span>
<span class="line-modified"> 481   do_previous_epoch_artifact(_subsystem_callback, entry);</span>
<span class="line-added"> 482 }</span>
<span class="line-added"> 483 </span>
<span class="line-added"> 484 static void do_modules() {</span>
<span class="line-added"> 485   ClassLoaderDataGraph::modules_do(&amp;do_module);</span>
<span class="line-added"> 486 }</span>
 487 
 488 class ModuleFieldSelector {
 489  public:
 490   typedef ModPtr TypePtr;
 491   static TypePtr select(KlassPtr klass) {
 492     assert(klass != NULL, &quot;invariant&quot;);
 493     PkgPtr pkg = klass-&gt;package();
 494     return pkg != NULL ? pkg-&gt;module() : NULL;
 495   }
 496 };
 497 
<span class="line-modified"> 498 typedef SerializePredicate&lt;ModPtr&gt; ModulePredicate;</span>
<span class="line-modified"> 499 typedef JfrPredicatedTypeWriterImplHost&lt;ModPtr, ModulePredicate, write__module&gt; ModuleWriterImpl;</span>
<span class="line-added"> 500 typedef JfrTypeWriterHost&lt;ModuleWriterImpl, TYPE_MODULE&gt; ModuleWriter;</span>
<span class="line-added"> 501 typedef CompositeFunctor&lt;ModPtr, ModuleWriter, ClearArtifact&lt;ModPtr&gt; &gt; ModuleWriterWithClear;</span>
<span class="line-added"> 502 typedef JfrArtifactCallbackHost&lt;ModPtr, ModuleWriterWithClear&gt; ModuleCallback;</span>
<span class="line-added"> 503 typedef KlassToFieldEnvelope&lt;ModuleFieldSelector, ModuleWriter&gt; KlassModuleWriter;</span>
 504 
<span class="line-modified"> 505 typedef LeakPredicate&lt;ModPtr&gt; LeakModulePredicate;</span>
<span class="line-modified"> 506 typedef JfrPredicatedTypeWriterImplHost&lt;ModPtr, LeakModulePredicate, write__module__leakp&gt; LeakModuleWriterImpl;</span>
<span class="line-added"> 507 typedef JfrTypeWriterHost&lt;LeakModuleWriterImpl, TYPE_MODULE&gt; LeakModuleWriter;</span>
 508 
<span class="line-modified"> 509 typedef CompositeFunctor&lt;ModPtr, LeakModuleWriter, ModuleWriter&gt; CompositeModuleWriter;</span>
<span class="line-modified"> 510 typedef KlassToFieldEnvelope&lt;ModuleFieldSelector, CompositeModuleWriter&gt; KlassCompositeModuleWriter;</span>
<span class="line-modified"> 511 typedef CompositeFunctor&lt;ModPtr, CompositeModuleWriter, ClearArtifact&lt;ModPtr&gt; &gt; CompositeModuleWriterWithClear;</span>
<span class="line-modified"> 512 typedef JfrArtifactCallbackHost&lt;ModPtr, CompositeModuleWriterWithClear&gt; CompositeModuleCallback;</span>
<span class="line-modified"> 513 </span>
<span class="line-modified"> 514 static void write_modules() {</span>
<span class="line-modified"> 515   assert(_writer != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 516   ModuleWriter mw(_writer, _class_unload);</span>
<span class="line-modified"> 517   KlassModuleWriter kmw(&amp;mw);</span>
<span class="line-modified"> 518   if (current_epoch()) {</span>
<span class="line-modified"> 519     _artifacts-&gt;iterate_klasses(kmw);</span>
<span class="line-modified"> 520     _artifacts-&gt;tally(mw);</span>
<span class="line-added"> 521     return;</span>
<span class="line-added"> 522   }</span>
<span class="line-added"> 523   assert(previous_epoch(), &quot;invariant&quot;);</span>
<span class="line-added"> 524   if (_leakp_writer == NULL) {</span>
<span class="line-added"> 525     _artifacts-&gt;iterate_klasses(kmw);</span>
<span class="line-added"> 526     ClearArtifact&lt;ModPtr&gt; clear;</span>
 527     ModuleWriterWithClear mwwc(&amp;mw, &amp;clear);


 528     ModuleCallback callback(&amp;mwwc);
 529     _subsystem_callback = &amp;callback;
 530     do_modules();
<span class="line-modified"> 531   } else {</span>
<span class="line-added"> 532     LeakModuleWriter lmw(_leakp_writer, _class_unload);</span>
<span class="line-added"> 533     CompositeModuleWriter cmw(&amp;lmw, &amp;mw);</span>
<span class="line-added"> 534     KlassCompositeModuleWriter kcpw(&amp;cmw);</span>
<span class="line-added"> 535     _artifacts-&gt;iterate_klasses(kcpw);</span>
<span class="line-added"> 536     ClearArtifact&lt;ModPtr&gt; clear;</span>
<span class="line-added"> 537     CompositeModuleWriterWithClear cmwwc(&amp;cmw, &amp;clear);</span>
<span class="line-added"> 538     CompositeModuleCallback callback(&amp;cmwwc);</span>
<span class="line-added"> 539     _subsystem_callback = &amp;callback;</span>
<span class="line-added"> 540     do_modules();</span>
 541   }
<span class="line-modified"> 542   _artifacts-&gt;tally(mw);</span>
<span class="line-modified"> 543 }</span>
<span class="line-modified"> 544 </span>
<span class="line-modified"> 545 typedef JfrArtifactCallbackHost&lt;ModPtr, ClearArtifact&lt;ModPtr&gt; &gt; ClearModuleCallback;</span>
<span class="line-modified"> 546 </span>
<span class="line-modified"> 547 static void clear_modules() {</span>
<span class="line-added"> 548   ClearArtifact&lt;ModPtr&gt; clear;</span>
<span class="line-added"> 549   ClearModuleCallback callback(&amp;clear);</span>
 550   _subsystem_callback = &amp;callback;
 551   do_modules();
 552 }
 553 
<span class="line-modified"> 554 static int write_classloader(JfrCheckpointWriter* writer, CldPtr cld, bool leakp) {</span>
<span class="line-modified"> 555   assert(cld != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 556   assert(!cld-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);</span>
<span class="line-modified"> 557   // class loader type</span>
<span class="line-modified"> 558   const Klass* class_loader_klass = cld-&gt;class_loader_klass();</span>
<span class="line-added"> 559   if (class_loader_klass == NULL) {</span>
<span class="line-added"> 560     // (primordial) boot class loader</span>
<span class="line-added"> 561     writer-&gt;write(artifact_id(cld)); // class loader instance id</span>
<span class="line-added"> 562     writer-&gt;write((traceid)0);  // class loader type id (absence of)</span>
<span class="line-added"> 563     writer-&gt;write(get_bootstrap_name(leakp)); // maps to synthetic name -&gt; &quot;bootstrap&quot;</span>
<span class="line-added"> 564   } else {</span>
<span class="line-added"> 565     writer-&gt;write(artifact_id(cld)); // class loader instance id</span>
<span class="line-added"> 566     writer-&gt;write(artifact_id(class_loader_klass)); // class loader type id</span>
<span class="line-added"> 567     writer-&gt;write(mark_symbol(cld-&gt;name(), leakp)); // class loader instance name</span>
<span class="line-added"> 568   }</span>
<span class="line-added"> 569   return 1;</span>
<span class="line-added"> 570 }</span>
<span class="line-added"> 571 </span>
<span class="line-added"> 572 int write__classloader(JfrCheckpointWriter* writer, const void* c) {</span>
<span class="line-added"> 573   assert(c != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 574   CldPtr cld = (CldPtr)c;</span>
<span class="line-added"> 575   set_serialized(cld);</span>
<span class="line-added"> 576   return write_classloader(writer, cld, false);</span>
<span class="line-added"> 577 }</span>
<span class="line-added"> 578 </span>
<span class="line-added"> 579 int write__classloader__leakp(JfrCheckpointWriter* writer, const void* c) {</span>
<span class="line-added"> 580   assert(c != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 581   CldPtr cld = (CldPtr)c;</span>
<span class="line-added"> 582   CLEAR_LEAKP(cld);</span>
<span class="line-added"> 583   return write_classloader(writer, cld, true);</span>
<span class="line-added"> 584 }</span>
 585 
<span class="line-modified"> 586 static void do_class_loader_data(ClassLoaderData* cld) {</span>
<span class="line-added"> 587   do_previous_epoch_artifact(_subsystem_callback, cld);</span>
<span class="line-added"> 588 }</span>
<span class="line-added"> 589 </span>
<span class="line-added"> 590 class KlassCldFieldSelector {</span>
 591  public:
 592   typedef CldPtr TypePtr;
 593   static TypePtr select(KlassPtr klass) {
 594     assert(klass != NULL, &quot;invariant&quot;);
<span class="line-modified"> 595     return get_cld(klass);</span>

 596   }
 597 };
 598 
<span class="line-modified"> 599 class ModuleCldFieldSelector {</span>
<span class="line-modified"> 600 public:</span>
<span class="line-added"> 601   typedef CldPtr TypePtr;</span>
<span class="line-added"> 602   static TypePtr select(KlassPtr klass) {</span>
<span class="line-added"> 603     assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 604     ModPtr mod = ModuleFieldSelector::select(klass);</span>
<span class="line-added"> 605     return mod != NULL ? mod-&gt;loader_data() : NULL;</span>
<span class="line-added"> 606   }</span>
<span class="line-added"> 607 };</span>
 608 
<span class="line-modified"> 609 class CLDCallback : public CLDClosure {</span>
<span class="line-modified"> 610  public:</span>
<span class="line-modified"> 611   CLDCallback() {}</span>
<span class="line-modified"> 612   void do_cld(ClassLoaderData* cld) {</span>
<span class="line-modified"> 613     assert(cld != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 614     if (cld-&gt;is_unsafe_anonymous()) {</span>
<span class="line-modified"> 615       return;</span>
<span class="line-modified"> 616     }</span>
<span class="line-modified"> 617     do_class_loader_data(cld);</span>
<span class="line-modified"> 618   }</span>
<span class="line-modified"> 619 };</span>
<span class="line-modified"> 620 </span>
<span class="line-added"> 621 static void do_class_loaders() {</span>
<span class="line-added"> 622   CLDCallback cld_cb;</span>
<span class="line-added"> 623   ClassLoaderDataGraph::loaded_cld_do(&amp;cld_cb);</span>
<span class="line-added"> 624 }</span>
<span class="line-added"> 625 </span>
<span class="line-added"> 626 typedef SerializePredicate&lt;CldPtr&gt; CldPredicate;</span>
<span class="line-added"> 627 typedef JfrPredicatedTypeWriterImplHost&lt;CldPtr, CldPredicate, write__classloader&gt; CldWriterImpl;</span>
<span class="line-added"> 628 typedef JfrTypeWriterHost&lt;CldWriterImpl, TYPE_CLASSLOADER&gt; CldWriter;</span>
<span class="line-added"> 629 typedef CompositeFunctor&lt;CldPtr, CldWriter, ClearArtifact&lt;CldPtr&gt; &gt; CldWriterWithClear;</span>
<span class="line-added"> 630 typedef JfrArtifactCallbackHost&lt;CldPtr, CldWriterWithClear&gt; CldCallback;</span>
<span class="line-added"> 631 typedef KlassToFieldEnvelope&lt;KlassCldFieldSelector, CldWriter&gt; KlassCldWriter;</span>
<span class="line-added"> 632 typedef KlassToFieldEnvelope&lt;ModuleCldFieldSelector, CldWriter&gt; ModuleCldWriter;</span>
<span class="line-added"> 633 typedef CompositeFunctor&lt;KlassPtr, KlassCldWriter, ModuleCldWriter&gt; KlassAndModuleCldWriter;</span>
<span class="line-added"> 634 </span>
<span class="line-added"> 635 typedef LeakPredicate&lt;CldPtr&gt; LeakCldPredicate;</span>
<span class="line-added"> 636 typedef JfrPredicatedTypeWriterImplHost&lt;CldPtr, LeakCldPredicate, write__classloader__leakp&gt; LeakCldWriterImpl;</span>
<span class="line-added"> 637 typedef JfrTypeWriterHost&lt;LeakCldWriterImpl, TYPE_CLASSLOADER&gt; LeakCldWriter;</span>
<span class="line-added"> 638 </span>
<span class="line-added"> 639 typedef CompositeFunctor&lt;CldPtr, LeakCldWriter, CldWriter&gt; CompositeCldWriter;</span>
<span class="line-added"> 640 typedef KlassToFieldEnvelope&lt;KlassCldFieldSelector, CompositeCldWriter&gt; KlassCompositeCldWriter;</span>
<span class="line-added"> 641 typedef KlassToFieldEnvelope&lt;ModuleCldFieldSelector, CompositeCldWriter&gt; ModuleCompositeCldWriter;</span>
<span class="line-added"> 642 typedef CompositeFunctor&lt;KlassPtr, KlassCompositeCldWriter, ModuleCompositeCldWriter&gt; KlassAndModuleCompositeCldWriter;</span>
<span class="line-added"> 643 typedef CompositeFunctor&lt;CldPtr, CompositeCldWriter, ClearArtifact&lt;CldPtr&gt; &gt; CompositeCldWriterWithClear;</span>
<span class="line-added"> 644 typedef JfrArtifactCallbackHost&lt;CldPtr, CompositeCldWriterWithClear&gt; CompositeCldCallback;</span>
<span class="line-added"> 645 </span>
<span class="line-added"> 646 static void write_classloaders() {</span>
<span class="line-added"> 647   assert(_writer != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 648   CldWriter cldw(_writer, _class_unload);</span>
<span class="line-added"> 649   KlassCldWriter kcw(&amp;cldw);</span>
<span class="line-added"> 650   ModuleCldWriter mcw(&amp;cldw);</span>
<span class="line-added"> 651   KlassAndModuleCldWriter kmcw(&amp;kcw, &amp;mcw);</span>
<span class="line-added"> 652   if (current_epoch()) {</span>
<span class="line-added"> 653     _artifacts-&gt;iterate_klasses(kmcw);</span>
<span class="line-added"> 654     _artifacts-&gt;tally(cldw);</span>
<span class="line-added"> 655     return;</span>
<span class="line-added"> 656   }</span>
<span class="line-added"> 657   assert(previous_epoch(), &quot;invariant&quot;);</span>
<span class="line-added"> 658   if (_leakp_writer == NULL) {</span>
<span class="line-added"> 659     _artifacts-&gt;iterate_klasses(kmcw);</span>
<span class="line-added"> 660     ClearArtifact&lt;CldPtr&gt; clear;</span>
 661     CldWriterWithClear cldwwc(&amp;cldw, &amp;clear);


 662     CldCallback callback(&amp;cldwwc);
 663     _subsystem_callback = &amp;callback;
 664     do_class_loaders();
<span class="line-modified"> 665   } else {</span>
<span class="line-added"> 666     LeakCldWriter lcldw(_leakp_writer, _class_unload);</span>
<span class="line-added"> 667     CompositeCldWriter ccldw(&amp;lcldw, &amp;cldw);</span>
<span class="line-added"> 668     KlassCompositeCldWriter kccldw(&amp;ccldw);</span>
<span class="line-added"> 669     ModuleCompositeCldWriter mccldw(&amp;ccldw);</span>
<span class="line-added"> 670     KlassAndModuleCompositeCldWriter kmccldw(&amp;kccldw, &amp;mccldw);</span>
<span class="line-added"> 671     _artifacts-&gt;iterate_klasses(kmccldw);</span>
<span class="line-added"> 672     ClearArtifact&lt;CldPtr&gt; clear;</span>
<span class="line-added"> 673     CompositeCldWriterWithClear ccldwwc(&amp;ccldw, &amp;clear);</span>
<span class="line-added"> 674     CompositeCldCallback callback(&amp;ccldwwc);</span>
<span class="line-added"> 675     _subsystem_callback = &amp;callback;</span>
<span class="line-added"> 676     do_class_loaders();</span>
 677   }
<span class="line-modified"> 678   _artifacts-&gt;tally(cldw);</span>
<span class="line-modified"> 679 }</span>
<span class="line-modified"> 680 </span>
<span class="line-modified"> 681 typedef JfrArtifactCallbackHost&lt;CldPtr, ClearArtifact&lt;CldPtr&gt; &gt; ClearCLDCallback;</span>
<span class="line-modified"> 682 </span>
<span class="line-modified"> 683 static void clear_classloaders() {</span>
<span class="line-added"> 684   ClearArtifact&lt;CldPtr&gt; clear;</span>
<span class="line-added"> 685   ClearCLDCallback callback(&amp;clear);</span>
 686   _subsystem_callback = &amp;callback;
 687   do_class_loaders();
 688 }
 689 
<span class="line-modified"> 690 static u1 get_visibility(MethodPtr method) {</span>
<span class="line-added"> 691   assert(method != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 692   return const_cast&lt;Method*&gt;(method)-&gt;is_hidden() ? (u1)1 : (u1)0;</span>
<span class="line-added"> 693 }</span>
<span class="line-added"> 694 </span>
<span class="line-added"> 695 template &lt;&gt;</span>
<span class="line-added"> 696 void set_serialized&lt;Method&gt;(MethodPtr method) {</span>
<span class="line-added"> 697   assert(method != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 698   SET_METHOD_SERIALIZED(method);</span>
<span class="line-added"> 699   assert(IS_METHOD_SERIALIZED(method), &quot;invariant&quot;);</span>
<span class="line-added"> 700   CLEAR_THIS_EPOCH_METHOD_CLEARED_BIT(method);</span>
<span class="line-added"> 701 }</span>
<span class="line-added"> 702 </span>
<span class="line-added"> 703 static int write_method(JfrCheckpointWriter* writer, MethodPtr method, bool leakp) {</span>
<span class="line-added"> 704   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 705   assert(method != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 706   assert(_artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 707   KlassPtr klass = method-&gt;method_holder();</span>
<span class="line-added"> 708   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 709   writer-&gt;write(method_id(klass, method));</span>
<span class="line-added"> 710   writer-&gt;write(artifact_id(klass));</span>
<span class="line-added"> 711   writer-&gt;write(mark_symbol(method-&gt;name(), leakp));</span>
<span class="line-added"> 712   writer-&gt;write(mark_symbol(method-&gt;signature(), leakp));</span>
<span class="line-added"> 713   writer-&gt;write((u2)get_flags(method));</span>
<span class="line-added"> 714   writer-&gt;write(get_visibility(method));</span>
<span class="line-added"> 715   return 1;</span>
<span class="line-added"> 716 }</span>
<span class="line-added"> 717 </span>
<span class="line-added"> 718 int write__method(JfrCheckpointWriter* writer, const void* m) {</span>
<span class="line-added"> 719   assert(m != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 720   MethodPtr method = (MethodPtr)m;</span>
<span class="line-added"> 721   set_serialized(method);</span>
<span class="line-added"> 722   return write_method(writer, method, false);</span>
<span class="line-added"> 723 }</span>
<span class="line-added"> 724 </span>
<span class="line-added"> 725 int write__method__leakp(JfrCheckpointWriter* writer, const void* m) {</span>
<span class="line-added"> 726   assert(m != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 727   MethodPtr method = (MethodPtr)m;</span>
<span class="line-added"> 728   return write_method(writer, method, true);</span>
<span class="line-added"> 729 }</span>
<span class="line-added"> 730 </span>
<span class="line-added"> 731 class BitMapFilter {</span>
<span class="line-added"> 732   ResourceBitMap _bitmap;</span>
<span class="line-added"> 733  public:</span>
<span class="line-added"> 734   explicit BitMapFilter(int length = 0) : _bitmap((size_t)length) {}</span>
<span class="line-added"> 735   bool operator()(size_t idx) {</span>
<span class="line-added"> 736     if (_bitmap.size() == 0) {</span>
<span class="line-added"> 737       return true;</span>
<span class="line-added"> 738     }</span>
<span class="line-added"> 739     if (_bitmap.at(idx)) {</span>
<span class="line-added"> 740       return false;</span>
<span class="line-added"> 741     }</span>
<span class="line-added"> 742     _bitmap.set_bit(idx);</span>
<span class="line-added"> 743     return true;</span>
<span class="line-added"> 744   }</span>
<span class="line-added"> 745 };</span>
<span class="line-added"> 746 </span>
<span class="line-added"> 747 class AlwaysTrue {</span>
<span class="line-added"> 748  public:</span>
<span class="line-added"> 749   explicit AlwaysTrue(int length = 0) {}</span>
<span class="line-added"> 750   bool operator()(size_t idx) {</span>
<span class="line-added"> 751     return true;</span>
<span class="line-added"> 752   }</span>
<span class="line-added"> 753 };</span>
<span class="line-added"> 754 </span>
<span class="line-added"> 755 template &lt;typename MethodCallback, typename KlassCallback, class Filter, bool leakp&gt;</span>
 756 class MethodIteratorHost {
 757  private:
<span class="line-modified"> 758   MethodCallback _method_cb;</span>
<span class="line-modified"> 759   KlassCallback _klass_cb;</span>
<span class="line-modified"> 760   MethodUsedPredicate&lt;leakp&gt; _method_used_predicate;</span>
<span class="line-modified"> 761   MethodFlagPredicate&lt;leakp&gt; _method_flag_predicate;</span>
 762  public:
 763   MethodIteratorHost(JfrCheckpointWriter* writer,
<span class="line-modified"> 764                      bool current_epoch = false,</span>
<span class="line-modified"> 765                      bool class_unload = false,</span>
 766                      bool skip_header = false) :
<span class="line-modified"> 767     _method_cb(writer, class_unload, skip_header),</span>
<span class="line-modified"> 768     _klass_cb(writer, class_unload, skip_header),</span>
<span class="line-modified"> 769     _method_used_predicate(current_epoch),</span>
<span class="line-added"> 770     _method_flag_predicate(current_epoch) {}</span>
 771 
 772   bool operator()(KlassPtr klass) {
 773     if (_method_used_predicate(klass)) {

 774       const InstanceKlass* ik = InstanceKlass::cast(klass);
 775       const int len = ik-&gt;methods()-&gt;length();
<span class="line-modified"> 776       Filter filter(ik-&gt;previous_versions() != NULL ? len : 0);</span>
<span class="line-modified"> 777       while (ik != NULL) {</span>
<span class="line-modified"> 778         for (int i = 0; i &lt; len; ++i) {</span>
<span class="line-modified"> 779           MethodPtr method = ik-&gt;methods()-&gt;at(i);</span>
<span class="line-added"> 780           if (_method_flag_predicate(method) &amp;&amp; filter(i)) {</span>
<span class="line-added"> 781             _method_cb(method);</span>
<span class="line-added"> 782           }</span>
 783         }
<span class="line-added"> 784         // There can be multiple versions of the same method running</span>
<span class="line-added"> 785         // due to redefinition. Need to inspect the complete set of methods.</span>
<span class="line-added"> 786         ik = ik-&gt;previous_versions();</span>
 787       }
 788     }
<span class="line-modified"> 789     return _klass_cb(klass);</span>
 790   }
 791 
<span class="line-modified"> 792   int count() const { return _method_cb.count(); }</span>
<span class="line-modified"> 793   void add(int count) { _method_cb.add(count); }</span>
 794 };
 795 
<span class="line-modified"> 796 template &lt;typename T, template &lt;typename&gt; class Impl&gt;</span>
<span class="line-modified"> 797 class Wrapper {</span>
<span class="line-modified"> 798   Impl&lt;T&gt; _t;</span>
<span class="line-modified"> 799  public:</span>
<span class="line-modified"> 800   Wrapper(JfrCheckpointWriter*, bool, bool) : _t() {}</span>
<span class="line-modified"> 801   bool operator()(T const&amp; value) {</span>
<span class="line-modified"> 802     return _t(value);</span>

























 803   }
<span class="line-modified"> 804 };</span>






 805 
<span class="line-modified"> 806 template &lt;typename T&gt;</span>
<span class="line-modified"> 807 class EmptyStub {</span>
<span class="line-modified"> 808  public:</span>
<span class="line-added"> 809   bool operator()(T const&amp; value) { return true; }</span>
<span class="line-added"> 810 };</span>
 811 
<span class="line-modified"> 812 typedef SerializePredicate&lt;MethodPtr&gt; MethodPredicate;</span>
<span class="line-modified"> 813 typedef JfrPredicatedTypeWriterImplHost&lt;MethodPtr, MethodPredicate, write__method&gt; MethodWriterImplTarget;</span>
<span class="line-modified"> 814 typedef Wrapper&lt;KlassPtr, EmptyStub&gt; KlassCallbackStub;</span>
<span class="line-modified"> 815 typedef JfrTypeWriterHost&lt;MethodWriterImplTarget, TYPE_METHOD&gt; MethodWriterImpl;</span>
<span class="line-modified"> 816 typedef MethodIteratorHost&lt;MethodWriterImpl, KlassCallbackStub, BitMapFilter, false&gt; MethodWriter;</span>
<span class="line-added"> 817 </span>
<span class="line-added"> 818 typedef LeakPredicate&lt;MethodPtr&gt; LeakMethodPredicate;</span>
<span class="line-added"> 819 typedef JfrPredicatedTypeWriterImplHost&lt;MethodPtr, LeakMethodPredicate, write__method__leakp&gt; LeakMethodWriterImplTarget;</span>
<span class="line-added"> 820 typedef JfrTypeWriterHost&lt;LeakMethodWriterImplTarget, TYPE_METHOD&gt; LeakMethodWriterImpl;</span>
<span class="line-added"> 821 typedef MethodIteratorHost&lt;LeakMethodWriterImpl, KlassCallbackStub, BitMapFilter, true&gt; LeakMethodWriter;</span>
<span class="line-added"> 822 typedef MethodIteratorHost&lt;LeakMethodWriterImpl, KlassCallbackStub, BitMapFilter, true&gt; LeakMethodWriter;</span>
<span class="line-added"> 823 typedef CompositeFunctor&lt;KlassPtr, LeakMethodWriter, MethodWriter&gt; CompositeMethodWriter;</span>
 824 
<span class="line-modified"> 825 static void write_methods() {</span>
<span class="line-modified"> 826   assert(_writer != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 827   MethodWriter mw(_writer, current_epoch(), _class_unload);</span>
<span class="line-modified"> 828   if (_leakp_writer == NULL) {</span>
<span class="line-modified"> 829     _artifacts-&gt;iterate_klasses(mw);</span>
<span class="line-modified"> 830   } else {</span>
<span class="line-modified"> 831     LeakMethodWriter lpmw(_leakp_writer, current_epoch(), _class_unload);</span>
<span class="line-modified"> 832     CompositeMethodWriter cmw(&amp;lpmw, &amp;mw);</span>
<span class="line-modified"> 833     _artifacts-&gt;iterate_klasses(cmw);</span>




 834   }
<span class="line-added"> 835   _artifacts-&gt;tally(mw);</span>
 836 }
 837 
<span class="line-modified"> 838 template &lt;&gt;</span>
<span class="line-modified"> 839 void set_serialized&lt;JfrSymbolId::SymbolEntry&gt;(SymbolEntryPtr ptr) {</span>
<span class="line-modified"> 840   assert(ptr != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 841   ptr-&gt;set_serialized();</span>
<span class="line-modified"> 842   assert(ptr-&gt;is_serialized(), &quot;invariant&quot;);</span>






 843 }
 844 
<span class="line-modified"> 845 template &lt;&gt;</span>
<span class="line-modified"> 846 void set_serialized&lt;JfrSymbolId::CStringEntry&gt;(CStringEntryPtr ptr) {</span>
<span class="line-modified"> 847   assert(ptr != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 848   ptr-&gt;set_serialized();</span>
<span class="line-modified"> 849   assert(ptr-&gt;is_serialized(), &quot;invariant&quot;);</span>

 850 }
 851 
<span class="line-modified"> 852 static int write_symbol(JfrCheckpointWriter* writer, SymbolEntryPtr entry, bool leakp) {</span>
<span class="line-added"> 853   assert(writer != NULL, &quot;invariant&quot;);</span>
 854   assert(entry != NULL, &quot;invariant&quot;);
<span class="line-modified"> 855   ResourceMark rm;</span>
<span class="line-modified"> 856   writer-&gt;write(create_symbol_id(entry-&gt;id()));</span>
<span class="line-modified"> 857   writer-&gt;write(entry-&gt;value()-&gt;as_C_string());</span>
<span class="line-modified"> 858   return 1;</span>
 859 }
 860 
<span class="line-modified"> 861 int write__symbol(JfrCheckpointWriter* writer, const void* e) {</span>
<span class="line-modified"> 862   assert(e != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 863   SymbolEntryPtr entry = (SymbolEntryPtr)e;</span>
<span class="line-modified"> 864   set_serialized(entry);</span>
<span class="line-modified"> 865   return write_symbol(writer, entry, false);</span>
 866 }
 867 
<span class="line-modified"> 868 int write__symbol__leakp(JfrCheckpointWriter* writer, const void* e) {</span>
<span class="line-modified"> 869   assert(e != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 870   SymbolEntryPtr entry = (SymbolEntryPtr)e;</span>
<span class="line-modified"> 871   return write_symbol(writer, entry, true);</span>


 872 }
<span class="line-modified"> 873 </span>
<span class="line-added"> 874 static int write_cstring(JfrCheckpointWriter* writer, CStringEntryPtr entry, bool leakp) {</span>
<span class="line-added"> 875   assert(writer != NULL, &quot;invariant&quot;);</span>
 876   assert(entry != NULL, &quot;invariant&quot;);
<span class="line-modified"> 877   writer-&gt;write(create_symbol_id(entry-&gt;id()));</span>
<span class="line-modified"> 878   writer-&gt;write(entry-&gt;value());</span>
<span class="line-modified"> 879   return 1;</span>

 880 }
 881 
<span class="line-modified"> 882 int write__cstring(JfrCheckpointWriter* writer, const void* e) {</span>
<span class="line-modified"> 883   assert(e != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 884   CStringEntryPtr entry = (CStringEntryPtr)e;</span>
<span class="line-modified"> 885   set_serialized(entry);</span>
<span class="line-modified"> 886   return write_cstring(writer, entry, false);</span>
 887 }
 888 
<span class="line-modified"> 889 int write__cstring__leakp(JfrCheckpointWriter* writer, const void* e) {</span>
<span class="line-modified"> 890   assert(e != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 891   CStringEntryPtr entry = (CStringEntryPtr)e;</span>
<span class="line-added"> 892   return write_cstring(writer, entry, true);</span>
<span class="line-added"> 893 }</span>
<span class="line-added"> 894 </span>
<span class="line-added"> 895 typedef SymbolPredicate&lt;SymbolEntryPtr, false&gt; SymPredicate;</span>
<span class="line-added"> 896 typedef JfrPredicatedTypeWriterImplHost&lt;SymbolEntryPtr, SymPredicate, write__symbol&gt; SymbolEntryWriterImpl;</span>
<span class="line-added"> 897 typedef JfrTypeWriterHost&lt;SymbolEntryWriterImpl, TYPE_SYMBOL&gt; SymbolEntryWriter;</span>
<span class="line-added"> 898 typedef SymbolPredicate&lt;CStringEntryPtr, false&gt; CStringPredicate;</span>
<span class="line-added"> 899 typedef JfrPredicatedTypeWriterImplHost&lt;CStringEntryPtr, CStringPredicate, write__cstring&gt; CStringEntryWriterImpl;</span>
<span class="line-added"> 900 typedef JfrTypeWriterHost&lt;CStringEntryWriterImpl, TYPE_SYMBOL&gt; CStringEntryWriter;</span>
<span class="line-added"> 901 </span>
<span class="line-added"> 902 typedef SymbolPredicate&lt;SymbolEntryPtr, true&gt; LeakSymPredicate;</span>
<span class="line-added"> 903 typedef JfrPredicatedTypeWriterImplHost&lt;SymbolEntryPtr, LeakSymPredicate, write__symbol__leakp&gt; LeakSymbolEntryWriterImpl;</span>
<span class="line-added"> 904 typedef JfrTypeWriterHost&lt;LeakSymbolEntryWriterImpl, TYPE_SYMBOL&gt; LeakSymbolEntryWriter;</span>
<span class="line-added"> 905 typedef CompositeFunctor&lt;SymbolEntryPtr, LeakSymbolEntryWriter, SymbolEntryWriter&gt; CompositeSymbolWriter;</span>
<span class="line-added"> 906 typedef SymbolPredicate&lt;CStringEntryPtr, true&gt; LeakCStringPredicate;</span>
<span class="line-added"> 907 typedef JfrPredicatedTypeWriterImplHost&lt;CStringEntryPtr, LeakCStringPredicate, write__cstring__leakp&gt; LeakCStringEntryWriterImpl;</span>
<span class="line-added"> 908 typedef JfrTypeWriterHost&lt;LeakCStringEntryWriterImpl, TYPE_SYMBOL&gt; LeakCStringEntryWriter;</span>
<span class="line-added"> 909 typedef CompositeFunctor&lt;CStringEntryPtr, LeakCStringEntryWriter, CStringEntryWriter&gt; CompositeCStringWriter;</span>
<span class="line-added"> 910 </span>
<span class="line-added"> 911 static void write_symbols_with_leakp() {</span>
<span class="line-added"> 912   assert(_leakp_writer != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 913   SymbolEntryWriter sw(_writer, _class_unload);</span>
<span class="line-added"> 914   LeakSymbolEntryWriter lsw(_leakp_writer, _class_unload);</span>
<span class="line-added"> 915   CompositeSymbolWriter csw(&amp;lsw, &amp;sw);</span>
<span class="line-added"> 916   _artifacts-&gt;iterate_symbols(csw);</span>
<span class="line-added"> 917   CStringEntryWriter ccsw(_writer, _class_unload, true); // skip header</span>
<span class="line-added"> 918   LeakCStringEntryWriter lccsw(_leakp_writer, _class_unload, true); // skip header</span>
<span class="line-added"> 919   CompositeCStringWriter cccsw(&amp;lccsw, &amp;ccsw);</span>
<span class="line-added"> 920   _artifacts-&gt;iterate_cstrings(cccsw);</span>
<span class="line-added"> 921   sw.add(ccsw.count());</span>
<span class="line-added"> 922   lsw.add(lccsw.count());</span>
<span class="line-added"> 923   _artifacts-&gt;tally(sw);</span>
<span class="line-added"> 924 }</span>
<span class="line-added"> 925 </span>
<span class="line-added"> 926 static void write_symbols() {</span>
<span class="line-added"> 927   assert(_writer != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 928   if (_leakp_writer != NULL) {</span>
<span class="line-added"> 929     write_symbols_with_leakp();</span>
 930     return;
 931   }
<span class="line-modified"> 932   SymbolEntryWriter sw(_writer, _class_unload);</span>
<span class="line-added"> 933   _artifacts-&gt;iterate_symbols(sw);</span>
<span class="line-added"> 934   CStringEntryWriter csw(_writer, _class_unload, true); // skip header</span>
<span class="line-added"> 935   _artifacts-&gt;iterate_cstrings(csw);</span>
<span class="line-added"> 936   sw.add(csw.count());</span>
<span class="line-added"> 937   _artifacts-&gt;tally(sw);</span>
 938 }
 939 
<span class="line-modified"> 940 typedef Wrapper&lt;KlassPtr, ClearArtifact&gt; ClearKlassBits;</span>
<span class="line-modified"> 941 typedef Wrapper&lt;MethodPtr, ClearArtifact&gt; ClearMethodFlag;</span>
<span class="line-modified"> 942 typedef MethodIteratorHost&lt;ClearMethodFlag, ClearKlassBits, AlwaysTrue, false&gt; ClearKlassAndMethods;</span>



 943 
<span class="line-modified"> 944 static bool clear_artifacts = false;</span>























 945 
<span class="line-modified"> 946 static void clear_klasses_and_methods() {</span>
<span class="line-modified"> 947   ClearKlassAndMethods clear(_writer);</span>
<span class="line-modified"> 948   _artifacts-&gt;iterate_klasses(clear);</span>




 949 }
 950 
<span class="line-modified"> 951 static size_t teardown() {</span>
<span class="line-modified"> 952   assert(_artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 953   const size_t total_count = _artifacts-&gt;total_count();</span>
<span class="line-modified"> 954   if (previous_epoch()) {</span>
<span class="line-modified"> 955     clear_klasses_and_methods();</span>
<span class="line-modified"> 956     clear_artifacts = true;</span>
<span class="line-modified"> 957     ++checkpoint_id;</span>
<span class="line-modified"> 958   }</span>
<span class="line-modified"> 959   return total_count;</span>
 960 }
 961 
<span class="line-modified"> 962 static void setup(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer, bool class_unload, bool flushpoint) {</span>
<span class="line-modified"> 963   _writer = writer;</span>
<span class="line-modified"> 964   _leakp_writer = leakp_writer;</span>




 965   _class_unload = class_unload;
<span class="line-modified"> 966   _flushpoint = flushpoint;</span>
 967   if (_artifacts == NULL) {
 968     _artifacts = new JfrArtifactSet(class_unload);

 969   } else {
<span class="line-modified"> 970     _artifacts-&gt;initialize(class_unload, clear_artifacts);</span>

 971   }
<span class="line-added"> 972   clear_artifacts = false;</span>
 973   assert(_artifacts != NULL, &quot;invariant&quot;);
 974   assert(!_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);
<span class="line-modified"> 975 }</span>

 976 
<span class="line-added"> 977 /**</span>
<span class="line-added"> 978  * Write all &quot;tagged&quot; (in-use) constant artifacts and their dependencies.</span>
<span class="line-added"> 979  */</span>
<span class="line-added"> 980 size_t JfrTypeSet::serialize(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer, bool class_unload, bool flushpoint) {</span>
<span class="line-added"> 981   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 982   ResourceMark rm;</span>
<span class="line-added"> 983   setup(writer, leakp_writer, class_unload, flushpoint);</span>
 984   // write order is important because an individual write step
 985   // might tag an artifact to be written in a subsequent step
<span class="line-modified"> 986   if (!write_klasses()) {</span>
<span class="line-modified"> 987     return 0;</span>






 988   }
<span class="line-added"> 989   write_packages();</span>
<span class="line-added"> 990   write_modules();</span>
<span class="line-added"> 991   write_classloaders();</span>
<span class="line-added"> 992   write_methods();</span>
<span class="line-added"> 993   write_symbols();</span>
<span class="line-added"> 994   return teardown();</span>
<span class="line-added"> 995 }</span>
<span class="line-added"> 996 </span>
<span class="line-added"> 997 /**</span>
<span class="line-added"> 998  * Clear all tags from the previous epoch.</span>
<span class="line-added"> 999  */</span>
<span class="line-added">1000 void JfrTypeSet::clear() {</span>
<span class="line-added">1001   clear_artifacts = true;</span>
<span class="line-added">1002   setup(NULL, NULL, false, false);</span>
<span class="line-added">1003   register_klasses();</span>
<span class="line-added">1004   clear_packages();</span>
<span class="line-added">1005   clear_modules();</span>
<span class="line-added">1006   clear_classloaders();</span>
<span class="line-added">1007   clear_klasses_and_methods();</span>
1008 }
</pre>
</td>
</tr>
</table>
<center><a href="jfrTypeManager.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="jfrTypeSet.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
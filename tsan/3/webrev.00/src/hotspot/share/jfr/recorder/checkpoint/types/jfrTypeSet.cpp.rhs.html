<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeSet.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  27 #include &quot;classfile/javaClasses.inline.hpp&quot;
  28 #include &quot;classfile/moduleEntry.hpp&quot;
  29 #include &quot;classfile/packageEntry.hpp&quot;
  30 #include &quot;classfile/symbolTable.hpp&quot;
<a name="2" id="anc2"></a>
  31 #include &quot;jfr/jfr.hpp&quot;
  32 #include &quot;jfr/jni/jfrGetAllEventClasses.hpp&quot;
<a name="3" id="anc3"></a><span class="line-modified">  33 #include &quot;jfr/leakprofiler/checkpoint/objectSampleCheckpoint.hpp&quot;</span>
  34 #include &quot;jfr/recorder/checkpoint/types/jfrTypeSet.hpp&quot;
  35 #include &quot;jfr/recorder/checkpoint/types/jfrTypeSetUtils.hpp&quot;
<a name="4" id="anc4"></a>
  36 #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceId.inline.hpp&quot;
<a name="5" id="anc5"></a>
  37 #include &quot;jfr/utilities/jfrHashtable.hpp&quot;
  38 #include &quot;jfr/utilities/jfrTypes.hpp&quot;
<a name="6" id="anc6"></a><span class="line-added">  39 #include &quot;jfr/writers/jfrTypeWriterHost.hpp&quot;</span>
  40 #include &quot;memory/iterator.hpp&quot;
  41 #include &quot;memory/resourceArea.hpp&quot;
  42 #include &quot;oops/instanceKlass.hpp&quot;
  43 #include &quot;oops/objArrayKlass.hpp&quot;
  44 #include &quot;oops/oop.inline.hpp&quot;
<a name="7" id="anc7"></a>
  45 #include &quot;utilities/accessFlags.hpp&quot;
<a name="8" id="anc8"></a><span class="line-modified">  46 #include &quot;utilities/bitMap.inline.hpp&quot;</span>






  47 
  48 typedef const Klass* KlassPtr;
  49 typedef const PackageEntry* PkgPtr;
  50 typedef const ModuleEntry* ModPtr;
  51 typedef const ClassLoaderData* CldPtr;
  52 typedef const Method* MethodPtr;
  53 typedef const Symbol* SymbolPtr;
  54 typedef const JfrSymbolId::SymbolEntry* SymbolEntryPtr;
  55 typedef const JfrSymbolId::CStringEntry* CStringEntryPtr;
  56 
<a name="9" id="anc9"></a><span class="line-modified">  57 static JfrCheckpointWriter* _writer = NULL;</span>
<span class="line-modified">  58 static JfrCheckpointWriter* _leakp_writer = NULL;</span>
<span class="line-modified">  59 static JfrArtifactSet* _artifacts = NULL;</span>
<span class="line-modified">  60 static JfrArtifactClosure* _subsystem_callback = NULL;</span>
<span class="line-added">  61 static bool _class_unload = false;</span>
<span class="line-added">  62 static bool _flushpoint = false;</span>
<span class="line-added">  63 </span>
<span class="line-added">  64 // incremented on each rotation</span>
<span class="line-added">  65 static u8 checkpoint_id = 1;</span>
<span class="line-added">  66 </span>
<span class="line-added">  67 // creates a unique id by combining a checkpoint relative symbol id (2^24)</span>
<span class="line-added">  68 // with the current checkpoint id (2^40)</span>
<span class="line-added">  69 #define CREATE_SYMBOL_ID(sym_id) (((u8)((checkpoint_id &lt;&lt; 24) | sym_id)))</span>
<span class="line-added">  70 </span>
<span class="line-added">  71 static traceid create_symbol_id(traceid artifact_id) {</span>
<span class="line-added">  72   return artifact_id != 0 ? CREATE_SYMBOL_ID(artifact_id) : 0;</span>
  73 }
  74 
<a name="10" id="anc10"></a><span class="line-modified">  75 static bool current_epoch() {</span>
<span class="line-modified">  76   return _class_unload || _flushpoint;</span>


  77 }
  78 
<a name="11" id="anc11"></a><span class="line-modified">  79 static bool previous_epoch() {</span>
<span class="line-modified">  80   return !current_epoch();</span>

  81 }
  82 
<a name="12" id="anc12"></a><span class="line-modified">  83 static bool is_complete() {</span>
<span class="line-modified">  84   return !_artifacts-&gt;has_klass_entries() &amp;&amp; current_epoch();</span>













  85 }
  86 
<a name="13" id="anc13"></a><span class="line-modified">  87 static traceid mark_symbol(KlassPtr klass, bool leakp) {</span>
<span class="line-modified">  88   return klass != NULL ? create_symbol_id(_artifacts-&gt;mark(klass, leakp)) : 0;</span>
<span class="line-modified">  89 }</span>














  90 
<a name="14" id="anc14"></a><span class="line-modified">  91 static traceid mark_symbol(Symbol* symbol, bool leakp) {</span>
<span class="line-modified">  92   return symbol != NULL ? create_symbol_id(_artifacts-&gt;mark(symbol, leakp)) : 0;</span>
<span class="line-modified">  93 }</span>




  94 
<a name="15" id="anc15"></a><span class="line-modified">  95 static traceid get_bootstrap_name(bool leakp) {</span>
<span class="line-modified">  96   return create_symbol_id(_artifacts-&gt;bootstrap_name(leakp));</span>






















  97 }
  98 
<a name="16" id="anc16"></a><span class="line-modified">  99 template &lt;typename T&gt;</span>
<span class="line-modified"> 100 static traceid artifact_id(const T* ptr) {</span>
<span class="line-modified"> 101   assert(ptr != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 102   return TRACE_ID(ptr);</span>
<span class="line-modified"> 103 }</span>
 104 
<a name="17" id="anc17"></a><span class="line-modified"> 105 static traceid package_id(KlassPtr klass, bool leakp) {</span>









 106   assert(klass != NULL, &quot;invariant&quot;);
<a name="18" id="anc18"></a><span class="line-modified"> 107   PkgPtr pkg_entry = klass-&gt;package();</span>
<span class="line-modified"> 108   if (pkg_entry == NULL) {</span>
<span class="line-modified"> 109     return 0;</span>
<span class="line-modified"> 110   }</span>
<span class="line-modified"> 111   if (leakp) {</span>
<span class="line-modified"> 112     SET_LEAKP(pkg_entry);</span>
<span class="line-modified"> 113   }</span>
<span class="line-modified"> 114   // package implicitly tagged already</span>
<span class="line-added"> 115   return artifact_id(pkg_entry);</span>
 116 }
 117 
<a name="19" id="anc19"></a><span class="line-modified"> 118 static traceid module_id(PkgPtr pkg, bool leakp) {</span>
<span class="line-modified"> 119   assert(pkg != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 120   ModPtr module_entry = pkg-&gt;module();</span>
<span class="line-modified"> 121   if (module_entry == NULL) {</span>
<span class="line-modified"> 122     return 0;</span>
<span class="line-modified"> 123   }</span>
<span class="line-modified"> 124   if (leakp) {</span>
<span class="line-modified"> 125     SET_LEAKP(module_entry);</span>
<span class="line-modified"> 126   } else {</span>
<span class="line-modified"> 127     SET_TRANSIENT(module_entry);</span>
<span class="line-modified"> 128   }</span>
<span class="line-modified"> 129   return artifact_id(module_entry);</span>




 130 }
 131 
<a name="20" id="anc20"></a><span class="line-modified"> 132 static traceid method_id(KlassPtr klass, MethodPtr method) {</span>
<span class="line-modified"> 133   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 134   assert(method != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 135   return METHOD_ID(klass, method);</span>



















 136 }
 137 
<a name="21" id="anc21"></a><span class="line-modified"> 138 static traceid cld_id(CldPtr cld, bool leakp) {</span>
<span class="line-modified"> 139   assert(cld != NULL, &quot;invariant&quot;);</span>









 140   assert(!cld-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);
<a name="22" id="anc22"></a><span class="line-modified"> 141   if (leakp) {</span>
<span class="line-modified"> 142     SET_LEAKP(cld);</span>






 143   } else {
<a name="23" id="anc23"></a><span class="line-modified"> 144     SET_TRANSIENT(cld);</span>





 145   }
<a name="24" id="anc24"></a><span class="line-modified"> 146   return artifact_id(cld);</span>
 147 }
 148 
<a name="25" id="anc25"></a><span class="line-modified"> 149 template &lt;typename T&gt;</span>
<span class="line-modified"> 150 static s4 get_flags(const T* ptr) {</span>
<span class="line-modified"> 151   assert(ptr != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 152   return ptr-&gt;access_flags().get_flags();</span>
<span class="line-modified"> 153 }</span>




 154 
<a name="26" id="anc26"></a><span class="line-modified"> 155 static bool is_unsafe_anonymous(const Klass* klass) {</span>
<span class="line-modified"> 156   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 157   return klass-&gt;is_instance_klass() &amp;&amp; ((const InstanceKlass*)klass)-&gt;is_unsafe_anonymous();</span>





 158 }
 159 
<a name="27" id="anc27"></a><span class="line-modified"> 160 static ClassLoaderData* get_cld(const Klass* klass) {</span>
<span class="line-modified"> 161   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 162   return is_unsafe_anonymous(klass) ?</span>
<span class="line-added"> 163     InstanceKlass::cast(klass)-&gt;unsafe_anonymous_host()-&gt;class_loader_data() : klass-&gt;class_loader_data();</span>
 164 }
 165 
<a name="28" id="anc28"></a><span class="line-modified"> 166 template &lt;typename T&gt;</span>
<span class="line-modified"> 167 static void set_serialized(const T* ptr) {</span>
<span class="line-added"> 168   assert(ptr != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 169   SET_SERIALIZED(ptr);</span>
<span class="line-added"> 170   assert(IS_SERIALIZED(ptr), &quot;invariant&quot;);</span>
<span class="line-added"> 171   CLEAR_THIS_EPOCH_CLEARED_BIT(ptr);</span>
<span class="line-added"> 172 }</span>
 173 
<a name="29" id="anc29"></a><span class="line-modified"> 174 /*</span>
<span class="line-added"> 175  * In C++03, functions used as template parameters must have external linkage;</span>
<span class="line-added"> 176  * this restriction was removed in C++11. Change back to &quot;static&quot; and</span>
<span class="line-added"> 177  * rename functions when C++11 becomes available.</span>
<span class="line-added"> 178  *</span>
<span class="line-added"> 179  * The weird naming is an effort to decrease the risk of name clashes.</span>
<span class="line-added"> 180  */</span>
 181 
<a name="30" id="anc30"></a><span class="line-modified"> 182 static int write_klass(JfrCheckpointWriter* writer, KlassPtr klass, bool leakp) {</span>
 183   assert(writer != NULL, &quot;invariant&quot;);
<a name="31" id="anc31"></a><span class="line-modified"> 184   assert(_artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 185   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 186   traceid pkg_id = 0;</span>
<span class="line-added"> 187   KlassPtr theklass = klass;</span>
<span class="line-added"> 188   if (theklass-&gt;is_objArray_klass()) {</span>
<span class="line-added"> 189     const ObjArrayKlass* obj_arr_klass = ObjArrayKlass::cast(klass);</span>
<span class="line-added"> 190     theklass = obj_arr_klass-&gt;bottom_klass();</span>
<span class="line-added"> 191   }</span>
<span class="line-added"> 192   if (theklass-&gt;is_instance_klass()) {</span>
<span class="line-added"> 193     pkg_id = package_id(theklass, leakp);</span>
<span class="line-added"> 194   } else {</span>
<span class="line-added"> 195     assert(theklass-&gt;is_typeArray_klass(), &quot;invariant&quot;);</span>
<span class="line-added"> 196   }</span>
<span class="line-added"> 197   writer-&gt;write(artifact_id(klass));</span>
<span class="line-added"> 198   writer-&gt;write(cld_id(get_cld(klass), leakp));</span>
<span class="line-added"> 199   writer-&gt;write(mark_symbol(klass, leakp));</span>
<span class="line-added"> 200   writer-&gt;write(pkg_id);</span>
<span class="line-added"> 201   writer-&gt;write(get_flags(klass));</span>
 202   return 1;
 203 }
 204 
<a name="32" id="anc32"></a><span class="line-modified"> 205 int write__klass(JfrCheckpointWriter* writer, const void* k) {</span>
<span class="line-modified"> 206   assert(k != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 207   KlassPtr klass = (KlassPtr)k;</span>
<span class="line-added"> 208   set_serialized(klass);</span>
<span class="line-added"> 209   return write_klass(writer, klass, false);</span>
 210 }
 211 
<a name="33" id="anc33"></a><span class="line-modified"> 212 int write__klass__leakp(JfrCheckpointWriter* writer, const void* k) {</span>





 213   assert(k != NULL, &quot;invariant&quot;);
<a name="34" id="anc34"></a><span class="line-modified"> 214   KlassPtr klass = (KlassPtr)k;</span>
<span class="line-modified"> 215   return write_klass(writer, klass, true);</span>








 216 }
 217 
<a name="35" id="anc35"></a><span class="line-modified"> 218 static bool is_implied(const Klass* klass) {</span>
<span class="line-modified"> 219   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 220   return klass-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass()) || klass == SystemDictionary::Object_klass();</span>
 221 }
 222 
<a name="36" id="anc36"></a><span class="line-modified"> 223 static void do_implied(Klass* klass) {</span>
<span class="line-modified"> 224   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 225   if (is_implied(klass)) {</span>
<span class="line-modified"> 226     if (_leakp_writer != NULL) {</span>
<span class="line-modified"> 227       SET_LEAKP(klass);</span>











































 228     }
<a name="37" id="anc37"></a><span class="line-modified"> 229     _subsystem_callback-&gt;do_artifact(klass);</span>
 230   }
<a name="38" id="anc38"></a>















 231 }
 232 
<a name="39" id="anc39"></a><span class="line-modified"> 233 static void do_unloaded_klass(Klass* klass) {</span>
<span class="line-modified"> 234   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 235   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 236   if (IS_JDK_JFR_EVENT_SUBKLASS(klass)) {</span>
<span class="line-modified"> 237     JfrEventClasses::increment_unloaded_event_class();</span>



























 238   }
<a name="40" id="anc40"></a><span class="line-modified"> 239   if (USED_THIS_EPOCH(klass)) {</span>
<span class="line-modified"> 240     ObjectSampleCheckpoint::on_klass_unload(klass);</span>
<span class="line-modified"> 241     _subsystem_callback-&gt;do_artifact(klass);</span>
<span class="line-modified"> 242     return;</span>



 243   }
<a name="41" id="anc41"></a><span class="line-modified"> 244   do_implied(klass);</span>
 245 }
 246 
<a name="42" id="anc42"></a><span class="line-modified"> 247 static void do_klass(Klass* klass) {</span>
<span class="line-modified"> 248   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 249   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 250   if (_flushpoint) {</span>
<span class="line-modified"> 251     if (USED_THIS_EPOCH(klass)) {</span>
<span class="line-modified"> 252       _subsystem_callback-&gt;do_artifact(klass);</span>
<span class="line-modified"> 253       return;</span>









 254     }
 255   } else {
<a name="43" id="anc43"></a><span class="line-modified"> 256     if (USED_PREV_EPOCH(klass)) {</span>
<span class="line-modified"> 257       _subsystem_callback-&gt;do_artifact(klass);</span>
<span class="line-modified"> 258       return;</span>






























 259     }
 260   }
<a name="44" id="anc44"></a><span class="line-modified"> 261   do_implied(klass);</span>
 262 }
 263 
<a name="45" id="anc45"></a><span class="line-modified"> 264 static void do_klasses() {</span>
<span class="line-modified"> 265   if (_class_unload) {</span>
<span class="line-added"> 266     ClassLoaderDataGraph::classes_unloading_do(&amp;do_unloaded_klass);</span>
<span class="line-added"> 267     return;</span>
<span class="line-added"> 268   }</span>
<span class="line-added"> 269   ClassLoaderDataGraph::classes_do(&amp;do_klass);</span>
<span class="line-added"> 270 }</span>
 271 
<a name="46" id="anc46"></a><span class="line-modified"> 272 typedef SerializePredicate&lt;KlassPtr&gt; KlassPredicate;</span>
<span class="line-modified"> 273 typedef JfrPredicatedTypeWriterImplHost&lt;KlassPtr, KlassPredicate, write__klass&gt; KlassWriterImpl;</span>
<span class="line-modified"> 274 typedef JfrTypeWriterHost&lt;KlassWriterImpl, TYPE_CLASS&gt; KlassWriter;</span>
<span class="line-modified"> 275 typedef CompositeFunctor&lt;KlassPtr, KlassWriter, KlassArtifactRegistrator&gt; KlassWriterRegistration;</span>
<span class="line-modified"> 276 typedef JfrArtifactCallbackHost&lt;KlassPtr, KlassWriterRegistration&gt; KlassCallback;</span>
 277 
<a name="47" id="anc47"></a><span class="line-modified"> 278 template &lt;&gt;</span>
<span class="line-modified"> 279 class LeakPredicate&lt;const Klass*&gt; {</span>
<span class="line-modified"> 280 public:</span>
<span class="line-modified"> 281   LeakPredicate(bool class_unload) {}</span>
<span class="line-modified"> 282   bool operator()(const Klass* klass) {</span>
<span class="line-modified"> 283     assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 284     return IS_LEAKP(klass) || is_implied(klass);</span>








 285   }
 286 };
 287 
<a name="48" id="anc48"></a><span class="line-modified"> 288 typedef LeakPredicate&lt;KlassPtr&gt; LeakKlassPredicate;</span>
<span class="line-modified"> 289 typedef JfrPredicatedTypeWriterImplHost&lt;KlassPtr, LeakKlassPredicate, write__klass__leakp&gt; LeakKlassWriterImpl;</span>
<span class="line-modified"> 290 typedef JfrTypeWriterHost&lt;LeakKlassWriterImpl, TYPE_CLASS&gt; LeakKlassWriter;</span>












 291 
<a name="49" id="anc49"></a><span class="line-modified"> 292 typedef CompositeFunctor&lt;KlassPtr, LeakKlassWriter, KlassWriter&gt; CompositeKlassWriter;</span>
<span class="line-added"> 293 typedef CompositeFunctor&lt;KlassPtr, CompositeKlassWriter, KlassArtifactRegistrator&gt; CompositeKlassWriterRegistration;</span>
 294 typedef JfrArtifactCallbackHost&lt;KlassPtr, CompositeKlassWriterRegistration&gt; CompositeKlassCallback;
 295 
<a name="50" id="anc50"></a><span class="line-modified"> 296 static bool write_klasses() {</span>










 297   assert(!_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);
<a name="51" id="anc51"></a><span class="line-added"> 298   assert(_writer != NULL, &quot;invariant&quot;);</span>
 299   KlassArtifactRegistrator reg(_artifacts);
<a name="52" id="anc52"></a><span class="line-modified"> 300   KlassWriter kw(_writer, _class_unload);</span>
 301   KlassWriterRegistration kwr(&amp;kw, &amp;reg);
<a name="53" id="anc53"></a><span class="line-modified"> 302   if (_leakp_writer == NULL) {</span>
 303     KlassCallback callback(&amp;kwr);
 304     _subsystem_callback = &amp;callback;
 305     do_klasses();
<a name="54" id="anc54"></a><span class="line-added"> 306   } else {</span>
<span class="line-added"> 307     LeakKlassWriter lkw(_leakp_writer, _class_unload);</span>
<span class="line-added"> 308     CompositeKlassWriter ckw(&amp;lkw, &amp;kw);</span>
<span class="line-added"> 309     CompositeKlassWriterRegistration ckwr(&amp;ckw, &amp;reg);</span>
<span class="line-added"> 310     CompositeKlassCallback callback(&amp;ckwr);</span>
<span class="line-added"> 311     _subsystem_callback = &amp;callback;</span>
<span class="line-added"> 312     do_klasses();</span>
<span class="line-added"> 313   }</span>
<span class="line-added"> 314   if (is_complete()) {</span>
<span class="line-added"> 315     return false;</span>
<span class="line-added"> 316   }</span>
<span class="line-added"> 317   _artifacts-&gt;tally(kw);</span>
<span class="line-added"> 318   return true;</span>
<span class="line-added"> 319 }</span>
<span class="line-added"> 320 </span>
<span class="line-added"> 321 template &lt;typename T&gt;</span>
<span class="line-added"> 322 static void do_previous_epoch_artifact(JfrArtifactClosure* callback, T* value) {</span>
<span class="line-added"> 323   assert(callback != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 324   assert(value != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 325   if (USED_PREV_EPOCH(value)) {</span>
<span class="line-added"> 326     callback-&gt;do_artifact(value);</span>
<span class="line-added"> 327     assert(IS_NOT_SERIALIZED(value), &quot;invariant&quot;);</span>
 328     return;
 329   }
<a name="55" id="anc55"></a><span class="line-modified"> 330   if (IS_SERIALIZED(value)) {</span>
<span class="line-modified"> 331     CLEAR_SERIALIZED(value);</span>
<span class="line-modified"> 332   }</span>
<span class="line-modified"> 333   assert(IS_NOT_SERIALIZED(value), &quot;invariant&quot;);</span>
<span class="line-modified"> 334 }</span>
<span class="line-modified"> 335 </span>
<span class="line-added"> 336 typedef JfrArtifactCallbackHost&lt;KlassPtr, KlassArtifactRegistrator&gt; RegistrationCallback;</span>
<span class="line-added"> 337 </span>
<span class="line-added"> 338 static void register_klass(Klass* klass) {</span>
<span class="line-added"> 339   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 340   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 341   do_previous_epoch_artifact(_subsystem_callback, klass);</span>
<span class="line-added"> 342 }</span>
<span class="line-added"> 343 </span>
<span class="line-added"> 344 static void do_register_klasses() {</span>
<span class="line-added"> 345   ClassLoaderDataGraph::classes_do(&amp;register_klass);</span>
<span class="line-added"> 346 }</span>
<span class="line-added"> 347 </span>
<span class="line-added"> 348 static void register_klasses() {</span>
<span class="line-added"> 349   assert(!_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);</span>
<span class="line-added"> 350   KlassArtifactRegistrator reg(_artifacts);</span>
<span class="line-added"> 351   RegistrationCallback callback(&amp;reg);</span>
 352   _subsystem_callback = &amp;callback;
<a name="56" id="anc56"></a><span class="line-modified"> 353   do_register_klasses();</span>
<span class="line-added"> 354 }</span>
<span class="line-added"> 355 </span>
<span class="line-added"> 356 static int write_package(JfrCheckpointWriter* writer, PkgPtr pkg, bool leakp) {</span>
<span class="line-added"> 357   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 358   assert(_artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 359   assert(pkg != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 360   writer-&gt;write(artifact_id(pkg));</span>
<span class="line-added"> 361   writer-&gt;write(mark_symbol(pkg-&gt;name(), leakp));</span>
<span class="line-added"> 362   writer-&gt;write(module_id(pkg, leakp));</span>
<span class="line-added"> 363   writer-&gt;write((bool)pkg-&gt;is_exported());</span>
<span class="line-added"> 364   return 1;</span>
<span class="line-added"> 365 }</span>
<span class="line-added"> 366 </span>
<span class="line-added"> 367 int write__package(JfrCheckpointWriter* writer, const void* p) {</span>
<span class="line-added"> 368   assert(p != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 369   PkgPtr pkg = (PkgPtr)p;</span>
<span class="line-added"> 370   set_serialized(pkg);</span>
<span class="line-added"> 371   return write_package(writer, pkg, false);</span>
 372 }
 373 
<a name="57" id="anc57"></a><span class="line-modified"> 374 int write__package__leakp(JfrCheckpointWriter* writer, const void* p) {</span>
<span class="line-modified"> 375   assert(p != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 376   PkgPtr pkg = (PkgPtr)p;</span>
<span class="line-added"> 377   CLEAR_LEAKP(pkg);</span>
<span class="line-added"> 378   return write_package(writer, pkg, true);</span>
<span class="line-added"> 379 }</span>
 380 
<a name="58" id="anc58"></a><span class="line-modified"> 381 static void do_package(PackageEntry* entry) {</span>
<span class="line-modified"> 382   do_previous_epoch_artifact(_subsystem_callback, entry);</span>
<span class="line-modified"> 383 }</span>
 384 
<a name="59" id="anc59"></a><span class="line-modified"> 385 static void do_packages() {</span>
<span class="line-modified"> 386   ClassLoaderDataGraph::packages_do(&amp;do_package);</span>
<span class="line-modified"> 387 }</span>
 388 
 389 class PackageFieldSelector {
 390  public:
 391   typedef PkgPtr TypePtr;
 392   static TypePtr select(KlassPtr klass) {
 393     assert(klass != NULL, &quot;invariant&quot;);
 394     return ((InstanceKlass*)klass)-&gt;package();
 395   }
 396 };
 397 
<a name="60" id="anc60"></a><span class="line-modified"> 398 typedef SerializePredicate&lt;PkgPtr&gt; PackagePredicate;</span>
<span class="line-modified"> 399 typedef JfrPredicatedTypeWriterImplHost&lt;PkgPtr, PackagePredicate, write__package&gt; PackageWriterImpl;</span>
<span class="line-added"> 400 typedef JfrTypeWriterHost&lt;PackageWriterImpl, TYPE_PACKAGE&gt; PackageWriter;</span>
<span class="line-added"> 401 typedef CompositeFunctor&lt;PkgPtr, PackageWriter, ClearArtifact&lt;PkgPtr&gt; &gt; PackageWriterWithClear;</span>
<span class="line-added"> 402 typedef KlassToFieldEnvelope&lt;PackageFieldSelector, PackageWriter&gt; KlassPackageWriter;</span>
<span class="line-added"> 403 typedef JfrArtifactCallbackHost&lt;PkgPtr, PackageWriterWithClear&gt; PackageCallback;</span>
 404 
<a name="61" id="anc61"></a><span class="line-modified"> 405 typedef LeakPredicate&lt;PkgPtr&gt; LeakPackagePredicate;</span>
<span class="line-modified"> 406 typedef JfrPredicatedTypeWriterImplHost&lt;PkgPtr, LeakPackagePredicate, write__package__leakp&gt; LeakPackageWriterImpl;</span>
<span class="line-added"> 407 typedef JfrTypeWriterHost&lt;LeakPackageWriterImpl, TYPE_PACKAGE&gt; LeakPackageWriter;</span>
 408 
<a name="62" id="anc62"></a><span class="line-modified"> 409 typedef CompositeFunctor&lt;PkgPtr, LeakPackageWriter, PackageWriter&gt; CompositePackageWriter;</span>
<span class="line-added"> 410 typedef KlassToFieldEnvelope&lt;PackageFieldSelector, CompositePackageWriter&gt; KlassCompositePackageWriter;</span>
<span class="line-added"> 411 typedef KlassToFieldEnvelope&lt;PackageFieldSelector, PackageWriterWithClear&gt; KlassPackageWriterWithClear;</span>
<span class="line-added"> 412 typedef CompositeFunctor&lt;PkgPtr, CompositePackageWriter, ClearArtifact&lt;PkgPtr&gt; &gt; CompositePackageWriterWithClear;</span>
 413 typedef JfrArtifactCallbackHost&lt;PkgPtr, CompositePackageWriterWithClear&gt; CompositePackageCallback;
 414 
<a name="63" id="anc63"></a><span class="line-modified"> 415 static void write_packages() {</span>
<span class="line-modified"> 416   assert(_writer != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 417   PackageWriter pw(_writer, _class_unload);</span>
<span class="line-modified"> 418   KlassPackageWriter kpw(&amp;pw);</span>
<span class="line-modified"> 419   if (current_epoch()) {</span>
<span class="line-modified"> 420     _artifacts-&gt;iterate_klasses(kpw);</span>
<span class="line-modified"> 421     _artifacts-&gt;tally(pw);</span>
<span class="line-modified"> 422     return;</span>
<span class="line-modified"> 423   }</span>
<span class="line-modified"> 424   assert(previous_epoch(), &quot;invariant&quot;);</span>
<span class="line-modified"> 425   if (_leakp_writer == NULL) {</span>
<span class="line-modified"> 426     _artifacts-&gt;iterate_klasses(kpw);</span>
<span class="line-modified"> 427     ClearArtifact&lt;PkgPtr&gt; clear;</span>
 428     PackageWriterWithClear pwwc(&amp;pw, &amp;clear);
<a name="64" id="anc64"></a>

 429     PackageCallback callback(&amp;pwwc);
 430     _subsystem_callback = &amp;callback;
 431     do_packages();
<a name="65" id="anc65"></a><span class="line-modified"> 432   } else {</span>
<span class="line-added"> 433     LeakPackageWriter lpw(_leakp_writer, _class_unload);</span>
<span class="line-added"> 434     CompositePackageWriter cpw(&amp;lpw, &amp;pw);</span>
<span class="line-added"> 435     KlassCompositePackageWriter kcpw(&amp;cpw);</span>
<span class="line-added"> 436     _artifacts-&gt;iterate_klasses(kcpw);</span>
<span class="line-added"> 437     ClearArtifact&lt;PkgPtr&gt; clear;</span>
<span class="line-added"> 438     CompositePackageWriterWithClear cpwwc(&amp;cpw, &amp;clear);</span>
<span class="line-added"> 439     CompositePackageCallback callback(&amp;cpwwc);</span>
<span class="line-added"> 440     _subsystem_callback = &amp;callback;</span>
<span class="line-added"> 441     do_packages();</span>
 442   }
<a name="66" id="anc66"></a><span class="line-modified"> 443   _artifacts-&gt;tally(pw);</span>
<span class="line-modified"> 444 }</span>
<span class="line-modified"> 445 </span>
<span class="line-modified"> 446 typedef JfrArtifactCallbackHost&lt;PkgPtr, ClearArtifact&lt;PkgPtr&gt; &gt; ClearPackageCallback;</span>
<span class="line-modified"> 447 </span>
<span class="line-modified"> 448 static void clear_packages() {</span>
<span class="line-added"> 449   ClearArtifact&lt;PkgPtr&gt; clear;</span>
<span class="line-added"> 450   ClearPackageCallback callback(&amp;clear);</span>
 451   _subsystem_callback = &amp;callback;
 452   do_packages();
 453 }
 454 
<a name="67" id="anc67"></a><span class="line-modified"> 455 static int write_module(JfrCheckpointWriter* writer, ModPtr mod, bool leakp) {</span>
<span class="line-modified"> 456   assert(mod != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 457   assert(_artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 458   writer-&gt;write(artifact_id(mod));</span>
<span class="line-added"> 459   writer-&gt;write(mark_symbol(mod-&gt;name(), leakp));</span>
<span class="line-added"> 460   writer-&gt;write(mark_symbol(mod-&gt;version(), leakp));</span>
<span class="line-added"> 461   writer-&gt;write(mark_symbol(mod-&gt;location(), leakp));</span>
<span class="line-added"> 462   writer-&gt;write(cld_id(mod-&gt;loader_data(), leakp));</span>
<span class="line-added"> 463   return 1;</span>
<span class="line-added"> 464 }</span>
 465 
<a name="68" id="anc68"></a><span class="line-modified"> 466 int write__module(JfrCheckpointWriter* writer, const void* m) {</span>
<span class="line-modified"> 467   assert(m != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 468   ModPtr mod = (ModPtr)m;</span>
<span class="line-added"> 469   set_serialized(mod);</span>
<span class="line-added"> 470   return write_module(writer, mod, false);</span>
<span class="line-added"> 471 }</span>
 472 
<a name="69" id="anc69"></a><span class="line-modified"> 473 int write__module__leakp(JfrCheckpointWriter* writer, const void* m) {</span>
<span class="line-modified"> 474   assert(m != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 475   ModPtr mod = (ModPtr)m;</span>
<span class="line-added"> 476   CLEAR_LEAKP(mod);</span>
<span class="line-added"> 477   return write_module(writer, mod, true);</span>
<span class="line-added"> 478 }</span>
 479 
<a name="70" id="anc70"></a><span class="line-modified"> 480 static void do_module(ModuleEntry* entry) {</span>
<span class="line-modified"> 481   do_previous_epoch_artifact(_subsystem_callback, entry);</span>
<span class="line-added"> 482 }</span>
<span class="line-added"> 483 </span>
<span class="line-added"> 484 static void do_modules() {</span>
<span class="line-added"> 485   ClassLoaderDataGraph::modules_do(&amp;do_module);</span>
<span class="line-added"> 486 }</span>
 487 
 488 class ModuleFieldSelector {
 489  public:
 490   typedef ModPtr TypePtr;
 491   static TypePtr select(KlassPtr klass) {
 492     assert(klass != NULL, &quot;invariant&quot;);
 493     PkgPtr pkg = klass-&gt;package();
 494     return pkg != NULL ? pkg-&gt;module() : NULL;
 495   }
 496 };
 497 
<a name="71" id="anc71"></a><span class="line-modified"> 498 typedef SerializePredicate&lt;ModPtr&gt; ModulePredicate;</span>
<span class="line-modified"> 499 typedef JfrPredicatedTypeWriterImplHost&lt;ModPtr, ModulePredicate, write__module&gt; ModuleWriterImpl;</span>
<span class="line-added"> 500 typedef JfrTypeWriterHost&lt;ModuleWriterImpl, TYPE_MODULE&gt; ModuleWriter;</span>
<span class="line-added"> 501 typedef CompositeFunctor&lt;ModPtr, ModuleWriter, ClearArtifact&lt;ModPtr&gt; &gt; ModuleWriterWithClear;</span>
<span class="line-added"> 502 typedef JfrArtifactCallbackHost&lt;ModPtr, ModuleWriterWithClear&gt; ModuleCallback;</span>
<span class="line-added"> 503 typedef KlassToFieldEnvelope&lt;ModuleFieldSelector, ModuleWriter&gt; KlassModuleWriter;</span>
 504 
<a name="72" id="anc72"></a><span class="line-modified"> 505 typedef LeakPredicate&lt;ModPtr&gt; LeakModulePredicate;</span>
<span class="line-modified"> 506 typedef JfrPredicatedTypeWriterImplHost&lt;ModPtr, LeakModulePredicate, write__module__leakp&gt; LeakModuleWriterImpl;</span>
<span class="line-added"> 507 typedef JfrTypeWriterHost&lt;LeakModuleWriterImpl, TYPE_MODULE&gt; LeakModuleWriter;</span>
 508 
<a name="73" id="anc73"></a><span class="line-modified"> 509 typedef CompositeFunctor&lt;ModPtr, LeakModuleWriter, ModuleWriter&gt; CompositeModuleWriter;</span>
<span class="line-modified"> 510 typedef KlassToFieldEnvelope&lt;ModuleFieldSelector, CompositeModuleWriter&gt; KlassCompositeModuleWriter;</span>
<span class="line-modified"> 511 typedef CompositeFunctor&lt;ModPtr, CompositeModuleWriter, ClearArtifact&lt;ModPtr&gt; &gt; CompositeModuleWriterWithClear;</span>
<span class="line-modified"> 512 typedef JfrArtifactCallbackHost&lt;ModPtr, CompositeModuleWriterWithClear&gt; CompositeModuleCallback;</span>
<span class="line-modified"> 513 </span>
<span class="line-modified"> 514 static void write_modules() {</span>
<span class="line-modified"> 515   assert(_writer != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 516   ModuleWriter mw(_writer, _class_unload);</span>
<span class="line-modified"> 517   KlassModuleWriter kmw(&amp;mw);</span>
<span class="line-modified"> 518   if (current_epoch()) {</span>
<span class="line-modified"> 519     _artifacts-&gt;iterate_klasses(kmw);</span>
<span class="line-modified"> 520     _artifacts-&gt;tally(mw);</span>
<span class="line-added"> 521     return;</span>
<span class="line-added"> 522   }</span>
<span class="line-added"> 523   assert(previous_epoch(), &quot;invariant&quot;);</span>
<span class="line-added"> 524   if (_leakp_writer == NULL) {</span>
<span class="line-added"> 525     _artifacts-&gt;iterate_klasses(kmw);</span>
<span class="line-added"> 526     ClearArtifact&lt;ModPtr&gt; clear;</span>
 527     ModuleWriterWithClear mwwc(&amp;mw, &amp;clear);
<a name="74" id="anc74"></a>

 528     ModuleCallback callback(&amp;mwwc);
 529     _subsystem_callback = &amp;callback;
 530     do_modules();
<a name="75" id="anc75"></a><span class="line-modified"> 531   } else {</span>
<span class="line-added"> 532     LeakModuleWriter lmw(_leakp_writer, _class_unload);</span>
<span class="line-added"> 533     CompositeModuleWriter cmw(&amp;lmw, &amp;mw);</span>
<span class="line-added"> 534     KlassCompositeModuleWriter kcpw(&amp;cmw);</span>
<span class="line-added"> 535     _artifacts-&gt;iterate_klasses(kcpw);</span>
<span class="line-added"> 536     ClearArtifact&lt;ModPtr&gt; clear;</span>
<span class="line-added"> 537     CompositeModuleWriterWithClear cmwwc(&amp;cmw, &amp;clear);</span>
<span class="line-added"> 538     CompositeModuleCallback callback(&amp;cmwwc);</span>
<span class="line-added"> 539     _subsystem_callback = &amp;callback;</span>
<span class="line-added"> 540     do_modules();</span>
 541   }
<a name="76" id="anc76"></a><span class="line-modified"> 542   _artifacts-&gt;tally(mw);</span>
<span class="line-modified"> 543 }</span>
<span class="line-modified"> 544 </span>
<span class="line-modified"> 545 typedef JfrArtifactCallbackHost&lt;ModPtr, ClearArtifact&lt;ModPtr&gt; &gt; ClearModuleCallback;</span>
<span class="line-modified"> 546 </span>
<span class="line-modified"> 547 static void clear_modules() {</span>
<span class="line-added"> 548   ClearArtifact&lt;ModPtr&gt; clear;</span>
<span class="line-added"> 549   ClearModuleCallback callback(&amp;clear);</span>
 550   _subsystem_callback = &amp;callback;
 551   do_modules();
 552 }
 553 
<a name="77" id="anc77"></a><span class="line-modified"> 554 static int write_classloader(JfrCheckpointWriter* writer, CldPtr cld, bool leakp) {</span>
<span class="line-modified"> 555   assert(cld != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 556   assert(!cld-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);</span>
<span class="line-modified"> 557   // class loader type</span>
<span class="line-modified"> 558   const Klass* class_loader_klass = cld-&gt;class_loader_klass();</span>
<span class="line-added"> 559   if (class_loader_klass == NULL) {</span>
<span class="line-added"> 560     // (primordial) boot class loader</span>
<span class="line-added"> 561     writer-&gt;write(artifact_id(cld)); // class loader instance id</span>
<span class="line-added"> 562     writer-&gt;write((traceid)0);  // class loader type id (absence of)</span>
<span class="line-added"> 563     writer-&gt;write(get_bootstrap_name(leakp)); // maps to synthetic name -&gt; &quot;bootstrap&quot;</span>
<span class="line-added"> 564   } else {</span>
<span class="line-added"> 565     writer-&gt;write(artifact_id(cld)); // class loader instance id</span>
<span class="line-added"> 566     writer-&gt;write(artifact_id(class_loader_klass)); // class loader type id</span>
<span class="line-added"> 567     writer-&gt;write(mark_symbol(cld-&gt;name(), leakp)); // class loader instance name</span>
<span class="line-added"> 568   }</span>
<span class="line-added"> 569   return 1;</span>
<span class="line-added"> 570 }</span>
<span class="line-added"> 571 </span>
<span class="line-added"> 572 int write__classloader(JfrCheckpointWriter* writer, const void* c) {</span>
<span class="line-added"> 573   assert(c != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 574   CldPtr cld = (CldPtr)c;</span>
<span class="line-added"> 575   set_serialized(cld);</span>
<span class="line-added"> 576   return write_classloader(writer, cld, false);</span>
<span class="line-added"> 577 }</span>
<span class="line-added"> 578 </span>
<span class="line-added"> 579 int write__classloader__leakp(JfrCheckpointWriter* writer, const void* c) {</span>
<span class="line-added"> 580   assert(c != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 581   CldPtr cld = (CldPtr)c;</span>
<span class="line-added"> 582   CLEAR_LEAKP(cld);</span>
<span class="line-added"> 583   return write_classloader(writer, cld, true);</span>
<span class="line-added"> 584 }</span>
 585 
<a name="78" id="anc78"></a><span class="line-modified"> 586 static void do_class_loader_data(ClassLoaderData* cld) {</span>
<span class="line-added"> 587   do_previous_epoch_artifact(_subsystem_callback, cld);</span>
<span class="line-added"> 588 }</span>
<span class="line-added"> 589 </span>
<span class="line-added"> 590 class KlassCldFieldSelector {</span>
 591  public:
 592   typedef CldPtr TypePtr;
 593   static TypePtr select(KlassPtr klass) {
 594     assert(klass != NULL, &quot;invariant&quot;);
<a name="79" id="anc79"></a><span class="line-modified"> 595     return get_cld(klass);</span>

 596   }
 597 };
 598 
<a name="80" id="anc80"></a><span class="line-modified"> 599 class ModuleCldFieldSelector {</span>
<span class="line-modified"> 600 public:</span>
<span class="line-added"> 601   typedef CldPtr TypePtr;</span>
<span class="line-added"> 602   static TypePtr select(KlassPtr klass) {</span>
<span class="line-added"> 603     assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 604     ModPtr mod = ModuleFieldSelector::select(klass);</span>
<span class="line-added"> 605     return mod != NULL ? mod-&gt;loader_data() : NULL;</span>
<span class="line-added"> 606   }</span>
<span class="line-added"> 607 };</span>
 608 
<a name="81" id="anc81"></a><span class="line-modified"> 609 class CLDCallback : public CLDClosure {</span>
<span class="line-modified"> 610  public:</span>
<span class="line-modified"> 611   CLDCallback() {}</span>
<span class="line-modified"> 612   void do_cld(ClassLoaderData* cld) {</span>
<span class="line-modified"> 613     assert(cld != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 614     if (cld-&gt;is_unsafe_anonymous()) {</span>
<span class="line-modified"> 615       return;</span>
<span class="line-modified"> 616     }</span>
<span class="line-modified"> 617     do_class_loader_data(cld);</span>
<span class="line-modified"> 618   }</span>
<span class="line-modified"> 619 };</span>
<span class="line-modified"> 620 </span>
<span class="line-added"> 621 static void do_class_loaders() {</span>
<span class="line-added"> 622   CLDCallback cld_cb;</span>
<span class="line-added"> 623   ClassLoaderDataGraph::loaded_cld_do(&amp;cld_cb);</span>
<span class="line-added"> 624 }</span>
<span class="line-added"> 625 </span>
<span class="line-added"> 626 typedef SerializePredicate&lt;CldPtr&gt; CldPredicate;</span>
<span class="line-added"> 627 typedef JfrPredicatedTypeWriterImplHost&lt;CldPtr, CldPredicate, write__classloader&gt; CldWriterImpl;</span>
<span class="line-added"> 628 typedef JfrTypeWriterHost&lt;CldWriterImpl, TYPE_CLASSLOADER&gt; CldWriter;</span>
<span class="line-added"> 629 typedef CompositeFunctor&lt;CldPtr, CldWriter, ClearArtifact&lt;CldPtr&gt; &gt; CldWriterWithClear;</span>
<span class="line-added"> 630 typedef JfrArtifactCallbackHost&lt;CldPtr, CldWriterWithClear&gt; CldCallback;</span>
<span class="line-added"> 631 typedef KlassToFieldEnvelope&lt;KlassCldFieldSelector, CldWriter&gt; KlassCldWriter;</span>
<span class="line-added"> 632 typedef KlassToFieldEnvelope&lt;ModuleCldFieldSelector, CldWriter&gt; ModuleCldWriter;</span>
<span class="line-added"> 633 typedef CompositeFunctor&lt;KlassPtr, KlassCldWriter, ModuleCldWriter&gt; KlassAndModuleCldWriter;</span>
<span class="line-added"> 634 </span>
<span class="line-added"> 635 typedef LeakPredicate&lt;CldPtr&gt; LeakCldPredicate;</span>
<span class="line-added"> 636 typedef JfrPredicatedTypeWriterImplHost&lt;CldPtr, LeakCldPredicate, write__classloader__leakp&gt; LeakCldWriterImpl;</span>
<span class="line-added"> 637 typedef JfrTypeWriterHost&lt;LeakCldWriterImpl, TYPE_CLASSLOADER&gt; LeakCldWriter;</span>
<span class="line-added"> 638 </span>
<span class="line-added"> 639 typedef CompositeFunctor&lt;CldPtr, LeakCldWriter, CldWriter&gt; CompositeCldWriter;</span>
<span class="line-added"> 640 typedef KlassToFieldEnvelope&lt;KlassCldFieldSelector, CompositeCldWriter&gt; KlassCompositeCldWriter;</span>
<span class="line-added"> 641 typedef KlassToFieldEnvelope&lt;ModuleCldFieldSelector, CompositeCldWriter&gt; ModuleCompositeCldWriter;</span>
<span class="line-added"> 642 typedef CompositeFunctor&lt;KlassPtr, KlassCompositeCldWriter, ModuleCompositeCldWriter&gt; KlassAndModuleCompositeCldWriter;</span>
<span class="line-added"> 643 typedef CompositeFunctor&lt;CldPtr, CompositeCldWriter, ClearArtifact&lt;CldPtr&gt; &gt; CompositeCldWriterWithClear;</span>
<span class="line-added"> 644 typedef JfrArtifactCallbackHost&lt;CldPtr, CompositeCldWriterWithClear&gt; CompositeCldCallback;</span>
<span class="line-added"> 645 </span>
<span class="line-added"> 646 static void write_classloaders() {</span>
<span class="line-added"> 647   assert(_writer != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 648   CldWriter cldw(_writer, _class_unload);</span>
<span class="line-added"> 649   KlassCldWriter kcw(&amp;cldw);</span>
<span class="line-added"> 650   ModuleCldWriter mcw(&amp;cldw);</span>
<span class="line-added"> 651   KlassAndModuleCldWriter kmcw(&amp;kcw, &amp;mcw);</span>
<span class="line-added"> 652   if (current_epoch()) {</span>
<span class="line-added"> 653     _artifacts-&gt;iterate_klasses(kmcw);</span>
<span class="line-added"> 654     _artifacts-&gt;tally(cldw);</span>
<span class="line-added"> 655     return;</span>
<span class="line-added"> 656   }</span>
<span class="line-added"> 657   assert(previous_epoch(), &quot;invariant&quot;);</span>
<span class="line-added"> 658   if (_leakp_writer == NULL) {</span>
<span class="line-added"> 659     _artifacts-&gt;iterate_klasses(kmcw);</span>
<span class="line-added"> 660     ClearArtifact&lt;CldPtr&gt; clear;</span>
 661     CldWriterWithClear cldwwc(&amp;cldw, &amp;clear);
<a name="82" id="anc82"></a>

 662     CldCallback callback(&amp;cldwwc);
 663     _subsystem_callback = &amp;callback;
 664     do_class_loaders();
<a name="83" id="anc83"></a><span class="line-modified"> 665   } else {</span>
<span class="line-added"> 666     LeakCldWriter lcldw(_leakp_writer, _class_unload);</span>
<span class="line-added"> 667     CompositeCldWriter ccldw(&amp;lcldw, &amp;cldw);</span>
<span class="line-added"> 668     KlassCompositeCldWriter kccldw(&amp;ccldw);</span>
<span class="line-added"> 669     ModuleCompositeCldWriter mccldw(&amp;ccldw);</span>
<span class="line-added"> 670     KlassAndModuleCompositeCldWriter kmccldw(&amp;kccldw, &amp;mccldw);</span>
<span class="line-added"> 671     _artifacts-&gt;iterate_klasses(kmccldw);</span>
<span class="line-added"> 672     ClearArtifact&lt;CldPtr&gt; clear;</span>
<span class="line-added"> 673     CompositeCldWriterWithClear ccldwwc(&amp;ccldw, &amp;clear);</span>
<span class="line-added"> 674     CompositeCldCallback callback(&amp;ccldwwc);</span>
<span class="line-added"> 675     _subsystem_callback = &amp;callback;</span>
<span class="line-added"> 676     do_class_loaders();</span>
 677   }
<a name="84" id="anc84"></a><span class="line-modified"> 678   _artifacts-&gt;tally(cldw);</span>
<span class="line-modified"> 679 }</span>
<span class="line-modified"> 680 </span>
<span class="line-modified"> 681 typedef JfrArtifactCallbackHost&lt;CldPtr, ClearArtifact&lt;CldPtr&gt; &gt; ClearCLDCallback;</span>
<span class="line-modified"> 682 </span>
<span class="line-modified"> 683 static void clear_classloaders() {</span>
<span class="line-added"> 684   ClearArtifact&lt;CldPtr&gt; clear;</span>
<span class="line-added"> 685   ClearCLDCallback callback(&amp;clear);</span>
 686   _subsystem_callback = &amp;callback;
 687   do_class_loaders();
 688 }
 689 
<a name="85" id="anc85"></a><span class="line-modified"> 690 static u1 get_visibility(MethodPtr method) {</span>
<span class="line-added"> 691   assert(method != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 692   return const_cast&lt;Method*&gt;(method)-&gt;is_hidden() ? (u1)1 : (u1)0;</span>
<span class="line-added"> 693 }</span>
<span class="line-added"> 694 </span>
<span class="line-added"> 695 template &lt;&gt;</span>
<span class="line-added"> 696 void set_serialized&lt;Method&gt;(MethodPtr method) {</span>
<span class="line-added"> 697   assert(method != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 698   SET_METHOD_SERIALIZED(method);</span>
<span class="line-added"> 699   assert(IS_METHOD_SERIALIZED(method), &quot;invariant&quot;);</span>
<span class="line-added"> 700   CLEAR_THIS_EPOCH_METHOD_CLEARED_BIT(method);</span>
<span class="line-added"> 701 }</span>
<span class="line-added"> 702 </span>
<span class="line-added"> 703 static int write_method(JfrCheckpointWriter* writer, MethodPtr method, bool leakp) {</span>
<span class="line-added"> 704   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 705   assert(method != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 706   assert(_artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 707   KlassPtr klass = method-&gt;method_holder();</span>
<span class="line-added"> 708   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 709   writer-&gt;write(method_id(klass, method));</span>
<span class="line-added"> 710   writer-&gt;write(artifact_id(klass));</span>
<span class="line-added"> 711   writer-&gt;write(mark_symbol(method-&gt;name(), leakp));</span>
<span class="line-added"> 712   writer-&gt;write(mark_symbol(method-&gt;signature(), leakp));</span>
<span class="line-added"> 713   writer-&gt;write((u2)get_flags(method));</span>
<span class="line-added"> 714   writer-&gt;write(get_visibility(method));</span>
<span class="line-added"> 715   return 1;</span>
<span class="line-added"> 716 }</span>
<span class="line-added"> 717 </span>
<span class="line-added"> 718 int write__method(JfrCheckpointWriter* writer, const void* m) {</span>
<span class="line-added"> 719   assert(m != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 720   MethodPtr method = (MethodPtr)m;</span>
<span class="line-added"> 721   set_serialized(method);</span>
<span class="line-added"> 722   return write_method(writer, method, false);</span>
<span class="line-added"> 723 }</span>
<span class="line-added"> 724 </span>
<span class="line-added"> 725 int write__method__leakp(JfrCheckpointWriter* writer, const void* m) {</span>
<span class="line-added"> 726   assert(m != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 727   MethodPtr method = (MethodPtr)m;</span>
<span class="line-added"> 728   return write_method(writer, method, true);</span>
<span class="line-added"> 729 }</span>
<span class="line-added"> 730 </span>
<span class="line-added"> 731 class BitMapFilter {</span>
<span class="line-added"> 732   ResourceBitMap _bitmap;</span>
<span class="line-added"> 733  public:</span>
<span class="line-added"> 734   explicit BitMapFilter(int length = 0) : _bitmap((size_t)length) {}</span>
<span class="line-added"> 735   bool operator()(size_t idx) {</span>
<span class="line-added"> 736     if (_bitmap.size() == 0) {</span>
<span class="line-added"> 737       return true;</span>
<span class="line-added"> 738     }</span>
<span class="line-added"> 739     if (_bitmap.at(idx)) {</span>
<span class="line-added"> 740       return false;</span>
<span class="line-added"> 741     }</span>
<span class="line-added"> 742     _bitmap.set_bit(idx);</span>
<span class="line-added"> 743     return true;</span>
<span class="line-added"> 744   }</span>
<span class="line-added"> 745 };</span>
<span class="line-added"> 746 </span>
<span class="line-added"> 747 class AlwaysTrue {</span>
<span class="line-added"> 748  public:</span>
<span class="line-added"> 749   explicit AlwaysTrue(int length = 0) {}</span>
<span class="line-added"> 750   bool operator()(size_t idx) {</span>
<span class="line-added"> 751     return true;</span>
<span class="line-added"> 752   }</span>
<span class="line-added"> 753 };</span>
<span class="line-added"> 754 </span>
<span class="line-added"> 755 template &lt;typename MethodCallback, typename KlassCallback, class Filter, bool leakp&gt;</span>
 756 class MethodIteratorHost {
 757  private:
<a name="86" id="anc86"></a><span class="line-modified"> 758   MethodCallback _method_cb;</span>
<span class="line-modified"> 759   KlassCallback _klass_cb;</span>
<span class="line-modified"> 760   MethodUsedPredicate&lt;leakp&gt; _method_used_predicate;</span>
<span class="line-modified"> 761   MethodFlagPredicate&lt;leakp&gt; _method_flag_predicate;</span>
 762  public:
 763   MethodIteratorHost(JfrCheckpointWriter* writer,
<a name="87" id="anc87"></a><span class="line-modified"> 764                      bool current_epoch = false,</span>
<span class="line-modified"> 765                      bool class_unload = false,</span>
 766                      bool skip_header = false) :
<a name="88" id="anc88"></a><span class="line-modified"> 767     _method_cb(writer, class_unload, skip_header),</span>
<span class="line-modified"> 768     _klass_cb(writer, class_unload, skip_header),</span>
<span class="line-modified"> 769     _method_used_predicate(current_epoch),</span>
<span class="line-added"> 770     _method_flag_predicate(current_epoch) {}</span>
 771 
 772   bool operator()(KlassPtr klass) {
 773     if (_method_used_predicate(klass)) {
<a name="89" id="anc89"></a>
 774       const InstanceKlass* ik = InstanceKlass::cast(klass);
 775       const int len = ik-&gt;methods()-&gt;length();
<a name="90" id="anc90"></a><span class="line-modified"> 776       Filter filter(ik-&gt;previous_versions() != NULL ? len : 0);</span>
<span class="line-modified"> 777       while (ik != NULL) {</span>
<span class="line-modified"> 778         for (int i = 0; i &lt; len; ++i) {</span>
<span class="line-modified"> 779           MethodPtr method = ik-&gt;methods()-&gt;at(i);</span>
<span class="line-added"> 780           if (_method_flag_predicate(method) &amp;&amp; filter(i)) {</span>
<span class="line-added"> 781             _method_cb(method);</span>
<span class="line-added"> 782           }</span>
 783         }
<a name="91" id="anc91"></a><span class="line-added"> 784         // There can be multiple versions of the same method running</span>
<span class="line-added"> 785         // due to redefinition. Need to inspect the complete set of methods.</span>
<span class="line-added"> 786         ik = ik-&gt;previous_versions();</span>
 787       }
 788     }
<a name="92" id="anc92"></a><span class="line-modified"> 789     return _klass_cb(klass);</span>
 790   }
 791 
<a name="93" id="anc93"></a><span class="line-modified"> 792   int count() const { return _method_cb.count(); }</span>
<span class="line-modified"> 793   void add(int count) { _method_cb.add(count); }</span>
 794 };
 795 
<a name="94" id="anc94"></a><span class="line-modified"> 796 template &lt;typename T, template &lt;typename&gt; class Impl&gt;</span>
<span class="line-modified"> 797 class Wrapper {</span>
<span class="line-modified"> 798   Impl&lt;T&gt; _t;</span>
<span class="line-modified"> 799  public:</span>
<span class="line-modified"> 800   Wrapper(JfrCheckpointWriter*, bool, bool) : _t() {}</span>
<span class="line-modified"> 801   bool operator()(T const&amp; value) {</span>
<span class="line-modified"> 802     return _t(value);</span>

























 803   }
<a name="95" id="anc95"></a><span class="line-modified"> 804 };</span>






 805 
<a name="96" id="anc96"></a><span class="line-modified"> 806 template &lt;typename T&gt;</span>
<span class="line-modified"> 807 class EmptyStub {</span>
<span class="line-modified"> 808  public:</span>
<span class="line-added"> 809   bool operator()(T const&amp; value) { return true; }</span>
<span class="line-added"> 810 };</span>
 811 
<a name="97" id="anc97"></a><span class="line-modified"> 812 typedef SerializePredicate&lt;MethodPtr&gt; MethodPredicate;</span>
<span class="line-modified"> 813 typedef JfrPredicatedTypeWriterImplHost&lt;MethodPtr, MethodPredicate, write__method&gt; MethodWriterImplTarget;</span>
<span class="line-modified"> 814 typedef Wrapper&lt;KlassPtr, EmptyStub&gt; KlassCallbackStub;</span>
<span class="line-modified"> 815 typedef JfrTypeWriterHost&lt;MethodWriterImplTarget, TYPE_METHOD&gt; MethodWriterImpl;</span>
<span class="line-modified"> 816 typedef MethodIteratorHost&lt;MethodWriterImpl, KlassCallbackStub, BitMapFilter, false&gt; MethodWriter;</span>
<span class="line-added"> 817 </span>
<span class="line-added"> 818 typedef LeakPredicate&lt;MethodPtr&gt; LeakMethodPredicate;</span>
<span class="line-added"> 819 typedef JfrPredicatedTypeWriterImplHost&lt;MethodPtr, LeakMethodPredicate, write__method__leakp&gt; LeakMethodWriterImplTarget;</span>
<span class="line-added"> 820 typedef JfrTypeWriterHost&lt;LeakMethodWriterImplTarget, TYPE_METHOD&gt; LeakMethodWriterImpl;</span>
<span class="line-added"> 821 typedef MethodIteratorHost&lt;LeakMethodWriterImpl, KlassCallbackStub, BitMapFilter, true&gt; LeakMethodWriter;</span>
<span class="line-added"> 822 typedef MethodIteratorHost&lt;LeakMethodWriterImpl, KlassCallbackStub, BitMapFilter, true&gt; LeakMethodWriter;</span>
<span class="line-added"> 823 typedef CompositeFunctor&lt;KlassPtr, LeakMethodWriter, MethodWriter&gt; CompositeMethodWriter;</span>
 824 
<a name="98" id="anc98"></a><span class="line-modified"> 825 static void write_methods() {</span>
<span class="line-modified"> 826   assert(_writer != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 827   MethodWriter mw(_writer, current_epoch(), _class_unload);</span>
<span class="line-modified"> 828   if (_leakp_writer == NULL) {</span>
<span class="line-modified"> 829     _artifacts-&gt;iterate_klasses(mw);</span>
<span class="line-modified"> 830   } else {</span>
<span class="line-modified"> 831     LeakMethodWriter lpmw(_leakp_writer, current_epoch(), _class_unload);</span>
<span class="line-modified"> 832     CompositeMethodWriter cmw(&amp;lpmw, &amp;mw);</span>
<span class="line-modified"> 833     _artifacts-&gt;iterate_klasses(cmw);</span>




 834   }
<a name="99" id="anc99"></a><span class="line-added"> 835   _artifacts-&gt;tally(mw);</span>
 836 }
 837 
<a name="100" id="anc100"></a><span class="line-modified"> 838 template &lt;&gt;</span>
<span class="line-modified"> 839 void set_serialized&lt;JfrSymbolId::SymbolEntry&gt;(SymbolEntryPtr ptr) {</span>
<span class="line-modified"> 840   assert(ptr != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 841   ptr-&gt;set_serialized();</span>
<span class="line-modified"> 842   assert(ptr-&gt;is_serialized(), &quot;invariant&quot;);</span>






 843 }
 844 
<a name="101" id="anc101"></a><span class="line-modified"> 845 template &lt;&gt;</span>
<span class="line-modified"> 846 void set_serialized&lt;JfrSymbolId::CStringEntry&gt;(CStringEntryPtr ptr) {</span>
<span class="line-modified"> 847   assert(ptr != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 848   ptr-&gt;set_serialized();</span>
<span class="line-modified"> 849   assert(ptr-&gt;is_serialized(), &quot;invariant&quot;);</span>

 850 }
 851 
<a name="102" id="anc102"></a><span class="line-modified"> 852 static int write_symbol(JfrCheckpointWriter* writer, SymbolEntryPtr entry, bool leakp) {</span>
<span class="line-added"> 853   assert(writer != NULL, &quot;invariant&quot;);</span>
 854   assert(entry != NULL, &quot;invariant&quot;);
<a name="103" id="anc103"></a><span class="line-modified"> 855   ResourceMark rm;</span>
<span class="line-modified"> 856   writer-&gt;write(create_symbol_id(entry-&gt;id()));</span>
<span class="line-modified"> 857   writer-&gt;write(entry-&gt;value()-&gt;as_C_string());</span>
<span class="line-modified"> 858   return 1;</span>
 859 }
 860 
<a name="104" id="anc104"></a><span class="line-modified"> 861 int write__symbol(JfrCheckpointWriter* writer, const void* e) {</span>
<span class="line-modified"> 862   assert(e != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 863   SymbolEntryPtr entry = (SymbolEntryPtr)e;</span>
<span class="line-modified"> 864   set_serialized(entry);</span>
<span class="line-modified"> 865   return write_symbol(writer, entry, false);</span>
 866 }
 867 
<a name="105" id="anc105"></a><span class="line-modified"> 868 int write__symbol__leakp(JfrCheckpointWriter* writer, const void* e) {</span>
<span class="line-modified"> 869   assert(e != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 870   SymbolEntryPtr entry = (SymbolEntryPtr)e;</span>
<span class="line-modified"> 871   return write_symbol(writer, entry, true);</span>


 872 }
<a name="106" id="anc106"></a><span class="line-modified"> 873 </span>
<span class="line-added"> 874 static int write_cstring(JfrCheckpointWriter* writer, CStringEntryPtr entry, bool leakp) {</span>
<span class="line-added"> 875   assert(writer != NULL, &quot;invariant&quot;);</span>
 876   assert(entry != NULL, &quot;invariant&quot;);
<a name="107" id="anc107"></a><span class="line-modified"> 877   writer-&gt;write(create_symbol_id(entry-&gt;id()));</span>
<span class="line-modified"> 878   writer-&gt;write(entry-&gt;value());</span>
<span class="line-modified"> 879   return 1;</span>

 880 }
 881 
<a name="108" id="anc108"></a><span class="line-modified"> 882 int write__cstring(JfrCheckpointWriter* writer, const void* e) {</span>
<span class="line-modified"> 883   assert(e != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 884   CStringEntryPtr entry = (CStringEntryPtr)e;</span>
<span class="line-modified"> 885   set_serialized(entry);</span>
<span class="line-modified"> 886   return write_cstring(writer, entry, false);</span>
 887 }
 888 
<a name="109" id="anc109"></a><span class="line-modified"> 889 int write__cstring__leakp(JfrCheckpointWriter* writer, const void* e) {</span>
<span class="line-modified"> 890   assert(e != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 891   CStringEntryPtr entry = (CStringEntryPtr)e;</span>
<span class="line-added"> 892   return write_cstring(writer, entry, true);</span>
<span class="line-added"> 893 }</span>
<span class="line-added"> 894 </span>
<span class="line-added"> 895 typedef SymbolPredicate&lt;SymbolEntryPtr, false&gt; SymPredicate;</span>
<span class="line-added"> 896 typedef JfrPredicatedTypeWriterImplHost&lt;SymbolEntryPtr, SymPredicate, write__symbol&gt; SymbolEntryWriterImpl;</span>
<span class="line-added"> 897 typedef JfrTypeWriterHost&lt;SymbolEntryWriterImpl, TYPE_SYMBOL&gt; SymbolEntryWriter;</span>
<span class="line-added"> 898 typedef SymbolPredicate&lt;CStringEntryPtr, false&gt; CStringPredicate;</span>
<span class="line-added"> 899 typedef JfrPredicatedTypeWriterImplHost&lt;CStringEntryPtr, CStringPredicate, write__cstring&gt; CStringEntryWriterImpl;</span>
<span class="line-added"> 900 typedef JfrTypeWriterHost&lt;CStringEntryWriterImpl, TYPE_SYMBOL&gt; CStringEntryWriter;</span>
<span class="line-added"> 901 </span>
<span class="line-added"> 902 typedef SymbolPredicate&lt;SymbolEntryPtr, true&gt; LeakSymPredicate;</span>
<span class="line-added"> 903 typedef JfrPredicatedTypeWriterImplHost&lt;SymbolEntryPtr, LeakSymPredicate, write__symbol__leakp&gt; LeakSymbolEntryWriterImpl;</span>
<span class="line-added"> 904 typedef JfrTypeWriterHost&lt;LeakSymbolEntryWriterImpl, TYPE_SYMBOL&gt; LeakSymbolEntryWriter;</span>
<span class="line-added"> 905 typedef CompositeFunctor&lt;SymbolEntryPtr, LeakSymbolEntryWriter, SymbolEntryWriter&gt; CompositeSymbolWriter;</span>
<span class="line-added"> 906 typedef SymbolPredicate&lt;CStringEntryPtr, true&gt; LeakCStringPredicate;</span>
<span class="line-added"> 907 typedef JfrPredicatedTypeWriterImplHost&lt;CStringEntryPtr, LeakCStringPredicate, write__cstring__leakp&gt; LeakCStringEntryWriterImpl;</span>
<span class="line-added"> 908 typedef JfrTypeWriterHost&lt;LeakCStringEntryWriterImpl, TYPE_SYMBOL&gt; LeakCStringEntryWriter;</span>
<span class="line-added"> 909 typedef CompositeFunctor&lt;CStringEntryPtr, LeakCStringEntryWriter, CStringEntryWriter&gt; CompositeCStringWriter;</span>
<span class="line-added"> 910 </span>
<span class="line-added"> 911 static void write_symbols_with_leakp() {</span>
<span class="line-added"> 912   assert(_leakp_writer != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 913   SymbolEntryWriter sw(_writer, _class_unload);</span>
<span class="line-added"> 914   LeakSymbolEntryWriter lsw(_leakp_writer, _class_unload);</span>
<span class="line-added"> 915   CompositeSymbolWriter csw(&amp;lsw, &amp;sw);</span>
<span class="line-added"> 916   _artifacts-&gt;iterate_symbols(csw);</span>
<span class="line-added"> 917   CStringEntryWriter ccsw(_writer, _class_unload, true); // skip header</span>
<span class="line-added"> 918   LeakCStringEntryWriter lccsw(_leakp_writer, _class_unload, true); // skip header</span>
<span class="line-added"> 919   CompositeCStringWriter cccsw(&amp;lccsw, &amp;ccsw);</span>
<span class="line-added"> 920   _artifacts-&gt;iterate_cstrings(cccsw);</span>
<span class="line-added"> 921   sw.add(ccsw.count());</span>
<span class="line-added"> 922   lsw.add(lccsw.count());</span>
<span class="line-added"> 923   _artifacts-&gt;tally(sw);</span>
<span class="line-added"> 924 }</span>
<span class="line-added"> 925 </span>
<span class="line-added"> 926 static void write_symbols() {</span>
<span class="line-added"> 927   assert(_writer != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 928   if (_leakp_writer != NULL) {</span>
<span class="line-added"> 929     write_symbols_with_leakp();</span>
 930     return;
 931   }
<a name="110" id="anc110"></a><span class="line-modified"> 932   SymbolEntryWriter sw(_writer, _class_unload);</span>
<span class="line-added"> 933   _artifacts-&gt;iterate_symbols(sw);</span>
<span class="line-added"> 934   CStringEntryWriter csw(_writer, _class_unload, true); // skip header</span>
<span class="line-added"> 935   _artifacts-&gt;iterate_cstrings(csw);</span>
<span class="line-added"> 936   sw.add(csw.count());</span>
<span class="line-added"> 937   _artifacts-&gt;tally(sw);</span>
 938 }
 939 
<a name="111" id="anc111"></a><span class="line-modified"> 940 typedef Wrapper&lt;KlassPtr, ClearArtifact&gt; ClearKlassBits;</span>
<span class="line-modified"> 941 typedef Wrapper&lt;MethodPtr, ClearArtifact&gt; ClearMethodFlag;</span>
<span class="line-modified"> 942 typedef MethodIteratorHost&lt;ClearMethodFlag, ClearKlassBits, AlwaysTrue, false&gt; ClearKlassAndMethods;</span>



 943 
<a name="112" id="anc112"></a><span class="line-modified"> 944 static bool clear_artifacts = false;</span>























 945 
<a name="113" id="anc113"></a><span class="line-modified"> 946 static void clear_klasses_and_methods() {</span>
<span class="line-modified"> 947   ClearKlassAndMethods clear(_writer);</span>
<span class="line-modified"> 948   _artifacts-&gt;iterate_klasses(clear);</span>




 949 }
 950 
<a name="114" id="anc114"></a><span class="line-modified"> 951 static size_t teardown() {</span>
<span class="line-modified"> 952   assert(_artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 953   const size_t total_count = _artifacts-&gt;total_count();</span>
<span class="line-modified"> 954   if (previous_epoch()) {</span>
<span class="line-modified"> 955     clear_klasses_and_methods();</span>
<span class="line-modified"> 956     clear_artifacts = true;</span>
<span class="line-modified"> 957     ++checkpoint_id;</span>
<span class="line-modified"> 958   }</span>
<span class="line-modified"> 959   return total_count;</span>
 960 }
 961 
<a name="115" id="anc115"></a><span class="line-modified"> 962 static void setup(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer, bool class_unload, bool flushpoint) {</span>
<span class="line-modified"> 963   _writer = writer;</span>
<span class="line-modified"> 964   _leakp_writer = leakp_writer;</span>




 965   _class_unload = class_unload;
<a name="116" id="anc116"></a><span class="line-modified"> 966   _flushpoint = flushpoint;</span>
 967   if (_artifacts == NULL) {
 968     _artifacts = new JfrArtifactSet(class_unload);
<a name="117" id="anc117"></a>
 969   } else {
<a name="118" id="anc118"></a><span class="line-modified"> 970     _artifacts-&gt;initialize(class_unload, clear_artifacts);</span>

 971   }
<a name="119" id="anc119"></a><span class="line-added"> 972   clear_artifacts = false;</span>
 973   assert(_artifacts != NULL, &quot;invariant&quot;);
 974   assert(!_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);
<a name="120" id="anc120"></a><span class="line-modified"> 975 }</span>

 976 
<a name="121" id="anc121"></a><span class="line-added"> 977 /**</span>
<span class="line-added"> 978  * Write all &quot;tagged&quot; (in-use) constant artifacts and their dependencies.</span>
<span class="line-added"> 979  */</span>
<span class="line-added"> 980 size_t JfrTypeSet::serialize(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer, bool class_unload, bool flushpoint) {</span>
<span class="line-added"> 981   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 982   ResourceMark rm;</span>
<span class="line-added"> 983   setup(writer, leakp_writer, class_unload, flushpoint);</span>
 984   // write order is important because an individual write step
 985   // might tag an artifact to be written in a subsequent step
<a name="122" id="anc122"></a><span class="line-modified"> 986   if (!write_klasses()) {</span>
<span class="line-modified"> 987     return 0;</span>






 988   }
<a name="123" id="anc123"></a><span class="line-added"> 989   write_packages();</span>
<span class="line-added"> 990   write_modules();</span>
<span class="line-added"> 991   write_classloaders();</span>
<span class="line-added"> 992   write_methods();</span>
<span class="line-added"> 993   write_symbols();</span>
<span class="line-added"> 994   return teardown();</span>
<span class="line-added"> 995 }</span>
<span class="line-added"> 996 </span>
<span class="line-added"> 997 /**</span>
<span class="line-added"> 998  * Clear all tags from the previous epoch.</span>
<span class="line-added"> 999  */</span>
<span class="line-added">1000 void JfrTypeSet::clear() {</span>
<span class="line-added">1001   clear_artifacts = true;</span>
<span class="line-added">1002   setup(NULL, NULL, false, false);</span>
<span class="line-added">1003   register_klasses();</span>
<span class="line-added">1004   clear_packages();</span>
<span class="line-added">1005   clear_modules();</span>
<span class="line-added">1006   clear_classloaders();</span>
<span class="line-added">1007   clear_klasses_and_methods();</span>
1008 }
<a name="124" id="anc124"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="124" type="hidden" />
</body>
</html>
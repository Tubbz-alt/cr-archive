diff a/src/hotspot/share/jfr/recorder/service/jfrOptionSet.cpp b/src/hotspot/share/jfr/recorder/service/jfrOptionSet.cpp
--- a/src/hotspot/share/jfr/recorder/service/jfrOptionSet.cpp
+++ b/src/hotspot/share/jfr/recorder/service/jfrOptionSet.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -25,10 +25,11 @@
 #include "precompiled.hpp"
 #include "jfr/dcmd/jfrDcmds.hpp"
 #include "jfr/recorder/service/jfrMemorySizer.hpp"
 #include "jfr/recorder/service/jfrOptionSet.hpp"
 #include "jfr/utilities/jfrAllocation.hpp"
+#include "jfr/utilities/jfrTypes.hpp"
 #include "logging/log.hpp"
 #include "memory/allocation.inline.hpp"
 #include "memory/resourceArea.hpp"
 #include "runtime/java.hpp"
 #include "runtime/thread.inline.hpp"
@@ -104,14 +105,10 @@
 
 u4 JfrOptionSet::stackdepth() {
   return _stack_depth;
 }
 
-static const u4 STACK_DEPTH_DEFAULT = 64;
-static const u4 MIN_STACK_DEPTH = 1;
-static const u4 MAX_STACK_DEPTH = 2048;
-
 void JfrOptionSet::set_stackdepth(u4 depth) {
   if (depth < MIN_STACK_DEPTH) {
     _stack_depth = MIN_STACK_DEPTH;
   } else if (depth > MAX_STACK_DEPTH) {
     _stack_depth = MAX_STACK_DEPTH;
@@ -678,11 +675,11 @@
     *delimiter = '=';
   }
   return false;
 }
 
-static GrowableArray<const char*>* startup_recording_options_array = NULL;
+static GrowableArray<const char*>* start_flight_recording_options_array = NULL;
 
 bool JfrOptionSet::parse_start_flight_recording_option(const JavaVMOption** option, char* delimiter) {
   assert(option != NULL, "invariant");
   assert(delimiter != NULL, "invariant");
   assert((*option)->optionString != NULL, "invariant");
@@ -701,30 +698,30 @@
     value = delimiter + 1;
   }
   assert(value != NULL, "invariant");
   const size_t value_length = strlen(value);
 
-  if (startup_recording_options_array == NULL) {
-    startup_recording_options_array = new (ResourceObj::C_HEAP, mtTracing) GrowableArray<const char*>(8, true, mtTracing);
+  if (start_flight_recording_options_array == NULL) {
+    start_flight_recording_options_array = new (ResourceObj::C_HEAP, mtTracing) GrowableArray<const char*>(8, true, mtTracing);
   }
-  assert(startup_recording_options_array != NULL, "invariant");
+  assert(start_flight_recording_options_array != NULL, "invariant");
   char* const startup_value = NEW_C_HEAP_ARRAY(char, value_length + 1, mtTracing);
   strncpy(startup_value, value, value_length + 1);
   assert(strncmp(startup_value, value, value_length) == 0, "invariant");
-  startup_recording_options_array->append(startup_value);
+  start_flight_recording_options_array->append(startup_value);
   return false;
 }
 
-const GrowableArray<const char*>* JfrOptionSet::startup_recording_options() {
-  return startup_recording_options_array;
+const GrowableArray<const char*>* JfrOptionSet::start_flight_recording_options() {
+  return start_flight_recording_options_array;
 }
 
-void JfrOptionSet::release_startup_recording_options() {
-  if (startup_recording_options_array != NULL) {
-    const int length = startup_recording_options_array->length();
+void JfrOptionSet::release_start_flight_recording_options() {
+  if (start_flight_recording_options_array != NULL) {
+    const int length = start_flight_recording_options_array->length();
     for (int i = 0; i < length; ++i) {
-      FREE_C_HEAP_ARRAY(char, startup_recording_options_array->at(i));
+      FREE_C_HEAP_ARRAY(char, start_flight_recording_options_array->at(i));
     }
-    delete startup_recording_options_array;
-    startup_recording_options_array = NULL;
+    delete start_flight_recording_options_array;
+    start_flight_recording_options_array = NULL;
   }
 }

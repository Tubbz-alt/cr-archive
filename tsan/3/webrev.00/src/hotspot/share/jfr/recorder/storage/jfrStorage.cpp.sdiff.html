<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/recorder/storage/jfrStorage.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="jfrMemorySpace.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrStorage.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/storage/jfrStorage.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/jfrEvents.hpp&quot;
 27 #include &quot;jfr/jni/jfrJavaSupport.hpp&quot;
 28 #include &quot;jfr/recorder/jfrRecorder.hpp&quot;

 29 #include &quot;jfr/recorder/repository/jfrChunkWriter.hpp&quot;
 30 #include &quot;jfr/recorder/service/jfrOptionSet.hpp&quot;
 31 #include &quot;jfr/recorder/service/jfrPostBox.hpp&quot;
 32 #include &quot;jfr/recorder/storage/jfrMemorySpace.inline.hpp&quot;
 33 #include &quot;jfr/recorder/storage/jfrStorage.hpp&quot;
 34 #include &quot;jfr/recorder/storage/jfrStorageControl.hpp&quot;
 35 #include &quot;jfr/recorder/storage/jfrStorageUtils.inline.hpp&quot;
 36 #include &quot;jfr/utilities/jfrIterator.hpp&quot;
 37 #include &quot;jfr/utilities/jfrTime.hpp&quot;
 38 #include &quot;jfr/writers/jfrNativeEventWriter.hpp&quot;
 39 #include &quot;logging/log.hpp&quot;
 40 #include &quot;runtime/mutexLocker.hpp&quot;
<span class="line-removed"> 41 #include &quot;runtime/orderAccess.hpp&quot;</span>
 42 #include &quot;runtime/os.inline.hpp&quot;
 43 #include &quot;runtime/safepoint.hpp&quot;
 44 #include &quot;runtime/thread.hpp&quot;
 45 
 46 typedef JfrStorage::Buffer* BufferPtr;
 47 
 48 static JfrStorage* _instance = NULL;
 49 static JfrStorageControl* _control;
 50 
 51 JfrStorage&amp; JfrStorage::instance() {
 52   return *_instance;
 53 }
 54 
 55 JfrStorage* JfrStorage::create(JfrChunkWriter&amp; chunkwriter, JfrPostBox&amp; post_box) {
 56   assert(_instance == NULL, &quot;invariant&quot;);
 57   _instance = new JfrStorage(chunkwriter, post_box);
 58   return _instance;
 59 }
 60 
 61 void JfrStorage::destroy() {
</pre>
<hr />
<pre>
217   }
218   return acquire_transient(size, thread);
219 }
220 
221 static void write_data_loss_event(JfrBuffer* buffer, u8 unflushed_size, Thread* thread) {
222   assert(buffer != NULL, &quot;invariant&quot;);
223   assert(buffer-&gt;empty(), &quot;invariant&quot;);
224   const u8 total_data_loss = thread-&gt;jfr_thread_local()-&gt;add_data_lost(unflushed_size);
225   if (EventDataLoss::is_enabled()) {
226     JfrNativeEventWriter writer(buffer, thread);
227     writer.write&lt;u8&gt;(EventDataLoss::eventId);
228     writer.write(JfrTicks::now());
229     writer.write(unflushed_size);
230     writer.write(total_data_loss);
231   }
232 }
233 
234 static void write_data_loss(BufferPtr buffer, Thread* thread) {
235   assert(buffer != NULL, &quot;invariant&quot;);
236   const size_t unflushed_size = buffer-&gt;unflushed_size();
<span class="line-modified">237   buffer-&gt;concurrent_reinitialization();</span>
238   if (unflushed_size == 0) {
239     return;
240   }
241   write_data_loss_event(buffer, unflushed_size, thread);
242 }
243 
244 static const size_t promotion_retry = 100;
245 
246 bool JfrStorage::flush_regular_buffer(BufferPtr buffer, Thread* thread) {
247   assert(buffer != NULL, &quot;invariant&quot;);
248   assert(!buffer-&gt;lease(), &quot;invariant&quot;);
249   assert(!buffer-&gt;transient(), &quot;invariant&quot;);
250   const size_t unflushed_size = buffer-&gt;unflushed_size();
251   if (unflushed_size == 0) {
<span class="line-modified">252     buffer-&gt;concurrent_reinitialization();</span>
253     assert(buffer-&gt;empty(), &quot;invariant&quot;);
254     return true;
255   }












256   BufferPtr const promotion_buffer = get_promotion_buffer(unflushed_size, _global_mspace, *this, promotion_retry, thread);
257   if (promotion_buffer == NULL) {
258     write_data_loss(buffer, thread);
259     return false;
260   }
261   assert(promotion_buffer-&gt;acquired_by_self(), &quot;invariant&quot;);
262   assert(promotion_buffer-&gt;free_size() &gt;= unflushed_size, &quot;invariant&quot;);
<span class="line-modified">263   buffer-&gt;concurrent_move_and_reinitialize(promotion_buffer, unflushed_size);</span>
264   assert(buffer-&gt;empty(), &quot;invariant&quot;);
265   return true;
266 }
267 
268 /*
269 * 1. If the buffer was a &quot;lease&quot; from the global system, release back.
270 * 2. If the buffer is transient (temporal dynamically allocated), retire and register full.
271 *
272 * The buffer is effectively invalidated for the thread post-return,
273 * and the caller should take means to ensure that it is not referenced any longer.
274 */
275 void JfrStorage::release_large(BufferPtr buffer, Thread* thread) {
276   assert(buffer != NULL, &quot;invariant&quot;);
277   assert(buffer-&gt;lease(), &quot;invariant&quot;);
278   assert(buffer-&gt;acquired_by_self(), &quot;invariant&quot;);
279   buffer-&gt;clear_lease();
280   if (buffer-&gt;transient()) {
281     buffer-&gt;set_retired();
282     register_full(buffer, thread);
283   } else {
</pre>
<hr />
<pre>
295 static void log_registration_failure(size_t unflushed_size) {
296   log_warning(jfr)(&quot;Unable to register a full buffer of &quot; SIZE_FORMAT &quot; bytes.&quot;, unflushed_size);
297   log_debug(jfr, system)(&quot;Cleared 1 full buffer of &quot; SIZE_FORMAT &quot; bytes.&quot;, unflushed_size);
298 }
299 
300 static void handle_registration_failure(BufferPtr buffer) {
301   assert(buffer != NULL, &quot;invariant&quot;);
302   assert(buffer-&gt;retired(), &quot;invariant&quot;);
303   const size_t unflushed_size = buffer-&gt;unflushed_size();
304   buffer-&gt;reinitialize();
305   log_registration_failure(unflushed_size);
306 }
307 
308 static JfrAgeNode* get_free_age_node(JfrStorageAgeMspace* age_mspace, Thread* thread) {
309   assert(JfrBuffer_lock-&gt;owned_by_self(), &quot;invariant&quot;);
310   return mspace_get_free_with_detach(0, age_mspace, thread);
311 }
312 
313 static bool insert_full_age_node(JfrAgeNode* age_node, JfrStorageAgeMspace* age_mspace, Thread* thread) {
314   assert(JfrBuffer_lock-&gt;owned_by_self(), &quot;invariant&quot;);


315   assert(age_node-&gt;retired_buffer()-&gt;retired(), &quot;invariant&quot;);


316   age_mspace-&gt;insert_full_head(age_node);
317   return true;
318 }
319 
320 static bool full_buffer_registration(BufferPtr buffer, JfrStorageAgeMspace* age_mspace, JfrStorageControl&amp; control, Thread* thread) {
321   assert(buffer != NULL, &quot;invariant&quot;);
322   assert(buffer-&gt;retired(), &quot;invariant&quot;);
323   assert(age_mspace != NULL, &quot;invariant&quot;);
<span class="line-modified">324   MutexLockerEx lock(JfrBuffer_lock, Mutex::_no_safepoint_check_flag);</span>
325   JfrAgeNode* age_node = get_free_age_node(age_mspace, thread);
326   if (age_node == NULL) {
327     age_node = new_age_node(buffer, age_mspace, thread);
328     if (age_node == NULL) {
329       return false;
330     }
331   }
<span class="line-removed">332   assert(age_node-&gt;acquired_by_self(), &quot;invariant&quot;);</span>
333   assert(age_node != NULL, &quot;invariant&quot;);

334   age_node-&gt;set_retired_buffer(buffer);
335   control.increment_full();
336   return insert_full_age_node(age_node, age_mspace, thread);
337 }
338 
339 void JfrStorage::register_full(BufferPtr buffer, Thread* thread) {
340   assert(buffer != NULL, &quot;invariant&quot;);
341   assert(buffer-&gt;retired(), &quot;invariant&quot;);

342   if (!full_buffer_registration(buffer, _age_mspace, control(), thread)) {
343     handle_registration_failure(buffer);
<span class="line-removed">344     buffer-&gt;release();</span>
345   }
346   if (control().should_post_buffer_full_message()) {
347     _post_box.post(MSG_FULLBUFFER);
348   }
349 }
350 
351 void JfrStorage::lock() {
352   assert(!JfrBuffer_lock-&gt;owned_by_self(), &quot;invariant&quot;);
353   JfrBuffer_lock-&gt;lock_without_safepoint_check();
354 }
355 
356 void JfrStorage::unlock() {
357   assert(JfrBuffer_lock-&gt;owned_by_self(), &quot;invariant&quot;);
358   JfrBuffer_lock-&gt;unlock();
359 }
360 
361 #ifdef ASSERT
362 bool JfrStorage::is_locked() const {
363   return JfrBuffer_lock-&gt;owned_by_self();
364 }
365 #endif
366 
367 // don&#39;t use buffer on return, it is gone
368 void JfrStorage::release(BufferPtr buffer, Thread* thread) {
369   assert(buffer != NULL, &quot;invariant&quot;);
370   assert(!buffer-&gt;lease(), &quot;invariant&quot;);
371   assert(!buffer-&gt;transient(), &quot;invariant&quot;);
372   assert(!buffer-&gt;retired(), &quot;invariant&quot;);
373   if (!buffer-&gt;empty()) {
374     if (!flush_regular_buffer(buffer, thread)) {
<span class="line-modified">375       buffer-&gt;concurrent_reinitialization();</span>
376     }
377   }
378   assert(buffer-&gt;empty(), &quot;invariant&quot;);

379   control().increment_dead();
<span class="line-removed">380   buffer-&gt;release();</span>
381   buffer-&gt;set_retired();
382 }
383 
384 void JfrStorage::release_thread_local(BufferPtr buffer, Thread* thread) {
385   assert(buffer != NULL, &quot;invariant&quot;);
386   JfrStorage&amp; storage_instance = instance();
387   storage_instance.release(buffer, thread);
388   if (storage_instance.control().should_scavenge()) {
389     storage_instance._post_box.post(MSG_DEADBUFFER);
390   }
391 }
392 
393 static void log_discard(size_t count, size_t amount, size_t current) {
394   if (log_is_enabled(Debug, jfr, system)) {
395     assert(count &gt; 0, &quot;invariant&quot;);
396     log_debug(jfr, system)(&quot;Cleared &quot; SIZE_FORMAT &quot; full buffer(s) of &quot; SIZE_FORMAT&quot; bytes.&quot;, count, amount);
397     log_debug(jfr, system)(&quot;Current number of full buffers &quot; SIZE_FORMAT &quot;&quot;, current);
398   }
399 }
400 
401 void JfrStorage::discard_oldest(Thread* thread) {
402   if (JfrBuffer_lock-&gt;try_lock()) {
403     if (!control().should_discard()) {
404       // another thread handled it
405       return;
406     }
407     const size_t num_full_pre_discard = control().full_count();
408     size_t num_full_post_discard = 0;
409     size_t discarded_size = 0;
410     while (true) {
411       JfrAgeNode* const oldest_age_node = _age_mspace-&gt;full_tail();
412       if (oldest_age_node == NULL) {
413         break;
414       }

415       BufferPtr const buffer = oldest_age_node-&gt;retired_buffer();
416       assert(buffer-&gt;retired(), &quot;invariant&quot;);
<span class="line-modified">417       discarded_size += buffer-&gt;unflushed_size();</span>


418       num_full_post_discard = control().decrement_full();

419       if (buffer-&gt;transient()) {
420         mspace_release_full(buffer, _transient_mspace);
<span class="line-removed">421         mspace_release_full(oldest_age_node, _age_mspace);</span>
422         continue;
<span class="line-removed">423       } else {</span>
<span class="line-removed">424         mspace_release_full(oldest_age_node, _age_mspace);</span>
<span class="line-removed">425         buffer-&gt;reinitialize();</span>
<span class="line-removed">426         buffer-&gt;release(); // pusb</span>
<span class="line-removed">427         break;</span>
428       }



429     }
430     JfrBuffer_lock-&gt;unlock();
431     const size_t number_of_discards = num_full_pre_discard - num_full_post_discard;
432     if (number_of_discards &gt; 0) {
433       log_discard(number_of_discards, discarded_size, num_full_post_discard);
434     }
435   }
436 }
437 
438 #ifdef ASSERT
439 typedef const BufferPtr ConstBufferPtr;
440 
441 static void assert_flush_precondition(ConstBufferPtr cur, size_t used, bool native, const Thread* t) {
442   assert(t != NULL, &quot;invariant&quot;);
443   assert(cur != NULL, &quot;invariant&quot;);
444   assert(cur-&gt;pos() + used &lt;= cur-&gt;end(), &quot;invariant&quot;);
445   assert(native ? t-&gt;jfr_thread_local()-&gt;native_buffer() == cur : t-&gt;jfr_thread_local()-&gt;java_buffer() == cur, &quot;invariant&quot;);
446 }
447 
448 static void assert_flush_regular_precondition(ConstBufferPtr cur, const u1* const cur_pos, size_t used, size_t req, const Thread* t) {
449   assert(t != NULL, &quot;invariant&quot;);
450   assert(t-&gt;jfr_thread_local()-&gt;shelved_buffer() == NULL, &quot;invariant&quot;);
451   assert(cur != NULL, &quot;invariant&quot;);
452   assert(!cur-&gt;lease(), &quot;invariant&quot;);
453   assert(cur_pos != NULL, &quot;invariant&quot;);
454   assert(req &gt;= used, &quot;invariant&quot;);
455 }
456 
457 static void assert_provision_large_precondition(ConstBufferPtr cur, size_t used, size_t req, const Thread* t) {
458   assert(cur != NULL, &quot;invariant&quot;);
459   assert(t != NULL, &quot;invariant&quot;);
460   assert(t-&gt;jfr_thread_local()-&gt;shelved_buffer() != NULL, &quot;invariant&quot;);
461   assert(req &gt;= used, &quot;invariant&quot;);
462 }
463 
464 static void assert_flush_large_precondition(ConstBufferPtr cur, const u1* const cur_pos, size_t used, size_t req, bool native, Thread* t) {
465   assert(t != NULL, &quot;invariant&quot;);
466   assert(cur != NULL, &quot;invariant&quot;);
467   assert(cur-&gt;lease(), &quot;invariant&quot;);

468   assert(cur_pos != NULL, &quot;invariant&quot;);
469   assert(native ? t-&gt;jfr_thread_local()-&gt;native_buffer() == cur : t-&gt;jfr_thread_local()-&gt;java_buffer() == cur, &quot;invariant&quot;);
470   assert(t-&gt;jfr_thread_local()-&gt;shelved_buffer() != NULL, &quot;invariant&quot;);
471   assert(req &gt;= used, &quot;invariant&quot;);
472   assert(cur != t-&gt;jfr_thread_local()-&gt;shelved_buffer(), &quot;invariant&quot;);
473 }
474 #endif // ASSERT
475 
476 BufferPtr JfrStorage::flush(BufferPtr cur, size_t used, size_t req, bool native, Thread* t) {
477   debug_only(assert_flush_precondition(cur, used, native, t);)
478   const u1* const cur_pos = cur-&gt;pos();
479   req += used;
480   // requested size now encompass the outstanding used size
481   return cur-&gt;lease() ? instance().flush_large(cur, cur_pos, used, req, native, t) :
482                           instance().flush_regular(cur, cur_pos, used, req, native, t);
483 }
484 
485 BufferPtr JfrStorage::flush_regular(BufferPtr cur, const u1* const cur_pos, size_t used, size_t req, bool native, Thread* t) {
486   debug_only(assert_flush_regular_precondition(cur, cur_pos, used, req, t);)
487   // A flush is needed before memcpy since a non-large buffer is thread stable
488   // (thread local). The flush will not modify memory in addresses above pos()
489   // which is where the &quot;used / uncommitted&quot; data resides. It is therefore both
490   // possible and valid to migrate data after the flush. This is however only
491   // the case for stable thread local buffers; it is not the case for large buffers.
492   if (!cur-&gt;empty()) {
493     flush_regular_buffer(cur, t);



494   }
495   assert(t-&gt;jfr_thread_local()-&gt;shelved_buffer() == NULL, &quot;invariant&quot;);
496   if (cur-&gt;free_size() &gt;= req) {
497     // simplest case, no switching of buffers
498     if (used &gt; 0) {
499       memcpy(cur-&gt;pos(), (void*)cur_pos, used);
500     }
501     assert(native ? t-&gt;jfr_thread_local()-&gt;native_buffer() == cur : t-&gt;jfr_thread_local()-&gt;java_buffer() == cur, &quot;invariant&quot;);
502     return cur;
503   }
504   // Going for a &quot;larger-than-regular&quot; buffer.
505   // Shelve the current buffer to make room for a temporary lease.
506   t-&gt;jfr_thread_local()-&gt;shelve_buffer(cur);
507   return provision_large(cur, cur_pos, used, req, native, t);
508 }
509 
510 static BufferPtr store_buffer_to_thread_local(BufferPtr buffer, JfrThreadLocal* jfr_thread_local, bool native) {
511   assert(buffer != NULL, &quot;invariant&quot;);
512   if (native) {
513     jfr_thread_local-&gt;set_native_buffer(buffer);
</pre>
<hr />
<pre>
562   BufferPtr const buffer = acquire_large(req, t);
563   if (buffer == NULL) {
564     // unable to allocate and serve the request
565     return large_fail(cur, native, *this, t);
566   }
567   // ok managed to acquire a &quot;large&quot; buffer for the requested size
568   assert(buffer-&gt;free_size() &gt;= req, &quot;invariant&quot;);
569   assert(buffer-&gt;lease(), &quot;invariant&quot;);
570   // transfer outstanding data
571   memcpy(buffer-&gt;pos(), (void*)cur_pos, used);
572   if (cur-&gt;lease()) {
573     release_large(cur, t);
574     // don&#39;t use current anymore, it is gone
575   }
576   return store_buffer_to_thread_local(buffer, t-&gt;jfr_thread_local(), native);
577 }
578 
579 typedef UnBufferedWriteToChunk&lt;JfrBuffer&gt; WriteOperation;
580 typedef MutexedWriteOp&lt;WriteOperation&gt; MutexedWriteOperation;
581 typedef ConcurrentWriteOp&lt;WriteOperation&gt; ConcurrentWriteOperation;
<span class="line-modified">582 typedef ConcurrentWriteOpExcludeRetired&lt;WriteOperation&gt; ThreadLocalConcurrentWriteOperation;</span>





583 
584 size_t JfrStorage::write() {
<span class="line-modified">585   const size_t full_size_processed = write_full();</span>
586   WriteOperation wo(_chunkwriter);
<span class="line-modified">587   ThreadLocalConcurrentWriteOperation tlwo(wo);</span>



588   process_full_list(tlwo, _thread_local_mspace);
589   ConcurrentWriteOperation cwo(wo);
590   process_free_list(cwo, _global_mspace);
<span class="line-modified">591   return full_size_processed + wo.processed();</span>
592 }
593 
594 size_t JfrStorage::write_at_safepoint() {
595   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
596   WriteOperation wo(_chunkwriter);
597   MutexedWriteOperation writer(wo); // mutexed write mode
<span class="line-modified">598   process_full_list(writer, _thread_local_mspace);</span>




599   assert(_transient_mspace-&gt;is_free_empty(), &quot;invariant&quot;);
600   process_full_list(writer, _transient_mspace);
601   assert(_global_mspace-&gt;is_full_empty(), &quot;invariant&quot;);
602   process_free_list(writer, _global_mspace);
<span class="line-modified">603   return wo.processed();</span>
604 }
605 
606 typedef DiscardOp&lt;DefaultDiscarder&lt;JfrStorage::Buffer&gt; &gt; DiscardOperation;
607 typedef ReleaseOp&lt;JfrStorageMspace&gt; ReleaseOperation;
608 typedef CompositeOperation&lt;MutexedWriteOperation, ReleaseOperation&gt; FullOperation;
609 
610 size_t JfrStorage::clear() {
<span class="line-modified">611   const size_t full_size_processed = clear_full();</span>
612   DiscardOperation discarder(concurrent); // concurrent discard mode
613   process_full_list(discarder, _thread_local_mspace);
614   assert(_transient_mspace-&gt;is_free_empty(), &quot;invariant&quot;);
615   process_full_list(discarder, _transient_mspace);
616   assert(_global_mspace-&gt;is_full_empty(), &quot;invariant&quot;);
617   process_free_list(discarder, _global_mspace);
<span class="line-modified">618   return full_size_processed + discarder.processed();</span>
619 }
620 
621 static void insert_free_age_nodes(JfrStorageAgeMspace* age_mspace, JfrAgeNode* head, JfrAgeNode* tail, size_t count) {
622   if (tail != NULL) {
623     assert(tail-&gt;next() == NULL, &quot;invariant&quot;);
624     assert(head != NULL, &quot;invariant&quot;);
625     assert(head-&gt;prev() == NULL, &quot;invariant&quot;);
<span class="line-modified">626     MutexLockerEx buffer_lock(JfrBuffer_lock, Mutex::_no_safepoint_check_flag);</span>
627     age_mspace-&gt;insert_free_tail(head, tail, count);
628   }
629 }
630 
631 template &lt;typename Processor&gt;
632 static void process_age_list(Processor&amp; processor, JfrStorageAgeMspace* age_mspace, JfrAgeNode* head, size_t count) {
633   assert(age_mspace != NULL, &quot;invariant&quot;);
634   assert(head != NULL, &quot;invariant&quot;);
635   assert(count &gt; 0, &quot;invariant&quot;);
636   JfrAgeNode* node = head;
637   JfrAgeNode* last = NULL;
638   while (node != NULL) {
639     last = node;

640     BufferPtr const buffer = node-&gt;retired_buffer();
641     assert(buffer != NULL, &quot;invariant&quot;);
642     assert(buffer-&gt;retired(), &quot;invariant&quot;);
643     processor.process(buffer);
644     // at this point, buffer is already live or destroyed
<span class="line-removed">645     node-&gt;clear_identity();</span>
646     JfrAgeNode* const next = (JfrAgeNode*)node-&gt;next();
647     if (node-&gt;transient()) {
648       // detach
649       last = (JfrAgeNode*)last-&gt;prev();
650       if (last != NULL) {
651         last-&gt;set_next(next);
652       } else {
653         head = next;
654       }
655       if (next != NULL) {
656         next-&gt;set_prev(last);
657       }
658       --count;
659       age_mspace-&gt;deallocate(node);
660     }
661     node = next;
662   }
663   insert_free_age_nodes(age_mspace, head, last, count);
664 }
665 
666 template &lt;typename Processor&gt;
667 static size_t process_full(Processor&amp; processor, JfrStorageControl&amp; control, JfrStorageAgeMspace* age_mspace) {
668   assert(age_mspace != NULL, &quot;invariant&quot;);
669   if (age_mspace-&gt;is_full_empty()) {
670     // nothing to do
671     return 0;
672   }
673   size_t count;
674   JfrAgeNode* head;
675   {
676     // fetch age list
<span class="line-modified">677     MutexLockerEx buffer_lock(JfrBuffer_lock, Mutex::_no_safepoint_check_flag);</span>
678     count = age_mspace-&gt;full_count();
679     head = age_mspace-&gt;clear_full();
680     control.reset_full();
681   }
682   assert(head != NULL, &quot;invariant&quot;);
683   assert(count &gt; 0, &quot;invariant&quot;);
684   process_age_list(processor, age_mspace, head, count);
685   return count;
686 }
687 
688 static void log(size_t count, size_t amount, bool clear = false) {
689   if (log_is_enabled(Debug, jfr, system)) {
690     if (count &gt; 0) {
691       log_debug(jfr, system)(&quot;%s &quot; SIZE_FORMAT &quot; full buffer(s) of &quot; SIZE_FORMAT&quot; B of data%s&quot;,
692         clear ? &quot;Discarded&quot; : &quot;Wrote&quot;, count, amount, clear ? &quot;.&quot; : &quot; to chunk.&quot;);
693     }
694   }
695 }
696 
697 // full writer
698 // Assumption is retired only; exclusive access
699 // MutexedWriter -&gt; ReleaseOp
700 //
701 size_t JfrStorage::write_full() {
702   assert(_chunkwriter.is_valid(), &quot;invariant&quot;);
703   Thread* const thread = Thread::current();
704   WriteOperation wo(_chunkwriter);
705   MutexedWriteOperation writer(wo); // a retired buffer implies mutexed access
706   ReleaseOperation ro(_transient_mspace, thread);
707   FullOperation cmd(&amp;writer, &amp;ro);
708   const size_t count = process_full(cmd, control(), _age_mspace);
<span class="line-modified">709   log(count, writer.processed());</span>
<span class="line-modified">710   return writer.processed();</span>





711 }
712 
713 size_t JfrStorage::clear_full() {
714   DiscardOperation discarder(mutexed); // a retired buffer implies mutexed access
715   const size_t count = process_full(discarder, control(), _age_mspace);
<span class="line-modified">716   log(count, discarder.processed(), true);</span>
<span class="line-modified">717   return discarder.processed();</span>





718 }
719 
720 static void scavenge_log(size_t count, size_t amount, size_t current) {
721   if (count &gt; 0) {
722     if (log_is_enabled(Debug, jfr, system)) {
723       log_debug(jfr, system)(&quot;Released &quot; SIZE_FORMAT &quot; dead buffer(s) of &quot; SIZE_FORMAT&quot; B of data.&quot;, count, amount);
724       log_debug(jfr, system)(&quot;Current number of dead buffers &quot; SIZE_FORMAT &quot;&quot;, current);
725     }
726   }
727 }
728 
729 template &lt;typename Mspace&gt;
730 class Scavenger {
731 private:
732   JfrStorageControl&amp; _control;
733   Mspace* _mspace;
734   size_t _count;
735   size_t _amount;
736 public:
737   typedef typename Mspace::Type Type;
738   Scavenger(JfrStorageControl&amp; control, Mspace* mspace) : _control(control), _mspace(mspace), _count(0), _amount(0) {}
739   bool process(Type* t) {
740     if (t-&gt;retired()) {


741       assert(!t-&gt;transient(), &quot;invariant&quot;);
742       assert(!t-&gt;lease(), &quot;invariant&quot;);
<span class="line-removed">743       assert(t-&gt;empty(), &quot;invariant&quot;);</span>
<span class="line-removed">744       assert(t-&gt;identity() == NULL, &quot;invariant&quot;);</span>
745       ++_count;
746       _amount += t-&gt;total_size();




747       t-&gt;clear_retired();

748       _control.decrement_dead();
749       mspace_release_full_critical(t, _mspace);
750     }
751     return true;
752   }
753   size_t processed() const { return _count; }
754   size_t amount() const { return _amount; }
755 };
756 
757 size_t JfrStorage::scavenge() {
758   JfrStorageControl&amp; ctrl = control();
759   if (ctrl.dead_count() == 0) {
760     return 0;
761   }
762   Scavenger&lt;JfrThreadLocalMspace&gt; scavenger(ctrl, _thread_local_mspace);
763   process_full_list(scavenger, _thread_local_mspace);
<span class="line-modified">764   scavenge_log(scavenger.processed(), scavenger.amount(), ctrl.dead_count());</span>
<span class="line-modified">765   return scavenger.processed();</span>





766 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/jfrEvents.hpp&quot;
 27 #include &quot;jfr/jni/jfrJavaSupport.hpp&quot;
 28 #include &quot;jfr/recorder/jfrRecorder.hpp&quot;
<span class="line-added"> 29 #include &quot;jfr/recorder/checkpoint/jfrCheckpointManager.hpp&quot;</span>
 30 #include &quot;jfr/recorder/repository/jfrChunkWriter.hpp&quot;
 31 #include &quot;jfr/recorder/service/jfrOptionSet.hpp&quot;
 32 #include &quot;jfr/recorder/service/jfrPostBox.hpp&quot;
 33 #include &quot;jfr/recorder/storage/jfrMemorySpace.inline.hpp&quot;
 34 #include &quot;jfr/recorder/storage/jfrStorage.hpp&quot;
 35 #include &quot;jfr/recorder/storage/jfrStorageControl.hpp&quot;
 36 #include &quot;jfr/recorder/storage/jfrStorageUtils.inline.hpp&quot;
 37 #include &quot;jfr/utilities/jfrIterator.hpp&quot;
 38 #include &quot;jfr/utilities/jfrTime.hpp&quot;
 39 #include &quot;jfr/writers/jfrNativeEventWriter.hpp&quot;
 40 #include &quot;logging/log.hpp&quot;
 41 #include &quot;runtime/mutexLocker.hpp&quot;

 42 #include &quot;runtime/os.inline.hpp&quot;
 43 #include &quot;runtime/safepoint.hpp&quot;
 44 #include &quot;runtime/thread.hpp&quot;
 45 
 46 typedef JfrStorage::Buffer* BufferPtr;
 47 
 48 static JfrStorage* _instance = NULL;
 49 static JfrStorageControl* _control;
 50 
 51 JfrStorage&amp; JfrStorage::instance() {
 52   return *_instance;
 53 }
 54 
 55 JfrStorage* JfrStorage::create(JfrChunkWriter&amp; chunkwriter, JfrPostBox&amp; post_box) {
 56   assert(_instance == NULL, &quot;invariant&quot;);
 57   _instance = new JfrStorage(chunkwriter, post_box);
 58   return _instance;
 59 }
 60 
 61 void JfrStorage::destroy() {
</pre>
<hr />
<pre>
217   }
218   return acquire_transient(size, thread);
219 }
220 
221 static void write_data_loss_event(JfrBuffer* buffer, u8 unflushed_size, Thread* thread) {
222   assert(buffer != NULL, &quot;invariant&quot;);
223   assert(buffer-&gt;empty(), &quot;invariant&quot;);
224   const u8 total_data_loss = thread-&gt;jfr_thread_local()-&gt;add_data_lost(unflushed_size);
225   if (EventDataLoss::is_enabled()) {
226     JfrNativeEventWriter writer(buffer, thread);
227     writer.write&lt;u8&gt;(EventDataLoss::eventId);
228     writer.write(JfrTicks::now());
229     writer.write(unflushed_size);
230     writer.write(total_data_loss);
231   }
232 }
233 
234 static void write_data_loss(BufferPtr buffer, Thread* thread) {
235   assert(buffer != NULL, &quot;invariant&quot;);
236   const size_t unflushed_size = buffer-&gt;unflushed_size();
<span class="line-modified">237   buffer-&gt;reinitialize();</span>
238   if (unflushed_size == 0) {
239     return;
240   }
241   write_data_loss_event(buffer, unflushed_size, thread);
242 }
243 
244 static const size_t promotion_retry = 100;
245 
246 bool JfrStorage::flush_regular_buffer(BufferPtr buffer, Thread* thread) {
247   assert(buffer != NULL, &quot;invariant&quot;);
248   assert(!buffer-&gt;lease(), &quot;invariant&quot;);
249   assert(!buffer-&gt;transient(), &quot;invariant&quot;);
250   const size_t unflushed_size = buffer-&gt;unflushed_size();
251   if (unflushed_size == 0) {
<span class="line-modified">252     buffer-&gt;reinitialize();</span>
253     assert(buffer-&gt;empty(), &quot;invariant&quot;);
254     return true;
255   }
<span class="line-added">256 </span>
<span class="line-added">257   if (buffer-&gt;excluded()) {</span>
<span class="line-added">258     const bool thread_is_excluded = thread-&gt;jfr_thread_local()-&gt;is_excluded();</span>
<span class="line-added">259     buffer-&gt;reinitialize(thread_is_excluded);</span>
<span class="line-added">260     assert(buffer-&gt;empty(), &quot;invariant&quot;);</span>
<span class="line-added">261     if (!thread_is_excluded) {</span>
<span class="line-added">262       // state change from exclusion to inclusion requires a thread checkpoint</span>
<span class="line-added">263       JfrCheckpointManager::write_thread_checkpoint(thread);</span>
<span class="line-added">264     }</span>
<span class="line-added">265     return true;</span>
<span class="line-added">266   }</span>
<span class="line-added">267 </span>
268   BufferPtr const promotion_buffer = get_promotion_buffer(unflushed_size, _global_mspace, *this, promotion_retry, thread);
269   if (promotion_buffer == NULL) {
270     write_data_loss(buffer, thread);
271     return false;
272   }
273   assert(promotion_buffer-&gt;acquired_by_self(), &quot;invariant&quot;);
274   assert(promotion_buffer-&gt;free_size() &gt;= unflushed_size, &quot;invariant&quot;);
<span class="line-modified">275   buffer-&gt;move(promotion_buffer, unflushed_size);</span>
276   assert(buffer-&gt;empty(), &quot;invariant&quot;);
277   return true;
278 }
279 
280 /*
281 * 1. If the buffer was a &quot;lease&quot; from the global system, release back.
282 * 2. If the buffer is transient (temporal dynamically allocated), retire and register full.
283 *
284 * The buffer is effectively invalidated for the thread post-return,
285 * and the caller should take means to ensure that it is not referenced any longer.
286 */
287 void JfrStorage::release_large(BufferPtr buffer, Thread* thread) {
288   assert(buffer != NULL, &quot;invariant&quot;);
289   assert(buffer-&gt;lease(), &quot;invariant&quot;);
290   assert(buffer-&gt;acquired_by_self(), &quot;invariant&quot;);
291   buffer-&gt;clear_lease();
292   if (buffer-&gt;transient()) {
293     buffer-&gt;set_retired();
294     register_full(buffer, thread);
295   } else {
</pre>
<hr />
<pre>
307 static void log_registration_failure(size_t unflushed_size) {
308   log_warning(jfr)(&quot;Unable to register a full buffer of &quot; SIZE_FORMAT &quot; bytes.&quot;, unflushed_size);
309   log_debug(jfr, system)(&quot;Cleared 1 full buffer of &quot; SIZE_FORMAT &quot; bytes.&quot;, unflushed_size);
310 }
311 
312 static void handle_registration_failure(BufferPtr buffer) {
313   assert(buffer != NULL, &quot;invariant&quot;);
314   assert(buffer-&gt;retired(), &quot;invariant&quot;);
315   const size_t unflushed_size = buffer-&gt;unflushed_size();
316   buffer-&gt;reinitialize();
317   log_registration_failure(unflushed_size);
318 }
319 
320 static JfrAgeNode* get_free_age_node(JfrStorageAgeMspace* age_mspace, Thread* thread) {
321   assert(JfrBuffer_lock-&gt;owned_by_self(), &quot;invariant&quot;);
322   return mspace_get_free_with_detach(0, age_mspace, thread);
323 }
324 
325 static bool insert_full_age_node(JfrAgeNode* age_node, JfrStorageAgeMspace* age_mspace, Thread* thread) {
326   assert(JfrBuffer_lock-&gt;owned_by_self(), &quot;invariant&quot;);
<span class="line-added">327   assert(age_node != NULL, &quot;invariant&quot;);</span>
<span class="line-added">328   assert(age_node-&gt;acquired_by_self(), &quot;invariant&quot;);</span>
329   assert(age_node-&gt;retired_buffer()-&gt;retired(), &quot;invariant&quot;);
<span class="line-added">330   age_node-&gt;release(); // drop identity claim on age node when inserting to full list</span>
<span class="line-added">331   assert(age_node-&gt;identity() == NULL, &quot;invariant&quot;);</span>
332   age_mspace-&gt;insert_full_head(age_node);
333   return true;
334 }
335 
336 static bool full_buffer_registration(BufferPtr buffer, JfrStorageAgeMspace* age_mspace, JfrStorageControl&amp; control, Thread* thread) {
337   assert(buffer != NULL, &quot;invariant&quot;);
338   assert(buffer-&gt;retired(), &quot;invariant&quot;);
339   assert(age_mspace != NULL, &quot;invariant&quot;);
<span class="line-modified">340   MutexLocker lock(JfrBuffer_lock, Mutex::_no_safepoint_check_flag);</span>
341   JfrAgeNode* age_node = get_free_age_node(age_mspace, thread);
342   if (age_node == NULL) {
343     age_node = new_age_node(buffer, age_mspace, thread);
344     if (age_node == NULL) {
345       return false;
346     }
347   }

348   assert(age_node != NULL, &quot;invariant&quot;);
<span class="line-added">349   assert(age_node-&gt;acquired_by_self(), &quot;invariant&quot;);</span>
350   age_node-&gt;set_retired_buffer(buffer);
351   control.increment_full();
352   return insert_full_age_node(age_node, age_mspace, thread);
353 }
354 
355 void JfrStorage::register_full(BufferPtr buffer, Thread* thread) {
356   assert(buffer != NULL, &quot;invariant&quot;);
357   assert(buffer-&gt;retired(), &quot;invariant&quot;);
<span class="line-added">358   assert(buffer-&gt;acquired_by(thread), &quot;invariant&quot;);</span>
359   if (!full_buffer_registration(buffer, _age_mspace, control(), thread)) {
360     handle_registration_failure(buffer);

361   }
362   if (control().should_post_buffer_full_message()) {
363     _post_box.post(MSG_FULLBUFFER);
364   }
365 }
366 
367 void JfrStorage::lock() {
368   assert(!JfrBuffer_lock-&gt;owned_by_self(), &quot;invariant&quot;);
369   JfrBuffer_lock-&gt;lock_without_safepoint_check();
370 }
371 
372 void JfrStorage::unlock() {
373   assert(JfrBuffer_lock-&gt;owned_by_self(), &quot;invariant&quot;);
374   JfrBuffer_lock-&gt;unlock();
375 }
376 
377 #ifdef ASSERT
378 bool JfrStorage::is_locked() const {
379   return JfrBuffer_lock-&gt;owned_by_self();
380 }
381 #endif
382 
383 // don&#39;t use buffer on return, it is gone
384 void JfrStorage::release(BufferPtr buffer, Thread* thread) {
385   assert(buffer != NULL, &quot;invariant&quot;);
386   assert(!buffer-&gt;lease(), &quot;invariant&quot;);
387   assert(!buffer-&gt;transient(), &quot;invariant&quot;);
388   assert(!buffer-&gt;retired(), &quot;invariant&quot;);
389   if (!buffer-&gt;empty()) {
390     if (!flush_regular_buffer(buffer, thread)) {
<span class="line-modified">391       buffer-&gt;reinitialize();</span>
392     }
393   }
394   assert(buffer-&gt;empty(), &quot;invariant&quot;);
<span class="line-added">395   assert(buffer-&gt;identity() != NULL, &quot;invariant&quot;);</span>
396   control().increment_dead();

397   buffer-&gt;set_retired();
398 }
399 
400 void JfrStorage::release_thread_local(BufferPtr buffer, Thread* thread) {
401   assert(buffer != NULL, &quot;invariant&quot;);
402   JfrStorage&amp; storage_instance = instance();
403   storage_instance.release(buffer, thread);
404   if (storage_instance.control().should_scavenge()) {
405     storage_instance._post_box.post(MSG_DEADBUFFER);
406   }
407 }
408 
409 static void log_discard(size_t count, size_t amount, size_t current) {
410   if (log_is_enabled(Debug, jfr, system)) {
411     assert(count &gt; 0, &quot;invariant&quot;);
412     log_debug(jfr, system)(&quot;Cleared &quot; SIZE_FORMAT &quot; full buffer(s) of &quot; SIZE_FORMAT&quot; bytes.&quot;, count, amount);
413     log_debug(jfr, system)(&quot;Current number of full buffers &quot; SIZE_FORMAT &quot;&quot;, current);
414   }
415 }
416 
417 void JfrStorage::discard_oldest(Thread* thread) {
418   if (JfrBuffer_lock-&gt;try_lock()) {
419     if (!control().should_discard()) {
420       // another thread handled it
421       return;
422     }
423     const size_t num_full_pre_discard = control().full_count();
424     size_t num_full_post_discard = 0;
425     size_t discarded_size = 0;
426     while (true) {
427       JfrAgeNode* const oldest_age_node = _age_mspace-&gt;full_tail();
428       if (oldest_age_node == NULL) {
429         break;
430       }
<span class="line-added">431       assert(oldest_age_node-&gt;identity() == NULL, &quot;invariant&quot;);</span>
432       BufferPtr const buffer = oldest_age_node-&gt;retired_buffer();
433       assert(buffer-&gt;retired(), &quot;invariant&quot;);
<span class="line-modified">434       assert(buffer-&gt;identity() != NULL, &quot;invariant&quot;);</span>
<span class="line-added">435       discarded_size += buffer-&gt;discard();</span>
<span class="line-added">436       assert(buffer-&gt;unflushed_size() == 0, &quot;invariant&quot;);</span>
437       num_full_post_discard = control().decrement_full();
<span class="line-added">438       mspace_release_full(oldest_age_node, _age_mspace);</span>
439       if (buffer-&gt;transient()) {
440         mspace_release_full(buffer, _transient_mspace);

441         continue;





442       }
<span class="line-added">443       buffer-&gt;reinitialize();</span>
<span class="line-added">444       buffer-&gt;release(); // publish</span>
<span class="line-added">445       break;</span>
446     }
447     JfrBuffer_lock-&gt;unlock();
448     const size_t number_of_discards = num_full_pre_discard - num_full_post_discard;
449     if (number_of_discards &gt; 0) {
450       log_discard(number_of_discards, discarded_size, num_full_post_discard);
451     }
452   }
453 }
454 
455 #ifdef ASSERT
456 typedef const BufferPtr ConstBufferPtr;
457 
458 static void assert_flush_precondition(ConstBufferPtr cur, size_t used, bool native, const Thread* t) {
459   assert(t != NULL, &quot;invariant&quot;);
460   assert(cur != NULL, &quot;invariant&quot;);
461   assert(cur-&gt;pos() + used &lt;= cur-&gt;end(), &quot;invariant&quot;);
462   assert(native ? t-&gt;jfr_thread_local()-&gt;native_buffer() == cur : t-&gt;jfr_thread_local()-&gt;java_buffer() == cur, &quot;invariant&quot;);
463 }
464 
465 static void assert_flush_regular_precondition(ConstBufferPtr cur, const u1* const cur_pos, size_t used, size_t req, const Thread* t) {
466   assert(t != NULL, &quot;invariant&quot;);
467   assert(t-&gt;jfr_thread_local()-&gt;shelved_buffer() == NULL, &quot;invariant&quot;);
468   assert(cur != NULL, &quot;invariant&quot;);
469   assert(!cur-&gt;lease(), &quot;invariant&quot;);
470   assert(cur_pos != NULL, &quot;invariant&quot;);
471   assert(req &gt;= used, &quot;invariant&quot;);
472 }
473 
474 static void assert_provision_large_precondition(ConstBufferPtr cur, size_t used, size_t req, const Thread* t) {
475   assert(cur != NULL, &quot;invariant&quot;);
476   assert(t != NULL, &quot;invariant&quot;);
477   assert(t-&gt;jfr_thread_local()-&gt;shelved_buffer() != NULL, &quot;invariant&quot;);
478   assert(req &gt;= used, &quot;invariant&quot;);
479 }
480 
481 static void assert_flush_large_precondition(ConstBufferPtr cur, const u1* const cur_pos, size_t used, size_t req, bool native, Thread* t) {
482   assert(t != NULL, &quot;invariant&quot;);
483   assert(cur != NULL, &quot;invariant&quot;);
484   assert(cur-&gt;lease(), &quot;invariant&quot;);
<span class="line-added">485   assert(!cur-&gt;excluded(), &quot;invariant&quot;);</span>
486   assert(cur_pos != NULL, &quot;invariant&quot;);
487   assert(native ? t-&gt;jfr_thread_local()-&gt;native_buffer() == cur : t-&gt;jfr_thread_local()-&gt;java_buffer() == cur, &quot;invariant&quot;);
488   assert(t-&gt;jfr_thread_local()-&gt;shelved_buffer() != NULL, &quot;invariant&quot;);
489   assert(req &gt;= used, &quot;invariant&quot;);
490   assert(cur != t-&gt;jfr_thread_local()-&gt;shelved_buffer(), &quot;invariant&quot;);
491 }
492 #endif // ASSERT
493 
494 BufferPtr JfrStorage::flush(BufferPtr cur, size_t used, size_t req, bool native, Thread* t) {
495   debug_only(assert_flush_precondition(cur, used, native, t);)
496   const u1* const cur_pos = cur-&gt;pos();
497   req += used;
498   // requested size now encompass the outstanding used size
499   return cur-&gt;lease() ? instance().flush_large(cur, cur_pos, used, req, native, t) :
500                           instance().flush_regular(cur, cur_pos, used, req, native, t);
501 }
502 
503 BufferPtr JfrStorage::flush_regular(BufferPtr cur, const u1* const cur_pos, size_t used, size_t req, bool native, Thread* t) {
504   debug_only(assert_flush_regular_precondition(cur, cur_pos, used, req, t);)
505   // A flush is needed before memcpy since a non-large buffer is thread stable
506   // (thread local). The flush will not modify memory in addresses above pos()
507   // which is where the &quot;used / uncommitted&quot; data resides. It is therefore both
508   // possible and valid to migrate data after the flush. This is however only
509   // the case for stable thread local buffers; it is not the case for large buffers.
510   if (!cur-&gt;empty()) {
511     flush_regular_buffer(cur, t);
<span class="line-added">512     if (cur-&gt;excluded()) {</span>
<span class="line-added">513       return cur;</span>
<span class="line-added">514     }</span>
515   }
516   assert(t-&gt;jfr_thread_local()-&gt;shelved_buffer() == NULL, &quot;invariant&quot;);
517   if (cur-&gt;free_size() &gt;= req) {
518     // simplest case, no switching of buffers
519     if (used &gt; 0) {
520       memcpy(cur-&gt;pos(), (void*)cur_pos, used);
521     }
522     assert(native ? t-&gt;jfr_thread_local()-&gt;native_buffer() == cur : t-&gt;jfr_thread_local()-&gt;java_buffer() == cur, &quot;invariant&quot;);
523     return cur;
524   }
525   // Going for a &quot;larger-than-regular&quot; buffer.
526   // Shelve the current buffer to make room for a temporary lease.
527   t-&gt;jfr_thread_local()-&gt;shelve_buffer(cur);
528   return provision_large(cur, cur_pos, used, req, native, t);
529 }
530 
531 static BufferPtr store_buffer_to_thread_local(BufferPtr buffer, JfrThreadLocal* jfr_thread_local, bool native) {
532   assert(buffer != NULL, &quot;invariant&quot;);
533   if (native) {
534     jfr_thread_local-&gt;set_native_buffer(buffer);
</pre>
<hr />
<pre>
583   BufferPtr const buffer = acquire_large(req, t);
584   if (buffer == NULL) {
585     // unable to allocate and serve the request
586     return large_fail(cur, native, *this, t);
587   }
588   // ok managed to acquire a &quot;large&quot; buffer for the requested size
589   assert(buffer-&gt;free_size() &gt;= req, &quot;invariant&quot;);
590   assert(buffer-&gt;lease(), &quot;invariant&quot;);
591   // transfer outstanding data
592   memcpy(buffer-&gt;pos(), (void*)cur_pos, used);
593   if (cur-&gt;lease()) {
594     release_large(cur, t);
595     // don&#39;t use current anymore, it is gone
596   }
597   return store_buffer_to_thread_local(buffer, t-&gt;jfr_thread_local(), native);
598 }
599 
600 typedef UnBufferedWriteToChunk&lt;JfrBuffer&gt; WriteOperation;
601 typedef MutexedWriteOp&lt;WriteOperation&gt; MutexedWriteOperation;
602 typedef ConcurrentWriteOp&lt;WriteOperation&gt; ConcurrentWriteOperation;
<span class="line-modified">603 </span>
<span class="line-added">604 typedef Retired&lt;JfrBuffer, true&gt; NonRetired;</span>
<span class="line-added">605 typedef Excluded&lt;JfrBuffer, true&gt; NonExcluded;</span>
<span class="line-added">606 typedef CompositeOperation&lt;NonRetired, NonExcluded&gt; BufferPredicate;</span>
<span class="line-added">607 typedef PredicatedMutexedWriteOp&lt;WriteOperation, BufferPredicate&gt; ThreadLocalMutexedWriteOperation;</span>
<span class="line-added">608 typedef PredicatedConcurrentWriteOp&lt;WriteOperation, BufferPredicate&gt; ThreadLocalConcurrentWriteOperation;</span>
609 
610 size_t JfrStorage::write() {
<span class="line-modified">611   const size_t full_elements = write_full();</span>
612   WriteOperation wo(_chunkwriter);
<span class="line-modified">613   NonRetired nr;</span>
<span class="line-added">614   NonExcluded ne;</span>
<span class="line-added">615   BufferPredicate bp(&amp;nr, &amp;ne);</span>
<span class="line-added">616   ThreadLocalConcurrentWriteOperation tlwo(wo, bp);</span>
617   process_full_list(tlwo, _thread_local_mspace);
618   ConcurrentWriteOperation cwo(wo);
619   process_free_list(cwo, _global_mspace);
<span class="line-modified">620   return full_elements + wo.elements();</span>
621 }
622 
623 size_t JfrStorage::write_at_safepoint() {
624   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
625   WriteOperation wo(_chunkwriter);
626   MutexedWriteOperation writer(wo); // mutexed write mode
<span class="line-modified">627   NonRetired nr;</span>
<span class="line-added">628   NonExcluded ne;</span>
<span class="line-added">629   BufferPredicate bp(&amp;nr, &amp;ne);</span>
<span class="line-added">630   ThreadLocalMutexedWriteOperation tlmwo(wo, bp);</span>
<span class="line-added">631   process_full_list(tlmwo, _thread_local_mspace);</span>
632   assert(_transient_mspace-&gt;is_free_empty(), &quot;invariant&quot;);
633   process_full_list(writer, _transient_mspace);
634   assert(_global_mspace-&gt;is_full_empty(), &quot;invariant&quot;);
635   process_free_list(writer, _global_mspace);
<span class="line-modified">636   return wo.elements();</span>
637 }
638 
639 typedef DiscardOp&lt;DefaultDiscarder&lt;JfrStorage::Buffer&gt; &gt; DiscardOperation;
640 typedef ReleaseOp&lt;JfrStorageMspace&gt; ReleaseOperation;
641 typedef CompositeOperation&lt;MutexedWriteOperation, ReleaseOperation&gt; FullOperation;
642 
643 size_t JfrStorage::clear() {
<span class="line-modified">644   const size_t full_elements = clear_full();</span>
645   DiscardOperation discarder(concurrent); // concurrent discard mode
646   process_full_list(discarder, _thread_local_mspace);
647   assert(_transient_mspace-&gt;is_free_empty(), &quot;invariant&quot;);
648   process_full_list(discarder, _transient_mspace);
649   assert(_global_mspace-&gt;is_full_empty(), &quot;invariant&quot;);
650   process_free_list(discarder, _global_mspace);
<span class="line-modified">651   return full_elements + discarder.elements();</span>
652 }
653 
654 static void insert_free_age_nodes(JfrStorageAgeMspace* age_mspace, JfrAgeNode* head, JfrAgeNode* tail, size_t count) {
655   if (tail != NULL) {
656     assert(tail-&gt;next() == NULL, &quot;invariant&quot;);
657     assert(head != NULL, &quot;invariant&quot;);
658     assert(head-&gt;prev() == NULL, &quot;invariant&quot;);
<span class="line-modified">659     MutexLocker buffer_lock(JfrBuffer_lock, Mutex::_no_safepoint_check_flag);</span>
660     age_mspace-&gt;insert_free_tail(head, tail, count);
661   }
662 }
663 
664 template &lt;typename Processor&gt;
665 static void process_age_list(Processor&amp; processor, JfrStorageAgeMspace* age_mspace, JfrAgeNode* head, size_t count) {
666   assert(age_mspace != NULL, &quot;invariant&quot;);
667   assert(head != NULL, &quot;invariant&quot;);
668   assert(count &gt; 0, &quot;invariant&quot;);
669   JfrAgeNode* node = head;
670   JfrAgeNode* last = NULL;
671   while (node != NULL) {
672     last = node;
<span class="line-added">673     assert(node-&gt;identity() == NULL, &quot;invariant&quot;);</span>
674     BufferPtr const buffer = node-&gt;retired_buffer();
675     assert(buffer != NULL, &quot;invariant&quot;);
676     assert(buffer-&gt;retired(), &quot;invariant&quot;);
677     processor.process(buffer);
678     // at this point, buffer is already live or destroyed

679     JfrAgeNode* const next = (JfrAgeNode*)node-&gt;next();
680     if (node-&gt;transient()) {
681       // detach
682       last = (JfrAgeNode*)last-&gt;prev();
683       if (last != NULL) {
684         last-&gt;set_next(next);
685       } else {
686         head = next;
687       }
688       if (next != NULL) {
689         next-&gt;set_prev(last);
690       }
691       --count;
692       age_mspace-&gt;deallocate(node);
693     }
694     node = next;
695   }
696   insert_free_age_nodes(age_mspace, head, last, count);
697 }
698 
699 template &lt;typename Processor&gt;
700 static size_t process_full(Processor&amp; processor, JfrStorageControl&amp; control, JfrStorageAgeMspace* age_mspace) {
701   assert(age_mspace != NULL, &quot;invariant&quot;);
702   if (age_mspace-&gt;is_full_empty()) {
703     // nothing to do
704     return 0;
705   }
706   size_t count;
707   JfrAgeNode* head;
708   {
709     // fetch age list
<span class="line-modified">710     MutexLocker buffer_lock(JfrBuffer_lock, Mutex::_no_safepoint_check_flag);</span>
711     count = age_mspace-&gt;full_count();
712     head = age_mspace-&gt;clear_full();
713     control.reset_full();
714   }
715   assert(head != NULL, &quot;invariant&quot;);
716   assert(count &gt; 0, &quot;invariant&quot;);
717   process_age_list(processor, age_mspace, head, count);
718   return count;
719 }
720 
721 static void log(size_t count, size_t amount, bool clear = false) {
722   if (log_is_enabled(Debug, jfr, system)) {
723     if (count &gt; 0) {
724       log_debug(jfr, system)(&quot;%s &quot; SIZE_FORMAT &quot; full buffer(s) of &quot; SIZE_FORMAT&quot; B of data%s&quot;,
725         clear ? &quot;Discarded&quot; : &quot;Wrote&quot;, count, amount, clear ? &quot;.&quot; : &quot; to chunk.&quot;);
726     }
727   }
728 }
729 
730 // full writer
731 // Assumption is retired only; exclusive access
732 // MutexedWriter -&gt; ReleaseOp
733 //
734 size_t JfrStorage::write_full() {
735   assert(_chunkwriter.is_valid(), &quot;invariant&quot;);
736   Thread* const thread = Thread::current();
737   WriteOperation wo(_chunkwriter);
738   MutexedWriteOperation writer(wo); // a retired buffer implies mutexed access
739   ReleaseOperation ro(_transient_mspace, thread);
740   FullOperation cmd(&amp;writer, &amp;ro);
741   const size_t count = process_full(cmd, control(), _age_mspace);
<span class="line-modified">742   if (0 == count) {</span>
<span class="line-modified">743     assert(0 == writer.elements(), &quot;invariant&quot;);</span>
<span class="line-added">744     return 0;</span>
<span class="line-added">745   }</span>
<span class="line-added">746   const size_t size = writer.size();</span>
<span class="line-added">747   log(count, size);</span>
<span class="line-added">748   return count;</span>
749 }
750 
751 size_t JfrStorage::clear_full() {
752   DiscardOperation discarder(mutexed); // a retired buffer implies mutexed access
753   const size_t count = process_full(discarder, control(), _age_mspace);
<span class="line-modified">754   if (0 == count) {</span>
<span class="line-modified">755     assert(0 == discarder.elements(), &quot;invariant&quot;);</span>
<span class="line-added">756     return 0;</span>
<span class="line-added">757   }</span>
<span class="line-added">758   const size_t size = discarder.size();</span>
<span class="line-added">759   log(count, size, true);</span>
<span class="line-added">760   return count;</span>
761 }
762 
763 static void scavenge_log(size_t count, size_t amount, size_t current) {
764   if (count &gt; 0) {
765     if (log_is_enabled(Debug, jfr, system)) {
766       log_debug(jfr, system)(&quot;Released &quot; SIZE_FORMAT &quot; dead buffer(s) of &quot; SIZE_FORMAT&quot; B of data.&quot;, count, amount);
767       log_debug(jfr, system)(&quot;Current number of dead buffers &quot; SIZE_FORMAT &quot;&quot;, current);
768     }
769   }
770 }
771 
772 template &lt;typename Mspace&gt;
773 class Scavenger {
774 private:
775   JfrStorageControl&amp; _control;
776   Mspace* _mspace;
777   size_t _count;
778   size_t _amount;
779 public:
780   typedef typename Mspace::Type Type;
781   Scavenger(JfrStorageControl&amp; control, Mspace* mspace) : _control(control), _mspace(mspace), _count(0), _amount(0) {}
782   bool process(Type* t) {
783     if (t-&gt;retired()) {
<span class="line-added">784       assert(t-&gt;identity() != NULL, &quot;invariant&quot;);</span>
<span class="line-added">785       assert(t-&gt;empty(), &quot;invariant&quot;);</span>
786       assert(!t-&gt;transient(), &quot;invariant&quot;);
787       assert(!t-&gt;lease(), &quot;invariant&quot;);


788       ++_count;
789       _amount += t-&gt;total_size();
<span class="line-added">790       if (t-&gt;excluded()) {</span>
<span class="line-added">791         t-&gt;clear_excluded();</span>
<span class="line-added">792       }</span>
<span class="line-added">793       assert(!t-&gt;excluded(), &quot;invariant&quot;);</span>
794       t-&gt;clear_retired();
<span class="line-added">795       t-&gt;release();</span>
796       _control.decrement_dead();
797       mspace_release_full_critical(t, _mspace);
798     }
799     return true;
800   }
801   size_t processed() const { return _count; }
802   size_t amount() const { return _amount; }
803 };
804 
805 size_t JfrStorage::scavenge() {
806   JfrStorageControl&amp; ctrl = control();
807   if (ctrl.dead_count() == 0) {
808     return 0;
809   }
810   Scavenger&lt;JfrThreadLocalMspace&gt; scavenger(ctrl, _thread_local_mspace);
811   process_full_list(scavenger, _thread_local_mspace);
<span class="line-modified">812   const size_t count = scavenger.processed();</span>
<span class="line-modified">813   if (0 == count) {</span>
<span class="line-added">814     assert(0 == scavenger.amount(), &quot;invariant&quot;);</span>
<span class="line-added">815     return 0;</span>
<span class="line-added">816   }</span>
<span class="line-added">817   scavenge_log(count, scavenger.amount(), ctrl.dead_count());</span>
<span class="line-added">818   return count;</span>
819 }
</pre>
</td>
</tr>
</table>
<center><a href="jfrMemorySpace.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrStorage.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
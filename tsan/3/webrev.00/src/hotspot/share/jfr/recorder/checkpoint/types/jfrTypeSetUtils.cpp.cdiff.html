<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeSetUtils.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="jfrTypeSet.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="jfrTypeSetUtils.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeSetUtils.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 26,19 ***</span>
  #include &quot;jfr/recorder/checkpoint/types/jfrTypeSetUtils.hpp&quot;
  #include &quot;oops/instanceKlass.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/symbol.hpp&quot;
  
<span class="line-modified">! JfrSymbolId::JfrSymbolId() : _sym_table(new SymbolTable(this)), _cstring_table(new CStringTable(this)), _symbol_id_counter(0) {</span>
    assert(_sym_table != NULL, &quot;invariant&quot;);
    assert(_cstring_table != NULL, &quot;invariant&quot;);
<span class="line-modified">!   initialize();</span>
  }
  
<span class="line-modified">! void JfrSymbolId::initialize() {</span>
    clear();
<span class="line-modified">!   assert(_symbol_id_counter == 0, &quot;invariant&quot;);</span>
  }
  
  void JfrSymbolId::clear() {
    assert(_sym_table != NULL, &quot;invariant&quot;);
    if (_sym_table-&gt;has_entries()) {
<span class="line-new-header">--- 26,34 ---</span>
  #include &quot;jfr/recorder/checkpoint/types/jfrTypeSetUtils.hpp&quot;
  #include &quot;oops/instanceKlass.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/symbol.hpp&quot;
  
<span class="line-modified">! static JfrSymbolId::CStringEntry* bootstrap = NULL;</span>
<span class="line-added">+ </span>
<span class="line-added">+ JfrSymbolId::JfrSymbolId() :</span>
<span class="line-added">+   _sym_table(new SymbolTable(this)),</span>
<span class="line-added">+   _cstring_table(new CStringTable(this)),</span>
<span class="line-added">+   _sym_list(NULL),</span>
<span class="line-added">+   _cstring_list(NULL),</span>
<span class="line-added">+   _sym_query(NULL),</span>
<span class="line-added">+   _cstring_query(NULL),</span>
<span class="line-added">+   _symbol_id_counter(1),</span>
<span class="line-added">+   _class_unload(false) {</span>
    assert(_sym_table != NULL, &quot;invariant&quot;);
    assert(_cstring_table != NULL, &quot;invariant&quot;);
<span class="line-modified">!   bootstrap = new CStringEntry(0, (const char*)&amp;BOOTSTRAP_LOADER_NAME);</span>
<span class="line-added">+   assert(bootstrap != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   bootstrap-&gt;set_id(1);</span>
<span class="line-added">+   _cstring_list = bootstrap;</span>
  }
  
<span class="line-modified">! JfrSymbolId::~JfrSymbolId() {</span>
    clear();
<span class="line-modified">!   delete _sym_table;</span>
<span class="line-added">+   delete _cstring_table;</span>
<span class="line-added">+   delete bootstrap;</span>
  }
  
  void JfrSymbolId::clear() {
    assert(_sym_table != NULL, &quot;invariant&quot;);
    if (_sym_table-&gt;has_entries()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 49,212 ***</span>
    assert(_cstring_table != NULL, &quot;invariant&quot;);
    if (_cstring_table-&gt;has_entries()) {
      _cstring_table-&gt;clear_entries();
    }
    assert(!_cstring_table-&gt;has_entries(), &quot;invariant&quot;);
<span class="line-removed">-   _symbol_id_counter = 0;</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! JfrSymbolId::~JfrSymbolId() {</span>
<span class="line-modified">!   delete _sym_table;</span>
<span class="line-removed">-   delete _cstring_table;</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! traceid JfrSymbolId::mark_unsafe_anonymous_klass_name(const Klass* k) {</span>
<span class="line-modified">!   assert(k != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   assert(k-&gt;is_instance_klass(), &quot;invariant&quot;);</span>
<span class="line-removed">-   assert(is_unsafe_anonymous_klass(k), &quot;invariant&quot;);</span>
  
<span class="line-modified">!   uintptr_t anonymous_symbol_hash_code = 0;</span>
<span class="line-modified">!   const char* const anonymous_symbol =</span>
<span class="line-modified">!     create_unsafe_anonymous_klass_symbol((const InstanceKlass*)k, anonymous_symbol_hash_code);</span>
  
<span class="line-modified">!   if (anonymous_symbol == NULL) {</span>
<span class="line-modified">!     return 0;</span>
<span class="line-modified">!   }</span>
  
<span class="line-modified">!   assert(anonymous_symbol_hash_code != 0, &quot;invariant&quot;);</span>
<span class="line-modified">!   traceid symbol_id = mark(anonymous_symbol, anonymous_symbol_hash_code);</span>
<span class="line-modified">!   assert(mark(anonymous_symbol, anonymous_symbol_hash_code) == symbol_id, &quot;invariant&quot;);</span>
<span class="line-modified">!   return symbol_id;</span>
  }
  
<span class="line-modified">! const JfrSymbolId::SymbolEntry* JfrSymbolId::map_symbol(const Symbol* symbol) const {</span>
<span class="line-modified">!   return _sym_table-&gt;lookup_only(symbol, (uintptr_t)const_cast&lt;Symbol*&gt;(symbol)-&gt;identity_hash());</span>
  }
  
<span class="line-modified">! const JfrSymbolId::SymbolEntry* JfrSymbolId::map_symbol(uintptr_t hash) const {</span>
<span class="line-modified">!   return _sym_table-&gt;lookup_only(NULL, hash);</span>
  }
  
<span class="line-modified">! const JfrSymbolId::CStringEntry* JfrSymbolId::map_cstring(uintptr_t hash) const {</span>
<span class="line-modified">!   return _cstring_table-&gt;lookup_only(NULL, hash);</span>
  }
  
<span class="line-modified">! void JfrSymbolId::assign_id(SymbolEntry* entry) {</span>
    assert(entry != NULL, &quot;invariant&quot;);
    assert(entry-&gt;id() == 0, &quot;invariant&quot;);
    entry-&gt;set_id(++_symbol_id_counter);
  }
  
<span class="line-modified">! bool JfrSymbolId::equals(const Symbol* query, uintptr_t hash, const SymbolEntry* entry) {</span>
<span class="line-modified">!   // query might be NULL</span>
<span class="line-modified">!   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(entry-&gt;hash() == hash, &quot;invariant&quot;);</span>
<span class="line-modified">!   return true;</span>
  }
  
<span class="line-modified">! void JfrSymbolId::assign_id(CStringEntry* entry) {</span>
    assert(entry != NULL, &quot;invariant&quot;);
<span class="line-modified">!   assert(entry-&gt;id() == 0, &quot;invariant&quot;);</span>
<span class="line-modified">!   entry-&gt;set_id(++_symbol_id_counter);</span>
  }
  
<span class="line-modified">! bool JfrSymbolId::equals(const char* query, uintptr_t hash, const CStringEntry* entry) {</span>
<span class="line-removed">-   // query might be NULL</span>
    assert(entry != NULL, &quot;invariant&quot;);
<span class="line-modified">!   assert(entry-&gt;hash() == hash, &quot;invariant&quot;);</span>
<span class="line-removed">-   return true;</span>
  }
  
<span class="line-modified">! traceid JfrSymbolId::mark(const Klass* k) {</span>
<span class="line-modified">!   assert(k != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   traceid symbol_id = 0;</span>
<span class="line-modified">!   if (is_unsafe_anonymous_klass(k)) {</span>
<span class="line-removed">-     symbol_id = mark_unsafe_anonymous_klass_name(k);</span>
    }
<span class="line-modified">!   if (0 == symbol_id) {</span>
<span class="line-removed">-     const Symbol* const sym = k-&gt;name();</span>
<span class="line-removed">-     if (sym != NULL) {</span>
<span class="line-removed">-       symbol_id = mark(sym);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   assert(symbol_id &gt; 0, &quot;a symbol handler must mark the symbol for writing&quot;);</span>
<span class="line-removed">-   return symbol_id;</span>
  }
  
<span class="line-modified">! traceid JfrSymbolId::mark(const Symbol* symbol) {</span>
    assert(symbol != NULL, &quot;invariant&quot;);
<span class="line-modified">!   return mark(symbol, (uintptr_t)const_cast&lt;Symbol*&gt;(symbol)-&gt;identity_hash());</span>
  }
  
<span class="line-modified">! traceid JfrSymbolId::mark(const Symbol* data, uintptr_t hash) {</span>
    assert(data != NULL, &quot;invariant&quot;);
    assert(_sym_table != NULL, &quot;invariant&quot;);
<span class="line-modified">!   return _sym_table-&gt;id(data, hash);</span>
  }
  
<span class="line-modified">! traceid JfrSymbolId::mark(const char* str, uintptr_t hash) {</span>
    assert(str != NULL, &quot;invariant&quot;);
<span class="line-modified">!   return _cstring_table-&gt;id(str, hash);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! bool JfrSymbolId::is_unsafe_anonymous_klass(const Klass* k) {</span>
<span class="line-modified">!   assert(k != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   return k-&gt;is_instance_klass() &amp;&amp; ((const InstanceKlass*)k)-&gt;is_unsafe_anonymous();</span>
  }
  
  /*
  * jsr292 anonymous classes symbol is the external name +
  * the identity_hashcode slash appended:
  *   java.lang.invoke.LambdaForm$BMH/22626602
  *
  * caller needs ResourceMark
  */
  
<span class="line-modified">! uintptr_t JfrSymbolId::unsafe_anonymous_klass_name_hash_code(const InstanceKlass* ik) {</span>
    assert(ik != NULL, &quot;invariant&quot;);
    assert(ik-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);
    const oop mirror = ik-&gt;java_mirror_no_keepalive();
    assert(mirror != NULL, &quot;invariant&quot;);
    return (uintptr_t)mirror-&gt;identity_hash();
  }
  
<span class="line-modified">! const char* JfrSymbolId::create_unsafe_anonymous_klass_symbol(const InstanceKlass* ik, uintptr_t&amp; hashcode) {</span>
    assert(ik != NULL, &quot;invariant&quot;);
    assert(ik-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);
<span class="line-modified">!   assert(0 == hashcode, &quot;invariant&quot;);</span>
    char* anonymous_symbol = NULL;
    const oop mirror = ik-&gt;java_mirror_no_keepalive();
    assert(mirror != NULL, &quot;invariant&quot;);
    char hash_buf[40];
<span class="line-modified">!   hashcode = unsafe_anonymous_klass_name_hash_code(ik);</span>
<span class="line-removed">-   sprintf(hash_buf, &quot;/&quot; UINTX_FORMAT, hashcode);</span>
    const size_t hash_len = strlen(hash_buf);
    const size_t result_len = ik-&gt;name()-&gt;utf8_length();
    anonymous_symbol = NEW_RESOURCE_ARRAY(char, result_len + hash_len + 1);
    ik-&gt;name()-&gt;as_klass_external_name(anonymous_symbol, (int)result_len + 1);
    assert(strlen(anonymous_symbol) == result_len, &quot;invariant&quot;);
    strcpy(anonymous_symbol + result_len, hash_buf);
    assert(strlen(anonymous_symbol) == result_len + hash_len, &quot;invariant&quot;);
    return anonymous_symbol;
  }
  
<span class="line-modified">! uintptr_t JfrSymbolId::regular_klass_name_hash_code(const Klass* k) {</span>
    assert(k != NULL, &quot;invariant&quot;);
<span class="line-modified">!   const Symbol* const sym = k-&gt;name();</span>
<span class="line-modified">!   assert(sym != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   return (uintptr_t)const_cast&lt;Symbol*&gt;(sym)-&gt;identity_hash();</span>
  }
  
  JfrArtifactSet::JfrArtifactSet(bool class_unload) : _symbol_id(new JfrSymbolId()),
                                                      _klass_list(NULL),
<span class="line-modified">!                                                     _class_unload(class_unload) {</span>
    initialize(class_unload);
    assert(_klass_list != NULL, &quot;invariant&quot;);
  }
  
  static const size_t initial_class_list_size = 200;
<span class="line-modified">! void JfrArtifactSet::initialize(bool class_unload) {</span>
    assert(_symbol_id != NULL, &quot;invariant&quot;);
<span class="line-modified">!   _symbol_id-&gt;initialize();</span>
<span class="line-modified">!   assert(!_symbol_id-&gt;has_entries(), &quot;invariant&quot;);</span>
<span class="line-modified">!   _symbol_id-&gt;mark(BOOTSTRAP_LOADER_NAME, 0); // pre-load &quot;bootstrap&quot;</span>
<span class="line-modified">!   _class_unload = class_unload;</span>
    // resource allocation
    _klass_list = new GrowableArray&lt;const Klass*&gt;(initial_class_list_size, false, mtTracing);
  }
  
  JfrArtifactSet::~JfrArtifactSet() {
<span class="line-removed">-   clear();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void JfrArtifactSet::clear() {</span>
    _symbol_id-&gt;clear();
    // _klass_list will be cleared by a ResourceMark
  }
  
<span class="line-modified">! traceid JfrArtifactSet::mark_unsafe_anonymous_klass_name(const Klass* klass) {</span>
<span class="line-modified">!   return _symbol_id-&gt;mark_unsafe_anonymous_klass_name(klass);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- traceid JfrArtifactSet::mark(const Symbol* sym, uintptr_t hash) {</span>
<span class="line-removed">-   return _symbol_id-&gt;mark(sym, hash);</span>
  }
  
<span class="line-modified">! traceid JfrArtifactSet::mark(const Klass* klass) {</span>
<span class="line-modified">!   return _symbol_id-&gt;mark(klass);</span>
  }
  
<span class="line-modified">! traceid JfrArtifactSet::mark(const Symbol* symbol) {</span>
<span class="line-modified">!   return _symbol_id-&gt;mark(symbol);</span>
  }
  
<span class="line-modified">! traceid JfrArtifactSet::mark(const char* const str, uintptr_t hash) {</span>
<span class="line-modified">!   return _symbol_id-&gt;mark(str, hash);</span>
  }
  
<span class="line-modified">! const JfrSymbolId::SymbolEntry* JfrArtifactSet::map_symbol(const Symbol* symbol) const {</span>
<span class="line-modified">!   return _symbol_id-&gt;map_symbol(symbol);</span>
  }
  
<span class="line-modified">! const JfrSymbolId::SymbolEntry* JfrArtifactSet::map_symbol(uintptr_t hash) const {</span>
<span class="line-modified">!   return _symbol_id-&gt;map_symbol(hash);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- const JfrSymbolId::CStringEntry* JfrArtifactSet::map_cstring(uintptr_t hash) const {</span>
<span class="line-removed">-   return _symbol_id-&gt;map_cstring(hash);</span>
  }
  
  bool JfrArtifactSet::has_klass_entries() const {
    return _klass_list-&gt;is_nonempty();
  }
<span class="line-new-header">--- 64,239 ---</span>
    assert(_cstring_table != NULL, &quot;invariant&quot;);
    if (_cstring_table-&gt;has_entries()) {
      _cstring_table-&gt;clear_entries();
    }
    assert(!_cstring_table-&gt;has_entries(), &quot;invariant&quot;);
  
<span class="line-modified">!   _sym_list = NULL;</span>
<span class="line-modified">!   _symbol_id_counter = 1;</span>
  
<span class="line-modified">!   _sym_query = NULL;</span>
<span class="line-modified">!   _cstring_query = NULL;</span>
  
<span class="line-modified">!   assert(bootstrap != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   bootstrap-&gt;reset();</span>
<span class="line-modified">!   _cstring_list = bootstrap;</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! void JfrSymbolId::set_class_unload(bool class_unload) {</span>
<span class="line-modified">!   _class_unload = class_unload;</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void JfrSymbolId::on_link(const SymbolEntry* entry) {</span>
<span class="line-modified">!   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   const_cast&lt;Symbol*&gt;(entry-&gt;literal())-&gt;increment_refcount();</span>
<span class="line-modified">!   assert(entry-&gt;id() == 0, &quot;invariant&quot;);</span>
<span class="line-added">+   entry-&gt;set_id(++_symbol_id_counter);</span>
<span class="line-added">+   entry-&gt;set_list_next(_sym_list);</span>
<span class="line-added">+   _sym_list = entry;</span>
  }
  
<span class="line-modified">! bool JfrSymbolId::on_equals(uintptr_t hash, const SymbolEntry* entry) {</span>
<span class="line-modified">!   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(entry-&gt;hash() == hash, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(_sym_query != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   return _sym_query == entry-&gt;literal();</span>
  }
  
<span class="line-modified">! void JfrSymbolId::on_unlink(const SymbolEntry* entry) {</span>
<span class="line-modified">!   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   const_cast&lt;Symbol*&gt;(entry-&gt;literal())-&gt;decrement_refcount();</span>
  }
  
<span class="line-modified">! static const char* resource_to_cstring(const char* resource_str) {</span>
<span class="line-modified">!   assert(resource_str != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   const size_t length = strlen(resource_str);</span>
<span class="line-added">+   char* const c_string = JfrCHeapObj::new_array&lt;char&gt;(length + 1);</span>
<span class="line-added">+   assert(c_string != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   strncpy(c_string, resource_str, length + 1);</span>
<span class="line-added">+   return c_string;</span>
  }
  
<span class="line-modified">! void JfrSymbolId::on_link(const CStringEntry* entry) {</span>
    assert(entry != NULL, &quot;invariant&quot;);
    assert(entry-&gt;id() == 0, &quot;invariant&quot;);
    entry-&gt;set_id(++_symbol_id_counter);
<span class="line-added">+   const_cast&lt;CStringEntry*&gt;(entry)-&gt;set_literal(resource_to_cstring(entry-&gt;literal()));</span>
<span class="line-added">+   entry-&gt;set_list_next(_cstring_list);</span>
<span class="line-added">+   _cstring_list = entry;</span>
  }
  
<span class="line-modified">! static bool string_compare(const char* query, const char* candidate) {</span>
<span class="line-modified">!   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(candidate != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   const size_t length = strlen(query);</span>
<span class="line-modified">!   return strncmp(query, candidate, length) == 0;</span>
  }
  
<span class="line-modified">! bool JfrSymbolId::on_equals(uintptr_t hash, const CStringEntry* entry) {</span>
    assert(entry != NULL, &quot;invariant&quot;);
<span class="line-modified">!   assert(entry-&gt;hash() == hash, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(_cstring_query != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   return string_compare(_cstring_query, entry-&gt;literal());</span>
  }
  
<span class="line-modified">! void JfrSymbolId::on_unlink(const CStringEntry* entry) {</span>
    assert(entry != NULL, &quot;invariant&quot;);
<span class="line-modified">!   JfrCHeapObj::free(const_cast&lt;char*&gt;(entry-&gt;literal()), strlen(entry-&gt;literal() + 1));</span>
  }
  
<span class="line-modified">! traceid JfrSymbolId::bootstrap_name(bool leakp) {</span>
<span class="line-modified">!   assert(bootstrap != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   if (leakp) {</span>
<span class="line-modified">!     bootstrap-&gt;set_leakp();</span>
    }
<span class="line-modified">!   return 1;</span>
  }
  
<span class="line-modified">! traceid JfrSymbolId::mark(const Symbol* symbol, bool leakp) {</span>
    assert(symbol != NULL, &quot;invariant&quot;);
<span class="line-modified">!   return mark((uintptr_t)symbol-&gt;identity_hash(), symbol, leakp);</span>
  }
  
<span class="line-modified">! traceid JfrSymbolId::mark(uintptr_t hash, const Symbol* data, bool leakp) {</span>
    assert(data != NULL, &quot;invariant&quot;);
    assert(_sym_table != NULL, &quot;invariant&quot;);
<span class="line-modified">!   _sym_query = data;</span>
<span class="line-added">+   const SymbolEntry&amp; entry = _sym_table-&gt;lookup_put(hash, data);</span>
<span class="line-added">+   if (_class_unload) {</span>
<span class="line-added">+     entry.set_unloading();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (leakp) {</span>
<span class="line-added">+     entry.set_leakp();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return entry.id();</span>
  }
  
<span class="line-modified">! traceid JfrSymbolId::mark(uintptr_t hash, const char* str, bool leakp) {</span>
    assert(str != NULL, &quot;invariant&quot;);
<span class="line-modified">!   assert(_cstring_table != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   _cstring_query = str;</span>
<span class="line-modified">!   const CStringEntry&amp; entry = _cstring_table-&gt;lookup_put(hash, str);</span>
<span class="line-modified">!   if (_class_unload) {</span>
<span class="line-modified">!     entry.set_unloading();</span>
<span class="line-modified">!   }</span>
<span class="line-added">+   if (leakp) {</span>
<span class="line-added">+     entry.set_leakp();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return entry.id();</span>
  }
  
  /*
  * jsr292 anonymous classes symbol is the external name +
  * the identity_hashcode slash appended:
  *   java.lang.invoke.LambdaForm$BMH/22626602
  *
  * caller needs ResourceMark
  */
  
<span class="line-modified">! uintptr_t JfrSymbolId::unsafe_anonymous_klass_name_hash(const InstanceKlass* ik) {</span>
    assert(ik != NULL, &quot;invariant&quot;);
    assert(ik-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);
    const oop mirror = ik-&gt;java_mirror_no_keepalive();
    assert(mirror != NULL, &quot;invariant&quot;);
    return (uintptr_t)mirror-&gt;identity_hash();
  }
  
<span class="line-modified">! static const char* create_unsafe_anonymous_klass_symbol(const InstanceKlass* ik, uintptr_t hash) {</span>
    assert(ik != NULL, &quot;invariant&quot;);
    assert(ik-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);
<span class="line-modified">!   assert(hash != 0, &quot;invariant&quot;);</span>
    char* anonymous_symbol = NULL;
    const oop mirror = ik-&gt;java_mirror_no_keepalive();
    assert(mirror != NULL, &quot;invariant&quot;);
    char hash_buf[40];
<span class="line-modified">!   sprintf(hash_buf, &quot;/&quot; UINTX_FORMAT, hash);</span>
    const size_t hash_len = strlen(hash_buf);
    const size_t result_len = ik-&gt;name()-&gt;utf8_length();
    anonymous_symbol = NEW_RESOURCE_ARRAY(char, result_len + hash_len + 1);
    ik-&gt;name()-&gt;as_klass_external_name(anonymous_symbol, (int)result_len + 1);
    assert(strlen(anonymous_symbol) == result_len, &quot;invariant&quot;);
    strcpy(anonymous_symbol + result_len, hash_buf);
    assert(strlen(anonymous_symbol) == result_len + hash_len, &quot;invariant&quot;);
    return anonymous_symbol;
  }
  
<span class="line-modified">! bool JfrSymbolId::is_unsafe_anonymous_klass(const Klass* k) {</span>
    assert(k != NULL, &quot;invariant&quot;);
<span class="line-modified">!   return k-&gt;is_instance_klass() &amp;&amp; ((const InstanceKlass*)k)-&gt;is_unsafe_anonymous();</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-added">+ traceid JfrSymbolId::mark_unsafe_anonymous_klass_name(const InstanceKlass* ik, bool leakp) {</span>
<span class="line-added">+   assert(ik != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(ik-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);</span>
<span class="line-added">+   const uintptr_t hash = unsafe_anonymous_klass_name_hash(ik);</span>
<span class="line-added">+   const char* const anonymous_klass_symbol = create_unsafe_anonymous_klass_symbol(ik, hash);</span>
<span class="line-added">+   return mark(hash, anonymous_klass_symbol, leakp);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ traceid JfrSymbolId::mark(const Klass* k, bool leakp) {</span>
<span class="line-added">+   assert(k != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   traceid symbol_id = 0;</span>
<span class="line-added">+   if (is_unsafe_anonymous_klass(k)) {</span>
<span class="line-added">+     assert(k-&gt;is_instance_klass(), &quot;invariant&quot;);</span>
<span class="line-added">+     symbol_id = mark_unsafe_anonymous_klass_name((const InstanceKlass*)k, leakp);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (0 == symbol_id) {</span>
<span class="line-added">+     Symbol* const sym = k-&gt;name();</span>
<span class="line-added">+     if (sym != NULL) {</span>
<span class="line-added">+       symbol_id = mark(sym, leakp);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+   assert(symbol_id &gt; 0, &quot;a symbol handler must mark the symbol for writing&quot;);</span>
<span class="line-added">+   return symbol_id;</span>
  }
  
  JfrArtifactSet::JfrArtifactSet(bool class_unload) : _symbol_id(new JfrSymbolId()),
                                                      _klass_list(NULL),
<span class="line-modified">!                                                     _total_count(0) {</span>
    initialize(class_unload);
    assert(_klass_list != NULL, &quot;invariant&quot;);
  }
  
  static const size_t initial_class_list_size = 200;
<span class="line-modified">! </span>
<span class="line-added">+ void JfrArtifactSet::initialize(bool class_unload, bool clear /* false */) {</span>
    assert(_symbol_id != NULL, &quot;invariant&quot;);
<span class="line-modified">!   if (clear) {</span>
<span class="line-modified">!     _symbol_id-&gt;clear();</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   _symbol_id-&gt;set_class_unload(class_unload);</span>
<span class="line-added">+   _total_count = 0;</span>
    // resource allocation
    _klass_list = new GrowableArray&lt;const Klass*&gt;(initial_class_list_size, false, mtTracing);
  }
  
  JfrArtifactSet::~JfrArtifactSet() {
    _symbol_id-&gt;clear();
<span class="line-added">+   delete _symbol_id;</span>
    // _klass_list will be cleared by a ResourceMark
  }
  
<span class="line-modified">! traceid JfrArtifactSet::bootstrap_name(bool leakp) {</span>
<span class="line-modified">!   return _symbol_id-&gt;bootstrap_name(leakp);</span>
  }
  
<span class="line-modified">! traceid JfrArtifactSet::mark_unsafe_anonymous_klass_name(const Klass* klass, bool leakp) {</span>
<span class="line-modified">!   assert(klass-&gt;is_instance_klass(), &quot;invariant&quot;);</span>
<span class="line-added">+   return _symbol_id-&gt;mark_unsafe_anonymous_klass_name((const InstanceKlass*)klass, leakp);</span>
  }
  
<span class="line-modified">! traceid JfrArtifactSet::mark(uintptr_t hash, const Symbol* sym, bool leakp) {</span>
<span class="line-modified">!   return _symbol_id-&gt;mark(hash, sym, leakp);</span>
  }
  
<span class="line-modified">! traceid JfrArtifactSet::mark(const Klass* klass, bool leakp) {</span>
<span class="line-modified">!   return _symbol_id-&gt;mark(klass, leakp);</span>
  }
  
<span class="line-modified">! traceid JfrArtifactSet::mark(const Symbol* symbol, bool leakp) {</span>
<span class="line-modified">!   return _symbol_id-&gt;mark(symbol, leakp);</span>
  }
  
<span class="line-modified">! traceid JfrArtifactSet::mark(uintptr_t hash, const char* const str, bool leakp) {</span>
<span class="line-modified">!   return _symbol_id-&gt;mark(hash, str, leakp);</span>
  }
  
  bool JfrArtifactSet::has_klass_entries() const {
    return _klass_list-&gt;is_nonempty();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 267,5 ***</span>
<span class="line-new-header">--- 309,9 ---</span>
    assert(k != NULL, &quot;invariant&quot;);
    assert(_klass_list != NULL, &quot;invariant&quot;);
    assert(_klass_list-&gt;find(k) == -1, &quot;invariant&quot;);
    _klass_list-&gt;append(k);
  }
<span class="line-added">+ </span>
<span class="line-added">+ size_t JfrArtifactSet::total_count() const {</span>
<span class="line-added">+   return _total_count;</span>
<span class="line-added">+ }</span>
</pre>
<center><a href="jfrTypeSet.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="jfrTypeSetUtils.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
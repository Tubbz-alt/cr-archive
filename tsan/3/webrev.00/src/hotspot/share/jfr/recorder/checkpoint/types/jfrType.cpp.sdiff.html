<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/recorder/checkpoint/types/jfrType.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="jfrThreadState.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="jfrType.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/checkpoint/types/jfrType.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/javaClasses.inline.hpp&quot;
 27 #include &quot;code/codeBlob.hpp&quot;
 28 #include &quot;code/codeCache.hpp&quot;

 29 #include &quot;gc/shared/gcCause.hpp&quot;
 30 #include &quot;gc/shared/gcName.hpp&quot;
 31 #include &quot;gc/shared/gcTrace.hpp&quot;
 32 #include &quot;gc/shared/gcWhen.hpp&quot;
<span class="line-removed"> 33 #include &quot;jfr/leakprofiler/checkpoint/objectSampleCheckpoint.hpp&quot;</span>
 34 #include &quot;jfr/leakprofiler/leakProfiler.hpp&quot;
<span class="line-modified"> 35 #include &quot;jfr/recorder/checkpoint/jfrCheckpointManager.hpp&quot;</span>
 36 #include &quot;jfr/recorder/checkpoint/types/jfrType.hpp&quot;
 37 #include &quot;jfr/recorder/jfrRecorder.hpp&quot;
 38 #include &quot;jfr/recorder/checkpoint/types/jfrThreadGroup.hpp&quot;
 39 #include &quot;jfr/recorder/checkpoint/types/jfrThreadState.hpp&quot;
<span class="line-removed"> 40 #include &quot;jfr/recorder/checkpoint/types/jfrTypeSet.hpp&quot;</span>
 41 #include &quot;jfr/support/jfrThreadLocal.hpp&quot;
 42 #include &quot;jfr/writers/jfrJavaEventWriter.hpp&quot;


 43 #include &quot;memory/metaspaceGCThresholdUpdater.hpp&quot;
 44 #include &quot;memory/referenceType.hpp&quot;
 45 #include &quot;memory/universe.hpp&quot;

 46 #include &quot;runtime/flags/jvmFlag.hpp&quot;
 47 #include &quot;runtime/mutexLocker.hpp&quot;
 48 #include &quot;runtime/osThread.hpp&quot;
 49 #include &quot;runtime/safepoint.hpp&quot;
 50 #include &quot;runtime/synchronizer.hpp&quot;
 51 #include &quot;runtime/thread.inline.hpp&quot;
 52 #include &quot;runtime/vmOperations.hpp&quot;
 53 
 54 #ifdef COMPILER2
 55 #include &quot;opto/compile.hpp&quot;
 56 #include &quot;opto/node.hpp&quot;
 57 #endif
<span class="line-removed"> 58 #if INCLUDE_G1GC</span>
<span class="line-removed"> 59 #include &quot;gc/g1/g1HeapRegionTraceType.hpp&quot;</span>
<span class="line-removed"> 60 #include &quot;gc/g1/g1YCTypes.hpp&quot;</span>
<span class="line-removed"> 61 #endif</span>
 62 
 63 // Requires a ResourceMark for get_thread_name/as_utf8
 64 class JfrCheckpointThreadClosure : public ThreadClosure {
 65  private:
 66   JfrCheckpointWriter&amp; _writer;
 67   JfrCheckpointContext _ctx;
 68   const int64_t _count_position;
 69   Thread* const _curthread;
 70   u4 _count;
 71 
 72  public:
 73   JfrCheckpointThreadClosure(JfrCheckpointWriter&amp; writer) : _writer(writer),
 74                                                             _ctx(writer.context()),
 75                                                             _count_position(writer.reserve(sizeof(u4))),
 76                                                             _curthread(Thread::current()),
 77                                                             _count(0) {
 78   }
 79 
 80   ~JfrCheckpointThreadClosure() {
 81     if (_count == 0) {
 82       // restore
 83       _writer.set_context(_ctx);
 84       return;
 85     }
 86     _writer.write_count(_count, _count_position);
 87   }
 88 
 89   void do_thread(Thread* t);
 90 };
 91 
<span class="line-removed"> 92 // Requires a ResourceMark for get_thread_name/as_utf8</span>
 93 void JfrCheckpointThreadClosure::do_thread(Thread* t) {
 94   assert(t != NULL, &quot;invariant&quot;);
<span class="line-removed"> 95   assert_locked_or_safepoint(Threads_lock);</span>
<span class="line-removed"> 96   const JfrThreadLocal* const tl = t-&gt;jfr_thread_local();</span>
<span class="line-removed"> 97   assert(tl != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 98   if (tl-&gt;is_dead()) {</span>
<span class="line-removed"> 99     return;</span>
<span class="line-removed">100   }</span>
101   ++_count;
<span class="line-modified">102   _writer.write_key(tl-&gt;thread_id());</span>
<span class="line-modified">103   _writer.write(t-&gt;name());</span>
<span class="line-modified">104   const OSThread* const os_thread = t-&gt;osthread();</span>
<span class="line-modified">105   _writer.write&lt;traceid&gt;(os_thread != NULL ? os_thread-&gt;thread_id() : 0);</span>

106   if (t-&gt;is_Java_thread()) {
<span class="line-modified">107     JavaThread* const jt = (JavaThread*)t;</span>
<span class="line-modified">108     _writer.write(jt-&gt;name());</span>
<span class="line-modified">109     _writer.write(java_lang_Thread::thread_id(jt-&gt;threadObj()));</span>
<span class="line-removed">110     _writer.write(JfrThreadGroup::thread_group_id(jt, _curthread));</span>
<span class="line-removed">111     // since we are iterating threads during a safepoint, also issue notification</span>
<span class="line-removed">112     JfrJavaEventWriter::notify(jt);</span>
113     return;
114   }
115   _writer.write((const char*)NULL); // java name
116   _writer.write((traceid)0); // java thread id
117   _writer.write((traceid)0); // java thread group
118 }
119 
120 void JfrThreadConstantSet::serialize(JfrCheckpointWriter&amp; writer) {
<span class="line-removed">121   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);</span>
122   JfrCheckpointThreadClosure tc(writer);
<span class="line-modified">123   Threads::threads_do(&amp;tc);</span>







124 }
125 
126 void JfrThreadGroupConstant::serialize(JfrCheckpointWriter&amp; writer) {
<span class="line-removed">127   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);</span>
128   JfrThreadGroup::serialize(writer);
129 }
130 
131 static const char* flag_value_origin_to_string(JVMFlag::Flags origin) {
132   switch (origin) {
133     case JVMFlag::DEFAULT: return &quot;Default&quot;;
134     case JVMFlag::COMMAND_LINE: return &quot;Command line&quot;;
135     case JVMFlag::ENVIRON_VAR: return &quot;Environment variable&quot;;
136     case JVMFlag::CONFIG_FILE: return &quot;Config file&quot;;
137     case JVMFlag::MANAGEMENT: return &quot;Management&quot;;
138     case JVMFlag::ERGONOMIC: return &quot;Ergonomic&quot;;
139     case JVMFlag::ATTACH_ON_DEMAND: return &quot;Attach on demand&quot;;
140     case JVMFlag::INTERNAL: return &quot;Internal&quot;;

141     default: ShouldNotReachHere(); return &quot;&quot;;
142   }
143 }
144 
145 void FlagValueOriginConstant::serialize(JfrCheckpointWriter&amp; writer) {
146   static const u4 nof_entries = JVMFlag::LAST_VALUE_ORIGIN + 1;
147   writer.write_count(nof_entries);
148   for (u4 i = 0; i &lt; nof_entries; ++i) {
149     writer.write_key(i);
150     writer.write(flag_value_origin_to_string((JVMFlag::Flags)i));
151   }
152 }
153 
154 void MonitorInflateCauseConstant::serialize(JfrCheckpointWriter&amp; writer) {
155   static const u4 nof_entries = ObjectSynchronizer::inflate_cause_nof;
156   writer.write_count(nof_entries);
157   for (u4 i = 0; i &lt; nof_entries; ++i) {
158     writer.write_key(i);
159     writer.write(ObjectSynchronizer::inflate_cause_name((ObjectSynchronizer::InflateCause)i));
160   }
</pre>
<hr />
<pre>
170 }
171 
172 void GCNameConstant::serialize(JfrCheckpointWriter&amp; writer) {
173   static const u4 nof_entries = GCNameEndSentinel;
174   writer.write_count(nof_entries);
175   for (u4 i = 0; i &lt; nof_entries; ++i) {
176     writer.write_key(i);
177     writer.write(GCNameHelper::to_string((GCName)i));
178   }
179 }
180 
181 void GCWhenConstant::serialize(JfrCheckpointWriter&amp; writer) {
182   static const u4 nof_entries = GCWhen::GCWhenEndSentinel;
183   writer.write_count(nof_entries);
184   for (u4 i = 0; i &lt; nof_entries; ++i) {
185     writer.write_key(i);
186     writer.write(GCWhen::to_string((GCWhen::Type)i));
187   }
188 }
189 
<span class="line-removed">190 void G1HeapRegionTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-removed">191   static const u4 nof_entries = G1HeapRegionTraceType::G1HeapRegionTypeEndSentinel;</span>
<span class="line-removed">192   writer.write_count(nof_entries);</span>
<span class="line-removed">193   for (u4 i = 0; i &lt; nof_entries; ++i) {</span>
<span class="line-removed">194     writer.write_key(i);</span>
<span class="line-removed">195     writer.write(G1HeapRegionTraceType::to_string((G1HeapRegionTraceType::Type)i));</span>
<span class="line-removed">196   }</span>
<span class="line-removed">197 }</span>
<span class="line-removed">198 </span>
199 void GCThresholdUpdaterConstant::serialize(JfrCheckpointWriter&amp; writer) {
200   static const u4 nof_entries = MetaspaceGCThresholdUpdater::Last;
201   writer.write_count(nof_entries);
202   for (u4 i = 0; i &lt; nof_entries; ++i) {
203     writer.write_key(i);
204     writer.write(MetaspaceGCThresholdUpdater::to_string((MetaspaceGCThresholdUpdater::Type)i));
205   }
206 }
207 
208 void MetadataTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
209   static const u4 nof_entries = Metaspace::MetadataTypeCount;
210   writer.write_count(nof_entries);
211   for (u4 i = 0; i &lt; nof_entries; ++i) {
212     writer.write_key(i);
213     writer.write(Metaspace::metadata_type_name((Metaspace::MetadataType)i));
214   }
215 }
216 
217 void MetaspaceObjectTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
218   static const u4 nof_entries = MetaspaceObj::_number_of_types;
219   writer.write_count(nof_entries);
220   for (u4 i = 0; i &lt; nof_entries; ++i) {
221     writer.write_key(i);
222     writer.write(MetaspaceObj::type_name((MetaspaceObj::Type)i));
223   }
224 }
225 
<span class="line-removed">226 void G1YCTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-removed">227 #if INCLUDE_G1GC</span>
<span class="line-removed">228   static const u4 nof_entries = G1YCTypeEndSentinel;</span>
<span class="line-removed">229   writer.write_count(nof_entries);</span>
<span class="line-removed">230   for (u4 i = 0; i &lt; nof_entries; ++i) {</span>
<span class="line-removed">231     writer.write_key(i);</span>
<span class="line-removed">232     writer.write(G1YCTypeHelper::to_string((G1YCType)i));</span>
<span class="line-removed">233   }</span>
<span class="line-removed">234 #endif</span>
<span class="line-removed">235 }</span>
<span class="line-removed">236 </span>
237 static const char* reference_type_to_string(ReferenceType rt) {
238   switch (rt) {
239     case REF_NONE: return &quot;None reference&quot;;
240     case REF_OTHER: return &quot;Other reference&quot;;
241     case REF_SOFT: return &quot;Soft reference&quot;;
242     case REF_WEAK: return &quot;Weak reference&quot;;
243     case REF_FINAL: return &quot;Final reference&quot;;
244     case REF_PHANTOM: return &quot;Phantom reference&quot;;
245     default:
246       ShouldNotReachHere();
247     return NULL;
248   }
249 }
250 
251 void ReferenceTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
252   static const u4 nof_entries = REF_PHANTOM + 1;
253   writer.write_count(nof_entries);
254   for (u4 i = 0; i &lt; nof_entries; ++i) {
255     writer.write_key(i);
256     writer.write(reference_type_to_string((ReferenceType)i));
257   }
258 }
259 
260 void NarrowOopModeConstant::serialize(JfrCheckpointWriter&amp; writer) {
<span class="line-modified">261   static const u4 nof_entries = Universe::HeapBasedNarrowOop + 1;</span>
262   writer.write_count(nof_entries);
263   for (u4 i = 0; i &lt; nof_entries; ++i) {
264     writer.write_key(i);
<span class="line-modified">265     writer.write(Universe::narrow_oop_mode_to_string((Universe::NARROW_OOP_MODE)i));</span>
266   }
267 }
268 
269 void CompilerPhaseTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
270 #ifdef COMPILER2
271   static const u4 nof_entries = PHASE_NUM_TYPES;
272   writer.write_count(nof_entries);
273   for (u4 i = 0; i &lt; nof_entries; ++i) {
274     writer.write_key(i);
275     writer.write(CompilerPhaseTypeHelper::to_string((CompilerPhaseType)i));
276   }
277 #endif
278 }
279 
280 void CodeBlobTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
281   static const u4 nof_entries = CodeBlobType::NumTypes;
282   writer.write_count(nof_entries);
283   for (u4 i = 0; i &lt; nof_entries; ++i) {
284     writer.write_key(i);
285     writer.write(CodeCache::get_code_heap_name(i));
286   }
287 };
288 
289 void VMOperationTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
290   static const u4 nof_entries = VM_Operation::VMOp_Terminating;
291   writer.write_count(nof_entries);
292   for (u4 i = 0; i &lt; nof_entries; ++i) {
293     writer.write_key(i);
294     writer.write(VM_Operation::name(VM_Operation::VMOp_Type(i)));
295   }
296 }
297 
<span class="line-removed">298 class TypeSetSerialization {</span>
<span class="line-removed">299  private:</span>
<span class="line-removed">300   bool _class_unload;</span>
<span class="line-removed">301  public:</span>
<span class="line-removed">302   explicit TypeSetSerialization(bool class_unload) : _class_unload(class_unload) {}</span>
<span class="line-removed">303   void write(JfrCheckpointWriter&amp; writer, JfrCheckpointWriter* leakp_writer) {</span>
<span class="line-removed">304     JfrTypeSet::serialize(&amp;writer, leakp_writer, _class_unload);</span>
<span class="line-removed">305   }</span>
<span class="line-removed">306 };</span>
<span class="line-removed">307 </span>
<span class="line-removed">308 void ClassUnloadTypeSet::serialize(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-removed">309   TypeSetSerialization type_set(true);</span>
<span class="line-removed">310   if (LeakProfiler::is_running()) {</span>
<span class="line-removed">311     JfrCheckpointWriter leakp_writer(false, true, Thread::current());</span>
<span class="line-removed">312     type_set.write(writer, &amp;leakp_writer);</span>
<span class="line-removed">313     ObjectSampleCheckpoint::install(leakp_writer, true, true);</span>
<span class="line-removed">314     return;</span>
<span class="line-removed">315   }</span>
<span class="line-removed">316   type_set.write(writer, NULL);</span>
<span class="line-removed">317 };</span>
<span class="line-removed">318 </span>
<span class="line-removed">319 void TypeSet::serialize(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-removed">320   TypeSetSerialization type_set(false);</span>
<span class="line-removed">321   if (LeakProfiler::is_suspended()) {</span>
<span class="line-removed">322     JfrCheckpointWriter leakp_writer(false, true, Thread::current());</span>
<span class="line-removed">323     type_set.write(writer, &amp;leakp_writer);</span>
<span class="line-removed">324     ObjectSampleCheckpoint::install(leakp_writer, false, true);</span>
<span class="line-removed">325     return;</span>
<span class="line-removed">326   }</span>
<span class="line-removed">327   type_set.write(writer, NULL);</span>
<span class="line-removed">328 };</span>
<span class="line-removed">329 </span>
330 void ThreadStateConstant::serialize(JfrCheckpointWriter&amp; writer) {
331   JfrThreadState::serialize(writer);
332 }
333 
334 void JfrThreadConstant::serialize(JfrCheckpointWriter&amp; writer) {
335   assert(_thread != NULL, &quot;invariant&quot;);
336   assert(_thread == Thread::current(), &quot;invariant&quot;);
<span class="line-removed">337   assert(_thread-&gt;is_Java_thread(), &quot;invariant&quot;);</span>
<span class="line-removed">338   assert(!_thread-&gt;jfr_thread_local()-&gt;has_thread_checkpoint(), &quot;invariant&quot;);</span>
<span class="line-removed">339   ResourceMark rm(_thread);</span>
<span class="line-removed">340   const oop threadObj = _thread-&gt;threadObj();</span>
<span class="line-removed">341   assert(threadObj != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">342   const u8 java_lang_thread_id = java_lang_Thread::thread_id(threadObj);</span>
<span class="line-removed">343   const char* const thread_name = _thread-&gt;name();</span>
<span class="line-removed">344   const traceid thread_group_id = JfrThreadGroup::thread_group_id(_thread);</span>
345   writer.write_count(1);
<span class="line-modified">346   writer.write_key(_thread-&gt;jfr_thread_local()-&gt;thread_id());</span>
<span class="line-modified">347   writer.write(thread_name);</span>
<span class="line-modified">348   writer.write((traceid)_thread-&gt;osthread()-&gt;thread_id());</span>
<span class="line-modified">349   writer.write(thread_name);</span>
<span class="line-modified">350   writer.write(java_lang_thread_id);</span>
<span class="line-modified">351   writer.write(thread_group_id);</span>
<span class="line-modified">352   JfrThreadGroup::serialize(&amp;writer, thread_group_id);</span>



























353 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/javaClasses.inline.hpp&quot;
 27 #include &quot;code/codeBlob.hpp&quot;
 28 #include &quot;code/codeCache.hpp&quot;
<span class="line-added"> 29 #include &quot;compiler/compilerDefinitions.hpp&quot;</span>
 30 #include &quot;gc/shared/gcCause.hpp&quot;
 31 #include &quot;gc/shared/gcName.hpp&quot;
 32 #include &quot;gc/shared/gcTrace.hpp&quot;
 33 #include &quot;gc/shared/gcWhen.hpp&quot;

 34 #include &quot;jfr/leakprofiler/leakProfiler.hpp&quot;
<span class="line-modified"> 35 #include &quot;jfr/recorder/checkpoint/jfrCheckpointWriter.hpp&quot;</span>
 36 #include &quot;jfr/recorder/checkpoint/types/jfrType.hpp&quot;
 37 #include &quot;jfr/recorder/jfrRecorder.hpp&quot;
 38 #include &quot;jfr/recorder/checkpoint/types/jfrThreadGroup.hpp&quot;
 39 #include &quot;jfr/recorder/checkpoint/types/jfrThreadState.hpp&quot;

 40 #include &quot;jfr/support/jfrThreadLocal.hpp&quot;
 41 #include &quot;jfr/writers/jfrJavaEventWriter.hpp&quot;
<span class="line-added"> 42 #include &quot;jfr/utilities/jfrThreadIterator.hpp&quot;</span>
<span class="line-added"> 43 #include &quot;memory/iterator.hpp&quot;</span>
 44 #include &quot;memory/metaspaceGCThresholdUpdater.hpp&quot;
 45 #include &quot;memory/referenceType.hpp&quot;
 46 #include &quot;memory/universe.hpp&quot;
<span class="line-added"> 47 #include &quot;oops/compressedOops.hpp&quot;</span>
 48 #include &quot;runtime/flags/jvmFlag.hpp&quot;
 49 #include &quot;runtime/mutexLocker.hpp&quot;
 50 #include &quot;runtime/osThread.hpp&quot;
 51 #include &quot;runtime/safepoint.hpp&quot;
 52 #include &quot;runtime/synchronizer.hpp&quot;
 53 #include &quot;runtime/thread.inline.hpp&quot;
 54 #include &quot;runtime/vmOperations.hpp&quot;
 55 
 56 #ifdef COMPILER2
 57 #include &quot;opto/compile.hpp&quot;
 58 #include &quot;opto/node.hpp&quot;
 59 #endif




 60 
 61 // Requires a ResourceMark for get_thread_name/as_utf8
 62 class JfrCheckpointThreadClosure : public ThreadClosure {
 63  private:
 64   JfrCheckpointWriter&amp; _writer;
 65   JfrCheckpointContext _ctx;
 66   const int64_t _count_position;
 67   Thread* const _curthread;
 68   u4 _count;
 69 
 70  public:
 71   JfrCheckpointThreadClosure(JfrCheckpointWriter&amp; writer) : _writer(writer),
 72                                                             _ctx(writer.context()),
 73                                                             _count_position(writer.reserve(sizeof(u4))),
 74                                                             _curthread(Thread::current()),
 75                                                             _count(0) {
 76   }
 77 
 78   ~JfrCheckpointThreadClosure() {
 79     if (_count == 0) {
 80       // restore
 81       _writer.set_context(_ctx);
 82       return;
 83     }
 84     _writer.write_count(_count, _count_position);
 85   }
 86 
 87   void do_thread(Thread* t);
 88 };
 89 

 90 void JfrCheckpointThreadClosure::do_thread(Thread* t) {
 91   assert(t != NULL, &quot;invariant&quot;);






 92   ++_count;
<span class="line-modified"> 93   _writer.write_key(JfrThreadId::jfr_id(t));</span>
<span class="line-modified"> 94   const char* const name = JfrThreadName::name(t);</span>
<span class="line-modified"> 95   assert(name != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 96   _writer.write(name);</span>
<span class="line-added"> 97   _writer.write&lt;traceid&gt;(JfrThreadId::os_id(t));</span>
 98   if (t-&gt;is_Java_thread()) {
<span class="line-modified"> 99     _writer.write(name);</span>
<span class="line-modified">100     _writer.write(JfrThreadId::id(t));</span>
<span class="line-modified">101     _writer.write(JfrThreadGroup::thread_group_id((JavaThread*)t, _curthread));</span>



102     return;
103   }
104   _writer.write((const char*)NULL); // java name
105   _writer.write((traceid)0); // java thread id
106   _writer.write((traceid)0); // java thread group
107 }
108 
109 void JfrThreadConstantSet::serialize(JfrCheckpointWriter&amp; writer) {

110   JfrCheckpointThreadClosure tc(writer);
<span class="line-modified">111   JfrJavaThreadIterator javathreads;</span>
<span class="line-added">112   while (javathreads.has_next()) {</span>
<span class="line-added">113     tc.do_thread(javathreads.next());</span>
<span class="line-added">114   }</span>
<span class="line-added">115   JfrNonJavaThreadIterator nonjavathreads;</span>
<span class="line-added">116   while (nonjavathreads.has_next()) {</span>
<span class="line-added">117     tc.do_thread(nonjavathreads.next());</span>
<span class="line-added">118   }</span>
119 }
120 
121 void JfrThreadGroupConstant::serialize(JfrCheckpointWriter&amp; writer) {

122   JfrThreadGroup::serialize(writer);
123 }
124 
125 static const char* flag_value_origin_to_string(JVMFlag::Flags origin) {
126   switch (origin) {
127     case JVMFlag::DEFAULT: return &quot;Default&quot;;
128     case JVMFlag::COMMAND_LINE: return &quot;Command line&quot;;
129     case JVMFlag::ENVIRON_VAR: return &quot;Environment variable&quot;;
130     case JVMFlag::CONFIG_FILE: return &quot;Config file&quot;;
131     case JVMFlag::MANAGEMENT: return &quot;Management&quot;;
132     case JVMFlag::ERGONOMIC: return &quot;Ergonomic&quot;;
133     case JVMFlag::ATTACH_ON_DEMAND: return &quot;Attach on demand&quot;;
134     case JVMFlag::INTERNAL: return &quot;Internal&quot;;
<span class="line-added">135     case JVMFlag::JIMAGE_RESOURCE: return &quot;JImage resource&quot;;</span>
136     default: ShouldNotReachHere(); return &quot;&quot;;
137   }
138 }
139 
140 void FlagValueOriginConstant::serialize(JfrCheckpointWriter&amp; writer) {
141   static const u4 nof_entries = JVMFlag::LAST_VALUE_ORIGIN + 1;
142   writer.write_count(nof_entries);
143   for (u4 i = 0; i &lt; nof_entries; ++i) {
144     writer.write_key(i);
145     writer.write(flag_value_origin_to_string((JVMFlag::Flags)i));
146   }
147 }
148 
149 void MonitorInflateCauseConstant::serialize(JfrCheckpointWriter&amp; writer) {
150   static const u4 nof_entries = ObjectSynchronizer::inflate_cause_nof;
151   writer.write_count(nof_entries);
152   for (u4 i = 0; i &lt; nof_entries; ++i) {
153     writer.write_key(i);
154     writer.write(ObjectSynchronizer::inflate_cause_name((ObjectSynchronizer::InflateCause)i));
155   }
</pre>
<hr />
<pre>
165 }
166 
167 void GCNameConstant::serialize(JfrCheckpointWriter&amp; writer) {
168   static const u4 nof_entries = GCNameEndSentinel;
169   writer.write_count(nof_entries);
170   for (u4 i = 0; i &lt; nof_entries; ++i) {
171     writer.write_key(i);
172     writer.write(GCNameHelper::to_string((GCName)i));
173   }
174 }
175 
176 void GCWhenConstant::serialize(JfrCheckpointWriter&amp; writer) {
177   static const u4 nof_entries = GCWhen::GCWhenEndSentinel;
178   writer.write_count(nof_entries);
179   for (u4 i = 0; i &lt; nof_entries; ++i) {
180     writer.write_key(i);
181     writer.write(GCWhen::to_string((GCWhen::Type)i));
182   }
183 }
184 









185 void GCThresholdUpdaterConstant::serialize(JfrCheckpointWriter&amp; writer) {
186   static const u4 nof_entries = MetaspaceGCThresholdUpdater::Last;
187   writer.write_count(nof_entries);
188   for (u4 i = 0; i &lt; nof_entries; ++i) {
189     writer.write_key(i);
190     writer.write(MetaspaceGCThresholdUpdater::to_string((MetaspaceGCThresholdUpdater::Type)i));
191   }
192 }
193 
194 void MetadataTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
195   static const u4 nof_entries = Metaspace::MetadataTypeCount;
196   writer.write_count(nof_entries);
197   for (u4 i = 0; i &lt; nof_entries; ++i) {
198     writer.write_key(i);
199     writer.write(Metaspace::metadata_type_name((Metaspace::MetadataType)i));
200   }
201 }
202 
203 void MetaspaceObjectTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
204   static const u4 nof_entries = MetaspaceObj::_number_of_types;
205   writer.write_count(nof_entries);
206   for (u4 i = 0; i &lt; nof_entries; ++i) {
207     writer.write_key(i);
208     writer.write(MetaspaceObj::type_name((MetaspaceObj::Type)i));
209   }
210 }
211 











212 static const char* reference_type_to_string(ReferenceType rt) {
213   switch (rt) {
214     case REF_NONE: return &quot;None reference&quot;;
215     case REF_OTHER: return &quot;Other reference&quot;;
216     case REF_SOFT: return &quot;Soft reference&quot;;
217     case REF_WEAK: return &quot;Weak reference&quot;;
218     case REF_FINAL: return &quot;Final reference&quot;;
219     case REF_PHANTOM: return &quot;Phantom reference&quot;;
220     default:
221       ShouldNotReachHere();
222     return NULL;
223   }
224 }
225 
226 void ReferenceTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
227   static const u4 nof_entries = REF_PHANTOM + 1;
228   writer.write_count(nof_entries);
229   for (u4 i = 0; i &lt; nof_entries; ++i) {
230     writer.write_key(i);
231     writer.write(reference_type_to_string((ReferenceType)i));
232   }
233 }
234 
235 void NarrowOopModeConstant::serialize(JfrCheckpointWriter&amp; writer) {
<span class="line-modified">236   static const u4 nof_entries = CompressedOops::HeapBasedNarrowOop + 1;</span>
237   writer.write_count(nof_entries);
238   for (u4 i = 0; i &lt; nof_entries; ++i) {
239     writer.write_key(i);
<span class="line-modified">240     writer.write(CompressedOops::mode_to_string((CompressedOops::Mode)i));</span>
241   }
242 }
243 
244 void CompilerPhaseTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
245 #ifdef COMPILER2
246   static const u4 nof_entries = PHASE_NUM_TYPES;
247   writer.write_count(nof_entries);
248   for (u4 i = 0; i &lt; nof_entries; ++i) {
249     writer.write_key(i);
250     writer.write(CompilerPhaseTypeHelper::to_string((CompilerPhaseType)i));
251   }
252 #endif
253 }
254 
255 void CodeBlobTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
256   static const u4 nof_entries = CodeBlobType::NumTypes;
257   writer.write_count(nof_entries);
258   for (u4 i = 0; i &lt; nof_entries; ++i) {
259     writer.write_key(i);
260     writer.write(CodeCache::get_code_heap_name(i));
261   }
262 };
263 
264 void VMOperationTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
265   static const u4 nof_entries = VM_Operation::VMOp_Terminating;
266   writer.write_count(nof_entries);
267   for (u4 i = 0; i &lt; nof_entries; ++i) {
268     writer.write_key(i);
269     writer.write(VM_Operation::name(VM_Operation::VMOp_Type(i)));
270   }
271 }
272 
































273 void ThreadStateConstant::serialize(JfrCheckpointWriter&amp; writer) {
274   JfrThreadState::serialize(writer);
275 }
276 
277 void JfrThreadConstant::serialize(JfrCheckpointWriter&amp; writer) {
278   assert(_thread != NULL, &quot;invariant&quot;);
279   assert(_thread == Thread::current(), &quot;invariant&quot;);








280   writer.write_count(1);
<span class="line-modified">281   writer.write_key(JfrThreadId::jfr_id(_thread));</span>
<span class="line-modified">282   const char* const name = JfrThreadName::name(_thread);</span>
<span class="line-modified">283   writer.write(name);</span>
<span class="line-modified">284   writer.write(JfrThreadId::os_id(_thread));</span>
<span class="line-modified">285   if (_thread-&gt;is_Java_thread()) {</span>
<span class="line-modified">286     writer.write(name);</span>
<span class="line-modified">287     writer.write(JfrThreadId::id(_thread));</span>
<span class="line-added">288     JavaThread* const jt = (JavaThread*)_thread;</span>
<span class="line-added">289     const traceid thread_group_id = JfrThreadGroup::thread_group_id(jt, jt);</span>
<span class="line-added">290     writer.write(thread_group_id);</span>
<span class="line-added">291     JfrThreadGroup::serialize(&amp;writer, thread_group_id);</span>
<span class="line-added">292     return;</span>
<span class="line-added">293   }</span>
<span class="line-added">294   writer.write((const char*)NULL); // java name</span>
<span class="line-added">295   writer.write((traceid)0); // java thread id</span>
<span class="line-added">296   writer.write((traceid)0); // java thread group</span>
<span class="line-added">297 }</span>
<span class="line-added">298 </span>
<span class="line-added">299 void BytecodeConstant::serialize(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-added">300   static const u4 nof_entries = Bytecodes::number_of_codes;</span>
<span class="line-added">301   writer.write_count(nof_entries);</span>
<span class="line-added">302   for (u4 i = 0; i &lt; nof_entries; ++i) {</span>
<span class="line-added">303     writer.write_key(i);</span>
<span class="line-added">304     writer.write(Bytecodes::name((Bytecodes::Code)i));</span>
<span class="line-added">305   }</span>
<span class="line-added">306 }</span>
<span class="line-added">307 </span>
<span class="line-added">308 void CompilerTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-added">309   static const u4 nof_entries = compiler_number_of_types;</span>
<span class="line-added">310   writer.write_count(nof_entries);</span>
<span class="line-added">311   for (u4 i = 0; i &lt; nof_entries; ++i) {</span>
<span class="line-added">312     writer.write_key(i);</span>
<span class="line-added">313     writer.write(compilertype2name((CompilerType)i));</span>
<span class="line-added">314   }</span>
315 }
</pre>
</td>
</tr>
</table>
<center><a href="jfrThreadState.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="jfrType.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
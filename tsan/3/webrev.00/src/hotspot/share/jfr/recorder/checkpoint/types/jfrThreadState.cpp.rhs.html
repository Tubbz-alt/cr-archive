<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jfr/recorder/checkpoint/types/jfrThreadState.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2 * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4 *
  5 * This code is free software; you can redistribute it and/or modify it
  6 * under the terms of the GNU General Public License version 2 only, as
  7 * published by the Free Software Foundation.
  8 *
  9 * This code is distributed in the hope that it will be useful, but WITHOUT
 10 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12 * version 2 for more details (a copy is included in the LICENSE file that
 13 * accompanied this code).
 14 *
 15 * You should have received a copy of the GNU General Public License version
 16 * 2 along with this work; if not, write to the Free Software Foundation,
 17 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18 *
 19 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20 * or visit www.oracle.com if you need additional information or have any
 21 * questions.
 22 *
 23 */
 24 
 25 #include &quot;precompiled.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added"> 26 #include &quot;classfile/javaClasses.inline.hpp&quot;</span>
 27 #include &quot;jfr/recorder/checkpoint/types/jfrThreadState.hpp&quot;
 28 #include &quot;jfr/recorder/checkpoint/jfrCheckpointWriter.hpp&quot;
<a name="3" id="anc3"></a><span class="line-added"> 29 #include &quot;jfr/support/jfrThreadLocal.hpp&quot;</span>
 30 #include &quot;jvmtifiles/jvmti.h&quot;
<a name="4" id="anc4"></a><span class="line-added"> 31 #include &quot;runtime/osThread.hpp&quot;</span>
<span class="line-added"> 32 #include &quot;runtime/thread.hpp&quot;</span>
 33 
 34 struct jvmti_thread_state {
 35   u8 id;
 36   const char* description;
 37 };
 38 
 39 static jvmti_thread_state states[] = {
 40   {
 41     JVMTI_JAVA_LANG_THREAD_STATE_NEW,
 42     &quot;STATE_NEW&quot;
 43   },
 44   {
 45     JVMTI_THREAD_STATE_TERMINATED,
 46     &quot;STATE_TERMINATED&quot;
 47   },
 48   {
 49     JVMTI_JAVA_LANG_THREAD_STATE_RUNNABLE,
 50     &quot;STATE_RUNNABLE&quot;
 51   },
 52   {
 53     (JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT | JVMTI_THREAD_STATE_SLEEPING),
 54     &quot;STATE_SLEEPING&quot;
 55   },
 56   {
 57     (JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_INDEFINITELY | JVMTI_THREAD_STATE_IN_OBJECT_WAIT),
 58     &quot;STATE_IN_OBJECT_WAIT&quot;
 59   },
 60   {
 61     (JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT | JVMTI_THREAD_STATE_IN_OBJECT_WAIT),
 62     &quot;STATE_IN_OBJECT_WAIT_TIMED&quot;
 63   },
 64   {
 65     (JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_INDEFINITELY | JVMTI_THREAD_STATE_PARKED),
 66     &quot;STATE_PARKED&quot;
 67   },
 68   {
 69     (JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT | JVMTI_THREAD_STATE_PARKED),
 70     &quot;STATE_PARKED_TIMED&quot;
 71   },
 72   {
 73     JVMTI_JAVA_LANG_THREAD_STATE_BLOCKED,
 74     &quot;STATE_BLOCKED_ON_MONITOR_ENTER&quot;
 75   }
 76 };
 77 
 78 void JfrThreadState::serialize(JfrCheckpointWriter&amp; writer) {
 79   const u4 number_of_states = sizeof(states) / sizeof(jvmti_thread_state);
 80   writer.write_count(number_of_states);
 81   for (u4 i = 0; i &lt; number_of_states; ++i) {
 82     writer.write_key(states[i].id);
 83     writer.write(states[i].description);
 84   }
 85 }
 86 
<a name="5" id="anc5"></a><span class="line-added"> 87 traceid JfrThreadId::id(const Thread* t) {</span>
<span class="line-added"> 88   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 89   if (!t-&gt;is_Java_thread()) {</span>
<span class="line-added"> 90     return os_id(t);</span>
<span class="line-added"> 91   }</span>
<span class="line-added"> 92   const JavaThread* const jt = (JavaThread*)t;</span>
<span class="line-added"> 93   const oop thread_obj = jt-&gt;threadObj();</span>
<span class="line-added"> 94   return thread_obj != NULL ? java_lang_Thread::thread_id(thread_obj) : 0;</span>
<span class="line-added"> 95 }</span>
<span class="line-added"> 96 </span>
<span class="line-added"> 97 traceid JfrThreadId::os_id(const Thread* t) {</span>
<span class="line-added"> 98   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 99   const OSThread* const os_thread = t-&gt;osthread();</span>
<span class="line-added">100   return os_thread != NULL ? os_thread-&gt;thread_id() : 0;</span>
<span class="line-added">101 }</span>
<span class="line-added">102 </span>
<span class="line-added">103 traceid JfrThreadId::jfr_id(const Thread* t) {</span>
<span class="line-added">104   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="line-added">105   return t-&gt;jfr_thread_local()-&gt;thread_id();</span>
<span class="line-added">106 }</span>
<span class="line-added">107 </span>
<span class="line-added">108 // caller needs ResourceMark</span>
<span class="line-added">109 const char* get_java_thread_name(const Thread* t) {</span>
<span class="line-added">110   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="line-added">111   assert(t-&gt;is_Java_thread(), &quot;invariant&quot;);</span>
<span class="line-added">112   const JavaThread* const jt = ((JavaThread*)t);</span>
<span class="line-added">113   const char* name_str = &quot;&lt;no-name - thread name unresolved&gt;&quot;;</span>
<span class="line-added">114   const oop thread_obj = jt-&gt;threadObj();</span>
<span class="line-added">115   if (thread_obj != NULL) {</span>
<span class="line-added">116     const oop name = java_lang_Thread::name(thread_obj);</span>
<span class="line-added">117     if (name != NULL) {</span>
<span class="line-added">118       name_str = java_lang_String::as_utf8_string(name);</span>
<span class="line-added">119     }</span>
<span class="line-added">120   } else if (jt-&gt;is_attaching_via_jni()) {</span>
<span class="line-added">121     name_str = &quot;&lt;no-name - thread is attaching&gt;&quot;;</span>
<span class="line-added">122   }</span>
<span class="line-added">123   assert(name_str != NULL, &quot;unexpected NULL thread name&quot;);</span>
<span class="line-added">124   return name_str;</span>
<span class="line-added">125 }</span>
<span class="line-added">126 </span>
<span class="line-added">127 const char* JfrThreadName::name(const Thread* t) {</span>
<span class="line-added">128   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="line-added">129   return t-&gt;is_Java_thread() ? get_java_thread_name(t) : t-&gt;name();</span>
<span class="line-added">130 }</span>
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/jfr/recorder/storage/jfrStorageUtils.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="jfrStorageUtils.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrVirtualMemory.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/storage/jfrStorageUtils.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,75 ***</span>
  
  #ifndef SHARE_JFR_RECORDER_STORAGE_JFRSTORAGEUTILS_INLINE_HPP
  #define SHARE_JFR_RECORDER_STORAGE_JFRSTORAGEUTILS_INLINE_HPP
  
  #include &quot;jfr/recorder/storage/jfrStorageUtils.hpp&quot;
  
  template &lt;typename T&gt;
  inline bool UnBufferedWriteToChunk&lt;T&gt;::write(T* t, const u1* data, size_t size) {
    _writer.write_unbuffered(data, size);
<span class="line-modified">!   _processed += size;</span>
    return true;
  }
  
  template &lt;typename T&gt;
  inline bool DefaultDiscarder&lt;T&gt;::discard(T* t, const u1* data, size_t size) {
<span class="line-modified">!   _processed += size;</span>
    return true;
  }
  
  template &lt;typename Operation&gt;
  inline bool ConcurrentWriteOp&lt;Operation&gt;::process(typename Operation::Type* t) {
<span class="line-modified">!   const u1* const current_top = t-&gt;concurrent_top();</span>
<span class="line-modified">!   const size_t unflushed_size = t-&gt;pos() - current_top;</span>
    if (unflushed_size == 0) {
<span class="line-modified">!     t-&gt;set_concurrent_top(current_top);</span>
      return true;
    }
<span class="line-modified">!   const bool result = _operation.write(t, current_top, unflushed_size);</span>
<span class="line-modified">!   t-&gt;set_concurrent_top(current_top + unflushed_size);</span>
    return result;
  }
  
<span class="line-removed">- template &lt;typename Operation&gt;</span>
<span class="line-removed">- inline bool ConcurrentWriteOpExcludeRetired&lt;Operation&gt;::process(typename Operation::Type* t) {</span>
<span class="line-removed">-   if (t-&gt;retired()) {</span>
<span class="line-removed">-     assert(t-&gt;empty(), &quot;invariant&quot;);</span>
<span class="line-removed">-     return true;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return ConcurrentWriteOp&lt;Operation&gt;::process(t);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  template &lt;typename Operation&gt;
  inline bool MutexedWriteOp&lt;Operation&gt;::process(typename Operation::Type* t) {
    assert(t != NULL, &quot;invariant&quot;);
<span class="line-modified">!   const u1* const current_top = t-&gt;top();</span>
<span class="line-modified">!   const size_t unflushed_size = t-&gt;pos() - current_top;</span>
    if (unflushed_size == 0) {
      return true;
    }
<span class="line-modified">!   const bool result = _operation.write(t, current_top, unflushed_size);</span>
<span class="line-modified">!   t-&gt;set_top(current_top + unflushed_size);</span>
    return result;
  }
  
  template &lt;typename Operation&gt;
  inline bool DiscardOp&lt;Operation&gt;::process(typename Operation::Type* t) {
    assert(t != NULL, &quot;invariant&quot;);
<span class="line-modified">!   const u1* const current_top = _mode == concurrent ? t-&gt;concurrent_top() : t-&gt;top();</span>
<span class="line-modified">!   const size_t unflushed_size = t-&gt;pos() - current_top;</span>
    if (unflushed_size == 0) {
      if (_mode == concurrent) {
<span class="line-modified">!       t-&gt;set_concurrent_top(current_top);</span>
      }
      return true;
    }
<span class="line-modified">!   const bool result = _operation.discard(t, current_top, unflushed_size);</span>
    if (_mode == concurrent) {
<span class="line-modified">!     t-&gt;set_concurrent_top(current_top + unflushed_size);</span>
    } else {
<span class="line-modified">!     t-&gt;set_top(current_top + unflushed_size);</span>
    }
    return result;
  }
  
  #endif // SHARE_JFR_RECORDER_STORAGE_JFRSTORAGEUTILS_INLINE_HPP
<span class="line-new-header">--- 24,99 ---</span>
  
  #ifndef SHARE_JFR_RECORDER_STORAGE_JFRSTORAGEUTILS_INLINE_HPP
  #define SHARE_JFR_RECORDER_STORAGE_JFRSTORAGEUTILS_INLINE_HPP
  
  #include &quot;jfr/recorder/storage/jfrStorageUtils.hpp&quot;
<span class="line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-added">+ #include &quot;runtime/thread.inline.hpp&quot;</span>
  
  template &lt;typename T&gt;
  inline bool UnBufferedWriteToChunk&lt;T&gt;::write(T* t, const u1* data, size_t size) {
    _writer.write_unbuffered(data, size);
<span class="line-modified">!   ++_elements;</span>
<span class="line-added">+   _size += size;</span>
    return true;
  }
  
  template &lt;typename T&gt;
  inline bool DefaultDiscarder&lt;T&gt;::discard(T* t, const u1* data, size_t size) {
<span class="line-modified">!   ++_elements;</span>
<span class="line-added">+   _size += size;</span>
    return true;
  }
  
<span class="line-added">+ template &lt;typename Type&gt;</span>
<span class="line-added">+ inline size_t get_unflushed_size(const u1* top, Type* t) {</span>
<span class="line-added">+   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   return Atomic::load_acquire(t-&gt;pos_address()) - top;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  template &lt;typename Operation&gt;
  inline bool ConcurrentWriteOp&lt;Operation&gt;::process(typename Operation::Type* t) {
<span class="line-modified">!   // acquire_critical_section_top() must be read before pos() for stable access</span>
<span class="line-modified">!   const u1* const top = t-&gt;acquire_critical_section_top();</span>
<span class="line-added">+   const size_t unflushed_size = get_unflushed_size(top, t);</span>
    if (unflushed_size == 0) {
<span class="line-modified">!     t-&gt;release_critical_section_top(top);</span>
      return true;
    }
<span class="line-modified">!   const bool result = _operation.write(t, top, unflushed_size);</span>
<span class="line-modified">!   t-&gt;release_critical_section_top(top + unflushed_size);</span>
    return result;
  }
  
  template &lt;typename Operation&gt;
  inline bool MutexedWriteOp&lt;Operation&gt;::process(typename Operation::Type* t) {
    assert(t != NULL, &quot;invariant&quot;);
<span class="line-modified">!   const u1* const top = t-&gt;top();</span>
<span class="line-modified">!   const size_t unflushed_size = get_unflushed_size(top, t);</span>
    if (unflushed_size == 0) {
      return true;
    }
<span class="line-modified">!   const bool result = _operation.write(t, top, unflushed_size);</span>
<span class="line-modified">!   t-&gt;set_top(top + unflushed_size);</span>
    return result;
  }
  
<span class="line-added">+ template &lt;typename Type&gt;</span>
<span class="line-added">+ static void retired_sensitive_acquire(Type* t) {</span>
<span class="line-added">+   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   if (t-&gt;retired()) {</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   Thread* const thread = Thread::current();</span>
<span class="line-added">+   while (!t-&gt;try_acquire(thread)) {</span>
<span class="line-added">+     if (t-&gt;retired()) {</span>
<span class="line-added">+       return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename Operation&gt;</span>
<span class="line-added">+ inline bool ExclusiveOp&lt;Operation&gt;::process(typename Operation::Type* t) {</span>
<span class="line-added">+   retired_sensitive_acquire(t);</span>
<span class="line-added">+   assert(t-&gt;acquired_by_self() || t-&gt;retired(), &quot;invariant&quot;);</span>
<span class="line-added">+   // User is required to ensure proper release of the acquisition</span>
<span class="line-added">+   return MutexedWriteOp&lt;Operation&gt;::process(t);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  template &lt;typename Operation&gt;
  inline bool DiscardOp&lt;Operation&gt;::process(typename Operation::Type* t) {
    assert(t != NULL, &quot;invariant&quot;);
<span class="line-modified">!   const u1* const top = _mode == concurrent ? t-&gt;acquire_critical_section_top() : t-&gt;top();</span>
<span class="line-modified">!   const size_t unflushed_size = get_unflushed_size(top, t);</span>
    if (unflushed_size == 0) {
      if (_mode == concurrent) {
<span class="line-modified">!       t-&gt;release_critical_section_top(top);</span>
      }
      return true;
    }
<span class="line-modified">!   const bool result = _operation.discard(t, top, unflushed_size);</span>
    if (_mode == concurrent) {
<span class="line-modified">!     t-&gt;release_critical_section_top(top + unflushed_size);</span>
    } else {
<span class="line-modified">!     t-&gt;set_top(top + unflushed_size);</span>
    }
    return result;
  }
  
  #endif // SHARE_JFR_RECORDER_STORAGE_JFRSTORAGEUTILS_INLINE_HPP
</pre>
<center><a href="jfrStorageUtils.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrVirtualMemory.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
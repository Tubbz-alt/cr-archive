<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jfr/recorder/checkpoint/types/jfrType.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/javaClasses.inline.hpp&quot;
 27 #include &quot;code/codeBlob.hpp&quot;
 28 #include &quot;code/codeCache.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added"> 29 #include &quot;compiler/compilerDefinitions.hpp&quot;</span>
 30 #include &quot;gc/shared/gcCause.hpp&quot;
 31 #include &quot;gc/shared/gcName.hpp&quot;
 32 #include &quot;gc/shared/gcTrace.hpp&quot;
 33 #include &quot;gc/shared/gcWhen.hpp&quot;
<a name="3" id="anc3"></a>
 34 #include &quot;jfr/leakprofiler/leakProfiler.hpp&quot;
<a name="4" id="anc4"></a><span class="line-modified"> 35 #include &quot;jfr/recorder/checkpoint/jfrCheckpointWriter.hpp&quot;</span>
 36 #include &quot;jfr/recorder/checkpoint/types/jfrType.hpp&quot;
 37 #include &quot;jfr/recorder/jfrRecorder.hpp&quot;
 38 #include &quot;jfr/recorder/checkpoint/types/jfrThreadGroup.hpp&quot;
 39 #include &quot;jfr/recorder/checkpoint/types/jfrThreadState.hpp&quot;
<a name="5" id="anc5"></a>
 40 #include &quot;jfr/support/jfrThreadLocal.hpp&quot;
 41 #include &quot;jfr/writers/jfrJavaEventWriter.hpp&quot;
<a name="6" id="anc6"></a><span class="line-added"> 42 #include &quot;jfr/utilities/jfrThreadIterator.hpp&quot;</span>
<span class="line-added"> 43 #include &quot;memory/iterator.hpp&quot;</span>
 44 #include &quot;memory/metaspaceGCThresholdUpdater.hpp&quot;
 45 #include &quot;memory/referenceType.hpp&quot;
 46 #include &quot;memory/universe.hpp&quot;
<a name="7" id="anc7"></a><span class="line-added"> 47 #include &quot;oops/compressedOops.hpp&quot;</span>
 48 #include &quot;runtime/flags/jvmFlag.hpp&quot;
 49 #include &quot;runtime/mutexLocker.hpp&quot;
 50 #include &quot;runtime/osThread.hpp&quot;
 51 #include &quot;runtime/safepoint.hpp&quot;
 52 #include &quot;runtime/synchronizer.hpp&quot;
 53 #include &quot;runtime/thread.inline.hpp&quot;
 54 #include &quot;runtime/vmOperations.hpp&quot;
 55 
 56 #ifdef COMPILER2
 57 #include &quot;opto/compile.hpp&quot;
 58 #include &quot;opto/node.hpp&quot;
 59 #endif
<a name="8" id="anc8"></a>



 60 
 61 // Requires a ResourceMark for get_thread_name/as_utf8
 62 class JfrCheckpointThreadClosure : public ThreadClosure {
 63  private:
 64   JfrCheckpointWriter&amp; _writer;
 65   JfrCheckpointContext _ctx;
 66   const int64_t _count_position;
 67   Thread* const _curthread;
 68   u4 _count;
 69 
 70  public:
 71   JfrCheckpointThreadClosure(JfrCheckpointWriter&amp; writer) : _writer(writer),
 72                                                             _ctx(writer.context()),
 73                                                             _count_position(writer.reserve(sizeof(u4))),
 74                                                             _curthread(Thread::current()),
 75                                                             _count(0) {
 76   }
 77 
 78   ~JfrCheckpointThreadClosure() {
 79     if (_count == 0) {
 80       // restore
 81       _writer.set_context(_ctx);
 82       return;
 83     }
 84     _writer.write_count(_count, _count_position);
 85   }
 86 
 87   void do_thread(Thread* t);
 88 };
 89 
<a name="9" id="anc9"></a>
 90 void JfrCheckpointThreadClosure::do_thread(Thread* t) {
 91   assert(t != NULL, &quot;invariant&quot;);
<a name="10" id="anc10"></a>





 92   ++_count;
<a name="11" id="anc11"></a><span class="line-modified"> 93   _writer.write_key(JfrThreadId::jfr_id(t));</span>
<span class="line-modified"> 94   const char* const name = JfrThreadName::name(t);</span>
<span class="line-modified"> 95   assert(name != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 96   _writer.write(name);</span>
<span class="line-added"> 97   _writer.write&lt;traceid&gt;(JfrThreadId::os_id(t));</span>
 98   if (t-&gt;is_Java_thread()) {
<a name="12" id="anc12"></a><span class="line-modified"> 99     _writer.write(name);</span>
<span class="line-modified">100     _writer.write(JfrThreadId::id(t));</span>
<span class="line-modified">101     _writer.write(JfrThreadGroup::thread_group_id((JavaThread*)t, _curthread));</span>



102     return;
103   }
104   _writer.write((const char*)NULL); // java name
105   _writer.write((traceid)0); // java thread id
106   _writer.write((traceid)0); // java thread group
107 }
108 
109 void JfrThreadConstantSet::serialize(JfrCheckpointWriter&amp; writer) {
<a name="13" id="anc13"></a>
110   JfrCheckpointThreadClosure tc(writer);
<a name="14" id="anc14"></a><span class="line-modified">111   JfrJavaThreadIterator javathreads;</span>
<span class="line-added">112   while (javathreads.has_next()) {</span>
<span class="line-added">113     tc.do_thread(javathreads.next());</span>
<span class="line-added">114   }</span>
<span class="line-added">115   JfrNonJavaThreadIterator nonjavathreads;</span>
<span class="line-added">116   while (nonjavathreads.has_next()) {</span>
<span class="line-added">117     tc.do_thread(nonjavathreads.next());</span>
<span class="line-added">118   }</span>
119 }
120 
121 void JfrThreadGroupConstant::serialize(JfrCheckpointWriter&amp; writer) {
<a name="15" id="anc15"></a>
122   JfrThreadGroup::serialize(writer);
123 }
124 
125 static const char* flag_value_origin_to_string(JVMFlag::Flags origin) {
126   switch (origin) {
127     case JVMFlag::DEFAULT: return &quot;Default&quot;;
128     case JVMFlag::COMMAND_LINE: return &quot;Command line&quot;;
129     case JVMFlag::ENVIRON_VAR: return &quot;Environment variable&quot;;
130     case JVMFlag::CONFIG_FILE: return &quot;Config file&quot;;
131     case JVMFlag::MANAGEMENT: return &quot;Management&quot;;
132     case JVMFlag::ERGONOMIC: return &quot;Ergonomic&quot;;
133     case JVMFlag::ATTACH_ON_DEMAND: return &quot;Attach on demand&quot;;
134     case JVMFlag::INTERNAL: return &quot;Internal&quot;;
<a name="16" id="anc16"></a><span class="line-added">135     case JVMFlag::JIMAGE_RESOURCE: return &quot;JImage resource&quot;;</span>
136     default: ShouldNotReachHere(); return &quot;&quot;;
137   }
138 }
139 
140 void FlagValueOriginConstant::serialize(JfrCheckpointWriter&amp; writer) {
141   static const u4 nof_entries = JVMFlag::LAST_VALUE_ORIGIN + 1;
142   writer.write_count(nof_entries);
143   for (u4 i = 0; i &lt; nof_entries; ++i) {
144     writer.write_key(i);
145     writer.write(flag_value_origin_to_string((JVMFlag::Flags)i));
146   }
147 }
148 
149 void MonitorInflateCauseConstant::serialize(JfrCheckpointWriter&amp; writer) {
150   static const u4 nof_entries = ObjectSynchronizer::inflate_cause_nof;
151   writer.write_count(nof_entries);
152   for (u4 i = 0; i &lt; nof_entries; ++i) {
153     writer.write_key(i);
154     writer.write(ObjectSynchronizer::inflate_cause_name((ObjectSynchronizer::InflateCause)i));
155   }
156 }
157 
158 void GCCauseConstant::serialize(JfrCheckpointWriter&amp; writer) {
159   static const u4 nof_entries = GCCause::_last_gc_cause;
160   writer.write_count(nof_entries);
161   for (u4 i = 0; i &lt; nof_entries; ++i) {
162     writer.write_key(i);
163     writer.write(GCCause::to_string((GCCause::Cause)i));
164   }
165 }
166 
167 void GCNameConstant::serialize(JfrCheckpointWriter&amp; writer) {
168   static const u4 nof_entries = GCNameEndSentinel;
169   writer.write_count(nof_entries);
170   for (u4 i = 0; i &lt; nof_entries; ++i) {
171     writer.write_key(i);
172     writer.write(GCNameHelper::to_string((GCName)i));
173   }
174 }
175 
176 void GCWhenConstant::serialize(JfrCheckpointWriter&amp; writer) {
177   static const u4 nof_entries = GCWhen::GCWhenEndSentinel;
178   writer.write_count(nof_entries);
179   for (u4 i = 0; i &lt; nof_entries; ++i) {
180     writer.write_key(i);
181     writer.write(GCWhen::to_string((GCWhen::Type)i));
182   }
183 }
184 
<a name="17" id="anc17"></a>








185 void GCThresholdUpdaterConstant::serialize(JfrCheckpointWriter&amp; writer) {
186   static const u4 nof_entries = MetaspaceGCThresholdUpdater::Last;
187   writer.write_count(nof_entries);
188   for (u4 i = 0; i &lt; nof_entries; ++i) {
189     writer.write_key(i);
190     writer.write(MetaspaceGCThresholdUpdater::to_string((MetaspaceGCThresholdUpdater::Type)i));
191   }
192 }
193 
194 void MetadataTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
195   static const u4 nof_entries = Metaspace::MetadataTypeCount;
196   writer.write_count(nof_entries);
197   for (u4 i = 0; i &lt; nof_entries; ++i) {
198     writer.write_key(i);
199     writer.write(Metaspace::metadata_type_name((Metaspace::MetadataType)i));
200   }
201 }
202 
203 void MetaspaceObjectTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
204   static const u4 nof_entries = MetaspaceObj::_number_of_types;
205   writer.write_count(nof_entries);
206   for (u4 i = 0; i &lt; nof_entries; ++i) {
207     writer.write_key(i);
208     writer.write(MetaspaceObj::type_name((MetaspaceObj::Type)i));
209   }
210 }
211 
<a name="18" id="anc18"></a>










212 static const char* reference_type_to_string(ReferenceType rt) {
213   switch (rt) {
214     case REF_NONE: return &quot;None reference&quot;;
215     case REF_OTHER: return &quot;Other reference&quot;;
216     case REF_SOFT: return &quot;Soft reference&quot;;
217     case REF_WEAK: return &quot;Weak reference&quot;;
218     case REF_FINAL: return &quot;Final reference&quot;;
219     case REF_PHANTOM: return &quot;Phantom reference&quot;;
220     default:
221       ShouldNotReachHere();
222     return NULL;
223   }
224 }
225 
226 void ReferenceTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
227   static const u4 nof_entries = REF_PHANTOM + 1;
228   writer.write_count(nof_entries);
229   for (u4 i = 0; i &lt; nof_entries; ++i) {
230     writer.write_key(i);
231     writer.write(reference_type_to_string((ReferenceType)i));
232   }
233 }
234 
235 void NarrowOopModeConstant::serialize(JfrCheckpointWriter&amp; writer) {
<a name="19" id="anc19"></a><span class="line-modified">236   static const u4 nof_entries = CompressedOops::HeapBasedNarrowOop + 1;</span>
237   writer.write_count(nof_entries);
238   for (u4 i = 0; i &lt; nof_entries; ++i) {
239     writer.write_key(i);
<a name="20" id="anc20"></a><span class="line-modified">240     writer.write(CompressedOops::mode_to_string((CompressedOops::Mode)i));</span>
241   }
242 }
243 
244 void CompilerPhaseTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
245 #ifdef COMPILER2
246   static const u4 nof_entries = PHASE_NUM_TYPES;
247   writer.write_count(nof_entries);
248   for (u4 i = 0; i &lt; nof_entries; ++i) {
249     writer.write_key(i);
250     writer.write(CompilerPhaseTypeHelper::to_string((CompilerPhaseType)i));
251   }
252 #endif
253 }
254 
255 void CodeBlobTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
256   static const u4 nof_entries = CodeBlobType::NumTypes;
257   writer.write_count(nof_entries);
258   for (u4 i = 0; i &lt; nof_entries; ++i) {
259     writer.write_key(i);
260     writer.write(CodeCache::get_code_heap_name(i));
261   }
262 };
263 
264 void VMOperationTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
265   static const u4 nof_entries = VM_Operation::VMOp_Terminating;
266   writer.write_count(nof_entries);
267   for (u4 i = 0; i &lt; nof_entries; ++i) {
268     writer.write_key(i);
269     writer.write(VM_Operation::name(VM_Operation::VMOp_Type(i)));
270   }
271 }
272 
<a name="21" id="anc21"></a>































273 void ThreadStateConstant::serialize(JfrCheckpointWriter&amp; writer) {
274   JfrThreadState::serialize(writer);
275 }
276 
277 void JfrThreadConstant::serialize(JfrCheckpointWriter&amp; writer) {
278   assert(_thread != NULL, &quot;invariant&quot;);
279   assert(_thread == Thread::current(), &quot;invariant&quot;);
<a name="22" id="anc22"></a>







280   writer.write_count(1);
<a name="23" id="anc23"></a><span class="line-modified">281   writer.write_key(JfrThreadId::jfr_id(_thread));</span>
<span class="line-modified">282   const char* const name = JfrThreadName::name(_thread);</span>
<span class="line-modified">283   writer.write(name);</span>
<span class="line-modified">284   writer.write(JfrThreadId::os_id(_thread));</span>
<span class="line-modified">285   if (_thread-&gt;is_Java_thread()) {</span>
<span class="line-modified">286     writer.write(name);</span>
<span class="line-modified">287     writer.write(JfrThreadId::id(_thread));</span>
<span class="line-added">288     JavaThread* const jt = (JavaThread*)_thread;</span>
<span class="line-added">289     const traceid thread_group_id = JfrThreadGroup::thread_group_id(jt, jt);</span>
<span class="line-added">290     writer.write(thread_group_id);</span>
<span class="line-added">291     JfrThreadGroup::serialize(&amp;writer, thread_group_id);</span>
<span class="line-added">292     return;</span>
<span class="line-added">293   }</span>
<span class="line-added">294   writer.write((const char*)NULL); // java name</span>
<span class="line-added">295   writer.write((traceid)0); // java thread id</span>
<span class="line-added">296   writer.write((traceid)0); // java thread group</span>
<span class="line-added">297 }</span>
<span class="line-added">298 </span>
<span class="line-added">299 void BytecodeConstant::serialize(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-added">300   static const u4 nof_entries = Bytecodes::number_of_codes;</span>
<span class="line-added">301   writer.write_count(nof_entries);</span>
<span class="line-added">302   for (u4 i = 0; i &lt; nof_entries; ++i) {</span>
<span class="line-added">303     writer.write_key(i);</span>
<span class="line-added">304     writer.write(Bytecodes::name((Bytecodes::Code)i));</span>
<span class="line-added">305   }</span>
<span class="line-added">306 }</span>
<span class="line-added">307 </span>
<span class="line-added">308 void CompilerTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-added">309   static const u4 nof_entries = compiler_number_of_types;</span>
<span class="line-added">310   writer.write_count(nof_entries);</span>
<span class="line-added">311   for (u4 i = 0; i &lt; nof_entries; ++i) {</span>
<span class="line-added">312     writer.write_key(i);</span>
<span class="line-added">313     writer.write(compilertype2name((CompilerType)i));</span>
<span class="line-added">314   }</span>
315 }
<a name="24" id="anc24"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="24" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/jfr/recorder/service/jfrRecorderService.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="jfrPostBox.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrRecorderService.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/service/jfrRecorderService.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 21,12 ***</span>
<span class="line-new-header">--- 21,15 ---</span>
   * questions.
   *
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="line-added">+ #include &quot;jfrfiles/jfrEventClasses.hpp&quot;</span>
  #include &quot;jfr/jni/jfrJavaSupport.hpp&quot;
<span class="line-added">+ #include &quot;jfr/leakprofiler/leakProfiler.hpp&quot;</span>
  #include &quot;jfr/leakprofiler/checkpoint/objectSampleCheckpoint.hpp&quot;
<span class="line-added">+ #include &quot;jfr/leakprofiler/sampling/objectSampler.hpp&quot;</span>
  #include &quot;jfr/recorder/jfrRecorder.hpp&quot;
  #include &quot;jfr/recorder/checkpoint/jfrCheckpointManager.hpp&quot;
  #include &quot;jfr/recorder/checkpoint/jfrMetadataEvent.hpp&quot;
  #include &quot;jfr/recorder/repository/jfrChunkRotation.hpp&quot;
  #include &quot;jfr/recorder/repository/jfrChunkWriter.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 44,219 ***</span>
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/mutexLocker.hpp&quot;
<span class="line-removed">- #include &quot;runtime/orderAccess.hpp&quot;</span>
  #include &quot;runtime/os.hpp&quot;
  #include &quot;runtime/safepoint.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;runtime/vmOperations.hpp&quot;
  #include &quot;runtime/vmThread.hpp&quot;
  
<span class="line-modified">! // set data iff *dest == NULL</span>
<span class="line-modified">! static bool try_set(void* const data, void** dest, bool clear) {</span>
<span class="line-removed">-   assert(data != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   const void* const current = OrderAccess::load_acquire(dest);</span>
<span class="line-removed">-   if (current != NULL) {</span>
<span class="line-removed">-     if (current != data) {</span>
<span class="line-removed">-       // already set</span>
<span class="line-removed">-       return false;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     assert(current == data, &quot;invariant&quot;);</span>
<span class="line-removed">-     if (!clear) {</span>
<span class="line-removed">-       // recursion disallowed</span>
<span class="line-removed">-       return false;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return Atomic::cmpxchg(clear ? NULL : data, dest, current) == current;</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! static void* rotation_thread = NULL;</span>
<span class="line-modified">! static const int rotation_try_limit = 1000;</span>
<span class="line-removed">- static const int rotation_retry_sleep_millis = 10;</span>
<span class="line-removed">- </span>
<span class="line-removed">- class RotationLock : public StackObj {</span>
   private:
<span class="line-modified">!   Thread* const _thread;</span>
<span class="line-modified">!   bool _acquired;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   void log(bool recursion) {</span>
<span class="line-modified">!     assert(!_acquired, &quot;invariant&quot;);</span>
<span class="line-modified">!     const char* error_msg = NULL;</span>
<span class="line-modified">!     if (recursion) {</span>
<span class="line-removed">-       error_msg = &quot;Unable to issue rotation due to recursive calls.&quot;;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     else {</span>
<span class="line-removed">-       error_msg = &quot;Unable to issue rotation due to wait timeout.&quot;;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     log_info(jfr)( // For user, should not be &quot;jfr, system&quot;</span>
<span class="line-removed">-       &quot;%s&quot;, error_msg);</span>
    }
   public:
<span class="line-removed">-   RotationLock(Thread* thread) : _thread(thread), _acquired(false) {</span>
<span class="line-removed">-     assert(_thread != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-     if (_thread == rotation_thread) {</span>
<span class="line-removed">-       // recursion not supported</span>
<span class="line-removed">-       log(true);</span>
<span class="line-removed">-       return;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     // limited to not spin indefinitely</span>
<span class="line-modified">!     for (int i = 0; i &lt; rotation_try_limit; ++i) {</span>
<span class="line-modified">!       if (try_set(_thread, &amp;rotation_thread, false)) {</span>
<span class="line-modified">!         _acquired = true;</span>
<span class="line-modified">!         assert(_thread == rotation_thread, &quot;invariant&quot;);</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">!       }</span>
<span class="line-removed">-       if (_thread-&gt;is_Java_thread()) {</span>
<span class="line-removed">-         // in order to allow the system to move to a safepoint</span>
<span class="line-removed">-         MutexLockerEx msg_lock(JfrMsg_lock);</span>
<span class="line-removed">-         JfrMsg_lock-&gt;wait(false, rotation_retry_sleep_millis);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       else {</span>
<span class="line-removed">-         os::naked_short_sleep(rotation_retry_sleep_millis);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     log(false);</span>
    }
  
<span class="line-modified">!   ~RotationLock() {</span>
<span class="line-modified">!     assert(_thread != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!     if (_acquired) {</span>
<span class="line-modified">!       assert(_thread == rotation_thread, &quot;invariant&quot;);</span>
<span class="line-modified">!       while (!try_set(_thread, &amp;rotation_thread, true));</span>
<span class="line-modified">!     }</span>
    }
<span class="line-removed">-   bool not_acquired() const { return !_acquired; }</span>
  };
  
  static int64_t write_checkpoint_event_prologue(JfrChunkWriter&amp; cw, u8 type_id) {
<span class="line-modified">!   const int64_t prev_cp_offset = cw.previous_checkpoint_offset();</span>
<span class="line-modified">!   const int64_t prev_cp_relative_offset = 0 == prev_cp_offset ? 0 : prev_cp_offset - cw.current_offset();</span>
    cw.reserve(sizeof(u4));
    cw.write&lt;u8&gt;(EVENT_CHECKPOINT);
    cw.write(JfrTicks::now());
<span class="line-modified">!   cw.write((int64_t)0);</span>
<span class="line-modified">!   cw.write(prev_cp_relative_offset); // write previous checkpoint offset delta</span>
<span class="line-modified">!   cw.write&lt;bool&gt;(false); // flushpoint</span>
<span class="line-modified">!   cw.write((u4)1); // nof types in this checkpoint</span>
    cw.write(type_id);
<span class="line-modified">!   const int64_t number_of_elements_offset = cw.current_offset();</span>
<span class="line-removed">-   cw.reserve(sizeof(u4));</span>
<span class="line-removed">-   return number_of_elements_offset;</span>
  }
  
<span class="line-modified">! template &lt;typename ContentFunctor&gt;</span>
<span class="line-modified">! class WriteCheckpointEvent : public StackObj {</span>
   private:
<span class="line-modified">!   JfrChunkWriter&amp; _cw;</span>
<span class="line-removed">-   u8 _type_id;</span>
<span class="line-removed">-   ContentFunctor&amp; _content_functor;</span>
   public:
<span class="line-modified">!   WriteCheckpointEvent(JfrChunkWriter&amp; cw, u8 type_id, ContentFunctor&amp; functor) :</span>
<span class="line-modified">!     _cw(cw),</span>
<span class="line-modified">!     _type_id(type_id),</span>
<span class="line-removed">-     _content_functor(functor) {</span>
<span class="line-removed">-     assert(_cw.is_valid(), &quot;invariant&quot;);</span>
<span class="line-removed">-   }</span>
    bool process() {
<span class="line-modified">!     // current_cp_offset is also offset for the event size header field</span>
<span class="line-modified">!     const int64_t current_cp_offset = _cw.current_offset();</span>
<span class="line-removed">-     const int64_t num_elements_offset = write_checkpoint_event_prologue(_cw, _type_id);</span>
<span class="line-removed">-     // invocation</span>
<span class="line-removed">-     _content_functor.process();</span>
<span class="line-removed">-     const u4 number_of_elements = (u4)_content_functor.processed();</span>
<span class="line-removed">-     if (number_of_elements == 0) {</span>
        // nothing to do, rewind writer to start
<span class="line-modified">!       _cw.seek(current_cp_offset);</span>
<span class="line-modified">!       return true;</span>
      }
<span class="line-modified">!     assert(number_of_elements &gt; 0, &quot;invariant&quot;);</span>
<span class="line-modified">!     assert(_cw.current_offset() &gt; num_elements_offset, &quot;invariant&quot;);</span>
<span class="line-modified">!     _cw.write_padded_at_offset&lt;u4&gt;(number_of_elements, num_elements_offset);</span>
<span class="line-modified">!     _cw.write_padded_at_offset&lt;u4&gt;((u4)_cw.current_offset() - current_cp_offset, current_cp_offset);</span>
<span class="line-modified">!     // update writer with last checkpoint position</span>
<span class="line-removed">-     _cw.set_previous_checkpoint_offset(current_cp_offset);</span>
      return true;
    }
  };
  
<span class="line-modified">! template &lt;typename Instance, size_t(Instance::*func)()&gt;</span>
<span class="line-modified">! class ServiceFunctor {</span>
   private:
<span class="line-modified">!   Instance&amp; _instance;</span>
<span class="line-modified">!   size_t _processed;</span>
   public:
<span class="line-modified">!   ServiceFunctor(Instance&amp; instance) : _instance(instance), _processed(0) {}</span>
    bool process() {
<span class="line-modified">!     _processed = (_instance.*func)();</span>
      return true;
    }
<span class="line-modified">!   size_t processed() const { return _processed; }</span>
  };
  
<span class="line-modified">! template &lt;typename Instance, void(Instance::*func)()&gt;</span>
<span class="line-modified">! class JfrVMOperation : public VM_Operation {</span>
<span class="line-modified">!  private:</span>
<span class="line-modified">!   Instance&amp; _instance;</span>
<span class="line-modified">!  public:</span>
<span class="line-modified">!   JfrVMOperation(Instance&amp; instance) : _instance(instance) {}</span>
<span class="line-modified">!   void doit() { (_instance.*func)(); }</span>
<span class="line-modified">!   VMOp_Type type() const { return VMOp_JFRCheckpoint; }</span>
<span class="line-modified">!   Mode evaluation_mode() const { return _safepoint; } // default</span>
<span class="line-modified">! };</span>
  
<span class="line-modified">! class WriteStackTraceRepository : public StackObj {</span>
   private:
<span class="line-removed">-   JfrStackTraceRepository&amp; _repo;</span>
    JfrChunkWriter&amp; _cw;
<span class="line-removed">-   size_t _elements_processed;</span>
<span class="line-removed">-   bool _clear;</span>
<span class="line-removed">- </span>
   public:
<span class="line-modified">!   WriteStackTraceRepository(JfrStackTraceRepository&amp; repo, JfrChunkWriter&amp; cw, bool clear) :</span>
<span class="line-removed">-     _repo(repo), _cw(cw), _elements_processed(0), _clear(clear) {}</span>
    bool process() {
<span class="line-modified">!     _elements_processed = _repo.write(_cw, _clear);</span>
      return true;
    }
<span class="line-modified">!   size_t processed() const { return _elements_processed; }</span>
<span class="line-removed">-   void reset() { _elements_processed = 0; }</span>
  };
  
<span class="line-modified">! static bool recording = false;</span>
  
<span class="line-modified">! static void set_recording_state(bool is_recording) {</span>
<span class="line-modified">!   OrderAccess::storestore();</span>
<span class="line-modified">!   recording = is_recording;</span>
  }
  
<span class="line-modified">! bool JfrRecorderService::is_recording() {</span>
<span class="line-modified">!   return recording;</span>
  }
  
  JfrRecorderService::JfrRecorderService() :
    _checkpoint_manager(JfrCheckpointManager::instance()),
    _chunkwriter(JfrRepository::chunkwriter()),
    _repository(JfrRepository::instance()),
    _stack_trace_repository(JfrStackTraceRepository::instance()),
    _storage(JfrStorage::instance()),
    _string_pool(JfrStringPool::instance()) {}
  
  void JfrRecorderService::start() {
<span class="line-modified">!   RotationLock rl(Thread::current());</span>
<span class="line-removed">-   if (rl.not_acquired()) {</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   log_debug(jfr, system)(&quot;Request to START recording&quot;);</span>
    assert(!is_recording(), &quot;invariant&quot;);
    clear();
<span class="line-removed">-   set_recording_state(true);</span>
<span class="line-removed">-   assert(is_recording(), &quot;invariant&quot;);</span>
    open_new_chunk();
<span class="line-modified">!   log_debug(jfr, system)(&quot;Recording STARTED&quot;);</span>
  }
  
  void JfrRecorderService::clear() {
    ResourceMark rm;
    HandleMark hm;
<span class="line-new-header">--- 47,331 ---</span>
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/mutexLocker.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
  #include &quot;runtime/safepoint.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;runtime/vmOperations.hpp&quot;
  #include &quot;runtime/vmThread.hpp&quot;
  
<span class="line-modified">! // incremented on each flushpoint</span>
<span class="line-modified">! static u8 flushpoint_id = 0;</span>
  
<span class="line-modified">! template &lt;typename Instance, size_t(Instance::*func)()&gt;</span>
<span class="line-modified">! class Content {</span>
   private:
<span class="line-modified">!   Instance&amp; _instance;</span>
<span class="line-modified">!   u4 _elements;</span>
<span class="line-modified">!  public:</span>
<span class="line-modified">!   Content(Instance&amp; instance) : _instance(instance), _elements(0) {}</span>
<span class="line-modified">!   bool process() {</span>
<span class="line-modified">!     _elements = (u4)(_instance.*func)();</span>
<span class="line-modified">!     return true;</span>
    }
<span class="line-added">+   u4 elements() const { return _elements; }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename Content&gt;</span>
<span class="line-added">+ class WriteContent : public StackObj {</span>
<span class="line-added">+  protected:</span>
<span class="line-added">+   const JfrTicks _start_time;</span>
<span class="line-added">+   JfrTicks _end_time;</span>
<span class="line-added">+   JfrChunkWriter&amp; _cw;</span>
<span class="line-added">+   Content&amp; _content;</span>
<span class="line-added">+   const int64_t _start_offset;</span>
   public:
  
<span class="line-modified">!   WriteContent(JfrChunkWriter&amp; cw, Content&amp; content) :</span>
<span class="line-modified">!     _start_time(JfrTicks::now()),</span>
<span class="line-modified">!     _end_time(),</span>
<span class="line-modified">!     _cw(cw),</span>
<span class="line-modified">!     _content(content),</span>
<span class="line-modified">!     _start_offset(_cw.current_offset()) {</span>
<span class="line-modified">!     assert(_cw.is_valid(), &quot;invariant&quot;);</span>
    }
  
<span class="line-modified">!   bool process() {</span>
<span class="line-modified">!     // invocation</span>
<span class="line-modified">!     _content.process();</span>
<span class="line-modified">!     _end_time = JfrTicks::now();</span>
<span class="line-modified">!     return 0 != _content.elements();</span>
<span class="line-modified">!   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   const JfrTicks&amp; start_time() const {</span>
<span class="line-added">+     return _start_time;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   const JfrTicks&amp; end_time() const {</span>
<span class="line-added">+     return _end_time;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   int64_t start_offset() const {</span>
<span class="line-added">+     return _start_offset;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   int64_t end_offset() const {</span>
<span class="line-added">+     return current_offset();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   int64_t current_offset() const {</span>
<span class="line-added">+     return _cw.current_offset();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   u4 elements() const {</span>
<span class="line-added">+     return (u4) _content.elements();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   u4 size() const {</span>
<span class="line-added">+     return (u4)(end_offset() - start_offset());</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void write_elements(int64_t offset) {</span>
<span class="line-added">+     _cw.write_padded_at_offset&lt;u4&gt;(elements(), offset);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void write_size() {</span>
<span class="line-added">+     _cw.write_padded_at_offset&lt;u4&gt;(size(), start_offset());</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void set_last_checkpoint() {</span>
<span class="line-added">+     _cw.set_last_checkpoint_offset(start_offset());</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void rewind() {</span>
<span class="line-added">+     _cw.seek(start_offset());</span>
    }
  };
  
  static int64_t write_checkpoint_event_prologue(JfrChunkWriter&amp; cw, u8 type_id) {
<span class="line-modified">!   const int64_t last_cp_offset = cw.last_checkpoint_offset();</span>
<span class="line-modified">!   const int64_t delta_to_last_checkpoint = 0 == last_cp_offset ? 0 : last_cp_offset - cw.current_offset();</span>
    cw.reserve(sizeof(u4));
    cw.write&lt;u8&gt;(EVENT_CHECKPOINT);
    cw.write(JfrTicks::now());
<span class="line-modified">!   cw.write&lt;u8&gt;(0); // duration</span>
<span class="line-modified">!   cw.write(delta_to_last_checkpoint);</span>
<span class="line-modified">!   cw.write&lt;u4&gt;(GENERIC); // checkpoint type</span>
<span class="line-modified">!   cw.write&lt;u4&gt;(1); // nof types in this checkpoint</span>
    cw.write(type_id);
<span class="line-modified">!   return cw.reserve(sizeof(u4));</span>
  }
  
<span class="line-modified">! template &lt;typename Content&gt;</span>
<span class="line-modified">! class WriteCheckpointEvent : public WriteContent&lt;Content&gt; {</span>
   private:
<span class="line-modified">!   const u8 _type_id;</span>
   public:
<span class="line-modified">!   WriteCheckpointEvent(JfrChunkWriter&amp; cw, Content&amp; content, u8 type_id) :</span>
<span class="line-modified">!     WriteContent&lt;Content&gt;(cw, content), _type_id(type_id) {}</span>
<span class="line-modified">! </span>
    bool process() {
<span class="line-modified">!     const int64_t num_elements_offset = write_checkpoint_event_prologue(this-&gt;_cw, _type_id);</span>
<span class="line-modified">!     if (!WriteContent&lt;Content&gt;::process()) {</span>
        // nothing to do, rewind writer to start
<span class="line-modified">!       this-&gt;rewind();</span>
<span class="line-modified">!       assert(this-&gt;current_offset() == this-&gt;start_offset(), &quot;invariant&quot;);</span>
<span class="line-added">+       return false;</span>
      }
<span class="line-modified">!     assert(this-&gt;elements() &gt; 0, &quot;invariant&quot;);</span>
<span class="line-modified">!     assert(this-&gt;current_offset() &gt; num_elements_offset, &quot;invariant&quot;);</span>
<span class="line-modified">!     this-&gt;write_elements(num_elements_offset);</span>
<span class="line-modified">!     this-&gt;write_size();</span>
<span class="line-modified">!     this-&gt;set_last_checkpoint();</span>
      return true;
    }
  };
  
<span class="line-modified">! template &lt;typename Functor&gt;</span>
<span class="line-modified">! static u4 invoke(Functor&amp; f) {</span>
<span class="line-added">+   f.process();</span>
<span class="line-added">+   return f.elements();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename Functor&gt;</span>
<span class="line-added">+ static u4 invoke_with_flush_event(Functor&amp; f) {</span>
<span class="line-added">+   const u4 elements = invoke(f);</span>
<span class="line-added">+   EventFlush e(UNTIMED);</span>
<span class="line-added">+   e.set_starttime(f.start_time());</span>
<span class="line-added">+   e.set_endtime(f.end_time());</span>
<span class="line-added">+   e.set_flushId(flushpoint_id);</span>
<span class="line-added">+   e.set_elements(f.elements());</span>
<span class="line-added">+   e.set_size(f.size());</span>
<span class="line-added">+   e.commit();</span>
<span class="line-added">+   return elements;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ class StackTraceRepository : public StackObj {</span>
   private:
<span class="line-modified">!   JfrStackTraceRepository&amp; _repo;</span>
<span class="line-modified">!   JfrChunkWriter&amp; _cw;</span>
<span class="line-added">+   size_t _elements;</span>
<span class="line-added">+   bool _clear;</span>
<span class="line-added">+ </span>
   public:
<span class="line-modified">!   StackTraceRepository(JfrStackTraceRepository&amp; repo, JfrChunkWriter&amp; cw, bool clear) :</span>
<span class="line-added">+     _repo(repo), _cw(cw), _elements(0), _clear(clear) {}</span>
    bool process() {
<span class="line-modified">!     _elements = _repo.write(_cw, _clear);</span>
      return true;
    }
<span class="line-modified">!   size_t elements() const { return _elements; }</span>
<span class="line-added">+   void reset() { _elements = 0; }</span>
  };
  
<span class="line-modified">! typedef WriteCheckpointEvent&lt;StackTraceRepository&gt; WriteStackTrace;</span>
<span class="line-modified">! </span>
<span class="line-modified">! static u4 flush_stacktrace(JfrStackTraceRepository&amp; stack_trace_repo, JfrChunkWriter&amp; chunkwriter) {</span>
<span class="line-modified">!   StackTraceRepository str(stack_trace_repo, chunkwriter, false);</span>
<span class="line-modified">!   WriteStackTrace wst(chunkwriter, str, TYPE_STACKTRACE);</span>
<span class="line-modified">!   return invoke(wst);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! static u4 write_stacktrace(JfrStackTraceRepository&amp; stack_trace_repo, JfrChunkWriter&amp; chunkwriter, bool clear) {</span>
<span class="line-modified">!   StackTraceRepository str(stack_trace_repo, chunkwriter, clear);</span>
<span class="line-added">+   WriteStackTrace wst(chunkwriter, str, TYPE_STACKTRACE);</span>
<span class="line-added">+   return invoke(wst);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ typedef Content&lt;JfrStorage, &amp;JfrStorage::write&gt; Storage;</span>
<span class="line-added">+ typedef WriteContent&lt;Storage&gt; WriteStorage;</span>
<span class="line-added">+ </span>
<span class="line-added">+ static size_t flush_storage(JfrStorage&amp; storage, JfrChunkWriter&amp; chunkwriter) {</span>
<span class="line-added">+   assert(chunkwriter.is_valid(), &quot;invariant&quot;);</span>
<span class="line-added">+   Storage fsf(storage);</span>
<span class="line-added">+   WriteStorage fs(chunkwriter, fsf);</span>
<span class="line-added">+   return invoke(fs);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static size_t write_storage(JfrStorage&amp; storage, JfrChunkWriter&amp; chunkwriter) {</span>
<span class="line-added">+   assert(chunkwriter.is_valid(), &quot;invariant&quot;);</span>
<span class="line-added">+   Storage fsf(storage);</span>
<span class="line-added">+   WriteStorage fs(chunkwriter, fsf);</span>
<span class="line-added">+   return invoke(fs);</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! typedef Content&lt;JfrStringPool, &amp;JfrStringPool::write&gt; StringPool;</span>
<span class="line-added">+ typedef Content&lt;JfrStringPool, &amp;JfrStringPool::write_at_safepoint&gt; StringPoolSafepoint;</span>
<span class="line-added">+ typedef WriteCheckpointEvent&lt;StringPool&gt; WriteStringPool;</span>
<span class="line-added">+ typedef WriteCheckpointEvent&lt;StringPoolSafepoint&gt; WriteStringPoolSafepoint;</span>
<span class="line-added">+ </span>
<span class="line-added">+ static u4 flush_stringpool(JfrStringPool&amp; string_pool, JfrChunkWriter&amp; chunkwriter) {</span>
<span class="line-added">+   StringPool sp(string_pool);</span>
<span class="line-added">+   WriteStringPool wsp(chunkwriter, sp, TYPE_STRING);</span>
<span class="line-added">+   return invoke(wsp);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static u4 write_stringpool(JfrStringPool&amp; string_pool, JfrChunkWriter&amp; chunkwriter) {</span>
<span class="line-added">+   StringPool sp(string_pool);</span>
<span class="line-added">+   WriteStringPool wsp(chunkwriter, sp, TYPE_STRING);</span>
<span class="line-added">+   return invoke(wsp);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static u4 write_stringpool_safepoint(JfrStringPool&amp; string_pool, JfrChunkWriter&amp; chunkwriter) {</span>
<span class="line-added">+   StringPoolSafepoint sps(string_pool);</span>
<span class="line-added">+   WriteStringPoolSafepoint wsps(chunkwriter, sps, TYPE_STRING);</span>
<span class="line-added">+   return invoke(wsps);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ typedef Content&lt;JfrCheckpointManager, &amp;JfrCheckpointManager::flush_type_set&gt; FlushTypeSetFunctor;</span>
<span class="line-added">+ typedef WriteContent&lt;FlushTypeSetFunctor&gt; FlushTypeSet;</span>
<span class="line-added">+ </span>
<span class="line-added">+ static u4 flush_typeset(JfrCheckpointManager&amp; checkpoint_manager, JfrChunkWriter&amp; chunkwriter) {</span>
<span class="line-added">+   FlushTypeSetFunctor flush_type_set(checkpoint_manager);</span>
<span class="line-added">+   FlushTypeSet fts(chunkwriter, flush_type_set);</span>
<span class="line-added">+   return invoke(fts);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ class MetadataEvent : public StackObj {</span>
   private:
    JfrChunkWriter&amp; _cw;
   public:
<span class="line-modified">!   MetadataEvent(JfrChunkWriter&amp; cw) : _cw(cw) {}</span>
    bool process() {
<span class="line-modified">!     JfrMetadataEvent::write(_cw);</span>
      return true;
    }
<span class="line-modified">!   size_t elements() const { return 1; }</span>
  };
  
<span class="line-modified">! typedef WriteContent&lt;MetadataEvent&gt; WriteMetadata;</span>
  
<span class="line-modified">! static u4 flush_metadata(JfrChunkWriter&amp; chunkwriter) {</span>
<span class="line-modified">!   assert(chunkwriter.is_valid(), &quot;invariant&quot;);</span>
<span class="line-modified">!   MetadataEvent me(chunkwriter);</span>
<span class="line-added">+   WriteMetadata wm(chunkwriter, me);</span>
<span class="line-added">+   return invoke(wm);</span>
  }
  
<span class="line-modified">! static u4 write_metadata(JfrChunkWriter&amp; chunkwriter) {</span>
<span class="line-modified">!   assert(chunkwriter.is_valid(), &quot;invariant&quot;);</span>
<span class="line-added">+   MetadataEvent me(chunkwriter);</span>
<span class="line-added">+   WriteMetadata wm(chunkwriter, me);</span>
<span class="line-added">+   return invoke(wm);</span>
  }
  
<span class="line-added">+ template &lt;typename Instance, void(Instance::*func)()&gt;</span>
<span class="line-added">+ class JfrVMOperation : public VM_Operation {</span>
<span class="line-added">+  private:</span>
<span class="line-added">+   Instance&amp; _instance;</span>
<span class="line-added">+  public:</span>
<span class="line-added">+   JfrVMOperation(Instance&amp; instance) : _instance(instance) {}</span>
<span class="line-added">+   void doit() { (_instance.*func)(); }</span>
<span class="line-added">+   VMOp_Type type() const { return VMOp_JFRCheckpoint; }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
  JfrRecorderService::JfrRecorderService() :
    _checkpoint_manager(JfrCheckpointManager::instance()),
    _chunkwriter(JfrRepository::chunkwriter()),
    _repository(JfrRepository::instance()),
    _stack_trace_repository(JfrStackTraceRepository::instance()),
    _storage(JfrStorage::instance()),
    _string_pool(JfrStringPool::instance()) {}
  
<span class="line-added">+ enum RecorderState {</span>
<span class="line-added">+   STOPPED,</span>
<span class="line-added">+   RUNNING</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ static RecorderState recorder_state = STOPPED;</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void set_recorder_state(RecorderState from, RecorderState to) {</span>
<span class="line-added">+   assert(from == recorder_state, &quot;invariant&quot;);</span>
<span class="line-added">+   OrderAccess::storestore();</span>
<span class="line-added">+   recorder_state = to;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void start_recorder() {</span>
<span class="line-added">+   set_recorder_state(STOPPED, RUNNING);</span>
<span class="line-added">+   log_debug(jfr, system)(&quot;Recording service STARTED&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void stop_recorder() {</span>
<span class="line-added">+   set_recorder_state(RUNNING, STOPPED);</span>
<span class="line-added">+   log_debug(jfr, system)(&quot;Recording service STOPPED&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool JfrRecorderService::is_recording() {</span>
<span class="line-added">+   const bool is_running = recorder_state == RUNNING;</span>
<span class="line-added">+   OrderAccess::loadload();</span>
<span class="line-added">+   return is_running;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void JfrRecorderService::start() {
<span class="line-modified">!   MutexLocker lock(JfrStream_lock, Mutex::_no_safepoint_check_flag);</span>
    assert(!is_recording(), &quot;invariant&quot;);
    clear();
    open_new_chunk();
<span class="line-modified">!   start_recorder();</span>
<span class="line-added">+   assert(is_recording(), &quot;invariant&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void stop() {</span>
<span class="line-added">+   assert(JfrRecorderService::is_recording(), &quot;invariant&quot;);</span>
<span class="line-added">+   stop_recorder();</span>
<span class="line-added">+   assert(!JfrRecorderService::is_recording(), &quot;invariant&quot;);</span>
  }
  
  void JfrRecorderService::clear() {
    ResourceMark rm;
    HandleMark hm;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 264,271 ***</span>
    invoke_safepoint_clear();
    post_safepoint_clear();
  }
  
  void JfrRecorderService::pre_safepoint_clear() {
<span class="line-removed">-   _stack_trace_repository.clear();</span>
    _string_pool.clear();
    _storage.clear();
  }
  
  void JfrRecorderService::invoke_safepoint_clear() {
    JfrVMOperation&lt;JfrRecorderService, &amp;JfrRecorderService::safepoint_clear&gt; safepoint_task(*this);
    VMThread::execute(&amp;safepoint_task);
  }
  
<span class="line-removed">- //</span>
<span class="line-removed">- // safepoint clear sequence</span>
<span class="line-removed">- //</span>
<span class="line-removed">- //  clear stacktrace repository -&gt;</span>
<span class="line-removed">- //    clear string pool -&gt;</span>
<span class="line-removed">- //      clear storage -&gt;</span>
<span class="line-removed">- //        shift epoch -&gt;</span>
<span class="line-removed">- //          update time</span>
<span class="line-removed">- //</span>
  void JfrRecorderService::safepoint_clear() {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
<span class="line-modified">!   _stack_trace_repository.clear();</span>
    _string_pool.clear();
    _storage.clear();
<span class="line-modified">!   _checkpoint_manager.shift_epoch();</span>
<span class="line-modified">!   _chunkwriter.time_stamp_chunk_now();</span>
  }
  
  void JfrRecorderService::post_safepoint_clear() {
    _checkpoint_manager.clear();
  }
  
<span class="line-modified">! static void stop() {</span>
<span class="line-modified">!   assert(JfrRecorderService::is_recording(), &quot;invariant&quot;);</span>
<span class="line-modified">!   log_debug(jfr, system)(&quot;Recording STOPPED&quot;);</span>
<span class="line-modified">!   set_recording_state(false);</span>
<span class="line-modified">!   assert(!JfrRecorderService::is_recording(), &quot;invariant&quot;);</span>
  }
  
<span class="line-modified">! void JfrRecorderService::rotate(int msgs) {</span>
<span class="line-modified">!   RotationLock rl(Thread::current());</span>
<span class="line-modified">!   if (rl.not_acquired()) {</span>
<span class="line-modified">!     return;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   static bool vm_error = false;</span>
<span class="line-modified">!   if (msgs &amp; MSGBIT(MSG_VM_ERROR)) {</span>
<span class="line-modified">!     vm_error = true;</span>
<span class="line-modified">!     prepare_for_vm_error_rotation();</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (msgs &amp; (MSGBIT(MSG_STOP))) {</span>
<span class="line-modified">!     stop();</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   // action determined by chunkwriter state</span>
<span class="line-modified">!   if (!_chunkwriter.is_valid()) {</span>
<span class="line-modified">!     in_memory_rotation();</span>
<span class="line-modified">!     return;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (vm_error) {</span>
<span class="line-modified">!     vm_error_rotation();</span>
<span class="line-modified">!     return;</span>
    }
<span class="line-modified">!   chunk_rotation();</span>
  }
  
<span class="line-modified">! void JfrRecorderService::prepare_for_vm_error_rotation() {</span>
    if (!_chunkwriter.is_valid()) {
      open_new_chunk(true);
    }
<span class="line-modified">!   _checkpoint_manager.register_service_thread(Thread::current());</span>
  }
  
<span class="line-modified">! void JfrRecorderService::open_new_chunk(bool vm_error) {</span>
<span class="line-removed">-   assert(!_chunkwriter.is_valid(), &quot;invariant&quot;);</span>
    assert(!JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);
<span class="line-modified">!   JfrChunkRotation::on_rotation();</span>
<span class="line-modified">!   MutexLockerEx stream_lock(JfrStream_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">!   if (!_repository.open_chunk(vm_error)) {</span>
<span class="line-modified">!     assert(!_chunkwriter.is_valid(), &quot;invariant&quot;);</span>
<span class="line-modified">!     _storage.control().set_to_disk(false);</span>
      return;
    }
<span class="line-modified">!   assert(_chunkwriter.is_valid(), &quot;invariant&quot;);</span>
<span class="line-modified">!   _storage.control().set_to_disk(true);</span>
  }
  
  void JfrRecorderService::in_memory_rotation() {
<span class="line-modified">!   assert(!_chunkwriter.is_valid(), &quot;invariant&quot;);</span>
    // currently running an in-memory recording
    open_new_chunk();
    if (_chunkwriter.is_valid()) {
      // dump all in-memory buffer data to the newly created chunk
<span class="line-modified">!     serialize_storage_from_in_memory_recording();</span>
    }
  }
  
<span class="line-removed">- void JfrRecorderService::serialize_storage_from_in_memory_recording() {</span>
<span class="line-removed">-   assert(!JfrStream_lock-&gt;owned_by_self(), &quot;not holding stream lock!&quot;);</span>
<span class="line-removed">-   MutexLockerEx stream_lock(JfrStream_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed">-   _storage.write();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void JfrRecorderService::chunk_rotation() {
    finalize_current_chunk();
    open_new_chunk();
  }
  
  void JfrRecorderService::finalize_current_chunk() {
    assert(_chunkwriter.is_valid(), &quot;invariant&quot;);
    write();
<span class="line-modified">!   assert(!_chunkwriter.is_valid(), &quot;invariant&quot;);</span>
  }
  
  void JfrRecorderService::write() {
    ResourceMark rm;
    HandleMark hm;
    pre_safepoint_write();
    invoke_safepoint_write();
    post_safepoint_write();
  }
  
<span class="line-removed">- typedef ServiceFunctor&lt;JfrStringPool, &amp;JfrStringPool::write&gt; WriteStringPool;</span>
<span class="line-removed">- typedef ServiceFunctor&lt;JfrStringPool, &amp;JfrStringPool::write_at_safepoint&gt; WriteStringPoolSafepoint;</span>
<span class="line-removed">- typedef WriteCheckpointEvent&lt;WriteStackTraceRepository&gt; WriteStackTraceCheckpoint;</span>
<span class="line-removed">- typedef WriteCheckpointEvent&lt;WriteStringPool&gt; WriteStringPoolCheckpoint;</span>
<span class="line-removed">- typedef WriteCheckpointEvent&lt;WriteStringPoolSafepoint&gt; WriteStringPoolCheckpointSafepoint;</span>
<span class="line-removed">- </span>
<span class="line-removed">- static void write_stacktrace_checkpoint(JfrStackTraceRepository&amp; stack_trace_repo, JfrChunkWriter&amp; chunkwriter, bool clear) {</span>
<span class="line-removed">-   WriteStackTraceRepository write_stacktrace_repo(stack_trace_repo, chunkwriter, clear);</span>
<span class="line-removed">-   WriteStackTraceCheckpoint write_stack_trace_checkpoint(chunkwriter, TYPE_STACKTRACE, write_stacktrace_repo);</span>
<span class="line-removed">-   write_stack_trace_checkpoint.process();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static void write_stringpool_checkpoint(JfrStringPool&amp; string_pool, JfrChunkWriter&amp; chunkwriter) {</span>
<span class="line-removed">-   WriteStringPool write_string_pool(string_pool);</span>
<span class="line-removed">-   WriteStringPoolCheckpoint write_string_pool_checkpoint(chunkwriter, TYPE_STRING, write_string_pool);</span>
<span class="line-removed">-   write_string_pool_checkpoint.process();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static void write_stringpool_checkpoint_safepoint(JfrStringPool&amp; string_pool, JfrChunkWriter&amp; chunkwriter) {</span>
<span class="line-removed">-   WriteStringPoolSafepoint write_string_pool(string_pool);</span>
<span class="line-removed">-   WriteStringPoolCheckpointSafepoint write_string_pool_checkpoint(chunkwriter, TYPE_STRING, write_string_pool);</span>
<span class="line-removed">-   write_string_pool_checkpoint.process();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- //</span>
<span class="line-removed">- // pre-safepoint write sequence</span>
<span class="line-removed">- //</span>
<span class="line-removed">- //  lock stream lock -&gt;</span>
<span class="line-removed">- //    write non-safepoint dependent types -&gt;</span>
<span class="line-removed">- //      write checkpoint epoch transition list-&gt;</span>
<span class="line-removed">- //        write stack trace checkpoint -&gt;</span>
<span class="line-removed">- //          write string pool checkpoint -&gt;</span>
<span class="line-removed">- //            write storage -&gt;</span>
<span class="line-removed">- //              release stream lock</span>
<span class="line-removed">- //</span>
  void JfrRecorderService::pre_safepoint_write() {
<span class="line-removed">-   MutexLockerEx stream_lock(JfrStream_lock, Mutex::_no_safepoint_check_flag);</span>
    assert(_chunkwriter.is_valid(), &quot;invariant&quot;);
<span class="line-modified">!   _checkpoint_manager.write_types();</span>
<span class="line-modified">!   _checkpoint_manager.write_epoch_transition_mspace();</span>
<span class="line-modified">!   write_stacktrace_checkpoint(_stack_trace_repository, _chunkwriter, false);</span>
<span class="line-modified">!   write_stringpool_checkpoint(_string_pool, _chunkwriter);</span>
<span class="line-modified">!   _storage.write();</span>
  }
  
  void JfrRecorderService::invoke_safepoint_write() {
    JfrVMOperation&lt;JfrRecorderService, &amp;JfrRecorderService::safepoint_write&gt; safepoint_task(*this);
    VMThread::execute(&amp;safepoint_task);
  }
  
<span class="line-removed">- static void write_object_sample_stacktrace(JfrStackTraceRepository&amp; stack_trace_repository) {</span>
<span class="line-removed">-   WriteObjectSampleStacktrace object_sample_stacktrace(stack_trace_repository);</span>
<span class="line-removed">-   object_sample_stacktrace.process();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- //</span>
<span class="line-removed">- // safepoint write sequence</span>
<span class="line-removed">- //</span>
<span class="line-removed">- //   lock stream lock -&gt;</span>
<span class="line-removed">- //     write object sample stacktraces -&gt;</span>
<span class="line-removed">- //       write stacktrace repository -&gt;</span>
<span class="line-removed">- //         write string pool -&gt;</span>
<span class="line-removed">- //           write safepoint dependent types -&gt;</span>
<span class="line-removed">- //             write storage -&gt;</span>
<span class="line-removed">- //                 shift_epoch -&gt;</span>
<span class="line-removed">- //                   update time -&gt;</span>
<span class="line-removed">- //                     lock metadata descriptor -&gt;</span>
<span class="line-removed">- //                       release stream lock</span>
<span class="line-removed">- //</span>
  void JfrRecorderService::safepoint_write() {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
<span class="line-modified">!   MutexLockerEx stream_lock(JfrStream_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">!   write_object_sample_stacktrace(_stack_trace_repository);</span>
<span class="line-modified">!   write_stacktrace_checkpoint(_stack_trace_repository, _chunkwriter, true);</span>
<span class="line-modified">!   write_stringpool_checkpoint_safepoint(_string_pool, _chunkwriter);</span>
<span class="line-modified">!   _checkpoint_manager.write_safepoint_types();</span>
    _storage.write_at_safepoint();
<span class="line-modified">!   _checkpoint_manager.shift_epoch();</span>
<span class="line-modified">!   _chunkwriter.time_stamp_chunk_now();</span>
<span class="line-modified">!   JfrMetadataEvent::lock();</span>
  }
  
<span class="line-removed">- static int64_t write_metadata_event(JfrChunkWriter&amp; chunkwriter) {</span>
<span class="line-removed">-   assert(chunkwriter.is_valid(), &quot;invariant&quot;);</span>
<span class="line-removed">-   const int64_t metadata_offset = chunkwriter.current_offset();</span>
<span class="line-removed">-   JfrMetadataEvent::write(chunkwriter, metadata_offset);</span>
<span class="line-removed">-   return metadata_offset;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- //</span>
<span class="line-removed">- // post-safepoint write sequence</span>
<span class="line-removed">- //</span>
<span class="line-removed">- //  lock stream lock -&gt;</span>
<span class="line-removed">- //    write type set -&gt;</span>
<span class="line-removed">- //      write checkpoints -&gt;</span>
<span class="line-removed">- //        write metadata event -&gt;</span>
<span class="line-removed">- //          write chunk header -&gt;</span>
<span class="line-removed">- //            close chunk fd -&gt;</span>
<span class="line-removed">- //              release stream lock</span>
<span class="line-removed">- //</span>
  void JfrRecorderService::post_safepoint_write() {
    assert(_chunkwriter.is_valid(), &quot;invariant&quot;);
    // During the safepoint tasks just completed, the system transitioned to a new epoch.
    // Type tagging is epoch relative which entails we are able to write out the
    // already tagged artifacts for the previous epoch. We can accomplish this concurrently
    // with threads now tagging artifacts in relation to the new, now updated, epoch and remain outside of a safepoint.
    _checkpoint_manager.write_type_set();
<span class="line-modified">!   MutexLockerEx stream_lock(JfrStream_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">!   // serialize any outstanding checkpoint memory</span>
<span class="line-modified">!   _checkpoint_manager.write();</span>
    // serialize the metadata descriptor event and close out the chunk
<span class="line-modified">!   _repository.close_chunk(write_metadata_event(_chunkwriter));</span>
<span class="line-modified">!   assert(!_chunkwriter.is_valid(), &quot;invariant&quot;);</span>
  }
  
<span class="line-modified">! void JfrRecorderService::vm_error_rotation() {</span>
<span class="line-modified">!   if (_chunkwriter.is_valid()) {</span>
<span class="line-modified">!     finalize_current_chunk_on_vm_error();</span>
<span class="line-modified">!     assert(!_chunkwriter.is_valid(), &quot;invariant&quot;);</span>
<span class="line-modified">!     _repository.on_vm_error();</span>
    }
  }
  
<span class="line-modified">! void JfrRecorderService::finalize_current_chunk_on_vm_error() {</span>
    assert(_chunkwriter.is_valid(), &quot;invariant&quot;);
<span class="line-modified">!   pre_safepoint_write();</span>
<span class="line-modified">!   JfrMetadataEvent::lock();</span>
<span class="line-modified">!   // Do not attempt safepoint dependent operations during emergency dump.</span>
<span class="line-modified">!   // Optimistically write tagged artifacts.</span>
<span class="line-modified">!   _checkpoint_manager.shift_epoch();</span>
<span class="line-modified">!   _checkpoint_manager.write_type_set();</span>
<span class="line-modified">!   // update time</span>
<span class="line-modified">!   _chunkwriter.time_stamp_chunk_now();</span>
<span class="line-modified">!   post_safepoint_write();</span>
<span class="line-modified">!   assert(!_chunkwriter.is_valid(), &quot;invariant&quot;);</span>
  }
  
  void JfrRecorderService::process_full_buffers() {
    if (_chunkwriter.is_valid()) {
<span class="line-removed">-     assert(!JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-removed">-     MutexLockerEx stream_lock(JfrStream_lock, Mutex::_no_safepoint_check_flag);</span>
      _storage.write_full();
    }
  }
  
  void JfrRecorderService::scavenge() {
<span class="line-new-header">--- 379,288 ---</span>
    invoke_safepoint_clear();
    post_safepoint_clear();
  }
  
  void JfrRecorderService::pre_safepoint_clear() {
    _string_pool.clear();
    _storage.clear();
<span class="line-added">+   _stack_trace_repository.clear();</span>
  }
  
  void JfrRecorderService::invoke_safepoint_clear() {
    JfrVMOperation&lt;JfrRecorderService, &amp;JfrRecorderService::safepoint_clear&gt; safepoint_task(*this);
    VMThread::execute(&amp;safepoint_task);
  }
  
  void JfrRecorderService::safepoint_clear() {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
<span class="line-modified">!   _checkpoint_manager.begin_epoch_shift();</span>
    _string_pool.clear();
    _storage.clear();
<span class="line-modified">!   _chunkwriter.set_time_stamp();</span>
<span class="line-modified">!   _stack_trace_repository.clear();</span>
<span class="line-added">+   _checkpoint_manager.end_epoch_shift();</span>
  }
  
  void JfrRecorderService::post_safepoint_clear() {
    _checkpoint_manager.clear();
  }
  
<span class="line-modified">! void JfrRecorderService::open_new_chunk(bool vm_error) {</span>
<span class="line-modified">!   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-modified">!   JfrChunkRotation::on_rotation();</span>
<span class="line-modified">!   const bool valid_chunk = _repository.open_chunk(vm_error);</span>
<span class="line-modified">!   _storage.control().set_to_disk(valid_chunk);</span>
<span class="line-added">+   if (valid_chunk) {</span>
<span class="line-added">+     _checkpoint_manager.write_static_type_set_and_threads();</span>
<span class="line-added">+   }</span>
  }
  
<span class="line-modified">! // &#39;rotation_safepoint_pending&#39; is currently only relevant in the unusual case of an emergency dump.</span>
<span class="line-modified">! // Since the JfrStream_lock must be acquired using _no_safepoint_check,</span>
<span class="line-modified">! // if the thread running the emergency dump is a JavaThread, a pending safepoint, induced by rotation,</span>
<span class="line-modified">! // would lead to a deadlock. This deadlock, although unpleasant, is not completely horrendous at this</span>
<span class="line-modified">! // location because the WatcherThread will terminate the VM after a timeout.</span>
<span class="line-modified">! // Deadlock avoidance is done not to affect the stability of general VM error reporting.</span>
<span class="line-modified">! static bool rotation_safepoint_pending = false;</span>
<span class="line-modified">! </span>
<span class="line-modified">! static bool is_rotation_safepoint_pending() {</span>
<span class="line-modified">!   return Atomic::load_acquire(&amp;rotation_safepoint_pending);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! static void set_rotation_safepoint_pending(bool value) {</span>
<span class="line-modified">!   assert(value ? !is_rotation_safepoint_pending() : is_rotation_safepoint_pending(), &quot;invariant&quot;);</span>
<span class="line-modified">!   Atomic::release_store(&amp;rotation_safepoint_pending, value);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! static bool vm_error = false;</span>
<span class="line-modified">! static const Thread* vm_error_thread = NULL;</span>
<span class="line-modified">! </span>
<span class="line-modified">! static bool prepare_for_vm_error_rotation() {</span>
<span class="line-added">+   assert(!JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-added">+   Thread* const t = Thread::current();</span>
<span class="line-added">+   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   if (is_rotation_safepoint_pending() &amp;&amp; t-&gt;is_Java_thread()) {</span>
<span class="line-added">+     // A safepoint is pending, avoid deadlock.</span>
<span class="line-added">+     log_warning(jfr, system)(&quot;Unable to issue successful emergency dump&quot;);</span>
<span class="line-added">+     return false;</span>
    }
<span class="line-modified">!   vm_error_thread = t;</span>
<span class="line-added">+   vm_error = true;</span>
<span class="line-added">+   OrderAccess::fence();</span>
<span class="line-added">+   return true;</span>
  }
  
<span class="line-modified">! void JfrRecorderService::vm_error_rotation() {</span>
<span class="line-added">+   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-added">+   assert(vm_error, &quot;invariant&quot;);</span>
<span class="line-added">+   Thread* const t = Thread::current();</span>
<span class="line-added">+   if (vm_error_thread != t) {</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   assert(vm_error_thread == t, &quot;invariant&quot;);</span>
    if (!_chunkwriter.is_valid()) {
      open_new_chunk(true);
    }
<span class="line-modified">!   if (_chunkwriter.is_valid()) {</span>
<span class="line-added">+     _checkpoint_manager.register_service_thread(t);</span>
<span class="line-added">+     _storage.flush_regular_buffer(t-&gt;jfr_thread_local()-&gt;native_buffer(), t);</span>
<span class="line-added">+     _chunkwriter.mark_chunk_final();</span>
<span class="line-added">+     invoke_flush();</span>
<span class="line-added">+     _chunkwriter.set_time_stamp();</span>
<span class="line-added">+     _repository.close_chunk();</span>
<span class="line-added">+     assert(!_chunkwriter.is_valid(), &quot;invariant&quot;);</span>
<span class="line-added">+     _repository.on_vm_error();</span>
<span class="line-added">+   }</span>
  }
  
<span class="line-modified">! void JfrRecorderService::rotate(int msgs) {</span>
    assert(!JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);
<span class="line-modified">!   if (msgs &amp; MSGBIT(MSG_VM_ERROR)) {</span>
<span class="line-modified">!     // emergency dump</span>
<span class="line-modified">!     if (!prepare_for_vm_error_rotation()) {</span>
<span class="line-modified">!       return;</span>
<span class="line-modified">!     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+   MutexLocker lock(JfrStream_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">+   if (vm_error) {</span>
<span class="line-added">+     vm_error_rotation();</span>
      return;
    }
<span class="line-modified">!   if (_storage.control().to_disk()) {</span>
<span class="line-modified">!     chunk_rotation();</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     in_memory_rotation();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (msgs &amp; (MSGBIT(MSG_STOP))) {</span>
<span class="line-added">+     stop();</span>
<span class="line-added">+   }</span>
  }
  
  void JfrRecorderService::in_memory_rotation() {
<span class="line-modified">!   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
    // currently running an in-memory recording
<span class="line-added">+   assert(!_storage.control().to_disk(), &quot;invariant&quot;);</span>
    open_new_chunk();
    if (_chunkwriter.is_valid()) {
      // dump all in-memory buffer data to the newly created chunk
<span class="line-modified">!     write_storage(_storage, _chunkwriter);</span>
    }
  }
  
  void JfrRecorderService::chunk_rotation() {
<span class="line-added">+   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
    finalize_current_chunk();
    open_new_chunk();
  }
  
  void JfrRecorderService::finalize_current_chunk() {
    assert(_chunkwriter.is_valid(), &quot;invariant&quot;);
<span class="line-added">+   assert(!is_rotation_safepoint_pending(), &quot;invariant&quot;);</span>
<span class="line-added">+   set_rotation_safepoint_pending(true);</span>
    write();
<span class="line-modified">!   assert(!is_rotation_safepoint_pending(), &quot;invariant&quot;);</span>
  }
  
  void JfrRecorderService::write() {
    ResourceMark rm;
    HandleMark hm;
    pre_safepoint_write();
    invoke_safepoint_write();
    post_safepoint_write();
  }
  
  void JfrRecorderService::pre_safepoint_write() {
    assert(_chunkwriter.is_valid(), &quot;invariant&quot;);
<span class="line-modified">!   assert(is_rotation_safepoint_pending(), &quot;invariant&quot;);</span>
<span class="line-modified">!   if (LeakProfiler::is_running()) {</span>
<span class="line-modified">!     // Exclusive access to the object sampler instance.</span>
<span class="line-modified">!     // The sampler is released (unlocked) later in post_safepoint_write.</span>
<span class="line-modified">!     ObjectSampleCheckpoint::on_rotation(ObjectSampler::acquire(), _stack_trace_repository);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (_string_pool.is_modified()) {</span>
<span class="line-added">+     write_stringpool(_string_pool, _chunkwriter);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   write_storage(_storage, _chunkwriter);</span>
<span class="line-added">+   if (_stack_trace_repository.is_modified()) {</span>
<span class="line-added">+     write_stacktrace(_stack_trace_repository, _chunkwriter, false);</span>
<span class="line-added">+   }</span>
  }
  
  void JfrRecorderService::invoke_safepoint_write() {
    JfrVMOperation&lt;JfrRecorderService, &amp;JfrRecorderService::safepoint_write&gt; safepoint_task(*this);
    VMThread::execute(&amp;safepoint_task);
  }
  
  void JfrRecorderService::safepoint_write() {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
<span class="line-modified">!   assert(is_rotation_safepoint_pending(), &quot;invariant&quot;);</span>
<span class="line-modified">!   set_rotation_safepoint_pending(false);</span>
<span class="line-modified">!   _checkpoint_manager.begin_epoch_shift();</span>
<span class="line-modified">!   if (_string_pool.is_modified()) {</span>
<span class="line-modified">!     write_stringpool_safepoint(_string_pool, _chunkwriter);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   _checkpoint_manager.on_rotation();</span>
    _storage.write_at_safepoint();
<span class="line-modified">!   _chunkwriter.set_time_stamp();</span>
<span class="line-modified">!   write_stacktrace(_stack_trace_repository, _chunkwriter, true);</span>
<span class="line-modified">!   _checkpoint_manager.end_epoch_shift();</span>
  }
  
  void JfrRecorderService::post_safepoint_write() {
    assert(_chunkwriter.is_valid(), &quot;invariant&quot;);
<span class="line-added">+   assert(!is_rotation_safepoint_pending(), &quot;invariant&quot;);</span>
    // During the safepoint tasks just completed, the system transitioned to a new epoch.
    // Type tagging is epoch relative which entails we are able to write out the
    // already tagged artifacts for the previous epoch. We can accomplish this concurrently
    // with threads now tagging artifacts in relation to the new, now updated, epoch and remain outside of a safepoint.
    _checkpoint_manager.write_type_set();
<span class="line-modified">!   if (LeakProfiler::is_running()) {</span>
<span class="line-modified">!     // The object sampler instance was exclusively acquired and locked in pre_safepoint_write.</span>
<span class="line-modified">!     // Note: There is a dependency on write_type_set() above, ensure the release is subsequent.</span>
<span class="line-added">+     ObjectSampler::release();</span>
<span class="line-added">+   }</span>
    // serialize the metadata descriptor event and close out the chunk
<span class="line-modified">!   write_metadata(_chunkwriter);</span>
<span class="line-modified">!   _repository.close_chunk();</span>
  }
  
<span class="line-modified">! static JfrBuffer* thread_local_buffer(Thread* t) {</span>
<span class="line-modified">!   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   return t-&gt;jfr_thread_local()-&gt;native_buffer();</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-added">+ static void reset_buffer(JfrBuffer* buffer, Thread* t) {</span>
<span class="line-added">+   assert(buffer != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(buffer == thread_local_buffer(t), &quot;invariant&quot;);</span>
<span class="line-added">+   buffer-&gt;set_pos(const_cast&lt;u1*&gt;(buffer-&gt;top()));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void reset_thread_local_buffer(Thread* t) {</span>
<span class="line-added">+   reset_buffer(thread_local_buffer(t), t);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void write_thread_local_buffer(JfrChunkWriter&amp; chunkwriter, Thread* t) {</span>
<span class="line-added">+   JfrBuffer * const buffer = thread_local_buffer(t);</span>
<span class="line-added">+   assert(buffer != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   if (!buffer-&gt;empty()) {</span>
<span class="line-added">+     chunkwriter.write_unbuffered(buffer-&gt;top(), buffer-&gt;pos() - buffer-&gt;top());</span>
<span class="line-added">+     reset_buffer(buffer, t);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ size_t JfrRecorderService::flush() {</span>
<span class="line-added">+   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-added">+   size_t total_elements = flush_metadata(_chunkwriter);</span>
<span class="line-added">+   const size_t storage_elements = flush_storage(_storage, _chunkwriter);</span>
<span class="line-added">+   if (0 == storage_elements) {</span>
<span class="line-added">+     return total_elements;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   total_elements += storage_elements;</span>
<span class="line-added">+   if (_string_pool.is_modified()) {</span>
<span class="line-added">+     total_elements += flush_stringpool(_string_pool, _chunkwriter);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (_stack_trace_repository.is_modified()) {</span>
<span class="line-added">+     total_elements += flush_stacktrace(_stack_trace_repository, _chunkwriter);</span>
    }
<span class="line-added">+   if (_checkpoint_manager.is_type_set_required()) {</span>
<span class="line-added">+     total_elements += flush_typeset(_checkpoint_manager, _chunkwriter);</span>
<span class="line-added">+   } else if (_checkpoint_manager.is_static_type_set_required()) {</span>
<span class="line-added">+     // don&#39;t tally this, it is only in order to flush the waiting constants</span>
<span class="line-added">+     _checkpoint_manager.flush_static_type_set();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return total_elements;</span>
  }
  
<span class="line-modified">! typedef Content&lt;JfrRecorderService, &amp;JfrRecorderService::flush&gt; FlushFunctor;</span>
<span class="line-added">+ typedef WriteContent&lt;FlushFunctor&gt; Flush;</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JfrRecorderService::invoke_flush() {</span>
<span class="line-added">+   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
    assert(_chunkwriter.is_valid(), &quot;invariant&quot;);
<span class="line-modified">!   Thread* const t = Thread::current();</span>
<span class="line-modified">!   ResourceMark rm(t);</span>
<span class="line-modified">!   HandleMark hm(t);</span>
<span class="line-modified">!   ++flushpoint_id;</span>
<span class="line-modified">!   reset_thread_local_buffer(t);</span>
<span class="line-modified">!   FlushFunctor flushpoint(*this);</span>
<span class="line-modified">!   Flush fl(_chunkwriter, flushpoint);</span>
<span class="line-modified">!   invoke_with_flush_event(fl);</span>
<span class="line-modified">!   write_thread_local_buffer(_chunkwriter, t);</span>
<span class="line-modified">!   _repository.flush_chunk();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JfrRecorderService::flushpoint() {</span>
<span class="line-added">+   MutexLocker lock(JfrStream_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">+   if (_chunkwriter.is_valid()) {</span>
<span class="line-added">+     invoke_flush();</span>
<span class="line-added">+   }</span>
  }
  
  void JfrRecorderService::process_full_buffers() {
    if (_chunkwriter.is_valid()) {
      _storage.write_full();
    }
  }
  
  void JfrRecorderService::scavenge() {
</pre>
<center><a href="jfrPostBox.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrRecorderService.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jfr/recorder/jfrRecorder.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/dcmd/jfrDcmds.hpp&quot;
 27 #include &quot;jfr/instrumentation/jfrJvmtiAgent.hpp&quot;
 28 #include &quot;jfr/jni/jfrJavaSupport.hpp&quot;
 29 #include &quot;jfr/periodic/jfrOSInterface.hpp&quot;
 30 #include &quot;jfr/periodic/sampling/jfrThreadSampler.hpp&quot;
 31 #include &quot;jfr/recorder/jfrRecorder.hpp&quot;
 32 #include &quot;jfr/recorder/checkpoint/jfrCheckpointManager.hpp&quot;
 33 #include &quot;jfr/recorder/repository/jfrRepository.hpp&quot;
 34 #include &quot;jfr/recorder/service/jfrOptionSet.hpp&quot;
 35 #include &quot;jfr/recorder/service/jfrPostBox.hpp&quot;
 36 #include &quot;jfr/recorder/service/jfrRecorderService.hpp&quot;
 37 #include &quot;jfr/recorder/service/jfrRecorderThread.hpp&quot;
 38 #include &quot;jfr/recorder/storage/jfrStorage.hpp&quot;
 39 #include &quot;jfr/recorder/stacktrace/jfrStackTraceRepository.hpp&quot;
 40 #include &quot;jfr/recorder/stringpool/jfrStringPool.hpp&quot;
 41 #include &quot;jfr/utilities/jfrTime.hpp&quot;
 42 #include &quot;jfr/writers/jfrJavaEventWriter.hpp&quot;
 43 #include &quot;logging/log.hpp&quot;
 44 #include &quot;logging/logStream.hpp&quot;
 45 #include &quot;memory/resourceArea.inline.hpp&quot;
 46 #include &quot;runtime/handles.inline.hpp&quot;
 47 #include &quot;runtime/globals_extension.hpp&quot;
 48 #include &quot;utilities/growableArray.hpp&quot;
<a name="1" id="anc1"></a>


 49 
 50 bool JfrRecorder::is_disabled() {
 51   // True if -XX:-FlightRecorder has been explicitly set on the
 52   // command line
 53   return FLAG_IS_CMDLINE(FlightRecorder) ? !FlightRecorder : false;
 54 }
 55 
 56 static bool _enabled = false;
 57 
 58 static bool enable() {
 59   assert(!_enabled, &quot;invariant&quot;);
<a name="2" id="anc2"></a><span class="line-modified"> 60   FLAG_SET_MGMT(bool, FlightRecorder, true);</span>


 61   _enabled = FlightRecorder;
 62   assert(_enabled, &quot;invariant&quot;);
 63   return _enabled;
 64 }
 65 
 66 bool JfrRecorder::is_enabled() {
 67   return _enabled;
 68 }
 69 
<a name="3" id="anc3"></a><span class="line-modified"> 70 bool JfrRecorder::on_vm_init() {</span>
 71   if (!is_disabled()) {
 72     if (FlightRecorder || StartFlightRecording != NULL) {
 73       enable();
 74     }
 75   }
 76   // fast time initialization
 77   return JfrTime::initialize();
 78 }
 79 
 80 static GrowableArray&lt;JfrStartFlightRecordingDCmd*&gt;* dcmd_recordings_array = NULL;
 81 
 82 static void release_recordings() {
 83   if (dcmd_recordings_array != NULL) {
 84     const int length = dcmd_recordings_array-&gt;length();
 85     for (int i = 0; i &lt; length; ++i) {
 86       delete dcmd_recordings_array-&gt;at(i);
 87     }
 88     delete dcmd_recordings_array;
 89     dcmd_recordings_array = NULL;
 90   }
 91 }
 92 
 93 static void teardown_startup_support() {
 94   release_recordings();
<a name="4" id="anc4"></a><span class="line-modified"> 95   JfrOptionSet::release_startup_recording_options();</span>
 96 }
 97 
 98 // Parsing options here to detect errors as soon as possible
 99 static bool parse_recording_options(const char* options, JfrStartFlightRecordingDCmd* dcmd_recording, TRAPS) {
100   assert(options != NULL, &quot;invariant&quot;);
101   assert(dcmd_recording != NULL, &quot;invariant&quot;);
102   CmdLine cmdline(options, strlen(options), true);
103   dcmd_recording-&gt;parse(&amp;cmdline, &#39;,&#39;, THREAD);
104   if (HAS_PENDING_EXCEPTION) {
105     java_lang_Throwable::print(PENDING_EXCEPTION, tty);
106     CLEAR_PENDING_EXCEPTION;
107     return false;
108   }
109   return true;
110 }
111 
112 static bool validate_recording_options(TRAPS) {
<a name="5" id="anc5"></a><span class="line-modified">113   const GrowableArray&lt;const char*&gt;* options = JfrOptionSet::startup_recording_options();</span>
114   if (options == NULL) {
115     return true;
116   }
117   const int length = options-&gt;length();
118   assert(length &gt;= 1, &quot;invariant&quot;);
119   assert(dcmd_recordings_array == NULL, &quot;invariant&quot;);
120   dcmd_recordings_array = new (ResourceObj::C_HEAP, mtTracing)GrowableArray&lt;JfrStartFlightRecordingDCmd*&gt;(length, true, mtTracing);
121   assert(dcmd_recordings_array != NULL, &quot;invariant&quot;);
122   for (int i = 0; i &lt; length; ++i) {
123     JfrStartFlightRecordingDCmd* const dcmd_recording = new(ResourceObj::C_HEAP, mtTracing) JfrStartFlightRecordingDCmd(tty, true);
124     assert(dcmd_recording != NULL, &quot;invariant&quot;);
125     dcmd_recordings_array-&gt;append(dcmd_recording);
126     if (!parse_recording_options(options-&gt;at(i), dcmd_recording, THREAD)) {
127       return false;
128     }
129   }
130   return true;
131 }
132 
133 static bool launch_recording(JfrStartFlightRecordingDCmd* dcmd_recording, TRAPS) {
134   assert(dcmd_recording != NULL, &quot;invariant&quot;);
135   log_trace(jfr, system)(&quot;Starting a recording&quot;);
136   dcmd_recording-&gt;execute(DCmd_Source_Internal, THREAD);
137   if (HAS_PENDING_EXCEPTION) {
138     log_debug(jfr, system)(&quot;Exception while starting a recording&quot;);
139     CLEAR_PENDING_EXCEPTION;
140     return false;
141   }
142   log_trace(jfr, system)(&quot;Finished starting a recording&quot;);
143   return true;
144 }
145 
<a name="6" id="anc6"></a><span class="line-modified">146 static bool launch_recordings(TRAPS) {</span>
147   bool result = true;
148   if (dcmd_recordings_array != NULL) {
149     const int length = dcmd_recordings_array-&gt;length();
150     assert(length &gt;= 1, &quot;invariant&quot;);
151     for (int i = 0; i &lt; length; ++i) {
152       if (!launch_recording(dcmd_recordings_array-&gt;at(i), THREAD)) {
153         result = false;
154         break;
155       }
156     }
157   }
158   teardown_startup_support();
159   return result;
160 }
161 
162 static void log_jdk_jfr_module_resolution_error(TRAPS) {
163   LogTarget(Error, jfr, system) lt_error;
164   LogTargetHandle handle(lt_error);
165   LogStream stream(handle);
166   JfrJavaSupport::is_jdk_jfr_module_available(&amp;stream, THREAD);
167 }
168 
169 static bool is_cds_dump_requested() {
170   // we will not be able to launch recordings if a cds dump is being requested
<a name="7" id="anc7"></a><span class="line-modified">171   if (DumpSharedSpaces &amp;&amp; (JfrOptionSet::startup_recording_options() != NULL)) {</span>
172     warning(&quot;JFR will be disabled during CDS dumping&quot;);
173     teardown_startup_support();
174     return true;
175   }
176   return false;
177 }
178 
<a name="8" id="anc8"></a><span class="line-modified">179 bool JfrRecorder::on_vm_start() {</span>
180   if (is_cds_dump_requested()) {
181     return true;
182   }
183   Thread* const thread = Thread::current();
184   if (!JfrOptionSet::initialize(thread)) {
185     return false;
186   }
187   if (!register_jfr_dcmds()) {
188     return false;
189   }
<a name="9" id="anc9"></a><span class="line-removed">190 </span>
191   const bool in_graph = JfrJavaSupport::is_jdk_jfr_module_available();
<a name="10" id="anc10"></a><span class="line-removed">192 </span>
193   if (in_graph) {
194     if (!validate_recording_options(thread)) {
195       return false;
196     }
<a name="11" id="anc11"></a><span class="line-removed">197     if (!JfrJavaEventWriter::initialize()) {</span>
<span class="line-removed">198       return false;</span>
<span class="line-removed">199     }</span>
200     if (!JfrOptionSet::configure(thread)) {
201       return false;
202     }
203   }
<a name="12" id="anc12"></a><span class="line-removed">204 </span>
205   if (!is_enabled()) {
206     return true;
207   }
<a name="13" id="anc13"></a><span class="line-removed">208 </span>
209   if (!in_graph) {
210     log_jdk_jfr_module_resolution_error(thread);
211     return false;
212   }
<a name="14" id="anc14"></a>

213 
<a name="15" id="anc15"></a><span class="line-modified">214   return launch_recordings(thread);</span>


215 }
216 
217 static bool _created = false;
218 
219 //
220 // Main entry point for starting Jfr functionality.
221 // Non-protected initializations assume single-threaded setup.
222 //
223 bool JfrRecorder::create(bool simulate_failure) {
224   assert(!is_disabled(), &quot;invariant&quot;);
225   assert(!is_created(), &quot;invariant&quot;);
226   if (!is_enabled()) {
227     enable();
228   }
229   if (!create_components() || simulate_failure) {
230     destroy_components();
231     return false;
232   }
233   if (!create_recorder_thread()) {
234     destroy_components();
235     return false;
236   }
237   _created = true;
238   return true;
239 }
240 
241 bool JfrRecorder::is_created() {
242   return _created;
243 }
244 
245 bool JfrRecorder::create_components() {
246   ResourceMark rm;
247   HandleMark hm;
248 
<a name="16" id="anc16"></a>


249   if (!create_jvmti_agent()) {
250     return false;
251   }
252   if (!create_post_box()) {
253     return false;
254   }
255   if (!create_chunk_repository()) {
256     return false;
257   }
258   if (!create_storage()) {
259     return false;
260   }
261   if (!create_checkpoint_manager()) {
262     return false;
263   }
264   if (!create_stacktrace_repository()) {
265     return false;
266   }
267   if (!create_os_interface()) {
268     return false;
269   }
270   if (!create_stringpool()) {
271     return false;
272   }
273   if (!create_thread_sampling()) {
274     return false;
275   }
276   return true;
277 }
278 
279 // subsystems
<a name="17" id="anc17"></a><span class="line-removed">280 static JfrJvmtiAgent* _jvmti_agent = NULL;</span>
281 static JfrPostBox* _post_box = NULL;
282 static JfrStorage* _storage = NULL;
283 static JfrCheckpointManager* _checkpoint_manager = NULL;
284 static JfrRepository* _repository = NULL;
285 static JfrStackTraceRepository* _stack_trace_repository;
286 static JfrStringPool* _stringpool = NULL;
287 static JfrOSInterface* _os_interface = NULL;
288 static JfrThreadSampling* _thread_sampling = NULL;
289 
<a name="18" id="anc18"></a>



290 bool JfrRecorder::create_jvmti_agent() {
291   return JfrOptionSet::allow_retransforms() ? JfrJvmtiAgent::create() : true;
292 }
293 
294 bool JfrRecorder::create_post_box() {
295   assert(_post_box == NULL, &quot;invariant&quot;);
296   _post_box = JfrPostBox::create();
297   return _post_box != NULL;
298 }
299 
300 bool JfrRecorder::create_chunk_repository() {
301   assert(_repository == NULL, &quot;invariant&quot;);
302   assert(_post_box != NULL, &quot;invariant&quot;);
303   _repository = JfrRepository::create(*_post_box);
304   return _repository != NULL &amp;&amp; _repository-&gt;initialize();
305 }
306 
307 bool JfrRecorder::create_os_interface() {
308   assert(_os_interface == NULL, &quot;invariant&quot;);
309   _os_interface = JfrOSInterface::create();
310   return _os_interface != NULL &amp;&amp; _os_interface-&gt;initialize();
311 }
312 
313 bool JfrRecorder::create_storage() {
314   assert(_repository != NULL, &quot;invariant&quot;);
315   assert(_post_box != NULL, &quot;invariant&quot;);
316   _storage = JfrStorage::create(_repository-&gt;chunkwriter(), *_post_box);
317   return _storage != NULL &amp;&amp; _storage-&gt;initialize();
318 }
319 
320 bool JfrRecorder::create_checkpoint_manager() {
321   assert(_checkpoint_manager == NULL, &quot;invariant&quot;);
322   assert(_repository != NULL, &quot;invariant&quot;);
323   _checkpoint_manager = JfrCheckpointManager::create(_repository-&gt;chunkwriter());
324   return _checkpoint_manager != NULL &amp;&amp; _checkpoint_manager-&gt;initialize();
325 }
326 
327 bool JfrRecorder::create_stacktrace_repository() {
328   assert(_stack_trace_repository == NULL, &quot;invariant&quot;);
329   _stack_trace_repository = JfrStackTraceRepository::create();
330   return _stack_trace_repository != NULL &amp;&amp; _stack_trace_repository-&gt;initialize();
331 }
332 
333 bool JfrRecorder::create_stringpool() {
334   assert(_stringpool == NULL, &quot;invariant&quot;);
335   assert(_repository != NULL, &quot;invariant&quot;);
336   _stringpool = JfrStringPool::create(_repository-&gt;chunkwriter());
337   return _stringpool != NULL &amp;&amp; _stringpool-&gt;initialize();
338 }
339 
340 bool JfrRecorder::create_thread_sampling() {
341   assert(_thread_sampling == NULL, &quot;invariant&quot;);
342   _thread_sampling = JfrThreadSampling::create();
343   return _thread_sampling != NULL;
344 }
345 
346 void JfrRecorder::destroy_components() {
347   JfrJvmtiAgent::destroy();
348   if (_post_box != NULL) {
349     JfrPostBox::destroy();
350     _post_box = NULL;
351   }
352   if (_repository != NULL) {
353     JfrRepository::destroy();
354     _repository = NULL;
355   }
356   if (_storage != NULL) {
357     JfrStorage::destroy();
358     _storage = NULL;
359   }
360   if (_checkpoint_manager != NULL) {
361     JfrCheckpointManager::destroy();
362     _checkpoint_manager = NULL;
363   }
364   if (_stack_trace_repository != NULL) {
365     JfrStackTraceRepository::destroy();
366     _stack_trace_repository = NULL;
367   }
368   if (_stringpool != NULL) {
369     JfrStringPool::destroy();
370     _stringpool = NULL;
371   }
372   if (_os_interface != NULL) {
373     JfrOSInterface::destroy();
374     _os_interface = NULL;
375   }
376   if (_thread_sampling != NULL) {
377     JfrThreadSampling::destroy();
378     _thread_sampling = NULL;
379   }
380 }
381 
382 bool JfrRecorder::create_recorder_thread() {
383   return JfrRecorderThread::start(_checkpoint_manager, _post_box, Thread::current());
384 }
385 
386 void JfrRecorder::destroy() {
387   assert(is_created(), &quot;invariant&quot;);
388   _post_box-&gt;post(MSG_SHUTDOWN);
389   JfrJvmtiAgent::destroy();
390 }
391 
392 void JfrRecorder::on_recorder_thread_exit() {
393   assert(!is_recording(), &quot;invariant&quot;);
394   // intent is to destroy the recorder instance and components,
395   // but need sensitive coordination not yet in place
396   //
397   // destroy_components();
398   //
399   log_debug(jfr, system)(&quot;Recorder thread STOPPED&quot;);
400 }
401 
402 void JfrRecorder::start_recording() {
403   _post_box-&gt;post(MSG_START);
404 }
405 
406 bool JfrRecorder::is_recording() {
407   return JfrRecorderService::is_recording();
408 }
409 
410 void JfrRecorder::stop_recording() {
411   _post_box-&gt;post(MSG_STOP);
412 }
<a name="19" id="anc19"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="19" type="hidden" />
</body>
</html>
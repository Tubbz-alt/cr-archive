<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jfr/recorder/storage/jfrMemorySpace.hpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 #ifndef SHARE_JFR_RECORDER_STORAGE_JFRMEMORYSPACE_HPP
 25 #define SHARE_JFR_RECORDER_STORAGE_JFRMEMORYSPACE_HPP
 26 
 27 #include &quot;jfr/utilities/jfrAllocation.hpp&quot;
 28 #include &quot;jfr/utilities/jfrDoublyLinkedList.hpp&quot;
 29 #include &quot;jfr/utilities/jfrIterator.hpp&quot;
<a name="1" id="anc1"></a><span class="line-removed"> 30 #include &quot;jfr/utilities/jfrTypes.hpp&quot;</span>
<span class="line-removed"> 31 #include &quot;runtime/os.hpp&quot;</span>
<span class="line-removed"> 32 #include &quot;utilities/globalDefinitions.hpp&quot;</span>
<span class="line-removed"> 33 #include &quot;utilities/macros.hpp&quot;</span>
 34 
 35 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;
 36 class JfrMemorySpace : public JfrCHeapObj {
 37  public:
 38   typedef T Type;
 39   typedef RetrievalType&lt;JfrMemorySpace&lt;T, RetrievalType, Callback&gt; &gt; Retrieval;
 40   typedef JfrDoublyLinkedList&lt;Type&gt; List;
 41   typedef StopOnNullIterator&lt;List&gt; Iterator;
 42  private:
 43   List _free;
 44   List _full;
 45   size_t _min_elem_size;
 46   size_t _limit_size;
 47   size_t _cache_count;
 48   Callback* _callback;
 49 
 50   bool should_populate_cache() const { return _free.count() &lt; _cache_count; }
 51 
 52  public:
 53   JfrMemorySpace(size_t min_elem_size, size_t limit_size, size_t cache_count, Callback* callback);
 54   ~JfrMemorySpace();
 55   bool initialize();
 56 
 57   size_t min_elem_size() const { return _min_elem_size; }
 58   size_t limit_size() const { return _limit_size; }
 59 
 60   bool has_full() const { return _full.head() != NULL; }
 61   bool has_free() const { return _free.head() != NULL; }
 62   bool is_full_empty() const { return !has_full(); }
 63   bool is_free_empty() const { return !has_free(); }
 64 
 65   size_t full_count() const { return _full.count(); }
 66   size_t free_count() const { return _free.count(); }
 67 
 68   List&amp; full() { return _full; }
 69   const List&amp; full() const { return _full; }
 70   List&amp; free() { return _free; }
 71   const List&amp; free() const { return _free; }
 72 
 73   Type* full_head() { return _full.head(); }
 74   Type* full_tail() { return _full.tail(); }
 75   Type* free_head() { return _free.head(); }
 76   Type* free_tail() { return _free.tail(); }
 77 
 78   void insert_free_head(Type* t) { _free.prepend(t); }
 79   void insert_free_tail(Type* t) { _free.append(t); }
 80   void insert_free_tail(Type* t, Type* tail, size_t count) { _free.append_list(t, tail, count); }
 81   void insert_full_head(Type* t) { _full.prepend(t); }
 82   void insert_full_tail(Type* t) { _full.append(t); }
 83   void insert_full_tail(Type* t, Type* tail, size_t count) { _full.append_list(t, tail, count); }
 84 
 85   Type* remove_free(Type* t) { return _free.remove(t); }
 86   Type* remove_full(Type* t) { return _full.remove(t); }
 87   Type* remove_free_tail() { _free.remove(_free.tail()); }
 88   Type* remove_full_tail() { return _full.remove(_full.tail()); }
 89   Type* clear_full(bool return_tail = false) { return _full.clear(return_tail); }
 90   Type* clear_free(bool return_tail = false) { return _free.clear(return_tail); }
 91   void release_full(Type* t);
 92   void release_free(Type* t);
 93 
 94   void register_full(Type* t, Thread* thread) { _callback-&gt;register_full(t, thread); }
 95   void lock() { _callback-&gt;lock(); }
 96   void unlock() { _callback-&gt;unlock(); }
 97   DEBUG_ONLY(bool is_locked() const { return _callback-&gt;is_locked(); })
 98 
 99   Type* allocate(size_t size);
100   void deallocate(Type* t);
101   Type* get(size_t size, Thread* thread) { return Retrieval::get(size, this, thread); }
102 
103   template &lt;typename IteratorCallback, typename IteratorType&gt;
104   void iterate(IteratorCallback&amp; callback, bool full = true, jfr_iter_direction direction = forward);
105 
<a name="2" id="anc2"></a><span class="line-modified">106   debug_only(bool in_full_list(const Type* t) const { return _full.in_list(t); })</span>
<span class="line-modified">107   debug_only(bool in_free_list(const Type* t) const { return _free.in_list(t); })</span>
<span class="line-removed">108 };</span>
<span class="line-removed">109 </span>
<span class="line-removed">110 // allocations are even multiples of the mspace min size</span>
<span class="line-removed">111 inline u8 align_allocation_size(u8 requested_size, size_t min_elem_size) {</span>
<span class="line-removed">112   assert((int)min_elem_size % os::vm_page_size() == 0, &quot;invariant&quot;);</span>
<span class="line-removed">113   u8 alloc_size_bytes = min_elem_size;</span>
<span class="line-removed">114   while (requested_size &gt; alloc_size_bytes) {</span>
<span class="line-removed">115     alloc_size_bytes &lt;&lt;= 1;</span>
<span class="line-removed">116   }</span>
<span class="line-removed">117   assert((int)alloc_size_bytes % os::vm_page_size() == 0, &quot;invariant&quot;);</span>
<span class="line-removed">118   return alloc_size_bytes;</span>
<span class="line-removed">119 }</span>
<span class="line-removed">120 </span>
<span class="line-removed">121 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;</span>
<span class="line-removed">122 T* JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::allocate(size_t size) {</span>
<span class="line-removed">123   const u8 aligned_size_bytes = align_allocation_size(size, _min_elem_size);</span>
<span class="line-removed">124   void* const allocation = JfrCHeapObj::new_array&lt;u1&gt;(aligned_size_bytes + sizeof(T));</span>
<span class="line-removed">125   if (allocation == NULL) {</span>
<span class="line-removed">126     return NULL;</span>
<span class="line-removed">127   }</span>
<span class="line-removed">128   T* const t = new (allocation) T;</span>
<span class="line-removed">129   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">130   if (!t-&gt;initialize(sizeof(T), aligned_size_bytes)) {</span>
<span class="line-removed">131     JfrCHeapObj::free(t, aligned_size_bytes + sizeof(T));</span>
<span class="line-removed">132     return NULL;</span>
<span class="line-removed">133   }</span>
<span class="line-removed">134   return t;</span>
<span class="line-removed">135 }</span>
<span class="line-removed">136 </span>
<span class="line-removed">137 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;</span>
<span class="line-removed">138 void JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::deallocate(T* t) {</span>
<span class="line-removed">139   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">140   assert(!_free.in_list(t), &quot;invariant&quot;);</span>
<span class="line-removed">141   assert(!_full.in_list(t), &quot;invariant&quot;);</span>
<span class="line-removed">142   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">143   JfrCHeapObj::free(t, t-&gt;total_size());</span>
<span class="line-removed">144 }</span>
<span class="line-removed">145 </span>
<span class="line-removed">146 template &lt;typename Mspace&gt;</span>
<span class="line-removed">147 class MspaceLock {</span>
<span class="line-removed">148  private:</span>
<span class="line-removed">149   Mspace* _mspace;</span>
<span class="line-removed">150  public:</span>
<span class="line-removed">151   MspaceLock(Mspace* mspace) : _mspace(mspace) { _mspace-&gt;lock(); }</span>
<span class="line-removed">152   ~MspaceLock() { _mspace-&gt;unlock(); }</span>
<span class="line-removed">153 };</span>
<span class="line-removed">154 </span>
<span class="line-removed">155 template &lt;typename Mspace&gt;</span>
<span class="line-removed">156 class ReleaseOp : public StackObj {</span>
<span class="line-removed">157  private:</span>
<span class="line-removed">158   Mspace* _mspace;</span>
<span class="line-removed">159   Thread* _thread;</span>
<span class="line-removed">160   bool _release_full;</span>
<span class="line-removed">161  public:</span>
<span class="line-removed">162   typedef typename Mspace::Type Type;</span>
<span class="line-removed">163   ReleaseOp(Mspace* mspace, Thread* thread, bool release_full = true) : _mspace(mspace), _thread(thread), _release_full(release_full) {}</span>
<span class="line-removed">164   bool process(Type* t);</span>
<span class="line-removed">165   size_t processed() const { return 0; }</span>
166 };
167 
168 #endif // SHARE_JFR_RECORDER_STORAGE_JFRMEMORYSPACE_HPP
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/jfr/recorder/checkpoint/jfrCheckpointManager.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../periodic/sampling/jfrThreadSampler.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrCheckpointManager.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/checkpoint/jfrCheckpointManager.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 22,25 ***</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;classfile/javaClasses.inline.hpp&quot;
<span class="line-modified">! #include &quot;jfr/recorder/jfrRecorder.hpp&quot;</span>
  #include &quot;jfr/recorder/checkpoint/jfrCheckpointManager.hpp&quot;
  #include &quot;jfr/recorder/checkpoint/jfrCheckpointWriter.hpp&quot;
  #include &quot;jfr/recorder/checkpoint/types/jfrTypeManager.hpp&quot;
  #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceIdEpoch.hpp&quot;
  #include &quot;jfr/recorder/service/jfrOptionSet.hpp&quot;
  #include &quot;jfr/recorder/storage/jfrMemorySpace.inline.hpp&quot;
  #include &quot;jfr/recorder/storage/jfrStorageUtils.inline.hpp&quot;
<span class="line-removed">- #include &quot;jfr/recorder/repository/jfrChunkWriter.hpp&quot;</span>
  #include &quot;jfr/utilities/jfrBigEndian.hpp&quot;
  #include &quot;jfr/utilities/jfrTypes.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-modified">! #include &quot;runtime/mutexLocker.hpp&quot;</span>
<span class="line-modified">! #include &quot;runtime/orderAccess.hpp&quot;</span>
  #include &quot;runtime/os.inline.hpp&quot;
  #include &quot;runtime/safepoint.hpp&quot;
  
  typedef JfrCheckpointManager::Buffer* BufferPtr;
  
<span class="line-new-header">--- 22,33 ---</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;classfile/javaClasses.inline.hpp&quot;
<span class="line-modified">! #include &quot;jfr/leakprofiler/checkpoint/objectSampleCheckpoint.hpp&quot;</span>
<span class="line-added">+ #include &quot;jfr/leakprofiler/leakProfiler.hpp&quot;</span>
  #include &quot;jfr/recorder/checkpoint/jfrCheckpointManager.hpp&quot;
  #include &quot;jfr/recorder/checkpoint/jfrCheckpointWriter.hpp&quot;
  #include &quot;jfr/recorder/checkpoint/types/jfrTypeManager.hpp&quot;
<span class="line-added">+ #include &quot;jfr/recorder/checkpoint/types/jfrTypeSet.hpp&quot;</span>
  #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceIdEpoch.hpp&quot;
<span class="line-added">+ #include &quot;jfr/recorder/jfrRecorder.hpp&quot;</span>
<span class="line-added">+ #include &quot;jfr/recorder/repository/jfrChunkWriter.hpp&quot;</span>
  #include &quot;jfr/recorder/service/jfrOptionSet.hpp&quot;
  #include &quot;jfr/recorder/storage/jfrMemorySpace.inline.hpp&quot;
  #include &quot;jfr/recorder/storage/jfrStorageUtils.inline.hpp&quot;
  #include &quot;jfr/utilities/jfrBigEndian.hpp&quot;
<span class="line-added">+ #include &quot;jfr/utilities/jfrIterator.hpp&quot;</span>
<span class="line-added">+ #include &quot;jfr/utilities/jfrThreadIterator.hpp&quot;</span>
  #include &quot;jfr/utilities/jfrTypes.hpp&quot;
<span class="line-added">+ #include &quot;jfr/writers/jfrJavaEventWriter.hpp&quot;</span>
  #include &quot;logging/log.hpp&quot;
<span class="line-added">+ #include &quot;memory/iterator.hpp&quot;</span>
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-modified">! #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-modified">! #include &quot;runtime/handles.inline.hpp&quot;</span>
<span class="line-added">+ #include &quot;runtime/mutex.hpp&quot;</span>
  #include &quot;runtime/os.inline.hpp&quot;
  #include &quot;runtime/safepoint.hpp&quot;
  
  typedef JfrCheckpointManager::Buffer* BufferPtr;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 78,33 ***</span>
      delete _epoch_transition_mspace;
    }
    if (_lock != NULL) {
      delete _lock;
    }
<span class="line-modified">!   JfrTypeManager::clear();</span>
  }
  
  static const size_t unlimited_mspace_size = 0;
  static const size_t checkpoint_buffer_cache_count = 2;
  static const size_t checkpoint_buffer_size = 512 * K;
  
<span class="line-modified">! static JfrCheckpointMspace* create_mspace(size_t buffer_size, size_t limit, size_t cache_count, JfrCheckpointManager* system) {</span>
<span class="line-modified">!   JfrCheckpointMspace* mspace = new JfrCheckpointMspace(buffer_size, limit, cache_count, system);</span>
<span class="line-removed">-   if (mspace != NULL) {</span>
<span class="line-removed">-     mspace-&gt;initialize();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return mspace;</span>
  }
  
  bool JfrCheckpointManager::initialize() {
    assert(_free_list_mspace == NULL, &quot;invariant&quot;);
<span class="line-modified">!   _free_list_mspace = create_mspace(checkpoint_buffer_size, unlimited_mspace_size, checkpoint_buffer_cache_count, this);</span>
    if (_free_list_mspace == NULL) {
      return false;
    }
    assert(_epoch_transition_mspace == NULL, &quot;invariant&quot;);
<span class="line-modified">!   _epoch_transition_mspace = create_mspace(checkpoint_buffer_size, unlimited_mspace_size, checkpoint_buffer_cache_count, this);</span>
    if (_epoch_transition_mspace == NULL) {
      return false;
    }
    assert(_lock == NULL, &quot;invariant&quot;);
    _lock = new Mutex(Monitor::leaf - 1, &quot;Checkpoint mutex&quot;, Mutex::_allow_vm_block_flag, Monitor::_safepoint_check_never);
<span class="line-new-header">--- 86,29 ---</span>
      delete _epoch_transition_mspace;
    }
    if (_lock != NULL) {
      delete _lock;
    }
<span class="line-modified">!   JfrTypeManager::destroy();</span>
  }
  
  static const size_t unlimited_mspace_size = 0;
  static const size_t checkpoint_buffer_cache_count = 2;
  static const size_t checkpoint_buffer_size = 512 * K;
  
<span class="line-modified">! static JfrCheckpointMspace* allocate_mspace(size_t size, size_t limit, size_t cache_count, JfrCheckpointManager* mgr) {</span>
<span class="line-modified">!   return create_mspace&lt;JfrCheckpointMspace, JfrCheckpointManager&gt;(size, limit, cache_count, mgr);</span>
  }
  
  bool JfrCheckpointManager::initialize() {
    assert(_free_list_mspace == NULL, &quot;invariant&quot;);
<span class="line-modified">!   _free_list_mspace = allocate_mspace(checkpoint_buffer_size, unlimited_mspace_size, checkpoint_buffer_cache_count, this);</span>
    if (_free_list_mspace == NULL) {
      return false;
    }
    assert(_epoch_transition_mspace == NULL, &quot;invariant&quot;);
<span class="line-modified">!   _epoch_transition_mspace = allocate_mspace(checkpoint_buffer_size, unlimited_mspace_size, checkpoint_buffer_cache_count, this);</span>
    if (_epoch_transition_mspace == NULL) {
      return false;
    }
    assert(_lock == NULL, &quot;invariant&quot;);
    _lock = new Mutex(Monitor::leaf - 1, &quot;Checkpoint mutex&quot;, Mutex::_allow_vm_block_flag, Monitor::_safepoint_check_never);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 112,32 ***</span>
      return false;
    }
    return JfrTypeManager::initialize();
  }
  
<span class="line-removed">- bool JfrCheckpointManager::use_epoch_transition_mspace(const Thread* thread) const {</span>
<span class="line-removed">-   return _service_thread != thread &amp;&amp; OrderAccess::load_acquire(&amp;_checkpoint_epoch_state) != JfrTraceIdEpoch::epoch();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void JfrCheckpointManager::synchronize_epoch() {</span>
<span class="line-removed">-   assert(_checkpoint_epoch_state != JfrTraceIdEpoch::epoch(), &quot;invariant&quot;);</span>
<span class="line-removed">-   OrderAccess::storestore();</span>
<span class="line-removed">-   _checkpoint_epoch_state = JfrTraceIdEpoch::epoch();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void JfrCheckpointManager::shift_epoch() {</span>
<span class="line-removed">-   debug_only(const u1 current_epoch = JfrTraceIdEpoch::current();)</span>
<span class="line-removed">-   JfrTraceIdEpoch::shift_epoch();</span>
<span class="line-removed">-   assert(current_epoch != JfrTraceIdEpoch::current(), &quot;invariant&quot;);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void JfrCheckpointManager::register_service_thread(const Thread* thread) {
    _service_thread = thread;
  }
  
  void JfrCheckpointManager::register_full(BufferPtr t, Thread* thread) {
    // nothing here at the moment
    assert(t-&gt;retired(), &quot;invariant&quot;);
  }
  
  void JfrCheckpointManager::lock() {
    assert(!_lock-&gt;owned_by_self(), &quot;invariant&quot;);
<span class="line-new-header">--- 116,18 ---</span>
      return false;
    }
    return JfrTypeManager::initialize();
  }
  
  void JfrCheckpointManager::register_service_thread(const Thread* thread) {
    _service_thread = thread;
  }
  
  void JfrCheckpointManager::register_full(BufferPtr t, Thread* thread) {
    // nothing here at the moment
<span class="line-added">+   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(t-&gt;acquired_by(thread), &quot;invariant&quot;);</span>
    assert(t-&gt;retired(), &quot;invariant&quot;);
  }
  
  void JfrCheckpointManager::lock() {
    assert(!_lock-&gt;owned_by_self(), &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 147,11 ***</span>
  void JfrCheckpointManager::unlock() {
    _lock-&gt;unlock();
  }
  
  #ifdef ASSERT
<span class="line-removed">- </span>
  bool JfrCheckpointManager::is_locked() const {
    return _lock-&gt;owned_by_self();
  }
  
  static void assert_free_lease(const BufferPtr buffer) {
<span class="line-new-header">--- 137,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 163,11 ***</span>
  static void assert_release(const BufferPtr buffer) {
    assert(buffer != NULL, &quot;invariant&quot;);
    assert(buffer-&gt;lease(), &quot;invariant&quot;);
    assert(buffer-&gt;acquired_by_self(), &quot;invariant&quot;);
  }
<span class="line-removed">- </span>
  #endif // ASSERT
  
  static BufferPtr lease_free(size_t size, JfrCheckpointMspace* mspace, size_t retry_count, Thread* thread) {
    static const size_t max_elem_size = mspace-&gt;min_elem_size(); // min is max
    BufferPtr buffer;
<span class="line-new-header">--- 152,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 181,26 ***</span>
    buffer = mspace_allocate_transient_lease_to_free(size, mspace, thread);
    DEBUG_ONLY(assert_free_lease(buffer);)
    return buffer;
  }
  
  static const size_t lease_retry = 10;
  
  BufferPtr JfrCheckpointManager::lease_buffer(Thread* thread, size_t size /* 0 */) {
    JfrCheckpointManager&amp; manager = instance();
    if (manager.use_epoch_transition_mspace(thread)) {
      return lease_free(size, manager._epoch_transition_mspace, lease_retry, thread);
    }
    return lease_free(size, manager._free_list_mspace, lease_retry, thread);
  }
  
  /*
<span class="line-modified">! * If the buffer was a &quot;lease&quot; from the free list, release back.</span>
<span class="line-modified">! *</span>
<span class="line-modified">! * The buffer is effectively invalidated for the thread post-return,</span>
<span class="line-modified">! * and the caller should take means to ensure that it is not referenced.</span>
<span class="line-modified">! */</span>
  static void release(BufferPtr const buffer, Thread* thread) {
    DEBUG_ONLY(assert_release(buffer);)
    buffer-&gt;clear_lease();
    buffer-&gt;release();
  }
<span class="line-new-header">--- 169,42 ---</span>
    buffer = mspace_allocate_transient_lease_to_free(size, mspace, thread);
    DEBUG_ONLY(assert_free_lease(buffer);)
    return buffer;
  }
  
<span class="line-added">+ bool JfrCheckpointManager::use_epoch_transition_mspace(const Thread* thread) const {</span>
<span class="line-added">+   return _service_thread != thread &amp;&amp; Atomic::load_acquire(&amp;_checkpoint_epoch_state) != JfrTraceIdEpoch::epoch();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  static const size_t lease_retry = 10;
  
  BufferPtr JfrCheckpointManager::lease_buffer(Thread* thread, size_t size /* 0 */) {
    JfrCheckpointManager&amp; manager = instance();
    if (manager.use_epoch_transition_mspace(thread)) {
      return lease_free(size, manager._epoch_transition_mspace, lease_retry, thread);
    }
    return lease_free(size, manager._free_list_mspace, lease_retry, thread);
  }
  
<span class="line-added">+ JfrCheckpointMspace* JfrCheckpointManager::lookup(BufferPtr old) const {</span>
<span class="line-added">+   assert(old != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   return _free_list_mspace-&gt;in_free_list(old) ? _free_list_mspace : _epoch_transition_mspace;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ BufferPtr JfrCheckpointManager::lease_buffer(BufferPtr old, Thread* thread, size_t size /* 0 */) {</span>
<span class="line-added">+   assert(old != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   JfrCheckpointMspace* mspace = instance().lookup(old);</span>
<span class="line-added">+   assert(mspace != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   return lease_free(size, mspace, lease_retry, thread);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  /*
<span class="line-modified">!  * If the buffer was a lease, release back.</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * The buffer is effectively invalidated for the thread post-return,</span>
<span class="line-modified">!  * and the caller should take means to ensure that it is not referenced.</span>
<span class="line-modified">!  */</span>
  static void release(BufferPtr const buffer, Thread* thread) {
    DEBUG_ONLY(assert_release(buffer);)
    buffer-&gt;clear_lease();
    buffer-&gt;release();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 212,23 ***</span>
      // indicates a lease is being returned
      release(old, thread);
      return NULL;
    }
    // migration of in-flight information
<span class="line-modified">!   BufferPtr const new_buffer = lease_buffer(thread, used + requested);</span>
    if (new_buffer != NULL) {
      migrate_outstanding_writes(old, new_buffer, used, requested);
    }
    release(old, thread);
    return new_buffer; // might be NULL
  }
  
  // offsets into the JfrCheckpointEntry
  static const juint starttime_offset = sizeof(jlong);
  static const juint duration_offset = starttime_offset + sizeof(jlong);
<span class="line-modified">! static const juint flushpoint_offset = duration_offset + sizeof(jlong);</span>
<span class="line-modified">! static const juint types_offset = flushpoint_offset + sizeof(juint);</span>
  static const juint payload_offset = types_offset + sizeof(juint);
  
  template &lt;typename Return&gt;
  static Return read_data(const u1* data) {
    return JfrBigEndian::read&lt;Return&gt;(data);
<span class="line-new-header">--- 216,23 ---</span>
      // indicates a lease is being returned
      release(old, thread);
      return NULL;
    }
    // migration of in-flight information
<span class="line-modified">!   BufferPtr const new_buffer = lease_buffer(old, thread, used + requested);</span>
    if (new_buffer != NULL) {
      migrate_outstanding_writes(old, new_buffer, used, requested);
    }
    release(old, thread);
    return new_buffer; // might be NULL
  }
  
  // offsets into the JfrCheckpointEntry
  static const juint starttime_offset = sizeof(jlong);
  static const juint duration_offset = starttime_offset + sizeof(jlong);
<span class="line-modified">! static const juint checkpoint_type_offset = duration_offset + sizeof(jlong);</span>
<span class="line-modified">! static const juint types_offset = checkpoint_type_offset + sizeof(juint);</span>
  static const juint payload_offset = types_offset + sizeof(juint);
  
  template &lt;typename Return&gt;
  static Return read_data(const u1* data) {
    return JfrBigEndian::read&lt;Return&gt;(data);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 244,60 ***</span>
  
  static jlong duration(const u1* data) {
    return read_data&lt;jlong&gt;(data + duration_offset);
  }
  
<span class="line-modified">! static bool is_flushpoint(const u1* data) {</span>
<span class="line-modified">!   return read_data&lt;juint&gt;(data + flushpoint_offset) == (juint)1;</span>
  }
  
  static juint number_of_types(const u1* data) {
    return read_data&lt;juint&gt;(data + types_offset);
  }
  
<span class="line-modified">! static void write_checkpoint_header(JfrChunkWriter&amp; cw, intptr_t offset_prev_cp_event, const u1* data) {</span>
    cw.reserve(sizeof(u4));
<span class="line-modified">!   cw.write((u8)EVENT_CHECKPOINT);</span>
    cw.write(starttime(data));
    cw.write(duration(data));
<span class="line-modified">!   cw.write((jlong)offset_prev_cp_event);</span>
<span class="line-modified">!   cw.write(is_flushpoint(data));</span>
    cw.write(number_of_types(data));
  }
  
  static void write_checkpoint_content(JfrChunkWriter&amp; cw, const u1* data, size_t size) {
    assert(data != NULL, &quot;invariant&quot;);
<span class="line-modified">!   cw.write_unbuffered(data + payload_offset, size);</span>
  }
  
  static size_t write_checkpoint_event(JfrChunkWriter&amp; cw, const u1* data) {
    assert(data != NULL, &quot;invariant&quot;);
<span class="line-modified">!   const intptr_t previous_checkpoint_event = cw.previous_checkpoint_offset();</span>
<span class="line-modified">!   const intptr_t event_begin = cw.current_offset();</span>
<span class="line-modified">!   const intptr_t offset_to_previous_checkpoint_event = 0 == previous_checkpoint_event ? 0 : previous_checkpoint_event - event_begin;</span>
<span class="line-modified">!   const jlong total_checkpoint_size = total_size(data);</span>
<span class="line-modified">!   write_checkpoint_header(cw, offset_to_previous_checkpoint_event, data);</span>
<span class="line-modified">!   write_checkpoint_content(cw, data, total_checkpoint_size - sizeof(JfrCheckpointEntry));</span>
<span class="line-modified">!   const jlong checkpoint_event_size = cw.current_offset() - event_begin;</span>
<span class="line-modified">!   cw.write_padded_at_offset&lt;u4&gt;(checkpoint_event_size, event_begin);</span>
<span class="line-modified">!   cw.set_previous_checkpoint_offset(event_begin);</span>
<span class="line-modified">!   return (size_t)total_checkpoint_size;</span>
  }
  
  static size_t write_checkpoints(JfrChunkWriter&amp; cw, const u1* data, size_t size) {
    assert(cw.is_valid(), &quot;invariant&quot;);
    assert(data != NULL, &quot;invariant&quot;);
    assert(size &gt; 0, &quot;invariant&quot;);
    const u1* const limit = data + size;
<span class="line-modified">!   const u1* next_entry = data;</span>
    size_t processed = 0;
<span class="line-modified">!   while (next_entry &lt; limit) {</span>
<span class="line-modified">!     const size_t checkpoint_size = write_checkpoint_event(cw, next_entry);</span>
      processed += checkpoint_size;
<span class="line-modified">!     next_entry += checkpoint_size;</span>
    }
<span class="line-modified">!   assert(next_entry == limit, &quot;invariant&quot;);</span>
    return processed;
  }
  
  template &lt;typename T&gt;
  class CheckpointWriteOp {
<span class="line-new-header">--- 248,60 ---</span>
  
  static jlong duration(const u1* data) {
    return read_data&lt;jlong&gt;(data + duration_offset);
  }
  
<span class="line-modified">! static u1 checkpoint_type(const u1* data) {</span>
<span class="line-modified">!   return read_data&lt;u1&gt;(data + checkpoint_type_offset);</span>
  }
  
  static juint number_of_types(const u1* data) {
    return read_data&lt;juint&gt;(data + types_offset);
  }
  
<span class="line-modified">! static void write_checkpoint_header(JfrChunkWriter&amp; cw, int64_t delta_to_last_checkpoint, const u1* data) {</span>
    cw.reserve(sizeof(u4));
<span class="line-modified">!   cw.write&lt;u8&gt;(EVENT_CHECKPOINT);</span>
    cw.write(starttime(data));
    cw.write(duration(data));
<span class="line-modified">!   cw.write(delta_to_last_checkpoint);</span>
<span class="line-modified">!   cw.write(checkpoint_type(data));</span>
    cw.write(number_of_types(data));
  }
  
  static void write_checkpoint_content(JfrChunkWriter&amp; cw, const u1* data, size_t size) {
    assert(data != NULL, &quot;invariant&quot;);
<span class="line-modified">!   cw.write_unbuffered(data + payload_offset, size - sizeof(JfrCheckpointEntry));</span>
  }
  
  static size_t write_checkpoint_event(JfrChunkWriter&amp; cw, const u1* data) {
    assert(data != NULL, &quot;invariant&quot;);
<span class="line-modified">!   const int64_t event_begin = cw.current_offset();</span>
<span class="line-modified">!   const int64_t last_checkpoint_event = cw.last_checkpoint_offset();</span>
<span class="line-modified">!   const int64_t delta_to_last_checkpoint = last_checkpoint_event == 0 ? 0 : last_checkpoint_event - event_begin;</span>
<span class="line-modified">!   const int64_t checkpoint_size = total_size(data);</span>
<span class="line-modified">!   write_checkpoint_header(cw, delta_to_last_checkpoint, data);</span>
<span class="line-modified">!   write_checkpoint_content(cw, data, checkpoint_size);</span>
<span class="line-modified">!   const int64_t event_size = cw.current_offset() - event_begin;</span>
<span class="line-modified">!   cw.write_padded_at_offset&lt;u4&gt;(event_size, event_begin);</span>
<span class="line-modified">!   cw.set_last_checkpoint_offset(event_begin);</span>
<span class="line-modified">!   return (size_t)checkpoint_size;</span>
  }
  
  static size_t write_checkpoints(JfrChunkWriter&amp; cw, const u1* data, size_t size) {
    assert(cw.is_valid(), &quot;invariant&quot;);
    assert(data != NULL, &quot;invariant&quot;);
    assert(size &gt; 0, &quot;invariant&quot;);
    const u1* const limit = data + size;
<span class="line-modified">!   const u1* next = data;</span>
    size_t processed = 0;
<span class="line-modified">!   while (next &lt; limit) {</span>
<span class="line-modified">!     const size_t checkpoint_size = write_checkpoint_event(cw, next);</span>
      processed += checkpoint_size;
<span class="line-modified">!     next += checkpoint_size;</span>
    }
<span class="line-modified">!   assert(next == limit, &quot;invariant&quot;);</span>
    return processed;
  }
  
  template &lt;typename T&gt;
  class CheckpointWriteOp {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 313,68 ***</span>
    }
    size_t processed() const { return _processed; }
  };
  
  typedef CheckpointWriteOp&lt;JfrCheckpointMspace::Type&gt; WriteOperation;
<span class="line-removed">- typedef MutexedWriteOp&lt;WriteOperation&gt; MutexedWriteOperation;</span>
  typedef ReleaseOp&lt;JfrCheckpointMspace&gt; CheckpointReleaseOperation;
<span class="line-removed">- typedef CompositeOperation&lt;MutexedWriteOperation, CheckpointReleaseOperation&gt; CheckpointWriteOperation;</span>
  
<span class="line-modified">! static size_t write_mspace_exclusive(JfrCheckpointMspace* mspace, JfrChunkWriter&amp; chunkwriter) {</span>
<span class="line-modified">!   Thread* const thread = Thread::current();</span>
    WriteOperation wo(chunkwriter);
<span class="line-modified">!   MutexedWriteOperation mwo(wo);</span>
<span class="line-modified">!   CheckpointReleaseOperation cro(mspace, thread, false);</span>
<span class="line-modified">!   CheckpointWriteOperation cpwo(&amp;mwo, &amp;cro);</span>
    assert(mspace-&gt;is_full_empty(), &quot;invariant&quot;);
<span class="line-modified">!   process_free_list(cpwo, mspace);</span>
    return wo.processed();
  }
  
  size_t JfrCheckpointManager::write() {
<span class="line-modified">!   const size_t processed = write_mspace_exclusive(_free_list_mspace, _chunkwriter);</span>
<span class="line-modified">!   synchronize_epoch();</span>
    return processed;
  }
  
  size_t JfrCheckpointManager::write_epoch_transition_mspace() {
<span class="line-modified">!   return write_mspace_exclusive(_epoch_transition_mspace, _chunkwriter);</span>
  }
  
  typedef DiscardOp&lt;DefaultDiscarder&lt;JfrBuffer&gt; &gt; DiscardOperation;
  size_t JfrCheckpointManager::clear() {
    DiscardOperation discarder(mutexed); // mutexed discard mode
    process_free_list(discarder, _free_list_mspace);
    process_free_list(discarder, _epoch_transition_mspace);
<span class="line-modified">!   synchronize_epoch();</span>
<span class="line-modified">!   return discarder.processed();</span>
  }
  
<span class="line-modified">! size_t JfrCheckpointManager::write_types() {</span>
<span class="line-modified">!   JfrCheckpointWriter writer(false, true, Thread::current());</span>
<span class="line-modified">!   JfrTypeManager::write_types(writer);</span>
    return writer.used_size();
  }
  
<span class="line-modified">! size_t JfrCheckpointManager::write_safepoint_types() {</span>
<span class="line-modified">!   // this is also a &quot;flushpoint&quot;</span>
<span class="line-modified">!   JfrCheckpointWriter writer(true, true, Thread::current());</span>
<span class="line-modified">!   JfrTypeManager::write_safepoint_types(writer);</span>
    return writer.used_size();
  }
  
  void JfrCheckpointManager::write_type_set() {
<span class="line-modified">!   JfrTypeManager::write_type_set();</span>
  }
  
  void JfrCheckpointManager::write_type_set_for_unloaded_classes() {
    assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
<span class="line-modified">!   JfrTypeManager::write_type_set_for_unloaded_classes();</span>
  }
  
<span class="line-modified">! void JfrCheckpointManager::create_thread_checkpoint(JavaThread* jt) {</span>
<span class="line-modified">!   JfrTypeManager::create_thread_checkpoint(jt);</span>
  }
  
<span class="line-modified">! void JfrCheckpointManager::write_thread_checkpoint(JavaThread* jt) {</span>
<span class="line-modified">!   JfrTypeManager::write_thread_checkpoint(jt);</span>
  }
<span class="line-new-header">--- 317,205 ---</span>
    }
    size_t processed() const { return _processed; }
  };
  
  typedef CheckpointWriteOp&lt;JfrCheckpointMspace::Type&gt; WriteOperation;
  typedef ReleaseOp&lt;JfrCheckpointMspace&gt; CheckpointReleaseOperation;
  
<span class="line-modified">! template &lt;template &lt;typename&gt; class WriterHost, template &lt;typename, typename, typename&gt; class CompositeOperation&gt;</span>
<span class="line-modified">! static size_t write_mspace(JfrCheckpointMspace* mspace, JfrChunkWriter&amp; chunkwriter) {</span>
<span class="line-added">+   assert(mspace != NULL, &quot;invariant&quot;);</span>
    WriteOperation wo(chunkwriter);
<span class="line-modified">!   WriterHost&lt;WriteOperation&gt; wh(wo);</span>
<span class="line-modified">!   CheckpointReleaseOperation cro(mspace, Thread::current(), false);</span>
<span class="line-modified">!   CompositeOperation&lt;WriterHost&lt;WriteOperation&gt;, CheckpointReleaseOperation, CompositeOperationAnd&gt; co(&amp;wh, &amp;cro);</span>
    assert(mspace-&gt;is_full_empty(), &quot;invariant&quot;);
<span class="line-modified">!   process_free_list(co, mspace);</span>
    return wo.processed();
  }
  
<span class="line-added">+ void JfrCheckpointManager::begin_epoch_shift() {</span>
<span class="line-added">+   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);</span>
<span class="line-added">+   JfrTraceIdEpoch::begin_epoch_shift();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JfrCheckpointManager::end_epoch_shift() {</span>
<span class="line-added">+   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);</span>
<span class="line-added">+   debug_only(const u1 current_epoch = JfrTraceIdEpoch::current();)</span>
<span class="line-added">+   JfrTraceIdEpoch::end_epoch_shift();</span>
<span class="line-added">+   assert(current_epoch != JfrTraceIdEpoch::current(), &quot;invariant&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JfrCheckpointManager::synchronize_checkpoint_manager_with_current_epoch() {</span>
<span class="line-added">+   assert(_checkpoint_epoch_state != JfrTraceIdEpoch::epoch(), &quot;invariant&quot;);</span>
<span class="line-added">+   OrderAccess::storestore();</span>
<span class="line-added">+   _checkpoint_epoch_state = JfrTraceIdEpoch::epoch();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  size_t JfrCheckpointManager::write() {
<span class="line-modified">!   const size_t processed = write_mspace&lt;MutexedWriteOp, CompositeOperation&gt;(_free_list_mspace, _chunkwriter);</span>
<span class="line-modified">!   synchronize_checkpoint_manager_with_current_epoch();</span>
    return processed;
  }
  
  size_t JfrCheckpointManager::write_epoch_transition_mspace() {
<span class="line-modified">!   return write_mspace&lt;ExclusiveOp, CompositeOperation&gt;(_epoch_transition_mspace, _chunkwriter);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ typedef MutexedWriteOp&lt;WriteOperation&gt; FlushOperation;</span>
<span class="line-added">+ </span>
<span class="line-added">+ size_t JfrCheckpointManager::flush() {</span>
<span class="line-added">+   WriteOperation wo(_chunkwriter);</span>
<span class="line-added">+   FlushOperation fo(wo);</span>
<span class="line-added">+   assert(_free_list_mspace-&gt;is_full_empty(), &quot;invariant&quot;);</span>
<span class="line-added">+   process_free_list(fo, _free_list_mspace);</span>
<span class="line-added">+   return wo.processed();</span>
  }
  
  typedef DiscardOp&lt;DefaultDiscarder&lt;JfrBuffer&gt; &gt; DiscardOperation;
  size_t JfrCheckpointManager::clear() {
<span class="line-added">+   clear_type_set();</span>
    DiscardOperation discarder(mutexed); // mutexed discard mode
    process_free_list(discarder, _free_list_mspace);
    process_free_list(discarder, _epoch_transition_mspace);
<span class="line-modified">!   synchronize_checkpoint_manager_with_current_epoch();</span>
<span class="line-modified">!   return discarder.elements();</span>
  }
  
<span class="line-modified">! // Optimization for write_static_type_set() and write_threads() is to write</span>
<span class="line-modified">! // directly into the epoch transition mspace because we will immediately</span>
<span class="line-modified">! // serialize and reset this mspace post-write.</span>
<span class="line-added">+ static JfrBuffer* get_epoch_transition_buffer(JfrCheckpointMspace* mspace, Thread* t) {</span>
<span class="line-added">+   assert(mspace != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   JfrBuffer* const buffer = mspace-&gt;free_head();</span>
<span class="line-added">+   assert(buffer != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   buffer-&gt;acquire(t);</span>
<span class="line-added">+   buffer-&gt;set_lease();</span>
<span class="line-added">+   DEBUG_ONLY(assert_free_lease(buffer);)</span>
<span class="line-added">+   return buffer;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool JfrCheckpointManager::is_static_type_set_required() {</span>
<span class="line-added">+   return JfrTypeManager::has_new_static_type();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ size_t JfrCheckpointManager::write_static_type_set() {</span>
<span class="line-added">+   Thread* const t = Thread::current();</span>
<span class="line-added">+   ResourceMark rm(t);</span>
<span class="line-added">+   HandleMark hm(t);</span>
<span class="line-added">+   JfrCheckpointWriter writer(t, get_epoch_transition_buffer(_epoch_transition_mspace, t), STATICS);</span>
<span class="line-added">+   JfrTypeManager::write_static_types(writer);</span>
    return writer.used_size();
  }
  
<span class="line-modified">! size_t JfrCheckpointManager::write_threads() {</span>
<span class="line-modified">!   Thread* const t = Thread::current();</span>
<span class="line-modified">!   ResourceMark rm(t);</span>
<span class="line-modified">!   HandleMark hm(t);</span>
<span class="line-added">+   JfrCheckpointWriter writer(t, get_epoch_transition_buffer(_epoch_transition_mspace, t), THREADS);</span>
<span class="line-added">+   JfrTypeManager::write_threads(writer);</span>
    return writer.used_size();
  }
  
<span class="line-added">+ size_t JfrCheckpointManager::write_static_type_set_and_threads() {</span>
<span class="line-added">+   write_static_type_set();</span>
<span class="line-added">+   write_threads();</span>
<span class="line-added">+   return write_epoch_transition_mspace();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JfrCheckpointManager::on_rotation() {</span>
<span class="line-added">+   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);</span>
<span class="line-added">+   JfrTypeManager::on_rotation();</span>
<span class="line-added">+   notify_threads();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JfrCheckpointManager::clear_type_set() {</span>
<span class="line-added">+   assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);</span>
<span class="line-added">+   assert(!JfrRecorder::is_recording(), &quot;invariant&quot;);</span>
<span class="line-added">+   // can safepoint here</span>
<span class="line-added">+   MutexLocker cld_lock(ClassLoaderDataGraph_lock);</span>
<span class="line-added">+   MutexLocker module_lock(Module_lock);</span>
<span class="line-added">+   JfrTypeSet::clear();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void JfrCheckpointManager::write_type_set() {
<span class="line-modified">!   assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);</span>
<span class="line-added">+   if (LeakProfiler::is_running()) {</span>
<span class="line-added">+     Thread* const t = Thread::current();</span>
<span class="line-added">+     // can safepoint here</span>
<span class="line-added">+     MutexLocker cld_lock(t, ClassLoaderDataGraph_lock);</span>
<span class="line-added">+     MutexLocker module_lock(t, Module_lock);</span>
<span class="line-added">+     JfrCheckpointWriter leakp_writer(t);</span>
<span class="line-added">+     JfrCheckpointWriter writer(t);</span>
<span class="line-added">+     JfrTypeSet::serialize(&amp;writer, &amp;leakp_writer, false, false);</span>
<span class="line-added">+     ObjectSampleCheckpoint::on_type_set(leakp_writer);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     // can safepoint here</span>
<span class="line-added">+     MutexLocker cld_lock(ClassLoaderDataGraph_lock);</span>
<span class="line-added">+     MutexLocker module_lock(Module_lock);</span>
<span class="line-added">+     JfrCheckpointWriter writer(Thread::current());</span>
<span class="line-added">+     JfrTypeSet::serialize(&amp;writer, NULL, false, false);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   write();</span>
  }
  
  void JfrCheckpointManager::write_type_set_for_unloaded_classes() {
    assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
<span class="line-modified">!   JfrCheckpointWriter writer(Thread::current());</span>
<span class="line-added">+   const JfrCheckpointContext ctx = writer.context();</span>
<span class="line-added">+   JfrTypeSet::serialize(&amp;writer, NULL, true, false);</span>
<span class="line-added">+   if (LeakProfiler::is_running()) {</span>
<span class="line-added">+     ObjectSampleCheckpoint::on_type_set_unload(writer);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (!JfrRecorder::is_recording()) {</span>
<span class="line-added">+     // discard by rewind</span>
<span class="line-added">+     writer.set_context(ctx);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool JfrCheckpointManager::is_type_set_required() {</span>
<span class="line-added">+   return JfrTraceIdEpoch::has_changed_tag_state();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ size_t JfrCheckpointManager::flush_type_set() {</span>
<span class="line-added">+   size_t elements = 0;</span>
<span class="line-added">+   {</span>
<span class="line-added">+     JfrCheckpointWriter writer(Thread::current());</span>
<span class="line-added">+     // can safepoint here</span>
<span class="line-added">+     MutexLocker cld_lock(ClassLoaderDataGraph_lock);</span>
<span class="line-added">+     MutexLocker module_lock(Module_lock);</span>
<span class="line-added">+     elements = JfrTypeSet::serialize(&amp;writer, NULL, false, true);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   flush();</span>
<span class="line-added">+   return elements;</span>
  }
  
<span class="line-modified">! void JfrCheckpointManager::flush_static_type_set() {</span>
<span class="line-modified">!   flush();</span>
  }
  
<span class="line-modified">! void JfrCheckpointManager::create_thread_blob(Thread* t) {</span>
<span class="line-modified">!   JfrTypeManager::create_thread_blob(t);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JfrCheckpointManager::write_thread_checkpoint(Thread* t) {</span>
<span class="line-added">+   JfrTypeManager::write_thread_checkpoint(t);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ class JfrNotifyClosure : public ThreadClosure {</span>
<span class="line-added">+  public:</span>
<span class="line-added">+   void do_thread(Thread* t) {</span>
<span class="line-added">+     assert(t != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+     assert(t-&gt;is_Java_thread(), &quot;invariant&quot;);</span>
<span class="line-added">+     assert_locked_or_safepoint(Threads_lock);</span>
<span class="line-added">+     JfrJavaEventWriter::notify((JavaThread*)t);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JfrCheckpointManager::notify_threads() {</span>
<span class="line-added">+   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);</span>
<span class="line-added">+   JfrNotifyClosure tc;</span>
<span class="line-added">+   JfrJavaThreadIterator iter;</span>
<span class="line-added">+   while (iter.has_next()) {</span>
<span class="line-added">+     tc.do_thread(iter.next());</span>
<span class="line-added">+   }</span>
  }
</pre>
<center><a href="../../periodic/sampling/jfrThreadSampler.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrCheckpointManager.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
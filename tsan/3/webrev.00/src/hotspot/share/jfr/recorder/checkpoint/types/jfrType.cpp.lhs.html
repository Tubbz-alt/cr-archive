<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jfr/recorder/checkpoint/types/jfrType.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/javaClasses.inline.hpp&quot;
 27 #include &quot;code/codeBlob.hpp&quot;
 28 #include &quot;code/codeCache.hpp&quot;
<a name="2" id="anc2"></a>
 29 #include &quot;gc/shared/gcCause.hpp&quot;
 30 #include &quot;gc/shared/gcName.hpp&quot;
 31 #include &quot;gc/shared/gcTrace.hpp&quot;
 32 #include &quot;gc/shared/gcWhen.hpp&quot;
<a name="3" id="anc3"></a><span class="line-removed"> 33 #include &quot;jfr/leakprofiler/checkpoint/objectSampleCheckpoint.hpp&quot;</span>
 34 #include &quot;jfr/leakprofiler/leakProfiler.hpp&quot;
<a name="4" id="anc4"></a><span class="line-modified"> 35 #include &quot;jfr/recorder/checkpoint/jfrCheckpointManager.hpp&quot;</span>
 36 #include &quot;jfr/recorder/checkpoint/types/jfrType.hpp&quot;
 37 #include &quot;jfr/recorder/jfrRecorder.hpp&quot;
 38 #include &quot;jfr/recorder/checkpoint/types/jfrThreadGroup.hpp&quot;
 39 #include &quot;jfr/recorder/checkpoint/types/jfrThreadState.hpp&quot;
<a name="5" id="anc5"></a><span class="line-removed"> 40 #include &quot;jfr/recorder/checkpoint/types/jfrTypeSet.hpp&quot;</span>
 41 #include &quot;jfr/support/jfrThreadLocal.hpp&quot;
 42 #include &quot;jfr/writers/jfrJavaEventWriter.hpp&quot;
<a name="6" id="anc6"></a>

 43 #include &quot;memory/metaspaceGCThresholdUpdater.hpp&quot;
 44 #include &quot;memory/referenceType.hpp&quot;
 45 #include &quot;memory/universe.hpp&quot;
<a name="7" id="anc7"></a>
 46 #include &quot;runtime/flags/jvmFlag.hpp&quot;
 47 #include &quot;runtime/mutexLocker.hpp&quot;
 48 #include &quot;runtime/osThread.hpp&quot;
 49 #include &quot;runtime/safepoint.hpp&quot;
 50 #include &quot;runtime/synchronizer.hpp&quot;
 51 #include &quot;runtime/thread.inline.hpp&quot;
 52 #include &quot;runtime/vmOperations.hpp&quot;
 53 
 54 #ifdef COMPILER2
 55 #include &quot;opto/compile.hpp&quot;
 56 #include &quot;opto/node.hpp&quot;
 57 #endif
<a name="8" id="anc8"></a><span class="line-removed"> 58 #if INCLUDE_G1GC</span>
<span class="line-removed"> 59 #include &quot;gc/g1/g1HeapRegionTraceType.hpp&quot;</span>
<span class="line-removed"> 60 #include &quot;gc/g1/g1YCTypes.hpp&quot;</span>
<span class="line-removed"> 61 #endif</span>
 62 
 63 // Requires a ResourceMark for get_thread_name/as_utf8
 64 class JfrCheckpointThreadClosure : public ThreadClosure {
 65  private:
 66   JfrCheckpointWriter&amp; _writer;
 67   JfrCheckpointContext _ctx;
 68   const int64_t _count_position;
 69   Thread* const _curthread;
 70   u4 _count;
 71 
 72  public:
 73   JfrCheckpointThreadClosure(JfrCheckpointWriter&amp; writer) : _writer(writer),
 74                                                             _ctx(writer.context()),
 75                                                             _count_position(writer.reserve(sizeof(u4))),
 76                                                             _curthread(Thread::current()),
 77                                                             _count(0) {
 78   }
 79 
 80   ~JfrCheckpointThreadClosure() {
 81     if (_count == 0) {
 82       // restore
 83       _writer.set_context(_ctx);
 84       return;
 85     }
 86     _writer.write_count(_count, _count_position);
 87   }
 88 
 89   void do_thread(Thread* t);
 90 };
 91 
<a name="9" id="anc9"></a><span class="line-removed"> 92 // Requires a ResourceMark for get_thread_name/as_utf8</span>
 93 void JfrCheckpointThreadClosure::do_thread(Thread* t) {
 94   assert(t != NULL, &quot;invariant&quot;);
<a name="10" id="anc10"></a><span class="line-removed"> 95   assert_locked_or_safepoint(Threads_lock);</span>
<span class="line-removed"> 96   const JfrThreadLocal* const tl = t-&gt;jfr_thread_local();</span>
<span class="line-removed"> 97   assert(tl != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 98   if (tl-&gt;is_dead()) {</span>
<span class="line-removed"> 99     return;</span>
<span class="line-removed">100   }</span>
101   ++_count;
<a name="11" id="anc11"></a><span class="line-modified">102   _writer.write_key(tl-&gt;thread_id());</span>
<span class="line-modified">103   _writer.write(t-&gt;name());</span>
<span class="line-modified">104   const OSThread* const os_thread = t-&gt;osthread();</span>
<span class="line-modified">105   _writer.write&lt;traceid&gt;(os_thread != NULL ? os_thread-&gt;thread_id() : 0);</span>

106   if (t-&gt;is_Java_thread()) {
<a name="12" id="anc12"></a><span class="line-modified">107     JavaThread* const jt = (JavaThread*)t;</span>
<span class="line-modified">108     _writer.write(jt-&gt;name());</span>
<span class="line-modified">109     _writer.write(java_lang_Thread::thread_id(jt-&gt;threadObj()));</span>
<span class="line-removed">110     _writer.write(JfrThreadGroup::thread_group_id(jt, _curthread));</span>
<span class="line-removed">111     // since we are iterating threads during a safepoint, also issue notification</span>
<span class="line-removed">112     JfrJavaEventWriter::notify(jt);</span>
113     return;
114   }
115   _writer.write((const char*)NULL); // java name
116   _writer.write((traceid)0); // java thread id
117   _writer.write((traceid)0); // java thread group
118 }
119 
120 void JfrThreadConstantSet::serialize(JfrCheckpointWriter&amp; writer) {
<a name="13" id="anc13"></a><span class="line-removed">121   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);</span>
122   JfrCheckpointThreadClosure tc(writer);
<a name="14" id="anc14"></a><span class="line-modified">123   Threads::threads_do(&amp;tc);</span>







124 }
125 
126 void JfrThreadGroupConstant::serialize(JfrCheckpointWriter&amp; writer) {
<a name="15" id="anc15"></a><span class="line-removed">127   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);</span>
128   JfrThreadGroup::serialize(writer);
129 }
130 
131 static const char* flag_value_origin_to_string(JVMFlag::Flags origin) {
132   switch (origin) {
133     case JVMFlag::DEFAULT: return &quot;Default&quot;;
134     case JVMFlag::COMMAND_LINE: return &quot;Command line&quot;;
135     case JVMFlag::ENVIRON_VAR: return &quot;Environment variable&quot;;
136     case JVMFlag::CONFIG_FILE: return &quot;Config file&quot;;
137     case JVMFlag::MANAGEMENT: return &quot;Management&quot;;
138     case JVMFlag::ERGONOMIC: return &quot;Ergonomic&quot;;
139     case JVMFlag::ATTACH_ON_DEMAND: return &quot;Attach on demand&quot;;
140     case JVMFlag::INTERNAL: return &quot;Internal&quot;;
<a name="16" id="anc16"></a>
141     default: ShouldNotReachHere(); return &quot;&quot;;
142   }
143 }
144 
145 void FlagValueOriginConstant::serialize(JfrCheckpointWriter&amp; writer) {
146   static const u4 nof_entries = JVMFlag::LAST_VALUE_ORIGIN + 1;
147   writer.write_count(nof_entries);
148   for (u4 i = 0; i &lt; nof_entries; ++i) {
149     writer.write_key(i);
150     writer.write(flag_value_origin_to_string((JVMFlag::Flags)i));
151   }
152 }
153 
154 void MonitorInflateCauseConstant::serialize(JfrCheckpointWriter&amp; writer) {
155   static const u4 nof_entries = ObjectSynchronizer::inflate_cause_nof;
156   writer.write_count(nof_entries);
157   for (u4 i = 0; i &lt; nof_entries; ++i) {
158     writer.write_key(i);
159     writer.write(ObjectSynchronizer::inflate_cause_name((ObjectSynchronizer::InflateCause)i));
160   }
161 }
162 
163 void GCCauseConstant::serialize(JfrCheckpointWriter&amp; writer) {
164   static const u4 nof_entries = GCCause::_last_gc_cause;
165   writer.write_count(nof_entries);
166   for (u4 i = 0; i &lt; nof_entries; ++i) {
167     writer.write_key(i);
168     writer.write(GCCause::to_string((GCCause::Cause)i));
169   }
170 }
171 
172 void GCNameConstant::serialize(JfrCheckpointWriter&amp; writer) {
173   static const u4 nof_entries = GCNameEndSentinel;
174   writer.write_count(nof_entries);
175   for (u4 i = 0; i &lt; nof_entries; ++i) {
176     writer.write_key(i);
177     writer.write(GCNameHelper::to_string((GCName)i));
178   }
179 }
180 
181 void GCWhenConstant::serialize(JfrCheckpointWriter&amp; writer) {
182   static const u4 nof_entries = GCWhen::GCWhenEndSentinel;
183   writer.write_count(nof_entries);
184   for (u4 i = 0; i &lt; nof_entries; ++i) {
185     writer.write_key(i);
186     writer.write(GCWhen::to_string((GCWhen::Type)i));
187   }
188 }
189 
<a name="17" id="anc17"></a><span class="line-removed">190 void G1HeapRegionTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-removed">191   static const u4 nof_entries = G1HeapRegionTraceType::G1HeapRegionTypeEndSentinel;</span>
<span class="line-removed">192   writer.write_count(nof_entries);</span>
<span class="line-removed">193   for (u4 i = 0; i &lt; nof_entries; ++i) {</span>
<span class="line-removed">194     writer.write_key(i);</span>
<span class="line-removed">195     writer.write(G1HeapRegionTraceType::to_string((G1HeapRegionTraceType::Type)i));</span>
<span class="line-removed">196   }</span>
<span class="line-removed">197 }</span>
<span class="line-removed">198 </span>
199 void GCThresholdUpdaterConstant::serialize(JfrCheckpointWriter&amp; writer) {
200   static const u4 nof_entries = MetaspaceGCThresholdUpdater::Last;
201   writer.write_count(nof_entries);
202   for (u4 i = 0; i &lt; nof_entries; ++i) {
203     writer.write_key(i);
204     writer.write(MetaspaceGCThresholdUpdater::to_string((MetaspaceGCThresholdUpdater::Type)i));
205   }
206 }
207 
208 void MetadataTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
209   static const u4 nof_entries = Metaspace::MetadataTypeCount;
210   writer.write_count(nof_entries);
211   for (u4 i = 0; i &lt; nof_entries; ++i) {
212     writer.write_key(i);
213     writer.write(Metaspace::metadata_type_name((Metaspace::MetadataType)i));
214   }
215 }
216 
217 void MetaspaceObjectTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
218   static const u4 nof_entries = MetaspaceObj::_number_of_types;
219   writer.write_count(nof_entries);
220   for (u4 i = 0; i &lt; nof_entries; ++i) {
221     writer.write_key(i);
222     writer.write(MetaspaceObj::type_name((MetaspaceObj::Type)i));
223   }
224 }
225 
<a name="18" id="anc18"></a><span class="line-removed">226 void G1YCTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-removed">227 #if INCLUDE_G1GC</span>
<span class="line-removed">228   static const u4 nof_entries = G1YCTypeEndSentinel;</span>
<span class="line-removed">229   writer.write_count(nof_entries);</span>
<span class="line-removed">230   for (u4 i = 0; i &lt; nof_entries; ++i) {</span>
<span class="line-removed">231     writer.write_key(i);</span>
<span class="line-removed">232     writer.write(G1YCTypeHelper::to_string((G1YCType)i));</span>
<span class="line-removed">233   }</span>
<span class="line-removed">234 #endif</span>
<span class="line-removed">235 }</span>
<span class="line-removed">236 </span>
237 static const char* reference_type_to_string(ReferenceType rt) {
238   switch (rt) {
239     case REF_NONE: return &quot;None reference&quot;;
240     case REF_OTHER: return &quot;Other reference&quot;;
241     case REF_SOFT: return &quot;Soft reference&quot;;
242     case REF_WEAK: return &quot;Weak reference&quot;;
243     case REF_FINAL: return &quot;Final reference&quot;;
244     case REF_PHANTOM: return &quot;Phantom reference&quot;;
245     default:
246       ShouldNotReachHere();
247     return NULL;
248   }
249 }
250 
251 void ReferenceTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
252   static const u4 nof_entries = REF_PHANTOM + 1;
253   writer.write_count(nof_entries);
254   for (u4 i = 0; i &lt; nof_entries; ++i) {
255     writer.write_key(i);
256     writer.write(reference_type_to_string((ReferenceType)i));
257   }
258 }
259 
260 void NarrowOopModeConstant::serialize(JfrCheckpointWriter&amp; writer) {
<a name="19" id="anc19"></a><span class="line-modified">261   static const u4 nof_entries = Universe::HeapBasedNarrowOop + 1;</span>
262   writer.write_count(nof_entries);
263   for (u4 i = 0; i &lt; nof_entries; ++i) {
264     writer.write_key(i);
<a name="20" id="anc20"></a><span class="line-modified">265     writer.write(Universe::narrow_oop_mode_to_string((Universe::NARROW_OOP_MODE)i));</span>
266   }
267 }
268 
269 void CompilerPhaseTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
270 #ifdef COMPILER2
271   static const u4 nof_entries = PHASE_NUM_TYPES;
272   writer.write_count(nof_entries);
273   for (u4 i = 0; i &lt; nof_entries; ++i) {
274     writer.write_key(i);
275     writer.write(CompilerPhaseTypeHelper::to_string((CompilerPhaseType)i));
276   }
277 #endif
278 }
279 
280 void CodeBlobTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
281   static const u4 nof_entries = CodeBlobType::NumTypes;
282   writer.write_count(nof_entries);
283   for (u4 i = 0; i &lt; nof_entries; ++i) {
284     writer.write_key(i);
285     writer.write(CodeCache::get_code_heap_name(i));
286   }
287 };
288 
289 void VMOperationTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
290   static const u4 nof_entries = VM_Operation::VMOp_Terminating;
291   writer.write_count(nof_entries);
292   for (u4 i = 0; i &lt; nof_entries; ++i) {
293     writer.write_key(i);
294     writer.write(VM_Operation::name(VM_Operation::VMOp_Type(i)));
295   }
296 }
297 
<a name="21" id="anc21"></a><span class="line-removed">298 class TypeSetSerialization {</span>
<span class="line-removed">299  private:</span>
<span class="line-removed">300   bool _class_unload;</span>
<span class="line-removed">301  public:</span>
<span class="line-removed">302   explicit TypeSetSerialization(bool class_unload) : _class_unload(class_unload) {}</span>
<span class="line-removed">303   void write(JfrCheckpointWriter&amp; writer, JfrCheckpointWriter* leakp_writer) {</span>
<span class="line-removed">304     JfrTypeSet::serialize(&amp;writer, leakp_writer, _class_unload);</span>
<span class="line-removed">305   }</span>
<span class="line-removed">306 };</span>
<span class="line-removed">307 </span>
<span class="line-removed">308 void ClassUnloadTypeSet::serialize(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-removed">309   TypeSetSerialization type_set(true);</span>
<span class="line-removed">310   if (LeakProfiler::is_running()) {</span>
<span class="line-removed">311     JfrCheckpointWriter leakp_writer(false, true, Thread::current());</span>
<span class="line-removed">312     type_set.write(writer, &amp;leakp_writer);</span>
<span class="line-removed">313     ObjectSampleCheckpoint::install(leakp_writer, true, true);</span>
<span class="line-removed">314     return;</span>
<span class="line-removed">315   }</span>
<span class="line-removed">316   type_set.write(writer, NULL);</span>
<span class="line-removed">317 };</span>
<span class="line-removed">318 </span>
<span class="line-removed">319 void TypeSet::serialize(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-removed">320   TypeSetSerialization type_set(false);</span>
<span class="line-removed">321   if (LeakProfiler::is_suspended()) {</span>
<span class="line-removed">322     JfrCheckpointWriter leakp_writer(false, true, Thread::current());</span>
<span class="line-removed">323     type_set.write(writer, &amp;leakp_writer);</span>
<span class="line-removed">324     ObjectSampleCheckpoint::install(leakp_writer, false, true);</span>
<span class="line-removed">325     return;</span>
<span class="line-removed">326   }</span>
<span class="line-removed">327   type_set.write(writer, NULL);</span>
<span class="line-removed">328 };</span>
<span class="line-removed">329 </span>
330 void ThreadStateConstant::serialize(JfrCheckpointWriter&amp; writer) {
331   JfrThreadState::serialize(writer);
332 }
333 
334 void JfrThreadConstant::serialize(JfrCheckpointWriter&amp; writer) {
335   assert(_thread != NULL, &quot;invariant&quot;);
336   assert(_thread == Thread::current(), &quot;invariant&quot;);
<a name="22" id="anc22"></a><span class="line-removed">337   assert(_thread-&gt;is_Java_thread(), &quot;invariant&quot;);</span>
<span class="line-removed">338   assert(!_thread-&gt;jfr_thread_local()-&gt;has_thread_checkpoint(), &quot;invariant&quot;);</span>
<span class="line-removed">339   ResourceMark rm(_thread);</span>
<span class="line-removed">340   const oop threadObj = _thread-&gt;threadObj();</span>
<span class="line-removed">341   assert(threadObj != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">342   const u8 java_lang_thread_id = java_lang_Thread::thread_id(threadObj);</span>
<span class="line-removed">343   const char* const thread_name = _thread-&gt;name();</span>
<span class="line-removed">344   const traceid thread_group_id = JfrThreadGroup::thread_group_id(_thread);</span>
345   writer.write_count(1);
<a name="23" id="anc23"></a><span class="line-modified">346   writer.write_key(_thread-&gt;jfr_thread_local()-&gt;thread_id());</span>
<span class="line-modified">347   writer.write(thread_name);</span>
<span class="line-modified">348   writer.write((traceid)_thread-&gt;osthread()-&gt;thread_id());</span>
<span class="line-modified">349   writer.write(thread_name);</span>
<span class="line-modified">350   writer.write(java_lang_thread_id);</span>
<span class="line-modified">351   writer.write(thread_group_id);</span>
<span class="line-modified">352   JfrThreadGroup::serialize(&amp;writer, thread_group_id);</span>



























353 }
<a name="24" id="anc24"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="24" type="hidden" />
</body>
</html>
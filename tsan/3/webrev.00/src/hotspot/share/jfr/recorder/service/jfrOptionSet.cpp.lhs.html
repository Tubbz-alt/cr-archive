<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jfr/recorder/service/jfrOptionSet.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/dcmd/jfrDcmds.hpp&quot;
 27 #include &quot;jfr/recorder/service/jfrMemorySizer.hpp&quot;
 28 #include &quot;jfr/recorder/service/jfrOptionSet.hpp&quot;
 29 #include &quot;jfr/utilities/jfrAllocation.hpp&quot;
<a name="2" id="anc2"></a>
 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;memory/allocation.inline.hpp&quot;
 32 #include &quot;memory/resourceArea.hpp&quot;
 33 #include &quot;runtime/java.hpp&quot;
 34 #include &quot;runtime/thread.inline.hpp&quot;
 35 #include &quot;services/diagnosticArgument.hpp&quot;
 36 #include &quot;services/diagnosticFramework.hpp&quot;
 37 #include &quot;utilities/growableArray.hpp&quot;
 38 #include &quot;utilities/ostream.hpp&quot;
 39 
 40 struct ObsoleteOption {
 41   const char* name;
 42   const char* message;
 43 };
 44 
 45 static const ObsoleteOption OBSOLETE_OPTIONS[] = {
 46   {&quot;checkpointbuffersize&quot;, &quot;&quot;},
 47   {&quot;maxsize&quot;,              &quot;Use -XX:StartFlightRecording=maxsize=... instead.&quot;},
 48   {&quot;maxage&quot;,               &quot;Use -XX:StartFlightRecording=maxage=... instead.&quot;},
 49   {&quot;settings&quot;,             &quot;Use -XX:StartFlightRecording=settings=... instead.&quot;},
 50   {&quot;defaultrecording&quot;,     &quot;Use -XX:StartFlightRecording=disk=false to create an in-memory recording.&quot;},
 51   {&quot;disk&quot;,                 &quot;Use -XX:StartFlightRecording=disk=... instead.&quot;},
 52   {&quot;dumponexit&quot;,           &quot;Use -XX:StartFlightRecording=dumponexit=... instead.&quot;},
 53   {&quot;dumponexitpath&quot;,       &quot;Use -XX:StartFlightRecording=filename=... instead.&quot;},
 54   {&quot;loglevel&quot;,             &quot;Use -Xlog:jfr=... instead.&quot;}
 55 };
 56 
 57 jlong JfrOptionSet::max_chunk_size() {
 58   return _max_chunk_size;
 59 }
 60 
 61 void JfrOptionSet::set_max_chunk_size(jlong value) {
 62   _max_chunk_size = value;
 63 }
 64 
 65 jlong JfrOptionSet::global_buffer_size() {
 66   return _global_buffer_size;
 67 }
 68 
 69 void JfrOptionSet::set_global_buffer_size(jlong value) {
 70   _global_buffer_size = value;
 71 }
 72 
 73 jlong JfrOptionSet::thread_buffer_size() {
 74   return _thread_buffer_size;
 75 }
 76 
 77 void JfrOptionSet::set_thread_buffer_size(jlong value) {
 78   _thread_buffer_size = value;
 79 }
 80 
 81 jlong JfrOptionSet::memory_size() {
 82   return _memory_size;
 83 }
 84 
 85 void JfrOptionSet::set_memory_size(jlong value) {
 86   _memory_size = value;
 87 }
 88 
 89 jlong JfrOptionSet::num_global_buffers() {
 90   return _num_global_buffers;
 91 }
 92 
 93 void JfrOptionSet::set_num_global_buffers(jlong value) {
 94   _num_global_buffers = value;
 95 }
 96 
 97 jint JfrOptionSet::old_object_queue_size() {
 98   return (jint)_old_object_queue_size;
 99 }
100 
101 void JfrOptionSet::set_old_object_queue_size(jlong value) {
102   _old_object_queue_size = value;
103 }
104 
105 u4 JfrOptionSet::stackdepth() {
106   return _stack_depth;
107 }
108 
<a name="3" id="anc3"></a><span class="line-removed">109 static const u4 STACK_DEPTH_DEFAULT = 64;</span>
<span class="line-removed">110 static const u4 MIN_STACK_DEPTH = 1;</span>
<span class="line-removed">111 static const u4 MAX_STACK_DEPTH = 2048;</span>
<span class="line-removed">112 </span>
113 void JfrOptionSet::set_stackdepth(u4 depth) {
114   if (depth &lt; MIN_STACK_DEPTH) {
115     _stack_depth = MIN_STACK_DEPTH;
116   } else if (depth &gt; MAX_STACK_DEPTH) {
117     _stack_depth = MAX_STACK_DEPTH;
118   } else {
119     _stack_depth = depth;
120   }
121 }
122 
123 bool JfrOptionSet::sample_threads() {
124   return _sample_threads == JNI_TRUE;
125 }
126 
127 void JfrOptionSet::set_sample_threads(jboolean sample) {
128   _sample_threads = sample;
129 }
130 
131 bool JfrOptionSet::can_retransform() {
132   return _retransform == JNI_TRUE;
133 }
134 
135 void JfrOptionSet::set_retransform(jboolean value) {
136   _retransform = value;
137 }
138 
139 bool JfrOptionSet::sample_protection() {
140   return _sample_protection == JNI_TRUE;
141 }
142 
143 #ifdef ASSERT
144 void JfrOptionSet::set_sample_protection(jboolean protection) {
145   _sample_protection = protection;
146 }
147 #endif
148 
149 bool JfrOptionSet::compressed_integers() {
150   // Set this to false for debugging purposes.
151   return true;
152 }
153 
154 bool JfrOptionSet::allow_retransforms() {
155 #if INCLUDE_JVMTI
156   return true;
157 #else
158   return false;
159 #endif
160 }
161 
162 bool JfrOptionSet::allow_event_retransforms() {
163   return allow_retransforms() &amp;&amp; (DumpSharedSpaces || can_retransform());
164 }
165 
166 // default options for the dcmd parser
167 const char* const default_repository = NULL;
168 const char* const default_global_buffer_size = &quot;512k&quot;;
169 const char* const default_num_global_buffers = &quot;20&quot;;
170 const char* const default_memory_size = &quot;10m&quot;;
171 const char* const default_thread_buffer_size = &quot;8k&quot;;
172 const char* const default_max_chunk_size = &quot;12m&quot;;
173 const char* const default_sample_threads = &quot;true&quot;;
174 const char* const default_stack_depth = &quot;64&quot;;
175 const char* const default_retransform = &quot;true&quot;;
176 const char* const default_old_object_queue_size = &quot;256&quot;;
177 DEBUG_ONLY(const char* const default_sample_protection = &quot;false&quot;;)
178 
179 // statics
180 static DCmdArgument&lt;char*&gt; _dcmd_repository(
181   &quot;repository&quot;,
182   &quot;Flight recorder disk repository location&quot;,
183   &quot;STRING&quot;,
184   false,
185   default_repository);
186 
187 static DCmdArgument&lt;MemorySizeArgument&gt; _dcmd_threadbuffersize(
188   &quot;threadbuffersize&quot;,
189   &quot;Thread buffer size&quot;,
190   &quot;MEMORY SIZE&quot;,
191   false,
192   default_thread_buffer_size);
193 
194 static DCmdArgument&lt;MemorySizeArgument&gt; _dcmd_memorysize(
195   &quot;memorysize&quot;,
196   &quot;Size of memory to be used by Flight Recorder&quot;,
197   &quot;MEMORY SIZE&quot;,
198   false,
199   default_memory_size);
200 
201 static DCmdArgument&lt;MemorySizeArgument&gt; _dcmd_globalbuffersize(
202   &quot;globalbuffersize&quot;,
203   &quot;Global buffer size&quot;,
204   &quot;MEMORY SIZE&quot;,
205   false,
206   default_global_buffer_size);
207 
208 static DCmdArgument&lt;jlong&gt; _dcmd_numglobalbuffers(
209   &quot;numglobalbuffers&quot;,
210   &quot;Number of global buffers&quot;,
211   &quot;JULONG&quot;,
212   false,
213   default_num_global_buffers);
214 
215 static DCmdArgument&lt;MemorySizeArgument&gt; _dcmd_maxchunksize(
216   &quot;maxchunksize&quot;,
217   &quot;Maximum size of a single repository disk chunk&quot;,
218   &quot;MEMORY SIZE&quot;,
219   false,
220   default_max_chunk_size);
221 
222 static DCmdArgument&lt;jlong&gt; _dcmd_old_object_queue_size (
223   &quot;old-object-queue-size&quot;,
224   &quot;Maximum number of old objects to track&quot;,
225   &quot;JINT&quot;,
226   false,
227   default_old_object_queue_size);
228 
229 static DCmdArgument&lt;bool&gt; _dcmd_sample_threads(
230   &quot;samplethreads&quot;,
231   &quot;Thread sampling enable / disable (only sampling when event enabled and sampling enabled)&quot;,
232   &quot;BOOLEAN&quot;,
233   false,
234   default_sample_threads);
235 
236 #ifdef ASSERT
237 static DCmdArgument&lt;bool&gt; _dcmd_sample_protection(
238   &quot;sampleprotection&quot;,
239   &quot;Safeguard for stackwalking while sampling threads (false by default)&quot;,
240   &quot;BOOLEAN&quot;,
241   false,
242   default_sample_protection);
243 #endif
244 
245 static DCmdArgument&lt;jlong&gt; _dcmd_stackdepth(
246   &quot;stackdepth&quot;,
247   &quot;Stack depth for stacktraces (minimum 1, maximum 2048)&quot;,
248   &quot;JULONG&quot;,
249   false,
250   default_stack_depth);
251 
252 static DCmdArgument&lt;bool&gt; _dcmd_retransform(
253   &quot;retransform&quot;,
254   &quot;If event classes should be instrumented using JVMTI (by default true)&quot;,
255   &quot;BOOLEAN&quot;,
256   true,
257   default_retransform);
258 
259 static DCmdParser _parser;
260 
261 static void register_parser_options() {
262   _parser.add_dcmd_option(&amp;_dcmd_repository);
263   _parser.add_dcmd_option(&amp;_dcmd_threadbuffersize);
264   _parser.add_dcmd_option(&amp;_dcmd_memorysize);
265   _parser.add_dcmd_option(&amp;_dcmd_globalbuffersize);
266   _parser.add_dcmd_option(&amp;_dcmd_numglobalbuffers);
267   _parser.add_dcmd_option(&amp;_dcmd_maxchunksize);
268   _parser.add_dcmd_option(&amp;_dcmd_stackdepth);
269   _parser.add_dcmd_option(&amp;_dcmd_sample_threads);
270   _parser.add_dcmd_option(&amp;_dcmd_retransform);
271   _parser.add_dcmd_option(&amp;_dcmd_old_object_queue_size);
272   DEBUG_ONLY(_parser.add_dcmd_option(&amp;_dcmd_sample_protection);)
273 }
274 
275 static bool parse_flight_recorder_options_internal(TRAPS) {
276   if (FlightRecorderOptions == NULL) {
277     return true;
278   }
279   const size_t length = strlen((const char*)FlightRecorderOptions);
280   CmdLine cmdline((const char*)FlightRecorderOptions, length, true);
281   _parser.parse(&amp;cmdline, &#39;,&#39;, THREAD);
282   if (HAS_PENDING_EXCEPTION) {
283     for (int index = 0; index &lt; 9; index++) {
284       ObsoleteOption option = OBSOLETE_OPTIONS[index];
285       const char* p = strstr((const char*)FlightRecorderOptions, option.name);
286       const size_t option_length = strlen(option.name);
287       if (p != NULL &amp;&amp; p[option_length] == &#39;=&#39;) {
288         log_error(arguments) (&quot;-XX:FlightRecorderOptions=%s=... has been removed. %s&quot;, option.name, option.message);
289         return false;
290       }
291     }
292     ResourceMark rm(THREAD);
293     oop message = java_lang_Throwable::message(PENDING_EXCEPTION);
294     if (message != NULL) {
295       const char* msg = java_lang_String::as_utf8_string(message);
296       log_error(arguments) (&quot;%s&quot;, msg);
297     }
298     CLEAR_PENDING_EXCEPTION;
299     return false;
300   }
301   return true;
302 }
303 
304 jlong JfrOptionSet::_max_chunk_size = 0;
305 jlong JfrOptionSet::_global_buffer_size = 0;
306 jlong JfrOptionSet::_thread_buffer_size = 0;
307 jlong JfrOptionSet::_memory_size = 0;
308 jlong JfrOptionSet::_num_global_buffers = 0;
309 jlong JfrOptionSet::_old_object_queue_size = 0;
310 u4 JfrOptionSet::_stack_depth = STACK_DEPTH_DEFAULT;
311 jboolean JfrOptionSet::_sample_threads = JNI_TRUE;
312 jboolean JfrOptionSet::_retransform = JNI_TRUE;
313 #ifdef ASSERT
314 jboolean JfrOptionSet::_sample_protection = JNI_FALSE;
315 #else
316 jboolean JfrOptionSet::_sample_protection = JNI_TRUE;
317 #endif
318 
319 bool JfrOptionSet::initialize(Thread* thread) {
320   register_parser_options();
321   if (!parse_flight_recorder_options_internal(thread)) {
322     return false;
323   }
324   if (_dcmd_retransform.is_set()) {
325     set_retransform(_dcmd_retransform.value());
326   }
327   set_old_object_queue_size(_dcmd_old_object_queue_size.value());
328   return adjust_memory_options();
329 }
330 
331 bool JfrOptionSet::configure(TRAPS) {
332   if (FlightRecorderOptions == NULL) {
333     return true;
334   }
335   ResourceMark rm(THREAD);
336   bufferedStream st;
337   // delegate to DCmd execution
338   JfrConfigureFlightRecorderDCmd configure(&amp;st, false);
339   configure._repository_path.set_is_set(_dcmd_repository.is_set());
340   char* repo = _dcmd_repository.value();
341   if (repo != NULL) {
342     const size_t len = strlen(repo);
343     char* repo_copy = JfrCHeapObj::new_array&lt;char&gt;(len + 1);
344     if (NULL == repo_copy) {
345       return false;
346     }
347     strncpy(repo_copy, repo, len + 1);
348     configure._repository_path.set_value(repo_copy);
349   }
350 
351   configure._stack_depth.set_is_set(_dcmd_stackdepth.is_set());
352   configure._stack_depth.set_value(_dcmd_stackdepth.value());
353 
354   configure._thread_buffer_size.set_is_set(_dcmd_threadbuffersize.is_set());
355   configure._thread_buffer_size.set_value(_dcmd_threadbuffersize.value());
356 
357   configure._global_buffer_count.set_is_set(_dcmd_numglobalbuffers.is_set());
358   configure._global_buffer_count.set_value(_dcmd_numglobalbuffers.value());
359 
360   configure._global_buffer_size.set_is_set(_dcmd_globalbuffersize.is_set());
361   configure._global_buffer_size.set_value(_dcmd_globalbuffersize.value());
362 
363   configure._max_chunk_size.set_is_set(_dcmd_maxchunksize.is_set());
364   configure._max_chunk_size.set_value(_dcmd_maxchunksize.value());
365 
366   configure._memory_size.set_is_set(_dcmd_memorysize.is_set());
367   configure._memory_size.set_value(_dcmd_memorysize.value());
368 
369   configure._sample_threads.set_is_set(_dcmd_sample_threads.is_set());
370   configure._sample_threads.set_value(_dcmd_sample_threads.value());
371 
372   configure.execute(DCmd_Source_Internal, THREAD);
373 
374   if (HAS_PENDING_EXCEPTION) {
375     java_lang_Throwable::print(PENDING_EXCEPTION, tty);
376     CLEAR_PENDING_EXCEPTION;
377     return false;
378   }
379   return true;
380 }
381 
382 template &lt;typename Argument&gt;
383 static julong divide_with_user_unit(Argument&amp; memory_argument, julong value) {
384   if (memory_argument.value()._size != memory_argument.value()._val) {
385     switch (memory_argument.value()._multiplier) {
386     case &#39;k&#39;: case &#39;K&#39;:
387       return value / K;
388     case &#39;m&#39;: case &#39;M&#39;:
389       return value / M;
390     case &#39;g&#39;: case &#39;G&#39;:
391       return value / G;
392     }
393   }
394   return value;
395 }
396 
397 template &lt;typename Argument&gt;
398 static void log_lower_than_min_value(Argument&amp; memory_argument, julong min_value) {
399   if (memory_argument.value()._size != memory_argument.value()._val) {
400     // has multiplier
401     log_error(arguments) (
402       &quot;This value is lower than the minimum size required &quot; JULONG_FORMAT &quot;%c&quot;,
403       divide_with_user_unit(memory_argument, min_value),
404       memory_argument.value()._multiplier);
405     return;
406   }
407   log_error(arguments) (
408     &quot;This value is lower than the minimum size required &quot; JULONG_FORMAT,
409     divide_with_user_unit(memory_argument, min_value));
410 }
411 
412 template &lt;typename Argument&gt;
413 static void log_set_value(Argument&amp; memory_argument) {
414   if (memory_argument.value()._size != memory_argument.value()._val) {
415     // has multiplier
416     log_error(arguments) (
417       &quot;Value specified for option \&quot;%s\&quot; is &quot; JULONG_FORMAT &quot;%c&quot;,
418       memory_argument.name(),
419       memory_argument.value()._val,
420       memory_argument.value()._multiplier);
421     return;
422   }
423   log_error(arguments) (
424     &quot;Value specified for option \&quot;%s\&quot; is &quot; JULONG_FORMAT,
425     memory_argument.name(), memory_argument.value()._val);
426 }
427 
428 template &lt;typename MemoryArg&gt;
429 static void log_adjustments(MemoryArg&amp; original_memory_size, julong new_memory_size, const char* msg) {
430   log_trace(arguments) (
431     &quot;%s size (original) &quot; JULONG_FORMAT &quot; B (user defined: %s)&quot;,
432     msg,
433     original_memory_size.value()._size,
434     original_memory_size.is_set() ? &quot;true&quot; : &quot;false&quot;);
435   log_trace(arguments) (
436     &quot;%s size (adjusted) &quot; JULONG_FORMAT &quot; B (modified: %s)&quot;,
437     msg,
438     new_memory_size,
439     original_memory_size.value()._size != new_memory_size ? &quot;true&quot; : &quot;false&quot;);
440   log_trace(arguments) (
441     &quot;%s size (adjustment) %s&quot; JULONG_FORMAT &quot; B&quot;,
442     msg,
443     new_memory_size &lt; original_memory_size.value()._size ? &quot;-&quot; : &quot;+&quot;,
444     new_memory_size &lt; original_memory_size.value()._size ?
445     original_memory_size.value()._size - new_memory_size :
446     new_memory_size - original_memory_size.value()._size);
447 }
448 
449 // All &quot;triangular&quot; options are explicitly set
450 // check that they are congruent and not causing
451 // an ambiguous situtation
452 template &lt;typename MemoryArg, typename NumberArg&gt;
453 static bool check_for_ambiguity(MemoryArg&amp; memory_size, MemoryArg&amp; global_buffer_size, NumberArg&amp; num_global_buffers) {
454   assert(memory_size.is_set(), &quot;invariant&quot;);
455   assert(global_buffer_size.is_set(), &quot;invariant&quot;);
456   assert(num_global_buffers.is_set(), &quot;invariant&quot;);
457   const julong calc_size = global_buffer_size.value()._size * (julong)num_global_buffers.value();
458   if (calc_size != memory_size.value()._size) {
459     // ambiguous
460     log_set_value(global_buffer_size);
461     log_error(arguments) (
462       &quot;Value specified for option \&quot;%s\&quot; is &quot; JLONG_FORMAT,
463       num_global_buffers.name(), num_global_buffers.value());
464     log_set_value(memory_size);
465     log_error(arguments) (
466       &quot;These values are causing an ambiguity when trying to determine how much memory to use&quot;);
467     log_error(arguments) (&quot;\&quot;%s\&quot; * \&quot;%s\&quot; do not equal \&quot;%s\&quot;&quot;,
468       global_buffer_size.name(),
469       num_global_buffers.name(),
470       memory_size.name());
471     log_error(arguments) (
472       &quot;Try to remove one of the involved options or make sure they are unambigous&quot;);
473     return false;
474   }
475   return true;
476 }
477 
478 template &lt;typename Argument&gt;
479 static bool ensure_minimum_count(Argument&amp; buffer_count_argument, jlong min_count) {
480   if (buffer_count_argument.value() &lt; min_count) {
481     log_error(arguments) (
482       &quot;Value specified for option \&quot;%s\&quot; is &quot; JLONG_FORMAT,
483       buffer_count_argument.name(), buffer_count_argument.value());
484     log_error(arguments) (
485       &quot;This value is lower than the minimum required number &quot; JLONG_FORMAT,
486       min_count);
487     return false;
488   }
489   return true;
490 }
491 
492 // global buffer size and num global buffers specified
493 // ensure that particular combination to be ihigher than minimum memory size
494 template &lt;typename MemoryArg, typename NumberArg&gt;
495 static bool ensure_calculated_gteq(MemoryArg&amp; global_buffer_size, NumberArg&amp; num_global_buffers, julong min_value) {
496   assert(global_buffer_size.is_set(), &quot;invariant&quot;);
497   assert(num_global_buffers.is_set(), &quot;invariant&quot;);
498   const julong calc_size = global_buffer_size.value()._size * (julong)num_global_buffers.value();
499   if (calc_size &lt; min_value) {
500     log_set_value(global_buffer_size);
501     log_error(arguments) (
502       &quot;Value specified for option \&quot;%s\&quot; is &quot; JLONG_FORMAT,
503       num_global_buffers.name(), num_global_buffers.value());
504     log_error(arguments) (&quot;\&quot;%s\&quot; * \&quot;%s\&quot; (&quot; JULONG_FORMAT
505       &quot;) is lower than minimum memory size required &quot; JULONG_FORMAT,
506       global_buffer_size.name(),
507       num_global_buffers.name(),
508       calc_size,
509       min_value);
510     return false;
511   }
512   return true;
513 }
514 
515 template &lt;typename Argument&gt;
516 static bool ensure_first_gteq_second(Argument&amp; first_argument, Argument&amp; second_argument) {
517   if (second_argument.value()._size &gt; first_argument.value()._size) {
518     log_set_value(first_argument);
519     log_set_value(second_argument);
520     log_error(arguments) (
521       &quot;The value for option \&quot;%s\&quot; should not be larger than the value specified for option \&quot;%s\&quot;&quot;,
522       second_argument.name(), first_argument.name());
523     return false;
524   }
525   return true;
526 }
527 
528 static bool valid_memory_relations(const JfrMemoryOptions&amp; options) {
529   if (options.global_buffer_size_configured) {
530     if (options.memory_size_configured) {
531       if (!ensure_first_gteq_second(_dcmd_memorysize, _dcmd_globalbuffersize)) {
532         return false;
533       }
534     }
535     if (options.thread_buffer_size_configured) {
536       if (!ensure_first_gteq_second(_dcmd_globalbuffersize, _dcmd_threadbuffersize)) {
537         return false;
538       }
539     }
540     if (options.buffer_count_configured) {
541       if (!ensure_calculated_gteq(_dcmd_globalbuffersize, _dcmd_numglobalbuffers, MIN_MEMORY_SIZE)) {
542         return false;
543       }
544     }
545   }
546   return true;
547 }
548 
549 static void post_process_adjusted_memory_options(const JfrMemoryOptions&amp; options) {
550   assert(options.memory_size &gt;= MIN_MEMORY_SIZE, &quot;invariant&quot;);
551   assert(options.global_buffer_size &gt;= MIN_GLOBAL_BUFFER_SIZE, &quot;invariant&quot;);
552   assert(options.buffer_count &gt;= MIN_BUFFER_COUNT, &quot;invariant&quot;);
553   assert(options.thread_buffer_size &gt;= MIN_THREAD_BUFFER_SIZE, &quot;invariant&quot;);
554   log_adjustments(_dcmd_memorysize, options.memory_size, &quot;Memory&quot;);
555   log_adjustments(_dcmd_globalbuffersize, options.global_buffer_size, &quot;Global buffer&quot;);
556   log_adjustments(_dcmd_threadbuffersize, options.thread_buffer_size, &quot;Thread local buffer&quot;);
557   log_trace(arguments) (&quot;Number of global buffers (original) &quot; JLONG_FORMAT &quot; (user defined: %s)&quot;,
558     _dcmd_numglobalbuffers.value(),
559     _dcmd_numglobalbuffers.is_set() ? &quot;true&quot; : &quot;false&quot;);
560   log_trace(arguments) ( &quot;Number of global buffers (adjusted) &quot; JULONG_FORMAT &quot; (modified: %s)&quot;,
561     options.buffer_count,
562     _dcmd_numglobalbuffers.value() != (jlong)options.buffer_count ? &quot;true&quot; : &quot;false&quot;);
563   log_trace(arguments) (&quot;Number of global buffers (adjustment) %s&quot; JLONG_FORMAT,
564     (jlong)options.buffer_count &lt; _dcmd_numglobalbuffers.value() ? &quot;&quot; : &quot;+&quot;,
565     (jlong)options.buffer_count - _dcmd_numglobalbuffers.value());
566 
567   MemorySizeArgument adjusted_memory_size;
568   adjusted_memory_size._val = divide_with_user_unit(_dcmd_memorysize, options.memory_size);
569   adjusted_memory_size._multiplier = _dcmd_memorysize.value()._multiplier;
570   adjusted_memory_size._size = options.memory_size;
571 
572   MemorySizeArgument adjusted_global_buffer_size;
573   adjusted_global_buffer_size._val = divide_with_user_unit(_dcmd_globalbuffersize, options.global_buffer_size);
574   adjusted_global_buffer_size._multiplier = _dcmd_globalbuffersize.value()._multiplier;
575   adjusted_global_buffer_size._size = options.global_buffer_size;
576 
577   MemorySizeArgument adjusted_thread_buffer_size;
578   adjusted_thread_buffer_size._val = divide_with_user_unit(_dcmd_threadbuffersize, options.thread_buffer_size);
579   adjusted_thread_buffer_size._multiplier = _dcmd_threadbuffersize.value()._multiplier;
580   adjusted_thread_buffer_size._size = options.thread_buffer_size;
581 
582   // store back to dcmd
583   _dcmd_memorysize.set_value(adjusted_memory_size);
584   _dcmd_memorysize.set_is_set(true);
585   _dcmd_globalbuffersize.set_value(adjusted_global_buffer_size);
586   _dcmd_globalbuffersize.set_is_set(true);
587   _dcmd_numglobalbuffers.set_value((jlong)options.buffer_count);
588   _dcmd_numglobalbuffers.set_is_set(true);
589   _dcmd_threadbuffersize.set_value(adjusted_thread_buffer_size);
590   _dcmd_threadbuffersize.set_is_set(true);
591 }
592 
593 static void initialize_memory_options_from_dcmd(JfrMemoryOptions&amp; options) {
594   options.memory_size = _dcmd_memorysize.value()._size;
595   options.global_buffer_size = MAX2&lt;julong&gt;(_dcmd_globalbuffersize.value()._size, (julong)os::vm_page_size());
596   options.buffer_count = (julong)_dcmd_numglobalbuffers.value();
597   options.thread_buffer_size = MAX2&lt;julong&gt;(_dcmd_threadbuffersize.value()._size, (julong)os::vm_page_size());
598   // determine which options have been explicitly set
599   options.memory_size_configured = _dcmd_memorysize.is_set();
600   options.global_buffer_size_configured = _dcmd_globalbuffersize.is_set();
601   options.buffer_count_configured = _dcmd_numglobalbuffers.is_set();
602   options.thread_buffer_size_configured = _dcmd_threadbuffersize.is_set();
603   assert(options.memory_size &gt;= MIN_MEMORY_SIZE, &quot;invariant&quot;);
604   assert(options.global_buffer_size &gt;= MIN_GLOBAL_BUFFER_SIZE, &quot;invariant&quot;);
605   assert(options.buffer_count &gt;= MIN_BUFFER_COUNT, &quot;invariant&quot;);
606   assert(options.thread_buffer_size &gt;= MIN_THREAD_BUFFER_SIZE, &quot;invariant&quot;);
607 }
608 
609 template &lt;typename Argument&gt;
610 static bool ensure_gteq(Argument&amp; memory_argument, const jlong value) {
611   if ((jlong)memory_argument.value()._size &lt; value) {
612     log_set_value(memory_argument);
613     log_lower_than_min_value(memory_argument, value);
614     return false;
615   }
616   return true;
617 }
618 
619 static bool ensure_valid_minimum_sizes() {
620   // ensure valid minimum memory sizes
621   if (_dcmd_memorysize.is_set()) {
622     if (!ensure_gteq(_dcmd_memorysize, MIN_MEMORY_SIZE)) {
623       return false;
624     }
625   }
626   if (_dcmd_globalbuffersize.is_set()) {
627     if (!ensure_gteq(_dcmd_globalbuffersize, MIN_GLOBAL_BUFFER_SIZE)) {
628       return false;
629     }
630   }
631   if (_dcmd_numglobalbuffers.is_set()) {
632     if (!ensure_minimum_count(_dcmd_numglobalbuffers, MIN_BUFFER_COUNT)) {
633       return false;
634     }
635   }
636   if (_dcmd_threadbuffersize.is_set()) {
637     if (!ensure_gteq(_dcmd_threadbuffersize, MIN_THREAD_BUFFER_SIZE)) {
638       return false;
639     }
640   }
641   return true;
642 }
643 
644 /**
645  * Starting with the initial set of memory values from the user,
646  * sanitize, enforce min/max rules and adjust to a set of consistent options.
647  *
648  * Adjusted memory sizes will be page aligned.
649  */
650 bool JfrOptionSet::adjust_memory_options() {
651   if (!ensure_valid_minimum_sizes()) {
652     return false;
653   }
654   JfrMemoryOptions options;
655   initialize_memory_options_from_dcmd(options);
656   if (!valid_memory_relations(options)) {
657     return false;
658   }
659   if (!JfrMemorySizer::adjust_options(&amp;options)) {
660     if (!check_for_ambiguity(_dcmd_memorysize, _dcmd_globalbuffersize, _dcmd_numglobalbuffers)) {
661       return false;
662     }
663   }
664   post_process_adjusted_memory_options(options);
665   return true;
666 }
667 
668 bool JfrOptionSet::parse_flight_recorder_option(const JavaVMOption** option, char* delimiter) {
669   assert(option != NULL, &quot;invariant&quot;);
670   assert(delimiter != NULL, &quot;invariant&quot;);
671   assert((*option)-&gt;optionString != NULL, &quot;invariant&quot;);
672   assert(strncmp((*option)-&gt;optionString, &quot;-XX:FlightRecorderOptions&quot;, 25) == 0, &quot;invariant&quot;);
673   if (*delimiter == &#39;\0&#39;) {
674     // -XX:FlightRecorderOptions without any delimiter and values
675   } else {
676     // -XX:FlightRecorderOptions[=|:]
677     // set delimiter to &#39;=&#39;
678     *delimiter = &#39;=&#39;;
679   }
680   return false;
681 }
682 
<a name="4" id="anc4"></a><span class="line-modified">683 static GrowableArray&lt;const char*&gt;* startup_recording_options_array = NULL;</span>
684 
685 bool JfrOptionSet::parse_start_flight_recording_option(const JavaVMOption** option, char* delimiter) {
686   assert(option != NULL, &quot;invariant&quot;);
687   assert(delimiter != NULL, &quot;invariant&quot;);
688   assert((*option)-&gt;optionString != NULL, &quot;invariant&quot;);
689   assert(strncmp((*option)-&gt;optionString, &quot;-XX:StartFlightRecording&quot;, 24) == 0, &quot;invariant&quot;);
690   const char* value = NULL;
691   if (*delimiter == &#39;\0&#39;) {
692     // -XX:StartFlightRecording without any delimiter and values
693     // Add dummy value &quot;dumponexit=false&quot; so -XX:StartFlightRecording can be used without explicit values.
694     // The existing option-&gt;optionString points to stack memory so no need to deallocate.
695     const_cast&lt;JavaVMOption*&gt;(*option)-&gt;optionString = (char*)&quot;-XX:StartFlightRecording=dumponexit=false&quot;;
696     value = (*option)-&gt;optionString + 25;
697   } else {
698     // -XX:StartFlightRecording[=|:]
699     // set delimiter to &#39;=&#39;
700     *delimiter = &#39;=&#39;;
701     value = delimiter + 1;
702   }
703   assert(value != NULL, &quot;invariant&quot;);
704   const size_t value_length = strlen(value);
705 
<a name="5" id="anc5"></a><span class="line-modified">706   if (startup_recording_options_array == NULL) {</span>
<span class="line-modified">707     startup_recording_options_array = new (ResourceObj::C_HEAP, mtTracing) GrowableArray&lt;const char*&gt;(8, true, mtTracing);</span>
708   }
<a name="6" id="anc6"></a><span class="line-modified">709   assert(startup_recording_options_array != NULL, &quot;invariant&quot;);</span>
710   char* const startup_value = NEW_C_HEAP_ARRAY(char, value_length + 1, mtTracing);
711   strncpy(startup_value, value, value_length + 1);
712   assert(strncmp(startup_value, value, value_length) == 0, &quot;invariant&quot;);
<a name="7" id="anc7"></a><span class="line-modified">713   startup_recording_options_array-&gt;append(startup_value);</span>
714   return false;
715 }
716 
<a name="8" id="anc8"></a><span class="line-modified">717 const GrowableArray&lt;const char*&gt;* JfrOptionSet::startup_recording_options() {</span>
<span class="line-modified">718   return startup_recording_options_array;</span>
719 }
720 
<a name="9" id="anc9"></a><span class="line-modified">721 void JfrOptionSet::release_startup_recording_options() {</span>
<span class="line-modified">722   if (startup_recording_options_array != NULL) {</span>
<span class="line-modified">723     const int length = startup_recording_options_array-&gt;length();</span>
724     for (int i = 0; i &lt; length; ++i) {
<a name="10" id="anc10"></a><span class="line-modified">725       FREE_C_HEAP_ARRAY(char, startup_recording_options_array-&gt;at(i));</span>
726     }
<a name="11" id="anc11"></a><span class="line-modified">727     delete startup_recording_options_array;</span>
<span class="line-modified">728     startup_recording_options_array = NULL;</span>
729   }
730 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
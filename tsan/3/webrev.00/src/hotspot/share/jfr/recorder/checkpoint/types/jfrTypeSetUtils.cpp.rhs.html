<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeSetUtils.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/recorder/checkpoint/types/jfrTypeSetUtils.hpp&quot;
 27 #include &quot;oops/instanceKlass.hpp&quot;
 28 #include &quot;oops/oop.inline.hpp&quot;
 29 #include &quot;oops/symbol.hpp&quot;
 30 
<a name="2" id="anc2"></a><span class="line-modified"> 31 static JfrSymbolId::CStringEntry* bootstrap = NULL;</span>
<span class="line-added"> 32 </span>
<span class="line-added"> 33 JfrSymbolId::JfrSymbolId() :</span>
<span class="line-added"> 34   _sym_table(new SymbolTable(this)),</span>
<span class="line-added"> 35   _cstring_table(new CStringTable(this)),</span>
<span class="line-added"> 36   _sym_list(NULL),</span>
<span class="line-added"> 37   _cstring_list(NULL),</span>
<span class="line-added"> 38   _sym_query(NULL),</span>
<span class="line-added"> 39   _cstring_query(NULL),</span>
<span class="line-added"> 40   _symbol_id_counter(1),</span>
<span class="line-added"> 41   _class_unload(false) {</span>
 42   assert(_sym_table != NULL, &quot;invariant&quot;);
 43   assert(_cstring_table != NULL, &quot;invariant&quot;);
<a name="3" id="anc3"></a><span class="line-modified"> 44   bootstrap = new CStringEntry(0, (const char*)&amp;BOOTSTRAP_LOADER_NAME);</span>
<span class="line-added"> 45   assert(bootstrap != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 46   bootstrap-&gt;set_id(1);</span>
<span class="line-added"> 47   _cstring_list = bootstrap;</span>
 48 }
 49 
<a name="4" id="anc4"></a><span class="line-modified"> 50 JfrSymbolId::~JfrSymbolId() {</span>
 51   clear();
<a name="5" id="anc5"></a><span class="line-modified"> 52   delete _sym_table;</span>
<span class="line-added"> 53   delete _cstring_table;</span>
<span class="line-added"> 54   delete bootstrap;</span>
 55 }
 56 
 57 void JfrSymbolId::clear() {
 58   assert(_sym_table != NULL, &quot;invariant&quot;);
 59   if (_sym_table-&gt;has_entries()) {
 60     _sym_table-&gt;clear_entries();
 61   }
 62   assert(!_sym_table-&gt;has_entries(), &quot;invariant&quot;);
 63 
 64   assert(_cstring_table != NULL, &quot;invariant&quot;);
 65   if (_cstring_table-&gt;has_entries()) {
 66     _cstring_table-&gt;clear_entries();
 67   }
 68   assert(!_cstring_table-&gt;has_entries(), &quot;invariant&quot;);
<a name="6" id="anc6"></a>

 69 
<a name="7" id="anc7"></a><span class="line-modified"> 70   _sym_list = NULL;</span>
<span class="line-modified"> 71   _symbol_id_counter = 1;</span>


 72 
<a name="8" id="anc8"></a><span class="line-modified"> 73   _sym_query = NULL;</span>
<span class="line-modified"> 74   _cstring_query = NULL;</span>


 75 
<a name="9" id="anc9"></a><span class="line-modified"> 76   assert(bootstrap != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 77   bootstrap-&gt;reset();</span>
<span class="line-modified"> 78   _cstring_list = bootstrap;</span>
<span class="line-added"> 79 }</span>
 80 
<a name="10" id="anc10"></a><span class="line-modified"> 81 void JfrSymbolId::set_class_unload(bool class_unload) {</span>
<span class="line-modified"> 82   _class_unload = class_unload;</span>
<span class="line-modified"> 83 }</span>
 84 
<a name="11" id="anc11"></a><span class="line-modified"> 85 void JfrSymbolId::on_link(const SymbolEntry* entry) {</span>
<span class="line-modified"> 86   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 87   const_cast&lt;Symbol*&gt;(entry-&gt;literal())-&gt;increment_refcount();</span>
<span class="line-modified"> 88   assert(entry-&gt;id() == 0, &quot;invariant&quot;);</span>
<span class="line-added"> 89   entry-&gt;set_id(++_symbol_id_counter);</span>
<span class="line-added"> 90   entry-&gt;set_list_next(_sym_list);</span>
<span class="line-added"> 91   _sym_list = entry;</span>
 92 }
 93 
<a name="12" id="anc12"></a><span class="line-modified"> 94 bool JfrSymbolId::on_equals(uintptr_t hash, const SymbolEntry* entry) {</span>
<span class="line-modified"> 95   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 96   assert(entry-&gt;hash() == hash, &quot;invariant&quot;);</span>
<span class="line-added"> 97   assert(_sym_query != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 98   return _sym_query == entry-&gt;literal();</span>
 99 }
100 
<a name="13" id="anc13"></a><span class="line-modified">101 void JfrSymbolId::on_unlink(const SymbolEntry* entry) {</span>
<span class="line-modified">102   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-added">103   const_cast&lt;Symbol*&gt;(entry-&gt;literal())-&gt;decrement_refcount();</span>
104 }
105 
<a name="14" id="anc14"></a><span class="line-modified">106 static const char* resource_to_cstring(const char* resource_str) {</span>
<span class="line-modified">107   assert(resource_str != NULL, &quot;invariant&quot;);</span>
<span class="line-added">108   const size_t length = strlen(resource_str);</span>
<span class="line-added">109   char* const c_string = JfrCHeapObj::new_array&lt;char&gt;(length + 1);</span>
<span class="line-added">110   assert(c_string != NULL, &quot;invariant&quot;);</span>
<span class="line-added">111   strncpy(c_string, resource_str, length + 1);</span>
<span class="line-added">112   return c_string;</span>
113 }
114 
<a name="15" id="anc15"></a><span class="line-modified">115 void JfrSymbolId::on_link(const CStringEntry* entry) {</span>
116   assert(entry != NULL, &quot;invariant&quot;);
117   assert(entry-&gt;id() == 0, &quot;invariant&quot;);
118   entry-&gt;set_id(++_symbol_id_counter);
<a name="16" id="anc16"></a><span class="line-added">119   const_cast&lt;CStringEntry*&gt;(entry)-&gt;set_literal(resource_to_cstring(entry-&gt;literal()));</span>
<span class="line-added">120   entry-&gt;set_list_next(_cstring_list);</span>
<span class="line-added">121   _cstring_list = entry;</span>
122 }
123 
<a name="17" id="anc17"></a><span class="line-modified">124 static bool string_compare(const char* query, const char* candidate) {</span>
<span class="line-modified">125   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">126   assert(candidate != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">127   const size_t length = strlen(query);</span>
<span class="line-modified">128   return strncmp(query, candidate, length) == 0;</span>
129 }
130 
<a name="18" id="anc18"></a><span class="line-modified">131 bool JfrSymbolId::on_equals(uintptr_t hash, const CStringEntry* entry) {</span>
132   assert(entry != NULL, &quot;invariant&quot;);
<a name="19" id="anc19"></a><span class="line-modified">133   assert(entry-&gt;hash() == hash, &quot;invariant&quot;);</span>
<span class="line-modified">134   assert(_cstring_query != NULL, &quot;invariant&quot;);</span>
<span class="line-added">135   return string_compare(_cstring_query, entry-&gt;literal());</span>
136 }
137 
<a name="20" id="anc20"></a><span class="line-modified">138 void JfrSymbolId::on_unlink(const CStringEntry* entry) {</span>

139   assert(entry != NULL, &quot;invariant&quot;);
<a name="21" id="anc21"></a><span class="line-modified">140   JfrCHeapObj::free(const_cast&lt;char*&gt;(entry-&gt;literal()), strlen(entry-&gt;literal() + 1));</span>

141 }
142 
<a name="22" id="anc22"></a><span class="line-modified">143 traceid JfrSymbolId::bootstrap_name(bool leakp) {</span>
<span class="line-modified">144   assert(bootstrap != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">145   if (leakp) {</span>
<span class="line-modified">146     bootstrap-&gt;set_leakp();</span>

147   }
<a name="23" id="anc23"></a><span class="line-modified">148   return 1;</span>







149 }
150 
<a name="24" id="anc24"></a><span class="line-modified">151 traceid JfrSymbolId::mark(const Symbol* symbol, bool leakp) {</span>
152   assert(symbol != NULL, &quot;invariant&quot;);
<a name="25" id="anc25"></a><span class="line-modified">153   return mark((uintptr_t)symbol-&gt;identity_hash(), symbol, leakp);</span>
154 }
155 
<a name="26" id="anc26"></a><span class="line-modified">156 traceid JfrSymbolId::mark(uintptr_t hash, const Symbol* data, bool leakp) {</span>
157   assert(data != NULL, &quot;invariant&quot;);
158   assert(_sym_table != NULL, &quot;invariant&quot;);
<a name="27" id="anc27"></a><span class="line-modified">159   _sym_query = data;</span>
<span class="line-added">160   const SymbolEntry&amp; entry = _sym_table-&gt;lookup_put(hash, data);</span>
<span class="line-added">161   if (_class_unload) {</span>
<span class="line-added">162     entry.set_unloading();</span>
<span class="line-added">163   }</span>
<span class="line-added">164   if (leakp) {</span>
<span class="line-added">165     entry.set_leakp();</span>
<span class="line-added">166   }</span>
<span class="line-added">167   return entry.id();</span>
168 }
169 
<a name="28" id="anc28"></a><span class="line-modified">170 traceid JfrSymbolId::mark(uintptr_t hash, const char* str, bool leakp) {</span>
171   assert(str != NULL, &quot;invariant&quot;);
<a name="29" id="anc29"></a><span class="line-modified">172   assert(_cstring_table != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">173   _cstring_query = str;</span>
<span class="line-modified">174   const CStringEntry&amp; entry = _cstring_table-&gt;lookup_put(hash, str);</span>
<span class="line-modified">175   if (_class_unload) {</span>
<span class="line-modified">176     entry.set_unloading();</span>
<span class="line-modified">177   }</span>
<span class="line-added">178   if (leakp) {</span>
<span class="line-added">179     entry.set_leakp();</span>
<span class="line-added">180   }</span>
<span class="line-added">181   return entry.id();</span>
182 }
183 
184 /*
185 * jsr292 anonymous classes symbol is the external name +
186 * the identity_hashcode slash appended:
187 *   java.lang.invoke.LambdaForm$BMH/22626602
188 *
189 * caller needs ResourceMark
190 */
191 
<a name="30" id="anc30"></a><span class="line-modified">192 uintptr_t JfrSymbolId::unsafe_anonymous_klass_name_hash(const InstanceKlass* ik) {</span>
193   assert(ik != NULL, &quot;invariant&quot;);
194   assert(ik-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);
195   const oop mirror = ik-&gt;java_mirror_no_keepalive();
196   assert(mirror != NULL, &quot;invariant&quot;);
197   return (uintptr_t)mirror-&gt;identity_hash();
198 }
199 
<a name="31" id="anc31"></a><span class="line-modified">200 static const char* create_unsafe_anonymous_klass_symbol(const InstanceKlass* ik, uintptr_t hash) {</span>
201   assert(ik != NULL, &quot;invariant&quot;);
202   assert(ik-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);
<a name="32" id="anc32"></a><span class="line-modified">203   assert(hash != 0, &quot;invariant&quot;);</span>
204   char* anonymous_symbol = NULL;
205   const oop mirror = ik-&gt;java_mirror_no_keepalive();
206   assert(mirror != NULL, &quot;invariant&quot;);
207   char hash_buf[40];
<a name="33" id="anc33"></a><span class="line-modified">208   sprintf(hash_buf, &quot;/&quot; UINTX_FORMAT, hash);</span>

209   const size_t hash_len = strlen(hash_buf);
210   const size_t result_len = ik-&gt;name()-&gt;utf8_length();
211   anonymous_symbol = NEW_RESOURCE_ARRAY(char, result_len + hash_len + 1);
212   ik-&gt;name()-&gt;as_klass_external_name(anonymous_symbol, (int)result_len + 1);
213   assert(strlen(anonymous_symbol) == result_len, &quot;invariant&quot;);
214   strcpy(anonymous_symbol + result_len, hash_buf);
215   assert(strlen(anonymous_symbol) == result_len + hash_len, &quot;invariant&quot;);
216   return anonymous_symbol;
217 }
218 
<a name="34" id="anc34"></a><span class="line-modified">219 bool JfrSymbolId::is_unsafe_anonymous_klass(const Klass* k) {</span>
220   assert(k != NULL, &quot;invariant&quot;);
<a name="35" id="anc35"></a><span class="line-modified">221   return k-&gt;is_instance_klass() &amp;&amp; ((const InstanceKlass*)k)-&gt;is_unsafe_anonymous();</span>
<span class="line-modified">222 }</span>
<span class="line-modified">223 </span>
<span class="line-added">224 traceid JfrSymbolId::mark_unsafe_anonymous_klass_name(const InstanceKlass* ik, bool leakp) {</span>
<span class="line-added">225   assert(ik != NULL, &quot;invariant&quot;);</span>
<span class="line-added">226   assert(ik-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);</span>
<span class="line-added">227   const uintptr_t hash = unsafe_anonymous_klass_name_hash(ik);</span>
<span class="line-added">228   const char* const anonymous_klass_symbol = create_unsafe_anonymous_klass_symbol(ik, hash);</span>
<span class="line-added">229   return mark(hash, anonymous_klass_symbol, leakp);</span>
<span class="line-added">230 }</span>
<span class="line-added">231 </span>
<span class="line-added">232 traceid JfrSymbolId::mark(const Klass* k, bool leakp) {</span>
<span class="line-added">233   assert(k != NULL, &quot;invariant&quot;);</span>
<span class="line-added">234   traceid symbol_id = 0;</span>
<span class="line-added">235   if (is_unsafe_anonymous_klass(k)) {</span>
<span class="line-added">236     assert(k-&gt;is_instance_klass(), &quot;invariant&quot;);</span>
<span class="line-added">237     symbol_id = mark_unsafe_anonymous_klass_name((const InstanceKlass*)k, leakp);</span>
<span class="line-added">238   }</span>
<span class="line-added">239   if (0 == symbol_id) {</span>
<span class="line-added">240     Symbol* const sym = k-&gt;name();</span>
<span class="line-added">241     if (sym != NULL) {</span>
<span class="line-added">242       symbol_id = mark(sym, leakp);</span>
<span class="line-added">243     }</span>
<span class="line-added">244   }</span>
<span class="line-added">245   assert(symbol_id &gt; 0, &quot;a symbol handler must mark the symbol for writing&quot;);</span>
<span class="line-added">246   return symbol_id;</span>
247 }
248 
249 JfrArtifactSet::JfrArtifactSet(bool class_unload) : _symbol_id(new JfrSymbolId()),
250                                                     _klass_list(NULL),
<a name="36" id="anc36"></a><span class="line-modified">251                                                     _total_count(0) {</span>
252   initialize(class_unload);
253   assert(_klass_list != NULL, &quot;invariant&quot;);
254 }
255 
256 static const size_t initial_class_list_size = 200;
<a name="37" id="anc37"></a><span class="line-modified">257 </span>
<span class="line-added">258 void JfrArtifactSet::initialize(bool class_unload, bool clear /* false */) {</span>
259   assert(_symbol_id != NULL, &quot;invariant&quot;);
<a name="38" id="anc38"></a><span class="line-modified">260   if (clear) {</span>
<span class="line-modified">261     _symbol_id-&gt;clear();</span>
<span class="line-modified">262   }</span>
<span class="line-modified">263   _symbol_id-&gt;set_class_unload(class_unload);</span>
<span class="line-added">264   _total_count = 0;</span>
265   // resource allocation
266   _klass_list = new GrowableArray&lt;const Klass*&gt;(initial_class_list_size, false, mtTracing);
267 }
268 
269 JfrArtifactSet::~JfrArtifactSet() {
<a name="39" id="anc39"></a>



270   _symbol_id-&gt;clear();
<a name="40" id="anc40"></a><span class="line-added">271   delete _symbol_id;</span>
272   // _klass_list will be cleared by a ResourceMark
273 }
274 
<a name="41" id="anc41"></a><span class="line-modified">275 traceid JfrArtifactSet::bootstrap_name(bool leakp) {</span>
<span class="line-modified">276   return _symbol_id-&gt;bootstrap_name(leakp);</span>




277 }
278 
<a name="42" id="anc42"></a><span class="line-modified">279 traceid JfrArtifactSet::mark_unsafe_anonymous_klass_name(const Klass* klass, bool leakp) {</span>
<span class="line-modified">280   assert(klass-&gt;is_instance_klass(), &quot;invariant&quot;);</span>
<span class="line-added">281   return _symbol_id-&gt;mark_unsafe_anonymous_klass_name((const InstanceKlass*)klass, leakp);</span>
282 }
283 
<a name="43" id="anc43"></a><span class="line-modified">284 traceid JfrArtifactSet::mark(uintptr_t hash, const Symbol* sym, bool leakp) {</span>
<span class="line-modified">285   return _symbol_id-&gt;mark(hash, sym, leakp);</span>
286 }
287 
<a name="44" id="anc44"></a><span class="line-modified">288 traceid JfrArtifactSet::mark(const Klass* klass, bool leakp) {</span>
<span class="line-modified">289   return _symbol_id-&gt;mark(klass, leakp);</span>
290 }
291 
<a name="45" id="anc45"></a><span class="line-modified">292 traceid JfrArtifactSet::mark(const Symbol* symbol, bool leakp) {</span>
<span class="line-modified">293   return _symbol_id-&gt;mark(symbol, leakp);</span>
294 }
295 
<a name="46" id="anc46"></a><span class="line-modified">296 traceid JfrArtifactSet::mark(uintptr_t hash, const char* const str, bool leakp) {</span>
<span class="line-modified">297   return _symbol_id-&gt;mark(hash, str, leakp);</span>




298 }
299 
300 bool JfrArtifactSet::has_klass_entries() const {
301   return _klass_list-&gt;is_nonempty();
302 }
303 
304 int JfrArtifactSet::entries() const {
305   return _klass_list-&gt;length();
306 }
307 
308 void JfrArtifactSet::register_klass(const Klass* k) {
309   assert(k != NULL, &quot;invariant&quot;);
310   assert(_klass_list != NULL, &quot;invariant&quot;);
311   assert(_klass_list-&gt;find(k) == -1, &quot;invariant&quot;);
312   _klass_list-&gt;append(k);
313 }
<a name="47" id="anc47"></a><span class="line-added">314 </span>
<span class="line-added">315 size_t JfrArtifactSet::total_count() const {</span>
<span class="line-added">316   return _total_count;</span>
<span class="line-added">317 }</span>
<a name="48" id="anc48"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="48" type="hidden" />
</body>
</html>
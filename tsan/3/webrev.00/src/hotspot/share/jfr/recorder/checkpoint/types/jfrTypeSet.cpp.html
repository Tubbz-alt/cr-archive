<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeSet.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  27 #include &quot;classfile/javaClasses.inline.hpp&quot;
  28 #include &quot;classfile/moduleEntry.hpp&quot;
  29 #include &quot;classfile/packageEntry.hpp&quot;
  30 #include &quot;classfile/symbolTable.hpp&quot;
  31 #include &quot;jfr/jfr.hpp&quot;
  32 #include &quot;jfr/jni/jfrGetAllEventClasses.hpp&quot;
  33 #include &quot;jfr/leakprofiler/checkpoint/objectSampleCheckpoint.hpp&quot;
  34 #include &quot;jfr/recorder/checkpoint/types/jfrTypeSet.hpp&quot;
  35 #include &quot;jfr/recorder/checkpoint/types/jfrTypeSetUtils.hpp&quot;
  36 #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceId.inline.hpp&quot;
  37 #include &quot;jfr/utilities/jfrHashtable.hpp&quot;
  38 #include &quot;jfr/utilities/jfrTypes.hpp&quot;
  39 #include &quot;jfr/writers/jfrTypeWriterHost.hpp&quot;
  40 #include &quot;memory/iterator.hpp&quot;
  41 #include &quot;memory/resourceArea.hpp&quot;
  42 #include &quot;oops/instanceKlass.hpp&quot;
  43 #include &quot;oops/objArrayKlass.hpp&quot;
  44 #include &quot;oops/oop.inline.hpp&quot;
  45 #include &quot;utilities/accessFlags.hpp&quot;
  46 #include &quot;utilities/bitMap.inline.hpp&quot;
  47 
  48 typedef const Klass* KlassPtr;
  49 typedef const PackageEntry* PkgPtr;
  50 typedef const ModuleEntry* ModPtr;
  51 typedef const ClassLoaderData* CldPtr;
  52 typedef const Method* MethodPtr;
  53 typedef const Symbol* SymbolPtr;
  54 typedef const JfrSymbolId::SymbolEntry* SymbolEntryPtr;
  55 typedef const JfrSymbolId::CStringEntry* CStringEntryPtr;
  56 
  57 static JfrCheckpointWriter* _writer = NULL;
  58 static JfrCheckpointWriter* _leakp_writer = NULL;
  59 static JfrArtifactSet* _artifacts = NULL;
  60 static JfrArtifactClosure* _subsystem_callback = NULL;
  61 static bool _class_unload = false;
  62 static bool _flushpoint = false;
  63 
  64 // incremented on each rotation
  65 static u8 checkpoint_id = 1;
  66 
  67 // creates a unique id by combining a checkpoint relative symbol id (2^24)
  68 // with the current checkpoint id (2^40)
  69 #define CREATE_SYMBOL_ID(sym_id) (((u8)((checkpoint_id &lt;&lt; 24) | sym_id)))
  70 
  71 static traceid create_symbol_id(traceid artifact_id) {
  72   return artifact_id != 0 ? CREATE_SYMBOL_ID(artifact_id) : 0;
  73 }
  74 
  75 static bool current_epoch() {
  76   return _class_unload || _flushpoint;
  77 }
  78 
  79 static bool previous_epoch() {
  80   return !current_epoch();
  81 }
  82 
  83 static bool is_complete() {
  84   return !_artifacts-&gt;has_klass_entries() &amp;&amp; current_epoch();
  85 }
  86 
  87 static traceid mark_symbol(KlassPtr klass, bool leakp) {
  88   return klass != NULL ? create_symbol_id(_artifacts-&gt;mark(klass, leakp)) : 0;
  89 }
  90 
  91 static traceid mark_symbol(Symbol* symbol, bool leakp) {
  92   return symbol != NULL ? create_symbol_id(_artifacts-&gt;mark(symbol, leakp)) : 0;
  93 }
  94 
  95 static traceid get_bootstrap_name(bool leakp) {
  96   return create_symbol_id(_artifacts-&gt;bootstrap_name(leakp));
  97 }
  98 
  99 template &lt;typename T&gt;
 100 static traceid artifact_id(const T* ptr) {
 101   assert(ptr != NULL, &quot;invariant&quot;);
 102   return TRACE_ID(ptr);
 103 }
 104 
 105 static traceid package_id(KlassPtr klass, bool leakp) {
 106   assert(klass != NULL, &quot;invariant&quot;);
 107   PkgPtr pkg_entry = klass-&gt;package();
 108   if (pkg_entry == NULL) {
 109     return 0;
 110   }
 111   if (leakp) {
 112     SET_LEAKP(pkg_entry);
 113   }
 114   // package implicitly tagged already
 115   return artifact_id(pkg_entry);
 116 }
 117 
 118 static traceid module_id(PkgPtr pkg, bool leakp) {
 119   assert(pkg != NULL, &quot;invariant&quot;);
 120   ModPtr module_entry = pkg-&gt;module();
 121   if (module_entry == NULL) {
 122     return 0;
 123   }
 124   if (leakp) {
 125     SET_LEAKP(module_entry);
 126   } else {
 127     SET_TRANSIENT(module_entry);
 128   }
 129   return artifact_id(module_entry);
 130 }
 131 
 132 static traceid method_id(KlassPtr klass, MethodPtr method) {
 133   assert(klass != NULL, &quot;invariant&quot;);
 134   assert(method != NULL, &quot;invariant&quot;);
 135   return METHOD_ID(klass, method);
 136 }
 137 
 138 static traceid cld_id(CldPtr cld, bool leakp) {
 139   assert(cld != NULL, &quot;invariant&quot;);
 140   assert(!cld-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);
 141   if (leakp) {
 142     SET_LEAKP(cld);
 143   } else {
 144     SET_TRANSIENT(cld);
 145   }
 146   return artifact_id(cld);
 147 }
 148 
 149 template &lt;typename T&gt;
 150 static s4 get_flags(const T* ptr) {
 151   assert(ptr != NULL, &quot;invariant&quot;);
 152   return ptr-&gt;access_flags().get_flags();
 153 }
 154 
 155 static bool is_unsafe_anonymous(const Klass* klass) {
 156   assert(klass != NULL, &quot;invariant&quot;);
 157   return klass-&gt;is_instance_klass() &amp;&amp; ((const InstanceKlass*)klass)-&gt;is_unsafe_anonymous();
 158 }
 159 
 160 static ClassLoaderData* get_cld(const Klass* klass) {
 161   assert(klass != NULL, &quot;invariant&quot;);
 162   return is_unsafe_anonymous(klass) ?
 163     InstanceKlass::cast(klass)-&gt;unsafe_anonymous_host()-&gt;class_loader_data() : klass-&gt;class_loader_data();
 164 }
 165 
 166 template &lt;typename T&gt;
 167 static void set_serialized(const T* ptr) {
 168   assert(ptr != NULL, &quot;invariant&quot;);
 169   SET_SERIALIZED(ptr);
 170   assert(IS_SERIALIZED(ptr), &quot;invariant&quot;);
 171   CLEAR_THIS_EPOCH_CLEARED_BIT(ptr);
 172 }
 173 
 174 /*
 175  * In C++03, functions used as template parameters must have external linkage;
 176  * this restriction was removed in C++11. Change back to &quot;static&quot; and
 177  * rename functions when C++11 becomes available.
 178  *
 179  * The weird naming is an effort to decrease the risk of name clashes.
 180  */
 181 
 182 static int write_klass(JfrCheckpointWriter* writer, KlassPtr klass, bool leakp) {
 183   assert(writer != NULL, &quot;invariant&quot;);
 184   assert(_artifacts != NULL, &quot;invariant&quot;);
 185   assert(klass != NULL, &quot;invariant&quot;);
 186   traceid pkg_id = 0;
 187   KlassPtr theklass = klass;
 188   if (theklass-&gt;is_objArray_klass()) {
 189     const ObjArrayKlass* obj_arr_klass = ObjArrayKlass::cast(klass);
 190     theklass = obj_arr_klass-&gt;bottom_klass();
 191   }
 192   if (theklass-&gt;is_instance_klass()) {
 193     pkg_id = package_id(theklass, leakp);
 194   } else {
 195     assert(theklass-&gt;is_typeArray_klass(), &quot;invariant&quot;);
 196   }
 197   writer-&gt;write(artifact_id(klass));
 198   writer-&gt;write(cld_id(get_cld(klass), leakp));
 199   writer-&gt;write(mark_symbol(klass, leakp));
 200   writer-&gt;write(pkg_id);
 201   writer-&gt;write(get_flags(klass));
 202   return 1;
 203 }
 204 
 205 int write__klass(JfrCheckpointWriter* writer, const void* k) {
 206   assert(k != NULL, &quot;invariant&quot;);
 207   KlassPtr klass = (KlassPtr)k;
 208   set_serialized(klass);
 209   return write_klass(writer, klass, false);
 210 }
 211 
 212 int write__klass__leakp(JfrCheckpointWriter* writer, const void* k) {
 213   assert(k != NULL, &quot;invariant&quot;);
 214   KlassPtr klass = (KlassPtr)k;
 215   return write_klass(writer, klass, true);
 216 }
 217 
 218 static bool is_implied(const Klass* klass) {
 219   assert(klass != NULL, &quot;invariant&quot;);
 220   return klass-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass()) || klass == SystemDictionary::Object_klass();
 221 }
 222 
 223 static void do_implied(Klass* klass) {
 224   assert(klass != NULL, &quot;invariant&quot;);
 225   if (is_implied(klass)) {
 226     if (_leakp_writer != NULL) {
 227       SET_LEAKP(klass);
 228     }
 229     _subsystem_callback-&gt;do_artifact(klass);
 230   }
 231 }
 232 
 233 static void do_unloaded_klass(Klass* klass) {
 234   assert(klass != NULL, &quot;invariant&quot;);
 235   assert(_subsystem_callback != NULL, &quot;invariant&quot;);
 236   if (IS_JDK_JFR_EVENT_SUBKLASS(klass)) {
 237     JfrEventClasses::increment_unloaded_event_class();
 238   }
 239   if (USED_THIS_EPOCH(klass)) {
 240     ObjectSampleCheckpoint::on_klass_unload(klass);
 241     _subsystem_callback-&gt;do_artifact(klass);
 242     return;
 243   }
 244   do_implied(klass);
 245 }
 246 
 247 static void do_klass(Klass* klass) {
 248   assert(klass != NULL, &quot;invariant&quot;);
 249   assert(_subsystem_callback != NULL, &quot;invariant&quot;);
 250   if (_flushpoint) {
 251     if (USED_THIS_EPOCH(klass)) {
 252       _subsystem_callback-&gt;do_artifact(klass);
 253       return;
 254     }
 255   } else {
 256     if (USED_PREV_EPOCH(klass)) {
 257       _subsystem_callback-&gt;do_artifact(klass);
 258       return;
 259     }
 260   }
 261   do_implied(klass);
 262 }
 263 
 264 static void do_klasses() {
 265   if (_class_unload) {
 266     ClassLoaderDataGraph::classes_unloading_do(&amp;do_unloaded_klass);
 267     return;
 268   }
 269   ClassLoaderDataGraph::classes_do(&amp;do_klass);
 270 }
 271 
 272 typedef SerializePredicate&lt;KlassPtr&gt; KlassPredicate;
 273 typedef JfrPredicatedTypeWriterImplHost&lt;KlassPtr, KlassPredicate, write__klass&gt; KlassWriterImpl;
 274 typedef JfrTypeWriterHost&lt;KlassWriterImpl, TYPE_CLASS&gt; KlassWriter;
 275 typedef CompositeFunctor&lt;KlassPtr, KlassWriter, KlassArtifactRegistrator&gt; KlassWriterRegistration;
 276 typedef JfrArtifactCallbackHost&lt;KlassPtr, KlassWriterRegistration&gt; KlassCallback;
 277 
 278 template &lt;&gt;
 279 class LeakPredicate&lt;const Klass*&gt; {
 280 public:
 281   LeakPredicate(bool class_unload) {}
 282   bool operator()(const Klass* klass) {
 283     assert(klass != NULL, &quot;invariant&quot;);
 284     return IS_LEAKP(klass) || is_implied(klass);
 285   }
 286 };
 287 
 288 typedef LeakPredicate&lt;KlassPtr&gt; LeakKlassPredicate;
 289 typedef JfrPredicatedTypeWriterImplHost&lt;KlassPtr, LeakKlassPredicate, write__klass__leakp&gt; LeakKlassWriterImpl;
 290 typedef JfrTypeWriterHost&lt;LeakKlassWriterImpl, TYPE_CLASS&gt; LeakKlassWriter;
 291 
 292 typedef CompositeFunctor&lt;KlassPtr, LeakKlassWriter, KlassWriter&gt; CompositeKlassWriter;
 293 typedef CompositeFunctor&lt;KlassPtr, CompositeKlassWriter, KlassArtifactRegistrator&gt; CompositeKlassWriterRegistration;
 294 typedef JfrArtifactCallbackHost&lt;KlassPtr, CompositeKlassWriterRegistration&gt; CompositeKlassCallback;
 295 
 296 static bool write_klasses() {
 297   assert(!_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);
 298   assert(_writer != NULL, &quot;invariant&quot;);
 299   KlassArtifactRegistrator reg(_artifacts);
 300   KlassWriter kw(_writer, _class_unload);
 301   KlassWriterRegistration kwr(&amp;kw, &amp;reg);
 302   if (_leakp_writer == NULL) {
 303     KlassCallback callback(&amp;kwr);
 304     _subsystem_callback = &amp;callback;
 305     do_klasses();
 306   } else {
 307     LeakKlassWriter lkw(_leakp_writer, _class_unload);
 308     CompositeKlassWriter ckw(&amp;lkw, &amp;kw);
 309     CompositeKlassWriterRegistration ckwr(&amp;ckw, &amp;reg);
 310     CompositeKlassCallback callback(&amp;ckwr);
 311     _subsystem_callback = &amp;callback;
 312     do_klasses();
 313   }
 314   if (is_complete()) {
 315     return false;
 316   }
 317   _artifacts-&gt;tally(kw);
 318   return true;
 319 }
 320 
 321 template &lt;typename T&gt;
 322 static void do_previous_epoch_artifact(JfrArtifactClosure* callback, T* value) {
 323   assert(callback != NULL, &quot;invariant&quot;);
 324   assert(value != NULL, &quot;invariant&quot;);
 325   if (USED_PREV_EPOCH(value)) {
 326     callback-&gt;do_artifact(value);
 327     assert(IS_NOT_SERIALIZED(value), &quot;invariant&quot;);
 328     return;
 329   }
 330   if (IS_SERIALIZED(value)) {
 331     CLEAR_SERIALIZED(value);
 332   }
 333   assert(IS_NOT_SERIALIZED(value), &quot;invariant&quot;);
 334 }
 335 
 336 typedef JfrArtifactCallbackHost&lt;KlassPtr, KlassArtifactRegistrator&gt; RegistrationCallback;
 337 
 338 static void register_klass(Klass* klass) {
 339   assert(klass != NULL, &quot;invariant&quot;);
 340   assert(_subsystem_callback != NULL, &quot;invariant&quot;);
 341   do_previous_epoch_artifact(_subsystem_callback, klass);
 342 }
 343 
 344 static void do_register_klasses() {
 345   ClassLoaderDataGraph::classes_do(&amp;register_klass);
 346 }
 347 
 348 static void register_klasses() {
 349   assert(!_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);
 350   KlassArtifactRegistrator reg(_artifacts);
 351   RegistrationCallback callback(&amp;reg);
 352   _subsystem_callback = &amp;callback;
 353   do_register_klasses();
 354 }
 355 
 356 static int write_package(JfrCheckpointWriter* writer, PkgPtr pkg, bool leakp) {
 357   assert(writer != NULL, &quot;invariant&quot;);
 358   assert(_artifacts != NULL, &quot;invariant&quot;);
 359   assert(pkg != NULL, &quot;invariant&quot;);
 360   writer-&gt;write(artifact_id(pkg));
 361   writer-&gt;write(mark_symbol(pkg-&gt;name(), leakp));
 362   writer-&gt;write(module_id(pkg, leakp));
 363   writer-&gt;write((bool)pkg-&gt;is_exported());
 364   return 1;
 365 }
 366 
 367 int write__package(JfrCheckpointWriter* writer, const void* p) {
 368   assert(p != NULL, &quot;invariant&quot;);
 369   PkgPtr pkg = (PkgPtr)p;
 370   set_serialized(pkg);
 371   return write_package(writer, pkg, false);
 372 }
 373 
 374 int write__package__leakp(JfrCheckpointWriter* writer, const void* p) {
 375   assert(p != NULL, &quot;invariant&quot;);
 376   PkgPtr pkg = (PkgPtr)p;
 377   CLEAR_LEAKP(pkg);
 378   return write_package(writer, pkg, true);
 379 }
 380 
 381 static void do_package(PackageEntry* entry) {
 382   do_previous_epoch_artifact(_subsystem_callback, entry);
 383 }
 384 
 385 static void do_packages() {
 386   ClassLoaderDataGraph::packages_do(&amp;do_package);
 387 }
 388 
 389 class PackageFieldSelector {
 390  public:
 391   typedef PkgPtr TypePtr;
 392   static TypePtr select(KlassPtr klass) {
 393     assert(klass != NULL, &quot;invariant&quot;);
 394     return ((InstanceKlass*)klass)-&gt;package();
 395   }
 396 };
 397 
 398 typedef SerializePredicate&lt;PkgPtr&gt; PackagePredicate;
 399 typedef JfrPredicatedTypeWriterImplHost&lt;PkgPtr, PackagePredicate, write__package&gt; PackageWriterImpl;
 400 typedef JfrTypeWriterHost&lt;PackageWriterImpl, TYPE_PACKAGE&gt; PackageWriter;
 401 typedef CompositeFunctor&lt;PkgPtr, PackageWriter, ClearArtifact&lt;PkgPtr&gt; &gt; PackageWriterWithClear;
 402 typedef KlassToFieldEnvelope&lt;PackageFieldSelector, PackageWriter&gt; KlassPackageWriter;
 403 typedef JfrArtifactCallbackHost&lt;PkgPtr, PackageWriterWithClear&gt; PackageCallback;
 404 
 405 typedef LeakPredicate&lt;PkgPtr&gt; LeakPackagePredicate;
 406 typedef JfrPredicatedTypeWriterImplHost&lt;PkgPtr, LeakPackagePredicate, write__package__leakp&gt; LeakPackageWriterImpl;
 407 typedef JfrTypeWriterHost&lt;LeakPackageWriterImpl, TYPE_PACKAGE&gt; LeakPackageWriter;
 408 
 409 typedef CompositeFunctor&lt;PkgPtr, LeakPackageWriter, PackageWriter&gt; CompositePackageWriter;
 410 typedef KlassToFieldEnvelope&lt;PackageFieldSelector, CompositePackageWriter&gt; KlassCompositePackageWriter;
 411 typedef KlassToFieldEnvelope&lt;PackageFieldSelector, PackageWriterWithClear&gt; KlassPackageWriterWithClear;
 412 typedef CompositeFunctor&lt;PkgPtr, CompositePackageWriter, ClearArtifact&lt;PkgPtr&gt; &gt; CompositePackageWriterWithClear;
 413 typedef JfrArtifactCallbackHost&lt;PkgPtr, CompositePackageWriterWithClear&gt; CompositePackageCallback;
 414 
 415 static void write_packages() {
 416   assert(_writer != NULL, &quot;invariant&quot;);
 417   PackageWriter pw(_writer, _class_unload);
 418   KlassPackageWriter kpw(&amp;pw);
 419   if (current_epoch()) {
 420     _artifacts-&gt;iterate_klasses(kpw);
 421     _artifacts-&gt;tally(pw);
 422     return;
 423   }
 424   assert(previous_epoch(), &quot;invariant&quot;);
 425   if (_leakp_writer == NULL) {
 426     _artifacts-&gt;iterate_klasses(kpw);
 427     ClearArtifact&lt;PkgPtr&gt; clear;
 428     PackageWriterWithClear pwwc(&amp;pw, &amp;clear);
 429     PackageCallback callback(&amp;pwwc);
 430     _subsystem_callback = &amp;callback;
 431     do_packages();
 432   } else {
 433     LeakPackageWriter lpw(_leakp_writer, _class_unload);
 434     CompositePackageWriter cpw(&amp;lpw, &amp;pw);
 435     KlassCompositePackageWriter kcpw(&amp;cpw);
 436     _artifacts-&gt;iterate_klasses(kcpw);
 437     ClearArtifact&lt;PkgPtr&gt; clear;
 438     CompositePackageWriterWithClear cpwwc(&amp;cpw, &amp;clear);
 439     CompositePackageCallback callback(&amp;cpwwc);
 440     _subsystem_callback = &amp;callback;
 441     do_packages();
 442   }
 443   _artifacts-&gt;tally(pw);
 444 }
 445 
 446 typedef JfrArtifactCallbackHost&lt;PkgPtr, ClearArtifact&lt;PkgPtr&gt; &gt; ClearPackageCallback;
 447 
 448 static void clear_packages() {
 449   ClearArtifact&lt;PkgPtr&gt; clear;
 450   ClearPackageCallback callback(&amp;clear);
 451   _subsystem_callback = &amp;callback;
 452   do_packages();
 453 }
 454 
 455 static int write_module(JfrCheckpointWriter* writer, ModPtr mod, bool leakp) {
 456   assert(mod != NULL, &quot;invariant&quot;);
 457   assert(_artifacts != NULL, &quot;invariant&quot;);
 458   writer-&gt;write(artifact_id(mod));
 459   writer-&gt;write(mark_symbol(mod-&gt;name(), leakp));
 460   writer-&gt;write(mark_symbol(mod-&gt;version(), leakp));
 461   writer-&gt;write(mark_symbol(mod-&gt;location(), leakp));
 462   writer-&gt;write(cld_id(mod-&gt;loader_data(), leakp));
 463   return 1;
 464 }
 465 
 466 int write__module(JfrCheckpointWriter* writer, const void* m) {
 467   assert(m != NULL, &quot;invariant&quot;);
 468   ModPtr mod = (ModPtr)m;
 469   set_serialized(mod);
 470   return write_module(writer, mod, false);
 471 }
 472 
 473 int write__module__leakp(JfrCheckpointWriter* writer, const void* m) {
 474   assert(m != NULL, &quot;invariant&quot;);
 475   ModPtr mod = (ModPtr)m;
 476   CLEAR_LEAKP(mod);
 477   return write_module(writer, mod, true);
 478 }
 479 
 480 static void do_module(ModuleEntry* entry) {
 481   do_previous_epoch_artifact(_subsystem_callback, entry);
 482 }
 483 
 484 static void do_modules() {
 485   ClassLoaderDataGraph::modules_do(&amp;do_module);
 486 }
 487 
 488 class ModuleFieldSelector {
 489  public:
 490   typedef ModPtr TypePtr;
 491   static TypePtr select(KlassPtr klass) {
 492     assert(klass != NULL, &quot;invariant&quot;);
 493     PkgPtr pkg = klass-&gt;package();
 494     return pkg != NULL ? pkg-&gt;module() : NULL;
 495   }
 496 };
 497 
 498 typedef SerializePredicate&lt;ModPtr&gt; ModulePredicate;
 499 typedef JfrPredicatedTypeWriterImplHost&lt;ModPtr, ModulePredicate, write__module&gt; ModuleWriterImpl;
 500 typedef JfrTypeWriterHost&lt;ModuleWriterImpl, TYPE_MODULE&gt; ModuleWriter;
 501 typedef CompositeFunctor&lt;ModPtr, ModuleWriter, ClearArtifact&lt;ModPtr&gt; &gt; ModuleWriterWithClear;
 502 typedef JfrArtifactCallbackHost&lt;ModPtr, ModuleWriterWithClear&gt; ModuleCallback;
 503 typedef KlassToFieldEnvelope&lt;ModuleFieldSelector, ModuleWriter&gt; KlassModuleWriter;
 504 
 505 typedef LeakPredicate&lt;ModPtr&gt; LeakModulePredicate;
 506 typedef JfrPredicatedTypeWriterImplHost&lt;ModPtr, LeakModulePredicate, write__module__leakp&gt; LeakModuleWriterImpl;
 507 typedef JfrTypeWriterHost&lt;LeakModuleWriterImpl, TYPE_MODULE&gt; LeakModuleWriter;
 508 
 509 typedef CompositeFunctor&lt;ModPtr, LeakModuleWriter, ModuleWriter&gt; CompositeModuleWriter;
 510 typedef KlassToFieldEnvelope&lt;ModuleFieldSelector, CompositeModuleWriter&gt; KlassCompositeModuleWriter;
 511 typedef CompositeFunctor&lt;ModPtr, CompositeModuleWriter, ClearArtifact&lt;ModPtr&gt; &gt; CompositeModuleWriterWithClear;
 512 typedef JfrArtifactCallbackHost&lt;ModPtr, CompositeModuleWriterWithClear&gt; CompositeModuleCallback;
 513 
 514 static void write_modules() {
 515   assert(_writer != NULL, &quot;invariant&quot;);
 516   ModuleWriter mw(_writer, _class_unload);
 517   KlassModuleWriter kmw(&amp;mw);
 518   if (current_epoch()) {
 519     _artifacts-&gt;iterate_klasses(kmw);
 520     _artifacts-&gt;tally(mw);
 521     return;
 522   }
 523   assert(previous_epoch(), &quot;invariant&quot;);
 524   if (_leakp_writer == NULL) {
 525     _artifacts-&gt;iterate_klasses(kmw);
 526     ClearArtifact&lt;ModPtr&gt; clear;
 527     ModuleWriterWithClear mwwc(&amp;mw, &amp;clear);
 528     ModuleCallback callback(&amp;mwwc);
 529     _subsystem_callback = &amp;callback;
 530     do_modules();
 531   } else {
 532     LeakModuleWriter lmw(_leakp_writer, _class_unload);
 533     CompositeModuleWriter cmw(&amp;lmw, &amp;mw);
 534     KlassCompositeModuleWriter kcpw(&amp;cmw);
 535     _artifacts-&gt;iterate_klasses(kcpw);
 536     ClearArtifact&lt;ModPtr&gt; clear;
 537     CompositeModuleWriterWithClear cmwwc(&amp;cmw, &amp;clear);
 538     CompositeModuleCallback callback(&amp;cmwwc);
 539     _subsystem_callback = &amp;callback;
 540     do_modules();
 541   }
 542   _artifacts-&gt;tally(mw);
 543 }
 544 
 545 typedef JfrArtifactCallbackHost&lt;ModPtr, ClearArtifact&lt;ModPtr&gt; &gt; ClearModuleCallback;
 546 
 547 static void clear_modules() {
 548   ClearArtifact&lt;ModPtr&gt; clear;
 549   ClearModuleCallback callback(&amp;clear);
 550   _subsystem_callback = &amp;callback;
 551   do_modules();
 552 }
 553 
 554 static int write_classloader(JfrCheckpointWriter* writer, CldPtr cld, bool leakp) {
 555   assert(cld != NULL, &quot;invariant&quot;);
 556   assert(!cld-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);
 557   // class loader type
 558   const Klass* class_loader_klass = cld-&gt;class_loader_klass();
 559   if (class_loader_klass == NULL) {
 560     // (primordial) boot class loader
 561     writer-&gt;write(artifact_id(cld)); // class loader instance id
 562     writer-&gt;write((traceid)0);  // class loader type id (absence of)
 563     writer-&gt;write(get_bootstrap_name(leakp)); // maps to synthetic name -&gt; &quot;bootstrap&quot;
 564   } else {
 565     writer-&gt;write(artifact_id(cld)); // class loader instance id
 566     writer-&gt;write(artifact_id(class_loader_klass)); // class loader type id
 567     writer-&gt;write(mark_symbol(cld-&gt;name(), leakp)); // class loader instance name
 568   }
 569   return 1;
 570 }
 571 
 572 int write__classloader(JfrCheckpointWriter* writer, const void* c) {
 573   assert(c != NULL, &quot;invariant&quot;);
 574   CldPtr cld = (CldPtr)c;
 575   set_serialized(cld);
 576   return write_classloader(writer, cld, false);
 577 }
 578 
 579 int write__classloader__leakp(JfrCheckpointWriter* writer, const void* c) {
 580   assert(c != NULL, &quot;invariant&quot;);
 581   CldPtr cld = (CldPtr)c;
 582   CLEAR_LEAKP(cld);
 583   return write_classloader(writer, cld, true);
 584 }
 585 
 586 static void do_class_loader_data(ClassLoaderData* cld) {
 587   do_previous_epoch_artifact(_subsystem_callback, cld);
 588 }
 589 
 590 class KlassCldFieldSelector {
 591  public:
 592   typedef CldPtr TypePtr;
 593   static TypePtr select(KlassPtr klass) {
 594     assert(klass != NULL, &quot;invariant&quot;);
 595     return get_cld(klass);
 596   }
 597 };
 598 
 599 class ModuleCldFieldSelector {
 600 public:
 601   typedef CldPtr TypePtr;
 602   static TypePtr select(KlassPtr klass) {
 603     assert(klass != NULL, &quot;invariant&quot;);
 604     ModPtr mod = ModuleFieldSelector::select(klass);
 605     return mod != NULL ? mod-&gt;loader_data() : NULL;
 606   }
 607 };
 608 
 609 class CLDCallback : public CLDClosure {
 610  public:
 611   CLDCallback() {}
 612   void do_cld(ClassLoaderData* cld) {
 613     assert(cld != NULL, &quot;invariant&quot;);
 614     if (cld-&gt;is_unsafe_anonymous()) {
 615       return;
 616     }
 617     do_class_loader_data(cld);
 618   }
 619 };
 620 
 621 static void do_class_loaders() {
 622   CLDCallback cld_cb;
 623   ClassLoaderDataGraph::loaded_cld_do(&amp;cld_cb);
 624 }
 625 
 626 typedef SerializePredicate&lt;CldPtr&gt; CldPredicate;
 627 typedef JfrPredicatedTypeWriterImplHost&lt;CldPtr, CldPredicate, write__classloader&gt; CldWriterImpl;
 628 typedef JfrTypeWriterHost&lt;CldWriterImpl, TYPE_CLASSLOADER&gt; CldWriter;
 629 typedef CompositeFunctor&lt;CldPtr, CldWriter, ClearArtifact&lt;CldPtr&gt; &gt; CldWriterWithClear;
 630 typedef JfrArtifactCallbackHost&lt;CldPtr, CldWriterWithClear&gt; CldCallback;
 631 typedef KlassToFieldEnvelope&lt;KlassCldFieldSelector, CldWriter&gt; KlassCldWriter;
 632 typedef KlassToFieldEnvelope&lt;ModuleCldFieldSelector, CldWriter&gt; ModuleCldWriter;
 633 typedef CompositeFunctor&lt;KlassPtr, KlassCldWriter, ModuleCldWriter&gt; KlassAndModuleCldWriter;
 634 
 635 typedef LeakPredicate&lt;CldPtr&gt; LeakCldPredicate;
 636 typedef JfrPredicatedTypeWriterImplHost&lt;CldPtr, LeakCldPredicate, write__classloader__leakp&gt; LeakCldWriterImpl;
 637 typedef JfrTypeWriterHost&lt;LeakCldWriterImpl, TYPE_CLASSLOADER&gt; LeakCldWriter;
 638 
 639 typedef CompositeFunctor&lt;CldPtr, LeakCldWriter, CldWriter&gt; CompositeCldWriter;
 640 typedef KlassToFieldEnvelope&lt;KlassCldFieldSelector, CompositeCldWriter&gt; KlassCompositeCldWriter;
 641 typedef KlassToFieldEnvelope&lt;ModuleCldFieldSelector, CompositeCldWriter&gt; ModuleCompositeCldWriter;
 642 typedef CompositeFunctor&lt;KlassPtr, KlassCompositeCldWriter, ModuleCompositeCldWriter&gt; KlassAndModuleCompositeCldWriter;
 643 typedef CompositeFunctor&lt;CldPtr, CompositeCldWriter, ClearArtifact&lt;CldPtr&gt; &gt; CompositeCldWriterWithClear;
 644 typedef JfrArtifactCallbackHost&lt;CldPtr, CompositeCldWriterWithClear&gt; CompositeCldCallback;
 645 
 646 static void write_classloaders() {
 647   assert(_writer != NULL, &quot;invariant&quot;);
 648   CldWriter cldw(_writer, _class_unload);
 649   KlassCldWriter kcw(&amp;cldw);
 650   ModuleCldWriter mcw(&amp;cldw);
 651   KlassAndModuleCldWriter kmcw(&amp;kcw, &amp;mcw);
 652   if (current_epoch()) {
 653     _artifacts-&gt;iterate_klasses(kmcw);
 654     _artifacts-&gt;tally(cldw);
 655     return;
 656   }
 657   assert(previous_epoch(), &quot;invariant&quot;);
 658   if (_leakp_writer == NULL) {
 659     _artifacts-&gt;iterate_klasses(kmcw);
 660     ClearArtifact&lt;CldPtr&gt; clear;
 661     CldWriterWithClear cldwwc(&amp;cldw, &amp;clear);
 662     CldCallback callback(&amp;cldwwc);
 663     _subsystem_callback = &amp;callback;
 664     do_class_loaders();
 665   } else {
 666     LeakCldWriter lcldw(_leakp_writer, _class_unload);
 667     CompositeCldWriter ccldw(&amp;lcldw, &amp;cldw);
 668     KlassCompositeCldWriter kccldw(&amp;ccldw);
 669     ModuleCompositeCldWriter mccldw(&amp;ccldw);
 670     KlassAndModuleCompositeCldWriter kmccldw(&amp;kccldw, &amp;mccldw);
 671     _artifacts-&gt;iterate_klasses(kmccldw);
 672     ClearArtifact&lt;CldPtr&gt; clear;
 673     CompositeCldWriterWithClear ccldwwc(&amp;ccldw, &amp;clear);
 674     CompositeCldCallback callback(&amp;ccldwwc);
 675     _subsystem_callback = &amp;callback;
 676     do_class_loaders();
 677   }
 678   _artifacts-&gt;tally(cldw);
 679 }
 680 
 681 typedef JfrArtifactCallbackHost&lt;CldPtr, ClearArtifact&lt;CldPtr&gt; &gt; ClearCLDCallback;
 682 
 683 static void clear_classloaders() {
 684   ClearArtifact&lt;CldPtr&gt; clear;
 685   ClearCLDCallback callback(&amp;clear);
 686   _subsystem_callback = &amp;callback;
 687   do_class_loaders();
 688 }
 689 
 690 static u1 get_visibility(MethodPtr method) {
 691   assert(method != NULL, &quot;invariant&quot;);
 692   return const_cast&lt;Method*&gt;(method)-&gt;is_hidden() ? (u1)1 : (u1)0;
 693 }
 694 
 695 template &lt;&gt;
 696 void set_serialized&lt;Method&gt;(MethodPtr method) {
 697   assert(method != NULL, &quot;invariant&quot;);
 698   SET_METHOD_SERIALIZED(method);
 699   assert(IS_METHOD_SERIALIZED(method), &quot;invariant&quot;);
 700   CLEAR_THIS_EPOCH_METHOD_CLEARED_BIT(method);
 701 }
 702 
 703 static int write_method(JfrCheckpointWriter* writer, MethodPtr method, bool leakp) {
 704   assert(writer != NULL, &quot;invariant&quot;);
 705   assert(method != NULL, &quot;invariant&quot;);
 706   assert(_artifacts != NULL, &quot;invariant&quot;);
 707   KlassPtr klass = method-&gt;method_holder();
 708   assert(klass != NULL, &quot;invariant&quot;);
 709   writer-&gt;write(method_id(klass, method));
 710   writer-&gt;write(artifact_id(klass));
 711   writer-&gt;write(mark_symbol(method-&gt;name(), leakp));
 712   writer-&gt;write(mark_symbol(method-&gt;signature(), leakp));
 713   writer-&gt;write((u2)get_flags(method));
 714   writer-&gt;write(get_visibility(method));
 715   return 1;
 716 }
 717 
 718 int write__method(JfrCheckpointWriter* writer, const void* m) {
 719   assert(m != NULL, &quot;invariant&quot;);
 720   MethodPtr method = (MethodPtr)m;
 721   set_serialized(method);
 722   return write_method(writer, method, false);
 723 }
 724 
 725 int write__method__leakp(JfrCheckpointWriter* writer, const void* m) {
 726   assert(m != NULL, &quot;invariant&quot;);
 727   MethodPtr method = (MethodPtr)m;
 728   return write_method(writer, method, true);
 729 }
 730 
 731 class BitMapFilter {
 732   ResourceBitMap _bitmap;
 733  public:
 734   explicit BitMapFilter(int length = 0) : _bitmap((size_t)length) {}
 735   bool operator()(size_t idx) {
 736     if (_bitmap.size() == 0) {
 737       return true;
 738     }
 739     if (_bitmap.at(idx)) {
 740       return false;
 741     }
 742     _bitmap.set_bit(idx);
 743     return true;
 744   }
 745 };
 746 
 747 class AlwaysTrue {
 748  public:
 749   explicit AlwaysTrue(int length = 0) {}
 750   bool operator()(size_t idx) {
 751     return true;
 752   }
 753 };
 754 
 755 template &lt;typename MethodCallback, typename KlassCallback, class Filter, bool leakp&gt;
 756 class MethodIteratorHost {
 757  private:
 758   MethodCallback _method_cb;
 759   KlassCallback _klass_cb;
 760   MethodUsedPredicate&lt;leakp&gt; _method_used_predicate;
 761   MethodFlagPredicate&lt;leakp&gt; _method_flag_predicate;
 762  public:
 763   MethodIteratorHost(JfrCheckpointWriter* writer,
 764                      bool current_epoch = false,
 765                      bool class_unload = false,
 766                      bool skip_header = false) :
 767     _method_cb(writer, class_unload, skip_header),
 768     _klass_cb(writer, class_unload, skip_header),
 769     _method_used_predicate(current_epoch),
 770     _method_flag_predicate(current_epoch) {}
 771 
 772   bool operator()(KlassPtr klass) {
 773     if (_method_used_predicate(klass)) {
 774       const InstanceKlass* ik = InstanceKlass::cast(klass);
 775       const int len = ik-&gt;methods()-&gt;length();
 776       Filter filter(ik-&gt;previous_versions() != NULL ? len : 0);
 777       while (ik != NULL) {
 778         for (int i = 0; i &lt; len; ++i) {
 779           MethodPtr method = ik-&gt;methods()-&gt;at(i);
 780           if (_method_flag_predicate(method) &amp;&amp; filter(i)) {
 781             _method_cb(method);
 782           }
 783         }
 784         // There can be multiple versions of the same method running
 785         // due to redefinition. Need to inspect the complete set of methods.
 786         ik = ik-&gt;previous_versions();
 787       }
 788     }
 789     return _klass_cb(klass);
 790   }
 791 
 792   int count() const { return _method_cb.count(); }
 793   void add(int count) { _method_cb.add(count); }
 794 };
 795 
 796 template &lt;typename T, template &lt;typename&gt; class Impl&gt;
 797 class Wrapper {
 798   Impl&lt;T&gt; _t;
 799  public:
 800   Wrapper(JfrCheckpointWriter*, bool, bool) : _t() {}
 801   bool operator()(T const&amp; value) {
 802     return _t(value);
 803   }
 804 };
 805 
 806 template &lt;typename T&gt;
 807 class EmptyStub {
 808  public:
 809   bool operator()(T const&amp; value) { return true; }
 810 };
 811 
 812 typedef SerializePredicate&lt;MethodPtr&gt; MethodPredicate;
 813 typedef JfrPredicatedTypeWriterImplHost&lt;MethodPtr, MethodPredicate, write__method&gt; MethodWriterImplTarget;
 814 typedef Wrapper&lt;KlassPtr, EmptyStub&gt; KlassCallbackStub;
 815 typedef JfrTypeWriterHost&lt;MethodWriterImplTarget, TYPE_METHOD&gt; MethodWriterImpl;
 816 typedef MethodIteratorHost&lt;MethodWriterImpl, KlassCallbackStub, BitMapFilter, false&gt; MethodWriter;
 817 
 818 typedef LeakPredicate&lt;MethodPtr&gt; LeakMethodPredicate;
 819 typedef JfrPredicatedTypeWriterImplHost&lt;MethodPtr, LeakMethodPredicate, write__method__leakp&gt; LeakMethodWriterImplTarget;
 820 typedef JfrTypeWriterHost&lt;LeakMethodWriterImplTarget, TYPE_METHOD&gt; LeakMethodWriterImpl;
 821 typedef MethodIteratorHost&lt;LeakMethodWriterImpl, KlassCallbackStub, BitMapFilter, true&gt; LeakMethodWriter;
 822 typedef MethodIteratorHost&lt;LeakMethodWriterImpl, KlassCallbackStub, BitMapFilter, true&gt; LeakMethodWriter;
 823 typedef CompositeFunctor&lt;KlassPtr, LeakMethodWriter, MethodWriter&gt; CompositeMethodWriter;
 824 
 825 static void write_methods() {
 826   assert(_writer != NULL, &quot;invariant&quot;);
 827   MethodWriter mw(_writer, current_epoch(), _class_unload);
 828   if (_leakp_writer == NULL) {
 829     _artifacts-&gt;iterate_klasses(mw);
 830   } else {
 831     LeakMethodWriter lpmw(_leakp_writer, current_epoch(), _class_unload);
 832     CompositeMethodWriter cmw(&amp;lpmw, &amp;mw);
 833     _artifacts-&gt;iterate_klasses(cmw);
 834   }
 835   _artifacts-&gt;tally(mw);
 836 }
 837 
 838 template &lt;&gt;
 839 void set_serialized&lt;JfrSymbolId::SymbolEntry&gt;(SymbolEntryPtr ptr) {
 840   assert(ptr != NULL, &quot;invariant&quot;);
 841   ptr-&gt;set_serialized();
 842   assert(ptr-&gt;is_serialized(), &quot;invariant&quot;);
 843 }
 844 
 845 template &lt;&gt;
 846 void set_serialized&lt;JfrSymbolId::CStringEntry&gt;(CStringEntryPtr ptr) {
 847   assert(ptr != NULL, &quot;invariant&quot;);
 848   ptr-&gt;set_serialized();
 849   assert(ptr-&gt;is_serialized(), &quot;invariant&quot;);
 850 }
 851 
 852 static int write_symbol(JfrCheckpointWriter* writer, SymbolEntryPtr entry, bool leakp) {
 853   assert(writer != NULL, &quot;invariant&quot;);
 854   assert(entry != NULL, &quot;invariant&quot;);
 855   ResourceMark rm;
 856   writer-&gt;write(create_symbol_id(entry-&gt;id()));
 857   writer-&gt;write(entry-&gt;value()-&gt;as_C_string());
 858   return 1;
 859 }
 860 
 861 int write__symbol(JfrCheckpointWriter* writer, const void* e) {
 862   assert(e != NULL, &quot;invariant&quot;);
 863   SymbolEntryPtr entry = (SymbolEntryPtr)e;
 864   set_serialized(entry);
 865   return write_symbol(writer, entry, false);
 866 }
 867 
 868 int write__symbol__leakp(JfrCheckpointWriter* writer, const void* e) {
 869   assert(e != NULL, &quot;invariant&quot;);
 870   SymbolEntryPtr entry = (SymbolEntryPtr)e;
 871   return write_symbol(writer, entry, true);
 872 }
 873 
 874 static int write_cstring(JfrCheckpointWriter* writer, CStringEntryPtr entry, bool leakp) {
 875   assert(writer != NULL, &quot;invariant&quot;);
 876   assert(entry != NULL, &quot;invariant&quot;);
 877   writer-&gt;write(create_symbol_id(entry-&gt;id()));
 878   writer-&gt;write(entry-&gt;value());
 879   return 1;
 880 }
 881 
 882 int write__cstring(JfrCheckpointWriter* writer, const void* e) {
 883   assert(e != NULL, &quot;invariant&quot;);
 884   CStringEntryPtr entry = (CStringEntryPtr)e;
 885   set_serialized(entry);
 886   return write_cstring(writer, entry, false);
 887 }
 888 
 889 int write__cstring__leakp(JfrCheckpointWriter* writer, const void* e) {
 890   assert(e != NULL, &quot;invariant&quot;);
 891   CStringEntryPtr entry = (CStringEntryPtr)e;
 892   return write_cstring(writer, entry, true);
 893 }
 894 
 895 typedef SymbolPredicate&lt;SymbolEntryPtr, false&gt; SymPredicate;
 896 typedef JfrPredicatedTypeWriterImplHost&lt;SymbolEntryPtr, SymPredicate, write__symbol&gt; SymbolEntryWriterImpl;
 897 typedef JfrTypeWriterHost&lt;SymbolEntryWriterImpl, TYPE_SYMBOL&gt; SymbolEntryWriter;
 898 typedef SymbolPredicate&lt;CStringEntryPtr, false&gt; CStringPredicate;
 899 typedef JfrPredicatedTypeWriterImplHost&lt;CStringEntryPtr, CStringPredicate, write__cstring&gt; CStringEntryWriterImpl;
 900 typedef JfrTypeWriterHost&lt;CStringEntryWriterImpl, TYPE_SYMBOL&gt; CStringEntryWriter;
 901 
 902 typedef SymbolPredicate&lt;SymbolEntryPtr, true&gt; LeakSymPredicate;
 903 typedef JfrPredicatedTypeWriterImplHost&lt;SymbolEntryPtr, LeakSymPredicate, write__symbol__leakp&gt; LeakSymbolEntryWriterImpl;
 904 typedef JfrTypeWriterHost&lt;LeakSymbolEntryWriterImpl, TYPE_SYMBOL&gt; LeakSymbolEntryWriter;
 905 typedef CompositeFunctor&lt;SymbolEntryPtr, LeakSymbolEntryWriter, SymbolEntryWriter&gt; CompositeSymbolWriter;
 906 typedef SymbolPredicate&lt;CStringEntryPtr, true&gt; LeakCStringPredicate;
 907 typedef JfrPredicatedTypeWriterImplHost&lt;CStringEntryPtr, LeakCStringPredicate, write__cstring__leakp&gt; LeakCStringEntryWriterImpl;
 908 typedef JfrTypeWriterHost&lt;LeakCStringEntryWriterImpl, TYPE_SYMBOL&gt; LeakCStringEntryWriter;
 909 typedef CompositeFunctor&lt;CStringEntryPtr, LeakCStringEntryWriter, CStringEntryWriter&gt; CompositeCStringWriter;
 910 
 911 static void write_symbols_with_leakp() {
 912   assert(_leakp_writer != NULL, &quot;invariant&quot;);
 913   SymbolEntryWriter sw(_writer, _class_unload);
 914   LeakSymbolEntryWriter lsw(_leakp_writer, _class_unload);
 915   CompositeSymbolWriter csw(&amp;lsw, &amp;sw);
 916   _artifacts-&gt;iterate_symbols(csw);
 917   CStringEntryWriter ccsw(_writer, _class_unload, true); // skip header
 918   LeakCStringEntryWriter lccsw(_leakp_writer, _class_unload, true); // skip header
 919   CompositeCStringWriter cccsw(&amp;lccsw, &amp;ccsw);
 920   _artifacts-&gt;iterate_cstrings(cccsw);
 921   sw.add(ccsw.count());
 922   lsw.add(lccsw.count());
 923   _artifacts-&gt;tally(sw);
 924 }
 925 
 926 static void write_symbols() {
 927   assert(_writer != NULL, &quot;invariant&quot;);
 928   if (_leakp_writer != NULL) {
 929     write_symbols_with_leakp();
 930     return;
 931   }
 932   SymbolEntryWriter sw(_writer, _class_unload);
 933   _artifacts-&gt;iterate_symbols(sw);
 934   CStringEntryWriter csw(_writer, _class_unload, true); // skip header
 935   _artifacts-&gt;iterate_cstrings(csw);
 936   sw.add(csw.count());
 937   _artifacts-&gt;tally(sw);
 938 }
 939 
 940 typedef Wrapper&lt;KlassPtr, ClearArtifact&gt; ClearKlassBits;
 941 typedef Wrapper&lt;MethodPtr, ClearArtifact&gt; ClearMethodFlag;
 942 typedef MethodIteratorHost&lt;ClearMethodFlag, ClearKlassBits, AlwaysTrue, false&gt; ClearKlassAndMethods;
 943 
 944 static bool clear_artifacts = false;
 945 
 946 static void clear_klasses_and_methods() {
 947   ClearKlassAndMethods clear(_writer);
 948   _artifacts-&gt;iterate_klasses(clear);
 949 }
 950 
 951 static size_t teardown() {
 952   assert(_artifacts != NULL, &quot;invariant&quot;);
 953   const size_t total_count = _artifacts-&gt;total_count();
 954   if (previous_epoch()) {
 955     clear_klasses_and_methods();
 956     clear_artifacts = true;
 957     ++checkpoint_id;
 958   }
 959   return total_count;
 960 }
 961 
 962 static void setup(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer, bool class_unload, bool flushpoint) {
 963   _writer = writer;
 964   _leakp_writer = leakp_writer;
 965   _class_unload = class_unload;
 966   _flushpoint = flushpoint;
 967   if (_artifacts == NULL) {
 968     _artifacts = new JfrArtifactSet(class_unload);
 969   } else {
 970     _artifacts-&gt;initialize(class_unload, clear_artifacts);
 971   }
 972   clear_artifacts = false;
 973   assert(_artifacts != NULL, &quot;invariant&quot;);
 974   assert(!_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);
 975 }
 976 
 977 /**
 978  * Write all &quot;tagged&quot; (in-use) constant artifacts and their dependencies.
 979  */
 980 size_t JfrTypeSet::serialize(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer, bool class_unload, bool flushpoint) {
 981   assert(writer != NULL, &quot;invariant&quot;);
 982   ResourceMark rm;
 983   setup(writer, leakp_writer, class_unload, flushpoint);
 984   // write order is important because an individual write step
 985   // might tag an artifact to be written in a subsequent step
 986   if (!write_klasses()) {
 987     return 0;
 988   }
 989   write_packages();
 990   write_modules();
 991   write_classloaders();
 992   write_methods();
 993   write_symbols();
 994   return teardown();
 995 }
 996 
 997 /**
 998  * Clear all tags from the previous epoch.
 999  */
1000 void JfrTypeSet::clear() {
1001   clear_artifacts = true;
1002   setup(NULL, NULL, false, false);
1003   register_klasses();
1004   clear_packages();
1005   clear_modules();
1006   clear_classloaders();
1007   clear_klasses_and_methods();
1008 }
    </pre>
  </body>
</html>
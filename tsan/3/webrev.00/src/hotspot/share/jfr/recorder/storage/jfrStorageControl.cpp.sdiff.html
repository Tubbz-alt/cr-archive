<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/recorder/storage/jfrStorageControl.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="jfrStorage.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrStorageUtils.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/storage/jfrStorageControl.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/recorder/storage/jfrStorageControl.hpp&quot;
 27 #include &quot;runtime/atomic.hpp&quot;
 28 #include &quot;runtime/mutexLocker.hpp&quot;
<span class="line-removed"> 29 #include &quot;runtime/orderAccess.hpp&quot;</span>
 30 
 31 // returns the updated value
 32 static jlong atomic_add(size_t value, size_t volatile* const dest) {
 33   size_t compare_value;
 34   size_t exchange_value;
 35   do {
<span class="line-modified"> 36     compare_value = OrderAccess::load_acquire(dest);</span>
 37     exchange_value = compare_value + value;
<span class="line-modified"> 38   } while (Atomic::cmpxchg(exchange_value, dest, compare_value) != compare_value);</span>
 39   return exchange_value;
 40 }
 41 
 42 static jlong atomic_dec(size_t volatile* const dest) {
 43   size_t compare_value;
 44   size_t exchange_value;
 45   do {
<span class="line-modified"> 46     compare_value = OrderAccess::load_acquire(dest);</span>
 47     assert(compare_value &gt;= 1, &quot;invariant&quot;);
 48     exchange_value = compare_value - 1;
<span class="line-modified"> 49   } while (Atomic::cmpxchg(exchange_value, dest, compare_value) != compare_value);</span>
 50   return exchange_value;
 51 }
 52 
 53 const size_t max_lease_factor = 2;
 54 JfrStorageControl::JfrStorageControl(size_t global_count_total, size_t in_memory_discard_threshold) :
 55   _global_count_total(global_count_total),
 56   _full_count(0),
 57   _global_lease_count(0),
 58   _dead_count(0),
 59   _to_disk_threshold(0),
 60   _in_memory_discard_threshold(in_memory_discard_threshold),
 61   _global_lease_threshold(global_count_total / max_lease_factor),
 62   _scavenge_threshold(0),
 63   _to_disk(false) {}
 64 
 65 bool JfrStorageControl::to_disk() const {
 66   return _to_disk;
 67 }
 68 
 69 void JfrStorageControl::set_to_disk(bool enable) {
</pre>
<hr />
<pre>
 85   assert(_full_count &gt; 0, &quot;invariant&quot;);
 86   return --_full_count;
 87 }
 88 
 89 void JfrStorageControl::reset_full() {
 90   assert(JfrBuffer_lock-&gt;owned_by_self(), &quot;invariant&quot;);
 91   _full_count = 0;
 92 }
 93 
 94 bool JfrStorageControl::should_post_buffer_full_message() const {
 95   return to_disk() &amp;&amp; (full_count() &gt; _to_disk_threshold);
 96 }
 97 
 98 bool JfrStorageControl::should_discard() const {
 99   return !to_disk() &amp;&amp; full_count() &gt;= _in_memory_discard_threshold;
100 }
101 
102 // concurrent with accuracy requirement
103 
104 size_t JfrStorageControl::global_lease_count() const {
<span class="line-modified">105   return OrderAccess::load_acquire(&amp;_global_lease_count);</span>
106 }
107 
108 size_t JfrStorageControl::increment_leased() {
109   return atomic_add(1, &amp;_global_lease_count);
110 }
111 
112 size_t JfrStorageControl::decrement_leased() {
113   return atomic_dec(&amp;_global_lease_count);
114 }
115 
116 bool JfrStorageControl::is_global_lease_allowed() const {
117   return global_lease_count() &lt;= _global_lease_threshold;
118 }
119 
120 // concurrent with lax requirement
121 
122 size_t JfrStorageControl::dead_count() const {
123   return _dead_count;
124 }
125 
126 size_t JfrStorageControl::increment_dead() {
127   return atomic_add(1, &amp;_dead_count);
128 }
129 
130 size_t JfrStorageControl::decrement_dead() {
131   return atomic_dec(&amp;_dead_count);
132 }
133 
134 bool JfrStorageControl::should_scavenge() const {
135   return dead_count() &gt;= _scavenge_threshold;
136 }
137 
138 void JfrStorageControl::set_scavenge_threshold(size_t number_of_dead_buffers) {
139   _scavenge_threshold = number_of_dead_buffers;
140 }
<span class="line-removed">141 </span>
</pre>
</td>
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/recorder/storage/jfrStorageControl.hpp&quot;
 27 #include &quot;runtime/atomic.hpp&quot;
 28 #include &quot;runtime/mutexLocker.hpp&quot;

 29 
 30 // returns the updated value
 31 static jlong atomic_add(size_t value, size_t volatile* const dest) {
 32   size_t compare_value;
 33   size_t exchange_value;
 34   do {
<span class="line-modified"> 35     compare_value = *dest;</span>
 36     exchange_value = compare_value + value;
<span class="line-modified"> 37   } while (Atomic::cmpxchg(dest, compare_value, exchange_value) != compare_value);</span>
 38   return exchange_value;
 39 }
 40 
 41 static jlong atomic_dec(size_t volatile* const dest) {
 42   size_t compare_value;
 43   size_t exchange_value;
 44   do {
<span class="line-modified"> 45     compare_value = *dest;</span>
 46     assert(compare_value &gt;= 1, &quot;invariant&quot;);
 47     exchange_value = compare_value - 1;
<span class="line-modified"> 48   } while (Atomic::cmpxchg(dest, compare_value, exchange_value) != compare_value);</span>
 49   return exchange_value;
 50 }
 51 
 52 const size_t max_lease_factor = 2;
 53 JfrStorageControl::JfrStorageControl(size_t global_count_total, size_t in_memory_discard_threshold) :
 54   _global_count_total(global_count_total),
 55   _full_count(0),
 56   _global_lease_count(0),
 57   _dead_count(0),
 58   _to_disk_threshold(0),
 59   _in_memory_discard_threshold(in_memory_discard_threshold),
 60   _global_lease_threshold(global_count_total / max_lease_factor),
 61   _scavenge_threshold(0),
 62   _to_disk(false) {}
 63 
 64 bool JfrStorageControl::to_disk() const {
 65   return _to_disk;
 66 }
 67 
 68 void JfrStorageControl::set_to_disk(bool enable) {
</pre>
<hr />
<pre>
 84   assert(_full_count &gt; 0, &quot;invariant&quot;);
 85   return --_full_count;
 86 }
 87 
 88 void JfrStorageControl::reset_full() {
 89   assert(JfrBuffer_lock-&gt;owned_by_self(), &quot;invariant&quot;);
 90   _full_count = 0;
 91 }
 92 
 93 bool JfrStorageControl::should_post_buffer_full_message() const {
 94   return to_disk() &amp;&amp; (full_count() &gt; _to_disk_threshold);
 95 }
 96 
 97 bool JfrStorageControl::should_discard() const {
 98   return !to_disk() &amp;&amp; full_count() &gt;= _in_memory_discard_threshold;
 99 }
100 
101 // concurrent with accuracy requirement
102 
103 size_t JfrStorageControl::global_lease_count() const {
<span class="line-modified">104   return Atomic::load(&amp;_global_lease_count);</span>
105 }
106 
107 size_t JfrStorageControl::increment_leased() {
108   return atomic_add(1, &amp;_global_lease_count);
109 }
110 
111 size_t JfrStorageControl::decrement_leased() {
112   return atomic_dec(&amp;_global_lease_count);
113 }
114 
115 bool JfrStorageControl::is_global_lease_allowed() const {
116   return global_lease_count() &lt;= _global_lease_threshold;
117 }
118 
119 // concurrent with lax requirement
120 
121 size_t JfrStorageControl::dead_count() const {
122   return _dead_count;
123 }
124 
125 size_t JfrStorageControl::increment_dead() {
126   return atomic_add(1, &amp;_dead_count);
127 }
128 
129 size_t JfrStorageControl::decrement_dead() {
130   return atomic_dec(&amp;_dead_count);
131 }
132 
133 bool JfrStorageControl::should_scavenge() const {
134   return dead_count() &gt;= _scavenge_threshold;
135 }
136 
137 void JfrStorageControl::set_scavenge_threshold(size_t number_of_dead_buffers) {
138   _scavenge_threshold = number_of_dead_buffers;
139 }

</pre>
</td>
</tr>
</table>
<center><a href="jfrStorage.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrStorageUtils.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
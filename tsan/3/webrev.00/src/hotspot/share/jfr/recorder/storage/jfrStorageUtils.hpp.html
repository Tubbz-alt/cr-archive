<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/jfr/recorder/storage/jfrStorageUtils.hpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_JFR_RECORDER_STORAGE_JFRSTORAGEUTILS_HPP
 26 #define SHARE_JFR_RECORDER_STORAGE_JFRSTORAGEUTILS_HPP
 27 
 28 #include &quot;jfr/recorder/storage/jfrBuffer.hpp&quot;
 29 #include &quot;jfr/recorder/repository/jfrChunkWriter.hpp&quot;
 30 #include &quot;jfr/utilities/jfrAllocation.hpp&quot;
 31 #include &quot;jfr/utilities/jfrTypes.hpp&quot;
 32 #include &quot;runtime/thread.hpp&quot;
 33 
 34 class CompositeOperationOr {
 35  public:
 36   static bool evaluate(bool value) {
 37     return !value;
 38   }
 39 };
 40 
 41 class CompositeOperationAnd {
 42  public:
 43   static bool evaluate(bool value) {
 44     return value;
 45   }
 46 };
 47 
 48 template &lt;typename Operation, typename NextOperation, typename TruthFunction = CompositeOperationAnd&gt;
 49 class CompositeOperation {
 50  private:
 51   Operation* _op;
 52   NextOperation* _next;
 53  public:
 54   CompositeOperation(Operation* op, NextOperation* next) : _op(op), _next(next) {
 55     assert(_op != NULL, &quot;invariant&quot;);
 56   }
 57   typedef typename Operation::Type Type;
 58   bool process(Type* t) {
 59     const bool op_result = _op-&gt;process(t);
 60     return _next == NULL ? op_result : TruthFunction::evaluate(op_result) ? _next-&gt;process(t) : op_result;
 61   }
 62   size_t elements() const {
 63     return _next == NULL ? _op-&gt;elements() : _op-&gt;elements() + _next-&gt;elements();
 64   }
 65   size_t size() const {
 66     return _next == NULL ? _op-&gt;size() : _op-&gt;size() + _next-&gt;size();
 67   }
 68 };
 69 
 70 template &lt;typename T&gt;
 71 class UnBufferedWriteToChunk {
 72  private:
 73   JfrChunkWriter&amp; _writer;
 74   size_t _elements;
 75   size_t _size;
 76  public:
 77   typedef T Type;
 78   UnBufferedWriteToChunk(JfrChunkWriter&amp; writer) : _writer(writer), _elements(0), _size(0) {}
 79   bool write(Type* t, const u1* data, size_t size);
 80   size_t elements() const { return _elements; }
 81   size_t size() const { return _size; }
 82 };
 83 
 84 template &lt;typename T&gt;
 85 class DefaultDiscarder {
 86  private:
 87   size_t _elements;
 88   size_t _size;
 89  public:
 90   typedef T Type;
 91   DefaultDiscarder() : _elements(0), _size(0) {}
 92   bool discard(Type* t, const u1* data, size_t size);
 93   size_t elements() const { return _elements; }
 94   size_t size() const { return _size; }
 95 };
 96 
 97 template &lt;typename T, bool negation&gt;
 98 class Retired {
 99  public:
100   typedef T Type;
101   bool process(Type* t) {
102     assert(t != NULL, &quot;invariant&quot;);
103     return negation ? !t-&gt;retired() : t-&gt;retired();
104   }
105 };
106 
107 template &lt;typename T, bool negation&gt;
108 class Excluded {
109  public:
110   typedef T Type;
111   bool process(Type* t) {
112     assert(t != NULL, &quot;invariant&quot;);
113     return negation ? !t-&gt;excluded() : t-&gt;excluded();
114   }
115 };
116 
117 template &lt;typename Operation&gt;
118 class MutexedWriteOp {
119  private:
120   Operation&amp; _operation;
121  public:
122   typedef typename Operation::Type Type;
123   MutexedWriteOp(Operation&amp; operation) : _operation(operation) {}
124   bool process(Type* t);
125   size_t elements() const { return _operation.elements(); }
126   size_t size() const { return _operation.size(); }
127 };
128 
129 template &lt;typename Operation, typename Predicate&gt;
130 class PredicatedMutexedWriteOp : public MutexedWriteOp&lt;Operation&gt; {
131  private:
132   Predicate&amp; _predicate;
133  public:
134   PredicatedMutexedWriteOp(Operation&amp; operation, Predicate&amp; predicate) :
135     MutexedWriteOp&lt;Operation&gt;(operation), _predicate(predicate) {}
136   bool process(typename Operation::Type* t) {
137     return _predicate.process(t) ? MutexedWriteOp&lt;Operation&gt;::process(t) : true;
138   }
139 };
140 
141 template &lt;typename Operation&gt;
142 class ConcurrentWriteOp {
143  private:
144   Operation&amp; _operation;
145  public:
146   typedef typename Operation::Type Type;
147   ConcurrentWriteOp(Operation&amp; operation) : _operation(operation) {}
148   bool process(Type* t);
149   size_t elements() const { return _operation.elements(); }
150   size_t size() const { return _operation.size(); }
151 };
152 
153 template &lt;typename Operation, typename Predicate&gt;
154 class PredicatedConcurrentWriteOp : public ConcurrentWriteOp&lt;Operation&gt; {
155  private:
156   Predicate&amp; _predicate;
157  public:
158   PredicatedConcurrentWriteOp(Operation&amp; operation, Predicate&amp; predicate) :
159     ConcurrentWriteOp&lt;Operation&gt;(operation), _predicate(predicate) {}
160   bool process(typename Operation::Type* t) {
161     return _predicate.process(t) ? ConcurrentWriteOp&lt;Operation&gt;::process(t) : true;
162   }
163 };
164 
165 template &lt;typename Operation&gt;
166 class ExclusiveOp : private MutexedWriteOp&lt;Operation&gt; {
167  public:
168   typedef typename Operation::Type Type;
169   ExclusiveOp(Operation&amp; operation) : MutexedWriteOp&lt;Operation&gt;(operation) {}
170   bool process(Type* t);
171   size_t processed() const { return MutexedWriteOp&lt;Operation&gt;::processed(); }
172 };
173 
174 enum jfr_operation_mode {
175   mutexed = 1,
176   concurrent
177 };
178 
179 template &lt;typename Operation&gt;
180 class DiscardOp {
181  private:
182   Operation _operation;
183   jfr_operation_mode _mode;
184  public:
185   typedef typename Operation::Type Type;
186   DiscardOp(jfr_operation_mode mode = concurrent) : _operation(), _mode(mode) {}
187   bool process(Type* t);
188   size_t elements() const { return _operation.elements(); }
189   size_t size() const { return _operation.size(); }
190 };
191 
192 #endif // SHARE_JFR_RECORDER_STORAGE_JFRSTORAGEUTILS_HPP
    </pre>
  </body>
</html>
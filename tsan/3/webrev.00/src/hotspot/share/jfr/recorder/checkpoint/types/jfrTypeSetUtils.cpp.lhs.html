<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeSetUtils.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/recorder/checkpoint/types/jfrTypeSetUtils.hpp&quot;
 27 #include &quot;oops/instanceKlass.hpp&quot;
 28 #include &quot;oops/oop.inline.hpp&quot;
 29 #include &quot;oops/symbol.hpp&quot;
 30 
<a name="2" id="anc2"></a><span class="line-modified"> 31 JfrSymbolId::JfrSymbolId() : _sym_table(new SymbolTable(this)), _cstring_table(new CStringTable(this)), _symbol_id_counter(0) {</span>










 32   assert(_sym_table != NULL, &quot;invariant&quot;);
 33   assert(_cstring_table != NULL, &quot;invariant&quot;);
<a name="3" id="anc3"></a><span class="line-modified"> 34   initialize();</span>



 35 }
 36 
<a name="4" id="anc4"></a><span class="line-modified"> 37 void JfrSymbolId::initialize() {</span>
 38   clear();
<a name="5" id="anc5"></a><span class="line-modified"> 39   assert(_symbol_id_counter == 0, &quot;invariant&quot;);</span>


 40 }
 41 
 42 void JfrSymbolId::clear() {
 43   assert(_sym_table != NULL, &quot;invariant&quot;);
 44   if (_sym_table-&gt;has_entries()) {
 45     _sym_table-&gt;clear_entries();
 46   }
 47   assert(!_sym_table-&gt;has_entries(), &quot;invariant&quot;);
 48 
 49   assert(_cstring_table != NULL, &quot;invariant&quot;);
 50   if (_cstring_table-&gt;has_entries()) {
 51     _cstring_table-&gt;clear_entries();
 52   }
 53   assert(!_cstring_table-&gt;has_entries(), &quot;invariant&quot;);
<a name="6" id="anc6"></a><span class="line-removed"> 54   _symbol_id_counter = 0;</span>
<span class="line-removed"> 55 }</span>
 56 
<a name="7" id="anc7"></a><span class="line-modified"> 57 JfrSymbolId::~JfrSymbolId() {</span>
<span class="line-modified"> 58   delete _sym_table;</span>
<span class="line-removed"> 59   delete _cstring_table;</span>
<span class="line-removed"> 60 }</span>
 61 
<a name="8" id="anc8"></a><span class="line-modified"> 62 traceid JfrSymbolId::mark_unsafe_anonymous_klass_name(const Klass* k) {</span>
<span class="line-modified"> 63   assert(k != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 64   assert(k-&gt;is_instance_klass(), &quot;invariant&quot;);</span>
<span class="line-removed"> 65   assert(is_unsafe_anonymous_klass(k), &quot;invariant&quot;);</span>
 66 
<a name="9" id="anc9"></a><span class="line-modified"> 67   uintptr_t anonymous_symbol_hash_code = 0;</span>
<span class="line-modified"> 68   const char* const anonymous_symbol =</span>
<span class="line-modified"> 69     create_unsafe_anonymous_klass_symbol((const InstanceKlass*)k, anonymous_symbol_hash_code);</span>

 70 
<a name="10" id="anc10"></a><span class="line-modified"> 71   if (anonymous_symbol == NULL) {</span>
<span class="line-modified"> 72     return 0;</span>
<span class="line-modified"> 73   }</span>
 74 
<a name="11" id="anc11"></a><span class="line-modified"> 75   assert(anonymous_symbol_hash_code != 0, &quot;invariant&quot;);</span>
<span class="line-modified"> 76   traceid symbol_id = mark(anonymous_symbol, anonymous_symbol_hash_code);</span>
<span class="line-modified"> 77   assert(mark(anonymous_symbol, anonymous_symbol_hash_code) == symbol_id, &quot;invariant&quot;);</span>
<span class="line-modified"> 78   return symbol_id;</span>



 79 }
 80 
<a name="12" id="anc12"></a><span class="line-modified"> 81 const JfrSymbolId::SymbolEntry* JfrSymbolId::map_symbol(const Symbol* symbol) const {</span>
<span class="line-modified"> 82   return _sym_table-&gt;lookup_only(symbol, (uintptr_t)const_cast&lt;Symbol*&gt;(symbol)-&gt;identity_hash());</span>



 83 }
 84 
<a name="13" id="anc13"></a><span class="line-modified"> 85 const JfrSymbolId::SymbolEntry* JfrSymbolId::map_symbol(uintptr_t hash) const {</span>
<span class="line-modified"> 86   return _sym_table-&gt;lookup_only(NULL, hash);</span>

 87 }
 88 
<a name="14" id="anc14"></a><span class="line-modified"> 89 const JfrSymbolId::CStringEntry* JfrSymbolId::map_cstring(uintptr_t hash) const {</span>
<span class="line-modified"> 90   return _cstring_table-&gt;lookup_only(NULL, hash);</span>





 91 }
 92 
<a name="15" id="anc15"></a><span class="line-modified"> 93 void JfrSymbolId::assign_id(SymbolEntry* entry) {</span>
 94   assert(entry != NULL, &quot;invariant&quot;);
 95   assert(entry-&gt;id() == 0, &quot;invariant&quot;);
 96   entry-&gt;set_id(++_symbol_id_counter);
<a name="16" id="anc16"></a>


 97 }
 98 
<a name="17" id="anc17"></a><span class="line-modified"> 99 bool JfrSymbolId::equals(const Symbol* query, uintptr_t hash, const SymbolEntry* entry) {</span>
<span class="line-modified">100   // query might be NULL</span>
<span class="line-modified">101   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">102   assert(entry-&gt;hash() == hash, &quot;invariant&quot;);</span>
<span class="line-modified">103   return true;</span>
104 }
105 
<a name="18" id="anc18"></a><span class="line-modified">106 void JfrSymbolId::assign_id(CStringEntry* entry) {</span>
107   assert(entry != NULL, &quot;invariant&quot;);
<a name="19" id="anc19"></a><span class="line-modified">108   assert(entry-&gt;id() == 0, &quot;invariant&quot;);</span>
<span class="line-modified">109   entry-&gt;set_id(++_symbol_id_counter);</span>

110 }
111 
<a name="20" id="anc20"></a><span class="line-modified">112 bool JfrSymbolId::equals(const char* query, uintptr_t hash, const CStringEntry* entry) {</span>
<span class="line-removed">113   // query might be NULL</span>
114   assert(entry != NULL, &quot;invariant&quot;);
<a name="21" id="anc21"></a><span class="line-modified">115   assert(entry-&gt;hash() == hash, &quot;invariant&quot;);</span>
<span class="line-removed">116   return true;</span>
117 }
118 
<a name="22" id="anc22"></a><span class="line-modified">119 traceid JfrSymbolId::mark(const Klass* k) {</span>
<span class="line-modified">120   assert(k != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">121   traceid symbol_id = 0;</span>
<span class="line-modified">122   if (is_unsafe_anonymous_klass(k)) {</span>
<span class="line-removed">123     symbol_id = mark_unsafe_anonymous_klass_name(k);</span>
124   }
<a name="23" id="anc23"></a><span class="line-modified">125   if (0 == symbol_id) {</span>
<span class="line-removed">126     const Symbol* const sym = k-&gt;name();</span>
<span class="line-removed">127     if (sym != NULL) {</span>
<span class="line-removed">128       symbol_id = mark(sym);</span>
<span class="line-removed">129     }</span>
<span class="line-removed">130   }</span>
<span class="line-removed">131   assert(symbol_id &gt; 0, &quot;a symbol handler must mark the symbol for writing&quot;);</span>
<span class="line-removed">132   return symbol_id;</span>
133 }
134 
<a name="24" id="anc24"></a><span class="line-modified">135 traceid JfrSymbolId::mark(const Symbol* symbol) {</span>
136   assert(symbol != NULL, &quot;invariant&quot;);
<a name="25" id="anc25"></a><span class="line-modified">137   return mark(symbol, (uintptr_t)const_cast&lt;Symbol*&gt;(symbol)-&gt;identity_hash());</span>
138 }
139 
<a name="26" id="anc26"></a><span class="line-modified">140 traceid JfrSymbolId::mark(const Symbol* data, uintptr_t hash) {</span>
141   assert(data != NULL, &quot;invariant&quot;);
142   assert(_sym_table != NULL, &quot;invariant&quot;);
<a name="27" id="anc27"></a><span class="line-modified">143   return _sym_table-&gt;id(data, hash);</span>








144 }
145 
<a name="28" id="anc28"></a><span class="line-modified">146 traceid JfrSymbolId::mark(const char* str, uintptr_t hash) {</span>
147   assert(str != NULL, &quot;invariant&quot;);
<a name="29" id="anc29"></a><span class="line-modified">148   return _cstring_table-&gt;id(str, hash);</span>
<span class="line-modified">149 }</span>
<span class="line-modified">150 </span>
<span class="line-modified">151 bool JfrSymbolId::is_unsafe_anonymous_klass(const Klass* k) {</span>
<span class="line-modified">152   assert(k != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">153   return k-&gt;is_instance_klass() &amp;&amp; ((const InstanceKlass*)k)-&gt;is_unsafe_anonymous();</span>




154 }
155 
156 /*
157 * jsr292 anonymous classes symbol is the external name +
158 * the identity_hashcode slash appended:
159 *   java.lang.invoke.LambdaForm$BMH/22626602
160 *
161 * caller needs ResourceMark
162 */
163 
<a name="30" id="anc30"></a><span class="line-modified">164 uintptr_t JfrSymbolId::unsafe_anonymous_klass_name_hash_code(const InstanceKlass* ik) {</span>
165   assert(ik != NULL, &quot;invariant&quot;);
166   assert(ik-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);
167   const oop mirror = ik-&gt;java_mirror_no_keepalive();
168   assert(mirror != NULL, &quot;invariant&quot;);
169   return (uintptr_t)mirror-&gt;identity_hash();
170 }
171 
<a name="31" id="anc31"></a><span class="line-modified">172 const char* JfrSymbolId::create_unsafe_anonymous_klass_symbol(const InstanceKlass* ik, uintptr_t&amp; hashcode) {</span>
173   assert(ik != NULL, &quot;invariant&quot;);
174   assert(ik-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);
<a name="32" id="anc32"></a><span class="line-modified">175   assert(0 == hashcode, &quot;invariant&quot;);</span>
176   char* anonymous_symbol = NULL;
177   const oop mirror = ik-&gt;java_mirror_no_keepalive();
178   assert(mirror != NULL, &quot;invariant&quot;);
179   char hash_buf[40];
<a name="33" id="anc33"></a><span class="line-modified">180   hashcode = unsafe_anonymous_klass_name_hash_code(ik);</span>
<span class="line-removed">181   sprintf(hash_buf, &quot;/&quot; UINTX_FORMAT, hashcode);</span>
182   const size_t hash_len = strlen(hash_buf);
183   const size_t result_len = ik-&gt;name()-&gt;utf8_length();
184   anonymous_symbol = NEW_RESOURCE_ARRAY(char, result_len + hash_len + 1);
185   ik-&gt;name()-&gt;as_klass_external_name(anonymous_symbol, (int)result_len + 1);
186   assert(strlen(anonymous_symbol) == result_len, &quot;invariant&quot;);
187   strcpy(anonymous_symbol + result_len, hash_buf);
188   assert(strlen(anonymous_symbol) == result_len + hash_len, &quot;invariant&quot;);
189   return anonymous_symbol;
190 }
191 
<a name="34" id="anc34"></a><span class="line-modified">192 uintptr_t JfrSymbolId::regular_klass_name_hash_code(const Klass* k) {</span>
193   assert(k != NULL, &quot;invariant&quot;);
<a name="35" id="anc35"></a><span class="line-modified">194   const Symbol* const sym = k-&gt;name();</span>
<span class="line-modified">195   assert(sym != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">196   return (uintptr_t)const_cast&lt;Symbol*&gt;(sym)-&gt;identity_hash();</span>























197 }
198 
199 JfrArtifactSet::JfrArtifactSet(bool class_unload) : _symbol_id(new JfrSymbolId()),
200                                                     _klass_list(NULL),
<a name="36" id="anc36"></a><span class="line-modified">201                                                     _class_unload(class_unload) {</span>
202   initialize(class_unload);
203   assert(_klass_list != NULL, &quot;invariant&quot;);
204 }
205 
206 static const size_t initial_class_list_size = 200;
<a name="37" id="anc37"></a><span class="line-modified">207 void JfrArtifactSet::initialize(bool class_unload) {</span>

208   assert(_symbol_id != NULL, &quot;invariant&quot;);
<a name="38" id="anc38"></a><span class="line-modified">209   _symbol_id-&gt;initialize();</span>
<span class="line-modified">210   assert(!_symbol_id-&gt;has_entries(), &quot;invariant&quot;);</span>
<span class="line-modified">211   _symbol_id-&gt;mark(BOOTSTRAP_LOADER_NAME, 0); // pre-load &quot;bootstrap&quot;</span>
<span class="line-modified">212   _class_unload = class_unload;</span>

213   // resource allocation
214   _klass_list = new GrowableArray&lt;const Klass*&gt;(initial_class_list_size, false, mtTracing);
215 }
216 
217 JfrArtifactSet::~JfrArtifactSet() {
<a name="39" id="anc39"></a><span class="line-removed">218   clear();</span>
<span class="line-removed">219 }</span>
<span class="line-removed">220 </span>
<span class="line-removed">221 void JfrArtifactSet::clear() {</span>
222   _symbol_id-&gt;clear();
<a name="40" id="anc40"></a>
223   // _klass_list will be cleared by a ResourceMark
224 }
225 
<a name="41" id="anc41"></a><span class="line-modified">226 traceid JfrArtifactSet::mark_unsafe_anonymous_klass_name(const Klass* klass) {</span>
<span class="line-modified">227   return _symbol_id-&gt;mark_unsafe_anonymous_klass_name(klass);</span>
<span class="line-removed">228 }</span>
<span class="line-removed">229 </span>
<span class="line-removed">230 traceid JfrArtifactSet::mark(const Symbol* sym, uintptr_t hash) {</span>
<span class="line-removed">231   return _symbol_id-&gt;mark(sym, hash);</span>
232 }
233 
<a name="42" id="anc42"></a><span class="line-modified">234 traceid JfrArtifactSet::mark(const Klass* klass) {</span>
<span class="line-modified">235   return _symbol_id-&gt;mark(klass);</span>

236 }
237 
<a name="43" id="anc43"></a><span class="line-modified">238 traceid JfrArtifactSet::mark(const Symbol* symbol) {</span>
<span class="line-modified">239   return _symbol_id-&gt;mark(symbol);</span>
240 }
241 
<a name="44" id="anc44"></a><span class="line-modified">242 traceid JfrArtifactSet::mark(const char* const str, uintptr_t hash) {</span>
<span class="line-modified">243   return _symbol_id-&gt;mark(str, hash);</span>
244 }
245 
<a name="45" id="anc45"></a><span class="line-modified">246 const JfrSymbolId::SymbolEntry* JfrArtifactSet::map_symbol(const Symbol* symbol) const {</span>
<span class="line-modified">247   return _symbol_id-&gt;map_symbol(symbol);</span>
248 }
249 
<a name="46" id="anc46"></a><span class="line-modified">250 const JfrSymbolId::SymbolEntry* JfrArtifactSet::map_symbol(uintptr_t hash) const {</span>
<span class="line-modified">251   return _symbol_id-&gt;map_symbol(hash);</span>
<span class="line-removed">252 }</span>
<span class="line-removed">253 </span>
<span class="line-removed">254 const JfrSymbolId::CStringEntry* JfrArtifactSet::map_cstring(uintptr_t hash) const {</span>
<span class="line-removed">255   return _symbol_id-&gt;map_cstring(hash);</span>
256 }
257 
258 bool JfrArtifactSet::has_klass_entries() const {
259   return _klass_list-&gt;is_nonempty();
260 }
261 
262 int JfrArtifactSet::entries() const {
263   return _klass_list-&gt;length();
264 }
265 
266 void JfrArtifactSet::register_klass(const Klass* k) {
267   assert(k != NULL, &quot;invariant&quot;);
268   assert(_klass_list != NULL, &quot;invariant&quot;);
269   assert(_klass_list-&gt;find(k) == -1, &quot;invariant&quot;);
270   _klass_list-&gt;append(k);
271 }
<a name="47" id="anc47"></a>



<a name="48" id="anc48"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="48" type="hidden" />
</body>
</html>
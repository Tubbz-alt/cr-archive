<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/jfr/recorder/service/jfrPostBox.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="jfrOptionSet.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrPostBox.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/service/jfrPostBox.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -24,18 +24,18 @@</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;jfr/recorder/service/jfrPostBox.hpp&quot;
  #include &quot;jfr/utilities/jfrTryLock.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
<span class="udiff-line-removed">- #include &quot;runtime/orderAccess.hpp&quot;</span>
  #include &quot;runtime/thread.inline.hpp&quot;
  
  #define MSG_IS_SYNCHRONOUS ( (MSGBIT(MSG_ROTATE)) |          \
                               (MSGBIT(MSG_STOP))   |          \
                               (MSGBIT(MSG_START))  |          \
                               (MSGBIT(MSG_CLONE_IN_MEMORY)) | \
<span class="udiff-line-modified-removed">-                              (MSGBIT(MSG_VM_ERROR))          \</span>
<span class="udiff-line-modified-added">+                              (MSGBIT(MSG_VM_ERROR))        | \</span>
<span class="udiff-line-added">+                              (MSGBIT(MSG_FLUSHPOINT))        \</span>
                             )
  
  static JfrPostBox* _instance = NULL;
  
  JfrPostBox&amp; JfrPostBox::instance() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -82,14 +82,14 @@</span>
    synchronous_post(the_message);
  }
  
  void JfrPostBox::deposit(int new_messages) {
    while (true) {
<span class="udiff-line-modified-removed">-     const int current_msgs = OrderAccess::load_acquire(&amp;_messages);</span>
<span class="udiff-line-modified-added">+     const int current_msgs = Atomic::load(&amp;_messages);</span>
      // OR the new message
      const int exchange_value = current_msgs | new_messages;
<span class="udiff-line-modified-removed">-     const int result = Atomic::cmpxchg(exchange_value, &amp;_messages, current_msgs);</span>
<span class="udiff-line-modified-added">+     const int result = Atomic::cmpxchg(&amp;_messages, current_msgs, exchange_value);</span>
      if (result == current_msgs) {
        return;
      }
      /* Some other thread just set exactly what this thread wanted */
      if ((result &amp; new_messages) == new_messages) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -108,18 +108,18 @@</span>
  }
  
  void JfrPostBox::synchronous_post(int msg) {
    assert(is_synchronous(msg), &quot;invariant&quot;);
    assert(!JfrMsg_lock-&gt;owned_by_self(), &quot;should not hold JfrMsg_lock here!&quot;);
<span class="udiff-line-modified-removed">-   MutexLockerEx msg_lock(JfrMsg_lock);</span>
<span class="udiff-line-modified-added">+   MonitorLocker msg_lock(JfrMsg_lock);</span>
    deposit(msg);
    // serial_id is used to check when what we send in has been processed.
    // _msg_read_serial is read under JfrMsg_lock protection.
<span class="udiff-line-modified-removed">-   const uintptr_t serial_id = OrderAccess::load_acquire(&amp;_msg_read_serial) + 1;</span>
<span class="udiff-line-modified-removed">-   JfrMsg_lock-&gt;notify_all();</span>
<span class="udiff-line-modified-added">+   const uintptr_t serial_id = Atomic::load(&amp;_msg_read_serial) + 1;</span>
<span class="udiff-line-modified-added">+   msg_lock.notify_all();</span>
    while (!is_message_processed(serial_id)) {
<span class="udiff-line-modified-removed">-     JfrMsg_lock-&gt;wait();</span>
<span class="udiff-line-modified-added">+     msg_lock.wait();</span>
    }
  }
  
  /*
   * Check if a synchronous message has been processed.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -127,21 +127,21 @@</span>
   * that we are holding the JfrMsg_lock when checking
   * completion status.
   */
  bool JfrPostBox::is_message_processed(uintptr_t serial_id) const {
    assert(JfrMsg_lock-&gt;owned_by_self(), &quot;_msg_handled_serial must be read under JfrMsg_lock protection&quot;);
<span class="udiff-line-modified-removed">-   return serial_id &lt;= OrderAccess::load_acquire(&amp;_msg_handled_serial);</span>
<span class="udiff-line-modified-added">+   return serial_id &lt;= Atomic::load(&amp;_msg_handled_serial);</span>
  }
  
  bool JfrPostBox::is_empty() const {
    assert(JfrMsg_lock-&gt;owned_by_self(), &quot;not holding JfrMsg_lock!&quot;);
<span class="udiff-line-modified-removed">-   return OrderAccess::load_acquire(&amp;_messages) == 0;</span>
<span class="udiff-line-modified-added">+   return Atomic::load(&amp;_messages) == 0;</span>
  }
  
  int JfrPostBox::collect() {
    // get pending and reset to 0
<span class="udiff-line-modified-removed">-   const int messages = Atomic::xchg(0, &amp;_messages);</span>
<span class="udiff-line-modified-added">+   const int messages = Atomic::xchg(&amp;_messages, 0);</span>
    if (check_waiters(messages)) {
      _has_waiters = true;
      assert(JfrMsg_lock-&gt;owned_by_self(), &quot;incrementing _msg_read_serial is protected by JfrMsg_lock&quot;);
      // Update made visible on release of JfrMsg_lock via fence instruction in Monitor::IUnlock.
      ++_msg_read_serial;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -166,8 +166,8 @@</span>
    JfrMsg_lock-&gt;notify();
  }
  
  // safeguard to ensure no threads are left waiting
  void JfrPostBox::notify_collection_stop() {
<span class="udiff-line-modified-removed">-   MutexLockerEx msg_lock(JfrMsg_lock);</span>
<span class="udiff-line-modified-added">+   MutexLocker msg_lock(JfrMsg_lock);</span>
    JfrMsg_lock-&gt;notify_all();
  }
</pre>
<center><a href="jfrOptionSet.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrPostBox.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
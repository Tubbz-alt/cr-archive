<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/recorder/service/jfrOptionSet.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../repository/jfrRepository.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrOptionSet.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/service/jfrOptionSet.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/dcmd/jfrDcmds.hpp&quot;
 27 #include &quot;jfr/recorder/service/jfrMemorySizer.hpp&quot;
 28 #include &quot;jfr/recorder/service/jfrOptionSet.hpp&quot;
 29 #include &quot;jfr/utilities/jfrAllocation.hpp&quot;

 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;memory/allocation.inline.hpp&quot;
 32 #include &quot;memory/resourceArea.hpp&quot;
 33 #include &quot;runtime/java.hpp&quot;
 34 #include &quot;runtime/thread.inline.hpp&quot;
 35 #include &quot;services/diagnosticArgument.hpp&quot;
 36 #include &quot;services/diagnosticFramework.hpp&quot;
 37 #include &quot;utilities/growableArray.hpp&quot;
 38 #include &quot;utilities/ostream.hpp&quot;
 39 
 40 struct ObsoleteOption {
 41   const char* name;
 42   const char* message;
 43 };
 44 
 45 static const ObsoleteOption OBSOLETE_OPTIONS[] = {
 46   {&quot;checkpointbuffersize&quot;, &quot;&quot;},
 47   {&quot;maxsize&quot;,              &quot;Use -XX:StartFlightRecording=maxsize=... instead.&quot;},
 48   {&quot;maxage&quot;,               &quot;Use -XX:StartFlightRecording=maxage=... instead.&quot;},
 49   {&quot;settings&quot;,             &quot;Use -XX:StartFlightRecording=settings=... instead.&quot;},
</pre>
<hr />
<pre>
 89 jlong JfrOptionSet::num_global_buffers() {
 90   return _num_global_buffers;
 91 }
 92 
 93 void JfrOptionSet::set_num_global_buffers(jlong value) {
 94   _num_global_buffers = value;
 95 }
 96 
 97 jint JfrOptionSet::old_object_queue_size() {
 98   return (jint)_old_object_queue_size;
 99 }
100 
101 void JfrOptionSet::set_old_object_queue_size(jlong value) {
102   _old_object_queue_size = value;
103 }
104 
105 u4 JfrOptionSet::stackdepth() {
106   return _stack_depth;
107 }
108 
<span class="line-removed">109 static const u4 STACK_DEPTH_DEFAULT = 64;</span>
<span class="line-removed">110 static const u4 MIN_STACK_DEPTH = 1;</span>
<span class="line-removed">111 static const u4 MAX_STACK_DEPTH = 2048;</span>
<span class="line-removed">112 </span>
113 void JfrOptionSet::set_stackdepth(u4 depth) {
114   if (depth &lt; MIN_STACK_DEPTH) {
115     _stack_depth = MIN_STACK_DEPTH;
116   } else if (depth &gt; MAX_STACK_DEPTH) {
117     _stack_depth = MAX_STACK_DEPTH;
118   } else {
119     _stack_depth = depth;
120   }
121 }
122 
123 bool JfrOptionSet::sample_threads() {
124   return _sample_threads == JNI_TRUE;
125 }
126 
127 void JfrOptionSet::set_sample_threads(jboolean sample) {
128   _sample_threads = sample;
129 }
130 
131 bool JfrOptionSet::can_retransform() {
132   return _retransform == JNI_TRUE;
</pre>
<hr />
<pre>
663   }
664   post_process_adjusted_memory_options(options);
665   return true;
666 }
667 
668 bool JfrOptionSet::parse_flight_recorder_option(const JavaVMOption** option, char* delimiter) {
669   assert(option != NULL, &quot;invariant&quot;);
670   assert(delimiter != NULL, &quot;invariant&quot;);
671   assert((*option)-&gt;optionString != NULL, &quot;invariant&quot;);
672   assert(strncmp((*option)-&gt;optionString, &quot;-XX:FlightRecorderOptions&quot;, 25) == 0, &quot;invariant&quot;);
673   if (*delimiter == &#39;\0&#39;) {
674     // -XX:FlightRecorderOptions without any delimiter and values
675   } else {
676     // -XX:FlightRecorderOptions[=|:]
677     // set delimiter to &#39;=&#39;
678     *delimiter = &#39;=&#39;;
679   }
680   return false;
681 }
682 
<span class="line-modified">683 static GrowableArray&lt;const char*&gt;* startup_recording_options_array = NULL;</span>
684 
685 bool JfrOptionSet::parse_start_flight_recording_option(const JavaVMOption** option, char* delimiter) {
686   assert(option != NULL, &quot;invariant&quot;);
687   assert(delimiter != NULL, &quot;invariant&quot;);
688   assert((*option)-&gt;optionString != NULL, &quot;invariant&quot;);
689   assert(strncmp((*option)-&gt;optionString, &quot;-XX:StartFlightRecording&quot;, 24) == 0, &quot;invariant&quot;);
690   const char* value = NULL;
691   if (*delimiter == &#39;\0&#39;) {
692     // -XX:StartFlightRecording without any delimiter and values
693     // Add dummy value &quot;dumponexit=false&quot; so -XX:StartFlightRecording can be used without explicit values.
694     // The existing option-&gt;optionString points to stack memory so no need to deallocate.
695     const_cast&lt;JavaVMOption*&gt;(*option)-&gt;optionString = (char*)&quot;-XX:StartFlightRecording=dumponexit=false&quot;;
696     value = (*option)-&gt;optionString + 25;
697   } else {
698     // -XX:StartFlightRecording[=|:]
699     // set delimiter to &#39;=&#39;
700     *delimiter = &#39;=&#39;;
701     value = delimiter + 1;
702   }
703   assert(value != NULL, &quot;invariant&quot;);
704   const size_t value_length = strlen(value);
705 
<span class="line-modified">706   if (startup_recording_options_array == NULL) {</span>
<span class="line-modified">707     startup_recording_options_array = new (ResourceObj::C_HEAP, mtTracing) GrowableArray&lt;const char*&gt;(8, true, mtTracing);</span>
708   }
<span class="line-modified">709   assert(startup_recording_options_array != NULL, &quot;invariant&quot;);</span>
710   char* const startup_value = NEW_C_HEAP_ARRAY(char, value_length + 1, mtTracing);
711   strncpy(startup_value, value, value_length + 1);
712   assert(strncmp(startup_value, value, value_length) == 0, &quot;invariant&quot;);
<span class="line-modified">713   startup_recording_options_array-&gt;append(startup_value);</span>
714   return false;
715 }
716 
<span class="line-modified">717 const GrowableArray&lt;const char*&gt;* JfrOptionSet::startup_recording_options() {</span>
<span class="line-modified">718   return startup_recording_options_array;</span>
719 }
720 
<span class="line-modified">721 void JfrOptionSet::release_startup_recording_options() {</span>
<span class="line-modified">722   if (startup_recording_options_array != NULL) {</span>
<span class="line-modified">723     const int length = startup_recording_options_array-&gt;length();</span>
724     for (int i = 0; i &lt; length; ++i) {
<span class="line-modified">725       FREE_C_HEAP_ARRAY(char, startup_recording_options_array-&gt;at(i));</span>
726     }
<span class="line-modified">727     delete startup_recording_options_array;</span>
<span class="line-modified">728     startup_recording_options_array = NULL;</span>
729   }
730 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/dcmd/jfrDcmds.hpp&quot;
 27 #include &quot;jfr/recorder/service/jfrMemorySizer.hpp&quot;
 28 #include &quot;jfr/recorder/service/jfrOptionSet.hpp&quot;
 29 #include &quot;jfr/utilities/jfrAllocation.hpp&quot;
<span class="line-added"> 30 #include &quot;jfr/utilities/jfrTypes.hpp&quot;</span>
 31 #include &quot;logging/log.hpp&quot;
 32 #include &quot;memory/allocation.inline.hpp&quot;
 33 #include &quot;memory/resourceArea.hpp&quot;
 34 #include &quot;runtime/java.hpp&quot;
 35 #include &quot;runtime/thread.inline.hpp&quot;
 36 #include &quot;services/diagnosticArgument.hpp&quot;
 37 #include &quot;services/diagnosticFramework.hpp&quot;
 38 #include &quot;utilities/growableArray.hpp&quot;
 39 #include &quot;utilities/ostream.hpp&quot;
 40 
 41 struct ObsoleteOption {
 42   const char* name;
 43   const char* message;
 44 };
 45 
 46 static const ObsoleteOption OBSOLETE_OPTIONS[] = {
 47   {&quot;checkpointbuffersize&quot;, &quot;&quot;},
 48   {&quot;maxsize&quot;,              &quot;Use -XX:StartFlightRecording=maxsize=... instead.&quot;},
 49   {&quot;maxage&quot;,               &quot;Use -XX:StartFlightRecording=maxage=... instead.&quot;},
 50   {&quot;settings&quot;,             &quot;Use -XX:StartFlightRecording=settings=... instead.&quot;},
</pre>
<hr />
<pre>
 90 jlong JfrOptionSet::num_global_buffers() {
 91   return _num_global_buffers;
 92 }
 93 
 94 void JfrOptionSet::set_num_global_buffers(jlong value) {
 95   _num_global_buffers = value;
 96 }
 97 
 98 jint JfrOptionSet::old_object_queue_size() {
 99   return (jint)_old_object_queue_size;
100 }
101 
102 void JfrOptionSet::set_old_object_queue_size(jlong value) {
103   _old_object_queue_size = value;
104 }
105 
106 u4 JfrOptionSet::stackdepth() {
107   return _stack_depth;
108 }
109 




110 void JfrOptionSet::set_stackdepth(u4 depth) {
111   if (depth &lt; MIN_STACK_DEPTH) {
112     _stack_depth = MIN_STACK_DEPTH;
113   } else if (depth &gt; MAX_STACK_DEPTH) {
114     _stack_depth = MAX_STACK_DEPTH;
115   } else {
116     _stack_depth = depth;
117   }
118 }
119 
120 bool JfrOptionSet::sample_threads() {
121   return _sample_threads == JNI_TRUE;
122 }
123 
124 void JfrOptionSet::set_sample_threads(jboolean sample) {
125   _sample_threads = sample;
126 }
127 
128 bool JfrOptionSet::can_retransform() {
129   return _retransform == JNI_TRUE;
</pre>
<hr />
<pre>
660   }
661   post_process_adjusted_memory_options(options);
662   return true;
663 }
664 
665 bool JfrOptionSet::parse_flight_recorder_option(const JavaVMOption** option, char* delimiter) {
666   assert(option != NULL, &quot;invariant&quot;);
667   assert(delimiter != NULL, &quot;invariant&quot;);
668   assert((*option)-&gt;optionString != NULL, &quot;invariant&quot;);
669   assert(strncmp((*option)-&gt;optionString, &quot;-XX:FlightRecorderOptions&quot;, 25) == 0, &quot;invariant&quot;);
670   if (*delimiter == &#39;\0&#39;) {
671     // -XX:FlightRecorderOptions without any delimiter and values
672   } else {
673     // -XX:FlightRecorderOptions[=|:]
674     // set delimiter to &#39;=&#39;
675     *delimiter = &#39;=&#39;;
676   }
677   return false;
678 }
679 
<span class="line-modified">680 static GrowableArray&lt;const char*&gt;* start_flight_recording_options_array = NULL;</span>
681 
682 bool JfrOptionSet::parse_start_flight_recording_option(const JavaVMOption** option, char* delimiter) {
683   assert(option != NULL, &quot;invariant&quot;);
684   assert(delimiter != NULL, &quot;invariant&quot;);
685   assert((*option)-&gt;optionString != NULL, &quot;invariant&quot;);
686   assert(strncmp((*option)-&gt;optionString, &quot;-XX:StartFlightRecording&quot;, 24) == 0, &quot;invariant&quot;);
687   const char* value = NULL;
688   if (*delimiter == &#39;\0&#39;) {
689     // -XX:StartFlightRecording without any delimiter and values
690     // Add dummy value &quot;dumponexit=false&quot; so -XX:StartFlightRecording can be used without explicit values.
691     // The existing option-&gt;optionString points to stack memory so no need to deallocate.
692     const_cast&lt;JavaVMOption*&gt;(*option)-&gt;optionString = (char*)&quot;-XX:StartFlightRecording=dumponexit=false&quot;;
693     value = (*option)-&gt;optionString + 25;
694   } else {
695     // -XX:StartFlightRecording[=|:]
696     // set delimiter to &#39;=&#39;
697     *delimiter = &#39;=&#39;;
698     value = delimiter + 1;
699   }
700   assert(value != NULL, &quot;invariant&quot;);
701   const size_t value_length = strlen(value);
702 
<span class="line-modified">703   if (start_flight_recording_options_array == NULL) {</span>
<span class="line-modified">704     start_flight_recording_options_array = new (ResourceObj::C_HEAP, mtTracing) GrowableArray&lt;const char*&gt;(8, true, mtTracing);</span>
705   }
<span class="line-modified">706   assert(start_flight_recording_options_array != NULL, &quot;invariant&quot;);</span>
707   char* const startup_value = NEW_C_HEAP_ARRAY(char, value_length + 1, mtTracing);
708   strncpy(startup_value, value, value_length + 1);
709   assert(strncmp(startup_value, value, value_length) == 0, &quot;invariant&quot;);
<span class="line-modified">710   start_flight_recording_options_array-&gt;append(startup_value);</span>
711   return false;
712 }
713 
<span class="line-modified">714 const GrowableArray&lt;const char*&gt;* JfrOptionSet::start_flight_recording_options() {</span>
<span class="line-modified">715   return start_flight_recording_options_array;</span>
716 }
717 
<span class="line-modified">718 void JfrOptionSet::release_start_flight_recording_options() {</span>
<span class="line-modified">719   if (start_flight_recording_options_array != NULL) {</span>
<span class="line-modified">720     const int length = start_flight_recording_options_array-&gt;length();</span>
721     for (int i = 0; i &lt; length; ++i) {
<span class="line-modified">722       FREE_C_HEAP_ARRAY(char, start_flight_recording_options_array-&gt;at(i));</span>
723     }
<span class="line-modified">724     delete start_flight_recording_options_array;</span>
<span class="line-modified">725     start_flight_recording_options_array = NULL;</span>
726   }
727 }
</pre>
</td>
</tr>
</table>
<center><a href="../repository/jfrRepository.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrOptionSet.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
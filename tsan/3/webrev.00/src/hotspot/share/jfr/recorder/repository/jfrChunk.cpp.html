<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/jfr/recorder/repository/jfrChunk.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/recorder/repository/jfrChunk.hpp&quot;
 27 #include &quot;jfr/recorder/service/jfrOptionSet.hpp&quot;
 28 #include &quot;jfr/utilities/jfrTime.hpp&quot;
 29 #include &quot;jfr/utilities/jfrTimeConverter.hpp&quot;
 30 #include &quot;jfr/utilities/jfrTypes.hpp&quot;
 31 #include &quot;runtime/os.inline.hpp&quot;
 32 
 33 static const char* const MAGIC = &quot;FLR&quot;;
 34 static const u2 JFR_VERSION_MAJOR = 2;
 35 static const u2 JFR_VERSION_MINOR = 1;
 36 
 37 // strictly monotone
 38 static jlong nanos_now() {
 39   static jlong last = 0;
 40   // We use javaTimeMillis so this can be correlated with
 41   // external timestamps.
 42   const jlong now = os::javaTimeMillis() * JfrTimeConverter::NANOS_PER_MILLISEC;
 43   if (now &gt; last) {
 44     last = now;
 45   } else {
 46     ++last;
 47   }
 48   return last;
 49 }
 50 
 51 static jlong ticks_now() {
 52   return JfrTicks::now();
 53 }
 54 
 55 JfrChunk::JfrChunk() :
 56   _path(NULL),
 57   _start_ticks(0),
 58   _previous_start_ticks(invalid_time),
 59   _start_nanos(0),
 60   _previous_start_nanos(invalid_time),
 61   _last_update_nanos(0),
 62   _last_checkpoint_offset(0),
 63   _last_metadata_offset(0),
 64   _generation(1),
 65   _final(false) {}
 66 
 67 JfrChunk::~JfrChunk() {
 68   reset();
 69 }
 70 
 71 void JfrChunk::reset() {
 72   if (_path != NULL) {
 73     JfrCHeapObj::free(_path, strlen(_path) + 1);
 74     _path = NULL;
 75   }
 76   _last_checkpoint_offset = _last_metadata_offset = 0;
 77   _generation = 1;
 78 }
 79 
 80 const char* JfrChunk::magic() const {
 81   return MAGIC;
 82 }
 83 
 84 u2 JfrChunk::major_version() const {
 85   return JFR_VERSION_MAJOR;
 86 }
 87 
 88 u2 JfrChunk::minor_version() const {
 89   return JFR_VERSION_MINOR;
 90 }
 91 
 92 void JfrChunk::mark_final() {
 93   _final = true;
 94 }
 95 
 96 u2 JfrChunk::flags() const {
 97   // chunk capabilities, CompressedIntegers etc
 98   u2 flags = 0;
 99   if (JfrOptionSet::compressed_integers()) {
100     flags |= 1 &lt;&lt; 0;
101   }
102   if (_final) {
103     flags |= 1 &lt;&lt; 1;
104   }
105   return flags;
106 }
107 
108 int64_t JfrChunk::cpu_frequency() const {
109   static const jlong frequency = JfrTime::frequency();
110   return frequency;
111 }
112 
113 void JfrChunk::set_last_checkpoint_offset(int64_t offset) {
114   _last_checkpoint_offset = offset;
115 }
116 
117 int64_t JfrChunk::last_checkpoint_offset() const {
118   return _last_checkpoint_offset;
119 }
120 
121 int64_t JfrChunk::start_ticks() const {
122   assert(_start_ticks != 0, &quot;invariant&quot;);
123   return _start_ticks;
124 }
125 
126 int64_t JfrChunk::start_nanos() const {
127   assert(_start_nanos != 0, &quot;invariant&quot;);
128   return _start_nanos;
129 }
130 
131 int64_t JfrChunk::previous_start_ticks() const {
132   assert(_previous_start_ticks != invalid_time, &quot;invariant&quot;);
133   return _previous_start_ticks;
134 }
135 
136 int64_t JfrChunk::previous_start_nanos() const {
137   assert(_previous_start_nanos != invalid_time, &quot;invariant&quot;);
138   return _previous_start_nanos;
139 }
140 
141 void JfrChunk::update_start_ticks() {
142   _start_ticks = ticks_now();
143 }
144 
145 void JfrChunk::update_start_nanos() {
146   const jlong now = nanos_now();
147   assert(now &gt; _start_nanos, &quot;invariant&quot;);
148   assert(now &gt; _last_update_nanos, &quot;invariant&quot;);
149   _start_nanos = _last_update_nanos = now;
150 }
151 
152 void JfrChunk::update_current_nanos() {
153   const jlong now = nanos_now();
154   assert(now &gt; _last_update_nanos, &quot;invariant&quot;);
155   _last_update_nanos = now;
156 }
157 
158 void JfrChunk::save_current_and_update_start_ticks() {
159   _previous_start_ticks = _start_ticks;
160   update_start_ticks();
161 }
162 
163 void JfrChunk::save_current_and_update_start_nanos() {
164   _previous_start_nanos = _start_nanos;
165   update_start_nanos();
166 }
167 
168 void JfrChunk::set_time_stamp() {
169   save_current_and_update_start_nanos();
170   save_current_and_update_start_ticks();
171 }
172 
173 int64_t JfrChunk::last_chunk_duration() const {
174   assert(_previous_start_nanos != invalid_time, &quot;invariant&quot;);
175   return _start_nanos - _previous_start_nanos;
176 }
177 
178 static char* copy_path(const char* path) {
179   assert(path != NULL, &quot;invariant&quot;);
180   const size_t path_len = strlen(path);
181   char* new_path = JfrCHeapObj::new_array&lt;char&gt;(path_len + 1);
182   strncpy(new_path, path, path_len + 1);
183   return new_path;
184 }
185 
186 void JfrChunk::set_path(const char* path) {
187   if (_path != NULL) {
188     JfrCHeapObj::free(_path, strlen(_path) + 1);
189     _path = NULL;
190   }
191   if (path != NULL) {
192     _path = copy_path(path);
193   }
194 }
195 
196 const char* JfrChunk::path() const {
197   return _path;
198 }
199 
200 bool JfrChunk::is_started() const {
201   return _start_nanos != 0;
202 }
203 
204 bool JfrChunk::is_finished() const {
205   return 0 == _generation;
206 }
207 
208 int64_t JfrChunk::duration() const {
209   assert(_last_update_nanos &gt;= _start_nanos, &quot;invariant&quot;);
210   return _last_update_nanos - _start_nanos;
211 }
212 
213 int64_t JfrChunk::last_metadata_offset() const {
214   return _last_metadata_offset;
215 }
216 
217 void JfrChunk::set_last_metadata_offset(int64_t offset) {
218   assert(offset &gt; _last_metadata_offset, &quot;invariant&quot;);
219   _last_metadata_offset = offset;
220 }
221 
222 bool JfrChunk::has_metadata() const {
223   return 0 != _last_metadata_offset;
224 }
225 
226 u1 JfrChunk::generation() const {
227   assert(_generation &gt; 0, &quot;invariant&quot;);
228   const u1 this_generation = _generation++;
229   if (GUARD == _generation) {
230     _generation = 1;
231   }
232   return this_generation;
233 }
234 
235 u1 JfrChunk::next_generation() const {
236   assert(_generation &gt; 0, &quot;invariant&quot;);
237   const u1 next_gen = _generation;
238   return GUARD == next_gen ? 1 : next_gen;
239 }
    </pre>
  </body>
</html>
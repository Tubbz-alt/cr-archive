<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/recorder/checkpoint/types/jfrThreadGroup.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../jfrMetadataEvent.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="jfrThreadState.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/checkpoint/types/jfrThreadGroup.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/recorder/checkpoint/jfrCheckpointWriter.hpp&quot;
 27 #include &quot;jfr/recorder/checkpoint/types/jfrThreadGroup.hpp&quot;
<span class="line-removed"> 28 #include &quot;jfr/utilities/jfrResourceManager.hpp&quot;</span>
 29 #include &quot;jfr/utilities/jfrTypes.hpp&quot;
 30 #include &quot;runtime/handles.inline.hpp&quot;
 31 #include &quot;runtime/jniHandles.inline.hpp&quot;
 32 #include &quot;runtime/safepoint.hpp&quot;
 33 #include &quot;runtime/semaphore.hpp&quot;
 34 #include &quot;utilities/growableArray.hpp&quot;
 35 


 36 class ThreadGroupExclusiveAccess : public StackObj {
 37  private:
 38   static Semaphore _mutex_semaphore;
 39  public:
 40   ThreadGroupExclusiveAccess() { _mutex_semaphore.wait(); }
 41   ~ThreadGroupExclusiveAccess() { _mutex_semaphore.signal(); }
 42 };
 43 
 44 Semaphore ThreadGroupExclusiveAccess::_mutex_semaphore(1);
 45 JfrThreadGroup* JfrThreadGroup::_instance = NULL;
 46 
 47 class JfrThreadGroupPointers : public ResourceObj {
 48  private:
 49   const Handle _thread_group_handle;
 50   jweak _thread_group_weak_ref;
 51  public:
 52   JfrThreadGroupPointers(Handle thread_group_handle, jweak thread_group_weak_ref);
 53   Handle thread_group_handle() const;
 54   jweak thread_group_weak_ref() const;
 55   oopDesc* const thread_group_oop() const;
</pre>
<hr />
<pre>
240     size_t len = strlen(tgname);
241     _thread_group_name = JfrCHeapObj::new_array&lt;char&gt;(len + 1);
242     strncpy(_thread_group_name, tgname, len + 1);
243   }
244 }
245 
246 const oop JfrThreadGroup::JfrThreadGroupEntry::thread_group() const {
247   return _thread_group_weak_ref != NULL ? JNIHandles::resolve(_thread_group_weak_ref) : _thread_group_oop;
248 }
249 
250 void JfrThreadGroup::JfrThreadGroupEntry::set_thread_group(JfrThreadGroupPointers&amp; ptrs) {
251   _thread_group_weak_ref = ptrs.transfer_weak_global_handle_ownership();
252   if (_thread_group_weak_ref == NULL) {
253     _thread_group_oop = ptrs.thread_group_oop();
254     assert(_thread_group_oop != NULL, &quot;invariant&quot;);
255   } else {
256     _thread_group_oop = NULL;
257   }
258 }
259 
<span class="line-modified">260 JfrThreadGroup::JfrThreadGroup() : _list(NULL) {</span>
<span class="line-modified">261   _list = new (ResourceObj::C_HEAP, mtTracing) GrowableArray&lt;JfrThreadGroupEntry*&gt;(30, true);</span>
<span class="line-removed">262 }</span>
263 
264 JfrThreadGroup::~JfrThreadGroup() {
<span class="line-removed">265   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);</span>
266   if (_list != NULL) {
267     for (int i = 0; i &lt; _list-&gt;length(); i++) {
268       JfrThreadGroupEntry* e = _list-&gt;at(i);
269       delete e;
270     }
271     delete _list;
272   }
273 }
274 
275 JfrThreadGroup* JfrThreadGroup::instance() {
276   return _instance;
277 }
278 
279 void JfrThreadGroup::set_instance(JfrThreadGroup* new_instance) {
280   _instance = new_instance;
281 }
282 
283 traceid JfrThreadGroup::thread_group_id(const JavaThread* jt, Thread* current) {
<span class="line-removed">284   ResourceMark rm(current);</span>
<span class="line-removed">285   HandleMark hm(current);</span>
286   JfrThreadGroupsHelper helper(jt, current);
287   return helper.is_valid() ? thread_group_id_internal(helper) : 0;
288 }
289 
290 traceid JfrThreadGroup::thread_group_id(JavaThread* const jt) {
<span class="line-removed">291   assert(!JfrStream_lock-&gt;owned_by_self(), &quot;holding stream lock but should not hold it here&quot;);</span>
292   return thread_group_id(jt, jt);
293 }
294 
295 traceid JfrThreadGroup::thread_group_id_internal(JfrThreadGroupsHelper&amp; helper) {
296   ThreadGroupExclusiveAccess lock;
297   JfrThreadGroup* tg_instance = instance();
298   if (tg_instance == NULL) {
299     tg_instance = new JfrThreadGroup();
300     if (tg_instance == NULL) {
301       return 0;
302     }
303     set_instance(tg_instance);
304   }
305 
306   JfrThreadGroupEntry* tge = NULL;
307   int parent_thread_group_id = 0;
308   while (helper.has_next()) {
309     JfrThreadGroupPointers&amp; ptrs = helper.next();
310     tge = tg_instance-&gt;find_entry(ptrs);
311     if (NULL == tge) {
</pre>
<hr />
<pre>
379       writer-&gt;write(curtge-&gt;parent_group_id());
380       writer-&gt;write(curtge-&gt;thread_group_name());
381       ++number_of_entries_written;
382       thread_group_id = curtge-&gt;parent_group_id();
383     }
384   }
385   if (number_of_entries_written == 0) {
386     // nothing to write, restore context
387     writer-&gt;set_context(ctx);
388     return;
389   }
390   assert(number_of_entries_written &gt; 0, &quot;invariant&quot;);
391   writer-&gt;write_count(number_of_entries_written, count_offset);
392 }
393 
394 // Write out JfrThreadGroup instance and then delete it
395 void JfrThreadGroup::serialize(JfrCheckpointWriter&amp; writer) {
396   ThreadGroupExclusiveAccess lock;
397   JfrThreadGroup* tg_instance = instance();
398   assert(tg_instance != NULL, &quot;invariant&quot;);
<span class="line-modified">399   ResourceManager&lt;JfrThreadGroup&gt; tg_handle(tg_instance);</span>
<span class="line-removed">400   set_instance(NULL);</span>
<span class="line-removed">401   tg_handle-&gt;write_thread_group_entries(writer);</span>
402 }
403 
404 // for writing a particular thread group
405 void JfrThreadGroup::serialize(JfrCheckpointWriter* writer, traceid thread_group_id) {
406   assert(writer != NULL, &quot;invariant&quot;);
407   ThreadGroupExclusiveAccess lock;
408   JfrThreadGroup* const tg_instance = instance();
409   assert(tg_instance != NULL, &quot;invariant&quot;);
410   tg_instance-&gt;write_selective_thread_group(writer, thread_group_id);
411 }
</pre>
</td>
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/recorder/checkpoint/jfrCheckpointWriter.hpp&quot;
 27 #include &quot;jfr/recorder/checkpoint/types/jfrThreadGroup.hpp&quot;

 28 #include &quot;jfr/utilities/jfrTypes.hpp&quot;
 29 #include &quot;runtime/handles.inline.hpp&quot;
 30 #include &quot;runtime/jniHandles.inline.hpp&quot;
 31 #include &quot;runtime/safepoint.hpp&quot;
 32 #include &quot;runtime/semaphore.hpp&quot;
 33 #include &quot;utilities/growableArray.hpp&quot;
 34 
<span class="line-added"> 35 static const int initial_array_size = 30;</span>
<span class="line-added"> 36 </span>
 37 class ThreadGroupExclusiveAccess : public StackObj {
 38  private:
 39   static Semaphore _mutex_semaphore;
 40  public:
 41   ThreadGroupExclusiveAccess() { _mutex_semaphore.wait(); }
 42   ~ThreadGroupExclusiveAccess() { _mutex_semaphore.signal(); }
 43 };
 44 
 45 Semaphore ThreadGroupExclusiveAccess::_mutex_semaphore(1);
 46 JfrThreadGroup* JfrThreadGroup::_instance = NULL;
 47 
 48 class JfrThreadGroupPointers : public ResourceObj {
 49  private:
 50   const Handle _thread_group_handle;
 51   jweak _thread_group_weak_ref;
 52  public:
 53   JfrThreadGroupPointers(Handle thread_group_handle, jweak thread_group_weak_ref);
 54   Handle thread_group_handle() const;
 55   jweak thread_group_weak_ref() const;
 56   oopDesc* const thread_group_oop() const;
</pre>
<hr />
<pre>
241     size_t len = strlen(tgname);
242     _thread_group_name = JfrCHeapObj::new_array&lt;char&gt;(len + 1);
243     strncpy(_thread_group_name, tgname, len + 1);
244   }
245 }
246 
247 const oop JfrThreadGroup::JfrThreadGroupEntry::thread_group() const {
248   return _thread_group_weak_ref != NULL ? JNIHandles::resolve(_thread_group_weak_ref) : _thread_group_oop;
249 }
250 
251 void JfrThreadGroup::JfrThreadGroupEntry::set_thread_group(JfrThreadGroupPointers&amp; ptrs) {
252   _thread_group_weak_ref = ptrs.transfer_weak_global_handle_ownership();
253   if (_thread_group_weak_ref == NULL) {
254     _thread_group_oop = ptrs.thread_group_oop();
255     assert(_thread_group_oop != NULL, &quot;invariant&quot;);
256   } else {
257     _thread_group_oop = NULL;
258   }
259 }
260 
<span class="line-modified">261 JfrThreadGroup::JfrThreadGroup() :</span>
<span class="line-modified">262   _list(new (ResourceObj::C_HEAP, mtTracing) GrowableArray&lt;JfrThreadGroupEntry*&gt;(initial_array_size, true, mtTracing)) {}</span>

263 
264 JfrThreadGroup::~JfrThreadGroup() {

265   if (_list != NULL) {
266     for (int i = 0; i &lt; _list-&gt;length(); i++) {
267       JfrThreadGroupEntry* e = _list-&gt;at(i);
268       delete e;
269     }
270     delete _list;
271   }
272 }
273 
274 JfrThreadGroup* JfrThreadGroup::instance() {
275   return _instance;
276 }
277 
278 void JfrThreadGroup::set_instance(JfrThreadGroup* new_instance) {
279   _instance = new_instance;
280 }
281 
282 traceid JfrThreadGroup::thread_group_id(const JavaThread* jt, Thread* current) {


283   JfrThreadGroupsHelper helper(jt, current);
284   return helper.is_valid() ? thread_group_id_internal(helper) : 0;
285 }
286 
287 traceid JfrThreadGroup::thread_group_id(JavaThread* const jt) {

288   return thread_group_id(jt, jt);
289 }
290 
291 traceid JfrThreadGroup::thread_group_id_internal(JfrThreadGroupsHelper&amp; helper) {
292   ThreadGroupExclusiveAccess lock;
293   JfrThreadGroup* tg_instance = instance();
294   if (tg_instance == NULL) {
295     tg_instance = new JfrThreadGroup();
296     if (tg_instance == NULL) {
297       return 0;
298     }
299     set_instance(tg_instance);
300   }
301 
302   JfrThreadGroupEntry* tge = NULL;
303   int parent_thread_group_id = 0;
304   while (helper.has_next()) {
305     JfrThreadGroupPointers&amp; ptrs = helper.next();
306     tge = tg_instance-&gt;find_entry(ptrs);
307     if (NULL == tge) {
</pre>
<hr />
<pre>
375       writer-&gt;write(curtge-&gt;parent_group_id());
376       writer-&gt;write(curtge-&gt;thread_group_name());
377       ++number_of_entries_written;
378       thread_group_id = curtge-&gt;parent_group_id();
379     }
380   }
381   if (number_of_entries_written == 0) {
382     // nothing to write, restore context
383     writer-&gt;set_context(ctx);
384     return;
385   }
386   assert(number_of_entries_written &gt; 0, &quot;invariant&quot;);
387   writer-&gt;write_count(number_of_entries_written, count_offset);
388 }
389 
390 // Write out JfrThreadGroup instance and then delete it
391 void JfrThreadGroup::serialize(JfrCheckpointWriter&amp; writer) {
392   ThreadGroupExclusiveAccess lock;
393   JfrThreadGroup* tg_instance = instance();
394   assert(tg_instance != NULL, &quot;invariant&quot;);
<span class="line-modified">395   tg_instance-&gt;write_thread_group_entries(writer);</span>


396 }
397 
398 // for writing a particular thread group
399 void JfrThreadGroup::serialize(JfrCheckpointWriter* writer, traceid thread_group_id) {
400   assert(writer != NULL, &quot;invariant&quot;);
401   ThreadGroupExclusiveAccess lock;
402   JfrThreadGroup* const tg_instance = instance();
403   assert(tg_instance != NULL, &quot;invariant&quot;);
404   tg_instance-&gt;write_selective_thread_group(writer, thread_group_id);
405 }
</pre>
</td>
</tr>
</table>
<center><a href="../jfrMetadataEvent.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="jfrThreadState.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
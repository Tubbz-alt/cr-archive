<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/jfr/recorder/storage/jfrMemorySpace.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_JFR_RECORDER_STORAGE_JFRMEMORYSPACE_INLINE_HPP
 26 #define SHARE_JFR_RECORDER_STORAGE_JFRMEMORYSPACE_INLINE_HPP
 27 
 28 #include &quot;jfr/recorder/storage/jfrMemorySpace.hpp&quot;
 29 #include &quot;runtime/os.hpp&quot;
 30 
 31 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;
 32 JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::
 33 JfrMemorySpace(size_t min_elem_size, size_t limit_size, size_t cache_count, Callback* callback) :
 34   _free(),
 35   _full(),
 36   _min_elem_size(min_elem_size),
 37   _limit_size(limit_size),
 38   _cache_count(cache_count),
 39   _callback(callback) {}
 40 
 41 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;
 42 JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::~JfrMemorySpace() {
 43   Iterator full_iter(_full);
 44   while (full_iter.has_next()) {
 45     Type* t = full_iter.next();
 46     _full.remove(t);
 47     deallocate(t);
 48   }
 49   Iterator free_iter(_free);
 50   while (free_iter.has_next()) {
 51     Type* t = free_iter.next();
 52     _free.remove(t);
 53     deallocate(t);
 54   }
 55 }
 56 
 57 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;
 58 bool JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::initialize() {
 59   assert(_min_elem_size % os::vm_page_size() == 0, &quot;invariant&quot;);
 60   assert(_limit_size % os::vm_page_size() == 0, &quot;invariant&quot;);
 61   // pre-allocate cache elements
 62   for (size_t i = 0; i &lt; _cache_count; ++i) {
 63     Type* const t = allocate(_min_elem_size);
 64     if (t == NULL) {
 65       return false;
 66     }
 67     insert_free_head(t);
 68   }
 69   assert(_free.count() == _cache_count, &quot;invariant&quot;);
 70   return true;
 71 }
 72 
 73 // allocations are even multiples of the mspace min size
 74 static inline size_t align_allocation_size(size_t requested_size, size_t min_elem_size) {
 75   assert((int)min_elem_size % os::vm_page_size() == 0, &quot;invariant&quot;);
 76   u8 alloc_size_bytes = min_elem_size;
 77   while (requested_size &gt; alloc_size_bytes) {
 78     alloc_size_bytes &lt;&lt;= 1;
 79   }
 80   assert((int)alloc_size_bytes % os::vm_page_size() == 0, &quot;invariant&quot;);
 81   return (size_t)alloc_size_bytes;
 82 }
 83 
 84 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;
 85 inline T* JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::allocate(size_t size) {
 86   const size_t aligned_size_bytes = align_allocation_size(size, _min_elem_size);
 87   void* const allocation = JfrCHeapObj::new_array&lt;u1&gt;(aligned_size_bytes + sizeof(T));
 88   if (allocation == NULL) {
 89     return NULL;
 90   }
 91   T* const t = new (allocation) T;
 92   assert(t != NULL, &quot;invariant&quot;);
 93   if (!t-&gt;initialize(sizeof(T), aligned_size_bytes)) {
 94     JfrCHeapObj::free(t, aligned_size_bytes + sizeof(T));
 95     return NULL;
 96   }
 97   return t;
 98 }
 99 
100 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;
101 inline void JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::deallocate(T* t) {
102   assert(t != NULL, &quot;invariant&quot;);
103   assert(!_free.in_list(t), &quot;invariant&quot;);
104   assert(!_full.in_list(t), &quot;invariant&quot;);
105   assert(t != NULL, &quot;invariant&quot;);
106   JfrCHeapObj::free(t, t-&gt;total_size());
107 }
108 
109 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;
110 inline void JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::release_full(T* t) {
111   assert(is_locked(), &quot;invariant&quot;);
112   assert(t != NULL, &quot;invariant&quot;);
113   assert(_full.in_list(t), &quot;invariant&quot;);
114   remove_full(t);
115   assert(!_full.in_list(t), &quot;invariant&quot;);
116   if (t-&gt;transient()) {
117     deallocate(t);
118     return;
119   }
120   assert(t-&gt;empty(), &quot;invariant&quot;);
121   assert(!t-&gt;retired(), &quot;invariant&quot;);
122   assert(t-&gt;identity() == NULL, &quot;invariant&quot;);
123   if (should_populate_cache()) {
124     assert(!_free.in_list(t), &quot;invariant&quot;);
125     insert_free_head(t);
126   } else {
127     deallocate(t);
128   }
129 }
130 
131 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;
132 inline void JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::release_free(T* t) {
133   assert(is_locked(), &quot;invariant&quot;);
134   assert(t != NULL, &quot;invariant&quot;);
135   assert(_free.in_list(t), &quot;invariant&quot;);
136   if (t-&gt;transient()) {
137     remove_free(t);
138     assert(!_free.in_list(t), &quot;invariant&quot;);
139     deallocate(t);
140     return;
141   }
142   assert(t-&gt;empty(), &quot;invariant&quot;);
143   assert(!t-&gt;retired(), &quot;invariant&quot;);
144   assert(!t-&gt;excluded(), &quot;invariant&quot;);
145   assert(t-&gt;identity() == NULL, &quot;invariant&quot;);
146   if (!should_populate_cache()) {
147     remove_free(t);
148     assert(!_free.in_list(t), &quot;invariant&quot;);
149     deallocate(t);
150   }
151 }
152 
153 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;
154 template &lt;typename IteratorCallback, typename IteratorType&gt;
155 inline void JfrMemorySpace&lt;T, RetrievalType, Callback&gt;
156 ::iterate(IteratorCallback&amp; callback, bool full, jfr_iter_direction direction) {
157   IteratorType iterator(full ? _full : _free, direction);
158   while (iterator.has_next()) {
159     callback.process(iterator.next());
160   }
161 }
162 
163 template &lt;typename Mspace, typename Callback&gt;
164 static inline Mspace* create_mspace(size_t buffer_size, size_t limit, size_t cache_count, Callback* cb) {
165   Mspace* const mspace = new Mspace(buffer_size, limit, cache_count, cb);
166   if (mspace != NULL) {
167     mspace-&gt;initialize();
168   }
169   return mspace;
170 }
171 
172 template &lt;typename Mspace&gt;
173 inline size_t size_adjustment(size_t size, Mspace* mspace) {
174   assert(mspace != NULL, &quot;invariant&quot;);
175   static const size_t min_elem_size = mspace-&gt;min_elem_size();
176   if (size &lt; min_elem_size) {
177     size = min_elem_size;
178   }
179   return size;
180 }
181 
182 template &lt;typename Mspace&gt;
183 inline typename Mspace::Type* mspace_allocate(size_t size, Mspace* mspace) {
184   return mspace-&gt;allocate(size_adjustment(size, mspace));
185 }
186 
187 template &lt;typename Mspace&gt;
188 inline typename Mspace::Type* mspace_allocate_acquired(size_t size, Mspace* mspace, Thread* thread) {
189   typename Mspace::Type* const t = mspace_allocate(size, mspace);
190   if (t == NULL) return NULL;
191   t-&gt;acquire(thread);
192   return t;
193 }
194 
195 template &lt;typename Mspace&gt;
196 inline typename Mspace::Type* mspace_allocate_transient(size_t size, Mspace* mspace, Thread* thread) {
197   typename Mspace::Type* const t = mspace_allocate_acquired(size, mspace, thread);
198   if (t == NULL) return NULL;
199   assert(t-&gt;acquired_by_self(), &quot;invariant&quot;);
200   t-&gt;set_transient();
201   return t;
202 }
203 
204 template &lt;typename Mspace&gt;
205 inline typename Mspace::Type* mspace_allocate_transient_lease(size_t size, Mspace* mspace, Thread* thread) {
206   typename Mspace::Type* const t = mspace_allocate_transient(size, mspace, thread);
207   if (t == NULL) return NULL;
208   assert(t-&gt;acquired_by_self(), &quot;invariant&quot;);
209   assert(t-&gt;transient(), &quot;invaiant&quot;);
210   t-&gt;set_lease();
211   return t;
212 }
213 
214 template &lt;typename Mspace&gt;
215 inline typename Mspace::Type* mspace_allocate_to_full(size_t size, Mspace* mspace, Thread* thread) {
216   assert(mspace-&gt;is_locked(), &quot;invariant&quot;);
217   typename Mspace::Type* const t = mspace_allocate_acquired(size, mspace, thread);
218   if (t == NULL) return NULL;
219   mspace-&gt;insert_full_head(t);
220   return t;
221 }
222 
223 template &lt;typename Mspace&gt;
224 class MspaceLock {
225  private:
226   Mspace* _mspace;
227  public:
228   MspaceLock(Mspace* mspace) : _mspace(mspace) { _mspace-&gt;lock(); }
229   ~MspaceLock() { _mspace-&gt;unlock(); }
230 };
231 
232 template &lt;typename Mspace&gt;
233 inline typename Mspace::Type* mspace_allocate_transient_to_full(size_t size, Mspace* mspace, Thread* thread) {
234   typename Mspace::Type* const t = mspace_allocate_transient(size, mspace, thread);
235   if (t == NULL) return NULL;
236   MspaceLock&lt;Mspace&gt; lock(mspace);
237   mspace-&gt;insert_full_head(t);
238   return t;
239 }
240 
241 template &lt;typename Mspace&gt;
242 inline typename Mspace::Type* mspace_allocate_transient_lease_to_full(size_t size, Mspace* mspace, Thread* thread) {
243   typename Mspace::Type* const t = mspace_allocate_transient_lease(size, mspace, thread);
244   if (t == NULL) return NULL;
245   assert(t-&gt;acquired_by_self(), &quot;invariant&quot;);
246   assert(t-&gt;transient(), &quot;invaiant&quot;);
247   assert(t-&gt;lease(), &quot;invariant&quot;);
248   MspaceLock&lt;Mspace&gt; lock(mspace);
249   mspace-&gt;insert_full_head(t);
250   return t;
251 }
252 
253 template &lt;typename Mspace&gt;
254 inline typename Mspace::Type* mspace_allocate_transient_lease_to_free(size_t size, Mspace* mspace, Thread* thread) {
255   typename Mspace::Type* const t = mspace_allocate_transient_lease(size, mspace, thread);
256   if (t == NULL) return NULL;
257   assert(t-&gt;acquired_by_self(), &quot;invariant&quot;);
258   assert(t-&gt;transient(), &quot;invaiant&quot;);
259   assert(t-&gt;lease(), &quot;invariant&quot;);
260   MspaceLock&lt;Mspace&gt; lock(mspace);
261   mspace-&gt;insert_free_head(t);
262   return t;
263 }
264 
265 template &lt;typename Mspace&gt;
266 inline typename Mspace::Type* mspace_get_free(size_t size, Mspace* mspace, Thread* thread) {
267   return mspace-&gt;get(size, thread);
268 }
269 
270 template &lt;typename Mspace&gt;
271 inline typename Mspace::Type* mspace_get_free_with_retry(size_t size, Mspace* mspace, size_t retry_count, Thread* thread) {
272   assert(size &lt;= mspace-&gt;min_elem_size(), &quot;invariant&quot;);
273   for (size_t i = 0; i &lt; retry_count; ++i) {
274     typename Mspace::Type* const t = mspace_get_free(size, mspace, thread);
275     if (t != NULL) {
276       return t;
277     }
278   }
279   return NULL;
280 }
281 
282 template &lt;typename Mspace&gt;
283 inline typename Mspace::Type* mspace_get_free_with_detach(size_t size, Mspace* mspace, Thread* thread) {
284   typename Mspace::Type* t = mspace_get_free(size, mspace, thread);
285   if (t != NULL) {
286     mspace-&gt;remove_free(t);
287   }
288   return t;
289 }
290 
291 template &lt;typename Mspace&gt;
292 inline typename Mspace::Type* mspace_get_free_to_full(size_t size, Mspace* mspace, Thread* thread) {
293   assert(size &lt;= mspace-&gt;min_elem_size(), &quot;invariant&quot;);
294   assert(mspace-&gt;is_locked(), &quot;invariant&quot;);
295   typename Mspace::Type* t = mspace_get_free(size, mspace, thread);
296   if (t == NULL) {
297     return NULL;
298   }
299   assert(t-&gt;acquired_by_self(), &quot;invariant&quot;);
300   move_to_head(t, mspace-&gt;free(), mspace-&gt;full());
301   return t;
302 }
303 
304 template &lt;typename Mspace&gt;
305 inline typename Mspace::Type* mspace_get_to_full(size_t size, Mspace* mspace, Thread* thread) {
306   size = size_adjustment(size, mspace);
307   MspaceLock&lt;Mspace&gt; lock(mspace);
308   if (size &lt;= mspace-&gt;min_elem_size()) {
309     typename Mspace::Type* const t = mspace_get_free_to_full(size, mspace, thread);
310     if (t != NULL) {
311       return t;
312     }
313   }
314   return mspace_allocate_to_full(size, mspace, thread);
315 }
316 
317 template &lt;typename Mspace&gt;
318 inline typename Mspace::Type* mspace_get_free_lease_with_retry(size_t size, Mspace* mspace, size_t retry_count, Thread* thread) {
319   typename Mspace::Type* t = mspace_get_free_with_retry(size, mspace, retry_count, thread);
320   if (t != NULL) {
321     t-&gt;set_lease();
322   }
323   return t;
324 }
325 
326 template &lt;typename Mspace&gt;
327 inline typename Mspace::Type* mspace_get_lease(size_t size, Mspace* mspace, Thread* thread) {
328   typename Mspace::Type* t;
329   t = mspace_get_free_lease(size, mspace, thread);
330   if (t != NULL) {
331     assert(t-&gt;acquired_by_self(), &quot;invariant&quot;);
332     assert(t-&gt;lease(), &quot;invariant&quot;);
333     return t;
334   }
335   t = mspace_allocate_transient_to_full(size, mspace, thread);
336   if (t != NULL) {
337     t-&gt;set_lease();
338   }
339   return t;
340 }
341 
342 template &lt;typename Mspace&gt;
343 inline void mspace_release_full(typename Mspace::Type* t, Mspace* mspace) {
344   assert(t != NULL, &quot;invariant&quot;);
345   assert(t-&gt;unflushed_size() == 0, &quot;invariant&quot;);
346   assert(mspace != NULL, &quot;invariant&quot;);
347   assert(mspace-&gt;is_locked(), &quot;invariant&quot;);
348   mspace-&gt;release_full(t);
349 }
350 
351 template &lt;typename Mspace&gt;
352 inline void mspace_release_free(typename Mspace::Type* t, Mspace* mspace) {
353   assert(t != NULL, &quot;invariant&quot;);
354   assert(t-&gt;unflushed_size() == 0, &quot;invariant&quot;);
355   assert(mspace != NULL, &quot;invariant&quot;);
356   assert(mspace-&gt;is_locked(), &quot;invariant&quot;);
357   mspace-&gt;release_free(t);
358 }
359 
360 template &lt;typename Mspace&gt;
361 inline void mspace_release_full_critical(typename Mspace::Type* t, Mspace* mspace) {
362   MspaceLock&lt;Mspace&gt; lock(mspace);
363   mspace_release_full(t, mspace);
364 }
365 
366 template &lt;typename Mspace&gt;
367 inline void mspace_release_free_critical(typename Mspace::Type* t, Mspace* mspace) {
368   MspaceLock&lt;Mspace&gt; lock(mspace);
369   mspace_release_free(t, mspace);
370 }
371 
372 template &lt;typename List&gt;
373 inline void move_to_head(typename List::Node* t, List&amp; from, List&amp; to) {
374   assert(from.in_list(t), &quot;invariant&quot;);
375   to.prepend(from.remove(t));
376 }
377 
378 template &lt;typename Processor, typename Mspace, typename Iterator&gt;
379 inline void process_free_list_iterator_control(Processor&amp; processor, Mspace* mspace, jfr_iter_direction direction = forward) {
380   mspace-&gt;template iterate&lt;Processor, Iterator&gt;(processor, false, direction);
381 }
382 
383 template &lt;typename Processor, typename Mspace, typename Iterator&gt;
384 inline void process_full_list_iterator_control(Processor&amp; processor, Mspace* mspace, jfr_iter_direction direction = forward) {
385   mspace-&gt;template iterate&lt;Processor, Iterator&gt;(processor, true, direction);
386 }
387 
388 template &lt;typename Processor, typename Mspace&gt;
389 inline void process_full_list(Processor&amp; processor, Mspace* mspace, jfr_iter_direction direction = forward) {
390   assert(mspace != NULL, &quot;invariant&quot;);
391   if (mspace-&gt;is_full_empty()) return;
392   process_full_list_iterator_control&lt;Processor, Mspace, typename Mspace::Iterator&gt;(processor, mspace, direction);
393 }
394 
395 template &lt;typename Processor, typename Mspace&gt;
396 inline void process_free_list(Processor&amp; processor, Mspace* mspace, jfr_iter_direction direction = forward) {
397   assert(mspace != NULL, &quot;invariant&quot;);
398   assert(mspace-&gt;has_free(), &quot;invariant&quot;);
399   process_free_list_iterator_control&lt;Processor, Mspace, typename Mspace::Iterator&gt;(processor, mspace, direction);
400 }
401 
402 template &lt;typename Mspace&gt;
403 class ReleaseOp : public StackObj {
404  private:
405   Mspace* _mspace;
406   Thread* _thread;
407   bool _release_full;
408  public:
409   typedef typename Mspace::Type Type;
410   ReleaseOp(Mspace* mspace, Thread* thread, bool release_full = true) :
411     _mspace(mspace), _thread(thread), _release_full(release_full) {}
412   bool process(Type* t);
413   size_t processed() const { return 0; }
414 };
415 
416 template &lt;typename Mspace&gt;
417 inline bool ReleaseOp&lt;Mspace&gt;::process(typename Mspace::Type* t) {
418   assert(t != NULL, &quot;invariant&quot;);
419   // assumes some means of exclusive access to t
420   if (t-&gt;transient()) {
421     if (_release_full) {
422       mspace_release_full_critical(t, _mspace);
423     } else {
424       mspace_release_free_critical(t, _mspace);
425     }
426     return true;
427   }
428   t-&gt;reinitialize();
429   if (t-&gt;identity() != NULL) {
430     assert(t-&gt;empty(), &quot;invariant&quot;);
431     assert(!t-&gt;retired(), &quot;invariant&quot;);
432     t-&gt;release(); // publish
433   }
434   return true;
435 }
436 
437 #ifdef ASSERT
438 template &lt;typename T&gt;
439 inline void assert_migration_state(const T* old, const T* new_buffer, size_t used, size_t requested) {
440   assert(old != NULL, &quot;invariant&quot;);
441   assert(new_buffer != NULL, &quot;invariant&quot;);
442   assert(old-&gt;pos() &gt;= old-&gt;start(), &quot;invariant&quot;);
443   assert(old-&gt;pos() + used &lt;= old-&gt;end(), &quot;invariant&quot;);
444   assert(new_buffer-&gt;free_size() &gt;= (used + requested), &quot;invariant&quot;);
445 }
446 #endif // ASSERT
447 
448 template &lt;typename T&gt;
449 inline void migrate_outstanding_writes(const T* old, T* new_buffer, size_t used, size_t requested) {
450   DEBUG_ONLY(assert_migration_state(old, new_buffer, used, requested);)
451   if (used &gt; 0) {
452     memcpy(new_buffer-&gt;pos(), old-&gt;pos(), used);
453   }
454 }
455 
456 #endif // SHARE_JFR_RECORDER_STORAGE_JFRMEMORYSPACE_INLINE_HPP
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/jfr/recorder/checkpoint/types/jfrType.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="jfrThreadState.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="jfrType.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/checkpoint/types/jfrType.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 24,27 ***</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;classfile/javaClasses.inline.hpp&quot;
  #include &quot;code/codeBlob.hpp&quot;
  #include &quot;code/codeCache.hpp&quot;
  #include &quot;gc/shared/gcCause.hpp&quot;
  #include &quot;gc/shared/gcName.hpp&quot;
  #include &quot;gc/shared/gcTrace.hpp&quot;
  #include &quot;gc/shared/gcWhen.hpp&quot;
<span class="line-removed">- #include &quot;jfr/leakprofiler/checkpoint/objectSampleCheckpoint.hpp&quot;</span>
  #include &quot;jfr/leakprofiler/leakProfiler.hpp&quot;
<span class="line-modified">! #include &quot;jfr/recorder/checkpoint/jfrCheckpointManager.hpp&quot;</span>
  #include &quot;jfr/recorder/checkpoint/types/jfrType.hpp&quot;
  #include &quot;jfr/recorder/jfrRecorder.hpp&quot;
  #include &quot;jfr/recorder/checkpoint/types/jfrThreadGroup.hpp&quot;
  #include &quot;jfr/recorder/checkpoint/types/jfrThreadState.hpp&quot;
<span class="line-removed">- #include &quot;jfr/recorder/checkpoint/types/jfrTypeSet.hpp&quot;</span>
  #include &quot;jfr/support/jfrThreadLocal.hpp&quot;
  #include &quot;jfr/writers/jfrJavaEventWriter.hpp&quot;
  #include &quot;memory/metaspaceGCThresholdUpdater.hpp&quot;
  #include &quot;memory/referenceType.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
  #include &quot;runtime/flags/jvmFlag.hpp&quot;
  #include &quot;runtime/mutexLocker.hpp&quot;
  #include &quot;runtime/osThread.hpp&quot;
  #include &quot;runtime/safepoint.hpp&quot;
  #include &quot;runtime/synchronizer.hpp&quot;
<span class="line-new-header">--- 24,29 ---</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;classfile/javaClasses.inline.hpp&quot;
  #include &quot;code/codeBlob.hpp&quot;
  #include &quot;code/codeCache.hpp&quot;
<span class="line-added">+ #include &quot;compiler/compilerDefinitions.hpp&quot;</span>
  #include &quot;gc/shared/gcCause.hpp&quot;
  #include &quot;gc/shared/gcName.hpp&quot;
  #include &quot;gc/shared/gcTrace.hpp&quot;
  #include &quot;gc/shared/gcWhen.hpp&quot;
  #include &quot;jfr/leakprofiler/leakProfiler.hpp&quot;
<span class="line-modified">! #include &quot;jfr/recorder/checkpoint/jfrCheckpointWriter.hpp&quot;</span>
  #include &quot;jfr/recorder/checkpoint/types/jfrType.hpp&quot;
  #include &quot;jfr/recorder/jfrRecorder.hpp&quot;
  #include &quot;jfr/recorder/checkpoint/types/jfrThreadGroup.hpp&quot;
  #include &quot;jfr/recorder/checkpoint/types/jfrThreadState.hpp&quot;
  #include &quot;jfr/support/jfrThreadLocal.hpp&quot;
  #include &quot;jfr/writers/jfrJavaEventWriter.hpp&quot;
<span class="line-added">+ #include &quot;jfr/utilities/jfrThreadIterator.hpp&quot;</span>
<span class="line-added">+ #include &quot;memory/iterator.hpp&quot;</span>
  #include &quot;memory/metaspaceGCThresholdUpdater.hpp&quot;
  #include &quot;memory/referenceType.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
<span class="line-added">+ #include &quot;oops/compressedOops.hpp&quot;</span>
  #include &quot;runtime/flags/jvmFlag.hpp&quot;
  #include &quot;runtime/mutexLocker.hpp&quot;
  #include &quot;runtime/osThread.hpp&quot;
  #include &quot;runtime/safepoint.hpp&quot;
  #include &quot;runtime/synchronizer.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 53,14 ***</span>
  
  #ifdef COMPILER2
  #include &quot;opto/compile.hpp&quot;
  #include &quot;opto/node.hpp&quot;
  #endif
<span class="line-removed">- #if INCLUDE_G1GC</span>
<span class="line-removed">- #include &quot;gc/g1/g1HeapRegionTraceType.hpp&quot;</span>
<span class="line-removed">- #include &quot;gc/g1/g1YCTypes.hpp&quot;</span>
<span class="line-removed">- #endif</span>
  
  // Requires a ResourceMark for get_thread_name/as_utf8
  class JfrCheckpointThreadClosure : public ThreadClosure {
   private:
    JfrCheckpointWriter&amp; _writer;
<span class="line-new-header">--- 55,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 87,46 ***</span>
    }
  
    void do_thread(Thread* t);
  };
  
<span class="line-removed">- // Requires a ResourceMark for get_thread_name/as_utf8</span>
  void JfrCheckpointThreadClosure::do_thread(Thread* t) {
    assert(t != NULL, &quot;invariant&quot;);
<span class="line-removed">-   assert_locked_or_safepoint(Threads_lock);</span>
<span class="line-removed">-   const JfrThreadLocal* const tl = t-&gt;jfr_thread_local();</span>
<span class="line-removed">-   assert(tl != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   if (tl-&gt;is_dead()) {</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
    ++_count;
<span class="line-modified">!   _writer.write_key(tl-&gt;thread_id());</span>
<span class="line-modified">!   _writer.write(t-&gt;name());</span>
<span class="line-modified">!   const OSThread* const os_thread = t-&gt;osthread();</span>
<span class="line-modified">!   _writer.write&lt;traceid&gt;(os_thread != NULL ? os_thread-&gt;thread_id() : 0);</span>
    if (t-&gt;is_Java_thread()) {
<span class="line-modified">!     JavaThread* const jt = (JavaThread*)t;</span>
<span class="line-modified">!     _writer.write(jt-&gt;name());</span>
<span class="line-modified">!     _writer.write(java_lang_Thread::thread_id(jt-&gt;threadObj()));</span>
<span class="line-removed">-     _writer.write(JfrThreadGroup::thread_group_id(jt, _curthread));</span>
<span class="line-removed">-     // since we are iterating threads during a safepoint, also issue notification</span>
<span class="line-removed">-     JfrJavaEventWriter::notify(jt);</span>
      return;
    }
    _writer.write((const char*)NULL); // java name
    _writer.write((traceid)0); // java thread id
    _writer.write((traceid)0); // java thread group
  }
  
  void JfrThreadConstantSet::serialize(JfrCheckpointWriter&amp; writer) {
<span class="line-removed">-   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);</span>
    JfrCheckpointThreadClosure tc(writer);
<span class="line-modified">!   Threads::threads_do(&amp;tc);</span>
  }
  
  void JfrThreadGroupConstant::serialize(JfrCheckpointWriter&amp; writer) {
<span class="line-removed">-   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);</span>
    JfrThreadGroup::serialize(writer);
  }
  
  static const char* flag_value_origin_to_string(JVMFlag::Flags origin) {
    switch (origin) {
<span class="line-new-header">--- 85,42 ---</span>
    }
  
    void do_thread(Thread* t);
  };
  
  void JfrCheckpointThreadClosure::do_thread(Thread* t) {
    assert(t != NULL, &quot;invariant&quot;);
    ++_count;
<span class="line-modified">!   _writer.write_key(JfrThreadId::jfr_id(t));</span>
<span class="line-modified">!   const char* const name = JfrThreadName::name(t);</span>
<span class="line-modified">!   assert(name != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   _writer.write(name);</span>
<span class="line-added">+   _writer.write&lt;traceid&gt;(JfrThreadId::os_id(t));</span>
    if (t-&gt;is_Java_thread()) {
<span class="line-modified">!     _writer.write(name);</span>
<span class="line-modified">!     _writer.write(JfrThreadId::id(t));</span>
<span class="line-modified">!     _writer.write(JfrThreadGroup::thread_group_id((JavaThread*)t, _curthread));</span>
      return;
    }
    _writer.write((const char*)NULL); // java name
    _writer.write((traceid)0); // java thread id
    _writer.write((traceid)0); // java thread group
  }
  
  void JfrThreadConstantSet::serialize(JfrCheckpointWriter&amp; writer) {
    JfrCheckpointThreadClosure tc(writer);
<span class="line-modified">!   JfrJavaThreadIterator javathreads;</span>
<span class="line-added">+   while (javathreads.has_next()) {</span>
<span class="line-added">+     tc.do_thread(javathreads.next());</span>
<span class="line-added">+   }</span>
<span class="line-added">+   JfrNonJavaThreadIterator nonjavathreads;</span>
<span class="line-added">+   while (nonjavathreads.has_next()) {</span>
<span class="line-added">+     tc.do_thread(nonjavathreads.next());</span>
<span class="line-added">+   }</span>
  }
  
  void JfrThreadGroupConstant::serialize(JfrCheckpointWriter&amp; writer) {
    JfrThreadGroup::serialize(writer);
  }
  
  static const char* flag_value_origin_to_string(JVMFlag::Flags origin) {
    switch (origin) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 136,10 ***</span>
<span class="line-new-header">--- 130,11 ---</span>
      case JVMFlag::CONFIG_FILE: return &quot;Config file&quot;;
      case JVMFlag::MANAGEMENT: return &quot;Management&quot;;
      case JVMFlag::ERGONOMIC: return &quot;Ergonomic&quot;;
      case JVMFlag::ATTACH_ON_DEMAND: return &quot;Attach on demand&quot;;
      case JVMFlag::INTERNAL: return &quot;Internal&quot;;
<span class="line-added">+     case JVMFlag::JIMAGE_RESOURCE: return &quot;JImage resource&quot;;</span>
      default: ShouldNotReachHere(); return &quot;&quot;;
    }
  }
  
  void FlagValueOriginConstant::serialize(JfrCheckpointWriter&amp; writer) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 185,19 ***</span>
      writer.write_key(i);
      writer.write(GCWhen::to_string((GCWhen::Type)i));
    }
  }
  
<span class="line-removed">- void G1HeapRegionTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-removed">-   static const u4 nof_entries = G1HeapRegionTraceType::G1HeapRegionTypeEndSentinel;</span>
<span class="line-removed">-   writer.write_count(nof_entries);</span>
<span class="line-removed">-   for (u4 i = 0; i &lt; nof_entries; ++i) {</span>
<span class="line-removed">-     writer.write_key(i);</span>
<span class="line-removed">-     writer.write(G1HeapRegionTraceType::to_string((G1HeapRegionTraceType::Type)i));</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void GCThresholdUpdaterConstant::serialize(JfrCheckpointWriter&amp; writer) {
    static const u4 nof_entries = MetaspaceGCThresholdUpdater::Last;
    writer.write_count(nof_entries);
    for (u4 i = 0; i &lt; nof_entries; ++i) {
      writer.write_key(i);
<span class="line-new-header">--- 180,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 221,21 ***</span>
      writer.write_key(i);
      writer.write(MetaspaceObj::type_name((MetaspaceObj::Type)i));
    }
  }
  
<span class="line-removed">- void G1YCTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-removed">- #if INCLUDE_G1GC</span>
<span class="line-removed">-   static const u4 nof_entries = G1YCTypeEndSentinel;</span>
<span class="line-removed">-   writer.write_count(nof_entries);</span>
<span class="line-removed">-   for (u4 i = 0; i &lt; nof_entries; ++i) {</span>
<span class="line-removed">-     writer.write_key(i);</span>
<span class="line-removed">-     writer.write(G1YCTypeHelper::to_string((G1YCType)i));</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  static const char* reference_type_to_string(ReferenceType rt) {
    switch (rt) {
      case REF_NONE: return &quot;None reference&quot;;
      case REF_OTHER: return &quot;Other reference&quot;;
      case REF_SOFT: return &quot;Soft reference&quot;;
<span class="line-new-header">--- 207,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 256,15 ***</span>
      writer.write(reference_type_to_string((ReferenceType)i));
    }
  }
  
  void NarrowOopModeConstant::serialize(JfrCheckpointWriter&amp; writer) {
<span class="line-modified">!   static const u4 nof_entries = Universe::HeapBasedNarrowOop + 1;</span>
    writer.write_count(nof_entries);
    for (u4 i = 0; i &lt; nof_entries; ++i) {
      writer.write_key(i);
<span class="line-modified">!     writer.write(Universe::narrow_oop_mode_to_string((Universe::NARROW_OOP_MODE)i));</span>
    }
  }
  
  void CompilerPhaseTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
  #ifdef COMPILER2
<span class="line-new-header">--- 231,15 ---</span>
      writer.write(reference_type_to_string((ReferenceType)i));
    }
  }
  
  void NarrowOopModeConstant::serialize(JfrCheckpointWriter&amp; writer) {
<span class="line-modified">!   static const u4 nof_entries = CompressedOops::HeapBasedNarrowOop + 1;</span>
    writer.write_count(nof_entries);
    for (u4 i = 0; i &lt; nof_entries; ++i) {
      writer.write_key(i);
<span class="line-modified">!     writer.write(CompressedOops::mode_to_string((CompressedOops::Mode)i));</span>
    }
  }
  
  void CompilerPhaseTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
  #ifdef COMPILER2
</pre>
<hr />
<pre>
<span class="line-old-header">*** 293,61 ***</span>
      writer.write_key(i);
      writer.write(VM_Operation::name(VM_Operation::VMOp_Type(i)));
    }
  }
  
<span class="line-removed">- class TypeSetSerialization {</span>
<span class="line-removed">-  private:</span>
<span class="line-removed">-   bool _class_unload;</span>
<span class="line-removed">-  public:</span>
<span class="line-removed">-   explicit TypeSetSerialization(bool class_unload) : _class_unload(class_unload) {}</span>
<span class="line-removed">-   void write(JfrCheckpointWriter&amp; writer, JfrCheckpointWriter* leakp_writer) {</span>
<span class="line-removed">-     JfrTypeSet::serialize(&amp;writer, leakp_writer, _class_unload);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- void ClassUnloadTypeSet::serialize(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-removed">-   TypeSetSerialization type_set(true);</span>
<span class="line-removed">-   if (LeakProfiler::is_running()) {</span>
<span class="line-removed">-     JfrCheckpointWriter leakp_writer(false, true, Thread::current());</span>
<span class="line-removed">-     type_set.write(writer, &amp;leakp_writer);</span>
<span class="line-removed">-     ObjectSampleCheckpoint::install(leakp_writer, true, true);</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   type_set.write(writer, NULL);</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- void TypeSet::serialize(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-removed">-   TypeSetSerialization type_set(false);</span>
<span class="line-removed">-   if (LeakProfiler::is_suspended()) {</span>
<span class="line-removed">-     JfrCheckpointWriter leakp_writer(false, true, Thread::current());</span>
<span class="line-removed">-     type_set.write(writer, &amp;leakp_writer);</span>
<span class="line-removed">-     ObjectSampleCheckpoint::install(leakp_writer, false, true);</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   type_set.write(writer, NULL);</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
  void ThreadStateConstant::serialize(JfrCheckpointWriter&amp; writer) {
    JfrThreadState::serialize(writer);
  }
  
  void JfrThreadConstant::serialize(JfrCheckpointWriter&amp; writer) {
    assert(_thread != NULL, &quot;invariant&quot;);
    assert(_thread == Thread::current(), &quot;invariant&quot;);
<span class="line-removed">-   assert(_thread-&gt;is_Java_thread(), &quot;invariant&quot;);</span>
<span class="line-removed">-   assert(!_thread-&gt;jfr_thread_local()-&gt;has_thread_checkpoint(), &quot;invariant&quot;);</span>
<span class="line-removed">-   ResourceMark rm(_thread);</span>
<span class="line-removed">-   const oop threadObj = _thread-&gt;threadObj();</span>
<span class="line-removed">-   assert(threadObj != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   const u8 java_lang_thread_id = java_lang_Thread::thread_id(threadObj);</span>
<span class="line-removed">-   const char* const thread_name = _thread-&gt;name();</span>
<span class="line-removed">-   const traceid thread_group_id = JfrThreadGroup::thread_group_id(_thread);</span>
    writer.write_count(1);
<span class="line-modified">!   writer.write_key(_thread-&gt;jfr_thread_local()-&gt;thread_id());</span>
<span class="line-modified">!   writer.write(thread_name);</span>
<span class="line-modified">!   writer.write((traceid)_thread-&gt;osthread()-&gt;thread_id());</span>
<span class="line-modified">!   writer.write(thread_name);</span>
<span class="line-modified">!   writer.write(java_lang_thread_id);</span>
<span class="line-modified">!   writer.write(thread_group_id);</span>
<span class="line-modified">!   JfrThreadGroup::serialize(&amp;writer, thread_group_id);</span>
  }
<span class="line-new-header">--- 268,48 ---</span>
      writer.write_key(i);
      writer.write(VM_Operation::name(VM_Operation::VMOp_Type(i)));
    }
  }
  
  void ThreadStateConstant::serialize(JfrCheckpointWriter&amp; writer) {
    JfrThreadState::serialize(writer);
  }
  
  void JfrThreadConstant::serialize(JfrCheckpointWriter&amp; writer) {
    assert(_thread != NULL, &quot;invariant&quot;);
    assert(_thread == Thread::current(), &quot;invariant&quot;);
    writer.write_count(1);
<span class="line-modified">!   writer.write_key(JfrThreadId::jfr_id(_thread));</span>
<span class="line-modified">!   const char* const name = JfrThreadName::name(_thread);</span>
<span class="line-modified">!   writer.write(name);</span>
<span class="line-modified">!   writer.write(JfrThreadId::os_id(_thread));</span>
<span class="line-modified">!   if (_thread-&gt;is_Java_thread()) {</span>
<span class="line-modified">!     writer.write(name);</span>
<span class="line-modified">!     writer.write(JfrThreadId::id(_thread));</span>
<span class="line-added">+     JavaThread* const jt = (JavaThread*)_thread;</span>
<span class="line-added">+     const traceid thread_group_id = JfrThreadGroup::thread_group_id(jt, jt);</span>
<span class="line-added">+     writer.write(thread_group_id);</span>
<span class="line-added">+     JfrThreadGroup::serialize(&amp;writer, thread_group_id);</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   writer.write((const char*)NULL); // java name</span>
<span class="line-added">+   writer.write((traceid)0); // java thread id</span>
<span class="line-added">+   writer.write((traceid)0); // java thread group</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void BytecodeConstant::serialize(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-added">+   static const u4 nof_entries = Bytecodes::number_of_codes;</span>
<span class="line-added">+   writer.write_count(nof_entries);</span>
<span class="line-added">+   for (u4 i = 0; i &lt; nof_entries; ++i) {</span>
<span class="line-added">+     writer.write_key(i);</span>
<span class="line-added">+     writer.write(Bytecodes::name((Bytecodes::Code)i));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void CompilerTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-added">+   static const u4 nof_entries = compiler_number_of_types;</span>
<span class="line-added">+   writer.write_count(nof_entries);</span>
<span class="line-added">+   for (u4 i = 0; i &lt; nof_entries; ++i) {</span>
<span class="line-added">+     writer.write_key(i);</span>
<span class="line-added">+     writer.write(compilertype2name((CompilerType)i));</span>
<span class="line-added">+   }</span>
  }
</pre>
<center><a href="jfrThreadState.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="jfrType.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/jfr/recorder/service/jfrPostBox.cpp b/src/hotspot/share/jfr/recorder/service/jfrPostBox.cpp
--- a/src/hotspot/share/jfr/recorder/service/jfrPostBox.cpp
+++ b/src/hotspot/share/jfr/recorder/service/jfrPostBox.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -24,18 +24,18 @@
 
 #include "precompiled.hpp"
 #include "jfr/recorder/service/jfrPostBox.hpp"
 #include "jfr/utilities/jfrTryLock.hpp"
 #include "runtime/atomic.hpp"
-#include "runtime/orderAccess.hpp"
 #include "runtime/thread.inline.hpp"
 
 #define MSG_IS_SYNCHRONOUS ( (MSGBIT(MSG_ROTATE)) |          \
                              (MSGBIT(MSG_STOP))   |          \
                              (MSGBIT(MSG_START))  |          \
                              (MSGBIT(MSG_CLONE_IN_MEMORY)) | \
-                             (MSGBIT(MSG_VM_ERROR))          \
+                             (MSGBIT(MSG_VM_ERROR))        | \
+                             (MSGBIT(MSG_FLUSHPOINT))        \
                            )
 
 static JfrPostBox* _instance = NULL;
 
 JfrPostBox& JfrPostBox::instance() {
@@ -82,14 +82,14 @@
   synchronous_post(the_message);
 }
 
 void JfrPostBox::deposit(int new_messages) {
   while (true) {
-    const int current_msgs = OrderAccess::load_acquire(&_messages);
+    const int current_msgs = Atomic::load(&_messages);
     // OR the new message
     const int exchange_value = current_msgs | new_messages;
-    const int result = Atomic::cmpxchg(exchange_value, &_messages, current_msgs);
+    const int result = Atomic::cmpxchg(&_messages, current_msgs, exchange_value);
     if (result == current_msgs) {
       return;
     }
     /* Some other thread just set exactly what this thread wanted */
     if ((result & new_messages) == new_messages) {
@@ -108,18 +108,18 @@
 }
 
 void JfrPostBox::synchronous_post(int msg) {
   assert(is_synchronous(msg), "invariant");
   assert(!JfrMsg_lock->owned_by_self(), "should not hold JfrMsg_lock here!");
-  MutexLockerEx msg_lock(JfrMsg_lock);
+  MonitorLocker msg_lock(JfrMsg_lock);
   deposit(msg);
   // serial_id is used to check when what we send in has been processed.
   // _msg_read_serial is read under JfrMsg_lock protection.
-  const uintptr_t serial_id = OrderAccess::load_acquire(&_msg_read_serial) + 1;
-  JfrMsg_lock->notify_all();
+  const uintptr_t serial_id = Atomic::load(&_msg_read_serial) + 1;
+  msg_lock.notify_all();
   while (!is_message_processed(serial_id)) {
-    JfrMsg_lock->wait();
+    msg_lock.wait();
   }
 }
 
 /*
  * Check if a synchronous message has been processed.
@@ -127,21 +127,21 @@
  * that we are holding the JfrMsg_lock when checking
  * completion status.
  */
 bool JfrPostBox::is_message_processed(uintptr_t serial_id) const {
   assert(JfrMsg_lock->owned_by_self(), "_msg_handled_serial must be read under JfrMsg_lock protection");
-  return serial_id <= OrderAccess::load_acquire(&_msg_handled_serial);
+  return serial_id <= Atomic::load(&_msg_handled_serial);
 }
 
 bool JfrPostBox::is_empty() const {
   assert(JfrMsg_lock->owned_by_self(), "not holding JfrMsg_lock!");
-  return OrderAccess::load_acquire(&_messages) == 0;
+  return Atomic::load(&_messages) == 0;
 }
 
 int JfrPostBox::collect() {
   // get pending and reset to 0
-  const int messages = Atomic::xchg(0, &_messages);
+  const int messages = Atomic::xchg(&_messages, 0);
   if (check_waiters(messages)) {
     _has_waiters = true;
     assert(JfrMsg_lock->owned_by_self(), "incrementing _msg_read_serial is protected by JfrMsg_lock");
     // Update made visible on release of JfrMsg_lock via fence instruction in Monitor::IUnlock.
     ++_msg_read_serial;
@@ -166,8 +166,8 @@
   JfrMsg_lock->notify();
 }
 
 // safeguard to ensure no threads are left waiting
 void JfrPostBox::notify_collection_stop() {
-  MutexLockerEx msg_lock(JfrMsg_lock);
+  MutexLocker msg_lock(JfrMsg_lock);
   JfrMsg_lock->notify_all();
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeManager.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="jfrType.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="jfrTypeManager.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeManager.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -25,23 +25,26 @@</span>
  #include &quot;precompiled.hpp&quot;
  #include &quot;jfr/metadata/jfrSerializer.hpp&quot;
  #include &quot;jfr/recorder/checkpoint/jfrCheckpointWriter.hpp&quot;
  #include &quot;jfr/recorder/checkpoint/types/jfrType.hpp&quot;
  #include &quot;jfr/recorder/checkpoint/types/jfrTypeManager.hpp&quot;
<span class="udiff-line-added">+ #include &quot;jfr/recorder/jfrRecorder.hpp&quot;</span>
  #include &quot;jfr/utilities/jfrDoublyLinkedList.hpp&quot;
  #include &quot;jfr/utilities/jfrIterator.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/resourceArea.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;runtime/handles.inline.hpp&quot;</span>
  #include &quot;runtime/safepoint.hpp&quot;
<span class="udiff-line-added">+ #include &quot;runtime/semaphore.hpp&quot;</span>
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;utilities/exceptions.hpp&quot;
<span class="udiff-line-removed">- #include &quot;runtime/semaphore.hpp&quot;</span>
  
  class JfrSerializerRegistration : public JfrCHeapObj {
   private:
    JfrSerializerRegistration* _next;
    JfrSerializerRegistration* _prev;
    JfrSerializer* _serializer;
<span class="udiff-line-modified-removed">-   mutable JfrCheckpointBlobHandle _cache;</span>
<span class="udiff-line-modified-added">+   mutable JfrBlobHandle _cache;</span>
    JfrTypeId _id;
    bool _permit_cache;
  
   public:
    JfrSerializerRegistration(JfrTypeId id, bool permit_cache, JfrSerializer* serializer) :
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -69,33 +72,75 @@</span>
  
    JfrTypeId id() const {
      return _id;
    }
  
<span class="udiff-line-modified-removed">-   void invoke(JfrCheckpointWriter&amp; writer) const;</span>
<span class="udiff-line-modified-added">+   void on_rotation() const {</span>
<span class="udiff-line-added">+     _serializer-&gt;on_rotation();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void invoke(JfrCheckpointWriter&amp; writer) const {</span>
<span class="udiff-line-added">+     if (_cache.valid()) {</span>
<span class="udiff-line-added">+       writer.increment();</span>
<span class="udiff-line-added">+       _cache-&gt;write(writer);</span>
<span class="udiff-line-added">+       return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     const JfrCheckpointContext ctx = writer.context();</span>
<span class="udiff-line-added">+     // serialize the type id before invoking callback</span>
<span class="udiff-line-added">+     writer.write_type(_id);</span>
<span class="udiff-line-added">+     const intptr_t start = writer.current_offset();</span>
<span class="udiff-line-added">+     // invoke the serializer routine</span>
<span class="udiff-line-added">+     _serializer-&gt;serialize(writer);</span>
<span class="udiff-line-added">+     if (start == writer.current_offset()) {</span>
<span class="udiff-line-added">+       // the serializer implementation did nothing, rewind to restore</span>
<span class="udiff-line-added">+       writer.set_context(ctx);</span>
<span class="udiff-line-added">+       return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if (_permit_cache) {</span>
<span class="udiff-line-added">+       _cache = writer.copy(&amp;ctx);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
  };
  
<span class="udiff-line-modified-removed">- void JfrSerializerRegistration::invoke(JfrCheckpointWriter&amp; writer) const {</span>
<span class="udiff-line-modified-removed">-   if (_cache.valid()) {</span>
<span class="udiff-line-modified-removed">-     writer.increment();</span>
<span class="udiff-line-modified-removed">-     _cache-&gt;write(writer);</span>
<span class="udiff-line-modified-removed">-     return;</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">-   const JfrCheckpointContext ctx = writer.context();</span>
<span class="udiff-line-modified-removed">-   // serialize the type id before invoking callback</span>
<span class="udiff-line-modified-removed">-   writer.write_type(_id);</span>
<span class="udiff-line-modified-removed">-   const intptr_t start = writer.current_offset();</span>
<span class="udiff-line-modified-removed">-   // invoke the serializer routine</span>
<span class="udiff-line-modified-removed">-   _serializer-&gt;serialize(writer);</span>
<span class="udiff-line-modified-removed">-   if (start == writer.current_offset() ) {</span>
<span class="udiff-line-modified-removed">-     // the serializer implementation did nothing, rewind to restore</span>
<span class="udiff-line-modified-removed">-     writer.set_context(ctx);</span>
<span class="udiff-line-modified-removed">-     return;</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">-   if (_permit_cache) {</span>
<span class="udiff-line-modified-removed">-     _cache = writer.copy(&amp;ctx);</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-added">+ static void serialize_threads(JfrCheckpointWriter&amp; writer) {</span>
<span class="udiff-line-modified-added">+   JfrThreadConstantSet thread_set;</span>
<span class="udiff-line-modified-added">+   writer.write_type(TYPE_THREAD);</span>
<span class="udiff-line-modified-added">+   thread_set.serialize(writer);</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ static void serialize_thread_groups(JfrCheckpointWriter&amp; writer) {</span>
<span class="udiff-line-modified-added">+   JfrThreadGroupConstant thread_group_set;</span>
<span class="udiff-line-modified-added">+   writer.write_type(TYPE_THREADGROUP);</span>
<span class="udiff-line-modified-added">+   thread_group_set.serialize(writer);</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ void JfrTypeManager::write_threads(JfrCheckpointWriter&amp; writer) {</span>
<span class="udiff-line-modified-added">+   serialize_threads(writer);</span>
<span class="udiff-line-modified-added">+   serialize_thread_groups(writer);</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ void JfrTypeManager::create_thread_blob(Thread* t) {</span>
<span class="udiff-line-modified-added">+   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-modified-added">+   ResourceMark rm(t);</span>
<span class="udiff-line-added">+   HandleMark hm(t);</span>
<span class="udiff-line-added">+   JfrThreadConstant type_thread(t);</span>
<span class="udiff-line-added">+   JfrCheckpointWriter writer(t, true, THREADS);</span>
<span class="udiff-line-added">+   writer.write_type(TYPE_THREAD);</span>
<span class="udiff-line-added">+   type_thread.serialize(writer);</span>
<span class="udiff-line-added">+   // create and install a checkpoint blob</span>
<span class="udiff-line-added">+   t-&gt;jfr_thread_local()-&gt;set_thread_blob(writer.move());</span>
<span class="udiff-line-added">+   assert(t-&gt;jfr_thread_local()-&gt;has_thread_blob(), &quot;invariant&quot;);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void JfrTypeManager::write_thread_checkpoint(Thread* t) {</span>
<span class="udiff-line-added">+   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-added">+   ResourceMark rm(t);</span>
<span class="udiff-line-added">+   HandleMark hm(t);</span>
<span class="udiff-line-added">+   JfrThreadConstant type_thread(t);</span>
<span class="udiff-line-added">+   JfrCheckpointWriter writer(t, true, THREADS);</span>
<span class="udiff-line-added">+   writer.write_type(TYPE_THREAD);</span>
<span class="udiff-line-added">+   type_thread.serialize(writer);</span>
  }
  
  class SerializerRegistrationGuard : public StackObj {
   private:
    static Semaphore _mutex_semaphore;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -111,83 +156,26 @@</span>
  Semaphore SerializerRegistrationGuard::_mutex_semaphore(1);
  
  typedef JfrDoublyLinkedList&lt;JfrSerializerRegistration&gt; List;
  typedef StopOnNullIterator&lt;const List&gt; Iterator;
  static List types;
<span class="udiff-line-removed">- static List safepoint_types;</span>
  
<span class="udiff-line-modified-removed">- void JfrTypeManager::clear() {</span>
<span class="udiff-line-modified-added">+ void JfrTypeManager::destroy() {</span>
    SerializerRegistrationGuard guard;
    Iterator iter(types);
    JfrSerializerRegistration* registration;
    while (iter.has_next()) {
      registration = types.remove(iter.next());
      assert(registration != NULL, &quot;invariant&quot;);
      delete registration;
    }
<span class="udiff-line-removed">-   Iterator sp_type_iter(safepoint_types);</span>
<span class="udiff-line-removed">-   while (sp_type_iter.has_next()) {</span>
<span class="udiff-line-removed">-     registration = safepoint_types.remove(sp_type_iter.next());</span>
<span class="udiff-line-removed">-     assert(registration != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-     delete registration;</span>
<span class="udiff-line-removed">-   }</span>
  }
  
<span class="udiff-line-modified-removed">- void JfrTypeManager::write_types(JfrCheckpointWriter&amp; writer) {</span>
<span class="udiff-line-modified-added">+ void JfrTypeManager::on_rotation() {</span>
    const Iterator iter(types);
    while (iter.has_next()) {
<span class="udiff-line-modified-removed">-     iter.next()-&gt;invoke(writer);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void JfrTypeManager::write_safepoint_types(JfrCheckpointWriter&amp; writer) {</span>
<span class="udiff-line-removed">-   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   const Iterator iter(safepoint_types);</span>
<span class="udiff-line-removed">-   while (iter.has_next()) {</span>
<span class="udiff-line-removed">-     iter.next()-&gt;invoke(writer);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void JfrTypeManager::write_type_set() {</span>
<span class="udiff-line-removed">-   // can safepoint here because of Module_lock</span>
<span class="udiff-line-removed">-   MutexLockerEx cld_lock(SafepointSynchronize::is_at_safepoint() ? NULL : ClassLoaderDataGraph_lock);</span>
<span class="udiff-line-removed">-   MutexLockerEx lock(SafepointSynchronize::is_at_safepoint() ? NULL : Module_lock);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   JfrCheckpointWriter writer(true, true, Thread::current());</span>
<span class="udiff-line-removed">-   TypeSet set;</span>
<span class="udiff-line-removed">-   set.serialize(writer);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void JfrTypeManager::write_type_set_for_unloaded_classes() {</span>
<span class="udiff-line-removed">-   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);</span>
<span class="udiff-line-removed">-   JfrCheckpointWriter writer(false, true, Thread::current());</span>
<span class="udiff-line-removed">-   ClassUnloadTypeSet class_unload_set;</span>
<span class="udiff-line-removed">-   class_unload_set.serialize(writer);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void JfrTypeManager::create_thread_checkpoint(JavaThread* jt) {</span>
<span class="udiff-line-removed">-   assert(jt != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   JfrThreadConstant type_thread(jt);</span>
<span class="udiff-line-removed">-   JfrCheckpointWriter writer(false, true, jt);</span>
<span class="udiff-line-removed">-   writer.write_type(TYPE_THREAD);</span>
<span class="udiff-line-removed">-   type_thread.serialize(writer);</span>
<span class="udiff-line-removed">-   // create and install a checkpoint blob</span>
<span class="udiff-line-removed">-   jt-&gt;jfr_thread_local()-&gt;set_thread_checkpoint(writer.checkpoint_blob());</span>
<span class="udiff-line-removed">-   assert(jt-&gt;jfr_thread_local()-&gt;has_thread_checkpoint(), &quot;invariant&quot;);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void JfrTypeManager::write_thread_checkpoint(JavaThread* jt) {</span>
<span class="udiff-line-removed">-   assert(jt != NULL, &quot;JavaThread is NULL!&quot;);</span>
<span class="udiff-line-removed">-   ResourceMark rm(jt);</span>
<span class="udiff-line-removed">-   if (jt-&gt;jfr_thread_local()-&gt;has_thread_checkpoint()) {</span>
<span class="udiff-line-removed">-     JfrCheckpointWriter writer(false, false, jt);</span>
<span class="udiff-line-removed">-     jt-&gt;jfr_thread_local()-&gt;thread_checkpoint()-&gt;write(writer);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     JfrThreadConstant type_thread(jt);</span>
<span class="udiff-line-removed">-     JfrCheckpointWriter writer(false, true, jt);</span>
<span class="udiff-line-removed">-     writer.write_type(TYPE_THREAD);</span>
<span class="udiff-line-removed">-     type_thread.serialize(writer);</span>
<span class="udiff-line-modified-added">+     iter.next()-&gt;on_rotation();</span>
    }
  }
  
  #ifdef ASSERT
  static void assert_not_registered_twice(JfrTypeId id, List&amp; list) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -196,56 +184,69 @@</span>
      assert(iter.next()-&gt;id() != id, &quot;invariant&quot;);
    }
  }
  #endif
  
<span class="udiff-line-modified-removed">- static bool register_type(JfrTypeId id, bool require_safepoint, bool permit_cache, JfrSerializer* serializer) {</span>
<span class="udiff-line-modified-added">+ static bool new_registration = false;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static bool register_static_type(JfrTypeId id, bool permit_cache, JfrSerializer* serializer) {</span>
    assert(serializer != NULL, &quot;invariant&quot;);
    JfrSerializerRegistration* const registration = new JfrSerializerRegistration(id, permit_cache, serializer);
    if (registration == NULL) {
      delete serializer;
      return false;
    }
<span class="udiff-line-modified-removed">-   if (require_safepoint) {</span>
<span class="udiff-line-modified-removed">-     assert(!safepoint_types.in_list(registration), &quot;invariant&quot;);</span>
<span class="udiff-line-modified-removed">-     DEBUG_ONLY(assert_not_registered_twice(id, safepoint_types);)</span>
<span class="udiff-line-modified-removed">-     safepoint_types.prepend(registration);</span>
<span class="udiff-line-modified-removed">-   } else {</span>
<span class="udiff-line-modified-removed">-     assert(!types.in_list(registration), &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-     DEBUG_ONLY(assert_not_registered_twice(id, types);)</span>
<span class="udiff-line-removed">-     types.prepend(registration);</span>
<span class="udiff-line-modified-added">+   assert(!types.in_list(registration), &quot;invariant&quot;);</span>
<span class="udiff-line-modified-added">+   DEBUG_ONLY(assert_not_registered_twice(id, types);)</span>
<span class="udiff-line-modified-added">+   if (JfrRecorder::is_recording()) {</span>
<span class="udiff-line-modified-added">+     JfrCheckpointWriter writer(STATICS);</span>
<span class="udiff-line-modified-added">+     registration-&gt;invoke(writer);</span>
<span class="udiff-line-modified-added">+     new_registration = true;</span>
    }
<span class="udiff-line-added">+   types.prepend(registration);</span>
    return true;
  }
  
  bool JfrTypeManager::initialize() {
    SerializerRegistrationGuard guard;
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   // register non-safepointing type serialization</span>
<span class="udiff-line-modified-removed">-   register_type(TYPE_FLAGVALUEORIGIN, false, true, new FlagValueOriginConstant());</span>
<span class="udiff-line-modified-removed">-   register_type(TYPE_INFLATECAUSE, false, true, new MonitorInflateCauseConstant());</span>
<span class="udiff-line-modified-removed">-   register_type(TYPE_GCCAUSE, false, true, new GCCauseConstant());</span>
<span class="udiff-line-modified-removed">-   register_type(TYPE_GCNAME, false, true, new GCNameConstant());</span>
<span class="udiff-line-modified-removed">-   register_type(TYPE_GCWHEN, false, true, new GCWhenConstant());</span>
<span class="udiff-line-modified-removed">-   register_type(TYPE_G1HEAPREGIONTYPE, false, true, new G1HeapRegionTypeConstant());</span>
<span class="udiff-line-modified-removed">-   register_type(TYPE_GCTHRESHOLDUPDATER, false, true, new GCThresholdUpdaterConstant());</span>
<span class="udiff-line-modified-removed">-   register_type(TYPE_METADATATYPE, false, true, new MetadataTypeConstant());</span>
<span class="udiff-line-modified-removed">-   register_type(TYPE_METASPACEOBJECTTYPE, false, true, new MetaspaceObjectTypeConstant());</span>
<span class="udiff-line-modified-removed">-   register_type(TYPE_G1YCTYPE, false, true, new G1YCTypeConstant());</span>
<span class="udiff-line-modified-removed">-   register_type(TYPE_REFERENCETYPE, false, true, new ReferenceTypeConstant());</span>
<span class="udiff-line-modified-removed">-   register_type(TYPE_NARROWOOPMODE, false, true, new NarrowOopModeConstant());</span>
<span class="udiff-line-modified-removed">-   register_type(TYPE_COMPILERPHASETYPE, false, true, new CompilerPhaseTypeConstant());</span>
<span class="udiff-line-modified-removed">-   register_type(TYPE_CODEBLOBTYPE, false, true, new CodeBlobTypeConstant());</span>
<span class="udiff-line-removed">-   register_type(TYPE_VMOPERATIONTYPE, false, true, new VMOperationTypeConstant());</span>
<span class="udiff-line-removed">-   register_type(TYPE_THREADSTATE, false, true, new ThreadStateConstant());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // register safepointing type serialization</span>
<span class="udiff-line-removed">-   register_type(TYPE_THREADGROUP, true, false, new JfrThreadGroupConstant());</span>
<span class="udiff-line-removed">-   register_type(TYPE_THREAD, true, false, new JfrThreadConstantSet());</span>
<span class="udiff-line-modified-added">+   register_static_type(TYPE_FLAGVALUEORIGIN, true, new FlagValueOriginConstant());</span>
<span class="udiff-line-modified-added">+   register_static_type(TYPE_INFLATECAUSE, true, new MonitorInflateCauseConstant());</span>
<span class="udiff-line-modified-added">+   register_static_type(TYPE_GCCAUSE, true, new GCCauseConstant());</span>
<span class="udiff-line-modified-added">+   register_static_type(TYPE_GCNAME, true, new GCNameConstant());</span>
<span class="udiff-line-modified-added">+   register_static_type(TYPE_GCWHEN, true, new GCWhenConstant());</span>
<span class="udiff-line-modified-added">+   register_static_type(TYPE_GCTHRESHOLDUPDATER, true, new GCThresholdUpdaterConstant());</span>
<span class="udiff-line-modified-added">+   register_static_type(TYPE_METADATATYPE, true, new MetadataTypeConstant());</span>
<span class="udiff-line-modified-added">+   register_static_type(TYPE_METASPACEOBJECTTYPE, true, new MetaspaceObjectTypeConstant());</span>
<span class="udiff-line-modified-added">+   register_static_type(TYPE_REFERENCETYPE, true, new ReferenceTypeConstant());</span>
<span class="udiff-line-modified-added">+   register_static_type(TYPE_NARROWOOPMODE, true, new NarrowOopModeConstant());</span>
<span class="udiff-line-modified-added">+   register_static_type(TYPE_COMPILERPHASETYPE, true, new CompilerPhaseTypeConstant());</span>
<span class="udiff-line-modified-added">+   register_static_type(TYPE_CODEBLOBTYPE, true, new CodeBlobTypeConstant());</span>
<span class="udiff-line-modified-added">+   register_static_type(TYPE_VMOPERATIONTYPE, true, new VMOperationTypeConstant());</span>
<span class="udiff-line-modified-added">+   register_static_type(TYPE_THREADSTATE, true, new ThreadStateConstant());</span>
<span class="udiff-line-modified-added">+   register_static_type(TYPE_BYTECODE, true, new BytecodeConstant());</span>
<span class="udiff-line-modified-added">+   register_static_type(TYPE_COMPILERTYPE, true, new CompilerTypeConstant());</span>
    return true;
  }
  
  // implementation for the static registration function exposed in the JfrSerializer api
<span class="udiff-line-modified-removed">- bool JfrSerializer::register_serializer(JfrTypeId id, bool require_safepoint, bool permit_cache, JfrSerializer* serializer) {</span>
<span class="udiff-line-modified-added">+ bool JfrSerializer::register_serializer(JfrTypeId id, bool permit_cache, JfrSerializer* serializer) {</span>
    SerializerRegistrationGuard guard;
<span class="udiff-line-modified-removed">-   return register_type(id, require_safepoint, permit_cache, serializer);</span>
<span class="udiff-line-modified-added">+   return register_static_type(id, permit_cache, serializer);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool JfrTypeManager::has_new_static_type() {</span>
<span class="udiff-line-added">+   if (new_registration) {</span>
<span class="udiff-line-added">+     SerializerRegistrationGuard guard;</span>
<span class="udiff-line-added">+     new_registration = false;</span>
<span class="udiff-line-added">+     return true;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return false;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void JfrTypeManager::write_static_types(JfrCheckpointWriter&amp; writer) {</span>
<span class="udiff-line-added">+   SerializerRegistrationGuard guard;</span>
<span class="udiff-line-added">+   const Iterator iter(types);</span>
<span class="udiff-line-added">+   while (iter.has_next()) {</span>
<span class="udiff-line-added">+     iter.next()-&gt;invoke(writer);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   new_registration = false;</span>
  }
</pre>
<center><a href="jfrType.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="jfrTypeManager.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/jfr/recorder/storage/jfrBuffer.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/recorder/storage/jfrBuffer.hpp&quot;
 27 #include &quot;runtime/thread.inline.hpp&quot;
 28 
 29 static const u1* const TOP_CRITICAL_SECTION = NULL;
 30 
 31 JfrBuffer::JfrBuffer() : _next(NULL),
 32                          _prev(NULL),
 33                          _identity(NULL),
 34                          _pos(NULL),
 35                          _top(NULL),
 36                          _flags(0),
 37                          _header_size(0),
 38                          _size(0) {}
 39 
 40 bool JfrBuffer::initialize(size_t header_size, size_t size) {
 41   assert(_next == NULL, &quot;invariant&quot;);
 42   assert(_identity == NULL, &quot;invariant&quot;);
 43   _header_size = (u2)header_size;
 44   _size = (u4)(size / BytesPerWord);
 45   set_pos(start());
 46   set_top(start());
 47   assert(free_size() == size, &quot;invariant&quot;);
 48   assert(!transient(), &quot;invariant&quot;);
 49   assert(!lease(), &quot;invariant&quot;);
 50   assert(!retired(), &quot;invariant&quot;);
 51   return true;
 52 }
 53 
 54 void JfrBuffer::reinitialize(bool exclusion /* false */) {
 55   acquire_critical_section_top();
 56   assert(!lease(), &quot;invariant&quot;);
 57   assert(!transient(), &quot;invariant&quot;);
 58   if (exclusion != excluded()) {
 59     // update
 60     if (exclusion) {
 61       set_excluded();
 62     } else {
 63       clear_excluded();
 64     }
 65   }
 66   set_pos(start());
 67   release_critical_section_top(start());
 68   clear_retired();
 69 }
 70 
 71 const u1* JfrBuffer::top() const {
 72   return Atomic::load_acquire(&amp;_top);
 73 }
 74 
 75 const u1* JfrBuffer::stable_top() const {
 76   const u1* current_top;
 77   do {
 78     current_top = top();
 79   } while (TOP_CRITICAL_SECTION == current_top);
 80   return current_top;
 81 }
 82 
 83 void JfrBuffer::set_top(const u1* new_top) {
 84   assert(new_top &lt;= end(), &quot;invariant&quot;);
 85   assert(new_top &gt;= start(), &quot;invariant&quot;);
 86   Atomic::release_store(&amp;_top, new_top);
 87 }
 88 
 89 const u1* JfrBuffer::acquire_critical_section_top() const {
 90   do {
 91     const u1* current_top = stable_top();
 92     assert(current_top != TOP_CRITICAL_SECTION, &quot;invariant&quot;);
 93     if (Atomic::cmpxchg(&amp;_top, current_top, TOP_CRITICAL_SECTION) == current_top) {
 94       return current_top;
 95     }
 96   } while (true);
 97 }
 98 
 99 void JfrBuffer::release_critical_section_top(const u1* new_top) {
100   assert(new_top != TOP_CRITICAL_SECTION, &quot;invariant&quot;);
101   assert(top() == TOP_CRITICAL_SECTION, &quot;invariant&quot;);
102   set_top(new_top);
103 }
104 
105 bool JfrBuffer::acquired_by(const void* id) const {
106   return identity() == id;
107 }
108 
109 bool JfrBuffer::acquired_by_self() const {
110   return acquired_by(Thread::current());
111 }
112 
113 void JfrBuffer::acquire(const void* id) {
114   assert(id != NULL, &quot;invariant&quot;);
115   const void* current_id;
116   do {
117     current_id = identity();
118   } while (current_id != NULL || Atomic::cmpxchg(&amp;_identity, current_id, id) != current_id);
119 }
120 
121 bool JfrBuffer::try_acquire(const void* id) {
122   assert(id != NULL, &quot;invariant&quot;);
123   const void* const current_id = identity();
124   return current_id == NULL &amp;&amp; Atomic::cmpxchg(&amp;_identity, current_id, id) == current_id;
125 }
126 
127 void JfrBuffer::release() {
128   assert(identity() != NULL, &quot;invariant&quot;);
129   Atomic::release_store(&amp;_identity, (const void*)NULL);
130 }
131 
132 #ifdef ASSERT
133 static bool validate_to(const JfrBuffer* const to, size_t size) {
134   assert(to != NULL, &quot;invariant&quot;);
135   assert(to-&gt;acquired_by_self(), &quot;invariant&quot;);
136   assert(to-&gt;free_size() &gt;= size, &quot;invariant&quot;);
137   return true;
138 }
139 
140 static bool validate_this(const JfrBuffer* const t, size_t size) {
141   assert(t-&gt;acquired_by_self(), &quot;invariant&quot;);
142   assert(t-&gt;top() == TOP_CRITICAL_SECTION, &quot;invariant&quot;);
143   return true;
144 }
145 #endif // ASSERT
146 
147 void JfrBuffer::move(JfrBuffer* const to, size_t size) {
148   assert(validate_to(to, size), &quot;invariant&quot;);
149   const u1* const current_top = acquire_critical_section_top();
150   assert(validate_this(this, size), &quot;invariant&quot;);
151   const size_t actual_size = pos() - current_top;
152   assert(actual_size &lt;= size, &quot;invariant&quot;);
153   if (actual_size &gt; 0) {
154     memcpy(to-&gt;pos(), current_top, actual_size);
155     to-&gt;set_pos(actual_size);
156   }
157   to-&gt;release();
158   set_pos(start());
159   release_critical_section_top(start());
160 }
161 
162 size_t JfrBuffer::discard() {
163   const u1* const position = pos();
164   // stable_top() provides acquire semantics for pos()
165   const u1* const current_top = stable_top();
166   set_top(position);
167   return position - current_top;
168 }
169 
170 size_t JfrBuffer::unflushed_size() const {
171   const u1* const position = pos();
172   // stable_top() provides acquire semantics for pos()
173   return position - stable_top();
174 }
175 
176 enum FLAG {
177   RETIRED = 1,
178   TRANSIENT = 2,
179   LEASE = 4,
180   EXCLUDED = 8
181 };
182 
183 inline u2 load(const volatile u2* flags) {
184   assert(flags != NULL, &quot;invariant&quot;);
185   return Atomic::load_acquire(flags);
186 }
187 
188 inline void set(u2* flags, FLAG flag) {
189   assert(flags != NULL, &quot;invariant&quot;);
190   OrderAccess::storestore();
191   *flags |= (u1)flag;
192 }
193 
194 inline void clear(u2* flags, FLAG flag) {
195   assert(flags != NULL, &quot;invariant&quot;);
196   OrderAccess::storestore();
197   *flags ^= (u1)flag;
198 }
199 
200 inline bool test(const u2* flags, FLAG flag) {
201   return (u1)flag == (load(flags) &amp; (u1)flag);
202 }
203 
204 bool JfrBuffer::transient() const {
205   return test(&amp;_flags, TRANSIENT);
206 }
207 
208 void JfrBuffer::set_transient() {
209   assert(acquired_by_self(), &quot;invariant&quot;);
210   set(&amp;_flags, TRANSIENT);
211   assert(transient(), &quot;invariant&quot;);
212 }
213 
214 void JfrBuffer::clear_transient() {
215   if (transient()) {
216     assert(acquired_by_self(), &quot;invariant&quot;);
217     clear(&amp;_flags, TRANSIENT);
218   }
219   assert(!transient(), &quot;invariant&quot;);
220 }
221 
222 bool JfrBuffer::lease() const {
223   return test(&amp;_flags, LEASE);
224 }
225 
226 void JfrBuffer::set_lease() {
227   assert(acquired_by_self(), &quot;invariant&quot;);
228   set(&amp;_flags, LEASE);
229   assert(lease(), &quot;invariant&quot;);
230 }
231 
232 void JfrBuffer::clear_lease() {
233   if (lease()) {
234     assert(acquired_by_self(), &quot;invariant&quot;);
235     clear(&amp;_flags, LEASE);
236   }
237   assert(!lease(), &quot;invariant&quot;);
238 }
239 
240 bool JfrBuffer::excluded() const {
241   return test(&amp;_flags, EXCLUDED);
242 }
243 
244 void JfrBuffer::set_excluded() {
245   assert(acquired_by_self(), &quot;invariant&quot;);
246   set(&amp;_flags, EXCLUDED);
247   assert(excluded(), &quot;invariant&quot;);
248 }
249 
250 void JfrBuffer::clear_excluded() {
251   if (excluded()) {
252     assert(identity() != NULL, &quot;invariant&quot;);
253     clear(&amp;_flags, EXCLUDED);
254   }
255   assert(!excluded(), &quot;invariant&quot;);
256 }
257 
258 bool JfrBuffer::retired() const {
259   return test(&amp;_flags, RETIRED);
260 }
261 
262 void JfrBuffer::set_retired() {
263   assert(acquired_by_self(), &quot;invariant&quot;);
264   set(&amp;_flags, RETIRED);
265 }
266 
267 void JfrBuffer::clear_retired() {
268   if (retired()) {
269     assert(identity() != NULL, &quot;invariant&quot;);
270     clear(&amp;_flags, RETIRED);
271   }
272 }
    </pre>
  </body>
</html>
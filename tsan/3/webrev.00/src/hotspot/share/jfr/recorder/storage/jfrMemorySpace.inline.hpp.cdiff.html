<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/jfr/recorder/storage/jfrMemorySpace.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="jfrMemorySpace.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrStorage.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/storage/jfrMemorySpace.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,10 ***</span>
<span class="line-new-header">--- 24,11 ---</span>
  
  #ifndef SHARE_JFR_RECORDER_STORAGE_JFRMEMORYSPACE_INLINE_HPP
  #define SHARE_JFR_RECORDER_STORAGE_JFRMEMORYSPACE_INLINE_HPP
  
  #include &quot;jfr/recorder/storage/jfrMemorySpace.hpp&quot;
<span class="line-added">+ #include &quot;runtime/os.hpp&quot;</span>
  
  template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;
  JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::
  JfrMemorySpace(size_t min_elem_size, size_t limit_size, size_t cache_count, Callback* callback) :
    _free(),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 67,10 ***</span>
<span class="line-new-header">--- 68,46 ---</span>
    }
    assert(_free.count() == _cache_count, &quot;invariant&quot;);
    return true;
  }
  
<span class="line-added">+ // allocations are even multiples of the mspace min size</span>
<span class="line-added">+ static inline size_t align_allocation_size(size_t requested_size, size_t min_elem_size) {</span>
<span class="line-added">+   assert((int)min_elem_size % os::vm_page_size() == 0, &quot;invariant&quot;);</span>
<span class="line-added">+   u8 alloc_size_bytes = min_elem_size;</span>
<span class="line-added">+   while (requested_size &gt; alloc_size_bytes) {</span>
<span class="line-added">+     alloc_size_bytes &lt;&lt;= 1;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   assert((int)alloc_size_bytes % os::vm_page_size() == 0, &quot;invariant&quot;);</span>
<span class="line-added">+   return (size_t)alloc_size_bytes;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;</span>
<span class="line-added">+ inline T* JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::allocate(size_t size) {</span>
<span class="line-added">+   const size_t aligned_size_bytes = align_allocation_size(size, _min_elem_size);</span>
<span class="line-added">+   void* const allocation = JfrCHeapObj::new_array&lt;u1&gt;(aligned_size_bytes + sizeof(T));</span>
<span class="line-added">+   if (allocation == NULL) {</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   T* const t = new (allocation) T;</span>
<span class="line-added">+   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   if (!t-&gt;initialize(sizeof(T), aligned_size_bytes)) {</span>
<span class="line-added">+     JfrCHeapObj::free(t, aligned_size_bytes + sizeof(T));</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return t;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;</span>
<span class="line-added">+ inline void JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::deallocate(T* t) {</span>
<span class="line-added">+   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(!_free.in_list(t), &quot;invariant&quot;);</span>
<span class="line-added">+   assert(!_full.in_list(t), &quot;invariant&quot;);</span>
<span class="line-added">+   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   JfrCHeapObj::free(t, t-&gt;total_size());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;
  inline void JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::release_full(T* t) {
    assert(is_locked(), &quot;invariant&quot;);
    assert(t != NULL, &quot;invariant&quot;);
    assert(_full.in_list(t), &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 102,10 ***</span>
<span class="line-new-header">--- 139,11 ---</span>
      deallocate(t);
      return;
    }
    assert(t-&gt;empty(), &quot;invariant&quot;);
    assert(!t-&gt;retired(), &quot;invariant&quot;);
<span class="line-added">+   assert(!t-&gt;excluded(), &quot;invariant&quot;);</span>
    assert(t-&gt;identity() == NULL, &quot;invariant&quot;);
    if (!should_populate_cache()) {
      remove_free(t);
      assert(!_free.in_list(t), &quot;invariant&quot;);
      deallocate(t);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 120,10 ***</span>
<span class="line-new-header">--- 158,19 ---</span>
    while (iterator.has_next()) {
      callback.process(iterator.next());
    }
  }
  
<span class="line-added">+ template &lt;typename Mspace, typename Callback&gt;</span>
<span class="line-added">+ static inline Mspace* create_mspace(size_t buffer_size, size_t limit, size_t cache_count, Callback* cb) {</span>
<span class="line-added">+   Mspace* const mspace = new Mspace(buffer_size, limit, cache_count, cb);</span>
<span class="line-added">+   if (mspace != NULL) {</span>
<span class="line-added">+     mspace-&gt;initialize();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return mspace;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  template &lt;typename Mspace&gt;
  inline size_t size_adjustment(size_t size, Mspace* mspace) {
    assert(mspace != NULL, &quot;invariant&quot;);
    static const size_t min_elem_size = mspace-&gt;min_elem_size();
    if (size &lt; min_elem_size) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 171,10 ***</span>
<span class="line-new-header">--- 218,19 ---</span>
    if (t == NULL) return NULL;
    mspace-&gt;insert_full_head(t);
    return t;
  }
  
<span class="line-added">+ template &lt;typename Mspace&gt;</span>
<span class="line-added">+ class MspaceLock {</span>
<span class="line-added">+  private:</span>
<span class="line-added">+   Mspace* _mspace;</span>
<span class="line-added">+  public:</span>
<span class="line-added">+   MspaceLock(Mspace* mspace) : _mspace(mspace) { _mspace-&gt;lock(); }</span>
<span class="line-added">+   ~MspaceLock() { _mspace-&gt;unlock(); }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
  template &lt;typename Mspace&gt;
  inline typename Mspace::Type* mspace_allocate_transient_to_full(size_t size, Mspace* mspace, Thread* thread) {
    typename Mspace::Type* const t = mspace_allocate_transient(size, mspace, thread);
    if (t == NULL) return NULL;
    MspaceLock&lt;Mspace&gt; lock(mspace);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 341,24 ***</span>
    assert(mspace != NULL, &quot;invariant&quot;);
    assert(mspace-&gt;has_free(), &quot;invariant&quot;);
    process_free_list_iterator_control&lt;Processor, Mspace, typename Mspace::Iterator&gt;(processor, mspace, direction);
  }
  
  template &lt;typename Mspace&gt;
  inline bool ReleaseOp&lt;Mspace&gt;::process(typename Mspace::Type* t) {
    assert(t != NULL, &quot;invariant&quot;);
<span class="line-modified">!   if (t-&gt;retired() || t-&gt;try_acquire(_thread)) {</span>
<span class="line-modified">!     if (t-&gt;transient()) {</span>
<span class="line-modified">!       if (_release_full) {</span>
<span class="line-modified">!         mspace_release_full_critical(t, _mspace);</span>
<span class="line-modified">!       } else {</span>
<span class="line-modified">!         mspace_release_free_critical(t, _mspace);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       return true;</span>
      }
<span class="line-modified">!     t-&gt;reinitialize();</span>
      assert(t-&gt;empty(), &quot;invariant&quot;);
      t-&gt;release(); // publish
    }
    return true;
  }
  
<span class="line-new-header">--- 397,40 ---</span>
    assert(mspace != NULL, &quot;invariant&quot;);
    assert(mspace-&gt;has_free(), &quot;invariant&quot;);
    process_free_list_iterator_control&lt;Processor, Mspace, typename Mspace::Iterator&gt;(processor, mspace, direction);
  }
  
<span class="line-added">+ template &lt;typename Mspace&gt;</span>
<span class="line-added">+ class ReleaseOp : public StackObj {</span>
<span class="line-added">+  private:</span>
<span class="line-added">+   Mspace* _mspace;</span>
<span class="line-added">+   Thread* _thread;</span>
<span class="line-added">+   bool _release_full;</span>
<span class="line-added">+  public:</span>
<span class="line-added">+   typedef typename Mspace::Type Type;</span>
<span class="line-added">+   ReleaseOp(Mspace* mspace, Thread* thread, bool release_full = true) :</span>
<span class="line-added">+     _mspace(mspace), _thread(thread), _release_full(release_full) {}</span>
<span class="line-added">+   bool process(Type* t);</span>
<span class="line-added">+   size_t processed() const { return 0; }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
  template &lt;typename Mspace&gt;
  inline bool ReleaseOp&lt;Mspace&gt;::process(typename Mspace::Type* t) {
    assert(t != NULL, &quot;invariant&quot;);
<span class="line-modified">!   // assumes some means of exclusive access to t</span>
<span class="line-modified">!   if (t-&gt;transient()) {</span>
<span class="line-modified">!     if (_release_full) {</span>
<span class="line-modified">!       mspace_release_full_critical(t, _mspace);</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       mspace_release_free_critical(t, _mspace);</span>
      }
<span class="line-modified">!     return true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   t-&gt;reinitialize();</span>
<span class="line-added">+   if (t-&gt;identity() != NULL) {</span>
      assert(t-&gt;empty(), &quot;invariant&quot;);
<span class="line-added">+     assert(!t-&gt;retired(), &quot;invariant&quot;);</span>
      t-&gt;release(); // publish
    }
    return true;
  }
  
</pre>
<center><a href="jfrMemorySpace.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrStorage.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
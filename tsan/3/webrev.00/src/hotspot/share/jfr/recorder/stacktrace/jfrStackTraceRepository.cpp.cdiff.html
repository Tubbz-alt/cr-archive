<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/jfr/recorder/stacktrace/jfrStackTraceRepository.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../service/jfrRecorderThreadLoop.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrStackTraceRepository.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/stacktrace/jfrStackTraceRepository.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 22,89 ***</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;jfr/metadata/jfrSerializer.hpp&quot;
<span class="line-modified">! #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceId.inline.hpp&quot;</span>
  #include &quot;jfr/recorder/repository/jfrChunkWriter.hpp&quot;
<span class="line-removed">- #include &quot;jfr/recorder/service/jfrOptionSet.hpp&quot;</span>
  #include &quot;jfr/recorder/stacktrace/jfrStackTraceRepository.hpp&quot;
<span class="line-modified">! #include &quot;jfr/utilities/jfrTypes.hpp&quot;</span>
<span class="line-removed">- #include &quot;memory/allocation.inline.hpp&quot;</span>
  #include &quot;runtime/mutexLocker.hpp&quot;
<span class="line-removed">- #include &quot;runtime/os.inline.hpp&quot;</span>
<span class="line-removed">- #include &quot;runtime/safepoint.hpp&quot;</span>
<span class="line-removed">- #include &quot;runtime/task.hpp&quot;</span>
<span class="line-removed">- #include &quot;runtime/vframe.inline.hpp&quot;</span>
  
<span class="line-modified">! class vframeStreamSamples : public vframeStreamCommon {</span>
<span class="line-removed">-  public:</span>
<span class="line-removed">-   // constructor that starts with sender of frame fr (top_frame)</span>
<span class="line-removed">-   vframeStreamSamples(JavaThread *jt, frame fr, bool stop_at_java_call_stub);</span>
<span class="line-removed">-   void samples_next();</span>
<span class="line-removed">-   void stop() {}</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- vframeStreamSamples::vframeStreamSamples(JavaThread *jt, frame fr, bool stop_at_java_call_stub) : vframeStreamCommon(jt) {</span>
<span class="line-removed">-   _stop_at_java_call_stub = stop_at_java_call_stub;</span>
<span class="line-removed">-   _frame = fr;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // We must always have a valid frame to start filling</span>
<span class="line-removed">-   bool filled_in = fill_from_frame();</span>
<span class="line-removed">-   assert(filled_in, &quot;invariant&quot;);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Solaris SPARC Compiler1 needs an additional check on the grandparent</span>
<span class="line-removed">- // of the top_frame when the parent of the top_frame is interpreted and</span>
<span class="line-removed">- // the grandparent is compiled. However, in this method we do not know</span>
<span class="line-removed">- // the relationship of the current _frame relative to the top_frame so</span>
<span class="line-removed">- // we implement a more broad sanity check. When the previous callee is</span>
<span class="line-removed">- // interpreted and the current sender is compiled, we verify that the</span>
<span class="line-removed">- // current sender is also walkable. If it is not walkable, then we mark</span>
<span class="line-removed">- // the current vframeStream as at the end.</span>
<span class="line-removed">- void vframeStreamSamples::samples_next() {</span>
<span class="line-removed">-   // handle frames with inlining</span>
<span class="line-removed">-   if (_mode == compiled_mode &amp;&amp;</span>
<span class="line-removed">-       vframeStreamCommon::fill_in_compiled_inlined_sender()) {</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   // handle general case</span>
<span class="line-modified">!   int loop_count = 0;</span>
<span class="line-removed">-   int loop_max = MaxJavaStackTraceDepth * 2;</span>
<span class="line-removed">-   do {</span>
<span class="line-removed">-     loop_count++;</span>
<span class="line-removed">-     // By the time we get here we should never see unsafe but better safe then segv&#39;d</span>
<span class="line-removed">-     if (loop_count &gt; loop_max || !_frame.safe_for_sender(_thread)) {</span>
<span class="line-removed">-       _mode = at_end_mode;</span>
<span class="line-removed">-       return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     _frame = _frame.sender(&amp;_reg_map);</span>
<span class="line-removed">-   } while (!fill_from_frame());</span>
  }
  
<span class="line-removed">- static JfrStackTraceRepository* _instance = NULL;</span>
<span class="line-removed">- </span>
  JfrStackTraceRepository&amp; JfrStackTraceRepository::instance() {
    return *_instance;
  }
  
  JfrStackTraceRepository* JfrStackTraceRepository::create() {
    assert(_instance == NULL, &quot;invariant&quot;);
    _instance = new JfrStackTraceRepository();
    return _instance;
  }
  
<span class="line-removed">- void JfrStackTraceRepository::destroy() {</span>
<span class="line-removed">-   assert(_instance != NULL, &quot;invarinat&quot;);</span>
<span class="line-removed">-   delete _instance;</span>
<span class="line-removed">-   _instance = NULL;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- JfrStackTraceRepository::JfrStackTraceRepository() : _next_id(0), _entries(0) {</span>
<span class="line-removed">-   memset(_table, 0, sizeof(_table));</span>
<span class="line-removed">- }</span>
  class JfrFrameType : public JfrSerializer {
   public:
    void serialize(JfrCheckpointWriter&amp; writer) {
      writer.write_count(JfrStackFrame::NUM_FRAME_TYPES);
      writer.write_key(JfrStackFrame::FRAME_INTERPRETER);
<span class="line-new-header">--- 22,32 ---</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;jfr/metadata/jfrSerializer.hpp&quot;
<span class="line-modified">! #include &quot;jfr/recorder/checkpoint/jfrCheckpointWriter.hpp&quot;</span>
  #include &quot;jfr/recorder/repository/jfrChunkWriter.hpp&quot;
  #include &quot;jfr/recorder/stacktrace/jfrStackTraceRepository.hpp&quot;
<span class="line-modified">! #include &quot;jfr/support/jfrThreadLocal.hpp&quot;</span>
  #include &quot;runtime/mutexLocker.hpp&quot;
  
<span class="line-modified">! static JfrStackTraceRepository* _instance = NULL;</span>
  
<span class="line-modified">! JfrStackTraceRepository::JfrStackTraceRepository() : _next_id(0), _entries(0) {</span>
<span class="line-modified">!   memset(_table, 0, sizeof(_table));</span>
  }
  
  JfrStackTraceRepository&amp; JfrStackTraceRepository::instance() {
    return *_instance;
  }
  
  JfrStackTraceRepository* JfrStackTraceRepository::create() {
    assert(_instance == NULL, &quot;invariant&quot;);
    _instance = new JfrStackTraceRepository();
    return _instance;
  }
  
  class JfrFrameType : public JfrSerializer {
   public:
    void serialize(JfrCheckpointWriter&amp; writer) {
      writer.write_count(JfrStackFrame::NUM_FRAME_TYPES);
      writer.write_key(JfrStackFrame::FRAME_INTERPRETER);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 117,347 ***</span>
      writer.write(&quot;Native&quot;);
    }
  };
  
  bool JfrStackTraceRepository::initialize() {
<span class="line-modified">!   return JfrSerializer::register_serializer(TYPE_FRAMETYPE, false, true, new JfrFrameType());</span>
  }
  
  size_t JfrStackTraceRepository::clear() {
<span class="line-modified">!   MutexLockerEx lock(JfrStacktrace_lock, Mutex::_no_safepoint_check_flag);</span>
    if (_entries == 0) {
      return 0;
    }
    for (u4 i = 0; i &lt; TABLE_SIZE; ++i) {
<span class="line-modified">!     JfrStackTraceRepository::StackTrace* stacktrace = _table[i];</span>
      while (stacktrace != NULL) {
<span class="line-modified">!       JfrStackTraceRepository::StackTrace* next = stacktrace-&gt;next();</span>
        delete stacktrace;
        stacktrace = next;
      }
    }
    memset(_table, 0, sizeof(_table));
    const size_t processed = _entries;
    _entries = 0;
    return processed;
  }
  
<span class="line-removed">- traceid JfrStackTraceRepository::add_trace(const JfrStackTrace&amp; stacktrace) {</span>
<span class="line-removed">-   MutexLockerEx lock(JfrStacktrace_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed">-   const size_t index = stacktrace._hash % TABLE_SIZE;</span>
<span class="line-removed">-   const StackTrace* table_entry = _table[index];</span>
<span class="line-removed">- </span>
<span class="line-removed">-   while (table_entry != NULL) {</span>
<span class="line-removed">-     if (table_entry-&gt;equals(stacktrace)) {</span>
<span class="line-removed">-       return table_entry-&gt;id();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     table_entry = table_entry-&gt;next();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (!stacktrace.have_lineno()) {</span>
<span class="line-removed">-     return 0;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   traceid id = ++_next_id;</span>
<span class="line-removed">-   _table[index] = new StackTrace(id, stacktrace, _table[index]);</span>
<span class="line-removed">-   ++_entries;</span>
<span class="line-removed">-   return id;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- traceid JfrStackTraceRepository::add(const JfrStackTrace&amp; stacktrace) {</span>
<span class="line-removed">-   return instance().add_trace(stacktrace);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  traceid JfrStackTraceRepository::record(Thread* thread, int skip /* 0 */) {
    assert(thread == Thread::current(), &quot;invariant&quot;);
    JfrThreadLocal* const tl = thread-&gt;jfr_thread_local();
    assert(tl != NULL, &quot;invariant&quot;);
    if (tl-&gt;has_cached_stack_trace()) {
      return tl-&gt;cached_stack_trace_id();
    }
<span class="line-modified">!   if (!thread-&gt;is_Java_thread() || thread-&gt;is_hidden_from_external_view()) {</span>
<span class="line-removed">-     return 0;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   JfrStackFrame* frames = tl-&gt;stackframes();</span>
<span class="line-removed">-   if (frames == NULL) {</span>
<span class="line-removed">-     // pending oom</span>
<span class="line-removed">-     return 0;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   assert(frames != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   assert(tl-&gt;stackframes() == frames, &quot;invariant&quot;);</span>
<span class="line-removed">-   return instance().record_for((JavaThread*)thread, skip,frames, tl-&gt;stackdepth());</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- traceid JfrStackTraceRepository::record(Thread* thread, int skip, unsigned int* hash) {</span>
<span class="line-removed">-   assert(thread == Thread::current(), &quot;invariant&quot;);</span>
<span class="line-removed">-   JfrThreadLocal* const tl = thread-&gt;jfr_thread_local();</span>
<span class="line-removed">-   assert(tl != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (tl-&gt;has_cached_stack_trace()) {</span>
<span class="line-removed">-     *hash = tl-&gt;cached_stack_trace_hash();</span>
<span class="line-removed">-     return tl-&gt;cached_stack_trace_id();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (!thread-&gt;is_Java_thread() || thread-&gt;is_hidden_from_external_view()) {</span>
      return 0;
    }
    JfrStackFrame* frames = tl-&gt;stackframes();
    if (frames == NULL) {
      // pending oom
      return 0;
    }
    assert(frames != NULL, &quot;invariant&quot;);
    assert(tl-&gt;stackframes() == frames, &quot;invariant&quot;);
<span class="line-modified">!   return instance().record_for((JavaThread*)thread, skip, frames, tl-&gt;stackdepth(), hash);</span>
  }
  
  traceid JfrStackTraceRepository::record_for(JavaThread* thread, int skip, JfrStackFrame *frames, u4 max_frames) {
    JfrStackTrace stacktrace(frames, max_frames);
<span class="line-modified">!   if (!stacktrace.record_safe(thread, skip)) {</span>
<span class="line-removed">-     return 0;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   traceid tid = add(stacktrace);</span>
<span class="line-removed">-   if (tid == 0) {</span>
<span class="line-removed">-     stacktrace.resolve_linenos();</span>
<span class="line-removed">-     tid = add(stacktrace);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return tid;</span>
  }
  
<span class="line-modified">! traceid JfrStackTraceRepository::record_for(JavaThread* thread, int skip, JfrStackFrame *frames, u4 max_frames, unsigned int* hash) {</span>
<span class="line-modified">!   assert(hash != NULL &amp;&amp; *hash == 0, &quot;invariant&quot;);</span>
<span class="line-removed">-   JfrStackTrace stacktrace(frames, max_frames);</span>
<span class="line-removed">-   if (!stacktrace.record_safe(thread, skip, true)) {</span>
<span class="line-removed">-     return 0;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   traceid tid = add(stacktrace);</span>
    if (tid == 0) {
      stacktrace.resolve_linenos();
<span class="line-modified">!     tid = add(stacktrace);</span>
    }
<span class="line-modified">!   *hash = stacktrace._hash;</span>
    return tid;
  }
  
<span class="line-modified">! size_t JfrStackTraceRepository::write_impl(JfrChunkWriter&amp; sw, bool clear) {</span>
<span class="line-modified">!   MutexLockerEx lock(JfrStacktrace_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">!   assert(_entries &gt; 0, &quot;invariant&quot;);</span>
<span class="line-modified">!   int count = 0;</span>
<span class="line-modified">!   for (u4 i = 0; i &lt; TABLE_SIZE; ++i) {</span>
<span class="line-modified">!     JfrStackTraceRepository::StackTrace* stacktrace = _table[i];</span>
<span class="line-modified">!     while (stacktrace != NULL) {</span>
<span class="line-modified">!       JfrStackTraceRepository::StackTrace* next = stacktrace-&gt;next();</span>
<span class="line-modified">!       if (stacktrace-&gt;should_write()) {</span>
<span class="line-modified">!         stacktrace-&gt;write(sw);</span>
<span class="line-removed">-         ++count;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       if (clear) {</span>
<span class="line-removed">-         delete stacktrace;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       stacktrace = next;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (clear) {</span>
<span class="line-removed">-     memset(_table, 0, sizeof(_table));</span>
<span class="line-removed">-     _entries = 0;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return count;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- size_t JfrStackTraceRepository::write(JfrChunkWriter&amp; sw, bool clear) {</span>
<span class="line-removed">-   return _entries &gt; 0 ? write_impl(sw, clear) : 0;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- traceid JfrStackTraceRepository::write(JfrCheckpointWriter&amp; writer, traceid id, unsigned int hash) {</span>
<span class="line-removed">-   assert(JfrStacktrace_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-removed">-   const StackTrace* const trace = resolve_entry(hash, id);</span>
<span class="line-removed">-   assert(trace != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   assert(trace-&gt;hash() == hash, &quot;invariant&quot;);</span>
<span class="line-removed">-   assert(trace-&gt;id() == id, &quot;invariant&quot;);</span>
<span class="line-removed">-   trace-&gt;write(writer);</span>
<span class="line-removed">-   return id;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- JfrStackTraceRepository::StackTrace::StackTrace(traceid id, const JfrStackTrace&amp; trace, JfrStackTraceRepository::StackTrace* next) :</span>
<span class="line-removed">-   _next(next),</span>
<span class="line-removed">-   _frames(NULL),</span>
<span class="line-removed">-   _id(id),</span>
<span class="line-removed">-   _nr_of_frames(trace._nr_of_frames),</span>
<span class="line-removed">-   _hash(trace._hash),</span>
<span class="line-removed">-   _reached_root(trace._reached_root),</span>
<span class="line-removed">-   _written(false) {</span>
<span class="line-removed">-   if (_nr_of_frames &gt; 0) {</span>
<span class="line-removed">-     _frames = NEW_C_HEAP_ARRAY(JfrStackFrame, _nr_of_frames, mtTracing);</span>
<span class="line-removed">-     memcpy(_frames, trace._frames, _nr_of_frames * sizeof(JfrStackFrame));</span>
    }
  }
  
<span class="line-modified">! JfrStackTraceRepository::StackTrace::~StackTrace() {</span>
<span class="line-modified">!   if (_frames != NULL) {</span>
<span class="line-modified">!     FREE_C_HEAP_ARRAY(JfrStackFrame, _frames);</span>
<span class="line-modified">!   }</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! bool JfrStackTraceRepository::StackTrace::equals(const JfrStackTrace&amp; rhs) const {</span>
<span class="line-modified">!   if (_reached_root != rhs._reached_root || _nr_of_frames != rhs._nr_of_frames || _hash != rhs._hash) {</span>
<span class="line-modified">!     return false;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   for (u4 i = 0; i &lt; _nr_of_frames; ++i) {</span>
<span class="line-removed">-     if (!_frames[i].equals(rhs._frames[i])) {</span>
<span class="line-removed">-       return false;</span>
      }
    }
<span class="line-removed">-   return true;</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! template &lt;typename Writer&gt;</span>
<span class="line-modified">! static void write_stacktrace(Writer&amp; w, traceid id, bool reached_root, u4 nr_of_frames, const JfrStackFrame* frames) {</span>
<span class="line-removed">-   w.write((u8)id);</span>
<span class="line-removed">-   w.write((u1)!reached_root);</span>
<span class="line-removed">-   w.write(nr_of_frames);</span>
<span class="line-removed">-   for (u4 i = 0; i &lt; nr_of_frames; ++i) {</span>
<span class="line-removed">-     frames[i].write(w);</span>
    }
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void JfrStackTraceRepository::StackTrace::write(JfrChunkWriter&amp; sw) const {</span>
<span class="line-removed">-   assert(!_written, &quot;invariant&quot;);</span>
<span class="line-removed">-   write_stacktrace(sw, _id, _reached_root, _nr_of_frames, _frames);</span>
<span class="line-removed">-   _written = true;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void JfrStackTraceRepository::StackTrace::write(JfrCheckpointWriter&amp; cpw) const {</span>
<span class="line-removed">-   write_stacktrace(cpw, _id, _reached_root, _nr_of_frames, _frames);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- // JfrStackFrame</span>
  
<span class="line-modified">! bool JfrStackFrame::equals(const JfrStackFrame&amp; rhs) const {</span>
<span class="line-modified">!   return _methodid == rhs._methodid &amp;&amp; _bci == rhs._bci &amp;&amp; _type == rhs._type;</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-removed">- template &lt;typename Writer&gt;</span>
<span class="line-removed">- static void write_frame(Writer&amp; w, traceid methodid, int line, int bci, u1 type) {</span>
<span class="line-removed">-   w.write((u8)methodid);</span>
<span class="line-removed">-   w.write((u4)line);</span>
<span class="line-removed">-   w.write((u4)bci);</span>
<span class="line-removed">-   w.write((u8)type);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void JfrStackFrame::write(JfrChunkWriter&amp; cw) const {</span>
<span class="line-removed">-   write_frame(cw, _methodid, _line, _bci, _type);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void JfrStackFrame::write(JfrCheckpointWriter&amp; cpw) const {</span>
<span class="line-removed">-   write_frame(cpw, _methodid, _line, _bci, _type);</span>
  }
  
  // invariant is that the entry to be resolved actually exists in the table
<span class="line-modified">! const JfrStackTraceRepository::StackTrace* JfrStackTraceRepository::resolve_entry(unsigned int hash, traceid id) const {</span>
    const size_t index = (hash % TABLE_SIZE);
<span class="line-modified">!   const StackTrace* trace = _table[index];</span>
    while (trace != NULL &amp;&amp; trace-&gt;id() != id) {
      trace = trace-&gt;next();
    }
    assert(trace != NULL, &quot;invariant&quot;);
    assert(trace-&gt;hash() == hash, &quot;invariant&quot;);
    assert(trace-&gt;id() == id, &quot;invariant&quot;);
    return trace;
  }
<span class="line-removed">- </span>
<span class="line-removed">- void JfrStackFrame::resolve_lineno() {</span>
<span class="line-removed">-   assert(_method, &quot;no method pointer&quot;);</span>
<span class="line-removed">-   assert(_line == 0, &quot;already have linenumber&quot;);</span>
<span class="line-removed">-   _line = _method-&gt;line_number_from_bci(_bci);</span>
<span class="line-removed">-   _method = NULL;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void JfrStackTrace::set_frame(u4 frame_pos, JfrStackFrame&amp; frame) {</span>
<span class="line-removed">-   assert(frame_pos &lt; _max_frames, &quot;illegal frame_pos&quot;);</span>
<span class="line-removed">-   _frames[frame_pos] = frame;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void JfrStackTrace::resolve_linenos() {</span>
<span class="line-removed">-   for(unsigned int i = 0; i &lt; _nr_of_frames; i++) {</span>
<span class="line-removed">-     _frames[i].resolve_lineno();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   _lineno = true;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool JfrStackTrace::record_safe(JavaThread* thread, int skip, bool leakp /* false */) {</span>
<span class="line-removed">-   assert(thread == Thread::current(), &quot;Thread stack needs to be walkable&quot;);</span>
<span class="line-removed">-   vframeStream vfs(thread);</span>
<span class="line-removed">-   u4 count = 0;</span>
<span class="line-removed">-   _reached_root = true;</span>
<span class="line-removed">-   for(int i = 0; i &lt; skip; i++) {</span>
<span class="line-removed">-     if (vfs.at_end()) {</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     vfs.next();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   while (!vfs.at_end()) {</span>
<span class="line-removed">-     if (count &gt;= _max_frames) {</span>
<span class="line-removed">-       _reached_root = false;</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     const Method* method = vfs.method();</span>
<span class="line-removed">-     const traceid mid = JfrTraceId::use(method, leakp);</span>
<span class="line-removed">-     int type = vfs.is_interpreted_frame() ? JfrStackFrame::FRAME_INTERPRETER : JfrStackFrame::FRAME_JIT;</span>
<span class="line-removed">-     int bci = 0;</span>
<span class="line-removed">-     if (method-&gt;is_native()) {</span>
<span class="line-removed">-       type = JfrStackFrame::FRAME_NATIVE;</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       bci = vfs.bci();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     // Can we determine if it&#39;s inlined?</span>
<span class="line-removed">-     _hash = (_hash &lt;&lt; 2) + (unsigned int)(((size_t)mid &gt;&gt; 2) + (bci &lt;&lt; 4) + type);</span>
<span class="line-removed">-     _frames[count] = JfrStackFrame(mid, bci, type, method);</span>
<span class="line-removed">-     vfs.next();</span>
<span class="line-removed">-     count++;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   _nr_of_frames = count;</span>
<span class="line-removed">-   return true;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool JfrStackTrace::record_thread(JavaThread&amp; thread, frame&amp; frame) {</span>
<span class="line-removed">-   vframeStreamSamples st(&amp;thread, frame, false);</span>
<span class="line-removed">-   u4 count = 0;</span>
<span class="line-removed">-   _reached_root = true;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   while (!st.at_end()) {</span>
<span class="line-removed">-     if (count &gt;= _max_frames) {</span>
<span class="line-removed">-       _reached_root = false;</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     const Method* method = st.method();</span>
<span class="line-removed">-     if (!Method::is_valid_method(method)) {</span>
<span class="line-removed">-       // we throw away everything we&#39;ve gathered in this sample since</span>
<span class="line-removed">-       // none of it is safe</span>
<span class="line-removed">-       return false;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     const traceid mid = JfrTraceId::use(method);</span>
<span class="line-removed">-     int type = st.is_interpreted_frame() ? JfrStackFrame::FRAME_INTERPRETER : JfrStackFrame::FRAME_JIT;</span>
<span class="line-removed">-     int bci = 0;</span>
<span class="line-removed">-     if (method-&gt;is_native()) {</span>
<span class="line-removed">-       type = JfrStackFrame::FRAME_NATIVE;</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       bci = st.bci();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     const int lineno = method-&gt;line_number_from_bci(bci);</span>
<span class="line-removed">-     // Can we determine if it&#39;s inlined?</span>
<span class="line-removed">-     _hash = (_hash &lt;&lt; 2) + (unsigned int)(((size_t)mid &gt;&gt; 2) + (bci &lt;&lt; 4) + type);</span>
<span class="line-removed">-     _frames[count] = JfrStackFrame(mid, bci, type, lineno);</span>
<span class="line-removed">-     st.samples_next();</span>
<span class="line-removed">-     count++;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   _lineno = true;</span>
<span class="line-removed">-   _nr_of_frames = count;</span>
<span class="line-removed">-   return true;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void JfrStackTraceRepository::write_metadata(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-removed">-   JfrFrameType fct;</span>
<span class="line-removed">-   writer.write_type(TYPE_FRAMETYPE);</span>
<span class="line-removed">-   fct.serialize(writer);</span>
<span class="line-removed">- }</span>
<span class="line-new-header">--- 60,150 ---</span>
      writer.write(&quot;Native&quot;);
    }
  };
  
  bool JfrStackTraceRepository::initialize() {
<span class="line-modified">!   return JfrSerializer::register_serializer(TYPE_FRAMETYPE, true, new JfrFrameType());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JfrStackTraceRepository::destroy() {</span>
<span class="line-added">+   assert(_instance != NULL, &quot;invarinat&quot;);</span>
<span class="line-added">+   delete _instance;</span>
<span class="line-added">+   _instance = NULL;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static traceid last_id = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool JfrStackTraceRepository::is_modified() const {</span>
<span class="line-added">+   return last_id != _next_id;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ size_t JfrStackTraceRepository::write(JfrChunkWriter&amp; sw, bool clear) {</span>
<span class="line-added">+   if (_entries == 0) {</span>
<span class="line-added">+     return 0;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   MutexLocker lock(JfrStacktrace_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">+   assert(_entries &gt; 0, &quot;invariant&quot;);</span>
<span class="line-added">+   int count = 0;</span>
<span class="line-added">+   for (u4 i = 0; i &lt; TABLE_SIZE; ++i) {</span>
<span class="line-added">+     JfrStackTrace* stacktrace = _table[i];</span>
<span class="line-added">+     while (stacktrace != NULL) {</span>
<span class="line-added">+       JfrStackTrace* next = const_cast&lt;JfrStackTrace*&gt;(stacktrace-&gt;next());</span>
<span class="line-added">+       if (stacktrace-&gt;should_write()) {</span>
<span class="line-added">+         stacktrace-&gt;write(sw);</span>
<span class="line-added">+         ++count;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       if (clear) {</span>
<span class="line-added">+         delete stacktrace;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       stacktrace = next;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (clear) {</span>
<span class="line-added">+     memset(_table, 0, sizeof(_table));</span>
<span class="line-added">+     _entries = 0;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   last_id = _next_id;</span>
<span class="line-added">+   return count;</span>
  }
  
  size_t JfrStackTraceRepository::clear() {
<span class="line-modified">!   MutexLocker lock(JfrStacktrace_lock, Mutex::_no_safepoint_check_flag);</span>
    if (_entries == 0) {
      return 0;
    }
    for (u4 i = 0; i &lt; TABLE_SIZE; ++i) {
<span class="line-modified">!     JfrStackTrace* stacktrace = _table[i];</span>
      while (stacktrace != NULL) {
<span class="line-modified">!       JfrStackTrace* next = const_cast&lt;JfrStackTrace*&gt;(stacktrace-&gt;next());</span>
        delete stacktrace;
        stacktrace = next;
      }
    }
    memset(_table, 0, sizeof(_table));
    const size_t processed = _entries;
    _entries = 0;
    return processed;
  }
  
  traceid JfrStackTraceRepository::record(Thread* thread, int skip /* 0 */) {
    assert(thread == Thread::current(), &quot;invariant&quot;);
    JfrThreadLocal* const tl = thread-&gt;jfr_thread_local();
    assert(tl != NULL, &quot;invariant&quot;);
    if (tl-&gt;has_cached_stack_trace()) {
      return tl-&gt;cached_stack_trace_id();
    }
<span class="line-modified">!   if (!thread-&gt;is_Java_thread() || thread-&gt;is_hidden_from_external_view() || tl-&gt;is_excluded()) {</span>
      return 0;
    }
    JfrStackFrame* frames = tl-&gt;stackframes();
    if (frames == NULL) {
      // pending oom
      return 0;
    }
    assert(frames != NULL, &quot;invariant&quot;);
    assert(tl-&gt;stackframes() == frames, &quot;invariant&quot;);
<span class="line-modified">!   return instance().record_for((JavaThread*)thread, skip, frames, tl-&gt;stackdepth());</span>
  }
  
  traceid JfrStackTraceRepository::record_for(JavaThread* thread, int skip, JfrStackFrame *frames, u4 max_frames) {
    JfrStackTrace stacktrace(frames, max_frames);
<span class="line-modified">!   return stacktrace.record_safe(thread, skip) ? add(stacktrace) : 0;</span>
  }
  
<span class="line-modified">! traceid JfrStackTraceRepository::add(const JfrStackTrace&amp; stacktrace) {</span>
<span class="line-modified">!   traceid tid = instance().add_trace(stacktrace);</span>
    if (tid == 0) {
      stacktrace.resolve_linenos();
<span class="line-modified">!     tid = instance().add_trace(stacktrace);</span>
    }
<span class="line-modified">!   assert(tid != 0, &quot;invariant&quot;);</span>
    return tid;
  }
  
<span class="line-modified">! void JfrStackTraceRepository::record_and_cache(JavaThread* thread, int skip /* 0 */) {</span>
<span class="line-modified">!   assert(thread != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   JfrThreadLocal* const tl = thread-&gt;jfr_thread_local();</span>
<span class="line-modified">!   assert(tl != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(!tl-&gt;has_cached_stack_trace(), &quot;invariant&quot;);</span>
<span class="line-modified">!   JfrStackTrace stacktrace(tl-&gt;stackframes(), tl-&gt;stackdepth());</span>
<span class="line-modified">!   stacktrace.record_safe(thread, skip);</span>
<span class="line-modified">!   const unsigned int hash = stacktrace.hash();</span>
<span class="line-modified">!   if (hash != 0) {</span>
<span class="line-modified">!     tl-&gt;set_cached_stack_trace_id(instance().add(stacktrace), hash);</span>
    }
  }
  
<span class="line-modified">! traceid JfrStackTraceRepository::add_trace(const JfrStackTrace&amp; stacktrace) {</span>
<span class="line-modified">!   MutexLocker lock(JfrStacktrace_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">!   const size_t index = stacktrace._hash % TABLE_SIZE;</span>
<span class="line-modified">!   const JfrStackTrace* table_entry = _table[index];</span>
  
<span class="line-modified">!   while (table_entry != NULL) {</span>
<span class="line-modified">!     if (table_entry-&gt;equals(stacktrace)) {</span>
<span class="line-modified">!       return table_entry-&gt;id();</span>
      }
<span class="line-added">+     table_entry = table_entry-&gt;next();</span>
    }
  
<span class="line-modified">!   if (!stacktrace.have_lineno()) {</span>
<span class="line-modified">!     return 0;</span>
    }
  
<span class="line-modified">!   traceid id = ++_next_id;</span>
<span class="line-modified">!   _table[index] = new JfrStackTrace(id, stacktrace, _table[index]);</span>
<span class="line-modified">!   ++_entries;</span>
<span class="line-modified">!   return id;</span>
  }
  
  // invariant is that the entry to be resolved actually exists in the table
<span class="line-modified">! const JfrStackTrace* JfrStackTraceRepository::lookup(unsigned int hash, traceid id) const {</span>
    const size_t index = (hash % TABLE_SIZE);
<span class="line-modified">!   const JfrStackTrace* trace = _table[index];</span>
    while (trace != NULL &amp;&amp; trace-&gt;id() != id) {
      trace = trace-&gt;next();
    }
    assert(trace != NULL, &quot;invariant&quot;);
    assert(trace-&gt;hash() == hash, &quot;invariant&quot;);
    assert(trace-&gt;id() == id, &quot;invariant&quot;);
    return trace;
  }
</pre>
<center><a href="../service/jfrRecorderThreadLoop.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrStackTraceRepository.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/recorder/storage/jfrBuffer.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../stacktrace/jfrStackTraceRepository.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrBuffer.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/storage/jfrBuffer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/recorder/storage/jfrBuffer.hpp&quot;
<span class="line-removed"> 27 #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-removed"> 28 #include &quot;runtime/orderAccess.hpp&quot;</span>
 29 #include &quot;runtime/thread.inline.hpp&quot;
 30 
<span class="line-modified"> 31 static const u1* const MUTEX_CLAIM = NULL;</span>
 32 
 33 JfrBuffer::JfrBuffer() : _next(NULL),
 34                          _prev(NULL),
 35                          _identity(NULL),
 36                          _pos(NULL),
 37                          _top(NULL),
 38                          _flags(0),
 39                          _header_size(0),
 40                          _size(0) {}
 41 
<span class="line-modified"> 42 bool JfrBuffer::initialize(size_t header_size, size_t size, const void* id /* NULL */) {</span>


 43   _header_size = (u2)header_size;
 44   _size = (u4)(size / BytesPerWord);
<span class="line-removed"> 45   assert(_identity == NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 46   _identity = id;</span>
 47   set_pos(start());
 48   set_top(start());
<span class="line-removed"> 49   assert(_next == NULL, &quot;invariant&quot;);</span>
 50   assert(free_size() == size, &quot;invariant&quot;);
 51   assert(!transient(), &quot;invariant&quot;);
 52   assert(!lease(), &quot;invariant&quot;);
 53   assert(!retired(), &quot;invariant&quot;);
 54   return true;
 55 }
 56 
<span class="line-modified"> 57 void JfrBuffer::reinitialize() {</span>
<span class="line-modified"> 58   assert(!lease(), &quot;invariant&quot;);</span>
<span class="line-removed"> 59   assert(!transient(), &quot;invariant&quot;);</span>
<span class="line-removed"> 60   set_pos(start());</span>
<span class="line-removed"> 61   clear_retired();</span>
<span class="line-removed"> 62   set_top(start());</span>
<span class="line-removed"> 63 }</span>
<span class="line-removed"> 64 </span>
<span class="line-removed"> 65 void JfrBuffer::concurrent_reinitialization() {</span>
<span class="line-removed"> 66   concurrent_top();</span>
 67   assert(!lease(), &quot;invariant&quot;);
 68   assert(!transient(), &quot;invariant&quot;);








 69   set_pos(start());
<span class="line-modified"> 70   set_concurrent_top(start());</span>
 71   clear_retired();
 72 }
 73 
<span class="line-modified"> 74 size_t JfrBuffer::discard() {</span>
<span class="line-modified"> 75   size_t discard_size = unflushed_size();</span>
<span class="line-removed"> 76   set_top(pos());</span>
<span class="line-removed"> 77   return discard_size;</span>
 78 }
 79 
 80 const u1* JfrBuffer::stable_top() const {
 81   const u1* current_top;
 82   do {
<span class="line-modified"> 83     current_top = OrderAccess::load_acquire(&amp;_top);</span>
<span class="line-modified"> 84   } while (MUTEX_CLAIM == current_top);</span>
 85   return current_top;
 86 }
 87 
<span class="line-removed"> 88 const u1* JfrBuffer::top() const {</span>
<span class="line-removed"> 89   return _top;</span>
<span class="line-removed"> 90 }</span>
<span class="line-removed"> 91 </span>
 92 void JfrBuffer::set_top(const u1* new_top) {
<span class="line-modified"> 93   _top = new_top;</span>


 94 }
 95 
<span class="line-modified"> 96 const u1* JfrBuffer::concurrent_top() const {</span>
 97   do {
 98     const u1* current_top = stable_top();
<span class="line-modified"> 99     if (Atomic::cmpxchg(MUTEX_CLAIM, &amp;_top, current_top) == current_top) {</span>

100       return current_top;
101     }
102   } while (true);
103 }
104 
<span class="line-modified">105 void JfrBuffer::set_concurrent_top(const u1* new_top) {</span>
<span class="line-modified">106   assert(new_top != MUTEX_CLAIM, &quot;invariant&quot;);</span>
<span class="line-modified">107   assert(new_top &lt;= end(), &quot;invariant&quot;);</span>
<span class="line-modified">108   assert(new_top &gt;= start(), &quot;invariant&quot;);</span>
<span class="line-removed">109   assert(top() == MUTEX_CLAIM, &quot;invariant&quot;);</span>
<span class="line-removed">110   OrderAccess::release_store(&amp;_top, new_top);</span>
111 }
112 
<span class="line-modified">113 size_t JfrBuffer::unflushed_size() const {</span>
<span class="line-modified">114   return pos() - stable_top();</span>




115 }
116 
117 void JfrBuffer::acquire(const void* id) {
118   assert(id != NULL, &quot;invariant&quot;);
119   const void* current_id;
120   do {
<span class="line-modified">121     current_id = OrderAccess::load_acquire(&amp;_identity);</span>
<span class="line-modified">122   } while (current_id != NULL || Atomic::cmpxchg(id, &amp;_identity, current_id) != current_id);</span>
123 }
124 
125 bool JfrBuffer::try_acquire(const void* id) {
126   assert(id != NULL, &quot;invariant&quot;);
<span class="line-modified">127   const void* const current_id = OrderAccess::load_acquire(&amp;_identity);</span>
<span class="line-modified">128   return current_id == NULL &amp;&amp; Atomic::cmpxchg(id, &amp;_identity, current_id) == current_id;</span>
129 }
130 
131 void JfrBuffer::release() {
<span class="line-modified">132   OrderAccess::release_store(&amp;_identity, (const void*)NULL);</span>
<span class="line-modified">133 }</span>
<span class="line-removed">134 </span>
<span class="line-removed">135 void JfrBuffer::clear_identity() {</span>
<span class="line-removed">136   _identity = NULL;</span>
137 }
138 
139 #ifdef ASSERT
140 static bool validate_to(const JfrBuffer* const to, size_t size) {
141   assert(to != NULL, &quot;invariant&quot;);
142   assert(to-&gt;acquired_by_self(), &quot;invariant&quot;);
143   assert(to-&gt;free_size() &gt;= size, &quot;invariant&quot;);
144   return true;
145 }
146 
<span class="line-removed">147 static bool validate_concurrent_this(const JfrBuffer* const t, size_t size) {</span>
<span class="line-removed">148   assert(t-&gt;top() == MUTEX_CLAIM, &quot;invariant&quot;);</span>
<span class="line-removed">149   return true;</span>
<span class="line-removed">150 }</span>
<span class="line-removed">151 </span>
152 static bool validate_this(const JfrBuffer* const t, size_t size) {
<span class="line-modified">153   assert(t-&gt;top() + size &lt;= t-&gt;pos(), &quot;invariant&quot;);</span>

154   return true;
155 }
<span class="line-removed">156 </span>
<span class="line-removed">157 bool JfrBuffer::acquired_by_self() const {</span>
<span class="line-removed">158   return identity() == Thread::current();</span>
<span class="line-removed">159 }</span>
160 #endif // ASSERT
161 
162 void JfrBuffer::move(JfrBuffer* const to, size_t size) {
163   assert(validate_to(to, size), &quot;invariant&quot;);

164   assert(validate_this(this, size), &quot;invariant&quot;);
<span class="line-modified">165   const u1* current_top = top();</span>
<span class="line-modified">166   assert(current_top != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">167   memcpy(to-&gt;pos(), current_top, size);</span>
<span class="line-modified">168   to-&gt;set_pos(size);</span>


169   to-&gt;release();
<span class="line-modified">170   set_top(current_top + size);</span>

171 }
172 
<span class="line-modified">173 void JfrBuffer::concurrent_move_and_reinitialize(JfrBuffer* const to, size_t size) {</span>
<span class="line-modified">174   assert(validate_to(to, size), &quot;invariant&quot;);</span>
<span class="line-modified">175   const u1* current_top = concurrent_top();</span>
<span class="line-modified">176   assert(validate_concurrent_this(this, size), &quot;invariant&quot;);</span>
<span class="line-modified">177   const size_t actual_size = MIN2(size, (size_t)(pos() - current_top));</span>
<span class="line-modified">178   assert(actual_size &lt;= size, &quot;invariant&quot;);</span>
<span class="line-modified">179   memcpy(to-&gt;pos(), current_top, actual_size);</span>
<span class="line-modified">180   to-&gt;set_pos(actual_size);</span>
<span class="line-modified">181   set_pos(start());</span>
<span class="line-modified">182   to-&gt;release();</span>
<span class="line-modified">183   set_concurrent_top(start());</span>

184 }
185 
<span class="line-removed">186 // flags</span>
187 enum FLAG {
188   RETIRED = 1,
189   TRANSIENT = 2,
<span class="line-modified">190   LEASE = 4</span>

191 };
192 





















193 bool JfrBuffer::transient() const {
<span class="line-modified">194   return (u1)TRANSIENT == (_flags &amp; (u1)TRANSIENT);</span>
195 }
196 
197 void JfrBuffer::set_transient() {
<span class="line-modified">198   _flags |= (u1)TRANSIENT;</span>

199   assert(transient(), &quot;invariant&quot;);
200 }
201 
202 void JfrBuffer::clear_transient() {
203   if (transient()) {
<span class="line-modified">204     _flags ^= (u1)TRANSIENT;</span>

205   }
206   assert(!transient(), &quot;invariant&quot;);
207 }
208 
209 bool JfrBuffer::lease() const {
<span class="line-modified">210   return (u1)LEASE == (_flags &amp; (u1)LEASE);</span>
211 }
212 
213 void JfrBuffer::set_lease() {
<span class="line-modified">214   _flags |= (u1)LEASE;</span>

215   assert(lease(), &quot;invariant&quot;);
216 }
217 
218 void JfrBuffer::clear_lease() {
219   if (lease()) {
<span class="line-modified">220     _flags ^= (u1)LEASE;</span>

221   }
222   assert(!lease(), &quot;invariant&quot;);
223 }
224 
<span class="line-modified">225 static u2 load_acquire_flags(const u2* const flags) {</span>
<span class="line-modified">226   return OrderAccess::load_acquire(flags);</span>
227 }
228 
<span class="line-modified">229 static void release_store_flags(u2* const flags, u2 new_flags) {</span>
<span class="line-modified">230   OrderAccess::release_store(flags, new_flags);</span>










231 }
232 
233 bool JfrBuffer::retired() const {
<span class="line-modified">234   return (u1)RETIRED == (load_acquire_flags(&amp;_flags) &amp; (u1)RETIRED);</span>
235 }
236 
237 void JfrBuffer::set_retired() {
<span class="line-modified">238   const u2 new_flags = load_acquire_flags(&amp;_flags) | (u1)RETIRED;</span>
<span class="line-modified">239   release_store_flags(&amp;_flags, new_flags);</span>
240 }
241 
242 void JfrBuffer::clear_retired() {
<span class="line-modified">243   u2 new_flags = load_acquire_flags(&amp;_flags);</span>
<span class="line-modified">244   if ((u1)RETIRED == (new_flags &amp; (u1)RETIRED)) {</span>
<span class="line-modified">245     new_flags ^= (u1)RETIRED;</span>
<span class="line-removed">246     release_store_flags(&amp;_flags, new_flags);</span>
247   }
248 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/recorder/storage/jfrBuffer.hpp&quot;


 27 #include &quot;runtime/thread.inline.hpp&quot;
 28 
<span class="line-modified"> 29 static const u1* const TOP_CRITICAL_SECTION = NULL;</span>
 30 
 31 JfrBuffer::JfrBuffer() : _next(NULL),
 32                          _prev(NULL),
 33                          _identity(NULL),
 34                          _pos(NULL),
 35                          _top(NULL),
 36                          _flags(0),
 37                          _header_size(0),
 38                          _size(0) {}
 39 
<span class="line-modified"> 40 bool JfrBuffer::initialize(size_t header_size, size_t size) {</span>
<span class="line-added"> 41   assert(_next == NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 42   assert(_identity == NULL, &quot;invariant&quot;);</span>
 43   _header_size = (u2)header_size;
 44   _size = (u4)(size / BytesPerWord);


 45   set_pos(start());
 46   set_top(start());

 47   assert(free_size() == size, &quot;invariant&quot;);
 48   assert(!transient(), &quot;invariant&quot;);
 49   assert(!lease(), &quot;invariant&quot;);
 50   assert(!retired(), &quot;invariant&quot;);
 51   return true;
 52 }
 53 
<span class="line-modified"> 54 void JfrBuffer::reinitialize(bool exclusion /* false */) {</span>
<span class="line-modified"> 55   acquire_critical_section_top();</span>








 56   assert(!lease(), &quot;invariant&quot;);
 57   assert(!transient(), &quot;invariant&quot;);
<span class="line-added"> 58   if (exclusion != excluded()) {</span>
<span class="line-added"> 59     // update</span>
<span class="line-added"> 60     if (exclusion) {</span>
<span class="line-added"> 61       set_excluded();</span>
<span class="line-added"> 62     } else {</span>
<span class="line-added"> 63       clear_excluded();</span>
<span class="line-added"> 64     }</span>
<span class="line-added"> 65   }</span>
 66   set_pos(start());
<span class="line-modified"> 67   release_critical_section_top(start());</span>
 68   clear_retired();
 69 }
 70 
<span class="line-modified"> 71 const u1* JfrBuffer::top() const {</span>
<span class="line-modified"> 72   return Atomic::load_acquire(&amp;_top);</span>


 73 }
 74 
 75 const u1* JfrBuffer::stable_top() const {
 76   const u1* current_top;
 77   do {
<span class="line-modified"> 78     current_top = top();</span>
<span class="line-modified"> 79   } while (TOP_CRITICAL_SECTION == current_top);</span>
 80   return current_top;
 81 }
 82 




 83 void JfrBuffer::set_top(const u1* new_top) {
<span class="line-modified"> 84   assert(new_top &lt;= end(), &quot;invariant&quot;);</span>
<span class="line-added"> 85   assert(new_top &gt;= start(), &quot;invariant&quot;);</span>
<span class="line-added"> 86   Atomic::release_store(&amp;_top, new_top);</span>
 87 }
 88 
<span class="line-modified"> 89 const u1* JfrBuffer::acquire_critical_section_top() const {</span>
 90   do {
 91     const u1* current_top = stable_top();
<span class="line-modified"> 92     assert(current_top != TOP_CRITICAL_SECTION, &quot;invariant&quot;);</span>
<span class="line-added"> 93     if (Atomic::cmpxchg(&amp;_top, current_top, TOP_CRITICAL_SECTION) == current_top) {</span>
 94       return current_top;
 95     }
 96   } while (true);
 97 }
 98 
<span class="line-modified"> 99 void JfrBuffer::release_critical_section_top(const u1* new_top) {</span>
<span class="line-modified">100   assert(new_top != TOP_CRITICAL_SECTION, &quot;invariant&quot;);</span>
<span class="line-modified">101   assert(top() == TOP_CRITICAL_SECTION, &quot;invariant&quot;);</span>
<span class="line-modified">102   set_top(new_top);</span>


103 }
104 
<span class="line-modified">105 bool JfrBuffer::acquired_by(const void* id) const {</span>
<span class="line-modified">106   return identity() == id;</span>
<span class="line-added">107 }</span>
<span class="line-added">108 </span>
<span class="line-added">109 bool JfrBuffer::acquired_by_self() const {</span>
<span class="line-added">110   return acquired_by(Thread::current());</span>
111 }
112 
113 void JfrBuffer::acquire(const void* id) {
114   assert(id != NULL, &quot;invariant&quot;);
115   const void* current_id;
116   do {
<span class="line-modified">117     current_id = identity();</span>
<span class="line-modified">118   } while (current_id != NULL || Atomic::cmpxchg(&amp;_identity, current_id, id) != current_id);</span>
119 }
120 
121 bool JfrBuffer::try_acquire(const void* id) {
122   assert(id != NULL, &quot;invariant&quot;);
<span class="line-modified">123   const void* const current_id = identity();</span>
<span class="line-modified">124   return current_id == NULL &amp;&amp; Atomic::cmpxchg(&amp;_identity, current_id, id) == current_id;</span>
125 }
126 
127 void JfrBuffer::release() {
<span class="line-modified">128   assert(identity() != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">129   Atomic::release_store(&amp;_identity, (const void*)NULL);</span>



130 }
131 
132 #ifdef ASSERT
133 static bool validate_to(const JfrBuffer* const to, size_t size) {
134   assert(to != NULL, &quot;invariant&quot;);
135   assert(to-&gt;acquired_by_self(), &quot;invariant&quot;);
136   assert(to-&gt;free_size() &gt;= size, &quot;invariant&quot;);
137   return true;
138 }
139 





140 static bool validate_this(const JfrBuffer* const t, size_t size) {
<span class="line-modified">141   assert(t-&gt;acquired_by_self(), &quot;invariant&quot;);</span>
<span class="line-added">142   assert(t-&gt;top() == TOP_CRITICAL_SECTION, &quot;invariant&quot;);</span>
143   return true;
144 }




145 #endif // ASSERT
146 
147 void JfrBuffer::move(JfrBuffer* const to, size_t size) {
148   assert(validate_to(to, size), &quot;invariant&quot;);
<span class="line-added">149   const u1* const current_top = acquire_critical_section_top();</span>
150   assert(validate_this(this, size), &quot;invariant&quot;);
<span class="line-modified">151   const size_t actual_size = pos() - current_top;</span>
<span class="line-modified">152   assert(actual_size &lt;= size, &quot;invariant&quot;);</span>
<span class="line-modified">153   if (actual_size &gt; 0) {</span>
<span class="line-modified">154     memcpy(to-&gt;pos(), current_top, actual_size);</span>
<span class="line-added">155     to-&gt;set_pos(actual_size);</span>
<span class="line-added">156   }</span>
157   to-&gt;release();
<span class="line-modified">158   set_pos(start());</span>
<span class="line-added">159   release_critical_section_top(start());</span>
160 }
161 
<span class="line-modified">162 size_t JfrBuffer::discard() {</span>
<span class="line-modified">163   const u1* const position = pos();</span>
<span class="line-modified">164   // stable_top() provides acquire semantics for pos()</span>
<span class="line-modified">165   const u1* const current_top = stable_top();</span>
<span class="line-modified">166   set_top(position);</span>
<span class="line-modified">167   return position - current_top;</span>
<span class="line-modified">168 }</span>
<span class="line-modified">169 </span>
<span class="line-modified">170 size_t JfrBuffer::unflushed_size() const {</span>
<span class="line-modified">171   const u1* const position = pos();</span>
<span class="line-modified">172   // stable_top() provides acquire semantics for pos()</span>
<span class="line-added">173   return position - stable_top();</span>
174 }
175 

176 enum FLAG {
177   RETIRED = 1,
178   TRANSIENT = 2,
<span class="line-modified">179   LEASE = 4,</span>
<span class="line-added">180   EXCLUDED = 8</span>
181 };
182 
<span class="line-added">183 inline u2 load(const volatile u2* flags) {</span>
<span class="line-added">184   assert(flags != NULL, &quot;invariant&quot;);</span>
<span class="line-added">185   return Atomic::load_acquire(flags);</span>
<span class="line-added">186 }</span>
<span class="line-added">187 </span>
<span class="line-added">188 inline void set(u2* flags, FLAG flag) {</span>
<span class="line-added">189   assert(flags != NULL, &quot;invariant&quot;);</span>
<span class="line-added">190   OrderAccess::storestore();</span>
<span class="line-added">191   *flags |= (u1)flag;</span>
<span class="line-added">192 }</span>
<span class="line-added">193 </span>
<span class="line-added">194 inline void clear(u2* flags, FLAG flag) {</span>
<span class="line-added">195   assert(flags != NULL, &quot;invariant&quot;);</span>
<span class="line-added">196   OrderAccess::storestore();</span>
<span class="line-added">197   *flags ^= (u1)flag;</span>
<span class="line-added">198 }</span>
<span class="line-added">199 </span>
<span class="line-added">200 inline bool test(const u2* flags, FLAG flag) {</span>
<span class="line-added">201   return (u1)flag == (load(flags) &amp; (u1)flag);</span>
<span class="line-added">202 }</span>
<span class="line-added">203 </span>
204 bool JfrBuffer::transient() const {
<span class="line-modified">205   return test(&amp;_flags, TRANSIENT);</span>
206 }
207 
208 void JfrBuffer::set_transient() {
<span class="line-modified">209   assert(acquired_by_self(), &quot;invariant&quot;);</span>
<span class="line-added">210   set(&amp;_flags, TRANSIENT);</span>
211   assert(transient(), &quot;invariant&quot;);
212 }
213 
214 void JfrBuffer::clear_transient() {
215   if (transient()) {
<span class="line-modified">216     assert(acquired_by_self(), &quot;invariant&quot;);</span>
<span class="line-added">217     clear(&amp;_flags, TRANSIENT);</span>
218   }
219   assert(!transient(), &quot;invariant&quot;);
220 }
221 
222 bool JfrBuffer::lease() const {
<span class="line-modified">223   return test(&amp;_flags, LEASE);</span>
224 }
225 
226 void JfrBuffer::set_lease() {
<span class="line-modified">227   assert(acquired_by_self(), &quot;invariant&quot;);</span>
<span class="line-added">228   set(&amp;_flags, LEASE);</span>
229   assert(lease(), &quot;invariant&quot;);
230 }
231 
232 void JfrBuffer::clear_lease() {
233   if (lease()) {
<span class="line-modified">234     assert(acquired_by_self(), &quot;invariant&quot;);</span>
<span class="line-added">235     clear(&amp;_flags, LEASE);</span>
236   }
237   assert(!lease(), &quot;invariant&quot;);
238 }
239 
<span class="line-modified">240 bool JfrBuffer::excluded() const {</span>
<span class="line-modified">241   return test(&amp;_flags, EXCLUDED);</span>
242 }
243 
<span class="line-modified">244 void JfrBuffer::set_excluded() {</span>
<span class="line-modified">245   assert(acquired_by_self(), &quot;invariant&quot;);</span>
<span class="line-added">246   set(&amp;_flags, EXCLUDED);</span>
<span class="line-added">247   assert(excluded(), &quot;invariant&quot;);</span>
<span class="line-added">248 }</span>
<span class="line-added">249 </span>
<span class="line-added">250 void JfrBuffer::clear_excluded() {</span>
<span class="line-added">251   if (excluded()) {</span>
<span class="line-added">252     assert(identity() != NULL, &quot;invariant&quot;);</span>
<span class="line-added">253     clear(&amp;_flags, EXCLUDED);</span>
<span class="line-added">254   }</span>
<span class="line-added">255   assert(!excluded(), &quot;invariant&quot;);</span>
256 }
257 
258 bool JfrBuffer::retired() const {
<span class="line-modified">259   return test(&amp;_flags, RETIRED);</span>
260 }
261 
262 void JfrBuffer::set_retired() {
<span class="line-modified">263   assert(acquired_by_self(), &quot;invariant&quot;);</span>
<span class="line-modified">264   set(&amp;_flags, RETIRED);</span>
265 }
266 
267 void JfrBuffer::clear_retired() {
<span class="line-modified">268   if (retired()) {</span>
<span class="line-modified">269     assert(identity() != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">270     clear(&amp;_flags, RETIRED);</span>

271   }
272 }
</pre>
</td>
</tr>
</table>
<center><a href="../stacktrace/jfrStackTraceRepository.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrBuffer.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
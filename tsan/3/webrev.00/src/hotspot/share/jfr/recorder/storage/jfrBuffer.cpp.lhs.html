<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jfr/recorder/storage/jfrBuffer.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/recorder/storage/jfrBuffer.hpp&quot;
<a name="2" id="anc2"></a><span class="line-removed"> 27 #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-removed"> 28 #include &quot;runtime/orderAccess.hpp&quot;</span>
 29 #include &quot;runtime/thread.inline.hpp&quot;
 30 
<a name="3" id="anc3"></a><span class="line-modified"> 31 static const u1* const MUTEX_CLAIM = NULL;</span>
 32 
 33 JfrBuffer::JfrBuffer() : _next(NULL),
 34                          _prev(NULL),
 35                          _identity(NULL),
 36                          _pos(NULL),
 37                          _top(NULL),
 38                          _flags(0),
 39                          _header_size(0),
 40                          _size(0) {}
 41 
<a name="4" id="anc4"></a><span class="line-modified"> 42 bool JfrBuffer::initialize(size_t header_size, size_t size, const void* id /* NULL */) {</span>


 43   _header_size = (u2)header_size;
 44   _size = (u4)(size / BytesPerWord);
<a name="5" id="anc5"></a><span class="line-removed"> 45   assert(_identity == NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 46   _identity = id;</span>
 47   set_pos(start());
 48   set_top(start());
<a name="6" id="anc6"></a><span class="line-removed"> 49   assert(_next == NULL, &quot;invariant&quot;);</span>
 50   assert(free_size() == size, &quot;invariant&quot;);
 51   assert(!transient(), &quot;invariant&quot;);
 52   assert(!lease(), &quot;invariant&quot;);
 53   assert(!retired(), &quot;invariant&quot;);
 54   return true;
 55 }
 56 
<a name="7" id="anc7"></a><span class="line-modified"> 57 void JfrBuffer::reinitialize() {</span>
<span class="line-modified"> 58   assert(!lease(), &quot;invariant&quot;);</span>
<span class="line-removed"> 59   assert(!transient(), &quot;invariant&quot;);</span>
<span class="line-removed"> 60   set_pos(start());</span>
<span class="line-removed"> 61   clear_retired();</span>
<span class="line-removed"> 62   set_top(start());</span>
<span class="line-removed"> 63 }</span>
<span class="line-removed"> 64 </span>
<span class="line-removed"> 65 void JfrBuffer::concurrent_reinitialization() {</span>
<span class="line-removed"> 66   concurrent_top();</span>
 67   assert(!lease(), &quot;invariant&quot;);
 68   assert(!transient(), &quot;invariant&quot;);
<a name="8" id="anc8"></a>







 69   set_pos(start());
<a name="9" id="anc9"></a><span class="line-modified"> 70   set_concurrent_top(start());</span>
 71   clear_retired();
 72 }
 73 
<a name="10" id="anc10"></a><span class="line-modified"> 74 size_t JfrBuffer::discard() {</span>
<span class="line-modified"> 75   size_t discard_size = unflushed_size();</span>
<span class="line-removed"> 76   set_top(pos());</span>
<span class="line-removed"> 77   return discard_size;</span>
 78 }
 79 
 80 const u1* JfrBuffer::stable_top() const {
 81   const u1* current_top;
 82   do {
<a name="11" id="anc11"></a><span class="line-modified"> 83     current_top = OrderAccess::load_acquire(&amp;_top);</span>
<span class="line-modified"> 84   } while (MUTEX_CLAIM == current_top);</span>
 85   return current_top;
 86 }
 87 
<a name="12" id="anc12"></a><span class="line-removed"> 88 const u1* JfrBuffer::top() const {</span>
<span class="line-removed"> 89   return _top;</span>
<span class="line-removed"> 90 }</span>
<span class="line-removed"> 91 </span>
 92 void JfrBuffer::set_top(const u1* new_top) {
<a name="13" id="anc13"></a><span class="line-modified"> 93   _top = new_top;</span>


 94 }
 95 
<a name="14" id="anc14"></a><span class="line-modified"> 96 const u1* JfrBuffer::concurrent_top() const {</span>
 97   do {
 98     const u1* current_top = stable_top();
<a name="15" id="anc15"></a><span class="line-modified"> 99     if (Atomic::cmpxchg(MUTEX_CLAIM, &amp;_top, current_top) == current_top) {</span>

100       return current_top;
101     }
102   } while (true);
103 }
104 
<a name="16" id="anc16"></a><span class="line-modified">105 void JfrBuffer::set_concurrent_top(const u1* new_top) {</span>
<span class="line-modified">106   assert(new_top != MUTEX_CLAIM, &quot;invariant&quot;);</span>
<span class="line-modified">107   assert(new_top &lt;= end(), &quot;invariant&quot;);</span>
<span class="line-modified">108   assert(new_top &gt;= start(), &quot;invariant&quot;);</span>
<span class="line-removed">109   assert(top() == MUTEX_CLAIM, &quot;invariant&quot;);</span>
<span class="line-removed">110   OrderAccess::release_store(&amp;_top, new_top);</span>
111 }
112 
<a name="17" id="anc17"></a><span class="line-modified">113 size_t JfrBuffer::unflushed_size() const {</span>
<span class="line-modified">114   return pos() - stable_top();</span>




115 }
116 
117 void JfrBuffer::acquire(const void* id) {
118   assert(id != NULL, &quot;invariant&quot;);
119   const void* current_id;
120   do {
<a name="18" id="anc18"></a><span class="line-modified">121     current_id = OrderAccess::load_acquire(&amp;_identity);</span>
<span class="line-modified">122   } while (current_id != NULL || Atomic::cmpxchg(id, &amp;_identity, current_id) != current_id);</span>
123 }
124 
125 bool JfrBuffer::try_acquire(const void* id) {
126   assert(id != NULL, &quot;invariant&quot;);
<a name="19" id="anc19"></a><span class="line-modified">127   const void* const current_id = OrderAccess::load_acquire(&amp;_identity);</span>
<span class="line-modified">128   return current_id == NULL &amp;&amp; Atomic::cmpxchg(id, &amp;_identity, current_id) == current_id;</span>
129 }
130 
131 void JfrBuffer::release() {
<a name="20" id="anc20"></a><span class="line-modified">132   OrderAccess::release_store(&amp;_identity, (const void*)NULL);</span>
<span class="line-modified">133 }</span>
<span class="line-removed">134 </span>
<span class="line-removed">135 void JfrBuffer::clear_identity() {</span>
<span class="line-removed">136   _identity = NULL;</span>
137 }
138 
139 #ifdef ASSERT
140 static bool validate_to(const JfrBuffer* const to, size_t size) {
141   assert(to != NULL, &quot;invariant&quot;);
142   assert(to-&gt;acquired_by_self(), &quot;invariant&quot;);
143   assert(to-&gt;free_size() &gt;= size, &quot;invariant&quot;);
144   return true;
145 }
146 
<a name="21" id="anc21"></a><span class="line-removed">147 static bool validate_concurrent_this(const JfrBuffer* const t, size_t size) {</span>
<span class="line-removed">148   assert(t-&gt;top() == MUTEX_CLAIM, &quot;invariant&quot;);</span>
<span class="line-removed">149   return true;</span>
<span class="line-removed">150 }</span>
<span class="line-removed">151 </span>
152 static bool validate_this(const JfrBuffer* const t, size_t size) {
<a name="22" id="anc22"></a><span class="line-modified">153   assert(t-&gt;top() + size &lt;= t-&gt;pos(), &quot;invariant&quot;);</span>

154   return true;
155 }
<a name="23" id="anc23"></a><span class="line-removed">156 </span>
<span class="line-removed">157 bool JfrBuffer::acquired_by_self() const {</span>
<span class="line-removed">158   return identity() == Thread::current();</span>
<span class="line-removed">159 }</span>
160 #endif // ASSERT
161 
162 void JfrBuffer::move(JfrBuffer* const to, size_t size) {
163   assert(validate_to(to, size), &quot;invariant&quot;);
<a name="24" id="anc24"></a>
164   assert(validate_this(this, size), &quot;invariant&quot;);
<a name="25" id="anc25"></a><span class="line-modified">165   const u1* current_top = top();</span>
<span class="line-modified">166   assert(current_top != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">167   memcpy(to-&gt;pos(), current_top, size);</span>
<span class="line-modified">168   to-&gt;set_pos(size);</span>


169   to-&gt;release();
<a name="26" id="anc26"></a><span class="line-modified">170   set_top(current_top + size);</span>

171 }
172 
<a name="27" id="anc27"></a><span class="line-modified">173 void JfrBuffer::concurrent_move_and_reinitialize(JfrBuffer* const to, size_t size) {</span>
<span class="line-modified">174   assert(validate_to(to, size), &quot;invariant&quot;);</span>
<span class="line-modified">175   const u1* current_top = concurrent_top();</span>
<span class="line-modified">176   assert(validate_concurrent_this(this, size), &quot;invariant&quot;);</span>
<span class="line-modified">177   const size_t actual_size = MIN2(size, (size_t)(pos() - current_top));</span>
<span class="line-modified">178   assert(actual_size &lt;= size, &quot;invariant&quot;);</span>
<span class="line-modified">179   memcpy(to-&gt;pos(), current_top, actual_size);</span>
<span class="line-modified">180   to-&gt;set_pos(actual_size);</span>
<span class="line-modified">181   set_pos(start());</span>
<span class="line-modified">182   to-&gt;release();</span>
<span class="line-modified">183   set_concurrent_top(start());</span>

184 }
185 
<a name="28" id="anc28"></a><span class="line-removed">186 // flags</span>
187 enum FLAG {
188   RETIRED = 1,
189   TRANSIENT = 2,
<a name="29" id="anc29"></a><span class="line-modified">190   LEASE = 4</span>

191 };
192 
<a name="30" id="anc30"></a>




















193 bool JfrBuffer::transient() const {
<a name="31" id="anc31"></a><span class="line-modified">194   return (u1)TRANSIENT == (_flags &amp; (u1)TRANSIENT);</span>
195 }
196 
197 void JfrBuffer::set_transient() {
<a name="32" id="anc32"></a><span class="line-modified">198   _flags |= (u1)TRANSIENT;</span>

199   assert(transient(), &quot;invariant&quot;);
200 }
201 
202 void JfrBuffer::clear_transient() {
203   if (transient()) {
<a name="33" id="anc33"></a><span class="line-modified">204     _flags ^= (u1)TRANSIENT;</span>

205   }
206   assert(!transient(), &quot;invariant&quot;);
207 }
208 
209 bool JfrBuffer::lease() const {
<a name="34" id="anc34"></a><span class="line-modified">210   return (u1)LEASE == (_flags &amp; (u1)LEASE);</span>
211 }
212 
213 void JfrBuffer::set_lease() {
<a name="35" id="anc35"></a><span class="line-modified">214   _flags |= (u1)LEASE;</span>

215   assert(lease(), &quot;invariant&quot;);
216 }
217 
218 void JfrBuffer::clear_lease() {
219   if (lease()) {
<a name="36" id="anc36"></a><span class="line-modified">220     _flags ^= (u1)LEASE;</span>

221   }
222   assert(!lease(), &quot;invariant&quot;);
223 }
224 
<a name="37" id="anc37"></a><span class="line-modified">225 static u2 load_acquire_flags(const u2* const flags) {</span>
<span class="line-modified">226   return OrderAccess::load_acquire(flags);</span>
227 }
228 
<a name="38" id="anc38"></a><span class="line-modified">229 static void release_store_flags(u2* const flags, u2 new_flags) {</span>
<span class="line-modified">230   OrderAccess::release_store(flags, new_flags);</span>










231 }
232 
233 bool JfrBuffer::retired() const {
<a name="39" id="anc39"></a><span class="line-modified">234   return (u1)RETIRED == (load_acquire_flags(&amp;_flags) &amp; (u1)RETIRED);</span>
235 }
236 
237 void JfrBuffer::set_retired() {
<a name="40" id="anc40"></a><span class="line-modified">238   const u2 new_flags = load_acquire_flags(&amp;_flags) | (u1)RETIRED;</span>
<span class="line-modified">239   release_store_flags(&amp;_flags, new_flags);</span>
240 }
241 
242 void JfrBuffer::clear_retired() {
<a name="41" id="anc41"></a><span class="line-modified">243   u2 new_flags = load_acquire_flags(&amp;_flags);</span>
<span class="line-modified">244   if ((u1)RETIRED == (new_flags &amp; (u1)RETIRED)) {</span>
<span class="line-modified">245     new_flags ^= (u1)RETIRED;</span>
<span class="line-removed">246     release_store_flags(&amp;_flags, new_flags);</span>
247   }
248 }
<a name="42" id="anc42"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="42" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jfr/recorder/repository/jfrEmergencyDump.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/jfrEvents.hpp&quot;
<a name="1" id="anc1"></a>
 27 #include &quot;jfr/leakprofiler/leakProfiler.hpp&quot;
 28 #include &quot;jfr/recorder/repository/jfrEmergencyDump.hpp&quot;
 29 #include &quot;jfr/recorder/service/jfrPostBox.hpp&quot;
 30 #include &quot;jfr/recorder/service/jfrRecorderService.hpp&quot;
 31 #include &quot;jfr/utilities/jfrTypes.hpp&quot;
<a name="2" id="anc2"></a>
 32 #include &quot;memory/resourceArea.hpp&quot;
 33 #include &quot;runtime/atomic.hpp&quot;
 34 #include &quot;runtime/handles.inline.hpp&quot;
 35 #include &quot;runtime/globals.hpp&quot;
 36 #include &quot;runtime/mutexLocker.hpp&quot;
<a name="3" id="anc3"></a><span class="line-modified"> 37 #include &quot;runtime/thread.hpp&quot;</span>




































































































































































































































































































 38 
 39 /*
 40 * We are just about to exit the VM, so we will be very aggressive
<a name="4" id="anc4"></a><span class="line-modified"> 41 * at this point in order to increase overall success of dumping jfr data:</span>
<span class="line-removed"> 42 *</span>
<span class="line-removed"> 43 * 1. if the thread state is not &quot;_thread_in_vm&quot;, we will quick transition</span>
<span class="line-removed"> 44 *    it to &quot;_thread_in_vm&quot;.</span>
<span class="line-removed"> 45 * 2. the nesting state for both resource and handle areas are unknown,</span>
<span class="line-removed"> 46 *    so we allocate new fresh arenas, discarding the old ones.</span>
<span class="line-removed"> 47 * 3. if the thread is the owner of some critical lock(s), unlock them.</span>
 48 *
 49 * If we end up deadlocking in the attempt of dumping out jfr data,
 50 * we rely on the WatcherThread task &quot;is_error_reported()&quot;,
<a name="5" id="anc5"></a><span class="line-modified"> 51 * to exit the VM after a hard-coded timeout.</span>
 52 * This &quot;safety net&quot; somewhat explains the aggressiveness in this attempt.
 53 *
 54 */
<a name="6" id="anc6"></a><span class="line-modified"> 55 static void prepare_for_emergency_dump(Thread* thread) {</span>
<span class="line-modified"> 56   if (thread-&gt;is_Java_thread()) {</span>
<span class="line-modified"> 57     ((JavaThread*)thread)-&gt;set_thread_state(_thread_in_vm);</span>







 58   }
 59 
 60 #ifdef ASSERT
<a name="7" id="anc7"></a><span class="line-modified"> 61   Monitor* owned_lock = thread-&gt;owned_locks();</span>
 62   while (owned_lock != NULL) {
<a name="8" id="anc8"></a><span class="line-modified"> 63     Monitor* next = owned_lock-&gt;next();</span>
 64     owned_lock-&gt;unlock();
 65     owned_lock = next;
 66   }
 67 #endif // ASSERT
 68 
 69   if (Threads_lock-&gt;owned_by_self()) {
 70     Threads_lock-&gt;unlock();
 71   }
 72 
 73   if (Module_lock-&gt;owned_by_self()) {
 74     Module_lock-&gt;unlock();
 75   }
 76 
 77   if (ClassLoaderDataGraph_lock-&gt;owned_by_self()) {
 78     ClassLoaderDataGraph_lock-&gt;unlock();
 79   }
 80 
 81   if (Heap_lock-&gt;owned_by_self()) {
 82     Heap_lock-&gt;unlock();
 83   }
 84 
 85   if (VMOperationQueue_lock-&gt;owned_by_self()) {
 86     VMOperationQueue_lock-&gt;unlock();
 87   }
 88 
 89   if (VMOperationRequest_lock-&gt;owned_by_self()) {
 90     VMOperationRequest_lock-&gt;unlock();
 91   }
 92 
<a name="9" id="anc9"></a><span class="line-removed"> 93 </span>
 94   if (Service_lock-&gt;owned_by_self()) {
 95     Service_lock-&gt;unlock();
 96   }
 97 
<a name="10" id="anc10"></a>



 98   if (CodeCache_lock-&gt;owned_by_self()) {
 99     CodeCache_lock-&gt;unlock();
100   }
101 
102   if (PeriodicTask_lock-&gt;owned_by_self()) {
103     PeriodicTask_lock-&gt;unlock();
104   }
105 
106   if (JfrMsg_lock-&gt;owned_by_self()) {
107     JfrMsg_lock-&gt;unlock();
108   }
109 
110   if (JfrBuffer_lock-&gt;owned_by_self()) {
111     JfrBuffer_lock-&gt;unlock();
112   }
113 
<a name="11" id="anc11"></a><span class="line-removed">114   if (JfrStream_lock-&gt;owned_by_self()) {</span>
<span class="line-removed">115     JfrStream_lock-&gt;unlock();</span>
<span class="line-removed">116   }</span>
<span class="line-removed">117 </span>
118   if (JfrStacktrace_lock-&gt;owned_by_self()) {
119     JfrStacktrace_lock-&gt;unlock();
120   }
<a name="12" id="anc12"></a>
121 }
122 
123 static volatile int jfr_shutdown_lock = 0;
124 
125 static bool guard_reentrancy() {
<a name="13" id="anc13"></a><span class="line-modified">126   return Atomic::cmpxchg(1, &amp;jfr_shutdown_lock, 0) == 0;</span>
127 }
128 
<a name="14" id="anc14"></a>





















129 void JfrEmergencyDump::on_vm_shutdown(bool exception_handler) {
130   if (!guard_reentrancy()) {
131     return;
132   }
<a name="15" id="anc15"></a><span class="line-modified">133   // function made non-reentrant</span>
<span class="line-modified">134   Thread* thread = Thread::current();</span>
<span class="line-modified">135   if (exception_handler) {</span>
<span class="line-modified">136     // we are crashing</span>
<span class="line-removed">137     if (thread-&gt;is_Watcher_thread()) {</span>
<span class="line-removed">138       // The Watcher thread runs the periodic thread sampling task.</span>
<span class="line-removed">139       // If it has crashed, it is likely that another thread is</span>
<span class="line-removed">140       // left in a suspended state. This would mean the system</span>
<span class="line-removed">141       // will not be able to ever move to a safepoint. We try</span>
<span class="line-removed">142       // to avoid issuing safepoint operations when attempting</span>
<span class="line-removed">143       // an emergency dump, but a safepoint might be already pending.</span>
<span class="line-removed">144       return;</span>
<span class="line-removed">145     }</span>
<span class="line-removed">146     prepare_for_emergency_dump(thread);</span>
147   }
<a name="16" id="anc16"></a>





148   EventDumpReason event;
149   if (event.should_commit()) {
150     event.set_reason(exception_handler ? &quot;Crash&quot; : &quot;Out of Memory&quot;);
151     event.set_recordingId(-1);
152     event.commit();
153   }
154   if (!exception_handler) {
155     // OOM
156     LeakProfiler::emit_events(max_jlong, false);
157   }
158   const int messages = MSGBIT(MSG_VM_ERROR);
<a name="17" id="anc17"></a><span class="line-removed">159   ResourceMark rm(thread);</span>
<span class="line-removed">160   HandleMark hm(thread);</span>
161   JfrRecorderService service;
162   service.rotate(messages);
163 }
<a name="18" id="anc18"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="18" type="hidden" />
</body>
</html>
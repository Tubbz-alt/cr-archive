<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jfr/recorder/repository/jfrRepository.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/jfr.hpp&quot;
 27 #include &quot;jfr/jni/jfrJavaSupport.hpp&quot;
 28 #include &quot;jfr/recorder/jfrRecorder.hpp&quot;
<a name="1" id="anc1"></a><span class="line-removed"> 29 #include &quot;jfr/recorder/repository/jfrChunkState.hpp&quot;</span>
 30 #include &quot;jfr/recorder/repository/jfrChunkWriter.hpp&quot;
<a name="2" id="anc2"></a>
 31 #include &quot;jfr/recorder/repository/jfrRepository.hpp&quot;
 32 #include &quot;jfr/recorder/service/jfrPostBox.hpp&quot;
 33 #include &quot;logging/log.hpp&quot;
 34 #include &quot;memory/resourceArea.hpp&quot;
 35 #include &quot;runtime/mutex.hpp&quot;
 36 #include &quot;runtime/os.hpp&quot;
 37 #include &quot;runtime/thread.inline.hpp&quot;
 38 
 39 static JfrRepository* _instance = NULL;
 40 
 41 JfrRepository&amp; JfrRepository::instance() {
 42   return *_instance;
 43 }
 44 
 45 static JfrChunkWriter* _chunkwriter = NULL;
 46 
<a name="3" id="anc3"></a><span class="line-removed"> 47 static bool initialize_chunkwriter() {</span>
<span class="line-removed"> 48   assert(_chunkwriter == NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 49   _chunkwriter = new JfrChunkWriter();</span>
<span class="line-removed"> 50   return _chunkwriter != NULL &amp;&amp; _chunkwriter-&gt;initialize();</span>
<span class="line-removed"> 51 }</span>
 52 
 53 JfrChunkWriter&amp; JfrRepository::chunkwriter() {
 54   return *_chunkwriter;
 55 }
 56 
 57 JfrRepository::JfrRepository(JfrPostBox&amp; post_box) : _path(NULL), _post_box(post_box) {}
 58 
 59 bool JfrRepository::initialize() {
<a name="4" id="anc4"></a><span class="line-modified"> 60   return initialize_chunkwriter();</span>


 61 }
 62 
 63 JfrRepository::~JfrRepository() {
 64   if (_path != NULL) {
 65     JfrCHeapObj::free(_path, strlen(_path) + 1);
 66     _path = NULL;
 67   }
 68 
 69   if (_chunkwriter != NULL) {
 70     delete _chunkwriter;
 71     _chunkwriter = NULL;
 72   }
 73 }
 74 
 75 JfrRepository* JfrRepository::create(JfrPostBox&amp; post_box) {
 76   assert(_instance == NULL, &quot;invariant&quot;);
 77   _instance = new JfrRepository(post_box);
 78   return _instance;
 79 }
 80 
 81 void JfrRepository::destroy() {
 82   assert(_instance != NULL, &quot;invariant&quot;);
 83   delete _instance;
 84   _instance = NULL;
 85 }
 86 
<a name="5" id="anc5"></a><span class="line-removed"> 87 static const char vm_error_filename_fmt[] = &quot;hs_err_pid%p.jfr&quot;;</span>
<span class="line-removed"> 88 static const char vm_oom_filename_fmt[] = &quot;hs_oom_pid%p.jfr&quot;;</span>
<span class="line-removed"> 89 static const char vm_soe_filename_fmt[] = &quot;hs_soe_pid%p.jfr&quot;;</span>
<span class="line-removed"> 90 static const char chunk_file_jfr_ext[] = &quot;.jfr&quot;;</span>
<span class="line-removed"> 91 static const size_t iso8601_len = 19; // &quot;YYYY-MM-DDTHH:MM:SS&quot;</span>
<span class="line-removed"> 92 </span>
<span class="line-removed"> 93 static fio_fd open_exclusivly(const char* path) {</span>
<span class="line-removed"> 94   return os::open(path, O_CREAT | O_WRONLY, S_IREAD | S_IWRITE);</span>
<span class="line-removed"> 95 }</span>
<span class="line-removed"> 96 </span>
<span class="line-removed"> 97 static fio_fd open_existing(const char* path) {</span>
<span class="line-removed"> 98   return os::open(path, O_RDWR, S_IREAD | S_IWRITE);</span>
<span class="line-removed"> 99 }</span>
<span class="line-removed">100 </span>
<span class="line-removed">101 static int file_sort(const char** const file1, const char** file2) {</span>
<span class="line-removed">102   assert(NULL != *file1 &amp;&amp; NULL != *file2, &quot;invariant&quot;);</span>
<span class="line-removed">103   int cmp = strncmp(*file1, *file2, iso8601_len);</span>
<span class="line-removed">104   if (0 == cmp) {</span>
<span class="line-removed">105     const char* const dot1 = strchr(*file1, &#39;.&#39;);</span>
<span class="line-removed">106     assert(NULL != dot1, &quot;invariant&quot;);</span>
<span class="line-removed">107     const char* const dot2 = strchr(*file2, &#39;.&#39;);</span>
<span class="line-removed">108     assert(NULL != dot2, &quot;invariant&quot;);</span>
<span class="line-removed">109     ptrdiff_t file1_len = dot1 - *file1;</span>
<span class="line-removed">110     ptrdiff_t file2_len = dot2 - *file2;</span>
<span class="line-removed">111     if (file1_len &lt; file2_len) {</span>
<span class="line-removed">112       return -1;</span>
<span class="line-removed">113     }</span>
<span class="line-removed">114     if (file1_len &gt; file2_len) {</span>
<span class="line-removed">115       return 1;</span>
<span class="line-removed">116     }</span>
<span class="line-removed">117     assert(file1_len == file2_len, &quot;invariant&quot;);</span>
<span class="line-removed">118     cmp = strncmp(*file1, *file2, file1_len);</span>
<span class="line-removed">119   }</span>
<span class="line-removed">120   assert(cmp != 0, &quot;invariant&quot;);</span>
<span class="line-removed">121   return cmp;</span>
<span class="line-removed">122 }</span>
<span class="line-removed">123 </span>
<span class="line-removed">124 static void iso8601_to_date_time(char* iso8601_str) {</span>
<span class="line-removed">125   assert(iso8601_str != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">126   assert(strlen(iso8601_str) == iso8601_len, &quot;invariant&quot;);</span>
<span class="line-removed">127   // &quot;YYYY-MM-DDTHH:MM:SS&quot;</span>
<span class="line-removed">128   for (size_t i = 0; i &lt; iso8601_len; ++i) {</span>
<span class="line-removed">129     switch(iso8601_str[i]) {</span>
<span class="line-removed">130       case &#39;T&#39; :</span>
<span class="line-removed">131       case &#39;-&#39; :</span>
<span class="line-removed">132       case &#39;:&#39; :</span>
<span class="line-removed">133         iso8601_str[i] = &#39;_&#39;;</span>
<span class="line-removed">134         break;</span>
<span class="line-removed">135     }</span>
<span class="line-removed">136   }</span>
<span class="line-removed">137   // &quot;YYYY_MM_DD_HH_MM_SS&quot;</span>
<span class="line-removed">138 }</span>
<span class="line-removed">139 </span>
<span class="line-removed">140 static void date_time(char* buffer, size_t buffer_len) {</span>
<span class="line-removed">141   assert(buffer != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">142   assert(buffer_len &gt;= iso8601_len, &quot;buffer too small&quot;);</span>
<span class="line-removed">143   os::iso8601_time(buffer, buffer_len);</span>
<span class="line-removed">144   assert(strlen(buffer) &gt;= iso8601_len + 1, &quot;invariant&quot;);</span>
<span class="line-removed">145   // &quot;YYYY-MM-DDTHH:MM:SS&quot;</span>
<span class="line-removed">146   buffer[iso8601_len] = &#39;\0&#39;;</span>
<span class="line-removed">147   iso8601_to_date_time(buffer);</span>
<span class="line-removed">148 }</span>
<span class="line-removed">149 </span>
<span class="line-removed">150 static int64_t file_size(fio_fd fd) {</span>
<span class="line-removed">151   assert(fd != invalid_fd, &quot;invariant&quot;);</span>
<span class="line-removed">152   const int64_t current_offset = os::current_file_offset(fd);</span>
<span class="line-removed">153   const int64_t size = os::lseek(fd, 0, SEEK_END);</span>
<span class="line-removed">154   os::seek_to_file_offset(fd, current_offset);</span>
<span class="line-removed">155   return size;</span>
<span class="line-removed">156 }</span>
<span class="line-removed">157 </span>
<span class="line-removed">158 class RepositoryIterator : public StackObj {</span>
<span class="line-removed">159  private:</span>
<span class="line-removed">160   const char* const _repo;</span>
<span class="line-removed">161   const size_t _repository_len;</span>
<span class="line-removed">162   GrowableArray&lt;const char*&gt;* _files;</span>
<span class="line-removed">163   const char* const fully_qualified(const char* entry) const;</span>
<span class="line-removed">164   mutable int _iterator;</span>
<span class="line-removed">165 </span>
<span class="line-removed">166  public:</span>
<span class="line-removed">167    RepositoryIterator(const char* repository, size_t repository_len);</span>
<span class="line-removed">168    ~RepositoryIterator() {}</span>
<span class="line-removed">169   debug_only(void print_repository_files() const;)</span>
<span class="line-removed">170   const char* const filter(const char* entry) const;</span>
<span class="line-removed">171   bool has_next() const;</span>
<span class="line-removed">172   const char* const next() const;</span>
<span class="line-removed">173 };</span>
<span class="line-removed">174 </span>
<span class="line-removed">175 const char* const RepositoryIterator::fully_qualified(const char* entry) const {</span>
<span class="line-removed">176   assert(NULL != entry, &quot;invariant&quot;);</span>
<span class="line-removed">177   char* file_path_entry = NULL;</span>
<span class="line-removed">178    // only use files that have content, not placeholders</span>
<span class="line-removed">179   const char* const file_separator = os::file_separator();</span>
<span class="line-removed">180   if (NULL != file_separator) {</span>
<span class="line-removed">181     const size_t entry_len = strlen(entry);</span>
<span class="line-removed">182     const size_t file_separator_length = strlen(file_separator);</span>
<span class="line-removed">183     const size_t file_path_entry_length = _repository_len + file_separator_length + entry_len;</span>
<span class="line-removed">184     file_path_entry = NEW_RESOURCE_ARRAY_RETURN_NULL(char, file_path_entry_length + 1);</span>
<span class="line-removed">185     if (NULL == file_path_entry) {</span>
<span class="line-removed">186       return NULL;</span>
<span class="line-removed">187     }</span>
<span class="line-removed">188     int position = 0;</span>
<span class="line-removed">189     position += jio_snprintf(&amp;file_path_entry[position], _repository_len + 1, &quot;%s&quot;, _repo);</span>
<span class="line-removed">190     position += jio_snprintf(&amp;file_path_entry[position], file_separator_length + 1, &quot;%s&quot;, os::file_separator());</span>
<span class="line-removed">191     position += jio_snprintf(&amp;file_path_entry[position], entry_len + 1, &quot;%s&quot;, entry);</span>
<span class="line-removed">192     file_path_entry[position] = &#39;\0&#39;;</span>
<span class="line-removed">193     assert((size_t)position == file_path_entry_length, &quot;invariant&quot;);</span>
<span class="line-removed">194     assert(strlen(file_path_entry) == (size_t)position, &quot;invariant&quot;);</span>
<span class="line-removed">195   }</span>
<span class="line-removed">196   return file_path_entry;</span>
<span class="line-removed">197 }</span>
<span class="line-removed">198 </span>
<span class="line-removed">199 const char* const RepositoryIterator::filter(const char* entry) const {</span>
<span class="line-removed">200   if (entry == NULL) {</span>
<span class="line-removed">201     return NULL;</span>
<span class="line-removed">202   }</span>
<span class="line-removed">203   const size_t entry_len = strlen(entry);</span>
<span class="line-removed">204   if (entry_len &lt;= 2) {</span>
<span class="line-removed">205     // for &quot;.&quot; and &quot;..&quot;</span>
<span class="line-removed">206     return NULL;</span>
<span class="line-removed">207   }</span>
<span class="line-removed">208   char* entry_name = NEW_RESOURCE_ARRAY_RETURN_NULL(char, entry_len + 1);</span>
<span class="line-removed">209   if (entry_name == NULL) {</span>
<span class="line-removed">210     return NULL;</span>
<span class="line-removed">211   }</span>
<span class="line-removed">212   strncpy(entry_name, entry, entry_len + 1);</span>
<span class="line-removed">213   const char* const fully_qualified_path_entry = fully_qualified(entry_name);</span>
<span class="line-removed">214   if (NULL == fully_qualified_path_entry) {</span>
<span class="line-removed">215     return NULL;</span>
<span class="line-removed">216   }</span>
<span class="line-removed">217   const fio_fd entry_fd = open_existing(fully_qualified_path_entry);</span>
<span class="line-removed">218   if (invalid_fd == entry_fd) {</span>
<span class="line-removed">219     return NULL;</span>
<span class="line-removed">220   }</span>
<span class="line-removed">221   const int64_t entry_size = file_size(entry_fd);</span>
<span class="line-removed">222   os::close(entry_fd);</span>
<span class="line-removed">223   if (0 == entry_size) {</span>
<span class="line-removed">224     return NULL;</span>
<span class="line-removed">225   }</span>
<span class="line-removed">226   return entry_name;</span>
<span class="line-removed">227 }</span>
<span class="line-removed">228 </span>
<span class="line-removed">229 RepositoryIterator::RepositoryIterator(const char* repository, size_t repository_len) :</span>
<span class="line-removed">230   _repo(repository),</span>
<span class="line-removed">231   _repository_len(repository_len),</span>
<span class="line-removed">232   _files(NULL),</span>
<span class="line-removed">233   _iterator(0) {</span>
<span class="line-removed">234   if (NULL != _repo) {</span>
<span class="line-removed">235     assert(strlen(_repo) == _repository_len, &quot;invariant&quot;);</span>
<span class="line-removed">236     _files = new GrowableArray&lt;const char*&gt;(10);</span>
<span class="line-removed">237     DIR* dirp = os::opendir(_repo);</span>
<span class="line-removed">238     if (dirp == NULL) {</span>
<span class="line-removed">239       log_error(jfr, system)(&quot;Unable to open repository %s&quot;, _repo);</span>
<span class="line-removed">240       return;</span>
<span class="line-removed">241     }</span>
<span class="line-removed">242     struct dirent* dentry;</span>
<span class="line-removed">243     while ((dentry = os::readdir(dirp)) != NULL) {</span>
<span class="line-removed">244       const char* const entry_path = filter(dentry-&gt;d_name);</span>
<span class="line-removed">245       if (NULL != entry_path) {</span>
<span class="line-removed">246         _files-&gt;append(entry_path);</span>
<span class="line-removed">247       }</span>
<span class="line-removed">248     }</span>
<span class="line-removed">249     os::closedir(dirp);</span>
<span class="line-removed">250     if (_files-&gt;length() &gt; 1) {</span>
<span class="line-removed">251       _files-&gt;sort(file_sort);</span>
<span class="line-removed">252     }</span>
<span class="line-removed">253   }</span>
<span class="line-removed">254 }</span>
<span class="line-removed">255 </span>
<span class="line-removed">256 #ifdef ASSERT</span>
<span class="line-removed">257 void RepositoryIterator::print_repository_files() const {</span>
<span class="line-removed">258   while (has_next()) {</span>
<span class="line-removed">259     log_error(jfr, system)( &quot;%s&quot;, next());</span>
<span class="line-removed">260   }</span>
<span class="line-removed">261 }</span>
<span class="line-removed">262 #endif</span>
<span class="line-removed">263 </span>
<span class="line-removed">264 bool RepositoryIterator::has_next() const {</span>
<span class="line-removed">265   return (_files != NULL &amp;&amp; _iterator &lt; _files-&gt;length());</span>
<span class="line-removed">266 }</span>
<span class="line-removed">267 </span>
<span class="line-removed">268 const char* const RepositoryIterator::next() const {</span>
<span class="line-removed">269   return _iterator &gt;= _files-&gt;length() ? NULL : fully_qualified(_files-&gt;at(_iterator++));</span>
<span class="line-removed">270 }</span>
<span class="line-removed">271 </span>
<span class="line-removed">272 static void write_emergency_file(fio_fd emergency_fd, const RepositoryIterator&amp; iterator) {</span>
<span class="line-removed">273   assert(emergency_fd != invalid_fd, &quot;invariant&quot;);</span>
<span class="line-removed">274   const size_t size_of_file_copy_block = 1 * M; // 1 mb</span>
<span class="line-removed">275   jbyte* const file_copy_block = NEW_RESOURCE_ARRAY_RETURN_NULL(jbyte, size_of_file_copy_block);</span>
<span class="line-removed">276   if (file_copy_block == NULL) {</span>
<span class="line-removed">277     return;</span>
<span class="line-removed">278   }</span>
<span class="line-removed">279  int64_t bytes_written_total = 0;</span>
<span class="line-removed">280   while (iterator.has_next()) {</span>
<span class="line-removed">281     fio_fd current_fd = invalid_fd;</span>
<span class="line-removed">282     const char* const fqn = iterator.next();</span>
<span class="line-removed">283     if (fqn != NULL) {</span>
<span class="line-removed">284       current_fd = open_existing(fqn);</span>
<span class="line-removed">285       if (current_fd != invalid_fd) {</span>
<span class="line-removed">286         const int64_t current_filesize = file_size(current_fd);</span>
<span class="line-removed">287         assert(current_filesize &gt; 0, &quot;invariant&quot;);</span>
<span class="line-removed">288         int64_t bytes_read = 0;</span>
<span class="line-removed">289         int64_t bytes_written = 0;</span>
<span class="line-removed">290         while (bytes_read &lt; current_filesize) {</span>
<span class="line-removed">291           const ssize_t read_result = os::read_at(current_fd, file_copy_block, size_of_file_copy_block, bytes_read);</span>
<span class="line-removed">292           if (-1 == read_result) {</span>
<span class="line-removed">293             log_info(jfr) ( // For user, should not be &quot;jfr, system&quot;</span>
<span class="line-removed">294               &quot;Unable to recover JFR data&quot;);</span>
<span class="line-removed">295             break;</span>
<span class="line-removed">296           }</span>
<span class="line-removed">297           bytes_read += (int64_t)read_result;</span>
<span class="line-removed">298           assert(bytes_read - bytes_written &lt;= (int64_t)size_of_file_copy_block, &quot;invariant&quot;);</span>
<span class="line-removed">299           bytes_written += (int64_t)os::write(emergency_fd, file_copy_block, bytes_read - bytes_written);</span>
<span class="line-removed">300           assert(bytes_read == bytes_written, &quot;invariant&quot;);</span>
<span class="line-removed">301         }</span>
<span class="line-removed">302         os::close(current_fd);</span>
<span class="line-removed">303         bytes_written_total += bytes_written;</span>
<span class="line-removed">304       }</span>
<span class="line-removed">305     }</span>
<span class="line-removed">306   }</span>
<span class="line-removed">307 }</span>
<span class="line-removed">308 </span>
<span class="line-removed">309 static const char* create_emergency_dump_path() {</span>
<span class="line-removed">310   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-removed">311   char* buffer = NEW_RESOURCE_ARRAY_RETURN_NULL(char, O_BUFLEN);</span>
<span class="line-removed">312   if (NULL == buffer) {</span>
<span class="line-removed">313     return NULL;</span>
<span class="line-removed">314   }</span>
<span class="line-removed">315   const char* const cwd = os::get_current_directory(buffer, O_BUFLEN);</span>
<span class="line-removed">316   if (NULL == cwd) {</span>
<span class="line-removed">317     return NULL;</span>
<span class="line-removed">318   }</span>
<span class="line-removed">319   size_t pos = strlen(cwd);</span>
<span class="line-removed">320   const int fsep_len = jio_snprintf(&amp;buffer[pos], O_BUFLEN - pos, &quot;%s&quot;, os::file_separator());</span>
<span class="line-removed">321   const char* filename_fmt = NULL;</span>
<span class="line-removed">322   // fetch specific error cause</span>
<span class="line-removed">323   switch (JfrJavaSupport::cause()) {</span>
<span class="line-removed">324     case JfrJavaSupport::OUT_OF_MEMORY:</span>
<span class="line-removed">325       filename_fmt = vm_oom_filename_fmt;</span>
<span class="line-removed">326       break;</span>
<span class="line-removed">327     case JfrJavaSupport::STACK_OVERFLOW:</span>
<span class="line-removed">328       filename_fmt = vm_soe_filename_fmt;</span>
<span class="line-removed">329       break;</span>
<span class="line-removed">330     default:</span>
<span class="line-removed">331       filename_fmt = vm_error_filename_fmt;</span>
<span class="line-removed">332   }</span>
<span class="line-removed">333   char* emergency_dump_path = NULL;</span>
<span class="line-removed">334   pos += fsep_len;</span>
<span class="line-removed">335   if (Arguments::copy_expand_pid(filename_fmt, strlen(filename_fmt), &amp;buffer[pos], O_BUFLEN - pos)) {</span>
<span class="line-removed">336     const size_t emergency_filename_length = strlen(buffer);</span>
<span class="line-removed">337     emergency_dump_path = NEW_RESOURCE_ARRAY_RETURN_NULL(char, emergency_filename_length + 1);</span>
<span class="line-removed">338     if (NULL == emergency_dump_path) {</span>
<span class="line-removed">339       return NULL;</span>
<span class="line-removed">340     }</span>
<span class="line-removed">341     strncpy(emergency_dump_path, buffer, emergency_filename_length + 1);</span>
<span class="line-removed">342   }</span>
<span class="line-removed">343   return emergency_dump_path;</span>
<span class="line-removed">344 }</span>
<span class="line-removed">345 </span>
<span class="line-removed">346 // Caller needs ResourceMark</span>
<span class="line-removed">347 static const char* create_emergency_chunk_path(const char* repository_base, size_t repository_len) {</span>
<span class="line-removed">348   assert(repository_base != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">349   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-removed">350   // date time</span>
<span class="line-removed">351   char date_time_buffer[32] = {0};</span>
<span class="line-removed">352   date_time(date_time_buffer, sizeof(date_time_buffer));</span>
<span class="line-removed">353   size_t date_time_len = strlen(date_time_buffer);</span>
<span class="line-removed">354   size_t chunkname_max_len = repository_len               // repository_base</span>
<span class="line-removed">355                              + 1                          // &quot;/&quot;</span>
<span class="line-removed">356                              + date_time_len              // date_time</span>
<span class="line-removed">357                              + strlen(chunk_file_jfr_ext) // .jfr</span>
<span class="line-removed">358                              + 1;</span>
<span class="line-removed">359   char* chunk_path = NEW_RESOURCE_ARRAY_RETURN_NULL(char, chunkname_max_len);</span>
<span class="line-removed">360   if (chunk_path == NULL) {</span>
<span class="line-removed">361     return NULL;</span>
<span class="line-removed">362   }</span>
<span class="line-removed">363   // append the individual substrings</span>
<span class="line-removed">364   jio_snprintf(chunk_path, chunkname_max_len, &quot;%s%s%s%s&quot;, repository_base, os::file_separator(), date_time_buffer, chunk_file_jfr_ext);</span>
<span class="line-removed">365   return chunk_path;</span>
<span class="line-removed">366 }</span>
<span class="line-removed">367 </span>
<span class="line-removed">368 static fio_fd emergency_dump_file() {</span>
<span class="line-removed">369   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-removed">370   ResourceMark rm;</span>
<span class="line-removed">371   const char* const emergency_dump_path = create_emergency_dump_path();</span>
<span class="line-removed">372   if (emergency_dump_path == NULL) {</span>
<span class="line-removed">373     return invalid_fd;</span>
<span class="line-removed">374   }</span>
<span class="line-removed">375   const fio_fd fd = open_exclusivly(emergency_dump_path);</span>
<span class="line-removed">376   if (fd != invalid_fd) {</span>
<span class="line-removed">377     log_info(jfr)( // For user, should not be &quot;jfr, system&quot;</span>
<span class="line-removed">378       &quot;Attempting to recover JFR data, emergency jfr file: %s&quot;, emergency_dump_path);</span>
<span class="line-removed">379   }</span>
<span class="line-removed">380   return fd;</span>
<span class="line-removed">381 }</span>
<span class="line-removed">382 </span>
<span class="line-removed">383 static const char* emergency_path(const char* repository, size_t repository_len) {</span>
<span class="line-removed">384   return repository == NULL ? create_emergency_dump_path() : create_emergency_chunk_path(repository, repository_len);</span>
<span class="line-removed">385 }</span>
<span class="line-removed">386 </span>
387 void JfrRepository::on_vm_error() {
<a name="6" id="anc6"></a><span class="line-modified">388   assert(!JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-removed">389   const char* path = _path;</span>
<span class="line-removed">390   if (path == NULL) {</span>
391     // completed already
392     return;
393   }
<a name="7" id="anc7"></a><span class="line-modified">394   ResourceMark rm;</span>
<span class="line-removed">395   MutexLockerEx stream_lock(JfrStream_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed">396   const fio_fd emergency_fd = emergency_dump_file();</span>
<span class="line-removed">397   if (emergency_fd != invalid_fd) {</span>
<span class="line-removed">398     RepositoryIterator iterator(path, strlen(path));</span>
<span class="line-removed">399     write_emergency_file(emergency_fd, iterator);</span>
<span class="line-removed">400     os::close(emergency_fd);</span>
<span class="line-removed">401   }</span>
402 }
403 
404 bool JfrRepository::set_path(const char* path) {
405   assert(path != NULL, &quot;trying to set the repository path with a NULL string!&quot;);
406   if (_path != NULL) {
407     // delete existing
408     JfrCHeapObj::free(_path, strlen(_path) + 1);
409   }
410   const size_t path_len = strlen(path);
411   _path = JfrCHeapObj::new_array&lt;char&gt;(path_len + 1);
412   if (_path == NULL) {
413     return false;
414   }
415   strncpy(_path, path, path_len + 1);
416   return true;
417 }
418 
<a name="8" id="anc8"></a><span class="line-removed">419 void JfrRepository::set_chunk_path(const char* path) {</span>
<span class="line-removed">420   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-removed">421   chunkwriter().set_chunk_path(path);</span>
<span class="line-removed">422 }</span>
<span class="line-removed">423 </span>
424 void JfrRepository::notify_on_new_chunk_path() {
425   if (Jfr::is_recording()) {
<a name="9" id="anc9"></a>
426     instance()._post_box.post(MSG_ROTATE);
427   }
428 }
429 
<a name="10" id="anc10"></a>











430 /**
431 * Sets the file where data should be written.
432 *
433 * Recording  Previous  Current  Action
434 * ==============================================
435 *   true     null      null     Ignore, keep recording in-memory
436 *   true     null      file1    Start disk recording
437 *   true     file      null     Copy out metadata to disk and continue in-memory recording
438 *   true     file1     file2    Copy out metadata and start with new File (file2)
439 *   false     *        null     Ignore, but start recording to memory
440 *   false     *        file     Ignore, but start recording to disk
441 */
442 void JfrRepository::set_chunk_path(jstring path, JavaThread* jt) {
443   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(jt));
444   ResourceMark rm(jt);
445   const char* const canonical_chunk_path = JfrJavaSupport::c_str(path, jt);
<a name="11" id="anc11"></a><span class="line-modified">446   {</span>
<span class="line-modified">447     MutexLockerEx stream_lock(JfrStream_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">448     if (NULL == canonical_chunk_path &amp;&amp; !_chunkwriter-&gt;is_valid()) {</span>
<span class="line-removed">449       // new output is NULL and current output is NULL</span>
<span class="line-removed">450       return;</span>
<span class="line-removed">451     }</span>
<span class="line-removed">452     instance().set_chunk_path(canonical_chunk_path);</span>
453   }
<a name="12" id="anc12"></a>
454   notify_on_new_chunk_path();
455 }
456 
457 void JfrRepository::set_path(jstring location, JavaThread* jt) {
458   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(jt));
459   ResourceMark rm(jt);
460   const char* const path = JfrJavaSupport::c_str(location, jt);
461   if (path != NULL) {
462     instance().set_path(path);
463   }
464 }
465 
466 bool JfrRepository::open_chunk(bool vm_error /* false */) {
<a name="13" id="anc13"></a><span class="line-removed">467   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
468   if (vm_error) {
469     ResourceMark rm;
<a name="14" id="anc14"></a><span class="line-modified">470     const char* repository_path = _path;</span>
<span class="line-removed">471     const size_t repository_path_len = repository_path != NULL ? strlen(repository_path) : 0;</span>
<span class="line-removed">472     const char* const path = emergency_path(repository_path, repository_path_len);</span>
<span class="line-removed">473     _chunkwriter-&gt;set_chunk_path(path);</span>
474   }
475   return _chunkwriter-&gt;open();
476 }
477 
<a name="15" id="anc15"></a><span class="line-modified">478 size_t JfrRepository::close_chunk(int64_t metadata_offset) {</span>
<span class="line-modified">479   return _chunkwriter-&gt;close(metadata_offset);</span>















480 }
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>
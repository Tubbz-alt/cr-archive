<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jfr/recorder/service/jfrPostBox.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/recorder/service/jfrPostBox.hpp&quot;
 27 #include &quot;jfr/utilities/jfrTryLock.hpp&quot;
 28 #include &quot;runtime/atomic.hpp&quot;
<a name="2" id="anc2"></a><span class="line-removed"> 29 #include &quot;runtime/orderAccess.hpp&quot;</span>
 30 #include &quot;runtime/thread.inline.hpp&quot;
 31 
 32 #define MSG_IS_SYNCHRONOUS ( (MSGBIT(MSG_ROTATE)) |          \
 33                              (MSGBIT(MSG_STOP))   |          \
 34                              (MSGBIT(MSG_START))  |          \
 35                              (MSGBIT(MSG_CLONE_IN_MEMORY)) | \
<a name="3" id="anc3"></a><span class="line-modified"> 36                              (MSGBIT(MSG_VM_ERROR))          \</span>

 37                            )
 38 
 39 static JfrPostBox* _instance = NULL;
 40 
 41 JfrPostBox&amp; JfrPostBox::instance() {
 42   return *_instance;
 43 }
 44 
 45 JfrPostBox* JfrPostBox::create() {
 46   assert(_instance == NULL, &quot;invariant&quot;);
 47   _instance = new JfrPostBox();
 48   return _instance;
 49 }
 50 
 51 void JfrPostBox::destroy() {
 52   assert(_instance != NULL, &quot;invariant&quot;);
 53   delete _instance;
 54   _instance = NULL;
 55 }
 56 
 57 JfrPostBox::JfrPostBox() :
 58   _msg_read_serial(0),
 59   _msg_handled_serial(0),
 60   _messages(0),
 61   _has_waiters(false) {}
 62 
 63 static bool is_thread_lock_aversive() {
 64   Thread* const thread = Thread::current();
 65   return (thread-&gt;is_Java_thread() &amp;&amp; ((JavaThread*)thread)-&gt;thread_state() != _thread_in_vm) || thread-&gt;is_VM_thread();
 66 }
 67 
 68 static bool is_synchronous(int messages) {
 69   return ((messages &amp; MSG_IS_SYNCHRONOUS) != 0);
 70 }
 71 
 72 void JfrPostBox::post(JFR_Msg msg) {
 73   const int the_message = MSGBIT(msg);
 74   if (is_thread_lock_aversive()) {
 75     deposit(the_message);
 76     return;
 77   }
 78   if (!is_synchronous(the_message)) {
 79     asynchronous_post(the_message);
 80     return;
 81   }
 82   synchronous_post(the_message);
 83 }
 84 
 85 void JfrPostBox::deposit(int new_messages) {
 86   while (true) {
<a name="4" id="anc4"></a><span class="line-modified"> 87     const int current_msgs = OrderAccess::load_acquire(&amp;_messages);</span>
 88     // OR the new message
 89     const int exchange_value = current_msgs | new_messages;
<a name="5" id="anc5"></a><span class="line-modified"> 90     const int result = Atomic::cmpxchg(exchange_value, &amp;_messages, current_msgs);</span>
 91     if (result == current_msgs) {
 92       return;
 93     }
 94     /* Some other thread just set exactly what this thread wanted */
 95     if ((result &amp; new_messages) == new_messages) {
 96       return;
 97     }
 98   }
 99 }
100 
101 void JfrPostBox::asynchronous_post(int msg) {
102   assert(!is_synchronous(msg), &quot;invariant&quot;);
103   deposit(msg);
104   JfrMonitorTryLock try_msg_lock(JfrMsg_lock);
105   if (try_msg_lock.acquired()) {
106     JfrMsg_lock-&gt;notify_all();
107   }
108 }
109 
110 void JfrPostBox::synchronous_post(int msg) {
111   assert(is_synchronous(msg), &quot;invariant&quot;);
112   assert(!JfrMsg_lock-&gt;owned_by_self(), &quot;should not hold JfrMsg_lock here!&quot;);
<a name="6" id="anc6"></a><span class="line-modified">113   MutexLockerEx msg_lock(JfrMsg_lock);</span>
114   deposit(msg);
115   // serial_id is used to check when what we send in has been processed.
116   // _msg_read_serial is read under JfrMsg_lock protection.
<a name="7" id="anc7"></a><span class="line-modified">117   const uintptr_t serial_id = OrderAccess::load_acquire(&amp;_msg_read_serial) + 1;</span>
<span class="line-modified">118   JfrMsg_lock-&gt;notify_all();</span>
119   while (!is_message_processed(serial_id)) {
<a name="8" id="anc8"></a><span class="line-modified">120     JfrMsg_lock-&gt;wait();</span>
121   }
122 }
123 
124 /*
125  * Check if a synchronous message has been processed.
126  * We avoid racing on _msg_handled_serial by ensuring
127  * that we are holding the JfrMsg_lock when checking
128  * completion status.
129  */
130 bool JfrPostBox::is_message_processed(uintptr_t serial_id) const {
131   assert(JfrMsg_lock-&gt;owned_by_self(), &quot;_msg_handled_serial must be read under JfrMsg_lock protection&quot;);
<a name="9" id="anc9"></a><span class="line-modified">132   return serial_id &lt;= OrderAccess::load_acquire(&amp;_msg_handled_serial);</span>
133 }
134 
135 bool JfrPostBox::is_empty() const {
136   assert(JfrMsg_lock-&gt;owned_by_self(), &quot;not holding JfrMsg_lock!&quot;);
<a name="10" id="anc10"></a><span class="line-modified">137   return OrderAccess::load_acquire(&amp;_messages) == 0;</span>
138 }
139 
140 int JfrPostBox::collect() {
141   // get pending and reset to 0
<a name="11" id="anc11"></a><span class="line-modified">142   const int messages = Atomic::xchg(0, &amp;_messages);</span>
143   if (check_waiters(messages)) {
144     _has_waiters = true;
145     assert(JfrMsg_lock-&gt;owned_by_self(), &quot;incrementing _msg_read_serial is protected by JfrMsg_lock&quot;);
146     // Update made visible on release of JfrMsg_lock via fence instruction in Monitor::IUnlock.
147     ++_msg_read_serial;
148   }
149   return messages;
150 }
151 
152 bool JfrPostBox::check_waiters(int messages) const {
153   assert(JfrMsg_lock-&gt;owned_by_self(), &quot;not holding JfrMsg_lock!&quot;);
154   assert(!_has_waiters, &quot;invariant&quot;);
155   return is_synchronous(messages);
156 }
157 
158 void JfrPostBox::notify_waiters() {
159   if (!_has_waiters) {
160     return;
161   }
162   _has_waiters = false;
163   assert(JfrMsg_lock-&gt;owned_by_self(), &quot;incrementing _msg_handled_serial is protected by JfrMsg_lock.&quot;);
164   // Update made visible on release of JfrMsg_lock via fence instruction in Monitor::IUnlock.
165   ++_msg_handled_serial;
166   JfrMsg_lock-&gt;notify();
167 }
168 
169 // safeguard to ensure no threads are left waiting
170 void JfrPostBox::notify_collection_stop() {
<a name="12" id="anc12"></a><span class="line-modified">171   MutexLockerEx msg_lock(JfrMsg_lock);</span>
172   JfrMsg_lock-&gt;notify_all();
173 }
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>
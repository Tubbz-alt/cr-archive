<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/jfr/recorder/checkpoint/types/jfrThreadGroup.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/recorder/checkpoint/jfrCheckpointWriter.hpp&quot;
 27 #include &quot;jfr/recorder/checkpoint/types/jfrThreadGroup.hpp&quot;
 28 #include &quot;jfr/utilities/jfrResourceManager.hpp&quot;
 29 #include &quot;jfr/utilities/jfrTypes.hpp&quot;
 30 #include &quot;runtime/handles.inline.hpp&quot;
 31 #include &quot;runtime/jniHandles.inline.hpp&quot;
 32 #include &quot;runtime/safepoint.hpp&quot;
 33 #include &quot;runtime/semaphore.hpp&quot;
 34 #include &quot;utilities/growableArray.hpp&quot;
 35 
 36 class ThreadGroupExclusiveAccess : public StackObj {
 37  private:
 38   static Semaphore _mutex_semaphore;
 39  public:
 40   ThreadGroupExclusiveAccess() { _mutex_semaphore.wait(); }
 41   ~ThreadGroupExclusiveAccess() { _mutex_semaphore.signal(); }
 42 };
 43 
 44 Semaphore ThreadGroupExclusiveAccess::_mutex_semaphore(1);
 45 JfrThreadGroup* JfrThreadGroup::_instance = NULL;
 46 
 47 class JfrThreadGroupPointers : public ResourceObj {
 48  private:
 49   const Handle _thread_group_handle;
 50   jweak _thread_group_weak_ref;
 51  public:
 52   JfrThreadGroupPointers(Handle thread_group_handle, jweak thread_group_weak_ref);
 53   Handle thread_group_handle() const;
 54   jweak thread_group_weak_ref() const;
 55   oopDesc* const thread_group_oop() const;
 56   jweak transfer_weak_global_handle_ownership();
 57   void clear_weak_ref();
 58 };
 59 
 60 JfrThreadGroupPointers::JfrThreadGroupPointers(Handle thread_group_handle, jweak thread_group_weak_ref) :
 61   _thread_group_handle(thread_group_handle),
 62   _thread_group_weak_ref(thread_group_weak_ref) {}
 63 
 64 Handle JfrThreadGroupPointers::thread_group_handle() const {
 65   return _thread_group_handle;
 66 }
 67 
 68 jweak JfrThreadGroupPointers::thread_group_weak_ref() const {
 69   return _thread_group_weak_ref;
 70 }
 71 
 72 oopDesc* const JfrThreadGroupPointers::thread_group_oop() const {
 73   assert(_thread_group_weak_ref == NULL ||
 74          JNIHandles::resolve_non_null(_thread_group_weak_ref) == _thread_group_handle(), &quot;invariant&quot;);
 75   return _thread_group_handle();
 76 }
 77 
 78 jweak JfrThreadGroupPointers::transfer_weak_global_handle_ownership() {
 79   jweak temp = _thread_group_weak_ref;
 80   _thread_group_weak_ref = NULL;
 81   return temp;
 82 }
 83 
 84 void JfrThreadGroupPointers::clear_weak_ref() {
 85   if (NULL != _thread_group_weak_ref) {
 86     JNIHandles::destroy_weak_global(_thread_group_weak_ref);
 87   }
 88 }
 89 
 90 class JfrThreadGroupsHelper : public ResourceObj {
 91  private:
 92   static const int invalid_iterator_pos = -1;
 93   GrowableArray&lt;JfrThreadGroupPointers*&gt;* _thread_group_hierarchy;
 94   int _current_iterator_pos;
 95 
 96   int populate_thread_group_hierarchy(const JavaThread* jt, Thread* current);
 97   JfrThreadGroupPointers&amp; at(int index);
 98 
 99  public:
100   JfrThreadGroupsHelper(const JavaThread* jt, Thread* current);
101   ~JfrThreadGroupsHelper();
102   JfrThreadGroupPointers&amp; next();
103   bool is_valid() const;
104   bool has_next() const;
105 };
106 
107 JfrThreadGroupsHelper::JfrThreadGroupsHelper(const JavaThread* jt, Thread* current) {
108   _thread_group_hierarchy = new GrowableArray&lt;JfrThreadGroupPointers*&gt;(10, false, mtTracing);
109   _current_iterator_pos = populate_thread_group_hierarchy(jt, current) - 1;
110 }
111 
112 JfrThreadGroupsHelper::~JfrThreadGroupsHelper() {
113   assert(_current_iterator_pos == invalid_iterator_pos, &quot;invariant&quot;);
114   for (int i = 0; i &lt; _thread_group_hierarchy-&gt;length(); ++i) {
115     _thread_group_hierarchy-&gt;at(i)-&gt;clear_weak_ref();
116   }
117 }
118 
119 JfrThreadGroupPointers&amp; JfrThreadGroupsHelper::at(int index) {
120   assert(_thread_group_hierarchy != NULL, &quot;invariant&quot;);
121   assert(index &gt; invalid_iterator_pos &amp;&amp; index &lt; _thread_group_hierarchy-&gt;length(), &quot;invariant&quot;);
122   return *(_thread_group_hierarchy-&gt;at(index));
123 }
124 
125 bool JfrThreadGroupsHelper::has_next() const {
126   return _current_iterator_pos &gt; invalid_iterator_pos;
127 }
128 
129 bool JfrThreadGroupsHelper::is_valid() const {
130   return (_thread_group_hierarchy != NULL &amp;&amp; _thread_group_hierarchy-&gt;length() &gt; 0);
131 }
132 
133 JfrThreadGroupPointers&amp; JfrThreadGroupsHelper::next() {
134   assert(is_valid(), &quot;invariant&quot;);
135   return at(_current_iterator_pos--);
136 }
137 
138 /*
139  * If not at a safepoint, we create global weak references for
140  * all reachable threadgroups for this thread.
141  * If we are at a safepoint, the caller is the VMThread during
142  * JFR checkpointing. It can use naked oops, because nothing
143  * will move before the list of threadgroups is cleared and
144  * mutator threads restarted. The threadgroup list is cleared
145  * later by the VMThread as one of the final steps in JFR checkpointing
146  * (not here).
147  */
148 int JfrThreadGroupsHelper::populate_thread_group_hierarchy(const JavaThread* jt, Thread* current) {
149   assert(jt != NULL &amp;&amp; jt-&gt;is_Java_thread(), &quot;invariant&quot;);
150   assert(current != NULL, &quot;invariant&quot;);
151   assert(_thread_group_hierarchy != NULL, &quot;invariant&quot;);
152 
153   // immediate thread group
154   Handle thread_group_handle(current, java_lang_Thread::threadGroup(jt-&gt;threadObj()));
155   if (thread_group_handle == NULL) {
156     return 0;
157   }
158 
159   const bool use_weak_handles = !SafepointSynchronize::is_at_safepoint();
160   jweak thread_group_weak_ref = use_weak_handles ? JNIHandles::make_weak_global(thread_group_handle) : NULL;
161 
162   JfrThreadGroupPointers* thread_group_pointers = new JfrThreadGroupPointers(thread_group_handle, thread_group_weak_ref);
163   _thread_group_hierarchy-&gt;append(thread_group_pointers);
164   // immediate parent thread group
165   oop parent_thread_group_obj = java_lang_ThreadGroup::parent(thread_group_handle());
166   Handle parent_thread_group_handle(current, parent_thread_group_obj);
167 
168   // and check parents parents...
169   while (!(parent_thread_group_handle == NULL)) {
170     const jweak parent_group_weak_ref = use_weak_handles ? JNIHandles::make_weak_global(parent_thread_group_handle) : NULL;
171     thread_group_pointers = new JfrThreadGroupPointers(parent_thread_group_handle, parent_group_weak_ref);
172     _thread_group_hierarchy-&gt;append(thread_group_pointers);
173     parent_thread_group_obj = java_lang_ThreadGroup::parent(parent_thread_group_handle());
174     parent_thread_group_handle = Handle(current, parent_thread_group_obj);
175   }
176   return _thread_group_hierarchy-&gt;length();
177 }
178 
179 static traceid next_id() {
180   static traceid _current_threadgroup_id = 0;
181   return ++_current_threadgroup_id;
182 }
183 
184 class JfrThreadGroup::JfrThreadGroupEntry : public JfrCHeapObj {
185   friend class JfrThreadGroup;
186  private:
187   traceid _thread_group_id;
188   traceid _parent_group_id;
189   char* _thread_group_name; // utf8 format
190   // If an entry is created during a safepoint, the
191   // _thread_group_oop contains a direct oop to
192   // the java.lang.ThreadGroup object.
193   // If an entry is created on javathread exit time (not at safepoint),
194   // _thread_group_weak_ref contains a JNI weak global handle
195   // indirection to the java.lang.ThreadGroup object.
196   // Note: we cannot use a union here since CHECK_UNHANDLED_OOPS makes oop have
197   //       a ctor which isn&#39;t allowed in a union by the SunStudio compiler
198   oop _thread_group_oop;
199   jweak _thread_group_weak_ref;
200 
201   JfrThreadGroupEntry(const char* tgstr, JfrThreadGroupPointers&amp; ptrs);
202   ~JfrThreadGroupEntry();
203 
204   traceid thread_group_id() const { return _thread_group_id; }
205   void set_thread_group_id(traceid tgid) { _thread_group_id = tgid; }
206 
207   const char* const thread_group_name() const { return _thread_group_name; }
208   void set_thread_group_name(const char* tgname);
209 
210   traceid parent_group_id() const { return _parent_group_id; }
211   void set_parent_group_id(traceid pgid) { _parent_group_id = pgid; }
212 
213   void set_thread_group(JfrThreadGroupPointers&amp; ptrs);
214   bool is_equal(const JfrThreadGroupPointers&amp; ptrs) const;
215   const oop thread_group() const;
216 };
217 
218 JfrThreadGroup::JfrThreadGroupEntry::JfrThreadGroupEntry(const char* tgname, JfrThreadGroupPointers&amp; ptrs) :
219   _thread_group_id(0),
220   _parent_group_id(0),
221   _thread_group_name(NULL),
222   _thread_group_oop(NULL),
223   _thread_group_weak_ref(NULL) {
224   set_thread_group_name(tgname);
225   set_thread_group(ptrs);
226 }
227 
228 JfrThreadGroup::JfrThreadGroupEntry::~JfrThreadGroupEntry() {
229   if (_thread_group_name != NULL) {
230     JfrCHeapObj::free(_thread_group_name, strlen(_thread_group_name) + 1);
231   }
232   if (_thread_group_weak_ref != NULL) {
233     JNIHandles::destroy_weak_global(_thread_group_weak_ref);
234   }
235 }
236 
237 void JfrThreadGroup::JfrThreadGroupEntry::set_thread_group_name(const char* tgname) {
238   assert(_thread_group_name == NULL, &quot;invariant&quot;);
239   if (tgname != NULL) {
240     size_t len = strlen(tgname);
241     _thread_group_name = JfrCHeapObj::new_array&lt;char&gt;(len + 1);
242     strncpy(_thread_group_name, tgname, len + 1);
243   }
244 }
245 
246 const oop JfrThreadGroup::JfrThreadGroupEntry::thread_group() const {
247   return _thread_group_weak_ref != NULL ? JNIHandles::resolve(_thread_group_weak_ref) : _thread_group_oop;
248 }
249 
250 void JfrThreadGroup::JfrThreadGroupEntry::set_thread_group(JfrThreadGroupPointers&amp; ptrs) {
251   _thread_group_weak_ref = ptrs.transfer_weak_global_handle_ownership();
252   if (_thread_group_weak_ref == NULL) {
253     _thread_group_oop = ptrs.thread_group_oop();
254     assert(_thread_group_oop != NULL, &quot;invariant&quot;);
255   } else {
256     _thread_group_oop = NULL;
257   }
258 }
259 
260 JfrThreadGroup::JfrThreadGroup() : _list(NULL) {
261   _list = new (ResourceObj::C_HEAP, mtTracing) GrowableArray&lt;JfrThreadGroupEntry*&gt;(30, true);
262 }
263 
264 JfrThreadGroup::~JfrThreadGroup() {
265   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
266   if (_list != NULL) {
267     for (int i = 0; i &lt; _list-&gt;length(); i++) {
268       JfrThreadGroupEntry* e = _list-&gt;at(i);
269       delete e;
270     }
271     delete _list;
272   }
273 }
274 
275 JfrThreadGroup* JfrThreadGroup::instance() {
276   return _instance;
277 }
278 
279 void JfrThreadGroup::set_instance(JfrThreadGroup* new_instance) {
280   _instance = new_instance;
281 }
282 
283 traceid JfrThreadGroup::thread_group_id(const JavaThread* jt, Thread* current) {
284   ResourceMark rm(current);
285   HandleMark hm(current);
286   JfrThreadGroupsHelper helper(jt, current);
287   return helper.is_valid() ? thread_group_id_internal(helper) : 0;
288 }
289 
290 traceid JfrThreadGroup::thread_group_id(JavaThread* const jt) {
291   assert(!JfrStream_lock-&gt;owned_by_self(), &quot;holding stream lock but should not hold it here&quot;);
292   return thread_group_id(jt, jt);
293 }
294 
295 traceid JfrThreadGroup::thread_group_id_internal(JfrThreadGroupsHelper&amp; helper) {
296   ThreadGroupExclusiveAccess lock;
297   JfrThreadGroup* tg_instance = instance();
298   if (tg_instance == NULL) {
299     tg_instance = new JfrThreadGroup();
300     if (tg_instance == NULL) {
301       return 0;
302     }
303     set_instance(tg_instance);
304   }
305 
306   JfrThreadGroupEntry* tge = NULL;
307   int parent_thread_group_id = 0;
308   while (helper.has_next()) {
309     JfrThreadGroupPointers&amp; ptrs = helper.next();
310     tge = tg_instance-&gt;find_entry(ptrs);
311     if (NULL == tge) {
312       tge = tg_instance-&gt;new_entry(ptrs);
313       assert(tge != NULL, &quot;invariant&quot;);
314       tge-&gt;set_parent_group_id(parent_thread_group_id);
315     }
316     parent_thread_group_id = tge-&gt;thread_group_id();
317   }
318   // the last entry in the hierarchy is the immediate thread group
319   return tge-&gt;thread_group_id();
320 }
321 
322 bool JfrThreadGroup::JfrThreadGroupEntry::is_equal(const JfrThreadGroupPointers&amp; ptrs) const {
323   return ptrs.thread_group_oop() == thread_group();
324 }
325 
326 JfrThreadGroup::JfrThreadGroupEntry*
327 JfrThreadGroup::find_entry(const JfrThreadGroupPointers&amp; ptrs) const {
328   for (int index = 0; index &lt; _list-&gt;length(); ++index) {
329     JfrThreadGroupEntry* curtge = _list-&gt;at(index);
330     if (curtge-&gt;is_equal(ptrs)) {
331       return curtge;
332     }
333   }
334   return (JfrThreadGroupEntry*) NULL;
335 }
336 
337 // Assumes you already searched for the existence
338 // of a corresponding entry in find_entry().
339 JfrThreadGroup::JfrThreadGroupEntry*
340 JfrThreadGroup::new_entry(JfrThreadGroupPointers&amp; ptrs) {
341   JfrThreadGroupEntry* const tge = new JfrThreadGroupEntry(java_lang_ThreadGroup::name(ptrs.thread_group_oop()), ptrs);
342   add_entry(tge);
343   return tge;
344 }
345 
346 int JfrThreadGroup::add_entry(JfrThreadGroupEntry* tge) {
347   assert(tge != NULL, &quot;attempting to add a null entry!&quot;);
348   assert(0 == tge-&gt;thread_group_id(), &quot;id must be unassigned!&quot;);
349   tge-&gt;set_thread_group_id(next_id());
350   return _list-&gt;append(tge);
351 }
352 
353 void JfrThreadGroup::write_thread_group_entries(JfrCheckpointWriter&amp; writer) const {
354   assert(_list != NULL &amp;&amp; !_list-&gt;is_empty(), &quot;should not need be here!&quot;);
355   const int number_of_tg_entries = _list-&gt;length();
356   writer.write_count(number_of_tg_entries);
357   for (int index = 0; index &lt; number_of_tg_entries; ++index) {
358     const JfrThreadGroupEntry* const curtge = _list-&gt;at(index);
359     writer.write_key(curtge-&gt;thread_group_id());
360     writer.write(curtge-&gt;parent_group_id());
361     writer.write(curtge-&gt;thread_group_name());
362   }
363 }
364 
365 void JfrThreadGroup::write_selective_thread_group(JfrCheckpointWriter* writer, traceid thread_group_id) const {
366   assert(writer != NULL, &quot;invariant&quot;);
367   assert(_list != NULL &amp;&amp; !_list-&gt;is_empty(), &quot;should not need be here!&quot;);
368   const int number_of_tg_entries = _list-&gt;length();
369 
370   // save context
371   const JfrCheckpointContext ctx = writer-&gt;context();
372   writer-&gt;write_type(TYPE_THREADGROUP);
373   const jlong count_offset = writer-&gt;reserve(sizeof(u4)); // Don&#39;t know how many yet
374   int number_of_entries_written = 0;
375   for (int index = number_of_tg_entries - 1; index &gt;= 0; --index) {
376     const JfrThreadGroupEntry* const curtge = _list-&gt;at(index);
377     if (thread_group_id == curtge-&gt;thread_group_id()) {
378       writer-&gt;write_key(curtge-&gt;thread_group_id());
379       writer-&gt;write(curtge-&gt;parent_group_id());
380       writer-&gt;write(curtge-&gt;thread_group_name());
381       ++number_of_entries_written;
382       thread_group_id = curtge-&gt;parent_group_id();
383     }
384   }
385   if (number_of_entries_written == 0) {
386     // nothing to write, restore context
387     writer-&gt;set_context(ctx);
388     return;
389   }
390   assert(number_of_entries_written &gt; 0, &quot;invariant&quot;);
391   writer-&gt;write_count(number_of_entries_written, count_offset);
392 }
393 
394 // Write out JfrThreadGroup instance and then delete it
395 void JfrThreadGroup::serialize(JfrCheckpointWriter&amp; writer) {
396   ThreadGroupExclusiveAccess lock;
397   JfrThreadGroup* tg_instance = instance();
398   assert(tg_instance != NULL, &quot;invariant&quot;);
399   ResourceManager&lt;JfrThreadGroup&gt; tg_handle(tg_instance);
400   set_instance(NULL);
401   tg_handle-&gt;write_thread_group_entries(writer);
402 }
403 
404 // for writing a particular thread group
405 void JfrThreadGroup::serialize(JfrCheckpointWriter* writer, traceid thread_group_id) {
406   assert(writer != NULL, &quot;invariant&quot;);
407   ThreadGroupExclusiveAccess lock;
408   JfrThreadGroup* const tg_instance = instance();
409   assert(tg_instance != NULL, &quot;invariant&quot;);
410   tg_instance-&gt;write_selective_thread_group(writer, thread_group_id);
411 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/recorder/storage/jfrMemorySpace.hpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="jfrBuffer.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrMemorySpace.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/storage/jfrMemorySpace.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 #ifndef SHARE_JFR_RECORDER_STORAGE_JFRMEMORYSPACE_HPP
 25 #define SHARE_JFR_RECORDER_STORAGE_JFRMEMORYSPACE_HPP
 26 
 27 #include &quot;jfr/utilities/jfrAllocation.hpp&quot;
 28 #include &quot;jfr/utilities/jfrDoublyLinkedList.hpp&quot;
 29 #include &quot;jfr/utilities/jfrIterator.hpp&quot;
<span class="line-removed"> 30 #include &quot;jfr/utilities/jfrTypes.hpp&quot;</span>
<span class="line-removed"> 31 #include &quot;runtime/os.hpp&quot;</span>
<span class="line-removed"> 32 #include &quot;utilities/globalDefinitions.hpp&quot;</span>
<span class="line-removed"> 33 #include &quot;utilities/macros.hpp&quot;</span>
 34 
 35 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;
 36 class JfrMemorySpace : public JfrCHeapObj {
 37  public:
 38   typedef T Type;
 39   typedef RetrievalType&lt;JfrMemorySpace&lt;T, RetrievalType, Callback&gt; &gt; Retrieval;
 40   typedef JfrDoublyLinkedList&lt;Type&gt; List;
 41   typedef StopOnNullIterator&lt;List&gt; Iterator;
 42  private:
 43   List _free;
 44   List _full;
 45   size_t _min_elem_size;
 46   size_t _limit_size;
 47   size_t _cache_count;
 48   Callback* _callback;
 49 
 50   bool should_populate_cache() const { return _free.count() &lt; _cache_count; }
 51 
 52  public:
 53   JfrMemorySpace(size_t min_elem_size, size_t limit_size, size_t cache_count, Callback* callback);
</pre>
<hr />
<pre>
 86   Type* remove_full(Type* t) { return _full.remove(t); }
 87   Type* remove_free_tail() { _free.remove(_free.tail()); }
 88   Type* remove_full_tail() { return _full.remove(_full.tail()); }
 89   Type* clear_full(bool return_tail = false) { return _full.clear(return_tail); }
 90   Type* clear_free(bool return_tail = false) { return _free.clear(return_tail); }
 91   void release_full(Type* t);
 92   void release_free(Type* t);
 93 
 94   void register_full(Type* t, Thread* thread) { _callback-&gt;register_full(t, thread); }
 95   void lock() { _callback-&gt;lock(); }
 96   void unlock() { _callback-&gt;unlock(); }
 97   DEBUG_ONLY(bool is_locked() const { return _callback-&gt;is_locked(); })
 98 
 99   Type* allocate(size_t size);
100   void deallocate(Type* t);
101   Type* get(size_t size, Thread* thread) { return Retrieval::get(size, this, thread); }
102 
103   template &lt;typename IteratorCallback, typename IteratorType&gt;
104   void iterate(IteratorCallback&amp; callback, bool full = true, jfr_iter_direction direction = forward);
105 
<span class="line-modified">106   debug_only(bool in_full_list(const Type* t) const { return _full.in_list(t); })</span>
<span class="line-modified">107   debug_only(bool in_free_list(const Type* t) const { return _free.in_list(t); })</span>
<span class="line-removed">108 };</span>
<span class="line-removed">109 </span>
<span class="line-removed">110 // allocations are even multiples of the mspace min size</span>
<span class="line-removed">111 inline u8 align_allocation_size(u8 requested_size, size_t min_elem_size) {</span>
<span class="line-removed">112   assert((int)min_elem_size % os::vm_page_size() == 0, &quot;invariant&quot;);</span>
<span class="line-removed">113   u8 alloc_size_bytes = min_elem_size;</span>
<span class="line-removed">114   while (requested_size &gt; alloc_size_bytes) {</span>
<span class="line-removed">115     alloc_size_bytes &lt;&lt;= 1;</span>
<span class="line-removed">116   }</span>
<span class="line-removed">117   assert((int)alloc_size_bytes % os::vm_page_size() == 0, &quot;invariant&quot;);</span>
<span class="line-removed">118   return alloc_size_bytes;</span>
<span class="line-removed">119 }</span>
<span class="line-removed">120 </span>
<span class="line-removed">121 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;</span>
<span class="line-removed">122 T* JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::allocate(size_t size) {</span>
<span class="line-removed">123   const u8 aligned_size_bytes = align_allocation_size(size, _min_elem_size);</span>
<span class="line-removed">124   void* const allocation = JfrCHeapObj::new_array&lt;u1&gt;(aligned_size_bytes + sizeof(T));</span>
<span class="line-removed">125   if (allocation == NULL) {</span>
<span class="line-removed">126     return NULL;</span>
<span class="line-removed">127   }</span>
<span class="line-removed">128   T* const t = new (allocation) T;</span>
<span class="line-removed">129   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">130   if (!t-&gt;initialize(sizeof(T), aligned_size_bytes)) {</span>
<span class="line-removed">131     JfrCHeapObj::free(t, aligned_size_bytes + sizeof(T));</span>
<span class="line-removed">132     return NULL;</span>
<span class="line-removed">133   }</span>
<span class="line-removed">134   return t;</span>
<span class="line-removed">135 }</span>
<span class="line-removed">136 </span>
<span class="line-removed">137 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;</span>
<span class="line-removed">138 void JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::deallocate(T* t) {</span>
<span class="line-removed">139   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">140   assert(!_free.in_list(t), &quot;invariant&quot;);</span>
<span class="line-removed">141   assert(!_full.in_list(t), &quot;invariant&quot;);</span>
<span class="line-removed">142   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">143   JfrCHeapObj::free(t, t-&gt;total_size());</span>
<span class="line-removed">144 }</span>
<span class="line-removed">145 </span>
<span class="line-removed">146 template &lt;typename Mspace&gt;</span>
<span class="line-removed">147 class MspaceLock {</span>
<span class="line-removed">148  private:</span>
<span class="line-removed">149   Mspace* _mspace;</span>
<span class="line-removed">150  public:</span>
<span class="line-removed">151   MspaceLock(Mspace* mspace) : _mspace(mspace) { _mspace-&gt;lock(); }</span>
<span class="line-removed">152   ~MspaceLock() { _mspace-&gt;unlock(); }</span>
<span class="line-removed">153 };</span>
<span class="line-removed">154 </span>
<span class="line-removed">155 template &lt;typename Mspace&gt;</span>
<span class="line-removed">156 class ReleaseOp : public StackObj {</span>
<span class="line-removed">157  private:</span>
<span class="line-removed">158   Mspace* _mspace;</span>
<span class="line-removed">159   Thread* _thread;</span>
<span class="line-removed">160   bool _release_full;</span>
<span class="line-removed">161  public:</span>
<span class="line-removed">162   typedef typename Mspace::Type Type;</span>
<span class="line-removed">163   ReleaseOp(Mspace* mspace, Thread* thread, bool release_full = true) : _mspace(mspace), _thread(thread), _release_full(release_full) {}</span>
<span class="line-removed">164   bool process(Type* t);</span>
<span class="line-removed">165   size_t processed() const { return 0; }</span>
166 };
167 
168 #endif // SHARE_JFR_RECORDER_STORAGE_JFRMEMORYSPACE_HPP
</pre>
</td>
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 #ifndef SHARE_JFR_RECORDER_STORAGE_JFRMEMORYSPACE_HPP
 25 #define SHARE_JFR_RECORDER_STORAGE_JFRMEMORYSPACE_HPP
 26 
 27 #include &quot;jfr/utilities/jfrAllocation.hpp&quot;
 28 #include &quot;jfr/utilities/jfrDoublyLinkedList.hpp&quot;
 29 #include &quot;jfr/utilities/jfrIterator.hpp&quot;




 30 
 31 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;
 32 class JfrMemorySpace : public JfrCHeapObj {
 33  public:
 34   typedef T Type;
 35   typedef RetrievalType&lt;JfrMemorySpace&lt;T, RetrievalType, Callback&gt; &gt; Retrieval;
 36   typedef JfrDoublyLinkedList&lt;Type&gt; List;
 37   typedef StopOnNullIterator&lt;List&gt; Iterator;
 38  private:
 39   List _free;
 40   List _full;
 41   size_t _min_elem_size;
 42   size_t _limit_size;
 43   size_t _cache_count;
 44   Callback* _callback;
 45 
 46   bool should_populate_cache() const { return _free.count() &lt; _cache_count; }
 47 
 48  public:
 49   JfrMemorySpace(size_t min_elem_size, size_t limit_size, size_t cache_count, Callback* callback);
</pre>
<hr />
<pre>
 82   Type* remove_full(Type* t) { return _full.remove(t); }
 83   Type* remove_free_tail() { _free.remove(_free.tail()); }
 84   Type* remove_full_tail() { return _full.remove(_full.tail()); }
 85   Type* clear_full(bool return_tail = false) { return _full.clear(return_tail); }
 86   Type* clear_free(bool return_tail = false) { return _free.clear(return_tail); }
 87   void release_full(Type* t);
 88   void release_free(Type* t);
 89 
 90   void register_full(Type* t, Thread* thread) { _callback-&gt;register_full(t, thread); }
 91   void lock() { _callback-&gt;lock(); }
 92   void unlock() { _callback-&gt;unlock(); }
 93   DEBUG_ONLY(bool is_locked() const { return _callback-&gt;is_locked(); })
 94 
 95   Type* allocate(size_t size);
 96   void deallocate(Type* t);
 97   Type* get(size_t size, Thread* thread) { return Retrieval::get(size, this, thread); }
 98 
 99   template &lt;typename IteratorCallback, typename IteratorType&gt;
100   void iterate(IteratorCallback&amp; callback, bool full = true, jfr_iter_direction direction = forward);
101 
<span class="line-modified">102   bool in_full_list(const Type* t) const { return _full.in_list(t); }</span>
<span class="line-modified">103   bool in_free_list(const Type* t) const { return _free.in_list(t); }</span>


























































104 };
105 
106 #endif // SHARE_JFR_RECORDER_STORAGE_JFRMEMORYSPACE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="jfrBuffer.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrMemorySpace.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
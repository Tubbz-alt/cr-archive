<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/jfr/recorder/checkpoint/types/jfrType.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/javaClasses.inline.hpp&quot;
 27 #include &quot;code/codeBlob.hpp&quot;
 28 #include &quot;code/codeCache.hpp&quot;
 29 #include &quot;gc/shared/gcCause.hpp&quot;
 30 #include &quot;gc/shared/gcName.hpp&quot;
 31 #include &quot;gc/shared/gcTrace.hpp&quot;
 32 #include &quot;gc/shared/gcWhen.hpp&quot;
 33 #include &quot;jfr/leakprofiler/checkpoint/objectSampleCheckpoint.hpp&quot;
 34 #include &quot;jfr/leakprofiler/leakProfiler.hpp&quot;
 35 #include &quot;jfr/recorder/checkpoint/jfrCheckpointManager.hpp&quot;
 36 #include &quot;jfr/recorder/checkpoint/types/jfrType.hpp&quot;
 37 #include &quot;jfr/recorder/jfrRecorder.hpp&quot;
 38 #include &quot;jfr/recorder/checkpoint/types/jfrThreadGroup.hpp&quot;
 39 #include &quot;jfr/recorder/checkpoint/types/jfrThreadState.hpp&quot;
 40 #include &quot;jfr/recorder/checkpoint/types/jfrTypeSet.hpp&quot;
 41 #include &quot;jfr/support/jfrThreadLocal.hpp&quot;
 42 #include &quot;jfr/writers/jfrJavaEventWriter.hpp&quot;
 43 #include &quot;memory/metaspaceGCThresholdUpdater.hpp&quot;
 44 #include &quot;memory/referenceType.hpp&quot;
 45 #include &quot;memory/universe.hpp&quot;
 46 #include &quot;runtime/flags/jvmFlag.hpp&quot;
 47 #include &quot;runtime/mutexLocker.hpp&quot;
 48 #include &quot;runtime/osThread.hpp&quot;
 49 #include &quot;runtime/safepoint.hpp&quot;
 50 #include &quot;runtime/synchronizer.hpp&quot;
 51 #include &quot;runtime/thread.inline.hpp&quot;
 52 #include &quot;runtime/vmOperations.hpp&quot;
 53 
 54 #ifdef COMPILER2
 55 #include &quot;opto/compile.hpp&quot;
 56 #include &quot;opto/node.hpp&quot;
 57 #endif
 58 #if INCLUDE_G1GC
 59 #include &quot;gc/g1/g1HeapRegionTraceType.hpp&quot;
 60 #include &quot;gc/g1/g1YCTypes.hpp&quot;
 61 #endif
 62 
 63 // Requires a ResourceMark for get_thread_name/as_utf8
 64 class JfrCheckpointThreadClosure : public ThreadClosure {
 65  private:
 66   JfrCheckpointWriter&amp; _writer;
 67   JfrCheckpointContext _ctx;
 68   const int64_t _count_position;
 69   Thread* const _curthread;
 70   u4 _count;
 71 
 72  public:
 73   JfrCheckpointThreadClosure(JfrCheckpointWriter&amp; writer) : _writer(writer),
 74                                                             _ctx(writer.context()),
 75                                                             _count_position(writer.reserve(sizeof(u4))),
 76                                                             _curthread(Thread::current()),
 77                                                             _count(0) {
 78   }
 79 
 80   ~JfrCheckpointThreadClosure() {
 81     if (_count == 0) {
 82       // restore
 83       _writer.set_context(_ctx);
 84       return;
 85     }
 86     _writer.write_count(_count, _count_position);
 87   }
 88 
 89   void do_thread(Thread* t);
 90 };
 91 
 92 // Requires a ResourceMark for get_thread_name/as_utf8
 93 void JfrCheckpointThreadClosure::do_thread(Thread* t) {
 94   assert(t != NULL, &quot;invariant&quot;);
 95   assert_locked_or_safepoint(Threads_lock);
 96   const JfrThreadLocal* const tl = t-&gt;jfr_thread_local();
 97   assert(tl != NULL, &quot;invariant&quot;);
 98   if (tl-&gt;is_dead()) {
 99     return;
100   }
101   ++_count;
102   _writer.write_key(tl-&gt;thread_id());
103   _writer.write(t-&gt;name());
104   const OSThread* const os_thread = t-&gt;osthread();
105   _writer.write&lt;traceid&gt;(os_thread != NULL ? os_thread-&gt;thread_id() : 0);
106   if (t-&gt;is_Java_thread()) {
107     JavaThread* const jt = (JavaThread*)t;
108     _writer.write(jt-&gt;name());
109     _writer.write(java_lang_Thread::thread_id(jt-&gt;threadObj()));
110     _writer.write(JfrThreadGroup::thread_group_id(jt, _curthread));
111     // since we are iterating threads during a safepoint, also issue notification
112     JfrJavaEventWriter::notify(jt);
113     return;
114   }
115   _writer.write((const char*)NULL); // java name
116   _writer.write((traceid)0); // java thread id
117   _writer.write((traceid)0); // java thread group
118 }
119 
120 void JfrThreadConstantSet::serialize(JfrCheckpointWriter&amp; writer) {
121   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
122   JfrCheckpointThreadClosure tc(writer);
123   Threads::threads_do(&amp;tc);
124 }
125 
126 void JfrThreadGroupConstant::serialize(JfrCheckpointWriter&amp; writer) {
127   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
128   JfrThreadGroup::serialize(writer);
129 }
130 
131 static const char* flag_value_origin_to_string(JVMFlag::Flags origin) {
132   switch (origin) {
133     case JVMFlag::DEFAULT: return &quot;Default&quot;;
134     case JVMFlag::COMMAND_LINE: return &quot;Command line&quot;;
135     case JVMFlag::ENVIRON_VAR: return &quot;Environment variable&quot;;
136     case JVMFlag::CONFIG_FILE: return &quot;Config file&quot;;
137     case JVMFlag::MANAGEMENT: return &quot;Management&quot;;
138     case JVMFlag::ERGONOMIC: return &quot;Ergonomic&quot;;
139     case JVMFlag::ATTACH_ON_DEMAND: return &quot;Attach on demand&quot;;
140     case JVMFlag::INTERNAL: return &quot;Internal&quot;;
141     default: ShouldNotReachHere(); return &quot;&quot;;
142   }
143 }
144 
145 void FlagValueOriginConstant::serialize(JfrCheckpointWriter&amp; writer) {
146   static const u4 nof_entries = JVMFlag::LAST_VALUE_ORIGIN + 1;
147   writer.write_count(nof_entries);
148   for (u4 i = 0; i &lt; nof_entries; ++i) {
149     writer.write_key(i);
150     writer.write(flag_value_origin_to_string((JVMFlag::Flags)i));
151   }
152 }
153 
154 void MonitorInflateCauseConstant::serialize(JfrCheckpointWriter&amp; writer) {
155   static const u4 nof_entries = ObjectSynchronizer::inflate_cause_nof;
156   writer.write_count(nof_entries);
157   for (u4 i = 0; i &lt; nof_entries; ++i) {
158     writer.write_key(i);
159     writer.write(ObjectSynchronizer::inflate_cause_name((ObjectSynchronizer::InflateCause)i));
160   }
161 }
162 
163 void GCCauseConstant::serialize(JfrCheckpointWriter&amp; writer) {
164   static const u4 nof_entries = GCCause::_last_gc_cause;
165   writer.write_count(nof_entries);
166   for (u4 i = 0; i &lt; nof_entries; ++i) {
167     writer.write_key(i);
168     writer.write(GCCause::to_string((GCCause::Cause)i));
169   }
170 }
171 
172 void GCNameConstant::serialize(JfrCheckpointWriter&amp; writer) {
173   static const u4 nof_entries = GCNameEndSentinel;
174   writer.write_count(nof_entries);
175   for (u4 i = 0; i &lt; nof_entries; ++i) {
176     writer.write_key(i);
177     writer.write(GCNameHelper::to_string((GCName)i));
178   }
179 }
180 
181 void GCWhenConstant::serialize(JfrCheckpointWriter&amp; writer) {
182   static const u4 nof_entries = GCWhen::GCWhenEndSentinel;
183   writer.write_count(nof_entries);
184   for (u4 i = 0; i &lt; nof_entries; ++i) {
185     writer.write_key(i);
186     writer.write(GCWhen::to_string((GCWhen::Type)i));
187   }
188 }
189 
190 void G1HeapRegionTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
191   static const u4 nof_entries = G1HeapRegionTraceType::G1HeapRegionTypeEndSentinel;
192   writer.write_count(nof_entries);
193   for (u4 i = 0; i &lt; nof_entries; ++i) {
194     writer.write_key(i);
195     writer.write(G1HeapRegionTraceType::to_string((G1HeapRegionTraceType::Type)i));
196   }
197 }
198 
199 void GCThresholdUpdaterConstant::serialize(JfrCheckpointWriter&amp; writer) {
200   static const u4 nof_entries = MetaspaceGCThresholdUpdater::Last;
201   writer.write_count(nof_entries);
202   for (u4 i = 0; i &lt; nof_entries; ++i) {
203     writer.write_key(i);
204     writer.write(MetaspaceGCThresholdUpdater::to_string((MetaspaceGCThresholdUpdater::Type)i));
205   }
206 }
207 
208 void MetadataTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
209   static const u4 nof_entries = Metaspace::MetadataTypeCount;
210   writer.write_count(nof_entries);
211   for (u4 i = 0; i &lt; nof_entries; ++i) {
212     writer.write_key(i);
213     writer.write(Metaspace::metadata_type_name((Metaspace::MetadataType)i));
214   }
215 }
216 
217 void MetaspaceObjectTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
218   static const u4 nof_entries = MetaspaceObj::_number_of_types;
219   writer.write_count(nof_entries);
220   for (u4 i = 0; i &lt; nof_entries; ++i) {
221     writer.write_key(i);
222     writer.write(MetaspaceObj::type_name((MetaspaceObj::Type)i));
223   }
224 }
225 
226 void G1YCTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
227 #if INCLUDE_G1GC
228   static const u4 nof_entries = G1YCTypeEndSentinel;
229   writer.write_count(nof_entries);
230   for (u4 i = 0; i &lt; nof_entries; ++i) {
231     writer.write_key(i);
232     writer.write(G1YCTypeHelper::to_string((G1YCType)i));
233   }
234 #endif
235 }
236 
237 static const char* reference_type_to_string(ReferenceType rt) {
238   switch (rt) {
239     case REF_NONE: return &quot;None reference&quot;;
240     case REF_OTHER: return &quot;Other reference&quot;;
241     case REF_SOFT: return &quot;Soft reference&quot;;
242     case REF_WEAK: return &quot;Weak reference&quot;;
243     case REF_FINAL: return &quot;Final reference&quot;;
244     case REF_PHANTOM: return &quot;Phantom reference&quot;;
245     default:
246       ShouldNotReachHere();
247     return NULL;
248   }
249 }
250 
251 void ReferenceTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
252   static const u4 nof_entries = REF_PHANTOM + 1;
253   writer.write_count(nof_entries);
254   for (u4 i = 0; i &lt; nof_entries; ++i) {
255     writer.write_key(i);
256     writer.write(reference_type_to_string((ReferenceType)i));
257   }
258 }
259 
260 void NarrowOopModeConstant::serialize(JfrCheckpointWriter&amp; writer) {
261   static const u4 nof_entries = Universe::HeapBasedNarrowOop + 1;
262   writer.write_count(nof_entries);
263   for (u4 i = 0; i &lt; nof_entries; ++i) {
264     writer.write_key(i);
265     writer.write(Universe::narrow_oop_mode_to_string((Universe::NARROW_OOP_MODE)i));
266   }
267 }
268 
269 void CompilerPhaseTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
270 #ifdef COMPILER2
271   static const u4 nof_entries = PHASE_NUM_TYPES;
272   writer.write_count(nof_entries);
273   for (u4 i = 0; i &lt; nof_entries; ++i) {
274     writer.write_key(i);
275     writer.write(CompilerPhaseTypeHelper::to_string((CompilerPhaseType)i));
276   }
277 #endif
278 }
279 
280 void CodeBlobTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
281   static const u4 nof_entries = CodeBlobType::NumTypes;
282   writer.write_count(nof_entries);
283   for (u4 i = 0; i &lt; nof_entries; ++i) {
284     writer.write_key(i);
285     writer.write(CodeCache::get_code_heap_name(i));
286   }
287 };
288 
289 void VMOperationTypeConstant::serialize(JfrCheckpointWriter&amp; writer) {
290   static const u4 nof_entries = VM_Operation::VMOp_Terminating;
291   writer.write_count(nof_entries);
292   for (u4 i = 0; i &lt; nof_entries; ++i) {
293     writer.write_key(i);
294     writer.write(VM_Operation::name(VM_Operation::VMOp_Type(i)));
295   }
296 }
297 
298 class TypeSetSerialization {
299  private:
300   bool _class_unload;
301  public:
302   explicit TypeSetSerialization(bool class_unload) : _class_unload(class_unload) {}
303   void write(JfrCheckpointWriter&amp; writer, JfrCheckpointWriter* leakp_writer) {
304     JfrTypeSet::serialize(&amp;writer, leakp_writer, _class_unload);
305   }
306 };
307 
308 void ClassUnloadTypeSet::serialize(JfrCheckpointWriter&amp; writer) {
309   TypeSetSerialization type_set(true);
310   if (LeakProfiler::is_running()) {
311     JfrCheckpointWriter leakp_writer(false, true, Thread::current());
312     type_set.write(writer, &amp;leakp_writer);
313     ObjectSampleCheckpoint::install(leakp_writer, true, true);
314     return;
315   }
316   type_set.write(writer, NULL);
317 };
318 
319 void TypeSet::serialize(JfrCheckpointWriter&amp; writer) {
320   TypeSetSerialization type_set(false);
321   if (LeakProfiler::is_suspended()) {
322     JfrCheckpointWriter leakp_writer(false, true, Thread::current());
323     type_set.write(writer, &amp;leakp_writer);
324     ObjectSampleCheckpoint::install(leakp_writer, false, true);
325     return;
326   }
327   type_set.write(writer, NULL);
328 };
329 
330 void ThreadStateConstant::serialize(JfrCheckpointWriter&amp; writer) {
331   JfrThreadState::serialize(writer);
332 }
333 
334 void JfrThreadConstant::serialize(JfrCheckpointWriter&amp; writer) {
335   assert(_thread != NULL, &quot;invariant&quot;);
336   assert(_thread == Thread::current(), &quot;invariant&quot;);
337   assert(_thread-&gt;is_Java_thread(), &quot;invariant&quot;);
338   assert(!_thread-&gt;jfr_thread_local()-&gt;has_thread_checkpoint(), &quot;invariant&quot;);
339   ResourceMark rm(_thread);
340   const oop threadObj = _thread-&gt;threadObj();
341   assert(threadObj != NULL, &quot;invariant&quot;);
342   const u8 java_lang_thread_id = java_lang_Thread::thread_id(threadObj);
343   const char* const thread_name = _thread-&gt;name();
344   const traceid thread_group_id = JfrThreadGroup::thread_group_id(_thread);
345   writer.write_count(1);
346   writer.write_key(_thread-&gt;jfr_thread_local()-&gt;thread_id());
347   writer.write(thread_name);
348   writer.write((traceid)_thread-&gt;osthread()-&gt;thread_id());
349   writer.write(thread_name);
350   writer.write(java_lang_thread_id);
351   writer.write(thread_group_id);
352   JfrThreadGroup::serialize(&amp;writer, thread_group_id);
353 }
    </pre>
  </body>
</html>
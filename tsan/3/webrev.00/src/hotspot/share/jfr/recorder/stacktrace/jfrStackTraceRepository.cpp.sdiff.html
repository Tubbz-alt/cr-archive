<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/recorder/stacktrace/jfrStackTraceRepository.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../service/jfrRecorderThreadLoop.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrStackTraceRepository.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/stacktrace/jfrStackTraceRepository.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/metadata/jfrSerializer.hpp&quot;
<span class="line-modified"> 27 #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceId.inline.hpp&quot;</span>
 28 #include &quot;jfr/recorder/repository/jfrChunkWriter.hpp&quot;
<span class="line-removed"> 29 #include &quot;jfr/recorder/service/jfrOptionSet.hpp&quot;</span>
 30 #include &quot;jfr/recorder/stacktrace/jfrStackTraceRepository.hpp&quot;
<span class="line-modified"> 31 #include &quot;jfr/utilities/jfrTypes.hpp&quot;</span>
<span class="line-removed"> 32 #include &quot;memory/allocation.inline.hpp&quot;</span>
 33 #include &quot;runtime/mutexLocker.hpp&quot;
<span class="line-removed"> 34 #include &quot;runtime/os.inline.hpp&quot;</span>
<span class="line-removed"> 35 #include &quot;runtime/safepoint.hpp&quot;</span>
<span class="line-removed"> 36 #include &quot;runtime/task.hpp&quot;</span>
<span class="line-removed"> 37 #include &quot;runtime/vframe.inline.hpp&quot;</span>
 38 
<span class="line-modified"> 39 class vframeStreamSamples : public vframeStreamCommon {</span>
<span class="line-removed"> 40  public:</span>
<span class="line-removed"> 41   // constructor that starts with sender of frame fr (top_frame)</span>
<span class="line-removed"> 42   vframeStreamSamples(JavaThread *jt, frame fr, bool stop_at_java_call_stub);</span>
<span class="line-removed"> 43   void samples_next();</span>
<span class="line-removed"> 44   void stop() {}</span>
<span class="line-removed"> 45 };</span>
<span class="line-removed"> 46 </span>
<span class="line-removed"> 47 vframeStreamSamples::vframeStreamSamples(JavaThread *jt, frame fr, bool stop_at_java_call_stub) : vframeStreamCommon(jt) {</span>
<span class="line-removed"> 48   _stop_at_java_call_stub = stop_at_java_call_stub;</span>
<span class="line-removed"> 49   _frame = fr;</span>
<span class="line-removed"> 50 </span>
<span class="line-removed"> 51   // We must always have a valid frame to start filling</span>
<span class="line-removed"> 52   bool filled_in = fill_from_frame();</span>
<span class="line-removed"> 53   assert(filled_in, &quot;invariant&quot;);</span>
<span class="line-removed"> 54 }</span>
<span class="line-removed"> 55 </span>
<span class="line-removed"> 56 // Solaris SPARC Compiler1 needs an additional check on the grandparent</span>
<span class="line-removed"> 57 // of the top_frame when the parent of the top_frame is interpreted and</span>
<span class="line-removed"> 58 // the grandparent is compiled. However, in this method we do not know</span>
<span class="line-removed"> 59 // the relationship of the current _frame relative to the top_frame so</span>
<span class="line-removed"> 60 // we implement a more broad sanity check. When the previous callee is</span>
<span class="line-removed"> 61 // interpreted and the current sender is compiled, we verify that the</span>
<span class="line-removed"> 62 // current sender is also walkable. If it is not walkable, then we mark</span>
<span class="line-removed"> 63 // the current vframeStream as at the end.</span>
<span class="line-removed"> 64 void vframeStreamSamples::samples_next() {</span>
<span class="line-removed"> 65   // handle frames with inlining</span>
<span class="line-removed"> 66   if (_mode == compiled_mode &amp;&amp;</span>
<span class="line-removed"> 67       vframeStreamCommon::fill_in_compiled_inlined_sender()) {</span>
<span class="line-removed"> 68     return;</span>
<span class="line-removed"> 69   }</span>
 70 
<span class="line-modified"> 71   // handle general case</span>
<span class="line-modified"> 72   int loop_count = 0;</span>
<span class="line-removed"> 73   int loop_max = MaxJavaStackTraceDepth * 2;</span>
<span class="line-removed"> 74   do {</span>
<span class="line-removed"> 75     loop_count++;</span>
<span class="line-removed"> 76     // By the time we get here we should never see unsafe but better safe then segv&#39;d</span>
<span class="line-removed"> 77     if (loop_count &gt; loop_max || !_frame.safe_for_sender(_thread)) {</span>
<span class="line-removed"> 78       _mode = at_end_mode;</span>
<span class="line-removed"> 79       return;</span>
<span class="line-removed"> 80     }</span>
<span class="line-removed"> 81     _frame = _frame.sender(&amp;_reg_map);</span>
<span class="line-removed"> 82   } while (!fill_from_frame());</span>
 83 }
 84 
<span class="line-removed"> 85 static JfrStackTraceRepository* _instance = NULL;</span>
<span class="line-removed"> 86 </span>
 87 JfrStackTraceRepository&amp; JfrStackTraceRepository::instance() {
 88   return *_instance;
 89 }
 90 
 91 JfrStackTraceRepository* JfrStackTraceRepository::create() {
 92   assert(_instance == NULL, &quot;invariant&quot;);
 93   _instance = new JfrStackTraceRepository();
 94   return _instance;
 95 }
 96 
<span class="line-removed"> 97 void JfrStackTraceRepository::destroy() {</span>
<span class="line-removed"> 98   assert(_instance != NULL, &quot;invarinat&quot;);</span>
<span class="line-removed"> 99   delete _instance;</span>
<span class="line-removed">100   _instance = NULL;</span>
<span class="line-removed">101 }</span>
<span class="line-removed">102 </span>
<span class="line-removed">103 JfrStackTraceRepository::JfrStackTraceRepository() : _next_id(0), _entries(0) {</span>
<span class="line-removed">104   memset(_table, 0, sizeof(_table));</span>
<span class="line-removed">105 }</span>
106 class JfrFrameType : public JfrSerializer {
107  public:
108   void serialize(JfrCheckpointWriter&amp; writer) {
109     writer.write_count(JfrStackFrame::NUM_FRAME_TYPES);
110     writer.write_key(JfrStackFrame::FRAME_INTERPRETER);
111     writer.write(&quot;Interpreted&quot;);
112     writer.write_key(JfrStackFrame::FRAME_JIT);
113     writer.write(&quot;JIT compiled&quot;);
114     writer.write_key(JfrStackFrame::FRAME_INLINE);
115     writer.write(&quot;Inlined&quot;);
116     writer.write_key(JfrStackFrame::FRAME_NATIVE);
117     writer.write(&quot;Native&quot;);
118   }
119 };
120 
121 bool JfrStackTraceRepository::initialize() {
<span class="line-modified">122   return JfrSerializer::register_serializer(TYPE_FRAMETYPE, false, true, new JfrFrameType());</span>









































123 }
124 
125 size_t JfrStackTraceRepository::clear() {
<span class="line-modified">126   MutexLockerEx lock(JfrStacktrace_lock, Mutex::_no_safepoint_check_flag);</span>
127   if (_entries == 0) {
128     return 0;
129   }
130   for (u4 i = 0; i &lt; TABLE_SIZE; ++i) {
<span class="line-modified">131     JfrStackTraceRepository::StackTrace* stacktrace = _table[i];</span>
132     while (stacktrace != NULL) {
<span class="line-modified">133       JfrStackTraceRepository::StackTrace* next = stacktrace-&gt;next();</span>
134       delete stacktrace;
135       stacktrace = next;
136     }
137   }
138   memset(_table, 0, sizeof(_table));
139   const size_t processed = _entries;
140   _entries = 0;
141   return processed;
142 }
143 
<span class="line-removed">144 traceid JfrStackTraceRepository::add_trace(const JfrStackTrace&amp; stacktrace) {</span>
<span class="line-removed">145   MutexLockerEx lock(JfrStacktrace_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed">146   const size_t index = stacktrace._hash % TABLE_SIZE;</span>
<span class="line-removed">147   const StackTrace* table_entry = _table[index];</span>
<span class="line-removed">148 </span>
<span class="line-removed">149   while (table_entry != NULL) {</span>
<span class="line-removed">150     if (table_entry-&gt;equals(stacktrace)) {</span>
<span class="line-removed">151       return table_entry-&gt;id();</span>
<span class="line-removed">152     }</span>
<span class="line-removed">153     table_entry = table_entry-&gt;next();</span>
<span class="line-removed">154   }</span>
<span class="line-removed">155 </span>
<span class="line-removed">156   if (!stacktrace.have_lineno()) {</span>
<span class="line-removed">157     return 0;</span>
<span class="line-removed">158   }</span>
<span class="line-removed">159 </span>
<span class="line-removed">160   traceid id = ++_next_id;</span>
<span class="line-removed">161   _table[index] = new StackTrace(id, stacktrace, _table[index]);</span>
<span class="line-removed">162   ++_entries;</span>
<span class="line-removed">163   return id;</span>
<span class="line-removed">164 }</span>
<span class="line-removed">165 </span>
<span class="line-removed">166 traceid JfrStackTraceRepository::add(const JfrStackTrace&amp; stacktrace) {</span>
<span class="line-removed">167   return instance().add_trace(stacktrace);</span>
<span class="line-removed">168 }</span>
<span class="line-removed">169 </span>
170 traceid JfrStackTraceRepository::record(Thread* thread, int skip /* 0 */) {
171   assert(thread == Thread::current(), &quot;invariant&quot;);
172   JfrThreadLocal* const tl = thread-&gt;jfr_thread_local();
173   assert(tl != NULL, &quot;invariant&quot;);
174   if (tl-&gt;has_cached_stack_trace()) {
175     return tl-&gt;cached_stack_trace_id();
176   }
<span class="line-modified">177   if (!thread-&gt;is_Java_thread() || thread-&gt;is_hidden_from_external_view()) {</span>
<span class="line-removed">178     return 0;</span>
<span class="line-removed">179   }</span>
<span class="line-removed">180   JfrStackFrame* frames = tl-&gt;stackframes();</span>
<span class="line-removed">181   if (frames == NULL) {</span>
<span class="line-removed">182     // pending oom</span>
<span class="line-removed">183     return 0;</span>
<span class="line-removed">184   }</span>
<span class="line-removed">185   assert(frames != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">186   assert(tl-&gt;stackframes() == frames, &quot;invariant&quot;);</span>
<span class="line-removed">187   return instance().record_for((JavaThread*)thread, skip,frames, tl-&gt;stackdepth());</span>
<span class="line-removed">188 }</span>
<span class="line-removed">189 </span>
<span class="line-removed">190 traceid JfrStackTraceRepository::record(Thread* thread, int skip, unsigned int* hash) {</span>
<span class="line-removed">191   assert(thread == Thread::current(), &quot;invariant&quot;);</span>
<span class="line-removed">192   JfrThreadLocal* const tl = thread-&gt;jfr_thread_local();</span>
<span class="line-removed">193   assert(tl != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">194 </span>
<span class="line-removed">195   if (tl-&gt;has_cached_stack_trace()) {</span>
<span class="line-removed">196     *hash = tl-&gt;cached_stack_trace_hash();</span>
<span class="line-removed">197     return tl-&gt;cached_stack_trace_id();</span>
<span class="line-removed">198   }</span>
<span class="line-removed">199   if (!thread-&gt;is_Java_thread() || thread-&gt;is_hidden_from_external_view()) {</span>
200     return 0;
201   }
202   JfrStackFrame* frames = tl-&gt;stackframes();
203   if (frames == NULL) {
204     // pending oom
205     return 0;
206   }
207   assert(frames != NULL, &quot;invariant&quot;);
208   assert(tl-&gt;stackframes() == frames, &quot;invariant&quot;);
<span class="line-modified">209   return instance().record_for((JavaThread*)thread, skip, frames, tl-&gt;stackdepth(), hash);</span>
210 }
211 
212 traceid JfrStackTraceRepository::record_for(JavaThread* thread, int skip, JfrStackFrame *frames, u4 max_frames) {
213   JfrStackTrace stacktrace(frames, max_frames);
<span class="line-modified">214   if (!stacktrace.record_safe(thread, skip)) {</span>
<span class="line-removed">215     return 0;</span>
<span class="line-removed">216   }</span>
<span class="line-removed">217   traceid tid = add(stacktrace);</span>
<span class="line-removed">218   if (tid == 0) {</span>
<span class="line-removed">219     stacktrace.resolve_linenos();</span>
<span class="line-removed">220     tid = add(stacktrace);</span>
<span class="line-removed">221   }</span>
<span class="line-removed">222   return tid;</span>
223 }
224 
<span class="line-modified">225 traceid JfrStackTraceRepository::record_for(JavaThread* thread, int skip, JfrStackFrame *frames, u4 max_frames, unsigned int* hash) {</span>
<span class="line-modified">226   assert(hash != NULL &amp;&amp; *hash == 0, &quot;invariant&quot;);</span>
<span class="line-removed">227   JfrStackTrace stacktrace(frames, max_frames);</span>
<span class="line-removed">228   if (!stacktrace.record_safe(thread, skip, true)) {</span>
<span class="line-removed">229     return 0;</span>
<span class="line-removed">230   }</span>
<span class="line-removed">231   traceid tid = add(stacktrace);</span>
232   if (tid == 0) {
233     stacktrace.resolve_linenos();
<span class="line-modified">234     tid = add(stacktrace);</span>
235   }
<span class="line-modified">236   *hash = stacktrace._hash;</span>
237   return tid;
238 }
239 
<span class="line-modified">240 size_t JfrStackTraceRepository::write_impl(JfrChunkWriter&amp; sw, bool clear) {</span>
<span class="line-modified">241   MutexLockerEx lock(JfrStacktrace_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">242   assert(_entries &gt; 0, &quot;invariant&quot;);</span>
<span class="line-modified">243   int count = 0;</span>
<span class="line-modified">244   for (u4 i = 0; i &lt; TABLE_SIZE; ++i) {</span>
<span class="line-modified">245     JfrStackTraceRepository::StackTrace* stacktrace = _table[i];</span>
<span class="line-modified">246     while (stacktrace != NULL) {</span>
<span class="line-modified">247       JfrStackTraceRepository::StackTrace* next = stacktrace-&gt;next();</span>
<span class="line-modified">248       if (stacktrace-&gt;should_write()) {</span>
<span class="line-modified">249         stacktrace-&gt;write(sw);</span>
<span class="line-removed">250         ++count;</span>
<span class="line-removed">251       }</span>
<span class="line-removed">252       if (clear) {</span>
<span class="line-removed">253         delete stacktrace;</span>
<span class="line-removed">254       }</span>
<span class="line-removed">255       stacktrace = next;</span>
<span class="line-removed">256     }</span>
<span class="line-removed">257   }</span>
<span class="line-removed">258   if (clear) {</span>
<span class="line-removed">259     memset(_table, 0, sizeof(_table));</span>
<span class="line-removed">260     _entries = 0;</span>
<span class="line-removed">261   }</span>
<span class="line-removed">262   return count;</span>
<span class="line-removed">263 }</span>
<span class="line-removed">264 </span>
<span class="line-removed">265 size_t JfrStackTraceRepository::write(JfrChunkWriter&amp; sw, bool clear) {</span>
<span class="line-removed">266   return _entries &gt; 0 ? write_impl(sw, clear) : 0;</span>
<span class="line-removed">267 }</span>
<span class="line-removed">268 </span>
<span class="line-removed">269 traceid JfrStackTraceRepository::write(JfrCheckpointWriter&amp; writer, traceid id, unsigned int hash) {</span>
<span class="line-removed">270   assert(JfrStacktrace_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-removed">271   const StackTrace* const trace = resolve_entry(hash, id);</span>
<span class="line-removed">272   assert(trace != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">273   assert(trace-&gt;hash() == hash, &quot;invariant&quot;);</span>
<span class="line-removed">274   assert(trace-&gt;id() == id, &quot;invariant&quot;);</span>
<span class="line-removed">275   trace-&gt;write(writer);</span>
<span class="line-removed">276   return id;</span>
<span class="line-removed">277 }</span>
<span class="line-removed">278 </span>
<span class="line-removed">279 JfrStackTraceRepository::StackTrace::StackTrace(traceid id, const JfrStackTrace&amp; trace, JfrStackTraceRepository::StackTrace* next) :</span>
<span class="line-removed">280   _next(next),</span>
<span class="line-removed">281   _frames(NULL),</span>
<span class="line-removed">282   _id(id),</span>
<span class="line-removed">283   _nr_of_frames(trace._nr_of_frames),</span>
<span class="line-removed">284   _hash(trace._hash),</span>
<span class="line-removed">285   _reached_root(trace._reached_root),</span>
<span class="line-removed">286   _written(false) {</span>
<span class="line-removed">287   if (_nr_of_frames &gt; 0) {</span>
<span class="line-removed">288     _frames = NEW_C_HEAP_ARRAY(JfrStackFrame, _nr_of_frames, mtTracing);</span>
<span class="line-removed">289     memcpy(_frames, trace._frames, _nr_of_frames * sizeof(JfrStackFrame));</span>
290   }
291 }
292 
<span class="line-modified">293 JfrStackTraceRepository::StackTrace::~StackTrace() {</span>
<span class="line-modified">294   if (_frames != NULL) {</span>
<span class="line-modified">295     FREE_C_HEAP_ARRAY(JfrStackFrame, _frames);</span>
<span class="line-modified">296   }</span>
<span class="line-removed">297 }</span>
298 
<span class="line-modified">299 bool JfrStackTraceRepository::StackTrace::equals(const JfrStackTrace&amp; rhs) const {</span>
<span class="line-modified">300   if (_reached_root != rhs._reached_root || _nr_of_frames != rhs._nr_of_frames || _hash != rhs._hash) {</span>
<span class="line-modified">301     return false;</span>
<span class="line-removed">302   }</span>
<span class="line-removed">303   for (u4 i = 0; i &lt; _nr_of_frames; ++i) {</span>
<span class="line-removed">304     if (!_frames[i].equals(rhs._frames[i])) {</span>
<span class="line-removed">305       return false;</span>
306     }

307   }
<span class="line-removed">308   return true;</span>
<span class="line-removed">309 }</span>
310 
<span class="line-modified">311 template &lt;typename Writer&gt;</span>
<span class="line-modified">312 static void write_stacktrace(Writer&amp; w, traceid id, bool reached_root, u4 nr_of_frames, const JfrStackFrame* frames) {</span>
<span class="line-removed">313   w.write((u8)id);</span>
<span class="line-removed">314   w.write((u1)!reached_root);</span>
<span class="line-removed">315   w.write(nr_of_frames);</span>
<span class="line-removed">316   for (u4 i = 0; i &lt; nr_of_frames; ++i) {</span>
<span class="line-removed">317     frames[i].write(w);</span>
318   }
<span class="line-removed">319 }</span>
<span class="line-removed">320 </span>
<span class="line-removed">321 void JfrStackTraceRepository::StackTrace::write(JfrChunkWriter&amp; sw) const {</span>
<span class="line-removed">322   assert(!_written, &quot;invariant&quot;);</span>
<span class="line-removed">323   write_stacktrace(sw, _id, _reached_root, _nr_of_frames, _frames);</span>
<span class="line-removed">324   _written = true;</span>
<span class="line-removed">325 }</span>
<span class="line-removed">326 </span>
<span class="line-removed">327 void JfrStackTraceRepository::StackTrace::write(JfrCheckpointWriter&amp; cpw) const {</span>
<span class="line-removed">328   write_stacktrace(cpw, _id, _reached_root, _nr_of_frames, _frames);</span>
<span class="line-removed">329 }</span>
<span class="line-removed">330 </span>
<span class="line-removed">331 // JfrStackFrame</span>
332 
<span class="line-modified">333 bool JfrStackFrame::equals(const JfrStackFrame&amp; rhs) const {</span>
<span class="line-modified">334   return _methodid == rhs._methodid &amp;&amp; _bci == rhs._bci &amp;&amp; _type == rhs._type;</span>
<span class="line-modified">335 }</span>
<span class="line-modified">336 </span>
<span class="line-removed">337 template &lt;typename Writer&gt;</span>
<span class="line-removed">338 static void write_frame(Writer&amp; w, traceid methodid, int line, int bci, u1 type) {</span>
<span class="line-removed">339   w.write((u8)methodid);</span>
<span class="line-removed">340   w.write((u4)line);</span>
<span class="line-removed">341   w.write((u4)bci);</span>
<span class="line-removed">342   w.write((u8)type);</span>
<span class="line-removed">343 }</span>
<span class="line-removed">344 </span>
<span class="line-removed">345 void JfrStackFrame::write(JfrChunkWriter&amp; cw) const {</span>
<span class="line-removed">346   write_frame(cw, _methodid, _line, _bci, _type);</span>
<span class="line-removed">347 }</span>
<span class="line-removed">348 </span>
<span class="line-removed">349 void JfrStackFrame::write(JfrCheckpointWriter&amp; cpw) const {</span>
<span class="line-removed">350   write_frame(cpw, _methodid, _line, _bci, _type);</span>
351 }
352 
353 // invariant is that the entry to be resolved actually exists in the table
<span class="line-modified">354 const JfrStackTraceRepository::StackTrace* JfrStackTraceRepository::resolve_entry(unsigned int hash, traceid id) const {</span>
355   const size_t index = (hash % TABLE_SIZE);
<span class="line-modified">356   const StackTrace* trace = _table[index];</span>
357   while (trace != NULL &amp;&amp; trace-&gt;id() != id) {
358     trace = trace-&gt;next();
359   }
360   assert(trace != NULL, &quot;invariant&quot;);
361   assert(trace-&gt;hash() == hash, &quot;invariant&quot;);
362   assert(trace-&gt;id() == id, &quot;invariant&quot;);
363   return trace;
364 }
<span class="line-removed">365 </span>
<span class="line-removed">366 void JfrStackFrame::resolve_lineno() {</span>
<span class="line-removed">367   assert(_method, &quot;no method pointer&quot;);</span>
<span class="line-removed">368   assert(_line == 0, &quot;already have linenumber&quot;);</span>
<span class="line-removed">369   _line = _method-&gt;line_number_from_bci(_bci);</span>
<span class="line-removed">370   _method = NULL;</span>
<span class="line-removed">371 }</span>
<span class="line-removed">372 </span>
<span class="line-removed">373 void JfrStackTrace::set_frame(u4 frame_pos, JfrStackFrame&amp; frame) {</span>
<span class="line-removed">374   assert(frame_pos &lt; _max_frames, &quot;illegal frame_pos&quot;);</span>
<span class="line-removed">375   _frames[frame_pos] = frame;</span>
<span class="line-removed">376 }</span>
<span class="line-removed">377 </span>
<span class="line-removed">378 void JfrStackTrace::resolve_linenos() {</span>
<span class="line-removed">379   for(unsigned int i = 0; i &lt; _nr_of_frames; i++) {</span>
<span class="line-removed">380     _frames[i].resolve_lineno();</span>
<span class="line-removed">381   }</span>
<span class="line-removed">382   _lineno = true;</span>
<span class="line-removed">383 }</span>
<span class="line-removed">384 </span>
<span class="line-removed">385 bool JfrStackTrace::record_safe(JavaThread* thread, int skip, bool leakp /* false */) {</span>
<span class="line-removed">386   assert(thread == Thread::current(), &quot;Thread stack needs to be walkable&quot;);</span>
<span class="line-removed">387   vframeStream vfs(thread);</span>
<span class="line-removed">388   u4 count = 0;</span>
<span class="line-removed">389   _reached_root = true;</span>
<span class="line-removed">390   for(int i = 0; i &lt; skip; i++) {</span>
<span class="line-removed">391     if (vfs.at_end()) {</span>
<span class="line-removed">392       break;</span>
<span class="line-removed">393     }</span>
<span class="line-removed">394     vfs.next();</span>
<span class="line-removed">395   }</span>
<span class="line-removed">396 </span>
<span class="line-removed">397   while (!vfs.at_end()) {</span>
<span class="line-removed">398     if (count &gt;= _max_frames) {</span>
<span class="line-removed">399       _reached_root = false;</span>
<span class="line-removed">400       break;</span>
<span class="line-removed">401     }</span>
<span class="line-removed">402     const Method* method = vfs.method();</span>
<span class="line-removed">403     const traceid mid = JfrTraceId::use(method, leakp);</span>
<span class="line-removed">404     int type = vfs.is_interpreted_frame() ? JfrStackFrame::FRAME_INTERPRETER : JfrStackFrame::FRAME_JIT;</span>
<span class="line-removed">405     int bci = 0;</span>
<span class="line-removed">406     if (method-&gt;is_native()) {</span>
<span class="line-removed">407       type = JfrStackFrame::FRAME_NATIVE;</span>
<span class="line-removed">408     } else {</span>
<span class="line-removed">409       bci = vfs.bci();</span>
<span class="line-removed">410     }</span>
<span class="line-removed">411     // Can we determine if it&#39;s inlined?</span>
<span class="line-removed">412     _hash = (_hash &lt;&lt; 2) + (unsigned int)(((size_t)mid &gt;&gt; 2) + (bci &lt;&lt; 4) + type);</span>
<span class="line-removed">413     _frames[count] = JfrStackFrame(mid, bci, type, method);</span>
<span class="line-removed">414     vfs.next();</span>
<span class="line-removed">415     count++;</span>
<span class="line-removed">416   }</span>
<span class="line-removed">417 </span>
<span class="line-removed">418   _nr_of_frames = count;</span>
<span class="line-removed">419   return true;</span>
<span class="line-removed">420 }</span>
<span class="line-removed">421 </span>
<span class="line-removed">422 bool JfrStackTrace::record_thread(JavaThread&amp; thread, frame&amp; frame) {</span>
<span class="line-removed">423   vframeStreamSamples st(&amp;thread, frame, false);</span>
<span class="line-removed">424   u4 count = 0;</span>
<span class="line-removed">425   _reached_root = true;</span>
<span class="line-removed">426 </span>
<span class="line-removed">427   while (!st.at_end()) {</span>
<span class="line-removed">428     if (count &gt;= _max_frames) {</span>
<span class="line-removed">429       _reached_root = false;</span>
<span class="line-removed">430       break;</span>
<span class="line-removed">431     }</span>
<span class="line-removed">432     const Method* method = st.method();</span>
<span class="line-removed">433     if (!Method::is_valid_method(method)) {</span>
<span class="line-removed">434       // we throw away everything we&#39;ve gathered in this sample since</span>
<span class="line-removed">435       // none of it is safe</span>
<span class="line-removed">436       return false;</span>
<span class="line-removed">437     }</span>
<span class="line-removed">438     const traceid mid = JfrTraceId::use(method);</span>
<span class="line-removed">439     int type = st.is_interpreted_frame() ? JfrStackFrame::FRAME_INTERPRETER : JfrStackFrame::FRAME_JIT;</span>
<span class="line-removed">440     int bci = 0;</span>
<span class="line-removed">441     if (method-&gt;is_native()) {</span>
<span class="line-removed">442       type = JfrStackFrame::FRAME_NATIVE;</span>
<span class="line-removed">443     } else {</span>
<span class="line-removed">444       bci = st.bci();</span>
<span class="line-removed">445     }</span>
<span class="line-removed">446     const int lineno = method-&gt;line_number_from_bci(bci);</span>
<span class="line-removed">447     // Can we determine if it&#39;s inlined?</span>
<span class="line-removed">448     _hash = (_hash &lt;&lt; 2) + (unsigned int)(((size_t)mid &gt;&gt; 2) + (bci &lt;&lt; 4) + type);</span>
<span class="line-removed">449     _frames[count] = JfrStackFrame(mid, bci, type, lineno);</span>
<span class="line-removed">450     st.samples_next();</span>
<span class="line-removed">451     count++;</span>
<span class="line-removed">452   }</span>
<span class="line-removed">453 </span>
<span class="line-removed">454   _lineno = true;</span>
<span class="line-removed">455   _nr_of_frames = count;</span>
<span class="line-removed">456   return true;</span>
<span class="line-removed">457 }</span>
<span class="line-removed">458 </span>
<span class="line-removed">459 void JfrStackTraceRepository::write_metadata(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-removed">460   JfrFrameType fct;</span>
<span class="line-removed">461   writer.write_type(TYPE_FRAMETYPE);</span>
<span class="line-removed">462   fct.serialize(writer);</span>
<span class="line-removed">463 }</span>
</pre>
</td>
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/metadata/jfrSerializer.hpp&quot;
<span class="line-modified"> 27 #include &quot;jfr/recorder/checkpoint/jfrCheckpointWriter.hpp&quot;</span>
 28 #include &quot;jfr/recorder/repository/jfrChunkWriter.hpp&quot;

 29 #include &quot;jfr/recorder/stacktrace/jfrStackTraceRepository.hpp&quot;
<span class="line-modified"> 30 #include &quot;jfr/support/jfrThreadLocal.hpp&quot;</span>

 31 #include &quot;runtime/mutexLocker.hpp&quot;




 32 
<span class="line-modified"> 33 static JfrStackTraceRepository* _instance = NULL;</span>






























 34 
<span class="line-modified"> 35 JfrStackTraceRepository::JfrStackTraceRepository() : _next_id(0), _entries(0) {</span>
<span class="line-modified"> 36   memset(_table, 0, sizeof(_table));</span>










 37 }
 38 


 39 JfrStackTraceRepository&amp; JfrStackTraceRepository::instance() {
 40   return *_instance;
 41 }
 42 
 43 JfrStackTraceRepository* JfrStackTraceRepository::create() {
 44   assert(_instance == NULL, &quot;invariant&quot;);
 45   _instance = new JfrStackTraceRepository();
 46   return _instance;
 47 }
 48 









 49 class JfrFrameType : public JfrSerializer {
 50  public:
 51   void serialize(JfrCheckpointWriter&amp; writer) {
 52     writer.write_count(JfrStackFrame::NUM_FRAME_TYPES);
 53     writer.write_key(JfrStackFrame::FRAME_INTERPRETER);
 54     writer.write(&quot;Interpreted&quot;);
 55     writer.write_key(JfrStackFrame::FRAME_JIT);
 56     writer.write(&quot;JIT compiled&quot;);
 57     writer.write_key(JfrStackFrame::FRAME_INLINE);
 58     writer.write(&quot;Inlined&quot;);
 59     writer.write_key(JfrStackFrame::FRAME_NATIVE);
 60     writer.write(&quot;Native&quot;);
 61   }
 62 };
 63 
 64 bool JfrStackTraceRepository::initialize() {
<span class="line-modified"> 65   return JfrSerializer::register_serializer(TYPE_FRAMETYPE, true, new JfrFrameType());</span>
<span class="line-added"> 66 }</span>
<span class="line-added"> 67 </span>
<span class="line-added"> 68 void JfrStackTraceRepository::destroy() {</span>
<span class="line-added"> 69   assert(_instance != NULL, &quot;invarinat&quot;);</span>
<span class="line-added"> 70   delete _instance;</span>
<span class="line-added"> 71   _instance = NULL;</span>
<span class="line-added"> 72 }</span>
<span class="line-added"> 73 </span>
<span class="line-added"> 74 static traceid last_id = 0;</span>
<span class="line-added"> 75 </span>
<span class="line-added"> 76 bool JfrStackTraceRepository::is_modified() const {</span>
<span class="line-added"> 77   return last_id != _next_id;</span>
<span class="line-added"> 78 }</span>
<span class="line-added"> 79 </span>
<span class="line-added"> 80 size_t JfrStackTraceRepository::write(JfrChunkWriter&amp; sw, bool clear) {</span>
<span class="line-added"> 81   if (_entries == 0) {</span>
<span class="line-added"> 82     return 0;</span>
<span class="line-added"> 83   }</span>
<span class="line-added"> 84   MutexLocker lock(JfrStacktrace_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added"> 85   assert(_entries &gt; 0, &quot;invariant&quot;);</span>
<span class="line-added"> 86   int count = 0;</span>
<span class="line-added"> 87   for (u4 i = 0; i &lt; TABLE_SIZE; ++i) {</span>
<span class="line-added"> 88     JfrStackTrace* stacktrace = _table[i];</span>
<span class="line-added"> 89     while (stacktrace != NULL) {</span>
<span class="line-added"> 90       JfrStackTrace* next = const_cast&lt;JfrStackTrace*&gt;(stacktrace-&gt;next());</span>
<span class="line-added"> 91       if (stacktrace-&gt;should_write()) {</span>
<span class="line-added"> 92         stacktrace-&gt;write(sw);</span>
<span class="line-added"> 93         ++count;</span>
<span class="line-added"> 94       }</span>
<span class="line-added"> 95       if (clear) {</span>
<span class="line-added"> 96         delete stacktrace;</span>
<span class="line-added"> 97       }</span>
<span class="line-added"> 98       stacktrace = next;</span>
<span class="line-added"> 99     }</span>
<span class="line-added">100   }</span>
<span class="line-added">101   if (clear) {</span>
<span class="line-added">102     memset(_table, 0, sizeof(_table));</span>
<span class="line-added">103     _entries = 0;</span>
<span class="line-added">104   }</span>
<span class="line-added">105   last_id = _next_id;</span>
<span class="line-added">106   return count;</span>
107 }
108 
109 size_t JfrStackTraceRepository::clear() {
<span class="line-modified">110   MutexLocker lock(JfrStacktrace_lock, Mutex::_no_safepoint_check_flag);</span>
111   if (_entries == 0) {
112     return 0;
113   }
114   for (u4 i = 0; i &lt; TABLE_SIZE; ++i) {
<span class="line-modified">115     JfrStackTrace* stacktrace = _table[i];</span>
116     while (stacktrace != NULL) {
<span class="line-modified">117       JfrStackTrace* next = const_cast&lt;JfrStackTrace*&gt;(stacktrace-&gt;next());</span>
118       delete stacktrace;
119       stacktrace = next;
120     }
121   }
122   memset(_table, 0, sizeof(_table));
123   const size_t processed = _entries;
124   _entries = 0;
125   return processed;
126 }
127 


























128 traceid JfrStackTraceRepository::record(Thread* thread, int skip /* 0 */) {
129   assert(thread == Thread::current(), &quot;invariant&quot;);
130   JfrThreadLocal* const tl = thread-&gt;jfr_thread_local();
131   assert(tl != NULL, &quot;invariant&quot;);
132   if (tl-&gt;has_cached_stack_trace()) {
133     return tl-&gt;cached_stack_trace_id();
134   }
<span class="line-modified">135   if (!thread-&gt;is_Java_thread() || thread-&gt;is_hidden_from_external_view() || tl-&gt;is_excluded()) {</span>






















136     return 0;
137   }
138   JfrStackFrame* frames = tl-&gt;stackframes();
139   if (frames == NULL) {
140     // pending oom
141     return 0;
142   }
143   assert(frames != NULL, &quot;invariant&quot;);
144   assert(tl-&gt;stackframes() == frames, &quot;invariant&quot;);
<span class="line-modified">145   return instance().record_for((JavaThread*)thread, skip, frames, tl-&gt;stackdepth());</span>
146 }
147 
148 traceid JfrStackTraceRepository::record_for(JavaThread* thread, int skip, JfrStackFrame *frames, u4 max_frames) {
149   JfrStackTrace stacktrace(frames, max_frames);
<span class="line-modified">150   return stacktrace.record_safe(thread, skip) ? add(stacktrace) : 0;</span>








151 }
152 
<span class="line-modified">153 traceid JfrStackTraceRepository::add(const JfrStackTrace&amp; stacktrace) {</span>
<span class="line-modified">154   traceid tid = instance().add_trace(stacktrace);</span>





155   if (tid == 0) {
156     stacktrace.resolve_linenos();
<span class="line-modified">157     tid = instance().add_trace(stacktrace);</span>
158   }
<span class="line-modified">159   assert(tid != 0, &quot;invariant&quot;);</span>
160   return tid;
161 }
162 
<span class="line-modified">163 void JfrStackTraceRepository::record_and_cache(JavaThread* thread, int skip /* 0 */) {</span>
<span class="line-modified">164   assert(thread != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">165   JfrThreadLocal* const tl = thread-&gt;jfr_thread_local();</span>
<span class="line-modified">166   assert(tl != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">167   assert(!tl-&gt;has_cached_stack_trace(), &quot;invariant&quot;);</span>
<span class="line-modified">168   JfrStackTrace stacktrace(tl-&gt;stackframes(), tl-&gt;stackdepth());</span>
<span class="line-modified">169   stacktrace.record_safe(thread, skip);</span>
<span class="line-modified">170   const unsigned int hash = stacktrace.hash();</span>
<span class="line-modified">171   if (hash != 0) {</span>
<span class="line-modified">172     tl-&gt;set_cached_stack_trace_id(instance().add(stacktrace), hash);</span>








































173   }
174 }
175 
<span class="line-modified">176 traceid JfrStackTraceRepository::add_trace(const JfrStackTrace&amp; stacktrace) {</span>
<span class="line-modified">177   MutexLocker lock(JfrStacktrace_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">178   const size_t index = stacktrace._hash % TABLE_SIZE;</span>
<span class="line-modified">179   const JfrStackTrace* table_entry = _table[index];</span>

180 
<span class="line-modified">181   while (table_entry != NULL) {</span>
<span class="line-modified">182     if (table_entry-&gt;equals(stacktrace)) {</span>
<span class="line-modified">183       return table_entry-&gt;id();</span>




184     }
<span class="line-added">185     table_entry = table_entry-&gt;next();</span>
186   }


187 
<span class="line-modified">188   if (!stacktrace.have_lineno()) {</span>
<span class="line-modified">189     return 0;</span>





190   }













191 
<span class="line-modified">192   traceid id = ++_next_id;</span>
<span class="line-modified">193   _table[index] = new JfrStackTrace(id, stacktrace, _table[index]);</span>
<span class="line-modified">194   ++_entries;</span>
<span class="line-modified">195   return id;</span>














196 }
197 
198 // invariant is that the entry to be resolved actually exists in the table
<span class="line-modified">199 const JfrStackTrace* JfrStackTraceRepository::lookup(unsigned int hash, traceid id) const {</span>
200   const size_t index = (hash % TABLE_SIZE);
<span class="line-modified">201   const JfrStackTrace* trace = _table[index];</span>
202   while (trace != NULL &amp;&amp; trace-&gt;id() != id) {
203     trace = trace-&gt;next();
204   }
205   assert(trace != NULL, &quot;invariant&quot;);
206   assert(trace-&gt;hash() == hash, &quot;invariant&quot;);
207   assert(trace-&gt;id() == id, &quot;invariant&quot;);
208   return trace;
209 }



































































































</pre>
</td>
</tr>
</table>
<center><a href="../service/jfrRecorderThreadLoop.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrStackTraceRepository.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/jfr/recorder/checkpoint/types/jfrThreadState.cpp b/src/hotspot/share/jfr/recorder/checkpoint/types/jfrThreadState.cpp
--- a/src/hotspot/share/jfr/recorder/checkpoint/types/jfrThreadState.cpp
+++ b/src/hotspot/share/jfr/recorder/checkpoint/types/jfrThreadState.cpp
@@ -1,7 +1,7 @@
 /*
-* Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
+* Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
@@ -21,13 +21,17 @@
 * questions.
 *
 */
 
 #include "precompiled.hpp"
+#include "classfile/javaClasses.inline.hpp"
 #include "jfr/recorder/checkpoint/types/jfrThreadState.hpp"
 #include "jfr/recorder/checkpoint/jfrCheckpointWriter.hpp"
+#include "jfr/support/jfrThreadLocal.hpp"
 #include "jvmtifiles/jvmti.h"
+#include "runtime/osThread.hpp"
+#include "runtime/thread.hpp"
 
 struct jvmti_thread_state {
   u8 id;
   const char* description;
 };
@@ -78,5 +82,49 @@
     writer.write_key(states[i].id);
     writer.write(states[i].description);
   }
 }
 
+traceid JfrThreadId::id(const Thread* t) {
+  assert(t != NULL, "invariant");
+  if (!t->is_Java_thread()) {
+    return os_id(t);
+  }
+  const JavaThread* const jt = (JavaThread*)t;
+  const oop thread_obj = jt->threadObj();
+  return thread_obj != NULL ? java_lang_Thread::thread_id(thread_obj) : 0;
+}
+
+traceid JfrThreadId::os_id(const Thread* t) {
+  assert(t != NULL, "invariant");
+  const OSThread* const os_thread = t->osthread();
+  return os_thread != NULL ? os_thread->thread_id() : 0;
+}
+
+traceid JfrThreadId::jfr_id(const Thread* t) {
+  assert(t != NULL, "invariant");
+  return t->jfr_thread_local()->thread_id();
+}
+
+// caller needs ResourceMark
+const char* get_java_thread_name(const Thread* t) {
+  assert(t != NULL, "invariant");
+  assert(t->is_Java_thread(), "invariant");
+  const JavaThread* const jt = ((JavaThread*)t);
+  const char* name_str = "<no-name - thread name unresolved>";
+  const oop thread_obj = jt->threadObj();
+  if (thread_obj != NULL) {
+    const oop name = java_lang_Thread::name(thread_obj);
+    if (name != NULL) {
+      name_str = java_lang_String::as_utf8_string(name);
+    }
+  } else if (jt->is_attaching_via_jni()) {
+    name_str = "<no-name - thread is attaching>";
+  }
+  assert(name_str != NULL, "unexpected NULL thread name");
+  return name_str;
+}
+
+const char* JfrThreadName::name(const Thread* t) {
+  assert(t != NULL, "invariant");
+  return t->is_Java_thread() ? get_java_thread_name(t) : t->name();
+}

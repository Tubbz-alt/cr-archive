<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/jfr/recorder/storage/jfrStorage.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="jfrMemorySpace.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrStorage.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/storage/jfrStorage.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 24,10 ***</span>
<span class="line-new-header">--- 24,11 ---</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;jfr/jfrEvents.hpp&quot;
  #include &quot;jfr/jni/jfrJavaSupport.hpp&quot;
  #include &quot;jfr/recorder/jfrRecorder.hpp&quot;
<span class="line-added">+ #include &quot;jfr/recorder/checkpoint/jfrCheckpointManager.hpp&quot;</span>
  #include &quot;jfr/recorder/repository/jfrChunkWriter.hpp&quot;
  #include &quot;jfr/recorder/service/jfrOptionSet.hpp&quot;
  #include &quot;jfr/recorder/service/jfrPostBox.hpp&quot;
  #include &quot;jfr/recorder/storage/jfrMemorySpace.inline.hpp&quot;
  #include &quot;jfr/recorder/storage/jfrStorage.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 36,11 ***</span>
  #include &quot;jfr/utilities/jfrIterator.hpp&quot;
  #include &quot;jfr/utilities/jfrTime.hpp&quot;
  #include &quot;jfr/writers/jfrNativeEventWriter.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;runtime/mutexLocker.hpp&quot;
<span class="line-removed">- #include &quot;runtime/orderAccess.hpp&quot;</span>
  #include &quot;runtime/os.inline.hpp&quot;
  #include &quot;runtime/safepoint.hpp&quot;
  #include &quot;runtime/thread.hpp&quot;
  
  typedef JfrStorage::Buffer* BufferPtr;
<span class="line-new-header">--- 37,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 232,11 ***</span>
  }
  
  static void write_data_loss(BufferPtr buffer, Thread* thread) {
    assert(buffer != NULL, &quot;invariant&quot;);
    const size_t unflushed_size = buffer-&gt;unflushed_size();
<span class="line-modified">!   buffer-&gt;concurrent_reinitialization();</span>
    if (unflushed_size == 0) {
      return;
    }
    write_data_loss_event(buffer, unflushed_size, thread);
  }
<span class="line-new-header">--- 232,11 ---</span>
  }
  
  static void write_data_loss(BufferPtr buffer, Thread* thread) {
    assert(buffer != NULL, &quot;invariant&quot;);
    const size_t unflushed_size = buffer-&gt;unflushed_size();
<span class="line-modified">!   buffer-&gt;reinitialize();</span>
    if (unflushed_size == 0) {
      return;
    }
    write_data_loss_event(buffer, unflushed_size, thread);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 247,22 ***</span>
    assert(buffer != NULL, &quot;invariant&quot;);
    assert(!buffer-&gt;lease(), &quot;invariant&quot;);
    assert(!buffer-&gt;transient(), &quot;invariant&quot;);
    const size_t unflushed_size = buffer-&gt;unflushed_size();
    if (unflushed_size == 0) {
<span class="line-modified">!     buffer-&gt;concurrent_reinitialization();</span>
      assert(buffer-&gt;empty(), &quot;invariant&quot;);
      return true;
    }
    BufferPtr const promotion_buffer = get_promotion_buffer(unflushed_size, _global_mspace, *this, promotion_retry, thread);
    if (promotion_buffer == NULL) {
      write_data_loss(buffer, thread);
      return false;
    }
    assert(promotion_buffer-&gt;acquired_by_self(), &quot;invariant&quot;);
    assert(promotion_buffer-&gt;free_size() &gt;= unflushed_size, &quot;invariant&quot;);
<span class="line-modified">!   buffer-&gt;concurrent_move_and_reinitialize(promotion_buffer, unflushed_size);</span>
    assert(buffer-&gt;empty(), &quot;invariant&quot;);
    return true;
  }
  
  /*
<span class="line-new-header">--- 247,34 ---</span>
    assert(buffer != NULL, &quot;invariant&quot;);
    assert(!buffer-&gt;lease(), &quot;invariant&quot;);
    assert(!buffer-&gt;transient(), &quot;invariant&quot;);
    const size_t unflushed_size = buffer-&gt;unflushed_size();
    if (unflushed_size == 0) {
<span class="line-modified">!     buffer-&gt;reinitialize();</span>
      assert(buffer-&gt;empty(), &quot;invariant&quot;);
      return true;
    }
<span class="line-added">+ </span>
<span class="line-added">+   if (buffer-&gt;excluded()) {</span>
<span class="line-added">+     const bool thread_is_excluded = thread-&gt;jfr_thread_local()-&gt;is_excluded();</span>
<span class="line-added">+     buffer-&gt;reinitialize(thread_is_excluded);</span>
<span class="line-added">+     assert(buffer-&gt;empty(), &quot;invariant&quot;);</span>
<span class="line-added">+     if (!thread_is_excluded) {</span>
<span class="line-added">+       // state change from exclusion to inclusion requires a thread checkpoint</span>
<span class="line-added">+       JfrCheckpointManager::write_thread_checkpoint(thread);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    BufferPtr const promotion_buffer = get_promotion_buffer(unflushed_size, _global_mspace, *this, promotion_retry, thread);
    if (promotion_buffer == NULL) {
      write_data_loss(buffer, thread);
      return false;
    }
    assert(promotion_buffer-&gt;acquired_by_self(), &quot;invariant&quot;);
    assert(promotion_buffer-&gt;free_size() &gt;= unflushed_size, &quot;invariant&quot;);
<span class="line-modified">!   buffer-&gt;move(promotion_buffer, unflushed_size);</span>
    assert(buffer-&gt;empty(), &quot;invariant&quot;);
    return true;
  }
  
  /*
</pre>
<hr />
<pre>
<span class="line-old-header">*** 310,40 ***</span>
    return mspace_get_free_with_detach(0, age_mspace, thread);
  }
  
  static bool insert_full_age_node(JfrAgeNode* age_node, JfrStorageAgeMspace* age_mspace, Thread* thread) {
    assert(JfrBuffer_lock-&gt;owned_by_self(), &quot;invariant&quot;);
    assert(age_node-&gt;retired_buffer()-&gt;retired(), &quot;invariant&quot;);
    age_mspace-&gt;insert_full_head(age_node);
    return true;
  }
  
  static bool full_buffer_registration(BufferPtr buffer, JfrStorageAgeMspace* age_mspace, JfrStorageControl&amp; control, Thread* thread) {
    assert(buffer != NULL, &quot;invariant&quot;);
    assert(buffer-&gt;retired(), &quot;invariant&quot;);
    assert(age_mspace != NULL, &quot;invariant&quot;);
<span class="line-modified">!   MutexLockerEx lock(JfrBuffer_lock, Mutex::_no_safepoint_check_flag);</span>
    JfrAgeNode* age_node = get_free_age_node(age_mspace, thread);
    if (age_node == NULL) {
      age_node = new_age_node(buffer, age_mspace, thread);
      if (age_node == NULL) {
        return false;
      }
    }
<span class="line-removed">-   assert(age_node-&gt;acquired_by_self(), &quot;invariant&quot;);</span>
    assert(age_node != NULL, &quot;invariant&quot;);
    age_node-&gt;set_retired_buffer(buffer);
    control.increment_full();
    return insert_full_age_node(age_node, age_mspace, thread);
  }
  
  void JfrStorage::register_full(BufferPtr buffer, Thread* thread) {
    assert(buffer != NULL, &quot;invariant&quot;);
    assert(buffer-&gt;retired(), &quot;invariant&quot;);
    if (!full_buffer_registration(buffer, _age_mspace, control(), thread)) {
      handle_registration_failure(buffer);
<span class="line-removed">-     buffer-&gt;release();</span>
    }
    if (control().should_post_buffer_full_message()) {
      _post_box.post(MSG_FULLBUFFER);
    }
  }
<span class="line-new-header">--- 322,44 ---</span>
    return mspace_get_free_with_detach(0, age_mspace, thread);
  }
  
  static bool insert_full_age_node(JfrAgeNode* age_node, JfrStorageAgeMspace* age_mspace, Thread* thread) {
    assert(JfrBuffer_lock-&gt;owned_by_self(), &quot;invariant&quot;);
<span class="line-added">+   assert(age_node != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(age_node-&gt;acquired_by_self(), &quot;invariant&quot;);</span>
    assert(age_node-&gt;retired_buffer()-&gt;retired(), &quot;invariant&quot;);
<span class="line-added">+   age_node-&gt;release(); // drop identity claim on age node when inserting to full list</span>
<span class="line-added">+   assert(age_node-&gt;identity() == NULL, &quot;invariant&quot;);</span>
    age_mspace-&gt;insert_full_head(age_node);
    return true;
  }
  
  static bool full_buffer_registration(BufferPtr buffer, JfrStorageAgeMspace* age_mspace, JfrStorageControl&amp; control, Thread* thread) {
    assert(buffer != NULL, &quot;invariant&quot;);
    assert(buffer-&gt;retired(), &quot;invariant&quot;);
    assert(age_mspace != NULL, &quot;invariant&quot;);
<span class="line-modified">!   MutexLocker lock(JfrBuffer_lock, Mutex::_no_safepoint_check_flag);</span>
    JfrAgeNode* age_node = get_free_age_node(age_mspace, thread);
    if (age_node == NULL) {
      age_node = new_age_node(buffer, age_mspace, thread);
      if (age_node == NULL) {
        return false;
      }
    }
    assert(age_node != NULL, &quot;invariant&quot;);
<span class="line-added">+   assert(age_node-&gt;acquired_by_self(), &quot;invariant&quot;);</span>
    age_node-&gt;set_retired_buffer(buffer);
    control.increment_full();
    return insert_full_age_node(age_node, age_mspace, thread);
  }
  
  void JfrStorage::register_full(BufferPtr buffer, Thread* thread) {
    assert(buffer != NULL, &quot;invariant&quot;);
    assert(buffer-&gt;retired(), &quot;invariant&quot;);
<span class="line-added">+   assert(buffer-&gt;acquired_by(thread), &quot;invariant&quot;);</span>
    if (!full_buffer_registration(buffer, _age_mspace, control(), thread)) {
      handle_registration_failure(buffer);
    }
    if (control().should_post_buffer_full_message()) {
      _post_box.post(MSG_FULLBUFFER);
    }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 370,16 ***</span>
    assert(!buffer-&gt;lease(), &quot;invariant&quot;);
    assert(!buffer-&gt;transient(), &quot;invariant&quot;);
    assert(!buffer-&gt;retired(), &quot;invariant&quot;);
    if (!buffer-&gt;empty()) {
      if (!flush_regular_buffer(buffer, thread)) {
<span class="line-modified">!       buffer-&gt;concurrent_reinitialization();</span>
      }
    }
    assert(buffer-&gt;empty(), &quot;invariant&quot;);
    control().increment_dead();
<span class="line-removed">-   buffer-&gt;release();</span>
    buffer-&gt;set_retired();
  }
  
  void JfrStorage::release_thread_local(BufferPtr buffer, Thread* thread) {
    assert(buffer != NULL, &quot;invariant&quot;);
<span class="line-new-header">--- 386,16 ---</span>
    assert(!buffer-&gt;lease(), &quot;invariant&quot;);
    assert(!buffer-&gt;transient(), &quot;invariant&quot;);
    assert(!buffer-&gt;retired(), &quot;invariant&quot;);
    if (!buffer-&gt;empty()) {
      if (!flush_regular_buffer(buffer, thread)) {
<span class="line-modified">!       buffer-&gt;reinitialize();</span>
      }
    }
    assert(buffer-&gt;empty(), &quot;invariant&quot;);
<span class="line-added">+   assert(buffer-&gt;identity() != NULL, &quot;invariant&quot;);</span>
    control().increment_dead();
    buffer-&gt;set_retired();
  }
  
  void JfrStorage::release_thread_local(BufferPtr buffer, Thread* thread) {
    assert(buffer != NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 410,24 ***</span>
      while (true) {
        JfrAgeNode* const oldest_age_node = _age_mspace-&gt;full_tail();
        if (oldest_age_node == NULL) {
          break;
        }
        BufferPtr const buffer = oldest_age_node-&gt;retired_buffer();
        assert(buffer-&gt;retired(), &quot;invariant&quot;);
<span class="line-modified">!       discarded_size += buffer-&gt;unflushed_size();</span>
        num_full_post_discard = control().decrement_full();
        if (buffer-&gt;transient()) {
          mspace_release_full(buffer, _transient_mspace);
<span class="line-removed">-         mspace_release_full(oldest_age_node, _age_mspace);</span>
          continue;
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         mspace_release_full(oldest_age_node, _age_mspace);</span>
<span class="line-removed">-         buffer-&gt;reinitialize();</span>
<span class="line-removed">-         buffer-&gt;release(); // pusb</span>
<span class="line-removed">-         break;</span>
        }
      }
      JfrBuffer_lock-&gt;unlock();
      const size_t number_of_discards = num_full_pre_discard - num_full_post_discard;
      if (number_of_discards &gt; 0) {
        log_discard(number_of_discards, discarded_size, num_full_post_discard);
<span class="line-new-header">--- 426,25 ---</span>
      while (true) {
        JfrAgeNode* const oldest_age_node = _age_mspace-&gt;full_tail();
        if (oldest_age_node == NULL) {
          break;
        }
<span class="line-added">+       assert(oldest_age_node-&gt;identity() == NULL, &quot;invariant&quot;);</span>
        BufferPtr const buffer = oldest_age_node-&gt;retired_buffer();
        assert(buffer-&gt;retired(), &quot;invariant&quot;);
<span class="line-modified">!       assert(buffer-&gt;identity() != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+       discarded_size += buffer-&gt;discard();</span>
<span class="line-added">+       assert(buffer-&gt;unflushed_size() == 0, &quot;invariant&quot;);</span>
        num_full_post_discard = control().decrement_full();
<span class="line-added">+       mspace_release_full(oldest_age_node, _age_mspace);</span>
        if (buffer-&gt;transient()) {
          mspace_release_full(buffer, _transient_mspace);
          continue;
        }
<span class="line-added">+       buffer-&gt;reinitialize();</span>
<span class="line-added">+       buffer-&gt;release(); // publish</span>
<span class="line-added">+       break;</span>
      }
      JfrBuffer_lock-&gt;unlock();
      const size_t number_of_discards = num_full_pre_discard - num_full_post_discard;
      if (number_of_discards &gt; 0) {
        log_discard(number_of_discards, discarded_size, num_full_post_discard);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 463,10 ***</span>
<span class="line-new-header">--- 480,11 ---</span>
  
  static void assert_flush_large_precondition(ConstBufferPtr cur, const u1* const cur_pos, size_t used, size_t req, bool native, Thread* t) {
    assert(t != NULL, &quot;invariant&quot;);
    assert(cur != NULL, &quot;invariant&quot;);
    assert(cur-&gt;lease(), &quot;invariant&quot;);
<span class="line-added">+   assert(!cur-&gt;excluded(), &quot;invariant&quot;);</span>
    assert(cur_pos != NULL, &quot;invariant&quot;);
    assert(native ? t-&gt;jfr_thread_local()-&gt;native_buffer() == cur : t-&gt;jfr_thread_local()-&gt;java_buffer() == cur, &quot;invariant&quot;);
    assert(t-&gt;jfr_thread_local()-&gt;shelved_buffer() != NULL, &quot;invariant&quot;);
    assert(req &gt;= used, &quot;invariant&quot;);
    assert(cur != t-&gt;jfr_thread_local()-&gt;shelved_buffer(), &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 489,10 ***</span>
<span class="line-new-header">--- 507,13 ---</span>
    // which is where the &quot;used / uncommitted&quot; data resides. It is therefore both
    // possible and valid to migrate data after the flush. This is however only
    // the case for stable thread local buffers; it is not the case for large buffers.
    if (!cur-&gt;empty()) {
      flush_regular_buffer(cur, t);
<span class="line-added">+     if (cur-&gt;excluded()) {</span>
<span class="line-added">+       return cur;</span>
<span class="line-added">+     }</span>
    }
    assert(t-&gt;jfr_thread_local()-&gt;shelved_buffer() == NULL, &quot;invariant&quot;);
    if (cur-&gt;free_size() &gt;= req) {
      // simplest case, no switching of buffers
      if (used &gt; 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 577,55 ***</span>
  }
  
  typedef UnBufferedWriteToChunk&lt;JfrBuffer&gt; WriteOperation;
  typedef MutexedWriteOp&lt;WriteOperation&gt; MutexedWriteOperation;
  typedef ConcurrentWriteOp&lt;WriteOperation&gt; ConcurrentWriteOperation;
<span class="line-modified">! typedef ConcurrentWriteOpExcludeRetired&lt;WriteOperation&gt; ThreadLocalConcurrentWriteOperation;</span>
  
  size_t JfrStorage::write() {
<span class="line-modified">!   const size_t full_size_processed = write_full();</span>
    WriteOperation wo(_chunkwriter);
<span class="line-modified">!   ThreadLocalConcurrentWriteOperation tlwo(wo);</span>
    process_full_list(tlwo, _thread_local_mspace);
    ConcurrentWriteOperation cwo(wo);
    process_free_list(cwo, _global_mspace);
<span class="line-modified">!   return full_size_processed + wo.processed();</span>
  }
  
  size_t JfrStorage::write_at_safepoint() {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
    WriteOperation wo(_chunkwriter);
    MutexedWriteOperation writer(wo); // mutexed write mode
<span class="line-modified">!   process_full_list(writer, _thread_local_mspace);</span>
    assert(_transient_mspace-&gt;is_free_empty(), &quot;invariant&quot;);
    process_full_list(writer, _transient_mspace);
    assert(_global_mspace-&gt;is_full_empty(), &quot;invariant&quot;);
    process_free_list(writer, _global_mspace);
<span class="line-modified">!   return wo.processed();</span>
  }
  
  typedef DiscardOp&lt;DefaultDiscarder&lt;JfrStorage::Buffer&gt; &gt; DiscardOperation;
  typedef ReleaseOp&lt;JfrStorageMspace&gt; ReleaseOperation;
  typedef CompositeOperation&lt;MutexedWriteOperation, ReleaseOperation&gt; FullOperation;
  
  size_t JfrStorage::clear() {
<span class="line-modified">!   const size_t full_size_processed = clear_full();</span>
    DiscardOperation discarder(concurrent); // concurrent discard mode
    process_full_list(discarder, _thread_local_mspace);
    assert(_transient_mspace-&gt;is_free_empty(), &quot;invariant&quot;);
    process_full_list(discarder, _transient_mspace);
    assert(_global_mspace-&gt;is_full_empty(), &quot;invariant&quot;);
    process_free_list(discarder, _global_mspace);
<span class="line-modified">!   return full_size_processed + discarder.processed();</span>
  }
  
  static void insert_free_age_nodes(JfrStorageAgeMspace* age_mspace, JfrAgeNode* head, JfrAgeNode* tail, size_t count) {
    if (tail != NULL) {
      assert(tail-&gt;next() == NULL, &quot;invariant&quot;);
      assert(head != NULL, &quot;invariant&quot;);
      assert(head-&gt;prev() == NULL, &quot;invariant&quot;);
<span class="line-modified">!     MutexLockerEx buffer_lock(JfrBuffer_lock, Mutex::_no_safepoint_check_flag);</span>
      age_mspace-&gt;insert_free_tail(head, tail, count);
    }
  }
  
  template &lt;typename Processor&gt;
<span class="line-new-header">--- 598,67 ---</span>
  }
  
  typedef UnBufferedWriteToChunk&lt;JfrBuffer&gt; WriteOperation;
  typedef MutexedWriteOp&lt;WriteOperation&gt; MutexedWriteOperation;
  typedef ConcurrentWriteOp&lt;WriteOperation&gt; ConcurrentWriteOperation;
<span class="line-modified">! </span>
<span class="line-added">+ typedef Retired&lt;JfrBuffer, true&gt; NonRetired;</span>
<span class="line-added">+ typedef Excluded&lt;JfrBuffer, true&gt; NonExcluded;</span>
<span class="line-added">+ typedef CompositeOperation&lt;NonRetired, NonExcluded&gt; BufferPredicate;</span>
<span class="line-added">+ typedef PredicatedMutexedWriteOp&lt;WriteOperation, BufferPredicate&gt; ThreadLocalMutexedWriteOperation;</span>
<span class="line-added">+ typedef PredicatedConcurrentWriteOp&lt;WriteOperation, BufferPredicate&gt; ThreadLocalConcurrentWriteOperation;</span>
  
  size_t JfrStorage::write() {
<span class="line-modified">!   const size_t full_elements = write_full();</span>
    WriteOperation wo(_chunkwriter);
<span class="line-modified">!   NonRetired nr;</span>
<span class="line-added">+   NonExcluded ne;</span>
<span class="line-added">+   BufferPredicate bp(&amp;nr, &amp;ne);</span>
<span class="line-added">+   ThreadLocalConcurrentWriteOperation tlwo(wo, bp);</span>
    process_full_list(tlwo, _thread_local_mspace);
    ConcurrentWriteOperation cwo(wo);
    process_free_list(cwo, _global_mspace);
<span class="line-modified">!   return full_elements + wo.elements();</span>
  }
  
  size_t JfrStorage::write_at_safepoint() {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
    WriteOperation wo(_chunkwriter);
    MutexedWriteOperation writer(wo); // mutexed write mode
<span class="line-modified">!   NonRetired nr;</span>
<span class="line-added">+   NonExcluded ne;</span>
<span class="line-added">+   BufferPredicate bp(&amp;nr, &amp;ne);</span>
<span class="line-added">+   ThreadLocalMutexedWriteOperation tlmwo(wo, bp);</span>
<span class="line-added">+   process_full_list(tlmwo, _thread_local_mspace);</span>
    assert(_transient_mspace-&gt;is_free_empty(), &quot;invariant&quot;);
    process_full_list(writer, _transient_mspace);
    assert(_global_mspace-&gt;is_full_empty(), &quot;invariant&quot;);
    process_free_list(writer, _global_mspace);
<span class="line-modified">!   return wo.elements();</span>
  }
  
  typedef DiscardOp&lt;DefaultDiscarder&lt;JfrStorage::Buffer&gt; &gt; DiscardOperation;
  typedef ReleaseOp&lt;JfrStorageMspace&gt; ReleaseOperation;
  typedef CompositeOperation&lt;MutexedWriteOperation, ReleaseOperation&gt; FullOperation;
  
  size_t JfrStorage::clear() {
<span class="line-modified">!   const size_t full_elements = clear_full();</span>
    DiscardOperation discarder(concurrent); // concurrent discard mode
    process_full_list(discarder, _thread_local_mspace);
    assert(_transient_mspace-&gt;is_free_empty(), &quot;invariant&quot;);
    process_full_list(discarder, _transient_mspace);
    assert(_global_mspace-&gt;is_full_empty(), &quot;invariant&quot;);
    process_free_list(discarder, _global_mspace);
<span class="line-modified">!   return full_elements + discarder.elements();</span>
  }
  
  static void insert_free_age_nodes(JfrStorageAgeMspace* age_mspace, JfrAgeNode* head, JfrAgeNode* tail, size_t count) {
    if (tail != NULL) {
      assert(tail-&gt;next() == NULL, &quot;invariant&quot;);
      assert(head != NULL, &quot;invariant&quot;);
      assert(head-&gt;prev() == NULL, &quot;invariant&quot;);
<span class="line-modified">!     MutexLocker buffer_lock(JfrBuffer_lock, Mutex::_no_safepoint_check_flag);</span>
      age_mspace-&gt;insert_free_tail(head, tail, count);
    }
  }
  
  template &lt;typename Processor&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 635,16 ***</span>
    assert(count &gt; 0, &quot;invariant&quot;);
    JfrAgeNode* node = head;
    JfrAgeNode* last = NULL;
    while (node != NULL) {
      last = node;
      BufferPtr const buffer = node-&gt;retired_buffer();
      assert(buffer != NULL, &quot;invariant&quot;);
      assert(buffer-&gt;retired(), &quot;invariant&quot;);
      processor.process(buffer);
      // at this point, buffer is already live or destroyed
<span class="line-removed">-     node-&gt;clear_identity();</span>
      JfrAgeNode* const next = (JfrAgeNode*)node-&gt;next();
      if (node-&gt;transient()) {
        // detach
        last = (JfrAgeNode*)last-&gt;prev();
        if (last != NULL) {
<span class="line-new-header">--- 668,16 ---</span>
    assert(count &gt; 0, &quot;invariant&quot;);
    JfrAgeNode* node = head;
    JfrAgeNode* last = NULL;
    while (node != NULL) {
      last = node;
<span class="line-added">+     assert(node-&gt;identity() == NULL, &quot;invariant&quot;);</span>
      BufferPtr const buffer = node-&gt;retired_buffer();
      assert(buffer != NULL, &quot;invariant&quot;);
      assert(buffer-&gt;retired(), &quot;invariant&quot;);
      processor.process(buffer);
      // at this point, buffer is already live or destroyed
      JfrAgeNode* const next = (JfrAgeNode*)node-&gt;next();
      if (node-&gt;transient()) {
        // detach
        last = (JfrAgeNode*)last-&gt;prev();
        if (last != NULL) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 672,11 ***</span>
    }
    size_t count;
    JfrAgeNode* head;
    {
      // fetch age list
<span class="line-modified">!     MutexLockerEx buffer_lock(JfrBuffer_lock, Mutex::_no_safepoint_check_flag);</span>
      count = age_mspace-&gt;full_count();
      head = age_mspace-&gt;clear_full();
      control.reset_full();
    }
    assert(head != NULL, &quot;invariant&quot;);
<span class="line-new-header">--- 705,11 ---</span>
    }
    size_t count;
    JfrAgeNode* head;
    {
      // fetch age list
<span class="line-modified">!     MutexLocker buffer_lock(JfrBuffer_lock, Mutex::_no_safepoint_check_flag);</span>
      count = age_mspace-&gt;full_count();
      head = age_mspace-&gt;clear_full();
      control.reset_full();
    }
    assert(head != NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 704,19 ***</span>
    WriteOperation wo(_chunkwriter);
    MutexedWriteOperation writer(wo); // a retired buffer implies mutexed access
    ReleaseOperation ro(_transient_mspace, thread);
    FullOperation cmd(&amp;writer, &amp;ro);
    const size_t count = process_full(cmd, control(), _age_mspace);
<span class="line-modified">!   log(count, writer.processed());</span>
<span class="line-modified">!   return writer.processed();</span>
  }
  
  size_t JfrStorage::clear_full() {
    DiscardOperation discarder(mutexed); // a retired buffer implies mutexed access
    const size_t count = process_full(discarder, control(), _age_mspace);
<span class="line-modified">!   log(count, discarder.processed(), true);</span>
<span class="line-modified">!   return discarder.processed();</span>
  }
  
  static void scavenge_log(size_t count, size_t amount, size_t current) {
    if (count &gt; 0) {
      if (log_is_enabled(Debug, jfr, system)) {
<span class="line-new-header">--- 737,29 ---</span>
    WriteOperation wo(_chunkwriter);
    MutexedWriteOperation writer(wo); // a retired buffer implies mutexed access
    ReleaseOperation ro(_transient_mspace, thread);
    FullOperation cmd(&amp;writer, &amp;ro);
    const size_t count = process_full(cmd, control(), _age_mspace);
<span class="line-modified">!   if (0 == count) {</span>
<span class="line-modified">!     assert(0 == writer.elements(), &quot;invariant&quot;);</span>
<span class="line-added">+     return 0;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   const size_t size = writer.size();</span>
<span class="line-added">+   log(count, size);</span>
<span class="line-added">+   return count;</span>
  }
  
  size_t JfrStorage::clear_full() {
    DiscardOperation discarder(mutexed); // a retired buffer implies mutexed access
    const size_t count = process_full(discarder, control(), _age_mspace);
<span class="line-modified">!   if (0 == count) {</span>
<span class="line-modified">!     assert(0 == discarder.elements(), &quot;invariant&quot;);</span>
<span class="line-added">+     return 0;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   const size_t size = discarder.size();</span>
<span class="line-added">+   log(count, size, true);</span>
<span class="line-added">+   return count;</span>
  }
  
  static void scavenge_log(size_t count, size_t amount, size_t current) {
    if (count &gt; 0) {
      if (log_is_enabled(Debug, jfr, system)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 736,17 ***</span>
  public:
    typedef typename Mspace::Type Type;
    Scavenger(JfrStorageControl&amp; control, Mspace* mspace) : _control(control), _mspace(mspace), _count(0), _amount(0) {}
    bool process(Type* t) {
      if (t-&gt;retired()) {
        assert(!t-&gt;transient(), &quot;invariant&quot;);
        assert(!t-&gt;lease(), &quot;invariant&quot;);
<span class="line-removed">-       assert(t-&gt;empty(), &quot;invariant&quot;);</span>
<span class="line-removed">-       assert(t-&gt;identity() == NULL, &quot;invariant&quot;);</span>
        ++_count;
        _amount += t-&gt;total_size();
        t-&gt;clear_retired();
        _control.decrement_dead();
        mspace_release_full_critical(t, _mspace);
      }
      return true;
    }
<span class="line-new-header">--- 779,22 ---</span>
  public:
    typedef typename Mspace::Type Type;
    Scavenger(JfrStorageControl&amp; control, Mspace* mspace) : _control(control), _mspace(mspace), _count(0), _amount(0) {}
    bool process(Type* t) {
      if (t-&gt;retired()) {
<span class="line-added">+       assert(t-&gt;identity() != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+       assert(t-&gt;empty(), &quot;invariant&quot;);</span>
        assert(!t-&gt;transient(), &quot;invariant&quot;);
        assert(!t-&gt;lease(), &quot;invariant&quot;);
        ++_count;
        _amount += t-&gt;total_size();
<span class="line-added">+       if (t-&gt;excluded()) {</span>
<span class="line-added">+         t-&gt;clear_excluded();</span>
<span class="line-added">+       }</span>
<span class="line-added">+       assert(!t-&gt;excluded(), &quot;invariant&quot;);</span>
        t-&gt;clear_retired();
<span class="line-added">+       t-&gt;release();</span>
        _control.decrement_dead();
        mspace_release_full_critical(t, _mspace);
      }
      return true;
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 759,8 ***</span>
    if (ctrl.dead_count() == 0) {
      return 0;
    }
    Scavenger&lt;JfrThreadLocalMspace&gt; scavenger(ctrl, _thread_local_mspace);
    process_full_list(scavenger, _thread_local_mspace);
<span class="line-modified">!   scavenge_log(scavenger.processed(), scavenger.amount(), ctrl.dead_count());</span>
<span class="line-modified">!   return scavenger.processed();</span>
  }
<span class="line-new-header">--- 807,13 ---</span>
    if (ctrl.dead_count() == 0) {
      return 0;
    }
    Scavenger&lt;JfrThreadLocalMspace&gt; scavenger(ctrl, _thread_local_mspace);
    process_full_list(scavenger, _thread_local_mspace);
<span class="line-modified">!   const size_t count = scavenger.processed();</span>
<span class="line-modified">!   if (0 == count) {</span>
<span class="line-added">+     assert(0 == scavenger.amount(), &quot;invariant&quot;);</span>
<span class="line-added">+     return 0;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   scavenge_log(count, scavenger.amount(), ctrl.dead_count());</span>
<span class="line-added">+   return count;</span>
  }
</pre>
<center><a href="jfrMemorySpace.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrStorage.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
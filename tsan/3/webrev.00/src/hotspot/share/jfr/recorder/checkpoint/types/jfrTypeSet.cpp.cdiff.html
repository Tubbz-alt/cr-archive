<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeSet.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="jfrTypeManager.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="jfrTypeSet.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeSet.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 26,619 ***</span>
  #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  #include &quot;classfile/javaClasses.inline.hpp&quot;
  #include &quot;classfile/moduleEntry.hpp&quot;
  #include &quot;classfile/packageEntry.hpp&quot;
  #include &quot;classfile/symbolTable.hpp&quot;
<span class="line-removed">- #include &quot;classfile/systemDictionary.hpp&quot;</span>
  #include &quot;jfr/jfr.hpp&quot;
  #include &quot;jfr/jni/jfrGetAllEventClasses.hpp&quot;
<span class="line-modified">! #include &quot;jfr/recorder/checkpoint/jfrCheckpointWriter.hpp&quot;</span>
  #include &quot;jfr/recorder/checkpoint/types/jfrTypeSet.hpp&quot;
  #include &quot;jfr/recorder/checkpoint/types/jfrTypeSetUtils.hpp&quot;
<span class="line-removed">- #include &quot;jfr/recorder/checkpoint/types/jfrTypeSetWriter.hpp&quot;</span>
  #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceId.inline.hpp&quot;
<span class="line-removed">- #include &quot;jfr/recorder/storage/jfrBuffer.hpp&quot;</span>
  #include &quot;jfr/utilities/jfrHashtable.hpp&quot;
  #include &quot;jfr/utilities/jfrTypes.hpp&quot;
  #include &quot;memory/iterator.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;oops/instanceKlass.hpp&quot;
  #include &quot;oops/objArrayKlass.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
<span class="line-removed">- #include &quot;memory/resourceArea.hpp&quot;</span>
  #include &quot;utilities/accessFlags.hpp&quot;
<span class="line-modified">! </span>
<span class="line-removed">- // incremented on each checkpoint</span>
<span class="line-removed">- static u8 checkpoint_id = 0;</span>
<span class="line-removed">- </span>
<span class="line-removed">- // creates a unique id by combining a checkpoint relative symbol id (2^24)</span>
<span class="line-removed">- // with the current checkpoint id (2^40)</span>
<span class="line-removed">- #define CREATE_SYMBOL_ID(sym_id) (((u8)((checkpoint_id &lt;&lt; 24) | sym_id)))</span>
  
  typedef const Klass* KlassPtr;
  typedef const PackageEntry* PkgPtr;
  typedef const ModuleEntry* ModPtr;
  typedef const ClassLoaderData* CldPtr;
  typedef const Method* MethodPtr;
  typedef const Symbol* SymbolPtr;
  typedef const JfrSymbolId::SymbolEntry* SymbolEntryPtr;
  typedef const JfrSymbolId::CStringEntry* CStringEntryPtr;
  
<span class="line-modified">! static traceid module_id(PkgPtr pkg) {</span>
<span class="line-modified">!   assert(pkg != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   ModPtr module_entry = pkg-&gt;module();</span>
<span class="line-modified">!   return module_entry != NULL &amp;&amp; module_entry-&gt;is_named() ? TRACE_ID(module_entry) : 0;</span>
  }
  
<span class="line-modified">! static traceid package_id(KlassPtr klass) {</span>
<span class="line-modified">!   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   PkgPtr pkg_entry = klass-&gt;package();</span>
<span class="line-removed">-   return pkg_entry == NULL ? 0 : TRACE_ID(pkg_entry);</span>
  }
  
<span class="line-modified">! static traceid cld_id(CldPtr cld) {</span>
<span class="line-modified">!   assert(cld != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   return cld-&gt;is_unsafe_anonymous() ? 0 : TRACE_ID(cld);</span>
  }
  
<span class="line-modified">! static void tag_leakp_klass_artifacts(KlassPtr k, bool class_unload) {</span>
<span class="line-modified">!   assert(k != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   PkgPtr pkg = k-&gt;package();</span>
<span class="line-removed">-   if (pkg != NULL) {</span>
<span class="line-removed">-     tag_leakp_artifact(pkg, class_unload);</span>
<span class="line-removed">-     ModPtr module = pkg-&gt;module();</span>
<span class="line-removed">-     if (module != NULL) {</span>
<span class="line-removed">-       tag_leakp_artifact(module, class_unload);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   CldPtr cld = k-&gt;class_loader_data();</span>
<span class="line-removed">-   assert(cld != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   if (!cld-&gt;is_unsafe_anonymous()) {</span>
<span class="line-removed">-     tag_leakp_artifact(cld, class_unload);</span>
<span class="line-removed">-   }</span>
  }
  
<span class="line-modified">! class TagLeakpKlassArtifact {</span>
<span class="line-modified">!   bool _class_unload;</span>
<span class="line-modified">!  public:</span>
<span class="line-removed">-   TagLeakpKlassArtifact(bool class_unload) : _class_unload(class_unload) {}</span>
<span class="line-removed">-   bool operator()(KlassPtr klass) {</span>
<span class="line-removed">-     if (_class_unload) {</span>
<span class="line-removed">-       if (LEAKP_USED_THIS_EPOCH(klass)) {</span>
<span class="line-removed">-         tag_leakp_klass_artifacts(klass, _class_unload);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       if (LEAKP_USED_PREV_EPOCH(klass)) {</span>
<span class="line-removed">-         tag_leakp_klass_artifacts(klass, _class_unload);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return true;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- };</span>
  
<span class="line-modified">! /*</span>
<span class="line-modified">!  * In C++03, functions used as template parameters must have external linkage;</span>
<span class="line-modified">!  * this restriction was removed in C++11. Change back to &quot;static&quot; and</span>
<span class="line-removed">-  * rename functions when C++11 becomes available.</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * The weird naming is an effort to decrease the risk of name clashes.</span>
<span class="line-removed">-  */</span>
  
<span class="line-modified">! int write__artifact__klass(JfrCheckpointWriter* writer, JfrArtifactSet* artifacts, const void* k) {</span>
<span class="line-modified">!   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   assert(artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   assert(k != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   KlassPtr klass = (KlassPtr)k;</span>
<span class="line-removed">-   traceid pkg_id = 0;</span>
<span class="line-removed">-   KlassPtr theklass = klass;</span>
<span class="line-removed">-   if (theklass-&gt;is_objArray_klass()) {</span>
<span class="line-removed">-     const ObjArrayKlass* obj_arr_klass = ObjArrayKlass::cast(klass);</span>
<span class="line-removed">-     theklass = obj_arr_klass-&gt;bottom_klass();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (theklass-&gt;is_instance_klass()) {</span>
<span class="line-removed">-     pkg_id = package_id(theklass);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     assert(theklass-&gt;is_typeArray_klass(), &quot;invariant&quot;);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   const traceid symbol_id = artifacts-&gt;mark(klass);</span>
<span class="line-removed">-   assert(symbol_id &gt; 0, &quot;need to have an address for symbol!&quot;);</span>
<span class="line-removed">-   writer-&gt;write(TRACE_ID(klass));</span>
<span class="line-removed">-   writer-&gt;write(cld_id(klass-&gt;class_loader_data()));</span>
<span class="line-removed">-   writer-&gt;write((traceid)CREATE_SYMBOL_ID(symbol_id));</span>
<span class="line-removed">-   writer-&gt;write(pkg_id);</span>
<span class="line-removed">-   writer-&gt;write((s4)klass-&gt;access_flags().get_flags());</span>
<span class="line-removed">-   return 1;</span>
  }
  
<span class="line-modified">! typedef LeakPredicate&lt;KlassPtr&gt; LeakKlassPredicate;</span>
<span class="line-modified">! typedef JfrPredicatedArtifactWriterImplHost&lt;KlassPtr, LeakKlassPredicate, write__artifact__klass&gt; LeakKlassWriterImpl;</span>
<span class="line-modified">! typedef JfrArtifactWriterHost&lt;LeakKlassWriterImpl, TYPE_CLASS&gt; LeakKlassWriter;</span>
<span class="line-modified">! typedef JfrArtifactWriterImplHost&lt;KlassPtr, write__artifact__klass&gt; KlassWriterImpl;</span>
<span class="line-modified">! typedef JfrArtifactWriterHost&lt;KlassWriterImpl, TYPE_CLASS&gt; KlassWriter;</span>
  
<span class="line-modified">! int write__artifact__method(JfrCheckpointWriter* writer, JfrArtifactSet* artifacts, const void* m) {</span>
<span class="line-removed">-   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   assert(artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   assert(m != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   MethodPtr method = (MethodPtr)m;</span>
<span class="line-removed">-   const traceid method_name_symbol_id = artifacts-&gt;mark(method-&gt;name());</span>
<span class="line-removed">-   assert(method_name_symbol_id &gt; 0, &quot;invariant&quot;);</span>
<span class="line-removed">-   const traceid method_sig_symbol_id = artifacts-&gt;mark(method-&gt;signature());</span>
<span class="line-removed">-   assert(method_sig_symbol_id &gt; 0, &quot;invariant&quot;);</span>
<span class="line-removed">-   KlassPtr klass = method-&gt;method_holder();</span>
    assert(klass != NULL, &quot;invariant&quot;);
<span class="line-modified">!   assert(METHOD_USED_ANY_EPOCH(klass), &quot;invariant&quot;);</span>
<span class="line-modified">!   writer-&gt;write((u8)METHOD_ID(klass, method));</span>
<span class="line-modified">!   writer-&gt;write((u8)TRACE_ID(klass));</span>
<span class="line-modified">!   writer-&gt;write((u8)CREATE_SYMBOL_ID(method_name_symbol_id));</span>
<span class="line-modified">!   writer-&gt;write((u8)CREATE_SYMBOL_ID(method_sig_symbol_id));</span>
<span class="line-modified">!   writer-&gt;write((u2)method-&gt;access_flags().get_flags());</span>
<span class="line-modified">!   writer-&gt;write(const_cast&lt;Method*&gt;(method)-&gt;is_hidden() ? (u1)1 : (u1)0);</span>
<span class="line-modified">!   return 1;</span>
  }
  
<span class="line-modified">! typedef JfrArtifactWriterImplHost&lt;MethodPtr, write__artifact__method&gt; MethodWriterImplTarget;</span>
<span class="line-modified">! typedef JfrArtifactWriterHost&lt;MethodWriterImplTarget, TYPE_METHOD&gt; MethodWriterImpl;</span>
<span class="line-modified">! </span>
<span class="line-modified">! int write__artifact__package(JfrCheckpointWriter* writer, JfrArtifactSet* artifacts, const void* p) {</span>
<span class="line-modified">!   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(p != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   PkgPtr pkg = (PkgPtr)p;</span>
<span class="line-modified">!   Symbol* const pkg_name = pkg-&gt;name();</span>
<span class="line-modified">!   const traceid package_name_symbol_id = pkg_name != NULL ? artifacts-&gt;mark(pkg_name) : 0;</span>
<span class="line-modified">!   assert(package_name_symbol_id &gt; 0, &quot;invariant&quot;);</span>
<span class="line-modified">!   writer-&gt;write((traceid)TRACE_ID(pkg));</span>
<span class="line-removed">-   writer-&gt;write((traceid)CREATE_SYMBOL_ID(package_name_symbol_id));</span>
<span class="line-removed">-   writer-&gt;write(module_id(pkg));</span>
<span class="line-removed">-   writer-&gt;write((bool)pkg-&gt;is_exported());</span>
<span class="line-removed">-   return 1;</span>
  }
  
<span class="line-modified">! typedef LeakPredicate&lt;PkgPtr&gt; LeakPackagePredicate;</span>
<span class="line-modified">! int _compare_pkg_ptr_(PkgPtr const&amp; lhs, PkgPtr const&amp; rhs) { return lhs &gt; rhs ? 1 : (lhs &lt; rhs) ? -1 : 0; }</span>
<span class="line-modified">! typedef UniquePredicate&lt;PkgPtr, _compare_pkg_ptr_&gt; PackagePredicate;</span>
<span class="line-modified">! typedef JfrPredicatedArtifactWriterImplHost&lt;PkgPtr, LeakPackagePredicate, write__artifact__package&gt; LeakPackageWriterImpl;</span>
<span class="line-removed">- typedef JfrPredicatedArtifactWriterImplHost&lt;PkgPtr, PackagePredicate, write__artifact__package&gt; PackageWriterImpl;</span>
<span class="line-removed">- typedef JfrArtifactWriterHost&lt;LeakPackageWriterImpl, TYPE_PACKAGE&gt; LeakPackageWriter;</span>
<span class="line-removed">- typedef JfrArtifactWriterHost&lt;PackageWriterImpl, TYPE_PACKAGE&gt; PackageWriter;</span>
<span class="line-removed">- </span>
<span class="line-removed">- int write__artifact__module(JfrCheckpointWriter* writer, JfrArtifactSet* artifacts, const void* m) {</span>
<span class="line-removed">-   assert( m != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   ModPtr entry = (ModPtr)m;</span>
<span class="line-removed">-   Symbol* const module_name = entry-&gt;name();</span>
<span class="line-removed">-   const traceid module_name_symbol_id = module_name != NULL ? artifacts-&gt;mark(module_name) : 0;</span>
<span class="line-removed">-   Symbol* const module_version = entry-&gt;version();</span>
<span class="line-removed">-   const traceid module_version_symbol_id = module_version != NULL ? artifacts-&gt;mark(module_version) : 0;</span>
<span class="line-removed">-   Symbol* const module_location = entry-&gt;location();</span>
<span class="line-removed">-   const traceid module_location_symbol_id = module_location != NULL ? artifacts-&gt;mark(module_location) : 0;</span>
<span class="line-removed">-   writer-&gt;write((traceid)TRACE_ID(entry));</span>
<span class="line-removed">-   writer-&gt;write(module_name_symbol_id == 0 ? (traceid)0 : (traceid)CREATE_SYMBOL_ID(module_name_symbol_id));</span>
<span class="line-removed">-   writer-&gt;write(module_version_symbol_id == 0 ? (traceid)0 : (traceid)CREATE_SYMBOL_ID(module_version_symbol_id));</span>
<span class="line-removed">-   writer-&gt;write(module_location_symbol_id == 0 ? (traceid)0 : (traceid)CREATE_SYMBOL_ID(module_location_symbol_id));</span>
<span class="line-removed">-   writer-&gt;write(cld_id(entry-&gt;loader_data()));</span>
<span class="line-removed">-   return 1;</span>
  }
  
<span class="line-modified">! typedef LeakPredicate&lt;ModPtr&gt; LeakModulePredicate;</span>
<span class="line-modified">! int _compare_mod_ptr_(ModPtr const&amp; lhs, ModPtr const&amp; rhs) { return lhs &gt; rhs ? 1 : (lhs &lt; rhs) ? -1 : 0; }</span>
<span class="line-removed">- typedef UniquePredicate&lt;ModPtr, _compare_mod_ptr_&gt; ModulePredicate;</span>
<span class="line-removed">- typedef JfrPredicatedArtifactWriterImplHost&lt;ModPtr, LeakModulePredicate, write__artifact__module&gt; LeakModuleWriterImpl;</span>
<span class="line-removed">- typedef JfrPredicatedArtifactWriterImplHost&lt;ModPtr, ModulePredicate, write__artifact__module&gt; ModuleWriterImpl;</span>
<span class="line-removed">- typedef JfrArtifactWriterHost&lt;LeakModuleWriterImpl, TYPE_MODULE&gt; LeakModuleWriter;</span>
<span class="line-removed">- typedef JfrArtifactWriterHost&lt;ModuleWriterImpl, TYPE_MODULE&gt; ModuleWriter;</span>
<span class="line-removed">- </span>
<span class="line-removed">- int write__artifact__classloader(JfrCheckpointWriter* writer, JfrArtifactSet* artifacts, const void* c) {</span>
<span class="line-removed">-   assert(c != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   CldPtr cld = (CldPtr)c;</span>
    assert(!cld-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);
<span class="line-modified">!   const traceid cld_id = TRACE_ID(cld);</span>
<span class="line-modified">!   // class loader type</span>
<span class="line-removed">-   const Klass* class_loader_klass = cld-&gt;class_loader_klass();</span>
<span class="line-removed">-   if (class_loader_klass == NULL) {</span>
<span class="line-removed">-     // (primordial) boot class loader</span>
<span class="line-removed">-     writer-&gt;write(cld_id); // class loader instance id</span>
<span class="line-removed">-     writer-&gt;write((traceid)0);  // class loader type id (absence of)</span>
<span class="line-removed">-     writer-&gt;write((traceid)CREATE_SYMBOL_ID(1)); // 1 maps to synthetic name -&gt; &quot;bootstrap&quot;</span>
    } else {
<span class="line-modified">!     Symbol* symbol_name = cld-&gt;name();</span>
<span class="line-removed">-     const traceid symbol_name_id = symbol_name != NULL ? artifacts-&gt;mark(symbol_name) : 0;</span>
<span class="line-removed">-     writer-&gt;write(cld_id); // class loader instance id</span>
<span class="line-removed">-     writer-&gt;write(TRACE_ID(class_loader_klass)); // class loader type id</span>
<span class="line-removed">-     writer-&gt;write(symbol_name_id == 0 ? (traceid)0 :</span>
<span class="line-removed">-       (traceid)CREATE_SYMBOL_ID(symbol_name_id)); // class loader instance name</span>
    }
<span class="line-modified">!   return 1;</span>
  }
  
<span class="line-modified">! typedef LeakPredicate&lt;CldPtr&gt; LeakCldPredicate;</span>
<span class="line-modified">! int _compare_cld_ptr_(CldPtr const&amp; lhs, CldPtr const&amp; rhs) { return lhs &gt; rhs ? 1 : (lhs &lt; rhs) ? -1 : 0; }</span>
<span class="line-modified">! typedef UniquePredicate&lt;CldPtr, _compare_cld_ptr_&gt; CldPredicate;</span>
<span class="line-modified">! typedef JfrPredicatedArtifactWriterImplHost&lt;CldPtr, LeakCldPredicate, write__artifact__classloader&gt; LeakCldWriterImpl;</span>
<span class="line-modified">! typedef JfrPredicatedArtifactWriterImplHost&lt;CldPtr, CldPredicate, write__artifact__classloader&gt; CldWriterImpl;</span>
<span class="line-removed">- typedef JfrArtifactWriterHost&lt;LeakCldWriterImpl, TYPE_CLASSLOADER&gt; LeakCldWriter;</span>
<span class="line-removed">- typedef JfrArtifactWriterHost&lt;CldWriterImpl, TYPE_CLASSLOADER&gt; CldWriter;</span>
<span class="line-removed">- </span>
<span class="line-removed">- typedef const JfrSymbolId::SymbolEntry* SymbolEntryPtr;</span>
  
<span class="line-modified">! static int write__artifact__symbol__entry__(JfrCheckpointWriter* writer,</span>
<span class="line-modified">!                                             SymbolEntryPtr entry) {</span>
<span class="line-modified">!   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   ResourceMark rm;</span>
<span class="line-removed">-   writer-&gt;write(CREATE_SYMBOL_ID(entry-&gt;id()));</span>
<span class="line-removed">-   writer-&gt;write(entry-&gt;value()-&gt;as_C_string());</span>
<span class="line-removed">-   return 1;</span>
  }
  
<span class="line-modified">! int write__artifact__symbol__entry(JfrCheckpointWriter* writer, JfrArtifactSet* artifacts, const void* e) {</span>
<span class="line-modified">!   assert(e != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   return write__artifact__symbol__entry__(writer, (SymbolEntryPtr)e);</span>
  }
  
<span class="line-modified">! typedef JfrArtifactWriterImplHost&lt;SymbolEntryPtr, write__artifact__symbol__entry&gt; SymbolEntryWriterImpl;</span>
<span class="line-modified">! typedef JfrArtifactWriterHost&lt;SymbolEntryWriterImpl, TYPE_SYMBOL&gt; SymbolEntryWriter;</span>
  
<span class="line-modified">! typedef const JfrSymbolId::CStringEntry* CStringEntryPtr;</span>
  
<span class="line-modified">! static int write__artifact__cstring__entry__(JfrCheckpointWriter* writer, CStringEntryPtr entry) {</span>
    assert(writer != NULL, &quot;invariant&quot;);
<span class="line-modified">!   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   writer-&gt;write(CREATE_SYMBOL_ID(entry-&gt;id()));</span>
<span class="line-modified">!   writer-&gt;write(entry-&gt;value());</span>
    return 1;
  }
  
<span class="line-modified">! int write__artifact__cstring__entry(JfrCheckpointWriter* writer, JfrArtifactSet* artifacts, const void* e) {</span>
<span class="line-modified">!   assert(e != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   return write__artifact__cstring__entry__(writer, (CStringEntryPtr)e);</span>
  }
  
<span class="line-modified">! typedef JfrArtifactWriterImplHost&lt;CStringEntryPtr, write__artifact__cstring__entry&gt; CStringEntryWriterImpl;</span>
<span class="line-removed">- typedef JfrArtifactWriterHost&lt;CStringEntryWriterImpl, TYPE_SYMBOL&gt; CStringEntryWriter;</span>
<span class="line-removed">- </span>
<span class="line-removed">- int write__artifact__klass__symbol(JfrCheckpointWriter* writer, JfrArtifactSet* artifacts, const void* k) {</span>
<span class="line-removed">-   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   assert(artifacts != NULL, &quot;invaiant&quot;);</span>
    assert(k != NULL, &quot;invariant&quot;);
<span class="line-modified">!   const InstanceKlass* const ik = (const InstanceKlass*)k;</span>
<span class="line-modified">!   if (ik-&gt;is_unsafe_anonymous()) {</span>
<span class="line-removed">-     CStringEntryPtr entry =</span>
<span class="line-removed">-       artifacts-&gt;map_cstring(JfrSymbolId::unsafe_anonymous_klass_name_hash_code(ik));</span>
<span class="line-removed">-     assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-     return write__artifact__cstring__entry__(writer, entry);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   SymbolEntryPtr entry = artifacts-&gt;map_symbol(JfrSymbolId::regular_klass_name_hash_code(ik));</span>
<span class="line-removed">-   return write__artifact__symbol__entry__(writer, entry);</span>
  }
  
<span class="line-modified">! int _compare_traceid_(const traceid&amp; lhs, const traceid&amp; rhs) {</span>
<span class="line-modified">!   return lhs &gt; rhs ? 1 : (lhs &lt; rhs) ? -1 : 0;</span>
  }
  
<span class="line-modified">! template &lt;template &lt;typename&gt; class Predicate&gt;</span>
<span class="line-modified">! class KlassSymbolWriterImpl {</span>
<span class="line-modified">!  private:</span>
<span class="line-modified">!   JfrCheckpointWriter* _writer;</span>
<span class="line-modified">!   JfrArtifactSet* _artifacts;</span>
<span class="line-removed">-   Predicate&lt;KlassPtr&gt; _predicate;</span>
<span class="line-removed">-   MethodUsedPredicate&lt;true&gt; _method_used_predicate;</span>
<span class="line-removed">-   MethodFlagPredicate _method_flag_predicate;</span>
<span class="line-removed">-   UniquePredicate&lt;traceid, _compare_traceid_&gt; _unique_predicate;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   int klass_symbols(KlassPtr klass);</span>
<span class="line-removed">-   int package_symbols(PkgPtr pkg);</span>
<span class="line-removed">-   int module_symbols(ModPtr module);</span>
<span class="line-removed">-   int class_loader_symbols(CldPtr cld);</span>
<span class="line-removed">-   int method_symbols(KlassPtr klass);</span>
<span class="line-removed">- </span>
<span class="line-removed">-  public:</span>
<span class="line-removed">-   typedef KlassPtr Type;</span>
<span class="line-removed">-   KlassSymbolWriterImpl(JfrCheckpointWriter* writer,</span>
<span class="line-removed">-                         JfrArtifactSet* artifacts,</span>
<span class="line-removed">-                         bool class_unload) : _writer(writer),</span>
<span class="line-removed">-                                              _artifacts(artifacts),</span>
<span class="line-removed">-                                              _predicate(class_unload),</span>
<span class="line-removed">-                                              _method_used_predicate(class_unload),</span>
<span class="line-removed">-                                              _method_flag_predicate(class_unload),</span>
<span class="line-removed">-                                              _unique_predicate(class_unload) {}</span>
<span class="line-removed">- </span>
<span class="line-removed">-   int operator()(KlassPtr klass) {</span>
<span class="line-removed">-     assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-     int count = 0;</span>
<span class="line-removed">-     if (_predicate(klass)) {</span>
<span class="line-removed">-       count += klass_symbols(klass);</span>
<span class="line-removed">-       PkgPtr pkg = klass-&gt;package();</span>
<span class="line-removed">-       if (pkg != NULL) {</span>
<span class="line-removed">-         count += package_symbols(pkg);</span>
<span class="line-removed">-         ModPtr module = pkg-&gt;module();</span>
<span class="line-removed">-         if (module != NULL &amp;&amp; module-&gt;is_named()) {</span>
<span class="line-removed">-           count += module_symbols(module);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       CldPtr cld = klass-&gt;class_loader_data();</span>
<span class="line-removed">-       assert(cld != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-       if (!cld-&gt;is_unsafe_anonymous()) {</span>
<span class="line-removed">-         count += class_loader_symbols(cld);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       if (_method_used_predicate(klass)) {</span>
<span class="line-removed">-         count += method_symbols(klass);</span>
<span class="line-removed">-       }</span>
      }
<span class="line-modified">!     return count;</span>
    }
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- template &lt;template &lt;typename&gt; class Predicate&gt;</span>
<span class="line-removed">- int KlassSymbolWriterImpl&lt;Predicate&gt;::klass_symbols(KlassPtr klass) {</span>
<span class="line-removed">-   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   assert(_predicate(klass), &quot;invariant&quot;);</span>
<span class="line-removed">-   const InstanceKlass* const ik = (const InstanceKlass*)klass;</span>
<span class="line-removed">-   if (ik-&gt;is_unsafe_anonymous()) {</span>
<span class="line-removed">-     CStringEntryPtr entry =</span>
<span class="line-removed">-       this-&gt;_artifacts-&gt;map_cstring(JfrSymbolId::unsafe_anonymous_klass_name_hash_code(ik));</span>
<span class="line-removed">-     assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-     return _unique_predicate(entry-&gt;id()) ? write__artifact__cstring__entry__(this-&gt;_writer, entry) : 0;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   SymbolEntryPtr entry = this-&gt;_artifacts-&gt;map_symbol(ik-&gt;name());</span>
<span class="line-removed">-   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   return _unique_predicate(entry-&gt;id()) ? write__artifact__symbol__entry__(this-&gt;_writer, entry) : 0;</span>
  }
  
<span class="line-modified">! template &lt;template &lt;typename&gt; class Predicate&gt;</span>
<span class="line-modified">! int KlassSymbolWriterImpl&lt;Predicate&gt;::package_symbols(PkgPtr pkg) {</span>
<span class="line-modified">!   assert(pkg != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   SymbolPtr pkg_name = pkg-&gt;name();</span>
<span class="line-modified">!   assert(pkg_name != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   SymbolEntryPtr package_symbol = this-&gt;_artifacts-&gt;map_symbol(pkg_name);</span>
<span class="line-removed">-   assert(package_symbol != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   return _unique_predicate(package_symbol-&gt;id()) ?</span>
<span class="line-removed">-     write__artifact__symbol__entry__(this-&gt;_writer, package_symbol) : 0;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- template &lt;template &lt;typename&gt; class Predicate&gt;</span>
<span class="line-removed">- int KlassSymbolWriterImpl&lt;Predicate&gt;::module_symbols(ModPtr module) {</span>
<span class="line-removed">-   assert(module != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   assert(module-&gt;is_named(), &quot;invariant&quot;);</span>
<span class="line-removed">-   int count = 0;</span>
<span class="line-removed">-   SymbolPtr sym = module-&gt;name();</span>
<span class="line-removed">-   SymbolEntryPtr entry = NULL;</span>
<span class="line-removed">-   if (sym != NULL) {</span>
<span class="line-removed">-     entry = this-&gt;_artifacts-&gt;map_symbol(sym);</span>
<span class="line-removed">-     assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-     if (_unique_predicate(entry-&gt;id())) {</span>
<span class="line-removed">-       count += write__artifact__symbol__entry__(this-&gt;_writer, entry);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   sym = module-&gt;version();</span>
<span class="line-removed">-   if (sym != NULL) {</span>
<span class="line-removed">-     entry = this-&gt;_artifacts-&gt;map_symbol(sym);</span>
<span class="line-removed">-     assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-     if (_unique_predicate(entry-&gt;id())) {</span>
<span class="line-removed">-       count += write__artifact__symbol__entry__(this-&gt;_writer, entry);</span>
<span class="line-removed">-     }</span>
    }
<span class="line-modified">!   sym = module-&gt;location();</span>
<span class="line-modified">!   if (sym != NULL) {</span>
<span class="line-modified">!     entry = this-&gt;_artifacts-&gt;map_symbol(sym);</span>
<span class="line-modified">!     assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-     if (_unique_predicate(entry-&gt;id())) {</span>
<span class="line-removed">-       count += write__artifact__symbol__entry__(this-&gt;_writer, entry);</span>
<span class="line-removed">-     }</span>
    }
<span class="line-modified">!   return count;</span>
  }
  
<span class="line-modified">! template &lt;template &lt;typename&gt; class Predicate&gt;</span>
<span class="line-modified">! int KlassSymbolWriterImpl&lt;Predicate&gt;::class_loader_symbols(CldPtr cld) {</span>
<span class="line-modified">!   assert(cld != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(!cld-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);</span>
<span class="line-modified">!   int count = 0;</span>
<span class="line-modified">!   // class loader type</span>
<span class="line-modified">!   const Klass* class_loader_klass = cld-&gt;class_loader_klass();</span>
<span class="line-removed">-   if (class_loader_klass == NULL) {</span>
<span class="line-removed">-     // (primordial) boot class loader</span>
<span class="line-removed">-     CStringEntryPtr entry = this-&gt;_artifacts-&gt;map_cstring(0);</span>
<span class="line-removed">-     assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-     assert(strncmp(entry-&gt;literal(),</span>
<span class="line-removed">-       BOOTSTRAP_LOADER_NAME,</span>
<span class="line-removed">-       BOOTSTRAP_LOADER_NAME_LEN) == 0, &quot;invariant&quot;);</span>
<span class="line-removed">-     if (_unique_predicate(entry-&gt;id())) {</span>
<span class="line-removed">-       count += write__artifact__cstring__entry__(this-&gt;_writer, entry);</span>
      }
    } else {
<span class="line-modified">!     const Symbol* class_loader_name = cld-&gt;name();</span>
<span class="line-modified">!     if (class_loader_name != NULL) {</span>
<span class="line-modified">!       SymbolEntryPtr entry = this-&gt;_artifacts-&gt;map_symbol(class_loader_name);</span>
<span class="line-removed">-       assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-       if (_unique_predicate(entry-&gt;id())) {</span>
<span class="line-removed">-         count += write__artifact__symbol__entry__(this-&gt;_writer, entry);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return count;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- template &lt;template &lt;typename&gt; class Predicate&gt;</span>
<span class="line-removed">- int KlassSymbolWriterImpl&lt;Predicate&gt;::method_symbols(KlassPtr klass) {</span>
<span class="line-removed">-   assert(_predicate(klass), &quot;invariant&quot;);</span>
<span class="line-removed">-   assert(_method_used_predicate(klass), &quot;invariant&quot;);</span>
<span class="line-removed">-   assert(METHOD_AND_CLASS_USED_ANY_EPOCH(klass), &quot;invariant&quot;);</span>
<span class="line-removed">-   int count = 0;</span>
<span class="line-removed">-   const InstanceKlass* const ik = InstanceKlass::cast(klass);</span>
<span class="line-removed">-   const int len = ik-&gt;methods()-&gt;length();</span>
<span class="line-removed">-   for (int i = 0; i &lt; len; ++i) {</span>
<span class="line-removed">-     MethodPtr method = ik-&gt;methods()-&gt;at(i);</span>
<span class="line-removed">-     if (_method_flag_predicate(method)) {</span>
<span class="line-removed">-       SymbolEntryPtr entry = this-&gt;_artifacts-&gt;map_symbol(method-&gt;name());</span>
<span class="line-removed">-       assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-       if (_unique_predicate(entry-&gt;id())) {</span>
<span class="line-removed">-         count += write__artifact__symbol__entry__(this-&gt;_writer, entry);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       entry = this-&gt;_artifacts-&gt;map_symbol(method-&gt;signature());</span>
<span class="line-removed">-       assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-       if (_unique_predicate(entry-&gt;id())) {</span>
<span class="line-removed">-         count += write__artifact__symbol__entry__(this-&gt;_writer, entry);</span>
<span class="line-removed">-       }</span>
      }
    }
<span class="line-modified">!   return count;</span>
  }
  
<span class="line-modified">! typedef KlassSymbolWriterImpl&lt;LeakPredicate&gt; LeakKlassSymbolWriterImpl;</span>
<span class="line-modified">! typedef JfrArtifactWriterHost&lt;LeakKlassSymbolWriterImpl, TYPE_SYMBOL&gt; LeakKlassSymbolWriter;</span>
  
<span class="line-modified">! class ClearKlassAndMethods {</span>
<span class="line-modified">!  private:</span>
<span class="line-modified">!   ClearArtifact&lt;KlassPtr&gt; _clear_klass_tag_bits;</span>
<span class="line-modified">!   ClearArtifact&lt;MethodPtr&gt; _clear_method_flag;</span>
<span class="line-modified">!   MethodUsedPredicate&lt;false&gt; _method_used_predicate;</span>
  
<span class="line-modified">!  public:</span>
<span class="line-modified">!   ClearKlassAndMethods(bool class_unload) : _clear_klass_tag_bits(class_unload),</span>
<span class="line-modified">!                                             _clear_method_flag(class_unload),</span>
<span class="line-modified">!                                             _method_used_predicate(class_unload) {}</span>
<span class="line-modified">!   bool operator()(KlassPtr klass) {</span>
<span class="line-modified">!     if (_method_used_predicate(klass)) {</span>
<span class="line-modified">!       const InstanceKlass* ik = InstanceKlass::cast(klass);</span>
<span class="line-removed">-       const int len = ik-&gt;methods()-&gt;length();</span>
<span class="line-removed">-       for (int i = 0; i &lt; len; ++i) {</span>
<span class="line-removed">-         MethodPtr method = ik-&gt;methods()-&gt;at(i);</span>
<span class="line-removed">-         _clear_method_flag(method);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     _clear_klass_tag_bits(klass);</span>
<span class="line-removed">-     return true;</span>
    }
  };
  
<span class="line-modified">! typedef CompositeFunctor&lt;KlassPtr,</span>
<span class="line-modified">!                          TagLeakpKlassArtifact,</span>
<span class="line-modified">!                          LeakKlassWriter&gt; LeakpKlassArtifactTagging;</span>
<span class="line-removed">- </span>
<span class="line-removed">- typedef CompositeFunctor&lt;KlassPtr,</span>
<span class="line-removed">-                          LeakpKlassArtifactTagging,</span>
<span class="line-removed">-                          KlassWriter&gt; CompositeKlassWriter;</span>
<span class="line-removed">- </span>
<span class="line-removed">- typedef CompositeFunctor&lt;KlassPtr,</span>
<span class="line-removed">-                          CompositeKlassWriter,</span>
<span class="line-removed">-                          KlassArtifactRegistrator&gt; CompositeKlassWriterRegistration;</span>
<span class="line-removed">- </span>
<span class="line-removed">- typedef CompositeFunctor&lt;KlassPtr,</span>
<span class="line-removed">-                          KlassWriter,</span>
<span class="line-removed">-                          KlassArtifactRegistrator&gt; KlassWriterRegistration;</span>
  
<span class="line-modified">! typedef JfrArtifactCallbackHost&lt;KlassPtr, KlassWriterRegistration&gt; KlassCallback;</span>
  typedef JfrArtifactCallbackHost&lt;KlassPtr, CompositeKlassWriterRegistration&gt; CompositeKlassCallback;
  
<span class="line-modified">! /*</span>
<span class="line-removed">-  * Composite operation</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * TagLeakpKlassArtifact -&gt;</span>
<span class="line-removed">-  *   LeakpPredicate -&gt;</span>
<span class="line-removed">-  *     LeakpKlassWriter -&gt;</span>
<span class="line-removed">-  *       KlassPredicate -&gt;</span>
<span class="line-removed">-  *         KlassWriter -&gt;</span>
<span class="line-removed">-  *           KlassWriterRegistration</span>
<span class="line-removed">-  */</span>
<span class="line-removed">- void JfrTypeSet::write_klass_constants(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer) {</span>
    assert(!_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);
    KlassArtifactRegistrator reg(_artifacts);
<span class="line-modified">!   KlassWriter kw(writer, _artifacts, _class_unload);</span>
    KlassWriterRegistration kwr(&amp;kw, &amp;reg);
<span class="line-modified">!   if (leakp_writer == NULL) {</span>
      KlassCallback callback(&amp;kwr);
      _subsystem_callback = &amp;callback;
      do_klasses();
      return;
    }
<span class="line-modified">!   TagLeakpKlassArtifact tagging(_class_unload);</span>
<span class="line-modified">!   LeakKlassWriter lkw(leakp_writer, _artifacts, _class_unload);</span>
<span class="line-modified">!   LeakpKlassArtifactTagging lpkat(&amp;tagging, &amp;lkw);</span>
<span class="line-modified">!   CompositeKlassWriter ckw(&amp;lpkat, &amp;kw);</span>
<span class="line-modified">!   CompositeKlassWriterRegistration ckwr(&amp;ckw, &amp;reg);</span>
<span class="line-modified">!   CompositeKlassCallback callback(&amp;ckwr);</span>
    _subsystem_callback = &amp;callback;
<span class="line-modified">!   do_klasses();</span>
  }
  
<span class="line-modified">! typedef CompositeFunctor&lt;PkgPtr,</span>
<span class="line-modified">!                          PackageWriter,</span>
<span class="line-modified">!                          ClearArtifact&lt;PkgPtr&gt; &gt; PackageWriterWithClear;</span>
  
<span class="line-modified">! typedef CompositeFunctor&lt;PkgPtr,</span>
<span class="line-modified">!                          LeakPackageWriter,</span>
<span class="line-modified">!                          PackageWriter&gt; CompositePackageWriter;</span>
  
<span class="line-modified">! typedef CompositeFunctor&lt;PkgPtr,</span>
<span class="line-modified">!                          CompositePackageWriter,</span>
<span class="line-modified">!                          ClearArtifact&lt;PkgPtr&gt; &gt; CompositePackageWriterWithClear;</span>
  
  class PackageFieldSelector {
   public:
    typedef PkgPtr TypePtr;
    static TypePtr select(KlassPtr klass) {
      assert(klass != NULL, &quot;invariant&quot;);
      return ((InstanceKlass*)klass)-&gt;package();
    }
  };
  
<span class="line-modified">! typedef KlassToFieldEnvelope&lt;PackageFieldSelector,</span>
<span class="line-modified">!                              PackageWriterWithClear&gt; KlassPackageWriterWithClear;</span>
  
<span class="line-modified">! typedef KlassToFieldEnvelope&lt;PackageFieldSelector,</span>
<span class="line-modified">!                              CompositePackageWriterWithClear&gt; KlassCompositePackageWriterWithClear;</span>
  
<span class="line-modified">! typedef JfrArtifactCallbackHost&lt;PkgPtr, PackageWriterWithClear&gt; PackageCallback;</span>
  typedef JfrArtifactCallbackHost&lt;PkgPtr, CompositePackageWriterWithClear&gt; CompositePackageCallback;
  
<span class="line-modified">! /*</span>
<span class="line-modified">!  * Composite operation</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * LeakpPackageWriter -&gt;</span>
<span class="line-modified">!  *   PackageWriter -&gt;</span>
<span class="line-modified">!  *     ClearArtifact&lt;PackageEntry&gt;</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  */</span>
<span class="line-modified">! void JfrTypeSet::write_package_constants(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer) {</span>
<span class="line-modified">!   assert(_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);</span>
<span class="line-modified">!   ClearArtifact&lt;PkgPtr&gt; clear(_class_unload);</span>
<span class="line-modified">!   PackageWriter pw(writer, _artifacts, _class_unload);</span>
<span class="line-modified">!   if (leakp_writer == NULL) {</span>
      PackageWriterWithClear pwwc(&amp;pw, &amp;clear);
<span class="line-removed">-     KlassPackageWriterWithClear kpwwc(&amp;pwwc);</span>
<span class="line-removed">-     _artifacts-&gt;iterate_klasses(kpwwc);</span>
      PackageCallback callback(&amp;pwwc);
      _subsystem_callback = &amp;callback;
      do_packages();
<span class="line-modified">!     return;</span>
    }
<span class="line-modified">!   LeakPackageWriter lpw(leakp_writer, _artifacts, _class_unload);</span>
<span class="line-modified">!   CompositePackageWriter cpw(&amp;lpw, &amp;pw);</span>
<span class="line-modified">!   CompositePackageWriterWithClear cpwwc(&amp;cpw, &amp;clear);</span>
<span class="line-modified">!   KlassCompositePackageWriterWithClear ckpw(&amp;cpwwc);</span>
<span class="line-modified">!   _artifacts-&gt;iterate_klasses(ckpw);</span>
<span class="line-modified">!   CompositePackageCallback callback(&amp;cpwwc);</span>
    _subsystem_callback = &amp;callback;
    do_packages();
  }
  
<span class="line-modified">! typedef CompositeFunctor&lt;ModPtr,</span>
<span class="line-modified">!                          ModuleWriter,</span>
<span class="line-modified">!                          ClearArtifact&lt;ModPtr&gt; &gt; ModuleWriterWithClear;</span>
  
<span class="line-modified">! typedef CompositeFunctor&lt;ModPtr,</span>
<span class="line-modified">!                          LeakModuleWriter,</span>
<span class="line-modified">!                          ModuleWriter&gt; CompositeModuleWriter;</span>
  
<span class="line-modified">! typedef CompositeFunctor&lt;ModPtr,</span>
<span class="line-modified">!                          CompositeModuleWriter,</span>
<span class="line-modified">!                          ClearArtifact&lt;ModPtr&gt; &gt; CompositeModuleWriterWithClear;</span>
  
<span class="line-modified">! typedef JfrArtifactCallbackHost&lt;ModPtr, ModuleWriterWithClear&gt; ModuleCallback;</span>
<span class="line-modified">! typedef JfrArtifactCallbackHost&lt;ModPtr, CompositeModuleWriterWithClear&gt; CompositeModuleCallback;</span>
  
  class ModuleFieldSelector {
   public:
    typedef ModPtr TypePtr;
    static TypePtr select(KlassPtr klass) {
<span class="line-new-header">--- 26,466 ---</span>
  #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  #include &quot;classfile/javaClasses.inline.hpp&quot;
  #include &quot;classfile/moduleEntry.hpp&quot;
  #include &quot;classfile/packageEntry.hpp&quot;
  #include &quot;classfile/symbolTable.hpp&quot;
  #include &quot;jfr/jfr.hpp&quot;
  #include &quot;jfr/jni/jfrGetAllEventClasses.hpp&quot;
<span class="line-modified">! #include &quot;jfr/leakprofiler/checkpoint/objectSampleCheckpoint.hpp&quot;</span>
  #include &quot;jfr/recorder/checkpoint/types/jfrTypeSet.hpp&quot;
  #include &quot;jfr/recorder/checkpoint/types/jfrTypeSetUtils.hpp&quot;
  #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceId.inline.hpp&quot;
  #include &quot;jfr/utilities/jfrHashtable.hpp&quot;
  #include &quot;jfr/utilities/jfrTypes.hpp&quot;
<span class="line-added">+ #include &quot;jfr/writers/jfrTypeWriterHost.hpp&quot;</span>
  #include &quot;memory/iterator.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;oops/instanceKlass.hpp&quot;
  #include &quot;oops/objArrayKlass.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;utilities/accessFlags.hpp&quot;
<span class="line-modified">! #include &quot;utilities/bitMap.inline.hpp&quot;</span>
  
  typedef const Klass* KlassPtr;
  typedef const PackageEntry* PkgPtr;
  typedef const ModuleEntry* ModPtr;
  typedef const ClassLoaderData* CldPtr;
  typedef const Method* MethodPtr;
  typedef const Symbol* SymbolPtr;
  typedef const JfrSymbolId::SymbolEntry* SymbolEntryPtr;
  typedef const JfrSymbolId::CStringEntry* CStringEntryPtr;
  
<span class="line-modified">! static JfrCheckpointWriter* _writer = NULL;</span>
<span class="line-modified">! static JfrCheckpointWriter* _leakp_writer = NULL;</span>
<span class="line-modified">! static JfrArtifactSet* _artifacts = NULL;</span>
<span class="line-modified">! static JfrArtifactClosure* _subsystem_callback = NULL;</span>
<span class="line-added">+ static bool _class_unload = false;</span>
<span class="line-added">+ static bool _flushpoint = false;</span>
<span class="line-added">+ </span>
<span class="line-added">+ // incremented on each rotation</span>
<span class="line-added">+ static u8 checkpoint_id = 1;</span>
<span class="line-added">+ </span>
<span class="line-added">+ // creates a unique id by combining a checkpoint relative symbol id (2^24)</span>
<span class="line-added">+ // with the current checkpoint id (2^40)</span>
<span class="line-added">+ #define CREATE_SYMBOL_ID(sym_id) (((u8)((checkpoint_id &lt;&lt; 24) | sym_id)))</span>
<span class="line-added">+ </span>
<span class="line-added">+ static traceid create_symbol_id(traceid artifact_id) {</span>
<span class="line-added">+   return artifact_id != 0 ? CREATE_SYMBOL_ID(artifact_id) : 0;</span>
  }
  
<span class="line-modified">! static bool current_epoch() {</span>
<span class="line-modified">!   return _class_unload || _flushpoint;</span>
  }
  
<span class="line-modified">! static bool previous_epoch() {</span>
<span class="line-modified">!   return !current_epoch();</span>
  }
  
<span class="line-modified">! static bool is_complete() {</span>
<span class="line-modified">!   return !_artifacts-&gt;has_klass_entries() &amp;&amp; current_epoch();</span>
  }
  
<span class="line-modified">! static traceid mark_symbol(KlassPtr klass, bool leakp) {</span>
<span class="line-modified">!   return klass != NULL ? create_symbol_id(_artifacts-&gt;mark(klass, leakp)) : 0;</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! static traceid mark_symbol(Symbol* symbol, bool leakp) {</span>
<span class="line-modified">!   return symbol != NULL ? create_symbol_id(_artifacts-&gt;mark(symbol, leakp)) : 0;</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! static traceid get_bootstrap_name(bool leakp) {</span>
<span class="line-modified">!   return create_symbol_id(_artifacts-&gt;bootstrap_name(leakp));</span>
  }
  
<span class="line-modified">! template &lt;typename T&gt;</span>
<span class="line-modified">! static traceid artifact_id(const T* ptr) {</span>
<span class="line-modified">!   assert(ptr != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   return TRACE_ID(ptr);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! static traceid package_id(KlassPtr klass, bool leakp) {</span>
    assert(klass != NULL, &quot;invariant&quot;);
<span class="line-modified">!   PkgPtr pkg_entry = klass-&gt;package();</span>
<span class="line-modified">!   if (pkg_entry == NULL) {</span>
<span class="line-modified">!     return 0;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (leakp) {</span>
<span class="line-modified">!     SET_LEAKP(pkg_entry);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   // package implicitly tagged already</span>
<span class="line-added">+   return artifact_id(pkg_entry);</span>
  }
  
<span class="line-modified">! static traceid module_id(PkgPtr pkg, bool leakp) {</span>
<span class="line-modified">!   assert(pkg != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   ModPtr module_entry = pkg-&gt;module();</span>
<span class="line-modified">!   if (module_entry == NULL) {</span>
<span class="line-modified">!     return 0;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (leakp) {</span>
<span class="line-modified">!     SET_LEAKP(module_entry);</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     SET_TRANSIENT(module_entry);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   return artifact_id(module_entry);</span>
  }
  
<span class="line-modified">! static traceid method_id(KlassPtr klass, MethodPtr method) {</span>
<span class="line-modified">!   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(method != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   return METHOD_ID(klass, method);</span>
  }
  
<span class="line-modified">! static traceid cld_id(CldPtr cld, bool leakp) {</span>
<span class="line-modified">!   assert(cld != NULL, &quot;invariant&quot;);</span>
    assert(!cld-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);
<span class="line-modified">!   if (leakp) {</span>
<span class="line-modified">!     SET_LEAKP(cld);</span>
    } else {
<span class="line-modified">!     SET_TRANSIENT(cld);</span>
    }
<span class="line-modified">!   return artifact_id(cld);</span>
  }
  
<span class="line-modified">! template &lt;typename T&gt;</span>
<span class="line-modified">! static s4 get_flags(const T* ptr) {</span>
<span class="line-modified">!   assert(ptr != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   return ptr-&gt;access_flags().get_flags();</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! static bool is_unsafe_anonymous(const Klass* klass) {</span>
<span class="line-modified">!   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   return klass-&gt;is_instance_klass() &amp;&amp; ((const InstanceKlass*)klass)-&gt;is_unsafe_anonymous();</span>
  }
  
<span class="line-modified">! static ClassLoaderData* get_cld(const Klass* klass) {</span>
<span class="line-modified">!   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   return is_unsafe_anonymous(klass) ?</span>
<span class="line-added">+     InstanceKlass::cast(klass)-&gt;unsafe_anonymous_host()-&gt;class_loader_data() : klass-&gt;class_loader_data();</span>
  }
  
<span class="line-modified">! template &lt;typename T&gt;</span>
<span class="line-modified">! static void set_serialized(const T* ptr) {</span>
<span class="line-added">+   assert(ptr != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   SET_SERIALIZED(ptr);</span>
<span class="line-added">+   assert(IS_SERIALIZED(ptr), &quot;invariant&quot;);</span>
<span class="line-added">+   CLEAR_THIS_EPOCH_CLEARED_BIT(ptr);</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! /*</span>
<span class="line-added">+  * In C++03, functions used as template parameters must have external linkage;</span>
<span class="line-added">+  * this restriction was removed in C++11. Change back to &quot;static&quot; and</span>
<span class="line-added">+  * rename functions when C++11 becomes available.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * The weird naming is an effort to decrease the risk of name clashes.</span>
<span class="line-added">+  */</span>
  
<span class="line-modified">! static int write_klass(JfrCheckpointWriter* writer, KlassPtr klass, bool leakp) {</span>
    assert(writer != NULL, &quot;invariant&quot;);
<span class="line-modified">!   assert(_artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   traceid pkg_id = 0;</span>
<span class="line-added">+   KlassPtr theklass = klass;</span>
<span class="line-added">+   if (theklass-&gt;is_objArray_klass()) {</span>
<span class="line-added">+     const ObjArrayKlass* obj_arr_klass = ObjArrayKlass::cast(klass);</span>
<span class="line-added">+     theklass = obj_arr_klass-&gt;bottom_klass();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (theklass-&gt;is_instance_klass()) {</span>
<span class="line-added">+     pkg_id = package_id(theklass, leakp);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     assert(theklass-&gt;is_typeArray_klass(), &quot;invariant&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   writer-&gt;write(artifact_id(klass));</span>
<span class="line-added">+   writer-&gt;write(cld_id(get_cld(klass), leakp));</span>
<span class="line-added">+   writer-&gt;write(mark_symbol(klass, leakp));</span>
<span class="line-added">+   writer-&gt;write(pkg_id);</span>
<span class="line-added">+   writer-&gt;write(get_flags(klass));</span>
    return 1;
  }
  
<span class="line-modified">! int write__klass(JfrCheckpointWriter* writer, const void* k) {</span>
<span class="line-modified">!   assert(k != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   KlassPtr klass = (KlassPtr)k;</span>
<span class="line-added">+   set_serialized(klass);</span>
<span class="line-added">+   return write_klass(writer, klass, false);</span>
  }
  
<span class="line-modified">! int write__klass__leakp(JfrCheckpointWriter* writer, const void* k) {</span>
    assert(k != NULL, &quot;invariant&quot;);
<span class="line-modified">!   KlassPtr klass = (KlassPtr)k;</span>
<span class="line-modified">!   return write_klass(writer, klass, true);</span>
  }
  
<span class="line-modified">! static bool is_implied(const Klass* klass) {</span>
<span class="line-modified">!   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   return klass-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass()) || klass == SystemDictionary::Object_klass();</span>
  }
  
<span class="line-modified">! static void do_implied(Klass* klass) {</span>
<span class="line-modified">!   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   if (is_implied(klass)) {</span>
<span class="line-modified">!     if (_leakp_writer != NULL) {</span>
<span class="line-modified">!       SET_LEAKP(klass);</span>
      }
<span class="line-modified">!     _subsystem_callback-&gt;do_artifact(klass);</span>
    }
  }
  
<span class="line-modified">! static void do_unloaded_klass(Klass* klass) {</span>
<span class="line-modified">!   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   if (IS_JDK_JFR_EVENT_SUBKLASS(klass)) {</span>
<span class="line-modified">!     JfrEventClasses::increment_unloaded_event_class();</span>
    }
<span class="line-modified">!   if (USED_THIS_EPOCH(klass)) {</span>
<span class="line-modified">!     ObjectSampleCheckpoint::on_klass_unload(klass);</span>
<span class="line-modified">!     _subsystem_callback-&gt;do_artifact(klass);</span>
<span class="line-modified">!     return;</span>
    }
<span class="line-modified">!   do_implied(klass);</span>
  }
  
<span class="line-modified">! static void do_klass(Klass* klass) {</span>
<span class="line-modified">!   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   if (_flushpoint) {</span>
<span class="line-modified">!     if (USED_THIS_EPOCH(klass)) {</span>
<span class="line-modified">!       _subsystem_callback-&gt;do_artifact(klass);</span>
<span class="line-modified">!       return;</span>
      }
    } else {
<span class="line-modified">!     if (USED_PREV_EPOCH(klass)) {</span>
<span class="line-modified">!       _subsystem_callback-&gt;do_artifact(klass);</span>
<span class="line-modified">!       return;</span>
      }
    }
<span class="line-modified">!   do_implied(klass);</span>
  }
  
<span class="line-modified">! static void do_klasses() {</span>
<span class="line-modified">!   if (_class_unload) {</span>
<span class="line-added">+     ClassLoaderDataGraph::classes_unloading_do(&amp;do_unloaded_klass);</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   ClassLoaderDataGraph::classes_do(&amp;do_klass);</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! typedef SerializePredicate&lt;KlassPtr&gt; KlassPredicate;</span>
<span class="line-modified">! typedef JfrPredicatedTypeWriterImplHost&lt;KlassPtr, KlassPredicate, write__klass&gt; KlassWriterImpl;</span>
<span class="line-modified">! typedef JfrTypeWriterHost&lt;KlassWriterImpl, TYPE_CLASS&gt; KlassWriter;</span>
<span class="line-modified">! typedef CompositeFunctor&lt;KlassPtr, KlassWriter, KlassArtifactRegistrator&gt; KlassWriterRegistration;</span>
<span class="line-modified">! typedef JfrArtifactCallbackHost&lt;KlassPtr, KlassWriterRegistration&gt; KlassCallback;</span>
  
<span class="line-modified">! template &lt;&gt;</span>
<span class="line-modified">! class LeakPredicate&lt;const Klass*&gt; {</span>
<span class="line-modified">! public:</span>
<span class="line-modified">!   LeakPredicate(bool class_unload) {}</span>
<span class="line-modified">!   bool operator()(const Klass* klass) {</span>
<span class="line-modified">!     assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!     return IS_LEAKP(klass) || is_implied(klass);</span>
    }
  };
  
<span class="line-modified">! typedef LeakPredicate&lt;KlassPtr&gt; LeakKlassPredicate;</span>
<span class="line-modified">! typedef JfrPredicatedTypeWriterImplHost&lt;KlassPtr, LeakKlassPredicate, write__klass__leakp&gt; LeakKlassWriterImpl;</span>
<span class="line-modified">! typedef JfrTypeWriterHost&lt;LeakKlassWriterImpl, TYPE_CLASS&gt; LeakKlassWriter;</span>
  
<span class="line-modified">! typedef CompositeFunctor&lt;KlassPtr, LeakKlassWriter, KlassWriter&gt; CompositeKlassWriter;</span>
<span class="line-added">+ typedef CompositeFunctor&lt;KlassPtr, CompositeKlassWriter, KlassArtifactRegistrator&gt; CompositeKlassWriterRegistration;</span>
  typedef JfrArtifactCallbackHost&lt;KlassPtr, CompositeKlassWriterRegistration&gt; CompositeKlassCallback;
  
<span class="line-modified">! static bool write_klasses() {</span>
    assert(!_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);
<span class="line-added">+   assert(_writer != NULL, &quot;invariant&quot;);</span>
    KlassArtifactRegistrator reg(_artifacts);
<span class="line-modified">!   KlassWriter kw(_writer, _class_unload);</span>
    KlassWriterRegistration kwr(&amp;kw, &amp;reg);
<span class="line-modified">!   if (_leakp_writer == NULL) {</span>
      KlassCallback callback(&amp;kwr);
      _subsystem_callback = &amp;callback;
      do_klasses();
<span class="line-added">+   } else {</span>
<span class="line-added">+     LeakKlassWriter lkw(_leakp_writer, _class_unload);</span>
<span class="line-added">+     CompositeKlassWriter ckw(&amp;lkw, &amp;kw);</span>
<span class="line-added">+     CompositeKlassWriterRegistration ckwr(&amp;ckw, &amp;reg);</span>
<span class="line-added">+     CompositeKlassCallback callback(&amp;ckwr);</span>
<span class="line-added">+     _subsystem_callback = &amp;callback;</span>
<span class="line-added">+     do_klasses();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (is_complete()) {</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   _artifacts-&gt;tally(kw);</span>
<span class="line-added">+   return true;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ static void do_previous_epoch_artifact(JfrArtifactClosure* callback, T* value) {</span>
<span class="line-added">+   assert(callback != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(value != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   if (USED_PREV_EPOCH(value)) {</span>
<span class="line-added">+     callback-&gt;do_artifact(value);</span>
<span class="line-added">+     assert(IS_NOT_SERIALIZED(value), &quot;invariant&quot;);</span>
      return;
    }
<span class="line-modified">!   if (IS_SERIALIZED(value)) {</span>
<span class="line-modified">!     CLEAR_SERIALIZED(value);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   assert(IS_NOT_SERIALIZED(value), &quot;invariant&quot;);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-added">+ typedef JfrArtifactCallbackHost&lt;KlassPtr, KlassArtifactRegistrator&gt; RegistrationCallback;</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void register_klass(Klass* klass) {</span>
<span class="line-added">+   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   do_previous_epoch_artifact(_subsystem_callback, klass);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void do_register_klasses() {</span>
<span class="line-added">+   ClassLoaderDataGraph::classes_do(&amp;register_klass);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void register_klasses() {</span>
<span class="line-added">+   assert(!_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);</span>
<span class="line-added">+   KlassArtifactRegistrator reg(_artifacts);</span>
<span class="line-added">+   RegistrationCallback callback(&amp;reg);</span>
    _subsystem_callback = &amp;callback;
<span class="line-modified">!   do_register_klasses();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static int write_package(JfrCheckpointWriter* writer, PkgPtr pkg, bool leakp) {</span>
<span class="line-added">+   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(_artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(pkg != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   writer-&gt;write(artifact_id(pkg));</span>
<span class="line-added">+   writer-&gt;write(mark_symbol(pkg-&gt;name(), leakp));</span>
<span class="line-added">+   writer-&gt;write(module_id(pkg, leakp));</span>
<span class="line-added">+   writer-&gt;write((bool)pkg-&gt;is_exported());</span>
<span class="line-added">+   return 1;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ int write__package(JfrCheckpointWriter* writer, const void* p) {</span>
<span class="line-added">+   assert(p != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   PkgPtr pkg = (PkgPtr)p;</span>
<span class="line-added">+   set_serialized(pkg);</span>
<span class="line-added">+   return write_package(writer, pkg, false);</span>
  }
  
<span class="line-modified">! int write__package__leakp(JfrCheckpointWriter* writer, const void* p) {</span>
<span class="line-modified">!   assert(p != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   PkgPtr pkg = (PkgPtr)p;</span>
<span class="line-added">+   CLEAR_LEAKP(pkg);</span>
<span class="line-added">+   return write_package(writer, pkg, true);</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! static void do_package(PackageEntry* entry) {</span>
<span class="line-modified">!   do_previous_epoch_artifact(_subsystem_callback, entry);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! static void do_packages() {</span>
<span class="line-modified">!   ClassLoaderDataGraph::packages_do(&amp;do_package);</span>
<span class="line-modified">! }</span>
  
  class PackageFieldSelector {
   public:
    typedef PkgPtr TypePtr;
    static TypePtr select(KlassPtr klass) {
      assert(klass != NULL, &quot;invariant&quot;);
      return ((InstanceKlass*)klass)-&gt;package();
    }
  };
  
<span class="line-modified">! typedef SerializePredicate&lt;PkgPtr&gt; PackagePredicate;</span>
<span class="line-modified">! typedef JfrPredicatedTypeWriterImplHost&lt;PkgPtr, PackagePredicate, write__package&gt; PackageWriterImpl;</span>
<span class="line-added">+ typedef JfrTypeWriterHost&lt;PackageWriterImpl, TYPE_PACKAGE&gt; PackageWriter;</span>
<span class="line-added">+ typedef CompositeFunctor&lt;PkgPtr, PackageWriter, ClearArtifact&lt;PkgPtr&gt; &gt; PackageWriterWithClear;</span>
<span class="line-added">+ typedef KlassToFieldEnvelope&lt;PackageFieldSelector, PackageWriter&gt; KlassPackageWriter;</span>
<span class="line-added">+ typedef JfrArtifactCallbackHost&lt;PkgPtr, PackageWriterWithClear&gt; PackageCallback;</span>
  
<span class="line-modified">! typedef LeakPredicate&lt;PkgPtr&gt; LeakPackagePredicate;</span>
<span class="line-modified">! typedef JfrPredicatedTypeWriterImplHost&lt;PkgPtr, LeakPackagePredicate, write__package__leakp&gt; LeakPackageWriterImpl;</span>
<span class="line-added">+ typedef JfrTypeWriterHost&lt;LeakPackageWriterImpl, TYPE_PACKAGE&gt; LeakPackageWriter;</span>
  
<span class="line-modified">! typedef CompositeFunctor&lt;PkgPtr, LeakPackageWriter, PackageWriter&gt; CompositePackageWriter;</span>
<span class="line-added">+ typedef KlassToFieldEnvelope&lt;PackageFieldSelector, CompositePackageWriter&gt; KlassCompositePackageWriter;</span>
<span class="line-added">+ typedef KlassToFieldEnvelope&lt;PackageFieldSelector, PackageWriterWithClear&gt; KlassPackageWriterWithClear;</span>
<span class="line-added">+ typedef CompositeFunctor&lt;PkgPtr, CompositePackageWriter, ClearArtifact&lt;PkgPtr&gt; &gt; CompositePackageWriterWithClear;</span>
  typedef JfrArtifactCallbackHost&lt;PkgPtr, CompositePackageWriterWithClear&gt; CompositePackageCallback;
  
<span class="line-modified">! static void write_packages() {</span>
<span class="line-modified">!   assert(_writer != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   PackageWriter pw(_writer, _class_unload);</span>
<span class="line-modified">!   KlassPackageWriter kpw(&amp;pw);</span>
<span class="line-modified">!   if (current_epoch()) {</span>
<span class="line-modified">!     _artifacts-&gt;iterate_klasses(kpw);</span>
<span class="line-modified">!     _artifacts-&gt;tally(pw);</span>
<span class="line-modified">!     return;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   assert(previous_epoch(), &quot;invariant&quot;);</span>
<span class="line-modified">!   if (_leakp_writer == NULL) {</span>
<span class="line-modified">!     _artifacts-&gt;iterate_klasses(kpw);</span>
<span class="line-modified">!     ClearArtifact&lt;PkgPtr&gt; clear;</span>
      PackageWriterWithClear pwwc(&amp;pw, &amp;clear);
      PackageCallback callback(&amp;pwwc);
      _subsystem_callback = &amp;callback;
      do_packages();
<span class="line-modified">!   } else {</span>
<span class="line-added">+     LeakPackageWriter lpw(_leakp_writer, _class_unload);</span>
<span class="line-added">+     CompositePackageWriter cpw(&amp;lpw, &amp;pw);</span>
<span class="line-added">+     KlassCompositePackageWriter kcpw(&amp;cpw);</span>
<span class="line-added">+     _artifacts-&gt;iterate_klasses(kcpw);</span>
<span class="line-added">+     ClearArtifact&lt;PkgPtr&gt; clear;</span>
<span class="line-added">+     CompositePackageWriterWithClear cpwwc(&amp;cpw, &amp;clear);</span>
<span class="line-added">+     CompositePackageCallback callback(&amp;cpwwc);</span>
<span class="line-added">+     _subsystem_callback = &amp;callback;</span>
<span class="line-added">+     do_packages();</span>
    }
<span class="line-modified">!   _artifacts-&gt;tally(pw);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! typedef JfrArtifactCallbackHost&lt;PkgPtr, ClearArtifact&lt;PkgPtr&gt; &gt; ClearPackageCallback;</span>
<span class="line-modified">! </span>
<span class="line-modified">! static void clear_packages() {</span>
<span class="line-added">+   ClearArtifact&lt;PkgPtr&gt; clear;</span>
<span class="line-added">+   ClearPackageCallback callback(&amp;clear);</span>
    _subsystem_callback = &amp;callback;
    do_packages();
  }
  
<span class="line-modified">! static int write_module(JfrCheckpointWriter* writer, ModPtr mod, bool leakp) {</span>
<span class="line-modified">!   assert(mod != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(_artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   writer-&gt;write(artifact_id(mod));</span>
<span class="line-added">+   writer-&gt;write(mark_symbol(mod-&gt;name(), leakp));</span>
<span class="line-added">+   writer-&gt;write(mark_symbol(mod-&gt;version(), leakp));</span>
<span class="line-added">+   writer-&gt;write(mark_symbol(mod-&gt;location(), leakp));</span>
<span class="line-added">+   writer-&gt;write(cld_id(mod-&gt;loader_data(), leakp));</span>
<span class="line-added">+   return 1;</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! int write__module(JfrCheckpointWriter* writer, const void* m) {</span>
<span class="line-modified">!   assert(m != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   ModPtr mod = (ModPtr)m;</span>
<span class="line-added">+   set_serialized(mod);</span>
<span class="line-added">+   return write_module(writer, mod, false);</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! int write__module__leakp(JfrCheckpointWriter* writer, const void* m) {</span>
<span class="line-modified">!   assert(m != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   ModPtr mod = (ModPtr)m;</span>
<span class="line-added">+   CLEAR_LEAKP(mod);</span>
<span class="line-added">+   return write_module(writer, mod, true);</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! static void do_module(ModuleEntry* entry) {</span>
<span class="line-modified">!   do_previous_epoch_artifact(_subsystem_callback, entry);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void do_modules() {</span>
<span class="line-added">+   ClassLoaderDataGraph::modules_do(&amp;do_module);</span>
<span class="line-added">+ }</span>
  
  class ModuleFieldSelector {
   public:
    typedef ModPtr TypePtr;
    static TypePtr select(KlassPtr klass) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 646,343 ***</span>
      PkgPtr pkg = klass-&gt;package();
      return pkg != NULL ? pkg-&gt;module() : NULL;
    }
  };
  
<span class="line-modified">! typedef KlassToFieldEnvelope&lt;ModuleFieldSelector,</span>
<span class="line-modified">!                              ModuleWriterWithClear&gt; KlassModuleWriterWithClear;</span>
  
<span class="line-modified">! typedef KlassToFieldEnvelope&lt;ModuleFieldSelector,</span>
<span class="line-modified">!                              CompositeModuleWriterWithClear&gt; KlassCompositeModuleWriterWithClear;</span>
  
<span class="line-modified">! /*</span>
<span class="line-modified">!  * Composite operation</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * LeakpModuleWriter -&gt;</span>
<span class="line-modified">!  *   ModuleWriter -&gt;</span>
<span class="line-modified">!  *     ClearArtifact&lt;ModuleEntry&gt;</span>
<span class="line-modified">!  */</span>
<span class="line-modified">! void JfrTypeSet::write_module_constants(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer) {</span>
<span class="line-modified">!   assert(_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);</span>
<span class="line-modified">!   ClearArtifact&lt;ModPtr&gt; clear(_class_unload);</span>
<span class="line-modified">!   ModuleWriter mw(writer, _artifacts, _class_unload);</span>
<span class="line-modified">!   if (leakp_writer == NULL) {</span>
      ModuleWriterWithClear mwwc(&amp;mw, &amp;clear);
<span class="line-removed">-     KlassModuleWriterWithClear kmwwc(&amp;mwwc);</span>
<span class="line-removed">-     _artifacts-&gt;iterate_klasses(kmwwc);</span>
      ModuleCallback callback(&amp;mwwc);
      _subsystem_callback = &amp;callback;
      do_modules();
<span class="line-modified">!     return;</span>
    }
<span class="line-modified">!   LeakModuleWriter lmw(leakp_writer, _artifacts, _class_unload);</span>
<span class="line-modified">!   CompositeModuleWriter cmw(&amp;lmw, &amp;mw);</span>
<span class="line-modified">!   CompositeModuleWriterWithClear cmwwc(&amp;cmw, &amp;clear);</span>
<span class="line-modified">!   KlassCompositeModuleWriterWithClear kmwwc(&amp;cmwwc);</span>
<span class="line-modified">!   _artifacts-&gt;iterate_klasses(kmwwc);</span>
<span class="line-modified">!   CompositeModuleCallback callback(&amp;cmwwc);</span>
    _subsystem_callback = &amp;callback;
    do_modules();
  }
  
<span class="line-modified">! typedef CompositeFunctor&lt;CldPtr, CldWriter, ClearArtifact&lt;CldPtr&gt; &gt; CldWriterWithClear;</span>
<span class="line-modified">! typedef CompositeFunctor&lt;CldPtr, LeakCldWriter, CldWriter&gt; CompositeCldWriter;</span>
<span class="line-modified">! typedef CompositeFunctor&lt;CldPtr, CompositeCldWriter, ClearArtifact&lt;CldPtr&gt; &gt; CompositeCldWriterWithClear;</span>
<span class="line-modified">! typedef JfrArtifactCallbackHost&lt;CldPtr, CldWriterWithClear&gt; CldCallback;</span>
<span class="line-modified">! typedef JfrArtifactCallbackHost&lt;CldPtr, CompositeCldWriterWithClear&gt; CompositeCldCallback;</span>
  
<span class="line-modified">! class CldFieldSelector {</span>
   public:
    typedef CldPtr TypePtr;
    static TypePtr select(KlassPtr klass) {
      assert(klass != NULL, &quot;invariant&quot;);
<span class="line-modified">!     CldPtr cld = klass-&gt;class_loader_data();</span>
<span class="line-removed">-     return cld-&gt;is_unsafe_anonymous() ? NULL : cld;</span>
    }
  };
  
<span class="line-modified">! typedef KlassToFieldEnvelope&lt;CldFieldSelector, CldWriterWithClear&gt; KlassCldWriterWithClear;</span>
<span class="line-modified">! typedef KlassToFieldEnvelope&lt;CldFieldSelector, CompositeCldWriterWithClear&gt; KlassCompositeCldWriterWithClear;</span>
  
<span class="line-modified">! /*</span>
<span class="line-modified">!  * Composite operation</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * LeakpClassLoaderWriter -&gt;</span>
<span class="line-modified">!  *   ClassLoaderWriter -&gt;</span>
<span class="line-modified">!  *     ClearArtifact&lt;ClassLoaderData&gt;</span>
<span class="line-modified">!  */</span>
<span class="line-modified">! void JfrTypeSet::write_class_loader_constants(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer) {</span>
<span class="line-modified">!   assert(_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);</span>
<span class="line-modified">!   ClearArtifact&lt;CldPtr&gt; clear(_class_unload);</span>
<span class="line-modified">!   CldWriter cldw(writer, _artifacts, _class_unload);</span>
<span class="line-modified">!   if (leakp_writer == NULL) {</span>
      CldWriterWithClear cldwwc(&amp;cldw, &amp;clear);
<span class="line-removed">-     KlassCldWriterWithClear kcldwwc(&amp;cldwwc);</span>
<span class="line-removed">-     _artifacts-&gt;iterate_klasses(kcldwwc);</span>
      CldCallback callback(&amp;cldwwc);
      _subsystem_callback = &amp;callback;
      do_class_loaders();
<span class="line-modified">!     return;</span>
    }
<span class="line-modified">!   LeakCldWriter lcldw(leakp_writer, _artifacts, _class_unload);</span>
<span class="line-modified">!   CompositeCldWriter ccldw(&amp;lcldw, &amp;cldw);</span>
<span class="line-modified">!   CompositeCldWriterWithClear ccldwwc(&amp;ccldw, &amp;clear);</span>
<span class="line-modified">!   KlassCompositeCldWriterWithClear kcclwwc(&amp;ccldwwc);</span>
<span class="line-modified">!   _artifacts-&gt;iterate_klasses(kcclwwc);</span>
<span class="line-modified">!   CompositeCldCallback callback(&amp;ccldwwc);</span>
    _subsystem_callback = &amp;callback;
    do_class_loaders();
  }
  
<span class="line-modified">! template &lt;bool predicate_bool, typename MethodFunctor&gt;</span>
  class MethodIteratorHost {
   private:
<span class="line-modified">!   MethodFunctor _method_functor;</span>
<span class="line-modified">!   MethodUsedPredicate&lt;predicate_bool&gt; _method_used_predicate;</span>
<span class="line-modified">!   MethodFlagPredicate _method_flag_predicate;</span>
<span class="line-modified">! </span>
   public:
    MethodIteratorHost(JfrCheckpointWriter* writer,
<span class="line-modified">!                      JfrArtifactSet* artifacts,</span>
<span class="line-modified">!                      bool class_unload,</span>
                       bool skip_header = false) :
<span class="line-modified">!     _method_functor(writer, artifacts, class_unload, skip_header),</span>
<span class="line-modified">!     _method_used_predicate(class_unload),</span>
<span class="line-modified">!     _method_flag_predicate(class_unload) {}</span>
  
    bool operator()(KlassPtr klass) {
      if (_method_used_predicate(klass)) {
<span class="line-removed">-       assert(METHOD_AND_CLASS_USED_ANY_EPOCH(klass), &quot;invariant&quot;);</span>
        const InstanceKlass* ik = InstanceKlass::cast(klass);
        const int len = ik-&gt;methods()-&gt;length();
<span class="line-modified">!       for (int i = 0; i &lt; len; ++i) {</span>
<span class="line-modified">!         MethodPtr method = ik-&gt;methods()-&gt;at(i);</span>
<span class="line-modified">!         if (_method_flag_predicate(method)) {</span>
<span class="line-modified">!           _method_functor(method);</span>
          }
        }
      }
<span class="line-modified">!     return true;</span>
    }
  
<span class="line-modified">!   int count() const { return _method_functor.count(); }</span>
<span class="line-modified">!   void add(int count) { _method_functor.add(count); }</span>
  };
  
<span class="line-modified">! typedef MethodIteratorHost&lt;true /*leakp */,  MethodWriterImpl&gt; LeakMethodWriter;</span>
<span class="line-modified">! typedef MethodIteratorHost&lt;false, MethodWriterImpl&gt; MethodWriter;</span>
<span class="line-modified">! typedef CompositeFunctor&lt;KlassPtr, LeakMethodWriter, MethodWriter&gt; CompositeMethodWriter;</span>
<span class="line-modified">! </span>
<span class="line-modified">! /*</span>
<span class="line-modified">!  * Composite operation</span>
<span class="line-modified">!  *</span>
<span class="line-removed">-  * LeakpMethodWriter -&gt;</span>
<span class="line-removed">-  *   MethodWriter</span>
<span class="line-removed">-  */</span>
<span class="line-removed">- void JfrTypeSet::write_method_constants(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer) {</span>
<span class="line-removed">-   assert(_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);</span>
<span class="line-removed">-   MethodWriter mw(writer, _artifacts, _class_unload);</span>
<span class="line-removed">-   if (leakp_writer == NULL) {</span>
<span class="line-removed">-     _artifacts-&gt;iterate_klasses(mw);</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   LeakMethodWriter lpmw(leakp_writer, _artifacts, _class_unload);</span>
<span class="line-removed">-   CompositeMethodWriter cmw(&amp;lpmw, &amp;mw);</span>
<span class="line-removed">-   _artifacts-&gt;iterate_klasses(cmw);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- static void write_symbols_leakp(JfrCheckpointWriter* leakp_writer, JfrArtifactSet* artifacts, bool class_unload) {</span>
<span class="line-removed">-   assert(leakp_writer != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   assert(artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   LeakKlassSymbolWriter lpksw(leakp_writer, artifacts, class_unload);</span>
<span class="line-removed">-   artifacts-&gt;iterate_klasses(lpksw);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- static void write_symbols(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer, JfrArtifactSet* artifacts, bool class_unload) {</span>
<span class="line-removed">-   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   assert(artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   if (leakp_writer != NULL) {</span>
<span class="line-removed">-     write_symbols_leakp(leakp_writer, artifacts, class_unload);</span>
    }
<span class="line-modified">!   // iterate all registered symbols</span>
<span class="line-removed">-   SymbolEntryWriter symbol_writer(writer, artifacts, class_unload);</span>
<span class="line-removed">-   artifacts-&gt;iterate_symbols(symbol_writer);</span>
<span class="line-removed">-   CStringEntryWriter cstring_writer(writer, artifacts, class_unload, true); // skip header</span>
<span class="line-removed">-   artifacts-&gt;iterate_cstrings(cstring_writer);</span>
<span class="line-removed">-   symbol_writer.add(cstring_writer.count());</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! bool JfrTypeSet::_class_unload = false;</span>
<span class="line-modified">! JfrArtifactSet* JfrTypeSet::_artifacts = NULL;</span>
<span class="line-modified">! JfrArtifactClosure* JfrTypeSet::_subsystem_callback = NULL;</span>
  
<span class="line-modified">! void JfrTypeSet::write_symbol_constants(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer) {</span>
<span class="line-modified">!   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);</span>
<span class="line-modified">!   write_symbols(writer, leakp_writer, _artifacts, _class_unload);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void JfrTypeSet::do_unloaded_klass(Klass* klass) {</span>
<span class="line-modified">!   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   if (IS_JDK_JFR_EVENT_SUBKLASS(klass)) {</span>
<span class="line-modified">!     JfrEventClasses::increment_unloaded_event_class();</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (USED_THIS_EPOCH(klass)) { // includes leakp subset</span>
<span class="line-modified">!     _subsystem_callback-&gt;do_artifact(klass);</span>
<span class="line-modified">!     return;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (klass-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass()) || klass == SystemDictionary::Object_klass()) {</span>
<span class="line-removed">-     SET_LEAKP_USED_THIS_EPOCH(klass); // tag leakp &quot;safe byte&quot; for subset inclusion</span>
<span class="line-removed">-     _subsystem_callback-&gt;do_artifact(klass);</span>
    }
  }
  
<span class="line-modified">! void JfrTypeSet::do_klass(Klass* klass) {</span>
<span class="line-modified">!   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   if (USED_PREV_EPOCH(klass)) { // includes leakp subset</span>
<span class="line-modified">!     _subsystem_callback-&gt;do_artifact(klass);</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (klass-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass()) || klass == SystemDictionary::Object_klass()) {</span>
<span class="line-removed">-     SET_LEAKP_USED_PREV_EPOCH(klass); // tag leakp &quot;safe byte&quot; for subset inclusion</span>
<span class="line-removed">-     _subsystem_callback-&gt;do_artifact(klass);</span>
<span class="line-removed">-   }</span>
  }
  
<span class="line-modified">! void JfrTypeSet::do_klasses() {</span>
<span class="line-modified">!   if (_class_unload) {</span>
<span class="line-modified">!     ClassLoaderDataGraph::classes_unloading_do(&amp;do_unloaded_klass);</span>
<span class="line-modified">!     return;</span>
<span class="line-modified">!   }</span>
<span class="line-removed">-   ClassLoaderDataGraph::classes_do(&amp;do_klass);</span>
  }
  
<span class="line-modified">! void JfrTypeSet::do_unloaded_package(PackageEntry* entry) {</span>
    assert(entry != NULL, &quot;invariant&quot;);
<span class="line-modified">!   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   if (ANY_USED_THIS_EPOCH(entry)) { // includes leakp subset</span>
<span class="line-modified">!     _subsystem_callback-&gt;do_artifact(entry);</span>
<span class="line-modified">!   }</span>
  }
  
<span class="line-modified">! void JfrTypeSet::do_package(PackageEntry* entry) {</span>
<span class="line-modified">!   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   if (ANY_USED_PREV_EPOCH(entry)) { // includes leakp subset</span>
<span class="line-modified">!     _subsystem_callback-&gt;do_artifact(entry);</span>
<span class="line-modified">!   }</span>
  }
  
<span class="line-modified">! void JfrTypeSet::do_packages() {</span>
<span class="line-modified">!   if (_class_unload) {</span>
<span class="line-modified">!     ClassLoaderDataGraph::packages_unloading_do(&amp;do_unloaded_package);</span>
<span class="line-modified">!     return;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   ClassLoaderDataGraph::packages_do(&amp;do_package);</span>
  }
<span class="line-modified">! void JfrTypeSet::do_unloaded_module(ModuleEntry* entry) {</span>
    assert(entry != NULL, &quot;invariant&quot;);
<span class="line-modified">!   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   if (ANY_USED_THIS_EPOCH(entry)) { // includes leakp subset</span>
<span class="line-modified">!     _subsystem_callback-&gt;do_artifact(entry);</span>
<span class="line-removed">-   }</span>
  }
  
<span class="line-modified">! void JfrTypeSet::do_module(ModuleEntry* entry) {</span>
<span class="line-modified">!   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   if (ANY_USED_PREV_EPOCH(entry)) { // includes leakp subset</span>
<span class="line-modified">!     _subsystem_callback-&gt;do_artifact(entry);</span>
<span class="line-modified">!   }</span>
  }
  
<span class="line-modified">! void JfrTypeSet::do_modules() {</span>
<span class="line-modified">!   if (_class_unload) {</span>
<span class="line-modified">!     ClassLoaderDataGraph::modules_unloading_do(&amp;do_unloaded_module);</span>
      return;
    }
<span class="line-modified">!   ClassLoaderDataGraph::modules_do(&amp;do_module);</span>
  }
  
<span class="line-modified">! void JfrTypeSet::do_unloaded_class_loader_data(ClassLoaderData* cld) {</span>
<span class="line-modified">!   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   if (ANY_USED_THIS_EPOCH(cld)) { // includes leakp subset</span>
<span class="line-removed">-     _subsystem_callback-&gt;do_artifact(cld);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void JfrTypeSet::do_class_loader_data(ClassLoaderData* cld) {</span>
<span class="line-removed">-   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   if (ANY_USED_PREV_EPOCH(cld)) { // includes leakp subset</span>
<span class="line-removed">-     _subsystem_callback-&gt;do_artifact(cld);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- class CLDCallback : public CLDClosure {</span>
<span class="line-removed">-  private:</span>
<span class="line-removed">-   bool _class_unload;</span>
<span class="line-removed">-  public:</span>
<span class="line-removed">-   CLDCallback(bool class_unload) : _class_unload(class_unload) {}</span>
<span class="line-removed">-   void do_cld(ClassLoaderData* cld) {</span>
<span class="line-removed">-      assert(cld != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-     if (cld-&gt;is_unsafe_anonymous()) {</span>
<span class="line-removed">-       return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (_class_unload) {</span>
<span class="line-removed">-       JfrTypeSet::do_unloaded_class_loader_data(cld);</span>
<span class="line-removed">-       return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     JfrTypeSet::do_class_loader_data(cld);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- };</span>
  
<span class="line-modified">! void JfrTypeSet::do_class_loaders() {</span>
<span class="line-modified">!   CLDCallback cld_cb(_class_unload);</span>
<span class="line-modified">!   if (_class_unload) {</span>
<span class="line-removed">-     ClassLoaderDataGraph::cld_unloading_do(&amp;cld_cb);</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   ClassLoaderDataGraph::loaded_cld_do(&amp;cld_cb);</span>
  }
  
<span class="line-modified">! static void clear_artifacts(JfrArtifactSet* artifacts,</span>
<span class="line-modified">!                             bool class_unload) {</span>
<span class="line-modified">!   assert(artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // untag</span>
<span class="line-modified">!   ClearKlassAndMethods clear(class_unload);</span>
<span class="line-modified">!   artifacts-&gt;iterate_klasses(clear);</span>
<span class="line-modified">!   artifacts-&gt;clear();</span>
  }
  
<span class="line-modified">! /**</span>
<span class="line-modified">!  * Write all &quot;tagged&quot; (in-use) constant artifacts and their dependencies.</span>
<span class="line-modified">!  */</span>
<span class="line-removed">- void JfrTypeSet::serialize(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer, bool class_unload) {</span>
<span class="line-removed">-   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   ResourceMark rm;</span>
<span class="line-removed">-   // initialization begin</span>
    _class_unload = class_unload;
<span class="line-modified">!   ++checkpoint_id;</span>
    if (_artifacts == NULL) {
      _artifacts = new JfrArtifactSet(class_unload);
<span class="line-removed">-     _subsystem_callback = NULL;</span>
    } else {
<span class="line-modified">!     _artifacts-&gt;initialize(class_unload);</span>
<span class="line-removed">-     _subsystem_callback = NULL;</span>
    }
    assert(_artifacts != NULL, &quot;invariant&quot;);
    assert(!_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);
<span class="line-modified">!   assert(_subsystem_callback == NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   // initialization complete</span>
  
    // write order is important because an individual write step
    // might tag an artifact to be written in a subsequent step
<span class="line-modified">!   write_klass_constants(writer, leakp_writer);</span>
<span class="line-modified">!   if (_artifacts-&gt;has_klass_entries()) {</span>
<span class="line-removed">-     write_package_constants(writer, leakp_writer);</span>
<span class="line-removed">-     write_module_constants(writer, leakp_writer);</span>
<span class="line-removed">-     write_class_loader_constants(writer, leakp_writer);</span>
<span class="line-removed">-     write_method_constants(writer, leakp_writer);</span>
<span class="line-removed">-     write_symbol_constants(writer, leakp_writer);</span>
<span class="line-removed">-     clear_artifacts(_artifacts, class_unload);</span>
    }
  }
<span class="line-new-header">--- 493,516 ---</span>
      PkgPtr pkg = klass-&gt;package();
      return pkg != NULL ? pkg-&gt;module() : NULL;
    }
  };
  
<span class="line-modified">! typedef SerializePredicate&lt;ModPtr&gt; ModulePredicate;</span>
<span class="line-modified">! typedef JfrPredicatedTypeWriterImplHost&lt;ModPtr, ModulePredicate, write__module&gt; ModuleWriterImpl;</span>
<span class="line-added">+ typedef JfrTypeWriterHost&lt;ModuleWriterImpl, TYPE_MODULE&gt; ModuleWriter;</span>
<span class="line-added">+ typedef CompositeFunctor&lt;ModPtr, ModuleWriter, ClearArtifact&lt;ModPtr&gt; &gt; ModuleWriterWithClear;</span>
<span class="line-added">+ typedef JfrArtifactCallbackHost&lt;ModPtr, ModuleWriterWithClear&gt; ModuleCallback;</span>
<span class="line-added">+ typedef KlassToFieldEnvelope&lt;ModuleFieldSelector, ModuleWriter&gt; KlassModuleWriter;</span>
  
<span class="line-modified">! typedef LeakPredicate&lt;ModPtr&gt; LeakModulePredicate;</span>
<span class="line-modified">! typedef JfrPredicatedTypeWriterImplHost&lt;ModPtr, LeakModulePredicate, write__module__leakp&gt; LeakModuleWriterImpl;</span>
<span class="line-added">+ typedef JfrTypeWriterHost&lt;LeakModuleWriterImpl, TYPE_MODULE&gt; LeakModuleWriter;</span>
  
<span class="line-modified">! typedef CompositeFunctor&lt;ModPtr, LeakModuleWriter, ModuleWriter&gt; CompositeModuleWriter;</span>
<span class="line-modified">! typedef KlassToFieldEnvelope&lt;ModuleFieldSelector, CompositeModuleWriter&gt; KlassCompositeModuleWriter;</span>
<span class="line-modified">! typedef CompositeFunctor&lt;ModPtr, CompositeModuleWriter, ClearArtifact&lt;ModPtr&gt; &gt; CompositeModuleWriterWithClear;</span>
<span class="line-modified">! typedef JfrArtifactCallbackHost&lt;ModPtr, CompositeModuleWriterWithClear&gt; CompositeModuleCallback;</span>
<span class="line-modified">! </span>
<span class="line-modified">! static void write_modules() {</span>
<span class="line-modified">!   assert(_writer != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   ModuleWriter mw(_writer, _class_unload);</span>
<span class="line-modified">!   KlassModuleWriter kmw(&amp;mw);</span>
<span class="line-modified">!   if (current_epoch()) {</span>
<span class="line-modified">!     _artifacts-&gt;iterate_klasses(kmw);</span>
<span class="line-modified">!     _artifacts-&gt;tally(mw);</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   assert(previous_epoch(), &quot;invariant&quot;);</span>
<span class="line-added">+   if (_leakp_writer == NULL) {</span>
<span class="line-added">+     _artifacts-&gt;iterate_klasses(kmw);</span>
<span class="line-added">+     ClearArtifact&lt;ModPtr&gt; clear;</span>
      ModuleWriterWithClear mwwc(&amp;mw, &amp;clear);
      ModuleCallback callback(&amp;mwwc);
      _subsystem_callback = &amp;callback;
      do_modules();
<span class="line-modified">!   } else {</span>
<span class="line-added">+     LeakModuleWriter lmw(_leakp_writer, _class_unload);</span>
<span class="line-added">+     CompositeModuleWriter cmw(&amp;lmw, &amp;mw);</span>
<span class="line-added">+     KlassCompositeModuleWriter kcpw(&amp;cmw);</span>
<span class="line-added">+     _artifacts-&gt;iterate_klasses(kcpw);</span>
<span class="line-added">+     ClearArtifact&lt;ModPtr&gt; clear;</span>
<span class="line-added">+     CompositeModuleWriterWithClear cmwwc(&amp;cmw, &amp;clear);</span>
<span class="line-added">+     CompositeModuleCallback callback(&amp;cmwwc);</span>
<span class="line-added">+     _subsystem_callback = &amp;callback;</span>
<span class="line-added">+     do_modules();</span>
    }
<span class="line-modified">!   _artifacts-&gt;tally(mw);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! typedef JfrArtifactCallbackHost&lt;ModPtr, ClearArtifact&lt;ModPtr&gt; &gt; ClearModuleCallback;</span>
<span class="line-modified">! </span>
<span class="line-modified">! static void clear_modules() {</span>
<span class="line-added">+   ClearArtifact&lt;ModPtr&gt; clear;</span>
<span class="line-added">+   ClearModuleCallback callback(&amp;clear);</span>
    _subsystem_callback = &amp;callback;
    do_modules();
  }
  
<span class="line-modified">! static int write_classloader(JfrCheckpointWriter* writer, CldPtr cld, bool leakp) {</span>
<span class="line-modified">!   assert(cld != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(!cld-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);</span>
<span class="line-modified">!   // class loader type</span>
<span class="line-modified">!   const Klass* class_loader_klass = cld-&gt;class_loader_klass();</span>
<span class="line-added">+   if (class_loader_klass == NULL) {</span>
<span class="line-added">+     // (primordial) boot class loader</span>
<span class="line-added">+     writer-&gt;write(artifact_id(cld)); // class loader instance id</span>
<span class="line-added">+     writer-&gt;write((traceid)0);  // class loader type id (absence of)</span>
<span class="line-added">+     writer-&gt;write(get_bootstrap_name(leakp)); // maps to synthetic name -&gt; &quot;bootstrap&quot;</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     writer-&gt;write(artifact_id(cld)); // class loader instance id</span>
<span class="line-added">+     writer-&gt;write(artifact_id(class_loader_klass)); // class loader type id</span>
<span class="line-added">+     writer-&gt;write(mark_symbol(cld-&gt;name(), leakp)); // class loader instance name</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return 1;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ int write__classloader(JfrCheckpointWriter* writer, const void* c) {</span>
<span class="line-added">+   assert(c != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   CldPtr cld = (CldPtr)c;</span>
<span class="line-added">+   set_serialized(cld);</span>
<span class="line-added">+   return write_classloader(writer, cld, false);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ int write__classloader__leakp(JfrCheckpointWriter* writer, const void* c) {</span>
<span class="line-added">+   assert(c != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   CldPtr cld = (CldPtr)c;</span>
<span class="line-added">+   CLEAR_LEAKP(cld);</span>
<span class="line-added">+   return write_classloader(writer, cld, true);</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! static void do_class_loader_data(ClassLoaderData* cld) {</span>
<span class="line-added">+   do_previous_epoch_artifact(_subsystem_callback, cld);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ class KlassCldFieldSelector {</span>
   public:
    typedef CldPtr TypePtr;
    static TypePtr select(KlassPtr klass) {
      assert(klass != NULL, &quot;invariant&quot;);
<span class="line-modified">!     return get_cld(klass);</span>
    }
  };
  
<span class="line-modified">! class ModuleCldFieldSelector {</span>
<span class="line-modified">! public:</span>
<span class="line-added">+   typedef CldPtr TypePtr;</span>
<span class="line-added">+   static TypePtr select(KlassPtr klass) {</span>
<span class="line-added">+     assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+     ModPtr mod = ModuleFieldSelector::select(klass);</span>
<span class="line-added">+     return mod != NULL ? mod-&gt;loader_data() : NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
  
<span class="line-modified">! class CLDCallback : public CLDClosure {</span>
<span class="line-modified">!  public:</span>
<span class="line-modified">!   CLDCallback() {}</span>
<span class="line-modified">!   void do_cld(ClassLoaderData* cld) {</span>
<span class="line-modified">!     assert(cld != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!     if (cld-&gt;is_unsafe_anonymous()) {</span>
<span class="line-modified">!       return;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     do_class_loader_data(cld);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! };</span>
<span class="line-modified">! </span>
<span class="line-added">+ static void do_class_loaders() {</span>
<span class="line-added">+   CLDCallback cld_cb;</span>
<span class="line-added">+   ClassLoaderDataGraph::loaded_cld_do(&amp;cld_cb);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ typedef SerializePredicate&lt;CldPtr&gt; CldPredicate;</span>
<span class="line-added">+ typedef JfrPredicatedTypeWriterImplHost&lt;CldPtr, CldPredicate, write__classloader&gt; CldWriterImpl;</span>
<span class="line-added">+ typedef JfrTypeWriterHost&lt;CldWriterImpl, TYPE_CLASSLOADER&gt; CldWriter;</span>
<span class="line-added">+ typedef CompositeFunctor&lt;CldPtr, CldWriter, ClearArtifact&lt;CldPtr&gt; &gt; CldWriterWithClear;</span>
<span class="line-added">+ typedef JfrArtifactCallbackHost&lt;CldPtr, CldWriterWithClear&gt; CldCallback;</span>
<span class="line-added">+ typedef KlassToFieldEnvelope&lt;KlassCldFieldSelector, CldWriter&gt; KlassCldWriter;</span>
<span class="line-added">+ typedef KlassToFieldEnvelope&lt;ModuleCldFieldSelector, CldWriter&gt; ModuleCldWriter;</span>
<span class="line-added">+ typedef CompositeFunctor&lt;KlassPtr, KlassCldWriter, ModuleCldWriter&gt; KlassAndModuleCldWriter;</span>
<span class="line-added">+ </span>
<span class="line-added">+ typedef LeakPredicate&lt;CldPtr&gt; LeakCldPredicate;</span>
<span class="line-added">+ typedef JfrPredicatedTypeWriterImplHost&lt;CldPtr, LeakCldPredicate, write__classloader__leakp&gt; LeakCldWriterImpl;</span>
<span class="line-added">+ typedef JfrTypeWriterHost&lt;LeakCldWriterImpl, TYPE_CLASSLOADER&gt; LeakCldWriter;</span>
<span class="line-added">+ </span>
<span class="line-added">+ typedef CompositeFunctor&lt;CldPtr, LeakCldWriter, CldWriter&gt; CompositeCldWriter;</span>
<span class="line-added">+ typedef KlassToFieldEnvelope&lt;KlassCldFieldSelector, CompositeCldWriter&gt; KlassCompositeCldWriter;</span>
<span class="line-added">+ typedef KlassToFieldEnvelope&lt;ModuleCldFieldSelector, CompositeCldWriter&gt; ModuleCompositeCldWriter;</span>
<span class="line-added">+ typedef CompositeFunctor&lt;KlassPtr, KlassCompositeCldWriter, ModuleCompositeCldWriter&gt; KlassAndModuleCompositeCldWriter;</span>
<span class="line-added">+ typedef CompositeFunctor&lt;CldPtr, CompositeCldWriter, ClearArtifact&lt;CldPtr&gt; &gt; CompositeCldWriterWithClear;</span>
<span class="line-added">+ typedef JfrArtifactCallbackHost&lt;CldPtr, CompositeCldWriterWithClear&gt; CompositeCldCallback;</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void write_classloaders() {</span>
<span class="line-added">+   assert(_writer != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   CldWriter cldw(_writer, _class_unload);</span>
<span class="line-added">+   KlassCldWriter kcw(&amp;cldw);</span>
<span class="line-added">+   ModuleCldWriter mcw(&amp;cldw);</span>
<span class="line-added">+   KlassAndModuleCldWriter kmcw(&amp;kcw, &amp;mcw);</span>
<span class="line-added">+   if (current_epoch()) {</span>
<span class="line-added">+     _artifacts-&gt;iterate_klasses(kmcw);</span>
<span class="line-added">+     _artifacts-&gt;tally(cldw);</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   assert(previous_epoch(), &quot;invariant&quot;);</span>
<span class="line-added">+   if (_leakp_writer == NULL) {</span>
<span class="line-added">+     _artifacts-&gt;iterate_klasses(kmcw);</span>
<span class="line-added">+     ClearArtifact&lt;CldPtr&gt; clear;</span>
      CldWriterWithClear cldwwc(&amp;cldw, &amp;clear);
      CldCallback callback(&amp;cldwwc);
      _subsystem_callback = &amp;callback;
      do_class_loaders();
<span class="line-modified">!   } else {</span>
<span class="line-added">+     LeakCldWriter lcldw(_leakp_writer, _class_unload);</span>
<span class="line-added">+     CompositeCldWriter ccldw(&amp;lcldw, &amp;cldw);</span>
<span class="line-added">+     KlassCompositeCldWriter kccldw(&amp;ccldw);</span>
<span class="line-added">+     ModuleCompositeCldWriter mccldw(&amp;ccldw);</span>
<span class="line-added">+     KlassAndModuleCompositeCldWriter kmccldw(&amp;kccldw, &amp;mccldw);</span>
<span class="line-added">+     _artifacts-&gt;iterate_klasses(kmccldw);</span>
<span class="line-added">+     ClearArtifact&lt;CldPtr&gt; clear;</span>
<span class="line-added">+     CompositeCldWriterWithClear ccldwwc(&amp;ccldw, &amp;clear);</span>
<span class="line-added">+     CompositeCldCallback callback(&amp;ccldwwc);</span>
<span class="line-added">+     _subsystem_callback = &amp;callback;</span>
<span class="line-added">+     do_class_loaders();</span>
    }
<span class="line-modified">!   _artifacts-&gt;tally(cldw);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! typedef JfrArtifactCallbackHost&lt;CldPtr, ClearArtifact&lt;CldPtr&gt; &gt; ClearCLDCallback;</span>
<span class="line-modified">! </span>
<span class="line-modified">! static void clear_classloaders() {</span>
<span class="line-added">+   ClearArtifact&lt;CldPtr&gt; clear;</span>
<span class="line-added">+   ClearCLDCallback callback(&amp;clear);</span>
    _subsystem_callback = &amp;callback;
    do_class_loaders();
  }
  
<span class="line-modified">! static u1 get_visibility(MethodPtr method) {</span>
<span class="line-added">+   assert(method != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   return const_cast&lt;Method*&gt;(method)-&gt;is_hidden() ? (u1)1 : (u1)0;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;&gt;</span>
<span class="line-added">+ void set_serialized&lt;Method&gt;(MethodPtr method) {</span>
<span class="line-added">+   assert(method != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   SET_METHOD_SERIALIZED(method);</span>
<span class="line-added">+   assert(IS_METHOD_SERIALIZED(method), &quot;invariant&quot;);</span>
<span class="line-added">+   CLEAR_THIS_EPOCH_METHOD_CLEARED_BIT(method);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static int write_method(JfrCheckpointWriter* writer, MethodPtr method, bool leakp) {</span>
<span class="line-added">+   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(method != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(_artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   KlassPtr klass = method-&gt;method_holder();</span>
<span class="line-added">+   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   writer-&gt;write(method_id(klass, method));</span>
<span class="line-added">+   writer-&gt;write(artifact_id(klass));</span>
<span class="line-added">+   writer-&gt;write(mark_symbol(method-&gt;name(), leakp));</span>
<span class="line-added">+   writer-&gt;write(mark_symbol(method-&gt;signature(), leakp));</span>
<span class="line-added">+   writer-&gt;write((u2)get_flags(method));</span>
<span class="line-added">+   writer-&gt;write(get_visibility(method));</span>
<span class="line-added">+   return 1;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ int write__method(JfrCheckpointWriter* writer, const void* m) {</span>
<span class="line-added">+   assert(m != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   MethodPtr method = (MethodPtr)m;</span>
<span class="line-added">+   set_serialized(method);</span>
<span class="line-added">+   return write_method(writer, method, false);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ int write__method__leakp(JfrCheckpointWriter* writer, const void* m) {</span>
<span class="line-added">+   assert(m != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   MethodPtr method = (MethodPtr)m;</span>
<span class="line-added">+   return write_method(writer, method, true);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ class BitMapFilter {</span>
<span class="line-added">+   ResourceBitMap _bitmap;</span>
<span class="line-added">+  public:</span>
<span class="line-added">+   explicit BitMapFilter(int length = 0) : _bitmap((size_t)length) {}</span>
<span class="line-added">+   bool operator()(size_t idx) {</span>
<span class="line-added">+     if (_bitmap.size() == 0) {</span>
<span class="line-added">+       return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (_bitmap.at(idx)) {</span>
<span class="line-added">+       return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     _bitmap.set_bit(idx);</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ class AlwaysTrue {</span>
<span class="line-added">+  public:</span>
<span class="line-added">+   explicit AlwaysTrue(int length = 0) {}</span>
<span class="line-added">+   bool operator()(size_t idx) {</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename MethodCallback, typename KlassCallback, class Filter, bool leakp&gt;</span>
  class MethodIteratorHost {
   private:
<span class="line-modified">!   MethodCallback _method_cb;</span>
<span class="line-modified">!   KlassCallback _klass_cb;</span>
<span class="line-modified">!   MethodUsedPredicate&lt;leakp&gt; _method_used_predicate;</span>
<span class="line-modified">!   MethodFlagPredicate&lt;leakp&gt; _method_flag_predicate;</span>
   public:
    MethodIteratorHost(JfrCheckpointWriter* writer,
<span class="line-modified">!                      bool current_epoch = false,</span>
<span class="line-modified">!                      bool class_unload = false,</span>
                       bool skip_header = false) :
<span class="line-modified">!     _method_cb(writer, class_unload, skip_header),</span>
<span class="line-modified">!     _klass_cb(writer, class_unload, skip_header),</span>
<span class="line-modified">!     _method_used_predicate(current_epoch),</span>
<span class="line-added">+     _method_flag_predicate(current_epoch) {}</span>
  
    bool operator()(KlassPtr klass) {
      if (_method_used_predicate(klass)) {
        const InstanceKlass* ik = InstanceKlass::cast(klass);
        const int len = ik-&gt;methods()-&gt;length();
<span class="line-modified">!       Filter filter(ik-&gt;previous_versions() != NULL ? len : 0);</span>
<span class="line-modified">!       while (ik != NULL) {</span>
<span class="line-modified">!         for (int i = 0; i &lt; len; ++i) {</span>
<span class="line-modified">!           MethodPtr method = ik-&gt;methods()-&gt;at(i);</span>
<span class="line-added">+           if (_method_flag_predicate(method) &amp;&amp; filter(i)) {</span>
<span class="line-added">+             _method_cb(method);</span>
<span class="line-added">+           }</span>
          }
<span class="line-added">+         // There can be multiple versions of the same method running</span>
<span class="line-added">+         // due to redefinition. Need to inspect the complete set of methods.</span>
<span class="line-added">+         ik = ik-&gt;previous_versions();</span>
        }
      }
<span class="line-modified">!     return _klass_cb(klass);</span>
    }
  
<span class="line-modified">!   int count() const { return _method_cb.count(); }</span>
<span class="line-modified">!   void add(int count) { _method_cb.add(count); }</span>
  };
  
<span class="line-modified">! template &lt;typename T, template &lt;typename&gt; class Impl&gt;</span>
<span class="line-modified">! class Wrapper {</span>
<span class="line-modified">!   Impl&lt;T&gt; _t;</span>
<span class="line-modified">!  public:</span>
<span class="line-modified">!   Wrapper(JfrCheckpointWriter*, bool, bool) : _t() {}</span>
<span class="line-modified">!   bool operator()(T const&amp; value) {</span>
<span class="line-modified">!     return _t(value);</span>
    }
<span class="line-modified">! };</span>
  
<span class="line-modified">! template &lt;typename T&gt;</span>
<span class="line-modified">! class EmptyStub {</span>
<span class="line-modified">!  public:</span>
<span class="line-added">+   bool operator()(T const&amp; value) { return true; }</span>
<span class="line-added">+ };</span>
  
<span class="line-modified">! typedef SerializePredicate&lt;MethodPtr&gt; MethodPredicate;</span>
<span class="line-modified">! typedef JfrPredicatedTypeWriterImplHost&lt;MethodPtr, MethodPredicate, write__method&gt; MethodWriterImplTarget;</span>
<span class="line-modified">! typedef Wrapper&lt;KlassPtr, EmptyStub&gt; KlassCallbackStub;</span>
<span class="line-modified">! typedef JfrTypeWriterHost&lt;MethodWriterImplTarget, TYPE_METHOD&gt; MethodWriterImpl;</span>
<span class="line-modified">! typedef MethodIteratorHost&lt;MethodWriterImpl, KlassCallbackStub, BitMapFilter, false&gt; MethodWriter;</span>
<span class="line-added">+ </span>
<span class="line-added">+ typedef LeakPredicate&lt;MethodPtr&gt; LeakMethodPredicate;</span>
<span class="line-added">+ typedef JfrPredicatedTypeWriterImplHost&lt;MethodPtr, LeakMethodPredicate, write__method__leakp&gt; LeakMethodWriterImplTarget;</span>
<span class="line-added">+ typedef JfrTypeWriterHost&lt;LeakMethodWriterImplTarget, TYPE_METHOD&gt; LeakMethodWriterImpl;</span>
<span class="line-added">+ typedef MethodIteratorHost&lt;LeakMethodWriterImpl, KlassCallbackStub, BitMapFilter, true&gt; LeakMethodWriter;</span>
<span class="line-added">+ typedef MethodIteratorHost&lt;LeakMethodWriterImpl, KlassCallbackStub, BitMapFilter, true&gt; LeakMethodWriter;</span>
<span class="line-added">+ typedef CompositeFunctor&lt;KlassPtr, LeakMethodWriter, MethodWriter&gt; CompositeMethodWriter;</span>
  
<span class="line-modified">! static void write_methods() {</span>
<span class="line-modified">!   assert(_writer != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   MethodWriter mw(_writer, current_epoch(), _class_unload);</span>
<span class="line-modified">!   if (_leakp_writer == NULL) {</span>
<span class="line-modified">!     _artifacts-&gt;iterate_klasses(mw);</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     LeakMethodWriter lpmw(_leakp_writer, current_epoch(), _class_unload);</span>
<span class="line-modified">!     CompositeMethodWriter cmw(&amp;lpmw, &amp;mw);</span>
<span class="line-modified">!     _artifacts-&gt;iterate_klasses(cmw);</span>
    }
<span class="line-added">+   _artifacts-&gt;tally(mw);</span>
  }
  
<span class="line-modified">! template &lt;&gt;</span>
<span class="line-modified">! void set_serialized&lt;JfrSymbolId::SymbolEntry&gt;(SymbolEntryPtr ptr) {</span>
<span class="line-modified">!   assert(ptr != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   ptr-&gt;set_serialized();</span>
<span class="line-modified">!   assert(ptr-&gt;is_serialized(), &quot;invariant&quot;);</span>
  }
  
<span class="line-modified">! template &lt;&gt;</span>
<span class="line-modified">! void set_serialized&lt;JfrSymbolId::CStringEntry&gt;(CStringEntryPtr ptr) {</span>
<span class="line-modified">!   assert(ptr != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   ptr-&gt;set_serialized();</span>
<span class="line-modified">!   assert(ptr-&gt;is_serialized(), &quot;invariant&quot;);</span>
  }
  
<span class="line-modified">! static int write_symbol(JfrCheckpointWriter* writer, SymbolEntryPtr entry, bool leakp) {</span>
<span class="line-added">+   assert(writer != NULL, &quot;invariant&quot;);</span>
    assert(entry != NULL, &quot;invariant&quot;);
<span class="line-modified">!   ResourceMark rm;</span>
<span class="line-modified">!   writer-&gt;write(create_symbol_id(entry-&gt;id()));</span>
<span class="line-modified">!   writer-&gt;write(entry-&gt;value()-&gt;as_C_string());</span>
<span class="line-modified">!   return 1;</span>
  }
  
<span class="line-modified">! int write__symbol(JfrCheckpointWriter* writer, const void* e) {</span>
<span class="line-modified">!   assert(e != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   SymbolEntryPtr entry = (SymbolEntryPtr)e;</span>
<span class="line-modified">!   set_serialized(entry);</span>
<span class="line-modified">!   return write_symbol(writer, entry, false);</span>
  }
  
<span class="line-modified">! int write__symbol__leakp(JfrCheckpointWriter* writer, const void* e) {</span>
<span class="line-modified">!   assert(e != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   SymbolEntryPtr entry = (SymbolEntryPtr)e;</span>
<span class="line-modified">!   return write_symbol(writer, entry, true);</span>
  }
<span class="line-modified">! </span>
<span class="line-added">+ static int write_cstring(JfrCheckpointWriter* writer, CStringEntryPtr entry, bool leakp) {</span>
<span class="line-added">+   assert(writer != NULL, &quot;invariant&quot;);</span>
    assert(entry != NULL, &quot;invariant&quot;);
<span class="line-modified">!   writer-&gt;write(create_symbol_id(entry-&gt;id()));</span>
<span class="line-modified">!   writer-&gt;write(entry-&gt;value());</span>
<span class="line-modified">!   return 1;</span>
  }
  
<span class="line-modified">! int write__cstring(JfrCheckpointWriter* writer, const void* e) {</span>
<span class="line-modified">!   assert(e != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   CStringEntryPtr entry = (CStringEntryPtr)e;</span>
<span class="line-modified">!   set_serialized(entry);</span>
<span class="line-modified">!   return write_cstring(writer, entry, false);</span>
  }
  
<span class="line-modified">! int write__cstring__leakp(JfrCheckpointWriter* writer, const void* e) {</span>
<span class="line-modified">!   assert(e != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   CStringEntryPtr entry = (CStringEntryPtr)e;</span>
<span class="line-added">+   return write_cstring(writer, entry, true);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ typedef SymbolPredicate&lt;SymbolEntryPtr, false&gt; SymPredicate;</span>
<span class="line-added">+ typedef JfrPredicatedTypeWriterImplHost&lt;SymbolEntryPtr, SymPredicate, write__symbol&gt; SymbolEntryWriterImpl;</span>
<span class="line-added">+ typedef JfrTypeWriterHost&lt;SymbolEntryWriterImpl, TYPE_SYMBOL&gt; SymbolEntryWriter;</span>
<span class="line-added">+ typedef SymbolPredicate&lt;CStringEntryPtr, false&gt; CStringPredicate;</span>
<span class="line-added">+ typedef JfrPredicatedTypeWriterImplHost&lt;CStringEntryPtr, CStringPredicate, write__cstring&gt; CStringEntryWriterImpl;</span>
<span class="line-added">+ typedef JfrTypeWriterHost&lt;CStringEntryWriterImpl, TYPE_SYMBOL&gt; CStringEntryWriter;</span>
<span class="line-added">+ </span>
<span class="line-added">+ typedef SymbolPredicate&lt;SymbolEntryPtr, true&gt; LeakSymPredicate;</span>
<span class="line-added">+ typedef JfrPredicatedTypeWriterImplHost&lt;SymbolEntryPtr, LeakSymPredicate, write__symbol__leakp&gt; LeakSymbolEntryWriterImpl;</span>
<span class="line-added">+ typedef JfrTypeWriterHost&lt;LeakSymbolEntryWriterImpl, TYPE_SYMBOL&gt; LeakSymbolEntryWriter;</span>
<span class="line-added">+ typedef CompositeFunctor&lt;SymbolEntryPtr, LeakSymbolEntryWriter, SymbolEntryWriter&gt; CompositeSymbolWriter;</span>
<span class="line-added">+ typedef SymbolPredicate&lt;CStringEntryPtr, true&gt; LeakCStringPredicate;</span>
<span class="line-added">+ typedef JfrPredicatedTypeWriterImplHost&lt;CStringEntryPtr, LeakCStringPredicate, write__cstring__leakp&gt; LeakCStringEntryWriterImpl;</span>
<span class="line-added">+ typedef JfrTypeWriterHost&lt;LeakCStringEntryWriterImpl, TYPE_SYMBOL&gt; LeakCStringEntryWriter;</span>
<span class="line-added">+ typedef CompositeFunctor&lt;CStringEntryPtr, LeakCStringEntryWriter, CStringEntryWriter&gt; CompositeCStringWriter;</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void write_symbols_with_leakp() {</span>
<span class="line-added">+   assert(_leakp_writer != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   SymbolEntryWriter sw(_writer, _class_unload);</span>
<span class="line-added">+   LeakSymbolEntryWriter lsw(_leakp_writer, _class_unload);</span>
<span class="line-added">+   CompositeSymbolWriter csw(&amp;lsw, &amp;sw);</span>
<span class="line-added">+   _artifacts-&gt;iterate_symbols(csw);</span>
<span class="line-added">+   CStringEntryWriter ccsw(_writer, _class_unload, true); // skip header</span>
<span class="line-added">+   LeakCStringEntryWriter lccsw(_leakp_writer, _class_unload, true); // skip header</span>
<span class="line-added">+   CompositeCStringWriter cccsw(&amp;lccsw, &amp;ccsw);</span>
<span class="line-added">+   _artifacts-&gt;iterate_cstrings(cccsw);</span>
<span class="line-added">+   sw.add(ccsw.count());</span>
<span class="line-added">+   lsw.add(lccsw.count());</span>
<span class="line-added">+   _artifacts-&gt;tally(sw);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void write_symbols() {</span>
<span class="line-added">+   assert(_writer != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   if (_leakp_writer != NULL) {</span>
<span class="line-added">+     write_symbols_with_leakp();</span>
      return;
    }
<span class="line-modified">!   SymbolEntryWriter sw(_writer, _class_unload);</span>
<span class="line-added">+   _artifacts-&gt;iterate_symbols(sw);</span>
<span class="line-added">+   CStringEntryWriter csw(_writer, _class_unload, true); // skip header</span>
<span class="line-added">+   _artifacts-&gt;iterate_cstrings(csw);</span>
<span class="line-added">+   sw.add(csw.count());</span>
<span class="line-added">+   _artifacts-&gt;tally(sw);</span>
  }
  
<span class="line-modified">! typedef Wrapper&lt;KlassPtr, ClearArtifact&gt; ClearKlassBits;</span>
<span class="line-modified">! typedef Wrapper&lt;MethodPtr, ClearArtifact&gt; ClearMethodFlag;</span>
<span class="line-modified">! typedef MethodIteratorHost&lt;ClearMethodFlag, ClearKlassBits, AlwaysTrue, false&gt; ClearKlassAndMethods;</span>
  
<span class="line-modified">! static bool clear_artifacts = false;</span>
  
<span class="line-modified">! static void clear_klasses_and_methods() {</span>
<span class="line-modified">!   ClearKlassAndMethods clear(_writer);</span>
<span class="line-modified">!   _artifacts-&gt;iterate_klasses(clear);</span>
  }
  
<span class="line-modified">! static size_t teardown() {</span>
<span class="line-modified">!   assert(_artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   const size_t total_count = _artifacts-&gt;total_count();</span>
<span class="line-modified">!   if (previous_epoch()) {</span>
<span class="line-modified">!     clear_klasses_and_methods();</span>
<span class="line-modified">!     clear_artifacts = true;</span>
<span class="line-modified">!     ++checkpoint_id;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   return total_count;</span>
  }
  
<span class="line-modified">! static void setup(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer, bool class_unload, bool flushpoint) {</span>
<span class="line-modified">!   _writer = writer;</span>
<span class="line-modified">!   _leakp_writer = leakp_writer;</span>
    _class_unload = class_unload;
<span class="line-modified">!   _flushpoint = flushpoint;</span>
    if (_artifacts == NULL) {
      _artifacts = new JfrArtifactSet(class_unload);
    } else {
<span class="line-modified">!     _artifacts-&gt;initialize(class_unload, clear_artifacts);</span>
    }
<span class="line-added">+   clear_artifacts = false;</span>
    assert(_artifacts != NULL, &quot;invariant&quot;);
    assert(!_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);
<span class="line-modified">! }</span>
  
<span class="line-added">+ /**</span>
<span class="line-added">+  * Write all &quot;tagged&quot; (in-use) constant artifacts and their dependencies.</span>
<span class="line-added">+  */</span>
<span class="line-added">+ size_t JfrTypeSet::serialize(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer, bool class_unload, bool flushpoint) {</span>
<span class="line-added">+   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   ResourceMark rm;</span>
<span class="line-added">+   setup(writer, leakp_writer, class_unload, flushpoint);</span>
    // write order is important because an individual write step
    // might tag an artifact to be written in a subsequent step
<span class="line-modified">!   if (!write_klasses()) {</span>
<span class="line-modified">!     return 0;</span>
    }
<span class="line-added">+   write_packages();</span>
<span class="line-added">+   write_modules();</span>
<span class="line-added">+   write_classloaders();</span>
<span class="line-added">+   write_methods();</span>
<span class="line-added">+   write_symbols();</span>
<span class="line-added">+   return teardown();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ /**</span>
<span class="line-added">+  * Clear all tags from the previous epoch.</span>
<span class="line-added">+  */</span>
<span class="line-added">+ void JfrTypeSet::clear() {</span>
<span class="line-added">+   clear_artifacts = true;</span>
<span class="line-added">+   setup(NULL, NULL, false, false);</span>
<span class="line-added">+   register_klasses();</span>
<span class="line-added">+   clear_packages();</span>
<span class="line-added">+   clear_modules();</span>
<span class="line-added">+   clear_classloaders();</span>
<span class="line-added">+   clear_klasses_and_methods();</span>
  }
</pre>
<center><a href="jfrTypeManager.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="jfrTypeSet.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
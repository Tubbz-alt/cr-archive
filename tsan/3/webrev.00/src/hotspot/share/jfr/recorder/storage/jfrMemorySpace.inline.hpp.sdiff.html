<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/recorder/storage/jfrMemorySpace.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="jfrMemorySpace.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrStorage.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/storage/jfrMemorySpace.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_JFR_RECORDER_STORAGE_JFRMEMORYSPACE_INLINE_HPP
 26 #define SHARE_JFR_RECORDER_STORAGE_JFRMEMORYSPACE_INLINE_HPP
 27 
 28 #include &quot;jfr/recorder/storage/jfrMemorySpace.hpp&quot;

 29 
 30 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;
 31 JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::
 32 JfrMemorySpace(size_t min_elem_size, size_t limit_size, size_t cache_count, Callback* callback) :
 33   _free(),
 34   _full(),
 35   _min_elem_size(min_elem_size),
 36   _limit_size(limit_size),
 37   _cache_count(cache_count),
 38   _callback(callback) {}
 39 
 40 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;
 41 JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::~JfrMemorySpace() {
 42   Iterator full_iter(_full);
 43   while (full_iter.has_next()) {
 44     Type* t = full_iter.next();
 45     _full.remove(t);
 46     deallocate(t);
 47   }
 48   Iterator free_iter(_free);
</pre>
<hr />
<pre>
 52     deallocate(t);
 53   }
 54 }
 55 
 56 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;
 57 bool JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::initialize() {
 58   assert(_min_elem_size % os::vm_page_size() == 0, &quot;invariant&quot;);
 59   assert(_limit_size % os::vm_page_size() == 0, &quot;invariant&quot;);
 60   // pre-allocate cache elements
 61   for (size_t i = 0; i &lt; _cache_count; ++i) {
 62     Type* const t = allocate(_min_elem_size);
 63     if (t == NULL) {
 64       return false;
 65     }
 66     insert_free_head(t);
 67   }
 68   assert(_free.count() == _cache_count, &quot;invariant&quot;);
 69   return true;
 70 }
 71 




































 72 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;
 73 inline void JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::release_full(T* t) {
 74   assert(is_locked(), &quot;invariant&quot;);
 75   assert(t != NULL, &quot;invariant&quot;);
 76   assert(_full.in_list(t), &quot;invariant&quot;);
 77   remove_full(t);
 78   assert(!_full.in_list(t), &quot;invariant&quot;);
 79   if (t-&gt;transient()) {
 80     deallocate(t);
 81     return;
 82   }
 83   assert(t-&gt;empty(), &quot;invariant&quot;);
 84   assert(!t-&gt;retired(), &quot;invariant&quot;);
 85   assert(t-&gt;identity() == NULL, &quot;invariant&quot;);
 86   if (should_populate_cache()) {
 87     assert(!_free.in_list(t), &quot;invariant&quot;);
 88     insert_free_head(t);
 89   } else {
 90     deallocate(t);
 91   }
 92 }
 93 
 94 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;
 95 inline void JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::release_free(T* t) {
 96   assert(is_locked(), &quot;invariant&quot;);
 97   assert(t != NULL, &quot;invariant&quot;);
 98   assert(_free.in_list(t), &quot;invariant&quot;);
 99   if (t-&gt;transient()) {
100     remove_free(t);
101     assert(!_free.in_list(t), &quot;invariant&quot;);
102     deallocate(t);
103     return;
104   }
105   assert(t-&gt;empty(), &quot;invariant&quot;);
106   assert(!t-&gt;retired(), &quot;invariant&quot;);

107   assert(t-&gt;identity() == NULL, &quot;invariant&quot;);
108   if (!should_populate_cache()) {
109     remove_free(t);
110     assert(!_free.in_list(t), &quot;invariant&quot;);
111     deallocate(t);
112   }
113 }
114 
115 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;
116 template &lt;typename IteratorCallback, typename IteratorType&gt;
117 inline void JfrMemorySpace&lt;T, RetrievalType, Callback&gt;
118 ::iterate(IteratorCallback&amp; callback, bool full, jfr_iter_direction direction) {
119   IteratorType iterator(full ? _full : _free, direction);
120   while (iterator.has_next()) {
121     callback.process(iterator.next());
122   }
123 }
124 









125 template &lt;typename Mspace&gt;
126 inline size_t size_adjustment(size_t size, Mspace* mspace) {
127   assert(mspace != NULL, &quot;invariant&quot;);
128   static const size_t min_elem_size = mspace-&gt;min_elem_size();
129   if (size &lt; min_elem_size) {
130     size = min_elem_size;
131   }
132   return size;
133 }
134 
135 template &lt;typename Mspace&gt;
136 inline typename Mspace::Type* mspace_allocate(size_t size, Mspace* mspace) {
137   return mspace-&gt;allocate(size_adjustment(size, mspace));
138 }
139 
140 template &lt;typename Mspace&gt;
141 inline typename Mspace::Type* mspace_allocate_acquired(size_t size, Mspace* mspace, Thread* thread) {
142   typename Mspace::Type* const t = mspace_allocate(size, mspace);
143   if (t == NULL) return NULL;
144   t-&gt;acquire(thread);
</pre>
<hr />
<pre>
156 
157 template &lt;typename Mspace&gt;
158 inline typename Mspace::Type* mspace_allocate_transient_lease(size_t size, Mspace* mspace, Thread* thread) {
159   typename Mspace::Type* const t = mspace_allocate_transient(size, mspace, thread);
160   if (t == NULL) return NULL;
161   assert(t-&gt;acquired_by_self(), &quot;invariant&quot;);
162   assert(t-&gt;transient(), &quot;invaiant&quot;);
163   t-&gt;set_lease();
164   return t;
165 }
166 
167 template &lt;typename Mspace&gt;
168 inline typename Mspace::Type* mspace_allocate_to_full(size_t size, Mspace* mspace, Thread* thread) {
169   assert(mspace-&gt;is_locked(), &quot;invariant&quot;);
170   typename Mspace::Type* const t = mspace_allocate_acquired(size, mspace, thread);
171   if (t == NULL) return NULL;
172   mspace-&gt;insert_full_head(t);
173   return t;
174 }
175 









176 template &lt;typename Mspace&gt;
177 inline typename Mspace::Type* mspace_allocate_transient_to_full(size_t size, Mspace* mspace, Thread* thread) {
178   typename Mspace::Type* const t = mspace_allocate_transient(size, mspace, thread);
179   if (t == NULL) return NULL;
180   MspaceLock&lt;Mspace&gt; lock(mspace);
181   mspace-&gt;insert_full_head(t);
182   return t;
183 }
184 
185 template &lt;typename Mspace&gt;
186 inline typename Mspace::Type* mspace_allocate_transient_lease_to_full(size_t size, Mspace* mspace, Thread* thread) {
187   typename Mspace::Type* const t = mspace_allocate_transient_lease(size, mspace, thread);
188   if (t == NULL) return NULL;
189   assert(t-&gt;acquired_by_self(), &quot;invariant&quot;);
190   assert(t-&gt;transient(), &quot;invaiant&quot;);
191   assert(t-&gt;lease(), &quot;invariant&quot;);
192   MspaceLock&lt;Mspace&gt; lock(mspace);
193   mspace-&gt;insert_full_head(t);
194   return t;
195 }
</pre>
<hr />
<pre>
326 
327 template &lt;typename Processor, typename Mspace, typename Iterator&gt;
328 inline void process_full_list_iterator_control(Processor&amp; processor, Mspace* mspace, jfr_iter_direction direction = forward) {
329   mspace-&gt;template iterate&lt;Processor, Iterator&gt;(processor, true, direction);
330 }
331 
332 template &lt;typename Processor, typename Mspace&gt;
333 inline void process_full_list(Processor&amp; processor, Mspace* mspace, jfr_iter_direction direction = forward) {
334   assert(mspace != NULL, &quot;invariant&quot;);
335   if (mspace-&gt;is_full_empty()) return;
336   process_full_list_iterator_control&lt;Processor, Mspace, typename Mspace::Iterator&gt;(processor, mspace, direction);
337 }
338 
339 template &lt;typename Processor, typename Mspace&gt;
340 inline void process_free_list(Processor&amp; processor, Mspace* mspace, jfr_iter_direction direction = forward) {
341   assert(mspace != NULL, &quot;invariant&quot;);
342   assert(mspace-&gt;has_free(), &quot;invariant&quot;);
343   process_free_list_iterator_control&lt;Processor, Mspace, typename Mspace::Iterator&gt;(processor, mspace, direction);
344 }
345 














346 template &lt;typename Mspace&gt;
347 inline bool ReleaseOp&lt;Mspace&gt;::process(typename Mspace::Type* t) {
348   assert(t != NULL, &quot;invariant&quot;);
<span class="line-modified">349   if (t-&gt;retired() || t-&gt;try_acquire(_thread)) {</span>
<span class="line-modified">350     if (t-&gt;transient()) {</span>
<span class="line-modified">351       if (_release_full) {</span>
<span class="line-modified">352         mspace_release_full_critical(t, _mspace);</span>
<span class="line-modified">353       } else {</span>
<span class="line-modified">354         mspace_release_free_critical(t, _mspace);</span>
<span class="line-removed">355       }</span>
<span class="line-removed">356       return true;</span>
357     }
<span class="line-modified">358     t-&gt;reinitialize();</span>



359     assert(t-&gt;empty(), &quot;invariant&quot;);

360     t-&gt;release(); // publish
361   }
362   return true;
363 }
364 
365 #ifdef ASSERT
366 template &lt;typename T&gt;
367 inline void assert_migration_state(const T* old, const T* new_buffer, size_t used, size_t requested) {
368   assert(old != NULL, &quot;invariant&quot;);
369   assert(new_buffer != NULL, &quot;invariant&quot;);
370   assert(old-&gt;pos() &gt;= old-&gt;start(), &quot;invariant&quot;);
371   assert(old-&gt;pos() + used &lt;= old-&gt;end(), &quot;invariant&quot;);
372   assert(new_buffer-&gt;free_size() &gt;= (used + requested), &quot;invariant&quot;);
373 }
374 #endif // ASSERT
375 
376 template &lt;typename T&gt;
377 inline void migrate_outstanding_writes(const T* old, T* new_buffer, size_t used, size_t requested) {
378   DEBUG_ONLY(assert_migration_state(old, new_buffer, used, requested);)
379   if (used &gt; 0) {
</pre>
</td>
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_JFR_RECORDER_STORAGE_JFRMEMORYSPACE_INLINE_HPP
 26 #define SHARE_JFR_RECORDER_STORAGE_JFRMEMORYSPACE_INLINE_HPP
 27 
 28 #include &quot;jfr/recorder/storage/jfrMemorySpace.hpp&quot;
<span class="line-added"> 29 #include &quot;runtime/os.hpp&quot;</span>
 30 
 31 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;
 32 JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::
 33 JfrMemorySpace(size_t min_elem_size, size_t limit_size, size_t cache_count, Callback* callback) :
 34   _free(),
 35   _full(),
 36   _min_elem_size(min_elem_size),
 37   _limit_size(limit_size),
 38   _cache_count(cache_count),
 39   _callback(callback) {}
 40 
 41 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;
 42 JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::~JfrMemorySpace() {
 43   Iterator full_iter(_full);
 44   while (full_iter.has_next()) {
 45     Type* t = full_iter.next();
 46     _full.remove(t);
 47     deallocate(t);
 48   }
 49   Iterator free_iter(_free);
</pre>
<hr />
<pre>
 53     deallocate(t);
 54   }
 55 }
 56 
 57 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;
 58 bool JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::initialize() {
 59   assert(_min_elem_size % os::vm_page_size() == 0, &quot;invariant&quot;);
 60   assert(_limit_size % os::vm_page_size() == 0, &quot;invariant&quot;);
 61   // pre-allocate cache elements
 62   for (size_t i = 0; i &lt; _cache_count; ++i) {
 63     Type* const t = allocate(_min_elem_size);
 64     if (t == NULL) {
 65       return false;
 66     }
 67     insert_free_head(t);
 68   }
 69   assert(_free.count() == _cache_count, &quot;invariant&quot;);
 70   return true;
 71 }
 72 
<span class="line-added"> 73 // allocations are even multiples of the mspace min size</span>
<span class="line-added"> 74 static inline size_t align_allocation_size(size_t requested_size, size_t min_elem_size) {</span>
<span class="line-added"> 75   assert((int)min_elem_size % os::vm_page_size() == 0, &quot;invariant&quot;);</span>
<span class="line-added"> 76   u8 alloc_size_bytes = min_elem_size;</span>
<span class="line-added"> 77   while (requested_size &gt; alloc_size_bytes) {</span>
<span class="line-added"> 78     alloc_size_bytes &lt;&lt;= 1;</span>
<span class="line-added"> 79   }</span>
<span class="line-added"> 80   assert((int)alloc_size_bytes % os::vm_page_size() == 0, &quot;invariant&quot;);</span>
<span class="line-added"> 81   return (size_t)alloc_size_bytes;</span>
<span class="line-added"> 82 }</span>
<span class="line-added"> 83 </span>
<span class="line-added"> 84 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;</span>
<span class="line-added"> 85 inline T* JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::allocate(size_t size) {</span>
<span class="line-added"> 86   const size_t aligned_size_bytes = align_allocation_size(size, _min_elem_size);</span>
<span class="line-added"> 87   void* const allocation = JfrCHeapObj::new_array&lt;u1&gt;(aligned_size_bytes + sizeof(T));</span>
<span class="line-added"> 88   if (allocation == NULL) {</span>
<span class="line-added"> 89     return NULL;</span>
<span class="line-added"> 90   }</span>
<span class="line-added"> 91   T* const t = new (allocation) T;</span>
<span class="line-added"> 92   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 93   if (!t-&gt;initialize(sizeof(T), aligned_size_bytes)) {</span>
<span class="line-added"> 94     JfrCHeapObj::free(t, aligned_size_bytes + sizeof(T));</span>
<span class="line-added"> 95     return NULL;</span>
<span class="line-added"> 96   }</span>
<span class="line-added"> 97   return t;</span>
<span class="line-added"> 98 }</span>
<span class="line-added"> 99 </span>
<span class="line-added">100 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;</span>
<span class="line-added">101 inline void JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::deallocate(T* t) {</span>
<span class="line-added">102   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="line-added">103   assert(!_free.in_list(t), &quot;invariant&quot;);</span>
<span class="line-added">104   assert(!_full.in_list(t), &quot;invariant&quot;);</span>
<span class="line-added">105   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="line-added">106   JfrCHeapObj::free(t, t-&gt;total_size());</span>
<span class="line-added">107 }</span>
<span class="line-added">108 </span>
109 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;
110 inline void JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::release_full(T* t) {
111   assert(is_locked(), &quot;invariant&quot;);
112   assert(t != NULL, &quot;invariant&quot;);
113   assert(_full.in_list(t), &quot;invariant&quot;);
114   remove_full(t);
115   assert(!_full.in_list(t), &quot;invariant&quot;);
116   if (t-&gt;transient()) {
117     deallocate(t);
118     return;
119   }
120   assert(t-&gt;empty(), &quot;invariant&quot;);
121   assert(!t-&gt;retired(), &quot;invariant&quot;);
122   assert(t-&gt;identity() == NULL, &quot;invariant&quot;);
123   if (should_populate_cache()) {
124     assert(!_free.in_list(t), &quot;invariant&quot;);
125     insert_free_head(t);
126   } else {
127     deallocate(t);
128   }
129 }
130 
131 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;
132 inline void JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::release_free(T* t) {
133   assert(is_locked(), &quot;invariant&quot;);
134   assert(t != NULL, &quot;invariant&quot;);
135   assert(_free.in_list(t), &quot;invariant&quot;);
136   if (t-&gt;transient()) {
137     remove_free(t);
138     assert(!_free.in_list(t), &quot;invariant&quot;);
139     deallocate(t);
140     return;
141   }
142   assert(t-&gt;empty(), &quot;invariant&quot;);
143   assert(!t-&gt;retired(), &quot;invariant&quot;);
<span class="line-added">144   assert(!t-&gt;excluded(), &quot;invariant&quot;);</span>
145   assert(t-&gt;identity() == NULL, &quot;invariant&quot;);
146   if (!should_populate_cache()) {
147     remove_free(t);
148     assert(!_free.in_list(t), &quot;invariant&quot;);
149     deallocate(t);
150   }
151 }
152 
153 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;
154 template &lt;typename IteratorCallback, typename IteratorType&gt;
155 inline void JfrMemorySpace&lt;T, RetrievalType, Callback&gt;
156 ::iterate(IteratorCallback&amp; callback, bool full, jfr_iter_direction direction) {
157   IteratorType iterator(full ? _full : _free, direction);
158   while (iterator.has_next()) {
159     callback.process(iterator.next());
160   }
161 }
162 
<span class="line-added">163 template &lt;typename Mspace, typename Callback&gt;</span>
<span class="line-added">164 static inline Mspace* create_mspace(size_t buffer_size, size_t limit, size_t cache_count, Callback* cb) {</span>
<span class="line-added">165   Mspace* const mspace = new Mspace(buffer_size, limit, cache_count, cb);</span>
<span class="line-added">166   if (mspace != NULL) {</span>
<span class="line-added">167     mspace-&gt;initialize();</span>
<span class="line-added">168   }</span>
<span class="line-added">169   return mspace;</span>
<span class="line-added">170 }</span>
<span class="line-added">171 </span>
172 template &lt;typename Mspace&gt;
173 inline size_t size_adjustment(size_t size, Mspace* mspace) {
174   assert(mspace != NULL, &quot;invariant&quot;);
175   static const size_t min_elem_size = mspace-&gt;min_elem_size();
176   if (size &lt; min_elem_size) {
177     size = min_elem_size;
178   }
179   return size;
180 }
181 
182 template &lt;typename Mspace&gt;
183 inline typename Mspace::Type* mspace_allocate(size_t size, Mspace* mspace) {
184   return mspace-&gt;allocate(size_adjustment(size, mspace));
185 }
186 
187 template &lt;typename Mspace&gt;
188 inline typename Mspace::Type* mspace_allocate_acquired(size_t size, Mspace* mspace, Thread* thread) {
189   typename Mspace::Type* const t = mspace_allocate(size, mspace);
190   if (t == NULL) return NULL;
191   t-&gt;acquire(thread);
</pre>
<hr />
<pre>
203 
204 template &lt;typename Mspace&gt;
205 inline typename Mspace::Type* mspace_allocate_transient_lease(size_t size, Mspace* mspace, Thread* thread) {
206   typename Mspace::Type* const t = mspace_allocate_transient(size, mspace, thread);
207   if (t == NULL) return NULL;
208   assert(t-&gt;acquired_by_self(), &quot;invariant&quot;);
209   assert(t-&gt;transient(), &quot;invaiant&quot;);
210   t-&gt;set_lease();
211   return t;
212 }
213 
214 template &lt;typename Mspace&gt;
215 inline typename Mspace::Type* mspace_allocate_to_full(size_t size, Mspace* mspace, Thread* thread) {
216   assert(mspace-&gt;is_locked(), &quot;invariant&quot;);
217   typename Mspace::Type* const t = mspace_allocate_acquired(size, mspace, thread);
218   if (t == NULL) return NULL;
219   mspace-&gt;insert_full_head(t);
220   return t;
221 }
222 
<span class="line-added">223 template &lt;typename Mspace&gt;</span>
<span class="line-added">224 class MspaceLock {</span>
<span class="line-added">225  private:</span>
<span class="line-added">226   Mspace* _mspace;</span>
<span class="line-added">227  public:</span>
<span class="line-added">228   MspaceLock(Mspace* mspace) : _mspace(mspace) { _mspace-&gt;lock(); }</span>
<span class="line-added">229   ~MspaceLock() { _mspace-&gt;unlock(); }</span>
<span class="line-added">230 };</span>
<span class="line-added">231 </span>
232 template &lt;typename Mspace&gt;
233 inline typename Mspace::Type* mspace_allocate_transient_to_full(size_t size, Mspace* mspace, Thread* thread) {
234   typename Mspace::Type* const t = mspace_allocate_transient(size, mspace, thread);
235   if (t == NULL) return NULL;
236   MspaceLock&lt;Mspace&gt; lock(mspace);
237   mspace-&gt;insert_full_head(t);
238   return t;
239 }
240 
241 template &lt;typename Mspace&gt;
242 inline typename Mspace::Type* mspace_allocate_transient_lease_to_full(size_t size, Mspace* mspace, Thread* thread) {
243   typename Mspace::Type* const t = mspace_allocate_transient_lease(size, mspace, thread);
244   if (t == NULL) return NULL;
245   assert(t-&gt;acquired_by_self(), &quot;invariant&quot;);
246   assert(t-&gt;transient(), &quot;invaiant&quot;);
247   assert(t-&gt;lease(), &quot;invariant&quot;);
248   MspaceLock&lt;Mspace&gt; lock(mspace);
249   mspace-&gt;insert_full_head(t);
250   return t;
251 }
</pre>
<hr />
<pre>
382 
383 template &lt;typename Processor, typename Mspace, typename Iterator&gt;
384 inline void process_full_list_iterator_control(Processor&amp; processor, Mspace* mspace, jfr_iter_direction direction = forward) {
385   mspace-&gt;template iterate&lt;Processor, Iterator&gt;(processor, true, direction);
386 }
387 
388 template &lt;typename Processor, typename Mspace&gt;
389 inline void process_full_list(Processor&amp; processor, Mspace* mspace, jfr_iter_direction direction = forward) {
390   assert(mspace != NULL, &quot;invariant&quot;);
391   if (mspace-&gt;is_full_empty()) return;
392   process_full_list_iterator_control&lt;Processor, Mspace, typename Mspace::Iterator&gt;(processor, mspace, direction);
393 }
394 
395 template &lt;typename Processor, typename Mspace&gt;
396 inline void process_free_list(Processor&amp; processor, Mspace* mspace, jfr_iter_direction direction = forward) {
397   assert(mspace != NULL, &quot;invariant&quot;);
398   assert(mspace-&gt;has_free(), &quot;invariant&quot;);
399   process_free_list_iterator_control&lt;Processor, Mspace, typename Mspace::Iterator&gt;(processor, mspace, direction);
400 }
401 
<span class="line-added">402 template &lt;typename Mspace&gt;</span>
<span class="line-added">403 class ReleaseOp : public StackObj {</span>
<span class="line-added">404  private:</span>
<span class="line-added">405   Mspace* _mspace;</span>
<span class="line-added">406   Thread* _thread;</span>
<span class="line-added">407   bool _release_full;</span>
<span class="line-added">408  public:</span>
<span class="line-added">409   typedef typename Mspace::Type Type;</span>
<span class="line-added">410   ReleaseOp(Mspace* mspace, Thread* thread, bool release_full = true) :</span>
<span class="line-added">411     _mspace(mspace), _thread(thread), _release_full(release_full) {}</span>
<span class="line-added">412   bool process(Type* t);</span>
<span class="line-added">413   size_t processed() const { return 0; }</span>
<span class="line-added">414 };</span>
<span class="line-added">415 </span>
416 template &lt;typename Mspace&gt;
417 inline bool ReleaseOp&lt;Mspace&gt;::process(typename Mspace::Type* t) {
418   assert(t != NULL, &quot;invariant&quot;);
<span class="line-modified">419   // assumes some means of exclusive access to t</span>
<span class="line-modified">420   if (t-&gt;transient()) {</span>
<span class="line-modified">421     if (_release_full) {</span>
<span class="line-modified">422       mspace_release_full_critical(t, _mspace);</span>
<span class="line-modified">423     } else {</span>
<span class="line-modified">424       mspace_release_free_critical(t, _mspace);</span>


425     }
<span class="line-modified">426     return true;</span>
<span class="line-added">427   }</span>
<span class="line-added">428   t-&gt;reinitialize();</span>
<span class="line-added">429   if (t-&gt;identity() != NULL) {</span>
430     assert(t-&gt;empty(), &quot;invariant&quot;);
<span class="line-added">431     assert(!t-&gt;retired(), &quot;invariant&quot;);</span>
432     t-&gt;release(); // publish
433   }
434   return true;
435 }
436 
437 #ifdef ASSERT
438 template &lt;typename T&gt;
439 inline void assert_migration_state(const T* old, const T* new_buffer, size_t used, size_t requested) {
440   assert(old != NULL, &quot;invariant&quot;);
441   assert(new_buffer != NULL, &quot;invariant&quot;);
442   assert(old-&gt;pos() &gt;= old-&gt;start(), &quot;invariant&quot;);
443   assert(old-&gt;pos() + used &lt;= old-&gt;end(), &quot;invariant&quot;);
444   assert(new_buffer-&gt;free_size() &gt;= (used + requested), &quot;invariant&quot;);
445 }
446 #endif // ASSERT
447 
448 template &lt;typename T&gt;
449 inline void migrate_outstanding_writes(const T* old, T* new_buffer, size_t used, size_t requested) {
450   DEBUG_ONLY(assert_migration_state(old, new_buffer, used, requested);)
451   if (used &gt; 0) {
</pre>
</td>
</tr>
</table>
<center><a href="jfrMemorySpace.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrStorage.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
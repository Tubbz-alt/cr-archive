<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeManager.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/metadata/jfrSerializer.hpp&quot;
 27 #include &quot;jfr/recorder/checkpoint/jfrCheckpointWriter.hpp&quot;
 28 #include &quot;jfr/recorder/checkpoint/types/jfrType.hpp&quot;
 29 #include &quot;jfr/recorder/checkpoint/types/jfrTypeManager.hpp&quot;
<a name="2" id="anc2"></a>
 30 #include &quot;jfr/utilities/jfrDoublyLinkedList.hpp&quot;
 31 #include &quot;jfr/utilities/jfrIterator.hpp&quot;
<a name="3" id="anc3"></a>

 32 #include &quot;runtime/safepoint.hpp&quot;
<a name="4" id="anc4"></a>
 33 #include &quot;runtime/thread.inline.hpp&quot;
 34 #include &quot;utilities/exceptions.hpp&quot;
<a name="5" id="anc5"></a><span class="line-removed"> 35 #include &quot;runtime/semaphore.hpp&quot;</span>
 36 
 37 class JfrSerializerRegistration : public JfrCHeapObj {
 38  private:
 39   JfrSerializerRegistration* _next;
 40   JfrSerializerRegistration* _prev;
 41   JfrSerializer* _serializer;
<a name="6" id="anc6"></a><span class="line-modified"> 42   mutable JfrCheckpointBlobHandle _cache;</span>
 43   JfrTypeId _id;
 44   bool _permit_cache;
 45 
 46  public:
 47   JfrSerializerRegistration(JfrTypeId id, bool permit_cache, JfrSerializer* serializer) :
 48     _next(NULL), _prev(NULL), _serializer(serializer), _cache(), _id(id), _permit_cache(permit_cache) {}
 49 
 50   ~JfrSerializerRegistration() {
 51     delete _serializer;
 52   }
 53 
 54   JfrSerializerRegistration* next() const {
 55     return _next;
 56   }
 57 
 58   void set_next(JfrSerializerRegistration* next) {
 59     _next = next;
 60   }
 61 
 62   JfrSerializerRegistration* prev() const {
 63     return _prev;
 64   }
 65 
 66   void set_prev(JfrSerializerRegistration* prev) {
 67     _prev = prev;
 68   }
 69 
 70   JfrTypeId id() const {
 71     return _id;
 72   }
 73 
<a name="7" id="anc7"></a><span class="line-modified"> 74   void invoke(JfrCheckpointWriter&amp; writer) const;</span>
























 75 };
 76 
<a name="8" id="anc8"></a><span class="line-modified"> 77 void JfrSerializerRegistration::invoke(JfrCheckpointWriter&amp; writer) const {</span>
<span class="line-modified"> 78   if (_cache.valid()) {</span>
<span class="line-modified"> 79     writer.increment();</span>
<span class="line-modified"> 80     _cache-&gt;write(writer);</span>
<span class="line-modified"> 81     return;</span>
<span class="line-modified"> 82   }</span>
<span class="line-modified"> 83   const JfrCheckpointContext ctx = writer.context();</span>
<span class="line-modified"> 84   // serialize the type id before invoking callback</span>
<span class="line-modified"> 85   writer.write_type(_id);</span>
<span class="line-modified"> 86   const intptr_t start = writer.current_offset();</span>
<span class="line-modified"> 87   // invoke the serializer routine</span>
<span class="line-modified"> 88   _serializer-&gt;serialize(writer);</span>
<span class="line-modified"> 89   if (start == writer.current_offset() ) {</span>
<span class="line-modified"> 90     // the serializer implementation did nothing, rewind to restore</span>
<span class="line-modified"> 91     writer.set_context(ctx);</span>
<span class="line-modified"> 92     return;</span>
<span class="line-modified"> 93   }</span>
<span class="line-modified"> 94   if (_permit_cache) {</span>
<span class="line-modified"> 95     _cache = writer.copy(&amp;ctx);</span>
<span class="line-modified"> 96   }</span>


















 97 }
 98 
 99 class SerializerRegistrationGuard : public StackObj {
100  private:
101   static Semaphore _mutex_semaphore;
102  public:
103   SerializerRegistrationGuard() {
104     _mutex_semaphore.wait();
105   }
106   ~SerializerRegistrationGuard() {
107     _mutex_semaphore.signal();
108   }
109 };
110 
111 Semaphore SerializerRegistrationGuard::_mutex_semaphore(1);
112 
113 typedef JfrDoublyLinkedList&lt;JfrSerializerRegistration&gt; List;
114 typedef StopOnNullIterator&lt;const List&gt; Iterator;
115 static List types;
<a name="9" id="anc9"></a><span class="line-removed">116 static List safepoint_types;</span>
117 
<a name="10" id="anc10"></a><span class="line-modified">118 void JfrTypeManager::clear() {</span>
119   SerializerRegistrationGuard guard;
120   Iterator iter(types);
121   JfrSerializerRegistration* registration;
122   while (iter.has_next()) {
123     registration = types.remove(iter.next());
124     assert(registration != NULL, &quot;invariant&quot;);
125     delete registration;
126   }
<a name="11" id="anc11"></a><span class="line-removed">127   Iterator sp_type_iter(safepoint_types);</span>
<span class="line-removed">128   while (sp_type_iter.has_next()) {</span>
<span class="line-removed">129     registration = safepoint_types.remove(sp_type_iter.next());</span>
<span class="line-removed">130     assert(registration != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">131     delete registration;</span>
<span class="line-removed">132   }</span>
133 }
134 
<a name="12" id="anc12"></a><span class="line-modified">135 void JfrTypeManager::write_types(JfrCheckpointWriter&amp; writer) {</span>
136   const Iterator iter(types);
137   while (iter.has_next()) {
<a name="13" id="anc13"></a><span class="line-modified">138     iter.next()-&gt;invoke(writer);</span>
<span class="line-removed">139   }</span>
<span class="line-removed">140 }</span>
<span class="line-removed">141 </span>
<span class="line-removed">142 void JfrTypeManager::write_safepoint_types(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-removed">143   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);</span>
<span class="line-removed">144   const Iterator iter(safepoint_types);</span>
<span class="line-removed">145   while (iter.has_next()) {</span>
<span class="line-removed">146     iter.next()-&gt;invoke(writer);</span>
<span class="line-removed">147   }</span>
<span class="line-removed">148 }</span>
<span class="line-removed">149 </span>
<span class="line-removed">150 void JfrTypeManager::write_type_set() {</span>
<span class="line-removed">151   // can safepoint here because of Module_lock</span>
<span class="line-removed">152   MutexLockerEx cld_lock(SafepointSynchronize::is_at_safepoint() ? NULL : ClassLoaderDataGraph_lock);</span>
<span class="line-removed">153   MutexLockerEx lock(SafepointSynchronize::is_at_safepoint() ? NULL : Module_lock);</span>
<span class="line-removed">154 </span>
<span class="line-removed">155   JfrCheckpointWriter writer(true, true, Thread::current());</span>
<span class="line-removed">156   TypeSet set;</span>
<span class="line-removed">157   set.serialize(writer);</span>
<span class="line-removed">158 }</span>
<span class="line-removed">159 </span>
<span class="line-removed">160 void JfrTypeManager::write_type_set_for_unloaded_classes() {</span>
<span class="line-removed">161   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);</span>
<span class="line-removed">162   JfrCheckpointWriter writer(false, true, Thread::current());</span>
<span class="line-removed">163   ClassUnloadTypeSet class_unload_set;</span>
<span class="line-removed">164   class_unload_set.serialize(writer);</span>
<span class="line-removed">165 }</span>
<span class="line-removed">166 </span>
<span class="line-removed">167 void JfrTypeManager::create_thread_checkpoint(JavaThread* jt) {</span>
<span class="line-removed">168   assert(jt != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">169   JfrThreadConstant type_thread(jt);</span>
<span class="line-removed">170   JfrCheckpointWriter writer(false, true, jt);</span>
<span class="line-removed">171   writer.write_type(TYPE_THREAD);</span>
<span class="line-removed">172   type_thread.serialize(writer);</span>
<span class="line-removed">173   // create and install a checkpoint blob</span>
<span class="line-removed">174   jt-&gt;jfr_thread_local()-&gt;set_thread_checkpoint(writer.checkpoint_blob());</span>
<span class="line-removed">175   assert(jt-&gt;jfr_thread_local()-&gt;has_thread_checkpoint(), &quot;invariant&quot;);</span>
<span class="line-removed">176 }</span>
<span class="line-removed">177 </span>
<span class="line-removed">178 void JfrTypeManager::write_thread_checkpoint(JavaThread* jt) {</span>
<span class="line-removed">179   assert(jt != NULL, &quot;JavaThread is NULL!&quot;);</span>
<span class="line-removed">180   ResourceMark rm(jt);</span>
<span class="line-removed">181   if (jt-&gt;jfr_thread_local()-&gt;has_thread_checkpoint()) {</span>
<span class="line-removed">182     JfrCheckpointWriter writer(false, false, jt);</span>
<span class="line-removed">183     jt-&gt;jfr_thread_local()-&gt;thread_checkpoint()-&gt;write(writer);</span>
<span class="line-removed">184   } else {</span>
<span class="line-removed">185     JfrThreadConstant type_thread(jt);</span>
<span class="line-removed">186     JfrCheckpointWriter writer(false, true, jt);</span>
<span class="line-removed">187     writer.write_type(TYPE_THREAD);</span>
<span class="line-removed">188     type_thread.serialize(writer);</span>
189   }
190 }
191 
192 #ifdef ASSERT
193 static void assert_not_registered_twice(JfrTypeId id, List&amp; list) {
194   const Iterator iter(list);
195   while (iter.has_next()) {
196     assert(iter.next()-&gt;id() != id, &quot;invariant&quot;);
197   }
198 }
199 #endif
200 
<a name="14" id="anc14"></a><span class="line-modified">201 static bool register_type(JfrTypeId id, bool require_safepoint, bool permit_cache, JfrSerializer* serializer) {</span>


202   assert(serializer != NULL, &quot;invariant&quot;);
203   JfrSerializerRegistration* const registration = new JfrSerializerRegistration(id, permit_cache, serializer);
204   if (registration == NULL) {
205     delete serializer;
206     return false;
207   }
<a name="15" id="anc15"></a><span class="line-modified">208   if (require_safepoint) {</span>
<span class="line-modified">209     assert(!safepoint_types.in_list(registration), &quot;invariant&quot;);</span>
<span class="line-modified">210     DEBUG_ONLY(assert_not_registered_twice(id, safepoint_types);)</span>
<span class="line-modified">211     safepoint_types.prepend(registration);</span>
<span class="line-modified">212   } else {</span>
<span class="line-modified">213     assert(!types.in_list(registration), &quot;invariant&quot;);</span>
<span class="line-removed">214     DEBUG_ONLY(assert_not_registered_twice(id, types);)</span>
<span class="line-removed">215     types.prepend(registration);</span>
216   }
<a name="16" id="anc16"></a>
217   return true;
218 }
219 
220 bool JfrTypeManager::initialize() {
221   SerializerRegistrationGuard guard;
<a name="17" id="anc17"></a><span class="line-modified">222 </span>
<span class="line-modified">223   // register non-safepointing type serialization</span>
<span class="line-modified">224   register_type(TYPE_FLAGVALUEORIGIN, false, true, new FlagValueOriginConstant());</span>
<span class="line-modified">225   register_type(TYPE_INFLATECAUSE, false, true, new MonitorInflateCauseConstant());</span>
<span class="line-modified">226   register_type(TYPE_GCCAUSE, false, true, new GCCauseConstant());</span>
<span class="line-modified">227   register_type(TYPE_GCNAME, false, true, new GCNameConstant());</span>
<span class="line-modified">228   register_type(TYPE_GCWHEN, false, true, new GCWhenConstant());</span>
<span class="line-modified">229   register_type(TYPE_G1HEAPREGIONTYPE, false, true, new G1HeapRegionTypeConstant());</span>
<span class="line-modified">230   register_type(TYPE_GCTHRESHOLDUPDATER, false, true, new GCThresholdUpdaterConstant());</span>
<span class="line-modified">231   register_type(TYPE_METADATATYPE, false, true, new MetadataTypeConstant());</span>
<span class="line-modified">232   register_type(TYPE_METASPACEOBJECTTYPE, false, true, new MetaspaceObjectTypeConstant());</span>
<span class="line-modified">233   register_type(TYPE_G1YCTYPE, false, true, new G1YCTypeConstant());</span>
<span class="line-modified">234   register_type(TYPE_REFERENCETYPE, false, true, new ReferenceTypeConstant());</span>
<span class="line-modified">235   register_type(TYPE_NARROWOOPMODE, false, true, new NarrowOopModeConstant());</span>
<span class="line-modified">236   register_type(TYPE_COMPILERPHASETYPE, false, true, new CompilerPhaseTypeConstant());</span>
<span class="line-modified">237   register_type(TYPE_CODEBLOBTYPE, false, true, new CodeBlobTypeConstant());</span>
<span class="line-removed">238   register_type(TYPE_VMOPERATIONTYPE, false, true, new VMOperationTypeConstant());</span>
<span class="line-removed">239   register_type(TYPE_THREADSTATE, false, true, new ThreadStateConstant());</span>
<span class="line-removed">240 </span>
<span class="line-removed">241   // register safepointing type serialization</span>
<span class="line-removed">242   register_type(TYPE_THREADGROUP, true, false, new JfrThreadGroupConstant());</span>
<span class="line-removed">243   register_type(TYPE_THREAD, true, false, new JfrThreadConstantSet());</span>
244   return true;
245 }
246 
247 // implementation for the static registration function exposed in the JfrSerializer api
<a name="18" id="anc18"></a><span class="line-modified">248 bool JfrSerializer::register_serializer(JfrTypeId id, bool require_safepoint, bool permit_cache, JfrSerializer* serializer) {</span>
249   SerializerRegistrationGuard guard;
<a name="19" id="anc19"></a><span class="line-modified">250   return register_type(id, require_safepoint, permit_cache, serializer);</span>


















251 }
<a name="20" id="anc20"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="20" type="hidden" />
</body>
</html>
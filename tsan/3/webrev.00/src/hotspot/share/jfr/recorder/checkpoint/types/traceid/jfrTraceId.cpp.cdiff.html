<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/jfr/recorder/checkpoint/types/traceid/jfrTraceId.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../jfrTypeSetUtils.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="jfrTraceId.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/checkpoint/types/traceid/jfrTraceId.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 31,11 ***</span>
  #include &quot;oops/klass.inline.hpp&quot;
  #include &quot;oops/instanceKlass.inline.hpp&quot;
  #include &quot;oops/method.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
<span class="line-removed">- #include &quot;runtime/orderAccess.hpp&quot;</span>
  #include &quot;runtime/vm_version.hpp&quot;
  #include &quot;runtime/jniHandles.inline.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;utilities/debug.hpp&quot;
  
<span class="line-new-header">--- 31,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 43,13 ***</span>
  static traceid atomic_inc(traceid volatile* const dest) {
    assert(VM_Version::supports_cx8(), &quot;invariant&quot;);
    traceid compare_value;
    traceid exchange_value;
    do {
<span class="line-modified">!     compare_value = OrderAccess::load_acquire(dest);</span>
      exchange_value = compare_value + 1;
<span class="line-modified">!   } while (Atomic::cmpxchg(exchange_value, dest, compare_value) != compare_value);</span>
    return exchange_value;
  }
  
  static traceid next_class_id() {
    static volatile traceid class_id_counter = MaxJfrEventId + 100;
<span class="line-new-header">--- 42,13 ---</span>
  static traceid atomic_inc(traceid volatile* const dest) {
    assert(VM_Version::supports_cx8(), &quot;invariant&quot;);
    traceid compare_value;
    traceid exchange_value;
    do {
<span class="line-modified">!     compare_value = *dest;</span>
      exchange_value = compare_value + 1;
<span class="line-modified">!   } while (Atomic::cmpxchg(dest, compare_value, exchange_value) != compare_value);</span>
    return exchange_value;
  }
  
  static traceid next_class_id() {
    static volatile traceid class_id_counter = MaxJfrEventId + 100;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 85,18 ***</span>
      return;
    }
    static const Symbol* jdk_internal_event_sym = NULL;
    if (jdk_internal_event_sym == NULL) {
      // setup when loading the first TypeArrayKlass (Universe::genesis) hence single threaded invariant
<span class="line-modified">!     jdk_internal_event_sym = SymbolTable::new_permanent_symbol(&quot;jdk/internal/event/Event&quot;, Thread::current());</span>
    }
    assert(jdk_internal_event_sym != NULL, &quot;invariant&quot;);
  
    static const Symbol* jdk_jfr_event_sym = NULL;
    if (jdk_jfr_event_sym == NULL) {
      // setup when loading the first TypeArrayKlass (Universe::genesis) hence single threaded invariant
<span class="line-modified">!     jdk_jfr_event_sym = SymbolTable::new_permanent_symbol(&quot;jdk/jfr/Event&quot;, Thread::current());</span>
    }
    assert(jdk_jfr_event_sym != NULL, &quot;invariant&quot;);
    const Symbol* const klass_name = klass-&gt;name();
  
    if (!found_jdk_internal_event_klass) {
<span class="line-new-header">--- 84,18 ---</span>
      return;
    }
    static const Symbol* jdk_internal_event_sym = NULL;
    if (jdk_internal_event_sym == NULL) {
      // setup when loading the first TypeArrayKlass (Universe::genesis) hence single threaded invariant
<span class="line-modified">!     jdk_internal_event_sym = SymbolTable::new_permanent_symbol(&quot;jdk/internal/event/Event&quot;);</span>
    }
    assert(jdk_internal_event_sym != NULL, &quot;invariant&quot;);
  
    static const Symbol* jdk_jfr_event_sym = NULL;
    if (jdk_jfr_event_sym == NULL) {
      // setup when loading the first TypeArrayKlass (Universe::genesis) hence single threaded invariant
<span class="line-modified">!     jdk_jfr_event_sym = SymbolTable::new_permanent_symbol(&quot;jdk/jfr/Event&quot;);</span>
    }
    assert(jdk_jfr_event_sym != NULL, &quot;invariant&quot;);
    const Symbol* const klass_name = klass-&gt;name();
  
    if (!found_jdk_internal_event_klass) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 157,11 ***</span>
    assert(k != NULL, &quot;invariant&quot;);
    // Mask off and store the event flags.
    // This mechanism will retain the event specific flags
    // in the archive, allowing for event flag restoration
    // when renewing the traceid on klass revival.
<span class="line-modified">!   k-&gt;set_trace_id(EVENT_FLAGS_MASK(k));</span>
  }
  
  // used by CDS / APPCDS as part of &quot;restore_unshareable_info&quot;
  void JfrTraceId::restore(const Klass* k) {
    assert(k != NULL, &quot;invariant&quot;);
<span class="line-new-header">--- 156,11 ---</span>
    assert(k != NULL, &quot;invariant&quot;);
    // Mask off and store the event flags.
    // This mechanism will retain the event specific flags
    // in the archive, allowing for event flag restoration
    // when renewing the traceid on klass revival.
<span class="line-modified">!   k-&gt;set_trace_id(EVENT_KLASS_MASK(k));</span>
  }
  
  // used by CDS / APPCDS as part of &quot;restore_unshareable_info&quot;
  void JfrTraceId::restore(const Klass* k) {
    assert(k != NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 179,16 ***</span>
    const oop my_oop = JNIHandles::resolve(jc);
    assert(my_oop != NULL, &quot;invariant&quot;);
    return get(java_lang_Class::as_Klass(my_oop));
  }
  
<span class="line-modified">! traceid JfrTraceId::use(jclass jc, bool leakp /* false */) {</span>
    assert(jc != NULL, &quot;invariant&quot;);
    assert(((JavaThread*)Thread::current())-&gt;thread_state() == _thread_in_vm, &quot;invariant&quot;);
    const oop my_oop = JNIHandles::resolve(jc);
    assert(my_oop != NULL, &quot;invariant&quot;);
<span class="line-modified">!   return use(java_lang_Class::as_Klass(my_oop), leakp);</span>
  }
  
  bool JfrTraceId::in_visible_set(const jclass jc) {
    assert(jc != NULL, &quot;invariant&quot;);
    assert(((JavaThread*)Thread::current())-&gt;thread_state() == _thread_in_vm, &quot;invariant&quot;);
<span class="line-new-header">--- 178,16 ---</span>
    const oop my_oop = JNIHandles::resolve(jc);
    assert(my_oop != NULL, &quot;invariant&quot;);
    return get(java_lang_Class::as_Klass(my_oop));
  }
  
<span class="line-modified">! traceid JfrTraceId::use(jclass jc) {</span>
    assert(jc != NULL, &quot;invariant&quot;);
    assert(((JavaThread*)Thread::current())-&gt;thread_state() == _thread_in_vm, &quot;invariant&quot;);
    const oop my_oop = JNIHandles::resolve(jc);
    assert(my_oop != NULL, &quot;invariant&quot;);
<span class="line-modified">!   return use(java_lang_Class::as_Klass(my_oop));</span>
  }
  
  bool JfrTraceId::in_visible_set(const jclass jc) {
    assert(jc != NULL, &quot;invariant&quot;);
    assert(((JavaThread*)Thread::current())-&gt;thread_state() == _thread_in_vm, &quot;invariant&quot;);
</pre>
<center><a href="../jfrTypeSetUtils.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="jfrTraceId.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/jfr/recorder/checkpoint/types/jfrThreadState.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2 * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4 *
  5 * This code is free software; you can redistribute it and/or modify it
  6 * under the terms of the GNU General Public License version 2 only, as
  7 * published by the Free Software Foundation.
  8 *
  9 * This code is distributed in the hope that it will be useful, but WITHOUT
 10 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12 * version 2 for more details (a copy is included in the LICENSE file that
 13 * accompanied this code).
 14 *
 15 * You should have received a copy of the GNU General Public License version
 16 * 2 along with this work; if not, write to the Free Software Foundation,
 17 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18 *
 19 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20 * or visit www.oracle.com if you need additional information or have any
 21 * questions.
 22 *
 23 */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/javaClasses.inline.hpp&quot;
 27 #include &quot;jfr/recorder/checkpoint/types/jfrThreadState.hpp&quot;
 28 #include &quot;jfr/recorder/checkpoint/jfrCheckpointWriter.hpp&quot;
 29 #include &quot;jfr/support/jfrThreadLocal.hpp&quot;
 30 #include &quot;jvmtifiles/jvmti.h&quot;
 31 #include &quot;runtime/osThread.hpp&quot;
 32 #include &quot;runtime/thread.hpp&quot;
 33 
 34 struct jvmti_thread_state {
 35   u8 id;
 36   const char* description;
 37 };
 38 
 39 static jvmti_thread_state states[] = {
 40   {
 41     JVMTI_JAVA_LANG_THREAD_STATE_NEW,
 42     &quot;STATE_NEW&quot;
 43   },
 44   {
 45     JVMTI_THREAD_STATE_TERMINATED,
 46     &quot;STATE_TERMINATED&quot;
 47   },
 48   {
 49     JVMTI_JAVA_LANG_THREAD_STATE_RUNNABLE,
 50     &quot;STATE_RUNNABLE&quot;
 51   },
 52   {
 53     (JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT | JVMTI_THREAD_STATE_SLEEPING),
 54     &quot;STATE_SLEEPING&quot;
 55   },
 56   {
 57     (JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_INDEFINITELY | JVMTI_THREAD_STATE_IN_OBJECT_WAIT),
 58     &quot;STATE_IN_OBJECT_WAIT&quot;
 59   },
 60   {
 61     (JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT | JVMTI_THREAD_STATE_IN_OBJECT_WAIT),
 62     &quot;STATE_IN_OBJECT_WAIT_TIMED&quot;
 63   },
 64   {
 65     (JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_INDEFINITELY | JVMTI_THREAD_STATE_PARKED),
 66     &quot;STATE_PARKED&quot;
 67   },
 68   {
 69     (JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT | JVMTI_THREAD_STATE_PARKED),
 70     &quot;STATE_PARKED_TIMED&quot;
 71   },
 72   {
 73     JVMTI_JAVA_LANG_THREAD_STATE_BLOCKED,
 74     &quot;STATE_BLOCKED_ON_MONITOR_ENTER&quot;
 75   }
 76 };
 77 
 78 void JfrThreadState::serialize(JfrCheckpointWriter&amp; writer) {
 79   const u4 number_of_states = sizeof(states) / sizeof(jvmti_thread_state);
 80   writer.write_count(number_of_states);
 81   for (u4 i = 0; i &lt; number_of_states; ++i) {
 82     writer.write_key(states[i].id);
 83     writer.write(states[i].description);
 84   }
 85 }
 86 
 87 traceid JfrThreadId::id(const Thread* t) {
 88   assert(t != NULL, &quot;invariant&quot;);
 89   if (!t-&gt;is_Java_thread()) {
 90     return os_id(t);
 91   }
 92   const JavaThread* const jt = (JavaThread*)t;
 93   const oop thread_obj = jt-&gt;threadObj();
 94   return thread_obj != NULL ? java_lang_Thread::thread_id(thread_obj) : 0;
 95 }
 96 
 97 traceid JfrThreadId::os_id(const Thread* t) {
 98   assert(t != NULL, &quot;invariant&quot;);
 99   const OSThread* const os_thread = t-&gt;osthread();
100   return os_thread != NULL ? os_thread-&gt;thread_id() : 0;
101 }
102 
103 traceid JfrThreadId::jfr_id(const Thread* t) {
104   assert(t != NULL, &quot;invariant&quot;);
105   return t-&gt;jfr_thread_local()-&gt;thread_id();
106 }
107 
108 // caller needs ResourceMark
109 const char* get_java_thread_name(const Thread* t) {
110   assert(t != NULL, &quot;invariant&quot;);
111   assert(t-&gt;is_Java_thread(), &quot;invariant&quot;);
112   const JavaThread* const jt = ((JavaThread*)t);
113   const char* name_str = &quot;&lt;no-name - thread name unresolved&gt;&quot;;
114   const oop thread_obj = jt-&gt;threadObj();
115   if (thread_obj != NULL) {
116     const oop name = java_lang_Thread::name(thread_obj);
117     if (name != NULL) {
118       name_str = java_lang_String::as_utf8_string(name);
119     }
120   } else if (jt-&gt;is_attaching_via_jni()) {
121     name_str = &quot;&lt;no-name - thread is attaching&gt;&quot;;
122   }
123   assert(name_str != NULL, &quot;unexpected NULL thread name&quot;);
124   return name_str;
125 }
126 
127 const char* JfrThreadName::name(const Thread* t) {
128   assert(t != NULL, &quot;invariant&quot;);
129   return t-&gt;is_Java_thread() ? get_java_thread_name(t) : t-&gt;name();
130 }
    </pre>
  </body>
</html>
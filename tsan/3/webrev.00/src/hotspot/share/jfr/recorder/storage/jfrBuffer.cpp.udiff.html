<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/jfr/recorder/storage/jfrBuffer.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../stacktrace/jfrStackTraceRepository.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrBuffer.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/storage/jfrBuffer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -22,227 +22,251 @@</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;jfr/recorder/storage/jfrBuffer.hpp&quot;
<span class="udiff-line-removed">- #include &quot;runtime/atomic.hpp&quot;</span>
<span class="udiff-line-removed">- #include &quot;runtime/orderAccess.hpp&quot;</span>
  #include &quot;runtime/thread.inline.hpp&quot;
  
<span class="udiff-line-modified-removed">- static const u1* const MUTEX_CLAIM = NULL;</span>
<span class="udiff-line-modified-added">+ static const u1* const TOP_CRITICAL_SECTION = NULL;</span>
  
  JfrBuffer::JfrBuffer() : _next(NULL),
                           _prev(NULL),
                           _identity(NULL),
                           _pos(NULL),
                           _top(NULL),
                           _flags(0),
                           _header_size(0),
                           _size(0) {}
  
<span class="udiff-line-modified-removed">- bool JfrBuffer::initialize(size_t header_size, size_t size, const void* id /* NULL */) {</span>
<span class="udiff-line-modified-added">+ bool JfrBuffer::initialize(size_t header_size, size_t size) {</span>
<span class="udiff-line-added">+   assert(_next == NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-added">+   assert(_identity == NULL, &quot;invariant&quot;);</span>
    _header_size = (u2)header_size;
    _size = (u4)(size / BytesPerWord);
<span class="udiff-line-removed">-   assert(_identity == NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   _identity = id;</span>
    set_pos(start());
    set_top(start());
<span class="udiff-line-removed">-   assert(_next == NULL, &quot;invariant&quot;);</span>
    assert(free_size() == size, &quot;invariant&quot;);
    assert(!transient(), &quot;invariant&quot;);
    assert(!lease(), &quot;invariant&quot;);
    assert(!retired(), &quot;invariant&quot;);
    return true;
  }
  
<span class="udiff-line-modified-removed">- void JfrBuffer::reinitialize() {</span>
<span class="udiff-line-modified-removed">-   assert(!lease(), &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   assert(!transient(), &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   set_pos(start());</span>
<span class="udiff-line-removed">-   clear_retired();</span>
<span class="udiff-line-removed">-   set_top(start());</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void JfrBuffer::concurrent_reinitialization() {</span>
<span class="udiff-line-removed">-   concurrent_top();</span>
<span class="udiff-line-modified-added">+ void JfrBuffer::reinitialize(bool exclusion /* false */) {</span>
<span class="udiff-line-modified-added">+   acquire_critical_section_top();</span>
    assert(!lease(), &quot;invariant&quot;);
    assert(!transient(), &quot;invariant&quot;);
<span class="udiff-line-added">+   if (exclusion != excluded()) {</span>
<span class="udiff-line-added">+     // update</span>
<span class="udiff-line-added">+     if (exclusion) {</span>
<span class="udiff-line-added">+       set_excluded();</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       clear_excluded();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
    set_pos(start());
<span class="udiff-line-modified-removed">-   set_concurrent_top(start());</span>
<span class="udiff-line-modified-added">+   release_critical_section_top(start());</span>
    clear_retired();
  }
  
<span class="udiff-line-modified-removed">- size_t JfrBuffer::discard() {</span>
<span class="udiff-line-modified-removed">-   size_t discard_size = unflushed_size();</span>
<span class="udiff-line-removed">-   set_top(pos());</span>
<span class="udiff-line-removed">-   return discard_size;</span>
<span class="udiff-line-modified-added">+ const u1* JfrBuffer::top() const {</span>
<span class="udiff-line-modified-added">+   return Atomic::load_acquire(&amp;_top);</span>
  }
  
  const u1* JfrBuffer::stable_top() const {
    const u1* current_top;
    do {
<span class="udiff-line-modified-removed">-     current_top = OrderAccess::load_acquire(&amp;_top);</span>
<span class="udiff-line-modified-removed">-   } while (MUTEX_CLAIM == current_top);</span>
<span class="udiff-line-modified-added">+     current_top = top();</span>
<span class="udiff-line-modified-added">+   } while (TOP_CRITICAL_SECTION == current_top);</span>
    return current_top;
  }
  
<span class="udiff-line-removed">- const u1* JfrBuffer::top() const {</span>
<span class="udiff-line-removed">-   return _top;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  void JfrBuffer::set_top(const u1* new_top) {
<span class="udiff-line-modified-removed">-   _top = new_top;</span>
<span class="udiff-line-modified-added">+   assert(new_top &lt;= end(), &quot;invariant&quot;);</span>
<span class="udiff-line-added">+   assert(new_top &gt;= start(), &quot;invariant&quot;);</span>
<span class="udiff-line-added">+   Atomic::release_store(&amp;_top, new_top);</span>
  }
  
<span class="udiff-line-modified-removed">- const u1* JfrBuffer::concurrent_top() const {</span>
<span class="udiff-line-modified-added">+ const u1* JfrBuffer::acquire_critical_section_top() const {</span>
    do {
      const u1* current_top = stable_top();
<span class="udiff-line-modified-removed">-     if (Atomic::cmpxchg(MUTEX_CLAIM, &amp;_top, current_top) == current_top) {</span>
<span class="udiff-line-modified-added">+     assert(current_top != TOP_CRITICAL_SECTION, &quot;invariant&quot;);</span>
<span class="udiff-line-added">+     if (Atomic::cmpxchg(&amp;_top, current_top, TOP_CRITICAL_SECTION) == current_top) {</span>
        return current_top;
      }
    } while (true);
  }
  
<span class="udiff-line-modified-removed">- void JfrBuffer::set_concurrent_top(const u1* new_top) {</span>
<span class="udiff-line-modified-removed">-   assert(new_top != MUTEX_CLAIM, &quot;invariant&quot;);</span>
<span class="udiff-line-modified-removed">-   assert(new_top &lt;= end(), &quot;invariant&quot;);</span>
<span class="udiff-line-modified-removed">-   assert(new_top &gt;= start(), &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   assert(top() == MUTEX_CLAIM, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   OrderAccess::release_store(&amp;_top, new_top);</span>
<span class="udiff-line-modified-added">+ void JfrBuffer::release_critical_section_top(const u1* new_top) {</span>
<span class="udiff-line-modified-added">+   assert(new_top != TOP_CRITICAL_SECTION, &quot;invariant&quot;);</span>
<span class="udiff-line-modified-added">+   assert(top() == TOP_CRITICAL_SECTION, &quot;invariant&quot;);</span>
<span class="udiff-line-modified-added">+   set_top(new_top);</span>
  }
  
<span class="udiff-line-modified-removed">- size_t JfrBuffer::unflushed_size() const {</span>
<span class="udiff-line-modified-removed">-   return pos() - stable_top();</span>
<span class="udiff-line-modified-added">+ bool JfrBuffer::acquired_by(const void* id) const {</span>
<span class="udiff-line-modified-added">+   return identity() == id;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool JfrBuffer::acquired_by_self() const {</span>
<span class="udiff-line-added">+   return acquired_by(Thread::current());</span>
  }
  
  void JfrBuffer::acquire(const void* id) {
    assert(id != NULL, &quot;invariant&quot;);
    const void* current_id;
    do {
<span class="udiff-line-modified-removed">-     current_id = OrderAccess::load_acquire(&amp;_identity);</span>
<span class="udiff-line-modified-removed">-   } while (current_id != NULL || Atomic::cmpxchg(id, &amp;_identity, current_id) != current_id);</span>
<span class="udiff-line-modified-added">+     current_id = identity();</span>
<span class="udiff-line-modified-added">+   } while (current_id != NULL || Atomic::cmpxchg(&amp;_identity, current_id, id) != current_id);</span>
  }
  
  bool JfrBuffer::try_acquire(const void* id) {
    assert(id != NULL, &quot;invariant&quot;);
<span class="udiff-line-modified-removed">-   const void* const current_id = OrderAccess::load_acquire(&amp;_identity);</span>
<span class="udiff-line-modified-removed">-   return current_id == NULL &amp;&amp; Atomic::cmpxchg(id, &amp;_identity, current_id) == current_id;</span>
<span class="udiff-line-modified-added">+   const void* const current_id = identity();</span>
<span class="udiff-line-modified-added">+   return current_id == NULL &amp;&amp; Atomic::cmpxchg(&amp;_identity, current_id, id) == current_id;</span>
  }
  
  void JfrBuffer::release() {
<span class="udiff-line-modified-removed">-   OrderAccess::release_store(&amp;_identity, (const void*)NULL);</span>
<span class="udiff-line-modified-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void JfrBuffer::clear_identity() {</span>
<span class="udiff-line-removed">-   _identity = NULL;</span>
<span class="udiff-line-modified-added">+   assert(identity() != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-modified-added">+   Atomic::release_store(&amp;_identity, (const void*)NULL);</span>
  }
  
  #ifdef ASSERT
  static bool validate_to(const JfrBuffer* const to, size_t size) {
    assert(to != NULL, &quot;invariant&quot;);
    assert(to-&gt;acquired_by_self(), &quot;invariant&quot;);
    assert(to-&gt;free_size() &gt;= size, &quot;invariant&quot;);
    return true;
  }
  
<span class="udiff-line-removed">- static bool validate_concurrent_this(const JfrBuffer* const t, size_t size) {</span>
<span class="udiff-line-removed">-   assert(t-&gt;top() == MUTEX_CLAIM, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   return true;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  static bool validate_this(const JfrBuffer* const t, size_t size) {
<span class="udiff-line-modified-removed">-   assert(t-&gt;top() + size &lt;= t-&gt;pos(), &quot;invariant&quot;);</span>
<span class="udiff-line-modified-added">+   assert(t-&gt;acquired_by_self(), &quot;invariant&quot;);</span>
<span class="udiff-line-added">+   assert(t-&gt;top() == TOP_CRITICAL_SECTION, &quot;invariant&quot;);</span>
    return true;
  }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- bool JfrBuffer::acquired_by_self() const {</span>
<span class="udiff-line-removed">-   return identity() == Thread::current();</span>
<span class="udiff-line-removed">- }</span>
  #endif // ASSERT
  
  void JfrBuffer::move(JfrBuffer* const to, size_t size) {
    assert(validate_to(to, size), &quot;invariant&quot;);
<span class="udiff-line-added">+   const u1* const current_top = acquire_critical_section_top();</span>
    assert(validate_this(this, size), &quot;invariant&quot;);
<span class="udiff-line-modified-removed">-   const u1* current_top = top();</span>
<span class="udiff-line-modified-removed">-   assert(current_top != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-modified-removed">-   memcpy(to-&gt;pos(), current_top, size);</span>
<span class="udiff-line-modified-removed">-   to-&gt;set_pos(size);</span>
<span class="udiff-line-modified-added">+   const size_t actual_size = pos() - current_top;</span>
<span class="udiff-line-modified-added">+   assert(actual_size &lt;= size, &quot;invariant&quot;);</span>
<span class="udiff-line-modified-added">+   if (actual_size &gt; 0) {</span>
<span class="udiff-line-modified-added">+     memcpy(to-&gt;pos(), current_top, actual_size);</span>
<span class="udiff-line-added">+     to-&gt;set_pos(actual_size);</span>
<span class="udiff-line-added">+   }</span>
    to-&gt;release();
<span class="udiff-line-modified-removed">-   set_top(current_top + size);</span>
<span class="udiff-line-modified-added">+   set_pos(start());</span>
<span class="udiff-line-added">+   release_critical_section_top(start());</span>
  }
  
<span class="udiff-line-modified-removed">- void JfrBuffer::concurrent_move_and_reinitialize(JfrBuffer* const to, size_t size) {</span>
<span class="udiff-line-modified-removed">-   assert(validate_to(to, size), &quot;invariant&quot;);</span>
<span class="udiff-line-modified-removed">-   const u1* current_top = concurrent_top();</span>
<span class="udiff-line-modified-removed">-   assert(validate_concurrent_this(this, size), &quot;invariant&quot;);</span>
<span class="udiff-line-modified-removed">-   const size_t actual_size = MIN2(size, (size_t)(pos() - current_top));</span>
<span class="udiff-line-modified-removed">-   assert(actual_size &lt;= size, &quot;invariant&quot;);</span>
<span class="udiff-line-modified-removed">-   memcpy(to-&gt;pos(), current_top, actual_size);</span>
<span class="udiff-line-modified-removed">-   to-&gt;set_pos(actual_size);</span>
<span class="udiff-line-modified-removed">-   set_pos(start());</span>
<span class="udiff-line-modified-removed">-   to-&gt;release();</span>
<span class="udiff-line-modified-removed">-   set_concurrent_top(start());</span>
<span class="udiff-line-modified-added">+ size_t JfrBuffer::discard() {</span>
<span class="udiff-line-modified-added">+   const u1* const position = pos();</span>
<span class="udiff-line-modified-added">+   // stable_top() provides acquire semantics for pos()</span>
<span class="udiff-line-modified-added">+   const u1* const current_top = stable_top();</span>
<span class="udiff-line-modified-added">+   set_top(position);</span>
<span class="udiff-line-modified-added">+   return position - current_top;</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ size_t JfrBuffer::unflushed_size() const {</span>
<span class="udiff-line-modified-added">+   const u1* const position = pos();</span>
<span class="udiff-line-modified-added">+   // stable_top() provides acquire semantics for pos()</span>
<span class="udiff-line-added">+   return position - stable_top();</span>
  }
  
<span class="udiff-line-removed">- // flags</span>
  enum FLAG {
    RETIRED = 1,
    TRANSIENT = 2,
<span class="udiff-line-modified-removed">-   LEASE = 4</span>
<span class="udiff-line-modified-added">+   LEASE = 4,</span>
<span class="udiff-line-added">+   EXCLUDED = 8</span>
  };
  
<span class="udiff-line-added">+ inline u2 load(const volatile u2* flags) {</span>
<span class="udiff-line-added">+   assert(flags != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-added">+   return Atomic::load_acquire(flags);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ inline void set(u2* flags, FLAG flag) {</span>
<span class="udiff-line-added">+   assert(flags != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-added">+   OrderAccess::storestore();</span>
<span class="udiff-line-added">+   *flags |= (u1)flag;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ inline void clear(u2* flags, FLAG flag) {</span>
<span class="udiff-line-added">+   assert(flags != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-added">+   OrderAccess::storestore();</span>
<span class="udiff-line-added">+   *flags ^= (u1)flag;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ inline bool test(const u2* flags, FLAG flag) {</span>
<span class="udiff-line-added">+   return (u1)flag == (load(flags) &amp; (u1)flag);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  bool JfrBuffer::transient() const {
<span class="udiff-line-modified-removed">-   return (u1)TRANSIENT == (_flags &amp; (u1)TRANSIENT);</span>
<span class="udiff-line-modified-added">+   return test(&amp;_flags, TRANSIENT);</span>
  }
  
  void JfrBuffer::set_transient() {
<span class="udiff-line-modified-removed">-   _flags |= (u1)TRANSIENT;</span>
<span class="udiff-line-modified-added">+   assert(acquired_by_self(), &quot;invariant&quot;);</span>
<span class="udiff-line-added">+   set(&amp;_flags, TRANSIENT);</span>
    assert(transient(), &quot;invariant&quot;);
  }
  
  void JfrBuffer::clear_transient() {
    if (transient()) {
<span class="udiff-line-modified-removed">-     _flags ^= (u1)TRANSIENT;</span>
<span class="udiff-line-modified-added">+     assert(acquired_by_self(), &quot;invariant&quot;);</span>
<span class="udiff-line-added">+     clear(&amp;_flags, TRANSIENT);</span>
    }
    assert(!transient(), &quot;invariant&quot;);
  }
  
  bool JfrBuffer::lease() const {
<span class="udiff-line-modified-removed">-   return (u1)LEASE == (_flags &amp; (u1)LEASE);</span>
<span class="udiff-line-modified-added">+   return test(&amp;_flags, LEASE);</span>
  }
  
  void JfrBuffer::set_lease() {
<span class="udiff-line-modified-removed">-   _flags |= (u1)LEASE;</span>
<span class="udiff-line-modified-added">+   assert(acquired_by_self(), &quot;invariant&quot;);</span>
<span class="udiff-line-added">+   set(&amp;_flags, LEASE);</span>
    assert(lease(), &quot;invariant&quot;);
  }
  
  void JfrBuffer::clear_lease() {
    if (lease()) {
<span class="udiff-line-modified-removed">-     _flags ^= (u1)LEASE;</span>
<span class="udiff-line-modified-added">+     assert(acquired_by_self(), &quot;invariant&quot;);</span>
<span class="udiff-line-added">+     clear(&amp;_flags, LEASE);</span>
    }
    assert(!lease(), &quot;invariant&quot;);
  }
  
<span class="udiff-line-modified-removed">- static u2 load_acquire_flags(const u2* const flags) {</span>
<span class="udiff-line-modified-removed">-   return OrderAccess::load_acquire(flags);</span>
<span class="udiff-line-modified-added">+ bool JfrBuffer::excluded() const {</span>
<span class="udiff-line-modified-added">+   return test(&amp;_flags, EXCLUDED);</span>
  }
  
<span class="udiff-line-modified-removed">- static void release_store_flags(u2* const flags, u2 new_flags) {</span>
<span class="udiff-line-modified-removed">-   OrderAccess::release_store(flags, new_flags);</span>
<span class="udiff-line-modified-added">+ void JfrBuffer::set_excluded() {</span>
<span class="udiff-line-modified-added">+   assert(acquired_by_self(), &quot;invariant&quot;);</span>
<span class="udiff-line-added">+   set(&amp;_flags, EXCLUDED);</span>
<span class="udiff-line-added">+   assert(excluded(), &quot;invariant&quot;);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void JfrBuffer::clear_excluded() {</span>
<span class="udiff-line-added">+   if (excluded()) {</span>
<span class="udiff-line-added">+     assert(identity() != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-added">+     clear(&amp;_flags, EXCLUDED);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   assert(!excluded(), &quot;invariant&quot;);</span>
  }
  
  bool JfrBuffer::retired() const {
<span class="udiff-line-modified-removed">-   return (u1)RETIRED == (load_acquire_flags(&amp;_flags) &amp; (u1)RETIRED);</span>
<span class="udiff-line-modified-added">+   return test(&amp;_flags, RETIRED);</span>
  }
  
  void JfrBuffer::set_retired() {
<span class="udiff-line-modified-removed">-   const u2 new_flags = load_acquire_flags(&amp;_flags) | (u1)RETIRED;</span>
<span class="udiff-line-modified-removed">-   release_store_flags(&amp;_flags, new_flags);</span>
<span class="udiff-line-modified-added">+   assert(acquired_by_self(), &quot;invariant&quot;);</span>
<span class="udiff-line-modified-added">+   set(&amp;_flags, RETIRED);</span>
  }
  
  void JfrBuffer::clear_retired() {
<span class="udiff-line-modified-removed">-   u2 new_flags = load_acquire_flags(&amp;_flags);</span>
<span class="udiff-line-modified-removed">-   if ((u1)RETIRED == (new_flags &amp; (u1)RETIRED)) {</span>
<span class="udiff-line-modified-removed">-     new_flags ^= (u1)RETIRED;</span>
<span class="udiff-line-removed">-     release_store_flags(&amp;_flags, new_flags);</span>
<span class="udiff-line-modified-added">+   if (retired()) {</span>
<span class="udiff-line-modified-added">+     assert(identity() != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-modified-added">+     clear(&amp;_flags, RETIRED);</span>
    }
  }
</pre>
<center><a href="../stacktrace/jfrStackTraceRepository.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrBuffer.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
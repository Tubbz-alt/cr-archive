<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeSetUtils.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="jfrTypeSet.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="jfrTypeSetUtils.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeSetUtils.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/recorder/checkpoint/types/jfrTypeSetUtils.hpp&quot;
 27 #include &quot;oops/instanceKlass.hpp&quot;
 28 #include &quot;oops/oop.inline.hpp&quot;
 29 #include &quot;oops/symbol.hpp&quot;
 30 
<span class="line-modified"> 31 JfrSymbolId::JfrSymbolId() : _sym_table(new SymbolTable(this)), _cstring_table(new CStringTable(this)), _symbol_id_counter(0) {</span>










 32   assert(_sym_table != NULL, &quot;invariant&quot;);
 33   assert(_cstring_table != NULL, &quot;invariant&quot;);
<span class="line-modified"> 34   initialize();</span>



 35 }
 36 
<span class="line-modified"> 37 void JfrSymbolId::initialize() {</span>
 38   clear();
<span class="line-modified"> 39   assert(_symbol_id_counter == 0, &quot;invariant&quot;);</span>


 40 }
 41 
 42 void JfrSymbolId::clear() {
 43   assert(_sym_table != NULL, &quot;invariant&quot;);
 44   if (_sym_table-&gt;has_entries()) {
 45     _sym_table-&gt;clear_entries();
 46   }
 47   assert(!_sym_table-&gt;has_entries(), &quot;invariant&quot;);
 48 
 49   assert(_cstring_table != NULL, &quot;invariant&quot;);
 50   if (_cstring_table-&gt;has_entries()) {
 51     _cstring_table-&gt;clear_entries();
 52   }
 53   assert(!_cstring_table-&gt;has_entries(), &quot;invariant&quot;);
<span class="line-removed"> 54   _symbol_id_counter = 0;</span>
<span class="line-removed"> 55 }</span>
 56 
<span class="line-modified"> 57 JfrSymbolId::~JfrSymbolId() {</span>
<span class="line-modified"> 58   delete _sym_table;</span>
<span class="line-removed"> 59   delete _cstring_table;</span>
<span class="line-removed"> 60 }</span>
 61 
<span class="line-modified"> 62 traceid JfrSymbolId::mark_unsafe_anonymous_klass_name(const Klass* k) {</span>
<span class="line-modified"> 63   assert(k != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 64   assert(k-&gt;is_instance_klass(), &quot;invariant&quot;);</span>
<span class="line-removed"> 65   assert(is_unsafe_anonymous_klass(k), &quot;invariant&quot;);</span>
 66 
<span class="line-modified"> 67   uintptr_t anonymous_symbol_hash_code = 0;</span>
<span class="line-modified"> 68   const char* const anonymous_symbol =</span>
<span class="line-modified"> 69     create_unsafe_anonymous_klass_symbol((const InstanceKlass*)k, anonymous_symbol_hash_code);</span>

 70 
<span class="line-modified"> 71   if (anonymous_symbol == NULL) {</span>
<span class="line-modified"> 72     return 0;</span>
<span class="line-modified"> 73   }</span>
 74 
<span class="line-modified"> 75   assert(anonymous_symbol_hash_code != 0, &quot;invariant&quot;);</span>
<span class="line-modified"> 76   traceid symbol_id = mark(anonymous_symbol, anonymous_symbol_hash_code);</span>
<span class="line-modified"> 77   assert(mark(anonymous_symbol, anonymous_symbol_hash_code) == symbol_id, &quot;invariant&quot;);</span>
<span class="line-modified"> 78   return symbol_id;</span>



 79 }
 80 
<span class="line-modified"> 81 const JfrSymbolId::SymbolEntry* JfrSymbolId::map_symbol(const Symbol* symbol) const {</span>
<span class="line-modified"> 82   return _sym_table-&gt;lookup_only(symbol, (uintptr_t)const_cast&lt;Symbol*&gt;(symbol)-&gt;identity_hash());</span>



 83 }
 84 
<span class="line-modified"> 85 const JfrSymbolId::SymbolEntry* JfrSymbolId::map_symbol(uintptr_t hash) const {</span>
<span class="line-modified"> 86   return _sym_table-&gt;lookup_only(NULL, hash);</span>

 87 }
 88 
<span class="line-modified"> 89 const JfrSymbolId::CStringEntry* JfrSymbolId::map_cstring(uintptr_t hash) const {</span>
<span class="line-modified"> 90   return _cstring_table-&gt;lookup_only(NULL, hash);</span>





 91 }
 92 
<span class="line-modified"> 93 void JfrSymbolId::assign_id(SymbolEntry* entry) {</span>
 94   assert(entry != NULL, &quot;invariant&quot;);
 95   assert(entry-&gt;id() == 0, &quot;invariant&quot;);
 96   entry-&gt;set_id(++_symbol_id_counter);



 97 }
 98 
<span class="line-modified"> 99 bool JfrSymbolId::equals(const Symbol* query, uintptr_t hash, const SymbolEntry* entry) {</span>
<span class="line-modified">100   // query might be NULL</span>
<span class="line-modified">101   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">102   assert(entry-&gt;hash() == hash, &quot;invariant&quot;);</span>
<span class="line-modified">103   return true;</span>
104 }
105 
<span class="line-modified">106 void JfrSymbolId::assign_id(CStringEntry* entry) {</span>
107   assert(entry != NULL, &quot;invariant&quot;);
<span class="line-modified">108   assert(entry-&gt;id() == 0, &quot;invariant&quot;);</span>
<span class="line-modified">109   entry-&gt;set_id(++_symbol_id_counter);</span>

110 }
111 
<span class="line-modified">112 bool JfrSymbolId::equals(const char* query, uintptr_t hash, const CStringEntry* entry) {</span>
<span class="line-removed">113   // query might be NULL</span>
114   assert(entry != NULL, &quot;invariant&quot;);
<span class="line-modified">115   assert(entry-&gt;hash() == hash, &quot;invariant&quot;);</span>
<span class="line-removed">116   return true;</span>
117 }
118 
<span class="line-modified">119 traceid JfrSymbolId::mark(const Klass* k) {</span>
<span class="line-modified">120   assert(k != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">121   traceid symbol_id = 0;</span>
<span class="line-modified">122   if (is_unsafe_anonymous_klass(k)) {</span>
<span class="line-removed">123     symbol_id = mark_unsafe_anonymous_klass_name(k);</span>
124   }
<span class="line-modified">125   if (0 == symbol_id) {</span>
<span class="line-removed">126     const Symbol* const sym = k-&gt;name();</span>
<span class="line-removed">127     if (sym != NULL) {</span>
<span class="line-removed">128       symbol_id = mark(sym);</span>
<span class="line-removed">129     }</span>
<span class="line-removed">130   }</span>
<span class="line-removed">131   assert(symbol_id &gt; 0, &quot;a symbol handler must mark the symbol for writing&quot;);</span>
<span class="line-removed">132   return symbol_id;</span>
133 }
134 
<span class="line-modified">135 traceid JfrSymbolId::mark(const Symbol* symbol) {</span>
136   assert(symbol != NULL, &quot;invariant&quot;);
<span class="line-modified">137   return mark(symbol, (uintptr_t)const_cast&lt;Symbol*&gt;(symbol)-&gt;identity_hash());</span>
138 }
139 
<span class="line-modified">140 traceid JfrSymbolId::mark(const Symbol* data, uintptr_t hash) {</span>
141   assert(data != NULL, &quot;invariant&quot;);
142   assert(_sym_table != NULL, &quot;invariant&quot;);
<span class="line-modified">143   return _sym_table-&gt;id(data, hash);</span>








144 }
145 
<span class="line-modified">146 traceid JfrSymbolId::mark(const char* str, uintptr_t hash) {</span>
147   assert(str != NULL, &quot;invariant&quot;);
<span class="line-modified">148   return _cstring_table-&gt;id(str, hash);</span>
<span class="line-modified">149 }</span>
<span class="line-modified">150 </span>
<span class="line-modified">151 bool JfrSymbolId::is_unsafe_anonymous_klass(const Klass* k) {</span>
<span class="line-modified">152   assert(k != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">153   return k-&gt;is_instance_klass() &amp;&amp; ((const InstanceKlass*)k)-&gt;is_unsafe_anonymous();</span>




154 }
155 
156 /*
157 * jsr292 anonymous classes symbol is the external name +
158 * the identity_hashcode slash appended:
159 *   java.lang.invoke.LambdaForm$BMH/22626602
160 *
161 * caller needs ResourceMark
162 */
163 
<span class="line-modified">164 uintptr_t JfrSymbolId::unsafe_anonymous_klass_name_hash_code(const InstanceKlass* ik) {</span>
165   assert(ik != NULL, &quot;invariant&quot;);
166   assert(ik-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);
167   const oop mirror = ik-&gt;java_mirror_no_keepalive();
168   assert(mirror != NULL, &quot;invariant&quot;);
169   return (uintptr_t)mirror-&gt;identity_hash();
170 }
171 
<span class="line-modified">172 const char* JfrSymbolId::create_unsafe_anonymous_klass_symbol(const InstanceKlass* ik, uintptr_t&amp; hashcode) {</span>
173   assert(ik != NULL, &quot;invariant&quot;);
174   assert(ik-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);
<span class="line-modified">175   assert(0 == hashcode, &quot;invariant&quot;);</span>
176   char* anonymous_symbol = NULL;
177   const oop mirror = ik-&gt;java_mirror_no_keepalive();
178   assert(mirror != NULL, &quot;invariant&quot;);
179   char hash_buf[40];
<span class="line-modified">180   hashcode = unsafe_anonymous_klass_name_hash_code(ik);</span>
<span class="line-removed">181   sprintf(hash_buf, &quot;/&quot; UINTX_FORMAT, hashcode);</span>
182   const size_t hash_len = strlen(hash_buf);
183   const size_t result_len = ik-&gt;name()-&gt;utf8_length();
184   anonymous_symbol = NEW_RESOURCE_ARRAY(char, result_len + hash_len + 1);
185   ik-&gt;name()-&gt;as_klass_external_name(anonymous_symbol, (int)result_len + 1);
186   assert(strlen(anonymous_symbol) == result_len, &quot;invariant&quot;);
187   strcpy(anonymous_symbol + result_len, hash_buf);
188   assert(strlen(anonymous_symbol) == result_len + hash_len, &quot;invariant&quot;);
189   return anonymous_symbol;
190 }
191 
<span class="line-modified">192 uintptr_t JfrSymbolId::regular_klass_name_hash_code(const Klass* k) {</span>
193   assert(k != NULL, &quot;invariant&quot;);
<span class="line-modified">194   const Symbol* const sym = k-&gt;name();</span>
<span class="line-modified">195   assert(sym != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">196   return (uintptr_t)const_cast&lt;Symbol*&gt;(sym)-&gt;identity_hash();</span>























197 }
198 
199 JfrArtifactSet::JfrArtifactSet(bool class_unload) : _symbol_id(new JfrSymbolId()),
200                                                     _klass_list(NULL),
<span class="line-modified">201                                                     _class_unload(class_unload) {</span>
202   initialize(class_unload);
203   assert(_klass_list != NULL, &quot;invariant&quot;);
204 }
205 
206 static const size_t initial_class_list_size = 200;
<span class="line-modified">207 void JfrArtifactSet::initialize(bool class_unload) {</span>

208   assert(_symbol_id != NULL, &quot;invariant&quot;);
<span class="line-modified">209   _symbol_id-&gt;initialize();</span>
<span class="line-modified">210   assert(!_symbol_id-&gt;has_entries(), &quot;invariant&quot;);</span>
<span class="line-modified">211   _symbol_id-&gt;mark(BOOTSTRAP_LOADER_NAME, 0); // pre-load &quot;bootstrap&quot;</span>
<span class="line-modified">212   _class_unload = class_unload;</span>

213   // resource allocation
214   _klass_list = new GrowableArray&lt;const Klass*&gt;(initial_class_list_size, false, mtTracing);
215 }
216 
217 JfrArtifactSet::~JfrArtifactSet() {
<span class="line-removed">218   clear();</span>
<span class="line-removed">219 }</span>
<span class="line-removed">220 </span>
<span class="line-removed">221 void JfrArtifactSet::clear() {</span>
222   _symbol_id-&gt;clear();

223   // _klass_list will be cleared by a ResourceMark
224 }
225 
<span class="line-modified">226 traceid JfrArtifactSet::mark_unsafe_anonymous_klass_name(const Klass* klass) {</span>
<span class="line-modified">227   return _symbol_id-&gt;mark_unsafe_anonymous_klass_name(klass);</span>
<span class="line-removed">228 }</span>
<span class="line-removed">229 </span>
<span class="line-removed">230 traceid JfrArtifactSet::mark(const Symbol* sym, uintptr_t hash) {</span>
<span class="line-removed">231   return _symbol_id-&gt;mark(sym, hash);</span>
232 }
233 
<span class="line-modified">234 traceid JfrArtifactSet::mark(const Klass* klass) {</span>
<span class="line-modified">235   return _symbol_id-&gt;mark(klass);</span>

236 }
237 
<span class="line-modified">238 traceid JfrArtifactSet::mark(const Symbol* symbol) {</span>
<span class="line-modified">239   return _symbol_id-&gt;mark(symbol);</span>
240 }
241 
<span class="line-modified">242 traceid JfrArtifactSet::mark(const char* const str, uintptr_t hash) {</span>
<span class="line-modified">243   return _symbol_id-&gt;mark(str, hash);</span>
244 }
245 
<span class="line-modified">246 const JfrSymbolId::SymbolEntry* JfrArtifactSet::map_symbol(const Symbol* symbol) const {</span>
<span class="line-modified">247   return _symbol_id-&gt;map_symbol(symbol);</span>
248 }
249 
<span class="line-modified">250 const JfrSymbolId::SymbolEntry* JfrArtifactSet::map_symbol(uintptr_t hash) const {</span>
<span class="line-modified">251   return _symbol_id-&gt;map_symbol(hash);</span>
<span class="line-removed">252 }</span>
<span class="line-removed">253 </span>
<span class="line-removed">254 const JfrSymbolId::CStringEntry* JfrArtifactSet::map_cstring(uintptr_t hash) const {</span>
<span class="line-removed">255   return _symbol_id-&gt;map_cstring(hash);</span>
256 }
257 
258 bool JfrArtifactSet::has_klass_entries() const {
259   return _klass_list-&gt;is_nonempty();
260 }
261 
262 int JfrArtifactSet::entries() const {
263   return _klass_list-&gt;length();
264 }
265 
266 void JfrArtifactSet::register_klass(const Klass* k) {
267   assert(k != NULL, &quot;invariant&quot;);
268   assert(_klass_list != NULL, &quot;invariant&quot;);
269   assert(_klass_list-&gt;find(k) == -1, &quot;invariant&quot;);
270   _klass_list-&gt;append(k);
271 }




</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/recorder/checkpoint/types/jfrTypeSetUtils.hpp&quot;
 27 #include &quot;oops/instanceKlass.hpp&quot;
 28 #include &quot;oops/oop.inline.hpp&quot;
 29 #include &quot;oops/symbol.hpp&quot;
 30 
<span class="line-modified"> 31 static JfrSymbolId::CStringEntry* bootstrap = NULL;</span>
<span class="line-added"> 32 </span>
<span class="line-added"> 33 JfrSymbolId::JfrSymbolId() :</span>
<span class="line-added"> 34   _sym_table(new SymbolTable(this)),</span>
<span class="line-added"> 35   _cstring_table(new CStringTable(this)),</span>
<span class="line-added"> 36   _sym_list(NULL),</span>
<span class="line-added"> 37   _cstring_list(NULL),</span>
<span class="line-added"> 38   _sym_query(NULL),</span>
<span class="line-added"> 39   _cstring_query(NULL),</span>
<span class="line-added"> 40   _symbol_id_counter(1),</span>
<span class="line-added"> 41   _class_unload(false) {</span>
 42   assert(_sym_table != NULL, &quot;invariant&quot;);
 43   assert(_cstring_table != NULL, &quot;invariant&quot;);
<span class="line-modified"> 44   bootstrap = new CStringEntry(0, (const char*)&amp;BOOTSTRAP_LOADER_NAME);</span>
<span class="line-added"> 45   assert(bootstrap != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 46   bootstrap-&gt;set_id(1);</span>
<span class="line-added"> 47   _cstring_list = bootstrap;</span>
 48 }
 49 
<span class="line-modified"> 50 JfrSymbolId::~JfrSymbolId() {</span>
 51   clear();
<span class="line-modified"> 52   delete _sym_table;</span>
<span class="line-added"> 53   delete _cstring_table;</span>
<span class="line-added"> 54   delete bootstrap;</span>
 55 }
 56 
 57 void JfrSymbolId::clear() {
 58   assert(_sym_table != NULL, &quot;invariant&quot;);
 59   if (_sym_table-&gt;has_entries()) {
 60     _sym_table-&gt;clear_entries();
 61   }
 62   assert(!_sym_table-&gt;has_entries(), &quot;invariant&quot;);
 63 
 64   assert(_cstring_table != NULL, &quot;invariant&quot;);
 65   if (_cstring_table-&gt;has_entries()) {
 66     _cstring_table-&gt;clear_entries();
 67   }
 68   assert(!_cstring_table-&gt;has_entries(), &quot;invariant&quot;);


 69 
<span class="line-modified"> 70   _sym_list = NULL;</span>
<span class="line-modified"> 71   _symbol_id_counter = 1;</span>


 72 
<span class="line-modified"> 73   _sym_query = NULL;</span>
<span class="line-modified"> 74   _cstring_query = NULL;</span>


 75 
<span class="line-modified"> 76   assert(bootstrap != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 77   bootstrap-&gt;reset();</span>
<span class="line-modified"> 78   _cstring_list = bootstrap;</span>
<span class="line-added"> 79 }</span>
 80 
<span class="line-modified"> 81 void JfrSymbolId::set_class_unload(bool class_unload) {</span>
<span class="line-modified"> 82   _class_unload = class_unload;</span>
<span class="line-modified"> 83 }</span>
 84 
<span class="line-modified"> 85 void JfrSymbolId::on_link(const SymbolEntry* entry) {</span>
<span class="line-modified"> 86   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 87   const_cast&lt;Symbol*&gt;(entry-&gt;literal())-&gt;increment_refcount();</span>
<span class="line-modified"> 88   assert(entry-&gt;id() == 0, &quot;invariant&quot;);</span>
<span class="line-added"> 89   entry-&gt;set_id(++_symbol_id_counter);</span>
<span class="line-added"> 90   entry-&gt;set_list_next(_sym_list);</span>
<span class="line-added"> 91   _sym_list = entry;</span>
 92 }
 93 
<span class="line-modified"> 94 bool JfrSymbolId::on_equals(uintptr_t hash, const SymbolEntry* entry) {</span>
<span class="line-modified"> 95   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 96   assert(entry-&gt;hash() == hash, &quot;invariant&quot;);</span>
<span class="line-added"> 97   assert(_sym_query != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 98   return _sym_query == entry-&gt;literal();</span>
 99 }
100 
<span class="line-modified">101 void JfrSymbolId::on_unlink(const SymbolEntry* entry) {</span>
<span class="line-modified">102   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-added">103   const_cast&lt;Symbol*&gt;(entry-&gt;literal())-&gt;decrement_refcount();</span>
104 }
105 
<span class="line-modified">106 static const char* resource_to_cstring(const char* resource_str) {</span>
<span class="line-modified">107   assert(resource_str != NULL, &quot;invariant&quot;);</span>
<span class="line-added">108   const size_t length = strlen(resource_str);</span>
<span class="line-added">109   char* const c_string = JfrCHeapObj::new_array&lt;char&gt;(length + 1);</span>
<span class="line-added">110   assert(c_string != NULL, &quot;invariant&quot;);</span>
<span class="line-added">111   strncpy(c_string, resource_str, length + 1);</span>
<span class="line-added">112   return c_string;</span>
113 }
114 
<span class="line-modified">115 void JfrSymbolId::on_link(const CStringEntry* entry) {</span>
116   assert(entry != NULL, &quot;invariant&quot;);
117   assert(entry-&gt;id() == 0, &quot;invariant&quot;);
118   entry-&gt;set_id(++_symbol_id_counter);
<span class="line-added">119   const_cast&lt;CStringEntry*&gt;(entry)-&gt;set_literal(resource_to_cstring(entry-&gt;literal()));</span>
<span class="line-added">120   entry-&gt;set_list_next(_cstring_list);</span>
<span class="line-added">121   _cstring_list = entry;</span>
122 }
123 
<span class="line-modified">124 static bool string_compare(const char* query, const char* candidate) {</span>
<span class="line-modified">125   assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">126   assert(candidate != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">127   const size_t length = strlen(query);</span>
<span class="line-modified">128   return strncmp(query, candidate, length) == 0;</span>
129 }
130 
<span class="line-modified">131 bool JfrSymbolId::on_equals(uintptr_t hash, const CStringEntry* entry) {</span>
132   assert(entry != NULL, &quot;invariant&quot;);
<span class="line-modified">133   assert(entry-&gt;hash() == hash, &quot;invariant&quot;);</span>
<span class="line-modified">134   assert(_cstring_query != NULL, &quot;invariant&quot;);</span>
<span class="line-added">135   return string_compare(_cstring_query, entry-&gt;literal());</span>
136 }
137 
<span class="line-modified">138 void JfrSymbolId::on_unlink(const CStringEntry* entry) {</span>

139   assert(entry != NULL, &quot;invariant&quot;);
<span class="line-modified">140   JfrCHeapObj::free(const_cast&lt;char*&gt;(entry-&gt;literal()), strlen(entry-&gt;literal() + 1));</span>

141 }
142 
<span class="line-modified">143 traceid JfrSymbolId::bootstrap_name(bool leakp) {</span>
<span class="line-modified">144   assert(bootstrap != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">145   if (leakp) {</span>
<span class="line-modified">146     bootstrap-&gt;set_leakp();</span>

147   }
<span class="line-modified">148   return 1;</span>







149 }
150 
<span class="line-modified">151 traceid JfrSymbolId::mark(const Symbol* symbol, bool leakp) {</span>
152   assert(symbol != NULL, &quot;invariant&quot;);
<span class="line-modified">153   return mark((uintptr_t)symbol-&gt;identity_hash(), symbol, leakp);</span>
154 }
155 
<span class="line-modified">156 traceid JfrSymbolId::mark(uintptr_t hash, const Symbol* data, bool leakp) {</span>
157   assert(data != NULL, &quot;invariant&quot;);
158   assert(_sym_table != NULL, &quot;invariant&quot;);
<span class="line-modified">159   _sym_query = data;</span>
<span class="line-added">160   const SymbolEntry&amp; entry = _sym_table-&gt;lookup_put(hash, data);</span>
<span class="line-added">161   if (_class_unload) {</span>
<span class="line-added">162     entry.set_unloading();</span>
<span class="line-added">163   }</span>
<span class="line-added">164   if (leakp) {</span>
<span class="line-added">165     entry.set_leakp();</span>
<span class="line-added">166   }</span>
<span class="line-added">167   return entry.id();</span>
168 }
169 
<span class="line-modified">170 traceid JfrSymbolId::mark(uintptr_t hash, const char* str, bool leakp) {</span>
171   assert(str != NULL, &quot;invariant&quot;);
<span class="line-modified">172   assert(_cstring_table != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">173   _cstring_query = str;</span>
<span class="line-modified">174   const CStringEntry&amp; entry = _cstring_table-&gt;lookup_put(hash, str);</span>
<span class="line-modified">175   if (_class_unload) {</span>
<span class="line-modified">176     entry.set_unloading();</span>
<span class="line-modified">177   }</span>
<span class="line-added">178   if (leakp) {</span>
<span class="line-added">179     entry.set_leakp();</span>
<span class="line-added">180   }</span>
<span class="line-added">181   return entry.id();</span>
182 }
183 
184 /*
185 * jsr292 anonymous classes symbol is the external name +
186 * the identity_hashcode slash appended:
187 *   java.lang.invoke.LambdaForm$BMH/22626602
188 *
189 * caller needs ResourceMark
190 */
191 
<span class="line-modified">192 uintptr_t JfrSymbolId::unsafe_anonymous_klass_name_hash(const InstanceKlass* ik) {</span>
193   assert(ik != NULL, &quot;invariant&quot;);
194   assert(ik-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);
195   const oop mirror = ik-&gt;java_mirror_no_keepalive();
196   assert(mirror != NULL, &quot;invariant&quot;);
197   return (uintptr_t)mirror-&gt;identity_hash();
198 }
199 
<span class="line-modified">200 static const char* create_unsafe_anonymous_klass_symbol(const InstanceKlass* ik, uintptr_t hash) {</span>
201   assert(ik != NULL, &quot;invariant&quot;);
202   assert(ik-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);
<span class="line-modified">203   assert(hash != 0, &quot;invariant&quot;);</span>
204   char* anonymous_symbol = NULL;
205   const oop mirror = ik-&gt;java_mirror_no_keepalive();
206   assert(mirror != NULL, &quot;invariant&quot;);
207   char hash_buf[40];
<span class="line-modified">208   sprintf(hash_buf, &quot;/&quot; UINTX_FORMAT, hash);</span>

209   const size_t hash_len = strlen(hash_buf);
210   const size_t result_len = ik-&gt;name()-&gt;utf8_length();
211   anonymous_symbol = NEW_RESOURCE_ARRAY(char, result_len + hash_len + 1);
212   ik-&gt;name()-&gt;as_klass_external_name(anonymous_symbol, (int)result_len + 1);
213   assert(strlen(anonymous_symbol) == result_len, &quot;invariant&quot;);
214   strcpy(anonymous_symbol + result_len, hash_buf);
215   assert(strlen(anonymous_symbol) == result_len + hash_len, &quot;invariant&quot;);
216   return anonymous_symbol;
217 }
218 
<span class="line-modified">219 bool JfrSymbolId::is_unsafe_anonymous_klass(const Klass* k) {</span>
220   assert(k != NULL, &quot;invariant&quot;);
<span class="line-modified">221   return k-&gt;is_instance_klass() &amp;&amp; ((const InstanceKlass*)k)-&gt;is_unsafe_anonymous();</span>
<span class="line-modified">222 }</span>
<span class="line-modified">223 </span>
<span class="line-added">224 traceid JfrSymbolId::mark_unsafe_anonymous_klass_name(const InstanceKlass* ik, bool leakp) {</span>
<span class="line-added">225   assert(ik != NULL, &quot;invariant&quot;);</span>
<span class="line-added">226   assert(ik-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);</span>
<span class="line-added">227   const uintptr_t hash = unsafe_anonymous_klass_name_hash(ik);</span>
<span class="line-added">228   const char* const anonymous_klass_symbol = create_unsafe_anonymous_klass_symbol(ik, hash);</span>
<span class="line-added">229   return mark(hash, anonymous_klass_symbol, leakp);</span>
<span class="line-added">230 }</span>
<span class="line-added">231 </span>
<span class="line-added">232 traceid JfrSymbolId::mark(const Klass* k, bool leakp) {</span>
<span class="line-added">233   assert(k != NULL, &quot;invariant&quot;);</span>
<span class="line-added">234   traceid symbol_id = 0;</span>
<span class="line-added">235   if (is_unsafe_anonymous_klass(k)) {</span>
<span class="line-added">236     assert(k-&gt;is_instance_klass(), &quot;invariant&quot;);</span>
<span class="line-added">237     symbol_id = mark_unsafe_anonymous_klass_name((const InstanceKlass*)k, leakp);</span>
<span class="line-added">238   }</span>
<span class="line-added">239   if (0 == symbol_id) {</span>
<span class="line-added">240     Symbol* const sym = k-&gt;name();</span>
<span class="line-added">241     if (sym != NULL) {</span>
<span class="line-added">242       symbol_id = mark(sym, leakp);</span>
<span class="line-added">243     }</span>
<span class="line-added">244   }</span>
<span class="line-added">245   assert(symbol_id &gt; 0, &quot;a symbol handler must mark the symbol for writing&quot;);</span>
<span class="line-added">246   return symbol_id;</span>
247 }
248 
249 JfrArtifactSet::JfrArtifactSet(bool class_unload) : _symbol_id(new JfrSymbolId()),
250                                                     _klass_list(NULL),
<span class="line-modified">251                                                     _total_count(0) {</span>
252   initialize(class_unload);
253   assert(_klass_list != NULL, &quot;invariant&quot;);
254 }
255 
256 static const size_t initial_class_list_size = 200;
<span class="line-modified">257 </span>
<span class="line-added">258 void JfrArtifactSet::initialize(bool class_unload, bool clear /* false */) {</span>
259   assert(_symbol_id != NULL, &quot;invariant&quot;);
<span class="line-modified">260   if (clear) {</span>
<span class="line-modified">261     _symbol_id-&gt;clear();</span>
<span class="line-modified">262   }</span>
<span class="line-modified">263   _symbol_id-&gt;set_class_unload(class_unload);</span>
<span class="line-added">264   _total_count = 0;</span>
265   // resource allocation
266   _klass_list = new GrowableArray&lt;const Klass*&gt;(initial_class_list_size, false, mtTracing);
267 }
268 
269 JfrArtifactSet::~JfrArtifactSet() {




270   _symbol_id-&gt;clear();
<span class="line-added">271   delete _symbol_id;</span>
272   // _klass_list will be cleared by a ResourceMark
273 }
274 
<span class="line-modified">275 traceid JfrArtifactSet::bootstrap_name(bool leakp) {</span>
<span class="line-modified">276   return _symbol_id-&gt;bootstrap_name(leakp);</span>




277 }
278 
<span class="line-modified">279 traceid JfrArtifactSet::mark_unsafe_anonymous_klass_name(const Klass* klass, bool leakp) {</span>
<span class="line-modified">280   assert(klass-&gt;is_instance_klass(), &quot;invariant&quot;);</span>
<span class="line-added">281   return _symbol_id-&gt;mark_unsafe_anonymous_klass_name((const InstanceKlass*)klass, leakp);</span>
282 }
283 
<span class="line-modified">284 traceid JfrArtifactSet::mark(uintptr_t hash, const Symbol* sym, bool leakp) {</span>
<span class="line-modified">285   return _symbol_id-&gt;mark(hash, sym, leakp);</span>
286 }
287 
<span class="line-modified">288 traceid JfrArtifactSet::mark(const Klass* klass, bool leakp) {</span>
<span class="line-modified">289   return _symbol_id-&gt;mark(klass, leakp);</span>
290 }
291 
<span class="line-modified">292 traceid JfrArtifactSet::mark(const Symbol* symbol, bool leakp) {</span>
<span class="line-modified">293   return _symbol_id-&gt;mark(symbol, leakp);</span>
294 }
295 
<span class="line-modified">296 traceid JfrArtifactSet::mark(uintptr_t hash, const char* const str, bool leakp) {</span>
<span class="line-modified">297   return _symbol_id-&gt;mark(hash, str, leakp);</span>




298 }
299 
300 bool JfrArtifactSet::has_klass_entries() const {
301   return _klass_list-&gt;is_nonempty();
302 }
303 
304 int JfrArtifactSet::entries() const {
305   return _klass_list-&gt;length();
306 }
307 
308 void JfrArtifactSet::register_klass(const Klass* k) {
309   assert(k != NULL, &quot;invariant&quot;);
310   assert(_klass_list != NULL, &quot;invariant&quot;);
311   assert(_klass_list-&gt;find(k) == -1, &quot;invariant&quot;);
312   _klass_list-&gt;append(k);
313 }
<span class="line-added">314 </span>
<span class="line-added">315 size_t JfrArtifactSet::total_count() const {</span>
<span class="line-added">316   return _total_count;</span>
<span class="line-added">317 }</span>
</pre>
</td>
</tr>
</table>
<center><a href="jfrTypeSet.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="jfrTypeSetUtils.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/jfr/recorder/checkpoint/types/traceid/jfrTraceId.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="jfrTraceId.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="jfrTraceIdBits.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/checkpoint/types/traceid/jfrTraceId.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 26,35 ***</span>
  #define SHARE_JFR_RECORDER_CHECKPOINT_TYPES_TRACEID_JFRTRACEID_INLINE_HPP
  
  #include &quot;classfile/classLoaderData.hpp&quot;
  #include &quot;classfile/moduleEntry.hpp&quot;
  #include &quot;classfile/packageEntry.hpp&quot;
<span class="line-removed">- #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceIdMacros.hpp&quot;</span>
  #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceId.hpp&quot;
  #include &quot;oops/arrayKlass.hpp&quot;
  #include &quot;oops/klass.hpp&quot;
  #include &quot;oops/instanceKlass.hpp&quot;
  #include &quot;oops/method.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;utilities/debug.hpp&quot;
  
  template &lt;typename T&gt;
<span class="line-modified">! inline traceid set_used_and_get(const T* type, bool leakp) {</span>
<span class="line-modified">!   assert(type != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   if (leakp) {</span>
<span class="line-modified">!     SET_LEAKP_USED_THIS_EPOCH(type);</span>
<span class="line-modified">!     assert(LEAKP_USED_THIS_EPOCH(type), &quot;invariant&quot;);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   SET_USED_THIS_EPOCH(type);</span>
<span class="line-modified">!   assert(USED_THIS_EPOCH(type), &quot;invariant&quot;);</span>
<span class="line-modified">!   return TRACE_ID_MASKED_PTR(type);</span>
  }
  
  template &lt;typename T&gt;
<span class="line-modified">! inline traceid set_used_and_get_shifted(const T* type, bool leakp) {</span>
    assert(type != NULL, &quot;invariant&quot;);
<span class="line-modified">!   return set_used_and_get(type, leakp) &gt;&gt; TRACE_ID_SHIFT;</span>
  }
  
  inline traceid JfrTraceId::get(const Klass* klass) {
    assert(klass != NULL, &quot;invariant&quot;);
    return TRACE_ID(klass);
<span class="line-new-header">--- 26,47 ---</span>
  #define SHARE_JFR_RECORDER_CHECKPOINT_TYPES_TRACEID_JFRTRACEID_INLINE_HPP
  
  #include &quot;classfile/classLoaderData.hpp&quot;
  #include &quot;classfile/moduleEntry.hpp&quot;
  #include &quot;classfile/packageEntry.hpp&quot;
  #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceId.hpp&quot;
<span class="line-added">+ #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceIdBits.inline.hpp&quot;</span>
<span class="line-added">+ #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceIdEpoch.hpp&quot;</span>
<span class="line-added">+ #include &quot;jfr/support/jfrKlassExtension.hpp&quot;</span>
  #include &quot;oops/arrayKlass.hpp&quot;
  #include &quot;oops/klass.hpp&quot;
  #include &quot;oops/instanceKlass.hpp&quot;
  #include &quot;oops/method.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;utilities/debug.hpp&quot;
  
<span class="line-added">+ inline bool is_not_tagged(traceid value) {</span>
<span class="line-added">+   const traceid this_epoch_bit = JfrTraceIdEpoch::in_use_this_epoch_bit();</span>
<span class="line-added">+   return (value &amp; ((this_epoch_bit &lt;&lt; META_SHIFT) | this_epoch_bit)) != this_epoch_bit;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  template &lt;typename T&gt;
<span class="line-modified">! inline bool should_tag(const T* t) {</span>
<span class="line-modified">!   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   return is_not_tagged(TRACE_ID_RAW(t));</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! template &lt;&gt;</span>
<span class="line-modified">! inline bool should_tag&lt;Method&gt;(const Method* method) {</span>
<span class="line-modified">!   assert(method != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   return is_not_tagged((traceid)method-&gt;trace_flags());</span>
  }
  
  template &lt;typename T&gt;
<span class="line-modified">! inline traceid set_used_and_get(const T* type) {</span>
    assert(type != NULL, &quot;invariant&quot;);
<span class="line-modified">!   if (should_tag(type)) {</span>
<span class="line-added">+     SET_USED_THIS_EPOCH(type);</span>
<span class="line-added">+     JfrTraceIdEpoch::set_changed_tag_state();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   assert(USED_THIS_EPOCH(type), &quot;invariant&quot;);</span>
<span class="line-added">+   return TRACE_ID(type);</span>
  }
  
  inline traceid JfrTraceId::get(const Klass* klass) {
    assert(klass != NULL, &quot;invariant&quot;);
    return TRACE_ID(klass);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 63,42 ***</span>
  inline traceid JfrTraceId::get(const Thread* t) {
    assert(t != NULL, &quot;invariant&quot;);
    return TRACE_ID_RAW(t-&gt;jfr_thread_local());
  }
  
<span class="line-modified">! inline traceid JfrTraceId::use(const Klass* klass, bool leakp /* false */) {</span>
    assert(klass != NULL, &quot;invariant&quot;);
<span class="line-modified">!   return set_used_and_get_shifted(klass, leakp);</span>
  }
  
<span class="line-modified">! inline traceid JfrTraceId::use(const Method* method, bool leakp /* false */) {</span>
<span class="line-modified">!   assert(method != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   SET_METHOD_FLAG_USED_THIS_EPOCH(method);</span>
<span class="line-modified">!   const Klass* const klass = method-&gt;method_holder();</span>
    assert(klass != NULL, &quot;invariant&quot;);
<span class="line-modified">!   if (leakp) {</span>
<span class="line-modified">!     SET_LEAKP_USED_THIS_EPOCH(klass);</span>
<span class="line-modified">!     assert(LEAKP_USED_THIS_EPOCH(klass), &quot;invariant&quot;);</span>
    }
<span class="line-removed">-   SET_METHOD_AND_CLASS_USED_THIS_EPOCH(klass);</span>
<span class="line-removed">-   assert(METHOD_AND_CLASS_USED_THIS_EPOCH(klass), &quot;invariant&quot;);</span>
    return (METHOD_ID(klass, method));
  }
  
<span class="line-modified">! inline traceid JfrTraceId::use(const ModuleEntry* module, bool leakp /* false */) {</span>
<span class="line-modified">!   assert(module != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   return set_used_and_get_shifted(module, leakp);</span>
  }
  
<span class="line-modified">! inline traceid JfrTraceId::use(const PackageEntry* package, bool leakp /* false */) {</span>
<span class="line-modified">!   assert(package != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   return set_used_and_get_shifted(package, leakp);</span>
  }
  
<span class="line-modified">! inline traceid JfrTraceId::use(const ClassLoaderData* cld, bool leakp /* false */) {</span>
    assert(cld != NULL, &quot;invariant&quot;);
<span class="line-modified">!   return cld-&gt;is_unsafe_anonymous() ? 0 : set_used_and_get_shifted(cld, leakp);</span>
  }
  
  inline bool JfrTraceId::in_visible_set(const Klass* klass) {
    assert(klass != NULL, &quot;invariant&quot;);
    assert(((JavaThread*)Thread::current())-&gt;thread_state() == _thread_in_vm, &quot;invariant&quot;);
<span class="line-new-header">--- 75,64 ---</span>
  inline traceid JfrTraceId::get(const Thread* t) {
    assert(t != NULL, &quot;invariant&quot;);
    return TRACE_ID_RAW(t-&gt;jfr_thread_local());
  }
  
<span class="line-modified">! inline traceid JfrTraceId::use(const Klass* klass) {</span>
    assert(klass != NULL, &quot;invariant&quot;);
<span class="line-modified">!   if (should_tag(klass)) {</span>
<span class="line-added">+     SET_USED_THIS_EPOCH(klass);</span>
<span class="line-added">+     JfrTraceIdEpoch::set_changed_tag_state();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   assert(USED_THIS_EPOCH(klass), &quot;invariant&quot;);</span>
<span class="line-added">+   return get(klass);</span>
  }
  
<span class="line-modified">! inline traceid JfrTraceId::use(const Method* method) {</span>
<span class="line-modified">!   return use(method-&gt;method_holder(), method);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-added">+ inline traceid JfrTraceId::use(const Klass* klass, const Method* method) {</span>
    assert(klass != NULL, &quot;invariant&quot;);
<span class="line-modified">!   assert(method != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   if (METHOD_FLAG_NOT_USED_THIS_EPOCH(method)) {</span>
<span class="line-modified">!     SET_METHOD_AND_CLASS_USED_THIS_EPOCH(klass);</span>
<span class="line-added">+     SET_METHOD_FLAG_USED_THIS_EPOCH(method);</span>
<span class="line-added">+     assert(METHOD_AND_CLASS_USED_THIS_EPOCH(klass), &quot;invariant&quot;);</span>
<span class="line-added">+     assert(METHOD_FLAG_USED_THIS_EPOCH(method), &quot;invariant&quot;);</span>
<span class="line-added">+     JfrTraceIdEpoch::set_changed_tag_state();</span>
    }
    return (METHOD_ID(klass, method));
  }
  
<span class="line-modified">! inline traceid JfrTraceId::use(const ModuleEntry* module) {</span>
<span class="line-modified">!   return set_used_and_get(module);</span>
  }
  
<span class="line-modified">! inline traceid JfrTraceId::use(const PackageEntry* package) {</span>
<span class="line-modified">!   return set_used_and_get(package);</span>
  }
  
<span class="line-modified">! inline traceid JfrTraceId::use(const ClassLoaderData* cld) {</span>
    assert(cld != NULL, &quot;invariant&quot;);
<span class="line-modified">!   return cld-&gt;is_unsafe_anonymous() ? 0 : set_used_and_get(cld);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline void JfrTraceId::set_leakp(const Klass* klass, const Method* method) {</span>
<span class="line-added">+   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(METHOD_AND_CLASS_USED_THIS_EPOCH(klass), &quot;invariant&quot;);</span>
<span class="line-added">+   assert(method != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(klass == method-&gt;method_holder(), &quot;invariant&quot;);</span>
<span class="line-added">+   if (METHOD_FLAG_NOT_USED_THIS_EPOCH(method)) {</span>
<span class="line-added">+     // the method is already logically tagged, just like the klass,</span>
<span class="line-added">+     // but because of redefinition, the latest Method*</span>
<span class="line-added">+     // representation might not have a reified tag.</span>
<span class="line-added">+     SET_METHOD_FLAG_USED_THIS_EPOCH(method);</span>
<span class="line-added">+     assert(METHOD_FLAG_USED_THIS_EPOCH(method), &quot;invariant&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   SET_LEAKP(klass);</span>
<span class="line-added">+   SET_METHOD_LEAKP(method);</span>
  }
  
  inline bool JfrTraceId::in_visible_set(const Klass* klass) {
    assert(klass != NULL, &quot;invariant&quot;);
    assert(((JavaThread*)Thread::current())-&gt;thread_state() == _thread_in_vm, &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 110,11 ***</span>
    return IS_JDK_JFR_EVENT_KLASS(k);
  }
  
  inline void JfrTraceId::tag_as_jdk_jfr_event(const Klass* klass) {
    assert(klass != NULL, &quot;invariant&quot;);
<span class="line-modified">!   SET_TAG(klass, JDK_JFR_EVENT_KLASS);</span>
    assert(IS_JDK_JFR_EVENT_KLASS(klass), &quot;invariant&quot;);
  }
  
  inline bool JfrTraceId::is_jdk_jfr_event_sub(const Klass* k) {
    assert(k != NULL, &quot;invariant&quot;);
<span class="line-new-header">--- 144,11 ---</span>
    return IS_JDK_JFR_EVENT_KLASS(k);
  }
  
  inline void JfrTraceId::tag_as_jdk_jfr_event(const Klass* klass) {
    assert(klass != NULL, &quot;invariant&quot;);
<span class="line-modified">!   SET_JDK_JFR_EVENT_KLASS(klass);</span>
    assert(IS_JDK_JFR_EVENT_KLASS(klass), &quot;invariant&quot;);
  }
  
  inline bool JfrTraceId::is_jdk_jfr_event_sub(const Klass* k) {
    assert(k != NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 122,11 ***</span>
  }
  
  inline void JfrTraceId::tag_as_jdk_jfr_event_sub(const Klass* k) {
    assert(k != NULL, &quot;invariant&quot;);
    if (IS_NOT_AN_EVENT_SUB_KLASS(k)) {
<span class="line-modified">!     SET_TAG(k, JDK_JFR_EVENT_SUBKLASS);</span>
    }
    assert(IS_JDK_JFR_EVENT_SUBKLASS(k), &quot;invariant&quot;);
  }
  
  inline bool JfrTraceId::in_jdk_jfr_event_hierarchy(const Klass* klass) {
<span class="line-new-header">--- 156,11 ---</span>
  }
  
  inline void JfrTraceId::tag_as_jdk_jfr_event_sub(const Klass* k) {
    assert(k != NULL, &quot;invariant&quot;);
    if (IS_NOT_AN_EVENT_SUB_KLASS(k)) {
<span class="line-modified">!     SET_JDK_JFR_EVENT_SUBKLASS(k);</span>
    }
    assert(IS_JDK_JFR_EVENT_SUBKLASS(k), &quot;invariant&quot;);
  }
  
  inline bool JfrTraceId::in_jdk_jfr_event_hierarchy(const Klass* klass) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 143,10 ***</span>
    return IS_EVENT_HOST_KLASS(k);
  }
  
  inline void JfrTraceId::tag_as_event_host(const Klass* k) {
    assert(k != NULL, &quot;invariant&quot;);
<span class="line-modified">!   SET_TAG(k, EVENT_HOST_KLASS);</span>
    assert(IS_EVENT_HOST_KLASS(k), &quot;invariant&quot;);
  }
  
  #endif // SHARE_JFR_RECORDER_CHECKPOINT_TYPES_TRACEID_JFRTRACEID_INLINE_HPP
<span class="line-new-header">--- 177,10 ---</span>
    return IS_EVENT_HOST_KLASS(k);
  }
  
  inline void JfrTraceId::tag_as_event_host(const Klass* k) {
    assert(k != NULL, &quot;invariant&quot;);
<span class="line-modified">!   SET_EVENT_HOST_KLASS(k);</span>
    assert(IS_EVENT_HOST_KLASS(k), &quot;invariant&quot;);
  }
  
  #endif // SHARE_JFR_RECORDER_CHECKPOINT_TYPES_TRACEID_JFRTRACEID_INLINE_HPP
</pre>
<center><a href="jfrTraceId.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="jfrTraceIdBits.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
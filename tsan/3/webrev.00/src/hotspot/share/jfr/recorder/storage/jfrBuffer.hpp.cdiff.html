<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/jfr/recorder/storage/jfrBuffer.hpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="jfrBuffer.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrMemorySpace.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/storage/jfrBuffer.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,49 ***</span>
  
  #ifndef SHARE_JFR_RECORDER_STORAGE_JFRBUFFER_HPP
  #define SHARE_JFR_RECORDER_STORAGE_JFRBUFFER_HPP
  
  #include &quot;memory/allocation.hpp&quot;
  
  //
  // Represents a piece of committed memory.
  //
<span class="line-removed">- // u1* _pos &lt;-- next store position</span>
<span class="line-removed">- // u1* _top &lt;-- next unflushed position</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // const void* _identity &lt;-- acquired by</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // Must be the owner before attempting stores.</span>
  // Use acquire() and/or try_acquire() for exclusive access
<span class="line-modified">! // to the (entire) buffer (cas identity).</span>
  //
<span class="line-modified">! // Stores to the buffer should uphold transactional semantics.</span>
<span class="line-modified">! // A new _pos must be updated only after all intended stores have completed.</span>
  // The relation between _pos and _top must hold atomically,
  // e.g. the delta must always be fully parsable.
  // _top can move concurrently by other threads but is always &lt;= _pos.
  //
  class JfrBuffer {
   private:
    JfrBuffer* _next;
    JfrBuffer* _prev;
<span class="line-modified">!   const void* volatile _identity;</span>
    u1* _pos;
<span class="line-modified">!   mutable const u1* volatile _top;</span>
    u2 _flags;
    u2 _header_size;
    u4 _size;
  
    const u1* stable_top() const;
<span class="line-removed">-   void clear_flags();</span>
  
   public:
    JfrBuffer();
<span class="line-modified">!   bool initialize(size_t header_size, size_t size, const void* id = NULL);</span>
<span class="line-modified">!   void reinitialize();</span>
<span class="line-modified">!   void concurrent_reinitialization();</span>
<span class="line-removed">-   size_t discard();</span>
    JfrBuffer* next() const {
      return _next;
    }
  
    JfrBuffer* prev() const {
<span class="line-new-header">--- 24,61 ---</span>
  
  #ifndef SHARE_JFR_RECORDER_STORAGE_JFRBUFFER_HPP
  #define SHARE_JFR_RECORDER_STORAGE_JFRBUFFER_HPP
  
  #include &quot;memory/allocation.hpp&quot;
<span class="line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
  
  //
  // Represents a piece of committed memory.
  //
  // Use acquire() and/or try_acquire() for exclusive access
<span class="line-modified">! // to the buffer (cas identity). This is a precondition</span>
<span class="line-added">+ // for attempting stores.</span>
  //
<span class="line-modified">! // u1* _pos &lt;-- last committed position</span>
<span class="line-modified">! // u1* _top &lt;-- next unflushed position</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // Stores must uphold transactional semantics. This means that _pos</span>
<span class="line-added">+ // must be updated only after all intended stores have completed already.</span>
  // The relation between _pos and _top must hold atomically,
  // e.g. the delta must always be fully parsable.
  // _top can move concurrently by other threads but is always &lt;= _pos.
  //
<span class="line-added">+ // Memory ordering:</span>
<span class="line-added">+ //</span>
<span class="line-added">+ //  Method                 Owner thread             Other threads</span>
<span class="line-added">+ //  ---------------------------------------------------------------</span>
<span class="line-added">+ //  acquire()              Acquire semantics (cas)  Acquire semantics (cas)</span>
<span class="line-added">+ //  try_acquire()          Acquire semantics (cas)  Acquire semantics (cas)</span>
<span class="line-added">+ //  release()              Release semantics        Release semantics</span>
<span class="line-added">+ //  pos()                  Plain load               Acquire semantics needed at call sites</span>
<span class="line-added">+ //  set_pos()              Release semantics        N/A</span>
<span class="line-added">+ //  top()                  Acquire semantics        Acquire semantics</span>
<span class="line-added">+ //  set_top()              Release semantics        Release semantics</span>
<span class="line-added">+ //  acquire_crit_sec_top() Acquire semantics (cas)  Acquire semantics (cas)</span>
<span class="line-added">+ //  release_crit_sec_top() Release semantics        Release semantics</span>
<span class="line-added">+ //</span>
<span class="line-added">+ </span>
  class JfrBuffer {
   private:
    JfrBuffer* _next;
    JfrBuffer* _prev;
<span class="line-modified">!   const void* _identity;</span>
    u1* _pos;
<span class="line-modified">!   mutable const u1* _top;</span>
    u2 _flags;
    u2 _header_size;
    u4 _size;
  
    const u1* stable_top() const;
  
   public:
    JfrBuffer();
<span class="line-modified">!   bool initialize(size_t header_size, size_t size);</span>
<span class="line-modified">!   void reinitialize(bool exclusion = false);</span>
<span class="line-modified">! </span>
    JfrBuffer* next() const {
      return _next;
    }
  
    JfrBuffer* prev() const {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 91,71 ***</span>
  
    const u1* end() const {
      return start() + size();
    }
  
    const u1* pos() const {
      return _pos;
    }
  
    u1* pos() {
      return _pos;
    }
  
    u1** pos_address() {
<span class="line-modified">!     return (u1**)&amp;_pos;</span>
    }
  
    void set_pos(u1* new_pos) {
      assert(new_pos &lt;= end(), &quot;invariant&quot;);
<span class="line-modified">!     _pos = new_pos;</span>
    }
  
    void set_pos(size_t size) {
<span class="line-modified">!     assert(_pos + size &lt;= end(), &quot;invariant&quot;);</span>
<span class="line-removed">-     _pos += size;</span>
    }
  
    const u1* top() const;
    void set_top(const u1* new_top);
<span class="line-removed">-   const u1* concurrent_top() const;</span>
<span class="line-removed">-   void set_concurrent_top(const u1* new_top);</span>
  
<span class="line-modified">!   size_t header_size() const {</span>
<span class="line-modified">!     return _header_size;</span>
<span class="line-modified">!   }</span>
  
    size_t size() const {
      return _size * BytesPerWord;
    }
  
    size_t total_size() const {
<span class="line-modified">!     return header_size() + size();</span>
    }
  
    size_t free_size() const {
<span class="line-modified">!     return end() - pos();</span>
    }
  
    size_t unflushed_size() const;
  
    bool empty() const {
<span class="line-modified">!     return pos() == start();</span>
    }
  
    const void* identity() const {
<span class="line-modified">!     return _identity;</span>
    }
  
<span class="line-removed">-   void clear_identity();</span>
<span class="line-removed">- </span>
    void acquire(const void* id);
    bool try_acquire(const void* id);
    void release();
  
    void move(JfrBuffer* const to, size_t size);
<span class="line-removed">-   void concurrent_move_and_reinitialize(JfrBuffer* const to, size_t size);</span>
  
    bool transient() const;
    void set_transient();
    void clear_transient();
  
<span class="line-new-header">--- 103,70 ---</span>
  
    const u1* end() const {
      return start() + size();
    }
  
<span class="line-added">+   // If pos() methods are invoked by a thread that is not the owner,</span>
<span class="line-added">+   // then acquire semantics must be ensured at the call site.</span>
    const u1* pos() const {
      return _pos;
    }
  
    u1* pos() {
      return _pos;
    }
  
    u1** pos_address() {
<span class="line-modified">!     return &amp;_pos;</span>
    }
  
    void set_pos(u1* new_pos) {
      assert(new_pos &lt;= end(), &quot;invariant&quot;);
<span class="line-modified">!     Atomic::release_store(&amp;_pos, new_pos);</span>
    }
  
    void set_pos(size_t size) {
<span class="line-modified">!     set_pos(pos() + size);</span>
    }
  
    const u1* top() const;
    void set_top(const u1* new_top);
  
<span class="line-modified">!   // mutual exclusion</span>
<span class="line-modified">!   const u1* acquire_critical_section_top() const;</span>
<span class="line-modified">!   void release_critical_section_top(const u1* new_top);</span>
  
    size_t size() const {
      return _size * BytesPerWord;
    }
  
    size_t total_size() const {
<span class="line-modified">!     return _header_size + size();</span>
    }
  
    size_t free_size() const {
<span class="line-modified">!     return end() - Atomic::load_acquire(&amp;_pos);</span>
    }
  
    size_t unflushed_size() const;
  
    bool empty() const {
<span class="line-modified">!     return Atomic::load_acquire(&amp;_pos) == start();</span>
    }
  
    const void* identity() const {
<span class="line-modified">!     return Atomic::load_acquire(&amp;_identity);</span>
    }
  
    void acquire(const void* id);
    bool try_acquire(const void* id);
<span class="line-added">+   bool acquired_by(const void* id) const;</span>
<span class="line-added">+   bool acquired_by_self() const;</span>
    void release();
  
<span class="line-added">+   size_t discard();</span>
    void move(JfrBuffer* const to, size_t size);
  
    bool transient() const;
    void set_transient();
    void clear_transient();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 165,17 ***</span>
  
    bool retired() const;
    void set_retired();
    void clear_retired();
  
<span class="line-modified">!   debug_only(bool acquired_by_self() const;)</span>
  };
  
  class JfrAgeNode : public JfrBuffer {
   private:
    JfrBuffer* _retired;
<span class="line-removed">- </span>
   public:
    JfrAgeNode() : _retired(NULL) {}
    void set_retired_buffer(JfrBuffer* retired) {
      _retired = retired;
    }
<span class="line-new-header">--- 176,18 ---</span>
  
    bool retired() const;
    void set_retired();
    void clear_retired();
  
<span class="line-modified">!   bool excluded() const;</span>
<span class="line-added">+   void set_excluded();</span>
<span class="line-added">+   void clear_excluded();</span>
  };
  
  class JfrAgeNode : public JfrBuffer {
   private:
    JfrBuffer* _retired;
   public:
    JfrAgeNode() : _retired(NULL) {}
    void set_retired_buffer(JfrBuffer* retired) {
      _retired = retired;
    }
</pre>
<center><a href="jfrBuffer.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrMemorySpace.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
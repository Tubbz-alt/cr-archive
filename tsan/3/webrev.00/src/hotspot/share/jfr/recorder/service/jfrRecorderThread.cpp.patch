diff a/src/hotspot/share/jfr/recorder/service/jfrRecorderThread.cpp b/src/hotspot/share/jfr/recorder/service/jfrRecorderThread.cpp
--- a/src/hotspot/share/jfr/recorder/service/jfrRecorderThread.cpp
+++ b/src/hotspot/share/jfr/recorder/service/jfrRecorderThread.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -25,15 +25,17 @@
 #include "precompiled.hpp"
 #include "jni.h"
 #include "classfile/javaClasses.hpp"
 #include "classfile/symbolTable.hpp"
 #include "classfile/systemDictionary.hpp"
+#include "jfr/jfr.hpp"
 #include "jfr/jni/jfrJavaSupport.hpp"
 #include "jfr/recorder/jfrRecorder.hpp"
 #include "jfr/recorder/checkpoint/jfrCheckpointManager.hpp"
 #include "jfr/recorder/service/jfrRecorderThread.hpp"
 #include "memory/resourceArea.hpp"
+#include "memory/universe.hpp"
 #include "runtime/handles.inline.hpp"
 #include "runtime/mutexLocker.hpp"
 #include "runtime/thread.inline.hpp"
 #include "utilities/preserveException.hpp"
 #include "utilities/macros.hpp"
@@ -43,11 +45,11 @@
   assert(proc != NULL, "invariant");
 
   bool allocation_failed = false;
   JavaThread* new_thread = NULL;
   {
-    MutexLocker mu(Threads_lock);
+    MutexLocker mu(THREAD, Threads_lock);
     new_thread = new JavaThread(proc);
     // At this point it may be possible that no
     // osthread was created for the JavaThread due to lack of memory.
     if (new_thread == NULL || new_thread->osthread() == NULL) {
       delete new_thread;
@@ -61,11 +63,10 @@
     }
   }
   if (allocation_failed) {
     JfrJavaSupport::throw_out_of_memory_error("Unable to create native recording thread for JFR", CHECK_NULL);
   }
-
   Thread::start(new_thread);
   return new_thread;
 }
 
 JfrPostBox* JfrRecorderThread::_post_box = NULL;
@@ -95,12 +96,13 @@
 
   JfrJavaSupport::call_static(&create_thread_args, CHECK_false);
   instanceHandle h_thread_oop(THREAD, (instanceOop)result.get_jobject());
   assert(h_thread_oop.not_null(), "invariant");
   // attempt thread start
-  const Thread* const t = start_thread(h_thread_oop, recorderthread_entry,THREAD);
+  Thread* const t = start_thread(h_thread_oop, recorderthread_entry,THREAD);
   if (!HAS_PENDING_EXCEPTION) {
+    Jfr::exclude_thread(t);
     cp_manager->register_service_thread(t);
     return true;
   }
   assert(HAS_PENDING_EXCEPTION, "invariant");
   // Start failed, remove the thread from the system thread group

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeSetUtils.hpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="jfrTypeSetUtils.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="traceid/jfrTraceId.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeSetUtils.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 74,227 ***</span>
      return t != NULL ? (*_letter)(t) : true;
    }
  };
  
  template &lt;typename T&gt;
<span class="line-modified">! void tag_leakp_artifact(T const&amp; value, bool class_unload) {</span>
<span class="line-modified">!   assert(value != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   if (class_unload) {</span>
<span class="line-modified">!     SET_LEAKP_USED_THIS_EPOCH(value);</span>
<span class="line-modified">!     assert(LEAKP_USED_THIS_EPOCH(value), &quot;invariant&quot;);</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     SET_LEAKP_USED_PREV_EPOCH(value);</span>
<span class="line-modified">!     assert(LEAKP_USED_PREV_EPOCH(value), &quot;invariant&quot;);</span>
    }
<span class="line-modified">! }</span>
  
<span class="line-modified">! template &lt;typename T&gt;</span>
<span class="line-modified">! class LeakpClearArtifact {</span>
<span class="line-removed">-   bool _class_unload;</span>
   public:
<span class="line-modified">!   LeakpClearArtifact(bool class_unload) : _class_unload(class_unload) {}</span>
<span class="line-modified">!   bool operator()(T const&amp; value) {</span>
<span class="line-modified">!     if (_class_unload) {</span>
<span class="line-modified">!       if (LEAKP_USED_THIS_EPOCH(value)) {</span>
<span class="line-modified">!         LEAKP_UNUSE_THIS_EPOCH(value);</span>
<span class="line-modified">!       }</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       if (LEAKP_USED_PREV_EPOCH(value)) {</span>
<span class="line-removed">-         LEAKP_UNUSE_PREV_EPOCH(value);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
      return true;
    }
  };
  
  template &lt;typename T&gt;
<span class="line-modified">! class ClearArtifact {</span>
    bool _class_unload;
   public:
<span class="line-modified">!   ClearArtifact(bool class_unload) : _class_unload(class_unload) {}</span>
    bool operator()(T const&amp; value) {
<span class="line-modified">!     if (_class_unload) {</span>
<span class="line-modified">!       if (LEAKP_USED_THIS_EPOCH(value)) {</span>
<span class="line-removed">-         LEAKP_UNUSE_THIS_EPOCH(value);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       if (USED_THIS_EPOCH(value)) {</span>
<span class="line-removed">-         UNUSE_THIS_EPOCH(value);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       if (METHOD_USED_THIS_EPOCH(value)) {</span>
<span class="line-removed">-         UNUSE_METHOD_THIS_EPOCH(value);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       if (LEAKP_USED_PREV_EPOCH(value)) {</span>
<span class="line-removed">-         LEAKP_UNUSE_PREV_EPOCH(value);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       if (USED_PREV_EPOCH(value)) {</span>
<span class="line-removed">-         UNUSE_PREV_EPOCH(value);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       if (METHOD_USED_PREV_EPOCH(value)) {</span>
<span class="line-removed">-         UNUSE_METHOD_PREV_EPOCH(value);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return true;</span>
    }
  };
  
  template &lt;&gt;
<span class="line-modified">! class ClearArtifact&lt;const Method*&gt; {</span>
    bool _class_unload;
   public:
<span class="line-modified">!   ClearArtifact(bool class_unload) : _class_unload(class_unload) {}</span>
    bool operator()(const Method* method) {
<span class="line-modified">!     if (_class_unload) {</span>
<span class="line-modified">!       if (METHOD_FLAG_USED_THIS_EPOCH(method)) {</span>
<span class="line-removed">-         CLEAR_METHOD_FLAG_USED_THIS_EPOCH(method);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       if (METHOD_FLAG_USED_PREV_EPOCH(method)) {</span>
<span class="line-removed">-         CLEAR_METHOD_FLAG_USED_PREV_EPOCH(method);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return true;</span>
    }
  };
  
<span class="line-modified">! template &lt;typename T&gt;</span>
<span class="line-modified">! class LeakPredicate {</span>
    bool _class_unload;
   public:
<span class="line-modified">!   LeakPredicate(bool class_unload) : _class_unload(class_unload) {}</span>
    bool operator()(T const&amp; value) {
<span class="line-modified">!     return _class_unload ? LEAKP_USED_THIS_EPOCH(value) : LEAKP_USED_PREV_EPOCH(value);</span>
    }
  };
  
<span class="line-modified">! template &lt;typename T&gt;</span>
<span class="line-modified">! class UsedPredicate {</span>
<span class="line-modified">!   bool _class_unload;</span>
   public:
<span class="line-modified">!   UsedPredicate(bool class_unload) : _class_unload(class_unload) {}</span>
<span class="line-modified">!   bool operator()(T const&amp; value) {</span>
<span class="line-modified">!     return _class_unload ? USED_THIS_EPOCH(value) : USED_PREV_EPOCH(value);</span>
    }
  };
  
<span class="line-modified">! template &lt;typename T, int compare(const T&amp;, const T&amp;)&gt;</span>
<span class="line-modified">! class UniquePredicate {</span>
<span class="line-removed">-  private:</span>
<span class="line-removed">-   GrowableArray&lt;T&gt; _seen;</span>
   public:
<span class="line-modified">!   UniquePredicate(bool) : _seen() {}</span>
    bool operator()(T const&amp; value) {
<span class="line-modified">!     bool not_unique;</span>
<span class="line-removed">-     _seen.template find_sorted&lt;T, compare&gt;(value, not_unique);</span>
<span class="line-removed">-     if (not_unique) {</span>
<span class="line-removed">-       return false;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     _seen.template insert_sorted&lt;compare&gt;(value);</span>
<span class="line-removed">-     return true;</span>
    }
  };
  
<span class="line-modified">! class MethodFlagPredicate {</span>
<span class="line-modified">!   bool _class_unload;</span>
   public:
<span class="line-modified">!   MethodFlagPredicate(bool class_unload) : _class_unload(class_unload) {}</span>
    bool operator()(const Method* method) {
<span class="line-modified">!     return _class_unload ? METHOD_FLAG_USED_THIS_EPOCH(method) : METHOD_FLAG_USED_PREV_EPOCH(method);</span>
    }
  };
  
<span class="line-modified">! template &lt;bool leakp&gt;</span>
<span class="line-modified">! class MethodUsedPredicate {</span>
<span class="line-removed">-   bool _class_unload;</span>
   public:
<span class="line-modified">!   MethodUsedPredicate(bool class_unload) : _class_unload(class_unload) {}</span>
<span class="line-modified">!   bool operator()(const Klass* klass) {</span>
<span class="line-modified">!     assert(ANY_USED(klass), &quot;invariant&quot;);</span>
<span class="line-modified">!     if (_class_unload) {</span>
<span class="line-modified">!       return leakp ? LEAKP_METHOD_USED_THIS_EPOCH(klass) : METHOD_USED_THIS_EPOCH(klass);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return leakp ? LEAKP_METHOD_USED_PREV_EPOCH(klass) : METHOD_USED_PREV_EPOCH(klass);</span>
    }
  };
  
  class JfrSymbolId : public JfrCHeapObj {
    template &lt;typename, typename, template&lt;typename, typename&gt; class, typename, size_t&gt;
    friend class HashTableHost;
<span class="line-modified">!   typedef HashTableHost&lt;const Symbol*, traceid, Entry, JfrSymbolId&gt; SymbolTable;</span>
<span class="line-modified">!   typedef HashTableHost&lt;const char*, traceid, Entry, JfrSymbolId&gt; CStringTable;</span>
   public:
    typedef SymbolTable::HashEntry SymbolEntry;
    typedef CStringTable::HashEntry CStringEntry;
   private:
    SymbolTable* _sym_table;
    CStringTable* _cstring_table;
    traceid _symbol_id_counter;
  
    // hashtable(s) callbacks
<span class="line-modified">!   void assign_id(SymbolEntry* entry);</span>
<span class="line-modified">!   bool equals(const Symbol* query, uintptr_t hash, const SymbolEntry* entry);</span>
<span class="line-modified">!   void assign_id(CStringEntry* entry);</span>
<span class="line-modified">!   bool equals(const char* query, uintptr_t hash, const CStringEntry* entry);</span>
  
<span class="line-modified">!  public:</span>
<span class="line-modified">!   static bool is_unsafe_anonymous_klass(const Klass* k);</span>
<span class="line-modified">!   static const char* create_unsafe_anonymous_klass_symbol(const InstanceKlass* ik, uintptr_t&amp; hashcode);</span>
<span class="line-removed">-   static uintptr_t unsafe_anonymous_klass_name_hash_code(const InstanceKlass* ik);</span>
<span class="line-removed">-   static uintptr_t regular_klass_name_hash_code(const Klass* k);</span>
  
    JfrSymbolId();
    ~JfrSymbolId();
  
<span class="line-removed">-   void initialize();</span>
    void clear();
  
<span class="line-modified">!   traceid mark_unsafe_anonymous_klass_name(const Klass* k);</span>
<span class="line-modified">!   traceid mark(const Symbol* sym, uintptr_t hash);</span>
<span class="line-modified">!   traceid mark(const Klass* k);</span>
<span class="line-modified">!   traceid mark(const Symbol* symbol);</span>
<span class="line-modified">!   traceid mark(const char* str, uintptr_t hash);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   const SymbolEntry* map_symbol(const Symbol* symbol) const;</span>
<span class="line-removed">-   const SymbolEntry* map_symbol(uintptr_t hash) const;</span>
<span class="line-removed">-   const CStringEntry* map_cstring(uintptr_t hash) const;</span>
  
<span class="line-modified">!   template &lt;typename T&gt;</span>
<span class="line-modified">!   void symbol(T&amp; functor, const Klass* k) {</span>
<span class="line-modified">!     if (is_unsafe_anonymous_klass(k)) {</span>
<span class="line-removed">-       return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     functor(map_symbol(regular_klass_name_hash_code(k)));</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   template &lt;typename T&gt;</span>
<span class="line-removed">-   void symbol(T&amp; functor, const Method* method) {</span>
<span class="line-removed">-     assert(method != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-     functor(map_symbol((uintptr_t)method-&gt;name()-&gt;identity_hash()));</span>
<span class="line-removed">-     functor(map_symbol((uintptr_t)method-&gt;signature()-&gt;identity_hash()));</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   template &lt;typename T&gt;</span>
<span class="line-removed">-   void cstring(T&amp; functor, const Klass* k) {</span>
<span class="line-removed">-     if (!is_unsafe_anonymous_klass(k)) {</span>
<span class="line-removed">-       return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     functor(map_cstring(unsafe_anonymous_klass_name_hash_code((const InstanceKlass*)k)));</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   template &lt;typename T&gt;</span>
<span class="line-removed">-   void iterate_symbols(T&amp; functor) {</span>
<span class="line-removed">-     _sym_table-&gt;iterate_entry(functor);</span>
    }
  
<span class="line-modified">!   template &lt;typename T&gt;</span>
<span class="line-modified">!   void iterate_cstrings(T&amp; functor) {</span>
<span class="line-modified">!     _cstring_table-&gt;iterate_entry(functor);</span>
    }
  
    bool has_entries() const { return has_symbol_entries() || has_cstring_entries(); }
<span class="line-modified">!   bool has_symbol_entries() const { return _sym_table-&gt;has_entries(); }</span>
<span class="line-modified">!   bool has_cstring_entries() const { return _cstring_table-&gt;has_entries(); }</span>
  };
  
  /**
   * When processing a set of artifacts, there will be a need
   * to track transitive dependencies originating with each artifact.
<span class="line-new-header">--- 74,205 ---</span>
      return t != NULL ? (*_letter)(t) : true;
    }
  };
  
  template &lt;typename T&gt;
<span class="line-modified">! class ClearArtifact {</span>
<span class="line-modified">!  public:</span>
<span class="line-modified">!   bool operator()(T const&amp; value) {</span>
<span class="line-modified">!     CLEAR_SERIALIZED(value);</span>
<span class="line-modified">!     assert(IS_NOT_SERIALIZED(value), &quot;invariant&quot;);</span>
<span class="line-modified">!     SET_PREV_EPOCH_CLEARED_BIT(value);</span>
<span class="line-modified">!     CLEAR_METHOD_AND_CLASS_PREV_EPOCH(value);</span>
<span class="line-modified">!     return true;</span>
    }
<span class="line-modified">! };</span>
  
<span class="line-modified">! template &lt;&gt;</span>
<span class="line-modified">! class ClearArtifact&lt;const Method*&gt; {</span>
   public:
<span class="line-modified">!   bool operator()(const Method* method) {</span>
<span class="line-modified">!     assert(METHOD_FLAG_USED_PREV_EPOCH(method), &quot;invariant&quot;);</span>
<span class="line-modified">!     CLEAR_METHOD_SERIALIZED(method);</span>
<span class="line-modified">!     assert(METHOD_NOT_SERIALIZED(method), &quot;invariant&quot;);</span>
<span class="line-modified">!     SET_PREV_EPOCH_METHOD_CLEARED_BIT(method);</span>
<span class="line-modified">!     CLEAR_METHOD_FLAG_USED_PREV_EPOCH(method);</span>
      return true;
    }
  };
  
  template &lt;typename T&gt;
<span class="line-modified">! class SerializePredicate {</span>
    bool _class_unload;
   public:
<span class="line-modified">!   SerializePredicate(bool class_unload) : _class_unload(class_unload) {}</span>
    bool operator()(T const&amp; value) {
<span class="line-modified">!     assert(value != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!     return _class_unload ? true : IS_NOT_SERIALIZED(value);</span>
    }
  };
  
  template &lt;&gt;
<span class="line-modified">! class SerializePredicate&lt;const Method*&gt; {</span>
    bool _class_unload;
   public:
<span class="line-modified">!   SerializePredicate(bool class_unload) : _class_unload(class_unload) {}</span>
    bool operator()(const Method* method) {
<span class="line-modified">!     assert(method != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!     return _class_unload ? true : METHOD_NOT_SERIALIZED(method);</span>
    }
  };
  
<span class="line-modified">! template &lt;typename T, bool leakp&gt;</span>
<span class="line-modified">! class SymbolPredicate {</span>
    bool _class_unload;
   public:
<span class="line-modified">!   SymbolPredicate(bool class_unload) : _class_unload(class_unload) {}</span>
    bool operator()(T const&amp; value) {
<span class="line-modified">!     assert(value != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+     if (_class_unload) {</span>
<span class="line-added">+       return leakp ? value-&gt;is_leakp() : value-&gt;is_unloading();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return leakp ? value-&gt;is_leakp() : !value-&gt;is_serialized();</span>
    }
  };
  
<span class="line-modified">! template &lt;bool leakp&gt;</span>
<span class="line-modified">! class MethodUsedPredicate {</span>
<span class="line-modified">!   bool _current_epoch;</span>
<span class="line-added">+ public:</span>
<span class="line-added">+   MethodUsedPredicate(bool current_epoch) : _current_epoch(current_epoch) {}</span>
<span class="line-added">+   bool operator()(const Klass* klass) {</span>
<span class="line-added">+     if (_current_epoch) {</span>
<span class="line-added">+       return leakp ? IS_LEAKP(klass) : METHOD_USED_THIS_EPOCH(klass);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return  leakp ? IS_LEAKP(klass) : METHOD_USED_PREV_EPOCH(klass);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;bool leakp&gt;</span>
<span class="line-added">+ class MethodFlagPredicate {</span>
<span class="line-added">+   bool _current_epoch;</span>
   public:
<span class="line-modified">!   MethodFlagPredicate(bool current_epoch) : _current_epoch(current_epoch) {}</span>
<span class="line-modified">!   bool operator()(const Method* method) {</span>
<span class="line-modified">!     if (_current_epoch) {</span>
<span class="line-added">+       return leakp ? IS_METHOD_LEAKP_USED(method) : METHOD_FLAG_USED_THIS_EPOCH(method);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return leakp ? IS_METHOD_LEAKP_USED(method) : METHOD_FLAG_USED_PREV_EPOCH(method);</span>
    }
  };
  
<span class="line-modified">! template &lt;typename T&gt;</span>
<span class="line-modified">! class LeakPredicate {</span>
   public:
<span class="line-modified">!   LeakPredicate(bool class_unload) {}</span>
    bool operator()(T const&amp; value) {
<span class="line-modified">!     return IS_LEAKP(value);</span>
    }
  };
  
<span class="line-modified">! template &lt;&gt;</span>
<span class="line-modified">! class LeakPredicate&lt;const Method*&gt; {</span>
   public:
<span class="line-modified">!   LeakPredicate(bool class_unload) {}</span>
    bool operator()(const Method* method) {
<span class="line-modified">!     assert(method != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+     return IS_METHOD_LEAKP_USED(method);</span>
    }
  };
  
<span class="line-modified">! template &lt;typename T, typename IdType&gt;</span>
<span class="line-modified">! class ListEntry : public JfrHashtableEntry&lt;T, IdType&gt; {</span>
   public:
<span class="line-modified">!   ListEntry(uintptr_t hash, const T&amp; data) : JfrHashtableEntry&lt;T, IdType&gt;(hash, data),</span>
<span class="line-modified">!     _list_next(NULL), _serialized(false), _unloading(false), _leakp(false) {}</span>
<span class="line-modified">!   const ListEntry&lt;T, IdType&gt;* list_next() const { return _list_next; }</span>
<span class="line-modified">!   void reset() const {</span>
<span class="line-modified">!     _list_next = NULL; _serialized = false; _unloading = false; _leakp = false;</span>
    }
<span class="line-added">+   void set_list_next(const ListEntry&lt;T, IdType&gt;* next) const { _list_next = next; }</span>
<span class="line-added">+   bool is_serialized() const { return _serialized; }</span>
<span class="line-added">+   void set_serialized() const { _serialized = true; }</span>
<span class="line-added">+   bool is_unloading() const { return _unloading; }</span>
<span class="line-added">+   void set_unloading() const { _unloading = true; }</span>
<span class="line-added">+   bool is_leakp() const { return _leakp; }</span>
<span class="line-added">+   void set_leakp() const { _leakp = true; }</span>
<span class="line-added">+  private:</span>
<span class="line-added">+   mutable const ListEntry&lt;T, IdType&gt;* _list_next;</span>
<span class="line-added">+   mutable bool _serialized;</span>
<span class="line-added">+   mutable bool _unloading;</span>
<span class="line-added">+   mutable bool _leakp;</span>
  };
  
  class JfrSymbolId : public JfrCHeapObj {
    template &lt;typename, typename, template&lt;typename, typename&gt; class, typename, size_t&gt;
    friend class HashTableHost;
<span class="line-modified">!   typedef HashTableHost&lt;const Symbol*, traceid, ListEntry, JfrSymbolId&gt; SymbolTable;</span>
<span class="line-modified">!   typedef HashTableHost&lt;const char*, traceid, ListEntry, JfrSymbolId&gt; CStringTable;</span>
<span class="line-added">+   friend class JfrArtifactSet;</span>
   public:
    typedef SymbolTable::HashEntry SymbolEntry;
    typedef CStringTable::HashEntry CStringEntry;
   private:
    SymbolTable* _sym_table;
    CStringTable* _cstring_table;
<span class="line-added">+   const SymbolEntry* _sym_list;</span>
<span class="line-added">+   const CStringEntry* _cstring_list;</span>
<span class="line-added">+   const Symbol* _sym_query;</span>
<span class="line-added">+   const char* _cstring_query;</span>
    traceid _symbol_id_counter;
<span class="line-added">+   bool _class_unload;</span>
  
    // hashtable(s) callbacks
<span class="line-modified">!   void on_link(const SymbolEntry* entry);</span>
<span class="line-modified">!   bool on_equals(uintptr_t hash, const SymbolEntry* entry);</span>
<span class="line-modified">!   void on_unlink(const SymbolEntry* entry);</span>
<span class="line-modified">!   void on_link(const CStringEntry* entry);</span>
<span class="line-added">+   bool on_equals(uintptr_t hash, const CStringEntry* entry);</span>
<span class="line-added">+   void on_unlink(const CStringEntry* entry);</span>
<span class="line-added">+ </span>
<span class="line-added">+   template &lt;typename Functor, typename T&gt;</span>
<span class="line-added">+   void iterate(Functor&amp; functor, const T* list) {</span>
<span class="line-added">+     const T* symbol = list;</span>
<span class="line-added">+     while (symbol != NULL) {</span>
<span class="line-added">+       const T* next = symbol-&gt;list_next();</span>
<span class="line-added">+       functor(symbol);</span>
<span class="line-added">+       symbol = next;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
  
<span class="line-modified">!   traceid mark_unsafe_anonymous_klass_name(const InstanceKlass* k, bool leakp);</span>
<span class="line-modified">!   bool is_unsafe_anonymous_klass(const Klass* k);</span>
<span class="line-modified">!   uintptr_t unsafe_anonymous_klass_name_hash(const InstanceKlass* ik);</span>
  
<span class="line-added">+  public:</span>
    JfrSymbolId();
    ~JfrSymbolId();
  
    void clear();
<span class="line-added">+   void set_class_unload(bool class_unload);</span>
  
<span class="line-modified">!   traceid mark(uintptr_t hash, const Symbol* sym, bool leakp);</span>
<span class="line-modified">!   traceid mark(const Klass* k, bool leakp);</span>
<span class="line-modified">!   traceid mark(const Symbol* symbol, bool leakp);</span>
<span class="line-modified">!   traceid mark(uintptr_t hash, const char* str, bool leakp);</span>
<span class="line-modified">!   traceid bootstrap_name(bool leakp);</span>
  
<span class="line-modified">!   template &lt;typename Functor&gt;</span>
<span class="line-modified">!   void iterate_symbols(Functor&amp; functor) {</span>
<span class="line-modified">!     iterate(functor, _sym_list);</span>
    }
  
<span class="line-modified">!   template &lt;typename Functor&gt;</span>
<span class="line-modified">!   void iterate_cstrings(Functor&amp; functor) {</span>
<span class="line-modified">!     iterate(functor, _cstring_list);</span>
    }
  
    bool has_entries() const { return has_symbol_entries() || has_cstring_entries(); }
<span class="line-modified">!   bool has_symbol_entries() const { return _sym_list != NULL; }</span>
<span class="line-modified">!   bool has_cstring_entries() const { return _cstring_list != NULL; }</span>
  };
  
  /**
   * When processing a set of artifacts, there will be a need
   * to track transitive dependencies originating with each artifact.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 311,32 ***</span>
   */
  class JfrArtifactSet : public JfrCHeapObj {
   private:
    JfrSymbolId* _symbol_id;
    GrowableArray&lt;const Klass*&gt;* _klass_list;
<span class="line-modified">!   bool _class_unload;</span>
  
   public:
    JfrArtifactSet(bool class_unload);
    ~JfrArtifactSet();
  
    // caller needs ResourceMark
<span class="line-modified">!   void initialize(bool class_unload);</span>
<span class="line-removed">-   void clear();</span>
  
<span class="line-modified">!   traceid mark(const Symbol* sym, uintptr_t hash);</span>
<span class="line-modified">!   traceid mark(const Klass* klass);</span>
<span class="line-modified">!   traceid mark(const Symbol* symbol);</span>
<span class="line-modified">!   traceid mark(const char* const str, uintptr_t hash);</span>
<span class="line-modified">!   traceid mark_unsafe_anonymous_klass_name(const Klass* klass);</span>
  
    const JfrSymbolId::SymbolEntry* map_symbol(const Symbol* symbol) const;
    const JfrSymbolId::SymbolEntry* map_symbol(uintptr_t hash) const;
    const JfrSymbolId::CStringEntry* map_cstring(uintptr_t hash) const;
  
    bool has_klass_entries() const;
    int entries() const;
    void register_klass(const Klass* k);
  
    template &lt;typename Functor&gt;
    void iterate_klasses(Functor&amp; functor) const {
      for (int i = 0; i &lt; _klass_list-&gt;length(); ++i) {
<span class="line-new-header">--- 289,33 ---</span>
   */
  class JfrArtifactSet : public JfrCHeapObj {
   private:
    JfrSymbolId* _symbol_id;
    GrowableArray&lt;const Klass*&gt;* _klass_list;
<span class="line-modified">!   size_t _total_count;</span>
  
   public:
    JfrArtifactSet(bool class_unload);
    ~JfrArtifactSet();
  
    // caller needs ResourceMark
<span class="line-modified">!   void initialize(bool class_unload, bool clear = false);</span>
  
<span class="line-modified">!   traceid mark(uintptr_t hash, const Symbol* sym, bool leakp);</span>
<span class="line-modified">!   traceid mark(const Klass* klass, bool leakp);</span>
<span class="line-modified">!   traceid mark(const Symbol* symbol, bool leakp);</span>
<span class="line-modified">!   traceid mark(uintptr_t hash, const char* const str, bool leakp);</span>
<span class="line-modified">!   traceid mark_unsafe_anonymous_klass_name(const Klass* klass, bool leakp);</span>
<span class="line-added">+   traceid bootstrap_name(bool leakp);</span>
  
    const JfrSymbolId::SymbolEntry* map_symbol(const Symbol* symbol) const;
    const JfrSymbolId::SymbolEntry* map_symbol(uintptr_t hash) const;
    const JfrSymbolId::CStringEntry* map_cstring(uintptr_t hash) const;
  
    bool has_klass_entries() const;
    int entries() const;
<span class="line-added">+   size_t total_count() const;</span>
    void register_klass(const Klass* k);
  
    template &lt;typename Functor&gt;
    void iterate_klasses(Functor&amp; functor) const {
      for (int i = 0; i &lt; _klass_list-&gt;length(); ++i) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 353,10 ***</span>
<span class="line-new-header">--- 332,16 ---</span>
  
    template &lt;typename T&gt;
    void iterate_cstrings(T&amp; functor) {
      _symbol_id-&gt;iterate_cstrings(functor);
    }
<span class="line-added">+ </span>
<span class="line-added">+   template &lt;typename Writer&gt;</span>
<span class="line-added">+   void tally(Writer&amp; writer) {</span>
<span class="line-added">+     _total_count += writer.count();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
  };
  
  class KlassArtifactRegistrator {
   private:
    JfrArtifactSet* _artifacts;
</pre>
<center><a href="jfrTypeSetUtils.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="traceid/jfrTraceId.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
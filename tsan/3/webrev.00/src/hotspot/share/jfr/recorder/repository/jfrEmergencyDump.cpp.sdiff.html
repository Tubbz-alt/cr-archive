<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/recorder/repository/jfrEmergencyDump.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="jfrChunkWriter.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrEmergencyDump.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/repository/jfrEmergencyDump.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/jfrEvents.hpp&quot;

 27 #include &quot;jfr/leakprofiler/leakProfiler.hpp&quot;
 28 #include &quot;jfr/recorder/repository/jfrEmergencyDump.hpp&quot;
 29 #include &quot;jfr/recorder/service/jfrPostBox.hpp&quot;
 30 #include &quot;jfr/recorder/service/jfrRecorderService.hpp&quot;
 31 #include &quot;jfr/utilities/jfrTypes.hpp&quot;

 32 #include &quot;memory/resourceArea.hpp&quot;
 33 #include &quot;runtime/atomic.hpp&quot;
 34 #include &quot;runtime/handles.inline.hpp&quot;
 35 #include &quot;runtime/globals.hpp&quot;
 36 #include &quot;runtime/mutexLocker.hpp&quot;
<span class="line-modified"> 37 #include &quot;runtime/thread.hpp&quot;</span>




































































































































































































































































































 38 
 39 /*
 40 * We are just about to exit the VM, so we will be very aggressive
<span class="line-modified"> 41 * at this point in order to increase overall success of dumping jfr data:</span>
<span class="line-removed"> 42 *</span>
<span class="line-removed"> 43 * 1. if the thread state is not &quot;_thread_in_vm&quot;, we will quick transition</span>
<span class="line-removed"> 44 *    it to &quot;_thread_in_vm&quot;.</span>
<span class="line-removed"> 45 * 2. the nesting state for both resource and handle areas are unknown,</span>
<span class="line-removed"> 46 *    so we allocate new fresh arenas, discarding the old ones.</span>
<span class="line-removed"> 47 * 3. if the thread is the owner of some critical lock(s), unlock them.</span>
 48 *
 49 * If we end up deadlocking in the attempt of dumping out jfr data,
 50 * we rely on the WatcherThread task &quot;is_error_reported()&quot;,
<span class="line-modified"> 51 * to exit the VM after a hard-coded timeout.</span>
 52 * This &quot;safety net&quot; somewhat explains the aggressiveness in this attempt.
 53 *
 54 */
<span class="line-modified"> 55 static void prepare_for_emergency_dump(Thread* thread) {</span>
<span class="line-modified"> 56   if (thread-&gt;is_Java_thread()) {</span>
<span class="line-modified"> 57     ((JavaThread*)thread)-&gt;set_thread_state(_thread_in_vm);</span>







 58   }
 59 
 60 #ifdef ASSERT
<span class="line-modified"> 61   Monitor* owned_lock = thread-&gt;owned_locks();</span>
 62   while (owned_lock != NULL) {
<span class="line-modified"> 63     Monitor* next = owned_lock-&gt;next();</span>
 64     owned_lock-&gt;unlock();
 65     owned_lock = next;
 66   }
 67 #endif // ASSERT
 68 
 69   if (Threads_lock-&gt;owned_by_self()) {
 70     Threads_lock-&gt;unlock();
 71   }
 72 
 73   if (Module_lock-&gt;owned_by_self()) {
 74     Module_lock-&gt;unlock();
 75   }
 76 
 77   if (ClassLoaderDataGraph_lock-&gt;owned_by_self()) {
 78     ClassLoaderDataGraph_lock-&gt;unlock();
 79   }
 80 
 81   if (Heap_lock-&gt;owned_by_self()) {
 82     Heap_lock-&gt;unlock();
 83   }
 84 
 85   if (VMOperationQueue_lock-&gt;owned_by_self()) {
 86     VMOperationQueue_lock-&gt;unlock();
 87   }
 88 
 89   if (VMOperationRequest_lock-&gt;owned_by_self()) {
 90     VMOperationRequest_lock-&gt;unlock();
 91   }
 92 
<span class="line-removed"> 93 </span>
 94   if (Service_lock-&gt;owned_by_self()) {
 95     Service_lock-&gt;unlock();
 96   }
 97 




 98   if (CodeCache_lock-&gt;owned_by_self()) {
 99     CodeCache_lock-&gt;unlock();
100   }
101 
102   if (PeriodicTask_lock-&gt;owned_by_self()) {
103     PeriodicTask_lock-&gt;unlock();
104   }
105 
106   if (JfrMsg_lock-&gt;owned_by_self()) {
107     JfrMsg_lock-&gt;unlock();
108   }
109 
110   if (JfrBuffer_lock-&gt;owned_by_self()) {
111     JfrBuffer_lock-&gt;unlock();
112   }
113 
<span class="line-removed">114   if (JfrStream_lock-&gt;owned_by_self()) {</span>
<span class="line-removed">115     JfrStream_lock-&gt;unlock();</span>
<span class="line-removed">116   }</span>
<span class="line-removed">117 </span>
118   if (JfrStacktrace_lock-&gt;owned_by_self()) {
119     JfrStacktrace_lock-&gt;unlock();
120   }

121 }
122 
123 static volatile int jfr_shutdown_lock = 0;
124 
125 static bool guard_reentrancy() {
<span class="line-modified">126   return Atomic::cmpxchg(1, &amp;jfr_shutdown_lock, 0) == 0;</span>
127 }
128 






















129 void JfrEmergencyDump::on_vm_shutdown(bool exception_handler) {
130   if (!guard_reentrancy()) {
131     return;
132   }
<span class="line-modified">133   // function made non-reentrant</span>
<span class="line-modified">134   Thread* thread = Thread::current();</span>
<span class="line-modified">135   if (exception_handler) {</span>
<span class="line-modified">136     // we are crashing</span>
<span class="line-removed">137     if (thread-&gt;is_Watcher_thread()) {</span>
<span class="line-removed">138       // The Watcher thread runs the periodic thread sampling task.</span>
<span class="line-removed">139       // If it has crashed, it is likely that another thread is</span>
<span class="line-removed">140       // left in a suspended state. This would mean the system</span>
<span class="line-removed">141       // will not be able to ever move to a safepoint. We try</span>
<span class="line-removed">142       // to avoid issuing safepoint operations when attempting</span>
<span class="line-removed">143       // an emergency dump, but a safepoint might be already pending.</span>
<span class="line-removed">144       return;</span>
<span class="line-removed">145     }</span>
<span class="line-removed">146     prepare_for_emergency_dump(thread);</span>
147   }






148   EventDumpReason event;
149   if (event.should_commit()) {
150     event.set_reason(exception_handler ? &quot;Crash&quot; : &quot;Out of Memory&quot;);
151     event.set_recordingId(-1);
152     event.commit();
153   }
154   if (!exception_handler) {
155     // OOM
156     LeakProfiler::emit_events(max_jlong, false);
157   }
158   const int messages = MSGBIT(MSG_VM_ERROR);
<span class="line-removed">159   ResourceMark rm(thread);</span>
<span class="line-removed">160   HandleMark hm(thread);</span>
161   JfrRecorderService service;
162   service.rotate(messages);
163 }
</pre>
</td>
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/jfrEvents.hpp&quot;
<span class="line-added"> 27 #include &quot;jfr/jni/jfrJavaSupport.hpp&quot;</span>
 28 #include &quot;jfr/leakprofiler/leakProfiler.hpp&quot;
 29 #include &quot;jfr/recorder/repository/jfrEmergencyDump.hpp&quot;
 30 #include &quot;jfr/recorder/service/jfrPostBox.hpp&quot;
 31 #include &quot;jfr/recorder/service/jfrRecorderService.hpp&quot;
 32 #include &quot;jfr/utilities/jfrTypes.hpp&quot;
<span class="line-added"> 33 #include &quot;logging/log.hpp&quot;</span>
 34 #include &quot;memory/resourceArea.hpp&quot;
 35 #include &quot;runtime/atomic.hpp&quot;
 36 #include &quot;runtime/handles.inline.hpp&quot;
 37 #include &quot;runtime/globals.hpp&quot;
 38 #include &quot;runtime/mutexLocker.hpp&quot;
<span class="line-modified"> 39 #include &quot;runtime/os.hpp&quot;</span>
<span class="line-added"> 40 #include &quot;runtime/thread.inline.hpp&quot;</span>
<span class="line-added"> 41 #include &quot;utilities/growableArray.hpp&quot;</span>
<span class="line-added"> 42 </span>
<span class="line-added"> 43 static const char vm_error_filename_fmt[] = &quot;hs_err_pid%p.jfr&quot;;</span>
<span class="line-added"> 44 static const char vm_oom_filename_fmt[] = &quot;hs_oom_pid%p.jfr&quot;;</span>
<span class="line-added"> 45 static const char vm_soe_filename_fmt[] = &quot;hs_soe_pid%p.jfr&quot;;</span>
<span class="line-added"> 46 static const char chunk_file_jfr_ext[] = &quot;.jfr&quot;;</span>
<span class="line-added"> 47 static const size_t iso8601_len = 19; // &quot;YYYY-MM-DDTHH:MM:SS&quot;</span>
<span class="line-added"> 48 </span>
<span class="line-added"> 49 static fio_fd open_exclusivly(const char* path) {</span>
<span class="line-added"> 50   return os::open(path, O_CREAT | O_RDWR, S_IREAD | S_IWRITE);</span>
<span class="line-added"> 51 }</span>
<span class="line-added"> 52 </span>
<span class="line-added"> 53 static int file_sort(const char** const file1, const char** file2) {</span>
<span class="line-added"> 54   assert(NULL != *file1 &amp;&amp; NULL != *file2, &quot;invariant&quot;);</span>
<span class="line-added"> 55   int cmp = strncmp(*file1, *file2, iso8601_len);</span>
<span class="line-added"> 56   if (0 == cmp) {</span>
<span class="line-added"> 57     const char* const dot1 = strchr(*file1, &#39;.&#39;);</span>
<span class="line-added"> 58     assert(NULL != dot1, &quot;invariant&quot;);</span>
<span class="line-added"> 59     const char* const dot2 = strchr(*file2, &#39;.&#39;);</span>
<span class="line-added"> 60     assert(NULL != dot2, &quot;invariant&quot;);</span>
<span class="line-added"> 61     ptrdiff_t file1_len = dot1 - *file1;</span>
<span class="line-added"> 62     ptrdiff_t file2_len = dot2 - *file2;</span>
<span class="line-added"> 63     if (file1_len &lt; file2_len) {</span>
<span class="line-added"> 64       return -1;</span>
<span class="line-added"> 65     }</span>
<span class="line-added"> 66     if (file1_len &gt; file2_len) {</span>
<span class="line-added"> 67       return 1;</span>
<span class="line-added"> 68     }</span>
<span class="line-added"> 69     assert(file1_len == file2_len, &quot;invariant&quot;);</span>
<span class="line-added"> 70     cmp = strncmp(*file1, *file2, file1_len);</span>
<span class="line-added"> 71   }</span>
<span class="line-added"> 72   assert(cmp != 0, &quot;invariant&quot;);</span>
<span class="line-added"> 73   return cmp;</span>
<span class="line-added"> 74 }</span>
<span class="line-added"> 75 </span>
<span class="line-added"> 76 static void iso8601_to_date_time(char* iso8601_str) {</span>
<span class="line-added"> 77   assert(iso8601_str != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 78   assert(strlen(iso8601_str) == iso8601_len, &quot;invariant&quot;);</span>
<span class="line-added"> 79   // &quot;YYYY-MM-DDTHH:MM:SS&quot;</span>
<span class="line-added"> 80   for (size_t i = 0; i &lt; iso8601_len; ++i) {</span>
<span class="line-added"> 81     switch (iso8601_str[i]) {</span>
<span class="line-added"> 82     case &#39;T&#39;:</span>
<span class="line-added"> 83     case &#39;-&#39;:</span>
<span class="line-added"> 84     case &#39;:&#39;:</span>
<span class="line-added"> 85       iso8601_str[i] = &#39;_&#39;;</span>
<span class="line-added"> 86       break;</span>
<span class="line-added"> 87     }</span>
<span class="line-added"> 88   }</span>
<span class="line-added"> 89   // &quot;YYYY_MM_DD_HH_MM_SS&quot;</span>
<span class="line-added"> 90 }</span>
<span class="line-added"> 91 </span>
<span class="line-added"> 92 static void date_time(char* buffer, size_t buffer_len) {</span>
<span class="line-added"> 93   assert(buffer != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 94   assert(buffer_len &gt;= iso8601_len, &quot;buffer too small&quot;);</span>
<span class="line-added"> 95   os::iso8601_time(buffer, buffer_len);</span>
<span class="line-added"> 96   assert(strlen(buffer) &gt;= iso8601_len + 1, &quot;invariant&quot;);</span>
<span class="line-added"> 97   // &quot;YYYY-MM-DDTHH:MM:SS&quot;</span>
<span class="line-added"> 98   buffer[iso8601_len] = &#39;\0&#39;;</span>
<span class="line-added"> 99   iso8601_to_date_time(buffer);</span>
<span class="line-added">100 }</span>
<span class="line-added">101 </span>
<span class="line-added">102 static int64_t file_size(fio_fd fd) {</span>
<span class="line-added">103   assert(fd != invalid_fd, &quot;invariant&quot;);</span>
<span class="line-added">104   const int64_t current_offset = os::current_file_offset(fd);</span>
<span class="line-added">105   const int64_t size = os::lseek(fd, 0, SEEK_END);</span>
<span class="line-added">106   os::seek_to_file_offset(fd, current_offset);</span>
<span class="line-added">107   return size;</span>
<span class="line-added">108 }</span>
<span class="line-added">109 </span>
<span class="line-added">110 class RepositoryIterator : public StackObj {</span>
<span class="line-added">111  private:</span>
<span class="line-added">112   const char* const _repo;</span>
<span class="line-added">113   const size_t _repository_len;</span>
<span class="line-added">114   GrowableArray&lt;const char*&gt;* _files;</span>
<span class="line-added">115   const char* const fully_qualified(const char* entry) const;</span>
<span class="line-added">116   mutable int _iterator;</span>
<span class="line-added">117 </span>
<span class="line-added">118  public:</span>
<span class="line-added">119   RepositoryIterator(const char* repository, size_t repository_len);</span>
<span class="line-added">120   ~RepositoryIterator() {}</span>
<span class="line-added">121   const char* const filter(const char* entry) const;</span>
<span class="line-added">122   bool has_next() const;</span>
<span class="line-added">123   const char* const next() const;</span>
<span class="line-added">124 };</span>
<span class="line-added">125 </span>
<span class="line-added">126 const char* const RepositoryIterator::fully_qualified(const char* entry) const {</span>
<span class="line-added">127   assert(NULL != entry, &quot;invariant&quot;);</span>
<span class="line-added">128   char* file_path_entry = NULL;</span>
<span class="line-added">129   // only use files that have content, not placeholders</span>
<span class="line-added">130   const char* const file_separator = os::file_separator();</span>
<span class="line-added">131   if (NULL != file_separator) {</span>
<span class="line-added">132     const size_t entry_len = strlen(entry);</span>
<span class="line-added">133     const size_t file_separator_length = strlen(file_separator);</span>
<span class="line-added">134     const size_t file_path_entry_length = _repository_len + file_separator_length + entry_len;</span>
<span class="line-added">135     file_path_entry = NEW_RESOURCE_ARRAY_RETURN_NULL(char, file_path_entry_length + 1);</span>
<span class="line-added">136     if (NULL == file_path_entry) {</span>
<span class="line-added">137       return NULL;</span>
<span class="line-added">138     }</span>
<span class="line-added">139     int position = 0;</span>
<span class="line-added">140     position += jio_snprintf(&amp;file_path_entry[position], _repository_len + 1, &quot;%s&quot;, _repo);</span>
<span class="line-added">141     position += jio_snprintf(&amp;file_path_entry[position], file_separator_length + 1, &quot;%s&quot;, os::file_separator());</span>
<span class="line-added">142     position += jio_snprintf(&amp;file_path_entry[position], entry_len + 1, &quot;%s&quot;, entry);</span>
<span class="line-added">143     file_path_entry[position] = &#39;\0&#39;;</span>
<span class="line-added">144     assert((size_t)position == file_path_entry_length, &quot;invariant&quot;);</span>
<span class="line-added">145     assert(strlen(file_path_entry) == (size_t)position, &quot;invariant&quot;);</span>
<span class="line-added">146   }</span>
<span class="line-added">147   return file_path_entry;</span>
<span class="line-added">148 }</span>
<span class="line-added">149 </span>
<span class="line-added">150 const char* const RepositoryIterator::filter(const char* entry) const {</span>
<span class="line-added">151   if (entry == NULL) {</span>
<span class="line-added">152     return NULL;</span>
<span class="line-added">153   }</span>
<span class="line-added">154   const size_t entry_len = strlen(entry);</span>
<span class="line-added">155   if (entry_len &lt;= 2) {</span>
<span class="line-added">156     // for &quot;.&quot; and &quot;..&quot;</span>
<span class="line-added">157     return NULL;</span>
<span class="line-added">158   }</span>
<span class="line-added">159   char* entry_name = NEW_RESOURCE_ARRAY_RETURN_NULL(char, entry_len + 1);</span>
<span class="line-added">160   if (entry_name == NULL) {</span>
<span class="line-added">161     return NULL;</span>
<span class="line-added">162   }</span>
<span class="line-added">163   strncpy(entry_name, entry, entry_len + 1);</span>
<span class="line-added">164   const char* const fully_qualified_path_entry = fully_qualified(entry_name);</span>
<span class="line-added">165   if (NULL == fully_qualified_path_entry) {</span>
<span class="line-added">166     return NULL;</span>
<span class="line-added">167   }</span>
<span class="line-added">168   const fio_fd entry_fd = open_exclusivly(fully_qualified_path_entry);</span>
<span class="line-added">169   if (invalid_fd == entry_fd) {</span>
<span class="line-added">170     return NULL;</span>
<span class="line-added">171   }</span>
<span class="line-added">172   const int64_t entry_size = file_size(entry_fd);</span>
<span class="line-added">173   os::close(entry_fd);</span>
<span class="line-added">174   if (0 == entry_size) {</span>
<span class="line-added">175     return NULL;</span>
<span class="line-added">176   }</span>
<span class="line-added">177   return entry_name;</span>
<span class="line-added">178 }</span>
<span class="line-added">179 </span>
<span class="line-added">180 RepositoryIterator::RepositoryIterator(const char* repository, size_t repository_len) :</span>
<span class="line-added">181   _repo(repository),</span>
<span class="line-added">182   _repository_len(repository_len),</span>
<span class="line-added">183   _files(NULL),</span>
<span class="line-added">184   _iterator(0) {</span>
<span class="line-added">185   if (NULL != _repo) {</span>
<span class="line-added">186     assert(strlen(_repo) == _repository_len, &quot;invariant&quot;);</span>
<span class="line-added">187     _files = new GrowableArray&lt;const char*&gt;(10);</span>
<span class="line-added">188     DIR* dirp = os::opendir(_repo);</span>
<span class="line-added">189     if (dirp == NULL) {</span>
<span class="line-added">190       log_error(jfr, system)(&quot;Unable to open repository %s&quot;, _repo);</span>
<span class="line-added">191       return;</span>
<span class="line-added">192     }</span>
<span class="line-added">193     struct dirent* dentry;</span>
<span class="line-added">194     while ((dentry = os::readdir(dirp)) != NULL) {</span>
<span class="line-added">195       const char* const entry_path = filter(dentry-&gt;d_name);</span>
<span class="line-added">196       if (NULL != entry_path) {</span>
<span class="line-added">197         _files-&gt;append(entry_path);</span>
<span class="line-added">198       }</span>
<span class="line-added">199     }</span>
<span class="line-added">200     os::closedir(dirp);</span>
<span class="line-added">201     if (_files-&gt;length() &gt; 1) {</span>
<span class="line-added">202       _files-&gt;sort(file_sort);</span>
<span class="line-added">203     }</span>
<span class="line-added">204   }</span>
<span class="line-added">205 }</span>
<span class="line-added">206 </span>
<span class="line-added">207 bool RepositoryIterator::has_next() const {</span>
<span class="line-added">208   return (_files != NULL &amp;&amp; _iterator &lt; _files-&gt;length());</span>
<span class="line-added">209 }</span>
<span class="line-added">210 </span>
<span class="line-added">211 const char* const RepositoryIterator::next() const {</span>
<span class="line-added">212   return _iterator &gt;= _files-&gt;length() ? NULL : fully_qualified(_files-&gt;at(_iterator++));</span>
<span class="line-added">213 }</span>
<span class="line-added">214 </span>
<span class="line-added">215 static void write_emergency_file(fio_fd emergency_fd, const RepositoryIterator&amp; iterator) {</span>
<span class="line-added">216   assert(emergency_fd != invalid_fd, &quot;invariant&quot;);</span>
<span class="line-added">217   const size_t size_of_file_copy_block = 1 * M; // 1 mb</span>
<span class="line-added">218   jbyte* const file_copy_block = NEW_RESOURCE_ARRAY_RETURN_NULL(jbyte, size_of_file_copy_block);</span>
<span class="line-added">219   if (file_copy_block == NULL) {</span>
<span class="line-added">220     return;</span>
<span class="line-added">221   }</span>
<span class="line-added">222   while (iterator.has_next()) {</span>
<span class="line-added">223     fio_fd current_fd = invalid_fd;</span>
<span class="line-added">224     const char* const fqn = iterator.next();</span>
<span class="line-added">225     if (fqn != NULL) {</span>
<span class="line-added">226       current_fd = open_exclusivly(fqn);</span>
<span class="line-added">227       if (current_fd != invalid_fd) {</span>
<span class="line-added">228         const int64_t current_filesize = file_size(current_fd);</span>
<span class="line-added">229         assert(current_filesize &gt; 0, &quot;invariant&quot;);</span>
<span class="line-added">230         int64_t bytes_read = 0;</span>
<span class="line-added">231         int64_t bytes_written = 0;</span>
<span class="line-added">232         while (bytes_read &lt; current_filesize) {</span>
<span class="line-added">233           const ssize_t read_result = os::read_at(current_fd, file_copy_block, size_of_file_copy_block, bytes_read);</span>
<span class="line-added">234           if (-1 == read_result) {</span>
<span class="line-added">235             log_info(jfr)( // For user, should not be &quot;jfr, system&quot;</span>
<span class="line-added">236               &quot;Unable to recover JFR data&quot;);</span>
<span class="line-added">237             break;</span>
<span class="line-added">238           }</span>
<span class="line-added">239           bytes_read += (int64_t)read_result;</span>
<span class="line-added">240           assert(bytes_read - bytes_written &lt;= (int64_t)size_of_file_copy_block, &quot;invariant&quot;);</span>
<span class="line-added">241           bytes_written += (int64_t)os::write(emergency_fd, file_copy_block, bytes_read - bytes_written);</span>
<span class="line-added">242           assert(bytes_read == bytes_written, &quot;invariant&quot;);</span>
<span class="line-added">243         }</span>
<span class="line-added">244         os::close(current_fd);</span>
<span class="line-added">245       }</span>
<span class="line-added">246     }</span>
<span class="line-added">247   }</span>
<span class="line-added">248 }</span>
<span class="line-added">249 </span>
<span class="line-added">250 static const char* create_emergency_dump_path() {</span>
<span class="line-added">251   char* buffer = NEW_RESOURCE_ARRAY_RETURN_NULL(char, JVM_MAXPATHLEN);</span>
<span class="line-added">252   if (NULL == buffer) {</span>
<span class="line-added">253     return NULL;</span>
<span class="line-added">254   }</span>
<span class="line-added">255   const char* const cwd = os::get_current_directory(buffer, JVM_MAXPATHLEN);</span>
<span class="line-added">256   if (NULL == cwd) {</span>
<span class="line-added">257     return NULL;</span>
<span class="line-added">258   }</span>
<span class="line-added">259   size_t pos = strlen(cwd);</span>
<span class="line-added">260   const int fsep_len = jio_snprintf(&amp;buffer[pos], JVM_MAXPATHLEN - pos, &quot;%s&quot;, os::file_separator());</span>
<span class="line-added">261   const char* filename_fmt = NULL;</span>
<span class="line-added">262   // fetch specific error cause</span>
<span class="line-added">263   switch (JfrJavaSupport::cause()) {</span>
<span class="line-added">264     case JfrJavaSupport::OUT_OF_MEMORY:</span>
<span class="line-added">265       filename_fmt = vm_oom_filename_fmt;</span>
<span class="line-added">266       break;</span>
<span class="line-added">267     case JfrJavaSupport::STACK_OVERFLOW:</span>
<span class="line-added">268       filename_fmt = vm_soe_filename_fmt;</span>
<span class="line-added">269       break;</span>
<span class="line-added">270     default:</span>
<span class="line-added">271       filename_fmt = vm_error_filename_fmt;</span>
<span class="line-added">272   }</span>
<span class="line-added">273   char* emergency_dump_path = NULL;</span>
<span class="line-added">274   pos += fsep_len;</span>
<span class="line-added">275   if (Arguments::copy_expand_pid(filename_fmt, strlen(filename_fmt), &amp;buffer[pos], JVM_MAXPATHLEN - pos)) {</span>
<span class="line-added">276     const size_t emergency_filename_length = strlen(buffer);</span>
<span class="line-added">277     emergency_dump_path = NEW_RESOURCE_ARRAY_RETURN_NULL(char, emergency_filename_length + 1);</span>
<span class="line-added">278     if (NULL == emergency_dump_path) {</span>
<span class="line-added">279       return NULL;</span>
<span class="line-added">280     }</span>
<span class="line-added">281     strncpy(emergency_dump_path, buffer, emergency_filename_length + 1);</span>
<span class="line-added">282   }</span>
<span class="line-added">283   if (emergency_dump_path != NULL) {</span>
<span class="line-added">284     log_info(jfr)( // For user, should not be &quot;jfr, system&quot;</span>
<span class="line-added">285       &quot;Attempting to recover JFR data, emergency jfr file: %s&quot;, emergency_dump_path);</span>
<span class="line-added">286   }</span>
<span class="line-added">287   return emergency_dump_path;</span>
<span class="line-added">288 }</span>
<span class="line-added">289 </span>
<span class="line-added">290 // Caller needs ResourceMark</span>
<span class="line-added">291 static const char* create_emergency_chunk_path(const char* repository_path) {</span>
<span class="line-added">292   assert(repository_path != NULL, &quot;invariant&quot;);</span>
<span class="line-added">293   const size_t repository_path_len = strlen(repository_path);</span>
<span class="line-added">294   // date time</span>
<span class="line-added">295   char date_time_buffer[32] = { 0 };</span>
<span class="line-added">296   date_time(date_time_buffer, sizeof(date_time_buffer));</span>
<span class="line-added">297   size_t date_time_len = strlen(date_time_buffer);</span>
<span class="line-added">298   size_t chunkname_max_len = repository_path_len          // repository_base_path</span>
<span class="line-added">299                              + 1                          // &quot;/&quot;</span>
<span class="line-added">300                              + date_time_len              // date_time</span>
<span class="line-added">301                              + strlen(chunk_file_jfr_ext) // .jfr</span>
<span class="line-added">302                              + 1;</span>
<span class="line-added">303   char* chunk_path = NEW_RESOURCE_ARRAY_RETURN_NULL(char, chunkname_max_len);</span>
<span class="line-added">304   if (chunk_path == NULL) {</span>
<span class="line-added">305     return NULL;</span>
<span class="line-added">306   }</span>
<span class="line-added">307   // append the individual substrings</span>
<span class="line-added">308   jio_snprintf(chunk_path, chunkname_max_len, &quot;%s%s%s%s&quot;, repository_path, os::file_separator(), date_time_buffer, chunk_file_jfr_ext);</span>
<span class="line-added">309   return chunk_path;</span>
<span class="line-added">310 }</span>
<span class="line-added">311 </span>
<span class="line-added">312 static fio_fd emergency_dump_file_descriptor() {</span>
<span class="line-added">313   ResourceMark rm;</span>
<span class="line-added">314   const char* const emergency_dump_path = create_emergency_dump_path();</span>
<span class="line-added">315   return emergency_dump_path != NULL ? open_exclusivly(emergency_dump_path) : invalid_fd;</span>
<span class="line-added">316 }</span>
<span class="line-added">317 </span>
<span class="line-added">318 const char* JfrEmergencyDump::build_dump_path(const char* repository_path) {</span>
<span class="line-added">319   return repository_path == NULL ? create_emergency_dump_path() : create_emergency_chunk_path(repository_path);</span>
<span class="line-added">320 }</span>
<span class="line-added">321 </span>
<span class="line-added">322 void JfrEmergencyDump::on_vm_error(const char* repository_path) {</span>
<span class="line-added">323   assert(repository_path != NULL, &quot;invariant&quot;);</span>
<span class="line-added">324   ResourceMark rm;</span>
<span class="line-added">325   const fio_fd emergency_fd = emergency_dump_file_descriptor();</span>
<span class="line-added">326   if (emergency_fd != invalid_fd) {</span>
<span class="line-added">327     RepositoryIterator iterator(repository_path, strlen(repository_path));</span>
<span class="line-added">328     write_emergency_file(emergency_fd, iterator);</span>
<span class="line-added">329     os::close(emergency_fd);</span>
<span class="line-added">330   }</span>
<span class="line-added">331 }</span>
332 
333 /*
334 * We are just about to exit the VM, so we will be very aggressive
<span class="line-modified">335 * at this point in order to increase overall success of dumping jfr data.</span>






336 *
337 * If we end up deadlocking in the attempt of dumping out jfr data,
338 * we rely on the WatcherThread task &quot;is_error_reported()&quot;,
<span class="line-modified">339 * to exit the VM after a hard-coded timeout (disallow WatcherThread to emergency dump).</span>
340 * This &quot;safety net&quot; somewhat explains the aggressiveness in this attempt.
341 *
342 */
<span class="line-modified">343 static bool prepare_for_emergency_dump(Thread* thread) {</span>
<span class="line-modified">344   assert(thread != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">345 </span>
<span class="line-added">346   if (thread-&gt;is_Watcher_thread()) {</span>
<span class="line-added">347     // need WatcherThread as a safeguard against potential deadlocks</span>
<span class="line-added">348     return false;</span>
<span class="line-added">349   }</span>
<span class="line-added">350   if (JfrStream_lock-&gt;owned_by_self()) {</span>
<span class="line-added">351     // crashed during jfr rotation, disallow recursion</span>
<span class="line-added">352     return false;</span>
353   }
354 
355 #ifdef ASSERT
<span class="line-modified">356   Mutex* owned_lock = thread-&gt;owned_locks();</span>
357   while (owned_lock != NULL) {
<span class="line-modified">358     Mutex* next = owned_lock-&gt;next();</span>
359     owned_lock-&gt;unlock();
360     owned_lock = next;
361   }
362 #endif // ASSERT
363 
364   if (Threads_lock-&gt;owned_by_self()) {
365     Threads_lock-&gt;unlock();
366   }
367 
368   if (Module_lock-&gt;owned_by_self()) {
369     Module_lock-&gt;unlock();
370   }
371 
372   if (ClassLoaderDataGraph_lock-&gt;owned_by_self()) {
373     ClassLoaderDataGraph_lock-&gt;unlock();
374   }
375 
376   if (Heap_lock-&gt;owned_by_self()) {
377     Heap_lock-&gt;unlock();
378   }
379 
380   if (VMOperationQueue_lock-&gt;owned_by_self()) {
381     VMOperationQueue_lock-&gt;unlock();
382   }
383 
384   if (VMOperationRequest_lock-&gt;owned_by_self()) {
385     VMOperationRequest_lock-&gt;unlock();
386   }
387 

388   if (Service_lock-&gt;owned_by_self()) {
389     Service_lock-&gt;unlock();
390   }
391 
<span class="line-added">392   if (UseNotificationThread &amp;&amp; Notification_lock-&gt;owned_by_self()) {</span>
<span class="line-added">393     Notification_lock-&gt;unlock();</span>
<span class="line-added">394   }</span>
<span class="line-added">395 </span>
396   if (CodeCache_lock-&gt;owned_by_self()) {
397     CodeCache_lock-&gt;unlock();
398   }
399 
400   if (PeriodicTask_lock-&gt;owned_by_self()) {
401     PeriodicTask_lock-&gt;unlock();
402   }
403 
404   if (JfrMsg_lock-&gt;owned_by_self()) {
405     JfrMsg_lock-&gt;unlock();
406   }
407 
408   if (JfrBuffer_lock-&gt;owned_by_self()) {
409     JfrBuffer_lock-&gt;unlock();
410   }
411 




412   if (JfrStacktrace_lock-&gt;owned_by_self()) {
413     JfrStacktrace_lock-&gt;unlock();
414   }
<span class="line-added">415   return true;</span>
416 }
417 
418 static volatile int jfr_shutdown_lock = 0;
419 
420 static bool guard_reentrancy() {
<span class="line-modified">421   return Atomic::cmpxchg(&amp;jfr_shutdown_lock, 0, 1) == 0;</span>
422 }
423 
<span class="line-added">424 class JavaThreadInVM : public StackObj {</span>
<span class="line-added">425  private:</span>
<span class="line-added">426   JavaThread* const _jt;</span>
<span class="line-added">427   JavaThreadState _original_state;</span>
<span class="line-added">428  public:</span>
<span class="line-added">429 </span>
<span class="line-added">430   JavaThreadInVM(Thread* t) : _jt(t-&gt;is_Java_thread() ? (JavaThread*)t : NULL),</span>
<span class="line-added">431                               _original_state(_thread_max_state) {</span>
<span class="line-added">432     if ((_jt != NULL) &amp;&amp; (_jt-&gt;thread_state() != _thread_in_vm)) {</span>
<span class="line-added">433       _original_state = _jt-&gt;thread_state();</span>
<span class="line-added">434       _jt-&gt;set_thread_state(_thread_in_vm);</span>
<span class="line-added">435     }</span>
<span class="line-added">436   }</span>
<span class="line-added">437 </span>
<span class="line-added">438   ~JavaThreadInVM() {</span>
<span class="line-added">439     if (_original_state != _thread_max_state) {</span>
<span class="line-added">440       _jt-&gt;set_thread_state(_original_state);</span>
<span class="line-added">441     }</span>
<span class="line-added">442   }</span>
<span class="line-added">443 </span>
<span class="line-added">444 };</span>
<span class="line-added">445 </span>
446 void JfrEmergencyDump::on_vm_shutdown(bool exception_handler) {
447   if (!guard_reentrancy()) {
448     return;
449   }
<span class="line-modified">450 </span>
<span class="line-modified">451   Thread* thread = Thread::current_or_null_safe();</span>
<span class="line-modified">452   if (thread == NULL) {</span>
<span class="line-modified">453     return;</span>










454   }
<span class="line-added">455   // Ensure a JavaThread is _thread_in_vm when we make this call</span>
<span class="line-added">456   JavaThreadInVM jtivm(thread);</span>
<span class="line-added">457   if (!prepare_for_emergency_dump(thread)) {</span>
<span class="line-added">458     return;</span>
<span class="line-added">459   }</span>
<span class="line-added">460 </span>
461   EventDumpReason event;
462   if (event.should_commit()) {
463     event.set_reason(exception_handler ? &quot;Crash&quot; : &quot;Out of Memory&quot;);
464     event.set_recordingId(-1);
465     event.commit();
466   }
467   if (!exception_handler) {
468     // OOM
469     LeakProfiler::emit_events(max_jlong, false);
470   }
471   const int messages = MSGBIT(MSG_VM_ERROR);


472   JfrRecorderService service;
473   service.rotate(messages);
474 }
</pre>
</td>
</tr>
</table>
<center><a href="jfrChunkWriter.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrEmergencyDump.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
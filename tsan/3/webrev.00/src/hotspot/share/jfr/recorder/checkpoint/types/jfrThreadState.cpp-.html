<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/jfr/recorder/checkpoint/types/jfrThreadState.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
 1 /*
 2 * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
 3 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 4 *
 5 * This code is free software; you can redistribute it and/or modify it
 6 * under the terms of the GNU General Public License version 2 only, as
 7 * published by the Free Software Foundation.
 8 *
 9 * This code is distributed in the hope that it will be useful, but WITHOUT
10 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
11 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
12 * version 2 for more details (a copy is included in the LICENSE file that
13 * accompanied this code).
14 *
15 * You should have received a copy of the GNU General Public License version
16 * 2 along with this work; if not, write to the Free Software Foundation,
17 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
18 *
19 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
20 * or visit www.oracle.com if you need additional information or have any
21 * questions.
22 *
23 */
24 
25 #include &quot;precompiled.hpp&quot;
26 #include &quot;jfr/recorder/checkpoint/types/jfrThreadState.hpp&quot;
27 #include &quot;jfr/recorder/checkpoint/jfrCheckpointWriter.hpp&quot;
28 #include &quot;jvmtifiles/jvmti.h&quot;
29 
30 struct jvmti_thread_state {
31   u8 id;
32   const char* description;
33 };
34 
35 static jvmti_thread_state states[] = {
36   {
37     JVMTI_JAVA_LANG_THREAD_STATE_NEW,
38     &quot;STATE_NEW&quot;
39   },
40   {
41     JVMTI_THREAD_STATE_TERMINATED,
42     &quot;STATE_TERMINATED&quot;
43   },
44   {
45     JVMTI_JAVA_LANG_THREAD_STATE_RUNNABLE,
46     &quot;STATE_RUNNABLE&quot;
47   },
48   {
49     (JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT | JVMTI_THREAD_STATE_SLEEPING),
50     &quot;STATE_SLEEPING&quot;
51   },
52   {
53     (JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_INDEFINITELY | JVMTI_THREAD_STATE_IN_OBJECT_WAIT),
54     &quot;STATE_IN_OBJECT_WAIT&quot;
55   },
56   {
57     (JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT | JVMTI_THREAD_STATE_IN_OBJECT_WAIT),
58     &quot;STATE_IN_OBJECT_WAIT_TIMED&quot;
59   },
60   {
61     (JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_INDEFINITELY | JVMTI_THREAD_STATE_PARKED),
62     &quot;STATE_PARKED&quot;
63   },
64   {
65     (JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT | JVMTI_THREAD_STATE_PARKED),
66     &quot;STATE_PARKED_TIMED&quot;
67   },
68   {
69     JVMTI_JAVA_LANG_THREAD_STATE_BLOCKED,
70     &quot;STATE_BLOCKED_ON_MONITOR_ENTER&quot;
71   }
72 };
73 
74 void JfrThreadState::serialize(JfrCheckpointWriter&amp; writer) {
75   const u4 number_of_states = sizeof(states) / sizeof(jvmti_thread_state);
76   writer.write_count(number_of_states);
77   for (u4 i = 0; i &lt; number_of_states; ++i) {
78     writer.write_key(states[i].id);
79     writer.write(states[i].description);
80   }
81 }
82 
    </pre>
  </body>
</html>
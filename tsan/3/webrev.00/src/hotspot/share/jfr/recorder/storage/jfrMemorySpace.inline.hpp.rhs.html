<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jfr/recorder/storage/jfrMemorySpace.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_JFR_RECORDER_STORAGE_JFRMEMORYSPACE_INLINE_HPP
 26 #define SHARE_JFR_RECORDER_STORAGE_JFRMEMORYSPACE_INLINE_HPP
 27 
 28 #include &quot;jfr/recorder/storage/jfrMemorySpace.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added"> 29 #include &quot;runtime/os.hpp&quot;</span>
 30 
 31 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;
 32 JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::
 33 JfrMemorySpace(size_t min_elem_size, size_t limit_size, size_t cache_count, Callback* callback) :
 34   _free(),
 35   _full(),
 36   _min_elem_size(min_elem_size),
 37   _limit_size(limit_size),
 38   _cache_count(cache_count),
 39   _callback(callback) {}
 40 
 41 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;
 42 JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::~JfrMemorySpace() {
 43   Iterator full_iter(_full);
 44   while (full_iter.has_next()) {
 45     Type* t = full_iter.next();
 46     _full.remove(t);
 47     deallocate(t);
 48   }
 49   Iterator free_iter(_free);
 50   while (free_iter.has_next()) {
 51     Type* t = free_iter.next();
 52     _free.remove(t);
 53     deallocate(t);
 54   }
 55 }
 56 
 57 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;
 58 bool JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::initialize() {
 59   assert(_min_elem_size % os::vm_page_size() == 0, &quot;invariant&quot;);
 60   assert(_limit_size % os::vm_page_size() == 0, &quot;invariant&quot;);
 61   // pre-allocate cache elements
 62   for (size_t i = 0; i &lt; _cache_count; ++i) {
 63     Type* const t = allocate(_min_elem_size);
 64     if (t == NULL) {
 65       return false;
 66     }
 67     insert_free_head(t);
 68   }
 69   assert(_free.count() == _cache_count, &quot;invariant&quot;);
 70   return true;
 71 }
 72 
<a name="2" id="anc2"></a><span class="line-added"> 73 // allocations are even multiples of the mspace min size</span>
<span class="line-added"> 74 static inline size_t align_allocation_size(size_t requested_size, size_t min_elem_size) {</span>
<span class="line-added"> 75   assert((int)min_elem_size % os::vm_page_size() == 0, &quot;invariant&quot;);</span>
<span class="line-added"> 76   u8 alloc_size_bytes = min_elem_size;</span>
<span class="line-added"> 77   while (requested_size &gt; alloc_size_bytes) {</span>
<span class="line-added"> 78     alloc_size_bytes &lt;&lt;= 1;</span>
<span class="line-added"> 79   }</span>
<span class="line-added"> 80   assert((int)alloc_size_bytes % os::vm_page_size() == 0, &quot;invariant&quot;);</span>
<span class="line-added"> 81   return (size_t)alloc_size_bytes;</span>
<span class="line-added"> 82 }</span>
<span class="line-added"> 83 </span>
<span class="line-added"> 84 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;</span>
<span class="line-added"> 85 inline T* JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::allocate(size_t size) {</span>
<span class="line-added"> 86   const size_t aligned_size_bytes = align_allocation_size(size, _min_elem_size);</span>
<span class="line-added"> 87   void* const allocation = JfrCHeapObj::new_array&lt;u1&gt;(aligned_size_bytes + sizeof(T));</span>
<span class="line-added"> 88   if (allocation == NULL) {</span>
<span class="line-added"> 89     return NULL;</span>
<span class="line-added"> 90   }</span>
<span class="line-added"> 91   T* const t = new (allocation) T;</span>
<span class="line-added"> 92   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 93   if (!t-&gt;initialize(sizeof(T), aligned_size_bytes)) {</span>
<span class="line-added"> 94     JfrCHeapObj::free(t, aligned_size_bytes + sizeof(T));</span>
<span class="line-added"> 95     return NULL;</span>
<span class="line-added"> 96   }</span>
<span class="line-added"> 97   return t;</span>
<span class="line-added"> 98 }</span>
<span class="line-added"> 99 </span>
<span class="line-added">100 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;</span>
<span class="line-added">101 inline void JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::deallocate(T* t) {</span>
<span class="line-added">102   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="line-added">103   assert(!_free.in_list(t), &quot;invariant&quot;);</span>
<span class="line-added">104   assert(!_full.in_list(t), &quot;invariant&quot;);</span>
<span class="line-added">105   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="line-added">106   JfrCHeapObj::free(t, t-&gt;total_size());</span>
<span class="line-added">107 }</span>
<span class="line-added">108 </span>
109 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;
110 inline void JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::release_full(T* t) {
111   assert(is_locked(), &quot;invariant&quot;);
112   assert(t != NULL, &quot;invariant&quot;);
113   assert(_full.in_list(t), &quot;invariant&quot;);
114   remove_full(t);
115   assert(!_full.in_list(t), &quot;invariant&quot;);
116   if (t-&gt;transient()) {
117     deallocate(t);
118     return;
119   }
120   assert(t-&gt;empty(), &quot;invariant&quot;);
121   assert(!t-&gt;retired(), &quot;invariant&quot;);
122   assert(t-&gt;identity() == NULL, &quot;invariant&quot;);
123   if (should_populate_cache()) {
124     assert(!_free.in_list(t), &quot;invariant&quot;);
125     insert_free_head(t);
126   } else {
127     deallocate(t);
128   }
129 }
130 
131 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;
132 inline void JfrMemorySpace&lt;T, RetrievalType, Callback&gt;::release_free(T* t) {
133   assert(is_locked(), &quot;invariant&quot;);
134   assert(t != NULL, &quot;invariant&quot;);
135   assert(_free.in_list(t), &quot;invariant&quot;);
136   if (t-&gt;transient()) {
137     remove_free(t);
138     assert(!_free.in_list(t), &quot;invariant&quot;);
139     deallocate(t);
140     return;
141   }
142   assert(t-&gt;empty(), &quot;invariant&quot;);
143   assert(!t-&gt;retired(), &quot;invariant&quot;);
<a name="3" id="anc3"></a><span class="line-added">144   assert(!t-&gt;excluded(), &quot;invariant&quot;);</span>
145   assert(t-&gt;identity() == NULL, &quot;invariant&quot;);
146   if (!should_populate_cache()) {
147     remove_free(t);
148     assert(!_free.in_list(t), &quot;invariant&quot;);
149     deallocate(t);
150   }
151 }
152 
153 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;
154 template &lt;typename IteratorCallback, typename IteratorType&gt;
155 inline void JfrMemorySpace&lt;T, RetrievalType, Callback&gt;
156 ::iterate(IteratorCallback&amp; callback, bool full, jfr_iter_direction direction) {
157   IteratorType iterator(full ? _full : _free, direction);
158   while (iterator.has_next()) {
159     callback.process(iterator.next());
160   }
161 }
162 
<a name="4" id="anc4"></a><span class="line-added">163 template &lt;typename Mspace, typename Callback&gt;</span>
<span class="line-added">164 static inline Mspace* create_mspace(size_t buffer_size, size_t limit, size_t cache_count, Callback* cb) {</span>
<span class="line-added">165   Mspace* const mspace = new Mspace(buffer_size, limit, cache_count, cb);</span>
<span class="line-added">166   if (mspace != NULL) {</span>
<span class="line-added">167     mspace-&gt;initialize();</span>
<span class="line-added">168   }</span>
<span class="line-added">169   return mspace;</span>
<span class="line-added">170 }</span>
<span class="line-added">171 </span>
172 template &lt;typename Mspace&gt;
173 inline size_t size_adjustment(size_t size, Mspace* mspace) {
174   assert(mspace != NULL, &quot;invariant&quot;);
175   static const size_t min_elem_size = mspace-&gt;min_elem_size();
176   if (size &lt; min_elem_size) {
177     size = min_elem_size;
178   }
179   return size;
180 }
181 
182 template &lt;typename Mspace&gt;
183 inline typename Mspace::Type* mspace_allocate(size_t size, Mspace* mspace) {
184   return mspace-&gt;allocate(size_adjustment(size, mspace));
185 }
186 
187 template &lt;typename Mspace&gt;
188 inline typename Mspace::Type* mspace_allocate_acquired(size_t size, Mspace* mspace, Thread* thread) {
189   typename Mspace::Type* const t = mspace_allocate(size, mspace);
190   if (t == NULL) return NULL;
191   t-&gt;acquire(thread);
192   return t;
193 }
194 
195 template &lt;typename Mspace&gt;
196 inline typename Mspace::Type* mspace_allocate_transient(size_t size, Mspace* mspace, Thread* thread) {
197   typename Mspace::Type* const t = mspace_allocate_acquired(size, mspace, thread);
198   if (t == NULL) return NULL;
199   assert(t-&gt;acquired_by_self(), &quot;invariant&quot;);
200   t-&gt;set_transient();
201   return t;
202 }
203 
204 template &lt;typename Mspace&gt;
205 inline typename Mspace::Type* mspace_allocate_transient_lease(size_t size, Mspace* mspace, Thread* thread) {
206   typename Mspace::Type* const t = mspace_allocate_transient(size, mspace, thread);
207   if (t == NULL) return NULL;
208   assert(t-&gt;acquired_by_self(), &quot;invariant&quot;);
209   assert(t-&gt;transient(), &quot;invaiant&quot;);
210   t-&gt;set_lease();
211   return t;
212 }
213 
214 template &lt;typename Mspace&gt;
215 inline typename Mspace::Type* mspace_allocate_to_full(size_t size, Mspace* mspace, Thread* thread) {
216   assert(mspace-&gt;is_locked(), &quot;invariant&quot;);
217   typename Mspace::Type* const t = mspace_allocate_acquired(size, mspace, thread);
218   if (t == NULL) return NULL;
219   mspace-&gt;insert_full_head(t);
220   return t;
221 }
222 
<a name="5" id="anc5"></a><span class="line-added">223 template &lt;typename Mspace&gt;</span>
<span class="line-added">224 class MspaceLock {</span>
<span class="line-added">225  private:</span>
<span class="line-added">226   Mspace* _mspace;</span>
<span class="line-added">227  public:</span>
<span class="line-added">228   MspaceLock(Mspace* mspace) : _mspace(mspace) { _mspace-&gt;lock(); }</span>
<span class="line-added">229   ~MspaceLock() { _mspace-&gt;unlock(); }</span>
<span class="line-added">230 };</span>
<span class="line-added">231 </span>
232 template &lt;typename Mspace&gt;
233 inline typename Mspace::Type* mspace_allocate_transient_to_full(size_t size, Mspace* mspace, Thread* thread) {
234   typename Mspace::Type* const t = mspace_allocate_transient(size, mspace, thread);
235   if (t == NULL) return NULL;
236   MspaceLock&lt;Mspace&gt; lock(mspace);
237   mspace-&gt;insert_full_head(t);
238   return t;
239 }
240 
241 template &lt;typename Mspace&gt;
242 inline typename Mspace::Type* mspace_allocate_transient_lease_to_full(size_t size, Mspace* mspace, Thread* thread) {
243   typename Mspace::Type* const t = mspace_allocate_transient_lease(size, mspace, thread);
244   if (t == NULL) return NULL;
245   assert(t-&gt;acquired_by_self(), &quot;invariant&quot;);
246   assert(t-&gt;transient(), &quot;invaiant&quot;);
247   assert(t-&gt;lease(), &quot;invariant&quot;);
248   MspaceLock&lt;Mspace&gt; lock(mspace);
249   mspace-&gt;insert_full_head(t);
250   return t;
251 }
252 
253 template &lt;typename Mspace&gt;
254 inline typename Mspace::Type* mspace_allocate_transient_lease_to_free(size_t size, Mspace* mspace, Thread* thread) {
255   typename Mspace::Type* const t = mspace_allocate_transient_lease(size, mspace, thread);
256   if (t == NULL) return NULL;
257   assert(t-&gt;acquired_by_self(), &quot;invariant&quot;);
258   assert(t-&gt;transient(), &quot;invaiant&quot;);
259   assert(t-&gt;lease(), &quot;invariant&quot;);
260   MspaceLock&lt;Mspace&gt; lock(mspace);
261   mspace-&gt;insert_free_head(t);
262   return t;
263 }
264 
265 template &lt;typename Mspace&gt;
266 inline typename Mspace::Type* mspace_get_free(size_t size, Mspace* mspace, Thread* thread) {
267   return mspace-&gt;get(size, thread);
268 }
269 
270 template &lt;typename Mspace&gt;
271 inline typename Mspace::Type* mspace_get_free_with_retry(size_t size, Mspace* mspace, size_t retry_count, Thread* thread) {
272   assert(size &lt;= mspace-&gt;min_elem_size(), &quot;invariant&quot;);
273   for (size_t i = 0; i &lt; retry_count; ++i) {
274     typename Mspace::Type* const t = mspace_get_free(size, mspace, thread);
275     if (t != NULL) {
276       return t;
277     }
278   }
279   return NULL;
280 }
281 
282 template &lt;typename Mspace&gt;
283 inline typename Mspace::Type* mspace_get_free_with_detach(size_t size, Mspace* mspace, Thread* thread) {
284   typename Mspace::Type* t = mspace_get_free(size, mspace, thread);
285   if (t != NULL) {
286     mspace-&gt;remove_free(t);
287   }
288   return t;
289 }
290 
291 template &lt;typename Mspace&gt;
292 inline typename Mspace::Type* mspace_get_free_to_full(size_t size, Mspace* mspace, Thread* thread) {
293   assert(size &lt;= mspace-&gt;min_elem_size(), &quot;invariant&quot;);
294   assert(mspace-&gt;is_locked(), &quot;invariant&quot;);
295   typename Mspace::Type* t = mspace_get_free(size, mspace, thread);
296   if (t == NULL) {
297     return NULL;
298   }
299   assert(t-&gt;acquired_by_self(), &quot;invariant&quot;);
300   move_to_head(t, mspace-&gt;free(), mspace-&gt;full());
301   return t;
302 }
303 
304 template &lt;typename Mspace&gt;
305 inline typename Mspace::Type* mspace_get_to_full(size_t size, Mspace* mspace, Thread* thread) {
306   size = size_adjustment(size, mspace);
307   MspaceLock&lt;Mspace&gt; lock(mspace);
308   if (size &lt;= mspace-&gt;min_elem_size()) {
309     typename Mspace::Type* const t = mspace_get_free_to_full(size, mspace, thread);
310     if (t != NULL) {
311       return t;
312     }
313   }
314   return mspace_allocate_to_full(size, mspace, thread);
315 }
316 
317 template &lt;typename Mspace&gt;
318 inline typename Mspace::Type* mspace_get_free_lease_with_retry(size_t size, Mspace* mspace, size_t retry_count, Thread* thread) {
319   typename Mspace::Type* t = mspace_get_free_with_retry(size, mspace, retry_count, thread);
320   if (t != NULL) {
321     t-&gt;set_lease();
322   }
323   return t;
324 }
325 
326 template &lt;typename Mspace&gt;
327 inline typename Mspace::Type* mspace_get_lease(size_t size, Mspace* mspace, Thread* thread) {
328   typename Mspace::Type* t;
329   t = mspace_get_free_lease(size, mspace, thread);
330   if (t != NULL) {
331     assert(t-&gt;acquired_by_self(), &quot;invariant&quot;);
332     assert(t-&gt;lease(), &quot;invariant&quot;);
333     return t;
334   }
335   t = mspace_allocate_transient_to_full(size, mspace, thread);
336   if (t != NULL) {
337     t-&gt;set_lease();
338   }
339   return t;
340 }
341 
342 template &lt;typename Mspace&gt;
343 inline void mspace_release_full(typename Mspace::Type* t, Mspace* mspace) {
344   assert(t != NULL, &quot;invariant&quot;);
345   assert(t-&gt;unflushed_size() == 0, &quot;invariant&quot;);
346   assert(mspace != NULL, &quot;invariant&quot;);
347   assert(mspace-&gt;is_locked(), &quot;invariant&quot;);
348   mspace-&gt;release_full(t);
349 }
350 
351 template &lt;typename Mspace&gt;
352 inline void mspace_release_free(typename Mspace::Type* t, Mspace* mspace) {
353   assert(t != NULL, &quot;invariant&quot;);
354   assert(t-&gt;unflushed_size() == 0, &quot;invariant&quot;);
355   assert(mspace != NULL, &quot;invariant&quot;);
356   assert(mspace-&gt;is_locked(), &quot;invariant&quot;);
357   mspace-&gt;release_free(t);
358 }
359 
360 template &lt;typename Mspace&gt;
361 inline void mspace_release_full_critical(typename Mspace::Type* t, Mspace* mspace) {
362   MspaceLock&lt;Mspace&gt; lock(mspace);
363   mspace_release_full(t, mspace);
364 }
365 
366 template &lt;typename Mspace&gt;
367 inline void mspace_release_free_critical(typename Mspace::Type* t, Mspace* mspace) {
368   MspaceLock&lt;Mspace&gt; lock(mspace);
369   mspace_release_free(t, mspace);
370 }
371 
372 template &lt;typename List&gt;
373 inline void move_to_head(typename List::Node* t, List&amp; from, List&amp; to) {
374   assert(from.in_list(t), &quot;invariant&quot;);
375   to.prepend(from.remove(t));
376 }
377 
378 template &lt;typename Processor, typename Mspace, typename Iterator&gt;
379 inline void process_free_list_iterator_control(Processor&amp; processor, Mspace* mspace, jfr_iter_direction direction = forward) {
380   mspace-&gt;template iterate&lt;Processor, Iterator&gt;(processor, false, direction);
381 }
382 
383 template &lt;typename Processor, typename Mspace, typename Iterator&gt;
384 inline void process_full_list_iterator_control(Processor&amp; processor, Mspace* mspace, jfr_iter_direction direction = forward) {
385   mspace-&gt;template iterate&lt;Processor, Iterator&gt;(processor, true, direction);
386 }
387 
388 template &lt;typename Processor, typename Mspace&gt;
389 inline void process_full_list(Processor&amp; processor, Mspace* mspace, jfr_iter_direction direction = forward) {
390   assert(mspace != NULL, &quot;invariant&quot;);
391   if (mspace-&gt;is_full_empty()) return;
392   process_full_list_iterator_control&lt;Processor, Mspace, typename Mspace::Iterator&gt;(processor, mspace, direction);
393 }
394 
395 template &lt;typename Processor, typename Mspace&gt;
396 inline void process_free_list(Processor&amp; processor, Mspace* mspace, jfr_iter_direction direction = forward) {
397   assert(mspace != NULL, &quot;invariant&quot;);
398   assert(mspace-&gt;has_free(), &quot;invariant&quot;);
399   process_free_list_iterator_control&lt;Processor, Mspace, typename Mspace::Iterator&gt;(processor, mspace, direction);
400 }
401 
<a name="6" id="anc6"></a><span class="line-added">402 template &lt;typename Mspace&gt;</span>
<span class="line-added">403 class ReleaseOp : public StackObj {</span>
<span class="line-added">404  private:</span>
<span class="line-added">405   Mspace* _mspace;</span>
<span class="line-added">406   Thread* _thread;</span>
<span class="line-added">407   bool _release_full;</span>
<span class="line-added">408  public:</span>
<span class="line-added">409   typedef typename Mspace::Type Type;</span>
<span class="line-added">410   ReleaseOp(Mspace* mspace, Thread* thread, bool release_full = true) :</span>
<span class="line-added">411     _mspace(mspace), _thread(thread), _release_full(release_full) {}</span>
<span class="line-added">412   bool process(Type* t);</span>
<span class="line-added">413   size_t processed() const { return 0; }</span>
<span class="line-added">414 };</span>
<span class="line-added">415 </span>
416 template &lt;typename Mspace&gt;
417 inline bool ReleaseOp&lt;Mspace&gt;::process(typename Mspace::Type* t) {
418   assert(t != NULL, &quot;invariant&quot;);
<a name="7" id="anc7"></a><span class="line-modified">419   // assumes some means of exclusive access to t</span>
<span class="line-modified">420   if (t-&gt;transient()) {</span>
<span class="line-modified">421     if (_release_full) {</span>
<span class="line-modified">422       mspace_release_full_critical(t, _mspace);</span>
<span class="line-modified">423     } else {</span>
<span class="line-modified">424       mspace_release_free_critical(t, _mspace);</span>


425     }
<a name="8" id="anc8"></a><span class="line-modified">426     return true;</span>
<span class="line-added">427   }</span>
<span class="line-added">428   t-&gt;reinitialize();</span>
<span class="line-added">429   if (t-&gt;identity() != NULL) {</span>
430     assert(t-&gt;empty(), &quot;invariant&quot;);
<a name="9" id="anc9"></a><span class="line-added">431     assert(!t-&gt;retired(), &quot;invariant&quot;);</span>
432     t-&gt;release(); // publish
433   }
434   return true;
435 }
436 
437 #ifdef ASSERT
438 template &lt;typename T&gt;
439 inline void assert_migration_state(const T* old, const T* new_buffer, size_t used, size_t requested) {
440   assert(old != NULL, &quot;invariant&quot;);
441   assert(new_buffer != NULL, &quot;invariant&quot;);
442   assert(old-&gt;pos() &gt;= old-&gt;start(), &quot;invariant&quot;);
443   assert(old-&gt;pos() + used &lt;= old-&gt;end(), &quot;invariant&quot;);
444   assert(new_buffer-&gt;free_size() &gt;= (used + requested), &quot;invariant&quot;);
445 }
446 #endif // ASSERT
447 
448 template &lt;typename T&gt;
449 inline void migrate_outstanding_writes(const T* old, T* new_buffer, size_t used, size_t requested) {
450   DEBUG_ONLY(assert_migration_state(old, new_buffer, used, requested);)
451   if (used &gt; 0) {
452     memcpy(new_buffer-&gt;pos(), old-&gt;pos(), used);
453   }
454 }
455 
456 #endif // SHARE_JFR_RECORDER_STORAGE_JFRMEMORYSPACE_INLINE_HPP
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
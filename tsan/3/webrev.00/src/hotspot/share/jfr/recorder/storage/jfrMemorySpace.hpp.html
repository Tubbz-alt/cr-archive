<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/jfr/recorder/storage/jfrMemorySpace.hpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 #ifndef SHARE_JFR_RECORDER_STORAGE_JFRMEMORYSPACE_HPP
 25 #define SHARE_JFR_RECORDER_STORAGE_JFRMEMORYSPACE_HPP
 26 
 27 #include &quot;jfr/utilities/jfrAllocation.hpp&quot;
 28 #include &quot;jfr/utilities/jfrDoublyLinkedList.hpp&quot;
 29 #include &quot;jfr/utilities/jfrIterator.hpp&quot;
 30 
 31 template &lt;typename T, template &lt;typename&gt; class RetrievalType, typename Callback&gt;
 32 class JfrMemorySpace : public JfrCHeapObj {
 33  public:
 34   typedef T Type;
 35   typedef RetrievalType&lt;JfrMemorySpace&lt;T, RetrievalType, Callback&gt; &gt; Retrieval;
 36   typedef JfrDoublyLinkedList&lt;Type&gt; List;
 37   typedef StopOnNullIterator&lt;List&gt; Iterator;
 38  private:
 39   List _free;
 40   List _full;
 41   size_t _min_elem_size;
 42   size_t _limit_size;
 43   size_t _cache_count;
 44   Callback* _callback;
 45 
 46   bool should_populate_cache() const { return _free.count() &lt; _cache_count; }
 47 
 48  public:
 49   JfrMemorySpace(size_t min_elem_size, size_t limit_size, size_t cache_count, Callback* callback);
 50   ~JfrMemorySpace();
 51   bool initialize();
 52 
 53   size_t min_elem_size() const { return _min_elem_size; }
 54   size_t limit_size() const { return _limit_size; }
 55 
 56   bool has_full() const { return _full.head() != NULL; }
 57   bool has_free() const { return _free.head() != NULL; }
 58   bool is_full_empty() const { return !has_full(); }
 59   bool is_free_empty() const { return !has_free(); }
 60 
 61   size_t full_count() const { return _full.count(); }
 62   size_t free_count() const { return _free.count(); }
 63 
 64   List&amp; full() { return _full; }
 65   const List&amp; full() const { return _full; }
 66   List&amp; free() { return _free; }
 67   const List&amp; free() const { return _free; }
 68 
 69   Type* full_head() { return _full.head(); }
 70   Type* full_tail() { return _full.tail(); }
 71   Type* free_head() { return _free.head(); }
 72   Type* free_tail() { return _free.tail(); }
 73 
 74   void insert_free_head(Type* t) { _free.prepend(t); }
 75   void insert_free_tail(Type* t) { _free.append(t); }
 76   void insert_free_tail(Type* t, Type* tail, size_t count) { _free.append_list(t, tail, count); }
 77   void insert_full_head(Type* t) { _full.prepend(t); }
 78   void insert_full_tail(Type* t) { _full.append(t); }
 79   void insert_full_tail(Type* t, Type* tail, size_t count) { _full.append_list(t, tail, count); }
 80 
 81   Type* remove_free(Type* t) { return _free.remove(t); }
 82   Type* remove_full(Type* t) { return _full.remove(t); }
 83   Type* remove_free_tail() { _free.remove(_free.tail()); }
 84   Type* remove_full_tail() { return _full.remove(_full.tail()); }
 85   Type* clear_full(bool return_tail = false) { return _full.clear(return_tail); }
 86   Type* clear_free(bool return_tail = false) { return _free.clear(return_tail); }
 87   void release_full(Type* t);
 88   void release_free(Type* t);
 89 
 90   void register_full(Type* t, Thread* thread) { _callback-&gt;register_full(t, thread); }
 91   void lock() { _callback-&gt;lock(); }
 92   void unlock() { _callback-&gt;unlock(); }
 93   DEBUG_ONLY(bool is_locked() const { return _callback-&gt;is_locked(); })
 94 
 95   Type* allocate(size_t size);
 96   void deallocate(Type* t);
 97   Type* get(size_t size, Thread* thread) { return Retrieval::get(size, this, thread); }
 98 
 99   template &lt;typename IteratorCallback, typename IteratorType&gt;
100   void iterate(IteratorCallback&amp; callback, bool full = true, jfr_iter_direction direction = forward);
101 
102   bool in_full_list(const Type* t) const { return _full.in_list(t); }
103   bool in_free_list(const Type* t) const { return _free.in_list(t); }
104 };
105 
106 #endif // SHARE_JFR_RECORDER_STORAGE_JFRMEMORYSPACE_HPP
    </pre>
  </body>
</html>
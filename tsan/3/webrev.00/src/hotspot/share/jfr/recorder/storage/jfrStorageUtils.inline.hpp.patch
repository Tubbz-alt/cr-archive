diff a/src/hotspot/share/jfr/recorder/storage/jfrStorageUtils.inline.hpp b/src/hotspot/share/jfr/recorder/storage/jfrStorageUtils.inline.hpp
--- a/src/hotspot/share/jfr/recorder/storage/jfrStorageUtils.inline.hpp
+++ b/src/hotspot/share/jfr/recorder/storage/jfrStorageUtils.inline.hpp
@@ -24,75 +24,99 @@
 
 #ifndef SHARE_JFR_RECORDER_STORAGE_JFRSTORAGEUTILS_INLINE_HPP
 #define SHARE_JFR_RECORDER_STORAGE_JFRSTORAGEUTILS_INLINE_HPP
 
 #include "jfr/recorder/storage/jfrStorageUtils.hpp"
+#include "runtime/atomic.hpp"
+#include "runtime/thread.inline.hpp"
 
 template <typename T>
 inline bool UnBufferedWriteToChunk<T>::write(T* t, const u1* data, size_t size) {
   _writer.write_unbuffered(data, size);
-  _processed += size;
+  ++_elements;
+  _size += size;
   return true;
 }
 
 template <typename T>
 inline bool DefaultDiscarder<T>::discard(T* t, const u1* data, size_t size) {
-  _processed += size;
+  ++_elements;
+  _size += size;
   return true;
 }
 
+template <typename Type>
+inline size_t get_unflushed_size(const u1* top, Type* t) {
+  assert(t != NULL, "invariant");
+  return Atomic::load_acquire(t->pos_address()) - top;
+}
+
 template <typename Operation>
 inline bool ConcurrentWriteOp<Operation>::process(typename Operation::Type* t) {
-  const u1* const current_top = t->concurrent_top();
-  const size_t unflushed_size = t->pos() - current_top;
+  // acquire_critical_section_top() must be read before pos() for stable access
+  const u1* const top = t->acquire_critical_section_top();
+  const size_t unflushed_size = get_unflushed_size(top, t);
   if (unflushed_size == 0) {
-    t->set_concurrent_top(current_top);
+    t->release_critical_section_top(top);
     return true;
   }
-  const bool result = _operation.write(t, current_top, unflushed_size);
-  t->set_concurrent_top(current_top + unflushed_size);
+  const bool result = _operation.write(t, top, unflushed_size);
+  t->release_critical_section_top(top + unflushed_size);
   return result;
 }
 
-template <typename Operation>
-inline bool ConcurrentWriteOpExcludeRetired<Operation>::process(typename Operation::Type* t) {
-  if (t->retired()) {
-    assert(t->empty(), "invariant");
-    return true;
-  }
-  return ConcurrentWriteOp<Operation>::process(t);
-}
-
 template <typename Operation>
 inline bool MutexedWriteOp<Operation>::process(typename Operation::Type* t) {
   assert(t != NULL, "invariant");
-  const u1* const current_top = t->top();
-  const size_t unflushed_size = t->pos() - current_top;
+  const u1* const top = t->top();
+  const size_t unflushed_size = get_unflushed_size(top, t);
   if (unflushed_size == 0) {
     return true;
   }
-  const bool result = _operation.write(t, current_top, unflushed_size);
-  t->set_top(current_top + unflushed_size);
+  const bool result = _operation.write(t, top, unflushed_size);
+  t->set_top(top + unflushed_size);
   return result;
 }
 
+template <typename Type>
+static void retired_sensitive_acquire(Type* t) {
+  assert(t != NULL, "invariant");
+  if (t->retired()) {
+    return;
+  }
+  Thread* const thread = Thread::current();
+  while (!t->try_acquire(thread)) {
+    if (t->retired()) {
+      return;
+    }
+  }
+}
+
+template <typename Operation>
+inline bool ExclusiveOp<Operation>::process(typename Operation::Type* t) {
+  retired_sensitive_acquire(t);
+  assert(t->acquired_by_self() || t->retired(), "invariant");
+  // User is required to ensure proper release of the acquisition
+  return MutexedWriteOp<Operation>::process(t);
+}
+
 template <typename Operation>
 inline bool DiscardOp<Operation>::process(typename Operation::Type* t) {
   assert(t != NULL, "invariant");
-  const u1* const current_top = _mode == concurrent ? t->concurrent_top() : t->top();
-  const size_t unflushed_size = t->pos() - current_top;
+  const u1* const top = _mode == concurrent ? t->acquire_critical_section_top() : t->top();
+  const size_t unflushed_size = get_unflushed_size(top, t);
   if (unflushed_size == 0) {
     if (_mode == concurrent) {
-      t->set_concurrent_top(current_top);
+      t->release_critical_section_top(top);
     }
     return true;
   }
-  const bool result = _operation.discard(t, current_top, unflushed_size);
+  const bool result = _operation.discard(t, top, unflushed_size);
   if (_mode == concurrent) {
-    t->set_concurrent_top(current_top + unflushed_size);
+    t->release_critical_section_top(top + unflushed_size);
   } else {
-    t->set_top(current_top + unflushed_size);
+    t->set_top(top + unflushed_size);
   }
   return result;
 }
 
 #endif // SHARE_JFR_RECORDER_STORAGE_JFRSTORAGEUTILS_INLINE_HPP

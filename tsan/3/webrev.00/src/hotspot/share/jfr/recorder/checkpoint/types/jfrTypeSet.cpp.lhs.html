<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeSet.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
 27 #include &quot;classfile/javaClasses.inline.hpp&quot;
 28 #include &quot;classfile/moduleEntry.hpp&quot;
 29 #include &quot;classfile/packageEntry.hpp&quot;
 30 #include &quot;classfile/symbolTable.hpp&quot;
<a name="2" id="anc2"></a><span class="line-removed"> 31 #include &quot;classfile/systemDictionary.hpp&quot;</span>
 32 #include &quot;jfr/jfr.hpp&quot;
 33 #include &quot;jfr/jni/jfrGetAllEventClasses.hpp&quot;
<a name="3" id="anc3"></a><span class="line-modified"> 34 #include &quot;jfr/recorder/checkpoint/jfrCheckpointWriter.hpp&quot;</span>
 35 #include &quot;jfr/recorder/checkpoint/types/jfrTypeSet.hpp&quot;
 36 #include &quot;jfr/recorder/checkpoint/types/jfrTypeSetUtils.hpp&quot;
<a name="4" id="anc4"></a><span class="line-removed"> 37 #include &quot;jfr/recorder/checkpoint/types/jfrTypeSetWriter.hpp&quot;</span>
 38 #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceId.inline.hpp&quot;
<a name="5" id="anc5"></a><span class="line-removed"> 39 #include &quot;jfr/recorder/storage/jfrBuffer.hpp&quot;</span>
 40 #include &quot;jfr/utilities/jfrHashtable.hpp&quot;
 41 #include &quot;jfr/utilities/jfrTypes.hpp&quot;
<a name="6" id="anc6"></a>
 42 #include &quot;memory/iterator.hpp&quot;
 43 #include &quot;memory/resourceArea.hpp&quot;
 44 #include &quot;oops/instanceKlass.hpp&quot;
 45 #include &quot;oops/objArrayKlass.hpp&quot;
 46 #include &quot;oops/oop.inline.hpp&quot;
<a name="7" id="anc7"></a><span class="line-removed"> 47 #include &quot;memory/resourceArea.hpp&quot;</span>
 48 #include &quot;utilities/accessFlags.hpp&quot;
<a name="8" id="anc8"></a><span class="line-modified"> 49 </span>
<span class="line-removed"> 50 // incremented on each checkpoint</span>
<span class="line-removed"> 51 static u8 checkpoint_id = 0;</span>
<span class="line-removed"> 52 </span>
<span class="line-removed"> 53 // creates a unique id by combining a checkpoint relative symbol id (2^24)</span>
<span class="line-removed"> 54 // with the current checkpoint id (2^40)</span>
<span class="line-removed"> 55 #define CREATE_SYMBOL_ID(sym_id) (((u8)((checkpoint_id &lt;&lt; 24) | sym_id)))</span>
 56 
 57 typedef const Klass* KlassPtr;
 58 typedef const PackageEntry* PkgPtr;
 59 typedef const ModuleEntry* ModPtr;
 60 typedef const ClassLoaderData* CldPtr;
 61 typedef const Method* MethodPtr;
 62 typedef const Symbol* SymbolPtr;
 63 typedef const JfrSymbolId::SymbolEntry* SymbolEntryPtr;
 64 typedef const JfrSymbolId::CStringEntry* CStringEntryPtr;
 65 
<a name="9" id="anc9"></a><span class="line-modified"> 66 static traceid module_id(PkgPtr pkg) {</span>
<span class="line-modified"> 67   assert(pkg != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 68   ModPtr module_entry = pkg-&gt;module();</span>
<span class="line-modified"> 69   return module_entry != NULL &amp;&amp; module_entry-&gt;is_named() ? TRACE_ID(module_entry) : 0;</span>












 70 }
 71 
<a name="10" id="anc10"></a><span class="line-modified"> 72 static traceid package_id(KlassPtr klass) {</span>
<span class="line-modified"> 73   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 74   PkgPtr pkg_entry = klass-&gt;package();</span>
<span class="line-removed"> 75   return pkg_entry == NULL ? 0 : TRACE_ID(pkg_entry);</span>
 76 }
 77 
<a name="11" id="anc11"></a><span class="line-modified"> 78 static traceid cld_id(CldPtr cld) {</span>
<span class="line-modified"> 79   assert(cld != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 80   return cld-&gt;is_unsafe_anonymous() ? 0 : TRACE_ID(cld);</span>
 81 }
 82 
<a name="12" id="anc12"></a><span class="line-modified"> 83 static void tag_leakp_klass_artifacts(KlassPtr k, bool class_unload) {</span>
<span class="line-modified"> 84   assert(k != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 85   PkgPtr pkg = k-&gt;package();</span>
<span class="line-removed"> 86   if (pkg != NULL) {</span>
<span class="line-removed"> 87     tag_leakp_artifact(pkg, class_unload);</span>
<span class="line-removed"> 88     ModPtr module = pkg-&gt;module();</span>
<span class="line-removed"> 89     if (module != NULL) {</span>
<span class="line-removed"> 90       tag_leakp_artifact(module, class_unload);</span>
<span class="line-removed"> 91     }</span>
<span class="line-removed"> 92   }</span>
<span class="line-removed"> 93   CldPtr cld = k-&gt;class_loader_data();</span>
<span class="line-removed"> 94   assert(cld != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 95   if (!cld-&gt;is_unsafe_anonymous()) {</span>
<span class="line-removed"> 96     tag_leakp_artifact(cld, class_unload);</span>
<span class="line-removed"> 97   }</span>
 98 }
 99 
<a name="13" id="anc13"></a><span class="line-modified">100 class TagLeakpKlassArtifact {</span>
<span class="line-modified">101   bool _class_unload;</span>
<span class="line-modified">102  public:</span>
<span class="line-removed">103   TagLeakpKlassArtifact(bool class_unload) : _class_unload(class_unload) {}</span>
<span class="line-removed">104   bool operator()(KlassPtr klass) {</span>
<span class="line-removed">105     if (_class_unload) {</span>
<span class="line-removed">106       if (LEAKP_USED_THIS_EPOCH(klass)) {</span>
<span class="line-removed">107         tag_leakp_klass_artifacts(klass, _class_unload);</span>
<span class="line-removed">108       }</span>
<span class="line-removed">109     } else {</span>
<span class="line-removed">110       if (LEAKP_USED_PREV_EPOCH(klass)) {</span>
<span class="line-removed">111         tag_leakp_klass_artifacts(klass, _class_unload);</span>
<span class="line-removed">112       }</span>
<span class="line-removed">113     }</span>
<span class="line-removed">114     return true;</span>
<span class="line-removed">115   }</span>
<span class="line-removed">116 };</span>
117 
<a name="14" id="anc14"></a><span class="line-modified">118 /*</span>
<span class="line-modified">119  * In C++03, functions used as template parameters must have external linkage;</span>
<span class="line-modified">120  * this restriction was removed in C++11. Change back to &quot;static&quot; and</span>
<span class="line-removed">121  * rename functions when C++11 becomes available.</span>
<span class="line-removed">122  *</span>
<span class="line-removed">123  * The weird naming is an effort to decrease the risk of name clashes.</span>
<span class="line-removed">124  */</span>
125 
<a name="15" id="anc15"></a><span class="line-modified">126 int write__artifact__klass(JfrCheckpointWriter* writer, JfrArtifactSet* artifacts, const void* k) {</span>
<span class="line-modified">127   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">128   assert(artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">129   assert(k != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">130   KlassPtr klass = (KlassPtr)k;</span>
<span class="line-removed">131   traceid pkg_id = 0;</span>
<span class="line-removed">132   KlassPtr theklass = klass;</span>
<span class="line-removed">133   if (theklass-&gt;is_objArray_klass()) {</span>
<span class="line-removed">134     const ObjArrayKlass* obj_arr_klass = ObjArrayKlass::cast(klass);</span>
<span class="line-removed">135     theklass = obj_arr_klass-&gt;bottom_klass();</span>
<span class="line-removed">136   }</span>
<span class="line-removed">137   if (theklass-&gt;is_instance_klass()) {</span>
<span class="line-removed">138     pkg_id = package_id(theklass);</span>
<span class="line-removed">139   } else {</span>
<span class="line-removed">140     assert(theklass-&gt;is_typeArray_klass(), &quot;invariant&quot;);</span>
<span class="line-removed">141   }</span>
<span class="line-removed">142   const traceid symbol_id = artifacts-&gt;mark(klass);</span>
<span class="line-removed">143   assert(symbol_id &gt; 0, &quot;need to have an address for symbol!&quot;);</span>
<span class="line-removed">144   writer-&gt;write(TRACE_ID(klass));</span>
<span class="line-removed">145   writer-&gt;write(cld_id(klass-&gt;class_loader_data()));</span>
<span class="line-removed">146   writer-&gt;write((traceid)CREATE_SYMBOL_ID(symbol_id));</span>
<span class="line-removed">147   writer-&gt;write(pkg_id);</span>
<span class="line-removed">148   writer-&gt;write((s4)klass-&gt;access_flags().get_flags());</span>
<span class="line-removed">149   return 1;</span>
150 }
151 
<a name="16" id="anc16"></a><span class="line-modified">152 typedef LeakPredicate&lt;KlassPtr&gt; LeakKlassPredicate;</span>
<span class="line-modified">153 typedef JfrPredicatedArtifactWriterImplHost&lt;KlassPtr, LeakKlassPredicate, write__artifact__klass&gt; LeakKlassWriterImpl;</span>
<span class="line-modified">154 typedef JfrArtifactWriterHost&lt;LeakKlassWriterImpl, TYPE_CLASS&gt; LeakKlassWriter;</span>
<span class="line-modified">155 typedef JfrArtifactWriterImplHost&lt;KlassPtr, write__artifact__klass&gt; KlassWriterImpl;</span>
<span class="line-modified">156 typedef JfrArtifactWriterHost&lt;KlassWriterImpl, TYPE_CLASS&gt; KlassWriter;</span>
157 
<a name="17" id="anc17"></a><span class="line-modified">158 int write__artifact__method(JfrCheckpointWriter* writer, JfrArtifactSet* artifacts, const void* m) {</span>
<span class="line-removed">159   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">160   assert(artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">161   assert(m != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">162   MethodPtr method = (MethodPtr)m;</span>
<span class="line-removed">163   const traceid method_name_symbol_id = artifacts-&gt;mark(method-&gt;name());</span>
<span class="line-removed">164   assert(method_name_symbol_id &gt; 0, &quot;invariant&quot;);</span>
<span class="line-removed">165   const traceid method_sig_symbol_id = artifacts-&gt;mark(method-&gt;signature());</span>
<span class="line-removed">166   assert(method_sig_symbol_id &gt; 0, &quot;invariant&quot;);</span>
<span class="line-removed">167   KlassPtr klass = method-&gt;method_holder();</span>
168   assert(klass != NULL, &quot;invariant&quot;);
<a name="18" id="anc18"></a><span class="line-modified">169   assert(METHOD_USED_ANY_EPOCH(klass), &quot;invariant&quot;);</span>
<span class="line-modified">170   writer-&gt;write((u8)METHOD_ID(klass, method));</span>
<span class="line-modified">171   writer-&gt;write((u8)TRACE_ID(klass));</span>
<span class="line-modified">172   writer-&gt;write((u8)CREATE_SYMBOL_ID(method_name_symbol_id));</span>
<span class="line-modified">173   writer-&gt;write((u8)CREATE_SYMBOL_ID(method_sig_symbol_id));</span>
<span class="line-modified">174   writer-&gt;write((u2)method-&gt;access_flags().get_flags());</span>
<span class="line-modified">175   writer-&gt;write(const_cast&lt;Method*&gt;(method)-&gt;is_hidden() ? (u1)1 : (u1)0);</span>
<span class="line-modified">176   return 1;</span>

177 }
178 
<a name="19" id="anc19"></a><span class="line-modified">179 typedef JfrArtifactWriterImplHost&lt;MethodPtr, write__artifact__method&gt; MethodWriterImplTarget;</span>
<span class="line-modified">180 typedef JfrArtifactWriterHost&lt;MethodWriterImplTarget, TYPE_METHOD&gt; MethodWriterImpl;</span>
<span class="line-modified">181 </span>
<span class="line-modified">182 int write__artifact__package(JfrCheckpointWriter* writer, JfrArtifactSet* artifacts, const void* p) {</span>
<span class="line-modified">183   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">184   assert(artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">185   assert(p != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">186   PkgPtr pkg = (PkgPtr)p;</span>
<span class="line-modified">187   Symbol* const pkg_name = pkg-&gt;name();</span>
<span class="line-modified">188   const traceid package_name_symbol_id = pkg_name != NULL ? artifacts-&gt;mark(pkg_name) : 0;</span>
<span class="line-modified">189   assert(package_name_symbol_id &gt; 0, &quot;invariant&quot;);</span>
<span class="line-modified">190   writer-&gt;write((traceid)TRACE_ID(pkg));</span>
<span class="line-removed">191   writer-&gt;write((traceid)CREATE_SYMBOL_ID(package_name_symbol_id));</span>
<span class="line-removed">192   writer-&gt;write(module_id(pkg));</span>
<span class="line-removed">193   writer-&gt;write((bool)pkg-&gt;is_exported());</span>
<span class="line-removed">194   return 1;</span>
195 }
196 
<a name="20" id="anc20"></a><span class="line-modified">197 typedef LeakPredicate&lt;PkgPtr&gt; LeakPackagePredicate;</span>
<span class="line-modified">198 int _compare_pkg_ptr_(PkgPtr const&amp; lhs, PkgPtr const&amp; rhs) { return lhs &gt; rhs ? 1 : (lhs &lt; rhs) ? -1 : 0; }</span>
<span class="line-modified">199 typedef UniquePredicate&lt;PkgPtr, _compare_pkg_ptr_&gt; PackagePredicate;</span>
<span class="line-modified">200 typedef JfrPredicatedArtifactWriterImplHost&lt;PkgPtr, LeakPackagePredicate, write__artifact__package&gt; LeakPackageWriterImpl;</span>
<span class="line-removed">201 typedef JfrPredicatedArtifactWriterImplHost&lt;PkgPtr, PackagePredicate, write__artifact__package&gt; PackageWriterImpl;</span>
<span class="line-removed">202 typedef JfrArtifactWriterHost&lt;LeakPackageWriterImpl, TYPE_PACKAGE&gt; LeakPackageWriter;</span>
<span class="line-removed">203 typedef JfrArtifactWriterHost&lt;PackageWriterImpl, TYPE_PACKAGE&gt; PackageWriter;</span>
<span class="line-removed">204 </span>
<span class="line-removed">205 int write__artifact__module(JfrCheckpointWriter* writer, JfrArtifactSet* artifacts, const void* m) {</span>
<span class="line-removed">206   assert( m != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">207   ModPtr entry = (ModPtr)m;</span>
<span class="line-removed">208   Symbol* const module_name = entry-&gt;name();</span>
<span class="line-removed">209   const traceid module_name_symbol_id = module_name != NULL ? artifacts-&gt;mark(module_name) : 0;</span>
<span class="line-removed">210   Symbol* const module_version = entry-&gt;version();</span>
<span class="line-removed">211   const traceid module_version_symbol_id = module_version != NULL ? artifacts-&gt;mark(module_version) : 0;</span>
<span class="line-removed">212   Symbol* const module_location = entry-&gt;location();</span>
<span class="line-removed">213   const traceid module_location_symbol_id = module_location != NULL ? artifacts-&gt;mark(module_location) : 0;</span>
<span class="line-removed">214   writer-&gt;write((traceid)TRACE_ID(entry));</span>
<span class="line-removed">215   writer-&gt;write(module_name_symbol_id == 0 ? (traceid)0 : (traceid)CREATE_SYMBOL_ID(module_name_symbol_id));</span>
<span class="line-removed">216   writer-&gt;write(module_version_symbol_id == 0 ? (traceid)0 : (traceid)CREATE_SYMBOL_ID(module_version_symbol_id));</span>
<span class="line-removed">217   writer-&gt;write(module_location_symbol_id == 0 ? (traceid)0 : (traceid)CREATE_SYMBOL_ID(module_location_symbol_id));</span>
<span class="line-removed">218   writer-&gt;write(cld_id(entry-&gt;loader_data()));</span>
<span class="line-removed">219   return 1;</span>
220 }
221 
<a name="21" id="anc21"></a><span class="line-modified">222 typedef LeakPredicate&lt;ModPtr&gt; LeakModulePredicate;</span>
<span class="line-modified">223 int _compare_mod_ptr_(ModPtr const&amp; lhs, ModPtr const&amp; rhs) { return lhs &gt; rhs ? 1 : (lhs &lt; rhs) ? -1 : 0; }</span>
<span class="line-removed">224 typedef UniquePredicate&lt;ModPtr, _compare_mod_ptr_&gt; ModulePredicate;</span>
<span class="line-removed">225 typedef JfrPredicatedArtifactWriterImplHost&lt;ModPtr, LeakModulePredicate, write__artifact__module&gt; LeakModuleWriterImpl;</span>
<span class="line-removed">226 typedef JfrPredicatedArtifactWriterImplHost&lt;ModPtr, ModulePredicate, write__artifact__module&gt; ModuleWriterImpl;</span>
<span class="line-removed">227 typedef JfrArtifactWriterHost&lt;LeakModuleWriterImpl, TYPE_MODULE&gt; LeakModuleWriter;</span>
<span class="line-removed">228 typedef JfrArtifactWriterHost&lt;ModuleWriterImpl, TYPE_MODULE&gt; ModuleWriter;</span>
<span class="line-removed">229 </span>
<span class="line-removed">230 int write__artifact__classloader(JfrCheckpointWriter* writer, JfrArtifactSet* artifacts, const void* c) {</span>
<span class="line-removed">231   assert(c != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">232   CldPtr cld = (CldPtr)c;</span>
233   assert(!cld-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);
<a name="22" id="anc22"></a><span class="line-modified">234   const traceid cld_id = TRACE_ID(cld);</span>
<span class="line-modified">235   // class loader type</span>
<span class="line-removed">236   const Klass* class_loader_klass = cld-&gt;class_loader_klass();</span>
<span class="line-removed">237   if (class_loader_klass == NULL) {</span>
<span class="line-removed">238     // (primordial) boot class loader</span>
<span class="line-removed">239     writer-&gt;write(cld_id); // class loader instance id</span>
<span class="line-removed">240     writer-&gt;write((traceid)0);  // class loader type id (absence of)</span>
<span class="line-removed">241     writer-&gt;write((traceid)CREATE_SYMBOL_ID(1)); // 1 maps to synthetic name -&gt; &quot;bootstrap&quot;</span>
242   } else {
<a name="23" id="anc23"></a><span class="line-modified">243     Symbol* symbol_name = cld-&gt;name();</span>
<span class="line-removed">244     const traceid symbol_name_id = symbol_name != NULL ? artifacts-&gt;mark(symbol_name) : 0;</span>
<span class="line-removed">245     writer-&gt;write(cld_id); // class loader instance id</span>
<span class="line-removed">246     writer-&gt;write(TRACE_ID(class_loader_klass)); // class loader type id</span>
<span class="line-removed">247     writer-&gt;write(symbol_name_id == 0 ? (traceid)0 :</span>
<span class="line-removed">248       (traceid)CREATE_SYMBOL_ID(symbol_name_id)); // class loader instance name</span>
249   }
<a name="24" id="anc24"></a><span class="line-modified">250   return 1;</span>
251 }
252 
<a name="25" id="anc25"></a><span class="line-modified">253 typedef LeakPredicate&lt;CldPtr&gt; LeakCldPredicate;</span>
<span class="line-modified">254 int _compare_cld_ptr_(CldPtr const&amp; lhs, CldPtr const&amp; rhs) { return lhs &gt; rhs ? 1 : (lhs &lt; rhs) ? -1 : 0; }</span>
<span class="line-modified">255 typedef UniquePredicate&lt;CldPtr, _compare_cld_ptr_&gt; CldPredicate;</span>
<span class="line-modified">256 typedef JfrPredicatedArtifactWriterImplHost&lt;CldPtr, LeakCldPredicate, write__artifact__classloader&gt; LeakCldWriterImpl;</span>
<span class="line-modified">257 typedef JfrPredicatedArtifactWriterImplHost&lt;CldPtr, CldPredicate, write__artifact__classloader&gt; CldWriterImpl;</span>
<span class="line-removed">258 typedef JfrArtifactWriterHost&lt;LeakCldWriterImpl, TYPE_CLASSLOADER&gt; LeakCldWriter;</span>
<span class="line-removed">259 typedef JfrArtifactWriterHost&lt;CldWriterImpl, TYPE_CLASSLOADER&gt; CldWriter;</span>
<span class="line-removed">260 </span>
<span class="line-removed">261 typedef const JfrSymbolId::SymbolEntry* SymbolEntryPtr;</span>
262 
<a name="26" id="anc26"></a><span class="line-modified">263 static int write__artifact__symbol__entry__(JfrCheckpointWriter* writer,</span>
<span class="line-modified">264                                             SymbolEntryPtr entry) {</span>
<span class="line-modified">265   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">266   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">267   ResourceMark rm;</span>
<span class="line-removed">268   writer-&gt;write(CREATE_SYMBOL_ID(entry-&gt;id()));</span>
<span class="line-removed">269   writer-&gt;write(entry-&gt;value()-&gt;as_C_string());</span>
<span class="line-removed">270   return 1;</span>
271 }
272 
<a name="27" id="anc27"></a><span class="line-modified">273 int write__artifact__symbol__entry(JfrCheckpointWriter* writer, JfrArtifactSet* artifacts, const void* e) {</span>
<span class="line-modified">274   assert(e != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">275   return write__artifact__symbol__entry__(writer, (SymbolEntryPtr)e);</span>

276 }
277 
<a name="28" id="anc28"></a><span class="line-modified">278 typedef JfrArtifactWriterImplHost&lt;SymbolEntryPtr, write__artifact__symbol__entry&gt; SymbolEntryWriterImpl;</span>
<span class="line-modified">279 typedef JfrArtifactWriterHost&lt;SymbolEntryWriterImpl, TYPE_SYMBOL&gt; SymbolEntryWriter;</span>





280 
<a name="29" id="anc29"></a><span class="line-modified">281 typedef const JfrSymbolId::CStringEntry* CStringEntryPtr;</span>






282 
<a name="30" id="anc30"></a><span class="line-modified">283 static int write__artifact__cstring__entry__(JfrCheckpointWriter* writer, CStringEntryPtr entry) {</span>
284   assert(writer != NULL, &quot;invariant&quot;);
<a name="31" id="anc31"></a><span class="line-modified">285   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">286   writer-&gt;write(CREATE_SYMBOL_ID(entry-&gt;id()));</span>
<span class="line-modified">287   writer-&gt;write(entry-&gt;value());</span>















288   return 1;
289 }
290 
<a name="32" id="anc32"></a><span class="line-modified">291 int write__artifact__cstring__entry(JfrCheckpointWriter* writer, JfrArtifactSet* artifacts, const void* e) {</span>
<span class="line-modified">292   assert(e != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">293   return write__artifact__cstring__entry__(writer, (CStringEntryPtr)e);</span>


294 }
295 
<a name="33" id="anc33"></a><span class="line-modified">296 typedef JfrArtifactWriterImplHost&lt;CStringEntryPtr, write__artifact__cstring__entry&gt; CStringEntryWriterImpl;</span>
<span class="line-removed">297 typedef JfrArtifactWriterHost&lt;CStringEntryWriterImpl, TYPE_SYMBOL&gt; CStringEntryWriter;</span>
<span class="line-removed">298 </span>
<span class="line-removed">299 int write__artifact__klass__symbol(JfrCheckpointWriter* writer, JfrArtifactSet* artifacts, const void* k) {</span>
<span class="line-removed">300   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">301   assert(artifacts != NULL, &quot;invaiant&quot;);</span>
302   assert(k != NULL, &quot;invariant&quot;);
<a name="34" id="anc34"></a><span class="line-modified">303   const InstanceKlass* const ik = (const InstanceKlass*)k;</span>
<span class="line-modified">304   if (ik-&gt;is_unsafe_anonymous()) {</span>
<span class="line-removed">305     CStringEntryPtr entry =</span>
<span class="line-removed">306       artifacts-&gt;map_cstring(JfrSymbolId::unsafe_anonymous_klass_name_hash_code(ik));</span>
<span class="line-removed">307     assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">308     return write__artifact__cstring__entry__(writer, entry);</span>
<span class="line-removed">309   }</span>
<span class="line-removed">310 </span>
<span class="line-removed">311   SymbolEntryPtr entry = artifacts-&gt;map_symbol(JfrSymbolId::regular_klass_name_hash_code(ik));</span>
<span class="line-removed">312   return write__artifact__symbol__entry__(writer, entry);</span>
313 }
314 
<a name="35" id="anc35"></a><span class="line-modified">315 int _compare_traceid_(const traceid&amp; lhs, const traceid&amp; rhs) {</span>
<span class="line-modified">316   return lhs &gt; rhs ? 1 : (lhs &lt; rhs) ? -1 : 0;</span>

317 }
318 
<a name="36" id="anc36"></a><span class="line-modified">319 template &lt;template &lt;typename&gt; class Predicate&gt;</span>
<span class="line-modified">320 class KlassSymbolWriterImpl {</span>
<span class="line-modified">321  private:</span>
<span class="line-modified">322   JfrCheckpointWriter* _writer;</span>
<span class="line-modified">323   JfrArtifactSet* _artifacts;</span>
<span class="line-removed">324   Predicate&lt;KlassPtr&gt; _predicate;</span>
<span class="line-removed">325   MethodUsedPredicate&lt;true&gt; _method_used_predicate;</span>
<span class="line-removed">326   MethodFlagPredicate _method_flag_predicate;</span>
<span class="line-removed">327   UniquePredicate&lt;traceid, _compare_traceid_&gt; _unique_predicate;</span>
<span class="line-removed">328 </span>
<span class="line-removed">329   int klass_symbols(KlassPtr klass);</span>
<span class="line-removed">330   int package_symbols(PkgPtr pkg);</span>
<span class="line-removed">331   int module_symbols(ModPtr module);</span>
<span class="line-removed">332   int class_loader_symbols(CldPtr cld);</span>
<span class="line-removed">333   int method_symbols(KlassPtr klass);</span>
<span class="line-removed">334 </span>
<span class="line-removed">335  public:</span>
<span class="line-removed">336   typedef KlassPtr Type;</span>
<span class="line-removed">337   KlassSymbolWriterImpl(JfrCheckpointWriter* writer,</span>
<span class="line-removed">338                         JfrArtifactSet* artifacts,</span>
<span class="line-removed">339                         bool class_unload) : _writer(writer),</span>
<span class="line-removed">340                                              _artifacts(artifacts),</span>
<span class="line-removed">341                                              _predicate(class_unload),</span>
<span class="line-removed">342                                              _method_used_predicate(class_unload),</span>
<span class="line-removed">343                                              _method_flag_predicate(class_unload),</span>
<span class="line-removed">344                                              _unique_predicate(class_unload) {}</span>
<span class="line-removed">345 </span>
<span class="line-removed">346   int operator()(KlassPtr klass) {</span>
<span class="line-removed">347     assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">348     int count = 0;</span>
<span class="line-removed">349     if (_predicate(klass)) {</span>
<span class="line-removed">350       count += klass_symbols(klass);</span>
<span class="line-removed">351       PkgPtr pkg = klass-&gt;package();</span>
<span class="line-removed">352       if (pkg != NULL) {</span>
<span class="line-removed">353         count += package_symbols(pkg);</span>
<span class="line-removed">354         ModPtr module = pkg-&gt;module();</span>
<span class="line-removed">355         if (module != NULL &amp;&amp; module-&gt;is_named()) {</span>
<span class="line-removed">356           count += module_symbols(module);</span>
<span class="line-removed">357         }</span>
<span class="line-removed">358       }</span>
<span class="line-removed">359       CldPtr cld = klass-&gt;class_loader_data();</span>
<span class="line-removed">360       assert(cld != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">361       if (!cld-&gt;is_unsafe_anonymous()) {</span>
<span class="line-removed">362         count += class_loader_symbols(cld);</span>
<span class="line-removed">363       }</span>
<span class="line-removed">364       if (_method_used_predicate(klass)) {</span>
<span class="line-removed">365         count += method_symbols(klass);</span>
<span class="line-removed">366       }</span>
367     }
<a name="37" id="anc37"></a><span class="line-modified">368     return count;</span>
369   }
<a name="38" id="anc38"></a><span class="line-removed">370 };</span>
<span class="line-removed">371 </span>
<span class="line-removed">372 template &lt;template &lt;typename&gt; class Predicate&gt;</span>
<span class="line-removed">373 int KlassSymbolWriterImpl&lt;Predicate&gt;::klass_symbols(KlassPtr klass) {</span>
<span class="line-removed">374   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">375   assert(_predicate(klass), &quot;invariant&quot;);</span>
<span class="line-removed">376   const InstanceKlass* const ik = (const InstanceKlass*)klass;</span>
<span class="line-removed">377   if (ik-&gt;is_unsafe_anonymous()) {</span>
<span class="line-removed">378     CStringEntryPtr entry =</span>
<span class="line-removed">379       this-&gt;_artifacts-&gt;map_cstring(JfrSymbolId::unsafe_anonymous_klass_name_hash_code(ik));</span>
<span class="line-removed">380     assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">381     return _unique_predicate(entry-&gt;id()) ? write__artifact__cstring__entry__(this-&gt;_writer, entry) : 0;</span>
<span class="line-removed">382   }</span>
<span class="line-removed">383   SymbolEntryPtr entry = this-&gt;_artifacts-&gt;map_symbol(ik-&gt;name());</span>
<span class="line-removed">384   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">385   return _unique_predicate(entry-&gt;id()) ? write__artifact__symbol__entry__(this-&gt;_writer, entry) : 0;</span>
386 }
387 
<a name="39" id="anc39"></a><span class="line-modified">388 template &lt;template &lt;typename&gt; class Predicate&gt;</span>
<span class="line-modified">389 int KlassSymbolWriterImpl&lt;Predicate&gt;::package_symbols(PkgPtr pkg) {</span>
<span class="line-modified">390   assert(pkg != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">391   SymbolPtr pkg_name = pkg-&gt;name();</span>
<span class="line-modified">392   assert(pkg_name != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">393   SymbolEntryPtr package_symbol = this-&gt;_artifacts-&gt;map_symbol(pkg_name);</span>
<span class="line-removed">394   assert(package_symbol != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">395   return _unique_predicate(package_symbol-&gt;id()) ?</span>
<span class="line-removed">396     write__artifact__symbol__entry__(this-&gt;_writer, package_symbol) : 0;</span>
<span class="line-removed">397 }</span>
<span class="line-removed">398 </span>
<span class="line-removed">399 template &lt;template &lt;typename&gt; class Predicate&gt;</span>
<span class="line-removed">400 int KlassSymbolWriterImpl&lt;Predicate&gt;::module_symbols(ModPtr module) {</span>
<span class="line-removed">401   assert(module != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">402   assert(module-&gt;is_named(), &quot;invariant&quot;);</span>
<span class="line-removed">403   int count = 0;</span>
<span class="line-removed">404   SymbolPtr sym = module-&gt;name();</span>
<span class="line-removed">405   SymbolEntryPtr entry = NULL;</span>
<span class="line-removed">406   if (sym != NULL) {</span>
<span class="line-removed">407     entry = this-&gt;_artifacts-&gt;map_symbol(sym);</span>
<span class="line-removed">408     assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">409     if (_unique_predicate(entry-&gt;id())) {</span>
<span class="line-removed">410       count += write__artifact__symbol__entry__(this-&gt;_writer, entry);</span>
<span class="line-removed">411     }</span>
<span class="line-removed">412   }</span>
<span class="line-removed">413   sym = module-&gt;version();</span>
<span class="line-removed">414   if (sym != NULL) {</span>
<span class="line-removed">415     entry = this-&gt;_artifacts-&gt;map_symbol(sym);</span>
<span class="line-removed">416     assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">417     if (_unique_predicate(entry-&gt;id())) {</span>
<span class="line-removed">418       count += write__artifact__symbol__entry__(this-&gt;_writer, entry);</span>
<span class="line-removed">419     }</span>
420   }
<a name="40" id="anc40"></a><span class="line-modified">421   sym = module-&gt;location();</span>
<span class="line-modified">422   if (sym != NULL) {</span>
<span class="line-modified">423     entry = this-&gt;_artifacts-&gt;map_symbol(sym);</span>
<span class="line-modified">424     assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">425     if (_unique_predicate(entry-&gt;id())) {</span>
<span class="line-removed">426       count += write__artifact__symbol__entry__(this-&gt;_writer, entry);</span>
<span class="line-removed">427     }</span>
428   }
<a name="41" id="anc41"></a><span class="line-modified">429   return count;</span>
430 }
431 
<a name="42" id="anc42"></a><span class="line-modified">432 template &lt;template &lt;typename&gt; class Predicate&gt;</span>
<span class="line-modified">433 int KlassSymbolWriterImpl&lt;Predicate&gt;::class_loader_symbols(CldPtr cld) {</span>
<span class="line-modified">434   assert(cld != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">435   assert(!cld-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);</span>
<span class="line-modified">436   int count = 0;</span>
<span class="line-modified">437   // class loader type</span>
<span class="line-modified">438   const Klass* class_loader_klass = cld-&gt;class_loader_klass();</span>
<span class="line-removed">439   if (class_loader_klass == NULL) {</span>
<span class="line-removed">440     // (primordial) boot class loader</span>
<span class="line-removed">441     CStringEntryPtr entry = this-&gt;_artifacts-&gt;map_cstring(0);</span>
<span class="line-removed">442     assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">443     assert(strncmp(entry-&gt;literal(),</span>
<span class="line-removed">444       BOOTSTRAP_LOADER_NAME,</span>
<span class="line-removed">445       BOOTSTRAP_LOADER_NAME_LEN) == 0, &quot;invariant&quot;);</span>
<span class="line-removed">446     if (_unique_predicate(entry-&gt;id())) {</span>
<span class="line-removed">447       count += write__artifact__cstring__entry__(this-&gt;_writer, entry);</span>
448     }
449   } else {
<a name="43" id="anc43"></a><span class="line-modified">450     const Symbol* class_loader_name = cld-&gt;name();</span>
<span class="line-modified">451     if (class_loader_name != NULL) {</span>
<span class="line-modified">452       SymbolEntryPtr entry = this-&gt;_artifacts-&gt;map_symbol(class_loader_name);</span>
<span class="line-removed">453       assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">454       if (_unique_predicate(entry-&gt;id())) {</span>
<span class="line-removed">455         count += write__artifact__symbol__entry__(this-&gt;_writer, entry);</span>
<span class="line-removed">456       }</span>
<span class="line-removed">457     }</span>
<span class="line-removed">458   }</span>
<span class="line-removed">459   return count;</span>
<span class="line-removed">460 }</span>
<span class="line-removed">461 </span>
<span class="line-removed">462 template &lt;template &lt;typename&gt; class Predicate&gt;</span>
<span class="line-removed">463 int KlassSymbolWriterImpl&lt;Predicate&gt;::method_symbols(KlassPtr klass) {</span>
<span class="line-removed">464   assert(_predicate(klass), &quot;invariant&quot;);</span>
<span class="line-removed">465   assert(_method_used_predicate(klass), &quot;invariant&quot;);</span>
<span class="line-removed">466   assert(METHOD_AND_CLASS_USED_ANY_EPOCH(klass), &quot;invariant&quot;);</span>
<span class="line-removed">467   int count = 0;</span>
<span class="line-removed">468   const InstanceKlass* const ik = InstanceKlass::cast(klass);</span>
<span class="line-removed">469   const int len = ik-&gt;methods()-&gt;length();</span>
<span class="line-removed">470   for (int i = 0; i &lt; len; ++i) {</span>
<span class="line-removed">471     MethodPtr method = ik-&gt;methods()-&gt;at(i);</span>
<span class="line-removed">472     if (_method_flag_predicate(method)) {</span>
<span class="line-removed">473       SymbolEntryPtr entry = this-&gt;_artifacts-&gt;map_symbol(method-&gt;name());</span>
<span class="line-removed">474       assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">475       if (_unique_predicate(entry-&gt;id())) {</span>
<span class="line-removed">476         count += write__artifact__symbol__entry__(this-&gt;_writer, entry);</span>
<span class="line-removed">477       }</span>
<span class="line-removed">478       entry = this-&gt;_artifacts-&gt;map_symbol(method-&gt;signature());</span>
<span class="line-removed">479       assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">480       if (_unique_predicate(entry-&gt;id())) {</span>
<span class="line-removed">481         count += write__artifact__symbol__entry__(this-&gt;_writer, entry);</span>
<span class="line-removed">482       }</span>
483     }
484   }
<a name="44" id="anc44"></a><span class="line-modified">485   return count;</span>
486 }
487 
<a name="45" id="anc45"></a><span class="line-modified">488 typedef KlassSymbolWriterImpl&lt;LeakPredicate&gt; LeakKlassSymbolWriterImpl;</span>
<span class="line-modified">489 typedef JfrArtifactWriterHost&lt;LeakKlassSymbolWriterImpl, TYPE_SYMBOL&gt; LeakKlassSymbolWriter;</span>





490 
<a name="46" id="anc46"></a><span class="line-modified">491 class ClearKlassAndMethods {</span>
<span class="line-modified">492  private:</span>
<span class="line-modified">493   ClearArtifact&lt;KlassPtr&gt; _clear_klass_tag_bits;</span>
<span class="line-modified">494   ClearArtifact&lt;MethodPtr&gt; _clear_method_flag;</span>
<span class="line-modified">495   MethodUsedPredicate&lt;false&gt; _method_used_predicate;</span>
496 
<a name="47" id="anc47"></a><span class="line-modified">497  public:</span>
<span class="line-modified">498   ClearKlassAndMethods(bool class_unload) : _clear_klass_tag_bits(class_unload),</span>
<span class="line-modified">499                                             _clear_method_flag(class_unload),</span>
<span class="line-modified">500                                             _method_used_predicate(class_unload) {}</span>
<span class="line-modified">501   bool operator()(KlassPtr klass) {</span>
<span class="line-modified">502     if (_method_used_predicate(klass)) {</span>
<span class="line-modified">503       const InstanceKlass* ik = InstanceKlass::cast(klass);</span>
<span class="line-removed">504       const int len = ik-&gt;methods()-&gt;length();</span>
<span class="line-removed">505       for (int i = 0; i &lt; len; ++i) {</span>
<span class="line-removed">506         MethodPtr method = ik-&gt;methods()-&gt;at(i);</span>
<span class="line-removed">507         _clear_method_flag(method);</span>
<span class="line-removed">508       }</span>
<span class="line-removed">509     }</span>
<span class="line-removed">510     _clear_klass_tag_bits(klass);</span>
<span class="line-removed">511     return true;</span>
512   }
513 };
514 
<a name="48" id="anc48"></a><span class="line-modified">515 typedef CompositeFunctor&lt;KlassPtr,</span>
<span class="line-modified">516                          TagLeakpKlassArtifact,</span>
<span class="line-modified">517                          LeakKlassWriter&gt; LeakpKlassArtifactTagging;</span>
<span class="line-removed">518 </span>
<span class="line-removed">519 typedef CompositeFunctor&lt;KlassPtr,</span>
<span class="line-removed">520                          LeakpKlassArtifactTagging,</span>
<span class="line-removed">521                          KlassWriter&gt; CompositeKlassWriter;</span>
<span class="line-removed">522 </span>
<span class="line-removed">523 typedef CompositeFunctor&lt;KlassPtr,</span>
<span class="line-removed">524                          CompositeKlassWriter,</span>
<span class="line-removed">525                          KlassArtifactRegistrator&gt; CompositeKlassWriterRegistration;</span>
<span class="line-removed">526 </span>
<span class="line-removed">527 typedef CompositeFunctor&lt;KlassPtr,</span>
<span class="line-removed">528                          KlassWriter,</span>
<span class="line-removed">529                          KlassArtifactRegistrator&gt; KlassWriterRegistration;</span>
530 
<a name="49" id="anc49"></a><span class="line-modified">531 typedef JfrArtifactCallbackHost&lt;KlassPtr, KlassWriterRegistration&gt; KlassCallback;</span>

532 typedef JfrArtifactCallbackHost&lt;KlassPtr, CompositeKlassWriterRegistration&gt; CompositeKlassCallback;
533 
<a name="50" id="anc50"></a><span class="line-modified">534 /*</span>
<span class="line-removed">535  * Composite operation</span>
<span class="line-removed">536  *</span>
<span class="line-removed">537  * TagLeakpKlassArtifact -&gt;</span>
<span class="line-removed">538  *   LeakpPredicate -&gt;</span>
<span class="line-removed">539  *     LeakpKlassWriter -&gt;</span>
<span class="line-removed">540  *       KlassPredicate -&gt;</span>
<span class="line-removed">541  *         KlassWriter -&gt;</span>
<span class="line-removed">542  *           KlassWriterRegistration</span>
<span class="line-removed">543  */</span>
<span class="line-removed">544 void JfrTypeSet::write_klass_constants(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer) {</span>
545   assert(!_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);
<a name="51" id="anc51"></a>
546   KlassArtifactRegistrator reg(_artifacts);
<a name="52" id="anc52"></a><span class="line-modified">547   KlassWriter kw(writer, _artifacts, _class_unload);</span>
548   KlassWriterRegistration kwr(&amp;kw, &amp;reg);
<a name="53" id="anc53"></a><span class="line-modified">549   if (leakp_writer == NULL) {</span>
550     KlassCallback callback(&amp;kwr);
551     _subsystem_callback = &amp;callback;
552     do_klasses();
<a name="54" id="anc54"></a>





















553     return;
554   }
<a name="55" id="anc55"></a><span class="line-modified">555   TagLeakpKlassArtifact tagging(_class_unload);</span>
<span class="line-modified">556   LeakKlassWriter lkw(leakp_writer, _artifacts, _class_unload);</span>
<span class="line-modified">557   LeakpKlassArtifactTagging lpkat(&amp;tagging, &amp;lkw);</span>
<span class="line-modified">558   CompositeKlassWriter ckw(&amp;lpkat, &amp;kw);</span>
<span class="line-modified">559   CompositeKlassWriterRegistration ckwr(&amp;ckw, &amp;reg);</span>
<span class="line-modified">560   CompositeKlassCallback callback(&amp;ckwr);</span>
















561   _subsystem_callback = &amp;callback;
<a name="56" id="anc56"></a><span class="line-modified">562   do_klasses();</span>


















563 }
564 
<a name="57" id="anc57"></a><span class="line-modified">565 typedef CompositeFunctor&lt;PkgPtr,</span>
<span class="line-modified">566                          PackageWriter,</span>
<span class="line-modified">567                          ClearArtifact&lt;PkgPtr&gt; &gt; PackageWriterWithClear;</span>



568 
<a name="58" id="anc58"></a><span class="line-modified">569 typedef CompositeFunctor&lt;PkgPtr,</span>
<span class="line-modified">570                          LeakPackageWriter,</span>
<span class="line-modified">571                          PackageWriter&gt; CompositePackageWriter;</span>
572 
<a name="59" id="anc59"></a><span class="line-modified">573 typedef CompositeFunctor&lt;PkgPtr,</span>
<span class="line-modified">574                          CompositePackageWriter,</span>
<span class="line-modified">575                          ClearArtifact&lt;PkgPtr&gt; &gt; CompositePackageWriterWithClear;</span>
576 
577 class PackageFieldSelector {
578  public:
579   typedef PkgPtr TypePtr;
580   static TypePtr select(KlassPtr klass) {
581     assert(klass != NULL, &quot;invariant&quot;);
582     return ((InstanceKlass*)klass)-&gt;package();
583   }
584 };
585 
<a name="60" id="anc60"></a><span class="line-modified">586 typedef KlassToFieldEnvelope&lt;PackageFieldSelector,</span>
<span class="line-modified">587                              PackageWriterWithClear&gt; KlassPackageWriterWithClear;</span>




588 
<a name="61" id="anc61"></a><span class="line-modified">589 typedef KlassToFieldEnvelope&lt;PackageFieldSelector,</span>
<span class="line-modified">590                              CompositePackageWriterWithClear&gt; KlassCompositePackageWriterWithClear;</span>

591 
<a name="62" id="anc62"></a><span class="line-modified">592 typedef JfrArtifactCallbackHost&lt;PkgPtr, PackageWriterWithClear&gt; PackageCallback;</span>



593 typedef JfrArtifactCallbackHost&lt;PkgPtr, CompositePackageWriterWithClear&gt; CompositePackageCallback;
594 
<a name="63" id="anc63"></a><span class="line-modified">595 /*</span>
<span class="line-modified">596  * Composite operation</span>
<span class="line-modified">597  *</span>
<span class="line-modified">598  * LeakpPackageWriter -&gt;</span>
<span class="line-modified">599  *   PackageWriter -&gt;</span>
<span class="line-modified">600  *     ClearArtifact&lt;PackageEntry&gt;</span>
<span class="line-modified">601  *</span>
<span class="line-modified">602  */</span>
<span class="line-modified">603 void JfrTypeSet::write_package_constants(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer) {</span>
<span class="line-modified">604   assert(_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);</span>
<span class="line-modified">605   ClearArtifact&lt;PkgPtr&gt; clear(_class_unload);</span>
<span class="line-modified">606   PackageWriter pw(writer, _artifacts, _class_unload);</span>
<span class="line-modified">607   if (leakp_writer == NULL) {</span>
608     PackageWriterWithClear pwwc(&amp;pw, &amp;clear);
<a name="64" id="anc64"></a><span class="line-removed">609     KlassPackageWriterWithClear kpwwc(&amp;pwwc);</span>
<span class="line-removed">610     _artifacts-&gt;iterate_klasses(kpwwc);</span>
611     PackageCallback callback(&amp;pwwc);
612     _subsystem_callback = &amp;callback;
613     do_packages();
<a name="65" id="anc65"></a><span class="line-modified">614     return;</span>









615   }
<a name="66" id="anc66"></a><span class="line-modified">616   LeakPackageWriter lpw(leakp_writer, _artifacts, _class_unload);</span>
<span class="line-modified">617   CompositePackageWriter cpw(&amp;lpw, &amp;pw);</span>
<span class="line-modified">618   CompositePackageWriterWithClear cpwwc(&amp;cpw, &amp;clear);</span>
<span class="line-modified">619   KlassCompositePackageWriterWithClear ckpw(&amp;cpwwc);</span>
<span class="line-modified">620   _artifacts-&gt;iterate_klasses(ckpw);</span>
<span class="line-modified">621   CompositePackageCallback callback(&amp;cpwwc);</span>


622   _subsystem_callback = &amp;callback;
623   do_packages();
624 }
625 
<a name="67" id="anc67"></a><span class="line-modified">626 typedef CompositeFunctor&lt;ModPtr,</span>
<span class="line-modified">627                          ModuleWriter,</span>
<span class="line-modified">628                          ClearArtifact&lt;ModPtr&gt; &gt; ModuleWriterWithClear;</span>







629 
<a name="68" id="anc68"></a><span class="line-modified">630 typedef CompositeFunctor&lt;ModPtr,</span>
<span class="line-modified">631                          LeakModuleWriter,</span>
<span class="line-modified">632                          ModuleWriter&gt; CompositeModuleWriter;</span>



633 
<a name="69" id="anc69"></a><span class="line-modified">634 typedef CompositeFunctor&lt;ModPtr,</span>
<span class="line-modified">635                          CompositeModuleWriter,</span>
<span class="line-modified">636                          ClearArtifact&lt;ModPtr&gt; &gt; CompositeModuleWriterWithClear;</span>



637 
<a name="70" id="anc70"></a><span class="line-modified">638 typedef JfrArtifactCallbackHost&lt;ModPtr, ModuleWriterWithClear&gt; ModuleCallback;</span>
<span class="line-modified">639 typedef JfrArtifactCallbackHost&lt;ModPtr, CompositeModuleWriterWithClear&gt; CompositeModuleCallback;</span>





640 
641 class ModuleFieldSelector {
642  public:
643   typedef ModPtr TypePtr;
644   static TypePtr select(KlassPtr klass) {
645     assert(klass != NULL, &quot;invariant&quot;);
646     PkgPtr pkg = klass-&gt;package();
647     return pkg != NULL ? pkg-&gt;module() : NULL;
648   }
649 };
650 
<a name="71" id="anc71"></a><span class="line-modified">651 typedef KlassToFieldEnvelope&lt;ModuleFieldSelector,</span>
<span class="line-modified">652                              ModuleWriterWithClear&gt; KlassModuleWriterWithClear;</span>




653 
<a name="72" id="anc72"></a><span class="line-modified">654 typedef KlassToFieldEnvelope&lt;ModuleFieldSelector,</span>
<span class="line-modified">655                              CompositeModuleWriterWithClear&gt; KlassCompositeModuleWriterWithClear;</span>

656 
<a name="73" id="anc73"></a><span class="line-modified">657 /*</span>
<span class="line-modified">658  * Composite operation</span>
<span class="line-modified">659  *</span>
<span class="line-modified">660  * LeakpModuleWriter -&gt;</span>
<span class="line-modified">661  *   ModuleWriter -&gt;</span>
<span class="line-modified">662  *     ClearArtifact&lt;ModuleEntry&gt;</span>
<span class="line-modified">663  */</span>
<span class="line-modified">664 void JfrTypeSet::write_module_constants(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer) {</span>
<span class="line-modified">665   assert(_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);</span>
<span class="line-modified">666   ClearArtifact&lt;ModPtr&gt; clear(_class_unload);</span>
<span class="line-modified">667   ModuleWriter mw(writer, _artifacts, _class_unload);</span>
<span class="line-modified">668   if (leakp_writer == NULL) {</span>






669     ModuleWriterWithClear mwwc(&amp;mw, &amp;clear);
<a name="74" id="anc74"></a><span class="line-removed">670     KlassModuleWriterWithClear kmwwc(&amp;mwwc);</span>
<span class="line-removed">671     _artifacts-&gt;iterate_klasses(kmwwc);</span>
672     ModuleCallback callback(&amp;mwwc);
673     _subsystem_callback = &amp;callback;
674     do_modules();
<a name="75" id="anc75"></a><span class="line-modified">675     return;</span>









676   }
<a name="76" id="anc76"></a><span class="line-modified">677   LeakModuleWriter lmw(leakp_writer, _artifacts, _class_unload);</span>
<span class="line-modified">678   CompositeModuleWriter cmw(&amp;lmw, &amp;mw);</span>
<span class="line-modified">679   CompositeModuleWriterWithClear cmwwc(&amp;cmw, &amp;clear);</span>
<span class="line-modified">680   KlassCompositeModuleWriterWithClear kmwwc(&amp;cmwwc);</span>
<span class="line-modified">681   _artifacts-&gt;iterate_klasses(kmwwc);</span>
<span class="line-modified">682   CompositeModuleCallback callback(&amp;cmwwc);</span>


683   _subsystem_callback = &amp;callback;
684   do_modules();
685 }
686 
<a name="77" id="anc77"></a><span class="line-modified">687 typedef CompositeFunctor&lt;CldPtr, CldWriter, ClearArtifact&lt;CldPtr&gt; &gt; CldWriterWithClear;</span>
<span class="line-modified">688 typedef CompositeFunctor&lt;CldPtr, LeakCldWriter, CldWriter&gt; CompositeCldWriter;</span>
<span class="line-modified">689 typedef CompositeFunctor&lt;CldPtr, CompositeCldWriter, ClearArtifact&lt;CldPtr&gt; &gt; CompositeCldWriterWithClear;</span>
<span class="line-modified">690 typedef JfrArtifactCallbackHost&lt;CldPtr, CldWriterWithClear&gt; CldCallback;</span>
<span class="line-modified">691 typedef JfrArtifactCallbackHost&lt;CldPtr, CompositeCldWriterWithClear&gt; CompositeCldCallback;</span>


























692 
<a name="78" id="anc78"></a><span class="line-modified">693 class CldFieldSelector {</span>




694  public:
695   typedef CldPtr TypePtr;
696   static TypePtr select(KlassPtr klass) {
697     assert(klass != NULL, &quot;invariant&quot;);
<a name="79" id="anc79"></a><span class="line-modified">698     CldPtr cld = klass-&gt;class_loader_data();</span>
<span class="line-removed">699     return cld-&gt;is_unsafe_anonymous() ? NULL : cld;</span>
700   }
701 };
702 
<a name="80" id="anc80"></a><span class="line-modified">703 typedef KlassToFieldEnvelope&lt;CldFieldSelector, CldWriterWithClear&gt; KlassCldWriterWithClear;</span>
<span class="line-modified">704 typedef KlassToFieldEnvelope&lt;CldFieldSelector, CompositeCldWriterWithClear&gt; KlassCompositeCldWriterWithClear;</span>







705 
<a name="81" id="anc81"></a><span class="line-modified">706 /*</span>
<span class="line-modified">707  * Composite operation</span>
<span class="line-modified">708  *</span>
<span class="line-modified">709  * LeakpClassLoaderWriter -&gt;</span>
<span class="line-modified">710  *   ClassLoaderWriter -&gt;</span>
<span class="line-modified">711  *     ClearArtifact&lt;ClassLoaderData&gt;</span>
<span class="line-modified">712  */</span>
<span class="line-modified">713 void JfrTypeSet::write_class_loader_constants(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer) {</span>
<span class="line-modified">714   assert(_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);</span>
<span class="line-modified">715   ClearArtifact&lt;CldPtr&gt; clear(_class_unload);</span>
<span class="line-modified">716   CldWriter cldw(writer, _artifacts, _class_unload);</span>
<span class="line-modified">717   if (leakp_writer == NULL) {</span>








































718     CldWriterWithClear cldwwc(&amp;cldw, &amp;clear);
<a name="82" id="anc82"></a><span class="line-removed">719     KlassCldWriterWithClear kcldwwc(&amp;cldwwc);</span>
<span class="line-removed">720     _artifacts-&gt;iterate_klasses(kcldwwc);</span>
721     CldCallback callback(&amp;cldwwc);
722     _subsystem_callback = &amp;callback;
723     do_class_loaders();
<a name="83" id="anc83"></a><span class="line-modified">724     return;</span>











725   }
<a name="84" id="anc84"></a><span class="line-modified">726   LeakCldWriter lcldw(leakp_writer, _artifacts, _class_unload);</span>
<span class="line-modified">727   CompositeCldWriter ccldw(&amp;lcldw, &amp;cldw);</span>
<span class="line-modified">728   CompositeCldWriterWithClear ccldwwc(&amp;ccldw, &amp;clear);</span>
<span class="line-modified">729   KlassCompositeCldWriterWithClear kcclwwc(&amp;ccldwwc);</span>
<span class="line-modified">730   _artifacts-&gt;iterate_klasses(kcclwwc);</span>
<span class="line-modified">731   CompositeCldCallback callback(&amp;ccldwwc);</span>


732   _subsystem_callback = &amp;callback;
733   do_class_loaders();
734 }
735 
<a name="85" id="anc85"></a><span class="line-modified">736 template &lt;bool predicate_bool, typename MethodFunctor&gt;</span>

































































737 class MethodIteratorHost {
738  private:
<a name="86" id="anc86"></a><span class="line-modified">739   MethodFunctor _method_functor;</span>
<span class="line-modified">740   MethodUsedPredicate&lt;predicate_bool&gt; _method_used_predicate;</span>
<span class="line-modified">741   MethodFlagPredicate _method_flag_predicate;</span>
<span class="line-modified">742 </span>
743  public:
744   MethodIteratorHost(JfrCheckpointWriter* writer,
<a name="87" id="anc87"></a><span class="line-modified">745                      JfrArtifactSet* artifacts,</span>
<span class="line-modified">746                      bool class_unload,</span>
747                      bool skip_header = false) :
<a name="88" id="anc88"></a><span class="line-modified">748     _method_functor(writer, artifacts, class_unload, skip_header),</span>
<span class="line-modified">749     _method_used_predicate(class_unload),</span>
<span class="line-modified">750     _method_flag_predicate(class_unload) {}</span>

751 
752   bool operator()(KlassPtr klass) {
753     if (_method_used_predicate(klass)) {
<a name="89" id="anc89"></a><span class="line-removed">754       assert(METHOD_AND_CLASS_USED_ANY_EPOCH(klass), &quot;invariant&quot;);</span>
755       const InstanceKlass* ik = InstanceKlass::cast(klass);
756       const int len = ik-&gt;methods()-&gt;length();
<a name="90" id="anc90"></a><span class="line-modified">757       for (int i = 0; i &lt; len; ++i) {</span>
<span class="line-modified">758         MethodPtr method = ik-&gt;methods()-&gt;at(i);</span>
<span class="line-modified">759         if (_method_flag_predicate(method)) {</span>
<span class="line-modified">760           _method_functor(method);</span>



761         }
<a name="91" id="anc91"></a>


762       }
763     }
<a name="92" id="anc92"></a><span class="line-modified">764     return true;</span>
765   }
766 
<a name="93" id="anc93"></a><span class="line-modified">767   int count() const { return _method_functor.count(); }</span>
<span class="line-modified">768   void add(int count) { _method_functor.add(count); }</span>
769 };
770 
<a name="94" id="anc94"></a><span class="line-modified">771 typedef MethodIteratorHost&lt;true /*leakp */,  MethodWriterImpl&gt; LeakMethodWriter;</span>
<span class="line-modified">772 typedef MethodIteratorHost&lt;false, MethodWriterImpl&gt; MethodWriter;</span>
<span class="line-modified">773 typedef CompositeFunctor&lt;KlassPtr, LeakMethodWriter, MethodWriter&gt; CompositeMethodWriter;</span>
<span class="line-modified">774 </span>
<span class="line-modified">775 /*</span>
<span class="line-modified">776  * Composite operation</span>
<span class="line-modified">777  *</span>
<span class="line-removed">778  * LeakpMethodWriter -&gt;</span>
<span class="line-removed">779  *   MethodWriter</span>
<span class="line-removed">780  */</span>
<span class="line-removed">781 void JfrTypeSet::write_method_constants(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer) {</span>
<span class="line-removed">782   assert(_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);</span>
<span class="line-removed">783   MethodWriter mw(writer, _artifacts, _class_unload);</span>
<span class="line-removed">784   if (leakp_writer == NULL) {</span>
<span class="line-removed">785     _artifacts-&gt;iterate_klasses(mw);</span>
<span class="line-removed">786     return;</span>
<span class="line-removed">787   }</span>
<span class="line-removed">788   LeakMethodWriter lpmw(leakp_writer, _artifacts, _class_unload);</span>
<span class="line-removed">789   CompositeMethodWriter cmw(&amp;lpmw, &amp;mw);</span>
<span class="line-removed">790   _artifacts-&gt;iterate_klasses(cmw);</span>
<span class="line-removed">791 }</span>
<span class="line-removed">792 static void write_symbols_leakp(JfrCheckpointWriter* leakp_writer, JfrArtifactSet* artifacts, bool class_unload) {</span>
<span class="line-removed">793   assert(leakp_writer != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">794   assert(artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">795   LeakKlassSymbolWriter lpksw(leakp_writer, artifacts, class_unload);</span>
<span class="line-removed">796   artifacts-&gt;iterate_klasses(lpksw);</span>
<span class="line-removed">797 }</span>
<span class="line-removed">798 static void write_symbols(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer, JfrArtifactSet* artifacts, bool class_unload) {</span>
<span class="line-removed">799   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">800   assert(artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">801   if (leakp_writer != NULL) {</span>
<span class="line-removed">802     write_symbols_leakp(leakp_writer, artifacts, class_unload);</span>
803   }
<a name="95" id="anc95"></a><span class="line-modified">804   // iterate all registered symbols</span>
<span class="line-removed">805   SymbolEntryWriter symbol_writer(writer, artifacts, class_unload);</span>
<span class="line-removed">806   artifacts-&gt;iterate_symbols(symbol_writer);</span>
<span class="line-removed">807   CStringEntryWriter cstring_writer(writer, artifacts, class_unload, true); // skip header</span>
<span class="line-removed">808   artifacts-&gt;iterate_cstrings(cstring_writer);</span>
<span class="line-removed">809   symbol_writer.add(cstring_writer.count());</span>
<span class="line-removed">810 }</span>
811 
<a name="96" id="anc96"></a><span class="line-modified">812 bool JfrTypeSet::_class_unload = false;</span>
<span class="line-modified">813 JfrArtifactSet* JfrTypeSet::_artifacts = NULL;</span>
<span class="line-modified">814 JfrArtifactClosure* JfrTypeSet::_subsystem_callback = NULL;</span>


815 
<a name="97" id="anc97"></a><span class="line-modified">816 void JfrTypeSet::write_symbol_constants(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer) {</span>
<span class="line-modified">817   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">818   assert(_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);</span>
<span class="line-modified">819   write_symbols(writer, leakp_writer, _artifacts, _class_unload);</span>
<span class="line-modified">820 }</span>







821 
<a name="98" id="anc98"></a><span class="line-modified">822 void JfrTypeSet::do_unloaded_klass(Klass* klass) {</span>
<span class="line-modified">823   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">824   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">825   if (IS_JDK_JFR_EVENT_SUBKLASS(klass)) {</span>
<span class="line-modified">826     JfrEventClasses::increment_unloaded_event_class();</span>
<span class="line-modified">827   }</span>
<span class="line-modified">828   if (USED_THIS_EPOCH(klass)) { // includes leakp subset</span>
<span class="line-modified">829     _subsystem_callback-&gt;do_artifact(klass);</span>
<span class="line-modified">830     return;</span>
<span class="line-removed">831   }</span>
<span class="line-removed">832   if (klass-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass()) || klass == SystemDictionary::Object_klass()) {</span>
<span class="line-removed">833     SET_LEAKP_USED_THIS_EPOCH(klass); // tag leakp &quot;safe byte&quot; for subset inclusion</span>
<span class="line-removed">834     _subsystem_callback-&gt;do_artifact(klass);</span>
835   }
<a name="99" id="anc99"></a>
836 }
837 
<a name="100" id="anc100"></a><span class="line-modified">838 void JfrTypeSet::do_klass(Klass* klass) {</span>
<span class="line-modified">839   assert(klass != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">840   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">841   if (USED_PREV_EPOCH(klass)) { // includes leakp subset</span>
<span class="line-modified">842     _subsystem_callback-&gt;do_artifact(klass);</span>
<span class="line-removed">843     return;</span>
<span class="line-removed">844   }</span>
<span class="line-removed">845   if (klass-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass()) || klass == SystemDictionary::Object_klass()) {</span>
<span class="line-removed">846     SET_LEAKP_USED_PREV_EPOCH(klass); // tag leakp &quot;safe byte&quot; for subset inclusion</span>
<span class="line-removed">847     _subsystem_callback-&gt;do_artifact(klass);</span>
<span class="line-removed">848   }</span>
849 }
850 
<a name="101" id="anc101"></a><span class="line-modified">851 void JfrTypeSet::do_klasses() {</span>
<span class="line-modified">852   if (_class_unload) {</span>
<span class="line-modified">853     ClassLoaderDataGraph::classes_unloading_do(&amp;do_unloaded_klass);</span>
<span class="line-modified">854     return;</span>
<span class="line-modified">855   }</span>
<span class="line-removed">856   ClassLoaderDataGraph::classes_do(&amp;do_klass);</span>
857 }
858 
<a name="102" id="anc102"></a><span class="line-modified">859 void JfrTypeSet::do_unloaded_package(PackageEntry* entry) {</span>

860   assert(entry != NULL, &quot;invariant&quot;);
<a name="103" id="anc103"></a><span class="line-modified">861   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">862   if (ANY_USED_THIS_EPOCH(entry)) { // includes leakp subset</span>
<span class="line-modified">863     _subsystem_callback-&gt;do_artifact(entry);</span>
<span class="line-modified">864   }</span>
865 }
866 
<a name="104" id="anc104"></a><span class="line-modified">867 void JfrTypeSet::do_package(PackageEntry* entry) {</span>
<span class="line-modified">868   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">869   if (ANY_USED_PREV_EPOCH(entry)) { // includes leakp subset</span>
<span class="line-modified">870     _subsystem_callback-&gt;do_artifact(entry);</span>
<span class="line-modified">871   }</span>
872 }
873 
<a name="105" id="anc105"></a><span class="line-modified">874 void JfrTypeSet::do_packages() {</span>
<span class="line-modified">875   if (_class_unload) {</span>
<span class="line-modified">876     ClassLoaderDataGraph::packages_unloading_do(&amp;do_unloaded_package);</span>
<span class="line-modified">877     return;</span>
<span class="line-removed">878   }</span>
<span class="line-removed">879   ClassLoaderDataGraph::packages_do(&amp;do_package);</span>
880 }
<a name="106" id="anc106"></a><span class="line-modified">881 void JfrTypeSet::do_unloaded_module(ModuleEntry* entry) {</span>


882   assert(entry != NULL, &quot;invariant&quot;);
<a name="107" id="anc107"></a><span class="line-modified">883   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">884   if (ANY_USED_THIS_EPOCH(entry)) { // includes leakp subset</span>
<span class="line-modified">885     _subsystem_callback-&gt;do_artifact(entry);</span>
<span class="line-removed">886   }</span>
887 }
888 
<a name="108" id="anc108"></a><span class="line-modified">889 void JfrTypeSet::do_module(ModuleEntry* entry) {</span>
<span class="line-modified">890   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">891   if (ANY_USED_PREV_EPOCH(entry)) { // includes leakp subset</span>
<span class="line-modified">892     _subsystem_callback-&gt;do_artifact(entry);</span>
<span class="line-modified">893   }</span>
894 }
895 
<a name="109" id="anc109"></a><span class="line-modified">896 void JfrTypeSet::do_modules() {</span>
<span class="line-modified">897   if (_class_unload) {</span>
<span class="line-modified">898     ClassLoaderDataGraph::modules_unloading_do(&amp;do_unloaded_module);</span>






































899     return;
900   }
<a name="110" id="anc110"></a><span class="line-modified">901   ClassLoaderDataGraph::modules_do(&amp;do_module);</span>





902 }
903 
<a name="111" id="anc111"></a><span class="line-modified">904 void JfrTypeSet::do_unloaded_class_loader_data(ClassLoaderData* cld) {</span>
<span class="line-modified">905   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">906   if (ANY_USED_THIS_EPOCH(cld)) { // includes leakp subset</span>
<span class="line-removed">907     _subsystem_callback-&gt;do_artifact(cld);</span>
<span class="line-removed">908   }</span>
<span class="line-removed">909 }</span>
910 
<a name="112" id="anc112"></a><span class="line-modified">911 void JfrTypeSet::do_class_loader_data(ClassLoaderData* cld) {</span>
<span class="line-removed">912   assert(_subsystem_callback != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">913   if (ANY_USED_PREV_EPOCH(cld)) { // includes leakp subset</span>
<span class="line-removed">914     _subsystem_callback-&gt;do_artifact(cld);</span>
<span class="line-removed">915   }</span>
<span class="line-removed">916 }</span>
<span class="line-removed">917 </span>
<span class="line-removed">918 class CLDCallback : public CLDClosure {</span>
<span class="line-removed">919  private:</span>
<span class="line-removed">920   bool _class_unload;</span>
<span class="line-removed">921  public:</span>
<span class="line-removed">922   CLDCallback(bool class_unload) : _class_unload(class_unload) {}</span>
<span class="line-removed">923   void do_cld(ClassLoaderData* cld) {</span>
<span class="line-removed">924      assert(cld != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">925     if (cld-&gt;is_unsafe_anonymous()) {</span>
<span class="line-removed">926       return;</span>
<span class="line-removed">927     }</span>
<span class="line-removed">928     if (_class_unload) {</span>
<span class="line-removed">929       JfrTypeSet::do_unloaded_class_loader_data(cld);</span>
<span class="line-removed">930       return;</span>
<span class="line-removed">931     }</span>
<span class="line-removed">932     JfrTypeSet::do_class_loader_data(cld);</span>
<span class="line-removed">933   }</span>
<span class="line-removed">934 };</span>
935 
<a name="113" id="anc113"></a><span class="line-modified">936 void JfrTypeSet::do_class_loaders() {</span>
<span class="line-modified">937   CLDCallback cld_cb(_class_unload);</span>
<span class="line-modified">938   if (_class_unload) {</span>
<span class="line-removed">939     ClassLoaderDataGraph::cld_unloading_do(&amp;cld_cb);</span>
<span class="line-removed">940     return;</span>
<span class="line-removed">941   }</span>
<span class="line-removed">942   ClassLoaderDataGraph::loaded_cld_do(&amp;cld_cb);</span>
943 }
944 
<a name="114" id="anc114"></a><span class="line-modified">945 static void clear_artifacts(JfrArtifactSet* artifacts,</span>
<span class="line-modified">946                             bool class_unload) {</span>
<span class="line-modified">947   assert(artifacts != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">948   assert(artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);</span>
<span class="line-modified">949 </span>
<span class="line-modified">950   // untag</span>
<span class="line-modified">951   ClearKlassAndMethods clear(class_unload);</span>
<span class="line-modified">952   artifacts-&gt;iterate_klasses(clear);</span>
<span class="line-modified">953   artifacts-&gt;clear();</span>
954 }
955 
<a name="115" id="anc115"></a><span class="line-modified">956 /**</span>
<span class="line-modified">957  * Write all &quot;tagged&quot; (in-use) constant artifacts and their dependencies.</span>
<span class="line-modified">958  */</span>
<span class="line-removed">959 void JfrTypeSet::serialize(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer, bool class_unload) {</span>
<span class="line-removed">960   assert(writer != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">961   ResourceMark rm;</span>
<span class="line-removed">962   // initialization begin</span>
963   _class_unload = class_unload;
<a name="116" id="anc116"></a><span class="line-modified">964   ++checkpoint_id;</span>
965   if (_artifacts == NULL) {
966     _artifacts = new JfrArtifactSet(class_unload);
<a name="117" id="anc117"></a><span class="line-removed">967     _subsystem_callback = NULL;</span>
968   } else {
<a name="118" id="anc118"></a><span class="line-modified">969     _artifacts-&gt;initialize(class_unload);</span>
<span class="line-removed">970     _subsystem_callback = NULL;</span>
971   }
<a name="119" id="anc119"></a>
972   assert(_artifacts != NULL, &quot;invariant&quot;);
973   assert(!_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);
<a name="120" id="anc120"></a><span class="line-modified">974   assert(_subsystem_callback == NULL, &quot;invariant&quot;);</span>
<span class="line-removed">975   // initialization complete</span>
976 
<a name="121" id="anc121"></a>






977   // write order is important because an individual write step
978   // might tag an artifact to be written in a subsequent step
<a name="122" id="anc122"></a><span class="line-modified">979   write_klass_constants(writer, leakp_writer);</span>
<span class="line-modified">980   if (_artifacts-&gt;has_klass_entries()) {</span>
<span class="line-removed">981     write_package_constants(writer, leakp_writer);</span>
<span class="line-removed">982     write_module_constants(writer, leakp_writer);</span>
<span class="line-removed">983     write_class_loader_constants(writer, leakp_writer);</span>
<span class="line-removed">984     write_method_constants(writer, leakp_writer);</span>
<span class="line-removed">985     write_symbol_constants(writer, leakp_writer);</span>
<span class="line-removed">986     clear_artifacts(_artifacts, class_unload);</span>
987   }
<a name="123" id="anc123"></a>


















988 }
<a name="124" id="anc124"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="124" type="hidden" />
</body>
</html>
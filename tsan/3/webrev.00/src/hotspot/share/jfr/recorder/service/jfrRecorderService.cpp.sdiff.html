<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/recorder/service/jfrRecorderService.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="jfrPostBox.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrRecorderService.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/service/jfrRecorderService.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;

 26 #include &quot;jfr/jni/jfrJavaSupport.hpp&quot;

 27 #include &quot;jfr/leakprofiler/checkpoint/objectSampleCheckpoint.hpp&quot;

 28 #include &quot;jfr/recorder/jfrRecorder.hpp&quot;
 29 #include &quot;jfr/recorder/checkpoint/jfrCheckpointManager.hpp&quot;
 30 #include &quot;jfr/recorder/checkpoint/jfrMetadataEvent.hpp&quot;
 31 #include &quot;jfr/recorder/repository/jfrChunkRotation.hpp&quot;
 32 #include &quot;jfr/recorder/repository/jfrChunkWriter.hpp&quot;
 33 #include &quot;jfr/recorder/repository/jfrRepository.hpp&quot;
 34 #include &quot;jfr/recorder/service/jfrPostBox.hpp&quot;
 35 #include &quot;jfr/recorder/service/jfrRecorderService.hpp&quot;
 36 #include &quot;jfr/recorder/stacktrace/jfrStackTraceRepository.hpp&quot;
 37 #include &quot;jfr/recorder/storage/jfrStorage.hpp&quot;
 38 #include &quot;jfr/recorder/storage/jfrStorageControl.hpp&quot;
 39 #include &quot;jfr/recorder/stringpool/jfrStringPool.hpp&quot;
 40 #include &quot;jfr/utilities/jfrAllocation.hpp&quot;
 41 #include &quot;jfr/utilities/jfrTime.hpp&quot;
 42 #include &quot;jfr/writers/jfrJavaEventWriter.hpp&quot;
 43 #include &quot;jfr/utilities/jfrTypes.hpp&quot;
 44 #include &quot;logging/log.hpp&quot;
 45 #include &quot;memory/resourceArea.hpp&quot;
 46 #include &quot;runtime/atomic.hpp&quot;
 47 #include &quot;runtime/handles.inline.hpp&quot;
 48 #include &quot;runtime/mutexLocker.hpp&quot;
<span class="line-removed"> 49 #include &quot;runtime/orderAccess.hpp&quot;</span>
 50 #include &quot;runtime/os.hpp&quot;
 51 #include &quot;runtime/safepoint.hpp&quot;
 52 #include &quot;runtime/thread.inline.hpp&quot;
 53 #include &quot;runtime/vmOperations.hpp&quot;
 54 #include &quot;runtime/vmThread.hpp&quot;
 55 
<span class="line-modified"> 56 // set data iff *dest == NULL</span>
<span class="line-modified"> 57 static bool try_set(void* const data, void** dest, bool clear) {</span>
<span class="line-removed"> 58   assert(data != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 59   const void* const current = OrderAccess::load_acquire(dest);</span>
<span class="line-removed"> 60   if (current != NULL) {</span>
<span class="line-removed"> 61     if (current != data) {</span>
<span class="line-removed"> 62       // already set</span>
<span class="line-removed"> 63       return false;</span>
<span class="line-removed"> 64     }</span>
<span class="line-removed"> 65     assert(current == data, &quot;invariant&quot;);</span>
<span class="line-removed"> 66     if (!clear) {</span>
<span class="line-removed"> 67       // recursion disallowed</span>
<span class="line-removed"> 68       return false;</span>
<span class="line-removed"> 69     }</span>
<span class="line-removed"> 70   }</span>
<span class="line-removed"> 71   return Atomic::cmpxchg(clear ? NULL : data, dest, current) == current;</span>
<span class="line-removed"> 72 }</span>
 73 
<span class="line-modified"> 74 static void* rotation_thread = NULL;</span>
<span class="line-modified"> 75 static const int rotation_try_limit = 1000;</span>
<span class="line-removed"> 76 static const int rotation_retry_sleep_millis = 10;</span>
<span class="line-removed"> 77 </span>
<span class="line-removed"> 78 class RotationLock : public StackObj {</span>
 79  private:
<span class="line-modified"> 80   Thread* const _thread;</span>
<span class="line-modified"> 81   bool _acquired;</span>
<span class="line-modified"> 82 </span>
<span class="line-modified"> 83   void log(bool recursion) {</span>
<span class="line-modified"> 84     assert(!_acquired, &quot;invariant&quot;);</span>
<span class="line-modified"> 85     const char* error_msg = NULL;</span>
<span class="line-modified"> 86     if (recursion) {</span>
<span class="line-removed"> 87       error_msg = &quot;Unable to issue rotation due to recursive calls.&quot;;</span>
<span class="line-removed"> 88     }</span>
<span class="line-removed"> 89     else {</span>
<span class="line-removed"> 90       error_msg = &quot;Unable to issue rotation due to wait timeout.&quot;;</span>
<span class="line-removed"> 91     }</span>
<span class="line-removed"> 92     log_info(jfr)( // For user, should not be &quot;jfr, system&quot;</span>
<span class="line-removed"> 93       &quot;%s&quot;, error_msg);</span>
 94   }











 95  public:
<span class="line-removed"> 96   RotationLock(Thread* thread) : _thread(thread), _acquired(false) {</span>
<span class="line-removed"> 97     assert(_thread != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 98     if (_thread == rotation_thread) {</span>
<span class="line-removed"> 99       // recursion not supported</span>
<span class="line-removed">100       log(true);</span>
<span class="line-removed">101       return;</span>
<span class="line-removed">102     }</span>
103 
<span class="line-modified">104     // limited to not spin indefinitely</span>
<span class="line-modified">105     for (int i = 0; i &lt; rotation_try_limit; ++i) {</span>
<span class="line-modified">106       if (try_set(_thread, &amp;rotation_thread, false)) {</span>
<span class="line-modified">107         _acquired = true;</span>
<span class="line-modified">108         assert(_thread == rotation_thread, &quot;invariant&quot;);</span>
<span class="line-modified">109         return;</span>
<span class="line-modified">110       }</span>
<span class="line-removed">111       if (_thread-&gt;is_Java_thread()) {</span>
<span class="line-removed">112         // in order to allow the system to move to a safepoint</span>
<span class="line-removed">113         MutexLockerEx msg_lock(JfrMsg_lock);</span>
<span class="line-removed">114         JfrMsg_lock-&gt;wait(false, rotation_retry_sleep_millis);</span>
<span class="line-removed">115       }</span>
<span class="line-removed">116       else {</span>
<span class="line-removed">117         os::naked_short_sleep(rotation_retry_sleep_millis);</span>
<span class="line-removed">118       }</span>
<span class="line-removed">119     }</span>
<span class="line-removed">120     log(false);</span>
121   }
122 
<span class="line-modified">123   ~RotationLock() {</span>
<span class="line-modified">124     assert(_thread != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">125     if (_acquired) {</span>
<span class="line-modified">126       assert(_thread == rotation_thread, &quot;invariant&quot;);</span>
<span class="line-modified">127       while (!try_set(_thread, &amp;rotation_thread, true));</span>
<span class="line-modified">128     }</span>











































129   }
<span class="line-removed">130   bool not_acquired() const { return !_acquired; }</span>
131 };
132 
133 static int64_t write_checkpoint_event_prologue(JfrChunkWriter&amp; cw, u8 type_id) {
<span class="line-modified">134   const int64_t prev_cp_offset = cw.previous_checkpoint_offset();</span>
<span class="line-modified">135   const int64_t prev_cp_relative_offset = 0 == prev_cp_offset ? 0 : prev_cp_offset - cw.current_offset();</span>
136   cw.reserve(sizeof(u4));
137   cw.write&lt;u8&gt;(EVENT_CHECKPOINT);
138   cw.write(JfrTicks::now());
<span class="line-modified">139   cw.write((int64_t)0);</span>
<span class="line-modified">140   cw.write(prev_cp_relative_offset); // write previous checkpoint offset delta</span>
<span class="line-modified">141   cw.write&lt;bool&gt;(false); // flushpoint</span>
<span class="line-modified">142   cw.write((u4)1); // nof types in this checkpoint</span>
143   cw.write(type_id);
<span class="line-modified">144   const int64_t number_of_elements_offset = cw.current_offset();</span>
<span class="line-removed">145   cw.reserve(sizeof(u4));</span>
<span class="line-removed">146   return number_of_elements_offset;</span>
147 }
148 
<span class="line-modified">149 template &lt;typename ContentFunctor&gt;</span>
<span class="line-modified">150 class WriteCheckpointEvent : public StackObj {</span>
151  private:
<span class="line-modified">152   JfrChunkWriter&amp; _cw;</span>
<span class="line-removed">153   u8 _type_id;</span>
<span class="line-removed">154   ContentFunctor&amp; _content_functor;</span>
155  public:
<span class="line-modified">156   WriteCheckpointEvent(JfrChunkWriter&amp; cw, u8 type_id, ContentFunctor&amp; functor) :</span>
<span class="line-modified">157     _cw(cw),</span>
<span class="line-modified">158     _type_id(type_id),</span>
<span class="line-removed">159     _content_functor(functor) {</span>
<span class="line-removed">160     assert(_cw.is_valid(), &quot;invariant&quot;);</span>
<span class="line-removed">161   }</span>
162   bool process() {
<span class="line-modified">163     // current_cp_offset is also offset for the event size header field</span>
<span class="line-modified">164     const int64_t current_cp_offset = _cw.current_offset();</span>
<span class="line-removed">165     const int64_t num_elements_offset = write_checkpoint_event_prologue(_cw, _type_id);</span>
<span class="line-removed">166     // invocation</span>
<span class="line-removed">167     _content_functor.process();</span>
<span class="line-removed">168     const u4 number_of_elements = (u4)_content_functor.processed();</span>
<span class="line-removed">169     if (number_of_elements == 0) {</span>
170       // nothing to do, rewind writer to start
<span class="line-modified">171       _cw.seek(current_cp_offset);</span>
<span class="line-modified">172       return true;</span>

173     }
<span class="line-modified">174     assert(number_of_elements &gt; 0, &quot;invariant&quot;);</span>
<span class="line-modified">175     assert(_cw.current_offset() &gt; num_elements_offset, &quot;invariant&quot;);</span>
<span class="line-modified">176     _cw.write_padded_at_offset&lt;u4&gt;(number_of_elements, num_elements_offset);</span>
<span class="line-modified">177     _cw.write_padded_at_offset&lt;u4&gt;((u4)_cw.current_offset() - current_cp_offset, current_cp_offset);</span>
<span class="line-modified">178     // update writer with last checkpoint position</span>
<span class="line-removed">179     _cw.set_previous_checkpoint_offset(current_cp_offset);</span>
180     return true;
181   }
182 };
183 
<span class="line-modified">184 template &lt;typename Instance, size_t(Instance::*func)()&gt;</span>
<span class="line-modified">185 class ServiceFunctor {</span>


















186  private:
<span class="line-modified">187   Instance&amp; _instance;</span>
<span class="line-modified">188   size_t _processed;</span>



189  public:
<span class="line-modified">190   ServiceFunctor(Instance&amp; instance) : _instance(instance), _processed(0) {}</span>

191   bool process() {
<span class="line-modified">192     _processed = (_instance.*func)();</span>
193     return true;
194   }
<span class="line-modified">195   size_t processed() const { return _processed; }</span>

196 };
197 
<span class="line-modified">198 template &lt;typename Instance, void(Instance::*func)()&gt;</span>
<span class="line-modified">199 class JfrVMOperation : public VM_Operation {</span>
<span class="line-modified">200  private:</span>
<span class="line-modified">201   Instance&amp; _instance;</span>
<span class="line-modified">202  public:</span>
<span class="line-modified">203   JfrVMOperation(Instance&amp; instance) : _instance(instance) {}</span>
<span class="line-modified">204   void doit() { (_instance.*func)(); }</span>
<span class="line-modified">205   VMOp_Type type() const { return VMOp_JFRCheckpoint; }</span>
<span class="line-modified">206   Mode evaluation_mode() const { return _safepoint; } // default</span>
<span class="line-modified">207 };</span>




















208 
<span class="line-modified">209 class WriteStackTraceRepository : public StackObj {</span>
































210  private:
<span class="line-removed">211   JfrStackTraceRepository&amp; _repo;</span>
212   JfrChunkWriter&amp; _cw;
<span class="line-removed">213   size_t _elements_processed;</span>
<span class="line-removed">214   bool _clear;</span>
<span class="line-removed">215 </span>
216  public:
<span class="line-modified">217   WriteStackTraceRepository(JfrStackTraceRepository&amp; repo, JfrChunkWriter&amp; cw, bool clear) :</span>
<span class="line-removed">218     _repo(repo), _cw(cw), _elements_processed(0), _clear(clear) {}</span>
219   bool process() {
<span class="line-modified">220     _elements_processed = _repo.write(_cw, _clear);</span>
221     return true;
222   }
<span class="line-modified">223   size_t processed() const { return _elements_processed; }</span>
<span class="line-removed">224   void reset() { _elements_processed = 0; }</span>
225 };
226 
<span class="line-modified">227 static bool recording = false;</span>
228 
<span class="line-modified">229 static void set_recording_state(bool is_recording) {</span>
<span class="line-modified">230   OrderAccess::storestore();</span>
<span class="line-modified">231   recording = is_recording;</span>


232 }
233 
<span class="line-modified">234 bool JfrRecorderService::is_recording() {</span>
<span class="line-modified">235   return recording;</span>



236 }
237 










238 JfrRecorderService::JfrRecorderService() :
239   _checkpoint_manager(JfrCheckpointManager::instance()),
240   _chunkwriter(JfrRepository::chunkwriter()),
241   _repository(JfrRepository::instance()),
242   _stack_trace_repository(JfrStackTraceRepository::instance()),
243   _storage(JfrStorage::instance()),
244   _string_pool(JfrStringPool::instance()) {}
245 





























246 void JfrRecorderService::start() {
<span class="line-modified">247   RotationLock rl(Thread::current());</span>
<span class="line-removed">248   if (rl.not_acquired()) {</span>
<span class="line-removed">249     return;</span>
<span class="line-removed">250   }</span>
<span class="line-removed">251   log_debug(jfr, system)(&quot;Request to START recording&quot;);</span>
252   assert(!is_recording(), &quot;invariant&quot;);
253   clear();
<span class="line-removed">254   set_recording_state(true);</span>
<span class="line-removed">255   assert(is_recording(), &quot;invariant&quot;);</span>
256   open_new_chunk();
<span class="line-modified">257   log_debug(jfr, system)(&quot;Recording STARTED&quot;);</span>







258 }
259 
260 void JfrRecorderService::clear() {
261   ResourceMark rm;
262   HandleMark hm;
263   pre_safepoint_clear();
264   invoke_safepoint_clear();
265   post_safepoint_clear();
266 }
267 
268 void JfrRecorderService::pre_safepoint_clear() {
<span class="line-removed">269   _stack_trace_repository.clear();</span>
270   _string_pool.clear();
271   _storage.clear();

272 }
273 
274 void JfrRecorderService::invoke_safepoint_clear() {
275   JfrVMOperation&lt;JfrRecorderService, &amp;JfrRecorderService::safepoint_clear&gt; safepoint_task(*this);
276   VMThread::execute(&amp;safepoint_task);
277 }
278 
<span class="line-removed">279 //</span>
<span class="line-removed">280 // safepoint clear sequence</span>
<span class="line-removed">281 //</span>
<span class="line-removed">282 //  clear stacktrace repository -&gt;</span>
<span class="line-removed">283 //    clear string pool -&gt;</span>
<span class="line-removed">284 //      clear storage -&gt;</span>
<span class="line-removed">285 //        shift epoch -&gt;</span>
<span class="line-removed">286 //          update time</span>
<span class="line-removed">287 //</span>
288 void JfrRecorderService::safepoint_clear() {
289   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
<span class="line-modified">290   _stack_trace_repository.clear();</span>
291   _string_pool.clear();
292   _storage.clear();
<span class="line-modified">293   _checkpoint_manager.shift_epoch();</span>
<span class="line-modified">294   _chunkwriter.time_stamp_chunk_now();</span>

295 }
296 
297 void JfrRecorderService::post_safepoint_clear() {
298   _checkpoint_manager.clear();
299 }
300 
<span class="line-modified">301 static void stop() {</span>
<span class="line-modified">302   assert(JfrRecorderService::is_recording(), &quot;invariant&quot;);</span>
<span class="line-modified">303   log_debug(jfr, system)(&quot;Recording STOPPED&quot;);</span>
<span class="line-modified">304   set_recording_state(false);</span>
<span class="line-modified">305   assert(!JfrRecorderService::is_recording(), &quot;invariant&quot;);</span>



306 }
307 
<span class="line-modified">308 void JfrRecorderService::rotate(int msgs) {</span>
<span class="line-modified">309   RotationLock rl(Thread::current());</span>
<span class="line-modified">310   if (rl.not_acquired()) {</span>
<span class="line-modified">311     return;</span>
<span class="line-modified">312   }</span>
<span class="line-modified">313   static bool vm_error = false;</span>
<span class="line-modified">314   if (msgs &amp; MSGBIT(MSG_VM_ERROR)) {</span>
<span class="line-modified">315     vm_error = true;</span>
<span class="line-modified">316     prepare_for_vm_error_rotation();</span>
<span class="line-modified">317   }</span>
<span class="line-modified">318   if (msgs &amp; (MSGBIT(MSG_STOP))) {</span>
<span class="line-modified">319     stop();</span>
<span class="line-modified">320   }</span>
<span class="line-modified">321   // action determined by chunkwriter state</span>
<span class="line-modified">322   if (!_chunkwriter.is_valid()) {</span>
<span class="line-modified">323     in_memory_rotation();</span>
<span class="line-modified">324     return;</span>
<span class="line-modified">325   }</span>
<span class="line-modified">326   if (vm_error) {</span>
<span class="line-modified">327     vm_error_rotation();</span>
<span class="line-modified">328     return;</span>







329   }
<span class="line-modified">330   chunk_rotation();</span>



331 }
332 
<span class="line-modified">333 void JfrRecorderService::prepare_for_vm_error_rotation() {</span>







334   if (!_chunkwriter.is_valid()) {
335     open_new_chunk(true);
336   }
<span class="line-modified">337   _checkpoint_manager.register_service_thread(Thread::current());</span>









338 }
339 
<span class="line-modified">340 void JfrRecorderService::open_new_chunk(bool vm_error) {</span>
<span class="line-removed">341   assert(!_chunkwriter.is_valid(), &quot;invariant&quot;);</span>
342   assert(!JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);
<span class="line-modified">343   JfrChunkRotation::on_rotation();</span>
<span class="line-modified">344   MutexLockerEx stream_lock(JfrStream_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">345   if (!_repository.open_chunk(vm_error)) {</span>
<span class="line-modified">346     assert(!_chunkwriter.is_valid(), &quot;invariant&quot;);</span>
<span class="line-modified">347     _storage.control().set_to_disk(false);</span>




348     return;
349   }
<span class="line-modified">350   assert(_chunkwriter.is_valid(), &quot;invariant&quot;);</span>
<span class="line-modified">351   _storage.control().set_to_disk(true);</span>






352 }
353 
354 void JfrRecorderService::in_memory_rotation() {
<span class="line-modified">355   assert(!_chunkwriter.is_valid(), &quot;invariant&quot;);</span>
356   // currently running an in-memory recording

357   open_new_chunk();
358   if (_chunkwriter.is_valid()) {
359     // dump all in-memory buffer data to the newly created chunk
<span class="line-modified">360     serialize_storage_from_in_memory_recording();</span>
361   }
362 }
363 
<span class="line-removed">364 void JfrRecorderService::serialize_storage_from_in_memory_recording() {</span>
<span class="line-removed">365   assert(!JfrStream_lock-&gt;owned_by_self(), &quot;not holding stream lock!&quot;);</span>
<span class="line-removed">366   MutexLockerEx stream_lock(JfrStream_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed">367   _storage.write();</span>
<span class="line-removed">368 }</span>
<span class="line-removed">369 </span>
370 void JfrRecorderService::chunk_rotation() {

371   finalize_current_chunk();
372   open_new_chunk();
373 }
374 
375 void JfrRecorderService::finalize_current_chunk() {
376   assert(_chunkwriter.is_valid(), &quot;invariant&quot;);


377   write();
<span class="line-modified">378   assert(!_chunkwriter.is_valid(), &quot;invariant&quot;);</span>
379 }
380 
381 void JfrRecorderService::write() {
382   ResourceMark rm;
383   HandleMark hm;
384   pre_safepoint_write();
385   invoke_safepoint_write();
386   post_safepoint_write();
387 }
388 
<span class="line-removed">389 typedef ServiceFunctor&lt;JfrStringPool, &amp;JfrStringPool::write&gt; WriteStringPool;</span>
<span class="line-removed">390 typedef ServiceFunctor&lt;JfrStringPool, &amp;JfrStringPool::write_at_safepoint&gt; WriteStringPoolSafepoint;</span>
<span class="line-removed">391 typedef WriteCheckpointEvent&lt;WriteStackTraceRepository&gt; WriteStackTraceCheckpoint;</span>
<span class="line-removed">392 typedef WriteCheckpointEvent&lt;WriteStringPool&gt; WriteStringPoolCheckpoint;</span>
<span class="line-removed">393 typedef WriteCheckpointEvent&lt;WriteStringPoolSafepoint&gt; WriteStringPoolCheckpointSafepoint;</span>
<span class="line-removed">394 </span>
<span class="line-removed">395 static void write_stacktrace_checkpoint(JfrStackTraceRepository&amp; stack_trace_repo, JfrChunkWriter&amp; chunkwriter, bool clear) {</span>
<span class="line-removed">396   WriteStackTraceRepository write_stacktrace_repo(stack_trace_repo, chunkwriter, clear);</span>
<span class="line-removed">397   WriteStackTraceCheckpoint write_stack_trace_checkpoint(chunkwriter, TYPE_STACKTRACE, write_stacktrace_repo);</span>
<span class="line-removed">398   write_stack_trace_checkpoint.process();</span>
<span class="line-removed">399 }</span>
<span class="line-removed">400 </span>
<span class="line-removed">401 static void write_stringpool_checkpoint(JfrStringPool&amp; string_pool, JfrChunkWriter&amp; chunkwriter) {</span>
<span class="line-removed">402   WriteStringPool write_string_pool(string_pool);</span>
<span class="line-removed">403   WriteStringPoolCheckpoint write_string_pool_checkpoint(chunkwriter, TYPE_STRING, write_string_pool);</span>
<span class="line-removed">404   write_string_pool_checkpoint.process();</span>
<span class="line-removed">405 }</span>
<span class="line-removed">406 </span>
<span class="line-removed">407 static void write_stringpool_checkpoint_safepoint(JfrStringPool&amp; string_pool, JfrChunkWriter&amp; chunkwriter) {</span>
<span class="line-removed">408   WriteStringPoolSafepoint write_string_pool(string_pool);</span>
<span class="line-removed">409   WriteStringPoolCheckpointSafepoint write_string_pool_checkpoint(chunkwriter, TYPE_STRING, write_string_pool);</span>
<span class="line-removed">410   write_string_pool_checkpoint.process();</span>
<span class="line-removed">411 }</span>
<span class="line-removed">412 </span>
<span class="line-removed">413 //</span>
<span class="line-removed">414 // pre-safepoint write sequence</span>
<span class="line-removed">415 //</span>
<span class="line-removed">416 //  lock stream lock -&gt;</span>
<span class="line-removed">417 //    write non-safepoint dependent types -&gt;</span>
<span class="line-removed">418 //      write checkpoint epoch transition list-&gt;</span>
<span class="line-removed">419 //        write stack trace checkpoint -&gt;</span>
<span class="line-removed">420 //          write string pool checkpoint -&gt;</span>
<span class="line-removed">421 //            write storage -&gt;</span>
<span class="line-removed">422 //              release stream lock</span>
<span class="line-removed">423 //</span>
424 void JfrRecorderService::pre_safepoint_write() {
<span class="line-removed">425   MutexLockerEx stream_lock(JfrStream_lock, Mutex::_no_safepoint_check_flag);</span>
426   assert(_chunkwriter.is_valid(), &quot;invariant&quot;);
<span class="line-modified">427   _checkpoint_manager.write_types();</span>
<span class="line-modified">428   _checkpoint_manager.write_epoch_transition_mspace();</span>
<span class="line-modified">429   write_stacktrace_checkpoint(_stack_trace_repository, _chunkwriter, false);</span>
<span class="line-modified">430   write_stringpool_checkpoint(_string_pool, _chunkwriter);</span>
<span class="line-modified">431   _storage.write();</span>








432 }
433 
434 void JfrRecorderService::invoke_safepoint_write() {
435   JfrVMOperation&lt;JfrRecorderService, &amp;JfrRecorderService::safepoint_write&gt; safepoint_task(*this);
436   VMThread::execute(&amp;safepoint_task);
437 }
438 
<span class="line-removed">439 static void write_object_sample_stacktrace(JfrStackTraceRepository&amp; stack_trace_repository) {</span>
<span class="line-removed">440   WriteObjectSampleStacktrace object_sample_stacktrace(stack_trace_repository);</span>
<span class="line-removed">441   object_sample_stacktrace.process();</span>
<span class="line-removed">442 }</span>
<span class="line-removed">443 </span>
<span class="line-removed">444 //</span>
<span class="line-removed">445 // safepoint write sequence</span>
<span class="line-removed">446 //</span>
<span class="line-removed">447 //   lock stream lock -&gt;</span>
<span class="line-removed">448 //     write object sample stacktraces -&gt;</span>
<span class="line-removed">449 //       write stacktrace repository -&gt;</span>
<span class="line-removed">450 //         write string pool -&gt;</span>
<span class="line-removed">451 //           write safepoint dependent types -&gt;</span>
<span class="line-removed">452 //             write storage -&gt;</span>
<span class="line-removed">453 //                 shift_epoch -&gt;</span>
<span class="line-removed">454 //                   update time -&gt;</span>
<span class="line-removed">455 //                     lock metadata descriptor -&gt;</span>
<span class="line-removed">456 //                       release stream lock</span>
<span class="line-removed">457 //</span>
458 void JfrRecorderService::safepoint_write() {
459   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
<span class="line-modified">460   MutexLockerEx stream_lock(JfrStream_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">461   write_object_sample_stacktrace(_stack_trace_repository);</span>
<span class="line-modified">462   write_stacktrace_checkpoint(_stack_trace_repository, _chunkwriter, true);</span>
<span class="line-modified">463   write_stringpool_checkpoint_safepoint(_string_pool, _chunkwriter);</span>
<span class="line-modified">464   _checkpoint_manager.write_safepoint_types();</span>


465   _storage.write_at_safepoint();
<span class="line-modified">466   _checkpoint_manager.shift_epoch();</span>
<span class="line-modified">467   _chunkwriter.time_stamp_chunk_now();</span>
<span class="line-modified">468   JfrMetadataEvent::lock();</span>
469 }
470 
<span class="line-removed">471 static int64_t write_metadata_event(JfrChunkWriter&amp; chunkwriter) {</span>
<span class="line-removed">472   assert(chunkwriter.is_valid(), &quot;invariant&quot;);</span>
<span class="line-removed">473   const int64_t metadata_offset = chunkwriter.current_offset();</span>
<span class="line-removed">474   JfrMetadataEvent::write(chunkwriter, metadata_offset);</span>
<span class="line-removed">475   return metadata_offset;</span>
<span class="line-removed">476 }</span>
<span class="line-removed">477 </span>
<span class="line-removed">478 //</span>
<span class="line-removed">479 // post-safepoint write sequence</span>
<span class="line-removed">480 //</span>
<span class="line-removed">481 //  lock stream lock -&gt;</span>
<span class="line-removed">482 //    write type set -&gt;</span>
<span class="line-removed">483 //      write checkpoints -&gt;</span>
<span class="line-removed">484 //        write metadata event -&gt;</span>
<span class="line-removed">485 //          write chunk header -&gt;</span>
<span class="line-removed">486 //            close chunk fd -&gt;</span>
<span class="line-removed">487 //              release stream lock</span>
<span class="line-removed">488 //</span>
489 void JfrRecorderService::post_safepoint_write() {
490   assert(_chunkwriter.is_valid(), &quot;invariant&quot;);

491   // During the safepoint tasks just completed, the system transitioned to a new epoch.
492   // Type tagging is epoch relative which entails we are able to write out the
493   // already tagged artifacts for the previous epoch. We can accomplish this concurrently
494   // with threads now tagging artifacts in relation to the new, now updated, epoch and remain outside of a safepoint.
495   _checkpoint_manager.write_type_set();
<span class="line-modified">496   MutexLockerEx stream_lock(JfrStream_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">497   // serialize any outstanding checkpoint memory</span>
<span class="line-modified">498   _checkpoint_manager.write();</span>


499   // serialize the metadata descriptor event and close out the chunk
<span class="line-modified">500   _repository.close_chunk(write_metadata_event(_chunkwriter));</span>
<span class="line-modified">501   assert(!_chunkwriter.is_valid(), &quot;invariant&quot;);</span>
502 }
503 
<span class="line-modified">504 void JfrRecorderService::vm_error_rotation() {</span>
<span class="line-modified">505   if (_chunkwriter.is_valid()) {</span>
<span class="line-modified">506     finalize_current_chunk_on_vm_error();</span>
<span class="line-modified">507     assert(!_chunkwriter.is_valid(), &quot;invariant&quot;);</span>
<span class="line-modified">508     _repository.on_vm_error();</span>

































509   }







510 }
511 
<span class="line-modified">512 void JfrRecorderService::finalize_current_chunk_on_vm_error() {</span>




513   assert(_chunkwriter.is_valid(), &quot;invariant&quot;);
<span class="line-modified">514   pre_safepoint_write();</span>
<span class="line-modified">515   JfrMetadataEvent::lock();</span>
<span class="line-modified">516   // Do not attempt safepoint dependent operations during emergency dump.</span>
<span class="line-modified">517   // Optimistically write tagged artifacts.</span>
<span class="line-modified">518   _checkpoint_manager.shift_epoch();</span>
<span class="line-modified">519   _checkpoint_manager.write_type_set();</span>
<span class="line-modified">520   // update time</span>
<span class="line-modified">521   _chunkwriter.time_stamp_chunk_now();</span>
<span class="line-modified">522   post_safepoint_write();</span>
<span class="line-modified">523   assert(!_chunkwriter.is_valid(), &quot;invariant&quot;);</span>







524 }
525 
526 void JfrRecorderService::process_full_buffers() {
527   if (_chunkwriter.is_valid()) {
<span class="line-removed">528     assert(!JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-removed">529     MutexLockerEx stream_lock(JfrStream_lock, Mutex::_no_safepoint_check_flag);</span>
530     _storage.write_full();
531   }
532 }
533 
534 void JfrRecorderService::scavenge() {
535   _storage.scavenge();
536 }
537 
538 void JfrRecorderService::evaluate_chunk_size_for_rotation() {
539   JfrChunkRotation::evaluate(_chunkwriter);
540 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
<span class="line-added"> 26 #include &quot;jfrfiles/jfrEventClasses.hpp&quot;</span>
 27 #include &quot;jfr/jni/jfrJavaSupport.hpp&quot;
<span class="line-added"> 28 #include &quot;jfr/leakprofiler/leakProfiler.hpp&quot;</span>
 29 #include &quot;jfr/leakprofiler/checkpoint/objectSampleCheckpoint.hpp&quot;
<span class="line-added"> 30 #include &quot;jfr/leakprofiler/sampling/objectSampler.hpp&quot;</span>
 31 #include &quot;jfr/recorder/jfrRecorder.hpp&quot;
 32 #include &quot;jfr/recorder/checkpoint/jfrCheckpointManager.hpp&quot;
 33 #include &quot;jfr/recorder/checkpoint/jfrMetadataEvent.hpp&quot;
 34 #include &quot;jfr/recorder/repository/jfrChunkRotation.hpp&quot;
 35 #include &quot;jfr/recorder/repository/jfrChunkWriter.hpp&quot;
 36 #include &quot;jfr/recorder/repository/jfrRepository.hpp&quot;
 37 #include &quot;jfr/recorder/service/jfrPostBox.hpp&quot;
 38 #include &quot;jfr/recorder/service/jfrRecorderService.hpp&quot;
 39 #include &quot;jfr/recorder/stacktrace/jfrStackTraceRepository.hpp&quot;
 40 #include &quot;jfr/recorder/storage/jfrStorage.hpp&quot;
 41 #include &quot;jfr/recorder/storage/jfrStorageControl.hpp&quot;
 42 #include &quot;jfr/recorder/stringpool/jfrStringPool.hpp&quot;
 43 #include &quot;jfr/utilities/jfrAllocation.hpp&quot;
 44 #include &quot;jfr/utilities/jfrTime.hpp&quot;
 45 #include &quot;jfr/writers/jfrJavaEventWriter.hpp&quot;
 46 #include &quot;jfr/utilities/jfrTypes.hpp&quot;
 47 #include &quot;logging/log.hpp&quot;
 48 #include &quot;memory/resourceArea.hpp&quot;
 49 #include &quot;runtime/atomic.hpp&quot;
 50 #include &quot;runtime/handles.inline.hpp&quot;
 51 #include &quot;runtime/mutexLocker.hpp&quot;

 52 #include &quot;runtime/os.hpp&quot;
 53 #include &quot;runtime/safepoint.hpp&quot;
 54 #include &quot;runtime/thread.inline.hpp&quot;
 55 #include &quot;runtime/vmOperations.hpp&quot;
 56 #include &quot;runtime/vmThread.hpp&quot;
 57 
<span class="line-modified"> 58 // incremented on each flushpoint</span>
<span class="line-modified"> 59 static u8 flushpoint_id = 0;</span>















 60 
<span class="line-modified"> 61 template &lt;typename Instance, size_t(Instance::*func)()&gt;</span>
<span class="line-modified"> 62 class Content {</span>



 63  private:
<span class="line-modified"> 64   Instance&amp; _instance;</span>
<span class="line-modified"> 65   u4 _elements;</span>
<span class="line-modified"> 66  public:</span>
<span class="line-modified"> 67   Content(Instance&amp; instance) : _instance(instance), _elements(0) {}</span>
<span class="line-modified"> 68   bool process() {</span>
<span class="line-modified"> 69     _elements = (u4)(_instance.*func)();</span>
<span class="line-modified"> 70     return true;</span>







 71   }
<span class="line-added"> 72   u4 elements() const { return _elements; }</span>
<span class="line-added"> 73 };</span>
<span class="line-added"> 74 </span>
<span class="line-added"> 75 template &lt;typename Content&gt;</span>
<span class="line-added"> 76 class WriteContent : public StackObj {</span>
<span class="line-added"> 77  protected:</span>
<span class="line-added"> 78   const JfrTicks _start_time;</span>
<span class="line-added"> 79   JfrTicks _end_time;</span>
<span class="line-added"> 80   JfrChunkWriter&amp; _cw;</span>
<span class="line-added"> 81   Content&amp; _content;</span>
<span class="line-added"> 82   const int64_t _start_offset;</span>
 83  public:







 84 
<span class="line-modified"> 85   WriteContent(JfrChunkWriter&amp; cw, Content&amp; content) :</span>
<span class="line-modified"> 86     _start_time(JfrTicks::now()),</span>
<span class="line-modified"> 87     _end_time(),</span>
<span class="line-modified"> 88     _cw(cw),</span>
<span class="line-modified"> 89     _content(content),</span>
<span class="line-modified"> 90     _start_offset(_cw.current_offset()) {</span>
<span class="line-modified"> 91     assert(_cw.is_valid(), &quot;invariant&quot;);</span>










 92   }
 93 
<span class="line-modified"> 94   bool process() {</span>
<span class="line-modified"> 95     // invocation</span>
<span class="line-modified"> 96     _content.process();</span>
<span class="line-modified"> 97     _end_time = JfrTicks::now();</span>
<span class="line-modified"> 98     return 0 != _content.elements();</span>
<span class="line-modified"> 99   }</span>
<span class="line-added">100 </span>
<span class="line-added">101   const JfrTicks&amp; start_time() const {</span>
<span class="line-added">102     return _start_time;</span>
<span class="line-added">103   }</span>
<span class="line-added">104 </span>
<span class="line-added">105   const JfrTicks&amp; end_time() const {</span>
<span class="line-added">106     return _end_time;</span>
<span class="line-added">107   }</span>
<span class="line-added">108 </span>
<span class="line-added">109   int64_t start_offset() const {</span>
<span class="line-added">110     return _start_offset;</span>
<span class="line-added">111   }</span>
<span class="line-added">112 </span>
<span class="line-added">113   int64_t end_offset() const {</span>
<span class="line-added">114     return current_offset();</span>
<span class="line-added">115   }</span>
<span class="line-added">116 </span>
<span class="line-added">117   int64_t current_offset() const {</span>
<span class="line-added">118     return _cw.current_offset();</span>
<span class="line-added">119   }</span>
<span class="line-added">120 </span>
<span class="line-added">121   u4 elements() const {</span>
<span class="line-added">122     return (u4) _content.elements();</span>
<span class="line-added">123   }</span>
<span class="line-added">124 </span>
<span class="line-added">125   u4 size() const {</span>
<span class="line-added">126     return (u4)(end_offset() - start_offset());</span>
<span class="line-added">127   }</span>
<span class="line-added">128 </span>
<span class="line-added">129   void write_elements(int64_t offset) {</span>
<span class="line-added">130     _cw.write_padded_at_offset&lt;u4&gt;(elements(), offset);</span>
<span class="line-added">131   }</span>
<span class="line-added">132 </span>
<span class="line-added">133   void write_size() {</span>
<span class="line-added">134     _cw.write_padded_at_offset&lt;u4&gt;(size(), start_offset());</span>
<span class="line-added">135   }</span>
<span class="line-added">136 </span>
<span class="line-added">137   void set_last_checkpoint() {</span>
<span class="line-added">138     _cw.set_last_checkpoint_offset(start_offset());</span>
<span class="line-added">139   }</span>
<span class="line-added">140 </span>
<span class="line-added">141   void rewind() {</span>
<span class="line-added">142     _cw.seek(start_offset());</span>
143   }

144 };
145 
146 static int64_t write_checkpoint_event_prologue(JfrChunkWriter&amp; cw, u8 type_id) {
<span class="line-modified">147   const int64_t last_cp_offset = cw.last_checkpoint_offset();</span>
<span class="line-modified">148   const int64_t delta_to_last_checkpoint = 0 == last_cp_offset ? 0 : last_cp_offset - cw.current_offset();</span>
149   cw.reserve(sizeof(u4));
150   cw.write&lt;u8&gt;(EVENT_CHECKPOINT);
151   cw.write(JfrTicks::now());
<span class="line-modified">152   cw.write&lt;u8&gt;(0); // duration</span>
<span class="line-modified">153   cw.write(delta_to_last_checkpoint);</span>
<span class="line-modified">154   cw.write&lt;u4&gt;(GENERIC); // checkpoint type</span>
<span class="line-modified">155   cw.write&lt;u4&gt;(1); // nof types in this checkpoint</span>
156   cw.write(type_id);
<span class="line-modified">157   return cw.reserve(sizeof(u4));</span>


158 }
159 
<span class="line-modified">160 template &lt;typename Content&gt;</span>
<span class="line-modified">161 class WriteCheckpointEvent : public WriteContent&lt;Content&gt; {</span>
162  private:
<span class="line-modified">163   const u8 _type_id;</span>


164  public:
<span class="line-modified">165   WriteCheckpointEvent(JfrChunkWriter&amp; cw, Content&amp; content, u8 type_id) :</span>
<span class="line-modified">166     WriteContent&lt;Content&gt;(cw, content), _type_id(type_id) {}</span>
<span class="line-modified">167 </span>



168   bool process() {
<span class="line-modified">169     const int64_t num_elements_offset = write_checkpoint_event_prologue(this-&gt;_cw, _type_id);</span>
<span class="line-modified">170     if (!WriteContent&lt;Content&gt;::process()) {</span>





171       // nothing to do, rewind writer to start
<span class="line-modified">172       this-&gt;rewind();</span>
<span class="line-modified">173       assert(this-&gt;current_offset() == this-&gt;start_offset(), &quot;invariant&quot;);</span>
<span class="line-added">174       return false;</span>
175     }
<span class="line-modified">176     assert(this-&gt;elements() &gt; 0, &quot;invariant&quot;);</span>
<span class="line-modified">177     assert(this-&gt;current_offset() &gt; num_elements_offset, &quot;invariant&quot;);</span>
<span class="line-modified">178     this-&gt;write_elements(num_elements_offset);</span>
<span class="line-modified">179     this-&gt;write_size();</span>
<span class="line-modified">180     this-&gt;set_last_checkpoint();</span>

181     return true;
182   }
183 };
184 
<span class="line-modified">185 template &lt;typename Functor&gt;</span>
<span class="line-modified">186 static u4 invoke(Functor&amp; f) {</span>
<span class="line-added">187   f.process();</span>
<span class="line-added">188   return f.elements();</span>
<span class="line-added">189 }</span>
<span class="line-added">190 </span>
<span class="line-added">191 template &lt;typename Functor&gt;</span>
<span class="line-added">192 static u4 invoke_with_flush_event(Functor&amp; f) {</span>
<span class="line-added">193   const u4 elements = invoke(f);</span>
<span class="line-added">194   EventFlush e(UNTIMED);</span>
<span class="line-added">195   e.set_starttime(f.start_time());</span>
<span class="line-added">196   e.set_endtime(f.end_time());</span>
<span class="line-added">197   e.set_flushId(flushpoint_id);</span>
<span class="line-added">198   e.set_elements(f.elements());</span>
<span class="line-added">199   e.set_size(f.size());</span>
<span class="line-added">200   e.commit();</span>
<span class="line-added">201   return elements;</span>
<span class="line-added">202 }</span>
<span class="line-added">203 </span>
<span class="line-added">204 class StackTraceRepository : public StackObj {</span>
205  private:
<span class="line-modified">206   JfrStackTraceRepository&amp; _repo;</span>
<span class="line-modified">207   JfrChunkWriter&amp; _cw;</span>
<span class="line-added">208   size_t _elements;</span>
<span class="line-added">209   bool _clear;</span>
<span class="line-added">210 </span>
211  public:
<span class="line-modified">212   StackTraceRepository(JfrStackTraceRepository&amp; repo, JfrChunkWriter&amp; cw, bool clear) :</span>
<span class="line-added">213     _repo(repo), _cw(cw), _elements(0), _clear(clear) {}</span>
214   bool process() {
<span class="line-modified">215     _elements = _repo.write(_cw, _clear);</span>
216     return true;
217   }
<span class="line-modified">218   size_t elements() const { return _elements; }</span>
<span class="line-added">219   void reset() { _elements = 0; }</span>
220 };
221 
<span class="line-modified">222 typedef WriteCheckpointEvent&lt;StackTraceRepository&gt; WriteStackTrace;</span>
<span class="line-modified">223 </span>
<span class="line-modified">224 static u4 flush_stacktrace(JfrStackTraceRepository&amp; stack_trace_repo, JfrChunkWriter&amp; chunkwriter) {</span>
<span class="line-modified">225   StackTraceRepository str(stack_trace_repo, chunkwriter, false);</span>
<span class="line-modified">226   WriteStackTrace wst(chunkwriter, str, TYPE_STACKTRACE);</span>
<span class="line-modified">227   return invoke(wst);</span>
<span class="line-modified">228 }</span>
<span class="line-modified">229 </span>
<span class="line-modified">230 static u4 write_stacktrace(JfrStackTraceRepository&amp; stack_trace_repo, JfrChunkWriter&amp; chunkwriter, bool clear) {</span>
<span class="line-modified">231   StackTraceRepository str(stack_trace_repo, chunkwriter, clear);</span>
<span class="line-added">232   WriteStackTrace wst(chunkwriter, str, TYPE_STACKTRACE);</span>
<span class="line-added">233   return invoke(wst);</span>
<span class="line-added">234 }</span>
<span class="line-added">235 </span>
<span class="line-added">236 typedef Content&lt;JfrStorage, &amp;JfrStorage::write&gt; Storage;</span>
<span class="line-added">237 typedef WriteContent&lt;Storage&gt; WriteStorage;</span>
<span class="line-added">238 </span>
<span class="line-added">239 static size_t flush_storage(JfrStorage&amp; storage, JfrChunkWriter&amp; chunkwriter) {</span>
<span class="line-added">240   assert(chunkwriter.is_valid(), &quot;invariant&quot;);</span>
<span class="line-added">241   Storage fsf(storage);</span>
<span class="line-added">242   WriteStorage fs(chunkwriter, fsf);</span>
<span class="line-added">243   return invoke(fs);</span>
<span class="line-added">244 }</span>
<span class="line-added">245 </span>
<span class="line-added">246 static size_t write_storage(JfrStorage&amp; storage, JfrChunkWriter&amp; chunkwriter) {</span>
<span class="line-added">247   assert(chunkwriter.is_valid(), &quot;invariant&quot;);</span>
<span class="line-added">248   Storage fsf(storage);</span>
<span class="line-added">249   WriteStorage fs(chunkwriter, fsf);</span>
<span class="line-added">250   return invoke(fs);</span>
<span class="line-added">251 }</span>
252 
<span class="line-modified">253 typedef Content&lt;JfrStringPool, &amp;JfrStringPool::write&gt; StringPool;</span>
<span class="line-added">254 typedef Content&lt;JfrStringPool, &amp;JfrStringPool::write_at_safepoint&gt; StringPoolSafepoint;</span>
<span class="line-added">255 typedef WriteCheckpointEvent&lt;StringPool&gt; WriteStringPool;</span>
<span class="line-added">256 typedef WriteCheckpointEvent&lt;StringPoolSafepoint&gt; WriteStringPoolSafepoint;</span>
<span class="line-added">257 </span>
<span class="line-added">258 static u4 flush_stringpool(JfrStringPool&amp; string_pool, JfrChunkWriter&amp; chunkwriter) {</span>
<span class="line-added">259   StringPool sp(string_pool);</span>
<span class="line-added">260   WriteStringPool wsp(chunkwriter, sp, TYPE_STRING);</span>
<span class="line-added">261   return invoke(wsp);</span>
<span class="line-added">262 }</span>
<span class="line-added">263 </span>
<span class="line-added">264 static u4 write_stringpool(JfrStringPool&amp; string_pool, JfrChunkWriter&amp; chunkwriter) {</span>
<span class="line-added">265   StringPool sp(string_pool);</span>
<span class="line-added">266   WriteStringPool wsp(chunkwriter, sp, TYPE_STRING);</span>
<span class="line-added">267   return invoke(wsp);</span>
<span class="line-added">268 }</span>
<span class="line-added">269 </span>
<span class="line-added">270 static u4 write_stringpool_safepoint(JfrStringPool&amp; string_pool, JfrChunkWriter&amp; chunkwriter) {</span>
<span class="line-added">271   StringPoolSafepoint sps(string_pool);</span>
<span class="line-added">272   WriteStringPoolSafepoint wsps(chunkwriter, sps, TYPE_STRING);</span>
<span class="line-added">273   return invoke(wsps);</span>
<span class="line-added">274 }</span>
<span class="line-added">275 </span>
<span class="line-added">276 typedef Content&lt;JfrCheckpointManager, &amp;JfrCheckpointManager::flush_type_set&gt; FlushTypeSetFunctor;</span>
<span class="line-added">277 typedef WriteContent&lt;FlushTypeSetFunctor&gt; FlushTypeSet;</span>
<span class="line-added">278 </span>
<span class="line-added">279 static u4 flush_typeset(JfrCheckpointManager&amp; checkpoint_manager, JfrChunkWriter&amp; chunkwriter) {</span>
<span class="line-added">280   FlushTypeSetFunctor flush_type_set(checkpoint_manager);</span>
<span class="line-added">281   FlushTypeSet fts(chunkwriter, flush_type_set);</span>
<span class="line-added">282   return invoke(fts);</span>
<span class="line-added">283 }</span>
<span class="line-added">284 </span>
<span class="line-added">285 class MetadataEvent : public StackObj {</span>
286  private:

287   JfrChunkWriter&amp; _cw;



288  public:
<span class="line-modified">289   MetadataEvent(JfrChunkWriter&amp; cw) : _cw(cw) {}</span>

290   bool process() {
<span class="line-modified">291     JfrMetadataEvent::write(_cw);</span>
292     return true;
293   }
<span class="line-modified">294   size_t elements() const { return 1; }</span>

295 };
296 
<span class="line-modified">297 typedef WriteContent&lt;MetadataEvent&gt; WriteMetadata;</span>
298 
<span class="line-modified">299 static u4 flush_metadata(JfrChunkWriter&amp; chunkwriter) {</span>
<span class="line-modified">300   assert(chunkwriter.is_valid(), &quot;invariant&quot;);</span>
<span class="line-modified">301   MetadataEvent me(chunkwriter);</span>
<span class="line-added">302   WriteMetadata wm(chunkwriter, me);</span>
<span class="line-added">303   return invoke(wm);</span>
304 }
305 
<span class="line-modified">306 static u4 write_metadata(JfrChunkWriter&amp; chunkwriter) {</span>
<span class="line-modified">307   assert(chunkwriter.is_valid(), &quot;invariant&quot;);</span>
<span class="line-added">308   MetadataEvent me(chunkwriter);</span>
<span class="line-added">309   WriteMetadata wm(chunkwriter, me);</span>
<span class="line-added">310   return invoke(wm);</span>
311 }
312 
<span class="line-added">313 template &lt;typename Instance, void(Instance::*func)()&gt;</span>
<span class="line-added">314 class JfrVMOperation : public VM_Operation {</span>
<span class="line-added">315  private:</span>
<span class="line-added">316   Instance&amp; _instance;</span>
<span class="line-added">317  public:</span>
<span class="line-added">318   JfrVMOperation(Instance&amp; instance) : _instance(instance) {}</span>
<span class="line-added">319   void doit() { (_instance.*func)(); }</span>
<span class="line-added">320   VMOp_Type type() const { return VMOp_JFRCheckpoint; }</span>
<span class="line-added">321 };</span>
<span class="line-added">322 </span>
323 JfrRecorderService::JfrRecorderService() :
324   _checkpoint_manager(JfrCheckpointManager::instance()),
325   _chunkwriter(JfrRepository::chunkwriter()),
326   _repository(JfrRepository::instance()),
327   _stack_trace_repository(JfrStackTraceRepository::instance()),
328   _storage(JfrStorage::instance()),
329   _string_pool(JfrStringPool::instance()) {}
330 
<span class="line-added">331 enum RecorderState {</span>
<span class="line-added">332   STOPPED,</span>
<span class="line-added">333   RUNNING</span>
<span class="line-added">334 };</span>
<span class="line-added">335 </span>
<span class="line-added">336 static RecorderState recorder_state = STOPPED;</span>
<span class="line-added">337 </span>
<span class="line-added">338 static void set_recorder_state(RecorderState from, RecorderState to) {</span>
<span class="line-added">339   assert(from == recorder_state, &quot;invariant&quot;);</span>
<span class="line-added">340   OrderAccess::storestore();</span>
<span class="line-added">341   recorder_state = to;</span>
<span class="line-added">342 }</span>
<span class="line-added">343 </span>
<span class="line-added">344 static void start_recorder() {</span>
<span class="line-added">345   set_recorder_state(STOPPED, RUNNING);</span>
<span class="line-added">346   log_debug(jfr, system)(&quot;Recording service STARTED&quot;);</span>
<span class="line-added">347 }</span>
<span class="line-added">348 </span>
<span class="line-added">349 static void stop_recorder() {</span>
<span class="line-added">350   set_recorder_state(RUNNING, STOPPED);</span>
<span class="line-added">351   log_debug(jfr, system)(&quot;Recording service STOPPED&quot;);</span>
<span class="line-added">352 }</span>
<span class="line-added">353 </span>
<span class="line-added">354 bool JfrRecorderService::is_recording() {</span>
<span class="line-added">355   const bool is_running = recorder_state == RUNNING;</span>
<span class="line-added">356   OrderAccess::loadload();</span>
<span class="line-added">357   return is_running;</span>
<span class="line-added">358 }</span>
<span class="line-added">359 </span>
360 void JfrRecorderService::start() {
<span class="line-modified">361   MutexLocker lock(JfrStream_lock, Mutex::_no_safepoint_check_flag);</span>




362   assert(!is_recording(), &quot;invariant&quot;);
363   clear();


364   open_new_chunk();
<span class="line-modified">365   start_recorder();</span>
<span class="line-added">366   assert(is_recording(), &quot;invariant&quot;);</span>
<span class="line-added">367 }</span>
<span class="line-added">368 </span>
<span class="line-added">369 static void stop() {</span>
<span class="line-added">370   assert(JfrRecorderService::is_recording(), &quot;invariant&quot;);</span>
<span class="line-added">371   stop_recorder();</span>
<span class="line-added">372   assert(!JfrRecorderService::is_recording(), &quot;invariant&quot;);</span>
373 }
374 
375 void JfrRecorderService::clear() {
376   ResourceMark rm;
377   HandleMark hm;
378   pre_safepoint_clear();
379   invoke_safepoint_clear();
380   post_safepoint_clear();
381 }
382 
383 void JfrRecorderService::pre_safepoint_clear() {

384   _string_pool.clear();
385   _storage.clear();
<span class="line-added">386   _stack_trace_repository.clear();</span>
387 }
388 
389 void JfrRecorderService::invoke_safepoint_clear() {
390   JfrVMOperation&lt;JfrRecorderService, &amp;JfrRecorderService::safepoint_clear&gt; safepoint_task(*this);
391   VMThread::execute(&amp;safepoint_task);
392 }
393 









394 void JfrRecorderService::safepoint_clear() {
395   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
<span class="line-modified">396   _checkpoint_manager.begin_epoch_shift();</span>
397   _string_pool.clear();
398   _storage.clear();
<span class="line-modified">399   _chunkwriter.set_time_stamp();</span>
<span class="line-modified">400   _stack_trace_repository.clear();</span>
<span class="line-added">401   _checkpoint_manager.end_epoch_shift();</span>
402 }
403 
404 void JfrRecorderService::post_safepoint_clear() {
405   _checkpoint_manager.clear();
406 }
407 
<span class="line-modified">408 void JfrRecorderService::open_new_chunk(bool vm_error) {</span>
<span class="line-modified">409   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-modified">410   JfrChunkRotation::on_rotation();</span>
<span class="line-modified">411   const bool valid_chunk = _repository.open_chunk(vm_error);</span>
<span class="line-modified">412   _storage.control().set_to_disk(valid_chunk);</span>
<span class="line-added">413   if (valid_chunk) {</span>
<span class="line-added">414     _checkpoint_manager.write_static_type_set_and_threads();</span>
<span class="line-added">415   }</span>
416 }
417 
<span class="line-modified">418 // &#39;rotation_safepoint_pending&#39; is currently only relevant in the unusual case of an emergency dump.</span>
<span class="line-modified">419 // Since the JfrStream_lock must be acquired using _no_safepoint_check,</span>
<span class="line-modified">420 // if the thread running the emergency dump is a JavaThread, a pending safepoint, induced by rotation,</span>
<span class="line-modified">421 // would lead to a deadlock. This deadlock, although unpleasant, is not completely horrendous at this</span>
<span class="line-modified">422 // location because the WatcherThread will terminate the VM after a timeout.</span>
<span class="line-modified">423 // Deadlock avoidance is done not to affect the stability of general VM error reporting.</span>
<span class="line-modified">424 static bool rotation_safepoint_pending = false;</span>
<span class="line-modified">425 </span>
<span class="line-modified">426 static bool is_rotation_safepoint_pending() {</span>
<span class="line-modified">427   return Atomic::load_acquire(&amp;rotation_safepoint_pending);</span>
<span class="line-modified">428 }</span>
<span class="line-modified">429 </span>
<span class="line-modified">430 static void set_rotation_safepoint_pending(bool value) {</span>
<span class="line-modified">431   assert(value ? !is_rotation_safepoint_pending() : is_rotation_safepoint_pending(), &quot;invariant&quot;);</span>
<span class="line-modified">432   Atomic::release_store(&amp;rotation_safepoint_pending, value);</span>
<span class="line-modified">433 }</span>
<span class="line-modified">434 </span>
<span class="line-modified">435 static bool vm_error = false;</span>
<span class="line-modified">436 static const Thread* vm_error_thread = NULL;</span>
<span class="line-modified">437 </span>
<span class="line-modified">438 static bool prepare_for_vm_error_rotation() {</span>
<span class="line-added">439   assert(!JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-added">440   Thread* const t = Thread::current();</span>
<span class="line-added">441   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="line-added">442   if (is_rotation_safepoint_pending() &amp;&amp; t-&gt;is_Java_thread()) {</span>
<span class="line-added">443     // A safepoint is pending, avoid deadlock.</span>
<span class="line-added">444     log_warning(jfr, system)(&quot;Unable to issue successful emergency dump&quot;);</span>
<span class="line-added">445     return false;</span>
446   }
<span class="line-modified">447   vm_error_thread = t;</span>
<span class="line-added">448   vm_error = true;</span>
<span class="line-added">449   OrderAccess::fence();</span>
<span class="line-added">450   return true;</span>
451 }
452 
<span class="line-modified">453 void JfrRecorderService::vm_error_rotation() {</span>
<span class="line-added">454   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-added">455   assert(vm_error, &quot;invariant&quot;);</span>
<span class="line-added">456   Thread* const t = Thread::current();</span>
<span class="line-added">457   if (vm_error_thread != t) {</span>
<span class="line-added">458     return;</span>
<span class="line-added">459   }</span>
<span class="line-added">460   assert(vm_error_thread == t, &quot;invariant&quot;);</span>
461   if (!_chunkwriter.is_valid()) {
462     open_new_chunk(true);
463   }
<span class="line-modified">464   if (_chunkwriter.is_valid()) {</span>
<span class="line-added">465     _checkpoint_manager.register_service_thread(t);</span>
<span class="line-added">466     _storage.flush_regular_buffer(t-&gt;jfr_thread_local()-&gt;native_buffer(), t);</span>
<span class="line-added">467     _chunkwriter.mark_chunk_final();</span>
<span class="line-added">468     invoke_flush();</span>
<span class="line-added">469     _chunkwriter.set_time_stamp();</span>
<span class="line-added">470     _repository.close_chunk();</span>
<span class="line-added">471     assert(!_chunkwriter.is_valid(), &quot;invariant&quot;);</span>
<span class="line-added">472     _repository.on_vm_error();</span>
<span class="line-added">473   }</span>
474 }
475 
<span class="line-modified">476 void JfrRecorderService::rotate(int msgs) {</span>

477   assert(!JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);
<span class="line-modified">478   if (msgs &amp; MSGBIT(MSG_VM_ERROR)) {</span>
<span class="line-modified">479     // emergency dump</span>
<span class="line-modified">480     if (!prepare_for_vm_error_rotation()) {</span>
<span class="line-modified">481       return;</span>
<span class="line-modified">482     }</span>
<span class="line-added">483   }</span>
<span class="line-added">484   MutexLocker lock(JfrStream_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">485   if (vm_error) {</span>
<span class="line-added">486     vm_error_rotation();</span>
487     return;
488   }
<span class="line-modified">489   if (_storage.control().to_disk()) {</span>
<span class="line-modified">490     chunk_rotation();</span>
<span class="line-added">491   } else {</span>
<span class="line-added">492     in_memory_rotation();</span>
<span class="line-added">493   }</span>
<span class="line-added">494   if (msgs &amp; (MSGBIT(MSG_STOP))) {</span>
<span class="line-added">495     stop();</span>
<span class="line-added">496   }</span>
497 }
498 
499 void JfrRecorderService::in_memory_rotation() {
<span class="line-modified">500   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
501   // currently running an in-memory recording
<span class="line-added">502   assert(!_storage.control().to_disk(), &quot;invariant&quot;);</span>
503   open_new_chunk();
504   if (_chunkwriter.is_valid()) {
505     // dump all in-memory buffer data to the newly created chunk
<span class="line-modified">506     write_storage(_storage, _chunkwriter);</span>
507   }
508 }
509 






510 void JfrRecorderService::chunk_rotation() {
<span class="line-added">511   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
512   finalize_current_chunk();
513   open_new_chunk();
514 }
515 
516 void JfrRecorderService::finalize_current_chunk() {
517   assert(_chunkwriter.is_valid(), &quot;invariant&quot;);
<span class="line-added">518   assert(!is_rotation_safepoint_pending(), &quot;invariant&quot;);</span>
<span class="line-added">519   set_rotation_safepoint_pending(true);</span>
520   write();
<span class="line-modified">521   assert(!is_rotation_safepoint_pending(), &quot;invariant&quot;);</span>
522 }
523 
524 void JfrRecorderService::write() {
525   ResourceMark rm;
526   HandleMark hm;
527   pre_safepoint_write();
528   invoke_safepoint_write();
529   post_safepoint_write();
530 }
531 



































532 void JfrRecorderService::pre_safepoint_write() {

533   assert(_chunkwriter.is_valid(), &quot;invariant&quot;);
<span class="line-modified">534   assert(is_rotation_safepoint_pending(), &quot;invariant&quot;);</span>
<span class="line-modified">535   if (LeakProfiler::is_running()) {</span>
<span class="line-modified">536     // Exclusive access to the object sampler instance.</span>
<span class="line-modified">537     // The sampler is released (unlocked) later in post_safepoint_write.</span>
<span class="line-modified">538     ObjectSampleCheckpoint::on_rotation(ObjectSampler::acquire(), _stack_trace_repository);</span>
<span class="line-added">539   }</span>
<span class="line-added">540   if (_string_pool.is_modified()) {</span>
<span class="line-added">541     write_stringpool(_string_pool, _chunkwriter);</span>
<span class="line-added">542   }</span>
<span class="line-added">543   write_storage(_storage, _chunkwriter);</span>
<span class="line-added">544   if (_stack_trace_repository.is_modified()) {</span>
<span class="line-added">545     write_stacktrace(_stack_trace_repository, _chunkwriter, false);</span>
<span class="line-added">546   }</span>
547 }
548 
549 void JfrRecorderService::invoke_safepoint_write() {
550   JfrVMOperation&lt;JfrRecorderService, &amp;JfrRecorderService::safepoint_write&gt; safepoint_task(*this);
551   VMThread::execute(&amp;safepoint_task);
552 }
553 



















554 void JfrRecorderService::safepoint_write() {
555   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
<span class="line-modified">556   assert(is_rotation_safepoint_pending(), &quot;invariant&quot;);</span>
<span class="line-modified">557   set_rotation_safepoint_pending(false);</span>
<span class="line-modified">558   _checkpoint_manager.begin_epoch_shift();</span>
<span class="line-modified">559   if (_string_pool.is_modified()) {</span>
<span class="line-modified">560     write_stringpool_safepoint(_string_pool, _chunkwriter);</span>
<span class="line-added">561   }</span>
<span class="line-added">562   _checkpoint_manager.on_rotation();</span>
563   _storage.write_at_safepoint();
<span class="line-modified">564   _chunkwriter.set_time_stamp();</span>
<span class="line-modified">565   write_stacktrace(_stack_trace_repository, _chunkwriter, true);</span>
<span class="line-modified">566   _checkpoint_manager.end_epoch_shift();</span>
567 }
568 


















569 void JfrRecorderService::post_safepoint_write() {
570   assert(_chunkwriter.is_valid(), &quot;invariant&quot;);
<span class="line-added">571   assert(!is_rotation_safepoint_pending(), &quot;invariant&quot;);</span>
572   // During the safepoint tasks just completed, the system transitioned to a new epoch.
573   // Type tagging is epoch relative which entails we are able to write out the
574   // already tagged artifacts for the previous epoch. We can accomplish this concurrently
575   // with threads now tagging artifacts in relation to the new, now updated, epoch and remain outside of a safepoint.
576   _checkpoint_manager.write_type_set();
<span class="line-modified">577   if (LeakProfiler::is_running()) {</span>
<span class="line-modified">578     // The object sampler instance was exclusively acquired and locked in pre_safepoint_write.</span>
<span class="line-modified">579     // Note: There is a dependency on write_type_set() above, ensure the release is subsequent.</span>
<span class="line-added">580     ObjectSampler::release();</span>
<span class="line-added">581   }</span>
582   // serialize the metadata descriptor event and close out the chunk
<span class="line-modified">583   write_metadata(_chunkwriter);</span>
<span class="line-modified">584   _repository.close_chunk();</span>
585 }
586 
<span class="line-modified">587 static JfrBuffer* thread_local_buffer(Thread* t) {</span>
<span class="line-modified">588   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">589   return t-&gt;jfr_thread_local()-&gt;native_buffer();</span>
<span class="line-modified">590 }</span>
<span class="line-modified">591 </span>
<span class="line-added">592 static void reset_buffer(JfrBuffer* buffer, Thread* t) {</span>
<span class="line-added">593   assert(buffer != NULL, &quot;invariant&quot;);</span>
<span class="line-added">594   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="line-added">595   assert(buffer == thread_local_buffer(t), &quot;invariant&quot;);</span>
<span class="line-added">596   buffer-&gt;set_pos(const_cast&lt;u1*&gt;(buffer-&gt;top()));</span>
<span class="line-added">597 }</span>
<span class="line-added">598 </span>
<span class="line-added">599 static void reset_thread_local_buffer(Thread* t) {</span>
<span class="line-added">600   reset_buffer(thread_local_buffer(t), t);</span>
<span class="line-added">601 }</span>
<span class="line-added">602 </span>
<span class="line-added">603 static void write_thread_local_buffer(JfrChunkWriter&amp; chunkwriter, Thread* t) {</span>
<span class="line-added">604   JfrBuffer * const buffer = thread_local_buffer(t);</span>
<span class="line-added">605   assert(buffer != NULL, &quot;invariant&quot;);</span>
<span class="line-added">606   if (!buffer-&gt;empty()) {</span>
<span class="line-added">607     chunkwriter.write_unbuffered(buffer-&gt;top(), buffer-&gt;pos() - buffer-&gt;top());</span>
<span class="line-added">608     reset_buffer(buffer, t);</span>
<span class="line-added">609   }</span>
<span class="line-added">610 }</span>
<span class="line-added">611 </span>
<span class="line-added">612 size_t JfrRecorderService::flush() {</span>
<span class="line-added">613   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-added">614   size_t total_elements = flush_metadata(_chunkwriter);</span>
<span class="line-added">615   const size_t storage_elements = flush_storage(_storage, _chunkwriter);</span>
<span class="line-added">616   if (0 == storage_elements) {</span>
<span class="line-added">617     return total_elements;</span>
<span class="line-added">618   }</span>
<span class="line-added">619   total_elements += storage_elements;</span>
<span class="line-added">620   if (_string_pool.is_modified()) {</span>
<span class="line-added">621     total_elements += flush_stringpool(_string_pool, _chunkwriter);</span>
<span class="line-added">622   }</span>
<span class="line-added">623   if (_stack_trace_repository.is_modified()) {</span>
<span class="line-added">624     total_elements += flush_stacktrace(_stack_trace_repository, _chunkwriter);</span>
625   }
<span class="line-added">626   if (_checkpoint_manager.is_type_set_required()) {</span>
<span class="line-added">627     total_elements += flush_typeset(_checkpoint_manager, _chunkwriter);</span>
<span class="line-added">628   } else if (_checkpoint_manager.is_static_type_set_required()) {</span>
<span class="line-added">629     // don&#39;t tally this, it is only in order to flush the waiting constants</span>
<span class="line-added">630     _checkpoint_manager.flush_static_type_set();</span>
<span class="line-added">631   }</span>
<span class="line-added">632   return total_elements;</span>
633 }
634 
<span class="line-modified">635 typedef Content&lt;JfrRecorderService, &amp;JfrRecorderService::flush&gt; FlushFunctor;</span>
<span class="line-added">636 typedef WriteContent&lt;FlushFunctor&gt; Flush;</span>
<span class="line-added">637 </span>
<span class="line-added">638 void JfrRecorderService::invoke_flush() {</span>
<span class="line-added">639   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
640   assert(_chunkwriter.is_valid(), &quot;invariant&quot;);
<span class="line-modified">641   Thread* const t = Thread::current();</span>
<span class="line-modified">642   ResourceMark rm(t);</span>
<span class="line-modified">643   HandleMark hm(t);</span>
<span class="line-modified">644   ++flushpoint_id;</span>
<span class="line-modified">645   reset_thread_local_buffer(t);</span>
<span class="line-modified">646   FlushFunctor flushpoint(*this);</span>
<span class="line-modified">647   Flush fl(_chunkwriter, flushpoint);</span>
<span class="line-modified">648   invoke_with_flush_event(fl);</span>
<span class="line-modified">649   write_thread_local_buffer(_chunkwriter, t);</span>
<span class="line-modified">650   _repository.flush_chunk();</span>
<span class="line-added">651 }</span>
<span class="line-added">652 </span>
<span class="line-added">653 void JfrRecorderService::flushpoint() {</span>
<span class="line-added">654   MutexLocker lock(JfrStream_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">655   if (_chunkwriter.is_valid()) {</span>
<span class="line-added">656     invoke_flush();</span>
<span class="line-added">657   }</span>
658 }
659 
660 void JfrRecorderService::process_full_buffers() {
661   if (_chunkwriter.is_valid()) {


662     _storage.write_full();
663   }
664 }
665 
666 void JfrRecorderService::scavenge() {
667   _storage.scavenge();
668 }
669 
670 void JfrRecorderService::evaluate_chunk_size_for_rotation() {
671   JfrChunkRotation::evaluate(_chunkwriter);
672 }
</pre>
</td>
</tr>
</table>
<center><a href="jfrPostBox.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jfrRecorderService.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/support/jfrThreadLocal.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="jfrThreadLocal.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jfrTraceIdExtension.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/support/jfrThreadLocal.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_JFR_SUPPORT_JFRTHREADLOCAL_HPP
 26 #define SHARE_JFR_SUPPORT_JFRTHREADLOCAL_HPP
 27 
<span class="line-modified"> 28 #include &quot;jfr/recorder/checkpoint/jfrCheckpointBlob.hpp&quot;</span>
 29 #include &quot;jfr/utilities/jfrTypes.hpp&quot;
 30 
 31 class JavaThread;
 32 class JfrBuffer;
 33 class JfrStackFrame;
 34 class Thread;
 35 
 36 class JfrThreadLocal {
 37  private:
 38   jobject _java_event_writer;
 39   mutable JfrBuffer* _java_buffer;
 40   mutable JfrBuffer* _native_buffer;
 41   JfrBuffer* _shelved_buffer;
 42   mutable JfrStackFrame* _stackframes;
 43   mutable traceid _trace_id;
<span class="line-modified"> 44   JfrCheckpointBlobHandle _thread_cp;</span>
 45   u8 _data_lost;
 46   traceid _stack_trace_id;
 47   jlong _user_time;
 48   jlong _cpu_time;
 49   jlong _wallclock_time;
 50   unsigned int _stack_trace_hash;
 51   mutable u4 _stackdepth;
 52   volatile jint _entering_suspend_flag;

 53   bool _dead;
 54 
 55   JfrBuffer* install_native_buffer() const;
 56   JfrBuffer* install_java_buffer() const;
 57   JfrStackFrame* install_stackframes() const;
<span class="line-modified"> 58 </span>
 59   static void release(JfrThreadLocal* tl, Thread* t);
 60 
 61  public:
 62   JfrThreadLocal();
 63 
 64   JfrBuffer* native_buffer() const {
 65     return _native_buffer != NULL ? _native_buffer : install_native_buffer();
 66   }
 67 
 68   bool has_native_buffer() const {
 69     return _native_buffer != NULL;
 70   }
 71 
 72   void set_native_buffer(JfrBuffer* buffer) {
 73     _native_buffer = buffer;
 74   }
 75 
 76   JfrBuffer* java_buffer() const {
 77     return _java_buffer != NULL ? _java_buffer : install_java_buffer();
 78   }
</pre>
<hr />
<pre>
 96   bool has_java_event_writer() const {
 97     return _java_event_writer != NULL;
 98   }
 99 
100   jobject java_event_writer() {
101     return _java_event_writer;
102   }
103 
104   void set_java_event_writer(jobject java_event_writer) {
105     _java_event_writer = java_event_writer;
106   }
107 
108   JfrStackFrame* stackframes() const {
109     return _stackframes != NULL ? _stackframes : install_stackframes();
110   }
111 
112   void set_stackframes(JfrStackFrame* frames) {
113     _stackframes = frames;
114   }
115 
<span class="line-modified">116   u4 stackdepth() const {</span>
<span class="line-removed">117     return _stackdepth;</span>
<span class="line-removed">118   }</span>
119 
120   void set_stackdepth(u4 depth) {
121     _stackdepth = depth;
122   }
123 
124   traceid thread_id() const {
125     return _trace_id;
126   }
127 
128   void set_thread_id(traceid thread_id) {
129     _trace_id = thread_id;
130   }
131 
132   void set_cached_stack_trace_id(traceid id, unsigned int hash = 0) {
133     _stack_trace_id = id;
134     _stack_trace_hash = hash;
135   }
136 
137   bool has_cached_stack_trace() const {
138     return _stack_trace_id != max_julong;
</pre>
<hr />
<pre>
188   jlong get_wallclock_time() const {
189     return _wallclock_time;
190   }
191 
192   void set_wallclock_time(jlong wallclock_time) {
193     _wallclock_time = wallclock_time;
194   }
195 
196   traceid trace_id() const {
197     return _trace_id;
198   }
199 
200   traceid* const trace_id_addr() const {
201     return &amp;_trace_id;
202   }
203 
204   void set_trace_id(traceid id) const {
205     _trace_id = id;
206   }
207 




208   bool is_dead() const {
209     return _dead;
210   }
211 
<span class="line-modified">212   bool has_thread_checkpoint() const;</span>
<span class="line-modified">213   void set_thread_checkpoint(const JfrCheckpointBlobHandle&amp; handle);</span>
<span class="line-modified">214   const JfrCheckpointBlobHandle&amp; thread_checkpoint() const;</span>



215 
216   static void on_start(Thread* t);
217   static void on_exit(Thread* t);
218 
219   // Code generation
220   static ByteSize trace_id_offset();
221   static ByteSize java_event_writer_offset();
222 };
223 
224 #endif // SHARE_JFR_SUPPORT_JFRTHREADLOCAL_HPP
</pre>
</td>
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_JFR_SUPPORT_JFRTHREADLOCAL_HPP
 26 #define SHARE_JFR_SUPPORT_JFRTHREADLOCAL_HPP
 27 
<span class="line-modified"> 28 #include &quot;jfr/utilities/jfrBlob.hpp&quot;</span>
 29 #include &quot;jfr/utilities/jfrTypes.hpp&quot;
 30 
 31 class JavaThread;
 32 class JfrBuffer;
 33 class JfrStackFrame;
 34 class Thread;
 35 
 36 class JfrThreadLocal {
 37  private:
 38   jobject _java_event_writer;
 39   mutable JfrBuffer* _java_buffer;
 40   mutable JfrBuffer* _native_buffer;
 41   JfrBuffer* _shelved_buffer;
 42   mutable JfrStackFrame* _stackframes;
 43   mutable traceid _trace_id;
<span class="line-modified"> 44   JfrBlobHandle _thread;</span>
 45   u8 _data_lost;
 46   traceid _stack_trace_id;
 47   jlong _user_time;
 48   jlong _cpu_time;
 49   jlong _wallclock_time;
 50   unsigned int _stack_trace_hash;
 51   mutable u4 _stackdepth;
 52   volatile jint _entering_suspend_flag;
<span class="line-added"> 53   bool _excluded;</span>
 54   bool _dead;
 55 
 56   JfrBuffer* install_native_buffer() const;
 57   JfrBuffer* install_java_buffer() const;
 58   JfrStackFrame* install_stackframes() const;
<span class="line-modified"> 59   void release(Thread* t);</span>
 60   static void release(JfrThreadLocal* tl, Thread* t);
 61 
 62  public:
 63   JfrThreadLocal();
 64 
 65   JfrBuffer* native_buffer() const {
 66     return _native_buffer != NULL ? _native_buffer : install_native_buffer();
 67   }
 68 
 69   bool has_native_buffer() const {
 70     return _native_buffer != NULL;
 71   }
 72 
 73   void set_native_buffer(JfrBuffer* buffer) {
 74     _native_buffer = buffer;
 75   }
 76 
 77   JfrBuffer* java_buffer() const {
 78     return _java_buffer != NULL ? _java_buffer : install_java_buffer();
 79   }
</pre>
<hr />
<pre>
 97   bool has_java_event_writer() const {
 98     return _java_event_writer != NULL;
 99   }
100 
101   jobject java_event_writer() {
102     return _java_event_writer;
103   }
104 
105   void set_java_event_writer(jobject java_event_writer) {
106     _java_event_writer = java_event_writer;
107   }
108 
109   JfrStackFrame* stackframes() const {
110     return _stackframes != NULL ? _stackframes : install_stackframes();
111   }
112 
113   void set_stackframes(JfrStackFrame* frames) {
114     _stackframes = frames;
115   }
116 
<span class="line-modified">117   u4 stackdepth() const;</span>


118 
119   void set_stackdepth(u4 depth) {
120     _stackdepth = depth;
121   }
122 
123   traceid thread_id() const {
124     return _trace_id;
125   }
126 
127   void set_thread_id(traceid thread_id) {
128     _trace_id = thread_id;
129   }
130 
131   void set_cached_stack_trace_id(traceid id, unsigned int hash = 0) {
132     _stack_trace_id = id;
133     _stack_trace_hash = hash;
134   }
135 
136   bool has_cached_stack_trace() const {
137     return _stack_trace_id != max_julong;
</pre>
<hr />
<pre>
187   jlong get_wallclock_time() const {
188     return _wallclock_time;
189   }
190 
191   void set_wallclock_time(jlong wallclock_time) {
192     _wallclock_time = wallclock_time;
193   }
194 
195   traceid trace_id() const {
196     return _trace_id;
197   }
198 
199   traceid* const trace_id_addr() const {
200     return &amp;_trace_id;
201   }
202 
203   void set_trace_id(traceid id) const {
204     _trace_id = id;
205   }
206 
<span class="line-added">207   bool is_excluded() const {</span>
<span class="line-added">208     return _excluded;</span>
<span class="line-added">209   }</span>
<span class="line-added">210 </span>
211   bool is_dead() const {
212     return _dead;
213   }
214 
<span class="line-modified">215   bool has_thread_blob() const;</span>
<span class="line-modified">216   void set_thread_blob(const JfrBlobHandle&amp; handle);</span>
<span class="line-modified">217   const JfrBlobHandle&amp; thread_blob() const;</span>
<span class="line-added">218 </span>
<span class="line-added">219   static void exclude(Thread* t);</span>
<span class="line-added">220   static void include(Thread* t);</span>
221 
222   static void on_start(Thread* t);
223   static void on_exit(Thread* t);
224 
225   // Code generation
226   static ByteSize trace_id_offset();
227   static ByteSize java_event_writer_offset();
228 };
229 
230 #endif // SHARE_JFR_SUPPORT_JFRTHREADLOCAL_HPP
</pre>
</td>
</tr>
</table>
<center><a href="jfrThreadLocal.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jfrTraceIdExtension.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
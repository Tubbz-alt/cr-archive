<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/jfr/utilities/jfrRefCountPointer.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_JFR_UTILITIES_JFRREFCOUNTPOINTER_HPP
 26 #define SHARE_JFR_UTILITIES_JFRREFCOUNTPOINTER_HPP
 27 
 28 #include &quot;jfr/utilities/jfrAllocation.hpp&quot;
 29 #include &quot;runtime/atomic.hpp&quot;
 30 
 31 template &lt;typename T&gt;
 32 class RefCountHandle {
 33   template &lt;typename, typename&gt;
 34   friend class RefCountPointer;
 35  private:
 36   const T* _ptr;
 37 
 38   RefCountHandle(const T* ptr) : _ptr(ptr) {
 39     assert(_ptr != NULL, &quot;invariant&quot;);
 40     _ptr-&gt;add_ref();
 41   }
 42 
 43  public:
 44   RefCountHandle() : _ptr(NULL) {}
 45 
 46   RefCountHandle(const RefCountHandle&lt;T&gt;&amp; rhs) : _ptr(rhs._ptr) {
 47     if (_ptr != NULL) {
 48       _ptr-&gt;add_ref();
 49     }
 50   }
 51 
 52   ~RefCountHandle() {
 53     if (_ptr != NULL) {
 54       const T* temp = _ptr;
 55       _ptr = NULL;
 56       temp-&gt;remove_ref();
 57     }
 58   }
 59 
 60   // The copy-and-swap idiom upholds reference counting semantics
 61   void operator=(RefCountHandle&lt;T&gt; rhs) {
 62     const T* temp = rhs._ptr;
 63     rhs._ptr = _ptr;
 64     _ptr = temp;
 65   }
 66 
 67   bool operator==(const RefCountHandle&lt;T&gt;&amp; rhs) const {
 68     return _ptr == rhs._ptr;
 69   }
 70 
 71   bool operator!=(const RefCountHandle&lt;T&gt;&amp; rhs) const {
 72     return !operator==(rhs);
 73   }
 74 
 75   bool valid() const {
 76     return _ptr != NULL;
 77   }
 78 
 79   const T &amp; operator-&gt;() const {
 80     return *_ptr;
 81   }
 82 
 83   T&amp; operator-&gt;() {
 84     return *const_cast&lt;T*&gt;(_ptr);
 85   }
 86 };
 87 
 88 class MultiThreadedRefCounter {
 89  private:
 90   mutable volatile int _refs;
 91  public:
 92   MultiThreadedRefCounter() : _refs(0) {}
 93 
 94   void inc() const {
 95     Atomic::add(1, &amp;_refs);
 96   }
 97 
 98   bool dec() const {
 99     return 0 == Atomic::add((-1), &amp;_refs);
100   }
101 
102   int current() const {
103    return _refs;
104   }
105 };
106 
107 template &lt;typename T, typename RefCountImpl = MultiThreadedRefCounter&gt;
108 class RefCountPointer : public JfrCHeapObj {
109   template &lt;typename&gt;
110   friend class RefCountHandle;
111   typedef RefCountHandle&lt;RefCountPointer&lt;T, RefCountImpl&gt; &gt; RefHandle;
112  private:
113   const T* _ptr;
114   mutable RefCountImpl _refs;
115 
116   // disallow multiple copies
117   RefCountPointer(const RefCountPointer&lt;T, RefCountImpl&gt;&amp; rhs);
118   void operator=(const RefCountPointer&lt;T, RefCountImpl&gt;&amp; rhs);
119 
120   ~RefCountPointer() {
121     assert(_refs.current() == 0, &quot;invariant&quot;);
122     delete const_cast&lt;T*&gt;(_ptr);
123   }
124 
125   void add_ref() const {
126     _refs.inc();
127   }
128 
129   void remove_ref() const {
130     if (_refs.dec()) {
131       delete this;
132     }
133   }
134 
135   RefCountPointer(const T* ptr) : _ptr(ptr), _refs() {
136     assert(_ptr != NULL, &quot;invariant&quot;);
137   }
138 
139  public:
140   const T* operator-&gt;() const {
141     return _ptr;
142   }
143 
144   T* operator-&gt;() {
145     return const_cast&lt;T*&gt;(_ptr);
146   }
147 
148   static RefHandle make(const T* ptr) {
149     assert(ptr != NULL, &quot;invariant&quot;);
150     return RefHandle(new RefCountPointer&lt;T, RefCountImpl&gt;(ptr));
151   }
152 };
153 
154 #endif // SHARE_JFR_UTILITIES_JFRREFCOUNTPOINTER_HPP
    </pre>
  </body>
</html>
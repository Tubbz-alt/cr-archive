<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/utilities/jfrDoublyLinkedList.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="jfrAllocation.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jfrHashtable.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/utilities/jfrDoublyLinkedList.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 31 class JfrDoublyLinkedList {
 32  private:
 33   T* _head;
 34   T* _tail;
 35   size_t _count;
 36 
 37   T** list_head() { return &amp;_head; }
 38   T** list_tail() { return &amp;_tail; }
 39 
 40  public:
 41   typedef T Node;
 42   JfrDoublyLinkedList() : _head(NULL), _tail(NULL), _count(0) {}
 43   T* head() const { return _head; }
 44   T* tail() const { return _tail; }
 45   size_t count() const { return _count; }
 46   T* clear(bool return_tail = false);
 47   T* remove(T* const node);
 48   void prepend(T* const node);
 49   void append(T* const node);
 50   void append_list(T* const head_node, T* const tail_node, size_t count);
<span class="line-modified"> 51   debug_only(bool in_list(const T* const target_node) const;)</span>
<span class="line-modified"> 52   debug_only(bool locate(const T* start_node, const T* const target_node) const;)</span>
 53 };
 54 
 55 template &lt;typename T&gt;
 56 inline void JfrDoublyLinkedList&lt;T&gt;::prepend(T* const node) {
 57   assert(node != NULL, &quot;invariant&quot;);
 58   node-&gt;set_prev(NULL);
 59   assert(!in_list(node), &quot;already in list error&quot;);
 60   T** lh = list_head();
 61   if (*lh != NULL) {
 62     (*lh)-&gt;set_prev(node);
 63     node-&gt;set_next(*lh);
 64   } else {
 65     T** lt = list_tail();
 66     assert(*lt == NULL, &quot;invariant&quot;);
 67     *lt = node;
 68     node-&gt;set_next(NULL);
 69     assert(tail() == node, &quot;invariant&quot;);
 70     assert(node-&gt;next() == NULL, &quot;invariant&quot;);
 71   }
 72   *lh = node;
</pre>
<hr />
<pre>
136   }
137   --_count;
138   assert(_count &gt;= 0, &quot;invariant&quot;);
139   assert(!in_list(node), &quot;still in list error&quot;);
140   return node;
141 }
142 
143 template &lt;typename T&gt;
144 T* JfrDoublyLinkedList&lt;T&gt;::clear(bool return_tail /* false */) {
145   T* const node = return_tail ? tail() : head();
146   T** l = list_head();
147   *l = NULL;
148   l = list_tail();
149   *l = NULL;
150   _count = 0;
151   assert(head() == NULL, &quot;invariant&quot;);
152   assert(tail() == NULL, &quot;invariant&quot;);
153   return node;
154 }
155 
<span class="line-removed">156 #ifdef ASSERT</span>
157 template &lt;typename T&gt;
158 bool JfrDoublyLinkedList&lt;T&gt;::locate(const T* node, const T* const target) const {
159   assert(target != NULL, &quot;invariant&quot;);
160   while (node != NULL) {
161     if (node == target) {
162       return true;
163     }
164     node = (T*)node-&gt;next();
165   }
166   return false;
167 }
168 
169 template &lt;typename T&gt;
170 bool JfrDoublyLinkedList&lt;T&gt;::in_list(const T* const target) const {
171   assert(target != NULL, &quot;invariant&quot;);
172   return locate(head(), target);
173 }
174 
175 template &lt;typename T&gt;
176 inline void validate_count_param(T* node, size_t count_param) {
177   assert(node != NULL, &quot;invariant&quot;);
178   size_t count = 0;
179   while (node) {
180     ++count;
181     node = (T*)node-&gt;next();
182   }
183   assert(count_param == count, &quot;invariant&quot;);
184 }
<span class="line-removed">185 #endif // ASSERT</span>
186 
187 template &lt;typename T&gt;
188 void JfrDoublyLinkedList&lt;T&gt;::append_list(T* const head_node, T* const tail_node, size_t count) {
189   assert(head_node != NULL, &quot;invariant&quot;);
190   assert(!in_list(head_node), &quot;already in list error&quot;);
191   assert(tail_node != NULL, &quot;invariant&quot;);
192   assert(!in_list(tail_node), &quot;already in list error&quot;);
193   assert(tail_node-&gt;next() == NULL, &quot;invariant&quot;);
194   // ensure passed in list nodes are connected
195   assert(locate(head_node, tail_node), &quot;invariant&quot;);
196   T** lt = list_tail();
197   if (*lt != NULL) {
198     head_node-&gt;set_prev(*lt);
199     (*lt)-&gt;set_next(head_node);
200   } else {
201     // no head
202     assert(*lt == NULL, &quot;invariant&quot;);
203     T** lh = list_head();
204     assert(*lh == NULL, &quot;invariant&quot;);
205     head_node-&gt;set_prev(NULL);
</pre>
</td>
<td>
<hr />
<pre>
 31 class JfrDoublyLinkedList {
 32  private:
 33   T* _head;
 34   T* _tail;
 35   size_t _count;
 36 
 37   T** list_head() { return &amp;_head; }
 38   T** list_tail() { return &amp;_tail; }
 39 
 40  public:
 41   typedef T Node;
 42   JfrDoublyLinkedList() : _head(NULL), _tail(NULL), _count(0) {}
 43   T* head() const { return _head; }
 44   T* tail() const { return _tail; }
 45   size_t count() const { return _count; }
 46   T* clear(bool return_tail = false);
 47   T* remove(T* const node);
 48   void prepend(T* const node);
 49   void append(T* const node);
 50   void append_list(T* const head_node, T* const tail_node, size_t count);
<span class="line-modified"> 51   bool in_list(const T* const target_node) const;</span>
<span class="line-modified"> 52   bool locate(const T* start_node, const T* const target_node) const;</span>
 53 };
 54 
 55 template &lt;typename T&gt;
 56 inline void JfrDoublyLinkedList&lt;T&gt;::prepend(T* const node) {
 57   assert(node != NULL, &quot;invariant&quot;);
 58   node-&gt;set_prev(NULL);
 59   assert(!in_list(node), &quot;already in list error&quot;);
 60   T** lh = list_head();
 61   if (*lh != NULL) {
 62     (*lh)-&gt;set_prev(node);
 63     node-&gt;set_next(*lh);
 64   } else {
 65     T** lt = list_tail();
 66     assert(*lt == NULL, &quot;invariant&quot;);
 67     *lt = node;
 68     node-&gt;set_next(NULL);
 69     assert(tail() == node, &quot;invariant&quot;);
 70     assert(node-&gt;next() == NULL, &quot;invariant&quot;);
 71   }
 72   *lh = node;
</pre>
<hr />
<pre>
136   }
137   --_count;
138   assert(_count &gt;= 0, &quot;invariant&quot;);
139   assert(!in_list(node), &quot;still in list error&quot;);
140   return node;
141 }
142 
143 template &lt;typename T&gt;
144 T* JfrDoublyLinkedList&lt;T&gt;::clear(bool return_tail /* false */) {
145   T* const node = return_tail ? tail() : head();
146   T** l = list_head();
147   *l = NULL;
148   l = list_tail();
149   *l = NULL;
150   _count = 0;
151   assert(head() == NULL, &quot;invariant&quot;);
152   assert(tail() == NULL, &quot;invariant&quot;);
153   return node;
154 }
155 

156 template &lt;typename T&gt;
157 bool JfrDoublyLinkedList&lt;T&gt;::locate(const T* node, const T* const target) const {
158   assert(target != NULL, &quot;invariant&quot;);
159   while (node != NULL) {
160     if (node == target) {
161       return true;
162     }
163     node = (T*)node-&gt;next();
164   }
165   return false;
166 }
167 
168 template &lt;typename T&gt;
169 bool JfrDoublyLinkedList&lt;T&gt;::in_list(const T* const target) const {
170   assert(target != NULL, &quot;invariant&quot;);
171   return locate(head(), target);
172 }
173 
174 template &lt;typename T&gt;
175 inline void validate_count_param(T* node, size_t count_param) {
176   assert(node != NULL, &quot;invariant&quot;);
177   size_t count = 0;
178   while (node) {
179     ++count;
180     node = (T*)node-&gt;next();
181   }
182   assert(count_param == count, &quot;invariant&quot;);
183 }

184 
185 template &lt;typename T&gt;
186 void JfrDoublyLinkedList&lt;T&gt;::append_list(T* const head_node, T* const tail_node, size_t count) {
187   assert(head_node != NULL, &quot;invariant&quot;);
188   assert(!in_list(head_node), &quot;already in list error&quot;);
189   assert(tail_node != NULL, &quot;invariant&quot;);
190   assert(!in_list(tail_node), &quot;already in list error&quot;);
191   assert(tail_node-&gt;next() == NULL, &quot;invariant&quot;);
192   // ensure passed in list nodes are connected
193   assert(locate(head_node, tail_node), &quot;invariant&quot;);
194   T** lt = list_tail();
195   if (*lt != NULL) {
196     head_node-&gt;set_prev(*lt);
197     (*lt)-&gt;set_next(head_node);
198   } else {
199     // no head
200     assert(*lt == NULL, &quot;invariant&quot;);
201     T** lh = list_head();
202     assert(*lh == NULL, &quot;invariant&quot;);
203     head_node-&gt;set_prev(NULL);
</pre>
</td>
</tr>
</table>
<center><a href="jfrAllocation.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jfrHashtable.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
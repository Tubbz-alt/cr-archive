<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/utilities/jfrHashtable.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="jfrDoublyLinkedList.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jfrJavaLog.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/utilities/jfrHashtable.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_JFR_UTILITIES_JFRHASHTABLE_HPP
 26 #define SHARE_JFR_UTILITIES_JFRHASHTABLE_HPP
 27 
<span class="line-modified"> 28 #include &quot;memory/allocation.inline.hpp&quot;</span>
<span class="line-modified"> 29 #include &quot;runtime/orderAccess.hpp&quot;</span>
 30 #include &quot;utilities/debug.hpp&quot;
 31 #include &quot;utilities/macros.hpp&quot;
 32 
 33 template &lt;typename T&gt;
<span class="line-modified"> 34 class JfrBasicHashtableEntry {</span>
 35  private:
 36   typedef JfrBasicHashtableEntry&lt;T&gt; Entry;
 37   Entry* _next;
 38   T _literal;          // ref to item in table.
 39   uintptr_t _hash;
 40 
 41  public:

 42   uintptr_t hash() const { return _hash; }
<span class="line-removed"> 43   void set_hash(uintptr_t hash) { _hash = hash; }</span>
 44   T literal() const { return _literal; }
 45   T* literal_addr() { return &amp;_literal; }
 46   void set_literal(T s) { _literal = s; }
 47   void set_next(Entry* next) { _next = next; }
 48   Entry* next() const { return _next; }
 49   Entry** next_addr() { return &amp;_next; }
 50 };
 51 
 52 template &lt;typename T&gt;
 53 class JfrHashtableBucket : public CHeapObj&lt;mtTracing&gt; {
 54   template &lt;typename&gt;
 55   friend class JfrBasicHashtable;
 56  private:
 57   typedef JfrBasicHashtableEntry&lt;T&gt; TableEntry;
 58   TableEntry* _entry;
 59 
 60   TableEntry* get_entry() const {
<span class="line-modified"> 61     return (TableEntry*)OrderAccess::load_acquire(&amp;_entry);</span>
 62   }
<span class="line-modified"> 63   void set_entry(TableEntry* entry) { OrderAccess::release_store(&amp;_entry, entry);}</span>
 64   TableEntry** entry_addr() { return &amp;_entry; }
 65 };
 66 
 67 template &lt;typename T&gt;
 68 class JfrBasicHashtable : public CHeapObj&lt;mtTracing&gt; {
 69  private:
 70   typedef JfrHashtableBucket&lt;T&gt; Bucket;
 71   typedef JfrBasicHashtableEntry&lt;T&gt; TableEntry;
 72   Bucket* _buckets;
 73   uintptr_t _table_size;
 74   const size_t _entry_size;
 75   size_t _number_of_entries;
 76 
 77  protected:
 78   JfrBasicHashtable(uintptr_t table_size, size_t entry_size) :
 79     _buckets(NULL), _table_size(table_size), _entry_size(entry_size), _number_of_entries(0) {
 80     _buckets = NEW_C_HEAP_ARRAY2(Bucket, table_size, mtTracing, CURRENT_PC);
 81     memset((void*)_buckets, 0, table_size * sizeof(Bucket));
 82   }
 83 
 84   size_t hash_to_index(uintptr_t full_hash) const {
 85     const uintptr_t h = full_hash % _table_size;
 86     assert(h &gt;= 0 &amp;&amp; h &lt; _table_size, &quot;Illegal hash value&quot;);
 87     return (size_t)h;
 88   }
 89   size_t entry_size() const { return _entry_size; }
 90   void unlink_entry(TableEntry* entry) {
 91     entry-&gt;set_next(NULL);
 92     --_number_of_entries;
 93   }
 94   void free_buckets() {
<span class="line-modified"> 95     if (NULL != _buckets) {</span>
<span class="line-removed"> 96       FREE_C_HEAP_ARRAY(Bucket, _buckets);</span>
<span class="line-removed"> 97       _buckets = NULL;</span>
<span class="line-removed"> 98     }</span>
 99   }
100   TableEntry* bucket(size_t i) { return _buckets[i].get_entry();}
101   TableEntry** bucket_addr(size_t i) { return _buckets[i].entry_addr(); }
102   uintptr_t table_size() const { return _table_size; }
103   size_t number_of_entries() const { return _number_of_entries; }
104   void add_entry(size_t index, TableEntry* entry) {
105     assert(entry != NULL, &quot;invariant&quot;);
106     entry-&gt;set_next(bucket(index));
107     _buckets[index].set_entry(entry);
108     ++_number_of_entries;
109   }
110 };
111 
112 template &lt;typename IdType, typename Entry, typename T&gt;
<span class="line-modified">113 class AscendingId : public CHeapObj&lt;mtTracing&gt;  {</span>
114  private:
115   IdType _id;
116  public:
117   AscendingId() : _id(0) {}
118   // callbacks
<span class="line-modified">119   void assign_id(Entry* entry) {</span>
120     assert(entry != NULL, &quot;invariant&quot;);
121     assert(entry-&gt;id() == 0, &quot;invariant&quot;);
122     entry-&gt;set_id(++_id);
123   }
<span class="line-modified">124   bool equals(const T&amp; data, uintptr_t hash, const Entry* entry) {</span>
125     assert(entry-&gt;hash() == hash, &quot;invariant&quot;);
126     return true;
127   }
128 };
129 
130 // IdType must be scalar
131 template &lt;typename T, typename IdType&gt;
<span class="line-modified">132 class Entry : public JfrBasicHashtableEntry&lt;T&gt; {</span>
133  public:

134   typedef IdType ID;
<span class="line-removed">135   void init() { _id = 0; }</span>
136   ID id() const { return _id; }
<span class="line-modified">137   void set_id(ID id) { _id = id; }</span>
<span class="line-modified">138   void set_value(const T&amp; value) { this-&gt;set_literal(value); }</span>
<span class="line-modified">139   T&amp; value() const { return *const_cast&lt;Entry*&gt;(this)-&gt;literal_addr();}</span>
<span class="line-removed">140   const T* value_addr() const { return const_cast&lt;Entry*&gt;(this)-&gt;literal_addr(); }</span>
<span class="line-removed">141 </span>
142  private:
<span class="line-modified">143   ID _id;</span>
144 };
145 
146 template &lt;typename T, typename IdType, template &lt;typename, typename&gt; class Entry,
147           typename Callback = AscendingId&lt;IdType, Entry&lt;T, IdType&gt;, T&gt; ,
148           size_t TABLE_SIZE = 1009&gt;
149 class HashTableHost : public JfrBasicHashtable&lt;T&gt; {
150  public:
151   typedef Entry&lt;T, IdType&gt; HashEntry;
<span class="line-modified">152   HashTableHost() : _callback(new Callback()) {}</span>
<span class="line-modified">153   HashTableHost(Callback* cb) : JfrBasicHashtable&lt;T&gt;(TABLE_SIZE, sizeof(HashEntry)), _callback(cb) {}</span>
154   ~HashTableHost() {
155     this-&gt;clear_entries();
156     this-&gt;free_buckets();
157   }
158 
159   // direct insert assumes non-existing entry
<span class="line-modified">160   HashEntry&amp; put(const T&amp; data, uintptr_t hash);</span>
161 
162   // lookup entry, will put if not found
<span class="line-modified">163   HashEntry&amp; lookup_put(const T&amp; data, uintptr_t hash) {</span>
<span class="line-modified">164     HashEntry* entry = lookup_only(data, hash);</span>
<span class="line-modified">165     return entry == NULL ? put(data, hash) : *entry;</span>
166   }
167 
<span class="line-modified">168   // read-only lookup</span>
<span class="line-removed">169   HashEntry* lookup_only(const T&amp; query, uintptr_t hash);</span>
170 
171   // id retrieval
<span class="line-modified">172   IdType id(const T&amp; data, uintptr_t hash) {</span>
173     assert(data != NULL, &quot;invariant&quot;);
<span class="line-modified">174     const HashEntry&amp; entry = lookup_put(data, hash);</span>
175     assert(entry.id() &gt; 0, &quot;invariant&quot;);
176     return entry.id();
177   }
178 
179   template &lt;typename Functor&gt;
180   void iterate_value(Functor&amp; f);
181 
182   template &lt;typename Functor&gt;
183   void iterate_entry(Functor&amp; f);
184 
185   size_t cardinality() const { return this-&gt;number_of_entries(); }
186   bool has_entries() const { return this-&gt;cardinality() &gt; 0; }
187   void clear_entries();
188 
189   // removal and deallocation
190   void free_entry(HashEntry* entry) {
191     assert(entry != NULL, &quot;invariant&quot;);
192     JfrBasicHashtable&lt;T&gt;::unlink_entry(entry);
<span class="line-modified">193     FREE_C_HEAP_ARRAY(char, entry);</span>

194   }
195 
196  private:
197   Callback* _callback;
198   size_t index_for(uintptr_t hash) { return this-&gt;hash_to_index(hash); }
<span class="line-modified">199   HashEntry* new_entry(const T&amp; data, uintptr_t hash);</span>
200   void add_entry(size_t index, HashEntry* new_entry) {
201     assert(new_entry != NULL, &quot;invariant&quot;);
<span class="line-modified">202     _callback-&gt;assign_id(new_entry);</span>
203     assert(new_entry-&gt;id() &gt; 0, &quot;invariant&quot;);
204     JfrBasicHashtable&lt;T&gt;::add_entry(index, new_entry);
205   }
206 };
207 
208 template &lt;typename T, typename IdType, template &lt;typename, typename&gt; class Entry, typename Callback, size_t TABLE_SIZE&gt;
<span class="line-modified">209 Entry&lt;T, IdType&gt;&amp; HashTableHost&lt;T, IdType, Entry, Callback, TABLE_SIZE&gt;::put(const T&amp; data, uintptr_t hash) {</span>
<span class="line-modified">210   assert(lookup_only(data, hash) == NULL, &quot;use lookup_put()&quot;);</span>
<span class="line-modified">211   HashEntry* const entry = new_entry(data, hash);</span>
212   add_entry(index_for(hash), entry);
213   return *entry;
214 }
215 
216 template &lt;typename T, typename IdType, template &lt;typename, typename&gt; class Entry, typename Callback, size_t TABLE_SIZE&gt;
<span class="line-modified">217 Entry&lt;T, IdType&gt;* HashTableHost&lt;T, IdType, Entry, Callback, TABLE_SIZE&gt;::lookup_only(const T&amp; query, uintptr_t hash) {</span>
218   HashEntry* entry = (HashEntry*)this-&gt;bucket(index_for(hash));
219   while (entry != NULL) {
<span class="line-modified">220     if (entry-&gt;hash() == hash &amp;&amp; _callback-&gt;equals(query, hash, entry)) {</span>
221       return entry;
222     }
223     entry = (HashEntry*)entry-&gt;next();
224   }
225   return NULL;
226 }
227 
228 template &lt;typename T, typename IdType, template &lt;typename, typename&gt; class Entry, typename Callback, size_t TABLE_SIZE&gt;
229 template &lt;typename Functor&gt;
230 void HashTableHost&lt;T, IdType, Entry, Callback, TABLE_SIZE&gt;::iterate_value(Functor&amp; f) {
231   for (size_t i = 0; i &lt; this-&gt;table_size(); ++i) {
232     const HashEntry* entry = (const HashEntry*)this-&gt;bucket(i);
233     while (entry != NULL) {
234       if (!f(entry-&gt;value())) {
235         break;
236       }
237       entry = (HashEntry*)entry-&gt;next();
238     }
239   }
240 }
</pre>
<hr />
<pre>
252     }
253   }
254 }
255 
256 template &lt;typename T, typename IdType, template &lt;typename, typename&gt; class Entry, typename Callback, size_t TABLE_SIZE&gt;
257 void HashTableHost&lt;T, IdType, Entry, Callback, TABLE_SIZE&gt;::clear_entries() {
258   for (size_t i = 0; i &lt; this-&gt;table_size(); ++i) {
259     HashEntry** bucket = (HashEntry**)this-&gt;bucket_addr(i);
260     HashEntry* entry = *bucket;
261     while (entry != NULL) {
262       HashEntry* entry_to_remove = entry;
263       entry = (HashEntry*)entry-&gt;next();
264       this-&gt;free_entry(entry_to_remove);
265     }
266     *bucket = NULL;
267   }
268   assert(this-&gt;number_of_entries() == 0, &quot;should have removed all entries&quot;);
269 }
270 
271 template &lt;typename T, typename IdType, template &lt;typename, typename&gt; class Entry, typename Callback, size_t TABLE_SIZE&gt;
<span class="line-modified">272 Entry&lt;T, IdType&gt;* HashTableHost&lt;T, IdType, Entry, Callback, TABLE_SIZE&gt;::new_entry(const T&amp; data, uintptr_t hash) {</span>
273   assert(sizeof(HashEntry) == this-&gt;entry_size(), &quot;invariant&quot;);
<span class="line-modified">274   HashEntry* const entry = (HashEntry*) NEW_C_HEAP_ARRAY2(char, this-&gt;entry_size(), mtTracing, CURRENT_PC);</span>
<span class="line-modified">275   entry-&gt;init();</span>
<span class="line-removed">276   entry-&gt;set_hash(hash);</span>
<span class="line-removed">277   entry-&gt;set_value(data);</span>
<span class="line-removed">278   entry-&gt;set_next(NULL);</span>
279   assert(0 == entry-&gt;id(), &quot;invariant&quot;);
280   return entry;
281 }
282 
283 #endif // SHARE_JFR_UTILITIES_JFRHASHTABLE_HPP
</pre>
</td>
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_JFR_UTILITIES_JFRHASHTABLE_HPP
 26 #define SHARE_JFR_UTILITIES_JFRHASHTABLE_HPP
 27 
<span class="line-modified"> 28 #include &quot;jfr/utilities/jfrAllocation.hpp&quot;</span>
<span class="line-modified"> 29 #include &quot;runtime/atomic.hpp&quot;</span>
 30 #include &quot;utilities/debug.hpp&quot;
 31 #include &quot;utilities/macros.hpp&quot;
 32 
 33 template &lt;typename T&gt;
<span class="line-modified"> 34 class JfrBasicHashtableEntry : public JfrCHeapObj {</span>
 35  private:
 36   typedef JfrBasicHashtableEntry&lt;T&gt; Entry;
 37   Entry* _next;
 38   T _literal;          // ref to item in table.
 39   uintptr_t _hash;
 40 
 41  public:
<span class="line-added"> 42   JfrBasicHashtableEntry(uintptr_t hash, const T&amp; data) : _next(NULL), _literal(data), _hash(hash) {}</span>
 43   uintptr_t hash() const { return _hash; }

 44   T literal() const { return _literal; }
 45   T* literal_addr() { return &amp;_literal; }
 46   void set_literal(T s) { _literal = s; }
 47   void set_next(Entry* next) { _next = next; }
 48   Entry* next() const { return _next; }
 49   Entry** next_addr() { return &amp;_next; }
 50 };
 51 
 52 template &lt;typename T&gt;
 53 class JfrHashtableBucket : public CHeapObj&lt;mtTracing&gt; {
 54   template &lt;typename&gt;
 55   friend class JfrBasicHashtable;
 56  private:
 57   typedef JfrBasicHashtableEntry&lt;T&gt; TableEntry;
 58   TableEntry* _entry;
 59 
 60   TableEntry* get_entry() const {
<span class="line-modified"> 61     return (TableEntry*)Atomic::load_acquire(&amp;_entry);</span>
 62   }
<span class="line-modified"> 63   void set_entry(TableEntry* entry) { Atomic::release_store(&amp;_entry, entry);}</span>
 64   TableEntry** entry_addr() { return &amp;_entry; }
 65 };
 66 
 67 template &lt;typename T&gt;
 68 class JfrBasicHashtable : public CHeapObj&lt;mtTracing&gt; {
 69  private:
 70   typedef JfrHashtableBucket&lt;T&gt; Bucket;
 71   typedef JfrBasicHashtableEntry&lt;T&gt; TableEntry;
 72   Bucket* _buckets;
 73   uintptr_t _table_size;
 74   const size_t _entry_size;
 75   size_t _number_of_entries;
 76 
 77  protected:
 78   JfrBasicHashtable(uintptr_t table_size, size_t entry_size) :
 79     _buckets(NULL), _table_size(table_size), _entry_size(entry_size), _number_of_entries(0) {
 80     _buckets = NEW_C_HEAP_ARRAY2(Bucket, table_size, mtTracing, CURRENT_PC);
 81     memset((void*)_buckets, 0, table_size * sizeof(Bucket));
 82   }
 83 
 84   size_t hash_to_index(uintptr_t full_hash) const {
 85     const uintptr_t h = full_hash % _table_size;
 86     assert(h &gt;= 0 &amp;&amp; h &lt; _table_size, &quot;Illegal hash value&quot;);
 87     return (size_t)h;
 88   }
 89   size_t entry_size() const { return _entry_size; }
 90   void unlink_entry(TableEntry* entry) {
 91     entry-&gt;set_next(NULL);
 92     --_number_of_entries;
 93   }
 94   void free_buckets() {
<span class="line-modified"> 95     FREE_C_HEAP_ARRAY(Bucket, _buckets);</span>



 96   }
 97   TableEntry* bucket(size_t i) { return _buckets[i].get_entry();}
 98   TableEntry** bucket_addr(size_t i) { return _buckets[i].entry_addr(); }
 99   uintptr_t table_size() const { return _table_size; }
100   size_t number_of_entries() const { return _number_of_entries; }
101   void add_entry(size_t index, TableEntry* entry) {
102     assert(entry != NULL, &quot;invariant&quot;);
103     entry-&gt;set_next(bucket(index));
104     _buckets[index].set_entry(entry);
105     ++_number_of_entries;
106   }
107 };
108 
109 template &lt;typename IdType, typename Entry, typename T&gt;
<span class="line-modified">110 class AscendingId : public JfrCHeapObj  {</span>
111  private:
112   IdType _id;
113  public:
114   AscendingId() : _id(0) {}
115   // callbacks
<span class="line-modified">116   void on_link(Entry* entry) {</span>
117     assert(entry != NULL, &quot;invariant&quot;);
118     assert(entry-&gt;id() == 0, &quot;invariant&quot;);
119     entry-&gt;set_id(++_id);
120   }
<span class="line-modified">121   bool on_equals(uintptr_t hash, const Entry* entry) {</span>
122     assert(entry-&gt;hash() == hash, &quot;invariant&quot;);
123     return true;
124   }
125 };
126 
127 // IdType must be scalar
128 template &lt;typename T, typename IdType&gt;
<span class="line-modified">129 class JfrHashtableEntry : public JfrBasicHashtableEntry&lt;T&gt; {</span>
130  public:
<span class="line-added">131   JfrHashtableEntry(uintptr_t hash, const T&amp; data) : JfrBasicHashtableEntry&lt;T&gt;(hash, data), _id(0) {}</span>
132   typedef IdType ID;

133   ID id() const { return _id; }
<span class="line-modified">134   void set_id(ID id) const { _id = id; }</span>
<span class="line-modified">135   T&amp; value() const { return *const_cast&lt;JfrHashtableEntry*&gt;(this)-&gt;literal_addr();}</span>
<span class="line-modified">136   const T* value_addr() const { return const_cast&lt;JfrHashtableEntry*&gt;(this)-&gt;literal_addr(); }</span>


137  private:
<span class="line-modified">138   mutable ID _id;</span>
139 };
140 
141 template &lt;typename T, typename IdType, template &lt;typename, typename&gt; class Entry,
142           typename Callback = AscendingId&lt;IdType, Entry&lt;T, IdType&gt;, T&gt; ,
143           size_t TABLE_SIZE = 1009&gt;
144 class HashTableHost : public JfrBasicHashtable&lt;T&gt; {
145  public:
146   typedef Entry&lt;T, IdType&gt; HashEntry;
<span class="line-modified">147   HashTableHost(size_t size = 0) : JfrBasicHashtable&lt;T&gt;(size == 0 ? TABLE_SIZE : size, sizeof(HashEntry)), _callback(new Callback()) {}</span>
<span class="line-modified">148   HashTableHost(Callback* cb, size_t size = 0) : JfrBasicHashtable&lt;T&gt;(size == 0 ? TABLE_SIZE : size, sizeof(HashEntry)), _callback(cb) {}</span>
149   ~HashTableHost() {
150     this-&gt;clear_entries();
151     this-&gt;free_buckets();
152   }
153 
154   // direct insert assumes non-existing entry
<span class="line-modified">155   HashEntry&amp; put(uintptr_t hash, const T&amp; data);</span>
156 
157   // lookup entry, will put if not found
<span class="line-modified">158   HashEntry&amp; lookup_put(uintptr_t hash, const T&amp; data) {</span>
<span class="line-modified">159     HashEntry* entry = lookup_only(hash);</span>
<span class="line-modified">160     return entry == NULL ? put(hash, data) : *entry;</span>
161   }
162 
<span class="line-modified">163   HashEntry* lookup_only(uintptr_t hash);</span>

164 
165   // id retrieval
<span class="line-modified">166   IdType id(uintptr_t hash, const T&amp; data) {</span>
167     assert(data != NULL, &quot;invariant&quot;);
<span class="line-modified">168     const HashEntry&amp; entry = lookup_put(hash, data);</span>
169     assert(entry.id() &gt; 0, &quot;invariant&quot;);
170     return entry.id();
171   }
172 
173   template &lt;typename Functor&gt;
174   void iterate_value(Functor&amp; f);
175 
176   template &lt;typename Functor&gt;
177   void iterate_entry(Functor&amp; f);
178 
179   size_t cardinality() const { return this-&gt;number_of_entries(); }
180   bool has_entries() const { return this-&gt;cardinality() &gt; 0; }
181   void clear_entries();
182 
183   // removal and deallocation
184   void free_entry(HashEntry* entry) {
185     assert(entry != NULL, &quot;invariant&quot;);
186     JfrBasicHashtable&lt;T&gt;::unlink_entry(entry);
<span class="line-modified">187     _callback-&gt;on_unlink(entry);</span>
<span class="line-added">188     delete entry;</span>
189   }
190 
191  private:
192   Callback* _callback;
193   size_t index_for(uintptr_t hash) { return this-&gt;hash_to_index(hash); }
<span class="line-modified">194   HashEntry* new_entry(uintptr_t hash, const T&amp; data);</span>
195   void add_entry(size_t index, HashEntry* new_entry) {
196     assert(new_entry != NULL, &quot;invariant&quot;);
<span class="line-modified">197     _callback-&gt;on_link(new_entry);</span>
198     assert(new_entry-&gt;id() &gt; 0, &quot;invariant&quot;);
199     JfrBasicHashtable&lt;T&gt;::add_entry(index, new_entry);
200   }
201 };
202 
203 template &lt;typename T, typename IdType, template &lt;typename, typename&gt; class Entry, typename Callback, size_t TABLE_SIZE&gt;
<span class="line-modified">204 Entry&lt;T, IdType&gt;&amp; HashTableHost&lt;T, IdType, Entry, Callback, TABLE_SIZE&gt;::put(uintptr_t hash, const T&amp; data) {</span>
<span class="line-modified">205   assert(lookup_only(hash) == NULL, &quot;use lookup_put()&quot;);</span>
<span class="line-modified">206   HashEntry* const entry = new_entry(hash, data);</span>
207   add_entry(index_for(hash), entry);
208   return *entry;
209 }
210 
211 template &lt;typename T, typename IdType, template &lt;typename, typename&gt; class Entry, typename Callback, size_t TABLE_SIZE&gt;
<span class="line-modified">212 Entry&lt;T, IdType&gt;* HashTableHost&lt;T, IdType, Entry, Callback, TABLE_SIZE&gt;::lookup_only(uintptr_t hash) {</span>
213   HashEntry* entry = (HashEntry*)this-&gt;bucket(index_for(hash));
214   while (entry != NULL) {
<span class="line-modified">215     if (entry-&gt;hash() == hash &amp;&amp; _callback-&gt;on_equals(hash, entry)) {</span>
216       return entry;
217     }
218     entry = (HashEntry*)entry-&gt;next();
219   }
220   return NULL;
221 }
222 
223 template &lt;typename T, typename IdType, template &lt;typename, typename&gt; class Entry, typename Callback, size_t TABLE_SIZE&gt;
224 template &lt;typename Functor&gt;
225 void HashTableHost&lt;T, IdType, Entry, Callback, TABLE_SIZE&gt;::iterate_value(Functor&amp; f) {
226   for (size_t i = 0; i &lt; this-&gt;table_size(); ++i) {
227     const HashEntry* entry = (const HashEntry*)this-&gt;bucket(i);
228     while (entry != NULL) {
229       if (!f(entry-&gt;value())) {
230         break;
231       }
232       entry = (HashEntry*)entry-&gt;next();
233     }
234   }
235 }
</pre>
<hr />
<pre>
247     }
248   }
249 }
250 
251 template &lt;typename T, typename IdType, template &lt;typename, typename&gt; class Entry, typename Callback, size_t TABLE_SIZE&gt;
252 void HashTableHost&lt;T, IdType, Entry, Callback, TABLE_SIZE&gt;::clear_entries() {
253   for (size_t i = 0; i &lt; this-&gt;table_size(); ++i) {
254     HashEntry** bucket = (HashEntry**)this-&gt;bucket_addr(i);
255     HashEntry* entry = *bucket;
256     while (entry != NULL) {
257       HashEntry* entry_to_remove = entry;
258       entry = (HashEntry*)entry-&gt;next();
259       this-&gt;free_entry(entry_to_remove);
260     }
261     *bucket = NULL;
262   }
263   assert(this-&gt;number_of_entries() == 0, &quot;should have removed all entries&quot;);
264 }
265 
266 template &lt;typename T, typename IdType, template &lt;typename, typename&gt; class Entry, typename Callback, size_t TABLE_SIZE&gt;
<span class="line-modified">267 Entry&lt;T, IdType&gt;* HashTableHost&lt;T, IdType, Entry, Callback, TABLE_SIZE&gt;::new_entry(uintptr_t hash, const T&amp; data) {</span>
268   assert(sizeof(HashEntry) == this-&gt;entry_size(), &quot;invariant&quot;);
<span class="line-modified">269   HashEntry* const entry = new HashEntry(hash, data);</span>
<span class="line-modified">270   assert(entry != NULL, &quot;invariant&quot;);</span>



271   assert(0 == entry-&gt;id(), &quot;invariant&quot;);
272   return entry;
273 }
274 
275 #endif // SHARE_JFR_UTILITIES_JFRHASHTABLE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="jfrDoublyLinkedList.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jfrJavaLog.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
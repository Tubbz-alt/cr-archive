<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/jfr/utilities/jfrDoublyLinkedList.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_JFR_UTILITIES_JFRDOUBLYLINKEDLIST_HPP
 26 #define SHARE_JFR_UTILITIES_JFRDOUBLYLINKEDLIST_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 
 30 template &lt;typename T&gt;
 31 class JfrDoublyLinkedList {
 32  private:
 33   T* _head;
 34   T* _tail;
 35   size_t _count;
 36 
 37   T** list_head() { return &amp;_head; }
 38   T** list_tail() { return &amp;_tail; }
 39 
 40  public:
 41   typedef T Node;
 42   JfrDoublyLinkedList() : _head(NULL), _tail(NULL), _count(0) {}
 43   T* head() const { return _head; }
 44   T* tail() const { return _tail; }
 45   size_t count() const { return _count; }
 46   T* clear(bool return_tail = false);
 47   T* remove(T* const node);
 48   void prepend(T* const node);
 49   void append(T* const node);
 50   void append_list(T* const head_node, T* const tail_node, size_t count);
 51   debug_only(bool in_list(const T* const target_node) const;)
 52   debug_only(bool locate(const T* start_node, const T* const target_node) const;)
 53 };
 54 
 55 template &lt;typename T&gt;
 56 inline void JfrDoublyLinkedList&lt;T&gt;::prepend(T* const node) {
 57   assert(node != NULL, &quot;invariant&quot;);
 58   node-&gt;set_prev(NULL);
 59   assert(!in_list(node), &quot;already in list error&quot;);
 60   T** lh = list_head();
 61   if (*lh != NULL) {
 62     (*lh)-&gt;set_prev(node);
 63     node-&gt;set_next(*lh);
 64   } else {
 65     T** lt = list_tail();
 66     assert(*lt == NULL, &quot;invariant&quot;);
 67     *lt = node;
 68     node-&gt;set_next(NULL);
 69     assert(tail() == node, &quot;invariant&quot;);
 70     assert(node-&gt;next() == NULL, &quot;invariant&quot;);
 71   }
 72   *lh = node;
 73   ++_count;
 74   assert(head() == node, &quot;head error&quot;);
 75   assert(in_list(node), &quot;not in list error&quot;);
 76   assert(node-&gt;prev() == NULL, &quot;invariant&quot;);
 77 }
 78 
 79 template &lt;typename T&gt;
 80 void JfrDoublyLinkedList&lt;T&gt;::append(T* const node) {
 81   assert(node != NULL, &quot;invariant&quot;);
 82   node-&gt;set_next(NULL);
 83   assert(!in_list(node), &quot;already in list error&quot;);
 84   T** lt = list_tail();
 85   if (*lt != NULL) {
 86     // already an existing tail
 87     node-&gt;set_prev(*lt);
 88     (*lt)-&gt;set_next(node);
 89   } else {
 90     // if no tail, also update head
 91     assert(*lt == NULL, &quot;invariant&quot;);
 92     T** lh = list_head();
 93     assert(*lh == NULL, &quot;invariant&quot;);
 94     node-&gt;set_prev(NULL);
 95     *lh = node;
 96     assert(head() == node, &quot;invariant&quot;);
 97   }
 98   *lt = node;
 99   ++_count;
100   assert(tail() == node, &quot;invariant&quot;);
101   assert(in_list(node), &quot;not in list error&quot;);
102   assert(node-&gt;next() == NULL, &quot;invariant&quot;);
103 }
104 
105 template &lt;typename T&gt;
106 T* JfrDoublyLinkedList&lt;T&gt;::remove(T* const node) {
107   assert(node != NULL, &quot;invariant&quot;);
108   assert(in_list(node), &quot;invariant&quot;);
109   T* const prev = (T*)node-&gt;prev();
110   T* const next = (T*)node-&gt;next();
111   if (prev == NULL) {
112     assert(head() == node, &quot;head error&quot;);
113     if (next != NULL) {
114       next-&gt;set_prev(NULL);
115     } else {
116       assert(next == NULL, &quot;invariant&quot;);
117       assert(tail() == node, &quot;tail error&quot;);
118       T** lt = list_tail();
119       *lt = NULL;
120       assert(tail() == NULL, &quot;invariant&quot;);
121     }
122     T** lh = list_head();
123     *lh = next;
124     assert(head() == next, &quot;invariant&quot;);
125   } else {
126     assert(prev != NULL, &quot;invariant&quot;);
127     if (next == NULL) {
128       assert(tail() == node, &quot;tail error&quot;);
129       T** lt = list_tail();
130       *lt = prev;
131       assert(tail() == prev, &quot;invariant&quot;);
132     } else {
133        next-&gt;set_prev(prev);
134     }
135     prev-&gt;set_next(next);
136   }
137   --_count;
138   assert(_count &gt;= 0, &quot;invariant&quot;);
139   assert(!in_list(node), &quot;still in list error&quot;);
140   return node;
141 }
142 
143 template &lt;typename T&gt;
144 T* JfrDoublyLinkedList&lt;T&gt;::clear(bool return_tail /* false */) {
145   T* const node = return_tail ? tail() : head();
146   T** l = list_head();
147   *l = NULL;
148   l = list_tail();
149   *l = NULL;
150   _count = 0;
151   assert(head() == NULL, &quot;invariant&quot;);
152   assert(tail() == NULL, &quot;invariant&quot;);
153   return node;
154 }
155 
156 #ifdef ASSERT
157 template &lt;typename T&gt;
158 bool JfrDoublyLinkedList&lt;T&gt;::locate(const T* node, const T* const target) const {
159   assert(target != NULL, &quot;invariant&quot;);
160   while (node != NULL) {
161     if (node == target) {
162       return true;
163     }
164     node = (T*)node-&gt;next();
165   }
166   return false;
167 }
168 
169 template &lt;typename T&gt;
170 bool JfrDoublyLinkedList&lt;T&gt;::in_list(const T* const target) const {
171   assert(target != NULL, &quot;invariant&quot;);
172   return locate(head(), target);
173 }
174 
175 template &lt;typename T&gt;
176 inline void validate_count_param(T* node, size_t count_param) {
177   assert(node != NULL, &quot;invariant&quot;);
178   size_t count = 0;
179   while (node) {
180     ++count;
181     node = (T*)node-&gt;next();
182   }
183   assert(count_param == count, &quot;invariant&quot;);
184 }
185 #endif // ASSERT
186 
187 template &lt;typename T&gt;
188 void JfrDoublyLinkedList&lt;T&gt;::append_list(T* const head_node, T* const tail_node, size_t count) {
189   assert(head_node != NULL, &quot;invariant&quot;);
190   assert(!in_list(head_node), &quot;already in list error&quot;);
191   assert(tail_node != NULL, &quot;invariant&quot;);
192   assert(!in_list(tail_node), &quot;already in list error&quot;);
193   assert(tail_node-&gt;next() == NULL, &quot;invariant&quot;);
194   // ensure passed in list nodes are connected
195   assert(locate(head_node, tail_node), &quot;invariant&quot;);
196   T** lt = list_tail();
197   if (*lt != NULL) {
198     head_node-&gt;set_prev(*lt);
199     (*lt)-&gt;set_next(head_node);
200   } else {
201     // no head
202     assert(*lt == NULL, &quot;invariant&quot;);
203     T** lh = list_head();
204     assert(*lh == NULL, &quot;invariant&quot;);
205     head_node-&gt;set_prev(NULL);
206     *lh = head_node;
207     assert(head() == head_node, &quot;invariant&quot;);
208   }
209   *lt = tail_node;
210   const T* node = head_node;
211   debug_only(validate_count_param(node, count);)
212     _count += count;
213   assert(tail() == tail_node, &quot;invariant&quot;);
214   assert(in_list(tail_node), &quot;not in list error&quot;);
215   assert(in_list(head_node), &quot;not in list error&quot;);
216 }
217 
218 #endif // SHARE_JFR_UTILITIES_JFRDOUBLYLINKEDLIST_HPP
    </pre>
  </body>
</html>
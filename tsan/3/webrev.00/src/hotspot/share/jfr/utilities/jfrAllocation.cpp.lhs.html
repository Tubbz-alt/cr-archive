<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jfr/utilities/jfrAllocation.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/recorder/jfrRecorder.hpp&quot;
 27 #include &quot;jfr/utilities/jfrAllocation.hpp&quot;
 28 #include &quot;logging/log.hpp&quot;
 29 #include &quot;memory/allocation.inline.hpp&quot;
 30 #include &quot;runtime/atomic.hpp&quot;
<a name="1" id="anc1"></a><span class="line-removed"> 31 #include &quot;runtime/orderAccess.hpp&quot;</span>
 32 #include &quot;runtime/vm_version.hpp&quot;
 33 #include &quot;utilities/debug.hpp&quot;
 34 #include &quot;utilities/macros.hpp&quot;
 35 #include &quot;utilities/nativeCallStack.hpp&quot;
 36 
 37 #ifdef ASSERT
 38 static jlong atomic_add_jlong(jlong value, jlong volatile* const dest) {
 39   assert(VM_Version::supports_cx8(), &quot;unsupported&quot;);
 40   jlong compare_value;
 41   jlong exchange_value;
 42   do {
<a name="2" id="anc2"></a><span class="line-modified"> 43     compare_value = OrderAccess::load_acquire(dest);</span>
 44     exchange_value = compare_value + value;
<a name="3" id="anc3"></a><span class="line-modified"> 45   } while (Atomic::cmpxchg(exchange_value, dest, compare_value) != compare_value);</span>
 46   return exchange_value;
 47 }
 48 
 49 // debug statistics
 50 static volatile jlong _allocated_bytes = 0;
 51 static volatile jlong _deallocated_bytes = 0;
 52 static volatile jlong _live_set_bytes = 0;
 53 
 54 static void add(size_t alloc_size) {
 55   if (!JfrRecorder::is_created()) {
 56     const jlong total_allocated = atomic_add_jlong((jlong)alloc_size, &amp;_allocated_bytes);
 57     const jlong current_live_set = atomic_add_jlong((jlong)alloc_size, &amp;_live_set_bytes);
 58     log_trace(jfr, system)(&quot;Allocation: [&quot; SIZE_FORMAT &quot;] bytes&quot;, alloc_size);
 59     log_trace(jfr, system)(&quot;Total alloc [&quot; JLONG_FORMAT &quot;] bytes&quot;, total_allocated);
 60     log_trace(jfr, system)(&quot;Liveset:    [&quot; JLONG_FORMAT &quot;] bytes&quot;, current_live_set);
 61   }
 62 }
 63 
 64 static void subtract(size_t dealloc_size) {
 65   if (!JfrRecorder::is_created()) {
 66     const jlong total_deallocated = atomic_add_jlong((jlong)dealloc_size, &amp;_deallocated_bytes);
 67     const jlong current_live_set = atomic_add_jlong(((jlong)dealloc_size * -1), &amp;_live_set_bytes);
 68     log_trace(jfr, system)(&quot;Deallocation: [&quot; SIZE_FORMAT &quot;] bytes&quot;, dealloc_size);
 69     log_trace(jfr, system)(&quot;Total dealloc [&quot; JLONG_FORMAT &quot;] bytes&quot;, total_deallocated);
 70     log_trace(jfr, system)(&quot;Liveset:      [&quot; JLONG_FORMAT &quot;] bytes&quot;, current_live_set);
 71   }
 72 }
 73 
 74 static void hook_memory_deallocation(size_t dealloc_size) {
 75   subtract(dealloc_size);
 76 }
 77 #endif // ASSERT
 78 
 79 static void hook_memory_allocation(const char* allocation, size_t alloc_size) {
 80   if (NULL == allocation) {
 81     if (!JfrRecorder::is_created()) {
 82       log_warning(jfr, system)(&quot;Memory allocation failed for size [&quot; SIZE_FORMAT &quot;] bytes&quot;, alloc_size);
 83       return;
 84     } else {
 85       // after critical startup, fail as by default
 86       vm_exit_out_of_memory(alloc_size, OOM_MALLOC_ERROR, &quot;AllocateHeap&quot;);
 87     }
 88   }
 89   debug_only(add(alloc_size));
 90 }
 91 
 92 void JfrCHeapObj::on_memory_allocation(const void* allocation, size_t size) {
 93   hook_memory_allocation((const char*)allocation, size);
 94 }
 95 
 96 void* JfrCHeapObj::operator new(size_t size) throw() {
 97   return operator new(size, std::nothrow);
 98 }
 99 
100 void* JfrCHeapObj::operator new (size_t size, const std::nothrow_t&amp;  nothrow_constant) throw() {
101   void* const memory = CHeapObj&lt;mtTracing&gt;::operator new(size, nothrow_constant, CALLER_PC);
102   hook_memory_allocation((const char*)memory, size);
103   return memory;
104 }
105 
106 void* JfrCHeapObj::operator new [](size_t size) throw() {
107   return operator new[](size, std::nothrow);
108 }
109 
110 void* JfrCHeapObj::operator new [](size_t size, const std::nothrow_t&amp;  nothrow_constant) throw() {
111   void* const memory = CHeapObj&lt;mtTracing&gt;::operator new[](size, nothrow_constant, CALLER_PC);
112   hook_memory_allocation((const char*)memory, size);
113   return memory;
114 }
115 
116 void JfrCHeapObj::operator delete(void* p, size_t size) {
117   debug_only(hook_memory_deallocation(size);)
118   CHeapObj&lt;mtTracing&gt;::operator delete(p);
119 }
120 
121 void JfrCHeapObj::operator delete[](void* p, size_t size) {
122   debug_only(hook_memory_deallocation(size);)
123   CHeapObj&lt;mtTracing&gt;::operator delete[](p);
124 }
125 
126 char* JfrCHeapObj::realloc_array(char* old, size_t size) {
127   char* const memory = ReallocateHeap(old, size, mtTracing, AllocFailStrategy::RETURN_NULL);
128   hook_memory_allocation(memory, size);
129   return memory;
130 }
131 
132 void JfrCHeapObj::free(void* p, size_t size) {
133   debug_only(hook_memory_deallocation(size);)
134   FreeHeap(p);
135 }
136 
137 char* JfrCHeapObj::allocate_array_noinline(size_t elements, size_t element_size) {
138   return AllocateHeap(elements * element_size, mtTracing, CALLER_PC, AllocFailStrategy::RETURN_NULL);
139 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
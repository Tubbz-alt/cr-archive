<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/jfr/utilities/jfrAllocation.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/recorder/jfrRecorder.hpp&quot;
 27 #include &quot;jfr/utilities/jfrAllocation.hpp&quot;
 28 #include &quot;logging/log.hpp&quot;
 29 #include &quot;memory/allocation.inline.hpp&quot;
 30 #include &quot;runtime/atomic.hpp&quot;
 31 #include &quot;runtime/vm_version.hpp&quot;
 32 #include &quot;utilities/debug.hpp&quot;
 33 #include &quot;utilities/macros.hpp&quot;
 34 #include &quot;utilities/nativeCallStack.hpp&quot;
 35 
 36 #ifdef ASSERT
 37 static jlong atomic_add_jlong(jlong value, jlong volatile* const dest) {
 38   assert(VM_Version::supports_cx8(), &quot;unsupported&quot;);
 39   jlong compare_value;
 40   jlong exchange_value;
 41   do {
 42     compare_value = *dest;
 43     exchange_value = compare_value + value;
 44   } while (Atomic::cmpxchg(dest, compare_value, exchange_value) != compare_value);
 45   return exchange_value;
 46 }
 47 
 48 // debug statistics
 49 static volatile jlong _allocated_bytes = 0;
 50 static volatile jlong _deallocated_bytes = 0;
 51 static volatile jlong _live_set_bytes = 0;
 52 
 53 static void add(size_t alloc_size) {
 54   if (!JfrRecorder::is_created()) {
 55     const jlong total_allocated = atomic_add_jlong((jlong)alloc_size, &amp;_allocated_bytes);
 56     const jlong current_live_set = atomic_add_jlong((jlong)alloc_size, &amp;_live_set_bytes);
 57     log_trace(jfr, system)(&quot;Allocation: [&quot; SIZE_FORMAT &quot;] bytes&quot;, alloc_size);
 58     log_trace(jfr, system)(&quot;Total alloc [&quot; JLONG_FORMAT &quot;] bytes&quot;, total_allocated);
 59     log_trace(jfr, system)(&quot;Liveset:    [&quot; JLONG_FORMAT &quot;] bytes&quot;, current_live_set);
 60   }
 61 }
 62 
 63 static void subtract(size_t dealloc_size) {
 64   if (!JfrRecorder::is_created()) {
 65     const jlong total_deallocated = atomic_add_jlong((jlong)dealloc_size, &amp;_deallocated_bytes);
 66     const jlong current_live_set = atomic_add_jlong(((jlong)dealloc_size * -1), &amp;_live_set_bytes);
 67     log_trace(jfr, system)(&quot;Deallocation: [&quot; SIZE_FORMAT &quot;] bytes&quot;, dealloc_size);
 68     log_trace(jfr, system)(&quot;Total dealloc [&quot; JLONG_FORMAT &quot;] bytes&quot;, total_deallocated);
 69     log_trace(jfr, system)(&quot;Liveset:      [&quot; JLONG_FORMAT &quot;] bytes&quot;, current_live_set);
 70   }
 71 }
 72 
 73 static void hook_memory_deallocation(size_t dealloc_size) {
 74   subtract(dealloc_size);
 75 }
 76 #endif // ASSERT
 77 
 78 static void hook_memory_allocation(const char* allocation, size_t alloc_size) {
 79   if (NULL == allocation) {
 80     if (!JfrRecorder::is_created()) {
 81       log_warning(jfr, system)(&quot;Memory allocation failed for size [&quot; SIZE_FORMAT &quot;] bytes&quot;, alloc_size);
 82       return;
 83     } else {
 84       // after critical startup, fail as by default
 85       vm_exit_out_of_memory(alloc_size, OOM_MALLOC_ERROR, &quot;AllocateHeap&quot;);
 86     }
 87   }
 88   debug_only(add(alloc_size));
 89 }
 90 
 91 void JfrCHeapObj::on_memory_allocation(const void* allocation, size_t size) {
 92   hook_memory_allocation((const char*)allocation, size);
 93 }
 94 
 95 void* JfrCHeapObj::operator new(size_t size) throw() {
 96   return operator new(size, std::nothrow);
 97 }
 98 
 99 void* JfrCHeapObj::operator new (size_t size, const std::nothrow_t&amp;  nothrow_constant) throw() {
100   void* const memory = CHeapObj&lt;mtTracing&gt;::operator new(size, nothrow_constant, CALLER_PC);
101   hook_memory_allocation((const char*)memory, size);
102   return memory;
103 }
104 
105 void* JfrCHeapObj::operator new [](size_t size) throw() {
106   return operator new[](size, std::nothrow);
107 }
108 
109 void* JfrCHeapObj::operator new [](size_t size, const std::nothrow_t&amp;  nothrow_constant) throw() {
110   void* const memory = CHeapObj&lt;mtTracing&gt;::operator new[](size, nothrow_constant, CALLER_PC);
111   hook_memory_allocation((const char*)memory, size);
112   return memory;
113 }
114 
115 void JfrCHeapObj::operator delete(void* p, size_t size) {
116   debug_only(hook_memory_deallocation(size);)
117   CHeapObj&lt;mtTracing&gt;::operator delete(p);
118 }
119 
120 void JfrCHeapObj::operator delete[](void* p, size_t size) {
121   debug_only(hook_memory_deallocation(size);)
122   CHeapObj&lt;mtTracing&gt;::operator delete[](p);
123 }
124 
125 char* JfrCHeapObj::realloc_array(char* old, size_t size) {
126   char* const memory = ReallocateHeap(old, size, mtTracing, AllocFailStrategy::RETURN_NULL);
127   hook_memory_allocation(memory, size);
128   return memory;
129 }
130 
131 void JfrCHeapObj::free(void* p, size_t size) {
132   debug_only(hook_memory_deallocation(size);)
133   FreeHeap(p);
134 }
135 
136 char* JfrCHeapObj::allocate_array_noinline(size_t elements, size_t element_size) {
137   return AllocateHeap(elements * element_size, mtTracing, CALLER_PC, AllocFailStrategy::RETURN_NULL);
138 }
    </pre>
  </body>
</html>
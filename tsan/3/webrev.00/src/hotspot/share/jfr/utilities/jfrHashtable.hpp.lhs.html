<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jfr/utilities/jfrHashtable.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_JFR_UTILITIES_JFRHASHTABLE_HPP
 26 #define SHARE_JFR_UTILITIES_JFRHASHTABLE_HPP
 27 
<a name="1" id="anc1"></a><span class="line-modified"> 28 #include &quot;memory/allocation.inline.hpp&quot;</span>
<span class="line-modified"> 29 #include &quot;runtime/orderAccess.hpp&quot;</span>
 30 #include &quot;utilities/debug.hpp&quot;
 31 #include &quot;utilities/macros.hpp&quot;
 32 
 33 template &lt;typename T&gt;
<a name="2" id="anc2"></a><span class="line-modified"> 34 class JfrBasicHashtableEntry {</span>
 35  private:
 36   typedef JfrBasicHashtableEntry&lt;T&gt; Entry;
 37   Entry* _next;
 38   T _literal;          // ref to item in table.
 39   uintptr_t _hash;
 40 
 41  public:
<a name="3" id="anc3"></a>
 42   uintptr_t hash() const { return _hash; }
<a name="4" id="anc4"></a><span class="line-removed"> 43   void set_hash(uintptr_t hash) { _hash = hash; }</span>
 44   T literal() const { return _literal; }
 45   T* literal_addr() { return &amp;_literal; }
 46   void set_literal(T s) { _literal = s; }
 47   void set_next(Entry* next) { _next = next; }
 48   Entry* next() const { return _next; }
 49   Entry** next_addr() { return &amp;_next; }
 50 };
 51 
 52 template &lt;typename T&gt;
 53 class JfrHashtableBucket : public CHeapObj&lt;mtTracing&gt; {
 54   template &lt;typename&gt;
 55   friend class JfrBasicHashtable;
 56  private:
 57   typedef JfrBasicHashtableEntry&lt;T&gt; TableEntry;
 58   TableEntry* _entry;
 59 
 60   TableEntry* get_entry() const {
<a name="5" id="anc5"></a><span class="line-modified"> 61     return (TableEntry*)OrderAccess::load_acquire(&amp;_entry);</span>
 62   }
<a name="6" id="anc6"></a><span class="line-modified"> 63   void set_entry(TableEntry* entry) { OrderAccess::release_store(&amp;_entry, entry);}</span>
 64   TableEntry** entry_addr() { return &amp;_entry; }
 65 };
 66 
 67 template &lt;typename T&gt;
 68 class JfrBasicHashtable : public CHeapObj&lt;mtTracing&gt; {
 69  private:
 70   typedef JfrHashtableBucket&lt;T&gt; Bucket;
 71   typedef JfrBasicHashtableEntry&lt;T&gt; TableEntry;
 72   Bucket* _buckets;
 73   uintptr_t _table_size;
 74   const size_t _entry_size;
 75   size_t _number_of_entries;
 76 
 77  protected:
 78   JfrBasicHashtable(uintptr_t table_size, size_t entry_size) :
 79     _buckets(NULL), _table_size(table_size), _entry_size(entry_size), _number_of_entries(0) {
 80     _buckets = NEW_C_HEAP_ARRAY2(Bucket, table_size, mtTracing, CURRENT_PC);
 81     memset((void*)_buckets, 0, table_size * sizeof(Bucket));
 82   }
 83 
 84   size_t hash_to_index(uintptr_t full_hash) const {
 85     const uintptr_t h = full_hash % _table_size;
 86     assert(h &gt;= 0 &amp;&amp; h &lt; _table_size, &quot;Illegal hash value&quot;);
 87     return (size_t)h;
 88   }
 89   size_t entry_size() const { return _entry_size; }
 90   void unlink_entry(TableEntry* entry) {
 91     entry-&gt;set_next(NULL);
 92     --_number_of_entries;
 93   }
 94   void free_buckets() {
<a name="7" id="anc7"></a><span class="line-modified"> 95     if (NULL != _buckets) {</span>
<span class="line-removed"> 96       FREE_C_HEAP_ARRAY(Bucket, _buckets);</span>
<span class="line-removed"> 97       _buckets = NULL;</span>
<span class="line-removed"> 98     }</span>
 99   }
100   TableEntry* bucket(size_t i) { return _buckets[i].get_entry();}
101   TableEntry** bucket_addr(size_t i) { return _buckets[i].entry_addr(); }
102   uintptr_t table_size() const { return _table_size; }
103   size_t number_of_entries() const { return _number_of_entries; }
104   void add_entry(size_t index, TableEntry* entry) {
105     assert(entry != NULL, &quot;invariant&quot;);
106     entry-&gt;set_next(bucket(index));
107     _buckets[index].set_entry(entry);
108     ++_number_of_entries;
109   }
110 };
111 
112 template &lt;typename IdType, typename Entry, typename T&gt;
<a name="8" id="anc8"></a><span class="line-modified">113 class AscendingId : public CHeapObj&lt;mtTracing&gt;  {</span>
114  private:
115   IdType _id;
116  public:
117   AscendingId() : _id(0) {}
118   // callbacks
<a name="9" id="anc9"></a><span class="line-modified">119   void assign_id(Entry* entry) {</span>
120     assert(entry != NULL, &quot;invariant&quot;);
121     assert(entry-&gt;id() == 0, &quot;invariant&quot;);
122     entry-&gt;set_id(++_id);
123   }
<a name="10" id="anc10"></a><span class="line-modified">124   bool equals(const T&amp; data, uintptr_t hash, const Entry* entry) {</span>
125     assert(entry-&gt;hash() == hash, &quot;invariant&quot;);
126     return true;
127   }
128 };
129 
130 // IdType must be scalar
131 template &lt;typename T, typename IdType&gt;
<a name="11" id="anc11"></a><span class="line-modified">132 class Entry : public JfrBasicHashtableEntry&lt;T&gt; {</span>
133  public:
<a name="12" id="anc12"></a>
134   typedef IdType ID;
<a name="13" id="anc13"></a><span class="line-removed">135   void init() { _id = 0; }</span>
136   ID id() const { return _id; }
<a name="14" id="anc14"></a><span class="line-modified">137   void set_id(ID id) { _id = id; }</span>
<span class="line-modified">138   void set_value(const T&amp; value) { this-&gt;set_literal(value); }</span>
<span class="line-modified">139   T&amp; value() const { return *const_cast&lt;Entry*&gt;(this)-&gt;literal_addr();}</span>
<span class="line-removed">140   const T* value_addr() const { return const_cast&lt;Entry*&gt;(this)-&gt;literal_addr(); }</span>
<span class="line-removed">141 </span>
142  private:
<a name="15" id="anc15"></a><span class="line-modified">143   ID _id;</span>
144 };
145 
146 template &lt;typename T, typename IdType, template &lt;typename, typename&gt; class Entry,
147           typename Callback = AscendingId&lt;IdType, Entry&lt;T, IdType&gt;, T&gt; ,
148           size_t TABLE_SIZE = 1009&gt;
149 class HashTableHost : public JfrBasicHashtable&lt;T&gt; {
150  public:
151   typedef Entry&lt;T, IdType&gt; HashEntry;
<a name="16" id="anc16"></a><span class="line-modified">152   HashTableHost() : _callback(new Callback()) {}</span>
<span class="line-modified">153   HashTableHost(Callback* cb) : JfrBasicHashtable&lt;T&gt;(TABLE_SIZE, sizeof(HashEntry)), _callback(cb) {}</span>
154   ~HashTableHost() {
155     this-&gt;clear_entries();
156     this-&gt;free_buckets();
157   }
158 
159   // direct insert assumes non-existing entry
<a name="17" id="anc17"></a><span class="line-modified">160   HashEntry&amp; put(const T&amp; data, uintptr_t hash);</span>
161 
162   // lookup entry, will put if not found
<a name="18" id="anc18"></a><span class="line-modified">163   HashEntry&amp; lookup_put(const T&amp; data, uintptr_t hash) {</span>
<span class="line-modified">164     HashEntry* entry = lookup_only(data, hash);</span>
<span class="line-modified">165     return entry == NULL ? put(data, hash) : *entry;</span>
166   }
167 
<a name="19" id="anc19"></a><span class="line-modified">168   // read-only lookup</span>
<span class="line-removed">169   HashEntry* lookup_only(const T&amp; query, uintptr_t hash);</span>
170 
171   // id retrieval
<a name="20" id="anc20"></a><span class="line-modified">172   IdType id(const T&amp; data, uintptr_t hash) {</span>
173     assert(data != NULL, &quot;invariant&quot;);
<a name="21" id="anc21"></a><span class="line-modified">174     const HashEntry&amp; entry = lookup_put(data, hash);</span>
175     assert(entry.id() &gt; 0, &quot;invariant&quot;);
176     return entry.id();
177   }
178 
179   template &lt;typename Functor&gt;
180   void iterate_value(Functor&amp; f);
181 
182   template &lt;typename Functor&gt;
183   void iterate_entry(Functor&amp; f);
184 
185   size_t cardinality() const { return this-&gt;number_of_entries(); }
186   bool has_entries() const { return this-&gt;cardinality() &gt; 0; }
187   void clear_entries();
188 
189   // removal and deallocation
190   void free_entry(HashEntry* entry) {
191     assert(entry != NULL, &quot;invariant&quot;);
192     JfrBasicHashtable&lt;T&gt;::unlink_entry(entry);
<a name="22" id="anc22"></a><span class="line-modified">193     FREE_C_HEAP_ARRAY(char, entry);</span>

194   }
195 
196  private:
197   Callback* _callback;
198   size_t index_for(uintptr_t hash) { return this-&gt;hash_to_index(hash); }
<a name="23" id="anc23"></a><span class="line-modified">199   HashEntry* new_entry(const T&amp; data, uintptr_t hash);</span>
200   void add_entry(size_t index, HashEntry* new_entry) {
201     assert(new_entry != NULL, &quot;invariant&quot;);
<a name="24" id="anc24"></a><span class="line-modified">202     _callback-&gt;assign_id(new_entry);</span>
203     assert(new_entry-&gt;id() &gt; 0, &quot;invariant&quot;);
204     JfrBasicHashtable&lt;T&gt;::add_entry(index, new_entry);
205   }
206 };
207 
208 template &lt;typename T, typename IdType, template &lt;typename, typename&gt; class Entry, typename Callback, size_t TABLE_SIZE&gt;
<a name="25" id="anc25"></a><span class="line-modified">209 Entry&lt;T, IdType&gt;&amp; HashTableHost&lt;T, IdType, Entry, Callback, TABLE_SIZE&gt;::put(const T&amp; data, uintptr_t hash) {</span>
<span class="line-modified">210   assert(lookup_only(data, hash) == NULL, &quot;use lookup_put()&quot;);</span>
<span class="line-modified">211   HashEntry* const entry = new_entry(data, hash);</span>
212   add_entry(index_for(hash), entry);
213   return *entry;
214 }
215 
216 template &lt;typename T, typename IdType, template &lt;typename, typename&gt; class Entry, typename Callback, size_t TABLE_SIZE&gt;
<a name="26" id="anc26"></a><span class="line-modified">217 Entry&lt;T, IdType&gt;* HashTableHost&lt;T, IdType, Entry, Callback, TABLE_SIZE&gt;::lookup_only(const T&amp; query, uintptr_t hash) {</span>
218   HashEntry* entry = (HashEntry*)this-&gt;bucket(index_for(hash));
219   while (entry != NULL) {
<a name="27" id="anc27"></a><span class="line-modified">220     if (entry-&gt;hash() == hash &amp;&amp; _callback-&gt;equals(query, hash, entry)) {</span>
221       return entry;
222     }
223     entry = (HashEntry*)entry-&gt;next();
224   }
225   return NULL;
226 }
227 
228 template &lt;typename T, typename IdType, template &lt;typename, typename&gt; class Entry, typename Callback, size_t TABLE_SIZE&gt;
229 template &lt;typename Functor&gt;
230 void HashTableHost&lt;T, IdType, Entry, Callback, TABLE_SIZE&gt;::iterate_value(Functor&amp; f) {
231   for (size_t i = 0; i &lt; this-&gt;table_size(); ++i) {
232     const HashEntry* entry = (const HashEntry*)this-&gt;bucket(i);
233     while (entry != NULL) {
234       if (!f(entry-&gt;value())) {
235         break;
236       }
237       entry = (HashEntry*)entry-&gt;next();
238     }
239   }
240 }
241 
242 template &lt;typename T, typename IdType, template &lt;typename, typename&gt; class Entry, typename Callback, size_t TABLE_SIZE&gt;
243 template &lt;typename Functor&gt;
244 void HashTableHost&lt;T, IdType, Entry, Callback, TABLE_SIZE&gt;::iterate_entry(Functor&amp; f) {
245   for (size_t i = 0; i &lt; this-&gt;table_size(); ++i) {
246     const HashEntry* entry = (const HashEntry*)this-&gt;bucket(i);
247     while (entry != NULL) {
248       if (!f(entry)) {
249         break;
250       }
251       entry = (const HashEntry*)entry-&gt;next();
252     }
253   }
254 }
255 
256 template &lt;typename T, typename IdType, template &lt;typename, typename&gt; class Entry, typename Callback, size_t TABLE_SIZE&gt;
257 void HashTableHost&lt;T, IdType, Entry, Callback, TABLE_SIZE&gt;::clear_entries() {
258   for (size_t i = 0; i &lt; this-&gt;table_size(); ++i) {
259     HashEntry** bucket = (HashEntry**)this-&gt;bucket_addr(i);
260     HashEntry* entry = *bucket;
261     while (entry != NULL) {
262       HashEntry* entry_to_remove = entry;
263       entry = (HashEntry*)entry-&gt;next();
264       this-&gt;free_entry(entry_to_remove);
265     }
266     *bucket = NULL;
267   }
268   assert(this-&gt;number_of_entries() == 0, &quot;should have removed all entries&quot;);
269 }
270 
271 template &lt;typename T, typename IdType, template &lt;typename, typename&gt; class Entry, typename Callback, size_t TABLE_SIZE&gt;
<a name="28" id="anc28"></a><span class="line-modified">272 Entry&lt;T, IdType&gt;* HashTableHost&lt;T, IdType, Entry, Callback, TABLE_SIZE&gt;::new_entry(const T&amp; data, uintptr_t hash) {</span>
273   assert(sizeof(HashEntry) == this-&gt;entry_size(), &quot;invariant&quot;);
<a name="29" id="anc29"></a><span class="line-modified">274   HashEntry* const entry = (HashEntry*) NEW_C_HEAP_ARRAY2(char, this-&gt;entry_size(), mtTracing, CURRENT_PC);</span>
<span class="line-modified">275   entry-&gt;init();</span>
<span class="line-removed">276   entry-&gt;set_hash(hash);</span>
<span class="line-removed">277   entry-&gt;set_value(data);</span>
<span class="line-removed">278   entry-&gt;set_next(NULL);</span>
279   assert(0 == entry-&gt;id(), &quot;invariant&quot;);
280   return entry;
281 }
282 
283 #endif // SHARE_JFR_UTILITIES_JFRHASHTABLE_HPP
<a name="30" id="anc30"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="30" type="hidden" />
</body>
</html>
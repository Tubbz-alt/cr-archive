<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/jfr/instrumentation/jfrEventClassTransformer.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classFileParser.hpp&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/javaClasses.inline.hpp&quot;
  30 #include &quot;classfile/moduleEntry.hpp&quot;
  31 #include &quot;classfile/modules.hpp&quot;
  32 #include &quot;classfile/stackMapTable.hpp&quot;
  33 #include &quot;classfile/verificationType.hpp&quot;
  34 #include &quot;interpreter/bytecodes.hpp&quot;
  35 #include &quot;jfr/instrumentation/jfrEventClassTransformer.hpp&quot;
  36 #include &quot;jfr/jfr.hpp&quot;
  37 #include &quot;jfr/jni/jfrJavaSupport.hpp&quot;
  38 #include &quot;jfr/jni/jfrUpcalls.hpp&quot;
  39 #include &quot;jfr/support/jfrEventClass.hpp&quot;
  40 #include &quot;jfr/utilities/jfrBigEndian.hpp&quot;
  41 #include &quot;jfr/writers/jfrBigEndianWriter.hpp&quot;
  42 #include &quot;logging/log.hpp&quot;
  43 #include &quot;memory/allocation.inline.hpp&quot;
  44 #include &quot;memory/resourceArea.hpp&quot;
  45 #include &quot;oops/array.hpp&quot;
  46 #include &quot;oops/constantPool.hpp&quot;
  47 #include &quot;oops/instanceKlass.hpp&quot;
  48 #include &quot;oops/method.hpp&quot;
  49 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  50 #include &quot;runtime/handles.inline.hpp&quot;
  51 #include &quot;runtime/os.hpp&quot;
  52 #include &quot;runtime/thread.inline.hpp&quot;
  53 #include &quot;utilities/exceptions.hpp&quot;
  54 #include &quot;utilities/globalDefinitions.hpp&quot;
  55 #include &quot;utilities/macros.hpp&quot;
  56 
  57 static const u2 number_of_new_methods = 5;
  58 static const u2 number_of_new_fields = 3;
  59 static const int extra_stream_bytes = 0x280;
  60 static const u2 invalid_cp_index = 0;
  61 
  62 static const char* utf8_constants[] = {
  63   &quot;Code&quot;,         // 0
  64   &quot;J&quot;,            // 1
  65   &quot;commit&quot;,       // 2
  66   &quot;eventHandler&quot;, // 3
  67   &quot;duration&quot;,     // 4
  68   &quot;begin&quot;,        // 5
  69   &quot;()V&quot;,          // 6
  70   &quot;isEnabled&quot;,    // 7
  71   &quot;()Z&quot;,          // 8
  72   &quot;end&quot;,          // 9
  73   &quot;shouldCommit&quot;, // 10
  74   &quot;startTime&quot;,    // 11 // LAST_REQUIRED_UTF8
  75   &quot;Ljdk/jfr/internal/handlers/EventHandler;&quot;, // 12
  76   &quot;Ljava/lang/Object;&quot;, // 13
  77   &quot;&lt;clinit&gt;&quot;,     // 14
  78   &quot;jdk/jfr/FlightRecorder&quot;, // 15
  79   &quot;register&quot;,     // 16
  80   &quot;(Ljava/lang/Class;)V&quot;, // 17
  81   &quot;StackMapTable&quot;, // 18
  82   &quot;Exceptions&quot;, // 19
  83   &quot;LineNumberTable&quot;, // 20
  84   &quot;LocalVariableTable&quot;, // 21
  85   &quot;LocalVariableTypeTable&quot;, // 22
  86   &quot;RuntimeVisibleAnnotation&quot;, // 23
  87 };
  88 
  89 enum utf8_req_symbols {
  90   UTF8_REQ_Code,
  91   UTF8_REQ_J_FIELD_DESC,
  92   UTF8_REQ_commit,
  93   UTF8_REQ_eventHandler,
  94   UTF8_REQ_duration,
  95   UTF8_REQ_begin,
  96   UTF8_REQ_EMPTY_VOID_METHOD_DESC,
  97   UTF8_REQ_isEnabled,
  98   UTF8_REQ_EMPTY_BOOLEAN_METHOD_DESC,
  99   UTF8_REQ_end,
 100   UTF8_REQ_shouldCommit,
 101   UTF8_REQ_startTime,
 102   NOF_UTF8_REQ_SYMBOLS
 103 };
 104 
 105 enum utf8_opt_symbols {
 106   UTF8_OPT_eventHandler_FIELD_DESC = NOF_UTF8_REQ_SYMBOLS,
 107   UTF8_OPT_LjavaLangObject,
 108   UTF8_OPT_clinit,
 109   UTF8_OPT_FlightRecorder,
 110   UTF8_OPT_register,
 111   UTF8_OPT_CLASS_VOID_METHOD_DESC,
 112   UTF8_OPT_StackMapTable,
 113   UTF8_OPT_Exceptions,
 114   UTF8_OPT_LineNumberTable,
 115   UTF8_OPT_LocalVariableTable,
 116   UTF8_OPT_LocalVariableTypeTable,
 117   UTF8_OPT_RuntimeVisibleAnnotation,
 118   NOF_UTF8_SYMBOLS
 119 };
 120 
 121 static u1 empty_void_method_code_attribute[] = {
 122   0x0,
 123   0x0,
 124   0x0,
 125   0xd, // attribute len
 126   0x0,
 127   0x0, // max stack
 128   0x0,
 129   0x1, // max locals
 130   0x0,
 131   0x0,
 132   0x0,
 133   0x1, // code length
 134   Bytecodes::_return,
 135   0x0,
 136   0x0, // ex table len
 137   0x0,
 138   0x0  // attributes_count
 139 };
 140 
 141 static u1 boolean_method_code_attribute[] = {
 142   0x0,
 143   0x0,
 144   0x0,
 145   0xe,
 146   0x0,
 147   0x1, // max stack
 148   0x0,
 149   0x1, // max locals
 150   0x0,
 151   0x0,
 152   0x0,
 153   0x2,
 154   Bytecodes::_iconst_0,
 155   Bytecodes::_ireturn,
 156   0x0,
 157   0x0, // ex table len
 158   0x0,
 159   0x0, // attributes_count
 160 };
 161 
 162 // annotation processing support
 163 
 164 enum {  // initial annotation layout
 165   atype_off = 0,      // utf8 such as &#39;Ljava/lang/annotation/Retention;&#39;
 166   count_off = 2,      // u2   such as 1 (one value)
 167   member_off = 4,     // utf8 such as &#39;value&#39;
 168   tag_off = 6,        // u1   such as &#39;c&#39; (type) or &#39;e&#39; (enum)
 169   e_tag_val = &#39;e&#39;,
 170   e_type_off = 7,   // utf8 such as &#39;Ljava/lang/annotation/RetentionPolicy;&#39;
 171   e_con_off = 9,    // utf8 payload, such as &#39;SOURCE&#39;, &#39;CLASS&#39;, &#39;RUNTIME&#39;
 172   e_size = 11,     // end of &#39;e&#39; annotation
 173   c_tag_val = &#39;c&#39;,    // payload is type
 174   c_con_off = 7,    // utf8 payload, such as &#39;I&#39;
 175   c_size = 9,       // end of &#39;c&#39; annotation
 176   s_tag_val = &#39;s&#39;,    // payload is String
 177   s_con_off = 7,    // utf8 payload, such as &#39;Ljava/lang/String;&#39;
 178   s_size = 9,
 179   min_size = 6        // smallest possible size (zero members)
 180 };
 181 
 182 static int skip_annotation_value(const address, int, int); // fwd decl
 183 
 184 // Skip an annotation.  Return &gt;=limit if there is any problem.
 185 static int next_annotation_index(const address buffer, int limit, int index) {
 186   assert(buffer != NULL, &quot;invariant&quot;);
 187   index += 2;  // skip atype
 188   if ((index += 2) &gt;= limit) {
 189     return limit;
 190   }
 191   int nof_members = JfrBigEndian::read&lt;u2&gt;(buffer + index - 2);
 192   while (--nof_members &gt;= 0 &amp;&amp; index &lt; limit) {
 193     index += 2; // skip member
 194     index = skip_annotation_value(buffer, limit, index);
 195   }
 196   return index;
 197 }
 198 
 199 // Skip an annotation value.  Return &gt;=limit if there is any problem.
 200 static int skip_annotation_value(const address buffer, int limit, int index) {
 201   assert(buffer != NULL, &quot;invariant&quot;);
 202   // value := switch (tag:u1) {
 203   //   case B, C, I, S, Z, D, F, J, c: con:u2;
 204   //   case e: e_class:u2 e_name:u2;
 205   //   case s: s_con:u2;
 206   //   case [: do(nval:u2) {value};
 207   //   case @: annotation;
 208   //   case s: s_con:u2;
 209   // }
 210   if ((index += 1) &gt;= limit) {
 211     return limit;
 212   }
 213   const u1 tag = buffer[index - 1];
 214   switch (tag) {
 215     case &#39;B&#39;:
 216     case &#39;C&#39;:
 217     case &#39;I&#39;:
 218     case &#39;S&#39;:
 219     case &#39;Z&#39;:
 220     case &#39;D&#39;:
 221     case &#39;F&#39;:
 222     case &#39;J&#39;:
 223     case &#39;c&#39;:
 224     case &#39;s&#39;:
 225       index += 2;  // skip con or s_con
 226       break;
 227     case &#39;e&#39;:
 228       index += 4;  // skip e_class, e_name
 229       break;
 230     case &#39;[&#39;:
 231       {
 232         if ((index += 2) &gt;= limit) {
 233           return limit;
 234         }
 235         int nof_values = JfrBigEndian::read&lt;u2&gt;(buffer + index - 2);
 236         while (--nof_values &gt;= 0 &amp;&amp; index &lt; limit) {
 237           index = skip_annotation_value(buffer, limit, index);
 238         }
 239       }
 240       break;
 241     case &#39;@&#39;:
 242       index = next_annotation_index(buffer, limit, index);
 243       break;
 244     default:
 245       return limit;  //  bad tag byte
 246   }
 247   return index;
 248 }
 249 
 250 static const u2 number_of_elements_offset = (u2)2;
 251 static const u2 element_name_offset = (u2)(number_of_elements_offset + 2);
 252 static const u2 element_name_size = (u2)2;
 253 static const u2 value_type_relative_offset = (u2)2;
 254 static const u2 value_relative_offset = (u2)(value_type_relative_offset + 1);
 255 
 256 // see JVMS - 4.7.16. The RuntimeVisibleAnnotations Attribute
 257 
 258 class AnnotationElementIterator : public StackObj {
 259  private:
 260   const InstanceKlass* _ik;
 261   const address _buffer;
 262   const u2 _limit; // length of annotation
 263   mutable u2 _current; // element
 264   mutable u2 _next; // element
 265   u2 value_index() const {
 266     return JfrBigEndian::read&lt;u2&gt;(_buffer + _current + value_relative_offset);
 267   }
 268 
 269  public:
 270   AnnotationElementIterator(const InstanceKlass* ik, address buffer, u2 limit) : _ik(ik),
 271                                                                                  _buffer(buffer),
 272                                                                                  _limit(limit),
 273                                                                                  _current(element_name_offset),
 274                                                                                  _next(element_name_offset) {
 275     assert(_buffer != NULL, &quot;invariant&quot;);
 276     assert(_next == element_name_offset, &quot;invariant&quot;);
 277     assert(_current == element_name_offset, &quot;invariant&quot;);
 278   }
 279 
 280   bool has_next() const {
 281     return _next &lt; _limit;
 282   }
 283 
 284   void move_to_next() const {
 285     assert(has_next(), &quot;invariant&quot;);
 286     _current = _next;
 287     if (_next &lt; _limit) {
 288       _next = skip_annotation_value(_buffer, _limit, _next + element_name_size);
 289     }
 290     assert(_next &lt;= _limit, &quot;invariant&quot;);
 291     assert(_current &lt;= _limit, &quot;invariant&quot;);
 292   }
 293 
 294   u2 number_of_elements() const {
 295     return JfrBigEndian::read&lt;u2&gt;(_buffer + number_of_elements_offset);
 296   }
 297 
 298   const Symbol* name() const {
 299     assert(_current &lt; _next, &quot;invariant&quot;);
 300     return _ik-&gt;constants()-&gt;symbol_at(JfrBigEndian::read&lt;u2&gt;(_buffer + _current));
 301   }
 302 
 303   char value_type() const {
 304     return JfrBigEndian::read&lt;u1&gt;(_buffer + _current + value_type_relative_offset);
 305   }
 306 
 307   jint read_int() const {
 308     return _ik-&gt;constants()-&gt;int_at(value_index());
 309   }
 310 
 311   bool read_bool() const {
 312     return read_int() != 0;
 313   }
 314 };
 315 
 316 class AnnotationIterator : public StackObj {
 317  private:
 318   const InstanceKlass* _ik;
 319   // ensure _limit field is declared before _buffer
 320   u2 _limit; // length of annotations array
 321   const address _buffer;
 322   mutable u2 _current; // annotation
 323   mutable u2 _next; // annotation
 324 
 325  public:
 326   AnnotationIterator(const InstanceKlass* ik, AnnotationArray* ar) : _ik(ik),
 327                                                                      _limit(ar != NULL ? ar-&gt;length() : 0),
 328                                                                      _buffer(_limit &gt; 2 ? ar-&gt;adr_at(2) : NULL),
 329                                                                      _current(0),
 330                                                                      _next(0) {
 331     if (_buffer != NULL) {
 332       _limit -= 2; // subtract sizeof(u2) number of annotations field
 333     }
 334   }
 335   bool has_next() const {
 336     return _next &lt; _limit;
 337   }
 338 
 339   void move_to_next() const {
 340     assert(has_next(), &quot;invariant&quot;);
 341     _current = _next;
 342     if (_next &lt; _limit) {
 343       _next = next_annotation_index(_buffer, _limit, _next);
 344     }
 345     assert(_next &lt;= _limit, &quot;invariant&quot;);
 346     assert(_current &lt;= _limit, &quot;invariant&quot;);
 347   }
 348   const AnnotationElementIterator elements() const {
 349     assert(_current &lt; _next, &quot;invariant&quot;);
 350     return AnnotationElementIterator(_ik, _buffer + _current, _next - _current);
 351   }
 352   const Symbol* type() const {
 353     assert(_buffer != NULL, &quot;invariant&quot;);
 354     assert(_current &lt; _limit, &quot;invariant&quot;);
 355     return _ik-&gt;constants()-&gt;symbol_at(JfrBigEndian::read&lt;u2&gt;(_buffer + _current));
 356   }
 357 };
 358 
 359 static unsigned int unused_hash = 0;
 360 static const char value_name[] = &quot;value&quot;;
 361 static bool has_annotation(const InstanceKlass* ik, const Symbol* annotation_type, bool&amp; value) {
 362   assert(annotation_type != NULL, &quot;invariant&quot;);
 363   AnnotationArray* class_annotations = ik-&gt;class_annotations();
 364   if (class_annotations == NULL) {
 365     return false;
 366   }
 367 
 368   const AnnotationIterator annotation_iterator(ik, class_annotations);
 369   while (annotation_iterator.has_next()) {
 370     annotation_iterator.move_to_next();
 371     if (annotation_iterator.type() == annotation_type) {
 372       // target annotation found
 373       static const Symbol* value_symbol =
 374         SymbolTable::lookup_only(value_name, sizeof value_name - 1, unused_hash);
 375       assert(value_symbol != NULL, &quot;invariant&quot;);
 376       const AnnotationElementIterator element_iterator = annotation_iterator.elements();
 377       while (element_iterator.has_next()) {
 378         element_iterator.move_to_next();
 379         if (value_symbol == element_iterator.name()) {
 380           // &quot;value&quot; element
 381           assert(&#39;Z&#39; == element_iterator.value_type(), &quot;invariant&quot;);
 382           value = element_iterator.read_bool();
 383           return true;
 384         }
 385       }
 386     }
 387   }
 388   return false;
 389 }
 390 
 391 // Evaluate to the value of the first found Symbol* annotation type.
 392 // Searching moves upwards in the klass hierarchy in order to support
 393 // inherited annotations in addition to the ability to override.
 394 static bool annotation_value(const InstanceKlass* ik, const Symbol* annotation_type, bool&amp; value) {
 395   assert(ik != NULL, &quot;invariant&quot;);
 396   assert(annotation_type != NULL, &quot;invariant&quot;);
 397   assert(JdkJfrEvent::is_a(ik), &quot;invariant&quot;);
 398   if (has_annotation(ik, annotation_type, value)) {
 399     return true;
 400   }
 401   InstanceKlass* const super = InstanceKlass::cast(ik-&gt;super());
 402   return super != NULL &amp;&amp; JdkJfrEvent::is_a(super) ? annotation_value(super, annotation_type, value) : false;
 403 }
 404 
 405 static const char jdk_jfr_module_name[] = &quot;jdk.jfr&quot;;
 406 
 407 static bool java_base_can_read_jdk_jfr() {
 408   static bool can_read = false;
 409   if (can_read) {
 410     return true;
 411   }
 412   static Symbol* jdk_jfr_module_symbol = NULL;
 413   if (jdk_jfr_module_symbol == NULL) {
 414     jdk_jfr_module_symbol = SymbolTable::lookup_only(jdk_jfr_module_name, sizeof jdk_jfr_module_name - 1, unused_hash);
 415     if (jdk_jfr_module_symbol == NULL) {
 416       return false;
 417     }
 418   }
 419   assert(jdk_jfr_module_symbol != NULL, &quot;invariant&quot;);
 420   ModuleEntryTable* const table = Modules::get_module_entry_table(Handle());
 421   assert(table != NULL, &quot;invariant&quot;);
 422   const ModuleEntry* const java_base_module = table-&gt;javabase_moduleEntry();
 423   if (java_base_module == NULL) {
 424     return false;
 425   }
 426   assert(java_base_module != NULL, &quot;invariant&quot;);
 427   ModuleEntry* const jdk_jfr_module = table-&gt;lookup_only(jdk_jfr_module_symbol);
 428   if (jdk_jfr_module == NULL) {
 429     return false;
 430   }
 431   assert(jdk_jfr_module != NULL, &quot;invariant&quot;);
 432   if (java_base_module-&gt;can_read(jdk_jfr_module)) {
 433     can_read = true;
 434   }
 435   return can_read;
 436 }
 437 
 438 static const char registered_constant[] = &quot;Ljdk/jfr/Registered;&quot;;
 439 
 440 // Evaluate to the value of the first found &quot;Ljdk/jfr/Registered;&quot; annotation.
 441 // Searching moves upwards in the klass hierarchy in order to support
 442 // inherited annotations in addition to the ability to override.
 443 static bool should_register_klass(const InstanceKlass* ik, bool&amp; untypedEventHandler) {
 444   assert(ik != NULL, &quot;invariant&quot;);
 445   assert(JdkJfrEvent::is_a(ik), &quot;invariant&quot;);
 446   assert(!untypedEventHandler, &quot;invariant&quot;);
 447   static const Symbol* registered_symbol = NULL;
 448   if (registered_symbol == NULL) {
 449     registered_symbol = SymbolTable::lookup_only(registered_constant, sizeof registered_constant - 1, unused_hash);
 450     if (registered_symbol == NULL) {
 451       untypedEventHandler = true;
 452       return false;
 453     }
 454   }
 455   assert(registered_symbol != NULL, &quot;invariant&quot;);
 456   bool value = false; // to be set by annotation_value
 457   untypedEventHandler = !(annotation_value(ik, registered_symbol, value) || java_base_can_read_jdk_jfr());
 458   return value;
 459 }
 460 
 461 /*
 462  * Map an utf8 constant back to its CONSTANT_UTF8_INFO
 463  */
 464 static u2 utf8_info_index(const InstanceKlass* ik, const Symbol* const target, TRAPS) {
 465   assert(target != NULL, &quot;invariant&quot;);
 466   const ConstantPool* cp = ik-&gt;constants();
 467   const int cp_len = cp-&gt;length();
 468   for (u2 index = 1; index &lt; cp_len; ++index) {
 469     const constantTag tag = cp-&gt;tag_at(index);
 470     if (tag.is_utf8()) {
 471       const Symbol* const utf8_sym = cp-&gt;symbol_at(index);
 472       assert(utf8_sym != NULL, &quot;invariant&quot;);
 473       if (utf8_sym == target) {
 474         return index;
 475       }
 476     }
 477   }
 478   // not in constant pool
 479   return invalid_cp_index;
 480 }
 481 
 482 #ifdef ASSERT
 483 static bool is_index_within_range(u2 index, u2 orig_cp_len, u2 new_cp_entries_len) {
 484   return index &gt; 0 &amp;&amp; index &lt; orig_cp_len + new_cp_entries_len;
 485 }
 486 #endif
 487 
 488 static u2 add_utf8_info(JfrBigEndianWriter&amp; writer, const char* utf8_constant, u2 orig_cp_len, u2&amp; new_cp_entries_len) {
 489   assert(utf8_constant != NULL, &quot;invariant&quot;);
 490   writer.write&lt;u1&gt;(JVM_CONSTANT_Utf8);
 491   writer.write_utf8_u2_len(utf8_constant);
 492   assert(writer.is_valid(), &quot;invariant&quot;);
 493   // return index for the added utf8 info
 494   return orig_cp_len + new_cp_entries_len++;
 495 }
 496 
 497 static u2 add_method_ref_info(JfrBigEndianWriter&amp; writer,
 498                               u2 cls_name_index,
 499                               u2 method_index,
 500                               u2 desc_index,
 501                               u2 orig_cp_len,
 502                               u2&amp; number_of_new_constants,
 503                               TRAPS) {
 504   assert(cls_name_index != invalid_cp_index, &quot;invariant&quot;);
 505   assert(method_index != invalid_cp_index, &quot;invariant&quot;);
 506   assert(desc_index != invalid_cp_index, &quot;invariant&quot;);
 507   assert(is_index_within_range(cls_name_index, orig_cp_len, number_of_new_constants), &quot;invariant&quot;);
 508   assert(is_index_within_range(method_index, orig_cp_len, number_of_new_constants), &quot;invariant&quot;);
 509   assert(is_index_within_range(desc_index, orig_cp_len, number_of_new_constants), &quot;invariant&quot;);
 510   writer.write&lt;u1&gt;(JVM_CONSTANT_Class);
 511   writer.write&lt;u2&gt;(cls_name_index);
 512   const u2 cls_entry_index = orig_cp_len + number_of_new_constants;
 513   ++number_of_new_constants;
 514   writer.write&lt;u1&gt;(JVM_CONSTANT_NameAndType);
 515   writer.write&lt;u2&gt;(method_index);
 516   writer.write&lt;u2&gt;(desc_index);
 517   const u2 nat_entry_index = orig_cp_len + number_of_new_constants;
 518   ++number_of_new_constants;
 519   writer.write&lt;u1&gt;(JVM_CONSTANT_Methodref);
 520   writer.write&lt;u2&gt;(cls_entry_index);
 521   writer.write&lt;u2&gt;(nat_entry_index);
 522   // post-increment number_of_new_constants
 523   // value returned is the index to the added method_ref
 524   return orig_cp_len + number_of_new_constants++;
 525 }
 526 
 527 static u2 add_flr_register_method_constants(JfrBigEndianWriter&amp; writer,
 528                                             const u2* utf8_indexes,
 529                                             u2 orig_cp_len,
 530                                             u2&amp; number_of_new_constants,
 531                                             TRAPS) {
 532   assert(utf8_indexes != NULL, &quot;invariant&quot;);
 533   return add_method_ref_info(writer,
 534                              utf8_indexes[UTF8_OPT_FlightRecorder],
 535                              utf8_indexes[UTF8_OPT_register],
 536                              utf8_indexes[UTF8_OPT_CLASS_VOID_METHOD_DESC],
 537                              orig_cp_len,
 538                              number_of_new_constants,
 539                              THREAD);
 540 }
 541 
 542 /*
 543  * field_info {
 544  *   u2             access_flags;
 545  *   u2             name_index;
 546  *   u2             descriptor_index;
 547  *   u2             attributes_count;
 548  *   attribute_info attributes[attributes_count];
 549  * }
 550  */
 551 static jlong add_field_info(JfrBigEndianWriter&amp; writer, u2 name_index, u2 desc_index, bool is_static = false) {
 552   assert(name_index != invalid_cp_index, &quot;invariant&quot;);
 553   assert(desc_index != invalid_cp_index, &quot;invariant&quot;);
 554   DEBUG_ONLY(const jlong start_offset = writer.current_offset();)
 555   writer.write&lt;u2&gt;(JVM_ACC_SYNTHETIC | JVM_ACC_PRIVATE | (is_static ? JVM_ACC_STATIC : JVM_ACC_TRANSIENT)); // flags
 556   writer.write(name_index);
 557   writer.write(desc_index);
 558   writer.write((u2)0x0); // attributes_count
 559   assert(writer.is_valid(), &quot;invariant&quot;);
 560   DEBUG_ONLY(assert(start_offset + 8 == writer.current_offset(), &quot;invariant&quot;);)
 561   return writer.current_offset();
 562 }
 563 
 564 static u2 add_field_infos(JfrBigEndianWriter&amp; writer, const u2* utf8_indexes, bool untypedEventHandler) {
 565   assert(utf8_indexes != NULL, &quot;invariant&quot;);
 566   add_field_info(writer,
 567                  utf8_indexes[UTF8_REQ_eventHandler],
 568                  untypedEventHandler ? utf8_indexes[UTF8_OPT_LjavaLangObject] : utf8_indexes[UTF8_OPT_eventHandler_FIELD_DESC],
 569                  true); // static
 570 
 571   add_field_info(writer,
 572                  utf8_indexes[UTF8_REQ_startTime],
 573                  utf8_indexes[UTF8_REQ_J_FIELD_DESC]);
 574 
 575   add_field_info(writer,
 576                  utf8_indexes[UTF8_REQ_duration],
 577                  utf8_indexes[UTF8_REQ_J_FIELD_DESC]);
 578 
 579   return number_of_new_fields;
 580 }
 581 
 582 /*
 583  * method_info {
 584  *  u2             access_flags;
 585  *  u2             name_index;
 586  *  u2             descriptor_index;
 587  *  u2             attributes_count;
 588  *  attribute_info attributes[attributes_count];
 589  * }
 590  *
 591  * Code_attribute {
 592  *   u2 attribute_name_index;
 593  *   u4 attribute_length;
 594  *   u2 max_stack;
 595  *   u2 max_locals;
 596  *   u4 code_length;
 597  *   u1 code[code_length];
 598  *   u2 exception_table_length;
 599  *   {   u2 start_pc;
 600  *       u2 end_pc;
 601  *       u2 handler_pc;
 602  *       u2 catch_type;
 603  *   } exception_table[exception_table_length];
 604  *   u2 attributes_count;
 605  *   attribute_info attributes[attributes_count];
 606  * }
 607  */
 608 
 609 static jlong add_method_info(JfrBigEndianWriter&amp; writer,
 610                              u2 name_index,
 611                              u2 desc_index,
 612                              u2 code_index,
 613                              const u1* const code,
 614                              const size_t code_len) {
 615   assert(name_index &gt; 0, &quot;invariant&quot;);
 616   assert(desc_index &gt; 0, &quot;invariant&quot;);
 617   assert(code_index &gt; 0, &quot;invariant&quot;);
 618   DEBUG_ONLY(const jlong start_offset = writer.current_offset();)
 619   writer.write&lt;u2&gt;(JVM_ACC_SYNTHETIC | JVM_ACC_PUBLIC); // flags
 620   writer.write(name_index);
 621   writer.write(desc_index);
 622   writer.write&lt;u2&gt;(0x1); // attributes_count ; 1 for &quot;Code&quot; attribute
 623   assert(writer.is_valid(), &quot;invariant&quot;);
 624   DEBUG_ONLY(assert(start_offset + 8 == writer.current_offset(), &quot;invariant&quot;);)
 625   // Code attribute
 626   writer.write(code_index); // &quot;Code&quot;
 627   writer.bytes(code, code_len);
 628   DEBUG_ONLY(assert((start_offset + 8 + 2 + (jlong)code_len) == writer.current_offset(), &quot;invariant&quot;);)
 629   return writer.current_offset();
 630 }
 631 
 632 /*
 633  * On return, the passed stream will be positioned
 634  * just after the constant pool section in the classfile
 635  * and the cp length is returned.
 636  *
 637  * Stream should come in at the start position.
 638  */
 639 static u2 position_stream_after_cp(const ClassFileStream* stream) {
 640   assert(stream != NULL, &quot;invariant&quot;);
 641   assert(stream-&gt;current_offset() == 0, &quot;invariant&quot;);
 642   stream-&gt;skip_u4_fast(2);  // 8 bytes skipped
 643   const u2 cp_len = stream-&gt;get_u2_fast();
 644   assert(cp_len &gt; 0, &quot;invariant&quot;);
 645   // now spin the stream position to just after the constant pool
 646   for (u2 index = 1; index &lt; cp_len; ++index) {
 647     const u1 tag = stream-&gt;get_u1_fast(); // cp tag
 648     switch (tag) {
 649       case JVM_CONSTANT_Class:
 650       case JVM_CONSTANT_String: {
 651         stream-&gt;skip_u2_fast(1); // skip 2 bytes
 652         continue;
 653       }
 654       case JVM_CONSTANT_Fieldref:
 655       case JVM_CONSTANT_Methodref:
 656       case JVM_CONSTANT_InterfaceMethodref:
 657       case JVM_CONSTANT_Integer:
 658       case JVM_CONSTANT_Float:
 659       case JVM_CONSTANT_NameAndType:
 660       case JVM_CONSTANT_InvokeDynamic: {
 661         stream-&gt;skip_u4_fast(1); // skip 4 bytes
 662         continue;
 663       }
 664       case JVM_CONSTANT_Long:
 665       case JVM_CONSTANT_Double: {
 666         stream-&gt;skip_u4_fast(2); // skip 8 bytes
 667         // Skip entry following eigth-byte constant, see JVM book p. 98
 668         ++index;
 669         continue;
 670       }
 671       case JVM_CONSTANT_Utf8: {
 672         u2 utf8_length = stream-&gt;get_u2_fast();
 673         stream-&gt;skip_u1_fast(utf8_length); // skip 2 + len bytes
 674         continue;
 675       }
 676       case JVM_CONSTANT_MethodHandle:
 677       case JVM_CONSTANT_MethodType: {
 678         if (tag == JVM_CONSTANT_MethodHandle) {
 679           stream-&gt;skip_u1_fast(1);
 680           stream-&gt;skip_u2_fast(1); // skip 3 bytes
 681         }
 682         else if (tag == JVM_CONSTANT_MethodType) {
 683           stream-&gt;skip_u2_fast(1); // skip 3 bytes
 684         }
 685       }
 686       continue;
 687       default:
 688         assert(false, &quot;error in skip logic!&quot;);
 689         break;
 690     } // end switch(tag)
 691   }
 692   return cp_len;
 693 }
 694 
 695 /*
 696 * On return, the passed stream will be positioned
 697 * just after the fields section in the classfile
 698 * and the number of fields will be returned.
 699 *
 700 * Stream should come in positioned just before fields_count
 701 */
 702 static u2 position_stream_after_fields(const ClassFileStream* stream) {
 703   assert(stream != NULL, &quot;invariant&quot;);
 704   assert(stream-&gt;current_offset() &gt; 0, &quot;invariant&quot;);
 705   // fields len
 706   const u2 orig_fields_len = stream-&gt;get_u2_fast();
 707   // fields
 708   for (u2 i = 0; i &lt; orig_fields_len; ++i) {
 709     stream-&gt;skip_u2_fast(3);
 710     const u2 attrib_info_len = stream-&gt;get_u2_fast();
 711     for (u2 j = 0; j &lt; attrib_info_len; ++j) {
 712       stream-&gt;skip_u2_fast(1);
 713       const u4 attrib_len = stream-&gt;get_u4_fast();
 714       stream-&gt;skip_u1_fast(attrib_len);
 715     }
 716   }
 717   return orig_fields_len;
 718 }
 719 
 720 /*
 721 * On return, the passed stream will be positioned
 722 * just after the methods section in the classfile
 723 * and the number of methods will be returned.
 724 *
 725 * Stream should come in positioned just before methods_count
 726 */
 727 static u2 position_stream_after_methods(JfrBigEndianWriter&amp; writer,
 728                                         const ClassFileStream* stream,
 729                                         const u2* utf8_indexes,
 730                                         bool register_klass,
 731                                         const Method* clinit_method,
 732                                         u4&amp; orig_method_len_offset) {
 733   assert(stream != NULL, &quot;invariant&quot;);
 734   assert(stream-&gt;current_offset() &gt; 0, &quot;invariant&quot;);
 735   assert(utf8_indexes != NULL, &quot;invariant&quot;);
 736   // We will come back to this location when we
 737   // know how many methods there will be.
 738   writer.reserve(sizeof(u2));
 739   const u2 orig_methods_len = stream-&gt;get_u2_fast();
 740   // Move copy position past original method_count
 741   // in order to not copy the original count
 742   orig_method_len_offset += sizeof(u2);
 743   for (u2 i = 0; i &lt; orig_methods_len; ++i) {
 744     const u4 method_offset = stream-&gt;current_offset();
 745     stream-&gt;skip_u2_fast(1); // Access Flags
 746     const u2 name_index = stream-&gt;get_u2_fast(); // Name index
 747     stream-&gt;skip_u2_fast(1); // Descriptor index
 748     const u2 attributes_count = stream-&gt;get_u2_fast();
 749     for (u2 j = 0; j &lt; attributes_count; ++j) {
 750       stream-&gt;skip_u2_fast(1);
 751       const u4 attrib_len = stream-&gt;get_u4_fast();
 752       stream-&gt;skip_u1_fast(attrib_len);
 753     }
 754     if (clinit_method != NULL &amp;&amp; name_index == clinit_method-&gt;name_index()) {
 755       // The method just parsed is an existing &lt;clinit&gt; method.
 756       // If the class has the @Registered(false) annotation, i.e. marking a class
 757       // for opting out from automatic registration, then we do not need to do anything.
 758       if (!register_klass) {
 759         continue;
 760       }
 761       // Automatic registration with the jfr system is acccomplished
 762       // by pre-pending code to the &lt;clinit&gt; method of the class.
 763       // We will need to re-create a new &lt;clinit&gt; in a later step.
 764       // For now, ensure that this method is excluded from the methods
 765       // being copied.
 766       writer.bytes(stream-&gt;buffer() + orig_method_len_offset,
 767                    method_offset - orig_method_len_offset);
 768       assert(writer.is_valid(), &quot;invariant&quot;);
 769 
 770       // Update copy position to skip copy of &lt;clinit&gt; method
 771       orig_method_len_offset = stream-&gt;current_offset();
 772     }
 773   }
 774   return orig_methods_len;
 775 }
 776 
 777 static u2 add_method_infos(JfrBigEndianWriter&amp; writer, const u2* utf8_indexes) {
 778   assert(utf8_indexes != NULL, &quot;invariant&quot;);
 779   add_method_info(writer,
 780                   utf8_indexes[UTF8_REQ_begin],
 781                   utf8_indexes[UTF8_REQ_EMPTY_VOID_METHOD_DESC],
 782                   utf8_indexes[UTF8_REQ_Code],
 783                   empty_void_method_code_attribute,
 784                   sizeof(empty_void_method_code_attribute));
 785 
 786   assert(writer.is_valid(), &quot;invariant&quot;);
 787 
 788   add_method_info(writer,
 789                   utf8_indexes[UTF8_REQ_end],
 790                   utf8_indexes[UTF8_REQ_EMPTY_VOID_METHOD_DESC],
 791                   utf8_indexes[UTF8_REQ_Code],
 792                   empty_void_method_code_attribute,
 793                   sizeof(empty_void_method_code_attribute));
 794 
 795   assert(writer.is_valid(), &quot;invariant&quot;);
 796 
 797   add_method_info(writer,
 798                   utf8_indexes[UTF8_REQ_commit],
 799                   utf8_indexes[UTF8_REQ_EMPTY_VOID_METHOD_DESC],
 800                   utf8_indexes[UTF8_REQ_Code],
 801                   empty_void_method_code_attribute,
 802                   sizeof(empty_void_method_code_attribute));
 803 
 804   assert(writer.is_valid(), &quot;invariant&quot;);
 805 
 806   add_method_info(writer,
 807                   utf8_indexes[UTF8_REQ_isEnabled],
 808                   utf8_indexes[UTF8_REQ_EMPTY_BOOLEAN_METHOD_DESC],
 809                   utf8_indexes[UTF8_REQ_Code],
 810                   boolean_method_code_attribute,
 811                   sizeof(boolean_method_code_attribute));
 812 
 813   assert(writer.is_valid(), &quot;invariant&quot;);
 814 
 815   add_method_info(writer,
 816                   utf8_indexes[UTF8_REQ_shouldCommit],
 817                   utf8_indexes[UTF8_REQ_EMPTY_BOOLEAN_METHOD_DESC],
 818                   utf8_indexes[UTF8_REQ_Code],
 819                   boolean_method_code_attribute,
 820                   sizeof(boolean_method_code_attribute));
 821   assert(writer.is_valid(), &quot;invariant&quot;);
 822   return number_of_new_methods;
 823 }
 824 
 825 static void adjust_exception_table(JfrBigEndianWriter&amp; writer, u2 bci_adjustment_offset, const Method* method, TRAPS) {
 826   const u2 ex_table_length = method != NULL ? (u2)method-&gt;exception_table_length() : 0;
 827   writer.write&lt;u2&gt;(ex_table_length); // Exception table length
 828   if (ex_table_length &gt; 0) {
 829     assert(method != NULL, &quot;invariant&quot;);
 830     const ExceptionTableElement* const ex_elements = method-&gt;exception_table_start();
 831     for (int i = 0; i &lt; ex_table_length; ++i) {
 832       assert(ex_elements != NULL, &quot;invariant&quot;);
 833       writer.write&lt;u2&gt;(ex_elements[i].start_pc + bci_adjustment_offset);
 834       writer.write&lt;u2&gt;(ex_elements[i].end_pc + bci_adjustment_offset);
 835       writer.write&lt;u2&gt;(ex_elements[i].handler_pc + bci_adjustment_offset);
 836       writer.write&lt;u2&gt;(ex_elements[i].catch_type_index); // no adjustment
 837     }
 838   }
 839 }
 840 
 841 enum StackMapFrameTypes {
 842   SAME_FRAME_BEGIN = 0,
 843   SAME_FRAME_END = 63,
 844   SAME_LOCALS_1_STACK_ITEM_FRAME_BEGIN = 64,
 845   SAME_LOCALS_1_STACK_ITEM_FRAME_END = 127,
 846   SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247,
 847   CHOP_FRAME_BEGIN = 248,
 848   CHOP_FRAME_END = 250,
 849   SAME_FRAME_EXTENDED = 251,
 850   APPEND_FRAME_BEGIN = 252,
 851   APPEND_FRAME_END = 254,
 852   FULL_FRAME = 255
 853 };
 854 
 855 static void adjust_stack_map(JfrBigEndianWriter&amp; writer,
 856                              Array&lt;u1&gt;* stack_map,
 857                              const u2* utf8_indexes,
 858                              u2 bci_adjustment_offset,
 859                              TRAPS) {
 860   assert(stack_map != NULL, &quot;invariant&quot;);
 861   assert(utf8_indexes != NULL, &quot;invariant&quot;);
 862   writer.write&lt;u2&gt;(utf8_indexes[UTF8_OPT_StackMapTable]);
 863   const jlong stack_map_attrib_len_offset = writer.current_offset();
 864   writer.reserve(sizeof(u4));
 865   StackMapStream stream(stack_map);
 866   const u2 stack_map_entries = stream.get_u2(THREAD);
 867   // number of entries
 868   writer.write&lt;u2&gt;(stack_map_entries); // new stack map entry added
 869   const u1 frame_type = stream.get_u1(THREAD);
 870   // SAME_FRAME and SAME_LOCALS_1_STACK_ITEM_FRAME encode
 871   // their offset_delta into the actual frame type itself.
 872   // If such a frame type is the first frame, then we transform
 873   // it to a SAME_FRAME_EXTENDED or a SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED frame.
 874   // This is done in order to not overflow frame types accidentally
 875   // when adjusting the offset_delta. In changing the frame types,
 876   // we can work with an explicit u2 offset_delta field (like the other frame types)
 877   if (frame_type &lt;= SAME_FRAME_END) {
 878     writer.write&lt;u1&gt;(SAME_FRAME_EXTENDED);
 879     writer.write&lt;u2&gt;(frame_type + bci_adjustment_offset);
 880   } else if (frame_type &gt;= SAME_LOCALS_1_STACK_ITEM_FRAME_BEGIN &amp;&amp;
 881              frame_type &lt;= SAME_LOCALS_1_STACK_ITEM_FRAME_END) {
 882     writer.write&lt;u1&gt;(SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED);
 883     writer.write&lt;u2&gt;((frame_type - SAME_LOCALS_1_STACK_ITEM_FRAME_BEGIN) + bci_adjustment_offset);
 884   } else if (frame_type &gt;= SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {
 885       // SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED to FULL_FRAME
 886       // has a u2 offset_delta field
 887       writer.write&lt;u1&gt;(frame_type);
 888       writer.write&lt;u2&gt;(stream.get_u2(THREAD) + bci_adjustment_offset);
 889   } else {
 890     assert(false, &quot;stackMapFrame type is invalid&quot;);
 891   }
 892 
 893   while (!stream.at_end()) {
 894     writer.write&lt;u1&gt;(stream.get_u1(THREAD));
 895   }
 896 
 897   u4 stack_map_attrib_len = writer.current_offset() - stack_map_attrib_len_offset;
 898   // the stack_map_table_attributes_length value is exclusive
 899   stack_map_attrib_len -= sizeof(u4);
 900   writer.write_at_offset(stack_map_attrib_len, stack_map_attrib_len_offset);
 901 }
 902 
 903 static void adjust_line_number_table(JfrBigEndianWriter&amp; writer,
 904                                      const u2* utf8_indexes,
 905                                      u4 bci_adjustement_offset,
 906                                      const Method* method,
 907                                      TRAPS) {
 908   assert(utf8_indexes != NULL, &quot;invariant&quot;);
 909   assert(method != NULL, &quot;invariant&quot;);
 910   assert(method-&gt;has_linenumber_table(), &quot;invariant&quot;);
 911   writer.write(utf8_indexes[UTF8_OPT_LineNumberTable]);
 912   const jlong lnt_attributes_length_offset = writer.current_offset();
 913   writer.reserve(sizeof(u4));
 914   const jlong lnt_attributes_entries_offset = writer.current_offset();
 915   writer.reserve(sizeof(u2));
 916   u1* lnt = method-&gt;compressed_linenumber_table();
 917   CompressedLineNumberReadStream lnt_stream(lnt);
 918   u2 line_number_table_entries = 0;
 919   while (lnt_stream.read_pair()) {
 920     ++line_number_table_entries;
 921     const u2 bci = (u2)lnt_stream.bci();
 922     writer.write&lt;u2&gt;(bci + (u2)bci_adjustement_offset);
 923     writer.write&lt;u2&gt;((u2)lnt_stream.line());
 924   }
 925   writer.write_at_offset(line_number_table_entries, lnt_attributes_entries_offset);
 926   u4 lnt_table_attributes_len = writer.current_offset() - lnt_attributes_length_offset;
 927   // the line_number_table_attributes_length value is exclusive
 928   lnt_table_attributes_len -= sizeof(u4);
 929   writer.write_at_offset(lnt_table_attributes_len, lnt_attributes_length_offset);
 930 }
 931 
 932 // returns the number of lvtt entries
 933 static u2 adjust_local_variable_table(JfrBigEndianWriter&amp; writer,
 934                                       const u2* utf8_indexes,
 935                                       u2 bci_adjustment_offset,
 936                                       const Method* method,
 937                                       TRAPS) {
 938   assert(utf8_indexes != NULL, &quot;invariant&quot;);
 939   assert(method != NULL, &quot;invariant&quot;);
 940   assert(method-&gt;has_localvariable_table(), &quot;invariant&quot;);
 941   writer.write&lt;u2&gt;(utf8_indexes[UTF8_OPT_LocalVariableTable]);
 942   const jlong lvt_attributes_length_offset = writer.current_offset();
 943   writer.reserve(sizeof(u4));
 944   const int lvt_len = method-&gt;localvariable_table_length();
 945   writer.write&lt;u2&gt;((u2)lvt_len);
 946   const LocalVariableTableElement* table = method-&gt;localvariable_table_start();
 947   assert(table != NULL, &quot;invariant&quot;);
 948   u2 num_lvtt_entries = 0;
 949   for (int i = 0; i &lt; lvt_len; ++i) {
 950     writer.write&lt;u2&gt;(table[i].start_bci + bci_adjustment_offset);
 951     writer.write&lt;u2&gt;(table[i].length);
 952     writer.write&lt;u2&gt;(table[i].name_cp_index);
 953     writer.write&lt;u2&gt;(table[i].descriptor_cp_index);
 954     writer.write&lt;u2&gt;(table[i].slot);
 955     if (table[i].signature_cp_index &gt; 0) {
 956       ++num_lvtt_entries;
 957     }
 958   }
 959   u4 lvt_table_attributes_len = writer.current_offset() - lvt_attributes_length_offset;
 960   // the lvt_table_attributes_length value is exclusive
 961   lvt_table_attributes_len -= sizeof(u4);
 962   writer.write_at_offset(lvt_table_attributes_len, lvt_attributes_length_offset);
 963   return num_lvtt_entries;
 964 }
 965 
 966 static void adjust_local_variable_type_table(JfrBigEndianWriter&amp; writer,
 967                                             const u2* utf8_indexes,
 968                                             u2 bci_adjustment_offset,
 969                                             u2 num_lvtt_entries,
 970                                             const Method* method,
 971                                             TRAPS) {
 972   assert(num_lvtt_entries &gt; 0, &quot;invariant&quot;);
 973   writer.write&lt;u2&gt;(utf8_indexes[UTF8_OPT_LocalVariableTypeTable]);
 974   const jlong lvtt_attributes_length_offset = writer.current_offset();
 975   writer.reserve(sizeof(u4));
 976   writer.write&lt;u2&gt;(num_lvtt_entries);
 977   const LocalVariableTableElement* table = method-&gt;localvariable_table_start();
 978   assert(table != NULL, &quot;invariant&quot;);
 979   const int lvt_len = method-&gt;localvariable_table_length();
 980   for (int i = 0; i &lt; lvt_len; ++i) {
 981     if (table[i].signature_cp_index &gt; 0) {
 982       writer.write&lt;u2&gt;(table[i].start_bci + bci_adjustment_offset);
 983       writer.write&lt;u2&gt;(table[i].length);
 984       writer.write&lt;u2&gt;(table[i].name_cp_index);
 985       writer.write&lt;u2&gt;(table[i].signature_cp_index);
 986       writer.write&lt;u2&gt;(table[i].slot);
 987     }
 988   }
 989   u4 lvtt_table_attributes_len = writer.current_offset() - lvtt_attributes_length_offset;
 990   // the lvtt_table_attributes_length value is exclusive
 991   lvtt_table_attributes_len -= sizeof(u4);
 992   writer.write_at_offset(lvtt_table_attributes_len, lvtt_attributes_length_offset);
 993 }
 994 
 995 static void adjust_code_attributes(JfrBigEndianWriter&amp; writer,
 996                                    const u2* utf8_indexes,
 997                                    u2 bci_adjustment_offset,
 998                                    const Method* clinit_method,
 999                                    TRAPS) {
1000   // &quot;Code&quot; attributes
1001   assert(utf8_indexes != NULL, &quot;invariant&quot;);
1002   const jlong code_attributes_offset = writer.current_offset();
1003   writer.reserve(sizeof(u2));
1004   u2 number_of_code_attributes = 0;
1005   if (clinit_method != NULL) {
1006     Array&lt;u1&gt;* stack_map = clinit_method-&gt;stackmap_data();
1007     if (stack_map != NULL) {
1008       ++number_of_code_attributes;
1009       adjust_stack_map(writer, stack_map, utf8_indexes, bci_adjustment_offset, THREAD);
1010       assert(writer.is_valid(), &quot;invariant&quot;);
1011     }
1012     if (clinit_method != NULL &amp;&amp; clinit_method-&gt;has_linenumber_table()) {
1013       ++number_of_code_attributes;
1014       adjust_line_number_table(writer, utf8_indexes, bci_adjustment_offset, clinit_method, THREAD);
1015       assert(writer.is_valid(), &quot;invariant&quot;);
1016     }
1017     if (clinit_method != NULL &amp;&amp; clinit_method-&gt;has_localvariable_table()) {
1018       ++number_of_code_attributes;
1019       const u2 num_of_lvtt_entries = adjust_local_variable_table(writer, utf8_indexes, bci_adjustment_offset, clinit_method, THREAD);
1020       assert(writer.is_valid(), &quot;invariant&quot;);
1021       if (num_of_lvtt_entries &gt; 0) {
1022         ++number_of_code_attributes;
1023         adjust_local_variable_type_table(writer, utf8_indexes, bci_adjustment_offset, num_of_lvtt_entries, clinit_method, THREAD);
1024         assert(writer.is_valid(), &quot;invariant&quot;);
1025       }
1026     }
1027   }
1028 
1029   // Store the number of code_attributes
1030   writer.write_at_offset(number_of_code_attributes, code_attributes_offset);
1031 }
1032 
1033 static jlong insert_clinit_method(const InstanceKlass* ik,
1034                                   const ClassFileParser&amp; parser,
1035                                   JfrBigEndianWriter&amp; writer,
1036                                   u2 orig_constant_pool_len,
1037                                   const u2* utf8_indexes,
1038                                   const u2 register_method_ref_index,
1039                                   const Method* clinit_method,
1040                                   TRAPS) {
1041   assert(utf8_indexes != NULL, &quot;invariant&quot;);
1042   // The injected code length is always this value.
1043   // This is to ensure that padding can be done
1044   // where needed and to simplify size calculations.
1045   static const u2 injected_code_length = 8;
1046   const u2 name_index = utf8_indexes[UTF8_OPT_clinit];
1047   assert(name_index != invalid_cp_index, &quot;invariant&quot;);
1048   const u2 desc_index = utf8_indexes[UTF8_REQ_EMPTY_VOID_METHOD_DESC];
1049   const u2 max_stack = MAX2(clinit_method != NULL ? clinit_method-&gt;verifier_max_stack() : 1, 1);
1050   const u2 max_locals = MAX2(clinit_method != NULL ? clinit_method-&gt;max_locals() : 0, 0);
1051   const u2 orig_bytecodes_length = clinit_method != NULL ? (u2)clinit_method-&gt;code_size() : 0;
1052   const address orig_bytecodes = clinit_method != NULL ? clinit_method-&gt;code_base() : NULL;
1053   const u2 new_code_length = injected_code_length + orig_bytecodes_length;
1054   DEBUG_ONLY(const jlong start_offset = writer.current_offset();)
1055   writer.write&lt;u2&gt;(JVM_ACC_STATIC); // flags
1056   writer.write&lt;u2&gt;(name_index);
1057   writer.write&lt;u2&gt;(desc_index);
1058   writer.write&lt;u2&gt;((u2)0x1); // attributes_count // &quot;Code&quot;
1059   assert(writer.is_valid(), &quot;invariant&quot;);
1060   DEBUG_ONLY(assert(start_offset + 8 == writer.current_offset(), &quot;invariant&quot;);)
1061   // &quot;Code&quot; attribute
1062   writer.write&lt;u2&gt;(utf8_indexes[UTF8_REQ_Code]); // &quot;Code&quot;
1063   const jlong code_attribute_length_offset = writer.current_offset();
1064   writer.reserve(sizeof(u4));
1065   writer.write&lt;u2&gt;(max_stack); // max stack
1066   writer.write&lt;u2&gt;(max_locals); // max locals
1067   writer.write&lt;u4&gt;((u4)new_code_length); // code length
1068 
1069   /* BEGIN CLINIT CODE */
1070 
1071   // Note the use of ldc_w here instead of ldc.
1072   // This is to handle all values of &quot;this_class_index&quot;
1073   writer.write&lt;u1&gt;((u1)Bytecodes::_ldc_w);
1074   writer.write&lt;u2&gt;((u2)parser.this_class_index()); // load constant &quot;this class&quot;
1075   writer.write&lt;u1&gt;((u1)Bytecodes::_invokestatic);
1076   // invoke &quot;FlightRecorder.register(Ljava/lang/Class;&quot;)
1077   writer.write&lt;u2&gt;(register_method_ref_index);
1078   if (clinit_method == NULL) {
1079     writer.write&lt;u1&gt;((u1)Bytecodes::_nop);
1080     writer.write&lt;u1&gt;((u1)Bytecodes::_return);
1081   } else {
1082     // If we are pre-pending to original code,
1083     // do padding to minimize disruption to the original.
1084     // It might have dependencies on 4-byte boundaries
1085     // i.e. lookupswitch and tableswitch instructions
1086     writer.write&lt;u1&gt;((u1)Bytecodes::_nop);
1087     writer.write&lt;u1&gt;((u1)Bytecodes::_nop);
1088     // insert original clinit code
1089     writer.bytes(orig_bytecodes, orig_bytecodes_length);
1090   }
1091 
1092   /* END CLINIT CODE */
1093 
1094   assert(writer.is_valid(), &quot;invariant&quot;);
1095   adjust_exception_table(writer, injected_code_length, clinit_method, THREAD);
1096   assert(writer.is_valid(), &quot;invariant&quot;);
1097   adjust_code_attributes(writer, utf8_indexes, injected_code_length, clinit_method, THREAD);
1098   assert(writer.is_valid(), &quot;invariant&quot;);
1099   u4 code_attribute_len = writer.current_offset() - code_attribute_length_offset;
1100   // the code_attribute_length value is exclusive
1101   code_attribute_len -= sizeof(u4);
1102   writer.write_at_offset(code_attribute_len, code_attribute_length_offset);
1103   return writer.current_offset();
1104 }
1105 
1106 // Caller needs ResourceMark
1107 static ClassFileStream* create_new_bytes_for_event_klass(const InstanceKlass* ik, const ClassFileParser&amp; parser, TRAPS) {
1108   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));
1109   static const u2 public_final_flag_mask = JVM_ACC_PUBLIC | JVM_ACC_FINAL;
1110   const ClassFileStream* const orig_stream = parser.clone_stream();
1111   const int orig_stream_length = orig_stream-&gt;length();
1112   // allocate an identically sized buffer
1113   u1* const new_buffer = NEW_RESOURCE_ARRAY_IN_THREAD_RETURN_NULL(THREAD, u1, orig_stream_length);
1114   if (new_buffer == NULL) {
1115     return NULL;
1116   }
1117   assert(new_buffer != NULL, &quot;invariant&quot;);
1118   // memcpy the entire [B
1119   memcpy(new_buffer, orig_stream-&gt;buffer(), orig_stream_length);
1120   const u2 orig_cp_len = position_stream_after_cp(orig_stream);
1121   assert(orig_cp_len &gt; 0, &quot;invariant&quot;);
1122   assert(orig_stream-&gt;current_offset() &gt; 0, &quot;invariant&quot;);
1123   orig_stream-&gt;skip_u2_fast(3); // access_flags, this_class_index, super_class_index
1124   const u2 iface_len = orig_stream-&gt;get_u2_fast();
1125   orig_stream-&gt;skip_u2_fast(iface_len);
1126   // fields len
1127   const u2 orig_fields_len = orig_stream-&gt;get_u2_fast();
1128   // fields
1129   for (u2 i = 0; i &lt; orig_fields_len; ++i) {
1130     orig_stream-&gt;skip_u2_fast(3);
1131     const u2 attrib_info_len = orig_stream-&gt;get_u2_fast();
1132     for (u2 j = 0; j &lt; attrib_info_len; ++j) {
1133       orig_stream-&gt;skip_u2_fast(1);
1134       const u4 attrib_len = orig_stream-&gt;get_u4_fast();
1135       orig_stream-&gt;skip_u1_fast(attrib_len);
1136     }
1137   }
1138   // methods
1139   const u2 orig_methods_len = orig_stream-&gt;get_u2_fast();
1140   for (u2 i = 0; i &lt; orig_methods_len; ++i) {
1141     const u4 access_flag_offset = orig_stream-&gt;current_offset();
1142     const u2 flags = orig_stream-&gt;get_u2_fast();
1143     // Rewrite JVM_ACC_FINAL -&gt; JVM_ACC_PUBLIC
1144     if (public_final_flag_mask == flags) {
1145       JfrBigEndianWriter accessflagsrewriter(new_buffer + access_flag_offset, sizeof(u2));
1146       accessflagsrewriter.write&lt;u2&gt;(JVM_ACC_PUBLIC);
1147       assert(accessflagsrewriter.is_valid(), &quot;invariant&quot;);
1148     }
1149     orig_stream-&gt;skip_u2_fast(2);
1150     const u2 attributes_count = orig_stream-&gt;get_u2_fast();
1151     for (u2 j = 0; j &lt; attributes_count; ++j) {
1152       orig_stream-&gt;skip_u2_fast(1);
1153       const u4 attrib_len = orig_stream-&gt;get_u4_fast();
1154       orig_stream-&gt;skip_u1_fast(attrib_len);
1155     }
1156   }
1157   return new ClassFileStream(new_buffer, orig_stream_length, NULL, ClassFileStream::verify);
1158 }
1159 
1160 // Attempt to locate an existing UTF8_INFO mapping the utf8_constant.
1161 // If no UTF8_INFO exists, add (append) a new one to the constant pool.
1162 static u2 find_or_add_utf8_info(JfrBigEndianWriter&amp; writer,
1163                                 const InstanceKlass* ik,
1164                                 const char* const utf8_constant,
1165                                 u2 orig_cp_len,
1166                                 u2&amp; added_cp_entries,
1167                                 TRAPS) {
1168   assert(utf8_constant != NULL, &quot;invariant&quot;);
1169   TempNewSymbol utf8_sym = SymbolTable::new_symbol(utf8_constant, THREAD);
1170   // lookup existing
1171   const int utf8_orig_idx = utf8_info_index(ik, utf8_sym, THREAD);
1172   if (utf8_orig_idx != invalid_cp_index) {
1173     // existing constant pool entry found
1174     return utf8_orig_idx;
1175   }
1176   // no existing match, need to add a new utf8 cp entry
1177   assert(invalid_cp_index == utf8_orig_idx, &quot;invariant&quot;);
1178   // add / append new
1179   return add_utf8_info(writer, utf8_constant, orig_cp_len, added_cp_entries);
1180 }
1181 
1182 /*
1183  * This routine will resolve the required utf8_constants array
1184  * to their constant pool indexes (mapping to their UTF8_INFO&#39;s)
1185  * Only if a constant is actually needed and does not already exist
1186  * will it be added.
1187  *
1188  * The passed in indexes array will be populated with the resolved indexes.
1189  * The number of newly added constant pool entries is returned.
1190  */
1191 static u2 resolve_utf8_indexes(JfrBigEndianWriter&amp; writer,
1192                                const InstanceKlass* ik,
1193                                u2* const utf8_indexes,
1194                                u2 orig_cp_len,
1195                                const Method* clinit_method,
1196                                bool register_klass,
1197                                bool untypedEventHandler,
1198                                TRAPS) {
1199   assert(utf8_indexes != NULL, &quot;invariant&quot;);
1200   u2 added_cp_entries = 0;
1201   // resolve all required symbols
1202   for (u2 index = 0; index &lt; NOF_UTF8_REQ_SYMBOLS; ++index) {
1203     utf8_indexes[index] = find_or_add_utf8_info(writer, ik, utf8_constants[index], orig_cp_len, added_cp_entries, THREAD);
1204   }
1205 
1206   // resolve optional constants
1207   utf8_indexes[UTF8_OPT_eventHandler_FIELD_DESC] = untypedEventHandler ? invalid_cp_index :
1208     find_or_add_utf8_info(writer, ik, utf8_constants[UTF8_OPT_eventHandler_FIELD_DESC], orig_cp_len, added_cp_entries, THREAD);
1209 
1210   utf8_indexes[UTF8_OPT_LjavaLangObject] = untypedEventHandler ?
1211     find_or_add_utf8_info(writer, ik, utf8_constants[UTF8_OPT_LjavaLangObject], orig_cp_len, added_cp_entries, THREAD) : invalid_cp_index;
1212 
1213   if (register_klass) {
1214     utf8_indexes[UTF8_OPT_clinit] =
1215       find_or_add_utf8_info(writer, ik, utf8_constants[UTF8_OPT_clinit], orig_cp_len, added_cp_entries, THREAD);
1216     utf8_indexes[UTF8_OPT_FlightRecorder] =
1217       find_or_add_utf8_info(writer, ik, utf8_constants[UTF8_OPT_FlightRecorder], orig_cp_len, added_cp_entries, THREAD);
1218     utf8_indexes[UTF8_OPT_register] =
1219       find_or_add_utf8_info(writer, ik, utf8_constants[UTF8_OPT_register], orig_cp_len, added_cp_entries, THREAD);
1220     utf8_indexes[UTF8_OPT_CLASS_VOID_METHOD_DESC] =
1221       find_or_add_utf8_info(writer, ik, utf8_constants[UTF8_OPT_CLASS_VOID_METHOD_DESC], orig_cp_len, added_cp_entries, THREAD);
1222   } else {
1223     utf8_indexes[UTF8_OPT_clinit] = invalid_cp_index;
1224     utf8_indexes[UTF8_OPT_FlightRecorder] = invalid_cp_index;
1225     utf8_indexes[UTF8_OPT_register] = invalid_cp_index;
1226     utf8_indexes[UTF8_OPT_CLASS_VOID_METHOD_DESC] = invalid_cp_index;
1227   }
1228 
1229   if (clinit_method != NULL &amp;&amp; clinit_method-&gt;has_stackmap_table()) {
1230     utf8_indexes[UTF8_OPT_StackMapTable] =
1231       find_or_add_utf8_info(writer, ik, utf8_constants[UTF8_OPT_StackMapTable], orig_cp_len, added_cp_entries, THREAD);
1232   } else {
1233     utf8_indexes[UTF8_OPT_StackMapTable] = invalid_cp_index;
1234   }
1235 
1236   if (clinit_method != NULL &amp;&amp; clinit_method-&gt;has_linenumber_table()) {
1237     utf8_indexes[UTF8_OPT_LineNumberTable] =
1238       find_or_add_utf8_info(writer, ik, utf8_constants[UTF8_OPT_LineNumberTable], orig_cp_len, added_cp_entries, THREAD);
1239   } else {
1240     utf8_indexes[UTF8_OPT_LineNumberTable] = invalid_cp_index;
1241   }
1242 
1243   if (clinit_method != NULL &amp;&amp; clinit_method-&gt;has_localvariable_table()) {
1244     utf8_indexes[UTF8_OPT_LocalVariableTable] =
1245       find_or_add_utf8_info(writer, ik, utf8_constants[UTF8_OPT_LocalVariableTable], orig_cp_len, added_cp_entries, THREAD);
1246     utf8_indexes[UTF8_OPT_LocalVariableTypeTable] =
1247       find_or_add_utf8_info(writer, ik, utf8_constants[UTF8_OPT_LocalVariableTypeTable], orig_cp_len, added_cp_entries, THREAD);
1248   } else {
1249     utf8_indexes[UTF8_OPT_LocalVariableTable] = invalid_cp_index;
1250     utf8_indexes[UTF8_OPT_LocalVariableTypeTable] = invalid_cp_index;
1251   }
1252 
1253   return added_cp_entries;
1254 }
1255 
1256 static u1* new_bytes_for_lazy_instrumentation(const InstanceKlass* ik,
1257                                               const ClassFileParser&amp; parser,
1258                                               jint&amp; size_of_new_bytes,
1259                                               TRAPS) {
1260   assert(ik != NULL, &quot;invariant&quot;);
1261   // If the class already has a clinit method
1262   // we need to take that into account
1263   const Method* clinit_method = ik-&gt;class_initializer();
1264   bool untypedEventHandler = false;
1265   const bool register_klass = should_register_klass(ik, untypedEventHandler);
1266   const ClassFileStream* const orig_stream = parser.clone_stream();
1267   const int orig_stream_size = orig_stream-&gt;length();
1268   assert(orig_stream-&gt;current_offset() == 0, &quot;invariant&quot;);
1269   const u2 orig_cp_len = position_stream_after_cp(orig_stream);
1270   assert(orig_cp_len &gt; 0, &quot;invariant&quot;);
1271   assert(orig_stream-&gt;current_offset() &gt; 0, &quot;invariant&quot;);
1272   // Dimension and allocate a working byte buffer
1273   // to be used in building up a modified class [B.
1274   const jint new_buffer_size = extra_stream_bytes + orig_stream_size;
1275   u1* const new_buffer = NEW_RESOURCE_ARRAY_IN_THREAD_RETURN_NULL(THREAD, u1, new_buffer_size);
1276   if (new_buffer == NULL) {
1277     log_error(jfr, system) (&quot;Thread local allocation (native) for &quot; SIZE_FORMAT
1278       &quot; bytes failed in JfrClassAdapter::on_klass_creation&quot;, (size_t)new_buffer_size);
1279     return NULL;
1280   }
1281   assert(new_buffer != NULL, &quot;invariant&quot;);
1282   // [B wrapped in a big endian writer
1283   JfrBigEndianWriter writer(new_buffer, new_buffer_size);
1284   assert(writer.current_offset() == 0, &quot;invariant&quot;);
1285   const u4 orig_access_flag_offset = orig_stream-&gt;current_offset();
1286   // Copy original stream from the beginning up to AccessFlags
1287   // This means the original constant pool contents are copied unmodified
1288   writer.bytes(orig_stream-&gt;buffer(), orig_access_flag_offset);
1289   assert(writer.is_valid(), &quot;invariant&quot;);
1290   assert(writer.current_offset() == (intptr_t)orig_access_flag_offset, &quot;invariant&quot;); // same positions
1291   // Our writer now sits just after the last original constant pool entry.
1292   // I.e. we are in a good position to append new constant pool entries
1293   // This array will contain the resolved indexes
1294   // in order to reference UTF8_INFO&#39;s needed
1295   u2 utf8_indexes[NOF_UTF8_SYMBOLS];
1296   // Resolve_utf8_indexes will be conservative in attempting to
1297   // locate an existing UTF8_INFO; it will only append constants
1298   // that is absolutely required
1299   u2 number_of_new_constants =
1300     resolve_utf8_indexes(writer, ik, utf8_indexes, orig_cp_len, clinit_method, register_klass, untypedEventHandler, THREAD);
1301   // UTF8_INFO entries now added to the constant pool
1302   // In order to invoke a method we would need additional
1303   // constants, JVM_CONSTANT_Class, JVM_CONSTANT_NameAndType
1304   // and JVM_CONSTANT_Methodref.
1305   const u2 flr_register_method_ref_index =
1306     register_klass ?
1307       add_flr_register_method_constants(writer,
1308                                         utf8_indexes,
1309                                         orig_cp_len,
1310                                         number_of_new_constants,
1311                                         THREAD) :  invalid_cp_index;
1312 
1313   // New constant pool entries added and all UTF8_INFO indexes resolved
1314   // Now update the class file constant_pool_count with an updated count
1315   writer.write_at_offset&lt;u2&gt;(orig_cp_len + number_of_new_constants, 8);
1316   assert(writer.is_valid(), &quot;invariant&quot;);
1317   orig_stream-&gt;skip_u2_fast(3); // access_flags, this_class_index, super_class_index
1318   const u2 iface_len = orig_stream-&gt;get_u2_fast(); // interfaces
1319   orig_stream-&gt;skip_u2_fast(iface_len);
1320   const u4 orig_fields_len_offset = orig_stream-&gt;current_offset();
1321   // Copy from AccessFlags up to and including interfaces
1322   writer.bytes(orig_stream-&gt;buffer() + orig_access_flag_offset,
1323                orig_fields_len_offset - orig_access_flag_offset);
1324   assert(writer.is_valid(), &quot;invariant&quot;);
1325   const jlong new_fields_len_offset = writer.current_offset();
1326   const u2 orig_fields_len = position_stream_after_fields(orig_stream);
1327   u4 orig_method_len_offset = orig_stream-&gt;current_offset();
1328   // Copy up to and including fields
1329   writer.bytes(orig_stream-&gt;buffer() + orig_fields_len_offset, orig_method_len_offset - orig_fields_len_offset);
1330   assert(writer.is_valid(), &quot;invariant&quot;);
1331   // We are sitting just after the original number of field_infos
1332   // so this is a position where we can add (append) new field_infos
1333   const u2 number_of_new_fields = add_field_infos(writer, utf8_indexes, untypedEventHandler);
1334   assert(writer.is_valid(), &quot;invariant&quot;);
1335   const jlong new_method_len_offset = writer.current_offset();
1336   // Additional field_infos added, update classfile fields_count
1337   writer.write_at_offset&lt;u2&gt;(orig_fields_len + number_of_new_fields, new_fields_len_offset);
1338   assert(writer.is_valid(), &quot;invariant&quot;);
1339   // Our current location is now at classfile methods_count
1340   const u2 orig_methods_len = position_stream_after_methods(writer,
1341                                                             orig_stream,
1342                                                             utf8_indexes,
1343                                                             register_klass,
1344                                                             clinit_method,
1345                                                             orig_method_len_offset);
1346   const u4 orig_attributes_count_offset = orig_stream-&gt;current_offset();
1347   // Copy existing methods
1348   writer.bytes(orig_stream-&gt;buffer() + orig_method_len_offset, orig_attributes_count_offset - orig_method_len_offset);
1349   assert(writer.is_valid(), &quot;invariant&quot;);
1350   // We are sitting just after the original number of method_infos
1351   // so this is a position where we can add (append) new method_infos
1352   u2 number_of_new_methods = add_method_infos(writer, utf8_indexes);
1353 
1354   // We have just added the new methods.
1355   //
1356   // What about the state of &lt;clinit&gt;?
1357   // We would need to do:
1358   // 1. Nothing (@Registered(false) annotation)
1359   // 2. Build up a new &lt;clinit&gt; - and if the original class already contains a &lt;clinit&gt;,
1360   //                              merging will be neccessary.
1361   //
1362   if (register_klass) {
1363     insert_clinit_method(ik, parser, writer, orig_cp_len, utf8_indexes, flr_register_method_ref_index, clinit_method, THREAD);
1364   }
1365   number_of_new_methods += clinit_method != NULL ? 0 : register_klass ? 1 : 0;
1366   // Update classfile methods_count
1367   writer.write_at_offset&lt;u2&gt;(orig_methods_len + number_of_new_methods, new_method_len_offset);
1368   assert(writer.is_valid(), &quot;invariant&quot;);
1369   // Copy last remaining bytes
1370   writer.bytes(orig_stream-&gt;buffer() + orig_attributes_count_offset, orig_stream_size - orig_attributes_count_offset);
1371   assert(writer.is_valid(), &quot;invariant&quot;);
1372   assert(writer.current_offset() &gt; orig_stream-&gt;length(), &quot;invariant&quot;);
1373   size_of_new_bytes = (jint)writer.current_offset();
1374   return new_buffer;
1375 }
1376 
1377 static void log_pending_exception(oop throwable) {
1378   assert(throwable != NULL, &quot;invariant&quot;);
1379   oop msg = java_lang_Throwable::message(throwable);
1380   if (msg != NULL) {
1381     char* text = java_lang_String::as_utf8_string(msg);
1382     if (text != NULL) {
1383       log_error(jfr, system) (&quot;%s&quot;, text);
1384     }
1385   }
1386 }
1387 
1388 static bool should_force_instrumentation() {
1389   return !JfrOptionSet::allow_event_retransforms() || JfrEventClassTransformer::is_force_instrumentation();
1390 }
1391 
1392 static ClassFileStream* create_new_bytes_for_subklass(const InstanceKlass* ik, const ClassFileParser&amp; parser, Thread* t) {
1393   assert(JdkJfrEvent::is_a(ik), &quot;invariant&quot;);
1394   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(t));
1395   jint size_of_new_bytes = 0;
1396   const u1* new_bytes = new_bytes_for_lazy_instrumentation(ik, parser, size_of_new_bytes, t);
1397   if (new_bytes == NULL) {
1398     return NULL;
1399   }
1400   assert(new_bytes != NULL, &quot;invariant&quot;);
1401   assert(size_of_new_bytes &gt; 0, &quot;invariant&quot;);
1402 
1403   bool force_instrumentation = should_force_instrumentation();
1404   if (Jfr::is_recording() || force_instrumentation) {
1405     jint size_instrumented_data = 0;
1406     unsigned char* instrumented_data = NULL;
1407     const jclass super = (jclass)JNIHandles::make_local(ik-&gt;super()-&gt;java_mirror());
1408     JfrUpcalls::new_bytes_eager_instrumentation(TRACE_ID(ik),
1409                                                 force_instrumentation,
1410                                                 super,
1411                                                 size_of_new_bytes,
1412                                                 new_bytes,
1413                                                 &amp;size_instrumented_data,
1414                                                 &amp;instrumented_data,
1415                                                 t);
1416     if (t-&gt;has_pending_exception()) {
1417       log_pending_exception(t-&gt;pending_exception());
1418       t-&gt;clear_pending_exception();
1419       return NULL;
1420     }
1421     assert(instrumented_data != NULL, &quot;invariant&quot;);
1422     assert(size_instrumented_data &gt; 0, &quot;invariant&quot;);
1423     return new ClassFileStream(instrumented_data, size_instrumented_data, NULL, ClassFileStream::verify);
1424   }
1425   return new ClassFileStream(new_bytes, size_of_new_bytes, NULL, ClassFileStream::verify);
1426 }
1427 
1428 static bool cache_bytes(InstanceKlass* ik, ClassFileStream* new_stream, InstanceKlass* new_ik, TRAPS) {
1429   assert(ik != NULL, &quot;invariant&quot;);
1430   assert(new_ik != NULL, &quot;invariant&quot;);
1431   assert(new_ik-&gt;name() != NULL, &quot;invariant&quot;);
1432   assert(new_stream != NULL, &quot;invariant&quot;);
1433   assert(!HAS_PENDING_EXCEPTION, &quot;invariant&quot;);
1434   static const bool can_retransform = JfrOptionSet::allow_retransforms();
1435   if (!can_retransform) {
1436     return true;
1437   }
1438   const jint stream_len = new_stream-&gt;length();
1439   JvmtiCachedClassFileData* p =
1440     (JvmtiCachedClassFileData*)NEW_C_HEAP_ARRAY_RETURN_NULL(u1, offset_of(JvmtiCachedClassFileData, data) + stream_len, mtInternal);
1441   if (p == NULL) {
1442     log_error(jfr, system)(&quot;Allocation using C_HEAP_ARRAY for &quot; SIZE_FORMAT
1443       &quot; bytes failed in JfrClassAdapter::on_klass_creation&quot;, (size_t)offset_of(JvmtiCachedClassFileData, data) + stream_len);
1444     return false;
1445   }
1446   p-&gt;length = stream_len;
1447   memcpy(p-&gt;data, new_stream-&gt;buffer(), stream_len);
1448   new_ik-&gt;set_cached_class_file(p);
1449   JvmtiCachedClassFileData* const cached_class_data = ik-&gt;get_cached_class_file();
1450   if (cached_class_data != NULL) {
1451     os::free(cached_class_data);
1452     ik-&gt;set_cached_class_file(NULL);
1453   }
1454   return true;
1455 }
1456 
1457 static InstanceKlass* create_new_instance_klass(InstanceKlass* ik, ClassFileStream* stream, TRAPS) {
1458   assert(stream != NULL, &quot;invariant&quot;);
1459   ResourceMark rm(THREAD);
1460   ClassLoaderData* const cld = ik-&gt;class_loader_data();
1461   Handle pd(THREAD, ik-&gt;protection_domain());
1462   Symbol* const class_name = ik-&gt;name();
1463   const char* const klass_name = class_name != NULL ? class_name-&gt;as_C_string() : &quot;&quot;;
1464   ClassFileParser new_parser(stream,
1465                              class_name,
1466                              cld,
1467                              pd,
1468                              NULL, // host klass
1469                              NULL, // cp_patches
1470                              ClassFileParser::INTERNAL, // internal visibility
1471                              THREAD);
1472   if (HAS_PENDING_EXCEPTION) {
1473     log_pending_exception(PENDING_EXCEPTION);
1474     CLEAR_PENDING_EXCEPTION;
1475     return NULL;
1476   }
1477   InstanceKlass* const new_ik = new_parser.create_instance_klass(false, THREAD);
1478   if (HAS_PENDING_EXCEPTION) {
1479     log_pending_exception(PENDING_EXCEPTION);
1480     CLEAR_PENDING_EXCEPTION;
1481     return NULL;
1482   }
1483   assert(new_ik != NULL, &quot;invariant&quot;);
1484   assert(new_ik-&gt;name() != NULL, &quot;invariant&quot;);
1485   assert(strncmp(ik-&gt;name()-&gt;as_C_string(), new_ik-&gt;name()-&gt;as_C_string(), strlen(ik-&gt;name()-&gt;as_C_string())) == 0, &quot;invariant&quot;);
1486   return cache_bytes(ik, stream, new_ik, THREAD) ? new_ik : NULL;
1487 }
1488 
1489 static void rewrite_klass_pointer(InstanceKlass*&amp; ik, InstanceKlass* new_ik, ClassFileParser&amp; parser, TRAPS) {
1490   assert(ik != NULL, &quot;invariant&quot;);
1491   assert(new_ik != NULL, &quot;invariant&quot;);
1492   assert(new_ik-&gt;name() != NULL, &quot;invariant&quot;);
1493   assert(JdkJfrEvent::is(new_ik) || JdkJfrEvent::is_subklass(new_ik), &quot;invariant&quot;);
1494   assert(!HAS_PENDING_EXCEPTION, &quot;invariant&quot;);
1495   // assign original InstanceKlass* back onto &quot;its&quot; parser object for proper destruction
1496   parser.set_klass_to_deallocate(ik);
1497   // now rewrite original pointer to newly created InstanceKlass
1498   ik = new_ik;
1499 }
1500 
1501 // During retransform/redefine, copy the Method specific trace flags
1502 // from the previous ik (&quot;the original klass&quot;) to the new ik (&quot;the scratch_klass&quot;).
1503 // The open code for retransform/redefine does not know about these.
1504 // In doing this migration here, we ensure the new Methods (defined in scratch klass)
1505 // will carry over trace tags from the old Methods being replaced,
1506 // ensuring flag/tag continuity while being transparent to open code.
1507 static void copy_method_trace_flags(const InstanceKlass* the_original_klass, const InstanceKlass* the_scratch_klass) {
1508   assert(the_original_klass != NULL, &quot;invariant&quot;);
1509   assert(the_scratch_klass != NULL, &quot;invariant&quot;);
1510   assert(the_original_klass-&gt;name() == the_scratch_klass-&gt;name(), &quot;invariant&quot;);
1511   const Array&lt;Method*&gt;* old_methods = the_original_klass-&gt;methods();
1512   const Array&lt;Method*&gt;* new_methods = the_scratch_klass-&gt;methods();
1513   const bool equal_array_length = old_methods-&gt;length() == new_methods-&gt;length();
1514   // The Method array has the property of being sorted.
1515   // If they are the same length, there is a one-to-one mapping.
1516   // If they are unequal, there was a method added (currently only
1517   // private static methods allowed to be added), use lookup.
1518   for (int i = 0; i &lt; old_methods-&gt;length(); ++i) {
1519     const Method* const old_method = old_methods-&gt;at(i);
1520     Method* const new_method = equal_array_length ? new_methods-&gt;at(i) :
1521       the_scratch_klass-&gt;find_method(old_method-&gt;name(), old_method-&gt;signature());
1522     assert(new_method != NULL, &quot;invariant&quot;);
1523     assert(new_method-&gt;name() == old_method-&gt;name(), &quot;invariant&quot;);
1524     assert(new_method-&gt;signature() == old_method-&gt;signature(), &quot;invariant&quot;);
1525     *new_method-&gt;trace_flags_addr() = old_method-&gt;trace_flags();
1526     assert(new_method-&gt;trace_flags() == old_method-&gt;trace_flags(), &quot;invariant&quot;);
1527   }
1528 }
1529 
1530 static bool is_retransforming(const InstanceKlass* ik, TRAPS) {
1531   assert(ik != NULL, &quot;invariant&quot;);
1532   assert(JdkJfrEvent::is_a(ik), &quot;invariant&quot;);
1533   Symbol* const name = ik-&gt;name();
1534   assert(name != NULL, &quot;invariant&quot;);
1535   Handle class_loader(THREAD, ik-&gt;class_loader());
1536   Handle protection_domain(THREAD, ik-&gt;protection_domain());
1537   // nota bene: use lock-free dictionary lookup
1538   const InstanceKlass* prev_ik = (const InstanceKlass*)SystemDictionary::find(name, class_loader, protection_domain, THREAD);
1539   if (prev_ik == NULL) {
1540     return false;
1541   }
1542   // an existing ik implies a retransform/redefine
1543   assert(prev_ik != NULL, &quot;invariant&quot;);
1544   assert(JdkJfrEvent::is_a(prev_ik), &quot;invariant&quot;);
1545   copy_method_trace_flags(prev_ik, ik);
1546   return true;
1547 }
1548 
1549 // target for JFR_ON_KLASS_CREATION hook
1550 void JfrEventClassTransformer::on_klass_creation(InstanceKlass*&amp; ik, ClassFileParser&amp; parser, TRAPS) {
1551   assert(ik != NULL, &quot;invariant&quot;);
1552   if (JdkJfrEvent::is(ik)) {
1553     ResourceMark rm(THREAD);
1554     HandleMark hm(THREAD);
1555     ClassFileStream* new_stream = create_new_bytes_for_event_klass(ik, parser, THREAD);
1556     if (new_stream == NULL) {
1557       log_error(jfr, system)(&quot;JfrClassAdapter: unable to create ClassFileStream&quot;);
1558       return;
1559     }
1560     assert(new_stream != NULL, &quot;invariant&quot;);
1561     InstanceKlass* new_ik = create_new_instance_klass(ik, new_stream, THREAD);
1562     if (new_ik == NULL) {
1563       log_error(jfr, system)(&quot;JfrClassAdapter: unable to create InstanceKlass&quot;);
1564       return;
1565     }
1566     assert(new_ik != NULL, &quot;invariant&quot;);
1567     // We now need to explicitly tag the replaced klass as the jdk.jfr.Event klass
1568     assert(!JdkJfrEvent::is(new_ik), &quot;invariant&quot;);
1569     JdkJfrEvent::tag_as(new_ik);
1570     assert(JdkJfrEvent::is(new_ik), &quot;invariant&quot;);
1571     rewrite_klass_pointer(ik, new_ik, parser, THREAD);
1572     return;
1573   }
1574   assert(JdkJfrEvent::is_subklass(ik), &quot;invariant&quot;);
1575   if (is_retransforming(ik, THREAD)) {
1576     // not the initial klass load
1577     return;
1578   }
1579   if (ik-&gt;is_abstract()) {
1580     // abstract classes are not instrumented
1581     return;
1582   }
1583   ResourceMark rm(THREAD);
1584   HandleMark hm(THREAD);
1585   ClassFileStream* const new_stream = create_new_bytes_for_subklass(ik, parser, THREAD);
1586   if (NULL == new_stream) {
1587     log_error(jfr, system)(&quot;JfrClassAdapter: unable to create ClassFileStream&quot;);
1588     return;
1589   }
1590   assert(new_stream != NULL, &quot;invariant&quot;);
1591   InstanceKlass* new_ik = create_new_instance_klass(ik, new_stream, THREAD);
1592   if (new_ik == NULL) {
1593     log_error(jfr, system)(&quot;JfrClassAdapter: unable to create InstanceKlass&quot;);
1594     return;
1595   }
1596   assert(new_ik != NULL, &quot;invariant&quot;);
1597   // would have been tagged already as a subklass during the normal process of traceid assignment
1598   assert(JdkJfrEvent::is_subklass(new_ik), &quot;invariant&quot;);
1599   traceid id = ik-&gt;trace_id();
1600   ik-&gt;set_trace_id(0);
1601   new_ik-&gt;set_trace_id(id);
1602   rewrite_klass_pointer(ik, new_ik, parser, THREAD);
1603 }
1604 
1605 static bool _force_instrumentation = false;
1606 void JfrEventClassTransformer::set_force_instrumentation(bool force_instrumentation) {
1607   _force_instrumentation = force_instrumentation;
1608 }
1609 
1610 bool JfrEventClassTransformer::is_force_instrumentation() {
1611   return _force_instrumentation;
1612 }
    </pre>
  </body>
</html>
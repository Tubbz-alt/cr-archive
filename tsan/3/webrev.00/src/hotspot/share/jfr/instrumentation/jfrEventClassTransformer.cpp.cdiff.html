<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/jfr/instrumentation/jfrEventClassTransformer.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../dcmd/jfrDcmds.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jfrJvmtiAgent.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/instrumentation/jfrEventClassTransformer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 28,10 ***</span>
<span class="line-new-header">--- 28,11 ---</span>
  #include &quot;classfile/classFileStream.hpp&quot;
  #include &quot;classfile/javaClasses.inline.hpp&quot;
  #include &quot;classfile/moduleEntry.hpp&quot;
  #include &quot;classfile/modules.hpp&quot;
  #include &quot;classfile/stackMapTable.hpp&quot;
<span class="line-added">+ #include &quot;classfile/symbolTable.hpp&quot;</span>
  #include &quot;classfile/verificationType.hpp&quot;
  #include &quot;interpreter/bytecodes.hpp&quot;
  #include &quot;jfr/instrumentation/jfrEventClassTransformer.hpp&quot;
  #include &quot;jfr/jfr.hpp&quot;
  #include &quot;jfr/jni/jfrJavaSupport.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 41,11 ***</span>
  #include &quot;jfr/writers/jfrBigEndianWriter.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;oops/array.hpp&quot;
<span class="line-removed">- #include &quot;oops/constantPool.hpp&quot;</span>
  #include &quot;oops/instanceKlass.hpp&quot;
  #include &quot;oops/method.hpp&quot;
  #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
<span class="line-new-header">--- 42,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 354,11 ***</span>
      assert(_current &lt; _limit, &quot;invariant&quot;);
      return _ik-&gt;constants()-&gt;symbol_at(JfrBigEndian::read&lt;u2&gt;(_buffer + _current));
    }
  };
  
<span class="line-removed">- static unsigned int unused_hash = 0;</span>
  static const char value_name[] = &quot;value&quot;;
  static bool has_annotation(const InstanceKlass* ik, const Symbol* annotation_type, bool&amp; value) {
    assert(annotation_type != NULL, &quot;invariant&quot;);
    AnnotationArray* class_annotations = ik-&gt;class_annotations();
    if (class_annotations == NULL) {
<span class="line-new-header">--- 354,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 369,11 ***</span>
    while (annotation_iterator.has_next()) {
      annotation_iterator.move_to_next();
      if (annotation_iterator.type() == annotation_type) {
        // target annotation found
        static const Symbol* value_symbol =
<span class="line-modified">!         SymbolTable::lookup_only(value_name, sizeof value_name - 1, unused_hash);</span>
        assert(value_symbol != NULL, &quot;invariant&quot;);
        const AnnotationElementIterator element_iterator = annotation_iterator.elements();
        while (element_iterator.has_next()) {
          element_iterator.move_to_next();
          if (value_symbol == element_iterator.name()) {
<span class="line-new-header">--- 368,11 ---</span>
    while (annotation_iterator.has_next()) {
      annotation_iterator.move_to_next();
      if (annotation_iterator.type() == annotation_type) {
        // target annotation found
        static const Symbol* value_symbol =
<span class="line-modified">!         SymbolTable::probe(value_name, sizeof value_name - 1);</span>
        assert(value_symbol != NULL, &quot;invariant&quot;);
        const AnnotationElementIterator element_iterator = annotation_iterator.elements();
        while (element_iterator.has_next()) {
          element_iterator.move_to_next();
          if (value_symbol == element_iterator.name()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 409,11 ***</span>
    if (can_read) {
      return true;
    }
    static Symbol* jdk_jfr_module_symbol = NULL;
    if (jdk_jfr_module_symbol == NULL) {
<span class="line-modified">!     jdk_jfr_module_symbol = SymbolTable::lookup_only(jdk_jfr_module_name, sizeof jdk_jfr_module_name - 1, unused_hash);</span>
      if (jdk_jfr_module_symbol == NULL) {
        return false;
      }
    }
    assert(jdk_jfr_module_symbol != NULL, &quot;invariant&quot;);
<span class="line-new-header">--- 408,11 ---</span>
    if (can_read) {
      return true;
    }
    static Symbol* jdk_jfr_module_symbol = NULL;
    if (jdk_jfr_module_symbol == NULL) {
<span class="line-modified">!     jdk_jfr_module_symbol = SymbolTable::probe(jdk_jfr_module_name, sizeof jdk_jfr_module_name - 1);</span>
      if (jdk_jfr_module_symbol == NULL) {
        return false;
      }
    }
    assert(jdk_jfr_module_symbol != NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 444,11 ***</span>
    assert(ik != NULL, &quot;invariant&quot;);
    assert(JdkJfrEvent::is_a(ik), &quot;invariant&quot;);
    assert(!untypedEventHandler, &quot;invariant&quot;);
    static const Symbol* registered_symbol = NULL;
    if (registered_symbol == NULL) {
<span class="line-modified">!     registered_symbol = SymbolTable::lookup_only(registered_constant, sizeof registered_constant - 1, unused_hash);</span>
      if (registered_symbol == NULL) {
        untypedEventHandler = true;
        return false;
      }
    }
<span class="line-new-header">--- 443,11 ---</span>
    assert(ik != NULL, &quot;invariant&quot;);
    assert(JdkJfrEvent::is_a(ik), &quot;invariant&quot;);
    assert(!untypedEventHandler, &quot;invariant&quot;);
    static const Symbol* registered_symbol = NULL;
    if (registered_symbol == NULL) {
<span class="line-modified">!     registered_symbol = SymbolTable::probe(registered_constant, sizeof registered_constant - 1);</span>
      if (registered_symbol == NULL) {
        untypedEventHandler = true;
        return false;
      }
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1164,11 ***</span>
                                  const char* const utf8_constant,
                                  u2 orig_cp_len,
                                  u2&amp; added_cp_entries,
                                  TRAPS) {
    assert(utf8_constant != NULL, &quot;invariant&quot;);
<span class="line-modified">!   TempNewSymbol utf8_sym = SymbolTable::new_symbol(utf8_constant, THREAD);</span>
    // lookup existing
    const int utf8_orig_idx = utf8_info_index(ik, utf8_sym, THREAD);
    if (utf8_orig_idx != invalid_cp_index) {
      // existing constant pool entry found
      return utf8_orig_idx;
<span class="line-new-header">--- 1163,11 ---</span>
                                  const char* const utf8_constant,
                                  u2 orig_cp_len,
                                  u2&amp; added_cp_entries,
                                  TRAPS) {
    assert(utf8_constant != NULL, &quot;invariant&quot;);
<span class="line-modified">!   TempNewSymbol utf8_sym = SymbolTable::new_symbol(utf8_constant);</span>
    // lookup existing
    const int utf8_orig_idx = utf8_info_index(ik, utf8_sym, THREAD);
    if (utf8_orig_idx != invalid_cp_index) {
      // existing constant pool entry found
      return utf8_orig_idx;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1496,56 ***</span>
    parser.set_klass_to_deallocate(ik);
    // now rewrite original pointer to newly created InstanceKlass
    ik = new_ik;
  }
  
<span class="line-removed">- // During retransform/redefine, copy the Method specific trace flags</span>
<span class="line-removed">- // from the previous ik (&quot;the original klass&quot;) to the new ik (&quot;the scratch_klass&quot;).</span>
<span class="line-removed">- // The open code for retransform/redefine does not know about these.</span>
<span class="line-removed">- // In doing this migration here, we ensure the new Methods (defined in scratch klass)</span>
<span class="line-removed">- // will carry over trace tags from the old Methods being replaced,</span>
<span class="line-removed">- // ensuring flag/tag continuity while being transparent to open code.</span>
<span class="line-removed">- static void copy_method_trace_flags(const InstanceKlass* the_original_klass, const InstanceKlass* the_scratch_klass) {</span>
<span class="line-removed">-   assert(the_original_klass != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   assert(the_scratch_klass != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   assert(the_original_klass-&gt;name() == the_scratch_klass-&gt;name(), &quot;invariant&quot;);</span>
<span class="line-removed">-   const Array&lt;Method*&gt;* old_methods = the_original_klass-&gt;methods();</span>
<span class="line-removed">-   const Array&lt;Method*&gt;* new_methods = the_scratch_klass-&gt;methods();</span>
<span class="line-removed">-   const bool equal_array_length = old_methods-&gt;length() == new_methods-&gt;length();</span>
<span class="line-removed">-   // The Method array has the property of being sorted.</span>
<span class="line-removed">-   // If they are the same length, there is a one-to-one mapping.</span>
<span class="line-removed">-   // If they are unequal, there was a method added (currently only</span>
<span class="line-removed">-   // private static methods allowed to be added), use lookup.</span>
<span class="line-removed">-   for (int i = 0; i &lt; old_methods-&gt;length(); ++i) {</span>
<span class="line-removed">-     const Method* const old_method = old_methods-&gt;at(i);</span>
<span class="line-removed">-     Method* const new_method = equal_array_length ? new_methods-&gt;at(i) :</span>
<span class="line-removed">-       the_scratch_klass-&gt;find_method(old_method-&gt;name(), old_method-&gt;signature());</span>
<span class="line-removed">-     assert(new_method != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-     assert(new_method-&gt;name() == old_method-&gt;name(), &quot;invariant&quot;);</span>
<span class="line-removed">-     assert(new_method-&gt;signature() == old_method-&gt;signature(), &quot;invariant&quot;);</span>
<span class="line-removed">-     *new_method-&gt;trace_flags_addr() = old_method-&gt;trace_flags();</span>
<span class="line-removed">-     assert(new_method-&gt;trace_flags() == old_method-&gt;trace_flags(), &quot;invariant&quot;);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  static bool is_retransforming(const InstanceKlass* ik, TRAPS) {
    assert(ik != NULL, &quot;invariant&quot;);
    assert(JdkJfrEvent::is_a(ik), &quot;invariant&quot;);
    Symbol* const name = ik-&gt;name();
    assert(name != NULL, &quot;invariant&quot;);
    Handle class_loader(THREAD, ik-&gt;class_loader());
    Handle protection_domain(THREAD, ik-&gt;protection_domain());
<span class="line-modified">!   // nota bene: use lock-free dictionary lookup</span>
<span class="line-removed">-   const InstanceKlass* prev_ik = (const InstanceKlass*)SystemDictionary::find(name, class_loader, protection_domain, THREAD);</span>
<span class="line-removed">-   if (prev_ik == NULL) {</span>
<span class="line-removed">-     return false;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   // an existing ik implies a retransform/redefine</span>
<span class="line-removed">-   assert(prev_ik != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   assert(JdkJfrEvent::is_a(prev_ik), &quot;invariant&quot;);</span>
<span class="line-removed">-   copy_method_trace_flags(prev_ik, ik);</span>
<span class="line-removed">-   return true;</span>
  }
  
  // target for JFR_ON_KLASS_CREATION hook
  void JfrEventClassTransformer::on_klass_creation(InstanceKlass*&amp; ik, ClassFileParser&amp; parser, TRAPS) {
    assert(ik != NULL, &quot;invariant&quot;);
<span class="line-new-header">--- 1495,18 ---</span>
    parser.set_klass_to_deallocate(ik);
    // now rewrite original pointer to newly created InstanceKlass
    ik = new_ik;
  }
  
  static bool is_retransforming(const InstanceKlass* ik, TRAPS) {
    assert(ik != NULL, &quot;invariant&quot;);
    assert(JdkJfrEvent::is_a(ik), &quot;invariant&quot;);
    Symbol* const name = ik-&gt;name();
    assert(name != NULL, &quot;invariant&quot;);
    Handle class_loader(THREAD, ik-&gt;class_loader());
    Handle protection_domain(THREAD, ik-&gt;protection_domain());
<span class="line-modified">!   return SystemDictionary::find(name, class_loader, protection_domain, THREAD) != NULL;</span>
  }
  
  // target for JFR_ON_KLASS_CREATION hook
  void JfrEventClassTransformer::on_klass_creation(InstanceKlass*&amp; ik, ClassFileParser&amp; parser, TRAPS) {
    assert(ik != NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1570,16 ***</span>
      assert(JdkJfrEvent::is(new_ik), &quot;invariant&quot;);
      rewrite_klass_pointer(ik, new_ik, parser, THREAD);
      return;
    }
    assert(JdkJfrEvent::is_subklass(ik), &quot;invariant&quot;);
<span class="line-modified">!   if (is_retransforming(ik, THREAD)) {</span>
<span class="line-modified">!     // not the initial klass load</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (ik-&gt;is_abstract()) {</span>
<span class="line-removed">-     // abstract classes are not instrumented</span>
      return;
    }
    ResourceMark rm(THREAD);
    HandleMark hm(THREAD);
    ClassFileStream* const new_stream = create_new_bytes_for_subklass(ik, parser, THREAD);
<span class="line-new-header">--- 1531,12 ---</span>
      assert(JdkJfrEvent::is(new_ik), &quot;invariant&quot;);
      rewrite_klass_pointer(ik, new_ik, parser, THREAD);
      return;
    }
    assert(JdkJfrEvent::is_subklass(ik), &quot;invariant&quot;);
<span class="line-modified">!   if (ik-&gt;is_abstract() || is_retransforming(ik, THREAD)) {</span>
<span class="line-modified">!     // abstract and scratch classes are not instrumented</span>
      return;
    }
    ResourceMark rm(THREAD);
    HandleMark hm(THREAD);
    ClassFileStream* const new_stream = create_new_bytes_for_subklass(ik, parser, THREAD);
</pre>
<center><a href="../dcmd/jfrDcmds.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jfrJvmtiAgent.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
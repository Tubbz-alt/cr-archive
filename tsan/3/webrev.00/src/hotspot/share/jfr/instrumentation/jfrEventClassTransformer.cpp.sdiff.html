<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/instrumentation/jfrEventClassTransformer.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../dcmd/jfrDcmds.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jfrJvmtiAgent.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/instrumentation/jfrEventClassTransformer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classFileParser.hpp&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/javaClasses.inline.hpp&quot;
  30 #include &quot;classfile/moduleEntry.hpp&quot;
  31 #include &quot;classfile/modules.hpp&quot;
  32 #include &quot;classfile/stackMapTable.hpp&quot;

  33 #include &quot;classfile/verificationType.hpp&quot;
  34 #include &quot;interpreter/bytecodes.hpp&quot;
  35 #include &quot;jfr/instrumentation/jfrEventClassTransformer.hpp&quot;
  36 #include &quot;jfr/jfr.hpp&quot;
  37 #include &quot;jfr/jni/jfrJavaSupport.hpp&quot;
  38 #include &quot;jfr/jni/jfrUpcalls.hpp&quot;
  39 #include &quot;jfr/support/jfrEventClass.hpp&quot;
  40 #include &quot;jfr/utilities/jfrBigEndian.hpp&quot;
  41 #include &quot;jfr/writers/jfrBigEndianWriter.hpp&quot;
  42 #include &quot;logging/log.hpp&quot;
  43 #include &quot;memory/allocation.inline.hpp&quot;
  44 #include &quot;memory/resourceArea.hpp&quot;
  45 #include &quot;oops/array.hpp&quot;
<span class="line-removed">  46 #include &quot;oops/constantPool.hpp&quot;</span>
  47 #include &quot;oops/instanceKlass.hpp&quot;
  48 #include &quot;oops/method.hpp&quot;
  49 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  50 #include &quot;runtime/handles.inline.hpp&quot;
  51 #include &quot;runtime/os.hpp&quot;
  52 #include &quot;runtime/thread.inline.hpp&quot;
  53 #include &quot;utilities/exceptions.hpp&quot;
  54 #include &quot;utilities/globalDefinitions.hpp&quot;
  55 #include &quot;utilities/macros.hpp&quot;
  56 
  57 static const u2 number_of_new_methods = 5;
  58 static const u2 number_of_new_fields = 3;
  59 static const int extra_stream_bytes = 0x280;
  60 static const u2 invalid_cp_index = 0;
  61 
  62 static const char* utf8_constants[] = {
  63   &quot;Code&quot;,         // 0
  64   &quot;J&quot;,            // 1
  65   &quot;commit&quot;,       // 2
  66   &quot;eventHandler&quot;, // 3
</pre>
<hr />
<pre>
 339   void move_to_next() const {
 340     assert(has_next(), &quot;invariant&quot;);
 341     _current = _next;
 342     if (_next &lt; _limit) {
 343       _next = next_annotation_index(_buffer, _limit, _next);
 344     }
 345     assert(_next &lt;= _limit, &quot;invariant&quot;);
 346     assert(_current &lt;= _limit, &quot;invariant&quot;);
 347   }
 348   const AnnotationElementIterator elements() const {
 349     assert(_current &lt; _next, &quot;invariant&quot;);
 350     return AnnotationElementIterator(_ik, _buffer + _current, _next - _current);
 351   }
 352   const Symbol* type() const {
 353     assert(_buffer != NULL, &quot;invariant&quot;);
 354     assert(_current &lt; _limit, &quot;invariant&quot;);
 355     return _ik-&gt;constants()-&gt;symbol_at(JfrBigEndian::read&lt;u2&gt;(_buffer + _current));
 356   }
 357 };
 358 
<span class="line-removed"> 359 static unsigned int unused_hash = 0;</span>
 360 static const char value_name[] = &quot;value&quot;;
 361 static bool has_annotation(const InstanceKlass* ik, const Symbol* annotation_type, bool&amp; value) {
 362   assert(annotation_type != NULL, &quot;invariant&quot;);
 363   AnnotationArray* class_annotations = ik-&gt;class_annotations();
 364   if (class_annotations == NULL) {
 365     return false;
 366   }
 367 
 368   const AnnotationIterator annotation_iterator(ik, class_annotations);
 369   while (annotation_iterator.has_next()) {
 370     annotation_iterator.move_to_next();
 371     if (annotation_iterator.type() == annotation_type) {
 372       // target annotation found
 373       static const Symbol* value_symbol =
<span class="line-modified"> 374         SymbolTable::lookup_only(value_name, sizeof value_name - 1, unused_hash);</span>
 375       assert(value_symbol != NULL, &quot;invariant&quot;);
 376       const AnnotationElementIterator element_iterator = annotation_iterator.elements();
 377       while (element_iterator.has_next()) {
 378         element_iterator.move_to_next();
 379         if (value_symbol == element_iterator.name()) {
 380           // &quot;value&quot; element
 381           assert(&#39;Z&#39; == element_iterator.value_type(), &quot;invariant&quot;);
 382           value = element_iterator.read_bool();
 383           return true;
 384         }
 385       }
 386     }
 387   }
 388   return false;
 389 }
 390 
 391 // Evaluate to the value of the first found Symbol* annotation type.
 392 // Searching moves upwards in the klass hierarchy in order to support
 393 // inherited annotations in addition to the ability to override.
 394 static bool annotation_value(const InstanceKlass* ik, const Symbol* annotation_type, bool&amp; value) {
 395   assert(ik != NULL, &quot;invariant&quot;);
 396   assert(annotation_type != NULL, &quot;invariant&quot;);
 397   assert(JdkJfrEvent::is_a(ik), &quot;invariant&quot;);
 398   if (has_annotation(ik, annotation_type, value)) {
 399     return true;
 400   }
 401   InstanceKlass* const super = InstanceKlass::cast(ik-&gt;super());
 402   return super != NULL &amp;&amp; JdkJfrEvent::is_a(super) ? annotation_value(super, annotation_type, value) : false;
 403 }
 404 
 405 static const char jdk_jfr_module_name[] = &quot;jdk.jfr&quot;;
 406 
 407 static bool java_base_can_read_jdk_jfr() {
 408   static bool can_read = false;
 409   if (can_read) {
 410     return true;
 411   }
 412   static Symbol* jdk_jfr_module_symbol = NULL;
 413   if (jdk_jfr_module_symbol == NULL) {
<span class="line-modified"> 414     jdk_jfr_module_symbol = SymbolTable::lookup_only(jdk_jfr_module_name, sizeof jdk_jfr_module_name - 1, unused_hash);</span>
 415     if (jdk_jfr_module_symbol == NULL) {
 416       return false;
 417     }
 418   }
 419   assert(jdk_jfr_module_symbol != NULL, &quot;invariant&quot;);
 420   ModuleEntryTable* const table = Modules::get_module_entry_table(Handle());
 421   assert(table != NULL, &quot;invariant&quot;);
 422   const ModuleEntry* const java_base_module = table-&gt;javabase_moduleEntry();
 423   if (java_base_module == NULL) {
 424     return false;
 425   }
 426   assert(java_base_module != NULL, &quot;invariant&quot;);
 427   ModuleEntry* const jdk_jfr_module = table-&gt;lookup_only(jdk_jfr_module_symbol);
 428   if (jdk_jfr_module == NULL) {
 429     return false;
 430   }
 431   assert(jdk_jfr_module != NULL, &quot;invariant&quot;);
 432   if (java_base_module-&gt;can_read(jdk_jfr_module)) {
 433     can_read = true;
 434   }
 435   return can_read;
 436 }
 437 
 438 static const char registered_constant[] = &quot;Ljdk/jfr/Registered;&quot;;
 439 
 440 // Evaluate to the value of the first found &quot;Ljdk/jfr/Registered;&quot; annotation.
 441 // Searching moves upwards in the klass hierarchy in order to support
 442 // inherited annotations in addition to the ability to override.
 443 static bool should_register_klass(const InstanceKlass* ik, bool&amp; untypedEventHandler) {
 444   assert(ik != NULL, &quot;invariant&quot;);
 445   assert(JdkJfrEvent::is_a(ik), &quot;invariant&quot;);
 446   assert(!untypedEventHandler, &quot;invariant&quot;);
 447   static const Symbol* registered_symbol = NULL;
 448   if (registered_symbol == NULL) {
<span class="line-modified"> 449     registered_symbol = SymbolTable::lookup_only(registered_constant, sizeof registered_constant - 1, unused_hash);</span>
 450     if (registered_symbol == NULL) {
 451       untypedEventHandler = true;
 452       return false;
 453     }
 454   }
 455   assert(registered_symbol != NULL, &quot;invariant&quot;);
 456   bool value = false; // to be set by annotation_value
 457   untypedEventHandler = !(annotation_value(ik, registered_symbol, value) || java_base_can_read_jdk_jfr());
 458   return value;
 459 }
 460 
 461 /*
 462  * Map an utf8 constant back to its CONSTANT_UTF8_INFO
 463  */
 464 static u2 utf8_info_index(const InstanceKlass* ik, const Symbol* const target, TRAPS) {
 465   assert(target != NULL, &quot;invariant&quot;);
 466   const ConstantPool* cp = ik-&gt;constants();
 467   const int cp_len = cp-&gt;length();
 468   for (u2 index = 1; index &lt; cp_len; ++index) {
 469     const constantTag tag = cp-&gt;tag_at(index);
</pre>
<hr />
<pre>
1149     orig_stream-&gt;skip_u2_fast(2);
1150     const u2 attributes_count = orig_stream-&gt;get_u2_fast();
1151     for (u2 j = 0; j &lt; attributes_count; ++j) {
1152       orig_stream-&gt;skip_u2_fast(1);
1153       const u4 attrib_len = orig_stream-&gt;get_u4_fast();
1154       orig_stream-&gt;skip_u1_fast(attrib_len);
1155     }
1156   }
1157   return new ClassFileStream(new_buffer, orig_stream_length, NULL, ClassFileStream::verify);
1158 }
1159 
1160 // Attempt to locate an existing UTF8_INFO mapping the utf8_constant.
1161 // If no UTF8_INFO exists, add (append) a new one to the constant pool.
1162 static u2 find_or_add_utf8_info(JfrBigEndianWriter&amp; writer,
1163                                 const InstanceKlass* ik,
1164                                 const char* const utf8_constant,
1165                                 u2 orig_cp_len,
1166                                 u2&amp; added_cp_entries,
1167                                 TRAPS) {
1168   assert(utf8_constant != NULL, &quot;invariant&quot;);
<span class="line-modified">1169   TempNewSymbol utf8_sym = SymbolTable::new_symbol(utf8_constant, THREAD);</span>
1170   // lookup existing
1171   const int utf8_orig_idx = utf8_info_index(ik, utf8_sym, THREAD);
1172   if (utf8_orig_idx != invalid_cp_index) {
1173     // existing constant pool entry found
1174     return utf8_orig_idx;
1175   }
1176   // no existing match, need to add a new utf8 cp entry
1177   assert(invalid_cp_index == utf8_orig_idx, &quot;invariant&quot;);
1178   // add / append new
1179   return add_utf8_info(writer, utf8_constant, orig_cp_len, added_cp_entries);
1180 }
1181 
1182 /*
1183  * This routine will resolve the required utf8_constants array
1184  * to their constant pool indexes (mapping to their UTF8_INFO&#39;s)
1185  * Only if a constant is actually needed and does not already exist
1186  * will it be added.
1187  *
1188  * The passed in indexes array will be populated with the resolved indexes.
1189  * The number of newly added constant pool entries is returned.
</pre>
<hr />
<pre>
1481     return NULL;
1482   }
1483   assert(new_ik != NULL, &quot;invariant&quot;);
1484   assert(new_ik-&gt;name() != NULL, &quot;invariant&quot;);
1485   assert(strncmp(ik-&gt;name()-&gt;as_C_string(), new_ik-&gt;name()-&gt;as_C_string(), strlen(ik-&gt;name()-&gt;as_C_string())) == 0, &quot;invariant&quot;);
1486   return cache_bytes(ik, stream, new_ik, THREAD) ? new_ik : NULL;
1487 }
1488 
1489 static void rewrite_klass_pointer(InstanceKlass*&amp; ik, InstanceKlass* new_ik, ClassFileParser&amp; parser, TRAPS) {
1490   assert(ik != NULL, &quot;invariant&quot;);
1491   assert(new_ik != NULL, &quot;invariant&quot;);
1492   assert(new_ik-&gt;name() != NULL, &quot;invariant&quot;);
1493   assert(JdkJfrEvent::is(new_ik) || JdkJfrEvent::is_subklass(new_ik), &quot;invariant&quot;);
1494   assert(!HAS_PENDING_EXCEPTION, &quot;invariant&quot;);
1495   // assign original InstanceKlass* back onto &quot;its&quot; parser object for proper destruction
1496   parser.set_klass_to_deallocate(ik);
1497   // now rewrite original pointer to newly created InstanceKlass
1498   ik = new_ik;
1499 }
1500 
<span class="line-removed">1501 // During retransform/redefine, copy the Method specific trace flags</span>
<span class="line-removed">1502 // from the previous ik (&quot;the original klass&quot;) to the new ik (&quot;the scratch_klass&quot;).</span>
<span class="line-removed">1503 // The open code for retransform/redefine does not know about these.</span>
<span class="line-removed">1504 // In doing this migration here, we ensure the new Methods (defined in scratch klass)</span>
<span class="line-removed">1505 // will carry over trace tags from the old Methods being replaced,</span>
<span class="line-removed">1506 // ensuring flag/tag continuity while being transparent to open code.</span>
<span class="line-removed">1507 static void copy_method_trace_flags(const InstanceKlass* the_original_klass, const InstanceKlass* the_scratch_klass) {</span>
<span class="line-removed">1508   assert(the_original_klass != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">1509   assert(the_scratch_klass != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">1510   assert(the_original_klass-&gt;name() == the_scratch_klass-&gt;name(), &quot;invariant&quot;);</span>
<span class="line-removed">1511   const Array&lt;Method*&gt;* old_methods = the_original_klass-&gt;methods();</span>
<span class="line-removed">1512   const Array&lt;Method*&gt;* new_methods = the_scratch_klass-&gt;methods();</span>
<span class="line-removed">1513   const bool equal_array_length = old_methods-&gt;length() == new_methods-&gt;length();</span>
<span class="line-removed">1514   // The Method array has the property of being sorted.</span>
<span class="line-removed">1515   // If they are the same length, there is a one-to-one mapping.</span>
<span class="line-removed">1516   // If they are unequal, there was a method added (currently only</span>
<span class="line-removed">1517   // private static methods allowed to be added), use lookup.</span>
<span class="line-removed">1518   for (int i = 0; i &lt; old_methods-&gt;length(); ++i) {</span>
<span class="line-removed">1519     const Method* const old_method = old_methods-&gt;at(i);</span>
<span class="line-removed">1520     Method* const new_method = equal_array_length ? new_methods-&gt;at(i) :</span>
<span class="line-removed">1521       the_scratch_klass-&gt;find_method(old_method-&gt;name(), old_method-&gt;signature());</span>
<span class="line-removed">1522     assert(new_method != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">1523     assert(new_method-&gt;name() == old_method-&gt;name(), &quot;invariant&quot;);</span>
<span class="line-removed">1524     assert(new_method-&gt;signature() == old_method-&gt;signature(), &quot;invariant&quot;);</span>
<span class="line-removed">1525     *new_method-&gt;trace_flags_addr() = old_method-&gt;trace_flags();</span>
<span class="line-removed">1526     assert(new_method-&gt;trace_flags() == old_method-&gt;trace_flags(), &quot;invariant&quot;);</span>
<span class="line-removed">1527   }</span>
<span class="line-removed">1528 }</span>
<span class="line-removed">1529 </span>
1530 static bool is_retransforming(const InstanceKlass* ik, TRAPS) {
1531   assert(ik != NULL, &quot;invariant&quot;);
1532   assert(JdkJfrEvent::is_a(ik), &quot;invariant&quot;);
1533   Symbol* const name = ik-&gt;name();
1534   assert(name != NULL, &quot;invariant&quot;);
1535   Handle class_loader(THREAD, ik-&gt;class_loader());
1536   Handle protection_domain(THREAD, ik-&gt;protection_domain());
<span class="line-modified">1537   // nota bene: use lock-free dictionary lookup</span>
<span class="line-removed">1538   const InstanceKlass* prev_ik = (const InstanceKlass*)SystemDictionary::find(name, class_loader, protection_domain, THREAD);</span>
<span class="line-removed">1539   if (prev_ik == NULL) {</span>
<span class="line-removed">1540     return false;</span>
<span class="line-removed">1541   }</span>
<span class="line-removed">1542   // an existing ik implies a retransform/redefine</span>
<span class="line-removed">1543   assert(prev_ik != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">1544   assert(JdkJfrEvent::is_a(prev_ik), &quot;invariant&quot;);</span>
<span class="line-removed">1545   copy_method_trace_flags(prev_ik, ik);</span>
<span class="line-removed">1546   return true;</span>
1547 }
1548 
1549 // target for JFR_ON_KLASS_CREATION hook
1550 void JfrEventClassTransformer::on_klass_creation(InstanceKlass*&amp; ik, ClassFileParser&amp; parser, TRAPS) {
1551   assert(ik != NULL, &quot;invariant&quot;);
1552   if (JdkJfrEvent::is(ik)) {
1553     ResourceMark rm(THREAD);
1554     HandleMark hm(THREAD);
1555     ClassFileStream* new_stream = create_new_bytes_for_event_klass(ik, parser, THREAD);
1556     if (new_stream == NULL) {
1557       log_error(jfr, system)(&quot;JfrClassAdapter: unable to create ClassFileStream&quot;);
1558       return;
1559     }
1560     assert(new_stream != NULL, &quot;invariant&quot;);
1561     InstanceKlass* new_ik = create_new_instance_klass(ik, new_stream, THREAD);
1562     if (new_ik == NULL) {
1563       log_error(jfr, system)(&quot;JfrClassAdapter: unable to create InstanceKlass&quot;);
1564       return;
1565     }
1566     assert(new_ik != NULL, &quot;invariant&quot;);
1567     // We now need to explicitly tag the replaced klass as the jdk.jfr.Event klass
1568     assert(!JdkJfrEvent::is(new_ik), &quot;invariant&quot;);
1569     JdkJfrEvent::tag_as(new_ik);
1570     assert(JdkJfrEvent::is(new_ik), &quot;invariant&quot;);
1571     rewrite_klass_pointer(ik, new_ik, parser, THREAD);
1572     return;
1573   }
1574   assert(JdkJfrEvent::is_subklass(ik), &quot;invariant&quot;);
<span class="line-modified">1575   if (is_retransforming(ik, THREAD)) {</span>
<span class="line-modified">1576     // not the initial klass load</span>
<span class="line-removed">1577     return;</span>
<span class="line-removed">1578   }</span>
<span class="line-removed">1579   if (ik-&gt;is_abstract()) {</span>
<span class="line-removed">1580     // abstract classes are not instrumented</span>
1581     return;
1582   }
1583   ResourceMark rm(THREAD);
1584   HandleMark hm(THREAD);
1585   ClassFileStream* const new_stream = create_new_bytes_for_subklass(ik, parser, THREAD);
1586   if (NULL == new_stream) {
1587     log_error(jfr, system)(&quot;JfrClassAdapter: unable to create ClassFileStream&quot;);
1588     return;
1589   }
1590   assert(new_stream != NULL, &quot;invariant&quot;);
1591   InstanceKlass* new_ik = create_new_instance_klass(ik, new_stream, THREAD);
1592   if (new_ik == NULL) {
1593     log_error(jfr, system)(&quot;JfrClassAdapter: unable to create InstanceKlass&quot;);
1594     return;
1595   }
1596   assert(new_ik != NULL, &quot;invariant&quot;);
1597   // would have been tagged already as a subklass during the normal process of traceid assignment
1598   assert(JdkJfrEvent::is_subklass(new_ik), &quot;invariant&quot;);
1599   traceid id = ik-&gt;trace_id();
1600   ik-&gt;set_trace_id(0);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classFileParser.hpp&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/javaClasses.inline.hpp&quot;
  30 #include &quot;classfile/moduleEntry.hpp&quot;
  31 #include &quot;classfile/modules.hpp&quot;
  32 #include &quot;classfile/stackMapTable.hpp&quot;
<span class="line-added">  33 #include &quot;classfile/symbolTable.hpp&quot;</span>
  34 #include &quot;classfile/verificationType.hpp&quot;
  35 #include &quot;interpreter/bytecodes.hpp&quot;
  36 #include &quot;jfr/instrumentation/jfrEventClassTransformer.hpp&quot;
  37 #include &quot;jfr/jfr.hpp&quot;
  38 #include &quot;jfr/jni/jfrJavaSupport.hpp&quot;
  39 #include &quot;jfr/jni/jfrUpcalls.hpp&quot;
  40 #include &quot;jfr/support/jfrEventClass.hpp&quot;
  41 #include &quot;jfr/utilities/jfrBigEndian.hpp&quot;
  42 #include &quot;jfr/writers/jfrBigEndianWriter.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;memory/allocation.inline.hpp&quot;
  45 #include &quot;memory/resourceArea.hpp&quot;
  46 #include &quot;oops/array.hpp&quot;

  47 #include &quot;oops/instanceKlass.hpp&quot;
  48 #include &quot;oops/method.hpp&quot;
  49 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  50 #include &quot;runtime/handles.inline.hpp&quot;
  51 #include &quot;runtime/os.hpp&quot;
  52 #include &quot;runtime/thread.inline.hpp&quot;
  53 #include &quot;utilities/exceptions.hpp&quot;
  54 #include &quot;utilities/globalDefinitions.hpp&quot;
  55 #include &quot;utilities/macros.hpp&quot;
  56 
  57 static const u2 number_of_new_methods = 5;
  58 static const u2 number_of_new_fields = 3;
  59 static const int extra_stream_bytes = 0x280;
  60 static const u2 invalid_cp_index = 0;
  61 
  62 static const char* utf8_constants[] = {
  63   &quot;Code&quot;,         // 0
  64   &quot;J&quot;,            // 1
  65   &quot;commit&quot;,       // 2
  66   &quot;eventHandler&quot;, // 3
</pre>
<hr />
<pre>
 339   void move_to_next() const {
 340     assert(has_next(), &quot;invariant&quot;);
 341     _current = _next;
 342     if (_next &lt; _limit) {
 343       _next = next_annotation_index(_buffer, _limit, _next);
 344     }
 345     assert(_next &lt;= _limit, &quot;invariant&quot;);
 346     assert(_current &lt;= _limit, &quot;invariant&quot;);
 347   }
 348   const AnnotationElementIterator elements() const {
 349     assert(_current &lt; _next, &quot;invariant&quot;);
 350     return AnnotationElementIterator(_ik, _buffer + _current, _next - _current);
 351   }
 352   const Symbol* type() const {
 353     assert(_buffer != NULL, &quot;invariant&quot;);
 354     assert(_current &lt; _limit, &quot;invariant&quot;);
 355     return _ik-&gt;constants()-&gt;symbol_at(JfrBigEndian::read&lt;u2&gt;(_buffer + _current));
 356   }
 357 };
 358 

 359 static const char value_name[] = &quot;value&quot;;
 360 static bool has_annotation(const InstanceKlass* ik, const Symbol* annotation_type, bool&amp; value) {
 361   assert(annotation_type != NULL, &quot;invariant&quot;);
 362   AnnotationArray* class_annotations = ik-&gt;class_annotations();
 363   if (class_annotations == NULL) {
 364     return false;
 365   }
 366 
 367   const AnnotationIterator annotation_iterator(ik, class_annotations);
 368   while (annotation_iterator.has_next()) {
 369     annotation_iterator.move_to_next();
 370     if (annotation_iterator.type() == annotation_type) {
 371       // target annotation found
 372       static const Symbol* value_symbol =
<span class="line-modified"> 373         SymbolTable::probe(value_name, sizeof value_name - 1);</span>
 374       assert(value_symbol != NULL, &quot;invariant&quot;);
 375       const AnnotationElementIterator element_iterator = annotation_iterator.elements();
 376       while (element_iterator.has_next()) {
 377         element_iterator.move_to_next();
 378         if (value_symbol == element_iterator.name()) {
 379           // &quot;value&quot; element
 380           assert(&#39;Z&#39; == element_iterator.value_type(), &quot;invariant&quot;);
 381           value = element_iterator.read_bool();
 382           return true;
 383         }
 384       }
 385     }
 386   }
 387   return false;
 388 }
 389 
 390 // Evaluate to the value of the first found Symbol* annotation type.
 391 // Searching moves upwards in the klass hierarchy in order to support
 392 // inherited annotations in addition to the ability to override.
 393 static bool annotation_value(const InstanceKlass* ik, const Symbol* annotation_type, bool&amp; value) {
 394   assert(ik != NULL, &quot;invariant&quot;);
 395   assert(annotation_type != NULL, &quot;invariant&quot;);
 396   assert(JdkJfrEvent::is_a(ik), &quot;invariant&quot;);
 397   if (has_annotation(ik, annotation_type, value)) {
 398     return true;
 399   }
 400   InstanceKlass* const super = InstanceKlass::cast(ik-&gt;super());
 401   return super != NULL &amp;&amp; JdkJfrEvent::is_a(super) ? annotation_value(super, annotation_type, value) : false;
 402 }
 403 
 404 static const char jdk_jfr_module_name[] = &quot;jdk.jfr&quot;;
 405 
 406 static bool java_base_can_read_jdk_jfr() {
 407   static bool can_read = false;
 408   if (can_read) {
 409     return true;
 410   }
 411   static Symbol* jdk_jfr_module_symbol = NULL;
 412   if (jdk_jfr_module_symbol == NULL) {
<span class="line-modified"> 413     jdk_jfr_module_symbol = SymbolTable::probe(jdk_jfr_module_name, sizeof jdk_jfr_module_name - 1);</span>
 414     if (jdk_jfr_module_symbol == NULL) {
 415       return false;
 416     }
 417   }
 418   assert(jdk_jfr_module_symbol != NULL, &quot;invariant&quot;);
 419   ModuleEntryTable* const table = Modules::get_module_entry_table(Handle());
 420   assert(table != NULL, &quot;invariant&quot;);
 421   const ModuleEntry* const java_base_module = table-&gt;javabase_moduleEntry();
 422   if (java_base_module == NULL) {
 423     return false;
 424   }
 425   assert(java_base_module != NULL, &quot;invariant&quot;);
 426   ModuleEntry* const jdk_jfr_module = table-&gt;lookup_only(jdk_jfr_module_symbol);
 427   if (jdk_jfr_module == NULL) {
 428     return false;
 429   }
 430   assert(jdk_jfr_module != NULL, &quot;invariant&quot;);
 431   if (java_base_module-&gt;can_read(jdk_jfr_module)) {
 432     can_read = true;
 433   }
 434   return can_read;
 435 }
 436 
 437 static const char registered_constant[] = &quot;Ljdk/jfr/Registered;&quot;;
 438 
 439 // Evaluate to the value of the first found &quot;Ljdk/jfr/Registered;&quot; annotation.
 440 // Searching moves upwards in the klass hierarchy in order to support
 441 // inherited annotations in addition to the ability to override.
 442 static bool should_register_klass(const InstanceKlass* ik, bool&amp; untypedEventHandler) {
 443   assert(ik != NULL, &quot;invariant&quot;);
 444   assert(JdkJfrEvent::is_a(ik), &quot;invariant&quot;);
 445   assert(!untypedEventHandler, &quot;invariant&quot;);
 446   static const Symbol* registered_symbol = NULL;
 447   if (registered_symbol == NULL) {
<span class="line-modified"> 448     registered_symbol = SymbolTable::probe(registered_constant, sizeof registered_constant - 1);</span>
 449     if (registered_symbol == NULL) {
 450       untypedEventHandler = true;
 451       return false;
 452     }
 453   }
 454   assert(registered_symbol != NULL, &quot;invariant&quot;);
 455   bool value = false; // to be set by annotation_value
 456   untypedEventHandler = !(annotation_value(ik, registered_symbol, value) || java_base_can_read_jdk_jfr());
 457   return value;
 458 }
 459 
 460 /*
 461  * Map an utf8 constant back to its CONSTANT_UTF8_INFO
 462  */
 463 static u2 utf8_info_index(const InstanceKlass* ik, const Symbol* const target, TRAPS) {
 464   assert(target != NULL, &quot;invariant&quot;);
 465   const ConstantPool* cp = ik-&gt;constants();
 466   const int cp_len = cp-&gt;length();
 467   for (u2 index = 1; index &lt; cp_len; ++index) {
 468     const constantTag tag = cp-&gt;tag_at(index);
</pre>
<hr />
<pre>
1148     orig_stream-&gt;skip_u2_fast(2);
1149     const u2 attributes_count = orig_stream-&gt;get_u2_fast();
1150     for (u2 j = 0; j &lt; attributes_count; ++j) {
1151       orig_stream-&gt;skip_u2_fast(1);
1152       const u4 attrib_len = orig_stream-&gt;get_u4_fast();
1153       orig_stream-&gt;skip_u1_fast(attrib_len);
1154     }
1155   }
1156   return new ClassFileStream(new_buffer, orig_stream_length, NULL, ClassFileStream::verify);
1157 }
1158 
1159 // Attempt to locate an existing UTF8_INFO mapping the utf8_constant.
1160 // If no UTF8_INFO exists, add (append) a new one to the constant pool.
1161 static u2 find_or_add_utf8_info(JfrBigEndianWriter&amp; writer,
1162                                 const InstanceKlass* ik,
1163                                 const char* const utf8_constant,
1164                                 u2 orig_cp_len,
1165                                 u2&amp; added_cp_entries,
1166                                 TRAPS) {
1167   assert(utf8_constant != NULL, &quot;invariant&quot;);
<span class="line-modified">1168   TempNewSymbol utf8_sym = SymbolTable::new_symbol(utf8_constant);</span>
1169   // lookup existing
1170   const int utf8_orig_idx = utf8_info_index(ik, utf8_sym, THREAD);
1171   if (utf8_orig_idx != invalid_cp_index) {
1172     // existing constant pool entry found
1173     return utf8_orig_idx;
1174   }
1175   // no existing match, need to add a new utf8 cp entry
1176   assert(invalid_cp_index == utf8_orig_idx, &quot;invariant&quot;);
1177   // add / append new
1178   return add_utf8_info(writer, utf8_constant, orig_cp_len, added_cp_entries);
1179 }
1180 
1181 /*
1182  * This routine will resolve the required utf8_constants array
1183  * to their constant pool indexes (mapping to their UTF8_INFO&#39;s)
1184  * Only if a constant is actually needed and does not already exist
1185  * will it be added.
1186  *
1187  * The passed in indexes array will be populated with the resolved indexes.
1188  * The number of newly added constant pool entries is returned.
</pre>
<hr />
<pre>
1480     return NULL;
1481   }
1482   assert(new_ik != NULL, &quot;invariant&quot;);
1483   assert(new_ik-&gt;name() != NULL, &quot;invariant&quot;);
1484   assert(strncmp(ik-&gt;name()-&gt;as_C_string(), new_ik-&gt;name()-&gt;as_C_string(), strlen(ik-&gt;name()-&gt;as_C_string())) == 0, &quot;invariant&quot;);
1485   return cache_bytes(ik, stream, new_ik, THREAD) ? new_ik : NULL;
1486 }
1487 
1488 static void rewrite_klass_pointer(InstanceKlass*&amp; ik, InstanceKlass* new_ik, ClassFileParser&amp; parser, TRAPS) {
1489   assert(ik != NULL, &quot;invariant&quot;);
1490   assert(new_ik != NULL, &quot;invariant&quot;);
1491   assert(new_ik-&gt;name() != NULL, &quot;invariant&quot;);
1492   assert(JdkJfrEvent::is(new_ik) || JdkJfrEvent::is_subklass(new_ik), &quot;invariant&quot;);
1493   assert(!HAS_PENDING_EXCEPTION, &quot;invariant&quot;);
1494   // assign original InstanceKlass* back onto &quot;its&quot; parser object for proper destruction
1495   parser.set_klass_to_deallocate(ik);
1496   // now rewrite original pointer to newly created InstanceKlass
1497   ik = new_ik;
1498 }
1499 





























1500 static bool is_retransforming(const InstanceKlass* ik, TRAPS) {
1501   assert(ik != NULL, &quot;invariant&quot;);
1502   assert(JdkJfrEvent::is_a(ik), &quot;invariant&quot;);
1503   Symbol* const name = ik-&gt;name();
1504   assert(name != NULL, &quot;invariant&quot;);
1505   Handle class_loader(THREAD, ik-&gt;class_loader());
1506   Handle protection_domain(THREAD, ik-&gt;protection_domain());
<span class="line-modified">1507   return SystemDictionary::find(name, class_loader, protection_domain, THREAD) != NULL;</span>









1508 }
1509 
1510 // target for JFR_ON_KLASS_CREATION hook
1511 void JfrEventClassTransformer::on_klass_creation(InstanceKlass*&amp; ik, ClassFileParser&amp; parser, TRAPS) {
1512   assert(ik != NULL, &quot;invariant&quot;);
1513   if (JdkJfrEvent::is(ik)) {
1514     ResourceMark rm(THREAD);
1515     HandleMark hm(THREAD);
1516     ClassFileStream* new_stream = create_new_bytes_for_event_klass(ik, parser, THREAD);
1517     if (new_stream == NULL) {
1518       log_error(jfr, system)(&quot;JfrClassAdapter: unable to create ClassFileStream&quot;);
1519       return;
1520     }
1521     assert(new_stream != NULL, &quot;invariant&quot;);
1522     InstanceKlass* new_ik = create_new_instance_klass(ik, new_stream, THREAD);
1523     if (new_ik == NULL) {
1524       log_error(jfr, system)(&quot;JfrClassAdapter: unable to create InstanceKlass&quot;);
1525       return;
1526     }
1527     assert(new_ik != NULL, &quot;invariant&quot;);
1528     // We now need to explicitly tag the replaced klass as the jdk.jfr.Event klass
1529     assert(!JdkJfrEvent::is(new_ik), &quot;invariant&quot;);
1530     JdkJfrEvent::tag_as(new_ik);
1531     assert(JdkJfrEvent::is(new_ik), &quot;invariant&quot;);
1532     rewrite_klass_pointer(ik, new_ik, parser, THREAD);
1533     return;
1534   }
1535   assert(JdkJfrEvent::is_subklass(ik), &quot;invariant&quot;);
<span class="line-modified">1536   if (ik-&gt;is_abstract() || is_retransforming(ik, THREAD)) {</span>
<span class="line-modified">1537     // abstract and scratch classes are not instrumented</span>




1538     return;
1539   }
1540   ResourceMark rm(THREAD);
1541   HandleMark hm(THREAD);
1542   ClassFileStream* const new_stream = create_new_bytes_for_subklass(ik, parser, THREAD);
1543   if (NULL == new_stream) {
1544     log_error(jfr, system)(&quot;JfrClassAdapter: unable to create ClassFileStream&quot;);
1545     return;
1546   }
1547   assert(new_stream != NULL, &quot;invariant&quot;);
1548   InstanceKlass* new_ik = create_new_instance_klass(ik, new_stream, THREAD);
1549   if (new_ik == NULL) {
1550     log_error(jfr, system)(&quot;JfrClassAdapter: unable to create InstanceKlass&quot;);
1551     return;
1552   }
1553   assert(new_ik != NULL, &quot;invariant&quot;);
1554   // would have been tagged already as a subklass during the normal process of traceid assignment
1555   assert(JdkJfrEvent::is_subklass(new_ik), &quot;invariant&quot;);
1556   traceid id = ik-&gt;trace_id();
1557   ik-&gt;set_trace_id(0);
</pre>
</td>
</tr>
</table>
<center><a href="../dcmd/jfrDcmds.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jfrJvmtiAgent.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
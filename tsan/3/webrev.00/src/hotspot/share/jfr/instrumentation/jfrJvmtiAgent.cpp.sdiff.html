<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/instrumentation/jfrJvmtiAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="jfrEventClassTransformer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../jfr.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/instrumentation/jfrJvmtiAgent.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
 27 #include &quot;jfr/instrumentation/jfrJvmtiAgent.hpp&quot;
 28 #include &quot;jfr/jni/jfrJavaSupport.hpp&quot;
 29 #include &quot;jfr/jni/jfrUpcalls.hpp&quot;
 30 #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceId.inline.hpp&quot;
 31 #include &quot;jfr/recorder/service/jfrOptionSet.hpp&quot;
 32 #include &quot;jfr/support/jfrEventClass.hpp&quot;
 33 #include &quot;logging/log.hpp&quot;
 34 #include &quot;memory/resourceArea.hpp&quot;

 35 #include &quot;prims/jvmtiExport.hpp&quot;

 36 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 37 #include &quot;runtime/thread.inline.hpp&quot;
 38 #include &quot;utilities/exceptions.hpp&quot;
 39 
 40 static const size_t ERROR_MSG_BUFFER_SIZE = 256;
 41 static JfrJvmtiAgent* agent = NULL;
 42 static jvmtiEnv* jfr_jvmti_env = NULL;
 43 
 44 static void check_jvmti_error(jvmtiEnv* jvmti, jvmtiError errnum, const char* str) {
 45   if (errnum != JVMTI_ERROR_NONE) {
 46     char* errnum_str = NULL;
 47     jvmti-&gt;GetErrorName(errnum, &amp;errnum_str);
 48     log_error(jfr, system)(&quot;ERROR: JfrJvmtiAgent: &quot; INT32_FORMAT &quot; (%s): %s\n&quot;,
 49                            errnum,
 50                            NULL == errnum_str ? &quot;Unknown&quot; : errnum_str,
 51                            NULL == str ? &quot;&quot; : str);
 52   }
 53 }
 54 
<span class="line-modified"> 55 static jvmtiError set_event_notification_mode(jvmtiEventMode mode,</span>
<span class="line-modified"> 56                                               jvmtiEvent event,</span>
<span class="line-modified"> 57                                               jthread event_thread,</span>
<span class="line-modified"> 58                                               ...) {</span>
<span class="line-modified"> 59   if (jfr_jvmti_env == NULL) {</span>
<span class="line-removed"> 60     return JVMTI_ERROR_NONE;</span>
<span class="line-removed"> 61   }</span>
 62   const jvmtiError jvmti_ret_code = jfr_jvmti_env-&gt;SetEventNotificationMode(mode, event, event_thread);
 63   check_jvmti_error(jfr_jvmti_env, jvmti_ret_code, &quot;SetEventNotificationMode&quot;);
<span class="line-modified"> 64   return jvmti_ret_code;</span>
 65 }
 66 
<span class="line-modified"> 67 static jvmtiError update_class_file_load_hook_event(jvmtiEventMode mode) {</span>
 68   return set_event_notification_mode(mode, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, NULL);
 69 }
 70 
 71 static JavaThread* current_java_thread() {
 72   Thread* this_thread = Thread::current();
 73   assert(this_thread != NULL &amp;&amp; this_thread-&gt;is_Java_thread(), &quot;invariant&quot;);
 74   return static_cast&lt;JavaThread*&gt;(this_thread);
 75 }
 76 
 77 // jvmti event callbacks require C linkage
 78 extern &quot;C&quot; void JNICALL jfr_on_class_file_load_hook(jvmtiEnv *jvmti_env,
 79                                                     JNIEnv* jni_env,
 80                                                     jclass class_being_redefined,
 81                                                     jobject loader,
 82                                                     const char* name,
 83                                                     jobject protection_domain,
 84                                                     jint class_data_len,
 85                                                     const unsigned char* class_data,
 86                                                     jint* new_class_data_len,
 87                                                     unsigned char** new_class_data) {
</pre>
<hr />
<pre>
100                              jt);
101 }
102 
103 // caller needs ResourceMark
104 static jclass* create_classes_array(jint classes_count, TRAPS) {
105   assert(classes_count &gt; 0, &quot;invariant&quot;);
106   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(THREAD));
107   ThreadInVMfromNative tvmfn((JavaThread*)THREAD);
108   jclass* const classes = NEW_RESOURCE_ARRAY_IN_THREAD_RETURN_NULL(THREAD, jclass, classes_count);
109   if (NULL == classes) {
110     char error_buffer[ERROR_MSG_BUFFER_SIZE];
111     jio_snprintf(error_buffer, ERROR_MSG_BUFFER_SIZE,
112       &quot;Thread local allocation (native) of &quot; SIZE_FORMAT &quot; bytes failed &quot;
113       &quot;in retransform classes&quot;, sizeof(jclass) * classes_count);
114     log_error(jfr, system)(&quot;%s&quot;, error_buffer);
115     JfrJavaSupport::throw_out_of_memory_error(error_buffer, CHECK_NULL);
116   }
117   return classes;
118 }
119 
<span class="line-modified">120 static void log_and_throw(TRAPS) {</span>

121   if (!HAS_PENDING_EXCEPTION) {
122     DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(THREAD));
123     ThreadInVMfromNative tvmfn((JavaThread*)THREAD);
<span class="line-modified">124     log_error(jfr, system)(&quot;JfrJvmtiAgent::retransformClasses failed&quot;);</span>
<span class="line-modified">125     JfrJavaSupport::throw_class_format_error(&quot;JfrJvmtiAgent::retransformClasses failed&quot;, THREAD);</span>










126   }
127 }
128 
129 static void check_exception_and_log(JNIEnv* env, TRAPS) {
130   assert(env != NULL, &quot;invariant&quot;);
131   if (env-&gt;ExceptionOccurred()) {
132     // array index out of bound
133     DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(THREAD));
134     ThreadInVMfromNative tvmfn((JavaThread*)THREAD);
135     log_error(jfr, system)(&quot;GetObjectArrayElement threw an exception&quot;);
136     return;
137   }
138 }
139 




140 void JfrJvmtiAgent::retransform_classes(JNIEnv* env, jobjectArray classes_array, TRAPS) {
141   assert(env != NULL, &quot;invariant&quot;);


142   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(THREAD));
<span class="line-removed">143   if (classes_array == NULL) {</span>
<span class="line-removed">144     return;</span>
<span class="line-removed">145   }</span>
146   const jint classes_count = env-&gt;GetArrayLength(classes_array);
147   if (classes_count &lt;= 0) {
148     return;
149   }
150   ResourceMark rm(THREAD);
151   jclass* const classes = create_classes_array(classes_count, CHECK);
152   assert(classes != NULL, &quot;invariant&quot;);
153   for (jint i = 0; i &lt; classes_count; i++) {
154     jclass clz = (jclass)env-&gt;GetObjectArrayElement(classes_array, i);
155     check_exception_and_log(env, THREAD);
<span class="line-modified">156 </span>


157     // inspecting the oop/klass requires a thread transition
<span class="line-modified">158     {</span>
<span class="line-modified">159       ThreadInVMfromNative transition((JavaThread*)THREAD);</span>
<span class="line-modified">160       if (JdkJfrEvent::is_a(clz)) {</span>
<span class="line-modified">161         // should have been tagged already</span>
<span class="line-removed">162         assert(JdkJfrEvent::is_subklass(clz), &quot;invariant&quot;);</span>
<span class="line-removed">163       } else {</span>
164         // outside the event hierarchy
165         JdkJfrEvent::tag_as_host(clz);
166       }
167     }
<span class="line-removed">168 </span>
<span class="line-removed">169     classes[i] = clz;</span>
170   }
<span class="line-modified">171   if (jfr_jvmti_env-&gt;RetransformClasses(classes_count, classes) != JVMTI_ERROR_NONE) {</span>
<span class="line-modified">172     log_and_throw(THREAD);</span>


173   }
174 }
175 
<span class="line-modified">176 static jvmtiError register_callbacks(JavaThread* jt) {</span>
177   assert(jfr_jvmti_env != NULL, &quot;invariant&quot;);
178   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt));
179   jvmtiEventCallbacks callbacks;
180   /* Set callbacks */
181   memset(&amp;callbacks, 0, sizeof(callbacks));
182   callbacks.ClassFileLoadHook = jfr_on_class_file_load_hook;
183   const jvmtiError jvmti_ret_code = jfr_jvmti_env-&gt;SetEventCallbacks(&amp;callbacks, sizeof(callbacks));
184   check_jvmti_error(jfr_jvmti_env, jvmti_ret_code, &quot;SetEventCallbacks&quot;);
<span class="line-modified">185   return jvmti_ret_code;</span>
186 }
187 
<span class="line-modified">188 static jvmtiError register_capabilities(JavaThread* jt) {</span>
189   assert(jfr_jvmti_env != NULL, &quot;invariant&quot;);
190   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt));
191   jvmtiCapabilities capabilities;
192   /* Add JVMTI capabilities */
193   (void)memset(&amp;capabilities, 0, sizeof(capabilities));
194   capabilities.can_retransform_classes = 1;
195   capabilities.can_retransform_any_class = 1;
196   const jvmtiError jvmti_ret_code = jfr_jvmti_env-&gt;AddCapabilities(&amp;capabilities);
197   check_jvmti_error(jfr_jvmti_env, jvmti_ret_code, &quot;Add Capabilities&quot;);
<span class="line-modified">198   return jvmti_ret_code;</span>
199 }
200 
201 static jint create_jvmti_env(JavaThread* jt) {
202   assert(jfr_jvmti_env == NULL, &quot;invariant&quot;);
203   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt));
204   extern struct JavaVM_ main_vm;
205   JavaVM* vm = &amp;main_vm;
206   return vm-&gt;GetEnv((void **)&amp;jfr_jvmti_env, JVMTI_VERSION);
207 }
208 
<span class="line-modified">209 static jvmtiError unregister_callbacks(JavaThread* jt) {</span>
<span class="line-modified">210   if (jfr_jvmti_env == NULL) {</span>
<span class="line-removed">211     return JVMTI_ERROR_NONE;</span>
<span class="line-removed">212   }</span>
213   jvmtiEventCallbacks callbacks;
214   /* Set empty callbacks */
215   memset(&amp;callbacks, 0, sizeof(callbacks));
216   const jvmtiError jvmti_ret_code = jfr_jvmti_env-&gt;SetEventCallbacks(&amp;callbacks, sizeof(callbacks));
217   check_jvmti_error(jfr_jvmti_env, jvmti_ret_code, &quot;SetEventCallbacks&quot;);
<span class="line-modified">218   return jvmti_ret_code;</span>
219 }
220 
221 JfrJvmtiAgent::JfrJvmtiAgent() {}
222 
223 JfrJvmtiAgent::~JfrJvmtiAgent() {
224   JavaThread* jt = current_java_thread();
225   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(jt));
<span class="line-removed">226   ThreadToNativeFromVM transition(jt);</span>
<span class="line-removed">227   update_class_file_load_hook_event(JVMTI_DISABLE);</span>
<span class="line-removed">228   unregister_callbacks(jt);</span>
229   if (jfr_jvmti_env != NULL) {



230     jfr_jvmti_env-&gt;DisposeEnvironment();
231     jfr_jvmti_env = NULL;
232   }
<span class="line-removed">233   agent = NULL;</span>
234 }
235 
<span class="line-modified">236 static bool initialize() {</span>
<span class="line-removed">237   JavaThread* const jt = current_java_thread();</span>
238   assert(jt != NULL, &quot;invariant&quot;);
<span class="line-removed">239   assert(jt-&gt;thread_state() == _thread_in_vm, &quot;invariant&quot;);</span>
240   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(jt));
241   ThreadToNativeFromVM transition(jt);
242   if (create_jvmti_env(jt) != JNI_OK) {
243     assert(jfr_jvmti_env == NULL, &quot;invariant&quot;);
244     return false;
245   }
246   assert(jfr_jvmti_env != NULL, &quot;invariant&quot;);
<span class="line-modified">247   if (register_capabilities(jt) != JVMTI_ERROR_NONE) {</span>
248     return false;
249   }
<span class="line-modified">250   if (register_callbacks(jt) != JVMTI_ERROR_NONE) {</span>
251     return false;
252   }
<span class="line-modified">253   if (update_class_file_load_hook_event(JVMTI_ENABLE) != JVMTI_ERROR_NONE) {</span>
<span class="line-modified">254     return false;</span>
<span class="line-modified">255   }</span>
<span class="line-modified">256   return true;</span>






257 }
258 
259 bool JfrJvmtiAgent::create() {
<span class="line-modified">260   assert(jfr_jvmti_env == NULL, &quot;invariant&quot;);</span>





261   agent = new JfrJvmtiAgent();
262   if (agent == NULL) {
263     return false;
264   }
<span class="line-modified">265   if (!initialize()) {</span>
266     delete agent;
267     agent = NULL;
268     return false;
269   }
270   return true;
271 }
272 
273 void JfrJvmtiAgent::destroy() {
274   if (agent != NULL) {
275     delete agent;
276     agent = NULL;
277   }
278 }
<span class="line-removed">279 </span>
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
 27 #include &quot;jfr/instrumentation/jfrJvmtiAgent.hpp&quot;
 28 #include &quot;jfr/jni/jfrJavaSupport.hpp&quot;
 29 #include &quot;jfr/jni/jfrUpcalls.hpp&quot;
 30 #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceId.inline.hpp&quot;
 31 #include &quot;jfr/recorder/service/jfrOptionSet.hpp&quot;
 32 #include &quot;jfr/support/jfrEventClass.hpp&quot;
 33 #include &quot;logging/log.hpp&quot;
 34 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added"> 35 #include &quot;prims/jvmtiEnvBase.hpp&quot;</span>
 36 #include &quot;prims/jvmtiExport.hpp&quot;
<span class="line-added"> 37 #include &quot;prims/jvmtiUtil.hpp&quot;</span>
 38 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 39 #include &quot;runtime/thread.inline.hpp&quot;
 40 #include &quot;utilities/exceptions.hpp&quot;
 41 
 42 static const size_t ERROR_MSG_BUFFER_SIZE = 256;
 43 static JfrJvmtiAgent* agent = NULL;
 44 static jvmtiEnv* jfr_jvmti_env = NULL;
 45 
 46 static void check_jvmti_error(jvmtiEnv* jvmti, jvmtiError errnum, const char* str) {
 47   if (errnum != JVMTI_ERROR_NONE) {
 48     char* errnum_str = NULL;
 49     jvmti-&gt;GetErrorName(errnum, &amp;errnum_str);
 50     log_error(jfr, system)(&quot;ERROR: JfrJvmtiAgent: &quot; INT32_FORMAT &quot; (%s): %s\n&quot;,
 51                            errnum,
 52                            NULL == errnum_str ? &quot;Unknown&quot; : errnum_str,
 53                            NULL == str ? &quot;&quot; : str);
 54   }
 55 }
 56 
<span class="line-modified"> 57 static bool set_event_notification_mode(jvmtiEventMode mode,</span>
<span class="line-modified"> 58                                         jvmtiEvent event,</span>
<span class="line-modified"> 59                                         jthread event_thread,</span>
<span class="line-modified"> 60                                         ...) {</span>
<span class="line-modified"> 61   assert(jfr_jvmti_env != NULL, &quot;invariant&quot;);</span>


 62   const jvmtiError jvmti_ret_code = jfr_jvmti_env-&gt;SetEventNotificationMode(mode, event, event_thread);
 63   check_jvmti_error(jfr_jvmti_env, jvmti_ret_code, &quot;SetEventNotificationMode&quot;);
<span class="line-modified"> 64   return jvmti_ret_code == JVMTI_ERROR_NONE;</span>
 65 }
 66 
<span class="line-modified"> 67 static bool update_class_file_load_hook_event(jvmtiEventMode mode) {</span>
 68   return set_event_notification_mode(mode, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, NULL);
 69 }
 70 
 71 static JavaThread* current_java_thread() {
 72   Thread* this_thread = Thread::current();
 73   assert(this_thread != NULL &amp;&amp; this_thread-&gt;is_Java_thread(), &quot;invariant&quot;);
 74   return static_cast&lt;JavaThread*&gt;(this_thread);
 75 }
 76 
 77 // jvmti event callbacks require C linkage
 78 extern &quot;C&quot; void JNICALL jfr_on_class_file_load_hook(jvmtiEnv *jvmti_env,
 79                                                     JNIEnv* jni_env,
 80                                                     jclass class_being_redefined,
 81                                                     jobject loader,
 82                                                     const char* name,
 83                                                     jobject protection_domain,
 84                                                     jint class_data_len,
 85                                                     const unsigned char* class_data,
 86                                                     jint* new_class_data_len,
 87                                                     unsigned char** new_class_data) {
</pre>
<hr />
<pre>
100                              jt);
101 }
102 
103 // caller needs ResourceMark
104 static jclass* create_classes_array(jint classes_count, TRAPS) {
105   assert(classes_count &gt; 0, &quot;invariant&quot;);
106   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(THREAD));
107   ThreadInVMfromNative tvmfn((JavaThread*)THREAD);
108   jclass* const classes = NEW_RESOURCE_ARRAY_IN_THREAD_RETURN_NULL(THREAD, jclass, classes_count);
109   if (NULL == classes) {
110     char error_buffer[ERROR_MSG_BUFFER_SIZE];
111     jio_snprintf(error_buffer, ERROR_MSG_BUFFER_SIZE,
112       &quot;Thread local allocation (native) of &quot; SIZE_FORMAT &quot; bytes failed &quot;
113       &quot;in retransform classes&quot;, sizeof(jclass) * classes_count);
114     log_error(jfr, system)(&quot;%s&quot;, error_buffer);
115     JfrJavaSupport::throw_out_of_memory_error(error_buffer, CHECK_NULL);
116   }
117   return classes;
118 }
119 
<span class="line-modified">120 // caller needs ResourceMark</span>
<span class="line-added">121 static void log_and_throw(jvmtiError error, TRAPS) {</span>
122   if (!HAS_PENDING_EXCEPTION) {
123     DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(THREAD));
124     ThreadInVMfromNative tvmfn((JavaThread*)THREAD);
<span class="line-modified">125     const char base_error_msg[] = &quot;JfrJvmtiAgent::retransformClasses failed: &quot;;</span>
<span class="line-modified">126     size_t length = sizeof base_error_msg; // includes terminating null</span>
<span class="line-added">127     const char* const jvmti_error_name = JvmtiUtil::error_name(error);</span>
<span class="line-added">128     assert(jvmti_error_name != NULL, &quot;invariant&quot;);</span>
<span class="line-added">129     length += strlen(jvmti_error_name);</span>
<span class="line-added">130     char* error_msg = NEW_RESOURCE_ARRAY(char, length);</span>
<span class="line-added">131     jio_snprintf(error_msg, length, &quot;%s%s&quot;, base_error_msg, jvmti_error_name);</span>
<span class="line-added">132     if (JVMTI_ERROR_INVALID_CLASS_FORMAT == error) {</span>
<span class="line-added">133       JfrJavaSupport::throw_class_format_error(error_msg, THREAD);</span>
<span class="line-added">134     } else {</span>
<span class="line-added">135       JfrJavaSupport::throw_runtime_exception(error_msg, THREAD);</span>
<span class="line-added">136     }</span>
137   }
138 }
139 
140 static void check_exception_and_log(JNIEnv* env, TRAPS) {
141   assert(env != NULL, &quot;invariant&quot;);
142   if (env-&gt;ExceptionOccurred()) {
143     // array index out of bound
144     DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(THREAD));
145     ThreadInVMfromNative tvmfn((JavaThread*)THREAD);
146     log_error(jfr, system)(&quot;GetObjectArrayElement threw an exception&quot;);
147     return;
148   }
149 }
150 
<span class="line-added">151 static bool is_valid_jvmti_phase() {</span>
<span class="line-added">152   return JvmtiEnvBase::get_phase() == JVMTI_PHASE_LIVE;</span>
<span class="line-added">153 }</span>
<span class="line-added">154 </span>
155 void JfrJvmtiAgent::retransform_classes(JNIEnv* env, jobjectArray classes_array, TRAPS) {
156   assert(env != NULL, &quot;invariant&quot;);
<span class="line-added">157   assert(classes_array != NULL, &quot;invariant&quot;);</span>
<span class="line-added">158   assert(is_valid_jvmti_phase(), &quot;invariant&quot;);</span>
159   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(THREAD));



160   const jint classes_count = env-&gt;GetArrayLength(classes_array);
161   if (classes_count &lt;= 0) {
162     return;
163   }
164   ResourceMark rm(THREAD);
165   jclass* const classes = create_classes_array(classes_count, CHECK);
166   assert(classes != NULL, &quot;invariant&quot;);
167   for (jint i = 0; i &lt; classes_count; i++) {
168     jclass clz = (jclass)env-&gt;GetObjectArrayElement(classes_array, i);
169     check_exception_and_log(env, THREAD);
<span class="line-modified">170     classes[i] = clz;</span>
<span class="line-added">171   }</span>
<span class="line-added">172   {</span>
173     // inspecting the oop/klass requires a thread transition
<span class="line-modified">174     ThreadInVMfromNative transition((JavaThread*)THREAD);</span>
<span class="line-modified">175     for (jint i = 0; i &lt; classes_count; ++i) {</span>
<span class="line-modified">176       jclass clz = classes[i];</span>
<span class="line-modified">177       if (!JdkJfrEvent::is_a(clz)) {</span>


178         // outside the event hierarchy
179         JdkJfrEvent::tag_as_host(clz);
180       }
181     }


182   }
<span class="line-modified">183   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(THREAD));</span>
<span class="line-modified">184   const jvmtiError result = jfr_jvmti_env-&gt;RetransformClasses(classes_count, classes);</span>
<span class="line-added">185   if (result != JVMTI_ERROR_NONE) {</span>
<span class="line-added">186     log_and_throw(result, THREAD);</span>
187   }
188 }
189 
<span class="line-modified">190 static bool register_callbacks(JavaThread* jt) {</span>
191   assert(jfr_jvmti_env != NULL, &quot;invariant&quot;);
192   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt));
193   jvmtiEventCallbacks callbacks;
194   /* Set callbacks */
195   memset(&amp;callbacks, 0, sizeof(callbacks));
196   callbacks.ClassFileLoadHook = jfr_on_class_file_load_hook;
197   const jvmtiError jvmti_ret_code = jfr_jvmti_env-&gt;SetEventCallbacks(&amp;callbacks, sizeof(callbacks));
198   check_jvmti_error(jfr_jvmti_env, jvmti_ret_code, &quot;SetEventCallbacks&quot;);
<span class="line-modified">199   return jvmti_ret_code == JVMTI_ERROR_NONE;</span>
200 }
201 
<span class="line-modified">202 static bool register_capabilities(JavaThread* jt) {</span>
203   assert(jfr_jvmti_env != NULL, &quot;invariant&quot;);
204   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt));
205   jvmtiCapabilities capabilities;
206   /* Add JVMTI capabilities */
207   (void)memset(&amp;capabilities, 0, sizeof(capabilities));
208   capabilities.can_retransform_classes = 1;
209   capabilities.can_retransform_any_class = 1;
210   const jvmtiError jvmti_ret_code = jfr_jvmti_env-&gt;AddCapabilities(&amp;capabilities);
211   check_jvmti_error(jfr_jvmti_env, jvmti_ret_code, &quot;Add Capabilities&quot;);
<span class="line-modified">212   return jvmti_ret_code == JVMTI_ERROR_NONE;</span>
213 }
214 
215 static jint create_jvmti_env(JavaThread* jt) {
216   assert(jfr_jvmti_env == NULL, &quot;invariant&quot;);
217   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt));
218   extern struct JavaVM_ main_vm;
219   JavaVM* vm = &amp;main_vm;
220   return vm-&gt;GetEnv((void **)&amp;jfr_jvmti_env, JVMTI_VERSION);
221 }
222 
<span class="line-modified">223 static bool unregister_callbacks(JavaThread* jt) {</span>
<span class="line-modified">224   assert(jfr_jvmti_env != NULL, &quot;invariant&quot;);</span>


225   jvmtiEventCallbacks callbacks;
226   /* Set empty callbacks */
227   memset(&amp;callbacks, 0, sizeof(callbacks));
228   const jvmtiError jvmti_ret_code = jfr_jvmti_env-&gt;SetEventCallbacks(&amp;callbacks, sizeof(callbacks));
229   check_jvmti_error(jfr_jvmti_env, jvmti_ret_code, &quot;SetEventCallbacks&quot;);
<span class="line-modified">230   return jvmti_ret_code == JVMTI_ERROR_NONE;</span>
231 }
232 
233 JfrJvmtiAgent::JfrJvmtiAgent() {}
234 
235 JfrJvmtiAgent::~JfrJvmtiAgent() {
236   JavaThread* jt = current_java_thread();
237   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(jt));



238   if (jfr_jvmti_env != NULL) {
<span class="line-added">239     ThreadToNativeFromVM transition(jt);</span>
<span class="line-added">240     update_class_file_load_hook_event(JVMTI_DISABLE);</span>
<span class="line-added">241     unregister_callbacks(jt);</span>
242     jfr_jvmti_env-&gt;DisposeEnvironment();
243     jfr_jvmti_env = NULL;
244   }

245 }
246 
<span class="line-modified">247 static bool initialize(JavaThread* jt) {</span>

248   assert(jt != NULL, &quot;invariant&quot;);

249   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(jt));
250   ThreadToNativeFromVM transition(jt);
251   if (create_jvmti_env(jt) != JNI_OK) {
252     assert(jfr_jvmti_env == NULL, &quot;invariant&quot;);
253     return false;
254   }
255   assert(jfr_jvmti_env != NULL, &quot;invariant&quot;);
<span class="line-modified">256   if (!register_capabilities(jt)) {</span>
257     return false;
258   }
<span class="line-modified">259   if (!register_callbacks(jt)) {</span>
260     return false;
261   }
<span class="line-modified">262   return update_class_file_load_hook_event(JVMTI_ENABLE);</span>
<span class="line-modified">263 }</span>
<span class="line-modified">264 </span>
<span class="line-modified">265 static void log_and_throw_illegal_state_exception(TRAPS) {</span>
<span class="line-added">266   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));</span>
<span class="line-added">267   const char* const illegal_state_msg = &quot;An attempt was made to start JFR too early in the VM initialization sequence.&quot;;</span>
<span class="line-added">268   log_error(jfr, system)(illegal_state_msg);</span>
<span class="line-added">269   log_error(jfr, system)(&quot;JFR uses JVMTI RetransformClasses and requires the JVMTI state to have entered JVMTI_PHASE_LIVE.&quot;);</span>
<span class="line-added">270   log_error(jfr, system)(&quot;Please initialize JFR in response to event JVMTI_EVENT_VM_INIT instead of JVMTI_EVENT_VM_START.&quot;);</span>
<span class="line-added">271   JfrJavaSupport::throw_illegal_state_exception(illegal_state_msg, THREAD);</span>
272 }
273 
274 bool JfrJvmtiAgent::create() {
<span class="line-modified">275   assert(agent == NULL, &quot;invariant&quot;);</span>
<span class="line-added">276   JavaThread* const jt = current_java_thread();</span>
<span class="line-added">277   if (!is_valid_jvmti_phase()) {</span>
<span class="line-added">278     log_and_throw_illegal_state_exception(jt);</span>
<span class="line-added">279     return false;</span>
<span class="line-added">280   }</span>
281   agent = new JfrJvmtiAgent();
282   if (agent == NULL) {
283     return false;
284   }
<span class="line-modified">285   if (!initialize(jt)) {</span>
286     delete agent;
287     agent = NULL;
288     return false;
289   }
290   return true;
291 }
292 
293 void JfrJvmtiAgent::destroy() {
294   if (agent != NULL) {
295     delete agent;
296     agent = NULL;
297   }
298 }

</pre>
</td>
</tr>
</table>
<center><a href="jfrEventClassTransformer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../jfr.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
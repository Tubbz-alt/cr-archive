<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/jfr/instrumentation/jfrJvmtiAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="jfrEventClassTransformer.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../jfr.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/instrumentation/jfrJvmtiAgent.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 30,11 ***</span>
<span class="line-new-header">--- 30,13 ---</span>
  #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceId.inline.hpp&quot;
  #include &quot;jfr/recorder/service/jfrOptionSet.hpp&quot;
  #include &quot;jfr/support/jfrEventClass.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">+ #include &quot;prims/jvmtiEnvBase.hpp&quot;</span>
  #include &quot;prims/jvmtiExport.hpp&quot;
<span class="line-added">+ #include &quot;prims/jvmtiUtil.hpp&quot;</span>
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;utilities/exceptions.hpp&quot;
  
  static const size_t ERROR_MSG_BUFFER_SIZE = 256;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 50,23 ***</span>
                             NULL == errnum_str ? &quot;Unknown&quot; : errnum_str,
                             NULL == str ? &quot;&quot; : str);
    }
  }
  
<span class="line-modified">! static jvmtiError set_event_notification_mode(jvmtiEventMode mode,</span>
<span class="line-modified">!                                               jvmtiEvent event,</span>
<span class="line-modified">!                                               jthread event_thread,</span>
<span class="line-modified">!                                               ...) {</span>
<span class="line-modified">!   if (jfr_jvmti_env == NULL) {</span>
<span class="line-removed">-     return JVMTI_ERROR_NONE;</span>
<span class="line-removed">-   }</span>
    const jvmtiError jvmti_ret_code = jfr_jvmti_env-&gt;SetEventNotificationMode(mode, event, event_thread);
    check_jvmti_error(jfr_jvmti_env, jvmti_ret_code, &quot;SetEventNotificationMode&quot;);
<span class="line-modified">!   return jvmti_ret_code;</span>
  }
  
<span class="line-modified">! static jvmtiError update_class_file_load_hook_event(jvmtiEventMode mode) {</span>
    return set_event_notification_mode(mode, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, NULL);
  }
  
  static JavaThread* current_java_thread() {
    Thread* this_thread = Thread::current();
<span class="line-new-header">--- 52,21 ---</span>
                             NULL == errnum_str ? &quot;Unknown&quot; : errnum_str,
                             NULL == str ? &quot;&quot; : str);
    }
  }
  
<span class="line-modified">! static bool set_event_notification_mode(jvmtiEventMode mode,</span>
<span class="line-modified">!                                         jvmtiEvent event,</span>
<span class="line-modified">!                                         jthread event_thread,</span>
<span class="line-modified">!                                         ...) {</span>
<span class="line-modified">!   assert(jfr_jvmti_env != NULL, &quot;invariant&quot;);</span>
    const jvmtiError jvmti_ret_code = jfr_jvmti_env-&gt;SetEventNotificationMode(mode, event, event_thread);
    check_jvmti_error(jfr_jvmti_env, jvmti_ret_code, &quot;SetEventNotificationMode&quot;);
<span class="line-modified">!   return jvmti_ret_code == JVMTI_ERROR_NONE;</span>
  }
  
<span class="line-modified">! static bool update_class_file_load_hook_event(jvmtiEventMode mode) {</span>
    return set_event_notification_mode(mode, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, NULL);
  }
  
  static JavaThread* current_java_thread() {
    Thread* this_thread = Thread::current();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 115,16 ***</span>
      JfrJavaSupport::throw_out_of_memory_error(error_buffer, CHECK_NULL);
    }
    return classes;
  }
  
<span class="line-modified">! static void log_and_throw(TRAPS) {</span>
    if (!HAS_PENDING_EXCEPTION) {
      DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(THREAD));
      ThreadInVMfromNative tvmfn((JavaThread*)THREAD);
<span class="line-modified">!     log_error(jfr, system)(&quot;JfrJvmtiAgent::retransformClasses failed&quot;);</span>
<span class="line-modified">!     JfrJavaSupport::throw_class_format_error(&quot;JfrJvmtiAgent::retransformClasses failed&quot;, THREAD);</span>
    }
  }
  
  static void check_exception_and_log(JNIEnv* env, TRAPS) {
    assert(env != NULL, &quot;invariant&quot;);
<span class="line-new-header">--- 115,27 ---</span>
      JfrJavaSupport::throw_out_of_memory_error(error_buffer, CHECK_NULL);
    }
    return classes;
  }
  
<span class="line-modified">! // caller needs ResourceMark</span>
<span class="line-added">+ static void log_and_throw(jvmtiError error, TRAPS) {</span>
    if (!HAS_PENDING_EXCEPTION) {
      DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(THREAD));
      ThreadInVMfromNative tvmfn((JavaThread*)THREAD);
<span class="line-modified">!     const char base_error_msg[] = &quot;JfrJvmtiAgent::retransformClasses failed: &quot;;</span>
<span class="line-modified">!     size_t length = sizeof base_error_msg; // includes terminating null</span>
<span class="line-added">+     const char* const jvmti_error_name = JvmtiUtil::error_name(error);</span>
<span class="line-added">+     assert(jvmti_error_name != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+     length += strlen(jvmti_error_name);</span>
<span class="line-added">+     char* error_msg = NEW_RESOURCE_ARRAY(char, length);</span>
<span class="line-added">+     jio_snprintf(error_msg, length, &quot;%s%s&quot;, base_error_msg, jvmti_error_name);</span>
<span class="line-added">+     if (JVMTI_ERROR_INVALID_CLASS_FORMAT == error) {</span>
<span class="line-added">+       JfrJavaSupport::throw_class_format_error(error_msg, THREAD);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       JfrJavaSupport::throw_runtime_exception(error_msg, THREAD);</span>
<span class="line-added">+     }</span>
    }
  }
  
  static void check_exception_and_log(JNIEnv* env, TRAPS) {
    assert(env != NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 135,136 ***</span>
      log_error(jfr, system)(&quot;GetObjectArrayElement threw an exception&quot;);
      return;
    }
  }
  
  void JfrJvmtiAgent::retransform_classes(JNIEnv* env, jobjectArray classes_array, TRAPS) {
    assert(env != NULL, &quot;invariant&quot;);
    DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(THREAD));
<span class="line-removed">-   if (classes_array == NULL) {</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
    const jint classes_count = env-&gt;GetArrayLength(classes_array);
    if (classes_count &lt;= 0) {
      return;
    }
    ResourceMark rm(THREAD);
    jclass* const classes = create_classes_array(classes_count, CHECK);
    assert(classes != NULL, &quot;invariant&quot;);
    for (jint i = 0; i &lt; classes_count; i++) {
      jclass clz = (jclass)env-&gt;GetObjectArrayElement(classes_array, i);
      check_exception_and_log(env, THREAD);
<span class="line-modified">! </span>
      // inspecting the oop/klass requires a thread transition
<span class="line-modified">!     {</span>
<span class="line-modified">!       ThreadInVMfromNative transition((JavaThread*)THREAD);</span>
<span class="line-modified">!       if (JdkJfrEvent::is_a(clz)) {</span>
<span class="line-modified">!         // should have been tagged already</span>
<span class="line-removed">-         assert(JdkJfrEvent::is_subklass(clz), &quot;invariant&quot;);</span>
<span class="line-removed">-       } else {</span>
          // outside the event hierarchy
          JdkJfrEvent::tag_as_host(clz);
        }
      }
<span class="line-removed">- </span>
<span class="line-removed">-     classes[i] = clz;</span>
    }
<span class="line-modified">!   if (jfr_jvmti_env-&gt;RetransformClasses(classes_count, classes) != JVMTI_ERROR_NONE) {</span>
<span class="line-modified">!     log_and_throw(THREAD);</span>
    }
  }
  
<span class="line-modified">! static jvmtiError register_callbacks(JavaThread* jt) {</span>
    assert(jfr_jvmti_env != NULL, &quot;invariant&quot;);
    DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt));
    jvmtiEventCallbacks callbacks;
    /* Set callbacks */
    memset(&amp;callbacks, 0, sizeof(callbacks));
    callbacks.ClassFileLoadHook = jfr_on_class_file_load_hook;
    const jvmtiError jvmti_ret_code = jfr_jvmti_env-&gt;SetEventCallbacks(&amp;callbacks, sizeof(callbacks));
    check_jvmti_error(jfr_jvmti_env, jvmti_ret_code, &quot;SetEventCallbacks&quot;);
<span class="line-modified">!   return jvmti_ret_code;</span>
  }
  
<span class="line-modified">! static jvmtiError register_capabilities(JavaThread* jt) {</span>
    assert(jfr_jvmti_env != NULL, &quot;invariant&quot;);
    DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt));
    jvmtiCapabilities capabilities;
    /* Add JVMTI capabilities */
    (void)memset(&amp;capabilities, 0, sizeof(capabilities));
    capabilities.can_retransform_classes = 1;
    capabilities.can_retransform_any_class = 1;
    const jvmtiError jvmti_ret_code = jfr_jvmti_env-&gt;AddCapabilities(&amp;capabilities);
    check_jvmti_error(jfr_jvmti_env, jvmti_ret_code, &quot;Add Capabilities&quot;);
<span class="line-modified">!   return jvmti_ret_code;</span>
  }
  
  static jint create_jvmti_env(JavaThread* jt) {
    assert(jfr_jvmti_env == NULL, &quot;invariant&quot;);
    DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt));
    extern struct JavaVM_ main_vm;
    JavaVM* vm = &amp;main_vm;
    return vm-&gt;GetEnv((void **)&amp;jfr_jvmti_env, JVMTI_VERSION);
  }
  
<span class="line-modified">! static jvmtiError unregister_callbacks(JavaThread* jt) {</span>
<span class="line-modified">!   if (jfr_jvmti_env == NULL) {</span>
<span class="line-removed">-     return JVMTI_ERROR_NONE;</span>
<span class="line-removed">-   }</span>
    jvmtiEventCallbacks callbacks;
    /* Set empty callbacks */
    memset(&amp;callbacks, 0, sizeof(callbacks));
    const jvmtiError jvmti_ret_code = jfr_jvmti_env-&gt;SetEventCallbacks(&amp;callbacks, sizeof(callbacks));
    check_jvmti_error(jfr_jvmti_env, jvmti_ret_code, &quot;SetEventCallbacks&quot;);
<span class="line-modified">!   return jvmti_ret_code;</span>
  }
  
  JfrJvmtiAgent::JfrJvmtiAgent() {}
  
  JfrJvmtiAgent::~JfrJvmtiAgent() {
    JavaThread* jt = current_java_thread();
    DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(jt));
<span class="line-removed">-   ThreadToNativeFromVM transition(jt);</span>
<span class="line-removed">-   update_class_file_load_hook_event(JVMTI_DISABLE);</span>
<span class="line-removed">-   unregister_callbacks(jt);</span>
    if (jfr_jvmti_env != NULL) {
      jfr_jvmti_env-&gt;DisposeEnvironment();
      jfr_jvmti_env = NULL;
    }
<span class="line-removed">-   agent = NULL;</span>
  }
  
<span class="line-modified">! static bool initialize() {</span>
<span class="line-removed">-   JavaThread* const jt = current_java_thread();</span>
    assert(jt != NULL, &quot;invariant&quot;);
<span class="line-removed">-   assert(jt-&gt;thread_state() == _thread_in_vm, &quot;invariant&quot;);</span>
    DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(jt));
    ThreadToNativeFromVM transition(jt);
    if (create_jvmti_env(jt) != JNI_OK) {
      assert(jfr_jvmti_env == NULL, &quot;invariant&quot;);
      return false;
    }
    assert(jfr_jvmti_env != NULL, &quot;invariant&quot;);
<span class="line-modified">!   if (register_capabilities(jt) != JVMTI_ERROR_NONE) {</span>
      return false;
    }
<span class="line-modified">!   if (register_callbacks(jt) != JVMTI_ERROR_NONE) {</span>
      return false;
    }
<span class="line-modified">!   if (update_class_file_load_hook_event(JVMTI_ENABLE) != JVMTI_ERROR_NONE) {</span>
<span class="line-modified">!     return false;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   return true;</span>
  }
  
  bool JfrJvmtiAgent::create() {
<span class="line-modified">!   assert(jfr_jvmti_env == NULL, &quot;invariant&quot;);</span>
    agent = new JfrJvmtiAgent();
    if (agent == NULL) {
      return false;
    }
<span class="line-modified">!   if (!initialize()) {</span>
      delete agent;
      agent = NULL;
      return false;
    }
    return true;
<span class="line-new-header">--- 146,145 ---</span>
      log_error(jfr, system)(&quot;GetObjectArrayElement threw an exception&quot;);
      return;
    }
  }
  
<span class="line-added">+ static bool is_valid_jvmti_phase() {</span>
<span class="line-added">+   return JvmtiEnvBase::get_phase() == JVMTI_PHASE_LIVE;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void JfrJvmtiAgent::retransform_classes(JNIEnv* env, jobjectArray classes_array, TRAPS) {
    assert(env != NULL, &quot;invariant&quot;);
<span class="line-added">+   assert(classes_array != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(is_valid_jvmti_phase(), &quot;invariant&quot;);</span>
    DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(THREAD));
    const jint classes_count = env-&gt;GetArrayLength(classes_array);
    if (classes_count &lt;= 0) {
      return;
    }
    ResourceMark rm(THREAD);
    jclass* const classes = create_classes_array(classes_count, CHECK);
    assert(classes != NULL, &quot;invariant&quot;);
    for (jint i = 0; i &lt; classes_count; i++) {
      jclass clz = (jclass)env-&gt;GetObjectArrayElement(classes_array, i);
      check_exception_and_log(env, THREAD);
<span class="line-modified">!     classes[i] = clz;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   {</span>
      // inspecting the oop/klass requires a thread transition
<span class="line-modified">!     ThreadInVMfromNative transition((JavaThread*)THREAD);</span>
<span class="line-modified">!     for (jint i = 0; i &lt; classes_count; ++i) {</span>
<span class="line-modified">!       jclass clz = classes[i];</span>
<span class="line-modified">!       if (!JdkJfrEvent::is_a(clz)) {</span>
          // outside the event hierarchy
          JdkJfrEvent::tag_as_host(clz);
        }
      }
    }
<span class="line-modified">!   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(THREAD));</span>
<span class="line-modified">!   const jvmtiError result = jfr_jvmti_env-&gt;RetransformClasses(classes_count, classes);</span>
<span class="line-added">+   if (result != JVMTI_ERROR_NONE) {</span>
<span class="line-added">+     log_and_throw(result, THREAD);</span>
    }
  }
  
<span class="line-modified">! static bool register_callbacks(JavaThread* jt) {</span>
    assert(jfr_jvmti_env != NULL, &quot;invariant&quot;);
    DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt));
    jvmtiEventCallbacks callbacks;
    /* Set callbacks */
    memset(&amp;callbacks, 0, sizeof(callbacks));
    callbacks.ClassFileLoadHook = jfr_on_class_file_load_hook;
    const jvmtiError jvmti_ret_code = jfr_jvmti_env-&gt;SetEventCallbacks(&amp;callbacks, sizeof(callbacks));
    check_jvmti_error(jfr_jvmti_env, jvmti_ret_code, &quot;SetEventCallbacks&quot;);
<span class="line-modified">!   return jvmti_ret_code == JVMTI_ERROR_NONE;</span>
  }
  
<span class="line-modified">! static bool register_capabilities(JavaThread* jt) {</span>
    assert(jfr_jvmti_env != NULL, &quot;invariant&quot;);
    DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt));
    jvmtiCapabilities capabilities;
    /* Add JVMTI capabilities */
    (void)memset(&amp;capabilities, 0, sizeof(capabilities));
    capabilities.can_retransform_classes = 1;
    capabilities.can_retransform_any_class = 1;
    const jvmtiError jvmti_ret_code = jfr_jvmti_env-&gt;AddCapabilities(&amp;capabilities);
    check_jvmti_error(jfr_jvmti_env, jvmti_ret_code, &quot;Add Capabilities&quot;);
<span class="line-modified">!   return jvmti_ret_code == JVMTI_ERROR_NONE;</span>
  }
  
  static jint create_jvmti_env(JavaThread* jt) {
    assert(jfr_jvmti_env == NULL, &quot;invariant&quot;);
    DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt));
    extern struct JavaVM_ main_vm;
    JavaVM* vm = &amp;main_vm;
    return vm-&gt;GetEnv((void **)&amp;jfr_jvmti_env, JVMTI_VERSION);
  }
  
<span class="line-modified">! static bool unregister_callbacks(JavaThread* jt) {</span>
<span class="line-modified">!   assert(jfr_jvmti_env != NULL, &quot;invariant&quot;);</span>
    jvmtiEventCallbacks callbacks;
    /* Set empty callbacks */
    memset(&amp;callbacks, 0, sizeof(callbacks));
    const jvmtiError jvmti_ret_code = jfr_jvmti_env-&gt;SetEventCallbacks(&amp;callbacks, sizeof(callbacks));
    check_jvmti_error(jfr_jvmti_env, jvmti_ret_code, &quot;SetEventCallbacks&quot;);
<span class="line-modified">!   return jvmti_ret_code == JVMTI_ERROR_NONE;</span>
  }
  
  JfrJvmtiAgent::JfrJvmtiAgent() {}
  
  JfrJvmtiAgent::~JfrJvmtiAgent() {
    JavaThread* jt = current_java_thread();
    DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(jt));
    if (jfr_jvmti_env != NULL) {
<span class="line-added">+     ThreadToNativeFromVM transition(jt);</span>
<span class="line-added">+     update_class_file_load_hook_event(JVMTI_DISABLE);</span>
<span class="line-added">+     unregister_callbacks(jt);</span>
      jfr_jvmti_env-&gt;DisposeEnvironment();
      jfr_jvmti_env = NULL;
    }
  }
  
<span class="line-modified">! static bool initialize(JavaThread* jt) {</span>
    assert(jt != NULL, &quot;invariant&quot;);
    DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(jt));
    ThreadToNativeFromVM transition(jt);
    if (create_jvmti_env(jt) != JNI_OK) {
      assert(jfr_jvmti_env == NULL, &quot;invariant&quot;);
      return false;
    }
    assert(jfr_jvmti_env != NULL, &quot;invariant&quot;);
<span class="line-modified">!   if (!register_capabilities(jt)) {</span>
      return false;
    }
<span class="line-modified">!   if (!register_callbacks(jt)) {</span>
      return false;
    }
<span class="line-modified">!   return update_class_file_load_hook_event(JVMTI_ENABLE);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! static void log_and_throw_illegal_state_exception(TRAPS) {</span>
<span class="line-added">+   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));</span>
<span class="line-added">+   const char* const illegal_state_msg = &quot;An attempt was made to start JFR too early in the VM initialization sequence.&quot;;</span>
<span class="line-added">+   log_error(jfr, system)(illegal_state_msg);</span>
<span class="line-added">+   log_error(jfr, system)(&quot;JFR uses JVMTI RetransformClasses and requires the JVMTI state to have entered JVMTI_PHASE_LIVE.&quot;);</span>
<span class="line-added">+   log_error(jfr, system)(&quot;Please initialize JFR in response to event JVMTI_EVENT_VM_INIT instead of JVMTI_EVENT_VM_START.&quot;);</span>
<span class="line-added">+   JfrJavaSupport::throw_illegal_state_exception(illegal_state_msg, THREAD);</span>
  }
  
  bool JfrJvmtiAgent::create() {
<span class="line-modified">!   assert(agent == NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   JavaThread* const jt = current_java_thread();</span>
<span class="line-added">+   if (!is_valid_jvmti_phase()) {</span>
<span class="line-added">+     log_and_throw_illegal_state_exception(jt);</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
    agent = new JfrJvmtiAgent();
    if (agent == NULL) {
      return false;
    }
<span class="line-modified">!   if (!initialize(jt)) {</span>
      delete agent;
      agent = NULL;
      return false;
    }
    return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 274,6 ***</span>
    if (agent != NULL) {
      delete agent;
      agent = NULL;
    }
  }
<span class="line-removed">- </span>
<span class="line-new-header">--- 294,5 ---</span>
</pre>
<center><a href="jfrEventClassTransformer.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../jfr.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
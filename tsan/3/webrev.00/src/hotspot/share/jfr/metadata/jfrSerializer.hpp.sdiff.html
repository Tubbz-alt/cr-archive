<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/metadata/jfrSerializer.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../leakprofiler/utilities/saveRestore.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="metadata.xml.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/metadata/jfrSerializer.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 53  *    TYPE_THREADGROUP,
 54  *    TYPE_CLASSLOADER,
 55  *    TYPE_METHOD,
 56  *    TYPE_SYMBOL,
 57  *    TYPE_THREADSTATE,
 58  *    TYPE_INFLATECAUSE,
 59  *    ...
 60  *
 61  * id                 this is the id of the type your are defining (see the enum above).
 62  * require_safepoint  indicate if your type need to be evaluated and serialized under a safepoint.
 63  * permit_cache       indicate if your type constants are stable to be cached.
 64  *                    (implies the callback is invoked only once and the contents will be cached. Set this to true for static information).
 65  * serializer         the serializer instance.
 66  *
 67  * See below for guidance about how to implement serialize().
 68  *
 69  */
 70 class JfrSerializer : public CHeapObj&lt;mtTracing&gt; {
 71  public:
 72   virtual ~JfrSerializer() {}
<span class="line-modified"> 73   static bool register_serializer(JfrTypeId id, bool require_safepoint, bool permit_cache, JfrSerializer* serializer);</span>

 74   virtual void serialize(JfrCheckpointWriter&amp; writer) = 0;
 75 };
 76 
 77 /*
 78  * Defining serialize(JfrCheckpointWriter&amp; writer):
 79  *
 80  *  Invoke writer.write_count(N) for the number of ordered pairs (cardinality) to be defined.
 81  *
 82  *  You then write each individual ordered pair, &lt;key, value&gt; ...
 83  *
 84  *  Here is a simple example, describing a type defining string constants:
 85  *
 86  *  void MyType::serialize(JfrCheckpointWriter&amp; writer) {
 87  *    const int nof_causes = ObjectSynchronizer::inflate_cause_nof;
 88  *    writer.write_count(nof_causes);                           // write number of ordered pairs (mappings) to follow
 89  *    for (int i = 0; i &lt; nof_causes; i++) {
 90  *      writer.write_key(i);                                    // write key
 91  *      writer.write(ObjectSynchronizer::inflate_cause_name((ObjectSynchronizer::InflateCause)i)); // write value
 92  *    }
 93  *  }
</pre>
</td>
<td>
<hr />
<pre>
 53  *    TYPE_THREADGROUP,
 54  *    TYPE_CLASSLOADER,
 55  *    TYPE_METHOD,
 56  *    TYPE_SYMBOL,
 57  *    TYPE_THREADSTATE,
 58  *    TYPE_INFLATECAUSE,
 59  *    ...
 60  *
 61  * id                 this is the id of the type your are defining (see the enum above).
 62  * require_safepoint  indicate if your type need to be evaluated and serialized under a safepoint.
 63  * permit_cache       indicate if your type constants are stable to be cached.
 64  *                    (implies the callback is invoked only once and the contents will be cached. Set this to true for static information).
 65  * serializer         the serializer instance.
 66  *
 67  * See below for guidance about how to implement serialize().
 68  *
 69  */
 70 class JfrSerializer : public CHeapObj&lt;mtTracing&gt; {
 71  public:
 72   virtual ~JfrSerializer() {}
<span class="line-modified"> 73   virtual void on_rotation() {}</span>
<span class="line-added"> 74   static bool register_serializer(JfrTypeId id, bool permit_cache, JfrSerializer* serializer);</span>
 75   virtual void serialize(JfrCheckpointWriter&amp; writer) = 0;
 76 };
 77 
 78 /*
 79  * Defining serialize(JfrCheckpointWriter&amp; writer):
 80  *
 81  *  Invoke writer.write_count(N) for the number of ordered pairs (cardinality) to be defined.
 82  *
 83  *  You then write each individual ordered pair, &lt;key, value&gt; ...
 84  *
 85  *  Here is a simple example, describing a type defining string constants:
 86  *
 87  *  void MyType::serialize(JfrCheckpointWriter&amp; writer) {
 88  *    const int nof_causes = ObjectSynchronizer::inflate_cause_nof;
 89  *    writer.write_count(nof_causes);                           // write number of ordered pairs (mappings) to follow
 90  *    for (int i = 0; i &lt; nof_causes; i++) {
 91  *      writer.write_key(i);                                    // write key
 92  *      writer.write(ObjectSynchronizer::inflate_cause_name((ObjectSynchronizer::InflateCause)i)); // write value
 93  *    }
 94  *  }
</pre>
</td>
</tr>
</table>
<center><a href="../leakprofiler/utilities/saveRestore.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="metadata.xml.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jfr/leakprofiler/checkpoint/objectSampleWriter.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfrfiles/jfrTypes.hpp&quot;
 27 #include &quot;jfr/leakprofiler/chains/edge.hpp&quot;
 28 #include &quot;jfr/leakprofiler/chains/edgeStore.hpp&quot;
 29 #include &quot;jfr/leakprofiler/chains/edgeUtils.hpp&quot;
 30 #include &quot;jfr/leakprofiler/checkpoint/objectSampleDescription.hpp&quot;
 31 #include &quot;jfr/leakprofiler/checkpoint/objectSampleWriter.hpp&quot;
 32 #include &quot;jfr/leakprofiler/checkpoint/rootResolver.hpp&quot;
 33 #include &quot;jfr/leakprofiler/sampling/objectSampler.hpp&quot;
 34 #include &quot;jfr/leakprofiler/utilities/rootType.hpp&quot;
<a name="2" id="anc2"></a><span class="line-modified"> 35 #include &quot;jfr/leakprofiler/utilities/unifiedOop.hpp&quot;</span>
<span class="line-modified"> 36 #include &quot;jfr/recorder/checkpoint/types/jfrTypeSetUtils.hpp&quot;</span>
<span class="line-modified"> 37 #include &quot;jfr/recorder/checkpoint/types/jfrTypeSetWriter.hpp&quot;</span>
 38 #include &quot;oops/oop.inline.hpp&quot;
 39 #include &quot;oops/symbol.hpp&quot;
 40 #include &quot;utilities/growableArray.hpp&quot;
 41 
 42 template &lt;typename Data&gt;
 43 class ObjectSampleAuxInfo : public ResourceObj {
 44  public:
 45   Data _data;
 46   traceid _id;
 47   ObjectSampleAuxInfo() : _data(), _id(0) {}
 48 };
 49 
 50 class ObjectSampleArrayData {
 51  public:
 52   int _array_size;
 53   int _array_index;
 54   ObjectSampleArrayData() : _array_size(0), _array_index(0) {}
 55 };
 56 
 57 class ObjectSampleFieldInfo : public ResourceObj {
 58  public:
 59   const Symbol* _field_name_symbol;
 60   jshort _field_modifiers;
 61   ObjectSampleFieldInfo() : _field_name_symbol(NULL), _field_modifiers(0) {}
 62 };
 63 
 64 class ObjectSampleRootDescriptionData {
 65  public:
 66   const Edge* _root_edge;
 67   const char* _description;
 68   OldObjectRoot::System _system;
 69   OldObjectRoot::Type _type;
 70   ObjectSampleRootDescriptionData() : _root_edge(NULL),
 71                                       _description(NULL),
 72                                       _system(OldObjectRoot::_system_undetermined),
 73                                       _type(OldObjectRoot::_type_undetermined) {}
 74 };
 75 
 76 class OldObjectSampleData {
 77  public:
 78   oop _object;
 79   traceid _reference_id;
 80 };
 81 
 82 class ReferenceData {
 83  public:
 84   traceid _field_info_id;
 85   traceid _array_info_id;
 86   traceid _old_object_sample_id;
 87   size_t  _skip;
 88 };
 89 
 90 static int initial_storage_size = 16;
 91 
 92 template &lt;typename Data&gt;
 93 class SampleSet : public ResourceObj {
 94  private:
 95   GrowableArray&lt;Data&gt;* _storage;
 96  public:
 97   SampleSet() : _storage(NULL) {}
 98 
 99   traceid store(Data data) {
100     assert(data != NULL, &quot;invariant&quot;);
101     if (_storage == NULL) {
102       _storage = new GrowableArray&lt;Data&gt;(initial_storage_size);
103     }
104     assert(_storage != NULL, &quot;invariant&quot;);
105     assert(_storage-&gt;find(data) == -1, &quot;invariant&quot;);
106     _storage-&gt;append(data);
107     return data-&gt;_id;
108   }
109 
110   size_t size() const {
111     return _storage != NULL ? (size_t)_storage-&gt;length() : 0;
112   }
113 
114   template &lt;typename Functor&gt;
115   void iterate(Functor&amp; functor) {
116     if (_storage != NULL) {
117       for (int i = 0; i &lt; _storage-&gt;length(); ++i) {
118         functor(_storage-&gt;at(i));
119       }
120     }
121   }
122 
123   const GrowableArray&lt;Data&gt;&amp; storage() const {
124     return *_storage;
125   }
126 };
127 
128 typedef ObjectSampleAuxInfo&lt;ObjectSampleArrayData&gt; ObjectSampleArrayInfo;
129 typedef ObjectSampleAuxInfo&lt;ObjectSampleRootDescriptionData&gt; ObjectSampleRootDescriptionInfo;
130 typedef ObjectSampleAuxInfo&lt;OldObjectSampleData&gt; OldObjectSampleInfo;
131 typedef ObjectSampleAuxInfo&lt;ReferenceData&gt; ReferenceInfo;
132 
133 class FieldTable : public ResourceObj {
134   template &lt;typename,
135             typename,
136             template&lt;typename, typename&gt; class,
137             typename,
138             size_t&gt;
139   friend class HashTableHost;
<a name="3" id="anc3"></a><span class="line-modified">140   typedef HashTableHost&lt;const ObjectSampleFieldInfo*, traceid, Entry, FieldTable, 109&gt; FieldInfoTable;</span>
141  public:
142   typedef FieldInfoTable::HashEntry FieldInfoEntry;
143 
144  private:
145   static traceid _field_id_counter;
146   FieldInfoTable* _table;
<a name="4" id="anc4"></a>
147 
<a name="5" id="anc5"></a><span class="line-modified">148   void assign_id(FieldInfoEntry* entry) {</span>
149     assert(entry != NULL, &quot;invariant&quot;);
150     entry-&gt;set_id(++_field_id_counter);
151   }
152 
<a name="6" id="anc6"></a><span class="line-modified">153   bool equals(const ObjectSampleFieldInfo* query, uintptr_t hash, const FieldInfoEntry* entry) {</span>
154     assert(hash == entry-&gt;hash(), &quot;invariant&quot;);
<a name="7" id="anc7"></a><span class="line-modified">155     assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">156     const ObjectSampleFieldInfo* stored = entry-&gt;literal();</span>
<span class="line-modified">157     assert(stored != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">158     assert(stored-&gt;_field_name_symbol-&gt;identity_hash() == query-&gt;_field_name_symbol-&gt;identity_hash(), &quot;invariant&quot;);</span>
<span class="line-modified">159     return stored-&gt;_field_modifiers == query-&gt;_field_modifiers;</span>


160   }
161 
162  public:
<a name="8" id="anc8"></a><span class="line-modified">163   FieldTable() : _table(new FieldInfoTable(this)) {}</span>
164   ~FieldTable() {
165     assert(_table != NULL, &quot;invariant&quot;);
166     delete _table;
167   }
168 
169   traceid store(const ObjectSampleFieldInfo* field_info) {
170     assert(field_info != NULL, &quot;invariant&quot;);
<a name="9" id="anc9"></a><span class="line-modified">171     const FieldInfoEntry&amp; entry =_table-&gt;lookup_put(field_info,</span>
<span class="line-modified">172                                                     field_info-&gt;_field_name_symbol-&gt;identity_hash());</span>
173     return entry.id();
174   }
175 
176   size_t size() const {
177     return _table-&gt;cardinality();
178   }
179 
180   template &lt;typename T&gt;
181   void iterate(T&amp; functor) const {
182     _table-&gt;iterate_entry&lt;T&gt;(functor);
183   }
184 };
185 
186 traceid FieldTable::_field_id_counter = 0;
187 
188 typedef SampleSet&lt;const OldObjectSampleInfo*&gt; SampleInfo;
189 typedef SampleSet&lt;const ReferenceInfo*&gt; RefInfo;
190 typedef SampleSet&lt;const ObjectSampleArrayInfo*&gt; ArrayInfo;
191 typedef SampleSet&lt;const ObjectSampleRootDescriptionInfo*&gt; RootDescriptionInfo;
192 
193 static SampleInfo* sample_infos = NULL;
194 static RefInfo* ref_infos = NULL;
195 static ArrayInfo* array_infos = NULL;
196 static FieldTable* field_infos = NULL;
197 static RootDescriptionInfo* root_infos = NULL;
198 
<a name="10" id="anc10"></a><span class="line-modified">199 int __write_sample_info__(JfrCheckpointWriter* writer, JfrArtifactSet* unused, const void* si) {</span>
200   assert(writer != NULL, &quot;invariant&quot;);
201   assert(si != NULL, &quot;invariant&quot;);
202   const OldObjectSampleInfo* const oosi = (const OldObjectSampleInfo*)si;
203   oop object = oosi-&gt;_data._object;
204   assert(object != NULL, &quot;invariant&quot;);
205   writer-&gt;write(oosi-&gt;_id);
<a name="11" id="anc11"></a><span class="line-modified">206   writer-&gt;write((u8)(const HeapWord*)object);</span>
207   writer-&gt;write(const_cast&lt;const Klass*&gt;(object-&gt;klass()));
208   ObjectSampleDescription od(object);
209   writer-&gt;write(od.description());
210   writer-&gt;write(oosi-&gt;_data._reference_id);
211   return 1;
212 }
213 
<a name="12" id="anc12"></a><span class="line-modified">214 typedef JfrArtifactWriterImplHost&lt;const OldObjectSampleInfo*, __write_sample_info__&gt; SampleWriterImpl;</span>
<span class="line-modified">215 typedef JfrArtifactWriterHost&lt;SampleWriterImpl, TYPE_OLDOBJECT&gt; SampleWriter;</span>
216 
217 static void write_sample_infos(JfrCheckpointWriter&amp; writer) {
218   if (sample_infos != NULL) {
<a name="13" id="anc13"></a><span class="line-modified">219     SampleWriter sw(&amp;writer, NULL, false);</span>
220     sample_infos-&gt;iterate(sw);
221   }
222 }
223 
<a name="14" id="anc14"></a><span class="line-modified">224 int __write_reference_info__(JfrCheckpointWriter* writer, JfrArtifactSet* unused, const void* ri) {</span>
225   assert(writer != NULL, &quot;invariant&quot;);
226   assert(ri != NULL, &quot;invariant&quot;);
227   const ReferenceInfo* const ref_info = (const ReferenceInfo*)ri;
228   writer-&gt;write(ref_info-&gt;_id);
229   writer-&gt;write(ref_info-&gt;_data._array_info_id);
230   writer-&gt;write(ref_info-&gt;_data._field_info_id);
231   writer-&gt;write(ref_info-&gt;_data._old_object_sample_id);
232   writer-&gt;write&lt;s4&gt;((s4)ref_info-&gt;_data._skip);
233   return 1;
234 }
235 
<a name="15" id="anc15"></a><span class="line-modified">236 typedef JfrArtifactWriterImplHost&lt;const ReferenceInfo*, __write_reference_info__&gt; ReferenceWriterImpl;</span>
<span class="line-modified">237 typedef JfrArtifactWriterHost&lt;ReferenceWriterImpl, TYPE_REFERENCE&gt; ReferenceWriter;</span>
238 
239 static void write_reference_infos(JfrCheckpointWriter&amp; writer) {
240   if (ref_infos != NULL) {
<a name="16" id="anc16"></a><span class="line-modified">241     ReferenceWriter rw(&amp;writer, NULL, false);</span>
242     ref_infos-&gt;iterate(rw);
243   }
244 }
245 
<a name="17" id="anc17"></a><span class="line-modified">246 int __write_array_info__(JfrCheckpointWriter* writer, JfrArtifactSet* unused, const void* ai) {</span>
247   assert(writer != NULL, &quot;invariant&quot;);
248   assert(ai != NULL, &quot;invariant&quot;);
249   const ObjectSampleArrayInfo* const osai = (const ObjectSampleArrayInfo*)ai;
250   writer-&gt;write(osai-&gt;_id);
251   writer-&gt;write(osai-&gt;_data._array_size);
252   writer-&gt;write(osai-&gt;_data._array_index);
253   return 1;
254 }
255 
256 static traceid get_array_info_id(const Edge&amp; edge, traceid id) {
257   if (edge.is_root() || !EdgeUtils::is_array_element(edge)) {
258     return 0;
259   }
260   if (array_infos == NULL) {
261     array_infos = new ArrayInfo();
262   }
263   assert(array_infos != NULL, &quot;invariant&quot;);
264 
265   ObjectSampleArrayInfo* const osai = new ObjectSampleArrayInfo();
266   assert(osai != NULL, &quot;invariant&quot;);
267   osai-&gt;_id = id;
268   osai-&gt;_data._array_size = EdgeUtils::array_size(edge);
269   osai-&gt;_data._array_index = EdgeUtils::array_index(edge);
270   return array_infos-&gt;store(osai);
271 }
272 
<a name="18" id="anc18"></a><span class="line-modified">273 typedef JfrArtifactWriterImplHost&lt;const ObjectSampleArrayInfo*, __write_array_info__&gt; ArrayWriterImpl;</span>
<span class="line-modified">274 typedef JfrArtifactWriterHost&lt;ArrayWriterImpl, TYPE_OLDOBJECTARRAY&gt; ArrayWriter;</span>
275 
276 static void write_array_infos(JfrCheckpointWriter&amp; writer) {
277   if (array_infos != NULL) {
<a name="19" id="anc19"></a><span class="line-modified">278     ArrayWriter aw(&amp;writer, NULL, false);</span>
279     array_infos-&gt;iterate(aw);
280   }
281 }
282 
<a name="20" id="anc20"></a><span class="line-modified">283 int __write_field_info__(JfrCheckpointWriter* writer, JfrArtifactSet* unused, const void* fi) {</span>
284   assert(writer != NULL, &quot;invariant&quot;);
285   assert(fi != NULL, &quot;invariant&quot;);
286   const FieldTable::FieldInfoEntry* field_info_entry = (const FieldTable::FieldInfoEntry*)fi;
287   writer-&gt;write(field_info_entry-&gt;id());
288   const ObjectSampleFieldInfo* const osfi = field_info_entry-&gt;literal();
289   writer-&gt;write(osfi-&gt;_field_name_symbol-&gt;as_C_string());
290   writer-&gt;write(osfi-&gt;_field_modifiers);
291   return 1;
292 }
293 
294 static traceid get_field_info_id(const Edge&amp; edge) {
295   if (edge.is_root()) {
296     return 0;
297   }
298 
299   assert(!EdgeUtils::is_array_element(edge), &quot;invariant&quot;);
300   const Symbol* const field_name_symbol = EdgeUtils::field_name_symbol(edge);
301   if (field_name_symbol == NULL) {
302     return 0;
303   }
304 
305   if (field_infos == NULL) {
306     field_infos = new FieldTable();
307   }
308   assert(field_infos != NULL, &quot;invariant&quot;);
309 
310   ObjectSampleFieldInfo* const osfi = new ObjectSampleFieldInfo();
311   assert(osfi != NULL, &quot;invariant&quot;);
312   osfi-&gt;_field_name_symbol = field_name_symbol;
313   osfi-&gt;_field_modifiers = EdgeUtils::field_modifiers(edge);
314   return field_infos-&gt;store(osfi);
315 }
316 
<a name="21" id="anc21"></a><span class="line-modified">317 typedef JfrArtifactWriterImplHost&lt;const FieldTable::FieldInfoEntry*, __write_field_info__&gt; FieldWriterImpl;</span>
<span class="line-modified">318 typedef JfrArtifactWriterHost&lt;FieldWriterImpl, TYPE_OLDOBJECTFIELD&gt; FieldWriter;</span>
319 
320 static void write_field_infos(JfrCheckpointWriter&amp; writer) {
321   if (field_infos != NULL) {
<a name="22" id="anc22"></a><span class="line-modified">322     FieldWriter fw(&amp;writer, NULL, false);</span>
323     field_infos-&gt;iterate(fw);
324   }
325 }
326 
327 static const char* description(const ObjectSampleRootDescriptionInfo* osdi) {
328   assert(osdi != NULL, &quot;invariant&quot;);
329 
330   if (osdi-&gt;_data._description == NULL) {
331     return NULL;
332   }
333 
334   ObjectDescriptionBuilder description;
335   if (osdi-&gt;_data._system == OldObjectRoot::_threads) {
336     description.write_text(&quot;Thread Name: &quot;);
337   }
338   description.write_text(osdi-&gt;_data._description);
339   return description.description();
340 }
341 
<a name="23" id="anc23"></a><span class="line-modified">342 int __write_root_description_info__(JfrCheckpointWriter* writer, JfrArtifactSet* unused, const void* di) {</span>
343   assert(writer != NULL, &quot;invariant&quot;);
344   assert(di != NULL, &quot;invariant&quot;);
345   const ObjectSampleRootDescriptionInfo* const osdi = (const ObjectSampleRootDescriptionInfo*)di;
346   writer-&gt;write(osdi-&gt;_id);
347   writer-&gt;write(description(osdi));
348   writer-&gt;write&lt;u8&gt;(osdi-&gt;_data._system);
349   writer-&gt;write&lt;u8&gt;(osdi-&gt;_data._type);
350   return 1;
351 }
352 
<a name="24" id="anc24"></a><span class="line-modified">353 static traceid get_root_description_info_id(const Edge&amp; edge, traceid id) {</span>
354   assert(edge.is_root(), &quot;invariant&quot;);
<a name="25" id="anc25"></a><span class="line-removed">355   if (EdgeUtils::is_leak_edge(edge)) {</span>
<span class="line-removed">356     return 0;</span>
<span class="line-removed">357   }</span>
<span class="line-removed">358 </span>
359   if (root_infos == NULL) {
360     root_infos = new RootDescriptionInfo();
361   }
362   assert(root_infos != NULL, &quot;invariant&quot;);
363   ObjectSampleRootDescriptionInfo* const oodi = new ObjectSampleRootDescriptionInfo();
364   oodi-&gt;_id = id;
365   oodi-&gt;_data._root_edge = &amp;edge;
366   return root_infos-&gt;store(oodi);
367 }
368 
<a name="26" id="anc26"></a><span class="line-modified">369 typedef JfrArtifactWriterImplHost&lt;const ObjectSampleRootDescriptionInfo*, __write_root_description_info__&gt; RootDescriptionWriterImpl;</span>
<span class="line-modified">370 typedef JfrArtifactWriterHost&lt;RootDescriptionWriterImpl, TYPE_OLDOBJECTGCROOT&gt; RootDescriptionWriter;</span>
371 
372 
373 int _edge_reference_compare_(uintptr_t lhs, uintptr_t rhs) {
374   return lhs &gt; rhs ? 1 : (lhs &lt; rhs) ? -1 : 0;
375 }
376 
377 int _root_desc_compare_(const ObjectSampleRootDescriptionInfo*const &amp; lhs, const ObjectSampleRootDescriptionInfo* const&amp; rhs) {
<a name="27" id="anc27"></a><span class="line-modified">378   const uintptr_t lhs_ref = (uintptr_t)lhs-&gt;_data._root_edge-&gt;reference();</span>
<span class="line-modified">379   const uintptr_t rhs_ref = (uintptr_t)rhs-&gt;_data._root_edge-&gt;reference();</span>
380   return _edge_reference_compare_(lhs_ref, rhs_ref);
381 }
382 
383 static int find_sorted(const RootCallbackInfo&amp; callback_info,
384                        const GrowableArray&lt;const ObjectSampleRootDescriptionInfo*&gt;* arr,
385                        int length,
386                        bool&amp; found) {
387   assert(arr != NULL, &quot;invariant&quot;);
388   assert(length &gt;= 0, &quot;invariant&quot;);
389   assert(length &lt;= arr-&gt;length(), &quot;invariant&quot;);
390 
391   found = false;
392   int min = 0;
393   int max = length;
394   while (max &gt;= min) {
395     const int mid = (int)(((uint)max + min) / 2);
396     int diff = _edge_reference_compare_((uintptr_t)callback_info._high,
<a name="28" id="anc28"></a><span class="line-modified">397                                         (uintptr_t)arr-&gt;at(mid)-&gt;_data._root_edge-&gt;reference());</span>
398     if (diff &gt; 0) {
399       min = mid + 1;
400     } else if (diff &lt; 0) {
401       max = mid - 1;
402     } else {
403       found = true;
404       return mid;
405     }
406   }
407   return min;
408 }
409 
410 class RootResolutionSet : public ResourceObj, public RootCallback {
411  private:
412   GrowableArray&lt;const ObjectSampleRootDescriptionInfo*&gt;* _unresolved_roots;
413 
414   const uintptr_t high() const {
<a name="29" id="anc29"></a><span class="line-modified">415     return (uintptr_t)_unresolved_roots-&gt;last()-&gt;_data._root_edge-&gt;reference();</span>
416   }
417 
418   const uintptr_t low() const {
<a name="30" id="anc30"></a><span class="line-modified">419     return (uintptr_t)_unresolved_roots-&gt;first()-&gt;_data._root_edge-&gt;reference();</span>
420   }
421 
422   bool in_set_address_range(const RootCallbackInfo&amp; callback_info) const {
423     assert(callback_info._low == NULL, &quot;invariant&quot;);
424     const uintptr_t addr = (uintptr_t)callback_info._high;
425     return low() &lt;= addr &amp;&amp; high() &gt;= addr;
426   }
427 
428   int compare_to_range(const RootCallbackInfo&amp; callback_info) const {
429     assert(callback_info._high != NULL, &quot;invariant&quot;);
430     assert(callback_info._low != NULL, &quot;invariant&quot;);
431 
432     for (int i = 0; i &lt; _unresolved_roots-&gt;length(); ++i) {
<a name="31" id="anc31"></a><span class="line-modified">433       const uintptr_t ref_addr = (uintptr_t)_unresolved_roots-&gt;at(i)-&gt;_data._root_edge-&gt;reference();</span>
434       if ((uintptr_t)callback_info._low &lt;= ref_addr &amp;&amp; (uintptr_t)callback_info._high &gt;= ref_addr) {
435         return i;
436       }
437     }
438     return -1;
439   }
440 
441   int exact(const RootCallbackInfo&amp; callback_info) const {
442     assert(callback_info._high != NULL, &quot;invariant&quot;);
443     assert(in_set_address_range(callback_info), &quot;invariant&quot;);
444 
445     bool found;
446     const int idx = find_sorted(callback_info, _unresolved_roots, _unresolved_roots-&gt;length(), found);
447     return found ? idx : -1;
448   }
449 
450   bool resolve_root(const RootCallbackInfo&amp; callback_info, int idx) const {
451     assert(idx &gt;= 0, &quot;invariant&quot;);
452     assert(idx &lt; _unresolved_roots-&gt;length(), &quot;invariant&quot;);
453 
454     ObjectSampleRootDescriptionInfo* const desc =
455       const_cast&lt;ObjectSampleRootDescriptionInfo*&gt;(_unresolved_roots-&gt;at(idx));
456     assert(desc != NULL, &quot;invariant&quot;);
<a name="32" id="anc32"></a><span class="line-modified">457     assert((uintptr_t)callback_info._high == (uintptr_t)desc-&gt;_data._root_edge-&gt;reference(), &quot;invariant&quot;);</span>
458 
459     desc-&gt;_data._system = callback_info._system;
460     desc-&gt;_data._type = callback_info._type;
461 
462     if (callback_info._system == OldObjectRoot::_threads) {
463       const JavaThread* jt = (const JavaThread*)callback_info._context;
464       assert(jt != NULL, &quot;invariant&quot;);
465       desc-&gt;_data._description = jt-&gt;name();
466     }
467 
468     _unresolved_roots-&gt;remove_at(idx);
469     return _unresolved_roots-&gt;is_empty();
470   }
471 
472  public:
473   RootResolutionSet(RootDescriptionInfo* info) : _unresolved_roots(NULL) {
474     assert(info != NULL, &quot;invariant&quot;);
475     // construct a sorted copy
476     const GrowableArray&lt;const ObjectSampleRootDescriptionInfo*&gt;&amp; info_storage = info-&gt;storage();
477     const int length = info_storage.length();
478     _unresolved_roots = new GrowableArray&lt;const ObjectSampleRootDescriptionInfo*&gt;(length);
479     assert(_unresolved_roots != NULL, &quot;invariant&quot;);
480 
481     for (int i = 0; i &lt; length; ++i) {
482       _unresolved_roots-&gt;insert_sorted&lt;_root_desc_compare_&gt;(info_storage.at(i));
483     }
484   }
485 
486   bool process(const RootCallbackInfo&amp; callback_info) {
487     if (NULL == callback_info._low) {
488       if (in_set_address_range(callback_info)) {
489         const int idx = exact(callback_info);
490         return idx == -1 ? false : resolve_root(callback_info, idx);
491       }
492       return false;
493     }
494     assert(callback_info._low != NULL, &quot;invariant&quot;);
495     const int idx = compare_to_range(callback_info);
496     return idx == -1 ? false : resolve_root(callback_info, idx);
497   }
498 
499   int entries() const {
500     return _unresolved_roots-&gt;length();
501   }
502 
<a name="33" id="anc33"></a><span class="line-modified">503   const void* at(int idx) const {</span>
504     assert(idx &gt;= 0, &quot;invariant&quot;);
505     assert(idx &lt; _unresolved_roots-&gt;length(), &quot;invariant&quot;);
506     return _unresolved_roots-&gt;at(idx)-&gt;_data._root_edge-&gt;reference();
507   }
508 };
509 
510 static void write_root_descriptors(JfrCheckpointWriter&amp; writer) {
511   if (root_infos != NULL) {
512     // resolve roots
513     RootResolutionSet rrs(root_infos);
514     RootResolver::resolve(rrs);
515     // write roots
<a name="34" id="anc34"></a><span class="line-modified">516     RootDescriptionWriter rw(&amp;writer, NULL, false);</span>
517     root_infos-&gt;iterate(rw);
518   }
519 }
520 
<a name="35" id="anc35"></a><span class="line-modified">521 static void add_old_object_sample_info(const Edge* current, traceid id) {</span>
522   assert(current != NULL, &quot;invariant&quot;);
523   if (sample_infos == NULL) {
524     sample_infos = new SampleInfo();
525   }
526   assert(sample_infos != NULL, &quot;invariant&quot;);
527   OldObjectSampleInfo* const oosi = new OldObjectSampleInfo();
528   assert(oosi != NULL, &quot;invariant&quot;);
529   oosi-&gt;_id = id;
530   oosi-&gt;_data._object = current-&gt;pointee();
<a name="36" id="anc36"></a><span class="line-modified">531   oosi-&gt;_data._reference_id = current-&gt;is_root() ? (traceid)0 : id;</span>
532   sample_infos-&gt;store(oosi);
533 }
534 
<a name="37" id="anc37"></a><span class="line-modified">535 static void add_reference_info(const RoutableEdge* current, traceid id, traceid parent_id) {</span>
536   assert(current != NULL, &quot;invariant&quot;);
537   if (ref_infos == NULL) {
538     ref_infos = new RefInfo();
539   }
540 
541   assert(ref_infos != NULL, &quot;invariant&quot;);
542   ReferenceInfo* const ri = new ReferenceInfo();
543   assert(ri != NULL, &quot;invariant&quot;);
544 
545   ri-&gt;_id = id;
546   ri-&gt;_data._array_info_id =  !current-&gt;is_skip_edge() ? get_array_info_id(*current, id) : 0;
<a name="38" id="anc38"></a><span class="line-modified">547   ri-&gt;_data._field_info_id = ri-&gt;_data._array_info_id == 0 &amp;&amp; !current-&gt;is_skip_edge() ?</span>
<span class="line-removed">548                                get_field_info_id(*current) : (traceid)0;</span>
549   ri-&gt;_data._old_object_sample_id = parent_id;
550   ri-&gt;_data._skip = current-&gt;skip_length();
551   ref_infos-&gt;store(ri);
552 }
553 
<a name="39" id="anc39"></a><span class="line-modified">554 static traceid add_root_info(const Edge* root, traceid id) {</span>





555   assert(root != NULL, &quot;invariant&quot;);
<a name="40" id="anc40"></a><span class="line-modified">556   assert(root-&gt;is_root(), &quot;invariant&quot;);</span>
<span class="line-modified">557   return get_root_description_info_id(*root, id);</span>
558 }
559 
<a name="41" id="anc41"></a><span class="line-modified">560 void ObjectSampleWriter::write(const RoutableEdge* edge) {</span>
561   assert(edge != NULL, &quot;invariant&quot;);
562   const traceid id = _store-&gt;get_id(edge);
563   add_old_object_sample_info(edge, id);
<a name="42" id="anc42"></a><span class="line-modified">564   const RoutableEdge* parent = edge-&gt;logical_parent();</span>
565   if (parent != NULL) {
566     add_reference_info(edge, id, _store-&gt;get_id(parent));
567   } else {
<a name="43" id="anc43"></a><span class="line-modified">568     assert(edge-&gt;is_root(), &quot;invariant&quot;);</span>
<span class="line-modified">569     add_root_info(edge, id);</span>


570   }
571 }
572 
<a name="44" id="anc44"></a><span class="line-modified">573 ObjectSampleWriter::ObjectSampleWriter(JfrCheckpointWriter&amp; writer, const EdgeStore* store) :</span>

































574   _writer(writer),
575   _store(store) {
576   assert(store != NULL, &quot;invariant&quot;);
<a name="45" id="anc45"></a><span class="line-modified">577   assert(store-&gt;number_of_entries() &gt; 0, &quot;invariant&quot;);</span>

578   sample_infos = NULL;
579   ref_infos = NULL;
580   array_infos = NULL;
581   field_infos = NULL;
582   root_infos = NULL;
583 }
584 
585 ObjectSampleWriter::~ObjectSampleWriter() {
586   write_sample_infos(_writer);
587   write_reference_infos(_writer);
588   write_array_infos(_writer);
589   write_field_infos(_writer);
590   write_root_descriptors(_writer);
591 }
592 
<a name="46" id="anc46"></a><span class="line-modified">593 void ObjectSampleWriter::write_chain(const RoutableEdge&amp; edge) {</span>
<span class="line-modified">594   assert(EdgeUtils::is_leak_edge(edge), &quot;invariant&quot;);</span>
<span class="line-removed">595   if (edge.processed()) {</span>
<span class="line-removed">596     return;</span>
<span class="line-removed">597   }</span>
<span class="line-removed">598   EdgeUtils::collapse_chain(edge);</span>
<span class="line-removed">599   const RoutableEdge* current = &amp;edge;</span>
<span class="line-removed">600   while (current != NULL) {</span>
<span class="line-removed">601     if (current-&gt;processed()) {</span>
<span class="line-removed">602       return;</span>
<span class="line-removed">603     }</span>
<span class="line-removed">604     write(current);</span>
<span class="line-removed">605     current-&gt;set_processed();</span>
<span class="line-removed">606     current = current-&gt;logical_parent();</span>
<span class="line-removed">607   }</span>
<span class="line-removed">608 }</span>
<span class="line-removed">609 </span>
<span class="line-removed">610 bool ObjectSampleWriter::operator()(const RoutableEdge&amp; edge) {</span>
<span class="line-removed">611   if (EdgeUtils::is_leak_edge(edge)) {</span>
<span class="line-removed">612     write_chain(edge);</span>
<span class="line-removed">613   }</span>
614   return true;
615 }
<a name="47" id="anc47"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="47" type="hidden" />
</body>
</html>
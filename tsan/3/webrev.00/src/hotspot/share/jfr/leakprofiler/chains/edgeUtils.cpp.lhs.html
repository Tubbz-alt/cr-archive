<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jfr/leakprofiler/chains/edgeUtils.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/javaClasses.hpp&quot;
 27 #include &quot;jfr/leakprofiler/chains/edge.hpp&quot;
 28 #include &quot;jfr/leakprofiler/chains/edgeStore.hpp&quot;
 29 #include &quot;jfr/leakprofiler/chains/edgeUtils.hpp&quot;
<a name="2" id="anc2"></a><span class="line-modified"> 30 #include &quot;jfr/leakprofiler/utilities/unifiedOop.hpp&quot;</span>
<span class="line-modified"> 31 #include &quot;oops/fieldStreams.hpp&quot;</span>
 32 #include &quot;oops/instanceKlass.hpp&quot;
 33 #include &quot;oops/objArrayOop.inline.hpp&quot;
 34 #include &quot;oops/oopsHierarchy.hpp&quot;
 35 #include &quot;runtime/handles.inline.hpp&quot;
 36 
 37 bool EdgeUtils::is_leak_edge(const Edge&amp; edge) {
<a name="3" id="anc3"></a><span class="line-modified"> 38   return (const Edge*)edge.pointee()-&gt;mark() == &amp;edge;</span>
 39 }
 40 
<a name="4" id="anc4"></a><span class="line-modified"> 41 bool EdgeUtils::is_root(const Edge&amp; edge) {</span>
<span class="line-removed"> 42   return edge.is_root();</span>
<span class="line-removed"> 43 }</span>
<span class="line-removed"> 44 </span>
<span class="line-removed"> 45 static int field_offset(const Edge&amp; edge) {</span>
 46   assert(!edge.is_root(), &quot;invariant&quot;);
 47   const oop ref_owner = edge.reference_owner();
 48   assert(ref_owner != NULL, &quot;invariant&quot;);
<a name="5" id="anc5"></a><span class="line-modified"> 49   const oop* reference = UnifiedOop::decode(edge.reference());</span>
<span class="line-modified"> 50   assert(reference != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 51   assert(!UnifiedOop::is_narrow(reference), &quot;invariant&quot;);</span>
 52   assert(!ref_owner-&gt;is_array(), &quot;invariant&quot;);
 53   assert(ref_owner-&gt;is_instance(), &quot;invariant&quot;);
<a name="6" id="anc6"></a><span class="line-modified"> 54   const int offset = (int)pointer_delta(reference, ref_owner, sizeof(char));</span>
 55   assert(offset &lt; (ref_owner-&gt;size() * HeapWordSize), &quot;invariant&quot;);
 56   return offset;
 57 }
 58 
<a name="7" id="anc7"></a><span class="line-modified"> 59 static const InstanceKlass* field_type(const Edge&amp; edge) {</span>
 60   assert(!edge.is_root() || !EdgeUtils::is_array_element(edge), &quot;invariant&quot;);
 61   return (const InstanceKlass*)edge.reference_owner_klass();
 62 }
 63 
 64 const Symbol* EdgeUtils::field_name_symbol(const Edge&amp; edge) {
 65   assert(!edge.is_root(), &quot;invariant&quot;);
 66   assert(!is_array_element(edge), &quot;invariant&quot;);
 67   const int offset = field_offset(edge);
 68   const InstanceKlass* ik = field_type(edge);
 69   while (ik != NULL) {
 70     JavaFieldStream jfs(ik);
 71     while (!jfs.done()) {
 72       if (offset == jfs.offset()) {
 73         return jfs.name();
 74       }
 75       jfs.next();
 76     }
 77     ik = (InstanceKlass*)ik-&gt;super();
 78   }
 79   return NULL;
 80 }
 81 
 82 jshort EdgeUtils::field_modifiers(const Edge&amp; edge) {
 83   const int offset = field_offset(edge);
 84   const InstanceKlass* ik = field_type(edge);
 85 
 86   while (ik != NULL) {
 87     JavaFieldStream jfs(ik);
 88     while (!jfs.done()) {
 89       if (offset == jfs.offset()) {
 90         return jfs.access_flags().as_short();
 91       }
 92       jfs.next();
 93     }
 94     ik = (InstanceKlass*)ik-&gt;super();
 95   }
 96   return 0;
 97 }
 98 
 99 bool EdgeUtils::is_array_element(const Edge&amp; edge) {
100   assert(!edge.is_root(), &quot;invariant&quot;);
101   const oop ref_owner = edge.reference_owner();
102   assert(ref_owner != NULL, &quot;invariant&quot;);
103   return ref_owner-&gt;is_objArray();
104 }
105 
106 static int array_offset(const Edge&amp; edge) {
107   assert(!edge.is_root(), &quot;invariant&quot;);
108   const oop ref_owner = edge.reference_owner();
109   assert(ref_owner != NULL, &quot;invariant&quot;);
<a name="8" id="anc8"></a><span class="line-modified">110   const oop* reference = UnifiedOop::decode(edge.reference());</span>
<span class="line-modified">111   assert(reference != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">112   assert(!UnifiedOop::is_narrow(reference), &quot;invariant&quot;);</span>
113   assert(ref_owner-&gt;is_array(), &quot;invariant&quot;);
114   const objArrayOop ref_owner_array = static_cast&lt;const objArrayOop&gt;(ref_owner);
<a name="9" id="anc9"></a><span class="line-modified">115   const int offset = (int)pointer_delta(reference, ref_owner_array-&gt;base(), heapOopSize);</span>
116   assert(offset &gt;= 0 &amp;&amp; offset &lt; ref_owner_array-&gt;length(), &quot;invariant&quot;);
117   return offset;
118 }
119 
120 int EdgeUtils::array_index(const Edge&amp; edge) {
121   return is_array_element(edge) ? array_offset(edge) : 0;
122 }
123 
124 int EdgeUtils::array_size(const Edge&amp; edge) {
125   if (is_array_element(edge)) {
126     const oop ref_owner = edge.reference_owner();
127     assert(ref_owner != NULL, &quot;invariant&quot;);
128     assert(ref_owner-&gt;is_objArray(), &quot;invariant&quot;);
<a name="10" id="anc10"></a><span class="line-modified">129     return ((objArrayOop)(ref_owner))-&gt;length();</span>
130   }
131   return 0;
132 }
133 
134 const Edge* EdgeUtils::root(const Edge&amp; edge) {
135   const Edge* current = &amp;edge;
136   const Edge* parent = current-&gt;parent();
137   while (parent != NULL) {
138     current = parent;
139     parent = current-&gt;parent();
140   }
<a name="11" id="anc11"></a>
141   return current;
142 }
143 
<a name="12" id="anc12"></a><span class="line-modified">144 // The number of references associated with the leak node;</span>
<span class="line-modified">145 // can be viewed as the leak node &quot;context&quot;.</span>
<span class="line-modified">146 // Used to provide leak context for a &quot;capped/skipped&quot; reference chain.</span>
<span class="line-removed">147 static const size_t leak_context = 100;</span>
<span class="line-removed">148 </span>
<span class="line-removed">149 // The number of references associated with the root node;</span>
<span class="line-removed">150 // can be viewed as the root node &quot;context&quot;.</span>
<span class="line-removed">151 // Used to provide root context for a &quot;capped/skipped&quot; reference chain.</span>
<span class="line-removed">152 static const size_t root_context = 100;</span>
<span class="line-removed">153 </span>
<span class="line-removed">154 // A limit on the reference chain depth to be serialized,</span>
<span class="line-removed">155 static const size_t max_ref_chain_depth = leak_context + root_context;</span>
<span class="line-removed">156 </span>
<span class="line-removed">157 const RoutableEdge* skip_to(const RoutableEdge&amp; edge, size_t skip_length) {</span>
<span class="line-removed">158   const RoutableEdge* current = &amp;edge;</span>
<span class="line-removed">159   const RoutableEdge* parent = current-&gt;physical_parent();</span>
160   size_t seek = 0;
<a name="13" id="anc13"></a><span class="line-modified">161   while (parent != NULL &amp;&amp; seek != skip_length) {</span>
162     seek++;
163     current = parent;
<a name="14" id="anc14"></a><span class="line-modified">164     parent = parent-&gt;physical_parent();</span>
<span class="line-removed">165   }</span>
<span class="line-removed">166   return current;</span>
<span class="line-removed">167 }</span>
<span class="line-removed">168 </span>
<span class="line-removed">169 #ifdef ASSERT</span>
<span class="line-removed">170 static void validate_skip_target(const RoutableEdge* skip_target) {</span>
<span class="line-removed">171   assert(skip_target != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">172   assert(skip_target-&gt;distance_to_root() + 1 == root_context, &quot;invariant&quot;);</span>
<span class="line-removed">173   assert(skip_target-&gt;is_sentinel(), &quot;invariant&quot;);</span>
<span class="line-removed">174 }</span>
<span class="line-removed">175 </span>
<span class="line-removed">176 static void validate_new_skip_edge(const RoutableEdge* new_skip_edge, const RoutableEdge* last_skip_edge, size_t adjustment) {</span>
<span class="line-removed">177   assert(new_skip_edge != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">178   assert(new_skip_edge-&gt;is_skip_edge(), &quot;invariant&quot;);</span>
<span class="line-removed">179   if (last_skip_edge != NULL) {</span>
<span class="line-removed">180     const RoutableEdge* const target = skip_to(*new_skip_edge-&gt;logical_parent(), adjustment);</span>
<span class="line-removed">181     validate_skip_target(target-&gt;logical_parent());</span>
<span class="line-removed">182     return;</span>
<span class="line-removed">183   }</span>
<span class="line-removed">184   assert(last_skip_edge == NULL, &quot;invariant&quot;);</span>
<span class="line-removed">185   // only one level of logical indirection</span>
<span class="line-removed">186   validate_skip_target(new_skip_edge-&gt;logical_parent());</span>
<span class="line-removed">187 }</span>
<span class="line-removed">188 #endif // ASSERT</span>
<span class="line-removed">189 </span>
<span class="line-removed">190 static void install_logical_route(const RoutableEdge* new_skip_edge, size_t skip_target_distance) {</span>
<span class="line-removed">191   assert(new_skip_edge != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">192   assert(!new_skip_edge-&gt;is_skip_edge(), &quot;invariant&quot;);</span>
<span class="line-removed">193   assert(!new_skip_edge-&gt;processed(), &quot;invariant&quot;);</span>
<span class="line-removed">194   const RoutableEdge* const skip_target = skip_to(*new_skip_edge, skip_target_distance);</span>
<span class="line-removed">195   assert(skip_target != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">196   new_skip_edge-&gt;set_skip_edge(skip_target);</span>
<span class="line-removed">197   new_skip_edge-&gt;set_skip_length(skip_target_distance);</span>
<span class="line-removed">198   assert(new_skip_edge-&gt;is_skip_edge(), &quot;invariant&quot;);</span>
<span class="line-removed">199   assert(new_skip_edge-&gt;logical_parent() == skip_target, &quot;invariant&quot;);</span>
<span class="line-removed">200 }</span>
<span class="line-removed">201 </span>
<span class="line-removed">202 static const RoutableEdge* find_last_skip_edge(const RoutableEdge&amp; edge, size_t&amp; distance) {</span>
<span class="line-removed">203   assert(distance == 0, &quot;invariant&quot;);</span>
<span class="line-removed">204   const RoutableEdge* current = &amp;edge;</span>
<span class="line-removed">205   while (current != NULL) {</span>
<span class="line-removed">206     if (current-&gt;is_skip_edge() &amp;&amp; current-&gt;skip_edge()-&gt;is_sentinel()) {</span>
<span class="line-removed">207       return current;</span>
<span class="line-removed">208     }</span>
<span class="line-removed">209     current = current-&gt;physical_parent();</span>
<span class="line-removed">210     ++distance;</span>
<span class="line-removed">211   }</span>
<span class="line-removed">212   return current;</span>
<span class="line-removed">213 }</span>
<span class="line-removed">214 </span>
<span class="line-removed">215 static void collapse_overlapping_chain(const RoutableEdge&amp; edge,</span>
<span class="line-removed">216                                        const RoutableEdge* first_processed_edge,</span>
<span class="line-removed">217                                        size_t first_processed_distance) {</span>
<span class="line-removed">218   assert(first_processed_edge != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">219   // first_processed_edge is already processed / written</span>
<span class="line-removed">220   assert(first_processed_edge-&gt;processed(), &quot;invariant&quot;);</span>
<span class="line-removed">221   assert(first_processed_distance + 1 &lt;= leak_context, &quot;invariant&quot;);</span>
<span class="line-removed">222 </span>
<span class="line-removed">223   // from this first processed edge, attempt to fetch the last skip edge</span>
<span class="line-removed">224   size_t last_skip_edge_distance = 0;</span>
<span class="line-removed">225   const RoutableEdge* const last_skip_edge = find_last_skip_edge(*first_processed_edge, last_skip_edge_distance);</span>
<span class="line-removed">226   const size_t distance_discovered = first_processed_distance + last_skip_edge_distance + 1;</span>
<span class="line-removed">227 </span>
<span class="line-removed">228   if (distance_discovered &lt;= leak_context || (last_skip_edge == NULL &amp;&amp; distance_discovered &lt;= max_ref_chain_depth)) {</span>
<span class="line-removed">229     // complete chain can be accommodated without modification</span>
<span class="line-removed">230     return;</span>
<span class="line-removed">231   }</span>
<span class="line-removed">232 </span>
<span class="line-removed">233   // backtrack one edge from existing processed edge</span>
<span class="line-removed">234   const RoutableEdge* const new_skip_edge = skip_to(edge, first_processed_distance - 1);</span>
<span class="line-removed">235   assert(new_skip_edge != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">236   assert(!new_skip_edge-&gt;processed(), &quot;invariant&quot;);</span>
<span class="line-removed">237   assert(new_skip_edge-&gt;parent() == first_processed_edge, &quot;invariant&quot;);</span>
<span class="line-removed">238 </span>
<span class="line-removed">239   size_t adjustment = 0;</span>
<span class="line-removed">240   if (last_skip_edge != NULL) {</span>
<span class="line-removed">241     assert(leak_context - 1 &gt; first_processed_distance - 1, &quot;invariant&quot;);</span>
<span class="line-removed">242     adjustment = leak_context - first_processed_distance - 1;</span>
<span class="line-removed">243     assert(last_skip_edge_distance + 1 &gt; adjustment, &quot;invariant&quot;);</span>
<span class="line-removed">244     install_logical_route(new_skip_edge, last_skip_edge_distance + 1 - adjustment);</span>
<span class="line-removed">245   } else {</span>
<span class="line-removed">246     install_logical_route(new_skip_edge, last_skip_edge_distance + 1 - root_context);</span>
<span class="line-removed">247     new_skip_edge-&gt;logical_parent()-&gt;set_skip_length(1); // sentinel</span>
<span class="line-removed">248   }</span>
<span class="line-removed">249 </span>
<span class="line-removed">250   DEBUG_ONLY(validate_new_skip_edge(new_skip_edge, last_skip_edge, adjustment);)</span>
<span class="line-removed">251 }</span>
<span class="line-removed">252 </span>
<span class="line-removed">253 static void collapse_non_overlapping_chain(const RoutableEdge&amp; edge,</span>
<span class="line-removed">254                                            const RoutableEdge* first_processed_edge,</span>
<span class="line-removed">255                                            size_t first_processed_distance) {</span>
<span class="line-removed">256   assert(first_processed_edge != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">257   assert(!first_processed_edge-&gt;processed(), &quot;invariant&quot;);</span>
<span class="line-removed">258   // this implies that the first &quot;processed&quot; edge is the leak context relative &quot;leaf&quot;</span>
<span class="line-removed">259   assert(first_processed_distance + 1 == leak_context, &quot;invariant&quot;);</span>
<span class="line-removed">260 </span>
<span class="line-removed">261   const size_t distance_to_root = edge.distance_to_root();</span>
<span class="line-removed">262   if (distance_to_root + 1 &lt;= max_ref_chain_depth) {</span>
<span class="line-removed">263     // complete chain can be accommodated without constructing a skip edge</span>
<span class="line-removed">264     return;</span>
<span class="line-removed">265   }</span>
<span class="line-removed">266 </span>
<span class="line-removed">267   install_logical_route(first_processed_edge, distance_to_root + 1 - first_processed_distance - root_context);</span>
<span class="line-removed">268   first_processed_edge-&gt;logical_parent()-&gt;set_skip_length(1); // sentinel</span>
<span class="line-removed">269 </span>
<span class="line-removed">270   DEBUG_ONLY(validate_new_skip_edge(first_processed_edge, NULL, 0);)</span>
<span class="line-removed">271 }</span>
<span class="line-removed">272 </span>
<span class="line-removed">273 static const RoutableEdge* processed_edge(const RoutableEdge&amp; edge, size_t&amp; distance) {</span>
<span class="line-removed">274   assert(distance == 0, &quot;invariant&quot;);</span>
<span class="line-removed">275   const RoutableEdge* current = &amp;edge;</span>
<span class="line-removed">276   while (current != NULL &amp;&amp; distance &lt; leak_context - 1) {</span>
<span class="line-removed">277     if (current-&gt;processed()) {</span>
<span class="line-removed">278       return current;</span>
<span class="line-removed">279     }</span>
<span class="line-removed">280     current = current-&gt;physical_parent();</span>
<span class="line-removed">281     ++distance;</span>
282   }
<a name="15" id="anc15"></a><span class="line-removed">283   assert(distance &lt;= leak_context - 1, &quot;invariant&quot;);</span>
284   return current;
285 }
<a name="16" id="anc16"></a><span class="line-removed">286 </span>
<span class="line-removed">287 /*</span>
<span class="line-removed">288  * Some vocabulary:</span>
<span class="line-removed">289  * -----------</span>
<span class="line-removed">290  * &quot;Context&quot; is an interval in the chain, it is associcated with an edge and it signifies a number of connected edges.</span>
<span class="line-removed">291  * &quot;Processed / written&quot; means an edge that has already been serialized.</span>
<span class="line-removed">292  * &quot;Skip edge&quot; is an edge that contains additional information for logical routing purposes.</span>
<span class="line-removed">293  * &quot;Skip target&quot; is an edge used as a destination for a skip edge</span>
<span class="line-removed">294  */</span>
<span class="line-removed">295 void EdgeUtils::collapse_chain(const RoutableEdge&amp; edge) {</span>
<span class="line-removed">296   assert(is_leak_edge(edge), &quot;invariant&quot;);</span>
<span class="line-removed">297 </span>
<span class="line-removed">298   // attempt to locate an already processed edge inside current leak context (if any)</span>
<span class="line-removed">299   size_t first_processed_distance = 0;</span>
<span class="line-removed">300   const RoutableEdge* const first_processed_edge = processed_edge(edge, first_processed_distance);</span>
<span class="line-removed">301   if (first_processed_edge == NULL) {</span>
<span class="line-removed">302     return;</span>
<span class="line-removed">303   }</span>
<span class="line-removed">304 </span>
<span class="line-removed">305   if (first_processed_edge-&gt;processed()) {</span>
<span class="line-removed">306     collapse_overlapping_chain(edge, first_processed_edge, first_processed_distance);</span>
<span class="line-removed">307   } else {</span>
<span class="line-removed">308     collapse_non_overlapping_chain(edge, first_processed_edge, first_processed_distance);</span>
<span class="line-removed">309   }</span>
<span class="line-removed">310 </span>
<span class="line-removed">311   assert(edge.logical_distance_to_root() + 1 &lt;= max_ref_chain_depth, &quot;invariant&quot;);</span>
<span class="line-removed">312 }</span>
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
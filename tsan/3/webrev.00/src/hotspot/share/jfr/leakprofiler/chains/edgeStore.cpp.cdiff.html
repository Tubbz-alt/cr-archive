<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/jfr/leakprofiler/chains/edgeStore.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="edgeQueue.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="edgeStore.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/leakprofiler/chains/edgeStore.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,133 ***</span>
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;jfr/leakprofiler/chains/edgeStore.hpp&quot;
  #include &quot;jfr/leakprofiler/chains/edgeUtils.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  
<span class="line-modified">! RoutableEdge::RoutableEdge() : Edge() {}</span>
<span class="line-modified">! RoutableEdge::RoutableEdge(const Edge* parent, const oop* reference) : Edge(parent, reference),</span>
<span class="line-modified">!                                                                        _skip_edge(NULL),</span>
<span class="line-modified">!                                                                        _skip_length(0),</span>
<span class="line-modified">!                                                                        _processed(false) {}</span>
<span class="line-removed">- </span>
<span class="line-removed">- RoutableEdge::RoutableEdge(const Edge&amp; edge) : Edge(edge),</span>
<span class="line-removed">-                                                _skip_edge(NULL),</span>
<span class="line-removed">-                                                _skip_length(0),</span>
<span class="line-removed">-                                                _processed(false) {}</span>
<span class="line-removed">- </span>
<span class="line-removed">- RoutableEdge::RoutableEdge(const RoutableEdge&amp; edge) : Edge(edge),</span>
<span class="line-removed">-                                                       _skip_edge(edge._skip_edge),</span>
<span class="line-removed">-                                                       _skip_length(edge._skip_length),</span>
<span class="line-removed">-                                                       _processed(edge._processed) {}</span>
<span class="line-removed">- </span>
<span class="line-removed">- void RoutableEdge::operator=(const RoutableEdge&amp; edge) {</span>
<span class="line-removed">-   Edge::operator=(edge);</span>
<span class="line-removed">-   _skip_edge = edge._skip_edge;</span>
<span class="line-removed">-   _skip_length = edge._skip_length;</span>
<span class="line-removed">-   _processed = edge._processed;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- size_t RoutableEdge::logical_distance_to_root() const {</span>
<span class="line-removed">-   size_t depth = 0;</span>
<span class="line-removed">-   const RoutableEdge* current = logical_parent();</span>
<span class="line-removed">-   while (current != NULL) {</span>
<span class="line-removed">-     depth++;</span>
<span class="line-removed">-     current = current-&gt;logical_parent();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return depth;</span>
<span class="line-removed">- }</span>
  
  traceid EdgeStore::_edge_id_counter = 0;
  
  EdgeStore::EdgeStore() : _edges(NULL) {
    _edges = new EdgeHashTable(this);
  }
  
  EdgeStore::~EdgeStore() {
    assert(_edges != NULL, &quot;invariant&quot;);
    delete _edges;
<span class="line-removed">-   _edges = NULL;</span>
  }
  
<span class="line-modified">! const Edge* EdgeStore::get_edge(const Edge* edge) const {</span>
<span class="line-modified">!   assert(edge != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   EdgeEntry* const entry = _edges-&gt;lookup_only(*edge, (uintptr_t)edge-&gt;reference());</span>
    return entry != NULL ? entry-&gt;literal_addr() : NULL;
  }
  
<span class="line-modified">! const Edge* EdgeStore::put(const Edge* edge) {</span>
<span class="line-modified">!   assert(edge != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   const RoutableEdge e = *edge;</span>
<span class="line-modified">!   assert(NULL == _edges-&gt;lookup_only(e, (uintptr_t)e.reference()), &quot;invariant&quot;);</span>
<span class="line-modified">!   EdgeEntry&amp; entry = _edges-&gt;put(e, (uintptr_t)e.reference());</span>
    return entry.literal_addr();
  }
  
  traceid EdgeStore::get_id(const Edge* edge) const {
    assert(edge != NULL, &quot;invariant&quot;);
<span class="line-modified">!   EdgeEntry* const entry = _edges-&gt;lookup_only(*edge, (uintptr_t)edge-&gt;reference());</span>
    assert(entry != NULL, &quot;invariant&quot;);
    return entry-&gt;id();
  }
  
<span class="line-modified">! traceid EdgeStore::get_root_id(const Edge* edge) const {</span>
    assert(edge != NULL, &quot;invariant&quot;);
<span class="line-modified">!   const Edge* root = EdgeUtils::root(*edge);</span>
    assert(root != NULL, &quot;invariant&quot;);
    return get_id(root);
  }
  
<span class="line-modified">! void EdgeStore::add_chain(const Edge* chain, size_t length) {</span>
<span class="line-modified">!   assert(chain != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(length &gt; 0, &quot;invariant&quot;);</span>
  
<span class="line-modified">!   size_t bottom_index = length - 1;</span>
<span class="line-modified">!   const size_t top_index = 0;</span>
  
<span class="line-modified">!   const Edge* stored_parent_edge = NULL;</span>
  
<span class="line-modified">!   // determine level of shared ancestry</span>
<span class="line-modified">!   for (; bottom_index &gt; top_index; --bottom_index) {</span>
<span class="line-modified">!     const Edge* stored_edge = get_edge(&amp;chain[bottom_index]);</span>
<span class="line-modified">!     if (stored_edge != NULL) {</span>
<span class="line-modified">!       stored_parent_edge = stored_edge;</span>
<span class="line-modified">!       continue;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     break;</span>
    }
  
<span class="line-modified">!   // insertion of new Edges</span>
<span class="line-modified">!   for (int i = (int)bottom_index; i &gt;= (int)top_index; --i) {</span>
<span class="line-modified">!     Edge edge(stored_parent_edge, chain[i].reference());</span>
<span class="line-modified">!     stored_parent_edge = put(&amp;edge);</span>
    }
  
<span class="line-modified">!   const oop sample_object = stored_parent_edge-&gt;pointee();</span>
<span class="line-modified">!   assert(sample_object != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(NULL == sample_object-&gt;mark(), &quot;invariant&quot;);</span>
  
<span class="line-modified">!   // Install the &quot;top&quot; edge of the chain into the sample object mark oop.</span>
<span class="line-modified">!   // This associates the sample object with its navigable reference chain.</span>
<span class="line-modified">!   sample_object-&gt;set_mark(markOop(stored_parent_edge));</span>
  }
  
<span class="line-modified">! bool EdgeStore::is_empty() const {</span>
<span class="line-modified">!   return !_edges-&gt;has_entries();</span>
  }
  
<span class="line-modified">! size_t EdgeStore::number_of_entries() const {</span>
<span class="line-modified">!   return _edges-&gt;cardinality();</span>
  }
  
<span class="line-modified">! void EdgeStore::assign_id(EdgeEntry* entry) {</span>
<span class="line-modified">!   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(entry-&gt;id() == 0, &quot;invariant&quot;);</span>
<span class="line-modified">!   entry-&gt;set_id(++_edge_id_counter);</span>
  }
  
<span class="line-modified">! bool EdgeStore::equals(const Edge&amp; query, uintptr_t hash, const EdgeEntry* entry) {</span>
<span class="line-modified">!   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(entry-&gt;hash() == hash, &quot;invariant&quot;);</span>
<span class="line-modified">!   return true;</span>
  }
<span class="line-new-header">--- 23,296 ---</span>
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;jfr/leakprofiler/chains/edgeStore.hpp&quot;
  #include &quot;jfr/leakprofiler/chains/edgeUtils.hpp&quot;
<span class="line-added">+ #include &quot;jfr/leakprofiler/utilities/unifiedOopRef.inline.hpp&quot;</span>
  #include &quot;oops/oop.inline.hpp&quot;
  
<span class="line-modified">! StoredEdge::StoredEdge(const Edge* parent, UnifiedOopRef reference) : Edge(parent, reference), _gc_root_id(0), _skip_length(0) {}</span>
<span class="line-modified">! </span>
<span class="line-modified">! StoredEdge::StoredEdge(const Edge&amp; edge) : Edge(edge), _gc_root_id(0), _skip_length(0) {}</span>
<span class="line-modified">! </span>
<span class="line-modified">! StoredEdge::StoredEdge(const StoredEdge&amp; edge) : Edge(edge), _gc_root_id(edge._gc_root_id), _skip_length(edge._skip_length) {}</span>
  
  traceid EdgeStore::_edge_id_counter = 0;
  
  EdgeStore::EdgeStore() : _edges(NULL) {
    _edges = new EdgeHashTable(this);
  }
  
  EdgeStore::~EdgeStore() {
    assert(_edges != NULL, &quot;invariant&quot;);
    delete _edges;
  }
  
<span class="line-modified">! bool EdgeStore::is_empty() const {</span>
<span class="line-modified">!   return !_edges-&gt;has_entries();</span>
<span class="line-modified">! }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void EdgeStore::on_link(EdgeEntry* entry) {</span>
<span class="line-added">+   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(entry-&gt;id() == 0, &quot;invariant&quot;);</span>
<span class="line-added">+   entry-&gt;set_id(++_edge_id_counter);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool EdgeStore::on_equals(uintptr_t hash, const EdgeEntry* entry) {</span>
<span class="line-added">+   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(entry-&gt;hash() == hash, &quot;invariant&quot;);</span>
<span class="line-added">+   return true;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void EdgeStore::on_unlink(EdgeEntry* entry) {</span>
<span class="line-added">+   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   // nothing</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #ifdef ASSERT</span>
<span class="line-added">+ bool EdgeStore::contains(UnifiedOopRef reference) const {</span>
<span class="line-added">+   return get(reference) != NULL;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ StoredEdge* EdgeStore::get(UnifiedOopRef reference) const {</span>
<span class="line-added">+   assert(!reference.is_null(), &quot;invariant&quot;);</span>
<span class="line-added">+   EdgeEntry* const entry = _edges-&gt;lookup_only(reference.addr&lt;uintptr_t&gt;());</span>
    return entry != NULL ? entry-&gt;literal_addr() : NULL;
  }
  
<span class="line-modified">! StoredEdge* EdgeStore::put(UnifiedOopRef reference) {</span>
<span class="line-modified">!   assert(!reference.is_null(), &quot;invariant&quot;);</span>
<span class="line-modified">!   const StoredEdge e(NULL, reference);</span>
<span class="line-modified">!   assert(NULL == _edges-&gt;lookup_only(reference.addr&lt;uintptr_t&gt;()), &quot;invariant&quot;);</span>
<span class="line-modified">!   EdgeEntry&amp; entry = _edges-&gt;put(reference.addr&lt;uintptr_t&gt;(), e);</span>
    return entry.literal_addr();
  }
  
  traceid EdgeStore::get_id(const Edge* edge) const {
    assert(edge != NULL, &quot;invariant&quot;);
<span class="line-modified">!   EdgeEntry* const entry = _edges-&gt;lookup_only(edge-&gt;reference().addr&lt;uintptr_t&gt;());</span>
    assert(entry != NULL, &quot;invariant&quot;);
    return entry-&gt;id();
  }
  
<span class="line-modified">! traceid EdgeStore::gc_root_id(const Edge* edge) const {</span>
<span class="line-added">+   assert(edge != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   const traceid gc_root_id = static_cast&lt;const StoredEdge*&gt;(edge)-&gt;gc_root_id();</span>
<span class="line-added">+   if (gc_root_id != 0) {</span>
<span class="line-added">+     return gc_root_id;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   // not cached</span>
    assert(edge != NULL, &quot;invariant&quot;);
<span class="line-modified">!   const Edge* const root = EdgeUtils::root(*edge);</span>
    assert(root != NULL, &quot;invariant&quot;);
<span class="line-added">+   assert(root-&gt;parent() == NULL, &quot;invariant&quot;);</span>
    return get_id(root);
  }
  
<span class="line-modified">! static const Edge* get_skip_ancestor(const Edge** current, size_t distance_to_root, size_t* skip_length) {</span>
<span class="line-modified">!   assert(distance_to_root &gt;= EdgeUtils::root_context, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(*skip_length == 0, &quot;invariant&quot;);</span>
<span class="line-added">+   *skip_length = distance_to_root - (EdgeUtils::root_context - 1);</span>
<span class="line-added">+   const Edge* const target = EdgeUtils::ancestor(**current, *skip_length);</span>
<span class="line-added">+   assert(target != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(target-&gt;distance_to_root() + 1 == EdgeUtils::root_context, &quot;invariant&quot;);</span>
<span class="line-added">+   return target;</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! bool EdgeStore::put_skip_edge(StoredEdge** previous, const Edge** current, size_t distance_to_root) {</span>
<span class="line-modified">!   assert(*previous != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert((*previous)-&gt;parent() == NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(*current != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert((*current)-&gt;distance_to_root() == distance_to_root, &quot;invariant&quot;);</span>
  
<span class="line-modified">!   if (distance_to_root &lt; EdgeUtils::root_context) {</span>
<span class="line-added">+     // nothing to skip</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
  
<span class="line-modified">!   size_t skip_length = 0;</span>
<span class="line-modified">!   const Edge* const skip_ancestor = get_skip_ancestor(current, distance_to_root, &amp;skip_length);</span>
<span class="line-modified">!   assert(skip_ancestor != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   (*previous)-&gt;set_skip_length(skip_length);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // lookup target</span>
<span class="line-modified">!   StoredEdge* stored_target = get(skip_ancestor-&gt;reference());</span>
<span class="line-modified">!   if (stored_target != NULL) {</span>
<span class="line-added">+     (*previous)-&gt;set_parent(stored_target);</span>
<span class="line-added">+     // linked to existing, complete</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   assert(stored_target == NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   stored_target = put(skip_ancestor-&gt;reference());</span>
<span class="line-added">+   assert(stored_target != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   (*previous)-&gt;set_parent(stored_target);</span>
<span class="line-added">+   *previous = stored_target;</span>
<span class="line-added">+   *current = skip_ancestor-&gt;parent();</span>
<span class="line-added">+   return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void link_edge(const StoredEdge* current_stored, StoredEdge** previous) {</span>
<span class="line-added">+   assert(current_stored != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(*previous != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert((*previous)-&gt;parent() == NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   (*previous)-&gt;set_parent(current_stored);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static const StoredEdge* find_closest_skip_edge(const StoredEdge* edge, size_t* distance) {</span>
<span class="line-added">+   assert(edge != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(distance != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   const StoredEdge* current = edge;</span>
<span class="line-added">+   *distance = 1;</span>
<span class="line-added">+   while (current != NULL &amp;&amp; !current-&gt;is_skip_edge()) {</span>
<span class="line-added">+     ++(*distance);</span>
<span class="line-added">+     current = current-&gt;parent();</span>
    }
<span class="line-added">+   return current;</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! void EdgeStore::link_with_existing_chain(const StoredEdge* current_stored, StoredEdge** previous, size_t previous_length) {</span>
<span class="line-modified">!   assert(current_stored != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert((*previous)-&gt;parent() == NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   size_t distance_to_skip_edge; // including the skip edge itself</span>
<span class="line-added">+   const StoredEdge* const closest_skip_edge = find_closest_skip_edge(current_stored, &amp;distance_to_skip_edge);</span>
<span class="line-added">+   if (closest_skip_edge == NULL) {</span>
<span class="line-added">+     // no found skip edge implies root</span>
<span class="line-added">+     if (distance_to_skip_edge + previous_length &lt;= EdgeUtils::max_ref_chain_depth) {</span>
<span class="line-added">+       link_edge(current_stored, previous);</span>
<span class="line-added">+       return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     assert(current_stored-&gt;distance_to_root() == distance_to_skip_edge - 2, &quot;invariant&quot;);</span>
<span class="line-added">+     put_skip_edge(previous, reinterpret_cast&lt;const Edge**&gt;(&amp;current_stored), distance_to_skip_edge - 2);</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   assert(closest_skip_edge-&gt;is_skip_edge(), &quot;invariant&quot;);</span>
<span class="line-added">+   if (distance_to_skip_edge + previous_length &lt;= EdgeUtils::leak_context) {</span>
<span class="line-added">+     link_edge(current_stored, previous);</span>
<span class="line-added">+     return;</span>
    }
<span class="line-added">+   // create a new skip edge with derived information from closest skip edge</span>
<span class="line-added">+   (*previous)-&gt;set_skip_length(distance_to_skip_edge + closest_skip_edge-&gt;skip_length());</span>
<span class="line-added">+   (*previous)-&gt;set_parent(closest_skip_edge-&gt;parent());</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! StoredEdge* EdgeStore::link_new_edge(StoredEdge** previous, const Edge** current) {</span>
<span class="line-modified">!   assert(*previous != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert((*previous)-&gt;parent() == NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(*current != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(!contains((*current)-&gt;reference()), &quot;invariant&quot;);</span>
<span class="line-added">+   StoredEdge* const stored_edge = put((*current)-&gt;reference());</span>
<span class="line-added">+   assert(stored_edge != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   link_edge(stored_edge, previous);</span>
<span class="line-added">+   return stored_edge;</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! bool EdgeStore::put_edges(StoredEdge** previous, const Edge** current, size_t limit) {</span>
<span class="line-modified">!   assert(*previous != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(*current != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   size_t depth = 1;</span>
<span class="line-added">+   while (*current != NULL &amp;&amp; depth &lt; limit) {</span>
<span class="line-added">+     StoredEdge* stored_edge = get((*current)-&gt;reference());</span>
<span class="line-added">+     if (stored_edge != NULL) {</span>
<span class="line-added">+       link_with_existing_chain(stored_edge, previous, depth);</span>
<span class="line-added">+       return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     stored_edge = link_new_edge(previous, current);</span>
<span class="line-added">+     assert((*previous)-&gt;parent() != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+     *previous = stored_edge;</span>
<span class="line-added">+     *current = (*current)-&gt;parent();</span>
<span class="line-added">+     ++depth;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return NULL == *current;</span>
  }
  
<span class="line-modified">! // Install the immediate edge into the mark word of the leak candidate object</span>
<span class="line-modified">! StoredEdge* EdgeStore::associate_leak_context_with_candidate(const Edge* edge) {</span>
<span class="line-added">+   assert(edge != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(!contains(edge-&gt;reference()), &quot;invariant&quot;);</span>
<span class="line-added">+   StoredEdge* const leak_context_edge = put(edge-&gt;reference());</span>
<span class="line-added">+   oop sample_object = edge-&gt;pointee();</span>
<span class="line-added">+   assert(sample_object != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(sample_object-&gt;mark().is_marked(), &quot;invariant&quot;);</span>
<span class="line-added">+   sample_object-&gt;set_mark(markWord::from_pointer(leak_context_edge));</span>
<span class="line-added">+   return leak_context_edge;</span>
  }
  
<span class="line-modified">! /*</span>
<span class="line-modified">!  * The purpose of put_chain() is to reify the edge sequence</span>
<span class="line-added">+  * discovered during heap traversal with a normalized logical copy.</span>
<span class="line-added">+  * This copy consist of two sub-sequences and a connecting link (skip edge).</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * &quot;current&quot; can be thought of as the cursor (search) edge, it is not in the edge store.</span>
<span class="line-added">+  * &quot;previous&quot; is always an edge in the edge store.</span>
<span class="line-added">+  * The leak context edge is the edge adjacent to the leak candidate object, always an edge in the edge store.</span>
<span class="line-added">+  */</span>
<span class="line-added">+ void EdgeStore::put_chain(const Edge* chain, size_t length) {</span>
<span class="line-added">+   assert(chain != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(chain-&gt;distance_to_root() + 1 == length, &quot;invariant&quot;);</span>
<span class="line-added">+   StoredEdge* const leak_context_edge = associate_leak_context_with_candidate(chain);</span>
<span class="line-added">+   assert(leak_context_edge != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(leak_context_edge-&gt;parent() == NULL, &quot;invariant&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (1 == length) {</span>
<span class="line-added">+     store_gc_root_id_in_leak_context_edge(leak_context_edge, leak_context_edge);</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   const Edge* current = chain-&gt;parent();</span>
<span class="line-added">+   assert(current != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   StoredEdge* previous = leak_context_edge;</span>
<span class="line-added">+ </span>
<span class="line-added">+   // a leak context is the sequence of (limited) edges reachable from the leak candidate</span>
<span class="line-added">+   if (put_edges(&amp;previous, &amp;current, EdgeUtils::leak_context)) {</span>
<span class="line-added">+     // complete</span>
<span class="line-added">+     assert(previous != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+     put_chain_epilogue(leak_context_edge, EdgeUtils::root(*previous));</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   const size_t distance_to_root = length &gt; EdgeUtils::leak_context ? length - 1 - EdgeUtils::leak_context : length - 1;</span>
<span class="line-added">+   assert(current-&gt;distance_to_root() == distance_to_root, &quot;invariant&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // a skip edge is the logical link</span>
<span class="line-added">+   // connecting the leak context sequence with the root context sequence</span>
<span class="line-added">+   if (put_skip_edge(&amp;previous, &amp;current, distance_to_root)) {</span>
<span class="line-added">+     // complete</span>
<span class="line-added">+     assert(previous != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+     assert(previous-&gt;is_skip_edge(), &quot;invariant&quot;);</span>
<span class="line-added">+     assert(previous-&gt;parent() != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+     put_chain_epilogue(leak_context_edge, EdgeUtils::root(*previous-&gt;parent()));</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   assert(current-&gt;distance_to_root() &lt; EdgeUtils::root_context, &quot;invariant&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // a root context is the sequence of (limited) edges reachable from the root</span>
<span class="line-added">+   put_edges(&amp;previous, &amp;current, EdgeUtils::root_context);</span>
<span class="line-added">+   assert(previous != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   put_chain_epilogue(leak_context_edge, EdgeUtils::root(*previous));</span>
  }
  
<span class="line-modified">! void EdgeStore::put_chain_epilogue(StoredEdge* leak_context_edge, const Edge* root) const {</span>
<span class="line-modified">!   assert(leak_context_edge != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(root != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   store_gc_root_id_in_leak_context_edge(leak_context_edge, root);</span>
<span class="line-added">+   assert(leak_context_edge-&gt;distance_to_root() + 1 &lt;= EdgeUtils::max_ref_chain_depth, &quot;invariant&quot;);</span>
  }
  
<span class="line-modified">! // To avoid another traversal to resolve the root edge id later,</span>
<span class="line-modified">! // cache it in the immediate leak context edge for fast retrieval.</span>
<span class="line-modified">! void EdgeStore::store_gc_root_id_in_leak_context_edge(StoredEdge* leak_context_edge, const Edge* root) const {</span>
<span class="line-modified">!   assert(leak_context_edge != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(leak_context_edge-&gt;gc_root_id() == 0, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(root != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(root-&gt;parent() == NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(root-&gt;distance_to_root() == 0, &quot;invariant&quot;);</span>
<span class="line-added">+   const StoredEdge* const stored_root = static_cast&lt;const StoredEdge*&gt;(root);</span>
<span class="line-added">+   traceid root_id = stored_root-&gt;gc_root_id();</span>
<span class="line-added">+   if (root_id == 0) {</span>
<span class="line-added">+     root_id = get_id(root);</span>
<span class="line-added">+     stored_root-&gt;set_gc_root_id(root_id);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   assert(root_id != 0, &quot;invariant&quot;);</span>
<span class="line-added">+   leak_context_edge-&gt;set_gc_root_id(root_id);</span>
<span class="line-added">+   assert(leak_context_edge-&gt;gc_root_id() == stored_root-&gt;gc_root_id(), &quot;invariant&quot;);</span>
  }
</pre>
<center><a href="edgeQueue.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="edgeStore.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
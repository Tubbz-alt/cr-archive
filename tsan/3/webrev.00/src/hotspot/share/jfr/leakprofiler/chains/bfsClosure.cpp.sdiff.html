<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/leakprofiler/chains/bfsClosure.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../jni/jfrUpcalls.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="bfsClosure.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/leakprofiler/chains/bfsClosure.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 #include &quot;precompiled.hpp&quot;
<span class="line-modified"> 25 #include &quot;jfr/leakprofiler/chains/bitset.hpp&quot;</span>
 26 #include &quot;jfr/leakprofiler/chains/bfsClosure.hpp&quot;
 27 #include &quot;jfr/leakprofiler/chains/dfsClosure.hpp&quot;
 28 #include &quot;jfr/leakprofiler/chains/edge.hpp&quot;
 29 #include &quot;jfr/leakprofiler/chains/edgeStore.hpp&quot;
 30 #include &quot;jfr/leakprofiler/chains/edgeQueue.hpp&quot;
 31 #include &quot;jfr/leakprofiler/utilities/granularTimer.hpp&quot;
<span class="line-modified"> 32 #include &quot;jfr/leakprofiler/utilities/unifiedOop.hpp&quot;</span>
 33 #include &quot;logging/log.hpp&quot;
 34 #include &quot;memory/iterator.inline.hpp&quot;
 35 #include &quot;memory/resourceArea.hpp&quot;
 36 #include &quot;oops/access.inline.hpp&quot;
 37 #include &quot;oops/oop.inline.hpp&quot;
 38 #include &quot;utilities/align.hpp&quot;
 39 
 40 BFSClosure::BFSClosure(EdgeQueue* edge_queue, EdgeStore* edge_store, BitSet* mark_bits) :
 41   _edge_queue(edge_queue),
 42   _edge_store(edge_store),
 43   _mark_bits(mark_bits),
 44   _current_parent(NULL),
 45   _current_frontier_level(0),
 46   _next_frontier_idx(0),
 47   _prev_frontier_idx(0),
 48   _dfs_fallback_idx(0),
 49   _use_dfs(false) {
 50 }
 51 
 52 static void log_frontier_level_summary(size_t level,
</pre>
<hr />
<pre>
 82                              _edge_queue-&gt;bottom(),
 83                              _next_frontier_idx,
 84                              edge_size);
 85 
 86   // additional information about DFS fallover
 87   log_trace(jfr, system)(
 88       &quot;BFS front: &quot; SIZE_FORMAT &quot; filled edge queue at edge: &quot; SIZE_FORMAT,
 89       _current_frontier_level,
 90       _dfs_fallback_idx
 91                         );
 92 
 93   const size_t nof_dfs_completed_edges = _edge_queue-&gt;bottom() - _dfs_fallback_idx;
 94   log_trace(jfr, system)(
 95       &quot;DFS to complete &quot; SIZE_FORMAT &quot; edges size: &quot; SIZE_FORMAT &quot; [KB]&quot;,
 96       nof_dfs_completed_edges,
 97       (nof_dfs_completed_edges * edge_size) / K
 98                         );
 99 }
100 
101 void BFSClosure::process() {
<span class="line-removed">102 </span>
103   process_root_set();
104   process_queue();
105 }
106 
107 void BFSClosure::process_root_set() {
108   for (size_t idx = _edge_queue-&gt;bottom(); idx &lt; _edge_queue-&gt;top(); ++idx) {
109     const Edge* edge = _edge_queue-&gt;element_at(idx);
110     assert(edge-&gt;parent() == NULL, &quot;invariant&quot;);
111     process(edge-&gt;reference(), edge-&gt;pointee());
112   }
113 }
114 
<span class="line-modified">115 void BFSClosure::process(const oop* reference, const oop pointee) {</span>
116   closure_impl(reference, pointee);
117 }
<span class="line-modified">118 void BFSClosure::closure_impl(const oop* reference, const oop pointee) {</span>
<span class="line-modified">119   assert(reference != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">120   assert(UnifiedOop::dereference(reference) == pointee, &quot;invariant&quot;);</span>
121 
122   if (GranularTimer::is_finished()) {
123      return;
124   }
125 
126   if (_use_dfs) {
127     assert(_current_parent != NULL, &quot;invariant&quot;);
128     DFSClosure::find_leaks_from_edge(_edge_store, _mark_bits, _current_parent);
129     return;
130   }
131 
132   if (!_mark_bits-&gt;is_marked(pointee)) {
133     _mark_bits-&gt;mark_obj(pointee);
134     // is the pointee a sample object?
<span class="line-modified">135     if (NULL == pointee-&gt;mark()) {</span>
136       add_chain(reference, pointee);
137     }
138 
139     // if we are processinig initial root set, don&#39;t add to queue
140     if (_current_parent != NULL) {
<span class="line-removed">141       assert(_current_parent-&gt;distance_to_root() == _current_frontier_level, &quot;invariant&quot;);</span>
142       _edge_queue-&gt;add(_current_parent, reference);
143     }
144 
145     if (_edge_queue-&gt;is_full()) {
146       dfs_fallback();
147     }
148   }
149 }
150 
<span class="line-modified">151 void BFSClosure::add_chain(const oop* reference, const oop pointee) {</span>
152   assert(pointee != NULL, &quot;invariant&quot;);
<span class="line-modified">153   assert(NULL == pointee-&gt;mark(), &quot;invariant&quot;);</span>
<span class="line-modified">154 </span>
<span class="line-modified">155   const size_t length = _current_parent == NULL ? 1 : _current_parent-&gt;distance_to_root() + 2;</span>
<span class="line-removed">156   ResourceMark rm;</span>
<span class="line-removed">157   Edge* const chain = NEW_RESOURCE_ARRAY(Edge, length);</span>
<span class="line-removed">158   size_t idx = 0;</span>
<span class="line-removed">159   chain[idx++] = Edge(NULL, reference);</span>
<span class="line-removed">160   // aggregate from breadth-first search</span>
<span class="line-removed">161   const Edge* current = _current_parent;</span>
<span class="line-removed">162   while (current != NULL) {</span>
<span class="line-removed">163     chain[idx++] = Edge(NULL, current-&gt;reference());</span>
<span class="line-removed">164     current = current-&gt;parent();</span>
<span class="line-removed">165   }</span>
<span class="line-removed">166   assert(length == idx, &quot;invariant&quot;);</span>
<span class="line-removed">167   _edge_store-&gt;add_chain(chain, length);</span>
168 }
169 
170 void BFSClosure::dfs_fallback() {
171   assert(_edge_queue-&gt;is_full(), &quot;invariant&quot;);
172   _use_dfs = true;
173   _dfs_fallback_idx = _edge_queue-&gt;bottom();
174   while (!_edge_queue-&gt;is_empty()) {
175     const Edge* edge = _edge_queue-&gt;remove();
176     if (edge-&gt;pointee() != NULL) {
177       DFSClosure::find_leaks_from_edge(_edge_store, _mark_bits, edge);
178     }
179   }
180 }
181 
182 void BFSClosure::process_queue() {
183   assert(_current_frontier_level == 0, &quot;invariant&quot;);
184   assert(_next_frontier_idx == 0, &quot;invariant&quot;);
185   assert(_prev_frontier_idx == 0, &quot;invariant&quot;);
186 
187   _next_frontier_idx = _edge_queue-&gt;top();
</pre>
<hr />
<pre>
210   }
211   assert(_edge_queue-&gt;bottom() == _next_frontier_idx, &quot;invariant&quot;);
212   if (_edge_queue-&gt;is_empty()) {
213     return true;
214   }
215   step_frontier();
216   return false;
217 }
218 
219 void BFSClosure::iterate(const Edge* parent) {
220   assert(parent != NULL, &quot;invariant&quot;);
221   const oop pointee = parent-&gt;pointee();
222   assert(pointee != NULL, &quot;invariant&quot;);
223   _current_parent = parent;
224   pointee-&gt;oop_iterate(this);
225 }
226 
227 void BFSClosure::do_oop(oop* ref) {
228   assert(ref != NULL, &quot;invariant&quot;);
229   assert(is_aligned(ref, HeapWordSize), &quot;invariant&quot;);
<span class="line-modified">230   const oop pointee = *ref;</span>
231   if (pointee != NULL) {
<span class="line-modified">232     closure_impl(ref, pointee);</span>
233   }
234 }
235 
236 void BFSClosure::do_oop(narrowOop* ref) {
237   assert(ref != NULL, &quot;invariant&quot;);
238   assert(is_aligned(ref, sizeof(narrowOop)), &quot;invariant&quot;);
<span class="line-modified">239   const oop pointee = RawAccess&lt;&gt;::oop_load(ref);</span>
240   if (pointee != NULL) {
<span class="line-modified">241     closure_impl(UnifiedOop::encode(ref), pointee);</span>







242   }
243 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 #include &quot;precompiled.hpp&quot;
<span class="line-modified"> 25 #include &quot;jfr/leakprofiler/chains/bitset.inline.hpp&quot;</span>
 26 #include &quot;jfr/leakprofiler/chains/bfsClosure.hpp&quot;
 27 #include &quot;jfr/leakprofiler/chains/dfsClosure.hpp&quot;
 28 #include &quot;jfr/leakprofiler/chains/edge.hpp&quot;
 29 #include &quot;jfr/leakprofiler/chains/edgeStore.hpp&quot;
 30 #include &quot;jfr/leakprofiler/chains/edgeQueue.hpp&quot;
 31 #include &quot;jfr/leakprofiler/utilities/granularTimer.hpp&quot;
<span class="line-modified"> 32 #include &quot;jfr/leakprofiler/utilities/unifiedOopRef.inline.hpp&quot;</span>
 33 #include &quot;logging/log.hpp&quot;
 34 #include &quot;memory/iterator.inline.hpp&quot;
 35 #include &quot;memory/resourceArea.hpp&quot;
 36 #include &quot;oops/access.inline.hpp&quot;
 37 #include &quot;oops/oop.inline.hpp&quot;
 38 #include &quot;utilities/align.hpp&quot;
 39 
 40 BFSClosure::BFSClosure(EdgeQueue* edge_queue, EdgeStore* edge_store, BitSet* mark_bits) :
 41   _edge_queue(edge_queue),
 42   _edge_store(edge_store),
 43   _mark_bits(mark_bits),
 44   _current_parent(NULL),
 45   _current_frontier_level(0),
 46   _next_frontier_idx(0),
 47   _prev_frontier_idx(0),
 48   _dfs_fallback_idx(0),
 49   _use_dfs(false) {
 50 }
 51 
 52 static void log_frontier_level_summary(size_t level,
</pre>
<hr />
<pre>
 82                              _edge_queue-&gt;bottom(),
 83                              _next_frontier_idx,
 84                              edge_size);
 85 
 86   // additional information about DFS fallover
 87   log_trace(jfr, system)(
 88       &quot;BFS front: &quot; SIZE_FORMAT &quot; filled edge queue at edge: &quot; SIZE_FORMAT,
 89       _current_frontier_level,
 90       _dfs_fallback_idx
 91                         );
 92 
 93   const size_t nof_dfs_completed_edges = _edge_queue-&gt;bottom() - _dfs_fallback_idx;
 94   log_trace(jfr, system)(
 95       &quot;DFS to complete &quot; SIZE_FORMAT &quot; edges size: &quot; SIZE_FORMAT &quot; [KB]&quot;,
 96       nof_dfs_completed_edges,
 97       (nof_dfs_completed_edges * edge_size) / K
 98                         );
 99 }
100 
101 void BFSClosure::process() {

102   process_root_set();
103   process_queue();
104 }
105 
106 void BFSClosure::process_root_set() {
107   for (size_t idx = _edge_queue-&gt;bottom(); idx &lt; _edge_queue-&gt;top(); ++idx) {
108     const Edge* edge = _edge_queue-&gt;element_at(idx);
109     assert(edge-&gt;parent() == NULL, &quot;invariant&quot;);
110     process(edge-&gt;reference(), edge-&gt;pointee());
111   }
112 }
113 
<span class="line-modified">114 void BFSClosure::process(UnifiedOopRef reference, const oop pointee) {</span>
115   closure_impl(reference, pointee);
116 }
<span class="line-modified">117 void BFSClosure::closure_impl(UnifiedOopRef reference, const oop pointee) {</span>
<span class="line-modified">118   assert(!reference.is_null(), &quot;invariant&quot;);</span>
<span class="line-modified">119   assert(reference.dereference() == pointee, &quot;invariant&quot;);</span>
120 
121   if (GranularTimer::is_finished()) {
122      return;
123   }
124 
125   if (_use_dfs) {
126     assert(_current_parent != NULL, &quot;invariant&quot;);
127     DFSClosure::find_leaks_from_edge(_edge_store, _mark_bits, _current_parent);
128     return;
129   }
130 
131   if (!_mark_bits-&gt;is_marked(pointee)) {
132     _mark_bits-&gt;mark_obj(pointee);
133     // is the pointee a sample object?
<span class="line-modified">134     if (pointee-&gt;mark().is_marked()) {</span>
135       add_chain(reference, pointee);
136     }
137 
138     // if we are processinig initial root set, don&#39;t add to queue
139     if (_current_parent != NULL) {

140       _edge_queue-&gt;add(_current_parent, reference);
141     }
142 
143     if (_edge_queue-&gt;is_full()) {
144       dfs_fallback();
145     }
146   }
147 }
148 
<span class="line-modified">149 void BFSClosure::add_chain(UnifiedOopRef reference, const oop pointee) {</span>
150   assert(pointee != NULL, &quot;invariant&quot;);
<span class="line-modified">151   assert(pointee-&gt;mark().is_marked(), &quot;invariant&quot;);</span>
<span class="line-modified">152   Edge leak_edge(_current_parent, reference);</span>
<span class="line-modified">153   _edge_store-&gt;put_chain(&amp;leak_edge, _current_parent == NULL ? 1 : _current_frontier_level + 2);</span>












154 }
155 
156 void BFSClosure::dfs_fallback() {
157   assert(_edge_queue-&gt;is_full(), &quot;invariant&quot;);
158   _use_dfs = true;
159   _dfs_fallback_idx = _edge_queue-&gt;bottom();
160   while (!_edge_queue-&gt;is_empty()) {
161     const Edge* edge = _edge_queue-&gt;remove();
162     if (edge-&gt;pointee() != NULL) {
163       DFSClosure::find_leaks_from_edge(_edge_store, _mark_bits, edge);
164     }
165   }
166 }
167 
168 void BFSClosure::process_queue() {
169   assert(_current_frontier_level == 0, &quot;invariant&quot;);
170   assert(_next_frontier_idx == 0, &quot;invariant&quot;);
171   assert(_prev_frontier_idx == 0, &quot;invariant&quot;);
172 
173   _next_frontier_idx = _edge_queue-&gt;top();
</pre>
<hr />
<pre>
196   }
197   assert(_edge_queue-&gt;bottom() == _next_frontier_idx, &quot;invariant&quot;);
198   if (_edge_queue-&gt;is_empty()) {
199     return true;
200   }
201   step_frontier();
202   return false;
203 }
204 
205 void BFSClosure::iterate(const Edge* parent) {
206   assert(parent != NULL, &quot;invariant&quot;);
207   const oop pointee = parent-&gt;pointee();
208   assert(pointee != NULL, &quot;invariant&quot;);
209   _current_parent = parent;
210   pointee-&gt;oop_iterate(this);
211 }
212 
213 void BFSClosure::do_oop(oop* ref) {
214   assert(ref != NULL, &quot;invariant&quot;);
215   assert(is_aligned(ref, HeapWordSize), &quot;invariant&quot;);
<span class="line-modified">216   const oop pointee = HeapAccess&lt;AS_NO_KEEPALIVE&gt;::oop_load(ref);</span>
217   if (pointee != NULL) {
<span class="line-modified">218     closure_impl(UnifiedOopRef::encode_in_heap(ref), pointee);</span>
219   }
220 }
221 
222 void BFSClosure::do_oop(narrowOop* ref) {
223   assert(ref != NULL, &quot;invariant&quot;);
224   assert(is_aligned(ref, sizeof(narrowOop)), &quot;invariant&quot;);
<span class="line-modified">225   const oop pointee = HeapAccess&lt;AS_NO_KEEPALIVE&gt;::oop_load(ref);</span>
226   if (pointee != NULL) {
<span class="line-modified">227     closure_impl(UnifiedOopRef::encode_in_heap(ref), pointee);</span>
<span class="line-added">228   }</span>
<span class="line-added">229 }</span>
<span class="line-added">230 </span>
<span class="line-added">231 void BFSClosure::do_root(UnifiedOopRef ref) {</span>
<span class="line-added">232   assert(!ref.is_null(), &quot;invariant&quot;);</span>
<span class="line-added">233   if (!_edge_queue-&gt;is_full()) {</span>
<span class="line-added">234     _edge_queue-&gt;add(NULL, ref);</span>
235   }
236 }
</pre>
</td>
</tr>
</table>
<center><a href="../../jni/jfrUpcalls.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="bfsClosure.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/jfr/leakprofiler/checkpoint/rootResolver.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;aot/aotLoader.hpp&quot;
 27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
 28 #include &quot;classfile/stringTable.hpp&quot;
 29 #include &quot;gc/shared/strongRootsScope.hpp&quot;
 30 #include &quot;jfr/leakprofiler/utilities/unifiedOopRef.inline.hpp&quot;
 31 #include &quot;jfr/leakprofiler/checkpoint/rootResolver.hpp&quot;
 32 #include &quot;jfr/utilities/jfrThreadIterator.hpp&quot;
 33 #include &quot;memory/iterator.hpp&quot;
 34 #include &quot;memory/universe.hpp&quot;
 35 #include &quot;oops/klass.hpp&quot;
 36 #include &quot;oops/oop.hpp&quot;
 37 #include &quot;prims/jvmtiThreadState.hpp&quot;
 38 #include &quot;runtime/frame.inline.hpp&quot;
 39 #include &quot;runtime/mutexLocker.hpp&quot;
 40 #include &quot;runtime/vframe_hp.hpp&quot;
 41 #include &quot;services/management.hpp&quot;
 42 #include &quot;utilities/growableArray.hpp&quot;
 43 
 44 class ReferenceLocateClosure : public OopClosure {
 45  protected:
 46   RootCallback&amp; _callback;
 47   RootCallbackInfo _info;
 48   bool _complete;
 49 
 50   void do_oop_shared(UnifiedOopRef ref);
 51 
 52  public:
 53   ReferenceLocateClosure(RootCallback&amp; callback,
 54                          OldObjectRoot::System system,
 55                          OldObjectRoot::Type type,
 56                          const void* context) : _callback(callback),
 57                                                 _info(),
 58                                                 _complete(false) {
 59     _info._high = NULL;
 60     _info._low = NULL;
 61     _info._system = system;
 62     _info._type = type;
 63     _info._context = context;
 64   }
 65 
 66   virtual void do_oop(oop* ref);
 67   virtual void do_oop(narrowOop* ref);
 68 
 69   bool complete() const {
 70     return _complete;
 71   }
 72 };
 73 
 74 void ReferenceLocateClosure::do_oop_shared(UnifiedOopRef ref) {
 75   assert(!ref.is_null(), &quot;invariant&quot;);
 76   if (!_complete) {
 77     _info._high = ref.addr&lt;address&gt;();
 78     _complete = _callback.process(_info);
 79   }
 80 }
 81 
 82 void ReferenceLocateClosure::do_oop(oop* ref) {
 83   do_oop_shared(UnifiedOopRef::encode_in_native(ref));
 84 }
 85 
 86 void ReferenceLocateClosure::do_oop(narrowOop* ref) {
 87   do_oop_shared(UnifiedOopRef::encode_in_native(ref));
 88 }
 89 
 90 class ReferenceToRootClosure : public StackObj {
 91  private:
 92   RootCallback&amp; _callback;
 93   RootCallbackInfo _info;
 94   bool _complete;
 95 
 96   bool do_cldg_roots();
 97   bool do_object_synchronizer_roots();
 98   bool do_universe_roots();
 99   bool do_jni_handle_roots();
100   bool do_jvmti_roots();
101   bool do_system_dictionary_roots();
102   bool do_management_roots();
103   bool do_string_table_roots();
104   bool do_aot_loader_roots();
105 
106   bool do_roots();
107 
108  public:
109   ReferenceToRootClosure(RootCallback&amp; callback) : _callback(callback),
110                                                    _info(),
111                                                    _complete(false) {
112     _info._high = NULL;
113     _info._low = NULL;
114     _info._context = NULL;
115     _info._system = OldObjectRoot::_system_undetermined;
116     _info._type = OldObjectRoot::_type_undetermined;
117 
118     assert_locked_or_safepoint(Threads_lock);
119     do_roots();
120   }
121 
122   bool complete() const {
123     return _complete;
124   }
125 };
126 
127 bool ReferenceToRootClosure::do_cldg_roots() {
128   assert(!complete(), &quot;invariant&quot;);
129   ReferenceLocateClosure rlc(_callback, OldObjectRoot::_class_loader_data, OldObjectRoot::_type_undetermined, NULL);
130   CLDToOopClosure cldt_closure(&amp;rlc, ClassLoaderData::_claim_none);
131   ClassLoaderDataGraph::always_strong_cld_do(&amp;cldt_closure);
132   return rlc.complete();
133 }
134 
135 bool ReferenceToRootClosure::do_object_synchronizer_roots() {
136   assert(!complete(), &quot;invariant&quot;);
137   ReferenceLocateClosure rlc(_callback, OldObjectRoot::_object_synchronizer, OldObjectRoot::_type_undetermined, NULL);
138   ObjectSynchronizer::oops_do(&amp;rlc);
139   return rlc.complete();
140 }
141 
142 bool ReferenceToRootClosure::do_universe_roots() {
143   assert(!complete(), &quot;invariant&quot;);
144   ReferenceLocateClosure rlc(_callback, OldObjectRoot::_universe, OldObjectRoot::_type_undetermined, NULL);
145   Universe::oops_do(&amp;rlc);
146   return rlc.complete();
147 }
148 
149 bool ReferenceToRootClosure::do_jni_handle_roots() {
150   assert(!complete(), &quot;invariant&quot;);
151   ReferenceLocateClosure rlc(_callback, OldObjectRoot::_global_jni_handles, OldObjectRoot::_global_jni_handle, NULL);
152   JNIHandles::oops_do(&amp;rlc);
153   return rlc.complete();
154 }
155 
156 bool ReferenceToRootClosure::do_jvmti_roots() {
157   assert(!complete(), &quot;invariant&quot;);
158   ReferenceLocateClosure rlc(_callback, OldObjectRoot::_jvmti, OldObjectRoot::_global_jni_handle, NULL);
159   JvmtiExport::oops_do(&amp;rlc);
160   return rlc.complete();
161 }
162 
163 bool ReferenceToRootClosure::do_system_dictionary_roots() {
164   assert(!complete(), &quot;invariant&quot;);
165   ReferenceLocateClosure rlc(_callback, OldObjectRoot::_system_dictionary, OldObjectRoot::_type_undetermined, NULL);
166   SystemDictionary::oops_do(&amp;rlc);
167   return rlc.complete();
168 }
169 
170 bool ReferenceToRootClosure::do_management_roots() {
171   assert(!complete(), &quot;invariant&quot;);
172   ReferenceLocateClosure rlc(_callback, OldObjectRoot::_management, OldObjectRoot::_type_undetermined, NULL);
173   Management::oops_do(&amp;rlc);
174   return rlc.complete();
175 }
176 
177 bool ReferenceToRootClosure::do_aot_loader_roots() {
178   assert(!complete(), &quot;invariant&quot;);
179   ReferenceLocateClosure rcl(_callback, OldObjectRoot::_aot, OldObjectRoot::_type_undetermined, NULL);
180   AOTLoader::oops_do(&amp;rcl);
181   return rcl.complete();
182 }
183 
184 bool ReferenceToRootClosure::do_roots() {
185   assert(!complete(), &quot;invariant&quot;);
186   assert(OldObjectRoot::_system_undetermined == _info._system, &quot;invariant&quot;);
187   assert(OldObjectRoot::_type_undetermined == _info._type, &quot;invariant&quot;);
188 
189   if (do_cldg_roots()) {
190     _complete = true;
191     return true;
192   }
193 
194   if (do_object_synchronizer_roots()) {
195    _complete = true;
196     return true;
197   }
198 
199   if (do_universe_roots()) {
200    _complete = true;
201     return true;
202   }
203 
204   if (do_jni_handle_roots()) {
205    _complete = true;
206     return true;
207   }
208 
209   if (do_jvmti_roots()) {
210    _complete = true;
211     return true;
212   }
213 
214   if (do_system_dictionary_roots()) {
215    _complete = true;
216     return true;
217   }
218 
219   if (do_management_roots()) {
220    _complete = true;
221     return true;
222   }
223 
224   if (do_aot_loader_roots()) {
225    _complete = true;
226     return true;
227   }
228 
229   return false;
230 }
231 
232 class ReferenceToThreadRootClosure : public StackObj {
233  private:
234   RootCallback&amp; _callback;
235   bool _complete;
236 
237   bool do_java_threads_oops(JavaThread* jt);
238   bool do_thread_roots(JavaThread* jt);
239   bool do_thread_stack_fast(JavaThread* jt);
240   bool do_thread_stack_detailed(JavaThread* jt);
241   bool do_thread_jni_handles(JavaThread* jt);
242   bool do_thread_handle_area(JavaThread* jt);
243 
244  public:
245   ReferenceToThreadRootClosure(RootCallback&amp; callback) :_callback(callback), _complete(false) {
246     assert_locked_or_safepoint(Threads_lock);
247     JfrJavaThreadIterator iter;
248     while (iter.has_next()) {
249       if (do_thread_roots(iter.next())) {
250         return;
251       }
252     }
253   }
254 
255   bool complete() const {
256     return _complete;
257   }
258 };
259 
260 bool ReferenceToThreadRootClosure::do_thread_handle_area(JavaThread* jt) {
261   assert(jt != NULL, &quot;invariant&quot;);
262   assert(!complete(), &quot;invariant&quot;);
263   ReferenceLocateClosure rcl(_callback, OldObjectRoot::_threads, OldObjectRoot::_handle_area, jt);
264   jt-&gt;handle_area()-&gt;oops_do(&amp;rcl);
265   return rcl.complete();
266 }
267 
268 bool ReferenceToThreadRootClosure::do_thread_jni_handles(JavaThread* jt) {
269   assert(jt != NULL, &quot;invariant&quot;);
270   assert(!complete(), &quot;invariant&quot;);
271 
272   ReferenceLocateClosure rcl(_callback, OldObjectRoot::_threads, OldObjectRoot::_local_jni_handle, jt);
273   jt-&gt;active_handles()-&gt;oops_do(&amp;rcl);
274   return rcl.complete();
275 }
276 
277 bool ReferenceToThreadRootClosure::do_thread_stack_fast(JavaThread* jt) {
278   assert(jt != NULL, &quot;invariant&quot;);
279   assert(!complete(), &quot;invariant&quot;);
280 
281   if (_callback.entries() == 0) {
282     _complete = true;
283     return true;
284   }
285 
286   RootCallbackInfo info;
287   info._high = NULL;
288   info._low = NULL;
289   info._context = jt;
290   info._system = OldObjectRoot::_threads;
291   info._type = OldObjectRoot::_stack_variable;
292 
293   for (int i = 0; i &lt; _callback.entries(); ++i) {
294     const address adr = _callback.at(i).addr&lt;address&gt;();
295     if (jt-&gt;is_in_usable_stack(adr)) {
296       info._high = adr;
297       _complete = _callback.process(info);
298       if (_complete) {
299         return true;
300       }
301     }
302   }
303   assert(!complete(), &quot;invariant&quot;);
304   return false;
305 }
306 
307 bool ReferenceToThreadRootClosure::do_thread_stack_detailed(JavaThread* jt) {
308   assert(jt != NULL, &quot;invariant&quot;);
309   assert(!complete(), &quot;invariant&quot;);
310 
311   ReferenceLocateClosure rcl(_callback, OldObjectRoot::_threads, OldObjectRoot::_stack_variable, jt);
312 
313   if (jt-&gt;has_last_Java_frame()) {
314     // traverse the registered growable array gc_array
315     // can&#39;t do this as it is not reachable from outside
316 
317     // Traverse the monitor chunks
318     MonitorChunk* chunk = jt-&gt;monitor_chunks();
319     for (; chunk != NULL; chunk = chunk-&gt;next()) {
320       chunk-&gt;oops_do(&amp;rcl);
321     }
322 
323     if (rcl.complete()) {
324       return true;
325     }
326 
327     // Traverse the execution stack
328     for (StackFrameStream fst(jt); !fst.is_done(); fst.next()) {
329       fst.current()-&gt;oops_do(&amp;rcl, NULL, fst.register_map());
330     }
331 
332   } // last java frame
333 
334   if (rcl.complete()) {
335     return true;
336   }
337 
338   GrowableArray&lt;jvmtiDeferredLocalVariableSet*&gt;* const list = jt-&gt;deferred_locals();
339   if (list != NULL) {
340     for (int i = 0; i &lt; list-&gt;length(); i++) {
341       list-&gt;at(i)-&gt;oops_do(&amp;rcl);
342     }
343   }
344 
345   if (rcl.complete()) {
346     return true;
347   }
348 
349   // Traverse instance variables at the end since the GC may be moving things
350   // around using this function
351   /*
352   * // can&#39;t reach these oop* from the outside
353   f-&gt;do_oop((oop*) &amp;_threadObj);
354   f-&gt;do_oop((oop*) &amp;_vm_result);
355   f-&gt;do_oop((oop*) &amp;_exception_oop);
356   f-&gt;do_oop((oop*) &amp;_pending_async_exception);
357   */
358 
359   JvmtiThreadState* const jvmti_thread_state = jt-&gt;jvmti_thread_state();
360   if (jvmti_thread_state != NULL) {
361     jvmti_thread_state-&gt;oops_do(&amp;rcl, NULL);
362   }
363 
364   return rcl.complete();
365 }
366 
367 bool ReferenceToThreadRootClosure::do_java_threads_oops(JavaThread* jt) {
368   assert(jt != NULL, &quot;invariant&quot;);
369   assert(!complete(), &quot;invariant&quot;);
370 
371   ReferenceLocateClosure rcl(_callback, OldObjectRoot::_threads, OldObjectRoot::_global_jni_handle, jt);
372   jt-&gt;oops_do(&amp;rcl, NULL);
373   return rcl.complete();
374 }
375 
376 bool ReferenceToThreadRootClosure::do_thread_roots(JavaThread* jt) {
377   assert(jt != NULL, &quot;invariant&quot;);
378 
379   if (do_thread_stack_fast(jt)) {
380     _complete = true;
381     return true;
382   }
383 
384   if (do_thread_jni_handles(jt)) {
385     _complete = true;
386     return true;
387   }
388 
389   if (do_thread_handle_area(jt)) {
390     _complete = true;
391     return true;
392   }
393 
394   if (do_thread_stack_detailed(jt)) {
395     _complete = true;
396     return true;
397   }
398 
399   return false;
400 }
401 
402 class RootResolverMarkScope : public MarkScope {
403 };
404 
405 void RootResolver::resolve(RootCallback&amp; callback) {
406   RootResolverMarkScope mark_scope;
407 
408   // thread local roots
409   ReferenceToThreadRootClosure rtrc(callback);
410   if (rtrc.complete()) {
411     return;
412   }
413   // system global roots
414   ReferenceToRootClosure rrc(callback);
415 }
    </pre>
  </body>
</html>
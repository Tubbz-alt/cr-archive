<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jfr/leakprofiler/chains/bfsClosure.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 #include &quot;precompiled.hpp&quot;
<a name="2" id="anc2"></a><span class="line-modified"> 25 #include &quot;jfr/leakprofiler/chains/bitset.inline.hpp&quot;</span>
 26 #include &quot;jfr/leakprofiler/chains/bfsClosure.hpp&quot;
 27 #include &quot;jfr/leakprofiler/chains/dfsClosure.hpp&quot;
 28 #include &quot;jfr/leakprofiler/chains/edge.hpp&quot;
 29 #include &quot;jfr/leakprofiler/chains/edgeStore.hpp&quot;
 30 #include &quot;jfr/leakprofiler/chains/edgeQueue.hpp&quot;
 31 #include &quot;jfr/leakprofiler/utilities/granularTimer.hpp&quot;
<a name="3" id="anc3"></a><span class="line-modified"> 32 #include &quot;jfr/leakprofiler/utilities/unifiedOopRef.inline.hpp&quot;</span>
 33 #include &quot;logging/log.hpp&quot;
 34 #include &quot;memory/iterator.inline.hpp&quot;
 35 #include &quot;memory/resourceArea.hpp&quot;
 36 #include &quot;oops/access.inline.hpp&quot;
 37 #include &quot;oops/oop.inline.hpp&quot;
 38 #include &quot;utilities/align.hpp&quot;
 39 
 40 BFSClosure::BFSClosure(EdgeQueue* edge_queue, EdgeStore* edge_store, BitSet* mark_bits) :
 41   _edge_queue(edge_queue),
 42   _edge_store(edge_store),
 43   _mark_bits(mark_bits),
 44   _current_parent(NULL),
 45   _current_frontier_level(0),
 46   _next_frontier_idx(0),
 47   _prev_frontier_idx(0),
 48   _dfs_fallback_idx(0),
 49   _use_dfs(false) {
 50 }
 51 
 52 static void log_frontier_level_summary(size_t level,
 53                                        size_t high_idx,
 54                                        size_t low_idx,
 55                                        size_t edge_size) {
 56   const size_t nof_edges_in_frontier = high_idx - low_idx;
 57   log_trace(jfr, system)(
 58       &quot;BFS front: &quot; SIZE_FORMAT &quot; edges: &quot; SIZE_FORMAT &quot; size: &quot; SIZE_FORMAT &quot; [KB]&quot;,
 59       level,
 60       nof_edges_in_frontier,
 61       (nof_edges_in_frontier * edge_size) / K
 62                         );
 63 }
 64 
 65 void BFSClosure::log_completed_frontier() const {
 66   log_frontier_level_summary(_current_frontier_level,
 67                              _next_frontier_idx,
 68                              _prev_frontier_idx,
 69                              _edge_queue-&gt;sizeof_edge());
 70 }
 71 
 72 void BFSClosure::log_dfs_fallback() const {
 73   const size_t edge_size = _edge_queue-&gt;sizeof_edge();
 74   // first complete summary for frontier in progress
 75   log_frontier_level_summary(_current_frontier_level,
 76                              _next_frontier_idx,
 77                              _prev_frontier_idx,
 78                              edge_size);
 79 
 80   // and then also complete the last frontier
 81   log_frontier_level_summary(_current_frontier_level + 1,
 82                              _edge_queue-&gt;bottom(),
 83                              _next_frontier_idx,
 84                              edge_size);
 85 
 86   // additional information about DFS fallover
 87   log_trace(jfr, system)(
 88       &quot;BFS front: &quot; SIZE_FORMAT &quot; filled edge queue at edge: &quot; SIZE_FORMAT,
 89       _current_frontier_level,
 90       _dfs_fallback_idx
 91                         );
 92 
 93   const size_t nof_dfs_completed_edges = _edge_queue-&gt;bottom() - _dfs_fallback_idx;
 94   log_trace(jfr, system)(
 95       &quot;DFS to complete &quot; SIZE_FORMAT &quot; edges size: &quot; SIZE_FORMAT &quot; [KB]&quot;,
 96       nof_dfs_completed_edges,
 97       (nof_dfs_completed_edges * edge_size) / K
 98                         );
 99 }
100 
101 void BFSClosure::process() {
<a name="4" id="anc4"></a>
102   process_root_set();
103   process_queue();
104 }
105 
106 void BFSClosure::process_root_set() {
107   for (size_t idx = _edge_queue-&gt;bottom(); idx &lt; _edge_queue-&gt;top(); ++idx) {
108     const Edge* edge = _edge_queue-&gt;element_at(idx);
109     assert(edge-&gt;parent() == NULL, &quot;invariant&quot;);
110     process(edge-&gt;reference(), edge-&gt;pointee());
111   }
112 }
113 
<a name="5" id="anc5"></a><span class="line-modified">114 void BFSClosure::process(UnifiedOopRef reference, const oop pointee) {</span>
115   closure_impl(reference, pointee);
116 }
<a name="6" id="anc6"></a><span class="line-modified">117 void BFSClosure::closure_impl(UnifiedOopRef reference, const oop pointee) {</span>
<span class="line-modified">118   assert(!reference.is_null(), &quot;invariant&quot;);</span>
<span class="line-modified">119   assert(reference.dereference() == pointee, &quot;invariant&quot;);</span>
120 
121   if (GranularTimer::is_finished()) {
122      return;
123   }
124 
125   if (_use_dfs) {
126     assert(_current_parent != NULL, &quot;invariant&quot;);
127     DFSClosure::find_leaks_from_edge(_edge_store, _mark_bits, _current_parent);
128     return;
129   }
130 
131   if (!_mark_bits-&gt;is_marked(pointee)) {
132     _mark_bits-&gt;mark_obj(pointee);
133     // is the pointee a sample object?
<a name="7" id="anc7"></a><span class="line-modified">134     if (pointee-&gt;mark().is_marked()) {</span>
135       add_chain(reference, pointee);
136     }
137 
138     // if we are processinig initial root set, don&#39;t add to queue
139     if (_current_parent != NULL) {
<a name="8" id="anc8"></a>
140       _edge_queue-&gt;add(_current_parent, reference);
141     }
142 
143     if (_edge_queue-&gt;is_full()) {
144       dfs_fallback();
145     }
146   }
147 }
148 
<a name="9" id="anc9"></a><span class="line-modified">149 void BFSClosure::add_chain(UnifiedOopRef reference, const oop pointee) {</span>
150   assert(pointee != NULL, &quot;invariant&quot;);
<a name="10" id="anc10"></a><span class="line-modified">151   assert(pointee-&gt;mark().is_marked(), &quot;invariant&quot;);</span>
<span class="line-modified">152   Edge leak_edge(_current_parent, reference);</span>
<span class="line-modified">153   _edge_store-&gt;put_chain(&amp;leak_edge, _current_parent == NULL ? 1 : _current_frontier_level + 2);</span>












154 }
155 
156 void BFSClosure::dfs_fallback() {
157   assert(_edge_queue-&gt;is_full(), &quot;invariant&quot;);
158   _use_dfs = true;
159   _dfs_fallback_idx = _edge_queue-&gt;bottom();
160   while (!_edge_queue-&gt;is_empty()) {
161     const Edge* edge = _edge_queue-&gt;remove();
162     if (edge-&gt;pointee() != NULL) {
163       DFSClosure::find_leaks_from_edge(_edge_store, _mark_bits, edge);
164     }
165   }
166 }
167 
168 void BFSClosure::process_queue() {
169   assert(_current_frontier_level == 0, &quot;invariant&quot;);
170   assert(_next_frontier_idx == 0, &quot;invariant&quot;);
171   assert(_prev_frontier_idx == 0, &quot;invariant&quot;);
172 
173   _next_frontier_idx = _edge_queue-&gt;top();
174   while (!is_complete()) {
175     iterate(_edge_queue-&gt;remove()); // edge_queue.remove() increments bottom
176   }
177 }
178 
179 void BFSClosure::step_frontier() const {
180   log_completed_frontier();
181   ++_current_frontier_level;
182   _prev_frontier_idx = _next_frontier_idx;
183   _next_frontier_idx = _edge_queue-&gt;top();
184 }
185 
186 bool BFSClosure::is_complete() const {
187   if (_edge_queue-&gt;bottom() &lt; _next_frontier_idx) {
188     return false;
189   }
190   if (_edge_queue-&gt;bottom() &gt; _next_frontier_idx) {
191     // fallback onto DFS as part of processing the frontier
192     assert(_dfs_fallback_idx &gt;= _prev_frontier_idx, &quot;invariant&quot;);
193     assert(_dfs_fallback_idx &lt; _next_frontier_idx, &quot;invariant&quot;);
194     log_dfs_fallback();
195     return true;
196   }
197   assert(_edge_queue-&gt;bottom() == _next_frontier_idx, &quot;invariant&quot;);
198   if (_edge_queue-&gt;is_empty()) {
199     return true;
200   }
201   step_frontier();
202   return false;
203 }
204 
205 void BFSClosure::iterate(const Edge* parent) {
206   assert(parent != NULL, &quot;invariant&quot;);
207   const oop pointee = parent-&gt;pointee();
208   assert(pointee != NULL, &quot;invariant&quot;);
209   _current_parent = parent;
210   pointee-&gt;oop_iterate(this);
211 }
212 
213 void BFSClosure::do_oop(oop* ref) {
214   assert(ref != NULL, &quot;invariant&quot;);
215   assert(is_aligned(ref, HeapWordSize), &quot;invariant&quot;);
<a name="11" id="anc11"></a><span class="line-modified">216   const oop pointee = HeapAccess&lt;AS_NO_KEEPALIVE&gt;::oop_load(ref);</span>
217   if (pointee != NULL) {
<a name="12" id="anc12"></a><span class="line-modified">218     closure_impl(UnifiedOopRef::encode_in_heap(ref), pointee);</span>
219   }
220 }
221 
222 void BFSClosure::do_oop(narrowOop* ref) {
223   assert(ref != NULL, &quot;invariant&quot;);
224   assert(is_aligned(ref, sizeof(narrowOop)), &quot;invariant&quot;);
<a name="13" id="anc13"></a><span class="line-modified">225   const oop pointee = HeapAccess&lt;AS_NO_KEEPALIVE&gt;::oop_load(ref);</span>
226   if (pointee != NULL) {
<a name="14" id="anc14"></a><span class="line-modified">227     closure_impl(UnifiedOopRef::encode_in_heap(ref), pointee);</span>
<span class="line-added">228   }</span>
<span class="line-added">229 }</span>
<span class="line-added">230 </span>
<span class="line-added">231 void BFSClosure::do_root(UnifiedOopRef ref) {</span>
<span class="line-added">232   assert(!ref.is_null(), &quot;invariant&quot;);</span>
<span class="line-added">233   if (!_edge_queue-&gt;is_full()) {</span>
<span class="line-added">234     _edge_queue-&gt;add(NULL, ref);</span>
235   }
236 }
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
diff a/src/hotspot/share/jfr/leakprofiler/sampling/objectSample.hpp b/src/hotspot/share/jfr/leakprofiler/sampling/objectSample.hpp
--- a/src/hotspot/share/jfr/leakprofiler/sampling/objectSample.hpp
+++ b/src/hotspot/share/jfr/leakprofiler/sampling/objectSample.hpp
@@ -23,17 +23,18 @@
  */
 
 #ifndef SHARE_JFR_LEAKPROFILER_SAMPLING_OBJECTSAMPLE_HPP
 #define SHARE_JFR_LEAKPROFILER_SAMPLING_OBJECTSAMPLE_HPP
 
-#include "jfr/recorder/checkpoint/jfrCheckpointBlob.hpp"
 #include "jfr/utilities/jfrAllocation.hpp"
+#include "jfr/utilities/jfrBlob.hpp"
 #include "jfr/utilities/jfrTime.hpp"
 #include "jfr/utilities/jfrTypes.hpp"
 #include "memory/allocation.hpp"
 #include "oops/oop.hpp"
 #include "utilities/ticks.hpp"
+
 /*
  * Handle for diagnosing Java memory leaks.
  *
  * The class tracks the time the object was
  * allocated, the thread and the stack trace.
@@ -42,58 +43,51 @@
   friend class ObjectSampler;
   friend class SampleList;
  private:
   ObjectSample* _next;
   ObjectSample* _previous;
-  JfrCheckpointBlobHandle _thread_cp;
-  JfrCheckpointBlobHandle _klass_cp;
+  JfrBlobHandle _stacktrace;
+  JfrBlobHandle _thread;
+  JfrBlobHandle _type_set;
   oop _object;
   Ticks _allocation_time;
   traceid _stack_trace_id;
   traceid _thread_id;
   int _index;
   size_t _span;
   size_t _allocated;
   size_t _heap_used_at_last_gc;
   unsigned int _stack_trace_hash;
-  bool _dead;
-
-  void set_dead() {
-    _dead = true;
-  }
 
   void release_references() {
-    if (_thread_cp.valid()) {
-      _thread_cp.~JfrCheckpointBlobHandle();
-    }
-    if (_klass_cp.valid()) {
-      _klass_cp.~JfrCheckpointBlobHandle();
-    }
+    _stacktrace.~JfrBlobHandle();
+    _thread.~JfrBlobHandle();
+    _type_set.~JfrBlobHandle();
   }
 
   void reset() {
+    _object = NULL;
     set_stack_trace_id(0);
-    set_stack_trace_hash(0),
+    set_stack_trace_hash(0);
     release_references();
-    _dead = false;
   }
 
  public:
   ObjectSample() : _next(NULL),
                    _previous(NULL),
-                   _thread_cp(),
-                   _klass_cp(),
+                   _stacktrace(),
+                   _thread(),
+                   _type_set(),
                    _object(NULL),
                    _allocation_time(),
                    _stack_trace_id(0),
                    _thread_id(0),
                    _index(0),
                    _span(0),
                    _allocated(0),
                    _heap_used_at_last_gc(0),
-                   _stack_trace_hash(0),
-                   _dead(false) {}
+                   _stack_trace_hash(0) {}
 
   ObjectSample* next() const {
     return _next;
   }
 
@@ -108,30 +102,20 @@
   void set_prev(ObjectSample* prev) {
     _previous = prev;
   }
 
   bool is_dead() const {
-    return _dead;
+    return object() == NULL;
   }
 
-  const oop object() const {
-    return _object;
-  }
+  const oop object() const;
+  void set_object(oop object);
 
   const oop* object_addr() const {
     return &_object;
   }
 
-  void set_object(oop object) {
-    _object = object;
-  }
-
-  const Klass* klass() const {
-    assert(_object != NULL, "invariant");
-    return _object->klass();
-  }
-
   int index() const {
     return _index;
   }
 
   void set_index(int index) {
@@ -172,11 +156,11 @@
 
   size_t heap_used_at_last_gc() const {
     return _heap_used_at_last_gc;
   }
 
-  bool has_stack_trace() const {
+  bool has_stack_trace_id() const {
     return stack_trace_id() != 0;
   }
 
   traceid stack_trace_id() const {
     return _stack_trace_id;
@@ -192,14 +176,10 @@
 
   void set_stack_trace_hash(unsigned int hash) {
     _stack_trace_hash = hash;
   }
 
-  bool has_thread() const {
-    return _thread_id != 0;
-  }
-
   traceid thread_id() const {
     return _thread_id;
   }
 
   void set_thread_id(traceid id) {
@@ -209,41 +189,55 @@
   bool is_alive_and_older_than(jlong time_stamp) const {
     return !is_dead() && (JfrTime::is_ft_enabled() ?
       _allocation_time.ft_value() : _allocation_time.value()) < time_stamp;
   }
 
-  const JfrCheckpointBlobHandle& thread_checkpoint() const {
-    return _thread_cp;
+  const JfrBlobHandle& stacktrace() const {
+    return _stacktrace;
   }
 
-  bool has_thread_checkpoint() const {
-    return _thread_cp.valid();
+  bool has_stacktrace() const {
+    return _stacktrace.valid();
   }
 
-  // JfrCheckpointBlobHandle assignment operator
+  // JfrBlobHandle assignment operator
   // maintains proper reference counting
-  void set_thread_checkpoint(const JfrCheckpointBlobHandle& ref) {
-    if (_thread_cp != ref) {
-      _thread_cp = ref;
+  void set_stacktrace(const JfrBlobHandle& ref) {
+    if (_stacktrace != ref) {
+      _stacktrace = ref;
+    }
+  }
+
+  const JfrBlobHandle& thread() const {
+    return _thread;
+  }
+
+  bool has_thread() const {
+    return _thread.valid();
+  }
+
+  void set_thread(const JfrBlobHandle& ref) {
+    if (_thread != ref) {
+      _thread = ref;
     }
   }
 
-  const JfrCheckpointBlobHandle& klass_checkpoint() const {
-    return _klass_cp;
+  const JfrBlobHandle& type_set() const {
+    return _type_set;
   }
 
-  bool has_klass_checkpoint() const {
-    return _klass_cp.valid();
+  bool has_type_set() const {
+    return _type_set.valid();
   }
 
-  void set_klass_checkpoint(const JfrCheckpointBlobHandle& ref) {
-    if (_klass_cp != ref) {
-      if (_klass_cp.valid()) {
-        _klass_cp->set_next(ref);
+  void set_type_set(const JfrBlobHandle& ref) {
+    if (_type_set != ref) {
+      if (_type_set.valid()) {
+        _type_set->set_next(ref);
         return;
       }
-      _klass_cp = ref;
+      _type_set = ref;
     }
   }
 };
 
 #endif // SHARE_JFR_LEAKPROFILER_SAMPLING_OBJECTSAMPLE_HPP

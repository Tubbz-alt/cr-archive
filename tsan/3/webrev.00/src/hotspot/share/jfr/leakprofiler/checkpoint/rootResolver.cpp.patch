diff a/src/hotspot/share/jfr/leakprofiler/checkpoint/rootResolver.cpp b/src/hotspot/share/jfr/leakprofiler/checkpoint/rootResolver.cpp
--- a/src/hotspot/share/jfr/leakprofiler/checkpoint/rootResolver.cpp
+++ b/src/hotspot/share/jfr/leakprofiler/checkpoint/rootResolver.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -25,31 +25,31 @@
 #include "precompiled.hpp"
 #include "aot/aotLoader.hpp"
 #include "classfile/classLoaderDataGraph.hpp"
 #include "classfile/stringTable.hpp"
 #include "gc/shared/strongRootsScope.hpp"
-#include "jfr/leakprofiler/utilities/unifiedOop.hpp"
+#include "jfr/leakprofiler/utilities/unifiedOopRef.inline.hpp"
 #include "jfr/leakprofiler/checkpoint/rootResolver.hpp"
+#include "jfr/utilities/jfrThreadIterator.hpp"
 #include "memory/iterator.hpp"
+#include "memory/universe.hpp"
 #include "oops/klass.hpp"
-#include "oops/markOop.hpp"
 #include "oops/oop.hpp"
 #include "prims/jvmtiThreadState.hpp"
 #include "runtime/frame.inline.hpp"
 #include "runtime/mutexLocker.hpp"
-#include "runtime/threadSMR.inline.hpp"
 #include "runtime/vframe_hp.hpp"
 #include "services/management.hpp"
 #include "utilities/growableArray.hpp"
 
 class ReferenceLocateClosure : public OopClosure {
  protected:
   RootCallback& _callback;
   RootCallbackInfo _info;
   bool _complete;
 
-  void do_oop_shared(const void* ref);
+  void do_oop_shared(UnifiedOopRef ref);
 
  public:
   ReferenceLocateClosure(RootCallback& callback,
                          OldObjectRoot::System system,
                          OldObjectRoot::Type type,
@@ -69,24 +69,24 @@
   bool complete() const {
     return _complete;
   }
 };
 
-void ReferenceLocateClosure::do_oop_shared(const void* ref) {
-  assert(ref != NULL, "invariant");
+void ReferenceLocateClosure::do_oop_shared(UnifiedOopRef ref) {
+  assert(!ref.is_null(), "invariant");
   if (!_complete) {
-    _info._high = ref;
+    _info._high = ref.addr<address>();
     _complete = _callback.process(_info);
   }
 }
 
 void ReferenceLocateClosure::do_oop(oop* ref) {
-  do_oop_shared(ref);
+  do_oop_shared(UnifiedOopRef::encode_in_native(ref));
 }
 
 void ReferenceLocateClosure::do_oop(narrowOop* ref) {
-  do_oop_shared(ref);
+  do_oop_shared(UnifiedOopRef::encode_in_native(ref));
 }
 
 class ReferenceToRootClosure : public StackObj {
  private:
   RootCallback& _callback;
@@ -125,11 +125,11 @@
 };
 
 bool ReferenceToRootClosure::do_cldg_roots() {
   assert(!complete(), "invariant");
   ReferenceLocateClosure rlc(_callback, OldObjectRoot::_class_loader_data, OldObjectRoot::_type_undetermined, NULL);
-  CLDToOopClosure cldt_closure(&rlc, ClassLoaderData::_claim_strong);
+  CLDToOopClosure cldt_closure(&rlc, ClassLoaderData::_claim_none);
   ClassLoaderDataGraph::always_strong_cld_do(&cldt_closure);
   return rlc.complete();
 }
 
 bool ReferenceToRootClosure::do_object_synchronizer_roots() {
@@ -172,17 +172,10 @@
   ReferenceLocateClosure rlc(_callback, OldObjectRoot::_management, OldObjectRoot::_type_undetermined, NULL);
   Management::oops_do(&rlc);
   return rlc.complete();
 }
 
-bool ReferenceToRootClosure::do_string_table_roots() {
-  assert(!complete(), "invariant");
-  ReferenceLocateClosure rlc(_callback, OldObjectRoot::_string_table, OldObjectRoot::_type_undetermined, NULL);
-  StringTable::oops_do(&rlc);
-  return rlc.complete();
-}
-
 bool ReferenceToRootClosure::do_aot_loader_roots() {
   assert(!complete(), "invariant");
   ReferenceLocateClosure rcl(_callback, OldObjectRoot::_aot, OldObjectRoot::_type_undetermined, NULL);
   AOTLoader::oops_do(&rcl);
   return rcl.complete();
@@ -226,15 +219,10 @@
   if (do_management_roots()) {
    _complete = true;
     return true;
   }
 
-  if (do_string_table_roots()) {
-   _complete = true;
-    return true;
-  }
-
   if (do_aot_loader_roots()) {
    _complete = true;
     return true;
   }
 
@@ -254,12 +242,13 @@
   bool do_thread_handle_area(JavaThread* jt);
 
  public:
   ReferenceToThreadRootClosure(RootCallback& callback) :_callback(callback), _complete(false) {
     assert_locked_or_safepoint(Threads_lock);
-    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {
-      if (do_thread_roots(jt)) {
+    JfrJavaThreadIterator iter;
+    while (iter.has_next()) {
+      if (do_thread_roots(iter.next())) {
         return;
       }
     }
   }
 
@@ -300,11 +289,11 @@
   info._context = jt;
   info._system = OldObjectRoot::_threads;
   info._type = OldObjectRoot::_stack_variable;
 
   for (int i = 0; i < _callback.entries(); ++i) {
-    const address adr = (address)_callback.at(i);
+    const address adr = _callback.at(i).addr<address>();
     if (jt->is_in_usable_stack(adr)) {
       info._high = adr;
       _complete = _callback.process(info);
       if (_complete) {
         return true;
@@ -367,11 +356,11 @@
   f->do_oop((oop*) &_pending_async_exception);
   */
 
   JvmtiThreadState* const jvmti_thread_state = jt->jvmti_thread_state();
   if (jvmti_thread_state != NULL) {
-    jvmti_thread_state->oops_do(&rcl);
+    jvmti_thread_state->oops_do(&rcl, NULL);
   }
 
   return rcl.complete();
 }
 
@@ -412,13 +401,10 @@
 
 class RootResolverMarkScope : public MarkScope {
 };
 
 void RootResolver::resolve(RootCallback& callback) {
-
-  // Need to clear cld claim bit before starting
-  ClassLoaderDataGraph::clear_claimed_marks();
   RootResolverMarkScope mark_scope;
 
   // thread local roots
   ReferenceToThreadRootClosure rtrc(callback);
   if (rtrc.complete()) {

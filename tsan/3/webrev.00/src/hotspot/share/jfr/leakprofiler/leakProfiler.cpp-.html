<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/jfr/leakprofiler/leakProfiler.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/leakprofiler/emitEventOperation.hpp&quot;
 27 #include &quot;jfr/leakprofiler/leakProfiler.hpp&quot;
 28 #include &quot;jfr/leakprofiler/startOperation.hpp&quot;
 29 #include &quot;jfr/leakprofiler/stopOperation.hpp&quot;
 30 #include &quot;jfr/leakprofiler/sampling/objectSampler.hpp&quot;
 31 #include &quot;jfr/recorder/service/jfrOptionSet.hpp&quot;
 32 #include &quot;memory/iterator.hpp&quot;
 33 #include &quot;oops/oop.hpp&quot;
 34 #include &quot;runtime/atomic.hpp&quot;
 35 #include &quot;runtime/orderAccess.hpp&quot;
 36 #include &quot;runtime/thread.inline.hpp&quot;
 37 #include &quot;runtime/vmThread.hpp&quot;
 38 #include &quot;utilities/ostream.hpp&quot;
 39 
 40 // Only to be updated during safepoint
 41 ObjectSampler* LeakProfiler::_object_sampler = NULL;
 42 
 43 static volatile jbyte suspended = 0;
 44 bool LeakProfiler::start(jint sample_count) {
 45   if (UseZGC) {
 46     log_warning(jfr)(&quot;LeakProfiler is currently not supported in combination with ZGC&quot;);
 47     return false;
 48   }
 49 
 50   if (UseShenandoahGC) {
 51     log_warning(jfr)(&quot;LeakProfiler is currently not supported in combination with Shenandoah GC&quot;);
 52     return false;
 53   }
 54 
 55   if (_object_sampler != NULL) {
 56     // already started
 57     return true;
 58   }
 59   // Allows user to disable leak profiler on command line by setting queue size to zero.
 60   if (sample_count &gt; 0) {
 61     StartOperation op(sample_count);
 62     VMThread::execute(&amp;op);
 63     return _object_sampler != NULL;
 64   }
 65   return false;
 66 }
 67 
 68 bool LeakProfiler::stop() {
 69   if (_object_sampler == NULL) {
 70     // already stopped/not started
 71     return true;
 72   }
 73   StopOperation op;
 74   VMThread::execute(&amp;op);
 75   return _object_sampler == NULL;
 76 }
 77 
 78 void LeakProfiler::emit_events(jlong cutoff_ticks, bool emit_all) {
 79   if (!is_running()) {
 80     return;
 81   }
 82   EmitEventOperation op(cutoff_ticks, emit_all);
 83   VMThread::execute(&amp;op);
 84 }
 85 
 86 void LeakProfiler::oops_do(BoolObjectClosure* is_alive, OopClosure* f) {
 87   assert(SafepointSynchronize::is_at_safepoint(),
 88     &quot;Leak Profiler::oops_do(...) may only be called during safepoint&quot;);
 89 
 90   if (_object_sampler != NULL) {
 91     _object_sampler-&gt;oops_do(is_alive, f);
 92   }
 93 }
 94 
 95 void LeakProfiler::sample(HeapWord* object,
 96                           size_t size,
 97                           JavaThread* thread) {
 98   assert(is_running(), &quot;invariant&quot;);
 99   assert(thread != NULL, &quot;invariant&quot;);
100   assert(thread-&gt;thread_state() == _thread_in_vm, &quot;invariant&quot;);
101 
102   // exclude compiler threads and code sweeper thread
103   if (thread-&gt;is_hidden_from_external_view()) {
104     return;
105   }
106 
107   _object_sampler-&gt;add(object, size, thread);
108 }
109 
110 ObjectSampler* LeakProfiler::object_sampler() {
111   assert(is_suspended() || SafepointSynchronize::is_at_safepoint(),
112     &quot;Leak Profiler::object_sampler() may only be called during safepoint&quot;);
113   return _object_sampler;
114 }
115 
116 void LeakProfiler::set_object_sampler(ObjectSampler* object_sampler) {
117   assert(SafepointSynchronize::is_at_safepoint(),
118     &quot;Leak Profiler::set_object_sampler() may only be called during safepoint&quot;);
119   _object_sampler = object_sampler;
120 }
121 
122 bool LeakProfiler::is_running() {
123   return _object_sampler != NULL &amp;&amp; !suspended;
124 }
125 
126 bool LeakProfiler::is_suspended() {
127   return _object_sampler != NULL &amp;&amp; suspended;
128 }
129 
130 void LeakProfiler::resume() {
131   assert(is_suspended(), &quot;invariant&quot;);
132   OrderAccess::storestore();
133   Atomic::store((jbyte)0, &amp;suspended);
134   assert(is_running(), &quot;invariant&quot;);
135 }
136 
137 void LeakProfiler::suspend() {
138   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
139   assert(_object_sampler != NULL, &quot;invariant&quot;);
140   assert(!is_suspended(), &quot;invariant&quot;);
141   suspended = (jbyte)1; // safepoint visible
142 }
    </pre>
  </body>
</html>
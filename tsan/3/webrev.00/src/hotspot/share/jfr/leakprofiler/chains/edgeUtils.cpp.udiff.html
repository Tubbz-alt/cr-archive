<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/jfr/leakprofiler/chains/edgeUtils.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="edgeStore.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="edgeUtils.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/leakprofiler/chains/edgeUtils.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -25,40 +25,35 @@</span>
  #include &quot;precompiled.hpp&quot;
  #include &quot;classfile/javaClasses.hpp&quot;
  #include &quot;jfr/leakprofiler/chains/edge.hpp&quot;
  #include &quot;jfr/leakprofiler/chains/edgeStore.hpp&quot;
  #include &quot;jfr/leakprofiler/chains/edgeUtils.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;jfr/leakprofiler/utilities/unifiedOop.hpp&quot;</span>
<span class="udiff-line-modified-removed">- #include &quot;oops/fieldStreams.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;jfr/leakprofiler/utilities/unifiedOopRef.inline.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;oops/fieldStreams.inline.hpp&quot;</span>
  #include &quot;oops/instanceKlass.hpp&quot;
  #include &quot;oops/objArrayOop.inline.hpp&quot;
  #include &quot;oops/oopsHierarchy.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  
  bool EdgeUtils::is_leak_edge(const Edge&amp; edge) {
<span class="udiff-line-modified-removed">-   return (const Edge*)edge.pointee()-&gt;mark() == &amp;edge;</span>
<span class="udiff-line-modified-added">+   return (const Edge*)edge.pointee()-&gt;mark().to_pointer() == &amp;edge;</span>
  }
  
<span class="udiff-line-modified-removed">- bool EdgeUtils::is_root(const Edge&amp; edge) {</span>
<span class="udiff-line-removed">-   return edge.is_root();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static int field_offset(const Edge&amp; edge) {</span>
<span class="udiff-line-modified-added">+ static int field_offset(const StoredEdge&amp; edge) {</span>
    assert(!edge.is_root(), &quot;invariant&quot;);
    const oop ref_owner = edge.reference_owner();
    assert(ref_owner != NULL, &quot;invariant&quot;);
<span class="udiff-line-modified-removed">-   const oop* reference = UnifiedOop::decode(edge.reference());</span>
<span class="udiff-line-modified-removed">-   assert(reference != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   assert(!UnifiedOop::is_narrow(reference), &quot;invariant&quot;);</span>
<span class="udiff-line-modified-added">+   UnifiedOopRef reference = edge.reference();</span>
<span class="udiff-line-modified-added">+   assert(!reference.is_null(), &quot;invariant&quot;);</span>
    assert(!ref_owner-&gt;is_array(), &quot;invariant&quot;);
    assert(ref_owner-&gt;is_instance(), &quot;invariant&quot;);
<span class="udiff-line-modified-removed">-   const int offset = (int)pointer_delta(reference, ref_owner, sizeof(char));</span>
<span class="udiff-line-modified-added">+   const int offset = (int)(reference.addr&lt;uintptr_t&gt;() - cast_from_oop&lt;uintptr_t&gt;(ref_owner));</span>
    assert(offset &lt; (ref_owner-&gt;size() * HeapWordSize), &quot;invariant&quot;);
    return offset;
  }
  
<span class="udiff-line-modified-removed">- static const InstanceKlass* field_type(const Edge&amp; edge) {</span>
<span class="udiff-line-modified-added">+ static const InstanceKlass* field_type(const StoredEdge&amp; edge) {</span>
    assert(!edge.is_root() || !EdgeUtils::is_array_element(edge), &quot;invariant&quot;);
    return (const InstanceKlass*)edge.reference_owner_klass();
  }
  
  const Symbol* EdgeUtils::field_name_symbol(const Edge&amp; edge) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -105,16 +100,15 @@</span>
  
  static int array_offset(const Edge&amp; edge) {
    assert(!edge.is_root(), &quot;invariant&quot;);
    const oop ref_owner = edge.reference_owner();
    assert(ref_owner != NULL, &quot;invariant&quot;);
<span class="udiff-line-modified-removed">-   const oop* reference = UnifiedOop::decode(edge.reference());</span>
<span class="udiff-line-modified-removed">-   assert(reference != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   assert(!UnifiedOop::is_narrow(reference), &quot;invariant&quot;);</span>
<span class="udiff-line-modified-added">+   UnifiedOopRef reference = edge.reference();</span>
<span class="udiff-line-modified-added">+   assert(!reference.is_null(), &quot;invariant&quot;);</span>
    assert(ref_owner-&gt;is_array(), &quot;invariant&quot;);
    const objArrayOop ref_owner_array = static_cast&lt;const objArrayOop&gt;(ref_owner);
<span class="udiff-line-modified-removed">-   const int offset = (int)pointer_delta(reference, ref_owner_array-&gt;base(), heapOopSize);</span>
<span class="udiff-line-modified-added">+   const int offset = (int)pointer_delta(reference.addr&lt;HeapWord*&gt;(), ref_owner_array-&gt;base(), heapOopSize);</span>
    assert(offset &gt;= 0 &amp;&amp; offset &lt; ref_owner_array-&gt;length(), &quot;invariant&quot;);
    return offset;
  }
  
  int EdgeUtils::array_index(const Edge&amp; edge) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -124,11 +118,11 @@</span>
  int EdgeUtils::array_size(const Edge&amp; edge) {
    if (is_array_element(edge)) {
      const oop ref_owner = edge.reference_owner();
      assert(ref_owner != NULL, &quot;invariant&quot;);
      assert(ref_owner-&gt;is_objArray(), &quot;invariant&quot;);
<span class="udiff-line-modified-removed">-     return ((objArrayOop)(ref_owner))-&gt;length();</span>
<span class="udiff-line-modified-added">+     return ((objArrayOop)ref_owner)-&gt;length();</span>
    }
    return 0;
  }
  
  const Edge* EdgeUtils::root(const Edge&amp; edge) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -136,177 +130,20 @@</span>
    const Edge* parent = current-&gt;parent();
    while (parent != NULL) {
      current = parent;
      parent = current-&gt;parent();
    }
<span class="udiff-line-added">+   assert(current != NULL, &quot;invariant&quot;);</span>
    return current;
  }
  
<span class="udiff-line-modified-removed">- // The number of references associated with the leak node;</span>
<span class="udiff-line-modified-removed">- // can be viewed as the leak node &quot;context&quot;.</span>
<span class="udiff-line-modified-removed">- // Used to provide leak context for a &quot;capped/skipped&quot; reference chain.</span>
<span class="udiff-line-removed">- static const size_t leak_context = 100;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // The number of references associated with the root node;</span>
<span class="udiff-line-removed">- // can be viewed as the root node &quot;context&quot;.</span>
<span class="udiff-line-removed">- // Used to provide root context for a &quot;capped/skipped&quot; reference chain.</span>
<span class="udiff-line-removed">- static const size_t root_context = 100;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // A limit on the reference chain depth to be serialized,</span>
<span class="udiff-line-removed">- static const size_t max_ref_chain_depth = leak_context + root_context;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- const RoutableEdge* skip_to(const RoutableEdge&amp; edge, size_t skip_length) {</span>
<span class="udiff-line-removed">-   const RoutableEdge* current = &amp;edge;</span>
<span class="udiff-line-removed">-   const RoutableEdge* parent = current-&gt;physical_parent();</span>
<span class="udiff-line-modified-added">+ const Edge* EdgeUtils::ancestor(const Edge&amp; edge, size_t distance) {</span>
<span class="udiff-line-modified-added">+   const Edge* current = &amp;edge;</span>
<span class="udiff-line-modified-added">+   const Edge* parent = current-&gt;parent();</span>
    size_t seek = 0;
<span class="udiff-line-modified-removed">-   while (parent != NULL &amp;&amp; seek != skip_length) {</span>
<span class="udiff-line-modified-added">+   while (parent != NULL &amp;&amp; seek != distance) {</span>
      seek++;
      current = parent;
<span class="udiff-line-modified-removed">-     parent = parent-&gt;physical_parent();</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return current;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">- static void validate_skip_target(const RoutableEdge* skip_target) {</span>
<span class="udiff-line-removed">-   assert(skip_target != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   assert(skip_target-&gt;distance_to_root() + 1 == root_context, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   assert(skip_target-&gt;is_sentinel(), &quot;invariant&quot;);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static void validate_new_skip_edge(const RoutableEdge* new_skip_edge, const RoutableEdge* last_skip_edge, size_t adjustment) {</span>
<span class="udiff-line-removed">-   assert(new_skip_edge != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   assert(new_skip_edge-&gt;is_skip_edge(), &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   if (last_skip_edge != NULL) {</span>
<span class="udiff-line-removed">-     const RoutableEdge* const target = skip_to(*new_skip_edge-&gt;logical_parent(), adjustment);</span>
<span class="udiff-line-removed">-     validate_skip_target(target-&gt;logical_parent());</span>
<span class="udiff-line-removed">-     return;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   assert(last_skip_edge == NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   // only one level of logical indirection</span>
<span class="udiff-line-removed">-   validate_skip_target(new_skip_edge-&gt;logical_parent());</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- #endif // ASSERT</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static void install_logical_route(const RoutableEdge* new_skip_edge, size_t skip_target_distance) {</span>
<span class="udiff-line-removed">-   assert(new_skip_edge != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   assert(!new_skip_edge-&gt;is_skip_edge(), &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   assert(!new_skip_edge-&gt;processed(), &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   const RoutableEdge* const skip_target = skip_to(*new_skip_edge, skip_target_distance);</span>
<span class="udiff-line-removed">-   assert(skip_target != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   new_skip_edge-&gt;set_skip_edge(skip_target);</span>
<span class="udiff-line-removed">-   new_skip_edge-&gt;set_skip_length(skip_target_distance);</span>
<span class="udiff-line-removed">-   assert(new_skip_edge-&gt;is_skip_edge(), &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   assert(new_skip_edge-&gt;logical_parent() == skip_target, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static const RoutableEdge* find_last_skip_edge(const RoutableEdge&amp; edge, size_t&amp; distance) {</span>
<span class="udiff-line-removed">-   assert(distance == 0, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   const RoutableEdge* current = &amp;edge;</span>
<span class="udiff-line-removed">-   while (current != NULL) {</span>
<span class="udiff-line-removed">-     if (current-&gt;is_skip_edge() &amp;&amp; current-&gt;skip_edge()-&gt;is_sentinel()) {</span>
<span class="udiff-line-removed">-       return current;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     current = current-&gt;physical_parent();</span>
<span class="udiff-line-removed">-     ++distance;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return current;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static void collapse_overlapping_chain(const RoutableEdge&amp; edge,</span>
<span class="udiff-line-removed">-                                        const RoutableEdge* first_processed_edge,</span>
<span class="udiff-line-removed">-                                        size_t first_processed_distance) {</span>
<span class="udiff-line-removed">-   assert(first_processed_edge != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   // first_processed_edge is already processed / written</span>
<span class="udiff-line-removed">-   assert(first_processed_edge-&gt;processed(), &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   assert(first_processed_distance + 1 &lt;= leak_context, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // from this first processed edge, attempt to fetch the last skip edge</span>
<span class="udiff-line-removed">-   size_t last_skip_edge_distance = 0;</span>
<span class="udiff-line-removed">-   const RoutableEdge* const last_skip_edge = find_last_skip_edge(*first_processed_edge, last_skip_edge_distance);</span>
<span class="udiff-line-removed">-   const size_t distance_discovered = first_processed_distance + last_skip_edge_distance + 1;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (distance_discovered &lt;= leak_context || (last_skip_edge == NULL &amp;&amp; distance_discovered &lt;= max_ref_chain_depth)) {</span>
<span class="udiff-line-removed">-     // complete chain can be accommodated without modification</span>
<span class="udiff-line-removed">-     return;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // backtrack one edge from existing processed edge</span>
<span class="udiff-line-removed">-   const RoutableEdge* const new_skip_edge = skip_to(edge, first_processed_distance - 1);</span>
<span class="udiff-line-removed">-   assert(new_skip_edge != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   assert(!new_skip_edge-&gt;processed(), &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   assert(new_skip_edge-&gt;parent() == first_processed_edge, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   size_t adjustment = 0;</span>
<span class="udiff-line-removed">-   if (last_skip_edge != NULL) {</span>
<span class="udiff-line-removed">-     assert(leak_context - 1 &gt; first_processed_distance - 1, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-     adjustment = leak_context - first_processed_distance - 1;</span>
<span class="udiff-line-removed">-     assert(last_skip_edge_distance + 1 &gt; adjustment, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-     install_logical_route(new_skip_edge, last_skip_edge_distance + 1 - adjustment);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     install_logical_route(new_skip_edge, last_skip_edge_distance + 1 - root_context);</span>
<span class="udiff-line-removed">-     new_skip_edge-&gt;logical_parent()-&gt;set_skip_length(1); // sentinel</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   DEBUG_ONLY(validate_new_skip_edge(new_skip_edge, last_skip_edge, adjustment);)</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static void collapse_non_overlapping_chain(const RoutableEdge&amp; edge,</span>
<span class="udiff-line-removed">-                                            const RoutableEdge* first_processed_edge,</span>
<span class="udiff-line-removed">-                                            size_t first_processed_distance) {</span>
<span class="udiff-line-removed">-   assert(first_processed_edge != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   assert(!first_processed_edge-&gt;processed(), &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   // this implies that the first &quot;processed&quot; edge is the leak context relative &quot;leaf&quot;</span>
<span class="udiff-line-removed">-   assert(first_processed_distance + 1 == leak_context, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   const size_t distance_to_root = edge.distance_to_root();</span>
<span class="udiff-line-removed">-   if (distance_to_root + 1 &lt;= max_ref_chain_depth) {</span>
<span class="udiff-line-removed">-     // complete chain can be accommodated without constructing a skip edge</span>
<span class="udiff-line-removed">-     return;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   install_logical_route(first_processed_edge, distance_to_root + 1 - first_processed_distance - root_context);</span>
<span class="udiff-line-removed">-   first_processed_edge-&gt;logical_parent()-&gt;set_skip_length(1); // sentinel</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   DEBUG_ONLY(validate_new_skip_edge(first_processed_edge, NULL, 0);)</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static const RoutableEdge* processed_edge(const RoutableEdge&amp; edge, size_t&amp; distance) {</span>
<span class="udiff-line-removed">-   assert(distance == 0, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   const RoutableEdge* current = &amp;edge;</span>
<span class="udiff-line-removed">-   while (current != NULL &amp;&amp; distance &lt; leak_context - 1) {</span>
<span class="udiff-line-removed">-     if (current-&gt;processed()) {</span>
<span class="udiff-line-removed">-       return current;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     current = current-&gt;physical_parent();</span>
<span class="udiff-line-removed">-     ++distance;</span>
<span class="udiff-line-modified-added">+     parent = parent-&gt;parent();</span>
    }
<span class="udiff-line-removed">-   assert(distance &lt;= leak_context - 1, &quot;invariant&quot;);</span>
    return current;
  }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- /*</span>
<span class="udiff-line-removed">-  * Some vocabulary:</span>
<span class="udiff-line-removed">-  * -----------</span>
<span class="udiff-line-removed">-  * &quot;Context&quot; is an interval in the chain, it is associcated with an edge and it signifies a number of connected edges.</span>
<span class="udiff-line-removed">-  * &quot;Processed / written&quot; means an edge that has already been serialized.</span>
<span class="udiff-line-removed">-  * &quot;Skip edge&quot; is an edge that contains additional information for logical routing purposes.</span>
<span class="udiff-line-removed">-  * &quot;Skip target&quot; is an edge used as a destination for a skip edge</span>
<span class="udiff-line-removed">-  */</span>
<span class="udiff-line-removed">- void EdgeUtils::collapse_chain(const RoutableEdge&amp; edge) {</span>
<span class="udiff-line-removed">-   assert(is_leak_edge(edge), &quot;invariant&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // attempt to locate an already processed edge inside current leak context (if any)</span>
<span class="udiff-line-removed">-   size_t first_processed_distance = 0;</span>
<span class="udiff-line-removed">-   const RoutableEdge* const first_processed_edge = processed_edge(edge, first_processed_distance);</span>
<span class="udiff-line-removed">-   if (first_processed_edge == NULL) {</span>
<span class="udiff-line-removed">-     return;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (first_processed_edge-&gt;processed()) {</span>
<span class="udiff-line-removed">-     collapse_overlapping_chain(edge, first_processed_edge, first_processed_distance);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     collapse_non_overlapping_chain(edge, first_processed_edge, first_processed_distance);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   assert(edge.logical_distance_to_root() + 1 &lt;= max_ref_chain_depth, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">- }</span>
</pre>
<center><a href="edgeStore.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="edgeUtils.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
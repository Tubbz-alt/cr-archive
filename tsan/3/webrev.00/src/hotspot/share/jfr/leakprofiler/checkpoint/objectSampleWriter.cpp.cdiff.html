<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/jfr/leakprofiler/checkpoint/objectSampleWriter.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="objectSampleDescription.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="objectSampleWriter.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/leakprofiler/checkpoint/objectSampleWriter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 30,13 ***</span>
  #include &quot;jfr/leakprofiler/checkpoint/objectSampleDescription.hpp&quot;
  #include &quot;jfr/leakprofiler/checkpoint/objectSampleWriter.hpp&quot;
  #include &quot;jfr/leakprofiler/checkpoint/rootResolver.hpp&quot;
  #include &quot;jfr/leakprofiler/sampling/objectSampler.hpp&quot;
  #include &quot;jfr/leakprofiler/utilities/rootType.hpp&quot;
<span class="line-modified">! #include &quot;jfr/leakprofiler/utilities/unifiedOop.hpp&quot;</span>
<span class="line-modified">! #include &quot;jfr/recorder/checkpoint/types/jfrTypeSetUtils.hpp&quot;</span>
<span class="line-modified">! #include &quot;jfr/recorder/checkpoint/types/jfrTypeSetWriter.hpp&quot;</span>
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/symbol.hpp&quot;
  #include &quot;utilities/growableArray.hpp&quot;
  
  template &lt;typename Data&gt;
<span class="line-new-header">--- 30,13 ---</span>
  #include &quot;jfr/leakprofiler/checkpoint/objectSampleDescription.hpp&quot;
  #include &quot;jfr/leakprofiler/checkpoint/objectSampleWriter.hpp&quot;
  #include &quot;jfr/leakprofiler/checkpoint/rootResolver.hpp&quot;
  #include &quot;jfr/leakprofiler/sampling/objectSampler.hpp&quot;
  #include &quot;jfr/leakprofiler/utilities/rootType.hpp&quot;
<span class="line-modified">! #include &quot;jfr/leakprofiler/utilities/unifiedOopRef.inline.hpp&quot;</span>
<span class="line-modified">! #include &quot;jfr/metadata/jfrSerializer.hpp&quot;</span>
<span class="line-modified">! #include &quot;jfr/writers/jfrTypeWriterHost.hpp&quot;</span>
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/symbol.hpp&quot;
  #include &quot;utilities/growableArray.hpp&quot;
  
  template &lt;typename Data&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 135,43 ***</span>
              typename,
              template&lt;typename, typename&gt; class,
              typename,
              size_t&gt;
    friend class HashTableHost;
<span class="line-modified">!   typedef HashTableHost&lt;const ObjectSampleFieldInfo*, traceid, Entry, FieldTable, 109&gt; FieldInfoTable;</span>
   public:
    typedef FieldInfoTable::HashEntry FieldInfoEntry;
  
   private:
    static traceid _field_id_counter;
    FieldInfoTable* _table;
  
<span class="line-modified">!   void assign_id(FieldInfoEntry* entry) {</span>
      assert(entry != NULL, &quot;invariant&quot;);
      entry-&gt;set_id(++_field_id_counter);
    }
  
<span class="line-modified">!   bool equals(const ObjectSampleFieldInfo* query, uintptr_t hash, const FieldInfoEntry* entry) {</span>
      assert(hash == entry-&gt;hash(), &quot;invariant&quot;);
<span class="line-modified">!     assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!     const ObjectSampleFieldInfo* stored = entry-&gt;literal();</span>
<span class="line-modified">!     assert(stored != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!     assert(stored-&gt;_field_name_symbol-&gt;identity_hash() == query-&gt;_field_name_symbol-&gt;identity_hash(), &quot;invariant&quot;);</span>
<span class="line-modified">!     return stored-&gt;_field_modifiers == query-&gt;_field_modifiers;</span>
    }
  
   public:
<span class="line-modified">!   FieldTable() : _table(new FieldInfoTable(this)) {}</span>
    ~FieldTable() {
      assert(_table != NULL, &quot;invariant&quot;);
      delete _table;
    }
  
    traceid store(const ObjectSampleFieldInfo* field_info) {
      assert(field_info != NULL, &quot;invariant&quot;);
<span class="line-modified">!     const FieldInfoEntry&amp; entry =_table-&gt;lookup_put(field_info,</span>
<span class="line-modified">!                                                     field_info-&gt;_field_name_symbol-&gt;identity_hash());</span>
      return entry.id();
    }
  
    size_t size() const {
      return _table-&gt;cardinality();
<span class="line-new-header">--- 135,46 ---</span>
              typename,
              template&lt;typename, typename&gt; class,
              typename,
              size_t&gt;
    friend class HashTableHost;
<span class="line-modified">!   typedef HashTableHost&lt;const ObjectSampleFieldInfo*, traceid, JfrHashtableEntry, FieldTable, 109&gt; FieldInfoTable;</span>
   public:
    typedef FieldInfoTable::HashEntry FieldInfoEntry;
  
   private:
    static traceid _field_id_counter;
    FieldInfoTable* _table;
<span class="line-added">+   const ObjectSampleFieldInfo* _lookup;</span>
  
<span class="line-modified">!   void on_link(FieldInfoEntry* entry) {</span>
      assert(entry != NULL, &quot;invariant&quot;);
      entry-&gt;set_id(++_field_id_counter);
    }
  
<span class="line-modified">!   bool on_equals(uintptr_t hash, const FieldInfoEntry* entry) {</span>
      assert(hash == entry-&gt;hash(), &quot;invariant&quot;);
<span class="line-modified">!     assert(_lookup != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!     return entry-&gt;literal()-&gt;_field_modifiers == _lookup-&gt;_field_modifiers;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   void on_unlink(FieldInfoEntry* entry) {</span>
<span class="line-added">+     assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+     // nothing</span>
    }
  
   public:
<span class="line-modified">!   FieldTable() : _table(new FieldInfoTable(this)), _lookup(NULL) {}</span>
    ~FieldTable() {
      assert(_table != NULL, &quot;invariant&quot;);
      delete _table;
    }
  
    traceid store(const ObjectSampleFieldInfo* field_info) {
      assert(field_info != NULL, &quot;invariant&quot;);
<span class="line-modified">!     _lookup = field_info;</span>
<span class="line-modified">!     const FieldInfoEntry&amp; entry = _table-&gt;lookup_put(field_info-&gt;_field_name_symbol-&gt;identity_hash(), field_info);</span>
      return entry.id();
    }
  
    size_t size() const {
      return _table-&gt;cardinality();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 194,36 ***</span>
  static RefInfo* ref_infos = NULL;
  static ArrayInfo* array_infos = NULL;
  static FieldTable* field_infos = NULL;
  static RootDescriptionInfo* root_infos = NULL;
  
<span class="line-modified">! int __write_sample_info__(JfrCheckpointWriter* writer, JfrArtifactSet* unused, const void* si) {</span>
    assert(writer != NULL, &quot;invariant&quot;);
    assert(si != NULL, &quot;invariant&quot;);
    const OldObjectSampleInfo* const oosi = (const OldObjectSampleInfo*)si;
    oop object = oosi-&gt;_data._object;
    assert(object != NULL, &quot;invariant&quot;);
    writer-&gt;write(oosi-&gt;_id);
<span class="line-modified">!   writer-&gt;write((u8)(const HeapWord*)object);</span>
    writer-&gt;write(const_cast&lt;const Klass*&gt;(object-&gt;klass()));
    ObjectSampleDescription od(object);
    writer-&gt;write(od.description());
    writer-&gt;write(oosi-&gt;_data._reference_id);
    return 1;
  }
  
<span class="line-modified">! typedef JfrArtifactWriterImplHost&lt;const OldObjectSampleInfo*, __write_sample_info__&gt; SampleWriterImpl;</span>
<span class="line-modified">! typedef JfrArtifactWriterHost&lt;SampleWriterImpl, TYPE_OLDOBJECT&gt; SampleWriter;</span>
  
  static void write_sample_infos(JfrCheckpointWriter&amp; writer) {
    if (sample_infos != NULL) {
<span class="line-modified">!     SampleWriter sw(&amp;writer, NULL, false);</span>
      sample_infos-&gt;iterate(sw);
    }
  }
  
<span class="line-modified">! int __write_reference_info__(JfrCheckpointWriter* writer, JfrArtifactSet* unused, const void* ri) {</span>
    assert(writer != NULL, &quot;invariant&quot;);
    assert(ri != NULL, &quot;invariant&quot;);
    const ReferenceInfo* const ref_info = (const ReferenceInfo*)ri;
    writer-&gt;write(ref_info-&gt;_id);
    writer-&gt;write(ref_info-&gt;_data._array_info_id);
<span class="line-new-header">--- 197,36 ---</span>
  static RefInfo* ref_infos = NULL;
  static ArrayInfo* array_infos = NULL;
  static FieldTable* field_infos = NULL;
  static RootDescriptionInfo* root_infos = NULL;
  
<span class="line-modified">! int __write_sample_info__(JfrCheckpointWriter* writer, const void* si) {</span>
    assert(writer != NULL, &quot;invariant&quot;);
    assert(si != NULL, &quot;invariant&quot;);
    const OldObjectSampleInfo* const oosi = (const OldObjectSampleInfo*)si;
    oop object = oosi-&gt;_data._object;
    assert(object != NULL, &quot;invariant&quot;);
    writer-&gt;write(oosi-&gt;_id);
<span class="line-modified">!   writer-&gt;write(cast_from_oop&lt;u8&gt;(object));</span>
    writer-&gt;write(const_cast&lt;const Klass*&gt;(object-&gt;klass()));
    ObjectSampleDescription od(object);
    writer-&gt;write(od.description());
    writer-&gt;write(oosi-&gt;_data._reference_id);
    return 1;
  }
  
<span class="line-modified">! typedef JfrTypeWriterImplHost&lt;const OldObjectSampleInfo*, __write_sample_info__&gt; SampleWriterImpl;</span>
<span class="line-modified">! typedef JfrTypeWriterHost&lt;SampleWriterImpl, TYPE_OLDOBJECT&gt; SampleWriter;</span>
  
  static void write_sample_infos(JfrCheckpointWriter&amp; writer) {
    if (sample_infos != NULL) {
<span class="line-modified">!     SampleWriter sw(&amp;writer);</span>
      sample_infos-&gt;iterate(sw);
    }
  }
  
<span class="line-modified">! int __write_reference_info__(JfrCheckpointWriter* writer, const void* ri) {</span>
    assert(writer != NULL, &quot;invariant&quot;);
    assert(ri != NULL, &quot;invariant&quot;);
    const ReferenceInfo* const ref_info = (const ReferenceInfo*)ri;
    writer-&gt;write(ref_info-&gt;_id);
    writer-&gt;write(ref_info-&gt;_data._array_info_id);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 231,21 ***</span>
    writer-&gt;write(ref_info-&gt;_data._old_object_sample_id);
    writer-&gt;write&lt;s4&gt;((s4)ref_info-&gt;_data._skip);
    return 1;
  }
  
<span class="line-modified">! typedef JfrArtifactWriterImplHost&lt;const ReferenceInfo*, __write_reference_info__&gt; ReferenceWriterImpl;</span>
<span class="line-modified">! typedef JfrArtifactWriterHost&lt;ReferenceWriterImpl, TYPE_REFERENCE&gt; ReferenceWriter;</span>
  
  static void write_reference_infos(JfrCheckpointWriter&amp; writer) {
    if (ref_infos != NULL) {
<span class="line-modified">!     ReferenceWriter rw(&amp;writer, NULL, false);</span>
      ref_infos-&gt;iterate(rw);
    }
  }
  
<span class="line-modified">! int __write_array_info__(JfrCheckpointWriter* writer, JfrArtifactSet* unused, const void* ai) {</span>
    assert(writer != NULL, &quot;invariant&quot;);
    assert(ai != NULL, &quot;invariant&quot;);
    const ObjectSampleArrayInfo* const osai = (const ObjectSampleArrayInfo*)ai;
    writer-&gt;write(osai-&gt;_id);
    writer-&gt;write(osai-&gt;_data._array_size);
<span class="line-new-header">--- 234,21 ---</span>
    writer-&gt;write(ref_info-&gt;_data._old_object_sample_id);
    writer-&gt;write&lt;s4&gt;((s4)ref_info-&gt;_data._skip);
    return 1;
  }
  
<span class="line-modified">! typedef JfrTypeWriterImplHost&lt;const ReferenceInfo*, __write_reference_info__&gt; ReferenceWriterImpl;</span>
<span class="line-modified">! typedef JfrTypeWriterHost&lt;ReferenceWriterImpl, TYPE_REFERENCE&gt; ReferenceWriter;</span>
  
  static void write_reference_infos(JfrCheckpointWriter&amp; writer) {
    if (ref_infos != NULL) {
<span class="line-modified">!     ReferenceWriter rw(&amp;writer);</span>
      ref_infos-&gt;iterate(rw);
    }
  }
  
<span class="line-modified">! int __write_array_info__(JfrCheckpointWriter* writer, const void* ai) {</span>
    assert(writer != NULL, &quot;invariant&quot;);
    assert(ai != NULL, &quot;invariant&quot;);
    const ObjectSampleArrayInfo* const osai = (const ObjectSampleArrayInfo*)ai;
    writer-&gt;write(osai-&gt;_id);
    writer-&gt;write(osai-&gt;_data._array_size);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 268,21 ***</span>
    osai-&gt;_data._array_size = EdgeUtils::array_size(edge);
    osai-&gt;_data._array_index = EdgeUtils::array_index(edge);
    return array_infos-&gt;store(osai);
  }
  
<span class="line-modified">! typedef JfrArtifactWriterImplHost&lt;const ObjectSampleArrayInfo*, __write_array_info__&gt; ArrayWriterImpl;</span>
<span class="line-modified">! typedef JfrArtifactWriterHost&lt;ArrayWriterImpl, TYPE_OLDOBJECTARRAY&gt; ArrayWriter;</span>
  
  static void write_array_infos(JfrCheckpointWriter&amp; writer) {
    if (array_infos != NULL) {
<span class="line-modified">!     ArrayWriter aw(&amp;writer, NULL, false);</span>
      array_infos-&gt;iterate(aw);
    }
  }
  
<span class="line-modified">! int __write_field_info__(JfrCheckpointWriter* writer, JfrArtifactSet* unused, const void* fi) {</span>
    assert(writer != NULL, &quot;invariant&quot;);
    assert(fi != NULL, &quot;invariant&quot;);
    const FieldTable::FieldInfoEntry* field_info_entry = (const FieldTable::FieldInfoEntry*)fi;
    writer-&gt;write(field_info_entry-&gt;id());
    const ObjectSampleFieldInfo* const osfi = field_info_entry-&gt;literal();
<span class="line-new-header">--- 271,21 ---</span>
    osai-&gt;_data._array_size = EdgeUtils::array_size(edge);
    osai-&gt;_data._array_index = EdgeUtils::array_index(edge);
    return array_infos-&gt;store(osai);
  }
  
<span class="line-modified">! typedef JfrTypeWriterImplHost&lt;const ObjectSampleArrayInfo*, __write_array_info__&gt; ArrayWriterImpl;</span>
<span class="line-modified">! typedef JfrTypeWriterHost&lt;ArrayWriterImpl, TYPE_OLDOBJECTARRAY&gt; ArrayWriter;</span>
  
  static void write_array_infos(JfrCheckpointWriter&amp; writer) {
    if (array_infos != NULL) {
<span class="line-modified">!     ArrayWriter aw(&amp;writer);</span>
      array_infos-&gt;iterate(aw);
    }
  }
  
<span class="line-modified">! int __write_field_info__(JfrCheckpointWriter* writer, const void* fi) {</span>
    assert(writer != NULL, &quot;invariant&quot;);
    assert(fi != NULL, &quot;invariant&quot;);
    const FieldTable::FieldInfoEntry* field_info_entry = (const FieldTable::FieldInfoEntry*)fi;
    writer-&gt;write(field_info_entry-&gt;id());
    const ObjectSampleFieldInfo* const osfi = field_info_entry-&gt;literal();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 312,16 ***</span>
    osfi-&gt;_field_name_symbol = field_name_symbol;
    osfi-&gt;_field_modifiers = EdgeUtils::field_modifiers(edge);
    return field_infos-&gt;store(osfi);
  }
  
<span class="line-modified">! typedef JfrArtifactWriterImplHost&lt;const FieldTable::FieldInfoEntry*, __write_field_info__&gt; FieldWriterImpl;</span>
<span class="line-modified">! typedef JfrArtifactWriterHost&lt;FieldWriterImpl, TYPE_OLDOBJECTFIELD&gt; FieldWriter;</span>
  
  static void write_field_infos(JfrCheckpointWriter&amp; writer) {
    if (field_infos != NULL) {
<span class="line-modified">!     FieldWriter fw(&amp;writer, NULL, false);</span>
      field_infos-&gt;iterate(fw);
    }
  }
  
  static const char* description(const ObjectSampleRootDescriptionInfo* osdi) {
<span class="line-new-header">--- 315,16 ---</span>
    osfi-&gt;_field_name_symbol = field_name_symbol;
    osfi-&gt;_field_modifiers = EdgeUtils::field_modifiers(edge);
    return field_infos-&gt;store(osfi);
  }
  
<span class="line-modified">! typedef JfrTypeWriterImplHost&lt;const FieldTable::FieldInfoEntry*, __write_field_info__&gt; FieldWriterImpl;</span>
<span class="line-modified">! typedef JfrTypeWriterHost&lt;FieldWriterImpl, TYPE_OLDOBJECTFIELD&gt; FieldWriter;</span>
  
  static void write_field_infos(JfrCheckpointWriter&amp; writer) {
    if (field_infos != NULL) {
<span class="line-modified">!     FieldWriter fw(&amp;writer);</span>
      field_infos-&gt;iterate(fw);
    }
  }
  
  static const char* description(const ObjectSampleRootDescriptionInfo* osdi) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 337,48 ***</span>
    }
    description.write_text(osdi-&gt;_data._description);
    return description.description();
  }
  
<span class="line-modified">! int __write_root_description_info__(JfrCheckpointWriter* writer, JfrArtifactSet* unused, const void* di) {</span>
    assert(writer != NULL, &quot;invariant&quot;);
    assert(di != NULL, &quot;invariant&quot;);
    const ObjectSampleRootDescriptionInfo* const osdi = (const ObjectSampleRootDescriptionInfo*)di;
    writer-&gt;write(osdi-&gt;_id);
    writer-&gt;write(description(osdi));
    writer-&gt;write&lt;u8&gt;(osdi-&gt;_data._system);
    writer-&gt;write&lt;u8&gt;(osdi-&gt;_data._type);
    return 1;
  }
  
<span class="line-modified">! static traceid get_root_description_info_id(const Edge&amp; edge, traceid id) {</span>
    assert(edge.is_root(), &quot;invariant&quot;);
<span class="line-removed">-   if (EdgeUtils::is_leak_edge(edge)) {</span>
<span class="line-removed">-     return 0;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    if (root_infos == NULL) {
      root_infos = new RootDescriptionInfo();
    }
    assert(root_infos != NULL, &quot;invariant&quot;);
    ObjectSampleRootDescriptionInfo* const oodi = new ObjectSampleRootDescriptionInfo();
    oodi-&gt;_id = id;
    oodi-&gt;_data._root_edge = &amp;edge;
    return root_infos-&gt;store(oodi);
  }
  
<span class="line-modified">! typedef JfrArtifactWriterImplHost&lt;const ObjectSampleRootDescriptionInfo*, __write_root_description_info__&gt; RootDescriptionWriterImpl;</span>
<span class="line-modified">! typedef JfrArtifactWriterHost&lt;RootDescriptionWriterImpl, TYPE_OLDOBJECTGCROOT&gt; RootDescriptionWriter;</span>
  
  
  int _edge_reference_compare_(uintptr_t lhs, uintptr_t rhs) {
    return lhs &gt; rhs ? 1 : (lhs &lt; rhs) ? -1 : 0;
  }
  
  int _root_desc_compare_(const ObjectSampleRootDescriptionInfo*const &amp; lhs, const ObjectSampleRootDescriptionInfo* const&amp; rhs) {
<span class="line-modified">!   const uintptr_t lhs_ref = (uintptr_t)lhs-&gt;_data._root_edge-&gt;reference();</span>
<span class="line-modified">!   const uintptr_t rhs_ref = (uintptr_t)rhs-&gt;_data._root_edge-&gt;reference();</span>
    return _edge_reference_compare_(lhs_ref, rhs_ref);
  }
  
  static int find_sorted(const RootCallbackInfo&amp; callback_info,
                         const GrowableArray&lt;const ObjectSampleRootDescriptionInfo*&gt;* arr,
<span class="line-new-header">--- 340,44 ---</span>
    }
    description.write_text(osdi-&gt;_data._description);
    return description.description();
  }
  
<span class="line-modified">! int __write_root_description_info__(JfrCheckpointWriter* writer, const void* di) {</span>
    assert(writer != NULL, &quot;invariant&quot;);
    assert(di != NULL, &quot;invariant&quot;);
    const ObjectSampleRootDescriptionInfo* const osdi = (const ObjectSampleRootDescriptionInfo*)di;
    writer-&gt;write(osdi-&gt;_id);
    writer-&gt;write(description(osdi));
    writer-&gt;write&lt;u8&gt;(osdi-&gt;_data._system);
    writer-&gt;write&lt;u8&gt;(osdi-&gt;_data._type);
    return 1;
  }
  
<span class="line-modified">! static traceid get_gc_root_description_info_id(const Edge&amp; edge, traceid id) {</span>
    assert(edge.is_root(), &quot;invariant&quot;);
    if (root_infos == NULL) {
      root_infos = new RootDescriptionInfo();
    }
    assert(root_infos != NULL, &quot;invariant&quot;);
    ObjectSampleRootDescriptionInfo* const oodi = new ObjectSampleRootDescriptionInfo();
    oodi-&gt;_id = id;
    oodi-&gt;_data._root_edge = &amp;edge;
    return root_infos-&gt;store(oodi);
  }
  
<span class="line-modified">! typedef JfrTypeWriterImplHost&lt;const ObjectSampleRootDescriptionInfo*, __write_root_description_info__&gt; RootDescriptionWriterImpl;</span>
<span class="line-modified">! typedef JfrTypeWriterHost&lt;RootDescriptionWriterImpl, TYPE_OLDOBJECTGCROOT&gt; RootDescriptionWriter;</span>
  
  
  int _edge_reference_compare_(uintptr_t lhs, uintptr_t rhs) {
    return lhs &gt; rhs ? 1 : (lhs &lt; rhs) ? -1 : 0;
  }
  
  int _root_desc_compare_(const ObjectSampleRootDescriptionInfo*const &amp; lhs, const ObjectSampleRootDescriptionInfo* const&amp; rhs) {
<span class="line-modified">!   const uintptr_t lhs_ref = lhs-&gt;_data._root_edge-&gt;reference().addr&lt;uintptr_t&gt;();</span>
<span class="line-modified">!   const uintptr_t rhs_ref = rhs-&gt;_data._root_edge-&gt;reference().addr&lt;uintptr_t&gt;();</span>
    return _edge_reference_compare_(lhs_ref, rhs_ref);
  }
  
  static int find_sorted(const RootCallbackInfo&amp; callback_info,
                         const GrowableArray&lt;const ObjectSampleRootDescriptionInfo*&gt;* arr,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 392,11 ***</span>
    int min = 0;
    int max = length;
    while (max &gt;= min) {
      const int mid = (int)(((uint)max + min) / 2);
      int diff = _edge_reference_compare_((uintptr_t)callback_info._high,
<span class="line-modified">!                                         (uintptr_t)arr-&gt;at(mid)-&gt;_data._root_edge-&gt;reference());</span>
      if (diff &gt; 0) {
        min = mid + 1;
      } else if (diff &lt; 0) {
        max = mid - 1;
      } else {
<span class="line-new-header">--- 391,11 ---</span>
    int min = 0;
    int max = length;
    while (max &gt;= min) {
      const int mid = (int)(((uint)max + min) / 2);
      int diff = _edge_reference_compare_((uintptr_t)callback_info._high,
<span class="line-modified">!                                         arr-&gt;at(mid)-&gt;_data._root_edge-&gt;reference().addr&lt;uintptr_t&gt;());</span>
      if (diff &gt; 0) {
        min = mid + 1;
      } else if (diff &lt; 0) {
        max = mid - 1;
      } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 410,15 ***</span>
  class RootResolutionSet : public ResourceObj, public RootCallback {
   private:
    GrowableArray&lt;const ObjectSampleRootDescriptionInfo*&gt;* _unresolved_roots;
  
    const uintptr_t high() const {
<span class="line-modified">!     return (uintptr_t)_unresolved_roots-&gt;last()-&gt;_data._root_edge-&gt;reference();</span>
    }
  
    const uintptr_t low() const {
<span class="line-modified">!     return (uintptr_t)_unresolved_roots-&gt;first()-&gt;_data._root_edge-&gt;reference();</span>
    }
  
    bool in_set_address_range(const RootCallbackInfo&amp; callback_info) const {
      assert(callback_info._low == NULL, &quot;invariant&quot;);
      const uintptr_t addr = (uintptr_t)callback_info._high;
<span class="line-new-header">--- 409,15 ---</span>
  class RootResolutionSet : public ResourceObj, public RootCallback {
   private:
    GrowableArray&lt;const ObjectSampleRootDescriptionInfo*&gt;* _unresolved_roots;
  
    const uintptr_t high() const {
<span class="line-modified">!     return _unresolved_roots-&gt;last()-&gt;_data._root_edge-&gt;reference().addr&lt;uintptr_t&gt;();</span>
    }
  
    const uintptr_t low() const {
<span class="line-modified">!     return _unresolved_roots-&gt;first()-&gt;_data._root_edge-&gt;reference().addr&lt;uintptr_t&gt;();</span>
    }
  
    bool in_set_address_range(const RootCallbackInfo&amp; callback_info) const {
      assert(callback_info._low == NULL, &quot;invariant&quot;);
      const uintptr_t addr = (uintptr_t)callback_info._high;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 428,11 ***</span>
    int compare_to_range(const RootCallbackInfo&amp; callback_info) const {
      assert(callback_info._high != NULL, &quot;invariant&quot;);
      assert(callback_info._low != NULL, &quot;invariant&quot;);
  
      for (int i = 0; i &lt; _unresolved_roots-&gt;length(); ++i) {
<span class="line-modified">!       const uintptr_t ref_addr = (uintptr_t)_unresolved_roots-&gt;at(i)-&gt;_data._root_edge-&gt;reference();</span>
        if ((uintptr_t)callback_info._low &lt;= ref_addr &amp;&amp; (uintptr_t)callback_info._high &gt;= ref_addr) {
          return i;
        }
      }
      return -1;
<span class="line-new-header">--- 427,11 ---</span>
    int compare_to_range(const RootCallbackInfo&amp; callback_info) const {
      assert(callback_info._high != NULL, &quot;invariant&quot;);
      assert(callback_info._low != NULL, &quot;invariant&quot;);
  
      for (int i = 0; i &lt; _unresolved_roots-&gt;length(); ++i) {
<span class="line-modified">!       const uintptr_t ref_addr = _unresolved_roots-&gt;at(i)-&gt;_data._root_edge-&gt;reference().addr&lt;uintptr_t&gt;();</span>
        if ((uintptr_t)callback_info._low &lt;= ref_addr &amp;&amp; (uintptr_t)callback_info._high &gt;= ref_addr) {
          return i;
        }
      }
      return -1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 452,11 ***</span>
      assert(idx &lt; _unresolved_roots-&gt;length(), &quot;invariant&quot;);
  
      ObjectSampleRootDescriptionInfo* const desc =
        const_cast&lt;ObjectSampleRootDescriptionInfo*&gt;(_unresolved_roots-&gt;at(idx));
      assert(desc != NULL, &quot;invariant&quot;);
<span class="line-modified">!     assert((uintptr_t)callback_info._high == (uintptr_t)desc-&gt;_data._root_edge-&gt;reference(), &quot;invariant&quot;);</span>
  
      desc-&gt;_data._system = callback_info._system;
      desc-&gt;_data._type = callback_info._type;
  
      if (callback_info._system == OldObjectRoot::_threads) {
<span class="line-new-header">--- 451,11 ---</span>
      assert(idx &lt; _unresolved_roots-&gt;length(), &quot;invariant&quot;);
  
      ObjectSampleRootDescriptionInfo* const desc =
        const_cast&lt;ObjectSampleRootDescriptionInfo*&gt;(_unresolved_roots-&gt;at(idx));
      assert(desc != NULL, &quot;invariant&quot;);
<span class="line-modified">!     assert((uintptr_t)callback_info._high == desc-&gt;_data._root_edge-&gt;reference().addr&lt;uintptr_t&gt;(), &quot;invariant&quot;);</span>
  
      desc-&gt;_data._system = callback_info._system;
      desc-&gt;_data._type = callback_info._type;
  
      if (callback_info._system == OldObjectRoot::_threads) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 498,11 ***</span>
  
    int entries() const {
      return _unresolved_roots-&gt;length();
    }
  
<span class="line-modified">!   const void* at(int idx) const {</span>
      assert(idx &gt;= 0, &quot;invariant&quot;);
      assert(idx &lt; _unresolved_roots-&gt;length(), &quot;invariant&quot;);
      return _unresolved_roots-&gt;at(idx)-&gt;_data._root_edge-&gt;reference();
    }
  };
<span class="line-new-header">--- 497,11 ---</span>
  
    int entries() const {
      return _unresolved_roots-&gt;length();
    }
  
<span class="line-modified">!   UnifiedOopRef at(int idx) const {</span>
      assert(idx &gt;= 0, &quot;invariant&quot;);
      assert(idx &lt; _unresolved_roots-&gt;length(), &quot;invariant&quot;);
      return _unresolved_roots-&gt;at(idx)-&gt;_data._root_edge-&gt;reference();
    }
  };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 511,30 ***</span>
    if (root_infos != NULL) {
      // resolve roots
      RootResolutionSet rrs(root_infos);
      RootResolver::resolve(rrs);
      // write roots
<span class="line-modified">!     RootDescriptionWriter rw(&amp;writer, NULL, false);</span>
      root_infos-&gt;iterate(rw);
    }
  }
  
<span class="line-modified">! static void add_old_object_sample_info(const Edge* current, traceid id) {</span>
    assert(current != NULL, &quot;invariant&quot;);
    if (sample_infos == NULL) {
      sample_infos = new SampleInfo();
    }
    assert(sample_infos != NULL, &quot;invariant&quot;);
    OldObjectSampleInfo* const oosi = new OldObjectSampleInfo();
    assert(oosi != NULL, &quot;invariant&quot;);
    oosi-&gt;_id = id;
    oosi-&gt;_data._object = current-&gt;pointee();
<span class="line-modified">!   oosi-&gt;_data._reference_id = current-&gt;is_root() ? (traceid)0 : id;</span>
    sample_infos-&gt;store(oosi);
  }
  
<span class="line-modified">! static void add_reference_info(const RoutableEdge* current, traceid id, traceid parent_id) {</span>
    assert(current != NULL, &quot;invariant&quot;);
    if (ref_infos == NULL) {
      ref_infos = new RefInfo();
    }
  
<span class="line-new-header">--- 510,30 ---</span>
    if (root_infos != NULL) {
      // resolve roots
      RootResolutionSet rrs(root_infos);
      RootResolver::resolve(rrs);
      // write roots
<span class="line-modified">!     RootDescriptionWriter rw(&amp;writer);</span>
      root_infos-&gt;iterate(rw);
    }
  }
  
<span class="line-modified">! static void add_old_object_sample_info(const StoredEdge* current, traceid id) {</span>
    assert(current != NULL, &quot;invariant&quot;);
    if (sample_infos == NULL) {
      sample_infos = new SampleInfo();
    }
    assert(sample_infos != NULL, &quot;invariant&quot;);
    OldObjectSampleInfo* const oosi = new OldObjectSampleInfo();
    assert(oosi != NULL, &quot;invariant&quot;);
    oosi-&gt;_id = id;
    oosi-&gt;_data._object = current-&gt;pointee();
<span class="line-modified">!   oosi-&gt;_data._reference_id = current-&gt;parent() == NULL ? (traceid)0 : id;</span>
    sample_infos-&gt;store(oosi);
  }
  
<span class="line-modified">! static void add_reference_info(const StoredEdge* current, traceid id, traceid parent_id) {</span>
    assert(current != NULL, &quot;invariant&quot;);
    if (ref_infos == NULL) {
      ref_infos = new RefInfo();
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 542,41 ***</span>
    ReferenceInfo* const ri = new ReferenceInfo();
    assert(ri != NULL, &quot;invariant&quot;);
  
    ri-&gt;_id = id;
    ri-&gt;_data._array_info_id =  !current-&gt;is_skip_edge() ? get_array_info_id(*current, id) : 0;
<span class="line-modified">!   ri-&gt;_data._field_info_id = ri-&gt;_data._array_info_id == 0 &amp;&amp; !current-&gt;is_skip_edge() ?</span>
<span class="line-removed">-                                get_field_info_id(*current) : (traceid)0;</span>
    ri-&gt;_data._old_object_sample_id = parent_id;
    ri-&gt;_data._skip = current-&gt;skip_length();
    ref_infos-&gt;store(ri);
  }
  
<span class="line-modified">! static traceid add_root_info(const Edge* root, traceid id) {</span>
    assert(root != NULL, &quot;invariant&quot;);
<span class="line-modified">!   assert(root-&gt;is_root(), &quot;invariant&quot;);</span>
<span class="line-modified">!   return get_root_description_info_id(*root, id);</span>
  }
  
<span class="line-modified">! void ObjectSampleWriter::write(const RoutableEdge* edge) {</span>
    assert(edge != NULL, &quot;invariant&quot;);
    const traceid id = _store-&gt;get_id(edge);
    add_old_object_sample_info(edge, id);
<span class="line-modified">!   const RoutableEdge* parent = edge-&gt;logical_parent();</span>
    if (parent != NULL) {
      add_reference_info(edge, id, _store-&gt;get_id(parent));
    } else {
<span class="line-modified">!     assert(edge-&gt;is_root(), &quot;invariant&quot;);</span>
<span class="line-modified">!     add_root_info(edge, id);</span>
    }
  }
  
<span class="line-modified">! ObjectSampleWriter::ObjectSampleWriter(JfrCheckpointWriter&amp; writer, const EdgeStore* store) :</span>
    _writer(writer),
    _store(store) {
    assert(store != NULL, &quot;invariant&quot;);
<span class="line-modified">!   assert(store-&gt;number_of_entries() &gt; 0, &quot;invariant&quot;);</span>
    sample_infos = NULL;
    ref_infos = NULL;
    array_infos = NULL;
    field_infos = NULL;
    root_infos = NULL;
<span class="line-new-header">--- 541,81 ---</span>
    ReferenceInfo* const ri = new ReferenceInfo();
    assert(ri != NULL, &quot;invariant&quot;);
  
    ri-&gt;_id = id;
    ri-&gt;_data._array_info_id =  !current-&gt;is_skip_edge() ? get_array_info_id(*current, id) : 0;
<span class="line-modified">!   ri-&gt;_data._field_info_id = ri-&gt;_data._array_info_id == 0 &amp;&amp; !current-&gt;is_skip_edge() ? get_field_info_id(*current) : (traceid)0;</span>
    ri-&gt;_data._old_object_sample_id = parent_id;
    ri-&gt;_data._skip = current-&gt;skip_length();
    ref_infos-&gt;store(ri);
  }
  
<span class="line-modified">! static bool is_gc_root(const StoredEdge* current) {</span>
<span class="line-added">+   assert(current != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   return current-&gt;parent() == NULL &amp;&amp; current-&gt;gc_root_id() != 0;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static traceid add_gc_root_info(const StoredEdge* root, traceid id) {</span>
    assert(root != NULL, &quot;invariant&quot;);
<span class="line-modified">!   assert(is_gc_root(root), &quot;invariant&quot;);</span>
<span class="line-modified">!   return get_gc_root_description_info_id(*root, id);</span>
  }
  
<span class="line-modified">! void ObjectSampleWriter::write(const StoredEdge* edge) {</span>
    assert(edge != NULL, &quot;invariant&quot;);
    const traceid id = _store-&gt;get_id(edge);
    add_old_object_sample_info(edge, id);
<span class="line-modified">!   const StoredEdge* const parent = edge-&gt;parent();</span>
    if (parent != NULL) {
      add_reference_info(edge, id, _store-&gt;get_id(parent));
    } else {
<span class="line-modified">!     if (is_gc_root(edge)) {</span>
<span class="line-modified">!       assert(edge-&gt;gc_root_id() == id, &quot;invariant&quot;);</span>
<span class="line-added">+       add_gc_root_info(edge, id);</span>
<span class="line-added">+     }</span>
    }
  }
  
<span class="line-modified">! class RootSystemType : public JfrSerializer {</span>
<span class="line-added">+  public:</span>
<span class="line-added">+   void serialize(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-added">+     const u4 nof_root_systems = OldObjectRoot::_number_of_systems;</span>
<span class="line-added">+     writer.write_count(nof_root_systems);</span>
<span class="line-added">+     for (u4 i = 0; i &lt; nof_root_systems; ++i) {</span>
<span class="line-added">+       writer.write_key(i);</span>
<span class="line-added">+       writer.write(OldObjectRoot::system_description((OldObjectRoot::System)i));</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ class RootType : public JfrSerializer {</span>
<span class="line-added">+  public:</span>
<span class="line-added">+   void serialize(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-added">+     const u4 nof_root_types = OldObjectRoot::_number_of_types;</span>
<span class="line-added">+     writer.write_count(nof_root_types);</span>
<span class="line-added">+     for (u4 i = 0; i &lt; nof_root_types; ++i) {</span>
<span class="line-added">+       writer.write_key(i);</span>
<span class="line-added">+       writer.write(OldObjectRoot::type_description((OldObjectRoot::Type)i));</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void register_serializers() {</span>
<span class="line-added">+   static bool is_registered = false;</span>
<span class="line-added">+   if (!is_registered) {</span>
<span class="line-added">+     JfrSerializer::register_serializer(TYPE_OLDOBJECTROOTSYSTEM, true, new RootSystemType());</span>
<span class="line-added">+     JfrSerializer::register_serializer(TYPE_OLDOBJECTROOTTYPE, true, new RootType());</span>
<span class="line-added">+     is_registered = true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ ObjectSampleWriter::ObjectSampleWriter(JfrCheckpointWriter&amp; writer, EdgeStore* store) :</span>
    _writer(writer),
    _store(store) {
    assert(store != NULL, &quot;invariant&quot;);
<span class="line-modified">!   assert(!store-&gt;is_empty(), &quot;invariant&quot;);</span>
<span class="line-added">+   register_serializers();</span>
    sample_infos = NULL;
    ref_infos = NULL;
    array_infos = NULL;
    field_infos = NULL;
    root_infos = NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 588,28 ***</span>
    write_array_infos(_writer);
    write_field_infos(_writer);
    write_root_descriptors(_writer);
  }
  
<span class="line-modified">! void ObjectSampleWriter::write_chain(const RoutableEdge&amp; edge) {</span>
<span class="line-modified">!   assert(EdgeUtils::is_leak_edge(edge), &quot;invariant&quot;);</span>
<span class="line-removed">-   if (edge.processed()) {</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   EdgeUtils::collapse_chain(edge);</span>
<span class="line-removed">-   const RoutableEdge* current = &amp;edge;</span>
<span class="line-removed">-   while (current != NULL) {</span>
<span class="line-removed">-     if (current-&gt;processed()) {</span>
<span class="line-removed">-       return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     write(current);</span>
<span class="line-removed">-     current-&gt;set_processed();</span>
<span class="line-removed">-     current = current-&gt;logical_parent();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool ObjectSampleWriter::operator()(const RoutableEdge&amp; edge) {</span>
<span class="line-removed">-   if (EdgeUtils::is_leak_edge(edge)) {</span>
<span class="line-removed">-     write_chain(edge);</span>
<span class="line-removed">-   }</span>
    return true;
  }
<span class="line-new-header">--- 627,9 ---</span>
    write_array_infos(_writer);
    write_field_infos(_writer);
    write_root_descriptors(_writer);
  }
  
<span class="line-modified">! bool ObjectSampleWriter::operator()(StoredEdge&amp; e) {</span>
<span class="line-modified">!   write(&amp;e);</span>
    return true;
  }
</pre>
<center><a href="objectSampleDescription.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="objectSampleWriter.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
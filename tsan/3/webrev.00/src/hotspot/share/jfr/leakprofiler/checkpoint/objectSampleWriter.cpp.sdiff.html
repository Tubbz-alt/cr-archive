<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/leakprofiler/checkpoint/objectSampleWriter.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="objectSampleDescription.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="objectSampleWriter.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/leakprofiler/checkpoint/objectSampleWriter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfrfiles/jfrTypes.hpp&quot;
 27 #include &quot;jfr/leakprofiler/chains/edge.hpp&quot;
 28 #include &quot;jfr/leakprofiler/chains/edgeStore.hpp&quot;
 29 #include &quot;jfr/leakprofiler/chains/edgeUtils.hpp&quot;
 30 #include &quot;jfr/leakprofiler/checkpoint/objectSampleDescription.hpp&quot;
 31 #include &quot;jfr/leakprofiler/checkpoint/objectSampleWriter.hpp&quot;
 32 #include &quot;jfr/leakprofiler/checkpoint/rootResolver.hpp&quot;
 33 #include &quot;jfr/leakprofiler/sampling/objectSampler.hpp&quot;
 34 #include &quot;jfr/leakprofiler/utilities/rootType.hpp&quot;
<span class="line-modified"> 35 #include &quot;jfr/leakprofiler/utilities/unifiedOop.hpp&quot;</span>
<span class="line-modified"> 36 #include &quot;jfr/recorder/checkpoint/types/jfrTypeSetUtils.hpp&quot;</span>
<span class="line-modified"> 37 #include &quot;jfr/recorder/checkpoint/types/jfrTypeSetWriter.hpp&quot;</span>
 38 #include &quot;oops/oop.inline.hpp&quot;
 39 #include &quot;oops/symbol.hpp&quot;
 40 #include &quot;utilities/growableArray.hpp&quot;
 41 
 42 template &lt;typename Data&gt;
 43 class ObjectSampleAuxInfo : public ResourceObj {
 44  public:
 45   Data _data;
 46   traceid _id;
 47   ObjectSampleAuxInfo() : _data(), _id(0) {}
 48 };
 49 
 50 class ObjectSampleArrayData {
 51  public:
 52   int _array_size;
 53   int _array_index;
 54   ObjectSampleArrayData() : _array_size(0), _array_index(0) {}
 55 };
 56 
 57 class ObjectSampleFieldInfo : public ResourceObj {
</pre>
<hr />
<pre>
120     }
121   }
122 
123   const GrowableArray&lt;Data&gt;&amp; storage() const {
124     return *_storage;
125   }
126 };
127 
128 typedef ObjectSampleAuxInfo&lt;ObjectSampleArrayData&gt; ObjectSampleArrayInfo;
129 typedef ObjectSampleAuxInfo&lt;ObjectSampleRootDescriptionData&gt; ObjectSampleRootDescriptionInfo;
130 typedef ObjectSampleAuxInfo&lt;OldObjectSampleData&gt; OldObjectSampleInfo;
131 typedef ObjectSampleAuxInfo&lt;ReferenceData&gt; ReferenceInfo;
132 
133 class FieldTable : public ResourceObj {
134   template &lt;typename,
135             typename,
136             template&lt;typename, typename&gt; class,
137             typename,
138             size_t&gt;
139   friend class HashTableHost;
<span class="line-modified">140   typedef HashTableHost&lt;const ObjectSampleFieldInfo*, traceid, Entry, FieldTable, 109&gt; FieldInfoTable;</span>
141  public:
142   typedef FieldInfoTable::HashEntry FieldInfoEntry;
143 
144  private:
145   static traceid _field_id_counter;
146   FieldInfoTable* _table;

147 
<span class="line-modified">148   void assign_id(FieldInfoEntry* entry) {</span>
149     assert(entry != NULL, &quot;invariant&quot;);
150     entry-&gt;set_id(++_field_id_counter);
151   }
152 
<span class="line-modified">153   bool equals(const ObjectSampleFieldInfo* query, uintptr_t hash, const FieldInfoEntry* entry) {</span>
154     assert(hash == entry-&gt;hash(), &quot;invariant&quot;);
<span class="line-modified">155     assert(query != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">156     const ObjectSampleFieldInfo* stored = entry-&gt;literal();</span>
<span class="line-modified">157     assert(stored != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">158     assert(stored-&gt;_field_name_symbol-&gt;identity_hash() == query-&gt;_field_name_symbol-&gt;identity_hash(), &quot;invariant&quot;);</span>
<span class="line-modified">159     return stored-&gt;_field_modifiers == query-&gt;_field_modifiers;</span>


160   }
161 
162  public:
<span class="line-modified">163   FieldTable() : _table(new FieldInfoTable(this)) {}</span>
164   ~FieldTable() {
165     assert(_table != NULL, &quot;invariant&quot;);
166     delete _table;
167   }
168 
169   traceid store(const ObjectSampleFieldInfo* field_info) {
170     assert(field_info != NULL, &quot;invariant&quot;);
<span class="line-modified">171     const FieldInfoEntry&amp; entry =_table-&gt;lookup_put(field_info,</span>
<span class="line-modified">172                                                     field_info-&gt;_field_name_symbol-&gt;identity_hash());</span>
173     return entry.id();
174   }
175 
176   size_t size() const {
177     return _table-&gt;cardinality();
178   }
179 
180   template &lt;typename T&gt;
181   void iterate(T&amp; functor) const {
182     _table-&gt;iterate_entry&lt;T&gt;(functor);
183   }
184 };
185 
186 traceid FieldTable::_field_id_counter = 0;
187 
188 typedef SampleSet&lt;const OldObjectSampleInfo*&gt; SampleInfo;
189 typedef SampleSet&lt;const ReferenceInfo*&gt; RefInfo;
190 typedef SampleSet&lt;const ObjectSampleArrayInfo*&gt; ArrayInfo;
191 typedef SampleSet&lt;const ObjectSampleRootDescriptionInfo*&gt; RootDescriptionInfo;
192 
193 static SampleInfo* sample_infos = NULL;
194 static RefInfo* ref_infos = NULL;
195 static ArrayInfo* array_infos = NULL;
196 static FieldTable* field_infos = NULL;
197 static RootDescriptionInfo* root_infos = NULL;
198 
<span class="line-modified">199 int __write_sample_info__(JfrCheckpointWriter* writer, JfrArtifactSet* unused, const void* si) {</span>
200   assert(writer != NULL, &quot;invariant&quot;);
201   assert(si != NULL, &quot;invariant&quot;);
202   const OldObjectSampleInfo* const oosi = (const OldObjectSampleInfo*)si;
203   oop object = oosi-&gt;_data._object;
204   assert(object != NULL, &quot;invariant&quot;);
205   writer-&gt;write(oosi-&gt;_id);
<span class="line-modified">206   writer-&gt;write((u8)(const HeapWord*)object);</span>
207   writer-&gt;write(const_cast&lt;const Klass*&gt;(object-&gt;klass()));
208   ObjectSampleDescription od(object);
209   writer-&gt;write(od.description());
210   writer-&gt;write(oosi-&gt;_data._reference_id);
211   return 1;
212 }
213 
<span class="line-modified">214 typedef JfrArtifactWriterImplHost&lt;const OldObjectSampleInfo*, __write_sample_info__&gt; SampleWriterImpl;</span>
<span class="line-modified">215 typedef JfrArtifactWriterHost&lt;SampleWriterImpl, TYPE_OLDOBJECT&gt; SampleWriter;</span>
216 
217 static void write_sample_infos(JfrCheckpointWriter&amp; writer) {
218   if (sample_infos != NULL) {
<span class="line-modified">219     SampleWriter sw(&amp;writer, NULL, false);</span>
220     sample_infos-&gt;iterate(sw);
221   }
222 }
223 
<span class="line-modified">224 int __write_reference_info__(JfrCheckpointWriter* writer, JfrArtifactSet* unused, const void* ri) {</span>
225   assert(writer != NULL, &quot;invariant&quot;);
226   assert(ri != NULL, &quot;invariant&quot;);
227   const ReferenceInfo* const ref_info = (const ReferenceInfo*)ri;
228   writer-&gt;write(ref_info-&gt;_id);
229   writer-&gt;write(ref_info-&gt;_data._array_info_id);
230   writer-&gt;write(ref_info-&gt;_data._field_info_id);
231   writer-&gt;write(ref_info-&gt;_data._old_object_sample_id);
232   writer-&gt;write&lt;s4&gt;((s4)ref_info-&gt;_data._skip);
233   return 1;
234 }
235 
<span class="line-modified">236 typedef JfrArtifactWriterImplHost&lt;const ReferenceInfo*, __write_reference_info__&gt; ReferenceWriterImpl;</span>
<span class="line-modified">237 typedef JfrArtifactWriterHost&lt;ReferenceWriterImpl, TYPE_REFERENCE&gt; ReferenceWriter;</span>
238 
239 static void write_reference_infos(JfrCheckpointWriter&amp; writer) {
240   if (ref_infos != NULL) {
<span class="line-modified">241     ReferenceWriter rw(&amp;writer, NULL, false);</span>
242     ref_infos-&gt;iterate(rw);
243   }
244 }
245 
<span class="line-modified">246 int __write_array_info__(JfrCheckpointWriter* writer, JfrArtifactSet* unused, const void* ai) {</span>
247   assert(writer != NULL, &quot;invariant&quot;);
248   assert(ai != NULL, &quot;invariant&quot;);
249   const ObjectSampleArrayInfo* const osai = (const ObjectSampleArrayInfo*)ai;
250   writer-&gt;write(osai-&gt;_id);
251   writer-&gt;write(osai-&gt;_data._array_size);
252   writer-&gt;write(osai-&gt;_data._array_index);
253   return 1;
254 }
255 
256 static traceid get_array_info_id(const Edge&amp; edge, traceid id) {
257   if (edge.is_root() || !EdgeUtils::is_array_element(edge)) {
258     return 0;
259   }
260   if (array_infos == NULL) {
261     array_infos = new ArrayInfo();
262   }
263   assert(array_infos != NULL, &quot;invariant&quot;);
264 
265   ObjectSampleArrayInfo* const osai = new ObjectSampleArrayInfo();
266   assert(osai != NULL, &quot;invariant&quot;);
267   osai-&gt;_id = id;
268   osai-&gt;_data._array_size = EdgeUtils::array_size(edge);
269   osai-&gt;_data._array_index = EdgeUtils::array_index(edge);
270   return array_infos-&gt;store(osai);
271 }
272 
<span class="line-modified">273 typedef JfrArtifactWriterImplHost&lt;const ObjectSampleArrayInfo*, __write_array_info__&gt; ArrayWriterImpl;</span>
<span class="line-modified">274 typedef JfrArtifactWriterHost&lt;ArrayWriterImpl, TYPE_OLDOBJECTARRAY&gt; ArrayWriter;</span>
275 
276 static void write_array_infos(JfrCheckpointWriter&amp; writer) {
277   if (array_infos != NULL) {
<span class="line-modified">278     ArrayWriter aw(&amp;writer, NULL, false);</span>
279     array_infos-&gt;iterate(aw);
280   }
281 }
282 
<span class="line-modified">283 int __write_field_info__(JfrCheckpointWriter* writer, JfrArtifactSet* unused, const void* fi) {</span>
284   assert(writer != NULL, &quot;invariant&quot;);
285   assert(fi != NULL, &quot;invariant&quot;);
286   const FieldTable::FieldInfoEntry* field_info_entry = (const FieldTable::FieldInfoEntry*)fi;
287   writer-&gt;write(field_info_entry-&gt;id());
288   const ObjectSampleFieldInfo* const osfi = field_info_entry-&gt;literal();
289   writer-&gt;write(osfi-&gt;_field_name_symbol-&gt;as_C_string());
290   writer-&gt;write(osfi-&gt;_field_modifiers);
291   return 1;
292 }
293 
294 static traceid get_field_info_id(const Edge&amp; edge) {
295   if (edge.is_root()) {
296     return 0;
297   }
298 
299   assert(!EdgeUtils::is_array_element(edge), &quot;invariant&quot;);
300   const Symbol* const field_name_symbol = EdgeUtils::field_name_symbol(edge);
301   if (field_name_symbol == NULL) {
302     return 0;
303   }
304 
305   if (field_infos == NULL) {
306     field_infos = new FieldTable();
307   }
308   assert(field_infos != NULL, &quot;invariant&quot;);
309 
310   ObjectSampleFieldInfo* const osfi = new ObjectSampleFieldInfo();
311   assert(osfi != NULL, &quot;invariant&quot;);
312   osfi-&gt;_field_name_symbol = field_name_symbol;
313   osfi-&gt;_field_modifiers = EdgeUtils::field_modifiers(edge);
314   return field_infos-&gt;store(osfi);
315 }
316 
<span class="line-modified">317 typedef JfrArtifactWriterImplHost&lt;const FieldTable::FieldInfoEntry*, __write_field_info__&gt; FieldWriterImpl;</span>
<span class="line-modified">318 typedef JfrArtifactWriterHost&lt;FieldWriterImpl, TYPE_OLDOBJECTFIELD&gt; FieldWriter;</span>
319 
320 static void write_field_infos(JfrCheckpointWriter&amp; writer) {
321   if (field_infos != NULL) {
<span class="line-modified">322     FieldWriter fw(&amp;writer, NULL, false);</span>
323     field_infos-&gt;iterate(fw);
324   }
325 }
326 
327 static const char* description(const ObjectSampleRootDescriptionInfo* osdi) {
328   assert(osdi != NULL, &quot;invariant&quot;);
329 
330   if (osdi-&gt;_data._description == NULL) {
331     return NULL;
332   }
333 
334   ObjectDescriptionBuilder description;
335   if (osdi-&gt;_data._system == OldObjectRoot::_threads) {
336     description.write_text(&quot;Thread Name: &quot;);
337   }
338   description.write_text(osdi-&gt;_data._description);
339   return description.description();
340 }
341 
<span class="line-modified">342 int __write_root_description_info__(JfrCheckpointWriter* writer, JfrArtifactSet* unused, const void* di) {</span>
343   assert(writer != NULL, &quot;invariant&quot;);
344   assert(di != NULL, &quot;invariant&quot;);
345   const ObjectSampleRootDescriptionInfo* const osdi = (const ObjectSampleRootDescriptionInfo*)di;
346   writer-&gt;write(osdi-&gt;_id);
347   writer-&gt;write(description(osdi));
348   writer-&gt;write&lt;u8&gt;(osdi-&gt;_data._system);
349   writer-&gt;write&lt;u8&gt;(osdi-&gt;_data._type);
350   return 1;
351 }
352 
<span class="line-modified">353 static traceid get_root_description_info_id(const Edge&amp; edge, traceid id) {</span>
354   assert(edge.is_root(), &quot;invariant&quot;);
<span class="line-removed">355   if (EdgeUtils::is_leak_edge(edge)) {</span>
<span class="line-removed">356     return 0;</span>
<span class="line-removed">357   }</span>
<span class="line-removed">358 </span>
359   if (root_infos == NULL) {
360     root_infos = new RootDescriptionInfo();
361   }
362   assert(root_infos != NULL, &quot;invariant&quot;);
363   ObjectSampleRootDescriptionInfo* const oodi = new ObjectSampleRootDescriptionInfo();
364   oodi-&gt;_id = id;
365   oodi-&gt;_data._root_edge = &amp;edge;
366   return root_infos-&gt;store(oodi);
367 }
368 
<span class="line-modified">369 typedef JfrArtifactWriterImplHost&lt;const ObjectSampleRootDescriptionInfo*, __write_root_description_info__&gt; RootDescriptionWriterImpl;</span>
<span class="line-modified">370 typedef JfrArtifactWriterHost&lt;RootDescriptionWriterImpl, TYPE_OLDOBJECTGCROOT&gt; RootDescriptionWriter;</span>
371 
372 
373 int _edge_reference_compare_(uintptr_t lhs, uintptr_t rhs) {
374   return lhs &gt; rhs ? 1 : (lhs &lt; rhs) ? -1 : 0;
375 }
376 
377 int _root_desc_compare_(const ObjectSampleRootDescriptionInfo*const &amp; lhs, const ObjectSampleRootDescriptionInfo* const&amp; rhs) {
<span class="line-modified">378   const uintptr_t lhs_ref = (uintptr_t)lhs-&gt;_data._root_edge-&gt;reference();</span>
<span class="line-modified">379   const uintptr_t rhs_ref = (uintptr_t)rhs-&gt;_data._root_edge-&gt;reference();</span>
380   return _edge_reference_compare_(lhs_ref, rhs_ref);
381 }
382 
383 static int find_sorted(const RootCallbackInfo&amp; callback_info,
384                        const GrowableArray&lt;const ObjectSampleRootDescriptionInfo*&gt;* arr,
385                        int length,
386                        bool&amp; found) {
387   assert(arr != NULL, &quot;invariant&quot;);
388   assert(length &gt;= 0, &quot;invariant&quot;);
389   assert(length &lt;= arr-&gt;length(), &quot;invariant&quot;);
390 
391   found = false;
392   int min = 0;
393   int max = length;
394   while (max &gt;= min) {
395     const int mid = (int)(((uint)max + min) / 2);
396     int diff = _edge_reference_compare_((uintptr_t)callback_info._high,
<span class="line-modified">397                                         (uintptr_t)arr-&gt;at(mid)-&gt;_data._root_edge-&gt;reference());</span>
398     if (diff &gt; 0) {
399       min = mid + 1;
400     } else if (diff &lt; 0) {
401       max = mid - 1;
402     } else {
403       found = true;
404       return mid;
405     }
406   }
407   return min;
408 }
409 
410 class RootResolutionSet : public ResourceObj, public RootCallback {
411  private:
412   GrowableArray&lt;const ObjectSampleRootDescriptionInfo*&gt;* _unresolved_roots;
413 
414   const uintptr_t high() const {
<span class="line-modified">415     return (uintptr_t)_unresolved_roots-&gt;last()-&gt;_data._root_edge-&gt;reference();</span>
416   }
417 
418   const uintptr_t low() const {
<span class="line-modified">419     return (uintptr_t)_unresolved_roots-&gt;first()-&gt;_data._root_edge-&gt;reference();</span>
420   }
421 
422   bool in_set_address_range(const RootCallbackInfo&amp; callback_info) const {
423     assert(callback_info._low == NULL, &quot;invariant&quot;);
424     const uintptr_t addr = (uintptr_t)callback_info._high;
425     return low() &lt;= addr &amp;&amp; high() &gt;= addr;
426   }
427 
428   int compare_to_range(const RootCallbackInfo&amp; callback_info) const {
429     assert(callback_info._high != NULL, &quot;invariant&quot;);
430     assert(callback_info._low != NULL, &quot;invariant&quot;);
431 
432     for (int i = 0; i &lt; _unresolved_roots-&gt;length(); ++i) {
<span class="line-modified">433       const uintptr_t ref_addr = (uintptr_t)_unresolved_roots-&gt;at(i)-&gt;_data._root_edge-&gt;reference();</span>
434       if ((uintptr_t)callback_info._low &lt;= ref_addr &amp;&amp; (uintptr_t)callback_info._high &gt;= ref_addr) {
435         return i;
436       }
437     }
438     return -1;
439   }
440 
441   int exact(const RootCallbackInfo&amp; callback_info) const {
442     assert(callback_info._high != NULL, &quot;invariant&quot;);
443     assert(in_set_address_range(callback_info), &quot;invariant&quot;);
444 
445     bool found;
446     const int idx = find_sorted(callback_info, _unresolved_roots, _unresolved_roots-&gt;length(), found);
447     return found ? idx : -1;
448   }
449 
450   bool resolve_root(const RootCallbackInfo&amp; callback_info, int idx) const {
451     assert(idx &gt;= 0, &quot;invariant&quot;);
452     assert(idx &lt; _unresolved_roots-&gt;length(), &quot;invariant&quot;);
453 
454     ObjectSampleRootDescriptionInfo* const desc =
455       const_cast&lt;ObjectSampleRootDescriptionInfo*&gt;(_unresolved_roots-&gt;at(idx));
456     assert(desc != NULL, &quot;invariant&quot;);
<span class="line-modified">457     assert((uintptr_t)callback_info._high == (uintptr_t)desc-&gt;_data._root_edge-&gt;reference(), &quot;invariant&quot;);</span>
458 
459     desc-&gt;_data._system = callback_info._system;
460     desc-&gt;_data._type = callback_info._type;
461 
462     if (callback_info._system == OldObjectRoot::_threads) {
463       const JavaThread* jt = (const JavaThread*)callback_info._context;
464       assert(jt != NULL, &quot;invariant&quot;);
465       desc-&gt;_data._description = jt-&gt;name();
466     }
467 
468     _unresolved_roots-&gt;remove_at(idx);
469     return _unresolved_roots-&gt;is_empty();
470   }
471 
472  public:
473   RootResolutionSet(RootDescriptionInfo* info) : _unresolved_roots(NULL) {
474     assert(info != NULL, &quot;invariant&quot;);
475     // construct a sorted copy
476     const GrowableArray&lt;const ObjectSampleRootDescriptionInfo*&gt;&amp; info_storage = info-&gt;storage();
477     const int length = info_storage.length();
</pre>
<hr />
<pre>
483     }
484   }
485 
486   bool process(const RootCallbackInfo&amp; callback_info) {
487     if (NULL == callback_info._low) {
488       if (in_set_address_range(callback_info)) {
489         const int idx = exact(callback_info);
490         return idx == -1 ? false : resolve_root(callback_info, idx);
491       }
492       return false;
493     }
494     assert(callback_info._low != NULL, &quot;invariant&quot;);
495     const int idx = compare_to_range(callback_info);
496     return idx == -1 ? false : resolve_root(callback_info, idx);
497   }
498 
499   int entries() const {
500     return _unresolved_roots-&gt;length();
501   }
502 
<span class="line-modified">503   const void* at(int idx) const {</span>
504     assert(idx &gt;= 0, &quot;invariant&quot;);
505     assert(idx &lt; _unresolved_roots-&gt;length(), &quot;invariant&quot;);
506     return _unresolved_roots-&gt;at(idx)-&gt;_data._root_edge-&gt;reference();
507   }
508 };
509 
510 static void write_root_descriptors(JfrCheckpointWriter&amp; writer) {
511   if (root_infos != NULL) {
512     // resolve roots
513     RootResolutionSet rrs(root_infos);
514     RootResolver::resolve(rrs);
515     // write roots
<span class="line-modified">516     RootDescriptionWriter rw(&amp;writer, NULL, false);</span>
517     root_infos-&gt;iterate(rw);
518   }
519 }
520 
<span class="line-modified">521 static void add_old_object_sample_info(const Edge* current, traceid id) {</span>
522   assert(current != NULL, &quot;invariant&quot;);
523   if (sample_infos == NULL) {
524     sample_infos = new SampleInfo();
525   }
526   assert(sample_infos != NULL, &quot;invariant&quot;);
527   OldObjectSampleInfo* const oosi = new OldObjectSampleInfo();
528   assert(oosi != NULL, &quot;invariant&quot;);
529   oosi-&gt;_id = id;
530   oosi-&gt;_data._object = current-&gt;pointee();
<span class="line-modified">531   oosi-&gt;_data._reference_id = current-&gt;is_root() ? (traceid)0 : id;</span>
532   sample_infos-&gt;store(oosi);
533 }
534 
<span class="line-modified">535 static void add_reference_info(const RoutableEdge* current, traceid id, traceid parent_id) {</span>
536   assert(current != NULL, &quot;invariant&quot;);
537   if (ref_infos == NULL) {
538     ref_infos = new RefInfo();
539   }
540 
541   assert(ref_infos != NULL, &quot;invariant&quot;);
542   ReferenceInfo* const ri = new ReferenceInfo();
543   assert(ri != NULL, &quot;invariant&quot;);
544 
545   ri-&gt;_id = id;
546   ri-&gt;_data._array_info_id =  !current-&gt;is_skip_edge() ? get_array_info_id(*current, id) : 0;
<span class="line-modified">547   ri-&gt;_data._field_info_id = ri-&gt;_data._array_info_id == 0 &amp;&amp; !current-&gt;is_skip_edge() ?</span>
<span class="line-removed">548                                get_field_info_id(*current) : (traceid)0;</span>
549   ri-&gt;_data._old_object_sample_id = parent_id;
550   ri-&gt;_data._skip = current-&gt;skip_length();
551   ref_infos-&gt;store(ri);
552 }
553 
<span class="line-modified">554 static traceid add_root_info(const Edge* root, traceid id) {</span>





555   assert(root != NULL, &quot;invariant&quot;);
<span class="line-modified">556   assert(root-&gt;is_root(), &quot;invariant&quot;);</span>
<span class="line-modified">557   return get_root_description_info_id(*root, id);</span>
558 }
559 
<span class="line-modified">560 void ObjectSampleWriter::write(const RoutableEdge* edge) {</span>
561   assert(edge != NULL, &quot;invariant&quot;);
562   const traceid id = _store-&gt;get_id(edge);
563   add_old_object_sample_info(edge, id);
<span class="line-modified">564   const RoutableEdge* parent = edge-&gt;logical_parent();</span>
565   if (parent != NULL) {
566     add_reference_info(edge, id, _store-&gt;get_id(parent));
567   } else {
<span class="line-modified">568     assert(edge-&gt;is_root(), &quot;invariant&quot;);</span>
<span class="line-modified">569     add_root_info(edge, id);</span>


570   }
571 }
572 
<span class="line-modified">573 ObjectSampleWriter::ObjectSampleWriter(JfrCheckpointWriter&amp; writer, const EdgeStore* store) :</span>

































574   _writer(writer),
575   _store(store) {
576   assert(store != NULL, &quot;invariant&quot;);
<span class="line-modified">577   assert(store-&gt;number_of_entries() &gt; 0, &quot;invariant&quot;);</span>

578   sample_infos = NULL;
579   ref_infos = NULL;
580   array_infos = NULL;
581   field_infos = NULL;
582   root_infos = NULL;
583 }
584 
585 ObjectSampleWriter::~ObjectSampleWriter() {
586   write_sample_infos(_writer);
587   write_reference_infos(_writer);
588   write_array_infos(_writer);
589   write_field_infos(_writer);
590   write_root_descriptors(_writer);
591 }
592 
<span class="line-modified">593 void ObjectSampleWriter::write_chain(const RoutableEdge&amp; edge) {</span>
<span class="line-modified">594   assert(EdgeUtils::is_leak_edge(edge), &quot;invariant&quot;);</span>
<span class="line-removed">595   if (edge.processed()) {</span>
<span class="line-removed">596     return;</span>
<span class="line-removed">597   }</span>
<span class="line-removed">598   EdgeUtils::collapse_chain(edge);</span>
<span class="line-removed">599   const RoutableEdge* current = &amp;edge;</span>
<span class="line-removed">600   while (current != NULL) {</span>
<span class="line-removed">601     if (current-&gt;processed()) {</span>
<span class="line-removed">602       return;</span>
<span class="line-removed">603     }</span>
<span class="line-removed">604     write(current);</span>
<span class="line-removed">605     current-&gt;set_processed();</span>
<span class="line-removed">606     current = current-&gt;logical_parent();</span>
<span class="line-removed">607   }</span>
<span class="line-removed">608 }</span>
<span class="line-removed">609 </span>
<span class="line-removed">610 bool ObjectSampleWriter::operator()(const RoutableEdge&amp; edge) {</span>
<span class="line-removed">611   if (EdgeUtils::is_leak_edge(edge)) {</span>
<span class="line-removed">612     write_chain(edge);</span>
<span class="line-removed">613   }</span>
614   return true;
615 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfrfiles/jfrTypes.hpp&quot;
 27 #include &quot;jfr/leakprofiler/chains/edge.hpp&quot;
 28 #include &quot;jfr/leakprofiler/chains/edgeStore.hpp&quot;
 29 #include &quot;jfr/leakprofiler/chains/edgeUtils.hpp&quot;
 30 #include &quot;jfr/leakprofiler/checkpoint/objectSampleDescription.hpp&quot;
 31 #include &quot;jfr/leakprofiler/checkpoint/objectSampleWriter.hpp&quot;
 32 #include &quot;jfr/leakprofiler/checkpoint/rootResolver.hpp&quot;
 33 #include &quot;jfr/leakprofiler/sampling/objectSampler.hpp&quot;
 34 #include &quot;jfr/leakprofiler/utilities/rootType.hpp&quot;
<span class="line-modified"> 35 #include &quot;jfr/leakprofiler/utilities/unifiedOopRef.inline.hpp&quot;</span>
<span class="line-modified"> 36 #include &quot;jfr/metadata/jfrSerializer.hpp&quot;</span>
<span class="line-modified"> 37 #include &quot;jfr/writers/jfrTypeWriterHost.hpp&quot;</span>
 38 #include &quot;oops/oop.inline.hpp&quot;
 39 #include &quot;oops/symbol.hpp&quot;
 40 #include &quot;utilities/growableArray.hpp&quot;
 41 
 42 template &lt;typename Data&gt;
 43 class ObjectSampleAuxInfo : public ResourceObj {
 44  public:
 45   Data _data;
 46   traceid _id;
 47   ObjectSampleAuxInfo() : _data(), _id(0) {}
 48 };
 49 
 50 class ObjectSampleArrayData {
 51  public:
 52   int _array_size;
 53   int _array_index;
 54   ObjectSampleArrayData() : _array_size(0), _array_index(0) {}
 55 };
 56 
 57 class ObjectSampleFieldInfo : public ResourceObj {
</pre>
<hr />
<pre>
120     }
121   }
122 
123   const GrowableArray&lt;Data&gt;&amp; storage() const {
124     return *_storage;
125   }
126 };
127 
128 typedef ObjectSampleAuxInfo&lt;ObjectSampleArrayData&gt; ObjectSampleArrayInfo;
129 typedef ObjectSampleAuxInfo&lt;ObjectSampleRootDescriptionData&gt; ObjectSampleRootDescriptionInfo;
130 typedef ObjectSampleAuxInfo&lt;OldObjectSampleData&gt; OldObjectSampleInfo;
131 typedef ObjectSampleAuxInfo&lt;ReferenceData&gt; ReferenceInfo;
132 
133 class FieldTable : public ResourceObj {
134   template &lt;typename,
135             typename,
136             template&lt;typename, typename&gt; class,
137             typename,
138             size_t&gt;
139   friend class HashTableHost;
<span class="line-modified">140   typedef HashTableHost&lt;const ObjectSampleFieldInfo*, traceid, JfrHashtableEntry, FieldTable, 109&gt; FieldInfoTable;</span>
141  public:
142   typedef FieldInfoTable::HashEntry FieldInfoEntry;
143 
144  private:
145   static traceid _field_id_counter;
146   FieldInfoTable* _table;
<span class="line-added">147   const ObjectSampleFieldInfo* _lookup;</span>
148 
<span class="line-modified">149   void on_link(FieldInfoEntry* entry) {</span>
150     assert(entry != NULL, &quot;invariant&quot;);
151     entry-&gt;set_id(++_field_id_counter);
152   }
153 
<span class="line-modified">154   bool on_equals(uintptr_t hash, const FieldInfoEntry* entry) {</span>
155     assert(hash == entry-&gt;hash(), &quot;invariant&quot;);
<span class="line-modified">156     assert(_lookup != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">157     return entry-&gt;literal()-&gt;_field_modifiers == _lookup-&gt;_field_modifiers;</span>
<span class="line-modified">158   }</span>
<span class="line-modified">159 </span>
<span class="line-modified">160   void on_unlink(FieldInfoEntry* entry) {</span>
<span class="line-added">161     assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-added">162     // nothing</span>
163   }
164 
165  public:
<span class="line-modified">166   FieldTable() : _table(new FieldInfoTable(this)), _lookup(NULL) {}</span>
167   ~FieldTable() {
168     assert(_table != NULL, &quot;invariant&quot;);
169     delete _table;
170   }
171 
172   traceid store(const ObjectSampleFieldInfo* field_info) {
173     assert(field_info != NULL, &quot;invariant&quot;);
<span class="line-modified">174     _lookup = field_info;</span>
<span class="line-modified">175     const FieldInfoEntry&amp; entry = _table-&gt;lookup_put(field_info-&gt;_field_name_symbol-&gt;identity_hash(), field_info);</span>
176     return entry.id();
177   }
178 
179   size_t size() const {
180     return _table-&gt;cardinality();
181   }
182 
183   template &lt;typename T&gt;
184   void iterate(T&amp; functor) const {
185     _table-&gt;iterate_entry&lt;T&gt;(functor);
186   }
187 };
188 
189 traceid FieldTable::_field_id_counter = 0;
190 
191 typedef SampleSet&lt;const OldObjectSampleInfo*&gt; SampleInfo;
192 typedef SampleSet&lt;const ReferenceInfo*&gt; RefInfo;
193 typedef SampleSet&lt;const ObjectSampleArrayInfo*&gt; ArrayInfo;
194 typedef SampleSet&lt;const ObjectSampleRootDescriptionInfo*&gt; RootDescriptionInfo;
195 
196 static SampleInfo* sample_infos = NULL;
197 static RefInfo* ref_infos = NULL;
198 static ArrayInfo* array_infos = NULL;
199 static FieldTable* field_infos = NULL;
200 static RootDescriptionInfo* root_infos = NULL;
201 
<span class="line-modified">202 int __write_sample_info__(JfrCheckpointWriter* writer, const void* si) {</span>
203   assert(writer != NULL, &quot;invariant&quot;);
204   assert(si != NULL, &quot;invariant&quot;);
205   const OldObjectSampleInfo* const oosi = (const OldObjectSampleInfo*)si;
206   oop object = oosi-&gt;_data._object;
207   assert(object != NULL, &quot;invariant&quot;);
208   writer-&gt;write(oosi-&gt;_id);
<span class="line-modified">209   writer-&gt;write(cast_from_oop&lt;u8&gt;(object));</span>
210   writer-&gt;write(const_cast&lt;const Klass*&gt;(object-&gt;klass()));
211   ObjectSampleDescription od(object);
212   writer-&gt;write(od.description());
213   writer-&gt;write(oosi-&gt;_data._reference_id);
214   return 1;
215 }
216 
<span class="line-modified">217 typedef JfrTypeWriterImplHost&lt;const OldObjectSampleInfo*, __write_sample_info__&gt; SampleWriterImpl;</span>
<span class="line-modified">218 typedef JfrTypeWriterHost&lt;SampleWriterImpl, TYPE_OLDOBJECT&gt; SampleWriter;</span>
219 
220 static void write_sample_infos(JfrCheckpointWriter&amp; writer) {
221   if (sample_infos != NULL) {
<span class="line-modified">222     SampleWriter sw(&amp;writer);</span>
223     sample_infos-&gt;iterate(sw);
224   }
225 }
226 
<span class="line-modified">227 int __write_reference_info__(JfrCheckpointWriter* writer, const void* ri) {</span>
228   assert(writer != NULL, &quot;invariant&quot;);
229   assert(ri != NULL, &quot;invariant&quot;);
230   const ReferenceInfo* const ref_info = (const ReferenceInfo*)ri;
231   writer-&gt;write(ref_info-&gt;_id);
232   writer-&gt;write(ref_info-&gt;_data._array_info_id);
233   writer-&gt;write(ref_info-&gt;_data._field_info_id);
234   writer-&gt;write(ref_info-&gt;_data._old_object_sample_id);
235   writer-&gt;write&lt;s4&gt;((s4)ref_info-&gt;_data._skip);
236   return 1;
237 }
238 
<span class="line-modified">239 typedef JfrTypeWriterImplHost&lt;const ReferenceInfo*, __write_reference_info__&gt; ReferenceWriterImpl;</span>
<span class="line-modified">240 typedef JfrTypeWriterHost&lt;ReferenceWriterImpl, TYPE_REFERENCE&gt; ReferenceWriter;</span>
241 
242 static void write_reference_infos(JfrCheckpointWriter&amp; writer) {
243   if (ref_infos != NULL) {
<span class="line-modified">244     ReferenceWriter rw(&amp;writer);</span>
245     ref_infos-&gt;iterate(rw);
246   }
247 }
248 
<span class="line-modified">249 int __write_array_info__(JfrCheckpointWriter* writer, const void* ai) {</span>
250   assert(writer != NULL, &quot;invariant&quot;);
251   assert(ai != NULL, &quot;invariant&quot;);
252   const ObjectSampleArrayInfo* const osai = (const ObjectSampleArrayInfo*)ai;
253   writer-&gt;write(osai-&gt;_id);
254   writer-&gt;write(osai-&gt;_data._array_size);
255   writer-&gt;write(osai-&gt;_data._array_index);
256   return 1;
257 }
258 
259 static traceid get_array_info_id(const Edge&amp; edge, traceid id) {
260   if (edge.is_root() || !EdgeUtils::is_array_element(edge)) {
261     return 0;
262   }
263   if (array_infos == NULL) {
264     array_infos = new ArrayInfo();
265   }
266   assert(array_infos != NULL, &quot;invariant&quot;);
267 
268   ObjectSampleArrayInfo* const osai = new ObjectSampleArrayInfo();
269   assert(osai != NULL, &quot;invariant&quot;);
270   osai-&gt;_id = id;
271   osai-&gt;_data._array_size = EdgeUtils::array_size(edge);
272   osai-&gt;_data._array_index = EdgeUtils::array_index(edge);
273   return array_infos-&gt;store(osai);
274 }
275 
<span class="line-modified">276 typedef JfrTypeWriterImplHost&lt;const ObjectSampleArrayInfo*, __write_array_info__&gt; ArrayWriterImpl;</span>
<span class="line-modified">277 typedef JfrTypeWriterHost&lt;ArrayWriterImpl, TYPE_OLDOBJECTARRAY&gt; ArrayWriter;</span>
278 
279 static void write_array_infos(JfrCheckpointWriter&amp; writer) {
280   if (array_infos != NULL) {
<span class="line-modified">281     ArrayWriter aw(&amp;writer);</span>
282     array_infos-&gt;iterate(aw);
283   }
284 }
285 
<span class="line-modified">286 int __write_field_info__(JfrCheckpointWriter* writer, const void* fi) {</span>
287   assert(writer != NULL, &quot;invariant&quot;);
288   assert(fi != NULL, &quot;invariant&quot;);
289   const FieldTable::FieldInfoEntry* field_info_entry = (const FieldTable::FieldInfoEntry*)fi;
290   writer-&gt;write(field_info_entry-&gt;id());
291   const ObjectSampleFieldInfo* const osfi = field_info_entry-&gt;literal();
292   writer-&gt;write(osfi-&gt;_field_name_symbol-&gt;as_C_string());
293   writer-&gt;write(osfi-&gt;_field_modifiers);
294   return 1;
295 }
296 
297 static traceid get_field_info_id(const Edge&amp; edge) {
298   if (edge.is_root()) {
299     return 0;
300   }
301 
302   assert(!EdgeUtils::is_array_element(edge), &quot;invariant&quot;);
303   const Symbol* const field_name_symbol = EdgeUtils::field_name_symbol(edge);
304   if (field_name_symbol == NULL) {
305     return 0;
306   }
307 
308   if (field_infos == NULL) {
309     field_infos = new FieldTable();
310   }
311   assert(field_infos != NULL, &quot;invariant&quot;);
312 
313   ObjectSampleFieldInfo* const osfi = new ObjectSampleFieldInfo();
314   assert(osfi != NULL, &quot;invariant&quot;);
315   osfi-&gt;_field_name_symbol = field_name_symbol;
316   osfi-&gt;_field_modifiers = EdgeUtils::field_modifiers(edge);
317   return field_infos-&gt;store(osfi);
318 }
319 
<span class="line-modified">320 typedef JfrTypeWriterImplHost&lt;const FieldTable::FieldInfoEntry*, __write_field_info__&gt; FieldWriterImpl;</span>
<span class="line-modified">321 typedef JfrTypeWriterHost&lt;FieldWriterImpl, TYPE_OLDOBJECTFIELD&gt; FieldWriter;</span>
322 
323 static void write_field_infos(JfrCheckpointWriter&amp; writer) {
324   if (field_infos != NULL) {
<span class="line-modified">325     FieldWriter fw(&amp;writer);</span>
326     field_infos-&gt;iterate(fw);
327   }
328 }
329 
330 static const char* description(const ObjectSampleRootDescriptionInfo* osdi) {
331   assert(osdi != NULL, &quot;invariant&quot;);
332 
333   if (osdi-&gt;_data._description == NULL) {
334     return NULL;
335   }
336 
337   ObjectDescriptionBuilder description;
338   if (osdi-&gt;_data._system == OldObjectRoot::_threads) {
339     description.write_text(&quot;Thread Name: &quot;);
340   }
341   description.write_text(osdi-&gt;_data._description);
342   return description.description();
343 }
344 
<span class="line-modified">345 int __write_root_description_info__(JfrCheckpointWriter* writer, const void* di) {</span>
346   assert(writer != NULL, &quot;invariant&quot;);
347   assert(di != NULL, &quot;invariant&quot;);
348   const ObjectSampleRootDescriptionInfo* const osdi = (const ObjectSampleRootDescriptionInfo*)di;
349   writer-&gt;write(osdi-&gt;_id);
350   writer-&gt;write(description(osdi));
351   writer-&gt;write&lt;u8&gt;(osdi-&gt;_data._system);
352   writer-&gt;write&lt;u8&gt;(osdi-&gt;_data._type);
353   return 1;
354 }
355 
<span class="line-modified">356 static traceid get_gc_root_description_info_id(const Edge&amp; edge, traceid id) {</span>
357   assert(edge.is_root(), &quot;invariant&quot;);




358   if (root_infos == NULL) {
359     root_infos = new RootDescriptionInfo();
360   }
361   assert(root_infos != NULL, &quot;invariant&quot;);
362   ObjectSampleRootDescriptionInfo* const oodi = new ObjectSampleRootDescriptionInfo();
363   oodi-&gt;_id = id;
364   oodi-&gt;_data._root_edge = &amp;edge;
365   return root_infos-&gt;store(oodi);
366 }
367 
<span class="line-modified">368 typedef JfrTypeWriterImplHost&lt;const ObjectSampleRootDescriptionInfo*, __write_root_description_info__&gt; RootDescriptionWriterImpl;</span>
<span class="line-modified">369 typedef JfrTypeWriterHost&lt;RootDescriptionWriterImpl, TYPE_OLDOBJECTGCROOT&gt; RootDescriptionWriter;</span>
370 
371 
372 int _edge_reference_compare_(uintptr_t lhs, uintptr_t rhs) {
373   return lhs &gt; rhs ? 1 : (lhs &lt; rhs) ? -1 : 0;
374 }
375 
376 int _root_desc_compare_(const ObjectSampleRootDescriptionInfo*const &amp; lhs, const ObjectSampleRootDescriptionInfo* const&amp; rhs) {
<span class="line-modified">377   const uintptr_t lhs_ref = lhs-&gt;_data._root_edge-&gt;reference().addr&lt;uintptr_t&gt;();</span>
<span class="line-modified">378   const uintptr_t rhs_ref = rhs-&gt;_data._root_edge-&gt;reference().addr&lt;uintptr_t&gt;();</span>
379   return _edge_reference_compare_(lhs_ref, rhs_ref);
380 }
381 
382 static int find_sorted(const RootCallbackInfo&amp; callback_info,
383                        const GrowableArray&lt;const ObjectSampleRootDescriptionInfo*&gt;* arr,
384                        int length,
385                        bool&amp; found) {
386   assert(arr != NULL, &quot;invariant&quot;);
387   assert(length &gt;= 0, &quot;invariant&quot;);
388   assert(length &lt;= arr-&gt;length(), &quot;invariant&quot;);
389 
390   found = false;
391   int min = 0;
392   int max = length;
393   while (max &gt;= min) {
394     const int mid = (int)(((uint)max + min) / 2);
395     int diff = _edge_reference_compare_((uintptr_t)callback_info._high,
<span class="line-modified">396                                         arr-&gt;at(mid)-&gt;_data._root_edge-&gt;reference().addr&lt;uintptr_t&gt;());</span>
397     if (diff &gt; 0) {
398       min = mid + 1;
399     } else if (diff &lt; 0) {
400       max = mid - 1;
401     } else {
402       found = true;
403       return mid;
404     }
405   }
406   return min;
407 }
408 
409 class RootResolutionSet : public ResourceObj, public RootCallback {
410  private:
411   GrowableArray&lt;const ObjectSampleRootDescriptionInfo*&gt;* _unresolved_roots;
412 
413   const uintptr_t high() const {
<span class="line-modified">414     return _unresolved_roots-&gt;last()-&gt;_data._root_edge-&gt;reference().addr&lt;uintptr_t&gt;();</span>
415   }
416 
417   const uintptr_t low() const {
<span class="line-modified">418     return _unresolved_roots-&gt;first()-&gt;_data._root_edge-&gt;reference().addr&lt;uintptr_t&gt;();</span>
419   }
420 
421   bool in_set_address_range(const RootCallbackInfo&amp; callback_info) const {
422     assert(callback_info._low == NULL, &quot;invariant&quot;);
423     const uintptr_t addr = (uintptr_t)callback_info._high;
424     return low() &lt;= addr &amp;&amp; high() &gt;= addr;
425   }
426 
427   int compare_to_range(const RootCallbackInfo&amp; callback_info) const {
428     assert(callback_info._high != NULL, &quot;invariant&quot;);
429     assert(callback_info._low != NULL, &quot;invariant&quot;);
430 
431     for (int i = 0; i &lt; _unresolved_roots-&gt;length(); ++i) {
<span class="line-modified">432       const uintptr_t ref_addr = _unresolved_roots-&gt;at(i)-&gt;_data._root_edge-&gt;reference().addr&lt;uintptr_t&gt;();</span>
433       if ((uintptr_t)callback_info._low &lt;= ref_addr &amp;&amp; (uintptr_t)callback_info._high &gt;= ref_addr) {
434         return i;
435       }
436     }
437     return -1;
438   }
439 
440   int exact(const RootCallbackInfo&amp; callback_info) const {
441     assert(callback_info._high != NULL, &quot;invariant&quot;);
442     assert(in_set_address_range(callback_info), &quot;invariant&quot;);
443 
444     bool found;
445     const int idx = find_sorted(callback_info, _unresolved_roots, _unresolved_roots-&gt;length(), found);
446     return found ? idx : -1;
447   }
448 
449   bool resolve_root(const RootCallbackInfo&amp; callback_info, int idx) const {
450     assert(idx &gt;= 0, &quot;invariant&quot;);
451     assert(idx &lt; _unresolved_roots-&gt;length(), &quot;invariant&quot;);
452 
453     ObjectSampleRootDescriptionInfo* const desc =
454       const_cast&lt;ObjectSampleRootDescriptionInfo*&gt;(_unresolved_roots-&gt;at(idx));
455     assert(desc != NULL, &quot;invariant&quot;);
<span class="line-modified">456     assert((uintptr_t)callback_info._high == desc-&gt;_data._root_edge-&gt;reference().addr&lt;uintptr_t&gt;(), &quot;invariant&quot;);</span>
457 
458     desc-&gt;_data._system = callback_info._system;
459     desc-&gt;_data._type = callback_info._type;
460 
461     if (callback_info._system == OldObjectRoot::_threads) {
462       const JavaThread* jt = (const JavaThread*)callback_info._context;
463       assert(jt != NULL, &quot;invariant&quot;);
464       desc-&gt;_data._description = jt-&gt;name();
465     }
466 
467     _unresolved_roots-&gt;remove_at(idx);
468     return _unresolved_roots-&gt;is_empty();
469   }
470 
471  public:
472   RootResolutionSet(RootDescriptionInfo* info) : _unresolved_roots(NULL) {
473     assert(info != NULL, &quot;invariant&quot;);
474     // construct a sorted copy
475     const GrowableArray&lt;const ObjectSampleRootDescriptionInfo*&gt;&amp; info_storage = info-&gt;storage();
476     const int length = info_storage.length();
</pre>
<hr />
<pre>
482     }
483   }
484 
485   bool process(const RootCallbackInfo&amp; callback_info) {
486     if (NULL == callback_info._low) {
487       if (in_set_address_range(callback_info)) {
488         const int idx = exact(callback_info);
489         return idx == -1 ? false : resolve_root(callback_info, idx);
490       }
491       return false;
492     }
493     assert(callback_info._low != NULL, &quot;invariant&quot;);
494     const int idx = compare_to_range(callback_info);
495     return idx == -1 ? false : resolve_root(callback_info, idx);
496   }
497 
498   int entries() const {
499     return _unresolved_roots-&gt;length();
500   }
501 
<span class="line-modified">502   UnifiedOopRef at(int idx) const {</span>
503     assert(idx &gt;= 0, &quot;invariant&quot;);
504     assert(idx &lt; _unresolved_roots-&gt;length(), &quot;invariant&quot;);
505     return _unresolved_roots-&gt;at(idx)-&gt;_data._root_edge-&gt;reference();
506   }
507 };
508 
509 static void write_root_descriptors(JfrCheckpointWriter&amp; writer) {
510   if (root_infos != NULL) {
511     // resolve roots
512     RootResolutionSet rrs(root_infos);
513     RootResolver::resolve(rrs);
514     // write roots
<span class="line-modified">515     RootDescriptionWriter rw(&amp;writer);</span>
516     root_infos-&gt;iterate(rw);
517   }
518 }
519 
<span class="line-modified">520 static void add_old_object_sample_info(const StoredEdge* current, traceid id) {</span>
521   assert(current != NULL, &quot;invariant&quot;);
522   if (sample_infos == NULL) {
523     sample_infos = new SampleInfo();
524   }
525   assert(sample_infos != NULL, &quot;invariant&quot;);
526   OldObjectSampleInfo* const oosi = new OldObjectSampleInfo();
527   assert(oosi != NULL, &quot;invariant&quot;);
528   oosi-&gt;_id = id;
529   oosi-&gt;_data._object = current-&gt;pointee();
<span class="line-modified">530   oosi-&gt;_data._reference_id = current-&gt;parent() == NULL ? (traceid)0 : id;</span>
531   sample_infos-&gt;store(oosi);
532 }
533 
<span class="line-modified">534 static void add_reference_info(const StoredEdge* current, traceid id, traceid parent_id) {</span>
535   assert(current != NULL, &quot;invariant&quot;);
536   if (ref_infos == NULL) {
537     ref_infos = new RefInfo();
538   }
539 
540   assert(ref_infos != NULL, &quot;invariant&quot;);
541   ReferenceInfo* const ri = new ReferenceInfo();
542   assert(ri != NULL, &quot;invariant&quot;);
543 
544   ri-&gt;_id = id;
545   ri-&gt;_data._array_info_id =  !current-&gt;is_skip_edge() ? get_array_info_id(*current, id) : 0;
<span class="line-modified">546   ri-&gt;_data._field_info_id = ri-&gt;_data._array_info_id == 0 &amp;&amp; !current-&gt;is_skip_edge() ? get_field_info_id(*current) : (traceid)0;</span>

547   ri-&gt;_data._old_object_sample_id = parent_id;
548   ri-&gt;_data._skip = current-&gt;skip_length();
549   ref_infos-&gt;store(ri);
550 }
551 
<span class="line-modified">552 static bool is_gc_root(const StoredEdge* current) {</span>
<span class="line-added">553   assert(current != NULL, &quot;invariant&quot;);</span>
<span class="line-added">554   return current-&gt;parent() == NULL &amp;&amp; current-&gt;gc_root_id() != 0;</span>
<span class="line-added">555 }</span>
<span class="line-added">556 </span>
<span class="line-added">557 static traceid add_gc_root_info(const StoredEdge* root, traceid id) {</span>
558   assert(root != NULL, &quot;invariant&quot;);
<span class="line-modified">559   assert(is_gc_root(root), &quot;invariant&quot;);</span>
<span class="line-modified">560   return get_gc_root_description_info_id(*root, id);</span>
561 }
562 
<span class="line-modified">563 void ObjectSampleWriter::write(const StoredEdge* edge) {</span>
564   assert(edge != NULL, &quot;invariant&quot;);
565   const traceid id = _store-&gt;get_id(edge);
566   add_old_object_sample_info(edge, id);
<span class="line-modified">567   const StoredEdge* const parent = edge-&gt;parent();</span>
568   if (parent != NULL) {
569     add_reference_info(edge, id, _store-&gt;get_id(parent));
570   } else {
<span class="line-modified">571     if (is_gc_root(edge)) {</span>
<span class="line-modified">572       assert(edge-&gt;gc_root_id() == id, &quot;invariant&quot;);</span>
<span class="line-added">573       add_gc_root_info(edge, id);</span>
<span class="line-added">574     }</span>
575   }
576 }
577 
<span class="line-modified">578 class RootSystemType : public JfrSerializer {</span>
<span class="line-added">579  public:</span>
<span class="line-added">580   void serialize(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-added">581     const u4 nof_root_systems = OldObjectRoot::_number_of_systems;</span>
<span class="line-added">582     writer.write_count(nof_root_systems);</span>
<span class="line-added">583     for (u4 i = 0; i &lt; nof_root_systems; ++i) {</span>
<span class="line-added">584       writer.write_key(i);</span>
<span class="line-added">585       writer.write(OldObjectRoot::system_description((OldObjectRoot::System)i));</span>
<span class="line-added">586     }</span>
<span class="line-added">587   }</span>
<span class="line-added">588 };</span>
<span class="line-added">589 </span>
<span class="line-added">590 class RootType : public JfrSerializer {</span>
<span class="line-added">591  public:</span>
<span class="line-added">592   void serialize(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-added">593     const u4 nof_root_types = OldObjectRoot::_number_of_types;</span>
<span class="line-added">594     writer.write_count(nof_root_types);</span>
<span class="line-added">595     for (u4 i = 0; i &lt; nof_root_types; ++i) {</span>
<span class="line-added">596       writer.write_key(i);</span>
<span class="line-added">597       writer.write(OldObjectRoot::type_description((OldObjectRoot::Type)i));</span>
<span class="line-added">598     }</span>
<span class="line-added">599   }</span>
<span class="line-added">600 };</span>
<span class="line-added">601 </span>
<span class="line-added">602 static void register_serializers() {</span>
<span class="line-added">603   static bool is_registered = false;</span>
<span class="line-added">604   if (!is_registered) {</span>
<span class="line-added">605     JfrSerializer::register_serializer(TYPE_OLDOBJECTROOTSYSTEM, true, new RootSystemType());</span>
<span class="line-added">606     JfrSerializer::register_serializer(TYPE_OLDOBJECTROOTTYPE, true, new RootType());</span>
<span class="line-added">607     is_registered = true;</span>
<span class="line-added">608   }</span>
<span class="line-added">609 }</span>
<span class="line-added">610 </span>
<span class="line-added">611 ObjectSampleWriter::ObjectSampleWriter(JfrCheckpointWriter&amp; writer, EdgeStore* store) :</span>
612   _writer(writer),
613   _store(store) {
614   assert(store != NULL, &quot;invariant&quot;);
<span class="line-modified">615   assert(!store-&gt;is_empty(), &quot;invariant&quot;);</span>
<span class="line-added">616   register_serializers();</span>
617   sample_infos = NULL;
618   ref_infos = NULL;
619   array_infos = NULL;
620   field_infos = NULL;
621   root_infos = NULL;
622 }
623 
624 ObjectSampleWriter::~ObjectSampleWriter() {
625   write_sample_infos(_writer);
626   write_reference_infos(_writer);
627   write_array_infos(_writer);
628   write_field_infos(_writer);
629   write_root_descriptors(_writer);
630 }
631 
<span class="line-modified">632 bool ObjectSampleWriter::operator()(StoredEdge&amp; e) {</span>
<span class="line-modified">633   write(&amp;e);</span>



















634   return true;
635 }
</pre>
</td>
</tr>
</table>
<center><a href="objectSampleDescription.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="objectSampleWriter.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
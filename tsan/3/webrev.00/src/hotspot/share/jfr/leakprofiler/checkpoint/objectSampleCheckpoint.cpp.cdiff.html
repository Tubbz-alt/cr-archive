<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/jfr/leakprofiler/checkpoint/objectSampleCheckpoint.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../chains/rootSetClosure.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="objectSampleCheckpoint.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/leakprofiler/checkpoint/objectSampleCheckpoint.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 22,299 ***</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;jfr/jfrEvents.hpp&quot;
<span class="line-removed">- #include &quot;jfr/recorder/jfrRecorder.hpp&quot;</span>
<span class="line-removed">- #include &quot;jfr/recorder/checkpoint/jfrCheckpointWriter.hpp&quot;</span>
<span class="line-removed">- #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceId.inline.hpp&quot;</span>
<span class="line-removed">- #include &quot;jfr/recorder/stacktrace/jfrStackTraceRepository.hpp&quot;</span>
  #include &quot;jfr/leakprofiler/chains/edgeStore.hpp&quot;
  #include &quot;jfr/leakprofiler/chains/objectSampleMarker.hpp&quot;
  #include &quot;jfr/leakprofiler/checkpoint/objectSampleCheckpoint.hpp&quot;
  #include &quot;jfr/leakprofiler/checkpoint/objectSampleWriter.hpp&quot;
  #include &quot;jfr/leakprofiler/leakProfiler.hpp&quot;
  #include &quot;jfr/leakprofiler/sampling/objectSample.hpp&quot;
  #include &quot;jfr/leakprofiler/sampling/objectSampler.hpp&quot;
<span class="line-modified">! #include &quot;jfr/leakprofiler/utilities/rootType.hpp&quot;</span>
<span class="line-modified">! #include &quot;jfr/metadata/jfrSerializer.hpp&quot;</span>
<span class="line-modified">! #include &quot;runtime/interfaceSupport.inline.hpp&quot;</span>
  #include &quot;runtime/mutexLocker.hpp&quot;
<span class="line-modified">! #include &quot;runtime/thread.inline.hpp&quot;</span>
  
<span class="line-modified">! template &lt;typename SampleProcessor&gt;</span>
<span class="line-modified">! static void do_samples(ObjectSample* sample, const ObjectSample* const end, SampleProcessor&amp; processor) {</span>
<span class="line-modified">!   assert(sample != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   while (sample != end) {</span>
<span class="line-modified">!     processor.sample_do(sample);</span>
<span class="line-removed">-     sample = sample-&gt;next();</span>
<span class="line-removed">-   }</span>
  }
  
<span class="line-modified">! class RootSystemType : public JfrSerializer {</span>
<span class="line-modified">!  public:</span>
<span class="line-modified">!   void serialize(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-modified">!     const u4 nof_root_systems = OldObjectRoot::_number_of_systems;</span>
<span class="line-modified">!     writer.write_count(nof_root_systems);</span>
<span class="line-modified">!     for (u4 i = 0; i &lt; nof_root_systems; ++i) {</span>
<span class="line-removed">-       writer.write_key(i);</span>
<span class="line-removed">-       writer.write(OldObjectRoot::system_description((OldObjectRoot::System)i));</span>
<span class="line-removed">-     }</span>
    }
<span class="line-modified">! };</span>
  
<span class="line-modified">! class RootType : public JfrSerializer {</span>
<span class="line-modified">!  public:</span>
<span class="line-modified">!   void serialize(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-modified">!     const u4 nof_root_types = OldObjectRoot::_number_of_types;</span>
<span class="line-removed">-     writer.write_count(nof_root_types);</span>
<span class="line-removed">-     for (u4 i = 0; i &lt; nof_root_types; ++i) {</span>
<span class="line-removed">-       writer.write_key(i);</span>
<span class="line-removed">-       writer.write(OldObjectRoot::type_description((OldObjectRoot::Type)i));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- };</span>
  
<span class="line-modified">! class CheckpointInstall {</span>
<span class="line-removed">-  private:</span>
<span class="line-removed">-   const JfrCheckpointBlobHandle&amp; _cp;</span>
<span class="line-removed">-  public:</span>
<span class="line-removed">-   CheckpointInstall(const JfrCheckpointBlobHandle&amp; cp) : _cp(cp) {}</span>
<span class="line-removed">-   void sample_do(ObjectSample* sample) {</span>
<span class="line-removed">-     assert(sample != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-     if (!sample-&gt;is_dead()) {</span>
<span class="line-removed">-       sample-&gt;set_klass_checkpoint(_cp);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- };</span>
  
<span class="line-modified">! class CheckpointWrite {</span>
   private:
<span class="line-modified">!   JfrCheckpointWriter&amp; _writer;</span>
<span class="line-removed">-   const jlong _last_sweep;</span>
   public:
<span class="line-modified">!   CheckpointWrite(JfrCheckpointWriter&amp; writer, jlong last_sweep) : _writer(writer), _last_sweep(last_sweep) {}</span>
<span class="line-modified">!   void sample_do(ObjectSample* sample) {</span>
<span class="line-removed">-     assert(sample != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-     if (sample-&gt;is_alive_and_older_than(_last_sweep)) {</span>
<span class="line-removed">-       if (sample-&gt;has_thread_checkpoint()) {</span>
<span class="line-removed">-         const JfrCheckpointBlobHandle&amp; thread_cp = sample-&gt;thread_checkpoint();</span>
<span class="line-removed">-         thread_cp-&gt;exclusive_write(_writer);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       if (sample-&gt;has_klass_checkpoint()) {</span>
<span class="line-removed">-         const JfrCheckpointBlobHandle&amp; klass_cp = sample-&gt;klass_checkpoint();</span>
<span class="line-removed">-         klass_cp-&gt;exclusive_write(_writer);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
  };
  
<span class="line-modified">! class CheckpointStateReset {</span>
<span class="line-modified">!  private:</span>
<span class="line-modified">!   const jlong _last_sweep;</span>
<span class="line-modified">!  public:</span>
<span class="line-modified">!   CheckpointStateReset(jlong last_sweep) : _last_sweep(last_sweep) {}</span>
<span class="line-modified">!   void sample_do(ObjectSample* sample) {</span>
<span class="line-modified">!     assert(sample != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!     if (sample-&gt;is_alive_and_older_than(_last_sweep)) {</span>
<span class="line-modified">!       if (sample-&gt;has_thread_checkpoint()) {</span>
<span class="line-modified">!         const JfrCheckpointBlobHandle&amp; thread_cp = sample-&gt;thread_checkpoint();</span>
<span class="line-modified">!         thread_cp-&gt;reset_write_state();</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       if (sample-&gt;has_klass_checkpoint()) {</span>
<span class="line-removed">-         const JfrCheckpointBlobHandle&amp; klass_cp = sample-&gt;klass_checkpoint();</span>
<span class="line-removed">-         klass_cp-&gt;reset_write_state();</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
    }
<span class="line-modified">! };</span>
  
<span class="line-modified">! class StackTraceWrite {</span>
<span class="line-modified">!  private:</span>
<span class="line-modified">!   JfrStackTraceRepository&amp; _stack_trace_repo;</span>
<span class="line-modified">!   JfrCheckpointWriter&amp; _writer;</span>
<span class="line-removed">-   int _count;</span>
<span class="line-removed">-  public:</span>
<span class="line-removed">-   StackTraceWrite(JfrStackTraceRepository&amp; stack_trace_repo, JfrCheckpointWriter&amp; writer) :</span>
<span class="line-removed">-     _stack_trace_repo(stack_trace_repo), _writer(writer), _count(0) {</span>
<span class="line-removed">-     JfrStacktrace_lock-&gt;lock();</span>
    }
<span class="line-modified">!   ~StackTraceWrite() {</span>
<span class="line-modified">!     assert(JfrStacktrace_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-modified">!     JfrStacktrace_lock-&gt;unlock();</span>
    }
  
<span class="line-modified">!   void sample_do(ObjectSample* sample) {</span>
<span class="line-modified">!     assert(sample != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!     if (!sample-&gt;is_dead()) {</span>
<span class="line-modified">!       if (sample-&gt;has_stack_trace()) {</span>
<span class="line-removed">-         JfrTraceId::use(sample-&gt;klass(), true);</span>
<span class="line-removed">-         _stack_trace_repo.write(_writer, sample-&gt;stack_trace_id(), sample-&gt;stack_trace_hash());</span>
<span class="line-removed">-         ++_count;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
    }
  
<span class="line-modified">!   int count() const {</span>
<span class="line-modified">!     return _count;</span>
    }
<span class="line-modified">! };</span>
  
<span class="line-modified">! class SampleMark {</span>
   private:
    ObjectSampleMarker&amp; _marker;
    jlong _last_sweep;
    int _count;
   public:
<span class="line-modified">!   SampleMark(ObjectSampleMarker&amp; marker, jlong last_sweep) : _marker(marker),</span>
<span class="line-removed">-                                                              _last_sweep(last_sweep),</span>
<span class="line-removed">-                                                              _count(0) {}</span>
    void sample_do(ObjectSample* sample) {
<span class="line-removed">-     assert(sample != NULL, &quot;invariant&quot;);</span>
      if (sample-&gt;is_alive_and_older_than(_last_sweep)) {
        _marker.mark(sample-&gt;object());
        ++_count;
      }
    }
<span class="line-removed">- </span>
    int count() const {
      return _count;
    }
  };
  
<span class="line-modified">! void ObjectSampleCheckpoint::install(JfrCheckpointWriter&amp; writer, bool class_unload, bool resume) {</span>
<span class="line-modified">!   assert(class_unload ? SafepointSynchronize::is_at_safepoint() : LeakProfiler::is_suspended(), &quot;invariant&quot;);</span>
  
<span class="line-modified">!   if (!writer.has_data()) {</span>
<span class="line-modified">!     if (!class_unload) {</span>
<span class="line-modified">!       LeakProfiler::resume();</span>
      }
<span class="line-modified">!     assert(LeakProfiler::is_running(), &quot;invariant&quot;);</span>
      return;
    }
  
<span class="line-modified">!   assert(writer.has_data(), &quot;invariant&quot;);</span>
<span class="line-modified">!   const JfrCheckpointBlobHandle h_cp = writer.checkpoint_blob();</span>
  
<span class="line-modified">!   const ObjectSampler* const object_sampler = LeakProfiler::object_sampler();</span>
<span class="line-modified">!   assert(object_sampler != NULL, &quot;invariant&quot;);</span>
  
<span class="line-modified">!   ObjectSample* const last = const_cast&lt;ObjectSample*&gt;(object_sampler-&gt;last());</span>
<span class="line-modified">!   const ObjectSample* const last_resolved = object_sampler-&gt;last_resolved();</span>
<span class="line-modified">!   CheckpointInstall install(h_cp);</span>
  
<span class="line-modified">!   if (class_unload) {</span>
<span class="line-modified">!     if (last != NULL) {</span>
<span class="line-modified">!       // all samples need the class unload information</span>
<span class="line-modified">!       do_samples(last, NULL, install);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     assert(LeakProfiler::is_running(), &quot;invariant&quot;);</span>
      return;
    }
  
<span class="line-modified">!   // only new samples since last resolved checkpoint</span>
<span class="line-modified">!   if (last != last_resolved) {</span>
<span class="line-modified">!     do_samples(last, last_resolved, install);</span>
<span class="line-modified">!     if (resume) {</span>
<span class="line-modified">!       const_cast&lt;ObjectSampler*&gt;(object_sampler)-&gt;set_last_resolved(last);</span>
      }
    }
<span class="line-modified">!   assert(LeakProfiler::is_suspended(), &quot;invariant&quot;);</span>
<span class="line-modified">!   if (resume) {</span>
<span class="line-removed">-     LeakProfiler::resume();</span>
<span class="line-removed">-     assert(LeakProfiler::is_running(), &quot;invariant&quot;);</span>
    }
  }
  
<span class="line-modified">! void ObjectSampleCheckpoint::write(const EdgeStore* edge_store, bool emit_all, Thread* thread) {</span>
    assert(edge_store != NULL, &quot;invariant&quot;);
    assert(thread != NULL, &quot;invariant&quot;);
<span class="line-modified">!   static bool types_registered = false;</span>
<span class="line-modified">!   if (!types_registered) {</span>
<span class="line-removed">-     JfrSerializer::register_serializer(TYPE_OLDOBJECTROOTSYSTEM, false, true, new RootSystemType());</span>
<span class="line-removed">-     JfrSerializer::register_serializer(TYPE_OLDOBJECTROOTTYPE, false, true, new RootType());</span>
<span class="line-removed">-     types_registered = true;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   const ObjectSampler* const object_sampler = LeakProfiler::object_sampler();</span>
<span class="line-removed">-   assert(object_sampler != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   const jlong last_sweep = emit_all ? max_jlong : object_sampler-&gt;last_sweep().value();</span>
<span class="line-removed">-   ObjectSample* const last = const_cast&lt;ObjectSample*&gt;(object_sampler-&gt;last());</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     JfrCheckpointWriter writer(false, false, thread);</span>
<span class="line-removed">-     CheckpointWrite checkpoint_write(writer, last_sweep);</span>
<span class="line-removed">-     do_samples(last, NULL, checkpoint_write);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   CheckpointStateReset state_reset(last_sweep);</span>
<span class="line-removed">-   do_samples(last, NULL, state_reset);</span>
    if (!edge_store-&gt;is_empty()) {
<span class="line-modified">!     // java object and chain representations</span>
<span class="line-removed">-     JfrCheckpointWriter writer(false, true, thread);</span>
      ObjectSampleWriter osw(writer, edge_store);
<span class="line-modified">!     edge_store-&gt;iterate_edges(osw);</span>
    }
  }
  
<span class="line-modified">! WriteObjectSampleStacktrace::WriteObjectSampleStacktrace(JfrStackTraceRepository&amp; repo) :</span>
<span class="line-modified">!   _stack_trace_repo(repo) {</span>
  }
  
<span class="line-modified">! bool WriteObjectSampleStacktrace::process() {</span>
<span class="line-modified">!   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);</span>
<span class="line-modified">!   if (!LeakProfiler::is_running()) {</span>
<span class="line-modified">!     return true;</span>
    }
<span class="line-modified">!   // Suspend the LeakProfiler subsystem</span>
<span class="line-modified">!   // to ensure stable samples even</span>
<span class="line-modified">!   // after we return from the safepoint.</span>
<span class="line-modified">!   LeakProfiler::suspend();</span>
<span class="line-removed">-   assert(!LeakProfiler::is_running(), &quot;invariant&quot;);</span>
<span class="line-removed">-   assert(LeakProfiler::is_suspended(), &quot;invariant&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   const ObjectSampler* object_sampler = LeakProfiler::object_sampler();</span>
<span class="line-removed">-   assert(object_sampler != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   assert(LeakProfiler::is_suspended(), &quot;invariant&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   ObjectSample* const last = const_cast&lt;ObjectSample*&gt;(object_sampler-&gt;last());</span>
<span class="line-removed">-   const ObjectSample* const last_resolved = object_sampler-&gt;last_resolved();</span>
<span class="line-removed">-   if (last == last_resolved) {</span>
<span class="line-removed">-     assert(LeakProfiler::is_suspended(), &quot;invariant&quot;);</span>
<span class="line-removed">-     return true;</span>
    }
  
<span class="line-modified">!   JfrCheckpointWriter writer(false, true, Thread::current());</span>
<span class="line-modified">!   const JfrCheckpointContext ctx = writer.context();</span>
<span class="line-modified">! </span>
<span class="line-modified">!   writer.write_type(TYPE_STACKTRACE);</span>
<span class="line-removed">-   const jlong count_offset = writer.reserve(sizeof(u4));</span>
  
<span class="line-modified">!   int count = 0;</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     StackTraceWrite stack_trace_write(_stack_trace_repo, writer); // JfrStacktrace_lock</span>
<span class="line-modified">!     do_samples(last, last_resolved, stack_trace_write);</span>
<span class="line-modified">!     count = stack_trace_write.count();</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (count == 0) {</span>
<span class="line-removed">-     writer.set_context(ctx);</span>
<span class="line-removed">-     assert(LeakProfiler::is_suspended(), &quot;invariant&quot;);</span>
<span class="line-removed">-     return true;</span>
    }
<span class="line-modified">!   assert(count &gt; 0, &quot;invariant&quot;);</span>
<span class="line-removed">-   writer.write_count((u4)count, count_offset);</span>
<span class="line-removed">-   JfrStackTraceRepository::write_metadata(writer);</span>
  
<span class="line-modified">!   ObjectSampleCheckpoint::install(writer, false, false);</span>
<span class="line-modified">!   assert(LeakProfiler::is_suspended(), &quot;invariant&quot;);</span>
<span class="line-modified">!   return true;</span>
  }
  
<span class="line-modified">! int ObjectSampleCheckpoint::mark(ObjectSampleMarker&amp; marker, bool emit_all) {</span>
<span class="line-modified">!   const ObjectSampler* object_sampler = LeakProfiler::object_sampler();</span>
<span class="line-modified">!   assert(object_sampler != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   ObjectSample* const last = const_cast&lt;ObjectSample*&gt;(object_sampler-&gt;last());</span>
<span class="line-modified">!   if (last == NULL) {</span>
<span class="line-removed">-     return 0;</span>
    }
<span class="line-removed">-   const jlong last_sweep = emit_all ? max_jlong : object_sampler-&gt;last_sweep().value();</span>
<span class="line-removed">-   SampleMark mark(marker, last_sweep);</span>
<span class="line-removed">-   do_samples(last, NULL, mark);</span>
<span class="line-removed">-   return mark.count();</span>
  }
<span class="line-new-header">--- 22,461 ---</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;jfr/jfrEvents.hpp&quot;
  #include &quot;jfr/leakprofiler/chains/edgeStore.hpp&quot;
  #include &quot;jfr/leakprofiler/chains/objectSampleMarker.hpp&quot;
  #include &quot;jfr/leakprofiler/checkpoint/objectSampleCheckpoint.hpp&quot;
  #include &quot;jfr/leakprofiler/checkpoint/objectSampleWriter.hpp&quot;
  #include &quot;jfr/leakprofiler/leakProfiler.hpp&quot;
  #include &quot;jfr/leakprofiler/sampling/objectSample.hpp&quot;
  #include &quot;jfr/leakprofiler/sampling/objectSampler.hpp&quot;
<span class="line-modified">! #include &quot;jfr/recorder/checkpoint/jfrCheckpointWriter.hpp&quot;</span>
<span class="line-modified">! #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceId.inline.hpp&quot;</span>
<span class="line-modified">! #include &quot;jfr/recorder/service/jfrOptionSet.hpp&quot;</span>
<span class="line-added">+ #include &quot;jfr/recorder/stacktrace/jfrStackTraceRepository.hpp&quot;</span>
<span class="line-added">+ #include &quot;jfr/support/jfrMethodLookup.hpp&quot;</span>
<span class="line-added">+ #include &quot;jfr/utilities/jfrHashtable.hpp&quot;</span>
<span class="line-added">+ #include &quot;jfr/utilities/jfrTypes.hpp&quot;</span>
<span class="line-added">+ #include &quot;oops/instanceKlass.inline.hpp&quot;</span>
  #include &quot;runtime/mutexLocker.hpp&quot;
<span class="line-modified">! #include &quot;runtime/safepoint.hpp&quot;</span>
<span class="line-added">+ #include &quot;runtime/thread.hpp&quot;</span>
<span class="line-added">+ #include &quot;utilities/growableArray.hpp&quot;</span>
  
<span class="line-modified">! static bool predicate(GrowableArray&lt;traceid&gt;* set, traceid id) {</span>
<span class="line-modified">!   assert(set != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   bool found = false;</span>
<span class="line-modified">!   set-&gt;find_sorted&lt;traceid, compare_traceid&gt;(id, found);</span>
<span class="line-modified">!   return found;</span>
  }
  
<span class="line-modified">! static bool mutable_predicate(GrowableArray&lt;traceid&gt;* set, traceid id) {</span>
<span class="line-modified">!   assert(set != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   bool found = false;</span>
<span class="line-modified">!   const int location = set-&gt;find_sorted&lt;traceid, compare_traceid&gt;(id, found);</span>
<span class="line-modified">!   if (!found) {</span>
<span class="line-modified">!     set-&gt;insert_before(location, id);</span>
    }
<span class="line-modified">!   return found;</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! static bool add(GrowableArray&lt;traceid&gt;* set, traceid id) {</span>
<span class="line-modified">!   assert(set != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   return mutable_predicate(set, id);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! const int initial_array_size = 64;</span>
  
<span class="line-modified">! template &lt;typename T&gt;</span>
<span class="line-added">+ static GrowableArray&lt;T&gt;* c_heap_allocate_array(int size = initial_array_size) {</span>
<span class="line-added">+   return new (ResourceObj::C_HEAP, mtTracing) GrowableArray&lt;T&gt;(size, true, mtTracing);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static GrowableArray&lt;traceid&gt;* unloaded_thread_id_set = NULL;</span>
<span class="line-added">+ </span>
<span class="line-added">+ class ThreadIdExclusiveAccess : public StackObj {</span>
   private:
<span class="line-modified">!   static Semaphore _mutex_semaphore;</span>
   public:
<span class="line-modified">!   ThreadIdExclusiveAccess() { _mutex_semaphore.wait(); }</span>
<span class="line-modified">!   ~ThreadIdExclusiveAccess() { _mutex_semaphore.signal(); }</span>
  };
  
<span class="line-modified">! Semaphore ThreadIdExclusiveAccess::_mutex_semaphore(1);</span>
<span class="line-modified">! </span>
<span class="line-modified">! static bool has_thread_exited(traceid tid) {</span>
<span class="line-modified">!   assert(tid != 0, &quot;invariant&quot;);</span>
<span class="line-modified">!   return unloaded_thread_id_set != NULL &amp;&amp; predicate(unloaded_thread_id_set, tid);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! static void add_to_unloaded_thread_set(traceid tid) {</span>
<span class="line-modified">!   ThreadIdExclusiveAccess lock;</span>
<span class="line-modified">!   if (unloaded_thread_id_set == NULL) {</span>
<span class="line-modified">!     unloaded_thread_id_set = c_heap_allocate_array&lt;traceid&gt;();</span>
    }
<span class="line-modified">!   add(unloaded_thread_id_set, tid);</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! void ObjectSampleCheckpoint::on_thread_exit(JavaThread* jt) {</span>
<span class="line-modified">!   assert(jt != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   if (LeakProfiler::is_running()) {</span>
<span class="line-modified">!     add_to_unloaded_thread_set(jt-&gt;jfr_thread_local()-&gt;thread_id());</span>
    }
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! // Track the set of unloaded klasses during a chunk / epoch.</span>
<span class="line-added">+ // Methods in stacktraces belonging to unloaded klasses must not be accessed.</span>
<span class="line-added">+ static GrowableArray&lt;traceid&gt;* unloaded_klass_set = NULL;</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void add_to_unloaded_klass_set(traceid klass_id) {</span>
<span class="line-added">+   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);</span>
<span class="line-added">+   if (unloaded_klass_set == NULL) {</span>
<span class="line-added">+     unloaded_klass_set = c_heap_allocate_array&lt;traceid&gt;();</span>
    }
<span class="line-added">+   unloaded_klass_set-&gt;append(klass_id);</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! static void sort_unloaded_klass_set() {</span>
<span class="line-modified">!   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);</span>
<span class="line-modified">!   if (unloaded_klass_set != NULL &amp;&amp; unloaded_klass_set-&gt;length() &gt; 1) {</span>
<span class="line-modified">!     unloaded_klass_set-&gt;sort(sort_traceid);</span>
    }
<span class="line-added">+ }</span>
  
<span class="line-modified">! void ObjectSampleCheckpoint::on_klass_unload(const Klass* k) {</span>
<span class="line-modified">!   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);</span>
<span class="line-added">+   assert(k != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   add_to_unloaded_klass_set(JfrTraceId::get(k));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename Processor&gt;</span>
<span class="line-added">+ static void do_samples(ObjectSample* sample, const ObjectSample* end, Processor&amp; processor) {</span>
<span class="line-added">+   assert(sample != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   while (sample != end) {</span>
<span class="line-added">+     processor.sample_do(sample);</span>
<span class="line-added">+     sample = sample-&gt;next();</span>
    }
<span class="line-modified">! }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename Processor&gt;</span>
<span class="line-added">+ static void iterate_samples(Processor&amp; processor, bool all = false) {</span>
<span class="line-added">+   ObjectSampler* const sampler = ObjectSampler::sampler();</span>
<span class="line-added">+   assert(sampler != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   ObjectSample* const last = sampler-&gt;last();</span>
<span class="line-added">+   assert(last != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   do_samples(last, all ? NULL : sampler-&gt;last_resolved(), processor);</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! class SampleMarker {</span>
   private:
    ObjectSampleMarker&amp; _marker;
    jlong _last_sweep;
    int _count;
   public:
<span class="line-modified">!   SampleMarker(ObjectSampleMarker&amp; marker, jlong last_sweep) : _marker(marker), _last_sweep(last_sweep), _count(0) {}</span>
    void sample_do(ObjectSample* sample) {
      if (sample-&gt;is_alive_and_older_than(_last_sweep)) {
        _marker.mark(sample-&gt;object());
        ++_count;
      }
    }
    int count() const {
      return _count;
    }
  };
  
<span class="line-modified">! int ObjectSampleCheckpoint::save_mark_words(const ObjectSampler* sampler, ObjectSampleMarker&amp; marker, bool emit_all) {</span>
<span class="line-modified">!   assert(sampler != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   if (sampler-&gt;last() == NULL) {</span>
<span class="line-added">+     return 0;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   SampleMarker sample_marker(marker, emit_all ? max_jlong : sampler-&gt;last_sweep().value());</span>
<span class="line-added">+   iterate_samples(sample_marker, true);</span>
<span class="line-added">+   return sample_marker.count();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ class BlobCache {</span>
<span class="line-added">+   typedef HashTableHost&lt;JfrBlobHandle, traceid, JfrHashtableEntry, BlobCache&gt; BlobTable;</span>
<span class="line-added">+   typedef BlobTable::HashEntry BlobEntry;</span>
<span class="line-added">+  private:</span>
<span class="line-added">+   BlobTable _table;</span>
<span class="line-added">+   traceid _lookup_id;</span>
<span class="line-added">+  public:</span>
<span class="line-added">+   BlobCache(size_t size) : _table(this, size), _lookup_id(0) {}</span>
<span class="line-added">+   JfrBlobHandle get(const ObjectSample* sample);</span>
<span class="line-added">+   void put(const ObjectSample* sample, const JfrBlobHandle&amp; blob);</span>
<span class="line-added">+   // Hash table callbacks</span>
<span class="line-added">+   void on_link(const BlobEntry* entry) const;</span>
<span class="line-added">+   bool on_equals(uintptr_t hash, const BlobEntry* entry) const;</span>
<span class="line-added">+   void on_unlink(BlobEntry* entry) const;</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ JfrBlobHandle BlobCache::get(const ObjectSample* sample) {</span>
<span class="line-added">+   assert(sample != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   _lookup_id = sample-&gt;stack_trace_id();</span>
<span class="line-added">+   assert(_lookup_id != 0, &quot;invariant&quot;);</span>
<span class="line-added">+   BlobEntry* const entry = _table.lookup_only(sample-&gt;stack_trace_hash());</span>
<span class="line-added">+   return entry != NULL ? entry-&gt;literal() : JfrBlobHandle();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void BlobCache::put(const ObjectSample* sample, const JfrBlobHandle&amp; blob) {</span>
<span class="line-added">+   assert(sample != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(_table.lookup_only(sample-&gt;stack_trace_hash()) == NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   _lookup_id = sample-&gt;stack_trace_id();</span>
<span class="line-added">+   assert(_lookup_id != 0, &quot;invariant&quot;);</span>
<span class="line-added">+   _table.put(sample-&gt;stack_trace_hash(), blob);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline void BlobCache::on_link(const BlobEntry* entry) const {</span>
<span class="line-added">+   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(entry-&gt;id() == 0, &quot;invariant&quot;);</span>
<span class="line-added">+   entry-&gt;set_id(_lookup_id);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline bool BlobCache::on_equals(uintptr_t hash, const BlobEntry* entry) const {</span>
<span class="line-added">+   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(entry-&gt;hash() == hash, &quot;invariant&quot;);</span>
<span class="line-added">+   return entry-&gt;id() == _lookup_id;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline void BlobCache::on_unlink(BlobEntry* entry) const {</span>
<span class="line-added">+   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static GrowableArray&lt;traceid&gt;* id_set = NULL;</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void prepare_for_resolution() {</span>
<span class="line-added">+   id_set = new GrowableArray&lt;traceid&gt;(JfrOptionSet::old_object_queue_size());</span>
<span class="line-added">+   sort_unloaded_klass_set();</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! static bool stack_trace_precondition(const ObjectSample* sample) {</span>
<span class="line-modified">!   assert(sample != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   return sample-&gt;has_stack_trace_id() &amp;&amp; !sample-&gt;is_dead();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ class StackTraceBlobInstaller {</span>
<span class="line-added">+  private:</span>
<span class="line-added">+   const JfrStackTraceRepository&amp; _stack_trace_repo;</span>
<span class="line-added">+   BlobCache _cache;</span>
<span class="line-added">+   const JfrStackTrace* resolve(const ObjectSample* sample);</span>
<span class="line-added">+   void install(ObjectSample* sample);</span>
<span class="line-added">+  public:</span>
<span class="line-added">+   StackTraceBlobInstaller(const JfrStackTraceRepository&amp; stack_trace_repo);</span>
<span class="line-added">+   void sample_do(ObjectSample* sample) {</span>
<span class="line-added">+     if (stack_trace_precondition(sample)) {</span>
<span class="line-added">+       install(sample);</span>
      }
<span class="line-modified">!   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ StackTraceBlobInstaller::StackTraceBlobInstaller(const JfrStackTraceRepository&amp; stack_trace_repo) :</span>
<span class="line-added">+   _stack_trace_repo(stack_trace_repo), _cache(JfrOptionSet::old_object_queue_size()) {</span>
<span class="line-added">+   prepare_for_resolution();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ const JfrStackTrace* StackTraceBlobInstaller::resolve(const ObjectSample* sample) {</span>
<span class="line-added">+   return _stack_trace_repo.lookup(sample-&gt;stack_trace_hash(), sample-&gt;stack_trace_id());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #ifdef ASSERT</span>
<span class="line-added">+ static void validate_stack_trace(const ObjectSample* sample, const JfrStackTrace* stack_trace) {</span>
<span class="line-added">+   assert(!sample-&gt;has_stacktrace(), &quot;invariant&quot;);</span>
<span class="line-added">+   assert(stack_trace != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(stack_trace-&gt;hash() == sample-&gt;stack_trace_hash(), &quot;invariant&quot;);</span>
<span class="line-added">+   assert(stack_trace-&gt;id() == sample-&gt;stack_trace_id(), &quot;invariant&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ void StackTraceBlobInstaller::install(ObjectSample* sample) {</span>
<span class="line-added">+   JfrBlobHandle blob = _cache.get(sample);</span>
<span class="line-added">+   if (blob.valid()) {</span>
<span class="line-added">+     sample-&gt;set_stacktrace(blob);</span>
      return;
    }
<span class="line-added">+   const JfrStackTrace* const stack_trace = resolve(sample);</span>
<span class="line-added">+   DEBUG_ONLY(validate_stack_trace(sample, stack_trace));</span>
<span class="line-added">+   JfrCheckpointWriter writer;</span>
<span class="line-added">+   writer.write_type(TYPE_STACKTRACE);</span>
<span class="line-added">+   writer.write_count(1);</span>
<span class="line-added">+   ObjectSampleCheckpoint::write_stacktrace(stack_trace, writer);</span>
<span class="line-added">+   blob = writer.move();</span>
<span class="line-added">+   _cache.put(sample, blob);</span>
<span class="line-added">+   sample-&gt;set_stacktrace(blob);</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! static void install_stack_traces(const ObjectSampler* sampler, JfrStackTraceRepository&amp; stack_trace_repo) {</span>
<span class="line-modified">!   assert(sampler != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   const ObjectSample* const last = sampler-&gt;last();</span>
<span class="line-added">+   if (last != sampler-&gt;last_resolved()) {</span>
<span class="line-added">+     StackTraceBlobInstaller installer(stack_trace_repo);</span>
<span class="line-added">+     iterate_samples(installer);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! // caller needs ResourceMark</span>
<span class="line-modified">! void ObjectSampleCheckpoint::on_rotation(const ObjectSampler* sampler, JfrStackTraceRepository&amp; stack_trace_repo) {</span>
<span class="line-added">+   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-added">+   assert(sampler != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(LeakProfiler::is_running(), &quot;invariant&quot;);</span>
<span class="line-added">+   MutexLocker lock(ClassLoaderDataGraph_lock);</span>
<span class="line-added">+   // the lock is needed to ensure the unload lists do not grow in the middle of inspection.</span>
<span class="line-added">+   install_stack_traces(sampler, stack_trace_repo);</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! static bool is_klass_unloaded(traceid klass_id) {</span>
<span class="line-modified">!   assert(ClassLoaderDataGraph_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-modified">!   return unloaded_klass_set != NULL &amp;&amp; predicate(unloaded_klass_set, klass_id);</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! static bool is_processed(traceid method_id) {</span>
<span class="line-modified">!   assert(method_id != 0, &quot;invariant&quot;);</span>
<span class="line-modified">!   assert(id_set != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   return mutable_predicate(id_set, method_id);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-added">+ void ObjectSampleCheckpoint::add_to_leakp_set(const InstanceKlass* ik, traceid method_id) {</span>
<span class="line-added">+   assert(ik != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   if (is_processed(method_id) || is_klass_unloaded(JfrMethodLookup::klass_id(method_id))) {</span>
      return;
    }
<span class="line-added">+   const Method* const method = JfrMethodLookup::lookup(ik, method_id);</span>
<span class="line-added">+   assert(method != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(method-&gt;method_holder() == ik, &quot;invariant&quot;);</span>
<span class="line-added">+   JfrTraceId::set_leakp(ik, method);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ObjectSampleCheckpoint::write_stacktrace(const JfrStackTrace* trace, JfrCheckpointWriter&amp; writer) {</span>
<span class="line-added">+   assert(trace != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   // JfrStackTrace</span>
<span class="line-added">+   writer.write(trace-&gt;id());</span>
<span class="line-added">+   writer.write((u1)!trace-&gt;_reached_root);</span>
<span class="line-added">+   writer.write(trace-&gt;_nr_of_frames);</span>
<span class="line-added">+   // JfrStackFrames</span>
<span class="line-added">+   for (u4 i = 0; i &lt; trace-&gt;_nr_of_frames; ++i) {</span>
<span class="line-added">+     const JfrStackFrame&amp; frame = trace-&gt;_frames[i];</span>
<span class="line-added">+     frame.write(writer);</span>
<span class="line-added">+     add_to_leakp_set(frame._klass, frame._methodid);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! static void write_blob(const JfrBlobHandle&amp; blob, JfrCheckpointWriter&amp; writer, bool reset) {</span>
<span class="line-modified">!   if (reset) {</span>
<span class="line-modified">!     blob-&gt;reset_write_state();</span>
<span class="line-modified">!     return;</span>
<span class="line-modified">!   }</span>
<span class="line-added">+   blob-&gt;exclusive_write(writer);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void write_type_set_blob(const ObjectSample* sample, JfrCheckpointWriter&amp; writer, bool reset) {</span>
<span class="line-added">+   if (sample-&gt;has_type_set()) {</span>
<span class="line-added">+     write_blob(sample-&gt;type_set(), writer, reset);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void write_thread_blob(const ObjectSample* sample, JfrCheckpointWriter&amp; writer, bool reset) {</span>
<span class="line-added">+   assert(sample-&gt;has_thread(), &quot;invariant&quot;);</span>
<span class="line-added">+   if (has_thread_exited(sample-&gt;thread_id())) {</span>
<span class="line-added">+     write_blob(sample-&gt;thread(), writer, reset);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void write_stacktrace_blob(const ObjectSample* sample, JfrCheckpointWriter&amp; writer, bool reset) {</span>
<span class="line-added">+   if (sample-&gt;has_stacktrace()) {</span>
<span class="line-added">+     write_blob(sample-&gt;stacktrace(), writer, reset);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void write_blobs(const ObjectSample* sample, JfrCheckpointWriter&amp; writer, bool reset) {</span>
<span class="line-added">+   assert(sample != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   write_stacktrace_blob(sample, writer, reset);</span>
<span class="line-added">+   write_thread_blob(sample, writer, reset);</span>
<span class="line-added">+   write_type_set_blob(sample, writer, reset);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ class BlobWriter {</span>
<span class="line-added">+  private:</span>
<span class="line-added">+   const ObjectSampler* _sampler;</span>
<span class="line-added">+   JfrCheckpointWriter&amp; _writer;</span>
<span class="line-added">+   const jlong _last_sweep;</span>
<span class="line-added">+   bool _reset;</span>
<span class="line-added">+  public:</span>
<span class="line-added">+   BlobWriter(const ObjectSampler* sampler, JfrCheckpointWriter&amp; writer, jlong last_sweep) :</span>
<span class="line-added">+     _sampler(sampler), _writer(writer), _last_sweep(last_sweep), _reset(false)  {}</span>
<span class="line-added">+   void sample_do(ObjectSample* sample) {</span>
<span class="line-added">+     if (sample-&gt;is_alive_and_older_than(_last_sweep)) {</span>
<span class="line-added">+       write_blobs(sample, _writer, _reset);</span>
      }
    }
<span class="line-modified">!   void set_reset() {</span>
<span class="line-modified">!     _reset = true;</span>
    }
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void write_sample_blobs(const ObjectSampler* sampler, bool emit_all, Thread* thread) {</span>
<span class="line-added">+   // sample set is predicated on time of last sweep</span>
<span class="line-added">+   const jlong last_sweep = emit_all ? max_jlong : sampler-&gt;last_sweep().value();</span>
<span class="line-added">+   JfrCheckpointWriter writer(thread, false);</span>
<span class="line-added">+   BlobWriter cbw(sampler, writer, last_sweep);</span>
<span class="line-added">+   iterate_samples(cbw, true);</span>
<span class="line-added">+   // reset blob write states</span>
<span class="line-added">+   cbw.set_reset();</span>
<span class="line-added">+   iterate_samples(cbw, true);</span>
  }
  
<span class="line-modified">! void ObjectSampleCheckpoint::write(const ObjectSampler* sampler, EdgeStore* edge_store, bool emit_all, Thread* thread) {</span>
<span class="line-added">+   assert_locked_or_safepoint(JfrStream_lock);</span>
<span class="line-added">+   assert(sampler != NULL, &quot;invariant&quot;);</span>
    assert(edge_store != NULL, &quot;invariant&quot;);
    assert(thread != NULL, &quot;invariant&quot;);
<span class="line-modified">!   write_sample_blobs(sampler, emit_all, thread);</span>
<span class="line-modified">!   // write reference chains</span>
    if (!edge_store-&gt;is_empty()) {
<span class="line-modified">!     JfrCheckpointWriter writer(thread);</span>
      ObjectSampleWriter osw(writer, edge_store);
<span class="line-modified">!     edge_store-&gt;iterate(osw);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void clear_unloaded_klass_set() {</span>
<span class="line-added">+   assert(ClassLoaderDataGraph_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-added">+   if (unloaded_klass_set != NULL &amp;&amp; unloaded_klass_set-&gt;is_nonempty()) {</span>
<span class="line-added">+     unloaded_klass_set-&gt;clear();</span>
    }
  }
  
<span class="line-modified">! // A linked list of saved type set blobs for the epoch.</span>
<span class="line-modified">! // The link consist of a reference counted handle.</span>
<span class="line-added">+ static JfrBlobHandle saved_type_set_blobs;</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void release_state_for_previous_epoch() {</span>
<span class="line-added">+   // decrements the reference count and the list is reinitialized</span>
<span class="line-added">+   saved_type_set_blobs = JfrBlobHandle();</span>
<span class="line-added">+   clear_unloaded_klass_set();</span>
  }
  
<span class="line-modified">! class BlobInstaller {</span>
<span class="line-modified">!  public:</span>
<span class="line-modified">!   ~BlobInstaller() {</span>
<span class="line-modified">!     release_state_for_previous_epoch();</span>
    }
<span class="line-modified">!   void sample_do(ObjectSample* sample) {</span>
<span class="line-modified">!     if (!sample-&gt;is_dead()) {</span>
<span class="line-modified">!       sample-&gt;set_type_set(saved_type_set_blobs);</span>
<span class="line-modified">!     }</span>
    }
<span class="line-added">+ };</span>
  
<span class="line-modified">! static void install_type_set_blobs() {</span>
<span class="line-modified">!   BlobInstaller installer;</span>
<span class="line-modified">!   iterate_samples(installer);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! static void save_type_set_blob(JfrCheckpointWriter&amp; writer, bool copy = false) {</span>
<span class="line-modified">!   assert(writer.has_data(), &quot;invariant&quot;);</span>
<span class="line-modified">!   const JfrBlobHandle blob = copy ? writer.copy() : writer.move();</span>
<span class="line-modified">!   if (saved_type_set_blobs.valid()) {</span>
<span class="line-modified">!     saved_type_set_blobs-&gt;set_next(blob);</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     saved_type_set_blobs = blob;</span>
    }
<span class="line-modified">! }</span>
  
<span class="line-modified">! void ObjectSampleCheckpoint::on_type_set(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-modified">!   assert(LeakProfiler::is_running(), &quot;invariant&quot;);</span>
<span class="line-modified">!   const ObjectSample* last = ObjectSampler::sampler()-&gt;last();</span>
<span class="line-added">+   if (writer.has_data() &amp;&amp; last != NULL) {</span>
<span class="line-added">+     save_type_set_blob(writer);</span>
<span class="line-added">+     install_type_set_blobs();</span>
<span class="line-added">+     ObjectSampler::sampler()-&gt;set_last_resolved(last);</span>
<span class="line-added">+   }</span>
  }
  
<span class="line-modified">! void ObjectSampleCheckpoint::on_type_set_unload(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-modified">!   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);</span>
<span class="line-modified">!   assert(LeakProfiler::is_running(), &quot;invariant&quot;);</span>
<span class="line-modified">!   if (writer.has_data() &amp;&amp; ObjectSampler::sampler()-&gt;last() != NULL) {</span>
<span class="line-modified">!     save_type_set_blob(writer, true);</span>
    }
  }
</pre>
<center><a href="../chains/rootSetClosure.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="objectSampleCheckpoint.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
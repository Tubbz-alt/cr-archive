<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jfr/leakprofiler/checkpoint/objectSampleCheckpoint.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/jfrEvents.hpp&quot;
<a name="2" id="anc2"></a>



 27 #include &quot;jfr/leakprofiler/chains/edgeStore.hpp&quot;
 28 #include &quot;jfr/leakprofiler/chains/objectSampleMarker.hpp&quot;
 29 #include &quot;jfr/leakprofiler/checkpoint/objectSampleCheckpoint.hpp&quot;
 30 #include &quot;jfr/leakprofiler/checkpoint/objectSampleWriter.hpp&quot;
 31 #include &quot;jfr/leakprofiler/leakProfiler.hpp&quot;
 32 #include &quot;jfr/leakprofiler/sampling/objectSample.hpp&quot;
 33 #include &quot;jfr/leakprofiler/sampling/objectSampler.hpp&quot;
<a name="3" id="anc3"></a><span class="line-modified"> 34 #include &quot;jfr/recorder/checkpoint/jfrCheckpointWriter.hpp&quot;</span>
<span class="line-modified"> 35 #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceId.inline.hpp&quot;</span>
<span class="line-modified"> 36 #include &quot;jfr/recorder/service/jfrOptionSet.hpp&quot;</span>
<span class="line-added"> 37 #include &quot;jfr/recorder/stacktrace/jfrStackTraceRepository.hpp&quot;</span>
<span class="line-added"> 38 #include &quot;jfr/support/jfrMethodLookup.hpp&quot;</span>
<span class="line-added"> 39 #include &quot;jfr/utilities/jfrHashtable.hpp&quot;</span>
<span class="line-added"> 40 #include &quot;jfr/utilities/jfrTypes.hpp&quot;</span>
<span class="line-added"> 41 #include &quot;oops/instanceKlass.inline.hpp&quot;</span>
 42 #include &quot;runtime/mutexLocker.hpp&quot;
<a name="4" id="anc4"></a><span class="line-modified"> 43 #include &quot;runtime/safepoint.hpp&quot;</span>
<span class="line-added"> 44 #include &quot;runtime/thread.hpp&quot;</span>
<span class="line-added"> 45 #include &quot;utilities/growableArray.hpp&quot;</span>
 46 
<a name="5" id="anc5"></a><span class="line-modified"> 47 static bool predicate(GrowableArray&lt;traceid&gt;* set, traceid id) {</span>
<span class="line-modified"> 48   assert(set != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 49   bool found = false;</span>
<span class="line-modified"> 50   set-&gt;find_sorted&lt;traceid, compare_traceid&gt;(id, found);</span>
<span class="line-modified"> 51   return found;</span>


 52 }
 53 
<a name="6" id="anc6"></a><span class="line-modified"> 54 static bool mutable_predicate(GrowableArray&lt;traceid&gt;* set, traceid id) {</span>
<span class="line-modified"> 55   assert(set != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 56   bool found = false;</span>
<span class="line-modified"> 57   const int location = set-&gt;find_sorted&lt;traceid, compare_traceid&gt;(id, found);</span>
<span class="line-modified"> 58   if (!found) {</span>
<span class="line-modified"> 59     set-&gt;insert_before(location, id);</span>



 60   }
<a name="7" id="anc7"></a><span class="line-modified"> 61   return found;</span>
<span class="line-added"> 62 }</span>
 63 
<a name="8" id="anc8"></a><span class="line-modified"> 64 static bool add(GrowableArray&lt;traceid&gt;* set, traceid id) {</span>
<span class="line-modified"> 65   assert(set != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 66   return mutable_predicate(set, id);</span>
<span class="line-modified"> 67 }</span>







 68 
<a name="9" id="anc9"></a><span class="line-modified"> 69 const int initial_array_size = 64;</span>











 70 
<a name="10" id="anc10"></a><span class="line-modified"> 71 template &lt;typename T&gt;</span>
<span class="line-added"> 72 static GrowableArray&lt;T&gt;* c_heap_allocate_array(int size = initial_array_size) {</span>
<span class="line-added"> 73   return new (ResourceObj::C_HEAP, mtTracing) GrowableArray&lt;T&gt;(size, true, mtTracing);</span>
<span class="line-added"> 74 }</span>
<span class="line-added"> 75 </span>
<span class="line-added"> 76 static GrowableArray&lt;traceid&gt;* unloaded_thread_id_set = NULL;</span>
<span class="line-added"> 77 </span>
<span class="line-added"> 78 class ThreadIdExclusiveAccess : public StackObj {</span>
 79  private:
<a name="11" id="anc11"></a><span class="line-modified"> 80   static Semaphore _mutex_semaphore;</span>

 81  public:
<a name="12" id="anc12"></a><span class="line-modified"> 82   ThreadIdExclusiveAccess() { _mutex_semaphore.wait(); }</span>
<span class="line-modified"> 83   ~ThreadIdExclusiveAccess() { _mutex_semaphore.signal(); }</span>












 84 };
 85 
<a name="13" id="anc13"></a><span class="line-modified"> 86 Semaphore ThreadIdExclusiveAccess::_mutex_semaphore(1);</span>
<span class="line-modified"> 87 </span>
<span class="line-modified"> 88 static bool has_thread_exited(traceid tid) {</span>
<span class="line-modified"> 89   assert(tid != 0, &quot;invariant&quot;);</span>
<span class="line-modified"> 90   return unloaded_thread_id_set != NULL &amp;&amp; predicate(unloaded_thread_id_set, tid);</span>
<span class="line-modified"> 91 }</span>
<span class="line-modified"> 92 </span>
<span class="line-modified"> 93 static void add_to_unloaded_thread_set(traceid tid) {</span>
<span class="line-modified"> 94   ThreadIdExclusiveAccess lock;</span>
<span class="line-modified"> 95   if (unloaded_thread_id_set == NULL) {</span>
<span class="line-modified"> 96     unloaded_thread_id_set = c_heap_allocate_array&lt;traceid&gt;();</span>






 97   }
<a name="14" id="anc14"></a><span class="line-modified"> 98   add(unloaded_thread_id_set, tid);</span>
<span class="line-added"> 99 }</span>
100 
<a name="15" id="anc15"></a><span class="line-modified">101 void ObjectSampleCheckpoint::on_thread_exit(JavaThread* jt) {</span>
<span class="line-modified">102   assert(jt != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">103   if (LeakProfiler::is_running()) {</span>
<span class="line-modified">104     add_to_unloaded_thread_set(jt-&gt;jfr_thread_local()-&gt;thread_id());</span>





105   }
<a name="16" id="anc16"></a><span class="line-modified">106 }</span>
<span class="line-modified">107 </span>
<span class="line-modified">108 // Track the set of unloaded klasses during a chunk / epoch.</span>
<span class="line-added">109 // Methods in stacktraces belonging to unloaded klasses must not be accessed.</span>
<span class="line-added">110 static GrowableArray&lt;traceid&gt;* unloaded_klass_set = NULL;</span>
<span class="line-added">111 </span>
<span class="line-added">112 static void add_to_unloaded_klass_set(traceid klass_id) {</span>
<span class="line-added">113   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);</span>
<span class="line-added">114   if (unloaded_klass_set == NULL) {</span>
<span class="line-added">115     unloaded_klass_set = c_heap_allocate_array&lt;traceid&gt;();</span>
116   }
<a name="17" id="anc17"></a><span class="line-added">117   unloaded_klass_set-&gt;append(klass_id);</span>
<span class="line-added">118 }</span>
119 
<a name="18" id="anc18"></a><span class="line-modified">120 static void sort_unloaded_klass_set() {</span>
<span class="line-modified">121   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);</span>
<span class="line-modified">122   if (unloaded_klass_set != NULL &amp;&amp; unloaded_klass_set-&gt;length() &gt; 1) {</span>
<span class="line-modified">123     unloaded_klass_set-&gt;sort(sort_traceid);</span>





124   }
<a name="19" id="anc19"></a><span class="line-added">125 }</span>
126 
<a name="20" id="anc20"></a><span class="line-modified">127 void ObjectSampleCheckpoint::on_klass_unload(const Klass* k) {</span>
<span class="line-modified">128   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);</span>
<span class="line-added">129   assert(k != NULL, &quot;invariant&quot;);</span>
<span class="line-added">130   add_to_unloaded_klass_set(JfrTraceId::get(k));</span>
<span class="line-added">131 }</span>
<span class="line-added">132 </span>
<span class="line-added">133 template &lt;typename Processor&gt;</span>
<span class="line-added">134 static void do_samples(ObjectSample* sample, const ObjectSample* end, Processor&amp; processor) {</span>
<span class="line-added">135   assert(sample != NULL, &quot;invariant&quot;);</span>
<span class="line-added">136   while (sample != end) {</span>
<span class="line-added">137     processor.sample_do(sample);</span>
<span class="line-added">138     sample = sample-&gt;next();</span>
139   }
<a name="21" id="anc21"></a><span class="line-modified">140 }</span>
<span class="line-added">141 </span>
<span class="line-added">142 template &lt;typename Processor&gt;</span>
<span class="line-added">143 static void iterate_samples(Processor&amp; processor, bool all = false) {</span>
<span class="line-added">144   ObjectSampler* const sampler = ObjectSampler::sampler();</span>
<span class="line-added">145   assert(sampler != NULL, &quot;invariant&quot;);</span>
<span class="line-added">146   ObjectSample* const last = sampler-&gt;last();</span>
<span class="line-added">147   assert(last != NULL, &quot;invariant&quot;);</span>
<span class="line-added">148   do_samples(last, all ? NULL : sampler-&gt;last_resolved(), processor);</span>
<span class="line-added">149 }</span>
150 
<a name="22" id="anc22"></a><span class="line-modified">151 class SampleMarker {</span>
152  private:
153   ObjectSampleMarker&amp; _marker;
154   jlong _last_sweep;
155   int _count;
156  public:
<a name="23" id="anc23"></a><span class="line-modified">157   SampleMarker(ObjectSampleMarker&amp; marker, jlong last_sweep) : _marker(marker), _last_sweep(last_sweep), _count(0) {}</span>


158   void sample_do(ObjectSample* sample) {
<a name="24" id="anc24"></a>
159     if (sample-&gt;is_alive_and_older_than(_last_sweep)) {
160       _marker.mark(sample-&gt;object());
161       ++_count;
162     }
163   }
<a name="25" id="anc25"></a>
164   int count() const {
165     return _count;
166   }
167 };
168 
<a name="26" id="anc26"></a><span class="line-modified">169 int ObjectSampleCheckpoint::save_mark_words(const ObjectSampler* sampler, ObjectSampleMarker&amp; marker, bool emit_all) {</span>
<span class="line-modified">170   assert(sampler != NULL, &quot;invariant&quot;);</span>
<span class="line-added">171   if (sampler-&gt;last() == NULL) {</span>
<span class="line-added">172     return 0;</span>
<span class="line-added">173   }</span>
<span class="line-added">174   SampleMarker sample_marker(marker, emit_all ? max_jlong : sampler-&gt;last_sweep().value());</span>
<span class="line-added">175   iterate_samples(sample_marker, true);</span>
<span class="line-added">176   return sample_marker.count();</span>
<span class="line-added">177 }</span>
<span class="line-added">178 </span>
<span class="line-added">179 class BlobCache {</span>
<span class="line-added">180   typedef HashTableHost&lt;JfrBlobHandle, traceid, JfrHashtableEntry, BlobCache&gt; BlobTable;</span>
<span class="line-added">181   typedef BlobTable::HashEntry BlobEntry;</span>
<span class="line-added">182  private:</span>
<span class="line-added">183   BlobTable _table;</span>
<span class="line-added">184   traceid _lookup_id;</span>
<span class="line-added">185  public:</span>
<span class="line-added">186   BlobCache(size_t size) : _table(this, size), _lookup_id(0) {}</span>
<span class="line-added">187   JfrBlobHandle get(const ObjectSample* sample);</span>
<span class="line-added">188   void put(const ObjectSample* sample, const JfrBlobHandle&amp; blob);</span>
<span class="line-added">189   // Hash table callbacks</span>
<span class="line-added">190   void on_link(const BlobEntry* entry) const;</span>
<span class="line-added">191   bool on_equals(uintptr_t hash, const BlobEntry* entry) const;</span>
<span class="line-added">192   void on_unlink(BlobEntry* entry) const;</span>
<span class="line-added">193 };</span>
<span class="line-added">194 </span>
<span class="line-added">195 JfrBlobHandle BlobCache::get(const ObjectSample* sample) {</span>
<span class="line-added">196   assert(sample != NULL, &quot;invariant&quot;);</span>
<span class="line-added">197   _lookup_id = sample-&gt;stack_trace_id();</span>
<span class="line-added">198   assert(_lookup_id != 0, &quot;invariant&quot;);</span>
<span class="line-added">199   BlobEntry* const entry = _table.lookup_only(sample-&gt;stack_trace_hash());</span>
<span class="line-added">200   return entry != NULL ? entry-&gt;literal() : JfrBlobHandle();</span>
<span class="line-added">201 }</span>
<span class="line-added">202 </span>
<span class="line-added">203 void BlobCache::put(const ObjectSample* sample, const JfrBlobHandle&amp; blob) {</span>
<span class="line-added">204   assert(sample != NULL, &quot;invariant&quot;);</span>
<span class="line-added">205   assert(_table.lookup_only(sample-&gt;stack_trace_hash()) == NULL, &quot;invariant&quot;);</span>
<span class="line-added">206   _lookup_id = sample-&gt;stack_trace_id();</span>
<span class="line-added">207   assert(_lookup_id != 0, &quot;invariant&quot;);</span>
<span class="line-added">208   _table.put(sample-&gt;stack_trace_hash(), blob);</span>
<span class="line-added">209 }</span>
<span class="line-added">210 </span>
<span class="line-added">211 inline void BlobCache::on_link(const BlobEntry* entry) const {</span>
<span class="line-added">212   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-added">213   assert(entry-&gt;id() == 0, &quot;invariant&quot;);</span>
<span class="line-added">214   entry-&gt;set_id(_lookup_id);</span>
<span class="line-added">215 }</span>
<span class="line-added">216 </span>
<span class="line-added">217 inline bool BlobCache::on_equals(uintptr_t hash, const BlobEntry* entry) const {</span>
<span class="line-added">218   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-added">219   assert(entry-&gt;hash() == hash, &quot;invariant&quot;);</span>
<span class="line-added">220   return entry-&gt;id() == _lookup_id;</span>
<span class="line-added">221 }</span>
<span class="line-added">222 </span>
<span class="line-added">223 inline void BlobCache::on_unlink(BlobEntry* entry) const {</span>
<span class="line-added">224   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-added">225 }</span>
<span class="line-added">226 </span>
<span class="line-added">227 static GrowableArray&lt;traceid&gt;* id_set = NULL;</span>
<span class="line-added">228 </span>
<span class="line-added">229 static void prepare_for_resolution() {</span>
<span class="line-added">230   id_set = new GrowableArray&lt;traceid&gt;(JfrOptionSet::old_object_queue_size());</span>
<span class="line-added">231   sort_unloaded_klass_set();</span>
<span class="line-added">232 }</span>
233 
<a name="27" id="anc27"></a><span class="line-modified">234 static bool stack_trace_precondition(const ObjectSample* sample) {</span>
<span class="line-modified">235   assert(sample != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">236   return sample-&gt;has_stack_trace_id() &amp;&amp; !sample-&gt;is_dead();</span>
<span class="line-added">237 }</span>
<span class="line-added">238 </span>
<span class="line-added">239 class StackTraceBlobInstaller {</span>
<span class="line-added">240  private:</span>
<span class="line-added">241   const JfrStackTraceRepository&amp; _stack_trace_repo;</span>
<span class="line-added">242   BlobCache _cache;</span>
<span class="line-added">243   const JfrStackTrace* resolve(const ObjectSample* sample);</span>
<span class="line-added">244   void install(ObjectSample* sample);</span>
<span class="line-added">245  public:</span>
<span class="line-added">246   StackTraceBlobInstaller(const JfrStackTraceRepository&amp; stack_trace_repo);</span>
<span class="line-added">247   void sample_do(ObjectSample* sample) {</span>
<span class="line-added">248     if (stack_trace_precondition(sample)) {</span>
<span class="line-added">249       install(sample);</span>
250     }
<a name="28" id="anc28"></a><span class="line-modified">251   }</span>
<span class="line-added">252 };</span>
<span class="line-added">253 </span>
<span class="line-added">254 StackTraceBlobInstaller::StackTraceBlobInstaller(const JfrStackTraceRepository&amp; stack_trace_repo) :</span>
<span class="line-added">255   _stack_trace_repo(stack_trace_repo), _cache(JfrOptionSet::old_object_queue_size()) {</span>
<span class="line-added">256   prepare_for_resolution();</span>
<span class="line-added">257 }</span>
<span class="line-added">258 </span>
<span class="line-added">259 const JfrStackTrace* StackTraceBlobInstaller::resolve(const ObjectSample* sample) {</span>
<span class="line-added">260   return _stack_trace_repo.lookup(sample-&gt;stack_trace_hash(), sample-&gt;stack_trace_id());</span>
<span class="line-added">261 }</span>
<span class="line-added">262 </span>
<span class="line-added">263 #ifdef ASSERT</span>
<span class="line-added">264 static void validate_stack_trace(const ObjectSample* sample, const JfrStackTrace* stack_trace) {</span>
<span class="line-added">265   assert(!sample-&gt;has_stacktrace(), &quot;invariant&quot;);</span>
<span class="line-added">266   assert(stack_trace != NULL, &quot;invariant&quot;);</span>
<span class="line-added">267   assert(stack_trace-&gt;hash() == sample-&gt;stack_trace_hash(), &quot;invariant&quot;);</span>
<span class="line-added">268   assert(stack_trace-&gt;id() == sample-&gt;stack_trace_id(), &quot;invariant&quot;);</span>
<span class="line-added">269 }</span>
<span class="line-added">270 #endif</span>
<span class="line-added">271 </span>
<span class="line-added">272 void StackTraceBlobInstaller::install(ObjectSample* sample) {</span>
<span class="line-added">273   JfrBlobHandle blob = _cache.get(sample);</span>
<span class="line-added">274   if (blob.valid()) {</span>
<span class="line-added">275     sample-&gt;set_stacktrace(blob);</span>
276     return;
277   }
<a name="29" id="anc29"></a><span class="line-added">278   const JfrStackTrace* const stack_trace = resolve(sample);</span>
<span class="line-added">279   DEBUG_ONLY(validate_stack_trace(sample, stack_trace));</span>
<span class="line-added">280   JfrCheckpointWriter writer;</span>
<span class="line-added">281   writer.write_type(TYPE_STACKTRACE);</span>
<span class="line-added">282   writer.write_count(1);</span>
<span class="line-added">283   ObjectSampleCheckpoint::write_stacktrace(stack_trace, writer);</span>
<span class="line-added">284   blob = writer.move();</span>
<span class="line-added">285   _cache.put(sample, blob);</span>
<span class="line-added">286   sample-&gt;set_stacktrace(blob);</span>
<span class="line-added">287 }</span>
288 
<a name="30" id="anc30"></a><span class="line-modified">289 static void install_stack_traces(const ObjectSampler* sampler, JfrStackTraceRepository&amp; stack_trace_repo) {</span>
<span class="line-modified">290   assert(sampler != NULL, &quot;invariant&quot;);</span>
<span class="line-added">291   const ObjectSample* const last = sampler-&gt;last();</span>
<span class="line-added">292   if (last != sampler-&gt;last_resolved()) {</span>
<span class="line-added">293     StackTraceBlobInstaller installer(stack_trace_repo);</span>
<span class="line-added">294     iterate_samples(installer);</span>
<span class="line-added">295   }</span>
<span class="line-added">296 }</span>
297 
<a name="31" id="anc31"></a><span class="line-modified">298 // caller needs ResourceMark</span>
<span class="line-modified">299 void ObjectSampleCheckpoint::on_rotation(const ObjectSampler* sampler, JfrStackTraceRepository&amp; stack_trace_repo) {</span>
<span class="line-added">300   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-added">301   assert(sampler != NULL, &quot;invariant&quot;);</span>
<span class="line-added">302   assert(LeakProfiler::is_running(), &quot;invariant&quot;);</span>
<span class="line-added">303   MutexLocker lock(ClassLoaderDataGraph_lock);</span>
<span class="line-added">304   // the lock is needed to ensure the unload lists do not grow in the middle of inspection.</span>
<span class="line-added">305   install_stack_traces(sampler, stack_trace_repo);</span>
<span class="line-added">306 }</span>
307 
<a name="32" id="anc32"></a><span class="line-modified">308 static bool is_klass_unloaded(traceid klass_id) {</span>
<span class="line-modified">309   assert(ClassLoaderDataGraph_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-modified">310   return unloaded_klass_set != NULL &amp;&amp; predicate(unloaded_klass_set, klass_id);</span>
<span class="line-added">311 }</span>
312 
<a name="33" id="anc33"></a><span class="line-modified">313 static bool is_processed(traceid method_id) {</span>
<span class="line-modified">314   assert(method_id != 0, &quot;invariant&quot;);</span>
<span class="line-modified">315   assert(id_set != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">316   return mutable_predicate(id_set, method_id);</span>
<span class="line-modified">317 }</span>
<span class="line-modified">318 </span>
<span class="line-added">319 void ObjectSampleCheckpoint::add_to_leakp_set(const InstanceKlass* ik, traceid method_id) {</span>
<span class="line-added">320   assert(ik != NULL, &quot;invariant&quot;);</span>
<span class="line-added">321   if (is_processed(method_id) || is_klass_unloaded(JfrMethodLookup::klass_id(method_id))) {</span>
322     return;
323   }
<a name="34" id="anc34"></a><span class="line-added">324   const Method* const method = JfrMethodLookup::lookup(ik, method_id);</span>
<span class="line-added">325   assert(method != NULL, &quot;invariant&quot;);</span>
<span class="line-added">326   assert(method-&gt;method_holder() == ik, &quot;invariant&quot;);</span>
<span class="line-added">327   JfrTraceId::set_leakp(ik, method);</span>
<span class="line-added">328 }</span>
<span class="line-added">329 </span>
<span class="line-added">330 void ObjectSampleCheckpoint::write_stacktrace(const JfrStackTrace* trace, JfrCheckpointWriter&amp; writer) {</span>
<span class="line-added">331   assert(trace != NULL, &quot;invariant&quot;);</span>
<span class="line-added">332   // JfrStackTrace</span>
<span class="line-added">333   writer.write(trace-&gt;id());</span>
<span class="line-added">334   writer.write((u1)!trace-&gt;_reached_root);</span>
<span class="line-added">335   writer.write(trace-&gt;_nr_of_frames);</span>
<span class="line-added">336   // JfrStackFrames</span>
<span class="line-added">337   for (u4 i = 0; i &lt; trace-&gt;_nr_of_frames; ++i) {</span>
<span class="line-added">338     const JfrStackFrame&amp; frame = trace-&gt;_frames[i];</span>
<span class="line-added">339     frame.write(writer);</span>
<span class="line-added">340     add_to_leakp_set(frame._klass, frame._methodid);</span>
<span class="line-added">341   }</span>
<span class="line-added">342 }</span>
343 
<a name="35" id="anc35"></a><span class="line-modified">344 static void write_blob(const JfrBlobHandle&amp; blob, JfrCheckpointWriter&amp; writer, bool reset) {</span>
<span class="line-modified">345   if (reset) {</span>
<span class="line-modified">346     blob-&gt;reset_write_state();</span>
<span class="line-modified">347     return;</span>
<span class="line-modified">348   }</span>
<span class="line-added">349   blob-&gt;exclusive_write(writer);</span>
<span class="line-added">350 }</span>
<span class="line-added">351 </span>
<span class="line-added">352 static void write_type_set_blob(const ObjectSample* sample, JfrCheckpointWriter&amp; writer, bool reset) {</span>
<span class="line-added">353   if (sample-&gt;has_type_set()) {</span>
<span class="line-added">354     write_blob(sample-&gt;type_set(), writer, reset);</span>
<span class="line-added">355   }</span>
<span class="line-added">356 }</span>
<span class="line-added">357 </span>
<span class="line-added">358 static void write_thread_blob(const ObjectSample* sample, JfrCheckpointWriter&amp; writer, bool reset) {</span>
<span class="line-added">359   assert(sample-&gt;has_thread(), &quot;invariant&quot;);</span>
<span class="line-added">360   if (has_thread_exited(sample-&gt;thread_id())) {</span>
<span class="line-added">361     write_blob(sample-&gt;thread(), writer, reset);</span>
<span class="line-added">362   }</span>
<span class="line-added">363 }</span>
<span class="line-added">364 </span>
<span class="line-added">365 static void write_stacktrace_blob(const ObjectSample* sample, JfrCheckpointWriter&amp; writer, bool reset) {</span>
<span class="line-added">366   if (sample-&gt;has_stacktrace()) {</span>
<span class="line-added">367     write_blob(sample-&gt;stacktrace(), writer, reset);</span>
<span class="line-added">368   }</span>
<span class="line-added">369 }</span>
<span class="line-added">370 </span>
<span class="line-added">371 static void write_blobs(const ObjectSample* sample, JfrCheckpointWriter&amp; writer, bool reset) {</span>
<span class="line-added">372   assert(sample != NULL, &quot;invariant&quot;);</span>
<span class="line-added">373   write_stacktrace_blob(sample, writer, reset);</span>
<span class="line-added">374   write_thread_blob(sample, writer, reset);</span>
<span class="line-added">375   write_type_set_blob(sample, writer, reset);</span>
<span class="line-added">376 }</span>
<span class="line-added">377 </span>
<span class="line-added">378 class BlobWriter {</span>
<span class="line-added">379  private:</span>
<span class="line-added">380   const ObjectSampler* _sampler;</span>
<span class="line-added">381   JfrCheckpointWriter&amp; _writer;</span>
<span class="line-added">382   const jlong _last_sweep;</span>
<span class="line-added">383   bool _reset;</span>
<span class="line-added">384  public:</span>
<span class="line-added">385   BlobWriter(const ObjectSampler* sampler, JfrCheckpointWriter&amp; writer, jlong last_sweep) :</span>
<span class="line-added">386     _sampler(sampler), _writer(writer), _last_sweep(last_sweep), _reset(false)  {}</span>
<span class="line-added">387   void sample_do(ObjectSample* sample) {</span>
<span class="line-added">388     if (sample-&gt;is_alive_and_older_than(_last_sweep)) {</span>
<span class="line-added">389       write_blobs(sample, _writer, _reset);</span>
390     }
391   }
<a name="36" id="anc36"></a><span class="line-modified">392   void set_reset() {</span>
<span class="line-modified">393     _reset = true;</span>


394   }
<a name="37" id="anc37"></a><span class="line-added">395 };</span>
<span class="line-added">396 </span>
<span class="line-added">397 static void write_sample_blobs(const ObjectSampler* sampler, bool emit_all, Thread* thread) {</span>
<span class="line-added">398   // sample set is predicated on time of last sweep</span>
<span class="line-added">399   const jlong last_sweep = emit_all ? max_jlong : sampler-&gt;last_sweep().value();</span>
<span class="line-added">400   JfrCheckpointWriter writer(thread, false);</span>
<span class="line-added">401   BlobWriter cbw(sampler, writer, last_sweep);</span>
<span class="line-added">402   iterate_samples(cbw, true);</span>
<span class="line-added">403   // reset blob write states</span>
<span class="line-added">404   cbw.set_reset();</span>
<span class="line-added">405   iterate_samples(cbw, true);</span>
406 }
407 
<a name="38" id="anc38"></a><span class="line-modified">408 void ObjectSampleCheckpoint::write(const ObjectSampler* sampler, EdgeStore* edge_store, bool emit_all, Thread* thread) {</span>
<span class="line-added">409   assert_locked_or_safepoint(JfrStream_lock);</span>
<span class="line-added">410   assert(sampler != NULL, &quot;invariant&quot;);</span>
411   assert(edge_store != NULL, &quot;invariant&quot;);
412   assert(thread != NULL, &quot;invariant&quot;);
<a name="39" id="anc39"></a><span class="line-modified">413   write_sample_blobs(sampler, emit_all, thread);</span>
<span class="line-modified">414   // write reference chains</span>















415   if (!edge_store-&gt;is_empty()) {
<a name="40" id="anc40"></a><span class="line-modified">416     JfrCheckpointWriter writer(thread);</span>

417     ObjectSampleWriter osw(writer, edge_store);
<a name="41" id="anc41"></a><span class="line-modified">418     edge_store-&gt;iterate(osw);</span>
<span class="line-added">419   }</span>
<span class="line-added">420 }</span>
<span class="line-added">421 </span>
<span class="line-added">422 static void clear_unloaded_klass_set() {</span>
<span class="line-added">423   assert(ClassLoaderDataGraph_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-added">424   if (unloaded_klass_set != NULL &amp;&amp; unloaded_klass_set-&gt;is_nonempty()) {</span>
<span class="line-added">425     unloaded_klass_set-&gt;clear();</span>
426   }
427 }
428 
<a name="42" id="anc42"></a><span class="line-modified">429 // A linked list of saved type set blobs for the epoch.</span>
<span class="line-modified">430 // The link consist of a reference counted handle.</span>
<span class="line-added">431 static JfrBlobHandle saved_type_set_blobs;</span>
<span class="line-added">432 </span>
<span class="line-added">433 static void release_state_for_previous_epoch() {</span>
<span class="line-added">434   // decrements the reference count and the list is reinitialized</span>
<span class="line-added">435   saved_type_set_blobs = JfrBlobHandle();</span>
<span class="line-added">436   clear_unloaded_klass_set();</span>
437 }
438 
<a name="43" id="anc43"></a><span class="line-modified">439 class BlobInstaller {</span>
<span class="line-modified">440  public:</span>
<span class="line-modified">441   ~BlobInstaller() {</span>
<span class="line-modified">442     release_state_for_previous_epoch();</span>
443   }
<a name="44" id="anc44"></a><span class="line-modified">444   void sample_do(ObjectSample* sample) {</span>
<span class="line-modified">445     if (!sample-&gt;is_dead()) {</span>
<span class="line-modified">446       sample-&gt;set_type_set(saved_type_set_blobs);</span>
<span class="line-modified">447     }</span>












448   }
<a name="45" id="anc45"></a><span class="line-added">449 };</span>
450 
<a name="46" id="anc46"></a><span class="line-modified">451 static void install_type_set_blobs() {</span>
<span class="line-modified">452   BlobInstaller installer;</span>
<span class="line-modified">453   iterate_samples(installer);</span>
<span class="line-modified">454 }</span>

455 
<a name="47" id="anc47"></a><span class="line-modified">456 static void save_type_set_blob(JfrCheckpointWriter&amp; writer, bool copy = false) {</span>
<span class="line-modified">457   assert(writer.has_data(), &quot;invariant&quot;);</span>
<span class="line-modified">458   const JfrBlobHandle blob = copy ? writer.copy() : writer.move();</span>
<span class="line-modified">459   if (saved_type_set_blobs.valid()) {</span>
<span class="line-modified">460     saved_type_set_blobs-&gt;set_next(blob);</span>
<span class="line-modified">461   } else {</span>
<span class="line-modified">462     saved_type_set_blobs = blob;</span>



463   }
<a name="48" id="anc48"></a><span class="line-modified">464 }</span>


465 
<a name="49" id="anc49"></a><span class="line-modified">466 void ObjectSampleCheckpoint::on_type_set(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-modified">467   assert(LeakProfiler::is_running(), &quot;invariant&quot;);</span>
<span class="line-modified">468   const ObjectSample* last = ObjectSampler::sampler()-&gt;last();</span>
<span class="line-added">469   if (writer.has_data() &amp;&amp; last != NULL) {</span>
<span class="line-added">470     save_type_set_blob(writer);</span>
<span class="line-added">471     install_type_set_blobs();</span>
<span class="line-added">472     ObjectSampler::sampler()-&gt;set_last_resolved(last);</span>
<span class="line-added">473   }</span>
474 }
475 
<a name="50" id="anc50"></a><span class="line-modified">476 void ObjectSampleCheckpoint::on_type_set_unload(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-modified">477   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);</span>
<span class="line-modified">478   assert(LeakProfiler::is_running(), &quot;invariant&quot;);</span>
<span class="line-modified">479   if (writer.has_data() &amp;&amp; ObjectSampler::sampler()-&gt;last() != NULL) {</span>
<span class="line-modified">480     save_type_set_blob(writer, true);</span>

481   }
<a name="51" id="anc51"></a>



482 }
<a name="52" id="anc52"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="52" type="hidden" />
</body>
</html>
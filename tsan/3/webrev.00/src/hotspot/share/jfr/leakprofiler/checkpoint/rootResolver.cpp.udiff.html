<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/jfr/leakprofiler/checkpoint/rootResolver.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="objectSampleWriter.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="rootResolver.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/leakprofiler/checkpoint/rootResolver.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -25,31 +25,31 @@</span>
  #include &quot;precompiled.hpp&quot;
  #include &quot;aot/aotLoader.hpp&quot;
  #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  #include &quot;classfile/stringTable.hpp&quot;
  #include &quot;gc/shared/strongRootsScope.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;jfr/leakprofiler/utilities/unifiedOop.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;jfr/leakprofiler/utilities/unifiedOopRef.inline.hpp&quot;</span>
  #include &quot;jfr/leakprofiler/checkpoint/rootResolver.hpp&quot;
<span class="udiff-line-added">+ #include &quot;jfr/utilities/jfrThreadIterator.hpp&quot;</span>
  #include &quot;memory/iterator.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/klass.hpp&quot;
<span class="udiff-line-removed">- #include &quot;oops/markOop.hpp&quot;</span>
  #include &quot;oops/oop.hpp&quot;
  #include &quot;prims/jvmtiThreadState.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/mutexLocker.hpp&quot;
<span class="udiff-line-removed">- #include &quot;runtime/threadSMR.inline.hpp&quot;</span>
  #include &quot;runtime/vframe_hp.hpp&quot;
  #include &quot;services/management.hpp&quot;
  #include &quot;utilities/growableArray.hpp&quot;
  
  class ReferenceLocateClosure : public OopClosure {
   protected:
    RootCallback&amp; _callback;
    RootCallbackInfo _info;
    bool _complete;
  
<span class="udiff-line-modified-removed">-   void do_oop_shared(const void* ref);</span>
<span class="udiff-line-modified-added">+   void do_oop_shared(UnifiedOopRef ref);</span>
  
   public:
    ReferenceLocateClosure(RootCallback&amp; callback,
                           OldObjectRoot::System system,
                           OldObjectRoot::Type type,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -69,24 +69,24 @@</span>
    bool complete() const {
      return _complete;
    }
  };
  
<span class="udiff-line-modified-removed">- void ReferenceLocateClosure::do_oop_shared(const void* ref) {</span>
<span class="udiff-line-modified-removed">-   assert(ref != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-modified-added">+ void ReferenceLocateClosure::do_oop_shared(UnifiedOopRef ref) {</span>
<span class="udiff-line-modified-added">+   assert(!ref.is_null(), &quot;invariant&quot;);</span>
    if (!_complete) {
<span class="udiff-line-modified-removed">-     _info._high = ref;</span>
<span class="udiff-line-modified-added">+     _info._high = ref.addr&lt;address&gt;();</span>
      _complete = _callback.process(_info);
    }
  }
  
  void ReferenceLocateClosure::do_oop(oop* ref) {
<span class="udiff-line-modified-removed">-   do_oop_shared(ref);</span>
<span class="udiff-line-modified-added">+   do_oop_shared(UnifiedOopRef::encode_in_native(ref));</span>
  }
  
  void ReferenceLocateClosure::do_oop(narrowOop* ref) {
<span class="udiff-line-modified-removed">-   do_oop_shared(ref);</span>
<span class="udiff-line-modified-added">+   do_oop_shared(UnifiedOopRef::encode_in_native(ref));</span>
  }
  
  class ReferenceToRootClosure : public StackObj {
   private:
    RootCallback&amp; _callback;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -125,11 +125,11 @@</span>
  };
  
  bool ReferenceToRootClosure::do_cldg_roots() {
    assert(!complete(), &quot;invariant&quot;);
    ReferenceLocateClosure rlc(_callback, OldObjectRoot::_class_loader_data, OldObjectRoot::_type_undetermined, NULL);
<span class="udiff-line-modified-removed">-   CLDToOopClosure cldt_closure(&amp;rlc, ClassLoaderData::_claim_strong);</span>
<span class="udiff-line-modified-added">+   CLDToOopClosure cldt_closure(&amp;rlc, ClassLoaderData::_claim_none);</span>
    ClassLoaderDataGraph::always_strong_cld_do(&amp;cldt_closure);
    return rlc.complete();
  }
  
  bool ReferenceToRootClosure::do_object_synchronizer_roots() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -172,17 +172,10 @@</span>
    ReferenceLocateClosure rlc(_callback, OldObjectRoot::_management, OldObjectRoot::_type_undetermined, NULL);
    Management::oops_do(&amp;rlc);
    return rlc.complete();
  }
  
<span class="udiff-line-removed">- bool ReferenceToRootClosure::do_string_table_roots() {</span>
<span class="udiff-line-removed">-   assert(!complete(), &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   ReferenceLocateClosure rlc(_callback, OldObjectRoot::_string_table, OldObjectRoot::_type_undetermined, NULL);</span>
<span class="udiff-line-removed">-   StringTable::oops_do(&amp;rlc);</span>
<span class="udiff-line-removed">-   return rlc.complete();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  bool ReferenceToRootClosure::do_aot_loader_roots() {
    assert(!complete(), &quot;invariant&quot;);
    ReferenceLocateClosure rcl(_callback, OldObjectRoot::_aot, OldObjectRoot::_type_undetermined, NULL);
    AOTLoader::oops_do(&amp;rcl);
    return rcl.complete();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -226,15 +219,10 @@</span>
    if (do_management_roots()) {
     _complete = true;
      return true;
    }
  
<span class="udiff-line-removed">-   if (do_string_table_roots()) {</span>
<span class="udiff-line-removed">-    _complete = true;</span>
<span class="udiff-line-removed">-     return true;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
    if (do_aot_loader_roots()) {
     _complete = true;
      return true;
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -254,12 +242,13 @@</span>
    bool do_thread_handle_area(JavaThread* jt);
  
   public:
    ReferenceToThreadRootClosure(RootCallback&amp; callback) :_callback(callback), _complete(false) {
      assert_locked_or_safepoint(Threads_lock);
<span class="udiff-line-modified-removed">-     for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {</span>
<span class="udiff-line-modified-removed">-       if (do_thread_roots(jt)) {</span>
<span class="udiff-line-modified-added">+     JfrJavaThreadIterator iter;</span>
<span class="udiff-line-modified-added">+     while (iter.has_next()) {</span>
<span class="udiff-line-added">+       if (do_thread_roots(iter.next())) {</span>
          return;
        }
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -300,11 +289,11 @@</span>
    info._context = jt;
    info._system = OldObjectRoot::_threads;
    info._type = OldObjectRoot::_stack_variable;
  
    for (int i = 0; i &lt; _callback.entries(); ++i) {
<span class="udiff-line-modified-removed">-     const address adr = (address)_callback.at(i);</span>
<span class="udiff-line-modified-added">+     const address adr = _callback.at(i).addr&lt;address&gt;();</span>
      if (jt-&gt;is_in_usable_stack(adr)) {
        info._high = adr;
        _complete = _callback.process(info);
        if (_complete) {
          return true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -367,11 +356,11 @@</span>
    f-&gt;do_oop((oop*) &amp;_pending_async_exception);
    */
  
    JvmtiThreadState* const jvmti_thread_state = jt-&gt;jvmti_thread_state();
    if (jvmti_thread_state != NULL) {
<span class="udiff-line-modified-removed">-     jvmti_thread_state-&gt;oops_do(&amp;rcl);</span>
<span class="udiff-line-modified-added">+     jvmti_thread_state-&gt;oops_do(&amp;rcl, NULL);</span>
    }
  
    return rcl.complete();
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -412,13 +401,10 @@</span>
  
  class RootResolverMarkScope : public MarkScope {
  };
  
  void RootResolver::resolve(RootCallback&amp; callback) {
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Need to clear cld claim bit before starting</span>
<span class="udiff-line-removed">-   ClassLoaderDataGraph::clear_claimed_marks();</span>
    RootResolverMarkScope mark_scope;
  
    // thread local roots
    ReferenceToThreadRootClosure rtrc(callback);
    if (rtrc.complete()) {
</pre>
<center><a href="objectSampleWriter.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="rootResolver.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/leakprofiler/checkpoint/objectSampleCheckpoint.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../chains/rootSetClosure.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="objectSampleCheckpoint.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/leakprofiler/checkpoint/objectSampleCheckpoint.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/jfrEvents.hpp&quot;
<span class="line-removed"> 27 #include &quot;jfr/recorder/jfrRecorder.hpp&quot;</span>
<span class="line-removed"> 28 #include &quot;jfr/recorder/checkpoint/jfrCheckpointWriter.hpp&quot;</span>
<span class="line-removed"> 29 #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceId.inline.hpp&quot;</span>
<span class="line-removed"> 30 #include &quot;jfr/recorder/stacktrace/jfrStackTraceRepository.hpp&quot;</span>
 31 #include &quot;jfr/leakprofiler/chains/edgeStore.hpp&quot;
 32 #include &quot;jfr/leakprofiler/chains/objectSampleMarker.hpp&quot;
 33 #include &quot;jfr/leakprofiler/checkpoint/objectSampleCheckpoint.hpp&quot;
 34 #include &quot;jfr/leakprofiler/checkpoint/objectSampleWriter.hpp&quot;
 35 #include &quot;jfr/leakprofiler/leakProfiler.hpp&quot;
 36 #include &quot;jfr/leakprofiler/sampling/objectSample.hpp&quot;
 37 #include &quot;jfr/leakprofiler/sampling/objectSampler.hpp&quot;
<span class="line-modified"> 38 #include &quot;jfr/leakprofiler/utilities/rootType.hpp&quot;</span>
<span class="line-modified"> 39 #include &quot;jfr/metadata/jfrSerializer.hpp&quot;</span>
<span class="line-modified"> 40 #include &quot;runtime/interfaceSupport.inline.hpp&quot;</span>





 41 #include &quot;runtime/mutexLocker.hpp&quot;
<span class="line-modified"> 42 #include &quot;runtime/thread.inline.hpp&quot;</span>


 43 
<span class="line-modified"> 44 template &lt;typename SampleProcessor&gt;</span>
<span class="line-modified"> 45 static void do_samples(ObjectSample* sample, const ObjectSample* const end, SampleProcessor&amp; processor) {</span>
<span class="line-modified"> 46   assert(sample != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 47   while (sample != end) {</span>
<span class="line-modified"> 48     processor.sample_do(sample);</span>
<span class="line-removed"> 49     sample = sample-&gt;next();</span>
<span class="line-removed"> 50   }</span>
 51 }
 52 
<span class="line-modified"> 53 class RootSystemType : public JfrSerializer {</span>
<span class="line-modified"> 54  public:</span>
<span class="line-modified"> 55   void serialize(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-modified"> 56     const u4 nof_root_systems = OldObjectRoot::_number_of_systems;</span>
<span class="line-modified"> 57     writer.write_count(nof_root_systems);</span>
<span class="line-modified"> 58     for (u4 i = 0; i &lt; nof_root_systems; ++i) {</span>
<span class="line-removed"> 59       writer.write_key(i);</span>
<span class="line-removed"> 60       writer.write(OldObjectRoot::system_description((OldObjectRoot::System)i));</span>
<span class="line-removed"> 61     }</span>
 62   }
<span class="line-modified"> 63 };</span>

 64 
<span class="line-modified"> 65 class RootType : public JfrSerializer {</span>
<span class="line-modified"> 66  public:</span>
<span class="line-modified"> 67   void serialize(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-modified"> 68     const u4 nof_root_types = OldObjectRoot::_number_of_types;</span>
<span class="line-removed"> 69     writer.write_count(nof_root_types);</span>
<span class="line-removed"> 70     for (u4 i = 0; i &lt; nof_root_types; ++i) {</span>
<span class="line-removed"> 71       writer.write_key(i);</span>
<span class="line-removed"> 72       writer.write(OldObjectRoot::type_description((OldObjectRoot::Type)i));</span>
<span class="line-removed"> 73     }</span>
<span class="line-removed"> 74   }</span>
<span class="line-removed"> 75 };</span>
 76 
<span class="line-modified"> 77 class CheckpointInstall {</span>
<span class="line-removed"> 78  private:</span>
<span class="line-removed"> 79   const JfrCheckpointBlobHandle&amp; _cp;</span>
<span class="line-removed"> 80  public:</span>
<span class="line-removed"> 81   CheckpointInstall(const JfrCheckpointBlobHandle&amp; cp) : _cp(cp) {}</span>
<span class="line-removed"> 82   void sample_do(ObjectSample* sample) {</span>
<span class="line-removed"> 83     assert(sample != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 84     if (!sample-&gt;is_dead()) {</span>
<span class="line-removed"> 85       sample-&gt;set_klass_checkpoint(_cp);</span>
<span class="line-removed"> 86     }</span>
<span class="line-removed"> 87   }</span>
<span class="line-removed"> 88 };</span>
 89 
<span class="line-modified"> 90 class CheckpointWrite {</span>







 91  private:
<span class="line-modified"> 92   JfrCheckpointWriter&amp; _writer;</span>
<span class="line-removed"> 93   const jlong _last_sweep;</span>
 94  public:
<span class="line-modified"> 95   CheckpointWrite(JfrCheckpointWriter&amp; writer, jlong last_sweep) : _writer(writer), _last_sweep(last_sweep) {}</span>
<span class="line-modified"> 96   void sample_do(ObjectSample* sample) {</span>
<span class="line-removed"> 97     assert(sample != NULL, &quot;invariant&quot;);</span>
<span class="line-removed"> 98     if (sample-&gt;is_alive_and_older_than(_last_sweep)) {</span>
<span class="line-removed"> 99       if (sample-&gt;has_thread_checkpoint()) {</span>
<span class="line-removed">100         const JfrCheckpointBlobHandle&amp; thread_cp = sample-&gt;thread_checkpoint();</span>
<span class="line-removed">101         thread_cp-&gt;exclusive_write(_writer);</span>
<span class="line-removed">102       }</span>
<span class="line-removed">103       if (sample-&gt;has_klass_checkpoint()) {</span>
<span class="line-removed">104         const JfrCheckpointBlobHandle&amp; klass_cp = sample-&gt;klass_checkpoint();</span>
<span class="line-removed">105         klass_cp-&gt;exclusive_write(_writer);</span>
<span class="line-removed">106       }</span>
<span class="line-removed">107     }</span>
<span class="line-removed">108   }</span>
109 };
110 
<span class="line-modified">111 class CheckpointStateReset {</span>
<span class="line-modified">112  private:</span>
<span class="line-modified">113   const jlong _last_sweep;</span>
<span class="line-modified">114  public:</span>
<span class="line-modified">115   CheckpointStateReset(jlong last_sweep) : _last_sweep(last_sweep) {}</span>
<span class="line-modified">116   void sample_do(ObjectSample* sample) {</span>
<span class="line-modified">117     assert(sample != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">118     if (sample-&gt;is_alive_and_older_than(_last_sweep)) {</span>
<span class="line-modified">119       if (sample-&gt;has_thread_checkpoint()) {</span>
<span class="line-modified">120         const JfrCheckpointBlobHandle&amp; thread_cp = sample-&gt;thread_checkpoint();</span>
<span class="line-modified">121         thread_cp-&gt;reset_write_state();</span>
<span class="line-removed">122       }</span>
<span class="line-removed">123       if (sample-&gt;has_klass_checkpoint()) {</span>
<span class="line-removed">124         const JfrCheckpointBlobHandle&amp; klass_cp = sample-&gt;klass_checkpoint();</span>
<span class="line-removed">125         klass_cp-&gt;reset_write_state();</span>
<span class="line-removed">126       }</span>
<span class="line-removed">127     }</span>
128   }
<span class="line-modified">129 };</span>

130 
<span class="line-modified">131 class StackTraceWrite {</span>
<span class="line-modified">132  private:</span>
<span class="line-modified">133   JfrStackTraceRepository&amp; _stack_trace_repo;</span>
<span class="line-modified">134   JfrCheckpointWriter&amp; _writer;</span>
<span class="line-removed">135   int _count;</span>
<span class="line-removed">136  public:</span>
<span class="line-removed">137   StackTraceWrite(JfrStackTraceRepository&amp; stack_trace_repo, JfrCheckpointWriter&amp; writer) :</span>
<span class="line-removed">138     _stack_trace_repo(stack_trace_repo), _writer(writer), _count(0) {</span>
<span class="line-removed">139     JfrStacktrace_lock-&gt;lock();</span>
140   }
<span class="line-modified">141   ~StackTraceWrite() {</span>
<span class="line-modified">142     assert(JfrStacktrace_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-modified">143     JfrStacktrace_lock-&gt;unlock();</span>







144   }


145 
<span class="line-modified">146   void sample_do(ObjectSample* sample) {</span>
<span class="line-modified">147     assert(sample != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">148     if (!sample-&gt;is_dead()) {</span>
<span class="line-modified">149       if (sample-&gt;has_stack_trace()) {</span>
<span class="line-removed">150         JfrTraceId::use(sample-&gt;klass(), true);</span>
<span class="line-removed">151         _stack_trace_repo.write(_writer, sample-&gt;stack_trace_id(), sample-&gt;stack_trace_hash());</span>
<span class="line-removed">152         ++_count;</span>
<span class="line-removed">153       }</span>
<span class="line-removed">154     }</span>
155   }

156 
<span class="line-modified">157   int count() const {</span>
<span class="line-modified">158     return _count;</span>










159   }
<span class="line-modified">160 };</span>









161 
<span class="line-modified">162 class SampleMark {</span>
163  private:
164   ObjectSampleMarker&amp; _marker;
165   jlong _last_sweep;
166   int _count;
167  public:
<span class="line-modified">168   SampleMark(ObjectSampleMarker&amp; marker, jlong last_sweep) : _marker(marker),</span>
<span class="line-removed">169                                                              _last_sweep(last_sweep),</span>
<span class="line-removed">170                                                              _count(0) {}</span>
171   void sample_do(ObjectSample* sample) {
<span class="line-removed">172     assert(sample != NULL, &quot;invariant&quot;);</span>
173     if (sample-&gt;is_alive_and_older_than(_last_sweep)) {
174       _marker.mark(sample-&gt;object());
175       ++_count;
176     }
177   }
<span class="line-removed">178 </span>
179   int count() const {
180     return _count;
181   }
182 };
183 
<span class="line-modified">184 void ObjectSampleCheckpoint::install(JfrCheckpointWriter&amp; writer, bool class_unload, bool resume) {</span>
<span class="line-modified">185   assert(class_unload ? SafepointSynchronize::is_at_safepoint() : LeakProfiler::is_suspended(), &quot;invariant&quot;);</span>






























































186 
<span class="line-modified">187   if (!writer.has_data()) {</span>
<span class="line-modified">188     if (!class_unload) {</span>
<span class="line-modified">189       LeakProfiler::resume();</span>













190     }
<span class="line-modified">191     assert(LeakProfiler::is_running(), &quot;invariant&quot;);</span>
























192     return;
193   }










194 
<span class="line-modified">195   assert(writer.has_data(), &quot;invariant&quot;);</span>
<span class="line-modified">196   const JfrCheckpointBlobHandle h_cp = writer.checkpoint_blob();</span>






197 
<span class="line-modified">198   const ObjectSampler* const object_sampler = LeakProfiler::object_sampler();</span>
<span class="line-modified">199   assert(object_sampler != NULL, &quot;invariant&quot;);</span>







200 
<span class="line-modified">201   ObjectSample* const last = const_cast&lt;ObjectSample*&gt;(object_sampler-&gt;last());</span>
<span class="line-modified">202   const ObjectSample* const last_resolved = object_sampler-&gt;last_resolved();</span>
<span class="line-modified">203   CheckpointInstall install(h_cp);</span>

204 
<span class="line-modified">205   if (class_unload) {</span>
<span class="line-modified">206     if (last != NULL) {</span>
<span class="line-modified">207       // all samples need the class unload information</span>
<span class="line-modified">208       do_samples(last, NULL, install);</span>
<span class="line-modified">209     }</span>
<span class="line-modified">210     assert(LeakProfiler::is_running(), &quot;invariant&quot;);</span>



211     return;
212   }



















213 
<span class="line-modified">214   // only new samples since last resolved checkpoint</span>
<span class="line-modified">215   if (last != last_resolved) {</span>
<span class="line-modified">216     do_samples(last, last_resolved, install);</span>
<span class="line-modified">217     if (resume) {</span>
<span class="line-modified">218       const_cast&lt;ObjectSampler*&gt;(object_sampler)-&gt;set_last_resolved(last);</span>









































219     }
220   }
<span class="line-modified">221   assert(LeakProfiler::is_suspended(), &quot;invariant&quot;);</span>
<span class="line-modified">222   if (resume) {</span>
<span class="line-removed">223     LeakProfiler::resume();</span>
<span class="line-removed">224     assert(LeakProfiler::is_running(), &quot;invariant&quot;);</span>
225   }











226 }
227 
<span class="line-modified">228 void ObjectSampleCheckpoint::write(const EdgeStore* edge_store, bool emit_all, Thread* thread) {</span>


229   assert(edge_store != NULL, &quot;invariant&quot;);
230   assert(thread != NULL, &quot;invariant&quot;);
<span class="line-modified">231   static bool types_registered = false;</span>
<span class="line-modified">232   if (!types_registered) {</span>
<span class="line-removed">233     JfrSerializer::register_serializer(TYPE_OLDOBJECTROOTSYSTEM, false, true, new RootSystemType());</span>
<span class="line-removed">234     JfrSerializer::register_serializer(TYPE_OLDOBJECTROOTTYPE, false, true, new RootType());</span>
<span class="line-removed">235     types_registered = true;</span>
<span class="line-removed">236   }</span>
<span class="line-removed">237   const ObjectSampler* const object_sampler = LeakProfiler::object_sampler();</span>
<span class="line-removed">238   assert(object_sampler != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">239   const jlong last_sweep = emit_all ? max_jlong : object_sampler-&gt;last_sweep().value();</span>
<span class="line-removed">240   ObjectSample* const last = const_cast&lt;ObjectSample*&gt;(object_sampler-&gt;last());</span>
<span class="line-removed">241   {</span>
<span class="line-removed">242     JfrCheckpointWriter writer(false, false, thread);</span>
<span class="line-removed">243     CheckpointWrite checkpoint_write(writer, last_sweep);</span>
<span class="line-removed">244     do_samples(last, NULL, checkpoint_write);</span>
<span class="line-removed">245   }</span>
<span class="line-removed">246   CheckpointStateReset state_reset(last_sweep);</span>
<span class="line-removed">247   do_samples(last, NULL, state_reset);</span>
248   if (!edge_store-&gt;is_empty()) {
<span class="line-modified">249     // java object and chain representations</span>
<span class="line-removed">250     JfrCheckpointWriter writer(false, true, thread);</span>
251     ObjectSampleWriter osw(writer, edge_store);
<span class="line-modified">252     edge_store-&gt;iterate_edges(osw);</span>







253   }
254 }
255 
<span class="line-modified">256 WriteObjectSampleStacktrace::WriteObjectSampleStacktrace(JfrStackTraceRepository&amp; repo) :</span>
<span class="line-modified">257   _stack_trace_repo(repo) {</span>






258 }
259 
<span class="line-modified">260 bool WriteObjectSampleStacktrace::process() {</span>
<span class="line-modified">261   assert(SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);</span>
<span class="line-modified">262   if (!LeakProfiler::is_running()) {</span>
<span class="line-modified">263     return true;</span>
264   }
<span class="line-modified">265   // Suspend the LeakProfiler subsystem</span>
<span class="line-modified">266   // to ensure stable samples even</span>
<span class="line-modified">267   // after we return from the safepoint.</span>
<span class="line-modified">268   LeakProfiler::suspend();</span>
<span class="line-removed">269   assert(!LeakProfiler::is_running(), &quot;invariant&quot;);</span>
<span class="line-removed">270   assert(LeakProfiler::is_suspended(), &quot;invariant&quot;);</span>
<span class="line-removed">271 </span>
<span class="line-removed">272   const ObjectSampler* object_sampler = LeakProfiler::object_sampler();</span>
<span class="line-removed">273   assert(object_sampler != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">274   assert(LeakProfiler::is_suspended(), &quot;invariant&quot;);</span>
<span class="line-removed">275 </span>
<span class="line-removed">276   ObjectSample* const last = const_cast&lt;ObjectSample*&gt;(object_sampler-&gt;last());</span>
<span class="line-removed">277   const ObjectSample* const last_resolved = object_sampler-&gt;last_resolved();</span>
<span class="line-removed">278   if (last == last_resolved) {</span>
<span class="line-removed">279     assert(LeakProfiler::is_suspended(), &quot;invariant&quot;);</span>
<span class="line-removed">280     return true;</span>
281   }

282 
<span class="line-modified">283   JfrCheckpointWriter writer(false, true, Thread::current());</span>
<span class="line-modified">284   const JfrCheckpointContext ctx = writer.context();</span>
<span class="line-modified">285 </span>
<span class="line-modified">286   writer.write_type(TYPE_STACKTRACE);</span>
<span class="line-removed">287   const jlong count_offset = writer.reserve(sizeof(u4));</span>
288 
<span class="line-modified">289   int count = 0;</span>
<span class="line-modified">290   {</span>
<span class="line-modified">291     StackTraceWrite stack_trace_write(_stack_trace_repo, writer); // JfrStacktrace_lock</span>
<span class="line-modified">292     do_samples(last, last_resolved, stack_trace_write);</span>
<span class="line-modified">293     count = stack_trace_write.count();</span>
<span class="line-modified">294   }</span>
<span class="line-modified">295   if (count == 0) {</span>
<span class="line-removed">296     writer.set_context(ctx);</span>
<span class="line-removed">297     assert(LeakProfiler::is_suspended(), &quot;invariant&quot;);</span>
<span class="line-removed">298     return true;</span>
299   }
<span class="line-modified">300   assert(count &gt; 0, &quot;invariant&quot;);</span>
<span class="line-removed">301   writer.write_count((u4)count, count_offset);</span>
<span class="line-removed">302   JfrStackTraceRepository::write_metadata(writer);</span>
303 
<span class="line-modified">304   ObjectSampleCheckpoint::install(writer, false, false);</span>
<span class="line-modified">305   assert(LeakProfiler::is_suspended(), &quot;invariant&quot;);</span>
<span class="line-modified">306   return true;</span>





307 }
308 
<span class="line-modified">309 int ObjectSampleCheckpoint::mark(ObjectSampleMarker&amp; marker, bool emit_all) {</span>
<span class="line-modified">310   const ObjectSampler* object_sampler = LeakProfiler::object_sampler();</span>
<span class="line-modified">311   assert(object_sampler != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">312   ObjectSample* const last = const_cast&lt;ObjectSample*&gt;(object_sampler-&gt;last());</span>
<span class="line-modified">313   if (last == NULL) {</span>
<span class="line-removed">314     return 0;</span>
315   }
<span class="line-removed">316   const jlong last_sweep = emit_all ? max_jlong : object_sampler-&gt;last_sweep().value();</span>
<span class="line-removed">317   SampleMark mark(marker, last_sweep);</span>
<span class="line-removed">318   do_samples(last, NULL, mark);</span>
<span class="line-removed">319   return mark.count();</span>
320 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/jfrEvents.hpp&quot;




 27 #include &quot;jfr/leakprofiler/chains/edgeStore.hpp&quot;
 28 #include &quot;jfr/leakprofiler/chains/objectSampleMarker.hpp&quot;
 29 #include &quot;jfr/leakprofiler/checkpoint/objectSampleCheckpoint.hpp&quot;
 30 #include &quot;jfr/leakprofiler/checkpoint/objectSampleWriter.hpp&quot;
 31 #include &quot;jfr/leakprofiler/leakProfiler.hpp&quot;
 32 #include &quot;jfr/leakprofiler/sampling/objectSample.hpp&quot;
 33 #include &quot;jfr/leakprofiler/sampling/objectSampler.hpp&quot;
<span class="line-modified"> 34 #include &quot;jfr/recorder/checkpoint/jfrCheckpointWriter.hpp&quot;</span>
<span class="line-modified"> 35 #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceId.inline.hpp&quot;</span>
<span class="line-modified"> 36 #include &quot;jfr/recorder/service/jfrOptionSet.hpp&quot;</span>
<span class="line-added"> 37 #include &quot;jfr/recorder/stacktrace/jfrStackTraceRepository.hpp&quot;</span>
<span class="line-added"> 38 #include &quot;jfr/support/jfrMethodLookup.hpp&quot;</span>
<span class="line-added"> 39 #include &quot;jfr/utilities/jfrHashtable.hpp&quot;</span>
<span class="line-added"> 40 #include &quot;jfr/utilities/jfrTypes.hpp&quot;</span>
<span class="line-added"> 41 #include &quot;oops/instanceKlass.inline.hpp&quot;</span>
 42 #include &quot;runtime/mutexLocker.hpp&quot;
<span class="line-modified"> 43 #include &quot;runtime/safepoint.hpp&quot;</span>
<span class="line-added"> 44 #include &quot;runtime/thread.hpp&quot;</span>
<span class="line-added"> 45 #include &quot;utilities/growableArray.hpp&quot;</span>
 46 
<span class="line-modified"> 47 static bool predicate(GrowableArray&lt;traceid&gt;* set, traceid id) {</span>
<span class="line-modified"> 48   assert(set != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 49   bool found = false;</span>
<span class="line-modified"> 50   set-&gt;find_sorted&lt;traceid, compare_traceid&gt;(id, found);</span>
<span class="line-modified"> 51   return found;</span>


 52 }
 53 
<span class="line-modified"> 54 static bool mutable_predicate(GrowableArray&lt;traceid&gt;* set, traceid id) {</span>
<span class="line-modified"> 55   assert(set != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 56   bool found = false;</span>
<span class="line-modified"> 57   const int location = set-&gt;find_sorted&lt;traceid, compare_traceid&gt;(id, found);</span>
<span class="line-modified"> 58   if (!found) {</span>
<span class="line-modified"> 59     set-&gt;insert_before(location, id);</span>



 60   }
<span class="line-modified"> 61   return found;</span>
<span class="line-added"> 62 }</span>
 63 
<span class="line-modified"> 64 static bool add(GrowableArray&lt;traceid&gt;* set, traceid id) {</span>
<span class="line-modified"> 65   assert(set != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 66   return mutable_predicate(set, id);</span>
<span class="line-modified"> 67 }</span>







 68 
<span class="line-modified"> 69 const int initial_array_size = 64;</span>











 70 
<span class="line-modified"> 71 template &lt;typename T&gt;</span>
<span class="line-added"> 72 static GrowableArray&lt;T&gt;* c_heap_allocate_array(int size = initial_array_size) {</span>
<span class="line-added"> 73   return new (ResourceObj::C_HEAP, mtTracing) GrowableArray&lt;T&gt;(size, true, mtTracing);</span>
<span class="line-added"> 74 }</span>
<span class="line-added"> 75 </span>
<span class="line-added"> 76 static GrowableArray&lt;traceid&gt;* unloaded_thread_id_set = NULL;</span>
<span class="line-added"> 77 </span>
<span class="line-added"> 78 class ThreadIdExclusiveAccess : public StackObj {</span>
 79  private:
<span class="line-modified"> 80   static Semaphore _mutex_semaphore;</span>

 81  public:
<span class="line-modified"> 82   ThreadIdExclusiveAccess() { _mutex_semaphore.wait(); }</span>
<span class="line-modified"> 83   ~ThreadIdExclusiveAccess() { _mutex_semaphore.signal(); }</span>












 84 };
 85 
<span class="line-modified"> 86 Semaphore ThreadIdExclusiveAccess::_mutex_semaphore(1);</span>
<span class="line-modified"> 87 </span>
<span class="line-modified"> 88 static bool has_thread_exited(traceid tid) {</span>
<span class="line-modified"> 89   assert(tid != 0, &quot;invariant&quot;);</span>
<span class="line-modified"> 90   return unloaded_thread_id_set != NULL &amp;&amp; predicate(unloaded_thread_id_set, tid);</span>
<span class="line-modified"> 91 }</span>
<span class="line-modified"> 92 </span>
<span class="line-modified"> 93 static void add_to_unloaded_thread_set(traceid tid) {</span>
<span class="line-modified"> 94   ThreadIdExclusiveAccess lock;</span>
<span class="line-modified"> 95   if (unloaded_thread_id_set == NULL) {</span>
<span class="line-modified"> 96     unloaded_thread_id_set = c_heap_allocate_array&lt;traceid&gt;();</span>






 97   }
<span class="line-modified"> 98   add(unloaded_thread_id_set, tid);</span>
<span class="line-added"> 99 }</span>
100 
<span class="line-modified">101 void ObjectSampleCheckpoint::on_thread_exit(JavaThread* jt) {</span>
<span class="line-modified">102   assert(jt != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">103   if (LeakProfiler::is_running()) {</span>
<span class="line-modified">104     add_to_unloaded_thread_set(jt-&gt;jfr_thread_local()-&gt;thread_id());</span>





105   }
<span class="line-modified">106 }</span>
<span class="line-modified">107 </span>
<span class="line-modified">108 // Track the set of unloaded klasses during a chunk / epoch.</span>
<span class="line-added">109 // Methods in stacktraces belonging to unloaded klasses must not be accessed.</span>
<span class="line-added">110 static GrowableArray&lt;traceid&gt;* unloaded_klass_set = NULL;</span>
<span class="line-added">111 </span>
<span class="line-added">112 static void add_to_unloaded_klass_set(traceid klass_id) {</span>
<span class="line-added">113   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);</span>
<span class="line-added">114   if (unloaded_klass_set == NULL) {</span>
<span class="line-added">115     unloaded_klass_set = c_heap_allocate_array&lt;traceid&gt;();</span>
116   }
<span class="line-added">117   unloaded_klass_set-&gt;append(klass_id);</span>
<span class="line-added">118 }</span>
119 
<span class="line-modified">120 static void sort_unloaded_klass_set() {</span>
<span class="line-modified">121   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);</span>
<span class="line-modified">122   if (unloaded_klass_set != NULL &amp;&amp; unloaded_klass_set-&gt;length() &gt; 1) {</span>
<span class="line-modified">123     unloaded_klass_set-&gt;sort(sort_traceid);</span>





124   }
<span class="line-added">125 }</span>
126 
<span class="line-modified">127 void ObjectSampleCheckpoint::on_klass_unload(const Klass* k) {</span>
<span class="line-modified">128   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);</span>
<span class="line-added">129   assert(k != NULL, &quot;invariant&quot;);</span>
<span class="line-added">130   add_to_unloaded_klass_set(JfrTraceId::get(k));</span>
<span class="line-added">131 }</span>
<span class="line-added">132 </span>
<span class="line-added">133 template &lt;typename Processor&gt;</span>
<span class="line-added">134 static void do_samples(ObjectSample* sample, const ObjectSample* end, Processor&amp; processor) {</span>
<span class="line-added">135   assert(sample != NULL, &quot;invariant&quot;);</span>
<span class="line-added">136   while (sample != end) {</span>
<span class="line-added">137     processor.sample_do(sample);</span>
<span class="line-added">138     sample = sample-&gt;next();</span>
139   }
<span class="line-modified">140 }</span>
<span class="line-added">141 </span>
<span class="line-added">142 template &lt;typename Processor&gt;</span>
<span class="line-added">143 static void iterate_samples(Processor&amp; processor, bool all = false) {</span>
<span class="line-added">144   ObjectSampler* const sampler = ObjectSampler::sampler();</span>
<span class="line-added">145   assert(sampler != NULL, &quot;invariant&quot;);</span>
<span class="line-added">146   ObjectSample* const last = sampler-&gt;last();</span>
<span class="line-added">147   assert(last != NULL, &quot;invariant&quot;);</span>
<span class="line-added">148   do_samples(last, all ? NULL : sampler-&gt;last_resolved(), processor);</span>
<span class="line-added">149 }</span>
150 
<span class="line-modified">151 class SampleMarker {</span>
152  private:
153   ObjectSampleMarker&amp; _marker;
154   jlong _last_sweep;
155   int _count;
156  public:
<span class="line-modified">157   SampleMarker(ObjectSampleMarker&amp; marker, jlong last_sweep) : _marker(marker), _last_sweep(last_sweep), _count(0) {}</span>


158   void sample_do(ObjectSample* sample) {

159     if (sample-&gt;is_alive_and_older_than(_last_sweep)) {
160       _marker.mark(sample-&gt;object());
161       ++_count;
162     }
163   }

164   int count() const {
165     return _count;
166   }
167 };
168 
<span class="line-modified">169 int ObjectSampleCheckpoint::save_mark_words(const ObjectSampler* sampler, ObjectSampleMarker&amp; marker, bool emit_all) {</span>
<span class="line-modified">170   assert(sampler != NULL, &quot;invariant&quot;);</span>
<span class="line-added">171   if (sampler-&gt;last() == NULL) {</span>
<span class="line-added">172     return 0;</span>
<span class="line-added">173   }</span>
<span class="line-added">174   SampleMarker sample_marker(marker, emit_all ? max_jlong : sampler-&gt;last_sweep().value());</span>
<span class="line-added">175   iterate_samples(sample_marker, true);</span>
<span class="line-added">176   return sample_marker.count();</span>
<span class="line-added">177 }</span>
<span class="line-added">178 </span>
<span class="line-added">179 class BlobCache {</span>
<span class="line-added">180   typedef HashTableHost&lt;JfrBlobHandle, traceid, JfrHashtableEntry, BlobCache&gt; BlobTable;</span>
<span class="line-added">181   typedef BlobTable::HashEntry BlobEntry;</span>
<span class="line-added">182  private:</span>
<span class="line-added">183   BlobTable _table;</span>
<span class="line-added">184   traceid _lookup_id;</span>
<span class="line-added">185  public:</span>
<span class="line-added">186   BlobCache(size_t size) : _table(this, size), _lookup_id(0) {}</span>
<span class="line-added">187   JfrBlobHandle get(const ObjectSample* sample);</span>
<span class="line-added">188   void put(const ObjectSample* sample, const JfrBlobHandle&amp; blob);</span>
<span class="line-added">189   // Hash table callbacks</span>
<span class="line-added">190   void on_link(const BlobEntry* entry) const;</span>
<span class="line-added">191   bool on_equals(uintptr_t hash, const BlobEntry* entry) const;</span>
<span class="line-added">192   void on_unlink(BlobEntry* entry) const;</span>
<span class="line-added">193 };</span>
<span class="line-added">194 </span>
<span class="line-added">195 JfrBlobHandle BlobCache::get(const ObjectSample* sample) {</span>
<span class="line-added">196   assert(sample != NULL, &quot;invariant&quot;);</span>
<span class="line-added">197   _lookup_id = sample-&gt;stack_trace_id();</span>
<span class="line-added">198   assert(_lookup_id != 0, &quot;invariant&quot;);</span>
<span class="line-added">199   BlobEntry* const entry = _table.lookup_only(sample-&gt;stack_trace_hash());</span>
<span class="line-added">200   return entry != NULL ? entry-&gt;literal() : JfrBlobHandle();</span>
<span class="line-added">201 }</span>
<span class="line-added">202 </span>
<span class="line-added">203 void BlobCache::put(const ObjectSample* sample, const JfrBlobHandle&amp; blob) {</span>
<span class="line-added">204   assert(sample != NULL, &quot;invariant&quot;);</span>
<span class="line-added">205   assert(_table.lookup_only(sample-&gt;stack_trace_hash()) == NULL, &quot;invariant&quot;);</span>
<span class="line-added">206   _lookup_id = sample-&gt;stack_trace_id();</span>
<span class="line-added">207   assert(_lookup_id != 0, &quot;invariant&quot;);</span>
<span class="line-added">208   _table.put(sample-&gt;stack_trace_hash(), blob);</span>
<span class="line-added">209 }</span>
<span class="line-added">210 </span>
<span class="line-added">211 inline void BlobCache::on_link(const BlobEntry* entry) const {</span>
<span class="line-added">212   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-added">213   assert(entry-&gt;id() == 0, &quot;invariant&quot;);</span>
<span class="line-added">214   entry-&gt;set_id(_lookup_id);</span>
<span class="line-added">215 }</span>
<span class="line-added">216 </span>
<span class="line-added">217 inline bool BlobCache::on_equals(uintptr_t hash, const BlobEntry* entry) const {</span>
<span class="line-added">218   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-added">219   assert(entry-&gt;hash() == hash, &quot;invariant&quot;);</span>
<span class="line-added">220   return entry-&gt;id() == _lookup_id;</span>
<span class="line-added">221 }</span>
<span class="line-added">222 </span>
<span class="line-added">223 inline void BlobCache::on_unlink(BlobEntry* entry) const {</span>
<span class="line-added">224   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-added">225 }</span>
<span class="line-added">226 </span>
<span class="line-added">227 static GrowableArray&lt;traceid&gt;* id_set = NULL;</span>
<span class="line-added">228 </span>
<span class="line-added">229 static void prepare_for_resolution() {</span>
<span class="line-added">230   id_set = new GrowableArray&lt;traceid&gt;(JfrOptionSet::old_object_queue_size());</span>
<span class="line-added">231   sort_unloaded_klass_set();</span>
<span class="line-added">232 }</span>
233 
<span class="line-modified">234 static bool stack_trace_precondition(const ObjectSample* sample) {</span>
<span class="line-modified">235   assert(sample != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">236   return sample-&gt;has_stack_trace_id() &amp;&amp; !sample-&gt;is_dead();</span>
<span class="line-added">237 }</span>
<span class="line-added">238 </span>
<span class="line-added">239 class StackTraceBlobInstaller {</span>
<span class="line-added">240  private:</span>
<span class="line-added">241   const JfrStackTraceRepository&amp; _stack_trace_repo;</span>
<span class="line-added">242   BlobCache _cache;</span>
<span class="line-added">243   const JfrStackTrace* resolve(const ObjectSample* sample);</span>
<span class="line-added">244   void install(ObjectSample* sample);</span>
<span class="line-added">245  public:</span>
<span class="line-added">246   StackTraceBlobInstaller(const JfrStackTraceRepository&amp; stack_trace_repo);</span>
<span class="line-added">247   void sample_do(ObjectSample* sample) {</span>
<span class="line-added">248     if (stack_trace_precondition(sample)) {</span>
<span class="line-added">249       install(sample);</span>
250     }
<span class="line-modified">251   }</span>
<span class="line-added">252 };</span>
<span class="line-added">253 </span>
<span class="line-added">254 StackTraceBlobInstaller::StackTraceBlobInstaller(const JfrStackTraceRepository&amp; stack_trace_repo) :</span>
<span class="line-added">255   _stack_trace_repo(stack_trace_repo), _cache(JfrOptionSet::old_object_queue_size()) {</span>
<span class="line-added">256   prepare_for_resolution();</span>
<span class="line-added">257 }</span>
<span class="line-added">258 </span>
<span class="line-added">259 const JfrStackTrace* StackTraceBlobInstaller::resolve(const ObjectSample* sample) {</span>
<span class="line-added">260   return _stack_trace_repo.lookup(sample-&gt;stack_trace_hash(), sample-&gt;stack_trace_id());</span>
<span class="line-added">261 }</span>
<span class="line-added">262 </span>
<span class="line-added">263 #ifdef ASSERT</span>
<span class="line-added">264 static void validate_stack_trace(const ObjectSample* sample, const JfrStackTrace* stack_trace) {</span>
<span class="line-added">265   assert(!sample-&gt;has_stacktrace(), &quot;invariant&quot;);</span>
<span class="line-added">266   assert(stack_trace != NULL, &quot;invariant&quot;);</span>
<span class="line-added">267   assert(stack_trace-&gt;hash() == sample-&gt;stack_trace_hash(), &quot;invariant&quot;);</span>
<span class="line-added">268   assert(stack_trace-&gt;id() == sample-&gt;stack_trace_id(), &quot;invariant&quot;);</span>
<span class="line-added">269 }</span>
<span class="line-added">270 #endif</span>
<span class="line-added">271 </span>
<span class="line-added">272 void StackTraceBlobInstaller::install(ObjectSample* sample) {</span>
<span class="line-added">273   JfrBlobHandle blob = _cache.get(sample);</span>
<span class="line-added">274   if (blob.valid()) {</span>
<span class="line-added">275     sample-&gt;set_stacktrace(blob);</span>
276     return;
277   }
<span class="line-added">278   const JfrStackTrace* const stack_trace = resolve(sample);</span>
<span class="line-added">279   DEBUG_ONLY(validate_stack_trace(sample, stack_trace));</span>
<span class="line-added">280   JfrCheckpointWriter writer;</span>
<span class="line-added">281   writer.write_type(TYPE_STACKTRACE);</span>
<span class="line-added">282   writer.write_count(1);</span>
<span class="line-added">283   ObjectSampleCheckpoint::write_stacktrace(stack_trace, writer);</span>
<span class="line-added">284   blob = writer.move();</span>
<span class="line-added">285   _cache.put(sample, blob);</span>
<span class="line-added">286   sample-&gt;set_stacktrace(blob);</span>
<span class="line-added">287 }</span>
288 
<span class="line-modified">289 static void install_stack_traces(const ObjectSampler* sampler, JfrStackTraceRepository&amp; stack_trace_repo) {</span>
<span class="line-modified">290   assert(sampler != NULL, &quot;invariant&quot;);</span>
<span class="line-added">291   const ObjectSample* const last = sampler-&gt;last();</span>
<span class="line-added">292   if (last != sampler-&gt;last_resolved()) {</span>
<span class="line-added">293     StackTraceBlobInstaller installer(stack_trace_repo);</span>
<span class="line-added">294     iterate_samples(installer);</span>
<span class="line-added">295   }</span>
<span class="line-added">296 }</span>
297 
<span class="line-modified">298 // caller needs ResourceMark</span>
<span class="line-modified">299 void ObjectSampleCheckpoint::on_rotation(const ObjectSampler* sampler, JfrStackTraceRepository&amp; stack_trace_repo) {</span>
<span class="line-added">300   assert(JfrStream_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-added">301   assert(sampler != NULL, &quot;invariant&quot;);</span>
<span class="line-added">302   assert(LeakProfiler::is_running(), &quot;invariant&quot;);</span>
<span class="line-added">303   MutexLocker lock(ClassLoaderDataGraph_lock);</span>
<span class="line-added">304   // the lock is needed to ensure the unload lists do not grow in the middle of inspection.</span>
<span class="line-added">305   install_stack_traces(sampler, stack_trace_repo);</span>
<span class="line-added">306 }</span>
307 
<span class="line-modified">308 static bool is_klass_unloaded(traceid klass_id) {</span>
<span class="line-modified">309   assert(ClassLoaderDataGraph_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-modified">310   return unloaded_klass_set != NULL &amp;&amp; predicate(unloaded_klass_set, klass_id);</span>
<span class="line-added">311 }</span>
312 
<span class="line-modified">313 static bool is_processed(traceid method_id) {</span>
<span class="line-modified">314   assert(method_id != 0, &quot;invariant&quot;);</span>
<span class="line-modified">315   assert(id_set != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">316   return mutable_predicate(id_set, method_id);</span>
<span class="line-modified">317 }</span>
<span class="line-modified">318 </span>
<span class="line-added">319 void ObjectSampleCheckpoint::add_to_leakp_set(const InstanceKlass* ik, traceid method_id) {</span>
<span class="line-added">320   assert(ik != NULL, &quot;invariant&quot;);</span>
<span class="line-added">321   if (is_processed(method_id) || is_klass_unloaded(JfrMethodLookup::klass_id(method_id))) {</span>
322     return;
323   }
<span class="line-added">324   const Method* const method = JfrMethodLookup::lookup(ik, method_id);</span>
<span class="line-added">325   assert(method != NULL, &quot;invariant&quot;);</span>
<span class="line-added">326   assert(method-&gt;method_holder() == ik, &quot;invariant&quot;);</span>
<span class="line-added">327   JfrTraceId::set_leakp(ik, method);</span>
<span class="line-added">328 }</span>
<span class="line-added">329 </span>
<span class="line-added">330 void ObjectSampleCheckpoint::write_stacktrace(const JfrStackTrace* trace, JfrCheckpointWriter&amp; writer) {</span>
<span class="line-added">331   assert(trace != NULL, &quot;invariant&quot;);</span>
<span class="line-added">332   // JfrStackTrace</span>
<span class="line-added">333   writer.write(trace-&gt;id());</span>
<span class="line-added">334   writer.write((u1)!trace-&gt;_reached_root);</span>
<span class="line-added">335   writer.write(trace-&gt;_nr_of_frames);</span>
<span class="line-added">336   // JfrStackFrames</span>
<span class="line-added">337   for (u4 i = 0; i &lt; trace-&gt;_nr_of_frames; ++i) {</span>
<span class="line-added">338     const JfrStackFrame&amp; frame = trace-&gt;_frames[i];</span>
<span class="line-added">339     frame.write(writer);</span>
<span class="line-added">340     add_to_leakp_set(frame._klass, frame._methodid);</span>
<span class="line-added">341   }</span>
<span class="line-added">342 }</span>
343 
<span class="line-modified">344 static void write_blob(const JfrBlobHandle&amp; blob, JfrCheckpointWriter&amp; writer, bool reset) {</span>
<span class="line-modified">345   if (reset) {</span>
<span class="line-modified">346     blob-&gt;reset_write_state();</span>
<span class="line-modified">347     return;</span>
<span class="line-modified">348   }</span>
<span class="line-added">349   blob-&gt;exclusive_write(writer);</span>
<span class="line-added">350 }</span>
<span class="line-added">351 </span>
<span class="line-added">352 static void write_type_set_blob(const ObjectSample* sample, JfrCheckpointWriter&amp; writer, bool reset) {</span>
<span class="line-added">353   if (sample-&gt;has_type_set()) {</span>
<span class="line-added">354     write_blob(sample-&gt;type_set(), writer, reset);</span>
<span class="line-added">355   }</span>
<span class="line-added">356 }</span>
<span class="line-added">357 </span>
<span class="line-added">358 static void write_thread_blob(const ObjectSample* sample, JfrCheckpointWriter&amp; writer, bool reset) {</span>
<span class="line-added">359   assert(sample-&gt;has_thread(), &quot;invariant&quot;);</span>
<span class="line-added">360   if (has_thread_exited(sample-&gt;thread_id())) {</span>
<span class="line-added">361     write_blob(sample-&gt;thread(), writer, reset);</span>
<span class="line-added">362   }</span>
<span class="line-added">363 }</span>
<span class="line-added">364 </span>
<span class="line-added">365 static void write_stacktrace_blob(const ObjectSample* sample, JfrCheckpointWriter&amp; writer, bool reset) {</span>
<span class="line-added">366   if (sample-&gt;has_stacktrace()) {</span>
<span class="line-added">367     write_blob(sample-&gt;stacktrace(), writer, reset);</span>
<span class="line-added">368   }</span>
<span class="line-added">369 }</span>
<span class="line-added">370 </span>
<span class="line-added">371 static void write_blobs(const ObjectSample* sample, JfrCheckpointWriter&amp; writer, bool reset) {</span>
<span class="line-added">372   assert(sample != NULL, &quot;invariant&quot;);</span>
<span class="line-added">373   write_stacktrace_blob(sample, writer, reset);</span>
<span class="line-added">374   write_thread_blob(sample, writer, reset);</span>
<span class="line-added">375   write_type_set_blob(sample, writer, reset);</span>
<span class="line-added">376 }</span>
<span class="line-added">377 </span>
<span class="line-added">378 class BlobWriter {</span>
<span class="line-added">379  private:</span>
<span class="line-added">380   const ObjectSampler* _sampler;</span>
<span class="line-added">381   JfrCheckpointWriter&amp; _writer;</span>
<span class="line-added">382   const jlong _last_sweep;</span>
<span class="line-added">383   bool _reset;</span>
<span class="line-added">384  public:</span>
<span class="line-added">385   BlobWriter(const ObjectSampler* sampler, JfrCheckpointWriter&amp; writer, jlong last_sweep) :</span>
<span class="line-added">386     _sampler(sampler), _writer(writer), _last_sweep(last_sweep), _reset(false)  {}</span>
<span class="line-added">387   void sample_do(ObjectSample* sample) {</span>
<span class="line-added">388     if (sample-&gt;is_alive_and_older_than(_last_sweep)) {</span>
<span class="line-added">389       write_blobs(sample, _writer, _reset);</span>
390     }
391   }
<span class="line-modified">392   void set_reset() {</span>
<span class="line-modified">393     _reset = true;</span>


394   }
<span class="line-added">395 };</span>
<span class="line-added">396 </span>
<span class="line-added">397 static void write_sample_blobs(const ObjectSampler* sampler, bool emit_all, Thread* thread) {</span>
<span class="line-added">398   // sample set is predicated on time of last sweep</span>
<span class="line-added">399   const jlong last_sweep = emit_all ? max_jlong : sampler-&gt;last_sweep().value();</span>
<span class="line-added">400   JfrCheckpointWriter writer(thread, false);</span>
<span class="line-added">401   BlobWriter cbw(sampler, writer, last_sweep);</span>
<span class="line-added">402   iterate_samples(cbw, true);</span>
<span class="line-added">403   // reset blob write states</span>
<span class="line-added">404   cbw.set_reset();</span>
<span class="line-added">405   iterate_samples(cbw, true);</span>
406 }
407 
<span class="line-modified">408 void ObjectSampleCheckpoint::write(const ObjectSampler* sampler, EdgeStore* edge_store, bool emit_all, Thread* thread) {</span>
<span class="line-added">409   assert_locked_or_safepoint(JfrStream_lock);</span>
<span class="line-added">410   assert(sampler != NULL, &quot;invariant&quot;);</span>
411   assert(edge_store != NULL, &quot;invariant&quot;);
412   assert(thread != NULL, &quot;invariant&quot;);
<span class="line-modified">413   write_sample_blobs(sampler, emit_all, thread);</span>
<span class="line-modified">414   // write reference chains</span>















415   if (!edge_store-&gt;is_empty()) {
<span class="line-modified">416     JfrCheckpointWriter writer(thread);</span>

417     ObjectSampleWriter osw(writer, edge_store);
<span class="line-modified">418     edge_store-&gt;iterate(osw);</span>
<span class="line-added">419   }</span>
<span class="line-added">420 }</span>
<span class="line-added">421 </span>
<span class="line-added">422 static void clear_unloaded_klass_set() {</span>
<span class="line-added">423   assert(ClassLoaderDataGraph_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-added">424   if (unloaded_klass_set != NULL &amp;&amp; unloaded_klass_set-&gt;is_nonempty()) {</span>
<span class="line-added">425     unloaded_klass_set-&gt;clear();</span>
426   }
427 }
428 
<span class="line-modified">429 // A linked list of saved type set blobs for the epoch.</span>
<span class="line-modified">430 // The link consist of a reference counted handle.</span>
<span class="line-added">431 static JfrBlobHandle saved_type_set_blobs;</span>
<span class="line-added">432 </span>
<span class="line-added">433 static void release_state_for_previous_epoch() {</span>
<span class="line-added">434   // decrements the reference count and the list is reinitialized</span>
<span class="line-added">435   saved_type_set_blobs = JfrBlobHandle();</span>
<span class="line-added">436   clear_unloaded_klass_set();</span>
437 }
438 
<span class="line-modified">439 class BlobInstaller {</span>
<span class="line-modified">440  public:</span>
<span class="line-modified">441   ~BlobInstaller() {</span>
<span class="line-modified">442     release_state_for_previous_epoch();</span>
443   }
<span class="line-modified">444   void sample_do(ObjectSample* sample) {</span>
<span class="line-modified">445     if (!sample-&gt;is_dead()) {</span>
<span class="line-modified">446       sample-&gt;set_type_set(saved_type_set_blobs);</span>
<span class="line-modified">447     }</span>












448   }
<span class="line-added">449 };</span>
450 
<span class="line-modified">451 static void install_type_set_blobs() {</span>
<span class="line-modified">452   BlobInstaller installer;</span>
<span class="line-modified">453   iterate_samples(installer);</span>
<span class="line-modified">454 }</span>

455 
<span class="line-modified">456 static void save_type_set_blob(JfrCheckpointWriter&amp; writer, bool copy = false) {</span>
<span class="line-modified">457   assert(writer.has_data(), &quot;invariant&quot;);</span>
<span class="line-modified">458   const JfrBlobHandle blob = copy ? writer.copy() : writer.move();</span>
<span class="line-modified">459   if (saved_type_set_blobs.valid()) {</span>
<span class="line-modified">460     saved_type_set_blobs-&gt;set_next(blob);</span>
<span class="line-modified">461   } else {</span>
<span class="line-modified">462     saved_type_set_blobs = blob;</span>



463   }
<span class="line-modified">464 }</span>


465 
<span class="line-modified">466 void ObjectSampleCheckpoint::on_type_set(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-modified">467   assert(LeakProfiler::is_running(), &quot;invariant&quot;);</span>
<span class="line-modified">468   const ObjectSample* last = ObjectSampler::sampler()-&gt;last();</span>
<span class="line-added">469   if (writer.has_data() &amp;&amp; last != NULL) {</span>
<span class="line-added">470     save_type_set_blob(writer);</span>
<span class="line-added">471     install_type_set_blobs();</span>
<span class="line-added">472     ObjectSampler::sampler()-&gt;set_last_resolved(last);</span>
<span class="line-added">473   }</span>
474 }
475 
<span class="line-modified">476 void ObjectSampleCheckpoint::on_type_set_unload(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-modified">477   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);</span>
<span class="line-modified">478   assert(LeakProfiler::is_running(), &quot;invariant&quot;);</span>
<span class="line-modified">479   if (writer.has_data() &amp;&amp; ObjectSampler::sampler()-&gt;last() != NULL) {</span>
<span class="line-modified">480     save_type_set_blob(writer, true);</span>

481   }




482 }
</pre>
</td>
</tr>
</table>
<center><a href="../chains/rootSetClosure.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="objectSampleCheckpoint.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
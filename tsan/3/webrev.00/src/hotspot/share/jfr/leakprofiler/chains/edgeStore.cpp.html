<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/jfr/leakprofiler/chains/edgeStore.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/leakprofiler/chains/edgeStore.hpp&quot;
 27 #include &quot;jfr/leakprofiler/chains/edgeUtils.hpp&quot;
 28 #include &quot;jfr/leakprofiler/utilities/unifiedOopRef.inline.hpp&quot;
 29 #include &quot;oops/oop.inline.hpp&quot;
 30 
 31 StoredEdge::StoredEdge(const Edge* parent, UnifiedOopRef reference) : Edge(parent, reference), _gc_root_id(0), _skip_length(0) {}
 32 
 33 StoredEdge::StoredEdge(const Edge&amp; edge) : Edge(edge), _gc_root_id(0), _skip_length(0) {}
 34 
 35 StoredEdge::StoredEdge(const StoredEdge&amp; edge) : Edge(edge), _gc_root_id(edge._gc_root_id), _skip_length(edge._skip_length) {}
 36 
 37 traceid EdgeStore::_edge_id_counter = 0;
 38 
 39 EdgeStore::EdgeStore() : _edges(NULL) {
 40   _edges = new EdgeHashTable(this);
 41 }
 42 
 43 EdgeStore::~EdgeStore() {
 44   assert(_edges != NULL, &quot;invariant&quot;);
 45   delete _edges;
 46 }
 47 
 48 bool EdgeStore::is_empty() const {
 49   return !_edges-&gt;has_entries();
 50 }
 51 
 52 void EdgeStore::on_link(EdgeEntry* entry) {
 53   assert(entry != NULL, &quot;invariant&quot;);
 54   assert(entry-&gt;id() == 0, &quot;invariant&quot;);
 55   entry-&gt;set_id(++_edge_id_counter);
 56 }
 57 
 58 bool EdgeStore::on_equals(uintptr_t hash, const EdgeEntry* entry) {
 59   assert(entry != NULL, &quot;invariant&quot;);
 60   assert(entry-&gt;hash() == hash, &quot;invariant&quot;);
 61   return true;
 62 }
 63 
 64 void EdgeStore::on_unlink(EdgeEntry* entry) {
 65   assert(entry != NULL, &quot;invariant&quot;);
 66   // nothing
 67 }
 68 
 69 #ifdef ASSERT
 70 bool EdgeStore::contains(UnifiedOopRef reference) const {
 71   return get(reference) != NULL;
 72 }
 73 #endif
 74 
 75 StoredEdge* EdgeStore::get(UnifiedOopRef reference) const {
 76   assert(!reference.is_null(), &quot;invariant&quot;);
 77   EdgeEntry* const entry = _edges-&gt;lookup_only(reference.addr&lt;uintptr_t&gt;());
 78   return entry != NULL ? entry-&gt;literal_addr() : NULL;
 79 }
 80 
 81 StoredEdge* EdgeStore::put(UnifiedOopRef reference) {
 82   assert(!reference.is_null(), &quot;invariant&quot;);
 83   const StoredEdge e(NULL, reference);
 84   assert(NULL == _edges-&gt;lookup_only(reference.addr&lt;uintptr_t&gt;()), &quot;invariant&quot;);
 85   EdgeEntry&amp; entry = _edges-&gt;put(reference.addr&lt;uintptr_t&gt;(), e);
 86   return entry.literal_addr();
 87 }
 88 
 89 traceid EdgeStore::get_id(const Edge* edge) const {
 90   assert(edge != NULL, &quot;invariant&quot;);
 91   EdgeEntry* const entry = _edges-&gt;lookup_only(edge-&gt;reference().addr&lt;uintptr_t&gt;());
 92   assert(entry != NULL, &quot;invariant&quot;);
 93   return entry-&gt;id();
 94 }
 95 
 96 traceid EdgeStore::gc_root_id(const Edge* edge) const {
 97   assert(edge != NULL, &quot;invariant&quot;);
 98   const traceid gc_root_id = static_cast&lt;const StoredEdge*&gt;(edge)-&gt;gc_root_id();
 99   if (gc_root_id != 0) {
100     return gc_root_id;
101   }
102   // not cached
103   assert(edge != NULL, &quot;invariant&quot;);
104   const Edge* const root = EdgeUtils::root(*edge);
105   assert(root != NULL, &quot;invariant&quot;);
106   assert(root-&gt;parent() == NULL, &quot;invariant&quot;);
107   return get_id(root);
108 }
109 
110 static const Edge* get_skip_ancestor(const Edge** current, size_t distance_to_root, size_t* skip_length) {
111   assert(distance_to_root &gt;= EdgeUtils::root_context, &quot;invariant&quot;);
112   assert(*skip_length == 0, &quot;invariant&quot;);
113   *skip_length = distance_to_root - (EdgeUtils::root_context - 1);
114   const Edge* const target = EdgeUtils::ancestor(**current, *skip_length);
115   assert(target != NULL, &quot;invariant&quot;);
116   assert(target-&gt;distance_to_root() + 1 == EdgeUtils::root_context, &quot;invariant&quot;);
117   return target;
118 }
119 
120 bool EdgeStore::put_skip_edge(StoredEdge** previous, const Edge** current, size_t distance_to_root) {
121   assert(*previous != NULL, &quot;invariant&quot;);
122   assert((*previous)-&gt;parent() == NULL, &quot;invariant&quot;);
123   assert(*current != NULL, &quot;invariant&quot;);
124   assert((*current)-&gt;distance_to_root() == distance_to_root, &quot;invariant&quot;);
125 
126   if (distance_to_root &lt; EdgeUtils::root_context) {
127     // nothing to skip
128     return false;
129   }
130 
131   size_t skip_length = 0;
132   const Edge* const skip_ancestor = get_skip_ancestor(current, distance_to_root, &amp;skip_length);
133   assert(skip_ancestor != NULL, &quot;invariant&quot;);
134   (*previous)-&gt;set_skip_length(skip_length);
135 
136   // lookup target
137   StoredEdge* stored_target = get(skip_ancestor-&gt;reference());
138   if (stored_target != NULL) {
139     (*previous)-&gt;set_parent(stored_target);
140     // linked to existing, complete
141     return true;
142   }
143 
144   assert(stored_target == NULL, &quot;invariant&quot;);
145   stored_target = put(skip_ancestor-&gt;reference());
146   assert(stored_target != NULL, &quot;invariant&quot;);
147   (*previous)-&gt;set_parent(stored_target);
148   *previous = stored_target;
149   *current = skip_ancestor-&gt;parent();
150   return false;
151 }
152 
153 static void link_edge(const StoredEdge* current_stored, StoredEdge** previous) {
154   assert(current_stored != NULL, &quot;invariant&quot;);
155   assert(*previous != NULL, &quot;invariant&quot;);
156   assert((*previous)-&gt;parent() == NULL, &quot;invariant&quot;);
157   (*previous)-&gt;set_parent(current_stored);
158 }
159 
160 static const StoredEdge* find_closest_skip_edge(const StoredEdge* edge, size_t* distance) {
161   assert(edge != NULL, &quot;invariant&quot;);
162   assert(distance != NULL, &quot;invariant&quot;);
163   const StoredEdge* current = edge;
164   *distance = 1;
165   while (current != NULL &amp;&amp; !current-&gt;is_skip_edge()) {
166     ++(*distance);
167     current = current-&gt;parent();
168   }
169   return current;
170 }
171 
172 void EdgeStore::link_with_existing_chain(const StoredEdge* current_stored, StoredEdge** previous, size_t previous_length) {
173   assert(current_stored != NULL, &quot;invariant&quot;);
174   assert((*previous)-&gt;parent() == NULL, &quot;invariant&quot;);
175   size_t distance_to_skip_edge; // including the skip edge itself
176   const StoredEdge* const closest_skip_edge = find_closest_skip_edge(current_stored, &amp;distance_to_skip_edge);
177   if (closest_skip_edge == NULL) {
178     // no found skip edge implies root
179     if (distance_to_skip_edge + previous_length &lt;= EdgeUtils::max_ref_chain_depth) {
180       link_edge(current_stored, previous);
181       return;
182     }
183     assert(current_stored-&gt;distance_to_root() == distance_to_skip_edge - 2, &quot;invariant&quot;);
184     put_skip_edge(previous, reinterpret_cast&lt;const Edge**&gt;(&amp;current_stored), distance_to_skip_edge - 2);
185     return;
186   }
187   assert(closest_skip_edge-&gt;is_skip_edge(), &quot;invariant&quot;);
188   if (distance_to_skip_edge + previous_length &lt;= EdgeUtils::leak_context) {
189     link_edge(current_stored, previous);
190     return;
191   }
192   // create a new skip edge with derived information from closest skip edge
193   (*previous)-&gt;set_skip_length(distance_to_skip_edge + closest_skip_edge-&gt;skip_length());
194   (*previous)-&gt;set_parent(closest_skip_edge-&gt;parent());
195 }
196 
197 StoredEdge* EdgeStore::link_new_edge(StoredEdge** previous, const Edge** current) {
198   assert(*previous != NULL, &quot;invariant&quot;);
199   assert((*previous)-&gt;parent() == NULL, &quot;invariant&quot;);
200   assert(*current != NULL, &quot;invariant&quot;);
201   assert(!contains((*current)-&gt;reference()), &quot;invariant&quot;);
202   StoredEdge* const stored_edge = put((*current)-&gt;reference());
203   assert(stored_edge != NULL, &quot;invariant&quot;);
204   link_edge(stored_edge, previous);
205   return stored_edge;
206 }
207 
208 bool EdgeStore::put_edges(StoredEdge** previous, const Edge** current, size_t limit) {
209   assert(*previous != NULL, &quot;invariant&quot;);
210   assert(*current != NULL, &quot;invariant&quot;);
211   size_t depth = 1;
212   while (*current != NULL &amp;&amp; depth &lt; limit) {
213     StoredEdge* stored_edge = get((*current)-&gt;reference());
214     if (stored_edge != NULL) {
215       link_with_existing_chain(stored_edge, previous, depth);
216       return true;
217     }
218     stored_edge = link_new_edge(previous, current);
219     assert((*previous)-&gt;parent() != NULL, &quot;invariant&quot;);
220     *previous = stored_edge;
221     *current = (*current)-&gt;parent();
222     ++depth;
223   }
224   return NULL == *current;
225 }
226 
227 // Install the immediate edge into the mark word of the leak candidate object
228 StoredEdge* EdgeStore::associate_leak_context_with_candidate(const Edge* edge) {
229   assert(edge != NULL, &quot;invariant&quot;);
230   assert(!contains(edge-&gt;reference()), &quot;invariant&quot;);
231   StoredEdge* const leak_context_edge = put(edge-&gt;reference());
232   oop sample_object = edge-&gt;pointee();
233   assert(sample_object != NULL, &quot;invariant&quot;);
234   assert(sample_object-&gt;mark().is_marked(), &quot;invariant&quot;);
235   sample_object-&gt;set_mark(markWord::from_pointer(leak_context_edge));
236   return leak_context_edge;
237 }
238 
239 /*
240  * The purpose of put_chain() is to reify the edge sequence
241  * discovered during heap traversal with a normalized logical copy.
242  * This copy consist of two sub-sequences and a connecting link (skip edge).
243  *
244  * &quot;current&quot; can be thought of as the cursor (search) edge, it is not in the edge store.
245  * &quot;previous&quot; is always an edge in the edge store.
246  * The leak context edge is the edge adjacent to the leak candidate object, always an edge in the edge store.
247  */
248 void EdgeStore::put_chain(const Edge* chain, size_t length) {
249   assert(chain != NULL, &quot;invariant&quot;);
250   assert(chain-&gt;distance_to_root() + 1 == length, &quot;invariant&quot;);
251   StoredEdge* const leak_context_edge = associate_leak_context_with_candidate(chain);
252   assert(leak_context_edge != NULL, &quot;invariant&quot;);
253   assert(leak_context_edge-&gt;parent() == NULL, &quot;invariant&quot;);
254 
255   if (1 == length) {
256     store_gc_root_id_in_leak_context_edge(leak_context_edge, leak_context_edge);
257     return;
258   }
259 
260   const Edge* current = chain-&gt;parent();
261   assert(current != NULL, &quot;invariant&quot;);
262   StoredEdge* previous = leak_context_edge;
263 
264   // a leak context is the sequence of (limited) edges reachable from the leak candidate
265   if (put_edges(&amp;previous, &amp;current, EdgeUtils::leak_context)) {
266     // complete
267     assert(previous != NULL, &quot;invariant&quot;);
268     put_chain_epilogue(leak_context_edge, EdgeUtils::root(*previous));
269     return;
270   }
271 
272   const size_t distance_to_root = length &gt; EdgeUtils::leak_context ? length - 1 - EdgeUtils::leak_context : length - 1;
273   assert(current-&gt;distance_to_root() == distance_to_root, &quot;invariant&quot;);
274 
275   // a skip edge is the logical link
276   // connecting the leak context sequence with the root context sequence
277   if (put_skip_edge(&amp;previous, &amp;current, distance_to_root)) {
278     // complete
279     assert(previous != NULL, &quot;invariant&quot;);
280     assert(previous-&gt;is_skip_edge(), &quot;invariant&quot;);
281     assert(previous-&gt;parent() != NULL, &quot;invariant&quot;);
282     put_chain_epilogue(leak_context_edge, EdgeUtils::root(*previous-&gt;parent()));
283     return;
284   }
285 
286   assert(current-&gt;distance_to_root() &lt; EdgeUtils::root_context, &quot;invariant&quot;);
287 
288   // a root context is the sequence of (limited) edges reachable from the root
289   put_edges(&amp;previous, &amp;current, EdgeUtils::root_context);
290   assert(previous != NULL, &quot;invariant&quot;);
291   put_chain_epilogue(leak_context_edge, EdgeUtils::root(*previous));
292 }
293 
294 void EdgeStore::put_chain_epilogue(StoredEdge* leak_context_edge, const Edge* root) const {
295   assert(leak_context_edge != NULL, &quot;invariant&quot;);
296   assert(root != NULL, &quot;invariant&quot;);
297   store_gc_root_id_in_leak_context_edge(leak_context_edge, root);
298   assert(leak_context_edge-&gt;distance_to_root() + 1 &lt;= EdgeUtils::max_ref_chain_depth, &quot;invariant&quot;);
299 }
300 
301 // To avoid another traversal to resolve the root edge id later,
302 // cache it in the immediate leak context edge for fast retrieval.
303 void EdgeStore::store_gc_root_id_in_leak_context_edge(StoredEdge* leak_context_edge, const Edge* root) const {
304   assert(leak_context_edge != NULL, &quot;invariant&quot;);
305   assert(leak_context_edge-&gt;gc_root_id() == 0, &quot;invariant&quot;);
306   assert(root != NULL, &quot;invariant&quot;);
307   assert(root-&gt;parent() == NULL, &quot;invariant&quot;);
308   assert(root-&gt;distance_to_root() == 0, &quot;invariant&quot;);
309   const StoredEdge* const stored_root = static_cast&lt;const StoredEdge*&gt;(root);
310   traceid root_id = stored_root-&gt;gc_root_id();
311   if (root_id == 0) {
312     root_id = get_id(root);
313     stored_root-&gt;set_gc_root_id(root_id);
314   }
315   assert(root_id != 0, &quot;invariant&quot;);
316   leak_context_edge-&gt;set_gc_root_id(root_id);
317   assert(leak_context_edge-&gt;gc_root_id() == stored_root-&gt;gc_root_id(), &quot;invariant&quot;);
318 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/leakprofiler/chains/edgeStore.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="edgeQueue.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="edgeStore.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/leakprofiler/chains/edgeStore.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/leakprofiler/chains/edgeStore.hpp&quot;
 27 #include &quot;jfr/leakprofiler/chains/edgeUtils.hpp&quot;

 28 #include &quot;oops/oop.inline.hpp&quot;
 29 
<span class="line-modified"> 30 RoutableEdge::RoutableEdge() : Edge() {}</span>
<span class="line-modified"> 31 RoutableEdge::RoutableEdge(const Edge* parent, const oop* reference) : Edge(parent, reference),</span>
<span class="line-modified"> 32                                                                        _skip_edge(NULL),</span>
<span class="line-modified"> 33                                                                        _skip_length(0),</span>
<span class="line-modified"> 34                                                                        _processed(false) {}</span>
<span class="line-removed"> 35 </span>
<span class="line-removed"> 36 RoutableEdge::RoutableEdge(const Edge&amp; edge) : Edge(edge),</span>
<span class="line-removed"> 37                                                _skip_edge(NULL),</span>
<span class="line-removed"> 38                                                _skip_length(0),</span>
<span class="line-removed"> 39                                                _processed(false) {}</span>
<span class="line-removed"> 40 </span>
<span class="line-removed"> 41 RoutableEdge::RoutableEdge(const RoutableEdge&amp; edge) : Edge(edge),</span>
<span class="line-removed"> 42                                                       _skip_edge(edge._skip_edge),</span>
<span class="line-removed"> 43                                                       _skip_length(edge._skip_length),</span>
<span class="line-removed"> 44                                                       _processed(edge._processed) {}</span>
<span class="line-removed"> 45 </span>
<span class="line-removed"> 46 void RoutableEdge::operator=(const RoutableEdge&amp; edge) {</span>
<span class="line-removed"> 47   Edge::operator=(edge);</span>
<span class="line-removed"> 48   _skip_edge = edge._skip_edge;</span>
<span class="line-removed"> 49   _skip_length = edge._skip_length;</span>
<span class="line-removed"> 50   _processed = edge._processed;</span>
<span class="line-removed"> 51 }</span>
<span class="line-removed"> 52 </span>
<span class="line-removed"> 53 size_t RoutableEdge::logical_distance_to_root() const {</span>
<span class="line-removed"> 54   size_t depth = 0;</span>
<span class="line-removed"> 55   const RoutableEdge* current = logical_parent();</span>
<span class="line-removed"> 56   while (current != NULL) {</span>
<span class="line-removed"> 57     depth++;</span>
<span class="line-removed"> 58     current = current-&gt;logical_parent();</span>
<span class="line-removed"> 59   }</span>
<span class="line-removed"> 60   return depth;</span>
<span class="line-removed"> 61 }</span>
 62 
 63 traceid EdgeStore::_edge_id_counter = 0;
 64 
 65 EdgeStore::EdgeStore() : _edges(NULL) {
 66   _edges = new EdgeHashTable(this);
 67 }
 68 
 69 EdgeStore::~EdgeStore() {
 70   assert(_edges != NULL, &quot;invariant&quot;);
 71   delete _edges;
<span class="line-removed"> 72   _edges = NULL;</span>
 73 }
 74 
<span class="line-modified"> 75 const Edge* EdgeStore::get_edge(const Edge* edge) const {</span>
<span class="line-modified"> 76   assert(edge != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 77   EdgeEntry* const entry = _edges-&gt;lookup_only(*edge, (uintptr_t)edge-&gt;reference());</span>



























 78   return entry != NULL ? entry-&gt;literal_addr() : NULL;
 79 }
 80 
<span class="line-modified"> 81 const Edge* EdgeStore::put(const Edge* edge) {</span>
<span class="line-modified"> 82   assert(edge != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 83   const RoutableEdge e = *edge;</span>
<span class="line-modified"> 84   assert(NULL == _edges-&gt;lookup_only(e, (uintptr_t)e.reference()), &quot;invariant&quot;);</span>
<span class="line-modified"> 85   EdgeEntry&amp; entry = _edges-&gt;put(e, (uintptr_t)e.reference());</span>
 86   return entry.literal_addr();
 87 }
 88 
 89 traceid EdgeStore::get_id(const Edge* edge) const {
 90   assert(edge != NULL, &quot;invariant&quot;);
<span class="line-modified"> 91   EdgeEntry* const entry = _edges-&gt;lookup_only(*edge, (uintptr_t)edge-&gt;reference());</span>
 92   assert(entry != NULL, &quot;invariant&quot;);
 93   return entry-&gt;id();
 94 }
 95 
<span class="line-modified"> 96 traceid EdgeStore::get_root_id(const Edge* edge) const {</span>






 97   assert(edge != NULL, &quot;invariant&quot;);
<span class="line-modified"> 98   const Edge* root = EdgeUtils::root(*edge);</span>
 99   assert(root != NULL, &quot;invariant&quot;);

100   return get_id(root);
101 }
102 
<span class="line-modified">103 void EdgeStore::add_chain(const Edge* chain, size_t length) {</span>
<span class="line-modified">104   assert(chain != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">105   assert(length &gt; 0, &quot;invariant&quot;);</span>






106 
<span class="line-modified">107   size_t bottom_index = length - 1;</span>
<span class="line-modified">108   const size_t top_index = 0;</span>



109 
<span class="line-modified">110   const Edge* stored_parent_edge = NULL;</span>



111 
<span class="line-modified">112   // determine level of shared ancestry</span>
<span class="line-modified">113   for (; bottom_index &gt; top_index; --bottom_index) {</span>
<span class="line-modified">114     const Edge* stored_edge = get_edge(&amp;chain[bottom_index]);</span>
<span class="line-modified">115     if (stored_edge != NULL) {</span>
<span class="line-modified">116       stored_parent_edge = stored_edge;</span>
<span class="line-modified">117       continue;</span>
<span class="line-modified">118     }</span>
<span class="line-modified">119     break;</span>





























120   }


121 
<span class="line-modified">122   // insertion of new Edges</span>
<span class="line-modified">123   for (int i = (int)bottom_index; i &gt;= (int)top_index; --i) {</span>
<span class="line-modified">124     Edge edge(stored_parent_edge, chain[i].reference());</span>
<span class="line-modified">125     stored_parent_edge = put(&amp;edge);</span>















126   }




127 
<span class="line-modified">128   const oop sample_object = stored_parent_edge-&gt;pointee();</span>
<span class="line-modified">129   assert(sample_object != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">130   assert(NULL == sample_object-&gt;mark(), &quot;invariant&quot;);</span>







131 
<span class="line-modified">132   // Install the &quot;top&quot; edge of the chain into the sample object mark oop.</span>
<span class="line-modified">133   // This associates the sample object with its navigable reference chain.</span>
<span class="line-modified">134   sample_object-&gt;set_mark(markOop(stored_parent_edge));</span>














135 }
136 
<span class="line-modified">137 bool EdgeStore::is_empty() const {</span>
<span class="line-modified">138   return !_edges-&gt;has_entries();</span>








139 }
140 
<span class="line-modified">141 size_t EdgeStore::number_of_entries() const {</span>
<span class="line-modified">142   return _edges-&gt;cardinality();</span>



















































143 }
144 
<span class="line-modified">145 void EdgeStore::assign_id(EdgeEntry* entry) {</span>
<span class="line-modified">146   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">147   assert(entry-&gt;id() == 0, &quot;invariant&quot;);</span>
<span class="line-modified">148   entry-&gt;set_id(++_edge_id_counter);</span>

149 }
150 
<span class="line-modified">151 bool EdgeStore::equals(const Edge&amp; query, uintptr_t hash, const EdgeEntry* entry) {</span>
<span class="line-modified">152   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">153   assert(entry-&gt;hash() == hash, &quot;invariant&quot;);</span>
<span class="line-modified">154   return true;</span>













155 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/leakprofiler/chains/edgeStore.hpp&quot;
 27 #include &quot;jfr/leakprofiler/chains/edgeUtils.hpp&quot;
<span class="line-added"> 28 #include &quot;jfr/leakprofiler/utilities/unifiedOopRef.inline.hpp&quot;</span>
 29 #include &quot;oops/oop.inline.hpp&quot;
 30 
<span class="line-modified"> 31 StoredEdge::StoredEdge(const Edge* parent, UnifiedOopRef reference) : Edge(parent, reference), _gc_root_id(0), _skip_length(0) {}</span>
<span class="line-modified"> 32 </span>
<span class="line-modified"> 33 StoredEdge::StoredEdge(const Edge&amp; edge) : Edge(edge), _gc_root_id(0), _skip_length(0) {}</span>
<span class="line-modified"> 34 </span>
<span class="line-modified"> 35 StoredEdge::StoredEdge(const StoredEdge&amp; edge) : Edge(edge), _gc_root_id(edge._gc_root_id), _skip_length(edge._skip_length) {}</span>



























 36 
 37 traceid EdgeStore::_edge_id_counter = 0;
 38 
 39 EdgeStore::EdgeStore() : _edges(NULL) {
 40   _edges = new EdgeHashTable(this);
 41 }
 42 
 43 EdgeStore::~EdgeStore() {
 44   assert(_edges != NULL, &quot;invariant&quot;);
 45   delete _edges;

 46 }
 47 
<span class="line-modified"> 48 bool EdgeStore::is_empty() const {</span>
<span class="line-modified"> 49   return !_edges-&gt;has_entries();</span>
<span class="line-modified"> 50 }</span>
<span class="line-added"> 51 </span>
<span class="line-added"> 52 void EdgeStore::on_link(EdgeEntry* entry) {</span>
<span class="line-added"> 53   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 54   assert(entry-&gt;id() == 0, &quot;invariant&quot;);</span>
<span class="line-added"> 55   entry-&gt;set_id(++_edge_id_counter);</span>
<span class="line-added"> 56 }</span>
<span class="line-added"> 57 </span>
<span class="line-added"> 58 bool EdgeStore::on_equals(uintptr_t hash, const EdgeEntry* entry) {</span>
<span class="line-added"> 59   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 60   assert(entry-&gt;hash() == hash, &quot;invariant&quot;);</span>
<span class="line-added"> 61   return true;</span>
<span class="line-added"> 62 }</span>
<span class="line-added"> 63 </span>
<span class="line-added"> 64 void EdgeStore::on_unlink(EdgeEntry* entry) {</span>
<span class="line-added"> 65   assert(entry != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 66   // nothing</span>
<span class="line-added"> 67 }</span>
<span class="line-added"> 68 </span>
<span class="line-added"> 69 #ifdef ASSERT</span>
<span class="line-added"> 70 bool EdgeStore::contains(UnifiedOopRef reference) const {</span>
<span class="line-added"> 71   return get(reference) != NULL;</span>
<span class="line-added"> 72 }</span>
<span class="line-added"> 73 #endif</span>
<span class="line-added"> 74 </span>
<span class="line-added"> 75 StoredEdge* EdgeStore::get(UnifiedOopRef reference) const {</span>
<span class="line-added"> 76   assert(!reference.is_null(), &quot;invariant&quot;);</span>
<span class="line-added"> 77   EdgeEntry* const entry = _edges-&gt;lookup_only(reference.addr&lt;uintptr_t&gt;());</span>
 78   return entry != NULL ? entry-&gt;literal_addr() : NULL;
 79 }
 80 
<span class="line-modified"> 81 StoredEdge* EdgeStore::put(UnifiedOopRef reference) {</span>
<span class="line-modified"> 82   assert(!reference.is_null(), &quot;invariant&quot;);</span>
<span class="line-modified"> 83   const StoredEdge e(NULL, reference);</span>
<span class="line-modified"> 84   assert(NULL == _edges-&gt;lookup_only(reference.addr&lt;uintptr_t&gt;()), &quot;invariant&quot;);</span>
<span class="line-modified"> 85   EdgeEntry&amp; entry = _edges-&gt;put(reference.addr&lt;uintptr_t&gt;(), e);</span>
 86   return entry.literal_addr();
 87 }
 88 
 89 traceid EdgeStore::get_id(const Edge* edge) const {
 90   assert(edge != NULL, &quot;invariant&quot;);
<span class="line-modified"> 91   EdgeEntry* const entry = _edges-&gt;lookup_only(edge-&gt;reference().addr&lt;uintptr_t&gt;());</span>
 92   assert(entry != NULL, &quot;invariant&quot;);
 93   return entry-&gt;id();
 94 }
 95 
<span class="line-modified"> 96 traceid EdgeStore::gc_root_id(const Edge* edge) const {</span>
<span class="line-added"> 97   assert(edge != NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 98   const traceid gc_root_id = static_cast&lt;const StoredEdge*&gt;(edge)-&gt;gc_root_id();</span>
<span class="line-added"> 99   if (gc_root_id != 0) {</span>
<span class="line-added">100     return gc_root_id;</span>
<span class="line-added">101   }</span>
<span class="line-added">102   // not cached</span>
103   assert(edge != NULL, &quot;invariant&quot;);
<span class="line-modified">104   const Edge* const root = EdgeUtils::root(*edge);</span>
105   assert(root != NULL, &quot;invariant&quot;);
<span class="line-added">106   assert(root-&gt;parent() == NULL, &quot;invariant&quot;);</span>
107   return get_id(root);
108 }
109 
<span class="line-modified">110 static const Edge* get_skip_ancestor(const Edge** current, size_t distance_to_root, size_t* skip_length) {</span>
<span class="line-modified">111   assert(distance_to_root &gt;= EdgeUtils::root_context, &quot;invariant&quot;);</span>
<span class="line-modified">112   assert(*skip_length == 0, &quot;invariant&quot;);</span>
<span class="line-added">113   *skip_length = distance_to_root - (EdgeUtils::root_context - 1);</span>
<span class="line-added">114   const Edge* const target = EdgeUtils::ancestor(**current, *skip_length);</span>
<span class="line-added">115   assert(target != NULL, &quot;invariant&quot;);</span>
<span class="line-added">116   assert(target-&gt;distance_to_root() + 1 == EdgeUtils::root_context, &quot;invariant&quot;);</span>
<span class="line-added">117   return target;</span>
<span class="line-added">118 }</span>
119 
<span class="line-modified">120 bool EdgeStore::put_skip_edge(StoredEdge** previous, const Edge** current, size_t distance_to_root) {</span>
<span class="line-modified">121   assert(*previous != NULL, &quot;invariant&quot;);</span>
<span class="line-added">122   assert((*previous)-&gt;parent() == NULL, &quot;invariant&quot;);</span>
<span class="line-added">123   assert(*current != NULL, &quot;invariant&quot;);</span>
<span class="line-added">124   assert((*current)-&gt;distance_to_root() == distance_to_root, &quot;invariant&quot;);</span>
125 
<span class="line-modified">126   if (distance_to_root &lt; EdgeUtils::root_context) {</span>
<span class="line-added">127     // nothing to skip</span>
<span class="line-added">128     return false;</span>
<span class="line-added">129   }</span>
130 
<span class="line-modified">131   size_t skip_length = 0;</span>
<span class="line-modified">132   const Edge* const skip_ancestor = get_skip_ancestor(current, distance_to_root, &amp;skip_length);</span>
<span class="line-modified">133   assert(skip_ancestor != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">134   (*previous)-&gt;set_skip_length(skip_length);</span>
<span class="line-modified">135 </span>
<span class="line-modified">136   // lookup target</span>
<span class="line-modified">137   StoredEdge* stored_target = get(skip_ancestor-&gt;reference());</span>
<span class="line-modified">138   if (stored_target != NULL) {</span>
<span class="line-added">139     (*previous)-&gt;set_parent(stored_target);</span>
<span class="line-added">140     // linked to existing, complete</span>
<span class="line-added">141     return true;</span>
<span class="line-added">142   }</span>
<span class="line-added">143 </span>
<span class="line-added">144   assert(stored_target == NULL, &quot;invariant&quot;);</span>
<span class="line-added">145   stored_target = put(skip_ancestor-&gt;reference());</span>
<span class="line-added">146   assert(stored_target != NULL, &quot;invariant&quot;);</span>
<span class="line-added">147   (*previous)-&gt;set_parent(stored_target);</span>
<span class="line-added">148   *previous = stored_target;</span>
<span class="line-added">149   *current = skip_ancestor-&gt;parent();</span>
<span class="line-added">150   return false;</span>
<span class="line-added">151 }</span>
<span class="line-added">152 </span>
<span class="line-added">153 static void link_edge(const StoredEdge* current_stored, StoredEdge** previous) {</span>
<span class="line-added">154   assert(current_stored != NULL, &quot;invariant&quot;);</span>
<span class="line-added">155   assert(*previous != NULL, &quot;invariant&quot;);</span>
<span class="line-added">156   assert((*previous)-&gt;parent() == NULL, &quot;invariant&quot;);</span>
<span class="line-added">157   (*previous)-&gt;set_parent(current_stored);</span>
<span class="line-added">158 }</span>
<span class="line-added">159 </span>
<span class="line-added">160 static const StoredEdge* find_closest_skip_edge(const StoredEdge* edge, size_t* distance) {</span>
<span class="line-added">161   assert(edge != NULL, &quot;invariant&quot;);</span>
<span class="line-added">162   assert(distance != NULL, &quot;invariant&quot;);</span>
<span class="line-added">163   const StoredEdge* current = edge;</span>
<span class="line-added">164   *distance = 1;</span>
<span class="line-added">165   while (current != NULL &amp;&amp; !current-&gt;is_skip_edge()) {</span>
<span class="line-added">166     ++(*distance);</span>
<span class="line-added">167     current = current-&gt;parent();</span>
168   }
<span class="line-added">169   return current;</span>
<span class="line-added">170 }</span>
171 
<span class="line-modified">172 void EdgeStore::link_with_existing_chain(const StoredEdge* current_stored, StoredEdge** previous, size_t previous_length) {</span>
<span class="line-modified">173   assert(current_stored != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">174   assert((*previous)-&gt;parent() == NULL, &quot;invariant&quot;);</span>
<span class="line-modified">175   size_t distance_to_skip_edge; // including the skip edge itself</span>
<span class="line-added">176   const StoredEdge* const closest_skip_edge = find_closest_skip_edge(current_stored, &amp;distance_to_skip_edge);</span>
<span class="line-added">177   if (closest_skip_edge == NULL) {</span>
<span class="line-added">178     // no found skip edge implies root</span>
<span class="line-added">179     if (distance_to_skip_edge + previous_length &lt;= EdgeUtils::max_ref_chain_depth) {</span>
<span class="line-added">180       link_edge(current_stored, previous);</span>
<span class="line-added">181       return;</span>
<span class="line-added">182     }</span>
<span class="line-added">183     assert(current_stored-&gt;distance_to_root() == distance_to_skip_edge - 2, &quot;invariant&quot;);</span>
<span class="line-added">184     put_skip_edge(previous, reinterpret_cast&lt;const Edge**&gt;(&amp;current_stored), distance_to_skip_edge - 2);</span>
<span class="line-added">185     return;</span>
<span class="line-added">186   }</span>
<span class="line-added">187   assert(closest_skip_edge-&gt;is_skip_edge(), &quot;invariant&quot;);</span>
<span class="line-added">188   if (distance_to_skip_edge + previous_length &lt;= EdgeUtils::leak_context) {</span>
<span class="line-added">189     link_edge(current_stored, previous);</span>
<span class="line-added">190     return;</span>
191   }
<span class="line-added">192   // create a new skip edge with derived information from closest skip edge</span>
<span class="line-added">193   (*previous)-&gt;set_skip_length(distance_to_skip_edge + closest_skip_edge-&gt;skip_length());</span>
<span class="line-added">194   (*previous)-&gt;set_parent(closest_skip_edge-&gt;parent());</span>
<span class="line-added">195 }</span>
196 
<span class="line-modified">197 StoredEdge* EdgeStore::link_new_edge(StoredEdge** previous, const Edge** current) {</span>
<span class="line-modified">198   assert(*previous != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">199   assert((*previous)-&gt;parent() == NULL, &quot;invariant&quot;);</span>
<span class="line-added">200   assert(*current != NULL, &quot;invariant&quot;);</span>
<span class="line-added">201   assert(!contains((*current)-&gt;reference()), &quot;invariant&quot;);</span>
<span class="line-added">202   StoredEdge* const stored_edge = put((*current)-&gt;reference());</span>
<span class="line-added">203   assert(stored_edge != NULL, &quot;invariant&quot;);</span>
<span class="line-added">204   link_edge(stored_edge, previous);</span>
<span class="line-added">205   return stored_edge;</span>
<span class="line-added">206 }</span>
207 
<span class="line-modified">208 bool EdgeStore::put_edges(StoredEdge** previous, const Edge** current, size_t limit) {</span>
<span class="line-modified">209   assert(*previous != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">210   assert(*current != NULL, &quot;invariant&quot;);</span>
<span class="line-added">211   size_t depth = 1;</span>
<span class="line-added">212   while (*current != NULL &amp;&amp; depth &lt; limit) {</span>
<span class="line-added">213     StoredEdge* stored_edge = get((*current)-&gt;reference());</span>
<span class="line-added">214     if (stored_edge != NULL) {</span>
<span class="line-added">215       link_with_existing_chain(stored_edge, previous, depth);</span>
<span class="line-added">216       return true;</span>
<span class="line-added">217     }</span>
<span class="line-added">218     stored_edge = link_new_edge(previous, current);</span>
<span class="line-added">219     assert((*previous)-&gt;parent() != NULL, &quot;invariant&quot;);</span>
<span class="line-added">220     *previous = stored_edge;</span>
<span class="line-added">221     *current = (*current)-&gt;parent();</span>
<span class="line-added">222     ++depth;</span>
<span class="line-added">223   }</span>
<span class="line-added">224   return NULL == *current;</span>
225 }
226 
<span class="line-modified">227 // Install the immediate edge into the mark word of the leak candidate object</span>
<span class="line-modified">228 StoredEdge* EdgeStore::associate_leak_context_with_candidate(const Edge* edge) {</span>
<span class="line-added">229   assert(edge != NULL, &quot;invariant&quot;);</span>
<span class="line-added">230   assert(!contains(edge-&gt;reference()), &quot;invariant&quot;);</span>
<span class="line-added">231   StoredEdge* const leak_context_edge = put(edge-&gt;reference());</span>
<span class="line-added">232   oop sample_object = edge-&gt;pointee();</span>
<span class="line-added">233   assert(sample_object != NULL, &quot;invariant&quot;);</span>
<span class="line-added">234   assert(sample_object-&gt;mark().is_marked(), &quot;invariant&quot;);</span>
<span class="line-added">235   sample_object-&gt;set_mark(markWord::from_pointer(leak_context_edge));</span>
<span class="line-added">236   return leak_context_edge;</span>
237 }
238 
<span class="line-modified">239 /*</span>
<span class="line-modified">240  * The purpose of put_chain() is to reify the edge sequence</span>
<span class="line-added">241  * discovered during heap traversal with a normalized logical copy.</span>
<span class="line-added">242  * This copy consist of two sub-sequences and a connecting link (skip edge).</span>
<span class="line-added">243  *</span>
<span class="line-added">244  * &quot;current&quot; can be thought of as the cursor (search) edge, it is not in the edge store.</span>
<span class="line-added">245  * &quot;previous&quot; is always an edge in the edge store.</span>
<span class="line-added">246  * The leak context edge is the edge adjacent to the leak candidate object, always an edge in the edge store.</span>
<span class="line-added">247  */</span>
<span class="line-added">248 void EdgeStore::put_chain(const Edge* chain, size_t length) {</span>
<span class="line-added">249   assert(chain != NULL, &quot;invariant&quot;);</span>
<span class="line-added">250   assert(chain-&gt;distance_to_root() + 1 == length, &quot;invariant&quot;);</span>
<span class="line-added">251   StoredEdge* const leak_context_edge = associate_leak_context_with_candidate(chain);</span>
<span class="line-added">252   assert(leak_context_edge != NULL, &quot;invariant&quot;);</span>
<span class="line-added">253   assert(leak_context_edge-&gt;parent() == NULL, &quot;invariant&quot;);</span>
<span class="line-added">254 </span>
<span class="line-added">255   if (1 == length) {</span>
<span class="line-added">256     store_gc_root_id_in_leak_context_edge(leak_context_edge, leak_context_edge);</span>
<span class="line-added">257     return;</span>
<span class="line-added">258   }</span>
<span class="line-added">259 </span>
<span class="line-added">260   const Edge* current = chain-&gt;parent();</span>
<span class="line-added">261   assert(current != NULL, &quot;invariant&quot;);</span>
<span class="line-added">262   StoredEdge* previous = leak_context_edge;</span>
<span class="line-added">263 </span>
<span class="line-added">264   // a leak context is the sequence of (limited) edges reachable from the leak candidate</span>
<span class="line-added">265   if (put_edges(&amp;previous, &amp;current, EdgeUtils::leak_context)) {</span>
<span class="line-added">266     // complete</span>
<span class="line-added">267     assert(previous != NULL, &quot;invariant&quot;);</span>
<span class="line-added">268     put_chain_epilogue(leak_context_edge, EdgeUtils::root(*previous));</span>
<span class="line-added">269     return;</span>
<span class="line-added">270   }</span>
<span class="line-added">271 </span>
<span class="line-added">272   const size_t distance_to_root = length &gt; EdgeUtils::leak_context ? length - 1 - EdgeUtils::leak_context : length - 1;</span>
<span class="line-added">273   assert(current-&gt;distance_to_root() == distance_to_root, &quot;invariant&quot;);</span>
<span class="line-added">274 </span>
<span class="line-added">275   // a skip edge is the logical link</span>
<span class="line-added">276   // connecting the leak context sequence with the root context sequence</span>
<span class="line-added">277   if (put_skip_edge(&amp;previous, &amp;current, distance_to_root)) {</span>
<span class="line-added">278     // complete</span>
<span class="line-added">279     assert(previous != NULL, &quot;invariant&quot;);</span>
<span class="line-added">280     assert(previous-&gt;is_skip_edge(), &quot;invariant&quot;);</span>
<span class="line-added">281     assert(previous-&gt;parent() != NULL, &quot;invariant&quot;);</span>
<span class="line-added">282     put_chain_epilogue(leak_context_edge, EdgeUtils::root(*previous-&gt;parent()));</span>
<span class="line-added">283     return;</span>
<span class="line-added">284   }</span>
<span class="line-added">285 </span>
<span class="line-added">286   assert(current-&gt;distance_to_root() &lt; EdgeUtils::root_context, &quot;invariant&quot;);</span>
<span class="line-added">287 </span>
<span class="line-added">288   // a root context is the sequence of (limited) edges reachable from the root</span>
<span class="line-added">289   put_edges(&amp;previous, &amp;current, EdgeUtils::root_context);</span>
<span class="line-added">290   assert(previous != NULL, &quot;invariant&quot;);</span>
<span class="line-added">291   put_chain_epilogue(leak_context_edge, EdgeUtils::root(*previous));</span>
292 }
293 
<span class="line-modified">294 void EdgeStore::put_chain_epilogue(StoredEdge* leak_context_edge, const Edge* root) const {</span>
<span class="line-modified">295   assert(leak_context_edge != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">296   assert(root != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">297   store_gc_root_id_in_leak_context_edge(leak_context_edge, root);</span>
<span class="line-added">298   assert(leak_context_edge-&gt;distance_to_root() + 1 &lt;= EdgeUtils::max_ref_chain_depth, &quot;invariant&quot;);</span>
299 }
300 
<span class="line-modified">301 // To avoid another traversal to resolve the root edge id later,</span>
<span class="line-modified">302 // cache it in the immediate leak context edge for fast retrieval.</span>
<span class="line-modified">303 void EdgeStore::store_gc_root_id_in_leak_context_edge(StoredEdge* leak_context_edge, const Edge* root) const {</span>
<span class="line-modified">304   assert(leak_context_edge != NULL, &quot;invariant&quot;);</span>
<span class="line-added">305   assert(leak_context_edge-&gt;gc_root_id() == 0, &quot;invariant&quot;);</span>
<span class="line-added">306   assert(root != NULL, &quot;invariant&quot;);</span>
<span class="line-added">307   assert(root-&gt;parent() == NULL, &quot;invariant&quot;);</span>
<span class="line-added">308   assert(root-&gt;distance_to_root() == 0, &quot;invariant&quot;);</span>
<span class="line-added">309   const StoredEdge* const stored_root = static_cast&lt;const StoredEdge*&gt;(root);</span>
<span class="line-added">310   traceid root_id = stored_root-&gt;gc_root_id();</span>
<span class="line-added">311   if (root_id == 0) {</span>
<span class="line-added">312     root_id = get_id(root);</span>
<span class="line-added">313     stored_root-&gt;set_gc_root_id(root_id);</span>
<span class="line-added">314   }</span>
<span class="line-added">315   assert(root_id != 0, &quot;invariant&quot;);</span>
<span class="line-added">316   leak_context_edge-&gt;set_gc_root_id(root_id);</span>
<span class="line-added">317   assert(leak_context_edge-&gt;gc_root_id() == stored_root-&gt;gc_root_id(), &quot;invariant&quot;);</span>
318 }
</pre>
</td>
</tr>
</table>
<center><a href="edgeQueue.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="edgeStore.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
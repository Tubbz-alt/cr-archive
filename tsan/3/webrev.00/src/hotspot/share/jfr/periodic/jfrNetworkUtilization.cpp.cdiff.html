<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/jfr/periodic/jfrNetworkUtilization.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../metadata/metadata.xsd.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jfrOSInterface.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/periodic/jfrNetworkUtilization.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 37,11 ***</span>
  struct InterfaceEntry {
    char* name;
    traceid id;
    uint64_t bytes_in;
    uint64_t bytes_out;
<span class="line-modified">!   bool in_use;</span>
  };
  
  static GrowableArray&lt;InterfaceEntry&gt;* _interfaces = NULL;
  
  void JfrNetworkUtilization::destroy() {
<span class="line-new-header">--- 37,11 ---</span>
  struct InterfaceEntry {
    char* name;
    traceid id;
    uint64_t bytes_in;
    uint64_t bytes_out;
<span class="line-modified">!   mutable bool written;</span>
  };
  
  static GrowableArray&lt;InterfaceEntry&gt;* _interfaces = NULL;
  
  void JfrNetworkUtilization::destroy() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 69,11 ***</span>
    entry.name = NEW_C_HEAP_ARRAY(char, length + 1, mtInternal);
    strncpy(entry.name, name, length + 1);
    entry.id = ++interface_id;
    entry.bytes_in = iface-&gt;get_bytes_in();
    entry.bytes_out = iface-&gt;get_bytes_out();
<span class="line-modified">!   entry.in_use = false;</span>
    return _interfaces-&gt;at(_interfaces-&gt;append(entry));
  }
  
  static GrowableArray&lt;InterfaceEntry&gt;* get_interfaces() {
    if (_interfaces == NULL) {
<span class="line-new-header">--- 69,11 ---</span>
    entry.name = NEW_C_HEAP_ARRAY(char, length + 1, mtInternal);
    strncpy(entry.name, name, length + 1);
    entry.id = ++interface_id;
    entry.bytes_in = iface-&gt;get_bytes_in();
    entry.bytes_out = iface-&gt;get_bytes_out();
<span class="line-modified">!   entry.written = false;</span>
    return _interfaces-&gt;at(_interfaces-&gt;append(entry));
  }
  
  static GrowableArray&lt;InterfaceEntry&gt;* get_interfaces() {
    if (_interfaces == NULL) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 106,50 ***</span>
      return 0;
    }
    return ((current - old) * NANOSECS_PER_SEC) / interval.nanoseconds();
  }
  
<span class="line-removed">- static bool get_interfaces(NetworkInterface** network_interfaces) {</span>
<span class="line-removed">-   const int ret_val = JfrOSInterface::network_utilization(network_interfaces);</span>
<span class="line-removed">-   if (ret_val == OS_ERR) {</span>
<span class="line-removed">-     log_debug(jfr, system)(&quot;Unable to generate network utilization events&quot;);</span>
<span class="line-removed">-     return false;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return ret_val != FUNCTIONALITY_NOT_IMPLEMENTED;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  class JfrNetworkInterfaceName : public JfrSerializer {
   public:
<span class="line-modified">!   void serialize(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-modified">!     assert(_interfaces != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!     const JfrCheckpointContext ctx = writer.context();</span>
<span class="line-modified">!     const intptr_t count_offset = writer.reserve(sizeof(u4)); // Don&#39;t know how many yet</span>
<span class="line-modified">!     int active_interfaces = 0;</span>
<span class="line-modified">!     for (int i = 0; i &lt; _interfaces-&gt;length(); ++i) {</span>
<span class="line-modified">!       InterfaceEntry&amp; entry = _interfaces-&gt;at(i);</span>
<span class="line-modified">!       if (entry.in_use) {</span>
<span class="line-modified">!         entry.in_use = false;</span>
<span class="line-modified">!         writer.write_key(entry.id);</span>
<span class="line-removed">-         writer.write(entry.name);</span>
<span class="line-removed">-         ++active_interfaces;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (active_interfaces == 0) {</span>
<span class="line-removed">-       // nothing to write, restore context</span>
<span class="line-removed">-       writer.set_context(ctx);</span>
<span class="line-removed">-       return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     writer.write_count(active_interfaces, count_offset);</span>
<span class="line-removed">-   }</span>
  };
  
  static bool register_network_interface_name_serializer() {
    assert(_interfaces != NULL, &quot;invariant&quot;);
    return JfrSerializer::register_serializer(TYPE_NETWORKINTERFACENAME,
<span class="line-modified">!                                             false, // require safepoint</span>
<span class="line-modified">!                                             false, // disallow caching; we want a callback every rotation</span>
<span class="line-modified">!                                             new JfrNetworkInterfaceName());</span>
  }
  
  void JfrNetworkUtilization::send_events() {
    ResourceMark rm;
    NetworkInterface* network_interfaces;
<span class="line-new-header">--- 106,50 ---</span>
      return 0;
    }
    return ((current - old) * NANOSECS_PER_SEC) / interval.nanoseconds();
  }
  
  class JfrNetworkInterfaceName : public JfrSerializer {
   public:
<span class="line-modified">!    void serialize(JfrCheckpointWriter&amp; writer) {} // we write each constant lazily</span>
<span class="line-modified">! </span>
<span class="line-modified">!    void on_rotation() {</span>
<span class="line-modified">!      for (int i = 0; i &lt; _interfaces-&gt;length(); ++i) {</span>
<span class="line-modified">!        const InterfaceEntry&amp; entry = _interfaces-&gt;at(i);</span>
<span class="line-modified">!        if (entry.written) {</span>
<span class="line-modified">!          entry.written = false;</span>
<span class="line-modified">!        }</span>
<span class="line-modified">!      }</span>
<span class="line-modified">!    }</span>
  };
  
  static bool register_network_interface_name_serializer() {
    assert(_interfaces != NULL, &quot;invariant&quot;);
    return JfrSerializer::register_serializer(TYPE_NETWORKINTERFACENAME,
<span class="line-modified">!     false, // disallow caching; we want a callback every rotation</span>
<span class="line-modified">!     new JfrNetworkInterfaceName());</span>
<span class="line-modified">! }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void write_interface_constant(const InterfaceEntry&amp; entry) {</span>
<span class="line-added">+   if (entry.written) {</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   JfrCheckpointWriter writer;</span>
<span class="line-added">+   writer.write_type(TYPE_NETWORKINTERFACENAME);</span>
<span class="line-added">+   writer.write_count(1);</span>
<span class="line-added">+   writer.write_key(entry.id);</span>
<span class="line-added">+   writer.write(entry.name);</span>
<span class="line-added">+   entry.written = true;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static bool get_interfaces(NetworkInterface** network_interfaces) {</span>
<span class="line-added">+   const int ret_val = JfrOSInterface::network_utilization(network_interfaces);</span>
<span class="line-added">+   if (ret_val == OS_ERR) {</span>
<span class="line-added">+     log_debug(jfr, system)(&quot;Unable to generate network utilization events&quot;);</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return ret_val != FUNCTIONALITY_NOT_IMPLEMENTED;</span>
  }
  
  void JfrNetworkUtilization::send_events() {
    ResourceMark rm;
    NetworkInterface* network_interfaces;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 167,11 ***</span>
        const uint64_t current_bytes_in = cur-&gt;get_bytes_in();
        const uint64_t current_bytes_out = cur-&gt;get_bytes_out();
        const uint64_t read_rate = rate_per_second(current_bytes_in, entry.bytes_in, interval);
        const uint64_t write_rate = rate_per_second(current_bytes_out, entry.bytes_out, interval);
        if (read_rate &gt; 0 || write_rate &gt; 0) {
<span class="line-modified">!         entry.in_use = true;</span>
          EventNetworkUtilization event(UNTIMED);
          event.set_starttime(cur_time);
          event.set_endtime(cur_time);
          event.set_networkInterface(entry.id);
          event.set_readRate(8 * read_rate);
<span class="line-new-header">--- 167,11 ---</span>
        const uint64_t current_bytes_in = cur-&gt;get_bytes_in();
        const uint64_t current_bytes_out = cur-&gt;get_bytes_out();
        const uint64_t read_rate = rate_per_second(current_bytes_in, entry.bytes_in, interval);
        const uint64_t write_rate = rate_per_second(current_bytes_out, entry.bytes_out, interval);
        if (read_rate &gt; 0 || write_rate &gt; 0) {
<span class="line-modified">!         write_interface_constant(entry);</span>
          EventNetworkUtilization event(UNTIMED);
          event.set_starttime(cur_time);
          event.set_endtime(cur_time);
          event.set_networkInterface(entry.id);
          event.set_readRate(8 * read_rate);
</pre>
<center><a href="../metadata/metadata.xsd.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jfrOSInterface.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jfr/periodic/jfrPeriodic.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
 27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
 28 #include &quot;classfile/classLoaderStats.hpp&quot;
 29 #include &quot;classfile/javaClasses.hpp&quot;
<a name="2" id="anc2"></a>


 30 #include &quot;code/codeCache.hpp&quot;
 31 #include &quot;compiler/compileBroker.hpp&quot;
<a name="3" id="anc3"></a><span class="line-removed"> 32 #include &quot;gc/g1/g1HeapRegionEventSender.hpp&quot;</span>
 33 #include &quot;gc/shared/gcConfiguration.hpp&quot;
 34 #include &quot;gc/shared/gcTrace.hpp&quot;
 35 #include &quot;gc/shared/gcVMOperations.hpp&quot;
 36 #include &quot;gc/shared/objectCountEventSender.hpp&quot;
 37 #include &quot;jfr/jfrEvents.hpp&quot;
 38 #include &quot;jfr/periodic/jfrModuleEvent.hpp&quot;
 39 #include &quot;jfr/periodic/jfrOSInterface.hpp&quot;
 40 #include &quot;jfr/periodic/jfrThreadCPULoadEvent.hpp&quot;
 41 #include &quot;jfr/periodic/jfrThreadDumpEvent.hpp&quot;
 42 #include &quot;jfr/periodic/jfrNetworkUtilization.hpp&quot;
 43 #include &quot;jfr/recorder/jfrRecorder.hpp&quot;
 44 #include &quot;jfr/support/jfrThreadId.hpp&quot;
<a name="4" id="anc4"></a>
 45 #include &quot;jfr/utilities/jfrTime.hpp&quot;
 46 #include &quot;jfrfiles/jfrPeriodic.hpp&quot;
 47 #include &quot;logging/log.hpp&quot;
 48 #include &quot;memory/heapInspection.hpp&quot;
 49 #include &quot;memory/resourceArea.hpp&quot;
 50 #include &quot;oops/oop.inline.hpp&quot;
 51 #include &quot;runtime/arguments.hpp&quot;
 52 #include &quot;runtime/flags/jvmFlag.hpp&quot;
 53 #include &quot;runtime/globals.hpp&quot;
 54 #include &quot;runtime/os.hpp&quot;
 55 #include &quot;runtime/os_perf.hpp&quot;
 56 #include &quot;runtime/thread.inline.hpp&quot;
<a name="5" id="anc5"></a><span class="line-removed"> 57 #include &quot;runtime/threadSMR.hpp&quot;</span>
 58 #include &quot;runtime/sweeper.hpp&quot;
 59 #include &quot;runtime/vmThread.hpp&quot;
 60 #include &quot;services/classLoadingService.hpp&quot;
 61 #include &quot;services/management.hpp&quot;
 62 #include &quot;services/threadService.hpp&quot;
 63 #include &quot;utilities/exceptions.hpp&quot;
 64 #include &quot;utilities/globalDefinitions.hpp&quot;
<a name="6" id="anc6"></a><span class="line-modified"> 65 </span>





 66 /**
 67  *  JfrPeriodic class
 68  *  Implementation of declarations in
 69  *  xsl generated traceRequestables.hpp
 70  */
 71 #define TRACE_REQUEST_FUNC(id)    void JfrPeriodicEventSet::request##id(void)
 72 
 73 TRACE_REQUEST_FUNC(JVMInformation) {
 74   ResourceMark rm;
 75   EventJVMInformation event;
 76   event.set_jvmName(VM_Version::vm_name());
 77   event.set_jvmVersion(VM_Version::internal_vm_info_string());
 78   event.set_javaArguments(Arguments::java_command());
 79   event.set_jvmArguments(Arguments::jvm_args());
 80   event.set_jvmFlags(Arguments::jvm_flags());
 81   event.set_jvmStartTime(Management::vm_init_done_time());
 82   event.set_pid(os::current_process_id());
 83   event.commit();
 84  }
 85 
 86 TRACE_REQUEST_FUNC(OSInformation) {
 87   ResourceMark rm;
 88   char* os_name = NEW_RESOURCE_ARRAY(char, 2048);
 89   JfrOSInterface::os_version(&amp;os_name);
 90   EventOSInformation event;
 91   event.set_osVersion(os_name);
 92   event.commit();
 93 }
 94 
<a name="7" id="anc7"></a>





 95 TRACE_REQUEST_FUNC(ModuleRequire) {
 96   JfrModuleEvent::generate_module_dependency_events();
 97 }
 98 
 99 TRACE_REQUEST_FUNC(ModuleExport) {
100   JfrModuleEvent::generate_module_export_events();
101 }
102 
103 /*
104  * This is left empty on purpose, having ExecutionSample as a requestable
105  * is a way of getting the period. The period is passed to ThreadSampling::update_period.
106  * Implementation in jfrSamples.cpp
107  */
108 TRACE_REQUEST_FUNC(ExecutionSample) {
109 }
110 TRACE_REQUEST_FUNC(NativeMethodSample) {
111 }
112 
113 TRACE_REQUEST_FUNC(ThreadDump) {
114   ResourceMark rm;
115   EventThreadDump event;
116   event.set_result(JfrDcmdEvent::thread_dump());
117   event.commit();
118 }
119 
120 static int _native_library_callback(const char* name, address base, address top, void *param) {
121   EventNativeLibrary event(UNTIMED);
122   event.set_name(name);
123   event.set_baseAddress((u8)base);
124   event.set_topAddress((u8)top);
125   event.set_endtime(*(JfrTicks*) param);
126   event.commit();
127   return 0;
128 }
129 
130 TRACE_REQUEST_FUNC(NativeLibrary) {
131   JfrTicks ts= JfrTicks::now();
132   os::get_loaded_modules_info(&amp;_native_library_callback, (void *)&amp;ts);
133 }
134 
135 TRACE_REQUEST_FUNC(InitialEnvironmentVariable) {
136   JfrOSInterface::generate_initial_environment_variable_events();
137 }
138 
139 TRACE_REQUEST_FUNC(CPUInformation) {
140   CPUInformation cpu_info;
141   int ret_val = JfrOSInterface::cpu_information(cpu_info);
142   if (ret_val == OS_ERR) {
143     log_debug(jfr, system)( &quot;Unable to generate requestable event CPUInformation&quot;);
144     return;
145   }
146   if (ret_val == FUNCTIONALITY_NOT_IMPLEMENTED) {
147      return;
148   }
149   if (ret_val == OS_OK) {
150     EventCPUInformation event;
151     event.set_cpu(cpu_info.cpu_name());
152     event.set_description(cpu_info.cpu_description());
153     event.set_sockets(cpu_info.number_of_sockets());
154     event.set_cores(cpu_info.number_of_cores());
155     event.set_hwThreads(cpu_info.number_of_hardware_threads());
156     event.commit();
157   }
158 }
159 
160 TRACE_REQUEST_FUNC(CPULoad) {
161   double u = 0; // user time
162   double s = 0; // kernel time
163   double t = 0; // total time
164   int ret_val = JfrOSInterface::cpu_loads_process(&amp;u, &amp;s, &amp;t);
165   if (ret_val == OS_ERR) {
166     log_debug(jfr, system)( &quot;Unable to generate requestable event CPULoad&quot;);
167     return;
168   }
169   if (ret_val == OS_OK) {
170     EventCPULoad event;
171     event.set_jvmUser((float)u);
172     event.set_jvmSystem((float)s);
173     event.set_machineTotal((float)t);
174     event.commit();
175   }
176 }
177 
178 TRACE_REQUEST_FUNC(ThreadCPULoad) {
179   JfrThreadCPULoadEvent::send_events();
180 }
181 
182 TRACE_REQUEST_FUNC(NetworkUtilization) {
183   JfrNetworkUtilization::send_events();
184 }
185 
186 TRACE_REQUEST_FUNC(CPUTimeStampCounter) {
187   EventCPUTimeStampCounter event;
188   event.set_fastTimeEnabled(JfrTime::is_ft_enabled());
189   event.set_fastTimeAutoEnabled(JfrTime::is_ft_supported());
190   event.set_osFrequency(os::elapsed_frequency());
191   event.set_fastTimeFrequency(JfrTime::frequency());
192   event.commit();
193 }
194 
195 TRACE_REQUEST_FUNC(SystemProcess) {
196   char pid_buf[16];
197   SystemProcess* processes = NULL;
198   int num_of_processes = 0;
199   JfrTicks start_time = JfrTicks::now();
200   int ret_val = JfrOSInterface::system_processes(&amp;processes, &amp;num_of_processes);
201   if (ret_val == OS_ERR) {
202     log_debug(jfr, system)( &quot;Unable to generate requestable event SystemProcesses&quot;);
203     return;
204   }
205   JfrTicks end_time = JfrTicks::now();
206   if (ret_val == FUNCTIONALITY_NOT_IMPLEMENTED) {
207     return;
208   }
209   if (ret_val == OS_OK) {
210     // feature is implemented, write real event
211     while (processes != NULL) {
212       SystemProcess* tmp = processes;
213       const char* info = processes-&gt;command_line();
214       if (info == NULL) {
215          info = processes-&gt;path();
216       }
217       if (info == NULL) {
218          info = processes-&gt;name();
219       }
220       if (info == NULL) {
221          info = &quot;?&quot;;
222       }
223       jio_snprintf(pid_buf, sizeof(pid_buf), &quot;%d&quot;, processes-&gt;pid());
224       EventSystemProcess event(UNTIMED);
225       event.set_pid(pid_buf);
226       event.set_commandLine(info);
227       event.set_starttime(start_time);
228       event.set_endtime(end_time);
229       event.commit();
230       processes = processes-&gt;next();
231       delete tmp;
232     }
233   }
234 }
235 
236 TRACE_REQUEST_FUNC(ThreadContextSwitchRate) {
237   double rate = 0.0;
238   int ret_val = JfrOSInterface::context_switch_rate(&amp;rate);
239   if (ret_val == OS_ERR) {
240     log_debug(jfr, system)( &quot;Unable to generate requestable event ThreadContextSwitchRate&quot;);
241     return;
242   }
243   if (ret_val == FUNCTIONALITY_NOT_IMPLEMENTED) {
244     return;
245   }
246   if (ret_val == OS_OK) {
247     EventThreadContextSwitchRate event;
248     event.set_switchRate((float)rate + 0.0f);
249     event.commit();
250   }
251 }
252 
253 #define SEND_FLAGS_OF_TYPE(eventType, flagType)                   \
254   do {                                                            \
255     JVMFlag *flag = JVMFlag::flags;                               \
256     while (flag-&gt;_name != NULL) {                                 \
257       if (flag-&gt;is_ ## flagType()) {                              \
258         if (flag-&gt;is_unlocked()) {                                \
259           Event ## eventType event;                               \
260           event.set_name(flag-&gt;_name);                            \
261           event.set_value(flag-&gt;get_ ## flagType());              \
262           event.set_origin(flag-&gt;get_origin());                   \
263           event.commit();                                         \
264         }                                                         \
265       }                                                           \
266       ++flag;                                                     \
267     }                                                             \
268   } while (0)
269 
270 TRACE_REQUEST_FUNC(IntFlag) {
271   SEND_FLAGS_OF_TYPE(IntFlag, int);
272 }
273 
274 TRACE_REQUEST_FUNC(UnsignedIntFlag) {
275   SEND_FLAGS_OF_TYPE(UnsignedIntFlag, uint);
276 }
277 
278 TRACE_REQUEST_FUNC(LongFlag) {
279   SEND_FLAGS_OF_TYPE(LongFlag, intx);
280 }
281 
282 TRACE_REQUEST_FUNC(UnsignedLongFlag) {
283   SEND_FLAGS_OF_TYPE(UnsignedLongFlag, uintx);
284   SEND_FLAGS_OF_TYPE(UnsignedLongFlag, uint64_t);
285   SEND_FLAGS_OF_TYPE(UnsignedLongFlag, size_t);
286 }
287 
288 TRACE_REQUEST_FUNC(DoubleFlag) {
289   SEND_FLAGS_OF_TYPE(DoubleFlag, double);
290 }
291 
292 TRACE_REQUEST_FUNC(BooleanFlag) {
293   SEND_FLAGS_OF_TYPE(BooleanFlag, bool);
294 }
295 
296 TRACE_REQUEST_FUNC(StringFlag) {
297   SEND_FLAGS_OF_TYPE(StringFlag, ccstr);
298 }
299 
300 class VM_GC_SendObjectCountEvent : public VM_GC_HeapInspection {
301  public:
302   VM_GC_SendObjectCountEvent() : VM_GC_HeapInspection(NULL, true) {}
303   virtual void doit() {
304     ObjectCountEventSender::enable_requestable_event();
305     collect();
306     ObjectCountEventSender::disable_requestable_event();
307   }
308 };
309 
310 TRACE_REQUEST_FUNC(ObjectCount) {
311   VM_GC_SendObjectCountEvent op;
312   VMThread::execute(&amp;op);
313 }
314 
<a name="8" id="anc8"></a><span class="line-removed">315 class VM_G1SendHeapRegionInfoEvents : public VM_Operation {</span>
<span class="line-removed">316   virtual void doit() {</span>
<span class="line-removed">317     G1HeapRegionEventSender::send_events();</span>
<span class="line-removed">318   }</span>
<span class="line-removed">319   virtual VMOp_Type type() const { return VMOp_HeapIterateOperation; }</span>
<span class="line-removed">320 };</span>
<span class="line-removed">321 </span>
322 TRACE_REQUEST_FUNC(G1HeapRegionInformation) {
<a name="9" id="anc9"></a><span class="line-modified">323   if (UseG1GC) {</span>
<span class="line-removed">324     VM_G1SendHeapRegionInfoEvents op;</span>
<span class="line-removed">325     VMThread::execute(&amp;op);</span>
<span class="line-removed">326   }</span>
327 }
328 
329 // Java Mission Control (JMC) uses (Java) Long.MIN_VALUE to describe that a
330 // long value is undefined.
331 static jlong jmc_undefined_long = min_jlong;
332 
333 TRACE_REQUEST_FUNC(GCConfiguration) {
334   GCConfiguration conf;
335   jlong pause_target = conf.has_pause_target_default_value() ? jmc_undefined_long : conf.pause_target();
336   EventGCConfiguration event;
337   event.set_youngCollector(conf.young_collector());
338   event.set_oldCollector(conf.old_collector());
339   event.set_parallelGCThreads(conf.num_parallel_gc_threads());
340   event.set_concurrentGCThreads(conf.num_concurrent_gc_threads());
341   event.set_usesDynamicGCThreads(conf.uses_dynamic_gc_threads());
342   event.set_isExplicitGCConcurrent(conf.is_explicit_gc_concurrent());
343   event.set_isExplicitGCDisabled(conf.is_explicit_gc_disabled());
344   event.set_gcTimeRatio(conf.gc_time_ratio());
345   event.set_pauseTarget((s8)pause_target);
346   event.commit();
347 }
348 
349 TRACE_REQUEST_FUNC(GCTLABConfiguration) {
350   GCTLABConfiguration conf;
351   EventGCTLABConfiguration event;
352   event.set_usesTLABs(conf.uses_tlabs());
353   event.set_minTLABSize(conf.min_tlab_size());
354   event.set_tlabRefillWasteLimit(conf.tlab_refill_waste_limit());
355   event.commit();
356 }
357 
358 TRACE_REQUEST_FUNC(GCSurvivorConfiguration) {
359   GCSurvivorConfiguration conf;
360   EventGCSurvivorConfiguration event;
361   event.set_maxTenuringThreshold(conf.max_tenuring_threshold());
362   event.set_initialTenuringThreshold(conf.initial_tenuring_threshold());
363   event.commit();
364 }
365 
366 TRACE_REQUEST_FUNC(GCHeapConfiguration) {
367   GCHeapConfiguration conf;
368   EventGCHeapConfiguration event;
369   event.set_minSize(conf.min_size());
370   event.set_maxSize(conf.max_size());
371   event.set_initialSize(conf.initial_size());
372   event.set_usesCompressedOops(conf.uses_compressed_oops());
373   event.set_compressedOopsMode(conf.narrow_oop_mode());
374   event.set_objectAlignment(conf.object_alignment_in_bytes());
375   event.set_heapAddressBits(conf.heap_address_size_in_bits());
376   event.commit();
377 }
378 
379 TRACE_REQUEST_FUNC(YoungGenerationConfiguration) {
380   GCYoungGenerationConfiguration conf;
381   jlong max_size = conf.has_max_size_default_value() ? jmc_undefined_long : conf.max_size();
382   EventYoungGenerationConfiguration event;
383   event.set_maxSize((u8)max_size);
384   event.set_minSize(conf.min_size());
385   event.set_newRatio(conf.new_ratio());
386   event.commit();
387 }
388 
389 TRACE_REQUEST_FUNC(InitialSystemProperty) {
390   SystemProperty* p = Arguments::system_properties();
391   JfrTicks time_stamp = JfrTicks::now();
392   while (p !=  NULL) {
393     if (!p-&gt;internal()) {
394       EventInitialSystemProperty event(UNTIMED);
395       event.set_key(p-&gt;key());
396       event.set_value(p-&gt;value());
397       event.set_endtime(time_stamp);
398       event.commit();
399     }
400     p = p-&gt;next();
401   }
402 }
403 
404 TRACE_REQUEST_FUNC(ThreadAllocationStatistics) {
405   ResourceMark rm;
406   int initial_size = Threads::number_of_threads();
407   GrowableArray&lt;jlong&gt; allocated(initial_size);
408   GrowableArray&lt;traceid&gt; thread_ids(initial_size);
409   JfrTicks time_stamp = JfrTicks::now();
<a name="10" id="anc10"></a><span class="line-modified">410   {</span>
<span class="line-modified">411     // Collect allocation statistics while holding threads lock</span>
<span class="line-modified">412     MutexLockerEx ml(Threads_lock);</span>
<span class="line-modified">413     for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {</span>
<span class="line-modified">414       allocated.append(jt-&gt;cooked_allocated_bytes());</span>
<span class="line-modified">415       thread_ids.append(JFR_THREAD_ID(jt));</span>
<span class="line-removed">416     }</span>
417   }
418 
419   // Write allocation statistics to buffer.
420   for(int i = 0; i &lt; thread_ids.length(); i++) {
421     EventThreadAllocationStatistics event(UNTIMED);
422     event.set_allocated(allocated.at(i));
423     event.set_thread(thread_ids.at(i));
424     event.set_endtime(time_stamp);
425     event.commit();
426   }
427 }
428 
429 /**
430  *  PhysicalMemory event represents:
431  *
432  *  @totalSize == The amount of physical memory (hw) installed and reported by the OS, in bytes.
433  *  @usedSize  == The amount of physical memory currently in use in the system (reserved/committed), in bytes.
434  *
435  *  Both fields are systemwide, i.e. represents the entire OS/HW environment.
436  *  These fields do not include virtual memory.
437  *
438  *  If running inside a guest OS on top of a hypervisor in a virtualized environment,
439  *  the total memory reported is the amount of memory configured for the guest OS by the hypervisor.
440  */
441 TRACE_REQUEST_FUNC(PhysicalMemory) {
442   u8 totalPhysicalMemory = os::physical_memory();
443   EventPhysicalMemory event;
444   event.set_totalSize(totalPhysicalMemory);
445   event.set_usedSize(totalPhysicalMemory - os::available_memory());
446   event.commit();
447 }
448 
449 TRACE_REQUEST_FUNC(JavaThreadStatistics) {
450   EventJavaThreadStatistics event;
451   event.set_activeCount(ThreadService::get_live_thread_count());
452   event.set_daemonCount(ThreadService::get_daemon_thread_count());
453   event.set_accumulatedCount(ThreadService::get_total_thread_count());
454   event.set_peakCount(ThreadService::get_peak_thread_count());
455   event.commit();
456 }
457 
458 TRACE_REQUEST_FUNC(ClassLoadingStatistics) {
459   EventClassLoadingStatistics event;
460   event.set_loadedClassCount(ClassLoadingService::loaded_class_count());
461   event.set_unloadedClassCount(ClassLoadingService::unloaded_class_count());
462   event.commit();
463 }
464 
465 class JfrClassLoaderStatsClosure : public ClassLoaderStatsClosure {
466 public:
467   JfrClassLoaderStatsClosure() : ClassLoaderStatsClosure(NULL) {}
468 
469   bool do_entry(oop const&amp; key, ClassLoaderStats* const&amp; cls) {
470     const ClassLoaderData* this_cld = cls-&gt;_class_loader != NULL ?
471       java_lang_ClassLoader::loader_data_acquire(cls-&gt;_class_loader) : NULL;
472     const ClassLoaderData* parent_cld = cls-&gt;_parent != NULL ?
473       java_lang_ClassLoader::loader_data_acquire(cls-&gt;_parent) : NULL;
474     EventClassLoaderStatistics event;
475     event.set_classLoader(this_cld);
476     event.set_parentClassLoader(parent_cld);
477     event.set_classLoaderData((intptr_t)cls-&gt;_cld);
478     event.set_classCount(cls-&gt;_classes_count);
479     event.set_chunkSize(cls-&gt;_chunk_sz);
480     event.set_blockSize(cls-&gt;_block_sz);
481     event.set_unsafeAnonymousClassCount(cls-&gt;_anon_classes_count);
482     event.set_unsafeAnonymousChunkSize(cls-&gt;_anon_chunk_sz);
483     event.set_unsafeAnonymousBlockSize(cls-&gt;_anon_block_sz);
484     event.commit();
485     return true;
486   }
487 
488   void createEvents(void) {
489     _stats-&gt;iterate(this);
490   }
491 };
492 
493 class JfrClassLoaderStatsVMOperation : public ClassLoaderStatsVMOperation {
494  public:
495   JfrClassLoaderStatsVMOperation() : ClassLoaderStatsVMOperation(NULL) { }
496 
497   void doit() {
498     JfrClassLoaderStatsClosure clsc;
499     ClassLoaderDataGraph::loaded_cld_do(&amp;clsc);
500     clsc.createEvents();
501   }
502 };
503 
504 TRACE_REQUEST_FUNC(ClassLoaderStatistics) {
505   JfrClassLoaderStatsVMOperation op;
506   VMThread::execute(&amp;op);
507 }
508 
<a name="11" id="anc11"></a>







































509 TRACE_REQUEST_FUNC(CompilerStatistics) {
510   EventCompilerStatistics event;
511   event.set_compileCount(CompileBroker::get_total_compile_count());
512   event.set_bailoutCount(CompileBroker::get_total_bailout_count());
513   event.set_invalidatedCount(CompileBroker::get_total_invalidated_count());
514   event.set_osrCompileCount(CompileBroker::get_total_osr_compile_count());
515   event.set_standardCompileCount(CompileBroker::get_total_standard_compile_count());
516   event.set_osrBytesCompiled(CompileBroker::get_sum_osr_bytes_compiled());
517   event.set_standardBytesCompiled(CompileBroker::get_sum_standard_bytes_compiled());
<a name="12" id="anc12"></a><span class="line-modified">518   event.set_nmetodsSize(CompileBroker::get_sum_nmethod_size());</span>
<span class="line-modified">519   event.set_nmetodCodeSize(CompileBroker::get_sum_nmethod_code_size());</span>
520   event.set_peakTimeSpent(CompileBroker::get_peak_compilation_time());
521   event.set_totalTimeSpent(CompileBroker::get_total_compilation_time());
522   event.commit();
523 }
524 
525 TRACE_REQUEST_FUNC(CompilerConfiguration) {
526   EventCompilerConfiguration event;
527   event.set_threadCount(CICompilerCount);
528   event.set_tieredCompilation(TieredCompilation);
529   event.commit();
530 }
531 
532 TRACE_REQUEST_FUNC(CodeCacheStatistics) {
533   // Emit stats for all available code heaps
534   for (int bt = 0; bt &lt; CodeBlobType::NumTypes; ++bt) {
535     if (CodeCache::heap_available(bt)) {
536       EventCodeCacheStatistics event;
537       event.set_codeBlobType((u1)bt);
538       event.set_startAddress((u8)CodeCache::low_bound(bt));
539       event.set_reservedTopAddress((u8)CodeCache::high_bound(bt));
540       event.set_entryCount(CodeCache::blob_count(bt));
541       event.set_methodCount(CodeCache::nmethod_count(bt));
542       event.set_adaptorCount(CodeCache::adapter_count(bt));
543       event.set_unallocatedCapacity(CodeCache::unallocated_capacity(bt));
544       event.set_fullCount(CodeCache::get_codemem_full_count(bt));
545       event.commit();
546     }
547   }
548 }
549 
550 TRACE_REQUEST_FUNC(CodeCacheConfiguration) {
551   EventCodeCacheConfiguration event;
552   event.set_initialSize(InitialCodeCacheSize);
553   event.set_reservedSize(ReservedCodeCacheSize);
554   event.set_nonNMethodSize(NonNMethodCodeHeapSize);
555   event.set_profiledSize(ProfiledCodeHeapSize);
556   event.set_nonProfiledSize(NonProfiledCodeHeapSize);
557   event.set_expansionSize(CodeCacheExpansionSize);
558   event.set_minBlockLength(CodeCacheMinBlockLength);
559   event.set_startAddress((u8)CodeCache::low_bound());
560   event.set_reservedTopAddress((u8)CodeCache::high_bound());
561   event.commit();
562 }
563 
564 TRACE_REQUEST_FUNC(CodeSweeperStatistics) {
565   EventCodeSweeperStatistics event;
566   event.set_sweepCount(NMethodSweeper::traversal_count());
567   event.set_methodReclaimedCount(NMethodSweeper::total_nof_methods_reclaimed());
568   event.set_totalSweepTime(NMethodSweeper::total_time_sweeping());
569   event.set_peakFractionTime(NMethodSweeper::peak_sweep_fraction_time());
570   event.set_peakSweepTime(NMethodSweeper::peak_sweep_time());
571   event.commit();
572 }
573 
574 TRACE_REQUEST_FUNC(CodeSweeperConfiguration) {
575   EventCodeSweeperConfiguration event;
576   event.set_sweeperEnabled(MethodFlushing);
577   event.set_flushingEnabled(UseCodeCacheFlushing);
578   event.commit();
579 }
<a name="13" id="anc13"></a>










<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
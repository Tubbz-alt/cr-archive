diff a/src/hotspot/share/jfr/periodic/jfrPeriodic.cpp b/src/hotspot/share/jfr/periodic/jfrPeriodic.cpp
--- a/src/hotspot/share/jfr/periodic/jfrPeriodic.cpp
+++ b/src/hotspot/share/jfr/periodic/jfrPeriodic.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -25,13 +25,15 @@
 #include "precompiled.hpp"
 #include "jvm.h"
 #include "classfile/classLoaderDataGraph.hpp"
 #include "classfile/classLoaderStats.hpp"
 #include "classfile/javaClasses.hpp"
+#include "classfile/stringTable.hpp"
+#include "classfile/symbolTable.hpp"
+#include "classfile/systemDictionary.hpp"
 #include "code/codeCache.hpp"
 #include "compiler/compileBroker.hpp"
-#include "gc/g1/g1HeapRegionEventSender.hpp"
 #include "gc/shared/gcConfiguration.hpp"
 #include "gc/shared/gcTrace.hpp"
 #include "gc/shared/gcVMOperations.hpp"
 #include "gc/shared/objectCountEventSender.hpp"
 #include "jfr/jfrEvents.hpp"
@@ -40,10 +42,11 @@
 #include "jfr/periodic/jfrThreadCPULoadEvent.hpp"
 #include "jfr/periodic/jfrThreadDumpEvent.hpp"
 #include "jfr/periodic/jfrNetworkUtilization.hpp"
 #include "jfr/recorder/jfrRecorder.hpp"
 #include "jfr/support/jfrThreadId.hpp"
+#include "jfr/utilities/jfrThreadIterator.hpp"
 #include "jfr/utilities/jfrTime.hpp"
 #include "jfrfiles/jfrPeriodic.hpp"
 #include "logging/log.hpp"
 #include "memory/heapInspection.hpp"
 #include "memory/resourceArea.hpp"
@@ -52,19 +55,23 @@
 #include "runtime/flags/jvmFlag.hpp"
 #include "runtime/globals.hpp"
 #include "runtime/os.hpp"
 #include "runtime/os_perf.hpp"
 #include "runtime/thread.inline.hpp"
-#include "runtime/threadSMR.hpp"
 #include "runtime/sweeper.hpp"
 #include "runtime/vmThread.hpp"
 #include "services/classLoadingService.hpp"
 #include "services/management.hpp"
 #include "services/threadService.hpp"
 #include "utilities/exceptions.hpp"
 #include "utilities/globalDefinitions.hpp"
-
+#if INCLUDE_G1GC
+#include "gc/g1/g1HeapRegionEventSender.hpp"
+#endif
+#if INCLUDE_SHENANDOAHGC
+#include "gc/shenandoah/shenandoahJfrSupport.hpp"
+#endif
 /**
  *  JfrPeriodic class
  *  Implementation of declarations in
  *  xsl generated traceRequestables.hpp
  */
@@ -90,10 +97,16 @@
   EventOSInformation event;
   event.set_osVersion(os_name);
   event.commit();
 }
 
+TRACE_REQUEST_FUNC(VirtualizationInformation) {
+  EventVirtualizationInformation event;
+  event.set_name(JfrOSInterface::virtualization_name());
+  event.commit();
+}
+
 TRACE_REQUEST_FUNC(ModuleRequire) {
   JfrModuleEvent::generate_module_dependency_events();
 }
 
 TRACE_REQUEST_FUNC(ModuleExport) {
@@ -310,22 +323,12 @@
 TRACE_REQUEST_FUNC(ObjectCount) {
   VM_GC_SendObjectCountEvent op;
   VMThread::execute(&op);
 }
 
-class VM_G1SendHeapRegionInfoEvents : public VM_Operation {
-  virtual void doit() {
-    G1HeapRegionEventSender::send_events();
-  }
-  virtual VMOp_Type type() const { return VMOp_HeapIterateOperation; }
-};
-
 TRACE_REQUEST_FUNC(G1HeapRegionInformation) {
-  if (UseG1GC) {
-    VM_G1SendHeapRegionInfoEvents op;
-    VMThread::execute(&op);
-  }
+  G1GC_ONLY(G1HeapRegionEventSender::send_events());
 }
 
 // Java Mission Control (JMC) uses (Java) Long.MIN_VALUE to describe that a
 // long value is undefined.
 static jlong jmc_undefined_long = min_jlong;
@@ -405,17 +408,16 @@
   ResourceMark rm;
   int initial_size = Threads::number_of_threads();
   GrowableArray<jlong> allocated(initial_size);
   GrowableArray<traceid> thread_ids(initial_size);
   JfrTicks time_stamp = JfrTicks::now();
-  {
-    // Collect allocation statistics while holding threads lock
-    MutexLockerEx ml(Threads_lock);
-    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {
-      allocated.append(jt->cooked_allocated_bytes());
-      thread_ids.append(JFR_THREAD_ID(jt));
-    }
+  JfrJavaThreadIterator iter;
+  while (iter.has_next()) {
+    JavaThread* const jt = iter.next();
+    assert(jt != NULL, "invariant");
+    allocated.append(jt->cooked_allocated_bytes());
+    thread_ids.append(JFR_THREAD_ID(jt));
   }
 
   // Write allocation statistics to buffer.
   for(int i = 0; i < thread_ids.length(); i++) {
     EventThreadAllocationStatistics event(UNTIMED);
@@ -504,21 +506,61 @@
 TRACE_REQUEST_FUNC(ClassLoaderStatistics) {
   JfrClassLoaderStatsVMOperation op;
   VMThread::execute(&op);
 }
 
+template<typename EVENT>
+static void emit_table_statistics(TableStatistics statistics) {
+  EVENT event;
+  event.set_bucketCount(statistics._number_of_buckets);
+  event.set_entryCount(statistics._number_of_entries);
+  event.set_totalFootprint(statistics._total_footprint);
+  event.set_bucketCountMaximum(statistics._maximum_bucket_size);
+  event.set_bucketCountAverage(statistics._average_bucket_size);
+  event.set_bucketCountVariance(statistics._variance_of_bucket_size);
+  event.set_bucketCountStandardDeviation(statistics._stddev_of_bucket_size);
+  event.set_insertionRate(statistics._add_rate);
+  event.set_removalRate(statistics._remove_rate);
+  event.commit();
+}
+
+TRACE_REQUEST_FUNC(SymbolTableStatistics) {
+  TableStatistics statistics = SymbolTable::get_table_statistics();
+  emit_table_statistics<EventSymbolTableStatistics>(statistics);
+}
+
+TRACE_REQUEST_FUNC(StringTableStatistics) {
+  TableStatistics statistics = StringTable::get_table_statistics();
+  emit_table_statistics<EventStringTableStatistics>(statistics);
+}
+
+TRACE_REQUEST_FUNC(PlaceholderTableStatistics) {
+  TableStatistics statistics = SystemDictionary::placeholders_statistics();
+  emit_table_statistics<EventPlaceholderTableStatistics>(statistics);
+}
+
+TRACE_REQUEST_FUNC(LoaderConstraintsTableStatistics) {
+  TableStatistics statistics = SystemDictionary::loader_constraints_statistics();
+  emit_table_statistics<EventLoaderConstraintsTableStatistics>(statistics);
+}
+
+TRACE_REQUEST_FUNC(ProtectionDomainCacheTableStatistics) {
+  TableStatistics statistics = SystemDictionary::protection_domain_cache_statistics();
+  emit_table_statistics<EventProtectionDomainCacheTableStatistics>(statistics);
+}
+
 TRACE_REQUEST_FUNC(CompilerStatistics) {
   EventCompilerStatistics event;
   event.set_compileCount(CompileBroker::get_total_compile_count());
   event.set_bailoutCount(CompileBroker::get_total_bailout_count());
   event.set_invalidatedCount(CompileBroker::get_total_invalidated_count());
   event.set_osrCompileCount(CompileBroker::get_total_osr_compile_count());
   event.set_standardCompileCount(CompileBroker::get_total_standard_compile_count());
   event.set_osrBytesCompiled(CompileBroker::get_sum_osr_bytes_compiled());
   event.set_standardBytesCompiled(CompileBroker::get_sum_standard_bytes_compiled());
-  event.set_nmetodsSize(CompileBroker::get_sum_nmethod_size());
-  event.set_nmetodCodeSize(CompileBroker::get_sum_nmethod_code_size());
+  event.set_nmethodsSize(CompileBroker::get_sum_nmethod_size());
+  event.set_nmethodCodeSize(CompileBroker::get_sum_nmethod_code_size());
   event.set_peakTimeSpent(CompileBroker::get_peak_compilation_time());
   event.set_totalTimeSpent(CompileBroker::get_total_compilation_time());
   event.commit();
 }
 
@@ -575,5 +617,16 @@
   EventCodeSweeperConfiguration event;
   event.set_sweeperEnabled(MethodFlushing);
   event.set_flushingEnabled(UseCodeCacheFlushing);
   event.commit();
 }
+
+
+TRACE_REQUEST_FUNC(ShenandoahHeapRegionInformation) {
+#if INCLUDE_SHENANDOAHGC
+  if (UseShenandoahGC) {
+    VM_ShenandoahSendHeapRegionInfoEvents op;
+    VMThread::execute(&op);
+  }
+#endif
+}
+

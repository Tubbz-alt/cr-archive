<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/periodic/sampling/jfrThreadSampler.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="jfrCallTrace.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../recorder/checkpoint/jfrCheckpointManager.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/periodic/sampling/jfrThreadSampler.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/jfrEvents.hpp&quot;
 27 #include &quot;jfr/recorder/jfrRecorder.hpp&quot;
 28 #include &quot;jfr/periodic/sampling/jfrCallTrace.hpp&quot;
 29 #include &quot;jfr/periodic/sampling/jfrThreadSampler.hpp&quot;
 30 #include &quot;jfr/recorder/service/jfrOptionSet.hpp&quot;
 31 #include &quot;jfr/recorder/stacktrace/jfrStackTraceRepository.hpp&quot;
 32 #include &quot;jfr/support/jfrThreadId.hpp&quot;

 33 #include &quot;jfr/utilities/jfrTime.hpp&quot;
 34 #include &quot;logging/log.hpp&quot;
 35 #include &quot;runtime/frame.inline.hpp&quot;
 36 #include &quot;runtime/os.hpp&quot;
 37 #include &quot;runtime/semaphore.hpp&quot;
 38 #include &quot;runtime/thread.inline.hpp&quot;
 39 #include &quot;runtime/threadSMR.hpp&quot;
 40 
 41 enum JfrSampleType {
 42   NO_SAMPLE = 0,
 43   JAVA_SAMPLE = 1,
 44   NATIVE_SAMPLE = 2
 45 };
 46 
 47 static bool thread_state_in_java(JavaThread* thread) {
 48   assert(thread != NULL, &quot;invariant&quot;);
 49   switch(thread-&gt;thread_state()) {
 50     case _thread_new:
 51     case _thread_uninitialized:
 52     case _thread_new_trans:
</pre>
<hr />
<pre>
330   void start_thread();
331 
332   void enroll();
333   void disenroll();
334   void set_java_interval(size_t interval) { _interval_java = interval; };
335   void set_native_interval(size_t interval) { _interval_native = interval; };
336   size_t get_java_interval() { return _interval_java; };
337   size_t get_native_interval() { return _interval_native; };
338  protected:
339   virtual void post_run();
340  public:
341   void run();
342   static Monitor* transition_block() { return JfrThreadSampler_lock; }
343   static void on_javathread_suspend(JavaThread* thread);
344 };
345 
346 static void clear_transition_block(JavaThread* jt) {
347   jt-&gt;clear_trace_flag();
348   JfrThreadLocal* const tl = jt-&gt;jfr_thread_local();
349   if (tl-&gt;is_trace_block()) {
<span class="line-modified">350     MutexLockerEx ml(JfrThreadSampler::transition_block(), Mutex::_no_safepoint_check_flag);</span>
351     JfrThreadSampler::transition_block()-&gt;notify_all();
352   }
353 }
354 





355 bool JfrThreadSampleClosure::do_sample_thread(JavaThread* thread, JfrStackFrame* frames, u4 max_frames, JfrSampleType type) {
356   assert(Threads_lock-&gt;owned_by_self(), &quot;Holding the thread table lock.&quot;);
<span class="line-modified">357   if (thread-&gt;is_hidden_from_external_view() || thread-&gt;in_deopt_handler()) {</span>
358     return false;
359   }
360 
361   bool ret = false;
<span class="line-modified">362   thread-&gt;set_trace_flag();</span>
363   if (JAVA_SAMPLE == type) {
364     if (thread_state_in_java(thread)) {
365       ret = sample_thread_in_java(thread, frames, max_frames);
366     }
367   } else {
368     assert(NATIVE_SAMPLE == type, &quot;invariant&quot;);
369     if (thread_state_in_native(thread)) {
370       ret = sample_thread_in_native(thread, frames, max_frames);
371     }
372   }
373   clear_transition_block(thread);
374   return ret;
375 }
376 
377 JfrThreadSampler::JfrThreadSampler(size_t interval_java, size_t interval_native, u4 max_frames) :
378   _sample(),
379   _sampler_thread(NULL),
380   _frames(JfrCHeapObj::new_array&lt;JfrStackFrame&gt;(max_frames)),
381   _last_thread_java(NULL),
382   _last_thread_native(NULL),
383   _interval_java(interval_java),
384   _interval_native(interval_native),
385   _cur_index(-1),
386   _max_frames(max_frames),
387   _disenrolled(true) {
388 }
389 
390 JfrThreadSampler::~JfrThreadSampler() {
391   JfrCHeapObj::free(_frames, sizeof(JfrStackFrame) * _max_frames);
392 }
393 
394 void JfrThreadSampler::on_javathread_suspend(JavaThread* thread) {
395   JfrThreadLocal* const tl = thread-&gt;jfr_thread_local();
396   tl-&gt;set_trace_block();
397   {
<span class="line-modified">398     MutexLockerEx ml(transition_block(), Mutex::_no_safepoint_check_flag);</span>
399     while (thread-&gt;is_trace_suspend()) {
<span class="line-modified">400       transition_block()-&gt;wait(true);</span>
401     }
402     tl-&gt;clear_trace_block();
403   }
404 }
405 
406 JavaThread* JfrThreadSampler::next_thread(ThreadsList* t_list, JavaThread* first_sampled, JavaThread* current) {
407   assert(t_list != NULL, &quot;invariant&quot;);
408   assert(Threads_lock-&gt;owned_by_self(), &quot;Holding the thread table lock.&quot;);
409   assert(_cur_index &gt;= -1 &amp;&amp; (uint)_cur_index + 1 &lt;= t_list-&gt;length(), &quot;invariant&quot;);
410   assert((current == NULL &amp;&amp; -1 == _cur_index) || (t_list-&gt;find_index_of_JavaThread(current) == _cur_index), &quot;invariant&quot;);
411   if ((uint)_cur_index + 1 == t_list-&gt;length()) {
412     // wrap
413     _cur_index = 0;
414   } else {
415     _cur_index++;
416   }
417   assert(_cur_index &gt;= 0 &amp;&amp; (uint)_cur_index &lt; t_list-&gt;length(), &quot;invariant&quot;);
418   JavaThread* const next = t_list-&gt;thread_at(_cur_index);
419   return next != first_sampled ? next : NULL;
420 }
421 
422 void JfrThreadSampler::start_thread() {
423   if (os::create_thread(this, os::os_thread)) {
424     os::start_thread(this);
425   } else {
426     log_error(jfr)(&quot;Failed to create thread for thread sampling&quot;);
427   }
428 }
429 
430 void JfrThreadSampler::enroll() {
431   if (_disenrolled) {
<span class="line-modified">432     log_info(jfr)(&quot;Enrolling thread sampler&quot;);</span>
433     _sample.signal();
434     _disenrolled = false;
435   }
436 }
437 
438 void JfrThreadSampler::disenroll() {
439   if (!_disenrolled) {
440     _sample.wait();
441     _disenrolled = true;
<span class="line-modified">442     log_info(jfr)(&quot;Disenrolling thread sampler&quot;);</span>
443   }
444 }
445 
446 static jlong get_monotonic_ms() {
447   return os::javaTimeNanos() / 1000000;
448 }
449 
450 void JfrThreadSampler::run() {
451   assert(_sampler_thread == NULL, &quot;invariant&quot;);
452 
453   _sampler_thread = this;
454 
455   jlong last_java_ms = get_monotonic_ms();
456   jlong last_native_ms = last_java_ms;
457   while (true) {
458     if (!_sample.trywait()) {
459       // disenrolled
460       _sample.wait();
461       last_java_ms = get_monotonic_ms();
462       last_native_ms = last_java_ms;
463     }
464     _sample.signal();
<span class="line-modified">465     jlong java_interval = _interval_java == 0 ? max_jlong : MAX2&lt;jlong&gt;(_interval_java, 10);</span>
<span class="line-modified">466     jlong native_interval = _interval_native == 0 ? max_jlong : MAX2&lt;jlong&gt;(_interval_native, 10);</span>
467 
468     jlong now_ms = get_monotonic_ms();
469 
470     /*
471      * Let I be java_interval or native_interval.
472      * Let L be last_java_ms or last_native_ms.
473      * Let N be now_ms.
474      *
475      * Interval, I, might be max_jlong so the addition
476      * could potentially overflow without parenthesis (UB). Also note that
477      * L - N &lt; 0. Avoid UB, by adding parenthesis.
478      */
479     jlong next_j = java_interval + (last_java_ms - now_ms);
480     jlong next_n = native_interval + (last_native_ms - now_ms);
481 
482     jlong sleep_to_next = MIN2&lt;jlong&gt;(next_j, next_n);
483 
484     if (sleep_to_next &gt; 0) {
485       os::naked_short_sleep(sleep_to_next);
486     }
</pre>
<hr />
<pre>
499 void JfrThreadSampler::post_run() {
500   this-&gt;NonJavaThread::post_run();
501   delete this;
502 }
503 
504 
505 void JfrThreadSampler::task_stacktrace(JfrSampleType type, JavaThread** last_thread) {
506   ResourceMark rm;
507   EventExecutionSample samples[MAX_NR_OF_JAVA_SAMPLES];
508   EventNativeMethodSample samples_native[MAX_NR_OF_NATIVE_SAMPLES];
509   JfrThreadSampleClosure sample_task(samples, samples_native);
510 
511   const uint sample_limit = JAVA_SAMPLE == type ? MAX_NR_OF_JAVA_SAMPLES : MAX_NR_OF_NATIVE_SAMPLES;
512   uint num_samples = 0;
513   JavaThread* start = NULL;
514 
515   {
516     elapsedTimer sample_time;
517     sample_time.start();
518     {
<span class="line-modified">519       MonitorLockerEx tlock(Threads_lock, Mutex::_allow_vm_block_flag);</span>
520       ThreadsListHandle tlh;
521       // Resolve a sample session relative start position index into the thread list array.
522       // In cases where the last sampled thread is NULL or not-NULL but stale, find_index() returns -1.
523       _cur_index = tlh.list()-&gt;find_index_of_JavaThread(*last_thread);
524       JavaThread* current = _cur_index != -1 ? *last_thread : NULL;
525 
526       while (num_samples &lt; sample_limit) {
527         current = next_thread(tlh.list(), start, current);
528         if (current == NULL) {
529           break;
530         }
531         if (start == NULL) {
532           start = current;  // remember the thread where we started to attempt sampling
533         }
534         if (current-&gt;is_Compiler_thread()) {
535           continue;
536         }
537         if (sample_task.do_sample_thread(current, _frames, _max_frames, type)) {
538           num_samples++;
539         }
</pre>
<hr />
<pre>
560   _instance = new JfrThreadSampling();
561   return _instance;
562 }
563 
564 void JfrThreadSampling::destroy() {
565   if (_instance != NULL) {
566     delete _instance;
567     _instance = NULL;
568   }
569 }
570 
571 JfrThreadSampling::JfrThreadSampling() : _sampler(NULL) {}
572 
573 JfrThreadSampling::~JfrThreadSampling() {
574   if (_sampler != NULL) {
575     _sampler-&gt;disenroll();
576   }
577 }
578 
579 static void log(size_t interval_java, size_t interval_native) {
<span class="line-modified">580   log_info(jfr)(&quot;Updated thread sampler for java: &quot; SIZE_FORMAT &quot;  ms, native &quot; SIZE_FORMAT &quot; ms&quot;, interval_java, interval_native);</span>
581 }
582 
583 void JfrThreadSampling::start_sampler(size_t interval_java, size_t interval_native) {
584   assert(_sampler == NULL, &quot;invariant&quot;);
<span class="line-modified">585   log_info(jfr)(&quot;Enrolling thread sampler&quot;);</span>
586   _sampler = new JfrThreadSampler(interval_java, interval_native, JfrOptionSet::stackdepth());
587   _sampler-&gt;start_thread();
588   _sampler-&gt;enroll();
589 }
590 
591 void JfrThreadSampling::set_sampling_interval(bool java_interval, size_t period) {
592   size_t interval_java = 0;
593   size_t interval_native = 0;
594   if (_sampler != NULL) {
595     interval_java = _sampler-&gt;get_java_interval();
596     interval_native = _sampler-&gt;get_native_interval();
597   }
598   if (java_interval) {
599     interval_java = period;
600   } else {
601     interval_native = period;
602   }
603   if (interval_java &gt; 0 || interval_native &gt; 0) {
604     if (_sampler == NULL) {
<span class="line-modified">605       log_info(jfr)(&quot;Creating thread sampler for java:%zu ms, native %zu ms&quot;, interval_java, interval_native);</span>
606       start_sampler(interval_java, interval_native);
607     } else {
608       _sampler-&gt;set_java_interval(interval_java);
609       _sampler-&gt;set_native_interval(interval_native);
610       _sampler-&gt;enroll();
611     }
612     assert(_sampler != NULL, &quot;invariant&quot;);
613     log(interval_java, interval_native);
614   } else if (_sampler != NULL) {
615     _sampler-&gt;disenroll();
616   }
617 }
618 
619 void JfrThreadSampling::set_java_sample_interval(size_t period) {
620   if (_instance == NULL &amp;&amp; 0 == period) {
621     return;
622   }
623   instance().set_sampling_interval(true, period);
624 }
625 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/jfrEvents.hpp&quot;
 27 #include &quot;jfr/recorder/jfrRecorder.hpp&quot;
 28 #include &quot;jfr/periodic/sampling/jfrCallTrace.hpp&quot;
 29 #include &quot;jfr/periodic/sampling/jfrThreadSampler.hpp&quot;
 30 #include &quot;jfr/recorder/service/jfrOptionSet.hpp&quot;
 31 #include &quot;jfr/recorder/stacktrace/jfrStackTraceRepository.hpp&quot;
 32 #include &quot;jfr/support/jfrThreadId.hpp&quot;
<span class="line-added"> 33 #include &quot;jfr/support/jfrThreadLocal.hpp&quot;</span>
 34 #include &quot;jfr/utilities/jfrTime.hpp&quot;
 35 #include &quot;logging/log.hpp&quot;
 36 #include &quot;runtime/frame.inline.hpp&quot;
 37 #include &quot;runtime/os.hpp&quot;
 38 #include &quot;runtime/semaphore.hpp&quot;
 39 #include &quot;runtime/thread.inline.hpp&quot;
 40 #include &quot;runtime/threadSMR.hpp&quot;
 41 
 42 enum JfrSampleType {
 43   NO_SAMPLE = 0,
 44   JAVA_SAMPLE = 1,
 45   NATIVE_SAMPLE = 2
 46 };
 47 
 48 static bool thread_state_in_java(JavaThread* thread) {
 49   assert(thread != NULL, &quot;invariant&quot;);
 50   switch(thread-&gt;thread_state()) {
 51     case _thread_new:
 52     case _thread_uninitialized:
 53     case _thread_new_trans:
</pre>
<hr />
<pre>
331   void start_thread();
332 
333   void enroll();
334   void disenroll();
335   void set_java_interval(size_t interval) { _interval_java = interval; };
336   void set_native_interval(size_t interval) { _interval_native = interval; };
337   size_t get_java_interval() { return _interval_java; };
338   size_t get_native_interval() { return _interval_native; };
339  protected:
340   virtual void post_run();
341  public:
342   void run();
343   static Monitor* transition_block() { return JfrThreadSampler_lock; }
344   static void on_javathread_suspend(JavaThread* thread);
345 };
346 
347 static void clear_transition_block(JavaThread* jt) {
348   jt-&gt;clear_trace_flag();
349   JfrThreadLocal* const tl = jt-&gt;jfr_thread_local();
350   if (tl-&gt;is_trace_block()) {
<span class="line-modified">351     MutexLocker ml(JfrThreadSampler::transition_block(), Mutex::_no_safepoint_check_flag);</span>
352     JfrThreadSampler::transition_block()-&gt;notify_all();
353   }
354 }
355 
<span class="line-added">356 static bool is_excluded(JavaThread* thread) {</span>
<span class="line-added">357   assert(thread != NULL, &quot;invariant&quot;);</span>
<span class="line-added">358   return thread-&gt;is_hidden_from_external_view() || thread-&gt;in_deopt_handler() || thread-&gt;jfr_thread_local()-&gt;is_excluded();</span>
<span class="line-added">359 }</span>
<span class="line-added">360 </span>
361 bool JfrThreadSampleClosure::do_sample_thread(JavaThread* thread, JfrStackFrame* frames, u4 max_frames, JfrSampleType type) {
362   assert(Threads_lock-&gt;owned_by_self(), &quot;Holding the thread table lock.&quot;);
<span class="line-modified">363   if (is_excluded(thread)) {</span>
364     return false;
365   }
366 
367   bool ret = false;
<span class="line-modified">368   thread-&gt;set_trace_flag();  // Provides StoreLoad, needed to keep read of thread state from floating up.</span>
369   if (JAVA_SAMPLE == type) {
370     if (thread_state_in_java(thread)) {
371       ret = sample_thread_in_java(thread, frames, max_frames);
372     }
373   } else {
374     assert(NATIVE_SAMPLE == type, &quot;invariant&quot;);
375     if (thread_state_in_native(thread)) {
376       ret = sample_thread_in_native(thread, frames, max_frames);
377     }
378   }
379   clear_transition_block(thread);
380   return ret;
381 }
382 
383 JfrThreadSampler::JfrThreadSampler(size_t interval_java, size_t interval_native, u4 max_frames) :
384   _sample(),
385   _sampler_thread(NULL),
386   _frames(JfrCHeapObj::new_array&lt;JfrStackFrame&gt;(max_frames)),
387   _last_thread_java(NULL),
388   _last_thread_native(NULL),
389   _interval_java(interval_java),
390   _interval_native(interval_native),
391   _cur_index(-1),
392   _max_frames(max_frames),
393   _disenrolled(true) {
394 }
395 
396 JfrThreadSampler::~JfrThreadSampler() {
397   JfrCHeapObj::free(_frames, sizeof(JfrStackFrame) * _max_frames);
398 }
399 
400 void JfrThreadSampler::on_javathread_suspend(JavaThread* thread) {
401   JfrThreadLocal* const tl = thread-&gt;jfr_thread_local();
402   tl-&gt;set_trace_block();
403   {
<span class="line-modified">404     MonitorLocker ml(transition_block(), Mutex::_no_safepoint_check_flag);</span>
405     while (thread-&gt;is_trace_suspend()) {
<span class="line-modified">406       ml.wait();</span>
407     }
408     tl-&gt;clear_trace_block();
409   }
410 }
411 
412 JavaThread* JfrThreadSampler::next_thread(ThreadsList* t_list, JavaThread* first_sampled, JavaThread* current) {
413   assert(t_list != NULL, &quot;invariant&quot;);
414   assert(Threads_lock-&gt;owned_by_self(), &quot;Holding the thread table lock.&quot;);
415   assert(_cur_index &gt;= -1 &amp;&amp; (uint)_cur_index + 1 &lt;= t_list-&gt;length(), &quot;invariant&quot;);
416   assert((current == NULL &amp;&amp; -1 == _cur_index) || (t_list-&gt;find_index_of_JavaThread(current) == _cur_index), &quot;invariant&quot;);
417   if ((uint)_cur_index + 1 == t_list-&gt;length()) {
418     // wrap
419     _cur_index = 0;
420   } else {
421     _cur_index++;
422   }
423   assert(_cur_index &gt;= 0 &amp;&amp; (uint)_cur_index &lt; t_list-&gt;length(), &quot;invariant&quot;);
424   JavaThread* const next = t_list-&gt;thread_at(_cur_index);
425   return next != first_sampled ? next : NULL;
426 }
427 
428 void JfrThreadSampler::start_thread() {
429   if (os::create_thread(this, os::os_thread)) {
430     os::start_thread(this);
431   } else {
432     log_error(jfr)(&quot;Failed to create thread for thread sampling&quot;);
433   }
434 }
435 
436 void JfrThreadSampler::enroll() {
437   if (_disenrolled) {
<span class="line-modified">438     log_trace(jfr)(&quot;Enrolling thread sampler&quot;);</span>
439     _sample.signal();
440     _disenrolled = false;
441   }
442 }
443 
444 void JfrThreadSampler::disenroll() {
445   if (!_disenrolled) {
446     _sample.wait();
447     _disenrolled = true;
<span class="line-modified">448     log_trace(jfr)(&quot;Disenrolling thread sampler&quot;);</span>
449   }
450 }
451 
452 static jlong get_monotonic_ms() {
453   return os::javaTimeNanos() / 1000000;
454 }
455 
456 void JfrThreadSampler::run() {
457   assert(_sampler_thread == NULL, &quot;invariant&quot;);
458 
459   _sampler_thread = this;
460 
461   jlong last_java_ms = get_monotonic_ms();
462   jlong last_native_ms = last_java_ms;
463   while (true) {
464     if (!_sample.trywait()) {
465       // disenrolled
466       _sample.wait();
467       last_java_ms = get_monotonic_ms();
468       last_native_ms = last_java_ms;
469     }
470     _sample.signal();
<span class="line-modified">471     jlong java_interval = _interval_java == 0 ? max_jlong : MAX2&lt;jlong&gt;(_interval_java, 1);</span>
<span class="line-modified">472     jlong native_interval = _interval_native == 0 ? max_jlong : MAX2&lt;jlong&gt;(_interval_native, 1);</span>
473 
474     jlong now_ms = get_monotonic_ms();
475 
476     /*
477      * Let I be java_interval or native_interval.
478      * Let L be last_java_ms or last_native_ms.
479      * Let N be now_ms.
480      *
481      * Interval, I, might be max_jlong so the addition
482      * could potentially overflow without parenthesis (UB). Also note that
483      * L - N &lt; 0. Avoid UB, by adding parenthesis.
484      */
485     jlong next_j = java_interval + (last_java_ms - now_ms);
486     jlong next_n = native_interval + (last_native_ms - now_ms);
487 
488     jlong sleep_to_next = MIN2&lt;jlong&gt;(next_j, next_n);
489 
490     if (sleep_to_next &gt; 0) {
491       os::naked_short_sleep(sleep_to_next);
492     }
</pre>
<hr />
<pre>
505 void JfrThreadSampler::post_run() {
506   this-&gt;NonJavaThread::post_run();
507   delete this;
508 }
509 
510 
511 void JfrThreadSampler::task_stacktrace(JfrSampleType type, JavaThread** last_thread) {
512   ResourceMark rm;
513   EventExecutionSample samples[MAX_NR_OF_JAVA_SAMPLES];
514   EventNativeMethodSample samples_native[MAX_NR_OF_NATIVE_SAMPLES];
515   JfrThreadSampleClosure sample_task(samples, samples_native);
516 
517   const uint sample_limit = JAVA_SAMPLE == type ? MAX_NR_OF_JAVA_SAMPLES : MAX_NR_OF_NATIVE_SAMPLES;
518   uint num_samples = 0;
519   JavaThread* start = NULL;
520 
521   {
522     elapsedTimer sample_time;
523     sample_time.start();
524     {
<span class="line-modified">525       MutexLocker tlock(Threads_lock);</span>
526       ThreadsListHandle tlh;
527       // Resolve a sample session relative start position index into the thread list array.
528       // In cases where the last sampled thread is NULL or not-NULL but stale, find_index() returns -1.
529       _cur_index = tlh.list()-&gt;find_index_of_JavaThread(*last_thread);
530       JavaThread* current = _cur_index != -1 ? *last_thread : NULL;
531 
532       while (num_samples &lt; sample_limit) {
533         current = next_thread(tlh.list(), start, current);
534         if (current == NULL) {
535           break;
536         }
537         if (start == NULL) {
538           start = current;  // remember the thread where we started to attempt sampling
539         }
540         if (current-&gt;is_Compiler_thread()) {
541           continue;
542         }
543         if (sample_task.do_sample_thread(current, _frames, _max_frames, type)) {
544           num_samples++;
545         }
</pre>
<hr />
<pre>
566   _instance = new JfrThreadSampling();
567   return _instance;
568 }
569 
570 void JfrThreadSampling::destroy() {
571   if (_instance != NULL) {
572     delete _instance;
573     _instance = NULL;
574   }
575 }
576 
577 JfrThreadSampling::JfrThreadSampling() : _sampler(NULL) {}
578 
579 JfrThreadSampling::~JfrThreadSampling() {
580   if (_sampler != NULL) {
581     _sampler-&gt;disenroll();
582   }
583 }
584 
585 static void log(size_t interval_java, size_t interval_native) {
<span class="line-modified">586   log_trace(jfr)(&quot;Updated thread sampler for java: &quot; SIZE_FORMAT &quot;  ms, native &quot; SIZE_FORMAT &quot; ms&quot;, interval_java, interval_native);</span>
587 }
588 
589 void JfrThreadSampling::start_sampler(size_t interval_java, size_t interval_native) {
590   assert(_sampler == NULL, &quot;invariant&quot;);
<span class="line-modified">591   log_trace(jfr)(&quot;Enrolling thread sampler&quot;);</span>
592   _sampler = new JfrThreadSampler(interval_java, interval_native, JfrOptionSet::stackdepth());
593   _sampler-&gt;start_thread();
594   _sampler-&gt;enroll();
595 }
596 
597 void JfrThreadSampling::set_sampling_interval(bool java_interval, size_t period) {
598   size_t interval_java = 0;
599   size_t interval_native = 0;
600   if (_sampler != NULL) {
601     interval_java = _sampler-&gt;get_java_interval();
602     interval_native = _sampler-&gt;get_native_interval();
603   }
604   if (java_interval) {
605     interval_java = period;
606   } else {
607     interval_native = period;
608   }
609   if (interval_java &gt; 0 || interval_native &gt; 0) {
610     if (_sampler == NULL) {
<span class="line-modified">611       log_trace(jfr)(&quot;Creating thread sampler for java:%zu ms, native %zu ms&quot;, interval_java, interval_native);</span>
612       start_sampler(interval_java, interval_native);
613     } else {
614       _sampler-&gt;set_java_interval(interval_java);
615       _sampler-&gt;set_native_interval(interval_native);
616       _sampler-&gt;enroll();
617     }
618     assert(_sampler != NULL, &quot;invariant&quot;);
619     log(interval_java, interval_native);
620   } else if (_sampler != NULL) {
621     _sampler-&gt;disenroll();
622   }
623 }
624 
625 void JfrThreadSampling::set_java_sample_interval(size_t period) {
626   if (_instance == NULL &amp;&amp; 0 == period) {
627     return;
628   }
629   instance().set_sampling_interval(true, period);
630 }
631 
</pre>
</td>
</tr>
</table>
<center><a href="jfrCallTrace.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../recorder/checkpoint/jfrCheckpointManager.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/jfr/jni/jfrGetAllEventClasses.cpp b/src/hotspot/share/jfr/jni/jfrGetAllEventClasses.cpp
--- a/src/hotspot/share/jfr/jni/jfrGetAllEventClasses.cpp
+++ b/src/hotspot/share/jfr/jni/jfrGetAllEventClasses.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -31,25 +31,23 @@
 #include "oops/instanceKlass.hpp"
 #include "memory/allocation.inline.hpp"
 #include "memory/resourceArea.hpp"
 #include "runtime/handles.inline.hpp"
 #include "runtime/mutexLocker.hpp"
-#include "runtime/safepoint.hpp"
 #include "runtime/thread.inline.hpp"
 #include "utilities/growableArray.hpp"
 #include "utilities/stack.inline.hpp"
 
- // incremented during class unloading (safepoint) for each unloaded event class
+ // incremented during class unloading for each unloaded event class
 static jlong unloaded_event_classes = 0;
 
 jlong JfrEventClasses::unloaded_event_classes_count() {
   return unloaded_event_classes;
 }
 
 void JfrEventClasses::increment_unloaded_event_class() {
-  // incremented during class unloading (safepoint) for each unloaded event class
-  assert(SafepointSynchronize::is_at_safepoint(), "invariant");
+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
   ++unloaded_event_classes;
 }
 
 static jobject empty_java_util_arraylist = NULL;
 
@@ -88,11 +86,11 @@
   assert(event_subklasses.length() == 0, "invariant");
   assert(event_klass != NULL, "invariant");
   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(thread));
 
   Stack<const Klass*, mtTracing> mark_stack;
-  MutexLocker ml(Compile_lock, thread);
+  MutexLocker ml(thread, Compile_lock);
   mark_stack.push(event_klass->subklass());
 
   while (!mark_stack.is_empty()) {
     const Klass* const current = mark_stack.pop();
     assert(current != NULL, "null element in stack!");
@@ -132,12 +130,11 @@
 jobject JfrEventClasses::get_all_event_classes(TRAPS) {
   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));
   initialize(THREAD);
   assert(empty_java_util_arraylist != NULL, "should have been setup already!");
   static const char jdk_jfr_event_name[] = "jdk/internal/event/Event";
-  unsigned int unused_hash = 0;
-  Symbol* const event_klass_name = SymbolTable::lookup_only(jdk_jfr_event_name, sizeof jdk_jfr_event_name - 1, unused_hash);
+  Symbol* const event_klass_name = SymbolTable::probe(jdk_jfr_event_name, sizeof jdk_jfr_event_name - 1);
 
   if (NULL == event_klass_name) {
     // not loaded yet
     return empty_java_util_arraylist;
   }
@@ -166,14 +163,14 @@
   static const char add_method_name[] = "add";
   static const char add_method_signature[] = "(Ljava/lang/Object;)Z";
   const Klass* const array_list_klass = JfrJavaSupport::klass(empty_java_util_arraylist);
   assert(array_list_klass != NULL, "invariant");
 
-  const Symbol* const add_method_sym = SymbolTable::lookup(add_method_name, sizeof add_method_name - 1, THREAD);
+  const Symbol* const add_method_sym = SymbolTable::new_symbol(add_method_name);
   assert(add_method_sym != NULL, "invariant");
 
-  const Symbol* const add_method_sig_sym = SymbolTable::lookup(add_method_signature, sizeof add_method_signature - 1, THREAD);
+  const Symbol* const add_method_sig_sym = SymbolTable::new_symbol(add_method_signature);
   assert(add_method_signature != NULL, "invariant");
 
   JavaValue result(T_BOOLEAN);
   for (int i = 0; i < event_subklasses.length(); ++i) {
     const jclass clazz = (const jclass)event_subklasses.at(i);

diff a/src/hotspot/share/jfr/jni/jfrJniMethod.hpp b/src/hotspot/share/jfr/jni/jfrJniMethod.hpp
--- a/src/hotspot/share/jfr/jni/jfrJniMethod.hpp
+++ b/src/hotspot/share/jfr/jni/jfrJniMethod.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -47,12 +47,16 @@
 
 jboolean JNICALL jfr_destroy_jfr(JNIEnv* env, jobject jvm);
 
 void JNICALL jfr_begin_recording(JNIEnv* env, jobject jvm);
 
+jboolean JNICALL jfr_is_recording(JNIEnv* env, jobject jvm);
+
 void JNICALL jfr_end_recording(JNIEnv* env, jobject jvm);
 
+void JNICALL jfr_mark_chunk_final(JNIEnv* env, jobject jvm);
+
 jboolean JNICALL jfr_emit_event(JNIEnv* env, jobject jvm, jlong eventTypeId, jlong timeStamp, jlong when);
 
 jobject JNICALL jfr_get_all_event_classes(JNIEnv* env, jobject jvm);
 
 jlong JNICALL jfr_class_id(JNIEnv* env, jclass jvm, jclass jc);
@@ -111,10 +115,11 @@
 
 jobject JNICALL jfr_new_event_writer(JNIEnv* env, jclass cls);
 
 jboolean JNICALL jfr_event_writer_flush(JNIEnv* env, jclass cls, jobject writer, jint used_size, jint requested_size);
 
+void JNICALL jfr_flush(JNIEnv* env, jobject jvm);
 void JNICALL jfr_abort(JNIEnv* env, jobject jvm, jstring errorMsg);
 
 jlong JNICALL jfr_get_epoch_address(JNIEnv* env, jobject jvm);
 
 jboolean JNICALL jfr_add_string_constant(JNIEnv* env, jclass jvm, jboolean epoch, jlong id, jstring string);
@@ -129,10 +134,22 @@
 
 void JNICALL jfr_emit_old_object_samples(JNIEnv* env, jobject jvm, jlong cutoff_ticks, jboolean);
 
 jboolean JNICALL jfr_should_rotate_disk(JNIEnv* env, jobject jvm);
 
+void JNICALL jfr_exclude_thread(JNIEnv* env, jobject jvm, jobject t);
+
+void JNICALL jfr_include_thread(JNIEnv* env, jobject jvm, jobject t);
+
+jboolean JNICALL jfr_is_thread_excluded(JNIEnv* env, jobject jvm, jobject t);
+
+jlong JNICALL jfr_chunk_start_nanos(JNIEnv* env, jobject jvm);
+
+jobject JNICALL jfr_get_handler(JNIEnv* env, jobject jvm, jobject clazz);
+
+jboolean JNICALL jfr_set_handler(JNIEnv* env, jobject jvm, jobject clazz, jobject handler);
+
 
 #ifdef __cplusplus
 }
 #endif
 

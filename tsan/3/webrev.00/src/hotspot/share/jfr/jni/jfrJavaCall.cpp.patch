diff a/src/hotspot/share/jfr/jni/jfrJavaCall.cpp b/src/hotspot/share/jfr/jni/jfrJavaCall.cpp
--- a/src/hotspot/share/jfr/jni/jfrJavaCall.cpp
+++ b/src/hotspot/share/jfr/jni/jfrJavaCall.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -36,13 +36,13 @@
 static bool is_large_value(const JavaValue& value) {
   return value.get_type() == T_LONG || value.get_type() == T_DOUBLE;
 }
 #endif // ASSERT
 
-static Symbol* resolve(const char* str, TRAPS) {
+static Symbol* resolve(const char* str) {
   assert(str != NULL, "invariant");
-  return SymbolTable::lookup(str, (int)strlen(str), THREAD);
+  return SymbolTable::new_symbol(str);
 }
 
 static Klass* resolve(Symbol* k_sym, TRAPS) {
   assert(k_sym != NULL, "invariant");
   return SystemDictionary::resolve_or_fail(k_sym, true, THREAD);
@@ -71,11 +71,11 @@
 
 void JfrJavaArguments::Parameters::set_receiver(const oop receiver) {
   assert(_storage != NULL, "invariant");
   assert(receiver != NULL, "invariant");
   JavaValue value(T_OBJECT);
-  value.set_jobject((jobject)receiver);
+  value.set_jobject(cast_from_oop<jobject>(receiver));
   _storage[0] = value;
 }
 
 void JfrJavaArguments::Parameters::set_receiver(Handle receiver) {
   set_receiver(receiver());
@@ -94,11 +94,11 @@
   return _storage[0].get_type() == T_OBJECT;
 }
 
 void JfrJavaArguments::Parameters::push_oop(const oop obj) {
   JavaValue value(T_OBJECT);
-  value.set_jobject((jobject)obj);
+  value.set_jobject(cast_from_oop<jobject>(obj));
   push(value);
 }
 
 void JfrJavaArguments::Parameters::push_oop(Handle h_obj) {
   push_oop(h_obj());
@@ -182,37 +182,37 @@
         ShouldNotReachHere();
     }
   }
 }
 
-JfrJavaArguments::JfrJavaArguments(JavaValue* result) : _result(result), _klass(NULL), _name(NULL), _signature(NULL), _array_length(0) {
+JfrJavaArguments::JfrJavaArguments(JavaValue* result) : _result(result), _klass(NULL), _name(NULL), _signature(NULL), _array_length(-1) {
   assert(result != NULL, "invariant");
 }
 
 JfrJavaArguments::JfrJavaArguments(JavaValue* result, const char* klass_name, const char* name, const char* signature, TRAPS) :
   _result(result),
   _klass(NULL),
   _name(NULL),
   _signature(NULL),
-  _array_length(0) {
+  _array_length(-1) {
   assert(result != NULL, "invariant");
   if (klass_name != NULL) {
     set_klass(klass_name, CHECK);
   }
   if (name != NULL) {
-    set_name(name, CHECK);
+    set_name(name);
   }
   if (signature != NULL) {
-    set_signature(signature, THREAD);
+    set_signature(signature);
   }
 }
 
 JfrJavaArguments::JfrJavaArguments(JavaValue* result, const Klass* klass, const Symbol* name, const Symbol* signature) : _result(result),
   _klass(NULL),
   _name(NULL),
   _signature(NULL),
-  _array_length(0) {
+  _array_length(-1) {
   assert(result != NULL, "invariant");
   if (klass != NULL) {
     set_klass(klass);
   }
   if (name != NULL) {
@@ -228,11 +228,11 @@
   return const_cast<Klass*>(_klass);
 }
 
 void JfrJavaArguments::set_klass(const char* klass_name, TRAPS) {
   assert(klass_name != NULL, "invariant");
-  Symbol* const k_sym = resolve(klass_name, CHECK);
+  Symbol* const k_sym = resolve(klass_name);
   assert(k_sym != NULL, "invariant");
   const Klass* const klass = resolve(k_sym, CHECK);
   set_klass(klass);
 }
 
@@ -244,13 +244,13 @@
 Symbol* JfrJavaArguments::name() const {
   assert(_name != NULL, "invariant");
   return const_cast<Symbol*>(_name);
 }
 
-void JfrJavaArguments::set_name(const char* name, TRAPS) {
+void JfrJavaArguments::set_name(const char* name) {
   assert(name != NULL, "invariant");
-  const Symbol* const sym = resolve(name, CHECK);
+  const Symbol* const sym = resolve(name);
   set_name(sym);
 }
 
 void JfrJavaArguments::set_name(const Symbol* name) {
   assert(name != NULL, "invariant");
@@ -260,13 +260,13 @@
 Symbol* JfrJavaArguments::signature() const {
   assert(_signature != NULL, "invariant");
   return const_cast<Symbol*>(_signature);
 }
 
-void JfrJavaArguments::set_signature(const char* signature, TRAPS) {
+void JfrJavaArguments::set_signature(const char* signature) {
   assert(signature != NULL, "invariant");
-  const Symbol* const sym = resolve(signature, CHECK);
+  const Symbol* const sym = resolve(signature);
   set_signature(sym);
 }
 
 void JfrJavaArguments::set_signature(const Symbol* signature) {
   assert(signature != NULL, "invariant");

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/jfr/jni/jfrJavaSupport.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="jfrJavaCall.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jfrJavaSupport.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/jni/jfrJavaSupport.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -21,11 +21,10 @@</span>
   * questions.
   *
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="udiff-line-removed">- #include &quot;jni.h&quot;</span>
  #include &quot;classfile/javaClasses.inline.hpp&quot;
  #include &quot;classfile/modules.hpp&quot;
  #include &quot;classfile/symbolTable.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;classfile/vmSymbols.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -40,13 +39,16 @@</span>
  #include &quot;oops/objArrayOop.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;runtime/jniHandles.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;runtime/semaphore.inline.hpp&quot;</span>
  #include &quot;runtime/synchronizer.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;runtime/threadSMR.hpp&quot;
<span class="udiff-line-added">+ #include &quot;utilities/growableArray.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;classfile/vmSymbols.hpp&quot;</span>
  
  #ifdef ASSERT
  void JfrJavaSupport::check_java_thread_in_vm(Thread* t) {
    assert(t != NULL, &quot;invariant&quot;);
    assert(t-&gt;is_Java_thread(), &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -56,10 +58,16 @@</span>
  void JfrJavaSupport::check_java_thread_in_native(Thread* t) {
    assert(t != NULL, &quot;invariant&quot;);
    assert(t-&gt;is_Java_thread(), &quot;invariant&quot;);
    assert(((JavaThread*)t)-&gt;thread_state() == _thread_in_native, &quot;invariant&quot;);
  }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static void check_new_unstarted_java_thread(Thread* t) {</span>
<span class="udiff-line-added">+   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-added">+   assert(t-&gt;is_Java_thread(), &quot;invariant&quot;);</span>
<span class="udiff-line-added">+   assert(((JavaThread*)t)-&gt;thread_state() == _thread_new, &quot;invariant&quot;);</span>
<span class="udiff-line-added">+ }</span>
  #endif
  
  /*
   *  Handles and references
   */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -91,10 +99,25 @@</span>
  
  void JfrJavaSupport::destroy_global_jni_handle(jobject handle) {
    JNIHandles::destroy_global(handle);
  }
  
<span class="udiff-line-added">+ jweak JfrJavaSupport::global_weak_jni_handle(const oop obj, Thread* t) {</span>
<span class="udiff-line-added">+   DEBUG_ONLY(check_java_thread_in_vm(t));</span>
<span class="udiff-line-added">+   HandleMark hm(t);</span>
<span class="udiff-line-added">+   return JNIHandles::make_weak_global(Handle(t, obj));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ jweak JfrJavaSupport::global_weak_jni_handle(const jobject handle, Thread* t) {</span>
<span class="udiff-line-added">+   const oop obj = JNIHandles::resolve(handle);</span>
<span class="udiff-line-added">+   return obj == NULL ? NULL : global_weak_jni_handle(obj, t);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void JfrJavaSupport::destroy_global_weak_jni_handle(jweak handle) {</span>
<span class="udiff-line-added">+   JNIHandles::destroy_weak_global(handle);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  oop JfrJavaSupport::resolve_non_null(jobject obj) {
    return JNIHandles::resolve_non_null(obj);
  }
  
  /*
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -139,11 +162,11 @@</span>
    assert(h_obj.not_null(), &quot;invariant&quot;);
    args-&gt;set_receiver(h_obj);
    result-&gt;set_type(T_VOID); // constructor result type
    JfrJavaSupport::call_special(args, CHECK);
    result-&gt;set_type(T_OBJECT); // set back to original result type
<span class="udiff-line-modified-removed">-   result-&gt;set_jobject((jobject)h_obj());</span>
<span class="udiff-line-modified-added">+   result-&gt;set_jobject(cast_from_oop&lt;jobject&gt;(h_obj()));</span>
  }
  
  static void array_construction(JfrJavaArguments* args, JavaValue* result, InstanceKlass* klass, int array_length, TRAPS) {
    assert(args != NULL, &quot;invariant&quot;);
    assert(result != NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -152,11 +175,11 @@</span>
  
    Klass* const ak = klass-&gt;array_klass(THREAD);
    ObjArrayKlass::cast(ak)-&gt;initialize(THREAD);
    HandleMark hm(THREAD);
    objArrayOop arr = ObjArrayKlass::cast(ak)-&gt;allocate(array_length, CHECK);
<span class="udiff-line-modified-removed">-   result-&gt;set_jobject((jobject)arr);</span>
<span class="udiff-line-modified-added">+   result-&gt;set_jobject(cast_from_oop&lt;jobject&gt;(arr));</span>
  }
  
  static void create_object(JfrJavaArguments* args, JavaValue* result, TRAPS) {
    assert(args != NULL, &quot;invariant&quot;);
    assert(result != NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -166,11 +189,11 @@</span>
    InstanceKlass* const klass = static_cast&lt;InstanceKlass*&gt;(args-&gt;klass());
    klass-&gt;initialize(CHECK);
  
    const int array_length = args-&gt;array_length();
  
<span class="udiff-line-modified-removed">-   if (array_length &gt; 0) {</span>
<span class="udiff-line-modified-added">+   if (array_length &gt;= 0) {</span>
      array_construction(args, result, klass, array_length, CHECK);
    } else {
      object_construction(args, result, klass, THREAD);
    }
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -353,11 +376,11 @@</span>
        break;
      case T_LONG:
        result-&gt;set_jlong(h_oop-&gt;long_field(fd-&gt;offset()));
        break;
      case T_OBJECT:
<span class="udiff-line-modified-removed">-       result-&gt;set_jobject((jobject)h_oop-&gt;obj_field(fd-&gt;offset()));</span>
<span class="udiff-line-modified-added">+       result-&gt;set_jobject(cast_from_oop&lt;jobject&gt;(h_oop-&gt;obj_field(fd-&gt;offset())));</span>
        break;
      default:
        ShouldNotReachHere();
    }
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -516,10 +539,14 @@</span>
  
  void JfrJavaSupport::throw_class_format_error(const char* message, TRAPS) {
    create_and_throw(vmSymbols::java_lang_ClassFormatError(), message, THREAD);
  }
  
<span class="udiff-line-added">+ void JfrJavaSupport::throw_runtime_exception(const char* message, TRAPS) {</span>
<span class="udiff-line-added">+   create_and_throw(vmSymbols::java_lang_RuntimeException(), message, THREAD);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void JfrJavaSupport::abort(jstring errorMsg, Thread* t) {
    DEBUG_ONLY(check_java_thread_in_vm(t));
  
    ResourceMark rm(t);
    const char* const error_msg = c_str(errorMsg, t);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -577,11 +604,11 @@</span>
  const char* const JDK_JFR_PACKAGE_NAME = &quot;jdk/jfr&quot;;
  
  static bool is_jdk_jfr_module_in_readability_graph() {
    Thread* const t = Thread::current();
    // take one of the packages in the module to be located and query for its definition.
<span class="udiff-line-modified-removed">-   TempNewSymbol pkg_sym = SymbolTable::new_symbol(JDK_JFR_PACKAGE_NAME, t);</span>
<span class="udiff-line-modified-added">+   TempNewSymbol pkg_sym = SymbolTable::new_symbol(JDK_JFR_PACKAGE_NAME);</span>
    return Modules::is_package_defined(pkg_sym, Handle(), t);
  }
  
  static void print_module_resolution_error(outputStream* stream) {
    assert(stream != NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -601,11 +628,219 @@</span>
      return false;
    }
    return true;
  }
  
<span class="udiff-line-modified-removed">- jlong JfrJavaSupport::jfr_thread_id(jobject target_thread) {</span>
<span class="udiff-line-modified-added">+ class ThreadExclusionListAccess : public StackObj {</span>
<span class="udiff-line-added">+  private:</span>
<span class="udiff-line-added">+   static Semaphore _mutex_semaphore;</span>
<span class="udiff-line-added">+  public:</span>
<span class="udiff-line-added">+   ThreadExclusionListAccess() { _mutex_semaphore.wait(); }</span>
<span class="udiff-line-added">+   ~ThreadExclusionListAccess() { _mutex_semaphore.signal(); }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ Semaphore ThreadExclusionListAccess::_mutex_semaphore(1);</span>
<span class="udiff-line-added">+ static GrowableArray&lt;jweak&gt;* exclusion_list = NULL;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static bool equals(const jweak excluded_thread, Handle target_thread) {</span>
<span class="udiff-line-added">+   return JfrJavaSupport::resolve_non_null(excluded_thread) == target_thread();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static int find_exclusion_thread_idx(Handle thread) {</span>
<span class="udiff-line-added">+   if (exclusion_list != NULL) {</span>
<span class="udiff-line-added">+     for (int i = 0; i &lt; exclusion_list-&gt;length(); ++i) {</span>
<span class="udiff-line-added">+       if (equals(exclusion_list-&gt;at(i), thread)) {</span>
<span class="udiff-line-added">+         return i;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return -1;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static Handle as_handle(jobject thread) {</span>
<span class="udiff-line-added">+   return Handle(Thread::current(), JfrJavaSupport::resolve_non_null(thread));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static bool thread_is_not_excluded(Handle thread) {</span>
<span class="udiff-line-added">+   return -1 == find_exclusion_thread_idx(thread);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static bool thread_is_not_excluded(jobject thread) {</span>
<span class="udiff-line-added">+   return thread_is_not_excluded(as_handle(thread));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static bool is_thread_excluded(jobject thread) {</span>
<span class="udiff-line-added">+   return !thread_is_not_excluded(thread);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifdef ASSERT</span>
<span class="udiff-line-added">+ static bool is_thread_excluded(Handle thread) {</span>
<span class="udiff-line-added">+   return !thread_is_not_excluded(thread);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ #endif // ASSERT</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static int add_thread_to_exclusion_list(jobject thread) {</span>
<span class="udiff-line-added">+   ThreadExclusionListAccess lock;</span>
<span class="udiff-line-added">+   if (exclusion_list == NULL) {</span>
<span class="udiff-line-added">+     exclusion_list = new (ResourceObj::C_HEAP, mtTracing) GrowableArray&lt;jweak&gt;(10, true, mtTracing);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   assert(exclusion_list != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-added">+   assert(thread_is_not_excluded(thread), &quot;invariant&quot;);</span>
<span class="udiff-line-added">+   jweak ref = JfrJavaSupport::global_weak_jni_handle(thread, Thread::current());</span>
<span class="udiff-line-added">+   const int idx = exclusion_list-&gt;append(ref);</span>
<span class="udiff-line-added">+   assert(is_thread_excluded(thread), &quot;invariant&quot;);</span>
<span class="udiff-line-added">+   return idx;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static void remove_thread_from_exclusion_list(Handle thread) {</span>
<span class="udiff-line-added">+   assert(exclusion_list != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-added">+   assert(is_thread_excluded(thread), &quot;invariant&quot;);</span>
<span class="udiff-line-added">+   assert(exclusion_list != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-added">+   const int idx = find_exclusion_thread_idx(thread);</span>
<span class="udiff-line-added">+   assert(idx &gt;= 0, &quot;invariant&quot;);</span>
<span class="udiff-line-added">+   assert(idx &lt; exclusion_list-&gt;length(), &quot;invariant&quot;);</span>
<span class="udiff-line-added">+   JfrJavaSupport::destroy_global_weak_jni_handle(exclusion_list-&gt;at(idx));</span>
<span class="udiff-line-added">+   exclusion_list-&gt;delete_at(idx);</span>
<span class="udiff-line-added">+   assert(thread_is_not_excluded(thread), &quot;invariant&quot;);</span>
<span class="udiff-line-added">+   if (0 == exclusion_list-&gt;length()) {</span>
<span class="udiff-line-added">+     delete exclusion_list;</span>
<span class="udiff-line-added">+     exclusion_list = NULL;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static void remove_thread_from_exclusion_list(jobject thread) {</span>
<span class="udiff-line-added">+   ThreadExclusionListAccess lock;</span>
<span class="udiff-line-added">+   remove_thread_from_exclusion_list(as_handle(thread));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // includes removal</span>
<span class="udiff-line-added">+ static bool check_exclusion_state_on_thread_start(JavaThread* jt) {</span>
<span class="udiff-line-added">+   Handle h_obj(jt, jt-&gt;threadObj());</span>
<span class="udiff-line-added">+   ThreadExclusionListAccess lock;</span>
<span class="udiff-line-added">+   if (thread_is_not_excluded(h_obj)) {</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   remove_thread_from_exclusion_list(h_obj);</span>
<span class="udiff-line-added">+   return true;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ jlong JfrJavaSupport::jfr_thread_id(jobject thread) {</span>
    ThreadsListHandle tlh;
    JavaThread* native_thread = NULL;
<span class="udiff-line-modified-removed">-   (void)tlh.cv_internal_thread_to_JavaThread(target_thread, &amp;native_thread, NULL);</span>
<span class="udiff-line-modified-added">+   (void)tlh.cv_internal_thread_to_JavaThread(thread, &amp;native_thread, NULL);</span>
    return native_thread != NULL ? JFR_THREAD_ID(native_thread) : 0;
  }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void JfrJavaSupport::exclude(jobject thread) {</span>
<span class="udiff-line-added">+   HandleMark hm;</span>
<span class="udiff-line-added">+   ThreadsListHandle tlh;</span>
<span class="udiff-line-added">+   JavaThread* native_thread = NULL;</span>
<span class="udiff-line-added">+   (void)tlh.cv_internal_thread_to_JavaThread(thread, &amp;native_thread, NULL);</span>
<span class="udiff-line-added">+   if (native_thread != NULL) {</span>
<span class="udiff-line-added">+     JfrThreadLocal::exclude(native_thread);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     // not started yet, track the thread oop</span>
<span class="udiff-line-added">+     add_thread_to_exclusion_list(thread);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void JfrJavaSupport::include(jobject thread) {</span>
<span class="udiff-line-added">+   HandleMark hm;</span>
<span class="udiff-line-added">+   ThreadsListHandle tlh;</span>
<span class="udiff-line-added">+   JavaThread* native_thread = NULL;</span>
<span class="udiff-line-added">+   (void)tlh.cv_internal_thread_to_JavaThread(thread, &amp;native_thread, NULL);</span>
<span class="udiff-line-added">+   if (native_thread != NULL) {</span>
<span class="udiff-line-added">+     JfrThreadLocal::include(native_thread);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     // not started yet, untrack the thread oop</span>
<span class="udiff-line-added">+     remove_thread_from_exclusion_list(thread);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool JfrJavaSupport::is_excluded(jobject thread) {</span>
<span class="udiff-line-added">+   HandleMark hm;</span>
<span class="udiff-line-added">+   ThreadsListHandle tlh;</span>
<span class="udiff-line-added">+   JavaThread* native_thread = NULL;</span>
<span class="udiff-line-added">+   (void)tlh.cv_internal_thread_to_JavaThread(thread, &amp;native_thread, NULL);</span>
<span class="udiff-line-added">+   return native_thread != NULL ? native_thread-&gt;jfr_thread_local()-&gt;is_excluded() : is_thread_excluded(thread);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ jobject JfrJavaSupport::get_handler(jobject clazz, TRAPS) {</span>
<span class="udiff-line-added">+   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));</span>
<span class="udiff-line-added">+   const oop klass_oop = JNIHandles::resolve(clazz);</span>
<span class="udiff-line-added">+   assert(klass_oop != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-added">+   Klass* klass = java_lang_Class::as_Klass(klass_oop);</span>
<span class="udiff-line-added">+   HandleMark hm(THREAD);</span>
<span class="udiff-line-added">+   Handle h_klass_oop(Handle(THREAD, klass-&gt;java_mirror()));</span>
<span class="udiff-line-added">+   InstanceKlass* const instance_klass = static_cast&lt;InstanceKlass*&gt;(klass);</span>
<span class="udiff-line-added">+   klass-&gt;initialize(CHECK_NULL);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   fieldDescriptor event_handler_field;</span>
<span class="udiff-line-added">+   Klass* f = instance_klass-&gt;find_field(</span>
<span class="udiff-line-added">+     vmSymbols::eventHandler_name(),</span>
<span class="udiff-line-added">+     vmSymbols::jdk_jfr_internal_handlers_EventHandler_signature(),</span>
<span class="udiff-line-added">+     true, &amp;event_handler_field);</span>
<span class="udiff-line-added">+   if (f != NULL) {</span>
<span class="udiff-line-added">+     oop ret = h_klass_oop-&gt;obj_field(event_handler_field.offset());</span>
<span class="udiff-line-added">+     return ret != NULL ? JfrJavaSupport::local_jni_handle(ret, THREAD) : NULL;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   fieldDescriptor object_field;</span>
<span class="udiff-line-added">+   Klass* g = instance_klass-&gt;find_field(</span>
<span class="udiff-line-added">+     vmSymbols::eventHandler_name(),</span>
<span class="udiff-line-added">+     vmSymbols::object_signature(),</span>
<span class="udiff-line-added">+     true, &amp;object_field);</span>
<span class="udiff-line-added">+   if (g != NULL) {</span>
<span class="udiff-line-added">+     oop ret = h_klass_oop-&gt;obj_field(object_field.offset());</span>
<span class="udiff-line-added">+     return ret != NULL ? JfrJavaSupport::local_jni_handle(ret, THREAD) : NULL;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   assert(f == NULL &amp;&amp; g == NULL, &quot;no handler field for class&quot;);</span>
<span class="udiff-line-added">+   return NULL;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool JfrJavaSupport::set_handler(jobject clazz, jobject handler, TRAPS) {</span>
<span class="udiff-line-added">+   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));</span>
<span class="udiff-line-added">+   const oop klass_oop = JNIHandles::resolve(clazz);</span>
<span class="udiff-line-added">+   assert(klass_oop != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-added">+   const oop handler_oop = JNIHandles::resolve(handler);</span>
<span class="udiff-line-added">+   assert(handler_oop != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-added">+   Klass* klass = java_lang_Class::as_Klass(klass_oop);</span>
<span class="udiff-line-added">+   HandleMark hm(THREAD);</span>
<span class="udiff-line-added">+   Handle h_klass_oop(Handle(THREAD, klass-&gt;java_mirror()));</span>
<span class="udiff-line-added">+   InstanceKlass* const instance_klass = static_cast&lt;InstanceKlass*&gt;(klass);</span>
<span class="udiff-line-added">+   klass-&gt;initialize(CHECK_false);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   fieldDescriptor event_handler_field;</span>
<span class="udiff-line-added">+   Klass* f = instance_klass-&gt;find_field(</span>
<span class="udiff-line-added">+     vmSymbols::eventHandler_name(),</span>
<span class="udiff-line-added">+     vmSymbols::jdk_jfr_internal_handlers_EventHandler_signature(),</span>
<span class="udiff-line-added">+     true, &amp;event_handler_field);</span>
<span class="udiff-line-added">+   if (f != NULL) {</span>
<span class="udiff-line-added">+     h_klass_oop-&gt;obj_field_put(event_handler_field.offset(), handler_oop);</span>
<span class="udiff-line-added">+     return true;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   fieldDescriptor object_handler_field;</span>
<span class="udiff-line-added">+   Klass* g = instance_klass-&gt;find_field(</span>
<span class="udiff-line-added">+     vmSymbols::eventHandler_name(),</span>
<span class="udiff-line-added">+     vmSymbols::object_signature(),</span>
<span class="udiff-line-added">+     true, &amp;object_handler_field);</span>
<span class="udiff-line-added">+   if (g != NULL) {</span>
<span class="udiff-line-added">+     h_klass_oop-&gt;obj_field_put(object_handler_field.offset(), handler_oop);</span>
<span class="udiff-line-added">+     return true;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   assert(f == NULL &amp;&amp; g == NULL, &quot;no handler field for class&quot;);</span>
<span class="udiff-line-added">+   return false;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void JfrJavaSupport::on_thread_start(Thread* t) {</span>
<span class="udiff-line-added">+   assert(t != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-added">+   assert(Thread::current() == t, &quot;invariant&quot;);</span>
<span class="udiff-line-added">+   if (!t-&gt;is_Java_thread()) {</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   DEBUG_ONLY(check_new_unstarted_java_thread(t);)</span>
<span class="udiff-line-added">+   HandleMark hm;</span>
<span class="udiff-line-added">+   if (check_exclusion_state_on_thread_start((JavaThread*)t)) {</span>
<span class="udiff-line-added">+     JfrThreadLocal::exclude(t);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
</pre>
<center><a href="jfrJavaCall.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jfrJavaSupport.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
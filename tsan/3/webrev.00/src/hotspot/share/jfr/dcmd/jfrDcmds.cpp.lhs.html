<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jfr/dcmd/jfrDcmds.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/javaClasses.hpp&quot;
 27 #include &quot;classfile/vmSymbols.hpp&quot;
 28 #include &quot;jfr/jfr.hpp&quot;
 29 #include &quot;jfr/dcmd/jfrDcmds.hpp&quot;
 30 #include &quot;jfr/jni/jfrJavaSupport.hpp&quot;
 31 #include &quot;jfr/recorder/jfrRecorder.hpp&quot;
 32 #include &quot;jfr/recorder/service/jfrOptionSet.hpp&quot;
 33 #include &quot;memory/resourceArea.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
 35 #include &quot;oops/symbol.hpp&quot;
 36 #include &quot;runtime/handles.inline.hpp&quot;
 37 #include &quot;services/diagnosticArgument.hpp&quot;
 38 #include &quot;services/diagnosticFramework.hpp&quot;
 39 #include &quot;utilities/globalDefinitions.hpp&quot;
 40 
 41 #ifdef _WINDOWS
 42 #define JFR_FILENAME_EXAMPLE &quot;C:\\Users\\user\\My Recording.jfr&quot;
 43 #endif
 44 
 45 #ifdef __APPLE__
 46 #define JFR_FILENAME_EXAMPLE  &quot;/Users/user/My Recording.jfr&quot;
 47 #endif
 48 
 49 #ifndef JFR_FILENAME_EXAMPLE
 50 #define JFR_FILENAME_EXAMPLE &quot;/home/user/My Recording.jfr&quot;
 51 #endif
 52 
 53 // JNIHandle management
 54 
 55 // ------------------------------------------------------------------
 56 // push_jni_handle_block
 57 //
 58 // Push on a new block of JNI handles.
 59 static void push_jni_handle_block(Thread* const thread) {
 60   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(thread));
 61 
 62   // Allocate a new block for JNI handles.
 63   // Inlined code from jni_PushLocalFrame()
 64   JNIHandleBlock* prev_handles = thread-&gt;active_handles();
 65   JNIHandleBlock* entry_handles = JNIHandleBlock::allocate_block(thread);
 66   assert(entry_handles != NULL &amp;&amp; prev_handles != NULL, &quot;should not be NULL&quot;);
 67   entry_handles-&gt;set_pop_frame_link(prev_handles);  // make sure prev handles get gc&#39;d.
 68   thread-&gt;set_active_handles(entry_handles);
 69 }
 70 
 71 // ------------------------------------------------------------------
 72 // pop_jni_handle_block
 73 //
 74 // Pop off the current block of JNI handles.
 75 static void pop_jni_handle_block(Thread* const thread) {
 76   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(thread));
 77 
 78   // Release our JNI handle block
 79   JNIHandleBlock* entry_handles = thread-&gt;active_handles();
 80   JNIHandleBlock* prev_handles = entry_handles-&gt;pop_frame_link();
 81   // restore
 82   thread-&gt;set_active_handles(prev_handles);
 83   entry_handles-&gt;set_pop_frame_link(NULL);
 84   JNIHandleBlock::release_block(entry_handles, thread); // may block
 85 }
 86 
 87 class JNIHandleBlockManager : public StackObj {
 88  private:
 89   Thread* const _thread;
 90  public:
 91   JNIHandleBlockManager(Thread* thread) : _thread(thread) {
 92     push_jni_handle_block(_thread);
 93   }
 94 
 95   ~JNIHandleBlockManager() {
 96     pop_jni_handle_block(_thread);
 97   }
 98 };
 99 
100 static bool is_module_available(outputStream* output, TRAPS) {
101   return JfrJavaSupport::is_jdk_jfr_module_available(output, THREAD);
102 }
103 
104 static bool is_disabled(outputStream* output) {
105   if (Jfr::is_disabled()) {
106     if (output != NULL) {
107       output-&gt;print_cr(&quot;Flight Recorder is disabled.\n&quot;);
108     }
109     return true;
110   }
111   return false;
112 }
113 
114 static bool is_recorder_instance_created(outputStream* output) {
115   if (!JfrRecorder::is_created()) {
116     if (output != NULL) {
117       output-&gt;print_cr(&quot;No available recordings.\n&quot;);
118       output-&gt;print_cr(&quot;Use JFR.start to start a recording.\n&quot;);
119     }
120     return false;
121   }
122   return true;
123 }
124 
125 static bool invalid_state(outputStream* out, TRAPS) {
126   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));
127   return is_disabled(out) || !is_module_available(out, THREAD);
128 }
129 
130 static void print_pending_exception(outputStream* output, oop throwable) {
131   assert(throwable != NULL, &quot;invariant&quot;);
132 
133   oop msg = java_lang_Throwable::message(throwable);
134 
135   if (msg != NULL) {
136     char* text = java_lang_String::as_utf8_string(msg);
137     output-&gt;print_raw_cr(text);
138   }
139 }
140 
141 static void print_message(outputStream* output, const char* message) {
142   if (message != NULL) {
143     output-&gt;print_raw(message);
144   }
145 }
146 
147 static void handle_dcmd_result(outputStream* output,
148                                const oop result,
149                                const DCmdSource source,
150                                TRAPS) {
151   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));
152   assert(output != NULL, &quot;invariant&quot;);
153   if (HAS_PENDING_EXCEPTION) {
154     print_pending_exception(output, PENDING_EXCEPTION);
155     // Don&#39;t clear excption on startup, JVM should fail initialization.
156     if (DCmd_Source_Internal != source) {
157       CLEAR_PENDING_EXCEPTION;
158     }
159     return;
160   }
161 
162   assert(!HAS_PENDING_EXCEPTION, &quot;invariant&quot;);
163 
164   if (result != NULL) {
165     const char* result_chars = java_lang_String::as_utf8_string(result);
166     print_message(output, result_chars);
167   }
168 }
169 
170 static oop construct_dcmd_instance(JfrJavaArguments* args, TRAPS) {
171   assert(args != NULL, &quot;invariant&quot;);
172   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));
173   assert(args-&gt;klass() != NULL, &quot;invariant&quot;);
<a name="2" id="anc2"></a><span class="line-modified">174   args-&gt;set_name(&quot;&lt;init&gt;&quot;, CHECK_NULL);</span>
<span class="line-modified">175   args-&gt;set_signature(&quot;()V&quot;, CHECK_NULL);</span>
176   JfrJavaSupport::new_object(args, CHECK_NULL);
177   return (oop)args-&gt;result()-&gt;get_jobject();
178 }
179 
180 JfrDumpFlightRecordingDCmd::JfrDumpFlightRecordingDCmd(outputStream* output,
181                                                        bool heap) : DCmdWithParser(output, heap),
182   _name(&quot;name&quot;, &quot;Recording name, e.g. \\\&quot;My Recording\\\&quot;&quot;, &quot;STRING&quot;, false, NULL),
183   _filename(&quot;filename&quot;, &quot;Copy recording data to file, e.g. \\\&quot;&quot; JFR_FILENAME_EXAMPLE &quot;\\\&quot;&quot;, &quot;STRING&quot;, false),
184   _maxage(&quot;maxage&quot;, &quot;Maximum duration to dump, in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 60m, or 0 for no limit&quot;, &quot;NANOTIME&quot;, false, &quot;0&quot;),
185   _maxsize(&quot;maxsize&quot;, &quot;Maximum amount of bytes to dump, in (M)B or (G)B, e.g. 500M, or 0 for no limit&quot;, &quot;MEMORY SIZE&quot;, false, &quot;0&quot;),
186   _begin(&quot;begin&quot;, &quot;Point in time to dump data from, e.g. 09:00, 21:35:00, 2018-06-03T18:12:56.827Z, 2018-06-03T20:13:46.832, -10m, -3h, or -1d&quot;, &quot;STRING&quot;, false),
187   _end(&quot;end&quot;, &quot;Point in time to dump data to, e.g. 09:00, 21:35:00, 2018-06-03T18:12:56.827Z, 2018-06-03T20:13:46.832, -10m, -3h, or -1d&quot;, &quot;STRING&quot;, false),
188   _path_to_gc_roots(&quot;path-to-gc-roots&quot;, &quot;Collect path to GC roots&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
189   _dcmdparser.add_dcmd_option(&amp;_name);
190   _dcmdparser.add_dcmd_option(&amp;_filename);
191   _dcmdparser.add_dcmd_option(&amp;_maxage);
192   _dcmdparser.add_dcmd_option(&amp;_maxsize);
193   _dcmdparser.add_dcmd_option(&amp;_begin);
194   _dcmdparser.add_dcmd_option(&amp;_end);
195   _dcmdparser.add_dcmd_option(&amp;_path_to_gc_roots);
196 };
197 
198 int JfrDumpFlightRecordingDCmd::num_arguments() {
199   ResourceMark rm;
200   JfrDumpFlightRecordingDCmd* dcmd = new JfrDumpFlightRecordingDCmd(NULL, false);
201   if (dcmd != NULL) {
202     DCmdMark mark(dcmd);
203     return dcmd-&gt;_dcmdparser.num_arguments();
204   }
205   return 0;
206 }
207 
208 void JfrDumpFlightRecordingDCmd::execute(DCmdSource source, TRAPS) {
209   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));
210 
211   if (invalid_state(output(), THREAD) || !is_recorder_instance_created(output())) {
212     return;
213   }
214 
215   ResourceMark rm(THREAD);
216   HandleMark hm(THREAD);
217   JNIHandleBlockManager jni_handle_management(THREAD);
218 
219   JavaValue result(T_OBJECT);
220   JfrJavaArguments constructor_args(&amp;result);
221   constructor_args.set_klass(&quot;jdk/jfr/internal/dcmd/DCmdDump&quot;, CHECK);
222   const oop dcmd = construct_dcmd_instance(&amp;constructor_args, CHECK);
223   Handle h_dcmd_instance(THREAD, dcmd);
224   assert(h_dcmd_instance.not_null(), &quot;invariant&quot;);
225 
226   jstring name = NULL;
227   if (_name.is_set() &amp;&amp; _name.value()  != NULL) {
228     name = JfrJavaSupport::new_string(_name.value(), CHECK);
229   }
230 
231   jstring filepath = NULL;
232   if (_filename.is_set() &amp;&amp; _filename.value() != NULL) {
233     filepath = JfrJavaSupport::new_string(_filename.value(), CHECK);
234   }
235 
236   jobject maxage = NULL;
237   if (_maxage.is_set()) {
238     maxage = JfrJavaSupport::new_java_lang_Long(_maxage.value()._nanotime, CHECK);
239   }
240 
241   jobject maxsize = NULL;
242   if (_maxsize.is_set()) {
243     maxsize = JfrJavaSupport::new_java_lang_Long(_maxsize.value()._size, CHECK);
244   }
245 
246   jstring begin = NULL;
247   if (_begin.is_set() &amp;&amp; _begin.value() != NULL) {
248     begin = JfrJavaSupport::new_string(_begin.value(), CHECK);
249   }
250 
251   jstring end = NULL;
252   if (_end.is_set() &amp;&amp; _end.value() != NULL) {
253     end = JfrJavaSupport::new_string(_end.value(), CHECK);
254   }
255 
256   jobject path_to_gc_roots = NULL;
257   if (_path_to_gc_roots.is_set()) {
258     path_to_gc_roots = JfrJavaSupport::new_java_lang_Boolean(_path_to_gc_roots.value(), CHECK);
259   }
260 
261   static const char klass[] = &quot;jdk/jfr/internal/dcmd/DCmdDump&quot;;
262   static const char method[] = &quot;execute&quot;;
263   static const char signature[] = &quot;(Ljava/lang/String;Ljava/lang/String;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/String;Ljava/lang/String;Ljava/lang/Boolean;)Ljava/lang/String;&quot;;
264 
265   JfrJavaArguments execute_args(&amp;result, klass, method, signature, CHECK);
266   execute_args.set_receiver(h_dcmd_instance);
267 
268   // arguments
269   execute_args.push_jobject(name);
270   execute_args.push_jobject(filepath);
271   execute_args.push_jobject(maxage);
272   execute_args.push_jobject(maxsize);
273   execute_args.push_jobject(begin);
274   execute_args.push_jobject(end);
275   execute_args.push_jobject(path_to_gc_roots);
276 
277   JfrJavaSupport::call_virtual(&amp;execute_args, THREAD);
278   handle_dcmd_result(output(), (oop)result.get_jobject(), source, THREAD);
279 }
280 
281 JfrCheckFlightRecordingDCmd::JfrCheckFlightRecordingDCmd(outputStream* output, bool heap) : DCmdWithParser(output, heap),
282   _name(&quot;name&quot;,&quot;Recording name, e.g. \\\&quot;My Recording\\\&quot; or omit to see all recordings&quot;,&quot;STRING&quot;,false, NULL),
283   _verbose(&quot;verbose&quot;,&quot;Print event settings for the recording(s)&quot;,&quot;BOOLEAN&quot;,
284            false, &quot;false&quot;) {
285   _dcmdparser.add_dcmd_option(&amp;_name);
286   _dcmdparser.add_dcmd_option(&amp;_verbose);
287 };
288 
289 int JfrCheckFlightRecordingDCmd::num_arguments() {
290   ResourceMark rm;
291   JfrCheckFlightRecordingDCmd* dcmd = new JfrCheckFlightRecordingDCmd(NULL, false);
292   if (dcmd != NULL) {
293     DCmdMark mark(dcmd);
294     return dcmd-&gt;_dcmdparser.num_arguments();
295   }
296   return 0;
297 }
298 
299 void JfrCheckFlightRecordingDCmd::execute(DCmdSource source, TRAPS) {
300   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));
301 
302   if (invalid_state(output(), THREAD) || !is_recorder_instance_created(output())) {
303     return;
304   }
305 
306   ResourceMark rm(THREAD);
307   HandleMark hm(THREAD);
308   JNIHandleBlockManager jni_handle_management(THREAD);
309 
310   JavaValue result(T_OBJECT);
311   JfrJavaArguments constructor_args(&amp;result);
312   constructor_args.set_klass(&quot;jdk/jfr/internal/dcmd/DCmdCheck&quot;, CHECK);
313   const oop dcmd = construct_dcmd_instance(&amp;constructor_args, CHECK);
314   Handle h_dcmd_instance(THREAD, dcmd);
315   assert(h_dcmd_instance.not_null(), &quot;invariant&quot;);
316 
317   jstring name = NULL;
318   if (_name.is_set() &amp;&amp; _name.value() != NULL) {
319     name = JfrJavaSupport::new_string(_name.value(), CHECK);
320   }
321 
322   jobject verbose = NULL;
323   if (_verbose.is_set()) {
324     verbose = JfrJavaSupport::new_java_lang_Boolean(_verbose.value(), CHECK);
325   }
326 
327   static const char klass[] = &quot;jdk/jfr/internal/dcmd/DCmdCheck&quot;;
328   static const char method[] = &quot;execute&quot;;
329   static const char signature[] = &quot;(Ljava/lang/String;Ljava/lang/Boolean;)Ljava/lang/String;&quot;;
330 
331   JfrJavaArguments execute_args(&amp;result, klass, method, signature, CHECK);
332   execute_args.set_receiver(h_dcmd_instance);
333 
334   // arguments
335   execute_args.push_jobject(name);
336   execute_args.push_jobject(verbose);
337 
338   JfrJavaSupport::call_virtual(&amp;execute_args, THREAD);
339   handle_dcmd_result(output(), (oop)result.get_jobject(), source, THREAD);
340 }
341 
342 JfrStartFlightRecordingDCmd::JfrStartFlightRecordingDCmd(outputStream* output,
343                                                          bool heap) : DCmdWithParser(output, heap),
344   _name(&quot;name&quot;, &quot;Name that can be used to identify recording, e.g. \\\&quot;My Recording\\\&quot;&quot;, &quot;STRING&quot;, false, NULL),
345   _settings(&quot;settings&quot;, &quot;Settings file(s), e.g. profile or default. See JRE_HOME/lib/jfr&quot;, &quot;STRING SET&quot;, false),
346   _delay(&quot;delay&quot;, &quot;Delay recording start with (s)econds, (m)inutes), (h)ours), or (d)ays, e.g. 5h.&quot;, &quot;NANOTIME&quot;, false, &quot;0&quot;),
347   _duration(&quot;duration&quot;, &quot;Duration of recording in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 300s.&quot;, &quot;NANOTIME&quot;, false, &quot;0&quot;),
348   _disk(&quot;disk&quot;, &quot;Recording should be persisted to disk&quot;, &quot;BOOLEAN&quot;, false),
349   _filename(&quot;filename&quot;, &quot;Resulting recording filename, e.g. \\\&quot;&quot; JFR_FILENAME_EXAMPLE &quot;\\\&quot;&quot;, &quot;STRING&quot;, false),
350   _maxage(&quot;maxage&quot;, &quot;Maximum time to keep recorded data (on disk) in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 60m, or 0 for no limit&quot;, &quot;NANOTIME&quot;, false, &quot;0&quot;),
351   _maxsize(&quot;maxsize&quot;, &quot;Maximum amount of bytes to keep (on disk) in (k)B, (M)B or (G)B, e.g. 500M, or 0 for no limit&quot;, &quot;MEMORY SIZE&quot;, false, &quot;0&quot;),
<a name="3" id="anc3"></a>
352   _dump_on_exit(&quot;dumponexit&quot;, &quot;Dump running recording when JVM shuts down&quot;, &quot;BOOLEAN&quot;, false),
353   _path_to_gc_roots(&quot;path-to-gc-roots&quot;, &quot;Collect path to GC roots&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
354   _dcmdparser.add_dcmd_option(&amp;_name);
355   _dcmdparser.add_dcmd_option(&amp;_settings);
356   _dcmdparser.add_dcmd_option(&amp;_delay);
357   _dcmdparser.add_dcmd_option(&amp;_duration);
358   _dcmdparser.add_dcmd_option(&amp;_disk);
359   _dcmdparser.add_dcmd_option(&amp;_filename);
360   _dcmdparser.add_dcmd_option(&amp;_maxage);
361   _dcmdparser.add_dcmd_option(&amp;_maxsize);
<a name="4" id="anc4"></a>
362   _dcmdparser.add_dcmd_option(&amp;_dump_on_exit);
363   _dcmdparser.add_dcmd_option(&amp;_path_to_gc_roots);
364 };
365 
366 int JfrStartFlightRecordingDCmd::num_arguments() {
367   ResourceMark rm;
368   JfrStartFlightRecordingDCmd* dcmd = new JfrStartFlightRecordingDCmd(NULL, false);
369   if (dcmd != NULL) {
370     DCmdMark mark(dcmd);
371     return dcmd-&gt;_dcmdparser.num_arguments();
372   }
373   return 0;
374 }
375 
376 void JfrStartFlightRecordingDCmd::execute(DCmdSource source, TRAPS) {
377   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));
378 
379   if (invalid_state(output(), THREAD)) {
380     return;
381   }
382 
383   ResourceMark rm(THREAD);
384   HandleMark hm(THREAD);
385   JNIHandleBlockManager jni_handle_management(THREAD);
386 
387   JavaValue result(T_OBJECT);
388   JfrJavaArguments constructor_args(&amp;result);
389   constructor_args.set_klass(&quot;jdk/jfr/internal/dcmd/DCmdStart&quot;, THREAD);
390   const oop dcmd = construct_dcmd_instance(&amp;constructor_args, CHECK);
391   Handle h_dcmd_instance(THREAD, dcmd);
392   assert(h_dcmd_instance.not_null(), &quot;invariant&quot;);
393 
394   jstring name = NULL;
395   if (_name.is_set() &amp;&amp; _name.value() != NULL) {
396     name = JfrJavaSupport::new_string(_name.value(), CHECK);
397   }
398 
399   jstring filename = NULL;
400   if (_filename.is_set() &amp;&amp; _filename.value() != NULL) {
401     filename = JfrJavaSupport::new_string(_filename.value(), CHECK);
402   }
403 
404   jobject maxage = NULL;
405   if (_maxage.is_set()) {
406     maxage = JfrJavaSupport::new_java_lang_Long(_maxage.value()._nanotime, CHECK);
407   }
408 
409   jobject maxsize = NULL;
410   if (_maxsize.is_set()) {
411     maxsize = JfrJavaSupport::new_java_lang_Long(_maxsize.value()._size, CHECK);
412   }
413 
<a name="5" id="anc5"></a>



414   jobject duration = NULL;
415   if (_duration.is_set()) {
416     duration = JfrJavaSupport::new_java_lang_Long(_duration.value()._nanotime, CHECK);
417   }
418 
419   jobject delay = NULL;
420   if (_delay.is_set()) {
421     delay = JfrJavaSupport::new_java_lang_Long(_delay.value()._nanotime, CHECK);
422   }
423 
424   jobject disk = NULL;
425   if (_disk.is_set()) {
426     disk = JfrJavaSupport::new_java_lang_Boolean(_disk.value(), CHECK);
427   }
428 
429   jobject dump_on_exit = NULL;
430   if (_dump_on_exit.is_set()) {
431     dump_on_exit = JfrJavaSupport::new_java_lang_Boolean(_dump_on_exit.value(), CHECK);
432   }
433 
434   jobject path_to_gc_roots = NULL;
435   if (_path_to_gc_roots.is_set()) {
436     path_to_gc_roots = JfrJavaSupport::new_java_lang_Boolean(_path_to_gc_roots.value(), CHECK);
437   }
438 
439   jobjectArray settings = NULL;
440   if (_settings.is_set()) {
<a name="6" id="anc6"></a><span class="line-modified">441     const int length = _settings.value()-&gt;array()-&gt;length();</span>






442     settings = JfrJavaSupport::new_string_array(length, CHECK);
443     assert(settings != NULL, &quot;invariant&quot;);
444     for (int i = 0; i &lt; length; ++i) {
445       jobject element = JfrJavaSupport::new_string(_settings.value()-&gt;array()-&gt;at(i), CHECK);
446       assert(element != NULL, &quot;invariant&quot;);
447       JfrJavaSupport::set_array_element(settings, element, i, CHECK);
448     }
449   } else {
450     settings = JfrJavaSupport::new_string_array(1, CHECK);
451     assert(settings != NULL, &quot;invariant&quot;);
452     jobject element = JfrJavaSupport::new_string(&quot;default&quot;, CHECK);
453     assert(element != NULL, &quot;invariant&quot;);
454     JfrJavaSupport::set_array_element(settings, element, 0, CHECK);
455   }
456 
457   static const char klass[] = &quot;jdk/jfr/internal/dcmd/DCmdStart&quot;;
458   static const char method[] = &quot;execute&quot;;
459   static const char signature[] = &quot;(Ljava/lang/String;[Ljava/lang/String;Ljava/lang/Long;&quot;
460     &quot;Ljava/lang/Long;Ljava/lang/Boolean;Ljava/lang/String;&quot;
<a name="7" id="anc7"></a><span class="line-modified">461     &quot;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Boolean;Ljava/lang/Boolean;)Ljava/lang/String;&quot;;</span>
462 
463   JfrJavaArguments execute_args(&amp;result, klass, method, signature, CHECK);
464   execute_args.set_receiver(h_dcmd_instance);
465 
466   // arguments
467   execute_args.push_jobject(name);
468   execute_args.push_jobject(settings);
469   execute_args.push_jobject(delay);
470   execute_args.push_jobject(duration);
471   execute_args.push_jobject(disk);
472   execute_args.push_jobject(filename);
473   execute_args.push_jobject(maxage);
474   execute_args.push_jobject(maxsize);
<a name="8" id="anc8"></a>
475   execute_args.push_jobject(dump_on_exit);
476   execute_args.push_jobject(path_to_gc_roots);
477 
478   JfrJavaSupport::call_virtual(&amp;execute_args, THREAD);
479   handle_dcmd_result(output(), (oop)result.get_jobject(), source, THREAD);
480 }
481 
482 JfrStopFlightRecordingDCmd::JfrStopFlightRecordingDCmd(outputStream* output,
483                                                        bool heap) : DCmdWithParser(output, heap),
484   _name(&quot;name&quot;, &quot;Recording text,.e.g \\\&quot;My Recording\\\&quot;&quot;, &quot;STRING&quot;, true, NULL),
485   _filename(&quot;filename&quot;, &quot;Copy recording data to file, e.g. \\\&quot;&quot; JFR_FILENAME_EXAMPLE &quot;\\\&quot;&quot;, &quot;STRING&quot;, false, NULL) {
486   _dcmdparser.add_dcmd_option(&amp;_name);
487   _dcmdparser.add_dcmd_option(&amp;_filename);
488 };
489 
490 int JfrStopFlightRecordingDCmd::num_arguments() {
491   ResourceMark rm;
492   JfrStopFlightRecordingDCmd* dcmd = new JfrStopFlightRecordingDCmd(NULL, false);
493   if (dcmd != NULL) {
494     DCmdMark mark(dcmd);
495     return dcmd-&gt;_dcmdparser.num_arguments();
496   }
497   return 0;
498 }
499 
500 void JfrStopFlightRecordingDCmd::execute(DCmdSource source, TRAPS) {
501   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));
502 
503   if (invalid_state(output(), THREAD) || !is_recorder_instance_created(output())) {
504     return;
505   }
506 
507   ResourceMark rm(THREAD);
508   HandleMark hm(THREAD);
509   JNIHandleBlockManager jni_handle_management(THREAD);
510 
511   JavaValue result(T_OBJECT);
512   JfrJavaArguments constructor_args(&amp;result);
513   constructor_args.set_klass(&quot;jdk/jfr/internal/dcmd/DCmdStop&quot;, CHECK);
514   const oop dcmd = construct_dcmd_instance(&amp;constructor_args, CHECK);
515   Handle h_dcmd_instance(THREAD, dcmd);
516   assert(h_dcmd_instance.not_null(), &quot;invariant&quot;);
517 
518   jstring name = NULL;
519   if (_name.is_set() &amp;&amp; _name.value()  != NULL) {
520     name = JfrJavaSupport::new_string(_name.value(), CHECK);
521   }
522 
523   jstring filepath = NULL;
524   if (_filename.is_set() &amp;&amp; _filename.value() != NULL) {
525     filepath = JfrJavaSupport::new_string(_filename.value(), CHECK);
526   }
527 
528   static const char klass[] = &quot;jdk/jfr/internal/dcmd/DCmdStop&quot;;
529   static const char method[] = &quot;execute&quot;;
530   static const char signature[] = &quot;(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;&quot;;
531 
532   JfrJavaArguments execute_args(&amp;result, klass, method, signature, CHECK);
533   execute_args.set_receiver(h_dcmd_instance);
534 
535   // arguments
536   execute_args.push_jobject(name);
537   execute_args.push_jobject(filepath);
538 
539   JfrJavaSupport::call_virtual(&amp;execute_args, THREAD);
540   handle_dcmd_result(output(), (oop)result.get_jobject(), source, THREAD);
541 }
542 
543 JfrConfigureFlightRecorderDCmd::JfrConfigureFlightRecorderDCmd(outputStream* output,
544                                                                bool heap) : DCmdWithParser(output, heap),
545   _repository_path(&quot;repositorypath&quot;, &quot;Path to repository,.e.g \\\&quot;My Repository\\\&quot;&quot;, &quot;STRING&quot;, false, NULL),
546   _dump_path(&quot;dumppath&quot;, &quot;Path to dump,.e.g \\\&quot;My Dump path\\\&quot;&quot;, &quot;STRING&quot;, false, NULL),
547   _stack_depth(&quot;stackdepth&quot;, &quot;Stack Depth&quot;, &quot;JULONG&quot;, false, &quot;64&quot;),
548   _global_buffer_count(&quot;globalbuffercount&quot;, &quot;Number of global buffers,&quot;, &quot;JULONG&quot;, false, &quot;20&quot;),
549   _global_buffer_size(&quot;globalbuffersize&quot;, &quot;Size of a global buffers,&quot;, &quot;MEMORY SIZE&quot;, false, &quot;512k&quot;),
550   _thread_buffer_size(&quot;thread_buffer_size&quot;, &quot;Size of a thread buffer&quot;, &quot;MEMORY SIZE&quot;, false, &quot;8k&quot;),
551   _memory_size(&quot;memorysize&quot;, &quot;Overall memory size, &quot;, &quot;MEMORY SIZE&quot;, false, &quot;10m&quot;),
552   _max_chunk_size(&quot;maxchunksize&quot;, &quot;Size of an individual disk chunk&quot;, &quot;MEMORY SIZE&quot;, false, &quot;12m&quot;),
553   _sample_threads(&quot;samplethreads&quot;, &quot;Activate Thread sampling&quot;, &quot;BOOLEAN&quot;, false, &quot;true&quot;) {
554   _dcmdparser.add_dcmd_option(&amp;_repository_path);
555   _dcmdparser.add_dcmd_option(&amp;_dump_path);
556   _dcmdparser.add_dcmd_option(&amp;_stack_depth);
557   _dcmdparser.add_dcmd_option(&amp;_global_buffer_count);
558   _dcmdparser.add_dcmd_option(&amp;_global_buffer_size);
559   _dcmdparser.add_dcmd_option(&amp;_thread_buffer_size);
560   _dcmdparser.add_dcmd_option(&amp;_memory_size);
561   _dcmdparser.add_dcmd_option(&amp;_max_chunk_size);
562   _dcmdparser.add_dcmd_option(&amp;_sample_threads);
563 };
564 
565 int JfrConfigureFlightRecorderDCmd::num_arguments() {
566   ResourceMark rm;
567   JfrConfigureFlightRecorderDCmd* dcmd = new JfrConfigureFlightRecorderDCmd(NULL, false);
568   if (dcmd != NULL) {
569     DCmdMark mark(dcmd);
570     return dcmd-&gt;_dcmdparser.num_arguments();
571   }
572   return 0;
573 }
574 
575 void JfrConfigureFlightRecorderDCmd::execute(DCmdSource source, TRAPS) {
576   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));
577 
578   if (invalid_state(output(), THREAD)) {
579     return;
580   }
581 
582   ResourceMark rm(THREAD);
583   HandleMark hm(THREAD);
584   JNIHandleBlockManager jni_handle_management(THREAD);
585 
586   JavaValue result(T_OBJECT);
587   JfrJavaArguments constructor_args(&amp;result);
588   constructor_args.set_klass(&quot;jdk/jfr/internal/dcmd/DCmdConfigure&quot;, CHECK);
589   const oop dcmd = construct_dcmd_instance(&amp;constructor_args, CHECK);
590   Handle h_dcmd_instance(THREAD, dcmd);
591   assert(h_dcmd_instance.not_null(), &quot;invariant&quot;);
592 
593   jstring repository_path = NULL;
594   if (_repository_path.is_set() &amp;&amp; _repository_path.value() != NULL) {
595     repository_path = JfrJavaSupport::new_string(_repository_path.value(), CHECK);
596   }
597 
598   jstring dump_path = NULL;
599   if (_dump_path.is_set() &amp;&amp; _dump_path.value() != NULL) {
600     dump_path = JfrJavaSupport::new_string(_dump_path.value(), CHECK);
601   }
602 
603   jobject stack_depth = NULL;
604   if (_stack_depth.is_set()) {
605     stack_depth = JfrJavaSupport::new_java_lang_Integer((jint)_stack_depth.value(), CHECK);
606   }
607 
608   jobject global_buffer_count = NULL;
609   if (_global_buffer_count.is_set()) {
610     global_buffer_count = JfrJavaSupport::new_java_lang_Long(_global_buffer_count.value(), CHECK);
611   }
612 
613   jobject global_buffer_size = NULL;
614   if (_global_buffer_size.is_set()) {
615     global_buffer_size = JfrJavaSupport::new_java_lang_Long(_global_buffer_size.value()._size, CHECK);
616   }
617 
618   jobject thread_buffer_size = NULL;
619   if (_thread_buffer_size.is_set()) {
620     thread_buffer_size = JfrJavaSupport::new_java_lang_Long(_thread_buffer_size.value()._size, CHECK);
621   }
622 
623   jobject max_chunk_size = NULL;
624   if (_max_chunk_size.is_set()) {
625     max_chunk_size = JfrJavaSupport::new_java_lang_Long(_max_chunk_size.value()._size, CHECK);
626   }
627 
628   jobject memory_size = NULL;
629   if (_memory_size.is_set()) {
630     memory_size = JfrJavaSupport::new_java_lang_Long(_memory_size.value()._size, CHECK);
631   }
632 
633   jobject sample_threads = NULL;
634   if (_sample_threads.is_set()) {
635     sample_threads = JfrJavaSupport::new_java_lang_Boolean(_sample_threads.value(), CHECK);
636   }
637 
638   static const char klass[] = &quot;jdk/jfr/internal/dcmd/DCmdConfigure&quot;;
639   static const char method[] = &quot;execute&quot;;
640   static const char signature[] = &quot;(Ljava/lang/String;Ljava/lang/String;Ljava/lang/Integer;&quot;
641     &quot;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Long;&quot;
642     &quot;Ljava/lang/Long;Ljava/lang/Boolean;)Ljava/lang/String;&quot;;
643 
644   JfrJavaArguments execute_args(&amp;result, klass, method, signature, CHECK);
645   execute_args.set_receiver(h_dcmd_instance);
646 
647   // params
648   execute_args.push_jobject(repository_path);
649   execute_args.push_jobject(dump_path);
650   execute_args.push_jobject(stack_depth);
651   execute_args.push_jobject(global_buffer_count);
652   execute_args.push_jobject(global_buffer_size);
653   execute_args.push_jobject(thread_buffer_size);
654   execute_args.push_jobject(memory_size);
655   execute_args.push_jobject(max_chunk_size);
656   execute_args.push_jobject(sample_threads);
657 
658   JfrJavaSupport::call_virtual(&amp;execute_args, THREAD);
659   handle_dcmd_result(output(), (oop)result.get_jobject(), source, THREAD);
660 }
661 
662 bool register_jfr_dcmds() {
663   uint32_t full_export = DCmd_Source_Internal | DCmd_Source_AttachAPI | DCmd_Source_MBean;
664   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JfrCheckFlightRecordingDCmd&gt;(full_export, true, false));
665   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JfrDumpFlightRecordingDCmd&gt;(full_export, true, false));
666   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JfrStartFlightRecordingDCmd&gt;(full_export, true, false));
667   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JfrStopFlightRecordingDCmd&gt;(full_export, true, false));
668   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JfrConfigureFlightRecorderDCmd&gt;(full_export, true, false));
669   return true;
670 }
671 
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/dcmd/jfrDcmds.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../../interpreter/templateInterpreter.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jfrDcmds.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/dcmd/jfrDcmds.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
154     print_pending_exception(output, PENDING_EXCEPTION);
155     // Don&#39;t clear excption on startup, JVM should fail initialization.
156     if (DCmd_Source_Internal != source) {
157       CLEAR_PENDING_EXCEPTION;
158     }
159     return;
160   }
161 
162   assert(!HAS_PENDING_EXCEPTION, &quot;invariant&quot;);
163 
164   if (result != NULL) {
165     const char* result_chars = java_lang_String::as_utf8_string(result);
166     print_message(output, result_chars);
167   }
168 }
169 
170 static oop construct_dcmd_instance(JfrJavaArguments* args, TRAPS) {
171   assert(args != NULL, &quot;invariant&quot;);
172   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));
173   assert(args-&gt;klass() != NULL, &quot;invariant&quot;);
<span class="line-modified">174   args-&gt;set_name(&quot;&lt;init&gt;&quot;, CHECK_NULL);</span>
<span class="line-modified">175   args-&gt;set_signature(&quot;()V&quot;, CHECK_NULL);</span>
176   JfrJavaSupport::new_object(args, CHECK_NULL);
177   return (oop)args-&gt;result()-&gt;get_jobject();
178 }
179 
180 JfrDumpFlightRecordingDCmd::JfrDumpFlightRecordingDCmd(outputStream* output,
181                                                        bool heap) : DCmdWithParser(output, heap),
182   _name(&quot;name&quot;, &quot;Recording name, e.g. \\\&quot;My Recording\\\&quot;&quot;, &quot;STRING&quot;, false, NULL),
183   _filename(&quot;filename&quot;, &quot;Copy recording data to file, e.g. \\\&quot;&quot; JFR_FILENAME_EXAMPLE &quot;\\\&quot;&quot;, &quot;STRING&quot;, false),
184   _maxage(&quot;maxage&quot;, &quot;Maximum duration to dump, in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 60m, or 0 for no limit&quot;, &quot;NANOTIME&quot;, false, &quot;0&quot;),
185   _maxsize(&quot;maxsize&quot;, &quot;Maximum amount of bytes to dump, in (M)B or (G)B, e.g. 500M, or 0 for no limit&quot;, &quot;MEMORY SIZE&quot;, false, &quot;0&quot;),
186   _begin(&quot;begin&quot;, &quot;Point in time to dump data from, e.g. 09:00, 21:35:00, 2018-06-03T18:12:56.827Z, 2018-06-03T20:13:46.832, -10m, -3h, or -1d&quot;, &quot;STRING&quot;, false),
187   _end(&quot;end&quot;, &quot;Point in time to dump data to, e.g. 09:00, 21:35:00, 2018-06-03T18:12:56.827Z, 2018-06-03T20:13:46.832, -10m, -3h, or -1d&quot;, &quot;STRING&quot;, false),
188   _path_to_gc_roots(&quot;path-to-gc-roots&quot;, &quot;Collect path to GC roots&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
189   _dcmdparser.add_dcmd_option(&amp;_name);
190   _dcmdparser.add_dcmd_option(&amp;_filename);
191   _dcmdparser.add_dcmd_option(&amp;_maxage);
192   _dcmdparser.add_dcmd_option(&amp;_maxsize);
193   _dcmdparser.add_dcmd_option(&amp;_begin);
194   _dcmdparser.add_dcmd_option(&amp;_end);
195   _dcmdparser.add_dcmd_option(&amp;_path_to_gc_roots);
</pre>
<hr />
<pre>
332   execute_args.set_receiver(h_dcmd_instance);
333 
334   // arguments
335   execute_args.push_jobject(name);
336   execute_args.push_jobject(verbose);
337 
338   JfrJavaSupport::call_virtual(&amp;execute_args, THREAD);
339   handle_dcmd_result(output(), (oop)result.get_jobject(), source, THREAD);
340 }
341 
342 JfrStartFlightRecordingDCmd::JfrStartFlightRecordingDCmd(outputStream* output,
343                                                          bool heap) : DCmdWithParser(output, heap),
344   _name(&quot;name&quot;, &quot;Name that can be used to identify recording, e.g. \\\&quot;My Recording\\\&quot;&quot;, &quot;STRING&quot;, false, NULL),
345   _settings(&quot;settings&quot;, &quot;Settings file(s), e.g. profile or default. See JRE_HOME/lib/jfr&quot;, &quot;STRING SET&quot;, false),
346   _delay(&quot;delay&quot;, &quot;Delay recording start with (s)econds, (m)inutes), (h)ours), or (d)ays, e.g. 5h.&quot;, &quot;NANOTIME&quot;, false, &quot;0&quot;),
347   _duration(&quot;duration&quot;, &quot;Duration of recording in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 300s.&quot;, &quot;NANOTIME&quot;, false, &quot;0&quot;),
348   _disk(&quot;disk&quot;, &quot;Recording should be persisted to disk&quot;, &quot;BOOLEAN&quot;, false),
349   _filename(&quot;filename&quot;, &quot;Resulting recording filename, e.g. \\\&quot;&quot; JFR_FILENAME_EXAMPLE &quot;\\\&quot;&quot;, &quot;STRING&quot;, false),
350   _maxage(&quot;maxage&quot;, &quot;Maximum time to keep recorded data (on disk) in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 60m, or 0 for no limit&quot;, &quot;NANOTIME&quot;, false, &quot;0&quot;),
351   _maxsize(&quot;maxsize&quot;, &quot;Maximum amount of bytes to keep (on disk) in (k)B, (M)B or (G)B, e.g. 500M, or 0 for no limit&quot;, &quot;MEMORY SIZE&quot;, false, &quot;0&quot;),

352   _dump_on_exit(&quot;dumponexit&quot;, &quot;Dump running recording when JVM shuts down&quot;, &quot;BOOLEAN&quot;, false),
353   _path_to_gc_roots(&quot;path-to-gc-roots&quot;, &quot;Collect path to GC roots&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
354   _dcmdparser.add_dcmd_option(&amp;_name);
355   _dcmdparser.add_dcmd_option(&amp;_settings);
356   _dcmdparser.add_dcmd_option(&amp;_delay);
357   _dcmdparser.add_dcmd_option(&amp;_duration);
358   _dcmdparser.add_dcmd_option(&amp;_disk);
359   _dcmdparser.add_dcmd_option(&amp;_filename);
360   _dcmdparser.add_dcmd_option(&amp;_maxage);
361   _dcmdparser.add_dcmd_option(&amp;_maxsize);

362   _dcmdparser.add_dcmd_option(&amp;_dump_on_exit);
363   _dcmdparser.add_dcmd_option(&amp;_path_to_gc_roots);
364 };
365 
366 int JfrStartFlightRecordingDCmd::num_arguments() {
367   ResourceMark rm;
368   JfrStartFlightRecordingDCmd* dcmd = new JfrStartFlightRecordingDCmd(NULL, false);
369   if (dcmd != NULL) {
370     DCmdMark mark(dcmd);
371     return dcmd-&gt;_dcmdparser.num_arguments();
372   }
373   return 0;
374 }
375 
376 void JfrStartFlightRecordingDCmd::execute(DCmdSource source, TRAPS) {
377   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));
378 
379   if (invalid_state(output(), THREAD)) {
380     return;
381   }
</pre>
<hr />
<pre>
394   jstring name = NULL;
395   if (_name.is_set() &amp;&amp; _name.value() != NULL) {
396     name = JfrJavaSupport::new_string(_name.value(), CHECK);
397   }
398 
399   jstring filename = NULL;
400   if (_filename.is_set() &amp;&amp; _filename.value() != NULL) {
401     filename = JfrJavaSupport::new_string(_filename.value(), CHECK);
402   }
403 
404   jobject maxage = NULL;
405   if (_maxage.is_set()) {
406     maxage = JfrJavaSupport::new_java_lang_Long(_maxage.value()._nanotime, CHECK);
407   }
408 
409   jobject maxsize = NULL;
410   if (_maxsize.is_set()) {
411     maxsize = JfrJavaSupport::new_java_lang_Long(_maxsize.value()._size, CHECK);
412   }
413 




414   jobject duration = NULL;
415   if (_duration.is_set()) {
416     duration = JfrJavaSupport::new_java_lang_Long(_duration.value()._nanotime, CHECK);
417   }
418 
419   jobject delay = NULL;
420   if (_delay.is_set()) {
421     delay = JfrJavaSupport::new_java_lang_Long(_delay.value()._nanotime, CHECK);
422   }
423 
424   jobject disk = NULL;
425   if (_disk.is_set()) {
426     disk = JfrJavaSupport::new_java_lang_Boolean(_disk.value(), CHECK);
427   }
428 
429   jobject dump_on_exit = NULL;
430   if (_dump_on_exit.is_set()) {
431     dump_on_exit = JfrJavaSupport::new_java_lang_Boolean(_dump_on_exit.value(), CHECK);
432   }
433 
434   jobject path_to_gc_roots = NULL;
435   if (_path_to_gc_roots.is_set()) {
436     path_to_gc_roots = JfrJavaSupport::new_java_lang_Boolean(_path_to_gc_roots.value(), CHECK);
437   }
438 
439   jobjectArray settings = NULL;
440   if (_settings.is_set()) {
<span class="line-modified">441     const int length = _settings.value()-&gt;array()-&gt;length();</span>






442     settings = JfrJavaSupport::new_string_array(length, CHECK);
443     assert(settings != NULL, &quot;invariant&quot;);
444     for (int i = 0; i &lt; length; ++i) {
445       jobject element = JfrJavaSupport::new_string(_settings.value()-&gt;array()-&gt;at(i), CHECK);
446       assert(element != NULL, &quot;invariant&quot;);
447       JfrJavaSupport::set_array_element(settings, element, i, CHECK);
448     }
449   } else {
450     settings = JfrJavaSupport::new_string_array(1, CHECK);
451     assert(settings != NULL, &quot;invariant&quot;);
452     jobject element = JfrJavaSupport::new_string(&quot;default&quot;, CHECK);
453     assert(element != NULL, &quot;invariant&quot;);
454     JfrJavaSupport::set_array_element(settings, element, 0, CHECK);
455   }
456 
457   static const char klass[] = &quot;jdk/jfr/internal/dcmd/DCmdStart&quot;;
458   static const char method[] = &quot;execute&quot;;
459   static const char signature[] = &quot;(Ljava/lang/String;[Ljava/lang/String;Ljava/lang/Long;&quot;
460     &quot;Ljava/lang/Long;Ljava/lang/Boolean;Ljava/lang/String;&quot;
<span class="line-modified">461     &quot;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Boolean;Ljava/lang/Boolean;)Ljava/lang/String;&quot;;</span>
462 
463   JfrJavaArguments execute_args(&amp;result, klass, method, signature, CHECK);
464   execute_args.set_receiver(h_dcmd_instance);
465 
466   // arguments
467   execute_args.push_jobject(name);
468   execute_args.push_jobject(settings);
469   execute_args.push_jobject(delay);
470   execute_args.push_jobject(duration);
471   execute_args.push_jobject(disk);
472   execute_args.push_jobject(filename);
473   execute_args.push_jobject(maxage);
474   execute_args.push_jobject(maxsize);

475   execute_args.push_jobject(dump_on_exit);
476   execute_args.push_jobject(path_to_gc_roots);
477 
478   JfrJavaSupport::call_virtual(&amp;execute_args, THREAD);
479   handle_dcmd_result(output(), (oop)result.get_jobject(), source, THREAD);
480 }
481 
482 JfrStopFlightRecordingDCmd::JfrStopFlightRecordingDCmd(outputStream* output,
483                                                        bool heap) : DCmdWithParser(output, heap),
484   _name(&quot;name&quot;, &quot;Recording text,.e.g \\\&quot;My Recording\\\&quot;&quot;, &quot;STRING&quot;, true, NULL),
485   _filename(&quot;filename&quot;, &quot;Copy recording data to file, e.g. \\\&quot;&quot; JFR_FILENAME_EXAMPLE &quot;\\\&quot;&quot;, &quot;STRING&quot;, false, NULL) {
486   _dcmdparser.add_dcmd_option(&amp;_name);
487   _dcmdparser.add_dcmd_option(&amp;_filename);
488 };
489 
490 int JfrStopFlightRecordingDCmd::num_arguments() {
491   ResourceMark rm;
492   JfrStopFlightRecordingDCmd* dcmd = new JfrStopFlightRecordingDCmd(NULL, false);
493   if (dcmd != NULL) {
494     DCmdMark mark(dcmd);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
154     print_pending_exception(output, PENDING_EXCEPTION);
155     // Don&#39;t clear excption on startup, JVM should fail initialization.
156     if (DCmd_Source_Internal != source) {
157       CLEAR_PENDING_EXCEPTION;
158     }
159     return;
160   }
161 
162   assert(!HAS_PENDING_EXCEPTION, &quot;invariant&quot;);
163 
164   if (result != NULL) {
165     const char* result_chars = java_lang_String::as_utf8_string(result);
166     print_message(output, result_chars);
167   }
168 }
169 
170 static oop construct_dcmd_instance(JfrJavaArguments* args, TRAPS) {
171   assert(args != NULL, &quot;invariant&quot;);
172   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));
173   assert(args-&gt;klass() != NULL, &quot;invariant&quot;);
<span class="line-modified">174   args-&gt;set_name(&quot;&lt;init&gt;&quot;);</span>
<span class="line-modified">175   args-&gt;set_signature(&quot;()V&quot;);</span>
176   JfrJavaSupport::new_object(args, CHECK_NULL);
177   return (oop)args-&gt;result()-&gt;get_jobject();
178 }
179 
180 JfrDumpFlightRecordingDCmd::JfrDumpFlightRecordingDCmd(outputStream* output,
181                                                        bool heap) : DCmdWithParser(output, heap),
182   _name(&quot;name&quot;, &quot;Recording name, e.g. \\\&quot;My Recording\\\&quot;&quot;, &quot;STRING&quot;, false, NULL),
183   _filename(&quot;filename&quot;, &quot;Copy recording data to file, e.g. \\\&quot;&quot; JFR_FILENAME_EXAMPLE &quot;\\\&quot;&quot;, &quot;STRING&quot;, false),
184   _maxage(&quot;maxage&quot;, &quot;Maximum duration to dump, in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 60m, or 0 for no limit&quot;, &quot;NANOTIME&quot;, false, &quot;0&quot;),
185   _maxsize(&quot;maxsize&quot;, &quot;Maximum amount of bytes to dump, in (M)B or (G)B, e.g. 500M, or 0 for no limit&quot;, &quot;MEMORY SIZE&quot;, false, &quot;0&quot;),
186   _begin(&quot;begin&quot;, &quot;Point in time to dump data from, e.g. 09:00, 21:35:00, 2018-06-03T18:12:56.827Z, 2018-06-03T20:13:46.832, -10m, -3h, or -1d&quot;, &quot;STRING&quot;, false),
187   _end(&quot;end&quot;, &quot;Point in time to dump data to, e.g. 09:00, 21:35:00, 2018-06-03T18:12:56.827Z, 2018-06-03T20:13:46.832, -10m, -3h, or -1d&quot;, &quot;STRING&quot;, false),
188   _path_to_gc_roots(&quot;path-to-gc-roots&quot;, &quot;Collect path to GC roots&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
189   _dcmdparser.add_dcmd_option(&amp;_name);
190   _dcmdparser.add_dcmd_option(&amp;_filename);
191   _dcmdparser.add_dcmd_option(&amp;_maxage);
192   _dcmdparser.add_dcmd_option(&amp;_maxsize);
193   _dcmdparser.add_dcmd_option(&amp;_begin);
194   _dcmdparser.add_dcmd_option(&amp;_end);
195   _dcmdparser.add_dcmd_option(&amp;_path_to_gc_roots);
</pre>
<hr />
<pre>
332   execute_args.set_receiver(h_dcmd_instance);
333 
334   // arguments
335   execute_args.push_jobject(name);
336   execute_args.push_jobject(verbose);
337 
338   JfrJavaSupport::call_virtual(&amp;execute_args, THREAD);
339   handle_dcmd_result(output(), (oop)result.get_jobject(), source, THREAD);
340 }
341 
342 JfrStartFlightRecordingDCmd::JfrStartFlightRecordingDCmd(outputStream* output,
343                                                          bool heap) : DCmdWithParser(output, heap),
344   _name(&quot;name&quot;, &quot;Name that can be used to identify recording, e.g. \\\&quot;My Recording\\\&quot;&quot;, &quot;STRING&quot;, false, NULL),
345   _settings(&quot;settings&quot;, &quot;Settings file(s), e.g. profile or default. See JRE_HOME/lib/jfr&quot;, &quot;STRING SET&quot;, false),
346   _delay(&quot;delay&quot;, &quot;Delay recording start with (s)econds, (m)inutes), (h)ours), or (d)ays, e.g. 5h.&quot;, &quot;NANOTIME&quot;, false, &quot;0&quot;),
347   _duration(&quot;duration&quot;, &quot;Duration of recording in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 300s.&quot;, &quot;NANOTIME&quot;, false, &quot;0&quot;),
348   _disk(&quot;disk&quot;, &quot;Recording should be persisted to disk&quot;, &quot;BOOLEAN&quot;, false),
349   _filename(&quot;filename&quot;, &quot;Resulting recording filename, e.g. \\\&quot;&quot; JFR_FILENAME_EXAMPLE &quot;\\\&quot;&quot;, &quot;STRING&quot;, false),
350   _maxage(&quot;maxage&quot;, &quot;Maximum time to keep recorded data (on disk) in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 60m, or 0 for no limit&quot;, &quot;NANOTIME&quot;, false, &quot;0&quot;),
351   _maxsize(&quot;maxsize&quot;, &quot;Maximum amount of bytes to keep (on disk) in (k)B, (M)B or (G)B, e.g. 500M, or 0 for no limit&quot;, &quot;MEMORY SIZE&quot;, false, &quot;0&quot;),
<span class="line-added">352   _flush_interval(&quot;flush-interval&quot;, &quot;Minimum time before flushing buffers, measured in (s)econds, e.g. 4 s, or 0 for flushing when a recording ends&quot;, &quot;NANOTIME&quot;, false, &quot;1s&quot;),</span>
353   _dump_on_exit(&quot;dumponexit&quot;, &quot;Dump running recording when JVM shuts down&quot;, &quot;BOOLEAN&quot;, false),
354   _path_to_gc_roots(&quot;path-to-gc-roots&quot;, &quot;Collect path to GC roots&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
355   _dcmdparser.add_dcmd_option(&amp;_name);
356   _dcmdparser.add_dcmd_option(&amp;_settings);
357   _dcmdparser.add_dcmd_option(&amp;_delay);
358   _dcmdparser.add_dcmd_option(&amp;_duration);
359   _dcmdparser.add_dcmd_option(&amp;_disk);
360   _dcmdparser.add_dcmd_option(&amp;_filename);
361   _dcmdparser.add_dcmd_option(&amp;_maxage);
362   _dcmdparser.add_dcmd_option(&amp;_maxsize);
<span class="line-added">363   _dcmdparser.add_dcmd_option(&amp;_flush_interval);</span>
364   _dcmdparser.add_dcmd_option(&amp;_dump_on_exit);
365   _dcmdparser.add_dcmd_option(&amp;_path_to_gc_roots);
366 };
367 
368 int JfrStartFlightRecordingDCmd::num_arguments() {
369   ResourceMark rm;
370   JfrStartFlightRecordingDCmd* dcmd = new JfrStartFlightRecordingDCmd(NULL, false);
371   if (dcmd != NULL) {
372     DCmdMark mark(dcmd);
373     return dcmd-&gt;_dcmdparser.num_arguments();
374   }
375   return 0;
376 }
377 
378 void JfrStartFlightRecordingDCmd::execute(DCmdSource source, TRAPS) {
379   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));
380 
381   if (invalid_state(output(), THREAD)) {
382     return;
383   }
</pre>
<hr />
<pre>
396   jstring name = NULL;
397   if (_name.is_set() &amp;&amp; _name.value() != NULL) {
398     name = JfrJavaSupport::new_string(_name.value(), CHECK);
399   }
400 
401   jstring filename = NULL;
402   if (_filename.is_set() &amp;&amp; _filename.value() != NULL) {
403     filename = JfrJavaSupport::new_string(_filename.value(), CHECK);
404   }
405 
406   jobject maxage = NULL;
407   if (_maxage.is_set()) {
408     maxage = JfrJavaSupport::new_java_lang_Long(_maxage.value()._nanotime, CHECK);
409   }
410 
411   jobject maxsize = NULL;
412   if (_maxsize.is_set()) {
413     maxsize = JfrJavaSupport::new_java_lang_Long(_maxsize.value()._size, CHECK);
414   }
415 
<span class="line-added">416   jobject flush_interval = NULL;</span>
<span class="line-added">417   if (_flush_interval.is_set()) {</span>
<span class="line-added">418     flush_interval = JfrJavaSupport::new_java_lang_Long(_flush_interval.value()._nanotime, CHECK);</span>
<span class="line-added">419   }</span>
420   jobject duration = NULL;
421   if (_duration.is_set()) {
422     duration = JfrJavaSupport::new_java_lang_Long(_duration.value()._nanotime, CHECK);
423   }
424 
425   jobject delay = NULL;
426   if (_delay.is_set()) {
427     delay = JfrJavaSupport::new_java_lang_Long(_delay.value()._nanotime, CHECK);
428   }
429 
430   jobject disk = NULL;
431   if (_disk.is_set()) {
432     disk = JfrJavaSupport::new_java_lang_Boolean(_disk.value(), CHECK);
433   }
434 
435   jobject dump_on_exit = NULL;
436   if (_dump_on_exit.is_set()) {
437     dump_on_exit = JfrJavaSupport::new_java_lang_Boolean(_dump_on_exit.value(), CHECK);
438   }
439 
440   jobject path_to_gc_roots = NULL;
441   if (_path_to_gc_roots.is_set()) {
442     path_to_gc_roots = JfrJavaSupport::new_java_lang_Boolean(_path_to_gc_roots.value(), CHECK);
443   }
444 
445   jobjectArray settings = NULL;
446   if (_settings.is_set()) {
<span class="line-modified">447     int length = _settings.value()-&gt;array()-&gt;length();</span>
<span class="line-added">448     if (length == 1) {</span>
<span class="line-added">449       const char* c_str = _settings.value()-&gt;array()-&gt;at(0);</span>
<span class="line-added">450       if (strcmp(c_str, &quot;none&quot;) == 0) {</span>
<span class="line-added">451         length = 0;</span>
<span class="line-added">452       }</span>
<span class="line-added">453     }</span>
454     settings = JfrJavaSupport::new_string_array(length, CHECK);
455     assert(settings != NULL, &quot;invariant&quot;);
456     for (int i = 0; i &lt; length; ++i) {
457       jobject element = JfrJavaSupport::new_string(_settings.value()-&gt;array()-&gt;at(i), CHECK);
458       assert(element != NULL, &quot;invariant&quot;);
459       JfrJavaSupport::set_array_element(settings, element, i, CHECK);
460     }
461   } else {
462     settings = JfrJavaSupport::new_string_array(1, CHECK);
463     assert(settings != NULL, &quot;invariant&quot;);
464     jobject element = JfrJavaSupport::new_string(&quot;default&quot;, CHECK);
465     assert(element != NULL, &quot;invariant&quot;);
466     JfrJavaSupport::set_array_element(settings, element, 0, CHECK);
467   }
468 
469   static const char klass[] = &quot;jdk/jfr/internal/dcmd/DCmdStart&quot;;
470   static const char method[] = &quot;execute&quot;;
471   static const char signature[] = &quot;(Ljava/lang/String;[Ljava/lang/String;Ljava/lang/Long;&quot;
472     &quot;Ljava/lang/Long;Ljava/lang/Boolean;Ljava/lang/String;&quot;
<span class="line-modified">473     &quot;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Boolean;Ljava/lang/Boolean;)Ljava/lang/String;&quot;;</span>
474 
475   JfrJavaArguments execute_args(&amp;result, klass, method, signature, CHECK);
476   execute_args.set_receiver(h_dcmd_instance);
477 
478   // arguments
479   execute_args.push_jobject(name);
480   execute_args.push_jobject(settings);
481   execute_args.push_jobject(delay);
482   execute_args.push_jobject(duration);
483   execute_args.push_jobject(disk);
484   execute_args.push_jobject(filename);
485   execute_args.push_jobject(maxage);
486   execute_args.push_jobject(maxsize);
<span class="line-added">487   execute_args.push_jobject(flush_interval);</span>
488   execute_args.push_jobject(dump_on_exit);
489   execute_args.push_jobject(path_to_gc_roots);
490 
491   JfrJavaSupport::call_virtual(&amp;execute_args, THREAD);
492   handle_dcmd_result(output(), (oop)result.get_jobject(), source, THREAD);
493 }
494 
495 JfrStopFlightRecordingDCmd::JfrStopFlightRecordingDCmd(outputStream* output,
496                                                        bool heap) : DCmdWithParser(output, heap),
497   _name(&quot;name&quot;, &quot;Recording text,.e.g \\\&quot;My Recording\\\&quot;&quot;, &quot;STRING&quot;, true, NULL),
498   _filename(&quot;filename&quot;, &quot;Copy recording data to file, e.g. \\\&quot;&quot; JFR_FILENAME_EXAMPLE &quot;\\\&quot;&quot;, &quot;STRING&quot;, false, NULL) {
499   _dcmdparser.add_dcmd_option(&amp;_name);
500   _dcmdparser.add_dcmd_option(&amp;_filename);
501 };
502 
503 int JfrStopFlightRecordingDCmd::num_arguments() {
504   ResourceMark rm;
505   JfrStopFlightRecordingDCmd* dcmd = new JfrStopFlightRecordingDCmd(NULL, false);
506   if (dcmd != NULL) {
507     DCmdMark mark(dcmd);
</pre>
</td>
</tr>
</table>
<center><a href="../../interpreter/templateInterpreter.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jfrDcmds.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
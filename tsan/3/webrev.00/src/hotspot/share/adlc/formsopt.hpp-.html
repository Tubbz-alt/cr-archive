<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/adlc/formsopt.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_ADLC_FORMSOPT_HPP
 26 #define SHARE_ADLC_FORMSOPT_HPP
 27 
 28 // FORMSOPT.HPP - ADL Parser Target Specific Optimization Forms Classes
 29 
 30 // Class List
 31 class Form;
 32 class InstructForm;
 33 class OperandForm;
 34 class OpClassForm;
 35 class AttributeForm;
 36 class RegisterForm;
 37 class PipelineForm;
 38 class SourceForm;
 39 class EncodeForm;
 40 class Component;
 41 class Constraint;
 42 class Predicate;
 43 class MatchRule;
 44 class Attribute;
 45 class Effect;
 46 class ExpandRule;
 47 class RewriteRule;
 48 class ConstructRule;
 49 class FormatRule;
 50 class Peephole;
 51 class PeepMatch;
 52 class PeepConstraint;
 53 class EncClass;
 54 class Interface;
 55 class RegInterface;
 56 class ConstInterface;
 57 class MemInterface;
 58 class CondInterface;
 59 class Opcode;
 60 class InsEncode;
 61 class RegDef;
 62 class RegClass;
 63 class CodeSnippetRegClass;
 64 class ConditionalRegClass;
 65 class AllocClass;
 66 class ResourceForm;
 67 class PipeClassForm;
 68 class PipeClassOperandForm;
 69 class PipeClassResourceForm;
 70 class PeepMatch;
 71 class PeepConstraint;
 72 class PeepReplace;
 73 class MatchList;
 74 
 75 class ArchDesc;
 76 
 77 //==============================Register Allocation============================
 78 //------------------------------RegisterForm-----------------------------------
 79 class RegisterForm : public Form {
 80 private:
 81   AllocClass *_current_ac;         // State used by iter_RegDefs()
 82 
 83 public:
 84   // Public Data
 85   NameList    _rdefs;              // List of register definition names
 86   Dict        _regDef;             // map register name to RegDef*
 87 
 88   NameList    _rclasses;           // List of register class names
 89   Dict        _regClass;           // map register class name to RegClass*
 90 
 91   NameList    _aclasses;           // List of allocation class names
 92   Dict        _allocClass;         // Dictionary of allocation classes
 93 
 94   static int  _reg_ctr;         // Register counter
 95   static int  RegMask_Size();   // Compute RegMask size
 96 
 97   // Public Methods
 98   RegisterForm();
 99   ~RegisterForm();
100 
101   void        addRegDef(char *regName, char *callingConv, char *c_conv,
102                         char * idealtype, char *encoding, char* concreteName);
103   template&lt;typename T&gt; T* addRegClass(const char* className);
104 
105   AllocClass *addAllocClass(char *allocName);
106   void        addSpillRegClass();
107 
108   // Provide iteration over all register definitions
109   // in the order used by the register allocator
110   void        reset_RegDefs();
111   RegDef     *iter_RegDefs();
112   RegDef     *getRegDef  (const char *regName);
113 
114   RegClass   *getRegClass(const char *className);
115 
116   // Return register mask, compressed chunk and register #
117   uint       reg_mask(char *register_class);
118 
119   // Check that register classes are compatible with chunks
120   bool       verify();
121 
122   void dump();                     // Debug printer
123   void output(FILE *fp);           // Write info to output files
124 };
125 
126 //------------------------------RegDef-----------------------------------------
127 class RegDef : public Form {
128 public:
129   // Public Data
130   const char *_regname;            // ADLC (Opto) Register name
131   const char *_callconv;           // Calling convention
132   const char *_c_conv;             // Native calling convention, &#39;C&#39;
133   const char *_idealtype;          // Ideal Type for register save/restore
134   const char *_concrete;           // concrete register name
135 
136 private:
137   const char *_register_encode;   // The register encoding
138   // The chunk and register mask bits define info for register allocation
139   uint32      _register_num;      // Which register am I
140 
141 public:
142   // Public Methods
143   RegDef(char  *regname, char *callconv, char *c_conv,
144          char *idealtype, char *encoding, char *concrete);
145   ~RegDef();                       // Destructor
146 
147   // Interface to define/redefine the register number
148   void     set_register_num(uint32 new_register_num);
149 
150   // Bit pattern used for generating machine code
151   const char *register_encode()   const;
152   // Register number used in machine-independent code
153   uint32   register_num()      const;
154 
155   void dump();                     // Debug printer
156   void output(FILE *fp);           // Write info to output files
157 };
158 
159 //------------------------------RegClass---------------------------------------
160 // Generic register class. This register class is the internal representation
161 // for the following .ad file format:
162 //
163 //  reg_class ptr(RAX, RBX, ...);
164 //
165 // where ptr is the name of the register class, RAX and RBX are registers.
166 //
167 // This register class allows registers to be spilled onto the stack. Spilling
168 // is allowed is field _stack_or_reg is true.
169 class RegClass : public Form {
170 public:
171   // Public Data
172   const char *_classid;         // Name of class
173   NameList    _regDefs;         // List of registers in class
174   Dict        _regDef;          // Dictionary of registers in class
175 protected:
176   bool        _stack_or_reg;    // Allowed on any stack slot
177 
178 public:
179   // Public Methods
180   RegClass(const char *classid);// Constructor
181   virtual ~RegClass();
182 
183   void addReg(RegDef *regDef);  // Add a register to this class
184 
185   uint size() const;            // Number of registers in class
186   int regs_in_word( int wordnum, bool stack_also );
187 
188   const RegDef *get_RegDef(const char *regDef_name) const;
189 
190   // Returns the lowest numbered register in the mask.
191   const RegDef* find_first_elem();
192 
193   // Iteration support
194   void          reset();        // Reset the following two iterators
195   RegDef       *RegDef_iter();  // which move jointly,
196   const char   *rd_name_iter(); // invoking either advances both.
197 
198   void dump();                  // Debug printer
199   void output(FILE *fp);        // Write info to output files
200 
201   virtual bool has_stack_version() {
202     return _stack_or_reg;
203   }
204   virtual void set_stack_version(bool flag) {
205     _stack_or_reg = flag;
206   }
207 
208   virtual void declare_register_masks(FILE* fp);
209   virtual void build_register_masks(FILE* fp);
210 };
211 
212 //------------------------------CodeSnippetRegClass----------------------------
213 // Register class that has an user-defined C++ code snippet attached to it
214 // to determine at runtime which register class to use. This register class is
215 // the internal representation for the following .ad file format:
216 //
217 //  reg_class actual_dflt_reg %{
218 //      if (VM_Version::has_vfp3_32()) {
219 //          return DFLT_REG_mask();
220 //      } else {
221 //          return DFLT_LOW_REG_mask();
222 //      }
223 //  %}
224 //
225 // where DFLT_REG_mask() and DFLT_LOW_REG_mask() are the internal names of the
226 // masks of register classes dflt_reg and dflt_low_reg.
227 //
228 // The attached code snippet can select also between more than two register classes.
229 // This register class can be, however, used only if the register class is not
230 // cisc-spillable (i.e., the registers of this class are not allowed on the stack,
231 // which is equivalent with _stack_or_reg being false).
232 class CodeSnippetRegClass : public RegClass {
233 protected:
234   char* _code_snippet;
235 public:
236   CodeSnippetRegClass(const char* classid);// Constructor
237   ~CodeSnippetRegClass();
238 
239   void set_code_snippet(char* code) {
240     _code_snippet = code;
241   }
242   char* code_snippet() {
243     return _code_snippet;
244   }
245   void declare_register_masks(FILE* fp);
246   void build_register_masks(FILE* fp) {
247     // We do not need to generate register masks because we select at runtime
248     // between register masks generated for other register classes.
249     return;
250   }
251 };
252 
253 //------------------------------ConditionalRegClass----------------------------
254 // Register class that has two register classes and a runtime condition attached
255 // to it. The condition is evaluated at runtime and either one of the register
256 // attached register classes is selected. This register class is the internal
257 // representation for the following .ad format:
258 //
259 //  reg_class_dynamic actual_dflt_reg(dflt_reg, low_reg,
260 //                                    %{ VM_Version::has_vfp3_32() }%
261 //                                    );
262 //
263 // This example is equivalent to the example used with the CodeSnippetRegClass
264 // register class. A ConditionalRegClass works also if a register class is cisc-spillable
265 // (i.e., _stack_or_reg is true), but if can select only between two register classes.
266 class ConditionalRegClass : public RegClass {
267 protected:
268   // reference to condition code
269   char* _condition_code;  // C++ condition code to dynamically determine which register class to use.
270 
271                           // Example syntax (equivalent to previous example):
272                           //
273                           //  reg_class actual_dflt_reg(dflt_reg, low_reg,
274                           //                            %{ VM_Version::has_vfp3_32() }%
275                           //                            );
276   // reference to conditional register classes
277   RegClass* _rclasses[2]; // 0 is the register class selected if the condition code returns true
278                           // 1 is the register class selected if the condition code returns false
279 public:
280   ConditionalRegClass(const char* classid);// Constructor
281   ~ConditionalRegClass();
282 
283   virtual void set_stack_version(bool flag) {
284     RegClass::set_stack_version(flag);
285     assert((_rclasses[0] != NULL), &quot;Register class NULL for condition code == true&quot;);
286     assert((_rclasses[1] != NULL), &quot;Register class NULL for condition code == false&quot;);
287     _rclasses[0]-&gt;set_stack_version(flag);
288     _rclasses[1]-&gt;set_stack_version(flag);
289   }
290   void declare_register_masks(FILE* fp);
291   void build_register_masks(FILE* fp) {
292     // We do not need to generate register masks because we select at runtime
293     // between register masks generated for other register classes.
294     return;
295   }
296   void set_rclass_at_index(int index, RegClass* rclass) {
297     assert((0 &lt;= index &amp;&amp; index &lt; 2), &quot;Condition code can select only between two register classes&quot;);
298     _rclasses[index] = rclass;
299   }
300   void set_condition_code(char* code) {
301     _condition_code = code;
302   }
303   char* condition_code() {
304     return _condition_code;
305   }
306 };
307 
308 //------------------------------AllocClass-------------------------------------
309 class AllocClass : public Form {
310 private:
311 
312 public:
313   // Public Data
314   char    *_classid;            // Name of class
315   NameList _regDefs;            // List of registers in class
316   Dict     _regDef;             // Dictionary of registers in class
317 
318   // Public Methods
319   AllocClass(char *classid);    // Constructor
320 
321   void addReg(RegDef *regDef);  // Add a register to this class
322   uint size() {return _regDef.Size();} // Number of registers in class
323 
324   void dump();                  // Debug printer
325   void output(FILE *fp);        // Write info to output files
326 };
327 
328 
329 //==============================Frame Handling================================
330 //------------------------------FrameForm-------------------------------------
331 class FrameForm : public Form {
332 private:
333 
334 public:
335   // Public Data
336   bool  _direction;                // Direction of stack growth
337   char *_sync_stack_slots;
338   char *_inline_cache_reg;
339   char *_interpreter_method_oop_reg;
340   char *_interpreter_frame_pointer_reg;
341   char *_cisc_spilling_operand_name;
342   char *_frame_pointer;
343   char *_c_frame_pointer;
344   char *_alignment;
345   bool  _return_addr_loc;
346   bool  _c_return_addr_loc;
347   char *_return_addr;
348   char *_c_return_addr;
349   char *_in_preserve_slots;
350   char *_varargs_C_out_slots_killed;
351   char *_calling_convention;
352   char *_c_calling_convention;
353   char *_return_value;
354   char *_c_return_value;
355 
356   // Public Methods
357   FrameForm();
358   ~FrameForm();
359 
360   void dump();                     // Debug printer
361   void output(FILE *fp);           // Write info to output files
362 };
363 
364 
365 //==============================Scheduling=====================================
366 //------------------------------PipelineForm-----------------------------------
367 class PipelineForm : public Form {
368 private:
369 
370 public:
371   // Public Data
372   NameList   _reslist;            // List of pipeline resources
373   FormDict   _resdict;            // Resource Name -&gt; ResourceForm mapping
374   int        _rescount;           // Number of resources (ignores OR cases)
375   int        _maxcycleused;       // Largest cycle used relative to beginning of instruction
376 
377   NameList   _stages;             // List of pipeline stages on architecture
378   int        _stagecnt;           // Number of stages listed
379 
380   NameList   _classlist;          // List of pipeline classes
381   FormDict   _classdict;          // Class Name -&gt; PipeClassForm mapping
382   int        _classcnt;           // Number of classes
383 
384   NameList   _noplist;            // List of NOP instructions
385   int        _nopcnt;             // Number of nop instructions
386 
387   bool       _variableSizeInstrs; // Indicates if this architecture has variable sized instructions
388   bool       _branchHasDelaySlot; // Indicates that branches have delay slot instructions
389   int        _maxInstrsPerBundle; // Indicates the maximum number of instructions for ILP
390   int        _maxBundlesPerCycle; // Indicates the maximum number of bundles for ILP
391   int        _instrUnitSize;      // The minimum instruction unit size, in bytes
392   int        _bundleUnitSize;     // The bundle unit size, in bytes
393   int        _instrFetchUnitSize; // The size of the I-fetch unit, in bytes [must be power of 2]
394   int        _instrFetchUnits;    // The number of I-fetch units processed per cycle
395 
396   // Public Methods
397   PipelineForm();
398   ~PipelineForm();
399 
400   void dump();                    // Debug printer
401   void output(FILE *fp);          // Write info to output files
402 };
403 
404 //------------------------------ResourceForm-----------------------------------
405 class ResourceForm : public Form {
406 public:
407   unsigned mask() const { return _resmask; };
408 
409 private:
410   // Public Data
411   unsigned _resmask;         // Resource Mask (OR of resource specifier bits)
412 
413 public:
414 
415   // Virtual Methods
416   virtual ResourceForm  *is_resource()    const;
417 
418   // Public Methods
419   ResourceForm(unsigned resmask); // Constructor
420   ~ResourceForm();                // Destructor
421 
422   void dump();                    // Debug printer
423   void output(FILE *fp);          // Write info to output files
424 };
425 
426 //------------------------------PipeClassOperandForm-----------------------------
427 class PipeClassOperandForm : public Form {
428 private:
429 
430 public:
431   // Public Data
432   const char *_stage;             // Name of Stage
433   unsigned _iswrite;              // Read or Write
434   unsigned _more_instrs;          // Additional Instructions
435 
436   // Public Methods
437   PipeClassOperandForm(const char *stage, unsigned iswrite, unsigned more_instrs)
438   : _stage(stage)
439   , _iswrite(iswrite)
440   , _more_instrs(more_instrs)
441  {};
442 
443   ~PipeClassOperandForm() {};     // Destructor
444 
445   bool isWrite() const { return _iswrite != 0; }
446 
447   void dump();                    // Debug printer
448   void output(FILE *fp);          // Write info to output files
449 };
450 
451 //------------------------------PipeClassResourceForm--------------------------
452 class PipeClassResourceForm : public Form {
453 private:
454 
455 public:
456   // Public Data
457   const char *_resource;          // Resource
458   const char *_stage;             // Stage the resource is used in
459   int         _cycles;            // Number of cycles the resource is used
460 
461   // Public Methods
462   PipeClassResourceForm(const char *resource, const char *stage, int cycles)
463                                   // Constructor
464     : _resource(resource)
465     , _stage(stage)
466     , _cycles(cycles)
467     {};
468 
469   ~PipeClassResourceForm() {};    // Destructor
470 
471   void dump();                    // Debug printer
472   void output(FILE *fp);          // Write info to output files
473 };
474 
475 //------------------------------PipeClassForm----------------------------------
476 class PipeClassForm : public Form {
477 private:
478 
479 public:
480 
481   // Public Data
482   const char       *_ident;             // Name of class
483   int               _num;               // Used in name of MachNode subclass
484   NameList          _parameters;        // Locally defined names
485   FormDict          _localNames;        // Table of operands &amp; their types
486   FormDict          _localUsage;        // Table of operand usage
487   FormList          _resUsage;          // List of resource usage
488   NameList          _instructs;         // List of instructions and machine nodes that use this pipeline class
489   bool              _has_fixed_latency; // Always takes this number of cycles
490   int               _fixed_latency;     // Always takes this number of cycles
491   int               _instruction_count; // Number of instructions in first bundle
492   bool              _has_multiple_bundles;  // Indicates if 1 or multiple bundles
493   bool              _has_branch_delay_slot; // Has branch delay slot as last instruction
494   bool              _force_serialization;   // This node serializes relative to surrounding nodes
495   bool              _may_have_no_code;      // This node may generate no code based on register allocation
496 
497   // Virtual Methods
498   virtual PipeClassForm  *is_pipeclass()    const;
499 
500   // Public Methods
501   PipeClassForm(const char *id, int num);
502                                   // Constructor
503   ~PipeClassForm();               // Destructor
504 
505   bool hasFixedLatency() { return _has_fixed_latency; }
506   int fixedLatency() { return _fixed_latency; }
507 
508   void setFixedLatency(int fixed_latency) { _has_fixed_latency = 1; _fixed_latency = fixed_latency; }
509 
510   void setInstructionCount(int i)    { _instruction_count = i; }
511   void setMultipleBundles(bool b)    { _has_multiple_bundles = b; }
512   void setBranchDelay(bool s)        { _has_branch_delay_slot = s; }
513   void setForceSerialization(bool s) { _force_serialization = s; }
514   void setMayHaveNoCode(bool s)      { _may_have_no_code = s; }
515 
516   int  InstructionCount()   const { return _instruction_count; }
517   bool hasMultipleBundles() const { return _has_multiple_bundles; }
518   bool hasBranchDelay()     const { return _has_branch_delay_slot; }
519   bool forceSerialization() const { return _force_serialization; }
520   bool mayHaveNoCode()      const { return _may_have_no_code; }
521 
522   void dump();                    // Debug printer
523   void output(FILE *fp);          // Write info to output files
524 };
525 
526 
527 //==============================Peephole Optimization==========================
528 //------------------------------Peephole---------------------------------------
529 class Peephole : public Form {
530 private:
531   static int      _peephole_counter;// Incremented by each peephole rule parsed
532   int             _peephole_number;// Remember my order in architecture description
533   PeepMatch      *_match;          // Instruction pattern to match
534   PeepConstraint *_constraint;     // List of additional constraints
535   PeepReplace    *_replace;        // Instruction pattern to substitute in
536 
537   Peephole *_next;
538 
539 public:
540   // Public Methods
541   Peephole();
542   ~Peephole();
543 
544   // Append a peephole rule with the same root instruction
545   void append_peephole(Peephole *next_peephole);
546 
547   // Store the components of this peephole rule
548   void add_match(PeepMatch *only_one_match);
549   void append_constraint(PeepConstraint *next_constraint);
550   void add_replace(PeepReplace *only_one_replacement);
551 
552   // Access the components of this peephole rule
553   int             peephole_number() { return _peephole_number; }
554   PeepMatch      *match()       { return _match; }
555   PeepConstraint *constraints() { return _constraint; }
556   PeepReplace    *replacement() { return _replace; }
557   Peephole       *next()        { return _next; }
558 
559   void dump();                     // Debug printer
560   void output(FILE *fp);           // Write info to output files
561 };
562 
563 
564 class PeepMatch : public Form {
565 private:
566   char *_rule;
567   // NameList  _depth;                // Depth of this instruction
568   NameList  _parent;
569   NameList  _position;
570   NameList  _instrs;               // List of instructions in match rule
571   NameList  _input;                // input position in parent&#39;s instruction
572   int       _max_position;
573 
574 public:
575   // Public Methods
576   PeepMatch(char *rule);
577   ~PeepMatch();
578 
579   // Insert info into the match-rule
580   void  add_instruction(int parent, int position, const char *name, int input);
581 
582   // Access info about instructions in the peep-match rule
583   int   max_position();
584   const char *instruction_name(int position);
585   // Iterate through all info on matched instructions
586   void  reset();
587   void  next_instruction(int &amp;parent, int &amp;position, const char* &amp;name, int &amp;input);
588   // &#39;true&#39; if current position in iteration is a placeholder, not matched.
589   bool  is_placeholder();
590 
591   void dump();
592   void output(FILE *fp);
593 };
594 
595 
596 class PeepConstraint : public Form {
597 private:
598   PeepConstraint *_next;           // Additional constraints ANDed together
599 
600 public:
601   const int   _left_inst;
602   const char* _left_op;
603   const char* _relation;
604   const int   _right_inst;
605   const char* _right_op;
606 
607 public:
608   // Public Methods
609   PeepConstraint(int left_inst,  char* left_op, char* relation,
610                  int right_inst, char* right_op);
611   ~PeepConstraint();
612 
613   // Check if constraints use instruction at position
614   bool constrains_instruction(int position);
615 
616   // Add another constraint
617   void append(PeepConstraint *next_peep_constraint);
618   // Access the next constraint in the list
619   PeepConstraint *next();
620 
621   void dump();
622   void output(FILE *fp);
623 };
624 
625 
626 class PeepReplace : public Form {
627 private:
628   char *_rule;
629   NameList _instruction;
630   NameList _operand_inst_num;
631   NameList _operand_op_name;
632 
633 public:
634 
635   // Public Methods
636   PeepReplace(char *rule);
637   ~PeepReplace();
638 
639   // Add contents of peepreplace
640   void  add_instruction(char *root);
641   void  add_operand( int inst_num, char *inst_operand );
642 
643   // Access contents of peepreplace
644   void  reset();
645   void  next_instruction(const char * &amp;root);
646   void  next_operand(int &amp;inst_num, const char * &amp;inst_operand );
647 
648   // Utilities
649   void dump();
650   void output(FILE *fp);
651 };
652 
653 
654 class PeepChild : public Form {
655 public:
656   const int   _inst_num;         // Number of instruction (-1 if only named)
657   const char *_inst_op;          // Instruction&#39;s operand, NULL if number == -1
658   const char *_inst_name;        // Name of the instruction
659 
660 public:
661   PeepChild(char *inst_name)
662     : _inst_num(-1), _inst_op(NULL), _inst_name(inst_name) {};
663   PeepChild(int inst_num, char *inst_op, char *inst_name)
664     : _inst_num(inst_num), _inst_op(inst_op), _inst_name(inst_name) {};
665   ~PeepChild();
666 
667   bool  use_leaf_operand()        { return _inst_num != -1; };
668   bool  generate_an_instruction() { return _inst_num == -1; }
669 
670   void dump();
671   void output(FILE *fp);
672 };
673 
674 #endif // SHARE_ADLC_FORMSOPT_HPP
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/adlc/formsopt.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 // FORMS.CPP - Definitions for ADL Parser Forms Classes
 26 #include &quot;adlc.hpp&quot;
 27 
 28 //==============================Register Allocation============================
 29 int RegisterForm::_reg_ctr = 0;
 30 
 31 //------------------------------RegisterForm-----------------------------------
 32 // Constructor
 33 RegisterForm::RegisterForm()
 34   : _regDef(cmpstr,hashstr, Form::arena),
 35     _regClass(cmpstr,hashstr, Form::arena),
 36     _allocClass(cmpstr,hashstr, Form::arena) {
 37 }
 38 RegisterForm::~RegisterForm() {
 39 }
 40 
 41 // record a new register definition
 42 void RegisterForm::addRegDef(char *name, char *callingConv, char *c_conv,
 43                              char *idealtype, char *encoding, char* concrete) {
 44   RegDef *regDef = new RegDef(name, callingConv, c_conv, idealtype, encoding, concrete);
 45   _rdefs.addName(name);
 46   _regDef.Insert(name,regDef);
 47 }
 48 
 49 // record a new register class
 50 template &lt;typename T&gt;
 51 T* RegisterForm::addRegClass(const char* className) {
 52   T* regClass = new T(className);
 53   _rclasses.addName(className);
 54   _regClass.Insert(className, regClass);
 55   return regClass;
 56 }
 57 
 58 // Explicit instantiation for all supported register classes.
 59 template RegClass* RegisterForm::addRegClass&lt;RegClass&gt;(const char* className);
 60 template CodeSnippetRegClass* RegisterForm::addRegClass&lt;CodeSnippetRegClass&gt;(const char* className);
 61 template ConditionalRegClass* RegisterForm::addRegClass&lt;ConditionalRegClass&gt;(const char* className);
 62 
 63 // record a new register class
 64 AllocClass *RegisterForm::addAllocClass(char *className) {
 65   AllocClass *allocClass = new AllocClass(className);
 66   _aclasses.addName(className);
 67   _allocClass.Insert(className,allocClass);
 68   return allocClass;
 69 }
 70 
 71 // Called after parsing the Register block.  Record the register class
 72 // for spill-slots/regs.
 73 void RegisterForm::addSpillRegClass() {
 74   // Stack slots start at the next available even register number.
 75   _reg_ctr = (_reg_ctr+7) &amp; ~7;
 76   const char *rc_name = &quot;stack_slots&quot;;
 77   RegClass* reg_class = new RegClass(rc_name);
 78   reg_class-&gt;set_stack_version(true);
 79   _rclasses.addName(rc_name);
 80   _regClass.Insert(rc_name,reg_class);
 81 }
 82 
<a name="1" id="anc1"></a><span class="line-added"> 83 // Called after parsing the Register block.  Record the register class</span>
<span class="line-added"> 84 // for operands which are overwritten after matching.</span>
<span class="line-added"> 85 void RegisterForm::addDynamicRegClass() {</span>
<span class="line-added"> 86   const char *rc_name = &quot;dynamic&quot;;</span>
<span class="line-added"> 87   RegClass* reg_class = new RegClass(rc_name);</span>
<span class="line-added"> 88   reg_class-&gt;set_stack_version(false);</span>
<span class="line-added"> 89   _rclasses.addName(rc_name);</span>
<span class="line-added"> 90   _regClass.Insert(rc_name,reg_class);</span>
<span class="line-added"> 91 }</span>
 92 
 93 // Provide iteration over all register definitions
 94 // in the order used by the register allocator
 95 void        RegisterForm::reset_RegDefs() {
 96   _current_ac = NULL;
 97   _aclasses.reset();
 98 }
 99 
100 RegDef     *RegisterForm::iter_RegDefs() {
101   // Check if we need to get the next AllocClass
102   if ( _current_ac == NULL ) {
103     const char *ac_name = _aclasses.iter();
104     if( ac_name == NULL )   return NULL;   // No more allocation classes
105     _current_ac = (AllocClass*)_allocClass[ac_name];
106     _current_ac-&gt;_regDefs.reset();
107     assert( _current_ac != NULL, &quot;Name must match an allocation class&quot;);
108   }
109 
110   const char *rd_name = _current_ac-&gt;_regDefs.iter();
111   if( rd_name == NULL ) {
112     // At end of this allocation class, check the next
113     _current_ac = NULL;
114     return iter_RegDefs();
115   }
116   RegDef *reg_def = (RegDef*)_current_ac-&gt;_regDef[rd_name];
117   assert( reg_def != NULL, &quot;Name must match a register definition&quot;);
118   return reg_def;
119 }
120 
121 // return the register definition with name &#39;regName&#39;
122 RegDef *RegisterForm::getRegDef(const char *regName) {
123   RegDef *regDef = (RegDef*)_regDef[regName];
124   return  regDef;
125 }
126 
127 // return the register class with name &#39;className&#39;
128 RegClass *RegisterForm::getRegClass(const char *className) {
129   RegClass *regClass = (RegClass*)_regClass[className];
130   return    regClass;
131 }
132 
133 
134 // Check that register classes are compatible with chunks
135 bool   RegisterForm::verify() {
136   bool valid = true;
137 
138   // Verify Register Classes
139   // check that each register class contains registers from one chunk
140   const char *rc_name = NULL;
141   _rclasses.reset();
142   while ( (rc_name = _rclasses.iter()) != NULL ) {
143     // Check the chunk value for all registers in this class
144     RegClass *reg_class = getRegClass(rc_name);
145     assert( reg_class != NULL, &quot;InternalError() no matching register class&quot;);
146   } // end of RegClasses
147 
148   // Verify that every register has been placed into an allocation class
149   RegDef *reg_def = NULL;
150   reset_RegDefs();
151   uint  num_register_zero = 0;
152   while ( (reg_def = iter_RegDefs()) != NULL ) {
153     if( reg_def-&gt;register_num() == 0 )  ++num_register_zero;
154   }
155   if( num_register_zero &gt; 1 ) {
156     fprintf(stderr,
157             &quot;ERROR: More than one register has been assigned register-number 0.\n&quot;
158             &quot;Probably because a register has not been entered into an allocation class.\n&quot;);
159   }
160 
161   return  valid;
162 }
163 
164 // Compute RegMask size
165 int RegisterForm::RegMask_Size() {
166   // Need at least this many words
167   int words_for_regs = (_reg_ctr + 31)&gt;&gt;5;
168   // The array of Register Mask bits should be large enough to cover
169   // all the machine registers and all parameters that need to be passed
170   // on the stack (stack registers) up to some interesting limit.  Methods
171   // that need more parameters will NOT be compiled.  On Intel, the limit
172   // is something like 90+ parameters.
173   // Add a few (3 words == 96 bits) for incoming &amp; outgoing arguments to calls.
174   // Round up to the next doubleword size.
175   return (words_for_regs + 3 + 1) &amp; ~1;
176 }
177 
178 void RegisterForm::dump() {                  // Debug printer
179   output(stderr);
180 }
181 
182 void RegisterForm::output(FILE *fp) {          // Write info to output files
183   const char *name;
184   fprintf(fp,&quot;\n&quot;);
185   fprintf(fp,&quot;-------------------- Dump RegisterForm --------------------\n&quot;);
186   for(_rdefs.reset(); (name = _rdefs.iter()) != NULL;) {
187     ((RegDef*)_regDef[name])-&gt;output(fp);
188   }
189   fprintf(fp,&quot;\n&quot;);
190   for (_rclasses.reset(); (name = _rclasses.iter()) != NULL;) {
191     ((RegClass*)_regClass[name])-&gt;output(fp);
192   }
193   fprintf(fp,&quot;\n&quot;);
194   for (_aclasses.reset(); (name = _aclasses.iter()) != NULL;) {
195     ((AllocClass*)_allocClass[name])-&gt;output(fp);
196   }
197   fprintf(fp,&quot;-------------------- end  RegisterForm --------------------\n&quot;);
198 }
199 
200 //------------------------------RegDef-----------------------------------------
201 // Constructor
202 RegDef::RegDef(char *regname, char *callconv, char *c_conv, char * idealtype, char * encode, char * concrete)
203   : _regname(regname), _callconv(callconv), _c_conv(c_conv),
204     _idealtype(idealtype),
205     _register_encode(encode),
206     _concrete(concrete),
207     _register_num(0) {
208 
209   // Chunk and register mask are determined by the register number
210   // _register_num is set when registers are added to an allocation class
211 }
212 RegDef::~RegDef() {                      // Destructor
213 }
214 
215 void RegDef::set_register_num(uint32 register_num) {
216   _register_num      = register_num;
217 }
218 
219 // Bit pattern used for generating machine code
220 const char* RegDef::register_encode() const {
221   return _register_encode;
222 }
223 
224 // Register number used in machine-independent code
225 uint32 RegDef::register_num()    const {
226   return _register_num;
227 }
228 
229 void RegDef::dump() {
230   output(stderr);
231 }
232 
233 void RegDef::output(FILE *fp) {         // Write info to output files
234   fprintf(fp,&quot;RegDef: %s (%s) encode as %s  using number %d\n&quot;,
235           _regname, (_callconv?_callconv:&quot;&quot;), _register_encode, _register_num);
236   fprintf(fp,&quot;\n&quot;);
237 }
238 
239 
240 //------------------------------RegClass---------------------------------------
241 // Construct a register class into which registers will be inserted
242 RegClass::RegClass(const char* classid) : _stack_or_reg(false), _classid(classid), _regDef(cmpstr, hashstr, Form::arena) {
243 }
244 
245 RegClass::~RegClass() {
246 }
247 
248 // record a register in this class
249 void RegClass::addReg(RegDef *regDef) {
250   _regDefs.addName(regDef-&gt;_regname);
251   _regDef.Insert((void*)regDef-&gt;_regname, regDef);
252 }
253 
254 // Number of registers in class
255 uint RegClass::size() const {
256   return _regDef.Size();
257 }
258 
259 const RegDef *RegClass::get_RegDef(const char *rd_name) const {
260   return  (const RegDef*)_regDef[rd_name];
261 }
262 
263 void RegClass::reset() {
264   _regDefs.reset();
265 }
266 
267 const char *RegClass::rd_name_iter() {
268   return _regDefs.iter();
269 }
270 
271 RegDef *RegClass::RegDef_iter() {
272   const char *rd_name  = rd_name_iter();
273   RegDef     *reg_def  = rd_name ? (RegDef*)_regDef[rd_name] : NULL;
274   return      reg_def;
275 }
276 
277 const RegDef* RegClass::find_first_elem() {
278   const RegDef* first = NULL;
279   const RegDef* def = NULL;
280 
281   reset();
282   while ((def = RegDef_iter()) != NULL) {
283     if (first == NULL || def-&gt;register_num() &lt; first-&gt;register_num()) {
284       first = def;
285     }
286   }
287 
288   assert(first != NULL, &quot;empty mask?&quot;);
289   return first;;
290 }
291 
292 // Collect all the registers in this register-word.  One bit per register.
293 int RegClass::regs_in_word( int wordnum, bool stack_also ) {
294   int         word = 0;
295   const char *name;
296   for(_regDefs.reset(); (name = _regDefs.iter()) != NULL;) {
297     int rnum = ((RegDef*)_regDef[name])-&gt;register_num();
298     if( (rnum &gt;&gt; 5) == wordnum )
299       word |= (1 &lt;&lt; (rnum &amp; 31));
300   }
301   if( stack_also ) {
302     // Now also collect stack bits
303     for( int i = 0; i &lt; 32; i++ )
304       if( wordnum*32+i &gt;= RegisterForm::_reg_ctr )
305         word |= (1 &lt;&lt; i);
306   }
307 
308   return word;
309 }
310 
311 void RegClass::dump() {
312   output(stderr);
313 }
314 
315 void RegClass::output(FILE *fp) {           // Write info to output files
316   fprintf(fp,&quot;RegClass: %s\n&quot;,_classid);
317   const char *name;
318   for(_regDefs.reset(); (name = _regDefs.iter()) != NULL;) {
319     ((RegDef*)_regDef[name])-&gt;output(fp);
320   }
321   fprintf(fp,&quot;--- done with entries for reg_class %s\n\n&quot;,_classid);
322 }
323 
324 void RegClass::declare_register_masks(FILE* fp) {
325   const char* prefix = &quot;&quot;;
326   const char* rc_name_to_upper = toUpper(_classid);
327   fprintf(fp, &quot;extern const RegMask _%s%s_mask;\n&quot;, prefix,  rc_name_to_upper);
328   fprintf(fp, &quot;inline const RegMask &amp;%s%s_mask() { return _%s%s_mask; }\n&quot;, prefix, rc_name_to_upper, prefix, rc_name_to_upper);
329   if (_stack_or_reg) {
330     fprintf(fp, &quot;extern const RegMask _%sSTACK_OR_%s_mask;\n&quot;, prefix, rc_name_to_upper);
331     fprintf(fp, &quot;inline const RegMask &amp;%sSTACK_OR_%s_mask() { return _%sSTACK_OR_%s_mask; }\n&quot;, prefix, rc_name_to_upper, prefix, rc_name_to_upper);
332   }
333   delete[] rc_name_to_upper;
334 }
335 
336 void RegClass::build_register_masks(FILE* fp) {
337   int len = RegisterForm::RegMask_Size();
338   const char *prefix = &quot;&quot;;
339   const char* rc_name_to_upper = toUpper(_classid);
340   fprintf(fp, &quot;const RegMask _%s%s_mask(&quot;, prefix, rc_name_to_upper);
341 
342   int i;
343   for(i = 0; i &lt; len - 1; i++) {
344     fprintf(fp,&quot; 0x%x,&quot;, regs_in_word(i, false));
345   }
346   fprintf(fp,&quot; 0x%x );\n&quot;, regs_in_word(i, false));
347 
348   if (_stack_or_reg) {
349     fprintf(fp, &quot;const RegMask _%sSTACK_OR_%s_mask(&quot;, prefix, rc_name_to_upper);
350     for(i = 0; i &lt; len - 1; i++) {
351       fprintf(fp,&quot; 0x%x,&quot;, regs_in_word(i, true));
352     }
353     fprintf(fp,&quot; 0x%x );\n&quot;, regs_in_word(i, true));
354   }
355   delete[] rc_name_to_upper;
356 }
357 
358 //------------------------------CodeSnippetRegClass---------------------------
359 CodeSnippetRegClass::CodeSnippetRegClass(const char* classid) : RegClass(classid), _code_snippet(NULL) {
360 }
361 
362 CodeSnippetRegClass::~CodeSnippetRegClass() {
363   delete _code_snippet;
364 }
365 
366 void CodeSnippetRegClass::declare_register_masks(FILE* fp) {
367   const char* prefix = &quot;&quot;;
368   const char* rc_name_to_upper = toUpper(_classid);
369   fprintf(fp, &quot;inline const RegMask &amp;%s%s_mask() { %s }\n&quot;, prefix, rc_name_to_upper, _code_snippet);
370   delete[] rc_name_to_upper;
371 }
372 
373 //------------------------------ConditionalRegClass---------------------------
374 ConditionalRegClass::ConditionalRegClass(const char *classid) : RegClass(classid), _condition_code(NULL) {
375 }
376 
377 ConditionalRegClass::~ConditionalRegClass() {
378   delete _condition_code;
379 }
380 
381 void ConditionalRegClass::declare_register_masks(FILE* fp) {
382   const char* prefix = &quot;&quot;;
383   const char* rc_name_to_upper = toUpper(_classid);
384   const char* rclass_0_to_upper = toUpper(_rclasses[0]-&gt;_classid);
385   const char* rclass_1_to_upper = toUpper(_rclasses[1]-&gt;_classid);
386   fprintf(fp, &quot;inline const RegMask &amp;%s%s_mask() {&quot;
387               &quot; return (%s) ?&quot;
388               &quot; %s%s_mask() :&quot;
389               &quot; %s%s_mask(); }\n&quot;,
390               prefix, rc_name_to_upper,
391               _condition_code,
392               prefix, rclass_0_to_upper,
393               prefix, rclass_1_to_upper);
394   if (_stack_or_reg) {
395     fprintf(fp, &quot;inline const RegMask &amp;%sSTACK_OR_%s_mask() {&quot;
396                   &quot; return (%s) ?&quot;
397                   &quot; %sSTACK_OR_%s_mask() :&quot;
398                   &quot; %sSTACK_OR_%s_mask(); }\n&quot;,
399                   prefix, rc_name_to_upper,
400                   _condition_code,
401                   prefix, rclass_0_to_upper,
402                   prefix, rclass_1_to_upper);
403   }
404   delete[] rc_name_to_upper;
405   delete[] rclass_0_to_upper;
406   delete[] rclass_1_to_upper;
407   return;
408 }
409 
410 //------------------------------AllocClass-------------------------------------
411 AllocClass::AllocClass(char *classid) : _classid(classid), _regDef(cmpstr,hashstr, Form::arena) {
412 }
413 
414 // record a register in this class
415 void AllocClass::addReg(RegDef *regDef) {
416   assert( regDef != NULL, &quot;Can not add a NULL to an allocation class&quot;);
417   regDef-&gt;set_register_num( RegisterForm::_reg_ctr++ );
418   // Add regDef to this allocation class
419   _regDefs.addName(regDef-&gt;_regname);
420   _regDef.Insert((void*)regDef-&gt;_regname, regDef);
421 }
422 
423 void AllocClass::dump() {
424   output(stderr);
425 }
426 
427 void AllocClass::output(FILE *fp) {       // Write info to output files
428   fprintf(fp,&quot;AllocClass: %s \n&quot;,_classid);
429   const char *name;
430   for(_regDefs.reset(); (name = _regDefs.iter()) != NULL;) {
431     ((RegDef*)_regDef[name])-&gt;output(fp);
432   }
433   fprintf(fp,&quot;--- done with entries for alloc_class %s\n\n&quot;,_classid);
434 }
435 
436 //==============================Frame Handling=================================
437 //------------------------------FrameForm--------------------------------------
438 FrameForm::FrameForm() {
439   _frame_pointer = NULL;
440   _c_frame_pointer = NULL;
441   _alignment = NULL;
442   _return_addr = NULL;
443   _c_return_addr = NULL;
444   _in_preserve_slots = NULL;
445   _varargs_C_out_slots_killed = NULL;
446   _calling_convention = NULL;
447   _c_calling_convention = NULL;
448   _return_value = NULL;
449   _c_return_value = NULL;
450   _interpreter_frame_pointer_reg = NULL;
451 }
452 
453 FrameForm::~FrameForm() {
454 }
455 
456 void FrameForm::dump() {
457   output(stderr);
458 }
459 
460 void FrameForm::output(FILE *fp) {           // Write info to output files
461   fprintf(fp,&quot;\nFrame:\n&quot;);
462 }
463 
464 //==============================Scheduling=====================================
465 //------------------------------PipelineForm-----------------------------------
466 PipelineForm::PipelineForm()
467   :  _reslist               ()
468   ,  _resdict               (cmpstr, hashstr, Form::arena)
469   ,  _classdict             (cmpstr, hashstr, Form::arena)
470   ,  _rescount              (0)
471   ,  _maxcycleused          (0)
472   ,  _stages                ()
473   ,  _stagecnt              (0)
474   ,  _classlist             ()
475   ,  _classcnt              (0)
476   ,  _noplist               ()
477   ,  _nopcnt                (0)
478   ,  _variableSizeInstrs    (false)
479   ,  _branchHasDelaySlot    (false)
480   ,  _maxInstrsPerBundle    (0)
481   ,  _maxBundlesPerCycle    (1)
482   ,  _instrUnitSize         (0)
483   ,  _bundleUnitSize        (0)
484   ,  _instrFetchUnitSize    (0)
485   ,  _instrFetchUnits       (0) {
486 }
487 PipelineForm::~PipelineForm() {
488 }
489 
490 void PipelineForm::dump() {
491   output(stderr);
492 }
493 
494 void PipelineForm::output(FILE *fp) {           // Write info to output files
495   const char *res;
496   const char *stage;
497   const char *cls;
498   const char *nop;
499   int count = 0;
500 
501   fprintf(fp,&quot;\nPipeline:&quot;);
502   if (_variableSizeInstrs)
503     if (_instrUnitSize &gt; 0)
504       fprintf(fp,&quot; variable-sized instructions in %d byte units&quot;, _instrUnitSize);
505     else
506       fprintf(fp,&quot; variable-sized instructions&quot;);
507   else
508     if (_instrUnitSize &gt; 0)
509       fprintf(fp,&quot; fixed-sized instructions of %d bytes&quot;, _instrUnitSize);
510     else if (_bundleUnitSize &gt; 0)
511       fprintf(fp,&quot; fixed-sized bundles of %d bytes&quot;, _bundleUnitSize);
512     else
513       fprintf(fp,&quot; fixed-sized instructions&quot;);
514   if (_branchHasDelaySlot)
515     fprintf(fp,&quot;, branch has delay slot&quot;);
516   if (_maxInstrsPerBundle &gt; 0)
517     fprintf(fp,&quot;, max of %d instruction%s in parallel&quot;,
518       _maxInstrsPerBundle, _maxInstrsPerBundle &gt; 1 ? &quot;s&quot; : &quot;&quot;);
519   if (_maxBundlesPerCycle &gt; 0)
520     fprintf(fp,&quot;, max of %d bundle%s in parallel&quot;,
521       _maxBundlesPerCycle, _maxBundlesPerCycle &gt; 1 ? &quot;s&quot; : &quot;&quot;);
522   if (_instrFetchUnitSize &gt; 0 &amp;&amp; _instrFetchUnits)
523     fprintf(fp, &quot;, fetch %d x % d bytes per cycle&quot;, _instrFetchUnits, _instrFetchUnitSize);
524 
525   fprintf(fp,&quot;\nResource:&quot;);
526   for ( _reslist.reset(); (res = _reslist.iter()) != NULL; )
527     fprintf(fp,&quot; %s(0x%08x)&quot;, res, _resdict[res]-&gt;is_resource()-&gt;mask());
528   fprintf(fp,&quot;\n&quot;);
529 
530   fprintf(fp,&quot;\nDescription:\n&quot;);
531   for ( _stages.reset(); (stage = _stages.iter()) != NULL; )
532     fprintf(fp,&quot; %s(%d)&quot;, stage, count++);
533   fprintf(fp,&quot;\n&quot;);
534 
535   fprintf(fp,&quot;\nClasses:\n&quot;);
536   for ( _classlist.reset(); (cls = _classlist.iter()) != NULL; )
537     _classdict[cls]-&gt;is_pipeclass()-&gt;output(fp);
538 
539   fprintf(fp,&quot;\nNop Instructions:&quot;);
540   for ( _noplist.reset(); (nop = _noplist.iter()) != NULL; )
541     fprintf(fp, &quot; \&quot;%s\&quot;&quot;, nop);
542   fprintf(fp,&quot;\n&quot;);
543 }
544 
545 
546 //------------------------------ResourceForm-----------------------------------
547 ResourceForm::ResourceForm(unsigned resmask)
548 : _resmask(resmask) {
549 }
550 ResourceForm::~ResourceForm() {
551 }
552 
553 ResourceForm  *ResourceForm::is_resource() const {
554   return (ResourceForm *)(this);
555 }
556 
557 void ResourceForm::dump() {
558   output(stderr);
559 }
560 
561 void ResourceForm::output(FILE *fp) {          // Write info to output files
562   fprintf(fp, &quot;resource: 0x%08x;\n&quot;, mask());
563 }
564 
565 
566 //------------------------------PipeClassOperandForm----------------------------------
567 
568 void PipeClassOperandForm::dump() {
569   output(stderr);
570 }
571 
572 void PipeClassOperandForm::output(FILE *fp) {         // Write info to output files
573   fprintf(stderr,&quot;PipeClassOperandForm: %s&quot;, _stage);
574   fflush(stderr);
575   if (_more_instrs &gt; 0)
576     fprintf(stderr,&quot;+%d&quot;, _more_instrs);
577   fprintf(stderr,&quot; (%s)\n&quot;, _iswrite ? &quot;write&quot; : &quot;read&quot;);
578   fflush(stderr);
579   fprintf(fp,&quot;PipeClassOperandForm: %s&quot;, _stage);
580   if (_more_instrs &gt; 0)
581     fprintf(fp,&quot;+%d&quot;, _more_instrs);
582   fprintf(fp,&quot; (%s)\n&quot;, _iswrite ? &quot;write&quot; : &quot;read&quot;);
583 }
584 
585 
586 //------------------------------PipeClassResourceForm----------------------------------
587 
588 void PipeClassResourceForm::dump() {
589   output(stderr);
590 }
591 
592 void PipeClassResourceForm::output(FILE *fp) {         // Write info to output files
593   fprintf(fp,&quot;PipeClassResourceForm: %s at stage %s for %d cycles\n&quot;,
594      _resource, _stage, _cycles);
595 }
596 
597 
598 //------------------------------PipeClassForm----------------------------------
599 PipeClassForm::PipeClassForm(const char *id, int num)
600   : _ident(id)
601   , _num(num)
602   , _localNames(cmpstr, hashstr, Form::arena)
603   , _localUsage(cmpstr, hashstr, Form::arena)
604   , _has_fixed_latency(0)
605   , _fixed_latency(0)
606   , _instruction_count(0)
607   , _has_multiple_bundles(false)
608   , _has_branch_delay_slot(false)
609   , _force_serialization(false)
610   , _may_have_no_code(false) {
611 }
612 
613 PipeClassForm::~PipeClassForm() {
614 }
615 
616 PipeClassForm  *PipeClassForm::is_pipeclass() const {
617   return (PipeClassForm *)(this);
618 }
619 
620 void PipeClassForm::dump() {
621   output(stderr);
622 }
623 
624 void PipeClassForm::output(FILE *fp) {         // Write info to output files
625   fprintf(fp,&quot;PipeClassForm: #%03d&quot;, _num);
626   if (_ident)
627      fprintf(fp,&quot; \&quot;%s\&quot;:&quot;, _ident);
628   if (_has_fixed_latency)
629      fprintf(fp,&quot; latency %d&quot;, _fixed_latency);
630   if (_force_serialization)
631      fprintf(fp, &quot;, force serialization&quot;);
632   if (_may_have_no_code)
633      fprintf(fp, &quot;, may have no code&quot;);
634   fprintf(fp, &quot;, %d instruction%s\n&quot;, InstructionCount(), InstructionCount() != 1 ? &quot;s&quot; : &quot;&quot;);
635 }
636 
637 
638 //==============================Peephole Optimization==========================
639 int Peephole::_peephole_counter = 0;
640 //------------------------------Peephole---------------------------------------
641 Peephole::Peephole() : _match(NULL), _constraint(NULL), _replace(NULL), _next(NULL) {
642   _peephole_number = _peephole_counter++;
643 }
644 Peephole::~Peephole() {
645 }
646 
647 // Append a peephole rule with the same root instruction
648 void Peephole::append_peephole(Peephole *next_peephole) {
649   if( _next == NULL ) {
650     _next = next_peephole;
651   } else {
652     _next-&gt;append_peephole( next_peephole );
653   }
654 }
655 
656 // Store the components of this peephole rule
657 void Peephole::add_match(PeepMatch *match) {
658   assert( _match == NULL, &quot;fatal()&quot; );
659   _match = match;
660 }
661 
662 void Peephole::append_constraint(PeepConstraint *next_constraint) {
663   if( _constraint == NULL ) {
664     _constraint = next_constraint;
665   } else {
666     _constraint-&gt;append( next_constraint );
667   }
668 }
669 
670 void Peephole::add_replace(PeepReplace *replace) {
671   assert( _replace == NULL, &quot;fatal()&quot; );
672   _replace = replace;
673 }
674 
675 // class Peephole accessor methods are in the declaration.
676 
677 
678 void Peephole::dump() {
679   output(stderr);
680 }
681 
682 void Peephole::output(FILE *fp) {         // Write info to output files
683   fprintf(fp,&quot;Peephole:\n&quot;);
684   if( _match != NULL )       _match-&gt;output(fp);
685   if( _constraint != NULL )  _constraint-&gt;output(fp);
686   if( _replace != NULL )     _replace-&gt;output(fp);
687   // Output the next entry
688   if( _next ) _next-&gt;output(fp);
689 }
690 
691 //------------------------------PeepMatch--------------------------------------
692 PeepMatch::PeepMatch(char *rule) : _max_position(0), _rule(rule) {
693 }
694 PeepMatch::~PeepMatch() {
695 }
696 
697 
698 // Insert info into the match-rule
699 void  PeepMatch::add_instruction(int parent, int position, const char *name,
700                                  int input) {
701   if( position &gt; _max_position ) _max_position = position;
702 
703   _parent.addName((char*) (intptr_t) parent);
704   _position.addName((char*) (intptr_t) position);
705   _instrs.addName(name);
706   _input.addName((char*) (intptr_t) input);
707 }
708 
709 // Access info about instructions in the peep-match rule
710 int   PeepMatch::max_position() {
711   return _max_position;
712 }
713 
714 const char *PeepMatch::instruction_name(int position) {
715   return _instrs.name(position);
716 }
717 
718 // Iterate through all info on matched instructions
719 void  PeepMatch::reset() {
720   _parent.reset();
721   _position.reset();
722   _instrs.reset();
723   _input.reset();
724 }
725 
726 void  PeepMatch::next_instruction(int &amp;parent, int &amp;position, const char* &amp;name, int &amp;input) {
727   parent   = (int) (intptr_t) _parent.iter();
728   position = (int) (intptr_t) _position.iter();
729   name     = _instrs.iter();
730   input    = (int) (intptr_t) _input.iter();
731 }
732 
733 // &#39;true&#39; if current position in iteration is a placeholder, not matched.
734 bool  PeepMatch::is_placeholder() {
735   return _instrs.current_is_signal();
736 }
737 
738 
739 void PeepMatch::dump() {
740   output(stderr);
741 }
742 
743 void PeepMatch::output(FILE *fp) {        // Write info to output files
744   fprintf(fp,&quot;PeepMatch:\n&quot;);
745 }
746 
747 //------------------------------PeepConstraint---------------------------------
748 PeepConstraint::PeepConstraint(int left_inst,  char* left_op, char* relation,
749                                int right_inst, char* right_op)
750   : _left_inst(left_inst), _left_op(left_op), _relation(relation),
751     _right_inst(right_inst), _right_op(right_op), _next(NULL) {}
752 PeepConstraint::~PeepConstraint() {
753 }
754 
755 // Check if constraints use instruction at position
756 bool PeepConstraint::constrains_instruction(int position) {
757   // Check local instruction constraints
758   if( _left_inst  == position ) return true;
759   if( _right_inst == position ) return true;
760 
761   // Check remaining constraints in list
762   if( _next == NULL )  return false;
763   else                 return _next-&gt;constrains_instruction(position);
764 }
765 
766 // Add another constraint
767 void PeepConstraint::append(PeepConstraint *next_constraint) {
768   if( _next == NULL ) {
769     _next = next_constraint;
770   } else {
771     _next-&gt;append( next_constraint );
772   }
773 }
774 
775 // Access the next constraint in the list
776 PeepConstraint *PeepConstraint::next() {
777   return _next;
778 }
779 
780 
781 void PeepConstraint::dump() {
782   output(stderr);
783 }
784 
785 void PeepConstraint::output(FILE *fp) {   // Write info to output files
786   fprintf(fp,&quot;PeepConstraint:\n&quot;);
787 }
788 
789 //------------------------------PeepReplace------------------------------------
790 PeepReplace::PeepReplace(char *rule) : _rule(rule) {
791 }
792 PeepReplace::~PeepReplace() {
793 }
794 
795 // Add contents of peepreplace
796 void  PeepReplace::add_instruction(char *root) {
797   _instruction.addName(root);
798   _operand_inst_num.add_signal();
799   _operand_op_name.add_signal();
800 }
801 void  PeepReplace::add_operand( int inst_num, char *inst_operand ) {
802   _instruction.add_signal();
803   _operand_inst_num.addName((char*) (intptr_t) inst_num);
804   _operand_op_name.addName(inst_operand);
805 }
806 
807 // Access contents of peepreplace
808 void  PeepReplace::reset() {
809   _instruction.reset();
810   _operand_inst_num.reset();
811   _operand_op_name.reset();
812 }
813 void  PeepReplace::next_instruction(const char* &amp;inst){
814   inst                     = _instruction.iter();
815   int         inst_num     = (int) (intptr_t) _operand_inst_num.iter();
816   const char* inst_operand = _operand_op_name.iter();
817 }
818 void  PeepReplace::next_operand(int &amp;inst_num, const char* &amp;inst_operand) {
819   const char* inst = _instruction.iter();
820   inst_num         = (int) (intptr_t) _operand_inst_num.iter();
821   inst_operand     = _operand_op_name.iter();
822 }
823 
824 
825 
826 void PeepReplace::dump() {
827   output(stderr);
828 }
829 
830 void PeepReplace::output(FILE *fp) {      // Write info to output files
831   fprintf(fp,&quot;PeepReplace:\n&quot;);
832 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
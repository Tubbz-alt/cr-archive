<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/adlc/archDesc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 //
   2 // Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
   3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4 //
   5 // This code is free software; you can redistribute it and/or modify it
   6 // under the terms of the GNU General Public License version 2 only, as
   7 // published by the Free Software Foundation.
   8 //
   9 // This code is distributed in the hope that it will be useful, but WITHOUT
  10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12 // version 2 for more details (a copy is included in the LICENSE file that
  13 // accompanied this code).
  14 //
  15 // You should have received a copy of the GNU General Public License version
  16 // 2 along with this work; if not, write to the Free Software Foundation,
  17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18 //
  19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20 // or visit www.oracle.com if you need additional information or have any
  21 // questions.
  22 //
  23 //
  24 
  25 
  26 // archDesc.cpp - Internal format for architecture definition
  27 #include &quot;adlc.hpp&quot;
  28 
  29 static FILE *errfile = stderr;
  30 
  31 //--------------------------- utility functions -----------------------------
  32 inline char toUpper(char lower) {
  33   return ((&#39;a&#39; &lt;= lower &amp;&amp; lower &lt;= &#39;z&#39;) ? ((char) (lower + (&#39;A&#39;-&#39;a&#39;))) : lower);
  34 }
  35 char *toUpper(const char *str) {
  36   char *upper  = new char[strlen(str)+1];
  37   char *result = upper;
  38   const char *end    = str + strlen(str);
  39   for (; str &lt; end; ++str, ++upper) {
  40     *upper = toUpper(*str);
  41   }
  42   *upper = &#39;\0&#39;;
  43   return result;
  44 }
  45 
  46 //---------------------------ChainList Methods-------------------------------
  47 ChainList::ChainList() {
  48 }
  49 
  50 void ChainList::insert(const char *name, const char *cost, const char *rule) {
  51   _name.addName(name);
  52   _cost.addName(cost);
  53   _rule.addName(rule);
  54 }
  55 
  56 bool ChainList::search(const char *name) {
  57   return _name.search(name);
  58 }
  59 
  60 void ChainList::reset() {
  61   _name.reset();
  62   _cost.reset();
  63   _rule.reset();
  64 }
  65 
  66 bool ChainList::iter(const char * &amp;name, const char * &amp;cost, const char * &amp;rule) {
  67   bool        notDone = false;
  68   const char *n       = _name.iter();
  69   const char *c       = _cost.iter();
  70   const char *r       = _rule.iter();
  71 
  72   if (n &amp;&amp; c &amp;&amp; r) {
  73     notDone = true;
  74     name = n;
  75     cost = c;
  76     rule = r;
  77   }
  78 
  79   return notDone;
  80 }
  81 
  82 void ChainList::dump() {
  83   output(stderr);
  84 }
  85 
  86 void ChainList::output(FILE *fp) {
  87   fprintf(fp, &quot;\nChain Rules: output resets iterator\n&quot;);
  88   const char   *cost  = NULL;
  89   const char   *name  = NULL;
  90   const char   *rule  = NULL;
  91   bool   chains_exist = false;
  92   for(reset(); (iter(name,cost,rule)) == true; ) {
  93     fprintf(fp, &quot;Chain to &lt;%s&gt; at cost #%s using %s_rule\n&quot;,name, cost ? cost : &quot;0&quot;, rule);
  94     //  // Check for transitive chain rules
  95     //  Form *form = (Form *)_globalNames[rule];
  96     //  if (form-&gt;is_instruction()) {
  97     //    // chain_rule(fp, indent, name, cost, rule);
  98     //    chain_rule(fp, indent, name, cost, rule);
  99     //  }
 100   }
 101   reset();
 102   if( ! chains_exist ) {
 103     fprintf(fp, &quot;No entries in this ChainList\n&quot;);
 104   }
 105 }
 106 
 107 
 108 //---------------------------MatchList Methods-------------------------------
 109 bool MatchList::search(const char *opc, const char *res, const char *lch,
 110                        const char *rch, Predicate *pr) {
 111   bool tmp = false;
 112   if ((res == _resultStr) || (res &amp;&amp; _resultStr &amp;&amp; !strcmp(res, _resultStr))) {
 113     if ((lch == _lchild) || (lch &amp;&amp; _lchild &amp;&amp; !strcmp(lch, _lchild))) {
 114       if ((rch == _rchild) || (rch &amp;&amp; _rchild &amp;&amp; !strcmp(rch, _rchild))) {
 115         char * predStr = get_pred();
 116         char * prStr = pr?pr-&gt;_pred:NULL;
 117         if (ADLParser::equivalent_expressions(prStr, predStr)) {
 118           return true;
 119         }
 120       }
 121     }
 122   }
 123   if (_next) {
 124     tmp = _next-&gt;search(opc, res, lch, rch, pr);
 125   }
 126   return tmp;
 127 }
 128 
 129 
 130 void MatchList::dump() {
 131   output(stderr);
 132 }
 133 
 134 void MatchList::output(FILE *fp) {
 135   fprintf(fp, &quot;\nMatchList output is Unimplemented();\n&quot;);
 136 }
 137 
 138 
 139 //---------------------------ArchDesc Constructor and Destructor-------------
 140 
 141 ArchDesc::ArchDesc()
 142   : _globalNames(cmpstr,hashstr, Form::arena),
 143     _globalDefs(cmpstr,hashstr, Form::arena),
 144     _preproc_table(cmpstr,hashstr, Form::arena),
 145     _idealIndex(cmpstr,hashstr, Form::arena),
 146     _internalOps(cmpstr,hashstr, Form::arena),
 147     _internalMatch(cmpstr,hashstr, Form::arena),
 148     _chainRules(cmpstr,hashstr, Form::arena),
 149     _cisc_spill_operand(NULL),
 150     _needs_clone_jvms(false) {
 151 
 152       // Initialize the opcode to MatchList table with NULLs
 153       for( int i=0; i&lt;_last_opcode; ++i ) {
 154         _mlistab[i] = NULL;
 155       }
 156 
 157       // Set-up the global tables
 158       initKeywords(_globalNames);    // Initialize the Name Table with keywords
 159 
 160       // Prime user-defined types with predefined types: Set, RegI, RegF, ...
 161       initBaseOpTypes();
 162 
 163       // Initialize flags &amp; counters
 164       _TotalLines        = 0;
 165       _no_output         = 0;
 166       _quiet_mode        = 0;
 167       _disable_warnings  = 0;
 168       _dfa_debug         = 0;
 169       _dfa_small         = 0;
 170       _adl_debug         = 0;
 171       _adlocation_debug  = 0;
 172       _internalOpCounter = 0;
 173       _cisc_spill_debug  = false;
 174       _short_branch_debug = false;
 175 
 176       // Initialize match rule flags
 177       for (int i = 0; i &lt; _last_opcode; i++) {
 178         _has_match_rule[i] = false;
 179       }
 180 
 181       // Error/Warning Counts
 182       _syntax_errs       = 0;
 183       _semantic_errs     = 0;
 184       _warnings          = 0;
 185       _internal_errs     = 0;
 186 
 187       // Initialize I/O Files
 188       _ADL_file._name = NULL; _ADL_file._fp = NULL;
 189       // Machine dependent output files
 190       _DFA_file._name    = NULL;  _DFA_file._fp = NULL;
 191       _HPP_file._name    = NULL;  _HPP_file._fp = NULL;
 192       _CPP_file._name    = NULL;  _CPP_file._fp = NULL;
 193       _bug_file._name    = &quot;bugs.out&quot;;      _bug_file._fp = NULL;
 194 
 195       // Initialize Register &amp; Pipeline Form Pointers
 196       _register = NULL;
 197       _encode = NULL;
 198       _pipeline = NULL;
 199       _frame = NULL;
 200 }
 201 
 202 ArchDesc::~ArchDesc() {
 203   // Clean-up and quit
 204 
 205 }
 206 
 207 //---------------------------ArchDesc methods: Public ----------------------
 208 // Store forms according to type
 209 void ArchDesc::addForm(PreHeaderForm *ptr) { _pre_header.addForm(ptr); };
 210 void ArchDesc::addForm(HeaderForm    *ptr) { _header.addForm(ptr); };
 211 void ArchDesc::addForm(SourceForm    *ptr) { _source.addForm(ptr); };
 212 void ArchDesc::addForm(EncodeForm    *ptr) { _encode = ptr; };
 213 void ArchDesc::addForm(InstructForm  *ptr) { _instructions.addForm(ptr); };
 214 void ArchDesc::addForm(MachNodeForm  *ptr) { _machnodes.addForm(ptr); };
 215 void ArchDesc::addForm(OperandForm   *ptr) { _operands.addForm(ptr); };
 216 void ArchDesc::addForm(OpClassForm   *ptr) { _opclass.addForm(ptr); };
 217 void ArchDesc::addForm(AttributeForm *ptr) { _attributes.addForm(ptr); };
 218 void ArchDesc::addForm(RegisterForm  *ptr) { _register = ptr; };
 219 void ArchDesc::addForm(FrameForm     *ptr) { _frame = ptr; };
 220 void ArchDesc::addForm(PipelineForm  *ptr) { _pipeline = ptr; };
 221 
 222 // Build MatchList array and construct MatchLists
 223 void ArchDesc::generateMatchLists() {
 224   // Call inspection routines to populate array
 225   inspectOperands();
 226   inspectInstructions();
 227 }
 228 
 229 // Build MatchList structures for operands
 230 void ArchDesc::inspectOperands() {
 231 
 232   // Iterate through all operands
 233   _operands.reset();
 234   OperandForm *op;
 235   for( ; (op = (OperandForm*)_operands.iter()) != NULL;) {
 236     // Construct list of top-level operands (components)
 237     op-&gt;build_components();
 238 
 239     // Ensure that match field is defined.
 240     if ( op-&gt;_matrule == NULL )  continue;
 241 
 242     // Type check match rules
 243     check_optype(op-&gt;_matrule);
 244 
 245     // Construct chain rules
 246     build_chain_rule(op);
 247 
 248     MatchRule *mrule = op-&gt;_matrule;
 249     Predicate *pred  = op-&gt;_predicate;
 250 
 251     // Grab the machine type of the operand
 252     const char  *rootOp    = op-&gt;_ident;
 253     mrule-&gt;_machType  = rootOp;
 254 
 255     // Check for special cases
 256     if (strcmp(rootOp,&quot;Universe&quot;)==0) continue;
 257     if (strcmp(rootOp,&quot;label&quot;)==0) continue;
 258     // !!!!! !!!!!
 259     assert( strcmp(rootOp,&quot;sReg&quot;) != 0, &quot;Disable untyped &#39;sReg&#39;&quot;);
 260     if (strcmp(rootOp,&quot;sRegI&quot;)==0) continue;
 261     if (strcmp(rootOp,&quot;sRegP&quot;)==0) continue;
 262     if (strcmp(rootOp,&quot;sRegF&quot;)==0) continue;
 263     if (strcmp(rootOp,&quot;sRegD&quot;)==0) continue;
 264     if (strcmp(rootOp,&quot;sRegL&quot;)==0) continue;
 265 
 266     // Cost for this match
 267     const char *costStr     = op-&gt;cost();
 268     const char *defaultCost =
 269       ((AttributeForm*)_globalNames[AttributeForm::_op_cost])-&gt;_attrdef;
 270     const char *cost        =  costStr? costStr : defaultCost;
 271 
 272     // Find result type for match.
 273     const char *result      = op-&gt;reduce_result();
 274 
 275     // Construct a MatchList for this entry.
 276     // Iterate over the list to enumerate all match cases for operands with multiple match rules.
 277     for (; mrule != NULL; mrule = mrule-&gt;_next) {
 278       mrule-&gt;_machType = rootOp;
 279       buildMatchList(mrule, result, rootOp, pred, cost);
 280     }
 281   }
 282 }
 283 
 284 // Build MatchList structures for instructions
 285 void ArchDesc::inspectInstructions() {
 286 
 287   // Iterate through all instructions
 288   _instructions.reset();
 289   InstructForm *instr;
 290   for( ; (instr = (InstructForm*)_instructions.iter()) != NULL; ) {
 291     // Construct list of top-level operands (components)
 292     instr-&gt;build_components();
 293 
 294     // Ensure that match field is defined.
 295     if ( instr-&gt;_matrule == NULL )  continue;
 296 
 297     MatchRule &amp;mrule = *instr-&gt;_matrule;
 298     Predicate *pred  =  instr-&gt;build_predicate();
 299 
 300     // Grab the machine type of the operand
 301     const char  *rootOp    = instr-&gt;_ident;
 302     mrule._machType  = rootOp;
 303 
 304     // Cost for this match
 305     const char *costStr = instr-&gt;cost();
 306     const char *defaultCost =
 307       ((AttributeForm*)_globalNames[AttributeForm::_ins_cost])-&gt;_attrdef;
 308     const char *cost    =  costStr? costStr : defaultCost;
 309 
 310     // Find result type for match
 311     const char *result  = instr-&gt;reduce_result();
 312 
 313     if (( instr-&gt;is_ideal_branch() &amp;&amp; instr-&gt;label_position() == -1) ||
 314         (!instr-&gt;is_ideal_branch() &amp;&amp; instr-&gt;label_position() != -1)) {
 315       syntax_err(instr-&gt;_linenum, &quot;%s: Only branches to a label are supported\n&quot;, rootOp);
 316     }
 317 
 318     Attribute *attr = instr-&gt;_attribs;
 319     while (attr != NULL) {
 320       if (strcmp(attr-&gt;_ident,&quot;ins_short_branch&quot;) == 0 &amp;&amp;
 321           attr-&gt;int_val(*this) != 0) {
 322         if (!instr-&gt;is_ideal_branch() || instr-&gt;label_position() == -1) {
 323           syntax_err(instr-&gt;_linenum, &quot;%s: Only short branch to a label is supported\n&quot;, rootOp);
 324         }
 325         instr-&gt;set_short_branch(true);
 326       } else if (strcmp(attr-&gt;_ident,&quot;ins_alignment&quot;) == 0 &amp;&amp;
 327           attr-&gt;int_val(*this) != 0) {
 328         instr-&gt;set_alignment(attr-&gt;int_val(*this));
 329       }
 330       attr = (Attribute *)attr-&gt;_next;
 331     }
 332 
 333     if (!instr-&gt;is_short_branch()) {
 334       buildMatchList(instr-&gt;_matrule, result, mrule._machType, pred, cost);
 335     }
 336   }
 337 }
 338 
 339 static int setsResult(MatchRule &amp;mrule) {
 340   if (strcmp(mrule._name,&quot;Set&quot;) == 0) return 1;
 341   return 0;
 342 }
 343 
 344 const char *ArchDesc::getMatchListIndex(MatchRule &amp;mrule) {
 345   if (setsResult(mrule)) {
 346     // right child
 347     return mrule._rChild-&gt;_opType;
 348   } else {
 349     // first entry
 350     return mrule._opType;
 351   }
 352 }
 353 
 354 
 355 //------------------------------result of reduction----------------------------
 356 
 357 
 358 //------------------------------left reduction---------------------------------
 359 // Return the left reduction associated with an internal name
 360 const char *ArchDesc::reduceLeft(char         *internalName) {
 361   const char *left  = NULL;
 362   MatchNode *mnode = (MatchNode*)_internalMatch[internalName];
 363   if (mnode-&gt;_lChild) {
 364     mnode = mnode-&gt;_lChild;
 365     left = mnode-&gt;_internalop ? mnode-&gt;_internalop : mnode-&gt;_opType;
 366   }
 367   return left;
 368 }
 369 
 370 
 371 //------------------------------right reduction--------------------------------
 372 const char *ArchDesc::reduceRight(char  *internalName) {
 373   const char *right  = NULL;
 374   MatchNode *mnode = (MatchNode*)_internalMatch[internalName];
 375   if (mnode-&gt;_rChild) {
 376     mnode = mnode-&gt;_rChild;
 377     right = mnode-&gt;_internalop ? mnode-&gt;_internalop : mnode-&gt;_opType;
 378   }
 379   return right;
 380 }
 381 
 382 
 383 //------------------------------check_optype-----------------------------------
 384 void ArchDesc::check_optype(MatchRule *mrule) {
 385   MatchRule *rule = mrule;
 386 
 387   //   !!!!!
 388   //   // Cycle through the list of match rules
 389   //   while(mrule) {
 390   //     // Check for a filled in type field
 391   //     if (mrule-&gt;_opType == NULL) {
 392   //     const Form  *form    = operands[_result];
 393   //     OpClassForm *opcForm = form ? form-&gt;is_opclass() : NULL;
 394   //     assert(opcForm != NULL, &quot;Match Rule contains invalid operand name.&quot;);
 395   //     }
 396   //     char *opType = opcForm-&gt;_ident;
 397   //   }
 398 }
 399 
 400 //------------------------------add_chain_rule_entry--------------------------
 401 void ArchDesc::add_chain_rule_entry(const char *src, const char *cost,
 402                                     const char *result) {
 403   // Look-up the operation in chain rule table
 404   ChainList *lst = (ChainList *)_chainRules[src];
 405   if (lst == NULL) {
 406     lst = new ChainList();
 407     _chainRules.Insert(src, lst);
 408   }
 409   if (!lst-&gt;search(result)) {
 410     if (cost == NULL) {
 411       cost = ((AttributeForm*)_globalNames[AttributeForm::_op_cost])-&gt;_attrdef;
 412     }
 413     lst-&gt;insert(result, cost, result);
 414   }
 415 }
 416 
 417 //------------------------------build_chain_rule-------------------------------
 418 void ArchDesc::build_chain_rule(OperandForm *oper) {
 419   MatchRule     *rule;
 420 
 421   // Check for chain rules here
 422   // If this is only a chain rule
 423   if ((oper-&gt;_matrule) &amp;&amp; (oper-&gt;_matrule-&gt;_lChild == NULL) &amp;&amp;
 424       (oper-&gt;_matrule-&gt;_rChild == NULL)) {
 425 
 426     {
 427       const Form *form = _globalNames[oper-&gt;_matrule-&gt;_opType];
 428       if ((form) &amp;&amp; form-&gt;is_operand() &amp;&amp;
 429           (form-&gt;ideal_only() == false)) {
 430         add_chain_rule_entry(oper-&gt;_matrule-&gt;_opType, oper-&gt;cost(), oper-&gt;_ident);
 431       }
 432     }
 433     // Check for additional chain rules
 434     if (oper-&gt;_matrule-&gt;_next) {
 435       rule = oper-&gt;_matrule;
 436       do {
 437         rule = rule-&gt;_next;
 438         // Any extra match rules after the first must be chain rules
 439         const Form *form = _globalNames[rule-&gt;_opType];
 440         if ((form) &amp;&amp; form-&gt;is_operand() &amp;&amp;
 441             (form-&gt;ideal_only() == false)) {
 442           add_chain_rule_entry(rule-&gt;_opType, oper-&gt;cost(), oper-&gt;_ident);
 443         }
 444       } while(rule-&gt;_next != NULL);
 445     }
 446   }
 447   else if ((oper-&gt;_matrule) &amp;&amp; (oper-&gt;_matrule-&gt;_next)) {
 448     // Regardles of whether the first matchrule is a chain rule, check the list
 449     rule = oper-&gt;_matrule;
 450     do {
 451       rule = rule-&gt;_next;
 452       // Any extra match rules after the first must be chain rules
 453       const Form *form = _globalNames[rule-&gt;_opType];
 454       if ((form) &amp;&amp; form-&gt;is_operand() &amp;&amp;
 455           (form-&gt;ideal_only() == false)) {
 456         assert( oper-&gt;cost(), &quot;This case expects NULL cost, not default cost&quot;);
 457         add_chain_rule_entry(rule-&gt;_opType, oper-&gt;cost(), oper-&gt;_ident);
 458       }
 459     } while(rule-&gt;_next != NULL);
 460   }
 461 
 462 }
 463 
 464 //------------------------------buildMatchList---------------------------------
 465 // operands and instructions provide the result
 466 void ArchDesc::buildMatchList(MatchRule *mrule, const char *resultStr,
 467                               const char *rootOp, Predicate *pred,
 468                               const char *cost) {
 469   const char *leftstr, *rightstr;
 470   MatchNode  *mnode;
 471 
 472   leftstr = rightstr = NULL;
 473   // Check for chain rule, and do not generate a match list for it
 474   if ( mrule-&gt;is_chain_rule(_globalNames) ) {
 475     return;
 476   }
 477 
 478   // Identify index position among ideal operands
 479   intptr_t    index     = _last_opcode;
 480   const char  *indexStr  = getMatchListIndex(*mrule);
 481   index  = (intptr_t)_idealIndex[indexStr];
 482   if (index == 0) {
 483     fprintf(stderr, &quot;Ideal node missing: %s\n&quot;, indexStr);
 484     assert(index != 0, &quot;Failed lookup of ideal node\n&quot;);
 485   }
 486 
 487   // Check that this will be placed appropriately in the DFA
 488   if (index &gt;= _last_opcode) {
 489     fprintf(stderr, &quot;Invalid match rule %s &lt;-- ( %s )\n&quot;,
 490             resultStr ? resultStr : &quot; &quot;,
 491             rootOp    ? rootOp    : &quot; &quot;);
 492     assert(index &lt; _last_opcode, &quot;Matching item not in ideal graph\n&quot;);
 493     return;
 494   }
 495 
 496 
 497   // Walk the MatchRule, generating MatchList entries for each level
 498   // of the rule (each nesting of parentheses)
 499   // Check for &quot;Set&quot;
 500   if (!strcmp(mrule-&gt;_opType, &quot;Set&quot;)) {
 501     mnode = mrule-&gt;_rChild;
 502     buildMList(mnode, rootOp, resultStr, pred, cost);
 503     return;
 504   }
 505   // Build MatchLists for children
 506   // Check each child for an internal operand name, and use that name
 507   // for the parent&#39;s matchlist entry if it exists
 508   mnode = mrule-&gt;_lChild;
 509   if (mnode) {
 510     buildMList(mnode, NULL, NULL, NULL, NULL);
 511     leftstr = mnode-&gt;_internalop ? mnode-&gt;_internalop : mnode-&gt;_opType;
 512   }
 513   mnode = mrule-&gt;_rChild;
 514   if (mnode) {
 515     buildMList(mnode, NULL, NULL, NULL, NULL);
 516     rightstr = mnode-&gt;_internalop ? mnode-&gt;_internalop : mnode-&gt;_opType;
 517   }
 518   // Search for an identical matchlist entry already on the list
 519   if ((_mlistab[index] == NULL) ||
 520       (_mlistab[index] &amp;&amp;
 521        !_mlistab[index]-&gt;search(rootOp, resultStr, leftstr, rightstr, pred))) {
 522     // Place this match rule at front of list
 523     MatchList *mList =
 524       new MatchList(_mlistab[index], pred, cost,
 525                     rootOp, resultStr, leftstr, rightstr);
 526     _mlistab[index] = mList;
 527   }
 528 }
 529 
 530 // Recursive call for construction of match lists
 531 void ArchDesc::buildMList(MatchNode *node, const char *rootOp,
 532                           const char *resultOp, Predicate *pred,
 533                           const char *cost) {
 534   const char *leftstr, *rightstr;
 535   const char *resultop;
 536   const char *opcode;
 537   MatchNode  *mnode;
 538   Form       *form;
 539 
 540   leftstr = rightstr = NULL;
 541   // Do not process leaves of the Match Tree if they are not ideal
 542   if ((node) &amp;&amp; (node-&gt;_lChild == NULL) &amp;&amp; (node-&gt;_rChild == NULL) &amp;&amp;
 543       ((form = (Form *)_globalNames[node-&gt;_opType]) != NULL) &amp;&amp;
 544       (!form-&gt;ideal_only())) {
 545     return;
 546   }
 547 
 548   // Identify index position among ideal operands
 549   intptr_t index = _last_opcode;
 550   const char *indexStr = node ? node-&gt;_opType : (char *) &quot; &quot;;
 551   index = (intptr_t)_idealIndex[indexStr];
 552   if (index == 0) {
 553     fprintf(stderr, &quot;error: operand \&quot;%s\&quot; not found\n&quot;, indexStr);
 554     assert(0, &quot;fatal error&quot;);
 555   }
 556 
 557   if (node == NULL) {
 558     fprintf(stderr, &quot;error: node is NULL\n&quot;);
 559     assert(0, &quot;fatal error&quot;);
 560   }
 561   // Build MatchLists for children
 562   // Check each child for an internal operand name, and use that name
 563   // for the parent&#39;s matchlist entry if it exists
 564   mnode = node-&gt;_lChild;
 565   if (mnode) {
 566     buildMList(mnode, NULL, NULL, NULL, NULL);
 567     leftstr = mnode-&gt;_internalop ? mnode-&gt;_internalop : mnode-&gt;_opType;
 568   }
 569   mnode = node-&gt;_rChild;
 570   if (mnode) {
 571     buildMList(mnode, NULL, NULL, NULL, NULL);
 572     rightstr = mnode-&gt;_internalop ? mnode-&gt;_internalop : mnode-&gt;_opType;
 573   }
 574   // Grab the string for the opcode of this list entry
 575   if (rootOp == NULL) {
 576     opcode = (node-&gt;_internalop) ? node-&gt;_internalop : node-&gt;_opType;
 577   } else {
 578     opcode = rootOp;
 579   }
 580   // Grab the string for the result of this list entry
 581   if (resultOp == NULL) {
 582     resultop = (node-&gt;_internalop) ? node-&gt;_internalop : node-&gt;_opType;
 583   }
 584   else resultop = resultOp;
 585   // Search for an identical matchlist entry already on the list
 586   if ((_mlistab[index] == NULL) || (_mlistab[index] &amp;&amp;
 587                                     !_mlistab[index]-&gt;search(opcode, resultop, leftstr, rightstr, pred))) {
 588     // Place this match rule at front of list
 589     MatchList *mList =
 590       new MatchList(_mlistab[index],pred,cost,
 591                     opcode, resultop, leftstr, rightstr);
 592     _mlistab[index] = mList;
 593   }
 594 }
 595 
 596 // Count number of OperandForms defined
 597 int  ArchDesc::operandFormCount() {
 598   // Only interested in ones with non-NULL match rule
 599   int  count = 0; _operands.reset();
 600   OperandForm *cur;
 601   for( ; (cur = (OperandForm*)_operands.iter()) != NULL; ) {
 602     if (cur-&gt;_matrule != NULL) ++count;
 603   };
 604   return count;
 605 }
 606 
 607 // Count number of OpClassForms defined
 608 int  ArchDesc::opclassFormCount() {
 609   // Only interested in ones with non-NULL match rule
 610   int  count = 0; _operands.reset();
 611   OpClassForm *cur;
 612   for( ; (cur = (OpClassForm*)_opclass.iter()) != NULL; ) {
 613     ++count;
 614   };
 615   return count;
 616 }
 617 
 618 // Count number of InstructForms defined
 619 int  ArchDesc::instructFormCount() {
 620   // Only interested in ones with non-NULL match rule
 621   int  count = 0; _instructions.reset();
 622   InstructForm *cur;
 623   for( ; (cur = (InstructForm*)_instructions.iter()) != NULL; ) {
 624     if (cur-&gt;_matrule != NULL) ++count;
 625   };
 626   return count;
 627 }
 628 
 629 
 630 //------------------------------get_preproc_def--------------------------------
 631 // Return the textual binding for a given CPP flag name.
 632 // Return NULL if there is no binding, or it has been #undef-ed.
 633 char* ArchDesc::get_preproc_def(const char* flag) {
 634   // In case of syntax errors, flag may take the value NULL.
 635   SourceForm* deff = NULL;
 636   if (flag != NULL)
 637     deff = (SourceForm*) _preproc_table[flag];
 638   return (deff == NULL) ? NULL : deff-&gt;_code;
 639 }
 640 
 641 
 642 //------------------------------set_preproc_def--------------------------------
 643 // Change or create a textual binding for a given CPP flag name.
 644 // Giving NULL means the flag name is to be #undef-ed.
 645 // In any case, _preproc_list collects all names either #defined or #undef-ed.
 646 void ArchDesc::set_preproc_def(const char* flag, const char* def) {
 647   SourceForm* deff = (SourceForm*) _preproc_table[flag];
 648   if (deff == NULL) {
 649     deff = new SourceForm(NULL);
 650     _preproc_table.Insert(flag, deff);
 651     _preproc_list.addName(flag);   // this supports iteration
 652   }
 653   deff-&gt;_code = (char*) def;
 654 }
 655 
 656 
 657 bool ArchDesc::verify() {
 658 
 659   if (_register)
 660     assert( _register-&gt;verify(), &quot;Register declarations failed verification&quot;);
 661   if (!_quiet_mode)
 662     fprintf(stderr,&quot;\n&quot;);
 663   // fprintf(stderr,&quot;---------------------------- Verify Operands ---------------\n&quot;);
 664   // _operands.verify();
 665   // fprintf(stderr,&quot;\n&quot;);
 666   // fprintf(stderr,&quot;---------------------------- Verify Operand Classes --------\n&quot;);
 667   // _opclass.verify();
 668   // fprintf(stderr,&quot;\n&quot;);
 669   // fprintf(stderr,&quot;---------------------------- Verify Attributes  ------------\n&quot;);
 670   // _attributes.verify();
 671   // fprintf(stderr,&quot;\n&quot;);
 672   if (!_quiet_mode)
 673     fprintf(stderr,&quot;---------------------------- Verify Instructions ----------------------------\n&quot;);
 674   _instructions.verify();
 675   if (!_quiet_mode)
 676     fprintf(stderr,&quot;\n&quot;);
 677   // if ( _encode ) {
 678   //   fprintf(stderr,&quot;---------------------------- Verify Encodings --------------\n&quot;);
 679   //   _encode-&gt;verify();
 680   // }
 681 
 682   //if (_pipeline) _pipeline-&gt;verify();
 683 
 684   return true;
 685 }
 686 
 687 
 688 void ArchDesc::dump() {
 689   _pre_header.dump();
 690   _header.dump();
 691   _source.dump();
 692   if (_register) _register-&gt;dump();
 693   fprintf(stderr,&quot;\n&quot;);
 694   fprintf(stderr,&quot;------------------ Dump Operands ---------------------\n&quot;);
 695   _operands.dump();
 696   fprintf(stderr,&quot;\n&quot;);
 697   fprintf(stderr,&quot;------------------ Dump Operand Classes --------------\n&quot;);
 698   _opclass.dump();
 699   fprintf(stderr,&quot;\n&quot;);
 700   fprintf(stderr,&quot;------------------ Dump Attributes  ------------------\n&quot;);
 701   _attributes.dump();
 702   fprintf(stderr,&quot;\n&quot;);
 703   fprintf(stderr,&quot;------------------ Dump Instructions -----------------\n&quot;);
 704   _instructions.dump();
 705   if ( _encode ) {
 706     fprintf(stderr,&quot;------------------ Dump Encodings --------------------\n&quot;);
 707     _encode-&gt;dump();
 708   }
 709   if (_pipeline) _pipeline-&gt;dump();
 710 }
 711 
 712 
 713 //------------------------------init_keywords----------------------------------
 714 // Load the kewords into the global name table
 715 void ArchDesc::initKeywords(FormDict&amp; names) {
 716   // Insert keyword strings into Global Name Table.  Keywords have a NULL value
 717   // field for quick easy identification when checking identifiers.
 718   names.Insert(&quot;instruct&quot;, NULL);
 719   names.Insert(&quot;operand&quot;, NULL);
 720   names.Insert(&quot;attribute&quot;, NULL);
 721   names.Insert(&quot;source&quot;, NULL);
 722   names.Insert(&quot;register&quot;, NULL);
 723   names.Insert(&quot;pipeline&quot;, NULL);
 724   names.Insert(&quot;constraint&quot;, NULL);
 725   names.Insert(&quot;predicate&quot;, NULL);
 726   names.Insert(&quot;encode&quot;, NULL);
 727   names.Insert(&quot;enc_class&quot;, NULL);
 728   names.Insert(&quot;interface&quot;, NULL);
 729   names.Insert(&quot;opcode&quot;, NULL);
 730   names.Insert(&quot;ins_encode&quot;, NULL);
 731   names.Insert(&quot;match&quot;, NULL);
 732   names.Insert(&quot;effect&quot;, NULL);
 733   names.Insert(&quot;expand&quot;, NULL);
 734   names.Insert(&quot;rewrite&quot;, NULL);
 735   names.Insert(&quot;reg_def&quot;, NULL);
 736   names.Insert(&quot;reg_class&quot;, NULL);
 737   names.Insert(&quot;alloc_class&quot;, NULL);
 738   names.Insert(&quot;resource&quot;, NULL);
 739   names.Insert(&quot;pipe_class&quot;, NULL);
 740   names.Insert(&quot;pipe_desc&quot;, NULL);
 741 }
 742 
 743 
 744 //------------------------------internal_err----------------------------------
 745 // Issue a parser error message, and skip to the end of the current line
 746 void ArchDesc::internal_err(const char *fmt, ...) {
 747   va_list args;
 748 
 749   va_start(args, fmt);
 750   _internal_errs += emit_msg(0, INTERNAL_ERR, 0, fmt, args);
 751   va_end(args);
 752 
 753   _no_output = 1;
 754 }
 755 
 756 //------------------------------syntax_err----------------------------------
 757 // Issue a parser error message, and skip to the end of the current line
 758 void ArchDesc::syntax_err(int lineno, const char *fmt, ...) {
 759   va_list args;
 760 
 761   va_start(args, fmt);
 762   _internal_errs += emit_msg(0, SYNERR, lineno, fmt, args);
 763   va_end(args);
 764 
 765   _no_output = 1;
 766 }
 767 
 768 //------------------------------emit_msg---------------------------------------
 769 // Emit a user message, typically a warning or error
 770 int ArchDesc::emit_msg(int quiet, int flag, int line, const char *fmt,
 771     va_list args) {
 772   static int  last_lineno = -1;
 773   int         i;
 774   const char *pref;
 775 
 776   switch(flag) {
 777   case 0: pref = &quot;Warning: &quot;; break;
 778   case 1: pref = &quot;Syntax Error: &quot;; break;
 779   case 2: pref = &quot;Semantic Error: &quot;; break;
 780   case 3: pref = &quot;Internal Error: &quot;; break;
 781   default: assert(0, &quot;&quot;); break;
 782   }
 783 
 784   if (line == last_lineno) return 0;
 785   last_lineno = line;
 786 
 787   if (!quiet) {                        /* no output if in quiet mode         */
 788     i = fprintf(errfile, &quot;%s(%d) &quot;, _ADL_file._name, line);
 789     while (i++ &lt;= 15)  fputc(&#39; &#39;, errfile);
 790     fprintf(errfile, &quot;%-8s:&quot;, pref);
 791     vfprintf(errfile, fmt, args);
 792     fprintf(errfile, &quot;\n&quot;);
 793     fflush(errfile);
 794   }
 795   return 1;
 796 }
 797 
 798 
 799 // ---------------------------------------------------------------------------
 800 //--------Utilities to build mappings for machine registers ------------------
 801 // ---------------------------------------------------------------------------
 802 
 803 // Construct the name of the register mask.
 804 static const char *getRegMask(const char *reg_class_name) {
 805   if( reg_class_name == NULL ) return &quot;RegMask::Empty&quot;;
 806 
 807   if (strcmp(reg_class_name,&quot;Universe&quot;)==0) {
 808     return &quot;RegMask::Empty&quot;;
 809   } else if (strcmp(reg_class_name,&quot;stack_slots&quot;)==0) {
 810     return &quot;(Compile::current()-&gt;FIRST_STACK_mask())&quot;;
 811   } else if (strcmp(reg_class_name, &quot;dynamic&quot;)==0) {
 812     return &quot;*_opnds[0]-&gt;in_RegMask(0)&quot;;
 813   } else {
 814     char       *rc_name = toUpper(reg_class_name);
 815     const char *mask    = &quot;_mask&quot;;
 816     int         length  = (int)strlen(rc_name) + (int)strlen(mask) + 5;
 817     char       *regMask = new char[length];
 818     sprintf(regMask,&quot;%s%s()&quot;, rc_name, mask);
 819     delete[] rc_name;
 820     return regMask;
 821   }
 822 }
 823 
 824 // Convert a register class name to its register mask.
 825 const char *ArchDesc::reg_class_to_reg_mask(const char *rc_name) {
 826   const char *reg_mask = &quot;RegMask::Empty&quot;;
 827 
 828   if( _register ) {
 829     RegClass *reg_class  = _register-&gt;getRegClass(rc_name);
 830     if (reg_class == NULL) {
 831       syntax_err(0, &quot;Use of an undefined register class %s&quot;, rc_name);
 832       return reg_mask;
 833     }
 834 
 835     // Construct the name of the register mask.
 836     reg_mask = getRegMask(rc_name);
 837   }
 838 
 839   return reg_mask;
 840 }
 841 
 842 
 843 // Obtain the name of the RegMask for an OperandForm
 844 const char *ArchDesc::reg_mask(OperandForm  &amp;opForm) {
 845   const char *regMask      = &quot;RegMask::Empty&quot;;
 846 
 847   // Check constraints on result&#39;s register class
 848   const char *result_class = opForm.constrained_reg_class();
 849   if (result_class == NULL) {
 850     opForm.dump();
 851     syntax_err(opForm._linenum,
 852                &quot;Use of an undefined result class for operand: %s&quot;,
 853                opForm._ident);
 854     abort();
 855   }
 856 
 857   regMask = reg_class_to_reg_mask( result_class );
 858 
 859   return regMask;
 860 }
 861 
 862 // Obtain the name of the RegMask for an InstructForm
 863 const char *ArchDesc::reg_mask(InstructForm &amp;inForm) {
 864   const char *result = inForm.reduce_result();
 865 
 866   if (result == NULL) {
 867     syntax_err(inForm._linenum,
 868                &quot;Did not find result operand or RegMask&quot;
 869                &quot; for this instruction: %s&quot;,
 870                inForm._ident);
 871     abort();
 872   }
 873 
 874   // Instructions producing &#39;Universe&#39; use RegMask::Empty
 875   if (strcmp(result,&quot;Universe&quot;) == 0) {
 876     return &quot;RegMask::Empty&quot;;
 877   }
 878 
 879   // Lookup this result operand and get its register class
 880   Form *form = (Form*)_globalNames[result];
 881   if (form == NULL) {
 882     syntax_err(inForm._linenum,
 883                &quot;Did not find result operand for result: %s&quot;, result);
 884     abort();
 885   }
 886   OperandForm *oper = form-&gt;is_operand();
 887   if (oper == NULL) {
 888     syntax_err(inForm._linenum, &quot;Form is not an OperandForm:&quot;);
 889     form-&gt;dump();
 890     abort();
 891   }
 892   return reg_mask( *oper );
 893 }
 894 
 895 
 896 // Obtain the STACK_OR_reg_mask name for an OperandForm
 897 char *ArchDesc::stack_or_reg_mask(OperandForm  &amp;opForm) {
 898   // name of cisc_spillable version
 899   const char *reg_mask_name = reg_mask(opForm);
 900 
 901   if (reg_mask_name == NULL) {
 902      syntax_err(opForm._linenum,
 903                 &quot;Did not find reg_mask for opForm: %s&quot;,
 904                 opForm._ident);
 905      abort();
 906   }
 907 
 908   const char *stack_or = &quot;STACK_OR_&quot;;
 909   int   length         = (int)strlen(stack_or) + (int)strlen(reg_mask_name) + 1;
 910   char *result         = new char[length];
 911   sprintf(result,&quot;%s%s&quot;, stack_or, reg_mask_name);
 912 
 913   return result;
 914 }
 915 
 916 // Record that the register class must generate a stack_or_reg_mask
 917 void ArchDesc::set_stack_or_reg(const char *reg_class_name) {
 918   if( _register ) {
 919     RegClass *reg_class  = _register-&gt;getRegClass(reg_class_name);
 920     reg_class-&gt;set_stack_version(true);
 921   }
 922 }
 923 
 924 
 925 // Return the type signature for the ideal operation
 926 const char *ArchDesc::getIdealType(const char *idealOp) {
 927   // Find last character in idealOp, it specifies the type
 928   char  last_char = 0;
 929   const char *ptr = idealOp;
 930   for (; *ptr != &#39;\0&#39;; ++ptr) {
 931     last_char = *ptr;
 932   }
 933 
 934   // Match Vector types.
 935   if (strncmp(idealOp, &quot;Vec&quot;,3)==0) {
 936     switch(last_char) {
 937     case &#39;S&#39;:  return &quot;TypeVect::VECTS&quot;;
 938     case &#39;D&#39;:  return &quot;TypeVect::VECTD&quot;;
 939     case &#39;X&#39;:  return &quot;TypeVect::VECTX&quot;;
 940     case &#39;Y&#39;:  return &quot;TypeVect::VECTY&quot;;
 941     case &#39;Z&#39;:  return &quot;TypeVect::VECTZ&quot;;
 942     default:
 943       internal_err(&quot;Vector type %s with unrecognized type\n&quot;,idealOp);
 944     }
 945   }
 946 
 947   // !!!!!
 948   switch(last_char) {
 949   case &#39;I&#39;:    return &quot;TypeInt::INT&quot;;
 950   case &#39;P&#39;:    return &quot;TypePtr::BOTTOM&quot;;
 951   case &#39;N&#39;:    return &quot;TypeNarrowOop::BOTTOM&quot;;
 952   case &#39;F&#39;:    return &quot;Type::FLOAT&quot;;
 953   case &#39;D&#39;:    return &quot;Type::DOUBLE&quot;;
 954   case &#39;L&#39;:    return &quot;TypeLong::LONG&quot;;
 955   case &#39;s&#39;:    return &quot;TypeInt::CC /*flags*/&quot;;
 956   default:
 957     return NULL;
 958     // !!!!!
 959     // internal_err(&quot;Ideal type %s with unrecognized type\n&quot;,idealOp);
 960     break;
 961   }
 962 
 963   return NULL;
 964 }
 965 
 966 
 967 
 968 OperandForm *ArchDesc::constructOperand(const char *ident,
 969                                         bool  ideal_only) {
 970   OperandForm *opForm = new OperandForm(ident, ideal_only);
 971   _globalNames.Insert(ident, opForm);
 972   addForm(opForm);
 973 
 974   return opForm;
 975 }
 976 
 977 
 978 // Import predefined base types: Set = 1, RegI, RegP, ...
 979 void ArchDesc::initBaseOpTypes() {
 980   // Create OperandForm and assign type for each opcode.
 981   for (int i = 1; i &lt; _last_machine_leaf; ++i) {
 982     char *ident = (char *)NodeClassNames[i];
 983     constructOperand(ident, true);
 984   }
 985   // Create InstructForm and assign type for each ideal instruction.
 986   for (int j = _last_machine_leaf+1; j &lt; _last_opcode; ++j) {
 987     char *ident = (char *)NodeClassNames[j];
 988     if (!strcmp(ident, &quot;ConI&quot;) || !strcmp(ident, &quot;ConP&quot;) ||
 989         !strcmp(ident, &quot;ConN&quot;) || !strcmp(ident, &quot;ConNKlass&quot;) ||
 990         !strcmp(ident, &quot;ConF&quot;) || !strcmp(ident, &quot;ConD&quot;) ||
 991         !strcmp(ident, &quot;ConL&quot;) || !strcmp(ident, &quot;Con&quot; ) ||
 992         !strcmp(ident, &quot;Bool&quot;)) {
 993       constructOperand(ident, true);
 994     } else {
 995       InstructForm *insForm = new InstructForm(ident, true);
 996       // insForm-&gt;_opcode = nextUserOpType(ident);
 997       _globalNames.Insert(ident, insForm);
 998       addForm(insForm);
 999     }
1000   }
1001 
1002   { OperandForm *opForm;
1003   // Create operand type &quot;Universe&quot; for return instructions.
1004   const char *ident = &quot;Universe&quot;;
1005   opForm = constructOperand(ident, false);
1006 
1007   // Create operand type &quot;label&quot; for branch targets
1008   ident = &quot;label&quot;;
1009   opForm = constructOperand(ident, false);
1010 
1011   // !!!!! Update - when adding a new sReg/stackSlot type
1012   // Create operand types &quot;sReg[IPFDL]&quot; for stack slot registers
1013   opForm = constructOperand(&quot;sRegI&quot;, false);
1014   opForm-&gt;_constraint = new Constraint(&quot;ALLOC_IN_RC&quot;, &quot;stack_slots&quot;);
1015   opForm = constructOperand(&quot;sRegP&quot;, false);
1016   opForm-&gt;_constraint = new Constraint(&quot;ALLOC_IN_RC&quot;, &quot;stack_slots&quot;);
1017   opForm = constructOperand(&quot;sRegF&quot;, false);
1018   opForm-&gt;_constraint = new Constraint(&quot;ALLOC_IN_RC&quot;, &quot;stack_slots&quot;);
1019   opForm = constructOperand(&quot;sRegD&quot;, false);
1020   opForm-&gt;_constraint = new Constraint(&quot;ALLOC_IN_RC&quot;, &quot;stack_slots&quot;);
1021   opForm = constructOperand(&quot;sRegL&quot;, false);
1022   opForm-&gt;_constraint = new Constraint(&quot;ALLOC_IN_RC&quot;, &quot;stack_slots&quot;);
1023 
1024   // Create operand type &quot;method&quot; for call targets
1025   ident = &quot;method&quot;;
1026   opForm = constructOperand(ident, false);
1027   }
1028 
1029   // Create Effect Forms for each of the legal effects
1030   // USE, DEF, USE_DEF, KILL, USE_KILL
1031   {
1032     const char *ident = &quot;USE&quot;;
1033     Effect     *eForm = new Effect(ident);
1034     _globalNames.Insert(ident, eForm);
1035     ident = &quot;DEF&quot;;
1036     eForm = new Effect(ident);
1037     _globalNames.Insert(ident, eForm);
1038     ident = &quot;USE_DEF&quot;;
1039     eForm = new Effect(ident);
1040     _globalNames.Insert(ident, eForm);
1041     ident = &quot;KILL&quot;;
1042     eForm = new Effect(ident);
1043     _globalNames.Insert(ident, eForm);
1044     ident = &quot;USE_KILL&quot;;
1045     eForm = new Effect(ident);
1046     _globalNames.Insert(ident, eForm);
1047     ident = &quot;TEMP&quot;;
1048     eForm = new Effect(ident);
1049     _globalNames.Insert(ident, eForm);
1050     ident = &quot;TEMP_DEF&quot;;
1051     eForm = new Effect(ident);
1052     _globalNames.Insert(ident, eForm);
1053     ident = &quot;CALL&quot;;
1054     eForm = new Effect(ident);
1055     _globalNames.Insert(ident, eForm);
1056   }
1057 
1058   //
1059   // Build mapping from ideal names to ideal indices
1060   int idealIndex = 0;
1061   for (idealIndex = 1; idealIndex &lt; _last_machine_leaf; ++idealIndex) {
1062     const char *idealName = NodeClassNames[idealIndex];
1063     _idealIndex.Insert((void*) idealName, (void*) (intptr_t) idealIndex);
1064   }
1065   for (idealIndex = _last_machine_leaf+1;
1066        idealIndex &lt; _last_opcode; ++idealIndex) {
1067     const char *idealName = NodeClassNames[idealIndex];
1068     _idealIndex.Insert((void*) idealName, (void*) (intptr_t) idealIndex);
1069   }
1070 
1071 }
1072 
1073 
1074 //---------------------------addSUNcopyright-------------------------------
1075 // output SUN copyright info
1076 void ArchDesc::addSunCopyright(char* legal, int size, FILE *fp) {
1077   size_t count = fwrite(legal, 1, size, fp);
1078   assert(count == (size_t) size, &quot;copyright info truncated&quot;);
1079   fprintf(fp,&quot;\n&quot;);
1080   fprintf(fp,&quot;// Machine Generated File.  Do Not Edit!\n&quot;);
1081   fprintf(fp,&quot;\n&quot;);
1082 }
1083 
1084 
1085 //---------------------------addIncludeGuardStart--------------------------
1086 // output the start of an include guard.
1087 void ArchDesc::addIncludeGuardStart(ADLFILE &amp;adlfile, const char* guardString) {
1088   // Build #include lines
1089   fprintf(adlfile._fp, &quot;\n&quot;);
1090   fprintf(adlfile._fp, &quot;#ifndef %s\n&quot;, guardString);
1091   fprintf(adlfile._fp, &quot;#define %s\n&quot;, guardString);
1092   fprintf(adlfile._fp, &quot;\n&quot;);
1093 
1094 }
1095 
1096 //---------------------------addIncludeGuardEnd--------------------------
1097 // output the end of an include guard.
1098 void ArchDesc::addIncludeGuardEnd(ADLFILE &amp;adlfile, const char* guardString) {
1099   // Build #include lines
1100   fprintf(adlfile._fp, &quot;\n&quot;);
1101   fprintf(adlfile._fp, &quot;#endif // %s\n&quot;, guardString);
1102 
1103 }
1104 
1105 //---------------------------addInclude--------------------------
1106 // output the #include line for this file.
1107 void ArchDesc::addInclude(ADLFILE &amp;adlfile, const char* fileName) {
1108   fprintf(adlfile._fp, &quot;#include \&quot;%s\&quot;\n&quot;, fileName);
1109 
1110 }
1111 
1112 void ArchDesc::addInclude(ADLFILE &amp;adlfile, const char* includeDir, const char* fileName) {
1113   fprintf(adlfile._fp, &quot;#include \&quot;%s/%s\&quot;\n&quot;, includeDir, fileName);
1114 
1115 }
1116 
1117 //---------------------------addPreprocessorChecks-----------------------------
1118 // Output C preprocessor code to verify the backend compilation environment.
1119 // The idea is to force code produced by &quot;adlc -DHS64&quot; to be compiled by a
1120 // command of the form &quot;CC ... -DHS64 ...&quot;, so that any #ifdefs in the source
1121 // blocks select C code that is consistent with adlc&#39;s selections of AD code.
1122 void ArchDesc::addPreprocessorChecks(FILE *fp) {
1123   const char* flag;
1124   _preproc_list.reset();
1125   if (_preproc_list.count() &gt; 0 &amp;&amp; !_preproc_list.current_is_signal()) {
1126     fprintf(fp, &quot;// Check consistency of C++ compilation with ADLC options:\n&quot;);
1127   }
1128   for (_preproc_list.reset(); (flag = _preproc_list.iter()) != NULL; ) {
1129     if (_preproc_list.current_is_signal())  break;
1130     char* def = get_preproc_def(flag);
1131     fprintf(fp, &quot;// Check adlc &quot;);
1132     if (def)
1133           fprintf(fp, &quot;-D%s=%s\n&quot;, flag, def);
1134     else  fprintf(fp, &quot;-U%s\n&quot;, flag);
1135     fprintf(fp, &quot;#%s %s\n&quot;,
1136             def ? &quot;ifndef&quot; : &quot;ifdef&quot;, flag);
1137     fprintf(fp, &quot;#  error \&quot;%s %s be defined\&quot;\n&quot;,
1138             flag, def ? &quot;must&quot; : &quot;must not&quot;);
1139     fprintf(fp, &quot;#endif // %s\n&quot;, flag);
1140   }
1141 }
1142 
1143 
1144 // Convert operand name into enum name
1145 const char *ArchDesc::machOperEnum(const char *opName) {
1146   return ArchDesc::getMachOperEnum(opName);
1147 }
1148 
1149 // Convert operand name into enum name
1150 const char *ArchDesc::getMachOperEnum(const char *opName) {
1151   return (opName ? toUpper(opName) : opName);
1152 }
1153 
1154 //---------------------------buildMustCloneMap-----------------------------
1155 // Flag cases when machine needs cloned values or instructions
1156 void ArchDesc::buildMustCloneMap(FILE *fp_hpp, FILE *fp_cpp) {
1157   // Build external declarations for mappings
1158   fprintf(fp_hpp, &quot;// Mapping from machine-independent opcode to boolean\n&quot;);
1159   fprintf(fp_hpp, &quot;// Flag cases where machine needs cloned values or instructions\n&quot;);
1160   fprintf(fp_hpp, &quot;extern const char must_clone[];\n&quot;);
1161   fprintf(fp_hpp, &quot;\n&quot;);
1162 
1163   // Build mapping from ideal names to ideal indices
1164   fprintf(fp_cpp, &quot;\n&quot;);
1165   fprintf(fp_cpp, &quot;// Mapping from machine-independent opcode to boolean\n&quot;);
1166   fprintf(fp_cpp, &quot;const        char must_clone[] = {\n&quot;);
1167   for (int idealIndex = 0; idealIndex &lt; _last_opcode; ++idealIndex) {
1168     int         must_clone = 0;
1169     const char *idealName = NodeClassNames[idealIndex];
1170     // Previously selected constants for cloning
1171     // !!!!!
1172     // These are the current machine-dependent clones
1173     if ( strcmp(idealName,&quot;CmpI&quot;) == 0
1174          || strcmp(idealName,&quot;CmpU&quot;) == 0
1175          || strcmp(idealName,&quot;CmpP&quot;) == 0
1176          || strcmp(idealName,&quot;CmpN&quot;) == 0
1177          || strcmp(idealName,&quot;CmpL&quot;) == 0
1178          || strcmp(idealName,&quot;CmpUL&quot;) == 0
1179          || strcmp(idealName,&quot;CmpD&quot;) == 0
1180          || strcmp(idealName,&quot;CmpF&quot;) == 0
1181          || strcmp(idealName,&quot;FastLock&quot;) == 0
1182          || strcmp(idealName,&quot;FastUnlock&quot;) == 0
1183          || strcmp(idealName,&quot;OverflowAddI&quot;) == 0
1184          || strcmp(idealName,&quot;OverflowAddL&quot;) == 0
1185          || strcmp(idealName,&quot;OverflowSubI&quot;) == 0
1186          || strcmp(idealName,&quot;OverflowSubL&quot;) == 0
1187          || strcmp(idealName,&quot;OverflowMulI&quot;) == 0
1188          || strcmp(idealName,&quot;OverflowMulL&quot;) == 0
1189          || strcmp(idealName,&quot;Bool&quot;) == 0
1190          || strcmp(idealName,&quot;Binary&quot;) == 0 ) {
1191       // Removed ConI from the must_clone list.  CPUs that cannot use
1192       // large constants as immediates manifest the constant as an
1193       // instruction.  The must_clone flag prevents the constant from
1194       // floating up out of loops.
1195       must_clone = 1;
1196     }
1197     fprintf(fp_cpp, &quot;  %d%s // %s: %d\n&quot;, must_clone,
1198       (idealIndex != (_last_opcode - 1)) ? &quot;,&quot; : &quot; // no trailing comma&quot;,
1199       idealName, idealIndex);
1200   }
1201   // Finish defining table
1202   fprintf(fp_cpp, &quot;};\n&quot;);
1203 }
    </pre>
  </body>
</html>
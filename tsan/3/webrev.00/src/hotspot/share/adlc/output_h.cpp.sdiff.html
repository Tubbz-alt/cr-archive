<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/adlc/output_h.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="output_c.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../aot/aotCodeHeap.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/adlc/output_h.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 741   fprintf(fp_hpp, &quot;// Pipeline_Use_Cycle_Mask Class\n&quot;);
 742   fprintf(fp_hpp, &quot;class Pipeline_Use_Cycle_Mask {\n&quot;);
 743 
 744   if (_pipeline-&gt;_maxcycleused &lt;=
 745 #ifdef SPARC
 746     64
 747 #else
 748     32
 749 #endif
 750       ) {
 751     fprintf(fp_hpp, &quot;protected:\n&quot;);
 752     fprintf(fp_hpp, &quot;  %s _mask;\n\n&quot;, _pipeline-&gt;_maxcycleused &lt;= 32 ? &quot;uint&quot; : &quot;uint64_t&quot; );
 753     fprintf(fp_hpp, &quot;public:\n&quot;);
 754     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask() : _mask(0) {}\n\n&quot;);
 755     if (_pipeline-&gt;_maxcycleused &lt;= 32)
 756       fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask(uint mask) : _mask(mask) {}\n\n&quot;);
 757     else {
 758       fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask(uint mask1, uint mask2) : _mask((((uint64_t)mask1) &lt;&lt; 32) | mask2) {}\n\n&quot;);
 759       fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask(uint64_t mask) : _mask(mask) {}\n\n&quot;);
 760     }
<span class="line-removed"> 761     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask&amp; operator=(const Pipeline_Use_Cycle_Mask &amp;in) {\n&quot;);</span>
<span class="line-removed"> 762     fprintf(fp_hpp, &quot;    _mask = in._mask;\n&quot;);</span>
<span class="line-removed"> 763     fprintf(fp_hpp, &quot;    return *this;\n&quot;);</span>
<span class="line-removed"> 764     fprintf(fp_hpp, &quot;  }\n\n&quot;);</span>
 765     fprintf(fp_hpp, &quot;  bool overlaps(const Pipeline_Use_Cycle_Mask &amp;in2) const {\n&quot;);
 766     fprintf(fp_hpp, &quot;    return ((_mask &amp; in2._mask) != 0);\n&quot;);
 767     fprintf(fp_hpp, &quot;  }\n\n&quot;);
 768     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask&amp; operator&lt;&lt;=(int n) {\n&quot;);
 769     fprintf(fp_hpp, &quot;    _mask &lt;&lt;= n;\n&quot;);
 770     fprintf(fp_hpp, &quot;    return *this;\n&quot;);
 771     fprintf(fp_hpp, &quot;  }\n\n&quot;);
 772     fprintf(fp_hpp, &quot;  void Or(const Pipeline_Use_Cycle_Mask &amp;in2) {\n&quot;);
 773     fprintf(fp_hpp, &quot;    _mask |= in2._mask;\n&quot;);
 774     fprintf(fp_hpp, &quot;  }\n\n&quot;);
 775     fprintf(fp_hpp, &quot;  friend Pipeline_Use_Cycle_Mask operator&amp;(const Pipeline_Use_Cycle_Mask &amp;, const Pipeline_Use_Cycle_Mask &amp;);\n&quot;);
 776     fprintf(fp_hpp, &quot;  friend Pipeline_Use_Cycle_Mask operator|(const Pipeline_Use_Cycle_Mask &amp;, const Pipeline_Use_Cycle_Mask &amp;);\n\n&quot;);
 777   }
 778   else {
 779     fprintf(fp_hpp, &quot;protected:\n&quot;);
 780     uint masklen = (_pipeline-&gt;_maxcycleused + 31) &gt;&gt; 5;
 781     uint l;
 782     fprintf(fp_hpp, &quot;  uint &quot;);
 783     for (l = 1; l &lt;= masklen; l++)
 784       fprintf(fp_hpp, &quot;_mask%d%s&quot;, l, l &lt; masklen ? &quot;, &quot; : &quot;;\n\n&quot;);
 785     fprintf(fp_hpp, &quot;public:\n&quot;);
 786     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask() : &quot;);
 787     for (l = 1; l &lt;= masklen; l++)
 788       fprintf(fp_hpp, &quot;_mask%d(0)%s&quot;, l, l &lt; masklen ? &quot;, &quot; : &quot; {}\n\n&quot;);
 789     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask(&quot;);
 790     for (l = 1; l &lt;= masklen; l++)
 791       fprintf(fp_hpp, &quot;uint mask%d%s&quot;, l, l &lt; masklen ? &quot;, &quot; : &quot;) : &quot;);
 792     for (l = 1; l &lt;= masklen; l++)
 793       fprintf(fp_hpp, &quot;_mask%d(mask%d)%s&quot;, l, l, l &lt; masklen ? &quot;, &quot; : &quot; {}\n\n&quot;);
 794 
<span class="line-removed"> 795     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask&amp; operator=(const Pipeline_Use_Cycle_Mask &amp;in) {\n&quot;);</span>
<span class="line-removed"> 796     for (l = 1; l &lt;= masklen; l++)</span>
<span class="line-removed"> 797       fprintf(fp_hpp, &quot;    _mask%d = in._mask%d;\n&quot;, l, l);</span>
<span class="line-removed"> 798     fprintf(fp_hpp, &quot;    return *this;\n&quot;);</span>
<span class="line-removed"> 799     fprintf(fp_hpp, &quot;  }\n\n&quot;);</span>
 800     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask intersect(const Pipeline_Use_Cycle_Mask &amp;in2) {\n&quot;);
 801     fprintf(fp_hpp, &quot;    Pipeline_Use_Cycle_Mask out;\n&quot;);
 802     for (l = 1; l &lt;= masklen; l++)
 803       fprintf(fp_hpp, &quot;    out._mask%d = _mask%d &amp; in2._mask%d;\n&quot;, l, l, l);
 804     fprintf(fp_hpp, &quot;    return out;\n&quot;);
 805     fprintf(fp_hpp, &quot;  }\n\n&quot;);
 806     fprintf(fp_hpp, &quot;  bool overlaps(const Pipeline_Use_Cycle_Mask &amp;in2) const {\n&quot;);
 807     fprintf(fp_hpp, &quot;    return (&quot;);
 808     for (l = 1; l &lt;= masklen; l++)
 809       fprintf(fp_hpp, &quot;((_mask%d &amp; in2._mask%d) != 0)%s&quot;, l, l, l &lt; masklen ? &quot; || &quot; : &quot;&quot;);
 810     fprintf(fp_hpp, &quot;) ? true : false;\n&quot;);
 811     fprintf(fp_hpp, &quot;  }\n\n&quot;);
 812     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask&amp; operator&lt;&lt;=(int n) {\n&quot;);
 813     fprintf(fp_hpp, &quot;    if (n &gt;= 32)\n&quot;);
 814     fprintf(fp_hpp, &quot;      do {\n       &quot;);
 815     for (l = masklen; l &gt; 1; l--)
 816       fprintf(fp_hpp, &quot; _mask%d = _mask%d;&quot;, l, l-1);
 817     fprintf(fp_hpp, &quot; _mask%d = 0;\n&quot;, 1);
 818     fprintf(fp_hpp, &quot;      } while ((n -= 32) &gt;= 32);\n\n&quot;);
 819     fprintf(fp_hpp, &quot;    if (n &gt; 0) {\n&quot;);
</pre>
<hr />
<pre>
1560 
1561     Attribute *att = instr-&gt;_attribs;
1562     // Fields of the node specified in the ad file.
1563     while (att != NULL) {
1564       if (strncmp(att-&gt;_ident, &quot;ins_field_&quot;, 10) == 0) {
1565         const char *field_name = att-&gt;_ident+10;
1566         const char *field_type = att-&gt;_val;
1567         fprintf(fp, &quot;  %s _%s;\n&quot;, field_type, field_name);
1568       }
1569       att = (Attribute *)att-&gt;_next;
1570     }
1571 
1572     fprintf(fp,&quot;  MachOper *opnd_array(uint operand_index) const {\n&quot;);
1573     fprintf(fp,&quot;    assert(operand_index &lt; _num_opnds, \&quot;invalid _opnd_array index\&quot;);\n&quot;);
1574     fprintf(fp,&quot;    return _opnd_array[operand_index];\n&quot;);
1575     fprintf(fp,&quot;  }\n&quot;);
1576     fprintf(fp,&quot;  void      set_opnd_array(uint operand_index, MachOper *operand) {\n&quot;);
1577     fprintf(fp,&quot;    assert(operand_index &lt; _num_opnds, \&quot;invalid _opnd_array index\&quot;);\n&quot;);
1578     fprintf(fp,&quot;    _opnd_array[operand_index] = operand;\n&quot;);
1579     fprintf(fp,&quot;  }\n&quot;);


1580     fprintf(fp,&quot;private:\n&quot;);
1581     if ( instr-&gt;is_ideal_jump() ) {
1582       fprintf(fp,&quot;  virtual void           add_case_label(int index_num, Label* blockLabel) {\n&quot;);
1583       fprintf(fp,&quot;    _index2label.at_put_grow(index_num, blockLabel);\n&quot;);
1584       fprintf(fp,&quot;  }\n&quot;);
1585     }
1586     if( can_cisc_spill() &amp;&amp; (instr-&gt;cisc_spill_alternate() != NULL) ) {
1587       fprintf(fp,&quot;  const RegMask  *_cisc_RegMask;\n&quot;);
1588     }
1589 
1590     out_RegMask(fp);                      // output register mask
<span class="line-removed">1591     fprintf(fp,&quot;  virtual uint           rule() const { return %s_rule; }\n&quot;,</span>
<span class="line-removed">1592             instr-&gt;_ident);</span>
1593 
1594     // If this instruction contains a labelOper
1595     // Declare Node::methods that set operand Label&#39;s contents
1596     int label_position = instr-&gt;label_position();
1597     if( label_position != -1 ) {
1598       // Set/Save the label, stored in labelOper::_branch_label
1599       fprintf(fp,&quot;  virtual void           label_set( Label* label, uint block_num );\n&quot;);
1600       fprintf(fp,&quot;  virtual void           save_label( Label** label, uint* block_num );\n&quot;);
1601     }
1602 
1603     // If this instruction contains a methodOper
1604     // Declare Node::methods that set operand method&#39;s contents
1605     int method_position = instr-&gt;method_position();
1606     if( method_position != -1 ) {
1607       // Set the address method, stored in methodOper::_method
1608       fprintf(fp,&quot;  virtual void           method_set( intptr_t method );\n&quot;);
1609     }
1610 
1611     // virtual functions for attributes
1612     //
</pre>
</td>
<td>
<hr />
<pre>
 741   fprintf(fp_hpp, &quot;// Pipeline_Use_Cycle_Mask Class\n&quot;);
 742   fprintf(fp_hpp, &quot;class Pipeline_Use_Cycle_Mask {\n&quot;);
 743 
 744   if (_pipeline-&gt;_maxcycleused &lt;=
 745 #ifdef SPARC
 746     64
 747 #else
 748     32
 749 #endif
 750       ) {
 751     fprintf(fp_hpp, &quot;protected:\n&quot;);
 752     fprintf(fp_hpp, &quot;  %s _mask;\n\n&quot;, _pipeline-&gt;_maxcycleused &lt;= 32 ? &quot;uint&quot; : &quot;uint64_t&quot; );
 753     fprintf(fp_hpp, &quot;public:\n&quot;);
 754     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask() : _mask(0) {}\n\n&quot;);
 755     if (_pipeline-&gt;_maxcycleused &lt;= 32)
 756       fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask(uint mask) : _mask(mask) {}\n\n&quot;);
 757     else {
 758       fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask(uint mask1, uint mask2) : _mask((((uint64_t)mask1) &lt;&lt; 32) | mask2) {}\n\n&quot;);
 759       fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask(uint64_t mask) : _mask(mask) {}\n\n&quot;);
 760     }




 761     fprintf(fp_hpp, &quot;  bool overlaps(const Pipeline_Use_Cycle_Mask &amp;in2) const {\n&quot;);
 762     fprintf(fp_hpp, &quot;    return ((_mask &amp; in2._mask) != 0);\n&quot;);
 763     fprintf(fp_hpp, &quot;  }\n\n&quot;);
 764     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask&amp; operator&lt;&lt;=(int n) {\n&quot;);
 765     fprintf(fp_hpp, &quot;    _mask &lt;&lt;= n;\n&quot;);
 766     fprintf(fp_hpp, &quot;    return *this;\n&quot;);
 767     fprintf(fp_hpp, &quot;  }\n\n&quot;);
 768     fprintf(fp_hpp, &quot;  void Or(const Pipeline_Use_Cycle_Mask &amp;in2) {\n&quot;);
 769     fprintf(fp_hpp, &quot;    _mask |= in2._mask;\n&quot;);
 770     fprintf(fp_hpp, &quot;  }\n\n&quot;);
 771     fprintf(fp_hpp, &quot;  friend Pipeline_Use_Cycle_Mask operator&amp;(const Pipeline_Use_Cycle_Mask &amp;, const Pipeline_Use_Cycle_Mask &amp;);\n&quot;);
 772     fprintf(fp_hpp, &quot;  friend Pipeline_Use_Cycle_Mask operator|(const Pipeline_Use_Cycle_Mask &amp;, const Pipeline_Use_Cycle_Mask &amp;);\n\n&quot;);
 773   }
 774   else {
 775     fprintf(fp_hpp, &quot;protected:\n&quot;);
 776     uint masklen = (_pipeline-&gt;_maxcycleused + 31) &gt;&gt; 5;
 777     uint l;
 778     fprintf(fp_hpp, &quot;  uint &quot;);
 779     for (l = 1; l &lt;= masklen; l++)
 780       fprintf(fp_hpp, &quot;_mask%d%s&quot;, l, l &lt; masklen ? &quot;, &quot; : &quot;;\n\n&quot;);
 781     fprintf(fp_hpp, &quot;public:\n&quot;);
 782     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask() : &quot;);
 783     for (l = 1; l &lt;= masklen; l++)
 784       fprintf(fp_hpp, &quot;_mask%d(0)%s&quot;, l, l &lt; masklen ? &quot;, &quot; : &quot; {}\n\n&quot;);
 785     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask(&quot;);
 786     for (l = 1; l &lt;= masklen; l++)
 787       fprintf(fp_hpp, &quot;uint mask%d%s&quot;, l, l &lt; masklen ? &quot;, &quot; : &quot;) : &quot;);
 788     for (l = 1; l &lt;= masklen; l++)
 789       fprintf(fp_hpp, &quot;_mask%d(mask%d)%s&quot;, l, l, l &lt; masklen ? &quot;, &quot; : &quot; {}\n\n&quot;);
 790 





 791     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask intersect(const Pipeline_Use_Cycle_Mask &amp;in2) {\n&quot;);
 792     fprintf(fp_hpp, &quot;    Pipeline_Use_Cycle_Mask out;\n&quot;);
 793     for (l = 1; l &lt;= masklen; l++)
 794       fprintf(fp_hpp, &quot;    out._mask%d = _mask%d &amp; in2._mask%d;\n&quot;, l, l, l);
 795     fprintf(fp_hpp, &quot;    return out;\n&quot;);
 796     fprintf(fp_hpp, &quot;  }\n\n&quot;);
 797     fprintf(fp_hpp, &quot;  bool overlaps(const Pipeline_Use_Cycle_Mask &amp;in2) const {\n&quot;);
 798     fprintf(fp_hpp, &quot;    return (&quot;);
 799     for (l = 1; l &lt;= masklen; l++)
 800       fprintf(fp_hpp, &quot;((_mask%d &amp; in2._mask%d) != 0)%s&quot;, l, l, l &lt; masklen ? &quot; || &quot; : &quot;&quot;);
 801     fprintf(fp_hpp, &quot;) ? true : false;\n&quot;);
 802     fprintf(fp_hpp, &quot;  }\n\n&quot;);
 803     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask&amp; operator&lt;&lt;=(int n) {\n&quot;);
 804     fprintf(fp_hpp, &quot;    if (n &gt;= 32)\n&quot;);
 805     fprintf(fp_hpp, &quot;      do {\n       &quot;);
 806     for (l = masklen; l &gt; 1; l--)
 807       fprintf(fp_hpp, &quot; _mask%d = _mask%d;&quot;, l, l-1);
 808     fprintf(fp_hpp, &quot; _mask%d = 0;\n&quot;, 1);
 809     fprintf(fp_hpp, &quot;      } while ((n -= 32) &gt;= 32);\n\n&quot;);
 810     fprintf(fp_hpp, &quot;    if (n &gt; 0) {\n&quot;);
</pre>
<hr />
<pre>
1551 
1552     Attribute *att = instr-&gt;_attribs;
1553     // Fields of the node specified in the ad file.
1554     while (att != NULL) {
1555       if (strncmp(att-&gt;_ident, &quot;ins_field_&quot;, 10) == 0) {
1556         const char *field_name = att-&gt;_ident+10;
1557         const char *field_type = att-&gt;_val;
1558         fprintf(fp, &quot;  %s _%s;\n&quot;, field_type, field_name);
1559       }
1560       att = (Attribute *)att-&gt;_next;
1561     }
1562 
1563     fprintf(fp,&quot;  MachOper *opnd_array(uint operand_index) const {\n&quot;);
1564     fprintf(fp,&quot;    assert(operand_index &lt; _num_opnds, \&quot;invalid _opnd_array index\&quot;);\n&quot;);
1565     fprintf(fp,&quot;    return _opnd_array[operand_index];\n&quot;);
1566     fprintf(fp,&quot;  }\n&quot;);
1567     fprintf(fp,&quot;  void      set_opnd_array(uint operand_index, MachOper *operand) {\n&quot;);
1568     fprintf(fp,&quot;    assert(operand_index &lt; _num_opnds, \&quot;invalid _opnd_array index\&quot;);\n&quot;);
1569     fprintf(fp,&quot;    _opnd_array[operand_index] = operand;\n&quot;);
1570     fprintf(fp,&quot;  }\n&quot;);
<span class="line-added">1571     fprintf(fp,&quot;  virtual uint           rule() const { return %s_rule; }\n&quot;,</span>
<span class="line-added">1572             instr-&gt;_ident);</span>
1573     fprintf(fp,&quot;private:\n&quot;);
1574     if ( instr-&gt;is_ideal_jump() ) {
1575       fprintf(fp,&quot;  virtual void           add_case_label(int index_num, Label* blockLabel) {\n&quot;);
1576       fprintf(fp,&quot;    _index2label.at_put_grow(index_num, blockLabel);\n&quot;);
1577       fprintf(fp,&quot;  }\n&quot;);
1578     }
1579     if( can_cisc_spill() &amp;&amp; (instr-&gt;cisc_spill_alternate() != NULL) ) {
1580       fprintf(fp,&quot;  const RegMask  *_cisc_RegMask;\n&quot;);
1581     }
1582 
1583     out_RegMask(fp);                      // output register mask


1584 
1585     // If this instruction contains a labelOper
1586     // Declare Node::methods that set operand Label&#39;s contents
1587     int label_position = instr-&gt;label_position();
1588     if( label_position != -1 ) {
1589       // Set/Save the label, stored in labelOper::_branch_label
1590       fprintf(fp,&quot;  virtual void           label_set( Label* label, uint block_num );\n&quot;);
1591       fprintf(fp,&quot;  virtual void           save_label( Label** label, uint* block_num );\n&quot;);
1592     }
1593 
1594     // If this instruction contains a methodOper
1595     // Declare Node::methods that set operand method&#39;s contents
1596     int method_position = instr-&gt;method_position();
1597     if( method_position != -1 ) {
1598       // Set the address method, stored in methodOper::_method
1599       fprintf(fp,&quot;  virtual void           method_set( intptr_t method );\n&quot;);
1600     }
1601 
1602     // virtual functions for attributes
1603     //
</pre>
</td>
</tr>
</table>
<center><a href="output_c.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../aot/aotCodeHeap.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/adlc/output_h.cpp b/src/hotspot/share/adlc/output_h.cpp
--- a/src/hotspot/share/adlc/output_h.cpp
+++ b/src/hotspot/share/adlc/output_h.cpp
@@ -756,14 +756,10 @@
       fprintf(fp_hpp, "  Pipeline_Use_Cycle_Mask(uint mask) : _mask(mask) {}\n\n");
     else {
       fprintf(fp_hpp, "  Pipeline_Use_Cycle_Mask(uint mask1, uint mask2) : _mask((((uint64_t)mask1) << 32) | mask2) {}\n\n");
       fprintf(fp_hpp, "  Pipeline_Use_Cycle_Mask(uint64_t mask) : _mask(mask) {}\n\n");
     }
-    fprintf(fp_hpp, "  Pipeline_Use_Cycle_Mask& operator=(const Pipeline_Use_Cycle_Mask &in) {\n");
-    fprintf(fp_hpp, "    _mask = in._mask;\n");
-    fprintf(fp_hpp, "    return *this;\n");
-    fprintf(fp_hpp, "  }\n\n");
     fprintf(fp_hpp, "  bool overlaps(const Pipeline_Use_Cycle_Mask &in2) const {\n");
     fprintf(fp_hpp, "    return ((_mask & in2._mask) != 0);\n");
     fprintf(fp_hpp, "  }\n\n");
     fprintf(fp_hpp, "  Pipeline_Use_Cycle_Mask& operator<<=(int n) {\n");
     fprintf(fp_hpp, "    _mask <<= n;\n");
@@ -790,15 +786,10 @@
     for (l = 1; l <= masklen; l++)
       fprintf(fp_hpp, "uint mask%d%s", l, l < masklen ? ", " : ") : ");
     for (l = 1; l <= masklen; l++)
       fprintf(fp_hpp, "_mask%d(mask%d)%s", l, l, l < masklen ? ", " : " {}\n\n");
 
-    fprintf(fp_hpp, "  Pipeline_Use_Cycle_Mask& operator=(const Pipeline_Use_Cycle_Mask &in) {\n");
-    for (l = 1; l <= masklen; l++)
-      fprintf(fp_hpp, "    _mask%d = in._mask%d;\n", l, l);
-    fprintf(fp_hpp, "    return *this;\n");
-    fprintf(fp_hpp, "  }\n\n");
     fprintf(fp_hpp, "  Pipeline_Use_Cycle_Mask intersect(const Pipeline_Use_Cycle_Mask &in2) {\n");
     fprintf(fp_hpp, "    Pipeline_Use_Cycle_Mask out;\n");
     for (l = 1; l <= masklen; l++)
       fprintf(fp_hpp, "    out._mask%d = _mask%d & in2._mask%d;\n", l, l, l);
     fprintf(fp_hpp, "    return out;\n");
@@ -1575,10 +1566,12 @@
     fprintf(fp,"  }\n");
     fprintf(fp,"  void      set_opnd_array(uint operand_index, MachOper *operand) {\n");
     fprintf(fp,"    assert(operand_index < _num_opnds, \"invalid _opnd_array index\");\n");
     fprintf(fp,"    _opnd_array[operand_index] = operand;\n");
     fprintf(fp,"  }\n");
+    fprintf(fp,"  virtual uint           rule() const { return %s_rule; }\n",
+            instr->_ident);
     fprintf(fp,"private:\n");
     if ( instr->is_ideal_jump() ) {
       fprintf(fp,"  virtual void           add_case_label(int index_num, Label* blockLabel) {\n");
       fprintf(fp,"    _index2label.at_put_grow(index_num, blockLabel);\n");
       fprintf(fp,"  }\n");
@@ -1586,12 +1579,10 @@
     if( can_cisc_spill() && (instr->cisc_spill_alternate() != NULL) ) {
       fprintf(fp,"  const RegMask  *_cisc_RegMask;\n");
     }
 
     out_RegMask(fp);                      // output register mask
-    fprintf(fp,"  virtual uint           rule() const { return %s_rule; }\n",
-            instr->_ident);
 
     // If this instruction contains a labelOper
     // Declare Node::methods that set operand Label's contents
     int label_position = instr->label_position();
     if( label_position != -1 ) {

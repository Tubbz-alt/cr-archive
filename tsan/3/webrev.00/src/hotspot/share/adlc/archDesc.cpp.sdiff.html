<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/adlc/archDesc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="adlparse.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="dfa.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/adlc/archDesc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 228 
 229 // Build MatchList structures for operands
 230 void ArchDesc::inspectOperands() {
 231 
 232   // Iterate through all operands
 233   _operands.reset();
 234   OperandForm *op;
 235   for( ; (op = (OperandForm*)_operands.iter()) != NULL;) {
 236     // Construct list of top-level operands (components)
 237     op-&gt;build_components();
 238 
 239     // Ensure that match field is defined.
 240     if ( op-&gt;_matrule == NULL )  continue;
 241 
 242     // Type check match rules
 243     check_optype(op-&gt;_matrule);
 244 
 245     // Construct chain rules
 246     build_chain_rule(op);
 247 
<span class="line-modified"> 248     MatchRule &amp;mrule = *op-&gt;_matrule;</span>
<span class="line-modified"> 249     Predicate *pred  =  op-&gt;_predicate;</span>
 250 
 251     // Grab the machine type of the operand
 252     const char  *rootOp    = op-&gt;_ident;
<span class="line-modified"> 253     mrule._machType  = rootOp;</span>
 254 
 255     // Check for special cases
 256     if (strcmp(rootOp,&quot;Universe&quot;)==0) continue;
 257     if (strcmp(rootOp,&quot;label&quot;)==0) continue;
 258     // !!!!! !!!!!
 259     assert( strcmp(rootOp,&quot;sReg&quot;) != 0, &quot;Disable untyped &#39;sReg&#39;&quot;);
 260     if (strcmp(rootOp,&quot;sRegI&quot;)==0) continue;
 261     if (strcmp(rootOp,&quot;sRegP&quot;)==0) continue;
 262     if (strcmp(rootOp,&quot;sRegF&quot;)==0) continue;
 263     if (strcmp(rootOp,&quot;sRegD&quot;)==0) continue;
 264     if (strcmp(rootOp,&quot;sRegL&quot;)==0) continue;
 265 
 266     // Cost for this match
 267     const char *costStr     = op-&gt;cost();
 268     const char *defaultCost =
 269       ((AttributeForm*)_globalNames[AttributeForm::_op_cost])-&gt;_attrdef;
 270     const char *cost        =  costStr? costStr : defaultCost;
 271 
 272     // Find result type for match.
 273     const char *result      = op-&gt;reduce_result();
<span class="line-removed"> 274     bool        has_root    = false;</span>
 275 
<span class="line-modified"> 276     // Construct a MatchList for this entry</span>
<span class="line-modified"> 277     buildMatchList(op-&gt;_matrule, result, rootOp, pred, cost);</span>




 278   }
 279 }
 280 
 281 // Build MatchList structures for instructions
 282 void ArchDesc::inspectInstructions() {
 283 
 284   // Iterate through all instructions
 285   _instructions.reset();
 286   InstructForm *instr;
 287   for( ; (instr = (InstructForm*)_instructions.iter()) != NULL; ) {
 288     // Construct list of top-level operands (components)
 289     instr-&gt;build_components();
 290 
 291     // Ensure that match field is defined.
 292     if ( instr-&gt;_matrule == NULL )  continue;
 293 
 294     MatchRule &amp;mrule = *instr-&gt;_matrule;
 295     Predicate *pred  =  instr-&gt;build_predicate();
 296 
 297     // Grab the machine type of the operand
</pre>
<hr />
<pre>
 788     vfprintf(errfile, fmt, args);
 789     fprintf(errfile, &quot;\n&quot;);
 790     fflush(errfile);
 791   }
 792   return 1;
 793 }
 794 
 795 
 796 // ---------------------------------------------------------------------------
 797 //--------Utilities to build mappings for machine registers ------------------
 798 // ---------------------------------------------------------------------------
 799 
 800 // Construct the name of the register mask.
 801 static const char *getRegMask(const char *reg_class_name) {
 802   if( reg_class_name == NULL ) return &quot;RegMask::Empty&quot;;
 803 
 804   if (strcmp(reg_class_name,&quot;Universe&quot;)==0) {
 805     return &quot;RegMask::Empty&quot;;
 806   } else if (strcmp(reg_class_name,&quot;stack_slots&quot;)==0) {
 807     return &quot;(Compile::current()-&gt;FIRST_STACK_mask())&quot;;


 808   } else {
 809     char       *rc_name = toUpper(reg_class_name);
 810     const char *mask    = &quot;_mask&quot;;
 811     int         length  = (int)strlen(rc_name) + (int)strlen(mask) + 5;
 812     char       *regMask = new char[length];
 813     sprintf(regMask,&quot;%s%s()&quot;, rc_name, mask);
 814     delete[] rc_name;
 815     return regMask;
 816   }
 817 }
 818 
 819 // Convert a register class name to its register mask.
 820 const char *ArchDesc::reg_class_to_reg_mask(const char *rc_name) {
 821   const char *reg_mask = &quot;RegMask::Empty&quot;;
 822 
 823   if( _register ) {
 824     RegClass *reg_class  = _register-&gt;getRegClass(rc_name);
 825     if (reg_class == NULL) {
 826       syntax_err(0, &quot;Use of an undefined register class %s&quot;, rc_name);
 827       return reg_mask;
</pre>
<hr />
<pre>
 850   }
 851 
 852   regMask = reg_class_to_reg_mask( result_class );
 853 
 854   return regMask;
 855 }
 856 
 857 // Obtain the name of the RegMask for an InstructForm
 858 const char *ArchDesc::reg_mask(InstructForm &amp;inForm) {
 859   const char *result = inForm.reduce_result();
 860 
 861   if (result == NULL) {
 862     syntax_err(inForm._linenum,
 863                &quot;Did not find result operand or RegMask&quot;
 864                &quot; for this instruction: %s&quot;,
 865                inForm._ident);
 866     abort();
 867   }
 868 
 869   // Instructions producing &#39;Universe&#39; use RegMask::Empty
<span class="line-modified"> 870   if( strcmp(result,&quot;Universe&quot;)==0 ) {</span>
 871     return &quot;RegMask::Empty&quot;;
 872   }
 873 
 874   // Lookup this result operand and get its register class
 875   Form *form = (Form*)_globalNames[result];
 876   if (form == NULL) {
 877     syntax_err(inForm._linenum,
 878                &quot;Did not find result operand for result: %s&quot;, result);
 879     abort();
 880   }
 881   OperandForm *oper = form-&gt;is_operand();
 882   if (oper == NULL) {
 883     syntax_err(inForm._linenum, &quot;Form is not an OperandForm:&quot;);
 884     form-&gt;dump();
 885     abort();
 886   }
 887   return reg_mask( *oper );
 888 }
 889 
 890 
</pre>
</td>
<td>
<hr />
<pre>
 228 
 229 // Build MatchList structures for operands
 230 void ArchDesc::inspectOperands() {
 231 
 232   // Iterate through all operands
 233   _operands.reset();
 234   OperandForm *op;
 235   for( ; (op = (OperandForm*)_operands.iter()) != NULL;) {
 236     // Construct list of top-level operands (components)
 237     op-&gt;build_components();
 238 
 239     // Ensure that match field is defined.
 240     if ( op-&gt;_matrule == NULL )  continue;
 241 
 242     // Type check match rules
 243     check_optype(op-&gt;_matrule);
 244 
 245     // Construct chain rules
 246     build_chain_rule(op);
 247 
<span class="line-modified"> 248     MatchRule *mrule = op-&gt;_matrule;</span>
<span class="line-modified"> 249     Predicate *pred  = op-&gt;_predicate;</span>
 250 
 251     // Grab the machine type of the operand
 252     const char  *rootOp    = op-&gt;_ident;
<span class="line-modified"> 253     mrule-&gt;_machType  = rootOp;</span>
 254 
 255     // Check for special cases
 256     if (strcmp(rootOp,&quot;Universe&quot;)==0) continue;
 257     if (strcmp(rootOp,&quot;label&quot;)==0) continue;
 258     // !!!!! !!!!!
 259     assert( strcmp(rootOp,&quot;sReg&quot;) != 0, &quot;Disable untyped &#39;sReg&#39;&quot;);
 260     if (strcmp(rootOp,&quot;sRegI&quot;)==0) continue;
 261     if (strcmp(rootOp,&quot;sRegP&quot;)==0) continue;
 262     if (strcmp(rootOp,&quot;sRegF&quot;)==0) continue;
 263     if (strcmp(rootOp,&quot;sRegD&quot;)==0) continue;
 264     if (strcmp(rootOp,&quot;sRegL&quot;)==0) continue;
 265 
 266     // Cost for this match
 267     const char *costStr     = op-&gt;cost();
 268     const char *defaultCost =
 269       ((AttributeForm*)_globalNames[AttributeForm::_op_cost])-&gt;_attrdef;
 270     const char *cost        =  costStr? costStr : defaultCost;
 271 
 272     // Find result type for match.
 273     const char *result      = op-&gt;reduce_result();

 274 
<span class="line-modified"> 275     // Construct a MatchList for this entry.</span>
<span class="line-modified"> 276     // Iterate over the list to enumerate all match cases for operands with multiple match rules.</span>
<span class="line-added"> 277     for (; mrule != NULL; mrule = mrule-&gt;_next) {</span>
<span class="line-added"> 278       mrule-&gt;_machType = rootOp;</span>
<span class="line-added"> 279       buildMatchList(mrule, result, rootOp, pred, cost);</span>
<span class="line-added"> 280     }</span>
 281   }
 282 }
 283 
 284 // Build MatchList structures for instructions
 285 void ArchDesc::inspectInstructions() {
 286 
 287   // Iterate through all instructions
 288   _instructions.reset();
 289   InstructForm *instr;
 290   for( ; (instr = (InstructForm*)_instructions.iter()) != NULL; ) {
 291     // Construct list of top-level operands (components)
 292     instr-&gt;build_components();
 293 
 294     // Ensure that match field is defined.
 295     if ( instr-&gt;_matrule == NULL )  continue;
 296 
 297     MatchRule &amp;mrule = *instr-&gt;_matrule;
 298     Predicate *pred  =  instr-&gt;build_predicate();
 299 
 300     // Grab the machine type of the operand
</pre>
<hr />
<pre>
 791     vfprintf(errfile, fmt, args);
 792     fprintf(errfile, &quot;\n&quot;);
 793     fflush(errfile);
 794   }
 795   return 1;
 796 }
 797 
 798 
 799 // ---------------------------------------------------------------------------
 800 //--------Utilities to build mappings for machine registers ------------------
 801 // ---------------------------------------------------------------------------
 802 
 803 // Construct the name of the register mask.
 804 static const char *getRegMask(const char *reg_class_name) {
 805   if( reg_class_name == NULL ) return &quot;RegMask::Empty&quot;;
 806 
 807   if (strcmp(reg_class_name,&quot;Universe&quot;)==0) {
 808     return &quot;RegMask::Empty&quot;;
 809   } else if (strcmp(reg_class_name,&quot;stack_slots&quot;)==0) {
 810     return &quot;(Compile::current()-&gt;FIRST_STACK_mask())&quot;;
<span class="line-added"> 811   } else if (strcmp(reg_class_name, &quot;dynamic&quot;)==0) {</span>
<span class="line-added"> 812     return &quot;*_opnds[0]-&gt;in_RegMask(0)&quot;;</span>
 813   } else {
 814     char       *rc_name = toUpper(reg_class_name);
 815     const char *mask    = &quot;_mask&quot;;
 816     int         length  = (int)strlen(rc_name) + (int)strlen(mask) + 5;
 817     char       *regMask = new char[length];
 818     sprintf(regMask,&quot;%s%s()&quot;, rc_name, mask);
 819     delete[] rc_name;
 820     return regMask;
 821   }
 822 }
 823 
 824 // Convert a register class name to its register mask.
 825 const char *ArchDesc::reg_class_to_reg_mask(const char *rc_name) {
 826   const char *reg_mask = &quot;RegMask::Empty&quot;;
 827 
 828   if( _register ) {
 829     RegClass *reg_class  = _register-&gt;getRegClass(rc_name);
 830     if (reg_class == NULL) {
 831       syntax_err(0, &quot;Use of an undefined register class %s&quot;, rc_name);
 832       return reg_mask;
</pre>
<hr />
<pre>
 855   }
 856 
 857   regMask = reg_class_to_reg_mask( result_class );
 858 
 859   return regMask;
 860 }
 861 
 862 // Obtain the name of the RegMask for an InstructForm
 863 const char *ArchDesc::reg_mask(InstructForm &amp;inForm) {
 864   const char *result = inForm.reduce_result();
 865 
 866   if (result == NULL) {
 867     syntax_err(inForm._linenum,
 868                &quot;Did not find result operand or RegMask&quot;
 869                &quot; for this instruction: %s&quot;,
 870                inForm._ident);
 871     abort();
 872   }
 873 
 874   // Instructions producing &#39;Universe&#39; use RegMask::Empty
<span class="line-modified"> 875   if (strcmp(result,&quot;Universe&quot;) == 0) {</span>
 876     return &quot;RegMask::Empty&quot;;
 877   }
 878 
 879   // Lookup this result operand and get its register class
 880   Form *form = (Form*)_globalNames[result];
 881   if (form == NULL) {
 882     syntax_err(inForm._linenum,
 883                &quot;Did not find result operand for result: %s&quot;, result);
 884     abort();
 885   }
 886   OperandForm *oper = form-&gt;is_operand();
 887   if (oper == NULL) {
 888     syntax_err(inForm._linenum, &quot;Form is not an OperandForm:&quot;);
 889     form-&gt;dump();
 890     abort();
 891   }
 892   return reg_mask( *oper );
 893 }
 894 
 895 
</pre>
</td>
</tr>
</table>
<center><a href="adlparse.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="dfa.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
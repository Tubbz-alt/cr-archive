<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/adlc/formssel.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="formsopt.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="main.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/adlc/formssel.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 740 
 741   // missed the memory op??
 742   if( true ) {  // %%% should not be necessary
 743     if( is_ideal_store() != Form::none ) {
 744       fprintf(stderr, &quot;Warning: cannot find memory opnd in instr.\n&quot;);
 745       ((InstructForm*)this)-&gt;dump();
 746       // pretend it has multiple defs and uses
 747       return MANY_MEMORY_OPERANDS;
 748     }
 749     if( is_ideal_load()  != Form::none ) {
 750       fprintf(stderr, &quot;Warning: cannot find memory opnd in instr.\n&quot;);
 751       ((InstructForm*)this)-&gt;dump();
 752       // pretend it has multiple uses and no defs
 753       return MANY_MEMORY_OPERANDS;
 754     }
 755   }
 756 
 757   return NO_MEMORY_OPERAND;
 758 }
 759 
<span class="line-removed"> 760 </span>
 761 // This instruction captures the machine-independent bottom_type
 762 // Expected use is for pointer vs oop determination for LoadP
 763 bool InstructForm::captures_bottom_type(FormDict &amp;globals) const {
 764   if (_matrule &amp;&amp; _matrule-&gt;_rChild &amp;&amp;
 765       (!strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;CastPP&quot;)       ||  // new result type
 766        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;CastX2P&quot;)      ||  // new result type
 767        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;DecodeN&quot;)      ||
 768        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;EncodeP&quot;)      ||
 769        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;DecodeNKlass&quot;) ||
 770        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;EncodePKlass&quot;) ||
 771        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;LoadN&quot;)        ||
 772        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;LoadNKlass&quot;)   ||
 773        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;CreateEx&quot;)     ||  // type of exception
 774        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;CheckCastPP&quot;)  ||
 775        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;GetAndSetP&quot;)   ||
 776        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;GetAndSetN&quot;)   ||
<span class="line-modified"> 777        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;CompareAndExchangeP&quot;) ||</span>
<span class="line-removed"> 778        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;CompareAndExchangeN&quot;) ||</span>
 779        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;ShenandoahCompareAndExchangeP&quot;) ||
 780        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;ShenandoahCompareAndExchangeN&quot;) ||
<span class="line-modified"> 781        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;ShenandoahReadBarrier&quot;)))  return true;</span>


 782   else if ( is_ideal_load() == Form::idealP )                return true;
 783   else if ( is_ideal_store() != Form::none  )                return true;
 784 
 785   if (needs_base_oop_edge(globals)) return true;
 786 
 787   if (is_vector()) return true;
 788   if (is_mach_constant()) return true;
 789 
 790   return  false;
 791 }
 792 
 793 
 794 // Access instr_cost attribute or return NULL.
 795 const char* InstructForm::cost() {
 796   for (Attribute* cur = _attribs; cur != NULL; cur = (Attribute*)cur-&gt;_next) {
 797     if( strcmp(cur-&gt;_ident,AttributeForm::_ins_cost) == 0 ) {
 798       return cur-&gt;_val;
 799     }
 800   }
 801   return NULL;
</pre>
<hr />
<pre>
1491 
1492 void MachNodeForm::dump() {
1493   output(stderr);
1494 }
1495 
1496 void MachNodeForm::output(FILE *fp) {
1497   fprintf(fp,&quot;\nMachNode: %s\n&quot;, (_ident?_ident:&quot;&quot;));
1498 }
1499 
1500 //------------------------------build_predicate--------------------------------
1501 // Build instruction predicates.  If the user uses the same operand name
1502 // twice, we need to check that the operands are pointer-eequivalent in
1503 // the DFA during the labeling process.
1504 Predicate *InstructForm::build_predicate() {
1505   const int buflen = 1024;
1506   char buf[buflen], *s=buf;
1507   Dict names(cmpstr,hashstr,Form::arena);       // Map Names to counts
1508 
1509   MatchNode *mnode =
1510     strcmp(_matrule-&gt;_opType, &quot;Set&quot;) ? _matrule : _matrule-&gt;_rChild;
<span class="line-modified">1511   mnode-&gt;count_instr_names(names);</span>
1512 
1513   uint first = 1;
1514   // Start with the predicate supplied in the .ad file.
1515   if (_predicate) {
1516     if (first) first = 0;
1517     strcpy(s, &quot;(&quot;); s += strlen(s);
1518     strncpy(s, _predicate-&gt;_pred, buflen - strlen(s) - 1);
1519     s += strlen(s);
1520     strcpy(s, &quot;)&quot;); s += strlen(s);
1521   }
1522   for( DictI i(&amp;names); i.test(); ++i ) {
1523     uintptr_t cnt = (uintptr_t)i._value;
1524     if( cnt &gt; 1 ) {             // Need a predicate at all?
1525       assert( cnt == 2, &quot;Unimplemented&quot; );
1526       // Handle many pairs
1527       if( first ) first=0;
1528       else {                    // All tests must pass, so use &#39;&amp;&amp;&#39;
1529         strcpy(s,&quot; &amp;&amp; &quot;);
1530         s += strlen(s);
1531       }
</pre>
<hr />
<pre>
1704 }
1705 
1706 Opcode::opcode_type Opcode::as_opcode_type(const char *param) {
1707   if( strcmp(param,&quot;primary&quot;) == 0 ) {
1708     return Opcode::PRIMARY;
1709   }
1710   else if( strcmp(param,&quot;secondary&quot;) == 0 ) {
1711     return Opcode::SECONDARY;
1712   }
1713   else if( strcmp(param,&quot;tertiary&quot;) == 0 ) {
1714     return Opcode::TERTIARY;
1715   }
1716   return Opcode::NOT_AN_OPCODE;
1717 }
1718 
1719 bool Opcode::print_opcode(FILE *fp, Opcode::opcode_type desired_opcode) {
1720   // Default values previously provided by MachNode::primary()...
1721   const char *description = NULL;
1722   const char *value       = NULL;
1723   // Check if user provided any opcode definitions
<span class="line-modified">1724   if( this != NULL ) {</span>
<span class="line-modified">1725     // Update &#39;value&#39; if user provided a definition in the instruction</span>
<span class="line-modified">1726     switch (desired_opcode) {</span>
<span class="line-modified">1727     case PRIMARY:</span>
<span class="line-modified">1728       description = &quot;primary()&quot;;</span>
<span class="line-modified">1729       if( _primary   != NULL)  { value = _primary;     }</span>
<span class="line-modified">1730       break;</span>
<span class="line-modified">1731     case SECONDARY:</span>
<span class="line-modified">1732       description = &quot;secondary()&quot;;</span>
<span class="line-modified">1733       if( _secondary != NULL ) { value = _secondary;   }</span>
<span class="line-modified">1734       break;</span>
<span class="line-modified">1735     case TERTIARY:</span>
<span class="line-modified">1736       description = &quot;tertiary()&quot;;</span>
<span class="line-modified">1737       if( _tertiary  != NULL ) { value = _tertiary;    }</span>
<span class="line-modified">1738       break;</span>
<span class="line-modified">1739     default:</span>
<span class="line-modified">1740       assert( false, &quot;ShouldNotReachHere();&quot;);</span>
<span class="line-removed">1741       break;</span>
<span class="line-removed">1742     }</span>
1743   }

1744   if (value != NULL) {
1745     fprintf(fp, &quot;(%s /*%s*/)&quot;, value, description);
1746   }
1747   return value != NULL;
1748 }
1749 
1750 void Opcode::dump() {
1751   output(stderr);
1752 }
1753 
1754 // Write info to output files
1755 void Opcode::output(FILE *fp) {
1756   if (_primary   != NULL) fprintf(fp,&quot;Primary   opcode: %s\n&quot;, _primary);
1757   if (_secondary != NULL) fprintf(fp,&quot;Secondary opcode: %s\n&quot;, _secondary);
1758   if (_tertiary  != NULL) fprintf(fp,&quot;Tertiary  opcode: %s\n&quot;, _tertiary);
1759 }
1760 
1761 //------------------------------InsEncode--------------------------------------
1762 InsEncode::InsEncode() {
1763 }
</pre>
<hr />
<pre>
3391   // If our left child exists, it is the left reduction
3392   if ( mnode-&gt;_lChild ) {
3393     leftStr = mnode-&gt;_lChild-&gt;_internalop ? mnode-&gt;_lChild-&gt;_internalop
3394       : mnode-&gt;_lChild-&gt;_opType;
3395   } else {
3396     // May be simple chain rule: (Set dst operand_form_source)
3397     if ( sets_result() ) {
3398       OperandForm *oper = globals[mnode-&gt;_opType]-&gt;is_operand();
3399       if( oper ) {
3400         leftStr = mnode-&gt;_opType;
3401       }
3402     }
3403   }
3404   return leftStr;
3405 }
3406 
3407 //------------------------------count_instr_names------------------------------
3408 // Count occurrences of operands names in the leaves of the instruction
3409 // match rule.
3410 void MatchNode::count_instr_names( Dict &amp;names ) {
<span class="line-removed">3411   if( this == NULL ) return;</span>
3412   if( _lChild ) _lChild-&gt;count_instr_names(names);
3413   if( _rChild ) _rChild-&gt;count_instr_names(names);
3414   if( !_lChild &amp;&amp; !_rChild ) {
3415     uintptr_t cnt = (uintptr_t)names[_name];
3416     cnt++;                      // One more name found
3417     names.Insert(_name,(void*)cnt);
3418   }
3419 }
3420 
3421 //------------------------------build_instr_pred-------------------------------
3422 // Build a path to &#39;name&#39; in buf.  Actually only build if cnt is zero, so we
3423 // can skip some leading instances of &#39;name&#39;.
3424 int MatchNode::build_instr_pred( char *buf, const char *name, int cnt ) {
3425   if( _lChild ) {
3426     if( !cnt ) strcpy( buf, &quot;_kids[0]-&gt;&quot; );
3427     cnt = _lChild-&gt;build_instr_pred( buf+strlen(buf), name, cnt );
3428     if( cnt &lt; 0 ) return cnt;   // Found it, all done
3429   }
3430   if( _rChild ) {
3431     if( !cnt ) strcpy( buf, &quot;_kids[1]-&gt;&quot; );
</pre>
<hr />
<pre>
3484     fprintf(fp,&quot; (%s &quot;,_name);  // &quot; (opcodeName &quot;
3485     if(_lChild) _lChild-&gt;output(fp); //               left operand
3486     if(_rChild) _rChild-&gt;output(fp); //                    right operand
3487     fprintf(fp,&quot;)&quot;);                 //                                 &quot;)&quot;
3488   }
3489 }
3490 
3491 int MatchNode::needs_ideal_memory_edge(FormDict &amp;globals) const {
3492   static const char *needs_ideal_memory_list[] = {
3493     &quot;StoreI&quot;,&quot;StoreL&quot;,&quot;StoreP&quot;,&quot;StoreN&quot;,&quot;StoreNKlass&quot;,&quot;StoreD&quot;,&quot;StoreF&quot; ,
3494     &quot;StoreB&quot;,&quot;StoreC&quot;,&quot;Store&quot; ,&quot;StoreFP&quot;,
3495     &quot;LoadI&quot;, &quot;LoadL&quot;, &quot;LoadP&quot; ,&quot;LoadN&quot;, &quot;LoadD&quot; ,&quot;LoadF&quot;  ,
3496     &quot;LoadB&quot; , &quot;LoadUB&quot;, &quot;LoadUS&quot; ,&quot;LoadS&quot; ,&quot;Load&quot; ,
3497     &quot;StoreVector&quot;, &quot;LoadVector&quot;,
3498     &quot;LoadRange&quot;, &quot;LoadKlass&quot;, &quot;LoadNKlass&quot;, &quot;LoadL_unaligned&quot;, &quot;LoadD_unaligned&quot;,
3499     &quot;LoadPLocked&quot;,
3500     &quot;StorePConditional&quot;, &quot;StoreIConditional&quot;, &quot;StoreLConditional&quot;,
3501     &quot;CompareAndSwapB&quot;, &quot;CompareAndSwapS&quot;, &quot;CompareAndSwapI&quot;, &quot;CompareAndSwapL&quot;, &quot;CompareAndSwapP&quot;, &quot;CompareAndSwapN&quot;,
3502     &quot;WeakCompareAndSwapB&quot;, &quot;WeakCompareAndSwapS&quot;, &quot;WeakCompareAndSwapI&quot;, &quot;WeakCompareAndSwapL&quot;, &quot;WeakCompareAndSwapP&quot;, &quot;WeakCompareAndSwapN&quot;,
3503     &quot;CompareAndExchangeB&quot;, &quot;CompareAndExchangeS&quot;, &quot;CompareAndExchangeI&quot;, &quot;CompareAndExchangeL&quot;, &quot;CompareAndExchangeP&quot;, &quot;CompareAndExchangeN&quot;,

3504     &quot;ShenandoahCompareAndSwapN&quot;, &quot;ShenandoahCompareAndSwapP&quot;, &quot;ShenandoahWeakCompareAndSwapP&quot;, &quot;ShenandoahWeakCompareAndSwapN&quot;, &quot;ShenandoahCompareAndExchangeP&quot;, &quot;ShenandoahCompareAndExchangeN&quot;,

3505     &quot;StoreCM&quot;,
<span class="line-removed">3506     &quot;ClearArray&quot;,</span>
3507     &quot;GetAndSetB&quot;, &quot;GetAndSetS&quot;, &quot;GetAndAddI&quot;, &quot;GetAndSetI&quot;, &quot;GetAndSetP&quot;,
3508     &quot;GetAndAddB&quot;, &quot;GetAndAddS&quot;, &quot;GetAndAddL&quot;, &quot;GetAndSetL&quot;, &quot;GetAndSetN&quot;,
<span class="line-modified">3509     &quot;ShenandoahReadBarrier&quot;,</span>
<span class="line-removed">3510     &quot;LoadBarrierSlowReg&quot;, &quot;LoadBarrierWeakSlowReg&quot;</span>
3511   };
3512   int cnt = sizeof(needs_ideal_memory_list)/sizeof(char*);
3513   if( strcmp(_opType,&quot;PrefetchAllocation&quot;)==0 )
3514     return 1;






3515   if( _lChild ) {
3516     const char *opType = _lChild-&gt;_opType;
3517     for( int i=0; i&lt;cnt; i++ )
3518       if( strcmp(opType,needs_ideal_memory_list[i]) == 0 )
3519         return 1;
3520     if( _lChild-&gt;needs_ideal_memory_edge(globals) )
3521       return 1;
3522   }
3523   if( _rChild ) {
3524     const char *opType = _rChild-&gt;_opType;
3525     for( int i=0; i&lt;cnt; i++ )
3526       if( strcmp(opType,needs_ideal_memory_list[i]) == 0 )
3527         return 1;
3528     if( _rChild-&gt;needs_ideal_memory_edge(globals) )
3529       return 1;
3530   }
3531 
3532   return 0;
3533 }
3534 
</pre>
<hr />
<pre>
3787   } else if (mNode2-&gt;_rChild) {
3788     return false; // I have NULL right child, mNode2 has non-NULL right child.
3789   }
3790 
3791   // We&#39;ve made it through the gauntlet.
3792   return true;
3793 }
3794 
3795 //-------------------------- has_commutative_op -------------------------------
3796 // Recursively check for commutative operations with subtree operands
3797 // which could be swapped.
3798 void MatchNode::count_commutative_op(int&amp; count) {
3799   static const char *commut_op_list[] = {
3800     &quot;AddI&quot;,&quot;AddL&quot;,&quot;AddF&quot;,&quot;AddD&quot;,
3801     &quot;AddVB&quot;,&quot;AddVS&quot;,&quot;AddVI&quot;,&quot;AddVL&quot;,&quot;AddVF&quot;,&quot;AddVD&quot;,
3802     &quot;AndI&quot;,&quot;AndL&quot;,
3803     &quot;AndV&quot;,
3804     &quot;MaxI&quot;,&quot;MinI&quot;,&quot;MaxF&quot;,&quot;MinF&quot;,&quot;MaxD&quot;,&quot;MinD&quot;,
3805     &quot;MaxV&quot;, &quot;MinV&quot;,
3806     &quot;MulI&quot;,&quot;MulL&quot;,&quot;MulF&quot;,&quot;MulD&quot;,
<span class="line-modified">3807     &quot;MulVS&quot;,&quot;MulVI&quot;,&quot;MulVL&quot;,&quot;MulVF&quot;,&quot;MulVD&quot;,</span>
3808     &quot;OrI&quot;,&quot;OrL&quot;,
3809     &quot;OrV&quot;,
3810     &quot;XorI&quot;,&quot;XorL&quot;,
3811     &quot;XorV&quot;
3812   };
3813   int cnt = sizeof(commut_op_list)/sizeof(char*);
3814 
3815   if( _lChild &amp;&amp; _rChild &amp;&amp; (_lChild-&gt;_lChild || _rChild-&gt;_lChild) ) {
3816     // Don&#39;t swap if right operand is an immediate constant.
3817     bool is_const = false;
3818     if( _rChild-&gt;_lChild == NULL &amp;&amp; _rChild-&gt;_rChild == NULL ) {
3819       FormDict &amp;globals = _AD.globalNames();
3820       const Form *form = globals[_rChild-&gt;_opType];
3821       if ( form ) {
3822         OperandForm  *oper = form-&gt;is_operand();
3823         if( oper &amp;&amp; oper-&gt;interface_type(globals) == Form::constant_interface )
3824           is_const = true;
3825       }
3826     }
3827     if( !is_const ) {
</pre>
<hr />
<pre>
3978   if ((_lChild == NULL) &amp;&amp; (_rChild == NULL) ) {
3979     const Form *form = globals[_opType];
3980     // If this is ideal, then it is a base match, not a chain rule.
3981     if ( form &amp;&amp; form-&gt;is_operand() &amp;&amp; (!form-&gt;ideal_only())) {
3982       return true;
3983     }
3984   }
3985   // Check for &quot;Set&quot; form of chain rule, and do not generate a match list
3986   if (_rChild) {
3987     const char *rch = _rChild-&gt;_opType;
3988     const Form *form = globals[rch];
3989     if ((!strcmp(_opType,&quot;Set&quot;) &amp;&amp;
3990          ((form) &amp;&amp; form-&gt;is_operand()))) {
3991       return true;
3992     }
3993   }
3994   return false;
3995 }
3996 
3997 int MatchRule::is_ideal_copy() const {
<span class="line-modified">3998   if( _rChild ) {</span>
<span class="line-modified">3999     const char  *opType = _rChild-&gt;_opType;</span>
<span class="line-removed">4000 #if 1</span>
<span class="line-removed">4001     if( strcmp(opType,&quot;CastIP&quot;)==0 )</span>
<span class="line-removed">4002       return 1;</span>
<span class="line-removed">4003 #else</span>
<span class="line-removed">4004     if( strcmp(opType,&quot;CastII&quot;)==0 )</span>
<span class="line-removed">4005       return 1;</span>
<span class="line-removed">4006     // Do not treat *CastPP this way, because it</span>
<span class="line-removed">4007     // may transfer a raw pointer to an oop.</span>
<span class="line-removed">4008     // If the register allocator were to coalesce this</span>
<span class="line-removed">4009     // into a single LRG, the GC maps would be incorrect.</span>
<span class="line-removed">4010     //if( strcmp(opType,&quot;CastPP&quot;)==0 )</span>
<span class="line-removed">4011     //  return 1;</span>
<span class="line-removed">4012     //if( strcmp(opType,&quot;CheckCastPP&quot;)==0 )</span>
<span class="line-removed">4013     //  return 1;</span>
<span class="line-removed">4014     //</span>
<span class="line-removed">4015     // Do not treat CastX2P or CastP2X this way, because</span>
<span class="line-removed">4016     // raw pointers and int types are treated differently</span>
<span class="line-removed">4017     // when saving local &amp; stack info for safepoints in</span>
<span class="line-removed">4018     // Output().</span>
<span class="line-removed">4019     //if( strcmp(opType,&quot;CastX2P&quot;)==0 )</span>
<span class="line-removed">4020     //  return 1;</span>
<span class="line-removed">4021     //if( strcmp(opType,&quot;CastP2X&quot;)==0 )</span>
<span class="line-removed">4022     //  return 1;</span>
<span class="line-removed">4023 #endif</span>
<span class="line-removed">4024   }</span>
<span class="line-removed">4025   if( is_chain_rule(_AD.globalNames()) &amp;&amp;</span>
<span class="line-removed">4026       _lChild &amp;&amp; strncmp(_lChild-&gt;_opType,&quot;stackSlot&quot;,9)==0 )</span>
4027     return 1;

4028   return 0;
4029 }
4030 
<span class="line-removed">4031 </span>
4032 int MatchRule::is_expensive() const {
4033   if( _rChild ) {
4034     const char  *opType = _rChild-&gt;_opType;
4035     if( strcmp(opType,&quot;AtanD&quot;)==0 ||
4036         strcmp(opType,&quot;DivD&quot;)==0 ||
4037         strcmp(opType,&quot;DivF&quot;)==0 ||
4038         strcmp(opType,&quot;DivI&quot;)==0 ||
4039         strcmp(opType,&quot;Log10D&quot;)==0 ||
4040         strcmp(opType,&quot;ModD&quot;)==0 ||
4041         strcmp(opType,&quot;ModF&quot;)==0 ||
4042         strcmp(opType,&quot;ModI&quot;)==0 ||
4043         strcmp(opType,&quot;SqrtD&quot;)==0 ||
4044         strcmp(opType,&quot;SqrtF&quot;)==0 ||
4045         strcmp(opType,&quot;TanD&quot;)==0 ||
4046         strcmp(opType,&quot;ConvD2F&quot;)==0 ||
4047         strcmp(opType,&quot;ConvD2I&quot;)==0 ||
4048         strcmp(opType,&quot;ConvD2L&quot;)==0 ||
4049         strcmp(opType,&quot;ConvF2D&quot;)==0 ||
4050         strcmp(opType,&quot;ConvF2I&quot;)==0 ||
4051         strcmp(opType,&quot;ConvF2L&quot;)==0 ||
4052         strcmp(opType,&quot;ConvI2D&quot;)==0 ||
4053         strcmp(opType,&quot;ConvI2F&quot;)==0 ||
4054         strcmp(opType,&quot;ConvI2L&quot;)==0 ||
4055         strcmp(opType,&quot;ConvL2D&quot;)==0 ||
4056         strcmp(opType,&quot;ConvL2F&quot;)==0 ||
4057         strcmp(opType,&quot;ConvL2I&quot;)==0 ||
4058         strcmp(opType,&quot;DecodeN&quot;)==0 ||
4059         strcmp(opType,&quot;EncodeP&quot;)==0 ||
4060         strcmp(opType,&quot;EncodePKlass&quot;)==0 ||
4061         strcmp(opType,&quot;DecodeNKlass&quot;)==0 ||
4062         strcmp(opType,&quot;FmaD&quot;) == 0 ||
4063         strcmp(opType,&quot;FmaF&quot;) == 0 ||
4064         strcmp(opType,&quot;RoundDouble&quot;)==0 ||

4065         strcmp(opType,&quot;RoundFloat&quot;)==0 ||
4066         strcmp(opType,&quot;ReverseBytesI&quot;)==0 ||
4067         strcmp(opType,&quot;ReverseBytesL&quot;)==0 ||
4068         strcmp(opType,&quot;ReverseBytesUS&quot;)==0 ||
4069         strcmp(opType,&quot;ReverseBytesS&quot;)==0 ||
4070         strcmp(opType,&quot;ReplicateB&quot;)==0 ||
4071         strcmp(opType,&quot;ReplicateS&quot;)==0 ||
4072         strcmp(opType,&quot;ReplicateI&quot;)==0 ||
4073         strcmp(opType,&quot;ReplicateL&quot;)==0 ||
4074         strcmp(opType,&quot;ReplicateF&quot;)==0 ||
4075         strcmp(opType,&quot;ReplicateD&quot;)==0 ||
4076         strcmp(opType,&quot;AddReductionVI&quot;)==0 ||
4077         strcmp(opType,&quot;AddReductionVL&quot;)==0 ||
4078         strcmp(opType,&quot;AddReductionVF&quot;)==0 ||
4079         strcmp(opType,&quot;AddReductionVD&quot;)==0 ||
4080         strcmp(opType,&quot;MulReductionVI&quot;)==0 ||
4081         strcmp(opType,&quot;MulReductionVL&quot;)==0 ||
4082         strcmp(opType,&quot;MulReductionVF&quot;)==0 ||
4083         strcmp(opType,&quot;MulReductionVD&quot;)==0 ||
4084         0 /* 0 to line up columns nicely */ )
</pre>
<hr />
<pre>
4154   }
4155   return false;
4156 }
4157 
4158 
4159 Form::DataType MatchRule::is_ideal_load() const {
4160   Form::DataType ideal_load = Form::none;
4161 
4162   if ( _opType &amp;&amp; (strcmp(_opType,&quot;Set&quot;) == 0) &amp;&amp; _rChild ) {
4163     const char *opType = _rChild-&gt;_opType;
4164     ideal_load = is_load_from_memory(opType);
4165   }
4166 
4167   return ideal_load;
4168 }
4169 
4170 bool MatchRule::is_vector() const {
4171   static const char *vector_list[] = {
4172     &quot;AddVB&quot;,&quot;AddVS&quot;,&quot;AddVI&quot;,&quot;AddVL&quot;,&quot;AddVF&quot;,&quot;AddVD&quot;,
4173     &quot;SubVB&quot;,&quot;SubVS&quot;,&quot;SubVI&quot;,&quot;SubVL&quot;,&quot;SubVF&quot;,&quot;SubVD&quot;,
<span class="line-modified">4174     &quot;MulVS&quot;,&quot;MulVI&quot;,&quot;MulVL&quot;,&quot;MulVF&quot;,&quot;MulVD&quot;,</span>
4175     &quot;CMoveVD&quot;, &quot;CMoveVF&quot;,
4176     &quot;DivVF&quot;,&quot;DivVD&quot;,
<span class="line-modified">4177     &quot;AbsVF&quot;,&quot;AbsVD&quot;,</span>
4178     &quot;NegVF&quot;,&quot;NegVD&quot;,
4179     &quot;SqrtVD&quot;,&quot;SqrtVF&quot;,
4180     &quot;AndV&quot; ,&quot;XorV&quot; ,&quot;OrV&quot;,
4181     &quot;MaxV&quot;, &quot;MinV&quot;,
4182     &quot;AddReductionVI&quot;, &quot;AddReductionVL&quot;,
4183     &quot;AddReductionVF&quot;, &quot;AddReductionVD&quot;,
4184     &quot;MulReductionVI&quot;, &quot;MulReductionVL&quot;,
4185     &quot;MulReductionVF&quot;, &quot;MulReductionVD&quot;,
4186     &quot;MulAddVS2VI&quot;,
4187     &quot;LShiftCntV&quot;,&quot;RShiftCntV&quot;,
4188     &quot;LShiftVB&quot;,&quot;LShiftVS&quot;,&quot;LShiftVI&quot;,&quot;LShiftVL&quot;,
4189     &quot;RShiftVB&quot;,&quot;RShiftVS&quot;,&quot;RShiftVI&quot;,&quot;RShiftVL&quot;,
4190     &quot;URShiftVB&quot;,&quot;URShiftVS&quot;,&quot;URShiftVI&quot;,&quot;URShiftVL&quot;,
4191     &quot;MaxReductionV&quot;, &quot;MinReductionV&quot;,
4192     &quot;ReplicateB&quot;,&quot;ReplicateS&quot;,&quot;ReplicateI&quot;,&quot;ReplicateL&quot;,&quot;ReplicateF&quot;,&quot;ReplicateD&quot;,
<span class="line-modified">4193     &quot;LoadVector&quot;,&quot;StoreVector&quot;,</span>
4194     &quot;FmaVD&quot;, &quot;FmaVF&quot;,&quot;PopCountVI&quot;,
4195     // Next are not supported currently.
4196     &quot;PackB&quot;,&quot;PackS&quot;,&quot;PackI&quot;,&quot;PackL&quot;,&quot;PackF&quot;,&quot;PackD&quot;,&quot;Pack2L&quot;,&quot;Pack2D&quot;,
4197     &quot;ExtractB&quot;,&quot;ExtractUB&quot;,&quot;ExtractC&quot;,&quot;ExtractS&quot;,&quot;ExtractI&quot;,&quot;ExtractL&quot;,&quot;ExtractF&quot;,&quot;ExtractD&quot;
4198   };
4199   int cnt = sizeof(vector_list)/sizeof(char*);
4200   if (_rChild) {
4201     const char  *opType = _rChild-&gt;_opType;
4202     for (int i=0; i&lt;cnt; i++)
4203       if (strcmp(opType,vector_list[i]) == 0)
4204         return true;
4205   }
4206   return false;
4207 }
4208 
4209 
4210 bool MatchRule::skip_antidep_check() const {
4211   // Some loads operate on what is effectively immutable memory so we
4212   // should skip the anti dep computations.  For some of these nodes
4213   // the rewritable field keeps the anti dep logic from triggering but
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 740 
 741   // missed the memory op??
 742   if( true ) {  // %%% should not be necessary
 743     if( is_ideal_store() != Form::none ) {
 744       fprintf(stderr, &quot;Warning: cannot find memory opnd in instr.\n&quot;);
 745       ((InstructForm*)this)-&gt;dump();
 746       // pretend it has multiple defs and uses
 747       return MANY_MEMORY_OPERANDS;
 748     }
 749     if( is_ideal_load()  != Form::none ) {
 750       fprintf(stderr, &quot;Warning: cannot find memory opnd in instr.\n&quot;);
 751       ((InstructForm*)this)-&gt;dump();
 752       // pretend it has multiple uses and no defs
 753       return MANY_MEMORY_OPERANDS;
 754     }
 755   }
 756 
 757   return NO_MEMORY_OPERAND;
 758 }
 759 

 760 // This instruction captures the machine-independent bottom_type
 761 // Expected use is for pointer vs oop determination for LoadP
 762 bool InstructForm::captures_bottom_type(FormDict &amp;globals) const {
 763   if (_matrule &amp;&amp; _matrule-&gt;_rChild &amp;&amp;
 764       (!strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;CastPP&quot;)       ||  // new result type
 765        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;CastX2P&quot;)      ||  // new result type
 766        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;DecodeN&quot;)      ||
 767        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;EncodeP&quot;)      ||
 768        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;DecodeNKlass&quot;) ||
 769        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;EncodePKlass&quot;) ||
 770        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;LoadN&quot;)        ||
 771        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;LoadNKlass&quot;)   ||
 772        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;CreateEx&quot;)     ||  // type of exception
 773        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;CheckCastPP&quot;)  ||
 774        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;GetAndSetP&quot;)   ||
 775        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;GetAndSetN&quot;)   ||
<span class="line-modified"> 776 #if INCLUDE_SHENANDOAHGC</span>

 777        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;ShenandoahCompareAndExchangeP&quot;) ||
 778        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;ShenandoahCompareAndExchangeN&quot;) ||
<span class="line-modified"> 779 #endif</span>
<span class="line-added"> 780        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;CompareAndExchangeP&quot;) ||</span>
<span class="line-added"> 781        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;CompareAndExchangeN&quot;))) return true;</span>
 782   else if ( is_ideal_load() == Form::idealP )                return true;
 783   else if ( is_ideal_store() != Form::none  )                return true;
 784 
 785   if (needs_base_oop_edge(globals)) return true;
 786 
 787   if (is_vector()) return true;
 788   if (is_mach_constant()) return true;
 789 
 790   return  false;
 791 }
 792 
 793 
 794 // Access instr_cost attribute or return NULL.
 795 const char* InstructForm::cost() {
 796   for (Attribute* cur = _attribs; cur != NULL; cur = (Attribute*)cur-&gt;_next) {
 797     if( strcmp(cur-&gt;_ident,AttributeForm::_ins_cost) == 0 ) {
 798       return cur-&gt;_val;
 799     }
 800   }
 801   return NULL;
</pre>
<hr />
<pre>
1491 
1492 void MachNodeForm::dump() {
1493   output(stderr);
1494 }
1495 
1496 void MachNodeForm::output(FILE *fp) {
1497   fprintf(fp,&quot;\nMachNode: %s\n&quot;, (_ident?_ident:&quot;&quot;));
1498 }
1499 
1500 //------------------------------build_predicate--------------------------------
1501 // Build instruction predicates.  If the user uses the same operand name
1502 // twice, we need to check that the operands are pointer-eequivalent in
1503 // the DFA during the labeling process.
1504 Predicate *InstructForm::build_predicate() {
1505   const int buflen = 1024;
1506   char buf[buflen], *s=buf;
1507   Dict names(cmpstr,hashstr,Form::arena);       // Map Names to counts
1508 
1509   MatchNode *mnode =
1510     strcmp(_matrule-&gt;_opType, &quot;Set&quot;) ? _matrule : _matrule-&gt;_rChild;
<span class="line-modified">1511   if (mnode != NULL) mnode-&gt;count_instr_names(names);</span>
1512 
1513   uint first = 1;
1514   // Start with the predicate supplied in the .ad file.
1515   if (_predicate) {
1516     if (first) first = 0;
1517     strcpy(s, &quot;(&quot;); s += strlen(s);
1518     strncpy(s, _predicate-&gt;_pred, buflen - strlen(s) - 1);
1519     s += strlen(s);
1520     strcpy(s, &quot;)&quot;); s += strlen(s);
1521   }
1522   for( DictI i(&amp;names); i.test(); ++i ) {
1523     uintptr_t cnt = (uintptr_t)i._value;
1524     if( cnt &gt; 1 ) {             // Need a predicate at all?
1525       assert( cnt == 2, &quot;Unimplemented&quot; );
1526       // Handle many pairs
1527       if( first ) first=0;
1528       else {                    // All tests must pass, so use &#39;&amp;&amp;&#39;
1529         strcpy(s,&quot; &amp;&amp; &quot;);
1530         s += strlen(s);
1531       }
</pre>
<hr />
<pre>
1704 }
1705 
1706 Opcode::opcode_type Opcode::as_opcode_type(const char *param) {
1707   if( strcmp(param,&quot;primary&quot;) == 0 ) {
1708     return Opcode::PRIMARY;
1709   }
1710   else if( strcmp(param,&quot;secondary&quot;) == 0 ) {
1711     return Opcode::SECONDARY;
1712   }
1713   else if( strcmp(param,&quot;tertiary&quot;) == 0 ) {
1714     return Opcode::TERTIARY;
1715   }
1716   return Opcode::NOT_AN_OPCODE;
1717 }
1718 
1719 bool Opcode::print_opcode(FILE *fp, Opcode::opcode_type desired_opcode) {
1720   // Default values previously provided by MachNode::primary()...
1721   const char *description = NULL;
1722   const char *value       = NULL;
1723   // Check if user provided any opcode definitions
<span class="line-modified">1724   // Update &#39;value&#39; if user provided a definition in the instruction</span>
<span class="line-modified">1725   switch (desired_opcode) {</span>
<span class="line-modified">1726   case PRIMARY:</span>
<span class="line-modified">1727     description = &quot;primary()&quot;;</span>
<span class="line-modified">1728     if( _primary   != NULL)  { value = _primary;     }</span>
<span class="line-modified">1729     break;</span>
<span class="line-modified">1730   case SECONDARY:</span>
<span class="line-modified">1731     description = &quot;secondary()&quot;;</span>
<span class="line-modified">1732     if( _secondary != NULL ) { value = _secondary;   }</span>
<span class="line-modified">1733     break;</span>
<span class="line-modified">1734   case TERTIARY:</span>
<span class="line-modified">1735     description = &quot;tertiary()&quot;;</span>
<span class="line-modified">1736     if( _tertiary  != NULL ) { value = _tertiary;    }</span>
<span class="line-modified">1737     break;</span>
<span class="line-modified">1738   default:</span>
<span class="line-modified">1739     assert( false, &quot;ShouldNotReachHere();&quot;);</span>
<span class="line-modified">1740     break;</span>


1741   }
<span class="line-added">1742 </span>
1743   if (value != NULL) {
1744     fprintf(fp, &quot;(%s /*%s*/)&quot;, value, description);
1745   }
1746   return value != NULL;
1747 }
1748 
1749 void Opcode::dump() {
1750   output(stderr);
1751 }
1752 
1753 // Write info to output files
1754 void Opcode::output(FILE *fp) {
1755   if (_primary   != NULL) fprintf(fp,&quot;Primary   opcode: %s\n&quot;, _primary);
1756   if (_secondary != NULL) fprintf(fp,&quot;Secondary opcode: %s\n&quot;, _secondary);
1757   if (_tertiary  != NULL) fprintf(fp,&quot;Tertiary  opcode: %s\n&quot;, _tertiary);
1758 }
1759 
1760 //------------------------------InsEncode--------------------------------------
1761 InsEncode::InsEncode() {
1762 }
</pre>
<hr />
<pre>
3390   // If our left child exists, it is the left reduction
3391   if ( mnode-&gt;_lChild ) {
3392     leftStr = mnode-&gt;_lChild-&gt;_internalop ? mnode-&gt;_lChild-&gt;_internalop
3393       : mnode-&gt;_lChild-&gt;_opType;
3394   } else {
3395     // May be simple chain rule: (Set dst operand_form_source)
3396     if ( sets_result() ) {
3397       OperandForm *oper = globals[mnode-&gt;_opType]-&gt;is_operand();
3398       if( oper ) {
3399         leftStr = mnode-&gt;_opType;
3400       }
3401     }
3402   }
3403   return leftStr;
3404 }
3405 
3406 //------------------------------count_instr_names------------------------------
3407 // Count occurrences of operands names in the leaves of the instruction
3408 // match rule.
3409 void MatchNode::count_instr_names( Dict &amp;names ) {

3410   if( _lChild ) _lChild-&gt;count_instr_names(names);
3411   if( _rChild ) _rChild-&gt;count_instr_names(names);
3412   if( !_lChild &amp;&amp; !_rChild ) {
3413     uintptr_t cnt = (uintptr_t)names[_name];
3414     cnt++;                      // One more name found
3415     names.Insert(_name,(void*)cnt);
3416   }
3417 }
3418 
3419 //------------------------------build_instr_pred-------------------------------
3420 // Build a path to &#39;name&#39; in buf.  Actually only build if cnt is zero, so we
3421 // can skip some leading instances of &#39;name&#39;.
3422 int MatchNode::build_instr_pred( char *buf, const char *name, int cnt ) {
3423   if( _lChild ) {
3424     if( !cnt ) strcpy( buf, &quot;_kids[0]-&gt;&quot; );
3425     cnt = _lChild-&gt;build_instr_pred( buf+strlen(buf), name, cnt );
3426     if( cnt &lt; 0 ) return cnt;   // Found it, all done
3427   }
3428   if( _rChild ) {
3429     if( !cnt ) strcpy( buf, &quot;_kids[1]-&gt;&quot; );
</pre>
<hr />
<pre>
3482     fprintf(fp,&quot; (%s &quot;,_name);  // &quot; (opcodeName &quot;
3483     if(_lChild) _lChild-&gt;output(fp); //               left operand
3484     if(_rChild) _rChild-&gt;output(fp); //                    right operand
3485     fprintf(fp,&quot;)&quot;);                 //                                 &quot;)&quot;
3486   }
3487 }
3488 
3489 int MatchNode::needs_ideal_memory_edge(FormDict &amp;globals) const {
3490   static const char *needs_ideal_memory_list[] = {
3491     &quot;StoreI&quot;,&quot;StoreL&quot;,&quot;StoreP&quot;,&quot;StoreN&quot;,&quot;StoreNKlass&quot;,&quot;StoreD&quot;,&quot;StoreF&quot; ,
3492     &quot;StoreB&quot;,&quot;StoreC&quot;,&quot;Store&quot; ,&quot;StoreFP&quot;,
3493     &quot;LoadI&quot;, &quot;LoadL&quot;, &quot;LoadP&quot; ,&quot;LoadN&quot;, &quot;LoadD&quot; ,&quot;LoadF&quot;  ,
3494     &quot;LoadB&quot; , &quot;LoadUB&quot;, &quot;LoadUS&quot; ,&quot;LoadS&quot; ,&quot;Load&quot; ,
3495     &quot;StoreVector&quot;, &quot;LoadVector&quot;,
3496     &quot;LoadRange&quot;, &quot;LoadKlass&quot;, &quot;LoadNKlass&quot;, &quot;LoadL_unaligned&quot;, &quot;LoadD_unaligned&quot;,
3497     &quot;LoadPLocked&quot;,
3498     &quot;StorePConditional&quot;, &quot;StoreIConditional&quot;, &quot;StoreLConditional&quot;,
3499     &quot;CompareAndSwapB&quot;, &quot;CompareAndSwapS&quot;, &quot;CompareAndSwapI&quot;, &quot;CompareAndSwapL&quot;, &quot;CompareAndSwapP&quot;, &quot;CompareAndSwapN&quot;,
3500     &quot;WeakCompareAndSwapB&quot;, &quot;WeakCompareAndSwapS&quot;, &quot;WeakCompareAndSwapI&quot;, &quot;WeakCompareAndSwapL&quot;, &quot;WeakCompareAndSwapP&quot;, &quot;WeakCompareAndSwapN&quot;,
3501     &quot;CompareAndExchangeB&quot;, &quot;CompareAndExchangeS&quot;, &quot;CompareAndExchangeI&quot;, &quot;CompareAndExchangeL&quot;, &quot;CompareAndExchangeP&quot;, &quot;CompareAndExchangeN&quot;,
<span class="line-added">3502 #if INCLUDE_SHENANDOAHGC</span>
3503     &quot;ShenandoahCompareAndSwapN&quot;, &quot;ShenandoahCompareAndSwapP&quot;, &quot;ShenandoahWeakCompareAndSwapP&quot;, &quot;ShenandoahWeakCompareAndSwapN&quot;, &quot;ShenandoahCompareAndExchangeP&quot;, &quot;ShenandoahCompareAndExchangeN&quot;,
<span class="line-added">3504 #endif</span>
3505     &quot;StoreCM&quot;,

3506     &quot;GetAndSetB&quot;, &quot;GetAndSetS&quot;, &quot;GetAndAddI&quot;, &quot;GetAndSetI&quot;, &quot;GetAndSetP&quot;,
3507     &quot;GetAndAddB&quot;, &quot;GetAndAddS&quot;, &quot;GetAndAddL&quot;, &quot;GetAndSetL&quot;, &quot;GetAndSetN&quot;,
<span class="line-modified">3508     &quot;ClearArray&quot;</span>

3509   };
3510   int cnt = sizeof(needs_ideal_memory_list)/sizeof(char*);
3511   if( strcmp(_opType,&quot;PrefetchAllocation&quot;)==0 )
3512     return 1;
<span class="line-added">3513   if( strcmp(_opType,&quot;CacheWB&quot;)==0 )</span>
<span class="line-added">3514     return 1;</span>
<span class="line-added">3515   if( strcmp(_opType,&quot;CacheWBPreSync&quot;)==0 )</span>
<span class="line-added">3516     return 1;</span>
<span class="line-added">3517   if( strcmp(_opType,&quot;CacheWBPostSync&quot;)==0 )</span>
<span class="line-added">3518     return 1;</span>
3519   if( _lChild ) {
3520     const char *opType = _lChild-&gt;_opType;
3521     for( int i=0; i&lt;cnt; i++ )
3522       if( strcmp(opType,needs_ideal_memory_list[i]) == 0 )
3523         return 1;
3524     if( _lChild-&gt;needs_ideal_memory_edge(globals) )
3525       return 1;
3526   }
3527   if( _rChild ) {
3528     const char *opType = _rChild-&gt;_opType;
3529     for( int i=0; i&lt;cnt; i++ )
3530       if( strcmp(opType,needs_ideal_memory_list[i]) == 0 )
3531         return 1;
3532     if( _rChild-&gt;needs_ideal_memory_edge(globals) )
3533       return 1;
3534   }
3535 
3536   return 0;
3537 }
3538 
</pre>
<hr />
<pre>
3791   } else if (mNode2-&gt;_rChild) {
3792     return false; // I have NULL right child, mNode2 has non-NULL right child.
3793   }
3794 
3795   // We&#39;ve made it through the gauntlet.
3796   return true;
3797 }
3798 
3799 //-------------------------- has_commutative_op -------------------------------
3800 // Recursively check for commutative operations with subtree operands
3801 // which could be swapped.
3802 void MatchNode::count_commutative_op(int&amp; count) {
3803   static const char *commut_op_list[] = {
3804     &quot;AddI&quot;,&quot;AddL&quot;,&quot;AddF&quot;,&quot;AddD&quot;,
3805     &quot;AddVB&quot;,&quot;AddVS&quot;,&quot;AddVI&quot;,&quot;AddVL&quot;,&quot;AddVF&quot;,&quot;AddVD&quot;,
3806     &quot;AndI&quot;,&quot;AndL&quot;,
3807     &quot;AndV&quot;,
3808     &quot;MaxI&quot;,&quot;MinI&quot;,&quot;MaxF&quot;,&quot;MinF&quot;,&quot;MaxD&quot;,&quot;MinD&quot;,
3809     &quot;MaxV&quot;, &quot;MinV&quot;,
3810     &quot;MulI&quot;,&quot;MulL&quot;,&quot;MulF&quot;,&quot;MulD&quot;,
<span class="line-modified">3811     &quot;MulVB&quot;,&quot;MulVS&quot;,&quot;MulVI&quot;,&quot;MulVL&quot;,&quot;MulVF&quot;,&quot;MulVD&quot;,</span>
3812     &quot;OrI&quot;,&quot;OrL&quot;,
3813     &quot;OrV&quot;,
3814     &quot;XorI&quot;,&quot;XorL&quot;,
3815     &quot;XorV&quot;
3816   };
3817   int cnt = sizeof(commut_op_list)/sizeof(char*);
3818 
3819   if( _lChild &amp;&amp; _rChild &amp;&amp; (_lChild-&gt;_lChild || _rChild-&gt;_lChild) ) {
3820     // Don&#39;t swap if right operand is an immediate constant.
3821     bool is_const = false;
3822     if( _rChild-&gt;_lChild == NULL &amp;&amp; _rChild-&gt;_rChild == NULL ) {
3823       FormDict &amp;globals = _AD.globalNames();
3824       const Form *form = globals[_rChild-&gt;_opType];
3825       if ( form ) {
3826         OperandForm  *oper = form-&gt;is_operand();
3827         if( oper &amp;&amp; oper-&gt;interface_type(globals) == Form::constant_interface )
3828           is_const = true;
3829       }
3830     }
3831     if( !is_const ) {
</pre>
<hr />
<pre>
3982   if ((_lChild == NULL) &amp;&amp; (_rChild == NULL) ) {
3983     const Form *form = globals[_opType];
3984     // If this is ideal, then it is a base match, not a chain rule.
3985     if ( form &amp;&amp; form-&gt;is_operand() &amp;&amp; (!form-&gt;ideal_only())) {
3986       return true;
3987     }
3988   }
3989   // Check for &quot;Set&quot; form of chain rule, and do not generate a match list
3990   if (_rChild) {
3991     const char *rch = _rChild-&gt;_opType;
3992     const Form *form = globals[rch];
3993     if ((!strcmp(_opType,&quot;Set&quot;) &amp;&amp;
3994          ((form) &amp;&amp; form-&gt;is_operand()))) {
3995       return true;
3996     }
3997   }
3998   return false;
3999 }
4000 
4001 int MatchRule::is_ideal_copy() const {
<span class="line-modified">4002   if (is_chain_rule(_AD.globalNames()) &amp;&amp;</span>
<span class="line-modified">4003       _lChild &amp;&amp; strncmp(_lChild-&gt;_opType, &quot;stackSlot&quot;, 9) == 0) {</span>



























4004     return 1;
<span class="line-added">4005   }</span>
4006   return 0;
4007 }
4008 

4009 int MatchRule::is_expensive() const {
4010   if( _rChild ) {
4011     const char  *opType = _rChild-&gt;_opType;
4012     if( strcmp(opType,&quot;AtanD&quot;)==0 ||
4013         strcmp(opType,&quot;DivD&quot;)==0 ||
4014         strcmp(opType,&quot;DivF&quot;)==0 ||
4015         strcmp(opType,&quot;DivI&quot;)==0 ||
4016         strcmp(opType,&quot;Log10D&quot;)==0 ||
4017         strcmp(opType,&quot;ModD&quot;)==0 ||
4018         strcmp(opType,&quot;ModF&quot;)==0 ||
4019         strcmp(opType,&quot;ModI&quot;)==0 ||
4020         strcmp(opType,&quot;SqrtD&quot;)==0 ||
4021         strcmp(opType,&quot;SqrtF&quot;)==0 ||
4022         strcmp(opType,&quot;TanD&quot;)==0 ||
4023         strcmp(opType,&quot;ConvD2F&quot;)==0 ||
4024         strcmp(opType,&quot;ConvD2I&quot;)==0 ||
4025         strcmp(opType,&quot;ConvD2L&quot;)==0 ||
4026         strcmp(opType,&quot;ConvF2D&quot;)==0 ||
4027         strcmp(opType,&quot;ConvF2I&quot;)==0 ||
4028         strcmp(opType,&quot;ConvF2L&quot;)==0 ||
4029         strcmp(opType,&quot;ConvI2D&quot;)==0 ||
4030         strcmp(opType,&quot;ConvI2F&quot;)==0 ||
4031         strcmp(opType,&quot;ConvI2L&quot;)==0 ||
4032         strcmp(opType,&quot;ConvL2D&quot;)==0 ||
4033         strcmp(opType,&quot;ConvL2F&quot;)==0 ||
4034         strcmp(opType,&quot;ConvL2I&quot;)==0 ||
4035         strcmp(opType,&quot;DecodeN&quot;)==0 ||
4036         strcmp(opType,&quot;EncodeP&quot;)==0 ||
4037         strcmp(opType,&quot;EncodePKlass&quot;)==0 ||
4038         strcmp(opType,&quot;DecodeNKlass&quot;)==0 ||
4039         strcmp(opType,&quot;FmaD&quot;) == 0 ||
4040         strcmp(opType,&quot;FmaF&quot;) == 0 ||
4041         strcmp(opType,&quot;RoundDouble&quot;)==0 ||
<span class="line-added">4042         strcmp(opType,&quot;RoundDoubleMode&quot;)==0 ||</span>
4043         strcmp(opType,&quot;RoundFloat&quot;)==0 ||
4044         strcmp(opType,&quot;ReverseBytesI&quot;)==0 ||
4045         strcmp(opType,&quot;ReverseBytesL&quot;)==0 ||
4046         strcmp(opType,&quot;ReverseBytesUS&quot;)==0 ||
4047         strcmp(opType,&quot;ReverseBytesS&quot;)==0 ||
4048         strcmp(opType,&quot;ReplicateB&quot;)==0 ||
4049         strcmp(opType,&quot;ReplicateS&quot;)==0 ||
4050         strcmp(opType,&quot;ReplicateI&quot;)==0 ||
4051         strcmp(opType,&quot;ReplicateL&quot;)==0 ||
4052         strcmp(opType,&quot;ReplicateF&quot;)==0 ||
4053         strcmp(opType,&quot;ReplicateD&quot;)==0 ||
4054         strcmp(opType,&quot;AddReductionVI&quot;)==0 ||
4055         strcmp(opType,&quot;AddReductionVL&quot;)==0 ||
4056         strcmp(opType,&quot;AddReductionVF&quot;)==0 ||
4057         strcmp(opType,&quot;AddReductionVD&quot;)==0 ||
4058         strcmp(opType,&quot;MulReductionVI&quot;)==0 ||
4059         strcmp(opType,&quot;MulReductionVL&quot;)==0 ||
4060         strcmp(opType,&quot;MulReductionVF&quot;)==0 ||
4061         strcmp(opType,&quot;MulReductionVD&quot;)==0 ||
4062         0 /* 0 to line up columns nicely */ )
</pre>
<hr />
<pre>
4132   }
4133   return false;
4134 }
4135 
4136 
4137 Form::DataType MatchRule::is_ideal_load() const {
4138   Form::DataType ideal_load = Form::none;
4139 
4140   if ( _opType &amp;&amp; (strcmp(_opType,&quot;Set&quot;) == 0) &amp;&amp; _rChild ) {
4141     const char *opType = _rChild-&gt;_opType;
4142     ideal_load = is_load_from_memory(opType);
4143   }
4144 
4145   return ideal_load;
4146 }
4147 
4148 bool MatchRule::is_vector() const {
4149   static const char *vector_list[] = {
4150     &quot;AddVB&quot;,&quot;AddVS&quot;,&quot;AddVI&quot;,&quot;AddVL&quot;,&quot;AddVF&quot;,&quot;AddVD&quot;,
4151     &quot;SubVB&quot;,&quot;SubVS&quot;,&quot;SubVI&quot;,&quot;SubVL&quot;,&quot;SubVF&quot;,&quot;SubVD&quot;,
<span class="line-modified">4152     &quot;MulVB&quot;,&quot;MulVS&quot;,&quot;MulVI&quot;,&quot;MulVL&quot;,&quot;MulVF&quot;,&quot;MulVD&quot;,</span>
4153     &quot;CMoveVD&quot;, &quot;CMoveVF&quot;,
4154     &quot;DivVF&quot;,&quot;DivVD&quot;,
<span class="line-modified">4155     &quot;AbsVB&quot;,&quot;AbsVS&quot;,&quot;AbsVI&quot;,&quot;AbsVL&quot;,&quot;AbsVF&quot;,&quot;AbsVD&quot;,</span>
4156     &quot;NegVF&quot;,&quot;NegVD&quot;,
4157     &quot;SqrtVD&quot;,&quot;SqrtVF&quot;,
4158     &quot;AndV&quot; ,&quot;XorV&quot; ,&quot;OrV&quot;,
4159     &quot;MaxV&quot;, &quot;MinV&quot;,
4160     &quot;AddReductionVI&quot;, &quot;AddReductionVL&quot;,
4161     &quot;AddReductionVF&quot;, &quot;AddReductionVD&quot;,
4162     &quot;MulReductionVI&quot;, &quot;MulReductionVL&quot;,
4163     &quot;MulReductionVF&quot;, &quot;MulReductionVD&quot;,
4164     &quot;MulAddVS2VI&quot;,
4165     &quot;LShiftCntV&quot;,&quot;RShiftCntV&quot;,
4166     &quot;LShiftVB&quot;,&quot;LShiftVS&quot;,&quot;LShiftVI&quot;,&quot;LShiftVL&quot;,
4167     &quot;RShiftVB&quot;,&quot;RShiftVS&quot;,&quot;RShiftVI&quot;,&quot;RShiftVL&quot;,
4168     &quot;URShiftVB&quot;,&quot;URShiftVS&quot;,&quot;URShiftVI&quot;,&quot;URShiftVL&quot;,
4169     &quot;MaxReductionV&quot;, &quot;MinReductionV&quot;,
4170     &quot;ReplicateB&quot;,&quot;ReplicateS&quot;,&quot;ReplicateI&quot;,&quot;ReplicateL&quot;,&quot;ReplicateF&quot;,&quot;ReplicateD&quot;,
<span class="line-modified">4171     &quot;RoundDoubleModeV&quot;,&quot;LoadVector&quot;,&quot;StoreVector&quot;,</span>
4172     &quot;FmaVD&quot;, &quot;FmaVF&quot;,&quot;PopCountVI&quot;,
4173     // Next are not supported currently.
4174     &quot;PackB&quot;,&quot;PackS&quot;,&quot;PackI&quot;,&quot;PackL&quot;,&quot;PackF&quot;,&quot;PackD&quot;,&quot;Pack2L&quot;,&quot;Pack2D&quot;,
4175     &quot;ExtractB&quot;,&quot;ExtractUB&quot;,&quot;ExtractC&quot;,&quot;ExtractS&quot;,&quot;ExtractI&quot;,&quot;ExtractL&quot;,&quot;ExtractF&quot;,&quot;ExtractD&quot;
4176   };
4177   int cnt = sizeof(vector_list)/sizeof(char*);
4178   if (_rChild) {
4179     const char  *opType = _rChild-&gt;_opType;
4180     for (int i=0; i&lt;cnt; i++)
4181       if (strcmp(opType,vector_list[i]) == 0)
4182         return true;
4183   }
4184   return false;
4185 }
4186 
4187 
4188 bool MatchRule::skip_antidep_check() const {
4189   // Some loads operate on what is effectively immutable memory so we
4190   // should skip the anti dep computations.  For some of these nodes
4191   // the rewritable field keeps the anti dep logic from triggering but
</pre>
</td>
</tr>
</table>
<center><a href="formsopt.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="main.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/adlc/formssel.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 // FORMS.CPP - Definitions for ADL Parser Forms Classes
  26 #include &quot;adlc.hpp&quot;
  27 
  28 //==============================Instructions===================================
  29 //------------------------------InstructForm-----------------------------------
  30 InstructForm::InstructForm(const char *id, bool ideal_only)
  31   : _ident(id), _ideal_only(ideal_only),
  32     _localNames(cmpstr, hashstr, Form::arena),
  33     _effects(cmpstr, hashstr, Form::arena),
  34     _is_mach_constant(false),
  35     _needs_constant_base(false),
  36     _has_call(false)
  37 {
  38       _ftype = Form::INS;
  39 
  40       _matrule              = NULL;
  41       _insencode            = NULL;
  42       _constant             = NULL;
  43       _is_postalloc_expand  = false;
  44       _opcode               = NULL;
  45       _size                 = NULL;
  46       _attribs              = NULL;
  47       _predicate            = NULL;
  48       _exprule              = NULL;
  49       _rewrule              = NULL;
  50       _format               = NULL;
  51       _peephole             = NULL;
  52       _ins_pipe             = NULL;
  53       _uniq_idx             = NULL;
  54       _num_uniq             = 0;
  55       _cisc_spill_operand   = Not_cisc_spillable;// Which operand may cisc-spill
  56       _cisc_spill_alternate = NULL;            // possible cisc replacement
  57       _cisc_reg_mask_name   = NULL;
  58       _is_cisc_alternate    = false;
  59       _is_short_branch      = false;
  60       _short_branch_form    = NULL;
  61       _alignment            = 1;
  62 }
  63 
  64 InstructForm::InstructForm(const char *id, InstructForm *instr, MatchRule *rule)
  65   : _ident(id), _ideal_only(false),
  66     _localNames(instr-&gt;_localNames),
  67     _effects(instr-&gt;_effects),
  68     _is_mach_constant(false),
  69     _needs_constant_base(false),
  70     _has_call(false)
  71 {
  72       _ftype = Form::INS;
  73 
  74       _matrule               = rule;
  75       _insencode             = instr-&gt;_insencode;
  76       _constant              = instr-&gt;_constant;
  77       _is_postalloc_expand   = instr-&gt;_is_postalloc_expand;
  78       _opcode                = instr-&gt;_opcode;
  79       _size                  = instr-&gt;_size;
  80       _attribs               = instr-&gt;_attribs;
  81       _predicate             = instr-&gt;_predicate;
  82       _exprule               = instr-&gt;_exprule;
  83       _rewrule               = instr-&gt;_rewrule;
  84       _format                = instr-&gt;_format;
  85       _peephole              = instr-&gt;_peephole;
  86       _ins_pipe              = instr-&gt;_ins_pipe;
  87       _uniq_idx              = instr-&gt;_uniq_idx;
  88       _num_uniq              = instr-&gt;_num_uniq;
  89       _cisc_spill_operand    = Not_cisc_spillable; // Which operand may cisc-spill
  90       _cisc_spill_alternate  = NULL;               // possible cisc replacement
  91       _cisc_reg_mask_name    = NULL;
  92       _is_cisc_alternate     = false;
  93       _is_short_branch       = false;
  94       _short_branch_form     = NULL;
  95       _alignment             = 1;
  96      // Copy parameters
  97      const char *name;
  98      instr-&gt;_parameters.reset();
  99      for (; (name = instr-&gt;_parameters.iter()) != NULL;)
 100        _parameters.addName(name);
 101 }
 102 
 103 InstructForm::~InstructForm() {
 104 }
 105 
 106 InstructForm *InstructForm::is_instruction() const {
 107   return (InstructForm*)this;
 108 }
 109 
 110 bool InstructForm::ideal_only() const {
 111   return _ideal_only;
 112 }
 113 
 114 bool InstructForm::sets_result() const {
 115   return (_matrule != NULL &amp;&amp; _matrule-&gt;sets_result());
 116 }
 117 
 118 bool InstructForm::needs_projections() {
 119   _components.reset();
 120   for( Component *comp; (comp = _components.iter()) != NULL; ) {
 121     if (comp-&gt;isa(Component::KILL)) {
 122       return true;
 123     }
 124   }
 125   return false;
 126 }
 127 
 128 
 129 bool InstructForm::has_temps() {
 130   if (_matrule) {
 131     // Examine each component to see if it is a TEMP
 132     _components.reset();
 133     // Skip the first component, if already handled as (SET dst (...))
 134     Component *comp = NULL;
 135     if (sets_result())  comp = _components.iter();
 136     while ((comp = _components.iter()) != NULL) {
 137       if (comp-&gt;isa(Component::TEMP)) {
 138         return true;
 139       }
 140     }
 141   }
 142 
 143   return false;
 144 }
 145 
 146 uint InstructForm::num_defs_or_kills() {
 147   uint   defs_or_kills = 0;
 148 
 149   _components.reset();
 150   for( Component *comp; (comp = _components.iter()) != NULL; ) {
 151     if( comp-&gt;isa(Component::DEF) || comp-&gt;isa(Component::KILL) ) {
 152       ++defs_or_kills;
 153     }
 154   }
 155 
 156   return  defs_or_kills;
 157 }
 158 
 159 // This instruction has an expand rule?
 160 bool InstructForm::expands() const {
 161   return ( _exprule != NULL );
 162 }
 163 
 164 // This instruction has a late expand rule?
 165 bool InstructForm::postalloc_expands() const {
 166   return _is_postalloc_expand;
 167 }
 168 
 169 // This instruction has a peephole rule?
 170 Peephole *InstructForm::peepholes() const {
 171   return _peephole;
 172 }
 173 
 174 // This instruction has a peephole rule?
 175 void InstructForm::append_peephole(Peephole *peephole) {
 176   if( _peephole == NULL ) {
 177     _peephole = peephole;
 178   } else {
 179     _peephole-&gt;append_peephole(peephole);
 180   }
 181 }
 182 
 183 
 184 // ideal opcode enumeration
 185 const char *InstructForm::ideal_Opcode( FormDict &amp;globalNames )  const {
 186   if( !_matrule ) return &quot;Node&quot;; // Something weird
 187   // Chain rules do not really have ideal Opcodes; use their source
 188   // operand ideal Opcode instead.
 189   if( is_simple_chain_rule(globalNames) ) {
 190     const char *src = _matrule-&gt;_rChild-&gt;_opType;
 191     OperandForm *src_op = globalNames[src]-&gt;is_operand();
 192     assert( src_op, &quot;Not operand class of chain rule&quot; );
 193     if( !src_op-&gt;_matrule ) return &quot;Node&quot;;
 194     return src_op-&gt;_matrule-&gt;_opType;
 195   }
 196   // Operand chain rules do not really have ideal Opcodes
 197   if( _matrule-&gt;is_chain_rule(globalNames) )
 198     return &quot;Node&quot;;
 199   return strcmp(_matrule-&gt;_opType,&quot;Set&quot;)
 200     ? _matrule-&gt;_opType
 201     : _matrule-&gt;_rChild-&gt;_opType;
 202 }
 203 
 204 // Recursive check on all operands&#39; match rules in my match rule
 205 bool InstructForm::is_pinned(FormDict &amp;globals) {
 206   if ( ! _matrule)  return false;
 207 
 208   int  index   = 0;
 209   if (_matrule-&gt;find_type(&quot;Goto&quot;,          index)) return true;
 210   if (_matrule-&gt;find_type(&quot;If&quot;,            index)) return true;
 211   if (_matrule-&gt;find_type(&quot;CountedLoopEnd&quot;,index)) return true;
 212   if (_matrule-&gt;find_type(&quot;Return&quot;,        index)) return true;
 213   if (_matrule-&gt;find_type(&quot;Rethrow&quot;,       index)) return true;
 214   if (_matrule-&gt;find_type(&quot;TailCall&quot;,      index)) return true;
 215   if (_matrule-&gt;find_type(&quot;TailJump&quot;,      index)) return true;
 216   if (_matrule-&gt;find_type(&quot;Halt&quot;,          index)) return true;
 217   if (_matrule-&gt;find_type(&quot;Jump&quot;,          index)) return true;
 218 
 219   return is_parm(globals);
 220 }
 221 
 222 // Recursive check on all operands&#39; match rules in my match rule
 223 bool InstructForm::is_projection(FormDict &amp;globals) {
 224   if ( ! _matrule)  return false;
 225 
 226   int  index   = 0;
 227   if (_matrule-&gt;find_type(&quot;Goto&quot;,    index)) return true;
 228   if (_matrule-&gt;find_type(&quot;Return&quot;,  index)) return true;
 229   if (_matrule-&gt;find_type(&quot;Rethrow&quot;, index)) return true;
 230   if (_matrule-&gt;find_type(&quot;TailCall&quot;,index)) return true;
 231   if (_matrule-&gt;find_type(&quot;TailJump&quot;,index)) return true;
 232   if (_matrule-&gt;find_type(&quot;Halt&quot;,    index)) return true;
 233 
 234   return false;
 235 }
 236 
 237 // Recursive check on all operands&#39; match rules in my match rule
 238 bool InstructForm::is_parm(FormDict &amp;globals) {
 239   if ( ! _matrule)  return false;
 240 
 241   int  index   = 0;
 242   if (_matrule-&gt;find_type(&quot;Parm&quot;,index)) return true;
 243 
 244   return false;
 245 }
 246 
 247 bool InstructForm::is_ideal_negD() const {
 248   return (_matrule &amp;&amp; _matrule-&gt;_rChild &amp;&amp; strcmp(_matrule-&gt;_rChild-&gt;_opType, &quot;NegD&quot;) == 0);
 249 }
 250 
 251 // Return &#39;true&#39; if this instruction matches an ideal &#39;Copy*&#39; node
 252 int InstructForm::is_ideal_copy() const {
 253   return _matrule ? _matrule-&gt;is_ideal_copy() : 0;
 254 }
 255 
 256 // Return &#39;true&#39; if this instruction is too complex to rematerialize.
 257 int InstructForm::is_expensive() const {
 258   // We can prove it is cheap if it has an empty encoding.
 259   // This helps with platform-specific nops like ThreadLocal and RoundFloat.
 260   if (is_empty_encoding())
 261     return 0;
 262 
 263   if (is_tls_instruction())
 264     return 1;
 265 
 266   if (_matrule == NULL)  return 0;
 267 
 268   return _matrule-&gt;is_expensive();
 269 }
 270 
 271 // Has an empty encoding if _size is a constant zero or there
 272 // are no ins_encode tokens.
 273 int InstructForm::is_empty_encoding() const {
 274   if (_insencode != NULL) {
 275     _insencode-&gt;reset();
 276     if (_insencode-&gt;encode_class_iter() == NULL) {
 277       return 1;
 278     }
 279   }
 280   if (_size != NULL &amp;&amp; strcmp(_size, &quot;0&quot;) == 0) {
 281     return 1;
 282   }
 283   return 0;
 284 }
 285 
 286 int InstructForm::is_tls_instruction() const {
 287   if (_ident != NULL &amp;&amp;
 288       ( ! strcmp( _ident,&quot;tlsLoadP&quot;) ||
 289         ! strncmp(_ident,&quot;tlsLoadP_&quot;,9)) ) {
 290     return 1;
 291   }
 292 
 293   if (_matrule != NULL &amp;&amp; _insencode != NULL) {
 294     const char* opType = _matrule-&gt;_opType;
 295     if (strcmp(opType, &quot;Set&quot;)==0)
 296       opType = _matrule-&gt;_rChild-&gt;_opType;
 297     if (strcmp(opType,&quot;ThreadLocal&quot;)==0) {
 298       fprintf(stderr, &quot;Warning: ThreadLocal instruction %s should be named &#39;tlsLoadP_*&#39;\n&quot;,
 299               (_ident == NULL ? &quot;NULL&quot; : _ident));
 300       return 1;
 301     }
 302   }
 303 
 304   return 0;
 305 }
 306 
 307 
 308 // Return &#39;true&#39; if this instruction matches an ideal &#39;If&#39; node
 309 bool InstructForm::is_ideal_if() const {
 310   if( _matrule == NULL ) return false;
 311 
 312   return _matrule-&gt;is_ideal_if();
 313 }
 314 
 315 // Return &#39;true&#39; if this instruction matches an ideal &#39;FastLock&#39; node
 316 bool InstructForm::is_ideal_fastlock() const {
 317   if( _matrule == NULL ) return false;
 318 
 319   return _matrule-&gt;is_ideal_fastlock();
 320 }
 321 
 322 // Return &#39;true&#39; if this instruction matches an ideal &#39;MemBarXXX&#39; node
 323 bool InstructForm::is_ideal_membar() const {
 324   if( _matrule == NULL ) return false;
 325 
 326   return _matrule-&gt;is_ideal_membar();
 327 }
 328 
 329 // Return &#39;true&#39; if this instruction matches an ideal &#39;LoadPC&#39; node
 330 bool InstructForm::is_ideal_loadPC() const {
 331   if( _matrule == NULL ) return false;
 332 
 333   return _matrule-&gt;is_ideal_loadPC();
 334 }
 335 
 336 // Return &#39;true&#39; if this instruction matches an ideal &#39;Box&#39; node
 337 bool InstructForm::is_ideal_box() const {
 338   if( _matrule == NULL ) return false;
 339 
 340   return _matrule-&gt;is_ideal_box();
 341 }
 342 
 343 // Return &#39;true&#39; if this instruction matches an ideal &#39;Goto&#39; node
 344 bool InstructForm::is_ideal_goto() const {
 345   if( _matrule == NULL ) return false;
 346 
 347   return _matrule-&gt;is_ideal_goto();
 348 }
 349 
 350 // Return &#39;true&#39; if this instruction matches an ideal &#39;Jump&#39; node
 351 bool InstructForm::is_ideal_jump() const {
 352   if( _matrule == NULL ) return false;
 353 
 354   return _matrule-&gt;is_ideal_jump();
 355 }
 356 
 357 // Return &#39;true&#39; if instruction matches ideal &#39;If&#39; | &#39;Goto&#39; | &#39;CountedLoopEnd&#39;
 358 bool InstructForm::is_ideal_branch() const {
 359   if( _matrule == NULL ) return false;
 360 
 361   return _matrule-&gt;is_ideal_if() || _matrule-&gt;is_ideal_goto();
 362 }
 363 
 364 
 365 // Return &#39;true&#39; if this instruction matches an ideal &#39;Return&#39; node
 366 bool InstructForm::is_ideal_return() const {
 367   if( _matrule == NULL ) return false;
 368 
 369   // Check MatchRule to see if the first entry is the ideal &quot;Return&quot; node
 370   int  index   = 0;
 371   if (_matrule-&gt;find_type(&quot;Return&quot;,index)) return true;
 372   if (_matrule-&gt;find_type(&quot;Rethrow&quot;,index)) return true;
 373   if (_matrule-&gt;find_type(&quot;TailCall&quot;,index)) return true;
 374   if (_matrule-&gt;find_type(&quot;TailJump&quot;,index)) return true;
 375 
 376   return false;
 377 }
 378 
 379 // Return &#39;true&#39; if this instruction matches an ideal &#39;Halt&#39; node
 380 bool InstructForm::is_ideal_halt() const {
 381   int  index   = 0;
 382   return _matrule &amp;&amp; _matrule-&gt;find_type(&quot;Halt&quot;,index);
 383 }
 384 
 385 // Return &#39;true&#39; if this instruction matches an ideal &#39;SafePoint&#39; node
 386 bool InstructForm::is_ideal_safepoint() const {
 387   int  index   = 0;
 388   return _matrule &amp;&amp; _matrule-&gt;find_type(&quot;SafePoint&quot;,index);
 389 }
 390 
 391 // Return &#39;true&#39; if this instruction matches an ideal &#39;Nop&#39; node
 392 bool InstructForm::is_ideal_nop() const {
 393   return _ident &amp;&amp; _ident[0] == &#39;N&#39; &amp;&amp; _ident[1] == &#39;o&#39; &amp;&amp; _ident[2] == &#39;p&#39; &amp;&amp; _ident[3] == &#39;_&#39;;
 394 }
 395 
 396 bool InstructForm::is_ideal_control() const {
 397   if ( ! _matrule)  return false;
 398 
 399   return is_ideal_return() || is_ideal_branch() || _matrule-&gt;is_ideal_jump() || is_ideal_halt();
 400 }
 401 
 402 // Return &#39;true&#39; if this instruction matches an ideal &#39;Call&#39; node
 403 Form::CallType InstructForm::is_ideal_call() const {
 404   if( _matrule == NULL ) return Form::invalid_type;
 405 
 406   // Check MatchRule to see if the first entry is the ideal &quot;Call&quot; node
 407   int  idx   = 0;
 408   if(_matrule-&gt;find_type(&quot;CallStaticJava&quot;,idx))   return Form::JAVA_STATIC;
 409   idx = 0;
 410   if(_matrule-&gt;find_type(&quot;Lock&quot;,idx))             return Form::JAVA_STATIC;
 411   idx = 0;
 412   if(_matrule-&gt;find_type(&quot;Unlock&quot;,idx))           return Form::JAVA_STATIC;
 413   idx = 0;
 414   if(_matrule-&gt;find_type(&quot;CallDynamicJava&quot;,idx))  return Form::JAVA_DYNAMIC;
 415   idx = 0;
 416   if(_matrule-&gt;find_type(&quot;CallRuntime&quot;,idx))      return Form::JAVA_RUNTIME;
 417   idx = 0;
 418   if(_matrule-&gt;find_type(&quot;CallLeaf&quot;,idx))         return Form::JAVA_LEAF;
 419   idx = 0;
 420   if(_matrule-&gt;find_type(&quot;CallLeafNoFP&quot;,idx))     return Form::JAVA_LEAF;
 421   idx = 0;
 422 
 423   return Form::invalid_type;
 424 }
 425 
 426 // Return &#39;true&#39; if this instruction matches an ideal &#39;Load?&#39; node
 427 Form::DataType InstructForm::is_ideal_load() const {
 428   if( _matrule == NULL ) return Form::none;
 429 
 430   return  _matrule-&gt;is_ideal_load();
 431 }
 432 
 433 // Return &#39;true&#39; if this instruction matches an ideal &#39;LoadKlass&#39; node
 434 bool InstructForm::skip_antidep_check() const {
 435   if( _matrule == NULL ) return false;
 436 
 437   return  _matrule-&gt;skip_antidep_check();
 438 }
 439 
 440 // Return &#39;true&#39; if this instruction matches an ideal &#39;Load?&#39; node
 441 Form::DataType InstructForm::is_ideal_store() const {
 442   if( _matrule == NULL ) return Form::none;
 443 
 444   return  _matrule-&gt;is_ideal_store();
 445 }
 446 
 447 // Return &#39;true&#39; if this instruction matches an ideal vector node
 448 bool InstructForm::is_vector() const {
 449   if( _matrule == NULL ) return false;
 450 
 451   return _matrule-&gt;is_vector();
 452 }
 453 
 454 
 455 // Return the input register that must match the output register
 456 // If this is not required, return 0
 457 uint InstructForm::two_address(FormDict &amp;globals) {
 458   uint  matching_input = 0;
 459   if(_components.count() == 0) return 0;
 460 
 461   _components.reset();
 462   Component *comp = _components.iter();
 463   // Check if there is a DEF
 464   if( comp-&gt;isa(Component::DEF) ) {
 465     // Check that this is a register
 466     const char  *def_type = comp-&gt;_type;
 467     const Form  *form     = globals[def_type];
 468     OperandForm *op       = form-&gt;is_operand();
 469     if( op ) {
 470       if( op-&gt;constrained_reg_class() != NULL &amp;&amp;
 471           op-&gt;interface_type(globals) == Form::register_interface ) {
 472         // Remember the local name for equality test later
 473         const char *def_name = comp-&gt;_name;
 474         // Check if a component has the same name and is a USE
 475         do {
 476           if( comp-&gt;isa(Component::USE) &amp;&amp; strcmp(comp-&gt;_name,def_name)==0 ) {
 477             return operand_position_format(def_name);
 478           }
 479         } while( (comp = _components.iter()) != NULL);
 480       }
 481     }
 482   }
 483 
 484   return 0;
 485 }
 486 
 487 
 488 // when chaining a constant to an instruction, returns &#39;true&#39; and sets opType
 489 Form::DataType InstructForm::is_chain_of_constant(FormDict &amp;globals) {
 490   const char *dummy  = NULL;
 491   const char *dummy2 = NULL;
 492   return is_chain_of_constant(globals, dummy, dummy2);
 493 }
 494 Form::DataType InstructForm::is_chain_of_constant(FormDict &amp;globals,
 495                 const char * &amp;opTypeParam) {
 496   const char *result = NULL;
 497 
 498   return is_chain_of_constant(globals, opTypeParam, result);
 499 }
 500 
 501 Form::DataType InstructForm::is_chain_of_constant(FormDict &amp;globals,
 502                 const char * &amp;opTypeParam, const char * &amp;resultParam) {
 503   Form::DataType  data_type = Form::none;
 504   if ( ! _matrule)  return data_type;
 505 
 506   // !!!!!
 507   // The source of the chain rule is &#39;position = 1&#39;
 508   uint         position = 1;
 509   const char  *result   = NULL;
 510   const char  *name     = NULL;
 511   const char  *opType   = NULL;
 512   // Here base_operand is looking for an ideal type to be returned (opType).
 513   if ( _matrule-&gt;is_chain_rule(globals)
 514        &amp;&amp; _matrule-&gt;base_operand(position, globals, result, name, opType) ) {
 515     data_type = ideal_to_const_type(opType);
 516 
 517     // if it isn&#39;t an ideal constant type, just return
 518     if ( data_type == Form::none ) return data_type;
 519 
 520     // Ideal constant types also adjust the opType parameter.
 521     resultParam = result;
 522     opTypeParam = opType;
 523     return data_type;
 524   }
 525 
 526   return data_type;
 527 }
 528 
 529 // Check if a simple chain rule
 530 bool InstructForm::is_simple_chain_rule(FormDict &amp;globals) const {
 531   if( _matrule &amp;&amp; _matrule-&gt;sets_result()
 532       &amp;&amp; _matrule-&gt;_rChild-&gt;_lChild == NULL
 533       &amp;&amp; globals[_matrule-&gt;_rChild-&gt;_opType]
 534       &amp;&amp; globals[_matrule-&gt;_rChild-&gt;_opType]-&gt;is_opclass() ) {
 535     return true;
 536   }
 537   return false;
 538 }
 539 
 540 // check for structural rematerialization
 541 bool InstructForm::rematerialize(FormDict &amp;globals, RegisterForm *registers ) {
 542   bool   rematerialize = false;
 543 
 544   Form::DataType data_type = is_chain_of_constant(globals);
 545   if( data_type != Form::none )
 546     rematerialize = true;
 547 
 548   // Constants
 549   if( _components.count() == 1 &amp;&amp; _components[0]-&gt;is(Component::USE_DEF) )
 550     rematerialize = true;
 551 
 552   // Pseudo-constants (values easily available to the runtime)
 553   if (is_empty_encoding() &amp;&amp; is_tls_instruction())
 554     rematerialize = true;
 555 
 556   // 1-input, 1-output, such as copies or increments.
 557   if( _components.count() == 2 &amp;&amp;
 558       _components[0]-&gt;is(Component::DEF) &amp;&amp;
 559       _components[1]-&gt;isa(Component::USE) )
 560     rematerialize = true;
 561 
 562   // Check for an ideal &#39;Load?&#39; and eliminate rematerialize option
 563   if ( is_ideal_load() != Form::none || // Ideal load?  Do not rematerialize
 564        is_ideal_copy() != Form::none || // Ideal copy?  Do not rematerialize
 565        is_expensive()  != Form::none) { // Expensive?   Do not rematerialize
 566     rematerialize = false;
 567   }
 568 
 569   // Always rematerialize the flags.  They are more expensive to save &amp;
 570   // restore than to recompute (and possibly spill the compare&#39;s inputs).
 571   if( _components.count() &gt;= 1 ) {
 572     Component *c = _components[0];
 573     const Form *form = globals[c-&gt;_type];
 574     OperandForm *opform = form-&gt;is_operand();
 575     if( opform ) {
 576       // Avoid the special stack_slots register classes
 577       const char *rc_name = opform-&gt;constrained_reg_class();
 578       if( rc_name ) {
 579         if( strcmp(rc_name,&quot;stack_slots&quot;) ) {
 580           // Check for ideal_type of RegFlags
 581           const char *type = opform-&gt;ideal_type( globals, registers );
 582           if( (type != NULL) &amp;&amp; !strcmp(type, &quot;RegFlags&quot;) )
 583             rematerialize = true;
 584         } else
 585           rematerialize = false; // Do not rematerialize things target stk
 586       }
 587     }
 588   }
 589 
 590   return rematerialize;
 591 }
 592 
 593 // loads from memory, so must check for anti-dependence
 594 bool InstructForm::needs_anti_dependence_check(FormDict &amp;globals) const {
 595   if ( skip_antidep_check() ) return false;
 596 
 597   // Machine independent loads must be checked for anti-dependences
 598   if( is_ideal_load() != Form::none )  return true;
 599 
 600   // !!!!! !!!!! !!!!!
 601   // TEMPORARY
 602   // if( is_simple_chain_rule(globals) )  return false;
 603 
 604   // String.(compareTo/equals/indexOf) and Arrays.equals use many memorys edges,
 605   // but writes none
 606   if( _matrule &amp;&amp; _matrule-&gt;_rChild &amp;&amp;
 607       ( strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;StrComp&quot;    )==0 ||
 608         strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;StrEquals&quot;  )==0 ||
 609         strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;StrIndexOf&quot; )==0 ||
 610         strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;StrIndexOfChar&quot; )==0 ||
 611         strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;HasNegatives&quot; )==0 ||
 612         strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;AryEq&quot;      )==0 ))
 613     return true;
 614 
 615   // Check if instruction has a USE of a memory operand class, but no defs
 616   bool USE_of_memory  = false;
 617   bool DEF_of_memory  = false;
 618   Component     *comp = NULL;
 619   ComponentList &amp;components = (ComponentList &amp;)_components;
 620 
 621   components.reset();
 622   while( (comp = components.iter()) != NULL ) {
 623     const Form  *form = globals[comp-&gt;_type];
 624     if( !form ) continue;
 625     OpClassForm *op   = form-&gt;is_opclass();
 626     if( !op ) continue;
 627     if( form-&gt;interface_type(globals) == Form::memory_interface ) {
 628       if( comp-&gt;isa(Component::USE) ) USE_of_memory = true;
 629       if( comp-&gt;isa(Component::DEF) ) {
 630         OperandForm *oper = form-&gt;is_operand();
 631         if( oper &amp;&amp; oper-&gt;is_user_name_for_sReg() ) {
 632           // Stack slots are unaliased memory handled by allocator
 633           oper = oper;  // debug stopping point !!!!!
 634         } else {
 635           DEF_of_memory = true;
 636         }
 637       }
 638     }
 639   }
 640   return (USE_of_memory &amp;&amp; !DEF_of_memory);
 641 }
 642 
 643 
 644 int InstructForm::memory_operand(FormDict &amp;globals) const {
 645   // Machine independent loads must be checked for anti-dependences
 646   // Check if instruction has a USE of a memory operand class, or a def.
 647   int USE_of_memory  = 0;
 648   int DEF_of_memory  = 0;
 649   const char*    last_memory_DEF = NULL; // to test DEF/USE pairing in asserts
 650   const char*    last_memory_USE = NULL;
 651   Component     *unique          = NULL;
 652   Component     *comp            = NULL;
 653   ComponentList &amp;components      = (ComponentList &amp;)_components;
 654 
 655   components.reset();
 656   while( (comp = components.iter()) != NULL ) {
 657     const Form  *form = globals[comp-&gt;_type];
 658     if( !form ) continue;
 659     OpClassForm *op   = form-&gt;is_opclass();
 660     if( !op ) continue;
 661     if( op-&gt;stack_slots_only(globals) )  continue;
 662     if( form-&gt;interface_type(globals) == Form::memory_interface ) {
 663       if( comp-&gt;isa(Component::DEF) ) {
 664         last_memory_DEF = comp-&gt;_name;
 665         DEF_of_memory++;
 666         unique = comp;
 667       } else if( comp-&gt;isa(Component::USE) ) {
 668         if( last_memory_DEF != NULL ) {
 669           assert(0 == strcmp(last_memory_DEF, comp-&gt;_name), &quot;every memory DEF is followed by a USE of the same name&quot;);
 670           last_memory_DEF = NULL;
 671         }
 672         // Handles same memory being used multiple times in the case of BMI1 instructions.
 673         if (last_memory_USE != NULL) {
 674           if (strcmp(comp-&gt;_name, last_memory_USE) != 0) {
 675             USE_of_memory++;
 676           }
 677         } else {
 678           USE_of_memory++;
 679         }
 680         last_memory_USE = comp-&gt;_name;
 681 
 682         if (DEF_of_memory == 0)  // defs take precedence
 683           unique = comp;
 684       } else {
 685         assert(last_memory_DEF == NULL, &quot;unpaired memory DEF&quot;);
 686       }
 687     }
 688   }
 689   assert(last_memory_DEF == NULL, &quot;unpaired memory DEF&quot;);
 690   assert(USE_of_memory &gt;= DEF_of_memory, &quot;unpaired memory DEF&quot;);
 691   USE_of_memory -= DEF_of_memory;   // treat paired DEF/USE as one occurrence
 692   if( (USE_of_memory + DEF_of_memory) &gt; 0 ) {
 693     if( is_simple_chain_rule(globals) ) {
 694       //fprintf(stderr, &quot;Warning: chain rule is not really a memory user.\n&quot;);
 695       //((InstructForm*)this)-&gt;dump();
 696       // Preceding code prints nothing on sparc and these insns on intel:
 697       // leaP8 leaP32 leaPIdxOff leaPIdxScale leaPIdxScaleOff leaP8 leaP32
 698       // leaPIdxOff leaPIdxScale leaPIdxScaleOff
 699       return NO_MEMORY_OPERAND;
 700     }
 701 
 702     if( DEF_of_memory == 1 ) {
 703       assert(unique != NULL, &quot;&quot;);
 704       if( USE_of_memory == 0 ) {
 705         // unique def, no uses
 706       } else {
 707         // // unique def, some uses
 708         // // must return bottom unless all uses match def
 709         // unique = NULL;
 710 #ifdef S390
 711         // This case is important for move instructions on s390x.
 712         // On other platforms (e.g. x86), all uses always match the def.
 713         unique = NULL;
 714 #endif
 715       }
 716     } else if( DEF_of_memory &gt; 0 ) {
 717       // multiple defs, don&#39;t care about uses
 718       unique = NULL;
 719     } else if( USE_of_memory == 1) {
 720       // unique use, no defs
 721       assert(unique != NULL, &quot;&quot;);
 722     } else if( USE_of_memory &gt; 0 ) {
 723       // multiple uses, no defs
 724       unique = NULL;
 725     } else {
 726       assert(false, &quot;bad case analysis&quot;);
 727     }
 728     // process the unique DEF or USE, if there is one
 729     if( unique == NULL ) {
 730       return MANY_MEMORY_OPERANDS;
 731     } else {
 732       int pos = components.operand_position(unique-&gt;_name);
 733       if( unique-&gt;isa(Component::DEF) ) {
 734         pos += 1;                // get corresponding USE from DEF
 735       }
 736       assert(pos &gt;= 1, &quot;I was just looking at it!&quot;);
 737       return pos;
 738     }
 739   }
 740 
 741   // missed the memory op??
 742   if( true ) {  // %%% should not be necessary
 743     if( is_ideal_store() != Form::none ) {
 744       fprintf(stderr, &quot;Warning: cannot find memory opnd in instr.\n&quot;);
 745       ((InstructForm*)this)-&gt;dump();
 746       // pretend it has multiple defs and uses
 747       return MANY_MEMORY_OPERANDS;
 748     }
 749     if( is_ideal_load()  != Form::none ) {
 750       fprintf(stderr, &quot;Warning: cannot find memory opnd in instr.\n&quot;);
 751       ((InstructForm*)this)-&gt;dump();
 752       // pretend it has multiple uses and no defs
 753       return MANY_MEMORY_OPERANDS;
 754     }
 755   }
 756 
 757   return NO_MEMORY_OPERAND;
 758 }
 759 
<a name="2" id="anc2"></a><span class="line-removed"> 760 </span>
 761 // This instruction captures the machine-independent bottom_type
 762 // Expected use is for pointer vs oop determination for LoadP
 763 bool InstructForm::captures_bottom_type(FormDict &amp;globals) const {
 764   if (_matrule &amp;&amp; _matrule-&gt;_rChild &amp;&amp;
 765       (!strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;CastPP&quot;)       ||  // new result type
 766        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;CastX2P&quot;)      ||  // new result type
 767        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;DecodeN&quot;)      ||
 768        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;EncodeP&quot;)      ||
 769        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;DecodeNKlass&quot;) ||
 770        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;EncodePKlass&quot;) ||
 771        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;LoadN&quot;)        ||
 772        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;LoadNKlass&quot;)   ||
 773        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;CreateEx&quot;)     ||  // type of exception
 774        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;CheckCastPP&quot;)  ||
 775        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;GetAndSetP&quot;)   ||
 776        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;GetAndSetN&quot;)   ||
<a name="3" id="anc3"></a><span class="line-modified"> 777        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;CompareAndExchangeP&quot;) ||</span>
<span class="line-removed"> 778        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;CompareAndExchangeN&quot;) ||</span>
 779        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;ShenandoahCompareAndExchangeP&quot;) ||
 780        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;ShenandoahCompareAndExchangeN&quot;) ||
<a name="4" id="anc4"></a><span class="line-modified"> 781        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;ShenandoahReadBarrier&quot;)))  return true;</span>


 782   else if ( is_ideal_load() == Form::idealP )                return true;
 783   else if ( is_ideal_store() != Form::none  )                return true;
 784 
 785   if (needs_base_oop_edge(globals)) return true;
 786 
 787   if (is_vector()) return true;
 788   if (is_mach_constant()) return true;
 789 
 790   return  false;
 791 }
 792 
 793 
 794 // Access instr_cost attribute or return NULL.
 795 const char* InstructForm::cost() {
 796   for (Attribute* cur = _attribs; cur != NULL; cur = (Attribute*)cur-&gt;_next) {
 797     if( strcmp(cur-&gt;_ident,AttributeForm::_ins_cost) == 0 ) {
 798       return cur-&gt;_val;
 799     }
 800   }
 801   return NULL;
 802 }
 803 
 804 // Return count of top-level operands.
 805 uint InstructForm::num_opnds() {
 806   int  num_opnds = _components.num_operands();
 807 
 808   // Need special handling for matching some ideal nodes
 809   // i.e. Matching a return node
 810   /*
 811   if( _matrule ) {
 812     if( strcmp(_matrule-&gt;_opType,&quot;Return&quot;   )==0 ||
 813         strcmp(_matrule-&gt;_opType,&quot;Halt&quot;     )==0 )
 814       return 3;
 815   }
 816     */
 817   return num_opnds;
 818 }
 819 
 820 const char* InstructForm::opnd_ident(int idx) {
 821   return _components.at(idx)-&gt;_name;
 822 }
 823 
 824 const char* InstructForm::unique_opnd_ident(uint idx) {
 825   uint i;
 826   for (i = 1; i &lt; num_opnds(); ++i) {
 827     if (unique_opnds_idx(i) == idx) {
 828       break;
 829     }
 830   }
 831   return (_components.at(i) != NULL) ? _components.at(i)-&gt;_name : &quot;&quot;;
 832 }
 833 
 834 // Return count of unmatched operands.
 835 uint InstructForm::num_post_match_opnds() {
 836   uint  num_post_match_opnds = _components.count();
 837   uint  num_match_opnds = _components.match_count();
 838   num_post_match_opnds = num_post_match_opnds - num_match_opnds;
 839 
 840   return num_post_match_opnds;
 841 }
 842 
 843 // Return the number of leaves below this complex operand
 844 uint InstructForm::num_consts(FormDict &amp;globals) const {
 845   if ( ! _matrule) return 0;
 846 
 847   // This is a recursive invocation on all operands in the matchrule
 848   return _matrule-&gt;num_consts(globals);
 849 }
 850 
 851 // Constants in match rule with specified type
 852 uint InstructForm::num_consts(FormDict &amp;globals, Form::DataType type) const {
 853   if ( ! _matrule) return 0;
 854 
 855   // This is a recursive invocation on all operands in the matchrule
 856   return _matrule-&gt;num_consts(globals, type);
 857 }
 858 
 859 
 860 // Return the register class associated with &#39;leaf&#39;.
 861 const char *InstructForm::out_reg_class(FormDict &amp;globals) {
 862   assert( false, &quot;InstructForm::out_reg_class(FormDict &amp;globals); Not Implemented&quot;);
 863 
 864   return NULL;
 865 }
 866 
 867 
 868 
 869 // Lookup the starting position of inputs we are interested in wrt. ideal nodes
 870 uint InstructForm::oper_input_base(FormDict &amp;globals) {
 871   if( !_matrule ) return 1;     // Skip control for most nodes
 872 
 873   // Need special handling for matching some ideal nodes
 874   // i.e. Matching a return node
 875   if( strcmp(_matrule-&gt;_opType,&quot;Return&quot;    )==0 ||
 876       strcmp(_matrule-&gt;_opType,&quot;Rethrow&quot;   )==0 ||
 877       strcmp(_matrule-&gt;_opType,&quot;TailCall&quot;  )==0 ||
 878       strcmp(_matrule-&gt;_opType,&quot;TailJump&quot;  )==0 ||
 879       strcmp(_matrule-&gt;_opType,&quot;SafePoint&quot; )==0 ||
 880       strcmp(_matrule-&gt;_opType,&quot;Halt&quot;      )==0 )
 881     return AdlcVMDeps::Parms;   // Skip the machine-state edges
 882 
 883   if( _matrule-&gt;_rChild &amp;&amp;
 884       ( strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;AryEq&quot;     )==0 ||
 885         strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;StrComp&quot;   )==0 ||
 886         strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;StrEquals&quot; )==0 ||
 887         strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;StrInflatedCopy&quot;   )==0 ||
 888         strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;StrCompressedCopy&quot; )==0 ||
 889         strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;StrIndexOf&quot;)==0 ||
 890         strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;StrIndexOfChar&quot;)==0 ||
 891         strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;HasNegatives&quot;)==0 ||
 892         strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;EncodeISOArray&quot;)==0)) {
 893         // String.(compareTo/equals/indexOf) and Arrays.equals
 894         // and sun.nio.cs.iso8859_1$Encoder.EncodeISOArray
 895         // take 1 control and 1 memory edges.
 896         // Also String.(compressedCopy/inflatedCopy).
 897     return 2;
 898   }
 899 
 900   // Check for handling of &#39;Memory&#39; input/edge in the ideal world.
 901   // The AD file writer is shielded from knowledge of these edges.
 902   int base = 1;                 // Skip control
 903   base += _matrule-&gt;needs_ideal_memory_edge(globals);
 904 
 905   // Also skip the base-oop value for uses of derived oops.
 906   // The AD file writer is shielded from knowledge of these edges.
 907   base += needs_base_oop_edge(globals);
 908 
 909   return base;
 910 }
 911 
 912 // This function determines the order of the MachOper in _opnds[]
 913 // by writing the operand names into the _components list.
 914 //
 915 // Implementation does not modify state of internal structures
 916 void InstructForm::build_components() {
 917   // Add top-level operands to the components
 918   if (_matrule)  _matrule-&gt;append_components(_localNames, _components);
 919 
 920   // Add parameters that &quot;do not appear in match rule&quot;.
 921   bool has_temp = false;
 922   const char *name;
 923   const char *kill_name = NULL;
 924   for (_parameters.reset(); (name = _parameters.iter()) != NULL;) {
 925     OpClassForm *opForm = _localNames[name]-&gt;is_opclass();
 926     assert(opForm != NULL, &quot;sanity&quot;);
 927 
 928     Effect* e = NULL;
 929     {
 930       const Form* form = _effects[name];
 931       e = form ? form-&gt;is_effect() : NULL;
 932     }
 933 
 934     if (e != NULL) {
 935       has_temp |= e-&gt;is(Component::TEMP);
 936 
 937       // KILLs must be declared after any TEMPs because TEMPs are real
 938       // uses so their operand numbering must directly follow the real
 939       // inputs from the match rule.  Fixing the numbering seems
 940       // complex so simply enforce the restriction during parse.
 941       if (kill_name != NULL &amp;&amp;
 942           e-&gt;isa(Component::TEMP) &amp;&amp; !e-&gt;isa(Component::DEF)) {
 943         OpClassForm* kill = _localNames[kill_name]-&gt;is_opclass();
 944         assert(kill != NULL, &quot;sanity&quot;);
 945         globalAD-&gt;syntax_err(_linenum, &quot;%s: %s %s must be at the end of the argument list\n&quot;,
 946                              _ident, kill-&gt;_ident, kill_name);
 947       } else if (e-&gt;isa(Component::KILL) &amp;&amp; !e-&gt;isa(Component::USE)) {
 948         kill_name = name;
 949       }
 950     }
 951 
 952     const Component *component  = _components.search(name);
 953     if ( component  == NULL ) {
 954       if (e) {
 955         _components.insert(name, opForm-&gt;_ident, e-&gt;_use_def, false);
 956         component = _components.search(name);
 957         if (component-&gt;isa(Component::USE) &amp;&amp; !component-&gt;isa(Component::TEMP) &amp;&amp; _matrule) {
 958           const Form *form = globalAD-&gt;globalNames()[component-&gt;_type];
 959           assert( form, &quot;component type must be a defined form&quot;);
 960           OperandForm *op   = form-&gt;is_operand();
 961           if (op-&gt;_interface &amp;&amp; op-&gt;_interface-&gt;is_RegInterface()) {
 962             globalAD-&gt;syntax_err(_linenum, &quot;%s: illegal USE of non-input: %s %s\n&quot;,
 963                                  _ident, opForm-&gt;_ident, name);
 964           }
 965         }
 966       } else {
 967         // This would be a nice warning but it triggers in a few places in a benign way
 968         // if (_matrule != NULL &amp;&amp; !expands()) {
 969         //   globalAD-&gt;syntax_err(_linenum, &quot;%s: %s %s not mentioned in effect or match rule\n&quot;,
 970         //                        _ident, opForm-&gt;_ident, name);
 971         // }
 972         _components.insert(name, opForm-&gt;_ident, Component::INVALID, false);
 973       }
 974     }
 975     else if (e) {
 976       // Component was found in the list
 977       // Check if there is a new effect that requires an extra component.
 978       // This happens when adding &#39;USE&#39; to a component that is not yet one.
 979       if ((!component-&gt;isa( Component::USE) &amp;&amp; ((e-&gt;_use_def &amp; Component::USE) != 0))) {
 980         if (component-&gt;isa(Component::USE) &amp;&amp; _matrule) {
 981           const Form *form = globalAD-&gt;globalNames()[component-&gt;_type];
 982           assert( form, &quot;component type must be a defined form&quot;);
 983           OperandForm *op   = form-&gt;is_operand();
 984           if (op-&gt;_interface &amp;&amp; op-&gt;_interface-&gt;is_RegInterface()) {
 985             globalAD-&gt;syntax_err(_linenum, &quot;%s: illegal USE of non-input: %s %s\n&quot;,
 986                                  _ident, opForm-&gt;_ident, name);
 987           }
 988         }
 989         _components.insert(name, opForm-&gt;_ident, e-&gt;_use_def, false);
 990       } else {
 991         Component  *comp = (Component*)component;
 992         comp-&gt;promote_use_def_info(e-&gt;_use_def);
 993       }
 994       // Component positions are zero based.
 995       int  pos  = _components.operand_position(name);
 996       assert( ! (component-&gt;isa(Component::DEF) &amp;&amp; (pos &gt;= 1)),
 997               &quot;Component::DEF can only occur in the first position&quot;);
 998     }
 999   }
1000 
1001   // Resolving the interactions between expand rules and TEMPs would
1002   // be complex so simply disallow it.
1003   if (_matrule == NULL &amp;&amp; has_temp) {
1004     globalAD-&gt;syntax_err(_linenum, &quot;%s: TEMPs without match rule isn&#39;t supported\n&quot;, _ident);
1005   }
1006 
1007   return;
1008 }
1009 
1010 // Return zero-based position in component list;  -1 if not in list.
1011 int   InstructForm::operand_position(const char *name, int usedef) {
1012   return unique_opnds_idx(_components.operand_position(name, usedef, this));
1013 }
1014 
1015 int   InstructForm::operand_position_format(const char *name) {
1016   return unique_opnds_idx(_components.operand_position_format(name, this));
1017 }
1018 
1019 // Return zero-based position in component list; -1 if not in list.
1020 int   InstructForm::label_position() {
1021   return unique_opnds_idx(_components.label_position());
1022 }
1023 
1024 int   InstructForm::method_position() {
1025   return unique_opnds_idx(_components.method_position());
1026 }
1027 
1028 // Return number of relocation entries needed for this instruction.
1029 uint  InstructForm::reloc(FormDict &amp;globals) {
1030   uint reloc_entries  = 0;
1031   // Check for &quot;Call&quot; nodes
1032   if ( is_ideal_call() )      ++reloc_entries;
1033   if ( is_ideal_return() )    ++reloc_entries;
1034   if ( is_ideal_safepoint() ) ++reloc_entries;
1035 
1036 
1037   // Check if operands MAYBE oop pointers, by checking for ConP elements
1038   // Proceed through the leaves of the match-tree and check for ConPs
1039   if ( _matrule != NULL ) {
1040     uint         position = 0;
1041     const char  *result   = NULL;
1042     const char  *name     = NULL;
1043     const char  *opType   = NULL;
1044     while (_matrule-&gt;base_operand(position, globals, result, name, opType)) {
1045       if ( strcmp(opType,&quot;ConP&quot;) == 0 ) {
1046 #ifdef SPARC
1047         reloc_entries += 2; // 1 for sethi + 1 for setlo
1048 #else
1049         ++reloc_entries;
1050 #endif
1051       }
1052       ++position;
1053     }
1054   }
1055 
1056   // Above is only a conservative estimate
1057   // because it did not check contents of operand classes.
1058   // !!!!! !!!!!
1059   // Add 1 to reloc info for each operand class in the component list.
1060   Component  *comp;
1061   _components.reset();
1062   while ( (comp = _components.iter()) != NULL ) {
1063     const Form        *form = globals[comp-&gt;_type];
1064     assert( form, &quot;Did not find component&#39;s type in global names&quot;);
1065     const OpClassForm *opc  = form-&gt;is_opclass();
1066     const OperandForm *oper = form-&gt;is_operand();
1067     if ( opc &amp;&amp; (oper == NULL) ) {
1068       ++reloc_entries;
1069     } else if ( oper ) {
1070       // floats and doubles loaded out of method&#39;s constant pool require reloc info
1071       Form::DataType type = oper-&gt;is_base_constant(globals);
1072       if ( (type == Form::idealF) || (type == Form::idealD) ) {
1073         ++reloc_entries;
1074       }
1075     }
1076   }
1077 
1078   // Float and Double constants may come from the CodeBuffer table
1079   // and require relocatable addresses for access
1080   // !!!!!
1081   // Check for any component being an immediate float or double.
1082   Form::DataType data_type = is_chain_of_constant(globals);
1083   if( data_type==idealD || data_type==idealF ) {
1084 #ifdef SPARC
1085     // sparc required more relocation entries for floating constants
1086     // (expires 9/98)
1087     reloc_entries += 6;
1088 #else
1089     reloc_entries++;
1090 #endif
1091   }
1092 
1093   return reloc_entries;
1094 }
1095 
1096 // Utility function defined in archDesc.cpp
1097 extern bool is_def(int usedef);
1098 
1099 // Return the result of reducing an instruction
1100 const char *InstructForm::reduce_result() {
1101   const char* result = &quot;Universe&quot;;  // default
1102   _components.reset();
1103   Component *comp = _components.iter();
1104   if (comp != NULL &amp;&amp; comp-&gt;isa(Component::DEF)) {
1105     result = comp-&gt;_type;
1106     // Override this if the rule is a store operation:
1107     if (_matrule &amp;&amp; _matrule-&gt;_rChild &amp;&amp;
1108         is_store_to_memory(_matrule-&gt;_rChild-&gt;_opType))
1109       result = &quot;Universe&quot;;
1110   }
1111   return result;
1112 }
1113 
1114 // Return the name of the operand on the right hand side of the binary match
1115 // Return NULL if there is no right hand side
1116 const char *InstructForm::reduce_right(FormDict &amp;globals)  const {
1117   if( _matrule == NULL ) return NULL;
1118   return  _matrule-&gt;reduce_right(globals);
1119 }
1120 
1121 // Similar for left
1122 const char *InstructForm::reduce_left(FormDict &amp;globals)   const {
1123   if( _matrule == NULL ) return NULL;
1124   return  _matrule-&gt;reduce_left(globals);
1125 }
1126 
1127 
1128 // Base class for this instruction, MachNode except for calls
1129 const char *InstructForm::mach_base_class(FormDict &amp;globals)  const {
1130   if( is_ideal_call() == Form::JAVA_STATIC ) {
1131     return &quot;MachCallStaticJavaNode&quot;;
1132   }
1133   else if( is_ideal_call() == Form::JAVA_DYNAMIC ) {
1134     return &quot;MachCallDynamicJavaNode&quot;;
1135   }
1136   else if( is_ideal_call() == Form::JAVA_RUNTIME ) {
1137     return &quot;MachCallRuntimeNode&quot;;
1138   }
1139   else if( is_ideal_call() == Form::JAVA_LEAF ) {
1140     return &quot;MachCallLeafNode&quot;;
1141   }
1142   else if (is_ideal_return()) {
1143     return &quot;MachReturnNode&quot;;
1144   }
1145   else if (is_ideal_halt()) {
1146     return &quot;MachHaltNode&quot;;
1147   }
1148   else if (is_ideal_safepoint()) {
1149     return &quot;MachSafePointNode&quot;;
1150   }
1151   else if (is_ideal_if()) {
1152     return &quot;MachIfNode&quot;;
1153   }
1154   else if (is_ideal_goto()) {
1155     return &quot;MachGotoNode&quot;;
1156   }
1157   else if (is_ideal_fastlock()) {
1158     return &quot;MachFastLockNode&quot;;
1159   }
1160   else if (is_ideal_nop()) {
1161     return &quot;MachNopNode&quot;;
1162   }
1163   else if( is_ideal_membar()) {
1164     return &quot;MachMemBarNode&quot;;
1165   }
1166   else if (is_ideal_jump()) {
1167     return &quot;MachJumpNode&quot;;
1168   }
1169   else if (is_mach_constant()) {
1170     return &quot;MachConstantNode&quot;;
1171   }
1172   else if (captures_bottom_type(globals)) {
1173     return &quot;MachTypeNode&quot;;
1174   } else {
1175     return &quot;MachNode&quot;;
1176   }
1177   assert( false, &quot;ShouldNotReachHere()&quot;);
1178   return NULL;
1179 }
1180 
1181 // Compare the instruction predicates for textual equality
1182 bool equivalent_predicates( const InstructForm *instr1, const InstructForm *instr2 ) {
1183   const Predicate *pred1  = instr1-&gt;_predicate;
1184   const Predicate *pred2  = instr2-&gt;_predicate;
1185   if( pred1 == NULL &amp;&amp; pred2 == NULL ) {
1186     // no predicates means they are identical
1187     return true;
1188   }
1189   if( pred1 != NULL &amp;&amp; pred2 != NULL ) {
1190     // compare the predicates
1191     if (ADLParser::equivalent_expressions(pred1-&gt;_pred, pred2-&gt;_pred)) {
1192       return true;
1193     }
1194   }
1195 
1196   return false;
1197 }
1198 
1199 // Check if this instruction can cisc-spill to &#39;alternate&#39;
1200 bool InstructForm::cisc_spills_to(ArchDesc &amp;AD, InstructForm *instr) {
1201   assert( _matrule != NULL &amp;&amp; instr-&gt;_matrule != NULL, &quot;must have match rules&quot;);
1202   // Do not replace if a cisc-version has been found.
1203   if( cisc_spill_operand() != Not_cisc_spillable ) return false;
1204 
1205   int         cisc_spill_operand = Maybe_cisc_spillable;
1206   char       *result             = NULL;
1207   char       *result2            = NULL;
1208   const char *op_name            = NULL;
1209   const char *reg_type           = NULL;
1210   FormDict   &amp;globals            = AD.globalNames();
1211   cisc_spill_operand = _matrule-&gt;matchrule_cisc_spill_match(globals, AD.get_registers(), instr-&gt;_matrule, op_name, reg_type);
1212   if( (cisc_spill_operand != Not_cisc_spillable) &amp;&amp; (op_name != NULL) &amp;&amp; equivalent_predicates(this, instr) ) {
1213     cisc_spill_operand = operand_position(op_name, Component::USE);
1214     int def_oper  = operand_position(op_name, Component::DEF);
1215     if( def_oper == NameList::Not_in_list &amp;&amp; instr-&gt;num_opnds() == num_opnds()) {
1216       // Do not support cisc-spilling for destination operands and
1217       // make sure they have the same number of operands.
1218       _cisc_spill_alternate = instr;
1219       instr-&gt;set_cisc_alternate(true);
1220       if( AD._cisc_spill_debug ) {
1221         fprintf(stderr, &quot;Instruction %s cisc-spills-to %s\n&quot;, _ident, instr-&gt;_ident);
1222         fprintf(stderr, &quot;   using operand %s %s at index %d\n&quot;, reg_type, op_name, cisc_spill_operand);
1223       }
1224       // Record that a stack-version of the reg_mask is needed
1225       // !!!!!
1226       OperandForm *oper = (OperandForm*)(globals[reg_type]-&gt;is_operand());
1227       assert( oper != NULL, &quot;cisc-spilling non operand&quot;);
1228       const char *reg_class_name = oper-&gt;constrained_reg_class();
1229       AD.set_stack_or_reg(reg_class_name);
1230       const char *reg_mask_name  = AD.reg_mask(*oper);
1231       set_cisc_reg_mask_name(reg_mask_name);
1232       const char *stack_or_reg_mask_name = AD.stack_or_reg_mask(*oper);
1233     } else {
1234       cisc_spill_operand = Not_cisc_spillable;
1235     }
1236   } else {
1237     cisc_spill_operand = Not_cisc_spillable;
1238   }
1239 
1240   set_cisc_spill_operand(cisc_spill_operand);
1241   return (cisc_spill_operand != Not_cisc_spillable);
1242 }
1243 
1244 // Check to see if this instruction can be replaced with the short branch
1245 // instruction `short-branch&#39;
1246 bool InstructForm::check_branch_variant(ArchDesc &amp;AD, InstructForm *short_branch) {
1247   if (_matrule != NULL &amp;&amp;
1248       this != short_branch &amp;&amp;   // Don&#39;t match myself
1249       !is_short_branch() &amp;&amp;     // Don&#39;t match another short branch variant
1250       reduce_result() != NULL &amp;&amp;
1251       strstr(_ident, &quot;restoreMask&quot;) == NULL &amp;&amp; // Don&#39;t match side effects
1252       strcmp(reduce_result(), short_branch-&gt;reduce_result()) == 0 &amp;&amp;
1253       _matrule-&gt;equivalent(AD.globalNames(), short_branch-&gt;_matrule)) {
1254     // The instructions are equivalent.
1255 
1256     // Now verify that both instructions have the same parameters and
1257     // the same effects. Both branch forms should have the same inputs
1258     // and resulting projections to correctly replace a long branch node
1259     // with corresponding short branch node during code generation.
1260 
1261     bool different = false;
1262     if (short_branch-&gt;_components.count() != _components.count()) {
1263        different = true;
1264     } else if (_components.count() &gt; 0) {
1265       short_branch-&gt;_components.reset();
1266       _components.reset();
1267       Component *comp;
1268       while ((comp = _components.iter()) != NULL) {
1269         Component *short_comp = short_branch-&gt;_components.iter();
1270         if (short_comp == NULL ||
1271             short_comp-&gt;_type != comp-&gt;_type ||
1272             short_comp-&gt;_usedef != comp-&gt;_usedef) {
1273           different = true;
1274           break;
1275         }
1276       }
1277       if (short_branch-&gt;_components.iter() != NULL)
1278         different = true;
1279     }
1280     if (different) {
1281       globalAD-&gt;syntax_err(short_branch-&gt;_linenum, &quot;Instruction %s and its short form %s have different parameters\n&quot;, _ident, short_branch-&gt;_ident);
1282     }
1283     if (AD._adl_debug &gt; 1 || AD._short_branch_debug) {
1284       fprintf(stderr, &quot;Instruction %s has short form %s\n&quot;, _ident, short_branch-&gt;_ident);
1285     }
1286     _short_branch_form = short_branch;
1287     return true;
1288   }
1289   return false;
1290 }
1291 
1292 
1293 // --------------------------- FILE *output_routines
1294 //
1295 // Generate the format call for the replacement variable
1296 void InstructForm::rep_var_format(FILE *fp, const char *rep_var) {
1297   // Handle special constant table variables.
1298   if (strcmp(rep_var, &quot;constanttablebase&quot;) == 0) {
1299     fprintf(fp, &quot;char reg[128];  ra-&gt;dump_register(in(mach_constant_base_node_input()), reg);\n&quot;);
1300     fprintf(fp, &quot;    st-&gt;print(\&quot;%%s\&quot;, reg);\n&quot;);
1301     return;
1302   }
1303   if (strcmp(rep_var, &quot;constantoffset&quot;) == 0) {
1304     fprintf(fp, &quot;st-&gt;print(\&quot;#%%d\&quot;, constant_offset_unchecked());\n&quot;);
1305     return;
1306   }
1307   if (strcmp(rep_var, &quot;constantaddress&quot;) == 0) {
1308     fprintf(fp, &quot;st-&gt;print(\&quot;constant table base + #%%d\&quot;, constant_offset_unchecked());\n&quot;);
1309     return;
1310   }
1311 
1312   // Find replacement variable&#39;s type
1313   const Form *form   = _localNames[rep_var];
1314   if (form == NULL) {
1315     globalAD-&gt;syntax_err(_linenum, &quot;Unknown replacement variable %s in format statement of %s.&quot;,
1316                          rep_var, _ident);
1317     return;
1318   }
1319   OpClassForm *opc   = form-&gt;is_opclass();
1320   assert( opc, &quot;replacement variable was not found in local names&quot;);
1321   // Lookup the index position of the replacement variable
1322   int idx  = operand_position_format(rep_var);
1323   if ( idx == -1 ) {
1324     globalAD-&gt;syntax_err(_linenum, &quot;Could not find replacement variable %s in format statement of %s.\n&quot;,
1325                          rep_var, _ident);
1326     assert(strcmp(opc-&gt;_ident, &quot;label&quot;) == 0, &quot;Unimplemented&quot;);
1327     return;
1328   }
1329 
1330   if (is_noninput_operand(idx)) {
1331     // This component isn&#39;t in the input array.  Print out the static
1332     // name of the register.
1333     OperandForm* oper = form-&gt;is_operand();
1334     if (oper != NULL &amp;&amp; oper-&gt;is_bound_register()) {
1335       const RegDef* first = oper-&gt;get_RegClass()-&gt;find_first_elem();
1336       fprintf(fp, &quot;    st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;, first-&gt;_regname);
1337     } else {
1338       globalAD-&gt;syntax_err(_linenum, &quot;In %s can&#39;t find format for %s %s&quot;, _ident, opc-&gt;_ident, rep_var);
1339     }
1340   } else {
1341     // Output the format call for this operand
1342     fprintf(fp,&quot;opnd_array(%d)-&gt;&quot;,idx);
1343     if (idx == 0)
1344       fprintf(fp,&quot;int_format(ra, this, st); // %s\n&quot;, rep_var);
1345     else
1346       fprintf(fp,&quot;ext_format(ra, this,idx%d, st); // %s\n&quot;, idx, rep_var );
1347   }
1348 }
1349 
1350 // Seach through operands to determine parameters unique positions.
1351 void InstructForm::set_unique_opnds() {
1352   uint* uniq_idx = NULL;
1353   uint  nopnds = num_opnds();
1354   uint  num_uniq = nopnds;
1355   uint i;
1356   _uniq_idx_length = 0;
1357   if (nopnds &gt; 0) {
1358     // Allocate index array.  Worst case we&#39;re mapping from each
1359     // component back to an index and any DEF always goes at 0 so the
1360     // length of the array has to be the number of components + 1.
1361     _uniq_idx_length = _components.count() + 1;
1362     uniq_idx = (uint*) AllocateHeap(sizeof(uint) * _uniq_idx_length);
1363     for (i = 0; i &lt; _uniq_idx_length; i++) {
1364       uniq_idx[i] = i;
1365     }
1366   }
1367   // Do it only if there is a match rule and no expand rule.  With an
1368   // expand rule it is done by creating new mach node in Expand()
1369   // method.
1370   if (nopnds &gt; 0 &amp;&amp; _matrule != NULL &amp;&amp; _exprule == NULL) {
1371     const char *name;
1372     uint count;
1373     bool has_dupl_use = false;
1374 
1375     _parameters.reset();
1376     while ((name = _parameters.iter()) != NULL) {
1377       count = 0;
1378       uint position = 0;
1379       uint uniq_position = 0;
1380       _components.reset();
1381       Component *comp = NULL;
1382       if (sets_result()) {
1383         comp = _components.iter();
1384         position++;
1385       }
1386       // The next code is copied from the method operand_position().
1387       for (; (comp = _components.iter()) != NULL; ++position) {
1388         // When the first component is not a DEF,
1389         // leave space for the result operand!
1390         if (position==0 &amp;&amp; (!comp-&gt;isa(Component::DEF))) {
1391           ++position;
1392         }
1393         if (strcmp(name, comp-&gt;_name) == 0) {
1394           if (++count &gt; 1) {
1395             assert(position &lt; _uniq_idx_length, &quot;out of bounds&quot;);
1396             uniq_idx[position] = uniq_position;
1397             has_dupl_use = true;
1398           } else {
1399             uniq_position = position;
1400           }
1401         }
1402         if (comp-&gt;isa(Component::DEF) &amp;&amp; comp-&gt;isa(Component::USE)) {
1403           ++position;
1404           if (position != 1)
1405             --position;   // only use two slots for the 1st USE_DEF
1406         }
1407       }
1408     }
1409     if (has_dupl_use) {
1410       for (i = 1; i &lt; nopnds; i++) {
1411         if (i != uniq_idx[i]) {
1412           break;
1413         }
1414       }
1415       uint j = i;
1416       for (; i &lt; nopnds; i++) {
1417         if (i == uniq_idx[i]) {
1418           uniq_idx[i] = j++;
1419         }
1420       }
1421       num_uniq = j;
1422     }
1423   }
1424   _uniq_idx = uniq_idx;
1425   _num_uniq = num_uniq;
1426 }
1427 
1428 // Generate index values needed for determining the operand position
1429 void InstructForm::index_temps(FILE *fp, FormDict &amp;globals, const char *prefix, const char *receiver) {
1430   uint  idx = 0;                  // position of operand in match rule
1431   int   cur_num_opnds = num_opnds();
1432 
1433   // Compute the index into vector of operand pointers:
1434   // idx0=0 is used to indicate that info comes from this same node, not from input edge.
1435   // idx1 starts at oper_input_base()
1436   if ( cur_num_opnds &gt;= 1 ) {
1437     fprintf(fp,&quot;  // Start at oper_input_base() and count operands\n&quot;);
1438     fprintf(fp,&quot;  unsigned %sidx0 = %d;\n&quot;, prefix, oper_input_base(globals));
1439     fprintf(fp,&quot;  unsigned %sidx1 = %d;&quot;, prefix, oper_input_base(globals));
1440     fprintf(fp,&quot; \t// %s\n&quot;, unique_opnd_ident(1));
1441 
1442     // Generate starting points for other unique operands if they exist
1443     for ( idx = 2; idx &lt; num_unique_opnds(); ++idx ) {
1444       if( *receiver == 0 ) {
1445         fprintf(fp,&quot;  unsigned %sidx%d = %sidx%d + opnd_array(%d)-&gt;num_edges();&quot;,
1446                 prefix, idx, prefix, idx-1, idx-1 );
1447       } else {
1448         fprintf(fp,&quot;  unsigned %sidx%d = %sidx%d + %s_opnds[%d]-&gt;num_edges();&quot;,
1449                 prefix, idx, prefix, idx-1, receiver, idx-1 );
1450       }
1451       fprintf(fp,&quot; \t// %s\n&quot;, unique_opnd_ident(idx));
1452     }
1453   }
1454   if( *receiver != 0 ) {
1455     // This value is used by generate_peepreplace when copying a node.
1456     // Don&#39;t emit it in other cases since it can hide bugs with the
1457     // use invalid idx&#39;s.
1458     fprintf(fp,&quot;  unsigned %sidx%d = %sreq(); \n&quot;, prefix, idx, receiver);
1459   }
1460 
1461 }
1462 
1463 // ---------------------------
1464 bool InstructForm::verify() {
1465   // !!!!! !!!!!
1466   // Check that a &quot;label&quot; operand occurs last in the operand list, if present
1467   return true;
1468 }
1469 
1470 void InstructForm::dump() {
1471   output(stderr);
1472 }
1473 
1474 void InstructForm::output(FILE *fp) {
1475   fprintf(fp,&quot;\nInstruction: %s\n&quot;, (_ident?_ident:&quot;&quot;));
1476   if (_matrule)   _matrule-&gt;output(fp);
1477   if (_insencode) _insencode-&gt;output(fp);
1478   if (_constant)  _constant-&gt;output(fp);
1479   if (_opcode)    _opcode-&gt;output(fp);
1480   if (_attribs)   _attribs-&gt;output(fp);
1481   if (_predicate) _predicate-&gt;output(fp);
1482   if (_effects.Size()) {
1483     fprintf(fp,&quot;Effects\n&quot;);
1484     _effects.dump();
1485   }
1486   if (_exprule)   _exprule-&gt;output(fp);
1487   if (_rewrule)   _rewrule-&gt;output(fp);
1488   if (_format)    _format-&gt;output(fp);
1489   if (_peephole)  _peephole-&gt;output(fp);
1490 }
1491 
1492 void MachNodeForm::dump() {
1493   output(stderr);
1494 }
1495 
1496 void MachNodeForm::output(FILE *fp) {
1497   fprintf(fp,&quot;\nMachNode: %s\n&quot;, (_ident?_ident:&quot;&quot;));
1498 }
1499 
1500 //------------------------------build_predicate--------------------------------
1501 // Build instruction predicates.  If the user uses the same operand name
1502 // twice, we need to check that the operands are pointer-eequivalent in
1503 // the DFA during the labeling process.
1504 Predicate *InstructForm::build_predicate() {
1505   const int buflen = 1024;
1506   char buf[buflen], *s=buf;
1507   Dict names(cmpstr,hashstr,Form::arena);       // Map Names to counts
1508 
1509   MatchNode *mnode =
1510     strcmp(_matrule-&gt;_opType, &quot;Set&quot;) ? _matrule : _matrule-&gt;_rChild;
<a name="5" id="anc5"></a><span class="line-modified">1511   mnode-&gt;count_instr_names(names);</span>
1512 
1513   uint first = 1;
1514   // Start with the predicate supplied in the .ad file.
1515   if (_predicate) {
1516     if (first) first = 0;
1517     strcpy(s, &quot;(&quot;); s += strlen(s);
1518     strncpy(s, _predicate-&gt;_pred, buflen - strlen(s) - 1);
1519     s += strlen(s);
1520     strcpy(s, &quot;)&quot;); s += strlen(s);
1521   }
1522   for( DictI i(&amp;names); i.test(); ++i ) {
1523     uintptr_t cnt = (uintptr_t)i._value;
1524     if( cnt &gt; 1 ) {             // Need a predicate at all?
1525       assert( cnt == 2, &quot;Unimplemented&quot; );
1526       // Handle many pairs
1527       if( first ) first=0;
1528       else {                    // All tests must pass, so use &#39;&amp;&amp;&#39;
1529         strcpy(s,&quot; &amp;&amp; &quot;);
1530         s += strlen(s);
1531       }
1532       // Add predicate to working buffer
1533       sprintf(s,&quot;/*%s*/(&quot;,(char*)i._key);
1534       s += strlen(s);
1535       mnode-&gt;build_instr_pred(s,(char*)i._key,0);
1536       s += strlen(s);
1537       strcpy(s,&quot; == &quot;); s += strlen(s);
1538       mnode-&gt;build_instr_pred(s,(char*)i._key,1);
1539       s += strlen(s);
1540       strcpy(s,&quot;)&quot;); s += strlen(s);
1541     }
1542   }
1543   if( s == buf ) s = NULL;
1544   else {
1545     assert( strlen(buf) &lt; sizeof(buf), &quot;String buffer overflow&quot; );
1546     s = strdup(buf);
1547   }
1548   return new Predicate(s);
1549 }
1550 
1551 //------------------------------EncodeForm-------------------------------------
1552 // Constructor
1553 EncodeForm::EncodeForm()
1554   : _encClass(cmpstr,hashstr, Form::arena) {
1555 }
1556 EncodeForm::~EncodeForm() {
1557 }
1558 
1559 // record a new register class
1560 EncClass *EncodeForm::add_EncClass(const char *className) {
1561   EncClass *encClass = new EncClass(className);
1562   _eclasses.addName(className);
1563   _encClass.Insert(className,encClass);
1564   return encClass;
1565 }
1566 
1567 // Lookup the function body for an encoding class
1568 EncClass  *EncodeForm::encClass(const char *className) {
1569   assert( className != NULL, &quot;Must provide a defined encoding name&quot;);
1570 
1571   EncClass *encClass = (EncClass*)_encClass[className];
1572   return encClass;
1573 }
1574 
1575 // Lookup the function body for an encoding class
1576 const char *EncodeForm::encClassBody(const char *className) {
1577   if( className == NULL ) return NULL;
1578 
1579   EncClass *encClass = (EncClass*)_encClass[className];
1580   assert( encClass != NULL, &quot;Encode Class is missing.&quot;);
1581   encClass-&gt;_code.reset();
1582   const char *code = (const char*)encClass-&gt;_code.iter();
1583   assert( code != NULL, &quot;Found an empty encode class body.&quot;);
1584 
1585   return code;
1586 }
1587 
1588 // Lookup the function body for an encoding class
1589 const char *EncodeForm::encClassPrototype(const char *className) {
1590   assert( className != NULL, &quot;Encode class name must be non NULL.&quot;);
1591 
1592   return className;
1593 }
1594 
1595 void EncodeForm::dump() {                  // Debug printer
1596   output(stderr);
1597 }
1598 
1599 void EncodeForm::output(FILE *fp) {          // Write info to output files
1600   const char *name;
1601   fprintf(fp,&quot;\n&quot;);
1602   fprintf(fp,&quot;-------------------- Dump EncodeForm --------------------\n&quot;);
1603   for (_eclasses.reset(); (name = _eclasses.iter()) != NULL;) {
1604     ((EncClass*)_encClass[name])-&gt;output(fp);
1605   }
1606   fprintf(fp,&quot;-------------------- end  EncodeForm --------------------\n&quot;);
1607 }
1608 //------------------------------EncClass---------------------------------------
1609 EncClass::EncClass(const char *name)
1610   : _localNames(cmpstr,hashstr, Form::arena), _name(name) {
1611 }
1612 EncClass::~EncClass() {
1613 }
1614 
1615 // Add a parameter &lt;type,name&gt; pair
1616 void EncClass::add_parameter(const char *parameter_type, const char *parameter_name) {
1617   _parameter_type.addName( parameter_type );
1618   _parameter_name.addName( parameter_name );
1619 }
1620 
1621 // Verify operand types in parameter list
1622 bool EncClass::check_parameter_types(FormDict &amp;globals) {
1623   // !!!!!
1624   return false;
1625 }
1626 
1627 // Add the decomposed &quot;code&quot; sections of an encoding&#39;s code-block
1628 void EncClass::add_code(const char *code) {
1629   _code.addName(code);
1630 }
1631 
1632 // Add the decomposed &quot;replacement variables&quot; of an encoding&#39;s code-block
1633 void EncClass::add_rep_var(char *replacement_var) {
1634   _code.addName(NameList::_signal);
1635   _rep_vars.addName(replacement_var);
1636 }
1637 
1638 // Lookup the function body for an encoding class
1639 int EncClass::rep_var_index(const char *rep_var) {
1640   uint        position = 0;
1641   const char *name     = NULL;
1642 
1643   _parameter_name.reset();
1644   while ( (name = _parameter_name.iter()) != NULL ) {
1645     if ( strcmp(rep_var,name) == 0 ) return position;
1646     ++position;
1647   }
1648 
1649   return -1;
1650 }
1651 
1652 // Check after parsing
1653 bool EncClass::verify() {
1654   // 1!!!!
1655   // Check that each replacement variable, &#39;$name&#39; in architecture description
1656   // is actually a local variable for this encode class, or a reserved name
1657   // &quot;primary, secondary, tertiary&quot;
1658   return true;
1659 }
1660 
1661 void EncClass::dump() {
1662   output(stderr);
1663 }
1664 
1665 // Write info to output files
1666 void EncClass::output(FILE *fp) {
1667   fprintf(fp,&quot;EncClass: %s&quot;, (_name ? _name : &quot;&quot;));
1668 
1669   // Output the parameter list
1670   _parameter_type.reset();
1671   _parameter_name.reset();
1672   const char *type = _parameter_type.iter();
1673   const char *name = _parameter_name.iter();
1674   fprintf(fp, &quot; ( &quot;);
1675   for ( ; (type != NULL) &amp;&amp; (name != NULL);
1676         (type = _parameter_type.iter()), (name = _parameter_name.iter()) ) {
1677     fprintf(fp, &quot; %s %s,&quot;, type, name);
1678   }
1679   fprintf(fp, &quot; ) &quot;);
1680 
1681   // Output the code block
1682   _code.reset();
1683   _rep_vars.reset();
1684   const char *code;
1685   while ( (code = _code.iter()) != NULL ) {
1686     if ( _code.is_signal(code) ) {
1687       // A replacement variable
1688       const char *rep_var = _rep_vars.iter();
1689       fprintf(fp,&quot;($%s)&quot;, rep_var);
1690     } else {
1691       // A section of code
1692       fprintf(fp,&quot;%s&quot;, code);
1693     }
1694   }
1695 
1696 }
1697 
1698 //------------------------------Opcode-----------------------------------------
1699 Opcode::Opcode(char *primary, char *secondary, char *tertiary)
1700   : _primary(primary), _secondary(secondary), _tertiary(tertiary) {
1701 }
1702 
1703 Opcode::~Opcode() {
1704 }
1705 
1706 Opcode::opcode_type Opcode::as_opcode_type(const char *param) {
1707   if( strcmp(param,&quot;primary&quot;) == 0 ) {
1708     return Opcode::PRIMARY;
1709   }
1710   else if( strcmp(param,&quot;secondary&quot;) == 0 ) {
1711     return Opcode::SECONDARY;
1712   }
1713   else if( strcmp(param,&quot;tertiary&quot;) == 0 ) {
1714     return Opcode::TERTIARY;
1715   }
1716   return Opcode::NOT_AN_OPCODE;
1717 }
1718 
1719 bool Opcode::print_opcode(FILE *fp, Opcode::opcode_type desired_opcode) {
1720   // Default values previously provided by MachNode::primary()...
1721   const char *description = NULL;
1722   const char *value       = NULL;
1723   // Check if user provided any opcode definitions
<a name="6" id="anc6"></a><span class="line-modified">1724   if( this != NULL ) {</span>
<span class="line-modified">1725     // Update &#39;value&#39; if user provided a definition in the instruction</span>
<span class="line-modified">1726     switch (desired_opcode) {</span>
<span class="line-modified">1727     case PRIMARY:</span>
<span class="line-modified">1728       description = &quot;primary()&quot;;</span>
<span class="line-modified">1729       if( _primary   != NULL)  { value = _primary;     }</span>
<span class="line-modified">1730       break;</span>
<span class="line-modified">1731     case SECONDARY:</span>
<span class="line-modified">1732       description = &quot;secondary()&quot;;</span>
<span class="line-modified">1733       if( _secondary != NULL ) { value = _secondary;   }</span>
<span class="line-modified">1734       break;</span>
<span class="line-modified">1735     case TERTIARY:</span>
<span class="line-modified">1736       description = &quot;tertiary()&quot;;</span>
<span class="line-modified">1737       if( _tertiary  != NULL ) { value = _tertiary;    }</span>
<span class="line-modified">1738       break;</span>
<span class="line-modified">1739     default:</span>
<span class="line-modified">1740       assert( false, &quot;ShouldNotReachHere();&quot;);</span>
<span class="line-removed">1741       break;</span>
<span class="line-removed">1742     }</span>
1743   }
<a name="7" id="anc7"></a>
1744   if (value != NULL) {
1745     fprintf(fp, &quot;(%s /*%s*/)&quot;, value, description);
1746   }
1747   return value != NULL;
1748 }
1749 
1750 void Opcode::dump() {
1751   output(stderr);
1752 }
1753 
1754 // Write info to output files
1755 void Opcode::output(FILE *fp) {
1756   if (_primary   != NULL) fprintf(fp,&quot;Primary   opcode: %s\n&quot;, _primary);
1757   if (_secondary != NULL) fprintf(fp,&quot;Secondary opcode: %s\n&quot;, _secondary);
1758   if (_tertiary  != NULL) fprintf(fp,&quot;Tertiary  opcode: %s\n&quot;, _tertiary);
1759 }
1760 
1761 //------------------------------InsEncode--------------------------------------
1762 InsEncode::InsEncode() {
1763 }
1764 InsEncode::~InsEncode() {
1765 }
1766 
1767 // Add &quot;encode class name&quot; and its parameters
1768 NameAndList *InsEncode::add_encode(char *encoding) {
1769   assert( encoding != NULL, &quot;Must provide name for encoding&quot;);
1770 
1771   // add_parameter(NameList::_signal);
1772   NameAndList *encode = new NameAndList(encoding);
1773   _encoding.addName((char*)encode);
1774 
1775   return encode;
1776 }
1777 
1778 // Access the list of encodings
1779 void InsEncode::reset() {
1780   _encoding.reset();
1781   // _parameter.reset();
1782 }
1783 const char* InsEncode::encode_class_iter() {
1784   NameAndList  *encode_class = (NameAndList*)_encoding.iter();
1785   return  ( encode_class != NULL ? encode_class-&gt;name() : NULL );
1786 }
1787 // Obtain parameter name from zero based index
1788 const char *InsEncode::rep_var_name(InstructForm &amp;inst, uint param_no) {
1789   NameAndList *params = (NameAndList*)_encoding.current();
1790   assert( params != NULL, &quot;Internal Error&quot;);
1791   const char *param = (*params)[param_no];
1792 
1793   // Remove &#39;$&#39; if parser placed it there.
1794   return ( param != NULL &amp;&amp; *param == &#39;$&#39;) ? (param+1) : param;
1795 }
1796 
1797 void InsEncode::dump() {
1798   output(stderr);
1799 }
1800 
1801 // Write info to output files
1802 void InsEncode::output(FILE *fp) {
1803   NameAndList *encoding  = NULL;
1804   const char  *parameter = NULL;
1805 
1806   fprintf(fp,&quot;InsEncode: &quot;);
1807   _encoding.reset();
1808 
1809   while ( (encoding = (NameAndList*)_encoding.iter()) != 0 ) {
1810     // Output the encoding being used
1811     fprintf(fp,&quot;%s(&quot;, encoding-&gt;name() );
1812 
1813     // Output its parameter list, if any
1814     bool first_param = true;
1815     encoding-&gt;reset();
1816     while (  (parameter = encoding-&gt;iter()) != 0 ) {
1817       // Output the &#39;,&#39; between parameters
1818       if ( ! first_param )  fprintf(fp,&quot;, &quot;);
1819       first_param = false;
1820       // Output the parameter
1821       fprintf(fp,&quot;%s&quot;, parameter);
1822     } // done with parameters
1823     fprintf(fp,&quot;)  &quot;);
1824   } // done with encodings
1825 
1826   fprintf(fp,&quot;\n&quot;);
1827 }
1828 
1829 //------------------------------Effect-----------------------------------------
1830 static int effect_lookup(const char *name) {
1831   if (!strcmp(name, &quot;USE&quot;)) return Component::USE;
1832   if (!strcmp(name, &quot;DEF&quot;)) return Component::DEF;
1833   if (!strcmp(name, &quot;USE_DEF&quot;)) return Component::USE_DEF;
1834   if (!strcmp(name, &quot;KILL&quot;)) return Component::KILL;
1835   if (!strcmp(name, &quot;USE_KILL&quot;)) return Component::USE_KILL;
1836   if (!strcmp(name, &quot;TEMP&quot;)) return Component::TEMP;
1837   if (!strcmp(name, &quot;TEMP_DEF&quot;)) return Component::TEMP_DEF;
1838   if (!strcmp(name, &quot;INVALID&quot;)) return Component::INVALID;
1839   if (!strcmp(name, &quot;CALL&quot;)) return Component::CALL;
1840   assert(false,&quot;Invalid effect name specified\n&quot;);
1841   return Component::INVALID;
1842 }
1843 
1844 const char *Component::getUsedefName() {
1845   switch (_usedef) {
1846     case Component::INVALID:  return &quot;INVALID&quot;;  break;
1847     case Component::USE:      return &quot;USE&quot;;      break;
1848     case Component::USE_DEF:  return &quot;USE_DEF&quot;;  break;
1849     case Component::USE_KILL: return &quot;USE_KILL&quot;; break;
1850     case Component::KILL:     return &quot;KILL&quot;;     break;
1851     case Component::TEMP:     return &quot;TEMP&quot;;     break;
1852     case Component::TEMP_DEF: return &quot;TEMP_DEF&quot;; break;
1853     case Component::DEF:      return &quot;DEF&quot;;      break;
1854     case Component::CALL:     return &quot;CALL&quot;;     break;
1855     default: assert(false, &quot;unknown effect&quot;);
1856   }
1857   return &quot;Undefined Use/Def info&quot;;
1858 }
1859 
1860 Effect::Effect(const char *name) : _name(name), _use_def(effect_lookup(name)) {
1861   _ftype = Form::EFF;
1862 }
1863 
1864 Effect::~Effect() {
1865 }
1866 
1867 // Dynamic type check
1868 Effect *Effect::is_effect() const {
1869   return (Effect*)this;
1870 }
1871 
1872 
1873 // True if this component is equal to the parameter.
1874 bool Effect::is(int use_def_kill_enum) const {
1875   return (_use_def == use_def_kill_enum ? true : false);
1876 }
1877 // True if this component is used/def&#39;d/kill&#39;d as the parameter suggests.
1878 bool Effect::isa(int use_def_kill_enum) const {
1879   return (_use_def &amp; use_def_kill_enum) == use_def_kill_enum;
1880 }
1881 
1882 void Effect::dump() {
1883   output(stderr);
1884 }
1885 
1886 void Effect::output(FILE *fp) {          // Write info to output files
1887   fprintf(fp,&quot;Effect: %s\n&quot;, (_name?_name:&quot;&quot;));
1888 }
1889 
1890 //------------------------------ExpandRule-------------------------------------
1891 ExpandRule::ExpandRule() : _expand_instrs(),
1892                            _newopconst(cmpstr, hashstr, Form::arena) {
1893   _ftype = Form::EXP;
1894 }
1895 
1896 ExpandRule::~ExpandRule() {                  // Destructor
1897 }
1898 
1899 void ExpandRule::add_instruction(NameAndList *instruction_name_and_operand_list) {
1900   _expand_instrs.addName((char*)instruction_name_and_operand_list);
1901 }
1902 
1903 void ExpandRule::reset_instructions() {
1904   _expand_instrs.reset();
1905 }
1906 
1907 NameAndList* ExpandRule::iter_instructions() {
1908   return (NameAndList*)_expand_instrs.iter();
1909 }
1910 
1911 
1912 void ExpandRule::dump() {
1913   output(stderr);
1914 }
1915 
1916 void ExpandRule::output(FILE *fp) {         // Write info to output files
1917   NameAndList *expand_instr = NULL;
1918   const char *opid = NULL;
1919 
1920   fprintf(fp,&quot;\nExpand Rule:\n&quot;);
1921 
1922   // Iterate over the instructions &#39;node&#39; expands into
1923   for(reset_instructions(); (expand_instr = iter_instructions()) != NULL; ) {
1924     fprintf(fp,&quot;%s(&quot;, expand_instr-&gt;name());
1925 
1926     // iterate over the operand list
1927     for( expand_instr-&gt;reset(); (opid = expand_instr-&gt;iter()) != NULL; ) {
1928       fprintf(fp,&quot;%s &quot;, opid);
1929     }
1930     fprintf(fp,&quot;);\n&quot;);
1931   }
1932 }
1933 
1934 //------------------------------RewriteRule------------------------------------
1935 RewriteRule::RewriteRule(char* params, char* block)
1936   : _tempParams(params), _tempBlock(block) { };  // Constructor
1937 RewriteRule::~RewriteRule() {                 // Destructor
1938 }
1939 
1940 void RewriteRule::dump() {
1941   output(stderr);
1942 }
1943 
1944 void RewriteRule::output(FILE *fp) {         // Write info to output files
1945   fprintf(fp,&quot;\nRewrite Rule:\n%s\n%s\n&quot;,
1946           (_tempParams?_tempParams:&quot;&quot;),
1947           (_tempBlock?_tempBlock:&quot;&quot;));
1948 }
1949 
1950 
1951 //==============================MachNodes======================================
1952 //------------------------------MachNodeForm-----------------------------------
1953 MachNodeForm::MachNodeForm(char *id)
1954   : _ident(id) {
1955 }
1956 
1957 MachNodeForm::~MachNodeForm() {
1958 }
1959 
1960 MachNodeForm *MachNodeForm::is_machnode() const {
1961   return (MachNodeForm*)this;
1962 }
1963 
1964 //==============================Operand Classes================================
1965 //------------------------------OpClassForm------------------------------------
1966 OpClassForm::OpClassForm(const char* id) : _ident(id) {
1967   _ftype = Form::OPCLASS;
1968 }
1969 
1970 OpClassForm::~OpClassForm() {
1971 }
1972 
1973 bool OpClassForm::ideal_only() const { return 0; }
1974 
1975 OpClassForm *OpClassForm::is_opclass() const {
1976   return (OpClassForm*)this;
1977 }
1978 
1979 Form::InterfaceType OpClassForm::interface_type(FormDict &amp;globals) const {
1980   if( _oplst.count() == 0 ) return Form::no_interface;
1981 
1982   // Check that my operands have the same interface type
1983   Form::InterfaceType  interface;
1984   bool  first = true;
1985   NameList &amp;op_list = (NameList &amp;)_oplst;
1986   op_list.reset();
1987   const char *op_name;
1988   while( (op_name = op_list.iter()) != NULL ) {
1989     const Form  *form    = globals[op_name];
1990     OperandForm *operand = form-&gt;is_operand();
1991     assert( operand, &quot;Entry in operand class that is not an operand&quot;);
1992     if( first ) {
1993       first     = false;
1994       interface = operand-&gt;interface_type(globals);
1995     } else {
1996       interface = (interface == operand-&gt;interface_type(globals) ? interface : Form::no_interface);
1997     }
1998   }
1999   return interface;
2000 }
2001 
2002 bool OpClassForm::stack_slots_only(FormDict &amp;globals) const {
2003   if( _oplst.count() == 0 ) return false;  // how?
2004 
2005   NameList &amp;op_list = (NameList &amp;)_oplst;
2006   op_list.reset();
2007   const char *op_name;
2008   while( (op_name = op_list.iter()) != NULL ) {
2009     const Form  *form    = globals[op_name];
2010     OperandForm *operand = form-&gt;is_operand();
2011     assert( operand, &quot;Entry in operand class that is not an operand&quot;);
2012     if( !operand-&gt;stack_slots_only(globals) )  return false;
2013   }
2014   return true;
2015 }
2016 
2017 
2018 void OpClassForm::dump() {
2019   output(stderr);
2020 }
2021 
2022 void OpClassForm::output(FILE *fp) {
2023   const char *name;
2024   fprintf(fp,&quot;\nOperand Class: %s\n&quot;, (_ident?_ident:&quot;&quot;));
2025   fprintf(fp,&quot;\nCount = %d\n&quot;, _oplst.count());
2026   for(_oplst.reset(); (name = _oplst.iter()) != NULL;) {
2027     fprintf(fp,&quot;%s, &quot;,name);
2028   }
2029   fprintf(fp,&quot;\n&quot;);
2030 }
2031 
2032 
2033 //==============================Operands=======================================
2034 //------------------------------OperandForm------------------------------------
2035 OperandForm::OperandForm(const char* id)
2036   : OpClassForm(id), _ideal_only(false),
2037     _localNames(cmpstr, hashstr, Form::arena) {
2038       _ftype = Form::OPER;
2039 
2040       _matrule   = NULL;
2041       _interface = NULL;
2042       _attribs   = NULL;
2043       _predicate = NULL;
2044       _constraint= NULL;
2045       _construct = NULL;
2046       _format    = NULL;
2047 }
2048 OperandForm::OperandForm(const char* id, bool ideal_only)
2049   : OpClassForm(id), _ideal_only(ideal_only),
2050     _localNames(cmpstr, hashstr, Form::arena) {
2051       _ftype = Form::OPER;
2052 
2053       _matrule   = NULL;
2054       _interface = NULL;
2055       _attribs   = NULL;
2056       _predicate = NULL;
2057       _constraint= NULL;
2058       _construct = NULL;
2059       _format    = NULL;
2060 }
2061 OperandForm::~OperandForm() {
2062 }
2063 
2064 
2065 OperandForm *OperandForm::is_operand() const {
2066   return (OperandForm*)this;
2067 }
2068 
2069 bool OperandForm::ideal_only() const {
2070   return _ideal_only;
2071 }
2072 
2073 Form::InterfaceType OperandForm::interface_type(FormDict &amp;globals) const {
2074   if( _interface == NULL )  return Form::no_interface;
2075 
2076   return _interface-&gt;interface_type(globals);
2077 }
2078 
2079 
2080 bool OperandForm::stack_slots_only(FormDict &amp;globals) const {
2081   if( _constraint == NULL )  return false;
2082   return _constraint-&gt;stack_slots_only();
2083 }
2084 
2085 
2086 // Access op_cost attribute or return NULL.
2087 const char* OperandForm::cost() {
2088   for (Attribute* cur = _attribs; cur != NULL; cur = (Attribute*)cur-&gt;_next) {
2089     if( strcmp(cur-&gt;_ident,AttributeForm::_op_cost) == 0 ) {
2090       return cur-&gt;_val;
2091     }
2092   }
2093   return NULL;
2094 }
2095 
2096 // Return the number of leaves below this complex operand
2097 uint OperandForm::num_leaves() const {
2098   if ( ! _matrule) return 0;
2099 
2100   int num_leaves = _matrule-&gt;_numleaves;
2101   return num_leaves;
2102 }
2103 
2104 // Return the number of constants contained within this complex operand
2105 uint OperandForm::num_consts(FormDict &amp;globals) const {
2106   if ( ! _matrule) return 0;
2107 
2108   // This is a recursive invocation on all operands in the matchrule
2109   return _matrule-&gt;num_consts(globals);
2110 }
2111 
2112 // Return the number of constants in match rule with specified type
2113 uint OperandForm::num_consts(FormDict &amp;globals, Form::DataType type) const {
2114   if ( ! _matrule) return 0;
2115 
2116   // This is a recursive invocation on all operands in the matchrule
2117   return _matrule-&gt;num_consts(globals, type);
2118 }
2119 
2120 // Return the number of pointer constants contained within this complex operand
2121 uint OperandForm::num_const_ptrs(FormDict &amp;globals) const {
2122   if ( ! _matrule) return 0;
2123 
2124   // This is a recursive invocation on all operands in the matchrule
2125   return _matrule-&gt;num_const_ptrs(globals);
2126 }
2127 
2128 uint OperandForm::num_edges(FormDict &amp;globals) const {
2129   uint edges  = 0;
2130   uint leaves = num_leaves();
2131   uint consts = num_consts(globals);
2132 
2133   // If we are matching a constant directly, there are no leaves.
2134   edges = ( leaves &gt; consts ) ? leaves - consts : 0;
2135 
2136   // !!!!!
2137   // Special case operands that do not have a corresponding ideal node.
2138   if( (edges == 0) &amp;&amp; (consts == 0) ) {
2139     if( constrained_reg_class() != NULL ) {
2140       edges = 1;
2141     } else {
2142       if( _matrule
2143           &amp;&amp; (_matrule-&gt;_lChild == NULL) &amp;&amp; (_matrule-&gt;_rChild == NULL) ) {
2144         const Form *form = globals[_matrule-&gt;_opType];
2145         OperandForm *oper = form ? form-&gt;is_operand() : NULL;
2146         if( oper ) {
2147           return oper-&gt;num_edges(globals);
2148         }
2149       }
2150     }
2151   }
2152 
2153   return edges;
2154 }
2155 
2156 
2157 // Check if this operand is usable for cisc-spilling
2158 bool  OperandForm::is_cisc_reg(FormDict &amp;globals) const {
2159   const char *ideal = ideal_type(globals);
2160   bool is_cisc_reg = (ideal &amp;&amp; (ideal_to_Reg_type(ideal) != none));
2161   return is_cisc_reg;
2162 }
2163 
2164 bool  OpClassForm::is_cisc_mem(FormDict &amp;globals) const {
2165   Form::InterfaceType my_interface = interface_type(globals);
2166   return (my_interface == memory_interface);
2167 }
2168 
2169 
2170 // node matches ideal &#39;Bool&#39;
2171 bool OperandForm::is_ideal_bool() const {
2172   if( _matrule == NULL ) return false;
2173 
2174   return _matrule-&gt;is_ideal_bool();
2175 }
2176 
2177 // Require user&#39;s name for an sRegX to be stackSlotX
2178 Form::DataType OperandForm::is_user_name_for_sReg() const {
2179   DataType data_type = none;
2180   if( _ident != NULL ) {
2181     if(      strcmp(_ident,&quot;stackSlotI&quot;) == 0 ) data_type = Form::idealI;
2182     else if( strcmp(_ident,&quot;stackSlotP&quot;) == 0 ) data_type = Form::idealP;
2183     else if( strcmp(_ident,&quot;stackSlotD&quot;) == 0 ) data_type = Form::idealD;
2184     else if( strcmp(_ident,&quot;stackSlotF&quot;) == 0 ) data_type = Form::idealF;
2185     else if( strcmp(_ident,&quot;stackSlotL&quot;) == 0 ) data_type = Form::idealL;
2186   }
2187   assert((data_type == none) || (_matrule == NULL), &quot;No match-rule for stackSlotX&quot;);
2188 
2189   return data_type;
2190 }
2191 
2192 
2193 // Return ideal type, if there is a single ideal type for this operand
2194 const char *OperandForm::ideal_type(FormDict &amp;globals, RegisterForm *registers) const {
2195   const char *type = NULL;
2196   if (ideal_only()) type = _ident;
2197   else if( _matrule == NULL ) {
2198     // Check for condition code register
2199     const char *rc_name = constrained_reg_class();
2200     // !!!!!
2201     if (rc_name == NULL) return NULL;
2202     // !!!!! !!!!!
2203     // Check constraints on result&#39;s register class
2204     if( registers ) {
2205       RegClass *reg_class  = registers-&gt;getRegClass(rc_name);
2206       assert( reg_class != NULL, &quot;Register class is not defined&quot;);
2207 
2208       // Check for ideal type of entries in register class, all are the same type
2209       reg_class-&gt;reset();
2210       RegDef *reg_def = reg_class-&gt;RegDef_iter();
2211       assert( reg_def != NULL, &quot;No entries in register class&quot;);
2212       assert( reg_def-&gt;_idealtype != NULL, &quot;Did not define ideal type for register&quot;);
2213       // Return substring that names the register&#39;s ideal type
2214       type = reg_def-&gt;_idealtype + 3;
2215       assert( *(reg_def-&gt;_idealtype + 0) == &#39;O&#39;, &quot;Expect Op_ prefix&quot;);
2216       assert( *(reg_def-&gt;_idealtype + 1) == &#39;p&#39;, &quot;Expect Op_ prefix&quot;);
2217       assert( *(reg_def-&gt;_idealtype + 2) == &#39;_&#39;, &quot;Expect Op_ prefix&quot;);
2218     }
2219   }
2220   else if( _matrule-&gt;_lChild == NULL &amp;&amp; _matrule-&gt;_rChild == NULL ) {
2221     // This operand matches a single type, at the top level.
2222     // Check for ideal type
2223     type = _matrule-&gt;_opType;
2224     if( strcmp(type,&quot;Bool&quot;) == 0 )
2225       return &quot;Bool&quot;;
2226     // transitive lookup
2227     const Form *frm = globals[type];
2228     OperandForm *op = frm-&gt;is_operand();
2229     type = op-&gt;ideal_type(globals, registers);
2230   }
2231   return type;
2232 }
2233 
2234 
2235 // If there is a single ideal type for this interface field, return it.
2236 const char *OperandForm::interface_ideal_type(FormDict &amp;globals,
2237                                               const char *field) const {
2238   const char  *ideal_type = NULL;
2239   const char  *value      = NULL;
2240 
2241   // Check if &quot;field&quot; is valid for this operand&#39;s interface
2242   if ( ! is_interface_field(field, value) )   return ideal_type;
2243 
2244   // !!!!! !!!!! !!!!!
2245   // If a valid field has a constant value, identify &quot;ConI&quot; or &quot;ConP&quot; or ...
2246 
2247   // Else, lookup type of field&#39;s replacement variable
2248 
2249   return ideal_type;
2250 }
2251 
2252 
2253 RegClass* OperandForm::get_RegClass() const {
2254   if (_interface &amp;&amp; !_interface-&gt;is_RegInterface()) return NULL;
2255   return globalAD-&gt;get_registers()-&gt;getRegClass(constrained_reg_class());
2256 }
2257 
2258 
2259 bool OperandForm::is_bound_register() const {
2260   RegClass* reg_class = get_RegClass();
2261   if (reg_class == NULL) {
2262     return false;
2263   }
2264 
2265   const char* name = ideal_type(globalAD-&gt;globalNames());
2266   if (name == NULL) {
2267     return false;
2268   }
2269 
2270   uint size = 0;
2271   if (strcmp(name, &quot;RegFlags&quot;) == 0) size = 1;
2272   if (strcmp(name, &quot;RegI&quot;) == 0) size = 1;
2273   if (strcmp(name, &quot;RegF&quot;) == 0) size = 1;
2274   if (strcmp(name, &quot;RegD&quot;) == 0) size = 2;
2275   if (strcmp(name, &quot;RegL&quot;) == 0) size = 2;
2276   if (strcmp(name, &quot;RegN&quot;) == 0) size = 1;
2277   if (strcmp(name, &quot;VecX&quot;) == 0) size = 4;
2278   if (strcmp(name, &quot;VecY&quot;) == 0) size = 8;
2279   if (strcmp(name, &quot;VecZ&quot;) == 0) size = 16;
2280   if (strcmp(name, &quot;RegP&quot;) == 0) size = globalAD-&gt;get_preproc_def(&quot;_LP64&quot;) ? 2 : 1;
2281   if (size == 0) {
2282     return false;
2283   }
2284   return size == reg_class-&gt;size();
2285 }
2286 
2287 
2288 // Check if this is a valid field for this operand,
2289 // Return &#39;true&#39; if valid, and set the value to the string the user provided.
2290 bool  OperandForm::is_interface_field(const char *field,
2291                                       const char * &amp;value) const {
2292   return false;
2293 }
2294 
2295 
2296 // Return register class name if a constraint specifies the register class.
2297 const char *OperandForm::constrained_reg_class() const {
2298   const char *reg_class  = NULL;
2299   if ( _constraint ) {
2300     // !!!!!
2301     Constraint *constraint = _constraint;
2302     if ( strcmp(_constraint-&gt;_func,&quot;ALLOC_IN_RC&quot;) == 0 ) {
2303       reg_class = _constraint-&gt;_arg;
2304     }
2305   }
2306 
2307   return reg_class;
2308 }
2309 
2310 
2311 // Return the register class associated with &#39;leaf&#39;.
2312 const char *OperandForm::in_reg_class(uint leaf, FormDict &amp;globals) {
2313   const char *reg_class = NULL; // &quot;RegMask::Empty&quot;;
2314 
2315   if((_matrule == NULL) || (_matrule-&gt;is_chain_rule(globals))) {
2316     reg_class = constrained_reg_class();
2317     return reg_class;
2318   }
2319   const char *result   = NULL;
2320   const char *name     = NULL;
2321   const char *type     = NULL;
2322   // iterate through all base operands
2323   // until we reach the register that corresponds to &quot;leaf&quot;
2324   // This function is not looking for an ideal type.  It needs the first
2325   // level user type associated with the leaf.
2326   for(uint idx = 0;_matrule-&gt;base_operand(idx,globals,result,name,type);++idx) {
2327     const Form *form = (_localNames[name] ? _localNames[name] : globals[result]);
2328     OperandForm *oper = form ? form-&gt;is_operand() : NULL;
2329     if( oper ) {
2330       reg_class = oper-&gt;constrained_reg_class();
2331       if( reg_class ) {
2332         reg_class = reg_class;
2333       } else {
2334         // ShouldNotReachHere();
2335       }
2336     } else {
2337       // ShouldNotReachHere();
2338     }
2339 
2340     // Increment our target leaf position if current leaf is not a candidate.
2341     if( reg_class == NULL)    ++leaf;
2342     // Exit the loop with the value of reg_class when at the correct index
2343     if( idx == leaf )         break;
2344     // May iterate through all base operands if reg_class for &#39;leaf&#39; is NULL
2345   }
2346   return reg_class;
2347 }
2348 
2349 
2350 // Recursive call to construct list of top-level operands.
2351 // Implementation does not modify state of internal structures
2352 void OperandForm::build_components() {
2353   if (_matrule)  _matrule-&gt;append_components(_localNames, _components);
2354 
2355   // Add parameters that &quot;do not appear in match rule&quot;.
2356   const char *name;
2357   for (_parameters.reset(); (name = _parameters.iter()) != NULL;) {
2358     OpClassForm *opForm = _localNames[name]-&gt;is_opclass();
2359     assert(opForm != NULL, &quot;sanity&quot;);
2360 
2361     if ( _components.operand_position(name) == -1 ) {
2362       _components.insert(name, opForm-&gt;_ident, Component::INVALID, false);
2363     }
2364   }
2365 
2366   return;
2367 }
2368 
2369 int OperandForm::operand_position(const char *name, int usedef) {
2370   return _components.operand_position(name, usedef, this);
2371 }
2372 
2373 
2374 // Return zero-based position in component list, only counting constants;
2375 // Return -1 if not in list.
2376 int OperandForm::constant_position(FormDict &amp;globals, const Component *last) {
2377   // Iterate through components and count constants preceding &#39;constant&#39;
2378   int position = 0;
2379   Component *comp;
2380   _components.reset();
2381   while( (comp = _components.iter()) != NULL  &amp;&amp; (comp != last) ) {
2382     // Special case for operands that take a single user-defined operand
2383     // Skip the initial definition in the component list.
2384     if( strcmp(comp-&gt;_name,this-&gt;_ident) == 0 ) continue;
2385 
2386     const char *type = comp-&gt;_type;
2387     // Lookup operand form for replacement variable&#39;s type
2388     const Form *form = globals[type];
2389     assert( form != NULL, &quot;Component&#39;s type not found&quot;);
2390     OperandForm *oper = form ? form-&gt;is_operand() : NULL;
2391     if( oper ) {
2392       if( oper-&gt;_matrule-&gt;is_base_constant(globals) != Form::none ) {
2393         ++position;
2394       }
2395     }
2396   }
2397 
2398   // Check for being passed a component that was not in the list
2399   if( comp != last )  position = -1;
2400 
2401   return position;
2402 }
2403 // Provide position of constant by &quot;name&quot;
2404 int OperandForm::constant_position(FormDict &amp;globals, const char *name) {
2405   const Component *comp = _components.search(name);
2406   int idx = constant_position( globals, comp );
2407 
2408   return idx;
2409 }
2410 
2411 
2412 // Return zero-based position in component list, only counting constants;
2413 // Return -1 if not in list.
2414 int OperandForm::register_position(FormDict &amp;globals, const char *reg_name) {
2415   // Iterate through components and count registers preceding &#39;last&#39;
2416   uint  position = 0;
2417   Component *comp;
2418   _components.reset();
2419   while( (comp = _components.iter()) != NULL
2420          &amp;&amp; (strcmp(comp-&gt;_name,reg_name) != 0) ) {
2421     // Special case for operands that take a single user-defined operand
2422     // Skip the initial definition in the component list.
2423     if( strcmp(comp-&gt;_name,this-&gt;_ident) == 0 ) continue;
2424 
2425     const char *type = comp-&gt;_type;
2426     // Lookup operand form for component&#39;s type
2427     const Form *form = globals[type];
2428     assert( form != NULL, &quot;Component&#39;s type not found&quot;);
2429     OperandForm *oper = form ? form-&gt;is_operand() : NULL;
2430     if( oper ) {
2431       if( oper-&gt;_matrule-&gt;is_base_register(globals) ) {
2432         ++position;
2433       }
2434     }
2435   }
2436 
2437   return position;
2438 }
2439 
2440 
2441 const char *OperandForm::reduce_result()  const {
2442   return _ident;
2443 }
2444 // Return the name of the operand on the right hand side of the binary match
2445 // Return NULL if there is no right hand side
2446 const char *OperandForm::reduce_right(FormDict &amp;globals)  const {
2447   return  ( _matrule ? _matrule-&gt;reduce_right(globals) : NULL );
2448 }
2449 
2450 // Similar for left
2451 const char *OperandForm::reduce_left(FormDict &amp;globals)   const {
2452   return  ( _matrule ? _matrule-&gt;reduce_left(globals) : NULL );
2453 }
2454 
2455 
2456 // --------------------------- FILE *output_routines
2457 //
2458 // Output code for disp_is_oop, if true.
2459 void OperandForm::disp_is_oop(FILE *fp, FormDict &amp;globals) {
2460   //  Check it is a memory interface with a non-user-constant disp field
2461   if ( this-&gt;_interface == NULL ) return;
2462   MemInterface *mem_interface = this-&gt;_interface-&gt;is_MemInterface();
2463   if ( mem_interface == NULL )    return;
2464   const char   *disp  = mem_interface-&gt;_disp;
2465   if ( *disp != &#39;$&#39; )             return;
2466 
2467   // Lookup replacement variable in operand&#39;s component list
2468   const char   *rep_var = disp + 1;
2469   const Component *comp = this-&gt;_components.search(rep_var);
2470   assert( comp != NULL, &quot;Replacement variable not found in components&quot;);
2471   // Lookup operand form for replacement variable&#39;s type
2472   const char      *type = comp-&gt;_type;
2473   Form            *form = (Form*)globals[type];
2474   assert( form != NULL, &quot;Replacement variable&#39;s type not found&quot;);
2475   OperandForm     *op   = form-&gt;is_operand();
2476   assert( op, &quot;Memory Interface &#39;disp&#39; can only emit an operand form&quot;);
2477   // Check if this is a ConP, which may require relocation
2478   if ( op-&gt;is_base_constant(globals) == Form::idealP ) {
2479     // Find the constant&#39;s index:  _c0, _c1, _c2, ... , _cN
2480     uint idx  = op-&gt;constant_position( globals, rep_var);
2481     fprintf(fp,&quot;  virtual relocInfo::relocType disp_reloc() const {&quot;);
2482     fprintf(fp,  &quot;  return _c%d-&gt;reloc();&quot;, idx);
2483     fprintf(fp, &quot; }\n&quot;);
2484   }
2485 }
2486 
2487 // Generate code for internal and external format methods
2488 //
2489 // internal access to reg# node-&gt;_idx
2490 // access to subsumed constant _c0, _c1,
2491 void  OperandForm::int_format(FILE *fp, FormDict &amp;globals, uint index) {
2492   Form::DataType dtype;
2493   if (_matrule &amp;&amp; (_matrule-&gt;is_base_register(globals) ||
2494                    strcmp(ideal_type(globalAD-&gt;globalNames()), &quot;RegFlags&quot;) == 0)) {
2495     // !!!!! !!!!!
2496     fprintf(fp,&quot;  { char reg_str[128];\n&quot;);
2497     fprintf(fp,&quot;    ra-&gt;dump_register(node,reg_str);\n&quot;);
2498     fprintf(fp,&quot;    st-&gt;print(\&quot;%cs\&quot;,reg_str);\n&quot;,&#39;%&#39;);
2499     fprintf(fp,&quot;  }\n&quot;);
2500   } else if (_matrule &amp;&amp; (dtype = _matrule-&gt;is_base_constant(globals)) != Form::none) {
2501     format_constant( fp, index, dtype );
2502   } else if (ideal_to_sReg_type(_ident) != Form::none) {
2503     // Special format for Stack Slot Register
2504     fprintf(fp,&quot;  { char reg_str[128];\n&quot;);
2505     fprintf(fp,&quot;    ra-&gt;dump_register(node,reg_str);\n&quot;);
2506     fprintf(fp,&quot;    st-&gt;print(\&quot;%cs\&quot;,reg_str);\n&quot;,&#39;%&#39;);
2507     fprintf(fp,&quot;  }\n&quot;);
2508   } else {
2509     fprintf(fp,&quot;  st-&gt;print(\&quot;No format defined for %s\n\&quot;);\n&quot;, _ident);
2510     fflush(fp);
2511     fprintf(stderr,&quot;No format defined for %s\n&quot;, _ident);
2512     dump();
2513     assert( false,&quot;Internal error:\n  output_internal_operand() attempting to output other than a Register or Constant&quot;);
2514   }
2515 }
2516 
2517 // Similar to &quot;int_format&quot; but for cases where data is external to operand
2518 // external access to reg# node-&gt;in(idx)-&gt;_idx,
2519 void  OperandForm::ext_format(FILE *fp, FormDict &amp;globals, uint index) {
2520   Form::DataType dtype;
2521   if (_matrule &amp;&amp; (_matrule-&gt;is_base_register(globals) ||
2522                    strcmp(ideal_type(globalAD-&gt;globalNames()), &quot;RegFlags&quot;) == 0)) {
2523     fprintf(fp,&quot;  { char reg_str[128];\n&quot;);
2524     fprintf(fp,&quot;    ra-&gt;dump_register(node-&gt;in(idx&quot;);
2525     if ( index != 0 ) fprintf(fp,              &quot;+%d&quot;,index);
2526     fprintf(fp,                                      &quot;),reg_str);\n&quot;);
2527     fprintf(fp,&quot;    st-&gt;print(\&quot;%cs\&quot;,reg_str);\n&quot;,&#39;%&#39;);
2528     fprintf(fp,&quot;  }\n&quot;);
2529   } else if (_matrule &amp;&amp; (dtype = _matrule-&gt;is_base_constant(globals)) != Form::none) {
2530     format_constant( fp, index, dtype );
2531   } else if (ideal_to_sReg_type(_ident) != Form::none) {
2532     // Special format for Stack Slot Register
2533     fprintf(fp,&quot;  { char reg_str[128];\n&quot;);
2534     fprintf(fp,&quot;    ra-&gt;dump_register(node-&gt;in(idx&quot;);
2535     if ( index != 0 ) fprintf(fp,                  &quot;+%d&quot;,index);
2536     fprintf(fp,                                       &quot;),reg_str);\n&quot;);
2537     fprintf(fp,&quot;    st-&gt;print(\&quot;%cs\&quot;,reg_str);\n&quot;,&#39;%&#39;);
2538     fprintf(fp,&quot;  }\n&quot;);
2539   } else {
2540     fprintf(fp,&quot;  st-&gt;print(\&quot;No format defined for %s\n\&quot;);\n&quot;, _ident);
2541     assert( false,&quot;Internal error:\n  output_external_operand() attempting to output other than a Register or Constant&quot;);
2542   }
2543 }
2544 
2545 void OperandForm::format_constant(FILE *fp, uint const_index, uint const_type) {
2546   switch(const_type) {
2547   case Form::idealI: fprintf(fp,&quot;  st-&gt;print(\&quot;#%%d\&quot;, _c%d);\n&quot;, const_index); break;
2548   case Form::idealP: fprintf(fp,&quot;  if (_c%d) _c%d-&gt;dump_on(st);\n&quot;, const_index, const_index); break;
2549   case Form::idealNKlass:
2550   case Form::idealN: fprintf(fp,&quot;  if (_c%d) _c%d-&gt;dump_on(st);\n&quot;, const_index, const_index); break;
2551   case Form::idealL: fprintf(fp,&quot;  st-&gt;print(\&quot;#\&quot; INT64_FORMAT, (int64_t)_c%d);\n&quot;, const_index); break;
2552   case Form::idealF: fprintf(fp,&quot;  st-&gt;print(\&quot;#%%f\&quot;, _c%d);\n&quot;, const_index); break;
2553   case Form::idealD: fprintf(fp,&quot;  st-&gt;print(\&quot;#%%f\&quot;, _c%d);\n&quot;, const_index); break;
2554   default:
2555     assert( false, &quot;ShouldNotReachHere()&quot;);
2556   }
2557 }
2558 
2559 // Return the operand form corresponding to the given index, else NULL.
2560 OperandForm *OperandForm::constant_operand(FormDict &amp;globals,
2561                                            uint      index) {
2562   // !!!!!
2563   // Check behavior on complex operands
2564   uint n_consts = num_consts(globals);
2565   if( n_consts &gt; 0 ) {
2566     uint i = 0;
2567     const char *type;
2568     Component  *comp;
2569     _components.reset();
2570     if ((comp = _components.iter()) == NULL) {
2571       assert(n_consts == 1, &quot;Bad component list detected.\n&quot;);
2572       // Current operand is THE operand
2573       if ( index == 0 ) {
2574         return this;
2575       }
2576     } // end if NULL
2577     else {
2578       // Skip the first component, it can not be a DEF of a constant
2579       do {
2580         type = comp-&gt;base_type(globals);
2581         // Check that &quot;type&quot; is a &#39;ConI&#39;, &#39;ConP&#39;, ...
2582         if ( ideal_to_const_type(type) != Form::none ) {
2583           // When at correct component, get corresponding Operand
2584           if ( index == 0 ) {
2585             return globals[comp-&gt;_type]-&gt;is_operand();
2586           }
2587           // Decrement number of constants to go
2588           --index;
2589         }
2590       } while((comp = _components.iter()) != NULL);
2591     }
2592   }
2593 
2594   // Did not find a constant for this index.
2595   return NULL;
2596 }
2597 
2598 // If this operand has a single ideal type, return its type
2599 Form::DataType OperandForm::simple_type(FormDict &amp;globals) const {
2600   const char *type_name = ideal_type(globals);
2601   Form::DataType type   = type_name ? ideal_to_const_type( type_name )
2602                                     : Form::none;
2603   return type;
2604 }
2605 
2606 Form::DataType OperandForm::is_base_constant(FormDict &amp;globals) const {
2607   if ( _matrule == NULL )    return Form::none;
2608 
2609   return _matrule-&gt;is_base_constant(globals);
2610 }
2611 
2612 // &quot;true&quot; if this operand is a simple type that is swallowed
2613 bool  OperandForm::swallowed(FormDict &amp;globals) const {
2614   Form::DataType type   = simple_type(globals);
2615   if( type != Form::none ) {
2616     return true;
2617   }
2618 
2619   return false;
2620 }
2621 
2622 // Output code to access the value of the index&#39;th constant
2623 void OperandForm::access_constant(FILE *fp, FormDict &amp;globals,
2624                                   uint const_index) {
2625   OperandForm *oper = constant_operand(globals, const_index);
2626   assert( oper, &quot;Index exceeds number of constants in operand&quot;);
2627   Form::DataType dtype = oper-&gt;is_base_constant(globals);
2628 
2629   switch(dtype) {
2630   case idealI: fprintf(fp,&quot;_c%d&quot;,           const_index); break;
2631   case idealP: fprintf(fp,&quot;_c%d-&gt;get_con()&quot;,const_index); break;
2632   case idealL: fprintf(fp,&quot;_c%d&quot;,           const_index); break;
2633   case idealF: fprintf(fp,&quot;_c%d&quot;,           const_index); break;
2634   case idealD: fprintf(fp,&quot;_c%d&quot;,           const_index); break;
2635   default:
2636     assert( false, &quot;ShouldNotReachHere()&quot;);
2637   }
2638 }
2639 
2640 
2641 void OperandForm::dump() {
2642   output(stderr);
2643 }
2644 
2645 void OperandForm::output(FILE *fp) {
2646   fprintf(fp,&quot;\nOperand: %s\n&quot;, (_ident?_ident:&quot;&quot;));
2647   if (_matrule)    _matrule-&gt;dump();
2648   if (_interface)  _interface-&gt;dump();
2649   if (_attribs)    _attribs-&gt;dump();
2650   if (_predicate)  _predicate-&gt;dump();
2651   if (_constraint) _constraint-&gt;dump();
2652   if (_construct)  _construct-&gt;dump();
2653   if (_format)     _format-&gt;dump();
2654 }
2655 
2656 //------------------------------Constraint-------------------------------------
2657 Constraint::Constraint(const char *func, const char *arg)
2658   : _func(func), _arg(arg) {
2659 }
2660 Constraint::~Constraint() { /* not owner of char* */
2661 }
2662 
2663 bool Constraint::stack_slots_only() const {
2664   return strcmp(_func, &quot;ALLOC_IN_RC&quot;) == 0
2665       &amp;&amp; strcmp(_arg,  &quot;stack_slots&quot;) == 0;
2666 }
2667 
2668 void Constraint::dump() {
2669   output(stderr);
2670 }
2671 
2672 void Constraint::output(FILE *fp) {           // Write info to output files
2673   assert((_func != NULL &amp;&amp; _arg != NULL),&quot;missing constraint function or arg&quot;);
2674   fprintf(fp,&quot;Constraint: %s ( %s )\n&quot;, _func, _arg);
2675 }
2676 
2677 //------------------------------Predicate--------------------------------------
2678 Predicate::Predicate(char *pr)
2679   : _pred(pr) {
2680 }
2681 Predicate::~Predicate() {
2682 }
2683 
2684 void Predicate::dump() {
2685   output(stderr);
2686 }
2687 
2688 void Predicate::output(FILE *fp) {
2689   fprintf(fp,&quot;Predicate&quot;);  // Write to output files
2690 }
2691 //------------------------------Interface--------------------------------------
2692 Interface::Interface(const char *name) : _name(name) {
2693 }
2694 Interface::~Interface() {
2695 }
2696 
2697 Form::InterfaceType Interface::interface_type(FormDict &amp;globals) const {
2698   Interface *thsi = (Interface*)this;
2699   if ( thsi-&gt;is_RegInterface()   ) return Form::register_interface;
2700   if ( thsi-&gt;is_MemInterface()   ) return Form::memory_interface;
2701   if ( thsi-&gt;is_ConstInterface() ) return Form::constant_interface;
2702   if ( thsi-&gt;is_CondInterface()  ) return Form::conditional_interface;
2703 
2704   return Form::no_interface;
2705 }
2706 
2707 RegInterface   *Interface::is_RegInterface() {
2708   if ( strcmp(_name,&quot;REG_INTER&quot;) != 0 )
2709     return NULL;
2710   return (RegInterface*)this;
2711 }
2712 MemInterface   *Interface::is_MemInterface() {
2713   if ( strcmp(_name,&quot;MEMORY_INTER&quot;) != 0 )  return NULL;
2714   return (MemInterface*)this;
2715 }
2716 ConstInterface *Interface::is_ConstInterface() {
2717   if ( strcmp(_name,&quot;CONST_INTER&quot;) != 0 )  return NULL;
2718   return (ConstInterface*)this;
2719 }
2720 CondInterface  *Interface::is_CondInterface() {
2721   if ( strcmp(_name,&quot;COND_INTER&quot;) != 0 )  return NULL;
2722   return (CondInterface*)this;
2723 }
2724 
2725 
2726 void Interface::dump() {
2727   output(stderr);
2728 }
2729 
2730 // Write info to output files
2731 void Interface::output(FILE *fp) {
2732   fprintf(fp,&quot;Interface: %s\n&quot;, (_name ? _name : &quot;&quot;) );
2733 }
2734 
2735 //------------------------------RegInterface-----------------------------------
2736 RegInterface::RegInterface() : Interface(&quot;REG_INTER&quot;) {
2737 }
2738 RegInterface::~RegInterface() {
2739 }
2740 
2741 void RegInterface::dump() {
2742   output(stderr);
2743 }
2744 
2745 // Write info to output files
2746 void RegInterface::output(FILE *fp) {
2747   Interface::output(fp);
2748 }
2749 
2750 //------------------------------ConstInterface---------------------------------
2751 ConstInterface::ConstInterface() : Interface(&quot;CONST_INTER&quot;) {
2752 }
2753 ConstInterface::~ConstInterface() {
2754 }
2755 
2756 void ConstInterface::dump() {
2757   output(stderr);
2758 }
2759 
2760 // Write info to output files
2761 void ConstInterface::output(FILE *fp) {
2762   Interface::output(fp);
2763 }
2764 
2765 //------------------------------MemInterface-----------------------------------
2766 MemInterface::MemInterface(char *base, char *index, char *scale, char *disp)
2767   : Interface(&quot;MEMORY_INTER&quot;), _base(base), _index(index), _scale(scale), _disp(disp) {
2768 }
2769 MemInterface::~MemInterface() {
2770   // not owner of any character arrays
2771 }
2772 
2773 void MemInterface::dump() {
2774   output(stderr);
2775 }
2776 
2777 // Write info to output files
2778 void MemInterface::output(FILE *fp) {
2779   Interface::output(fp);
2780   if ( _base  != NULL ) fprintf(fp,&quot;  base  == %s\n&quot;, _base);
2781   if ( _index != NULL ) fprintf(fp,&quot;  index == %s\n&quot;, _index);
2782   if ( _scale != NULL ) fprintf(fp,&quot;  scale == %s\n&quot;, _scale);
2783   if ( _disp  != NULL ) fprintf(fp,&quot;  disp  == %s\n&quot;, _disp);
2784   // fprintf(fp,&quot;\n&quot;);
2785 }
2786 
2787 //------------------------------CondInterface----------------------------------
2788 CondInterface::CondInterface(const char* equal,         const char* equal_format,
2789                              const char* not_equal,     const char* not_equal_format,
2790                              const char* less,          const char* less_format,
2791                              const char* greater_equal, const char* greater_equal_format,
2792                              const char* less_equal,    const char* less_equal_format,
2793                              const char* greater,       const char* greater_format,
2794                              const char* overflow,      const char* overflow_format,
2795                              const char* no_overflow,   const char* no_overflow_format)
2796   : Interface(&quot;COND_INTER&quot;),
2797     _equal(equal),                 _equal_format(equal_format),
2798     _not_equal(not_equal),         _not_equal_format(not_equal_format),
2799     _less(less),                   _less_format(less_format),
2800     _greater_equal(greater_equal), _greater_equal_format(greater_equal_format),
2801     _less_equal(less_equal),       _less_equal_format(less_equal_format),
2802     _greater(greater),             _greater_format(greater_format),
2803     _overflow(overflow),           _overflow_format(overflow_format),
2804     _no_overflow(no_overflow),     _no_overflow_format(no_overflow_format) {
2805 }
2806 CondInterface::~CondInterface() {
2807   // not owner of any character arrays
2808 }
2809 
2810 void CondInterface::dump() {
2811   output(stderr);
2812 }
2813 
2814 // Write info to output files
2815 void CondInterface::output(FILE *fp) {
2816   Interface::output(fp);
2817   if ( _equal  != NULL )     fprintf(fp,&quot; equal        == %s\n&quot;, _equal);
2818   if ( _not_equal  != NULL ) fprintf(fp,&quot; not_equal    == %s\n&quot;, _not_equal);
2819   if ( _less  != NULL )      fprintf(fp,&quot; less         == %s\n&quot;, _less);
2820   if ( _greater_equal  != NULL ) fprintf(fp,&quot; greater_equal    == %s\n&quot;, _greater_equal);
2821   if ( _less_equal  != NULL ) fprintf(fp,&quot; less_equal   == %s\n&quot;, _less_equal);
2822   if ( _greater  != NULL )    fprintf(fp,&quot; greater      == %s\n&quot;, _greater);
2823   if ( _overflow != NULL )    fprintf(fp,&quot; overflow     == %s\n&quot;, _overflow);
2824   if ( _no_overflow != NULL ) fprintf(fp,&quot; no_overflow  == %s\n&quot;, _no_overflow);
2825   // fprintf(fp,&quot;\n&quot;);
2826 }
2827 
2828 //------------------------------ConstructRule----------------------------------
2829 ConstructRule::ConstructRule(char *cnstr)
2830   : _construct(cnstr) {
2831 }
2832 ConstructRule::~ConstructRule() {
2833 }
2834 
2835 void ConstructRule::dump() {
2836   output(stderr);
2837 }
2838 
2839 void ConstructRule::output(FILE *fp) {
2840   fprintf(fp,&quot;\nConstruct Rule\n&quot;);  // Write to output files
2841 }
2842 
2843 
2844 //==============================Shared Forms===================================
2845 //------------------------------AttributeForm----------------------------------
2846 int         AttributeForm::_insId   = 0;           // start counter at 0
2847 int         AttributeForm::_opId    = 0;           // start counter at 0
2848 const char* AttributeForm::_ins_cost = &quot;ins_cost&quot;; // required name
2849 const char* AttributeForm::_op_cost  = &quot;op_cost&quot;;  // required name
2850 
2851 AttributeForm::AttributeForm(char *attr, int type, char *attrdef)
2852   : Form(Form::ATTR), _attrname(attr), _atype(type), _attrdef(attrdef) {
2853     if (type==OP_ATTR) {
2854       id = ++_opId;
2855     }
2856     else if (type==INS_ATTR) {
2857       id = ++_insId;
2858     }
2859     else assert( false,&quot;&quot;);
2860 }
2861 AttributeForm::~AttributeForm() {
2862 }
2863 
2864 // Dynamic type check
2865 AttributeForm *AttributeForm::is_attribute() const {
2866   return (AttributeForm*)this;
2867 }
2868 
2869 
2870 // inlined  // int  AttributeForm::type() { return id;}
2871 
2872 void AttributeForm::dump() {
2873   output(stderr);
2874 }
2875 
2876 void AttributeForm::output(FILE *fp) {
2877   if( _attrname &amp;&amp; _attrdef ) {
2878     fprintf(fp,&quot;\n// AttributeForm \nstatic const int %s = %s;\n&quot;,
2879             _attrname, _attrdef);
2880   }
2881   else {
2882     fprintf(fp,&quot;\n// AttributeForm missing name %s or definition %s\n&quot;,
2883             (_attrname?_attrname:&quot;&quot;), (_attrdef?_attrdef:&quot;&quot;) );
2884   }
2885 }
2886 
2887 //------------------------------Component--------------------------------------
2888 Component::Component(const char *name, const char *type, int usedef)
2889   : _name(name), _type(type), _usedef(usedef) {
2890     _ftype = Form::COMP;
2891 }
2892 Component::~Component() {
2893 }
2894 
2895 // True if this component is equal to the parameter.
2896 bool Component::is(int use_def_kill_enum) const {
2897   return (_usedef == use_def_kill_enum ? true : false);
2898 }
2899 // True if this component is used/def&#39;d/kill&#39;d as the parameter suggests.
2900 bool Component::isa(int use_def_kill_enum) const {
2901   return (_usedef &amp; use_def_kill_enum) == use_def_kill_enum;
2902 }
2903 
2904 // Extend this component with additional use/def/kill behavior
2905 int Component::promote_use_def_info(int new_use_def) {
2906   _usedef |= new_use_def;
2907 
2908   return _usedef;
2909 }
2910 
2911 // Check the base type of this component, if it has one
2912 const char *Component::base_type(FormDict &amp;globals) {
2913   const Form *frm = globals[_type];
2914   if (frm == NULL) return NULL;
2915   OperandForm *op = frm-&gt;is_operand();
2916   if (op == NULL) return NULL;
2917   if (op-&gt;ideal_only()) return op-&gt;_ident;
2918   return (char *)op-&gt;ideal_type(globals);
2919 }
2920 
2921 void Component::dump() {
2922   output(stderr);
2923 }
2924 
2925 void Component::output(FILE *fp) {
2926   fprintf(fp,&quot;Component:&quot;);  // Write to output files
2927   fprintf(fp, &quot;  name = %s&quot;, _name);
2928   fprintf(fp, &quot;, type = %s&quot;, _type);
2929   assert(_usedef != 0, &quot;unknown effect&quot;);
2930   fprintf(fp, &quot;, use/def = %s\n&quot;, getUsedefName());
2931 }
2932 
2933 
2934 //------------------------------ComponentList---------------------------------
2935 ComponentList::ComponentList() : NameList(), _matchcnt(0) {
2936 }
2937 ComponentList::~ComponentList() {
2938   // // This list may not own its elements if copied via assignment
2939   // Component *component;
2940   // for (reset(); (component = iter()) != NULL;) {
2941   //   delete component;
2942   // }
2943 }
2944 
2945 void   ComponentList::insert(Component *component, bool mflag) {
2946   NameList::addName((char *)component);
2947   if(mflag) _matchcnt++;
2948 }
2949 void   ComponentList::insert(const char *name, const char *opType, int usedef,
2950                              bool mflag) {
2951   Component * component = new Component(name, opType, usedef);
2952   insert(component, mflag);
2953 }
2954 Component *ComponentList::current() { return (Component*)NameList::current(); }
2955 Component *ComponentList::iter()    { return (Component*)NameList::iter(); }
2956 Component *ComponentList::match_iter() {
2957   if(_iter &lt; _matchcnt) return (Component*)NameList::iter();
2958   return NULL;
2959 }
2960 Component *ComponentList::post_match_iter() {
2961   Component *comp = iter();
2962   // At end of list?
2963   if ( comp == NULL ) {
2964     return comp;
2965   }
2966   // In post-match components?
2967   if (_iter &gt; match_count()-1) {
2968     return comp;
2969   }
2970 
2971   return post_match_iter();
2972 }
2973 
2974 void       ComponentList::reset()   { NameList::reset(); }
2975 int        ComponentList::count()   { return NameList::count(); }
2976 
2977 Component *ComponentList::operator[](int position) {
2978   // Shortcut complete iteration if there are not enough entries
2979   if (position &gt;= count()) return NULL;
2980 
2981   int        index     = 0;
2982   Component *component = NULL;
2983   for (reset(); (component = iter()) != NULL;) {
2984     if (index == position) {
2985       return component;
2986     }
2987     ++index;
2988   }
2989 
2990   return NULL;
2991 }
2992 
2993 const Component *ComponentList::search(const char *name) {
2994   PreserveIter pi(this);
2995   reset();
2996   for( Component *comp = NULL; ((comp = iter()) != NULL); ) {
2997     if( strcmp(comp-&gt;_name,name) == 0 ) return comp;
2998   }
2999 
3000   return NULL;
3001 }
3002 
3003 // Return number of USEs + number of DEFs
3004 // When there are no components, or the first component is a USE,
3005 // then we add &#39;1&#39; to hold a space for the &#39;result&#39; operand.
3006 int ComponentList::num_operands() {
3007   PreserveIter pi(this);
3008   uint       count = 1;           // result operand
3009   uint       position = 0;
3010 
3011   Component *component  = NULL;
3012   for( reset(); (component = iter()) != NULL; ++position ) {
3013     if( component-&gt;isa(Component::USE) ||
3014         ( position == 0 &amp;&amp; (! component-&gt;isa(Component::DEF))) ) {
3015       ++count;
3016     }
3017   }
3018 
3019   return count;
3020 }
3021 
3022 // Return zero-based position of operand &#39;name&#39; in list;  -1 if not in list.
3023 // if parameter &#39;usedef&#39; is ::USE, it will match USE, USE_DEF, ...
3024 int ComponentList::operand_position(const char *name, int usedef, Form *fm) {
3025   PreserveIter pi(this);
3026   int position = 0;
3027   int num_opnds = num_operands();
3028   Component *component;
3029   Component* preceding_non_use = NULL;
3030   Component* first_def = NULL;
3031   for (reset(); (component = iter()) != NULL; ++position) {
3032     // When the first component is not a DEF,
3033     // leave space for the result operand!
3034     if ( position==0 &amp;&amp; (! component-&gt;isa(Component::DEF)) ) {
3035       ++position;
3036       ++num_opnds;
3037     }
3038     if (strcmp(name, component-&gt;_name)==0 &amp;&amp; (component-&gt;isa(usedef))) {
3039       // When the first entry in the component list is a DEF and a USE
3040       // Treat them as being separate, a DEF first, then a USE
3041       if( position==0
3042           &amp;&amp; usedef==Component::USE &amp;&amp; component-&gt;isa(Component::DEF) ) {
3043         assert(position+1 &lt; num_opnds, &quot;advertised index in bounds&quot;);
3044         return position+1;
3045       } else {
3046         if( preceding_non_use &amp;&amp; strcmp(component-&gt;_name, preceding_non_use-&gt;_name) ) {
3047           fprintf(stderr, &quot;the name &#39;%s(%s)&#39; should not precede the name &#39;%s(%s)&#39;&quot;,
3048                   preceding_non_use-&gt;_name, preceding_non_use-&gt;getUsedefName(),
3049                   name, component-&gt;getUsedefName());
3050           if (fm &amp;&amp; fm-&gt;is_instruction()) fprintf(stderr,  &quot;in form &#39;%s&#39;&quot;, fm-&gt;is_instruction()-&gt;_ident);
3051           if (fm &amp;&amp; fm-&gt;is_operand()) fprintf(stderr,  &quot;in form &#39;%s&#39;&quot;, fm-&gt;is_operand()-&gt;_ident);
3052           fprintf(stderr,  &quot;\n&quot;);
3053         }
3054         if( position &gt;= num_opnds ) {
3055           fprintf(stderr, &quot;the name &#39;%s&#39; is too late in its name list&quot;, name);
3056           if (fm &amp;&amp; fm-&gt;is_instruction()) fprintf(stderr,  &quot;in form &#39;%s&#39;&quot;, fm-&gt;is_instruction()-&gt;_ident);
3057           if (fm &amp;&amp; fm-&gt;is_operand()) fprintf(stderr,  &quot;in form &#39;%s&#39;&quot;, fm-&gt;is_operand()-&gt;_ident);
3058           fprintf(stderr,  &quot;\n&quot;);
3059         }
3060         assert(position &lt; num_opnds, &quot;advertised index in bounds&quot;);
3061         return position;
3062       }
3063     }
3064     if( component-&gt;isa(Component::DEF)
3065         &amp;&amp; component-&gt;isa(Component::USE) ) {
3066       ++position;
3067       if( position != 1 )  --position;   // only use two slots for the 1st USE_DEF
3068     }
3069     if( component-&gt;isa(Component::DEF) &amp;&amp; !first_def ) {
3070       first_def = component;
3071     }
3072     if( !component-&gt;isa(Component::USE) &amp;&amp; component != first_def ) {
3073       preceding_non_use = component;
3074     } else if( preceding_non_use &amp;&amp; !strcmp(component-&gt;_name, preceding_non_use-&gt;_name) ) {
3075       preceding_non_use = NULL;
3076     }
3077   }
3078   return Not_in_list;
3079 }
3080 
3081 // Find position for this name, regardless of use/def information
3082 int ComponentList::operand_position(const char *name) {
3083   PreserveIter pi(this);
3084   int position = 0;
3085   Component *component;
3086   for (reset(); (component = iter()) != NULL; ++position) {
3087     // When the first component is not a DEF,
3088     // leave space for the result operand!
3089     if ( position==0 &amp;&amp; (! component-&gt;isa(Component::DEF)) ) {
3090       ++position;
3091     }
3092     if (strcmp(name, component-&gt;_name)==0) {
3093       return position;
3094     }
3095     if( component-&gt;isa(Component::DEF)
3096         &amp;&amp; component-&gt;isa(Component::USE) ) {
3097       ++position;
3098       if( position != 1 )  --position;   // only use two slots for the 1st USE_DEF
3099     }
3100   }
3101   return Not_in_list;
3102 }
3103 
3104 int ComponentList::operand_position_format(const char *name, Form *fm) {
3105   PreserveIter pi(this);
3106   int  first_position = operand_position(name);
3107   int  use_position   = operand_position(name, Component::USE, fm);
3108 
3109   return ((first_position &lt; use_position) ? use_position : first_position);
3110 }
3111 
3112 int ComponentList::label_position() {
3113   PreserveIter pi(this);
3114   int position = 0;
3115   reset();
3116   for( Component *comp; (comp = iter()) != NULL; ++position) {
3117     // When the first component is not a DEF,
3118     // leave space for the result operand!
3119     if ( position==0 &amp;&amp; (! comp-&gt;isa(Component::DEF)) ) {
3120       ++position;
3121     }
3122     if (strcmp(comp-&gt;_type, &quot;label&quot;)==0) {
3123       return position;
3124     }
3125     if( comp-&gt;isa(Component::DEF)
3126         &amp;&amp; comp-&gt;isa(Component::USE) ) {
3127       ++position;
3128       if( position != 1 )  --position;   // only use two slots for the 1st USE_DEF
3129     }
3130   }
3131 
3132   return -1;
3133 }
3134 
3135 int ComponentList::method_position() {
3136   PreserveIter pi(this);
3137   int position = 0;
3138   reset();
3139   for( Component *comp; (comp = iter()) != NULL; ++position) {
3140     // When the first component is not a DEF,
3141     // leave space for the result operand!
3142     if ( position==0 &amp;&amp; (! comp-&gt;isa(Component::DEF)) ) {
3143       ++position;
3144     }
3145     if (strcmp(comp-&gt;_type, &quot;method&quot;)==0) {
3146       return position;
3147     }
3148     if( comp-&gt;isa(Component::DEF)
3149         &amp;&amp; comp-&gt;isa(Component::USE) ) {
3150       ++position;
3151       if( position != 1 )  --position;   // only use two slots for the 1st USE_DEF
3152     }
3153   }
3154 
3155   return -1;
3156 }
3157 
3158 void ComponentList::dump() { output(stderr); }
3159 
3160 void ComponentList::output(FILE *fp) {
3161   PreserveIter pi(this);
3162   fprintf(fp, &quot;\n&quot;);
3163   Component *component;
3164   for (reset(); (component = iter()) != NULL;) {
3165     component-&gt;output(fp);
3166   }
3167   fprintf(fp, &quot;\n&quot;);
3168 }
3169 
3170 //------------------------------MatchNode--------------------------------------
3171 MatchNode::MatchNode(ArchDesc &amp;ad, const char *result, const char *mexpr,
3172                      const char *opType, MatchNode *lChild, MatchNode *rChild)
3173   : _AD(ad), _result(result), _name(mexpr), _opType(opType),
3174     _lChild(lChild), _rChild(rChild), _internalop(0), _numleaves(0),
3175     _commutative_id(0) {
3176   _numleaves = (lChild ? lChild-&gt;_numleaves : 0)
3177                + (rChild ? rChild-&gt;_numleaves : 0);
3178 }
3179 
3180 MatchNode::MatchNode(ArchDesc &amp;ad, MatchNode&amp; mnode)
3181   : _AD(ad), _result(mnode._result), _name(mnode._name),
3182     _opType(mnode._opType), _lChild(mnode._lChild), _rChild(mnode._rChild),
3183     _internalop(0), _numleaves(mnode._numleaves),
3184     _commutative_id(mnode._commutative_id) {
3185 }
3186 
3187 MatchNode::MatchNode(ArchDesc &amp;ad, MatchNode&amp; mnode, int clone)
3188   : _AD(ad), _result(mnode._result), _name(mnode._name),
3189     _opType(mnode._opType),
3190     _internalop(0), _numleaves(mnode._numleaves),
3191     _commutative_id(mnode._commutative_id) {
3192   if (mnode._lChild) {
3193     _lChild = new MatchNode(ad, *mnode._lChild, clone);
3194   } else {
3195     _lChild = NULL;
3196   }
3197   if (mnode._rChild) {
3198     _rChild = new MatchNode(ad, *mnode._rChild, clone);
3199   } else {
3200     _rChild = NULL;
3201   }
3202 }
3203 
3204 MatchNode::~MatchNode() {
3205   // // This node may not own its children if copied via assignment
3206   // if( _lChild ) delete _lChild;
3207   // if( _rChild ) delete _rChild;
3208 }
3209 
3210 bool  MatchNode::find_type(const char *type, int &amp;position) const {
3211   if ( (_lChild != NULL) &amp;&amp; (_lChild-&gt;find_type(type, position)) ) return true;
3212   if ( (_rChild != NULL) &amp;&amp; (_rChild-&gt;find_type(type, position)) ) return true;
3213 
3214   if (strcmp(type,_opType)==0)  {
3215     return true;
3216   } else {
3217     ++position;
3218   }
3219   return false;
3220 }
3221 
3222 // Recursive call collecting info on top-level operands, not transitive.
3223 // Implementation does not modify state of internal structures.
3224 void MatchNode::append_components(FormDict&amp; locals, ComponentList&amp; components,
3225                                   bool def_flag) const {
3226   int usedef = def_flag ? Component::DEF : Component::USE;
3227   FormDict &amp;globals = _AD.globalNames();
3228 
3229   assert (_name != NULL, &quot;MatchNode::build_components encountered empty node\n&quot;);
3230   // Base case
3231   if (_lChild==NULL &amp;&amp; _rChild==NULL) {
3232     // If _opType is not an operation, do not build a component for it #####
3233     const Form *f = globals[_opType];
3234     if( f != NULL ) {
3235       // Add non-ideals that are operands, operand-classes,
3236       if( ! f-&gt;ideal_only()
3237           &amp;&amp; (f-&gt;is_opclass() || f-&gt;is_operand()) ) {
3238         components.insert(_name, _opType, usedef, true);
3239       }
3240     }
3241     return;
3242   }
3243   // Promote results of &quot;Set&quot; to DEF
3244   bool tmpdef_flag = (!strcmp(_opType, &quot;Set&quot;)) ? true : false;
3245   if (_lChild) _lChild-&gt;append_components(locals, components, tmpdef_flag);
3246   tmpdef_flag = false;   // only applies to component immediately following &#39;Set&#39;
3247   if (_rChild) _rChild-&gt;append_components(locals, components, tmpdef_flag);
3248 }
3249 
3250 // Find the n&#39;th base-operand in the match node,
3251 // recursively investigates match rules of user-defined operands.
3252 //
3253 // Implementation does not modify state of internal structures since they
3254 // can be shared.
3255 bool MatchNode::base_operand(uint &amp;position, FormDict &amp;globals,
3256                              const char * &amp;result, const char * &amp;name,
3257                              const char * &amp;opType) const {
3258   assert (_name != NULL, &quot;MatchNode::base_operand encountered empty node\n&quot;);
3259   // Base case
3260   if (_lChild==NULL &amp;&amp; _rChild==NULL) {
3261     // Check for special case: &quot;Universe&quot;, &quot;label&quot;
3262     if (strcmp(_opType,&quot;Universe&quot;) == 0 || strcmp(_opType,&quot;label&quot;)==0 ) {
3263       if (position == 0) {
3264         result = _result;
3265         name   = _name;
3266         opType = _opType;
3267         return 1;
3268       } else {
3269         -- position;
3270         return 0;
3271       }
3272     }
3273 
3274     const Form *form = globals[_opType];
3275     MatchNode *matchNode = NULL;
3276     // Check for user-defined type
3277     if (form) {
3278       // User operand or instruction?
3279       OperandForm  *opForm = form-&gt;is_operand();
3280       InstructForm *inForm = form-&gt;is_instruction();
3281       if ( opForm ) {
3282         matchNode = (MatchNode*)opForm-&gt;_matrule;
3283       } else if ( inForm ) {
3284         matchNode = (MatchNode*)inForm-&gt;_matrule;
3285       }
3286     }
3287     // if this is user-defined, recurse on match rule
3288     // User-defined operand and instruction forms have a match-rule.
3289     if (matchNode) {
3290       return (matchNode-&gt;base_operand(position,globals,result,name,opType));
3291     } else {
3292       // Either not a form, or a system-defined form (no match rule).
3293       if (position==0) {
3294         result = _result;
3295         name   = _name;
3296         opType = _opType;
3297         return 1;
3298       } else {
3299         --position;
3300         return 0;
3301       }
3302     }
3303 
3304   } else {
3305     // Examine the left child and right child as well
3306     if (_lChild) {
3307       if (_lChild-&gt;base_operand(position, globals, result, name, opType))
3308         return 1;
3309     }
3310 
3311     if (_rChild) {
3312       if (_rChild-&gt;base_operand(position, globals, result, name, opType))
3313         return 1;
3314     }
3315   }
3316 
3317   return 0;
3318 }
3319 
3320 // Recursive call on all operands&#39; match rules in my match rule.
3321 uint  MatchNode::num_consts(FormDict &amp;globals) const {
3322   uint        index      = 0;
3323   uint        num_consts = 0;
3324   const char *result;
3325   const char *name;
3326   const char *opType;
3327 
3328   for (uint position = index;
3329        base_operand(position,globals,result,name,opType); position = index) {
3330     ++index;
3331     if( ideal_to_const_type(opType) )        num_consts++;
3332   }
3333 
3334   return num_consts;
3335 }
3336 
3337 // Recursive call on all operands&#39; match rules in my match rule.
3338 // Constants in match rule subtree with specified type
3339 uint  MatchNode::num_consts(FormDict &amp;globals, Form::DataType type) const {
3340   uint        index      = 0;
3341   uint        num_consts = 0;
3342   const char *result;
3343   const char *name;
3344   const char *opType;
3345 
3346   for (uint position = index;
3347        base_operand(position,globals,result,name,opType); position = index) {
3348     ++index;
3349     if( ideal_to_const_type(opType) == type ) num_consts++;
3350   }
3351 
3352   return num_consts;
3353 }
3354 
3355 // Recursive call on all operands&#39; match rules in my match rule.
3356 uint  MatchNode::num_const_ptrs(FormDict &amp;globals) const {
3357   return  num_consts( globals, Form::idealP );
3358 }
3359 
3360 bool  MatchNode::sets_result() const {
3361   return   ( (strcmp(_name,&quot;Set&quot;) == 0) ? true : false );
3362 }
3363 
3364 const char *MatchNode::reduce_right(FormDict &amp;globals) const {
3365   // If there is no right reduction, return NULL.
3366   const char      *rightStr    = NULL;
3367 
3368   // If we are a &quot;Set&quot;, start from the right child.
3369   const MatchNode *const mnode = sets_result() ?
3370     (const MatchNode *)this-&gt;_rChild :
3371     (const MatchNode *)this;
3372 
3373   // If our right child exists, it is the right reduction
3374   if ( mnode-&gt;_rChild ) {
3375     rightStr = mnode-&gt;_rChild-&gt;_internalop ? mnode-&gt;_rChild-&gt;_internalop
3376       : mnode-&gt;_rChild-&gt;_opType;
3377   }
3378   // Else, May be simple chain rule: (Set dst operand_form), rightStr=NULL;
3379   return rightStr;
3380 }
3381 
3382 const char *MatchNode::reduce_left(FormDict &amp;globals) const {
3383   // If there is no left reduction, return NULL.
3384   const char  *leftStr  = NULL;
3385 
3386   // If we are a &quot;Set&quot;, start from the right child.
3387   const MatchNode *const mnode = sets_result() ?
3388     (const MatchNode *)this-&gt;_rChild :
3389     (const MatchNode *)this;
3390 
3391   // If our left child exists, it is the left reduction
3392   if ( mnode-&gt;_lChild ) {
3393     leftStr = mnode-&gt;_lChild-&gt;_internalop ? mnode-&gt;_lChild-&gt;_internalop
3394       : mnode-&gt;_lChild-&gt;_opType;
3395   } else {
3396     // May be simple chain rule: (Set dst operand_form_source)
3397     if ( sets_result() ) {
3398       OperandForm *oper = globals[mnode-&gt;_opType]-&gt;is_operand();
3399       if( oper ) {
3400         leftStr = mnode-&gt;_opType;
3401       }
3402     }
3403   }
3404   return leftStr;
3405 }
3406 
3407 //------------------------------count_instr_names------------------------------
3408 // Count occurrences of operands names in the leaves of the instruction
3409 // match rule.
3410 void MatchNode::count_instr_names( Dict &amp;names ) {
<a name="8" id="anc8"></a><span class="line-removed">3411   if( this == NULL ) return;</span>
3412   if( _lChild ) _lChild-&gt;count_instr_names(names);
3413   if( _rChild ) _rChild-&gt;count_instr_names(names);
3414   if( !_lChild &amp;&amp; !_rChild ) {
3415     uintptr_t cnt = (uintptr_t)names[_name];
3416     cnt++;                      // One more name found
3417     names.Insert(_name,(void*)cnt);
3418   }
3419 }
3420 
3421 //------------------------------build_instr_pred-------------------------------
3422 // Build a path to &#39;name&#39; in buf.  Actually only build if cnt is zero, so we
3423 // can skip some leading instances of &#39;name&#39;.
3424 int MatchNode::build_instr_pred( char *buf, const char *name, int cnt ) {
3425   if( _lChild ) {
3426     if( !cnt ) strcpy( buf, &quot;_kids[0]-&gt;&quot; );
3427     cnt = _lChild-&gt;build_instr_pred( buf+strlen(buf), name, cnt );
3428     if( cnt &lt; 0 ) return cnt;   // Found it, all done
3429   }
3430   if( _rChild ) {
3431     if( !cnt ) strcpy( buf, &quot;_kids[1]-&gt;&quot; );
3432     cnt = _rChild-&gt;build_instr_pred( buf+strlen(buf), name, cnt );
3433     if( cnt &lt; 0 ) return cnt;   // Found it, all done
3434   }
3435   if( !_lChild &amp;&amp; !_rChild ) {  // Found a leaf
3436     // Wrong name?  Give up...
3437     if( strcmp(name,_name) ) return cnt;
3438     if( !cnt ) strcpy(buf,&quot;_leaf&quot;);
3439     return cnt-1;
3440   }
3441   return cnt;
3442 }
3443 
3444 
3445 //------------------------------build_internalop-------------------------------
3446 // Build string representation of subtree
3447 void MatchNode::build_internalop( ) {
3448   char *iop, *subtree;
3449   const char *lstr, *rstr;
3450   // Build string representation of subtree
3451   // Operation lchildType rchildType
3452   int len = (int)strlen(_opType) + 4;
3453   lstr = (_lChild) ? ((_lChild-&gt;_internalop) ?
3454                        _lChild-&gt;_internalop : _lChild-&gt;_opType) : &quot;&quot;;
3455   rstr = (_rChild) ? ((_rChild-&gt;_internalop) ?
3456                        _rChild-&gt;_internalop : _rChild-&gt;_opType) : &quot;&quot;;
3457   len += (int)strlen(lstr) + (int)strlen(rstr);
3458   subtree = (char *)AllocateHeap(len);
3459   sprintf(subtree,&quot;_%s_%s_%s&quot;, _opType, lstr, rstr);
3460   // Hash the subtree string in _internalOps; if a name exists, use it
3461   iop = (char *)_AD._internalOps[subtree];
3462   // Else create a unique name, and add it to the hash table
3463   if (iop == NULL) {
3464     iop = subtree;
3465     _AD._internalOps.Insert(subtree, iop);
3466     _AD._internalOpNames.addName(iop);
3467     _AD._internalMatch.Insert(iop, this);
3468   }
3469   // Add the internal operand name to the MatchNode
3470   _internalop = iop;
3471   _result = iop;
3472 }
3473 
3474 
3475 void MatchNode::dump() {
3476   output(stderr);
3477 }
3478 
3479 void MatchNode::output(FILE *fp) {
3480   if (_lChild==0 &amp;&amp; _rChild==0) {
3481     fprintf(fp,&quot; %s&quot;,_name);    // operand
3482   }
3483   else {
3484     fprintf(fp,&quot; (%s &quot;,_name);  // &quot; (opcodeName &quot;
3485     if(_lChild) _lChild-&gt;output(fp); //               left operand
3486     if(_rChild) _rChild-&gt;output(fp); //                    right operand
3487     fprintf(fp,&quot;)&quot;);                 //                                 &quot;)&quot;
3488   }
3489 }
3490 
3491 int MatchNode::needs_ideal_memory_edge(FormDict &amp;globals) const {
3492   static const char *needs_ideal_memory_list[] = {
3493     &quot;StoreI&quot;,&quot;StoreL&quot;,&quot;StoreP&quot;,&quot;StoreN&quot;,&quot;StoreNKlass&quot;,&quot;StoreD&quot;,&quot;StoreF&quot; ,
3494     &quot;StoreB&quot;,&quot;StoreC&quot;,&quot;Store&quot; ,&quot;StoreFP&quot;,
3495     &quot;LoadI&quot;, &quot;LoadL&quot;, &quot;LoadP&quot; ,&quot;LoadN&quot;, &quot;LoadD&quot; ,&quot;LoadF&quot;  ,
3496     &quot;LoadB&quot; , &quot;LoadUB&quot;, &quot;LoadUS&quot; ,&quot;LoadS&quot; ,&quot;Load&quot; ,
3497     &quot;StoreVector&quot;, &quot;LoadVector&quot;,
3498     &quot;LoadRange&quot;, &quot;LoadKlass&quot;, &quot;LoadNKlass&quot;, &quot;LoadL_unaligned&quot;, &quot;LoadD_unaligned&quot;,
3499     &quot;LoadPLocked&quot;,
3500     &quot;StorePConditional&quot;, &quot;StoreIConditional&quot;, &quot;StoreLConditional&quot;,
3501     &quot;CompareAndSwapB&quot;, &quot;CompareAndSwapS&quot;, &quot;CompareAndSwapI&quot;, &quot;CompareAndSwapL&quot;, &quot;CompareAndSwapP&quot;, &quot;CompareAndSwapN&quot;,
3502     &quot;WeakCompareAndSwapB&quot;, &quot;WeakCompareAndSwapS&quot;, &quot;WeakCompareAndSwapI&quot;, &quot;WeakCompareAndSwapL&quot;, &quot;WeakCompareAndSwapP&quot;, &quot;WeakCompareAndSwapN&quot;,
3503     &quot;CompareAndExchangeB&quot;, &quot;CompareAndExchangeS&quot;, &quot;CompareAndExchangeI&quot;, &quot;CompareAndExchangeL&quot;, &quot;CompareAndExchangeP&quot;, &quot;CompareAndExchangeN&quot;,
<a name="9" id="anc9"></a>
3504     &quot;ShenandoahCompareAndSwapN&quot;, &quot;ShenandoahCompareAndSwapP&quot;, &quot;ShenandoahWeakCompareAndSwapP&quot;, &quot;ShenandoahWeakCompareAndSwapN&quot;, &quot;ShenandoahCompareAndExchangeP&quot;, &quot;ShenandoahCompareAndExchangeN&quot;,
<a name="10" id="anc10"></a>
3505     &quot;StoreCM&quot;,
<a name="11" id="anc11"></a><span class="line-removed">3506     &quot;ClearArray&quot;,</span>
3507     &quot;GetAndSetB&quot;, &quot;GetAndSetS&quot;, &quot;GetAndAddI&quot;, &quot;GetAndSetI&quot;, &quot;GetAndSetP&quot;,
3508     &quot;GetAndAddB&quot;, &quot;GetAndAddS&quot;, &quot;GetAndAddL&quot;, &quot;GetAndSetL&quot;, &quot;GetAndSetN&quot;,
<a name="12" id="anc12"></a><span class="line-modified">3509     &quot;ShenandoahReadBarrier&quot;,</span>
<span class="line-removed">3510     &quot;LoadBarrierSlowReg&quot;, &quot;LoadBarrierWeakSlowReg&quot;</span>
3511   };
3512   int cnt = sizeof(needs_ideal_memory_list)/sizeof(char*);
3513   if( strcmp(_opType,&quot;PrefetchAllocation&quot;)==0 )
3514     return 1;
<a name="13" id="anc13"></a>





3515   if( _lChild ) {
3516     const char *opType = _lChild-&gt;_opType;
3517     for( int i=0; i&lt;cnt; i++ )
3518       if( strcmp(opType,needs_ideal_memory_list[i]) == 0 )
3519         return 1;
3520     if( _lChild-&gt;needs_ideal_memory_edge(globals) )
3521       return 1;
3522   }
3523   if( _rChild ) {
3524     const char *opType = _rChild-&gt;_opType;
3525     for( int i=0; i&lt;cnt; i++ )
3526       if( strcmp(opType,needs_ideal_memory_list[i]) == 0 )
3527         return 1;
3528     if( _rChild-&gt;needs_ideal_memory_edge(globals) )
3529       return 1;
3530   }
3531 
3532   return 0;
3533 }
3534 
3535 // TRUE if defines a derived oop, and so needs a base oop edge present
3536 // post-matching.
3537 int MatchNode::needs_base_oop_edge() const {
3538   if( !strcmp(_opType,&quot;AddP&quot;) ) return 1;
3539   if( strcmp(_opType,&quot;Set&quot;) ) return 0;
3540   return !strcmp(_rChild-&gt;_opType,&quot;AddP&quot;);
3541 }
3542 
3543 int InstructForm::needs_base_oop_edge(FormDict &amp;globals) const {
3544   if( is_simple_chain_rule(globals) ) {
3545     const char *src = _matrule-&gt;_rChild-&gt;_opType;
3546     OperandForm *src_op = globals[src]-&gt;is_operand();
3547     assert( src_op, &quot;Not operand class of chain rule&quot; );
3548     return src_op-&gt;_matrule ? src_op-&gt;_matrule-&gt;needs_base_oop_edge() : 0;
3549   }                             // Else check instruction
3550 
3551   return _matrule ? _matrule-&gt;needs_base_oop_edge() : 0;
3552 }
3553 
3554 
3555 //-------------------------cisc spilling methods-------------------------------
3556 // helper routines and methods for detecting cisc-spilling instructions
3557 //-------------------------cisc_spill_merge------------------------------------
3558 int MatchNode::cisc_spill_merge(int left_spillable, int right_spillable) {
3559   int cisc_spillable  = Maybe_cisc_spillable;
3560 
3561   // Combine results of left and right checks
3562   if( (left_spillable == Maybe_cisc_spillable) &amp;&amp; (right_spillable == Maybe_cisc_spillable) ) {
3563     // neither side is spillable, nor prevents cisc spilling
3564     cisc_spillable = Maybe_cisc_spillable;
3565   }
3566   else if( (left_spillable == Maybe_cisc_spillable) &amp;&amp; (right_spillable &gt; Maybe_cisc_spillable) ) {
3567     // right side is spillable
3568     cisc_spillable = right_spillable;
3569   }
3570   else if( (right_spillable == Maybe_cisc_spillable) &amp;&amp; (left_spillable &gt; Maybe_cisc_spillable) ) {
3571     // left side is spillable
3572     cisc_spillable = left_spillable;
3573   }
3574   else if( (left_spillable == Not_cisc_spillable) || (right_spillable == Not_cisc_spillable) ) {
3575     // left or right prevents cisc spilling this instruction
3576     cisc_spillable = Not_cisc_spillable;
3577   }
3578   else {
3579     // Only allow one to spill
3580     cisc_spillable = Not_cisc_spillable;
3581   }
3582 
3583   return cisc_spillable;
3584 }
3585 
3586 //-------------------------root_ops_match--------------------------------------
3587 bool static root_ops_match(FormDict &amp;globals, const char *op1, const char *op2) {
3588   // Base Case: check that the current operands/operations match
3589   assert( op1, &quot;Must have op&#39;s name&quot;);
3590   assert( op2, &quot;Must have op&#39;s name&quot;);
3591   const Form *form1 = globals[op1];
3592   const Form *form2 = globals[op2];
3593 
3594   return (form1 == form2);
3595 }
3596 
3597 //-------------------------cisc_spill_match_node-------------------------------
3598 // Recursively check two MatchRules for legal conversion via cisc-spilling
3599 int MatchNode::cisc_spill_match(FormDict&amp; globals, RegisterForm* registers, MatchNode* mRule2, const char* &amp;operand, const char* &amp;reg_type) {
3600   int cisc_spillable  = Maybe_cisc_spillable;
3601   int left_spillable  = Maybe_cisc_spillable;
3602   int right_spillable = Maybe_cisc_spillable;
3603 
3604   // Check that each has same number of operands at this level
3605   if( (_lChild &amp;&amp; !(mRule2-&gt;_lChild)) || (_rChild &amp;&amp; !(mRule2-&gt;_rChild)) )
3606     return Not_cisc_spillable;
3607 
3608   // Base Case: check that the current operands/operations match
3609   // or are CISC spillable
3610   assert( _opType, &quot;Must have _opType&quot;);
3611   assert( mRule2-&gt;_opType, &quot;Must have _opType&quot;);
3612   const Form *form  = globals[_opType];
3613   const Form *form2 = globals[mRule2-&gt;_opType];
3614   if( form == form2 ) {
3615     cisc_spillable = Maybe_cisc_spillable;
3616   } else {
3617     const InstructForm *form2_inst = form2 ? form2-&gt;is_instruction() : NULL;
3618     const char *name_left  = mRule2-&gt;_lChild ? mRule2-&gt;_lChild-&gt;_opType : NULL;
3619     const char *name_right = mRule2-&gt;_rChild ? mRule2-&gt;_rChild-&gt;_opType : NULL;
3620     DataType data_type = Form::none;
3621     if (form-&gt;is_operand()) {
3622       // Make sure the loadX matches the type of the reg
3623       data_type = form-&gt;ideal_to_Reg_type(form-&gt;is_operand()-&gt;ideal_type(globals));
3624     }
3625     // Detect reg vs (loadX memory)
3626     if( form-&gt;is_cisc_reg(globals)
3627         &amp;&amp; form2_inst
3628         &amp;&amp; data_type != Form::none
3629         &amp;&amp; (is_load_from_memory(mRule2-&gt;_opType) == data_type) // reg vs. (load memory)
3630         &amp;&amp; (name_left != NULL)       // NOT (load)
3631         &amp;&amp; (name_right == NULL) ) {  // NOT (load memory foo)
3632       const Form *form2_left = globals[name_left];
3633       if( form2_left &amp;&amp; form2_left-&gt;is_cisc_mem(globals) ) {
3634         cisc_spillable = Is_cisc_spillable;
3635         operand        = _name;
3636         reg_type       = _result;
3637         return Is_cisc_spillable;
3638       } else {
3639         cisc_spillable = Not_cisc_spillable;
3640       }
3641     }
3642     // Detect reg vs memory
3643     else if (form-&gt;is_cisc_reg(globals) &amp;&amp; form2 != NULL &amp;&amp; form2-&gt;is_cisc_mem(globals)) {
3644       cisc_spillable = Is_cisc_spillable;
3645       operand        = _name;
3646       reg_type       = _result;
3647       return Is_cisc_spillable;
3648     } else {
3649       cisc_spillable = Not_cisc_spillable;
3650     }
3651   }
3652 
3653   // If cisc is still possible, check rest of tree
3654   if( cisc_spillable == Maybe_cisc_spillable ) {
3655     // Check that each has same number of operands at this level
3656     if( (_lChild &amp;&amp; !(mRule2-&gt;_lChild)) || (_rChild &amp;&amp; !(mRule2-&gt;_rChild)) ) return Not_cisc_spillable;
3657 
3658     // Check left operands
3659     if( (_lChild == NULL) &amp;&amp; (mRule2-&gt;_lChild == NULL) ) {
3660       left_spillable = Maybe_cisc_spillable;
3661     } else  if (_lChild != NULL) {
3662       left_spillable = _lChild-&gt;cisc_spill_match(globals, registers, mRule2-&gt;_lChild, operand, reg_type);
3663     }
3664 
3665     // Check right operands
3666     if( (_rChild == NULL) &amp;&amp; (mRule2-&gt;_rChild == NULL) ) {
3667       right_spillable =  Maybe_cisc_spillable;
3668     } else if (_rChild != NULL) {
3669       right_spillable = _rChild-&gt;cisc_spill_match(globals, registers, mRule2-&gt;_rChild, operand, reg_type);
3670     }
3671 
3672     // Combine results of left and right checks
3673     cisc_spillable = cisc_spill_merge(left_spillable, right_spillable);
3674   }
3675 
3676   return cisc_spillable;
3677 }
3678 
3679 //---------------------------cisc_spill_match_rule------------------------------
3680 // Recursively check two MatchRules for legal conversion via cisc-spilling
3681 // This method handles the root of Match tree,
3682 // general recursive checks done in MatchNode
3683 int  MatchRule::matchrule_cisc_spill_match(FormDict&amp; globals, RegisterForm* registers,
3684                                            MatchRule* mRule2, const char* &amp;operand,
3685                                            const char* &amp;reg_type) {
3686   int cisc_spillable  = Maybe_cisc_spillable;
3687   int left_spillable  = Maybe_cisc_spillable;
3688   int right_spillable = Maybe_cisc_spillable;
3689 
3690   // Check that each sets a result
3691   if( !(sets_result() &amp;&amp; mRule2-&gt;sets_result()) ) return Not_cisc_spillable;
3692   // Check that each has same number of operands at this level
3693   if( (_lChild &amp;&amp; !(mRule2-&gt;_lChild)) || (_rChild &amp;&amp; !(mRule2-&gt;_rChild)) ) return Not_cisc_spillable;
3694 
3695   // Check left operands: at root, must be target of &#39;Set&#39;
3696   if( (_lChild == NULL) || (mRule2-&gt;_lChild == NULL) ) {
3697     left_spillable = Not_cisc_spillable;
3698   } else {
3699     // Do not support cisc-spilling instruction&#39;s target location
3700     if( root_ops_match(globals, _lChild-&gt;_opType, mRule2-&gt;_lChild-&gt;_opType) ) {
3701       left_spillable = Maybe_cisc_spillable;
3702     } else {
3703       left_spillable = Not_cisc_spillable;
3704     }
3705   }
3706 
3707   // Check right operands: recursive walk to identify reg-&gt;mem operand
3708   if (_rChild == NULL) {
3709     if (mRule2-&gt;_rChild == NULL) {
3710       right_spillable =  Maybe_cisc_spillable;
3711     } else {
3712       assert(0, &quot;_rChild should not be NULL&quot;);
3713     }
3714   } else {
3715     right_spillable = _rChild-&gt;cisc_spill_match(globals, registers, mRule2-&gt;_rChild, operand, reg_type);
3716   }
3717 
3718   // Combine results of left and right checks
3719   cisc_spillable = cisc_spill_merge(left_spillable, right_spillable);
3720 
3721   return cisc_spillable;
3722 }
3723 
3724 //----------------------------- equivalent ------------------------------------
3725 // Recursively check to see if two match rules are equivalent.
3726 // This rule handles the root.
3727 bool MatchRule::equivalent(FormDict &amp;globals, MatchNode *mRule2) {
3728   // Check that each sets a result
3729   if (sets_result() != mRule2-&gt;sets_result()) {
3730     return false;
3731   }
3732 
3733   // Check that the current operands/operations match
3734   assert( _opType, &quot;Must have _opType&quot;);
3735   assert( mRule2-&gt;_opType, &quot;Must have _opType&quot;);
3736   const Form *form  = globals[_opType];
3737   const Form *form2 = globals[mRule2-&gt;_opType];
3738   if( form != form2 ) {
3739     return false;
3740   }
3741 
3742   if (_lChild ) {
3743     if( !_lChild-&gt;equivalent(globals, mRule2-&gt;_lChild) )
3744       return false;
3745   } else if (mRule2-&gt;_lChild) {
3746     return false; // I have NULL left child, mRule2 has non-NULL left child.
3747   }
3748 
3749   if (_rChild ) {
3750     if( !_rChild-&gt;equivalent(globals, mRule2-&gt;_rChild) )
3751       return false;
3752   } else if (mRule2-&gt;_rChild) {
3753     return false; // I have NULL right child, mRule2 has non-NULL right child.
3754   }
3755 
3756   // We&#39;ve made it through the gauntlet.
3757   return true;
3758 }
3759 
3760 //----------------------------- equivalent ------------------------------------
3761 // Recursively check to see if two match rules are equivalent.
3762 // This rule handles the operands.
3763 bool MatchNode::equivalent(FormDict &amp;globals, MatchNode *mNode2) {
3764   if( !mNode2 )
3765     return false;
3766 
3767   // Check that the current operands/operations match
3768   assert( _opType, &quot;Must have _opType&quot;);
3769   assert( mNode2-&gt;_opType, &quot;Must have _opType&quot;);
3770   const Form *form  = globals[_opType];
3771   const Form *form2 = globals[mNode2-&gt;_opType];
3772   if( form != form2 ) {
3773     return false;
3774   }
3775 
3776   // Check that their children also match
3777   if (_lChild ) {
3778     if( !_lChild-&gt;equivalent(globals, mNode2-&gt;_lChild) )
3779       return false;
3780   } else if (mNode2-&gt;_lChild) {
3781     return false; // I have NULL left child, mNode2 has non-NULL left child.
3782   }
3783 
3784   if (_rChild ) {
3785     if( !_rChild-&gt;equivalent(globals, mNode2-&gt;_rChild) )
3786       return false;
3787   } else if (mNode2-&gt;_rChild) {
3788     return false; // I have NULL right child, mNode2 has non-NULL right child.
3789   }
3790 
3791   // We&#39;ve made it through the gauntlet.
3792   return true;
3793 }
3794 
3795 //-------------------------- has_commutative_op -------------------------------
3796 // Recursively check for commutative operations with subtree operands
3797 // which could be swapped.
3798 void MatchNode::count_commutative_op(int&amp; count) {
3799   static const char *commut_op_list[] = {
3800     &quot;AddI&quot;,&quot;AddL&quot;,&quot;AddF&quot;,&quot;AddD&quot;,
3801     &quot;AddVB&quot;,&quot;AddVS&quot;,&quot;AddVI&quot;,&quot;AddVL&quot;,&quot;AddVF&quot;,&quot;AddVD&quot;,
3802     &quot;AndI&quot;,&quot;AndL&quot;,
3803     &quot;AndV&quot;,
3804     &quot;MaxI&quot;,&quot;MinI&quot;,&quot;MaxF&quot;,&quot;MinF&quot;,&quot;MaxD&quot;,&quot;MinD&quot;,
3805     &quot;MaxV&quot;, &quot;MinV&quot;,
3806     &quot;MulI&quot;,&quot;MulL&quot;,&quot;MulF&quot;,&quot;MulD&quot;,
<a name="14" id="anc14"></a><span class="line-modified">3807     &quot;MulVS&quot;,&quot;MulVI&quot;,&quot;MulVL&quot;,&quot;MulVF&quot;,&quot;MulVD&quot;,</span>
3808     &quot;OrI&quot;,&quot;OrL&quot;,
3809     &quot;OrV&quot;,
3810     &quot;XorI&quot;,&quot;XorL&quot;,
3811     &quot;XorV&quot;
3812   };
3813   int cnt = sizeof(commut_op_list)/sizeof(char*);
3814 
3815   if( _lChild &amp;&amp; _rChild &amp;&amp; (_lChild-&gt;_lChild || _rChild-&gt;_lChild) ) {
3816     // Don&#39;t swap if right operand is an immediate constant.
3817     bool is_const = false;
3818     if( _rChild-&gt;_lChild == NULL &amp;&amp; _rChild-&gt;_rChild == NULL ) {
3819       FormDict &amp;globals = _AD.globalNames();
3820       const Form *form = globals[_rChild-&gt;_opType];
3821       if ( form ) {
3822         OperandForm  *oper = form-&gt;is_operand();
3823         if( oper &amp;&amp; oper-&gt;interface_type(globals) == Form::constant_interface )
3824           is_const = true;
3825       }
3826     }
3827     if( !is_const ) {
3828       for( int i=0; i&lt;cnt; i++ ) {
3829         if( strcmp(_opType, commut_op_list[i]) == 0 ) {
3830           count++;
3831           _commutative_id = count; // id should be &gt; 0
3832           break;
3833         }
3834       }
3835     }
3836   }
3837   if( _lChild )
3838     _lChild-&gt;count_commutative_op(count);
3839   if( _rChild )
3840     _rChild-&gt;count_commutative_op(count);
3841 }
3842 
3843 //-------------------------- swap_commutative_op ------------------------------
3844 // Recursively swap specified commutative operation with subtree operands.
3845 void MatchNode::swap_commutative_op(bool atroot, int id) {
3846   if( _commutative_id == id ) { // id should be &gt; 0
3847     assert(_lChild &amp;&amp; _rChild &amp;&amp; (_lChild-&gt;_lChild || _rChild-&gt;_lChild ),
3848             &quot;not swappable operation&quot;);
3849     MatchNode* tmp = _lChild;
3850     _lChild = _rChild;
3851     _rChild = tmp;
3852     // Don&#39;t exit here since we need to build internalop.
3853   }
3854 
3855   bool is_set = ( strcmp(_opType, &quot;Set&quot;) == 0 );
3856   if( _lChild )
3857     _lChild-&gt;swap_commutative_op(is_set, id);
3858   if( _rChild )
3859     _rChild-&gt;swap_commutative_op(is_set, id);
3860 
3861   // If not the root, reduce this subtree to an internal operand
3862   if( !atroot &amp;&amp; (_lChild || _rChild) ) {
3863     build_internalop();
3864   }
3865 }
3866 
3867 //-------------------------- swap_commutative_op ------------------------------
3868 // Recursively swap specified commutative operation with subtree operands.
3869 void MatchRule::matchrule_swap_commutative_op(const char* instr_ident, int count, int&amp; match_rules_cnt) {
3870   assert(match_rules_cnt &lt; 100,&quot; too many match rule clones&quot;);
3871   // Clone
3872   MatchRule* clone = new MatchRule(_AD, this);
3873   // Swap operands of commutative operation
3874   ((MatchNode*)clone)-&gt;swap_commutative_op(true, count);
3875   char* buf = (char*) AllocateHeap(strlen(instr_ident) + 4);
3876   sprintf(buf, &quot;%s_%d&quot;, instr_ident, match_rules_cnt++);
3877   clone-&gt;_result = buf;
3878 
3879   clone-&gt;_next = this-&gt;_next;
3880   this-&gt; _next = clone;
3881   if( (--count) &gt; 0 ) {
3882     this-&gt; matchrule_swap_commutative_op(instr_ident, count, match_rules_cnt);
3883     clone-&gt;matchrule_swap_commutative_op(instr_ident, count, match_rules_cnt);
3884   }
3885 }
3886 
3887 //------------------------------MatchRule--------------------------------------
3888 MatchRule::MatchRule(ArchDesc &amp;ad)
3889   : MatchNode(ad), _depth(0), _construct(NULL), _numchilds(0) {
3890     _next = NULL;
3891 }
3892 
3893 MatchRule::MatchRule(ArchDesc &amp;ad, MatchRule* mRule)
3894   : MatchNode(ad, *mRule, 0), _depth(mRule-&gt;_depth),
3895     _construct(mRule-&gt;_construct), _numchilds(mRule-&gt;_numchilds) {
3896     _next = NULL;
3897 }
3898 
3899 MatchRule::MatchRule(ArchDesc &amp;ad, MatchNode* mroot, int depth, char *cnstr,
3900                      int numleaves)
3901   : MatchNode(ad,*mroot), _depth(depth), _construct(cnstr),
3902     _numchilds(0) {
3903       _next = NULL;
3904       mroot-&gt;_lChild = NULL;
3905       mroot-&gt;_rChild = NULL;
3906       delete mroot;
3907       _numleaves = numleaves;
3908       _numchilds = (_lChild ? 1 : 0) + (_rChild ? 1 : 0);
3909 }
3910 MatchRule::~MatchRule() {
3911 }
3912 
3913 // Recursive call collecting info on top-level operands, not transitive.
3914 // Implementation does not modify state of internal structures.
3915 void MatchRule::append_components(FormDict&amp; locals, ComponentList&amp; components, bool def_flag) const {
3916   assert (_name != NULL, &quot;MatchNode::build_components encountered empty node\n&quot;);
3917 
3918   MatchNode::append_components(locals, components,
3919                                false /* not necessarily a def */);
3920 }
3921 
3922 // Recursive call on all operands&#39; match rules in my match rule.
3923 // Implementation does not modify state of internal structures  since they
3924 // can be shared.
3925 // The MatchNode that is called first treats its
3926 bool MatchRule::base_operand(uint &amp;position0, FormDict &amp;globals,
3927                              const char *&amp;result, const char * &amp;name,
3928                              const char * &amp;opType)const{
3929   uint position = position0;
3930 
3931   return (MatchNode::base_operand( position, globals, result, name, opType));
3932 }
3933 
3934 
3935 bool MatchRule::is_base_register(FormDict &amp;globals) const {
3936   uint   position = 1;
3937   const char  *result   = NULL;
3938   const char  *name     = NULL;
3939   const char  *opType   = NULL;
3940   if (!base_operand(position, globals, result, name, opType)) {
3941     position = 0;
3942     if( base_operand(position, globals, result, name, opType) &amp;&amp;
3943         (strcmp(opType,&quot;RegI&quot;)==0 ||
3944          strcmp(opType,&quot;RegP&quot;)==0 ||
3945          strcmp(opType,&quot;RegN&quot;)==0 ||
3946          strcmp(opType,&quot;RegL&quot;)==0 ||
3947          strcmp(opType,&quot;RegF&quot;)==0 ||
3948          strcmp(opType,&quot;RegD&quot;)==0 ||
3949          strcmp(opType,&quot;VecS&quot;)==0 ||
3950          strcmp(opType,&quot;VecD&quot;)==0 ||
3951          strcmp(opType,&quot;VecX&quot;)==0 ||
3952          strcmp(opType,&quot;VecY&quot;)==0 ||
3953          strcmp(opType,&quot;VecZ&quot;)==0 ||
3954          strcmp(opType,&quot;Reg&quot; )==0) ) {
3955       return 1;
3956     }
3957   }
3958   return 0;
3959 }
3960 
3961 Form::DataType MatchRule::is_base_constant(FormDict &amp;globals) const {
3962   uint         position = 1;
3963   const char  *result   = NULL;
3964   const char  *name     = NULL;
3965   const char  *opType   = NULL;
3966   if (!base_operand(position, globals, result, name, opType)) {
3967     position = 0;
3968     if (base_operand(position, globals, result, name, opType)) {
3969       return ideal_to_const_type(opType);
3970     }
3971   }
3972   return Form::none;
3973 }
3974 
3975 bool MatchRule::is_chain_rule(FormDict &amp;globals) const {
3976 
3977   // Check for chain rule, and do not generate a match list for it
3978   if ((_lChild == NULL) &amp;&amp; (_rChild == NULL) ) {
3979     const Form *form = globals[_opType];
3980     // If this is ideal, then it is a base match, not a chain rule.
3981     if ( form &amp;&amp; form-&gt;is_operand() &amp;&amp; (!form-&gt;ideal_only())) {
3982       return true;
3983     }
3984   }
3985   // Check for &quot;Set&quot; form of chain rule, and do not generate a match list
3986   if (_rChild) {
3987     const char *rch = _rChild-&gt;_opType;
3988     const Form *form = globals[rch];
3989     if ((!strcmp(_opType,&quot;Set&quot;) &amp;&amp;
3990          ((form) &amp;&amp; form-&gt;is_operand()))) {
3991       return true;
3992     }
3993   }
3994   return false;
3995 }
3996 
3997 int MatchRule::is_ideal_copy() const {
<a name="15" id="anc15"></a><span class="line-modified">3998   if( _rChild ) {</span>
<span class="line-modified">3999     const char  *opType = _rChild-&gt;_opType;</span>
<span class="line-removed">4000 #if 1</span>
<span class="line-removed">4001     if( strcmp(opType,&quot;CastIP&quot;)==0 )</span>
<span class="line-removed">4002       return 1;</span>
<span class="line-removed">4003 #else</span>
<span class="line-removed">4004     if( strcmp(opType,&quot;CastII&quot;)==0 )</span>
<span class="line-removed">4005       return 1;</span>
<span class="line-removed">4006     // Do not treat *CastPP this way, because it</span>
<span class="line-removed">4007     // may transfer a raw pointer to an oop.</span>
<span class="line-removed">4008     // If the register allocator were to coalesce this</span>
<span class="line-removed">4009     // into a single LRG, the GC maps would be incorrect.</span>
<span class="line-removed">4010     //if( strcmp(opType,&quot;CastPP&quot;)==0 )</span>
<span class="line-removed">4011     //  return 1;</span>
<span class="line-removed">4012     //if( strcmp(opType,&quot;CheckCastPP&quot;)==0 )</span>
<span class="line-removed">4013     //  return 1;</span>
<span class="line-removed">4014     //</span>
<span class="line-removed">4015     // Do not treat CastX2P or CastP2X this way, because</span>
<span class="line-removed">4016     // raw pointers and int types are treated differently</span>
<span class="line-removed">4017     // when saving local &amp; stack info for safepoints in</span>
<span class="line-removed">4018     // Output().</span>
<span class="line-removed">4019     //if( strcmp(opType,&quot;CastX2P&quot;)==0 )</span>
<span class="line-removed">4020     //  return 1;</span>
<span class="line-removed">4021     //if( strcmp(opType,&quot;CastP2X&quot;)==0 )</span>
<span class="line-removed">4022     //  return 1;</span>
<span class="line-removed">4023 #endif</span>
<span class="line-removed">4024   }</span>
<span class="line-removed">4025   if( is_chain_rule(_AD.globalNames()) &amp;&amp;</span>
<span class="line-removed">4026       _lChild &amp;&amp; strncmp(_lChild-&gt;_opType,&quot;stackSlot&quot;,9)==0 )</span>
4027     return 1;
<a name="16" id="anc16"></a>
4028   return 0;
4029 }
4030 
<a name="17" id="anc17"></a><span class="line-removed">4031 </span>
4032 int MatchRule::is_expensive() const {
4033   if( _rChild ) {
4034     const char  *opType = _rChild-&gt;_opType;
4035     if( strcmp(opType,&quot;AtanD&quot;)==0 ||
4036         strcmp(opType,&quot;DivD&quot;)==0 ||
4037         strcmp(opType,&quot;DivF&quot;)==0 ||
4038         strcmp(opType,&quot;DivI&quot;)==0 ||
4039         strcmp(opType,&quot;Log10D&quot;)==0 ||
4040         strcmp(opType,&quot;ModD&quot;)==0 ||
4041         strcmp(opType,&quot;ModF&quot;)==0 ||
4042         strcmp(opType,&quot;ModI&quot;)==0 ||
4043         strcmp(opType,&quot;SqrtD&quot;)==0 ||
4044         strcmp(opType,&quot;SqrtF&quot;)==0 ||
4045         strcmp(opType,&quot;TanD&quot;)==0 ||
4046         strcmp(opType,&quot;ConvD2F&quot;)==0 ||
4047         strcmp(opType,&quot;ConvD2I&quot;)==0 ||
4048         strcmp(opType,&quot;ConvD2L&quot;)==0 ||
4049         strcmp(opType,&quot;ConvF2D&quot;)==0 ||
4050         strcmp(opType,&quot;ConvF2I&quot;)==0 ||
4051         strcmp(opType,&quot;ConvF2L&quot;)==0 ||
4052         strcmp(opType,&quot;ConvI2D&quot;)==0 ||
4053         strcmp(opType,&quot;ConvI2F&quot;)==0 ||
4054         strcmp(opType,&quot;ConvI2L&quot;)==0 ||
4055         strcmp(opType,&quot;ConvL2D&quot;)==0 ||
4056         strcmp(opType,&quot;ConvL2F&quot;)==0 ||
4057         strcmp(opType,&quot;ConvL2I&quot;)==0 ||
4058         strcmp(opType,&quot;DecodeN&quot;)==0 ||
4059         strcmp(opType,&quot;EncodeP&quot;)==0 ||
4060         strcmp(opType,&quot;EncodePKlass&quot;)==0 ||
4061         strcmp(opType,&quot;DecodeNKlass&quot;)==0 ||
4062         strcmp(opType,&quot;FmaD&quot;) == 0 ||
4063         strcmp(opType,&quot;FmaF&quot;) == 0 ||
4064         strcmp(opType,&quot;RoundDouble&quot;)==0 ||
<a name="18" id="anc18"></a>
4065         strcmp(opType,&quot;RoundFloat&quot;)==0 ||
4066         strcmp(opType,&quot;ReverseBytesI&quot;)==0 ||
4067         strcmp(opType,&quot;ReverseBytesL&quot;)==0 ||
4068         strcmp(opType,&quot;ReverseBytesUS&quot;)==0 ||
4069         strcmp(opType,&quot;ReverseBytesS&quot;)==0 ||
4070         strcmp(opType,&quot;ReplicateB&quot;)==0 ||
4071         strcmp(opType,&quot;ReplicateS&quot;)==0 ||
4072         strcmp(opType,&quot;ReplicateI&quot;)==0 ||
4073         strcmp(opType,&quot;ReplicateL&quot;)==0 ||
4074         strcmp(opType,&quot;ReplicateF&quot;)==0 ||
4075         strcmp(opType,&quot;ReplicateD&quot;)==0 ||
4076         strcmp(opType,&quot;AddReductionVI&quot;)==0 ||
4077         strcmp(opType,&quot;AddReductionVL&quot;)==0 ||
4078         strcmp(opType,&quot;AddReductionVF&quot;)==0 ||
4079         strcmp(opType,&quot;AddReductionVD&quot;)==0 ||
4080         strcmp(opType,&quot;MulReductionVI&quot;)==0 ||
4081         strcmp(opType,&quot;MulReductionVL&quot;)==0 ||
4082         strcmp(opType,&quot;MulReductionVF&quot;)==0 ||
4083         strcmp(opType,&quot;MulReductionVD&quot;)==0 ||
4084         0 /* 0 to line up columns nicely */ )
4085       return 1;
4086   }
4087   return 0;
4088 }
4089 
4090 bool MatchRule::is_ideal_if() const {
4091   if( !_opType ) return false;
4092   return
4093     !strcmp(_opType,&quot;If&quot;            ) ||
4094     !strcmp(_opType,&quot;CountedLoopEnd&quot;);
4095 }
4096 
4097 bool MatchRule::is_ideal_fastlock() const {
4098   if ( _opType &amp;&amp; (strcmp(_opType,&quot;Set&quot;) == 0) &amp;&amp; _rChild ) {
4099     return (strcmp(_rChild-&gt;_opType,&quot;FastLock&quot;) == 0);
4100   }
4101   return false;
4102 }
4103 
4104 bool MatchRule::is_ideal_membar() const {
4105   if( !_opType ) return false;
4106   return
4107     !strcmp(_opType,&quot;MemBarAcquire&quot;) ||
4108     !strcmp(_opType,&quot;MemBarRelease&quot;) ||
4109     !strcmp(_opType,&quot;MemBarAcquireLock&quot;) ||
4110     !strcmp(_opType,&quot;MemBarReleaseLock&quot;) ||
4111     !strcmp(_opType,&quot;LoadFence&quot; ) ||
4112     !strcmp(_opType,&quot;StoreFence&quot;) ||
4113     !strcmp(_opType,&quot;MemBarVolatile&quot;) ||
4114     !strcmp(_opType,&quot;MemBarCPUOrder&quot;) ||
4115     !strcmp(_opType,&quot;MemBarStoreStore&quot;) ||
4116     !strcmp(_opType,&quot;OnSpinWait&quot;);
4117 }
4118 
4119 bool MatchRule::is_ideal_loadPC() const {
4120   if ( _opType &amp;&amp; (strcmp(_opType,&quot;Set&quot;) == 0) &amp;&amp; _rChild ) {
4121     return (strcmp(_rChild-&gt;_opType,&quot;LoadPC&quot;) == 0);
4122   }
4123   return false;
4124 }
4125 
4126 bool MatchRule::is_ideal_box() const {
4127   if ( _opType &amp;&amp; (strcmp(_opType,&quot;Set&quot;) == 0) &amp;&amp; _rChild ) {
4128     return (strcmp(_rChild-&gt;_opType,&quot;Box&quot;) == 0);
4129   }
4130   return false;
4131 }
4132 
4133 bool MatchRule::is_ideal_goto() const {
4134   bool   ideal_goto = false;
4135 
4136   if( _opType &amp;&amp; (strcmp(_opType,&quot;Goto&quot;) == 0) ) {
4137     ideal_goto = true;
4138   }
4139   return ideal_goto;
4140 }
4141 
4142 bool MatchRule::is_ideal_jump() const {
4143   if( _opType ) {
4144     if( !strcmp(_opType,&quot;Jump&quot;) )
4145       return true;
4146   }
4147   return false;
4148 }
4149 
4150 bool MatchRule::is_ideal_bool() const {
4151   if( _opType ) {
4152     if( !strcmp(_opType,&quot;Bool&quot;) )
4153       return true;
4154   }
4155   return false;
4156 }
4157 
4158 
4159 Form::DataType MatchRule::is_ideal_load() const {
4160   Form::DataType ideal_load = Form::none;
4161 
4162   if ( _opType &amp;&amp; (strcmp(_opType,&quot;Set&quot;) == 0) &amp;&amp; _rChild ) {
4163     const char *opType = _rChild-&gt;_opType;
4164     ideal_load = is_load_from_memory(opType);
4165   }
4166 
4167   return ideal_load;
4168 }
4169 
4170 bool MatchRule::is_vector() const {
4171   static const char *vector_list[] = {
4172     &quot;AddVB&quot;,&quot;AddVS&quot;,&quot;AddVI&quot;,&quot;AddVL&quot;,&quot;AddVF&quot;,&quot;AddVD&quot;,
4173     &quot;SubVB&quot;,&quot;SubVS&quot;,&quot;SubVI&quot;,&quot;SubVL&quot;,&quot;SubVF&quot;,&quot;SubVD&quot;,
<a name="19" id="anc19"></a><span class="line-modified">4174     &quot;MulVS&quot;,&quot;MulVI&quot;,&quot;MulVL&quot;,&quot;MulVF&quot;,&quot;MulVD&quot;,</span>
4175     &quot;CMoveVD&quot;, &quot;CMoveVF&quot;,
4176     &quot;DivVF&quot;,&quot;DivVD&quot;,
<a name="20" id="anc20"></a><span class="line-modified">4177     &quot;AbsVF&quot;,&quot;AbsVD&quot;,</span>
4178     &quot;NegVF&quot;,&quot;NegVD&quot;,
4179     &quot;SqrtVD&quot;,&quot;SqrtVF&quot;,
4180     &quot;AndV&quot; ,&quot;XorV&quot; ,&quot;OrV&quot;,
4181     &quot;MaxV&quot;, &quot;MinV&quot;,
4182     &quot;AddReductionVI&quot;, &quot;AddReductionVL&quot;,
4183     &quot;AddReductionVF&quot;, &quot;AddReductionVD&quot;,
4184     &quot;MulReductionVI&quot;, &quot;MulReductionVL&quot;,
4185     &quot;MulReductionVF&quot;, &quot;MulReductionVD&quot;,
4186     &quot;MulAddVS2VI&quot;,
4187     &quot;LShiftCntV&quot;,&quot;RShiftCntV&quot;,
4188     &quot;LShiftVB&quot;,&quot;LShiftVS&quot;,&quot;LShiftVI&quot;,&quot;LShiftVL&quot;,
4189     &quot;RShiftVB&quot;,&quot;RShiftVS&quot;,&quot;RShiftVI&quot;,&quot;RShiftVL&quot;,
4190     &quot;URShiftVB&quot;,&quot;URShiftVS&quot;,&quot;URShiftVI&quot;,&quot;URShiftVL&quot;,
4191     &quot;MaxReductionV&quot;, &quot;MinReductionV&quot;,
4192     &quot;ReplicateB&quot;,&quot;ReplicateS&quot;,&quot;ReplicateI&quot;,&quot;ReplicateL&quot;,&quot;ReplicateF&quot;,&quot;ReplicateD&quot;,
<a name="21" id="anc21"></a><span class="line-modified">4193     &quot;LoadVector&quot;,&quot;StoreVector&quot;,</span>
4194     &quot;FmaVD&quot;, &quot;FmaVF&quot;,&quot;PopCountVI&quot;,
4195     // Next are not supported currently.
4196     &quot;PackB&quot;,&quot;PackS&quot;,&quot;PackI&quot;,&quot;PackL&quot;,&quot;PackF&quot;,&quot;PackD&quot;,&quot;Pack2L&quot;,&quot;Pack2D&quot;,
4197     &quot;ExtractB&quot;,&quot;ExtractUB&quot;,&quot;ExtractC&quot;,&quot;ExtractS&quot;,&quot;ExtractI&quot;,&quot;ExtractL&quot;,&quot;ExtractF&quot;,&quot;ExtractD&quot;
4198   };
4199   int cnt = sizeof(vector_list)/sizeof(char*);
4200   if (_rChild) {
4201     const char  *opType = _rChild-&gt;_opType;
4202     for (int i=0; i&lt;cnt; i++)
4203       if (strcmp(opType,vector_list[i]) == 0)
4204         return true;
4205   }
4206   return false;
4207 }
4208 
4209 
4210 bool MatchRule::skip_antidep_check() const {
4211   // Some loads operate on what is effectively immutable memory so we
4212   // should skip the anti dep computations.  For some of these nodes
4213   // the rewritable field keeps the anti dep logic from triggering but
4214   // for certain kinds of LoadKlass it does not since they are
4215   // actually reading memory which could be rewritten by the runtime,
4216   // though never by generated code.  This disables it uniformly for
4217   // the nodes that behave like this: LoadKlass, LoadNKlass and
4218   // LoadRange.
4219   if ( _opType &amp;&amp; (strcmp(_opType,&quot;Set&quot;) == 0) &amp;&amp; _rChild ) {
4220     const char *opType = _rChild-&gt;_opType;
4221     if (strcmp(&quot;LoadKlass&quot;, opType) == 0 ||
4222         strcmp(&quot;LoadNKlass&quot;, opType) == 0 ||
4223         strcmp(&quot;LoadRange&quot;, opType) == 0) {
4224       return true;
4225     }
4226   }
4227 
4228   return false;
4229 }
4230 
4231 
4232 Form::DataType MatchRule::is_ideal_store() const {
4233   Form::DataType ideal_store = Form::none;
4234 
4235   if ( _opType &amp;&amp; (strcmp(_opType,&quot;Set&quot;) == 0) &amp;&amp; _rChild ) {
4236     const char *opType = _rChild-&gt;_opType;
4237     ideal_store = is_store_to_memory(opType);
4238   }
4239 
4240   return ideal_store;
4241 }
4242 
4243 
4244 void MatchRule::dump() {
4245   output(stderr);
4246 }
4247 
4248 // Write just one line.
4249 void MatchRule::output_short(FILE *fp) {
4250   fprintf(fp,&quot;MatchRule: ( %s&quot;,_name);
4251   if (_lChild) _lChild-&gt;output(fp);
4252   if (_rChild) _rChild-&gt;output(fp);
4253   fprintf(fp,&quot; )&quot;);
4254 }
4255 
4256 void MatchRule::output(FILE *fp) {
4257   output_short(fp);
4258   fprintf(fp,&quot;\n   nesting depth = %d\n&quot;, _depth);
4259   if (_result) fprintf(fp,&quot;   Result Type = %s&quot;, _result);
4260   fprintf(fp,&quot;\n&quot;);
4261 }
4262 
4263 //------------------------------Attribute--------------------------------------
4264 Attribute::Attribute(char *id, char* val, int type)
4265   : _ident(id), _val(val), _atype(type) {
4266 }
4267 Attribute::~Attribute() {
4268 }
4269 
4270 int Attribute::int_val(ArchDesc &amp;ad) {
4271   // Make sure it is an integer constant:
4272   int result = 0;
4273   if (!_val || !ADLParser::is_int_token(_val, result)) {
4274     ad.syntax_err(0, &quot;Attribute %s must have an integer value: %s&quot;,
4275                   _ident, _val ? _val : &quot;&quot;);
4276   }
4277   return result;
4278 }
4279 
4280 void Attribute::dump() {
4281   output(stderr);
4282 } // Debug printer
4283 
4284 // Write to output files
4285 void Attribute::output(FILE *fp) {
4286   fprintf(fp,&quot;Attribute: %s  %s\n&quot;, (_ident?_ident:&quot;&quot;), (_val?_val:&quot;&quot;));
4287 }
4288 
4289 //------------------------------FormatRule----------------------------------
4290 FormatRule::FormatRule(char *temp)
4291   : _temp(temp) {
4292 }
4293 FormatRule::~FormatRule() {
4294 }
4295 
4296 void FormatRule::dump() {
4297   output(stderr);
4298 }
4299 
4300 // Write to output files
4301 void FormatRule::output(FILE *fp) {
4302   fprintf(fp,&quot;\nFormat Rule: \n%s&quot;, (_temp?_temp:&quot;&quot;));
4303   fprintf(fp,&quot;\n&quot;);
4304 }
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/adlc/output_h.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1998, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 // output_h.cpp - Class HPP file output routines for architecture definition
  26 #include &quot;adlc.hpp&quot;
  27 
  28 // The comment delimiter used in format statements after assembler instructions.
  29 #if defined(PPC64)
  30 #define commentSeperator &quot;\t//&quot;
  31 #else
  32 #define commentSeperator &quot;!&quot;
  33 #endif
  34 
  35 // Generate the #define that describes the number of registers.
  36 static void defineRegCount(FILE *fp, RegisterForm *registers) {
  37   if (registers) {
  38     int regCount =  AdlcVMDeps::Physical + registers-&gt;_rdefs.count();
  39     fprintf(fp,&quot;\n&quot;);
  40     fprintf(fp,&quot;// the number of reserved registers + machine registers.\n&quot;);
  41     fprintf(fp,&quot;#define REG_COUNT    %d\n&quot;, regCount);
  42   }
  43 }
  44 
  45 // Output enumeration of machine register numbers
  46 // (1)
  47 // // Enumerate machine registers starting after reserved regs.
  48 // // in the order of occurrence in the register block.
  49 // enum MachRegisterNumbers {
  50 //   EAX_num = 0,
  51 //   ...
  52 //   _last_Mach_Reg
  53 // }
  54 void ArchDesc::buildMachRegisterNumbers(FILE *fp_hpp) {
  55   if (_register) {
  56     RegDef *reg_def = NULL;
  57 
  58     // Output a #define for the number of machine registers
  59     defineRegCount(fp_hpp, _register);
  60 
  61     // Count all the Save_On_Entry and Always_Save registers
  62     int    saved_on_entry = 0;
  63     int  c_saved_on_entry = 0;
  64     _register-&gt;reset_RegDefs();
  65     while( (reg_def = _register-&gt;iter_RegDefs()) != NULL ) {
  66       if( strcmp(reg_def-&gt;_callconv,&quot;SOE&quot;) == 0 ||
  67           strcmp(reg_def-&gt;_callconv,&quot;AS&quot;)  == 0 )  ++saved_on_entry;
  68       if( strcmp(reg_def-&gt;_c_conv,&quot;SOE&quot;) == 0 ||
  69           strcmp(reg_def-&gt;_c_conv,&quot;AS&quot;)  == 0 )  ++c_saved_on_entry;
  70     }
  71     fprintf(fp_hpp, &quot;\n&quot;);
  72     fprintf(fp_hpp, &quot;// the number of save_on_entry + always_saved registers.\n&quot;);
  73     fprintf(fp_hpp, &quot;#define MAX_SAVED_ON_ENTRY_REG_COUNT    %d\n&quot;,   max(saved_on_entry,c_saved_on_entry));
  74     fprintf(fp_hpp, &quot;#define     SAVED_ON_ENTRY_REG_COUNT    %d\n&quot;,   saved_on_entry);
  75     fprintf(fp_hpp, &quot;#define   C_SAVED_ON_ENTRY_REG_COUNT    %d\n&quot;, c_saved_on_entry);
  76 
  77     // (1)
  78     // Build definition for enumeration of register numbers
  79     fprintf(fp_hpp, &quot;\n&quot;);
  80     fprintf(fp_hpp, &quot;// Enumerate machine register numbers starting after reserved regs.\n&quot;);
  81     fprintf(fp_hpp, &quot;// in the order of occurrence in the register block.\n&quot;);
  82     fprintf(fp_hpp, &quot;enum MachRegisterNumbers {\n&quot;);
  83 
  84     // Output the register number for each register in the allocation classes
  85     _register-&gt;reset_RegDefs();
  86     int i = 0;
  87     while( (reg_def = _register-&gt;iter_RegDefs()) != NULL ) {
  88       fprintf(fp_hpp,&quot;  %s_num,&quot;, reg_def-&gt;_regname);
  89       for (int j = 0; j &lt; 20-(int)strlen(reg_def-&gt;_regname); j++) fprintf(fp_hpp, &quot; &quot;);
  90       fprintf(fp_hpp,&quot; // enum %3d, regnum %3d, reg encode %3s\n&quot;,
  91               i++,
  92               reg_def-&gt;register_num(),
  93               reg_def-&gt;register_encode());
  94     }
  95     // Finish defining enumeration
  96     fprintf(fp_hpp, &quot;  _last_Mach_Reg            // %d\n&quot;, i);
  97     fprintf(fp_hpp, &quot;};\n&quot;);
  98   }
  99 
 100   fprintf(fp_hpp, &quot;\n// Size of register-mask in ints\n&quot;);
 101   fprintf(fp_hpp, &quot;#define RM_SIZE %d\n&quot;,RegisterForm::RegMask_Size());
 102   fprintf(fp_hpp, &quot;// Unroll factor for loops over the data in a RegMask\n&quot;);
 103   fprintf(fp_hpp, &quot;#define FORALL_BODY &quot;);
 104   int len = RegisterForm::RegMask_Size();
 105   for( int i = 0; i &lt; len; i++ )
 106     fprintf(fp_hpp, &quot;BODY(%d) &quot;,i);
 107   fprintf(fp_hpp, &quot;\n\n&quot;);
 108 
 109   fprintf(fp_hpp,&quot;class RegMask;\n&quot;);
 110   // All RegMasks are declared &quot;extern const ...&quot; in ad_&lt;arch&gt;.hpp
 111   // fprintf(fp_hpp,&quot;extern RegMask STACK_OR_STACK_SLOTS_mask;\n\n&quot;);
 112 }
 113 
 114 
 115 // Output enumeration of machine register encodings
 116 // (2)
 117 // // Enumerate machine registers starting after reserved regs.
 118 // // in the order of occurrence in the alloc_class(es).
 119 // enum MachRegisterEncodes {
 120 //   EAX_enc = 0x00,
 121 //   ...
 122 // }
 123 void ArchDesc::buildMachRegisterEncodes(FILE *fp_hpp) {
 124   if (_register) {
 125     RegDef *reg_def = NULL;
 126     RegDef *reg_def_next = NULL;
 127 
 128     // (2)
 129     // Build definition for enumeration of encode values
 130     fprintf(fp_hpp, &quot;\n&quot;);
 131     fprintf(fp_hpp, &quot;// Enumerate machine registers starting after reserved regs.\n&quot;);
 132     fprintf(fp_hpp, &quot;// in the order of occurrence in the alloc_class(es).\n&quot;);
 133     fprintf(fp_hpp, &quot;enum MachRegisterEncodes {\n&quot;);
 134 
 135     // Find max enum string length.
 136     size_t maxlen = 0;
 137     _register-&gt;reset_RegDefs();
 138     reg_def = _register-&gt;iter_RegDefs();
 139     while (reg_def != NULL) {
 140       size_t len = strlen(reg_def-&gt;_regname);
 141       if (len &gt; maxlen) maxlen = len;
 142       reg_def = _register-&gt;iter_RegDefs();
 143     }
 144 
 145     // Output the register encoding for each register in the allocation classes
 146     _register-&gt;reset_RegDefs();
 147     reg_def_next = _register-&gt;iter_RegDefs();
 148     while( (reg_def = reg_def_next) != NULL ) {
 149       reg_def_next = _register-&gt;iter_RegDefs();
 150       fprintf(fp_hpp,&quot;  %s_enc&quot;, reg_def-&gt;_regname);
 151       for (size_t i = strlen(reg_def-&gt;_regname); i &lt; maxlen; i++) fprintf(fp_hpp, &quot; &quot;);
 152       fprintf(fp_hpp,&quot; = %3s%s\n&quot;, reg_def-&gt;register_encode(), reg_def_next == NULL? &quot;&quot; : &quot;,&quot; );
 153     }
 154     // Finish defining enumeration
 155     fprintf(fp_hpp, &quot;};\n&quot;);
 156 
 157   } // Done with register form
 158 }
 159 
 160 
 161 // Declare an array containing the machine register names, strings.
 162 static void declareRegNames(FILE *fp, RegisterForm *registers) {
 163   if (registers) {
 164 //    fprintf(fp,&quot;\n&quot;);
 165 //    fprintf(fp,&quot;// An array of character pointers to machine register names.\n&quot;);
 166 //    fprintf(fp,&quot;extern const char *regName[];\n&quot;);
 167   }
 168 }
 169 
 170 // Declare an array containing the machine register sizes in 32-bit words.
 171 void ArchDesc::declareRegSizes(FILE *fp) {
 172 // regSize[] is not used
 173 }
 174 
 175 // Declare an array containing the machine register encoding values
 176 static void declareRegEncodes(FILE *fp, RegisterForm *registers) {
 177   if (registers) {
 178     // // //
 179     // fprintf(fp,&quot;\n&quot;);
 180     // fprintf(fp,&quot;// An array containing the machine register encode values\n&quot;);
 181     // fprintf(fp,&quot;extern const char  regEncode[];\n&quot;);
 182   }
 183 }
 184 
 185 
 186 // ---------------------------------------------------------------------------
 187 //------------------------------Utilities to build Instruction Classes--------
 188 // ---------------------------------------------------------------------------
 189 static void out_RegMask(FILE *fp) {
 190   fprintf(fp,&quot;  virtual const RegMask &amp;out_RegMask() const;\n&quot;);
 191 }
 192 
 193 // ---------------------------------------------------------------------------
 194 //--------Utilities to build MachOper and MachNode derived Classes------------
 195 // ---------------------------------------------------------------------------
 196 
 197 //------------------------------Utilities to build Operand Classes------------
 198 static void in_RegMask(FILE *fp) {
 199   fprintf(fp,&quot;  virtual const RegMask *in_RegMask(int index) const;\n&quot;);
 200 }
 201 
 202 static void declareConstStorage(FILE *fp, FormDict &amp;globals, OperandForm *oper) {
 203   int i = 0;
 204   Component *comp;
 205 
 206   if (oper-&gt;num_consts(globals) == 0) return;
 207   // Iterate over the component list looking for constants
 208   oper-&gt;_components.reset();
 209   if ((comp = oper-&gt;_components.iter()) == NULL) {
 210     assert(oper-&gt;num_consts(globals) == 1, &quot;Bad component list detected.\n&quot;);
 211     const char *type = oper-&gt;ideal_type(globals);
 212     if (!strcmp(type, &quot;ConI&quot;)) {
 213       if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 214       fprintf(fp,&quot;  int32_t        _c%d;\n&quot;, i);
 215     }
 216     else if (!strcmp(type, &quot;ConP&quot;)) {
 217       if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 218       fprintf(fp,&quot;  const TypePtr *_c%d;\n&quot;, i);
 219     }
 220     else if (!strcmp(type, &quot;ConN&quot;)) {
 221       if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 222       fprintf(fp,&quot;  const TypeNarrowOop *_c%d;\n&quot;, i);
 223     }
 224     else if (!strcmp(type, &quot;ConNKlass&quot;)) {
 225       if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 226       fprintf(fp,&quot;  const TypeNarrowKlass *_c%d;\n&quot;, i);
 227     }
 228     else if (!strcmp(type, &quot;ConL&quot;)) {
 229       if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 230       fprintf(fp,&quot;  jlong          _c%d;\n&quot;, i);
 231     }
 232     else if (!strcmp(type, &quot;ConF&quot;)) {
 233       if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 234       fprintf(fp,&quot;  jfloat         _c%d;\n&quot;, i);
 235     }
 236     else if (!strcmp(type, &quot;ConD&quot;)) {
 237       if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 238       fprintf(fp,&quot;  jdouble        _c%d;\n&quot;, i);
 239     }
 240     else if (!strcmp(type, &quot;Bool&quot;)) {
 241       fprintf(fp,&quot;private:\n&quot;);
 242       fprintf(fp,&quot;  BoolTest::mask _c%d;\n&quot;, i);
 243       fprintf(fp,&quot;public:\n&quot;);
 244     }
 245     else {
 246       assert(0, &quot;Non-constant operand lacks component list.&quot;);
 247     }
 248   } // end if NULL
 249   else {
 250     oper-&gt;_components.reset();
 251     while ((comp = oper-&gt;_components.iter()) != NULL) {
 252       if (!strcmp(comp-&gt;base_type(globals), &quot;ConI&quot;)) {
 253         fprintf(fp,&quot;  jint             _c%d;\n&quot;, i);
 254         i++;
 255       }
 256       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConP&quot;)) {
 257         fprintf(fp,&quot;  const TypePtr *_c%d;\n&quot;, i);
 258         i++;
 259       }
 260       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConN&quot;)) {
 261         fprintf(fp,&quot;  const TypePtr *_c%d;\n&quot;, i);
 262         i++;
 263       }
 264       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConNKlass&quot;)) {
 265         fprintf(fp,&quot;  const TypePtr *_c%d;\n&quot;, i);
 266         i++;
 267       }
 268       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConL&quot;)) {
 269         fprintf(fp,&quot;  jlong            _c%d;\n&quot;, i);
 270         i++;
 271       }
 272       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConF&quot;)) {
 273         fprintf(fp,&quot;  jfloat           _c%d;\n&quot;, i);
 274         i++;
 275       }
 276       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConD&quot;)) {
 277         fprintf(fp,&quot;  jdouble          _c%d;\n&quot;, i);
 278         i++;
 279       }
 280     }
 281   }
 282 }
 283 
 284 // Declare constructor.
 285 // Parameters start with condition code, then all other constants
 286 //
 287 // (0) public:
 288 // (1)  MachXOper(int32 ccode, int32 c0, int32 c1, ..., int32 cn)
 289 // (2)     : _ccode(ccode), _c0(c0), _c1(c1), ..., _cn(cn) { }
 290 //
 291 static void defineConstructor(FILE *fp, const char *name, uint num_consts,
 292                               ComponentList &amp;lst, bool is_ideal_bool,
 293                               Form::DataType constant_type, FormDict &amp;globals) {
 294   fprintf(fp,&quot;public:\n&quot;);
 295   // generate line (1)
 296   fprintf(fp,&quot;  %sOper(&quot;, name);
 297   if( num_consts == 0 ) {
 298     fprintf(fp,&quot;) {}\n&quot;);
 299     return;
 300   }
 301 
 302   // generate parameters for constants
 303   uint i = 0;
 304   Component *comp;
 305   lst.reset();
 306   if ((comp = lst.iter()) == NULL) {
 307     assert(num_consts == 1, &quot;Bad component list detected.\n&quot;);
 308     switch( constant_type ) {
 309     case Form::idealI : {
 310       fprintf(fp,is_ideal_bool ? &quot;BoolTest::mask c%d&quot; : &quot;int32_t c%d&quot;, i);
 311       break;
 312     }
 313     case Form::idealN :      { fprintf(fp,&quot;const TypeNarrowOop *c%d&quot;, i); break; }
 314     case Form::idealNKlass : { fprintf(fp,&quot;const TypeNarrowKlass *c%d&quot;, i); break; }
 315     case Form::idealP :      { fprintf(fp,&quot;const TypePtr *c%d&quot;, i); break; }
 316     case Form::idealL :      { fprintf(fp,&quot;jlong c%d&quot;, i);   break;        }
 317     case Form::idealF :      { fprintf(fp,&quot;jfloat c%d&quot;, i);  break;        }
 318     case Form::idealD :      { fprintf(fp,&quot;jdouble c%d&quot;, i); break;        }
 319     default:
 320       assert(!is_ideal_bool, &quot;Non-constant operand lacks component list.&quot;);
 321       break;
 322     }
 323   } // end if NULL
 324   else {
 325     lst.reset();
 326     while((comp = lst.iter()) != NULL) {
 327       if (!strcmp(comp-&gt;base_type(globals), &quot;ConI&quot;)) {
 328         if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 329         fprintf(fp,&quot;int32_t c%d&quot;, i);
 330         i++;
 331       }
 332       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConP&quot;)) {
 333         if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 334         fprintf(fp,&quot;const TypePtr *c%d&quot;, i);
 335         i++;
 336       }
 337       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConN&quot;)) {
 338         if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 339         fprintf(fp,&quot;const TypePtr *c%d&quot;, i);
 340         i++;
 341       }
 342       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConNKlass&quot;)) {
 343         if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 344         fprintf(fp,&quot;const TypePtr *c%d&quot;, i);
 345         i++;
 346       }
 347       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConL&quot;)) {
 348         if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 349         fprintf(fp,&quot;jlong c%d&quot;, i);
 350         i++;
 351       }
 352       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConF&quot;)) {
 353         if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 354         fprintf(fp,&quot;jfloat c%d&quot;, i);
 355         i++;
 356       }
 357       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConD&quot;)) {
 358         if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 359         fprintf(fp,&quot;jdouble c%d&quot;, i);
 360         i++;
 361       }
 362       else if (!strcmp(comp-&gt;base_type(globals), &quot;Bool&quot;)) {
 363         if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 364         fprintf(fp,&quot;BoolTest::mask c%d&quot;, i);
 365         i++;
 366       }
 367     }
 368   }
 369   // finish line (1) and start line (2)
 370   fprintf(fp,&quot;)  : &quot;);
 371   // generate initializers for constants
 372   i = 0;
 373   fprintf(fp,&quot;_c%d(c%d)&quot;, i, i);
 374   for( i = 1; i &lt; num_consts; ++i) {
 375     fprintf(fp,&quot;, _c%d(c%d)&quot;, i, i);
 376   }
 377   // The body for the constructor is empty
 378   fprintf(fp,&quot; {}\n&quot;);
 379 }
 380 
 381 // ---------------------------------------------------------------------------
 382 // Utilities to generate format rules for machine operands and instructions
 383 // ---------------------------------------------------------------------------
 384 
 385 // Generate the format rule for condition codes
 386 static void defineCCodeDump(OperandForm* oper, FILE *fp, int i) {
 387   assert(oper != NULL, &quot;what&quot;);
 388   CondInterface* cond = oper-&gt;_interface-&gt;is_CondInterface();
 389   fprintf(fp, &quot;       if( _c%d == BoolTest::eq ) st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;,i,cond-&gt;_equal_format);
 390   fprintf(fp, &quot;  else if( _c%d == BoolTest::ne ) st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;,i,cond-&gt;_not_equal_format);
 391   fprintf(fp, &quot;  else if( _c%d == BoolTest::le ) st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;,i,cond-&gt;_less_equal_format);
 392   fprintf(fp, &quot;  else if( _c%d == BoolTest::ge ) st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;,i,cond-&gt;_greater_equal_format);
 393   fprintf(fp, &quot;  else if( _c%d == BoolTest::lt ) st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;,i,cond-&gt;_less_format);
 394   fprintf(fp, &quot;  else if( _c%d == BoolTest::gt ) st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;,i,cond-&gt;_greater_format);
 395   fprintf(fp, &quot;  else if( _c%d == BoolTest::overflow ) st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;,i,cond-&gt;_overflow_format);
 396   fprintf(fp, &quot;  else if( _c%d == BoolTest::no_overflow ) st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;,i,cond-&gt;_no_overflow_format);
 397 }
 398 
 399 // Output code that dumps constant values, increment &quot;i&quot; if type is constant
 400 static uint dump_spec_constant(FILE *fp, const char *ideal_type, uint i, OperandForm* oper) {
 401   if (!strcmp(ideal_type, &quot;ConI&quot;)) {
 402     fprintf(fp,&quot;   st-&gt;print(\&quot;#%%d\&quot;, _c%d);\n&quot;, i);
 403     fprintf(fp,&quot;   st-&gt;print(\&quot;/0x%%08x\&quot;, _c%d);\n&quot;, i);
 404     ++i;
 405   }
 406   else if (!strcmp(ideal_type, &quot;ConP&quot;)) {
 407     fprintf(fp,&quot;    _c%d-&gt;dump_on(st);\n&quot;, i);
 408     ++i;
 409   }
 410   else if (!strcmp(ideal_type, &quot;ConN&quot;)) {
 411     fprintf(fp,&quot;    _c%d-&gt;dump_on(st);\n&quot;, i);
 412     ++i;
 413   }
 414   else if (!strcmp(ideal_type, &quot;ConNKlass&quot;)) {
 415     fprintf(fp,&quot;    _c%d-&gt;dump_on(st);\n&quot;, i);
 416     ++i;
 417   }
 418   else if (!strcmp(ideal_type, &quot;ConL&quot;)) {
 419     fprintf(fp,&quot;    st-&gt;print(\&quot;#\&quot; INT64_FORMAT, (int64_t)_c%d);\n&quot;, i);
 420     fprintf(fp,&quot;    st-&gt;print(\&quot;/\&quot; PTR64_FORMAT, (uint64_t)_c%d);\n&quot;, i);
 421     ++i;
 422   }
 423   else if (!strcmp(ideal_type, &quot;ConF&quot;)) {
 424     fprintf(fp,&quot;    st-&gt;print(\&quot;#%%f\&quot;, _c%d);\n&quot;, i);
 425     fprintf(fp,&quot;    jint _c%di = JavaValue(_c%d).get_jint();\n&quot;, i, i);
 426     fprintf(fp,&quot;    st-&gt;print(\&quot;/0x%%x/\&quot;, _c%di);\n&quot;, i);
 427     ++i;
 428   }
 429   else if (!strcmp(ideal_type, &quot;ConD&quot;)) {
 430     fprintf(fp,&quot;    st-&gt;print(\&quot;#%%f\&quot;, _c%d);\n&quot;, i);
 431     fprintf(fp,&quot;    jlong _c%dl = JavaValue(_c%d).get_jlong();\n&quot;, i, i);
 432     fprintf(fp,&quot;    st-&gt;print(\&quot;/\&quot; PTR64_FORMAT, (uint64_t)_c%dl);\n&quot;, i);
 433     ++i;
 434   }
 435   else if (!strcmp(ideal_type, &quot;Bool&quot;)) {
 436     defineCCodeDump(oper, fp,i);
 437     ++i;
 438   }
 439 
 440   return i;
 441 }
 442 
 443 // Generate the format rule for an operand
 444 void gen_oper_format(FILE *fp, FormDict &amp;globals, OperandForm &amp;oper, bool for_c_file = false) {
 445   if (!for_c_file) {
 446     // invoked after output #ifndef PRODUCT to ad_&lt;arch&gt;.hpp
 447     // compile the bodies separately, to cut down on recompilations
 448     fprintf(fp,&quot;  virtual void           int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const;\n&quot;);
 449     fprintf(fp,&quot;  virtual void           ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const;\n&quot;);
 450     return;
 451   }
 452 
 453   // Local pointer indicates remaining part of format rule
 454   int idx = 0;                   // position of operand in match rule
 455 
 456   // Generate internal format function, used when stored locally
 457   fprintf(fp, &quot;\n#ifndef PRODUCT\n&quot;);
 458   fprintf(fp,&quot;void %sOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {\n&quot;, oper._ident);
 459   // Generate the user-defined portion of the format
 460   if (oper._format) {
 461     if ( oper._format-&gt;_strings.count() != 0 ) {
 462       // No initialization code for int_format
 463 
 464       // Build the format from the entries in strings and rep_vars
 465       const char  *string  = NULL;
 466       oper._format-&gt;_rep_vars.reset();
 467       oper._format-&gt;_strings.reset();
 468       while ( (string = oper._format-&gt;_strings.iter()) != NULL ) {
 469 
 470         // Check if this is a standard string or a replacement variable
 471         if ( string != NameList::_signal ) {
 472           // Normal string
 473           // Pass through to st-&gt;print
 474           fprintf(fp,&quot;  st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;, string);
 475         } else {
 476           // Replacement variable
 477           const char *rep_var = oper._format-&gt;_rep_vars.iter();
 478           // Check that it is a local name, and an operand
 479           const Form* form = oper._localNames[rep_var];
 480           if (form == NULL) {
 481             globalAD-&gt;syntax_err(oper._linenum,
 482                                  &quot;\&#39;%s\&#39; not found in format for %s\n&quot;, rep_var, oper._ident);
 483             assert(form, &quot;replacement variable was not found in local names&quot;);
 484           }
 485           OperandForm *op      = form-&gt;is_operand();
 486           // Get index if register or constant
 487           if ( op-&gt;_matrule &amp;&amp; op-&gt;_matrule-&gt;is_base_register(globals) ) {
 488             idx  = oper.register_position( globals, rep_var);
 489           }
 490           else if (op-&gt;_matrule &amp;&amp; op-&gt;_matrule-&gt;is_base_constant(globals)) {
 491             idx  = oper.constant_position( globals, rep_var);
 492           } else {
 493             idx = 0;
 494           }
 495 
 496           // output invocation of &quot;$...&quot;s format function
 497           if ( op != NULL ) op-&gt;int_format(fp, globals, idx);
 498 
 499           if ( idx == -1 ) {
 500             fprintf(stderr,
 501                     &quot;Using a name, %s, that isn&#39;t in match rule\n&quot;, rep_var);
 502             assert( strcmp(op-&gt;_ident,&quot;label&quot;)==0, &quot;Unimplemented&quot;);
 503           }
 504         } // Done with a replacement variable
 505       } // Done with all format strings
 506     } else {
 507       // Default formats for base operands (RegI, RegP, ConI, ConP, ...)
 508       oper.int_format(fp, globals, 0);
 509     }
 510 
 511   } else { // oper._format == NULL
 512     // Provide a few special case formats where the AD writer cannot.
 513     if ( strcmp(oper._ident,&quot;Universe&quot;)==0 ) {
 514       fprintf(fp, &quot;  st-&gt;print(\&quot;$$univ\&quot;);\n&quot;);
 515     }
 516     // labelOper::int_format is defined in ad_&lt;...&gt;.cpp
 517   }
 518   // ALWAYS! Provide a special case output for condition codes.
 519   if( oper.is_ideal_bool() ) {
 520     defineCCodeDump(&amp;oper, fp,0);
 521   }
 522   fprintf(fp,&quot;}\n&quot;);
 523 
 524   // Generate external format function, when data is stored externally
 525   fprintf(fp,&quot;void %sOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {\n&quot;, oper._ident);
 526   // Generate the user-defined portion of the format
 527   if (oper._format) {
 528     if ( oper._format-&gt;_strings.count() != 0 ) {
 529 
 530       // Check for a replacement string &quot;$...&quot;
 531       if ( oper._format-&gt;_rep_vars.count() != 0 ) {
 532         // Initialization code for ext_format
 533       }
 534 
 535       // Build the format from the entries in strings and rep_vars
 536       const char  *string  = NULL;
 537       oper._format-&gt;_rep_vars.reset();
 538       oper._format-&gt;_strings.reset();
 539       while ( (string = oper._format-&gt;_strings.iter()) != NULL ) {
 540 
 541         // Check if this is a standard string or a replacement variable
 542         if ( string != NameList::_signal ) {
 543           // Normal string
 544           // Pass through to st-&gt;print
 545           fprintf(fp,&quot;  st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;, string);
 546         } else {
 547           // Replacement variable
 548           const char *rep_var = oper._format-&gt;_rep_vars.iter();
 549          // Check that it is a local name, and an operand
 550           const Form* form = oper._localNames[rep_var];
 551           if (form == NULL) {
 552             globalAD-&gt;syntax_err(oper._linenum,
 553                                  &quot;\&#39;%s\&#39; not found in format for %s\n&quot;, rep_var, oper._ident);
 554             assert(form, &quot;replacement variable was not found in local names&quot;);
 555           }
 556           OperandForm *op      = form-&gt;is_operand();
 557           // Get index if register or constant
 558           if ( op-&gt;_matrule &amp;&amp; op-&gt;_matrule-&gt;is_base_register(globals) ) {
 559             idx  = oper.register_position( globals, rep_var);
 560           }
 561           else if (op-&gt;_matrule &amp;&amp; op-&gt;_matrule-&gt;is_base_constant(globals)) {
 562             idx  = oper.constant_position( globals, rep_var);
 563           } else {
 564             idx = 0;
 565           }
 566           // output invocation of &quot;$...&quot;s format function
 567           if ( op != NULL )   op-&gt;ext_format(fp, globals, idx);
 568 
 569           // Lookup the index position of the replacement variable
 570           idx      = oper._components.operand_position_format(rep_var, &amp;oper);
 571           if ( idx == -1 ) {
 572             fprintf(stderr,
 573                     &quot;Using a name, %s, that isn&#39;t in match rule\n&quot;, rep_var);
 574             assert( strcmp(op-&gt;_ident,&quot;label&quot;)==0, &quot;Unimplemented&quot;);
 575           }
 576         } // Done with a replacement variable
 577       } // Done with all format strings
 578 
 579     } else {
 580       // Default formats for base operands (RegI, RegP, ConI, ConP, ...)
 581       oper.ext_format(fp, globals, 0);
 582     }
 583   } else { // oper._format == NULL
 584     // Provide a few special case formats where the AD writer cannot.
 585     if ( strcmp(oper._ident,&quot;Universe&quot;)==0 ) {
 586       fprintf(fp, &quot;  st-&gt;print(\&quot;$$univ\&quot;);\n&quot;);
 587     }
 588     // labelOper::ext_format is defined in ad_&lt;...&gt;.cpp
 589   }
 590   // ALWAYS! Provide a special case output for condition codes.
 591   if( oper.is_ideal_bool() ) {
 592     defineCCodeDump(&amp;oper, fp,0);
 593   }
 594   fprintf(fp, &quot;}\n&quot;);
 595   fprintf(fp, &quot;#endif\n&quot;);
 596 }
 597 
 598 
 599 // Generate the format rule for an instruction
 600 void gen_inst_format(FILE *fp, FormDict &amp;globals, InstructForm &amp;inst, bool for_c_file = false) {
 601   if (!for_c_file) {
 602     // compile the bodies separately, to cut down on recompilations
 603     // #ifndef PRODUCT region generated by caller
 604     fprintf(fp,&quot;  virtual void           format(PhaseRegAlloc *ra, outputStream *st) const;\n&quot;);
 605     return;
 606   }
 607 
 608   // Define the format function
 609   fprintf(fp, &quot;#ifndef PRODUCT\n&quot;);
 610   fprintf(fp, &quot;void %sNode::format(PhaseRegAlloc *ra, outputStream *st) const {\n&quot;, inst._ident);
 611 
 612   // Generate the user-defined portion of the format
 613   if( inst._format ) {
 614     // If there are replacement variables,
 615     // Generate index values needed for determining the operand position
 616     if( inst._format-&gt;_rep_vars.count() )
 617       inst.index_temps(fp, globals);
 618 
 619     // Build the format from the entries in strings and rep_vars
 620     const char  *string  = NULL;
 621     inst._format-&gt;_rep_vars.reset();
 622     inst._format-&gt;_strings.reset();
 623     while( (string = inst._format-&gt;_strings.iter()) != NULL ) {
 624       fprintf(fp,&quot;  &quot;);
 625       // Check if this is a standard string or a replacement variable
 626       if( string == NameList::_signal ) { // Replacement variable
 627         const char* rep_var =  inst._format-&gt;_rep_vars.iter();
 628         inst.rep_var_format( fp, rep_var);
 629       } else if( string == NameList::_signal3 ) { // Replacement variable in raw text
 630         const char* rep_var =  inst._format-&gt;_rep_vars.iter();
 631         const Form *form   = inst._localNames[rep_var];
 632         if (form == NULL) {
 633           fprintf(stderr, &quot;unknown replacement variable in format statement: &#39;%s&#39;\n&quot;, rep_var);
 634           assert(false, &quot;ShouldNotReachHere()&quot;);
 635         }
 636         OpClassForm *opc   = form-&gt;is_opclass();
 637         assert( opc, &quot;replacement variable was not found in local names&quot;);
 638         // Lookup the index position of the replacement variable
 639         int idx  = inst.operand_position_format(rep_var);
 640         if ( idx == -1 ) {
 641           assert( strcmp(opc-&gt;_ident,&quot;label&quot;)==0, &quot;Unimplemented&quot;);
 642           assert( false, &quot;ShouldNotReachHere()&quot;);
 643         }
 644 
 645         if (inst.is_noninput_operand(idx)) {
 646           assert( false, &quot;ShouldNotReachHere()&quot;);
 647         } else {
 648           // Output the format call for this operand
 649           fprintf(fp,&quot;opnd_array(%d)&quot;,idx);
 650         }
 651         rep_var =  inst._format-&gt;_rep_vars.iter();
 652         inst._format-&gt;_strings.iter();
 653         if ( strcmp(rep_var,&quot;$constant&quot;) == 0 &amp;&amp; opc-&gt;is_operand()) {
 654           Form::DataType constant_type = form-&gt;is_operand()-&gt;is_base_constant(globals);
 655           if ( constant_type == Form::idealD ) {
 656             fprintf(fp,&quot;-&gt;constantD()&quot;);
 657           } else if ( constant_type == Form::idealF ) {
 658             fprintf(fp,&quot;-&gt;constantF()&quot;);
 659           } else if ( constant_type == Form::idealL ) {
 660             fprintf(fp,&quot;-&gt;constantL()&quot;);
 661           } else {
 662             fprintf(fp,&quot;-&gt;constant()&quot;);
 663           }
 664         } else if ( strcmp(rep_var,&quot;$cmpcode&quot;) == 0) {
 665             fprintf(fp,&quot;-&gt;ccode()&quot;);
 666         } else {
 667           assert( false, &quot;ShouldNotReachHere()&quot;);
 668         }
 669       } else if( string == NameList::_signal2 ) // Raw program text
 670         fputs(inst._format-&gt;_strings.iter(), fp);
 671       else
 672         fprintf(fp,&quot;st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;, string);
 673     } // Done with all format strings
 674   } // Done generating the user-defined portion of the format
 675 
 676   // Add call debug info automatically
 677   Form::CallType call_type = inst.is_ideal_call();
 678   if( call_type != Form::invalid_type ) {
 679     switch( call_type ) {
 680     case Form::JAVA_DYNAMIC:
 681       fprintf(fp,&quot;  _method-&gt;print_short_name(st);\n&quot;);
 682       break;
 683     case Form::JAVA_STATIC:
 684       fprintf(fp,&quot;  if( _method ) _method-&gt;print_short_name(st);\n&quot;);
 685       fprintf(fp,&quot;  else st-&gt;print(\&quot; wrapper for: %%s\&quot;, _name);\n&quot;);
 686       fprintf(fp,&quot;  if( !_method ) dump_trap_args(st);\n&quot;);
 687       break;
 688     case Form::JAVA_COMPILED:
 689     case Form::JAVA_INTERP:
 690       break;
 691     case Form::JAVA_RUNTIME:
 692     case Form::JAVA_LEAF:
 693     case Form::JAVA_NATIVE:
 694       fprintf(fp,&quot;  st-&gt;print(\&quot; %%s\&quot;, _name);&quot;);
 695       break;
 696     default:
 697       assert(0,&quot;ShouldNotReachHere&quot;);
 698     }
 699     fprintf(fp,  &quot;  st-&gt;cr();\n&quot; );
 700     fprintf(fp,  &quot;  if (_jvms) _jvms-&gt;format(ra, this, st); else st-&gt;print_cr(\&quot;        No JVM State Info\&quot;);\n&quot; );
 701     fprintf(fp,  &quot;  st-&gt;print(\&quot;        # \&quot;);\n&quot; );
 702     fprintf(fp,  &quot;  if( _jvms &amp;&amp; _oop_map ) _oop_map-&gt;print_on(st);\n&quot;);
 703   }
 704   else if(inst.is_ideal_safepoint()) {
 705     fprintf(fp,  &quot;  st-&gt;print_raw(\&quot;\&quot;);\n&quot; );
 706     fprintf(fp,  &quot;  if (_jvms) _jvms-&gt;format(ra, this, st); else st-&gt;print_cr(\&quot;        No JVM State Info\&quot;);\n&quot; );
 707     fprintf(fp,  &quot;  st-&gt;print(\&quot;        # \&quot;);\n&quot; );
 708     fprintf(fp,  &quot;  if( _jvms &amp;&amp; _oop_map ) _oop_map-&gt;print_on(st);\n&quot;);
 709   }
 710   else if( inst.is_ideal_if() ) {
 711     fprintf(fp,  &quot;  st-&gt;print(\&quot;  P=%%f C=%%f\&quot;,_prob,_fcnt);\n&quot; );
 712   }
 713   else if( inst.is_ideal_mem() ) {
 714     // Print out the field name if available to improve readability
 715     fprintf(fp,  &quot;  if (ra-&gt;C-&gt;alias_type(adr_type())-&gt;field() != NULL) {\n&quot;);
 716     fprintf(fp,  &quot;    ciField* f = ra-&gt;C-&gt;alias_type(adr_type())-&gt;field();\n&quot;);
 717     fprintf(fp,  &quot;    st-&gt;print(\&quot; %s Field: \&quot;);\n&quot;, commentSeperator);
 718     fprintf(fp,  &quot;    if (f-&gt;is_volatile())\n&quot;);
 719     fprintf(fp,  &quot;      st-&gt;print(\&quot;volatile \&quot;);\n&quot;);
 720     fprintf(fp,  &quot;    f-&gt;holder()-&gt;name()-&gt;print_symbol_on(st);\n&quot;);
 721     fprintf(fp,  &quot;    st-&gt;print(\&quot;.\&quot;);\n&quot;);
 722     fprintf(fp,  &quot;    f-&gt;name()-&gt;print_symbol_on(st);\n&quot;);
 723     fprintf(fp,  &quot;    if (f-&gt;is_constant())\n&quot;);
 724     fprintf(fp,  &quot;      st-&gt;print(\&quot; (constant)\&quot;);\n&quot;);
 725     fprintf(fp,  &quot;  } else {\n&quot;);
 726     // Make sure &#39;Volatile&#39; gets printed out
 727     fprintf(fp,  &quot;    if (ra-&gt;C-&gt;alias_type(adr_type())-&gt;is_volatile())\n&quot;);
 728     fprintf(fp,  &quot;      st-&gt;print(\&quot; volatile!\&quot;);\n&quot;);
 729     fprintf(fp,  &quot;  }\n&quot;);
 730   }
 731 
 732   // Complete the definition of the format function
 733   fprintf(fp, &quot;}\n#endif\n&quot;);
 734 }
 735 
 736 void ArchDesc::declare_pipe_classes(FILE *fp_hpp) {
 737   if (!_pipeline)
 738     return;
 739 
 740   fprintf(fp_hpp, &quot;\n&quot;);
 741   fprintf(fp_hpp, &quot;// Pipeline_Use_Cycle_Mask Class\n&quot;);
 742   fprintf(fp_hpp, &quot;class Pipeline_Use_Cycle_Mask {\n&quot;);
 743 
 744   if (_pipeline-&gt;_maxcycleused &lt;=
 745 #ifdef SPARC
 746     64
 747 #else
 748     32
 749 #endif
 750       ) {
 751     fprintf(fp_hpp, &quot;protected:\n&quot;);
 752     fprintf(fp_hpp, &quot;  %s _mask;\n\n&quot;, _pipeline-&gt;_maxcycleused &lt;= 32 ? &quot;uint&quot; : &quot;uint64_t&quot; );
 753     fprintf(fp_hpp, &quot;public:\n&quot;);
 754     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask() : _mask(0) {}\n\n&quot;);
 755     if (_pipeline-&gt;_maxcycleused &lt;= 32)
 756       fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask(uint mask) : _mask(mask) {}\n\n&quot;);
 757     else {
 758       fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask(uint mask1, uint mask2) : _mask((((uint64_t)mask1) &lt;&lt; 32) | mask2) {}\n\n&quot;);
 759       fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask(uint64_t mask) : _mask(mask) {}\n\n&quot;);
 760     }
<a name="1" id="anc1"></a><span class="line-removed"> 761     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask&amp; operator=(const Pipeline_Use_Cycle_Mask &amp;in) {\n&quot;);</span>
<span class="line-removed"> 762     fprintf(fp_hpp, &quot;    _mask = in._mask;\n&quot;);</span>
<span class="line-removed"> 763     fprintf(fp_hpp, &quot;    return *this;\n&quot;);</span>
<span class="line-removed"> 764     fprintf(fp_hpp, &quot;  }\n\n&quot;);</span>
 765     fprintf(fp_hpp, &quot;  bool overlaps(const Pipeline_Use_Cycle_Mask &amp;in2) const {\n&quot;);
 766     fprintf(fp_hpp, &quot;    return ((_mask &amp; in2._mask) != 0);\n&quot;);
 767     fprintf(fp_hpp, &quot;  }\n\n&quot;);
 768     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask&amp; operator&lt;&lt;=(int n) {\n&quot;);
 769     fprintf(fp_hpp, &quot;    _mask &lt;&lt;= n;\n&quot;);
 770     fprintf(fp_hpp, &quot;    return *this;\n&quot;);
 771     fprintf(fp_hpp, &quot;  }\n\n&quot;);
 772     fprintf(fp_hpp, &quot;  void Or(const Pipeline_Use_Cycle_Mask &amp;in2) {\n&quot;);
 773     fprintf(fp_hpp, &quot;    _mask |= in2._mask;\n&quot;);
 774     fprintf(fp_hpp, &quot;  }\n\n&quot;);
 775     fprintf(fp_hpp, &quot;  friend Pipeline_Use_Cycle_Mask operator&amp;(const Pipeline_Use_Cycle_Mask &amp;, const Pipeline_Use_Cycle_Mask &amp;);\n&quot;);
 776     fprintf(fp_hpp, &quot;  friend Pipeline_Use_Cycle_Mask operator|(const Pipeline_Use_Cycle_Mask &amp;, const Pipeline_Use_Cycle_Mask &amp;);\n\n&quot;);
 777   }
 778   else {
 779     fprintf(fp_hpp, &quot;protected:\n&quot;);
 780     uint masklen = (_pipeline-&gt;_maxcycleused + 31) &gt;&gt; 5;
 781     uint l;
 782     fprintf(fp_hpp, &quot;  uint &quot;);
 783     for (l = 1; l &lt;= masklen; l++)
 784       fprintf(fp_hpp, &quot;_mask%d%s&quot;, l, l &lt; masklen ? &quot;, &quot; : &quot;;\n\n&quot;);
 785     fprintf(fp_hpp, &quot;public:\n&quot;);
 786     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask() : &quot;);
 787     for (l = 1; l &lt;= masklen; l++)
 788       fprintf(fp_hpp, &quot;_mask%d(0)%s&quot;, l, l &lt; masklen ? &quot;, &quot; : &quot; {}\n\n&quot;);
 789     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask(&quot;);
 790     for (l = 1; l &lt;= masklen; l++)
 791       fprintf(fp_hpp, &quot;uint mask%d%s&quot;, l, l &lt; masklen ? &quot;, &quot; : &quot;) : &quot;);
 792     for (l = 1; l &lt;= masklen; l++)
 793       fprintf(fp_hpp, &quot;_mask%d(mask%d)%s&quot;, l, l, l &lt; masklen ? &quot;, &quot; : &quot; {}\n\n&quot;);
 794 
<a name="2" id="anc2"></a><span class="line-removed"> 795     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask&amp; operator=(const Pipeline_Use_Cycle_Mask &amp;in) {\n&quot;);</span>
<span class="line-removed"> 796     for (l = 1; l &lt;= masklen; l++)</span>
<span class="line-removed"> 797       fprintf(fp_hpp, &quot;    _mask%d = in._mask%d;\n&quot;, l, l);</span>
<span class="line-removed"> 798     fprintf(fp_hpp, &quot;    return *this;\n&quot;);</span>
<span class="line-removed"> 799     fprintf(fp_hpp, &quot;  }\n\n&quot;);</span>
 800     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask intersect(const Pipeline_Use_Cycle_Mask &amp;in2) {\n&quot;);
 801     fprintf(fp_hpp, &quot;    Pipeline_Use_Cycle_Mask out;\n&quot;);
 802     for (l = 1; l &lt;= masklen; l++)
 803       fprintf(fp_hpp, &quot;    out._mask%d = _mask%d &amp; in2._mask%d;\n&quot;, l, l, l);
 804     fprintf(fp_hpp, &quot;    return out;\n&quot;);
 805     fprintf(fp_hpp, &quot;  }\n\n&quot;);
 806     fprintf(fp_hpp, &quot;  bool overlaps(const Pipeline_Use_Cycle_Mask &amp;in2) const {\n&quot;);
 807     fprintf(fp_hpp, &quot;    return (&quot;);
 808     for (l = 1; l &lt;= masklen; l++)
 809       fprintf(fp_hpp, &quot;((_mask%d &amp; in2._mask%d) != 0)%s&quot;, l, l, l &lt; masklen ? &quot; || &quot; : &quot;&quot;);
 810     fprintf(fp_hpp, &quot;) ? true : false;\n&quot;);
 811     fprintf(fp_hpp, &quot;  }\n\n&quot;);
 812     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask&amp; operator&lt;&lt;=(int n) {\n&quot;);
 813     fprintf(fp_hpp, &quot;    if (n &gt;= 32)\n&quot;);
 814     fprintf(fp_hpp, &quot;      do {\n       &quot;);
 815     for (l = masklen; l &gt; 1; l--)
 816       fprintf(fp_hpp, &quot; _mask%d = _mask%d;&quot;, l, l-1);
 817     fprintf(fp_hpp, &quot; _mask%d = 0;\n&quot;, 1);
 818     fprintf(fp_hpp, &quot;      } while ((n -= 32) &gt;= 32);\n\n&quot;);
 819     fprintf(fp_hpp, &quot;    if (n &gt; 0) {\n&quot;);
 820     fprintf(fp_hpp, &quot;      uint m = 32 - n;\n&quot;);
 821     fprintf(fp_hpp, &quot;      uint mask = (1 &lt;&lt; n) - 1;\n&quot;);
 822     fprintf(fp_hpp, &quot;      uint temp%d = mask &amp; (_mask%d &gt;&gt; m); _mask%d &lt;&lt;= n;\n&quot;, 2, 1, 1);
 823     for (l = 2; l &lt; masklen; l++) {
 824       fprintf(fp_hpp, &quot;      uint temp%d = mask &amp; (_mask%d &gt;&gt; m); _mask%d &lt;&lt;= n; _mask%d |= temp%d;\n&quot;, l+1, l, l, l, l);
 825     }
 826     fprintf(fp_hpp, &quot;      _mask%d &lt;&lt;= n; _mask%d |= temp%d;\n&quot;, masklen, masklen, masklen);
 827     fprintf(fp_hpp, &quot;    }\n&quot;);
 828 
 829     fprintf(fp_hpp, &quot;    return *this;\n&quot;);
 830     fprintf(fp_hpp, &quot;  }\n\n&quot;);
 831     fprintf(fp_hpp, &quot;  void Or(const Pipeline_Use_Cycle_Mask &amp;);\n\n&quot;);
 832     fprintf(fp_hpp, &quot;  friend Pipeline_Use_Cycle_Mask operator&amp;(const Pipeline_Use_Cycle_Mask &amp;, const Pipeline_Use_Cycle_Mask &amp;);\n&quot;);
 833     fprintf(fp_hpp, &quot;  friend Pipeline_Use_Cycle_Mask operator|(const Pipeline_Use_Cycle_Mask &amp;, const Pipeline_Use_Cycle_Mask &amp;);\n\n&quot;);
 834   }
 835 
 836   fprintf(fp_hpp, &quot;  friend class Pipeline_Use;\n\n&quot;);
 837   fprintf(fp_hpp, &quot;  friend class Pipeline_Use_Element;\n\n&quot;);
 838   fprintf(fp_hpp, &quot;};\n\n&quot;);
 839 
 840   uint rescount = 0;
 841   const char *resource;
 842 
 843   for ( _pipeline-&gt;_reslist.reset(); (resource = _pipeline-&gt;_reslist.iter()) != NULL; ) {
 844       int mask = _pipeline-&gt;_resdict[resource]-&gt;is_resource()-&gt;mask();
 845       if ((mask &amp; (mask-1)) == 0)
 846         rescount++;
 847     }
 848 
 849   fprintf(fp_hpp, &quot;// Pipeline_Use_Element Class\n&quot;);
 850   fprintf(fp_hpp, &quot;class Pipeline_Use_Element {\n&quot;);
 851   fprintf(fp_hpp, &quot;protected:\n&quot;);
 852   fprintf(fp_hpp, &quot;  // Mask of used functional units\n&quot;);
 853   fprintf(fp_hpp, &quot;  uint _used;\n\n&quot;);
 854   fprintf(fp_hpp, &quot;  // Lower and upper bound of functional unit number range\n&quot;);
 855   fprintf(fp_hpp, &quot;  uint _lb, _ub;\n\n&quot;);
 856   fprintf(fp_hpp, &quot;  // Indicates multiple functionals units available\n&quot;);
 857   fprintf(fp_hpp, &quot;  bool _multiple;\n\n&quot;);
 858   fprintf(fp_hpp, &quot;  // Mask of specific used cycles\n&quot;);
 859   fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask _mask;\n\n&quot;);
 860   fprintf(fp_hpp, &quot;public:\n&quot;);
 861   fprintf(fp_hpp, &quot;  Pipeline_Use_Element() {}\n\n&quot;);
 862   fprintf(fp_hpp, &quot;  Pipeline_Use_Element(uint used, uint lb, uint ub, bool multiple, Pipeline_Use_Cycle_Mask mask)\n&quot;);
 863   fprintf(fp_hpp, &quot;  : _used(used), _lb(lb), _ub(ub), _multiple(multiple), _mask(mask) {}\n\n&quot;);
 864   fprintf(fp_hpp, &quot;  uint used() const { return _used; }\n\n&quot;);
 865   fprintf(fp_hpp, &quot;  uint lowerBound() const { return _lb; }\n\n&quot;);
 866   fprintf(fp_hpp, &quot;  uint upperBound() const { return _ub; }\n\n&quot;);
 867   fprintf(fp_hpp, &quot;  bool multiple() const { return _multiple; }\n\n&quot;);
 868   fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask mask() const { return _mask; }\n\n&quot;);
 869   fprintf(fp_hpp, &quot;  bool overlaps(const Pipeline_Use_Element &amp;in2) const {\n&quot;);
 870   fprintf(fp_hpp, &quot;    return ((_used &amp; in2._used) != 0 &amp;&amp; _mask.overlaps(in2._mask));\n&quot;);
 871   fprintf(fp_hpp, &quot;  }\n\n&quot;);
 872   fprintf(fp_hpp, &quot;  void step(uint cycles) {\n&quot;);
 873   fprintf(fp_hpp, &quot;    _used = 0;\n&quot;);
 874   fprintf(fp_hpp, &quot;    _mask &lt;&lt;= cycles;\n&quot;);
 875   fprintf(fp_hpp, &quot;  }\n\n&quot;);
 876   fprintf(fp_hpp, &quot;  friend class Pipeline_Use;\n&quot;);
 877   fprintf(fp_hpp, &quot;};\n\n&quot;);
 878 
 879   fprintf(fp_hpp, &quot;// Pipeline_Use Class\n&quot;);
 880   fprintf(fp_hpp, &quot;class Pipeline_Use {\n&quot;);
 881   fprintf(fp_hpp, &quot;protected:\n&quot;);
 882   fprintf(fp_hpp, &quot;  // These resources can be used\n&quot;);
 883   fprintf(fp_hpp, &quot;  uint _resources_used;\n\n&quot;);
 884   fprintf(fp_hpp, &quot;  // These resources are used; excludes multiple choice functional units\n&quot;);
 885   fprintf(fp_hpp, &quot;  uint _resources_used_exclusively;\n\n&quot;);
 886   fprintf(fp_hpp, &quot;  // Number of elements\n&quot;);
 887   fprintf(fp_hpp, &quot;  uint _count;\n\n&quot;);
 888   fprintf(fp_hpp, &quot;  // This is the array of Pipeline_Use_Elements\n&quot;);
 889   fprintf(fp_hpp, &quot;  Pipeline_Use_Element * _elements;\n\n&quot;);
 890   fprintf(fp_hpp, &quot;public:\n&quot;);
 891   fprintf(fp_hpp, &quot;  Pipeline_Use(uint resources_used, uint resources_used_exclusively, uint count, Pipeline_Use_Element *elements)\n&quot;);
 892   fprintf(fp_hpp, &quot;  : _resources_used(resources_used)\n&quot;);
 893   fprintf(fp_hpp, &quot;  , _resources_used_exclusively(resources_used_exclusively)\n&quot;);
 894   fprintf(fp_hpp, &quot;  , _count(count)\n&quot;);
 895   fprintf(fp_hpp, &quot;  , _elements(elements)\n&quot;);
 896   fprintf(fp_hpp, &quot;  {}\n\n&quot;);
 897   fprintf(fp_hpp, &quot;  uint resourcesUsed() const { return _resources_used; }\n\n&quot;);
 898   fprintf(fp_hpp, &quot;  uint resourcesUsedExclusively() const { return _resources_used_exclusively; }\n\n&quot;);
 899   fprintf(fp_hpp, &quot;  uint count() const { return _count; }\n\n&quot;);
 900   fprintf(fp_hpp, &quot;  Pipeline_Use_Element * element(uint i) const { return &amp;_elements[i]; }\n\n&quot;);
 901   fprintf(fp_hpp, &quot;  uint full_latency(uint delay, const Pipeline_Use &amp;pred) const;\n\n&quot;);
 902   fprintf(fp_hpp, &quot;  void add_usage(const Pipeline_Use &amp;pred);\n\n&quot;);
 903   fprintf(fp_hpp, &quot;  void reset() {\n&quot;);
 904   fprintf(fp_hpp, &quot;    _resources_used = _resources_used_exclusively = 0;\n&quot;);
 905   fprintf(fp_hpp, &quot;  };\n\n&quot;);
 906   fprintf(fp_hpp, &quot;  void step(uint cycles) {\n&quot;);
 907   fprintf(fp_hpp, &quot;    reset();\n&quot;);
 908   fprintf(fp_hpp, &quot;    for (uint i = 0; i &lt; %d; i++)\n&quot;,
 909     rescount);
 910   fprintf(fp_hpp, &quot;      (&amp;_elements[i])-&gt;step(cycles);\n&quot;);
 911   fprintf(fp_hpp, &quot;  };\n\n&quot;);
 912   fprintf(fp_hpp, &quot;  static const Pipeline_Use         elaborated_use;\n&quot;);
 913   fprintf(fp_hpp, &quot;  static const Pipeline_Use_Element elaborated_elements[%d];\n\n&quot;,
 914     rescount);
 915   fprintf(fp_hpp, &quot;  friend class Pipeline;\n&quot;);
 916   fprintf(fp_hpp, &quot;};\n\n&quot;);
 917 
 918   fprintf(fp_hpp, &quot;// Pipeline Class\n&quot;);
 919   fprintf(fp_hpp, &quot;class Pipeline {\n&quot;);
 920   fprintf(fp_hpp, &quot;public:\n&quot;);
 921 
 922   fprintf(fp_hpp, &quot;  static bool enabled() { return %s; }\n\n&quot;,
 923     _pipeline ? &quot;true&quot; : &quot;false&quot; );
 924 
 925   assert( _pipeline-&gt;_maxInstrsPerBundle &amp;&amp;
 926         ( _pipeline-&gt;_instrUnitSize || _pipeline-&gt;_bundleUnitSize) &amp;&amp;
 927           _pipeline-&gt;_instrFetchUnitSize &amp;&amp;
 928           _pipeline-&gt;_instrFetchUnits,
 929     &quot;unspecified pipeline architecture units&quot;);
 930 
 931   uint unitSize = _pipeline-&gt;_instrUnitSize ? _pipeline-&gt;_instrUnitSize : _pipeline-&gt;_bundleUnitSize;
 932 
 933   fprintf(fp_hpp, &quot;  enum {\n&quot;);
 934   fprintf(fp_hpp, &quot;    _variable_size_instructions = %d,\n&quot;,
 935     _pipeline-&gt;_variableSizeInstrs ? 1 : 0);
 936   fprintf(fp_hpp, &quot;    _fixed_size_instructions = %d,\n&quot;,
 937     _pipeline-&gt;_variableSizeInstrs ? 0 : 1);
 938   fprintf(fp_hpp, &quot;    _branch_has_delay_slot = %d,\n&quot;,
 939     _pipeline-&gt;_branchHasDelaySlot ? 1 : 0);
 940   fprintf(fp_hpp, &quot;    _max_instrs_per_bundle = %d,\n&quot;,
 941     _pipeline-&gt;_maxInstrsPerBundle);
 942   fprintf(fp_hpp, &quot;    _max_bundles_per_cycle = %d,\n&quot;,
 943     _pipeline-&gt;_maxBundlesPerCycle);
 944   fprintf(fp_hpp, &quot;    _max_instrs_per_cycle = %d\n&quot;,
 945     _pipeline-&gt;_maxBundlesPerCycle * _pipeline-&gt;_maxInstrsPerBundle);
 946   fprintf(fp_hpp, &quot;  };\n\n&quot;);
 947 
 948   fprintf(fp_hpp, &quot;  static bool instr_has_unit_size() { return %s; }\n\n&quot;,
 949     _pipeline-&gt;_instrUnitSize != 0 ? &quot;true&quot; : &quot;false&quot; );
 950   if( _pipeline-&gt;_bundleUnitSize != 0 )
 951     if( _pipeline-&gt;_instrUnitSize != 0 )
 952       fprintf(fp_hpp, &quot;// Individual Instructions may be bundled together by the hardware\n\n&quot;);
 953     else
 954       fprintf(fp_hpp, &quot;// Instructions exist only in bundles\n\n&quot;);
 955   else
 956     fprintf(fp_hpp, &quot;// Bundling is not supported\n\n&quot;);
 957   if( _pipeline-&gt;_instrUnitSize != 0 )
 958     fprintf(fp_hpp, &quot;  // Size of an instruction\n&quot;);
 959   else
 960     fprintf(fp_hpp, &quot;  // Size of an individual instruction does not exist - unsupported\n&quot;);
 961   fprintf(fp_hpp, &quot;  static uint instr_unit_size() {&quot;);
 962   if( _pipeline-&gt;_instrUnitSize == 0 )
 963     fprintf(fp_hpp, &quot; assert( false, \&quot;Instructions are only in bundles\&quot; );&quot;);
 964   fprintf(fp_hpp, &quot; return %d; };\n\n&quot;, _pipeline-&gt;_instrUnitSize);
 965 
 966   if( _pipeline-&gt;_bundleUnitSize != 0 )
 967     fprintf(fp_hpp, &quot;  // Size of a bundle\n&quot;);
 968   else
 969     fprintf(fp_hpp, &quot;  // Bundles do not exist - unsupported\n&quot;);
 970   fprintf(fp_hpp, &quot;  static uint bundle_unit_size() {&quot;);
 971   if( _pipeline-&gt;_bundleUnitSize == 0 )
 972     fprintf(fp_hpp, &quot; assert( false, \&quot;Bundles are not supported\&quot; );&quot;);
 973   fprintf(fp_hpp, &quot; return %d; };\n\n&quot;, _pipeline-&gt;_bundleUnitSize);
 974 
 975   fprintf(fp_hpp, &quot;  static bool requires_bundling() { return %s; }\n\n&quot;,
 976     _pipeline-&gt;_bundleUnitSize != 0 &amp;&amp; _pipeline-&gt;_instrUnitSize == 0 ? &quot;true&quot; : &quot;false&quot; );
 977 
 978   fprintf(fp_hpp, &quot;private:\n&quot;);
 979   fprintf(fp_hpp, &quot;  Pipeline();  // Not a legal constructor\n&quot;);
 980   fprintf(fp_hpp, &quot;\n&quot;);
 981   fprintf(fp_hpp, &quot;  const unsigned char                   _read_stage_count;\n&quot;);
 982   fprintf(fp_hpp, &quot;  const unsigned char                   _write_stage;\n&quot;);
 983   fprintf(fp_hpp, &quot;  const unsigned char                   _fixed_latency;\n&quot;);
 984   fprintf(fp_hpp, &quot;  const unsigned char                   _instruction_count;\n&quot;);
 985   fprintf(fp_hpp, &quot;  const bool                            _has_fixed_latency;\n&quot;);
 986   fprintf(fp_hpp, &quot;  const bool                            _has_branch_delay;\n&quot;);
 987   fprintf(fp_hpp, &quot;  const bool                            _has_multiple_bundles;\n&quot;);
 988   fprintf(fp_hpp, &quot;  const bool                            _force_serialization;\n&quot;);
 989   fprintf(fp_hpp, &quot;  const bool                            _may_have_no_code;\n&quot;);
 990   fprintf(fp_hpp, &quot;  const enum machPipelineStages * const _read_stages;\n&quot;);
 991   fprintf(fp_hpp, &quot;  const enum machPipelineStages * const _resource_stage;\n&quot;);
 992   fprintf(fp_hpp, &quot;  const uint                    * const _resource_cycles;\n&quot;);
 993   fprintf(fp_hpp, &quot;  const Pipeline_Use                    _resource_use;\n&quot;);
 994   fprintf(fp_hpp, &quot;\n&quot;);
 995   fprintf(fp_hpp, &quot;public:\n&quot;);
 996   fprintf(fp_hpp, &quot;  Pipeline(uint                            write_stage,\n&quot;);
 997   fprintf(fp_hpp, &quot;           uint                            count,\n&quot;);
 998   fprintf(fp_hpp, &quot;           bool                            has_fixed_latency,\n&quot;);
 999   fprintf(fp_hpp, &quot;           uint                            fixed_latency,\n&quot;);
1000   fprintf(fp_hpp, &quot;           uint                            instruction_count,\n&quot;);
1001   fprintf(fp_hpp, &quot;           bool                            has_branch_delay,\n&quot;);
1002   fprintf(fp_hpp, &quot;           bool                            has_multiple_bundles,\n&quot;);
1003   fprintf(fp_hpp, &quot;           bool                            force_serialization,\n&quot;);
1004   fprintf(fp_hpp, &quot;           bool                            may_have_no_code,\n&quot;);
1005   fprintf(fp_hpp, &quot;           enum machPipelineStages * const dst,\n&quot;);
1006   fprintf(fp_hpp, &quot;           enum machPipelineStages * const stage,\n&quot;);
1007   fprintf(fp_hpp, &quot;           uint                    * const cycles,\n&quot;);
1008   fprintf(fp_hpp, &quot;           Pipeline_Use                    resource_use)\n&quot;);
1009   fprintf(fp_hpp, &quot;  : _read_stage_count(count)\n&quot;);
1010   fprintf(fp_hpp, &quot;  , _write_stage(write_stage)\n&quot;);
1011   fprintf(fp_hpp, &quot;  , _fixed_latency(fixed_latency)\n&quot;);
1012   fprintf(fp_hpp, &quot;  , _instruction_count(instruction_count)\n&quot;);
1013   fprintf(fp_hpp, &quot;  , _has_fixed_latency(has_fixed_latency)\n&quot;);
1014   fprintf(fp_hpp, &quot;  , _has_branch_delay(has_branch_delay)\n&quot;);
1015   fprintf(fp_hpp, &quot;  , _has_multiple_bundles(has_multiple_bundles)\n&quot;);
1016   fprintf(fp_hpp, &quot;  , _force_serialization(force_serialization)\n&quot;);
1017   fprintf(fp_hpp, &quot;  , _may_have_no_code(may_have_no_code)\n&quot;);
1018   fprintf(fp_hpp, &quot;  , _read_stages(dst)\n&quot;);
1019   fprintf(fp_hpp, &quot;  , _resource_stage(stage)\n&quot;);
1020   fprintf(fp_hpp, &quot;  , _resource_cycles(cycles)\n&quot;);
1021   fprintf(fp_hpp, &quot;  , _resource_use(resource_use)\n&quot;);
1022   fprintf(fp_hpp, &quot;  {};\n&quot;);
1023   fprintf(fp_hpp, &quot;\n&quot;);
1024   fprintf(fp_hpp, &quot;  uint writeStage() const {\n&quot;);
1025   fprintf(fp_hpp, &quot;    return (_write_stage);\n&quot;);
1026   fprintf(fp_hpp, &quot;  }\n&quot;);
1027   fprintf(fp_hpp, &quot;\n&quot;);
1028   fprintf(fp_hpp, &quot;  enum machPipelineStages readStage(int ndx) const {\n&quot;);
1029   fprintf(fp_hpp, &quot;    return (ndx &lt; _read_stage_count ? _read_stages[ndx] : stage_undefined);&quot;);
1030   fprintf(fp_hpp, &quot;  }\n\n&quot;);
1031   fprintf(fp_hpp, &quot;  uint resourcesUsed() const {\n&quot;);
1032   fprintf(fp_hpp, &quot;    return _resource_use.resourcesUsed();\n  }\n\n&quot;);
1033   fprintf(fp_hpp, &quot;  uint resourcesUsedExclusively() const {\n&quot;);
1034   fprintf(fp_hpp, &quot;    return _resource_use.resourcesUsedExclusively();\n  }\n\n&quot;);
1035   fprintf(fp_hpp, &quot;  bool hasFixedLatency() const {\n&quot;);
1036   fprintf(fp_hpp, &quot;    return (_has_fixed_latency);\n  }\n\n&quot;);
1037   fprintf(fp_hpp, &quot;  uint fixedLatency() const {\n&quot;);
1038   fprintf(fp_hpp, &quot;    return (_fixed_latency);\n  }\n\n&quot;);
1039   fprintf(fp_hpp, &quot;  uint functional_unit_latency(uint start, const Pipeline *pred) const;\n\n&quot;);
1040   fprintf(fp_hpp, &quot;  uint operand_latency(uint opnd, const Pipeline *pred) const;\n\n&quot;);
1041   fprintf(fp_hpp, &quot;  const Pipeline_Use&amp; resourceUse() const {\n&quot;);
1042   fprintf(fp_hpp, &quot;    return (_resource_use); }\n\n&quot;);
1043   fprintf(fp_hpp, &quot;  const Pipeline_Use_Element * resourceUseElement(uint i) const {\n&quot;);
1044   fprintf(fp_hpp, &quot;    return (&amp;_resource_use._elements[i]); }\n\n&quot;);
1045   fprintf(fp_hpp, &quot;  uint resourceUseCount() const {\n&quot;);
1046   fprintf(fp_hpp, &quot;    return (_resource_use._count); }\n\n&quot;);
1047   fprintf(fp_hpp, &quot;  uint instructionCount() const {\n&quot;);
1048   fprintf(fp_hpp, &quot;    return (_instruction_count); }\n\n&quot;);
1049   fprintf(fp_hpp, &quot;  bool hasBranchDelay() const {\n&quot;);
1050   fprintf(fp_hpp, &quot;    return (_has_branch_delay); }\n\n&quot;);
1051   fprintf(fp_hpp, &quot;  bool hasMultipleBundles() const {\n&quot;);
1052   fprintf(fp_hpp, &quot;    return (_has_multiple_bundles); }\n\n&quot;);
1053   fprintf(fp_hpp, &quot;  bool forceSerialization() const {\n&quot;);
1054   fprintf(fp_hpp, &quot;    return (_force_serialization); }\n\n&quot;);
1055   fprintf(fp_hpp, &quot;  bool mayHaveNoCode() const {\n&quot;);
1056   fprintf(fp_hpp, &quot;    return (_may_have_no_code); }\n\n&quot;);
1057   fprintf(fp_hpp, &quot;//const Pipeline_Use_Cycle_Mask&amp; resourceUseMask(int resource) const {\n&quot;);
1058   fprintf(fp_hpp, &quot;//  return (_resource_use_masks[resource]); }\n\n&quot;);
1059   fprintf(fp_hpp, &quot;\n#ifndef PRODUCT\n&quot;);
1060   fprintf(fp_hpp, &quot;  static const char * stageName(uint i);\n&quot;);
1061   fprintf(fp_hpp, &quot;#endif\n&quot;);
1062   fprintf(fp_hpp, &quot;};\n\n&quot;);
1063 
1064   fprintf(fp_hpp, &quot;// Bundle class\n&quot;);
1065   fprintf(fp_hpp, &quot;class Bundle {\n&quot;);
1066 
1067   uint mshift = 0;
1068   for (uint msize = _pipeline-&gt;_maxInstrsPerBundle * _pipeline-&gt;_maxBundlesPerCycle; msize != 0; msize &gt;&gt;= 1)
1069     mshift++;
1070 
1071   uint rshift = rescount;
1072 
1073   fprintf(fp_hpp, &quot;protected:\n&quot;);
1074   fprintf(fp_hpp, &quot;  enum {\n&quot;);
1075   fprintf(fp_hpp, &quot;    _unused_delay                   = 0x%x,\n&quot;, 0);
1076   fprintf(fp_hpp, &quot;    _use_nop_delay                  = 0x%x,\n&quot;, 1);
1077   fprintf(fp_hpp, &quot;    _use_unconditional_delay        = 0x%x,\n&quot;, 2);
1078   fprintf(fp_hpp, &quot;    _use_conditional_delay          = 0x%x,\n&quot;, 3);
1079   fprintf(fp_hpp, &quot;    _used_in_conditional_delay      = 0x%x,\n&quot;, 4);
1080   fprintf(fp_hpp, &quot;    _used_in_unconditional_delay    = 0x%x,\n&quot;, 5);
1081   fprintf(fp_hpp, &quot;    _used_in_all_conditional_delays = 0x%x,\n&quot;, 6);
1082   fprintf(fp_hpp, &quot;\n&quot;);
1083   fprintf(fp_hpp, &quot;    _use_delay                      = 0x%x,\n&quot;, 3);
1084   fprintf(fp_hpp, &quot;    _used_in_delay                  = 0x%x\n&quot;,  4);
1085   fprintf(fp_hpp, &quot;  };\n\n&quot;);
1086   fprintf(fp_hpp, &quot;  uint _flags          : 3,\n&quot;);
1087   fprintf(fp_hpp, &quot;       _starts_bundle  : 1,\n&quot;);
1088   fprintf(fp_hpp, &quot;       _instr_count    : %d,\n&quot;,   mshift);
1089   fprintf(fp_hpp, &quot;       _resources_used : %d;\n&quot;,   rshift);
1090   fprintf(fp_hpp, &quot;public:\n&quot;);
1091   fprintf(fp_hpp, &quot;  Bundle() : _flags(_unused_delay), _starts_bundle(0), _instr_count(0), _resources_used(0) {}\n\n&quot;);
1092   fprintf(fp_hpp, &quot;  void set_instr_count(uint i) { _instr_count  = i; }\n&quot;);
1093   fprintf(fp_hpp, &quot;  void set_resources_used(uint i) { _resources_used   = i; }\n&quot;);
1094   fprintf(fp_hpp, &quot;  void clear_usage() { _flags = _unused_delay; }\n&quot;);
1095   fprintf(fp_hpp, &quot;  void set_starts_bundle() { _starts_bundle = true; }\n&quot;);
1096 
1097   fprintf(fp_hpp, &quot;  uint flags() const { return (_flags); }\n&quot;);
1098   fprintf(fp_hpp, &quot;  uint instr_count() const { return (_instr_count); }\n&quot;);
1099   fprintf(fp_hpp, &quot;  uint resources_used() const { return (_resources_used); }\n&quot;);
1100   fprintf(fp_hpp, &quot;  bool starts_bundle() const { return (_starts_bundle != 0); }\n&quot;);
1101 
1102   fprintf(fp_hpp, &quot;  void set_use_nop_delay() { _flags = _use_nop_delay; }\n&quot;);
1103   fprintf(fp_hpp, &quot;  void set_use_unconditional_delay() { _flags = _use_unconditional_delay; }\n&quot;);
1104   fprintf(fp_hpp, &quot;  void set_use_conditional_delay() { _flags = _use_conditional_delay; }\n&quot;);
1105   fprintf(fp_hpp, &quot;  void set_used_in_unconditional_delay() { _flags = _used_in_unconditional_delay; }\n&quot;);
1106   fprintf(fp_hpp, &quot;  void set_used_in_conditional_delay() { _flags = _used_in_conditional_delay; }\n&quot;);
1107   fprintf(fp_hpp, &quot;  void set_used_in_all_conditional_delays() { _flags = _used_in_all_conditional_delays; }\n&quot;);
1108 
1109   fprintf(fp_hpp, &quot;  bool use_nop_delay() { return (_flags == _use_nop_delay); }\n&quot;);
1110   fprintf(fp_hpp, &quot;  bool use_unconditional_delay() { return (_flags == _use_unconditional_delay); }\n&quot;);
1111   fprintf(fp_hpp, &quot;  bool use_conditional_delay() { return (_flags == _use_conditional_delay); }\n&quot;);
1112   fprintf(fp_hpp, &quot;  bool used_in_unconditional_delay() { return (_flags == _used_in_unconditional_delay); }\n&quot;);
1113   fprintf(fp_hpp, &quot;  bool used_in_conditional_delay() { return (_flags == _used_in_conditional_delay); }\n&quot;);
1114   fprintf(fp_hpp, &quot;  bool used_in_all_conditional_delays() { return (_flags == _used_in_all_conditional_delays); }\n&quot;);
1115   fprintf(fp_hpp, &quot;  bool use_delay() { return ((_flags &amp; _use_delay) != 0); }\n&quot;);
1116   fprintf(fp_hpp, &quot;  bool used_in_delay() { return ((_flags &amp; _used_in_delay) != 0); }\n\n&quot;);
1117 
1118   fprintf(fp_hpp, &quot;  enum {\n&quot;);
1119   fprintf(fp_hpp, &quot;    _nop_count = %d\n&quot;,
1120     _pipeline-&gt;_nopcnt);
1121   fprintf(fp_hpp, &quot;  };\n\n&quot;);
1122   fprintf(fp_hpp, &quot;  static void initialize_nops(MachNode *nop_list[%d]);\n\n&quot;,
1123     _pipeline-&gt;_nopcnt);
1124   fprintf(fp_hpp, &quot;#ifndef PRODUCT\n&quot;);
1125   fprintf(fp_hpp, &quot;  void dump(outputStream *st = tty) const;\n&quot;);
1126   fprintf(fp_hpp, &quot;#endif\n&quot;);
1127   fprintf(fp_hpp, &quot;};\n\n&quot;);
1128 
1129 //  const char *classname;
1130 //  for (_pipeline-&gt;_classlist.reset(); (classname = _pipeline-&gt;_classlist.iter()) != NULL; ) {
1131 //    PipeClassForm *pipeclass = _pipeline-&gt;_classdict[classname]-&gt;is_pipeclass();
1132 //    fprintf(fp_hpp, &quot;// Pipeline Class Instance for \&quot;%s\&quot;\n&quot;, classname);
1133 //  }
1134 }
1135 
1136 //------------------------------declareClasses---------------------------------
1137 // Construct the class hierarchy of MachNode classes from the instruction &amp;
1138 // operand lists
1139 void ArchDesc::declareClasses(FILE *fp) {
1140 
1141   // Declare an array containing the machine register names, strings.
1142   declareRegNames(fp, _register);
1143 
1144   // Declare an array containing the machine register encoding values
1145   declareRegEncodes(fp, _register);
1146 
1147   // Generate declarations for the total number of operands
1148   fprintf(fp,&quot;\n&quot;);
1149   fprintf(fp,&quot;// Total number of operands defined in architecture definition\n&quot;);
1150   int num_operands = 0;
1151   OperandForm *op;
1152   for (_operands.reset(); (op = (OperandForm*)_operands.iter()) != NULL; ) {
1153     // Ensure this is a machine-world instruction
1154     if (op-&gt;ideal_only()) continue;
1155 
1156     ++num_operands;
1157   }
1158   int first_operand_class = num_operands;
1159   OpClassForm *opc;
1160   for (_opclass.reset(); (opc = (OpClassForm*)_opclass.iter()) != NULL; ) {
1161     // Ensure this is a machine-world instruction
1162     if (opc-&gt;ideal_only()) continue;
1163 
1164     ++num_operands;
1165   }
1166   fprintf(fp,&quot;#define FIRST_OPERAND_CLASS   %d\n&quot;, first_operand_class);
1167   fprintf(fp,&quot;#define NUM_OPERANDS          %d\n&quot;, num_operands);
1168   fprintf(fp,&quot;\n&quot;);
1169   // Generate declarations for the total number of instructions
1170   fprintf(fp,&quot;// Total number of instructions defined in architecture definition\n&quot;);
1171   fprintf(fp,&quot;#define NUM_INSTRUCTIONS   %d\n&quot;,instructFormCount());
1172 
1173 
1174   // Generate Machine Classes for each operand defined in AD file
1175   fprintf(fp,&quot;\n&quot;);
1176   fprintf(fp,&quot;//----------------------------Declare classes derived from MachOper----------\n&quot;);
1177   // Iterate through all operands
1178   _operands.reset();
1179   OperandForm *oper;
1180   for( ; (oper = (OperandForm*)_operands.iter()) != NULL;) {
1181     // Ensure this is a machine-world instruction
1182     if (oper-&gt;ideal_only() ) continue;
1183     // The declaration of labelOper is in machine-independent file: machnode
1184     if ( strcmp(oper-&gt;_ident,&quot;label&quot;)  == 0 ) continue;
1185     // The declaration of methodOper is in machine-independent file: machnode
1186     if ( strcmp(oper-&gt;_ident,&quot;method&quot;) == 0 ) continue;
1187 
1188     // Build class definition for this operand
1189     fprintf(fp,&quot;\n&quot;);
1190     fprintf(fp,&quot;class %sOper : public MachOper { \n&quot;,oper-&gt;_ident);
1191     fprintf(fp,&quot;private:\n&quot;);
1192     // Operand definitions that depend upon number of input edges
1193     {
1194       uint num_edges = oper-&gt;num_edges(_globalNames);
1195       if( num_edges != 1 ) { // Use MachOper::num_edges() {return 1;}
1196         fprintf(fp,&quot;  virtual uint           num_edges() const { return %d; }\n&quot;,
1197               num_edges );
1198       }
1199       if( num_edges &gt; 0 ) {
1200         in_RegMask(fp);
1201       }
1202     }
1203 
1204     // Support storing constants inside the MachOper
1205     declareConstStorage(fp,_globalNames,oper);
1206 
1207     // Support storage of the condition codes
1208     if( oper-&gt;is_ideal_bool() ) {
1209       fprintf(fp,&quot;  virtual int ccode() const { \n&quot;);
1210       fprintf(fp,&quot;    switch (_c0) {\n&quot;);
1211       fprintf(fp,&quot;    case  BoolTest::eq : return equal();\n&quot;);
1212       fprintf(fp,&quot;    case  BoolTest::gt : return greater();\n&quot;);
1213       fprintf(fp,&quot;    case  BoolTest::lt : return less();\n&quot;);
1214       fprintf(fp,&quot;    case  BoolTest::ne : return not_equal();\n&quot;);
1215       fprintf(fp,&quot;    case  BoolTest::le : return less_equal();\n&quot;);
1216       fprintf(fp,&quot;    case  BoolTest::ge : return greater_equal();\n&quot;);
1217       fprintf(fp,&quot;    case  BoolTest::overflow : return overflow();\n&quot;);
1218       fprintf(fp,&quot;    case  BoolTest::no_overflow: return no_overflow();\n&quot;);
1219       fprintf(fp,&quot;    default : ShouldNotReachHere(); return 0;\n&quot;);
1220       fprintf(fp,&quot;    }\n&quot;);
1221       fprintf(fp,&quot;  };\n&quot;);
1222     }
1223 
1224     // Support storage of the condition codes
1225     if( oper-&gt;is_ideal_bool() ) {
1226       fprintf(fp,&quot;  virtual void negate() { \n&quot;);
1227       fprintf(fp,&quot;    _c0 = (BoolTest::mask)((int)_c0^0x4); \n&quot;);
1228       fprintf(fp,&quot;  };\n&quot;);
1229     }
1230 
1231     // Declare constructor.
1232     // Parameters start with condition code, then all other constants
1233     //
1234     // (1)  MachXOper(int32 ccode, int32 c0, int32 c1, ..., int32 cn)
1235     // (2)     : _ccode(ccode), _c0(c0), _c1(c1), ..., _cn(cn) { }
1236     //
1237     Form::DataType constant_type = oper-&gt;simple_type(_globalNames);
1238     defineConstructor(fp, oper-&gt;_ident, oper-&gt;num_consts(_globalNames),
1239                       oper-&gt;_components, oper-&gt;is_ideal_bool(),
1240                       constant_type, _globalNames);
1241 
1242     // Clone function
1243     fprintf(fp,&quot;  virtual MachOper      *clone() const;\n&quot;);
1244 
1245     // Support setting a spill offset into a constant operand.
1246     // We only support setting an &#39;int&#39; offset, while in the
1247     // LP64 build spill offsets are added with an AddP which
1248     // requires a long constant.  Thus we don&#39;t support spilling
1249     // in frames larger than 4Gig.
1250     if( oper-&gt;has_conI(_globalNames) ||
1251         oper-&gt;has_conL(_globalNames) )
1252       fprintf(fp, &quot;  virtual void set_con( jint c0 ) { _c0 = c0; }\n&quot;);
1253 
1254     // virtual functions for encoding and format
1255     //    fprintf(fp,&quot;  virtual void           encode()   const {\n    %s }\n&quot;,
1256     //            (oper-&gt;_encrule)?(oper-&gt;_encrule-&gt;_encrule):&quot;&quot;);
1257     // Check the interface type, and generate the correct query functions
1258     // encoding queries based upon MEMORY_INTER, REG_INTER, CONST_INTER.
1259 
1260     fprintf(fp,&quot;  virtual uint           opcode() const { return %s; }\n&quot;,
1261             machOperEnum(oper-&gt;_ident));
1262 
1263     // virtual function to look up ideal return type of machine instruction
1264     //
1265     // (1)  virtual const Type    *type() const { return .....; }
1266     //
1267     if ((oper-&gt;_matrule) &amp;&amp; (oper-&gt;_matrule-&gt;_lChild == NULL) &amp;&amp;
1268         (oper-&gt;_matrule-&gt;_rChild == NULL)) {
1269       unsigned int position = 0;
1270       const char  *opret, *opname, *optype;
1271       oper-&gt;_matrule-&gt;base_operand(position,_globalNames,opret,opname,optype);
1272       fprintf(fp,&quot;  virtual const Type    *type() const {&quot;);
1273       const char *type = getIdealType(optype);
1274       if( type != NULL ) {
1275         Form::DataType data_type = oper-&gt;is_base_constant(_globalNames);
1276         // Check if we are an ideal pointer type
1277         if( data_type == Form::idealP || data_type == Form::idealN || data_type == Form::idealNKlass ) {
1278           // Return the ideal type we already have: &lt;TypePtr *&gt;
1279           fprintf(fp,&quot; return _c0;&quot;);
1280         } else {
1281           // Return the appropriate bottom type
1282           fprintf(fp,&quot; return %s;&quot;, getIdealType(optype));
1283         }
1284       } else {
1285         fprintf(fp,&quot; ShouldNotCallThis(); return Type::BOTTOM;&quot;);
1286       }
1287       fprintf(fp,&quot; }\n&quot;);
1288     } else {
1289       // Check for user-defined stack slots, based upon sRegX
1290       Form::DataType data_type = oper-&gt;is_user_name_for_sReg();
1291       if( data_type != Form::none ){
1292         const char *type = NULL;
1293         switch( data_type ) {
1294         case Form::idealI: type = &quot;TypeInt::INT&quot;;   break;
1295         case Form::idealP: type = &quot;TypePtr::BOTTOM&quot;;break;
1296         case Form::idealF: type = &quot;Type::FLOAT&quot;;    break;
1297         case Form::idealD: type = &quot;Type::DOUBLE&quot;;   break;
1298         case Form::idealL: type = &quot;TypeLong::LONG&quot;; break;
1299         case Form::none: // fall through
1300         default:
1301           assert( false, &quot;No support for this type of stackSlot&quot;);
1302         }
1303         fprintf(fp,&quot;  virtual const Type    *type() const { return %s; } // stackSlotX\n&quot;, type);
1304       }
1305     }
1306 
1307 
1308     //
1309     // virtual functions for defining the encoding interface.
1310     //
1311     // Access the linearized ideal register mask,
1312     // map to physical register encoding
1313     if ( oper-&gt;_matrule &amp;&amp; oper-&gt;_matrule-&gt;is_base_register(_globalNames) ) {
1314       // Just use the default virtual &#39;reg&#39; call
1315     } else if ( oper-&gt;ideal_to_sReg_type(oper-&gt;_ident) != Form::none ) {
1316       // Special handling for operand &#39;sReg&#39;, a Stack Slot Register.
1317       // Map linearized ideal register mask to stack slot number
1318       fprintf(fp,&quot;  virtual int            reg(PhaseRegAlloc *ra_, const Node *node) const {\n&quot;);
1319       fprintf(fp,&quot;    return (int)OptoReg::reg2stack(ra_-&gt;get_reg_first(node));/* sReg */\n&quot;);
1320       fprintf(fp,&quot;  }\n&quot;);
1321       fprintf(fp,&quot;  virtual int            reg(PhaseRegAlloc *ra_, const Node *node, int idx) const {\n&quot;);
1322       fprintf(fp,&quot;    return (int)OptoReg::reg2stack(ra_-&gt;get_reg_first(node-&gt;in(idx)));/* sReg */\n&quot;);
1323       fprintf(fp,&quot;  }\n&quot;);
1324     }
1325 
1326     // Output the operand specific access functions used by an enc_class
1327     // These are only defined when we want to override the default virtual func
1328     if (oper-&gt;_interface != NULL) {
1329       fprintf(fp,&quot;\n&quot;);
1330       // Check if it is a Memory Interface
1331       if ( oper-&gt;_interface-&gt;is_MemInterface() != NULL ) {
1332         MemInterface *mem_interface = oper-&gt;_interface-&gt;is_MemInterface();
1333         const char *base = mem_interface-&gt;_base;
1334         if( base != NULL ) {
1335           define_oper_interface(fp, *oper, _globalNames, &quot;base&quot;, base);
1336         }
1337         char *index = mem_interface-&gt;_index;
1338         if( index != NULL ) {
1339           define_oper_interface(fp, *oper, _globalNames, &quot;index&quot;, index);
1340         }
1341         const char *scale = mem_interface-&gt;_scale;
1342         if( scale != NULL ) {
1343           define_oper_interface(fp, *oper, _globalNames, &quot;scale&quot;, scale);
1344         }
1345         const char *disp = mem_interface-&gt;_disp;
1346         if( disp != NULL ) {
1347           define_oper_interface(fp, *oper, _globalNames, &quot;disp&quot;, disp);
1348           oper-&gt;disp_is_oop(fp, _globalNames);
1349         }
1350         if( oper-&gt;stack_slots_only(_globalNames) ) {
1351           // should not call this:
1352           fprintf(fp,&quot;  virtual int       constant_disp() const { return Type::OffsetBot; }&quot;);
1353         } else if ( disp != NULL ) {
1354           define_oper_interface(fp, *oper, _globalNames, &quot;constant_disp&quot;, disp);
1355         }
1356       } // end Memory Interface
1357       // Check if it is a Conditional Interface
1358       else if (oper-&gt;_interface-&gt;is_CondInterface() != NULL) {
1359         CondInterface *cInterface = oper-&gt;_interface-&gt;is_CondInterface();
1360         const char *equal = cInterface-&gt;_equal;
1361         if( equal != NULL ) {
1362           define_oper_interface(fp, *oper, _globalNames, &quot;equal&quot;, equal);
1363         }
1364         const char *not_equal = cInterface-&gt;_not_equal;
1365         if( not_equal != NULL ) {
1366           define_oper_interface(fp, *oper, _globalNames, &quot;not_equal&quot;, not_equal);
1367         }
1368         const char *less = cInterface-&gt;_less;
1369         if( less != NULL ) {
1370           define_oper_interface(fp, *oper, _globalNames, &quot;less&quot;, less);
1371         }
1372         const char *greater_equal = cInterface-&gt;_greater_equal;
1373         if( greater_equal != NULL ) {
1374           define_oper_interface(fp, *oper, _globalNames, &quot;greater_equal&quot;, greater_equal);
1375         }
1376         const char *less_equal = cInterface-&gt;_less_equal;
1377         if( less_equal != NULL ) {
1378           define_oper_interface(fp, *oper, _globalNames, &quot;less_equal&quot;, less_equal);
1379         }
1380         const char *greater = cInterface-&gt;_greater;
1381         if( greater != NULL ) {
1382           define_oper_interface(fp, *oper, _globalNames, &quot;greater&quot;, greater);
1383         }
1384         const char *overflow = cInterface-&gt;_overflow;
1385         if( overflow != NULL ) {
1386           define_oper_interface(fp, *oper, _globalNames, &quot;overflow&quot;, overflow);
1387         }
1388         const char *no_overflow = cInterface-&gt;_no_overflow;
1389         if( no_overflow != NULL ) {
1390           define_oper_interface(fp, *oper, _globalNames, &quot;no_overflow&quot;, no_overflow);
1391         }
1392       } // end Conditional Interface
1393       // Check if it is a Constant Interface
1394       else if (oper-&gt;_interface-&gt;is_ConstInterface() != NULL ) {
1395         assert( oper-&gt;num_consts(_globalNames) == 1,
1396                 &quot;Must have one constant when using CONST_INTER encoding&quot;);
1397         if (!strcmp(oper-&gt;ideal_type(_globalNames), &quot;ConI&quot;)) {
1398           // Access the locally stored constant
1399           fprintf(fp,&quot;  virtual intptr_t       constant() const {&quot;);
1400           fprintf(fp,   &quot; return (intptr_t)_c0;&quot;);
1401           fprintf(fp,&quot;  }\n&quot;);
1402         }
1403         else if (!strcmp(oper-&gt;ideal_type(_globalNames), &quot;ConP&quot;)) {
1404           // Access the locally stored constant
1405           fprintf(fp,&quot;  virtual intptr_t       constant() const {&quot;);
1406           fprintf(fp,   &quot; return _c0-&gt;get_con();&quot;);
1407           fprintf(fp, &quot; }\n&quot;);
1408           // Generate query to determine if this pointer is an oop
1409           fprintf(fp,&quot;  virtual relocInfo::relocType           constant_reloc() const {&quot;);
1410           fprintf(fp,   &quot; return _c0-&gt;reloc();&quot;);
1411           fprintf(fp, &quot; }\n&quot;);
1412         }
1413         else if (!strcmp(oper-&gt;ideal_type(_globalNames), &quot;ConN&quot;)) {
1414           // Access the locally stored constant
1415           fprintf(fp,&quot;  virtual intptr_t       constant() const {&quot;);
1416           fprintf(fp,   &quot; return _c0-&gt;get_ptrtype()-&gt;get_con();&quot;);
1417           fprintf(fp, &quot; }\n&quot;);
1418           // Generate query to determine if this pointer is an oop
1419           fprintf(fp,&quot;  virtual relocInfo::relocType           constant_reloc() const {&quot;);
1420           fprintf(fp,   &quot; return _c0-&gt;get_ptrtype()-&gt;reloc();&quot;);
1421           fprintf(fp, &quot; }\n&quot;);
1422         }
1423         else if (!strcmp(oper-&gt;ideal_type(_globalNames), &quot;ConNKlass&quot;)) {
1424           // Access the locally stored constant
1425           fprintf(fp,&quot;  virtual intptr_t       constant() const {&quot;);
1426           fprintf(fp,   &quot; return _c0-&gt;get_ptrtype()-&gt;get_con();&quot;);
1427           fprintf(fp, &quot; }\n&quot;);
1428           // Generate query to determine if this pointer is an oop
1429           fprintf(fp,&quot;  virtual relocInfo::relocType           constant_reloc() const {&quot;);
1430           fprintf(fp,   &quot; return _c0-&gt;get_ptrtype()-&gt;reloc();&quot;);
1431           fprintf(fp, &quot; }\n&quot;);
1432         }
1433         else if (!strcmp(oper-&gt;ideal_type(_globalNames), &quot;ConL&quot;)) {
1434           fprintf(fp,&quot;  virtual intptr_t       constant() const {&quot;);
1435           // We don&#39;t support addressing modes with &gt; 4Gig offsets.
1436           // Truncate to int.
1437           fprintf(fp,   &quot;  return (intptr_t)_c0;&quot;);
1438           fprintf(fp, &quot; }\n&quot;);
1439           fprintf(fp,&quot;  virtual jlong          constantL() const {&quot;);
1440           fprintf(fp,   &quot; return _c0;&quot;);
1441           fprintf(fp, &quot; }\n&quot;);
1442         }
1443         else if (!strcmp(oper-&gt;ideal_type(_globalNames), &quot;ConF&quot;)) {
1444           fprintf(fp,&quot;  virtual intptr_t       constant() const {&quot;);
1445           fprintf(fp,   &quot; ShouldNotReachHere(); return 0; &quot;);
1446           fprintf(fp, &quot; }\n&quot;);
1447           fprintf(fp,&quot;  virtual jfloat         constantF() const {&quot;);
1448           fprintf(fp,   &quot; return (jfloat)_c0;&quot;);
1449           fprintf(fp, &quot; }\n&quot;);
1450         }
1451         else if (!strcmp(oper-&gt;ideal_type(_globalNames), &quot;ConD&quot;)) {
1452           fprintf(fp,&quot;  virtual intptr_t       constant() const {&quot;);
1453           fprintf(fp,   &quot; ShouldNotReachHere(); return 0; &quot;);
1454           fprintf(fp, &quot; }\n&quot;);
1455           fprintf(fp,&quot;  virtual jdouble        constantD() const {&quot;);
1456           fprintf(fp,   &quot; return _c0;&quot;);
1457           fprintf(fp, &quot; }\n&quot;);
1458         }
1459       }
1460       else if (oper-&gt;_interface-&gt;is_RegInterface() != NULL) {
1461         // make sure that a fixed format string isn&#39;t used for an
1462         // operand which might be assiged to multiple registers.
1463         // Otherwise the opto assembly output could be misleading.
1464         if (oper-&gt;_format-&gt;_strings.count() != 0 &amp;&amp; !oper-&gt;is_bound_register()) {
1465           syntax_err(oper-&gt;_linenum,
1466                      &quot;Only bound registers can have fixed formats: %s\n&quot;,
1467                      oper-&gt;_ident);
1468         }
1469       }
1470       else {
1471         assert( false, &quot;ShouldNotReachHere();&quot;);
1472       }
1473     }
1474 
1475     fprintf(fp,&quot;\n&quot;);
1476     // // Currently all XXXOper::hash() methods are identical (990820)
1477     // declare_hash(fp);
1478     // // Currently all XXXOper::Cmp() methods are identical (990820)
1479     // declare_cmp(fp);
1480 
1481     // Do not place dump_spec() and Name() into PRODUCT code
1482     // int_format and ext_format are not needed in PRODUCT code either
1483     fprintf(fp, &quot;#ifndef PRODUCT\n&quot;);
1484 
1485     // Declare int_format() and ext_format()
1486     gen_oper_format(fp, _globalNames, *oper);
1487 
1488     // Machine independent print functionality for debugging
1489     // IF we have constants, create a dump_spec function for the derived class
1490     //
1491     // (1)  virtual void           dump_spec() const {
1492     // (2)    st-&gt;print(&quot;#%d&quot;, _c#);        // Constant != ConP
1493     //  OR    _c#-&gt;dump_on(st);             // Type ConP
1494     //  ...
1495     // (3)  }
1496     uint num_consts = oper-&gt;num_consts(_globalNames);
1497     if( num_consts &gt; 0 ) {
1498       // line (1)
1499       fprintf(fp, &quot;  virtual void           dump_spec(outputStream *st) const {\n&quot;);
1500       // generate format string for st-&gt;print
1501       // Iterate over the component list &amp; spit out the right thing
1502       uint i = 0;
1503       const char *type = oper-&gt;ideal_type(_globalNames);
1504       Component  *comp;
1505       oper-&gt;_components.reset();
1506       if ((comp = oper-&gt;_components.iter()) == NULL) {
1507         assert(num_consts == 1, &quot;Bad component list detected.\n&quot;);
1508         i = dump_spec_constant( fp, type, i, oper );
1509         // Check that type actually matched
1510         assert( i != 0, &quot;Non-constant operand lacks component list.&quot;);
1511       } // end if NULL
1512       else {
1513         // line (2)
1514         // dump all components
1515         oper-&gt;_components.reset();
1516         while((comp = oper-&gt;_components.iter()) != NULL) {
1517           type = comp-&gt;base_type(_globalNames);
1518           i = dump_spec_constant( fp, type, i, NULL );
1519         }
1520       }
1521       // finish line (3)
1522       fprintf(fp,&quot;  }\n&quot;);
1523     }
1524 
1525     fprintf(fp,&quot;  virtual const char    *Name() const { return \&quot;%s\&quot;;}\n&quot;,
1526             oper-&gt;_ident);
1527 
1528     fprintf(fp,&quot;#endif\n&quot;);
1529 
1530     // Close definition of this XxxMachOper
1531     fprintf(fp,&quot;};\n&quot;);
1532   }
1533 
1534 
1535   // Generate Machine Classes for each instruction defined in AD file
1536   fprintf(fp,&quot;\n&quot;);
1537   fprintf(fp,&quot;//----------------------------Declare classes for Pipelines-----------------\n&quot;);
1538   declare_pipe_classes(fp);
1539 
1540   // Generate Machine Classes for each instruction defined in AD file
1541   fprintf(fp,&quot;\n&quot;);
1542   fprintf(fp,&quot;//----------------------------Declare classes derived from MachNode----------\n&quot;);
1543   _instructions.reset();
1544   InstructForm *instr;
1545   for( ; (instr = (InstructForm*)_instructions.iter()) != NULL; ) {
1546     // Ensure this is a machine-world instruction
1547     if ( instr-&gt;ideal_only() ) continue;
1548 
1549     // Build class definition for this instruction
1550     fprintf(fp,&quot;\n&quot;);
1551     fprintf(fp,&quot;class %sNode : public %s { \n&quot;,
1552             instr-&gt;_ident, instr-&gt;mach_base_class(_globalNames) );
1553     fprintf(fp,&quot;private:\n&quot;);
1554     fprintf(fp,&quot;  MachOper *_opnd_array[%d];\n&quot;, instr-&gt;num_opnds() );
1555     if ( instr-&gt;is_ideal_jump() ) {
1556       fprintf(fp, &quot;  GrowableArray&lt;Label*&gt; _index2label;\n&quot;);
1557     }
1558 
1559     fprintf(fp, &quot;public:\n&quot;);
1560 
1561     Attribute *att = instr-&gt;_attribs;
1562     // Fields of the node specified in the ad file.
1563     while (att != NULL) {
1564       if (strncmp(att-&gt;_ident, &quot;ins_field_&quot;, 10) == 0) {
1565         const char *field_name = att-&gt;_ident+10;
1566         const char *field_type = att-&gt;_val;
1567         fprintf(fp, &quot;  %s _%s;\n&quot;, field_type, field_name);
1568       }
1569       att = (Attribute *)att-&gt;_next;
1570     }
1571 
1572     fprintf(fp,&quot;  MachOper *opnd_array(uint operand_index) const {\n&quot;);
1573     fprintf(fp,&quot;    assert(operand_index &lt; _num_opnds, \&quot;invalid _opnd_array index\&quot;);\n&quot;);
1574     fprintf(fp,&quot;    return _opnd_array[operand_index];\n&quot;);
1575     fprintf(fp,&quot;  }\n&quot;);
1576     fprintf(fp,&quot;  void      set_opnd_array(uint operand_index, MachOper *operand) {\n&quot;);
1577     fprintf(fp,&quot;    assert(operand_index &lt; _num_opnds, \&quot;invalid _opnd_array index\&quot;);\n&quot;);
1578     fprintf(fp,&quot;    _opnd_array[operand_index] = operand;\n&quot;);
1579     fprintf(fp,&quot;  }\n&quot;);
<a name="3" id="anc3"></a>

1580     fprintf(fp,&quot;private:\n&quot;);
1581     if ( instr-&gt;is_ideal_jump() ) {
1582       fprintf(fp,&quot;  virtual void           add_case_label(int index_num, Label* blockLabel) {\n&quot;);
1583       fprintf(fp,&quot;    _index2label.at_put_grow(index_num, blockLabel);\n&quot;);
1584       fprintf(fp,&quot;  }\n&quot;);
1585     }
1586     if( can_cisc_spill() &amp;&amp; (instr-&gt;cisc_spill_alternate() != NULL) ) {
1587       fprintf(fp,&quot;  const RegMask  *_cisc_RegMask;\n&quot;);
1588     }
1589 
1590     out_RegMask(fp);                      // output register mask
<a name="4" id="anc4"></a><span class="line-removed">1591     fprintf(fp,&quot;  virtual uint           rule() const { return %s_rule; }\n&quot;,</span>
<span class="line-removed">1592             instr-&gt;_ident);</span>
1593 
1594     // If this instruction contains a labelOper
1595     // Declare Node::methods that set operand Label&#39;s contents
1596     int label_position = instr-&gt;label_position();
1597     if( label_position != -1 ) {
1598       // Set/Save the label, stored in labelOper::_branch_label
1599       fprintf(fp,&quot;  virtual void           label_set( Label* label, uint block_num );\n&quot;);
1600       fprintf(fp,&quot;  virtual void           save_label( Label** label, uint* block_num );\n&quot;);
1601     }
1602 
1603     // If this instruction contains a methodOper
1604     // Declare Node::methods that set operand method&#39;s contents
1605     int method_position = instr-&gt;method_position();
1606     if( method_position != -1 ) {
1607       // Set the address method, stored in methodOper::_method
1608       fprintf(fp,&quot;  virtual void           method_set( intptr_t method );\n&quot;);
1609     }
1610 
1611     // virtual functions for attributes
1612     //
1613     // Each instruction attribute results in a virtual call of same name.
1614     // The ins_cost is not handled here.
1615     Attribute *attr = instr-&gt;_attribs;
1616     Attribute *avoid_back_to_back_attr = NULL;
1617     while (attr != NULL) {
1618       if (strcmp (attr-&gt;_ident, &quot;ins_is_TrapBasedCheckNode&quot;) == 0) {
1619         fprintf(fp, &quot;  virtual bool           is_TrapBasedCheckNode() const { return %s; }\n&quot;, attr-&gt;_val);
1620       } else if (strcmp (attr-&gt;_ident, &quot;ins_cost&quot;) != 0 &amp;&amp;
1621           strncmp(attr-&gt;_ident, &quot;ins_field_&quot;, 10) != 0 &amp;&amp;
1622           // Must match function in node.hpp: return type bool, no prefix &quot;ins_&quot;.
1623           strcmp (attr-&gt;_ident, &quot;ins_is_TrapBasedCheckNode&quot;) != 0 &amp;&amp;
1624           strcmp (attr-&gt;_ident, &quot;ins_short_branch&quot;) != 0) {
1625         fprintf(fp, &quot;  virtual int            %s() const { return %s; }\n&quot;, attr-&gt;_ident, attr-&gt;_val);
1626       }
1627       if (strcmp(attr-&gt;_ident, &quot;ins_avoid_back_to_back&quot;) == 0) {
1628         avoid_back_to_back_attr = attr;
1629       }
1630       attr = (Attribute *)attr-&gt;_next;
1631     }
1632 
1633     // virtual functions for encode and format
1634 
1635     // Virtual function for evaluating the constant.
1636     if (instr-&gt;is_mach_constant()) {
1637       fprintf(fp,&quot;  virtual void           eval_constant(Compile* C);\n&quot;);
1638     }
1639 
1640     // Output the opcode function and the encode function here using the
1641     // encoding class information in the _insencode slot.
1642     if ( instr-&gt;_insencode ) {
1643       if (instr-&gt;postalloc_expands()) {
1644         fprintf(fp,&quot;  virtual bool           requires_postalloc_expand() const { return true; }\n&quot;);
1645         fprintf(fp,&quot;  virtual void           postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_);\n&quot;);
1646       } else {
1647         fprintf(fp,&quot;  virtual void           emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;\n&quot;);
1648       }
1649     }
1650 
1651     // virtual function for getting the size of an instruction
1652     if ( instr-&gt;_size ) {
1653       fprintf(fp,&quot;  virtual uint           size(PhaseRegAlloc *ra_) const;\n&quot;);
1654     }
1655 
1656     // Return the top-level ideal opcode.
1657     // Use MachNode::ideal_Opcode() for nodes based on MachNode class
1658     // if the ideal_Opcode == Op_Node.
1659     if ( strcmp(&quot;Node&quot;, instr-&gt;ideal_Opcode(_globalNames)) != 0 ||
1660          strcmp(&quot;MachNode&quot;, instr-&gt;mach_base_class(_globalNames)) != 0 ) {
1661       fprintf(fp,&quot;  virtual int            ideal_Opcode() const { return Op_%s; }\n&quot;,
1662             instr-&gt;ideal_Opcode(_globalNames) );
1663     }
1664 
1665     if (instr-&gt;needs_constant_base() &amp;&amp;
1666         !instr-&gt;is_mach_constant()) {  // These inherit the funcion from MachConstantNode.
1667       fprintf(fp,&quot;  virtual uint           mach_constant_base_node_input() const { &quot;);
1668       if (instr-&gt;is_ideal_call() != Form::invalid_type &amp;&amp;
1669           instr-&gt;is_ideal_call() != Form::JAVA_LEAF) {
1670         // MachConstantBase goes behind arguments, but before jvms.
1671         fprintf(fp,&quot;assert(tf() &amp;&amp; tf()-&gt;domain(), \&quot;\&quot;); return tf()-&gt;domain()-&gt;cnt();&quot;);
1672       } else {
1673         fprintf(fp,&quot;return req()-1;&quot;);
1674       }
1675       fprintf(fp,&quot; }\n&quot;);
1676     }
1677 
1678     // Allow machine-independent optimization, invert the sense of the IF test
1679     if( instr-&gt;is_ideal_if() ) {
1680       fprintf(fp,&quot;  virtual void           negate() { \n&quot;);
1681       // Identify which operand contains the negate(able) ideal condition code
1682       int   idx = 0;
1683       instr-&gt;_components.reset();
1684       for( Component *comp; (comp = instr-&gt;_components.iter()) != NULL; ) {
1685         // Check that component is an operand
1686         Form *form = (Form*)_globalNames[comp-&gt;_type];
1687         OperandForm *opForm = form ? form-&gt;is_operand() : NULL;
1688         if( opForm == NULL ) continue;
1689 
1690         // Lookup the position of the operand in the instruction.
1691         if( opForm-&gt;is_ideal_bool() ) {
1692           idx = instr-&gt;operand_position(comp-&gt;_name, comp-&gt;_usedef);
1693           assert( idx != NameList::Not_in_list, &quot;Did not find component in list that contained it.&quot;);
1694           break;
1695         }
1696       }
1697       fprintf(fp,&quot;    opnd_array(%d)-&gt;negate();\n&quot;, idx);
1698       fprintf(fp,&quot;    _prob = 1.0f - _prob;\n&quot;);
1699       fprintf(fp,&quot;  };\n&quot;);
1700     }
1701 
1702 
1703     // Identify which input register matches the input register.
1704     uint  matching_input = instr-&gt;two_address(_globalNames);
1705 
1706     // Generate the method if it returns != 0 otherwise use MachNode::two_adr()
1707     if( matching_input != 0 ) {
1708       fprintf(fp,&quot;  virtual uint           two_adr() const  &quot;);
1709       fprintf(fp,&quot;{ return oper_input_base()&quot;);
1710       for( uint i = 2; i &lt;= matching_input; i++ )
1711         fprintf(fp,&quot; + opnd_array(%d)-&gt;num_edges()&quot;,i-1);
1712       fprintf(fp,&quot;; }\n&quot;);
1713     }
1714 
1715     // Declare cisc_version, if applicable
1716     //   MachNode *cisc_version( int offset /* ,... */ );
1717     instr-&gt;declare_cisc_version(*this, fp);
1718 
1719     // If there is an explicit peephole rule, build it
1720     if ( instr-&gt;peepholes() != NULL ) {
1721       fprintf(fp,&quot;  virtual MachNode      *peephole(Block *block, int block_index, PhaseRegAlloc *ra_, int &amp;deleted);\n&quot;);
1722     }
1723 
1724     // Output the declaration for number of relocation entries
1725     if ( instr-&gt;reloc(_globalNames) != 0 ) {
1726       fprintf(fp,&quot;  virtual int            reloc() const;\n&quot;);
1727     }
1728 
1729     if (instr-&gt;alignment() != 1) {
1730       fprintf(fp,&quot;  virtual int            alignment_required() const { return %d; }\n&quot;, instr-&gt;alignment());
1731       fprintf(fp,&quot;  virtual int            compute_padding(int current_offset) const;\n&quot;);
1732     }
1733 
1734     // Starting point for inputs matcher wants.
1735     // Use MachNode::oper_input_base() for nodes based on MachNode class
1736     // if the base == 1.
1737     if ( instr-&gt;oper_input_base(_globalNames) != 1 ||
1738          strcmp(&quot;MachNode&quot;, instr-&gt;mach_base_class(_globalNames)) != 0 ) {
1739       fprintf(fp,&quot;  virtual uint           oper_input_base() const { return %d; }\n&quot;,
1740             instr-&gt;oper_input_base(_globalNames));
1741     }
1742 
1743     // Make the constructor and following methods &#39;public:&#39;
1744     fprintf(fp,&quot;public:\n&quot;);
1745 
1746     // Constructor
1747     if ( instr-&gt;is_ideal_jump() ) {
1748       fprintf(fp,&quot;  %sNode() : _index2label(MinJumpTableSize*2) { &quot;, instr-&gt;_ident);
1749     } else {
1750       fprintf(fp,&quot;  %sNode() { &quot;, instr-&gt;_ident);
1751       if( can_cisc_spill() &amp;&amp; (instr-&gt;cisc_spill_alternate() != NULL) ) {
1752         fprintf(fp,&quot;_cisc_RegMask = NULL; &quot;);
1753       }
1754     }
1755 
1756     fprintf(fp,&quot; _num_opnds = %d; _opnds = _opnd_array; &quot;, instr-&gt;num_opnds());
1757 
1758     bool node_flags_set = false;
1759     // flag: if this instruction matches an ideal &#39;Copy*&#39; node
1760     if ( instr-&gt;is_ideal_copy() != 0 ) {
1761       fprintf(fp,&quot;init_flags(Flag_is_Copy&quot;);
1762       node_flags_set = true;
1763     }
1764 
1765     // Is an instruction is a constant?  If so, get its type
1766     Form::DataType  data_type;
1767     const char     *opType = NULL;
1768     const char     *result = NULL;
1769     data_type    = instr-&gt;is_chain_of_constant(_globalNames, opType, result);
1770     // Check if this instruction is a constant
1771     if ( data_type != Form::none ) {
1772       if ( node_flags_set ) {
1773         fprintf(fp,&quot; | Flag_is_Con&quot;);
1774       } else {
1775         fprintf(fp,&quot;init_flags(Flag_is_Con&quot;);
1776         node_flags_set = true;
1777       }
1778     }
1779 
1780     // flag: if this instruction is cisc alternate
1781     if ( can_cisc_spill() &amp;&amp; instr-&gt;is_cisc_alternate() ) {
1782       if ( node_flags_set ) {
1783         fprintf(fp,&quot; | Flag_is_cisc_alternate&quot;);
1784       } else {
1785         fprintf(fp,&quot;init_flags(Flag_is_cisc_alternate&quot;);
1786         node_flags_set = true;
1787       }
1788     }
1789 
1790     // flag: if this instruction has short branch form
1791     if ( instr-&gt;has_short_branch_form() ) {
1792       if ( node_flags_set ) {
1793         fprintf(fp,&quot; | Flag_may_be_short_branch&quot;);
1794       } else {
1795         fprintf(fp,&quot;init_flags(Flag_may_be_short_branch&quot;);
1796         node_flags_set = true;
1797       }
1798     }
1799 
1800     // flag: if this instruction should not be generated back to back.
1801     if (avoid_back_to_back_attr != NULL) {
1802       if (node_flags_set) {
1803         fprintf(fp,&quot; | (%s)&quot;, avoid_back_to_back_attr-&gt;_val);
1804       } else {
1805         fprintf(fp,&quot;init_flags((%s)&quot;, avoid_back_to_back_attr-&gt;_val);
1806         node_flags_set = true;
1807       }
1808     }
1809 
1810     // Check if machine instructions that USE memory, but do not DEF memory,
1811     // depend upon a node that defines memory in machine-independent graph.
1812     if ( instr-&gt;needs_anti_dependence_check(_globalNames) ) {
1813       if ( node_flags_set ) {
1814         fprintf(fp,&quot; | Flag_needs_anti_dependence_check&quot;);
1815       } else {
1816         fprintf(fp,&quot;init_flags(Flag_needs_anti_dependence_check&quot;);
1817         node_flags_set = true;
1818       }
1819     }
1820 
1821     // flag: if this instruction is implemented with a call
1822     if ( instr-&gt;_has_call ) {
1823       if ( node_flags_set ) {
1824         fprintf(fp,&quot; | Flag_has_call&quot;);
1825       } else {
1826         fprintf(fp,&quot;init_flags(Flag_has_call&quot;);
1827         node_flags_set = true;
1828       }
1829     }
1830 
1831     if ( node_flags_set ) {
1832       fprintf(fp,&quot;); &quot;);
1833     }
1834 
1835     fprintf(fp,&quot;}\n&quot;);
1836 
1837     // size_of, used by base class&#39;s clone to obtain the correct size.
1838     fprintf(fp,&quot;  virtual uint           size_of() const {&quot;);
1839     fprintf(fp,   &quot; return sizeof(%sNode);&quot;, instr-&gt;_ident);
1840     fprintf(fp, &quot; }\n&quot;);
1841 
1842     // Virtual methods which are only generated to override base class
1843     if( instr-&gt;expands() || instr-&gt;needs_projections() ||
1844         instr-&gt;has_temps() ||
1845         instr-&gt;is_mach_constant() ||
1846         instr-&gt;needs_constant_base() ||
1847         (instr-&gt;_matrule != NULL &amp;&amp;
1848          instr-&gt;num_opnds() != instr-&gt;num_unique_opnds()) ) {
1849       fprintf(fp,&quot;  virtual MachNode      *Expand(State *state, Node_List &amp;proj_list, Node* mem);\n&quot;);
1850     }
1851 
1852     if (instr-&gt;is_pinned(_globalNames)) {
1853       fprintf(fp,&quot;  virtual bool           pinned() const { return &quot;);
1854       if (instr-&gt;is_parm(_globalNames)) {
1855         fprintf(fp,&quot;_in[0]-&gt;pinned();&quot;);
1856       } else {
1857         fprintf(fp,&quot;true;&quot;);
1858       }
1859       fprintf(fp,&quot; }\n&quot;);
1860     }
1861     if (instr-&gt;is_projection(_globalNames)) {
1862       fprintf(fp,&quot;  virtual const Node *is_block_proj() const { return this; }\n&quot;);
1863     }
1864     if ( instr-&gt;num_post_match_opnds() != 0
1865          || instr-&gt;is_chain_of_constant(_globalNames) ) {
1866       fprintf(fp,&quot;  friend MachNode *State::MachNodeGenerator(int opcode);\n&quot;);
1867     }
1868     if ( instr-&gt;rematerialize(_globalNames, get_registers()) ) {
1869       fprintf(fp,&quot;  // Rematerialize %s\n&quot;, instr-&gt;_ident);
1870     }
1871 
1872     // Declare short branch methods, if applicable
1873     instr-&gt;declare_short_branch_methods(fp);
1874 
1875     // See if there is an &quot;ins_pipe&quot; declaration for this instruction
1876     if (instr-&gt;_ins_pipe) {
1877       fprintf(fp,&quot;  static  const Pipeline *pipeline_class();\n&quot;);
1878       fprintf(fp,&quot;  virtual const Pipeline *pipeline() const;\n&quot;);
1879     }
1880 
1881     // Generate virtual function for MachNodeX::bottom_type when necessary
1882     //
1883     // Note on accuracy:  Pointer-types of machine nodes need to be accurate,
1884     // or else alias analysis on the matched graph may produce bad code.
1885     // Moreover, the aliasing decisions made on machine-node graph must be
1886     // no less accurate than those made on the ideal graph, or else the graph
1887     // may fail to schedule.  (Reason:  Memory ops which are reordered in
1888     // the ideal graph might look interdependent in the machine graph,
1889     // thereby removing degrees of scheduling freedom that the optimizer
1890     // assumed would be available.)
1891     //
1892     // %%% We should handle many of these cases with an explicit ADL clause:
1893     // instruct foo() %{ ... bottom_type(TypeRawPtr::BOTTOM); ... %}
1894     if( data_type != Form::none ) {
1895       // A constant&#39;s bottom_type returns a Type containing its constant value
1896 
1897       // !!!!!
1898       // Convert all ints, floats, ... to machine-independent TypeXs
1899       // as is done for pointers
1900       //
1901       // Construct appropriate constant type containing the constant value.
1902       fprintf(fp,&quot;  virtual const class Type *bottom_type() const {\n&quot;);
1903       switch( data_type ) {
1904       case Form::idealI:
1905         fprintf(fp,&quot;    return  TypeInt::make(opnd_array(1)-&gt;constant());\n&quot;);
1906         break;
1907       case Form::idealP:
1908       case Form::idealN:
1909       case Form::idealNKlass:
1910         fprintf(fp,&quot;    return  opnd_array(1)-&gt;type();\n&quot;);
1911         break;
1912       case Form::idealD:
1913         fprintf(fp,&quot;    return  TypeD::make(opnd_array(1)-&gt;constantD());\n&quot;);
1914         break;
1915       case Form::idealF:
1916         fprintf(fp,&quot;    return  TypeF::make(opnd_array(1)-&gt;constantF());\n&quot;);
1917         break;
1918       case Form::idealL:
1919         fprintf(fp,&quot;    return  TypeLong::make(opnd_array(1)-&gt;constantL());\n&quot;);
1920         break;
1921       default:
1922         assert( false, &quot;Unimplemented()&quot; );
1923         break;
1924       }
1925       fprintf(fp,&quot;  };\n&quot;);
1926     }
1927 /*    else if ( instr-&gt;_matrule &amp;&amp; instr-&gt;_matrule-&gt;_rChild &amp;&amp;
1928         (  strcmp(&quot;ConvF2I&quot;,instr-&gt;_matrule-&gt;_rChild-&gt;_opType)==0
1929         || strcmp(&quot;ConvD2I&quot;,instr-&gt;_matrule-&gt;_rChild-&gt;_opType)==0 ) ) {
1930       // !!!!! !!!!!
1931       // Provide explicit bottom type for conversions to int
1932       // On Intel the result operand is a stackSlot, untyped.
1933       fprintf(fp,&quot;  virtual const class Type *bottom_type() const {&quot;);
1934       fprintf(fp,   &quot; return  TypeInt::INT;&quot;);
1935       fprintf(fp, &quot; };\n&quot;);
1936     }*/
1937     else if( instr-&gt;is_ideal_copy() &amp;&amp;
1938               !strcmp(instr-&gt;_matrule-&gt;_lChild-&gt;_opType,&quot;stackSlotP&quot;) ) {
1939       // !!!!!
1940       // Special hack for ideal Copy of pointer.  Bottom type is oop or not depending on input.
1941       fprintf(fp,&quot;  const Type            *bottom_type() const { return in(1)-&gt;bottom_type(); } // Copy?\n&quot;);
1942     }
1943     else if( instr-&gt;is_ideal_loadPC() ) {
1944       // LoadPCNode provides the return address of a call to native code.
1945       // Define its bottom type to be TypeRawPtr::BOTTOM instead of TypePtr::BOTTOM
1946       // since it is a pointer to an internal VM location and must have a zero offset.
1947       // Allocation detects derived pointers, in part, by their non-zero offsets.
1948       fprintf(fp,&quot;  const Type            *bottom_type() const { return TypeRawPtr::BOTTOM; } // LoadPC?\n&quot;);
1949     }
1950     else if( instr-&gt;is_ideal_box() ) {
1951       // BoxNode provides the address of a stack slot.
1952       // Define its bottom type to be TypeRawPtr::BOTTOM instead of TypePtr::BOTTOM
1953       // This prevent s insert_anti_dependencies from complaining. It will
1954       // complain if it sees that the pointer base is TypePtr::BOTTOM since
1955       // it doesn&#39;t understand what that might alias.
1956       fprintf(fp,&quot;  const Type            *bottom_type() const { return TypeRawPtr::BOTTOM; } // Box?\n&quot;);
1957     }
1958     else if( instr-&gt;_matrule &amp;&amp; instr-&gt;_matrule-&gt;_rChild &amp;&amp; !strcmp(instr-&gt;_matrule-&gt;_rChild-&gt;_opType,&quot;CMoveP&quot;) ) {
1959       int offset = 1;
1960       // Special special hack to see if the Cmp? has been incorporated in the conditional move
1961       MatchNode *rl = instr-&gt;_matrule-&gt;_rChild-&gt;_lChild;
1962       if( rl &amp;&amp; !strcmp(rl-&gt;_opType, &quot;Binary&quot;) ) {
1963           MatchNode *rlr = rl-&gt;_rChild;
1964           if (rlr &amp;&amp; strncmp(rlr-&gt;_opType, &quot;Cmp&quot;, 3) == 0)
1965             offset = 2;
1966       }
1967       // Special hack for ideal CMoveP; ideal type depends on inputs
1968       fprintf(fp,&quot;  const Type            *bottom_type() const { const Type *t = in(oper_input_base()+%d)-&gt;bottom_type(); return (req() &lt;= oper_input_base()+%d) ? t : t-&gt;meet(in(oper_input_base()+%d)-&gt;bottom_type()); } // CMoveP\n&quot;,
1969         offset, offset+1, offset+1);
1970     }
1971     else if( instr-&gt;_matrule &amp;&amp; instr-&gt;_matrule-&gt;_rChild &amp;&amp; !strcmp(instr-&gt;_matrule-&gt;_rChild-&gt;_opType,&quot;CMoveN&quot;) ) {
1972       int offset = 1;
1973       // Special special hack to see if the Cmp? has been incorporated in the conditional move
1974       MatchNode *rl = instr-&gt;_matrule-&gt;_rChild-&gt;_lChild;
1975       if( rl &amp;&amp; !strcmp(rl-&gt;_opType, &quot;Binary&quot;) ) {
1976           MatchNode *rlr = rl-&gt;_rChild;
1977           if (rlr &amp;&amp; strncmp(rlr-&gt;_opType, &quot;Cmp&quot;, 3) == 0)
1978             offset = 2;
1979       }
1980       // Special hack for ideal CMoveN; ideal type depends on inputs
1981       fprintf(fp,&quot;  const Type            *bottom_type() const { const Type *t = in(oper_input_base()+%d)-&gt;bottom_type(); return (req() &lt;= oper_input_base()+%d) ? t : t-&gt;meet(in(oper_input_base()+%d)-&gt;bottom_type()); } // CMoveN\n&quot;,
1982         offset, offset+1, offset+1);
1983     }
1984     else if (instr-&gt;is_tls_instruction()) {
1985       // Special hack for tlsLoadP
1986       fprintf(fp,&quot;  const Type            *bottom_type() const { return TypeRawPtr::BOTTOM; } // tlsLoadP\n&quot;);
1987     }
1988     else if ( instr-&gt;is_ideal_if() ) {
1989       fprintf(fp,&quot;  const Type            *bottom_type() const { return TypeTuple::IFBOTH; } // matched IfNode\n&quot;);
1990     }
1991     else if ( instr-&gt;is_ideal_membar() ) {
1992       fprintf(fp,&quot;  const Type            *bottom_type() const { return TypeTuple::MEMBAR; } // matched MemBar\n&quot;);
1993     }
1994 
1995     // Check where &#39;ideal_type&#39; must be customized
1996     /*
1997     if ( instr-&gt;_matrule &amp;&amp; instr-&gt;_matrule-&gt;_rChild &amp;&amp;
1998         (  strcmp(&quot;ConvF2I&quot;,instr-&gt;_matrule-&gt;_rChild-&gt;_opType)==0
1999         || strcmp(&quot;ConvD2I&quot;,instr-&gt;_matrule-&gt;_rChild-&gt;_opType)==0 ) ) {
2000       fprintf(fp,&quot;  virtual uint           ideal_reg() const { return Compile::current()-&gt;matcher()-&gt;base2reg[Type::Int]; }\n&quot;);
2001     }*/
2002 
2003     // Analyze machine instructions that either USE or DEF memory.
2004     int memory_operand = instr-&gt;memory_operand(_globalNames);
2005     if ( memory_operand != InstructForm::NO_MEMORY_OPERAND ) {
2006       if( memory_operand == InstructForm::MANY_MEMORY_OPERANDS ) {
2007         fprintf(fp,&quot;  virtual const TypePtr *adr_type() const;\n&quot;);
2008       }
2009       fprintf(fp,&quot;  virtual const MachOper *memory_operand() const;\n&quot;);
2010     }
2011 
2012     fprintf(fp, &quot;#ifndef PRODUCT\n&quot;);
2013 
2014     // virtual function for generating the user&#39;s assembler output
2015     gen_inst_format(fp, _globalNames,*instr);
2016 
2017     // Machine independent print functionality for debugging
2018     fprintf(fp,&quot;  virtual const char    *Name() const { return \&quot;%s\&quot;;}\n&quot;,
2019             instr-&gt;_ident);
2020 
2021     fprintf(fp, &quot;#endif\n&quot;);
2022 
2023     // Close definition of this XxxMachNode
2024     fprintf(fp,&quot;};\n&quot;);
2025   };
2026 
2027 }
2028 
2029 void ArchDesc::defineStateClass(FILE *fp) {
2030   static const char *state__valid    = &quot;_valid[((uint)index) &gt;&gt; 5] &amp;  (0x1 &lt;&lt; (((uint)index) &amp; 0x0001F))&quot;;
2031   static const char *state__set_valid= &quot;_valid[((uint)index) &gt;&gt; 5] |= (0x1 &lt;&lt; (((uint)index) &amp; 0x0001F))&quot;;
2032 
2033   fprintf(fp,&quot;\n&quot;);
2034   fprintf(fp,&quot;// MACROS to inline and constant fold State::valid(index)...\n&quot;);
2035   fprintf(fp,&quot;// when given a constant &#39;index&#39; in dfa_&lt;arch&gt;.cpp\n&quot;);
2036   fprintf(fp,&quot;//   uint word   = index &gt;&gt; 5;       // Shift out bit position\n&quot;);
2037   fprintf(fp,&quot;//   uint bitpos = index &amp; 0x0001F;  // Mask off word bits\n&quot;);
2038   fprintf(fp,&quot;#define STATE__VALID(index) &quot;);
2039   fprintf(fp,&quot;    (%s)\n&quot;, state__valid);
2040   fprintf(fp,&quot;\n&quot;);
2041   fprintf(fp,&quot;#define STATE__NOT_YET_VALID(index) &quot;);
2042   fprintf(fp,&quot;  ( (%s) == 0 )\n&quot;, state__valid);
2043   fprintf(fp,&quot;\n&quot;);
2044   fprintf(fp,&quot;#define STATE__VALID_CHILD(state,index) &quot;);
2045   fprintf(fp,&quot;  ( state &amp;&amp; (state-&gt;%s) )\n&quot;, state__valid);
2046   fprintf(fp,&quot;\n&quot;);
2047   fprintf(fp,&quot;#define STATE__SET_VALID(index) &quot;);
2048   fprintf(fp,&quot;  (%s)\n&quot;, state__set_valid);
2049   fprintf(fp,&quot;\n&quot;);
2050   fprintf(fp,
2051           &quot;//---------------------------State-------------------------------------------\n&quot;);
2052   fprintf(fp,&quot;// State contains an integral cost vector, indexed by machine operand opcodes,\n&quot;);
2053   fprintf(fp,&quot;// a rule vector consisting of machine operand/instruction opcodes, and also\n&quot;);
2054   fprintf(fp,&quot;// indexed by machine operand opcodes, pointers to the children in the label\n&quot;);
2055   fprintf(fp,&quot;// tree generated by the Label routines in ideal nodes (currently limited to\n&quot;);
2056   fprintf(fp,&quot;// two for convenience, but this could change).\n&quot;);
2057   fprintf(fp,&quot;class State : public ResourceObj {\n&quot;);
2058   fprintf(fp,&quot;public:\n&quot;);
2059   fprintf(fp,&quot;  int    _id;         // State identifier\n&quot;);
2060   fprintf(fp,&quot;  Node  *_leaf;       // Ideal (non-machine-node) leaf of match tree\n&quot;);
2061   fprintf(fp,&quot;  State *_kids[2];       // Children of state node in label tree\n&quot;);
2062   fprintf(fp,&quot;  unsigned int _cost[_LAST_MACH_OPER];  // Cost vector, indexed by operand opcodes\n&quot;);
2063   fprintf(fp,&quot;  unsigned int _rule[_LAST_MACH_OPER];  // Rule vector, indexed by operand opcodes\n&quot;);
2064   fprintf(fp,&quot;  unsigned int _valid[(_LAST_MACH_OPER/32)+1]; // Bit Map of valid Cost/Rule entries\n&quot;);
2065   fprintf(fp,&quot;\n&quot;);
2066   fprintf(fp,&quot;  State(void);                      // Constructor\n&quot;);
2067   fprintf(fp,&quot;  DEBUG_ONLY( ~State(void); )       // Destructor\n&quot;);
2068   fprintf(fp,&quot;\n&quot;);
2069   fprintf(fp,&quot;  // Methods created by ADLC and invoked by Reduce\n&quot;);
2070   fprintf(fp,&quot;  MachOper *MachOperGenerator(int opcode);\n&quot;);
2071   fprintf(fp,&quot;  MachNode *MachNodeGenerator(int opcode);\n&quot;);
2072   fprintf(fp,&quot;\n&quot;);
2073   fprintf(fp,&quot;  // Assign a state to a node, definition of method produced by ADLC\n&quot;);
2074   fprintf(fp,&quot;  bool DFA( int opcode, const Node *ideal );\n&quot;);
2075   fprintf(fp,&quot;\n&quot;);
2076   fprintf(fp,&quot;  // Access function for _valid bit vector\n&quot;);
2077   fprintf(fp,&quot;  bool valid(uint index) {\n&quot;);
2078   fprintf(fp,&quot;    return( STATE__VALID(index) != 0 );\n&quot;);
2079   fprintf(fp,&quot;  }\n&quot;);
2080   fprintf(fp,&quot;\n&quot;);
2081   fprintf(fp,&quot;  // Set function for _valid bit vector\n&quot;);
2082   fprintf(fp,&quot;  void set_valid(uint index) {\n&quot;);
2083   fprintf(fp,&quot;    STATE__SET_VALID(index);\n&quot;);
2084   fprintf(fp,&quot;  }\n&quot;);
2085   fprintf(fp,&quot;\n&quot;);
2086   fprintf(fp,&quot;#ifndef PRODUCT\n&quot;);
2087   fprintf(fp,&quot;  void dump();                // Debugging prints\n&quot;);
2088   fprintf(fp,&quot;  void dump(int depth);\n&quot;);
2089   fprintf(fp,&quot;#endif\n&quot;);
2090   if (_dfa_small) {
2091     // Generate the routine name we&#39;ll need
2092     for (int i = 1; i &lt; _last_opcode; i++) {
2093       if (_mlistab[i] == NULL) continue;
2094       fprintf(fp, &quot;  void  _sub_Op_%s(const Node *n);\n&quot;, NodeClassNames[i]);
2095     }
2096   }
2097   fprintf(fp,&quot;};\n&quot;);
2098   fprintf(fp,&quot;\n&quot;);
2099   fprintf(fp,&quot;\n&quot;);
2100 
2101 }
2102 
2103 
2104 //---------------------------buildMachOperEnum---------------------------------
2105 // Build enumeration for densely packed operands.
2106 // This enumeration is used to index into the arrays in the State objects
2107 // that indicate cost and a successfull rule match.
2108 
2109 // Information needed to generate the ReduceOp mapping for the DFA
2110 class OutputMachOperands : public OutputMap {
2111 public:
2112   OutputMachOperands(FILE *hpp, FILE *cpp, FormDict &amp;globals, ArchDesc &amp;AD)
2113     : OutputMap(hpp, cpp, globals, AD, &quot;MachOperands&quot;) {};
2114 
2115   void declaration() { }
2116   void definition()  { fprintf(_cpp, &quot;enum MachOperands {\n&quot;); }
2117   void closing()     { fprintf(_cpp, &quot;  _LAST_MACH_OPER\n&quot;);
2118                        OutputMap::closing();
2119   }
2120   void map(OpClassForm &amp;opc)  {
2121     const char* opc_ident_to_upper = _AD.machOperEnum(opc._ident);
2122     fprintf(_cpp, &quot;  %s&quot;, opc_ident_to_upper);
2123     delete[] opc_ident_to_upper;
2124   }
2125   void map(OperandForm &amp;oper) {
2126     const char* oper_ident_to_upper = _AD.machOperEnum(oper._ident);
2127     fprintf(_cpp, &quot;  %s&quot;, oper_ident_to_upper);
2128     delete[] oper_ident_to_upper;
2129   }
2130   void map(char *name) {
2131     const char* name_to_upper = _AD.machOperEnum(name);
2132     fprintf(_cpp, &quot;  %s&quot;, name_to_upper);
2133     delete[] name_to_upper;
2134   }
2135 
2136   bool do_instructions()      { return false; }
2137   void map(InstructForm &amp;inst){ assert( false, &quot;ShouldNotCallThis()&quot;); }
2138 };
2139 
2140 
2141 void ArchDesc::buildMachOperEnum(FILE *fp_hpp) {
2142   // Construct the table for MachOpcodes
2143   OutputMachOperands output_mach_operands(fp_hpp, fp_hpp, _globalNames, *this);
2144   build_map(output_mach_operands);
2145 }
2146 
2147 
2148 //---------------------------buildMachEnum----------------------------------
2149 // Build enumeration for all MachOpers and all MachNodes
2150 
2151 // Information needed to generate the ReduceOp mapping for the DFA
2152 class OutputMachOpcodes : public OutputMap {
2153   int begin_inst_chain_rule;
2154   int end_inst_chain_rule;
2155   int begin_rematerialize;
2156   int end_rematerialize;
2157   int end_instructions;
2158 public:
2159   OutputMachOpcodes(FILE *hpp, FILE *cpp, FormDict &amp;globals, ArchDesc &amp;AD)
2160     : OutputMap(hpp, cpp, globals, AD, &quot;MachOpcodes&quot;),
2161       begin_inst_chain_rule(-1), end_inst_chain_rule(-1), end_instructions(-1)
2162   {};
2163 
2164   void declaration() { }
2165   void definition()  { fprintf(_cpp, &quot;enum MachOpcodes {\n&quot;); }
2166   void closing()     {
2167     if( begin_inst_chain_rule != -1 )
2168       fprintf(_cpp, &quot;  _BEGIN_INST_CHAIN_RULE = %d,\n&quot;, begin_inst_chain_rule);
2169     if( end_inst_chain_rule   != -1 )
2170       fprintf(_cpp, &quot;  _END_INST_CHAIN_RULE  = %d,\n&quot;, end_inst_chain_rule);
2171     if( begin_rematerialize   != -1 )
2172       fprintf(_cpp, &quot;  _BEGIN_REMATERIALIZE   = %d,\n&quot;, begin_rematerialize);
2173     if( end_rematerialize     != -1 )
2174       fprintf(_cpp, &quot;  _END_REMATERIALIZE    = %d,\n&quot;, end_rematerialize);
2175     // always execute since do_instructions() is true, and avoids trailing comma
2176     fprintf(_cpp, &quot;  _last_Mach_Node  = %d \n&quot;,  end_instructions);
2177     OutputMap::closing();
2178   }
2179   void map(OpClassForm &amp;opc)  { fprintf(_cpp, &quot;  %s_rule&quot;, opc._ident ); }
2180   void map(OperandForm &amp;oper) { fprintf(_cpp, &quot;  %s_rule&quot;, oper._ident ); }
2181   void map(char        *name) { if (name) fprintf(_cpp, &quot;  %s_rule&quot;, name);
2182                                 else      fprintf(_cpp, &quot;  0&quot;); }
2183   void map(InstructForm &amp;inst) {fprintf(_cpp, &quot;  %s_rule&quot;, inst._ident ); }
2184 
2185   void record_position(OutputMap::position place, int idx ) {
2186     switch(place) {
2187     case OutputMap::BEGIN_INST_CHAIN_RULES :
2188       begin_inst_chain_rule = idx;
2189       break;
2190     case OutputMap::END_INST_CHAIN_RULES :
2191       end_inst_chain_rule   = idx;
2192       break;
2193     case OutputMap::BEGIN_REMATERIALIZE :
2194       begin_rematerialize   = idx;
2195       break;
2196     case OutputMap::END_REMATERIALIZE :
2197       end_rematerialize     = idx;
2198       break;
2199     case OutputMap::END_INSTRUCTIONS :
2200       end_instructions      = idx;
2201       break;
2202     default:
2203       break;
2204     }
2205   }
2206 };
2207 
2208 
2209 void ArchDesc::buildMachOpcodesEnum(FILE *fp_hpp) {
2210   // Construct the table for MachOpcodes
2211   OutputMachOpcodes output_mach_opcodes(fp_hpp, fp_hpp, _globalNames, *this);
2212   build_map(output_mach_opcodes);
2213 }
2214 
2215 
2216 // Generate an enumeration of the pipeline states, and both
2217 // the functional units (resources) and the masks for
2218 // specifying resources
2219 void ArchDesc::build_pipeline_enums(FILE *fp_hpp) {
2220   int stagelen = (int)strlen(&quot;undefined&quot;);
2221   int stagenum = 0;
2222 
2223   if (_pipeline) {              // Find max enum string length
2224     const char *stage;
2225     for ( _pipeline-&gt;_stages.reset(); (stage = _pipeline-&gt;_stages.iter()) != NULL; ) {
2226       int len = (int)strlen(stage);
2227       if (stagelen &lt; len) stagelen = len;
2228     }
2229   }
2230 
2231   // Generate a list of stages
2232   fprintf(fp_hpp, &quot;\n&quot;);
2233   fprintf(fp_hpp, &quot;// Pipeline Stages\n&quot;);
2234   fprintf(fp_hpp, &quot;enum machPipelineStages {\n&quot;);
2235   fprintf(fp_hpp, &quot;   stage_%-*s = 0,\n&quot;, stagelen, &quot;undefined&quot;);
2236 
2237   if( _pipeline ) {
2238     const char *stage;
2239     for ( _pipeline-&gt;_stages.reset(); (stage = _pipeline-&gt;_stages.iter()) != NULL; )
2240       fprintf(fp_hpp, &quot;   stage_%-*s = %d,\n&quot;, stagelen, stage, ++stagenum);
2241   }
2242 
2243   fprintf(fp_hpp, &quot;   stage_%-*s = %d\n&quot;, stagelen, &quot;count&quot;, stagenum);
2244   fprintf(fp_hpp, &quot;};\n&quot;);
2245 
2246   fprintf(fp_hpp, &quot;\n&quot;);
2247   fprintf(fp_hpp, &quot;// Pipeline Resources\n&quot;);
2248   fprintf(fp_hpp, &quot;enum machPipelineResources {\n&quot;);
2249   int rescount = 0;
2250 
2251   if( _pipeline ) {
2252     const char *resource;
2253     int reslen = 0;
2254 
2255     // Generate a list of resources, and masks
2256     for ( _pipeline-&gt;_reslist.reset(); (resource = _pipeline-&gt;_reslist.iter()) != NULL; ) {
2257       int len = (int)strlen(resource);
2258       if (reslen &lt; len)
2259         reslen = len;
2260     }
2261 
2262     for ( _pipeline-&gt;_reslist.reset(); (resource = _pipeline-&gt;_reslist.iter()) != NULL; ) {
2263       const ResourceForm *resform = _pipeline-&gt;_resdict[resource]-&gt;is_resource();
2264       int mask = resform-&gt;mask();
2265       if ((mask &amp; (mask-1)) == 0)
2266         fprintf(fp_hpp, &quot;   resource_%-*s = %d,\n&quot;, reslen, resource, rescount++);
2267     }
2268     fprintf(fp_hpp, &quot;\n&quot;);
2269     for ( _pipeline-&gt;_reslist.reset(); (resource = _pipeline-&gt;_reslist.iter()) != NULL; ) {
2270       const ResourceForm *resform = _pipeline-&gt;_resdict[resource]-&gt;is_resource();
2271       fprintf(fp_hpp, &quot;   res_mask_%-*s = 0x%08x,\n&quot;, reslen, resource, resform-&gt;mask());
2272     }
2273     fprintf(fp_hpp, &quot;\n&quot;);
2274   }
2275   fprintf(fp_hpp, &quot;   resource_count = %d\n&quot;, rescount);
2276   fprintf(fp_hpp, &quot;};\n&quot;);
2277 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/adlc/formssel.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="formsopt.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="main.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/adlc/formssel.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -755,11 +755,10 @@</span>
    }
  
    return NO_MEMORY_OPERAND;
  }
  
<span class="udiff-line-removed">- </span>
  // This instruction captures the machine-independent bottom_type
  // Expected use is for pointer vs oop determination for LoadP
  bool InstructForm::captures_bottom_type(FormDict &amp;globals) const {
    if (_matrule &amp;&amp; _matrule-&gt;_rChild &amp;&amp;
        (!strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;CastPP&quot;)       ||  // new result type
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -772,15 +771,16 @@</span>
         !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;LoadNKlass&quot;)   ||
         !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;CreateEx&quot;)     ||  // type of exception
         !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;CheckCastPP&quot;)  ||
         !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;GetAndSetP&quot;)   ||
         !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;GetAndSetN&quot;)   ||
<span class="udiff-line-modified-removed">-        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;CompareAndExchangeP&quot;) ||</span>
<span class="udiff-line-removed">-        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;CompareAndExchangeN&quot;) ||</span>
<span class="udiff-line-modified-added">+ #if INCLUDE_SHENANDOAHGC</span>
         !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;ShenandoahCompareAndExchangeP&quot;) ||
         !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;ShenandoahCompareAndExchangeN&quot;) ||
<span class="udiff-line-modified-removed">-        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;ShenandoahReadBarrier&quot;)))  return true;</span>
<span class="udiff-line-modified-added">+ #endif</span>
<span class="udiff-line-added">+        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;CompareAndExchangeP&quot;) ||</span>
<span class="udiff-line-added">+        !strcmp(_matrule-&gt;_rChild-&gt;_opType,&quot;CompareAndExchangeN&quot;))) return true;</span>
    else if ( is_ideal_load() == Form::idealP )                return true;
    else if ( is_ideal_store() != Form::none  )                return true;
  
    if (needs_base_oop_edge(globals)) return true;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1506,11 +1506,11 @@</span>
    char buf[buflen], *s=buf;
    Dict names(cmpstr,hashstr,Form::arena);       // Map Names to counts
  
    MatchNode *mnode =
      strcmp(_matrule-&gt;_opType, &quot;Set&quot;) ? _matrule : _matrule-&gt;_rChild;
<span class="udiff-line-modified-removed">-   mnode-&gt;count_instr_names(names);</span>
<span class="udiff-line-modified-added">+   if (mnode != NULL) mnode-&gt;count_instr_names(names);</span>
  
    uint first = 1;
    // Start with the predicate supplied in the .ad file.
    if (_predicate) {
      if (first) first = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1719,30 +1719,29 @@</span>
  bool Opcode::print_opcode(FILE *fp, Opcode::opcode_type desired_opcode) {
    // Default values previously provided by MachNode::primary()...
    const char *description = NULL;
    const char *value       = NULL;
    // Check if user provided any opcode definitions
<span class="udiff-line-modified-removed">-   if( this != NULL ) {</span>
<span class="udiff-line-modified-removed">-     // Update &#39;value&#39; if user provided a definition in the instruction</span>
<span class="udiff-line-modified-removed">-     switch (desired_opcode) {</span>
<span class="udiff-line-modified-removed">-     case PRIMARY:</span>
<span class="udiff-line-modified-removed">-       description = &quot;primary()&quot;;</span>
<span class="udiff-line-modified-removed">-       if( _primary   != NULL)  { value = _primary;     }</span>
<span class="udiff-line-modified-removed">-       break;</span>
<span class="udiff-line-modified-removed">-     case SECONDARY:</span>
<span class="udiff-line-modified-removed">-       description = &quot;secondary()&quot;;</span>
<span class="udiff-line-modified-removed">-       if( _secondary != NULL ) { value = _secondary;   }</span>
<span class="udiff-line-modified-removed">-       break;</span>
<span class="udiff-line-modified-removed">-     case TERTIARY:</span>
<span class="udiff-line-modified-removed">-       description = &quot;tertiary()&quot;;</span>
<span class="udiff-line-modified-removed">-       if( _tertiary  != NULL ) { value = _tertiary;    }</span>
<span class="udiff-line-modified-removed">-       break;</span>
<span class="udiff-line-modified-removed">-     default:</span>
<span class="udiff-line-modified-removed">-       assert( false, &quot;ShouldNotReachHere();&quot;);</span>
<span class="udiff-line-removed">-       break;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+   // Update &#39;value&#39; if user provided a definition in the instruction</span>
<span class="udiff-line-modified-added">+   switch (desired_opcode) {</span>
<span class="udiff-line-modified-added">+   case PRIMARY:</span>
<span class="udiff-line-modified-added">+     description = &quot;primary()&quot;;</span>
<span class="udiff-line-modified-added">+     if( _primary   != NULL)  { value = _primary;     }</span>
<span class="udiff-line-modified-added">+     break;</span>
<span class="udiff-line-modified-added">+   case SECONDARY:</span>
<span class="udiff-line-modified-added">+     description = &quot;secondary()&quot;;</span>
<span class="udiff-line-modified-added">+     if( _secondary != NULL ) { value = _secondary;   }</span>
<span class="udiff-line-modified-added">+     break;</span>
<span class="udiff-line-modified-added">+   case TERTIARY:</span>
<span class="udiff-line-modified-added">+     description = &quot;tertiary()&quot;;</span>
<span class="udiff-line-modified-added">+     if( _tertiary  != NULL ) { value = _tertiary;    }</span>
<span class="udiff-line-modified-added">+     break;</span>
<span class="udiff-line-modified-added">+   default:</span>
<span class="udiff-line-modified-added">+     assert( false, &quot;ShouldNotReachHere();&quot;);</span>
<span class="udiff-line-modified-added">+     break;</span>
    }
<span class="udiff-line-added">+ </span>
    if (value != NULL) {
      fprintf(fp, &quot;(%s /*%s*/)&quot;, value, description);
    }
    return value != NULL;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3406,11 +3405,10 @@</span>
  
  //------------------------------count_instr_names------------------------------
  // Count occurrences of operands names in the leaves of the instruction
  // match rule.
  void MatchNode::count_instr_names( Dict &amp;names ) {
<span class="udiff-line-removed">-   if( this == NULL ) return;</span>
    if( _lChild ) _lChild-&gt;count_instr_names(names);
    if( _rChild ) _rChild-&gt;count_instr_names(names);
    if( !_lChild &amp;&amp; !_rChild ) {
      uintptr_t cnt = (uintptr_t)names[_name];
      cnt++;                      // One more name found
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3499,21 +3497,27 @@</span>
      &quot;LoadPLocked&quot;,
      &quot;StorePConditional&quot;, &quot;StoreIConditional&quot;, &quot;StoreLConditional&quot;,
      &quot;CompareAndSwapB&quot;, &quot;CompareAndSwapS&quot;, &quot;CompareAndSwapI&quot;, &quot;CompareAndSwapL&quot;, &quot;CompareAndSwapP&quot;, &quot;CompareAndSwapN&quot;,
      &quot;WeakCompareAndSwapB&quot;, &quot;WeakCompareAndSwapS&quot;, &quot;WeakCompareAndSwapI&quot;, &quot;WeakCompareAndSwapL&quot;, &quot;WeakCompareAndSwapP&quot;, &quot;WeakCompareAndSwapN&quot;,
      &quot;CompareAndExchangeB&quot;, &quot;CompareAndExchangeS&quot;, &quot;CompareAndExchangeI&quot;, &quot;CompareAndExchangeL&quot;, &quot;CompareAndExchangeP&quot;, &quot;CompareAndExchangeN&quot;,
<span class="udiff-line-added">+ #if INCLUDE_SHENANDOAHGC</span>
      &quot;ShenandoahCompareAndSwapN&quot;, &quot;ShenandoahCompareAndSwapP&quot;, &quot;ShenandoahWeakCompareAndSwapP&quot;, &quot;ShenandoahWeakCompareAndSwapN&quot;, &quot;ShenandoahCompareAndExchangeP&quot;, &quot;ShenandoahCompareAndExchangeN&quot;,
<span class="udiff-line-added">+ #endif</span>
      &quot;StoreCM&quot;,
<span class="udiff-line-removed">-     &quot;ClearArray&quot;,</span>
      &quot;GetAndSetB&quot;, &quot;GetAndSetS&quot;, &quot;GetAndAddI&quot;, &quot;GetAndSetI&quot;, &quot;GetAndSetP&quot;,
      &quot;GetAndAddB&quot;, &quot;GetAndAddS&quot;, &quot;GetAndAddL&quot;, &quot;GetAndSetL&quot;, &quot;GetAndSetN&quot;,
<span class="udiff-line-modified-removed">-     &quot;ShenandoahReadBarrier&quot;,</span>
<span class="udiff-line-removed">-     &quot;LoadBarrierSlowReg&quot;, &quot;LoadBarrierWeakSlowReg&quot;</span>
<span class="udiff-line-modified-added">+     &quot;ClearArray&quot;</span>
    };
    int cnt = sizeof(needs_ideal_memory_list)/sizeof(char*);
    if( strcmp(_opType,&quot;PrefetchAllocation&quot;)==0 )
      return 1;
<span class="udiff-line-added">+   if( strcmp(_opType,&quot;CacheWB&quot;)==0 )</span>
<span class="udiff-line-added">+     return 1;</span>
<span class="udiff-line-added">+   if( strcmp(_opType,&quot;CacheWBPreSync&quot;)==0 )</span>
<span class="udiff-line-added">+     return 1;</span>
<span class="udiff-line-added">+   if( strcmp(_opType,&quot;CacheWBPostSync&quot;)==0 )</span>
<span class="udiff-line-added">+     return 1;</span>
    if( _lChild ) {
      const char *opType = _lChild-&gt;_opType;
      for( int i=0; i&lt;cnt; i++ )
        if( strcmp(opType,needs_ideal_memory_list[i]) == 0 )
          return 1;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3802,11 +3806,11 @@</span>
      &quot;AndI&quot;,&quot;AndL&quot;,
      &quot;AndV&quot;,
      &quot;MaxI&quot;,&quot;MinI&quot;,&quot;MaxF&quot;,&quot;MinF&quot;,&quot;MaxD&quot;,&quot;MinD&quot;,
      &quot;MaxV&quot;, &quot;MinV&quot;,
      &quot;MulI&quot;,&quot;MulL&quot;,&quot;MulF&quot;,&quot;MulD&quot;,
<span class="udiff-line-modified-removed">-     &quot;MulVS&quot;,&quot;MulVI&quot;,&quot;MulVL&quot;,&quot;MulVF&quot;,&quot;MulVD&quot;,</span>
<span class="udiff-line-modified-added">+     &quot;MulVB&quot;,&quot;MulVS&quot;,&quot;MulVI&quot;,&quot;MulVL&quot;,&quot;MulVF&quot;,&quot;MulVD&quot;,</span>
      &quot;OrI&quot;,&quot;OrL&quot;,
      &quot;OrV&quot;,
      &quot;XorI&quot;,&quot;XorL&quot;,
      &quot;XorV&quot;
    };
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3993,44 +3997,17 @@</span>
    }
    return false;
  }
  
  int MatchRule::is_ideal_copy() const {
<span class="udiff-line-modified-removed">-   if( _rChild ) {</span>
<span class="udiff-line-modified-removed">-     const char  *opType = _rChild-&gt;_opType;</span>
<span class="udiff-line-removed">- #if 1</span>
<span class="udiff-line-removed">-     if( strcmp(opType,&quot;CastIP&quot;)==0 )</span>
<span class="udiff-line-removed">-       return 1;</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-     if( strcmp(opType,&quot;CastII&quot;)==0 )</span>
<span class="udiff-line-removed">-       return 1;</span>
<span class="udiff-line-removed">-     // Do not treat *CastPP this way, because it</span>
<span class="udiff-line-removed">-     // may transfer a raw pointer to an oop.</span>
<span class="udiff-line-removed">-     // If the register allocator were to coalesce this</span>
<span class="udiff-line-removed">-     // into a single LRG, the GC maps would be incorrect.</span>
<span class="udiff-line-removed">-     //if( strcmp(opType,&quot;CastPP&quot;)==0 )</span>
<span class="udiff-line-removed">-     //  return 1;</span>
<span class="udiff-line-removed">-     //if( strcmp(opType,&quot;CheckCastPP&quot;)==0 )</span>
<span class="udiff-line-removed">-     //  return 1;</span>
<span class="udiff-line-removed">-     //</span>
<span class="udiff-line-removed">-     // Do not treat CastX2P or CastP2X this way, because</span>
<span class="udiff-line-removed">-     // raw pointers and int types are treated differently</span>
<span class="udiff-line-removed">-     // when saving local &amp; stack info for safepoints in</span>
<span class="udiff-line-removed">-     // Output().</span>
<span class="udiff-line-removed">-     //if( strcmp(opType,&quot;CastX2P&quot;)==0 )</span>
<span class="udiff-line-removed">-     //  return 1;</span>
<span class="udiff-line-removed">-     //if( strcmp(opType,&quot;CastP2X&quot;)==0 )</span>
<span class="udiff-line-removed">-     //  return 1;</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   if( is_chain_rule(_AD.globalNames()) &amp;&amp;</span>
<span class="udiff-line-removed">-       _lChild &amp;&amp; strncmp(_lChild-&gt;_opType,&quot;stackSlot&quot;,9)==0 )</span>
<span class="udiff-line-modified-added">+   if (is_chain_rule(_AD.globalNames()) &amp;&amp;</span>
<span class="udiff-line-modified-added">+       _lChild &amp;&amp; strncmp(_lChild-&gt;_opType, &quot;stackSlot&quot;, 9) == 0) {</span>
      return 1;
<span class="udiff-line-added">+   }</span>
    return 0;
  }
  
<span class="udiff-line-removed">- </span>
  int MatchRule::is_expensive() const {
    if( _rChild ) {
      const char  *opType = _rChild-&gt;_opType;
      if( strcmp(opType,&quot;AtanD&quot;)==0 ||
          strcmp(opType,&quot;DivD&quot;)==0 ||
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4060,10 +4037,11 @@</span>
          strcmp(opType,&quot;EncodePKlass&quot;)==0 ||
          strcmp(opType,&quot;DecodeNKlass&quot;)==0 ||
          strcmp(opType,&quot;FmaD&quot;) == 0 ||
          strcmp(opType,&quot;FmaF&quot;) == 0 ||
          strcmp(opType,&quot;RoundDouble&quot;)==0 ||
<span class="udiff-line-added">+         strcmp(opType,&quot;RoundDoubleMode&quot;)==0 ||</span>
          strcmp(opType,&quot;RoundFloat&quot;)==0 ||
          strcmp(opType,&quot;ReverseBytesI&quot;)==0 ||
          strcmp(opType,&quot;ReverseBytesL&quot;)==0 ||
          strcmp(opType,&quot;ReverseBytesUS&quot;)==0 ||
          strcmp(opType,&quot;ReverseBytesS&quot;)==0 ||
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4169,14 +4147,14 @@</span>
  
  bool MatchRule::is_vector() const {
    static const char *vector_list[] = {
      &quot;AddVB&quot;,&quot;AddVS&quot;,&quot;AddVI&quot;,&quot;AddVL&quot;,&quot;AddVF&quot;,&quot;AddVD&quot;,
      &quot;SubVB&quot;,&quot;SubVS&quot;,&quot;SubVI&quot;,&quot;SubVL&quot;,&quot;SubVF&quot;,&quot;SubVD&quot;,
<span class="udiff-line-modified-removed">-     &quot;MulVS&quot;,&quot;MulVI&quot;,&quot;MulVL&quot;,&quot;MulVF&quot;,&quot;MulVD&quot;,</span>
<span class="udiff-line-modified-added">+     &quot;MulVB&quot;,&quot;MulVS&quot;,&quot;MulVI&quot;,&quot;MulVL&quot;,&quot;MulVF&quot;,&quot;MulVD&quot;,</span>
      &quot;CMoveVD&quot;, &quot;CMoveVF&quot;,
      &quot;DivVF&quot;,&quot;DivVD&quot;,
<span class="udiff-line-modified-removed">-     &quot;AbsVF&quot;,&quot;AbsVD&quot;,</span>
<span class="udiff-line-modified-added">+     &quot;AbsVB&quot;,&quot;AbsVS&quot;,&quot;AbsVI&quot;,&quot;AbsVL&quot;,&quot;AbsVF&quot;,&quot;AbsVD&quot;,</span>
      &quot;NegVF&quot;,&quot;NegVD&quot;,
      &quot;SqrtVD&quot;,&quot;SqrtVF&quot;,
      &quot;AndV&quot; ,&quot;XorV&quot; ,&quot;OrV&quot;,
      &quot;MaxV&quot;, &quot;MinV&quot;,
      &quot;AddReductionVI&quot;, &quot;AddReductionVL&quot;,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4188,11 +4166,11 @@</span>
      &quot;LShiftVB&quot;,&quot;LShiftVS&quot;,&quot;LShiftVI&quot;,&quot;LShiftVL&quot;,
      &quot;RShiftVB&quot;,&quot;RShiftVS&quot;,&quot;RShiftVI&quot;,&quot;RShiftVL&quot;,
      &quot;URShiftVB&quot;,&quot;URShiftVS&quot;,&quot;URShiftVI&quot;,&quot;URShiftVL&quot;,
      &quot;MaxReductionV&quot;, &quot;MinReductionV&quot;,
      &quot;ReplicateB&quot;,&quot;ReplicateS&quot;,&quot;ReplicateI&quot;,&quot;ReplicateL&quot;,&quot;ReplicateF&quot;,&quot;ReplicateD&quot;,
<span class="udiff-line-modified-removed">-     &quot;LoadVector&quot;,&quot;StoreVector&quot;,</span>
<span class="udiff-line-modified-added">+     &quot;RoundDoubleModeV&quot;,&quot;LoadVector&quot;,&quot;StoreVector&quot;,</span>
      &quot;FmaVD&quot;, &quot;FmaVF&quot;,&quot;PopCountVI&quot;,
      // Next are not supported currently.
      &quot;PackB&quot;,&quot;PackS&quot;,&quot;PackI&quot;,&quot;PackL&quot;,&quot;PackF&quot;,&quot;PackD&quot;,&quot;Pack2L&quot;,&quot;Pack2D&quot;,
      &quot;ExtractB&quot;,&quot;ExtractUB&quot;,&quot;ExtractC&quot;,&quot;ExtractS&quot;,&quot;ExtractI&quot;,&quot;ExtractL&quot;,&quot;ExtractF&quot;,&quot;ExtractD&quot;
    };
</pre>
<center><a href="formsopt.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="main.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
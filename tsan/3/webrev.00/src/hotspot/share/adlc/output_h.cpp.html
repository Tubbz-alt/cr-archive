<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/adlc/output_h.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1998, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 // output_h.cpp - Class HPP file output routines for architecture definition
  26 #include &quot;adlc.hpp&quot;
  27 
  28 // The comment delimiter used in format statements after assembler instructions.
  29 #if defined(PPC64)
  30 #define commentSeperator &quot;\t//&quot;
  31 #else
  32 #define commentSeperator &quot;!&quot;
  33 #endif
  34 
  35 // Generate the #define that describes the number of registers.
  36 static void defineRegCount(FILE *fp, RegisterForm *registers) {
  37   if (registers) {
  38     int regCount =  AdlcVMDeps::Physical + registers-&gt;_rdefs.count();
  39     fprintf(fp,&quot;\n&quot;);
  40     fprintf(fp,&quot;// the number of reserved registers + machine registers.\n&quot;);
  41     fprintf(fp,&quot;#define REG_COUNT    %d\n&quot;, regCount);
  42   }
  43 }
  44 
  45 // Output enumeration of machine register numbers
  46 // (1)
  47 // // Enumerate machine registers starting after reserved regs.
  48 // // in the order of occurrence in the register block.
  49 // enum MachRegisterNumbers {
  50 //   EAX_num = 0,
  51 //   ...
  52 //   _last_Mach_Reg
  53 // }
  54 void ArchDesc::buildMachRegisterNumbers(FILE *fp_hpp) {
  55   if (_register) {
  56     RegDef *reg_def = NULL;
  57 
  58     // Output a #define for the number of machine registers
  59     defineRegCount(fp_hpp, _register);
  60 
  61     // Count all the Save_On_Entry and Always_Save registers
  62     int    saved_on_entry = 0;
  63     int  c_saved_on_entry = 0;
  64     _register-&gt;reset_RegDefs();
  65     while( (reg_def = _register-&gt;iter_RegDefs()) != NULL ) {
  66       if( strcmp(reg_def-&gt;_callconv,&quot;SOE&quot;) == 0 ||
  67           strcmp(reg_def-&gt;_callconv,&quot;AS&quot;)  == 0 )  ++saved_on_entry;
  68       if( strcmp(reg_def-&gt;_c_conv,&quot;SOE&quot;) == 0 ||
  69           strcmp(reg_def-&gt;_c_conv,&quot;AS&quot;)  == 0 )  ++c_saved_on_entry;
  70     }
  71     fprintf(fp_hpp, &quot;\n&quot;);
  72     fprintf(fp_hpp, &quot;// the number of save_on_entry + always_saved registers.\n&quot;);
  73     fprintf(fp_hpp, &quot;#define MAX_SAVED_ON_ENTRY_REG_COUNT    %d\n&quot;,   max(saved_on_entry,c_saved_on_entry));
  74     fprintf(fp_hpp, &quot;#define     SAVED_ON_ENTRY_REG_COUNT    %d\n&quot;,   saved_on_entry);
  75     fprintf(fp_hpp, &quot;#define   C_SAVED_ON_ENTRY_REG_COUNT    %d\n&quot;, c_saved_on_entry);
  76 
  77     // (1)
  78     // Build definition for enumeration of register numbers
  79     fprintf(fp_hpp, &quot;\n&quot;);
  80     fprintf(fp_hpp, &quot;// Enumerate machine register numbers starting after reserved regs.\n&quot;);
  81     fprintf(fp_hpp, &quot;// in the order of occurrence in the register block.\n&quot;);
  82     fprintf(fp_hpp, &quot;enum MachRegisterNumbers {\n&quot;);
  83 
  84     // Output the register number for each register in the allocation classes
  85     _register-&gt;reset_RegDefs();
  86     int i = 0;
  87     while( (reg_def = _register-&gt;iter_RegDefs()) != NULL ) {
  88       fprintf(fp_hpp,&quot;  %s_num,&quot;, reg_def-&gt;_regname);
  89       for (int j = 0; j &lt; 20-(int)strlen(reg_def-&gt;_regname); j++) fprintf(fp_hpp, &quot; &quot;);
  90       fprintf(fp_hpp,&quot; // enum %3d, regnum %3d, reg encode %3s\n&quot;,
  91               i++,
  92               reg_def-&gt;register_num(),
  93               reg_def-&gt;register_encode());
  94     }
  95     // Finish defining enumeration
  96     fprintf(fp_hpp, &quot;  _last_Mach_Reg            // %d\n&quot;, i);
  97     fprintf(fp_hpp, &quot;};\n&quot;);
  98   }
  99 
 100   fprintf(fp_hpp, &quot;\n// Size of register-mask in ints\n&quot;);
 101   fprintf(fp_hpp, &quot;#define RM_SIZE %d\n&quot;,RegisterForm::RegMask_Size());
 102   fprintf(fp_hpp, &quot;// Unroll factor for loops over the data in a RegMask\n&quot;);
 103   fprintf(fp_hpp, &quot;#define FORALL_BODY &quot;);
 104   int len = RegisterForm::RegMask_Size();
 105   for( int i = 0; i &lt; len; i++ )
 106     fprintf(fp_hpp, &quot;BODY(%d) &quot;,i);
 107   fprintf(fp_hpp, &quot;\n\n&quot;);
 108 
 109   fprintf(fp_hpp,&quot;class RegMask;\n&quot;);
 110   // All RegMasks are declared &quot;extern const ...&quot; in ad_&lt;arch&gt;.hpp
 111   // fprintf(fp_hpp,&quot;extern RegMask STACK_OR_STACK_SLOTS_mask;\n\n&quot;);
 112 }
 113 
 114 
 115 // Output enumeration of machine register encodings
 116 // (2)
 117 // // Enumerate machine registers starting after reserved regs.
 118 // // in the order of occurrence in the alloc_class(es).
 119 // enum MachRegisterEncodes {
 120 //   EAX_enc = 0x00,
 121 //   ...
 122 // }
 123 void ArchDesc::buildMachRegisterEncodes(FILE *fp_hpp) {
 124   if (_register) {
 125     RegDef *reg_def = NULL;
 126     RegDef *reg_def_next = NULL;
 127 
 128     // (2)
 129     // Build definition for enumeration of encode values
 130     fprintf(fp_hpp, &quot;\n&quot;);
 131     fprintf(fp_hpp, &quot;// Enumerate machine registers starting after reserved regs.\n&quot;);
 132     fprintf(fp_hpp, &quot;// in the order of occurrence in the alloc_class(es).\n&quot;);
 133     fprintf(fp_hpp, &quot;enum MachRegisterEncodes {\n&quot;);
 134 
 135     // Find max enum string length.
 136     size_t maxlen = 0;
 137     _register-&gt;reset_RegDefs();
 138     reg_def = _register-&gt;iter_RegDefs();
 139     while (reg_def != NULL) {
 140       size_t len = strlen(reg_def-&gt;_regname);
 141       if (len &gt; maxlen) maxlen = len;
 142       reg_def = _register-&gt;iter_RegDefs();
 143     }
 144 
 145     // Output the register encoding for each register in the allocation classes
 146     _register-&gt;reset_RegDefs();
 147     reg_def_next = _register-&gt;iter_RegDefs();
 148     while( (reg_def = reg_def_next) != NULL ) {
 149       reg_def_next = _register-&gt;iter_RegDefs();
 150       fprintf(fp_hpp,&quot;  %s_enc&quot;, reg_def-&gt;_regname);
 151       for (size_t i = strlen(reg_def-&gt;_regname); i &lt; maxlen; i++) fprintf(fp_hpp, &quot; &quot;);
 152       fprintf(fp_hpp,&quot; = %3s%s\n&quot;, reg_def-&gt;register_encode(), reg_def_next == NULL? &quot;&quot; : &quot;,&quot; );
 153     }
 154     // Finish defining enumeration
 155     fprintf(fp_hpp, &quot;};\n&quot;);
 156 
 157   } // Done with register form
 158 }
 159 
 160 
 161 // Declare an array containing the machine register names, strings.
 162 static void declareRegNames(FILE *fp, RegisterForm *registers) {
 163   if (registers) {
 164 //    fprintf(fp,&quot;\n&quot;);
 165 //    fprintf(fp,&quot;// An array of character pointers to machine register names.\n&quot;);
 166 //    fprintf(fp,&quot;extern const char *regName[];\n&quot;);
 167   }
 168 }
 169 
 170 // Declare an array containing the machine register sizes in 32-bit words.
 171 void ArchDesc::declareRegSizes(FILE *fp) {
 172 // regSize[] is not used
 173 }
 174 
 175 // Declare an array containing the machine register encoding values
 176 static void declareRegEncodes(FILE *fp, RegisterForm *registers) {
 177   if (registers) {
 178     // // //
 179     // fprintf(fp,&quot;\n&quot;);
 180     // fprintf(fp,&quot;// An array containing the machine register encode values\n&quot;);
 181     // fprintf(fp,&quot;extern const char  regEncode[];\n&quot;);
 182   }
 183 }
 184 
 185 
 186 // ---------------------------------------------------------------------------
 187 //------------------------------Utilities to build Instruction Classes--------
 188 // ---------------------------------------------------------------------------
 189 static void out_RegMask(FILE *fp) {
 190   fprintf(fp,&quot;  virtual const RegMask &amp;out_RegMask() const;\n&quot;);
 191 }
 192 
 193 // ---------------------------------------------------------------------------
 194 //--------Utilities to build MachOper and MachNode derived Classes------------
 195 // ---------------------------------------------------------------------------
 196 
 197 //------------------------------Utilities to build Operand Classes------------
 198 static void in_RegMask(FILE *fp) {
 199   fprintf(fp,&quot;  virtual const RegMask *in_RegMask(int index) const;\n&quot;);
 200 }
 201 
 202 static void declareConstStorage(FILE *fp, FormDict &amp;globals, OperandForm *oper) {
 203   int i = 0;
 204   Component *comp;
 205 
 206   if (oper-&gt;num_consts(globals) == 0) return;
 207   // Iterate over the component list looking for constants
 208   oper-&gt;_components.reset();
 209   if ((comp = oper-&gt;_components.iter()) == NULL) {
 210     assert(oper-&gt;num_consts(globals) == 1, &quot;Bad component list detected.\n&quot;);
 211     const char *type = oper-&gt;ideal_type(globals);
 212     if (!strcmp(type, &quot;ConI&quot;)) {
 213       if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 214       fprintf(fp,&quot;  int32_t        _c%d;\n&quot;, i);
 215     }
 216     else if (!strcmp(type, &quot;ConP&quot;)) {
 217       if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 218       fprintf(fp,&quot;  const TypePtr *_c%d;\n&quot;, i);
 219     }
 220     else if (!strcmp(type, &quot;ConN&quot;)) {
 221       if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 222       fprintf(fp,&quot;  const TypeNarrowOop *_c%d;\n&quot;, i);
 223     }
 224     else if (!strcmp(type, &quot;ConNKlass&quot;)) {
 225       if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 226       fprintf(fp,&quot;  const TypeNarrowKlass *_c%d;\n&quot;, i);
 227     }
 228     else if (!strcmp(type, &quot;ConL&quot;)) {
 229       if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 230       fprintf(fp,&quot;  jlong          _c%d;\n&quot;, i);
 231     }
 232     else if (!strcmp(type, &quot;ConF&quot;)) {
 233       if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 234       fprintf(fp,&quot;  jfloat         _c%d;\n&quot;, i);
 235     }
 236     else if (!strcmp(type, &quot;ConD&quot;)) {
 237       if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 238       fprintf(fp,&quot;  jdouble        _c%d;\n&quot;, i);
 239     }
 240     else if (!strcmp(type, &quot;Bool&quot;)) {
 241       fprintf(fp,&quot;private:\n&quot;);
 242       fprintf(fp,&quot;  BoolTest::mask _c%d;\n&quot;, i);
 243       fprintf(fp,&quot;public:\n&quot;);
 244     }
 245     else {
 246       assert(0, &quot;Non-constant operand lacks component list.&quot;);
 247     }
 248   } // end if NULL
 249   else {
 250     oper-&gt;_components.reset();
 251     while ((comp = oper-&gt;_components.iter()) != NULL) {
 252       if (!strcmp(comp-&gt;base_type(globals), &quot;ConI&quot;)) {
 253         fprintf(fp,&quot;  jint             _c%d;\n&quot;, i);
 254         i++;
 255       }
 256       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConP&quot;)) {
 257         fprintf(fp,&quot;  const TypePtr *_c%d;\n&quot;, i);
 258         i++;
 259       }
 260       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConN&quot;)) {
 261         fprintf(fp,&quot;  const TypePtr *_c%d;\n&quot;, i);
 262         i++;
 263       }
 264       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConNKlass&quot;)) {
 265         fprintf(fp,&quot;  const TypePtr *_c%d;\n&quot;, i);
 266         i++;
 267       }
 268       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConL&quot;)) {
 269         fprintf(fp,&quot;  jlong            _c%d;\n&quot;, i);
 270         i++;
 271       }
 272       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConF&quot;)) {
 273         fprintf(fp,&quot;  jfloat           _c%d;\n&quot;, i);
 274         i++;
 275       }
 276       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConD&quot;)) {
 277         fprintf(fp,&quot;  jdouble          _c%d;\n&quot;, i);
 278         i++;
 279       }
 280     }
 281   }
 282 }
 283 
 284 // Declare constructor.
 285 // Parameters start with condition code, then all other constants
 286 //
 287 // (0) public:
 288 // (1)  MachXOper(int32 ccode, int32 c0, int32 c1, ..., int32 cn)
 289 // (2)     : _ccode(ccode), _c0(c0), _c1(c1), ..., _cn(cn) { }
 290 //
 291 static void defineConstructor(FILE *fp, const char *name, uint num_consts,
 292                               ComponentList &amp;lst, bool is_ideal_bool,
 293                               Form::DataType constant_type, FormDict &amp;globals) {
 294   fprintf(fp,&quot;public:\n&quot;);
 295   // generate line (1)
 296   fprintf(fp,&quot;  %sOper(&quot;, name);
 297   if( num_consts == 0 ) {
 298     fprintf(fp,&quot;) {}\n&quot;);
 299     return;
 300   }
 301 
 302   // generate parameters for constants
 303   uint i = 0;
 304   Component *comp;
 305   lst.reset();
 306   if ((comp = lst.iter()) == NULL) {
 307     assert(num_consts == 1, &quot;Bad component list detected.\n&quot;);
 308     switch( constant_type ) {
 309     case Form::idealI : {
 310       fprintf(fp,is_ideal_bool ? &quot;BoolTest::mask c%d&quot; : &quot;int32_t c%d&quot;, i);
 311       break;
 312     }
 313     case Form::idealN :      { fprintf(fp,&quot;const TypeNarrowOop *c%d&quot;, i); break; }
 314     case Form::idealNKlass : { fprintf(fp,&quot;const TypeNarrowKlass *c%d&quot;, i); break; }
 315     case Form::idealP :      { fprintf(fp,&quot;const TypePtr *c%d&quot;, i); break; }
 316     case Form::idealL :      { fprintf(fp,&quot;jlong c%d&quot;, i);   break;        }
 317     case Form::idealF :      { fprintf(fp,&quot;jfloat c%d&quot;, i);  break;        }
 318     case Form::idealD :      { fprintf(fp,&quot;jdouble c%d&quot;, i); break;        }
 319     default:
 320       assert(!is_ideal_bool, &quot;Non-constant operand lacks component list.&quot;);
 321       break;
 322     }
 323   } // end if NULL
 324   else {
 325     lst.reset();
 326     while((comp = lst.iter()) != NULL) {
 327       if (!strcmp(comp-&gt;base_type(globals), &quot;ConI&quot;)) {
 328         if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 329         fprintf(fp,&quot;int32_t c%d&quot;, i);
 330         i++;
 331       }
 332       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConP&quot;)) {
 333         if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 334         fprintf(fp,&quot;const TypePtr *c%d&quot;, i);
 335         i++;
 336       }
 337       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConN&quot;)) {
 338         if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 339         fprintf(fp,&quot;const TypePtr *c%d&quot;, i);
 340         i++;
 341       }
 342       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConNKlass&quot;)) {
 343         if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 344         fprintf(fp,&quot;const TypePtr *c%d&quot;, i);
 345         i++;
 346       }
 347       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConL&quot;)) {
 348         if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 349         fprintf(fp,&quot;jlong c%d&quot;, i);
 350         i++;
 351       }
 352       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConF&quot;)) {
 353         if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 354         fprintf(fp,&quot;jfloat c%d&quot;, i);
 355         i++;
 356       }
 357       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConD&quot;)) {
 358         if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 359         fprintf(fp,&quot;jdouble c%d&quot;, i);
 360         i++;
 361       }
 362       else if (!strcmp(comp-&gt;base_type(globals), &quot;Bool&quot;)) {
 363         if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 364         fprintf(fp,&quot;BoolTest::mask c%d&quot;, i);
 365         i++;
 366       }
 367     }
 368   }
 369   // finish line (1) and start line (2)
 370   fprintf(fp,&quot;)  : &quot;);
 371   // generate initializers for constants
 372   i = 0;
 373   fprintf(fp,&quot;_c%d(c%d)&quot;, i, i);
 374   for( i = 1; i &lt; num_consts; ++i) {
 375     fprintf(fp,&quot;, _c%d(c%d)&quot;, i, i);
 376   }
 377   // The body for the constructor is empty
 378   fprintf(fp,&quot; {}\n&quot;);
 379 }
 380 
 381 // ---------------------------------------------------------------------------
 382 // Utilities to generate format rules for machine operands and instructions
 383 // ---------------------------------------------------------------------------
 384 
 385 // Generate the format rule for condition codes
 386 static void defineCCodeDump(OperandForm* oper, FILE *fp, int i) {
 387   assert(oper != NULL, &quot;what&quot;);
 388   CondInterface* cond = oper-&gt;_interface-&gt;is_CondInterface();
 389   fprintf(fp, &quot;       if( _c%d == BoolTest::eq ) st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;,i,cond-&gt;_equal_format);
 390   fprintf(fp, &quot;  else if( _c%d == BoolTest::ne ) st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;,i,cond-&gt;_not_equal_format);
 391   fprintf(fp, &quot;  else if( _c%d == BoolTest::le ) st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;,i,cond-&gt;_less_equal_format);
 392   fprintf(fp, &quot;  else if( _c%d == BoolTest::ge ) st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;,i,cond-&gt;_greater_equal_format);
 393   fprintf(fp, &quot;  else if( _c%d == BoolTest::lt ) st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;,i,cond-&gt;_less_format);
 394   fprintf(fp, &quot;  else if( _c%d == BoolTest::gt ) st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;,i,cond-&gt;_greater_format);
 395   fprintf(fp, &quot;  else if( _c%d == BoolTest::overflow ) st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;,i,cond-&gt;_overflow_format);
 396   fprintf(fp, &quot;  else if( _c%d == BoolTest::no_overflow ) st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;,i,cond-&gt;_no_overflow_format);
 397 }
 398 
 399 // Output code that dumps constant values, increment &quot;i&quot; if type is constant
 400 static uint dump_spec_constant(FILE *fp, const char *ideal_type, uint i, OperandForm* oper) {
 401   if (!strcmp(ideal_type, &quot;ConI&quot;)) {
 402     fprintf(fp,&quot;   st-&gt;print(\&quot;#%%d\&quot;, _c%d);\n&quot;, i);
 403     fprintf(fp,&quot;   st-&gt;print(\&quot;/0x%%08x\&quot;, _c%d);\n&quot;, i);
 404     ++i;
 405   }
 406   else if (!strcmp(ideal_type, &quot;ConP&quot;)) {
 407     fprintf(fp,&quot;    _c%d-&gt;dump_on(st);\n&quot;, i);
 408     ++i;
 409   }
 410   else if (!strcmp(ideal_type, &quot;ConN&quot;)) {
 411     fprintf(fp,&quot;    _c%d-&gt;dump_on(st);\n&quot;, i);
 412     ++i;
 413   }
 414   else if (!strcmp(ideal_type, &quot;ConNKlass&quot;)) {
 415     fprintf(fp,&quot;    _c%d-&gt;dump_on(st);\n&quot;, i);
 416     ++i;
 417   }
 418   else if (!strcmp(ideal_type, &quot;ConL&quot;)) {
 419     fprintf(fp,&quot;    st-&gt;print(\&quot;#\&quot; INT64_FORMAT, (int64_t)_c%d);\n&quot;, i);
 420     fprintf(fp,&quot;    st-&gt;print(\&quot;/\&quot; PTR64_FORMAT, (uint64_t)_c%d);\n&quot;, i);
 421     ++i;
 422   }
 423   else if (!strcmp(ideal_type, &quot;ConF&quot;)) {
 424     fprintf(fp,&quot;    st-&gt;print(\&quot;#%%f\&quot;, _c%d);\n&quot;, i);
 425     fprintf(fp,&quot;    jint _c%di = JavaValue(_c%d).get_jint();\n&quot;, i, i);
 426     fprintf(fp,&quot;    st-&gt;print(\&quot;/0x%%x/\&quot;, _c%di);\n&quot;, i);
 427     ++i;
 428   }
 429   else if (!strcmp(ideal_type, &quot;ConD&quot;)) {
 430     fprintf(fp,&quot;    st-&gt;print(\&quot;#%%f\&quot;, _c%d);\n&quot;, i);
 431     fprintf(fp,&quot;    jlong _c%dl = JavaValue(_c%d).get_jlong();\n&quot;, i, i);
 432     fprintf(fp,&quot;    st-&gt;print(\&quot;/\&quot; PTR64_FORMAT, (uint64_t)_c%dl);\n&quot;, i);
 433     ++i;
 434   }
 435   else if (!strcmp(ideal_type, &quot;Bool&quot;)) {
 436     defineCCodeDump(oper, fp,i);
 437     ++i;
 438   }
 439 
 440   return i;
 441 }
 442 
 443 // Generate the format rule for an operand
 444 void gen_oper_format(FILE *fp, FormDict &amp;globals, OperandForm &amp;oper, bool for_c_file = false) {
 445   if (!for_c_file) {
 446     // invoked after output #ifndef PRODUCT to ad_&lt;arch&gt;.hpp
 447     // compile the bodies separately, to cut down on recompilations
 448     fprintf(fp,&quot;  virtual void           int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const;\n&quot;);
 449     fprintf(fp,&quot;  virtual void           ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const;\n&quot;);
 450     return;
 451   }
 452 
 453   // Local pointer indicates remaining part of format rule
 454   int idx = 0;                   // position of operand in match rule
 455 
 456   // Generate internal format function, used when stored locally
 457   fprintf(fp, &quot;\n#ifndef PRODUCT\n&quot;);
 458   fprintf(fp,&quot;void %sOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {\n&quot;, oper._ident);
 459   // Generate the user-defined portion of the format
 460   if (oper._format) {
 461     if ( oper._format-&gt;_strings.count() != 0 ) {
 462       // No initialization code for int_format
 463 
 464       // Build the format from the entries in strings and rep_vars
 465       const char  *string  = NULL;
 466       oper._format-&gt;_rep_vars.reset();
 467       oper._format-&gt;_strings.reset();
 468       while ( (string = oper._format-&gt;_strings.iter()) != NULL ) {
 469 
 470         // Check if this is a standard string or a replacement variable
 471         if ( string != NameList::_signal ) {
 472           // Normal string
 473           // Pass through to st-&gt;print
 474           fprintf(fp,&quot;  st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;, string);
 475         } else {
 476           // Replacement variable
 477           const char *rep_var = oper._format-&gt;_rep_vars.iter();
 478           // Check that it is a local name, and an operand
 479           const Form* form = oper._localNames[rep_var];
 480           if (form == NULL) {
 481             globalAD-&gt;syntax_err(oper._linenum,
 482                                  &quot;\&#39;%s\&#39; not found in format for %s\n&quot;, rep_var, oper._ident);
 483             assert(form, &quot;replacement variable was not found in local names&quot;);
 484           }
 485           OperandForm *op      = form-&gt;is_operand();
 486           // Get index if register or constant
 487           if ( op-&gt;_matrule &amp;&amp; op-&gt;_matrule-&gt;is_base_register(globals) ) {
 488             idx  = oper.register_position( globals, rep_var);
 489           }
 490           else if (op-&gt;_matrule &amp;&amp; op-&gt;_matrule-&gt;is_base_constant(globals)) {
 491             idx  = oper.constant_position( globals, rep_var);
 492           } else {
 493             idx = 0;
 494           }
 495 
 496           // output invocation of &quot;$...&quot;s format function
 497           if ( op != NULL ) op-&gt;int_format(fp, globals, idx);
 498 
 499           if ( idx == -1 ) {
 500             fprintf(stderr,
 501                     &quot;Using a name, %s, that isn&#39;t in match rule\n&quot;, rep_var);
 502             assert( strcmp(op-&gt;_ident,&quot;label&quot;)==0, &quot;Unimplemented&quot;);
 503           }
 504         } // Done with a replacement variable
 505       } // Done with all format strings
 506     } else {
 507       // Default formats for base operands (RegI, RegP, ConI, ConP, ...)
 508       oper.int_format(fp, globals, 0);
 509     }
 510 
 511   } else { // oper._format == NULL
 512     // Provide a few special case formats where the AD writer cannot.
 513     if ( strcmp(oper._ident,&quot;Universe&quot;)==0 ) {
 514       fprintf(fp, &quot;  st-&gt;print(\&quot;$$univ\&quot;);\n&quot;);
 515     }
 516     // labelOper::int_format is defined in ad_&lt;...&gt;.cpp
 517   }
 518   // ALWAYS! Provide a special case output for condition codes.
 519   if( oper.is_ideal_bool() ) {
 520     defineCCodeDump(&amp;oper, fp,0);
 521   }
 522   fprintf(fp,&quot;}\n&quot;);
 523 
 524   // Generate external format function, when data is stored externally
 525   fprintf(fp,&quot;void %sOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {\n&quot;, oper._ident);
 526   // Generate the user-defined portion of the format
 527   if (oper._format) {
 528     if ( oper._format-&gt;_strings.count() != 0 ) {
 529 
 530       // Check for a replacement string &quot;$...&quot;
 531       if ( oper._format-&gt;_rep_vars.count() != 0 ) {
 532         // Initialization code for ext_format
 533       }
 534 
 535       // Build the format from the entries in strings and rep_vars
 536       const char  *string  = NULL;
 537       oper._format-&gt;_rep_vars.reset();
 538       oper._format-&gt;_strings.reset();
 539       while ( (string = oper._format-&gt;_strings.iter()) != NULL ) {
 540 
 541         // Check if this is a standard string or a replacement variable
 542         if ( string != NameList::_signal ) {
 543           // Normal string
 544           // Pass through to st-&gt;print
 545           fprintf(fp,&quot;  st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;, string);
 546         } else {
 547           // Replacement variable
 548           const char *rep_var = oper._format-&gt;_rep_vars.iter();
 549          // Check that it is a local name, and an operand
 550           const Form* form = oper._localNames[rep_var];
 551           if (form == NULL) {
 552             globalAD-&gt;syntax_err(oper._linenum,
 553                                  &quot;\&#39;%s\&#39; not found in format for %s\n&quot;, rep_var, oper._ident);
 554             assert(form, &quot;replacement variable was not found in local names&quot;);
 555           }
 556           OperandForm *op      = form-&gt;is_operand();
 557           // Get index if register or constant
 558           if ( op-&gt;_matrule &amp;&amp; op-&gt;_matrule-&gt;is_base_register(globals) ) {
 559             idx  = oper.register_position( globals, rep_var);
 560           }
 561           else if (op-&gt;_matrule &amp;&amp; op-&gt;_matrule-&gt;is_base_constant(globals)) {
 562             idx  = oper.constant_position( globals, rep_var);
 563           } else {
 564             idx = 0;
 565           }
 566           // output invocation of &quot;$...&quot;s format function
 567           if ( op != NULL )   op-&gt;ext_format(fp, globals, idx);
 568 
 569           // Lookup the index position of the replacement variable
 570           idx      = oper._components.operand_position_format(rep_var, &amp;oper);
 571           if ( idx == -1 ) {
 572             fprintf(stderr,
 573                     &quot;Using a name, %s, that isn&#39;t in match rule\n&quot;, rep_var);
 574             assert( strcmp(op-&gt;_ident,&quot;label&quot;)==0, &quot;Unimplemented&quot;);
 575           }
 576         } // Done with a replacement variable
 577       } // Done with all format strings
 578 
 579     } else {
 580       // Default formats for base operands (RegI, RegP, ConI, ConP, ...)
 581       oper.ext_format(fp, globals, 0);
 582     }
 583   } else { // oper._format == NULL
 584     // Provide a few special case formats where the AD writer cannot.
 585     if ( strcmp(oper._ident,&quot;Universe&quot;)==0 ) {
 586       fprintf(fp, &quot;  st-&gt;print(\&quot;$$univ\&quot;);\n&quot;);
 587     }
 588     // labelOper::ext_format is defined in ad_&lt;...&gt;.cpp
 589   }
 590   // ALWAYS! Provide a special case output for condition codes.
 591   if( oper.is_ideal_bool() ) {
 592     defineCCodeDump(&amp;oper, fp,0);
 593   }
 594   fprintf(fp, &quot;}\n&quot;);
 595   fprintf(fp, &quot;#endif\n&quot;);
 596 }
 597 
 598 
 599 // Generate the format rule for an instruction
 600 void gen_inst_format(FILE *fp, FormDict &amp;globals, InstructForm &amp;inst, bool for_c_file = false) {
 601   if (!for_c_file) {
 602     // compile the bodies separately, to cut down on recompilations
 603     // #ifndef PRODUCT region generated by caller
 604     fprintf(fp,&quot;  virtual void           format(PhaseRegAlloc *ra, outputStream *st) const;\n&quot;);
 605     return;
 606   }
 607 
 608   // Define the format function
 609   fprintf(fp, &quot;#ifndef PRODUCT\n&quot;);
 610   fprintf(fp, &quot;void %sNode::format(PhaseRegAlloc *ra, outputStream *st) const {\n&quot;, inst._ident);
 611 
 612   // Generate the user-defined portion of the format
 613   if( inst._format ) {
 614     // If there are replacement variables,
 615     // Generate index values needed for determining the operand position
 616     if( inst._format-&gt;_rep_vars.count() )
 617       inst.index_temps(fp, globals);
 618 
 619     // Build the format from the entries in strings and rep_vars
 620     const char  *string  = NULL;
 621     inst._format-&gt;_rep_vars.reset();
 622     inst._format-&gt;_strings.reset();
 623     while( (string = inst._format-&gt;_strings.iter()) != NULL ) {
 624       fprintf(fp,&quot;  &quot;);
 625       // Check if this is a standard string or a replacement variable
 626       if( string == NameList::_signal ) { // Replacement variable
 627         const char* rep_var =  inst._format-&gt;_rep_vars.iter();
 628         inst.rep_var_format( fp, rep_var);
 629       } else if( string == NameList::_signal3 ) { // Replacement variable in raw text
 630         const char* rep_var =  inst._format-&gt;_rep_vars.iter();
 631         const Form *form   = inst._localNames[rep_var];
 632         if (form == NULL) {
 633           fprintf(stderr, &quot;unknown replacement variable in format statement: &#39;%s&#39;\n&quot;, rep_var);
 634           assert(false, &quot;ShouldNotReachHere()&quot;);
 635         }
 636         OpClassForm *opc   = form-&gt;is_opclass();
 637         assert( opc, &quot;replacement variable was not found in local names&quot;);
 638         // Lookup the index position of the replacement variable
 639         int idx  = inst.operand_position_format(rep_var);
 640         if ( idx == -1 ) {
 641           assert( strcmp(opc-&gt;_ident,&quot;label&quot;)==0, &quot;Unimplemented&quot;);
 642           assert( false, &quot;ShouldNotReachHere()&quot;);
 643         }
 644 
 645         if (inst.is_noninput_operand(idx)) {
 646           assert( false, &quot;ShouldNotReachHere()&quot;);
 647         } else {
 648           // Output the format call for this operand
 649           fprintf(fp,&quot;opnd_array(%d)&quot;,idx);
 650         }
 651         rep_var =  inst._format-&gt;_rep_vars.iter();
 652         inst._format-&gt;_strings.iter();
 653         if ( strcmp(rep_var,&quot;$constant&quot;) == 0 &amp;&amp; opc-&gt;is_operand()) {
 654           Form::DataType constant_type = form-&gt;is_operand()-&gt;is_base_constant(globals);
 655           if ( constant_type == Form::idealD ) {
 656             fprintf(fp,&quot;-&gt;constantD()&quot;);
 657           } else if ( constant_type == Form::idealF ) {
 658             fprintf(fp,&quot;-&gt;constantF()&quot;);
 659           } else if ( constant_type == Form::idealL ) {
 660             fprintf(fp,&quot;-&gt;constantL()&quot;);
 661           } else {
 662             fprintf(fp,&quot;-&gt;constant()&quot;);
 663           }
 664         } else if ( strcmp(rep_var,&quot;$cmpcode&quot;) == 0) {
 665             fprintf(fp,&quot;-&gt;ccode()&quot;);
 666         } else {
 667           assert( false, &quot;ShouldNotReachHere()&quot;);
 668         }
 669       } else if( string == NameList::_signal2 ) // Raw program text
 670         fputs(inst._format-&gt;_strings.iter(), fp);
 671       else
 672         fprintf(fp,&quot;st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;, string);
 673     } // Done with all format strings
 674   } // Done generating the user-defined portion of the format
 675 
 676   // Add call debug info automatically
 677   Form::CallType call_type = inst.is_ideal_call();
 678   if( call_type != Form::invalid_type ) {
 679     switch( call_type ) {
 680     case Form::JAVA_DYNAMIC:
 681       fprintf(fp,&quot;  _method-&gt;print_short_name(st);\n&quot;);
 682       break;
 683     case Form::JAVA_STATIC:
 684       fprintf(fp,&quot;  if( _method ) _method-&gt;print_short_name(st);\n&quot;);
 685       fprintf(fp,&quot;  else st-&gt;print(\&quot; wrapper for: %%s\&quot;, _name);\n&quot;);
 686       fprintf(fp,&quot;  if( !_method ) dump_trap_args(st);\n&quot;);
 687       break;
 688     case Form::JAVA_COMPILED:
 689     case Form::JAVA_INTERP:
 690       break;
 691     case Form::JAVA_RUNTIME:
 692     case Form::JAVA_LEAF:
 693     case Form::JAVA_NATIVE:
 694       fprintf(fp,&quot;  st-&gt;print(\&quot; %%s\&quot;, _name);&quot;);
 695       break;
 696     default:
 697       assert(0,&quot;ShouldNotReachHere&quot;);
 698     }
 699     fprintf(fp,  &quot;  st-&gt;cr();\n&quot; );
 700     fprintf(fp,  &quot;  if (_jvms) _jvms-&gt;format(ra, this, st); else st-&gt;print_cr(\&quot;        No JVM State Info\&quot;);\n&quot; );
 701     fprintf(fp,  &quot;  st-&gt;print(\&quot;        # \&quot;);\n&quot; );
 702     fprintf(fp,  &quot;  if( _jvms &amp;&amp; _oop_map ) _oop_map-&gt;print_on(st);\n&quot;);
 703   }
 704   else if(inst.is_ideal_safepoint()) {
 705     fprintf(fp,  &quot;  st-&gt;print_raw(\&quot;\&quot;);\n&quot; );
 706     fprintf(fp,  &quot;  if (_jvms) _jvms-&gt;format(ra, this, st); else st-&gt;print_cr(\&quot;        No JVM State Info\&quot;);\n&quot; );
 707     fprintf(fp,  &quot;  st-&gt;print(\&quot;        # \&quot;);\n&quot; );
 708     fprintf(fp,  &quot;  if( _jvms &amp;&amp; _oop_map ) _oop_map-&gt;print_on(st);\n&quot;);
 709   }
 710   else if( inst.is_ideal_if() ) {
 711     fprintf(fp,  &quot;  st-&gt;print(\&quot;  P=%%f C=%%f\&quot;,_prob,_fcnt);\n&quot; );
 712   }
 713   else if( inst.is_ideal_mem() ) {
 714     // Print out the field name if available to improve readability
 715     fprintf(fp,  &quot;  if (ra-&gt;C-&gt;alias_type(adr_type())-&gt;field() != NULL) {\n&quot;);
 716     fprintf(fp,  &quot;    ciField* f = ra-&gt;C-&gt;alias_type(adr_type())-&gt;field();\n&quot;);
 717     fprintf(fp,  &quot;    st-&gt;print(\&quot; %s Field: \&quot;);\n&quot;, commentSeperator);
 718     fprintf(fp,  &quot;    if (f-&gt;is_volatile())\n&quot;);
 719     fprintf(fp,  &quot;      st-&gt;print(\&quot;volatile \&quot;);\n&quot;);
 720     fprintf(fp,  &quot;    f-&gt;holder()-&gt;name()-&gt;print_symbol_on(st);\n&quot;);
 721     fprintf(fp,  &quot;    st-&gt;print(\&quot;.\&quot;);\n&quot;);
 722     fprintf(fp,  &quot;    f-&gt;name()-&gt;print_symbol_on(st);\n&quot;);
 723     fprintf(fp,  &quot;    if (f-&gt;is_constant())\n&quot;);
 724     fprintf(fp,  &quot;      st-&gt;print(\&quot; (constant)\&quot;);\n&quot;);
 725     fprintf(fp,  &quot;  } else {\n&quot;);
 726     // Make sure &#39;Volatile&#39; gets printed out
 727     fprintf(fp,  &quot;    if (ra-&gt;C-&gt;alias_type(adr_type())-&gt;is_volatile())\n&quot;);
 728     fprintf(fp,  &quot;      st-&gt;print(\&quot; volatile!\&quot;);\n&quot;);
 729     fprintf(fp,  &quot;  }\n&quot;);
 730   }
 731 
 732   // Complete the definition of the format function
 733   fprintf(fp, &quot;}\n#endif\n&quot;);
 734 }
 735 
 736 void ArchDesc::declare_pipe_classes(FILE *fp_hpp) {
 737   if (!_pipeline)
 738     return;
 739 
 740   fprintf(fp_hpp, &quot;\n&quot;);
 741   fprintf(fp_hpp, &quot;// Pipeline_Use_Cycle_Mask Class\n&quot;);
 742   fprintf(fp_hpp, &quot;class Pipeline_Use_Cycle_Mask {\n&quot;);
 743 
 744   if (_pipeline-&gt;_maxcycleused &lt;=
 745 #ifdef SPARC
 746     64
 747 #else
 748     32
 749 #endif
 750       ) {
 751     fprintf(fp_hpp, &quot;protected:\n&quot;);
 752     fprintf(fp_hpp, &quot;  %s _mask;\n\n&quot;, _pipeline-&gt;_maxcycleused &lt;= 32 ? &quot;uint&quot; : &quot;uint64_t&quot; );
 753     fprintf(fp_hpp, &quot;public:\n&quot;);
 754     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask() : _mask(0) {}\n\n&quot;);
 755     if (_pipeline-&gt;_maxcycleused &lt;= 32)
 756       fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask(uint mask) : _mask(mask) {}\n\n&quot;);
 757     else {
 758       fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask(uint mask1, uint mask2) : _mask((((uint64_t)mask1) &lt;&lt; 32) | mask2) {}\n\n&quot;);
 759       fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask(uint64_t mask) : _mask(mask) {}\n\n&quot;);
 760     }
 761     fprintf(fp_hpp, &quot;  bool overlaps(const Pipeline_Use_Cycle_Mask &amp;in2) const {\n&quot;);
 762     fprintf(fp_hpp, &quot;    return ((_mask &amp; in2._mask) != 0);\n&quot;);
 763     fprintf(fp_hpp, &quot;  }\n\n&quot;);
 764     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask&amp; operator&lt;&lt;=(int n) {\n&quot;);
 765     fprintf(fp_hpp, &quot;    _mask &lt;&lt;= n;\n&quot;);
 766     fprintf(fp_hpp, &quot;    return *this;\n&quot;);
 767     fprintf(fp_hpp, &quot;  }\n\n&quot;);
 768     fprintf(fp_hpp, &quot;  void Or(const Pipeline_Use_Cycle_Mask &amp;in2) {\n&quot;);
 769     fprintf(fp_hpp, &quot;    _mask |= in2._mask;\n&quot;);
 770     fprintf(fp_hpp, &quot;  }\n\n&quot;);
 771     fprintf(fp_hpp, &quot;  friend Pipeline_Use_Cycle_Mask operator&amp;(const Pipeline_Use_Cycle_Mask &amp;, const Pipeline_Use_Cycle_Mask &amp;);\n&quot;);
 772     fprintf(fp_hpp, &quot;  friend Pipeline_Use_Cycle_Mask operator|(const Pipeline_Use_Cycle_Mask &amp;, const Pipeline_Use_Cycle_Mask &amp;);\n\n&quot;);
 773   }
 774   else {
 775     fprintf(fp_hpp, &quot;protected:\n&quot;);
 776     uint masklen = (_pipeline-&gt;_maxcycleused + 31) &gt;&gt; 5;
 777     uint l;
 778     fprintf(fp_hpp, &quot;  uint &quot;);
 779     for (l = 1; l &lt;= masklen; l++)
 780       fprintf(fp_hpp, &quot;_mask%d%s&quot;, l, l &lt; masklen ? &quot;, &quot; : &quot;;\n\n&quot;);
 781     fprintf(fp_hpp, &quot;public:\n&quot;);
 782     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask() : &quot;);
 783     for (l = 1; l &lt;= masklen; l++)
 784       fprintf(fp_hpp, &quot;_mask%d(0)%s&quot;, l, l &lt; masklen ? &quot;, &quot; : &quot; {}\n\n&quot;);
 785     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask(&quot;);
 786     for (l = 1; l &lt;= masklen; l++)
 787       fprintf(fp_hpp, &quot;uint mask%d%s&quot;, l, l &lt; masklen ? &quot;, &quot; : &quot;) : &quot;);
 788     for (l = 1; l &lt;= masklen; l++)
 789       fprintf(fp_hpp, &quot;_mask%d(mask%d)%s&quot;, l, l, l &lt; masklen ? &quot;, &quot; : &quot; {}\n\n&quot;);
 790 
 791     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask intersect(const Pipeline_Use_Cycle_Mask &amp;in2) {\n&quot;);
 792     fprintf(fp_hpp, &quot;    Pipeline_Use_Cycle_Mask out;\n&quot;);
 793     for (l = 1; l &lt;= masklen; l++)
 794       fprintf(fp_hpp, &quot;    out._mask%d = _mask%d &amp; in2._mask%d;\n&quot;, l, l, l);
 795     fprintf(fp_hpp, &quot;    return out;\n&quot;);
 796     fprintf(fp_hpp, &quot;  }\n\n&quot;);
 797     fprintf(fp_hpp, &quot;  bool overlaps(const Pipeline_Use_Cycle_Mask &amp;in2) const {\n&quot;);
 798     fprintf(fp_hpp, &quot;    return (&quot;);
 799     for (l = 1; l &lt;= masklen; l++)
 800       fprintf(fp_hpp, &quot;((_mask%d &amp; in2._mask%d) != 0)%s&quot;, l, l, l &lt; masklen ? &quot; || &quot; : &quot;&quot;);
 801     fprintf(fp_hpp, &quot;) ? true : false;\n&quot;);
 802     fprintf(fp_hpp, &quot;  }\n\n&quot;);
 803     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask&amp; operator&lt;&lt;=(int n) {\n&quot;);
 804     fprintf(fp_hpp, &quot;    if (n &gt;= 32)\n&quot;);
 805     fprintf(fp_hpp, &quot;      do {\n       &quot;);
 806     for (l = masklen; l &gt; 1; l--)
 807       fprintf(fp_hpp, &quot; _mask%d = _mask%d;&quot;, l, l-1);
 808     fprintf(fp_hpp, &quot; _mask%d = 0;\n&quot;, 1);
 809     fprintf(fp_hpp, &quot;      } while ((n -= 32) &gt;= 32);\n\n&quot;);
 810     fprintf(fp_hpp, &quot;    if (n &gt; 0) {\n&quot;);
 811     fprintf(fp_hpp, &quot;      uint m = 32 - n;\n&quot;);
 812     fprintf(fp_hpp, &quot;      uint mask = (1 &lt;&lt; n) - 1;\n&quot;);
 813     fprintf(fp_hpp, &quot;      uint temp%d = mask &amp; (_mask%d &gt;&gt; m); _mask%d &lt;&lt;= n;\n&quot;, 2, 1, 1);
 814     for (l = 2; l &lt; masklen; l++) {
 815       fprintf(fp_hpp, &quot;      uint temp%d = mask &amp; (_mask%d &gt;&gt; m); _mask%d &lt;&lt;= n; _mask%d |= temp%d;\n&quot;, l+1, l, l, l, l);
 816     }
 817     fprintf(fp_hpp, &quot;      _mask%d &lt;&lt;= n; _mask%d |= temp%d;\n&quot;, masklen, masklen, masklen);
 818     fprintf(fp_hpp, &quot;    }\n&quot;);
 819 
 820     fprintf(fp_hpp, &quot;    return *this;\n&quot;);
 821     fprintf(fp_hpp, &quot;  }\n\n&quot;);
 822     fprintf(fp_hpp, &quot;  void Or(const Pipeline_Use_Cycle_Mask &amp;);\n\n&quot;);
 823     fprintf(fp_hpp, &quot;  friend Pipeline_Use_Cycle_Mask operator&amp;(const Pipeline_Use_Cycle_Mask &amp;, const Pipeline_Use_Cycle_Mask &amp;);\n&quot;);
 824     fprintf(fp_hpp, &quot;  friend Pipeline_Use_Cycle_Mask operator|(const Pipeline_Use_Cycle_Mask &amp;, const Pipeline_Use_Cycle_Mask &amp;);\n\n&quot;);
 825   }
 826 
 827   fprintf(fp_hpp, &quot;  friend class Pipeline_Use;\n\n&quot;);
 828   fprintf(fp_hpp, &quot;  friend class Pipeline_Use_Element;\n\n&quot;);
 829   fprintf(fp_hpp, &quot;};\n\n&quot;);
 830 
 831   uint rescount = 0;
 832   const char *resource;
 833 
 834   for ( _pipeline-&gt;_reslist.reset(); (resource = _pipeline-&gt;_reslist.iter()) != NULL; ) {
 835       int mask = _pipeline-&gt;_resdict[resource]-&gt;is_resource()-&gt;mask();
 836       if ((mask &amp; (mask-1)) == 0)
 837         rescount++;
 838     }
 839 
 840   fprintf(fp_hpp, &quot;// Pipeline_Use_Element Class\n&quot;);
 841   fprintf(fp_hpp, &quot;class Pipeline_Use_Element {\n&quot;);
 842   fprintf(fp_hpp, &quot;protected:\n&quot;);
 843   fprintf(fp_hpp, &quot;  // Mask of used functional units\n&quot;);
 844   fprintf(fp_hpp, &quot;  uint _used;\n\n&quot;);
 845   fprintf(fp_hpp, &quot;  // Lower and upper bound of functional unit number range\n&quot;);
 846   fprintf(fp_hpp, &quot;  uint _lb, _ub;\n\n&quot;);
 847   fprintf(fp_hpp, &quot;  // Indicates multiple functionals units available\n&quot;);
 848   fprintf(fp_hpp, &quot;  bool _multiple;\n\n&quot;);
 849   fprintf(fp_hpp, &quot;  // Mask of specific used cycles\n&quot;);
 850   fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask _mask;\n\n&quot;);
 851   fprintf(fp_hpp, &quot;public:\n&quot;);
 852   fprintf(fp_hpp, &quot;  Pipeline_Use_Element() {}\n\n&quot;);
 853   fprintf(fp_hpp, &quot;  Pipeline_Use_Element(uint used, uint lb, uint ub, bool multiple, Pipeline_Use_Cycle_Mask mask)\n&quot;);
 854   fprintf(fp_hpp, &quot;  : _used(used), _lb(lb), _ub(ub), _multiple(multiple), _mask(mask) {}\n\n&quot;);
 855   fprintf(fp_hpp, &quot;  uint used() const { return _used; }\n\n&quot;);
 856   fprintf(fp_hpp, &quot;  uint lowerBound() const { return _lb; }\n\n&quot;);
 857   fprintf(fp_hpp, &quot;  uint upperBound() const { return _ub; }\n\n&quot;);
 858   fprintf(fp_hpp, &quot;  bool multiple() const { return _multiple; }\n\n&quot;);
 859   fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask mask() const { return _mask; }\n\n&quot;);
 860   fprintf(fp_hpp, &quot;  bool overlaps(const Pipeline_Use_Element &amp;in2) const {\n&quot;);
 861   fprintf(fp_hpp, &quot;    return ((_used &amp; in2._used) != 0 &amp;&amp; _mask.overlaps(in2._mask));\n&quot;);
 862   fprintf(fp_hpp, &quot;  }\n\n&quot;);
 863   fprintf(fp_hpp, &quot;  void step(uint cycles) {\n&quot;);
 864   fprintf(fp_hpp, &quot;    _used = 0;\n&quot;);
 865   fprintf(fp_hpp, &quot;    _mask &lt;&lt;= cycles;\n&quot;);
 866   fprintf(fp_hpp, &quot;  }\n\n&quot;);
 867   fprintf(fp_hpp, &quot;  friend class Pipeline_Use;\n&quot;);
 868   fprintf(fp_hpp, &quot;};\n\n&quot;);
 869 
 870   fprintf(fp_hpp, &quot;// Pipeline_Use Class\n&quot;);
 871   fprintf(fp_hpp, &quot;class Pipeline_Use {\n&quot;);
 872   fprintf(fp_hpp, &quot;protected:\n&quot;);
 873   fprintf(fp_hpp, &quot;  // These resources can be used\n&quot;);
 874   fprintf(fp_hpp, &quot;  uint _resources_used;\n\n&quot;);
 875   fprintf(fp_hpp, &quot;  // These resources are used; excludes multiple choice functional units\n&quot;);
 876   fprintf(fp_hpp, &quot;  uint _resources_used_exclusively;\n\n&quot;);
 877   fprintf(fp_hpp, &quot;  // Number of elements\n&quot;);
 878   fprintf(fp_hpp, &quot;  uint _count;\n\n&quot;);
 879   fprintf(fp_hpp, &quot;  // This is the array of Pipeline_Use_Elements\n&quot;);
 880   fprintf(fp_hpp, &quot;  Pipeline_Use_Element * _elements;\n\n&quot;);
 881   fprintf(fp_hpp, &quot;public:\n&quot;);
 882   fprintf(fp_hpp, &quot;  Pipeline_Use(uint resources_used, uint resources_used_exclusively, uint count, Pipeline_Use_Element *elements)\n&quot;);
 883   fprintf(fp_hpp, &quot;  : _resources_used(resources_used)\n&quot;);
 884   fprintf(fp_hpp, &quot;  , _resources_used_exclusively(resources_used_exclusively)\n&quot;);
 885   fprintf(fp_hpp, &quot;  , _count(count)\n&quot;);
 886   fprintf(fp_hpp, &quot;  , _elements(elements)\n&quot;);
 887   fprintf(fp_hpp, &quot;  {}\n\n&quot;);
 888   fprintf(fp_hpp, &quot;  uint resourcesUsed() const { return _resources_used; }\n\n&quot;);
 889   fprintf(fp_hpp, &quot;  uint resourcesUsedExclusively() const { return _resources_used_exclusively; }\n\n&quot;);
 890   fprintf(fp_hpp, &quot;  uint count() const { return _count; }\n\n&quot;);
 891   fprintf(fp_hpp, &quot;  Pipeline_Use_Element * element(uint i) const { return &amp;_elements[i]; }\n\n&quot;);
 892   fprintf(fp_hpp, &quot;  uint full_latency(uint delay, const Pipeline_Use &amp;pred) const;\n\n&quot;);
 893   fprintf(fp_hpp, &quot;  void add_usage(const Pipeline_Use &amp;pred);\n\n&quot;);
 894   fprintf(fp_hpp, &quot;  void reset() {\n&quot;);
 895   fprintf(fp_hpp, &quot;    _resources_used = _resources_used_exclusively = 0;\n&quot;);
 896   fprintf(fp_hpp, &quot;  };\n\n&quot;);
 897   fprintf(fp_hpp, &quot;  void step(uint cycles) {\n&quot;);
 898   fprintf(fp_hpp, &quot;    reset();\n&quot;);
 899   fprintf(fp_hpp, &quot;    for (uint i = 0; i &lt; %d; i++)\n&quot;,
 900     rescount);
 901   fprintf(fp_hpp, &quot;      (&amp;_elements[i])-&gt;step(cycles);\n&quot;);
 902   fprintf(fp_hpp, &quot;  };\n\n&quot;);
 903   fprintf(fp_hpp, &quot;  static const Pipeline_Use         elaborated_use;\n&quot;);
 904   fprintf(fp_hpp, &quot;  static const Pipeline_Use_Element elaborated_elements[%d];\n\n&quot;,
 905     rescount);
 906   fprintf(fp_hpp, &quot;  friend class Pipeline;\n&quot;);
 907   fprintf(fp_hpp, &quot;};\n\n&quot;);
 908 
 909   fprintf(fp_hpp, &quot;// Pipeline Class\n&quot;);
 910   fprintf(fp_hpp, &quot;class Pipeline {\n&quot;);
 911   fprintf(fp_hpp, &quot;public:\n&quot;);
 912 
 913   fprintf(fp_hpp, &quot;  static bool enabled() { return %s; }\n\n&quot;,
 914     _pipeline ? &quot;true&quot; : &quot;false&quot; );
 915 
 916   assert( _pipeline-&gt;_maxInstrsPerBundle &amp;&amp;
 917         ( _pipeline-&gt;_instrUnitSize || _pipeline-&gt;_bundleUnitSize) &amp;&amp;
 918           _pipeline-&gt;_instrFetchUnitSize &amp;&amp;
 919           _pipeline-&gt;_instrFetchUnits,
 920     &quot;unspecified pipeline architecture units&quot;);
 921 
 922   uint unitSize = _pipeline-&gt;_instrUnitSize ? _pipeline-&gt;_instrUnitSize : _pipeline-&gt;_bundleUnitSize;
 923 
 924   fprintf(fp_hpp, &quot;  enum {\n&quot;);
 925   fprintf(fp_hpp, &quot;    _variable_size_instructions = %d,\n&quot;,
 926     _pipeline-&gt;_variableSizeInstrs ? 1 : 0);
 927   fprintf(fp_hpp, &quot;    _fixed_size_instructions = %d,\n&quot;,
 928     _pipeline-&gt;_variableSizeInstrs ? 0 : 1);
 929   fprintf(fp_hpp, &quot;    _branch_has_delay_slot = %d,\n&quot;,
 930     _pipeline-&gt;_branchHasDelaySlot ? 1 : 0);
 931   fprintf(fp_hpp, &quot;    _max_instrs_per_bundle = %d,\n&quot;,
 932     _pipeline-&gt;_maxInstrsPerBundle);
 933   fprintf(fp_hpp, &quot;    _max_bundles_per_cycle = %d,\n&quot;,
 934     _pipeline-&gt;_maxBundlesPerCycle);
 935   fprintf(fp_hpp, &quot;    _max_instrs_per_cycle = %d\n&quot;,
 936     _pipeline-&gt;_maxBundlesPerCycle * _pipeline-&gt;_maxInstrsPerBundle);
 937   fprintf(fp_hpp, &quot;  };\n\n&quot;);
 938 
 939   fprintf(fp_hpp, &quot;  static bool instr_has_unit_size() { return %s; }\n\n&quot;,
 940     _pipeline-&gt;_instrUnitSize != 0 ? &quot;true&quot; : &quot;false&quot; );
 941   if( _pipeline-&gt;_bundleUnitSize != 0 )
 942     if( _pipeline-&gt;_instrUnitSize != 0 )
 943       fprintf(fp_hpp, &quot;// Individual Instructions may be bundled together by the hardware\n\n&quot;);
 944     else
 945       fprintf(fp_hpp, &quot;// Instructions exist only in bundles\n\n&quot;);
 946   else
 947     fprintf(fp_hpp, &quot;// Bundling is not supported\n\n&quot;);
 948   if( _pipeline-&gt;_instrUnitSize != 0 )
 949     fprintf(fp_hpp, &quot;  // Size of an instruction\n&quot;);
 950   else
 951     fprintf(fp_hpp, &quot;  // Size of an individual instruction does not exist - unsupported\n&quot;);
 952   fprintf(fp_hpp, &quot;  static uint instr_unit_size() {&quot;);
 953   if( _pipeline-&gt;_instrUnitSize == 0 )
 954     fprintf(fp_hpp, &quot; assert( false, \&quot;Instructions are only in bundles\&quot; );&quot;);
 955   fprintf(fp_hpp, &quot; return %d; };\n\n&quot;, _pipeline-&gt;_instrUnitSize);
 956 
 957   if( _pipeline-&gt;_bundleUnitSize != 0 )
 958     fprintf(fp_hpp, &quot;  // Size of a bundle\n&quot;);
 959   else
 960     fprintf(fp_hpp, &quot;  // Bundles do not exist - unsupported\n&quot;);
 961   fprintf(fp_hpp, &quot;  static uint bundle_unit_size() {&quot;);
 962   if( _pipeline-&gt;_bundleUnitSize == 0 )
 963     fprintf(fp_hpp, &quot; assert( false, \&quot;Bundles are not supported\&quot; );&quot;);
 964   fprintf(fp_hpp, &quot; return %d; };\n\n&quot;, _pipeline-&gt;_bundleUnitSize);
 965 
 966   fprintf(fp_hpp, &quot;  static bool requires_bundling() { return %s; }\n\n&quot;,
 967     _pipeline-&gt;_bundleUnitSize != 0 &amp;&amp; _pipeline-&gt;_instrUnitSize == 0 ? &quot;true&quot; : &quot;false&quot; );
 968 
 969   fprintf(fp_hpp, &quot;private:\n&quot;);
 970   fprintf(fp_hpp, &quot;  Pipeline();  // Not a legal constructor\n&quot;);
 971   fprintf(fp_hpp, &quot;\n&quot;);
 972   fprintf(fp_hpp, &quot;  const unsigned char                   _read_stage_count;\n&quot;);
 973   fprintf(fp_hpp, &quot;  const unsigned char                   _write_stage;\n&quot;);
 974   fprintf(fp_hpp, &quot;  const unsigned char                   _fixed_latency;\n&quot;);
 975   fprintf(fp_hpp, &quot;  const unsigned char                   _instruction_count;\n&quot;);
 976   fprintf(fp_hpp, &quot;  const bool                            _has_fixed_latency;\n&quot;);
 977   fprintf(fp_hpp, &quot;  const bool                            _has_branch_delay;\n&quot;);
 978   fprintf(fp_hpp, &quot;  const bool                            _has_multiple_bundles;\n&quot;);
 979   fprintf(fp_hpp, &quot;  const bool                            _force_serialization;\n&quot;);
 980   fprintf(fp_hpp, &quot;  const bool                            _may_have_no_code;\n&quot;);
 981   fprintf(fp_hpp, &quot;  const enum machPipelineStages * const _read_stages;\n&quot;);
 982   fprintf(fp_hpp, &quot;  const enum machPipelineStages * const _resource_stage;\n&quot;);
 983   fprintf(fp_hpp, &quot;  const uint                    * const _resource_cycles;\n&quot;);
 984   fprintf(fp_hpp, &quot;  const Pipeline_Use                    _resource_use;\n&quot;);
 985   fprintf(fp_hpp, &quot;\n&quot;);
 986   fprintf(fp_hpp, &quot;public:\n&quot;);
 987   fprintf(fp_hpp, &quot;  Pipeline(uint                            write_stage,\n&quot;);
 988   fprintf(fp_hpp, &quot;           uint                            count,\n&quot;);
 989   fprintf(fp_hpp, &quot;           bool                            has_fixed_latency,\n&quot;);
 990   fprintf(fp_hpp, &quot;           uint                            fixed_latency,\n&quot;);
 991   fprintf(fp_hpp, &quot;           uint                            instruction_count,\n&quot;);
 992   fprintf(fp_hpp, &quot;           bool                            has_branch_delay,\n&quot;);
 993   fprintf(fp_hpp, &quot;           bool                            has_multiple_bundles,\n&quot;);
 994   fprintf(fp_hpp, &quot;           bool                            force_serialization,\n&quot;);
 995   fprintf(fp_hpp, &quot;           bool                            may_have_no_code,\n&quot;);
 996   fprintf(fp_hpp, &quot;           enum machPipelineStages * const dst,\n&quot;);
 997   fprintf(fp_hpp, &quot;           enum machPipelineStages * const stage,\n&quot;);
 998   fprintf(fp_hpp, &quot;           uint                    * const cycles,\n&quot;);
 999   fprintf(fp_hpp, &quot;           Pipeline_Use                    resource_use)\n&quot;);
1000   fprintf(fp_hpp, &quot;  : _read_stage_count(count)\n&quot;);
1001   fprintf(fp_hpp, &quot;  , _write_stage(write_stage)\n&quot;);
1002   fprintf(fp_hpp, &quot;  , _fixed_latency(fixed_latency)\n&quot;);
1003   fprintf(fp_hpp, &quot;  , _instruction_count(instruction_count)\n&quot;);
1004   fprintf(fp_hpp, &quot;  , _has_fixed_latency(has_fixed_latency)\n&quot;);
1005   fprintf(fp_hpp, &quot;  , _has_branch_delay(has_branch_delay)\n&quot;);
1006   fprintf(fp_hpp, &quot;  , _has_multiple_bundles(has_multiple_bundles)\n&quot;);
1007   fprintf(fp_hpp, &quot;  , _force_serialization(force_serialization)\n&quot;);
1008   fprintf(fp_hpp, &quot;  , _may_have_no_code(may_have_no_code)\n&quot;);
1009   fprintf(fp_hpp, &quot;  , _read_stages(dst)\n&quot;);
1010   fprintf(fp_hpp, &quot;  , _resource_stage(stage)\n&quot;);
1011   fprintf(fp_hpp, &quot;  , _resource_cycles(cycles)\n&quot;);
1012   fprintf(fp_hpp, &quot;  , _resource_use(resource_use)\n&quot;);
1013   fprintf(fp_hpp, &quot;  {};\n&quot;);
1014   fprintf(fp_hpp, &quot;\n&quot;);
1015   fprintf(fp_hpp, &quot;  uint writeStage() const {\n&quot;);
1016   fprintf(fp_hpp, &quot;    return (_write_stage);\n&quot;);
1017   fprintf(fp_hpp, &quot;  }\n&quot;);
1018   fprintf(fp_hpp, &quot;\n&quot;);
1019   fprintf(fp_hpp, &quot;  enum machPipelineStages readStage(int ndx) const {\n&quot;);
1020   fprintf(fp_hpp, &quot;    return (ndx &lt; _read_stage_count ? _read_stages[ndx] : stage_undefined);&quot;);
1021   fprintf(fp_hpp, &quot;  }\n\n&quot;);
1022   fprintf(fp_hpp, &quot;  uint resourcesUsed() const {\n&quot;);
1023   fprintf(fp_hpp, &quot;    return _resource_use.resourcesUsed();\n  }\n\n&quot;);
1024   fprintf(fp_hpp, &quot;  uint resourcesUsedExclusively() const {\n&quot;);
1025   fprintf(fp_hpp, &quot;    return _resource_use.resourcesUsedExclusively();\n  }\n\n&quot;);
1026   fprintf(fp_hpp, &quot;  bool hasFixedLatency() const {\n&quot;);
1027   fprintf(fp_hpp, &quot;    return (_has_fixed_latency);\n  }\n\n&quot;);
1028   fprintf(fp_hpp, &quot;  uint fixedLatency() const {\n&quot;);
1029   fprintf(fp_hpp, &quot;    return (_fixed_latency);\n  }\n\n&quot;);
1030   fprintf(fp_hpp, &quot;  uint functional_unit_latency(uint start, const Pipeline *pred) const;\n\n&quot;);
1031   fprintf(fp_hpp, &quot;  uint operand_latency(uint opnd, const Pipeline *pred) const;\n\n&quot;);
1032   fprintf(fp_hpp, &quot;  const Pipeline_Use&amp; resourceUse() const {\n&quot;);
1033   fprintf(fp_hpp, &quot;    return (_resource_use); }\n\n&quot;);
1034   fprintf(fp_hpp, &quot;  const Pipeline_Use_Element * resourceUseElement(uint i) const {\n&quot;);
1035   fprintf(fp_hpp, &quot;    return (&amp;_resource_use._elements[i]); }\n\n&quot;);
1036   fprintf(fp_hpp, &quot;  uint resourceUseCount() const {\n&quot;);
1037   fprintf(fp_hpp, &quot;    return (_resource_use._count); }\n\n&quot;);
1038   fprintf(fp_hpp, &quot;  uint instructionCount() const {\n&quot;);
1039   fprintf(fp_hpp, &quot;    return (_instruction_count); }\n\n&quot;);
1040   fprintf(fp_hpp, &quot;  bool hasBranchDelay() const {\n&quot;);
1041   fprintf(fp_hpp, &quot;    return (_has_branch_delay); }\n\n&quot;);
1042   fprintf(fp_hpp, &quot;  bool hasMultipleBundles() const {\n&quot;);
1043   fprintf(fp_hpp, &quot;    return (_has_multiple_bundles); }\n\n&quot;);
1044   fprintf(fp_hpp, &quot;  bool forceSerialization() const {\n&quot;);
1045   fprintf(fp_hpp, &quot;    return (_force_serialization); }\n\n&quot;);
1046   fprintf(fp_hpp, &quot;  bool mayHaveNoCode() const {\n&quot;);
1047   fprintf(fp_hpp, &quot;    return (_may_have_no_code); }\n\n&quot;);
1048   fprintf(fp_hpp, &quot;//const Pipeline_Use_Cycle_Mask&amp; resourceUseMask(int resource) const {\n&quot;);
1049   fprintf(fp_hpp, &quot;//  return (_resource_use_masks[resource]); }\n\n&quot;);
1050   fprintf(fp_hpp, &quot;\n#ifndef PRODUCT\n&quot;);
1051   fprintf(fp_hpp, &quot;  static const char * stageName(uint i);\n&quot;);
1052   fprintf(fp_hpp, &quot;#endif\n&quot;);
1053   fprintf(fp_hpp, &quot;};\n\n&quot;);
1054 
1055   fprintf(fp_hpp, &quot;// Bundle class\n&quot;);
1056   fprintf(fp_hpp, &quot;class Bundle {\n&quot;);
1057 
1058   uint mshift = 0;
1059   for (uint msize = _pipeline-&gt;_maxInstrsPerBundle * _pipeline-&gt;_maxBundlesPerCycle; msize != 0; msize &gt;&gt;= 1)
1060     mshift++;
1061 
1062   uint rshift = rescount;
1063 
1064   fprintf(fp_hpp, &quot;protected:\n&quot;);
1065   fprintf(fp_hpp, &quot;  enum {\n&quot;);
1066   fprintf(fp_hpp, &quot;    _unused_delay                   = 0x%x,\n&quot;, 0);
1067   fprintf(fp_hpp, &quot;    _use_nop_delay                  = 0x%x,\n&quot;, 1);
1068   fprintf(fp_hpp, &quot;    _use_unconditional_delay        = 0x%x,\n&quot;, 2);
1069   fprintf(fp_hpp, &quot;    _use_conditional_delay          = 0x%x,\n&quot;, 3);
1070   fprintf(fp_hpp, &quot;    _used_in_conditional_delay      = 0x%x,\n&quot;, 4);
1071   fprintf(fp_hpp, &quot;    _used_in_unconditional_delay    = 0x%x,\n&quot;, 5);
1072   fprintf(fp_hpp, &quot;    _used_in_all_conditional_delays = 0x%x,\n&quot;, 6);
1073   fprintf(fp_hpp, &quot;\n&quot;);
1074   fprintf(fp_hpp, &quot;    _use_delay                      = 0x%x,\n&quot;, 3);
1075   fprintf(fp_hpp, &quot;    _used_in_delay                  = 0x%x\n&quot;,  4);
1076   fprintf(fp_hpp, &quot;  };\n\n&quot;);
1077   fprintf(fp_hpp, &quot;  uint _flags          : 3,\n&quot;);
1078   fprintf(fp_hpp, &quot;       _starts_bundle  : 1,\n&quot;);
1079   fprintf(fp_hpp, &quot;       _instr_count    : %d,\n&quot;,   mshift);
1080   fprintf(fp_hpp, &quot;       _resources_used : %d;\n&quot;,   rshift);
1081   fprintf(fp_hpp, &quot;public:\n&quot;);
1082   fprintf(fp_hpp, &quot;  Bundle() : _flags(_unused_delay), _starts_bundle(0), _instr_count(0), _resources_used(0) {}\n\n&quot;);
1083   fprintf(fp_hpp, &quot;  void set_instr_count(uint i) { _instr_count  = i; }\n&quot;);
1084   fprintf(fp_hpp, &quot;  void set_resources_used(uint i) { _resources_used   = i; }\n&quot;);
1085   fprintf(fp_hpp, &quot;  void clear_usage() { _flags = _unused_delay; }\n&quot;);
1086   fprintf(fp_hpp, &quot;  void set_starts_bundle() { _starts_bundle = true; }\n&quot;);
1087 
1088   fprintf(fp_hpp, &quot;  uint flags() const { return (_flags); }\n&quot;);
1089   fprintf(fp_hpp, &quot;  uint instr_count() const { return (_instr_count); }\n&quot;);
1090   fprintf(fp_hpp, &quot;  uint resources_used() const { return (_resources_used); }\n&quot;);
1091   fprintf(fp_hpp, &quot;  bool starts_bundle() const { return (_starts_bundle != 0); }\n&quot;);
1092 
1093   fprintf(fp_hpp, &quot;  void set_use_nop_delay() { _flags = _use_nop_delay; }\n&quot;);
1094   fprintf(fp_hpp, &quot;  void set_use_unconditional_delay() { _flags = _use_unconditional_delay; }\n&quot;);
1095   fprintf(fp_hpp, &quot;  void set_use_conditional_delay() { _flags = _use_conditional_delay; }\n&quot;);
1096   fprintf(fp_hpp, &quot;  void set_used_in_unconditional_delay() { _flags = _used_in_unconditional_delay; }\n&quot;);
1097   fprintf(fp_hpp, &quot;  void set_used_in_conditional_delay() { _flags = _used_in_conditional_delay; }\n&quot;);
1098   fprintf(fp_hpp, &quot;  void set_used_in_all_conditional_delays() { _flags = _used_in_all_conditional_delays; }\n&quot;);
1099 
1100   fprintf(fp_hpp, &quot;  bool use_nop_delay() { return (_flags == _use_nop_delay); }\n&quot;);
1101   fprintf(fp_hpp, &quot;  bool use_unconditional_delay() { return (_flags == _use_unconditional_delay); }\n&quot;);
1102   fprintf(fp_hpp, &quot;  bool use_conditional_delay() { return (_flags == _use_conditional_delay); }\n&quot;);
1103   fprintf(fp_hpp, &quot;  bool used_in_unconditional_delay() { return (_flags == _used_in_unconditional_delay); }\n&quot;);
1104   fprintf(fp_hpp, &quot;  bool used_in_conditional_delay() { return (_flags == _used_in_conditional_delay); }\n&quot;);
1105   fprintf(fp_hpp, &quot;  bool used_in_all_conditional_delays() { return (_flags == _used_in_all_conditional_delays); }\n&quot;);
1106   fprintf(fp_hpp, &quot;  bool use_delay() { return ((_flags &amp; _use_delay) != 0); }\n&quot;);
1107   fprintf(fp_hpp, &quot;  bool used_in_delay() { return ((_flags &amp; _used_in_delay) != 0); }\n\n&quot;);
1108 
1109   fprintf(fp_hpp, &quot;  enum {\n&quot;);
1110   fprintf(fp_hpp, &quot;    _nop_count = %d\n&quot;,
1111     _pipeline-&gt;_nopcnt);
1112   fprintf(fp_hpp, &quot;  };\n\n&quot;);
1113   fprintf(fp_hpp, &quot;  static void initialize_nops(MachNode *nop_list[%d]);\n\n&quot;,
1114     _pipeline-&gt;_nopcnt);
1115   fprintf(fp_hpp, &quot;#ifndef PRODUCT\n&quot;);
1116   fprintf(fp_hpp, &quot;  void dump(outputStream *st = tty) const;\n&quot;);
1117   fprintf(fp_hpp, &quot;#endif\n&quot;);
1118   fprintf(fp_hpp, &quot;};\n\n&quot;);
1119 
1120 //  const char *classname;
1121 //  for (_pipeline-&gt;_classlist.reset(); (classname = _pipeline-&gt;_classlist.iter()) != NULL; ) {
1122 //    PipeClassForm *pipeclass = _pipeline-&gt;_classdict[classname]-&gt;is_pipeclass();
1123 //    fprintf(fp_hpp, &quot;// Pipeline Class Instance for \&quot;%s\&quot;\n&quot;, classname);
1124 //  }
1125 }
1126 
1127 //------------------------------declareClasses---------------------------------
1128 // Construct the class hierarchy of MachNode classes from the instruction &amp;
1129 // operand lists
1130 void ArchDesc::declareClasses(FILE *fp) {
1131 
1132   // Declare an array containing the machine register names, strings.
1133   declareRegNames(fp, _register);
1134 
1135   // Declare an array containing the machine register encoding values
1136   declareRegEncodes(fp, _register);
1137 
1138   // Generate declarations for the total number of operands
1139   fprintf(fp,&quot;\n&quot;);
1140   fprintf(fp,&quot;// Total number of operands defined in architecture definition\n&quot;);
1141   int num_operands = 0;
1142   OperandForm *op;
1143   for (_operands.reset(); (op = (OperandForm*)_operands.iter()) != NULL; ) {
1144     // Ensure this is a machine-world instruction
1145     if (op-&gt;ideal_only()) continue;
1146 
1147     ++num_operands;
1148   }
1149   int first_operand_class = num_operands;
1150   OpClassForm *opc;
1151   for (_opclass.reset(); (opc = (OpClassForm*)_opclass.iter()) != NULL; ) {
1152     // Ensure this is a machine-world instruction
1153     if (opc-&gt;ideal_only()) continue;
1154 
1155     ++num_operands;
1156   }
1157   fprintf(fp,&quot;#define FIRST_OPERAND_CLASS   %d\n&quot;, first_operand_class);
1158   fprintf(fp,&quot;#define NUM_OPERANDS          %d\n&quot;, num_operands);
1159   fprintf(fp,&quot;\n&quot;);
1160   // Generate declarations for the total number of instructions
1161   fprintf(fp,&quot;// Total number of instructions defined in architecture definition\n&quot;);
1162   fprintf(fp,&quot;#define NUM_INSTRUCTIONS   %d\n&quot;,instructFormCount());
1163 
1164 
1165   // Generate Machine Classes for each operand defined in AD file
1166   fprintf(fp,&quot;\n&quot;);
1167   fprintf(fp,&quot;//----------------------------Declare classes derived from MachOper----------\n&quot;);
1168   // Iterate through all operands
1169   _operands.reset();
1170   OperandForm *oper;
1171   for( ; (oper = (OperandForm*)_operands.iter()) != NULL;) {
1172     // Ensure this is a machine-world instruction
1173     if (oper-&gt;ideal_only() ) continue;
1174     // The declaration of labelOper is in machine-independent file: machnode
1175     if ( strcmp(oper-&gt;_ident,&quot;label&quot;)  == 0 ) continue;
1176     // The declaration of methodOper is in machine-independent file: machnode
1177     if ( strcmp(oper-&gt;_ident,&quot;method&quot;) == 0 ) continue;
1178 
1179     // Build class definition for this operand
1180     fprintf(fp,&quot;\n&quot;);
1181     fprintf(fp,&quot;class %sOper : public MachOper { \n&quot;,oper-&gt;_ident);
1182     fprintf(fp,&quot;private:\n&quot;);
1183     // Operand definitions that depend upon number of input edges
1184     {
1185       uint num_edges = oper-&gt;num_edges(_globalNames);
1186       if( num_edges != 1 ) { // Use MachOper::num_edges() {return 1;}
1187         fprintf(fp,&quot;  virtual uint           num_edges() const { return %d; }\n&quot;,
1188               num_edges );
1189       }
1190       if( num_edges &gt; 0 ) {
1191         in_RegMask(fp);
1192       }
1193     }
1194 
1195     // Support storing constants inside the MachOper
1196     declareConstStorage(fp,_globalNames,oper);
1197 
1198     // Support storage of the condition codes
1199     if( oper-&gt;is_ideal_bool() ) {
1200       fprintf(fp,&quot;  virtual int ccode() const { \n&quot;);
1201       fprintf(fp,&quot;    switch (_c0) {\n&quot;);
1202       fprintf(fp,&quot;    case  BoolTest::eq : return equal();\n&quot;);
1203       fprintf(fp,&quot;    case  BoolTest::gt : return greater();\n&quot;);
1204       fprintf(fp,&quot;    case  BoolTest::lt : return less();\n&quot;);
1205       fprintf(fp,&quot;    case  BoolTest::ne : return not_equal();\n&quot;);
1206       fprintf(fp,&quot;    case  BoolTest::le : return less_equal();\n&quot;);
1207       fprintf(fp,&quot;    case  BoolTest::ge : return greater_equal();\n&quot;);
1208       fprintf(fp,&quot;    case  BoolTest::overflow : return overflow();\n&quot;);
1209       fprintf(fp,&quot;    case  BoolTest::no_overflow: return no_overflow();\n&quot;);
1210       fprintf(fp,&quot;    default : ShouldNotReachHere(); return 0;\n&quot;);
1211       fprintf(fp,&quot;    }\n&quot;);
1212       fprintf(fp,&quot;  };\n&quot;);
1213     }
1214 
1215     // Support storage of the condition codes
1216     if( oper-&gt;is_ideal_bool() ) {
1217       fprintf(fp,&quot;  virtual void negate() { \n&quot;);
1218       fprintf(fp,&quot;    _c0 = (BoolTest::mask)((int)_c0^0x4); \n&quot;);
1219       fprintf(fp,&quot;  };\n&quot;);
1220     }
1221 
1222     // Declare constructor.
1223     // Parameters start with condition code, then all other constants
1224     //
1225     // (1)  MachXOper(int32 ccode, int32 c0, int32 c1, ..., int32 cn)
1226     // (2)     : _ccode(ccode), _c0(c0), _c1(c1), ..., _cn(cn) { }
1227     //
1228     Form::DataType constant_type = oper-&gt;simple_type(_globalNames);
1229     defineConstructor(fp, oper-&gt;_ident, oper-&gt;num_consts(_globalNames),
1230                       oper-&gt;_components, oper-&gt;is_ideal_bool(),
1231                       constant_type, _globalNames);
1232 
1233     // Clone function
1234     fprintf(fp,&quot;  virtual MachOper      *clone() const;\n&quot;);
1235 
1236     // Support setting a spill offset into a constant operand.
1237     // We only support setting an &#39;int&#39; offset, while in the
1238     // LP64 build spill offsets are added with an AddP which
1239     // requires a long constant.  Thus we don&#39;t support spilling
1240     // in frames larger than 4Gig.
1241     if( oper-&gt;has_conI(_globalNames) ||
1242         oper-&gt;has_conL(_globalNames) )
1243       fprintf(fp, &quot;  virtual void set_con( jint c0 ) { _c0 = c0; }\n&quot;);
1244 
1245     // virtual functions for encoding and format
1246     //    fprintf(fp,&quot;  virtual void           encode()   const {\n    %s }\n&quot;,
1247     //            (oper-&gt;_encrule)?(oper-&gt;_encrule-&gt;_encrule):&quot;&quot;);
1248     // Check the interface type, and generate the correct query functions
1249     // encoding queries based upon MEMORY_INTER, REG_INTER, CONST_INTER.
1250 
1251     fprintf(fp,&quot;  virtual uint           opcode() const { return %s; }\n&quot;,
1252             machOperEnum(oper-&gt;_ident));
1253 
1254     // virtual function to look up ideal return type of machine instruction
1255     //
1256     // (1)  virtual const Type    *type() const { return .....; }
1257     //
1258     if ((oper-&gt;_matrule) &amp;&amp; (oper-&gt;_matrule-&gt;_lChild == NULL) &amp;&amp;
1259         (oper-&gt;_matrule-&gt;_rChild == NULL)) {
1260       unsigned int position = 0;
1261       const char  *opret, *opname, *optype;
1262       oper-&gt;_matrule-&gt;base_operand(position,_globalNames,opret,opname,optype);
1263       fprintf(fp,&quot;  virtual const Type    *type() const {&quot;);
1264       const char *type = getIdealType(optype);
1265       if( type != NULL ) {
1266         Form::DataType data_type = oper-&gt;is_base_constant(_globalNames);
1267         // Check if we are an ideal pointer type
1268         if( data_type == Form::idealP || data_type == Form::idealN || data_type == Form::idealNKlass ) {
1269           // Return the ideal type we already have: &lt;TypePtr *&gt;
1270           fprintf(fp,&quot; return _c0;&quot;);
1271         } else {
1272           // Return the appropriate bottom type
1273           fprintf(fp,&quot; return %s;&quot;, getIdealType(optype));
1274         }
1275       } else {
1276         fprintf(fp,&quot; ShouldNotCallThis(); return Type::BOTTOM;&quot;);
1277       }
1278       fprintf(fp,&quot; }\n&quot;);
1279     } else {
1280       // Check for user-defined stack slots, based upon sRegX
1281       Form::DataType data_type = oper-&gt;is_user_name_for_sReg();
1282       if( data_type != Form::none ){
1283         const char *type = NULL;
1284         switch( data_type ) {
1285         case Form::idealI: type = &quot;TypeInt::INT&quot;;   break;
1286         case Form::idealP: type = &quot;TypePtr::BOTTOM&quot;;break;
1287         case Form::idealF: type = &quot;Type::FLOAT&quot;;    break;
1288         case Form::idealD: type = &quot;Type::DOUBLE&quot;;   break;
1289         case Form::idealL: type = &quot;TypeLong::LONG&quot;; break;
1290         case Form::none: // fall through
1291         default:
1292           assert( false, &quot;No support for this type of stackSlot&quot;);
1293         }
1294         fprintf(fp,&quot;  virtual const Type    *type() const { return %s; } // stackSlotX\n&quot;, type);
1295       }
1296     }
1297 
1298 
1299     //
1300     // virtual functions for defining the encoding interface.
1301     //
1302     // Access the linearized ideal register mask,
1303     // map to physical register encoding
1304     if ( oper-&gt;_matrule &amp;&amp; oper-&gt;_matrule-&gt;is_base_register(_globalNames) ) {
1305       // Just use the default virtual &#39;reg&#39; call
1306     } else if ( oper-&gt;ideal_to_sReg_type(oper-&gt;_ident) != Form::none ) {
1307       // Special handling for operand &#39;sReg&#39;, a Stack Slot Register.
1308       // Map linearized ideal register mask to stack slot number
1309       fprintf(fp,&quot;  virtual int            reg(PhaseRegAlloc *ra_, const Node *node) const {\n&quot;);
1310       fprintf(fp,&quot;    return (int)OptoReg::reg2stack(ra_-&gt;get_reg_first(node));/* sReg */\n&quot;);
1311       fprintf(fp,&quot;  }\n&quot;);
1312       fprintf(fp,&quot;  virtual int            reg(PhaseRegAlloc *ra_, const Node *node, int idx) const {\n&quot;);
1313       fprintf(fp,&quot;    return (int)OptoReg::reg2stack(ra_-&gt;get_reg_first(node-&gt;in(idx)));/* sReg */\n&quot;);
1314       fprintf(fp,&quot;  }\n&quot;);
1315     }
1316 
1317     // Output the operand specific access functions used by an enc_class
1318     // These are only defined when we want to override the default virtual func
1319     if (oper-&gt;_interface != NULL) {
1320       fprintf(fp,&quot;\n&quot;);
1321       // Check if it is a Memory Interface
1322       if ( oper-&gt;_interface-&gt;is_MemInterface() != NULL ) {
1323         MemInterface *mem_interface = oper-&gt;_interface-&gt;is_MemInterface();
1324         const char *base = mem_interface-&gt;_base;
1325         if( base != NULL ) {
1326           define_oper_interface(fp, *oper, _globalNames, &quot;base&quot;, base);
1327         }
1328         char *index = mem_interface-&gt;_index;
1329         if( index != NULL ) {
1330           define_oper_interface(fp, *oper, _globalNames, &quot;index&quot;, index);
1331         }
1332         const char *scale = mem_interface-&gt;_scale;
1333         if( scale != NULL ) {
1334           define_oper_interface(fp, *oper, _globalNames, &quot;scale&quot;, scale);
1335         }
1336         const char *disp = mem_interface-&gt;_disp;
1337         if( disp != NULL ) {
1338           define_oper_interface(fp, *oper, _globalNames, &quot;disp&quot;, disp);
1339           oper-&gt;disp_is_oop(fp, _globalNames);
1340         }
1341         if( oper-&gt;stack_slots_only(_globalNames) ) {
1342           // should not call this:
1343           fprintf(fp,&quot;  virtual int       constant_disp() const { return Type::OffsetBot; }&quot;);
1344         } else if ( disp != NULL ) {
1345           define_oper_interface(fp, *oper, _globalNames, &quot;constant_disp&quot;, disp);
1346         }
1347       } // end Memory Interface
1348       // Check if it is a Conditional Interface
1349       else if (oper-&gt;_interface-&gt;is_CondInterface() != NULL) {
1350         CondInterface *cInterface = oper-&gt;_interface-&gt;is_CondInterface();
1351         const char *equal = cInterface-&gt;_equal;
1352         if( equal != NULL ) {
1353           define_oper_interface(fp, *oper, _globalNames, &quot;equal&quot;, equal);
1354         }
1355         const char *not_equal = cInterface-&gt;_not_equal;
1356         if( not_equal != NULL ) {
1357           define_oper_interface(fp, *oper, _globalNames, &quot;not_equal&quot;, not_equal);
1358         }
1359         const char *less = cInterface-&gt;_less;
1360         if( less != NULL ) {
1361           define_oper_interface(fp, *oper, _globalNames, &quot;less&quot;, less);
1362         }
1363         const char *greater_equal = cInterface-&gt;_greater_equal;
1364         if( greater_equal != NULL ) {
1365           define_oper_interface(fp, *oper, _globalNames, &quot;greater_equal&quot;, greater_equal);
1366         }
1367         const char *less_equal = cInterface-&gt;_less_equal;
1368         if( less_equal != NULL ) {
1369           define_oper_interface(fp, *oper, _globalNames, &quot;less_equal&quot;, less_equal);
1370         }
1371         const char *greater = cInterface-&gt;_greater;
1372         if( greater != NULL ) {
1373           define_oper_interface(fp, *oper, _globalNames, &quot;greater&quot;, greater);
1374         }
1375         const char *overflow = cInterface-&gt;_overflow;
1376         if( overflow != NULL ) {
1377           define_oper_interface(fp, *oper, _globalNames, &quot;overflow&quot;, overflow);
1378         }
1379         const char *no_overflow = cInterface-&gt;_no_overflow;
1380         if( no_overflow != NULL ) {
1381           define_oper_interface(fp, *oper, _globalNames, &quot;no_overflow&quot;, no_overflow);
1382         }
1383       } // end Conditional Interface
1384       // Check if it is a Constant Interface
1385       else if (oper-&gt;_interface-&gt;is_ConstInterface() != NULL ) {
1386         assert( oper-&gt;num_consts(_globalNames) == 1,
1387                 &quot;Must have one constant when using CONST_INTER encoding&quot;);
1388         if (!strcmp(oper-&gt;ideal_type(_globalNames), &quot;ConI&quot;)) {
1389           // Access the locally stored constant
1390           fprintf(fp,&quot;  virtual intptr_t       constant() const {&quot;);
1391           fprintf(fp,   &quot; return (intptr_t)_c0;&quot;);
1392           fprintf(fp,&quot;  }\n&quot;);
1393         }
1394         else if (!strcmp(oper-&gt;ideal_type(_globalNames), &quot;ConP&quot;)) {
1395           // Access the locally stored constant
1396           fprintf(fp,&quot;  virtual intptr_t       constant() const {&quot;);
1397           fprintf(fp,   &quot; return _c0-&gt;get_con();&quot;);
1398           fprintf(fp, &quot; }\n&quot;);
1399           // Generate query to determine if this pointer is an oop
1400           fprintf(fp,&quot;  virtual relocInfo::relocType           constant_reloc() const {&quot;);
1401           fprintf(fp,   &quot; return _c0-&gt;reloc();&quot;);
1402           fprintf(fp, &quot; }\n&quot;);
1403         }
1404         else if (!strcmp(oper-&gt;ideal_type(_globalNames), &quot;ConN&quot;)) {
1405           // Access the locally stored constant
1406           fprintf(fp,&quot;  virtual intptr_t       constant() const {&quot;);
1407           fprintf(fp,   &quot; return _c0-&gt;get_ptrtype()-&gt;get_con();&quot;);
1408           fprintf(fp, &quot; }\n&quot;);
1409           // Generate query to determine if this pointer is an oop
1410           fprintf(fp,&quot;  virtual relocInfo::relocType           constant_reloc() const {&quot;);
1411           fprintf(fp,   &quot; return _c0-&gt;get_ptrtype()-&gt;reloc();&quot;);
1412           fprintf(fp, &quot; }\n&quot;);
1413         }
1414         else if (!strcmp(oper-&gt;ideal_type(_globalNames), &quot;ConNKlass&quot;)) {
1415           // Access the locally stored constant
1416           fprintf(fp,&quot;  virtual intptr_t       constant() const {&quot;);
1417           fprintf(fp,   &quot; return _c0-&gt;get_ptrtype()-&gt;get_con();&quot;);
1418           fprintf(fp, &quot; }\n&quot;);
1419           // Generate query to determine if this pointer is an oop
1420           fprintf(fp,&quot;  virtual relocInfo::relocType           constant_reloc() const {&quot;);
1421           fprintf(fp,   &quot; return _c0-&gt;get_ptrtype()-&gt;reloc();&quot;);
1422           fprintf(fp, &quot; }\n&quot;);
1423         }
1424         else if (!strcmp(oper-&gt;ideal_type(_globalNames), &quot;ConL&quot;)) {
1425           fprintf(fp,&quot;  virtual intptr_t       constant() const {&quot;);
1426           // We don&#39;t support addressing modes with &gt; 4Gig offsets.
1427           // Truncate to int.
1428           fprintf(fp,   &quot;  return (intptr_t)_c0;&quot;);
1429           fprintf(fp, &quot; }\n&quot;);
1430           fprintf(fp,&quot;  virtual jlong          constantL() const {&quot;);
1431           fprintf(fp,   &quot; return _c0;&quot;);
1432           fprintf(fp, &quot; }\n&quot;);
1433         }
1434         else if (!strcmp(oper-&gt;ideal_type(_globalNames), &quot;ConF&quot;)) {
1435           fprintf(fp,&quot;  virtual intptr_t       constant() const {&quot;);
1436           fprintf(fp,   &quot; ShouldNotReachHere(); return 0; &quot;);
1437           fprintf(fp, &quot; }\n&quot;);
1438           fprintf(fp,&quot;  virtual jfloat         constantF() const {&quot;);
1439           fprintf(fp,   &quot; return (jfloat)_c0;&quot;);
1440           fprintf(fp, &quot; }\n&quot;);
1441         }
1442         else if (!strcmp(oper-&gt;ideal_type(_globalNames), &quot;ConD&quot;)) {
1443           fprintf(fp,&quot;  virtual intptr_t       constant() const {&quot;);
1444           fprintf(fp,   &quot; ShouldNotReachHere(); return 0; &quot;);
1445           fprintf(fp, &quot; }\n&quot;);
1446           fprintf(fp,&quot;  virtual jdouble        constantD() const {&quot;);
1447           fprintf(fp,   &quot; return _c0;&quot;);
1448           fprintf(fp, &quot; }\n&quot;);
1449         }
1450       }
1451       else if (oper-&gt;_interface-&gt;is_RegInterface() != NULL) {
1452         // make sure that a fixed format string isn&#39;t used for an
1453         // operand which might be assiged to multiple registers.
1454         // Otherwise the opto assembly output could be misleading.
1455         if (oper-&gt;_format-&gt;_strings.count() != 0 &amp;&amp; !oper-&gt;is_bound_register()) {
1456           syntax_err(oper-&gt;_linenum,
1457                      &quot;Only bound registers can have fixed formats: %s\n&quot;,
1458                      oper-&gt;_ident);
1459         }
1460       }
1461       else {
1462         assert( false, &quot;ShouldNotReachHere();&quot;);
1463       }
1464     }
1465 
1466     fprintf(fp,&quot;\n&quot;);
1467     // // Currently all XXXOper::hash() methods are identical (990820)
1468     // declare_hash(fp);
1469     // // Currently all XXXOper::Cmp() methods are identical (990820)
1470     // declare_cmp(fp);
1471 
1472     // Do not place dump_spec() and Name() into PRODUCT code
1473     // int_format and ext_format are not needed in PRODUCT code either
1474     fprintf(fp, &quot;#ifndef PRODUCT\n&quot;);
1475 
1476     // Declare int_format() and ext_format()
1477     gen_oper_format(fp, _globalNames, *oper);
1478 
1479     // Machine independent print functionality for debugging
1480     // IF we have constants, create a dump_spec function for the derived class
1481     //
1482     // (1)  virtual void           dump_spec() const {
1483     // (2)    st-&gt;print(&quot;#%d&quot;, _c#);        // Constant != ConP
1484     //  OR    _c#-&gt;dump_on(st);             // Type ConP
1485     //  ...
1486     // (3)  }
1487     uint num_consts = oper-&gt;num_consts(_globalNames);
1488     if( num_consts &gt; 0 ) {
1489       // line (1)
1490       fprintf(fp, &quot;  virtual void           dump_spec(outputStream *st) const {\n&quot;);
1491       // generate format string for st-&gt;print
1492       // Iterate over the component list &amp; spit out the right thing
1493       uint i = 0;
1494       const char *type = oper-&gt;ideal_type(_globalNames);
1495       Component  *comp;
1496       oper-&gt;_components.reset();
1497       if ((comp = oper-&gt;_components.iter()) == NULL) {
1498         assert(num_consts == 1, &quot;Bad component list detected.\n&quot;);
1499         i = dump_spec_constant( fp, type, i, oper );
1500         // Check that type actually matched
1501         assert( i != 0, &quot;Non-constant operand lacks component list.&quot;);
1502       } // end if NULL
1503       else {
1504         // line (2)
1505         // dump all components
1506         oper-&gt;_components.reset();
1507         while((comp = oper-&gt;_components.iter()) != NULL) {
1508           type = comp-&gt;base_type(_globalNames);
1509           i = dump_spec_constant( fp, type, i, NULL );
1510         }
1511       }
1512       // finish line (3)
1513       fprintf(fp,&quot;  }\n&quot;);
1514     }
1515 
1516     fprintf(fp,&quot;  virtual const char    *Name() const { return \&quot;%s\&quot;;}\n&quot;,
1517             oper-&gt;_ident);
1518 
1519     fprintf(fp,&quot;#endif\n&quot;);
1520 
1521     // Close definition of this XxxMachOper
1522     fprintf(fp,&quot;};\n&quot;);
1523   }
1524 
1525 
1526   // Generate Machine Classes for each instruction defined in AD file
1527   fprintf(fp,&quot;\n&quot;);
1528   fprintf(fp,&quot;//----------------------------Declare classes for Pipelines-----------------\n&quot;);
1529   declare_pipe_classes(fp);
1530 
1531   // Generate Machine Classes for each instruction defined in AD file
1532   fprintf(fp,&quot;\n&quot;);
1533   fprintf(fp,&quot;//----------------------------Declare classes derived from MachNode----------\n&quot;);
1534   _instructions.reset();
1535   InstructForm *instr;
1536   for( ; (instr = (InstructForm*)_instructions.iter()) != NULL; ) {
1537     // Ensure this is a machine-world instruction
1538     if ( instr-&gt;ideal_only() ) continue;
1539 
1540     // Build class definition for this instruction
1541     fprintf(fp,&quot;\n&quot;);
1542     fprintf(fp,&quot;class %sNode : public %s { \n&quot;,
1543             instr-&gt;_ident, instr-&gt;mach_base_class(_globalNames) );
1544     fprintf(fp,&quot;private:\n&quot;);
1545     fprintf(fp,&quot;  MachOper *_opnd_array[%d];\n&quot;, instr-&gt;num_opnds() );
1546     if ( instr-&gt;is_ideal_jump() ) {
1547       fprintf(fp, &quot;  GrowableArray&lt;Label*&gt; _index2label;\n&quot;);
1548     }
1549 
1550     fprintf(fp, &quot;public:\n&quot;);
1551 
1552     Attribute *att = instr-&gt;_attribs;
1553     // Fields of the node specified in the ad file.
1554     while (att != NULL) {
1555       if (strncmp(att-&gt;_ident, &quot;ins_field_&quot;, 10) == 0) {
1556         const char *field_name = att-&gt;_ident+10;
1557         const char *field_type = att-&gt;_val;
1558         fprintf(fp, &quot;  %s _%s;\n&quot;, field_type, field_name);
1559       }
1560       att = (Attribute *)att-&gt;_next;
1561     }
1562 
1563     fprintf(fp,&quot;  MachOper *opnd_array(uint operand_index) const {\n&quot;);
1564     fprintf(fp,&quot;    assert(operand_index &lt; _num_opnds, \&quot;invalid _opnd_array index\&quot;);\n&quot;);
1565     fprintf(fp,&quot;    return _opnd_array[operand_index];\n&quot;);
1566     fprintf(fp,&quot;  }\n&quot;);
1567     fprintf(fp,&quot;  void      set_opnd_array(uint operand_index, MachOper *operand) {\n&quot;);
1568     fprintf(fp,&quot;    assert(operand_index &lt; _num_opnds, \&quot;invalid _opnd_array index\&quot;);\n&quot;);
1569     fprintf(fp,&quot;    _opnd_array[operand_index] = operand;\n&quot;);
1570     fprintf(fp,&quot;  }\n&quot;);
1571     fprintf(fp,&quot;  virtual uint           rule() const { return %s_rule; }\n&quot;,
1572             instr-&gt;_ident);
1573     fprintf(fp,&quot;private:\n&quot;);
1574     if ( instr-&gt;is_ideal_jump() ) {
1575       fprintf(fp,&quot;  virtual void           add_case_label(int index_num, Label* blockLabel) {\n&quot;);
1576       fprintf(fp,&quot;    _index2label.at_put_grow(index_num, blockLabel);\n&quot;);
1577       fprintf(fp,&quot;  }\n&quot;);
1578     }
1579     if( can_cisc_spill() &amp;&amp; (instr-&gt;cisc_spill_alternate() != NULL) ) {
1580       fprintf(fp,&quot;  const RegMask  *_cisc_RegMask;\n&quot;);
1581     }
1582 
1583     out_RegMask(fp);                      // output register mask
1584 
1585     // If this instruction contains a labelOper
1586     // Declare Node::methods that set operand Label&#39;s contents
1587     int label_position = instr-&gt;label_position();
1588     if( label_position != -1 ) {
1589       // Set/Save the label, stored in labelOper::_branch_label
1590       fprintf(fp,&quot;  virtual void           label_set( Label* label, uint block_num );\n&quot;);
1591       fprintf(fp,&quot;  virtual void           save_label( Label** label, uint* block_num );\n&quot;);
1592     }
1593 
1594     // If this instruction contains a methodOper
1595     // Declare Node::methods that set operand method&#39;s contents
1596     int method_position = instr-&gt;method_position();
1597     if( method_position != -1 ) {
1598       // Set the address method, stored in methodOper::_method
1599       fprintf(fp,&quot;  virtual void           method_set( intptr_t method );\n&quot;);
1600     }
1601 
1602     // virtual functions for attributes
1603     //
1604     // Each instruction attribute results in a virtual call of same name.
1605     // The ins_cost is not handled here.
1606     Attribute *attr = instr-&gt;_attribs;
1607     Attribute *avoid_back_to_back_attr = NULL;
1608     while (attr != NULL) {
1609       if (strcmp (attr-&gt;_ident, &quot;ins_is_TrapBasedCheckNode&quot;) == 0) {
1610         fprintf(fp, &quot;  virtual bool           is_TrapBasedCheckNode() const { return %s; }\n&quot;, attr-&gt;_val);
1611       } else if (strcmp (attr-&gt;_ident, &quot;ins_cost&quot;) != 0 &amp;&amp;
1612           strncmp(attr-&gt;_ident, &quot;ins_field_&quot;, 10) != 0 &amp;&amp;
1613           // Must match function in node.hpp: return type bool, no prefix &quot;ins_&quot;.
1614           strcmp (attr-&gt;_ident, &quot;ins_is_TrapBasedCheckNode&quot;) != 0 &amp;&amp;
1615           strcmp (attr-&gt;_ident, &quot;ins_short_branch&quot;) != 0) {
1616         fprintf(fp, &quot;  virtual int            %s() const { return %s; }\n&quot;, attr-&gt;_ident, attr-&gt;_val);
1617       }
1618       if (strcmp(attr-&gt;_ident, &quot;ins_avoid_back_to_back&quot;) == 0) {
1619         avoid_back_to_back_attr = attr;
1620       }
1621       attr = (Attribute *)attr-&gt;_next;
1622     }
1623 
1624     // virtual functions for encode and format
1625 
1626     // Virtual function for evaluating the constant.
1627     if (instr-&gt;is_mach_constant()) {
1628       fprintf(fp,&quot;  virtual void           eval_constant(Compile* C);\n&quot;);
1629     }
1630 
1631     // Output the opcode function and the encode function here using the
1632     // encoding class information in the _insencode slot.
1633     if ( instr-&gt;_insencode ) {
1634       if (instr-&gt;postalloc_expands()) {
1635         fprintf(fp,&quot;  virtual bool           requires_postalloc_expand() const { return true; }\n&quot;);
1636         fprintf(fp,&quot;  virtual void           postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_);\n&quot;);
1637       } else {
1638         fprintf(fp,&quot;  virtual void           emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;\n&quot;);
1639       }
1640     }
1641 
1642     // virtual function for getting the size of an instruction
1643     if ( instr-&gt;_size ) {
1644       fprintf(fp,&quot;  virtual uint           size(PhaseRegAlloc *ra_) const;\n&quot;);
1645     }
1646 
1647     // Return the top-level ideal opcode.
1648     // Use MachNode::ideal_Opcode() for nodes based on MachNode class
1649     // if the ideal_Opcode == Op_Node.
1650     if ( strcmp(&quot;Node&quot;, instr-&gt;ideal_Opcode(_globalNames)) != 0 ||
1651          strcmp(&quot;MachNode&quot;, instr-&gt;mach_base_class(_globalNames)) != 0 ) {
1652       fprintf(fp,&quot;  virtual int            ideal_Opcode() const { return Op_%s; }\n&quot;,
1653             instr-&gt;ideal_Opcode(_globalNames) );
1654     }
1655 
1656     if (instr-&gt;needs_constant_base() &amp;&amp;
1657         !instr-&gt;is_mach_constant()) {  // These inherit the funcion from MachConstantNode.
1658       fprintf(fp,&quot;  virtual uint           mach_constant_base_node_input() const { &quot;);
1659       if (instr-&gt;is_ideal_call() != Form::invalid_type &amp;&amp;
1660           instr-&gt;is_ideal_call() != Form::JAVA_LEAF) {
1661         // MachConstantBase goes behind arguments, but before jvms.
1662         fprintf(fp,&quot;assert(tf() &amp;&amp; tf()-&gt;domain(), \&quot;\&quot;); return tf()-&gt;domain()-&gt;cnt();&quot;);
1663       } else {
1664         fprintf(fp,&quot;return req()-1;&quot;);
1665       }
1666       fprintf(fp,&quot; }\n&quot;);
1667     }
1668 
1669     // Allow machine-independent optimization, invert the sense of the IF test
1670     if( instr-&gt;is_ideal_if() ) {
1671       fprintf(fp,&quot;  virtual void           negate() { \n&quot;);
1672       // Identify which operand contains the negate(able) ideal condition code
1673       int   idx = 0;
1674       instr-&gt;_components.reset();
1675       for( Component *comp; (comp = instr-&gt;_components.iter()) != NULL; ) {
1676         // Check that component is an operand
1677         Form *form = (Form*)_globalNames[comp-&gt;_type];
1678         OperandForm *opForm = form ? form-&gt;is_operand() : NULL;
1679         if( opForm == NULL ) continue;
1680 
1681         // Lookup the position of the operand in the instruction.
1682         if( opForm-&gt;is_ideal_bool() ) {
1683           idx = instr-&gt;operand_position(comp-&gt;_name, comp-&gt;_usedef);
1684           assert( idx != NameList::Not_in_list, &quot;Did not find component in list that contained it.&quot;);
1685           break;
1686         }
1687       }
1688       fprintf(fp,&quot;    opnd_array(%d)-&gt;negate();\n&quot;, idx);
1689       fprintf(fp,&quot;    _prob = 1.0f - _prob;\n&quot;);
1690       fprintf(fp,&quot;  };\n&quot;);
1691     }
1692 
1693 
1694     // Identify which input register matches the input register.
1695     uint  matching_input = instr-&gt;two_address(_globalNames);
1696 
1697     // Generate the method if it returns != 0 otherwise use MachNode::two_adr()
1698     if( matching_input != 0 ) {
1699       fprintf(fp,&quot;  virtual uint           two_adr() const  &quot;);
1700       fprintf(fp,&quot;{ return oper_input_base()&quot;);
1701       for( uint i = 2; i &lt;= matching_input; i++ )
1702         fprintf(fp,&quot; + opnd_array(%d)-&gt;num_edges()&quot;,i-1);
1703       fprintf(fp,&quot;; }\n&quot;);
1704     }
1705 
1706     // Declare cisc_version, if applicable
1707     //   MachNode *cisc_version( int offset /* ,... */ );
1708     instr-&gt;declare_cisc_version(*this, fp);
1709 
1710     // If there is an explicit peephole rule, build it
1711     if ( instr-&gt;peepholes() != NULL ) {
1712       fprintf(fp,&quot;  virtual MachNode      *peephole(Block *block, int block_index, PhaseRegAlloc *ra_, int &amp;deleted);\n&quot;);
1713     }
1714 
1715     // Output the declaration for number of relocation entries
1716     if ( instr-&gt;reloc(_globalNames) != 0 ) {
1717       fprintf(fp,&quot;  virtual int            reloc() const;\n&quot;);
1718     }
1719 
1720     if (instr-&gt;alignment() != 1) {
1721       fprintf(fp,&quot;  virtual int            alignment_required() const { return %d; }\n&quot;, instr-&gt;alignment());
1722       fprintf(fp,&quot;  virtual int            compute_padding(int current_offset) const;\n&quot;);
1723     }
1724 
1725     // Starting point for inputs matcher wants.
1726     // Use MachNode::oper_input_base() for nodes based on MachNode class
1727     // if the base == 1.
1728     if ( instr-&gt;oper_input_base(_globalNames) != 1 ||
1729          strcmp(&quot;MachNode&quot;, instr-&gt;mach_base_class(_globalNames)) != 0 ) {
1730       fprintf(fp,&quot;  virtual uint           oper_input_base() const { return %d; }\n&quot;,
1731             instr-&gt;oper_input_base(_globalNames));
1732     }
1733 
1734     // Make the constructor and following methods &#39;public:&#39;
1735     fprintf(fp,&quot;public:\n&quot;);
1736 
1737     // Constructor
1738     if ( instr-&gt;is_ideal_jump() ) {
1739       fprintf(fp,&quot;  %sNode() : _index2label(MinJumpTableSize*2) { &quot;, instr-&gt;_ident);
1740     } else {
1741       fprintf(fp,&quot;  %sNode() { &quot;, instr-&gt;_ident);
1742       if( can_cisc_spill() &amp;&amp; (instr-&gt;cisc_spill_alternate() != NULL) ) {
1743         fprintf(fp,&quot;_cisc_RegMask = NULL; &quot;);
1744       }
1745     }
1746 
1747     fprintf(fp,&quot; _num_opnds = %d; _opnds = _opnd_array; &quot;, instr-&gt;num_opnds());
1748 
1749     bool node_flags_set = false;
1750     // flag: if this instruction matches an ideal &#39;Copy*&#39; node
1751     if ( instr-&gt;is_ideal_copy() != 0 ) {
1752       fprintf(fp,&quot;init_flags(Flag_is_Copy&quot;);
1753       node_flags_set = true;
1754     }
1755 
1756     // Is an instruction is a constant?  If so, get its type
1757     Form::DataType  data_type;
1758     const char     *opType = NULL;
1759     const char     *result = NULL;
1760     data_type    = instr-&gt;is_chain_of_constant(_globalNames, opType, result);
1761     // Check if this instruction is a constant
1762     if ( data_type != Form::none ) {
1763       if ( node_flags_set ) {
1764         fprintf(fp,&quot; | Flag_is_Con&quot;);
1765       } else {
1766         fprintf(fp,&quot;init_flags(Flag_is_Con&quot;);
1767         node_flags_set = true;
1768       }
1769     }
1770 
1771     // flag: if this instruction is cisc alternate
1772     if ( can_cisc_spill() &amp;&amp; instr-&gt;is_cisc_alternate() ) {
1773       if ( node_flags_set ) {
1774         fprintf(fp,&quot; | Flag_is_cisc_alternate&quot;);
1775       } else {
1776         fprintf(fp,&quot;init_flags(Flag_is_cisc_alternate&quot;);
1777         node_flags_set = true;
1778       }
1779     }
1780 
1781     // flag: if this instruction has short branch form
1782     if ( instr-&gt;has_short_branch_form() ) {
1783       if ( node_flags_set ) {
1784         fprintf(fp,&quot; | Flag_may_be_short_branch&quot;);
1785       } else {
1786         fprintf(fp,&quot;init_flags(Flag_may_be_short_branch&quot;);
1787         node_flags_set = true;
1788       }
1789     }
1790 
1791     // flag: if this instruction should not be generated back to back.
1792     if (avoid_back_to_back_attr != NULL) {
1793       if (node_flags_set) {
1794         fprintf(fp,&quot; | (%s)&quot;, avoid_back_to_back_attr-&gt;_val);
1795       } else {
1796         fprintf(fp,&quot;init_flags((%s)&quot;, avoid_back_to_back_attr-&gt;_val);
1797         node_flags_set = true;
1798       }
1799     }
1800 
1801     // Check if machine instructions that USE memory, but do not DEF memory,
1802     // depend upon a node that defines memory in machine-independent graph.
1803     if ( instr-&gt;needs_anti_dependence_check(_globalNames) ) {
1804       if ( node_flags_set ) {
1805         fprintf(fp,&quot; | Flag_needs_anti_dependence_check&quot;);
1806       } else {
1807         fprintf(fp,&quot;init_flags(Flag_needs_anti_dependence_check&quot;);
1808         node_flags_set = true;
1809       }
1810     }
1811 
1812     // flag: if this instruction is implemented with a call
1813     if ( instr-&gt;_has_call ) {
1814       if ( node_flags_set ) {
1815         fprintf(fp,&quot; | Flag_has_call&quot;);
1816       } else {
1817         fprintf(fp,&quot;init_flags(Flag_has_call&quot;);
1818         node_flags_set = true;
1819       }
1820     }
1821 
1822     if ( node_flags_set ) {
1823       fprintf(fp,&quot;); &quot;);
1824     }
1825 
1826     fprintf(fp,&quot;}\n&quot;);
1827 
1828     // size_of, used by base class&#39;s clone to obtain the correct size.
1829     fprintf(fp,&quot;  virtual uint           size_of() const {&quot;);
1830     fprintf(fp,   &quot; return sizeof(%sNode);&quot;, instr-&gt;_ident);
1831     fprintf(fp, &quot; }\n&quot;);
1832 
1833     // Virtual methods which are only generated to override base class
1834     if( instr-&gt;expands() || instr-&gt;needs_projections() ||
1835         instr-&gt;has_temps() ||
1836         instr-&gt;is_mach_constant() ||
1837         instr-&gt;needs_constant_base() ||
1838         (instr-&gt;_matrule != NULL &amp;&amp;
1839          instr-&gt;num_opnds() != instr-&gt;num_unique_opnds()) ) {
1840       fprintf(fp,&quot;  virtual MachNode      *Expand(State *state, Node_List &amp;proj_list, Node* mem);\n&quot;);
1841     }
1842 
1843     if (instr-&gt;is_pinned(_globalNames)) {
1844       fprintf(fp,&quot;  virtual bool           pinned() const { return &quot;);
1845       if (instr-&gt;is_parm(_globalNames)) {
1846         fprintf(fp,&quot;_in[0]-&gt;pinned();&quot;);
1847       } else {
1848         fprintf(fp,&quot;true;&quot;);
1849       }
1850       fprintf(fp,&quot; }\n&quot;);
1851     }
1852     if (instr-&gt;is_projection(_globalNames)) {
1853       fprintf(fp,&quot;  virtual const Node *is_block_proj() const { return this; }\n&quot;);
1854     }
1855     if ( instr-&gt;num_post_match_opnds() != 0
1856          || instr-&gt;is_chain_of_constant(_globalNames) ) {
1857       fprintf(fp,&quot;  friend MachNode *State::MachNodeGenerator(int opcode);\n&quot;);
1858     }
1859     if ( instr-&gt;rematerialize(_globalNames, get_registers()) ) {
1860       fprintf(fp,&quot;  // Rematerialize %s\n&quot;, instr-&gt;_ident);
1861     }
1862 
1863     // Declare short branch methods, if applicable
1864     instr-&gt;declare_short_branch_methods(fp);
1865 
1866     // See if there is an &quot;ins_pipe&quot; declaration for this instruction
1867     if (instr-&gt;_ins_pipe) {
1868       fprintf(fp,&quot;  static  const Pipeline *pipeline_class();\n&quot;);
1869       fprintf(fp,&quot;  virtual const Pipeline *pipeline() const;\n&quot;);
1870     }
1871 
1872     // Generate virtual function for MachNodeX::bottom_type when necessary
1873     //
1874     // Note on accuracy:  Pointer-types of machine nodes need to be accurate,
1875     // or else alias analysis on the matched graph may produce bad code.
1876     // Moreover, the aliasing decisions made on machine-node graph must be
1877     // no less accurate than those made on the ideal graph, or else the graph
1878     // may fail to schedule.  (Reason:  Memory ops which are reordered in
1879     // the ideal graph might look interdependent in the machine graph,
1880     // thereby removing degrees of scheduling freedom that the optimizer
1881     // assumed would be available.)
1882     //
1883     // %%% We should handle many of these cases with an explicit ADL clause:
1884     // instruct foo() %{ ... bottom_type(TypeRawPtr::BOTTOM); ... %}
1885     if( data_type != Form::none ) {
1886       // A constant&#39;s bottom_type returns a Type containing its constant value
1887 
1888       // !!!!!
1889       // Convert all ints, floats, ... to machine-independent TypeXs
1890       // as is done for pointers
1891       //
1892       // Construct appropriate constant type containing the constant value.
1893       fprintf(fp,&quot;  virtual const class Type *bottom_type() const {\n&quot;);
1894       switch( data_type ) {
1895       case Form::idealI:
1896         fprintf(fp,&quot;    return  TypeInt::make(opnd_array(1)-&gt;constant());\n&quot;);
1897         break;
1898       case Form::idealP:
1899       case Form::idealN:
1900       case Form::idealNKlass:
1901         fprintf(fp,&quot;    return  opnd_array(1)-&gt;type();\n&quot;);
1902         break;
1903       case Form::idealD:
1904         fprintf(fp,&quot;    return  TypeD::make(opnd_array(1)-&gt;constantD());\n&quot;);
1905         break;
1906       case Form::idealF:
1907         fprintf(fp,&quot;    return  TypeF::make(opnd_array(1)-&gt;constantF());\n&quot;);
1908         break;
1909       case Form::idealL:
1910         fprintf(fp,&quot;    return  TypeLong::make(opnd_array(1)-&gt;constantL());\n&quot;);
1911         break;
1912       default:
1913         assert( false, &quot;Unimplemented()&quot; );
1914         break;
1915       }
1916       fprintf(fp,&quot;  };\n&quot;);
1917     }
1918 /*    else if ( instr-&gt;_matrule &amp;&amp; instr-&gt;_matrule-&gt;_rChild &amp;&amp;
1919         (  strcmp(&quot;ConvF2I&quot;,instr-&gt;_matrule-&gt;_rChild-&gt;_opType)==0
1920         || strcmp(&quot;ConvD2I&quot;,instr-&gt;_matrule-&gt;_rChild-&gt;_opType)==0 ) ) {
1921       // !!!!! !!!!!
1922       // Provide explicit bottom type for conversions to int
1923       // On Intel the result operand is a stackSlot, untyped.
1924       fprintf(fp,&quot;  virtual const class Type *bottom_type() const {&quot;);
1925       fprintf(fp,   &quot; return  TypeInt::INT;&quot;);
1926       fprintf(fp, &quot; };\n&quot;);
1927     }*/
1928     else if( instr-&gt;is_ideal_copy() &amp;&amp;
1929               !strcmp(instr-&gt;_matrule-&gt;_lChild-&gt;_opType,&quot;stackSlotP&quot;) ) {
1930       // !!!!!
1931       // Special hack for ideal Copy of pointer.  Bottom type is oop or not depending on input.
1932       fprintf(fp,&quot;  const Type            *bottom_type() const { return in(1)-&gt;bottom_type(); } // Copy?\n&quot;);
1933     }
1934     else if( instr-&gt;is_ideal_loadPC() ) {
1935       // LoadPCNode provides the return address of a call to native code.
1936       // Define its bottom type to be TypeRawPtr::BOTTOM instead of TypePtr::BOTTOM
1937       // since it is a pointer to an internal VM location and must have a zero offset.
1938       // Allocation detects derived pointers, in part, by their non-zero offsets.
1939       fprintf(fp,&quot;  const Type            *bottom_type() const { return TypeRawPtr::BOTTOM; } // LoadPC?\n&quot;);
1940     }
1941     else if( instr-&gt;is_ideal_box() ) {
1942       // BoxNode provides the address of a stack slot.
1943       // Define its bottom type to be TypeRawPtr::BOTTOM instead of TypePtr::BOTTOM
1944       // This prevent s insert_anti_dependencies from complaining. It will
1945       // complain if it sees that the pointer base is TypePtr::BOTTOM since
1946       // it doesn&#39;t understand what that might alias.
1947       fprintf(fp,&quot;  const Type            *bottom_type() const { return TypeRawPtr::BOTTOM; } // Box?\n&quot;);
1948     }
1949     else if( instr-&gt;_matrule &amp;&amp; instr-&gt;_matrule-&gt;_rChild &amp;&amp; !strcmp(instr-&gt;_matrule-&gt;_rChild-&gt;_opType,&quot;CMoveP&quot;) ) {
1950       int offset = 1;
1951       // Special special hack to see if the Cmp? has been incorporated in the conditional move
1952       MatchNode *rl = instr-&gt;_matrule-&gt;_rChild-&gt;_lChild;
1953       if( rl &amp;&amp; !strcmp(rl-&gt;_opType, &quot;Binary&quot;) ) {
1954           MatchNode *rlr = rl-&gt;_rChild;
1955           if (rlr &amp;&amp; strncmp(rlr-&gt;_opType, &quot;Cmp&quot;, 3) == 0)
1956             offset = 2;
1957       }
1958       // Special hack for ideal CMoveP; ideal type depends on inputs
1959       fprintf(fp,&quot;  const Type            *bottom_type() const { const Type *t = in(oper_input_base()+%d)-&gt;bottom_type(); return (req() &lt;= oper_input_base()+%d) ? t : t-&gt;meet(in(oper_input_base()+%d)-&gt;bottom_type()); } // CMoveP\n&quot;,
1960         offset, offset+1, offset+1);
1961     }
1962     else if( instr-&gt;_matrule &amp;&amp; instr-&gt;_matrule-&gt;_rChild &amp;&amp; !strcmp(instr-&gt;_matrule-&gt;_rChild-&gt;_opType,&quot;CMoveN&quot;) ) {
1963       int offset = 1;
1964       // Special special hack to see if the Cmp? has been incorporated in the conditional move
1965       MatchNode *rl = instr-&gt;_matrule-&gt;_rChild-&gt;_lChild;
1966       if( rl &amp;&amp; !strcmp(rl-&gt;_opType, &quot;Binary&quot;) ) {
1967           MatchNode *rlr = rl-&gt;_rChild;
1968           if (rlr &amp;&amp; strncmp(rlr-&gt;_opType, &quot;Cmp&quot;, 3) == 0)
1969             offset = 2;
1970       }
1971       // Special hack for ideal CMoveN; ideal type depends on inputs
1972       fprintf(fp,&quot;  const Type            *bottom_type() const { const Type *t = in(oper_input_base()+%d)-&gt;bottom_type(); return (req() &lt;= oper_input_base()+%d) ? t : t-&gt;meet(in(oper_input_base()+%d)-&gt;bottom_type()); } // CMoveN\n&quot;,
1973         offset, offset+1, offset+1);
1974     }
1975     else if (instr-&gt;is_tls_instruction()) {
1976       // Special hack for tlsLoadP
1977       fprintf(fp,&quot;  const Type            *bottom_type() const { return TypeRawPtr::BOTTOM; } // tlsLoadP\n&quot;);
1978     }
1979     else if ( instr-&gt;is_ideal_if() ) {
1980       fprintf(fp,&quot;  const Type            *bottom_type() const { return TypeTuple::IFBOTH; } // matched IfNode\n&quot;);
1981     }
1982     else if ( instr-&gt;is_ideal_membar() ) {
1983       fprintf(fp,&quot;  const Type            *bottom_type() const { return TypeTuple::MEMBAR; } // matched MemBar\n&quot;);
1984     }
1985 
1986     // Check where &#39;ideal_type&#39; must be customized
1987     /*
1988     if ( instr-&gt;_matrule &amp;&amp; instr-&gt;_matrule-&gt;_rChild &amp;&amp;
1989         (  strcmp(&quot;ConvF2I&quot;,instr-&gt;_matrule-&gt;_rChild-&gt;_opType)==0
1990         || strcmp(&quot;ConvD2I&quot;,instr-&gt;_matrule-&gt;_rChild-&gt;_opType)==0 ) ) {
1991       fprintf(fp,&quot;  virtual uint           ideal_reg() const { return Compile::current()-&gt;matcher()-&gt;base2reg[Type::Int]; }\n&quot;);
1992     }*/
1993 
1994     // Analyze machine instructions that either USE or DEF memory.
1995     int memory_operand = instr-&gt;memory_operand(_globalNames);
1996     if ( memory_operand != InstructForm::NO_MEMORY_OPERAND ) {
1997       if( memory_operand == InstructForm::MANY_MEMORY_OPERANDS ) {
1998         fprintf(fp,&quot;  virtual const TypePtr *adr_type() const;\n&quot;);
1999       }
2000       fprintf(fp,&quot;  virtual const MachOper *memory_operand() const;\n&quot;);
2001     }
2002 
2003     fprintf(fp, &quot;#ifndef PRODUCT\n&quot;);
2004 
2005     // virtual function for generating the user&#39;s assembler output
2006     gen_inst_format(fp, _globalNames,*instr);
2007 
2008     // Machine independent print functionality for debugging
2009     fprintf(fp,&quot;  virtual const char    *Name() const { return \&quot;%s\&quot;;}\n&quot;,
2010             instr-&gt;_ident);
2011 
2012     fprintf(fp, &quot;#endif\n&quot;);
2013 
2014     // Close definition of this XxxMachNode
2015     fprintf(fp,&quot;};\n&quot;);
2016   };
2017 
2018 }
2019 
2020 void ArchDesc::defineStateClass(FILE *fp) {
2021   static const char *state__valid    = &quot;_valid[((uint)index) &gt;&gt; 5] &amp;  (0x1 &lt;&lt; (((uint)index) &amp; 0x0001F))&quot;;
2022   static const char *state__set_valid= &quot;_valid[((uint)index) &gt;&gt; 5] |= (0x1 &lt;&lt; (((uint)index) &amp; 0x0001F))&quot;;
2023 
2024   fprintf(fp,&quot;\n&quot;);
2025   fprintf(fp,&quot;// MACROS to inline and constant fold State::valid(index)...\n&quot;);
2026   fprintf(fp,&quot;// when given a constant &#39;index&#39; in dfa_&lt;arch&gt;.cpp\n&quot;);
2027   fprintf(fp,&quot;//   uint word   = index &gt;&gt; 5;       // Shift out bit position\n&quot;);
2028   fprintf(fp,&quot;//   uint bitpos = index &amp; 0x0001F;  // Mask off word bits\n&quot;);
2029   fprintf(fp,&quot;#define STATE__VALID(index) &quot;);
2030   fprintf(fp,&quot;    (%s)\n&quot;, state__valid);
2031   fprintf(fp,&quot;\n&quot;);
2032   fprintf(fp,&quot;#define STATE__NOT_YET_VALID(index) &quot;);
2033   fprintf(fp,&quot;  ( (%s) == 0 )\n&quot;, state__valid);
2034   fprintf(fp,&quot;\n&quot;);
2035   fprintf(fp,&quot;#define STATE__VALID_CHILD(state,index) &quot;);
2036   fprintf(fp,&quot;  ( state &amp;&amp; (state-&gt;%s) )\n&quot;, state__valid);
2037   fprintf(fp,&quot;\n&quot;);
2038   fprintf(fp,&quot;#define STATE__SET_VALID(index) &quot;);
2039   fprintf(fp,&quot;  (%s)\n&quot;, state__set_valid);
2040   fprintf(fp,&quot;\n&quot;);
2041   fprintf(fp,
2042           &quot;//---------------------------State-------------------------------------------\n&quot;);
2043   fprintf(fp,&quot;// State contains an integral cost vector, indexed by machine operand opcodes,\n&quot;);
2044   fprintf(fp,&quot;// a rule vector consisting of machine operand/instruction opcodes, and also\n&quot;);
2045   fprintf(fp,&quot;// indexed by machine operand opcodes, pointers to the children in the label\n&quot;);
2046   fprintf(fp,&quot;// tree generated by the Label routines in ideal nodes (currently limited to\n&quot;);
2047   fprintf(fp,&quot;// two for convenience, but this could change).\n&quot;);
2048   fprintf(fp,&quot;class State : public ResourceObj {\n&quot;);
2049   fprintf(fp,&quot;public:\n&quot;);
2050   fprintf(fp,&quot;  int    _id;         // State identifier\n&quot;);
2051   fprintf(fp,&quot;  Node  *_leaf;       // Ideal (non-machine-node) leaf of match tree\n&quot;);
2052   fprintf(fp,&quot;  State *_kids[2];       // Children of state node in label tree\n&quot;);
2053   fprintf(fp,&quot;  unsigned int _cost[_LAST_MACH_OPER];  // Cost vector, indexed by operand opcodes\n&quot;);
2054   fprintf(fp,&quot;  unsigned int _rule[_LAST_MACH_OPER];  // Rule vector, indexed by operand opcodes\n&quot;);
2055   fprintf(fp,&quot;  unsigned int _valid[(_LAST_MACH_OPER/32)+1]; // Bit Map of valid Cost/Rule entries\n&quot;);
2056   fprintf(fp,&quot;\n&quot;);
2057   fprintf(fp,&quot;  State(void);                      // Constructor\n&quot;);
2058   fprintf(fp,&quot;  DEBUG_ONLY( ~State(void); )       // Destructor\n&quot;);
2059   fprintf(fp,&quot;\n&quot;);
2060   fprintf(fp,&quot;  // Methods created by ADLC and invoked by Reduce\n&quot;);
2061   fprintf(fp,&quot;  MachOper *MachOperGenerator(int opcode);\n&quot;);
2062   fprintf(fp,&quot;  MachNode *MachNodeGenerator(int opcode);\n&quot;);
2063   fprintf(fp,&quot;\n&quot;);
2064   fprintf(fp,&quot;  // Assign a state to a node, definition of method produced by ADLC\n&quot;);
2065   fprintf(fp,&quot;  bool DFA( int opcode, const Node *ideal );\n&quot;);
2066   fprintf(fp,&quot;\n&quot;);
2067   fprintf(fp,&quot;  // Access function for _valid bit vector\n&quot;);
2068   fprintf(fp,&quot;  bool valid(uint index) {\n&quot;);
2069   fprintf(fp,&quot;    return( STATE__VALID(index) != 0 );\n&quot;);
2070   fprintf(fp,&quot;  }\n&quot;);
2071   fprintf(fp,&quot;\n&quot;);
2072   fprintf(fp,&quot;  // Set function for _valid bit vector\n&quot;);
2073   fprintf(fp,&quot;  void set_valid(uint index) {\n&quot;);
2074   fprintf(fp,&quot;    STATE__SET_VALID(index);\n&quot;);
2075   fprintf(fp,&quot;  }\n&quot;);
2076   fprintf(fp,&quot;\n&quot;);
2077   fprintf(fp,&quot;#ifndef PRODUCT\n&quot;);
2078   fprintf(fp,&quot;  void dump();                // Debugging prints\n&quot;);
2079   fprintf(fp,&quot;  void dump(int depth);\n&quot;);
2080   fprintf(fp,&quot;#endif\n&quot;);
2081   if (_dfa_small) {
2082     // Generate the routine name we&#39;ll need
2083     for (int i = 1; i &lt; _last_opcode; i++) {
2084       if (_mlistab[i] == NULL) continue;
2085       fprintf(fp, &quot;  void  _sub_Op_%s(const Node *n);\n&quot;, NodeClassNames[i]);
2086     }
2087   }
2088   fprintf(fp,&quot;};\n&quot;);
2089   fprintf(fp,&quot;\n&quot;);
2090   fprintf(fp,&quot;\n&quot;);
2091 
2092 }
2093 
2094 
2095 //---------------------------buildMachOperEnum---------------------------------
2096 // Build enumeration for densely packed operands.
2097 // This enumeration is used to index into the arrays in the State objects
2098 // that indicate cost and a successfull rule match.
2099 
2100 // Information needed to generate the ReduceOp mapping for the DFA
2101 class OutputMachOperands : public OutputMap {
2102 public:
2103   OutputMachOperands(FILE *hpp, FILE *cpp, FormDict &amp;globals, ArchDesc &amp;AD)
2104     : OutputMap(hpp, cpp, globals, AD, &quot;MachOperands&quot;) {};
2105 
2106   void declaration() { }
2107   void definition()  { fprintf(_cpp, &quot;enum MachOperands {\n&quot;); }
2108   void closing()     { fprintf(_cpp, &quot;  _LAST_MACH_OPER\n&quot;);
2109                        OutputMap::closing();
2110   }
2111   void map(OpClassForm &amp;opc)  {
2112     const char* opc_ident_to_upper = _AD.machOperEnum(opc._ident);
2113     fprintf(_cpp, &quot;  %s&quot;, opc_ident_to_upper);
2114     delete[] opc_ident_to_upper;
2115   }
2116   void map(OperandForm &amp;oper) {
2117     const char* oper_ident_to_upper = _AD.machOperEnum(oper._ident);
2118     fprintf(_cpp, &quot;  %s&quot;, oper_ident_to_upper);
2119     delete[] oper_ident_to_upper;
2120   }
2121   void map(char *name) {
2122     const char* name_to_upper = _AD.machOperEnum(name);
2123     fprintf(_cpp, &quot;  %s&quot;, name_to_upper);
2124     delete[] name_to_upper;
2125   }
2126 
2127   bool do_instructions()      { return false; }
2128   void map(InstructForm &amp;inst){ assert( false, &quot;ShouldNotCallThis()&quot;); }
2129 };
2130 
2131 
2132 void ArchDesc::buildMachOperEnum(FILE *fp_hpp) {
2133   // Construct the table for MachOpcodes
2134   OutputMachOperands output_mach_operands(fp_hpp, fp_hpp, _globalNames, *this);
2135   build_map(output_mach_operands);
2136 }
2137 
2138 
2139 //---------------------------buildMachEnum----------------------------------
2140 // Build enumeration for all MachOpers and all MachNodes
2141 
2142 // Information needed to generate the ReduceOp mapping for the DFA
2143 class OutputMachOpcodes : public OutputMap {
2144   int begin_inst_chain_rule;
2145   int end_inst_chain_rule;
2146   int begin_rematerialize;
2147   int end_rematerialize;
2148   int end_instructions;
2149 public:
2150   OutputMachOpcodes(FILE *hpp, FILE *cpp, FormDict &amp;globals, ArchDesc &amp;AD)
2151     : OutputMap(hpp, cpp, globals, AD, &quot;MachOpcodes&quot;),
2152       begin_inst_chain_rule(-1), end_inst_chain_rule(-1), end_instructions(-1)
2153   {};
2154 
2155   void declaration() { }
2156   void definition()  { fprintf(_cpp, &quot;enum MachOpcodes {\n&quot;); }
2157   void closing()     {
2158     if( begin_inst_chain_rule != -1 )
2159       fprintf(_cpp, &quot;  _BEGIN_INST_CHAIN_RULE = %d,\n&quot;, begin_inst_chain_rule);
2160     if( end_inst_chain_rule   != -1 )
2161       fprintf(_cpp, &quot;  _END_INST_CHAIN_RULE  = %d,\n&quot;, end_inst_chain_rule);
2162     if( begin_rematerialize   != -1 )
2163       fprintf(_cpp, &quot;  _BEGIN_REMATERIALIZE   = %d,\n&quot;, begin_rematerialize);
2164     if( end_rematerialize     != -1 )
2165       fprintf(_cpp, &quot;  _END_REMATERIALIZE    = %d,\n&quot;, end_rematerialize);
2166     // always execute since do_instructions() is true, and avoids trailing comma
2167     fprintf(_cpp, &quot;  _last_Mach_Node  = %d \n&quot;,  end_instructions);
2168     OutputMap::closing();
2169   }
2170   void map(OpClassForm &amp;opc)  { fprintf(_cpp, &quot;  %s_rule&quot;, opc._ident ); }
2171   void map(OperandForm &amp;oper) { fprintf(_cpp, &quot;  %s_rule&quot;, oper._ident ); }
2172   void map(char        *name) { if (name) fprintf(_cpp, &quot;  %s_rule&quot;, name);
2173                                 else      fprintf(_cpp, &quot;  0&quot;); }
2174   void map(InstructForm &amp;inst) {fprintf(_cpp, &quot;  %s_rule&quot;, inst._ident ); }
2175 
2176   void record_position(OutputMap::position place, int idx ) {
2177     switch(place) {
2178     case OutputMap::BEGIN_INST_CHAIN_RULES :
2179       begin_inst_chain_rule = idx;
2180       break;
2181     case OutputMap::END_INST_CHAIN_RULES :
2182       end_inst_chain_rule   = idx;
2183       break;
2184     case OutputMap::BEGIN_REMATERIALIZE :
2185       begin_rematerialize   = idx;
2186       break;
2187     case OutputMap::END_REMATERIALIZE :
2188       end_rematerialize     = idx;
2189       break;
2190     case OutputMap::END_INSTRUCTIONS :
2191       end_instructions      = idx;
2192       break;
2193     default:
2194       break;
2195     }
2196   }
2197 };
2198 
2199 
2200 void ArchDesc::buildMachOpcodesEnum(FILE *fp_hpp) {
2201   // Construct the table for MachOpcodes
2202   OutputMachOpcodes output_mach_opcodes(fp_hpp, fp_hpp, _globalNames, *this);
2203   build_map(output_mach_opcodes);
2204 }
2205 
2206 
2207 // Generate an enumeration of the pipeline states, and both
2208 // the functional units (resources) and the masks for
2209 // specifying resources
2210 void ArchDesc::build_pipeline_enums(FILE *fp_hpp) {
2211   int stagelen = (int)strlen(&quot;undefined&quot;);
2212   int stagenum = 0;
2213 
2214   if (_pipeline) {              // Find max enum string length
2215     const char *stage;
2216     for ( _pipeline-&gt;_stages.reset(); (stage = _pipeline-&gt;_stages.iter()) != NULL; ) {
2217       int len = (int)strlen(stage);
2218       if (stagelen &lt; len) stagelen = len;
2219     }
2220   }
2221 
2222   // Generate a list of stages
2223   fprintf(fp_hpp, &quot;\n&quot;);
2224   fprintf(fp_hpp, &quot;// Pipeline Stages\n&quot;);
2225   fprintf(fp_hpp, &quot;enum machPipelineStages {\n&quot;);
2226   fprintf(fp_hpp, &quot;   stage_%-*s = 0,\n&quot;, stagelen, &quot;undefined&quot;);
2227 
2228   if( _pipeline ) {
2229     const char *stage;
2230     for ( _pipeline-&gt;_stages.reset(); (stage = _pipeline-&gt;_stages.iter()) != NULL; )
2231       fprintf(fp_hpp, &quot;   stage_%-*s = %d,\n&quot;, stagelen, stage, ++stagenum);
2232   }
2233 
2234   fprintf(fp_hpp, &quot;   stage_%-*s = %d\n&quot;, stagelen, &quot;count&quot;, stagenum);
2235   fprintf(fp_hpp, &quot;};\n&quot;);
2236 
2237   fprintf(fp_hpp, &quot;\n&quot;);
2238   fprintf(fp_hpp, &quot;// Pipeline Resources\n&quot;);
2239   fprintf(fp_hpp, &quot;enum machPipelineResources {\n&quot;);
2240   int rescount = 0;
2241 
2242   if( _pipeline ) {
2243     const char *resource;
2244     int reslen = 0;
2245 
2246     // Generate a list of resources, and masks
2247     for ( _pipeline-&gt;_reslist.reset(); (resource = _pipeline-&gt;_reslist.iter()) != NULL; ) {
2248       int len = (int)strlen(resource);
2249       if (reslen &lt; len)
2250         reslen = len;
2251     }
2252 
2253     for ( _pipeline-&gt;_reslist.reset(); (resource = _pipeline-&gt;_reslist.iter()) != NULL; ) {
2254       const ResourceForm *resform = _pipeline-&gt;_resdict[resource]-&gt;is_resource();
2255       int mask = resform-&gt;mask();
2256       if ((mask &amp; (mask-1)) == 0)
2257         fprintf(fp_hpp, &quot;   resource_%-*s = %d,\n&quot;, reslen, resource, rescount++);
2258     }
2259     fprintf(fp_hpp, &quot;\n&quot;);
2260     for ( _pipeline-&gt;_reslist.reset(); (resource = _pipeline-&gt;_reslist.iter()) != NULL; ) {
2261       const ResourceForm *resform = _pipeline-&gt;_resdict[resource]-&gt;is_resource();
2262       fprintf(fp_hpp, &quot;   res_mask_%-*s = 0x%08x,\n&quot;, reslen, resource, resform-&gt;mask());
2263     }
2264     fprintf(fp_hpp, &quot;\n&quot;);
2265   }
2266   fprintf(fp_hpp, &quot;   resource_count = %d\n&quot;, rescount);
2267   fprintf(fp_hpp, &quot;};\n&quot;);
2268 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/adlc/output_c.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 // output_c.cpp - Class CPP file output routines for architecture definition
  26 
  27 #include &quot;adlc.hpp&quot;
  28 
  29 // Utilities to characterize effect statements
  30 static bool is_def(int usedef) {
  31   switch(usedef) {
  32   case Component::DEF:
  33   case Component::USE_DEF: return true; break;
  34   }
  35   return false;
  36 }
  37 
  38 // Define  an array containing the machine register names, strings.
  39 static void defineRegNames(FILE *fp, RegisterForm *registers) {
  40   if (registers) {
  41     fprintf(fp,&quot;\n&quot;);
  42     fprintf(fp,&quot;// An array of character pointers to machine register names.\n&quot;);
  43     fprintf(fp,&quot;const char *Matcher::regName[REG_COUNT] = {\n&quot;);
  44 
  45     // Output the register name for each register in the allocation classes
  46     RegDef *reg_def = NULL;
  47     RegDef *next = NULL;
  48     registers-&gt;reset_RegDefs();
  49     for (reg_def = registers-&gt;iter_RegDefs(); reg_def != NULL; reg_def = next) {
  50       next = registers-&gt;iter_RegDefs();
  51       const char *comma = (next != NULL) ? &quot;,&quot; : &quot; // no trailing comma&quot;;
  52       fprintf(fp,&quot;  \&quot;%s\&quot;%s\n&quot;, reg_def-&gt;_regname, comma);
  53     }
  54 
  55     // Finish defining enumeration
  56     fprintf(fp,&quot;};\n&quot;);
  57 
  58     fprintf(fp,&quot;\n&quot;);
  59     fprintf(fp,&quot;// An array of character pointers to machine register names.\n&quot;);
  60     fprintf(fp,&quot;const VMReg OptoReg::opto2vm[REG_COUNT] = {\n&quot;);
  61     reg_def = NULL;
  62     next = NULL;
  63     registers-&gt;reset_RegDefs();
  64     for (reg_def = registers-&gt;iter_RegDefs(); reg_def != NULL; reg_def = next) {
  65       next = registers-&gt;iter_RegDefs();
  66       const char *comma = (next != NULL) ? &quot;,&quot; : &quot; // no trailing comma&quot;;
  67       fprintf(fp,&quot;\t%s%s\n&quot;, reg_def-&gt;_concrete, comma);
  68     }
  69     // Finish defining array
  70     fprintf(fp,&quot;\t};\n&quot;);
  71     fprintf(fp,&quot;\n&quot;);
  72 
  73     fprintf(fp,&quot; OptoReg::Name OptoReg::vm2opto[ConcreteRegisterImpl::number_of_registers];\n&quot;);
  74 
  75   }
  76 }
  77 
  78 // Define an array containing the machine register encoding values
  79 static void defineRegEncodes(FILE *fp, RegisterForm *registers) {
  80   if (registers) {
  81     fprintf(fp,&quot;\n&quot;);
  82     fprintf(fp,&quot;// An array of the machine register encode values\n&quot;);
  83     fprintf(fp,&quot;const unsigned char Matcher::_regEncode[REG_COUNT] = {\n&quot;);
  84 
  85     // Output the register encoding for each register in the allocation classes
  86     RegDef *reg_def = NULL;
  87     RegDef *next    = NULL;
  88     registers-&gt;reset_RegDefs();
  89     for (reg_def = registers-&gt;iter_RegDefs(); reg_def != NULL; reg_def = next) {
  90       next = registers-&gt;iter_RegDefs();
  91       const char* register_encode = reg_def-&gt;register_encode();
  92       const char *comma = (next != NULL) ? &quot;,&quot; : &quot; // no trailing comma&quot;;
  93       int encval;
  94       if (!ADLParser::is_int_token(register_encode, encval)) {
  95         fprintf(fp,&quot;  %s%s  // %s\n&quot;, register_encode, comma, reg_def-&gt;_regname);
  96       } else {
  97         // Output known constants in hex char format (backward compatibility).
  98         assert(encval &lt; 256, &quot;Exceeded supported width for register encoding&quot;);
  99         fprintf(fp,&quot;  (unsigned char)&#39;\\x%X&#39;%s  // %s\n&quot;, encval, comma, reg_def-&gt;_regname);
 100       }
 101     }
 102     // Finish defining enumeration
 103     fprintf(fp,&quot;};\n&quot;);
 104 
 105   } // Done defining array
 106 }
 107 
 108 // Output an enumeration of register class names
 109 static void defineRegClassEnum(FILE *fp, RegisterForm *registers) {
 110   if (registers) {
 111     // Output an enumeration of register class names
 112     fprintf(fp,&quot;\n&quot;);
 113     fprintf(fp,&quot;// Enumeration of register class names\n&quot;);
 114     fprintf(fp, &quot;enum machRegisterClass {\n&quot;);
 115     registers-&gt;_rclasses.reset();
 116     for (const char *class_name = NULL; (class_name = registers-&gt;_rclasses.iter()) != NULL;) {
 117       const char * class_name_to_upper = toUpper(class_name);
 118       fprintf(fp,&quot;  %s,\n&quot;, class_name_to_upper);
 119       delete[] class_name_to_upper;
 120     }
 121     // Finish defining enumeration
 122     fprintf(fp, &quot;  _last_Mach_Reg_Class\n&quot;);
 123     fprintf(fp, &quot;};\n&quot;);
 124   }
 125 }
 126 
 127 // Declare an enumeration of user-defined register classes
 128 // and a list of register masks, one for each class.
 129 void ArchDesc::declare_register_masks(FILE *fp_hpp) {
 130   const char  *rc_name;
 131 
 132   if (_register) {
 133     // Build enumeration of user-defined register classes.
 134     defineRegClassEnum(fp_hpp, _register);
 135 
 136     // Generate a list of register masks, one for each class.
 137     fprintf(fp_hpp,&quot;\n&quot;);
 138     fprintf(fp_hpp,&quot;// Register masks, one for each register class.\n&quot;);
 139     _register-&gt;_rclasses.reset();
 140     for (rc_name = NULL; (rc_name = _register-&gt;_rclasses.iter()) != NULL;) {
 141       RegClass *reg_class = _register-&gt;getRegClass(rc_name);
 142       assert(reg_class, &quot;Using an undefined register class&quot;);
 143       reg_class-&gt;declare_register_masks(fp_hpp);
 144     }
 145   }
 146 }
 147 
 148 // Generate an enumeration of user-defined register classes
 149 // and a list of register masks, one for each class.
 150 void ArchDesc::build_register_masks(FILE *fp_cpp) {
 151   const char  *rc_name;
 152 
 153   if (_register) {
 154     // Generate a list of register masks, one for each class.
 155     fprintf(fp_cpp,&quot;\n&quot;);
 156     fprintf(fp_cpp,&quot;// Register masks, one for each register class.\n&quot;);
 157     _register-&gt;_rclasses.reset();
 158     for (rc_name = NULL; (rc_name = _register-&gt;_rclasses.iter()) != NULL;) {
 159       RegClass *reg_class = _register-&gt;getRegClass(rc_name);
 160       assert(reg_class, &quot;Using an undefined register class&quot;);
 161       reg_class-&gt;build_register_masks(fp_cpp);
 162     }
 163   }
 164 }
 165 
 166 // Compute an index for an array in the pipeline_reads_NNN arrays
 167 static int pipeline_reads_initializer(FILE *fp_cpp, NameList &amp;pipeline_reads, PipeClassForm *pipeclass)
 168 {
 169   int templen = 1;
 170   int paramcount = 0;
 171   const char *paramname;
 172 
 173   if (pipeclass-&gt;_parameters.count() == 0)
 174     return -1;
 175 
 176   pipeclass-&gt;_parameters.reset();
 177   paramname = pipeclass-&gt;_parameters.iter();
 178   const PipeClassOperandForm *pipeopnd =
 179     (const PipeClassOperandForm *)pipeclass-&gt;_localUsage[paramname];
 180   if (pipeopnd &amp;&amp; !pipeopnd-&gt;isWrite() &amp;&amp; strcmp(pipeopnd-&gt;_stage, &quot;Universal&quot;))
 181     pipeclass-&gt;_parameters.reset();
 182 
 183   while ( (paramname = pipeclass-&gt;_parameters.iter()) != NULL ) {
 184     const PipeClassOperandForm *tmppipeopnd =
 185         (const PipeClassOperandForm *)pipeclass-&gt;_localUsage[paramname];
 186 
 187     if (tmppipeopnd)
 188       templen += 10 + (int)strlen(tmppipeopnd-&gt;_stage);
 189     else
 190       templen += 19;
 191 
 192     paramcount++;
 193   }
 194 
 195   // See if the count is zero
 196   if (paramcount == 0) {
 197     return -1;
 198   }
 199 
 200   char *operand_stages = new char [templen];
 201   operand_stages[0] = 0;
 202   int i = 0;
 203   templen = 0;
 204 
 205   pipeclass-&gt;_parameters.reset();
 206   paramname = pipeclass-&gt;_parameters.iter();
 207   pipeopnd = (const PipeClassOperandForm *)pipeclass-&gt;_localUsage[paramname];
 208   if (pipeopnd &amp;&amp; !pipeopnd-&gt;isWrite() &amp;&amp; strcmp(pipeopnd-&gt;_stage, &quot;Universal&quot;))
 209     pipeclass-&gt;_parameters.reset();
 210 
 211   while ( (paramname = pipeclass-&gt;_parameters.iter()) != NULL ) {
 212     const PipeClassOperandForm *tmppipeopnd =
 213         (const PipeClassOperandForm *)pipeclass-&gt;_localUsage[paramname];
 214     templen += sprintf(&amp;operand_stages[templen], &quot;  stage_%s%c\n&quot;,
 215       tmppipeopnd ? tmppipeopnd-&gt;_stage : &quot;undefined&quot;,
 216       (++i &lt; paramcount ? &#39;,&#39; : &#39; &#39;) );
 217   }
 218 
 219   // See if the same string is in the table
 220   int ndx = pipeline_reads.index(operand_stages);
 221 
 222   // No, add it to the table
 223   if (ndx &lt; 0) {
 224     pipeline_reads.addName(operand_stages);
 225     ndx = pipeline_reads.index(operand_stages);
 226 
 227     fprintf(fp_cpp, &quot;static const enum machPipelineStages pipeline_reads_%03d[%d] = {\n%s};\n\n&quot;,
 228       ndx+1, paramcount, operand_stages);
 229   }
 230   else
 231     delete [] operand_stages;
 232 
 233   return (ndx);
 234 }
 235 
 236 // Compute an index for an array in the pipeline_res_stages_NNN arrays
 237 static int pipeline_res_stages_initializer(
 238   FILE *fp_cpp,
 239   PipelineForm *pipeline,
 240   NameList &amp;pipeline_res_stages,
 241   PipeClassForm *pipeclass)
 242 {
 243   const PipeClassResourceForm *piperesource;
 244   int * res_stages = new int [pipeline-&gt;_rescount];
 245   int i;
 246 
 247   for (i = 0; i &lt; pipeline-&gt;_rescount; i++)
 248      res_stages[i] = 0;
 249 
 250   for (pipeclass-&gt;_resUsage.reset();
 251        (piperesource = (const PipeClassResourceForm *)pipeclass-&gt;_resUsage.iter()) != NULL; ) {
 252     int used_mask = pipeline-&gt;_resdict[piperesource-&gt;_resource]-&gt;is_resource()-&gt;mask();
 253     for (i = 0; i &lt; pipeline-&gt;_rescount; i++)
 254       if ((1 &lt;&lt; i) &amp; used_mask) {
 255         int stage = pipeline-&gt;_stages.index(piperesource-&gt;_stage);
 256         if (res_stages[i] &lt; stage+1)
 257           res_stages[i] = stage+1;
 258       }
 259   }
 260 
 261   // Compute the length needed for the resource list
 262   int commentlen = 0;
 263   int max_stage = 0;
 264   for (i = 0; i &lt; pipeline-&gt;_rescount; i++) {
 265     if (res_stages[i] == 0) {
 266       if (max_stage &lt; 9)
 267         max_stage = 9;
 268     }
 269     else {
 270       int stagelen = (int)strlen(pipeline-&gt;_stages.name(res_stages[i]-1));
 271       if (max_stage &lt; stagelen)
 272         max_stage = stagelen;
 273     }
 274 
 275     commentlen += (int)strlen(pipeline-&gt;_reslist.name(i));
 276   }
 277 
 278   int templen = 1 + commentlen + pipeline-&gt;_rescount * (max_stage + 14);
 279 
 280   // Allocate space for the resource list
 281   char * resource_stages = new char [templen];
 282 
 283   templen = 0;
 284   for (i = 0; i &lt; pipeline-&gt;_rescount; i++) {
 285     const char * const resname =
 286       res_stages[i] == 0 ? &quot;undefined&quot; : pipeline-&gt;_stages.name(res_stages[i]-1);
 287 
 288     templen += sprintf(&amp;resource_stages[templen], &quot;  stage_%s%-*s // %s\n&quot;,
 289       resname, max_stage - (int)strlen(resname) + 1,
 290       (i &lt; pipeline-&gt;_rescount-1) ? &quot;,&quot; : &quot;&quot;,
 291       pipeline-&gt;_reslist.name(i));
 292   }
 293 
 294   // See if the same string is in the table
 295   int ndx = pipeline_res_stages.index(resource_stages);
 296 
 297   // No, add it to the table
 298   if (ndx &lt; 0) {
 299     pipeline_res_stages.addName(resource_stages);
 300     ndx = pipeline_res_stages.index(resource_stages);
 301 
 302     fprintf(fp_cpp, &quot;static const enum machPipelineStages pipeline_res_stages_%03d[%d] = {\n%s};\n\n&quot;,
 303       ndx+1, pipeline-&gt;_rescount, resource_stages);
 304   }
 305   else
 306     delete [] resource_stages;
 307 
 308   delete [] res_stages;
 309 
 310   return (ndx);
 311 }
 312 
 313 // Compute an index for an array in the pipeline_res_cycles_NNN arrays
 314 static int pipeline_res_cycles_initializer(
 315   FILE *fp_cpp,
 316   PipelineForm *pipeline,
 317   NameList &amp;pipeline_res_cycles,
 318   PipeClassForm *pipeclass)
 319 {
 320   const PipeClassResourceForm *piperesource;
 321   int * res_cycles = new int [pipeline-&gt;_rescount];
 322   int i;
 323 
 324   for (i = 0; i &lt; pipeline-&gt;_rescount; i++)
 325      res_cycles[i] = 0;
 326 
 327   for (pipeclass-&gt;_resUsage.reset();
 328        (piperesource = (const PipeClassResourceForm *)pipeclass-&gt;_resUsage.iter()) != NULL; ) {
 329     int used_mask = pipeline-&gt;_resdict[piperesource-&gt;_resource]-&gt;is_resource()-&gt;mask();
 330     for (i = 0; i &lt; pipeline-&gt;_rescount; i++)
 331       if ((1 &lt;&lt; i) &amp; used_mask) {
 332         int cycles = piperesource-&gt;_cycles;
 333         if (res_cycles[i] &lt; cycles)
 334           res_cycles[i] = cycles;
 335       }
 336   }
 337 
 338   // Pre-compute the string length
 339   int templen;
 340   int cyclelen = 0, commentlen = 0;
 341   int max_cycles = 0;
 342   char temp[32];
 343 
 344   for (i = 0; i &lt; pipeline-&gt;_rescount; i++) {
 345     if (max_cycles &lt; res_cycles[i])
 346       max_cycles = res_cycles[i];
 347     templen = sprintf(temp, &quot;%d&quot;, res_cycles[i]);
 348     if (cyclelen &lt; templen)
 349       cyclelen = templen;
 350     commentlen += (int)strlen(pipeline-&gt;_reslist.name(i));
 351   }
 352 
 353   templen = 1 + commentlen + (cyclelen + 8) * pipeline-&gt;_rescount;
 354 
 355   // Allocate space for the resource list
 356   char * resource_cycles = new char [templen];
 357 
 358   templen = 0;
 359 
 360   for (i = 0; i &lt; pipeline-&gt;_rescount; i++) {
 361     templen += sprintf(&amp;resource_cycles[templen], &quot;  %*d%c // %s\n&quot;,
 362       cyclelen, res_cycles[i], (i &lt; pipeline-&gt;_rescount-1) ? &#39;,&#39; : &#39; &#39;, pipeline-&gt;_reslist.name(i));
 363   }
 364 
 365   // See if the same string is in the table
 366   int ndx = pipeline_res_cycles.index(resource_cycles);
 367 
 368   // No, add it to the table
 369   if (ndx &lt; 0) {
 370     pipeline_res_cycles.addName(resource_cycles);
 371     ndx = pipeline_res_cycles.index(resource_cycles);
 372 
 373     fprintf(fp_cpp, &quot;static const uint pipeline_res_cycles_%03d[%d] = {\n%s};\n\n&quot;,
 374       ndx+1, pipeline-&gt;_rescount, resource_cycles);
 375   }
 376   else
 377     delete [] resource_cycles;
 378 
 379   delete [] res_cycles;
 380 
 381   return (ndx);
 382 }
 383 
 384 //typedef unsigned long long uint64_t;
 385 
 386 // Compute an index for an array in the pipeline_res_mask_NNN arrays
 387 static int pipeline_res_mask_initializer(
 388   FILE *fp_cpp,
 389   PipelineForm *pipeline,
 390   NameList &amp;pipeline_res_mask,
 391   NameList &amp;pipeline_res_args,
 392   PipeClassForm *pipeclass)
 393 {
 394   const PipeClassResourceForm *piperesource;
 395   const uint rescount      = pipeline-&gt;_rescount;
 396   const uint maxcycleused  = pipeline-&gt;_maxcycleused;
 397   const uint cyclemasksize = (maxcycleused + 31) &gt;&gt; 5;
 398 
 399   int i, j;
 400   int element_count = 0;
 401   uint *res_mask = new uint [cyclemasksize];
 402   uint resources_used             = 0;
 403   uint resources_used_exclusively = 0;
 404 
 405   for (pipeclass-&gt;_resUsage.reset();
 406        (piperesource = (const PipeClassResourceForm*)pipeclass-&gt;_resUsage.iter()) != NULL; ) {
 407     element_count++;
 408   }
 409 
 410   // Pre-compute the string length
 411   int templen;
 412   int commentlen = 0;
 413   int max_cycles = 0;
 414 
 415   int cyclelen = ((maxcycleused + 3) &gt;&gt; 2);
 416   int masklen = (rescount + 3) &gt;&gt; 2;
 417 
 418   int cycledigit = 0;
 419   for (i = maxcycleused; i &gt; 0; i /= 10)
 420     cycledigit++;
 421 
 422   int maskdigit = 0;
 423   for (i = rescount; i &gt; 0; i /= 10)
 424     maskdigit++;
 425 
 426   static const char* pipeline_use_cycle_mask = &quot;Pipeline_Use_Cycle_Mask&quot;;
 427   static const char* pipeline_use_element    = &quot;Pipeline_Use_Element&quot;;
 428 
 429   templen = 1 +
 430     (int)(strlen(pipeline_use_cycle_mask) + (int)strlen(pipeline_use_element) +
 431      (cyclemasksize * 12) + masklen + (cycledigit * 2) + 30) * element_count;
 432 
 433   // Allocate space for the resource list
 434   char * resource_mask = new char [templen];
 435   char * last_comma = NULL;
 436 
 437   templen = 0;
 438 
 439   for (pipeclass-&gt;_resUsage.reset();
 440        (piperesource = (const PipeClassResourceForm*)pipeclass-&gt;_resUsage.iter()) != NULL; ) {
 441     int used_mask = pipeline-&gt;_resdict[piperesource-&gt;_resource]-&gt;is_resource()-&gt;mask();
 442 
 443     if (!used_mask) {
 444       fprintf(stderr, &quot;*** used_mask is 0 ***\n&quot;);
 445     }
 446 
 447     resources_used |= used_mask;
 448 
 449     uint lb, ub;
 450 
 451     for (lb =  0; (used_mask &amp; (1 &lt;&lt; lb)) == 0; lb++);
 452     for (ub = 31; (used_mask &amp; (1 &lt;&lt; ub)) == 0; ub--);
 453 
 454     if (lb == ub) {
 455       resources_used_exclusively |= used_mask;
 456     }
 457 
 458     int formatlen =
 459       sprintf(&amp;resource_mask[templen], &quot;  %s(0x%0*x, %*d, %*d, %s %s(&quot;,
 460         pipeline_use_element,
 461         masklen, used_mask,
 462         cycledigit, lb, cycledigit, ub,
 463         ((used_mask &amp; (used_mask-1)) != 0) ? &quot;true, &quot; : &quot;false,&quot;,
 464         pipeline_use_cycle_mask);
 465 
 466     templen += formatlen;
 467 
 468     memset(res_mask, 0, cyclemasksize * sizeof(uint));
 469 
 470     int cycles = piperesource-&gt;_cycles;
 471     uint stage          = pipeline-&gt;_stages.index(piperesource-&gt;_stage);
 472     if ((uint)NameList::Not_in_list == stage) {
 473       fprintf(stderr,
 474               &quot;pipeline_res_mask_initializer: &quot;
 475               &quot;semantic error: &quot;
 476               &quot;pipeline stage undeclared: %s\n&quot;,
 477               piperesource-&gt;_stage);
 478       exit(1);
 479     }
 480     uint upper_limit    = stage + cycles - 1;
 481     uint lower_limit    = stage - 1;
 482     uint upper_idx      = upper_limit &gt;&gt; 5;
 483     uint lower_idx      = lower_limit &gt;&gt; 5;
 484     uint upper_position = upper_limit &amp; 0x1f;
 485     uint lower_position = lower_limit &amp; 0x1f;
 486 
 487     uint mask = (((uint)1) &lt;&lt; upper_position) - 1;
 488 
 489     while (upper_idx &gt; lower_idx) {
 490       res_mask[upper_idx--] |= mask;
 491       mask = (uint)-1;
 492     }
 493 
 494     mask -= (((uint)1) &lt;&lt; lower_position) - 1;
 495     res_mask[upper_idx] |= mask;
 496 
 497     for (j = cyclemasksize-1; j &gt;= 0; j--) {
 498       formatlen =
 499         sprintf(&amp;resource_mask[templen], &quot;0x%08x%s&quot;, res_mask[j], j &gt; 0 ? &quot;, &quot; : &quot;&quot;);
 500       templen += formatlen;
 501     }
 502 
 503     resource_mask[templen++] = &#39;)&#39;;
 504     resource_mask[templen++] = &#39;)&#39;;
 505     last_comma = &amp;resource_mask[templen];
 506     resource_mask[templen++] = &#39;,&#39;;
 507     resource_mask[templen++] = &#39;\n&#39;;
 508   }
 509 
 510   resource_mask[templen] = 0;
 511   if (last_comma) {
 512     last_comma[0] = &#39; &#39;;
 513   }
 514 
 515   // See if the same string is in the table
 516   int ndx = pipeline_res_mask.index(resource_mask);
 517 
 518   // No, add it to the table
 519   if (ndx &lt; 0) {
 520     pipeline_res_mask.addName(resource_mask);
 521     ndx = pipeline_res_mask.index(resource_mask);
 522 
 523     if (strlen(resource_mask) &gt; 0)
 524       fprintf(fp_cpp, &quot;static const Pipeline_Use_Element pipeline_res_mask_%03d[%d] = {\n%s};\n\n&quot;,
 525         ndx+1, element_count, resource_mask);
 526 
 527     char* args = new char [9 + 2*masklen + maskdigit];
 528 
 529     sprintf(args, &quot;0x%0*x, 0x%0*x, %*d&quot;,
 530       masklen, resources_used,
 531       masklen, resources_used_exclusively,
 532       maskdigit, element_count);
 533 
 534     pipeline_res_args.addName(args);
 535   }
 536   else {
 537     delete [] resource_mask;
 538   }
 539 
 540   delete [] res_mask;
 541 //delete [] res_masks;
 542 
 543   return (ndx);
 544 }
 545 
 546 void ArchDesc::build_pipe_classes(FILE *fp_cpp) {
 547   const char *classname;
 548   const char *resourcename;
 549   int resourcenamelen = 0;
 550   NameList pipeline_reads;
 551   NameList pipeline_res_stages;
 552   NameList pipeline_res_cycles;
 553   NameList pipeline_res_masks;
 554   NameList pipeline_res_args;
 555   const int default_latency = 1;
 556   const int non_operand_latency = 0;
 557   const int node_latency = 0;
 558 
 559   if (!_pipeline) {
 560     fprintf(fp_cpp, &quot;uint Node::latency(uint i) const {\n&quot;);
 561     fprintf(fp_cpp, &quot;  // assert(false, \&quot;pipeline functionality is not defined\&quot;);\n&quot;);
 562     fprintf(fp_cpp, &quot;  return %d;\n&quot;, non_operand_latency);
 563     fprintf(fp_cpp, &quot;}\n&quot;);
 564     return;
 565   }
 566 
 567   fprintf(fp_cpp, &quot;\n&quot;);
 568   fprintf(fp_cpp, &quot;//------------------Pipeline Methods-----------------------------------------\n&quot;);
 569   fprintf(fp_cpp, &quot;#ifndef PRODUCT\n&quot;);
 570   fprintf(fp_cpp, &quot;const char * Pipeline::stageName(uint s) {\n&quot;);
 571   fprintf(fp_cpp, &quot;  static const char * const _stage_names[] = {\n&quot;);
 572   fprintf(fp_cpp, &quot;    \&quot;undefined\&quot;&quot;);
 573 
 574   for (int s = 0; s &lt; _pipeline-&gt;_stagecnt; s++)
 575     fprintf(fp_cpp, &quot;, \&quot;%s\&quot;&quot;, _pipeline-&gt;_stages.name(s));
 576 
 577   fprintf(fp_cpp, &quot;\n  };\n\n&quot;);
 578   fprintf(fp_cpp, &quot;  return (s &lt;= %d ? _stage_names[s] : \&quot;???\&quot;);\n&quot;,
 579     _pipeline-&gt;_stagecnt);
 580   fprintf(fp_cpp, &quot;}\n&quot;);
 581   fprintf(fp_cpp, &quot;#endif\n\n&quot;);
 582 
 583   fprintf(fp_cpp, &quot;uint Pipeline::functional_unit_latency(uint start, const Pipeline *pred) const {\n&quot;);
 584   fprintf(fp_cpp, &quot;  // See if the functional units overlap\n&quot;);
 585 #if 0
 586   fprintf(fp_cpp, &quot;\n#ifndef PRODUCT\n&quot;);
 587   fprintf(fp_cpp, &quot;  if (TraceOptoOutput) {\n&quot;);
 588   fprintf(fp_cpp, &quot;    tty-&gt;print(\&quot;#   functional_unit_latency: start == %%d, this-&gt;exclusively == 0x%%03x, pred-&gt;exclusively == 0x%%03x\\n\&quot;, start, resourcesUsedExclusively(), pred-&gt;resourcesUsedExclusively());\n&quot;);
 589   fprintf(fp_cpp, &quot;  }\n&quot;);
 590   fprintf(fp_cpp, &quot;#endif\n\n&quot;);
 591 #endif
 592   fprintf(fp_cpp, &quot;  uint mask = resourcesUsedExclusively() &amp; pred-&gt;resourcesUsedExclusively();\n&quot;);
 593   fprintf(fp_cpp, &quot;  if (mask == 0)\n    return (start);\n\n&quot;);
 594 #if 0
 595   fprintf(fp_cpp, &quot;\n#ifndef PRODUCT\n&quot;);
 596   fprintf(fp_cpp, &quot;  if (TraceOptoOutput) {\n&quot;);
 597   fprintf(fp_cpp, &quot;    tty-&gt;print(\&quot;#   functional_unit_latency: mask == 0x%%x\\n\&quot;, mask);\n&quot;);
 598   fprintf(fp_cpp, &quot;  }\n&quot;);
 599   fprintf(fp_cpp, &quot;#endif\n\n&quot;);
 600 #endif
 601   fprintf(fp_cpp, &quot;  for (uint i = 0; i &lt; pred-&gt;resourceUseCount(); i++) {\n&quot;);
 602   fprintf(fp_cpp, &quot;    const Pipeline_Use_Element *predUse = pred-&gt;resourceUseElement(i);\n&quot;);
 603   fprintf(fp_cpp, &quot;    if (predUse-&gt;multiple())\n&quot;);
 604   fprintf(fp_cpp, &quot;      continue;\n\n&quot;);
 605   fprintf(fp_cpp, &quot;    for (uint j = 0; j &lt; resourceUseCount(); j++) {\n&quot;);
 606   fprintf(fp_cpp, &quot;      const Pipeline_Use_Element *currUse = resourceUseElement(j);\n&quot;);
 607   fprintf(fp_cpp, &quot;      if (currUse-&gt;multiple())\n&quot;);
 608   fprintf(fp_cpp, &quot;        continue;\n\n&quot;);
 609   fprintf(fp_cpp, &quot;      if (predUse-&gt;used() &amp; currUse-&gt;used()) {\n&quot;);
 610   fprintf(fp_cpp, &quot;        Pipeline_Use_Cycle_Mask x = predUse-&gt;mask();\n&quot;);
 611   fprintf(fp_cpp, &quot;        Pipeline_Use_Cycle_Mask y = currUse-&gt;mask();\n\n&quot;);
 612   fprintf(fp_cpp, &quot;        for ( y &lt;&lt;= start; x.overlaps(y); start++ )\n&quot;);
 613   fprintf(fp_cpp, &quot;          y &lt;&lt;= 1;\n&quot;);
 614   fprintf(fp_cpp, &quot;      }\n&quot;);
 615   fprintf(fp_cpp, &quot;    }\n&quot;);
 616   fprintf(fp_cpp, &quot;  }\n\n&quot;);
 617   fprintf(fp_cpp, &quot;  // There is the potential for overlap\n&quot;);
 618   fprintf(fp_cpp, &quot;  return (start);\n&quot;);
 619   fprintf(fp_cpp, &quot;}\n\n&quot;);
 620   fprintf(fp_cpp, &quot;// The following two routines assume that the root Pipeline_Use entity\n&quot;);
 621   fprintf(fp_cpp, &quot;// consists of exactly 1 element for each functional unit\n&quot;);
 622   fprintf(fp_cpp, &quot;// start is relative to the current cycle; used for latency-based info\n&quot;);
 623   fprintf(fp_cpp, &quot;uint Pipeline_Use::full_latency(uint delay, const Pipeline_Use &amp;pred) const {\n&quot;);
 624   fprintf(fp_cpp, &quot;  for (uint i = 0; i &lt; pred._count; i++) {\n&quot;);
 625   fprintf(fp_cpp, &quot;    const Pipeline_Use_Element *predUse = pred.element(i);\n&quot;);
 626   fprintf(fp_cpp, &quot;    if (predUse-&gt;_multiple) {\n&quot;);
 627   fprintf(fp_cpp, &quot;      uint min_delay = %d;\n&quot;,
 628     _pipeline-&gt;_maxcycleused+1);
 629   fprintf(fp_cpp, &quot;      // Multiple possible functional units, choose first unused one\n&quot;);
 630   fprintf(fp_cpp, &quot;      for (uint j = predUse-&gt;_lb; j &lt;= predUse-&gt;_ub; j++) {\n&quot;);
 631   fprintf(fp_cpp, &quot;        const Pipeline_Use_Element *currUse = element(j);\n&quot;);
 632   fprintf(fp_cpp, &quot;        uint curr_delay = delay;\n&quot;);
 633   fprintf(fp_cpp, &quot;        if (predUse-&gt;_used &amp; currUse-&gt;_used) {\n&quot;);
 634   fprintf(fp_cpp, &quot;          Pipeline_Use_Cycle_Mask x = predUse-&gt;_mask;\n&quot;);
 635   fprintf(fp_cpp, &quot;          Pipeline_Use_Cycle_Mask y = currUse-&gt;_mask;\n\n&quot;);
 636   fprintf(fp_cpp, &quot;          for ( y &lt;&lt;= curr_delay; x.overlaps(y); curr_delay++ )\n&quot;);
 637   fprintf(fp_cpp, &quot;            y &lt;&lt;= 1;\n&quot;);
 638   fprintf(fp_cpp, &quot;        }\n&quot;);
 639   fprintf(fp_cpp, &quot;        if (min_delay &gt; curr_delay)\n          min_delay = curr_delay;\n&quot;);
 640   fprintf(fp_cpp, &quot;      }\n&quot;);
 641   fprintf(fp_cpp, &quot;      if (delay &lt; min_delay)\n      delay = min_delay;\n&quot;);
 642   fprintf(fp_cpp, &quot;    }\n&quot;);
 643   fprintf(fp_cpp, &quot;    else {\n&quot;);
 644   fprintf(fp_cpp, &quot;      for (uint j = predUse-&gt;_lb; j &lt;= predUse-&gt;_ub; j++) {\n&quot;);
 645   fprintf(fp_cpp, &quot;        const Pipeline_Use_Element *currUse = element(j);\n&quot;);
 646   fprintf(fp_cpp, &quot;        if (predUse-&gt;_used &amp; currUse-&gt;_used) {\n&quot;);
 647   fprintf(fp_cpp, &quot;          Pipeline_Use_Cycle_Mask x = predUse-&gt;_mask;\n&quot;);
 648   fprintf(fp_cpp, &quot;          Pipeline_Use_Cycle_Mask y = currUse-&gt;_mask;\n\n&quot;);
 649   fprintf(fp_cpp, &quot;          for ( y &lt;&lt;= delay; x.overlaps(y); delay++ )\n&quot;);
 650   fprintf(fp_cpp, &quot;            y &lt;&lt;= 1;\n&quot;);
 651   fprintf(fp_cpp, &quot;        }\n&quot;);
 652   fprintf(fp_cpp, &quot;      }\n&quot;);
 653   fprintf(fp_cpp, &quot;    }\n&quot;);
 654   fprintf(fp_cpp, &quot;  }\n\n&quot;);
 655   fprintf(fp_cpp, &quot;  return (delay);\n&quot;);
 656   fprintf(fp_cpp, &quot;}\n\n&quot;);
 657   fprintf(fp_cpp, &quot;void Pipeline_Use::add_usage(const Pipeline_Use &amp;pred) {\n&quot;);
 658   fprintf(fp_cpp, &quot;  for (uint i = 0; i &lt; pred._count; i++) {\n&quot;);
 659   fprintf(fp_cpp, &quot;    const Pipeline_Use_Element *predUse = pred.element(i);\n&quot;);
 660   fprintf(fp_cpp, &quot;    if (predUse-&gt;_multiple) {\n&quot;);
 661   fprintf(fp_cpp, &quot;      // Multiple possible functional units, choose first unused one\n&quot;);
 662   fprintf(fp_cpp, &quot;      for (uint j = predUse-&gt;_lb; j &lt;= predUse-&gt;_ub; j++) {\n&quot;);
 663   fprintf(fp_cpp, &quot;        Pipeline_Use_Element *currUse = element(j);\n&quot;);
 664   fprintf(fp_cpp, &quot;        if ( !predUse-&gt;_mask.overlaps(currUse-&gt;_mask) ) {\n&quot;);
 665   fprintf(fp_cpp, &quot;          currUse-&gt;_used |= (1 &lt;&lt; j);\n&quot;);
 666   fprintf(fp_cpp, &quot;          _resources_used |= (1 &lt;&lt; j);\n&quot;);
 667   fprintf(fp_cpp, &quot;          currUse-&gt;_mask.Or(predUse-&gt;_mask);\n&quot;);
 668   fprintf(fp_cpp, &quot;          break;\n&quot;);
 669   fprintf(fp_cpp, &quot;        }\n&quot;);
 670   fprintf(fp_cpp, &quot;      }\n&quot;);
 671   fprintf(fp_cpp, &quot;    }\n&quot;);
 672   fprintf(fp_cpp, &quot;    else {\n&quot;);
 673   fprintf(fp_cpp, &quot;      for (uint j = predUse-&gt;_lb; j &lt;= predUse-&gt;_ub; j++) {\n&quot;);
 674   fprintf(fp_cpp, &quot;        Pipeline_Use_Element *currUse = element(j);\n&quot;);
 675   fprintf(fp_cpp, &quot;        currUse-&gt;_used |= (1 &lt;&lt; j);\n&quot;);
 676   fprintf(fp_cpp, &quot;        _resources_used |= (1 &lt;&lt; j);\n&quot;);
 677   fprintf(fp_cpp, &quot;        currUse-&gt;_mask.Or(predUse-&gt;_mask);\n&quot;);
 678   fprintf(fp_cpp, &quot;      }\n&quot;);
 679   fprintf(fp_cpp, &quot;    }\n&quot;);
 680   fprintf(fp_cpp, &quot;  }\n&quot;);
 681   fprintf(fp_cpp, &quot;}\n\n&quot;);
 682 
 683   fprintf(fp_cpp, &quot;uint Pipeline::operand_latency(uint opnd, const Pipeline *pred) const {\n&quot;);
 684   fprintf(fp_cpp, &quot;  int const default_latency = 1;\n&quot;);
 685   fprintf(fp_cpp, &quot;\n&quot;);
 686 #if 0
 687   fprintf(fp_cpp, &quot;#ifndef PRODUCT\n&quot;);
 688   fprintf(fp_cpp, &quot;  if (TraceOptoOutput) {\n&quot;);
 689   fprintf(fp_cpp, &quot;    tty-&gt;print(\&quot;#   operand_latency(%%d), _read_stage_count = %%d\\n\&quot;, opnd, _read_stage_count);\n&quot;);
 690   fprintf(fp_cpp, &quot;  }\n&quot;);
 691   fprintf(fp_cpp, &quot;#endif\n\n&quot;);
 692 #endif
 693   fprintf(fp_cpp, &quot;  assert(this, \&quot;NULL pipeline info\&quot;);\n&quot;);
 694   fprintf(fp_cpp, &quot;  assert(pred, \&quot;NULL predecessor pipline info\&quot;);\n\n&quot;);
 695   fprintf(fp_cpp, &quot;  if (pred-&gt;hasFixedLatency())\n    return (pred-&gt;fixedLatency());\n\n&quot;);
 696   fprintf(fp_cpp, &quot;  // If this is not an operand, then assume a dependence with 0 latency\n&quot;);
 697   fprintf(fp_cpp, &quot;  if (opnd &gt; _read_stage_count)\n    return (0);\n\n&quot;);
 698   fprintf(fp_cpp, &quot;  uint writeStage = pred-&gt;_write_stage;\n&quot;);
 699   fprintf(fp_cpp, &quot;  uint readStage  = _read_stages[opnd-1];\n&quot;);
 700 #if 0
 701   fprintf(fp_cpp, &quot;\n#ifndef PRODUCT\n&quot;);
 702   fprintf(fp_cpp, &quot;  if (TraceOptoOutput) {\n&quot;);
 703   fprintf(fp_cpp, &quot;    tty-&gt;print(\&quot;#   operand_latency: writeStage=%%s readStage=%%s, opnd=%%d\\n\&quot;, stageName(writeStage), stageName(readStage), opnd);\n&quot;);
 704   fprintf(fp_cpp, &quot;  }\n&quot;);
 705   fprintf(fp_cpp, &quot;#endif\n\n&quot;);
 706 #endif
 707   fprintf(fp_cpp, &quot;\n&quot;);
 708   fprintf(fp_cpp, &quot;  if (writeStage == stage_undefined || readStage == stage_undefined)\n&quot;);
 709   fprintf(fp_cpp, &quot;    return (default_latency);\n&quot;);
 710   fprintf(fp_cpp, &quot;\n&quot;);
 711   fprintf(fp_cpp, &quot;  int delta = writeStage - readStage;\n&quot;);
 712   fprintf(fp_cpp, &quot;  if (delta &lt; 0) delta = 0;\n\n&quot;);
 713 #if 0
 714   fprintf(fp_cpp, &quot;\n#ifndef PRODUCT\n&quot;);
 715   fprintf(fp_cpp, &quot;  if (TraceOptoOutput) {\n&quot;);
 716   fprintf(fp_cpp, &quot;    tty-&gt;print(\&quot;# operand_latency: delta=%%d\\n\&quot;, delta);\n&quot;);
 717   fprintf(fp_cpp, &quot;  }\n&quot;);
 718   fprintf(fp_cpp, &quot;#endif\n\n&quot;);
 719 #endif
 720   fprintf(fp_cpp, &quot;  return (delta);\n&quot;);
 721   fprintf(fp_cpp, &quot;}\n\n&quot;);
 722 
 723   if (!_pipeline)
 724     /* Do Nothing */;
 725 
 726   else if (_pipeline-&gt;_maxcycleused &lt;=
 727 #ifdef SPARC
 728     64
 729 #else
 730     32
 731 #endif
 732       ) {
 733     fprintf(fp_cpp, &quot;Pipeline_Use_Cycle_Mask operator&amp;(const Pipeline_Use_Cycle_Mask &amp;in1, const Pipeline_Use_Cycle_Mask &amp;in2) {\n&quot;);
 734     fprintf(fp_cpp, &quot;  return Pipeline_Use_Cycle_Mask(in1._mask &amp; in2._mask);\n&quot;);
 735     fprintf(fp_cpp, &quot;}\n\n&quot;);
 736     fprintf(fp_cpp, &quot;Pipeline_Use_Cycle_Mask operator|(const Pipeline_Use_Cycle_Mask &amp;in1, const Pipeline_Use_Cycle_Mask &amp;in2) {\n&quot;);
 737     fprintf(fp_cpp, &quot;  return Pipeline_Use_Cycle_Mask(in1._mask | in2._mask);\n&quot;);
 738     fprintf(fp_cpp, &quot;}\n\n&quot;);
 739   }
 740   else {
 741     uint l;
 742     uint masklen = (_pipeline-&gt;_maxcycleused + 31) &gt;&gt; 5;
 743     fprintf(fp_cpp, &quot;Pipeline_Use_Cycle_Mask operator&amp;(const Pipeline_Use_Cycle_Mask &amp;in1, const Pipeline_Use_Cycle_Mask &amp;in2) {\n&quot;);
 744     fprintf(fp_cpp, &quot;  return Pipeline_Use_Cycle_Mask(&quot;);
 745     for (l = 1; l &lt;= masklen; l++)
 746       fprintf(fp_cpp, &quot;in1._mask%d &amp; in2._mask%d%s\n&quot;, l, l, l &lt; masklen ? &quot;, &quot; : &quot;&quot;);
 747     fprintf(fp_cpp, &quot;);\n&quot;);
 748     fprintf(fp_cpp, &quot;}\n\n&quot;);
 749     fprintf(fp_cpp, &quot;Pipeline_Use_Cycle_Mask operator|(const Pipeline_Use_Cycle_Mask &amp;in1, const Pipeline_Use_Cycle_Mask &amp;in2) {\n&quot;);
 750     fprintf(fp_cpp, &quot;  return Pipeline_Use_Cycle_Mask(&quot;);
 751     for (l = 1; l &lt;= masklen; l++)
 752       fprintf(fp_cpp, &quot;in1._mask%d | in2._mask%d%s&quot;, l, l, l &lt; masklen ? &quot;, &quot; : &quot;&quot;);
 753     fprintf(fp_cpp, &quot;);\n&quot;);
 754     fprintf(fp_cpp, &quot;}\n\n&quot;);
 755     fprintf(fp_cpp, &quot;void Pipeline_Use_Cycle_Mask::Or(const Pipeline_Use_Cycle_Mask &amp;in2) {\n &quot;);
 756     for (l = 1; l &lt;= masklen; l++)
 757       fprintf(fp_cpp, &quot; _mask%d |= in2._mask%d;&quot;, l, l);
 758     fprintf(fp_cpp, &quot;\n}\n\n&quot;);
 759   }
 760 
 761   /* Get the length of all the resource names */
 762   for (_pipeline-&gt;_reslist.reset(), resourcenamelen = 0;
 763        (resourcename = _pipeline-&gt;_reslist.iter()) != NULL;
 764        resourcenamelen += (int)strlen(resourcename));
 765 
 766   // Create the pipeline class description
 767 
 768   fprintf(fp_cpp, &quot;static const Pipeline pipeline_class_Zero_Instructions(0, 0, true, 0, 0, false, false, false, false, NULL, NULL, NULL, Pipeline_Use(0, 0, 0, NULL));\n\n&quot;);
 769   fprintf(fp_cpp, &quot;static const Pipeline pipeline_class_Unknown_Instructions(0, 0, true, 0, 0, false, true, true, false, NULL, NULL, NULL, Pipeline_Use(0, 0, 0, NULL));\n\n&quot;);
 770 
 771   fprintf(fp_cpp, &quot;const Pipeline_Use_Element Pipeline_Use::elaborated_elements[%d] = {\n&quot;, _pipeline-&gt;_rescount);
 772   for (int i1 = 0; i1 &lt; _pipeline-&gt;_rescount; i1++) {
 773     fprintf(fp_cpp, &quot;  Pipeline_Use_Element(0, %d, %d, false, Pipeline_Use_Cycle_Mask(&quot;, i1, i1);
 774     uint masklen = (_pipeline-&gt;_maxcycleused + 31) &gt;&gt; 5;
 775     for (int i2 = masklen-1; i2 &gt;= 0; i2--)
 776       fprintf(fp_cpp, &quot;0%s&quot;, i2 &gt; 0 ? &quot;, &quot; : &quot;&quot;);
 777     fprintf(fp_cpp, &quot;))%s\n&quot;, i1 &lt; (_pipeline-&gt;_rescount-1) ? &quot;,&quot; : &quot;&quot;);
 778   }
 779   fprintf(fp_cpp, &quot;};\n\n&quot;);
 780 
 781   fprintf(fp_cpp, &quot;const Pipeline_Use Pipeline_Use::elaborated_use(0, 0, %d, (Pipeline_Use_Element *)&amp;elaborated_elements[0]);\n\n&quot;,
 782     _pipeline-&gt;_rescount);
 783 
 784   for (_pipeline-&gt;_classlist.reset(); (classname = _pipeline-&gt;_classlist.iter()) != NULL; ) {
 785     fprintf(fp_cpp, &quot;\n&quot;);
 786     fprintf(fp_cpp, &quot;// Pipeline Class \&quot;%s\&quot;\n&quot;, classname);
 787     PipeClassForm *pipeclass = _pipeline-&gt;_classdict[classname]-&gt;is_pipeclass();
 788     int maxWriteStage = -1;
 789     int maxMoreInstrs = 0;
 790     int paramcount = 0;
 791     int i = 0;
 792     const char *paramname;
 793     int resource_count = (_pipeline-&gt;_rescount + 3) &gt;&gt; 2;
 794 
 795     // Scan the operands, looking for last output stage and number of inputs
 796     for (pipeclass-&gt;_parameters.reset(); (paramname = pipeclass-&gt;_parameters.iter()) != NULL; ) {
 797       const PipeClassOperandForm *pipeopnd =
 798           (const PipeClassOperandForm *)pipeclass-&gt;_localUsage[paramname];
 799       if (pipeopnd) {
 800         if (pipeopnd-&gt;_iswrite) {
 801            int stagenum  = _pipeline-&gt;_stages.index(pipeopnd-&gt;_stage);
 802            int moreinsts = pipeopnd-&gt;_more_instrs;
 803           if ((maxWriteStage+maxMoreInstrs) &lt; (stagenum+moreinsts)) {
 804             maxWriteStage = stagenum;
 805             maxMoreInstrs = moreinsts;
 806           }
 807         }
 808       }
 809 
 810       if (i++ &gt; 0 || (pipeopnd &amp;&amp; !pipeopnd-&gt;isWrite()))
 811         paramcount++;
 812     }
 813 
 814     // Create the list of stages for the operands that are read
 815     // Note that we will build a NameList to reduce the number of copies
 816 
 817     int pipeline_reads_index = pipeline_reads_initializer(fp_cpp, pipeline_reads, pipeclass);
 818 
 819     int pipeline_res_stages_index = pipeline_res_stages_initializer(
 820       fp_cpp, _pipeline, pipeline_res_stages, pipeclass);
 821 
 822     int pipeline_res_cycles_index = pipeline_res_cycles_initializer(
 823       fp_cpp, _pipeline, pipeline_res_cycles, pipeclass);
 824 
 825     int pipeline_res_mask_index = pipeline_res_mask_initializer(
 826       fp_cpp, _pipeline, pipeline_res_masks, pipeline_res_args, pipeclass);
 827 
 828 #if 0
 829     // Process the Resources
 830     const PipeClassResourceForm *piperesource;
 831 
 832     unsigned resources_used = 0;
 833     unsigned exclusive_resources_used = 0;
 834     unsigned resource_groups = 0;
 835     for (pipeclass-&gt;_resUsage.reset();
 836          (piperesource = (const PipeClassResourceForm *)pipeclass-&gt;_resUsage.iter()) != NULL; ) {
 837       int used_mask = _pipeline-&gt;_resdict[piperesource-&gt;_resource]-&gt;is_resource()-&gt;mask();
 838       if (used_mask)
 839         resource_groups++;
 840       resources_used |= used_mask;
 841       if ((used_mask &amp; (used_mask-1)) == 0)
 842         exclusive_resources_used |= used_mask;
 843     }
 844 
 845     if (resource_groups &gt; 0) {
 846       fprintf(fp_cpp, &quot;static const uint pipeline_res_or_masks_%03d[%d] = {&quot;,
 847         pipeclass-&gt;_num, resource_groups);
 848       for (pipeclass-&gt;_resUsage.reset(), i = 1;
 849            (piperesource = (const PipeClassResourceForm *)pipeclass-&gt;_resUsage.iter()) != NULL;
 850            i++ ) {
 851         int used_mask = _pipeline-&gt;_resdict[piperesource-&gt;_resource]-&gt;is_resource()-&gt;mask();
 852         if (used_mask) {
 853           fprintf(fp_cpp, &quot; 0x%0*x%c&quot;, resource_count, used_mask, i &lt; (int)resource_groups ? &#39;,&#39; : &#39; &#39;);
 854         }
 855       }
 856       fprintf(fp_cpp, &quot;};\n\n&quot;);
 857     }
 858 #endif
 859 
 860     // Create the pipeline class description
 861     fprintf(fp_cpp, &quot;static const Pipeline pipeline_class_%03d(&quot;,
 862       pipeclass-&gt;_num);
 863     if (maxWriteStage &lt; 0)
 864       fprintf(fp_cpp, &quot;(uint)stage_undefined&quot;);
 865     else if (maxMoreInstrs == 0)
 866       fprintf(fp_cpp, &quot;(uint)stage_%s&quot;, _pipeline-&gt;_stages.name(maxWriteStage));
 867     else
 868       fprintf(fp_cpp, &quot;((uint)stage_%s)+%d&quot;, _pipeline-&gt;_stages.name(maxWriteStage), maxMoreInstrs);
 869     fprintf(fp_cpp, &quot;, %d, %s, %d, %d, %s, %s, %s, %s,\n&quot;,
 870       paramcount,
 871       pipeclass-&gt;hasFixedLatency() ? &quot;true&quot; : &quot;false&quot;,
 872       pipeclass-&gt;fixedLatency(),
 873       pipeclass-&gt;InstructionCount(),
 874       pipeclass-&gt;hasBranchDelay() ? &quot;true&quot; : &quot;false&quot;,
 875       pipeclass-&gt;hasMultipleBundles() ? &quot;true&quot; : &quot;false&quot;,
 876       pipeclass-&gt;forceSerialization() ? &quot;true&quot; : &quot;false&quot;,
 877       pipeclass-&gt;mayHaveNoCode() ? &quot;true&quot; : &quot;false&quot; );
 878     if (paramcount &gt; 0) {
 879       fprintf(fp_cpp, &quot;\n  (enum machPipelineStages * const) pipeline_reads_%03d,\n &quot;,
 880         pipeline_reads_index+1);
 881     }
 882     else
 883       fprintf(fp_cpp, &quot; NULL,&quot;);
 884     fprintf(fp_cpp, &quot;  (enum machPipelineStages * const) pipeline_res_stages_%03d,\n&quot;,
 885       pipeline_res_stages_index+1);
 886     fprintf(fp_cpp, &quot;  (uint * const) pipeline_res_cycles_%03d,\n&quot;,
 887       pipeline_res_cycles_index+1);
 888     fprintf(fp_cpp, &quot;  Pipeline_Use(%s, (Pipeline_Use_Element *)&quot;,
 889       pipeline_res_args.name(pipeline_res_mask_index));
 890     if (strlen(pipeline_res_masks.name(pipeline_res_mask_index)) &gt; 0)
 891       fprintf(fp_cpp, &quot;&amp;pipeline_res_mask_%03d[0]&quot;,
 892         pipeline_res_mask_index+1);
 893     else
 894       fprintf(fp_cpp, &quot;NULL&quot;);
 895     fprintf(fp_cpp, &quot;));\n&quot;);
 896   }
 897 
 898   // Generate the Node::latency method if _pipeline defined
 899   fprintf(fp_cpp, &quot;\n&quot;);
 900   fprintf(fp_cpp, &quot;//------------------Inter-Instruction Latency--------------------------------\n&quot;);
 901   fprintf(fp_cpp, &quot;uint Node::latency(uint i) {\n&quot;);
 902   if (_pipeline) {
 903 #if 0
 904     fprintf(fp_cpp, &quot;#ifndef PRODUCT\n&quot;);
 905     fprintf(fp_cpp, &quot; if (TraceOptoOutput) {\n&quot;);
 906     fprintf(fp_cpp, &quot;    tty-&gt;print(\&quot;# %%4d-&gt;latency(%%d)\\n\&quot;, _idx, i);\n&quot;);
 907     fprintf(fp_cpp, &quot; }\n&quot;);
 908     fprintf(fp_cpp, &quot;#endif\n&quot;);
 909 #endif
 910     fprintf(fp_cpp, &quot;  uint j;\n&quot;);
 911     fprintf(fp_cpp, &quot;  // verify in legal range for inputs\n&quot;);
 912     fprintf(fp_cpp, &quot;  assert(i &lt; len(), \&quot;index not in range\&quot;);\n\n&quot;);
 913     fprintf(fp_cpp, &quot;  // verify input is not null\n&quot;);
 914     fprintf(fp_cpp, &quot;  Node *pred = in(i);\n&quot;);
 915     fprintf(fp_cpp, &quot;  if (!pred)\n    return %d;\n\n&quot;,
 916       non_operand_latency);
 917     fprintf(fp_cpp, &quot;  if (pred-&gt;is_Proj())\n    pred = pred-&gt;in(0);\n\n&quot;);
 918     fprintf(fp_cpp, &quot;  // if either node does not have pipeline info, use default\n&quot;);
 919     fprintf(fp_cpp, &quot;  const Pipeline *predpipe = pred-&gt;pipeline();\n&quot;);
 920     fprintf(fp_cpp, &quot;  assert(predpipe, \&quot;no predecessor pipeline info\&quot;);\n\n&quot;);
 921     fprintf(fp_cpp, &quot;  if (predpipe-&gt;hasFixedLatency())\n    return predpipe-&gt;fixedLatency();\n\n&quot;);
 922     fprintf(fp_cpp, &quot;  const Pipeline *currpipe = pipeline();\n&quot;);
 923     fprintf(fp_cpp, &quot;  assert(currpipe, \&quot;no pipeline info\&quot;);\n\n&quot;);
 924     fprintf(fp_cpp, &quot;  if (!is_Mach())\n    return %d;\n\n&quot;,
 925       node_latency);
 926     fprintf(fp_cpp, &quot;  const MachNode *m = as_Mach();\n&quot;);
 927     fprintf(fp_cpp, &quot;  j = m-&gt;oper_input_base();\n&quot;);
 928     fprintf(fp_cpp, &quot;  if (i &lt; j)\n    return currpipe-&gt;functional_unit_latency(%d, predpipe);\n\n&quot;,
 929       non_operand_latency);
 930     fprintf(fp_cpp, &quot;  // determine which operand this is in\n&quot;);
 931     fprintf(fp_cpp, &quot;  uint n = m-&gt;num_opnds();\n&quot;);
 932     fprintf(fp_cpp, &quot;  int delta = %d;\n\n&quot;,
 933       non_operand_latency);
 934     fprintf(fp_cpp, &quot;  uint k;\n&quot;);
 935     fprintf(fp_cpp, &quot;  for (k = 1; k &lt; n; k++) {\n&quot;);
 936     fprintf(fp_cpp, &quot;    j += m-&gt;_opnds[k]-&gt;num_edges();\n&quot;);
 937     fprintf(fp_cpp, &quot;    if (i &lt; j)\n&quot;);
 938     fprintf(fp_cpp, &quot;      break;\n&quot;);
 939     fprintf(fp_cpp, &quot;  }\n&quot;);
 940     fprintf(fp_cpp, &quot;  if (k &lt; n)\n&quot;);
 941     fprintf(fp_cpp, &quot;    delta = currpipe-&gt;operand_latency(k,predpipe);\n\n&quot;);
 942     fprintf(fp_cpp, &quot;  return currpipe-&gt;functional_unit_latency(delta, predpipe);\n&quot;);
 943   }
 944   else {
 945     fprintf(fp_cpp, &quot;  // assert(false, \&quot;pipeline functionality is not defined\&quot;);\n&quot;);
 946     fprintf(fp_cpp, &quot;  return %d;\n&quot;,
 947       non_operand_latency);
 948   }
 949   fprintf(fp_cpp, &quot;}\n\n&quot;);
 950 
 951   // Output the list of nop nodes
 952   fprintf(fp_cpp, &quot;// Descriptions for emitting different functional unit nops\n&quot;);
 953   const char *nop;
 954   int nopcnt = 0;
 955   for ( _pipeline-&gt;_noplist.reset(); (nop = _pipeline-&gt;_noplist.iter()) != NULL; nopcnt++ );
 956 
 957   fprintf(fp_cpp, &quot;void Bundle::initialize_nops(MachNode * nop_list[%d]) {\n&quot;, nopcnt);
 958   int i = 0;
 959   for ( _pipeline-&gt;_noplist.reset(); (nop = _pipeline-&gt;_noplist.iter()) != NULL; i++ ) {
 960     fprintf(fp_cpp, &quot;  nop_list[%d] = (MachNode *) new %sNode();\n&quot;, i, nop);
 961   }
 962   fprintf(fp_cpp, &quot;};\n\n&quot;);
 963   fprintf(fp_cpp, &quot;#ifndef PRODUCT\n&quot;);
 964   fprintf(fp_cpp, &quot;void Bundle::dump(outputStream *st) const {\n&quot;);
 965   fprintf(fp_cpp, &quot;  static const char * bundle_flags[] = {\n&quot;);
 966   fprintf(fp_cpp, &quot;    \&quot;\&quot;,\n&quot;);
 967   fprintf(fp_cpp, &quot;    \&quot;use nop delay\&quot;,\n&quot;);
 968   fprintf(fp_cpp, &quot;    \&quot;use unconditional delay\&quot;,\n&quot;);
 969   fprintf(fp_cpp, &quot;    \&quot;use conditional delay\&quot;,\n&quot;);
 970   fprintf(fp_cpp, &quot;    \&quot;used in conditional delay\&quot;,\n&quot;);
 971   fprintf(fp_cpp, &quot;    \&quot;used in unconditional delay\&quot;,\n&quot;);
 972   fprintf(fp_cpp, &quot;    \&quot;used in all conditional delays\&quot;,\n&quot;);
 973   fprintf(fp_cpp, &quot;  };\n\n&quot;);
 974 
 975   fprintf(fp_cpp, &quot;  static const char *resource_names[%d] = {&quot;, _pipeline-&gt;_rescount);
 976   for (i = 0; i &lt; _pipeline-&gt;_rescount; i++)
 977     fprintf(fp_cpp, &quot; \&quot;%s\&quot;%c&quot;, _pipeline-&gt;_reslist.name(i), i &lt; _pipeline-&gt;_rescount-1 ? &#39;,&#39; : &#39; &#39;);
 978   fprintf(fp_cpp, &quot;};\n\n&quot;);
 979 
 980   // See if the same string is in the table
 981   fprintf(fp_cpp, &quot;  bool needs_comma = false;\n\n&quot;);
 982   fprintf(fp_cpp, &quot;  if (_flags) {\n&quot;);
 983   fprintf(fp_cpp, &quot;    st-&gt;print(\&quot;%%s\&quot;, bundle_flags[_flags]);\n&quot;);
 984   fprintf(fp_cpp, &quot;    needs_comma = true;\n&quot;);
 985   fprintf(fp_cpp, &quot;  };\n&quot;);
 986   fprintf(fp_cpp, &quot;  if (instr_count()) {\n&quot;);
 987   fprintf(fp_cpp, &quot;    st-&gt;print(\&quot;%%s%%d instr%%s\&quot;, needs_comma ? \&quot;, \&quot; : \&quot;\&quot;, instr_count(), instr_count() != 1 ? \&quot;s\&quot; : \&quot;\&quot;);\n&quot;);
 988   fprintf(fp_cpp, &quot;    needs_comma = true;\n&quot;);
 989   fprintf(fp_cpp, &quot;  };\n&quot;);
 990   fprintf(fp_cpp, &quot;  uint r = resources_used();\n&quot;);
 991   fprintf(fp_cpp, &quot;  if (r) {\n&quot;);
 992   fprintf(fp_cpp, &quot;    st-&gt;print(\&quot;%%sresource%%s:\&quot;, needs_comma ? \&quot;, \&quot; : \&quot;\&quot;, (r &amp; (r-1)) != 0 ? \&quot;s\&quot; : \&quot;\&quot;);\n&quot;);
 993   fprintf(fp_cpp, &quot;    for (uint i = 0; i &lt; %d; i++)\n&quot;, _pipeline-&gt;_rescount);
 994   fprintf(fp_cpp, &quot;      if ((r &amp; (1 &lt;&lt; i)) != 0)\n&quot;);
 995   fprintf(fp_cpp, &quot;        st-&gt;print(\&quot; %%s\&quot;, resource_names[i]);\n&quot;);
 996   fprintf(fp_cpp, &quot;    needs_comma = true;\n&quot;);
 997   fprintf(fp_cpp, &quot;  };\n&quot;);
 998   fprintf(fp_cpp, &quot;  st-&gt;print(\&quot;\\n\&quot;);\n&quot;);
 999   fprintf(fp_cpp, &quot;}\n&quot;);
1000   fprintf(fp_cpp, &quot;#endif\n&quot;);
1001 }
1002 
1003 // ---------------------------------------------------------------------------
1004 //------------------------------Utilities to build Instruction Classes--------
1005 // ---------------------------------------------------------------------------
1006 
1007 static void defineOut_RegMask(FILE *fp, const char *node, const char *regMask) {
1008   fprintf(fp,&quot;const RegMask &amp;%sNode::out_RegMask() const { return (%s); }\n&quot;,
1009           node, regMask);
1010 }
1011 
1012 static void print_block_index(FILE *fp, int inst_position) {
1013   assert( inst_position &gt;= 0, &quot;Instruction number less than zero&quot;);
1014   fprintf(fp, &quot;block_index&quot;);
1015   if( inst_position != 0 ) {
1016     fprintf(fp, &quot; - %d&quot;, inst_position);
1017   }
1018 }
1019 
1020 // Scan the peepmatch and output a test for each instruction
1021 static void check_peepmatch_instruction_sequence(FILE *fp, PeepMatch *pmatch, PeepConstraint *pconstraint) {
1022   int         parent        = -1;
1023   int         inst_position = 0;
1024   const char* inst_name     = NULL;
1025   int         input         = 0;
1026   fprintf(fp, &quot;  // Check instruction sub-tree\n&quot;);
1027   pmatch-&gt;reset();
1028   for( pmatch-&gt;next_instruction( parent, inst_position, inst_name, input );
1029        inst_name != NULL;
1030        pmatch-&gt;next_instruction( parent, inst_position, inst_name, input ) ) {
1031     // If this is not a placeholder
1032     if( ! pmatch-&gt;is_placeholder() ) {
1033       // Define temporaries &#39;inst#&#39;, based on parent and parent&#39;s input index
1034       if( parent != -1 ) {                // root was initialized
1035         fprintf(fp, &quot;  // Identify previous instruction if inside this block\n&quot;);
1036         fprintf(fp, &quot;  if( &quot;);
1037         print_block_index(fp, inst_position);
1038         fprintf(fp, &quot; &gt; 0 ) {\n    Node *n = block-&gt;get_node(&quot;);
1039         print_block_index(fp, inst_position);
1040         fprintf(fp, &quot;);\n    inst%d = (n-&gt;is_Mach()) ? &quot;, inst_position);
1041         fprintf(fp, &quot;n-&gt;as_Mach() : NULL;\n  }\n&quot;);
1042       }
1043 
1044       // When not the root
1045       // Test we have the correct instruction by comparing the rule.
1046       if( parent != -1 ) {
1047         fprintf(fp, &quot;  matches = matches &amp;&amp; (inst%d != NULL) &amp;&amp; (inst%d-&gt;rule() == %s_rule);\n&quot;,
1048                 inst_position, inst_position, inst_name);
1049       }
1050     } else {
1051       // Check that user did not try to constrain a placeholder
1052       assert( ! pconstraint-&gt;constrains_instruction(inst_position),
1053               &quot;fatal(): Can not constrain a placeholder instruction&quot;);
1054     }
1055   }
1056 }
1057 
1058 // Build mapping for register indices, num_edges to input
1059 static void build_instruction_index_mapping( FILE *fp, FormDict &amp;globals, PeepMatch *pmatch ) {
1060   int         parent        = -1;
1061   int         inst_position = 0;
1062   const char* inst_name     = NULL;
1063   int         input         = 0;
1064   fprintf(fp, &quot;      // Build map to register info\n&quot;);
1065   pmatch-&gt;reset();
1066   for( pmatch-&gt;next_instruction( parent, inst_position, inst_name, input );
1067        inst_name != NULL;
1068        pmatch-&gt;next_instruction( parent, inst_position, inst_name, input ) ) {
1069     // If this is not a placeholder
1070     if( ! pmatch-&gt;is_placeholder() ) {
1071       // Define temporaries &#39;inst#&#39;, based on self&#39;s inst_position
1072       InstructForm *inst = globals[inst_name]-&gt;is_instruction();
1073       if( inst != NULL ) {
1074         char inst_prefix[]  = &quot;instXXXX_&quot;;
1075         sprintf(inst_prefix, &quot;inst%d_&quot;,   inst_position);
1076         char receiver[]     = &quot;instXXXX-&gt;&quot;;
1077         sprintf(receiver,    &quot;inst%d-&gt;&quot;, inst_position);
1078         inst-&gt;index_temps( fp, globals, inst_prefix, receiver );
1079       }
1080     }
1081   }
1082 }
1083 
1084 // Generate tests for the constraints
1085 static void check_peepconstraints(FILE *fp, FormDict &amp;globals, PeepMatch *pmatch, PeepConstraint *pconstraint) {
1086   fprintf(fp, &quot;\n&quot;);
1087   fprintf(fp, &quot;      // Check constraints on sub-tree-leaves\n&quot;);
1088 
1089   // Build mapping from num_edges to local variables
1090   build_instruction_index_mapping( fp, globals, pmatch );
1091 
1092   // Build constraint tests
1093   if( pconstraint != NULL ) {
1094     fprintf(fp, &quot;      matches = matches &amp;&amp;&quot;);
1095     bool   first_constraint = true;
1096     while( pconstraint != NULL ) {
1097       // indentation and connecting &#39;&amp;&amp;&#39;
1098       const char *indentation = &quot;      &quot;;
1099       fprintf(fp, &quot;\n%s%s&quot;, indentation, (!first_constraint ? &quot;&amp;&amp; &quot; : &quot;  &quot;));
1100 
1101       // Only have &#39;==&#39; relation implemented
1102       if( strcmp(pconstraint-&gt;_relation,&quot;==&quot;) != 0 ) {
1103         assert( false, &quot;Unimplemented()&quot; );
1104       }
1105 
1106       // LEFT
1107       int left_index       = pconstraint-&gt;_left_inst;
1108       const char *left_op  = pconstraint-&gt;_left_op;
1109       // Access info on the instructions whose operands are compared
1110       InstructForm *inst_left = globals[pmatch-&gt;instruction_name(left_index)]-&gt;is_instruction();
1111       assert( inst_left, &quot;Parser should guaranty this is an instruction&quot;);
1112       int left_op_base  = inst_left-&gt;oper_input_base(globals);
1113       // Access info on the operands being compared
1114       int left_op_index  = inst_left-&gt;operand_position(left_op, Component::USE);
1115       if( left_op_index == -1 ) {
1116         left_op_index = inst_left-&gt;operand_position(left_op, Component::DEF);
1117         if( left_op_index == -1 ) {
1118           left_op_index = inst_left-&gt;operand_position(left_op, Component::USE_DEF);
1119         }
1120       }
1121       assert( left_op_index  != NameList::Not_in_list, &quot;Did not find operand in instruction&quot;);
1122       ComponentList components_left = inst_left-&gt;_components;
1123       const char *left_comp_type = components_left.at(left_op_index)-&gt;_type;
1124       OpClassForm *left_opclass = globals[left_comp_type]-&gt;is_opclass();
1125       Form::InterfaceType left_interface_type = left_opclass-&gt;interface_type(globals);
1126 
1127 
1128       // RIGHT
1129       int right_op_index = -1;
1130       int right_index      = pconstraint-&gt;_right_inst;
1131       const char *right_op = pconstraint-&gt;_right_op;
1132       if( right_index != -1 ) { // Match operand
1133         // Access info on the instructions whose operands are compared
1134         InstructForm *inst_right = globals[pmatch-&gt;instruction_name(right_index)]-&gt;is_instruction();
1135         assert( inst_right, &quot;Parser should guaranty this is an instruction&quot;);
1136         int right_op_base = inst_right-&gt;oper_input_base(globals);
1137         // Access info on the operands being compared
1138         right_op_index = inst_right-&gt;operand_position(right_op, Component::USE);
1139         if( right_op_index == -1 ) {
1140           right_op_index = inst_right-&gt;operand_position(right_op, Component::DEF);
1141           if( right_op_index == -1 ) {
1142             right_op_index = inst_right-&gt;operand_position(right_op, Component::USE_DEF);
1143           }
1144         }
1145         assert( right_op_index != NameList::Not_in_list, &quot;Did not find operand in instruction&quot;);
1146         ComponentList components_right = inst_right-&gt;_components;
1147         const char *right_comp_type = components_right.at(right_op_index)-&gt;_type;
1148         OpClassForm *right_opclass = globals[right_comp_type]-&gt;is_opclass();
1149         Form::InterfaceType right_interface_type = right_opclass-&gt;interface_type(globals);
1150         assert( right_interface_type == left_interface_type, &quot;Both must be same interface&quot;);
1151 
1152       } else {                  // Else match register
1153         // assert( false, &quot;should be a register&quot; );
1154       }
1155 
1156       //
1157       // Check for equivalence
1158       //
1159       // fprintf(fp, &quot;phase-&gt;eqv( &quot;);
1160       // fprintf(fp, &quot;inst%d-&gt;in(%d+%d) /* %s */, inst%d-&gt;in(%d+%d) /* %s */&quot;,
1161       //         left_index,  left_op_base,  left_op_index,  left_op,
1162       //         right_index, right_op_base, right_op_index, right_op );
1163       // fprintf(fp, &quot;)&quot;);
1164       //
1165       switch( left_interface_type ) {
1166       case Form::register_interface: {
1167         // Check that they are allocated to the same register
1168         // Need parameter for index position if not result operand
1169         char left_reg_index[] = &quot;,instXXXX_idxXXXX&quot;;
1170         if( left_op_index != 0 ) {
1171           assert( (left_index &lt;= 9999) &amp;&amp; (left_op_index &lt;= 9999), &quot;exceed string size&quot;);
1172           // Must have index into operands
1173           sprintf(left_reg_index,&quot;,inst%d_idx%d&quot;, (int)left_index, left_op_index);
1174         } else {
1175           strcpy(left_reg_index, &quot;&quot;);
1176         }
1177         fprintf(fp, &quot;(inst%d-&gt;_opnds[%d]-&gt;reg(ra_,inst%d%s)  /* %d.%s */&quot;,
1178                 left_index,  left_op_index, left_index, left_reg_index, left_index, left_op );
1179         fprintf(fp, &quot; == &quot;);
1180 
1181         if( right_index != -1 ) {
1182           char right_reg_index[18] = &quot;,instXXXX_idxXXXX&quot;;
1183           if( right_op_index != 0 ) {
1184             assert( (right_index &lt;= 9999) &amp;&amp; (right_op_index &lt;= 9999), &quot;exceed string size&quot;);
1185             // Must have index into operands
1186             sprintf(right_reg_index,&quot;,inst%d_idx%d&quot;, (int)right_index, right_op_index);
1187           } else {
1188             strcpy(right_reg_index, &quot;&quot;);
1189           }
1190           fprintf(fp, &quot;/* %d.%s */ inst%d-&gt;_opnds[%d]-&gt;reg(ra_,inst%d%s)&quot;,
1191                   right_index, right_op, right_index, right_op_index, right_index, right_reg_index );
1192         } else {
1193           fprintf(fp, &quot;%s_enc&quot;, right_op );
1194         }
1195         fprintf(fp,&quot;)&quot;);
1196         break;
1197       }
1198       case Form::constant_interface: {
1199         // Compare the &#39;-&gt;constant()&#39; values
1200         fprintf(fp, &quot;(inst%d-&gt;_opnds[%d]-&gt;constant()  /* %d.%s */&quot;,
1201                 left_index,  left_op_index,  left_index, left_op );
1202         fprintf(fp, &quot; == &quot;);
1203         fprintf(fp, &quot;/* %d.%s */ inst%d-&gt;_opnds[%d]-&gt;constant())&quot;,
1204                 right_index, right_op, right_index, right_op_index );
1205         break;
1206       }
1207       case Form::memory_interface: {
1208         // Compare &#39;base&#39;, &#39;index&#39;, &#39;scale&#39;, and &#39;disp&#39;
1209         // base
1210         fprintf(fp, &quot;( \n&quot;);
1211         fprintf(fp, &quot;  (inst%d-&gt;_opnds[%d]-&gt;base(ra_,inst%d,inst%d_idx%d)  /* %d.%s$$base */&quot;,
1212           left_index, left_op_index, left_index, left_index, left_op_index, left_index, left_op );
1213         fprintf(fp, &quot; == &quot;);
1214         fprintf(fp, &quot;/* %d.%s$$base */ inst%d-&gt;_opnds[%d]-&gt;base(ra_,inst%d,inst%d_idx%d)) &amp;&amp;\n&quot;,
1215                 right_index, right_op, right_index, right_op_index, right_index, right_index, right_op_index );
1216         // index
1217         fprintf(fp, &quot;  (inst%d-&gt;_opnds[%d]-&gt;index(ra_,inst%d,inst%d_idx%d)  /* %d.%s$$index */&quot;,
1218                 left_index, left_op_index, left_index, left_index, left_op_index, left_index, left_op );
1219         fprintf(fp, &quot; == &quot;);
1220         fprintf(fp, &quot;/* %d.%s$$index */ inst%d-&gt;_opnds[%d]-&gt;index(ra_,inst%d,inst%d_idx%d)) &amp;&amp;\n&quot;,
1221                 right_index, right_op, right_index, right_op_index, right_index, right_index, right_op_index );
1222         // scale
1223         fprintf(fp, &quot;  (inst%d-&gt;_opnds[%d]-&gt;scale()  /* %d.%s$$scale */&quot;,
1224                 left_index,  left_op_index,  left_index, left_op );
1225         fprintf(fp, &quot; == &quot;);
1226         fprintf(fp, &quot;/* %d.%s$$scale */ inst%d-&gt;_opnds[%d]-&gt;scale()) &amp;&amp;\n&quot;,
1227                 right_index, right_op, right_index, right_op_index );
1228         // disp
1229         fprintf(fp, &quot;  (inst%d-&gt;_opnds[%d]-&gt;disp(ra_,inst%d,inst%d_idx%d)  /* %d.%s$$disp */&quot;,
1230                 left_index, left_op_index, left_index, left_index, left_op_index, left_index, left_op );
1231         fprintf(fp, &quot; == &quot;);
1232         fprintf(fp, &quot;/* %d.%s$$disp */ inst%d-&gt;_opnds[%d]-&gt;disp(ra_,inst%d,inst%d_idx%d))\n&quot;,
1233                 right_index, right_op, right_index, right_op_index, right_index, right_index, right_op_index );
1234         fprintf(fp, &quot;) \n&quot;);
1235         break;
1236       }
1237       case Form::conditional_interface: {
1238         // Compare the condition code being tested
1239         assert( false, &quot;Unimplemented()&quot; );
1240         break;
1241       }
1242       default: {
1243         assert( false, &quot;ShouldNotReachHere()&quot; );
1244         break;
1245       }
1246       }
1247 
1248       // Advance to next constraint
1249       pconstraint = pconstraint-&gt;next();
1250       first_constraint = false;
1251     }
1252 
1253     fprintf(fp, &quot;;\n&quot;);
1254   }
1255 }
1256 
1257 // // EXPERIMENTAL -- TEMPORARY code
1258 // static Form::DataType get_operand_type(FormDict &amp;globals, InstructForm *instr, const char *op_name ) {
1259 //   int op_index = instr-&gt;operand_position(op_name, Component::USE);
1260 //   if( op_index == -1 ) {
1261 //     op_index = instr-&gt;operand_position(op_name, Component::DEF);
1262 //     if( op_index == -1 ) {
1263 //       op_index = instr-&gt;operand_position(op_name, Component::USE_DEF);
1264 //     }
1265 //   }
1266 //   assert( op_index != NameList::Not_in_list, &quot;Did not find operand in instruction&quot;);
1267 //
1268 //   ComponentList components_right = instr-&gt;_components;
1269 //   char *right_comp_type = components_right.at(op_index)-&gt;_type;
1270 //   OpClassForm *right_opclass = globals[right_comp_type]-&gt;is_opclass();
1271 //   Form::InterfaceType  right_interface_type = right_opclass-&gt;interface_type(globals);
1272 //
1273 //   return;
1274 // }
1275 
1276 // Construct the new sub-tree
1277 static void generate_peepreplace( FILE *fp, FormDict &amp;globals, PeepMatch *pmatch, PeepConstraint *pconstraint, PeepReplace *preplace, int max_position ) {
1278   fprintf(fp, &quot;      // IF instructions and constraints matched\n&quot;);
1279   fprintf(fp, &quot;      if( matches ) {\n&quot;);
1280   fprintf(fp, &quot;        // generate the new sub-tree\n&quot;);
1281   fprintf(fp, &quot;        assert( true, \&quot;Debug stopping point\&quot;);\n&quot;);
1282   if( preplace != NULL ) {
1283     // Get the root of the new sub-tree
1284     const char *root_inst = NULL;
1285     preplace-&gt;next_instruction(root_inst);
1286     InstructForm *root_form = globals[root_inst]-&gt;is_instruction();
1287     assert( root_form != NULL, &quot;Replacement instruction was not previously defined&quot;);
1288     fprintf(fp, &quot;        %sNode *root = new %sNode();\n&quot;, root_inst, root_inst);
1289 
1290     int         inst_num;
1291     const char *op_name;
1292     int         opnds_index = 0;            // define result operand
1293     // Then install the use-operands for the new sub-tree
1294     // preplace-&gt;reset();             // reset breaks iteration
1295     for( preplace-&gt;next_operand( inst_num, op_name );
1296          op_name != NULL;
1297          preplace-&gt;next_operand( inst_num, op_name ) ) {
1298       InstructForm *inst_form;
1299       inst_form  = globals[pmatch-&gt;instruction_name(inst_num)]-&gt;is_instruction();
1300       assert( inst_form, &quot;Parser should guaranty this is an instruction&quot;);
1301       int inst_op_num = inst_form-&gt;operand_position(op_name, Component::USE);
1302       if( inst_op_num == NameList::Not_in_list )
1303         inst_op_num = inst_form-&gt;operand_position(op_name, Component::USE_DEF);
1304       assert( inst_op_num != NameList::Not_in_list, &quot;Did not find operand as USE&quot;);
1305       // find the name of the OperandForm from the local name
1306       const Form *form   = inst_form-&gt;_localNames[op_name];
1307       OperandForm  *op_form = form-&gt;is_operand();
1308       if( opnds_index == 0 ) {
1309         // Initial setup of new instruction
1310         fprintf(fp, &quot;        // ----- Initial setup -----\n&quot;);
1311         //
1312         // Add control edge for this node
1313         fprintf(fp, &quot;        root-&gt;add_req(_in[0]);                // control edge\n&quot;);
1314         // Add unmatched edges from root of match tree
1315         int op_base = root_form-&gt;oper_input_base(globals);
1316         for( int unmatched_edge = 1; unmatched_edge &lt; op_base; ++unmatched_edge ) {
1317           fprintf(fp, &quot;        root-&gt;add_req(inst%d-&gt;in(%d));        // unmatched ideal edge\n&quot;,
1318                                           inst_num, unmatched_edge);
1319         }
1320         // If new instruction captures bottom type
1321         if( root_form-&gt;captures_bottom_type(globals) ) {
1322           // Get bottom type from instruction whose result we are replacing
1323           fprintf(fp, &quot;        root-&gt;_bottom_type = inst%d-&gt;bottom_type();\n&quot;, inst_num);
1324         }
1325         // Define result register and result operand
1326         fprintf(fp, &quot;        ra_-&gt;add_reference(root, inst%d);\n&quot;, inst_num);
1327         fprintf(fp, &quot;        ra_-&gt;set_oop (root, ra_-&gt;is_oop(inst%d));\n&quot;, inst_num);
1328         fprintf(fp, &quot;        ra_-&gt;set_pair(root-&gt;_idx, ra_-&gt;get_reg_second(inst%d), ra_-&gt;get_reg_first(inst%d));\n&quot;, inst_num, inst_num);
1329         fprintf(fp, &quot;        root-&gt;_opnds[0] = inst%d-&gt;_opnds[0]-&gt;clone(); // result\n&quot;, inst_num);
1330         fprintf(fp, &quot;        // ----- Done with initial setup -----\n&quot;);
1331       } else {
1332         if( (op_form == NULL) || (op_form-&gt;is_base_constant(globals) == Form::none) ) {
1333           // Do not have ideal edges for constants after matching
1334           fprintf(fp, &quot;        for( unsigned x%d = inst%d_idx%d; x%d &lt; inst%d_idx%d; x%d++ )\n&quot;,
1335                   inst_op_num, inst_num, inst_op_num,
1336                   inst_op_num, inst_num, inst_op_num+1, inst_op_num );
1337           fprintf(fp, &quot;          root-&gt;add_req( inst%d-&gt;in(x%d) );\n&quot;,
1338                   inst_num, inst_op_num );
1339         } else {
1340           fprintf(fp, &quot;        // no ideal edge for constants after matching\n&quot;);
1341         }
1342         fprintf(fp, &quot;        root-&gt;_opnds[%d] = inst%d-&gt;_opnds[%d]-&gt;clone();\n&quot;,
1343                 opnds_index, inst_num, inst_op_num );
1344       }
1345       ++opnds_index;
1346     }
1347   }else {
1348     // Replacing subtree with empty-tree
1349     assert( false, &quot;ShouldNotReachHere();&quot;);
1350   }
1351 
1352   // Return the new sub-tree
1353   fprintf(fp, &quot;        deleted = %d;\n&quot;, max_position+1 /*zero to one based*/);
1354   fprintf(fp, &quot;        return root;  // return new root;\n&quot;);
1355   fprintf(fp, &quot;      }\n&quot;);
1356 }
1357 
1358 
1359 // Define the Peephole method for an instruction node
1360 void ArchDesc::definePeephole(FILE *fp, InstructForm *node) {
1361   // Generate Peephole function header
1362   fprintf(fp, &quot;MachNode *%sNode::peephole(Block *block, int block_index, PhaseRegAlloc *ra_, int &amp;deleted) {\n&quot;, node-&gt;_ident);
1363   fprintf(fp, &quot;  bool  matches = true;\n&quot;);
1364 
1365   // Identify the maximum instruction position,
1366   // generate temporaries that hold current instruction
1367   //
1368   //   MachNode  *inst0 = NULL;
1369   //   ...
1370   //   MachNode  *instMAX = NULL;
1371   //
1372   int max_position = 0;
1373   Peephole *peep;
1374   for( peep = node-&gt;peepholes(); peep != NULL; peep = peep-&gt;next() ) {
1375     PeepMatch *pmatch = peep-&gt;match();
1376     assert( pmatch != NULL, &quot;fatal(), missing peepmatch rule&quot;);
1377     if( max_position &lt; pmatch-&gt;max_position() )  max_position = pmatch-&gt;max_position();
1378   }
1379   for( int i = 0; i &lt;= max_position; ++i ) {
1380     if( i == 0 ) {
1381       fprintf(fp, &quot;  MachNode *inst0 = this;\n&quot;);
1382     } else {
1383       fprintf(fp, &quot;  MachNode *inst%d = NULL;\n&quot;, i);
1384     }
1385   }
1386 
1387   // For each peephole rule in architecture description
1388   //   Construct a test for the desired instruction sub-tree
1389   //   then check the constraints
1390   //   If these match, Generate the new subtree
1391   for( peep = node-&gt;peepholes(); peep != NULL; peep = peep-&gt;next() ) {
1392     int         peephole_number = peep-&gt;peephole_number();
1393     PeepMatch      *pmatch      = peep-&gt;match();
1394     PeepConstraint *pconstraint = peep-&gt;constraints();
1395     PeepReplace    *preplace    = peep-&gt;replacement();
1396 
1397     // Root of this peephole is the current MachNode
1398     assert( true, // %%name?%% strcmp( node-&gt;_ident, pmatch-&gt;name(0) ) == 0,
1399             &quot;root of PeepMatch does not match instruction&quot;);
1400 
1401     // Make each peephole rule individually selectable
1402     fprintf(fp, &quot;  if( (OptoPeepholeAt == -1) || (OptoPeepholeAt==%d) ) {\n&quot;, peephole_number);
1403     fprintf(fp, &quot;    matches = true;\n&quot;);
1404     // Scan the peepmatch and output a test for each instruction
1405     check_peepmatch_instruction_sequence( fp, pmatch, pconstraint );
1406 
1407     // Check constraints and build replacement inside scope
1408     fprintf(fp, &quot;    // If instruction subtree matches\n&quot;);
1409     fprintf(fp, &quot;    if( matches ) {\n&quot;);
1410 
1411     // Generate tests for the constraints
1412     check_peepconstraints( fp, _globalNames, pmatch, pconstraint );
1413 
1414     // Construct the new sub-tree
1415     generate_peepreplace( fp, _globalNames, pmatch, pconstraint, preplace, max_position );
1416 
1417     // End of scope for this peephole&#39;s constraints
1418     fprintf(fp, &quot;    }\n&quot;);
1419     // Closing brace &#39;}&#39; to make each peephole rule individually selectable
1420     fprintf(fp, &quot;  } // end of peephole rule #%d\n&quot;, peephole_number);
1421     fprintf(fp, &quot;\n&quot;);
1422   }
1423 
1424   fprintf(fp, &quot;  return NULL;  // No peephole rules matched\n&quot;);
1425   fprintf(fp, &quot;}\n&quot;);
1426   fprintf(fp, &quot;\n&quot;);
1427 }
1428 
1429 // Define the Expand method for an instruction node
1430 void ArchDesc::defineExpand(FILE *fp, InstructForm *node) {
1431   unsigned      cnt  = 0;          // Count nodes we have expand into
1432   unsigned      i;
1433 
1434   // Generate Expand function header
1435   fprintf(fp, &quot;MachNode* %sNode::Expand(State* state, Node_List&amp; proj_list, Node* mem) {\n&quot;, node-&gt;_ident);
1436   fprintf(fp, &quot;  Compile* C = Compile::current();\n&quot;);
1437   // Generate expand code
1438   if( node-&gt;expands() ) {
1439     const char   *opid;
1440     int           new_pos, exp_pos;
1441     const char   *new_id   = NULL;
1442     const Form   *frm      = NULL;
1443     InstructForm *new_inst = NULL;
1444     OperandForm  *new_oper = NULL;
1445     unsigned      numo     = node-&gt;num_opnds() +
1446                                 node-&gt;_exprule-&gt;_newopers.count();
1447 
1448     // If necessary, generate any operands created in expand rule
1449     if (node-&gt;_exprule-&gt;_newopers.count()) {
1450       for(node-&gt;_exprule-&gt;_newopers.reset();
1451           (new_id = node-&gt;_exprule-&gt;_newopers.iter()) != NULL; cnt++) {
1452         frm = node-&gt;_localNames[new_id];
1453         assert(frm, &quot;Invalid entry in new operands list of expand rule&quot;);
1454         new_oper = frm-&gt;is_operand();
1455         char *tmp = (char *)node-&gt;_exprule-&gt;_newopconst[new_id];
1456         if (tmp == NULL) {
1457           fprintf(fp,&quot;  MachOper *op%d = new %sOper();\n&quot;,
1458                   cnt, new_oper-&gt;_ident);
1459         }
1460         else {
1461           fprintf(fp,&quot;  MachOper *op%d = new %sOper(%s);\n&quot;,
1462                   cnt, new_oper-&gt;_ident, tmp);
1463         }
1464       }
1465     }
1466     cnt = 0;
1467     // Generate the temps to use for DAG building
1468     for(i = 0; i &lt; numo; i++) {
1469       if (i &lt; node-&gt;num_opnds()) {
1470         fprintf(fp,&quot;  MachNode *tmp%d = this;\n&quot;, i);
1471       }
1472       else {
1473         fprintf(fp,&quot;  MachNode *tmp%d = NULL;\n&quot;, i);
1474       }
1475     }
1476     // Build mapping from num_edges to local variables
1477     fprintf(fp,&quot;  unsigned num0 = 0;\n&quot;);
1478     for( i = 1; i &lt; node-&gt;num_opnds(); i++ ) {
1479       fprintf(fp,&quot;  unsigned num%d = opnd_array(%d)-&gt;num_edges();\n&quot;,i,i);
1480     }
1481 
1482     // Build a mapping from operand index to input edges
1483     fprintf(fp,&quot;  unsigned idx0 = oper_input_base();\n&quot;);
1484 
1485     // The order in which the memory input is added to a node is very
1486     // strange.  Store nodes get a memory input before Expand is
1487     // called and other nodes get it afterwards or before depending on
1488     // match order so oper_input_base is wrong during expansion.  This
1489     // code adjusts it so that expansion will work correctly.
1490     int has_memory_edge = node-&gt;_matrule-&gt;needs_ideal_memory_edge(_globalNames);
1491     if (has_memory_edge) {
1492       fprintf(fp,&quot;  if (mem == (Node*)1) {\n&quot;);
1493       fprintf(fp,&quot;    idx0--; // Adjust base because memory edge hasn&#39;t been inserted yet\n&quot;);
1494       fprintf(fp,&quot;  }\n&quot;);
1495     }
1496 
1497     for( i = 0; i &lt; node-&gt;num_opnds(); i++ ) {
1498       fprintf(fp,&quot;  unsigned idx%d = idx%d + num%d;\n&quot;,
1499               i+1,i,i);
1500     }
1501 
1502     // Declare variable to hold root of expansion
1503     fprintf(fp,&quot;  MachNode *result = NULL;\n&quot;);
1504 
1505     // Iterate over the instructions &#39;node&#39; expands into
1506     ExpandRule  *expand       = node-&gt;_exprule;
1507     NameAndList *expand_instr = NULL;
1508     for (expand-&gt;reset_instructions();
1509          (expand_instr = expand-&gt;iter_instructions()) != NULL; cnt++) {
1510       new_id = expand_instr-&gt;name();
1511 
1512       InstructForm* expand_instruction = (InstructForm*)globalAD-&gt;globalNames()[new_id];
1513 
1514       if (!expand_instruction) {
1515         globalAD-&gt;syntax_err(node-&gt;_linenum, &quot;In %s: instruction %s used in expand not declared\n&quot;,
1516                              node-&gt;_ident, new_id);
1517         continue;
1518       }
1519 
1520       // Build the node for the instruction
1521       fprintf(fp,&quot;\n  %sNode *n%d = new %sNode();\n&quot;, new_id, cnt, new_id);
1522       // Add control edge for this node
1523       fprintf(fp,&quot;  n%d-&gt;add_req(_in[0]);\n&quot;, cnt);
1524       // Build the operand for the value this node defines.
1525       Form *form = (Form*)_globalNames[new_id];
1526       assert(form, &quot;&#39;new_id&#39; must be a defined form name&quot;);
1527       // Grab the InstructForm for the new instruction
1528       new_inst = form-&gt;is_instruction();
1529       assert(new_inst, &quot;&#39;new_id&#39; must be an instruction name&quot;);
1530       if (node-&gt;is_ideal_if() &amp;&amp; new_inst-&gt;is_ideal_if()) {
1531         fprintf(fp, &quot;  ((MachIfNode*)n%d)-&gt;_prob = _prob;\n&quot;, cnt);
1532         fprintf(fp, &quot;  ((MachIfNode*)n%d)-&gt;_fcnt = _fcnt;\n&quot;, cnt);
1533       }
1534 
1535       if (node-&gt;is_ideal_fastlock() &amp;&amp; new_inst-&gt;is_ideal_fastlock()) {
1536         fprintf(fp, &quot;  ((MachFastLockNode*)n%d)-&gt;_counters = _counters;\n&quot;, cnt);
1537         fprintf(fp, &quot;  ((MachFastLockNode*)n%d)-&gt;_rtm_counters = _rtm_counters;\n&quot;, cnt);
1538         fprintf(fp, &quot;  ((MachFastLockNode*)n%d)-&gt;_stack_rtm_counters = _stack_rtm_counters;\n&quot;, cnt);
1539       }
1540 
1541       // Fill in the bottom_type where requested
1542       if (node-&gt;captures_bottom_type(_globalNames) &amp;&amp;
1543           new_inst-&gt;captures_bottom_type(_globalNames)) {
1544         fprintf(fp, &quot;  ((MachTypeNode*)n%d)-&gt;_bottom_type = bottom_type();\n&quot;, cnt);
1545       }
1546 
1547       const char *resultOper = new_inst-&gt;reduce_result();
1548       fprintf(fp,&quot;  n%d-&gt;set_opnd_array(0, state-&gt;MachOperGenerator(%s));\n&quot;,
1549               cnt, machOperEnum(resultOper));
1550 
1551       // get the formal operand NameList
1552       NameList *formal_lst = &amp;new_inst-&gt;_parameters;
1553       formal_lst-&gt;reset();
1554 
1555       // Handle any memory operand
1556       int memory_operand = new_inst-&gt;memory_operand(_globalNames);
1557       if( memory_operand != InstructForm::NO_MEMORY_OPERAND ) {
1558         int node_mem_op = node-&gt;memory_operand(_globalNames);
1559         assert( node_mem_op != InstructForm::NO_MEMORY_OPERAND,
1560                 &quot;expand rule member needs memory but top-level inst doesn&#39;t have any&quot; );
1561         if (has_memory_edge) {
1562           // Copy memory edge
1563           fprintf(fp,&quot;  if (mem != (Node*)1) {\n&quot;);
1564           fprintf(fp,&quot;    n%d-&gt;add_req(_in[1]);\t// Add memory edge\n&quot;, cnt);
1565           fprintf(fp,&quot;  }\n&quot;);
1566         }
1567       }
1568 
1569       // Iterate over the new instruction&#39;s operands
1570       int prev_pos = -1;
1571       for( expand_instr-&gt;reset(); (opid = expand_instr-&gt;iter()) != NULL; ) {
1572         // Use &#39;parameter&#39; at current position in list of new instruction&#39;s formals
1573         // instead of &#39;opid&#39; when looking up info internal to new_inst
1574         const char *parameter = formal_lst-&gt;iter();
1575         if (!parameter) {
1576           globalAD-&gt;syntax_err(node-&gt;_linenum, &quot;Operand %s of expand instruction %s has&quot;
1577                                &quot; no equivalent in new instruction %s.&quot;,
1578                                opid, node-&gt;_ident, new_inst-&gt;_ident);
1579           assert(0, &quot;Wrong expand&quot;);
1580         }
1581 
1582         // Check for an operand which is created in the expand rule
1583         if ((exp_pos = node-&gt;_exprule-&gt;_newopers.index(opid)) != -1) {
1584           new_pos = new_inst-&gt;operand_position(parameter,Component::USE);
1585           exp_pos += node-&gt;num_opnds();
1586           // If there is no use of the created operand, just skip it
1587           if (new_pos != NameList::Not_in_list) {
1588             //Copy the operand from the original made above
1589             fprintf(fp,&quot;  n%d-&gt;set_opnd_array(%d, op%d-&gt;clone()); // %s\n&quot;,
1590                     cnt, new_pos, exp_pos-node-&gt;num_opnds(), opid);
1591             // Check for who defines this operand &amp; add edge if needed
1592             fprintf(fp,&quot;  if(tmp%d != NULL)\n&quot;, exp_pos);
1593             fprintf(fp,&quot;    n%d-&gt;add_req(tmp%d);\n&quot;, cnt, exp_pos);
1594           }
1595         }
1596         else {
1597           // Use operand name to get an index into instruction component list
1598           // ins = (InstructForm *) _globalNames[new_id];
1599           exp_pos = node-&gt;operand_position_format(opid);
1600           assert(exp_pos != -1, &quot;Bad expand rule&quot;);
1601           if (prev_pos &gt; exp_pos &amp;&amp; expand_instruction-&gt;_matrule != NULL) {
1602             // For the add_req calls below to work correctly they need
1603             // to added in the same order that a match would add them.
1604             // This means that they would need to be in the order of
1605             // the components list instead of the formal parameters.
1606             // This is a sort of hidden invariant that previously
1607             // wasn&#39;t checked and could lead to incorrectly
1608             // constructed nodes.
1609             syntax_err(node-&gt;_linenum, &quot;For expand in %s to work, parameter declaration order in %s must follow matchrule\n&quot;,
1610                        node-&gt;_ident, new_inst-&gt;_ident);
1611           }
1612           prev_pos = exp_pos;
1613 
1614           new_pos = new_inst-&gt;operand_position(parameter,Component::USE);
1615           if (new_pos != -1) {
1616             // Copy the operand from the ExpandNode to the new node
1617             fprintf(fp,&quot;  n%d-&gt;set_opnd_array(%d, opnd_array(%d)-&gt;clone()); // %s\n&quot;,
1618                     cnt, new_pos, exp_pos, opid);
1619             // For each operand add appropriate input edges by looking at tmp&#39;s
1620             fprintf(fp,&quot;  if(tmp%d == this) {\n&quot;, exp_pos);
1621             // Grab corresponding edges from ExpandNode and insert them here
1622             fprintf(fp,&quot;    for(unsigned i = 0; i &lt; num%d; i++) {\n&quot;, exp_pos);
1623             fprintf(fp,&quot;      n%d-&gt;add_req(_in[i + idx%d]);\n&quot;, cnt, exp_pos);
1624             fprintf(fp,&quot;    }\n&quot;);
1625             fprintf(fp,&quot;  }\n&quot;);
1626             // This value is generated by one of the new instructions
1627             fprintf(fp,&quot;  else n%d-&gt;add_req(tmp%d);\n&quot;, cnt, exp_pos);
1628           }
1629         }
1630 
1631         // Update the DAG tmp&#39;s for values defined by this instruction
1632         int new_def_pos = new_inst-&gt;operand_position(parameter,Component::DEF);
1633         Effect *eform = (Effect *)new_inst-&gt;_effects[parameter];
1634         // If this operand is a definition in either an effects rule
1635         // or a match rule
1636         if((eform) &amp;&amp; (is_def(eform-&gt;_use_def))) {
1637           // Update the temp associated with this operand
1638           fprintf(fp,&quot;  tmp%d = n%d;\n&quot;, exp_pos, cnt);
1639         }
1640         else if( new_def_pos != -1 ) {
1641           // Instruction defines a value but user did not declare it
1642           // in the &#39;effect&#39; clause
1643           fprintf(fp,&quot;  tmp%d = n%d;\n&quot;, exp_pos, cnt);
1644         }
1645       } // done iterating over a new instruction&#39;s operands
1646 
1647       // Fix number of operands, as we do not generate redundant ones.
1648       // The matcher generates some redundant operands, which are removed
1649       // in the expand function (of the node we generate here). We don&#39;t
1650       // generate the redundant operands here, so set the correct _num_opnds.
1651       if (expand_instruction-&gt;num_opnds() != expand_instruction-&gt;num_unique_opnds()) {
1652         fprintf(fp, &quot;  n%d-&gt;_num_opnds = %d; // Only unique opnds generated.\n&quot;,
1653                 cnt, expand_instruction-&gt;num_unique_opnds());
1654       }
1655 
1656       // Invoke Expand() for the newly created instruction.
1657       fprintf(fp,&quot;  result = n%d-&gt;Expand( state, proj_list, mem );\n&quot;, cnt);
1658       assert( !new_inst-&gt;expands(), &quot;Do not have complete support for recursive expansion&quot;);
1659     } // done iterating over new instructions
1660     fprintf(fp,&quot;\n&quot;);
1661   } // done generating expand rule
1662 
1663   // Generate projections for instruction&#39;s additional DEFs and KILLs
1664   if( ! node-&gt;expands() &amp;&amp; (node-&gt;needs_projections() || node-&gt;has_temps())) {
1665     // Get string representing the MachNode that projections point at
1666     const char *machNode = &quot;this&quot;;
1667     // Generate the projections
1668     fprintf(fp,&quot;  // Add projection edges for additional defs or kills\n&quot;);
1669 
1670     // Examine each component to see if it is a DEF or KILL
1671     node-&gt;_components.reset();
1672     // Skip the first component, if already handled as (SET dst (...))
1673     Component *comp = NULL;
1674     // For kills, the choice of projection numbers is arbitrary
1675     int proj_no = 1;
1676     bool declared_def  = false;
1677     bool declared_kill = false;
1678 
1679     while ((comp = node-&gt;_components.iter()) != NULL) {
1680       // Lookup register class associated with operand type
1681       Form *form = (Form*)_globalNames[comp-&gt;_type];
1682       assert(form, &quot;component type must be a defined form&quot;);
1683       OperandForm *op = form-&gt;is_operand();
1684 
1685       if (comp-&gt;is(Component::TEMP) ||
1686           comp-&gt;is(Component::TEMP_DEF)) {
1687         fprintf(fp, &quot;  // TEMP %s\n&quot;, comp-&gt;_name);
1688         if (!declared_def) {
1689           // Define the variable &quot;def&quot; to hold new MachProjNodes
1690           fprintf(fp, &quot;  MachTempNode *def;\n&quot;);
1691           declared_def = true;
1692         }
1693         if (op &amp;&amp; op-&gt;_interface &amp;&amp; op-&gt;_interface-&gt;is_RegInterface()) {
1694           fprintf(fp,&quot;  def = new MachTempNode(state-&gt;MachOperGenerator(%s));\n&quot;,
1695                   machOperEnum(op-&gt;_ident));
1696           fprintf(fp,&quot;  add_req(def);\n&quot;);
1697           // The operand for TEMP is already constructed during
1698           // this mach node construction, see buildMachNode().
1699           //
1700           // int idx  = node-&gt;operand_position_format(comp-&gt;_name);
1701           // fprintf(fp,&quot;  set_opnd_array(%d, state-&gt;MachOperGenerator(%s));\n&quot;,
1702           //         idx, machOperEnum(op-&gt;_ident));
1703         } else {
1704           assert(false, &quot;can&#39;t have temps which aren&#39;t registers&quot;);
1705         }
1706       } else if (comp-&gt;isa(Component::KILL)) {
1707         fprintf(fp, &quot;  // DEF/KILL %s\n&quot;, comp-&gt;_name);
1708 
1709         if (!declared_kill) {
1710           // Define the variable &quot;kill&quot; to hold new MachProjNodes
1711           fprintf(fp, &quot;  MachProjNode *kill;\n&quot;);
1712           declared_kill = true;
1713         }
1714 
1715         assert(op, &quot;Support additional KILLS for base operands&quot;);
1716         const char *regmask    = reg_mask(*op);
1717         const char *ideal_type = op-&gt;ideal_type(_globalNames, _register);
1718 
1719         if (!op-&gt;is_bound_register()) {
1720           syntax_err(node-&gt;_linenum, &quot;In %s only bound registers can be killed: %s %s\n&quot;,
1721                      node-&gt;_ident, comp-&gt;_type, comp-&gt;_name);
1722         }
1723 
1724         fprintf(fp,&quot;  kill = &quot;);
1725         fprintf(fp,&quot;new MachProjNode( %s, %d, (%s), Op_%s );\n&quot;,
1726                 machNode, proj_no++, regmask, ideal_type);
1727         fprintf(fp,&quot;  proj_list.push(kill);\n&quot;);
1728       }
1729     }
1730   }
1731 
1732   if( !node-&gt;expands() &amp;&amp; node-&gt;_matrule != NULL ) {
1733     // Remove duplicated operands and inputs which use the same name.
1734     // Search through match operands for the same name usage.
1735     // The matcher generates these non-unique operands. If the node
1736     // was constructed by an expand rule, there are no unique operands.
1737     uint cur_num_opnds = node-&gt;num_opnds();
1738     if (cur_num_opnds &gt; 1 &amp;&amp; cur_num_opnds != node-&gt;num_unique_opnds()) {
1739       Component *comp = NULL;
1740       fprintf(fp, &quot;  // Remove duplicated operands and inputs which use the same name.\n&quot;);
1741       fprintf(fp, &quot;  if (num_opnds() == %d) {\n&quot;, cur_num_opnds);
1742       // Build mapping from num_edges to local variables
1743       fprintf(fp,&quot;    unsigned num0 = 0;\n&quot;);
1744       for (i = 1; i &lt; cur_num_opnds; i++) {
1745         fprintf(fp,&quot;    unsigned num%d = opnd_array(%d)-&gt;num_edges();&quot;, i, i);
1746         fprintf(fp, &quot; \t// %s\n&quot;, node-&gt;opnd_ident(i));
1747       }
1748       // Build a mapping from operand index to input edges
1749       fprintf(fp,&quot;    unsigned idx0 = oper_input_base();\n&quot;);
1750       for (i = 0; i &lt; cur_num_opnds; i++) {
1751         fprintf(fp,&quot;    unsigned idx%d = idx%d + num%d;\n&quot;, i+1, i, i);
1752       }
1753 
1754       uint new_num_opnds = 1;
1755       node-&gt;_components.reset();
1756       // Skip first unique operands.
1757       for (i = 1; i &lt; cur_num_opnds; i++) {
1758         comp = node-&gt;_components.iter();
1759         if (i != node-&gt;unique_opnds_idx(i)) {
1760           break;
1761         }
1762         new_num_opnds++;
1763       }
1764       // Replace not unique operands with next unique operands.
1765       for ( ; i &lt; cur_num_opnds; i++) {
1766         comp = node-&gt;_components.iter();
1767         uint j = node-&gt;unique_opnds_idx(i);
1768         // unique_opnds_idx(i) is unique if unique_opnds_idx(j) is not unique.
1769         if (j != node-&gt;unique_opnds_idx(j)) {
1770           fprintf(fp,&quot;    set_opnd_array(%d, opnd_array(%d)-&gt;clone()); // %s\n&quot;,
1771                   new_num_opnds, i, comp-&gt;_name);
1772           // Delete not unique edges here.
1773           fprintf(fp,&quot;    for (unsigned i = 0; i &lt; num%d; i++) {\n&quot;, i);
1774           fprintf(fp,&quot;      set_req(i + idx%d, _in[i + idx%d]);\n&quot;, new_num_opnds, i);
1775           fprintf(fp,&quot;    }\n&quot;);
1776           fprintf(fp,&quot;    num%d = num%d;\n&quot;, new_num_opnds, i);
1777           fprintf(fp,&quot;    idx%d = idx%d + num%d;\n&quot;, new_num_opnds+1, new_num_opnds, new_num_opnds);
1778           new_num_opnds++;
1779         }
1780       }
1781       // Delete the rest of edges.
1782       fprintf(fp,&quot;    for (int i = idx%d - 1; i &gt;= (int)idx%d; i--) {\n&quot;, cur_num_opnds, new_num_opnds);
1783       fprintf(fp,&quot;      del_req(i);\n&quot;);
1784       fprintf(fp,&quot;    }\n&quot;);
1785       fprintf(fp,&quot;    _num_opnds = %d;\n&quot;, new_num_opnds);
1786       assert(new_num_opnds == node-&gt;num_unique_opnds(), &quot;what?&quot;);
1787       fprintf(fp, &quot;  } else {\n&quot;);
1788       fprintf(fp, &quot;    assert(_num_opnds == %d, \&quot;There should be either %d or %d operands.\&quot;);\n&quot;,
1789                   new_num_opnds, new_num_opnds, cur_num_opnds);
1790       fprintf(fp, &quot;  }\n&quot;);
1791     }
1792   }
1793 
1794   // If the node is a MachConstantNode, insert the MachConstantBaseNode edge.
1795   // NOTE: this edge must be the last input (see MachConstantNode::mach_constant_base_node_input).
1796   // There are nodes that don&#39;t use $constantablebase, but still require that it
1797   // is an input to the node. Example: divF_reg_immN, Repl32B_imm on x86_64.
1798   if (node-&gt;is_mach_constant() || node-&gt;needs_constant_base()) {
1799     if (node-&gt;is_ideal_call() != Form::invalid_type &amp;&amp;
1800         node-&gt;is_ideal_call() != Form::JAVA_LEAF) {
1801       fprintf(fp, &quot;  // MachConstantBaseNode added in matcher.\n&quot;);
1802       _needs_clone_jvms = true;
1803     } else {
1804       fprintf(fp, &quot;  add_req(C-&gt;mach_constant_base_node());\n&quot;);
1805     }
1806   }
1807 
1808   fprintf(fp, &quot;\n&quot;);
1809   if (node-&gt;expands()) {
1810     fprintf(fp, &quot;  return result;\n&quot;);
1811   } else {
1812     fprintf(fp, &quot;  return this;\n&quot;);
1813   }
1814   fprintf(fp, &quot;}\n&quot;);
1815   fprintf(fp, &quot;\n&quot;);
1816 }
1817 
1818 
1819 //------------------------------Emit Routines----------------------------------
1820 // Special classes and routines for defining node emit routines which output
1821 // target specific instruction object encodings.
1822 // Define the ___Node::emit() routine
1823 //
1824 // (1) void  ___Node::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
1825 // (2)   // ...  encoding defined by user
1826 // (3)
1827 // (4) }
1828 //
1829 
1830 class DefineEmitState {
1831 private:
1832   enum reloc_format { RELOC_NONE        = -1,
1833                       RELOC_IMMEDIATE   =  0,
1834                       RELOC_DISP        =  1,
1835                       RELOC_CALL_DISP   =  2 };
1836   enum literal_status{ LITERAL_NOT_SEEN  = 0,
1837                        LITERAL_SEEN      = 1,
1838                        LITERAL_ACCESSED  = 2,
1839                        LITERAL_OUTPUT    = 3 };
1840   // Temporaries that describe current operand
1841   bool          _cleared;
1842   OpClassForm  *_opclass;
1843   OperandForm  *_operand;
1844   int           _operand_idx;
1845   const char   *_local_name;
1846   const char   *_operand_name;
1847   bool          _doing_disp;
1848   bool          _doing_constant;
1849   Form::DataType _constant_type;
1850   DefineEmitState::literal_status _constant_status;
1851   DefineEmitState::literal_status _reg_status;
1852   bool          _doing_emit8;
1853   bool          _doing_emit_d32;
1854   bool          _doing_emit_d16;
1855   bool          _doing_emit_hi;
1856   bool          _doing_emit_lo;
1857   bool          _may_reloc;
1858   reloc_format  _reloc_form;
1859   const char *  _reloc_type;
1860   bool          _processing_noninput;
1861 
1862   NameList      _strings_to_emit;
1863 
1864   // Stable state, set by constructor
1865   ArchDesc     &amp;_AD;
1866   FILE         *_fp;
1867   EncClass     &amp;_encoding;
1868   InsEncode    &amp;_ins_encode;
1869   InstructForm &amp;_inst;
1870 
1871 public:
1872   DefineEmitState(FILE *fp, ArchDesc &amp;AD, EncClass &amp;encoding,
1873                   InsEncode &amp;ins_encode, InstructForm &amp;inst)
1874     : _AD(AD), _fp(fp), _encoding(encoding), _ins_encode(ins_encode), _inst(inst) {
1875       clear();
1876   }
1877 
1878   void clear() {
1879     _cleared       = true;
1880     _opclass       = NULL;
1881     _operand       = NULL;
1882     _operand_idx   = 0;
1883     _local_name    = &quot;&quot;;
1884     _operand_name  = &quot;&quot;;
1885     _doing_disp    = false;
1886     _doing_constant= false;
1887     _constant_type = Form::none;
1888     _constant_status = LITERAL_NOT_SEEN;
1889     _reg_status      = LITERAL_NOT_SEEN;
1890     _doing_emit8   = false;
1891     _doing_emit_d32= false;
1892     _doing_emit_d16= false;
1893     _doing_emit_hi = false;
1894     _doing_emit_lo = false;
1895     _may_reloc     = false;
1896     _reloc_form    = RELOC_NONE;
1897     _reloc_type    = AdlcVMDeps::none_reloc_type();
1898     _strings_to_emit.clear();
1899   }
1900 
1901   // Track necessary state when identifying a replacement variable
1902   // @arg rep_var: The formal parameter of the encoding.
1903   void update_state(const char *rep_var) {
1904     // A replacement variable or one of its subfields
1905     // Obtain replacement variable from list
1906     if ( (*rep_var) != &#39;$&#39; ) {
1907       // A replacement variable, &#39;$&#39; prefix
1908       // check_rep_var( rep_var );
1909       if ( Opcode::as_opcode_type(rep_var) != Opcode::NOT_AN_OPCODE ) {
1910         // No state needed.
1911         assert( _opclass == NULL,
1912                 &quot;&#39;primary&#39;, &#39;secondary&#39; and &#39;tertiary&#39; don&#39;t follow operand.&quot;);
1913       }
1914       else if ((strcmp(rep_var, &quot;constanttablebase&quot;) == 0) ||
1915                (strcmp(rep_var, &quot;constantoffset&quot;)    == 0) ||
1916                (strcmp(rep_var, &quot;constantaddress&quot;)   == 0)) {
1917         if (!(_inst.is_mach_constant() || _inst.needs_constant_base())) {
1918           _AD.syntax_err(_encoding._linenum,
1919                          &quot;Replacement variable %s not allowed in instruct %s (only in MachConstantNode or MachCall).\n&quot;,
1920                          rep_var, _encoding._name);
1921         }
1922       }
1923       else {
1924         // Lookup its position in (formal) parameter list of encoding
1925         int   param_no  = _encoding.rep_var_index(rep_var);
1926         if ( param_no == -1 ) {
1927           _AD.syntax_err( _encoding._linenum,
1928                           &quot;Replacement variable %s not found in enc_class %s.\n&quot;,
1929                           rep_var, _encoding._name);
1930         }
1931 
1932         // Lookup the corresponding ins_encode parameter
1933         // This is the argument (actual parameter) to the encoding.
1934         const char *inst_rep_var = _ins_encode.rep_var_name(_inst, param_no);
1935         if (inst_rep_var == NULL) {
1936           _AD.syntax_err( _ins_encode._linenum,
1937                           &quot;Parameter %s not passed to enc_class %s from instruct %s.\n&quot;,
1938                           rep_var, _encoding._name, _inst._ident);
1939           assert(false, &quot;inst_rep_var == NULL, cannot continue.&quot;);
1940         }
1941 
1942         // Check if instruction&#39;s actual parameter is a local name in the instruction
1943         const Form  *local     = _inst._localNames[inst_rep_var];
1944         OpClassForm *opc       = (local != NULL) ? local-&gt;is_opclass() : NULL;
1945         // Note: assert removed to allow constant and symbolic parameters
1946         // assert( opc, &quot;replacement variable was not found in local names&quot;);
1947         // Lookup the index position iff the replacement variable is a localName
1948         int idx  = (opc != NULL) ? _inst.operand_position_format(inst_rep_var) : -1;
1949 
1950         if ( idx != -1 ) {
1951           // This is a local in the instruction
1952           // Update local state info.
1953           _opclass        = opc;
1954           _operand_idx    = idx;
1955           _local_name     = rep_var;
1956           _operand_name   = inst_rep_var;
1957 
1958           // !!!!!
1959           // Do not support consecutive operands.
1960           assert( _operand == NULL, &quot;Unimplemented()&quot;);
1961           _operand = opc-&gt;is_operand();
1962         }
1963         else if( ADLParser::is_literal_constant(inst_rep_var) ) {
1964           // Instruction provided a constant expression
1965           // Check later that encoding specifies $$$constant to resolve as constant
1966           _constant_status   = LITERAL_SEEN;
1967         }
1968         else if( Opcode::as_opcode_type(inst_rep_var) != Opcode::NOT_AN_OPCODE ) {
1969           // Instruction provided an opcode: &quot;primary&quot;, &quot;secondary&quot;, &quot;tertiary&quot;
1970           // Check later that encoding specifies $$$constant to resolve as constant
1971           _constant_status   = LITERAL_SEEN;
1972         }
1973         else if((_AD.get_registers() != NULL ) &amp;&amp; (_AD.get_registers()-&gt;getRegDef(inst_rep_var) != NULL)) {
1974           // Instruction provided a literal register name for this parameter
1975           // Check that encoding specifies $$$reg to resolve.as register.
1976           _reg_status        = LITERAL_SEEN;
1977         }
1978         else {
1979           // Check for unimplemented functionality before hard failure
1980           assert(opc != NULL &amp;&amp; strcmp(opc-&gt;_ident, &quot;label&quot;) == 0, &quot;Unimplemented Label&quot;);
1981           assert(false, &quot;ShouldNotReachHere()&quot;);
1982         }
1983       } // done checking which operand this is.
1984     } else {
1985       //
1986       // A subfield variable, &#39;$$&#39; prefix
1987       // Check for fields that may require relocation information.
1988       // Then check that literal register parameters are accessed with &#39;reg&#39; or &#39;constant&#39;
1989       //
1990       if ( strcmp(rep_var,&quot;$disp&quot;) == 0 ) {
1991         _doing_disp = true;
1992         assert( _opclass, &quot;Must use operand or operand class before &#39;$disp&#39;&quot;);
1993         if( _operand == NULL ) {
1994           // Only have an operand class, generate run-time check for relocation
1995           _may_reloc    = true;
1996           _reloc_form   = RELOC_DISP;
1997           _reloc_type   = AdlcVMDeps::oop_reloc_type();
1998         } else {
1999           // Do precise check on operand: is it a ConP or not
2000           //
2001           // Check interface for value of displacement
2002           assert( ( _operand-&gt;_interface != NULL ),
2003                   &quot;$disp can only follow memory interface operand&quot;);
2004           MemInterface *mem_interface= _operand-&gt;_interface-&gt;is_MemInterface();
2005           assert( mem_interface != NULL,
2006                   &quot;$disp can only follow memory interface operand&quot;);
2007           const char *disp = mem_interface-&gt;_disp;
2008 
2009           if( disp != NULL &amp;&amp; (*disp == &#39;$&#39;) ) {
2010             // MemInterface::disp contains a replacement variable,
2011             // Check if this matches a ConP
2012             //
2013             // Lookup replacement variable, in operand&#39;s component list
2014             const char *rep_var_name = disp + 1; // Skip &#39;$&#39;
2015             const Component *comp = _operand-&gt;_components.search(rep_var_name);
2016             assert( comp != NULL,&quot;Replacement variable not found in components&quot;);
2017             const char      *type = comp-&gt;_type;
2018             // Lookup operand form for replacement variable&#39;s type
2019             const Form *form = _AD.globalNames()[type];
2020             assert( form != NULL, &quot;Replacement variable&#39;s type not found&quot;);
2021             OperandForm *op = form-&gt;is_operand();
2022             assert( op, &quot;Attempting to emit a non-register or non-constant&quot;);
2023             // Check if this is a constant
2024             if (op-&gt;_matrule &amp;&amp; op-&gt;_matrule-&gt;is_base_constant(_AD.globalNames())) {
2025               // Check which constant this name maps to: _c0, _c1, ..., _cn
2026               // const int idx = _operand.constant_position(_AD.globalNames(), comp);
2027               // assert( idx != -1, &quot;Constant component not found in operand&quot;);
2028               Form::DataType dtype = op-&gt;is_base_constant(_AD.globalNames());
2029               if ( dtype == Form::idealP ) {
2030                 _may_reloc    = true;
2031                 // No longer true that idealP is always an oop
2032                 _reloc_form   = RELOC_DISP;
2033                 _reloc_type   = AdlcVMDeps::oop_reloc_type();
2034               }
2035             }
2036 
2037             else if( _operand-&gt;is_user_name_for_sReg() != Form::none ) {
2038               // The only non-constant allowed access to disp is an operand sRegX in a stackSlotX
2039               assert( op-&gt;ideal_to_sReg_type(type) != Form::none, &quot;StackSlots access displacements using &#39;sRegs&#39;&quot;);
2040               _may_reloc   = false;
2041             } else {
2042               assert( false, &quot;fatal(); Only stackSlots can access a non-constant using &#39;disp&#39;&quot;);
2043             }
2044           }
2045         } // finished with precise check of operand for relocation.
2046       } // finished with subfield variable
2047       else if ( strcmp(rep_var,&quot;$constant&quot;) == 0 ) {
2048         _doing_constant = true;
2049         if ( _constant_status == LITERAL_NOT_SEEN ) {
2050           // Check operand for type of constant
2051           assert( _operand, &quot;Must use operand before &#39;$$constant&#39;&quot;);
2052           Form::DataType dtype = _operand-&gt;is_base_constant(_AD.globalNames());
2053           _constant_type = dtype;
2054           if ( dtype == Form::idealP ) {
2055             _may_reloc    = true;
2056             // No longer true that idealP is always an oop
2057             // // _must_reloc   = true;
2058             _reloc_form   = RELOC_IMMEDIATE;
2059             _reloc_type   = AdlcVMDeps::oop_reloc_type();
2060           } else {
2061             // No relocation information needed
2062           }
2063         } else {
2064           // User-provided literals may not require relocation information !!!!!
2065           assert( _constant_status == LITERAL_SEEN, &quot;Must know we are processing a user-provided literal&quot;);
2066         }
2067       }
2068       else if ( strcmp(rep_var,&quot;$label&quot;) == 0 ) {
2069         // Calls containing labels require relocation
2070         if ( _inst.is_ideal_call() )  {
2071           _may_reloc    = true;
2072           // !!!!! !!!!!
2073           _reloc_type   = AdlcVMDeps::none_reloc_type();
2074         }
2075       }
2076 
2077       // literal register parameter must be accessed as a &#39;reg&#39; field.
2078       if ( _reg_status != LITERAL_NOT_SEEN ) {
2079         assert( _reg_status == LITERAL_SEEN, &quot;Must have seen register literal before now&quot;);
2080         if (strcmp(rep_var,&quot;$reg&quot;) == 0 || reg_conversion(rep_var) != NULL) {
2081           _reg_status  = LITERAL_ACCESSED;
2082         } else {
2083           _AD.syntax_err(_encoding._linenum,
2084                          &quot;Invalid access to literal register parameter &#39;%s&#39; in %s.\n&quot;,
2085                          rep_var, _encoding._name);
2086           assert( false, &quot;invalid access to literal register parameter&quot;);
2087         }
2088       }
2089       // literal constant parameters must be accessed as a &#39;constant&#39; field
2090       if (_constant_status != LITERAL_NOT_SEEN) {
2091         assert(_constant_status == LITERAL_SEEN, &quot;Must have seen constant literal before now&quot;);
2092         if (strcmp(rep_var,&quot;$constant&quot;) == 0) {
2093           _constant_status = LITERAL_ACCESSED;
2094         } else {
2095           _AD.syntax_err(_encoding._linenum,
2096                          &quot;Invalid access to literal constant parameter &#39;%s&#39; in %s.\n&quot;,
2097                          rep_var, _encoding._name);
2098         }
2099       }
2100     } // end replacement and/or subfield
2101 
2102   }
2103 
2104   void add_rep_var(const char *rep_var) {
2105     // Handle subfield and replacement variables.
2106     if ( ( *rep_var == &#39;$&#39; ) &amp;&amp; ( *(rep_var+1) == &#39;$&#39; ) ) {
2107       // Check for emit prefix, &#39;$$emit32&#39;
2108       assert( _cleared, &quot;Can not nest $$$emit32&quot;);
2109       if ( strcmp(rep_var,&quot;$$emit32&quot;) == 0 ) {
2110         _doing_emit_d32 = true;
2111       }
2112       else if ( strcmp(rep_var,&quot;$$emit16&quot;) == 0 ) {
2113         _doing_emit_d16 = true;
2114       }
2115       else if ( strcmp(rep_var,&quot;$$emit_hi&quot;) == 0 ) {
2116         _doing_emit_hi  = true;
2117       }
2118       else if ( strcmp(rep_var,&quot;$$emit_lo&quot;) == 0 ) {
2119         _doing_emit_lo  = true;
2120       }
2121       else if ( strcmp(rep_var,&quot;$$emit8&quot;) == 0 ) {
2122         _doing_emit8    = true;
2123       }
2124       else {
2125         _AD.syntax_err(_encoding._linenum, &quot;Unsupported $$operation &#39;%s&#39;\n&quot;,rep_var);
2126         assert( false, &quot;fatal();&quot;);
2127       }
2128     }
2129     else {
2130       // Update state for replacement variables
2131       update_state( rep_var );
2132       _strings_to_emit.addName(rep_var);
2133     }
2134     _cleared  = false;
2135   }
2136 
2137   void emit_replacement() {
2138     // A replacement variable or one of its subfields
2139     // Obtain replacement variable from list
2140     // const char *ec_rep_var = encoding-&gt;_rep_vars.iter();
2141     const char *rep_var;
2142     _strings_to_emit.reset();
2143     while ( (rep_var = _strings_to_emit.iter()) != NULL ) {
2144 
2145       if ( (*rep_var) == &#39;$&#39; ) {
2146         // A subfield variable, &#39;$$&#39; prefix
2147         emit_field( rep_var );
2148       } else {
2149         if (_strings_to_emit.peek() != NULL &amp;&amp;
2150             strcmp(_strings_to_emit.peek(), &quot;$Address&quot;) == 0) {
2151           fprintf(_fp, &quot;Address::make_raw(&quot;);
2152 
2153           emit_rep_var( rep_var );
2154           fprintf(_fp,&quot;-&gt;base(ra_,this,idx%d), &quot;, _operand_idx);
2155 
2156           _reg_status = LITERAL_ACCESSED;
2157           emit_rep_var( rep_var );
2158           fprintf(_fp,&quot;-&gt;index(ra_,this,idx%d), &quot;, _operand_idx);
2159 
2160           _reg_status = LITERAL_ACCESSED;
2161           emit_rep_var( rep_var );
2162           fprintf(_fp,&quot;-&gt;scale(), &quot;);
2163 
2164           _reg_status = LITERAL_ACCESSED;
2165           emit_rep_var( rep_var );
2166           Form::DataType stack_type = _operand ? _operand-&gt;is_user_name_for_sReg() : Form::none;
2167           if( _operand  &amp;&amp; _operand_idx==0 &amp;&amp; stack_type != Form::none ) {
2168             fprintf(_fp,&quot;-&gt;disp(ra_,this,0), &quot;);
2169           } else {
2170             fprintf(_fp,&quot;-&gt;disp(ra_,this,idx%d), &quot;, _operand_idx);
2171           }
2172 
2173           _reg_status = LITERAL_ACCESSED;
2174           emit_rep_var( rep_var );
2175           fprintf(_fp,&quot;-&gt;disp_reloc())&quot;);
2176 
2177           // skip trailing $Address
2178           _strings_to_emit.iter();
2179         } else {
2180           // A replacement variable, &#39;$&#39; prefix
2181           const char* next = _strings_to_emit.peek();
2182           const char* next2 = _strings_to_emit.peek(2);
2183           if (next != NULL &amp;&amp; next2 != NULL &amp;&amp; strcmp(next2, &quot;$Register&quot;) == 0 &amp;&amp;
2184               (strcmp(next, &quot;$base&quot;) == 0 || strcmp(next, &quot;$index&quot;) == 0)) {
2185             // handle $rev_var$$base$$Register and $rev_var$$index$$Register by
2186             // producing as_Register(opnd_array(#)-&gt;base(ra_,this,idx1)).
2187             fprintf(_fp, &quot;as_Register(&quot;);
2188             // emit the operand reference
2189             emit_rep_var( rep_var );
2190             rep_var = _strings_to_emit.iter();
2191             assert(strcmp(rep_var, &quot;$base&quot;) == 0 || strcmp(rep_var, &quot;$index&quot;) == 0, &quot;bad pattern&quot;);
2192             // handle base or index
2193             emit_field(rep_var);
2194             rep_var = _strings_to_emit.iter();
2195             assert(strcmp(rep_var, &quot;$Register&quot;) == 0, &quot;bad pattern&quot;);
2196             // close up the parens
2197             fprintf(_fp, &quot;)&quot;);
2198           } else {
2199             emit_rep_var( rep_var );
2200           }
2201         }
2202       } // end replacement and/or subfield
2203     }
2204   }
2205 
2206   void emit_reloc_type(const char* type) {
2207     fprintf(_fp, &quot;%s&quot;, type)
2208       ;
2209   }
2210 
2211 
2212   void emit() {
2213     //
2214     //   &quot;emit_d32_reloc(&quot; or &quot;emit_hi_reloc&quot; or &quot;emit_lo_reloc&quot;
2215     //
2216     // Emit the function name when generating an emit function
2217     if ( _doing_emit_d32 || _doing_emit_hi || _doing_emit_lo ) {
2218       const char *d32_hi_lo = _doing_emit_d32 ? &quot;d32&quot; : (_doing_emit_hi ? &quot;hi&quot; : &quot;lo&quot;);
2219       // In general, relocatable isn&#39;t known at compiler compile time.
2220       // Check results of prior scan
2221       if ( ! _may_reloc ) {
2222         // Definitely don&#39;t need relocation information
2223         fprintf( _fp, &quot;emit_%s(cbuf, &quot;, d32_hi_lo );
2224         emit_replacement(); fprintf(_fp, &quot;)&quot;);
2225       }
2226       else {
2227         // Emit RUNTIME CHECK to see if value needs relocation info
2228         // If emitting a relocatable address, use &#39;emit_d32_reloc&#39;
2229         const char *disp_constant = _doing_disp ? &quot;disp&quot; : _doing_constant ? &quot;constant&quot; : &quot;INVALID&quot;;
2230         assert( (_doing_disp || _doing_constant)
2231                 &amp;&amp; !(_doing_disp &amp;&amp; _doing_constant),
2232                 &quot;Must be emitting either a displacement or a constant&quot;);
2233         fprintf(_fp,&quot;\n&quot;);
2234         fprintf(_fp,&quot;if ( opnd_array(%d)-&gt;%s_reloc() != relocInfo::none ) {\n&quot;,
2235                 _operand_idx, disp_constant);
2236         fprintf(_fp,&quot;  &quot;);
2237         fprintf(_fp,&quot;emit_%s_reloc(cbuf, &quot;, d32_hi_lo );
2238         emit_replacement();             fprintf(_fp,&quot;, &quot;);
2239         fprintf(_fp,&quot;opnd_array(%d)-&gt;%s_reloc(), &quot;,
2240                 _operand_idx, disp_constant);
2241         fprintf(_fp, &quot;%d&quot;, _reloc_form);fprintf(_fp, &quot;);&quot;);
2242         fprintf(_fp,&quot;\n&quot;);
2243         fprintf(_fp,&quot;} else {\n&quot;);
2244         fprintf(_fp,&quot;  emit_%s(cbuf, &quot;, d32_hi_lo);
2245         emit_replacement(); fprintf(_fp, &quot;);\n&quot;); fprintf(_fp,&quot;}&quot;);
2246       }
2247     }
2248     else if ( _doing_emit_d16 ) {
2249       // Relocation of 16-bit values is not supported
2250       fprintf(_fp,&quot;emit_d16(cbuf, &quot;);
2251       emit_replacement(); fprintf(_fp, &quot;)&quot;);
2252       // No relocation done for 16-bit values
2253     }
2254     else if ( _doing_emit8 ) {
2255       // Relocation of 8-bit values is not supported
2256       fprintf(_fp,&quot;emit_d8(cbuf, &quot;);
2257       emit_replacement(); fprintf(_fp, &quot;)&quot;);
2258       // No relocation done for 8-bit values
2259     }
2260     else {
2261       // Not an emit# command, just output the replacement string.
2262       emit_replacement();
2263     }
2264 
2265     // Get ready for next state collection.
2266     clear();
2267   }
2268 
2269 private:
2270 
2271   // recognizes names which represent MacroAssembler register types
2272   // and return the conversion function to build them from OptoReg
2273   const char* reg_conversion(const char* rep_var) {
2274     if (strcmp(rep_var,&quot;$Register&quot;) == 0)      return &quot;as_Register&quot;;
2275     if (strcmp(rep_var,&quot;$FloatRegister&quot;) == 0) return &quot;as_FloatRegister&quot;;
2276 #if defined(IA32) || defined(AMD64)
2277     if (strcmp(rep_var,&quot;$XMMRegister&quot;) == 0)   return &quot;as_XMMRegister&quot;;
2278 #endif
2279     if (strcmp(rep_var,&quot;$CondRegister&quot;) == 0)  return &quot;as_ConditionRegister&quot;;
2280 #if defined(PPC64)
2281     if (strcmp(rep_var,&quot;$VectorRegister&quot;) == 0)   return &quot;as_VectorRegister&quot;;
2282     if (strcmp(rep_var,&quot;$VectorSRegister&quot;) == 0)  return &quot;as_VectorSRegister&quot;;
2283 #endif
2284     return NULL;
2285   }
2286 
2287   void emit_field(const char *rep_var) {
2288     const char* reg_convert = reg_conversion(rep_var);
2289 
2290     // A subfield variable, &#39;$$subfield&#39;
2291     if ( strcmp(rep_var, &quot;$reg&quot;) == 0 || reg_convert != NULL) {
2292       // $reg form or the $Register MacroAssembler type conversions
2293       assert( _operand_idx != -1,
2294               &quot;Must use this subfield after operand&quot;);
2295       if( _reg_status == LITERAL_NOT_SEEN ) {
2296         if (_processing_noninput) {
2297           const Form  *local     = _inst._localNames[_operand_name];
2298           OperandForm *oper      = local-&gt;is_operand();
2299           const RegDef* first = oper-&gt;get_RegClass()-&gt;find_first_elem();
2300           if (reg_convert != NULL) {
2301             fprintf(_fp, &quot;%s(%s_enc)&quot;, reg_convert, first-&gt;_regname);
2302           } else {
2303             fprintf(_fp, &quot;%s_enc&quot;, first-&gt;_regname);
2304           }
2305         } else {
2306           fprintf(_fp,&quot;-&gt;%s(ra_,this&quot;, reg_convert != NULL ? reg_convert : &quot;reg&quot;);
2307           // Add parameter for index position, if not result operand
2308           if( _operand_idx != 0 ) fprintf(_fp,&quot;,idx%d&quot;, _operand_idx);
2309           fprintf(_fp,&quot;)&quot;);
2310           fprintf(_fp, &quot;/* %s */&quot;, _operand_name);
2311         }
2312       } else {
2313         assert( _reg_status == LITERAL_OUTPUT, &quot;should have output register literal in emit_rep_var&quot;);
2314         // Register literal has already been sent to output file, nothing more needed
2315       }
2316     }
2317     else if ( strcmp(rep_var,&quot;$base&quot;) == 0 ) {
2318       assert( _operand_idx != -1,
2319               &quot;Must use this subfield after operand&quot;);
2320       assert( ! _may_reloc, &quot;UnImplemented()&quot;);
2321       fprintf(_fp,&quot;-&gt;base(ra_,this,idx%d)&quot;, _operand_idx);
2322     }
2323     else if ( strcmp(rep_var,&quot;$index&quot;) == 0 ) {
2324       assert( _operand_idx != -1,
2325               &quot;Must use this subfield after operand&quot;);
2326       assert( ! _may_reloc, &quot;UnImplemented()&quot;);
2327       fprintf(_fp,&quot;-&gt;index(ra_,this,idx%d)&quot;, _operand_idx);
2328     }
2329     else if ( strcmp(rep_var,&quot;$scale&quot;) == 0 ) {
2330       assert( ! _may_reloc, &quot;UnImplemented()&quot;);
2331       fprintf(_fp,&quot;-&gt;scale()&quot;);
2332     }
2333     else if ( strcmp(rep_var,&quot;$cmpcode&quot;) == 0 ) {
2334       assert( ! _may_reloc, &quot;UnImplemented()&quot;);
2335       fprintf(_fp,&quot;-&gt;ccode()&quot;);
2336     }
2337     else if ( strcmp(rep_var,&quot;$constant&quot;) == 0 ) {
2338       if( _constant_status == LITERAL_NOT_SEEN ) {
2339         if ( _constant_type == Form::idealD ) {
2340           fprintf(_fp,&quot;-&gt;constantD()&quot;);
2341         } else if ( _constant_type == Form::idealF ) {
2342           fprintf(_fp,&quot;-&gt;constantF()&quot;);
2343         } else if ( _constant_type == Form::idealL ) {
2344           fprintf(_fp,&quot;-&gt;constantL()&quot;);
2345         } else {
2346           fprintf(_fp,&quot;-&gt;constant()&quot;);
2347         }
2348       } else {
2349         assert( _constant_status == LITERAL_OUTPUT, &quot;should have output constant literal in emit_rep_var&quot;);
2350         // Constant literal has already been sent to output file, nothing more needed
2351       }
2352     }
2353     else if ( strcmp(rep_var,&quot;$disp&quot;) == 0 ) {
2354       Form::DataType stack_type = _operand ? _operand-&gt;is_user_name_for_sReg() : Form::none;
2355       if( _operand  &amp;&amp; _operand_idx==0 &amp;&amp; stack_type != Form::none ) {
2356         fprintf(_fp,&quot;-&gt;disp(ra_,this,0)&quot;);
2357       } else {
2358         fprintf(_fp,&quot;-&gt;disp(ra_,this,idx%d)&quot;, _operand_idx);
2359       }
2360     }
2361     else if ( strcmp(rep_var,&quot;$label&quot;) == 0 ) {
2362       fprintf(_fp,&quot;-&gt;label()&quot;);
2363     }
2364     else if ( strcmp(rep_var,&quot;$method&quot;) == 0 ) {
2365       fprintf(_fp,&quot;-&gt;method()&quot;);
2366     }
2367     else {
2368       printf(&quot;emit_field: %s\n&quot;,rep_var);
2369       globalAD-&gt;syntax_err(_inst._linenum, &quot;Unknown replacement variable %s in format statement of %s.&quot;,
2370                            rep_var, _inst._ident);
2371       assert( false, &quot;UnImplemented()&quot;);
2372     }
2373   }
2374 
2375 
2376   void emit_rep_var(const char *rep_var) {
2377     _processing_noninput = false;
2378     // A replacement variable, originally &#39;$&#39;
2379     if ( Opcode::as_opcode_type(rep_var) != Opcode::NOT_AN_OPCODE ) {
<a name="2" id="anc2"></a><span class="line-modified">2380       if (!_inst._opcode-&gt;print_opcode(_fp, Opcode::as_opcode_type(rep_var) )) {</span>
2381         // Missing opcode
2382         _AD.syntax_err( _inst._linenum,
2383                         &quot;Missing $%s opcode definition in %s, used by encoding %s\n&quot;,
2384                         rep_var, _inst._ident, _encoding._name);
2385       }
2386     }
2387     else if (strcmp(rep_var, &quot;constanttablebase&quot;) == 0) {
2388       fprintf(_fp, &quot;as_Register(ra_-&gt;get_encode(in(mach_constant_base_node_input())))&quot;);
2389     }
2390     else if (strcmp(rep_var, &quot;constantoffset&quot;) == 0) {
2391       fprintf(_fp, &quot;constant_offset()&quot;);
2392     }
2393     else if (strcmp(rep_var, &quot;constantaddress&quot;) == 0) {
2394       fprintf(_fp, &quot;InternalAddress(__ code()-&gt;consts()-&gt;start() + constant_offset())&quot;);
2395     }
2396     else {
2397       // Lookup its position in parameter list
2398       int   param_no  = _encoding.rep_var_index(rep_var);
2399       if ( param_no == -1 ) {
2400         _AD.syntax_err( _encoding._linenum,
2401                         &quot;Replacement variable %s not found in enc_class %s.\n&quot;,
2402                         rep_var, _encoding._name);
2403       }
2404       // Lookup the corresponding ins_encode parameter
2405       const char *inst_rep_var = _ins_encode.rep_var_name(_inst, param_no);
2406 
2407       // Check if instruction&#39;s actual parameter is a local name in the instruction
2408       const Form  *local     = _inst._localNames[inst_rep_var];
2409       OpClassForm *opc       = (local != NULL) ? local-&gt;is_opclass() : NULL;
2410       // Note: assert removed to allow constant and symbolic parameters
2411       // assert( opc, &quot;replacement variable was not found in local names&quot;);
2412       // Lookup the index position iff the replacement variable is a localName
2413       int idx  = (opc != NULL) ? _inst.operand_position_format(inst_rep_var) : -1;
2414       if( idx != -1 ) {
2415         if (_inst.is_noninput_operand(idx)) {
2416           // This operand isn&#39;t a normal input so printing it is done
2417           // specially.
2418           _processing_noninput = true;
2419         } else {
2420           // Output the emit code for this operand
2421           fprintf(_fp,&quot;opnd_array(%d)&quot;,idx);
2422         }
2423         assert( _operand == opc-&gt;is_operand(),
2424                 &quot;Previous emit $operand does not match current&quot;);
2425       }
2426       else if( ADLParser::is_literal_constant(inst_rep_var) ) {
2427         // else check if it is a constant expression
2428         // Removed following assert to allow primitive C types as arguments to encodings
2429         // assert( _constant_status == LITERAL_ACCESSED, &quot;Must be processing a literal constant parameter&quot;);
2430         fprintf(_fp,&quot;(%s)&quot;, inst_rep_var);
2431         _constant_status = LITERAL_OUTPUT;
2432       }
2433       else if( Opcode::as_opcode_type(inst_rep_var) != Opcode::NOT_AN_OPCODE ) {
2434         // else check if &quot;primary&quot;, &quot;secondary&quot;, &quot;tertiary&quot;
2435         assert( _constant_status == LITERAL_ACCESSED, &quot;Must be processing a literal constant parameter&quot;);
<a name="3" id="anc3"></a><span class="line-modified">2436         if (!_inst._opcode-&gt;print_opcode(_fp, Opcode::as_opcode_type(inst_rep_var) )) {</span>
2437           // Missing opcode
2438           _AD.syntax_err( _inst._linenum,
2439                           &quot;Missing $%s opcode definition in %s\n&quot;,
2440                           rep_var, _inst._ident);
2441 
2442         }
2443         _constant_status = LITERAL_OUTPUT;
2444       }
2445       else if((_AD.get_registers() != NULL ) &amp;&amp; (_AD.get_registers()-&gt;getRegDef(inst_rep_var) != NULL)) {
2446         // Instruction provided a literal register name for this parameter
2447         // Check that encoding specifies $$$reg to resolve.as register.
2448         assert( _reg_status == LITERAL_ACCESSED, &quot;Must be processing a literal register parameter&quot;);
2449         fprintf(_fp,&quot;(%s_enc)&quot;, inst_rep_var);
2450         _reg_status = LITERAL_OUTPUT;
2451       }
2452       else {
2453         // Check for unimplemented functionality before hard failure
2454         assert(opc != NULL &amp;&amp; strcmp(opc-&gt;_ident, &quot;label&quot;) == 0, &quot;Unimplemented Label&quot;);
2455         assert(false, &quot;ShouldNotReachHere()&quot;);
2456       }
2457       // all done
2458     }
2459   }
2460 
2461 };  // end class DefineEmitState
2462 
2463 
2464 void ArchDesc::defineSize(FILE *fp, InstructForm &amp;inst) {
2465 
2466   //(1)
2467   // Output instruction&#39;s emit prototype
2468   fprintf(fp,&quot;uint %sNode::size(PhaseRegAlloc *ra_) const {\n&quot;,
2469           inst._ident);
2470 
2471   fprintf(fp, &quot;  assert(VerifyOops || MachNode::size(ra_) &lt;= %s, \&quot;bad fixed size\&quot;);\n&quot;, inst._size);
2472 
2473   //(2)
2474   // Print the size
2475   fprintf(fp, &quot;  return (VerifyOops ? MachNode::size(ra_) : %s);\n&quot;, inst._size);
2476 
2477   // (3) and (4)
2478   fprintf(fp,&quot;}\n\n&quot;);
2479 }
2480 
2481 // Emit postalloc expand function.
2482 void ArchDesc::define_postalloc_expand(FILE *fp, InstructForm &amp;inst) {
2483   InsEncode *ins_encode = inst._insencode;
2484 
2485   // Output instruction&#39;s postalloc_expand prototype.
2486   fprintf(fp, &quot;void  %sNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {\n&quot;,
2487           inst._ident);
2488 
2489   assert((_encode != NULL) &amp;&amp; (ins_encode != NULL), &quot;You must define an encode section.&quot;);
2490 
2491   // Output each operand&#39;s offset into the array of registers.
2492   inst.index_temps(fp, _globalNames);
2493 
2494   // Output variables &quot;unsigned idx_&lt;par_name&gt;&quot;, Node *n_&lt;par_name&gt; and &quot;MachOpnd *op_&lt;par_name&gt;&quot;
2495   // for each parameter &lt;par_name&gt; specified in the encoding.
2496   ins_encode-&gt;reset();
2497   const char *ec_name = ins_encode-&gt;encode_class_iter();
2498   assert(ec_name != NULL, &quot;Postalloc expand must specify an encoding.&quot;);
2499 
2500   EncClass *encoding = _encode-&gt;encClass(ec_name);
2501   if (encoding == NULL) {
2502     fprintf(stderr, &quot;User did not define contents of this encode_class: %s\n&quot;, ec_name);
2503     abort();
2504   }
2505   if (ins_encode-&gt;current_encoding_num_args() != encoding-&gt;num_args()) {
2506     globalAD-&gt;syntax_err(ins_encode-&gt;_linenum, &quot;In %s: passing %d arguments to %s but expecting %d&quot;,
2507                          inst._ident, ins_encode-&gt;current_encoding_num_args(),
2508                          ec_name, encoding-&gt;num_args());
2509   }
2510 
2511   fprintf(fp, &quot;  // Access to ins and operands for postalloc expand.\n&quot;);
2512   const int buflen = 2000;
2513   char idxbuf[buflen]; char *ib = idxbuf; idxbuf[0] = &#39;\0&#39;;
2514   char nbuf  [buflen]; char *nb = nbuf;   nbuf[0]   = &#39;\0&#39;;
2515   char opbuf [buflen]; char *ob = opbuf;  opbuf[0]  = &#39;\0&#39;;
2516 
2517   encoding-&gt;_parameter_type.reset();
2518   encoding-&gt;_parameter_name.reset();
2519   const char *type = encoding-&gt;_parameter_type.iter();
2520   const char *name = encoding-&gt;_parameter_name.iter();
2521   int param_no = 0;
2522   for (; (type != NULL) &amp;&amp; (name != NULL);
2523        (type = encoding-&gt;_parameter_type.iter()), (name = encoding-&gt;_parameter_name.iter())) {
2524     const char* arg_name = ins_encode-&gt;rep_var_name(inst, param_no);
2525     int idx = inst.operand_position_format(arg_name);
2526     if (strcmp(arg_name, &quot;constanttablebase&quot;) == 0) {
2527       ib += sprintf(ib, &quot;  unsigned idx_%-5s = mach_constant_base_node_input(); \t// %s, \t%s\n&quot;,
2528                     name, type, arg_name);
2529       nb += sprintf(nb, &quot;  Node    *n_%-7s = lookup(idx_%s);\n&quot;, name, name);
2530       // There is no operand for the constanttablebase.
2531     } else if (inst.is_noninput_operand(idx)) {
2532       globalAD-&gt;syntax_err(inst._linenum,
2533                            &quot;In %s: you can not pass the non-input %s to a postalloc expand encoding.\n&quot;,
2534                            inst._ident, arg_name);
2535     } else {
2536       ib += sprintf(ib, &quot;  unsigned idx_%-5s = idx%d; \t// %s, \t%s\n&quot;,
2537                     name, idx, type, arg_name);
2538       nb += sprintf(nb, &quot;  Node    *n_%-7s = lookup(idx_%s);\n&quot;, name, name);
2539       ob += sprintf(ob, &quot;  %sOper *op_%s = (%sOper *)opnd_array(%d);\n&quot;, type, name, type, idx);
2540     }
2541     param_no++;
2542   }
2543   assert(ib &lt; &amp;idxbuf[buflen-1] &amp;&amp; nb &lt; &amp;nbuf[buflen-1] &amp;&amp; ob &lt; &amp;opbuf[buflen-1], &quot;buffer overflow&quot;);
2544 
2545   fprintf(fp, &quot;%s&quot;, idxbuf);
2546   fprintf(fp, &quot;  Node    *n_region  = lookup(0);\n&quot;);
2547   fprintf(fp, &quot;%s%s&quot;, nbuf, opbuf);
2548   fprintf(fp, &quot;  Compile *C = ra_-&gt;C;\n&quot;);
2549 
2550   // Output this instruction&#39;s encodings.
2551   fprintf(fp, &quot;  {&quot;);
2552   const char *ec_code    = NULL;
2553   const char *ec_rep_var = NULL;
2554   assert(encoding == _encode-&gt;encClass(ec_name), &quot;&quot;);
2555 
2556   DefineEmitState pending(fp, *this, *encoding, *ins_encode, inst);
2557   encoding-&gt;_code.reset();
2558   encoding-&gt;_rep_vars.reset();
2559   // Process list of user-defined strings,
2560   // and occurrences of replacement variables.
2561   // Replacement Vars are pushed into a list and then output.
2562   while ((ec_code = encoding-&gt;_code.iter()) != NULL) {
2563     if (! encoding-&gt;_code.is_signal(ec_code)) {
2564       // Emit pending code.
2565       pending.emit();
2566       pending.clear();
2567       // Emit this code section.
2568       fprintf(fp, &quot;%s&quot;, ec_code);
2569     } else {
2570       // A replacement variable or one of its subfields.
2571       // Obtain replacement variable from list.
2572       ec_rep_var = encoding-&gt;_rep_vars.iter();
2573       pending.add_rep_var(ec_rep_var);
2574     }
2575   }
2576   // Emit pending code.
2577   pending.emit();
2578   pending.clear();
2579   fprintf(fp, &quot;  }\n&quot;);
2580 
2581   fprintf(fp, &quot;}\n\n&quot;);
2582 
2583   ec_name = ins_encode-&gt;encode_class_iter();
2584   assert(ec_name == NULL, &quot;Postalloc expand may only have one encoding.&quot;);
2585 }
2586 
2587 // defineEmit -----------------------------------------------------------------
2588 void ArchDesc::defineEmit(FILE* fp, InstructForm&amp; inst) {
2589   InsEncode* encode = inst._insencode;
2590 
2591   // (1)
2592   // Output instruction&#39;s emit prototype
2593   fprintf(fp, &quot;void %sNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {\n&quot;, inst._ident);
2594 
2595   // If user did not define an encode section,
2596   // provide stub that does not generate any machine code.
2597   if( (_encode == NULL) || (encode == NULL) ) {
2598     fprintf(fp, &quot;  // User did not define an encode section.\n&quot;);
2599     fprintf(fp, &quot;}\n&quot;);
2600     return;
2601   }
2602 
2603   // Save current instruction&#39;s starting address (helps with relocation).
2604   fprintf(fp, &quot;  cbuf.set_insts_mark();\n&quot;);
2605 
2606   // For MachConstantNodes which are ideal jump nodes, fill the jump table.
2607   if (inst.is_mach_constant() &amp;&amp; inst.is_ideal_jump()) {
2608     fprintf(fp, &quot;  ra_-&gt;C-&gt;constant_table().fill_jump_table(cbuf, (MachConstantNode*) this, _index2label);\n&quot;);
2609   }
2610 
2611   // Output each operand&#39;s offset into the array of registers.
2612   inst.index_temps(fp, _globalNames);
2613 
2614   // Output this instruction&#39;s encodings
2615   const char *ec_name;
2616   bool        user_defined = false;
2617   encode-&gt;reset();
2618   while ((ec_name = encode-&gt;encode_class_iter()) != NULL) {
2619     fprintf(fp, &quot;  {\n&quot;);
2620     // Output user-defined encoding
2621     user_defined           = true;
2622 
2623     const char *ec_code    = NULL;
2624     const char *ec_rep_var = NULL;
2625     EncClass   *encoding   = _encode-&gt;encClass(ec_name);
2626     if (encoding == NULL) {
2627       fprintf(stderr, &quot;User did not define contents of this encode_class: %s\n&quot;, ec_name);
2628       abort();
2629     }
2630 
2631     if (encode-&gt;current_encoding_num_args() != encoding-&gt;num_args()) {
2632       globalAD-&gt;syntax_err(encode-&gt;_linenum, &quot;In %s: passing %d arguments to %s but expecting %d&quot;,
2633                            inst._ident, encode-&gt;current_encoding_num_args(),
2634                            ec_name, encoding-&gt;num_args());
2635     }
2636 
2637     DefineEmitState pending(fp, *this, *encoding, *encode, inst);
2638     encoding-&gt;_code.reset();
2639     encoding-&gt;_rep_vars.reset();
2640     // Process list of user-defined strings,
2641     // and occurrences of replacement variables.
2642     // Replacement Vars are pushed into a list and then output
2643     while ((ec_code = encoding-&gt;_code.iter()) != NULL) {
2644       if (!encoding-&gt;_code.is_signal(ec_code)) {
2645         // Emit pending code
2646         pending.emit();
2647         pending.clear();
2648         // Emit this code section
2649         fprintf(fp, &quot;%s&quot;, ec_code);
2650       } else {
2651         // A replacement variable or one of its subfields
2652         // Obtain replacement variable from list
2653         ec_rep_var  = encoding-&gt;_rep_vars.iter();
2654         pending.add_rep_var(ec_rep_var);
2655       }
2656     }
2657     // Emit pending code
2658     pending.emit();
2659     pending.clear();
2660     fprintf(fp, &quot;  }\n&quot;);
2661   } // end while instruction&#39;s encodings
2662 
2663   // Check if user stated which encoding to user
2664   if ( user_defined == false ) {
2665     fprintf(fp, &quot;  // User did not define which encode class to use.\n&quot;);
2666   }
2667 
2668   // (3) and (4)
2669   fprintf(fp, &quot;}\n\n&quot;);
2670 }
2671 
2672 // defineEvalConstant ---------------------------------------------------------
2673 void ArchDesc::defineEvalConstant(FILE* fp, InstructForm&amp; inst) {
2674   InsEncode* encode = inst._constant;
2675 
2676   // (1)
2677   // Output instruction&#39;s emit prototype
2678   fprintf(fp, &quot;void %sNode::eval_constant(Compile* C) {\n&quot;, inst._ident);
2679 
2680   // For ideal jump nodes, add a jump-table entry.
2681   if (inst.is_ideal_jump()) {
2682     fprintf(fp, &quot;  _constant = C-&gt;constant_table().add_jump_table(this);\n&quot;);
2683   }
2684 
2685   // If user did not define an encode section,
2686   // provide stub that does not generate any machine code.
2687   if ((_encode == NULL) || (encode == NULL)) {
2688     fprintf(fp, &quot;  // User did not define an encode section.\n&quot;);
2689     fprintf(fp, &quot;}\n&quot;);
2690     return;
2691   }
2692 
2693   // Output this instruction&#39;s encodings
2694   const char *ec_name;
2695   bool        user_defined = false;
2696   encode-&gt;reset();
2697   while ((ec_name = encode-&gt;encode_class_iter()) != NULL) {
2698     fprintf(fp, &quot;  {\n&quot;);
2699     // Output user-defined encoding
2700     user_defined           = true;
2701 
2702     const char *ec_code    = NULL;
2703     const char *ec_rep_var = NULL;
2704     EncClass   *encoding   = _encode-&gt;encClass(ec_name);
2705     if (encoding == NULL) {
2706       fprintf(stderr, &quot;User did not define contents of this encode_class: %s\n&quot;, ec_name);
2707       abort();
2708     }
2709 
2710     if (encode-&gt;current_encoding_num_args() != encoding-&gt;num_args()) {
2711       globalAD-&gt;syntax_err(encode-&gt;_linenum, &quot;In %s: passing %d arguments to %s but expecting %d&quot;,
2712                            inst._ident, encode-&gt;current_encoding_num_args(),
2713                            ec_name, encoding-&gt;num_args());
2714     }
2715 
2716     DefineEmitState pending(fp, *this, *encoding, *encode, inst);
2717     encoding-&gt;_code.reset();
2718     encoding-&gt;_rep_vars.reset();
2719     // Process list of user-defined strings,
2720     // and occurrences of replacement variables.
2721     // Replacement Vars are pushed into a list and then output
2722     while ((ec_code = encoding-&gt;_code.iter()) != NULL) {
2723       if (!encoding-&gt;_code.is_signal(ec_code)) {
2724         // Emit pending code
2725         pending.emit();
2726         pending.clear();
2727         // Emit this code section
2728         fprintf(fp, &quot;%s&quot;, ec_code);
2729       } else {
2730         // A replacement variable or one of its subfields
2731         // Obtain replacement variable from list
2732         ec_rep_var  = encoding-&gt;_rep_vars.iter();
2733         pending.add_rep_var(ec_rep_var);
2734       }
2735     }
2736     // Emit pending code
2737     pending.emit();
2738     pending.clear();
2739     fprintf(fp, &quot;  }\n&quot;);
2740   } // end while instruction&#39;s encodings
2741 
2742   // Check if user stated which encoding to user
2743   if (user_defined == false) {
2744     fprintf(fp, &quot;  // User did not define which encode class to use.\n&quot;);
2745   }
2746 
2747   // (3) and (4)
2748   fprintf(fp, &quot;}\n&quot;);
2749 }
2750 
2751 // ---------------------------------------------------------------------------
2752 //--------Utilities to build MachOper and MachNode derived Classes------------
2753 // ---------------------------------------------------------------------------
2754 
2755 //------------------------------Utilities to build Operand Classes------------
2756 static void defineIn_RegMask(FILE *fp, FormDict &amp;globals, OperandForm &amp;oper) {
2757   uint num_edges = oper.num_edges(globals);
2758   if( num_edges != 0 ) {
2759     // Method header
2760     fprintf(fp, &quot;const RegMask *%sOper::in_RegMask(int index) const {\n&quot;,
2761             oper._ident);
2762 
2763     // Assert that the index is in range.
2764     fprintf(fp, &quot;  assert(0 &lt;= index &amp;&amp; index &lt; %d, \&quot;index out of range\&quot;);\n&quot;,
2765             num_edges);
2766 
2767     // Figure out if all RegMasks are the same.
2768     const char* first_reg_class = oper.in_reg_class(0, globals);
2769     bool all_same = true;
2770     assert(first_reg_class != NULL, &quot;did not find register mask&quot;);
2771 
2772     for (uint index = 1; all_same &amp;&amp; index &lt; num_edges; index++) {
2773       const char* some_reg_class = oper.in_reg_class(index, globals);
2774       assert(some_reg_class != NULL, &quot;did not find register mask&quot;);
2775       if (strcmp(first_reg_class, some_reg_class) != 0) {
2776         all_same = false;
2777       }
2778     }
2779 
2780     if (all_same) {
2781       // Return the sole RegMask.
2782       if (strcmp(first_reg_class, &quot;stack_slots&quot;) == 0) {
2783         fprintf(fp,&quot;  return &amp;(Compile::current()-&gt;FIRST_STACK_mask());\n&quot;);
<a name="4" id="anc4"></a>

2784       } else {
2785         const char* first_reg_class_to_upper = toUpper(first_reg_class);
2786         fprintf(fp,&quot;  return &amp;%s_mask();\n&quot;, first_reg_class_to_upper);
2787         delete[] first_reg_class_to_upper;
2788       }
2789     } else {
2790       // Build a switch statement to return the desired mask.
2791       fprintf(fp,&quot;  switch (index) {\n&quot;);
2792 
2793       for (uint index = 0; index &lt; num_edges; index++) {
2794         const char *reg_class = oper.in_reg_class(index, globals);
2795         assert(reg_class != NULL, &quot;did not find register mask&quot;);
2796         if( !strcmp(reg_class, &quot;stack_slots&quot;) ) {
2797           fprintf(fp, &quot;  case %d: return &amp;(Compile::current()-&gt;FIRST_STACK_mask());\n&quot;, index);
2798         } else {
2799           const char* reg_class_to_upper = toUpper(reg_class);
2800           fprintf(fp, &quot;  case %d: return &amp;%s_mask();\n&quot;, index, reg_class_to_upper);
2801           delete[] reg_class_to_upper;
2802         }
2803       }
2804       fprintf(fp,&quot;  }\n&quot;);
2805       fprintf(fp,&quot;  ShouldNotReachHere();\n&quot;);
2806       fprintf(fp,&quot;  return NULL;\n&quot;);
2807     }
2808 
2809     // Method close
2810     fprintf(fp, &quot;}\n\n&quot;);
2811   }
2812 }
2813 
2814 // generate code to create a clone for a class derived from MachOper
2815 //
2816 // (0)  MachOper  *MachOperXOper::clone() const {
2817 // (1)    return new MachXOper( _ccode, _c0, _c1, ..., _cn);
2818 // (2)  }
2819 //
2820 static void defineClone(FILE *fp, FormDict &amp;globalNames, OperandForm &amp;oper) {
2821   fprintf(fp,&quot;MachOper *%sOper::clone() const {\n&quot;, oper._ident);
2822   // Check for constants that need to be copied over
2823   const int  num_consts    = oper.num_consts(globalNames);
2824   const bool is_ideal_bool = oper.is_ideal_bool();
2825   if( (num_consts &gt; 0) ) {
2826     fprintf(fp,&quot;  return new %sOper(&quot;, oper._ident);
2827     // generate parameters for constants
2828     int i = 0;
2829     fprintf(fp,&quot;_c%d&quot;, i);
2830     for( i = 1; i &lt; num_consts; ++i) {
2831       fprintf(fp,&quot;, _c%d&quot;, i);
2832     }
2833     // finish line (1)
2834     fprintf(fp,&quot;);\n&quot;);
2835   }
2836   else {
2837     assert( num_consts == 0, &quot;Currently support zero or one constant per operand clone function&quot;);
2838     fprintf(fp,&quot;  return new %sOper();\n&quot;, oper._ident);
2839   }
2840   // finish method
2841   fprintf(fp,&quot;}\n&quot;);
2842 }
2843 
2844 // Helper functions for bug 4796752, abstracted with minimal modification
2845 // from define_oper_interface()
2846 OperandForm *rep_var_to_operand(const char *encoding, OperandForm &amp;oper, FormDict &amp;globals) {
2847   OperandForm *op = NULL;
2848   // Check for replacement variable
2849   if( *encoding == &#39;$&#39; ) {
2850     // Replacement variable
2851     const char *rep_var = encoding + 1;
2852     // Lookup replacement variable, rep_var, in operand&#39;s component list
2853     const Component *comp = oper._components.search(rep_var);
2854     assert( comp != NULL, &quot;Replacement variable not found in components&quot;);
2855     // Lookup operand form for replacement variable&#39;s type
2856     const char      *type = comp-&gt;_type;
2857     Form            *form = (Form*)globals[type];
2858     assert( form != NULL, &quot;Replacement variable&#39;s type not found&quot;);
2859     op = form-&gt;is_operand();
2860     assert( op, &quot;Attempting to emit a non-register or non-constant&quot;);
2861   }
2862 
2863   return op;
2864 }
2865 
2866 int rep_var_to_constant_index(const char *encoding, OperandForm &amp;oper, FormDict &amp;globals) {
2867   int idx = -1;
2868   // Check for replacement variable
2869   if( *encoding == &#39;$&#39; ) {
2870     // Replacement variable
2871     const char *rep_var = encoding + 1;
2872     // Lookup replacement variable, rep_var, in operand&#39;s component list
2873     const Component *comp = oper._components.search(rep_var);
2874     assert( comp != NULL, &quot;Replacement variable not found in components&quot;);
2875     // Lookup operand form for replacement variable&#39;s type
2876     const char      *type = comp-&gt;_type;
2877     Form            *form = (Form*)globals[type];
2878     assert( form != NULL, &quot;Replacement variable&#39;s type not found&quot;);
2879     OperandForm *op = form-&gt;is_operand();
2880     assert( op, &quot;Attempting to emit a non-register or non-constant&quot;);
2881     // Check that this is a constant and find constant&#39;s index:
2882     if (op-&gt;_matrule &amp;&amp; op-&gt;_matrule-&gt;is_base_constant(globals)) {
2883       idx  = oper.constant_position(globals, comp);
2884     }
2885   }
2886 
2887   return idx;
2888 }
2889 
2890 bool is_regI(const char *encoding, OperandForm &amp;oper, FormDict &amp;globals ) {
2891   bool is_regI = false;
2892 
2893   OperandForm *op = rep_var_to_operand(encoding, oper, globals);
2894   if( op != NULL ) {
2895     // Check that this is a register
2896     if ( (op-&gt;_matrule &amp;&amp; op-&gt;_matrule-&gt;is_base_register(globals)) ) {
2897       // Register
2898       const char* ideal  = op-&gt;ideal_type(globals);
2899       is_regI = (ideal &amp;&amp; (op-&gt;ideal_to_Reg_type(ideal) == Form::idealI));
2900     }
2901   }
2902 
2903   return is_regI;
2904 }
2905 
2906 bool is_conP(const char *encoding, OperandForm &amp;oper, FormDict &amp;globals ) {
2907   bool is_conP = false;
2908 
2909   OperandForm *op = rep_var_to_operand(encoding, oper, globals);
2910   if( op != NULL ) {
2911     // Check that this is a constant pointer
2912     if (op-&gt;_matrule &amp;&amp; op-&gt;_matrule-&gt;is_base_constant(globals)) {
2913       // Constant
2914       Form::DataType dtype = op-&gt;is_base_constant(globals);
2915       is_conP = (dtype == Form::idealP);
2916     }
2917   }
2918 
2919   return is_conP;
2920 }
2921 
2922 
2923 // Define a MachOper interface methods
2924 void ArchDesc::define_oper_interface(FILE *fp, OperandForm &amp;oper, FormDict &amp;globals,
2925                                      const char *name, const char *encoding) {
2926   bool emit_position = false;
2927   int position = -1;
2928 
2929   fprintf(fp,&quot;  virtual int            %s&quot;, name);
2930   // Generate access method for base, index, scale, disp, ...
2931   if( (strcmp(name,&quot;base&quot;) == 0) || (strcmp(name,&quot;index&quot;) == 0) ) {
2932     fprintf(fp,&quot;(PhaseRegAlloc *ra_, const Node *node, int idx) const { \n&quot;);
2933     emit_position = true;
2934   } else if ( (strcmp(name,&quot;disp&quot;) == 0) ) {
2935     fprintf(fp,&quot;(PhaseRegAlloc *ra_, const Node *node, int idx) const { \n&quot;);
2936   } else {
2937     fprintf(fp, &quot;() const {\n&quot;);
2938   }
2939 
2940   // Check for hexadecimal value OR replacement variable
2941   if( *encoding == &#39;$&#39; ) {
2942     // Replacement variable
2943     const char *rep_var = encoding + 1;
2944     fprintf(fp,&quot;    // Replacement variable: %s\n&quot;, encoding+1);
2945     // Lookup replacement variable, rep_var, in operand&#39;s component list
2946     const Component *comp = oper._components.search(rep_var);
2947     assert( comp != NULL, &quot;Replacement variable not found in components&quot;);
2948     // Lookup operand form for replacement variable&#39;s type
2949     const char      *type = comp-&gt;_type;
2950     Form            *form = (Form*)globals[type];
2951     assert( form != NULL, &quot;Replacement variable&#39;s type not found&quot;);
2952     OperandForm *op = form-&gt;is_operand();
2953     assert( op, &quot;Attempting to emit a non-register or non-constant&quot;);
2954     // Check that this is a register or a constant and generate code:
2955     if ( (op-&gt;_matrule &amp;&amp; op-&gt;_matrule-&gt;is_base_register(globals)) ) {
2956       // Register
2957       int idx_offset = oper.register_position( globals, rep_var);
2958       position = idx_offset;
2959       fprintf(fp,&quot;    return (int)ra_-&gt;get_encode(node-&gt;in(idx&quot;);
2960       if ( idx_offset &gt; 0 ) fprintf(fp,                      &quot;+%d&quot;,idx_offset);
2961       fprintf(fp,&quot;));\n&quot;);
2962     } else if ( op-&gt;ideal_to_sReg_type(op-&gt;_ident) != Form::none ) {
2963       // StackSlot for an sReg comes either from input node or from self, when idx==0
2964       fprintf(fp,&quot;    if( idx != 0 ) {\n&quot;);
2965       fprintf(fp,&quot;      // Access stack offset (register number) for input operand\n&quot;);
2966       fprintf(fp,&quot;      return ra_-&gt;reg2offset(ra_-&gt;get_reg_first(node-&gt;in(idx)));/* sReg */\n&quot;);
2967       fprintf(fp,&quot;    }\n&quot;);
2968       fprintf(fp,&quot;    // Access stack offset (register number) from myself\n&quot;);
2969       fprintf(fp,&quot;    return ra_-&gt;reg2offset(ra_-&gt;get_reg_first(node));/* sReg */\n&quot;);
2970     } else if (op-&gt;_matrule &amp;&amp; op-&gt;_matrule-&gt;is_base_constant(globals)) {
2971       // Constant
2972       // Check which constant this name maps to: _c0, _c1, ..., _cn
2973       const int idx = oper.constant_position(globals, comp);
2974       assert( idx != -1, &quot;Constant component not found in operand&quot;);
2975       // Output code for this constant, type dependent.
2976       fprintf(fp,&quot;    return (int)&quot; );
2977       oper.access_constant(fp, globals, (uint)idx /* , const_type */);
2978       fprintf(fp,&quot;;\n&quot;);
2979     } else {
2980       assert( false, &quot;Attempting to emit a non-register or non-constant&quot;);
2981     }
2982   }
2983   else if( *encoding == &#39;0&#39; &amp;&amp; *(encoding+1) == &#39;x&#39; ) {
2984     // Hex value
2985     fprintf(fp,&quot;    return %s;\n&quot;, encoding);
2986   } else {
2987     globalAD-&gt;syntax_err(oper._linenum, &quot;In operand %s: Do not support this encode constant: &#39;%s&#39; for %s.&quot;,
2988                          oper._ident, encoding, name);
2989     assert( false, &quot;Do not support octal or decimal encode constants&quot;);
2990   }
2991   fprintf(fp,&quot;  }\n&quot;);
2992 
2993   if( emit_position &amp;&amp; (position != -1) &amp;&amp; (oper.num_edges(globals) &gt; 0) ) {
2994     fprintf(fp,&quot;  virtual int            %s_position() const { return %d; }\n&quot;, name, position);
2995     MemInterface *mem_interface = oper._interface-&gt;is_MemInterface();
2996     const char *base = mem_interface-&gt;_base;
2997     const char *disp = mem_interface-&gt;_disp;
2998     if( emit_position &amp;&amp; (strcmp(name,&quot;base&quot;) == 0)
2999         &amp;&amp; base != NULL &amp;&amp; is_regI(base, oper, globals)
3000         &amp;&amp; disp != NULL &amp;&amp; is_conP(disp, oper, globals) ) {
3001       // Found a memory access using a constant pointer for a displacement
3002       // and a base register containing an integer offset.
3003       // In this case the base and disp are reversed with respect to what
3004       // is expected by MachNode::get_base_and_disp() and MachNode::adr_type().
3005       // Provide a non-NULL return for disp_as_type() that will allow adr_type()
3006       // to correctly compute the access type for alias analysis.
3007       //
3008       // See BugId 4796752, operand indOffset32X in i486.ad
3009       int idx = rep_var_to_constant_index(disp, oper, globals);
3010       fprintf(fp,&quot;  virtual const TypePtr *disp_as_type() const { return _c%d; }\n&quot;, idx);
3011     }
3012   }
3013 }
3014 
3015 //
3016 // Construct the method to copy _idx, inputs and operands to new node.
3017 static void define_fill_new_machnode(bool used, FILE *fp_cpp) {
3018   fprintf(fp_cpp, &quot;\n&quot;);
3019   fprintf(fp_cpp, &quot;// Copy _idx, inputs and operands to new node\n&quot;);
3020   fprintf(fp_cpp, &quot;void MachNode::fill_new_machnode(MachNode* node) const {\n&quot;);
3021   if( !used ) {
3022     fprintf(fp_cpp, &quot;  // This architecture does not have cisc or short branch instructions\n&quot;);
3023     fprintf(fp_cpp, &quot;  ShouldNotCallThis();\n&quot;);
3024     fprintf(fp_cpp, &quot;}\n&quot;);
3025   } else {
3026     // New node must use same node index for access through allocator&#39;s tables
3027     fprintf(fp_cpp, &quot;  // New node must use same node index\n&quot;);
3028     fprintf(fp_cpp, &quot;  node-&gt;set_idx( _idx );\n&quot;);
3029     // Copy machine-independent inputs
3030     fprintf(fp_cpp, &quot;  // Copy machine-independent inputs\n&quot;);
3031     fprintf(fp_cpp, &quot;  for( uint j = 0; j &lt; req(); j++ ) {\n&quot;);
3032     fprintf(fp_cpp, &quot;    node-&gt;add_req(in(j));\n&quot;);
3033     fprintf(fp_cpp, &quot;  }\n&quot;);
3034     // Copy machine operands to new MachNode
3035     fprintf(fp_cpp, &quot;  // Copy my operands, except for cisc position\n&quot;);
3036     fprintf(fp_cpp, &quot;  int nopnds = num_opnds();\n&quot;);
3037     fprintf(fp_cpp, &quot;  assert( node-&gt;num_opnds() == (uint)nopnds, \&quot;Must have same number of operands\&quot;);\n&quot;);
3038     fprintf(fp_cpp, &quot;  MachOper **to = node-&gt;_opnds;\n&quot;);
3039     fprintf(fp_cpp, &quot;  for( int i = 0; i &lt; nopnds; i++ ) {\n&quot;);
3040     fprintf(fp_cpp, &quot;    if( i != cisc_operand() ) \n&quot;);
3041     fprintf(fp_cpp, &quot;      to[i] = _opnds[i]-&gt;clone();\n&quot;);
3042     fprintf(fp_cpp, &quot;  }\n&quot;);
3043     fprintf(fp_cpp, &quot;}\n&quot;);
3044   }
3045   fprintf(fp_cpp, &quot;\n&quot;);
3046 }
3047 
3048 //------------------------------defineClasses----------------------------------
3049 // Define members of MachNode and MachOper classes based on
3050 // operand and instruction lists
3051 void ArchDesc::defineClasses(FILE *fp) {
3052 
3053   // Define the contents of an array containing the machine register names
3054   defineRegNames(fp, _register);
3055   // Define an array containing the machine register encoding values
3056   defineRegEncodes(fp, _register);
3057   // Generate an enumeration of user-defined register classes
3058   // and a list of register masks, one for each class.
3059   // Only define the RegMask value objects in the expand file.
3060   // Declare each as an extern const RegMask ...; in ad_&lt;arch&gt;.hpp
3061   declare_register_masks(_HPP_file._fp);
3062   // build_register_masks(fp);
3063   build_register_masks(_CPP_EXPAND_file._fp);
3064   // Define the pipe_classes
3065   build_pipe_classes(_CPP_PIPELINE_file._fp);
3066 
3067   // Generate Machine Classes for each operand defined in AD file
3068   fprintf(fp,&quot;\n&quot;);
3069   fprintf(fp,&quot;\n&quot;);
3070   fprintf(fp,&quot;//------------------Define classes derived from MachOper---------------------\n&quot;);
3071   // Iterate through all operands
3072   _operands.reset();
3073   OperandForm *oper;
3074   for( ; (oper = (OperandForm*)_operands.iter()) != NULL; ) {
3075     // Ensure this is a machine-world instruction
3076     if ( oper-&gt;ideal_only() ) continue;
3077     // !!!!!
3078     // The declaration of labelOper is in machine-independent file: machnode
3079     if ( strcmp(oper-&gt;_ident,&quot;label&quot;) == 0 ) {
3080       defineIn_RegMask(_CPP_MISC_file._fp, _globalNames, *oper);
3081 
3082       fprintf(fp,&quot;MachOper  *%sOper::clone() const {\n&quot;, oper-&gt;_ident);
3083       fprintf(fp,&quot;  return  new %sOper(_label, _block_num);\n&quot;, oper-&gt;_ident);
3084       fprintf(fp,&quot;}\n&quot;);
3085 
3086       fprintf(fp,&quot;uint %sOper::opcode() const { return %s; }\n&quot;,
3087               oper-&gt;_ident, machOperEnum(oper-&gt;_ident));
3088       // // Currently all XXXOper::Hash() methods are identical (990820)
3089       // define_hash(fp, oper-&gt;_ident);
3090       // // Currently all XXXOper::Cmp() methods are identical (990820)
3091       // define_cmp(fp, oper-&gt;_ident);
3092       fprintf(fp,&quot;\n&quot;);
3093 
3094       continue;
3095     }
3096 
3097     // The declaration of methodOper is in machine-independent file: machnode
3098     if ( strcmp(oper-&gt;_ident,&quot;method&quot;) == 0 ) {
3099       defineIn_RegMask(_CPP_MISC_file._fp, _globalNames, *oper);
3100 
3101       fprintf(fp,&quot;MachOper  *%sOper::clone() const {\n&quot;, oper-&gt;_ident);
3102       fprintf(fp,&quot;  return  new %sOper(_method);\n&quot;, oper-&gt;_ident);
3103       fprintf(fp,&quot;}\n&quot;);
3104 
3105       fprintf(fp,&quot;uint %sOper::opcode() const { return %s; }\n&quot;,
3106               oper-&gt;_ident, machOperEnum(oper-&gt;_ident));
3107       // // Currently all XXXOper::Hash() methods are identical (990820)
3108       // define_hash(fp, oper-&gt;_ident);
3109       // // Currently all XXXOper::Cmp() methods are identical (990820)
3110       // define_cmp(fp, oper-&gt;_ident);
3111       fprintf(fp,&quot;\n&quot;);
3112 
3113       continue;
3114     }
3115 
3116     defineIn_RegMask(fp, _globalNames, *oper);
3117     defineClone(_CPP_CLONE_file._fp, _globalNames, *oper);
3118     // // Currently all XXXOper::Hash() methods are identical (990820)
3119     // define_hash(fp, oper-&gt;_ident);
3120     // // Currently all XXXOper::Cmp() methods are identical (990820)
3121     // define_cmp(fp, oper-&gt;_ident);
3122 
3123     // side-call to generate output that used to be in the header file:
3124     extern void gen_oper_format(FILE *fp, FormDict &amp;globals, OperandForm &amp;oper, bool for_c_file);
3125     gen_oper_format(_CPP_FORMAT_file._fp, _globalNames, *oper, true);
3126 
3127   }
3128 
3129 
3130   // Generate Machine Classes for each instruction defined in AD file
3131   fprintf(fp,&quot;//------------------Define members for classes derived from MachNode----------\n&quot;);
3132   // Output the definitions for out_RegMask() // &amp; kill_RegMask()
3133   _instructions.reset();
3134   InstructForm *instr;
3135   MachNodeForm *machnode;
3136   for( ; (instr = (InstructForm*)_instructions.iter()) != NULL; ) {
3137     // Ensure this is a machine-world instruction
3138     if ( instr-&gt;ideal_only() ) continue;
3139 
3140     defineOut_RegMask(_CPP_MISC_file._fp, instr-&gt;_ident, reg_mask(*instr));
3141   }
3142 
3143   bool used = false;
3144   // Output the definitions for expand rules &amp; peephole rules
3145   _instructions.reset();
3146   for( ; (instr = (InstructForm*)_instructions.iter()) != NULL; ) {
3147     // Ensure this is a machine-world instruction
3148     if ( instr-&gt;ideal_only() ) continue;
3149     // If there are multiple defs/kills, or an explicit expand rule, build rule
3150     if( instr-&gt;expands() || instr-&gt;needs_projections() ||
3151         instr-&gt;has_temps() ||
3152         instr-&gt;is_mach_constant() ||
3153         instr-&gt;needs_constant_base() ||
3154         (instr-&gt;_matrule != NULL &amp;&amp;
3155          instr-&gt;num_opnds() != instr-&gt;num_unique_opnds()) )
3156       defineExpand(_CPP_EXPAND_file._fp, instr);
3157     // If there is an explicit peephole rule, build it
3158     if ( instr-&gt;peepholes() )
3159       definePeephole(_CPP_PEEPHOLE_file._fp, instr);
3160 
3161     // Output code to convert to the cisc version, if applicable
3162     used |= instr-&gt;define_cisc_version(*this, fp);
3163 
3164     // Output code to convert to the short branch version, if applicable
3165     used |= instr-&gt;define_short_branch_methods(*this, fp);
3166   }
3167 
3168   // Construct the method called by cisc_version() to copy inputs and operands.
3169   define_fill_new_machnode(used, fp);
3170 
3171   // Output the definitions for labels
3172   _instructions.reset();
3173   while( (instr = (InstructForm*)_instructions.iter()) != NULL ) {
3174     // Ensure this is a machine-world instruction
3175     if ( instr-&gt;ideal_only() ) continue;
3176 
3177     // Access the fields for operand Label
3178     int label_position = instr-&gt;label_position();
3179     if( label_position != -1 ) {
3180       // Set the label
3181       fprintf(fp,&quot;void %sNode::label_set( Label* label, uint block_num ) {\n&quot;, instr-&gt;_ident);
3182       fprintf(fp,&quot;  labelOper* oper  = (labelOper*)(opnd_array(%d));\n&quot;,
3183               label_position );
3184       fprintf(fp,&quot;  oper-&gt;_label     = label;\n&quot;);
3185       fprintf(fp,&quot;  oper-&gt;_block_num = block_num;\n&quot;);
3186       fprintf(fp,&quot;}\n&quot;);
3187       // Save the label
3188       fprintf(fp,&quot;void %sNode::save_label( Label** label, uint* block_num ) {\n&quot;, instr-&gt;_ident);
3189       fprintf(fp,&quot;  labelOper* oper  = (labelOper*)(opnd_array(%d));\n&quot;,
3190               label_position );
3191       fprintf(fp,&quot;  *label = oper-&gt;_label;\n&quot;);
3192       fprintf(fp,&quot;  *block_num = oper-&gt;_block_num;\n&quot;);
3193       fprintf(fp,&quot;}\n&quot;);
3194     }
3195   }
3196 
3197   // Output the definitions for methods
3198   _instructions.reset();
3199   while( (instr = (InstructForm*)_instructions.iter()) != NULL ) {
3200     // Ensure this is a machine-world instruction
3201     if ( instr-&gt;ideal_only() ) continue;
3202 
3203     // Access the fields for operand Label
3204     int method_position = instr-&gt;method_position();
3205     if( method_position != -1 ) {
3206       // Access the method&#39;s address
3207       fprintf(fp,&quot;void %sNode::method_set( intptr_t method ) {\n&quot;, instr-&gt;_ident);
3208       fprintf(fp,&quot;  ((methodOper*)opnd_array(%d))-&gt;_method = method;\n&quot;,
3209               method_position );
3210       fprintf(fp,&quot;}\n&quot;);
3211       fprintf(fp,&quot;\n&quot;);
3212     }
3213   }
3214 
3215   // Define this instruction&#39;s number of relocation entries, base is &#39;0&#39;
3216   _instructions.reset();
3217   while( (instr = (InstructForm*)_instructions.iter()) != NULL ) {
3218     // Output the definition for number of relocation entries
3219     uint reloc_size = instr-&gt;reloc(_globalNames);
3220     if ( reloc_size != 0 ) {
3221       fprintf(fp,&quot;int %sNode::reloc() const {\n&quot;, instr-&gt;_ident);
3222       fprintf(fp,&quot;  return %d;\n&quot;, reloc_size);
3223       fprintf(fp,&quot;}\n&quot;);
3224       fprintf(fp,&quot;\n&quot;);
3225     }
3226   }
3227   fprintf(fp,&quot;\n&quot;);
3228 
3229   // Output the definitions for code generation
3230   //
3231   // address  ___Node::emit(address ptr, PhaseRegAlloc *ra_) const {
3232   //   // ...  encoding defined by user
3233   //   return ptr;
3234   // }
3235   //
3236   _instructions.reset();
3237   for( ; (instr = (InstructForm*)_instructions.iter()) != NULL; ) {
3238     // Ensure this is a machine-world instruction
3239     if ( instr-&gt;ideal_only() ) continue;
3240 
3241     if (instr-&gt;_insencode) {
3242       if (instr-&gt;postalloc_expands()) {
3243         // Don&#39;t write this to _CPP_EXPAND_file, as the code generated calls C-code
3244         // from code sections in ad file that is dumped to fp.
3245         define_postalloc_expand(fp, *instr);
3246       } else {
3247         defineEmit(fp, *instr);
3248       }
3249     }
3250     if (instr-&gt;is_mach_constant()) defineEvalConstant(fp, *instr);
3251     if (instr-&gt;_size)              defineSize        (fp, *instr);
3252 
3253     // side-call to generate output that used to be in the header file:
3254     extern void gen_inst_format(FILE *fp, FormDict &amp;globals, InstructForm &amp;oper, bool for_c_file);
3255     gen_inst_format(_CPP_FORMAT_file._fp, _globalNames, *instr, true);
3256   }
3257 
3258   // Output the definitions for alias analysis
3259   _instructions.reset();
3260   for( ; (instr = (InstructForm*)_instructions.iter()) != NULL; ) {
3261     // Ensure this is a machine-world instruction
3262     if ( instr-&gt;ideal_only() ) continue;
3263 
3264     // Analyze machine instructions that either USE or DEF memory.
3265     int memory_operand = instr-&gt;memory_operand(_globalNames);
3266 
3267     if ( memory_operand != InstructForm::NO_MEMORY_OPERAND ) {
3268       if( memory_operand == InstructForm::MANY_MEMORY_OPERANDS ) {
3269         fprintf(fp,&quot;const TypePtr *%sNode::adr_type() const { return TypePtr::BOTTOM; }\n&quot;, instr-&gt;_ident);
3270         fprintf(fp,&quot;const MachOper* %sNode::memory_operand() const { return (MachOper*)-1; }\n&quot;, instr-&gt;_ident);
3271       } else {
3272         fprintf(fp,&quot;const MachOper* %sNode::memory_operand() const { return _opnds[%d]; }\n&quot;, instr-&gt;_ident, memory_operand);
3273   }
3274     }
3275   }
3276 
3277   // Get the length of the longest identifier
3278   int max_ident_len = 0;
3279   _instructions.reset();
3280 
3281   for ( ; (instr = (InstructForm*)_instructions.iter()) != NULL; ) {
3282     if (instr-&gt;_ins_pipe &amp;&amp; _pipeline-&gt;_classlist.search(instr-&gt;_ins_pipe)) {
3283       int ident_len = (int)strlen(instr-&gt;_ident);
3284       if( max_ident_len &lt; ident_len )
3285         max_ident_len = ident_len;
3286     }
3287   }
3288 
3289   // Emit specifically for Node(s)
3290   fprintf(_CPP_PIPELINE_file._fp, &quot;const Pipeline * %*s::pipeline_class() { return %s; }\n&quot;,
3291     max_ident_len, &quot;Node&quot;, _pipeline ? &quot;(&amp;pipeline_class_Zero_Instructions)&quot; : &quot;NULL&quot;);
3292   fprintf(_CPP_PIPELINE_file._fp, &quot;const Pipeline * %*s::pipeline() const { return %s; }\n&quot;,
3293     max_ident_len, &quot;Node&quot;, _pipeline ? &quot;(&amp;pipeline_class_Zero_Instructions)&quot; : &quot;NULL&quot;);
3294   fprintf(_CPP_PIPELINE_file._fp, &quot;\n&quot;);
3295 
3296   fprintf(_CPP_PIPELINE_file._fp, &quot;const Pipeline * %*s::pipeline_class() { return %s; }\n&quot;,
3297     max_ident_len, &quot;MachNode&quot;, _pipeline ? &quot;(&amp;pipeline_class_Unknown_Instructions)&quot; : &quot;NULL&quot;);
3298   fprintf(_CPP_PIPELINE_file._fp, &quot;const Pipeline * %*s::pipeline() const { return pipeline_class(); }\n&quot;,
3299     max_ident_len, &quot;MachNode&quot;);
3300   fprintf(_CPP_PIPELINE_file._fp, &quot;\n&quot;);
3301 
3302   // Output the definitions for machine node specific pipeline data
3303   _machnodes.reset();
3304 
3305   if (_pipeline != NULL) {
3306     for ( ; (machnode = (MachNodeForm*)_machnodes.iter()) != NULL; ) {
3307       fprintf(_CPP_PIPELINE_file._fp, &quot;const Pipeline * %sNode::pipeline() const { return (&amp;pipeline_class_%03d); }\n&quot;,
3308               machnode-&gt;_ident, ((class PipeClassForm *)_pipeline-&gt;_classdict[machnode-&gt;_machnode_pipe])-&gt;_num);
3309     }
3310   }
3311 
3312   fprintf(_CPP_PIPELINE_file._fp, &quot;\n&quot;);
3313 
3314   // Output the definitions for instruction pipeline static data references
3315   _instructions.reset();
3316 
3317   if (_pipeline != NULL) {
3318     for ( ; (instr = (InstructForm*)_instructions.iter()) != NULL; ) {
3319       if (instr-&gt;_ins_pipe &amp;&amp; _pipeline-&gt;_classlist.search(instr-&gt;_ins_pipe)) {
3320         fprintf(_CPP_PIPELINE_file._fp, &quot;\n&quot;);
3321         fprintf(_CPP_PIPELINE_file._fp, &quot;const Pipeline * %*sNode::pipeline_class() { return (&amp;pipeline_class_%03d); }\n&quot;,
3322                 max_ident_len, instr-&gt;_ident, ((class PipeClassForm *)_pipeline-&gt;_classdict[instr-&gt;_ins_pipe])-&gt;_num);
3323         fprintf(_CPP_PIPELINE_file._fp, &quot;const Pipeline * %*sNode::pipeline() const { return (&amp;pipeline_class_%03d); }\n&quot;,
3324                 max_ident_len, instr-&gt;_ident, ((class PipeClassForm *)_pipeline-&gt;_classdict[instr-&gt;_ins_pipe])-&gt;_num);
3325       }
3326     }
3327   }
3328 }
3329 
3330 
3331 // -------------------------------- maps ------------------------------------
3332 
3333 // Information needed to generate the ReduceOp mapping for the DFA
3334 class OutputReduceOp : public OutputMap {
3335 public:
3336   OutputReduceOp(FILE *hpp, FILE *cpp, FormDict &amp;globals, ArchDesc &amp;AD)
3337     : OutputMap(hpp, cpp, globals, AD, &quot;reduceOp&quot;) {};
3338 
3339   void declaration() { fprintf(_hpp, &quot;extern const int   reduceOp[];\n&quot;); }
3340   void definition()  { fprintf(_cpp, &quot;const        int   reduceOp[] = {\n&quot;); }
3341   void closing()     { fprintf(_cpp, &quot;  0 // no trailing comma\n&quot;);
3342                        OutputMap::closing();
3343   }
3344   void map(OpClassForm &amp;opc)  {
3345     const char *reduce = opc._ident;
3346     if( reduce )  fprintf(_cpp, &quot;  %s_rule&quot;, reduce);
3347     else          fprintf(_cpp, &quot;  0&quot;);
3348   }
3349   void map(OperandForm &amp;oper) {
3350     // Most operands without match rules, e.g.  eFlagsReg, do not have a result operand
3351     const char *reduce = (oper._matrule ? oper.reduce_result() : NULL);
3352     // operand stackSlot does not have a match rule, but produces a stackSlot
3353     if( oper.is_user_name_for_sReg() != Form::none ) reduce = oper.reduce_result();
3354     if( reduce )  fprintf(_cpp, &quot;  %s_rule&quot;, reduce);
3355     else          fprintf(_cpp, &quot;  0&quot;);
3356   }
3357   void map(InstructForm &amp;inst) {
3358     const char *reduce = (inst._matrule ? inst.reduce_result() : NULL);
3359     if( reduce )  fprintf(_cpp, &quot;  %s_rule&quot;, reduce);
3360     else          fprintf(_cpp, &quot;  0&quot;);
3361   }
3362   void map(char         *reduce) {
3363     if( reduce )  fprintf(_cpp, &quot;  %s_rule&quot;, reduce);
3364     else          fprintf(_cpp, &quot;  0&quot;);
3365   }
3366 };
3367 
3368 // Information needed to generate the LeftOp mapping for the DFA
3369 class OutputLeftOp : public OutputMap {
3370 public:
3371   OutputLeftOp(FILE *hpp, FILE *cpp, FormDict &amp;globals, ArchDesc &amp;AD)
3372     : OutputMap(hpp, cpp, globals, AD, &quot;leftOp&quot;) {};
3373 
3374   void declaration() { fprintf(_hpp, &quot;extern const int   leftOp[];\n&quot;); }
3375   void definition()  { fprintf(_cpp, &quot;const        int   leftOp[] = {\n&quot;); }
3376   void closing()     { fprintf(_cpp, &quot;  0 // no trailing comma\n&quot;);
3377                        OutputMap::closing();
3378   }
3379   void map(OpClassForm &amp;opc)  { fprintf(_cpp, &quot;  0&quot;); }
3380   void map(OperandForm &amp;oper) {
3381     const char *reduce = oper.reduce_left(_globals);
3382     if( reduce )  fprintf(_cpp, &quot;  %s_rule&quot;, reduce);
3383     else          fprintf(_cpp, &quot;  0&quot;);
3384   }
3385   void map(char        *name) {
3386     const char *reduce = _AD.reduceLeft(name);
3387     if( reduce )  fprintf(_cpp, &quot;  %s_rule&quot;, reduce);
3388     else          fprintf(_cpp, &quot;  0&quot;);
3389   }
3390   void map(InstructForm &amp;inst) {
3391     const char *reduce = inst.reduce_left(_globals);
3392     if( reduce )  fprintf(_cpp, &quot;  %s_rule&quot;, reduce);
3393     else          fprintf(_cpp, &quot;  0&quot;);
3394   }
3395 };
3396 
3397 
3398 // Information needed to generate the RightOp mapping for the DFA
3399 class OutputRightOp : public OutputMap {
3400 public:
3401   OutputRightOp(FILE *hpp, FILE *cpp, FormDict &amp;globals, ArchDesc &amp;AD)
3402     : OutputMap(hpp, cpp, globals, AD, &quot;rightOp&quot;) {};
3403 
3404   void declaration() { fprintf(_hpp, &quot;extern const int   rightOp[];\n&quot;); }
3405   void definition()  { fprintf(_cpp, &quot;const        int   rightOp[] = {\n&quot;); }
3406   void closing()     { fprintf(_cpp, &quot;  0 // no trailing comma\n&quot;);
3407                        OutputMap::closing();
3408   }
3409   void map(OpClassForm &amp;opc)  { fprintf(_cpp, &quot;  0&quot;); }
3410   void map(OperandForm &amp;oper) {
3411     const char *reduce = oper.reduce_right(_globals);
3412     if( reduce )  fprintf(_cpp, &quot;  %s_rule&quot;, reduce);
3413     else          fprintf(_cpp, &quot;  0&quot;);
3414   }
3415   void map(char        *name) {
3416     const char *reduce = _AD.reduceRight(name);
3417     if( reduce )  fprintf(_cpp, &quot;  %s_rule&quot;, reduce);
3418     else          fprintf(_cpp, &quot;  0&quot;);
3419   }
3420   void map(InstructForm &amp;inst) {
3421     const char *reduce = inst.reduce_right(_globals);
3422     if( reduce )  fprintf(_cpp, &quot;  %s_rule&quot;, reduce);
3423     else          fprintf(_cpp, &quot;  0&quot;);
3424   }
3425 };
3426 
3427 
3428 // Information needed to generate the Rule names for the DFA
3429 class OutputRuleName : public OutputMap {
3430 public:
3431   OutputRuleName(FILE *hpp, FILE *cpp, FormDict &amp;globals, ArchDesc &amp;AD)
3432     : OutputMap(hpp, cpp, globals, AD, &quot;ruleName&quot;) {};
3433 
3434   void declaration() { fprintf(_hpp, &quot;extern const char *ruleName[];\n&quot;); }
3435   void definition()  { fprintf(_cpp, &quot;const char        *ruleName[] = {\n&quot;); }
3436   void closing()     { fprintf(_cpp, &quot;  \&quot;invalid rule name\&quot; // no trailing comma\n&quot;);
3437                        OutputMap::closing();
3438   }
3439   void map(OpClassForm &amp;opc)  { fprintf(_cpp, &quot;  \&quot;%s\&quot;&quot;, _AD.machOperEnum(opc._ident) ); }
3440   void map(OperandForm &amp;oper) { fprintf(_cpp, &quot;  \&quot;%s\&quot;&quot;, _AD.machOperEnum(oper._ident) ); }
3441   void map(char        *name) { fprintf(_cpp, &quot;  \&quot;%s\&quot;&quot;, name ? name : &quot;0&quot;); }
3442   void map(InstructForm &amp;inst){ fprintf(_cpp, &quot;  \&quot;%s\&quot;&quot;, inst._ident ? inst._ident : &quot;0&quot;); }
3443 };
3444 
3445 
3446 // Information needed to generate the swallowed mapping for the DFA
3447 class OutputSwallowed : public OutputMap {
3448 public:
3449   OutputSwallowed(FILE *hpp, FILE *cpp, FormDict &amp;globals, ArchDesc &amp;AD)
3450     : OutputMap(hpp, cpp, globals, AD, &quot;swallowed&quot;) {};
3451 
3452   void declaration() { fprintf(_hpp, &quot;extern const bool  swallowed[];\n&quot;); }
3453   void definition()  { fprintf(_cpp, &quot;const        bool  swallowed[] = {\n&quot;); }
3454   void closing()     { fprintf(_cpp, &quot;  false // no trailing comma\n&quot;);
3455                        OutputMap::closing();
3456   }
3457   void map(OperandForm &amp;oper) { // Generate the entry for this opcode
3458     const char *swallowed = oper.swallowed(_globals) ? &quot;true&quot; : &quot;false&quot;;
3459     fprintf(_cpp, &quot;  %s&quot;, swallowed);
3460   }
3461   void map(OpClassForm &amp;opc)  { fprintf(_cpp, &quot;  false&quot;); }
3462   void map(char        *name) { fprintf(_cpp, &quot;  false&quot;); }
3463   void map(InstructForm &amp;inst){ fprintf(_cpp, &quot;  false&quot;); }
3464 };
3465 
3466 
3467 // Information needed to generate the decision array for instruction chain rule
3468 class OutputInstChainRule : public OutputMap {
3469 public:
3470   OutputInstChainRule(FILE *hpp, FILE *cpp, FormDict &amp;globals, ArchDesc &amp;AD)
3471     : OutputMap(hpp, cpp, globals, AD, &quot;instruction_chain_rule&quot;) {};
3472 
3473   void declaration() { fprintf(_hpp, &quot;extern const bool  instruction_chain_rule[];\n&quot;); }
3474   void definition()  { fprintf(_cpp, &quot;const        bool  instruction_chain_rule[] = {\n&quot;); }
3475   void closing()     { fprintf(_cpp, &quot;  false // no trailing comma\n&quot;);
3476                        OutputMap::closing();
3477   }
3478   void map(OpClassForm &amp;opc)   { fprintf(_cpp, &quot;  false&quot;); }
3479   void map(OperandForm &amp;oper)  { fprintf(_cpp, &quot;  false&quot;); }
3480   void map(char        *name)  { fprintf(_cpp, &quot;  false&quot;); }
3481   void map(InstructForm &amp;inst) { // Check for simple chain rule
3482     const char *chain = inst.is_simple_chain_rule(_globals) ? &quot;true&quot; : &quot;false&quot;;
3483     fprintf(_cpp, &quot;  %s&quot;, chain);
3484   }
3485 };
3486 
3487 
3488 //---------------------------build_map------------------------------------
3489 // Build  mapping from enumeration for densely packed operands
3490 // TO result and child types.
3491 void ArchDesc::build_map(OutputMap &amp;map) {
3492   FILE         *fp_hpp = map.decl_file();
3493   FILE         *fp_cpp = map.def_file();
3494   int           idx    = 0;
3495   OperandForm  *op;
3496   OpClassForm  *opc;
3497   InstructForm *inst;
3498 
3499   // Construct this mapping
3500   map.declaration();
3501   fprintf(fp_cpp,&quot;\n&quot;);
3502   map.definition();
3503 
3504   // Output the mapping for operands
3505   map.record_position(OutputMap::BEGIN_OPERANDS, idx );
3506   _operands.reset();
3507   for(; (op = (OperandForm*)_operands.iter()) != NULL; ) {
3508     // Ensure this is a machine-world instruction
3509     if ( op-&gt;ideal_only() )  continue;
3510 
3511     // Generate the entry for this opcode
3512     fprintf(fp_cpp, &quot;  /* %4d */&quot;, idx); map.map(*op); fprintf(fp_cpp, &quot;,\n&quot;);
3513     ++idx;
3514   };
3515   fprintf(fp_cpp, &quot;  // last operand\n&quot;);
3516 
3517   // Place all user-defined operand classes into the mapping
3518   map.record_position(OutputMap::BEGIN_OPCLASSES, idx );
3519   _opclass.reset();
3520   for(; (opc = (OpClassForm*)_opclass.iter()) != NULL; ) {
3521     fprintf(fp_cpp, &quot;  /* %4d */&quot;, idx); map.map(*opc); fprintf(fp_cpp, &quot;,\n&quot;);
3522     ++idx;
3523   };
3524   fprintf(fp_cpp, &quot;  // last operand class\n&quot;);
3525 
3526   // Place all internally defined operands into the mapping
3527   map.record_position(OutputMap::BEGIN_INTERNALS, idx );
3528   _internalOpNames.reset();
3529   char *name = NULL;
3530   for(; (name = (char *)_internalOpNames.iter()) != NULL; ) {
3531     fprintf(fp_cpp, &quot;  /* %4d */&quot;, idx); map.map(name); fprintf(fp_cpp, &quot;,\n&quot;);
3532     ++idx;
3533   };
3534   fprintf(fp_cpp, &quot;  // last internally defined operand\n&quot;);
3535 
3536   // Place all user-defined instructions into the mapping
3537   if( map.do_instructions() ) {
3538     map.record_position(OutputMap::BEGIN_INSTRUCTIONS, idx );
3539     // Output all simple instruction chain rules first
3540     map.record_position(OutputMap::BEGIN_INST_CHAIN_RULES, idx );
3541     {
3542       _instructions.reset();
3543       for(; (inst = (InstructForm*)_instructions.iter()) != NULL; ) {
3544         // Ensure this is a machine-world instruction
3545         if ( inst-&gt;ideal_only() )  continue;
3546         if ( ! inst-&gt;is_simple_chain_rule(_globalNames) ) continue;
3547         if ( inst-&gt;rematerialize(_globalNames, get_registers()) ) continue;
3548 
3549         fprintf(fp_cpp, &quot;  /* %4d */&quot;, idx); map.map(*inst); fprintf(fp_cpp, &quot;,\n&quot;);
3550         ++idx;
3551       };
3552       map.record_position(OutputMap::BEGIN_REMATERIALIZE, idx );
3553       _instructions.reset();
3554       for(; (inst = (InstructForm*)_instructions.iter()) != NULL; ) {
3555         // Ensure this is a machine-world instruction
3556         if ( inst-&gt;ideal_only() )  continue;
3557         if ( ! inst-&gt;is_simple_chain_rule(_globalNames) ) continue;
3558         if ( ! inst-&gt;rematerialize(_globalNames, get_registers()) ) continue;
3559 
3560         fprintf(fp_cpp, &quot;  /* %4d */&quot;, idx); map.map(*inst); fprintf(fp_cpp, &quot;,\n&quot;);
3561         ++idx;
3562       };
3563       map.record_position(OutputMap::END_INST_CHAIN_RULES, idx );
3564     }
3565     // Output all instructions that are NOT simple chain rules
3566     {
3567       _instructions.reset();
3568       for(; (inst = (InstructForm*)_instructions.iter()) != NULL; ) {
3569         // Ensure this is a machine-world instruction
3570         if ( inst-&gt;ideal_only() )  continue;
3571         if ( inst-&gt;is_simple_chain_rule(_globalNames) ) continue;
3572         if ( ! inst-&gt;rematerialize(_globalNames, get_registers()) ) continue;
3573 
3574         fprintf(fp_cpp, &quot;  /* %4d */&quot;, idx); map.map(*inst); fprintf(fp_cpp, &quot;,\n&quot;);
3575         ++idx;
3576       };
3577       map.record_position(OutputMap::END_REMATERIALIZE, idx );
3578       _instructions.reset();
3579       for(; (inst = (InstructForm*)_instructions.iter()) != NULL; ) {
3580         // Ensure this is a machine-world instruction
3581         if ( inst-&gt;ideal_only() )  continue;
3582         if ( inst-&gt;is_simple_chain_rule(_globalNames) ) continue;
3583         if ( inst-&gt;rematerialize(_globalNames, get_registers()) ) continue;
3584 
3585         fprintf(fp_cpp, &quot;  /* %4d */&quot;, idx); map.map(*inst); fprintf(fp_cpp, &quot;,\n&quot;);
3586         ++idx;
3587       };
3588     }
3589     fprintf(fp_cpp, &quot;  // last instruction\n&quot;);
3590     map.record_position(OutputMap::END_INSTRUCTIONS, idx );
3591   }
3592   // Finish defining table
3593   map.closing();
3594 };
3595 
3596 
3597 // Helper function for buildReduceMaps
3598 char reg_save_policy(const char *calling_convention) {
3599   char callconv;
3600 
3601   if      (!strcmp(calling_convention, &quot;NS&quot;))  callconv = &#39;N&#39;;
3602   else if (!strcmp(calling_convention, &quot;SOE&quot;)) callconv = &#39;E&#39;;
3603   else if (!strcmp(calling_convention, &quot;SOC&quot;)) callconv = &#39;C&#39;;
3604   else if (!strcmp(calling_convention, &quot;AS&quot;))  callconv = &#39;A&#39;;
3605   else                                         callconv = &#39;Z&#39;;
3606 
3607   return callconv;
3608 }
3609 
3610 void ArchDesc::generate_needs_clone_jvms(FILE *fp_cpp) {
3611   fprintf(fp_cpp, &quot;bool Compile::needs_clone_jvms() { return %s; }\n\n&quot;,
3612           _needs_clone_jvms ? &quot;true&quot; : &quot;false&quot;);
3613 }
3614 
3615 //---------------------------generate_assertion_checks-------------------
3616 void ArchDesc::generate_adlc_verification(FILE *fp_cpp) {
3617   fprintf(fp_cpp, &quot;\n&quot;);
3618 
3619   fprintf(fp_cpp, &quot;#ifndef PRODUCT\n&quot;);
3620   fprintf(fp_cpp, &quot;void Compile::adlc_verification() {\n&quot;);
3621   globalDefs().print_asserts(fp_cpp);
3622   fprintf(fp_cpp, &quot;}\n&quot;);
3623   fprintf(fp_cpp, &quot;#endif\n&quot;);
3624   fprintf(fp_cpp, &quot;\n&quot;);
3625 }
3626 
3627 //---------------------------addSourceBlocks-----------------------------
3628 void ArchDesc::addSourceBlocks(FILE *fp_cpp) {
3629   if (_source.count() &gt; 0)
3630     _source.output(fp_cpp);
3631 
3632   generate_adlc_verification(fp_cpp);
3633 }
3634 //---------------------------addHeaderBlocks-----------------------------
3635 void ArchDesc::addHeaderBlocks(FILE *fp_hpp) {
3636   if (_header.count() &gt; 0)
3637     _header.output(fp_hpp);
3638 }
3639 //-------------------------addPreHeaderBlocks----------------------------
3640 void ArchDesc::addPreHeaderBlocks(FILE *fp_hpp) {
3641   // Output #defines from definition block
3642   globalDefs().print_defines(fp_hpp);
3643 
3644   if (_pre_header.count() &gt; 0)
3645     _pre_header.output(fp_hpp);
3646 }
3647 
3648 //---------------------------buildReduceMaps-----------------------------
3649 // Build  mapping from enumeration for densely packed operands
3650 // TO result and child types.
3651 void ArchDesc::buildReduceMaps(FILE *fp_hpp, FILE *fp_cpp) {
3652   RegDef       *rdef;
3653   RegDef       *next;
3654 
3655   // The emit bodies currently require functions defined in the source block.
3656 
3657   // Build external declarations for mappings
3658   fprintf(fp_hpp, &quot;\n&quot;);
3659   fprintf(fp_hpp, &quot;extern const char  register_save_policy[];\n&quot;);
3660   fprintf(fp_hpp, &quot;extern const char  c_reg_save_policy[];\n&quot;);
3661   fprintf(fp_hpp, &quot;extern const int   register_save_type[];\n&quot;);
3662   fprintf(fp_hpp, &quot;\n&quot;);
3663 
3664   // Construct Save-Policy array
3665   fprintf(fp_cpp, &quot;// Map from machine-independent register number to register_save_policy\n&quot;);
3666   fprintf(fp_cpp, &quot;const        char register_save_policy[] = {\n&quot;);
3667   _register-&gt;reset_RegDefs();
3668   for( rdef = _register-&gt;iter_RegDefs(); rdef != NULL; rdef = next ) {
3669     next              = _register-&gt;iter_RegDefs();
3670     char policy       = reg_save_policy(rdef-&gt;_callconv);
3671     const char *comma = (next != NULL) ? &quot;,&quot; : &quot; // no trailing comma&quot;;
3672     fprintf(fp_cpp, &quot;  &#39;%c&#39;%s // %s\n&quot;, policy, comma, rdef-&gt;_regname);
3673   }
3674   fprintf(fp_cpp, &quot;};\n\n&quot;);
3675 
3676   // Construct Native Save-Policy array
3677   fprintf(fp_cpp, &quot;// Map from machine-independent register number to c_reg_save_policy\n&quot;);
3678   fprintf(fp_cpp, &quot;const        char c_reg_save_policy[] = {\n&quot;);
3679   _register-&gt;reset_RegDefs();
3680   for( rdef = _register-&gt;iter_RegDefs(); rdef != NULL; rdef = next ) {
3681     next        = _register-&gt;iter_RegDefs();
3682     char policy = reg_save_policy(rdef-&gt;_c_conv);
3683     const char *comma = (next != NULL) ? &quot;,&quot; : &quot; // no trailing comma&quot;;
3684     fprintf(fp_cpp, &quot;  &#39;%c&#39;%s // %s\n&quot;, policy, comma, rdef-&gt;_regname);
3685   }
3686   fprintf(fp_cpp, &quot;};\n\n&quot;);
3687 
3688   // Construct Register Save Type array
3689   fprintf(fp_cpp, &quot;// Map from machine-independent register number to register_save_type\n&quot;);
3690   fprintf(fp_cpp, &quot;const        int register_save_type[] = {\n&quot;);
3691   _register-&gt;reset_RegDefs();
3692   for( rdef = _register-&gt;iter_RegDefs(); rdef != NULL; rdef = next ) {
3693     next = _register-&gt;iter_RegDefs();
3694     const char *comma = (next != NULL) ? &quot;,&quot; : &quot; // no trailing comma&quot;;
3695     fprintf(fp_cpp, &quot;  %s%s\n&quot;, rdef-&gt;_idealtype, comma);
3696   }
3697   fprintf(fp_cpp, &quot;};\n\n&quot;);
3698 
3699   // Construct the table for reduceOp
3700   OutputReduceOp output_reduce_op(fp_hpp, fp_cpp, _globalNames, *this);
3701   build_map(output_reduce_op);
3702   // Construct the table for leftOp
3703   OutputLeftOp output_left_op(fp_hpp, fp_cpp, _globalNames, *this);
3704   build_map(output_left_op);
3705   // Construct the table for rightOp
3706   OutputRightOp output_right_op(fp_hpp, fp_cpp, _globalNames, *this);
3707   build_map(output_right_op);
3708   // Construct the table of rule names
3709   OutputRuleName output_rule_name(fp_hpp, fp_cpp, _globalNames, *this);
3710   build_map(output_rule_name);
3711   // Construct the boolean table for subsumed operands
3712   OutputSwallowed output_swallowed(fp_hpp, fp_cpp, _globalNames, *this);
3713   build_map(output_swallowed);
3714   // // // Preserve in case we decide to use this table instead of another
3715   //// Construct the boolean table for instruction chain rules
3716   //OutputInstChainRule output_inst_chain(fp_hpp, fp_cpp, _globalNames, *this);
3717   //build_map(output_inst_chain);
3718 
3719 }
3720 
3721 
3722 //---------------------------buildMachOperGenerator---------------------------
3723 
3724 // Recurse through match tree, building path through corresponding state tree,
3725 // Until we reach the constant we are looking for.
3726 static void path_to_constant(FILE *fp, FormDict &amp;globals,
3727                              MatchNode *mnode, uint idx) {
3728   if ( ! mnode) return;
3729 
3730   unsigned    position = 0;
3731   const char *result   = NULL;
3732   const char *name     = NULL;
3733   const char *optype   = NULL;
3734 
3735   // Base Case: access constant in ideal node linked to current state node
3736   // Each type of constant has its own access function
3737   if ( (mnode-&gt;_lChild == NULL) &amp;&amp; (mnode-&gt;_rChild == NULL)
3738        &amp;&amp; mnode-&gt;base_operand(position, globals, result, name, optype) ) {
3739     if (         strcmp(optype,&quot;ConI&quot;) == 0 ) {
3740       fprintf(fp, &quot;_leaf-&gt;get_int()&quot;);
3741     } else if ( (strcmp(optype,&quot;ConP&quot;) == 0) ) {
3742       fprintf(fp, &quot;_leaf-&gt;bottom_type()-&gt;is_ptr()&quot;);
3743     } else if ( (strcmp(optype,&quot;ConN&quot;) == 0) ) {
3744       fprintf(fp, &quot;_leaf-&gt;bottom_type()-&gt;is_narrowoop()&quot;);
3745     } else if ( (strcmp(optype,&quot;ConNKlass&quot;) == 0) ) {
3746       fprintf(fp, &quot;_leaf-&gt;bottom_type()-&gt;is_narrowklass()&quot;);
3747     } else if ( (strcmp(optype,&quot;ConF&quot;) == 0) ) {
3748       fprintf(fp, &quot;_leaf-&gt;getf()&quot;);
3749     } else if ( (strcmp(optype,&quot;ConD&quot;) == 0) ) {
3750       fprintf(fp, &quot;_leaf-&gt;getd()&quot;);
3751     } else if ( (strcmp(optype,&quot;ConL&quot;) == 0) ) {
3752       fprintf(fp, &quot;_leaf-&gt;get_long()&quot;);
3753     } else if ( (strcmp(optype,&quot;Con&quot;)==0) ) {
3754       // !!!!! - Update if adding a machine-independent constant type
3755       fprintf(fp, &quot;_leaf-&gt;get_int()&quot;);
3756       assert( false, &quot;Unsupported constant type, pointer or indefinite&quot;);
3757     } else if ( (strcmp(optype,&quot;Bool&quot;) == 0) ) {
3758       fprintf(fp, &quot;_leaf-&gt;as_Bool()-&gt;_test._test&quot;);
3759     } else {
3760       assert( false, &quot;Unsupported constant type&quot;);
3761     }
3762     return;
3763   }
3764 
3765   // If constant is in left child, build path and recurse
3766   uint lConsts = (mnode-&gt;_lChild) ? (mnode-&gt;_lChild-&gt;num_consts(globals) ) : 0;
3767   uint rConsts = (mnode-&gt;_rChild) ? (mnode-&gt;_rChild-&gt;num_consts(globals) ) : 0;
3768   if ( (mnode-&gt;_lChild) &amp;&amp; (lConsts &gt; idx) ) {
3769     fprintf(fp, &quot;_kids[0]-&gt;&quot;);
3770     path_to_constant(fp, globals, mnode-&gt;_lChild, idx);
3771     return;
3772   }
3773   // If constant is in right child, build path and recurse
3774   if ( (mnode-&gt;_rChild) &amp;&amp; (rConsts &gt; (idx - lConsts) ) ) {
3775     idx = idx - lConsts;
3776     fprintf(fp, &quot;_kids[1]-&gt;&quot;);
3777     path_to_constant(fp, globals, mnode-&gt;_rChild, idx);
3778     return;
3779   }
3780   assert( false, &quot;ShouldNotReachHere()&quot;);
3781 }
3782 
3783 // Generate code that is executed when generating a specific Machine Operand
3784 static void genMachOperCase(FILE *fp, FormDict &amp;globalNames, ArchDesc &amp;AD,
3785                             OperandForm &amp;op) {
3786   const char *opName         = op._ident;
3787   const char *opEnumName     = AD.machOperEnum(opName);
3788   uint        num_consts     = op.num_consts(globalNames);
3789 
3790   // Generate the case statement for this opcode
3791   fprintf(fp, &quot;  case %s:&quot;, opEnumName);
3792   fprintf(fp, &quot;\n    return new %sOper(&quot;, opName);
3793   // Access parameters for constructor from the stat object
3794   //
3795   // Build access to condition code value
3796   if ( (num_consts &gt; 0) ) {
3797     uint i = 0;
3798     path_to_constant(fp, globalNames, op._matrule, i);
3799     for ( i = 1; i &lt; num_consts; ++i ) {
3800       fprintf(fp, &quot;, &quot;);
3801       path_to_constant(fp, globalNames, op._matrule, i);
3802     }
3803   }
3804   fprintf(fp, &quot; );\n&quot;);
3805 }
3806 
3807 
3808 // Build switch to invoke &quot;new&quot; MachNode or MachOper
3809 void ArchDesc::buildMachOperGenerator(FILE *fp_cpp) {
3810   int idx = 0;
3811 
3812   // Build switch to invoke &#39;new&#39; for a specific MachOper
3813   fprintf(fp_cpp, &quot;\n&quot;);
3814   fprintf(fp_cpp, &quot;\n&quot;);
3815   fprintf(fp_cpp,
3816           &quot;//------------------------- MachOper Generator ---------------\n&quot;);
3817   fprintf(fp_cpp,
3818           &quot;// A switch statement on the dense-packed user-defined type system\n&quot;
3819           &quot;// that invokes &#39;new&#39; on the corresponding class constructor.\n&quot;);
3820   fprintf(fp_cpp, &quot;\n&quot;);
3821   fprintf(fp_cpp, &quot;MachOper *State::MachOperGenerator&quot;);
3822   fprintf(fp_cpp, &quot;(int opcode)&quot;);
3823   fprintf(fp_cpp, &quot;{\n&quot;);
3824   fprintf(fp_cpp, &quot;\n&quot;);
3825   fprintf(fp_cpp, &quot;  switch(opcode) {\n&quot;);
3826 
3827   // Place all user-defined operands into the mapping
3828   _operands.reset();
3829   int  opIndex = 0;
3830   OperandForm *op;
3831   for( ; (op =  (OperandForm*)_operands.iter()) != NULL; ) {
3832     // Ensure this is a machine-world instruction
3833     if ( op-&gt;ideal_only() )  continue;
3834 
3835     genMachOperCase(fp_cpp, _globalNames, *this, *op);
3836   };
3837 
3838   // Do not iterate over operand classes for the  operand generator!!!
3839 
3840   // Place all internal operands into the mapping
3841   _internalOpNames.reset();
3842   const char *iopn;
3843   for( ; (iopn =  _internalOpNames.iter()) != NULL; ) {
3844     const char *opEnumName = machOperEnum(iopn);
3845     // Generate the case statement for this opcode
3846     fprintf(fp_cpp, &quot;  case %s:&quot;, opEnumName);
3847     fprintf(fp_cpp, &quot;    return NULL;\n&quot;);
3848   };
3849 
3850   // Generate the default case for switch(opcode)
3851   fprintf(fp_cpp, &quot;  \n&quot;);
3852   fprintf(fp_cpp, &quot;  default:\n&quot;);
3853   fprintf(fp_cpp, &quot;    fprintf(stderr, \&quot;Default MachOper Generator invoked for: \\n\&quot;);\n&quot;);
3854   fprintf(fp_cpp, &quot;    fprintf(stderr, \&quot;   opcode = %cd\\n\&quot;, opcode);\n&quot;, &#39;%&#39;);
3855   fprintf(fp_cpp, &quot;    break;\n&quot;);
3856   fprintf(fp_cpp, &quot;  }\n&quot;);
3857 
3858   // Generate the closing for method Matcher::MachOperGenerator
3859   fprintf(fp_cpp, &quot;  return NULL;\n&quot;);
3860   fprintf(fp_cpp, &quot;};\n&quot;);
3861 }
3862 
3863 
3864 //---------------------------buildMachNode-------------------------------------
3865 // Build a new MachNode, for MachNodeGenerator or cisc-spilling
3866 void ArchDesc::buildMachNode(FILE *fp_cpp, InstructForm *inst, const char *indent) {
3867   const char *opType  = NULL;
3868   const char *opClass = inst-&gt;_ident;
3869 
3870   // Create the MachNode object
3871   fprintf(fp_cpp, &quot;%s %sNode *node = new %sNode();\n&quot;,indent, opClass,opClass);
3872 
3873   if ( (inst-&gt;num_post_match_opnds() != 0) ) {
3874     // Instruction that contains operands which are not in match rule.
3875     //
3876     // Check if the first post-match component may be an interesting def
3877     bool           dont_care = false;
3878     ComponentList &amp;comp_list = inst-&gt;_components;
3879     Component     *comp      = NULL;
3880     comp_list.reset();
3881     if ( comp_list.match_iter() != NULL )    dont_care = true;
3882 
3883     // Insert operands that are not in match-rule.
3884     // Only insert a DEF if the do_care flag is set
3885     comp_list.reset();
3886     while ( (comp = comp_list.post_match_iter()) ) {
3887       // Check if we don&#39;t care about DEFs or KILLs that are not USEs
3888       if ( dont_care &amp;&amp; (! comp-&gt;isa(Component::USE)) ) {
3889         continue;
3890       }
3891       dont_care = true;
3892       // For each operand not in the match rule, call MachOperGenerator
3893       // with the enum for the opcode that needs to be built.
3894       ComponentList clist = inst-&gt;_components;
3895       int         index  = clist.operand_position(comp-&gt;_name, comp-&gt;_usedef, inst);
3896       const char *opcode = machOperEnum(comp-&gt;_type);
3897       fprintf(fp_cpp, &quot;%s node-&gt;set_opnd_array(%d, &quot;, indent, index);
3898       fprintf(fp_cpp, &quot;MachOperGenerator(%s));\n&quot;, opcode);
3899       }
3900   }
3901   else if ( inst-&gt;is_chain_of_constant(_globalNames, opType) ) {
3902     // An instruction that chains from a constant!
3903     // In this case, we need to subsume the constant into the node
3904     // at operand position, oper_input_base().
3905     //
3906     // Fill in the constant
3907     fprintf(fp_cpp, &quot;%s node-&gt;_opnd_array[%d] = &quot;, indent,
3908             inst-&gt;oper_input_base(_globalNames));
3909     // #####
3910     // Check for multiple constants and then fill them in.
3911     // Just like MachOperGenerator
3912     const char *opName = inst-&gt;_matrule-&gt;_rChild-&gt;_opType;
3913     fprintf(fp_cpp, &quot;new %sOper(&quot;, opName);
3914     // Grab operand form
3915     OperandForm *op = (_globalNames[opName])-&gt;is_operand();
3916     // Look up the number of constants
3917     uint num_consts = op-&gt;num_consts(_globalNames);
3918     if ( (num_consts &gt; 0) ) {
3919       uint i = 0;
3920       path_to_constant(fp_cpp, _globalNames, op-&gt;_matrule, i);
3921       for ( i = 1; i &lt; num_consts; ++i ) {
3922         fprintf(fp_cpp, &quot;, &quot;);
3923         path_to_constant(fp_cpp, _globalNames, op-&gt;_matrule, i);
3924       }
3925     }
3926     fprintf(fp_cpp, &quot; );\n&quot;);
3927     // #####
3928   }
3929 
3930   // Fill in the bottom_type where requested
3931   if (inst-&gt;captures_bottom_type(_globalNames)) {
3932     if (strncmp(&quot;MachCall&quot;, inst-&gt;mach_base_class(_globalNames), strlen(&quot;MachCall&quot;))) {
3933       fprintf(fp_cpp, &quot;%s node-&gt;_bottom_type = _leaf-&gt;bottom_type();\n&quot;, indent);
3934     }
3935   }
3936   if( inst-&gt;is_ideal_if() ) {
3937     fprintf(fp_cpp, &quot;%s node-&gt;_prob = _leaf-&gt;as_If()-&gt;_prob;\n&quot;, indent);
3938     fprintf(fp_cpp, &quot;%s node-&gt;_fcnt = _leaf-&gt;as_If()-&gt;_fcnt;\n&quot;, indent);
3939   }
<a name="5" id="anc5"></a>


3940   if (inst-&gt;is_ideal_jump()) {
3941     fprintf(fp_cpp, &quot;%s node-&gt;_probs = _leaf-&gt;as_Jump()-&gt;_probs;\n&quot;, indent);
3942   }
3943   if( inst-&gt;is_ideal_fastlock() ) {
3944     fprintf(fp_cpp, &quot;%s node-&gt;_counters = _leaf-&gt;as_FastLock()-&gt;counters();\n&quot;, indent);
3945     fprintf(fp_cpp, &quot;%s node-&gt;_rtm_counters = _leaf-&gt;as_FastLock()-&gt;rtm_counters();\n&quot;, indent);
3946     fprintf(fp_cpp, &quot;%s node-&gt;_stack_rtm_counters = _leaf-&gt;as_FastLock()-&gt;stack_rtm_counters();\n&quot;, indent);
3947   }
3948 
3949 }
3950 
3951 //---------------------------declare_cisc_version------------------------------
3952 // Build CISC version of this instruction
3953 void InstructForm::declare_cisc_version(ArchDesc &amp;AD, FILE *fp_hpp) {
3954   if( AD.can_cisc_spill() ) {
3955     InstructForm *inst_cisc = cisc_spill_alternate();
3956     if (inst_cisc != NULL) {
3957       fprintf(fp_hpp, &quot;  virtual int            cisc_operand() const { return %d; }\n&quot;, cisc_spill_operand());
3958       fprintf(fp_hpp, &quot;  virtual MachNode      *cisc_version(int offset);\n&quot;);
3959       fprintf(fp_hpp, &quot;  virtual void           use_cisc_RegMask();\n&quot;);
3960       fprintf(fp_hpp, &quot;  virtual const RegMask *cisc_RegMask() const { return _cisc_RegMask; }\n&quot;);
3961     }
3962   }
3963 }
3964 
3965 //---------------------------define_cisc_version-------------------------------
3966 // Build CISC version of this instruction
3967 bool InstructForm::define_cisc_version(ArchDesc &amp;AD, FILE *fp_cpp) {
3968   InstructForm *inst_cisc = this-&gt;cisc_spill_alternate();
3969   if( AD.can_cisc_spill() &amp;&amp; (inst_cisc != NULL) ) {
3970     const char   *name      = inst_cisc-&gt;_ident;
3971     assert( inst_cisc-&gt;num_opnds() == this-&gt;num_opnds(), &quot;Must have same number of operands&quot;);
3972     OperandForm *cisc_oper = AD.cisc_spill_operand();
3973     assert( cisc_oper != NULL, &quot;insanity check&quot;);
3974     const char *cisc_oper_name  = cisc_oper-&gt;_ident;
3975     assert( cisc_oper_name != NULL, &quot;insanity check&quot;);
3976     //
3977     // Set the correct reg_mask_or_stack for the cisc operand
3978     fprintf(fp_cpp, &quot;\n&quot;);
3979     fprintf(fp_cpp, &quot;void %sNode::use_cisc_RegMask() {\n&quot;, this-&gt;_ident);
3980     // Lookup the correct reg_mask_or_stack
3981     const char *reg_mask_name = cisc_reg_mask_name();
3982     fprintf(fp_cpp, &quot;  _cisc_RegMask = &amp;STACK_OR_%s;\n&quot;, reg_mask_name);
3983     fprintf(fp_cpp, &quot;}\n&quot;);
3984     //
3985     // Construct CISC version of this instruction
3986     fprintf(fp_cpp, &quot;\n&quot;);
3987     fprintf(fp_cpp, &quot;// Build CISC version of this instruction\n&quot;);
3988     fprintf(fp_cpp, &quot;MachNode *%sNode::cisc_version(int offset) {\n&quot;, this-&gt;_ident);
3989     // Create the MachNode object
3990     fprintf(fp_cpp, &quot;  %sNode *node = new %sNode();\n&quot;, name, name);
3991     // Fill in the bottom_type where requested
3992     if ( this-&gt;captures_bottom_type(AD.globalNames()) ) {
3993       fprintf(fp_cpp, &quot;  node-&gt;_bottom_type = bottom_type();\n&quot;);
3994     }
3995 
3996     uint cur_num_opnds = num_opnds();
3997     if (cur_num_opnds &gt; 1 &amp;&amp; cur_num_opnds != num_unique_opnds()) {
3998       fprintf(fp_cpp,&quot;  node-&gt;_num_opnds = %d;\n&quot;, num_unique_opnds());
3999     }
4000 
4001     fprintf(fp_cpp, &quot;\n&quot;);
4002     fprintf(fp_cpp, &quot;  // Copy _idx, inputs and operands to new node\n&quot;);
4003     fprintf(fp_cpp, &quot;  fill_new_machnode(node);\n&quot;);
4004     // Construct operand to access [stack_pointer + offset]
4005     fprintf(fp_cpp, &quot;  // Construct operand to access [stack_pointer + offset]\n&quot;);
4006     fprintf(fp_cpp, &quot;  node-&gt;set_opnd_array(cisc_operand(), new %sOper(offset));\n&quot;, cisc_oper_name);
4007     fprintf(fp_cpp, &quot;\n&quot;);
4008 
4009     // Return result and exit scope
4010     fprintf(fp_cpp, &quot;  return node;\n&quot;);
4011     fprintf(fp_cpp, &quot;}\n&quot;);
4012     fprintf(fp_cpp, &quot;\n&quot;);
4013     return true;
4014   }
4015   return false;
4016 }
4017 
4018 //---------------------------declare_short_branch_methods----------------------
4019 // Build prototypes for short branch methods
4020 void InstructForm::declare_short_branch_methods(FILE *fp_hpp) {
4021   if (has_short_branch_form()) {
4022     fprintf(fp_hpp, &quot;  virtual MachNode      *short_branch_version();\n&quot;);
4023   }
4024 }
4025 
4026 //---------------------------define_short_branch_methods-----------------------
4027 // Build definitions for short branch methods
4028 bool InstructForm::define_short_branch_methods(ArchDesc &amp;AD, FILE *fp_cpp) {
4029   if (has_short_branch_form()) {
4030     InstructForm *short_branch = short_branch_form();
4031     const char   *name         = short_branch-&gt;_ident;
4032 
4033     // Construct short_branch_version() method.
4034     fprintf(fp_cpp, &quot;// Build short branch version of this instruction\n&quot;);
4035     fprintf(fp_cpp, &quot;MachNode *%sNode::short_branch_version() {\n&quot;, this-&gt;_ident);
4036     // Create the MachNode object
4037     fprintf(fp_cpp, &quot;  %sNode *node = new %sNode();\n&quot;, name, name);
4038     if( is_ideal_if() ) {
4039       fprintf(fp_cpp, &quot;  node-&gt;_prob = _prob;\n&quot;);
4040       fprintf(fp_cpp, &quot;  node-&gt;_fcnt = _fcnt;\n&quot;);
4041     }
4042     // Fill in the bottom_type where requested
4043     if ( this-&gt;captures_bottom_type(AD.globalNames()) ) {
4044       fprintf(fp_cpp, &quot;  node-&gt;_bottom_type = bottom_type();\n&quot;);
4045     }
4046 
4047     fprintf(fp_cpp, &quot;\n&quot;);
4048     // Short branch version must use same node index for access
4049     // through allocator&#39;s tables
4050     fprintf(fp_cpp, &quot;  // Copy _idx, inputs and operands to new node\n&quot;);
4051     fprintf(fp_cpp, &quot;  fill_new_machnode(node);\n&quot;);
4052 
4053     // Return result and exit scope
4054     fprintf(fp_cpp, &quot;  return node;\n&quot;);
4055     fprintf(fp_cpp, &quot;}\n&quot;);
4056     fprintf(fp_cpp,&quot;\n&quot;);
4057     return true;
4058   }
4059   return false;
4060 }
4061 
4062 
4063 //---------------------------buildMachNodeGenerator----------------------------
4064 // Build switch to invoke appropriate &quot;new&quot; MachNode for an opcode
4065 void ArchDesc::buildMachNodeGenerator(FILE *fp_cpp) {
4066 
4067   // Build switch to invoke &#39;new&#39; for a specific MachNode
4068   fprintf(fp_cpp, &quot;\n&quot;);
4069   fprintf(fp_cpp, &quot;\n&quot;);
4070   fprintf(fp_cpp,
4071           &quot;//------------------------- MachNode Generator ---------------\n&quot;);
4072   fprintf(fp_cpp,
4073           &quot;// A switch statement on the dense-packed user-defined type system\n&quot;
4074           &quot;// that invokes &#39;new&#39; on the corresponding class constructor.\n&quot;);
4075   fprintf(fp_cpp, &quot;\n&quot;);
4076   fprintf(fp_cpp, &quot;MachNode *State::MachNodeGenerator&quot;);
4077   fprintf(fp_cpp, &quot;(int opcode)&quot;);
4078   fprintf(fp_cpp, &quot;{\n&quot;);
4079   fprintf(fp_cpp, &quot;  switch(opcode) {\n&quot;);
4080 
4081   // Provide constructor for all user-defined instructions
4082   _instructions.reset();
4083   int  opIndex = operandFormCount();
4084   InstructForm *inst;
4085   for( ; (inst = (InstructForm*)_instructions.iter()) != NULL; ) {
4086     // Ensure that matrule is defined.
4087     if ( inst-&gt;_matrule == NULL ) continue;
4088 
4089     int         opcode  = opIndex++;
4090     const char *opClass = inst-&gt;_ident;
4091     char       *opType  = NULL;
4092 
4093     // Generate the case statement for this instruction
4094     fprintf(fp_cpp, &quot;  case %s_rule:&quot;, opClass);
4095 
4096     // Start local scope
4097     fprintf(fp_cpp, &quot; {\n&quot;);
4098     // Generate code to construct the new MachNode
4099     buildMachNode(fp_cpp, inst, &quot;     &quot;);
4100     // Return result and exit scope
4101     fprintf(fp_cpp, &quot;      return node;\n&quot;);
4102     fprintf(fp_cpp, &quot;    }\n&quot;);
4103   }
4104 
4105   // Generate the default case for switch(opcode)
4106   fprintf(fp_cpp, &quot;  \n&quot;);
4107   fprintf(fp_cpp, &quot;  default:\n&quot;);
4108   fprintf(fp_cpp, &quot;    fprintf(stderr, \&quot;Default MachNode Generator invoked for: \\n\&quot;);\n&quot;);
4109   fprintf(fp_cpp, &quot;    fprintf(stderr, \&quot;   opcode = %cd\\n\&quot;, opcode);\n&quot;, &#39;%&#39;);
4110   fprintf(fp_cpp, &quot;    break;\n&quot;);
4111   fprintf(fp_cpp, &quot;  };\n&quot;);
4112 
4113   // Generate the closing for method Matcher::MachNodeGenerator
4114   fprintf(fp_cpp, &quot;  return NULL;\n&quot;);
4115   fprintf(fp_cpp, &quot;}\n&quot;);
4116 }
4117 
4118 
4119 //---------------------------buildInstructMatchCheck--------------------------
4120 // Output the method to Matcher which checks whether or not a specific
4121 // instruction has a matching rule for the host architecture.
4122 void ArchDesc::buildInstructMatchCheck(FILE *fp_cpp) const {
4123   fprintf(fp_cpp, &quot;\n\n&quot;);
4124   fprintf(fp_cpp, &quot;const bool Matcher::has_match_rule(int opcode) {\n&quot;);
4125   fprintf(fp_cpp, &quot;  assert(_last_machine_leaf &lt; opcode &amp;&amp; opcode &lt; _last_opcode, \&quot;opcode in range\&quot;);\n&quot;);
4126   fprintf(fp_cpp, &quot;  return _hasMatchRule[opcode];\n&quot;);
4127   fprintf(fp_cpp, &quot;}\n\n&quot;);
4128 
4129   fprintf(fp_cpp, &quot;const bool Matcher::_hasMatchRule[_last_opcode] = {\n&quot;);
4130   int i;
4131   for (i = 0; i &lt; _last_opcode - 1; i++) {
4132     fprintf(fp_cpp, &quot;    %-5s,  // %s\n&quot;,
4133             _has_match_rule[i] ? &quot;true&quot; : &quot;false&quot;,
4134             NodeClassNames[i]);
4135   }
4136   fprintf(fp_cpp, &quot;    %-5s   // %s\n&quot;,
4137           _has_match_rule[i] ? &quot;true&quot; : &quot;false&quot;,
4138           NodeClassNames[i]);
4139   fprintf(fp_cpp, &quot;};\n&quot;);
4140 }
4141 
4142 //---------------------------buildFrameMethods---------------------------------
4143 // Output the methods to Matcher which specify frame behavior
4144 void ArchDesc::buildFrameMethods(FILE *fp_cpp) {
4145   fprintf(fp_cpp,&quot;\n\n&quot;);
4146   // Stack Direction
4147   fprintf(fp_cpp,&quot;bool Matcher::stack_direction() const { return %s; }\n\n&quot;,
4148           _frame-&gt;_direction ? &quot;true&quot; : &quot;false&quot;);
4149   // Sync Stack Slots
4150   fprintf(fp_cpp,&quot;int Compile::sync_stack_slots() const { return %s; }\n\n&quot;,
4151           _frame-&gt;_sync_stack_slots);
4152   // Java Stack Alignment
4153   fprintf(fp_cpp,&quot;uint Matcher::stack_alignment_in_bytes() { return %s; }\n\n&quot;,
4154           _frame-&gt;_alignment);
4155   // Java Return Address Location
4156   fprintf(fp_cpp,&quot;OptoReg::Name Matcher::return_addr() const {&quot;);
4157   if (_frame-&gt;_return_addr_loc) {
4158     fprintf(fp_cpp,&quot; return OptoReg::Name(%s_num); }\n\n&quot;,
4159             _frame-&gt;_return_addr);
4160   }
4161   else {
4162     fprintf(fp_cpp,&quot; return OptoReg::stack2reg(%s); }\n\n&quot;,
4163             _frame-&gt;_return_addr);
4164   }
4165   // Java Stack Slot Preservation
4166   fprintf(fp_cpp,&quot;uint Compile::in_preserve_stack_slots() &quot;);
4167   fprintf(fp_cpp,&quot;{ return %s; }\n\n&quot;, _frame-&gt;_in_preserve_slots);
4168   // Top Of Stack Slot Preservation, for both Java and C
4169   fprintf(fp_cpp,&quot;uint Compile::out_preserve_stack_slots() &quot;);
4170   fprintf(fp_cpp,&quot;{ return SharedRuntime::out_preserve_stack_slots(); }\n\n&quot;);
4171   // varargs C out slots killed
4172   fprintf(fp_cpp,&quot;uint Compile::varargs_C_out_slots_killed() const &quot;);
4173   fprintf(fp_cpp,&quot;{ return %s; }\n\n&quot;, _frame-&gt;_varargs_C_out_slots_killed);
4174   // Java Argument Position
4175   fprintf(fp_cpp,&quot;void Matcher::calling_convention(BasicType *sig_bt, VMRegPair *regs, uint length, bool is_outgoing) {\n&quot;);
4176   fprintf(fp_cpp,&quot;%s\n&quot;, _frame-&gt;_calling_convention);
4177   fprintf(fp_cpp,&quot;}\n\n&quot;);
4178   // Native Argument Position
4179   fprintf(fp_cpp,&quot;void Matcher::c_calling_convention(BasicType *sig_bt, VMRegPair *regs, uint length) {\n&quot;);
4180   fprintf(fp_cpp,&quot;%s\n&quot;, _frame-&gt;_c_calling_convention);
4181   fprintf(fp_cpp,&quot;}\n\n&quot;);
4182   // Java Return Value Location
4183   fprintf(fp_cpp,&quot;OptoRegPair Matcher::return_value(uint ideal_reg, bool is_outgoing) {\n&quot;);
4184   fprintf(fp_cpp,&quot;%s\n&quot;, _frame-&gt;_return_value);
4185   fprintf(fp_cpp,&quot;}\n\n&quot;);
4186   // Native Return Value Location
4187   fprintf(fp_cpp,&quot;OptoRegPair Matcher::c_return_value(uint ideal_reg, bool is_outgoing) {\n&quot;);
4188   fprintf(fp_cpp,&quot;%s\n&quot;, _frame-&gt;_c_return_value);
4189   fprintf(fp_cpp,&quot;}\n\n&quot;);
4190 
4191   // Inline Cache Register, mask definition, and encoding
4192   fprintf(fp_cpp,&quot;OptoReg::Name Matcher::inline_cache_reg() {&quot;);
4193   fprintf(fp_cpp,&quot; return OptoReg::Name(%s_num); }\n\n&quot;,
4194           _frame-&gt;_inline_cache_reg);
4195   fprintf(fp_cpp,&quot;int Matcher::inline_cache_reg_encode() {&quot;);
4196   fprintf(fp_cpp,&quot; return _regEncode[inline_cache_reg()]; }\n\n&quot;);
4197 
4198   // Interpreter&#39;s Method Oop Register, mask definition, and encoding
4199   fprintf(fp_cpp,&quot;OptoReg::Name Matcher::interpreter_method_oop_reg() {&quot;);
4200   fprintf(fp_cpp,&quot; return OptoReg::Name(%s_num); }\n\n&quot;,
4201           _frame-&gt;_interpreter_method_oop_reg);
4202   fprintf(fp_cpp,&quot;int Matcher::interpreter_method_oop_reg_encode() {&quot;);
4203   fprintf(fp_cpp,&quot; return _regEncode[interpreter_method_oop_reg()]; }\n\n&quot;);
4204 
4205   // Interpreter&#39;s Frame Pointer Register, mask definition, and encoding
4206   fprintf(fp_cpp,&quot;OptoReg::Name Matcher::interpreter_frame_pointer_reg() {&quot;);
4207   if (_frame-&gt;_interpreter_frame_pointer_reg == NULL)
4208     fprintf(fp_cpp,&quot; return OptoReg::Bad; }\n\n&quot;);
4209   else
4210     fprintf(fp_cpp,&quot; return OptoReg::Name(%s_num); }\n\n&quot;,
4211             _frame-&gt;_interpreter_frame_pointer_reg);
4212 
4213   // Frame Pointer definition
4214   /* CNC - I can not contemplate having a different frame pointer between
4215      Java and native code; makes my head hurt to think about it.
4216   fprintf(fp_cpp,&quot;OptoReg::Name Matcher::frame_pointer() const {&quot;);
4217   fprintf(fp_cpp,&quot; return OptoReg::Name(%s_num); }\n\n&quot;,
4218           _frame-&gt;_frame_pointer);
4219   */
4220   // (Native) Frame Pointer definition
4221   fprintf(fp_cpp,&quot;OptoReg::Name Matcher::c_frame_pointer() const {&quot;);
4222   fprintf(fp_cpp,&quot; return OptoReg::Name(%s_num); }\n\n&quot;,
4223           _frame-&gt;_frame_pointer);
4224 
4225   // Number of callee-save + always-save registers for calling convention
4226   fprintf(fp_cpp, &quot;// Number of callee-save + always-save registers\n&quot;);
4227   fprintf(fp_cpp, &quot;int  Matcher::number_of_saved_registers() {\n&quot;);
4228   RegDef *rdef;
4229   int nof_saved_registers = 0;
4230   _register-&gt;reset_RegDefs();
4231   while( (rdef = _register-&gt;iter_RegDefs()) != NULL ) {
4232     if( !strcmp(rdef-&gt;_callconv, &quot;SOE&quot;) ||  !strcmp(rdef-&gt;_callconv, &quot;AS&quot;) )
4233       ++nof_saved_registers;
4234   }
4235   fprintf(fp_cpp, &quot;  return %d;\n&quot;, nof_saved_registers);
4236   fprintf(fp_cpp, &quot;};\n\n&quot;);
4237 }
4238 
4239 
4240 
4241 
4242 static int PrintAdlcCisc = 0;
4243 //---------------------------identify_cisc_spilling----------------------------
4244 // Get info for the CISC_oracle and MachNode::cisc_version()
4245 void ArchDesc::identify_cisc_spill_instructions() {
4246 
4247   if (_frame == NULL)
4248     return;
4249 
4250   // Find the user-defined operand for cisc-spilling
4251   if( _frame-&gt;_cisc_spilling_operand_name != NULL ) {
4252     const Form *form = _globalNames[_frame-&gt;_cisc_spilling_operand_name];
4253     OperandForm *oper = form ? form-&gt;is_operand() : NULL;
4254     // Verify the user&#39;s suggestion
4255     if( oper != NULL ) {
4256       // Ensure that match field is defined.
4257       if ( oper-&gt;_matrule != NULL )  {
4258         MatchRule &amp;mrule = *oper-&gt;_matrule;
4259         if( strcmp(mrule._opType,&quot;AddP&quot;) == 0 ) {
4260           MatchNode *left = mrule._lChild;
4261           MatchNode *right= mrule._rChild;
4262           if( left != NULL &amp;&amp; right != NULL ) {
4263             const Form *left_op  = _globalNames[left-&gt;_opType]-&gt;is_operand();
4264             const Form *right_op = _globalNames[right-&gt;_opType]-&gt;is_operand();
4265             if(  (left_op != NULL &amp;&amp; right_op != NULL)
4266               &amp;&amp; (left_op-&gt;interface_type(_globalNames) == Form::register_interface)
4267               &amp;&amp; (right_op-&gt;interface_type(_globalNames) == Form::constant_interface) ) {
4268               // Successfully verified operand
4269               set_cisc_spill_operand( oper );
4270               if( _cisc_spill_debug ) {
4271                 fprintf(stderr, &quot;\n\nVerified CISC-spill operand %s\n\n&quot;, oper-&gt;_ident);
4272              }
4273             }
4274           }
4275         }
4276       }
4277     }
4278   }
4279 
4280   if( cisc_spill_operand() != NULL ) {
4281     // N^2 comparison of instructions looking for a cisc-spilling version
4282     _instructions.reset();
4283     InstructForm *instr;
4284     for( ; (instr = (InstructForm*)_instructions.iter()) != NULL; ) {
4285       // Ensure that match field is defined.
4286       if ( instr-&gt;_matrule == NULL )  continue;
4287 
4288       MatchRule &amp;mrule = *instr-&gt;_matrule;
4289       Predicate *pred  =  instr-&gt;build_predicate();
4290 
4291       // Grab the machine type of the operand
4292       const char *rootOp = instr-&gt;_ident;
4293       mrule._machType    = rootOp;
4294 
4295       // Find result type for match
4296       const char *result = instr-&gt;reduce_result();
4297 
4298       if( PrintAdlcCisc ) fprintf(stderr, &quot;  new instruction %s \n&quot;, instr-&gt;_ident ? instr-&gt;_ident : &quot; &quot;);
4299       bool  found_cisc_alternate = false;
4300       _instructions.reset2();
4301       InstructForm *instr2;
4302       for( ; !found_cisc_alternate &amp;&amp; (instr2 = (InstructForm*)_instructions.iter2()) != NULL; ) {
4303         // Ensure that match field is defined.
4304         if( PrintAdlcCisc ) fprintf(stderr, &quot;  instr2 == %s \n&quot;, instr2-&gt;_ident ? instr2-&gt;_ident : &quot; &quot;);
4305         if ( instr2-&gt;_matrule != NULL
4306             &amp;&amp; (instr != instr2 )                // Skip self
4307             &amp;&amp; (instr2-&gt;reduce_result() != NULL) // want same result
4308             &amp;&amp; (strcmp(result, instr2-&gt;reduce_result()) == 0)) {
4309           MatchRule &amp;mrule2 = *instr2-&gt;_matrule;
4310           Predicate *pred2  =  instr2-&gt;build_predicate();
4311           found_cisc_alternate = instr-&gt;cisc_spills_to(*this, instr2);
4312         }
4313       }
4314     }
4315   }
4316 }
4317 
4318 //---------------------------build_cisc_spilling-------------------------------
4319 // Get info for the CISC_oracle and MachNode::cisc_version()
4320 void ArchDesc::build_cisc_spill_instructions(FILE *fp_hpp, FILE *fp_cpp) {
4321   // Output the table for cisc spilling
4322   fprintf(fp_cpp, &quot;//  The following instructions can cisc-spill\n&quot;);
4323   _instructions.reset();
4324   InstructForm *inst = NULL;
4325   for(; (inst = (InstructForm*)_instructions.iter()) != NULL; ) {
4326     // Ensure this is a machine-world instruction
4327     if ( inst-&gt;ideal_only() )  continue;
4328     const char *inst_name = inst-&gt;_ident;
4329     int   operand   = inst-&gt;cisc_spill_operand();
4330     if( operand != AdlcVMDeps::Not_cisc_spillable ) {
4331       InstructForm *inst2 = inst-&gt;cisc_spill_alternate();
4332       fprintf(fp_cpp, &quot;//  %s can cisc-spill operand %d to %s\n&quot;, inst-&gt;_ident, operand, inst2-&gt;_ident);
4333     }
4334   }
4335   fprintf(fp_cpp, &quot;\n\n&quot;);
4336 }
4337 
4338 //---------------------------identify_short_branches----------------------------
4339 // Get info for our short branch replacement oracle.
4340 void ArchDesc::identify_short_branches() {
4341   // Walk over all instructions, checking to see if they match a short
4342   // branching alternate.
4343   _instructions.reset();
4344   InstructForm *instr;
4345   while( (instr = (InstructForm*)_instructions.iter()) != NULL ) {
4346     // The instruction must have a match rule.
4347     if (instr-&gt;_matrule != NULL &amp;&amp;
4348         instr-&gt;is_short_branch()) {
4349 
4350       _instructions.reset2();
4351       InstructForm *instr2;
4352       while( (instr2 = (InstructForm*)_instructions.iter2()) != NULL ) {
4353         instr2-&gt;check_branch_variant(*this, instr);
4354       }
4355     }
4356   }
4357 }
4358 
4359 
4360 //---------------------------identify_unique_operands---------------------------
4361 // Identify unique operands.
4362 void ArchDesc::identify_unique_operands() {
4363   // Walk over all instructions.
4364   _instructions.reset();
4365   InstructForm *instr;
4366   while( (instr = (InstructForm*)_instructions.iter()) != NULL ) {
4367     // Ensure this is a machine-world instruction
4368     if (!instr-&gt;ideal_only()) {
4369       instr-&gt;set_unique_opnds();
4370     }
4371   }
4372 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
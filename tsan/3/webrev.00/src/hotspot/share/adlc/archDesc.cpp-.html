<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/adlc/archDesc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 //
   2 // Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
   3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4 //
   5 // This code is free software; you can redistribute it and/or modify it
   6 // under the terms of the GNU General Public License version 2 only, as
   7 // published by the Free Software Foundation.
   8 //
   9 // This code is distributed in the hope that it will be useful, but WITHOUT
  10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12 // version 2 for more details (a copy is included in the LICENSE file that
  13 // accompanied this code).
  14 //
  15 // You should have received a copy of the GNU General Public License version
  16 // 2 along with this work; if not, write to the Free Software Foundation,
  17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18 //
  19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20 // or visit www.oracle.com if you need additional information or have any
  21 // questions.
  22 //
  23 //
  24 
  25 
  26 // archDesc.cpp - Internal format for architecture definition
  27 #include &quot;adlc.hpp&quot;
  28 
  29 static FILE *errfile = stderr;
  30 
  31 //--------------------------- utility functions -----------------------------
  32 inline char toUpper(char lower) {
  33   return ((&#39;a&#39; &lt;= lower &amp;&amp; lower &lt;= &#39;z&#39;) ? ((char) (lower + (&#39;A&#39;-&#39;a&#39;))) : lower);
  34 }
  35 char *toUpper(const char *str) {
  36   char *upper  = new char[strlen(str)+1];
  37   char *result = upper;
  38   const char *end    = str + strlen(str);
  39   for (; str &lt; end; ++str, ++upper) {
  40     *upper = toUpper(*str);
  41   }
  42   *upper = &#39;\0&#39;;
  43   return result;
  44 }
  45 
  46 //---------------------------ChainList Methods-------------------------------
  47 ChainList::ChainList() {
  48 }
  49 
  50 void ChainList::insert(const char *name, const char *cost, const char *rule) {
  51   _name.addName(name);
  52   _cost.addName(cost);
  53   _rule.addName(rule);
  54 }
  55 
  56 bool ChainList::search(const char *name) {
  57   return _name.search(name);
  58 }
  59 
  60 void ChainList::reset() {
  61   _name.reset();
  62   _cost.reset();
  63   _rule.reset();
  64 }
  65 
  66 bool ChainList::iter(const char * &amp;name, const char * &amp;cost, const char * &amp;rule) {
  67   bool        notDone = false;
  68   const char *n       = _name.iter();
  69   const char *c       = _cost.iter();
  70   const char *r       = _rule.iter();
  71 
  72   if (n &amp;&amp; c &amp;&amp; r) {
  73     notDone = true;
  74     name = n;
  75     cost = c;
  76     rule = r;
  77   }
  78 
  79   return notDone;
  80 }
  81 
  82 void ChainList::dump() {
  83   output(stderr);
  84 }
  85 
  86 void ChainList::output(FILE *fp) {
  87   fprintf(fp, &quot;\nChain Rules: output resets iterator\n&quot;);
  88   const char   *cost  = NULL;
  89   const char   *name  = NULL;
  90   const char   *rule  = NULL;
  91   bool   chains_exist = false;
  92   for(reset(); (iter(name,cost,rule)) == true; ) {
  93     fprintf(fp, &quot;Chain to &lt;%s&gt; at cost #%s using %s_rule\n&quot;,name, cost ? cost : &quot;0&quot;, rule);
  94     //  // Check for transitive chain rules
  95     //  Form *form = (Form *)_globalNames[rule];
  96     //  if (form-&gt;is_instruction()) {
  97     //    // chain_rule(fp, indent, name, cost, rule);
  98     //    chain_rule(fp, indent, name, cost, rule);
  99     //  }
 100   }
 101   reset();
 102   if( ! chains_exist ) {
 103     fprintf(fp, &quot;No entries in this ChainList\n&quot;);
 104   }
 105 }
 106 
 107 
 108 //---------------------------MatchList Methods-------------------------------
 109 bool MatchList::search(const char *opc, const char *res, const char *lch,
 110                        const char *rch, Predicate *pr) {
 111   bool tmp = false;
 112   if ((res == _resultStr) || (res &amp;&amp; _resultStr &amp;&amp; !strcmp(res, _resultStr))) {
 113     if ((lch == _lchild) || (lch &amp;&amp; _lchild &amp;&amp; !strcmp(lch, _lchild))) {
 114       if ((rch == _rchild) || (rch &amp;&amp; _rchild &amp;&amp; !strcmp(rch, _rchild))) {
 115         char * predStr = get_pred();
 116         char * prStr = pr?pr-&gt;_pred:NULL;
 117         if (ADLParser::equivalent_expressions(prStr, predStr)) {
 118           return true;
 119         }
 120       }
 121     }
 122   }
 123   if (_next) {
 124     tmp = _next-&gt;search(opc, res, lch, rch, pr);
 125   }
 126   return tmp;
 127 }
 128 
 129 
 130 void MatchList::dump() {
 131   output(stderr);
 132 }
 133 
 134 void MatchList::output(FILE *fp) {
 135   fprintf(fp, &quot;\nMatchList output is Unimplemented();\n&quot;);
 136 }
 137 
 138 
 139 //---------------------------ArchDesc Constructor and Destructor-------------
 140 
 141 ArchDesc::ArchDesc()
 142   : _globalNames(cmpstr,hashstr, Form::arena),
 143     _globalDefs(cmpstr,hashstr, Form::arena),
 144     _preproc_table(cmpstr,hashstr, Form::arena),
 145     _idealIndex(cmpstr,hashstr, Form::arena),
 146     _internalOps(cmpstr,hashstr, Form::arena),
 147     _internalMatch(cmpstr,hashstr, Form::arena),
 148     _chainRules(cmpstr,hashstr, Form::arena),
 149     _cisc_spill_operand(NULL),
 150     _needs_clone_jvms(false) {
 151 
 152       // Initialize the opcode to MatchList table with NULLs
 153       for( int i=0; i&lt;_last_opcode; ++i ) {
 154         _mlistab[i] = NULL;
 155       }
 156 
 157       // Set-up the global tables
 158       initKeywords(_globalNames);    // Initialize the Name Table with keywords
 159 
 160       // Prime user-defined types with predefined types: Set, RegI, RegF, ...
 161       initBaseOpTypes();
 162 
 163       // Initialize flags &amp; counters
 164       _TotalLines        = 0;
 165       _no_output         = 0;
 166       _quiet_mode        = 0;
 167       _disable_warnings  = 0;
 168       _dfa_debug         = 0;
 169       _dfa_small         = 0;
 170       _adl_debug         = 0;
 171       _adlocation_debug  = 0;
 172       _internalOpCounter = 0;
 173       _cisc_spill_debug  = false;
 174       _short_branch_debug = false;
 175 
 176       // Initialize match rule flags
 177       for (int i = 0; i &lt; _last_opcode; i++) {
 178         _has_match_rule[i] = false;
 179       }
 180 
 181       // Error/Warning Counts
 182       _syntax_errs       = 0;
 183       _semantic_errs     = 0;
 184       _warnings          = 0;
 185       _internal_errs     = 0;
 186 
 187       // Initialize I/O Files
 188       _ADL_file._name = NULL; _ADL_file._fp = NULL;
 189       // Machine dependent output files
 190       _DFA_file._name    = NULL;  _DFA_file._fp = NULL;
 191       _HPP_file._name    = NULL;  _HPP_file._fp = NULL;
 192       _CPP_file._name    = NULL;  _CPP_file._fp = NULL;
 193       _bug_file._name    = &quot;bugs.out&quot;;      _bug_file._fp = NULL;
 194 
 195       // Initialize Register &amp; Pipeline Form Pointers
 196       _register = NULL;
 197       _encode = NULL;
 198       _pipeline = NULL;
 199       _frame = NULL;
 200 }
 201 
 202 ArchDesc::~ArchDesc() {
 203   // Clean-up and quit
 204 
 205 }
 206 
 207 //---------------------------ArchDesc methods: Public ----------------------
 208 // Store forms according to type
 209 void ArchDesc::addForm(PreHeaderForm *ptr) { _pre_header.addForm(ptr); };
 210 void ArchDesc::addForm(HeaderForm    *ptr) { _header.addForm(ptr); };
 211 void ArchDesc::addForm(SourceForm    *ptr) { _source.addForm(ptr); };
 212 void ArchDesc::addForm(EncodeForm    *ptr) { _encode = ptr; };
 213 void ArchDesc::addForm(InstructForm  *ptr) { _instructions.addForm(ptr); };
 214 void ArchDesc::addForm(MachNodeForm  *ptr) { _machnodes.addForm(ptr); };
 215 void ArchDesc::addForm(OperandForm   *ptr) { _operands.addForm(ptr); };
 216 void ArchDesc::addForm(OpClassForm   *ptr) { _opclass.addForm(ptr); };
 217 void ArchDesc::addForm(AttributeForm *ptr) { _attributes.addForm(ptr); };
 218 void ArchDesc::addForm(RegisterForm  *ptr) { _register = ptr; };
 219 void ArchDesc::addForm(FrameForm     *ptr) { _frame = ptr; };
 220 void ArchDesc::addForm(PipelineForm  *ptr) { _pipeline = ptr; };
 221 
 222 // Build MatchList array and construct MatchLists
 223 void ArchDesc::generateMatchLists() {
 224   // Call inspection routines to populate array
 225   inspectOperands();
 226   inspectInstructions();
 227 }
 228 
 229 // Build MatchList structures for operands
 230 void ArchDesc::inspectOperands() {
 231 
 232   // Iterate through all operands
 233   _operands.reset();
 234   OperandForm *op;
 235   for( ; (op = (OperandForm*)_operands.iter()) != NULL;) {
 236     // Construct list of top-level operands (components)
 237     op-&gt;build_components();
 238 
 239     // Ensure that match field is defined.
 240     if ( op-&gt;_matrule == NULL )  continue;
 241 
 242     // Type check match rules
 243     check_optype(op-&gt;_matrule);
 244 
 245     // Construct chain rules
 246     build_chain_rule(op);
 247 
 248     MatchRule &amp;mrule = *op-&gt;_matrule;
 249     Predicate *pred  =  op-&gt;_predicate;
 250 
 251     // Grab the machine type of the operand
 252     const char  *rootOp    = op-&gt;_ident;
 253     mrule._machType  = rootOp;
 254 
 255     // Check for special cases
 256     if (strcmp(rootOp,&quot;Universe&quot;)==0) continue;
 257     if (strcmp(rootOp,&quot;label&quot;)==0) continue;
 258     // !!!!! !!!!!
 259     assert( strcmp(rootOp,&quot;sReg&quot;) != 0, &quot;Disable untyped &#39;sReg&#39;&quot;);
 260     if (strcmp(rootOp,&quot;sRegI&quot;)==0) continue;
 261     if (strcmp(rootOp,&quot;sRegP&quot;)==0) continue;
 262     if (strcmp(rootOp,&quot;sRegF&quot;)==0) continue;
 263     if (strcmp(rootOp,&quot;sRegD&quot;)==0) continue;
 264     if (strcmp(rootOp,&quot;sRegL&quot;)==0) continue;
 265 
 266     // Cost for this match
 267     const char *costStr     = op-&gt;cost();
 268     const char *defaultCost =
 269       ((AttributeForm*)_globalNames[AttributeForm::_op_cost])-&gt;_attrdef;
 270     const char *cost        =  costStr? costStr : defaultCost;
 271 
 272     // Find result type for match.
 273     const char *result      = op-&gt;reduce_result();
 274     bool        has_root    = false;
 275 
 276     // Construct a MatchList for this entry
 277     buildMatchList(op-&gt;_matrule, result, rootOp, pred, cost);
 278   }
 279 }
 280 
 281 // Build MatchList structures for instructions
 282 void ArchDesc::inspectInstructions() {
 283 
 284   // Iterate through all instructions
 285   _instructions.reset();
 286   InstructForm *instr;
 287   for( ; (instr = (InstructForm*)_instructions.iter()) != NULL; ) {
 288     // Construct list of top-level operands (components)
 289     instr-&gt;build_components();
 290 
 291     // Ensure that match field is defined.
 292     if ( instr-&gt;_matrule == NULL )  continue;
 293 
 294     MatchRule &amp;mrule = *instr-&gt;_matrule;
 295     Predicate *pred  =  instr-&gt;build_predicate();
 296 
 297     // Grab the machine type of the operand
 298     const char  *rootOp    = instr-&gt;_ident;
 299     mrule._machType  = rootOp;
 300 
 301     // Cost for this match
 302     const char *costStr = instr-&gt;cost();
 303     const char *defaultCost =
 304       ((AttributeForm*)_globalNames[AttributeForm::_ins_cost])-&gt;_attrdef;
 305     const char *cost    =  costStr? costStr : defaultCost;
 306 
 307     // Find result type for match
 308     const char *result  = instr-&gt;reduce_result();
 309 
 310     if (( instr-&gt;is_ideal_branch() &amp;&amp; instr-&gt;label_position() == -1) ||
 311         (!instr-&gt;is_ideal_branch() &amp;&amp; instr-&gt;label_position() != -1)) {
 312       syntax_err(instr-&gt;_linenum, &quot;%s: Only branches to a label are supported\n&quot;, rootOp);
 313     }
 314 
 315     Attribute *attr = instr-&gt;_attribs;
 316     while (attr != NULL) {
 317       if (strcmp(attr-&gt;_ident,&quot;ins_short_branch&quot;) == 0 &amp;&amp;
 318           attr-&gt;int_val(*this) != 0) {
 319         if (!instr-&gt;is_ideal_branch() || instr-&gt;label_position() == -1) {
 320           syntax_err(instr-&gt;_linenum, &quot;%s: Only short branch to a label is supported\n&quot;, rootOp);
 321         }
 322         instr-&gt;set_short_branch(true);
 323       } else if (strcmp(attr-&gt;_ident,&quot;ins_alignment&quot;) == 0 &amp;&amp;
 324           attr-&gt;int_val(*this) != 0) {
 325         instr-&gt;set_alignment(attr-&gt;int_val(*this));
 326       }
 327       attr = (Attribute *)attr-&gt;_next;
 328     }
 329 
 330     if (!instr-&gt;is_short_branch()) {
 331       buildMatchList(instr-&gt;_matrule, result, mrule._machType, pred, cost);
 332     }
 333   }
 334 }
 335 
 336 static int setsResult(MatchRule &amp;mrule) {
 337   if (strcmp(mrule._name,&quot;Set&quot;) == 0) return 1;
 338   return 0;
 339 }
 340 
 341 const char *ArchDesc::getMatchListIndex(MatchRule &amp;mrule) {
 342   if (setsResult(mrule)) {
 343     // right child
 344     return mrule._rChild-&gt;_opType;
 345   } else {
 346     // first entry
 347     return mrule._opType;
 348   }
 349 }
 350 
 351 
 352 //------------------------------result of reduction----------------------------
 353 
 354 
 355 //------------------------------left reduction---------------------------------
 356 // Return the left reduction associated with an internal name
 357 const char *ArchDesc::reduceLeft(char         *internalName) {
 358   const char *left  = NULL;
 359   MatchNode *mnode = (MatchNode*)_internalMatch[internalName];
 360   if (mnode-&gt;_lChild) {
 361     mnode = mnode-&gt;_lChild;
 362     left = mnode-&gt;_internalop ? mnode-&gt;_internalop : mnode-&gt;_opType;
 363   }
 364   return left;
 365 }
 366 
 367 
 368 //------------------------------right reduction--------------------------------
 369 const char *ArchDesc::reduceRight(char  *internalName) {
 370   const char *right  = NULL;
 371   MatchNode *mnode = (MatchNode*)_internalMatch[internalName];
 372   if (mnode-&gt;_rChild) {
 373     mnode = mnode-&gt;_rChild;
 374     right = mnode-&gt;_internalop ? mnode-&gt;_internalop : mnode-&gt;_opType;
 375   }
 376   return right;
 377 }
 378 
 379 
 380 //------------------------------check_optype-----------------------------------
 381 void ArchDesc::check_optype(MatchRule *mrule) {
 382   MatchRule *rule = mrule;
 383 
 384   //   !!!!!
 385   //   // Cycle through the list of match rules
 386   //   while(mrule) {
 387   //     // Check for a filled in type field
 388   //     if (mrule-&gt;_opType == NULL) {
 389   //     const Form  *form    = operands[_result];
 390   //     OpClassForm *opcForm = form ? form-&gt;is_opclass() : NULL;
 391   //     assert(opcForm != NULL, &quot;Match Rule contains invalid operand name.&quot;);
 392   //     }
 393   //     char *opType = opcForm-&gt;_ident;
 394   //   }
 395 }
 396 
 397 //------------------------------add_chain_rule_entry--------------------------
 398 void ArchDesc::add_chain_rule_entry(const char *src, const char *cost,
 399                                     const char *result) {
 400   // Look-up the operation in chain rule table
 401   ChainList *lst = (ChainList *)_chainRules[src];
 402   if (lst == NULL) {
 403     lst = new ChainList();
 404     _chainRules.Insert(src, lst);
 405   }
 406   if (!lst-&gt;search(result)) {
 407     if (cost == NULL) {
 408       cost = ((AttributeForm*)_globalNames[AttributeForm::_op_cost])-&gt;_attrdef;
 409     }
 410     lst-&gt;insert(result, cost, result);
 411   }
 412 }
 413 
 414 //------------------------------build_chain_rule-------------------------------
 415 void ArchDesc::build_chain_rule(OperandForm *oper) {
 416   MatchRule     *rule;
 417 
 418   // Check for chain rules here
 419   // If this is only a chain rule
 420   if ((oper-&gt;_matrule) &amp;&amp; (oper-&gt;_matrule-&gt;_lChild == NULL) &amp;&amp;
 421       (oper-&gt;_matrule-&gt;_rChild == NULL)) {
 422 
 423     {
 424       const Form *form = _globalNames[oper-&gt;_matrule-&gt;_opType];
 425       if ((form) &amp;&amp; form-&gt;is_operand() &amp;&amp;
 426           (form-&gt;ideal_only() == false)) {
 427         add_chain_rule_entry(oper-&gt;_matrule-&gt;_opType, oper-&gt;cost(), oper-&gt;_ident);
 428       }
 429     }
 430     // Check for additional chain rules
 431     if (oper-&gt;_matrule-&gt;_next) {
 432       rule = oper-&gt;_matrule;
 433       do {
 434         rule = rule-&gt;_next;
 435         // Any extra match rules after the first must be chain rules
 436         const Form *form = _globalNames[rule-&gt;_opType];
 437         if ((form) &amp;&amp; form-&gt;is_operand() &amp;&amp;
 438             (form-&gt;ideal_only() == false)) {
 439           add_chain_rule_entry(rule-&gt;_opType, oper-&gt;cost(), oper-&gt;_ident);
 440         }
 441       } while(rule-&gt;_next != NULL);
 442     }
 443   }
 444   else if ((oper-&gt;_matrule) &amp;&amp; (oper-&gt;_matrule-&gt;_next)) {
 445     // Regardles of whether the first matchrule is a chain rule, check the list
 446     rule = oper-&gt;_matrule;
 447     do {
 448       rule = rule-&gt;_next;
 449       // Any extra match rules after the first must be chain rules
 450       const Form *form = _globalNames[rule-&gt;_opType];
 451       if ((form) &amp;&amp; form-&gt;is_operand() &amp;&amp;
 452           (form-&gt;ideal_only() == false)) {
 453         assert( oper-&gt;cost(), &quot;This case expects NULL cost, not default cost&quot;);
 454         add_chain_rule_entry(rule-&gt;_opType, oper-&gt;cost(), oper-&gt;_ident);
 455       }
 456     } while(rule-&gt;_next != NULL);
 457   }
 458 
 459 }
 460 
 461 //------------------------------buildMatchList---------------------------------
 462 // operands and instructions provide the result
 463 void ArchDesc::buildMatchList(MatchRule *mrule, const char *resultStr,
 464                               const char *rootOp, Predicate *pred,
 465                               const char *cost) {
 466   const char *leftstr, *rightstr;
 467   MatchNode  *mnode;
 468 
 469   leftstr = rightstr = NULL;
 470   // Check for chain rule, and do not generate a match list for it
 471   if ( mrule-&gt;is_chain_rule(_globalNames) ) {
 472     return;
 473   }
 474 
 475   // Identify index position among ideal operands
 476   intptr_t    index     = _last_opcode;
 477   const char  *indexStr  = getMatchListIndex(*mrule);
 478   index  = (intptr_t)_idealIndex[indexStr];
 479   if (index == 0) {
 480     fprintf(stderr, &quot;Ideal node missing: %s\n&quot;, indexStr);
 481     assert(index != 0, &quot;Failed lookup of ideal node\n&quot;);
 482   }
 483 
 484   // Check that this will be placed appropriately in the DFA
 485   if (index &gt;= _last_opcode) {
 486     fprintf(stderr, &quot;Invalid match rule %s &lt;-- ( %s )\n&quot;,
 487             resultStr ? resultStr : &quot; &quot;,
 488             rootOp    ? rootOp    : &quot; &quot;);
 489     assert(index &lt; _last_opcode, &quot;Matching item not in ideal graph\n&quot;);
 490     return;
 491   }
 492 
 493 
 494   // Walk the MatchRule, generating MatchList entries for each level
 495   // of the rule (each nesting of parentheses)
 496   // Check for &quot;Set&quot;
 497   if (!strcmp(mrule-&gt;_opType, &quot;Set&quot;)) {
 498     mnode = mrule-&gt;_rChild;
 499     buildMList(mnode, rootOp, resultStr, pred, cost);
 500     return;
 501   }
 502   // Build MatchLists for children
 503   // Check each child for an internal operand name, and use that name
 504   // for the parent&#39;s matchlist entry if it exists
 505   mnode = mrule-&gt;_lChild;
 506   if (mnode) {
 507     buildMList(mnode, NULL, NULL, NULL, NULL);
 508     leftstr = mnode-&gt;_internalop ? mnode-&gt;_internalop : mnode-&gt;_opType;
 509   }
 510   mnode = mrule-&gt;_rChild;
 511   if (mnode) {
 512     buildMList(mnode, NULL, NULL, NULL, NULL);
 513     rightstr = mnode-&gt;_internalop ? mnode-&gt;_internalop : mnode-&gt;_opType;
 514   }
 515   // Search for an identical matchlist entry already on the list
 516   if ((_mlistab[index] == NULL) ||
 517       (_mlistab[index] &amp;&amp;
 518        !_mlistab[index]-&gt;search(rootOp, resultStr, leftstr, rightstr, pred))) {
 519     // Place this match rule at front of list
 520     MatchList *mList =
 521       new MatchList(_mlistab[index], pred, cost,
 522                     rootOp, resultStr, leftstr, rightstr);
 523     _mlistab[index] = mList;
 524   }
 525 }
 526 
 527 // Recursive call for construction of match lists
 528 void ArchDesc::buildMList(MatchNode *node, const char *rootOp,
 529                           const char *resultOp, Predicate *pred,
 530                           const char *cost) {
 531   const char *leftstr, *rightstr;
 532   const char *resultop;
 533   const char *opcode;
 534   MatchNode  *mnode;
 535   Form       *form;
 536 
 537   leftstr = rightstr = NULL;
 538   // Do not process leaves of the Match Tree if they are not ideal
 539   if ((node) &amp;&amp; (node-&gt;_lChild == NULL) &amp;&amp; (node-&gt;_rChild == NULL) &amp;&amp;
 540       ((form = (Form *)_globalNames[node-&gt;_opType]) != NULL) &amp;&amp;
 541       (!form-&gt;ideal_only())) {
 542     return;
 543   }
 544 
 545   // Identify index position among ideal operands
 546   intptr_t index = _last_opcode;
 547   const char *indexStr = node ? node-&gt;_opType : (char *) &quot; &quot;;
 548   index = (intptr_t)_idealIndex[indexStr];
 549   if (index == 0) {
 550     fprintf(stderr, &quot;error: operand \&quot;%s\&quot; not found\n&quot;, indexStr);
 551     assert(0, &quot;fatal error&quot;);
 552   }
 553 
 554   if (node == NULL) {
 555     fprintf(stderr, &quot;error: node is NULL\n&quot;);
 556     assert(0, &quot;fatal error&quot;);
 557   }
 558   // Build MatchLists for children
 559   // Check each child for an internal operand name, and use that name
 560   // for the parent&#39;s matchlist entry if it exists
 561   mnode = node-&gt;_lChild;
 562   if (mnode) {
 563     buildMList(mnode, NULL, NULL, NULL, NULL);
 564     leftstr = mnode-&gt;_internalop ? mnode-&gt;_internalop : mnode-&gt;_opType;
 565   }
 566   mnode = node-&gt;_rChild;
 567   if (mnode) {
 568     buildMList(mnode, NULL, NULL, NULL, NULL);
 569     rightstr = mnode-&gt;_internalop ? mnode-&gt;_internalop : mnode-&gt;_opType;
 570   }
 571   // Grab the string for the opcode of this list entry
 572   if (rootOp == NULL) {
 573     opcode = (node-&gt;_internalop) ? node-&gt;_internalop : node-&gt;_opType;
 574   } else {
 575     opcode = rootOp;
 576   }
 577   // Grab the string for the result of this list entry
 578   if (resultOp == NULL) {
 579     resultop = (node-&gt;_internalop) ? node-&gt;_internalop : node-&gt;_opType;
 580   }
 581   else resultop = resultOp;
 582   // Search for an identical matchlist entry already on the list
 583   if ((_mlistab[index] == NULL) || (_mlistab[index] &amp;&amp;
 584                                     !_mlistab[index]-&gt;search(opcode, resultop, leftstr, rightstr, pred))) {
 585     // Place this match rule at front of list
 586     MatchList *mList =
 587       new MatchList(_mlistab[index],pred,cost,
 588                     opcode, resultop, leftstr, rightstr);
 589     _mlistab[index] = mList;
 590   }
 591 }
 592 
 593 // Count number of OperandForms defined
 594 int  ArchDesc::operandFormCount() {
 595   // Only interested in ones with non-NULL match rule
 596   int  count = 0; _operands.reset();
 597   OperandForm *cur;
 598   for( ; (cur = (OperandForm*)_operands.iter()) != NULL; ) {
 599     if (cur-&gt;_matrule != NULL) ++count;
 600   };
 601   return count;
 602 }
 603 
 604 // Count number of OpClassForms defined
 605 int  ArchDesc::opclassFormCount() {
 606   // Only interested in ones with non-NULL match rule
 607   int  count = 0; _operands.reset();
 608   OpClassForm *cur;
 609   for( ; (cur = (OpClassForm*)_opclass.iter()) != NULL; ) {
 610     ++count;
 611   };
 612   return count;
 613 }
 614 
 615 // Count number of InstructForms defined
 616 int  ArchDesc::instructFormCount() {
 617   // Only interested in ones with non-NULL match rule
 618   int  count = 0; _instructions.reset();
 619   InstructForm *cur;
 620   for( ; (cur = (InstructForm*)_instructions.iter()) != NULL; ) {
 621     if (cur-&gt;_matrule != NULL) ++count;
 622   };
 623   return count;
 624 }
 625 
 626 
 627 //------------------------------get_preproc_def--------------------------------
 628 // Return the textual binding for a given CPP flag name.
 629 // Return NULL if there is no binding, or it has been #undef-ed.
 630 char* ArchDesc::get_preproc_def(const char* flag) {
 631   // In case of syntax errors, flag may take the value NULL.
 632   SourceForm* deff = NULL;
 633   if (flag != NULL)
 634     deff = (SourceForm*) _preproc_table[flag];
 635   return (deff == NULL) ? NULL : deff-&gt;_code;
 636 }
 637 
 638 
 639 //------------------------------set_preproc_def--------------------------------
 640 // Change or create a textual binding for a given CPP flag name.
 641 // Giving NULL means the flag name is to be #undef-ed.
 642 // In any case, _preproc_list collects all names either #defined or #undef-ed.
 643 void ArchDesc::set_preproc_def(const char* flag, const char* def) {
 644   SourceForm* deff = (SourceForm*) _preproc_table[flag];
 645   if (deff == NULL) {
 646     deff = new SourceForm(NULL);
 647     _preproc_table.Insert(flag, deff);
 648     _preproc_list.addName(flag);   // this supports iteration
 649   }
 650   deff-&gt;_code = (char*) def;
 651 }
 652 
 653 
 654 bool ArchDesc::verify() {
 655 
 656   if (_register)
 657     assert( _register-&gt;verify(), &quot;Register declarations failed verification&quot;);
 658   if (!_quiet_mode)
 659     fprintf(stderr,&quot;\n&quot;);
 660   // fprintf(stderr,&quot;---------------------------- Verify Operands ---------------\n&quot;);
 661   // _operands.verify();
 662   // fprintf(stderr,&quot;\n&quot;);
 663   // fprintf(stderr,&quot;---------------------------- Verify Operand Classes --------\n&quot;);
 664   // _opclass.verify();
 665   // fprintf(stderr,&quot;\n&quot;);
 666   // fprintf(stderr,&quot;---------------------------- Verify Attributes  ------------\n&quot;);
 667   // _attributes.verify();
 668   // fprintf(stderr,&quot;\n&quot;);
 669   if (!_quiet_mode)
 670     fprintf(stderr,&quot;---------------------------- Verify Instructions ----------------------------\n&quot;);
 671   _instructions.verify();
 672   if (!_quiet_mode)
 673     fprintf(stderr,&quot;\n&quot;);
 674   // if ( _encode ) {
 675   //   fprintf(stderr,&quot;---------------------------- Verify Encodings --------------\n&quot;);
 676   //   _encode-&gt;verify();
 677   // }
 678 
 679   //if (_pipeline) _pipeline-&gt;verify();
 680 
 681   return true;
 682 }
 683 
 684 
 685 void ArchDesc::dump() {
 686   _pre_header.dump();
 687   _header.dump();
 688   _source.dump();
 689   if (_register) _register-&gt;dump();
 690   fprintf(stderr,&quot;\n&quot;);
 691   fprintf(stderr,&quot;------------------ Dump Operands ---------------------\n&quot;);
 692   _operands.dump();
 693   fprintf(stderr,&quot;\n&quot;);
 694   fprintf(stderr,&quot;------------------ Dump Operand Classes --------------\n&quot;);
 695   _opclass.dump();
 696   fprintf(stderr,&quot;\n&quot;);
 697   fprintf(stderr,&quot;------------------ Dump Attributes  ------------------\n&quot;);
 698   _attributes.dump();
 699   fprintf(stderr,&quot;\n&quot;);
 700   fprintf(stderr,&quot;------------------ Dump Instructions -----------------\n&quot;);
 701   _instructions.dump();
 702   if ( _encode ) {
 703     fprintf(stderr,&quot;------------------ Dump Encodings --------------------\n&quot;);
 704     _encode-&gt;dump();
 705   }
 706   if (_pipeline) _pipeline-&gt;dump();
 707 }
 708 
 709 
 710 //------------------------------init_keywords----------------------------------
 711 // Load the kewords into the global name table
 712 void ArchDesc::initKeywords(FormDict&amp; names) {
 713   // Insert keyword strings into Global Name Table.  Keywords have a NULL value
 714   // field for quick easy identification when checking identifiers.
 715   names.Insert(&quot;instruct&quot;, NULL);
 716   names.Insert(&quot;operand&quot;, NULL);
 717   names.Insert(&quot;attribute&quot;, NULL);
 718   names.Insert(&quot;source&quot;, NULL);
 719   names.Insert(&quot;register&quot;, NULL);
 720   names.Insert(&quot;pipeline&quot;, NULL);
 721   names.Insert(&quot;constraint&quot;, NULL);
 722   names.Insert(&quot;predicate&quot;, NULL);
 723   names.Insert(&quot;encode&quot;, NULL);
 724   names.Insert(&quot;enc_class&quot;, NULL);
 725   names.Insert(&quot;interface&quot;, NULL);
 726   names.Insert(&quot;opcode&quot;, NULL);
 727   names.Insert(&quot;ins_encode&quot;, NULL);
 728   names.Insert(&quot;match&quot;, NULL);
 729   names.Insert(&quot;effect&quot;, NULL);
 730   names.Insert(&quot;expand&quot;, NULL);
 731   names.Insert(&quot;rewrite&quot;, NULL);
 732   names.Insert(&quot;reg_def&quot;, NULL);
 733   names.Insert(&quot;reg_class&quot;, NULL);
 734   names.Insert(&quot;alloc_class&quot;, NULL);
 735   names.Insert(&quot;resource&quot;, NULL);
 736   names.Insert(&quot;pipe_class&quot;, NULL);
 737   names.Insert(&quot;pipe_desc&quot;, NULL);
 738 }
 739 
 740 
 741 //------------------------------internal_err----------------------------------
 742 // Issue a parser error message, and skip to the end of the current line
 743 void ArchDesc::internal_err(const char *fmt, ...) {
 744   va_list args;
 745 
 746   va_start(args, fmt);
 747   _internal_errs += emit_msg(0, INTERNAL_ERR, 0, fmt, args);
 748   va_end(args);
 749 
 750   _no_output = 1;
 751 }
 752 
 753 //------------------------------syntax_err----------------------------------
 754 // Issue a parser error message, and skip to the end of the current line
 755 void ArchDesc::syntax_err(int lineno, const char *fmt, ...) {
 756   va_list args;
 757 
 758   va_start(args, fmt);
 759   _internal_errs += emit_msg(0, SYNERR, lineno, fmt, args);
 760   va_end(args);
 761 
 762   _no_output = 1;
 763 }
 764 
 765 //------------------------------emit_msg---------------------------------------
 766 // Emit a user message, typically a warning or error
 767 int ArchDesc::emit_msg(int quiet, int flag, int line, const char *fmt,
 768     va_list args) {
 769   static int  last_lineno = -1;
 770   int         i;
 771   const char *pref;
 772 
 773   switch(flag) {
 774   case 0: pref = &quot;Warning: &quot;; break;
 775   case 1: pref = &quot;Syntax Error: &quot;; break;
 776   case 2: pref = &quot;Semantic Error: &quot;; break;
 777   case 3: pref = &quot;Internal Error: &quot;; break;
 778   default: assert(0, &quot;&quot;); break;
 779   }
 780 
 781   if (line == last_lineno) return 0;
 782   last_lineno = line;
 783 
 784   if (!quiet) {                        /* no output if in quiet mode         */
 785     i = fprintf(errfile, &quot;%s(%d) &quot;, _ADL_file._name, line);
 786     while (i++ &lt;= 15)  fputc(&#39; &#39;, errfile);
 787     fprintf(errfile, &quot;%-8s:&quot;, pref);
 788     vfprintf(errfile, fmt, args);
 789     fprintf(errfile, &quot;\n&quot;);
 790     fflush(errfile);
 791   }
 792   return 1;
 793 }
 794 
 795 
 796 // ---------------------------------------------------------------------------
 797 //--------Utilities to build mappings for machine registers ------------------
 798 // ---------------------------------------------------------------------------
 799 
 800 // Construct the name of the register mask.
 801 static const char *getRegMask(const char *reg_class_name) {
 802   if( reg_class_name == NULL ) return &quot;RegMask::Empty&quot;;
 803 
 804   if (strcmp(reg_class_name,&quot;Universe&quot;)==0) {
 805     return &quot;RegMask::Empty&quot;;
 806   } else if (strcmp(reg_class_name,&quot;stack_slots&quot;)==0) {
 807     return &quot;(Compile::current()-&gt;FIRST_STACK_mask())&quot;;
 808   } else {
 809     char       *rc_name = toUpper(reg_class_name);
 810     const char *mask    = &quot;_mask&quot;;
 811     int         length  = (int)strlen(rc_name) + (int)strlen(mask) + 5;
 812     char       *regMask = new char[length];
 813     sprintf(regMask,&quot;%s%s()&quot;, rc_name, mask);
 814     delete[] rc_name;
 815     return regMask;
 816   }
 817 }
 818 
 819 // Convert a register class name to its register mask.
 820 const char *ArchDesc::reg_class_to_reg_mask(const char *rc_name) {
 821   const char *reg_mask = &quot;RegMask::Empty&quot;;
 822 
 823   if( _register ) {
 824     RegClass *reg_class  = _register-&gt;getRegClass(rc_name);
 825     if (reg_class == NULL) {
 826       syntax_err(0, &quot;Use of an undefined register class %s&quot;, rc_name);
 827       return reg_mask;
 828     }
 829 
 830     // Construct the name of the register mask.
 831     reg_mask = getRegMask(rc_name);
 832   }
 833 
 834   return reg_mask;
 835 }
 836 
 837 
 838 // Obtain the name of the RegMask for an OperandForm
 839 const char *ArchDesc::reg_mask(OperandForm  &amp;opForm) {
 840   const char *regMask      = &quot;RegMask::Empty&quot;;
 841 
 842   // Check constraints on result&#39;s register class
 843   const char *result_class = opForm.constrained_reg_class();
 844   if (result_class == NULL) {
 845     opForm.dump();
 846     syntax_err(opForm._linenum,
 847                &quot;Use of an undefined result class for operand: %s&quot;,
 848                opForm._ident);
 849     abort();
 850   }
 851 
 852   regMask = reg_class_to_reg_mask( result_class );
 853 
 854   return regMask;
 855 }
 856 
 857 // Obtain the name of the RegMask for an InstructForm
 858 const char *ArchDesc::reg_mask(InstructForm &amp;inForm) {
 859   const char *result = inForm.reduce_result();
 860 
 861   if (result == NULL) {
 862     syntax_err(inForm._linenum,
 863                &quot;Did not find result operand or RegMask&quot;
 864                &quot; for this instruction: %s&quot;,
 865                inForm._ident);
 866     abort();
 867   }
 868 
 869   // Instructions producing &#39;Universe&#39; use RegMask::Empty
 870   if( strcmp(result,&quot;Universe&quot;)==0 ) {
 871     return &quot;RegMask::Empty&quot;;
 872   }
 873 
 874   // Lookup this result operand and get its register class
 875   Form *form = (Form*)_globalNames[result];
 876   if (form == NULL) {
 877     syntax_err(inForm._linenum,
 878                &quot;Did not find result operand for result: %s&quot;, result);
 879     abort();
 880   }
 881   OperandForm *oper = form-&gt;is_operand();
 882   if (oper == NULL) {
 883     syntax_err(inForm._linenum, &quot;Form is not an OperandForm:&quot;);
 884     form-&gt;dump();
 885     abort();
 886   }
 887   return reg_mask( *oper );
 888 }
 889 
 890 
 891 // Obtain the STACK_OR_reg_mask name for an OperandForm
 892 char *ArchDesc::stack_or_reg_mask(OperandForm  &amp;opForm) {
 893   // name of cisc_spillable version
 894   const char *reg_mask_name = reg_mask(opForm);
 895 
 896   if (reg_mask_name == NULL) {
 897      syntax_err(opForm._linenum,
 898                 &quot;Did not find reg_mask for opForm: %s&quot;,
 899                 opForm._ident);
 900      abort();
 901   }
 902 
 903   const char *stack_or = &quot;STACK_OR_&quot;;
 904   int   length         = (int)strlen(stack_or) + (int)strlen(reg_mask_name) + 1;
 905   char *result         = new char[length];
 906   sprintf(result,&quot;%s%s&quot;, stack_or, reg_mask_name);
 907 
 908   return result;
 909 }
 910 
 911 // Record that the register class must generate a stack_or_reg_mask
 912 void ArchDesc::set_stack_or_reg(const char *reg_class_name) {
 913   if( _register ) {
 914     RegClass *reg_class  = _register-&gt;getRegClass(reg_class_name);
 915     reg_class-&gt;set_stack_version(true);
 916   }
 917 }
 918 
 919 
 920 // Return the type signature for the ideal operation
 921 const char *ArchDesc::getIdealType(const char *idealOp) {
 922   // Find last character in idealOp, it specifies the type
 923   char  last_char = 0;
 924   const char *ptr = idealOp;
 925   for (; *ptr != &#39;\0&#39;; ++ptr) {
 926     last_char = *ptr;
 927   }
 928 
 929   // Match Vector types.
 930   if (strncmp(idealOp, &quot;Vec&quot;,3)==0) {
 931     switch(last_char) {
 932     case &#39;S&#39;:  return &quot;TypeVect::VECTS&quot;;
 933     case &#39;D&#39;:  return &quot;TypeVect::VECTD&quot;;
 934     case &#39;X&#39;:  return &quot;TypeVect::VECTX&quot;;
 935     case &#39;Y&#39;:  return &quot;TypeVect::VECTY&quot;;
 936     case &#39;Z&#39;:  return &quot;TypeVect::VECTZ&quot;;
 937     default:
 938       internal_err(&quot;Vector type %s with unrecognized type\n&quot;,idealOp);
 939     }
 940   }
 941 
 942   // !!!!!
 943   switch(last_char) {
 944   case &#39;I&#39;:    return &quot;TypeInt::INT&quot;;
 945   case &#39;P&#39;:    return &quot;TypePtr::BOTTOM&quot;;
 946   case &#39;N&#39;:    return &quot;TypeNarrowOop::BOTTOM&quot;;
 947   case &#39;F&#39;:    return &quot;Type::FLOAT&quot;;
 948   case &#39;D&#39;:    return &quot;Type::DOUBLE&quot;;
 949   case &#39;L&#39;:    return &quot;TypeLong::LONG&quot;;
 950   case &#39;s&#39;:    return &quot;TypeInt::CC /*flags*/&quot;;
 951   default:
 952     return NULL;
 953     // !!!!!
 954     // internal_err(&quot;Ideal type %s with unrecognized type\n&quot;,idealOp);
 955     break;
 956   }
 957 
 958   return NULL;
 959 }
 960 
 961 
 962 
 963 OperandForm *ArchDesc::constructOperand(const char *ident,
 964                                         bool  ideal_only) {
 965   OperandForm *opForm = new OperandForm(ident, ideal_only);
 966   _globalNames.Insert(ident, opForm);
 967   addForm(opForm);
 968 
 969   return opForm;
 970 }
 971 
 972 
 973 // Import predefined base types: Set = 1, RegI, RegP, ...
 974 void ArchDesc::initBaseOpTypes() {
 975   // Create OperandForm and assign type for each opcode.
 976   for (int i = 1; i &lt; _last_machine_leaf; ++i) {
 977     char *ident = (char *)NodeClassNames[i];
 978     constructOperand(ident, true);
 979   }
 980   // Create InstructForm and assign type for each ideal instruction.
 981   for (int j = _last_machine_leaf+1; j &lt; _last_opcode; ++j) {
 982     char *ident = (char *)NodeClassNames[j];
 983     if (!strcmp(ident, &quot;ConI&quot;) || !strcmp(ident, &quot;ConP&quot;) ||
 984         !strcmp(ident, &quot;ConN&quot;) || !strcmp(ident, &quot;ConNKlass&quot;) ||
 985         !strcmp(ident, &quot;ConF&quot;) || !strcmp(ident, &quot;ConD&quot;) ||
 986         !strcmp(ident, &quot;ConL&quot;) || !strcmp(ident, &quot;Con&quot; ) ||
 987         !strcmp(ident, &quot;Bool&quot;)) {
 988       constructOperand(ident, true);
 989     } else {
 990       InstructForm *insForm = new InstructForm(ident, true);
 991       // insForm-&gt;_opcode = nextUserOpType(ident);
 992       _globalNames.Insert(ident, insForm);
 993       addForm(insForm);
 994     }
 995   }
 996 
 997   { OperandForm *opForm;
 998   // Create operand type &quot;Universe&quot; for return instructions.
 999   const char *ident = &quot;Universe&quot;;
1000   opForm = constructOperand(ident, false);
1001 
1002   // Create operand type &quot;label&quot; for branch targets
1003   ident = &quot;label&quot;;
1004   opForm = constructOperand(ident, false);
1005 
1006   // !!!!! Update - when adding a new sReg/stackSlot type
1007   // Create operand types &quot;sReg[IPFDL]&quot; for stack slot registers
1008   opForm = constructOperand(&quot;sRegI&quot;, false);
1009   opForm-&gt;_constraint = new Constraint(&quot;ALLOC_IN_RC&quot;, &quot;stack_slots&quot;);
1010   opForm = constructOperand(&quot;sRegP&quot;, false);
1011   opForm-&gt;_constraint = new Constraint(&quot;ALLOC_IN_RC&quot;, &quot;stack_slots&quot;);
1012   opForm = constructOperand(&quot;sRegF&quot;, false);
1013   opForm-&gt;_constraint = new Constraint(&quot;ALLOC_IN_RC&quot;, &quot;stack_slots&quot;);
1014   opForm = constructOperand(&quot;sRegD&quot;, false);
1015   opForm-&gt;_constraint = new Constraint(&quot;ALLOC_IN_RC&quot;, &quot;stack_slots&quot;);
1016   opForm = constructOperand(&quot;sRegL&quot;, false);
1017   opForm-&gt;_constraint = new Constraint(&quot;ALLOC_IN_RC&quot;, &quot;stack_slots&quot;);
1018 
1019   // Create operand type &quot;method&quot; for call targets
1020   ident = &quot;method&quot;;
1021   opForm = constructOperand(ident, false);
1022   }
1023 
1024   // Create Effect Forms for each of the legal effects
1025   // USE, DEF, USE_DEF, KILL, USE_KILL
1026   {
1027     const char *ident = &quot;USE&quot;;
1028     Effect     *eForm = new Effect(ident);
1029     _globalNames.Insert(ident, eForm);
1030     ident = &quot;DEF&quot;;
1031     eForm = new Effect(ident);
1032     _globalNames.Insert(ident, eForm);
1033     ident = &quot;USE_DEF&quot;;
1034     eForm = new Effect(ident);
1035     _globalNames.Insert(ident, eForm);
1036     ident = &quot;KILL&quot;;
1037     eForm = new Effect(ident);
1038     _globalNames.Insert(ident, eForm);
1039     ident = &quot;USE_KILL&quot;;
1040     eForm = new Effect(ident);
1041     _globalNames.Insert(ident, eForm);
1042     ident = &quot;TEMP&quot;;
1043     eForm = new Effect(ident);
1044     _globalNames.Insert(ident, eForm);
1045     ident = &quot;TEMP_DEF&quot;;
1046     eForm = new Effect(ident);
1047     _globalNames.Insert(ident, eForm);
1048     ident = &quot;CALL&quot;;
1049     eForm = new Effect(ident);
1050     _globalNames.Insert(ident, eForm);
1051   }
1052 
1053   //
1054   // Build mapping from ideal names to ideal indices
1055   int idealIndex = 0;
1056   for (idealIndex = 1; idealIndex &lt; _last_machine_leaf; ++idealIndex) {
1057     const char *idealName = NodeClassNames[idealIndex];
1058     _idealIndex.Insert((void*) idealName, (void*) (intptr_t) idealIndex);
1059   }
1060   for (idealIndex = _last_machine_leaf+1;
1061        idealIndex &lt; _last_opcode; ++idealIndex) {
1062     const char *idealName = NodeClassNames[idealIndex];
1063     _idealIndex.Insert((void*) idealName, (void*) (intptr_t) idealIndex);
1064   }
1065 
1066 }
1067 
1068 
1069 //---------------------------addSUNcopyright-------------------------------
1070 // output SUN copyright info
1071 void ArchDesc::addSunCopyright(char* legal, int size, FILE *fp) {
1072   size_t count = fwrite(legal, 1, size, fp);
1073   assert(count == (size_t) size, &quot;copyright info truncated&quot;);
1074   fprintf(fp,&quot;\n&quot;);
1075   fprintf(fp,&quot;// Machine Generated File.  Do Not Edit!\n&quot;);
1076   fprintf(fp,&quot;\n&quot;);
1077 }
1078 
1079 
1080 //---------------------------addIncludeGuardStart--------------------------
1081 // output the start of an include guard.
1082 void ArchDesc::addIncludeGuardStart(ADLFILE &amp;adlfile, const char* guardString) {
1083   // Build #include lines
1084   fprintf(adlfile._fp, &quot;\n&quot;);
1085   fprintf(adlfile._fp, &quot;#ifndef %s\n&quot;, guardString);
1086   fprintf(adlfile._fp, &quot;#define %s\n&quot;, guardString);
1087   fprintf(adlfile._fp, &quot;\n&quot;);
1088 
1089 }
1090 
1091 //---------------------------addIncludeGuardEnd--------------------------
1092 // output the end of an include guard.
1093 void ArchDesc::addIncludeGuardEnd(ADLFILE &amp;adlfile, const char* guardString) {
1094   // Build #include lines
1095   fprintf(adlfile._fp, &quot;\n&quot;);
1096   fprintf(adlfile._fp, &quot;#endif // %s\n&quot;, guardString);
1097 
1098 }
1099 
1100 //---------------------------addInclude--------------------------
1101 // output the #include line for this file.
1102 void ArchDesc::addInclude(ADLFILE &amp;adlfile, const char* fileName) {
1103   fprintf(adlfile._fp, &quot;#include \&quot;%s\&quot;\n&quot;, fileName);
1104 
1105 }
1106 
1107 void ArchDesc::addInclude(ADLFILE &amp;adlfile, const char* includeDir, const char* fileName) {
1108   fprintf(adlfile._fp, &quot;#include \&quot;%s/%s\&quot;\n&quot;, includeDir, fileName);
1109 
1110 }
1111 
1112 //---------------------------addPreprocessorChecks-----------------------------
1113 // Output C preprocessor code to verify the backend compilation environment.
1114 // The idea is to force code produced by &quot;adlc -DHS64&quot; to be compiled by a
1115 // command of the form &quot;CC ... -DHS64 ...&quot;, so that any #ifdefs in the source
1116 // blocks select C code that is consistent with adlc&#39;s selections of AD code.
1117 void ArchDesc::addPreprocessorChecks(FILE *fp) {
1118   const char* flag;
1119   _preproc_list.reset();
1120   if (_preproc_list.count() &gt; 0 &amp;&amp; !_preproc_list.current_is_signal()) {
1121     fprintf(fp, &quot;// Check consistency of C++ compilation with ADLC options:\n&quot;);
1122   }
1123   for (_preproc_list.reset(); (flag = _preproc_list.iter()) != NULL; ) {
1124     if (_preproc_list.current_is_signal())  break;
1125     char* def = get_preproc_def(flag);
1126     fprintf(fp, &quot;// Check adlc &quot;);
1127     if (def)
1128           fprintf(fp, &quot;-D%s=%s\n&quot;, flag, def);
1129     else  fprintf(fp, &quot;-U%s\n&quot;, flag);
1130     fprintf(fp, &quot;#%s %s\n&quot;,
1131             def ? &quot;ifndef&quot; : &quot;ifdef&quot;, flag);
1132     fprintf(fp, &quot;#  error \&quot;%s %s be defined\&quot;\n&quot;,
1133             flag, def ? &quot;must&quot; : &quot;must not&quot;);
1134     fprintf(fp, &quot;#endif // %s\n&quot;, flag);
1135   }
1136 }
1137 
1138 
1139 // Convert operand name into enum name
1140 const char *ArchDesc::machOperEnum(const char *opName) {
1141   return ArchDesc::getMachOperEnum(opName);
1142 }
1143 
1144 // Convert operand name into enum name
1145 const char *ArchDesc::getMachOperEnum(const char *opName) {
1146   return (opName ? toUpper(opName) : opName);
1147 }
1148 
1149 //---------------------------buildMustCloneMap-----------------------------
1150 // Flag cases when machine needs cloned values or instructions
1151 void ArchDesc::buildMustCloneMap(FILE *fp_hpp, FILE *fp_cpp) {
1152   // Build external declarations for mappings
1153   fprintf(fp_hpp, &quot;// Mapping from machine-independent opcode to boolean\n&quot;);
1154   fprintf(fp_hpp, &quot;// Flag cases where machine needs cloned values or instructions\n&quot;);
1155   fprintf(fp_hpp, &quot;extern const char must_clone[];\n&quot;);
1156   fprintf(fp_hpp, &quot;\n&quot;);
1157 
1158   // Build mapping from ideal names to ideal indices
1159   fprintf(fp_cpp, &quot;\n&quot;);
1160   fprintf(fp_cpp, &quot;// Mapping from machine-independent opcode to boolean\n&quot;);
1161   fprintf(fp_cpp, &quot;const        char must_clone[] = {\n&quot;);
1162   for (int idealIndex = 0; idealIndex &lt; _last_opcode; ++idealIndex) {
1163     int         must_clone = 0;
1164     const char *idealName = NodeClassNames[idealIndex];
1165     // Previously selected constants for cloning
1166     // !!!!!
1167     // These are the current machine-dependent clones
1168     if ( strcmp(idealName,&quot;CmpI&quot;) == 0
1169          || strcmp(idealName,&quot;CmpU&quot;) == 0
1170          || strcmp(idealName,&quot;CmpP&quot;) == 0
1171          || strcmp(idealName,&quot;CmpN&quot;) == 0
1172          || strcmp(idealName,&quot;CmpL&quot;) == 0
1173          || strcmp(idealName,&quot;CmpUL&quot;) == 0
1174          || strcmp(idealName,&quot;CmpD&quot;) == 0
1175          || strcmp(idealName,&quot;CmpF&quot;) == 0
1176          || strcmp(idealName,&quot;FastLock&quot;) == 0
1177          || strcmp(idealName,&quot;FastUnlock&quot;) == 0
1178          || strcmp(idealName,&quot;OverflowAddI&quot;) == 0
1179          || strcmp(idealName,&quot;OverflowAddL&quot;) == 0
1180          || strcmp(idealName,&quot;OverflowSubI&quot;) == 0
1181          || strcmp(idealName,&quot;OverflowSubL&quot;) == 0
1182          || strcmp(idealName,&quot;OverflowMulI&quot;) == 0
1183          || strcmp(idealName,&quot;OverflowMulL&quot;) == 0
1184          || strcmp(idealName,&quot;Bool&quot;) == 0
1185          || strcmp(idealName,&quot;Binary&quot;) == 0 ) {
1186       // Removed ConI from the must_clone list.  CPUs that cannot use
1187       // large constants as immediates manifest the constant as an
1188       // instruction.  The must_clone flag prevents the constant from
1189       // floating up out of loops.
1190       must_clone = 1;
1191     }
1192     fprintf(fp_cpp, &quot;  %d%s // %s: %d\n&quot;, must_clone,
1193       (idealIndex != (_last_opcode - 1)) ? &quot;,&quot; : &quot; // no trailing comma&quot;,
1194       idealName, idealIndex);
1195   }
1196   // Finish defining table
1197   fprintf(fp_cpp, &quot;};\n&quot;);
1198 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/adlc/dfa.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 // DFA.CPP - Method definitions for outputting the matcher DFA from ADLC
  26 #include &quot;adlc.hpp&quot;
  27 
  28 //---------------------------Switches for debugging output---------------------
  29 static bool debug_output   = false;
  30 static bool debug_output1  = false;    // top level chain rules
  31 
  32 //---------------------------Access to internals of class State----------------
  33 static const char *sLeft   = &quot;_kids[0]&quot;;
  34 static const char *sRight  = &quot;_kids[1]&quot;;
  35 
  36 //---------------------------DFA productions-----------------------------------
  37 static const char *dfa_production           = &quot;DFA_PRODUCTION&quot;;
  38 static const char *dfa_production_set_valid = &quot;DFA_PRODUCTION__SET_VALID&quot;;
  39 
  40 //---------------------------Production State----------------------------------
  41 static const char *knownInvalid = &quot;knownInvalid&quot;;    // The result does NOT have a rule defined
  42 static const char *knownValid   = &quot;knownValid&quot;;      // The result must be produced by a rule
  43 static const char *unknownValid = &quot;unknownValid&quot;;    // Unknown (probably due to a child or predicate constraint)
  44 
  45 static const char *noConstraint  = &quot;noConstraint&quot;;   // No constraints seen so far
  46 static const char *hasConstraint = &quot;hasConstraint&quot;;  // Within the first constraint
  47 
  48 
  49 //------------------------------Production------------------------------------
  50 // Track the status of productions for a particular result
  51 class Production {
  52 public:
  53   const char *_result;
  54   const char *_constraint;
  55   const char *_valid;
  56   Expr       *_cost_lb;            // Cost lower bound for this production
  57   Expr       *_cost_ub;            // Cost upper bound for this production
  58 
  59 public:
  60   Production(const char *result, const char *constraint, const char *valid);
  61   ~Production() {};
  62 
  63   void        initialize();        // reset to be an empty container
  64 
  65   const char   *valid()  const { return _valid; }
  66   Expr       *cost_lb()  const { return (Expr *)_cost_lb;  }
  67   Expr       *cost_ub()  const { return (Expr *)_cost_ub;  }
  68 
  69   void print();
  70 };
  71 
  72 
  73 //------------------------------ProductionState--------------------------------
  74 // Track the status of all production rule results
  75 // Reset for each root opcode (e.g., Op_RegI, Op_AddI, ...)
  76 class ProductionState {
  77 private:
  78   Dict _production;    // map result of production, char*, to information or NULL
  79   const char *_constraint;
  80 
  81 public:
  82   // cmpstr does string comparisions.  hashstr computes a key.
  83   ProductionState(Arena *arena) : _production(cmpstr, hashstr, arena) { initialize(); };
  84   ~ProductionState() { };
  85 
  86   void        initialize();                // reset local and dictionary state
  87 
  88   const char *constraint();
  89   void    set_constraint(const char *constraint); // currently working inside of constraints
  90 
  91   const char *valid(const char *result);   // unknownValid, or status for this production
  92   void    set_valid(const char *result);   // if not constrained, set status to knownValid
  93 
  94   Expr           *cost_lb(const char *result);
  95   Expr           *cost_ub(const char *result);
  96   void    set_cost_bounds(const char *result, const Expr *cost, bool has_state_check, bool has_cost_check);
  97 
  98   // Return the Production associated with the result,
  99   // or create a new Production and insert it into the dictionary.
 100   Production *getProduction(const char *result);
 101 
 102   void print();
 103 
 104 private:
 105     // Disable public use of constructor, copy-ctor,  ...
 106   ProductionState( )                         : _production(cmpstr, hashstr, Form::arena) {  assert( false, &quot;NotImplemented&quot;);  };
 107   ProductionState( const ProductionState &amp; ) : _production(cmpstr, hashstr, Form::arena) {  assert( false, &quot;NotImplemented&quot;);  }; // Deep-copy
 108 };
 109 
 110 
 111 //---------------------------Helper Functions----------------------------------
 112 // cost_check template:
 113 // 1)      if (STATE__NOT_YET_VALID(EBXREGI) || _cost[EBXREGI] &gt; c) {
 114 // 2)        DFA_PRODUCTION__SET_VALID(EBXREGI, cmovI_memu_rule, c)
 115 // 3)      }
 116 //
 117 static void cost_check(FILE *fp, const char *spaces,
 118                        const char *arrayIdx, const Expr *cost, const char *rule, ProductionState &amp;status) {
 119   bool state_check               = false;  // true if this production needs to check validity
 120   bool cost_check                = false;  // true if this production needs to check cost
 121   bool cost_is_above_upper_bound = false;  // true if this production is unnecessary due to high cost
 122   bool cost_is_below_lower_bound = false;  // true if this production replaces a higher cost production
 123 
 124   // Get information about this production
 125   const Expr *previous_ub = status.cost_ub(arrayIdx);
 126   if( !previous_ub-&gt;is_unknown() ) {
 127     if( previous_ub-&gt;less_than_or_equal(cost) ) {
 128       cost_is_above_upper_bound = true;
 129       if( debug_output ) { fprintf(fp, &quot;// Previous rule with lower cost than: %s === %s_rule costs %s\n&quot;, arrayIdx, rule, cost-&gt;as_string()); }
 130     }
 131   }
 132 
 133   const Expr *previous_lb = status.cost_lb(arrayIdx);
 134   if( !previous_lb-&gt;is_unknown() ) {
 135     if( cost-&gt;less_than_or_equal(previous_lb) ) {
 136       cost_is_below_lower_bound = true;
 137       if( debug_output ) { fprintf(fp, &quot;// Previous rule with higher cost\n&quot;); }
 138     }
 139   }
 140 
 141   // line 1)
 142   // Check for validity and compare to other match costs
 143   const char *validity_check = status.valid(arrayIdx);
 144   if( validity_check == unknownValid ) {
 145     fprintf(fp, &quot;%sif (STATE__NOT_YET_VALID(%s) || _cost[%s] &gt; %s) {\n&quot;,  spaces, arrayIdx, arrayIdx, cost-&gt;as_string());
 146     state_check = true;
 147     cost_check  = true;
 148   }
 149   else if( validity_check == knownInvalid ) {
 150     if( debug_output ) { fprintf(fp, &quot;%s// %s KNOWN_INVALID \n&quot;,  spaces, arrayIdx); }
 151   }
 152   else if( validity_check == knownValid ) {
 153     if( cost_is_above_upper_bound ) {
 154       // production cost is known to be too high.
 155       return;
 156     } else if( cost_is_below_lower_bound ) {
 157       // production will unconditionally overwrite a previous production that had higher cost
 158     } else {
 159       fprintf(fp, &quot;%sif ( /* %s KNOWN_VALID || */ _cost[%s] &gt; %s) {\n&quot;,  spaces, arrayIdx, arrayIdx, cost-&gt;as_string());
 160       cost_check  = true;
 161     }
 162   }
 163 
 164   // line 2)
 165   // no need to set State vector if our state is knownValid
 166   const char *production = (validity_check == knownValid) ? dfa_production : dfa_production_set_valid;
 167   fprintf(fp, &quot;%s  %s(%s, %s_rule, %s)&quot;, spaces, production, arrayIdx, rule, cost-&gt;as_string() );
 168   if( validity_check == knownValid ) {
 169     if( cost_is_below_lower_bound ) { fprintf(fp, &quot;\t  // overwrites higher cost rule&quot;); }
 170    }
 171    fprintf(fp, &quot;\n&quot;);
 172 
 173   // line 3)
 174   if( cost_check || state_check ) {
 175     fprintf(fp, &quot;%s}\n&quot;, spaces);
 176   }
 177 
 178   status.set_cost_bounds(arrayIdx, cost, state_check, cost_check);
 179 
 180   // Update ProductionState
 181   if( validity_check != knownValid ) {
 182     // set State vector if not previously known
 183     status.set_valid(arrayIdx);
 184   }
 185 }
 186 
 187 
 188 //---------------------------child_test----------------------------------------
 189 // Example:
 190 //   STATE__VALID_CHILD(_kids[0], FOO) &amp;&amp;  STATE__VALID_CHILD(_kids[1], BAR)
 191 // Macro equivalent to: _kids[0]-&gt;valid(FOO) &amp;&amp; _kids[1]-&gt;valid(BAR)
 192 //
 193 static void child_test(FILE *fp, MatchList &amp;mList) {
 194   if (mList._lchild) { // If left child, check it
 195     const char* lchild_to_upper = ArchDesc::getMachOperEnum(mList._lchild);
 196     fprintf(fp, &quot;STATE__VALID_CHILD(_kids[0], %s)&quot;, lchild_to_upper);
 197     delete[] lchild_to_upper;
 198   }
 199   if (mList._lchild &amp;&amp; mList._rchild) { // If both, add the &quot;&amp;&amp;&quot;
 200     fprintf(fp, &quot; &amp;&amp; &quot;);
 201   }
 202   if (mList._rchild) { // If right child, check it
 203     const char* rchild_to_upper = ArchDesc::getMachOperEnum(mList._rchild);
 204     fprintf(fp, &quot;STATE__VALID_CHILD(_kids[1], %s)&quot;, rchild_to_upper);
 205     delete[] rchild_to_upper;
 206   }
 207 }
 208 
 209 //---------------------------calc_cost-----------------------------------------
 210 // Example:
 211 //           unsigned int c = _kids[0]-&gt;_cost[FOO] + _kids[1]-&gt;_cost[BAR] + 5;
 212 //
 213 Expr *ArchDesc::calc_cost(FILE *fp, const char *spaces, MatchList &amp;mList, ProductionState &amp;status) {
 214   fprintf(fp, &quot;%sunsigned int c = &quot;, spaces);
 215   Expr *c = new Expr(&quot;0&quot;);
 216   if (mList._lchild) { // If left child, add it in
 217     const char* lchild_to_upper = ArchDesc::getMachOperEnum(mList._lchild);
 218     sprintf(Expr::buffer(), &quot;_kids[0]-&gt;_cost[%s]&quot;, lchild_to_upper);
 219     c-&gt;add(Expr::buffer());
 220     delete[] lchild_to_upper;
 221 }
 222   if (mList._rchild) { // If right child, add it in
 223     const char* rchild_to_upper = ArchDesc::getMachOperEnum(mList._rchild);
 224     sprintf(Expr::buffer(), &quot;_kids[1]-&gt;_cost[%s]&quot;, rchild_to_upper);
 225     c-&gt;add(Expr::buffer());
 226     delete[] rchild_to_upper;
 227   }
 228   // Add in cost of this rule
 229   const char *mList_cost = mList.get_cost();
 230   c-&gt;add(mList_cost, *this);
 231 
 232   fprintf(fp, &quot;%s;\n&quot;, c-&gt;as_string());
 233   c-&gt;set_external_name(&quot;c&quot;);
 234   return c;
 235 }
 236 
 237 
 238 //---------------------------gen_match-----------------------------------------
 239 void ArchDesc::gen_match(FILE *fp, MatchList &amp;mList, ProductionState &amp;status, Dict &amp;operands_chained_from) {
 240   const char *spaces4 = &quot;    &quot;;
 241   const char *spaces6 = &quot;      &quot;;
 242 
 243   fprintf(fp, &quot;%s&quot;, spaces4);
 244   // Only generate child tests if this is not a leaf node
 245   bool has_child_constraints = mList._lchild || mList._rchild;
 246   const char *predicate_test = mList.get_pred();
 247   if (has_child_constraints || predicate_test) {
 248     // Open the child-and-predicate-test braces
 249     fprintf(fp, &quot;if( &quot;);
 250     status.set_constraint(hasConstraint);
 251     child_test(fp, mList);
 252     // Only generate predicate test if one exists for this match
 253     if (predicate_test) {
 254       if (has_child_constraints) {
 255         fprintf(fp,&quot; &amp;&amp;\n&quot;);
 256       }
 257       fprintf(fp, &quot;%s  %s&quot;, spaces6, predicate_test);
 258     }
 259     // End of outer tests
 260     fprintf(fp,&quot; ) &quot;);
 261   } else {
 262     // No child or predicate test needed
 263     status.set_constraint(noConstraint);
 264   }
 265 
 266   // End of outer tests
 267   fprintf(fp,&quot;{\n&quot;);
 268 
 269   // Calculate cost of this match
 270   const Expr *cost = calc_cost(fp, spaces6, mList, status);
 271   // Check against other match costs, and update cost &amp; rule vectors
 272   cost_check(fp, spaces6, ArchDesc::getMachOperEnum(mList._resultStr), cost, mList._opcode, status);
 273 
 274   // If this is a member of an operand class, update the class cost &amp; rule
 275   expand_opclass( fp, spaces6, cost, mList._resultStr, status);
 276 
 277   // Check if this rule should be used to generate the chains as well.
 278   const char *rule = /* set rule to &quot;Invalid&quot; for internal operands */
 279     strcmp(mList._opcode,mList._resultStr) ? mList._opcode : &quot;Invalid&quot;;
 280 
 281   // If this rule produces an operand which has associated chain rules,
 282   // update the operands with the chain rule + this rule cost &amp; this rule.
 283   chain_rule(fp, spaces6, mList._resultStr, cost, rule, operands_chained_from, status);
 284 
 285   // Close the child-and-predicate-test braces
 286   fprintf(fp, &quot;    }\n&quot;);
 287 
 288 }
 289 
 290 
 291 //---------------------------expand_opclass------------------------------------
 292 // Chain from one result_type to all other members of its operand class
 293 void ArchDesc::expand_opclass(FILE *fp, const char *indent, const Expr *cost,
 294                               const char *result_type, ProductionState &amp;status) {
 295   const Form *form = _globalNames[result_type];
 296   OperandForm *op = form ? form-&gt;is_operand() : NULL;
 297   if( op &amp;&amp; op-&gt;_classes.count() &gt; 0 ) {
 298     if( debug_output ) { fprintf(fp, &quot;// expand operand classes for operand: %s \n&quot;, (char *)op-&gt;_ident  ); } // %%%%% Explanation
 299     // Iterate through all operand classes which include this operand
 300     op-&gt;_classes.reset();
 301     const char *oclass;
 302     // Expr *cCost = new Expr(cost);
 303     while( (oclass = op-&gt;_classes.iter()) != NULL )
 304       // Check against other match costs, and update cost &amp; rule vectors
 305       cost_check(fp, indent, ArchDesc::getMachOperEnum(oclass), cost, result_type, status);
 306   }
 307 }
 308 
 309 //---------------------------chain_rule----------------------------------------
 310 // Starting at &#39;operand&#39;, check if we know how to automatically generate other results
 311 void ArchDesc::chain_rule(FILE *fp, const char *indent, const char *operand,
 312      const Expr *icost, const char *irule, Dict &amp;operands_chained_from,  ProductionState &amp;status) {
 313 
 314   // Check if we have already generated chains from this starting point
 315   if( operands_chained_from[operand] != NULL ) {
 316     return;
 317   } else {
 318     operands_chained_from.Insert( operand, operand);
 319   }
 320   if( debug_output ) { fprintf(fp, &quot;// chain rules starting from: %s  and  %s \n&quot;, (char *)operand, (char *)irule); } // %%%%% Explanation
 321 
 322   ChainList *lst = (ChainList *)_chainRules[operand];
 323   if (lst) {
 324     // printf(&quot;\nChain from &lt;%s&gt; at cost #%s\n&quot;,operand, icost ? icost : &quot;_&quot;);
 325     const char *result, *cost, *rule;
 326     for(lst-&gt;reset(); (lst-&gt;iter(result,cost,rule)) == true; ) {
 327       // Do not generate operands that are already available
 328       if( operands_chained_from[result] != NULL ) {
 329         continue;
 330       } else {
 331         // Compute the cost for previous match + chain_rule_cost
 332         // total_cost = icost + cost;
 333         Expr *total_cost = icost-&gt;clone();  // icost + cost
 334         total_cost-&gt;add(cost, *this);
 335 
 336         // Check for transitive chain rules
 337         Form *form = (Form *)_globalNames[rule];
 338         if ( ! form-&gt;is_instruction()) {
 339           // printf(&quot;   result=%s cost=%s rule=%s\n&quot;, result, total_cost, rule);
 340           // Check against other match costs, and update cost &amp; rule vectors
 341           const char *reduce_rule = strcmp(irule,&quot;Invalid&quot;) ? irule : rule;
 342           cost_check(fp, indent, ArchDesc::getMachOperEnum(result), total_cost, reduce_rule, status);
 343           chain_rule(fp, indent, result, total_cost, irule, operands_chained_from, status);
 344         } else {
 345           // printf(&quot;   result=%s cost=%s rule=%s\n&quot;, result, total_cost, rule);
 346           // Check against other match costs, and update cost &amp; rule vectors
 347           cost_check(fp, indent, ArchDesc::getMachOperEnum(result), total_cost, rule, status);
 348           chain_rule(fp, indent, result, total_cost, rule, operands_chained_from, status);
 349         }
 350 
 351         // If this is a member of an operand class, update class cost &amp; rule
 352         expand_opclass( fp, indent, total_cost, result, status );
 353       }
 354     }
 355   }
 356 }
 357 
 358 //---------------------------prune_matchlist-----------------------------------
 359 // Check for duplicate entries in a matchlist, and prune out the higher cost
 360 // entry.
 361 void ArchDesc::prune_matchlist(Dict &amp;minimize, MatchList &amp;mlist) {
 362 
 363 }
 364 
 365 //---------------------------buildDFA------------------------------------------
 366 // DFA is a large switch with case statements for each ideal opcode encountered
 367 // in any match rule in the ad file.  Each case has a series of if&#39;s to handle
 368 // the match or fail decisions.  The matches test the cost function of that
 369 // rule, and prune any cases which are higher cost for the same reduction.
 370 // In order to generate the DFA we walk the table of ideal opcode/MatchList
 371 // pairs generated by the ADLC front end to build the contents of the case
 372 // statements (a series of if statements).
 373 void ArchDesc::buildDFA(FILE* fp) {
 374   int i;
 375   // Remember operands that are the starting points for chain rules.
 376   // Prevent cycles by checking if we have already generated chain.
 377   Dict operands_chained_from(cmpstr, hashstr, Form::arena);
 378 
 379   // Hash inputs to match rules so that final DFA contains only one entry for
 380   // each match pattern which is the low cost entry.
 381   Dict minimize(cmpstr, hashstr, Form::arena);
 382 
 383   // Track status of dfa for each resulting production
 384   // reset for each ideal root.
 385   ProductionState status(Form::arena);
 386 
 387   // Output the start of the DFA method into the output file
 388 
 389   fprintf(fp, &quot;\n&quot;);
 390   fprintf(fp, &quot;//------------------------- Source -----------------------------------------\n&quot;);
 391   // Do not put random source code into the DFA.
 392   // If there are constants which need sharing, put them in &quot;source_hpp&quot; forms.
 393   // _source.output(fp);
 394   fprintf(fp, &quot;\n&quot;);
 395   fprintf(fp, &quot;//------------------------- Attributes -------------------------------------\n&quot;);
 396   _attributes.output(fp);
 397   fprintf(fp, &quot;\n&quot;);
 398   fprintf(fp, &quot;//------------------------- Macros -----------------------------------------\n&quot;);
 399   // #define DFA_PRODUCTION(result, rule, cost)\
 400   //   _cost[ (result) ] = cost; _rule[ (result) ] = rule;
 401   fprintf(fp, &quot;#define %s(result, rule, cost)\\\n&quot;, dfa_production);
 402   fprintf(fp, &quot;  _cost[ (result) ] = cost; _rule[ (result) ] = rule;\n&quot;);
 403   fprintf(fp, &quot;\n&quot;);
 404 
 405   // #define DFA_PRODUCTION__SET_VALID(result, rule, cost)\
 406   //     DFA_PRODUCTION( (result), (rule), (cost) ); STATE__SET_VALID( (result) );
 407   fprintf(fp, &quot;#define %s(result, rule, cost)\\\n&quot;, dfa_production_set_valid);
 408   fprintf(fp, &quot;  %s( (result), (rule), (cost) ); STATE__SET_VALID( (result) );\n&quot;, dfa_production);
 409   fprintf(fp, &quot;\n&quot;);
 410 
 411   fprintf(fp, &quot;//------------------------- DFA --------------------------------------------\n&quot;);
 412 
 413   fprintf(fp,
 414 &quot;// DFA is a large switch with case statements for each ideal opcode encountered\n&quot;
 415 &quot;// in any match rule in the ad file.  Each case has a series of if&#39;s to handle\n&quot;
 416 &quot;// the match or fail decisions.  The matches test the cost function of that\n&quot;
 417 &quot;// rule, and prune any cases which are higher cost for the same reduction.\n&quot;
 418 &quot;// In order to generate the DFA we walk the table of ideal opcode/MatchList\n&quot;
 419 &quot;// pairs generated by the ADLC front end to build the contents of the case\n&quot;
 420 &quot;// statements (a series of if statements).\n&quot;
 421 );
 422   fprintf(fp, &quot;\n&quot;);
 423   fprintf(fp, &quot;\n&quot;);
 424   if (_dfa_small) {
 425     // Now build the individual routines just like the switch entries in large version
 426     // Iterate over the table of MatchLists, start at first valid opcode of 1
 427     for (i = 1; i &lt; _last_opcode; i++) {
 428       if (_mlistab[i] == NULL) continue;
 429       // Generate the routine header statement for this opcode
 430       fprintf(fp, &quot;void  State::_sub_Op_%s(const Node *n){\n&quot;, NodeClassNames[i]);
 431       // Generate body. Shared for both inline and out-of-line version
 432       gen_dfa_state_body(fp, minimize, status, operands_chained_from, i);
 433       // End of routine
 434       fprintf(fp, &quot;}\n&quot;);
 435     }
 436   }
 437   fprintf(fp, &quot;bool State::DFA&quot;);
 438   fprintf(fp, &quot;(int opcode, const Node *n) {\n&quot;);
 439   fprintf(fp, &quot;  switch(opcode) {\n&quot;);
 440 
 441   // Iterate over the table of MatchLists, start at first valid opcode of 1
 442   for (i = 1; i &lt; _last_opcode; i++) {
 443     if (_mlistab[i] == NULL) continue;
 444     // Generate the case statement for this opcode
 445     if (_dfa_small) {
 446       fprintf(fp, &quot;  case Op_%s: { _sub_Op_%s(n);\n&quot;, NodeClassNames[i], NodeClassNames[i]);
 447     } else {
 448       fprintf(fp, &quot;  case Op_%s: {\n&quot;, NodeClassNames[i]);
 449       // Walk the list, compacting it
 450       gen_dfa_state_body(fp, minimize, status, operands_chained_from, i);
 451     }
 452     // Print the &quot;break&quot;
 453     fprintf(fp, &quot;    break;\n&quot;);
 454     fprintf(fp, &quot;  }\n&quot;);
 455   }
 456 
 457   // Generate the default case for switch(opcode)
 458   fprintf(fp, &quot;  \n&quot;);
 459   fprintf(fp, &quot;  default:\n&quot;);
 460   fprintf(fp, &quot;    tty-&gt;print(\&quot;Default case invoked for: \\n\&quot;);\n&quot;);
 461   fprintf(fp, &quot;    tty-&gt;print(\&quot;   opcode  = %cd, \\\&quot;%cs\\\&quot;\\n\&quot;, opcode, NodeClassNames[opcode]);\n&quot;, &#39;%&#39;, &#39;%&#39;);
 462   fprintf(fp, &quot;    return false;\n&quot;);
 463   fprintf(fp, &quot;  }\n&quot;);
 464 
 465   // Return status, indicating a successful match.
 466   fprintf(fp, &quot;  return true;\n&quot;);
 467   // Generate the closing brace for method Matcher::DFA
 468   fprintf(fp, &quot;}\n&quot;);
 469   Expr::check_buffers();
 470 }
 471 
 472 
 473 class dfa_shared_preds {
 474   enum { count = 4 };
 475 
 476   static bool        _found[count];
 477   static const char* _type [count];
 478   static const char* _var  [count];
 479   static const char* _pred [count];
 480 
 481   static void check_index(int index) { assert( 0 &lt;= index &amp;&amp; index &lt; count, &quot;Invalid index&quot;); }
 482 
 483   // Confirm that this is a separate sub-expression.
 484   // Only need to catch common cases like &quot; ... &amp;&amp; shared ...&quot;
 485   // and avoid hazardous ones like &quot;...-&gt;shared&quot;
 486   static bool valid_loc(char *pred, char *shared) {
 487     // start of predicate is valid
 488     if( shared == pred ) return true;
 489 
 490     // Check previous character and recurse if needed
 491     char *prev = shared - 1;
 492     char c  = *prev;
 493     switch( c ) {
 494     case &#39; &#39;:
 495     case &#39;\n&#39;:
 496       return dfa_shared_preds::valid_loc(pred, prev);
 497     case &#39;!&#39;:
 498     case &#39;(&#39;:
 499     case &#39;&lt;&#39;:
 500     case &#39;=&#39;:
 501       return true;
 502     case &#39;&quot;&#39;:  // such as: #line 10 &quot;myfile.ad&quot;\n mypredicate
 503       return true;
 504     case &#39;|&#39;:
 505       if (prev != pred &amp;&amp; *(prev-1) == &#39;|&#39;) return true;
 506       break;
 507     case &#39;&amp;&#39;:
 508       if (prev != pred &amp;&amp; *(prev-1) == &#39;&amp;&#39;) return true;
 509       break;
 510     default:
 511       return false;
 512     }
 513 
 514     return false;
 515   }
 516 
 517 public:
 518 
 519   static bool        found(int index){ check_index(index); return _found[index]; }
 520   static void    set_found(int index, bool val) { check_index(index); _found[index] = val; }
 521   static void  reset_found() {
 522     for( int i = 0; i &lt; count; ++i ) { _found[i] = false; }
 523   };
 524 
 525   static const char* type(int index) { check_index(index); return _type[index]; }
 526   static const char* var (int index) { check_index(index); return _var [index];  }
 527   static const char* pred(int index) { check_index(index); return _pred[index]; }
 528 
 529   // Check each predicate in the MatchList for common sub-expressions
 530   static void cse_matchlist(MatchList *matchList) {
 531     for( MatchList *mList = matchList; mList != NULL; mList = mList-&gt;get_next() ) {
 532       Predicate* predicate = mList-&gt;get_pred_obj();
 533       char*      pred      = mList-&gt;get_pred();
 534       if( pred != NULL ) {
 535         for(int index = 0; index &lt; count; ++index ) {
 536           const char *shared_pred      = dfa_shared_preds::pred(index);
 537           const char *shared_pred_var  = dfa_shared_preds::var(index);
 538           bool result = dfa_shared_preds::cse_predicate(predicate, shared_pred, shared_pred_var);
 539           if( result ) dfa_shared_preds::set_found(index, true);
 540         }
 541       }
 542     }
 543   }
 544 
 545   // If the Predicate contains a common sub-expression, replace the Predicate&#39;s
 546   // string with one that uses the variable name.
 547   static bool cse_predicate(Predicate* predicate, const char *shared_pred, const char *shared_pred_var) {
 548     bool result = false;
 549     char *pred = predicate-&gt;_pred;
 550     if( pred != NULL ) {
 551       char *new_pred = pred;
 552       for( char *shared_pred_loc = strstr(new_pred, shared_pred);
 553       shared_pred_loc != NULL &amp;&amp; dfa_shared_preds::valid_loc(new_pred,shared_pred_loc);
 554       shared_pred_loc = strstr(new_pred, shared_pred) ) {
 555         // Do not modify the original predicate string, it is shared
 556         if( new_pred == pred ) {
 557           new_pred = strdup(pred);
 558           shared_pred_loc = strstr(new_pred, shared_pred);
 559         }
 560         // Replace shared_pred with variable name
 561         strncpy(shared_pred_loc, shared_pred_var, strlen(shared_pred_var));
 562       }
 563       // Install new predicate
 564       if( new_pred != pred ) {
 565         predicate-&gt;_pred = new_pred;
 566         result = true;
 567       }
 568     }
 569     return result;
 570   }
 571 
 572   // Output the hoisted common sub-expression if we found it in predicates
 573   static void generate_cse(FILE *fp) {
 574     for(int j = 0; j &lt; count; ++j ) {
 575       if( dfa_shared_preds::found(j) ) {
 576         const char *shared_pred_type = dfa_shared_preds::type(j);
 577         const char *shared_pred_var  = dfa_shared_preds::var(j);
 578         const char *shared_pred      = dfa_shared_preds::pred(j);
 579         fprintf(fp, &quot;    %s %s = %s;\n&quot;, shared_pred_type, shared_pred_var, shared_pred);
 580       }
 581     }
 582   }
 583 };
 584 // shared predicates, _var and _pred entry should be the same length
 585 bool         dfa_shared_preds::_found[dfa_shared_preds::count]
 586   = { false, false, false, false };
 587 const char*  dfa_shared_preds::_type[dfa_shared_preds::count]
 588   = { &quot;int&quot;, &quot;jlong&quot;, &quot;intptr_t&quot;, &quot;bool&quot; };
 589 const char*  dfa_shared_preds::_var [dfa_shared_preds::count]
 590   = { &quot;_n_get_int__&quot;, &quot;_n_get_long__&quot;, &quot;_n_get_intptr_t__&quot;, &quot;Compile__current____select_24_bit_instr__&quot; };
 591 const char*  dfa_shared_preds::_pred[dfa_shared_preds::count]
 592   = { &quot;n-&gt;get_int()&quot;, &quot;n-&gt;get_long()&quot;, &quot;n-&gt;get_intptr_t()&quot;, &quot;Compile::current()-&gt;select_24_bit_instr()&quot; };
 593 
 594 
 595 void ArchDesc::gen_dfa_state_body(FILE* fp, Dict &amp;minimize, ProductionState &amp;status, Dict &amp;operands_chained_from, int i) {
 596   // Start the body of each Op_XXX sub-dfa with a clean state.
 597   status.initialize();
 598 
 599   // Walk the list, compacting it
 600   MatchList* mList = _mlistab[i];
 601   do {
 602     // Hash each entry using inputs as key and pointer as data.
 603     // If there is already an entry, keep the one with lower cost, and
 604     // remove the other one from the list.
 605     prune_matchlist(minimize, *mList);
 606     // Iterate
 607     mList = mList-&gt;get_next();
 608   } while(mList != NULL);
 609 
 610   // Hoist previously specified common sub-expressions out of predicates
 611   dfa_shared_preds::reset_found();
 612   dfa_shared_preds::cse_matchlist(_mlistab[i]);
 613   dfa_shared_preds::generate_cse(fp);
 614 
 615   mList = _mlistab[i];
 616 
 617   // Walk the list again, generating code
 618   do {
 619     // Each match can generate its own chains
 620     operands_chained_from.Clear();
 621     gen_match(fp, *mList, status, operands_chained_from);
 622     mList = mList-&gt;get_next();
 623   } while(mList != NULL);
 624   // Fill in any chain rules which add instructions
 625   // These can generate their own chains as well.
 626   operands_chained_from.Clear();  //
 627   if( debug_output1 ) { fprintf(fp, &quot;// top level chain rules for: %s \n&quot;, (char *)NodeClassNames[i]); } // %%%%% Explanation
 628   const Expr *zeroCost = new Expr(&quot;0&quot;);
 629   chain_rule(fp, &quot;   &quot;, (char *)NodeClassNames[i], zeroCost, &quot;Invalid&quot;,
 630              operands_chained_from, status);
 631 }
 632 
 633 
 634 
 635 //------------------------------Expr------------------------------------------
 636 Expr *Expr::_unknown_expr = NULL;
 637 char  Expr::string_buffer[STRING_BUFFER_LENGTH];
 638 char  Expr::external_buffer[STRING_BUFFER_LENGTH];
 639 bool  Expr::_init_buffers = Expr::init_buffers();
 640 
 641 Expr::Expr() {
 642   _external_name = NULL;
 643   _expr          = &quot;Invalid_Expr&quot;;
 644   _min_value     = Expr::Max;
 645   _max_value     = Expr::Zero;
 646 }
 647 Expr::Expr(const char *cost) {
 648   _external_name = NULL;
 649 
 650   int intval = 0;
 651   if( cost == NULL ) {
 652     _expr = &quot;0&quot;;
 653     _min_value = Expr::Zero;
 654     _max_value = Expr::Zero;
 655   }
 656   else if( ADLParser::is_int_token(cost, intval) ) {
 657     _expr = cost;
 658     _min_value = intval;
 659     _max_value = intval;
 660   }
 661   else {
 662     assert( strcmp(cost,&quot;0&quot;) != 0, &quot;Recognize string zero as an int&quot;);
 663     _expr = cost;
 664     _min_value = Expr::Zero;
 665     _max_value = Expr::Max;
 666   }
 667 }
 668 
 669 Expr::Expr(const char *name, const char *expression, int min_value, int max_value) {
 670   _external_name = name;
 671   _expr          = expression ? expression : name;
 672   _min_value     = min_value;
 673   _max_value     = max_value;
 674   assert(_min_value &gt;= 0 &amp;&amp; _min_value &lt;= Expr::Max, &quot;value out of range&quot;);
 675   assert(_max_value &gt;= 0 &amp;&amp; _max_value &lt;= Expr::Max, &quot;value out of range&quot;);
 676 }
 677 
 678 Expr *Expr::clone() const {
 679   Expr *cost = new Expr();
 680   cost-&gt;_external_name = _external_name;
 681   cost-&gt;_expr          = _expr;
 682   cost-&gt;_min_value     = _min_value;
 683   cost-&gt;_max_value     = _max_value;
 684 
 685   return cost;
 686 }
 687 
 688 void Expr::add(const Expr *c) {
 689   // Do not update fields until all computation is complete
 690   const char *external  = compute_external(this, c);
 691   const char *expr      = compute_expr(this, c);
 692   int         min_value = compute_min (this, c);
 693   int         max_value = compute_max (this, c);
 694 
 695   _external_name = external;
 696   _expr      = expr;
 697   _min_value = min_value;
 698   _max_value = max_value;
 699 }
 700 
 701 void Expr::add(const char *c) {
 702   Expr *cost = new Expr(c);
 703   add(cost);
 704 }
 705 
 706 void Expr::add(const char *c, ArchDesc &amp;AD) {
 707   const Expr *e = AD.globalDefs()[c];
 708   if( e != NULL ) {
 709     // use the value of &#39;c&#39; defined in &lt;arch&gt;.ad
 710     add(e);
 711   } else {
 712     Expr *cost = new Expr(c);
 713     add(cost);
 714   }
 715 }
 716 
 717 const char *Expr::compute_external(const Expr *c1, const Expr *c2) {
 718   const char * result = NULL;
 719 
 720   // Preserve use of external name which has a zero value
 721   if( c1-&gt;_external_name != NULL ) {
 722     if( c2-&gt;is_zero() ) {
 723       snprintf(string_buffer, STRING_BUFFER_LENGTH, &quot;%s&quot;, c1-&gt;as_string());
 724     } else {
 725       snprintf(string_buffer, STRING_BUFFER_LENGTH, &quot;%s+%s&quot;, c1-&gt;as_string(), c2-&gt;as_string());
 726     }
 727     string_buffer[STRING_BUFFER_LENGTH - 1] = &#39;\0&#39;;
 728     result = strdup(string_buffer);
 729   }
 730   else if( c2-&gt;_external_name != NULL ) {
 731     if( c1-&gt;is_zero() ) {
 732       snprintf(string_buffer, STRING_BUFFER_LENGTH, &quot;%s&quot;, c2-&gt;_external_name);
 733     } else {
 734       snprintf(string_buffer, STRING_BUFFER_LENGTH, &quot;%s + %s&quot;, c1-&gt;as_string(), c2-&gt;as_string());
 735     }
 736     string_buffer[STRING_BUFFER_LENGTH - 1] = &#39;\0&#39;;
 737     result = strdup(string_buffer);
 738   }
 739   return result;
 740 }
 741 
 742 const char *Expr::compute_expr(const Expr *c1, const Expr *c2) {
 743   if( !c1-&gt;is_zero() ) {
 744     if( c2-&gt;is_zero() ) {
 745       snprintf(string_buffer, STRING_BUFFER_LENGTH, &quot;%s&quot;, c1-&gt;_expr);
 746     } else {
 747       snprintf(string_buffer, STRING_BUFFER_LENGTH, &quot;%s+%s&quot;, c1-&gt;_expr, c2-&gt;_expr);
 748     }
 749   }
 750   else if( !c2-&gt;is_zero() ) {
 751     snprintf(string_buffer, STRING_BUFFER_LENGTH, &quot;%s&quot;, c2-&gt;_expr);
 752   }
 753   else {
 754     sprintf( string_buffer, &quot;0&quot;);
 755   }
 756   string_buffer[STRING_BUFFER_LENGTH - 1] = &#39;\0&#39;;
 757   char *cost = strdup(string_buffer);
 758 
 759   return cost;
 760 }
 761 
 762 int Expr::compute_min(const Expr *c1, const Expr *c2) {
 763   int v1 = c1-&gt;_min_value;
 764   int v2 = c2-&gt;_min_value;
 765   assert(0 &lt;= v2 &amp;&amp; v2 &lt;= Expr::Max, &quot;sanity&quot;);
 766   assert(v1 &lt;= Expr::Max - v2, &quot;Invalid cost computation&quot;);
 767 
 768   return v1 + v2;
 769 }
 770 
 771 
 772 int Expr::compute_max(const Expr *c1, const Expr *c2) {
 773   int v1 = c1-&gt;_max_value;
 774   int v2 = c2-&gt;_max_value;
 775 
 776   // Check for overflow without producing UB. If v2 is positive
 777   // and not larger than Max, the subtraction cannot underflow.
 778   assert(0 &lt;= v2 &amp;&amp; v2 &lt;= Expr::Max, &quot;sanity&quot;);
 779   if (v1 &gt; Expr::Max - v2) {
 780     return Expr::Max;
 781   }
 782 
 783   return v1 + v2;
 784 }
 785 
 786 void Expr::print() const {
 787   if( _external_name != NULL ) {
 788     printf(&quot;  %s == (%s) === [%d, %d]\n&quot;, _external_name, _expr, _min_value, _max_value);
 789   } else {
 790     printf(&quot;  %s === [%d, %d]\n&quot;, _expr, _min_value, _max_value);
 791   }
 792 }
 793 
 794 void Expr::print_define(FILE *fp) const {
 795   assert( _external_name != NULL, &quot;definition does not have a name&quot;);
 796   assert( _min_value == _max_value, &quot;Expect user definitions to have constant value&quot;);
 797   fprintf(fp, &quot;#define  %s  (%s)  \n&quot;, _external_name, _expr);
 798   fprintf(fp, &quot;// value == %d \n&quot;, _min_value);
 799 }
 800 
 801 void Expr::print_assert(FILE *fp) const {
 802   assert( _external_name != NULL, &quot;definition does not have a name&quot;);
 803   assert( _min_value == _max_value, &quot;Expect user definitions to have constant value&quot;);
 804   fprintf(fp, &quot;  assert( %s == %d, \&quot;Expect (%s) to equal %d\&quot;);\n&quot;, _external_name, _min_value, _expr, _min_value);
 805 }
 806 
 807 Expr *Expr::get_unknown() {
 808   if( Expr::_unknown_expr == NULL ) {
 809     Expr::_unknown_expr = new Expr();
 810   }
 811 
 812   return Expr::_unknown_expr;
 813 }
 814 
 815 bool Expr::init_buffers() {
 816   // Fill buffers with 0
 817   for( int i = 0; i &lt; STRING_BUFFER_LENGTH; ++i ) {
 818     external_buffer[i] = &#39;\0&#39;;
 819     string_buffer[i]   = &#39;\0&#39;;
 820   }
 821 
 822   return true;
 823 }
 824 
 825 bool Expr::check_buffers() {
 826   // returns &#39;true&#39; if buffer use may have overflowed
 827   bool ok = true;
 828   for( int i = STRING_BUFFER_LENGTH - 100; i &lt; STRING_BUFFER_LENGTH; ++i) {
 829     if( external_buffer[i] != &#39;\0&#39; || string_buffer[i]   != &#39;\0&#39; ) {
 830       ok = false;
 831       assert( false, &quot;Expr:: Buffer overflow&quot;);
 832     }
 833   }
 834 
 835   return ok;
 836 }
 837 
 838 
 839 //------------------------------ExprDict---------------------------------------
 840 // Constructor
 841 ExprDict::ExprDict( CmpKey cmp, Hash hash, Arena *arena )
 842   : _expr(cmp, hash, arena), _defines()  {
 843 }
 844 ExprDict::~ExprDict() {
 845 }
 846 
 847 // Return # of name-Expr pairs in dict
 848 int ExprDict::Size(void) const {
 849   return _expr.Size();
 850 }
 851 
 852 // define inserts the given key-value pair into the dictionary,
 853 // and records the name in order for later output, ...
 854 const Expr  *ExprDict::define(const char *name, Expr *expr) {
 855   const Expr *old_expr = (*this)[name];
 856   assert(old_expr == NULL, &quot;Implementation does not support redefinition&quot;);
 857 
 858   _expr.Insert(name, expr);
 859   _defines.addName(name);
 860 
 861   return old_expr;
 862 }
 863 
 864 // Insert inserts the given key-value pair into the dictionary.  The prior
 865 // value of the key is returned; NULL if the key was not previously defined.
 866 const Expr  *ExprDict::Insert(const char *name, Expr *expr) {
 867   return (Expr*)_expr.Insert((void*)name, (void*)expr);
 868 }
 869 
 870 // Finds the value of a given key; or NULL if not found.
 871 // The dictionary is NOT changed.
 872 const Expr  *ExprDict::operator [](const char *name) const {
 873   return (Expr*)_expr[name];
 874 }
 875 
 876 void ExprDict::print_defines(FILE *fp) {
 877   fprintf(fp, &quot;\n&quot;);
 878   const char *name = NULL;
 879   for( _defines.reset(); (name = _defines.iter()) != NULL; ) {
 880     const Expr *expr = (const Expr*)_expr[name];
 881     assert( expr != NULL, &quot;name in ExprDict without matching Expr in dictionary&quot;);
 882     expr-&gt;print_define(fp);
 883   }
 884 }
 885 void ExprDict::print_asserts(FILE *fp) {
 886   fprintf(fp, &quot;\n&quot;);
 887   fprintf(fp, &quot;  // Following assertions generated from definition section\n&quot;);
 888   const char *name = NULL;
 889   for( _defines.reset(); (name = _defines.iter()) != NULL; ) {
 890     const Expr *expr = (const Expr*)_expr[name];
 891     assert( expr != NULL, &quot;name in ExprDict without matching Expr in dictionary&quot;);
 892     expr-&gt;print_assert(fp);
 893   }
 894 }
 895 
 896 // Print out the dictionary contents as key-value pairs
 897 static void dumpekey(const void* key)  { fprintf(stdout, &quot;%s&quot;, (char*) key); }
 898 static void dumpexpr(const void* expr) { fflush(stdout); ((Expr*)expr)-&gt;print(); }
 899 
 900 void ExprDict::dump() {
 901   _expr.print(dumpekey, dumpexpr);
 902 }
 903 
 904 
 905 //------------------------------ExprDict::private------------------------------
 906 // Disable public use of constructor, copy-ctor, operator =, operator ==
 907 ExprDict::ExprDict( ) : _expr(cmpkey,hashkey), _defines()  {
 908   assert( false, &quot;NotImplemented&quot;);
 909 }
 910 ExprDict::ExprDict( const ExprDict &amp; ) : _expr(cmpkey,hashkey), _defines() {
 911   assert( false, &quot;NotImplemented&quot;);
 912 }
 913 ExprDict &amp;ExprDict::operator =( const ExprDict &amp;rhs) {
 914   assert( false, &quot;NotImplemented&quot;);
 915   _expr = rhs._expr;
 916   return *this;
 917 }
 918 // == compares two dictionaries; they must have the same keys (their keys
 919 // must match using CmpKey) and they must have the same values (pointer
 920 // comparison).  If so 1 is returned, if not 0 is returned.
 921 bool ExprDict::operator ==(const ExprDict &amp;d) const {
 922   assert( false, &quot;NotImplemented&quot;);
 923   return false;
 924 }
 925 
 926 
 927 //------------------------------Production-------------------------------------
 928 Production::Production(const char *result, const char *constraint, const char *valid) {
 929   initialize();
 930   _result     = result;
 931   _constraint = constraint;
 932   _valid      = valid;
 933 }
 934 
 935 void Production::initialize() {
 936   _result     = NULL;
 937   _constraint = NULL;
 938   _valid      = knownInvalid;
 939   _cost_lb    = Expr::get_unknown();
 940   _cost_ub    = Expr::get_unknown();
 941 }
 942 
 943 void Production::print() {
 944   printf(&quot;%s&quot;, (_result     == NULL ? &quot;NULL&quot; : _result ) );
 945   printf(&quot;%s&quot;, (_constraint == NULL ? &quot;NULL&quot; : _constraint ) );
 946   printf(&quot;%s&quot;, (_valid      == NULL ? &quot;NULL&quot; : _valid ) );
 947   _cost_lb-&gt;print();
 948   _cost_ub-&gt;print();
 949 }
 950 
 951 
 952 //------------------------------ProductionState--------------------------------
 953 void ProductionState::initialize() {
 954   _constraint = noConstraint;
 955 
 956   // reset each Production currently in the dictionary
 957   DictI iter( &amp;_production );
 958   const void *x, *y = NULL;
 959   for( ; iter.test(); ++iter) {
 960     x = iter._key;
 961     y = iter._value;
 962     Production *p = (Production*)y;
 963     if( p != NULL ) {
 964       p-&gt;initialize();
 965     }
 966   }
 967 }
 968 
 969 Production *ProductionState::getProduction(const char *result) {
 970   Production *p = (Production *)_production[result];
 971   if( p == NULL ) {
 972     p = new Production(result, _constraint, knownInvalid);
 973     _production.Insert(result, p);
 974   }
 975 
 976   return p;
 977 }
 978 
 979 void ProductionState::set_constraint(const char *constraint) {
 980   _constraint = constraint;
 981 }
 982 
 983 const char *ProductionState::valid(const char *result) {
 984   return getProduction(result)-&gt;valid();
 985 }
 986 
 987 void ProductionState::set_valid(const char *result) {
 988   Production *p = getProduction(result);
 989 
 990   // Update valid as allowed by current constraints
 991   if( _constraint == noConstraint ) {
 992     p-&gt;_valid = knownValid;
 993   } else {
 994     if( p-&gt;_valid != knownValid ) {
 995       p-&gt;_valid = unknownValid;
 996     }
 997   }
 998 }
 999 
1000 Expr *ProductionState::cost_lb(const char *result) {
1001   return getProduction(result)-&gt;cost_lb();
1002 }
1003 
1004 Expr *ProductionState::cost_ub(const char *result) {
1005   return getProduction(result)-&gt;cost_ub();
1006 }
1007 
1008 void ProductionState::set_cost_bounds(const char *result, const Expr *cost, bool has_state_check, bool has_cost_check) {
1009   Production *p = getProduction(result);
1010 
1011   if( p-&gt;_valid == knownInvalid ) {
1012     // Our cost bounds are not unknown, just not defined.
1013     p-&gt;_cost_lb = cost-&gt;clone();
1014     p-&gt;_cost_ub = cost-&gt;clone();
1015   } else if (has_state_check || _constraint != noConstraint) {
1016     // The production is protected by a condition, so
1017     // the cost bounds may expand.
1018     // _cost_lb = min(cost, _cost_lb)
1019     if( cost-&gt;less_than_or_equal(p-&gt;_cost_lb) ) {
1020       p-&gt;_cost_lb = cost-&gt;clone();
1021     }
1022     // _cost_ub = max(cost, _cost_ub)
1023     if( p-&gt;_cost_ub-&gt;less_than_or_equal(cost) ) {
1024       p-&gt;_cost_ub = cost-&gt;clone();
1025     }
1026   } else if (has_cost_check) {
1027     // The production has no condition check, but does
1028     // have a cost check that could reduce the upper
1029     // and/or lower bound.
1030     // _cost_lb = min(cost, _cost_lb)
1031     if( cost-&gt;less_than_or_equal(p-&gt;_cost_lb) ) {
1032       p-&gt;_cost_lb = cost-&gt;clone();
1033     }
1034     // _cost_ub = min(cost, _cost_ub)
1035     if( cost-&gt;less_than_or_equal(p-&gt;_cost_ub) ) {
1036       p-&gt;_cost_ub = cost-&gt;clone();
1037     }
1038   } else {
1039     // The costs are unconditionally set.
1040     p-&gt;_cost_lb = cost-&gt;clone();
1041     p-&gt;_cost_ub = cost-&gt;clone();
1042   }
1043 
1044 }
1045 
1046 // Print out the dictionary contents as key-value pairs
1047 static void print_key (const void* key)              { fprintf(stdout, &quot;%s&quot;, (char*) key); }
1048 static void print_production(const void* production) { fflush(stdout); ((Production*)production)-&gt;print(); }
1049 
1050 void ProductionState::print() {
1051   _production.print(print_key, print_production);
1052 }
    </pre>
  </body>
</html>
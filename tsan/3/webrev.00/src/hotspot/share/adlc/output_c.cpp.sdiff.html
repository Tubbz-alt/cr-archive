<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/adlc/output_c.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="main.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="output_h.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/adlc/output_c.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
2360     }
2361     else if ( strcmp(rep_var,&quot;$label&quot;) == 0 ) {
2362       fprintf(_fp,&quot;-&gt;label()&quot;);
2363     }
2364     else if ( strcmp(rep_var,&quot;$method&quot;) == 0 ) {
2365       fprintf(_fp,&quot;-&gt;method()&quot;);
2366     }
2367     else {
2368       printf(&quot;emit_field: %s\n&quot;,rep_var);
2369       globalAD-&gt;syntax_err(_inst._linenum, &quot;Unknown replacement variable %s in format statement of %s.&quot;,
2370                            rep_var, _inst._ident);
2371       assert( false, &quot;UnImplemented()&quot;);
2372     }
2373   }
2374 
2375 
2376   void emit_rep_var(const char *rep_var) {
2377     _processing_noninput = false;
2378     // A replacement variable, originally &#39;$&#39;
2379     if ( Opcode::as_opcode_type(rep_var) != Opcode::NOT_AN_OPCODE ) {
<span class="line-modified">2380       if (!_inst._opcode-&gt;print_opcode(_fp, Opcode::as_opcode_type(rep_var) )) {</span>
2381         // Missing opcode
2382         _AD.syntax_err( _inst._linenum,
2383                         &quot;Missing $%s opcode definition in %s, used by encoding %s\n&quot;,
2384                         rep_var, _inst._ident, _encoding._name);
2385       }
2386     }
2387     else if (strcmp(rep_var, &quot;constanttablebase&quot;) == 0) {
2388       fprintf(_fp, &quot;as_Register(ra_-&gt;get_encode(in(mach_constant_base_node_input())))&quot;);
2389     }
2390     else if (strcmp(rep_var, &quot;constantoffset&quot;) == 0) {
2391       fprintf(_fp, &quot;constant_offset()&quot;);
2392     }
2393     else if (strcmp(rep_var, &quot;constantaddress&quot;) == 0) {
2394       fprintf(_fp, &quot;InternalAddress(__ code()-&gt;consts()-&gt;start() + constant_offset())&quot;);
2395     }
2396     else {
2397       // Lookup its position in parameter list
2398       int   param_no  = _encoding.rep_var_index(rep_var);
2399       if ( param_no == -1 ) {
2400         _AD.syntax_err( _encoding._linenum,
</pre>
<hr />
<pre>
2416           // This operand isn&#39;t a normal input so printing it is done
2417           // specially.
2418           _processing_noninput = true;
2419         } else {
2420           // Output the emit code for this operand
2421           fprintf(_fp,&quot;opnd_array(%d)&quot;,idx);
2422         }
2423         assert( _operand == opc-&gt;is_operand(),
2424                 &quot;Previous emit $operand does not match current&quot;);
2425       }
2426       else if( ADLParser::is_literal_constant(inst_rep_var) ) {
2427         // else check if it is a constant expression
2428         // Removed following assert to allow primitive C types as arguments to encodings
2429         // assert( _constant_status == LITERAL_ACCESSED, &quot;Must be processing a literal constant parameter&quot;);
2430         fprintf(_fp,&quot;(%s)&quot;, inst_rep_var);
2431         _constant_status = LITERAL_OUTPUT;
2432       }
2433       else if( Opcode::as_opcode_type(inst_rep_var) != Opcode::NOT_AN_OPCODE ) {
2434         // else check if &quot;primary&quot;, &quot;secondary&quot;, &quot;tertiary&quot;
2435         assert( _constant_status == LITERAL_ACCESSED, &quot;Must be processing a literal constant parameter&quot;);
<span class="line-modified">2436         if (!_inst._opcode-&gt;print_opcode(_fp, Opcode::as_opcode_type(inst_rep_var) )) {</span>
2437           // Missing opcode
2438           _AD.syntax_err( _inst._linenum,
2439                           &quot;Missing $%s opcode definition in %s\n&quot;,
2440                           rep_var, _inst._ident);
2441 
2442         }
2443         _constant_status = LITERAL_OUTPUT;
2444       }
2445       else if((_AD.get_registers() != NULL ) &amp;&amp; (_AD.get_registers()-&gt;getRegDef(inst_rep_var) != NULL)) {
2446         // Instruction provided a literal register name for this parameter
2447         // Check that encoding specifies $$$reg to resolve.as register.
2448         assert( _reg_status == LITERAL_ACCESSED, &quot;Must be processing a literal register parameter&quot;);
2449         fprintf(_fp,&quot;(%s_enc)&quot;, inst_rep_var);
2450         _reg_status = LITERAL_OUTPUT;
2451       }
2452       else {
2453         // Check for unimplemented functionality before hard failure
2454         assert(opc != NULL &amp;&amp; strcmp(opc-&gt;_ident, &quot;label&quot;) == 0, &quot;Unimplemented Label&quot;);
2455         assert(false, &quot;ShouldNotReachHere()&quot;);
2456       }
</pre>
<hr />
<pre>
2764     fprintf(fp, &quot;  assert(0 &lt;= index &amp;&amp; index &lt; %d, \&quot;index out of range\&quot;);\n&quot;,
2765             num_edges);
2766 
2767     // Figure out if all RegMasks are the same.
2768     const char* first_reg_class = oper.in_reg_class(0, globals);
2769     bool all_same = true;
2770     assert(first_reg_class != NULL, &quot;did not find register mask&quot;);
2771 
2772     for (uint index = 1; all_same &amp;&amp; index &lt; num_edges; index++) {
2773       const char* some_reg_class = oper.in_reg_class(index, globals);
2774       assert(some_reg_class != NULL, &quot;did not find register mask&quot;);
2775       if (strcmp(first_reg_class, some_reg_class) != 0) {
2776         all_same = false;
2777       }
2778     }
2779 
2780     if (all_same) {
2781       // Return the sole RegMask.
2782       if (strcmp(first_reg_class, &quot;stack_slots&quot;) == 0) {
2783         fprintf(fp,&quot;  return &amp;(Compile::current()-&gt;FIRST_STACK_mask());\n&quot;);


2784       } else {
2785         const char* first_reg_class_to_upper = toUpper(first_reg_class);
2786         fprintf(fp,&quot;  return &amp;%s_mask();\n&quot;, first_reg_class_to_upper);
2787         delete[] first_reg_class_to_upper;
2788       }
2789     } else {
2790       // Build a switch statement to return the desired mask.
2791       fprintf(fp,&quot;  switch (index) {\n&quot;);
2792 
2793       for (uint index = 0; index &lt; num_edges; index++) {
2794         const char *reg_class = oper.in_reg_class(index, globals);
2795         assert(reg_class != NULL, &quot;did not find register mask&quot;);
2796         if( !strcmp(reg_class, &quot;stack_slots&quot;) ) {
2797           fprintf(fp, &quot;  case %d: return &amp;(Compile::current()-&gt;FIRST_STACK_mask());\n&quot;, index);
2798         } else {
2799           const char* reg_class_to_upper = toUpper(reg_class);
2800           fprintf(fp, &quot;  case %d: return &amp;%s_mask();\n&quot;, index, reg_class_to_upper);
2801           delete[] reg_class_to_upper;
2802         }
2803       }
</pre>
<hr />
<pre>
3920       path_to_constant(fp_cpp, _globalNames, op-&gt;_matrule, i);
3921       for ( i = 1; i &lt; num_consts; ++i ) {
3922         fprintf(fp_cpp, &quot;, &quot;);
3923         path_to_constant(fp_cpp, _globalNames, op-&gt;_matrule, i);
3924       }
3925     }
3926     fprintf(fp_cpp, &quot; );\n&quot;);
3927     // #####
3928   }
3929 
3930   // Fill in the bottom_type where requested
3931   if (inst-&gt;captures_bottom_type(_globalNames)) {
3932     if (strncmp(&quot;MachCall&quot;, inst-&gt;mach_base_class(_globalNames), strlen(&quot;MachCall&quot;))) {
3933       fprintf(fp_cpp, &quot;%s node-&gt;_bottom_type = _leaf-&gt;bottom_type();\n&quot;, indent);
3934     }
3935   }
3936   if( inst-&gt;is_ideal_if() ) {
3937     fprintf(fp_cpp, &quot;%s node-&gt;_prob = _leaf-&gt;as_If()-&gt;_prob;\n&quot;, indent);
3938     fprintf(fp_cpp, &quot;%s node-&gt;_fcnt = _leaf-&gt;as_If()-&gt;_fcnt;\n&quot;, indent);
3939   }



3940   if (inst-&gt;is_ideal_jump()) {
3941     fprintf(fp_cpp, &quot;%s node-&gt;_probs = _leaf-&gt;as_Jump()-&gt;_probs;\n&quot;, indent);
3942   }
3943   if( inst-&gt;is_ideal_fastlock() ) {
3944     fprintf(fp_cpp, &quot;%s node-&gt;_counters = _leaf-&gt;as_FastLock()-&gt;counters();\n&quot;, indent);
3945     fprintf(fp_cpp, &quot;%s node-&gt;_rtm_counters = _leaf-&gt;as_FastLock()-&gt;rtm_counters();\n&quot;, indent);
3946     fprintf(fp_cpp, &quot;%s node-&gt;_stack_rtm_counters = _leaf-&gt;as_FastLock()-&gt;stack_rtm_counters();\n&quot;, indent);
3947   }
3948 
3949 }
3950 
3951 //---------------------------declare_cisc_version------------------------------
3952 // Build CISC version of this instruction
3953 void InstructForm::declare_cisc_version(ArchDesc &amp;AD, FILE *fp_hpp) {
3954   if( AD.can_cisc_spill() ) {
3955     InstructForm *inst_cisc = cisc_spill_alternate();
3956     if (inst_cisc != NULL) {
3957       fprintf(fp_hpp, &quot;  virtual int            cisc_operand() const { return %d; }\n&quot;, cisc_spill_operand());
3958       fprintf(fp_hpp, &quot;  virtual MachNode      *cisc_version(int offset);\n&quot;);
3959       fprintf(fp_hpp, &quot;  virtual void           use_cisc_RegMask();\n&quot;);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
2360     }
2361     else if ( strcmp(rep_var,&quot;$label&quot;) == 0 ) {
2362       fprintf(_fp,&quot;-&gt;label()&quot;);
2363     }
2364     else if ( strcmp(rep_var,&quot;$method&quot;) == 0 ) {
2365       fprintf(_fp,&quot;-&gt;method()&quot;);
2366     }
2367     else {
2368       printf(&quot;emit_field: %s\n&quot;,rep_var);
2369       globalAD-&gt;syntax_err(_inst._linenum, &quot;Unknown replacement variable %s in format statement of %s.&quot;,
2370                            rep_var, _inst._ident);
2371       assert( false, &quot;UnImplemented()&quot;);
2372     }
2373   }
2374 
2375 
2376   void emit_rep_var(const char *rep_var) {
2377     _processing_noninput = false;
2378     // A replacement variable, originally &#39;$&#39;
2379     if ( Opcode::as_opcode_type(rep_var) != Opcode::NOT_AN_OPCODE ) {
<span class="line-modified">2380       if ((_inst._opcode == NULL) || !_inst._opcode-&gt;print_opcode(_fp, Opcode::as_opcode_type(rep_var) )) {</span>
2381         // Missing opcode
2382         _AD.syntax_err( _inst._linenum,
2383                         &quot;Missing $%s opcode definition in %s, used by encoding %s\n&quot;,
2384                         rep_var, _inst._ident, _encoding._name);
2385       }
2386     }
2387     else if (strcmp(rep_var, &quot;constanttablebase&quot;) == 0) {
2388       fprintf(_fp, &quot;as_Register(ra_-&gt;get_encode(in(mach_constant_base_node_input())))&quot;);
2389     }
2390     else if (strcmp(rep_var, &quot;constantoffset&quot;) == 0) {
2391       fprintf(_fp, &quot;constant_offset()&quot;);
2392     }
2393     else if (strcmp(rep_var, &quot;constantaddress&quot;) == 0) {
2394       fprintf(_fp, &quot;InternalAddress(__ code()-&gt;consts()-&gt;start() + constant_offset())&quot;);
2395     }
2396     else {
2397       // Lookup its position in parameter list
2398       int   param_no  = _encoding.rep_var_index(rep_var);
2399       if ( param_no == -1 ) {
2400         _AD.syntax_err( _encoding._linenum,
</pre>
<hr />
<pre>
2416           // This operand isn&#39;t a normal input so printing it is done
2417           // specially.
2418           _processing_noninput = true;
2419         } else {
2420           // Output the emit code for this operand
2421           fprintf(_fp,&quot;opnd_array(%d)&quot;,idx);
2422         }
2423         assert( _operand == opc-&gt;is_operand(),
2424                 &quot;Previous emit $operand does not match current&quot;);
2425       }
2426       else if( ADLParser::is_literal_constant(inst_rep_var) ) {
2427         // else check if it is a constant expression
2428         // Removed following assert to allow primitive C types as arguments to encodings
2429         // assert( _constant_status == LITERAL_ACCESSED, &quot;Must be processing a literal constant parameter&quot;);
2430         fprintf(_fp,&quot;(%s)&quot;, inst_rep_var);
2431         _constant_status = LITERAL_OUTPUT;
2432       }
2433       else if( Opcode::as_opcode_type(inst_rep_var) != Opcode::NOT_AN_OPCODE ) {
2434         // else check if &quot;primary&quot;, &quot;secondary&quot;, &quot;tertiary&quot;
2435         assert( _constant_status == LITERAL_ACCESSED, &quot;Must be processing a literal constant parameter&quot;);
<span class="line-modified">2436         if ((_inst._opcode == NULL) || !_inst._opcode-&gt;print_opcode(_fp, Opcode::as_opcode_type(inst_rep_var) )) {</span>
2437           // Missing opcode
2438           _AD.syntax_err( _inst._linenum,
2439                           &quot;Missing $%s opcode definition in %s\n&quot;,
2440                           rep_var, _inst._ident);
2441 
2442         }
2443         _constant_status = LITERAL_OUTPUT;
2444       }
2445       else if((_AD.get_registers() != NULL ) &amp;&amp; (_AD.get_registers()-&gt;getRegDef(inst_rep_var) != NULL)) {
2446         // Instruction provided a literal register name for this parameter
2447         // Check that encoding specifies $$$reg to resolve.as register.
2448         assert( _reg_status == LITERAL_ACCESSED, &quot;Must be processing a literal register parameter&quot;);
2449         fprintf(_fp,&quot;(%s_enc)&quot;, inst_rep_var);
2450         _reg_status = LITERAL_OUTPUT;
2451       }
2452       else {
2453         // Check for unimplemented functionality before hard failure
2454         assert(opc != NULL &amp;&amp; strcmp(opc-&gt;_ident, &quot;label&quot;) == 0, &quot;Unimplemented Label&quot;);
2455         assert(false, &quot;ShouldNotReachHere()&quot;);
2456       }
</pre>
<hr />
<pre>
2764     fprintf(fp, &quot;  assert(0 &lt;= index &amp;&amp; index &lt; %d, \&quot;index out of range\&quot;);\n&quot;,
2765             num_edges);
2766 
2767     // Figure out if all RegMasks are the same.
2768     const char* first_reg_class = oper.in_reg_class(0, globals);
2769     bool all_same = true;
2770     assert(first_reg_class != NULL, &quot;did not find register mask&quot;);
2771 
2772     for (uint index = 1; all_same &amp;&amp; index &lt; num_edges; index++) {
2773       const char* some_reg_class = oper.in_reg_class(index, globals);
2774       assert(some_reg_class != NULL, &quot;did not find register mask&quot;);
2775       if (strcmp(first_reg_class, some_reg_class) != 0) {
2776         all_same = false;
2777       }
2778     }
2779 
2780     if (all_same) {
2781       // Return the sole RegMask.
2782       if (strcmp(first_reg_class, &quot;stack_slots&quot;) == 0) {
2783         fprintf(fp,&quot;  return &amp;(Compile::current()-&gt;FIRST_STACK_mask());\n&quot;);
<span class="line-added">2784       } else if (strcmp(first_reg_class, &quot;dynamic&quot;) == 0) {</span>
<span class="line-added">2785         fprintf(fp,&quot;  return &amp;RegMask::Empty;\n&quot;);</span>
2786       } else {
2787         const char* first_reg_class_to_upper = toUpper(first_reg_class);
2788         fprintf(fp,&quot;  return &amp;%s_mask();\n&quot;, first_reg_class_to_upper);
2789         delete[] first_reg_class_to_upper;
2790       }
2791     } else {
2792       // Build a switch statement to return the desired mask.
2793       fprintf(fp,&quot;  switch (index) {\n&quot;);
2794 
2795       for (uint index = 0; index &lt; num_edges; index++) {
2796         const char *reg_class = oper.in_reg_class(index, globals);
2797         assert(reg_class != NULL, &quot;did not find register mask&quot;);
2798         if( !strcmp(reg_class, &quot;stack_slots&quot;) ) {
2799           fprintf(fp, &quot;  case %d: return &amp;(Compile::current()-&gt;FIRST_STACK_mask());\n&quot;, index);
2800         } else {
2801           const char* reg_class_to_upper = toUpper(reg_class);
2802           fprintf(fp, &quot;  case %d: return &amp;%s_mask();\n&quot;, index, reg_class_to_upper);
2803           delete[] reg_class_to_upper;
2804         }
2805       }
</pre>
<hr />
<pre>
3922       path_to_constant(fp_cpp, _globalNames, op-&gt;_matrule, i);
3923       for ( i = 1; i &lt; num_consts; ++i ) {
3924         fprintf(fp_cpp, &quot;, &quot;);
3925         path_to_constant(fp_cpp, _globalNames, op-&gt;_matrule, i);
3926       }
3927     }
3928     fprintf(fp_cpp, &quot; );\n&quot;);
3929     // #####
3930   }
3931 
3932   // Fill in the bottom_type where requested
3933   if (inst-&gt;captures_bottom_type(_globalNames)) {
3934     if (strncmp(&quot;MachCall&quot;, inst-&gt;mach_base_class(_globalNames), strlen(&quot;MachCall&quot;))) {
3935       fprintf(fp_cpp, &quot;%s node-&gt;_bottom_type = _leaf-&gt;bottom_type();\n&quot;, indent);
3936     }
3937   }
3938   if( inst-&gt;is_ideal_if() ) {
3939     fprintf(fp_cpp, &quot;%s node-&gt;_prob = _leaf-&gt;as_If()-&gt;_prob;\n&quot;, indent);
3940     fprintf(fp_cpp, &quot;%s node-&gt;_fcnt = _leaf-&gt;as_If()-&gt;_fcnt;\n&quot;, indent);
3941   }
<span class="line-added">3942   if (inst-&gt;is_ideal_halt()) {</span>
<span class="line-added">3943     fprintf(fp_cpp, &quot;%s node-&gt;_halt_reason = _leaf-&gt;as_Halt()-&gt;_halt_reason;\n&quot;, indent);</span>
<span class="line-added">3944   }</span>
3945   if (inst-&gt;is_ideal_jump()) {
3946     fprintf(fp_cpp, &quot;%s node-&gt;_probs = _leaf-&gt;as_Jump()-&gt;_probs;\n&quot;, indent);
3947   }
3948   if( inst-&gt;is_ideal_fastlock() ) {
3949     fprintf(fp_cpp, &quot;%s node-&gt;_counters = _leaf-&gt;as_FastLock()-&gt;counters();\n&quot;, indent);
3950     fprintf(fp_cpp, &quot;%s node-&gt;_rtm_counters = _leaf-&gt;as_FastLock()-&gt;rtm_counters();\n&quot;, indent);
3951     fprintf(fp_cpp, &quot;%s node-&gt;_stack_rtm_counters = _leaf-&gt;as_FastLock()-&gt;stack_rtm_counters();\n&quot;, indent);
3952   }
3953 
3954 }
3955 
3956 //---------------------------declare_cisc_version------------------------------
3957 // Build CISC version of this instruction
3958 void InstructForm::declare_cisc_version(ArchDesc &amp;AD, FILE *fp_hpp) {
3959   if( AD.can_cisc_spill() ) {
3960     InstructForm *inst_cisc = cisc_spill_alternate();
3961     if (inst_cisc != NULL) {
3962       fprintf(fp_hpp, &quot;  virtual int            cisc_operand() const { return %d; }\n&quot;, cisc_spill_operand());
3963       fprintf(fp_hpp, &quot;  virtual MachNode      *cisc_version(int offset);\n&quot;);
3964       fprintf(fp_hpp, &quot;  virtual void           use_cisc_RegMask();\n&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="main.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="output_h.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/adlc/formsopt.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="dfa.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="formsopt.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/adlc/formsopt.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 63 // record a new register class
 64 AllocClass *RegisterForm::addAllocClass(char *className) {
 65   AllocClass *allocClass = new AllocClass(className);
 66   _aclasses.addName(className);
 67   _allocClass.Insert(className,allocClass);
 68   return allocClass;
 69 }
 70 
 71 // Called after parsing the Register block.  Record the register class
 72 // for spill-slots/regs.
 73 void RegisterForm::addSpillRegClass() {
 74   // Stack slots start at the next available even register number.
 75   _reg_ctr = (_reg_ctr+7) &amp; ~7;
 76   const char *rc_name = &quot;stack_slots&quot;;
 77   RegClass* reg_class = new RegClass(rc_name);
 78   reg_class-&gt;set_stack_version(true);
 79   _rclasses.addName(rc_name);
 80   _regClass.Insert(rc_name,reg_class);
 81 }
 82 









 83 
 84 // Provide iteration over all register definitions
 85 // in the order used by the register allocator
 86 void        RegisterForm::reset_RegDefs() {
 87   _current_ac = NULL;
 88   _aclasses.reset();
 89 }
 90 
 91 RegDef     *RegisterForm::iter_RegDefs() {
 92   // Check if we need to get the next AllocClass
 93   if ( _current_ac == NULL ) {
 94     const char *ac_name = _aclasses.iter();
 95     if( ac_name == NULL )   return NULL;   // No more allocation classes
 96     _current_ac = (AllocClass*)_allocClass[ac_name];
 97     _current_ac-&gt;_regDefs.reset();
 98     assert( _current_ac != NULL, &quot;Name must match an allocation class&quot;);
 99   }
100 
101   const char *rd_name = _current_ac-&gt;_regDefs.iter();
102   if( rd_name == NULL ) {
</pre>
</td>
<td>
<hr />
<pre>
 63 // record a new register class
 64 AllocClass *RegisterForm::addAllocClass(char *className) {
 65   AllocClass *allocClass = new AllocClass(className);
 66   _aclasses.addName(className);
 67   _allocClass.Insert(className,allocClass);
 68   return allocClass;
 69 }
 70 
 71 // Called after parsing the Register block.  Record the register class
 72 // for spill-slots/regs.
 73 void RegisterForm::addSpillRegClass() {
 74   // Stack slots start at the next available even register number.
 75   _reg_ctr = (_reg_ctr+7) &amp; ~7;
 76   const char *rc_name = &quot;stack_slots&quot;;
 77   RegClass* reg_class = new RegClass(rc_name);
 78   reg_class-&gt;set_stack_version(true);
 79   _rclasses.addName(rc_name);
 80   _regClass.Insert(rc_name,reg_class);
 81 }
 82 
<span class="line-added"> 83 // Called after parsing the Register block.  Record the register class</span>
<span class="line-added"> 84 // for operands which are overwritten after matching.</span>
<span class="line-added"> 85 void RegisterForm::addDynamicRegClass() {</span>
<span class="line-added"> 86   const char *rc_name = &quot;dynamic&quot;;</span>
<span class="line-added"> 87   RegClass* reg_class = new RegClass(rc_name);</span>
<span class="line-added"> 88   reg_class-&gt;set_stack_version(false);</span>
<span class="line-added"> 89   _rclasses.addName(rc_name);</span>
<span class="line-added"> 90   _regClass.Insert(rc_name,reg_class);</span>
<span class="line-added"> 91 }</span>
 92 
 93 // Provide iteration over all register definitions
 94 // in the order used by the register allocator
 95 void        RegisterForm::reset_RegDefs() {
 96   _current_ac = NULL;
 97   _aclasses.reset();
 98 }
 99 
100 RegDef     *RegisterForm::iter_RegDefs() {
101   // Check if we need to get the next AllocClass
102   if ( _current_ac == NULL ) {
103     const char *ac_name = _aclasses.iter();
104     if( ac_name == NULL )   return NULL;   // No more allocation classes
105     _current_ac = (AllocClass*)_allocClass[ac_name];
106     _current_ac-&gt;_regDefs.reset();
107     assert( _current_ac != NULL, &quot;Name must match an allocation class&quot;);
108   }
109 
110   const char *rd_name = _current_ac-&gt;_regDefs.iter();
111   if( rd_name == NULL ) {
</pre>
</td>
</tr>
</table>
<center><a href="dfa.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="formsopt.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/code/relocInfo.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/codeCache.hpp&quot;
 27 #include &quot;code/compiledIC.hpp&quot;
 28 #include &quot;code/nmethod.hpp&quot;
 29 #include &quot;code/relocInfo.hpp&quot;
 30 #include &quot;memory/resourceArea.hpp&quot;
<a name="1" id="anc1"></a>
 31 #include &quot;oops/compressedOops.inline.hpp&quot;
 32 #include &quot;runtime/flags/flagSetting.hpp&quot;
 33 #include &quot;runtime/stubCodeGenerator.hpp&quot;
 34 #include &quot;utilities/copy.hpp&quot;
 35 #include &quot;oops/oop.inline.hpp&quot;
 36 
 37 const RelocationHolder RelocationHolder::none; // its type is relocInfo::none
 38 
 39 
 40 // Implementation of relocInfo
 41 
 42 #ifdef ASSERT
 43 relocInfo::relocInfo(relocType t, int off, int f) {
 44   assert(t != data_prefix_tag, &quot;cannot build a prefix this way&quot;);
 45   assert((t &amp; type_mask) == t, &quot;wrong type&quot;);
 46   assert((f &amp; format_mask) == f, &quot;wrong format&quot;);
 47   assert(off &gt;= 0 &amp;&amp; off &lt; offset_limit(), &quot;offset out off bounds&quot;);
 48   assert((off &amp; (offset_unit-1)) == 0, &quot;misaligned offset&quot;);
 49   (*this) = relocInfo(t, RAW_BITS, off, f);
 50 }
 51 #endif
 52 
 53 void relocInfo::initialize(CodeSection* dest, Relocation* reloc) {
 54   relocInfo* data = this+1;  // here&#39;s where the data might go
 55   dest-&gt;set_locs_end(data);  // sync end: the next call may read dest.locs_end
 56   reloc-&gt;pack_data_to(dest); // maybe write data into locs, advancing locs_end
 57   relocInfo* data_limit = dest-&gt;locs_end();
 58   if (data_limit &gt; data) {
 59     relocInfo suffix = (*this);
 60     data_limit = this-&gt;finish_prefix((short*) data_limit);
 61     // Finish up with the suffix.  (Hack note: pack_data_to might edit this.)
 62     *data_limit = suffix;
 63     dest-&gt;set_locs_end(data_limit+1);
 64   }
 65 }
 66 
 67 relocInfo* relocInfo::finish_prefix(short* prefix_limit) {
 68   assert(sizeof(relocInfo) == sizeof(short), &quot;change this code&quot;);
 69   short* p = (short*)(this+1);
 70   assert(prefix_limit &gt;= p, &quot;must be a valid span of data&quot;);
 71   int plen = prefix_limit - p;
 72   if (plen == 0) {
 73     debug_only(_value = 0xFFFF);
 74     return this;                         // no data: remove self completely
 75   }
 76   if (plen == 1 &amp;&amp; fits_into_immediate(p[0])) {
 77     (*this) = immediate_relocInfo(p[0]); // move data inside self
 78     return this+1;
 79   }
 80   // cannot compact, so just update the count and return the limit pointer
 81   (*this) = prefix_relocInfo(plen);   // write new datalen
 82   assert(data() + datalen() == prefix_limit, &quot;pointers must line up&quot;);
 83   return (relocInfo*)prefix_limit;
 84 }
 85 
 86 void relocInfo::set_type(relocType t) {
 87   int old_offset = addr_offset();
 88   int old_format = format();
 89   (*this) = relocInfo(t, old_offset, old_format);
 90   assert(type()==(int)t, &quot;sanity check&quot;);
 91   assert(addr_offset()==old_offset, &quot;sanity check&quot;);
 92   assert(format()==old_format, &quot;sanity check&quot;);
 93 }
 94 
 95 void relocInfo::change_reloc_info_for_address(RelocIterator *itr, address pc, relocType old_type, relocType new_type) {
 96   bool found = false;
 97   while (itr-&gt;next() &amp;&amp; !found) {
 98     if (itr-&gt;addr() == pc) {
 99       assert(itr-&gt;type()==old_type, &quot;wrong relocInfo type found&quot;);
100       itr-&gt;current()-&gt;set_type(new_type);
101       found=true;
102     }
103   }
104   assert(found, &quot;no relocInfo found for pc&quot;);
105 }
106 
107 
108 // ----------------------------------------------------------------------------------------------------
109 // Implementation of RelocIterator
110 
111 void RelocIterator::initialize(CompiledMethod* nm, address begin, address limit) {
112   initialize_misc();
113 
114   if (nm == NULL &amp;&amp; begin != NULL) {
115     // allow nmethod to be deduced from beginning address
116     CodeBlob* cb = CodeCache::find_blob(begin);
117     nm = (cb != NULL) ? cb-&gt;as_compiled_method_or_null() : NULL;
118   }
119   guarantee(nm != NULL, &quot;must be able to deduce nmethod from other arguments&quot;);
120 
121   _code    = nm;
122   _current = nm-&gt;relocation_begin() - 1;
123   _end     = nm-&gt;relocation_end();
124   _addr    = nm-&gt;content_begin();
125 
126   // Initialize code sections.
127   _section_start[CodeBuffer::SECT_CONSTS] = nm-&gt;consts_begin();
128   _section_start[CodeBuffer::SECT_INSTS ] = nm-&gt;insts_begin() ;
129   _section_start[CodeBuffer::SECT_STUBS ] = nm-&gt;stub_begin()  ;
130 
131   _section_end  [CodeBuffer::SECT_CONSTS] = nm-&gt;consts_end()  ;
132   _section_end  [CodeBuffer::SECT_INSTS ] = nm-&gt;insts_end()   ;
133   _section_end  [CodeBuffer::SECT_STUBS ] = nm-&gt;stub_end()    ;
134 
135   assert(!has_current(), &quot;just checking&quot;);
136   assert(begin == NULL || begin &gt;= nm-&gt;code_begin(), &quot;in bounds&quot;);
137   assert(limit == NULL || limit &lt;= nm-&gt;code_end(),   &quot;in bounds&quot;);
138   set_limits(begin, limit);
139 }
140 
141 
142 RelocIterator::RelocIterator(CodeSection* cs, address begin, address limit) {
143   initialize_misc();
144 
145   _current = cs-&gt;locs_start()-1;
146   _end     = cs-&gt;locs_end();
147   _addr    = cs-&gt;start();
148   _code    = NULL; // Not cb-&gt;blob();
149 
150   CodeBuffer* cb = cs-&gt;outer();
151   assert((int) SECT_LIMIT == CodeBuffer::SECT_LIMIT, &quot;my copy must be equal&quot;);
152   for (int n = (int) CodeBuffer::SECT_FIRST; n &lt; (int) CodeBuffer::SECT_LIMIT; n++) {
153     CodeSection* cs = cb-&gt;code_section(n);
154     _section_start[n] = cs-&gt;start();
155     _section_end  [n] = cs-&gt;end();
156   }
157 
158   assert(!has_current(), &quot;just checking&quot;);
159 
160   assert(begin == NULL || begin &gt;= cs-&gt;start(), &quot;in bounds&quot;);
161   assert(limit == NULL || limit &lt;= cs-&gt;end(),   &quot;in bounds&quot;);
162   set_limits(begin, limit);
163 }
164 
165 bool RelocIterator::addr_in_const() const {
166   const int n = CodeBuffer::SECT_CONSTS;
167   return section_start(n) &lt;= addr() &amp;&amp; addr() &lt; section_end(n);
168 }
169 
170 
171 void RelocIterator::set_limits(address begin, address limit) {
172   _limit = limit;
173 
174   // the limit affects this next stuff:
175   if (begin != NULL) {
176     relocInfo* backup;
177     address    backup_addr;
178     while (true) {
179       backup      = _current;
180       backup_addr = _addr;
181       if (!next() || addr() &gt;= begin) break;
182     }
183     // At this point, either we are at the first matching record,
184     // or else there is no such record, and !has_current().
185     // In either case, revert to the immediatly preceding state.
186     _current = backup;
187     _addr    = backup_addr;
188     set_has_current(false);
189   }
190 }
191 
192 
193 // All the strange bit-encodings are in here.
194 // The idea is to encode relocation data which are small integers
195 // very efficiently (a single extra halfword).  Larger chunks of
196 // relocation data need a halfword header to hold their size.
197 void RelocIterator::advance_over_prefix() {
198   if (_current-&gt;is_datalen()) {
199     _data    = (short*) _current-&gt;data();
200     _datalen =          _current-&gt;datalen();
201     _current += _datalen + 1;   // skip the embedded data &amp; header
202   } else {
203     _databuf = _current-&gt;immediate();
204     _data = &amp;_databuf;
205     _datalen = 1;
206     _current++;                 // skip the header
207   }
208   // The client will see the following relocInfo, whatever that is.
209   // It is the reloc to which the preceding data applies.
210 }
211 
212 
213 void RelocIterator::initialize_misc() {
214   set_has_current(false);
215   for (int i = (int) CodeBuffer::SECT_FIRST; i &lt; (int) CodeBuffer::SECT_LIMIT; i++) {
216     _section_start[i] = NULL;  // these will be lazily computed, if needed
217     _section_end  [i] = NULL;
218   }
219 }
220 
221 
222 Relocation* RelocIterator::reloc() {
223   // (take the &quot;switch&quot; out-of-line)
224   relocInfo::relocType t = type();
225   if (false) {}
226   #define EACH_TYPE(name)                             \
227   else if (t == relocInfo::name##_type) {             \
228     return name##_reloc();                            \
229   }
230   APPLY_TO_RELOCATIONS(EACH_TYPE);
231   #undef EACH_TYPE
232   assert(t == relocInfo::none, &quot;must be padding&quot;);
233   return new(_rh) Relocation();
234 }
235 
236 
237 //////// Methods for flyweight Relocation types
238 
239 
240 RelocationHolder RelocationHolder::plus(int offset) const {
241   if (offset != 0) {
242     switch (type()) {
243     case relocInfo::none:
244       break;
245     case relocInfo::oop_type:
246       {
247         oop_Relocation* r = (oop_Relocation*)reloc();
248         return oop_Relocation::spec(r-&gt;oop_index(), r-&gt;offset() + offset);
249       }
250     case relocInfo::metadata_type:
251       {
252         metadata_Relocation* r = (metadata_Relocation*)reloc();
253         return metadata_Relocation::spec(r-&gt;metadata_index(), r-&gt;offset() + offset);
254       }
255     default:
256       ShouldNotReachHere();
257     }
258   }
259   return (*this);
260 }
261 
262 
263 void Relocation::guarantee_size() {
264   guarantee(false, &quot;Make _relocbuf bigger!&quot;);
265 }
266 
267     // some relocations can compute their own values
268 address Relocation::value() {
269   ShouldNotReachHere();
270   return NULL;
271 }
272 
273 
274 void Relocation::set_value(address x) {
275   ShouldNotReachHere();
276 }
277 
278 void Relocation::const_set_data_value(address x) {
279 #ifdef _LP64
280   if (format() == relocInfo::narrow_oop_in_const) {
281     *(narrowOop*)addr() = CompressedOops::encode((oop) x);
282   } else {
283 #endif
284     *(address*)addr() = x;
285 #ifdef _LP64
286   }
287 #endif
288 }
289 
290 void Relocation::const_verify_data_value(address x) {
291 #ifdef _LP64
292   if (format() == relocInfo::narrow_oop_in_const) {
293     guarantee(*(narrowOop*)addr() == CompressedOops::encode((oop) x), &quot;must agree&quot;);
294   } else {
295 #endif
296     guarantee(*(address*)addr() == x, &quot;must agree&quot;);
297 #ifdef _LP64
298   }
299 #endif
300 }
301 
302 
303 RelocationHolder Relocation::spec_simple(relocInfo::relocType rtype) {
304   if (rtype == relocInfo::none)  return RelocationHolder::none;
305   relocInfo ri = relocInfo(rtype, 0);
306   RelocIterator itr;
307   itr.set_current(ri);
308   itr.reloc();
309   return itr._rh;
310 }
311 
312 address Relocation::old_addr_for(address newa,
313                                  const CodeBuffer* src, CodeBuffer* dest) {
314   int sect = dest-&gt;section_index_of(newa);
315   guarantee(sect != CodeBuffer::SECT_NONE, &quot;lost track of this address&quot;);
316   address ostart = src-&gt;code_section(sect)-&gt;start();
317   address nstart = dest-&gt;code_section(sect)-&gt;start();
318   return ostart + (newa - nstart);
319 }
320 
321 address Relocation::new_addr_for(address olda,
322                                  const CodeBuffer* src, CodeBuffer* dest) {
323   debug_only(const CodeBuffer* src0 = src);
324   int sect = CodeBuffer::SECT_NONE;
325   // Look for olda in the source buffer, and all previous incarnations
326   // if the source buffer has been expanded.
327   for (; src != NULL; src = src-&gt;before_expand()) {
328     sect = src-&gt;section_index_of(olda);
329     if (sect != CodeBuffer::SECT_NONE)  break;
330   }
331   guarantee(sect != CodeBuffer::SECT_NONE, &quot;lost track of this address&quot;);
332   address ostart = src-&gt;code_section(sect)-&gt;start();
333   address nstart = dest-&gt;code_section(sect)-&gt;start();
334   return nstart + (olda - ostart);
335 }
336 
337 void Relocation::normalize_address(address&amp; addr, const CodeSection* dest, bool allow_other_sections) {
338   address addr0 = addr;
339   if (addr0 == NULL || dest-&gt;allocates2(addr0))  return;
340   CodeBuffer* cb = dest-&gt;outer();
341   addr = new_addr_for(addr0, cb, cb);
342   assert(allow_other_sections || dest-&gt;contains2(addr),
343          &quot;addr must be in required section&quot;);
344 }
345 
346 
347 void CallRelocation::set_destination(address x) {
348   pd_set_call_destination(x);
349 }
350 
351 void CallRelocation::fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest) {
352   // Usually a self-relative reference to an external routine.
353   // On some platforms, the reference is absolute (not self-relative).
354   // The enhanced use of pd_call_destination sorts this all out.
355   address orig_addr = old_addr_for(addr(), src, dest);
356   address callee    = pd_call_destination(orig_addr);
357   // Reassert the callee address, this time in the new copy of the code.
358   pd_set_call_destination(callee);
359 }
360 
361 
362 //// pack/unpack methods
363 
364 void oop_Relocation::pack_data_to(CodeSection* dest) {
365   short* p = (short*) dest-&gt;locs_end();
366   p = pack_2_ints_to(p, _oop_index, _offset);
367   dest-&gt;set_locs_end((relocInfo*) p);
368 }
369 
370 
371 void oop_Relocation::unpack_data() {
372   unpack_2_ints(_oop_index, _offset);
373 }
374 
375 void metadata_Relocation::pack_data_to(CodeSection* dest) {
376   short* p = (short*) dest-&gt;locs_end();
377   p = pack_2_ints_to(p, _metadata_index, _offset);
378   dest-&gt;set_locs_end((relocInfo*) p);
379 }
380 
381 
382 void metadata_Relocation::unpack_data() {
383   unpack_2_ints(_metadata_index, _offset);
384 }
385 
386 
387 void virtual_call_Relocation::pack_data_to(CodeSection* dest) {
388   short*  p     = (short*) dest-&gt;locs_end();
389   address point =          dest-&gt;locs_point();
390 
391   normalize_address(_cached_value, dest);
392   jint x0 = scaled_offset_null_special(_cached_value, point);
393   p = pack_2_ints_to(p, x0, _method_index);
394   dest-&gt;set_locs_end((relocInfo*) p);
395 }
396 
397 
398 void virtual_call_Relocation::unpack_data() {
399   jint x0 = 0;
400   unpack_2_ints(x0, _method_index);
401   address point = addr();
402   _cached_value = x0==0? NULL: address_from_scaled_offset(x0, point);
403 }
404 
405 void runtime_call_w_cp_Relocation::pack_data_to(CodeSection * dest) {
406   short* p = pack_1_int_to((short *)dest-&gt;locs_end(), (jint)(_offset &gt;&gt; 2));
407   dest-&gt;set_locs_end((relocInfo*) p);
408 }
409 
410 void runtime_call_w_cp_Relocation::unpack_data() {
411   _offset = unpack_1_int() &lt;&lt; 2;
412 }
413 
414 void static_stub_Relocation::pack_data_to(CodeSection* dest) {
415   short* p = (short*) dest-&gt;locs_end();
416   CodeSection* insts = dest-&gt;outer()-&gt;insts();
417   normalize_address(_static_call, insts);
418   jint is_aot = _is_aot ? 1 : 0;
419   p = pack_2_ints_to(p, scaled_offset(_static_call, insts-&gt;start()), is_aot);
420   dest-&gt;set_locs_end((relocInfo*) p);
421 }
422 
423 void static_stub_Relocation::unpack_data() {
424   address base = binding()-&gt;section_start(CodeBuffer::SECT_INSTS);
425   jint offset;
426   jint is_aot;
427   unpack_2_ints(offset, is_aot);
428   _static_call = address_from_scaled_offset(offset, base);
429   _is_aot = (is_aot == 1);
430 }
431 
432 void trampoline_stub_Relocation::pack_data_to(CodeSection* dest ) {
433   short* p = (short*) dest-&gt;locs_end();
434   CodeSection* insts = dest-&gt;outer()-&gt;insts();
435   normalize_address(_owner, insts);
436   p = pack_1_int_to(p, scaled_offset(_owner, insts-&gt;start()));
437   dest-&gt;set_locs_end((relocInfo*) p);
438 }
439 
440 void trampoline_stub_Relocation::unpack_data() {
441   address base = binding()-&gt;section_start(CodeBuffer::SECT_INSTS);
442   _owner = address_from_scaled_offset(unpack_1_int(), base);
443 }
444 
445 void external_word_Relocation::pack_data_to(CodeSection* dest) {
446   short* p = (short*) dest-&gt;locs_end();
447 #ifndef _LP64
448   p = pack_1_int_to(p, (int32_t) (intptr_t)_target);
449 #else
450   jlong t = (jlong) _target;
451   int32_t lo = low(t);
452   int32_t hi = high(t);
453   p = pack_2_ints_to(p, lo, hi);
454 #endif /* _LP64 */
455   dest-&gt;set_locs_end((relocInfo*) p);
456 }
457 
458 
459 void external_word_Relocation::unpack_data() {
460 #ifndef _LP64
461   _target = (address) (intptr_t)unpack_1_int();
462 #else
463   jint lo, hi;
464   unpack_2_ints(lo, hi);
465   jlong t = jlong_from(hi, lo);;
466   _target = (address) t;
467 #endif /* _LP64 */
468 }
469 
470 
471 void internal_word_Relocation::pack_data_to(CodeSection* dest) {
472   short* p = (short*) dest-&gt;locs_end();
473   normalize_address(_target, dest, true);
474 
475   // Check whether my target address is valid within this section.
476   // If not, strengthen the relocation type to point to another section.
477   int sindex = _section;
478   if (sindex == CodeBuffer::SECT_NONE &amp;&amp; _target != NULL
479       &amp;&amp; (!dest-&gt;allocates(_target) || _target == dest-&gt;locs_point())) {
480     sindex = dest-&gt;outer()-&gt;section_index_of(_target);
481     guarantee(sindex != CodeBuffer::SECT_NONE, &quot;must belong somewhere&quot;);
482     relocInfo* base = dest-&gt;locs_end() - 1;
483     assert(base-&gt;type() == this-&gt;type(), &quot;sanity&quot;);
484     // Change the written type, to be section_word_type instead.
485     base-&gt;set_type(relocInfo::section_word_type);
486   }
487 
488   // Note: An internal_word relocation cannot refer to its own instruction,
489   // because we reserve &quot;0&quot; to mean that the pointer itself is embedded
490   // in the code stream.  We use a section_word relocation for such cases.
491 
492   if (sindex == CodeBuffer::SECT_NONE) {
493     assert(type() == relocInfo::internal_word_type, &quot;must be base class&quot;);
494     guarantee(_target == NULL || dest-&gt;allocates2(_target), &quot;must be within the given code section&quot;);
495     jint x0 = scaled_offset_null_special(_target, dest-&gt;locs_point());
496     assert(!(x0 == 0 &amp;&amp; _target != NULL), &quot;correct encoding of null target&quot;);
497     p = pack_1_int_to(p, x0);
498   } else {
499     assert(_target != NULL, &quot;sanity&quot;);
500     CodeSection* sect = dest-&gt;outer()-&gt;code_section(sindex);
501     guarantee(sect-&gt;allocates2(_target), &quot;must be in correct section&quot;);
502     address base = sect-&gt;start();
503     jint offset = scaled_offset(_target, base);
504     assert((uint)sindex &lt; (uint)CodeBuffer::SECT_LIMIT, &quot;sanity&quot;);
505     assert(CodeBuffer::SECT_LIMIT &lt;= (1 &lt;&lt; section_width), &quot;section_width++&quot;);
506     p = pack_1_int_to(p, (offset &lt;&lt; section_width) | sindex);
507   }
508 
509   dest-&gt;set_locs_end((relocInfo*) p);
510 }
511 
512 
513 void internal_word_Relocation::unpack_data() {
514   jint x0 = unpack_1_int();
515   _target = x0==0? NULL: address_from_scaled_offset(x0, addr());
516   _section = CodeBuffer::SECT_NONE;
517 }
518 
519 
520 void section_word_Relocation::unpack_data() {
521   jint    x      = unpack_1_int();
522   jint    offset = (x &gt;&gt; section_width);
523   int     sindex = (x &amp; ((1&lt;&lt;section_width)-1));
524   address base   = binding()-&gt;section_start(sindex);
525 
526   _section = sindex;
527   _target  = address_from_scaled_offset(offset, base);
528 }
529 
530 //// miscellaneous methods
531 oop* oop_Relocation::oop_addr() {
532   int n = _oop_index;
533   if (n == 0) {
534     // oop is stored in the code stream
535     return (oop*) pd_address_in_code();
536   } else {
537     // oop is stored in table at nmethod::oops_begin
538     return code()-&gt;oop_addr_at(n);
539   }
540 }
541 
542 
543 oop oop_Relocation::oop_value() {
544   oop v = *oop_addr();
545   // clean inline caches store a special pseudo-null
546   if (v == Universe::non_oop_word())  v = NULL;
547   return v;
548 }
549 
550 
551 void oop_Relocation::fix_oop_relocation() {
552   if (!oop_is_immediate()) {
553     // get the oop from the pool, and re-insert it into the instruction:
554     set_value(value());
555   }
556 }
557 
558 
559 void oop_Relocation::verify_oop_relocation() {
560   if (!oop_is_immediate()) {
561     // get the oop from the pool, and re-insert it into the instruction:
562     verify_value(value());
563   }
564 }
565 
566 // meta data versions
567 Metadata** metadata_Relocation::metadata_addr() {
568   int n = _metadata_index;
569   if (n == 0) {
570     // metadata is stored in the code stream
571     return (Metadata**) pd_address_in_code();
572     } else {
573     // metadata is stored in table at nmethod::metadatas_begin
574     return code()-&gt;metadata_addr_at(n);
575     }
576   }
577 
578 
579 Metadata* metadata_Relocation::metadata_value() {
580   Metadata* v = *metadata_addr();
581   // clean inline caches store a special pseudo-null
582   if (v == (Metadata*)Universe::non_oop_word())  v = NULL;
583   return v;
584   }
585 
586 
587 void metadata_Relocation::fix_metadata_relocation() {
588   if (!metadata_is_immediate()) {
589     // get the metadata from the pool, and re-insert it into the instruction:
590     pd_fix_value(value());
591   }
592 }
593 
594 address virtual_call_Relocation::cached_value() {
595   assert(_cached_value != NULL &amp;&amp; _cached_value &lt; addr(), &quot;must precede ic_call&quot;);
596   return _cached_value;
597 }
598 
599 Method* virtual_call_Relocation::method_value() {
600   CompiledMethod* cm = code();
601   if (cm == NULL) return (Method*)NULL;
602   Metadata* m = cm-&gt;metadata_at(_method_index);
603   assert(m != NULL || _method_index == 0, &quot;should be non-null for non-zero index&quot;);
604   assert(m == NULL || m-&gt;is_method(), &quot;not a method&quot;);
605   return (Method*)m;
606 }
607 
608 bool virtual_call_Relocation::clear_inline_cache() {
609   // No stubs for ICs
610   // Clean IC
611   ResourceMark rm;
612   CompiledIC* icache = CompiledIC_at(this);
613   return icache-&gt;set_to_clean();
614 }
615 
616 
617 void opt_virtual_call_Relocation::pack_data_to(CodeSection* dest) {
618   short* p = (short*) dest-&gt;locs_end();
619   p = pack_1_int_to(p, _method_index);
620   dest-&gt;set_locs_end((relocInfo*) p);
621 }
622 
623 void opt_virtual_call_Relocation::unpack_data() {
624   _method_index = unpack_1_int();
625 }
626 
627 Method* opt_virtual_call_Relocation::method_value() {
628   CompiledMethod* cm = code();
629   if (cm == NULL) return (Method*)NULL;
630   Metadata* m = cm-&gt;metadata_at(_method_index);
631   assert(m != NULL || _method_index == 0, &quot;should be non-null for non-zero index&quot;);
632   assert(m == NULL || m-&gt;is_method(), &quot;not a method&quot;);
633   return (Method*)m;
634 }
635 
636 template&lt;typename CompiledICorStaticCall&gt;
637 static bool set_to_clean_no_ic_refill(CompiledICorStaticCall* ic) {
638   guarantee(ic-&gt;set_to_clean(), &quot;Should not need transition stubs&quot;);
639   return true;
640 }
641 
642 bool opt_virtual_call_Relocation::clear_inline_cache() {
643   // No stubs for ICs
644   // Clean IC
645   ResourceMark rm;
646   CompiledIC* icache = CompiledIC_at(this);
647   return set_to_clean_no_ic_refill(icache);
648 }
649 
650 address opt_virtual_call_Relocation::static_stub(bool is_aot) {
651   // search for the static stub who points back to this static call
652   address static_call_addr = addr();
653   RelocIterator iter(code());
654   while (iter.next()) {
655     if (iter.type() == relocInfo::static_stub_type) {
656       static_stub_Relocation* stub_reloc = iter.static_stub_reloc();
657       if (stub_reloc-&gt;static_call() == static_call_addr &amp;&amp; stub_reloc-&gt;is_aot() == is_aot) {
658         return iter.addr();
659       }
660     }
661   }
662   return NULL;
663 }
664 
665 Method* static_call_Relocation::method_value() {
666   CompiledMethod* cm = code();
667   if (cm == NULL) return (Method*)NULL;
668   Metadata* m = cm-&gt;metadata_at(_method_index);
669   assert(m != NULL || _method_index == 0, &quot;should be non-null for non-zero index&quot;);
670   assert(m == NULL || m-&gt;is_method(), &quot;not a method&quot;);
671   return (Method*)m;
672 }
673 
674 void static_call_Relocation::pack_data_to(CodeSection* dest) {
675   short* p = (short*) dest-&gt;locs_end();
676   p = pack_1_int_to(p, _method_index);
677   dest-&gt;set_locs_end((relocInfo*) p);
678 }
679 
680 void static_call_Relocation::unpack_data() {
681   _method_index = unpack_1_int();
682 }
683 
684 bool static_call_Relocation::clear_inline_cache() {
685   // Safe call site info
686   CompiledStaticCall* handler = this-&gt;code()-&gt;compiledStaticCall_at(this);
687   return set_to_clean_no_ic_refill(handler);
688 }
689 
690 
691 address static_call_Relocation::static_stub(bool is_aot) {
692   // search for the static stub who points back to this static call
693   address static_call_addr = addr();
694   RelocIterator iter(code());
695   while (iter.next()) {
696     if (iter.type() == relocInfo::static_stub_type) {
697       static_stub_Relocation* stub_reloc = iter.static_stub_reloc();
698       if (stub_reloc-&gt;static_call() == static_call_addr &amp;&amp; stub_reloc-&gt;is_aot() == is_aot) {
699         return iter.addr();
700       }
701     }
702   }
703   return NULL;
704 }
705 
706 // Finds the trampoline address for a call. If no trampoline stub is
707 // found NULL is returned which can be handled by the caller.
708 address trampoline_stub_Relocation::get_trampoline_for(address call, nmethod* code) {
709   // There are no relocations available when the code gets relocated
710   // because of CodeBuffer expansion.
711   if (code-&gt;relocation_size() == 0)
712     return NULL;
713 
714   RelocIterator iter(code, call);
715   while (iter.next()) {
716     if (iter.type() == relocInfo::trampoline_stub_type) {
717       if (iter.trampoline_stub_reloc()-&gt;owner() == call) {
718         return iter.addr();
719       }
720     }
721   }
722 
723   return NULL;
724 }
725 
726 bool static_stub_Relocation::clear_inline_cache() {
727   // Call stub is only used when calling the interpreted code.
728   // It does not really need to be cleared, except that we want to clean out the methodoop.
729   CompiledDirectStaticCall::set_stub_to_clean(this);
730   return true;
731 }
732 
733 
734 void external_word_Relocation::fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest) {
735   address target = _target;
736   if (target == NULL) {
737     // An absolute embedded reference to an external location,
738     // which means there is nothing to fix here.
739     return;
740   }
741   // Probably this reference is absolute, not relative, so the
742   // following is probably a no-op.
743   assert(src-&gt;section_index_of(target) == CodeBuffer::SECT_NONE, &quot;sanity&quot;);
744   set_value(target);
745 }
746 
747 
748 address external_word_Relocation::target() {
749   address target = _target;
750   if (target == NULL) {
751     target = pd_get_address_from_code();
752   }
753   return target;
754 }
755 
756 
757 void internal_word_Relocation::fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest) {
758   address target = _target;
759   if (target == NULL) {
760     target = new_addr_for(this-&gt;target(), src, dest);
761   }
762   set_value(target);
763 }
764 
765 
766 address internal_word_Relocation::target() {
767   address target = _target;
768   if (target == NULL) {
769     if (addr_in_const()) {
770       target = *(address*)addr();
771     } else {
772       target = pd_get_address_from_code();
773     }
774   }
775   return target;
776 }
777 
778 //---------------------------------------------------------------------------------
779 // Non-product code
780 
781 #ifndef PRODUCT
782 
783 static const char* reloc_type_string(relocInfo::relocType t) {
784   switch (t) {
785   #define EACH_CASE(name) \
786   case relocInfo::name##_type: \
787     return #name;
788 
789   APPLY_TO_RELOCATIONS(EACH_CASE);
790   #undef EACH_CASE
791 
792   case relocInfo::none:
793     return &quot;none&quot;;
794   case relocInfo::data_prefix_tag:
795     return &quot;prefix&quot;;
796   default:
797     return &quot;UNKNOWN RELOC TYPE&quot;;
798   }
799 }
800 
801 
802 void RelocIterator::print_current() {
803   if (!has_current()) {
804     tty-&gt;print_cr(&quot;(no relocs)&quot;);
805     return;
806   }
807   tty-&gt;print(&quot;relocInfo@&quot; INTPTR_FORMAT &quot; [type=%d(%s) addr=&quot; INTPTR_FORMAT &quot; offset=%d&quot;,
808              p2i(_current), type(), reloc_type_string((relocInfo::relocType) type()), p2i(_addr), _current-&gt;addr_offset());
809   if (current()-&gt;format() != 0)
810     tty-&gt;print(&quot; format=%d&quot;, current()-&gt;format());
811   if (datalen() == 1) {
812     tty-&gt;print(&quot; data=%d&quot;, data()[0]);
813   } else if (datalen() &gt; 0) {
814     tty-&gt;print(&quot; data={&quot;);
815     for (int i = 0; i &lt; datalen(); i++) {
816       tty-&gt;print(&quot;%04x&quot;, data()[i] &amp; 0xFFFF);
817     }
818     tty-&gt;print(&quot;}&quot;);
819   }
820   tty-&gt;print(&quot;]&quot;);
821   switch (type()) {
822   case relocInfo::oop_type:
823     {
824       oop_Relocation* r = oop_reloc();
825       oop* oop_addr  = NULL;
826       oop  raw_oop   = NULL;
827       oop  oop_value = NULL;
828       if (code() != NULL || r-&gt;oop_is_immediate()) {
829         oop_addr  = r-&gt;oop_addr();
830         raw_oop   = *oop_addr;
831         oop_value = r-&gt;oop_value();
832       }
833       tty-&gt;print(&quot; | [oop_addr=&quot; INTPTR_FORMAT &quot; *=&quot; INTPTR_FORMAT &quot; offset=%d]&quot;,
834                  p2i(oop_addr), p2i(raw_oop), r-&gt;offset());
835       // Do not print the oop by default--we want this routine to
836       // work even during GC or other inconvenient times.
837       if (WizardMode &amp;&amp; oop_value != NULL) {
838         tty-&gt;print(&quot;oop_value=&quot; INTPTR_FORMAT &quot;: &quot;, p2i(oop_value));
839         if (oopDesc::is_oop(oop_value)) {
840           oop_value-&gt;print_value_on(tty);
841         }
842       }
843       break;
844     }
845   case relocInfo::metadata_type:
846     {
847       metadata_Relocation* r = metadata_reloc();
848       Metadata** metadata_addr  = NULL;
849       Metadata*    raw_metadata   = NULL;
850       Metadata*    metadata_value = NULL;
851       if (code() != NULL || r-&gt;metadata_is_immediate()) {
852         metadata_addr  = r-&gt;metadata_addr();
853         raw_metadata   = *metadata_addr;
854         metadata_value = r-&gt;metadata_value();
855       }
856       tty-&gt;print(&quot; | [metadata_addr=&quot; INTPTR_FORMAT &quot; *=&quot; INTPTR_FORMAT &quot; offset=%d]&quot;,
857                  p2i(metadata_addr), p2i(raw_metadata), r-&gt;offset());
858       if (metadata_value != NULL) {
859         tty-&gt;print(&quot;metadata_value=&quot; INTPTR_FORMAT &quot;: &quot;, p2i(metadata_value));
860         metadata_value-&gt;print_value_on(tty);
861       }
862       break;
863     }
864   case relocInfo::external_word_type:
865   case relocInfo::internal_word_type:
866   case relocInfo::section_word_type:
867     {
868       DataRelocation* r = (DataRelocation*) reloc();
869       tty-&gt;print(&quot; | [target=&quot; INTPTR_FORMAT &quot;]&quot;, p2i(r-&gt;value())); //value==target
870       break;
871     }
872   case relocInfo::static_call_type:
873     {
874       static_call_Relocation* r = (static_call_Relocation*) reloc();
875       tty-&gt;print(&quot; | [destination=&quot; INTPTR_FORMAT &quot; metadata=&quot; INTPTR_FORMAT &quot;]&quot;,
876                  p2i(r-&gt;destination()), p2i(r-&gt;method_value()));
877       break;
878     }
879   case relocInfo::runtime_call_type:
880   case relocInfo::runtime_call_w_cp_type:
881     {
882       CallRelocation* r = (CallRelocation*) reloc();
883       tty-&gt;print(&quot; | [destination=&quot; INTPTR_FORMAT &quot;]&quot;, p2i(r-&gt;destination()));
884       break;
885     }
886   case relocInfo::virtual_call_type:
887     {
888       virtual_call_Relocation* r = (virtual_call_Relocation*) reloc();
889       tty-&gt;print(&quot; | [destination=&quot; INTPTR_FORMAT &quot; cached_value=&quot; INTPTR_FORMAT &quot; metadata=&quot; INTPTR_FORMAT &quot;]&quot;,
890                  p2i(r-&gt;destination()), p2i(r-&gt;cached_value()), p2i(r-&gt;method_value()));
891       break;
892     }
893   case relocInfo::static_stub_type:
894     {
895       static_stub_Relocation* r = (static_stub_Relocation*) reloc();
896       tty-&gt;print(&quot; | [static_call=&quot; INTPTR_FORMAT &quot;]&quot;, p2i(r-&gt;static_call()));
897       break;
898     }
899   case relocInfo::trampoline_stub_type:
900     {
901       trampoline_stub_Relocation* r = (trampoline_stub_Relocation*) reloc();
902       tty-&gt;print(&quot; | [trampoline owner=&quot; INTPTR_FORMAT &quot;]&quot;, p2i(r-&gt;owner()));
903       break;
904     }
905   case relocInfo::opt_virtual_call_type:
906     {
907       opt_virtual_call_Relocation* r = (opt_virtual_call_Relocation*) reloc();
908       tty-&gt;print(&quot; | [destination=&quot; INTPTR_FORMAT &quot; metadata=&quot; INTPTR_FORMAT &quot;]&quot;,
909                  p2i(r-&gt;destination()), p2i(r-&gt;method_value()));
910       break;
911     }
912   default:
913     break;
914   }
915   tty-&gt;cr();
916 }
917 
918 
919 void RelocIterator::print() {
920   RelocIterator save_this = (*this);
921   relocInfo* scan = _current;
922   if (!has_current())  scan += 1;  // nothing to scan here!
923 
924   bool skip_next = has_current();
925   bool got_next;
926   while (true) {
927     got_next = (skip_next || next());
928     skip_next = false;
929 
930     tty-&gt;print(&quot;         @&quot; INTPTR_FORMAT &quot;: &quot;, p2i(scan));
931     relocInfo* newscan = _current+1;
932     if (!has_current())  newscan -= 1;  // nothing to scan here!
933     while (scan &lt; newscan) {
934       tty-&gt;print(&quot;%04x&quot;, *(short*)scan &amp; 0xFFFF);
935       scan++;
936     }
937     tty-&gt;cr();
938 
939     if (!got_next)  break;
940     print_current();
941   }
942 
943   (*this) = save_this;
944 }
945 
946 // For the debugger:
947 extern &quot;C&quot;
948 void print_blob_locs(nmethod* nm) {
949   nm-&gt;print();
950   RelocIterator iter(nm);
951   iter.print();
952 }
953 extern &quot;C&quot;
954 void print_buf_locs(CodeBuffer* cb) {
955   FlagSetting fs(PrintRelocations, true);
956   cb-&gt;print();
957 }
958 #endif // !PRODUCT
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
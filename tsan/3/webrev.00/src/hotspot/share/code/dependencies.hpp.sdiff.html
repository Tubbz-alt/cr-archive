<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/code/dependencies.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="dependencies.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="dependencyContext.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/dependencies.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CODE_DEPENDENCIES_HPP
 26 #define SHARE_CODE_DEPENDENCIES_HPP
 27 
 28 #include &quot;ci/ciCallSite.hpp&quot;
 29 #include &quot;ci/ciKlass.hpp&quot;

 30 #include &quot;ci/ciMethodHandle.hpp&quot;
 31 #include &quot;classfile/systemDictionary.hpp&quot;
 32 #include &quot;code/compressedStream.hpp&quot;
 33 #include &quot;code/nmethod.hpp&quot;
 34 #include &quot;memory/resourceArea.hpp&quot;
 35 #include &quot;runtime/safepointVerifiers.hpp&quot;
 36 #include &quot;utilities/growableArray.hpp&quot;
 37 #include &quot;utilities/hashtable.hpp&quot;
 38 
 39 //** Dependencies represent assertions (approximate invariants) within
 40 // the runtime system, e.g. class hierarchy changes.  An example is an
 41 // assertion that a given method is not overridden; another example is
 42 // that a type has only one concrete subtype.  Compiled code which
 43 // relies on such assertions must be discarded if they are overturned
 44 // by changes in the runtime system.  We can think of these assertions
 45 // as approximate invariants, because we expect them to be overturned
 46 // very infrequently.  We are willing to perform expensive recovery
 47 // operations when they are overturned.  The benefit, of course, is
 48 // performing optimistic optimizations (!) on the object code.
 49 //
</pre>
<hr />
<pre>
324   Dependencies(ciEnv* env) {
325     initialize(env);
326   }
327 #if INCLUDE_JVMCI
328   Dependencies(Arena* arena, OopRecorder* oop_recorder, CompileLog* log);
329 #endif
330 
331  private:
332   // Check for a valid context type.
333   // Enforce the restriction against array types.
334   static void check_ctxk(ciKlass* ctxk) {
335     assert(ctxk-&gt;is_instance_klass(), &quot;java types only&quot;);
336   }
337   static void check_ctxk_concrete(ciKlass* ctxk) {
338     assert(is_concrete_klass(ctxk-&gt;as_instance_klass()), &quot;must be concrete&quot;);
339   }
340   static void check_ctxk_abstract(ciKlass* ctxk) {
341     check_ctxk(ctxk);
342     assert(!is_concrete_klass(ctxk-&gt;as_instance_klass()), &quot;must be abstract&quot;);
343   }



344 
345   void assert_common_1(DepType dept, ciBaseObject* x);
346   void assert_common_2(DepType dept, ciBaseObject* x0, ciBaseObject* x1);
347   void assert_common_3(DepType dept, ciKlass* ctxk, ciBaseObject* x1, ciBaseObject* x2);
348 
349  public:
350   // Adding assertions to a new dependency set at compile time:
351   void assert_evol_method(ciMethod* m);
352   void assert_leaf_type(ciKlass* ctxk);
353   void assert_abstract_with_unique_concrete_subtype(ciKlass* ctxk, ciKlass* conck);
354   void assert_abstract_with_no_concrete_subtype(ciKlass* ctxk);
355   void assert_concrete_with_no_concrete_subtype(ciKlass* ctxk);
356   void assert_unique_concrete_method(ciKlass* ctxk, ciMethod* uniqm);
357   void assert_abstract_with_exclusive_concrete_subtypes(ciKlass* ctxk, ciKlass* k1, ciKlass* k2);
358   void assert_exclusive_concrete_methods(ciKlass* ctxk, ciMethod* m1, ciMethod* m2);
359   void assert_has_no_finalizable_subclasses(ciKlass* ctxk);
360   void assert_call_site_target_value(ciCallSite* call_site, ciMethodHandle* method_handle);
361 
362 #if INCLUDE_JVMCI
363  private:
364   static void check_ctxk(Klass* ctxk) {
365     assert(ctxk-&gt;is_instance_klass(), &quot;java types only&quot;);
366   }
367   static void check_ctxk_abstract(Klass* ctxk) {
368     check_ctxk(ctxk);
369     assert(ctxk-&gt;is_abstract(), &quot;must be abstract&quot;);
370   }




371   void assert_common_1(DepType dept, DepValue x);
372   void assert_common_2(DepType dept, DepValue x0, DepValue x1);
373 
374  public:
375   void assert_evol_method(Method* m);
376   void assert_has_no_finalizable_subclasses(Klass* ctxk);
377   void assert_leaf_type(Klass* ctxk);
378   void assert_unique_concrete_method(Klass* ctxk, Method* uniqm);
379   void assert_abstract_with_unique_concrete_subtype(Klass* ctxk, Klass* conck);
380   void assert_call_site_target_value(oop callSite, oop methodHandle);
381 #endif // INCLUDE_JVMCI
382 
383   // Define whether a given method or type is concrete.
384   // These methods define the term &quot;concrete&quot; as used in this module.
385   // For this module, an &quot;abstract&quot; class is one which is non-concrete.
386   //
387   // Future optimizations may allow some classes to remain
388   // non-concrete until their first instantiation, and allow some
389   // methods to remain non-concrete until their first invocation.
390   // In that case, there would be a middle ground between concrete
</pre>
<hr />
<pre>
451   static Method*   find_unique_concrete_method(Klass* ctxk, Method* m);
452   static int       find_exclusive_concrete_subtypes(Klass* ctxk, int klen, Klass* k[]);
453 
454   // Create the encoding which will be stored in an nmethod.
455   void encode_content_bytes();
456 
457   address content_bytes() {
458     assert(_content_bytes != NULL, &quot;encode it first&quot;);
459     return _content_bytes;
460   }
461   size_t size_in_bytes() {
462     assert(_content_bytes != NULL, &quot;encode it first&quot;);
463     return _size_in_bytes;
464   }
465 
466   OopRecorder* oop_recorder() { return _oop_recorder; }
467   CompileLog*  log()          { return _log; }
468 
469   void copy_to(nmethod* nm);
470 
<span class="line-modified">471   DepType validate_dependencies(CompileTask* task, bool counter_changed, char** failure_detail = NULL);</span>
472 
473   void log_all_dependencies();
474 
475   void log_dependency(DepType dept, GrowableArray&lt;ciBaseObject*&gt;* args) {
476     ResourceMark rm;
477     int argslen = args-&gt;length();
478     write_dependency_to(log(), dept, args);
479     guarantee(argslen == args-&gt;length(),
480               &quot;args array cannot grow inside nested ResoureMark scope&quot;);
481   }
482 
483   void log_dependency(DepType dept,
484                       ciBaseObject* x0,
485                       ciBaseObject* x1 = NULL,
486                       ciBaseObject* x2 = NULL) {
487     if (log() == NULL) {
488       return;
489     }
490     ResourceMark rm;
491     GrowableArray&lt;ciBaseObject*&gt;* ciargs =
</pre>
</td>
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CODE_DEPENDENCIES_HPP
 26 #define SHARE_CODE_DEPENDENCIES_HPP
 27 
 28 #include &quot;ci/ciCallSite.hpp&quot;
 29 #include &quot;ci/ciKlass.hpp&quot;
<span class="line-added"> 30 #include &quot;ci/ciMethod.hpp&quot;</span>
 31 #include &quot;ci/ciMethodHandle.hpp&quot;
 32 #include &quot;classfile/systemDictionary.hpp&quot;
 33 #include &quot;code/compressedStream.hpp&quot;
 34 #include &quot;code/nmethod.hpp&quot;
 35 #include &quot;memory/resourceArea.hpp&quot;
 36 #include &quot;runtime/safepointVerifiers.hpp&quot;
 37 #include &quot;utilities/growableArray.hpp&quot;
 38 #include &quot;utilities/hashtable.hpp&quot;
 39 
 40 //** Dependencies represent assertions (approximate invariants) within
 41 // the runtime system, e.g. class hierarchy changes.  An example is an
 42 // assertion that a given method is not overridden; another example is
 43 // that a type has only one concrete subtype.  Compiled code which
 44 // relies on such assertions must be discarded if they are overturned
 45 // by changes in the runtime system.  We can think of these assertions
 46 // as approximate invariants, because we expect them to be overturned
 47 // very infrequently.  We are willing to perform expensive recovery
 48 // operations when they are overturned.  The benefit, of course, is
 49 // performing optimistic optimizations (!) on the object code.
 50 //
</pre>
<hr />
<pre>
325   Dependencies(ciEnv* env) {
326     initialize(env);
327   }
328 #if INCLUDE_JVMCI
329   Dependencies(Arena* arena, OopRecorder* oop_recorder, CompileLog* log);
330 #endif
331 
332  private:
333   // Check for a valid context type.
334   // Enforce the restriction against array types.
335   static void check_ctxk(ciKlass* ctxk) {
336     assert(ctxk-&gt;is_instance_klass(), &quot;java types only&quot;);
337   }
338   static void check_ctxk_concrete(ciKlass* ctxk) {
339     assert(is_concrete_klass(ctxk-&gt;as_instance_klass()), &quot;must be concrete&quot;);
340   }
341   static void check_ctxk_abstract(ciKlass* ctxk) {
342     check_ctxk(ctxk);
343     assert(!is_concrete_klass(ctxk-&gt;as_instance_klass()), &quot;must be abstract&quot;);
344   }
<span class="line-added">345   static void check_unique_method(ciKlass* ctxk, ciMethod* m) {</span>
<span class="line-added">346     assert(!m-&gt;can_be_statically_bound(ctxk-&gt;as_instance_klass()), &quot;redundant&quot;);</span>
<span class="line-added">347   }</span>
348 
349   void assert_common_1(DepType dept, ciBaseObject* x);
350   void assert_common_2(DepType dept, ciBaseObject* x0, ciBaseObject* x1);
351   void assert_common_3(DepType dept, ciKlass* ctxk, ciBaseObject* x1, ciBaseObject* x2);
352 
353  public:
354   // Adding assertions to a new dependency set at compile time:
355   void assert_evol_method(ciMethod* m);
356   void assert_leaf_type(ciKlass* ctxk);
357   void assert_abstract_with_unique_concrete_subtype(ciKlass* ctxk, ciKlass* conck);
358   void assert_abstract_with_no_concrete_subtype(ciKlass* ctxk);
359   void assert_concrete_with_no_concrete_subtype(ciKlass* ctxk);
360   void assert_unique_concrete_method(ciKlass* ctxk, ciMethod* uniqm);
361   void assert_abstract_with_exclusive_concrete_subtypes(ciKlass* ctxk, ciKlass* k1, ciKlass* k2);
362   void assert_exclusive_concrete_methods(ciKlass* ctxk, ciMethod* m1, ciMethod* m2);
363   void assert_has_no_finalizable_subclasses(ciKlass* ctxk);
364   void assert_call_site_target_value(ciCallSite* call_site, ciMethodHandle* method_handle);
365 
366 #if INCLUDE_JVMCI
367  private:
368   static void check_ctxk(Klass* ctxk) {
369     assert(ctxk-&gt;is_instance_klass(), &quot;java types only&quot;);
370   }
371   static void check_ctxk_abstract(Klass* ctxk) {
372     check_ctxk(ctxk);
373     assert(ctxk-&gt;is_abstract(), &quot;must be abstract&quot;);
374   }
<span class="line-added">375   static void check_unique_method(Klass* ctxk, Method* m) {</span>
<span class="line-added">376     assert(!m-&gt;can_be_statically_bound(InstanceKlass::cast(ctxk)), &quot;redundant&quot;);</span>
<span class="line-added">377   }</span>
<span class="line-added">378 </span>
379   void assert_common_1(DepType dept, DepValue x);
380   void assert_common_2(DepType dept, DepValue x0, DepValue x1);
381 
382  public:
383   void assert_evol_method(Method* m);
384   void assert_has_no_finalizable_subclasses(Klass* ctxk);
385   void assert_leaf_type(Klass* ctxk);
386   void assert_unique_concrete_method(Klass* ctxk, Method* uniqm);
387   void assert_abstract_with_unique_concrete_subtype(Klass* ctxk, Klass* conck);
388   void assert_call_site_target_value(oop callSite, oop methodHandle);
389 #endif // INCLUDE_JVMCI
390 
391   // Define whether a given method or type is concrete.
392   // These methods define the term &quot;concrete&quot; as used in this module.
393   // For this module, an &quot;abstract&quot; class is one which is non-concrete.
394   //
395   // Future optimizations may allow some classes to remain
396   // non-concrete until their first instantiation, and allow some
397   // methods to remain non-concrete until their first invocation.
398   // In that case, there would be a middle ground between concrete
</pre>
<hr />
<pre>
459   static Method*   find_unique_concrete_method(Klass* ctxk, Method* m);
460   static int       find_exclusive_concrete_subtypes(Klass* ctxk, int klen, Klass* k[]);
461 
462   // Create the encoding which will be stored in an nmethod.
463   void encode_content_bytes();
464 
465   address content_bytes() {
466     assert(_content_bytes != NULL, &quot;encode it first&quot;);
467     return _content_bytes;
468   }
469   size_t size_in_bytes() {
470     assert(_content_bytes != NULL, &quot;encode it first&quot;);
471     return _size_in_bytes;
472   }
473 
474   OopRecorder* oop_recorder() { return _oop_recorder; }
475   CompileLog*  log()          { return _log; }
476 
477   void copy_to(nmethod* nm);
478 
<span class="line-modified">479   DepType validate_dependencies(CompileTask* task, char** failure_detail = NULL);</span>
480 
481   void log_all_dependencies();
482 
483   void log_dependency(DepType dept, GrowableArray&lt;ciBaseObject*&gt;* args) {
484     ResourceMark rm;
485     int argslen = args-&gt;length();
486     write_dependency_to(log(), dept, args);
487     guarantee(argslen == args-&gt;length(),
488               &quot;args array cannot grow inside nested ResoureMark scope&quot;);
489   }
490 
491   void log_dependency(DepType dept,
492                       ciBaseObject* x0,
493                       ciBaseObject* x1 = NULL,
494                       ciBaseObject* x2 = NULL) {
495     if (log() == NULL) {
496       return;
497     }
498     ResourceMark rm;
499     GrowableArray&lt;ciBaseObject*&gt;* ciargs =
</pre>
</td>
</tr>
</table>
<center><a href="dependencies.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="dependencyContext.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
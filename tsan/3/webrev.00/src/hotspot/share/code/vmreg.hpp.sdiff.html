<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/code/vmreg.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="vmreg.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vtableStubs.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/vmreg.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CODE_VMREG_HPP
 26 #define SHARE_CODE_VMREG_HPP
 27 
 28 #include &quot;asm/register.hpp&quot;

 29 #include &quot;utilities/globalDefinitions.hpp&quot;
 30 #include &quot;utilities/macros.hpp&quot;
 31 #include &quot;utilities/ostream.hpp&quot;
 32 #ifdef COMPILER2
 33 #include &quot;opto/adlcVMDeps.hpp&quot;
 34 #endif
 35 
 36 //------------------------------VMReg------------------------------------------
 37 // The VM uses &#39;unwarped&#39; stack slots; the compiler uses &#39;warped&#39; stack slots.
 38 // Register numbers below VMRegImpl::stack0 are the same for both.  Register
 39 // numbers above stack0 are either warped (in the compiler) or unwarped
 40 // (in the VM).  Unwarped numbers represent stack indices, offsets from
 41 // the current stack pointer.  Warped numbers are required during compilation
 42 // when we do not yet know how big the frame will be.
 43 
 44 class VMRegImpl;
 45 typedef VMRegImpl* VMReg;
 46 
 47 class VMRegImpl {
 48 // friend class OopMap;
</pre>
<hr />
<pre>
 95   // This really ought to check that the register is &quot;real&quot; in the sense that
 96   // we don&#39;t try and get the VMReg number of a physical register that doesn&#39;t
 97   // have an expressible part. That would be pd specific code
 98   VMReg next() {
 99     assert((is_reg() &amp;&amp; value() &lt; stack0-&gt;value() - 1) || is_stack(), &quot;must be&quot;);
100     return (VMReg)(intptr_t)(value() + 1);
101   }
102   VMReg next(int i) {
103     assert((is_reg() &amp;&amp; value() &lt; stack0-&gt;value() - i) || is_stack(), &quot;must be&quot;);
104     return (VMReg)(intptr_t)(value() + i);
105   }
106   VMReg prev() {
107     assert((is_stack() &amp;&amp; value() &gt; stack0-&gt;value()) || (is_reg() &amp;&amp; value() != 0), &quot;must be&quot;);
108     return (VMReg)(intptr_t)(value() - 1);
109   }
110 
111 
112   intptr_t value() const         {return (intptr_t) this; }
113 
114   void print_on(outputStream* st) const;
<span class="line-modified">115   void print() const { print_on(tty); }</span>
116 
117   // bias a stack slot.
118   // Typically used to adjust a virtual frame slots by amounts that are offset by
119   // amounts that are part of the native abi. The VMReg must be a stack slot
120   // and the result must be also.
121 
122   VMReg bias(int offset) {
123     assert(is_stack(), &quot;must be&quot;);
124     // VMReg res = VMRegImpl::as_VMReg(value() + offset);
125     VMReg res = stack2reg(reg2stack() + offset);
126     assert(res-&gt;is_stack(), &quot;must be&quot;);
127     return res;
128   }
129 
130   // Convert register numbers to stack slots and vice versa
131   static VMReg stack2reg( int idx ) {
132     return (VMReg) (intptr_t) (stack0-&gt;value() + idx);
133   }
134 
135   uintptr_t reg2stack() {
</pre>
</td>
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CODE_VMREG_HPP
 26 #define SHARE_CODE_VMREG_HPP
 27 
 28 #include &quot;asm/register.hpp&quot;
<span class="line-added"> 29 #include &quot;runtime/globals.hpp&quot;</span>
 30 #include &quot;utilities/globalDefinitions.hpp&quot;
 31 #include &quot;utilities/macros.hpp&quot;
 32 #include &quot;utilities/ostream.hpp&quot;
 33 #ifdef COMPILER2
 34 #include &quot;opto/adlcVMDeps.hpp&quot;
 35 #endif
 36 
 37 //------------------------------VMReg------------------------------------------
 38 // The VM uses &#39;unwarped&#39; stack slots; the compiler uses &#39;warped&#39; stack slots.
 39 // Register numbers below VMRegImpl::stack0 are the same for both.  Register
 40 // numbers above stack0 are either warped (in the compiler) or unwarped
 41 // (in the VM).  Unwarped numbers represent stack indices, offsets from
 42 // the current stack pointer.  Warped numbers are required during compilation
 43 // when we do not yet know how big the frame will be.
 44 
 45 class VMRegImpl;
 46 typedef VMRegImpl* VMReg;
 47 
 48 class VMRegImpl {
 49 // friend class OopMap;
</pre>
<hr />
<pre>
 96   // This really ought to check that the register is &quot;real&quot; in the sense that
 97   // we don&#39;t try and get the VMReg number of a physical register that doesn&#39;t
 98   // have an expressible part. That would be pd specific code
 99   VMReg next() {
100     assert((is_reg() &amp;&amp; value() &lt; stack0-&gt;value() - 1) || is_stack(), &quot;must be&quot;);
101     return (VMReg)(intptr_t)(value() + 1);
102   }
103   VMReg next(int i) {
104     assert((is_reg() &amp;&amp; value() &lt; stack0-&gt;value() - i) || is_stack(), &quot;must be&quot;);
105     return (VMReg)(intptr_t)(value() + i);
106   }
107   VMReg prev() {
108     assert((is_stack() &amp;&amp; value() &gt; stack0-&gt;value()) || (is_reg() &amp;&amp; value() != 0), &quot;must be&quot;);
109     return (VMReg)(intptr_t)(value() - 1);
110   }
111 
112 
113   intptr_t value() const         {return (intptr_t) this; }
114 
115   void print_on(outputStream* st) const;
<span class="line-modified">116   void print() const;</span>
117 
118   // bias a stack slot.
119   // Typically used to adjust a virtual frame slots by amounts that are offset by
120   // amounts that are part of the native abi. The VMReg must be a stack slot
121   // and the result must be also.
122 
123   VMReg bias(int offset) {
124     assert(is_stack(), &quot;must be&quot;);
125     // VMReg res = VMRegImpl::as_VMReg(value() + offset);
126     VMReg res = stack2reg(reg2stack() + offset);
127     assert(res-&gt;is_stack(), &quot;must be&quot;);
128     return res;
129   }
130 
131   // Convert register numbers to stack slots and vice versa
132   static VMReg stack2reg( int idx ) {
133     return (VMReg) (intptr_t) (stack0-&gt;value() + idx);
134   }
135 
136   uintptr_t reg2stack() {
</pre>
</td>
</tr>
</table>
<center><a href="vmreg.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vtableStubs.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
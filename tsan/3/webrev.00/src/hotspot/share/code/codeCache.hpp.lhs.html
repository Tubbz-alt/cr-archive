<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/code/codeCache.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CODE_CODECACHE_HPP
 26 #define SHARE_CODE_CODECACHE_HPP
 27 
 28 #include &quot;code/codeBlob.hpp&quot;
 29 #include &quot;code/nmethod.hpp&quot;
 30 #include &quot;gc/shared/gcBehaviours.hpp&quot;
 31 #include &quot;memory/allocation.hpp&quot;
 32 #include &quot;memory/heap.hpp&quot;
 33 #include &quot;oops/instanceKlass.hpp&quot;
 34 #include &quot;oops/oopsHierarchy.hpp&quot;
 35 #include &quot;runtime/mutexLocker.hpp&quot;
 36 
 37 // The CodeCache implements the code cache for various pieces of generated
 38 // code, e.g., compiled java methods, runtime stubs, transition frames, etc.
 39 // The entries in the CodeCache are all CodeBlob&#39;s.
 40 
 41 // -- Implementation --
 42 // The CodeCache consists of one or more CodeHeaps, each of which contains
 43 // CodeBlobs of a specific CodeBlobType. Currently heaps for the following
 44 // types are available:
 45 //  - Non-nmethods: Non-nmethods like Buffers, Adapters and Runtime Stubs
 46 //  - Profiled nmethods: nmethods that are profiled, i.e., those
 47 //    executed at level 2 or 3
 48 //  - Non-Profiled nmethods: nmethods that are not profiled, i.e., those
 49 //    executed at level 1 or 4 and native methods
 50 //  - All: Used for code of all types if code cache segmentation is disabled.
 51 //
 52 // In the rare case of the non-nmethod code heap getting full, non-nmethod code
 53 // will be stored in the non-profiled code heap as a fallback solution.
 54 //
 55 // Depending on the availability of compilers and TieredCompilation there
 56 // may be fewer heaps. The size of the code heaps depends on the values of
 57 // ReservedCodeCacheSize, NonProfiledCodeHeapSize and ProfiledCodeHeapSize
 58 // (see CodeCache::heap_available(..) and CodeCache::initialize_heaps(..)
 59 // for details).
 60 //
 61 // Code cache segmentation is controlled by the flag SegmentedCodeCache.
 62 // If turned off, all code types are stored in a single code heap. By default
 63 // code cache segmentation is turned on if TieredCompilation is enabled and
 64 // ReservedCodeCacheSize &gt;= 240 MB.
 65 //
 66 // All methods of the CodeCache accepting a CodeBlobType only apply to
 67 // CodeBlobs of the given type. For example, iteration over the
 68 // CodeBlobs of a specific type can be done by using CodeCache::first_blob(..)
 69 // and CodeCache::next_blob(..) and providing the corresponding CodeBlobType.
 70 //
 71 // IMPORTANT: If you add new CodeHeaps to the code cache or change the
 72 // existing ones, make sure to adapt the dtrace scripts (jhelper.d) for
 73 // Solaris and BSD.
 74 
 75 class ExceptionCache;
 76 class KlassDepChange;
 77 class OopClosure;
 78 class ShenandoahParallelCodeHeapIterator;
 79 
 80 class CodeCache : AllStatic {
 81   friend class VMStructs;
 82   friend class JVMCIVMStructs;
 83   template &lt;class T, class Filter&gt; friend class CodeBlobIterator;
 84   friend class WhiteBox;
 85   friend class CodeCacheLoader;
 86   friend class ShenandoahParallelCodeHeapIterator;
 87  private:
 88   // CodeHeaps of the cache
 89   static GrowableArray&lt;CodeHeap*&gt;* _heaps;
 90   static GrowableArray&lt;CodeHeap*&gt;* _compiled_heaps;
 91   static GrowableArray&lt;CodeHeap*&gt;* _nmethod_heaps;
 92   static GrowableArray&lt;CodeHeap*&gt;* _allocable_heaps;
 93 
 94   static address _low_bound;                            // Lower bound of CodeHeap addresses
 95   static address _high_bound;                           // Upper bound of CodeHeap addresses
 96   static int _number_of_nmethods_with_dependencies;     // Total number of nmethods with dependencies
 97   static uint8_t _unloading_cycle;                      // Global state for recognizing old nmethods that need to be unloaded
 98 
 99   static ExceptionCache* volatile _exception_cache_purge_list;
100 
101   // CodeHeap management
102   static void initialize_heaps();                             // Initializes the CodeHeaps
103   // Check the code heap sizes set by the user via command line
104   static void check_heap_sizes(size_t non_nmethod_size, size_t profiled_size, size_t non_profiled_size, size_t cache_size, bool all_set);
105   // Creates a new heap with the given name and size, containing CodeBlobs of the given type
106   static void add_heap(ReservedSpace rs, const char* name, int code_blob_type);
107   static CodeHeap* get_code_heap_containing(void* p);         // Returns the CodeHeap containing the given pointer, or NULL
108   static CodeHeap* get_code_heap(const CodeBlob* cb);         // Returns the CodeHeap for the given CodeBlob
109   static CodeHeap* get_code_heap(int code_blob_type);         // Returns the CodeHeap for the given CodeBlobType
110   // Returns the name of the VM option to set the size of the corresponding CodeHeap
111   static const char* get_code_heap_flag_name(int code_blob_type);
112   static ReservedCodeSpace reserve_heap_memory(size_t size);  // Reserves one continuous chunk of memory for the CodeHeaps
113 
114   // Iteration
115   static CodeBlob* first_blob(CodeHeap* heap);                // Returns the first CodeBlob on the given CodeHeap
116   static CodeBlob* first_blob(int code_blob_type);            // Returns the first CodeBlob of the given type
117   static CodeBlob* next_blob(CodeHeap* heap, CodeBlob* cb);   // Returns the next CodeBlob on the given CodeHeap
118 
119   static size_t bytes_allocated_in_freelists();
120   static int    allocated_segments();
121   static size_t freelists_length();
122 
123   // Make private to prevent unsafe calls.  Not all CodeBlob*&#39;s are embedded in a CodeHeap.
124   static bool contains(CodeBlob *p) { fatal(&quot;don&#39;t call me!&quot;); return false; }
125 
126  public:
127   // Initialization
128   static void initialize();
129   static size_t page_size(bool aligned = true, size_t min_pages = 1); // Returns the page size used by the CodeCache
130 
131   static int code_heap_compare(CodeHeap* const &amp;lhs, CodeHeap* const &amp;rhs);
132 
133   static void add_heap(CodeHeap* heap);
134   static const GrowableArray&lt;CodeHeap*&gt;* heaps() { return _heaps; }
135   static const GrowableArray&lt;CodeHeap*&gt;* compiled_heaps() { return _compiled_heaps; }
136   static const GrowableArray&lt;CodeHeap*&gt;* nmethod_heaps() { return _nmethod_heaps; }
137 
138   // Allocation/administration
139   static CodeBlob* allocate(int size, int code_blob_type, int orig_code_blob_type = CodeBlobType::All); // allocates a new CodeBlob
140   static void commit(CodeBlob* cb);                        // called when the allocated CodeBlob has been filled
141   static int  alignment_unit();                            // guaranteed alignment of all CodeBlobs
142   static int  alignment_offset();                          // guaranteed offset of first CodeBlob byte within alignment unit (i.e., allocation header)
143   static void free(CodeBlob* cb);                          // frees a CodeBlob
144   static void free_unused_tail(CodeBlob* cb, size_t used); // frees the unused tail of a CodeBlob (only used by TemplateInterpreter::initialize())
145   static bool contains(void *p);                           // returns whether p is included
146   static bool contains(nmethod* nm);                       // returns whether nm is included
147   static void blobs_do(void f(CodeBlob* cb));              // iterates over all CodeBlobs
148   static void blobs_do(CodeBlobClosure* f);                // iterates over all CodeBlobs
149   static void nmethods_do(void f(nmethod* nm));            // iterates over all nmethods
<a name="1" id="anc1"></a><span class="line-modified">150   static void metadata_do(void f(Metadata* m));            // iterates over metadata in alive nmethods</span>
151 
152   // Lookup
153   static CodeBlob* find_blob(void* start);              // Returns the CodeBlob containing the given address
154   static CodeBlob* find_blob_unsafe(void* start);       // Same as find_blob but does not fail if looking up a zombie method
155   static nmethod*  find_nmethod(void* start);           // Returns the nmethod containing the given address
156   static CompiledMethod* find_compiled(void* start);
157 
158   static int       blob_count();                        // Returns the total number of CodeBlobs in the cache
159   static int       blob_count(int code_blob_type);
160   static int       adapter_count();                     // Returns the total number of Adapters in the cache
161   static int       adapter_count(int code_blob_type);
162   static int       nmethod_count();                     // Returns the total number of nmethods in the cache
163   static int       nmethod_count(int code_blob_type);
164 
165   // GC support
166   static void verify_oops();
167   // If any oops are not marked this method unloads (i.e., breaks root links
168   // to) any unmarked codeBlobs in the cache.  Sets &quot;marked_for_unloading&quot;
169   // to &quot;true&quot; iff some code got unloaded.
170   // &quot;unloading_occurred&quot; controls whether metadata should be cleaned because of class unloading.
171   class UnloadingScope: StackObj {
172     ClosureIsUnloadingBehaviour _is_unloading_behaviour;
<a name="2" id="anc2"></a>
173 
174   public:
175     UnloadingScope(BoolObjectClosure* is_alive);
176     ~UnloadingScope();
177   };
178 
179   static void do_unloading(BoolObjectClosure* is_alive, bool unloading_occurred);
180   static uint8_t unloading_cycle() { return _unloading_cycle; }
181   static void increment_unloading_cycle();
182   static void release_exception_cache(ExceptionCache* entry);
183   static void purge_exception_caches();
184 
185   // Printing/debugging
186   static void print();                           // prints summary
187   static void print_internals();
188   static void print_memory_overhead();
189   static void verify();                          // verifies the code cache
190   static void print_trace(const char* event, CodeBlob* cb, int size = 0) PRODUCT_RETURN;
191   static void print_summary(outputStream* st, bool detailed = true); // Prints a summary of the code cache usage
192   static void log_state(outputStream* st);
193   static const char* get_code_heap_name(int code_blob_type)  { return (heap_available(code_blob_type) ? get_code_heap(code_blob_type)-&gt;name() : &quot;Unused&quot;); }
194   static void report_codemem_full(int code_blob_type, bool print);
195 
196   // Dcmd (Diagnostic commands)
197   static void print_codelist(outputStream* st);
198   static void print_layout(outputStream* st);
199 
200   // The full limits of the codeCache
201   static address low_bound()                          { return _low_bound; }
202   static address low_bound(int code_blob_type);
203   static address high_bound()                         { return _high_bound; }
204   static address high_bound(int code_blob_type);
205 
206   // Have to use far call instructions to call this pc.
207   static bool is_far_target(address pc);
208 
209   // Profiling
210   static size_t capacity();
211   static size_t unallocated_capacity(int code_blob_type);
212   static size_t unallocated_capacity();
213   static size_t max_capacity();
214 
215   static double reverse_free_ratio(int code_blob_type);
216 
217   static void clear_inline_caches();                  // clear all inline caches
218   static void cleanup_inline_caches();                // clean unloaded/zombie nmethods from inline caches
219 
220   // Returns true if an own CodeHeap for the given CodeBlobType is available
221   static bool heap_available(int code_blob_type);
222 
223   // Returns the CodeBlobType for the given CompiledMethod
224   static int get_code_blob_type(CompiledMethod* cm) {
225     return get_code_heap(cm)-&gt;code_blob_type();
226   }
227 
228   static bool code_blob_type_accepts_compiled(int type) {
229     bool result = type == CodeBlobType::All || type &lt;= CodeBlobType::MethodProfiled;
230     AOT_ONLY( result = result || type == CodeBlobType::AOT; )
231     return result;
232   }
233 
234   static bool code_blob_type_accepts_nmethod(int type) {
235     return type == CodeBlobType::All || type &lt;= CodeBlobType::MethodProfiled;
236   }
237 
238   static bool code_blob_type_accepts_allocable(int type) {
239     return type &lt;= CodeBlobType::All;
240   }
241 
242 
243   // Returns the CodeBlobType for the given compilation level
244   static int get_code_blob_type(int comp_level) {
245     if (comp_level == CompLevel_none ||
246         comp_level == CompLevel_simple ||
247         comp_level == CompLevel_full_optimization) {
248       // Non profiled methods
249       return CodeBlobType::MethodNonProfiled;
250     } else if (comp_level == CompLevel_limited_profile ||
251                comp_level == CompLevel_full_profile) {
252       // Profiled methods
253       return CodeBlobType::MethodProfiled;
254     }
255     ShouldNotReachHere();
256     return 0;
257   }
258 
259   static void verify_clean_inline_caches();
260   static void verify_icholder_relocations();
261 
262   // Deoptimization
263  private:
264   static int  mark_for_deoptimization(KlassDepChange&amp; changes);
265 
266  public:
267   static void mark_all_nmethods_for_deoptimization();
268   static int  mark_for_deoptimization(Method* dependee);
269   static void make_marked_nmethods_not_entrant();
270 
271   // Flushing and deoptimization
272   static void flush_dependents_on(InstanceKlass* dependee);
<a name="3" id="anc3"></a>

273   // Flushing and deoptimization in case of evolution
274   static void mark_for_evol_deoptimization(InstanceKlass* dependee);
275   static int  mark_dependents_for_evol_deoptimization();
<a name="4" id="anc4"></a>
276   static void flush_evol_dependents();
<a name="5" id="anc5"></a>


277   // Support for fullspeed debugging
278   static void flush_dependents_on_method(const methodHandle&amp; dependee);
279 
280   // tells how many nmethods have dependencies
281   static int number_of_nmethods_with_dependencies();
282 
283   static int get_codemem_full_count(int code_blob_type) {
284     CodeHeap* heap = get_code_heap(code_blob_type);
285     return (heap != NULL) ? heap-&gt;full_count() : 0;
286   }
287 
288   // CodeHeap State Analytics.
289   // interface methods for CodeHeap printing, called by CompileBroker
<a name="6" id="anc6"></a><span class="line-modified">290   static void aggregate(outputStream *out, const char* granularity);</span>
291   static void discard(outputStream *out);
292   static void print_usedSpace(outputStream *out);
293   static void print_freeSpace(outputStream *out);
294   static void print_count(outputStream *out);
295   static void print_space(outputStream *out);
296   static void print_age(outputStream *out);
297   static void print_names(outputStream *out);
298 };
299 
300 
301 // Iterator to iterate over nmethods in the CodeCache.
302 template &lt;class T, class Filter&gt; class CodeBlobIterator : public StackObj {
303  public:
304   enum LivenessFilter { all_blobs, only_alive, only_alive_and_not_unloading };
305 
306  private:
307   CodeBlob* _code_blob;   // Current CodeBlob
308   GrowableArrayIterator&lt;CodeHeap*&gt; _heap;
309   GrowableArrayIterator&lt;CodeHeap*&gt; _end;
310   bool _only_alive;
311   bool _only_not_unloading;
312 
313  public:
314   CodeBlobIterator(LivenessFilter filter, T* nm = NULL)
315     : _only_alive(filter == only_alive || filter == only_alive_and_not_unloading),
316       _only_not_unloading(filter == only_alive_and_not_unloading)
317   {
318     if (Filter::heaps() == NULL) {
319       return;
320     }
321     _heap = Filter::heaps()-&gt;begin();
322     _end = Filter::heaps()-&gt;end();
323     // If set to NULL, initialized by first call to next()
324     _code_blob = (CodeBlob*)nm;
325     if (nm != NULL) {
326       while(!(*_heap)-&gt;contains_blob(_code_blob)) {
327         ++_heap;
328       }
329       assert((*_heap)-&gt;contains_blob(_code_blob), &quot;match not found&quot;);
330     }
331   }
332 
333   // Advance iterator to next blob
334   bool next() {
335     assert_locked_or_safepoint(CodeCache_lock);
336 
337     for (;;) {
338       // Walk through heaps as required
339       if (!next_blob()) {
340         if (_heap == _end) {
341           return false;
342         }
343         ++_heap;
344         continue;
345       }
346 
347       // Filter is_alive as required
348       if (_only_alive &amp;&amp; !_code_blob-&gt;is_alive()) {
349         continue;
350       }
351 
352       // Filter is_unloading as required
353       if (_only_not_unloading) {
354         CompiledMethod* cm = _code_blob-&gt;as_compiled_method_or_null();
355         if (cm != NULL &amp;&amp; cm-&gt;is_unloading()) {
356           continue;
357         }
358       }
359 
360       return true;
361     }
362   }
363 
364   bool end()  const { return _code_blob == NULL; }
365   T* method() const { return (T*)_code_blob; }
366 
367 private:
368 
369   // Advance iterator to the next blob in the current code heap
370   bool next_blob() {
371     if (_heap == _end) {
372       return false;
373     }
374     CodeHeap *heap = *_heap;
375     // Get first method CodeBlob
376     if (_code_blob == NULL) {
377       _code_blob = CodeCache::first_blob(heap);
378       if (_code_blob == NULL) {
379         return false;
380       } else if (Filter::apply(_code_blob)) {
381         return true;
382       }
383     }
384     // Search for next method CodeBlob
385     _code_blob = CodeCache::next_blob(heap, _code_blob);
386     while (_code_blob != NULL &amp;&amp; !Filter::apply(_code_blob)) {
387       _code_blob = CodeCache::next_blob(heap, _code_blob);
388     }
389     return _code_blob != NULL;
390   }
391 };
392 
393 
394 struct CompiledMethodFilter {
395   static bool apply(CodeBlob* cb) { return cb-&gt;is_compiled(); }
396   static const GrowableArray&lt;CodeHeap*&gt;* heaps() { return CodeCache::compiled_heaps(); }
397 };
398 
399 
400 struct NMethodFilter {
401   static bool apply(CodeBlob* cb) { return cb-&gt;is_nmethod(); }
402   static const GrowableArray&lt;CodeHeap*&gt;* heaps() { return CodeCache::nmethod_heaps(); }
403 };
404 
405 typedef CodeBlobIterator&lt;CompiledMethod, CompiledMethodFilter&gt; CompiledMethodIterator;
406 typedef CodeBlobIterator&lt;nmethod, NMethodFilter&gt; NMethodIterator;
407 
408 #endif // SHARE_CODE_CODECACHE_HPP
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/code/codeBlob.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
 27 #include &quot;code/codeBlob.hpp&quot;
 28 #include &quot;code/codeCache.hpp&quot;
 29 #include &quot;code/icBuffer.hpp&quot;
 30 #include &quot;code/relocInfo.hpp&quot;
 31 #include &quot;code/vtableStubs.hpp&quot;
 32 #include &quot;compiler/disassembler.hpp&quot;
 33 #include &quot;interpreter/bytecode.hpp&quot;
<a name="2" id="anc2"></a>
 34 #include &quot;memory/allocation.inline.hpp&quot;
 35 #include &quot;memory/heap.hpp&quot;
 36 #include &quot;memory/resourceArea.hpp&quot;
 37 #include &quot;oops/oop.inline.hpp&quot;
 38 #include &quot;prims/forte.hpp&quot;
 39 #include &quot;runtime/handles.inline.hpp&quot;
 40 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 41 #include &quot;runtime/mutexLocker.hpp&quot;
 42 #include &quot;runtime/safepoint.hpp&quot;
 43 #include &quot;runtime/sharedRuntime.hpp&quot;
 44 #include &quot;runtime/vframe.hpp&quot;
 45 #include &quot;services/memoryService.hpp&quot;
 46 #include &quot;utilities/align.hpp&quot;
 47 #ifdef COMPILER1
 48 #include &quot;c1/c1_Runtime1.hpp&quot;
 49 #endif
 50 
 51 const char* CodeBlob::compiler_name() const {
 52   return compilertype2name(_type);
 53 }
 54 
 55 unsigned int CodeBlob::align_code_offset(int offset) {
 56   // align the size to CodeEntryAlignment
 57   return
 58     ((offset + (int)CodeHeap::header_size() + (CodeEntryAlignment-1)) &amp; ~(CodeEntryAlignment-1))
 59     - (int)CodeHeap::header_size();
 60 }
 61 
 62 
 63 // This must be consistent with the CodeBlob constructor&#39;s layout actions.
 64 unsigned int CodeBlob::allocation_size(CodeBuffer* cb, int header_size) {
 65   unsigned int size = header_size;
 66   size += align_up(cb-&gt;total_relocation_size(), oopSize);
 67   // align the size to CodeEntryAlignment
 68   size = align_code_offset(size);
 69   size += align_up(cb-&gt;total_content_size(), oopSize);
 70   size += align_up(cb-&gt;total_oop_size(), oopSize);
 71   size += align_up(cb-&gt;total_metadata_size(), oopSize);
 72   return size;
 73 }
 74 
 75 CodeBlob::CodeBlob(const char* name, CompilerType type, const CodeBlobLayout&amp; layout, int frame_complete_offset, int frame_size, ImmutableOopMapSet* oop_maps, bool caller_must_gc_arguments) :
 76   _type(type),
 77   _size(layout.size()),
 78   _header_size(layout.header_size()),
 79   _frame_complete_offset(frame_complete_offset),
 80   _data_offset(layout.data_offset()),
 81   _frame_size(frame_size),
 82   _code_begin(layout.code_begin()),
 83   _code_end(layout.code_end()),
 84   _content_begin(layout.content_begin()),
 85   _data_end(layout.data_end()),
 86   _relocation_begin(layout.relocation_begin()),
 87   _relocation_end(layout.relocation_end()),
 88   _oop_maps(oop_maps),
 89   _caller_must_gc_arguments(caller_must_gc_arguments),
 90   _strings(CodeStrings()),
 91   _name(name)
 92 {
 93   assert(is_aligned(layout.size(),            oopSize), &quot;unaligned size&quot;);
 94   assert(is_aligned(layout.header_size(),     oopSize), &quot;unaligned size&quot;);
 95   assert(is_aligned(layout.relocation_size(), oopSize), &quot;unaligned size&quot;);
 96   assert(layout.code_end() == layout.content_end(), &quot;must be the same - see code_end()&quot;);
 97 #ifdef COMPILER1
 98   // probably wrong for tiered
 99   assert(_frame_size &gt;= -1, &quot;must use frame size or -1 for runtime stubs&quot;);
100 #endif // COMPILER1
101 }
102 
103 CodeBlob::CodeBlob(const char* name, CompilerType type, const CodeBlobLayout&amp; layout, CodeBuffer* cb, int frame_complete_offset, int frame_size, OopMapSet* oop_maps, bool caller_must_gc_arguments) :
104   _type(type),
105   _size(layout.size()),
106   _header_size(layout.header_size()),
107   _frame_complete_offset(frame_complete_offset),
108   _data_offset(layout.data_offset()),
109   _frame_size(frame_size),
110   _code_begin(layout.code_begin()),
111   _code_end(layout.code_end()),
112   _content_begin(layout.content_begin()),
113   _data_end(layout.data_end()),
114   _relocation_begin(layout.relocation_begin()),
115   _relocation_end(layout.relocation_end()),
116   _caller_must_gc_arguments(caller_must_gc_arguments),
117   _strings(CodeStrings()),
118   _name(name)
119 {
120   assert(is_aligned(_size,        oopSize), &quot;unaligned size&quot;);
121   assert(is_aligned(_header_size, oopSize), &quot;unaligned size&quot;);
122   assert(_data_offset &lt;= _size, &quot;codeBlob is too small&quot;);
123   assert(layout.code_end() == layout.content_end(), &quot;must be the same - see code_end()&quot;);
124 
125   set_oop_maps(oop_maps);
126 #ifdef COMPILER1
127   // probably wrong for tiered
128   assert(_frame_size &gt;= -1, &quot;must use frame size or -1 for runtime stubs&quot;);
129 #endif // COMPILER1
130 }
131 
132 
133 // Creates a simple CodeBlob. Sets up the size of the different regions.
134 RuntimeBlob::RuntimeBlob(const char* name, int header_size, int size, int frame_complete, int locs_size)
135   : CodeBlob(name, compiler_none, CodeBlobLayout((address) this, size, header_size, locs_size, size), frame_complete, 0, NULL, false /* caller_must_gc_arguments */)
136 {
137   assert(is_aligned(locs_size, oopSize), &quot;unaligned size&quot;);
138 }
139 
140 
141 // Creates a RuntimeBlob from a CodeBuffer
142 // and copy code and relocation info.
143 RuntimeBlob::RuntimeBlob(
144   const char* name,
145   CodeBuffer* cb,
146   int         header_size,
147   int         size,
148   int         frame_complete,
149   int         frame_size,
150   OopMapSet*  oop_maps,
151   bool        caller_must_gc_arguments
152 ) : CodeBlob(name, compiler_none, CodeBlobLayout((address) this, size, header_size, cb), cb, frame_complete, frame_size, oop_maps, caller_must_gc_arguments) {
153   cb-&gt;copy_code_and_locs_to(this);
154 }
155 
156 void CodeBlob::flush() {
<a name="3" id="anc3"></a><span class="line-modified">157   if (_oop_maps) {</span>
<span class="line-modified">158     FREE_C_HEAP_ARRAY(unsigned char, _oop_maps);</span>
<span class="line-removed">159     _oop_maps = NULL;</span>
<span class="line-removed">160   }</span>
161   _strings.free();
162 }
163 
164 void CodeBlob::set_oop_maps(OopMapSet* p) {
165   // Danger Will Robinson! This method allocates a big
166   // chunk of memory, its your job to free it.
167   if (p != NULL) {
168     _oop_maps = ImmutableOopMapSet::build_from(p);
169   } else {
170     _oop_maps = NULL;
171   }
172 }
173 
174 
175 void RuntimeBlob::trace_new_stub(RuntimeBlob* stub, const char* name1, const char* name2) {
176   // Do not hold the CodeCache lock during name formatting.
177   assert(!CodeCache_lock-&gt;owned_by_self(), &quot;release CodeCache before registering the stub&quot;);
178 
179   if (stub != NULL) {
180     char stub_id[256];
181     assert(strlen(name1) + strlen(name2) &lt; sizeof(stub_id), &quot;&quot;);
182     jio_snprintf(stub_id, sizeof(stub_id), &quot;%s%s&quot;, name1, name2);
183     if (PrintStubCode) {
184       ttyLocker ttyl;
<a name="4" id="anc4"></a>
185       tty-&gt;print_cr(&quot;Decoding %s &quot; INTPTR_FORMAT, stub_id, (intptr_t) stub);
<a name="5" id="anc5"></a><span class="line-modified">186       Disassembler::decode(stub-&gt;code_begin(), stub-&gt;code_end());</span>





187       tty-&gt;cr();
188     }
189     Forte::register_stub(stub_id, stub-&gt;code_begin(), stub-&gt;code_end());
190 
191     if (JvmtiExport::should_post_dynamic_code_generated()) {
192       const char* stub_name = name2;
193       if (name2[0] == &#39;\0&#39;)  stub_name = name1;
194       JvmtiExport::post_dynamic_code_generated(stub_name, stub-&gt;code_begin(), stub-&gt;code_end());
195     }
196   }
197 
198   // Track memory usage statistic after releasing CodeCache_lock
199   MemoryService::track_code_cache_memory_usage();
200 }
201 
202 const ImmutableOopMap* CodeBlob::oop_map_for_return_address(address return_address) {
203   assert(_oop_maps != NULL, &quot;nope&quot;);
204   return _oop_maps-&gt;find_map_at_offset((intptr_t) return_address - (intptr_t) code_begin());
205 }
206 
207 void CodeBlob::print_code() {
208   ResourceMark m;
209   Disassembler::decode(this, tty);
210 }
211 
212 //----------------------------------------------------------------------------------------------------
213 // Implementation of BufferBlob
214 
215 
216 BufferBlob::BufferBlob(const char* name, int size)
217 : RuntimeBlob(name, sizeof(BufferBlob), size, CodeOffsets::frame_never_safe, /*locs_size:*/ 0)
218 {}
219 
220 BufferBlob* BufferBlob::create(const char* name, int buffer_size) {
221   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
222 
223   BufferBlob* blob = NULL;
224   unsigned int size = sizeof(BufferBlob);
225   // align the size to CodeEntryAlignment
226   size = CodeBlob::align_code_offset(size);
227   size += align_up(buffer_size, oopSize);
228   assert(name != NULL, &quot;must provide a name&quot;);
229   {
<a name="6" id="anc6"></a><span class="line-modified">230     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
231     blob = new (size) BufferBlob(name, size);
232   }
233   // Track memory usage statistic after releasing CodeCache_lock
234   MemoryService::track_code_cache_memory_usage();
235 
236   return blob;
237 }
238 
239 
240 BufferBlob::BufferBlob(const char* name, int size, CodeBuffer* cb)
241   : RuntimeBlob(name, cb, sizeof(BufferBlob), size, CodeOffsets::frame_never_safe, 0, NULL)
242 {}
243 
244 BufferBlob* BufferBlob::create(const char* name, CodeBuffer* cb) {
245   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
246 
247   BufferBlob* blob = NULL;
248   unsigned int size = CodeBlob::allocation_size(cb, sizeof(BufferBlob));
249   assert(name != NULL, &quot;must provide a name&quot;);
250   {
<a name="7" id="anc7"></a><span class="line-modified">251     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
252     blob = new (size) BufferBlob(name, size, cb);
253   }
254   // Track memory usage statistic after releasing CodeCache_lock
255   MemoryService::track_code_cache_memory_usage();
256 
257   return blob;
258 }
259 
260 void* BufferBlob::operator new(size_t s, unsigned size) throw() {
261   return CodeCache::allocate(size, CodeBlobType::NonNMethod);
262 }
263 
264 void BufferBlob::free(BufferBlob *blob) {
<a name="8" id="anc8"></a>
265   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
266   blob-&gt;flush();
267   {
<a name="9" id="anc9"></a><span class="line-modified">268     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
269     CodeCache::free((RuntimeBlob*)blob);
270   }
271   // Track memory usage statistic after releasing CodeCache_lock
272   MemoryService::track_code_cache_memory_usage();
273 }
274 
275 
276 //----------------------------------------------------------------------------------------------------
277 // Implementation of AdapterBlob
278 
279 AdapterBlob::AdapterBlob(int size, CodeBuffer* cb) :
280   BufferBlob(&quot;I2C/C2I adapters&quot;, size, cb) {
281   CodeCache::commit(this);
282 }
283 
284 AdapterBlob* AdapterBlob::create(CodeBuffer* cb) {
285   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
286 
287   AdapterBlob* blob = NULL;
288   unsigned int size = CodeBlob::allocation_size(cb, sizeof(AdapterBlob));
289   {
<a name="10" id="anc10"></a><span class="line-modified">290     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
291     blob = new (size) AdapterBlob(size, cb);
292   }
293   // Track memory usage statistic after releasing CodeCache_lock
294   MemoryService::track_code_cache_memory_usage();
295 
296   return blob;
297 }
298 
299 VtableBlob::VtableBlob(const char* name, int size) :
300   BufferBlob(name, size) {
301 }
302 
303 VtableBlob* VtableBlob::create(const char* name, int buffer_size) {
304   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
305 
306   VtableBlob* blob = NULL;
307   unsigned int size = sizeof(VtableBlob);
308   // align the size to CodeEntryAlignment
309   size = align_code_offset(size);
310   size += align_up(buffer_size, oopSize);
311   assert(name != NULL, &quot;must provide a name&quot;);
312   {
<a name="11" id="anc11"></a><span class="line-modified">313     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
314     blob = new (size) VtableBlob(name, size);
315   }
316   // Track memory usage statistic after releasing CodeCache_lock
317   MemoryService::track_code_cache_memory_usage();
318 
319   return blob;
320 }
321 
322 //----------------------------------------------------------------------------------------------------
323 // Implementation of MethodHandlesAdapterBlob
324 
325 MethodHandlesAdapterBlob* MethodHandlesAdapterBlob::create(int buffer_size) {
326   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
327 
328   MethodHandlesAdapterBlob* blob = NULL;
329   unsigned int size = sizeof(MethodHandlesAdapterBlob);
330   // align the size to CodeEntryAlignment
331   size = CodeBlob::align_code_offset(size);
332   size += align_up(buffer_size, oopSize);
333   {
<a name="12" id="anc12"></a><span class="line-modified">334     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
335     blob = new (size) MethodHandlesAdapterBlob(size);
336     if (blob == NULL) {
337       vm_exit_out_of_memory(size, OOM_MALLOC_ERROR, &quot;CodeCache: no room for method handle adapter blob&quot;);
338     }
339   }
340   // Track memory usage statistic after releasing CodeCache_lock
341   MemoryService::track_code_cache_memory_usage();
342 
343   return blob;
344 }
345 
346 //----------------------------------------------------------------------------------------------------
347 // Implementation of RuntimeStub
348 
349 RuntimeStub::RuntimeStub(
350   const char* name,
351   CodeBuffer* cb,
352   int         size,
353   int         frame_complete,
354   int         frame_size,
355   OopMapSet*  oop_maps,
356   bool        caller_must_gc_arguments
357 )
358 : RuntimeBlob(name, cb, sizeof(RuntimeStub), size, frame_complete, frame_size, oop_maps, caller_must_gc_arguments)
359 {
360 }
361 
362 RuntimeStub* RuntimeStub::new_runtime_stub(const char* stub_name,
363                                            CodeBuffer* cb,
364                                            int frame_complete,
365                                            int frame_size,
366                                            OopMapSet* oop_maps,
367                                            bool caller_must_gc_arguments)
368 {
369   RuntimeStub* stub = NULL;
370   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
371   {
<a name="13" id="anc13"></a><span class="line-modified">372     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
373     unsigned int size = CodeBlob::allocation_size(cb, sizeof(RuntimeStub));
374     stub = new (size) RuntimeStub(stub_name, cb, size, frame_complete, frame_size, oop_maps, caller_must_gc_arguments);
375   }
376 
377   trace_new_stub(stub, &quot;RuntimeStub - &quot;, stub_name);
378 
379   return stub;
380 }
381 
382 
383 void* RuntimeStub::operator new(size_t s, unsigned size) throw() {
384   void* p = CodeCache::allocate(size, CodeBlobType::NonNMethod);
385   if (!p) fatal(&quot;Initial size of CodeCache is too small&quot;);
386   return p;
387 }
388 
389 // operator new shared by all singletons:
390 void* SingletonBlob::operator new(size_t s, unsigned size) throw() {
391   void* p = CodeCache::allocate(size, CodeBlobType::NonNMethod);
392   if (!p) fatal(&quot;Initial size of CodeCache is too small&quot;);
393   return p;
394 }
395 
396 
397 //----------------------------------------------------------------------------------------------------
398 // Implementation of DeoptimizationBlob
399 
400 DeoptimizationBlob::DeoptimizationBlob(
401   CodeBuffer* cb,
402   int         size,
403   OopMapSet*  oop_maps,
404   int         unpack_offset,
405   int         unpack_with_exception_offset,
406   int         unpack_with_reexecution_offset,
407   int         frame_size
408 )
409 : SingletonBlob(&quot;DeoptimizationBlob&quot;, cb, sizeof(DeoptimizationBlob), size, frame_size, oop_maps)
410 {
411   _unpack_offset           = unpack_offset;
412   _unpack_with_exception   = unpack_with_exception_offset;
413   _unpack_with_reexecution = unpack_with_reexecution_offset;
414 #ifdef COMPILER1
415   _unpack_with_exception_in_tls   = -1;
416 #endif
417 }
418 
419 
420 DeoptimizationBlob* DeoptimizationBlob::create(
421   CodeBuffer* cb,
422   OopMapSet*  oop_maps,
423   int        unpack_offset,
424   int        unpack_with_exception_offset,
425   int        unpack_with_reexecution_offset,
426   int        frame_size)
427 {
428   DeoptimizationBlob* blob = NULL;
429   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
430   {
<a name="14" id="anc14"></a><span class="line-modified">431     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
432     unsigned int size = CodeBlob::allocation_size(cb, sizeof(DeoptimizationBlob));
433     blob = new (size) DeoptimizationBlob(cb,
434                                          size,
435                                          oop_maps,
436                                          unpack_offset,
437                                          unpack_with_exception_offset,
438                                          unpack_with_reexecution_offset,
439                                          frame_size);
440   }
441 
442   trace_new_stub(blob, &quot;DeoptimizationBlob&quot;);
443 
444   return blob;
445 }
446 
447 
448 //----------------------------------------------------------------------------------------------------
449 // Implementation of UncommonTrapBlob
450 
451 #ifdef COMPILER2
452 UncommonTrapBlob::UncommonTrapBlob(
453   CodeBuffer* cb,
454   int         size,
455   OopMapSet*  oop_maps,
456   int         frame_size
457 )
458 : SingletonBlob(&quot;UncommonTrapBlob&quot;, cb, sizeof(UncommonTrapBlob), size, frame_size, oop_maps)
459 {}
460 
461 
462 UncommonTrapBlob* UncommonTrapBlob::create(
463   CodeBuffer* cb,
464   OopMapSet*  oop_maps,
465   int        frame_size)
466 {
467   UncommonTrapBlob* blob = NULL;
468   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
469   {
<a name="15" id="anc15"></a><span class="line-modified">470     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
471     unsigned int size = CodeBlob::allocation_size(cb, sizeof(UncommonTrapBlob));
472     blob = new (size) UncommonTrapBlob(cb, size, oop_maps, frame_size);
473   }
474 
475   trace_new_stub(blob, &quot;UncommonTrapBlob&quot;);
476 
477   return blob;
478 }
479 
480 
481 #endif // COMPILER2
482 
483 
484 //----------------------------------------------------------------------------------------------------
485 // Implementation of ExceptionBlob
486 
487 #ifdef COMPILER2
488 ExceptionBlob::ExceptionBlob(
489   CodeBuffer* cb,
490   int         size,
491   OopMapSet*  oop_maps,
492   int         frame_size
493 )
494 : SingletonBlob(&quot;ExceptionBlob&quot;, cb, sizeof(ExceptionBlob), size, frame_size, oop_maps)
495 {}
496 
497 
498 ExceptionBlob* ExceptionBlob::create(
499   CodeBuffer* cb,
500   OopMapSet*  oop_maps,
501   int         frame_size)
502 {
503   ExceptionBlob* blob = NULL;
504   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
505   {
<a name="16" id="anc16"></a><span class="line-modified">506     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
507     unsigned int size = CodeBlob::allocation_size(cb, sizeof(ExceptionBlob));
508     blob = new (size) ExceptionBlob(cb, size, oop_maps, frame_size);
509   }
510 
511   trace_new_stub(blob, &quot;ExceptionBlob&quot;);
512 
513   return blob;
514 }
515 
516 
517 #endif // COMPILER2
518 
519 
520 //----------------------------------------------------------------------------------------------------
521 // Implementation of SafepointBlob
522 
523 SafepointBlob::SafepointBlob(
524   CodeBuffer* cb,
525   int         size,
526   OopMapSet*  oop_maps,
527   int         frame_size
528 )
529 : SingletonBlob(&quot;SafepointBlob&quot;, cb, sizeof(SafepointBlob), size, frame_size, oop_maps)
530 {}
531 
532 
533 SafepointBlob* SafepointBlob::create(
534   CodeBuffer* cb,
535   OopMapSet*  oop_maps,
536   int         frame_size)
537 {
538   SafepointBlob* blob = NULL;
539   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
540   {
<a name="17" id="anc17"></a><span class="line-modified">541     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
542     unsigned int size = CodeBlob::allocation_size(cb, sizeof(SafepointBlob));
543     blob = new (size) SafepointBlob(cb, size, oop_maps, frame_size);
544   }
545 
546   trace_new_stub(blob, &quot;SafepointBlob&quot;);
547 
548   return blob;
549 }
550 
551 
552 //----------------------------------------------------------------------------------------------------
553 // Verification and printing
554 
555 void CodeBlob::print_on(outputStream* st) const {
556   st-&gt;print_cr(&quot;[CodeBlob (&quot; INTPTR_FORMAT &quot;)]&quot;, p2i(this));
557   st-&gt;print_cr(&quot;Framesize: %d&quot;, _frame_size);
558 }
559 
<a name="18" id="anc18"></a>

560 void CodeBlob::print_value_on(outputStream* st) const {
561   st-&gt;print_cr(&quot;[CodeBlob]&quot;);
562 }
563 
564 void CodeBlob::dump_for_addr(address addr, outputStream* st, bool verbose) const {
565   if (is_buffer_blob()) {
566     // the interpreter is generated into a buffer blob
567     InterpreterCodelet* i = Interpreter::codelet_containing(addr);
568     if (i != NULL) {
569       st-&gt;print_cr(INTPTR_FORMAT &quot; is at code_begin+%d in an Interpreter codelet&quot;, p2i(addr), (int)(addr - i-&gt;code_begin()));
570       i-&gt;print_on(st);
571       return;
572     }
573     if (Interpreter::contains(addr)) {
574       st-&gt;print_cr(INTPTR_FORMAT &quot; is pointing into interpreter code&quot;
575                    &quot; (not bytecode specific)&quot;, p2i(addr));
576       return;
577     }
578     //
579     if (AdapterHandlerLibrary::contains(this)) {
580       st-&gt;print_cr(INTPTR_FORMAT &quot; is at code_begin+%d in an AdapterHandler&quot;, p2i(addr), (int)(addr - code_begin()));
581       AdapterHandlerLibrary::print_handler_on(st, this);
582     }
583     // the stubroutines are generated into a buffer blob
584     StubCodeDesc* d = StubCodeDesc::desc_for(addr);
585     if (d != NULL) {
586       st-&gt;print_cr(INTPTR_FORMAT &quot; is at begin+%d in a stub&quot;, p2i(addr), (int)(addr - d-&gt;begin()));
587       d-&gt;print_on(st);
588       st-&gt;cr();
589       return;
590     }
591     if (StubRoutines::contains(addr)) {
592       st-&gt;print_cr(INTPTR_FORMAT &quot; is pointing to an (unnamed) stub routine&quot;, p2i(addr));
593       return;
594     }
595     // the InlineCacheBuffer is using stubs generated into a buffer blob
596     if (InlineCacheBuffer::contains(addr)) {
597       st-&gt;print_cr(INTPTR_FORMAT &quot; is pointing into InlineCacheBuffer&quot;, p2i(addr));
598       return;
599     }
600     VtableStub* v = VtableStubs::stub_containing(addr);
601     if (v != NULL) {
602       st-&gt;print_cr(INTPTR_FORMAT &quot; is at entry_point+%d in a vtable stub&quot;, p2i(addr), (int)(addr - v-&gt;entry_point()));
603       v-&gt;print_on(st);
604       st-&gt;cr();
605       return;
606     }
607   }
608   if (is_nmethod()) {
609     nmethod* nm = (nmethod*)this;
610     ResourceMark rm;
611     st-&gt;print(INTPTR_FORMAT &quot; is at entry_point+%d in (nmethod*)&quot; INTPTR_FORMAT,
612               p2i(addr), (int)(addr - nm-&gt;entry_point()), p2i(nm));
613     if (verbose) {
614       st-&gt;print(&quot; for &quot;);
615       nm-&gt;method()-&gt;print_value_on(st);
616     }
617     st-&gt;cr();
618     nm-&gt;print_nmethod(verbose);
619     return;
620   }
621   st-&gt;print_cr(INTPTR_FORMAT &quot; is at code_begin+%d in &quot;, p2i(addr), (int)(addr - code_begin()));
622   print_on(st);
623 }
624 
625 void RuntimeBlob::verify() {
626   ShouldNotReachHere();
627 }
628 
629 void BufferBlob::verify() {
630   // unimplemented
631 }
632 
633 void BufferBlob::print_on(outputStream* st) const {
634   RuntimeBlob::print_on(st);
635   print_value_on(st);
636 }
637 
638 void BufferBlob::print_value_on(outputStream* st) const {
639   st-&gt;print_cr(&quot;BufferBlob (&quot; INTPTR_FORMAT  &quot;) used for %s&quot;, p2i(this), name());
640 }
641 
642 void RuntimeStub::verify() {
643   // unimplemented
644 }
645 
646 void RuntimeStub::print_on(outputStream* st) const {
647   ttyLocker ttyl;
648   RuntimeBlob::print_on(st);
649   st-&gt;print(&quot;Runtime Stub (&quot; INTPTR_FORMAT &quot;): &quot;, p2i(this));
650   st-&gt;print_cr(&quot;%s&quot;, name());
651   Disassembler::decode((RuntimeBlob*)this, st);
652 }
653 
654 void RuntimeStub::print_value_on(outputStream* st) const {
655   st-&gt;print(&quot;RuntimeStub (&quot; INTPTR_FORMAT &quot;): &quot;, p2i(this)); st-&gt;print(&quot;%s&quot;, name());
656 }
657 
658 void SingletonBlob::verify() {
659   // unimplemented
660 }
661 
662 void SingletonBlob::print_on(outputStream* st) const {
663   ttyLocker ttyl;
664   RuntimeBlob::print_on(st);
665   st-&gt;print_cr(&quot;%s&quot;, name());
666   Disassembler::decode((RuntimeBlob*)this, st);
667 }
668 
669 void SingletonBlob::print_value_on(outputStream* st) const {
670   st-&gt;print_cr(&quot;%s&quot;, name());
671 }
672 
673 void DeoptimizationBlob::print_value_on(outputStream* st) const {
674   st-&gt;print_cr(&quot;Deoptimization (frame not available)&quot;);
675 }
<a name="19" id="anc19"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="19" type="hidden" />
</body>
</html>
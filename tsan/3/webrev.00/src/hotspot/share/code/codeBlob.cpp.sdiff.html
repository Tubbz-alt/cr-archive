<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/code/codeBlob.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../classfile/vmSymbols.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="codeBlob.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/codeBlob.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
 27 #include &quot;code/codeBlob.hpp&quot;
 28 #include &quot;code/codeCache.hpp&quot;
 29 #include &quot;code/icBuffer.hpp&quot;
 30 #include &quot;code/relocInfo.hpp&quot;
 31 #include &quot;code/vtableStubs.hpp&quot;
 32 #include &quot;compiler/disassembler.hpp&quot;
 33 #include &quot;interpreter/bytecode.hpp&quot;

 34 #include &quot;memory/allocation.inline.hpp&quot;
 35 #include &quot;memory/heap.hpp&quot;
 36 #include &quot;memory/resourceArea.hpp&quot;
 37 #include &quot;oops/oop.inline.hpp&quot;
 38 #include &quot;prims/forte.hpp&quot;
 39 #include &quot;runtime/handles.inline.hpp&quot;
 40 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 41 #include &quot;runtime/mutexLocker.hpp&quot;
 42 #include &quot;runtime/safepoint.hpp&quot;
 43 #include &quot;runtime/sharedRuntime.hpp&quot;
 44 #include &quot;runtime/vframe.hpp&quot;
 45 #include &quot;services/memoryService.hpp&quot;
 46 #include &quot;utilities/align.hpp&quot;
 47 #ifdef COMPILER1
 48 #include &quot;c1/c1_Runtime1.hpp&quot;
 49 #endif
 50 
 51 const char* CodeBlob::compiler_name() const {
 52   return compilertype2name(_type);
 53 }
</pre>
<hr />
<pre>
137   assert(is_aligned(locs_size, oopSize), &quot;unaligned size&quot;);
138 }
139 
140 
141 // Creates a RuntimeBlob from a CodeBuffer
142 // and copy code and relocation info.
143 RuntimeBlob::RuntimeBlob(
144   const char* name,
145   CodeBuffer* cb,
146   int         header_size,
147   int         size,
148   int         frame_complete,
149   int         frame_size,
150   OopMapSet*  oop_maps,
151   bool        caller_must_gc_arguments
152 ) : CodeBlob(name, compiler_none, CodeBlobLayout((address) this, size, header_size, cb), cb, frame_complete, frame_size, oop_maps, caller_must_gc_arguments) {
153   cb-&gt;copy_code_and_locs_to(this);
154 }
155 
156 void CodeBlob::flush() {
<span class="line-modified">157   if (_oop_maps) {</span>
<span class="line-modified">158     FREE_C_HEAP_ARRAY(unsigned char, _oop_maps);</span>
<span class="line-removed">159     _oop_maps = NULL;</span>
<span class="line-removed">160   }</span>
161   _strings.free();
162 }
163 
164 void CodeBlob::set_oop_maps(OopMapSet* p) {
165   // Danger Will Robinson! This method allocates a big
166   // chunk of memory, its your job to free it.
167   if (p != NULL) {
168     _oop_maps = ImmutableOopMapSet::build_from(p);
169   } else {
170     _oop_maps = NULL;
171   }
172 }
173 
174 
175 void RuntimeBlob::trace_new_stub(RuntimeBlob* stub, const char* name1, const char* name2) {
176   // Do not hold the CodeCache lock during name formatting.
177   assert(!CodeCache_lock-&gt;owned_by_self(), &quot;release CodeCache before registering the stub&quot;);
178 
179   if (stub != NULL) {
180     char stub_id[256];
181     assert(strlen(name1) + strlen(name2) &lt; sizeof(stub_id), &quot;&quot;);
182     jio_snprintf(stub_id, sizeof(stub_id), &quot;%s%s&quot;, name1, name2);
183     if (PrintStubCode) {
184       ttyLocker ttyl;

185       tty-&gt;print_cr(&quot;Decoding %s &quot; INTPTR_FORMAT, stub_id, (intptr_t) stub);
<span class="line-modified">186       Disassembler::decode(stub-&gt;code_begin(), stub-&gt;code_end());</span>





187       tty-&gt;cr();
188     }
189     Forte::register_stub(stub_id, stub-&gt;code_begin(), stub-&gt;code_end());
190 
191     if (JvmtiExport::should_post_dynamic_code_generated()) {
192       const char* stub_name = name2;
193       if (name2[0] == &#39;\0&#39;)  stub_name = name1;
194       JvmtiExport::post_dynamic_code_generated(stub_name, stub-&gt;code_begin(), stub-&gt;code_end());
195     }
196   }
197 
198   // Track memory usage statistic after releasing CodeCache_lock
199   MemoryService::track_code_cache_memory_usage();
200 }
201 
202 const ImmutableOopMap* CodeBlob::oop_map_for_return_address(address return_address) {
203   assert(_oop_maps != NULL, &quot;nope&quot;);
204   return _oop_maps-&gt;find_map_at_offset((intptr_t) return_address - (intptr_t) code_begin());
205 }
206 
</pre>
<hr />
<pre>
210 }
211 
212 //----------------------------------------------------------------------------------------------------
213 // Implementation of BufferBlob
214 
215 
216 BufferBlob::BufferBlob(const char* name, int size)
217 : RuntimeBlob(name, sizeof(BufferBlob), size, CodeOffsets::frame_never_safe, /*locs_size:*/ 0)
218 {}
219 
220 BufferBlob* BufferBlob::create(const char* name, int buffer_size) {
221   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
222 
223   BufferBlob* blob = NULL;
224   unsigned int size = sizeof(BufferBlob);
225   // align the size to CodeEntryAlignment
226   size = CodeBlob::align_code_offset(size);
227   size += align_up(buffer_size, oopSize);
228   assert(name != NULL, &quot;must provide a name&quot;);
229   {
<span class="line-modified">230     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
231     blob = new (size) BufferBlob(name, size);
232   }
233   // Track memory usage statistic after releasing CodeCache_lock
234   MemoryService::track_code_cache_memory_usage();
235 
236   return blob;
237 }
238 
239 
240 BufferBlob::BufferBlob(const char* name, int size, CodeBuffer* cb)
241   : RuntimeBlob(name, cb, sizeof(BufferBlob), size, CodeOffsets::frame_never_safe, 0, NULL)
242 {}
243 
244 BufferBlob* BufferBlob::create(const char* name, CodeBuffer* cb) {
245   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
246 
247   BufferBlob* blob = NULL;
248   unsigned int size = CodeBlob::allocation_size(cb, sizeof(BufferBlob));
249   assert(name != NULL, &quot;must provide a name&quot;);
250   {
<span class="line-modified">251     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
252     blob = new (size) BufferBlob(name, size, cb);
253   }
254   // Track memory usage statistic after releasing CodeCache_lock
255   MemoryService::track_code_cache_memory_usage();
256 
257   return blob;
258 }
259 
260 void* BufferBlob::operator new(size_t s, unsigned size) throw() {
261   return CodeCache::allocate(size, CodeBlobType::NonNMethod);
262 }
263 
264 void BufferBlob::free(BufferBlob *blob) {

265   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
266   blob-&gt;flush();
267   {
<span class="line-modified">268     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
269     CodeCache::free((RuntimeBlob*)blob);
270   }
271   // Track memory usage statistic after releasing CodeCache_lock
272   MemoryService::track_code_cache_memory_usage();
273 }
274 
275 
276 //----------------------------------------------------------------------------------------------------
277 // Implementation of AdapterBlob
278 
279 AdapterBlob::AdapterBlob(int size, CodeBuffer* cb) :
280   BufferBlob(&quot;I2C/C2I adapters&quot;, size, cb) {
281   CodeCache::commit(this);
282 }
283 
284 AdapterBlob* AdapterBlob::create(CodeBuffer* cb) {
285   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
286 
287   AdapterBlob* blob = NULL;
288   unsigned int size = CodeBlob::allocation_size(cb, sizeof(AdapterBlob));
289   {
<span class="line-modified">290     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
291     blob = new (size) AdapterBlob(size, cb);
292   }
293   // Track memory usage statistic after releasing CodeCache_lock
294   MemoryService::track_code_cache_memory_usage();
295 
296   return blob;
297 }
298 
299 VtableBlob::VtableBlob(const char* name, int size) :
300   BufferBlob(name, size) {
301 }
302 
303 VtableBlob* VtableBlob::create(const char* name, int buffer_size) {
304   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
305 
306   VtableBlob* blob = NULL;
307   unsigned int size = sizeof(VtableBlob);
308   // align the size to CodeEntryAlignment
309   size = align_code_offset(size);
310   size += align_up(buffer_size, oopSize);
311   assert(name != NULL, &quot;must provide a name&quot;);
312   {
<span class="line-modified">313     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
314     blob = new (size) VtableBlob(name, size);
315   }
316   // Track memory usage statistic after releasing CodeCache_lock
317   MemoryService::track_code_cache_memory_usage();
318 
319   return blob;
320 }
321 
322 //----------------------------------------------------------------------------------------------------
323 // Implementation of MethodHandlesAdapterBlob
324 
325 MethodHandlesAdapterBlob* MethodHandlesAdapterBlob::create(int buffer_size) {
326   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
327 
328   MethodHandlesAdapterBlob* blob = NULL;
329   unsigned int size = sizeof(MethodHandlesAdapterBlob);
330   // align the size to CodeEntryAlignment
331   size = CodeBlob::align_code_offset(size);
332   size += align_up(buffer_size, oopSize);
333   {
<span class="line-modified">334     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
335     blob = new (size) MethodHandlesAdapterBlob(size);
336     if (blob == NULL) {
337       vm_exit_out_of_memory(size, OOM_MALLOC_ERROR, &quot;CodeCache: no room for method handle adapter blob&quot;);
338     }
339   }
340   // Track memory usage statistic after releasing CodeCache_lock
341   MemoryService::track_code_cache_memory_usage();
342 
343   return blob;
344 }
345 
346 //----------------------------------------------------------------------------------------------------
347 // Implementation of RuntimeStub
348 
349 RuntimeStub::RuntimeStub(
350   const char* name,
351   CodeBuffer* cb,
352   int         size,
353   int         frame_complete,
354   int         frame_size,
355   OopMapSet*  oop_maps,
356   bool        caller_must_gc_arguments
357 )
358 : RuntimeBlob(name, cb, sizeof(RuntimeStub), size, frame_complete, frame_size, oop_maps, caller_must_gc_arguments)
359 {
360 }
361 
362 RuntimeStub* RuntimeStub::new_runtime_stub(const char* stub_name,
363                                            CodeBuffer* cb,
364                                            int frame_complete,
365                                            int frame_size,
366                                            OopMapSet* oop_maps,
367                                            bool caller_must_gc_arguments)
368 {
369   RuntimeStub* stub = NULL;
370   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
371   {
<span class="line-modified">372     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
373     unsigned int size = CodeBlob::allocation_size(cb, sizeof(RuntimeStub));
374     stub = new (size) RuntimeStub(stub_name, cb, size, frame_complete, frame_size, oop_maps, caller_must_gc_arguments);
375   }
376 
377   trace_new_stub(stub, &quot;RuntimeStub - &quot;, stub_name);
378 
379   return stub;
380 }
381 
382 
383 void* RuntimeStub::operator new(size_t s, unsigned size) throw() {
384   void* p = CodeCache::allocate(size, CodeBlobType::NonNMethod);
385   if (!p) fatal(&quot;Initial size of CodeCache is too small&quot;);
386   return p;
387 }
388 
389 // operator new shared by all singletons:
390 void* SingletonBlob::operator new(size_t s, unsigned size) throw() {
391   void* p = CodeCache::allocate(size, CodeBlobType::NonNMethod);
392   if (!p) fatal(&quot;Initial size of CodeCache is too small&quot;);
</pre>
<hr />
<pre>
411   _unpack_offset           = unpack_offset;
412   _unpack_with_exception   = unpack_with_exception_offset;
413   _unpack_with_reexecution = unpack_with_reexecution_offset;
414 #ifdef COMPILER1
415   _unpack_with_exception_in_tls   = -1;
416 #endif
417 }
418 
419 
420 DeoptimizationBlob* DeoptimizationBlob::create(
421   CodeBuffer* cb,
422   OopMapSet*  oop_maps,
423   int        unpack_offset,
424   int        unpack_with_exception_offset,
425   int        unpack_with_reexecution_offset,
426   int        frame_size)
427 {
428   DeoptimizationBlob* blob = NULL;
429   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
430   {
<span class="line-modified">431     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
432     unsigned int size = CodeBlob::allocation_size(cb, sizeof(DeoptimizationBlob));
433     blob = new (size) DeoptimizationBlob(cb,
434                                          size,
435                                          oop_maps,
436                                          unpack_offset,
437                                          unpack_with_exception_offset,
438                                          unpack_with_reexecution_offset,
439                                          frame_size);
440   }
441 
442   trace_new_stub(blob, &quot;DeoptimizationBlob&quot;);
443 
444   return blob;
445 }
446 
447 
448 //----------------------------------------------------------------------------------------------------
449 // Implementation of UncommonTrapBlob
450 
451 #ifdef COMPILER2
452 UncommonTrapBlob::UncommonTrapBlob(
453   CodeBuffer* cb,
454   int         size,
455   OopMapSet*  oop_maps,
456   int         frame_size
457 )
458 : SingletonBlob(&quot;UncommonTrapBlob&quot;, cb, sizeof(UncommonTrapBlob), size, frame_size, oop_maps)
459 {}
460 
461 
462 UncommonTrapBlob* UncommonTrapBlob::create(
463   CodeBuffer* cb,
464   OopMapSet*  oop_maps,
465   int        frame_size)
466 {
467   UncommonTrapBlob* blob = NULL;
468   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
469   {
<span class="line-modified">470     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
471     unsigned int size = CodeBlob::allocation_size(cb, sizeof(UncommonTrapBlob));
472     blob = new (size) UncommonTrapBlob(cb, size, oop_maps, frame_size);
473   }
474 
475   trace_new_stub(blob, &quot;UncommonTrapBlob&quot;);
476 
477   return blob;
478 }
479 
480 
481 #endif // COMPILER2
482 
483 
484 //----------------------------------------------------------------------------------------------------
485 // Implementation of ExceptionBlob
486 
487 #ifdef COMPILER2
488 ExceptionBlob::ExceptionBlob(
489   CodeBuffer* cb,
490   int         size,
491   OopMapSet*  oop_maps,
492   int         frame_size
493 )
494 : SingletonBlob(&quot;ExceptionBlob&quot;, cb, sizeof(ExceptionBlob), size, frame_size, oop_maps)
495 {}
496 
497 
498 ExceptionBlob* ExceptionBlob::create(
499   CodeBuffer* cb,
500   OopMapSet*  oop_maps,
501   int         frame_size)
502 {
503   ExceptionBlob* blob = NULL;
504   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
505   {
<span class="line-modified">506     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
507     unsigned int size = CodeBlob::allocation_size(cb, sizeof(ExceptionBlob));
508     blob = new (size) ExceptionBlob(cb, size, oop_maps, frame_size);
509   }
510 
511   trace_new_stub(blob, &quot;ExceptionBlob&quot;);
512 
513   return blob;
514 }
515 
516 
517 #endif // COMPILER2
518 
519 
520 //----------------------------------------------------------------------------------------------------
521 // Implementation of SafepointBlob
522 
523 SafepointBlob::SafepointBlob(
524   CodeBuffer* cb,
525   int         size,
526   OopMapSet*  oop_maps,
527   int         frame_size
528 )
529 : SingletonBlob(&quot;SafepointBlob&quot;, cb, sizeof(SafepointBlob), size, frame_size, oop_maps)
530 {}
531 
532 
533 SafepointBlob* SafepointBlob::create(
534   CodeBuffer* cb,
535   OopMapSet*  oop_maps,
536   int         frame_size)
537 {
538   SafepointBlob* blob = NULL;
539   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
540   {
<span class="line-modified">541     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
542     unsigned int size = CodeBlob::allocation_size(cb, sizeof(SafepointBlob));
543     blob = new (size) SafepointBlob(cb, size, oop_maps, frame_size);
544   }
545 
546   trace_new_stub(blob, &quot;SafepointBlob&quot;);
547 
548   return blob;
549 }
550 
551 
552 //----------------------------------------------------------------------------------------------------
553 // Verification and printing
554 
555 void CodeBlob::print_on(outputStream* st) const {
556   st-&gt;print_cr(&quot;[CodeBlob (&quot; INTPTR_FORMAT &quot;)]&quot;, p2i(this));
557   st-&gt;print_cr(&quot;Framesize: %d&quot;, _frame_size);
558 }
559 


560 void CodeBlob::print_value_on(outputStream* st) const {
561   st-&gt;print_cr(&quot;[CodeBlob]&quot;);
562 }
563 
564 void CodeBlob::dump_for_addr(address addr, outputStream* st, bool verbose) const {
565   if (is_buffer_blob()) {
566     // the interpreter is generated into a buffer blob
567     InterpreterCodelet* i = Interpreter::codelet_containing(addr);
568     if (i != NULL) {
569       st-&gt;print_cr(INTPTR_FORMAT &quot; is at code_begin+%d in an Interpreter codelet&quot;, p2i(addr), (int)(addr - i-&gt;code_begin()));
570       i-&gt;print_on(st);
571       return;
572     }
573     if (Interpreter::contains(addr)) {
574       st-&gt;print_cr(INTPTR_FORMAT &quot; is pointing into interpreter code&quot;
575                    &quot; (not bytecode specific)&quot;, p2i(addr));
576       return;
577     }
578     //
579     if (AdapterHandlerLibrary::contains(this)) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
 27 #include &quot;code/codeBlob.hpp&quot;
 28 #include &quot;code/codeCache.hpp&quot;
 29 #include &quot;code/icBuffer.hpp&quot;
 30 #include &quot;code/relocInfo.hpp&quot;
 31 #include &quot;code/vtableStubs.hpp&quot;
 32 #include &quot;compiler/disassembler.hpp&quot;
 33 #include &quot;interpreter/bytecode.hpp&quot;
<span class="line-added"> 34 #include &quot;interpreter/interpreter.hpp&quot;</span>
 35 #include &quot;memory/allocation.inline.hpp&quot;
 36 #include &quot;memory/heap.hpp&quot;
 37 #include &quot;memory/resourceArea.hpp&quot;
 38 #include &quot;oops/oop.inline.hpp&quot;
 39 #include &quot;prims/forte.hpp&quot;
 40 #include &quot;runtime/handles.inline.hpp&quot;
 41 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 42 #include &quot;runtime/mutexLocker.hpp&quot;
 43 #include &quot;runtime/safepoint.hpp&quot;
 44 #include &quot;runtime/sharedRuntime.hpp&quot;
 45 #include &quot;runtime/vframe.hpp&quot;
 46 #include &quot;services/memoryService.hpp&quot;
 47 #include &quot;utilities/align.hpp&quot;
 48 #ifdef COMPILER1
 49 #include &quot;c1/c1_Runtime1.hpp&quot;
 50 #endif
 51 
 52 const char* CodeBlob::compiler_name() const {
 53   return compilertype2name(_type);
 54 }
</pre>
<hr />
<pre>
138   assert(is_aligned(locs_size, oopSize), &quot;unaligned size&quot;);
139 }
140 
141 
142 // Creates a RuntimeBlob from a CodeBuffer
143 // and copy code and relocation info.
144 RuntimeBlob::RuntimeBlob(
145   const char* name,
146   CodeBuffer* cb,
147   int         header_size,
148   int         size,
149   int         frame_complete,
150   int         frame_size,
151   OopMapSet*  oop_maps,
152   bool        caller_must_gc_arguments
153 ) : CodeBlob(name, compiler_none, CodeBlobLayout((address) this, size, header_size, cb), cb, frame_complete, frame_size, oop_maps, caller_must_gc_arguments) {
154   cb-&gt;copy_code_and_locs_to(this);
155 }
156 
157 void CodeBlob::flush() {
<span class="line-modified">158   FREE_C_HEAP_ARRAY(unsigned char, _oop_maps);</span>
<span class="line-modified">159   _oop_maps = NULL;</span>


160   _strings.free();
161 }
162 
163 void CodeBlob::set_oop_maps(OopMapSet* p) {
164   // Danger Will Robinson! This method allocates a big
165   // chunk of memory, its your job to free it.
166   if (p != NULL) {
167     _oop_maps = ImmutableOopMapSet::build_from(p);
168   } else {
169     _oop_maps = NULL;
170   }
171 }
172 
173 
174 void RuntimeBlob::trace_new_stub(RuntimeBlob* stub, const char* name1, const char* name2) {
175   // Do not hold the CodeCache lock during name formatting.
176   assert(!CodeCache_lock-&gt;owned_by_self(), &quot;release CodeCache before registering the stub&quot;);
177 
178   if (stub != NULL) {
179     char stub_id[256];
180     assert(strlen(name1) + strlen(name2) &lt; sizeof(stub_id), &quot;&quot;);
181     jio_snprintf(stub_id, sizeof(stub_id), &quot;%s%s&quot;, name1, name2);
182     if (PrintStubCode) {
183       ttyLocker ttyl;
<span class="line-added">184       tty-&gt;print_cr(&quot;- - - [BEGIN] - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -&quot;);</span>
185       tty-&gt;print_cr(&quot;Decoding %s &quot; INTPTR_FORMAT, stub_id, (intptr_t) stub);
<span class="line-modified">186       Disassembler::decode(stub-&gt;code_begin(), stub-&gt;code_end(), tty);</span>
<span class="line-added">187       if ((stub-&gt;oop_maps() != NULL) &amp;&amp; AbstractDisassembler::show_structs()) {</span>
<span class="line-added">188         tty-&gt;print_cr(&quot;- - - [OOP MAPS]- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -&quot;);</span>
<span class="line-added">189         stub-&gt;oop_maps()-&gt;print();</span>
<span class="line-added">190       }</span>
<span class="line-added">191       tty-&gt;print_cr(&quot;- - - [END] - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -&quot;);</span>
192       tty-&gt;cr();
193     }
194     Forte::register_stub(stub_id, stub-&gt;code_begin(), stub-&gt;code_end());
195 
196     if (JvmtiExport::should_post_dynamic_code_generated()) {
197       const char* stub_name = name2;
198       if (name2[0] == &#39;\0&#39;)  stub_name = name1;
199       JvmtiExport::post_dynamic_code_generated(stub_name, stub-&gt;code_begin(), stub-&gt;code_end());
200     }
201   }
202 
203   // Track memory usage statistic after releasing CodeCache_lock
204   MemoryService::track_code_cache_memory_usage();
205 }
206 
207 const ImmutableOopMap* CodeBlob::oop_map_for_return_address(address return_address) {
208   assert(_oop_maps != NULL, &quot;nope&quot;);
209   return _oop_maps-&gt;find_map_at_offset((intptr_t) return_address - (intptr_t) code_begin());
210 }
211 
</pre>
<hr />
<pre>
215 }
216 
217 //----------------------------------------------------------------------------------------------------
218 // Implementation of BufferBlob
219 
220 
221 BufferBlob::BufferBlob(const char* name, int size)
222 : RuntimeBlob(name, sizeof(BufferBlob), size, CodeOffsets::frame_never_safe, /*locs_size:*/ 0)
223 {}
224 
225 BufferBlob* BufferBlob::create(const char* name, int buffer_size) {
226   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
227 
228   BufferBlob* blob = NULL;
229   unsigned int size = sizeof(BufferBlob);
230   // align the size to CodeEntryAlignment
231   size = CodeBlob::align_code_offset(size);
232   size += align_up(buffer_size, oopSize);
233   assert(name != NULL, &quot;must provide a name&quot;);
234   {
<span class="line-modified">235     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
236     blob = new (size) BufferBlob(name, size);
237   }
238   // Track memory usage statistic after releasing CodeCache_lock
239   MemoryService::track_code_cache_memory_usage();
240 
241   return blob;
242 }
243 
244 
245 BufferBlob::BufferBlob(const char* name, int size, CodeBuffer* cb)
246   : RuntimeBlob(name, cb, sizeof(BufferBlob), size, CodeOffsets::frame_never_safe, 0, NULL)
247 {}
248 
249 BufferBlob* BufferBlob::create(const char* name, CodeBuffer* cb) {
250   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
251 
252   BufferBlob* blob = NULL;
253   unsigned int size = CodeBlob::allocation_size(cb, sizeof(BufferBlob));
254   assert(name != NULL, &quot;must provide a name&quot;);
255   {
<span class="line-modified">256     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
257     blob = new (size) BufferBlob(name, size, cb);
258   }
259   // Track memory usage statistic after releasing CodeCache_lock
260   MemoryService::track_code_cache_memory_usage();
261 
262   return blob;
263 }
264 
265 void* BufferBlob::operator new(size_t s, unsigned size) throw() {
266   return CodeCache::allocate(size, CodeBlobType::NonNMethod);
267 }
268 
269 void BufferBlob::free(BufferBlob *blob) {
<span class="line-added">270   assert(blob != NULL, &quot;caller must check for NULL&quot;);</span>
271   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
272   blob-&gt;flush();
273   {
<span class="line-modified">274     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
275     CodeCache::free((RuntimeBlob*)blob);
276   }
277   // Track memory usage statistic after releasing CodeCache_lock
278   MemoryService::track_code_cache_memory_usage();
279 }
280 
281 
282 //----------------------------------------------------------------------------------------------------
283 // Implementation of AdapterBlob
284 
285 AdapterBlob::AdapterBlob(int size, CodeBuffer* cb) :
286   BufferBlob(&quot;I2C/C2I adapters&quot;, size, cb) {
287   CodeCache::commit(this);
288 }
289 
290 AdapterBlob* AdapterBlob::create(CodeBuffer* cb) {
291   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
292 
293   AdapterBlob* blob = NULL;
294   unsigned int size = CodeBlob::allocation_size(cb, sizeof(AdapterBlob));
295   {
<span class="line-modified">296     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
297     blob = new (size) AdapterBlob(size, cb);
298   }
299   // Track memory usage statistic after releasing CodeCache_lock
300   MemoryService::track_code_cache_memory_usage();
301 
302   return blob;
303 }
304 
305 VtableBlob::VtableBlob(const char* name, int size) :
306   BufferBlob(name, size) {
307 }
308 
309 VtableBlob* VtableBlob::create(const char* name, int buffer_size) {
310   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
311 
312   VtableBlob* blob = NULL;
313   unsigned int size = sizeof(VtableBlob);
314   // align the size to CodeEntryAlignment
315   size = align_code_offset(size);
316   size += align_up(buffer_size, oopSize);
317   assert(name != NULL, &quot;must provide a name&quot;);
318   {
<span class="line-modified">319     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
320     blob = new (size) VtableBlob(name, size);
321   }
322   // Track memory usage statistic after releasing CodeCache_lock
323   MemoryService::track_code_cache_memory_usage();
324 
325   return blob;
326 }
327 
328 //----------------------------------------------------------------------------------------------------
329 // Implementation of MethodHandlesAdapterBlob
330 
331 MethodHandlesAdapterBlob* MethodHandlesAdapterBlob::create(int buffer_size) {
332   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
333 
334   MethodHandlesAdapterBlob* blob = NULL;
335   unsigned int size = sizeof(MethodHandlesAdapterBlob);
336   // align the size to CodeEntryAlignment
337   size = CodeBlob::align_code_offset(size);
338   size += align_up(buffer_size, oopSize);
339   {
<span class="line-modified">340     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
341     blob = new (size) MethodHandlesAdapterBlob(size);
342     if (blob == NULL) {
343       vm_exit_out_of_memory(size, OOM_MALLOC_ERROR, &quot;CodeCache: no room for method handle adapter blob&quot;);
344     }
345   }
346   // Track memory usage statistic after releasing CodeCache_lock
347   MemoryService::track_code_cache_memory_usage();
348 
349   return blob;
350 }
351 
352 //----------------------------------------------------------------------------------------------------
353 // Implementation of RuntimeStub
354 
355 RuntimeStub::RuntimeStub(
356   const char* name,
357   CodeBuffer* cb,
358   int         size,
359   int         frame_complete,
360   int         frame_size,
361   OopMapSet*  oop_maps,
362   bool        caller_must_gc_arguments
363 )
364 : RuntimeBlob(name, cb, sizeof(RuntimeStub), size, frame_complete, frame_size, oop_maps, caller_must_gc_arguments)
365 {
366 }
367 
368 RuntimeStub* RuntimeStub::new_runtime_stub(const char* stub_name,
369                                            CodeBuffer* cb,
370                                            int frame_complete,
371                                            int frame_size,
372                                            OopMapSet* oop_maps,
373                                            bool caller_must_gc_arguments)
374 {
375   RuntimeStub* stub = NULL;
376   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
377   {
<span class="line-modified">378     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
379     unsigned int size = CodeBlob::allocation_size(cb, sizeof(RuntimeStub));
380     stub = new (size) RuntimeStub(stub_name, cb, size, frame_complete, frame_size, oop_maps, caller_must_gc_arguments);
381   }
382 
383   trace_new_stub(stub, &quot;RuntimeStub - &quot;, stub_name);
384 
385   return stub;
386 }
387 
388 
389 void* RuntimeStub::operator new(size_t s, unsigned size) throw() {
390   void* p = CodeCache::allocate(size, CodeBlobType::NonNMethod);
391   if (!p) fatal(&quot;Initial size of CodeCache is too small&quot;);
392   return p;
393 }
394 
395 // operator new shared by all singletons:
396 void* SingletonBlob::operator new(size_t s, unsigned size) throw() {
397   void* p = CodeCache::allocate(size, CodeBlobType::NonNMethod);
398   if (!p) fatal(&quot;Initial size of CodeCache is too small&quot;);
</pre>
<hr />
<pre>
417   _unpack_offset           = unpack_offset;
418   _unpack_with_exception   = unpack_with_exception_offset;
419   _unpack_with_reexecution = unpack_with_reexecution_offset;
420 #ifdef COMPILER1
421   _unpack_with_exception_in_tls   = -1;
422 #endif
423 }
424 
425 
426 DeoptimizationBlob* DeoptimizationBlob::create(
427   CodeBuffer* cb,
428   OopMapSet*  oop_maps,
429   int        unpack_offset,
430   int        unpack_with_exception_offset,
431   int        unpack_with_reexecution_offset,
432   int        frame_size)
433 {
434   DeoptimizationBlob* blob = NULL;
435   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
436   {
<span class="line-modified">437     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
438     unsigned int size = CodeBlob::allocation_size(cb, sizeof(DeoptimizationBlob));
439     blob = new (size) DeoptimizationBlob(cb,
440                                          size,
441                                          oop_maps,
442                                          unpack_offset,
443                                          unpack_with_exception_offset,
444                                          unpack_with_reexecution_offset,
445                                          frame_size);
446   }
447 
448   trace_new_stub(blob, &quot;DeoptimizationBlob&quot;);
449 
450   return blob;
451 }
452 
453 
454 //----------------------------------------------------------------------------------------------------
455 // Implementation of UncommonTrapBlob
456 
457 #ifdef COMPILER2
458 UncommonTrapBlob::UncommonTrapBlob(
459   CodeBuffer* cb,
460   int         size,
461   OopMapSet*  oop_maps,
462   int         frame_size
463 )
464 : SingletonBlob(&quot;UncommonTrapBlob&quot;, cb, sizeof(UncommonTrapBlob), size, frame_size, oop_maps)
465 {}
466 
467 
468 UncommonTrapBlob* UncommonTrapBlob::create(
469   CodeBuffer* cb,
470   OopMapSet*  oop_maps,
471   int        frame_size)
472 {
473   UncommonTrapBlob* blob = NULL;
474   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
475   {
<span class="line-modified">476     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
477     unsigned int size = CodeBlob::allocation_size(cb, sizeof(UncommonTrapBlob));
478     blob = new (size) UncommonTrapBlob(cb, size, oop_maps, frame_size);
479   }
480 
481   trace_new_stub(blob, &quot;UncommonTrapBlob&quot;);
482 
483   return blob;
484 }
485 
486 
487 #endif // COMPILER2
488 
489 
490 //----------------------------------------------------------------------------------------------------
491 // Implementation of ExceptionBlob
492 
493 #ifdef COMPILER2
494 ExceptionBlob::ExceptionBlob(
495   CodeBuffer* cb,
496   int         size,
497   OopMapSet*  oop_maps,
498   int         frame_size
499 )
500 : SingletonBlob(&quot;ExceptionBlob&quot;, cb, sizeof(ExceptionBlob), size, frame_size, oop_maps)
501 {}
502 
503 
504 ExceptionBlob* ExceptionBlob::create(
505   CodeBuffer* cb,
506   OopMapSet*  oop_maps,
507   int         frame_size)
508 {
509   ExceptionBlob* blob = NULL;
510   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
511   {
<span class="line-modified">512     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
513     unsigned int size = CodeBlob::allocation_size(cb, sizeof(ExceptionBlob));
514     blob = new (size) ExceptionBlob(cb, size, oop_maps, frame_size);
515   }
516 
517   trace_new_stub(blob, &quot;ExceptionBlob&quot;);
518 
519   return blob;
520 }
521 
522 
523 #endif // COMPILER2
524 
525 
526 //----------------------------------------------------------------------------------------------------
527 // Implementation of SafepointBlob
528 
529 SafepointBlob::SafepointBlob(
530   CodeBuffer* cb,
531   int         size,
532   OopMapSet*  oop_maps,
533   int         frame_size
534 )
535 : SingletonBlob(&quot;SafepointBlob&quot;, cb, sizeof(SafepointBlob), size, frame_size, oop_maps)
536 {}
537 
538 
539 SafepointBlob* SafepointBlob::create(
540   CodeBuffer* cb,
541   OopMapSet*  oop_maps,
542   int         frame_size)
543 {
544   SafepointBlob* blob = NULL;
545   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
546   {
<span class="line-modified">547     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
548     unsigned int size = CodeBlob::allocation_size(cb, sizeof(SafepointBlob));
549     blob = new (size) SafepointBlob(cb, size, oop_maps, frame_size);
550   }
551 
552   trace_new_stub(blob, &quot;SafepointBlob&quot;);
553 
554   return blob;
555 }
556 
557 
558 //----------------------------------------------------------------------------------------------------
559 // Verification and printing
560 
561 void CodeBlob::print_on(outputStream* st) const {
562   st-&gt;print_cr(&quot;[CodeBlob (&quot; INTPTR_FORMAT &quot;)]&quot;, p2i(this));
563   st-&gt;print_cr(&quot;Framesize: %d&quot;, _frame_size);
564 }
565 
<span class="line-added">566 void CodeBlob::print() const { print_on(tty); }</span>
<span class="line-added">567 </span>
568 void CodeBlob::print_value_on(outputStream* st) const {
569   st-&gt;print_cr(&quot;[CodeBlob]&quot;);
570 }
571 
572 void CodeBlob::dump_for_addr(address addr, outputStream* st, bool verbose) const {
573   if (is_buffer_blob()) {
574     // the interpreter is generated into a buffer blob
575     InterpreterCodelet* i = Interpreter::codelet_containing(addr);
576     if (i != NULL) {
577       st-&gt;print_cr(INTPTR_FORMAT &quot; is at code_begin+%d in an Interpreter codelet&quot;, p2i(addr), (int)(addr - i-&gt;code_begin()));
578       i-&gt;print_on(st);
579       return;
580     }
581     if (Interpreter::contains(addr)) {
582       st-&gt;print_cr(INTPTR_FORMAT &quot; is pointing into interpreter code&quot;
583                    &quot; (not bytecode specific)&quot;, p2i(addr));
584       return;
585     }
586     //
587     if (AdapterHandlerLibrary::contains(this)) {
</pre>
</td>
</tr>
</table>
<center><a href="../classfile/vmSymbols.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="codeBlob.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/code/codeHeapState.cpp b/src/hotspot/share/code/codeHeapState.cpp
--- a/src/hotspot/share/code/codeHeapState.cpp
+++ b/src/hotspot/share/code/codeHeapState.cpp
@@ -25,10 +25,11 @@
 
 #include "precompiled.hpp"
 #include "code/codeHeapState.hpp"
 #include "compiler/compileBroker.hpp"
 #include "runtime/sweeper.hpp"
+#include "utilities/powerOfTwo.hpp"
 
 // -------------------------
 // |  General Description  |
 // -------------------------
 // The CodeHeap state analytics are divided in two parts.
@@ -122,11 +123,11 @@
     size_t     _nforcedflush = 0;                             \
     size_t      _nsavedflush = 0;                             \
     size_t     _nlockedflush = 0;                             \
     size_t     _nflush_bytes = 0;                             \
     size_t         _capacity = _capa;                         \
-    bufferedStream   _sstobj = bufferedStream(_capa);         \
+    bufferedStream   _sstobj(_capa);                          \
     bufferedStream*  _sstbuf = &_sstobj;                      \
     outputStream*    _outbuf = _outst;                        \
     bufferedStream*   _anyst = &_sstobj; /* any stream. Use this to just print - no buffer flush.  */
 
 // Same as above, but with fixed buffer size.
@@ -528,11 +529,11 @@
     }
     nHeaps = 0;
   }
 }
 
-void CodeHeapState::aggregate(outputStream* out, CodeHeap* heap, const char* granularity_request) {
+void CodeHeapState::aggregate(outputStream* out, CodeHeap* heap, size_t granularity) {
   unsigned int nBlocks_free    = 0;
   unsigned int nBlocks_used    = 0;
   unsigned int nBlocks_zomb    = 0;
   unsigned int nBlocks_disconn = 0;
   unsigned int nBlocks_notentr = 0;
@@ -610,11 +611,12 @@
   //   keep the amount of allocated storage in check.
   //
   //   Finally, we adjust the granularity such that each granule covers at most 64k-1 segments.
   //   This is necessary to prevent an unsigned short overflow while accumulating space information.
   //
-  size_t granularity = strtol(granularity_request, NULL, 0);
+  assert(granularity > 0, "granularity should be positive.");
+
   if (granularity > size) {
     granularity = size;
   }
   if (size/granularity < min_granules) {
     granularity = size/min_granules;                                   // at least min_granules granules

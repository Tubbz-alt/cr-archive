<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/code/nmethod.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="nmethod.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oopRecorder.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/nmethod.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 28,10 ***</span>
<span class="line-new-header">--- 28,11 ---</span>
  #include &quot;code/compiledMethod.hpp&quot;
  
  class DepChange;
  class DirectiveSet;
  class DebugInformationRecorder;
<span class="line-added">+ class JvmtiThreadState;</span>
  
  // nmethods (native methods) are the compiled code versions of Java methods.
  //
  // An nmethod contains:
  //  - header                 (the nmethod structure)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 49,46 ***</span>
  //  - pcs
  //  [Exception handler table]
  //  - handler entry point array
  //  [Implicit Null Pointer exception table]
  //  - implicit null table array
  
  class nmethod : public CompiledMethod {
    friend class VMStructs;
    friend class JVMCIVMStructs;
    friend class NMethodSweeper;
    friend class CodeCache;  // scavengable oops
<span class="line-modified">!  private:</span>
  
    // Shared fields for all nmethod&#39;s
    int       _entry_bci;        // != InvocationEntryBci if this nmethod is an on-stack replacement method
<span class="line-removed">-   jmethodID _jmethod_id;       // Cache of method()-&gt;jmethod_id()</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if INCLUDE_JVMCI</span>
<span class="line-removed">-   // A weak reference to an InstalledCode object associated with</span>
<span class="line-removed">-   // this nmethod.</span>
<span class="line-removed">-   jweak     _jvmci_installed_code;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // A weak reference to a SpeculationLog object associated with</span>
<span class="line-removed">-   // this nmethod.</span>
<span class="line-removed">-   jweak     _speculation_log;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Determines whether this nmethod is unloaded when the</span>
<span class="line-removed">-   // referent in _jvmci_installed_code is cleared. This</span>
<span class="line-removed">-   // will be false if the referent is initialized to a</span>
<span class="line-removed">-   // HotSpotNMethod object whose isDefault field is true.</span>
<span class="line-removed">-   // That is, installed code other than a &quot;default&quot;</span>
<span class="line-removed">-   // HotSpotNMethod causes nmethod unloading.</span>
<span class="line-removed">-   // This field is ignored once _jvmci_installed_code is NULL.</span>
<span class="line-removed">-   bool _jvmci_installed_code_triggers_invalidation;</span>
<span class="line-removed">- #endif</span>
  
    // To support simple linked-list chaining of nmethods:
    nmethod*  _osr_link;         // from InstanceKlass::osr_nmethods_head
  
    static nmethod* volatile _oops_do_mark_nmethods;
<span class="line-modified">!   nmethod*        volatile _oops_do_mark_link;</span>
  
    // offsets for entry points
    address _entry_point;                      // entry point with class check
    address _verified_entry_point;             // entry point without class check
    address _osr_entry_point;                  // entry point for on stack replacement
<span class="line-new-header">--- 50,147 ---</span>
  //  - pcs
  //  [Exception handler table]
  //  - handler entry point array
  //  [Implicit Null Pointer exception table]
  //  - implicit null table array
<span class="line-added">+ //  [Speculations]</span>
<span class="line-added">+ //  - encoded speculations array</span>
<span class="line-added">+ //  [JVMCINMethodData]</span>
<span class="line-added">+ //  - meta data for JVMCI compiled nmethod</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if INCLUDE_JVMCI</span>
<span class="line-added">+ class FailedSpeculation;</span>
<span class="line-added">+ class JVMCINMethodData;</span>
<span class="line-added">+ #endif</span>
  
  class nmethod : public CompiledMethod {
    friend class VMStructs;
    friend class JVMCIVMStructs;
    friend class NMethodSweeper;
    friend class CodeCache;  // scavengable oops
<span class="line-modified">!   friend class JVMCINMethodData;</span>
  
<span class="line-added">+  private:</span>
    // Shared fields for all nmethod&#39;s
    int       _entry_bci;        // != InvocationEntryBci if this nmethod is an on-stack replacement method
  
    // To support simple linked-list chaining of nmethods:
    nmethod*  _osr_link;         // from InstanceKlass::osr_nmethods_head
  
<span class="line-added">+   // STW two-phase nmethod root processing helpers.</span>
<span class="line-added">+   //</span>
<span class="line-added">+   // When determining liveness of a given nmethod to do code cache unloading,</span>
<span class="line-added">+   // some collectors need to to different things depending on whether the nmethods</span>
<span class="line-added">+   // need to absolutely be kept alive during root processing; &quot;strong&quot;ly reachable</span>
<span class="line-added">+   // nmethods are known to be kept alive at root processing, but the liveness of</span>
<span class="line-added">+   // &quot;weak&quot;ly reachable ones is to be determined later.</span>
<span class="line-added">+   //</span>
<span class="line-added">+   // We want to allow strong and weak processing of nmethods by different threads</span>
<span class="line-added">+   // at the same time without heavy synchronization. Additional constraints are</span>
<span class="line-added">+   // to make sure that every nmethod is processed a minimal amount of time, and</span>
<span class="line-added">+   // nmethods themselves are always iterated at most once at a particular time.</span>
<span class="line-added">+   //</span>
<span class="line-added">+   // Note that strong processing work must be a superset of weak processing work</span>
<span class="line-added">+   // for this code to work.</span>
<span class="line-added">+   //</span>
<span class="line-added">+   // We store state and claim information in the _oops_do_mark_link member, using</span>
<span class="line-added">+   // the two LSBs for the state and the remaining upper bits for linking together</span>
<span class="line-added">+   // nmethods that were already visited.</span>
<span class="line-added">+   // The last element is self-looped, i.e. points to itself to avoid some special</span>
<span class="line-added">+   // &quot;end-of-list&quot; sentinel value.</span>
<span class="line-added">+   //</span>
<span class="line-added">+   // _oops_do_mark_link special values:</span>
<span class="line-added">+   //</span>
<span class="line-added">+   //   _oops_do_mark_link == NULL: the nmethod has not been visited at all yet, i.e.</span>
<span class="line-added">+   //      is Unclaimed.</span>
<span class="line-added">+   //</span>
<span class="line-added">+   // For other values, its lowest two bits indicate the following states of the nmethod:</span>
<span class="line-added">+   //</span>
<span class="line-added">+   //   weak_request (WR): the nmethod has been claimed by a thread for weak processing</span>
<span class="line-added">+   //   weak_done (WD): weak processing has been completed for this nmethod.</span>
<span class="line-added">+   //   strong_request (SR): the nmethod has been found to need strong processing while</span>
<span class="line-added">+   //       being weak processed.</span>
<span class="line-added">+   //   strong_done (SD): strong processing has been completed for this nmethod .</span>
<span class="line-added">+   //</span>
<span class="line-added">+   // The following shows the _only_ possible progressions of the _oops_do_mark_link</span>
<span class="line-added">+   // pointer.</span>
<span class="line-added">+   //</span>
<span class="line-added">+   // Given</span>
<span class="line-added">+   //   N as the nmethod</span>
<span class="line-added">+   //   X the current next value of _oops_do_mark_link</span>
<span class="line-added">+   //</span>
<span class="line-added">+   // Unclaimed (C)-&gt; N|WR (C)-&gt; X|WD: the nmethod has been processed weakly by</span>
<span class="line-added">+   //   a single thread.</span>
<span class="line-added">+   // Unclaimed (C)-&gt; N|WR (C)-&gt; X|WD (O)-&gt; X|SD: after weak processing has been</span>
<span class="line-added">+   //   completed (as above) another thread found that the nmethod needs strong</span>
<span class="line-added">+   //   processing after all.</span>
<span class="line-added">+   // Unclaimed (C)-&gt; N|WR (O)-&gt; N|SR (C)-&gt; X|SD: during weak processing another</span>
<span class="line-added">+   //   thread finds that the nmethod needs strong processing, marks it as such and</span>
<span class="line-added">+   //   terminates. The original thread completes strong processing.</span>
<span class="line-added">+   // Unclaimed (C)-&gt; N|SD (C)-&gt; X|SD: the nmethod has been processed strongly from</span>
<span class="line-added">+   //   the beginning by a single thread.</span>
<span class="line-added">+   //</span>
<span class="line-added">+   // &quot;|&quot; describes the concatentation of bits in _oops_do_mark_link.</span>
<span class="line-added">+   //</span>
<span class="line-added">+   // The diagram also describes the threads responsible for changing the nmethod to</span>
<span class="line-added">+   // the next state by marking the _transition_ with (C) and (O), which mean &quot;current&quot;</span>
<span class="line-added">+   // and &quot;other&quot; thread respectively.</span>
<span class="line-added">+   //</span>
<span class="line-added">+   struct oops_do_mark_link; // Opaque data type.</span>
<span class="line-added">+ </span>
<span class="line-added">+   // States used for claiming nmethods during root processing.</span>
<span class="line-added">+   static const uint claim_weak_request_tag = 0;</span>
<span class="line-added">+   static const uint claim_weak_done_tag = 1;</span>
<span class="line-added">+   static const uint claim_strong_request_tag = 2;</span>
<span class="line-added">+   static const uint claim_strong_done_tag = 3;</span>
<span class="line-added">+ </span>
<span class="line-added">+   static oops_do_mark_link* mark_link(nmethod* nm, uint tag) {</span>
<span class="line-added">+     assert(tag &lt;= claim_strong_done_tag, &quot;invalid tag %u&quot;, tag);</span>
<span class="line-added">+     assert(is_aligned(nm, 4), &quot;nmethod pointer must have zero lower two LSB&quot;);</span>
<span class="line-added">+     return (oops_do_mark_link*)(((uintptr_t)nm &amp; ~0x3) | tag);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   static uint extract_state(oops_do_mark_link* link) {</span>
<span class="line-added">+     return (uint)((uintptr_t)link &amp; 0x3);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   static nmethod* extract_nmethod(oops_do_mark_link* link) {</span>
<span class="line-added">+     return (nmethod*)((uintptr_t)link &amp; ~0x3);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void oops_do_log_change(const char* state);</span>
<span class="line-added">+ </span>
<span class="line-added">+   static bool oops_do_has_weak_request(oops_do_mark_link* next) {</span>
<span class="line-added">+     return extract_state(next) == claim_weak_request_tag;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   static bool oops_do_has_any_strong_state(oops_do_mark_link* next) {</span>
<span class="line-added">+     return extract_state(next) &gt;= claim_strong_request_tag;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Attempt Unclaimed -&gt; N|WR transition. Returns true if successful.</span>
<span class="line-added">+   bool oops_do_try_claim_weak_request();</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Attempt Unclaimed -&gt; N|SD transition. Returns the current link.</span>
<span class="line-added">+   oops_do_mark_link* oops_do_try_claim_strong_done();</span>
<span class="line-added">+   // Attempt N|WR -&gt; X|WD transition. Returns NULL if successful, X otherwise.</span>
<span class="line-added">+   nmethod* oops_do_try_add_to_list_as_weak_done();</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Attempt X|WD -&gt; N|SR transition. Returns the current link.</span>
<span class="line-added">+   oops_do_mark_link* oops_do_try_add_strong_request(oops_do_mark_link* next);</span>
<span class="line-added">+   // Attempt X|WD -&gt; X|SD transition. Returns true if successful.</span>
<span class="line-added">+   bool oops_do_try_claim_weak_done_as_strong_done(oops_do_mark_link* next);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Do the N|SD -&gt; X|SD transition.</span>
<span class="line-added">+   void oops_do_add_to_list_as_strong_done();</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Sets this nmethod as strongly claimed (as part of N|SD -&gt; X|SD and N|SR -&gt; X|SD</span>
<span class="line-added">+   // transitions).</span>
<span class="line-added">+   void oops_do_set_strong_done(nmethod* old_head);</span>
<span class="line-added">+ </span>
    static nmethod* volatile _oops_do_mark_nmethods;
<span class="line-modified">!   oops_do_mark_link* volatile _oops_do_mark_link;</span>
  
    // offsets for entry points
    address _entry_point;                      // entry point with class check
    address _verified_entry_point;             // entry point without class check
    address _osr_entry_point;                  // entry point for on stack replacement
</pre>
<hr />
<pre>
<span class="line-old-header">*** 105,10 ***</span>
<span class="line-new-header">--- 207,14 ---</span>
    int _scopes_data_offset;
    int _scopes_pcs_offset;
    int _dependencies_offset;
    int _handler_table_offset;
    int _nul_chk_table_offset;
<span class="line-added">+ #if INCLUDE_JVMCI</span>
<span class="line-added">+   int _speculations_offset;</span>
<span class="line-added">+   int _jvmci_data_offset;</span>
<span class="line-added">+ #endif</span>
    int _nmethod_end_offset;
  
    int code_offset() const { return (address) code_begin() - header_begin(); }
  
    // location in frame (offset for sp) that deopt can store the original
</pre>
<hr />
<pre>
<span class="line-old-header">*** 119,14 ***</span>
    int _comp_level;                           // compilation level
  
    // protected by CodeCache_lock
    bool _has_flushed_dependencies;            // Used for maintenance of dependencies (CodeCache_lock)
  
<span class="line-modified">!   // used by jvmti to track if an unload event has been posted for this nmethod.</span>
    bool _unload_reported;
  
<span class="line-modified">!   // Protected by Patching_lock</span>
    volatile signed char _state;               // {not_installed, in_use, not_entrant, zombie, unloaded}
  
  #ifdef ASSERT
    bool _oops_are_stale;  // indicates that it&#39;s no longer safe to access oops section
  #endif
<span class="line-new-header">--- 225,15 ---</span>
    int _comp_level;                           // compilation level
  
    // protected by CodeCache_lock
    bool _has_flushed_dependencies;            // Used for maintenance of dependencies (CodeCache_lock)
  
<span class="line-modified">!   // used by jvmti to track if an event has been posted for this nmethod.</span>
    bool _unload_reported;
<span class="line-added">+   bool _load_reported;</span>
  
<span class="line-modified">!   // Protected by CompiledMethod_lock</span>
    volatile signed char _state;               // {not_installed, in_use, not_entrant, zombie, unloaded}
  
  #ifdef ASSERT
    bool _oops_are_stale;  // indicates that it&#39;s no longer safe to access oops section
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 205,19 ***</span>
            ExceptionHandlerTable* handler_table,
            ImplicitExceptionTable* nul_chk_table,
            AbstractCompiler* compiler,
            int comp_level
  #if INCLUDE_JVMCI
<span class="line-modified">!           , jweak installed_code,</span>
<span class="line-modified">!           jweak speculation_log</span>
  #endif
            );
  
    // helper methods
    void* operator new(size_t size, int nmethod_size, int comp_level) throw();
  
    const char* reloc_string_for(u_char* begin, u_char* end);
    // Returns true if this thread changed the state of the nmethod or
    // false if another thread performed the transition.
    bool make_not_entrant_or_zombie(int state);
    bool make_entrant() { Unimplemented(); return false; }
    void inc_decompile_count();
<span class="line-new-header">--- 312,23 ---</span>
            ExceptionHandlerTable* handler_table,
            ImplicitExceptionTable* nul_chk_table,
            AbstractCompiler* compiler,
            int comp_level
  #if INCLUDE_JVMCI
<span class="line-modified">!           , char* speculations,</span>
<span class="line-modified">!           int speculations_len,</span>
<span class="line-added">+           int jvmci_data_size</span>
  #endif
            );
  
    // helper methods
    void* operator new(size_t size, int nmethod_size, int comp_level) throw();
  
    const char* reloc_string_for(u_char* begin, u_char* end);
<span class="line-added">+ </span>
<span class="line-added">+   bool try_transition(int new_state);</span>
<span class="line-added">+ </span>
    // Returns true if this thread changed the state of the nmethod or
    // false if another thread performed the transition.
    bool make_not_entrant_or_zombie(int state);
    bool make_entrant() { Unimplemented(); return false; }
    void inc_decompile_count();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 249,12 ***</span>
                                ExceptionHandlerTable* handler_table,
                                ImplicitExceptionTable* nul_chk_table,
                                AbstractCompiler* compiler,
                                int comp_level
  #if INCLUDE_JVMCI
<span class="line-modified">!                               , jweak installed_code = NULL,</span>
<span class="line-modified">!                               jweak speculation_log = NULL</span>
  #endif
    );
  
    // Only used for unit tests.
    nmethod()
<span class="line-new-header">--- 360,15 ---</span>
                                ExceptionHandlerTable* handler_table,
                                ImplicitExceptionTable* nul_chk_table,
                                AbstractCompiler* compiler,
                                int comp_level
  #if INCLUDE_JVMCI
<span class="line-modified">!                               , char* speculations = NULL,</span>
<span class="line-modified">!                               int speculations_len = 0,</span>
<span class="line-added">+                               int nmethod_mirror_index = -1,</span>
<span class="line-added">+                               const char* nmethod_mirror_name = NULL,</span>
<span class="line-added">+                               FailedSpeculation** failed_speculations = NULL</span>
  #endif
    );
  
    // Only used for unit tests.
    nmethod()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 297,16 ***</span>
<span class="line-new-header">--- 411,28 ---</span>
    address dependencies_begin    () const          { return           header_begin() + _dependencies_offset  ; }
    address dependencies_end      () const          { return           header_begin() + _handler_table_offset ; }
    address handler_table_begin   () const          { return           header_begin() + _handler_table_offset ; }
    address handler_table_end     () const          { return           header_begin() + _nul_chk_table_offset ; }
    address nul_chk_table_begin   () const          { return           header_begin() + _nul_chk_table_offset ; }
<span class="line-added">+ #if INCLUDE_JVMCI</span>
<span class="line-added">+   address nul_chk_table_end     () const          { return           header_begin() + _speculations_offset  ; }</span>
<span class="line-added">+   address speculations_begin    () const          { return           header_begin() + _speculations_offset  ; }</span>
<span class="line-added">+   address speculations_end      () const          { return           header_begin() + _jvmci_data_offset   ; }</span>
<span class="line-added">+   address jvmci_data_begin      () const          { return           header_begin() + _jvmci_data_offset    ; }</span>
<span class="line-added">+   address jvmci_data_end        () const          { return           header_begin() + _nmethod_end_offset   ; }</span>
<span class="line-added">+ #else</span>
    address nul_chk_table_end     () const          { return           header_begin() + _nmethod_end_offset   ; }
<span class="line-added">+ #endif</span>
  
    // Sizes
    int oops_size         () const                  { return (address)  oops_end         () - (address)  oops_begin         (); }
    int metadata_size     () const                  { return (address)  metadata_end     () - (address)  metadata_begin     (); }
    int dependencies_size () const                  { return            dependencies_end () -            dependencies_begin (); }
<span class="line-added">+ #if INCLUDE_JVMCI</span>
<span class="line-added">+   int speculations_size () const                  { return            speculations_end () -            speculations_begin (); }</span>
<span class="line-added">+   int jvmci_data_size   () const                  { return            jvmci_data_end   () -            jvmci_data_begin   (); }</span>
<span class="line-added">+ #endif</span>
  
    int     oops_count() const { assert(oops_size() % oopSize == 0, &quot;&quot;);  return (oops_size() / oopSize) + 1; }
    int metadata_count() const { assert(metadata_size() % wordSize == 0, &quot;&quot;); return (metadata_size() / wordSize) + 1; }
  
    int total_size        () const;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 326,11 ***</span>
    address verified_entry_point() const            { return _verified_entry_point;    } // if klass is correct
  
    // flag accessing and manipulation
    bool  is_not_installed() const                  { return _state == not_installed; }
    bool  is_in_use() const                         { return _state &lt;= in_use; }
<span class="line-modified">!   bool  is_alive() const                          { return _state &lt; zombie; }</span>
    bool  is_not_entrant() const                    { return _state == not_entrant; }
    bool  is_zombie() const                         { return _state == zombie; }
    bool  is_unloaded() const                       { return _state == unloaded; }
  
    void clear_unloading_state();
<span class="line-new-header">--- 452,11 ---</span>
    address verified_entry_point() const            { return _verified_entry_point;    } // if klass is correct
  
    // flag accessing and manipulation
    bool  is_not_installed() const                  { return _state == not_installed; }
    bool  is_in_use() const                         { return _state &lt;= in_use; }
<span class="line-modified">!   bool  is_alive() const                          { return _state &lt; unloaded; }</span>
    bool  is_not_entrant() const                    { return _state == not_entrant; }
    bool  is_zombie() const                         { return _state == zombie; }
    bool  is_unloaded() const                       { return _state == unloaded; }
  
    void clear_unloading_state();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 341,11 ***</span>
    // rtm state accessing and manipulating
    RTMState  rtm_state() const                     { return _rtm_state; }
    void set_rtm_state(RTMState state)              { _rtm_state = state; }
  #endif
  
<span class="line-modified">!   void make_in_use()                              { _state = in_use; }</span>
    // Make the nmethod non entrant. The nmethod will continue to be
    // alive.  It is used when an uncommon trap happens.  Returns true
    // if this thread changed the state of the nmethod or false if
    // another thread performed the transition.
    bool  make_not_entrant() {
<span class="line-new-header">--- 467,13 ---</span>
    // rtm state accessing and manipulating
    RTMState  rtm_state() const                     { return _rtm_state; }
    void set_rtm_state(RTMState state)              { _rtm_state = state; }
  #endif
  
<span class="line-modified">!   bool make_in_use() {</span>
<span class="line-added">+     return try_transition(in_use);</span>
<span class="line-added">+   }</span>
    // Make the nmethod non entrant. The nmethod will continue to be
    // alive.  It is used when an uncommon trap happens.  Returns true
    // if this thread changed the state of the nmethod or false if
    // another thread performed the transition.
    bool  make_not_entrant() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 353,35 ***</span>
      return make_not_entrant_or_zombie(not_entrant);
    }
    bool  make_not_used()    { return make_not_entrant(); }
    bool  make_zombie()      { return make_not_entrant_or_zombie(zombie); }
  
<span class="line-removed">-   // used by jvmti to track if the unload event has been reported</span>
<span class="line-removed">-   bool  unload_reported()                         { return _unload_reported; }</span>
<span class="line-removed">-   void  set_unload_reported()                     { _unload_reported = true; }</span>
<span class="line-removed">- </span>
    int get_state() const {
      return _state;
    }
  
    void  make_unloaded();
  
    bool has_dependencies()                         { return dependencies_size() != 0; }
    void flush_dependencies(bool delete_immediately);
    bool has_flushed_dependencies()                 { return _has_flushed_dependencies; }
    void set_has_flushed_dependencies()             {
      assert(!has_flushed_dependencies(), &quot;should only happen once&quot;);
      _has_flushed_dependencies = 1;
    }
  
    int   comp_level() const                        { return _comp_level; }
  
<span class="line-modified">!   void unlink_from_method(bool acquire_lock);</span>
  
    // Support for oops in scopes and relocs:
    // Note: index 0 is reserved for null.
    oop   oop_at(int index) const;
    oop*  oop_addr_at(int index) const {  // for GC
      // relocation indexes are biased by 1 (because 0 is reserved)
      assert(index &gt; 0 &amp;&amp; index &lt;= oops_count(), &quot;must be a valid non-zero index&quot;);
      assert(!_oops_are_stale, &quot;oops are stale&quot;);
      return &amp;oops_begin()[index - 1];
<span class="line-new-header">--- 481,33 ---</span>
      return make_not_entrant_or_zombie(not_entrant);
    }
    bool  make_not_used()    { return make_not_entrant(); }
    bool  make_zombie()      { return make_not_entrant_or_zombie(zombie); }
  
    int get_state() const {
      return _state;
    }
  
    void  make_unloaded();
  
    bool has_dependencies()                         { return dependencies_size() != 0; }
<span class="line-added">+   void print_dependencies()                       PRODUCT_RETURN;</span>
    void flush_dependencies(bool delete_immediately);
    bool has_flushed_dependencies()                 { return _has_flushed_dependencies; }
    void set_has_flushed_dependencies()             {
      assert(!has_flushed_dependencies(), &quot;should only happen once&quot;);
      _has_flushed_dependencies = 1;
    }
  
    int   comp_level() const                        { return _comp_level; }
  
<span class="line-modified">!   void unlink_from_method();</span>
  
    // Support for oops in scopes and relocs:
    // Note: index 0 is reserved for null.
    oop   oop_at(int index) const;
<span class="line-added">+   oop   oop_at_phantom(int index) const; // phantom reference</span>
    oop*  oop_addr_at(int index) const {  // for GC
      // relocation indexes are biased by 1 (because 0 is reserved)
      assert(index &gt; 0 &amp;&amp; index &lt;= oops_count(), &quot;must be a valid non-zero index&quot;);
      assert(!_oops_are_stale, &quot;oops are stale&quot;);
      return &amp;oops_begin()[index - 1];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 410,13 ***</span>
  
    // Sweeper support
    long  stack_traversal_mark()                    { return _stack_traversal_mark; }
    void  set_stack_traversal_mark(long l)          { _stack_traversal_mark = l; }
  
<span class="line-removed">-   // implicit exceptions support</span>
<span class="line-removed">-   address continuation_for_implicit_exception(address pc);</span>
<span class="line-removed">- </span>
    // On-stack replacement support
    int   osr_entry_bci() const                     { assert(is_osr_method(), &quot;wrong kind of nmethod&quot;); return _entry_bci; }
    address  osr_entry() const                      { assert(is_osr_method(), &quot;wrong kind of nmethod&quot;); return _osr_entry_point; }
    void  invalidate_osr_method();
    nmethod* osr_link() const                       { return _osr_link; }
<span class="line-new-header">--- 536,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 444,90 ***</span>
  
    // Evolution support. We make old (discarded) compiled methods point to new Method*s.
    void set_method(Method* method) { _method = method; }
  
  #if INCLUDE_JVMCI
<span class="line-modified">!   // Gets the InstalledCode object associated with this nmethod</span>
<span class="line-modified">!   // which may be NULL if this nmethod was not compiled by JVMCI</span>
<span class="line-modified">!   // or the weak reference has been cleared.</span>
<span class="line-modified">!   oop jvmci_installed_code();</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Copies the value of the name field in the InstalledCode</span>
<span class="line-modified">!   // object (if any) associated with this nmethod into buf.</span>
<span class="line-modified">!   // Returns the value of buf if it was updated otherwise NULL.</span>
<span class="line-modified">!   char* jvmci_installed_code_name(char* buf, size_t buflen) const;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Updates the state of the InstalledCode (if any) associated with</span>
<span class="line-modified">!   // this nmethod based on the current value of _state.</span>
<span class="line-modified">!   void maybe_invalidate_installed_code();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Deoptimizes the nmethod (if any) in the address field of a given</span>
<span class="line-removed">-   // InstalledCode object. The address field is zeroed upon return.</span>
<span class="line-removed">-   static void invalidate_installed_code(Handle installed_code, TRAPS);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Gets the SpeculationLog object associated with this nmethod</span>
<span class="line-removed">-   // which may be NULL if this nmethod was not compiled by JVMCI</span>
<span class="line-removed">-   // or the weak reference has been cleared.</span>
<span class="line-removed">-   oop speculation_log();</span>
<span class="line-removed">- </span>
<span class="line-removed">-  private:</span>
<span class="line-removed">-   // Deletes the weak reference (if any) to the InstalledCode object</span>
<span class="line-removed">-   // associated with this nmethod.</span>
<span class="line-removed">-   void clear_jvmci_installed_code();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Deletes the weak reference (if any) to the SpeculationLog object</span>
<span class="line-removed">-   // associated with this nmethod.</span>
<span class="line-removed">-   void clear_speculation_log();</span>
<span class="line-removed">- </span>
<span class="line-removed">-  public:</span>
  #endif
  
   public:
    void oops_do(OopClosure* f) { oops_do(f, false); }
<span class="line-modified">!   void oops_do(OopClosure* f, bool allow_zombie);</span>
  
<span class="line-removed">-   bool test_set_oops_do_mark();</span>
    static void oops_do_marking_prologue();
    static void oops_do_marking_epilogue();
<span class="line-removed">-   static bool oops_do_marking_is_active() { return _oops_do_mark_nmethods != NULL; }</span>
<span class="line-removed">-   bool test_oops_do_mark() { return _oops_do_mark_link != NULL; }</span>
  
   private:
    ScopeDesc* scope_desc_in(address begin, address end);
  
    address* orig_pc_addr(const frame* fr);
  
   public:
    // copying of debugging information
    void copy_scopes_pcs(PcDesc* pcs, int count);
    void copy_scopes_data(address buffer, int size);
  
    // Accessor/mutator for the original pc of a frame before a frame was deopted.
    address get_original_pc(const frame* fr) { return *orig_pc_addr(fr); }
    void    set_original_pc(const frame* fr, address pc) { *orig_pc_addr(fr) = pc; }
  
    // jvmti support:
<span class="line-modified">!   void post_compiled_method_load_event();</span>
<span class="line-removed">-   jmethodID get_and_cache_jmethod_id();</span>
  
    // verify operations
    void verify();
    void verify_scopes();
    void verify_interrupt_point(address interrupt_point);
  
    // printing support
    void print()                          const;
    void print_relocations()                        PRODUCT_RETURN;
<span class="line-modified">!   void print_pcs()                                PRODUCT_RETURN;</span>
<span class="line-modified">!   void print_scopes()                             PRODUCT_RETURN;</span>
<span class="line-modified">!   void print_dependencies()                       PRODUCT_RETURN;</span>
<span class="line-modified">!   void print_value_on(outputStream* st) const     PRODUCT_RETURN;</span>
    void print_calls(outputStream* st)              PRODUCT_RETURN;
<span class="line-modified">!   void print_handler_table()                      PRODUCT_RETURN;</span>
<span class="line-removed">-   void print_nul_chk_table()                      PRODUCT_RETURN;</span>
<span class="line-removed">-   void print_recorded_oops()                      PRODUCT_RETURN;</span>
<span class="line-removed">-   void print_recorded_metadata()                  PRODUCT_RETURN;</span>
  
    void maybe_print_nmethod(DirectiveSet* directive);
    void print_nmethod(bool print_code);
  
    // need to re-define this from CodeBlob else the overload hides it
<span class="line-new-header">--- 567,116 ---</span>
  
    // Evolution support. We make old (discarded) compiled methods point to new Method*s.
    void set_method(Method* method) { _method = method; }
  
  #if INCLUDE_JVMCI
<span class="line-modified">!   // Gets the JVMCI name of this nmethod.</span>
<span class="line-modified">!   const char* jvmci_name();</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Records the pending failed speculation in the</span>
<span class="line-modified">!   // JVMCI speculation log associated with this nmethod.</span>
<span class="line-modified">!   void update_speculation(JavaThread* thread);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Gets the data specific to a JVMCI compiled method.</span>
<span class="line-modified">!   // This returns a non-NULL value iff this nmethod was</span>
<span class="line-modified">!   // compiled by the JVMCI compiler.</span>
<span class="line-modified">!   JVMCINMethodData* jvmci_nmethod_data() const {</span>
<span class="line-modified">!     return jvmci_data_size() == 0 ? NULL : (JVMCINMethodData*) jvmci_data_begin();</span>
<span class="line-modified">!   }</span>
  #endif
  
   public:
    void oops_do(OopClosure* f) { oops_do(f, false); }
<span class="line-modified">!   void oops_do(OopClosure* f, bool allow_dead);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // All-in-one claiming of nmethods: returns true if the caller successfully claimed that</span>
<span class="line-added">+   // nmethod.</span>
<span class="line-added">+   bool oops_do_try_claim();</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Class containing callbacks for the oops_do_process_weak/strong() methods</span>
<span class="line-added">+   // below.</span>
<span class="line-added">+   class OopsDoProcessor {</span>
<span class="line-added">+   public:</span>
<span class="line-added">+     // Process the oops of the given nmethod based on whether it has been called</span>
<span class="line-added">+     // in a weak or strong processing context, i.e. apply either weak or strong</span>
<span class="line-added">+     // work on it.</span>
<span class="line-added">+     virtual void do_regular_processing(nmethod* nm) = 0;</span>
<span class="line-added">+     // Assuming that the oops of the given nmethod has already been its weak</span>
<span class="line-added">+     // processing applied, apply the remaining strong processing part.</span>
<span class="line-added">+     virtual void do_remaining_strong_processing(nmethod* nm) = 0;</span>
<span class="line-added">+   };</span>
<span class="line-added">+ </span>
<span class="line-added">+   // The following two methods do the work corresponding to weak/strong nmethod</span>
<span class="line-added">+   // processing.</span>
<span class="line-added">+   void oops_do_process_weak(OopsDoProcessor* p);</span>
<span class="line-added">+   void oops_do_process_strong(OopsDoProcessor* p);</span>
  
    static void oops_do_marking_prologue();
    static void oops_do_marking_epilogue();
  
   private:
    ScopeDesc* scope_desc_in(address begin, address end);
  
    address* orig_pc_addr(const frame* fr);
  
<span class="line-added">+   // used by jvmti to track if the load and unload events has been reported</span>
<span class="line-added">+   bool  unload_reported() const                   { return _unload_reported; }</span>
<span class="line-added">+   void  set_unload_reported()                     { _unload_reported = true; }</span>
<span class="line-added">+   bool  load_reported() const                     { return _load_reported; }</span>
<span class="line-added">+   void  set_load_reported()                       { _load_reported = true; }</span>
<span class="line-added">+ </span>
   public:
    // copying of debugging information
    void copy_scopes_pcs(PcDesc* pcs, int count);
    void copy_scopes_data(address buffer, int size);
  
    // Accessor/mutator for the original pc of a frame before a frame was deopted.
    address get_original_pc(const frame* fr) { return *orig_pc_addr(fr); }
    void    set_original_pc(const frame* fr, address pc) { *orig_pc_addr(fr) = pc; }
  
    // jvmti support:
<span class="line-modified">!   void post_compiled_method_load_event(JvmtiThreadState* state = NULL);</span>
  
    // verify operations
    void verify();
    void verify_scopes();
    void verify_interrupt_point(address interrupt_point);
  
<span class="line-added">+   // Disassemble this nmethod with additional debug information, e.g. information about blocks.</span>
<span class="line-added">+   void decode2(outputStream* st) const;</span>
<span class="line-added">+   void print_constant_pool(outputStream* st);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Avoid hiding of parent&#39;s &#39;decode(outputStream*)&#39; method.</span>
<span class="line-added">+   void decode(outputStream* st) const { decode2(st); } // just delegate here.</span>
<span class="line-added">+ </span>
    // printing support
    void print()                          const;
<span class="line-added">+   void print(outputStream* st)          const;</span>
<span class="line-added">+   void print_code();</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if defined(SUPPORT_DATA_STRUCTS)</span>
<span class="line-added">+   // print output in opt build for disassembler library</span>
    void print_relocations()                        PRODUCT_RETURN;
<span class="line-modified">!   void print_pcs() { print_pcs_on(tty); }</span>
<span class="line-modified">!   void print_pcs_on(outputStream* st);</span>
<span class="line-modified">!   void print_scopes() { print_scopes_on(tty); }</span>
<span class="line-modified">!   void print_scopes_on(outputStream* st)          PRODUCT_RETURN;</span>
<span class="line-added">+   void print_value_on(outputStream* st) const;</span>
<span class="line-added">+   void print_handler_table();</span>
<span class="line-added">+   void print_nul_chk_table();</span>
<span class="line-added">+   void print_recorded_oops();</span>
<span class="line-added">+   void print_recorded_metadata();</span>
<span class="line-added">+ </span>
<span class="line-added">+   void print_oops(outputStream* st);     // oops from the underlying CodeBlob.</span>
<span class="line-added">+   void print_metadata(outputStream* st); // metadata in metadata pool.</span>
<span class="line-added">+ #else</span>
<span class="line-added">+   // void print_pcs()                             PRODUCT_RETURN;</span>
<span class="line-added">+   void print_pcs()                                { return; }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
    void print_calls(outputStream* st)              PRODUCT_RETURN;
<span class="line-modified">!   static void print_statistics()                  PRODUCT_RETURN;</span>
  
    void maybe_print_nmethod(DirectiveSet* directive);
    void print_nmethod(bool print_code);
  
    // need to re-define this from CodeBlob else the overload hides it
</pre>
<hr />
<pre>
<span class="line-old-header">*** 539,18 ***</span>
    void log_new_nmethod() const;
    void log_state_change() const;
  
    // Prints block-level comments, including nmethod specific block labels:
    virtual void print_block_comment(outputStream* stream, address block_begin) const {
      print_nmethod_labels(stream, block_begin);
      CodeBlob::print_block_comment(stream, block_begin);
    }
<span class="line-modified">!   void print_nmethod_labels(outputStream* stream, address block_begin) const;</span>
  
    // Prints a comment for one native instruction (reloc info, pc desc)
    void print_code_comment_on(outputStream* st, int column, address begin, address end);
<span class="line-removed">-   static void print_statistics() PRODUCT_RETURN;</span>
  
    // Compiler task identification.  Note that all OSR methods
    // are numbered in an independent sequence if CICountOSR is true,
    // and native method wrappers are also numbered independently if
    // CICountNative is true.
<span class="line-new-header">--- 688,25 ---</span>
    void log_new_nmethod() const;
    void log_state_change() const;
  
    // Prints block-level comments, including nmethod specific block labels:
    virtual void print_block_comment(outputStream* stream, address block_begin) const {
<span class="line-added">+ #if defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_ABSTRACT_ASSEMBLY)</span>
      print_nmethod_labels(stream, block_begin);
      CodeBlob::print_block_comment(stream, block_begin);
<span class="line-added">+ #endif</span>
    }
<span class="line-modified">!   bool has_block_comment(address block_begin) {</span>
<span class="line-added">+     return CodeBlob::has_block_comment(block_begin);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   void print_nmethod_labels(outputStream* stream, address block_begin, bool print_section_labels=true) const;</span>
<span class="line-added">+   const char* nmethod_section_label(address pos) const;</span>
  
<span class="line-added">+   // returns whether this nmethod has code comments.</span>
<span class="line-added">+   bool has_code_comment(address begin, address end);</span>
    // Prints a comment for one native instruction (reloc info, pc desc)
    void print_code_comment_on(outputStream* st, int column, address begin, address end);
  
    // Compiler task identification.  Note that all OSR methods
    // are numbered in an independent sequence if CICountOSR is true,
    // and native method wrappers are also numbered independently if
    // CICountNative is true.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 563,15 ***</span>
  
    // tells if this compiled method is dependent on the given changes,
    // and the changes have invalidated it
    bool check_dependency_on(DepChange&amp; changes);
  
<span class="line-removed">-   // Evolution support. Tells if this compiled method is dependent on any of</span>
<span class="line-removed">-   // redefined methods, such that if m() is replaced,</span>
<span class="line-removed">-   // this compiled method will have to be deoptimized.</span>
<span class="line-removed">-   bool is_evol_dependent();</span>
<span class="line-removed">- </span>
    // Fast breakpoint support. Tells if this compiled method is
    // dependent on the given method. Returns true if this nmethod
    // corresponds to the given method as well.
    virtual bool is_dependent_on_method(Method* dependee);
  
<span class="line-new-header">--- 719,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 589,11 ***</span>
    // support for code generation
    static int verified_entry_point_offset()        { return offset_of(nmethod, _verified_entry_point); }
    static int osr_entry_point_offset()             { return offset_of(nmethod, _osr_entry_point); }
    static int state_offset()                       { return offset_of(nmethod, _state); }
  
<span class="line-modified">!   virtual void metadata_do(void f(Metadata*));</span>
  
    NativeCallWrapper* call_wrapper_at(address call) const;
    NativeCallWrapper* call_wrapper_before(address return_pc) const;
    address call_instruction_address(address pc) const;
  
<span class="line-new-header">--- 740,11 ---</span>
    // support for code generation
    static int verified_entry_point_offset()        { return offset_of(nmethod, _verified_entry_point); }
    static int osr_entry_point_offset()             { return offset_of(nmethod, _osr_entry_point); }
    static int state_offset()                       { return offset_of(nmethod, _state); }
  
<span class="line-modified">!   virtual void metadata_do(MetadataClosure* f);</span>
  
    NativeCallWrapper* call_wrapper_at(address call) const;
    NativeCallWrapper* call_wrapper_before(address return_pc) const;
    address call_instruction_address(address pc) const;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 623,13 ***</span>
    nmethodLocker(CompiledMethod *nm) {
      _nm = nm;
      lock(_nm);
    }
  
<span class="line-modified">!   static void lock(CompiledMethod* method) {</span>
      if (method == NULL) return;
<span class="line-modified">!     lock_nmethod(method);</span>
    }
  
    static void unlock(CompiledMethod* method) {
      if (method == NULL) return;
      unlock_nmethod(method);
<span class="line-new-header">--- 774,13 ---</span>
    nmethodLocker(CompiledMethod *nm) {
      _nm = nm;
      lock(_nm);
    }
  
<span class="line-modified">!   static void lock(CompiledMethod* method, bool zombie_ok = false) {</span>
      if (method == NULL) return;
<span class="line-modified">!     lock_nmethod(method, zombie_ok);</span>
    }
  
    static void unlock(CompiledMethod* method) {
      if (method == NULL) return;
      unlock_nmethod(method);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 639,13 ***</span>
    ~nmethodLocker() {
      unlock(_nm);
    }
  
    CompiledMethod* code() { return _nm; }
<span class="line-modified">!   void set_code(CompiledMethod* new_nm) {</span>
      unlock(_nm);   // note:  This works even if _nm==new_nm.
      _nm = new_nm;
<span class="line-modified">!     lock(_nm);</span>
    }
  };
  
  #endif // SHARE_CODE_NMETHOD_HPP
<span class="line-new-header">--- 790,13 ---</span>
    ~nmethodLocker() {
      unlock(_nm);
    }
  
    CompiledMethod* code() { return _nm; }
<span class="line-modified">!   void set_code(CompiledMethod* new_nm, bool zombie_ok = false) {</span>
      unlock(_nm);   // note:  This works even if _nm==new_nm.
      _nm = new_nm;
<span class="line-modified">!     lock(_nm, zombie_ok);</span>
    }
  };
  
  #endif // SHARE_CODE_NMETHOD_HPP
</pre>
<center><a href="nmethod.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oopRecorder.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
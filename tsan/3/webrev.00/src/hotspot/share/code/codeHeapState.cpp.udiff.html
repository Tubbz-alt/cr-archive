<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/code/codeHeapState.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="codeCache.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="codeHeapState.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/codeHeapState.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -25,10 +25,11 @@</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;code/codeHeapState.hpp&quot;
  #include &quot;compiler/compileBroker.hpp&quot;
  #include &quot;runtime/sweeper.hpp&quot;
<span class="udiff-line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  // -------------------------
  // |  General Description  |
  // -------------------------
  // The CodeHeap state analytics are divided in two parts.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -122,11 +123,11 @@</span>
      size_t     _nforcedflush = 0;                             \
      size_t      _nsavedflush = 0;                             \
      size_t     _nlockedflush = 0;                             \
      size_t     _nflush_bytes = 0;                             \
      size_t         _capacity = _capa;                         \
<span class="udiff-line-modified-removed">-     bufferedStream   _sstobj = bufferedStream(_capa);         \</span>
<span class="udiff-line-modified-added">+     bufferedStream   _sstobj(_capa);                          \</span>
      bufferedStream*  _sstbuf = &amp;_sstobj;                      \
      outputStream*    _outbuf = _outst;                        \
      bufferedStream*   _anyst = &amp;_sstobj; /* any stream. Use this to just print - no buffer flush.  */
  
  // Same as above, but with fixed buffer size.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -528,11 +529,11 @@</span>
      }
      nHeaps = 0;
    }
  }
  
<span class="udiff-line-modified-removed">- void CodeHeapState::aggregate(outputStream* out, CodeHeap* heap, const char* granularity_request) {</span>
<span class="udiff-line-modified-added">+ void CodeHeapState::aggregate(outputStream* out, CodeHeap* heap, size_t granularity) {</span>
    unsigned int nBlocks_free    = 0;
    unsigned int nBlocks_used    = 0;
    unsigned int nBlocks_zomb    = 0;
    unsigned int nBlocks_disconn = 0;
    unsigned int nBlocks_notentr = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -610,11 +611,12 @@</span>
    //   keep the amount of allocated storage in check.
    //
    //   Finally, we adjust the granularity such that each granule covers at most 64k-1 segments.
    //   This is necessary to prevent an unsigned short overflow while accumulating space information.
    //
<span class="udiff-line-modified-removed">-   size_t granularity = strtol(granularity_request, NULL, 0);</span>
<span class="udiff-line-modified-added">+   assert(granularity &gt; 0, &quot;granularity should be positive.&quot;);</span>
<span class="udiff-line-added">+ </span>
    if (granularity &gt; size) {
      granularity = size;
    }
    if (size/granularity &lt; min_granules) {
      granularity = size/min_granules;                                   // at least min_granules granules
</pre>
<center><a href="codeCache.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="codeHeapState.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/code/relocInfo.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_CODE_RELOCINFO_HPP
  26 #define SHARE_CODE_RELOCINFO_HPP
  27 
  28 #include &quot;runtime/os.hpp&quot;
  29 #include &quot;utilities/macros.hpp&quot;
  30 
  31 class nmethod;
  32 class CodeBlob;
  33 class CompiledMethod;
  34 class Metadata;
  35 class NativeMovConstReg;
  36 
  37 // Types in this file:
  38 //    relocInfo
  39 //      One element of an array of halfwords encoding compressed relocations.
  40 //      Also, the source of relocation types (relocInfo::oop_type, ...).
  41 //    Relocation
  42 //      A flyweight object representing a single relocation.
  43 //      It is fully unpacked from the compressed relocation array.
  44 //    metadata_Relocation, ... (subclasses of Relocation)
  45 //      The location of some type-specific operations (metadata_addr, ...).
  46 //      Also, the source of relocation specs (metadata_Relocation::spec, ...).
  47 //    oop_Relocation, ... (subclasses of Relocation)
  48 //      oops in the code stream (strings, class loaders)
  49 //      Also, the source of relocation specs (oop_Relocation::spec, ...).
  50 //    RelocationHolder
  51 //      A value type which acts as a union holding a Relocation object.
  52 //      Represents a relocation spec passed into a CodeBuffer during assembly.
  53 //    RelocIterator
  54 //      A StackObj which iterates over the relocations associated with
  55 //      a range of code addresses.  Can be used to operate a copy of code.
  56 //    BoundRelocation
  57 //      An _internal_ type shared by packers and unpackers of relocations.
  58 //      It pastes together a RelocationHolder with some pointers into
  59 //      code and relocInfo streams.
  60 
  61 
  62 // Notes on relocType:
  63 //
  64 // These hold enough information to read or write a value embedded in
  65 // the instructions of an CodeBlob.  They&#39;re used to update:
  66 //
  67 //   1) embedded oops     (isOop()          == true)
  68 //   2) inline caches     (isIC()           == true)
  69 //   3) runtime calls     (isRuntimeCall()  == true)
  70 //   4) internal word ref (isInternalWord() == true)
  71 //   5) external word ref (isExternalWord() == true)
  72 //
  73 // when objects move (GC) or if code moves (compacting the code heap).
  74 // They are also used to patch the code (if a call site must change)
  75 //
  76 // A relocInfo is represented in 16 bits:
  77 //   4 bits indicating the relocation type
  78 //  12 bits indicating the offset from the previous relocInfo address
  79 //
  80 // The offsets accumulate along the relocInfo stream to encode the
  81 // address within the CodeBlob, which is named RelocIterator::addr().
  82 // The address of a particular relocInfo always points to the first
  83 // byte of the relevant instruction (and not to any of its subfields
  84 // or embedded immediate constants).
  85 //
  86 // The offset value is scaled appropriately for the target machine.
  87 // (See relocInfo_&lt;arch&gt;.hpp for the offset scaling.)
  88 //
  89 // On some machines, there may also be a &quot;format&quot; field which may provide
  90 // additional information about the format of the instruction stream
  91 // at the corresponding code address.  The format value is usually zero.
  92 // Any machine (such as Intel) whose instructions can sometimes contain
  93 // more than one relocatable constant needs format codes to distinguish
  94 // which operand goes with a given relocation.
  95 //
  96 // If the target machine needs N format bits, the offset has 12-N bits,
  97 // the format is encoded between the offset and the type, and the
  98 // relocInfo_&lt;arch&gt;.hpp file has manifest constants for the format codes.
  99 //
 100 // If the type is &quot;data_prefix_tag&quot; then the offset bits are further encoded,
 101 // and in fact represent not a code-stream offset but some inline data.
 102 // The data takes the form of a counted sequence of halfwords, which
 103 // precedes the actual relocation record.  (Clients never see it directly.)
 104 // The interpetation of this extra data depends on the relocation type.
 105 //
 106 // On machines that have 32-bit immediate fields, there is usually
 107 // little need for relocation &quot;prefix&quot; data, because the instruction stream
 108 // is a perfectly reasonable place to store the value.  On machines in
 109 // which 32-bit values must be &quot;split&quot; across instructions, the relocation
 110 // data is the &quot;true&quot; specification of the value, which is then applied
 111 // to some field of the instruction (22 or 13 bits, on SPARC).
 112 //
 113 // Whenever the location of the CodeBlob changes, any PC-relative
 114 // relocations, and any internal_word_type relocations, must be reapplied.
 115 // After the GC runs, oop_type relocations must be reapplied.
 116 //
 117 //
 118 // Here are meanings of the types:
 119 //
 120 // relocInfo::none -- a filler record
 121 //   Value:  none
 122 //   Instruction: The corresponding code address is ignored
 123 //   Data:  Any data prefix and format code are ignored
 124 //   (This means that any relocInfo can be disabled by setting
 125 //   its type to none.  See relocInfo::remove.)
 126 //
 127 // relocInfo::oop_type, relocInfo::metadata_type -- a reference to an oop or meta data
 128 //   Value:  an oop, or else the address (handle) of an oop
 129 //   Instruction types: memory (load), set (load address)
 130 //   Data:  []       an oop stored in 4 bytes of instruction
 131 //          [n]      n is the index of an oop in the CodeBlob&#39;s oop pool
 132 //          [[N]n l] and l is a byte offset to be applied to the oop
 133 //          [Nn Ll]  both index and offset may be 32 bits if necessary
 134 //   Here is a special hack, used only by the old compiler:
 135 //          [[N]n 00] the value is the __address__ of the nth oop in the pool
 136 //   (Note that the offset allows optimal references to class variables.)
 137 //
 138 // relocInfo::internal_word_type -- an address within the same CodeBlob
 139 // relocInfo::section_word_type -- same, but can refer to another section
 140 //   Value:  an address in the CodeBlob&#39;s code or constants section
 141 //   Instruction types: memory (load), set (load address)
 142 //   Data:  []     stored in 4 bytes of instruction
 143 //          [[L]l] a relative offset (see [About Offsets] below)
 144 //   In the case of section_word_type, the offset is relative to a section
 145 //   base address, and the section number (e.g., SECT_INSTS) is encoded
 146 //   into the low two bits of the offset L.
 147 //
 148 // relocInfo::external_word_type -- a fixed address in the runtime system
 149 //   Value:  an address
 150 //   Instruction types: memory (load), set (load address)
 151 //   Data:  []   stored in 4 bytes of instruction
 152 //          [n]  the index of a &quot;well-known&quot; stub (usual case on RISC)
 153 //          [Ll] a 32-bit address
 154 //
 155 // relocInfo::runtime_call_type -- a fixed subroutine in the runtime system
 156 //   Value:  an address
 157 //   Instruction types: PC-relative call (or a PC-relative branch)
 158 //   Data:  []   stored in 4 bytes of instruction
 159 //
 160 // relocInfo::static_call_type -- a static call
 161 //   Value:  an CodeBlob, a stub, or a fixup routine
 162 //   Instruction types: a call
 163 //   Data:  []
 164 //   The identity of the callee is extracted from debugging information.
 165 //   //%note reloc_3
 166 //
 167 // relocInfo::virtual_call_type -- a virtual call site (which includes an inline
 168 //                                 cache)
 169 //   Value:  an CodeBlob, a stub, the interpreter, or a fixup routine
 170 //   Instruction types: a call, plus some associated set-oop instructions
 171 //   Data:  []       the associated set-oops are adjacent to the call
 172 //          [n]      n is a relative offset to the first set-oop
 173 //          [[N]n l] and l is a limit within which the set-oops occur
 174 //          [Nn Ll]  both n and l may be 32 bits if necessary
 175 //   The identity of the callee is extracted from debugging information.
 176 //
 177 // relocInfo::opt_virtual_call_type -- a virtual call site that is statically bound
 178 //
 179 //    Same info as a static_call_type. We use a special type, so the handling of
 180 //    virtuals and statics are separated.
 181 //
 182 //
 183 //   The offset n points to the first set-oop.  (See [About Offsets] below.)
 184 //   In turn, the set-oop instruction specifies or contains an oop cell devoted
 185 //   exclusively to the IC call, which can be patched along with the call.
 186 //
 187 //   The locations of any other set-oops are found by searching the relocation
 188 //   information starting at the first set-oop, and continuing until all
 189 //   relocations up through l have been inspected.  The value l is another
 190 //   relative offset.  (Both n and l are relative to the call&#39;s first byte.)
 191 //
 192 //   The limit l of the search is exclusive.  However, if it points within
 193 //   the call (e.g., offset zero), it is adjusted to point after the call and
 194 //   any associated machine-specific delay slot.
 195 //
 196 //   Since the offsets could be as wide as 32-bits, these conventions
 197 //   put no restrictions whatever upon code reorganization.
 198 //
 199 //   The compiler is responsible for ensuring that transition from a clean
 200 //   state to a monomorphic compiled state is MP-safe.  This implies that
 201 //   the system must respond well to intermediate states where a random
 202 //   subset of the set-oops has been correctly from the clean state
 203 //   upon entry to the VEP of the compiled method.  In the case of a
 204 //   machine (Intel) with a single set-oop instruction, the 32-bit
 205 //   immediate field must not straddle a unit of memory coherence.
 206 //   //%note reloc_3
 207 //
 208 // relocInfo::static_stub_type -- an extra stub for each static_call_type
 209 //   Value:  none
 210 //   Instruction types: a virtual call:  { set_oop; jump; }
 211 //   Data:  [[N]n]  the offset of the associated static_call reloc
 212 //   This stub becomes the target of a static call which must be upgraded
 213 //   to a virtual call (because the callee is interpreted).
 214 //   See [About Offsets] below.
 215 //   //%note reloc_2
 216 //
 217 // relocInfo::poll_[return_]type -- a safepoint poll
 218 //   Value:  none
 219 //   Instruction types: memory load or test
 220 //   Data:  none
 221 //
 222 // For example:
 223 //
 224 //   INSTRUCTIONS                        RELOC: TYPE    PREFIX DATA
 225 //   ------------                               ----    -----------
 226 // sethi      %hi(myObject),  R               oop_type [n(myObject)]
 227 // ld      [R+%lo(myObject)+fldOffset], R2    oop_type [n(myObject) fldOffset]
 228 // add R2, 1, R2
 229 // st  R2, [R+%lo(myObject)+fldOffset]        oop_type [n(myObject) fldOffset]
 230 //%note reloc_1
 231 //
 232 // This uses 4 instruction words, 8 relocation halfwords,
 233 // and an entry (which is sharable) in the CodeBlob&#39;s oop pool,
 234 // for a total of 36 bytes.
 235 //
 236 // Note that the compiler is responsible for ensuring the &quot;fldOffset&quot; when
 237 // added to &quot;%lo(myObject)&quot; does not overflow the immediate fields of the
 238 // memory instructions.
 239 //
 240 //
 241 // [About Offsets] Relative offsets are supplied to this module as
 242 // positive byte offsets, but they may be internally stored scaled
 243 // and/or negated, depending on what is most compact for the target
 244 // system.  Since the object pointed to by the offset typically
 245 // precedes the relocation address, it is profitable to store
 246 // these negative offsets as positive numbers, but this decision
 247 // is internal to the relocation information abstractions.
 248 //
 249 
 250 class Relocation;
 251 class CodeBuffer;
 252 class CodeSection;
 253 class RelocIterator;
 254 
 255 class relocInfo {
 256   friend class RelocIterator;
 257  public:
 258   enum relocType {
 259     none                    =  0, // Used when no relocation should be generated
 260     oop_type                =  1, // embedded oop
 261     virtual_call_type       =  2, // a standard inline cache call for a virtual send
 262     opt_virtual_call_type   =  3, // a virtual call that has been statically bound (i.e., no IC cache)
 263     static_call_type        =  4, // a static send
 264     static_stub_type        =  5, // stub-entry for static send  (takes care of interpreter case)
 265     runtime_call_type       =  6, // call to fixed external routine
 266     external_word_type      =  7, // reference to fixed external address
 267     internal_word_type      =  8, // reference within the current code blob
 268     section_word_type       =  9, // internal, but a cross-section reference
 269     poll_type               = 10, // polling instruction for safepoints
 270     poll_return_type        = 11, // polling instruction for safepoints at return
 271     metadata_type           = 12, // metadata that used to be oops
 272     trampoline_stub_type    = 13, // stub-entry for trampoline
 273     runtime_call_w_cp_type  = 14, // Runtime call which may load its target from the constant pool
 274     data_prefix_tag         = 15, // tag for a prefix (carries data arguments)
 275     type_mask               = 15  // A mask which selects only the above values
 276   };
 277 
 278  protected:
 279   unsigned short _value;
 280 
 281   enum RawBitsToken { RAW_BITS };
 282   relocInfo(relocType type, RawBitsToken ignore, int bits)
 283     : _value((type &lt;&lt; nontype_width) + bits) { }
 284 
 285   relocInfo(relocType type, RawBitsToken ignore, int off, int f)
 286     : _value((type &lt;&lt; nontype_width) + (off / (unsigned)offset_unit) + (f &lt;&lt; offset_width)) { }
 287 
 288  public:
 289   // constructor
 290   relocInfo(relocType type, int offset, int format = 0)
 291 #ifndef ASSERT
 292   {
 293     (*this) = relocInfo(type, RAW_BITS, offset, format);
 294   }
 295 #else
 296   // Put a bunch of assertions out-of-line.
 297   ;
 298 #endif
 299 
 300   #define APPLY_TO_RELOCATIONS(visitor) \
 301     visitor(oop) \
 302     visitor(metadata) \
 303     visitor(virtual_call) \
 304     visitor(opt_virtual_call) \
 305     visitor(static_call) \
 306     visitor(static_stub) \
 307     visitor(runtime_call) \
 308     visitor(runtime_call_w_cp) \
 309     visitor(external_word) \
 310     visitor(internal_word) \
 311     visitor(poll) \
 312     visitor(poll_return) \
 313     visitor(section_word) \
 314     visitor(trampoline_stub) \
 315 
 316 
 317  public:
 318   enum {
 319     value_width             = sizeof(unsigned short) * BitsPerByte,
 320     type_width              = 4,   // == log2(type_mask+1)
 321     nontype_width           = value_width - type_width,
 322     datalen_width           = nontype_width-1,
 323     datalen_tag             = 1 &lt;&lt; datalen_width,  // or-ed into _value
 324     datalen_limit           = 1 &lt;&lt; datalen_width,
 325     datalen_mask            = (1 &lt;&lt; datalen_width)-1
 326   };
 327 
 328   // accessors
 329  public:
 330   relocType  type()       const { return (relocType)((unsigned)_value &gt;&gt; nontype_width); }
 331   int  format()           const { return format_mask==0? 0: format_mask &amp;
 332                                          ((unsigned)_value &gt;&gt; offset_width); }
 333   int  addr_offset()      const { assert(!is_prefix(), &quot;must have offset&quot;);
 334                                   return (_value &amp; offset_mask)*offset_unit; }
 335 
 336  protected:
 337   const short* data()     const { assert(is_datalen(), &quot;must have data&quot;);
 338                                   return (const short*)(this + 1); }
 339   int          datalen()  const { assert(is_datalen(), &quot;must have data&quot;);
 340                                   return (_value &amp; datalen_mask); }
 341   int         immediate() const { assert(is_immediate(), &quot;must have immed&quot;);
 342                                   return (_value &amp; datalen_mask); }
 343  public:
 344   static int addr_unit()        { return offset_unit; }
 345   static int offset_limit()     { return (1 &lt;&lt; offset_width) * offset_unit; }
 346 
 347   void set_type(relocType type);
 348 
 349   void remove() { set_type(none); }
 350 
 351  protected:
 352   bool is_none()                const { return type() == none; }
 353   bool is_prefix()              const { return type() == data_prefix_tag; }
 354   bool is_datalen()             const { assert(is_prefix(), &quot;must be prefix&quot;);
 355                                         return (_value &amp; datalen_tag) != 0; }
 356   bool is_immediate()           const { assert(is_prefix(), &quot;must be prefix&quot;);
 357                                         return (_value &amp; datalen_tag) == 0; }
 358 
 359  public:
 360   // Occasionally records of type relocInfo::none will appear in the stream.
 361   // We do not bother to filter these out, but clients should ignore them.
 362   // These records serve as &quot;filler&quot; in three ways:
 363   //  - to skip large spans of unrelocated code (this is rare)
 364   //  - to pad out the relocInfo array to the required oop alignment
 365   //  - to disable old relocation information which is no longer applicable
 366 
 367   inline friend relocInfo filler_relocInfo();
 368 
 369   // Every non-prefix relocation may be preceded by at most one prefix,
 370   // which supplies 1 or more halfwords of associated data.  Conventionally,
 371   // an int is represented by 0, 1, or 2 halfwords, depending on how
 372   // many bits are required to represent the value.  (In addition,
 373   // if the sole halfword is a 10-bit unsigned number, it is made
 374   // &quot;immediate&quot; in the prefix header word itself.  This optimization
 375   // is invisible outside this module.)
 376 
 377   inline friend relocInfo prefix_relocInfo(int datalen);
 378 
 379  protected:
 380   // an immediate relocInfo optimizes a prefix with one 10-bit unsigned value
 381   static relocInfo immediate_relocInfo(int data0) {
 382     assert(fits_into_immediate(data0), &quot;data0 in limits&quot;);
 383     return relocInfo(relocInfo::data_prefix_tag, RAW_BITS, data0);
 384   }
 385   static bool fits_into_immediate(int data0) {
 386     return (data0 &gt;= 0 &amp;&amp; data0 &lt; datalen_limit);
 387   }
 388 
 389  public:
 390   // Support routines for compilers.
 391 
 392   // This routine takes an infant relocInfo (unprefixed) and
 393   // edits in its prefix, if any.  It also updates dest.locs_end.
 394   void initialize(CodeSection* dest, Relocation* reloc);
 395 
 396   // This routine updates a prefix and returns the limit pointer.
 397   // It tries to compress the prefix from 32 to 16 bits, and if
 398   // successful returns a reduced &quot;prefix_limit&quot; pointer.
 399   relocInfo* finish_prefix(short* prefix_limit);
 400 
 401   // bit-packers for the data array:
 402 
 403   // As it happens, the bytes within the shorts are ordered natively,
 404   // but the shorts within the word are ordered big-endian.
 405   // This is an arbitrary choice, made this way mainly to ease debugging.
 406   static int data0_from_int(jint x)         { return x &gt;&gt; value_width; }
 407   static int data1_from_int(jint x)         { return (short)x; }
 408   static jint jint_from_data(short* data) {
 409     return (data[0] &lt;&lt; value_width) + (unsigned short)data[1];
 410   }
 411 
 412   static jint short_data_at(int n, short* data, int datalen) {
 413     return datalen &gt; n ? data[n] : 0;
 414   }
 415 
 416   static jint jint_data_at(int n, short* data, int datalen) {
 417     return datalen &gt; n+1 ? jint_from_data(&amp;data[n]) : short_data_at(n, data, datalen);
 418   }
 419 
 420   // Update methods for relocation information
 421   // (since code is dynamically patched, we also need to dynamically update the relocation info)
 422   // Both methods takes old_type, so it is able to performe sanity checks on the information removed.
 423   static void change_reloc_info_for_address(RelocIterator *itr, address pc, relocType old_type, relocType new_type);
 424 
 425   // Machine dependent stuff
 426 #include CPU_HEADER(relocInfo)
 427 
 428  protected:
 429   // Derived constant, based on format_width which is PD:
 430   enum {
 431     offset_width       = nontype_width - format_width,
 432     offset_mask        = (1&lt;&lt;offset_width) - 1,
 433     format_mask        = (1&lt;&lt;format_width) - 1
 434   };
 435  public:
 436   enum {
 437 #ifdef _LP64
 438     // for use in format
 439     // format_width must be at least 1 on _LP64
 440     narrow_oop_in_const = 1,
 441 #endif
 442     // Conservatively large estimate of maximum length (in shorts)
 443     // of any relocation record.
 444     // Extended format is length prefix, data words, and tag/offset suffix.
 445     length_limit       = 1 + 1 + (3*BytesPerWord/BytesPerShort) + 1,
 446     have_format        = format_width &gt; 0
 447   };
 448 };
 449 
 450 #define FORWARD_DECLARE_EACH_CLASS(name)              \
 451 class name##_Relocation;
 452 APPLY_TO_RELOCATIONS(FORWARD_DECLARE_EACH_CLASS)
 453 #undef FORWARD_DECLARE_EACH_CLASS
 454 
 455 
 456 
 457 inline relocInfo filler_relocInfo() {
 458   return relocInfo(relocInfo::none, relocInfo::offset_limit() - relocInfo::offset_unit);
 459 }
 460 
 461 inline relocInfo prefix_relocInfo(int datalen = 0) {
 462   assert(relocInfo::fits_into_immediate(datalen), &quot;datalen in limits&quot;);
 463   return relocInfo(relocInfo::data_prefix_tag, relocInfo::RAW_BITS, relocInfo::datalen_tag | datalen);
 464 }
 465 
 466 
 467 // Holder for flyweight relocation objects.
 468 // Although the flyweight subclasses are of varying sizes,
 469 // the holder is &quot;one size fits all&quot;.
 470 class RelocationHolder {
 471   friend class Relocation;
 472   friend class CodeSection;
 473 
 474  private:
 475   // this preallocated memory must accommodate all subclasses of Relocation
 476   // (this number is assertion-checked in Relocation::operator new)
 477   enum { _relocbuf_size = 5 };
 478   void* _relocbuf[ _relocbuf_size ];
 479 
 480  public:
 481   Relocation* reloc() const { return (Relocation*) &amp;_relocbuf[0]; }
 482   inline relocInfo::relocType type() const;
 483 
 484   // Add a constant offset to a relocation.  Helper for class Address.
 485   RelocationHolder plus(int offset) const;
 486 
 487   inline RelocationHolder();                // initializes type to none
 488 
 489   inline RelocationHolder(Relocation* r);   // make a copy
 490 
 491   static const RelocationHolder none;
 492 };
 493 
 494 // A RelocIterator iterates through the relocation information of a CodeBlob.
 495 // It is a variable BoundRelocation which is able to take on successive
 496 // values as it is advanced through a code stream.
 497 // Usage:
 498 //   RelocIterator iter(nm);
 499 //   while (iter.next()) {
 500 //     iter.reloc()-&gt;some_operation();
 501 //   }
 502 // or:
 503 //   RelocIterator iter(nm);
 504 //   while (iter.next()) {
 505 //     switch (iter.type()) {
 506 //      case relocInfo::oop_type          :
 507 //      case relocInfo::ic_type           :
 508 //      case relocInfo::prim_type         :
 509 //      case relocInfo::uncommon_type     :
 510 //      case relocInfo::runtime_call_type :
 511 //      case relocInfo::internal_word_type:
 512 //      case relocInfo::external_word_type:
 513 //      ...
 514 //     }
 515 //   }
 516 
 517 class RelocIterator : public StackObj {
 518   enum { SECT_LIMIT = 3 };  // must be equal to CodeBuffer::SECT_LIMIT, checked in ctor
 519   friend class Relocation;
 520   friend class relocInfo;       // for change_reloc_info_for_address only
 521   typedef relocInfo::relocType relocType;
 522 
 523  private:
 524   address         _limit;   // stop producing relocations after this _addr
 525   relocInfo*      _current; // the current relocation information
 526   relocInfo*      _end;     // end marker; we&#39;re done iterating when _current == _end
 527   CompiledMethod* _code;    // compiled method containing _addr
 528   address         _addr;    // instruction to which the relocation applies
 529   short           _databuf; // spare buffer for compressed data
 530   short*          _data;    // pointer to the relocation&#39;s data
 531   short           _datalen; // number of halfwords in _data
 532 
 533   // Base addresses needed to compute targets of section_word_type relocs.
 534   address _section_start[SECT_LIMIT];
 535   address _section_end  [SECT_LIMIT];
 536 
 537   void set_has_current(bool b) {
 538     _datalen = !b ? -1 : 0;
 539     debug_only(_data = NULL);
 540   }
 541   void set_current(relocInfo&amp; ri) {
 542     _current = &amp;ri;
 543     set_has_current(true);
 544   }
 545 
 546   RelocationHolder _rh; // where the current relocation is allocated
 547 
 548   relocInfo* current() const { assert(has_current(), &quot;must have current&quot;);
 549                                return _current; }
 550 
 551   void set_limits(address begin, address limit);
 552 
 553   void advance_over_prefix();    // helper method
 554 
 555   void initialize_misc();
 556 
 557   void initialize(CompiledMethod* nm, address begin, address limit);
 558 
 559   RelocIterator() { initialize_misc(); }
 560 
 561  public:
 562   // constructor
 563   RelocIterator(CompiledMethod* nm, address begin = NULL, address limit = NULL);
 564   RelocIterator(CodeSection* cb, address begin = NULL, address limit = NULL);
 565 
 566   // get next reloc info, return !eos
 567   bool next() {
 568     _current++;
 569     assert(_current &lt;= _end, &quot;must not overrun relocInfo&quot;);
 570     if (_current == _end) {
 571       set_has_current(false);
 572       return false;
 573     }
 574     set_has_current(true);
 575 
 576     if (_current-&gt;is_prefix()) {
 577       advance_over_prefix();
 578       assert(!current()-&gt;is_prefix(), &quot;only one prefix at a time&quot;);
 579     }
 580 
 581     _addr += _current-&gt;addr_offset();
 582 
 583     if (_limit != NULL &amp;&amp; _addr &gt;= _limit) {
 584       set_has_current(false);
 585       return false;
 586     }
 587 
 588     return true;
 589   }
 590 
 591   // accessors
 592   address      limit()        const { return _limit; }
 593   relocType    type()         const { return current()-&gt;type(); }
 594   int          format()       const { return (relocInfo::have_format) ? current()-&gt;format() : 0; }
 595   address      addr()         const { return _addr; }
 596   CompiledMethod*     code()  const { return _code; }
 597   short*       data()         const { return _data; }
 598   int          datalen()      const { return _datalen; }
 599   bool     has_current()      const { return _datalen &gt;= 0; }
 600   bool   addr_in_const()      const;
 601 
 602   address section_start(int n) const {
 603     assert(_section_start[n], &quot;must be initialized&quot;);
 604     return _section_start[n];
 605   }
 606   address section_end(int n) const {
 607     assert(_section_end[n], &quot;must be initialized&quot;);
 608     return _section_end[n];
 609   }
 610 
 611   // The address points to the affected displacement part of the instruction.
 612   // For RISC, this is just the whole instruction.
 613   // For Intel, this is an unaligned 32-bit word.
 614 
 615   // type-specific relocation accessors:  oop_Relocation* oop_reloc(), etc.
 616   #define EACH_TYPE(name)                               \
 617   inline name##_Relocation* name##_reloc();
 618   APPLY_TO_RELOCATIONS(EACH_TYPE)
 619   #undef EACH_TYPE
 620   // generic relocation accessor; switches on type to call the above
 621   Relocation* reloc();
 622 
 623 #ifndef PRODUCT
 624  public:
 625   void print();
 626   void print_current();
 627 #endif
 628 };
 629 
 630 
 631 // A Relocation is a flyweight object allocated within a RelocationHolder.
 632 // It represents the relocation data of relocation record.
 633 // So, the RelocIterator unpacks relocInfos into Relocations.
 634 
 635 class Relocation {
 636   friend class RelocationHolder;
 637   friend class RelocIterator;
 638 
 639  private:
 640   static void guarantee_size();
 641 
 642   // When a relocation has been created by a RelocIterator,
 643   // this field is non-null.  It allows the relocation to know
 644   // its context, such as the address to which it applies.
 645   RelocIterator* _binding;
 646 
 647  protected:
 648   RelocIterator* binding() const {
 649     assert(_binding != NULL, &quot;must be bound&quot;);
 650     return _binding;
 651   }
 652   void set_binding(RelocIterator* b) {
 653     assert(_binding == NULL, &quot;must be unbound&quot;);
 654     _binding = b;
 655     assert(_binding != NULL, &quot;must now be bound&quot;);
 656   }
 657 
 658   Relocation() {
 659     _binding = NULL;
 660   }
 661 
 662   static RelocationHolder newHolder() {
 663     return RelocationHolder();
 664   }
 665 
 666  public:
 667   void* operator new(size_t size, const RelocationHolder&amp; holder) throw() {
 668     if (size &gt; sizeof(holder._relocbuf)) guarantee_size();
 669     assert((void* const *)holder.reloc() == &amp;holder._relocbuf[0], &quot;ptrs must agree&quot;);
 670     return holder.reloc();
 671   }
 672 
 673   // make a generic relocation for a given type (if possible)
 674   static RelocationHolder spec_simple(relocInfo::relocType rtype);
 675 
 676   // here is the type-specific hook which writes relocation data:
 677   virtual void pack_data_to(CodeSection* dest) { }
 678 
 679   // here is the type-specific hook which reads (unpacks) relocation data:
 680   virtual void unpack_data() {
 681     assert(datalen()==0 || type()==relocInfo::none, &quot;no data here&quot;);
 682   }
 683 
 684  protected:
 685   // Helper functions for pack_data_to() and unpack_data().
 686 
 687   // Most of the compression logic is confined here.
 688   // (The &quot;immediate data&quot; mechanism of relocInfo works independently
 689   // of this stuff, and acts to further compress most 1-word data prefixes.)
 690 
 691   // A variable-width int is encoded as a short if it will fit in 16 bits.
 692   // The decoder looks at datalen to decide whether to unpack short or jint.
 693   // Most relocation records are quite simple, containing at most two ints.
 694 
 695   static bool is_short(jint x) { return x == (short)x; }
 696   static short* add_short(short* p, int x)  { *p++ = x; return p; }
 697   static short* add_jint (short* p, jint x) {
 698     *p++ = relocInfo::data0_from_int(x); *p++ = relocInfo::data1_from_int(x);
 699     return p;
 700   }
 701   static short* add_var_int(short* p, jint x) {   // add a variable-width int
 702     if (is_short(x))  p = add_short(p, x);
 703     else              p = add_jint (p, x);
 704     return p;
 705   }
 706 
 707   static short* pack_1_int_to(short* p, jint x0) {
 708     // Format is one of:  [] [x] [Xx]
 709     if (x0 != 0)  p = add_var_int(p, x0);
 710     return p;
 711   }
 712   int unpack_1_int() {
 713     assert(datalen() &lt;= 2, &quot;too much data&quot;);
 714     return relocInfo::jint_data_at(0, data(), datalen());
 715   }
 716 
 717   // With two ints, the short form is used only if both ints are short.
 718   short* pack_2_ints_to(short* p, jint x0, jint x1) {
 719     // Format is one of:  [] [x y?] [Xx Y?y]
 720     if (x0 == 0 &amp;&amp; x1 == 0) {
 721       // no halfwords needed to store zeroes
 722     } else if (is_short(x0) &amp;&amp; is_short(x1)) {
 723       // 1-2 halfwords needed to store shorts
 724       p = add_short(p, x0); if (x1!=0) p = add_short(p, x1);
 725     } else {
 726       // 3-4 halfwords needed to store jints
 727       p = add_jint(p, x0);             p = add_var_int(p, x1);
 728     }
 729     return p;
 730   }
 731   void unpack_2_ints(jint&amp; x0, jint&amp; x1) {
 732     int    dlen = datalen();
 733     short* dp  = data();
 734     if (dlen &lt;= 2) {
 735       x0 = relocInfo::short_data_at(0, dp, dlen);
 736       x1 = relocInfo::short_data_at(1, dp, dlen);
 737     } else {
 738       assert(dlen &lt;= 4, &quot;too much data&quot;);
 739       x0 = relocInfo::jint_data_at(0, dp, dlen);
 740       x1 = relocInfo::jint_data_at(2, dp, dlen);
 741     }
 742   }
 743 
 744  protected:
 745   // platform-independent utility for patching constant section
 746   void       const_set_data_value    (address x);
 747   void       const_verify_data_value (address x);
 748   // platform-dependent utilities for decoding and patching instructions
 749   void       pd_set_data_value       (address x, intptr_t off, bool verify_only = false); // a set or mem-ref
 750   void       pd_verify_data_value    (address x, intptr_t off) { pd_set_data_value(x, off, true); }
 751   address    pd_call_destination     (address orig_addr = NULL);
 752   void       pd_set_call_destination (address x);
 753 
 754   // this extracts the address of an address in the code stream instead of the reloc data
 755   address* pd_address_in_code       ();
 756 
 757   // this extracts an address from the code stream instead of the reloc data
 758   address  pd_get_address_from_code ();
 759 
 760   // these convert from byte offsets, to scaled offsets, to addresses
 761   static jint scaled_offset(address x, address base) {
 762     int byte_offset = x - base;
 763     int offset = -byte_offset / relocInfo::addr_unit();
 764     assert(address_from_scaled_offset(offset, base) == x, &quot;just checkin&#39;&quot;);
 765     return offset;
 766   }
 767   static jint scaled_offset_null_special(address x, address base) {
 768     // Some relocations treat offset=0 as meaning NULL.
 769     // Handle this extra convention carefully.
 770     if (x == NULL)  return 0;
 771     assert(x != base, &quot;offset must not be zero&quot;);
 772     return scaled_offset(x, base);
 773   }
 774   static address address_from_scaled_offset(jint offset, address base) {
 775     int byte_offset = -( offset * relocInfo::addr_unit() );
 776     return base + byte_offset;
 777   }
 778 
 779   // helpers for mapping between old and new addresses after a move or resize
 780   address old_addr_for(address newa, const CodeBuffer* src, CodeBuffer* dest);
 781   address new_addr_for(address olda, const CodeBuffer* src, CodeBuffer* dest);
 782   void normalize_address(address&amp; addr, const CodeSection* dest, bool allow_other_sections = false);
 783 
 784  public:
 785   // accessors which only make sense for a bound Relocation
 786   address         addr()            const { return binding()-&gt;addr(); }
 787   CompiledMethod* code()            const { return binding()-&gt;code(); }
 788   bool            addr_in_const()   const { return binding()-&gt;addr_in_const(); }
 789  protected:
 790   short*   data()         const { return binding()-&gt;data(); }
 791   int      datalen()      const { return binding()-&gt;datalen(); }
 792   int      format()       const { return binding()-&gt;format(); }
 793 
 794  public:
 795   virtual relocInfo::relocType type()            { return relocInfo::none; }
 796 
 797   // is it a call instruction?
 798   virtual bool is_call()                         { return false; }
 799 
 800   // is it a data movement instruction?
 801   virtual bool is_data()                         { return false; }
 802 
 803   // some relocations can compute their own values
 804   virtual address  value();
 805 
 806   // all relocations are able to reassert their values
 807   virtual void set_value(address x);
 808 
 809   virtual bool clear_inline_cache()              { return true; }
 810 
 811   // This method assumes that all virtual/static (inline) caches are cleared (since for static_call_type and
 812   // ic_call_type is not always posisition dependent (depending on the state of the cache)). However, this is
 813   // probably a reasonable assumption, since empty caches simplifies code reloacation.
 814   virtual void fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest) { }
 815 };
 816 
 817 
 818 // certain inlines must be deferred until class Relocation is defined:
 819 
 820 inline RelocationHolder::RelocationHolder() {
 821   // initialize the vtbl, just to keep things type-safe
 822   new(*this) Relocation();
 823 }
 824 
 825 
 826 inline RelocationHolder::RelocationHolder(Relocation* r) {
 827   // wordwise copy from r (ok if it copies garbage after r)
 828   for (int i = 0; i &lt; _relocbuf_size; i++) {
 829     _relocbuf[i] = ((void**)r)[i];
 830   }
 831 }
 832 
 833 
 834 relocInfo::relocType RelocationHolder::type() const {
 835   return reloc()-&gt;type();
 836 }
 837 
 838 // A DataRelocation always points at a memory or load-constant instruction..
 839 // It is absolute on most machines, and the constant is split on RISCs.
 840 // The specific subtypes are oop, external_word, and internal_word.
 841 // By convention, the &quot;value&quot; does not include a separately reckoned &quot;offset&quot;.
 842 class DataRelocation : public Relocation {
 843  public:
 844   bool          is_data()                      { return true; }
 845 
 846   // both target and offset must be computed somehow from relocation data
 847   virtual int    offset()                      { return 0; }
 848   address         value()                      = 0;
 849   void        set_value(address x)             { set_value(x, offset()); }
 850   void        set_value(address x, intptr_t o) {
 851     if (addr_in_const())
 852       const_set_data_value(x);
 853     else
 854       pd_set_data_value(x, o);
 855   }
 856   void        verify_value(address x) {
 857     if (addr_in_const())
 858       const_verify_data_value(x);
 859     else
 860       pd_verify_data_value(x, offset());
 861   }
 862 
 863   // The &quot;o&quot; (displacement) argument is relevant only to split relocations
 864   // on RISC machines.  In some CPUs (SPARC), the set-hi and set-lo ins&#39;ns
 865   // can encode more than 32 bits between them.  This allows compilers to
 866   // share set-hi instructions between addresses that differ by a small
 867   // offset (e.g., different static variables in the same class).
 868   // On such machines, the &quot;x&quot; argument to set_value on all set-lo
 869   // instructions must be the same as the &quot;x&quot; argument for the
 870   // corresponding set-hi instructions.  The &quot;o&quot; arguments for the
 871   // set-hi instructions are ignored, and must not affect the high-half
 872   // immediate constant.  The &quot;o&quot; arguments for the set-lo instructions are
 873   // added into the low-half immediate constant, and must not overflow it.
 874 };
 875 
 876 // A CallRelocation always points at a call instruction.
 877 // It is PC-relative on most machines.
 878 class CallRelocation : public Relocation {
 879  public:
 880   bool is_call() { return true; }
 881 
 882   address  destination()                    { return pd_call_destination(); }
 883   void     set_destination(address x); // pd_set_call_destination
 884 
 885   void     fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest);
 886   address  value()                          { return destination();  }
 887   void     set_value(address x)             { set_destination(x); }
 888 };
 889 
 890 class oop_Relocation : public DataRelocation {
 891   relocInfo::relocType type() { return relocInfo::oop_type; }
 892 
 893  public:
 894   // encode in one of these formats:  [] [n] [n l] [Nn l] [Nn Ll]
 895   // an oop in the CodeBlob&#39;s oop pool
 896   static RelocationHolder spec(int oop_index, int offset = 0) {
 897     assert(oop_index &gt; 0, &quot;must be a pool-resident oop&quot;);
 898     RelocationHolder rh = newHolder();
 899     new(rh) oop_Relocation(oop_index, offset);
 900     return rh;
 901   }
 902   // an oop in the instruction stream
 903   static RelocationHolder spec_for_immediate() {
 904     // If no immediate oops are generated, we can skip some walks over nmethods.
 905     // Assert that they don&#39;t get generated accidently!
 906     assert(relocInfo::mustIterateImmediateOopsInCode(),
 907            &quot;Must return true so we will search for oops as roots etc. in the code.&quot;);
 908     const int oop_index = 0;
 909     const int offset    = 0;    // if you want an offset, use the oop pool
 910     RelocationHolder rh = newHolder();
 911     new(rh) oop_Relocation(oop_index, offset);
 912     return rh;
 913   }
 914 
 915  private:
 916   jint _oop_index;                  // if &gt; 0, index into CodeBlob::oop_at
 917   jint _offset;                     // byte offset to apply to the oop itself
 918 
 919   oop_Relocation(int oop_index, int offset) {
 920     _oop_index = oop_index; _offset = offset;
 921   }
 922 
 923   friend class RelocIterator;
 924   oop_Relocation() { }
 925 
 926  public:
 927   int oop_index() { return _oop_index; }
 928   int offset()    { return _offset; }
 929 
 930   // data is packed in &quot;2_ints&quot; format:  [i o] or [Ii Oo]
 931   void pack_data_to(CodeSection* dest);
 932   void unpack_data();
 933 
 934   void fix_oop_relocation();        // reasserts oop value
 935 
 936   void verify_oop_relocation();
 937 
<a name="1" id="anc1"></a><span class="line-modified"> 938   address value()  { return (address) *oop_addr(); }</span>
 939 
 940   bool oop_is_immediate()  { return oop_index() == 0; }
 941 
 942   oop* oop_addr();                  // addr or &amp;pool[jint_data]
 943   oop  oop_value();                 // *oop_addr
 944   // Note:  oop_value transparently converts Universe::non_oop_word to NULL.
 945 };
 946 
 947 
 948 // copy of oop_Relocation for now but may delete stuff in both/either
 949 class metadata_Relocation : public DataRelocation {
 950   relocInfo::relocType type() { return relocInfo::metadata_type; }
 951 
 952  public:
 953   // encode in one of these formats:  [] [n] [n l] [Nn l] [Nn Ll]
 954   // an metadata in the CodeBlob&#39;s metadata pool
 955   static RelocationHolder spec(int metadata_index, int offset = 0) {
 956     assert(metadata_index &gt; 0, &quot;must be a pool-resident metadata&quot;);
 957     RelocationHolder rh = newHolder();
 958     new(rh) metadata_Relocation(metadata_index, offset);
 959     return rh;
 960   }
 961   // an metadata in the instruction stream
 962   static RelocationHolder spec_for_immediate() {
 963     const int metadata_index = 0;
 964     const int offset    = 0;    // if you want an offset, use the metadata pool
 965     RelocationHolder rh = newHolder();
 966     new(rh) metadata_Relocation(metadata_index, offset);
 967     return rh;
 968   }
 969 
 970  private:
 971   jint _metadata_index;            // if &gt; 0, index into nmethod::metadata_at
 972   jint _offset;                     // byte offset to apply to the metadata itself
 973 
 974   metadata_Relocation(int metadata_index, int offset) {
 975     _metadata_index = metadata_index; _offset = offset;
 976   }
 977 
 978   friend class RelocIterator;
 979   metadata_Relocation() { }
 980 
 981   // Fixes a Metadata pointer in the code. Most platforms embeds the
 982   // Metadata pointer in the code at compile time so this is empty
 983   // for them.
 984   void pd_fix_value(address x);
 985 
 986  public:
 987   int metadata_index() { return _metadata_index; }
 988   int offset()    { return _offset; }
 989 
 990   // data is packed in &quot;2_ints&quot; format:  [i o] or [Ii Oo]
 991   void pack_data_to(CodeSection* dest);
 992   void unpack_data();
 993 
 994   void fix_metadata_relocation();        // reasserts metadata value
 995 
 996   address value()  { return (address) *metadata_addr(); }
 997 
 998   bool metadata_is_immediate()  { return metadata_index() == 0; }
 999 
1000   Metadata**   metadata_addr();                  // addr or &amp;pool[jint_data]
1001   Metadata*    metadata_value();                 // *metadata_addr
1002   // Note:  metadata_value transparently converts Universe::non_metadata_word to NULL.
1003 };
1004 
1005 
1006 class virtual_call_Relocation : public CallRelocation {
1007   relocInfo::relocType type() { return relocInfo::virtual_call_type; }
1008 
1009  public:
1010   // &quot;cached_value&quot; points to the first associated set-oop.
1011   // The oop_limit helps find the last associated set-oop.
1012   // (See comments at the top of this file.)
1013   static RelocationHolder spec(address cached_value, jint method_index = 0) {
1014     RelocationHolder rh = newHolder();
1015     new(rh) virtual_call_Relocation(cached_value, method_index);
1016     return rh;
1017   }
1018 
1019  private:
1020   address _cached_value; // location of set-value instruction
1021   jint    _method_index; // resolved method for a Java call
1022 
1023   virtual_call_Relocation(address cached_value, int method_index) {
1024     _cached_value = cached_value;
1025     _method_index = method_index;
1026     assert(cached_value != NULL, &quot;first oop address must be specified&quot;);
1027   }
1028 
1029   friend class RelocIterator;
1030   virtual_call_Relocation() { }
1031 
1032  public:
1033   address cached_value();
1034 
1035   int     method_index() { return _method_index; }
1036   Method* method_value();
1037 
1038   // data is packed as scaled offsets in &quot;2_ints&quot; format:  [f l] or [Ff Ll]
1039   // oop_limit is set to 0 if the limit falls somewhere within the call.
1040   // When unpacking, a zero oop_limit is taken to refer to the end of the call.
1041   // (This has the effect of bringing in the call&#39;s delay slot on SPARC.)
1042   void pack_data_to(CodeSection* dest);
1043   void unpack_data();
1044 
1045   bool clear_inline_cache();
1046 };
1047 
1048 
1049 class opt_virtual_call_Relocation : public CallRelocation {
1050   relocInfo::relocType type() { return relocInfo::opt_virtual_call_type; }
1051 
1052  public:
1053   static RelocationHolder spec(int method_index = 0) {
1054     RelocationHolder rh = newHolder();
1055     new(rh) opt_virtual_call_Relocation(method_index);
1056     return rh;
1057   }
1058 
1059  private:
1060   jint _method_index; // resolved method for a Java call
1061 
1062   opt_virtual_call_Relocation(int method_index) {
1063     _method_index = method_index;
1064   }
1065 
1066   friend class RelocIterator;
1067   opt_virtual_call_Relocation() {}
1068 
1069  public:
1070   int     method_index() { return _method_index; }
1071   Method* method_value();
1072 
1073   void pack_data_to(CodeSection* dest);
1074   void unpack_data();
1075 
1076   bool clear_inline_cache();
1077 
1078   // find the matching static_stub
1079   address static_stub(bool is_aot);
1080 };
1081 
1082 
1083 class static_call_Relocation : public CallRelocation {
1084   relocInfo::relocType type() { return relocInfo::static_call_type; }
1085 
1086  public:
1087   static RelocationHolder spec(int method_index = 0) {
1088     RelocationHolder rh = newHolder();
1089     new(rh) static_call_Relocation(method_index);
1090     return rh;
1091   }
1092 
1093  private:
1094   jint _method_index; // resolved method for a Java call
1095 
1096   static_call_Relocation(int method_index) {
1097     _method_index = method_index;
1098   }
1099 
1100   friend class RelocIterator;
1101   static_call_Relocation() {}
1102 
1103  public:
1104   int     method_index() { return _method_index; }
1105   Method* method_value();
1106 
1107   void pack_data_to(CodeSection* dest);
1108   void unpack_data();
1109 
1110   bool clear_inline_cache();
1111 
1112   // find the matching static_stub
1113   address static_stub(bool is_aot);
1114 };
1115 
1116 class static_stub_Relocation : public Relocation {
1117   relocInfo::relocType type() { return relocInfo::static_stub_type; }
1118 
1119  public:
1120   static RelocationHolder spec(address static_call, bool is_aot = false) {
1121     RelocationHolder rh = newHolder();
1122     new(rh) static_stub_Relocation(static_call, is_aot);
1123     return rh;
1124   }
1125 
1126  private:
1127   address _static_call;  // location of corresponding static_call
1128   bool _is_aot;          // trampoline to aot code
1129 
1130   static_stub_Relocation(address static_call, bool is_aot) {
1131     _static_call = static_call;
1132     _is_aot = is_aot;
1133   }
1134 
1135   friend class RelocIterator;
1136   static_stub_Relocation() { }
1137 
1138  public:
1139   bool clear_inline_cache();
1140 
1141   address static_call() { return _static_call; }
1142   bool is_aot() { return _is_aot; }
1143 
1144   // data is packed as a scaled offset in &quot;1_int&quot; format:  [c] or [Cc]
1145   void pack_data_to(CodeSection* dest);
1146   void unpack_data();
1147 };
1148 
1149 class runtime_call_Relocation : public CallRelocation {
1150   relocInfo::relocType type() { return relocInfo::runtime_call_type; }
1151 
1152  public:
1153   static RelocationHolder spec() {
1154     RelocationHolder rh = newHolder();
1155     new(rh) runtime_call_Relocation();
1156     return rh;
1157   }
1158 
1159  private:
1160   friend class RelocIterator;
1161   runtime_call_Relocation() { }
1162 
1163  public:
1164 };
1165 
1166 
1167 class runtime_call_w_cp_Relocation : public CallRelocation {
1168   relocInfo::relocType type() { return relocInfo::runtime_call_w_cp_type; }
1169 
1170  public:
1171   static RelocationHolder spec() {
1172     RelocationHolder rh = newHolder();
1173     new(rh) runtime_call_w_cp_Relocation();
1174     return rh;
1175   }
1176 
1177  private:
1178   friend class RelocIterator;
1179   runtime_call_w_cp_Relocation() { _offset = -4; /* &lt;0 = invalid */ }
1180   // On z/Architecture, runtime calls are either a sequence
1181   // of two instructions (load destination of call from constant pool + do call)
1182   // or a pc-relative call. The pc-relative call is faster, but it can only
1183   // be used if the destination of the call is not too far away.
1184   // In order to be able to patch a pc-relative call back into one using
1185   // the constant pool, we have to remember the location of the call&#39;s destination
1186   // in the constant pool.
1187   int _offset;
1188 
1189  public:
1190   void set_constant_pool_offset(int offset) { _offset = offset; }
1191   int get_constant_pool_offset() { return _offset; }
1192   void pack_data_to(CodeSection * dest);
1193   void unpack_data();
1194 };
1195 
1196 // Trampoline Relocations.
1197 // A trampoline allows to encode a small branch in the code, even if there
1198 // is the chance that this branch can not reach all possible code locations.
1199 // If the relocation finds that a branch is too far for the instruction
1200 // in the code, it can patch it to jump to the trampoline where is
1201 // sufficient space for a far branch. Needed on PPC.
1202 class trampoline_stub_Relocation : public Relocation {
1203   relocInfo::relocType type() { return relocInfo::trampoline_stub_type; }
1204 
1205  public:
1206   static RelocationHolder spec(address static_call) {
1207     RelocationHolder rh = newHolder();
1208     return (new (rh) trampoline_stub_Relocation(static_call));
1209   }
1210 
1211  private:
1212   address _owner;    // Address of the NativeCall that owns the trampoline.
1213 
1214   trampoline_stub_Relocation(address owner) {
1215     _owner = owner;
1216   }
1217 
1218   friend class RelocIterator;
1219   trampoline_stub_Relocation() { }
1220 
1221  public:
1222 
1223   // Return the address of the NativeCall that owns the trampoline.
1224   address owner() { return _owner; }
1225 
1226   void pack_data_to(CodeSection * dest);
1227   void unpack_data();
1228 
1229   // Find the trampoline stub for a call.
1230   static address get_trampoline_for(address call, nmethod* code);
1231 };
1232 
1233 class external_word_Relocation : public DataRelocation {
1234   relocInfo::relocType type() { return relocInfo::external_word_type; }
1235 
1236  public:
1237   static RelocationHolder spec(address target) {
1238     assert(target != NULL, &quot;must not be null&quot;);
1239     RelocationHolder rh = newHolder();
1240     new(rh) external_word_Relocation(target);
1241     return rh;
1242   }
1243 
1244   // Use this one where all 32/64 bits of the target live in the code stream.
1245   // The target must be an intptr_t, and must be absolute (not relative).
1246   static RelocationHolder spec_for_immediate() {
1247     RelocationHolder rh = newHolder();
1248     new(rh) external_word_Relocation(NULL);
1249     return rh;
1250   }
1251 
1252   // Some address looking values aren&#39;t safe to treat as relocations
1253   // and should just be treated as constants.
1254   static bool can_be_relocated(address target) {
1255     assert(target == NULL || (uintptr_t)target &gt;= (uintptr_t)os::vm_page_size(), INTPTR_FORMAT, (intptr_t)target);
1256     return target != NULL;
1257   }
1258 
1259  private:
1260   address _target;                  // address in runtime
1261 
1262   external_word_Relocation(address target) {
1263     _target = target;
1264   }
1265 
1266   friend class RelocIterator;
1267   external_word_Relocation() { }
1268 
1269  public:
1270   // data is packed as a well-known address in &quot;1_int&quot; format:  [a] or [Aa]
1271   // The function runtime_address_to_index is used to turn full addresses
1272   // to short indexes, if they are pre-registered by the stub mechanism.
1273   // If the &quot;a&quot; value is 0 (i.e., _target is NULL), the address is stored
1274   // in the code stream.  See external_word_Relocation::target().
1275   void pack_data_to(CodeSection* dest);
1276   void unpack_data();
1277 
1278   void fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest);
1279   address  target();        // if _target==NULL, fetch addr from code stream
1280   address  value()          { return target(); }
1281 };
1282 
1283 class internal_word_Relocation : public DataRelocation {
1284   relocInfo::relocType type() { return relocInfo::internal_word_type; }
1285 
1286  public:
1287   static RelocationHolder spec(address target) {
1288     assert(target != NULL, &quot;must not be null&quot;);
1289     RelocationHolder rh = newHolder();
1290     new(rh) internal_word_Relocation(target);
1291     return rh;
1292   }
1293 
1294   // use this one where all the bits of the target can fit in the code stream:
1295   static RelocationHolder spec_for_immediate() {
1296     RelocationHolder rh = newHolder();
1297     new(rh) internal_word_Relocation(NULL);
1298     return rh;
1299   }
1300 
1301   internal_word_Relocation(address target) {
1302     _target  = target;
1303     _section = -1;  // self-relative
1304   }
1305 
1306  protected:
1307   address _target;                  // address in CodeBlob
1308   int     _section;                 // section providing base address, if any
1309 
1310   friend class RelocIterator;
1311   internal_word_Relocation() { }
1312 
1313   // bit-width of LSB field in packed offset, if section &gt;= 0
1314   enum { section_width = 2 }; // must equal CodeBuffer::sect_bits
1315 
1316  public:
1317   // data is packed as a scaled offset in &quot;1_int&quot; format:  [o] or [Oo]
1318   // If the &quot;o&quot; value is 0 (i.e., _target is NULL), the offset is stored
1319   // in the code stream.  See internal_word_Relocation::target().
1320   // If _section is not -1, it is appended to the low bits of the offset.
1321   void pack_data_to(CodeSection* dest);
1322   void unpack_data();
1323 
1324   void fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest);
1325   address  target();        // if _target==NULL, fetch addr from code stream
1326   int      section()        { return _section;   }
1327   address  value()          { return target();   }
1328 };
1329 
1330 class section_word_Relocation : public internal_word_Relocation {
1331   relocInfo::relocType type() { return relocInfo::section_word_type; }
1332 
1333  public:
1334   static RelocationHolder spec(address target, int section) {
1335     RelocationHolder rh = newHolder();
1336     new(rh) section_word_Relocation(target, section);
1337     return rh;
1338   }
1339 
1340   section_word_Relocation(address target, int section) {
1341     assert(target != NULL, &quot;must not be null&quot;);
1342     assert(section &gt;= 0, &quot;must be a valid section&quot;);
1343     _target  = target;
1344     _section = section;
1345   }
1346 
1347   //void pack_data_to -- inherited
1348   void unpack_data();
1349 
1350  private:
1351   friend class RelocIterator;
1352   section_word_Relocation() { }
1353 };
1354 
1355 
1356 class poll_Relocation : public Relocation {
1357   bool          is_data()                      { return true; }
1358   relocInfo::relocType type() { return relocInfo::poll_type; }
1359   void     fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest);
1360 };
1361 
1362 class poll_return_Relocation : public poll_Relocation {
1363   relocInfo::relocType type() { return relocInfo::poll_return_type; }
1364 };
1365 
1366 // We know all the xxx_Relocation classes, so now we can define these:
1367 #define EACH_CASE(name)                                         \
1368 inline name##_Relocation* RelocIterator::name##_reloc() {       \
1369   assert(type() == relocInfo::name##_type, &quot;type must agree&quot;);  \
1370   /* The purpose of the placed &quot;new&quot; is to re-use the same */   \
1371   /* stack storage for each new iteration. */                   \
1372   name##_Relocation* r = new(_rh) name##_Relocation();          \
1373   r-&gt;set_binding(this);                                         \
1374   r-&gt;name##_Relocation::unpack_data();                          \
1375   return r;                                                     \
1376 }
1377 APPLY_TO_RELOCATIONS(EACH_CASE);
1378 #undef EACH_CASE
1379 
1380 inline RelocIterator::RelocIterator(CompiledMethod* nm, address begin, address limit) {
1381   initialize(nm, begin, limit);
1382 }
1383 
1384 #endif // SHARE_CODE_RELOCINFO_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
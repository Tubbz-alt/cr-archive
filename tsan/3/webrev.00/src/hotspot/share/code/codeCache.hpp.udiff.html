<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/code/codeCache.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="codeCache.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="codeHeapState.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/codeCache.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -145,11 +145,11 @@</span>
    static bool contains(void *p);                           // returns whether p is included
    static bool contains(nmethod* nm);                       // returns whether nm is included
    static void blobs_do(void f(CodeBlob* cb));              // iterates over all CodeBlobs
    static void blobs_do(CodeBlobClosure* f);                // iterates over all CodeBlobs
    static void nmethods_do(void f(nmethod* nm));            // iterates over all nmethods
<span class="udiff-line-modified-removed">-   static void metadata_do(void f(Metadata* m));            // iterates over metadata in alive nmethods</span>
<span class="udiff-line-modified-added">+   static void metadata_do(MetadataClosure* f);             // iterates over metadata in alive nmethods</span>
  
    // Lookup
    static CodeBlob* find_blob(void* start);              // Returns the CodeBlob containing the given address
    static CodeBlob* find_blob_unsafe(void* start);       // Same as find_blob but does not fail if looking up a zombie method
    static nmethod*  find_nmethod(void* start);           // Returns the nmethod containing the given address
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -168,10 +168,11 @@</span>
    // to) any unmarked codeBlobs in the cache.  Sets &quot;marked_for_unloading&quot;
    // to &quot;true&quot; iff some code got unloaded.
    // &quot;unloading_occurred&quot; controls whether metadata should be cleaned because of class unloading.
    class UnloadingScope: StackObj {
      ClosureIsUnloadingBehaviour _is_unloading_behaviour;
<span class="udiff-line-added">+     IsUnloadingBehaviour*       _saved_behaviour;</span>
  
    public:
      UnloadingScope(BoolObjectClosure* is_alive);
      ~UnloadingScope();
    };
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -268,14 +269,20 @@</span>
    static int  mark_for_deoptimization(Method* dependee);
    static void make_marked_nmethods_not_entrant();
  
    // Flushing and deoptimization
    static void flush_dependents_on(InstanceKlass* dependee);
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // RedefineClasses support</span>
    // Flushing and deoptimization in case of evolution
    static void mark_for_evol_deoptimization(InstanceKlass* dependee);
    static int  mark_dependents_for_evol_deoptimization();
<span class="udiff-line-added">+   static void mark_all_nmethods_for_evol_deoptimization();</span>
    static void flush_evol_dependents();
<span class="udiff-line-added">+   static void old_nmethods_do(MetadataClosure* f);</span>
<span class="udiff-line-added">+   static void unregister_old_nmethod(CompiledMethod* c);</span>
<span class="udiff-line-added">+ </span>
    // Support for fullspeed debugging
    static void flush_dependents_on_method(const methodHandle&amp; dependee);
  
    // tells how many nmethods have dependencies
    static int number_of_nmethods_with_dependencies();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -285,11 +292,11 @@</span>
      return (heap != NULL) ? heap-&gt;full_count() : 0;
    }
  
    // CodeHeap State Analytics.
    // interface methods for CodeHeap printing, called by CompileBroker
<span class="udiff-line-modified-removed">-   static void aggregate(outputStream *out, const char* granularity);</span>
<span class="udiff-line-modified-added">+   static void aggregate(outputStream *out, size_t granularity);</span>
    static void discard(outputStream *out);
    static void print_usedSpace(outputStream *out);
    static void print_freeSpace(outputStream *out);
    static void print_count(outputStream *out);
    static void print_space(outputStream *out);
</pre>
<center><a href="codeCache.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="codeHeapState.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
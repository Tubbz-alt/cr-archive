<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/code/exceptionHandlerTable.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="exceptionHandlerTable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="icBuffer.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/exceptionHandlerTable.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
129 };
130 
131 
132 // ----------------------------------------------------------------------------
133 // Implicit null exception tables.  Maps an exception PC offset to a
134 // continuation PC offset.  During construction it&#39;s a variable sized
135 // array with a max size and current length.  When stored inside an
136 // nmethod a zero length table takes no space.  This is detected by
137 // nul_chk_table_size() == 0.  Otherwise the table has a length word
138 // followed by pairs of &lt;excp-offset, const-offset&gt;.
139 
140 // Use 32-bit representation for offsets
141 typedef  uint              implicit_null_entry;
142 
143 class ImplicitExceptionTable {
144   uint _size;
145   uint _len;
146   implicit_null_entry *_data;
147   implicit_null_entry *adr( uint idx ) const { return &amp;_data[2*idx]; }
148   ReallocMark          _nesting;  // assertion check for reallocations

149 public:
150   ImplicitExceptionTable( ) :  _size(0), _len(0), _data(0) { }
151   // (run-time) construction from nmethod
<span class="line-modified">152   ImplicitExceptionTable( const nmethod *nm );</span>
153 
154   void set_size( uint size );
155   void append( uint exec_off, uint cont_off );
<span class="line-modified">156   uint at( uint exec_off ) const;</span>











157 
158   uint len() const { return _len; }




159   int size_in_bytes() const { return len() == 0 ? 0 : ((2 * len() + 1) * sizeof(implicit_null_entry)); }
160 
161   void copy_to(nmethod* nm);

162   void print(address base) const;
163   void verify(nmethod *nm) const;
164 };
165 
166 #endif // SHARE_CODE_EXCEPTIONHANDLERTABLE_HPP
</pre>
</td>
<td>
<hr />
<pre>
129 };
130 
131 
132 // ----------------------------------------------------------------------------
133 // Implicit null exception tables.  Maps an exception PC offset to a
134 // continuation PC offset.  During construction it&#39;s a variable sized
135 // array with a max size and current length.  When stored inside an
136 // nmethod a zero length table takes no space.  This is detected by
137 // nul_chk_table_size() == 0.  Otherwise the table has a length word
138 // followed by pairs of &lt;excp-offset, const-offset&gt;.
139 
140 // Use 32-bit representation for offsets
141 typedef  uint              implicit_null_entry;
142 
143 class ImplicitExceptionTable {
144   uint _size;
145   uint _len;
146   implicit_null_entry *_data;
147   implicit_null_entry *adr( uint idx ) const { return &amp;_data[2*idx]; }
148   ReallocMark          _nesting;  // assertion check for reallocations
<span class="line-added">149 </span>
150 public:
151   ImplicitExceptionTable( ) :  _size(0), _len(0), _data(0) { }
152   // (run-time) construction from nmethod
<span class="line-modified">153   ImplicitExceptionTable( const CompiledMethod *nm );</span>
154 
155   void set_size( uint size );
156   void append( uint exec_off, uint cont_off );
<span class="line-modified">157 </span>
<span class="line-added">158 #if INCLUDE_JVMCI</span>
<span class="line-added">159   void add_deoptimize(uint exec_off) {</span>
<span class="line-added">160     // Use the same offset as a marker value for deoptimization</span>
<span class="line-added">161     append(exec_off, exec_off);</span>
<span class="line-added">162   }</span>
<span class="line-added">163 #endif</span>
<span class="line-added">164 </span>
<span class="line-added">165   // Returns the offset to continue execution at.  If the returned</span>
<span class="line-added">166   // value equals exec_off then the dispatch is expected to be a</span>
<span class="line-added">167   // deoptimization instead.</span>
<span class="line-added">168   uint continuation_offset( uint exec_off ) const;</span>
169 
170   uint len() const { return _len; }
<span class="line-added">171 </span>
<span class="line-added">172   uint get_exec_offset(uint i) { assert(i &lt; _len, &quot;oob&quot;); return *adr(i); }</span>
<span class="line-added">173   uint get_cont_offset(uint i) { assert(i &lt; _len, &quot;oob&quot;); return *(adr(i) + 1); }</span>
<span class="line-added">174 </span>
175   int size_in_bytes() const { return len() == 0 ? 0 : ((2 * len() + 1) * sizeof(implicit_null_entry)); }
176 
177   void copy_to(nmethod* nm);
<span class="line-added">178   void copy_bytes_to(address addr, int size);</span>
179   void print(address base) const;
180   void verify(nmethod *nm) const;
181 };
182 
183 #endif // SHARE_CODE_EXCEPTIONHANDLERTABLE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="exceptionHandlerTable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="icBuffer.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
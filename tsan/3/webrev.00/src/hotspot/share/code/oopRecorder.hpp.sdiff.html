<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/code/oopRecorder.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="oopRecorder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="pcDesc.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/oopRecorder.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CODE_OOPRECORDER_HPP
 26 #define SHARE_CODE_OOPRECORDER_HPP
 27 
<span class="line-removed"> 28 #include &quot;memory/universe.hpp&quot;</span>
 29 #include &quot;runtime/handles.hpp&quot;
 30 #include &quot;utilities/growableArray.hpp&quot;
 31 
 32 // Recording and retrieval of either oop relocations or metadata in compiled code.
 33 
 34 class CodeBlob;
 35 
 36 template &lt;class T&gt; class ValueRecorder : public StackObj {
 37  public:
 38   // A two-way mapping from positive indexes to oop handles.
 39   // The zero index is reserved for a constant (sharable) null.
 40   // Indexes may not be negative.
 41 
 42   // Use the given arena to manage storage, if not NULL.
 43   // By default, uses the current ResourceArea.
 44   ValueRecorder(Arena* arena = NULL);
 45 
 46   // Generate a new index on which nmethod::oop_addr_at will work.
 47   // allocate_index and find_index never return the same index,
 48   // and allocate_index never returns the same index twice.
</pre>
<hr />
<pre>
 60     if (index &lt; 0) {  // previously unallocated
 61       index = add_handle(h, true);
 62     }
 63     return index;
 64   }
 65 
 66   // returns the size of the generated oop/metadata table, for sizing the
 67   // CodeBlob. Must be called after all oops are allocated!
 68   int size();
 69 
 70   // Retrieve the value at a given index.
 71   T at(int index);
 72 
 73   int count() {
 74     if (_handles == NULL) return 0;
 75     // there is always a NULL virtually present as first object
 76     return _handles-&gt;length() + first_index;
 77   }
 78 
 79   // Helper function; returns false for NULL or Universe::non_oop_word().
<span class="line-modified"> 80   bool is_real(T h) {</span>
<span class="line-removed"> 81     return h != NULL &amp;&amp; h != (T)Universe::non_oop_word();</span>
<span class="line-removed"> 82   }</span>
 83 
 84   // copy the generated table to nmethod
 85   void copy_values_to(nmethod* nm);
 86 
 87   bool is_unused() { return _handles == NULL &amp;&amp; !_complete; }
 88 #ifdef ASSERT
 89   bool is_complete() { return _complete; }
 90 #endif
 91 
 92  private:
 93   // variant of find_index which does not allocate if not found (yields -1)
 94   int maybe_find_index(T h);
 95 
 96   // leaky hash table of handle =&gt; index, to help detect duplicate insertion
 97   template &lt;class X&gt; class IndexCache : public ResourceObj {
 98     // This class is only used by the ValueRecorder class.
 99     friend class ValueRecorder;
100     enum {
101       _log_cache_size = 9,
102       _cache_size = (1&lt;&lt;_log_cache_size),
</pre>
<hr />
<pre>
190     } else {
191       _object_lookup = NULL;
192     }
193   }
194 
195   int allocate_oop_index(jobject h) {
196     return _oops.allocate_index(h);
197   }
198   virtual int find_index(jobject h) {
199     return _object_lookup != NULL ? _object_lookup-&gt;find_index(h, this) : _oops.find_index(h);
200   }
201   jobject oop_at(int index) {
202     return _oops.at(index);
203   }
204   int oop_size() {
205     return _oops.size();
206   }
207   int oop_count() {
208     return _oops.count();
209   }
<span class="line-modified">210   bool is_real(jobject h) {</span>
<span class="line-removed">211     return _oops.is_real(h);</span>
<span class="line-removed">212   }</span>
213 
214   int allocate_metadata_index(Metadata* oop) {
215     return _metadata.allocate_index(oop);
216   }
217   virtual int find_index(Metadata* h) {
218     return _metadata.find_index(h);
219   }
220   Metadata* metadata_at(int index) {
221     return _metadata.at(index);
222   }
223   int metadata_size() {
224     return _metadata.size();
225   }
226   int metadata_count() {
227     return _metadata.count();
228   }
<span class="line-modified">229   bool is_real(Metadata* h) {</span>
<span class="line-removed">230     return _metadata.is_real(h);</span>
<span class="line-removed">231   }</span>
232 
233   bool is_unused() {
234     return _oops.is_unused() &amp;&amp; _metadata.is_unused();
235   }
236 
237   void freeze() {
238     _oops.size();
239     _metadata.size();
240   }
241 
242   void copy_values_to(nmethod* nm) {
243     if (!_oops.is_unused()) {
244       _oops.copy_values_to(nm);
245     }
246     if (!_metadata.is_unused()) {
247       _metadata.copy_values_to(nm);
248     }
249   }
250 
251 #ifdef ASSERT
</pre>
</td>
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CODE_OOPRECORDER_HPP
 26 #define SHARE_CODE_OOPRECORDER_HPP
 27 

 28 #include &quot;runtime/handles.hpp&quot;
 29 #include &quot;utilities/growableArray.hpp&quot;
 30 
 31 // Recording and retrieval of either oop relocations or metadata in compiled code.
 32 
 33 class CodeBlob;
 34 
 35 template &lt;class T&gt; class ValueRecorder : public StackObj {
 36  public:
 37   // A two-way mapping from positive indexes to oop handles.
 38   // The zero index is reserved for a constant (sharable) null.
 39   // Indexes may not be negative.
 40 
 41   // Use the given arena to manage storage, if not NULL.
 42   // By default, uses the current ResourceArea.
 43   ValueRecorder(Arena* arena = NULL);
 44 
 45   // Generate a new index on which nmethod::oop_addr_at will work.
 46   // allocate_index and find_index never return the same index,
 47   // and allocate_index never returns the same index twice.
</pre>
<hr />
<pre>
 59     if (index &lt; 0) {  // previously unallocated
 60       index = add_handle(h, true);
 61     }
 62     return index;
 63   }
 64 
 65   // returns the size of the generated oop/metadata table, for sizing the
 66   // CodeBlob. Must be called after all oops are allocated!
 67   int size();
 68 
 69   // Retrieve the value at a given index.
 70   T at(int index);
 71 
 72   int count() {
 73     if (_handles == NULL) return 0;
 74     // there is always a NULL virtually present as first object
 75     return _handles-&gt;length() + first_index;
 76   }
 77 
 78   // Helper function; returns false for NULL or Universe::non_oop_word().
<span class="line-modified"> 79   inline bool is_real(T h);</span>


 80 
 81   // copy the generated table to nmethod
 82   void copy_values_to(nmethod* nm);
 83 
 84   bool is_unused() { return _handles == NULL &amp;&amp; !_complete; }
 85 #ifdef ASSERT
 86   bool is_complete() { return _complete; }
 87 #endif
 88 
 89  private:
 90   // variant of find_index which does not allocate if not found (yields -1)
 91   int maybe_find_index(T h);
 92 
 93   // leaky hash table of handle =&gt; index, to help detect duplicate insertion
 94   template &lt;class X&gt; class IndexCache : public ResourceObj {
 95     // This class is only used by the ValueRecorder class.
 96     friend class ValueRecorder;
 97     enum {
 98       _log_cache_size = 9,
 99       _cache_size = (1&lt;&lt;_log_cache_size),
</pre>
<hr />
<pre>
187     } else {
188       _object_lookup = NULL;
189     }
190   }
191 
192   int allocate_oop_index(jobject h) {
193     return _oops.allocate_index(h);
194   }
195   virtual int find_index(jobject h) {
196     return _object_lookup != NULL ? _object_lookup-&gt;find_index(h, this) : _oops.find_index(h);
197   }
198   jobject oop_at(int index) {
199     return _oops.at(index);
200   }
201   int oop_size() {
202     return _oops.size();
203   }
204   int oop_count() {
205     return _oops.count();
206   }
<span class="line-modified">207   inline bool is_real(jobject h);</span>


208 
209   int allocate_metadata_index(Metadata* oop) {
210     return _metadata.allocate_index(oop);
211   }
212   virtual int find_index(Metadata* h) {
213     return _metadata.find_index(h);
214   }
215   Metadata* metadata_at(int index) {
216     return _metadata.at(index);
217   }
218   int metadata_size() {
219     return _metadata.size();
220   }
221   int metadata_count() {
222     return _metadata.count();
223   }
<span class="line-modified">224   inline bool is_real(Metadata* h);</span>


225 
226   bool is_unused() {
227     return _oops.is_unused() &amp;&amp; _metadata.is_unused();
228   }
229 
230   void freeze() {
231     _oops.size();
232     _metadata.size();
233   }
234 
235   void copy_values_to(nmethod* nm) {
236     if (!_oops.is_unused()) {
237       _oops.copy_values_to(nm);
238     }
239     if (!_metadata.is_unused()) {
240       _metadata.copy_values_to(nm);
241     }
242   }
243 
244 #ifdef ASSERT
</pre>
</td>
</tr>
</table>
<center><a href="oopRecorder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="pcDesc.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
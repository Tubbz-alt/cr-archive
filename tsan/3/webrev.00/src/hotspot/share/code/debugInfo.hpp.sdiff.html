<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/code/debugInfo.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="debugInfo.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="dependencies.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/debugInfo.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 32 #include &quot;runtime/stackValue.hpp&quot;
 33 #include &quot;runtime/thread.hpp&quot;
 34 #include &quot;utilities/growableArray.hpp&quot;
 35 
 36 // Classes used for serializing debugging information.
 37 // These abstractions are introducted to provide symmetric
 38 // read and write operations.
 39 
 40 // ScopeValue        describes the value of a variable/expression in a scope
 41 // - LocationValue   describes a value in a given location (in frame or register)
 42 // - ConstantValue   describes a constant
 43 
 44 class ConstantOopReadValue;
 45 class ObjectValue;
 46 
 47 class ScopeValue: public ResourceObj {
 48  public:
 49   // Testers
 50   virtual bool is_location() const { return false; }
 51   virtual bool is_object() const { return false; }

 52   virtual bool is_constant_int() const { return false; }
 53   virtual bool is_constant_double() const { return false; }
 54   virtual bool is_constant_long() const { return false; }
 55   virtual bool is_constant_oop() const { return false; }
 56   virtual bool equals(ScopeValue* other) const { return false; }
 57 
 58   ConstantOopReadValue* as_ConstantOopReadValue() {
 59     assert(is_constant_oop(), &quot;must be&quot;);
 60     return (ConstantOopReadValue*) this;
 61   }
 62 
 63   ObjectValue* as_ObjectValue() {
 64     assert(is_object(), &quot;must be&quot;);
 65     return (ObjectValue*)this;
 66   }
 67 
 68   // Serialization of debugging information
 69   virtual void write_on(DebugInfoWriteStream* stream) = 0;
 70   static ScopeValue* read_from(DebugInfoReadStream* stream);
 71 };
</pre>
<hr />
<pre>
 77 class LocationValue: public ScopeValue {
 78  private:
 79   Location  _location;
 80  public:
 81   LocationValue(Location location)           { _location = location; }
 82   bool      is_location() const              { return true; }
 83   Location  location() const                 { return _location; }
 84 
 85   // Serialization of debugging information
 86   LocationValue(DebugInfoReadStream* stream);
 87   void write_on(DebugInfoWriteStream* stream);
 88 
 89   // Printing
 90   void print_on(outputStream* st) const;
 91 };
 92 
 93 
 94 // An ObjectValue describes an object eliminated by escape analysis.
 95 
 96 class ObjectValue: public ScopeValue {
<span class="line-modified"> 97  private:</span>
 98   int                        _id;
 99   ScopeValue*                _klass;
100   GrowableArray&lt;ScopeValue*&gt; _field_values;
101   Handle                     _value;
102   bool                       _visited;
<span class="line-removed">103 </span>
104  public:
105   ObjectValue(int id, ScopeValue* klass)
106      : _id(id)
107      , _klass(klass)
108      , _field_values()
109      , _value()
110      , _visited(false) {
111     assert(klass-&gt;is_constant_oop(), &quot;should be constant java mirror oop&quot;);
112   }
113 
114   ObjectValue(int id)
115      : _id(id)
116      , _klass(NULL)
117      , _field_values()
118      , _value()
119      , _visited(false) {}
120 
121   // Accessors
122   bool                        is_object() const         { return true; }
123   int                         id() const                { return _id; }
124   ScopeValue*                 klass() const             { return _klass; }
125   GrowableArray&lt;ScopeValue*&gt;* field_values()            { return &amp;_field_values; }
126   ScopeValue*                 field_at(int i) const     { return _field_values.at(i); }
127   int                         field_size()              { return _field_values.length(); }
128   Handle                      value() const             { return _value; }
129   bool                        is_visited() const        { return _visited; }
130 
131   void                        set_value(oop value);
132   void                        set_visited(bool visited) { _visited = false; }
133 
134   // Serialization of debugging information
135   void read_object(DebugInfoReadStream* stream);
136   void write_on(DebugInfoWriteStream* stream);
137 
138   // Printing
139   void print_on(outputStream* st) const;
140   void print_fields_on(outputStream* st) const;
141 };
142 










143 
144 // A ConstantIntValue describes a constant int; i.e., the corresponding logical entity
145 // is either a source constant or its computation has been constant-folded.
146 
147 class ConstantIntValue: public ScopeValue {
148  private:
149   jint _value;
150  public:
151   ConstantIntValue(jint value)         { _value = value; }
152   jint value() const                   { return _value;  }
153   bool is_constant_int() const         { return true;    }
154   bool equals(ScopeValue* other) const { return false;   }
155 
156   // Serialization of debugging information
157   ConstantIntValue(DebugInfoReadStream* stream);
158   void write_on(DebugInfoWriteStream* stream);
159 
160   // Printing
161   void print_on(outputStream* st) const;
162 };
</pre>
<hr />
<pre>
263 class DebugInfoReadStream : public CompressedReadStream {
264  private:
265   const CompiledMethod* _code;
266   const CompiledMethod* code() const { return _code; }
267   GrowableArray&lt;ScopeValue*&gt;* _obj_pool;
268  public:
269   DebugInfoReadStream(const CompiledMethod* code, int offset, GrowableArray&lt;ScopeValue*&gt;* obj_pool = NULL) :
270     CompressedReadStream(code-&gt;scopes_data_begin(), offset) {
271     _code = code;
272     _obj_pool = obj_pool;
273 
274   } ;
275 
276   oop read_oop();
277   Method* read_method() {
278     Method* o = (Method*)(code()-&gt;metadata_at(read_int()));
279     // is_metadata() is a faster check than is_metaspace_object()
280     assert(o == NULL || o-&gt;is_metadata(), &quot;meta data only&quot;);
281     return o;
282   }
<span class="line-modified">283   ScopeValue* read_object_value();</span>
284   ScopeValue* get_cached_object();
285   // BCI encoding is mostly unsigned, but -1 is a distinguished value
286   int read_bci() { return read_int() + InvocationEntryBci; }
287 };
288 
289 // DebugInfoWriteStream specializes CompressedWriteStream for
290 // writing debugging information. Used by ScopeDescRecorder.
291 
292 class DebugInfoWriteStream : public CompressedWriteStream {
293  private:
294   DebugInformationRecorder* _recorder;
295   DebugInformationRecorder* recorder() const { return _recorder; }
296  public:
297   DebugInfoWriteStream(DebugInformationRecorder* recorder, int initial_size);
298   void write_handle(jobject h);
299   void write_bci(int bci) { write_int(bci - InvocationEntryBci); }
300 
301   void write_metadata(Metadata* m);
302 };
303 
</pre>
</td>
<td>
<hr />
<pre>
 32 #include &quot;runtime/stackValue.hpp&quot;
 33 #include &quot;runtime/thread.hpp&quot;
 34 #include &quot;utilities/growableArray.hpp&quot;
 35 
 36 // Classes used for serializing debugging information.
 37 // These abstractions are introducted to provide symmetric
 38 // read and write operations.
 39 
 40 // ScopeValue        describes the value of a variable/expression in a scope
 41 // - LocationValue   describes a value in a given location (in frame or register)
 42 // - ConstantValue   describes a constant
 43 
 44 class ConstantOopReadValue;
 45 class ObjectValue;
 46 
 47 class ScopeValue: public ResourceObj {
 48  public:
 49   // Testers
 50   virtual bool is_location() const { return false; }
 51   virtual bool is_object() const { return false; }
<span class="line-added"> 52   virtual bool is_auto_box() const { return false; }</span>
 53   virtual bool is_constant_int() const { return false; }
 54   virtual bool is_constant_double() const { return false; }
 55   virtual bool is_constant_long() const { return false; }
 56   virtual bool is_constant_oop() const { return false; }
 57   virtual bool equals(ScopeValue* other) const { return false; }
 58 
 59   ConstantOopReadValue* as_ConstantOopReadValue() {
 60     assert(is_constant_oop(), &quot;must be&quot;);
 61     return (ConstantOopReadValue*) this;
 62   }
 63 
 64   ObjectValue* as_ObjectValue() {
 65     assert(is_object(), &quot;must be&quot;);
 66     return (ObjectValue*)this;
 67   }
 68 
 69   // Serialization of debugging information
 70   virtual void write_on(DebugInfoWriteStream* stream) = 0;
 71   static ScopeValue* read_from(DebugInfoReadStream* stream);
 72 };
</pre>
<hr />
<pre>
 78 class LocationValue: public ScopeValue {
 79  private:
 80   Location  _location;
 81  public:
 82   LocationValue(Location location)           { _location = location; }
 83   bool      is_location() const              { return true; }
 84   Location  location() const                 { return _location; }
 85 
 86   // Serialization of debugging information
 87   LocationValue(DebugInfoReadStream* stream);
 88   void write_on(DebugInfoWriteStream* stream);
 89 
 90   // Printing
 91   void print_on(outputStream* st) const;
 92 };
 93 
 94 
 95 // An ObjectValue describes an object eliminated by escape analysis.
 96 
 97 class ObjectValue: public ScopeValue {
<span class="line-modified"> 98  protected:</span>
 99   int                        _id;
100   ScopeValue*                _klass;
101   GrowableArray&lt;ScopeValue*&gt; _field_values;
102   Handle                     _value;
103   bool                       _visited;

104  public:
105   ObjectValue(int id, ScopeValue* klass)
106      : _id(id)
107      , _klass(klass)
108      , _field_values()
109      , _value()
110      , _visited(false) {
111     assert(klass-&gt;is_constant_oop(), &quot;should be constant java mirror oop&quot;);
112   }
113 
114   ObjectValue(int id)
115      : _id(id)
116      , _klass(NULL)
117      , _field_values()
118      , _value()
119      , _visited(false) {}
120 
121   // Accessors
122   bool                        is_object() const         { return true; }
123   int                         id() const                { return _id; }
124   ScopeValue*                 klass() const             { return _klass; }
125   GrowableArray&lt;ScopeValue*&gt;* field_values()            { return &amp;_field_values; }
126   ScopeValue*                 field_at(int i) const     { return _field_values.at(i); }
127   int                         field_size()              { return _field_values.length(); }
128   Handle                      value() const             { return _value; }
129   bool                        is_visited() const        { return _visited; }
130 
131   void                        set_value(oop value);
132   void                        set_visited(bool visited) { _visited = false; }
133 
134   // Serialization of debugging information
135   void read_object(DebugInfoReadStream* stream);
136   void write_on(DebugInfoWriteStream* stream);
137 
138   // Printing
139   void print_on(outputStream* st) const;
140   void print_fields_on(outputStream* st) const;
141 };
142 
<span class="line-added">143 class AutoBoxObjectValue : public ObjectValue {</span>
<span class="line-added">144   bool                       _cached;</span>
<span class="line-added">145 public:</span>
<span class="line-added">146   bool                       is_auto_box() const        { return true; }</span>
<span class="line-added">147   bool                       is_cached() const          { return _cached; }</span>
<span class="line-added">148   void                       set_cached(bool cached)    { _cached = cached; }</span>
<span class="line-added">149   AutoBoxObjectValue(int id, ScopeValue* klass) : ObjectValue(id, klass), _cached(false) { }</span>
<span class="line-added">150   AutoBoxObjectValue(int id) : ObjectValue(id), _cached(false) { }</span>
<span class="line-added">151 };</span>
<span class="line-added">152 </span>
153 
154 // A ConstantIntValue describes a constant int; i.e., the corresponding logical entity
155 // is either a source constant or its computation has been constant-folded.
156 
157 class ConstantIntValue: public ScopeValue {
158  private:
159   jint _value;
160  public:
161   ConstantIntValue(jint value)         { _value = value; }
162   jint value() const                   { return _value;  }
163   bool is_constant_int() const         { return true;    }
164   bool equals(ScopeValue* other) const { return false;   }
165 
166   // Serialization of debugging information
167   ConstantIntValue(DebugInfoReadStream* stream);
168   void write_on(DebugInfoWriteStream* stream);
169 
170   // Printing
171   void print_on(outputStream* st) const;
172 };
</pre>
<hr />
<pre>
273 class DebugInfoReadStream : public CompressedReadStream {
274  private:
275   const CompiledMethod* _code;
276   const CompiledMethod* code() const { return _code; }
277   GrowableArray&lt;ScopeValue*&gt;* _obj_pool;
278  public:
279   DebugInfoReadStream(const CompiledMethod* code, int offset, GrowableArray&lt;ScopeValue*&gt;* obj_pool = NULL) :
280     CompressedReadStream(code-&gt;scopes_data_begin(), offset) {
281     _code = code;
282     _obj_pool = obj_pool;
283 
284   } ;
285 
286   oop read_oop();
287   Method* read_method() {
288     Method* o = (Method*)(code()-&gt;metadata_at(read_int()));
289     // is_metadata() is a faster check than is_metaspace_object()
290     assert(o == NULL || o-&gt;is_metadata(), &quot;meta data only&quot;);
291     return o;
292   }
<span class="line-modified">293   ScopeValue* read_object_value(bool is_auto_box);</span>
294   ScopeValue* get_cached_object();
295   // BCI encoding is mostly unsigned, but -1 is a distinguished value
296   int read_bci() { return read_int() + InvocationEntryBci; }
297 };
298 
299 // DebugInfoWriteStream specializes CompressedWriteStream for
300 // writing debugging information. Used by ScopeDescRecorder.
301 
302 class DebugInfoWriteStream : public CompressedWriteStream {
303  private:
304   DebugInformationRecorder* _recorder;
305   DebugInformationRecorder* recorder() const { return _recorder; }
306  public:
307   DebugInfoWriteStream(DebugInformationRecorder* recorder, int initial_size);
308   void write_handle(jobject h);
309   void write_bci(int bci) { write_int(bci - InvocationEntryBci); }
310 
311   void write_metadata(Metadata* m);
312 };
313 
</pre>
</td>
</tr>
</table>
<center><a href="debugInfo.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="dependencies.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/code/compiledMethod.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compiledMethod.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compiledMethod.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/compiledMethod.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 36,10 ***</span>
<span class="line-new-header">--- 36,11 ---</span>
  class xmlStream;
  class CompiledStaticCall;
  class NativeCallWrapper;
  class ScopeDesc;
  class CompiledIC;
<span class="line-added">+ class MetadataClosure;</span>
  
  // This class is used internally by nmethods, to cache
  // exception/pc/handler information.
  
  class ExceptionCache : public CHeapObj&lt;mtCode&gt; {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 205,13 ***</span>
                               // allowed to advance state
           in_use        = 0,  // executable nmethod
           not_used      = 1,  // not entrant, but revivable
           not_entrant   = 2,  // marked for deoptimization but activations may still exist,
                               // will be transformed to zombie when all activations are gone
<span class="line-modified">!          zombie        = 3,  // no activations exist, nmethod is ready for purge</span>
<span class="line-modified">!          unloaded      = 4   // there should be no activations, should not be called,</span>
<span class="line-modified">!                              // will be transformed to zombie immediately</span>
    };
  
    virtual bool  is_in_use() const = 0;
    virtual int   comp_level() const = 0;
    virtual int   compile_id() const = 0;
<span class="line-new-header">--- 206,13 ---</span>
                               // allowed to advance state
           in_use        = 0,  // executable nmethod
           not_used      = 1,  // not entrant, but revivable
           not_entrant   = 2,  // marked for deoptimization but activations may still exist,
                               // will be transformed to zombie when all activations are gone
<span class="line-modified">!          unloaded      = 3,  // there should be no activations, should not be called, will be</span>
<span class="line-modified">!                              // transformed to zombie by the sweeper, when not &quot;locked in vm&quot;.</span>
<span class="line-modified">!          zombie        = 4   // no activations exist, nmethod is ready for purge</span>
    };
  
    virtual bool  is_in_use() const = 0;
    virtual int   comp_level() const = 0;
    virtual int   compile_id() const = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 241,14 ***</span>
    ScopeDesc* scope_desc_near(address pc);
  
    bool is_at_poll_return(address pc);
    bool is_at_poll_or_poll_return(address pc);
  
<span class="line-modified">!   bool  is_marked_for_deoptimization() const      { return _mark_for_deoptimization_status != not_marked; }</span>
<span class="line-modified">!   void  mark_for_deoptimization(bool inc_recompile_counts = true) {</span>
<span class="line-modified">!     _mark_for_deoptimization_status = (inc_recompile_counts ? deoptimize : deoptimize_noupdate);</span>
<span class="line-removed">-   }</span>
    bool update_recompile_counts() const {
      // Update recompile counts when either the update is explicitly requested (deoptimize)
      // or the nmethod is not marked for deoptimization at all (not_marked).
      // The latter happens during uncommon traps when deoptimized nmethod is made not entrant.
      return _mark_for_deoptimization_status != deoptimize_noupdate;
<span class="line-new-header">--- 242,13 ---</span>
    ScopeDesc* scope_desc_near(address pc);
  
    bool is_at_poll_return(address pc);
    bool is_at_poll_or_poll_return(address pc);
  
<span class="line-modified">!   bool  is_marked_for_deoptimization() const { return _mark_for_deoptimization_status != not_marked; }</span>
<span class="line-modified">!   void  mark_for_deoptimization(bool inc_recompile_counts = true);</span>
<span class="line-modified">! </span>
    bool update_recompile_counts() const {
      // Update recompile counts when either the update is explicitly requested (deoptimize)
      // or the nmethod is not marked for deoptimization at all (not_marked).
      // The latter happens during uncommon traps when deoptimized nmethod is made not entrant.
      return _mark_for_deoptimization_status != deoptimize_noupdate;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 346,30 ***</span>
    }
  
    void preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, OopClosure* f);
  
    // implicit exceptions support
<span class="line-modified">!   virtual address continuation_for_implicit_exception(address pc) { return NULL; }</span>
  
    static address get_deopt_original_pc(const frame* fr);
  
    // Inline cache support for class unloading and nmethod unloading
   private:
    bool cleanup_inline_caches_impl(bool unloading_occurred, bool clean_all);
  
   public:
    // Serial version used by sweeper and whitebox test
    void cleanup_inline_caches(bool clean_all);
  
    virtual void clear_inline_caches();
    void clear_ic_callsites();
  
    // Verify and count cached icholder relocations.
    int  verify_icholder_relocations();
    void verify_oop_relocations();
  
<span class="line-modified">!   virtual bool is_evol_dependent() = 0;</span>
    // Fast breakpoint support. Tells if this compiled method is
    // dependent on the given method. Returns true if this nmethod
    // corresponds to the given method as well.
    virtual bool is_dependent_on_method(Method* dependee) = 0;
  
<span class="line-new-header">--- 346,37 ---</span>
    }
  
    void preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, OopClosure* f);
  
    // implicit exceptions support
<span class="line-modified">!   address continuation_for_implicit_div0_exception(address pc) { return continuation_for_implicit_exception(pc, true); }</span>
<span class="line-added">+   address continuation_for_implicit_null_exception(address pc) { return continuation_for_implicit_exception(pc, false); }</span>
  
    static address get_deopt_original_pc(const frame* fr);
  
    // Inline cache support for class unloading and nmethod unloading
   private:
    bool cleanup_inline_caches_impl(bool unloading_occurred, bool clean_all);
  
<span class="line-added">+   address continuation_for_implicit_exception(address pc, bool for_div0_check);</span>
<span class="line-added">+ </span>
   public:
    // Serial version used by sweeper and whitebox test
    void cleanup_inline_caches(bool clean_all);
  
    virtual void clear_inline_caches();
    void clear_ic_callsites();
  
<span class="line-added">+   // Execute nmethod barrier code, as if entering through nmethod call.</span>
<span class="line-added">+   void run_nmethod_entry_barrier();</span>
<span class="line-added">+ </span>
    // Verify and count cached icholder relocations.
    int  verify_icholder_relocations();
    void verify_oop_relocations();
  
<span class="line-modified">!   bool has_evol_metadata();</span>
<span class="line-added">+ </span>
    // Fast breakpoint support. Tells if this compiled method is
    // dependent on the given method. Returns true if this nmethod
    // corresponds to the given method as well.
    virtual bool is_dependent_on_method(Method* dependee) = 0;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 382,21 ***</span>
    virtual CompiledStaticCall* compiledStaticCall_before(address addr) const = 0;
  
    Method* attached_method(address call_pc);
    Method* attached_method_before_pc(address pc);
  
<span class="line-modified">!   virtual void metadata_do(void f(Metadata*)) = 0;</span>
  
    // GC support
   protected:
    address oops_reloc_begin() const;
  
   private:
    bool static clean_ic_if_metadata_is_dead(CompiledIC *ic);
  
<span class="line-removed">-   void clean_ic_stubs();</span>
<span class="line-removed">- </span>
   public:
    // GC unloading support
    // Cleans unloaded klasses and unloaded nmethods in inline caches
  
    virtual bool is_unloading() = 0;
<span class="line-new-header">--- 389,19 ---</span>
    virtual CompiledStaticCall* compiledStaticCall_before(address addr) const = 0;
  
    Method* attached_method(address call_pc);
    Method* attached_method_before_pc(address pc);
  
<span class="line-modified">!   virtual void metadata_do(MetadataClosure* f) = 0;</span>
  
    // GC support
   protected:
    address oops_reloc_begin() const;
  
   private:
    bool static clean_ic_if_metadata_is_dead(CompiledIC *ic);
  
   public:
    // GC unloading support
    // Cleans unloaded klasses and unloaded nmethods in inline caches
  
    virtual bool is_unloading() = 0;
</pre>
<center><a href="compiledMethod.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compiledMethod.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
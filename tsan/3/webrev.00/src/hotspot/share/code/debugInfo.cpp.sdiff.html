<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/code/debugInfo.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compiledMethod.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="debugInfo.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/debugInfo.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/debugInfo.hpp&quot;
 27 #include &quot;code/debugInfoRec.hpp&quot;
 28 #include &quot;code/nmethod.hpp&quot;

 29 #include &quot;oops/oop.inline.hpp&quot;
 30 #include &quot;runtime/handles.inline.hpp&quot;
 31 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 32 #include &quot;runtime/jniHandles.inline.hpp&quot;
 33 #include &quot;runtime/thread.hpp&quot;
 34 
 35 // Constructors
 36 
 37 DebugInfoWriteStream::DebugInfoWriteStream(DebugInformationRecorder* recorder, int initial_size)
 38 : CompressedWriteStream(initial_size) {
 39   _recorder = recorder;
 40 }
 41 
 42 // Serializing oops
 43 
 44 void DebugInfoWriteStream::write_handle(jobject h) {
 45   write_int(recorder()-&gt;oop_recorder()-&gt;find_index(h));
 46 }
 47 
 48 void DebugInfoWriteStream::write_metadata(Metadata* h) {
 49   write_int(recorder()-&gt;oop_recorder()-&gt;find_index(h));
 50 }
 51 
 52 oop DebugInfoReadStream::read_oop() {
<span class="line-modified"> 53   oop o = code()-&gt;oop_at(read_int());</span>








 54   assert(oopDesc::is_oop_or_null(o), &quot;oop only&quot;);
 55   return o;
 56 }
 57 
<span class="line-modified"> 58 ScopeValue* DebugInfoReadStream::read_object_value() {</span>
 59   int id = read_int();
 60 #ifdef ASSERT
 61   assert(_obj_pool != NULL, &quot;object pool does not exist&quot;);
 62   for (int i = _obj_pool-&gt;length() - 1; i &gt;= 0; i--) {
 63     assert(_obj_pool-&gt;at(i)-&gt;as_ObjectValue()-&gt;id() != id, &quot;should not be read twice&quot;);
 64   }
 65 #endif
<span class="line-modified"> 66   ObjectValue* result = new ObjectValue(id);</span>
 67   // Cache the object since an object field could reference it.
 68   _obj_pool-&gt;push(result);
 69   result-&gt;read_object(this);
 70   return result;
 71 }
 72 
 73 ScopeValue* DebugInfoReadStream::get_cached_object() {
 74   int id = read_int();
 75   assert(_obj_pool != NULL, &quot;object pool does not exist&quot;);
 76   for (int i = _obj_pool-&gt;length() - 1; i &gt;= 0; i--) {
 77     ObjectValue* ov = _obj_pool-&gt;at(i)-&gt;as_ObjectValue();
 78     if (ov-&gt;id() == id) {
 79       return ov;
 80     }
 81   }
 82   ShouldNotReachHere();
 83   return NULL;
 84 }
 85 
 86 // Serializing scope values
 87 
 88 enum { LOCATION_CODE = 0, CONSTANT_INT_CODE = 1,  CONSTANT_OOP_CODE = 2,
 89                           CONSTANT_LONG_CODE = 3, CONSTANT_DOUBLE_CODE = 4,
<span class="line-modified"> 90                           OBJECT_CODE = 5,        OBJECT_ID_CODE = 6 };</span>

 91 
 92 ScopeValue* ScopeValue::read_from(DebugInfoReadStream* stream) {
 93   ScopeValue* result = NULL;
 94   switch(stream-&gt;read_int()) {
<span class="line-modified"> 95    case LOCATION_CODE:        result = new LocationValue(stream);        break;</span>
<span class="line-modified"> 96    case CONSTANT_INT_CODE:    result = new ConstantIntValue(stream);     break;</span>
<span class="line-modified"> 97    case CONSTANT_OOP_CODE:    result = new ConstantOopReadValue(stream); break;</span>
<span class="line-modified"> 98    case CONSTANT_LONG_CODE:   result = new ConstantLongValue(stream);    break;</span>
<span class="line-modified"> 99    case CONSTANT_DOUBLE_CODE: result = new ConstantDoubleValue(stream);  break;</span>
<span class="line-modified">100    case OBJECT_CODE:          result = stream-&gt;read_object_value();      break;</span>
<span class="line-modified">101    case OBJECT_ID_CODE:       result = stream-&gt;get_cached_object();      break;</span>

102    default: ShouldNotReachHere();
103   }
104   return result;
105 }
106 
107 // LocationValue
108 
109 LocationValue::LocationValue(DebugInfoReadStream* stream) {
110   _location = Location(stream);
111 }
112 
113 void LocationValue::write_on(DebugInfoWriteStream* stream) {
114   stream-&gt;write_int(LOCATION_CODE);
115   location().write_on(stream);
116 }
117 
118 void LocationValue::print_on(outputStream* st) const {
119   location().print_on(st);
120 }
121 
</pre>
<hr />
<pre>
124 void ObjectValue::set_value(oop value) {
125   _value = Handle(Thread::current(), value);
126 }
127 
128 void ObjectValue::read_object(DebugInfoReadStream* stream) {
129   _klass = read_from(stream);
130   assert(_klass-&gt;is_constant_oop(), &quot;should be constant java mirror oop&quot;);
131   int length = stream-&gt;read_int();
132   for (int i = 0; i &lt; length; i++) {
133     ScopeValue* val = read_from(stream);
134     _field_values.append(val);
135   }
136 }
137 
138 void ObjectValue::write_on(DebugInfoWriteStream* stream) {
139   if (_visited) {
140     stream-&gt;write_int(OBJECT_ID_CODE);
141     stream-&gt;write_int(_id);
142   } else {
143     _visited = true;
<span class="line-modified">144     stream-&gt;write_int(OBJECT_CODE);</span>
145     stream-&gt;write_int(_id);
146     _klass-&gt;write_on(stream);
147     int length = _field_values.length();
148     stream-&gt;write_int(length);
149     for (int i = 0; i &lt; length; i++) {
150       _field_values.at(i)-&gt;write_on(stream);
151     }
152   }
153 }
154 
155 void ObjectValue::print_on(outputStream* st) const {
<span class="line-modified">156   st-&gt;print(&quot;obj[%d]&quot;, _id);</span>
157 }
158 
159 void ObjectValue::print_fields_on(outputStream* st) const {
160 #ifndef PRODUCT
161   if (_field_values.length() &gt; 0) {
162     _field_values.at(0)-&gt;print_on(st);
163   }
164   for (int i = 1; i &lt; _field_values.length(); i++) {
165     st-&gt;print(&quot;, &quot;);
166     _field_values.at(i)-&gt;print_on(st);
167   }
168 #endif
169 }
170 
171 // ConstantIntValue
172 
173 ConstantIntValue::ConstantIntValue(DebugInfoReadStream* stream) {
174   _value = stream-&gt;read_signed_int();
175 }
176 
</pre>
<hr />
<pre>
205 }
206 
207 void ConstantDoubleValue::write_on(DebugInfoWriteStream* stream) {
208   stream-&gt;write_int(CONSTANT_DOUBLE_CODE);
209   stream-&gt;write_double(value());
210 }
211 
212 void ConstantDoubleValue::print_on(outputStream* st) const {
213   st-&gt;print(&quot;%f&quot;, value());
214 }
215 
216 // ConstantOopWriteValue
217 
218 void ConstantOopWriteValue::write_on(DebugInfoWriteStream* stream) {
219 #ifdef ASSERT
220   {
221     // cannot use ThreadInVMfromNative here since in case of JVMCI compiler,
222     // thread is already in VM state.
223     ThreadInVMfromUnknown tiv;
224     assert(JNIHandles::resolve(value()) == NULL ||
<span class="line-modified">225            Universe::heap()-&gt;is_in_reserved(JNIHandles::resolve(value())),</span>
226            &quot;Should be in heap&quot;);
227  }
228 #endif
229   stream-&gt;write_int(CONSTANT_OOP_CODE);
230   stream-&gt;write_handle(value());
231 }
232 
233 void ConstantOopWriteValue::print_on(outputStream* st) const {
234   // using ThreadInVMfromUnknown here since in case of JVMCI compiler,
235   // thread is already in VM state.
236   ThreadInVMfromUnknown tiv;
237   JNIHandles::resolve(value())-&gt;print_value_on(st);
238 }
239 
240 
241 // ConstantOopReadValue
242 
243 ConstantOopReadValue::ConstantOopReadValue(DebugInfoReadStream* stream) {
244   _value = Handle(Thread::current(), stream-&gt;read_oop());
245   assert(_value() == NULL ||
<span class="line-modified">246          Universe::heap()-&gt;is_in_reserved(_value()), &quot;Should be in heap&quot;);</span>
247 }
248 
249 void ConstantOopReadValue::write_on(DebugInfoWriteStream* stream) {
250   ShouldNotReachHere();
251 }
252 
253 void ConstantOopReadValue::print_on(outputStream* st) const {
254   if (value()() != NULL) {
255     value()()-&gt;print_value_on(st);
256   } else {
257     st-&gt;print_cr(&quot;NULL&quot;);
258   }
259 }
260 
261 
262 // MonitorValue
263 
264 MonitorValue::MonitorValue(ScopeValue* owner, Location basic_lock, bool eliminated) {
265   _owner       = owner;
266   _basic_lock  = basic_lock;
</pre>
</td>
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/debugInfo.hpp&quot;
 27 #include &quot;code/debugInfoRec.hpp&quot;
 28 #include &quot;code/nmethod.hpp&quot;
<span class="line-added"> 29 #include &quot;memory/universe.hpp&quot;</span>
 30 #include &quot;oops/oop.inline.hpp&quot;
 31 #include &quot;runtime/handles.inline.hpp&quot;
 32 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 33 #include &quot;runtime/jniHandles.inline.hpp&quot;
 34 #include &quot;runtime/thread.hpp&quot;
 35 
 36 // Constructors
 37 
 38 DebugInfoWriteStream::DebugInfoWriteStream(DebugInformationRecorder* recorder, int initial_size)
 39 : CompressedWriteStream(initial_size) {
 40   _recorder = recorder;
 41 }
 42 
 43 // Serializing oops
 44 
 45 void DebugInfoWriteStream::write_handle(jobject h) {
 46   write_int(recorder()-&gt;oop_recorder()-&gt;find_index(h));
 47 }
 48 
 49 void DebugInfoWriteStream::write_metadata(Metadata* h) {
 50   write_int(recorder()-&gt;oop_recorder()-&gt;find_index(h));
 51 }
 52 
 53 oop DebugInfoReadStream::read_oop() {
<span class="line-modified"> 54   nmethod* nm = const_cast&lt;CompiledMethod*&gt;(code())-&gt;as_nmethod_or_null();</span>
<span class="line-added"> 55   oop o;</span>
<span class="line-added"> 56   if (nm != NULL) {</span>
<span class="line-added"> 57     // Despite these oops being found inside nmethods that are on-stack,</span>
<span class="line-added"> 58     // they are not kept alive by all GCs (e.g. G1 and Shenandoah).</span>
<span class="line-added"> 59     o = nm-&gt;oop_at_phantom(read_int());</span>
<span class="line-added"> 60   } else {</span>
<span class="line-added"> 61     o = code()-&gt;oop_at(read_int());</span>
<span class="line-added"> 62   }</span>
 63   assert(oopDesc::is_oop_or_null(o), &quot;oop only&quot;);
 64   return o;
 65 }
 66 
<span class="line-modified"> 67 ScopeValue* DebugInfoReadStream::read_object_value(bool is_auto_box) {</span>
 68   int id = read_int();
 69 #ifdef ASSERT
 70   assert(_obj_pool != NULL, &quot;object pool does not exist&quot;);
 71   for (int i = _obj_pool-&gt;length() - 1; i &gt;= 0; i--) {
 72     assert(_obj_pool-&gt;at(i)-&gt;as_ObjectValue()-&gt;id() != id, &quot;should not be read twice&quot;);
 73   }
 74 #endif
<span class="line-modified"> 75   ObjectValue* result = is_auto_box ? new AutoBoxObjectValue(id) : new ObjectValue(id);</span>
 76   // Cache the object since an object field could reference it.
 77   _obj_pool-&gt;push(result);
 78   result-&gt;read_object(this);
 79   return result;
 80 }
 81 
 82 ScopeValue* DebugInfoReadStream::get_cached_object() {
 83   int id = read_int();
 84   assert(_obj_pool != NULL, &quot;object pool does not exist&quot;);
 85   for (int i = _obj_pool-&gt;length() - 1; i &gt;= 0; i--) {
 86     ObjectValue* ov = _obj_pool-&gt;at(i)-&gt;as_ObjectValue();
 87     if (ov-&gt;id() == id) {
 88       return ov;
 89     }
 90   }
 91   ShouldNotReachHere();
 92   return NULL;
 93 }
 94 
 95 // Serializing scope values
 96 
 97 enum { LOCATION_CODE = 0, CONSTANT_INT_CODE = 1,  CONSTANT_OOP_CODE = 2,
 98                           CONSTANT_LONG_CODE = 3, CONSTANT_DOUBLE_CODE = 4,
<span class="line-modified"> 99                           OBJECT_CODE = 5,        OBJECT_ID_CODE = 6,</span>
<span class="line-added">100                           AUTO_BOX_OBJECT_CODE = 7 };</span>
101 
102 ScopeValue* ScopeValue::read_from(DebugInfoReadStream* stream) {
103   ScopeValue* result = NULL;
104   switch(stream-&gt;read_int()) {
<span class="line-modified">105    case LOCATION_CODE:        result = new LocationValue(stream);                        break;</span>
<span class="line-modified">106    case CONSTANT_INT_CODE:    result = new ConstantIntValue(stream);                     break;</span>
<span class="line-modified">107    case CONSTANT_OOP_CODE:    result = new ConstantOopReadValue(stream);                 break;</span>
<span class="line-modified">108    case CONSTANT_LONG_CODE:   result = new ConstantLongValue(stream);                    break;</span>
<span class="line-modified">109    case CONSTANT_DOUBLE_CODE: result = new ConstantDoubleValue(stream);                  break;</span>
<span class="line-modified">110    case OBJECT_CODE:          result = stream-&gt;read_object_value(false /*is_auto_box*/); break;</span>
<span class="line-modified">111    case AUTO_BOX_OBJECT_CODE: result = stream-&gt;read_object_value(true /*is_auto_box*/);  break;</span>
<span class="line-added">112    case OBJECT_ID_CODE:       result = stream-&gt;get_cached_object();                      break;</span>
113    default: ShouldNotReachHere();
114   }
115   return result;
116 }
117 
118 // LocationValue
119 
120 LocationValue::LocationValue(DebugInfoReadStream* stream) {
121   _location = Location(stream);
122 }
123 
124 void LocationValue::write_on(DebugInfoWriteStream* stream) {
125   stream-&gt;write_int(LOCATION_CODE);
126   location().write_on(stream);
127 }
128 
129 void LocationValue::print_on(outputStream* st) const {
130   location().print_on(st);
131 }
132 
</pre>
<hr />
<pre>
135 void ObjectValue::set_value(oop value) {
136   _value = Handle(Thread::current(), value);
137 }
138 
139 void ObjectValue::read_object(DebugInfoReadStream* stream) {
140   _klass = read_from(stream);
141   assert(_klass-&gt;is_constant_oop(), &quot;should be constant java mirror oop&quot;);
142   int length = stream-&gt;read_int();
143   for (int i = 0; i &lt; length; i++) {
144     ScopeValue* val = read_from(stream);
145     _field_values.append(val);
146   }
147 }
148 
149 void ObjectValue::write_on(DebugInfoWriteStream* stream) {
150   if (_visited) {
151     stream-&gt;write_int(OBJECT_ID_CODE);
152     stream-&gt;write_int(_id);
153   } else {
154     _visited = true;
<span class="line-modified">155     stream-&gt;write_int(is_auto_box() ? AUTO_BOX_OBJECT_CODE : OBJECT_CODE);</span>
156     stream-&gt;write_int(_id);
157     _klass-&gt;write_on(stream);
158     int length = _field_values.length();
159     stream-&gt;write_int(length);
160     for (int i = 0; i &lt; length; i++) {
161       _field_values.at(i)-&gt;write_on(stream);
162     }
163   }
164 }
165 
166 void ObjectValue::print_on(outputStream* st) const {
<span class="line-modified">167   st-&gt;print(&quot;%s[%d]&quot;, is_auto_box() ? &quot;box_obj&quot; : &quot;obj&quot;, _id);</span>
168 }
169 
170 void ObjectValue::print_fields_on(outputStream* st) const {
171 #ifndef PRODUCT
172   if (_field_values.length() &gt; 0) {
173     _field_values.at(0)-&gt;print_on(st);
174   }
175   for (int i = 1; i &lt; _field_values.length(); i++) {
176     st-&gt;print(&quot;, &quot;);
177     _field_values.at(i)-&gt;print_on(st);
178   }
179 #endif
180 }
181 
182 // ConstantIntValue
183 
184 ConstantIntValue::ConstantIntValue(DebugInfoReadStream* stream) {
185   _value = stream-&gt;read_signed_int();
186 }
187 
</pre>
<hr />
<pre>
216 }
217 
218 void ConstantDoubleValue::write_on(DebugInfoWriteStream* stream) {
219   stream-&gt;write_int(CONSTANT_DOUBLE_CODE);
220   stream-&gt;write_double(value());
221 }
222 
223 void ConstantDoubleValue::print_on(outputStream* st) const {
224   st-&gt;print(&quot;%f&quot;, value());
225 }
226 
227 // ConstantOopWriteValue
228 
229 void ConstantOopWriteValue::write_on(DebugInfoWriteStream* stream) {
230 #ifdef ASSERT
231   {
232     // cannot use ThreadInVMfromNative here since in case of JVMCI compiler,
233     // thread is already in VM state.
234     ThreadInVMfromUnknown tiv;
235     assert(JNIHandles::resolve(value()) == NULL ||
<span class="line-modified">236            Universe::heap()-&gt;is_in(JNIHandles::resolve(value())),</span>
237            &quot;Should be in heap&quot;);
238  }
239 #endif
240   stream-&gt;write_int(CONSTANT_OOP_CODE);
241   stream-&gt;write_handle(value());
242 }
243 
244 void ConstantOopWriteValue::print_on(outputStream* st) const {
245   // using ThreadInVMfromUnknown here since in case of JVMCI compiler,
246   // thread is already in VM state.
247   ThreadInVMfromUnknown tiv;
248   JNIHandles::resolve(value())-&gt;print_value_on(st);
249 }
250 
251 
252 // ConstantOopReadValue
253 
254 ConstantOopReadValue::ConstantOopReadValue(DebugInfoReadStream* stream) {
255   _value = Handle(Thread::current(), stream-&gt;read_oop());
256   assert(_value() == NULL ||
<span class="line-modified">257          Universe::heap()-&gt;is_in(_value()), &quot;Should be in heap&quot;);</span>
258 }
259 
260 void ConstantOopReadValue::write_on(DebugInfoWriteStream* stream) {
261   ShouldNotReachHere();
262 }
263 
264 void ConstantOopReadValue::print_on(outputStream* st) const {
265   if (value()() != NULL) {
266     value()()-&gt;print_value_on(st);
267   } else {
268     st-&gt;print_cr(&quot;NULL&quot;);
269   }
270 }
271 
272 
273 // MonitorValue
274 
275 MonitorValue::MonitorValue(ScopeValue* owner, Location basic_lock, bool eliminated) {
276   _owner       = owner;
277   _basic_lock  = basic_lock;
</pre>
</td>
</tr>
</table>
<center><a href="compiledMethod.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="debugInfo.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
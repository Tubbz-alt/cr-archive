<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/code/compiledIC.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="codeHeapState.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compiledIC.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/compiledIC.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/systemDictionary.hpp&quot;
 27 #include &quot;code/codeBehaviours.hpp&quot;
 28 #include &quot;code/codeCache.hpp&quot;
 29 #include &quot;code/compiledIC.hpp&quot;
 30 #include &quot;code/icBuffer.hpp&quot;
 31 #include &quot;code/nmethod.hpp&quot;
 32 #include &quot;code/vtableStubs.hpp&quot;
 33 #include &quot;interpreter/interpreter.hpp&quot;
 34 #include &quot;interpreter/linkResolver.hpp&quot;
 35 #include &quot;memory/metadataFactory.hpp&quot;
 36 #include &quot;memory/oopFactory.hpp&quot;
 37 #include &quot;memory/resourceArea.hpp&quot;

 38 #include &quot;oops/method.inline.hpp&quot;
 39 #include &quot;oops/oop.inline.hpp&quot;
 40 #include &quot;oops/symbol.hpp&quot;
 41 #include &quot;runtime/handles.inline.hpp&quot;
 42 #include &quot;runtime/icache.hpp&quot;
 43 #include &quot;runtime/sharedRuntime.hpp&quot;
 44 #include &quot;runtime/stubRoutines.hpp&quot;
 45 #include &quot;utilities/events.hpp&quot;
 46 
 47 
 48 // Every time a compiled IC is changed or its type is being accessed,
 49 // either the CompiledIC_lock must be set or we must be at a safe point.
 50 
 51 CompiledICLocker::CompiledICLocker(CompiledMethod* method)
 52   : _method(method),
 53     _behaviour(CompiledICProtectionBehaviour::current()),
<span class="line-modified"> 54     _locked(_behaviour-&gt;lock(_method)),</span>
<span class="line-removed"> 55     _nsv(true, !SafepointSynchronize::is_at_safepoint()) {</span>
 56 }
 57 
 58 CompiledICLocker::~CompiledICLocker() {
 59   if (_locked) {
 60     _behaviour-&gt;unlock(_method);
 61   }
 62 }
 63 
 64 bool CompiledICLocker::is_safe(CompiledMethod* method) {
 65   return CompiledICProtectionBehaviour::current()-&gt;is_safe(method);
 66 }
 67 
 68 bool CompiledICLocker::is_safe(address code) {
 69   CodeBlob* cb = CodeCache::find_blob_unsafe(code);
 70   assert(cb != NULL &amp;&amp; cb-&gt;is_compiled(), &quot;must be compiled&quot;);
 71   CompiledMethod* cm = cb-&gt;as_compiled_method();
 72   return CompiledICProtectionBehaviour::current()-&gt;is_safe(cm);
 73 }
 74 
 75 //-----------------------------------------------------------------------------
</pre>
<hr />
<pre>
270       needs_ic_stub_refill = true;
271       return false;
272     }
273   } else {
274     assert(call_info-&gt;call_kind() == CallInfo::vtable_call, &quot;either itable or vtable&quot;);
275     // Can be different than selected_method-&gt;vtable_index(), due to package-private etc.
276     int vtable_index = call_info-&gt;vtable_index();
277     assert(call_info-&gt;resolved_klass()-&gt;verify_vtable_index(vtable_index), &quot;sanity check&quot;);
278     entry = VtableStubs::find_vtable_stub(vtable_index);
279     if (entry == NULL) {
280       return false;
281     }
282     if (!InlineCacheBuffer::create_transition_stub(this, NULL, entry)) {
283       needs_ic_stub_refill = true;
284       return false;
285     }
286   }
287 
288   if (TraceICs) {
289     ResourceMark rm;
<span class="line-modified">290     assert(!call_info-&gt;selected_method().is_null(), &quot;Unexpected null selected method&quot;);</span>
291     tty-&gt;print_cr (&quot;IC@&quot; INTPTR_FORMAT &quot;: to megamorphic %s entry: &quot; INTPTR_FORMAT,
292                    p2i(instruction_address()), call_info-&gt;selected_method()-&gt;print_value_string(), p2i(entry));
293   }
294 
295   // We can&#39;t check this anymore. With lazy deopt we could have already
296   // cleaned this IC entry before we even return. This is possible if
297   // we ran out of space in the inline cache buffer trying to do the
298   // set_next and we safepointed to free up space. This is a benign
299   // race because the IC entry was complete when we safepointed so
300   // cleaning it immediately is harmless.
301   // assert(is_megamorphic(), &quot;sanity check&quot;);
302   return true;
303 }
304 
305 
306 // true if destination is megamorphic stub
307 bool CompiledIC::is_megamorphic() const {
308   assert(CompiledICLocker::is_safe(_method), &quot;mt unsafe call&quot;);
309   assert(!is_optimized(), &quot;an optimized call cannot be megamorphic&quot;);
310 
</pre>
<hr />
<pre>
724 
725 void CompiledIC::print_compiled_ic() {
726   tty-&gt;print(&quot;Inline cache at &quot; INTPTR_FORMAT &quot;, calling %s &quot; INTPTR_FORMAT &quot; cached_value &quot; INTPTR_FORMAT,
727              p2i(instruction_address()), is_call_to_interpreted() ? &quot;interpreted &quot; : &quot;&quot;, p2i(ic_destination()), p2i(is_optimized() ? NULL : cached_value()));
728 }
729 
730 void CompiledDirectStaticCall::print() {
731   tty-&gt;print(&quot;static call at &quot; INTPTR_FORMAT &quot; -&gt; &quot;, p2i(instruction_address()));
732   if (is_clean()) {
733     tty-&gt;print(&quot;clean&quot;);
734   } else if (is_call_to_compiled()) {
735     tty-&gt;print(&quot;compiled&quot;);
736   } else if (is_call_to_far()) {
737     tty-&gt;print(&quot;far&quot;);
738   } else if (is_call_to_interpreted()) {
739     tty-&gt;print(&quot;interpreted&quot;);
740   }
741   tty-&gt;cr();
742 }
743 


















744 #endif // !PRODUCT
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/systemDictionary.hpp&quot;
 27 #include &quot;code/codeBehaviours.hpp&quot;
 28 #include &quot;code/codeCache.hpp&quot;
 29 #include &quot;code/compiledIC.hpp&quot;
 30 #include &quot;code/icBuffer.hpp&quot;
 31 #include &quot;code/nmethod.hpp&quot;
 32 #include &quot;code/vtableStubs.hpp&quot;
 33 #include &quot;interpreter/interpreter.hpp&quot;
 34 #include &quot;interpreter/linkResolver.hpp&quot;
 35 #include &quot;memory/metadataFactory.hpp&quot;
 36 #include &quot;memory/oopFactory.hpp&quot;
 37 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added"> 38 #include &quot;memory/universe.hpp&quot;</span>
 39 #include &quot;oops/method.inline.hpp&quot;
 40 #include &quot;oops/oop.inline.hpp&quot;
 41 #include &quot;oops/symbol.hpp&quot;
 42 #include &quot;runtime/handles.inline.hpp&quot;
 43 #include &quot;runtime/icache.hpp&quot;
 44 #include &quot;runtime/sharedRuntime.hpp&quot;
 45 #include &quot;runtime/stubRoutines.hpp&quot;
 46 #include &quot;utilities/events.hpp&quot;
 47 
 48 
 49 // Every time a compiled IC is changed or its type is being accessed,
 50 // either the CompiledIC_lock must be set or we must be at a safe point.
 51 
 52 CompiledICLocker::CompiledICLocker(CompiledMethod* method)
 53   : _method(method),
 54     _behaviour(CompiledICProtectionBehaviour::current()),
<span class="line-modified"> 55     _locked(_behaviour-&gt;lock(_method)) {</span>

 56 }
 57 
 58 CompiledICLocker::~CompiledICLocker() {
 59   if (_locked) {
 60     _behaviour-&gt;unlock(_method);
 61   }
 62 }
 63 
 64 bool CompiledICLocker::is_safe(CompiledMethod* method) {
 65   return CompiledICProtectionBehaviour::current()-&gt;is_safe(method);
 66 }
 67 
 68 bool CompiledICLocker::is_safe(address code) {
 69   CodeBlob* cb = CodeCache::find_blob_unsafe(code);
 70   assert(cb != NULL &amp;&amp; cb-&gt;is_compiled(), &quot;must be compiled&quot;);
 71   CompiledMethod* cm = cb-&gt;as_compiled_method();
 72   return CompiledICProtectionBehaviour::current()-&gt;is_safe(cm);
 73 }
 74 
 75 //-----------------------------------------------------------------------------
</pre>
<hr />
<pre>
270       needs_ic_stub_refill = true;
271       return false;
272     }
273   } else {
274     assert(call_info-&gt;call_kind() == CallInfo::vtable_call, &quot;either itable or vtable&quot;);
275     // Can be different than selected_method-&gt;vtable_index(), due to package-private etc.
276     int vtable_index = call_info-&gt;vtable_index();
277     assert(call_info-&gt;resolved_klass()-&gt;verify_vtable_index(vtable_index), &quot;sanity check&quot;);
278     entry = VtableStubs::find_vtable_stub(vtable_index);
279     if (entry == NULL) {
280       return false;
281     }
282     if (!InlineCacheBuffer::create_transition_stub(this, NULL, entry)) {
283       needs_ic_stub_refill = true;
284       return false;
285     }
286   }
287 
288   if (TraceICs) {
289     ResourceMark rm;
<span class="line-modified">290     assert(call_info-&gt;selected_method() != NULL, &quot;Unexpected null selected method&quot;);</span>
291     tty-&gt;print_cr (&quot;IC@&quot; INTPTR_FORMAT &quot;: to megamorphic %s entry: &quot; INTPTR_FORMAT,
292                    p2i(instruction_address()), call_info-&gt;selected_method()-&gt;print_value_string(), p2i(entry));
293   }
294 
295   // We can&#39;t check this anymore. With lazy deopt we could have already
296   // cleaned this IC entry before we even return. This is possible if
297   // we ran out of space in the inline cache buffer trying to do the
298   // set_next and we safepointed to free up space. This is a benign
299   // race because the IC entry was complete when we safepointed so
300   // cleaning it immediately is harmless.
301   // assert(is_megamorphic(), &quot;sanity check&quot;);
302   return true;
303 }
304 
305 
306 // true if destination is megamorphic stub
307 bool CompiledIC::is_megamorphic() const {
308   assert(CompiledICLocker::is_safe(_method), &quot;mt unsafe call&quot;);
309   assert(!is_optimized(), &quot;an optimized call cannot be megamorphic&quot;);
310 
</pre>
<hr />
<pre>
724 
725 void CompiledIC::print_compiled_ic() {
726   tty-&gt;print(&quot;Inline cache at &quot; INTPTR_FORMAT &quot;, calling %s &quot; INTPTR_FORMAT &quot; cached_value &quot; INTPTR_FORMAT,
727              p2i(instruction_address()), is_call_to_interpreted() ? &quot;interpreted &quot; : &quot;&quot;, p2i(ic_destination()), p2i(is_optimized() ? NULL : cached_value()));
728 }
729 
730 void CompiledDirectStaticCall::print() {
731   tty-&gt;print(&quot;static call at &quot; INTPTR_FORMAT &quot; -&gt; &quot;, p2i(instruction_address()));
732   if (is_clean()) {
733     tty-&gt;print(&quot;clean&quot;);
734   } else if (is_call_to_compiled()) {
735     tty-&gt;print(&quot;compiled&quot;);
736   } else if (is_call_to_far()) {
737     tty-&gt;print(&quot;far&quot;);
738   } else if (is_call_to_interpreted()) {
739     tty-&gt;print(&quot;interpreted&quot;);
740   }
741   tty-&gt;cr();
742 }
743 
<span class="line-added">744 void CompiledDirectStaticCall::verify_mt_safe(const methodHandle&amp; callee, address entry,</span>
<span class="line-added">745                                               NativeMovConstReg* method_holder,</span>
<span class="line-added">746                                               NativeJump*        jump) {</span>
<span class="line-added">747   // A generated lambda form might be deleted from the Lambdaform</span>
<span class="line-added">748   // cache in MethodTypeForm.  If a jit compiled lambdaform method</span>
<span class="line-added">749   // becomes not entrant and the cache access returns null, the new</span>
<span class="line-added">750   // resolve will lead to a new generated LambdaForm.</span>
<span class="line-added">751   Method* old_method = reinterpret_cast&lt;Method*&gt;(method_holder-&gt;data());</span>
<span class="line-added">752   assert(old_method == NULL || old_method == callee() ||</span>
<span class="line-added">753          callee-&gt;is_compiled_lambda_form() ||</span>
<span class="line-added">754          !old_method-&gt;method_holder()-&gt;is_loader_alive() ||</span>
<span class="line-added">755          old_method-&gt;is_old(),  // may be race patching deoptimized nmethod due to redefinition.</span>
<span class="line-added">756          &quot;a) MT-unsafe modification of inline cache&quot;);</span>
<span class="line-added">757 </span>
<span class="line-added">758   address destination = jump-&gt;jump_destination();</span>
<span class="line-added">759   assert(destination == (address)-1 || destination == entry,</span>
<span class="line-added">760          &quot;b) MT-unsafe modification of inline cache&quot;);</span>
<span class="line-added">761 }</span>
762 #endif // !PRODUCT
</pre>
</td>
</tr>
</table>
<center><a href="codeHeapState.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compiledIC.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
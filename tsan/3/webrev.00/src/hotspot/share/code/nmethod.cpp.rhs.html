<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/code/nmethod.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
<a name="2" id="anc2"></a><span class="line-added">  27 #include &quot;asm/assembler.inline.hpp&quot;</span>
  28 #include &quot;code/codeCache.hpp&quot;
  29 #include &quot;code/compiledIC.hpp&quot;
  30 #include &quot;code/compiledMethod.inline.hpp&quot;
  31 #include &quot;code/dependencies.hpp&quot;
  32 #include &quot;code/nativeInst.hpp&quot;
  33 #include &quot;code/nmethod.hpp&quot;
  34 #include &quot;code/scopeDesc.hpp&quot;
  35 #include &quot;compiler/abstractCompiler.hpp&quot;
  36 #include &quot;compiler/compileBroker.hpp&quot;
  37 #include &quot;compiler/compileLog.hpp&quot;
  38 #include &quot;compiler/compilerDirectives.hpp&quot;
  39 #include &quot;compiler/directivesParser.hpp&quot;
  40 #include &quot;compiler/disassembler.hpp&quot;
  41 #include &quot;interpreter/bytecode.hpp&quot;
  42 #include &quot;logging/log.hpp&quot;
  43 #include &quot;logging/logStream.hpp&quot;
  44 #include &quot;memory/allocation.inline.hpp&quot;
  45 #include &quot;memory/resourceArea.hpp&quot;
<a name="3" id="anc3"></a><span class="line-added">  46 #include &quot;memory/universe.hpp&quot;</span>
  47 #include &quot;oops/access.inline.hpp&quot;
  48 #include &quot;oops/method.inline.hpp&quot;
  49 #include &quot;oops/methodData.hpp&quot;
  50 #include &quot;oops/oop.inline.hpp&quot;
  51 #include &quot;prims/jvmtiImpl.hpp&quot;
<a name="4" id="anc4"></a><span class="line-added">  52 #include &quot;prims/jvmtiThreadState.hpp&quot;</span>
  53 #include &quot;runtime/atomic.hpp&quot;
<a name="5" id="anc5"></a><span class="line-added">  54 #include &quot;runtime/deoptimization.hpp&quot;</span>
  55 #include &quot;runtime/flags/flagSetting.hpp&quot;
  56 #include &quot;runtime/frame.inline.hpp&quot;
  57 #include &quot;runtime/handles.inline.hpp&quot;
  58 #include &quot;runtime/jniHandles.inline.hpp&quot;
  59 #include &quot;runtime/orderAccess.hpp&quot;
  60 #include &quot;runtime/os.hpp&quot;
  61 #include &quot;runtime/safepointVerifiers.hpp&quot;
<a name="6" id="anc6"></a><span class="line-added">  62 #include &quot;runtime/serviceThread.hpp&quot;</span>
  63 #include &quot;runtime/sharedRuntime.hpp&quot;
  64 #include &quot;runtime/sweeper.hpp&quot;
  65 #include &quot;runtime/vmThread.hpp&quot;
  66 #include &quot;utilities/align.hpp&quot;
  67 #include &quot;utilities/dtrace.hpp&quot;
  68 #include &quot;utilities/events.hpp&quot;
  69 #include &quot;utilities/resourceHash.hpp&quot;
  70 #include &quot;utilities/xmlstream.hpp&quot;
  71 #if INCLUDE_JVMCI
<a name="7" id="anc7"></a><span class="line-modified">  72 #include &quot;jvmci/jvmciRuntime.hpp&quot;</span>
  73 #endif
  74 
  75 #ifdef DTRACE_ENABLED
  76 
  77 // Only bother with this argument setup if dtrace is available
  78 
  79 #define DTRACE_METHOD_UNLOAD_PROBE(method)                                \
  80   {                                                                       \
  81     Method* m = (method);                                                 \
  82     if (m != NULL) {                                                      \
  83       Symbol* klass_name = m-&gt;klass_name();                               \
  84       Symbol* name = m-&gt;name();                                           \
  85       Symbol* signature = m-&gt;signature();                                 \
  86       HOTSPOT_COMPILED_METHOD_UNLOAD(                                     \
  87         (char *) klass_name-&gt;bytes(), klass_name-&gt;utf8_length(),                   \
  88         (char *) name-&gt;bytes(), name-&gt;utf8_length(),                               \
  89         (char *) signature-&gt;bytes(), signature-&gt;utf8_length());                    \
  90     }                                                                     \
  91   }
  92 
  93 #else //  ndef DTRACE_ENABLED
  94 
  95 #define DTRACE_METHOD_UNLOAD_PROBE(method)
  96 
  97 #endif
  98 
  99 //---------------------------------------------------------------------------------
 100 // NMethod statistics
 101 // They are printed under various flags, including:
 102 //   PrintC1Statistics, PrintOptoStatistics, LogVMOutput, and LogCompilation.
 103 // (In the latter two cases, they like other stats are printed to the log only.)
 104 
 105 #ifndef PRODUCT
 106 // These variables are put into one block to reduce relocations
 107 // and make it simpler to print from the debugger.
 108 struct java_nmethod_stats_struct {
 109   int nmethod_count;
 110   int total_size;
 111   int relocation_size;
 112   int consts_size;
 113   int insts_size;
 114   int stub_size;
 115   int scopes_data_size;
 116   int scopes_pcs_size;
 117   int dependencies_size;
 118   int handler_table_size;
 119   int nul_chk_table_size;
<a name="8" id="anc8"></a><span class="line-added"> 120 #if INCLUDE_JVMCI</span>
<span class="line-added"> 121   int speculations_size;</span>
<span class="line-added"> 122   int jvmci_data_size;</span>
<span class="line-added"> 123 #endif</span>
 124   int oops_size;
 125   int metadata_size;
 126 
 127   void note_nmethod(nmethod* nm) {
 128     nmethod_count += 1;
 129     total_size          += nm-&gt;size();
 130     relocation_size     += nm-&gt;relocation_size();
 131     consts_size         += nm-&gt;consts_size();
 132     insts_size          += nm-&gt;insts_size();
 133     stub_size           += nm-&gt;stub_size();
 134     oops_size           += nm-&gt;oops_size();
 135     metadata_size       += nm-&gt;metadata_size();
 136     scopes_data_size    += nm-&gt;scopes_data_size();
 137     scopes_pcs_size     += nm-&gt;scopes_pcs_size();
 138     dependencies_size   += nm-&gt;dependencies_size();
 139     handler_table_size  += nm-&gt;handler_table_size();
 140     nul_chk_table_size  += nm-&gt;nul_chk_table_size();
<a name="9" id="anc9"></a><span class="line-added"> 141 #if INCLUDE_JVMCI</span>
<span class="line-added"> 142     speculations_size   += nm-&gt;speculations_size();</span>
<span class="line-added"> 143     jvmci_data_size     += nm-&gt;jvmci_data_size();</span>
<span class="line-added"> 144 #endif</span>
 145   }
 146   void print_nmethod_stats(const char* name) {
 147     if (nmethod_count == 0)  return;
 148     tty-&gt;print_cr(&quot;Statistics for %d bytecoded nmethods for %s:&quot;, nmethod_count, name);
 149     if (total_size != 0)          tty-&gt;print_cr(&quot; total in heap  = %d&quot;, total_size);
 150     if (nmethod_count != 0)       tty-&gt;print_cr(&quot; header         = &quot; SIZE_FORMAT, nmethod_count * sizeof(nmethod));
 151     if (relocation_size != 0)     tty-&gt;print_cr(&quot; relocation     = %d&quot;, relocation_size);
 152     if (consts_size != 0)         tty-&gt;print_cr(&quot; constants      = %d&quot;, consts_size);
 153     if (insts_size != 0)          tty-&gt;print_cr(&quot; main code      = %d&quot;, insts_size);
 154     if (stub_size != 0)           tty-&gt;print_cr(&quot; stub code      = %d&quot;, stub_size);
 155     if (oops_size != 0)           tty-&gt;print_cr(&quot; oops           = %d&quot;, oops_size);
 156     if (metadata_size != 0)       tty-&gt;print_cr(&quot; metadata       = %d&quot;, metadata_size);
 157     if (scopes_data_size != 0)    tty-&gt;print_cr(&quot; scopes data    = %d&quot;, scopes_data_size);
 158     if (scopes_pcs_size != 0)     tty-&gt;print_cr(&quot; scopes pcs     = %d&quot;, scopes_pcs_size);
 159     if (dependencies_size != 0)   tty-&gt;print_cr(&quot; dependencies   = %d&quot;, dependencies_size);
 160     if (handler_table_size != 0)  tty-&gt;print_cr(&quot; handler table  = %d&quot;, handler_table_size);
 161     if (nul_chk_table_size != 0)  tty-&gt;print_cr(&quot; nul chk table  = %d&quot;, nul_chk_table_size);
<a name="10" id="anc10"></a><span class="line-added"> 162 #if INCLUDE_JVMCI</span>
<span class="line-added"> 163     if (speculations_size != 0)   tty-&gt;print_cr(&quot; speculations   = %d&quot;, speculations_size);</span>
<span class="line-added"> 164     if (jvmci_data_size != 0)     tty-&gt;print_cr(&quot; JVMCI data     = %d&quot;, jvmci_data_size);</span>
<span class="line-added"> 165 #endif</span>
 166   }
 167 };
 168 
 169 struct native_nmethod_stats_struct {
 170   int native_nmethod_count;
 171   int native_total_size;
 172   int native_relocation_size;
 173   int native_insts_size;
 174   int native_oops_size;
 175   int native_metadata_size;
 176   void note_native_nmethod(nmethod* nm) {
 177     native_nmethod_count += 1;
 178     native_total_size       += nm-&gt;size();
 179     native_relocation_size  += nm-&gt;relocation_size();
 180     native_insts_size       += nm-&gt;insts_size();
 181     native_oops_size        += nm-&gt;oops_size();
 182     native_metadata_size    += nm-&gt;metadata_size();
 183   }
 184   void print_native_nmethod_stats() {
 185     if (native_nmethod_count == 0)  return;
 186     tty-&gt;print_cr(&quot;Statistics for %d native nmethods:&quot;, native_nmethod_count);
 187     if (native_total_size != 0)       tty-&gt;print_cr(&quot; N. total size  = %d&quot;, native_total_size);
 188     if (native_relocation_size != 0)  tty-&gt;print_cr(&quot; N. relocation  = %d&quot;, native_relocation_size);
 189     if (native_insts_size != 0)       tty-&gt;print_cr(&quot; N. main code   = %d&quot;, native_insts_size);
 190     if (native_oops_size != 0)        tty-&gt;print_cr(&quot; N. oops        = %d&quot;, native_oops_size);
 191     if (native_metadata_size != 0)    tty-&gt;print_cr(&quot; N. metadata    = %d&quot;, native_metadata_size);
 192   }
 193 };
 194 
 195 struct pc_nmethod_stats_struct {
 196   int pc_desc_resets;   // number of resets (= number of caches)
 197   int pc_desc_queries;  // queries to nmethod::find_pc_desc
 198   int pc_desc_approx;   // number of those which have approximate true
 199   int pc_desc_repeats;  // number of _pc_descs[0] hits
 200   int pc_desc_hits;     // number of LRU cache hits
 201   int pc_desc_tests;    // total number of PcDesc examinations
 202   int pc_desc_searches; // total number of quasi-binary search steps
 203   int pc_desc_adds;     // number of LUR cache insertions
 204 
 205   void print_pc_stats() {
 206     tty-&gt;print_cr(&quot;PcDesc Statistics:  %d queries, %.2f comparisons per query&quot;,
 207                   pc_desc_queries,
 208                   (double)(pc_desc_tests + pc_desc_searches)
 209                   / pc_desc_queries);
 210     tty-&gt;print_cr(&quot;  caches=%d queries=%d/%d, hits=%d+%d, tests=%d+%d, adds=%d&quot;,
 211                   pc_desc_resets,
 212                   pc_desc_queries, pc_desc_approx,
 213                   pc_desc_repeats, pc_desc_hits,
 214                   pc_desc_tests, pc_desc_searches, pc_desc_adds);
 215   }
 216 };
 217 
 218 #ifdef COMPILER1
 219 static java_nmethod_stats_struct c1_java_nmethod_stats;
 220 #endif
 221 #ifdef COMPILER2
 222 static java_nmethod_stats_struct c2_java_nmethod_stats;
 223 #endif
 224 #if INCLUDE_JVMCI
 225 static java_nmethod_stats_struct jvmci_java_nmethod_stats;
 226 #endif
 227 static java_nmethod_stats_struct unknown_java_nmethod_stats;
 228 
 229 static native_nmethod_stats_struct native_nmethod_stats;
 230 static pc_nmethod_stats_struct pc_nmethod_stats;
 231 
 232 static void note_java_nmethod(nmethod* nm) {
 233 #ifdef COMPILER1
 234   if (nm-&gt;is_compiled_by_c1()) {
 235     c1_java_nmethod_stats.note_nmethod(nm);
 236   } else
 237 #endif
 238 #ifdef COMPILER2
 239   if (nm-&gt;is_compiled_by_c2()) {
 240     c2_java_nmethod_stats.note_nmethod(nm);
 241   } else
 242 #endif
 243 #if INCLUDE_JVMCI
 244   if (nm-&gt;is_compiled_by_jvmci()) {
 245     jvmci_java_nmethod_stats.note_nmethod(nm);
 246   } else
 247 #endif
 248   {
 249     unknown_java_nmethod_stats.note_nmethod(nm);
 250   }
 251 }
 252 #endif // !PRODUCT
 253 
 254 //---------------------------------------------------------------------------------
 255 
 256 
 257 ExceptionCache::ExceptionCache(Handle exception, address pc, address handler) {
 258   assert(pc != NULL, &quot;Must be non null&quot;);
 259   assert(exception.not_null(), &quot;Must be non null&quot;);
 260   assert(handler != NULL, &quot;Must be non null&quot;);
 261 
 262   _count = 0;
 263   _exception_type = exception-&gt;klass();
 264   _next = NULL;
 265   _purge_list_next = NULL;
 266 
 267   add_address_and_handler(pc,handler);
 268 }
 269 
 270 
 271 address ExceptionCache::match(Handle exception, address pc) {
 272   assert(pc != NULL,&quot;Must be non null&quot;);
 273   assert(exception.not_null(),&quot;Must be non null&quot;);
 274   if (exception-&gt;klass() == exception_type()) {
 275     return (test_address(pc));
 276   }
 277 
 278   return NULL;
 279 }
 280 
 281 
 282 bool ExceptionCache::match_exception_with_space(Handle exception) {
 283   assert(exception.not_null(),&quot;Must be non null&quot;);
 284   if (exception-&gt;klass() == exception_type() &amp;&amp; count() &lt; cache_size) {
 285     return true;
 286   }
 287   return false;
 288 }
 289 
 290 
 291 address ExceptionCache::test_address(address addr) {
 292   int limit = count();
 293   for (int i = 0; i &lt; limit; i++) {
 294     if (pc_at(i) == addr) {
 295       return handler_at(i);
 296     }
 297   }
 298   return NULL;
 299 }
 300 
 301 
 302 bool ExceptionCache::add_address_and_handler(address addr, address handler) {
 303   if (test_address(addr) == handler) return true;
 304 
 305   int index = count();
 306   if (index &lt; cache_size) {
 307     set_pc_at(index, addr);
 308     set_handler_at(index, handler);
 309     increment_count();
 310     return true;
 311   }
 312   return false;
 313 }
 314 
 315 ExceptionCache* ExceptionCache::next() {
 316   return Atomic::load(&amp;_next);
 317 }
 318 
 319 void ExceptionCache::set_next(ExceptionCache *ec) {
<a name="11" id="anc11"></a><span class="line-modified"> 320   Atomic::store(&amp;_next, ec);</span>
 321 }
 322 
 323 //-----------------------------------------------------------------------------
 324 
 325 
 326 // Helper used by both find_pc_desc methods.
 327 static inline bool match_desc(PcDesc* pc, int pc_offset, bool approximate) {
 328   NOT_PRODUCT(++pc_nmethod_stats.pc_desc_tests);
 329   if (!approximate)
 330     return pc-&gt;pc_offset() == pc_offset;
 331   else
 332     return (pc-1)-&gt;pc_offset() &lt; pc_offset &amp;&amp; pc_offset &lt;= pc-&gt;pc_offset();
 333 }
 334 
 335 void PcDescCache::reset_to(PcDesc* initial_pc_desc) {
 336   if (initial_pc_desc == NULL) {
 337     _pc_descs[0] = NULL; // native method; no PcDescs at all
 338     return;
 339   }
 340   NOT_PRODUCT(++pc_nmethod_stats.pc_desc_resets);
 341   // reset the cache by filling it with benign (non-null) values
 342   assert(initial_pc_desc-&gt;pc_offset() &lt; 0, &quot;must be sentinel&quot;);
 343   for (int i = 0; i &lt; cache_size; i++)
 344     _pc_descs[i] = initial_pc_desc;
 345 }
 346 
 347 PcDesc* PcDescCache::find_pc_desc(int pc_offset, bool approximate) {
 348   NOT_PRODUCT(++pc_nmethod_stats.pc_desc_queries);
 349   NOT_PRODUCT(if (approximate) ++pc_nmethod_stats.pc_desc_approx);
 350 
 351   // Note: one might think that caching the most recently
 352   // read value separately would be a win, but one would be
 353   // wrong.  When many threads are updating it, the cache
 354   // line it&#39;s in would bounce between caches, negating
 355   // any benefit.
 356 
 357   // In order to prevent race conditions do not load cache elements
 358   // repeatedly, but use a local copy:
 359   PcDesc* res;
 360 
 361   // Step one:  Check the most recently added value.
 362   res = _pc_descs[0];
 363   if (res == NULL) return NULL;  // native method; no PcDescs at all
 364   if (match_desc(res, pc_offset, approximate)) {
 365     NOT_PRODUCT(++pc_nmethod_stats.pc_desc_repeats);
 366     return res;
 367   }
 368 
 369   // Step two:  Check the rest of the LRU cache.
 370   for (int i = 1; i &lt; cache_size; ++i) {
 371     res = _pc_descs[i];
 372     if (res-&gt;pc_offset() &lt; 0) break;  // optimization: skip empty cache
 373     if (match_desc(res, pc_offset, approximate)) {
 374       NOT_PRODUCT(++pc_nmethod_stats.pc_desc_hits);
 375       return res;
 376     }
 377   }
 378 
 379   // Report failure.
 380   return NULL;
 381 }
 382 
 383 void PcDescCache::add_pc_desc(PcDesc* pc_desc) {
 384   NOT_PRODUCT(++pc_nmethod_stats.pc_desc_adds);
 385   // Update the LRU cache by shifting pc_desc forward.
 386   for (int i = 0; i &lt; cache_size; i++)  {
 387     PcDesc* next = _pc_descs[i];
 388     _pc_descs[i] = pc_desc;
 389     pc_desc = next;
 390   }
 391 }
 392 
 393 // adjust pcs_size so that it is a multiple of both oopSize and
 394 // sizeof(PcDesc) (assumes that if sizeof(PcDesc) is not a multiple
 395 // of oopSize, then 2*sizeof(PcDesc) is)
 396 static int adjust_pcs_size(int pcs_size) {
 397   int nsize = align_up(pcs_size,   oopSize);
 398   if ((nsize % sizeof(PcDesc)) != 0) {
 399     nsize = pcs_size + sizeof(PcDesc);
 400   }
 401   assert((nsize % oopSize) == 0, &quot;correct alignment&quot;);
 402   return nsize;
 403 }
 404 
 405 
 406 int nmethod::total_size() const {
 407   return
 408     consts_size()        +
 409     insts_size()         +
 410     stub_size()          +
 411     scopes_data_size()   +
 412     scopes_pcs_size()    +
 413     handler_table_size() +
 414     nul_chk_table_size();
 415 }
 416 
 417 address* nmethod::orig_pc_addr(const frame* fr) {
 418   return (address*) ((address)fr-&gt;unextended_sp() + _orig_pc_offset);
 419 }
 420 
 421 const char* nmethod::compile_kind() const {
 422   if (is_osr_method())     return &quot;osr&quot;;
 423   if (method() != NULL &amp;&amp; is_native_method())  return &quot;c2n&quot;;
 424   return NULL;
 425 }
 426 
 427 // Fill in default values for various flag fields
 428 void nmethod::init_defaults() {
 429   _state                      = not_installed;
 430   _has_flushed_dependencies   = 0;
 431   _lock_count                 = 0;
 432   _stack_traversal_mark       = 0;
<a name="12" id="anc12"></a><span class="line-modified"> 433   _load_reported              = false; // jvmti state</span>
<span class="line-added"> 434   _unload_reported            = false;</span>
 435   _is_far_code                = false; // nmethods are located in CodeCache
 436 
 437 #ifdef ASSERT
 438   _oops_are_stale             = false;
 439 #endif
 440 
 441   _oops_do_mark_link       = NULL;
<a name="13" id="anc13"></a>
 442   _osr_link                = NULL;
 443 #if INCLUDE_RTM_OPT
 444   _rtm_state               = NoRTM;
 445 #endif
<a name="14" id="anc14"></a>




 446 }
 447 
 448 nmethod* nmethod::new_native_nmethod(const methodHandle&amp; method,
 449   int compile_id,
 450   CodeBuffer *code_buffer,
 451   int vep_offset,
 452   int frame_complete,
 453   int frame_size,
 454   ByteSize basic_lock_owner_sp_offset,
 455   ByteSize basic_lock_sp_offset,
 456   OopMapSet* oop_maps) {
 457   code_buffer-&gt;finalize_oop_references(method);
 458   // create nmethod
 459   nmethod* nm = NULL;
 460   {
<a name="15" id="anc15"></a><span class="line-modified"> 461     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
 462     int native_nmethod_size = CodeBlob::allocation_size(code_buffer, sizeof(nmethod));
<a name="16" id="anc16"></a><span class="line-added"> 463 </span>
 464     CodeOffsets offsets;
 465     offsets.set_value(CodeOffsets::Verified_Entry, vep_offset);
 466     offsets.set_value(CodeOffsets::Frame_Complete, frame_complete);
<a name="17" id="anc17"></a><span class="line-modified"> 467     nm = new (native_nmethod_size, CompLevel_none)</span>
<span class="line-modified"> 468     nmethod(method(), compiler_none, native_nmethod_size,</span>
<span class="line-modified"> 469             compile_id, &amp;offsets,</span>
<span class="line-modified"> 470             code_buffer, frame_size,</span>
<span class="line-modified"> 471             basic_lock_owner_sp_offset,</span>
<span class="line-added"> 472             basic_lock_sp_offset,</span>
<span class="line-added"> 473             oop_maps);</span>
 474     NOT_PRODUCT(if (nm != NULL)  native_nmethod_stats.note_native_nmethod(nm));
 475   }
 476 
 477   if (nm != NULL) {
 478     // verify nmethod
 479     debug_only(nm-&gt;verify();) // might block
 480 
 481     nm-&gt;log_new_nmethod();
<a name="18" id="anc18"></a>
 482   }
 483   return nm;
 484 }
 485 
 486 nmethod* nmethod::new_nmethod(const methodHandle&amp; method,
 487   int compile_id,
 488   int entry_bci,
 489   CodeOffsets* offsets,
 490   int orig_pc_offset,
 491   DebugInformationRecorder* debug_info,
 492   Dependencies* dependencies,
 493   CodeBuffer* code_buffer, int frame_size,
 494   OopMapSet* oop_maps,
 495   ExceptionHandlerTable* handler_table,
 496   ImplicitExceptionTable* nul_chk_table,
 497   AbstractCompiler* compiler,
 498   int comp_level
 499 #if INCLUDE_JVMCI
<a name="19" id="anc19"></a><span class="line-modified"> 500   , char* speculations,</span>
<span class="line-modified"> 501   int speculations_len,</span>
<span class="line-added"> 502   int nmethod_mirror_index,</span>
<span class="line-added"> 503   const char* nmethod_mirror_name,</span>
<span class="line-added"> 504   FailedSpeculation** failed_speculations</span>
 505 #endif
 506 )
 507 {
 508   assert(debug_info-&gt;oop_recorder() == code_buffer-&gt;oop_recorder(), &quot;shared OR&quot;);
 509   code_buffer-&gt;finalize_oop_references(method);
 510   // create nmethod
 511   nmethod* nm = NULL;
<a name="20" id="anc20"></a><span class="line-modified"> 512   { MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added"> 513 #if INCLUDE_JVMCI</span>
<span class="line-added"> 514     int jvmci_data_size = !compiler-&gt;is_jvmci() ? 0 : JVMCINMethodData::compute_size(nmethod_mirror_name);</span>
<span class="line-added"> 515 #endif</span>
 516     int nmethod_size =
 517       CodeBlob::allocation_size(code_buffer, sizeof(nmethod))
 518       + adjust_pcs_size(debug_info-&gt;pcs_size())
 519       + align_up((int)dependencies-&gt;size_in_bytes(), oopSize)
 520       + align_up(handler_table-&gt;size_in_bytes()    , oopSize)
 521       + align_up(nul_chk_table-&gt;size_in_bytes()    , oopSize)
<a name="21" id="anc21"></a><span class="line-added"> 522 #if INCLUDE_JVMCI</span>
<span class="line-added"> 523       + align_up(speculations_len                  , oopSize)</span>
<span class="line-added"> 524       + align_up(jvmci_data_size                   , oopSize)</span>
<span class="line-added"> 525 #endif</span>
 526       + align_up(debug_info-&gt;data_size()           , oopSize);
 527 
 528     nm = new (nmethod_size, comp_level)
 529     nmethod(method(), compiler-&gt;type(), nmethod_size, compile_id, entry_bci, offsets,
 530             orig_pc_offset, debug_info, dependencies, code_buffer, frame_size,
 531             oop_maps,
 532             handler_table,
 533             nul_chk_table,
 534             compiler,
 535             comp_level
 536 #if INCLUDE_JVMCI
<a name="22" id="anc22"></a><span class="line-modified"> 537             , speculations,</span>
<span class="line-modified"> 538             speculations_len,</span>
<span class="line-added"> 539             jvmci_data_size</span>
 540 #endif
 541             );
 542 
 543     if (nm != NULL) {
<a name="23" id="anc23"></a><span class="line-added"> 544 #if INCLUDE_JVMCI</span>
<span class="line-added"> 545       if (compiler-&gt;is_jvmci()) {</span>
<span class="line-added"> 546         // Initialize the JVMCINMethodData object inlined into nm</span>
<span class="line-added"> 547         nm-&gt;jvmci_nmethod_data()-&gt;initialize(nmethod_mirror_index, nmethod_mirror_name, failed_speculations);</span>
<span class="line-added"> 548       }</span>
<span class="line-added"> 549 #endif</span>
 550       // To make dependency checking during class loading fast, record
 551       // the nmethod dependencies in the classes it is dependent on.
 552       // This allows the dependency checking code to simply walk the
 553       // class hierarchy above the loaded class, checking only nmethods
 554       // which are dependent on those classes.  The slow way is to
 555       // check every nmethod for dependencies which makes it linear in
 556       // the number of methods compiled.  For applications with a lot
 557       // classes the slow way is too slow.
 558       for (Dependencies::DepStream deps(nm); deps.next(); ) {
 559         if (deps.type() == Dependencies::call_site_target_value) {
 560           // CallSite dependencies are managed on per-CallSite instance basis.
 561           oop call_site = deps.argument_oop(0);
 562           MethodHandles::add_dependent_nmethod(call_site, nm);
 563         } else {
 564           Klass* klass = deps.context_type();
 565           if (klass == NULL) {
 566             continue;  // ignore things like evol_method
 567           }
 568           // record this nmethod as dependent on this klass
 569           InstanceKlass::cast(klass)-&gt;add_dependent_nmethod(nm);
 570         }
 571       }
 572       NOT_PRODUCT(if (nm != NULL)  note_java_nmethod(nm));
 573     }
 574   }
 575   // Do verification and logging outside CodeCache_lock.
 576   if (nm != NULL) {
 577     // Safepoints in nmethod::verify aren&#39;t allowed because nm hasn&#39;t been installed yet.
 578     DEBUG_ONLY(nm-&gt;verify();)
 579     nm-&gt;log_new_nmethod();
 580   }
 581   return nm;
 582 }
 583 
 584 // For native wrappers
 585 nmethod::nmethod(
 586   Method* method,
 587   CompilerType type,
 588   int nmethod_size,
 589   int compile_id,
 590   CodeOffsets* offsets,
 591   CodeBuffer* code_buffer,
 592   int frame_size,
 593   ByteSize basic_lock_owner_sp_offset,
 594   ByteSize basic_lock_sp_offset,
 595   OopMapSet* oop_maps )
 596   : CompiledMethod(method, &quot;native nmethod&quot;, type, nmethod_size, sizeof(nmethod), code_buffer, offsets-&gt;value(CodeOffsets::Frame_Complete), frame_size, oop_maps, false),
 597   _is_unloading_state(0),
 598   _native_receiver_sp_offset(basic_lock_owner_sp_offset),
 599   _native_basic_lock_sp_offset(basic_lock_sp_offset)
 600 {
 601   {
<a name="24" id="anc24"></a><span class="line-modified"> 602     int scopes_data_offset   = 0;</span>
<span class="line-modified"> 603     int deoptimize_offset    = 0;</span>
<span class="line-modified"> 604     int deoptimize_mh_offset = 0;</span>
 605 
 606     debug_only(NoSafepointVerifier nsv;)
 607     assert_locked_or_safepoint(CodeCache_lock);
 608 
 609     init_defaults();
 610     _entry_bci               = InvocationEntryBci;
 611     // We have no exception handler or deopt handler make the
 612     // values something that will never match a pc like the nmethod vtable entry
 613     _exception_offset        = 0;
 614     _orig_pc_offset          = 0;
 615 
 616     _consts_offset           = data_offset();
 617     _stub_offset             = data_offset();
 618     _oops_offset             = data_offset();
 619     _metadata_offset         = _oops_offset         + align_up(code_buffer-&gt;total_oop_size(), oopSize);
 620     scopes_data_offset       = _metadata_offset     + align_up(code_buffer-&gt;total_metadata_size(), wordSize);
 621     _scopes_pcs_offset       = scopes_data_offset;
 622     _dependencies_offset     = _scopes_pcs_offset;
 623     _handler_table_offset    = _dependencies_offset;
 624     _nul_chk_table_offset    = _handler_table_offset;
<a name="25" id="anc25"></a><span class="line-added"> 625 #if INCLUDE_JVMCI</span>
<span class="line-added"> 626     _speculations_offset     = _nul_chk_table_offset;</span>
<span class="line-added"> 627     _jvmci_data_offset       = _speculations_offset;</span>
<span class="line-added"> 628     _nmethod_end_offset      = _jvmci_data_offset;</span>
<span class="line-added"> 629 #else</span>
 630     _nmethod_end_offset      = _nul_chk_table_offset;
<a name="26" id="anc26"></a><span class="line-added"> 631 #endif</span>
 632     _compile_id              = compile_id;
 633     _comp_level              = CompLevel_none;
 634     _entry_point             = code_begin()          + offsets-&gt;value(CodeOffsets::Entry);
 635     _verified_entry_point    = code_begin()          + offsets-&gt;value(CodeOffsets::Verified_Entry);
 636     _osr_entry_point         = NULL;
 637     _exception_cache         = NULL;
 638     _pc_desc_container.reset_to(NULL);
 639     _hotness_counter         = NMethodSweeper::hotness_counter_reset_val();
 640 
 641     _scopes_data_begin = (address) this + scopes_data_offset;
 642     _deopt_handler_begin = (address) this + deoptimize_offset;
 643     _deopt_mh_handler_begin = (address) this + deoptimize_mh_offset;
 644 
 645     code_buffer-&gt;copy_code_and_locs_to(this);
 646     code_buffer-&gt;copy_values_to(this);
 647 
 648     clear_unloading_state();
 649 
 650     Universe::heap()-&gt;register_nmethod(this);
 651     debug_only(Universe::heap()-&gt;verify_nmethod(this));
 652 
 653     CodeCache::commit(this);
 654   }
 655 
 656   if (PrintNativeNMethods || PrintDebugInfo || PrintRelocations || PrintDependencies) {
 657     ttyLocker ttyl;  // keep the following output all in one block
 658     // This output goes directly to the tty, not the compiler log.
 659     // To enable tools to match it up with the compilation activity,
 660     // be sure to tag this tty output with the compile ID.
 661     if (xtty != NULL) {
 662       xtty-&gt;begin_head(&quot;print_native_nmethod&quot;);
 663       xtty-&gt;method(_method);
 664       xtty-&gt;stamp();
 665       xtty-&gt;end_head(&quot; address=&#39;&quot; INTPTR_FORMAT &quot;&#39;&quot;, (intptr_t) this);
 666     }
<a name="27" id="anc27"></a><span class="line-modified"> 667     // Print the header part, then print the requested information.</span>
<span class="line-modified"> 668     // This is both handled in decode2(), called via print_code() -&gt; decode()</span>

 669     if (PrintNativeNMethods) {
<a name="28" id="anc28"></a><span class="line-added"> 670       tty-&gt;print_cr(&quot;-------------------------- Assembly (native nmethod) ---------------------------&quot;);</span>
 671       print_code();
<a name="29" id="anc29"></a><span class="line-modified"> 672       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);</span>
<span class="line-modified"> 673 #if defined(SUPPORT_DATA_STRUCTS)</span>
<span class="line-added"> 674       if (AbstractDisassembler::show_structs()) {</span>
<span class="line-added"> 675         if (oop_maps != NULL) {</span>
<span class="line-added"> 676           tty-&gt;print(&quot;oop maps:&quot;); // oop_maps-&gt;print_on(tty) outputs a cr() at the beginning</span>
<span class="line-added"> 677           oop_maps-&gt;print_on(tty);</span>
<span class="line-added"> 678           tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);</span>
<span class="line-added"> 679         }</span>
 680       }
<a name="30" id="anc30"></a><span class="line-added"> 681 #endif</span>
<span class="line-added"> 682     } else {</span>
<span class="line-added"> 683       print(); // print the header part only.</span>
 684     }
<a name="31" id="anc31"></a><span class="line-modified"> 685 #if defined(SUPPORT_DATA_STRUCTS)</span>
<span class="line-modified"> 686     if (AbstractDisassembler::show_structs()) {</span>
<span class="line-added"> 687       if (PrintRelocations) {</span>
<span class="line-added"> 688         print_relocations();</span>
<span class="line-added"> 689         tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);</span>
<span class="line-added"> 690       }</span>
 691     }
<a name="32" id="anc32"></a><span class="line-added"> 692 #endif</span>
 693     if (xtty != NULL) {
 694       xtty-&gt;tail(&quot;print_native_nmethod&quot;);
 695     }
 696   }
 697 }
 698 
 699 void* nmethod::operator new(size_t size, int nmethod_size, int comp_level) throw () {
 700   return CodeCache::allocate(nmethod_size, CodeCache::get_code_blob_type(comp_level));
 701 }
 702 
 703 nmethod::nmethod(
 704   Method* method,
 705   CompilerType type,
 706   int nmethod_size,
 707   int compile_id,
 708   int entry_bci,
 709   CodeOffsets* offsets,
 710   int orig_pc_offset,
 711   DebugInformationRecorder* debug_info,
 712   Dependencies* dependencies,
 713   CodeBuffer *code_buffer,
 714   int frame_size,
 715   OopMapSet* oop_maps,
 716   ExceptionHandlerTable* handler_table,
 717   ImplicitExceptionTable* nul_chk_table,
 718   AbstractCompiler* compiler,
 719   int comp_level
 720 #if INCLUDE_JVMCI
<a name="33" id="anc33"></a><span class="line-modified"> 721   , char* speculations,</span>
<span class="line-modified"> 722   int speculations_len,</span>
<span class="line-added"> 723   int jvmci_data_size</span>
 724 #endif
 725   )
 726   : CompiledMethod(method, &quot;nmethod&quot;, type, nmethod_size, sizeof(nmethod), code_buffer, offsets-&gt;value(CodeOffsets::Frame_Complete), frame_size, oop_maps, false),
 727   _is_unloading_state(0),
 728   _native_receiver_sp_offset(in_ByteSize(-1)),
 729   _native_basic_lock_sp_offset(in_ByteSize(-1))
 730 {
 731   assert(debug_info-&gt;oop_recorder() == code_buffer-&gt;oop_recorder(), &quot;shared OR&quot;);
 732   {
 733     debug_only(NoSafepointVerifier nsv;)
 734     assert_locked_or_safepoint(CodeCache_lock);
 735 
 736     _deopt_handler_begin = (address) this;
 737     _deopt_mh_handler_begin = (address) this;
 738 
 739     init_defaults();
 740     _entry_bci               = entry_bci;
 741     _compile_id              = compile_id;
 742     _comp_level              = comp_level;
 743     _orig_pc_offset          = orig_pc_offset;
 744     _hotness_counter         = NMethodSweeper::hotness_counter_reset_val();
 745 
 746     // Section offsets
 747     _consts_offset           = content_offset()      + code_buffer-&gt;total_offset_of(code_buffer-&gt;consts());
 748     _stub_offset             = content_offset()      + code_buffer-&gt;total_offset_of(code_buffer-&gt;stubs());
 749     set_ctable_begin(header_begin() + _consts_offset);
 750 
 751 #if INCLUDE_JVMCI
<a name="34" id="anc34"></a>








 752     if (compiler-&gt;is_jvmci()) {
 753       // JVMCI might not produce any stub sections
 754       if (offsets-&gt;value(CodeOffsets::Exceptions) != -1) {
 755         _exception_offset        = code_offset()          + offsets-&gt;value(CodeOffsets::Exceptions);
 756       } else {
 757         _exception_offset = -1;
 758       }
 759       if (offsets-&gt;value(CodeOffsets::Deopt) != -1) {
 760         _deopt_handler_begin       = (address) this + code_offset()          + offsets-&gt;value(CodeOffsets::Deopt);
 761       } else {
 762         _deopt_handler_begin = NULL;
 763       }
 764       if (offsets-&gt;value(CodeOffsets::DeoptMH) != -1) {
 765         _deopt_mh_handler_begin  = (address) this + code_offset()          + offsets-&gt;value(CodeOffsets::DeoptMH);
 766       } else {
 767         _deopt_mh_handler_begin = NULL;
 768       }
<a name="35" id="anc35"></a><span class="line-modified"> 769     } else</span>













 770 #endif
<a name="36" id="anc36"></a><span class="line-added"> 771     {</span>
<span class="line-added"> 772       // Exception handler and deopt handler are in the stub section</span>
<span class="line-added"> 773       assert(offsets-&gt;value(CodeOffsets::Exceptions) != -1, &quot;must be set&quot;);</span>
<span class="line-added"> 774       assert(offsets-&gt;value(CodeOffsets::Deopt     ) != -1, &quot;must be set&quot;);</span>
<span class="line-added"> 775 </span>
<span class="line-added"> 776       _exception_offset       = _stub_offset          + offsets-&gt;value(CodeOffsets::Exceptions);</span>
<span class="line-added"> 777       _deopt_handler_begin    = (address) this + _stub_offset          + offsets-&gt;value(CodeOffsets::Deopt);</span>
<span class="line-added"> 778       if (offsets-&gt;value(CodeOffsets::DeoptMH) != -1) {</span>
<span class="line-added"> 779         _deopt_mh_handler_begin  = (address) this + _stub_offset          + offsets-&gt;value(CodeOffsets::DeoptMH);</span>
<span class="line-added"> 780       } else {</span>
<span class="line-added"> 781         _deopt_mh_handler_begin  = NULL;</span>
<span class="line-added"> 782       }</span>
 783     }
 784     if (offsets-&gt;value(CodeOffsets::UnwindHandler) != -1) {
 785       _unwind_handler_offset = code_offset()         + offsets-&gt;value(CodeOffsets::UnwindHandler);
 786     } else {
 787       _unwind_handler_offset = -1;
 788     }
 789 
 790     _oops_offset             = data_offset();
 791     _metadata_offset         = _oops_offset          + align_up(code_buffer-&gt;total_oop_size(), oopSize);
 792     int scopes_data_offset   = _metadata_offset      + align_up(code_buffer-&gt;total_metadata_size(), wordSize);
 793 
 794     _scopes_pcs_offset       = scopes_data_offset    + align_up(debug_info-&gt;data_size       (), oopSize);
 795     _dependencies_offset     = _scopes_pcs_offset    + adjust_pcs_size(debug_info-&gt;pcs_size());
 796     _handler_table_offset    = _dependencies_offset  + align_up((int)dependencies-&gt;size_in_bytes (), oopSize);
 797     _nul_chk_table_offset    = _handler_table_offset + align_up(handler_table-&gt;size_in_bytes(), oopSize);
<a name="37" id="anc37"></a><span class="line-added"> 798 #if INCLUDE_JVMCI</span>
<span class="line-added"> 799     _speculations_offset     = _nul_chk_table_offset + align_up(nul_chk_table-&gt;size_in_bytes(), oopSize);</span>
<span class="line-added"> 800     _jvmci_data_offset       = _speculations_offset  + align_up(speculations_len, oopSize);</span>
<span class="line-added"> 801     _nmethod_end_offset      = _jvmci_data_offset    + align_up(jvmci_data_size, oopSize);</span>
<span class="line-added"> 802 #else</span>
 803     _nmethod_end_offset      = _nul_chk_table_offset + align_up(nul_chk_table-&gt;size_in_bytes(), oopSize);
<a name="38" id="anc38"></a><span class="line-added"> 804 #endif</span>
 805     _entry_point             = code_begin()          + offsets-&gt;value(CodeOffsets::Entry);
 806     _verified_entry_point    = code_begin()          + offsets-&gt;value(CodeOffsets::Verified_Entry);
 807     _osr_entry_point         = code_begin()          + offsets-&gt;value(CodeOffsets::OSR_Entry);
 808     _exception_cache         = NULL;
<a name="39" id="anc39"></a><span class="line-modified"> 809     _scopes_data_begin       = (address) this + scopes_data_offset;</span>

 810 
 811     _pc_desc_container.reset_to(scopes_pcs_begin());
 812 
 813     code_buffer-&gt;copy_code_and_locs_to(this);
 814     // Copy contents of ScopeDescRecorder to nmethod
 815     code_buffer-&gt;copy_values_to(this);
 816     debug_info-&gt;copy_to(this);
 817     dependencies-&gt;copy_to(this);
 818     clear_unloading_state();
 819 
 820     Universe::heap()-&gt;register_nmethod(this);
 821     debug_only(Universe::heap()-&gt;verify_nmethod(this));
 822 
 823     CodeCache::commit(this);
 824 
 825     // Copy contents of ExceptionHandlerTable to nmethod
 826     handler_table-&gt;copy_to(this);
 827     nul_chk_table-&gt;copy_to(this);
 828 
<a name="40" id="anc40"></a><span class="line-added"> 829 #if INCLUDE_JVMCI</span>
<span class="line-added"> 830     // Copy speculations to nmethod</span>
<span class="line-added"> 831     if (speculations_size() != 0) {</span>
<span class="line-added"> 832       memcpy(speculations_begin(), speculations, speculations_len);</span>
<span class="line-added"> 833     }</span>
<span class="line-added"> 834 #endif</span>
<span class="line-added"> 835 </span>
 836     // we use the information of entry points to find out if a method is
 837     // static or non static
 838     assert(compiler-&gt;is_c2() || compiler-&gt;is_jvmci() ||
 839            _method-&gt;is_static() == (entry_point() == _verified_entry_point),
 840            &quot; entry points must be same for static methods and vice versa&quot;);
 841   }
 842 }
 843 
 844 // Print a short set of xml attributes to identify this nmethod.  The
 845 // output should be embedded in some other element.
 846 void nmethod::log_identity(xmlStream* log) const {
 847   log-&gt;print(&quot; compile_id=&#39;%d&#39;&quot;, compile_id());
 848   const char* nm_kind = compile_kind();
 849   if (nm_kind != NULL)  log-&gt;print(&quot; compile_kind=&#39;%s&#39;&quot;, nm_kind);
 850   log-&gt;print(&quot; compiler=&#39;%s&#39;&quot;, compiler_name());
 851   if (TieredCompilation) {
 852     log-&gt;print(&quot; level=&#39;%d&#39;&quot;, comp_level());
 853   }
 854 #if INCLUDE_JVMCI
<a name="41" id="anc41"></a><span class="line-modified"> 855   if (jvmci_nmethod_data() != NULL) {</span>
<span class="line-modified"> 856     const char* jvmci_name = jvmci_nmethod_data()-&gt;name();</span>
 857     if (jvmci_name != NULL) {
<a name="42" id="anc42"></a><span class="line-modified"> 858       log-&gt;print(&quot; jvmci_mirror_name=&#39;&quot;);</span>
 859       log-&gt;text(&quot;%s&quot;, jvmci_name);
 860       log-&gt;print(&quot;&#39;&quot;);
 861     }
<a name="43" id="anc43"></a><span class="line-added"> 862   }</span>
 863 #endif
 864 }
 865 
 866 
 867 #define LOG_OFFSET(log, name)                    \
 868   if (p2i(name##_end()) - p2i(name##_begin())) \
 869     log-&gt;print(&quot; &quot; XSTR(name) &quot;_offset=&#39;&quot; INTX_FORMAT &quot;&#39;&quot;    , \
 870                p2i(name##_begin()) - p2i(this))
 871 
 872 
 873 void nmethod::log_new_nmethod() const {
 874   if (LogCompilation &amp;&amp; xtty != NULL) {
 875     ttyLocker ttyl;
 876     HandleMark hm;
 877     xtty-&gt;begin_elem(&quot;nmethod&quot;);
 878     log_identity(xtty);
 879     xtty-&gt;print(&quot; entry=&#39;&quot; INTPTR_FORMAT &quot;&#39; size=&#39;%d&#39;&quot;, p2i(code_begin()), size());
 880     xtty-&gt;print(&quot; address=&#39;&quot; INTPTR_FORMAT &quot;&#39;&quot;, p2i(this));
 881 
 882     LOG_OFFSET(xtty, relocation);
 883     LOG_OFFSET(xtty, consts);
 884     LOG_OFFSET(xtty, insts);
 885     LOG_OFFSET(xtty, stub);
 886     LOG_OFFSET(xtty, scopes_data);
 887     LOG_OFFSET(xtty, scopes_pcs);
 888     LOG_OFFSET(xtty, dependencies);
 889     LOG_OFFSET(xtty, handler_table);
 890     LOG_OFFSET(xtty, nul_chk_table);
 891     LOG_OFFSET(xtty, oops);
 892     LOG_OFFSET(xtty, metadata);
 893 
 894     xtty-&gt;method(method());
 895     xtty-&gt;stamp();
 896     xtty-&gt;end_elem();
 897   }
 898 }
 899 
 900 #undef LOG_OFFSET
 901 
 902 
 903 // Print out more verbose output usually for a newly created nmethod.
 904 void nmethod::print_on(outputStream* st, const char* msg) const {
 905   if (st != NULL) {
 906     ttyLocker ttyl;
 907     if (WizardMode) {
 908       CompileTask::print(st, this, msg, /*short_form:*/ true);
 909       st-&gt;print_cr(&quot; (&quot; INTPTR_FORMAT &quot;)&quot;, p2i(this));
 910     } else {
 911       CompileTask::print(st, this, msg, /*short_form:*/ false);
 912     }
 913   }
 914 }
 915 
 916 void nmethod::maybe_print_nmethod(DirectiveSet* directive) {
 917   bool printnmethods = directive-&gt;PrintAssemblyOption || directive-&gt;PrintNMethodsOption;
 918   if (printnmethods || PrintDebugInfo || PrintRelocations || PrintDependencies || PrintExceptionHandlers) {
 919     print_nmethod(printnmethods);
 920   }
 921 }
 922 
 923 void nmethod::print_nmethod(bool printmethod) {
 924   ttyLocker ttyl;  // keep the following output all in one block
 925   if (xtty != NULL) {
 926     xtty-&gt;begin_head(&quot;print_nmethod&quot;);
<a name="44" id="anc44"></a><span class="line-added"> 927     log_identity(xtty);</span>
 928     xtty-&gt;stamp();
 929     xtty-&gt;end_head();
 930   }
<a name="45" id="anc45"></a><span class="line-modified"> 931   // Print the header part, then print the requested information.</span>
<span class="line-modified"> 932   // This is both handled in decode2().</span>

 933   if (printmethod) {
<a name="46" id="anc46"></a><span class="line-modified"> 934     HandleMark hm;</span>
<span class="line-modified"> 935     ResourceMark m;</span>
<span class="line-modified"> 936     if (is_compiled_by_c1()) {</span>
<span class="line-modified"> 937       tty-&gt;cr();</span>
<span class="line-added"> 938       tty-&gt;print_cr(&quot;============================= C1-compiled nmethod ==============================&quot;);</span>
<span class="line-added"> 939     }</span>
<span class="line-added"> 940     if (is_compiled_by_jvmci()) {</span>
<span class="line-added"> 941       tty-&gt;cr();</span>
<span class="line-added"> 942       tty-&gt;print_cr(&quot;=========================== JVMCI-compiled nmethod =============================&quot;);</span>
<span class="line-added"> 943     }</span>
<span class="line-added"> 944     tty-&gt;print_cr(&quot;----------------------------------- Assembly -----------------------------------&quot;);</span>
<span class="line-added"> 945     decode2(tty);</span>
<span class="line-added"> 946 #if defined(SUPPORT_DATA_STRUCTS)</span>
<span class="line-added"> 947     if (AbstractDisassembler::show_structs()) {</span>
<span class="line-added"> 948       // Print the oops from the underlying CodeBlob as well.</span>
<span class="line-added"> 949       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);</span>
<span class="line-added"> 950       print_oops(tty);</span>
<span class="line-added"> 951       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);</span>
<span class="line-added"> 952       print_metadata(tty);</span>
<span class="line-added"> 953       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);</span>
<span class="line-added"> 954       print_pcs();</span>
<span class="line-added"> 955       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);</span>
<span class="line-added"> 956       if (oop_maps() != NULL) {</span>
<span class="line-added"> 957         tty-&gt;print(&quot;oop maps:&quot;); // oop_maps()-&gt;print_on(tty) outputs a cr() at the beginning</span>
<span class="line-added"> 958         oop_maps()-&gt;print_on(tty);</span>
<span class="line-added"> 959         tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);</span>
<span class="line-added"> 960       }</span>
 961     }
<a name="47" id="anc47"></a><span class="line-added"> 962 #endif</span>
<span class="line-added"> 963   } else {</span>
<span class="line-added"> 964     print(); // print the header part only.</span>
 965   }
<a name="48" id="anc48"></a><span class="line-modified"> 966 </span>
<span class="line-modified"> 967 #if defined(SUPPORT_DATA_STRUCTS)</span>
<span class="line-modified"> 968   if (AbstractDisassembler::show_structs()) {</span>
<span class="line-modified"> 969     methodHandle mh(Thread::current(), _method);</span>
<span class="line-modified"> 970     if (printmethod || PrintDebugInfo || CompilerOracle::has_option_string(mh, &quot;PrintDebugInfo&quot;)) {</span>
<span class="line-modified"> 971       print_scopes();</span>
<span class="line-modified"> 972       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);</span>
<span class="line-modified"> 973     }</span>
<span class="line-modified"> 974     if (printmethod || PrintRelocations || CompilerOracle::has_option_string(mh, &quot;PrintRelocations&quot;)) {</span>
<span class="line-modified"> 975       print_relocations();</span>
<span class="line-modified"> 976       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);</span>
<span class="line-modified"> 977     }</span>
<span class="line-modified"> 978     if (printmethod || PrintDependencies || CompilerOracle::has_option_string(mh, &quot;PrintDependencies&quot;)) {</span>
<span class="line-modified"> 979       print_dependencies();</span>
<span class="line-modified"> 980       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);</span>
<span class="line-modified"> 981     }</span>
<span class="line-added"> 982     if (printmethod || PrintExceptionHandlers) {</span>
<span class="line-added"> 983       print_handler_table();</span>
<span class="line-added"> 984       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);</span>
<span class="line-added"> 985       print_nul_chk_table();</span>
<span class="line-added"> 986       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);</span>
<span class="line-added"> 987     }</span>
<span class="line-added"> 988 </span>
<span class="line-added"> 989     if (printmethod) {</span>
<span class="line-added"> 990       print_recorded_oops();</span>
<span class="line-added"> 991       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);</span>
<span class="line-added"> 992       print_recorded_metadata();</span>
<span class="line-added"> 993       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);</span>
<span class="line-added"> 994     }</span>
 995   }
<a name="49" id="anc49"></a><span class="line-added"> 996 #endif</span>
<span class="line-added"> 997 </span>
 998   if (xtty != NULL) {
 999     xtty-&gt;tail(&quot;print_nmethod&quot;);
1000   }
1001 }
1002 
1003 
1004 // Promote one word from an assembly-time handle to a live embedded oop.
1005 inline void nmethod::initialize_immediate_oop(oop* dest, jobject handle) {
1006   if (handle == NULL ||
1007       // As a special case, IC oops are initialized to 1 or -1.
1008       handle == (jobject) Universe::non_oop_word()) {
1009     (*dest) = (oop) handle;
1010   } else {
1011     (*dest) = JNIHandles::resolve_non_null(handle);
1012   }
1013 }
1014 
1015 
1016 // Have to have the same name because it&#39;s called by a template
1017 void nmethod::copy_values(GrowableArray&lt;jobject&gt;* array) {
1018   int length = array-&gt;length();
1019   assert((address)(oops_begin() + length) &lt;= (address)oops_end(), &quot;oops big enough&quot;);
1020   oop* dest = oops_begin();
1021   for (int index = 0 ; index &lt; length; index++) {
1022     initialize_immediate_oop(&amp;dest[index], array-&gt;at(index));
1023   }
1024 
1025   // Now we can fix up all the oops in the code.  We need to do this
1026   // in the code because the assembler uses jobjects as placeholders.
1027   // The code and relocations have already been initialized by the
1028   // CodeBlob constructor, so it is valid even at this early point to
1029   // iterate over relocations and patch the code.
1030   fix_oop_relocations(NULL, NULL, /*initialize_immediates=*/ true);
1031 }
1032 
1033 void nmethod::copy_values(GrowableArray&lt;Metadata*&gt;* array) {
1034   int length = array-&gt;length();
1035   assert((address)(metadata_begin() + length) &lt;= (address)metadata_end(), &quot;big enough&quot;);
1036   Metadata** dest = metadata_begin();
1037   for (int index = 0 ; index &lt; length; index++) {
1038     dest[index] = array-&gt;at(index);
1039   }
1040 }
1041 
1042 void nmethod::fix_oop_relocations(address begin, address end, bool initialize_immediates) {
1043   // re-patch all oop-bearing instructions, just in case some oops moved
1044   RelocIterator iter(this, begin, end);
1045   while (iter.next()) {
1046     if (iter.type() == relocInfo::oop_type) {
1047       oop_Relocation* reloc = iter.oop_reloc();
1048       if (initialize_immediates &amp;&amp; reloc-&gt;oop_is_immediate()) {
1049         oop* dest = reloc-&gt;oop_addr();
<a name="50" id="anc50"></a><span class="line-modified">1050         initialize_immediate_oop(dest, cast_from_oop&lt;jobject&gt;(*dest));</span>
1051       }
1052       // Refresh the oop-related bits of this instruction.
1053       reloc-&gt;fix_oop_relocation();
1054     } else if (iter.type() == relocInfo::metadata_type) {
1055       metadata_Relocation* reloc = iter.metadata_reloc();
1056       reloc-&gt;fix_metadata_relocation();
1057     }
1058   }
1059 }
1060 
1061 
1062 void nmethod::verify_clean_inline_caches() {
1063   assert(CompiledICLocker::is_safe(this), &quot;mt unsafe call&quot;);
1064 
1065   ResourceMark rm;
1066   RelocIterator iter(this, oops_reloc_begin());
1067   while(iter.next()) {
1068     switch(iter.type()) {
1069       case relocInfo::virtual_call_type:
1070       case relocInfo::opt_virtual_call_type: {
1071         CompiledIC *ic = CompiledIC_at(&amp;iter);
1072         // Ok, to lookup references to zombies here
1073         CodeBlob *cb = CodeCache::find_blob_unsafe(ic-&gt;ic_destination());
1074         assert(cb != NULL, &quot;destination not in CodeBlob?&quot;);
1075         nmethod* nm = cb-&gt;as_nmethod_or_null();
1076         if( nm != NULL ) {
1077           // Verify that inline caches pointing to both zombie and not_entrant methods are clean
1078           if (!nm-&gt;is_in_use() || (nm-&gt;method()-&gt;code() != nm)) {
1079             assert(ic-&gt;is_clean(), &quot;IC should be clean&quot;);
1080           }
1081         }
1082         break;
1083       }
1084       case relocInfo::static_call_type: {
1085         CompiledStaticCall *csc = compiledStaticCall_at(iter.reloc());
1086         CodeBlob *cb = CodeCache::find_blob_unsafe(csc-&gt;destination());
1087         assert(cb != NULL, &quot;destination not in CodeBlob?&quot;);
1088         nmethod* nm = cb-&gt;as_nmethod_or_null();
1089         if( nm != NULL ) {
1090           // Verify that inline caches pointing to both zombie and not_entrant methods are clean
1091           if (!nm-&gt;is_in_use() || (nm-&gt;method()-&gt;code() != nm)) {
1092             assert(csc-&gt;is_clean(), &quot;IC should be clean&quot;);
1093           }
1094         }
1095         break;
1096       }
1097       default:
1098         break;
1099     }
1100   }
1101 }
1102 
1103 // This is a private interface with the sweeper.
1104 void nmethod::mark_as_seen_on_stack() {
1105   assert(is_alive(), &quot;Must be an alive method&quot;);
1106   // Set the traversal mark to ensure that the sweeper does 2
1107   // cleaning passes before moving to zombie.
1108   set_stack_traversal_mark(NMethodSweeper::traversal_count());
1109 }
1110 
1111 // Tell if a non-entrant method can be converted to a zombie (i.e.,
1112 // there are no activations on the stack, not in use by the VM,
1113 // and not in use by the ServiceThread)
1114 bool nmethod::can_convert_to_zombie() {
1115   // Note that this is called when the sweeper has observed the nmethod to be
1116   // not_entrant. However, with concurrent code cache unloading, the state
1117   // might have moved on to unloaded if it is_unloading(), due to racing
1118   // concurrent GC threads.
1119   assert(is_not_entrant() || is_unloading(), &quot;must be a non-entrant method&quot;);
1120 
1121   // Since the nmethod sweeper only does partial sweep the sweeper&#39;s traversal
1122   // count can be greater than the stack traversal count before it hits the
1123   // nmethod for the second time.
1124   // If an is_unloading() nmethod is still not_entrant, then it is not safe to
1125   // convert it to zombie due to GC unloading interactions. However, if it
1126   // has become unloaded, then it is okay to convert such nmethods to zombie.
1127   return stack_traversal_mark() + 1 &lt; NMethodSweeper::traversal_count() &amp;&amp;
1128          !is_locked_by_vm() &amp;&amp; (!is_unloading() || is_unloaded());
1129 }
1130 
1131 void nmethod::inc_decompile_count() {
1132   if (!is_compiled_by_c2() &amp;&amp; !is_compiled_by_jvmci()) return;
1133   // Could be gated by ProfileTraps, but do not bother...
1134   Method* m = method();
1135   if (m == NULL)  return;
1136   MethodData* mdo = m-&gt;method_data();
1137   if (mdo == NULL)  return;
1138   // There is a benign race here.  See comments in methodData.hpp.
1139   mdo-&gt;inc_decompile_count();
1140 }
1141 
<a name="51" id="anc51"></a><span class="line-added">1142 bool nmethod::try_transition(int new_state_int) {</span>
<span class="line-added">1143   signed char new_state = new_state_int;</span>
<span class="line-added">1144 #ifdef DEBUG</span>
<span class="line-added">1145   if (new_state != unloaded) {</span>
<span class="line-added">1146     assert_lock_strong(CompiledMethod_lock);</span>
<span class="line-added">1147   }</span>
<span class="line-added">1148 #endif</span>
<span class="line-added">1149   for (;;) {</span>
<span class="line-added">1150     signed char old_state = Atomic::load(&amp;_state);</span>
<span class="line-added">1151     if (old_state &gt;= new_state) {</span>
<span class="line-added">1152       // Ensure monotonicity of transitions.</span>
<span class="line-added">1153       return false;</span>
<span class="line-added">1154     }</span>
<span class="line-added">1155     if (Atomic::cmpxchg(&amp;_state, old_state, new_state) == old_state) {</span>
<span class="line-added">1156       return true;</span>
<span class="line-added">1157     }</span>
<span class="line-added">1158   }</span>
<span class="line-added">1159 }</span>
<span class="line-added">1160 </span>
1161 void nmethod::make_unloaded() {
1162   post_compiled_method_unload();
1163 
1164   // This nmethod is being unloaded, make sure that dependencies
1165   // recorded in instanceKlasses get flushed.
1166   // Since this work is being done during a GC, defer deleting dependencies from the
1167   // InstanceKlass.
1168   assert(Universe::heap()-&gt;is_gc_active() || Thread::current()-&gt;is_ConcurrentGC_thread(),
1169          &quot;should only be called during gc&quot;);
1170   flush_dependencies(/*delete_immediately*/false);
1171 
1172   // Break cycle between nmethod &amp; method
1173   LogTarget(Trace, class, unload, nmethod) lt;
1174   if (lt.is_enabled()) {
1175     LogStream ls(lt);
1176     ls.print(&quot;making nmethod &quot; INTPTR_FORMAT
1177              &quot; unloadable, Method*(&quot; INTPTR_FORMAT
1178              &quot;) &quot;,
1179              p2i(this), p2i(_method));
1180      ls.cr();
1181   }
1182   // Unlink the osr method, so we do not look this up again
1183   if (is_osr_method()) {
<a name="52" id="anc52"></a><span class="line-modified">1184     // Invalidate the osr nmethod only once. Note that with concurrent</span>
<span class="line-added">1185     // code cache unloading, OSR nmethods are invalidated before they</span>
<span class="line-added">1186     // are made unloaded. Therefore, this becomes a no-op then.</span>
1187     if (is_in_use()) {
1188       invalidate_osr_method();
1189     }
1190 #ifdef ASSERT
1191     if (method() != NULL) {
1192       // Make sure osr nmethod is invalidated, i.e. not on the list
1193       bool found = method()-&gt;method_holder()-&gt;remove_osr_nmethod(this);
1194       assert(!found, &quot;osr nmethod should have been invalidated&quot;);
1195     }
1196 #endif
1197   }
1198 
1199   // If _method is already NULL the Method* is about to be unloaded,
1200   // so we don&#39;t have to break the cycle. Note that it is possible to
1201   // have the Method* live here, in case we unload the nmethod because
1202   // it is pointing to some oop (other than the Method*) being unloaded.
1203   if (_method != NULL) {
<a name="53" id="anc53"></a><span class="line-modified">1204     _method-&gt;unlink_code(this);</span>





1205   }
1206 
1207   // Make the class unloaded - i.e., change state and notify sweeper
1208   assert(SafepointSynchronize::is_at_safepoint() || Thread::current()-&gt;is_ConcurrentGC_thread(),
1209          &quot;must be at safepoint&quot;);
1210 
1211   {
1212     // Clear ICStubs and release any CompiledICHolders.
1213     CompiledICLocker ml(this);
1214     clear_ic_callsites();
1215   }
1216 
1217   // Unregister must be done before the state change
1218   {
<a name="54" id="anc54"></a><span class="line-modified">1219     MutexLocker ml(SafepointSynchronize::is_at_safepoint() ? NULL : CodeCache_lock,</span>
1220                      Mutex::_no_safepoint_check_flag);
1221     Universe::heap()-&gt;unregister_nmethod(this);
1222   }
1223 
<a name="55" id="anc55"></a><span class="line-added">1224   // Clear the method of this dead nmethod</span>
<span class="line-added">1225   set_method(NULL);</span>
<span class="line-added">1226 </span>
1227   // Log the unloading.
1228   log_state_change();
1229 
<a name="56" id="anc56"></a>






1230   // The Method* is gone at this point
1231   assert(_method == NULL, &quot;Tautology&quot;);
1232 
1233   set_osr_link(NULL);
1234   NMethodSweeper::report_state_change(this);
1235 
<a name="57" id="anc57"></a><span class="line-modified">1236   bool transition_success = try_transition(unloaded);</span>
<span class="line-modified">1237 </span>
<span class="line-modified">1238   // It is an important invariant that there exists no race between</span>
<span class="line-modified">1239   // the sweeper and GC thread competing for making the same nmethod</span>
<span class="line-modified">1240   // zombie and unloaded respectively. This is ensured by</span>
<span class="line-modified">1241   // can_convert_to_zombie() returning false for any is_unloading()</span>
<span class="line-added">1242   // nmethod, informing the sweeper not to step on any GC toes.</span>
<span class="line-added">1243   assert(transition_success, &quot;Invalid nmethod transition to unloaded&quot;);</span>
<span class="line-added">1244 </span>
<span class="line-added">1245 #if INCLUDE_JVMCI</span>
<span class="line-added">1246   // Clear the link between this nmethod and a HotSpotNmethod mirror</span>
<span class="line-added">1247   JVMCINMethodData* nmethod_data = jvmci_nmethod_data();</span>
<span class="line-added">1248   if (nmethod_data != NULL) {</span>
<span class="line-added">1249     nmethod_data-&gt;invalidate_nmethod_mirror(this);</span>
<span class="line-added">1250     nmethod_data-&gt;clear_nmethod_mirror(this);</span>
<span class="line-added">1251   }</span>
<span class="line-added">1252 #endif</span>
1253 }
1254 
1255 void nmethod::invalidate_osr_method() {
1256   assert(_entry_bci != InvocationEntryBci, &quot;wrong kind of nmethod&quot;);
1257   // Remove from list of active nmethods
1258   if (method() != NULL) {
1259     method()-&gt;method_holder()-&gt;remove_osr_nmethod(this);
1260   }
1261 }
1262 
1263 void nmethod::log_state_change() const {
1264   if (LogCompilation) {
1265     if (xtty != NULL) {
1266       ttyLocker ttyl;  // keep the following output all in one block
1267       if (_state == unloaded) {
1268         xtty-&gt;begin_elem(&quot;make_unloaded thread=&#39;&quot; UINTX_FORMAT &quot;&#39;&quot;,
1269                          os::current_thread_id());
1270       } else {
1271         xtty-&gt;begin_elem(&quot;make_not_entrant thread=&#39;&quot; UINTX_FORMAT &quot;&#39;%s&quot;,
1272                          os::current_thread_id(),
1273                          (_state == zombie ? &quot; zombie=&#39;1&#39;&quot; : &quot;&quot;));
1274       }
1275       log_identity(xtty);
1276       xtty-&gt;stamp();
1277       xtty-&gt;end_elem();
1278     }
1279   }
1280 
1281   const char *state_msg = _state == zombie ? &quot;made zombie&quot; : &quot;made not entrant&quot;;
1282   CompileTask::print_ul(this, state_msg);
1283   if (PrintCompilation &amp;&amp; _state != unloaded) {
1284     print_on(tty, state_msg);
1285   }
1286 }
1287 
<a name="58" id="anc58"></a><span class="line-modified">1288 void nmethod::unlink_from_method() {</span>
<span class="line-modified">1289   if (method() != NULL) {</span>
<span class="line-modified">1290     method()-&gt;unlink_code(this);</span>







1291   }
1292 }
1293 
1294 /**
1295  * Common functionality for both make_not_entrant and make_zombie
1296  */
1297 bool nmethod::make_not_entrant_or_zombie(int state) {
1298   assert(state == zombie || state == not_entrant, &quot;must be zombie or not_entrant&quot;);
<a name="59" id="anc59"></a>
1299 
<a name="60" id="anc60"></a><span class="line-modified">1300   if (Atomic::load(&amp;_state) &gt;= state) {</span>
1301     // Avoid taking the lock if already in required state.
1302     // This is safe from races because the state is an end-state,
1303     // which the nmethod cannot back out of once entered.
1304     // No need for fencing either.
1305     return false;
1306   }
1307 
<a name="61" id="anc61"></a><span class="line-modified">1308   // Make sure the nmethod is not flushed.</span>
1309   nmethodLocker nml(this);
<a name="62" id="anc62"></a>
1310   // This can be called while the system is already at a safepoint which is ok
<a name="63" id="anc63"></a><span class="line-modified">1311   NoSafepointVerifier nsv;</span>
1312 
1313   // during patching, depending on the nmethod state we must notify the GC that
1314   // code has been unloaded, unregistering it. We cannot do this right while
<a name="64" id="anc64"></a><span class="line-modified">1315   // holding the CompiledMethod_lock because we need to use the CodeCache_lock. This</span>
1316   // would be prone to deadlocks.
1317   // This flag is used to remember whether we need to later lock and unregister.
1318   bool nmethod_needs_unregister = false;
1319 
1320   {
<a name="65" id="anc65"></a><span class="line-modified">1321     // Enter critical section.  Does not block for safepoint.</span>
<span class="line-modified">1322     MutexLocker ml(CompiledMethod_lock-&gt;owned_by_self() ? NULL : CompiledMethod_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">1323 </span>
1324     // This logic is equivalent to the logic below for patching the
1325     // verified entry point of regular methods. We check that the
1326     // nmethod is in use to ensure that it is invalidated only once.
1327     if (is_osr_method() &amp;&amp; is_in_use()) {
1328       // this effectively makes the osr nmethod not entrant
1329       invalidate_osr_method();
1330     }
1331 
<a name="66" id="anc66"></a><span class="line-modified">1332     if (Atomic::load(&amp;_state) &gt;= state) {</span>



1333       // another thread already performed this transition so nothing
1334       // to do, but return false to indicate this.
1335       return false;
1336     }
1337 
1338     // The caller can be calling the method statically or through an inline
1339     // cache call.
1340     if (!is_osr_method() &amp;&amp; !is_not_entrant()) {
1341       NativeJump::patch_verified_entry(entry_point(), verified_entry_point(),
1342                   SharedRuntime::get_handle_wrong_method_stub());
1343     }
1344 
1345     if (is_in_use() &amp;&amp; update_recompile_counts()) {
1346       // It&#39;s a true state change, so mark the method as decompiled.
1347       // Do it only for transition from alive.
1348       inc_decompile_count();
1349     }
1350 
1351     // If the state is becoming a zombie, signal to unregister the nmethod with
1352     // the heap.
1353     // This nmethod may have already been unloaded during a full GC.
1354     if ((state == zombie) &amp;&amp; !is_unloaded()) {
1355       nmethod_needs_unregister = true;
1356     }
1357 
1358     // Must happen before state change. Otherwise we have a race condition in
<a name="67" id="anc67"></a><span class="line-modified">1359     // nmethod::can_convert_to_zombie(). I.e., a method can immediately</span>
1360     // transition its state from &#39;not_entrant&#39; to &#39;zombie&#39; without having to wait
1361     // for stack scanning.
1362     if (state == not_entrant) {
1363       mark_as_seen_on_stack();
1364       OrderAccess::storestore(); // _stack_traversal_mark and _state
1365     }
1366 
1367     // Change state
<a name="68" id="anc68"></a><span class="line-modified">1368     if (!try_transition(state)) {</span>
<span class="line-added">1369       // If the transition fails, it is due to another thread making the nmethod more</span>
<span class="line-added">1370       // dead. In particular, one thread might be making the nmethod unloaded concurrently.</span>
<span class="line-added">1371       // If so, having patched in the jump in the verified entry unnecessarily is fine.</span>
<span class="line-added">1372       // The nmethod is no longer possible to call by Java threads.</span>
<span class="line-added">1373       // Incrementing the decompile count is also fine as the caller of make_not_entrant()</span>
<span class="line-added">1374       // had a valid reason to deoptimize the nmethod.</span>
<span class="line-added">1375       // Marking the nmethod as seen on stack also has no effect, as the nmethod is now</span>
<span class="line-added">1376       // !is_alive(), and the seen on stack value is only used to convert not_entrant</span>
<span class="line-added">1377       // nmethods to zombie in can_convert_to_zombie().</span>
<span class="line-added">1378       return false;</span>
<span class="line-added">1379     }</span>
1380 
1381     // Log the transition once
1382     log_state_change();
1383 
<a name="69" id="anc69"></a>


1384     // Remove nmethod from method.
<a name="70" id="anc70"></a><span class="line-modified">1385     unlink_from_method();</span>
<span class="line-modified">1386 </span>
<span class="line-added">1387   } // leave critical region under CompiledMethod_lock</span>
<span class="line-added">1388 </span>
<span class="line-added">1389 #if INCLUDE_JVMCI</span>
<span class="line-added">1390   // Invalidate can&#39;t occur while holding the Patching lock</span>
<span class="line-added">1391   JVMCINMethodData* nmethod_data = jvmci_nmethod_data();</span>
<span class="line-added">1392   if (nmethod_data != NULL) {</span>
<span class="line-added">1393     nmethod_data-&gt;invalidate_nmethod_mirror(this);</span>
<span class="line-added">1394   }</span>
<span class="line-added">1395 #endif</span>
1396 
1397 #ifdef ASSERT
1398   if (is_osr_method() &amp;&amp; method() != NULL) {
1399     // Make sure osr nmethod is invalidated, i.e. not on the list
1400     bool found = method()-&gt;method_holder()-&gt;remove_osr_nmethod(this);
1401     assert(!found, &quot;osr nmethod should have been invalidated&quot;);
1402   }
1403 #endif
1404 
1405   // When the nmethod becomes zombie it is no longer alive so the
1406   // dependencies must be flushed.  nmethods in the not_entrant
1407   // state will be flushed later when the transition to zombie
1408   // happens or they get unloaded.
1409   if (state == zombie) {
1410     {
1411       // Flushing dependencies must be done before any possible
1412       // safepoint can sneak in, otherwise the oops used by the
1413       // dependency logic could have become stale.
<a name="71" id="anc71"></a><span class="line-modified">1414       MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
1415       if (nmethod_needs_unregister) {
1416         Universe::heap()-&gt;unregister_nmethod(this);
1417       }
1418       flush_dependencies(/*delete_immediately*/true);
1419     }
1420 
<a name="72" id="anc72"></a><span class="line-added">1421 #if INCLUDE_JVMCI</span>
<span class="line-added">1422     // Now that the nmethod has been unregistered, it&#39;s</span>
<span class="line-added">1423     // safe to clear the HotSpotNmethod mirror oop.</span>
<span class="line-added">1424     if (nmethod_data != NULL) {</span>
<span class="line-added">1425       nmethod_data-&gt;clear_nmethod_mirror(this);</span>
<span class="line-added">1426     }</span>
<span class="line-added">1427 #endif</span>
<span class="line-added">1428 </span>
1429     // Clear ICStubs to prevent back patching stubs of zombie or flushed
1430     // nmethods during the next safepoint (see ICStub::finalize), as well
1431     // as to free up CompiledICHolder resources.
1432     {
1433       CompiledICLocker ml(this);
1434       clear_ic_callsites();
1435     }
1436 
1437     // zombie only - if a JVMTI agent has enabled the CompiledMethodUnload
1438     // event and it hasn&#39;t already been reported for this nmethod then
1439     // report it now. The event may have been reported earlier if the GC
1440     // marked it for unloading). JvmtiDeferredEventQueue support means
1441     // we no longer go to a safepoint here.
1442     post_compiled_method_unload();
1443 
1444 #ifdef ASSERT
1445     // It&#39;s no longer safe to access the oops section since zombie
1446     // nmethods aren&#39;t scanned for GC.
1447     _oops_are_stale = true;
1448 #endif
1449      // the Method may be reclaimed by class unloading now that the
1450      // nmethod is in zombie state
1451     set_method(NULL);
1452   } else {
1453     assert(state == not_entrant, &quot;other cases may need to be handled differently&quot;);
1454   }
1455 
<a name="73" id="anc73"></a><span class="line-modified">1456   if (TraceCreateZombies &amp;&amp; state == zombie) {</span>
1457     ResourceMark m;
1458     tty-&gt;print_cr(&quot;nmethod &lt;&quot; INTPTR_FORMAT &quot;&gt; %s code made %s&quot;, p2i(this), this-&gt;method() ? this-&gt;method()-&gt;name_and_sig_as_C_string() : &quot;null&quot;, (state == not_entrant) ? &quot;not entrant&quot; : &quot;zombie&quot;);
1459   }
1460 
1461   NMethodSweeper::report_state_change(this);
1462   return true;
1463 }
1464 
1465 void nmethod::flush() {
<a name="74" id="anc74"></a><span class="line-modified">1466   MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
1467   // Note that there are no valid oops in the nmethod anymore.
1468   assert(!is_osr_method() || is_unloaded() || is_zombie(),
1469          &quot;osr nmethod must be unloaded or zombie before flushing&quot;);
1470   assert(is_zombie() || is_osr_method(), &quot;must be a zombie method&quot;);
1471   assert (!is_locked_by_vm(), &quot;locked methods shouldn&#39;t be flushed&quot;);
1472   assert_locked_or_safepoint(CodeCache_lock);
1473 
1474   // completely deallocate this method
1475   Events::log(JavaThread::current(), &quot;flushing nmethod &quot; INTPTR_FORMAT, p2i(this));
1476   if (PrintMethodFlushing) {
1477     tty-&gt;print_cr(&quot;*flushing %s nmethod %3d/&quot; INTPTR_FORMAT &quot;. Live blobs:&quot; UINT32_FORMAT
1478                   &quot;/Free CodeCache:&quot; SIZE_FORMAT &quot;Kb&quot;,
1479                   is_osr_method() ? &quot;osr&quot; : &quot;&quot;,_compile_id, p2i(this), CodeCache::blob_count(),
1480                   CodeCache::unallocated_capacity(CodeCache::get_code_blob_type(this))/1024);
1481   }
1482 
1483   // We need to deallocate any ExceptionCache data.
1484   // Note that we do not need to grab the nmethod lock for this, it
1485   // better be thread safe if we&#39;re disposing of it!
1486   ExceptionCache* ec = exception_cache();
1487   set_exception_cache(NULL);
1488   while(ec != NULL) {
1489     ExceptionCache* next = ec-&gt;next();
1490     delete ec;
1491     ec = next;
1492   }
1493 
<a name="75" id="anc75"></a>




1494   Universe::heap()-&gt;flush_nmethod(this);
<a name="76" id="anc76"></a><span class="line-added">1495   CodeCache::unregister_old_nmethod(this);</span>
1496 
1497   CodeBlob::flush();
1498   CodeCache::free(this);
1499 }
1500 
1501 oop nmethod::oop_at(int index) const {
1502   if (index == 0) {
1503     return NULL;
1504   }
1505   return NativeAccess&lt;AS_NO_KEEPALIVE&gt;::oop_load(oop_addr_at(index));
1506 }
1507 
<a name="77" id="anc77"></a><span class="line-added">1508 oop nmethod::oop_at_phantom(int index) const {</span>
<span class="line-added">1509   if (index == 0) {</span>
<span class="line-added">1510     return NULL;</span>
<span class="line-added">1511   }</span>
<span class="line-added">1512   return NativeAccess&lt;ON_PHANTOM_OOP_REF&gt;::oop_load(oop_addr_at(index));</span>
<span class="line-added">1513 }</span>
<span class="line-added">1514 </span>
1515 //
1516 // Notify all classes this nmethod is dependent on that it is no
1517 // longer dependent. This should only be called in two situations.
1518 // First, when a nmethod transitions to a zombie all dependents need
1519 // to be clear.  Since zombification happens at a safepoint there&#39;s no
1520 // synchronization issues.  The second place is a little more tricky.
1521 // During phase 1 of mark sweep class unloading may happen and as a
1522 // result some nmethods may get unloaded.  In this case the flushing
1523 // of dependencies must happen during phase 1 since after GC any
1524 // dependencies in the unloaded nmethod won&#39;t be updated, so
1525 // traversing the dependency information in unsafe.  In that case this
1526 // function is called with a boolean argument and this function only
1527 // notifies instanceKlasses that are reachable
1528 
1529 void nmethod::flush_dependencies(bool delete_immediately) {
1530   DEBUG_ONLY(bool called_by_gc = Universe::heap()-&gt;is_gc_active() || Thread::current()-&gt;is_ConcurrentGC_thread();)
1531   assert(called_by_gc != delete_immediately,
1532   &quot;delete_immediately is false if and only if we are called during GC&quot;);
1533   if (!has_flushed_dependencies()) {
1534     set_has_flushed_dependencies();
1535     for (Dependencies::DepStream deps(this); deps.next(); ) {
1536       if (deps.type() == Dependencies::call_site_target_value) {
1537         // CallSite dependencies are managed on per-CallSite instance basis.
1538         oop call_site = deps.argument_oop(0);
1539         if (delete_immediately) {
1540           assert_locked_or_safepoint(CodeCache_lock);
1541           MethodHandles::remove_dependent_nmethod(call_site, this);
1542         } else {
1543           MethodHandles::clean_dependency_context(call_site);
1544         }
1545       } else {
1546         Klass* klass = deps.context_type();
1547         if (klass == NULL) {
1548           continue;  // ignore things like evol_method
1549         }
1550         // During GC delete_immediately is false, and liveness
1551         // of dependee determines class that needs to be updated.
1552         if (delete_immediately) {
1553           assert_locked_or_safepoint(CodeCache_lock);
1554           InstanceKlass::cast(klass)-&gt;remove_dependent_nmethod(this);
1555         } else if (klass-&gt;is_loader_alive()) {
1556           // The GC may clean dependency contexts concurrently and in parallel.
1557           InstanceKlass::cast(klass)-&gt;clean_dependency_context();
1558         }
1559       }
1560     }
1561   }
1562 }
1563 
1564 // ------------------------------------------------------------------
1565 // post_compiled_method_load_event
1566 // new method for install_code() path
1567 // Transfer information from compilation to jvmti
<a name="78" id="anc78"></a><span class="line-modified">1568 void nmethod::post_compiled_method_load_event(JvmtiThreadState* state) {</span>
<span class="line-added">1569 </span>
<span class="line-added">1570   // Don&#39;t post this nmethod load event if it is already dying</span>
<span class="line-added">1571   // because the sweeper might already be deleting this nmethod.</span>
<span class="line-added">1572   if (is_not_entrant() &amp;&amp; can_convert_to_zombie()) {</span>
<span class="line-added">1573     return;</span>
<span class="line-added">1574   }</span>
1575 
<a name="79" id="anc79"></a><span class="line-modified">1576   // This is a bad time for a safepoint.  We don&#39;t want</span>
<span class="line-added">1577   // this nmethod to get unloaded while we&#39;re queueing the event.</span>
<span class="line-added">1578   NoSafepointVerifier nsv;</span>
<span class="line-added">1579 </span>
<span class="line-added">1580   Method* m = method();</span>
1581   HOTSPOT_COMPILED_METHOD_LOAD(
<a name="80" id="anc80"></a><span class="line-modified">1582       (char *) m-&gt;klass_name()-&gt;bytes(),</span>
<span class="line-modified">1583       m-&gt;klass_name()-&gt;utf8_length(),</span>
<span class="line-modified">1584       (char *) m-&gt;name()-&gt;bytes(),</span>
<span class="line-modified">1585       m-&gt;name()-&gt;utf8_length(),</span>
<span class="line-modified">1586       (char *) m-&gt;signature()-&gt;bytes(),</span>
<span class="line-modified">1587       m-&gt;signature()-&gt;utf8_length(),</span>
1588       insts_begin(), insts_size());
1589 
<a name="81" id="anc81"></a>



1590 
1591   if (JvmtiExport::should_post_compiled_method_load()) {
<a name="82" id="anc82"></a><span class="line-modified">1592     // Only post unload events if load events are found.</span>
<span class="line-modified">1593     set_load_reported();</span>
<span class="line-modified">1594     // If a JavaThread hasn&#39;t been passed in, let the Service thread</span>
<span class="line-modified">1595     // (which is a real Java thread) post the event</span>
<span class="line-modified">1596     JvmtiDeferredEvent event = JvmtiDeferredEvent::compiled_method_load_event(this);</span>
<span class="line-modified">1597     if (state == NULL) {</span>
<span class="line-modified">1598       // Execute any barrier code for this nmethod as if it&#39;s called, since</span>
<span class="line-modified">1599       // keeping it alive looks like stack walking.</span>
<span class="line-modified">1600       run_nmethod_entry_barrier();</span>
<span class="line-modified">1601       ServiceThread::enqueue_deferred_event(&amp;event);</span>
<span class="line-modified">1602     } else {</span>
<span class="line-modified">1603       // This enters the nmethod barrier outside in the caller.</span>
<span class="line-added">1604       state-&gt;enqueue_event(&amp;event);</span>
<span class="line-added">1605     }</span>
1606   }
<a name="83" id="anc83"></a>
1607 }
1608 
1609 void nmethod::post_compiled_method_unload() {
1610   if (unload_reported()) {
1611     // During unloading we transition to unloaded and then to zombie
1612     // and the unloading is reported during the first transition.
1613     return;
1614   }
1615 
1616   assert(_method != NULL &amp;&amp; !is_unloaded(), &quot;just checking&quot;);
1617   DTRACE_METHOD_UNLOAD_PROBE(method());
1618 
1619   // If a JVMTI agent has enabled the CompiledMethodUnload event then
1620   // post the event. Sometime later this nmethod will be made a zombie
1621   // by the sweeper but the Method* will not be valid at that point.
<a name="84" id="anc84"></a><span class="line-modified">1622   // The jmethodID is a weak reference to the Method* so if</span>


1623   // it&#39;s being unloaded there&#39;s no way to look it up since the weak
1624   // ref will have been cleared.
<a name="85" id="anc85"></a><span class="line-modified">1625 </span>
<span class="line-added">1626   // Don&#39;t bother posting the unload if the load event wasn&#39;t posted.</span>
<span class="line-added">1627   if (load_reported() &amp;&amp; JvmtiExport::should_post_compiled_method_unload()) {</span>
1628     assert(!unload_reported(), &quot;already unloaded&quot;);
1629     JvmtiDeferredEvent event =
<a name="86" id="anc86"></a><span class="line-modified">1630       JvmtiDeferredEvent::compiled_method_unload_event(</span>
<span class="line-modified">1631           method()-&gt;jmethod_id(), insts_begin());</span>
<span class="line-modified">1632     ServiceThread::enqueue_deferred_event(&amp;event);</span>

1633   }
1634 
1635   // The JVMTI CompiledMethodUnload event can be enabled or disabled at
1636   // any time. As the nmethod is being unloaded now we mark it has
1637   // having the unload event reported - this will ensure that we don&#39;t
1638   // attempt to report the event in the unlikely scenario where the
1639   // event is enabled at the time the nmethod is made a zombie.
1640   set_unload_reported();
1641 }
1642 
1643 // Iterate over metadata calling this function.   Used by RedefineClasses
<a name="87" id="anc87"></a><span class="line-modified">1644 void nmethod::metadata_do(MetadataClosure* f) {</span>
1645   {
1646     // Visit all immediate references that are embedded in the instruction stream.
1647     RelocIterator iter(this, oops_reloc_begin());
1648     while (iter.next()) {
<a name="88" id="anc88"></a><span class="line-modified">1649       if (iter.type() == relocInfo::metadata_type) {</span>
1650         metadata_Relocation* r = iter.metadata_reloc();
1651         // In this metadata, we must only follow those metadatas directly embedded in
1652         // the code.  Other metadatas (oop_index&gt;0) are seen as part of
1653         // the metadata section below.
1654         assert(1 == (r-&gt;metadata_is_immediate()) +
1655                (r-&gt;metadata_addr() &gt;= metadata_begin() &amp;&amp; r-&gt;metadata_addr() &lt; metadata_end()),
1656                &quot;metadata must be found in exactly one place&quot;);
1657         if (r-&gt;metadata_is_immediate() &amp;&amp; r-&gt;metadata_value() != NULL) {
1658           Metadata* md = r-&gt;metadata_value();
<a name="89" id="anc89"></a><span class="line-modified">1659           if (md != _method) f-&gt;do_metadata(md);</span>
1660         }
1661       } else if (iter.type() == relocInfo::virtual_call_type) {
1662         // Check compiledIC holders associated with this nmethod
1663         ResourceMark rm;
1664         CompiledIC *ic = CompiledIC_at(&amp;iter);
1665         if (ic-&gt;is_icholder_call()) {
1666           CompiledICHolder* cichk = ic-&gt;cached_icholder();
<a name="90" id="anc90"></a><span class="line-modified">1667           f-&gt;do_metadata(cichk-&gt;holder_metadata());</span>
<span class="line-modified">1668           f-&gt;do_metadata(cichk-&gt;holder_klass());</span>
1669         } else {
1670           Metadata* ic_oop = ic-&gt;cached_metadata();
1671           if (ic_oop != NULL) {
<a name="91" id="anc91"></a><span class="line-modified">1672             f-&gt;do_metadata(ic_oop);</span>
1673           }
1674         }
1675       }
1676     }
1677   }
1678 
1679   // Visit the metadata section
1680   for (Metadata** p = metadata_begin(); p &lt; metadata_end(); p++) {
1681     if (*p == Universe::non_oop_word() || *p == NULL)  continue;  // skip non-oops
1682     Metadata* md = *p;
<a name="92" id="anc92"></a><span class="line-modified">1683     f-&gt;do_metadata(md);</span>
1684   }
1685 
1686   // Visit metadata not embedded in the other places.
<a name="93" id="anc93"></a><span class="line-modified">1687   if (_method != NULL) f-&gt;do_metadata(_method);</span>
1688 }
1689 
1690 // The _is_unloading_state encodes a tuple comprising the unloading cycle
1691 // and the result of IsUnloadingBehaviour::is_unloading() fpr that cycle.
1692 // This is the bit layout of the _is_unloading_state byte: 00000CCU
1693 // CC refers to the cycle, which has 2 bits, and U refers to the result of
1694 // IsUnloadingBehaviour::is_unloading() for that unloading cycle.
1695 
1696 class IsUnloadingState: public AllStatic {
1697   static const uint8_t _is_unloading_mask = 1;
1698   static const uint8_t _is_unloading_shift = 0;
1699   static const uint8_t _unloading_cycle_mask = 6;
1700   static const uint8_t _unloading_cycle_shift = 1;
1701 
1702   static uint8_t set_is_unloading(uint8_t state, bool value) {
1703     state &amp;= ~_is_unloading_mask;
1704     if (value) {
1705       state |= 1 &lt;&lt; _is_unloading_shift;
1706     }
1707     assert(is_unloading(state) == value, &quot;unexpected unloading cycle overflow&quot;);
1708     return state;
1709   }
1710 
1711   static uint8_t set_unloading_cycle(uint8_t state, uint8_t value) {
1712     state &amp;= ~_unloading_cycle_mask;
1713     state |= value &lt;&lt; _unloading_cycle_shift;
1714     assert(unloading_cycle(state) == value, &quot;unexpected unloading cycle overflow&quot;);
1715     return state;
1716   }
1717 
1718 public:
1719   static bool is_unloading(uint8_t state) { return (state &amp; _is_unloading_mask) &gt;&gt; _is_unloading_shift == 1; }
1720   static uint8_t unloading_cycle(uint8_t state) { return (state &amp; _unloading_cycle_mask) &gt;&gt; _unloading_cycle_shift; }
1721 
1722   static uint8_t create(bool is_unloading, uint8_t unloading_cycle) {
1723     uint8_t state = 0;
1724     state = set_is_unloading(state, is_unloading);
1725     state = set_unloading_cycle(state, unloading_cycle);
1726     return state;
1727   }
1728 };
1729 
1730 bool nmethod::is_unloading() {
1731   uint8_t state = RawAccess&lt;MO_RELAXED&gt;::load(&amp;_is_unloading_state);
1732   bool state_is_unloading = IsUnloadingState::is_unloading(state);
1733   uint8_t state_unloading_cycle = IsUnloadingState::unloading_cycle(state);
1734   if (state_is_unloading) {
1735     return true;
1736   }
1737   uint8_t current_cycle = CodeCache::unloading_cycle();
1738   if (state_unloading_cycle == current_cycle) {
1739     return false;
1740   }
1741 
1742   // The IsUnloadingBehaviour is responsible for checking if there are any dead
1743   // oops in the CompiledMethod, by calling oops_do on it.
1744   state_unloading_cycle = current_cycle;
1745 
1746   if (is_zombie()) {
1747     // Zombies without calculated unloading epoch are never unloading due to GC.
1748 
1749     // There are no races where a previously observed is_unloading() nmethod
1750     // suddenly becomes not is_unloading() due to here being observed as zombie.
1751 
1752     // With STW unloading, all is_alive() &amp;&amp; is_unloading() nmethods are unlinked
1753     // and unloaded in the safepoint. That makes races where an nmethod is first
1754     // observed as is_alive() &amp;&amp; is_unloading() and subsequently observed as
1755     // is_zombie() impossible.
1756 
1757     // With concurrent unloading, all references to is_unloading() nmethods are
1758     // first unlinked (e.g. IC caches and dependency contexts). Then a global
1759     // handshake operation is performed with all JavaThreads before finally
1760     // unloading the nmethods. The sweeper never converts is_alive() &amp;&amp; is_unloading()
1761     // nmethods to zombies; it waits for them to become is_unloaded(). So before
1762     // the global handshake, it is impossible for is_unloading() nmethods to
1763     // racingly become is_zombie(). And is_unloading() is calculated for all is_alive()
1764     // nmethods before taking that global handshake, meaning that it will never
1765     // be recalculated after the handshake.
1766 
1767     // After that global handshake, is_unloading() nmethods are only observable
1768     // to the iterators, and they will never trigger recomputation of the cached
1769     // is_unloading_state, and hence may not suffer from such races.
1770 
1771     state_is_unloading = false;
1772   } else {
1773     state_is_unloading = IsUnloadingBehaviour::current()-&gt;is_unloading(this);
1774   }
1775 
1776   state = IsUnloadingState::create(state_is_unloading, state_unloading_cycle);
1777 
1778   RawAccess&lt;MO_RELAXED&gt;::store(&amp;_is_unloading_state, state);
1779 
1780   return state_is_unloading;
1781 }
1782 
1783 void nmethod::clear_unloading_state() {
1784   uint8_t state = IsUnloadingState::create(false, CodeCache::unloading_cycle());
1785   RawAccess&lt;MO_RELAXED&gt;::store(&amp;_is_unloading_state, state);
1786 }
1787 
1788 
1789 // This is called at the end of the strong tracing/marking phase of a
1790 // GC to unload an nmethod if it contains otherwise unreachable
1791 // oops.
1792 
1793 void nmethod::do_unloading(bool unloading_occurred) {
1794   // Make sure the oop&#39;s ready to receive visitors
1795   assert(!is_zombie() &amp;&amp; !is_unloaded(),
1796          &quot;should not call follow on zombie or unloaded nmethod&quot;);
1797 
1798   if (is_unloading()) {
1799     make_unloaded();
1800   } else {
<a name="94" id="anc94"></a>










1801     guarantee(unload_nmethod_caches(unloading_occurred),
1802               &quot;Should not need transition stubs&quot;);
1803   }
1804 }
1805 
<a name="95" id="anc95"></a><span class="line-modified">1806 void nmethod::oops_do(OopClosure* f, bool allow_dead) {</span>
1807   // make sure the oops ready to receive visitors
<a name="96" id="anc96"></a><span class="line-modified">1808   assert(allow_dead || is_alive(), &quot;should not call follow on dead nmethod&quot;);</span>

1809 
1810   // Prevent extra code cache walk for platforms that don&#39;t have immediate oops.
1811   if (relocInfo::mustIterateImmediateOopsInCode()) {
1812     RelocIterator iter(this, oops_reloc_begin());
1813 
1814     while (iter.next()) {
1815       if (iter.type() == relocInfo::oop_type ) {
1816         oop_Relocation* r = iter.oop_reloc();
1817         // In this loop, we must only follow those oops directly embedded in
1818         // the code.  Other oops (oop_index&gt;0) are seen as part of scopes_oops.
1819         assert(1 == (r-&gt;oop_is_immediate()) +
1820                (r-&gt;oop_addr() &gt;= oops_begin() &amp;&amp; r-&gt;oop_addr() &lt; oops_end()),
1821                &quot;oop must be found in exactly one place&quot;);
1822         if (r-&gt;oop_is_immediate() &amp;&amp; r-&gt;oop_value() != NULL) {
1823           f-&gt;do_oop(r-&gt;oop_addr());
1824         }
1825       }
1826     }
1827   }
1828 
1829   // Scopes
1830   // This includes oop constants not inlined in the code stream.
1831   for (oop* p = oops_begin(); p &lt; oops_end(); p++) {
1832     if (*p == Universe::non_oop_word())  continue;  // skip non-oops
1833     f-&gt;do_oop(p);
1834   }
1835 }
1836 
<a name="97" id="anc97"></a>

1837 nmethod* volatile nmethod::_oops_do_mark_nmethods;
1838 
<a name="98" id="anc98"></a><span class="line-modified">1839 void nmethod::oops_do_log_change(const char* state) {</span>
<span class="line-modified">1840   LogTarget(Trace, gc, nmethod) lt;</span>
<span class="line-modified">1841   if (lt.is_enabled()) {</span>
<span class="line-modified">1842     LogStream ls(lt);</span>
<span class="line-modified">1843     CompileTask::print(&amp;ls, this, state, true /* short_form */);</span>
<span class="line-modified">1844   }</span>
<span class="line-modified">1845 }</span>
<span class="line-modified">1846 </span>
<span class="line-modified">1847 bool nmethod::oops_do_try_claim() {</span>
<span class="line-modified">1848   if (oops_do_try_claim_weak_request()) {</span>
<span class="line-modified">1849     nmethod* result = oops_do_try_add_to_list_as_weak_done();</span>
<span class="line-modified">1850     assert(result == NULL, &quot;adding to global list as weak done must always succeed.&quot;);</span>
<span class="line-modified">1851     return true;</span>
<span class="line-modified">1852   }</span>
<span class="line-modified">1853   return false;</span>
<span class="line-modified">1854 }</span>
<span class="line-modified">1855 </span>
<span class="line-modified">1856 bool nmethod::oops_do_try_claim_weak_request() {</span>
<span class="line-modified">1857   assert(SafepointSynchronize::is_at_safepoint(), &quot;only at safepoint&quot;);</span>
<span class="line-modified">1858 </span>
<span class="line-modified">1859   if ((_oops_do_mark_link == NULL) &amp;&amp;</span>
<span class="line-modified">1860       (Atomic::replace_if_null(&amp;_oops_do_mark_link, mark_link(this, claim_weak_request_tag)))) {</span>
<span class="line-modified">1861     oops_do_log_change(&quot;oops_do, mark weak request&quot;);</span>
<span class="line-modified">1862     return true;</span>
<span class="line-modified">1863   }</span>
<span class="line-modified">1864   return false;</span>
<span class="line-added">1865 }</span>
<span class="line-added">1866 </span>
<span class="line-added">1867 void nmethod::oops_do_set_strong_done(nmethod* old_head) {</span>
<span class="line-added">1868   _oops_do_mark_link = mark_link(old_head, claim_strong_done_tag);</span>
<span class="line-added">1869 }</span>
<span class="line-added">1870 </span>
<span class="line-added">1871 nmethod::oops_do_mark_link* nmethod::oops_do_try_claim_strong_done() {</span>
<span class="line-added">1872   assert(SafepointSynchronize::is_at_safepoint(), &quot;only at safepoint&quot;);</span>
<span class="line-added">1873 </span>
<span class="line-added">1874   oops_do_mark_link* old_next = Atomic::cmpxchg(&amp;_oops_do_mark_link, mark_link(NULL, claim_weak_request_tag), mark_link(this, claim_strong_done_tag));</span>
<span class="line-added">1875   if (old_next == NULL) {</span>
<span class="line-added">1876     oops_do_log_change(&quot;oops_do, mark strong done&quot;);</span>
<span class="line-added">1877   }</span>
<span class="line-added">1878   return old_next;</span>
<span class="line-added">1879 }</span>
<span class="line-added">1880 </span>
<span class="line-added">1881 nmethod::oops_do_mark_link* nmethod::oops_do_try_add_strong_request(nmethod::oops_do_mark_link* next) {</span>
<span class="line-added">1882   assert(SafepointSynchronize::is_at_safepoint(), &quot;only at safepoint&quot;);</span>
<span class="line-added">1883   assert(next == mark_link(this, claim_weak_request_tag), &quot;Should be claimed as weak&quot;);</span>
<span class="line-added">1884 </span>
<span class="line-added">1885   oops_do_mark_link* old_next = Atomic::cmpxchg(&amp;_oops_do_mark_link, next, mark_link(this, claim_strong_request_tag));</span>
<span class="line-added">1886   if (old_next == next) {</span>
<span class="line-added">1887     oops_do_log_change(&quot;oops_do, mark strong request&quot;);</span>
<span class="line-added">1888   }</span>
<span class="line-added">1889   return old_next;</span>
<span class="line-added">1890 }</span>
<span class="line-added">1891 </span>
<span class="line-added">1892 bool nmethod::oops_do_try_claim_weak_done_as_strong_done(nmethod::oops_do_mark_link* next) {</span>
<span class="line-added">1893   assert(SafepointSynchronize::is_at_safepoint(), &quot;only at safepoint&quot;);</span>
<span class="line-added">1894   assert(extract_state(next) == claim_weak_done_tag, &quot;Should be claimed as weak done&quot;);</span>
<span class="line-added">1895 </span>
<span class="line-added">1896   oops_do_mark_link* old_next = Atomic::cmpxchg(&amp;_oops_do_mark_link, next, mark_link(extract_nmethod(next), claim_strong_done_tag));</span>
<span class="line-added">1897   if (old_next == next) {</span>
<span class="line-added">1898     oops_do_log_change(&quot;oops_do, mark weak done -&gt; mark strong done&quot;);</span>
<span class="line-added">1899     return true;</span>
<span class="line-added">1900   }</span>
<span class="line-added">1901   return false;</span>
<span class="line-added">1902 }</span>
<span class="line-added">1903 </span>
<span class="line-added">1904 nmethod* nmethod::oops_do_try_add_to_list_as_weak_done() {</span>
<span class="line-added">1905   assert(SafepointSynchronize::is_at_safepoint(), &quot;only at safepoint&quot;);</span>
<span class="line-added">1906 </span>
<span class="line-added">1907   assert(extract_state(_oops_do_mark_link) == claim_weak_request_tag ||</span>
<span class="line-added">1908          extract_state(_oops_do_mark_link) == claim_strong_request_tag,</span>
<span class="line-added">1909          &quot;must be but is nmethod &quot; PTR_FORMAT &quot; %u&quot;, p2i(extract_nmethod(_oops_do_mark_link)), extract_state(_oops_do_mark_link));</span>
<span class="line-added">1910 </span>
<span class="line-added">1911   nmethod* old_head = Atomic::xchg(&amp;_oops_do_mark_nmethods, this);</span>
<span class="line-added">1912   // Self-loop if needed.</span>
<span class="line-added">1913   if (old_head == NULL) {</span>
<span class="line-added">1914     old_head = this;</span>
<span class="line-added">1915   }</span>
<span class="line-added">1916   // Try to install end of list and weak done tag.</span>
<span class="line-added">1917   if (Atomic::cmpxchg(&amp;_oops_do_mark_link, mark_link(this, claim_weak_request_tag), mark_link(old_head, claim_weak_done_tag)) == mark_link(this, claim_weak_request_tag)) {</span>
<span class="line-added">1918     oops_do_log_change(&quot;oops_do, mark weak done&quot;);</span>
<span class="line-added">1919     return NULL;</span>
<span class="line-added">1920   } else {</span>
<span class="line-added">1921     return old_head;</span>
<span class="line-added">1922   }</span>
<span class="line-added">1923 }</span>
<span class="line-added">1924 </span>
<span class="line-added">1925 void nmethod::oops_do_add_to_list_as_strong_done() {</span>
<span class="line-added">1926   assert(SafepointSynchronize::is_at_safepoint(), &quot;only at safepoint&quot;);</span>
<span class="line-added">1927 </span>
<span class="line-added">1928   nmethod* old_head = Atomic::xchg(&amp;_oops_do_mark_nmethods, this);</span>
<span class="line-added">1929   // Self-loop if needed.</span>
<span class="line-added">1930   if (old_head == NULL) {</span>
<span class="line-added">1931     old_head = this;</span>
<span class="line-added">1932   }</span>
<span class="line-added">1933   assert(_oops_do_mark_link == mark_link(this, claim_strong_done_tag), &quot;must be but is nmethod &quot; PTR_FORMAT &quot; state %u&quot;,</span>
<span class="line-added">1934          p2i(extract_nmethod(_oops_do_mark_link)), extract_state(_oops_do_mark_link));</span>
<span class="line-added">1935 </span>
<span class="line-added">1936   oops_do_set_strong_done(old_head);</span>
<span class="line-added">1937 }</span>
<span class="line-added">1938 </span>
<span class="line-added">1939 void nmethod::oops_do_process_weak(OopsDoProcessor* p) {</span>
<span class="line-added">1940   if (!oops_do_try_claim_weak_request()) {</span>
<span class="line-added">1941     // Failed to claim for weak processing.</span>
<span class="line-added">1942     oops_do_log_change(&quot;oops_do, mark weak request fail&quot;);</span>
<span class="line-added">1943     return;</span>
<span class="line-added">1944   }</span>
<span class="line-added">1945 </span>
<span class="line-added">1946   p-&gt;do_regular_processing(this);</span>
<span class="line-added">1947 </span>
<span class="line-added">1948   nmethod* old_head = oops_do_try_add_to_list_as_weak_done();</span>
<span class="line-added">1949   if (old_head == NULL) {</span>
<span class="line-added">1950     return;</span>
<span class="line-added">1951   }</span>
<span class="line-added">1952   oops_do_log_change(&quot;oops_do, mark weak done fail&quot;);</span>
<span class="line-added">1953   // Adding to global list failed, another thread added a strong request.</span>
<span class="line-added">1954   assert(extract_state(_oops_do_mark_link) == claim_strong_request_tag,</span>
<span class="line-added">1955          &quot;must be but is %u&quot;, extract_state(_oops_do_mark_link));</span>
<span class="line-added">1956 </span>
<span class="line-added">1957   oops_do_log_change(&quot;oops_do, mark weak request -&gt; mark strong done&quot;);</span>
<span class="line-added">1958 </span>
<span class="line-added">1959   oops_do_set_strong_done(old_head);</span>
<span class="line-added">1960   // Do missing strong processing.</span>
<span class="line-added">1961   p-&gt;do_remaining_strong_processing(this);</span>
<span class="line-added">1962 }</span>
<span class="line-added">1963 </span>
<span class="line-added">1964 void nmethod::oops_do_process_strong(OopsDoProcessor* p) {</span>
<span class="line-added">1965   oops_do_mark_link* next_raw = oops_do_try_claim_strong_done();</span>
<span class="line-added">1966   if (next_raw == NULL) {</span>
<span class="line-added">1967     p-&gt;do_regular_processing(this);</span>
<span class="line-added">1968     oops_do_add_to_list_as_strong_done();</span>
<span class="line-added">1969     return;</span>
<span class="line-added">1970   }</span>
<span class="line-added">1971   // Claim failed. Figure out why and handle it.</span>
<span class="line-added">1972   if (oops_do_has_weak_request(next_raw)) {</span>
<span class="line-added">1973     oops_do_mark_link* old = next_raw;</span>
<span class="line-added">1974     // Claim failed because being weak processed (state == &quot;weak request&quot;).</span>
<span class="line-added">1975     // Try to request deferred strong processing.</span>
<span class="line-added">1976     next_raw = oops_do_try_add_strong_request(old);</span>
<span class="line-added">1977     if (next_raw == old) {</span>
<span class="line-added">1978       // Successfully requested deferred strong processing.</span>
<span class="line-added">1979       return;</span>
1980     }
<a name="99" id="anc99"></a><span class="line-added">1981     // Failed because of a concurrent transition. No longer in &quot;weak request&quot; state.</span>
1982   }
<a name="100" id="anc100"></a><span class="line-modified">1983   if (oops_do_has_any_strong_state(next_raw)) {</span>
<span class="line-modified">1984     // Already claimed for strong processing or requested for such.</span>
<span class="line-added">1985     return;</span>
<span class="line-added">1986   }</span>
<span class="line-added">1987   if (oops_do_try_claim_weak_done_as_strong_done(next_raw)) {</span>
<span class="line-added">1988     // Successfully claimed &quot;weak done&quot; as &quot;strong done&quot;. Do the missing marking.</span>
<span class="line-added">1989     p-&gt;do_remaining_strong_processing(this);</span>
<span class="line-added">1990     return;</span>
<span class="line-added">1991   }</span>
<span class="line-added">1992   // Claim failed, some other thread got it.</span>
1993 }
1994 
1995 void nmethod::oops_do_marking_prologue() {
<a name="101" id="anc101"></a><span class="line-added">1996   assert_at_safepoint();</span>
<span class="line-added">1997 </span>
1998   log_trace(gc, nmethod)(&quot;oops_do_marking_prologue&quot;);
<a name="102" id="anc102"></a><span class="line-modified">1999   assert(_oops_do_mark_nmethods == NULL, &quot;must be empty&quot;);</span>




2000 }
2001 
2002 void nmethod::oops_do_marking_epilogue() {
<a name="103" id="anc103"></a><span class="line-modified">2003   assert_at_safepoint();</span>
<span class="line-modified">2004 </span>
<span class="line-modified">2005   nmethod* next = _oops_do_mark_nmethods;</span>
<span class="line-modified">2006   _oops_do_mark_nmethods = NULL;</span>
<span class="line-modified">2007   if (next == NULL) {</span>
<span class="line-added">2008     return;</span>
<span class="line-added">2009   }</span>
<span class="line-added">2010   nmethod* cur;</span>
<span class="line-added">2011   do {</span>
<span class="line-added">2012     cur = next;</span>
<span class="line-added">2013     next = extract_nmethod(cur-&gt;_oops_do_mark_link);</span>
2014     cur-&gt;_oops_do_mark_link = NULL;
2015     DEBUG_ONLY(cur-&gt;verify_oop_relocations());
2016 
2017     LogTarget(Trace, gc, nmethod) lt;
2018     if (lt.is_enabled()) {
2019       LogStream ls(lt);
2020       CompileTask::print(&amp;ls, cur, &quot;oops_do, unmark&quot;, /*short_form:*/ true);
2021     }
<a name="104" id="anc104"></a><span class="line-modified">2022     // End if self-loop has been detected.</span>
<span class="line-modified">2023   } while (cur != next);</span>



2024   log_trace(gc, nmethod)(&quot;oops_do_marking_epilogue&quot;);
2025 }
2026 
2027 inline bool includes(void* p, void* from, void* to) {
2028   return from &lt;= p &amp;&amp; p &lt; to;
2029 }
2030 
2031 
2032 void nmethod::copy_scopes_pcs(PcDesc* pcs, int count) {
2033   assert(count &gt;= 2, &quot;must be sentinel values, at least&quot;);
2034 
2035 #ifdef ASSERT
2036   // must be sorted and unique; we do a binary search in find_pc_desc()
2037   int prev_offset = pcs[0].pc_offset();
2038   assert(prev_offset == PcDesc::lower_offset_limit,
2039          &quot;must start with a sentinel&quot;);
2040   for (int i = 1; i &lt; count; i++) {
2041     int this_offset = pcs[i].pc_offset();
2042     assert(this_offset &gt; prev_offset, &quot;offsets must be sorted&quot;);
2043     prev_offset = this_offset;
2044   }
2045   assert(prev_offset == PcDesc::upper_offset_limit,
2046          &quot;must end with a sentinel&quot;);
2047 #endif //ASSERT
2048 
2049   // Search for MethodHandle invokes and tag the nmethod.
2050   for (int i = 0; i &lt; count; i++) {
2051     if (pcs[i].is_method_handle_invoke()) {
2052       set_has_method_handle_invokes(true);
2053       break;
2054     }
2055   }
2056   assert(has_method_handle_invokes() == (_deopt_mh_handler_begin != NULL), &quot;must have deopt mh handler&quot;);
2057 
2058   int size = count * sizeof(PcDesc);
2059   assert(scopes_pcs_size() &gt;= size, &quot;oob&quot;);
2060   memcpy(scopes_pcs_begin(), pcs, size);
2061 
2062   // Adjust the final sentinel downward.
2063   PcDesc* last_pc = &amp;scopes_pcs_begin()[count-1];
2064   assert(last_pc-&gt;pc_offset() == PcDesc::upper_offset_limit, &quot;sanity&quot;);
2065   last_pc-&gt;set_pc_offset(content_size() + 1);
2066   for (; last_pc + 1 &lt; scopes_pcs_end(); last_pc += 1) {
2067     // Fill any rounding gaps with copies of the last record.
2068     last_pc[1] = last_pc[0];
2069   }
2070   // The following assert could fail if sizeof(PcDesc) is not
2071   // an integral multiple of oopSize (the rounding term).
2072   // If it fails, change the logic to always allocate a multiple
2073   // of sizeof(PcDesc), and fill unused words with copies of *last_pc.
2074   assert(last_pc + 1 == scopes_pcs_end(), &quot;must match exactly&quot;);
2075 }
2076 
2077 void nmethod::copy_scopes_data(u_char* buffer, int size) {
2078   assert(scopes_data_size() &gt;= size, &quot;oob&quot;);
2079   memcpy(scopes_data_begin(), buffer, size);
2080 }
2081 
2082 #ifdef ASSERT
2083 static PcDesc* linear_search(const PcDescSearch&amp; search, int pc_offset, bool approximate) {
2084   PcDesc* lower = search.scopes_pcs_begin();
2085   PcDesc* upper = search.scopes_pcs_end();
2086   lower += 1; // exclude initial sentinel
2087   PcDesc* res = NULL;
2088   for (PcDesc* p = lower; p &lt; upper; p++) {
2089     NOT_PRODUCT(--pc_nmethod_stats.pc_desc_tests);  // don&#39;t count this call to match_desc
2090     if (match_desc(p, pc_offset, approximate)) {
2091       if (res == NULL)
2092         res = p;
2093       else
2094         res = (PcDesc*) badAddress;
2095     }
2096   }
2097   return res;
2098 }
2099 #endif
2100 
2101 
2102 // Finds a PcDesc with real-pc equal to &quot;pc&quot;
2103 PcDesc* PcDescContainer::find_pc_desc_internal(address pc, bool approximate, const PcDescSearch&amp; search) {
2104   address base_address = search.code_begin();
2105   if ((pc &lt; base_address) ||
2106       (pc - base_address) &gt;= (ptrdiff_t) PcDesc::upper_offset_limit) {
2107     return NULL;  // PC is wildly out of range
2108   }
2109   int pc_offset = (int) (pc - base_address);
2110 
2111   // Check the PcDesc cache if it contains the desired PcDesc
2112   // (This as an almost 100% hit rate.)
2113   PcDesc* res = _pc_desc_cache.find_pc_desc(pc_offset, approximate);
2114   if (res != NULL) {
2115     assert(res == linear_search(search, pc_offset, approximate), &quot;cache ok&quot;);
2116     return res;
2117   }
2118 
2119   // Fallback algorithm: quasi-linear search for the PcDesc
2120   // Find the last pc_offset less than the given offset.
2121   // The successor must be the required match, if there is a match at all.
2122   // (Use a fixed radix to avoid expensive affine pointer arithmetic.)
2123   PcDesc* lower = search.scopes_pcs_begin();
2124   PcDesc* upper = search.scopes_pcs_end();
2125   upper -= 1; // exclude final sentinel
2126   if (lower &gt;= upper)  return NULL;  // native method; no PcDescs at all
2127 
2128 #define assert_LU_OK \
2129   /* invariant on lower..upper during the following search: */ \
2130   assert(lower-&gt;pc_offset() &lt;  pc_offset, &quot;sanity&quot;); \
2131   assert(upper-&gt;pc_offset() &gt;= pc_offset, &quot;sanity&quot;)
2132   assert_LU_OK;
2133 
2134   // Use the last successful return as a split point.
2135   PcDesc* mid = _pc_desc_cache.last_pc_desc();
2136   NOT_PRODUCT(++pc_nmethod_stats.pc_desc_searches);
2137   if (mid-&gt;pc_offset() &lt; pc_offset) {
2138     lower = mid;
2139   } else {
2140     upper = mid;
2141   }
2142 
2143   // Take giant steps at first (4096, then 256, then 16, then 1)
2144   const int LOG2_RADIX = 4 /*smaller steps in debug mode:*/ debug_only(-1);
2145   const int RADIX = (1 &lt;&lt; LOG2_RADIX);
2146   for (int step = (1 &lt;&lt; (LOG2_RADIX*3)); step &gt; 1; step &gt;&gt;= LOG2_RADIX) {
2147     while ((mid = lower + step) &lt; upper) {
2148       assert_LU_OK;
2149       NOT_PRODUCT(++pc_nmethod_stats.pc_desc_searches);
2150       if (mid-&gt;pc_offset() &lt; pc_offset) {
2151         lower = mid;
2152       } else {
2153         upper = mid;
2154         break;
2155       }
2156     }
2157     assert_LU_OK;
2158   }
2159 
2160   // Sneak up on the value with a linear search of length ~16.
2161   while (true) {
2162     assert_LU_OK;
2163     mid = lower + 1;
2164     NOT_PRODUCT(++pc_nmethod_stats.pc_desc_searches);
2165     if (mid-&gt;pc_offset() &lt; pc_offset) {
2166       lower = mid;
2167     } else {
2168       upper = mid;
2169       break;
2170     }
2171   }
2172 #undef assert_LU_OK
2173 
2174   if (match_desc(upper, pc_offset, approximate)) {
2175     assert(upper == linear_search(search, pc_offset, approximate), &quot;search ok&quot;);
2176     _pc_desc_cache.add_pc_desc(upper);
2177     return upper;
2178   } else {
2179     assert(NULL == linear_search(search, pc_offset, approximate), &quot;search ok&quot;);
2180     return NULL;
2181   }
2182 }
2183 
2184 
2185 void nmethod::check_all_dependencies(DepChange&amp; changes) {
2186   // Checked dependencies are allocated into this ResourceMark
2187   ResourceMark rm;
2188 
2189   // Turn off dependency tracing while actually testing dependencies.
2190   NOT_PRODUCT( FlagSetting fs(TraceDependencies, false) );
2191 
2192   typedef ResourceHashtable&lt;DependencySignature, int, &amp;DependencySignature::hash,
2193                             &amp;DependencySignature::equals, 11027&gt; DepTable;
2194 
2195   DepTable* table = new DepTable();
2196 
2197   // Iterate over live nmethods and check dependencies of all nmethods that are not
2198   // marked for deoptimization. A particular dependency is only checked once.
2199   NMethodIterator iter(NMethodIterator::only_alive_and_not_unloading);
2200   while(iter.next()) {
2201     nmethod* nm = iter.method();
2202     // Only notify for live nmethods
2203     if (!nm-&gt;is_marked_for_deoptimization()) {
2204       for (Dependencies::DepStream deps(nm); deps.next(); ) {
2205         // Construct abstraction of a dependency.
2206         DependencySignature* current_sig = new DependencySignature(deps);
2207 
2208         // Determine if dependency is already checked. table-&gt;put(...) returns
2209         // &#39;true&#39; if the dependency is added (i.e., was not in the hashtable).
2210         if (table-&gt;put(*current_sig, 1)) {
2211           if (deps.check_dependency() != NULL) {
2212             // Dependency checking failed. Print out information about the failed
2213             // dependency and finally fail with an assert. We can fail here, since
2214             // dependency checking is never done in a product build.
2215             tty-&gt;print_cr(&quot;Failed dependency:&quot;);
2216             changes.print();
2217             nm-&gt;print();
2218             nm-&gt;print_dependencies();
2219             assert(false, &quot;Should have been marked for deoptimization&quot;);
2220           }
2221         }
2222       }
2223     }
2224   }
2225 }
2226 
2227 bool nmethod::check_dependency_on(DepChange&amp; changes) {
2228   // What has happened:
2229   // 1) a new class dependee has been added
2230   // 2) dependee and all its super classes have been marked
2231   bool found_check = false;  // set true if we are upset
2232   for (Dependencies::DepStream deps(this); deps.next(); ) {
2233     // Evaluate only relevant dependencies.
2234     if (deps.spot_check_dependency_at(changes) != NULL) {
2235       found_check = true;
2236       NOT_DEBUG(break);
2237     }
2238   }
2239   return found_check;
2240 }
2241 
<a name="105" id="anc105"></a>

























2242 // Called from mark_for_deoptimization, when dependee is invalidated.
2243 bool nmethod::is_dependent_on_method(Method* dependee) {
2244   for (Dependencies::DepStream deps(this); deps.next(); ) {
2245     if (deps.type() != Dependencies::evol_method)
2246       continue;
2247     Method* method = deps.method_argument(0);
2248     if (method == dependee) return true;
2249   }
2250   return false;
2251 }
2252 
2253 
2254 bool nmethod::is_patchable_at(address instr_addr) {
2255   assert(insts_contains(instr_addr), &quot;wrong nmethod used&quot;);
2256   if (is_zombie()) {
2257     // a zombie may never be patched
2258     return false;
2259   }
2260   return true;
2261 }
2262 
2263 
<a name="106" id="anc106"></a>





























2264 void nmethod_init() {
2265   // make sure you didn&#39;t forget to adjust the filler fields
2266   assert(sizeof(nmethod) % oopSize == 0, &quot;nmethod size must be multiple of a word&quot;);
2267 }
2268 
2269 
2270 //-------------------------------------------------------------------------------------------
2271 
2272 
2273 // QQQ might we make this work from a frame??
2274 nmethodLocker::nmethodLocker(address pc) {
2275   CodeBlob* cb = CodeCache::find_blob(pc);
2276   guarantee(cb != NULL &amp;&amp; cb-&gt;is_compiled(), &quot;bad pc for a nmethod found&quot;);
2277   _nm = cb-&gt;as_compiled_method();
2278   lock_nmethod(_nm);
2279 }
2280 
2281 // Only JvmtiDeferredEvent::compiled_method_unload_event()
2282 // should pass zombie_ok == true.
2283 void nmethodLocker::lock_nmethod(CompiledMethod* cm, bool zombie_ok) {
2284   if (cm == NULL)  return;
2285   if (cm-&gt;is_aot()) return;  // FIXME: Revisit once _lock_count is added to aot_method
2286   nmethod* nm = cm-&gt;as_nmethod();
2287   Atomic::inc(&amp;nm-&gt;_lock_count);
<a name="107" id="anc107"></a><span class="line-modified">2288   assert(zombie_ok || !nm-&gt;is_zombie(), &quot;cannot lock a zombie method: %p&quot;, nm);</span>
2289 }
2290 
2291 void nmethodLocker::unlock_nmethod(CompiledMethod* cm) {
2292   if (cm == NULL)  return;
2293   if (cm-&gt;is_aot()) return;  // FIXME: Revisit once _lock_count is added to aot_method
2294   nmethod* nm = cm-&gt;as_nmethod();
2295   Atomic::dec(&amp;nm-&gt;_lock_count);
2296   assert(nm-&gt;_lock_count &gt;= 0, &quot;unmatched nmethod lock/unlock&quot;);
2297 }
2298 
2299 
2300 // -----------------------------------------------------------------------------
2301 // Verification
2302 
2303 class VerifyOopsClosure: public OopClosure {
2304   nmethod* _nm;
2305   bool     _ok;
2306 public:
2307   VerifyOopsClosure(nmethod* nm) : _nm(nm), _ok(true) { }
2308   bool ok() { return _ok; }
2309   virtual void do_oop(oop* p) {
2310     if (oopDesc::is_oop_or_null(*p)) return;
<a name="108" id="anc108"></a><span class="line-added">2311     // Print diagnostic information before calling print_nmethod().</span>
<span class="line-added">2312     // Assertions therein might prevent call from returning.</span>
<span class="line-added">2313     tty-&gt;print_cr(&quot;*** non-oop &quot; PTR_FORMAT &quot; found at &quot; PTR_FORMAT &quot; (offset %d)&quot;,</span>
<span class="line-added">2314                   p2i(*p), p2i(p), (int)((intptr_t)p - (intptr_t)_nm));</span>
2315     if (_ok) {
2316       _nm-&gt;print_nmethod(true);
2317       _ok = false;
2318     }
<a name="109" id="anc109"></a>

2319   }
2320   virtual void do_oop(narrowOop* p) { ShouldNotReachHere(); }
2321 };
2322 
<a name="110" id="anc110"></a><span class="line-added">2323 class VerifyMetadataClosure: public MetadataClosure {</span>
<span class="line-added">2324  public:</span>
<span class="line-added">2325   void do_metadata(Metadata* md) {</span>
<span class="line-added">2326     if (md-&gt;is_method()) {</span>
<span class="line-added">2327       Method* method = (Method*)md;</span>
<span class="line-added">2328       assert(!method-&gt;is_old(), &quot;Should not be installing old methods&quot;);</span>
<span class="line-added">2329     }</span>
<span class="line-added">2330   }</span>
<span class="line-added">2331 };</span>
<span class="line-added">2332 </span>
<span class="line-added">2333 </span>
2334 void nmethod::verify() {
2335 
2336   // Hmm. OSR methods can be deopted but not marked as zombie or not_entrant
2337   // seems odd.
2338 
2339   if (is_zombie() || is_not_entrant() || is_unloaded())
2340     return;
2341 
2342   // Make sure all the entry points are correctly aligned for patching.
2343   NativeJump::check_verified_entry_alignment(entry_point(), verified_entry_point());
2344 
2345   // assert(oopDesc::is_oop(method()), &quot;must be valid&quot;);
2346 
2347   ResourceMark rm;
2348 
2349   if (!CodeCache::contains(this)) {
2350     fatal(&quot;nmethod at &quot; INTPTR_FORMAT &quot; not in zone&quot;, p2i(this));
2351   }
2352 
2353   if(is_native_method() )
2354     return;
2355 
2356   nmethod* nm = CodeCache::find_nmethod(verified_entry_point());
2357   if (nm != this) {
2358     fatal(&quot;findNMethod did not find this nmethod (&quot; INTPTR_FORMAT &quot;)&quot;, p2i(this));
2359   }
2360 
2361   for (PcDesc* p = scopes_pcs_begin(); p &lt; scopes_pcs_end(); p++) {
2362     if (! p-&gt;verify(this)) {
2363       tty-&gt;print_cr(&quot;\t\tin nmethod at &quot; INTPTR_FORMAT &quot; (pcs)&quot;, p2i(this));
2364     }
2365   }
2366 
<a name="111" id="anc111"></a><span class="line-added">2367 #ifdef ASSERT</span>
<span class="line-added">2368 #if INCLUDE_JVMCI</span>
<span class="line-added">2369   {</span>
<span class="line-added">2370     // Verify that implicit exceptions that deoptimize have a PcDesc and OopMap</span>
<span class="line-added">2371     ImmutableOopMapSet* oms = oop_maps();</span>
<span class="line-added">2372     ImplicitExceptionTable implicit_table(this);</span>
<span class="line-added">2373     for (uint i = 0; i &lt; implicit_table.len(); i++) {</span>
<span class="line-added">2374       int exec_offset = (int) implicit_table.get_exec_offset(i);</span>
<span class="line-added">2375       if (implicit_table.get_exec_offset(i) == implicit_table.get_cont_offset(i)) {</span>
<span class="line-added">2376         assert(pc_desc_at(code_begin() + exec_offset) != NULL, &quot;missing PcDesc&quot;);</span>
<span class="line-added">2377         bool found = false;</span>
<span class="line-added">2378         for (int i = 0, imax = oms-&gt;count(); i &lt; imax; i++) {</span>
<span class="line-added">2379           if (oms-&gt;pair_at(i)-&gt;pc_offset() == exec_offset) {</span>
<span class="line-added">2380             found = true;</span>
<span class="line-added">2381             break;</span>
<span class="line-added">2382           }</span>
<span class="line-added">2383         }</span>
<span class="line-added">2384         assert(found, &quot;missing oopmap&quot;);</span>
<span class="line-added">2385       }</span>
<span class="line-added">2386     }</span>
<span class="line-added">2387   }</span>
<span class="line-added">2388 #endif</span>
<span class="line-added">2389 #endif</span>
<span class="line-added">2390 </span>
2391   VerifyOopsClosure voc(this);
2392   oops_do(&amp;voc);
2393   assert(voc.ok(), &quot;embedded oops must be OK&quot;);
2394   Universe::heap()-&gt;verify_nmethod(this);
2395 
<a name="112" id="anc112"></a><span class="line-added">2396   assert(_oops_do_mark_link == NULL, &quot;_oops_do_mark_link for %s should be NULL but is &quot; PTR_FORMAT,</span>
<span class="line-added">2397          nm-&gt;method()-&gt;external_name(), p2i(_oops_do_mark_link));</span>
2398   verify_scopes();
<a name="113" id="anc113"></a><span class="line-added">2399 </span>
<span class="line-added">2400   CompiledICLocker nm_verify(this);</span>
<span class="line-added">2401   VerifyMetadataClosure vmc;</span>
<span class="line-added">2402   metadata_do(&amp;vmc);</span>
2403 }
2404 
2405 
2406 void nmethod::verify_interrupt_point(address call_site) {
2407   // Verify IC only when nmethod installation is finished.
2408   if (!is_not_installed()) {
2409     if (CompiledICLocker::is_safe(this)) {
2410       CompiledIC_at(this, call_site);
<a name="114" id="anc114"></a>
2411     } else {
2412       CompiledICLocker ml_verify(this);
2413       CompiledIC_at(this, call_site);
2414     }
2415   }
2416 
2417   PcDesc* pd = pc_desc_at(nativeCall_at(call_site)-&gt;return_address());
2418   assert(pd != NULL, &quot;PcDesc must exist&quot;);
2419   for (ScopeDesc* sd = new ScopeDesc(this, pd-&gt;scope_decode_offset(),
2420                                      pd-&gt;obj_decode_offset(), pd-&gt;should_reexecute(), pd-&gt;rethrow_exception(),
2421                                      pd-&gt;return_oop());
2422        !sd-&gt;is_top(); sd = sd-&gt;sender()) {
2423     sd-&gt;verify();
2424   }
2425 }
2426 
2427 void nmethod::verify_scopes() {
2428   if( !method() ) return;       // Runtime stubs have no scope
2429   if (method()-&gt;is_native()) return; // Ignore stub methods.
2430   // iterate through all interrupt point
2431   // and verify the debug information is valid.
2432   RelocIterator iter((nmethod*)this);
2433   while (iter.next()) {
2434     address stub = NULL;
2435     switch (iter.type()) {
2436       case relocInfo::virtual_call_type:
2437         verify_interrupt_point(iter.addr());
2438         break;
2439       case relocInfo::opt_virtual_call_type:
2440         stub = iter.opt_virtual_call_reloc()-&gt;static_stub(false);
2441         verify_interrupt_point(iter.addr());
2442         break;
2443       case relocInfo::static_call_type:
2444         stub = iter.static_call_reloc()-&gt;static_stub(false);
2445         //verify_interrupt_point(iter.addr());
2446         break;
2447       case relocInfo::runtime_call_type:
2448       case relocInfo::runtime_call_w_cp_type: {
2449         address destination = iter.reloc()-&gt;value();
2450         // Right now there is no way to find out which entries support
2451         // an interrupt point.  It would be nice if we had this
2452         // information in a table.
2453         break;
2454       }
2455       default:
2456         break;
2457     }
2458     assert(stub == NULL || stub_contains(stub), &quot;static call stub outside stub section&quot;);
2459   }
2460 }
2461 
2462 
2463 // -----------------------------------------------------------------------------
2464 // Printing operations
2465 
2466 void nmethod::print() const {
<a name="115" id="anc115"></a>
2467   ttyLocker ttyl;   // keep the following output all in one block
<a name="116" id="anc116"></a><span class="line-added">2468   print(tty);</span>
<span class="line-added">2469 }</span>
<span class="line-added">2470 </span>
<span class="line-added">2471 void nmethod::print(outputStream* st) const {</span>
<span class="line-added">2472   ResourceMark rm;</span>
2473 
<a name="117" id="anc117"></a><span class="line-modified">2474   st-&gt;print(&quot;Compiled method &quot;);</span>
2475 
2476   if (is_compiled_by_c1()) {
<a name="118" id="anc118"></a><span class="line-modified">2477     st-&gt;print(&quot;(c1) &quot;);</span>
2478   } else if (is_compiled_by_c2()) {
<a name="119" id="anc119"></a><span class="line-modified">2479     st-&gt;print(&quot;(c2) &quot;);</span>
2480   } else if (is_compiled_by_jvmci()) {
<a name="120" id="anc120"></a><span class="line-modified">2481     st-&gt;print(&quot;(JVMCI) &quot;);</span>
2482   } else {
<a name="121" id="anc121"></a><span class="line-modified">2483     st-&gt;print(&quot;(n/a) &quot;);</span>
2484   }
2485 
2486   print_on(tty, NULL);
2487 
2488   if (WizardMode) {
<a name="122" id="anc122"></a><span class="line-modified">2489     st-&gt;print(&quot;((nmethod*) &quot; INTPTR_FORMAT &quot;) &quot;, p2i(this));</span>
<span class="line-modified">2490     st-&gt;print(&quot; for method &quot; INTPTR_FORMAT , p2i(method()));</span>
<span class="line-modified">2491     st-&gt;print(&quot; { &quot;);</span>
<span class="line-modified">2492     st-&gt;print_cr(&quot;%s &quot;, state());</span>
<span class="line-modified">2493     st-&gt;print_cr(&quot;}:&quot;);</span>
<span class="line-modified">2494   }</span>
<span class="line-modified">2495   if (size              () &gt; 0) st-&gt;print_cr(&quot; total in heap  [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="line-modified">2496                                              p2i(this),</span>
<span class="line-modified">2497                                              p2i(this) + size(),</span>
<span class="line-modified">2498                                              size());</span>
<span class="line-modified">2499   if (relocation_size   () &gt; 0) st-&gt;print_cr(&quot; relocation     [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="line-modified">2500                                              p2i(relocation_begin()),</span>
<span class="line-modified">2501                                              p2i(relocation_end()),</span>
<span class="line-modified">2502                                              relocation_size());</span>
<span class="line-modified">2503   if (consts_size       () &gt; 0) st-&gt;print_cr(&quot; constants      [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="line-modified">2504                                              p2i(consts_begin()),</span>
<span class="line-modified">2505                                              p2i(consts_end()),</span>
<span class="line-modified">2506                                              consts_size());</span>
<span class="line-modified">2507   if (insts_size        () &gt; 0) st-&gt;print_cr(&quot; main code      [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="line-modified">2508                                              p2i(insts_begin()),</span>
<span class="line-modified">2509                                              p2i(insts_end()),</span>
<span class="line-modified">2510                                              insts_size());</span>
<span class="line-modified">2511   if (stub_size         () &gt; 0) st-&gt;print_cr(&quot; stub code      [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="line-modified">2512                                              p2i(stub_begin()),</span>
<span class="line-modified">2513                                              p2i(stub_end()),</span>
<span class="line-modified">2514                                              stub_size());</span>
<span class="line-modified">2515   if (oops_size         () &gt; 0) st-&gt;print_cr(&quot; oops           [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="line-modified">2516                                              p2i(oops_begin()),</span>
<span class="line-modified">2517                                              p2i(oops_end()),</span>
<span class="line-modified">2518                                              oops_size());</span>
<span class="line-modified">2519   if (metadata_size     () &gt; 0) st-&gt;print_cr(&quot; metadata       [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="line-modified">2520                                              p2i(metadata_begin()),</span>
<span class="line-modified">2521                                              p2i(metadata_end()),</span>
<span class="line-modified">2522                                              metadata_size());</span>
<span class="line-modified">2523   if (scopes_data_size  () &gt; 0) st-&gt;print_cr(&quot; scopes data    [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="line-modified">2524                                              p2i(scopes_data_begin()),</span>
<span class="line-modified">2525                                              p2i(scopes_data_end()),</span>
<span class="line-modified">2526                                              scopes_data_size());</span>
<span class="line-modified">2527   if (scopes_pcs_size   () &gt; 0) st-&gt;print_cr(&quot; scopes pcs     [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="line-modified">2528                                              p2i(scopes_pcs_begin()),</span>
<span class="line-modified">2529                                              p2i(scopes_pcs_end()),</span>
<span class="line-modified">2530                                              scopes_pcs_size());</span>
<span class="line-modified">2531   if (dependencies_size () &gt; 0) st-&gt;print_cr(&quot; dependencies   [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="line-modified">2532                                              p2i(dependencies_begin()),</span>
<span class="line-modified">2533                                              p2i(dependencies_end()),</span>
<span class="line-modified">2534                                              dependencies_size());</span>
<span class="line-modified">2535   if (handler_table_size() &gt; 0) st-&gt;print_cr(&quot; handler table  [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="line-modified">2536                                              p2i(handler_table_begin()),</span>
<span class="line-modified">2537                                              p2i(handler_table_end()),</span>
<span class="line-modified">2538                                              handler_table_size());</span>
<span class="line-modified">2539   if (nul_chk_table_size() &gt; 0) st-&gt;print_cr(&quot; nul chk table  [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="line-modified">2540                                              p2i(nul_chk_table_begin()),</span>
<span class="line-modified">2541                                              p2i(nul_chk_table_end()),</span>
<span class="line-modified">2542                                              nul_chk_table_size());</span>
<span class="line-added">2543 #if INCLUDE_JVMCI</span>
<span class="line-added">2544   if (speculations_size () &gt; 0) st-&gt;print_cr(&quot; speculations   [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="line-added">2545                                              p2i(speculations_begin()),</span>
<span class="line-added">2546                                              p2i(speculations_end()),</span>
<span class="line-added">2547                                              speculations_size());</span>
<span class="line-added">2548   if (jvmci_data_size   () &gt; 0) st-&gt;print_cr(&quot; JVMCI data     [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="line-added">2549                                              p2i(jvmci_data_begin()),</span>
<span class="line-added">2550                                              p2i(jvmci_data_end()),</span>
<span class="line-added">2551                                              jvmci_data_size());</span>
<span class="line-added">2552 #endif</span>
2553 }
2554 
<a name="123" id="anc123"></a><span class="line-modified">2555 void nmethod::print_code() {</span>
<span class="line-modified">2556   HandleMark hm;</span>
<span class="line-modified">2557   ResourceMark m;</span>
<span class="line-modified">2558   ttyLocker ttyl;</span>
<span class="line-modified">2559   // Call the specialized decode method of this class.</span>
<span class="line-modified">2560   decode(tty);</span>









2561 }
2562 
<a name="124" id="anc124"></a><span class="line-added">2563 #ifndef PRODUCT  // called InstanceKlass methods are available only then. Declared as PRODUCT_RETURN</span>
<span class="line-added">2564 </span>
2565 void nmethod::print_dependencies() {
2566   ResourceMark rm;
2567   ttyLocker ttyl;   // keep the following output all in one block
2568   tty-&gt;print_cr(&quot;Dependencies:&quot;);
2569   for (Dependencies::DepStream deps(this); deps.next(); ) {
2570     deps.print_dependency();
2571     Klass* ctxk = deps.context_type();
2572     if (ctxk != NULL) {
2573       if (ctxk-&gt;is_instance_klass() &amp;&amp; InstanceKlass::cast(ctxk)-&gt;is_dependent_nmethod(this)) {
2574         tty-&gt;print_cr(&quot;   [nmethod&lt;=klass]%s&quot;, ctxk-&gt;external_name());
2575       }
2576     }
2577     deps.log_dependency();  // put it into the xml log also
2578   }
2579 }
<a name="125" id="anc125"></a><span class="line-added">2580 #endif</span>
2581 
<a name="126" id="anc126"></a><span class="line-added">2582 #if defined(SUPPORT_DATA_STRUCTS)</span>
<span class="line-added">2583 </span>
<span class="line-added">2584 // Print the oops from the underlying CodeBlob.</span>
<span class="line-added">2585 void nmethod::print_oops(outputStream* st) {</span>
<span class="line-added">2586   HandleMark hm;</span>
<span class="line-added">2587   ResourceMark m;</span>
<span class="line-added">2588   st-&gt;print(&quot;Oops:&quot;);</span>
<span class="line-added">2589   if (oops_begin() &lt; oops_end()) {</span>
<span class="line-added">2590     st-&gt;cr();</span>
<span class="line-added">2591     for (oop* p = oops_begin(); p &lt; oops_end(); p++) {</span>
<span class="line-added">2592       Disassembler::print_location((unsigned char*)p, (unsigned char*)oops_begin(), (unsigned char*)oops_end(), st, true, false);</span>
<span class="line-added">2593       st-&gt;print(PTR_FORMAT &quot; &quot;, *((uintptr_t*)p));</span>
<span class="line-added">2594       if (*p == Universe::non_oop_word()) {</span>
<span class="line-added">2595         st-&gt;print_cr(&quot;NON_OOP&quot;);</span>
<span class="line-added">2596         continue;  // skip non-oops</span>
<span class="line-added">2597       }</span>
<span class="line-added">2598       if (*p == NULL) {</span>
<span class="line-added">2599         st-&gt;print_cr(&quot;NULL-oop&quot;);</span>
<span class="line-added">2600         continue;  // skip non-oops</span>
<span class="line-added">2601       }</span>
<span class="line-added">2602       (*p)-&gt;print_value_on(st);</span>
<span class="line-added">2603       st-&gt;cr();</span>
<span class="line-added">2604     }</span>
<span class="line-added">2605   } else {</span>
<span class="line-added">2606     st-&gt;print_cr(&quot; &lt;list empty&gt;&quot;);</span>
<span class="line-added">2607   }</span>
<span class="line-added">2608 }</span>
<span class="line-added">2609 </span>
<span class="line-added">2610 // Print metadata pool.</span>
<span class="line-added">2611 void nmethod::print_metadata(outputStream* st) {</span>
<span class="line-added">2612   HandleMark hm;</span>
<span class="line-added">2613   ResourceMark m;</span>
<span class="line-added">2614   st-&gt;print(&quot;Metadata:&quot;);</span>
<span class="line-added">2615   if (metadata_begin() &lt; metadata_end()) {</span>
<span class="line-added">2616     st-&gt;cr();</span>
<span class="line-added">2617     for (Metadata** p = metadata_begin(); p &lt; metadata_end(); p++) {</span>
<span class="line-added">2618       Disassembler::print_location((unsigned char*)p, (unsigned char*)metadata_begin(), (unsigned char*)metadata_end(), st, true, false);</span>
<span class="line-added">2619       st-&gt;print(PTR_FORMAT &quot; &quot;, *((uintptr_t*)p));</span>
<span class="line-added">2620       if (*p &amp;&amp; *p != Universe::non_oop_word()) {</span>
<span class="line-added">2621         (*p)-&gt;print_value_on(st);</span>
<span class="line-added">2622       }</span>
<span class="line-added">2623       st-&gt;cr();</span>
<span class="line-added">2624     }</span>
<span class="line-added">2625   } else {</span>
<span class="line-added">2626     st-&gt;print_cr(&quot; &lt;list empty&gt;&quot;);</span>
<span class="line-added">2627   }</span>
<span class="line-added">2628 }</span>
2629 
<a name="127" id="anc127"></a><span class="line-added">2630 #ifndef PRODUCT  // ScopeDesc::print_on() is available only then. Declared as PRODUCT_RETURN</span>
<span class="line-added">2631 void nmethod::print_scopes_on(outputStream* st) {</span>
<span class="line-added">2632   // Find the first pc desc for all scopes in the code and print it.</span>
<span class="line-added">2633   ResourceMark rm;</span>
<span class="line-added">2634   st-&gt;print(&quot;scopes:&quot;);</span>
<span class="line-added">2635   if (scopes_pcs_begin() &lt; scopes_pcs_end()) {</span>
<span class="line-added">2636     st-&gt;cr();</span>
<span class="line-added">2637     for (PcDesc* p = scopes_pcs_begin(); p &lt; scopes_pcs_end(); p++) {</span>
<span class="line-added">2638       if (p-&gt;scope_decode_offset() == DebugInformationRecorder::serialized_null)</span>
<span class="line-added">2639         continue;</span>
<span class="line-added">2640 </span>
<span class="line-added">2641       ScopeDesc* sd = scope_desc_at(p-&gt;real_pc(this));</span>
<span class="line-added">2642       while (sd != NULL) {</span>
<span class="line-added">2643         sd-&gt;print_on(st, p);  // print output ends with a newline</span>
<span class="line-added">2644         sd = sd-&gt;sender();</span>
<span class="line-added">2645       }</span>
<span class="line-added">2646     }</span>
<span class="line-added">2647   } else {</span>
<span class="line-added">2648     st-&gt;print_cr(&quot; &lt;list empty&gt;&quot;);</span>
<span class="line-added">2649   }</span>
<span class="line-added">2650 }</span>
<span class="line-added">2651 #endif</span>
<span class="line-added">2652 </span>
<span class="line-added">2653 #ifndef PRODUCT  // RelocIterator does support printing only then.</span>
2654 void nmethod::print_relocations() {
2655   ResourceMark m;       // in case methods get printed via the debugger
2656   tty-&gt;print_cr(&quot;relocations:&quot;);
2657   RelocIterator iter(this);
2658   iter.print();
2659 }
<a name="128" id="anc128"></a><span class="line-added">2660 #endif</span>
2661 
<a name="129" id="anc129"></a><span class="line-modified">2662 void nmethod::print_pcs_on(outputStream* st) {</span>

2663   ResourceMark m;       // in case methods get printed via debugger
<a name="130" id="anc130"></a><span class="line-modified">2664   st-&gt;print(&quot;pc-bytecode offsets:&quot;);</span>
<span class="line-modified">2665   if (scopes_pcs_begin() &lt; scopes_pcs_end()) {</span>
<span class="line-modified">2666     st-&gt;cr();</span>
<span class="line-added">2667     for (PcDesc* p = scopes_pcs_begin(); p &lt; scopes_pcs_end(); p++) {</span>
<span class="line-added">2668       p-&gt;print_on(st, this);  // print output ends with a newline</span>
<span class="line-added">2669     }</span>
<span class="line-added">2670   } else {</span>
<span class="line-added">2671     st-&gt;print_cr(&quot; &lt;list empty&gt;&quot;);</span>
2672   }
2673 }
2674 
<a name="131" id="anc131"></a><span class="line-added">2675 void nmethod::print_handler_table() {</span>
<span class="line-added">2676   ExceptionHandlerTable(this).print();</span>
<span class="line-added">2677 }</span>
<span class="line-added">2678 </span>
<span class="line-added">2679 void nmethod::print_nul_chk_table() {</span>
<span class="line-added">2680   ImplicitExceptionTable(this).print(code_begin());</span>
<span class="line-added">2681 }</span>
<span class="line-added">2682 </span>
2683 void nmethod::print_recorded_oops() {
<a name="132" id="anc132"></a><span class="line-modified">2684   const int n = oops_count();</span>
<span class="line-modified">2685   const int log_n = (n&lt;10) ? 1 : (n&lt;100) ? 2 : (n&lt;1000) ? 3 : (n&lt;10000) ? 4 : 6;</span>
<span class="line-modified">2686   tty-&gt;print(&quot;Recorded oops:&quot;);</span>
<span class="line-modified">2687   if (n &gt; 0) {</span>
<span class="line-modified">2688     tty-&gt;cr();</span>
<span class="line-modified">2689     for (int i = 0; i &lt; n; i++) {</span>
<span class="line-modified">2690       oop o = oop_at(i);</span>
<span class="line-modified">2691       tty-&gt;print(&quot;#%*d: &quot; INTPTR_FORMAT &quot; &quot;, log_n, i, p2i(o));</span>
<span class="line-modified">2692       if (o == (oop)Universe::non_oop_word()) {</span>
<span class="line-added">2693         tty-&gt;print(&quot;non-oop word&quot;);</span>
<span class="line-added">2694       } else if (o == NULL) {</span>
<span class="line-added">2695         tty-&gt;print(&quot;NULL-oop&quot;);</span>
2696       } else {
<a name="133" id="anc133"></a><span class="line-modified">2697         o-&gt;print_value_on(tty);</span>
2698       }
<a name="134" id="anc134"></a><span class="line-added">2699       tty-&gt;cr();</span>
2700     }
<a name="135" id="anc135"></a><span class="line-modified">2701   } else {</span>
<span class="line-added">2702     tty-&gt;print_cr(&quot; &lt;list empty&gt;&quot;);</span>
2703   }
2704 }
2705 
2706 void nmethod::print_recorded_metadata() {
<a name="136" id="anc136"></a><span class="line-modified">2707   const int n = metadata_count();</span>
<span class="line-modified">2708   const int log_n = (n&lt;10) ? 1 : (n&lt;100) ? 2 : (n&lt;1000) ? 3 : (n&lt;10000) ? 4 : 6;</span>
<span class="line-modified">2709   tty-&gt;print(&quot;Recorded metadata:&quot;);</span>
<span class="line-modified">2710   if (n &gt; 0) {</span>
<span class="line-modified">2711     tty-&gt;cr();</span>
<span class="line-modified">2712     for (int i = 0; i &lt; n; i++) {</span>
<span class="line-added">2713       Metadata* m = metadata_at(i);</span>
<span class="line-added">2714       tty-&gt;print(&quot;#%*d: &quot; INTPTR_FORMAT &quot; &quot;, log_n, i, p2i(m));</span>
<span class="line-added">2715       if (m == (Metadata*)Universe::non_oop_word()) {</span>
<span class="line-added">2716         tty-&gt;print(&quot;non-metadata word&quot;);</span>
<span class="line-added">2717       } else if (m == NULL) {</span>
<span class="line-added">2718         tty-&gt;print(&quot;NULL-oop&quot;);</span>
<span class="line-added">2719       } else {</span>
<span class="line-added">2720         Metadata::print_value_on_maybe_null(tty, m);</span>
<span class="line-added">2721       }</span>
<span class="line-added">2722       tty-&gt;cr();</span>
<span class="line-added">2723     }</span>
<span class="line-added">2724   } else {</span>
<span class="line-added">2725     tty-&gt;print_cr(&quot; &lt;list empty&gt;&quot;);</span>
<span class="line-added">2726   }</span>
<span class="line-added">2727 }</span>
<span class="line-added">2728 #endif</span>
<span class="line-added">2729 </span>
<span class="line-added">2730 #if defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_ABSTRACT_ASSEMBLY)</span>
<span class="line-added">2731 </span>
<span class="line-added">2732 void nmethod::print_constant_pool(outputStream* st) {</span>
<span class="line-added">2733   //-----------------------------------</span>
<span class="line-added">2734   //---&lt;  Print the constant pool  &gt;---</span>
<span class="line-added">2735   //-----------------------------------</span>
<span class="line-added">2736   int consts_size = this-&gt;consts_size();</span>
<span class="line-added">2737   if ( consts_size &gt; 0 ) {</span>
<span class="line-added">2738     unsigned char* cstart = this-&gt;consts_begin();</span>
<span class="line-added">2739     unsigned char* cp     = cstart;</span>
<span class="line-added">2740     unsigned char* cend   = cp + consts_size;</span>
<span class="line-added">2741     unsigned int   bytes_per_line = 4;</span>
<span class="line-added">2742     unsigned int   CP_alignment   = 8;</span>
<span class="line-added">2743     unsigned int   n;</span>
<span class="line-added">2744 </span>
<span class="line-added">2745     st-&gt;cr();</span>
<span class="line-added">2746 </span>
<span class="line-added">2747     //---&lt;  print CP header to make clear what&#39;s printed  &gt;---</span>
<span class="line-added">2748     if( ((uintptr_t)cp&amp;(CP_alignment-1)) == 0 ) {</span>
<span class="line-added">2749       n = bytes_per_line;</span>
<span class="line-added">2750       st-&gt;print_cr(&quot;[Constant Pool]&quot;);</span>
<span class="line-added">2751       Disassembler::print_location(cp, cstart, cend, st, true, true);</span>
<span class="line-added">2752       Disassembler::print_hexdata(cp, n, st, true);</span>
<span class="line-added">2753       st-&gt;cr();</span>
2754     } else {
<a name="137" id="anc137"></a><span class="line-modified">2755       n = (uintptr_t)cp&amp;(bytes_per_line-1);</span>
<span class="line-added">2756       st-&gt;print_cr(&quot;[Constant Pool (unaligned)]&quot;);</span>
2757     }
<a name="138" id="anc138"></a><span class="line-modified">2758 </span>
<span class="line-added">2759     //---&lt;  print CP contents, bytes_per_line at a time  &gt;---</span>
<span class="line-added">2760     while (cp &lt; cend) {</span>
<span class="line-added">2761       Disassembler::print_location(cp, cstart, cend, st, true, false);</span>
<span class="line-added">2762       Disassembler::print_hexdata(cp, n, st, false);</span>
<span class="line-added">2763       cp += n;</span>
<span class="line-added">2764       n   = bytes_per_line;</span>
<span class="line-added">2765       st-&gt;cr();</span>
<span class="line-added">2766     }</span>
<span class="line-added">2767 </span>
<span class="line-added">2768     //---&lt;  Show potential alignment gap between constant pool and code  &gt;---</span>
<span class="line-added">2769     cend = code_begin();</span>
<span class="line-added">2770     if( cp &lt; cend ) {</span>
<span class="line-added">2771       n = 4;</span>
<span class="line-added">2772       st-&gt;print_cr(&quot;[Code entry alignment]&quot;);</span>
<span class="line-added">2773       while (cp &lt; cend) {</span>
<span class="line-added">2774         Disassembler::print_location(cp, cstart, cend, st, false, false);</span>
<span class="line-added">2775         cp += n;</span>
<span class="line-added">2776         st-&gt;cr();</span>
<span class="line-added">2777       }</span>
<span class="line-added">2778     }</span>
<span class="line-added">2779   } else {</span>
<span class="line-added">2780     st-&gt;print_cr(&quot;[Constant Pool (empty)]&quot;);</span>
<span class="line-added">2781   }</span>
<span class="line-added">2782   st-&gt;cr();</span>
<span class="line-added">2783 }</span>
<span class="line-added">2784 </span>
<span class="line-added">2785 #endif</span>
<span class="line-added">2786 </span>
<span class="line-added">2787 // Disassemble this nmethod.</span>
<span class="line-added">2788 // Print additional debug information, if requested. This could be code</span>
<span class="line-added">2789 // comments, block comments, profiling counters, etc.</span>
<span class="line-added">2790 // The undisassembled format is useful no disassembler library is available.</span>
<span class="line-added">2791 // The resulting hex dump (with markers) can be disassembled later, or on</span>
<span class="line-added">2792 // another system, when/where a disassembler library is available.</span>
<span class="line-added">2793 void nmethod::decode2(outputStream* ost) const {</span>
<span class="line-added">2794 </span>
<span class="line-added">2795   // Called from frame::back_trace_with_decode without ResourceMark.</span>
<span class="line-added">2796   ResourceMark rm;</span>
<span class="line-added">2797 </span>
<span class="line-added">2798   // Make sure we have a valid stream to print on.</span>
<span class="line-added">2799   outputStream* st = ost ? ost : tty;</span>
<span class="line-added">2800 </span>
<span class="line-added">2801 #if defined(SUPPORT_ABSTRACT_ASSEMBLY) &amp;&amp; ! defined(SUPPORT_ASSEMBLY)</span>
<span class="line-added">2802   const bool use_compressed_format    = true;</span>
<span class="line-added">2803   const bool compressed_with_comments = use_compressed_format &amp;&amp; (AbstractDisassembler::show_comment() ||</span>
<span class="line-added">2804                                                                   AbstractDisassembler::show_block_comment());</span>
<span class="line-added">2805 #else</span>
<span class="line-added">2806   const bool use_compressed_format    = Disassembler::is_abstract();</span>
<span class="line-added">2807   const bool compressed_with_comments = use_compressed_format &amp;&amp; (AbstractDisassembler::show_comment() ||</span>
<span class="line-added">2808                                                                   AbstractDisassembler::show_block_comment());</span>
<span class="line-added">2809 #endif</span>
<span class="line-added">2810 </span>
<span class="line-added">2811   st-&gt;cr();</span>
<span class="line-added">2812   this-&gt;print(st);</span>
<span class="line-added">2813   st-&gt;cr();</span>
<span class="line-added">2814 </span>
<span class="line-added">2815 #if defined(SUPPORT_ASSEMBLY)</span>
<span class="line-added">2816   //----------------------------------</span>
<span class="line-added">2817   //---&lt;  Print real disassembly  &gt;---</span>
<span class="line-added">2818   //----------------------------------</span>
<span class="line-added">2819   if (! use_compressed_format) {</span>
<span class="line-added">2820     Disassembler::decode(const_cast&lt;nmethod*&gt;(this), st);</span>
<span class="line-added">2821     return;</span>
2822   }
<a name="139" id="anc139"></a><span class="line-added">2823 #endif</span>
<span class="line-added">2824 </span>
<span class="line-added">2825 #if defined(SUPPORT_ABSTRACT_ASSEMBLY)</span>
<span class="line-added">2826 </span>
<span class="line-added">2827   // Compressed undisassembled disassembly format.</span>
<span class="line-added">2828   // The following stati are defined/supported:</span>
<span class="line-added">2829   //   = 0 - currently at bol() position, nothing printed yet on current line.</span>
<span class="line-added">2830   //   = 1 - currently at position after print_location().</span>
<span class="line-added">2831   //   &gt; 1 - in the midst of printing instruction stream bytes.</span>
<span class="line-added">2832   int        compressed_format_idx    = 0;</span>
<span class="line-added">2833   int        code_comment_column      = 0;</span>
<span class="line-added">2834   const int  instr_maxlen             = Assembler::instr_maxlen();</span>
<span class="line-added">2835   const uint tabspacing               = 8;</span>
<span class="line-added">2836   unsigned char* start = this-&gt;code_begin();</span>
<span class="line-added">2837   unsigned char* p     = this-&gt;code_begin();</span>
<span class="line-added">2838   unsigned char* end   = this-&gt;code_end();</span>
<span class="line-added">2839   unsigned char* pss   = p; // start of a code section (used for offsets)</span>
<span class="line-added">2840 </span>
<span class="line-added">2841   if ((start == NULL) || (end == NULL)) {</span>
<span class="line-added">2842     st-&gt;print_cr(&quot;PrintAssembly not possible due to uninitialized section pointers&quot;);</span>
<span class="line-added">2843     return;</span>
<span class="line-added">2844   }</span>
<span class="line-added">2845 #endif</span>
<span class="line-added">2846 </span>
<span class="line-added">2847 #if defined(SUPPORT_ABSTRACT_ASSEMBLY)</span>
<span class="line-added">2848   //---&lt;  plain abstract disassembly, no comments or anything, just section headers  &gt;---</span>
<span class="line-added">2849   if (use_compressed_format &amp;&amp; ! compressed_with_comments) {</span>
<span class="line-added">2850     const_cast&lt;nmethod*&gt;(this)-&gt;print_constant_pool(st);</span>
<span class="line-added">2851 </span>
<span class="line-added">2852     //---&lt;  Open the output (Marker for post-mortem disassembler)  &gt;---</span>
<span class="line-added">2853     st-&gt;print_cr(&quot;[MachCode]&quot;);</span>
<span class="line-added">2854     const char* header = NULL;</span>
<span class="line-added">2855     address p0 = p;</span>
<span class="line-added">2856     while (p &lt; end) {</span>
<span class="line-added">2857       address pp = p;</span>
<span class="line-added">2858       while ((p &lt; end) &amp;&amp; (header == NULL)) {</span>
<span class="line-added">2859         header = nmethod_section_label(p);</span>
<span class="line-added">2860         pp  = p;</span>
<span class="line-added">2861         p  += Assembler::instr_len(p);</span>
<span class="line-added">2862       }</span>
<span class="line-added">2863       if (pp &gt; p0) {</span>
<span class="line-added">2864         AbstractDisassembler::decode_range_abstract(p0, pp, start, end, st, Assembler::instr_maxlen());</span>
<span class="line-added">2865         p0 = pp;</span>
<span class="line-added">2866         p  = pp;</span>
<span class="line-added">2867         header = NULL;</span>
<span class="line-added">2868       } else if (header != NULL) {</span>
<span class="line-added">2869         st-&gt;bol();</span>
<span class="line-added">2870         st-&gt;print_cr(&quot;%s&quot;, header);</span>
<span class="line-added">2871         header = NULL;</span>
<span class="line-added">2872       }</span>
<span class="line-added">2873     }</span>
<span class="line-added">2874     //---&lt;  Close the output (Marker for post-mortem disassembler)  &gt;---</span>
<span class="line-added">2875     st-&gt;bol();</span>
<span class="line-added">2876     st-&gt;print_cr(&quot;[/MachCode]&quot;);</span>
<span class="line-added">2877     return;</span>
<span class="line-added">2878   }</span>
<span class="line-added">2879 #endif</span>
<span class="line-added">2880 </span>
<span class="line-added">2881 #if defined(SUPPORT_ABSTRACT_ASSEMBLY)</span>
<span class="line-added">2882   //---&lt;  abstract disassembly with comments and section headers merged in  &gt;---</span>
<span class="line-added">2883   if (compressed_with_comments) {</span>
<span class="line-added">2884     const_cast&lt;nmethod*&gt;(this)-&gt;print_constant_pool(st);</span>
<span class="line-added">2885 </span>
<span class="line-added">2886     //---&lt;  Open the output (Marker for post-mortem disassembler)  &gt;---</span>
<span class="line-added">2887     st-&gt;print_cr(&quot;[MachCode]&quot;);</span>
<span class="line-added">2888     while ((p &lt; end) &amp;&amp; (p != NULL)) {</span>
<span class="line-added">2889       const int instruction_size_in_bytes = Assembler::instr_len(p);</span>
<span class="line-added">2890 </span>
<span class="line-added">2891       //---&lt;  Block comments for nmethod. Interrupts instruction stream, if any.  &gt;---</span>
<span class="line-added">2892       // Outputs a bol() before and a cr() after, but only if a comment is printed.</span>
<span class="line-added">2893       // Prints nmethod_section_label as well.</span>
<span class="line-added">2894       if (AbstractDisassembler::show_block_comment()) {</span>
<span class="line-added">2895         print_block_comment(st, p);</span>
<span class="line-added">2896         if (st-&gt;position() == 0) {</span>
<span class="line-added">2897           compressed_format_idx = 0;</span>
<span class="line-added">2898         }</span>
<span class="line-added">2899       }</span>
<span class="line-added">2900 </span>
<span class="line-added">2901       //---&lt;  New location information after line break  &gt;---</span>
<span class="line-added">2902       if (compressed_format_idx == 0) {</span>
<span class="line-added">2903         code_comment_column   = Disassembler::print_location(p, pss, end, st, false, false);</span>
<span class="line-added">2904         compressed_format_idx = 1;</span>
<span class="line-added">2905       }</span>
<span class="line-added">2906 </span>
<span class="line-added">2907       //---&lt;  Code comment for current instruction. Address range [p..(p+len))  &gt;---</span>
<span class="line-added">2908       unsigned char* p_end = p + (ssize_t)instruction_size_in_bytes;</span>
<span class="line-added">2909       S390_ONLY(if (p_end &gt; end) p_end = end;) // avoid getting past the end</span>
<span class="line-added">2910 </span>
<span class="line-added">2911       if (AbstractDisassembler::show_comment() &amp;&amp; const_cast&lt;nmethod*&gt;(this)-&gt;has_code_comment(p, p_end)) {</span>
<span class="line-added">2912         //---&lt;  interrupt instruction byte stream for code comment  &gt;---</span>
<span class="line-added">2913         if (compressed_format_idx &gt; 1) {</span>
<span class="line-added">2914           st-&gt;cr();  // interrupt byte stream</span>
<span class="line-added">2915           st-&gt;cr();  // add an empty line</span>
<span class="line-added">2916           code_comment_column = Disassembler::print_location(p, pss, end, st, false, false);</span>
<span class="line-added">2917         }</span>
<span class="line-added">2918         const_cast&lt;nmethod*&gt;(this)-&gt;print_code_comment_on(st, code_comment_column, p, p_end );</span>
<span class="line-added">2919         st-&gt;bol();</span>
<span class="line-added">2920         compressed_format_idx = 0;</span>
<span class="line-added">2921       }</span>
<span class="line-added">2922 </span>
<span class="line-added">2923       //---&lt;  New location information after line break  &gt;---</span>
<span class="line-added">2924       if (compressed_format_idx == 0) {</span>
<span class="line-added">2925         code_comment_column   = Disassembler::print_location(p, pss, end, st, false, false);</span>
<span class="line-added">2926         compressed_format_idx = 1;</span>
<span class="line-added">2927       }</span>
<span class="line-added">2928 </span>
<span class="line-added">2929       //---&lt;  Nicely align instructions for readability  &gt;---</span>
<span class="line-added">2930       if (compressed_format_idx &gt; 1) {</span>
<span class="line-added">2931         Disassembler::print_delimiter(st);</span>
<span class="line-added">2932       }</span>
<span class="line-added">2933 </span>
<span class="line-added">2934       //---&lt;  Now, finally, print the actual instruction bytes  &gt;---</span>
<span class="line-added">2935       unsigned char* p0 = p;</span>
<span class="line-added">2936       p = Disassembler::decode_instruction_abstract(p, st, instruction_size_in_bytes, instr_maxlen);</span>
<span class="line-added">2937       compressed_format_idx += p - p0;</span>
<span class="line-added">2938 </span>
<span class="line-added">2939       if (Disassembler::start_newline(compressed_format_idx-1)) {</span>
<span class="line-added">2940         st-&gt;cr();</span>
<span class="line-added">2941         compressed_format_idx = 0;</span>
<span class="line-added">2942       }</span>
<span class="line-added">2943     }</span>
<span class="line-added">2944     //---&lt;  Close the output (Marker for post-mortem disassembler)  &gt;---</span>
<span class="line-added">2945     st-&gt;bol();</span>
<span class="line-added">2946     st-&gt;print_cr(&quot;[/MachCode]&quot;);</span>
<span class="line-added">2947     return;</span>
<span class="line-added">2948   }</span>
<span class="line-added">2949 #endif</span>
2950 }
2951 
<a name="140" id="anc140"></a><span class="line-modified">2952 #if defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_ABSTRACT_ASSEMBLY)</span>
2953 
2954 const char* nmethod::reloc_string_for(u_char* begin, u_char* end) {
2955   RelocIterator iter(this, begin, end);
2956   bool have_one = false;
2957   while (iter.next()) {
2958     have_one = true;
2959     switch (iter.type()) {
2960         case relocInfo::none:                  return &quot;no_reloc&quot;;
2961         case relocInfo::oop_type: {
<a name="141" id="anc141"></a><span class="line-modified">2962           // Get a non-resizable resource-allocated stringStream.</span>
<span class="line-added">2963           // Our callees make use of (nested) ResourceMarks.</span>
<span class="line-added">2964           stringStream st(NEW_RESOURCE_ARRAY(char, 1024), 1024);</span>
2965           oop_Relocation* r = iter.oop_reloc();
2966           oop obj = r-&gt;oop_value();
2967           st.print(&quot;oop(&quot;);
2968           if (obj == NULL) st.print(&quot;NULL&quot;);
2969           else obj-&gt;print_value_on(&amp;st);
2970           st.print(&quot;)&quot;);
2971           return st.as_string();
2972         }
2973         case relocInfo::metadata_type: {
2974           stringStream st;
2975           metadata_Relocation* r = iter.metadata_reloc();
2976           Metadata* obj = r-&gt;metadata_value();
2977           st.print(&quot;metadata(&quot;);
2978           if (obj == NULL) st.print(&quot;NULL&quot;);
2979           else obj-&gt;print_value_on(&amp;st);
2980           st.print(&quot;)&quot;);
2981           return st.as_string();
2982         }
2983         case relocInfo::runtime_call_type:
2984         case relocInfo::runtime_call_w_cp_type: {
2985           stringStream st;
2986           st.print(&quot;runtime_call&quot;);
2987           CallRelocation* r = (CallRelocation*)iter.reloc();
2988           address dest = r-&gt;destination();
2989           CodeBlob* cb = CodeCache::find_blob(dest);
2990           if (cb != NULL) {
2991             st.print(&quot; %s&quot;, cb-&gt;name());
2992           } else {
2993             ResourceMark rm;
2994             const int buflen = 1024;
2995             char* buf = NEW_RESOURCE_ARRAY(char, buflen);
2996             int offset;
2997             if (os::dll_address_to_function_name(dest, buf, buflen, &amp;offset)) {
2998               st.print(&quot; %s&quot;, buf);
2999               if (offset != 0) {
3000                 st.print(&quot;+%d&quot;, offset);
3001               }
3002             }
3003           }
3004           return st.as_string();
3005         }
3006         case relocInfo::virtual_call_type: {
3007           stringStream st;
3008           st.print_raw(&quot;virtual_call&quot;);
3009           virtual_call_Relocation* r = iter.virtual_call_reloc();
3010           Method* m = r-&gt;method_value();
3011           if (m != NULL) {
3012             assert(m-&gt;is_method(), &quot;&quot;);
3013             m-&gt;print_short_name(&amp;st);
3014           }
3015           return st.as_string();
3016         }
3017         case relocInfo::opt_virtual_call_type: {
3018           stringStream st;
3019           st.print_raw(&quot;optimized virtual_call&quot;);
3020           opt_virtual_call_Relocation* r = iter.opt_virtual_call_reloc();
3021           Method* m = r-&gt;method_value();
3022           if (m != NULL) {
3023             assert(m-&gt;is_method(), &quot;&quot;);
3024             m-&gt;print_short_name(&amp;st);
3025           }
3026           return st.as_string();
3027         }
3028         case relocInfo::static_call_type: {
3029           stringStream st;
3030           st.print_raw(&quot;static_call&quot;);
3031           static_call_Relocation* r = iter.static_call_reloc();
3032           Method* m = r-&gt;method_value();
3033           if (m != NULL) {
3034             assert(m-&gt;is_method(), &quot;&quot;);
3035             m-&gt;print_short_name(&amp;st);
3036           }
3037           return st.as_string();
3038         }
3039         case relocInfo::static_stub_type:      return &quot;static_stub&quot;;
3040         case relocInfo::external_word_type:    return &quot;external_word&quot;;
3041         case relocInfo::internal_word_type:    return &quot;internal_word&quot;;
3042         case relocInfo::section_word_type:     return &quot;section_word&quot;;
3043         case relocInfo::poll_type:             return &quot;poll&quot;;
3044         case relocInfo::poll_return_type:      return &quot;poll_return&quot;;
3045         case relocInfo::trampoline_stub_type:  return &quot;trampoline_stub&quot;;
3046         case relocInfo::type_mask:             return &quot;type_bit_mask&quot;;
3047 
3048         default:
3049           break;
3050     }
3051   }
3052   return have_one ? &quot;other&quot; : NULL;
3053 }
3054 
3055 // Return a the last scope in (begin..end]
3056 ScopeDesc* nmethod::scope_desc_in(address begin, address end) {
3057   PcDesc* p = pc_desc_near(begin+1);
3058   if (p != NULL &amp;&amp; p-&gt;real_pc(this) &lt;= end) {
3059     return new ScopeDesc(this, p-&gt;scope_decode_offset(),
3060                          p-&gt;obj_decode_offset(), p-&gt;should_reexecute(), p-&gt;rethrow_exception(),
3061                          p-&gt;return_oop());
3062   }
3063   return NULL;
3064 }
3065 
<a name="142" id="anc142"></a><span class="line-modified">3066 const char* nmethod::nmethod_section_label(address pos) const {</span>
<span class="line-modified">3067   const char* label = NULL;</span>
<span class="line-modified">3068   if (pos == code_begin())                                              label = &quot;[Instructions begin]&quot;;</span>
<span class="line-modified">3069   if (pos == entry_point())                                             label = &quot;[Entry Point]&quot;;</span>
<span class="line-modified">3070   if (pos == verified_entry_point())                                    label = &quot;[Verified Entry Point]&quot;;</span>
<span class="line-modified">3071   if (has_method_handle_invokes() &amp;&amp; (pos == deopt_mh_handler_begin())) label = &quot;[Deopt MH Handler Code]&quot;;</span>
<span class="line-modified">3072   if (pos == consts_begin() &amp;&amp; pos != insts_begin())                    label = &quot;[Constants]&quot;;</span>
<span class="line-modified">3073   // Check stub_code before checking exception_handler or deopt_handler.</span>
<span class="line-modified">3074   if (pos == this-&gt;stub_begin())                                        label = &quot;[Stub Code]&quot;;</span>
<span class="line-added">3075   if (JVMCI_ONLY(_exception_offset &gt;= 0 &amp;&amp;) pos == exception_begin())           label = &quot;[Exception Handler]&quot;;</span>
<span class="line-added">3076   if (JVMCI_ONLY(_deopt_handler_begin != NULL &amp;&amp;) pos == deopt_handler_begin()) label = &quot;[Deopt Handler Code]&quot;;</span>
<span class="line-added">3077   return label;</span>
<span class="line-added">3078 }</span>
3079 
<a name="143" id="anc143"></a><span class="line-modified">3080 void nmethod::print_nmethod_labels(outputStream* stream, address block_begin, bool print_section_labels) const {</span>
<span class="line-added">3081   if (print_section_labels) {</span>
<span class="line-added">3082     const char* label = nmethod_section_label(block_begin);</span>
<span class="line-added">3083     if (label != NULL) {</span>
<span class="line-added">3084       stream-&gt;bol();</span>
<span class="line-added">3085       stream-&gt;print_cr(&quot;%s&quot;, label);</span>
<span class="line-added">3086     }</span>
<span class="line-added">3087   }</span>
3088 
3089   if (block_begin == entry_point()) {
<a name="144" id="anc144"></a><span class="line-modified">3090     Method* m = method();</span>
<span class="line-modified">3091     if (m != NULL) {</span>
3092       stream-&gt;print(&quot;  # &quot;);
3093       m-&gt;print_value_on(stream);
3094       stream-&gt;cr();
3095     }
<a name="145" id="anc145"></a><span class="line-modified">3096     if (m != NULL &amp;&amp; !is_osr_method()) {</span>
3097       ResourceMark rm;
3098       int sizeargs = m-&gt;size_of_parameters();
3099       BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, sizeargs);
3100       VMRegPair* regs   = NEW_RESOURCE_ARRAY(VMRegPair, sizeargs);
3101       {
3102         int sig_index = 0;
3103         if (!m-&gt;is_static())
3104           sig_bt[sig_index++] = T_OBJECT; // &#39;this&#39;
3105         for (SignatureStream ss(m-&gt;signature()); !ss.at_return_type(); ss.next()) {
3106           BasicType t = ss.type();
3107           sig_bt[sig_index++] = t;
3108           if (type2size[t] == 2) {
3109             sig_bt[sig_index++] = T_VOID;
3110           } else {
3111             assert(type2size[t] == 1, &quot;size is 1 or 2&quot;);
3112           }
3113         }
3114         assert(sig_index == sizeargs, &quot;&quot;);
3115       }
3116       const char* spname = &quot;sp&quot;; // make arch-specific?
3117       intptr_t out_preserve = SharedRuntime::java_calling_convention(sig_bt, regs, sizeargs, false);
3118       int stack_slot_offset = this-&gt;frame_size() * wordSize;
3119       int tab1 = 14, tab2 = 24;
3120       int sig_index = 0;
3121       int arg_index = (m-&gt;is_static() ? 0 : -1);
3122       bool did_old_sp = false;
3123       for (SignatureStream ss(m-&gt;signature()); !ss.at_return_type(); ) {
3124         bool at_this = (arg_index == -1);
3125         bool at_old_sp = false;
3126         BasicType t = (at_this ? T_OBJECT : ss.type());
3127         assert(t == sig_bt[sig_index], &quot;sigs in sync&quot;);
3128         if (at_this)
3129           stream-&gt;print(&quot;  # this: &quot;);
3130         else
3131           stream-&gt;print(&quot;  # parm%d: &quot;, arg_index);
3132         stream-&gt;move_to(tab1);
3133         VMReg fst = regs[sig_index].first();
3134         VMReg snd = regs[sig_index].second();
3135         if (fst-&gt;is_reg()) {
3136           stream-&gt;print(&quot;%s&quot;, fst-&gt;name());
3137           if (snd-&gt;is_valid())  {
3138             stream-&gt;print(&quot;:%s&quot;, snd-&gt;name());
3139           }
3140         } else if (fst-&gt;is_stack()) {
3141           int offset = fst-&gt;reg2stack() * VMRegImpl::stack_slot_size + stack_slot_offset;
3142           if (offset == stack_slot_offset)  at_old_sp = true;
3143           stream-&gt;print(&quot;[%s+0x%x]&quot;, spname, offset);
3144         } else {
3145           stream-&gt;print(&quot;reg%d:%d??&quot;, (int)(intptr_t)fst, (int)(intptr_t)snd);
3146         }
3147         stream-&gt;print(&quot; &quot;);
3148         stream-&gt;move_to(tab2);
3149         stream-&gt;print(&quot;= &quot;);
3150         if (at_this) {
3151           m-&gt;method_holder()-&gt;print_value_on(stream);
3152         } else {
3153           bool did_name = false;
<a name="146" id="anc146"></a><span class="line-modified">3154           if (!at_this &amp;&amp; ss.is_reference()) {</span>
<span class="line-modified">3155             Symbol* name = ss.as_symbol();</span>
<span class="line-modified">3156             name-&gt;print_value_on(stream);</span>
<span class="line-modified">3157             did_name = true;</span>


3158           }
3159           if (!did_name)
3160             stream-&gt;print(&quot;%s&quot;, type2name(t));
3161         }
3162         if (at_old_sp) {
3163           stream-&gt;print(&quot;  (%s of caller)&quot;, spname);
3164           did_old_sp = true;
3165         }
3166         stream-&gt;cr();
3167         sig_index += type2size[t];
3168         arg_index += 1;
3169         if (!at_this)  ss.next();
3170       }
3171       if (!did_old_sp) {
3172         stream-&gt;print(&quot;  # &quot;);
3173         stream-&gt;move_to(tab1);
3174         stream-&gt;print(&quot;[%s+0x%x]&quot;, spname, stack_slot_offset);
3175         stream-&gt;print(&quot;  (%s of caller)&quot;, spname);
3176         stream-&gt;cr();
3177       }
3178     }
3179   }
3180 }
3181 
<a name="147" id="anc147"></a><span class="line-modified">3182 // Returns whether this nmethod has code comments.</span>
<span class="line-modified">3183 bool nmethod::has_code_comment(address begin, address end) {</span>
<span class="line-modified">3184   // scopes?</span>
<span class="line-modified">3185   ScopeDesc* sd  = scope_desc_in(begin, end);</span>
<span class="line-added">3186   if (sd != NULL) return true;</span>
<span class="line-added">3187 </span>
<span class="line-added">3188   // relocations?</span>
<span class="line-added">3189   const char* str = reloc_string_for(begin, end);</span>
<span class="line-added">3190   if (str != NULL) return true;</span>
<span class="line-added">3191 </span>
<span class="line-added">3192   // implicit exceptions?</span>
<span class="line-added">3193   int cont_offset = ImplicitExceptionTable(this).continuation_offset(begin - code_begin());</span>
<span class="line-added">3194   if (cont_offset != 0) return true;</span>
<span class="line-added">3195 </span>
<span class="line-added">3196   return false;</span>
<span class="line-added">3197 }</span>
<span class="line-added">3198 </span>
<span class="line-added">3199 void nmethod::print_code_comment_on(outputStream* st, int column, address begin, address end) {</span>
<span class="line-added">3200   ImplicitExceptionTable implicit_table(this);</span>
<span class="line-added">3201   int pc_offset = begin - code_begin();</span>
<span class="line-added">3202   int cont_offset = implicit_table.continuation_offset(pc_offset);</span>
<span class="line-added">3203   bool oop_map_required = false;</span>
<span class="line-added">3204   if (cont_offset != 0) {</span>
<span class="line-added">3205     st-&gt;move_to(column, 6, 0);</span>
<span class="line-added">3206     if (pc_offset == cont_offset) {</span>
<span class="line-added">3207       st-&gt;print(&quot;; implicit exception: deoptimizes&quot;);</span>
<span class="line-added">3208       oop_map_required = true;</span>
<span class="line-added">3209     } else {</span>
<span class="line-added">3210       st-&gt;print(&quot;; implicit exception: dispatches to &quot; INTPTR_FORMAT, p2i(code_begin() + cont_offset));</span>
<span class="line-added">3211     }</span>
<span class="line-added">3212   }</span>
<span class="line-added">3213 </span>
<span class="line-added">3214   // Find an oopmap in (begin, end].  We use the odd half-closed</span>
<span class="line-added">3215   // interval so that oop maps and scope descs which are tied to the</span>
<span class="line-added">3216   // byte after a call are printed with the call itself.  OopMaps</span>
<span class="line-added">3217   // associated with implicit exceptions are printed with the implicit</span>
<span class="line-added">3218   // instruction.</span>
3219   address base = code_begin();
3220   ImmutableOopMapSet* oms = oop_maps();
3221   if (oms != NULL) {
3222     for (int i = 0, imax = oms-&gt;count(); i &lt; imax; i++) {
3223       const ImmutableOopMapPair* pair = oms-&gt;pair_at(i);
3224       const ImmutableOopMap* om = pair-&gt;get_from(oms);
3225       address pc = base + pair-&gt;pc_offset();
<a name="148" id="anc148"></a><span class="line-modified">3226       if (pc &gt;= begin) {</span>
<span class="line-modified">3227 #if INCLUDE_JVMCI</span>
<span class="line-modified">3228         bool is_implicit_deopt = implicit_table.continuation_offset(pair-&gt;pc_offset()) == (uint) pair-&gt;pc_offset();</span>
<span class="line-added">3229 #else</span>
<span class="line-added">3230         bool is_implicit_deopt = false;</span>
<span class="line-added">3231 #endif</span>
<span class="line-added">3232         if (is_implicit_deopt ? pc == begin : pc &gt; begin &amp;&amp; pc &lt;= end) {</span>
<span class="line-added">3233           st-&gt;move_to(column, 6, 0);</span>
3234           st-&gt;print(&quot;; &quot;);
3235           om-&gt;print_on(st);
<a name="149" id="anc149"></a><span class="line-added">3236           oop_map_required = false;</span>
3237         }
<a name="150" id="anc150"></a><span class="line-added">3238       }</span>
<span class="line-added">3239       if (pc &gt; end) {</span>
3240         break;
3241       }
3242     }
3243   }
<a name="151" id="anc151"></a><span class="line-added">3244   assert(!oop_map_required, &quot;missed oopmap&quot;);</span>
<span class="line-added">3245 </span>
<span class="line-added">3246   Thread* thread = Thread::current();</span>
3247 
3248   // Print any debug info present at this pc.
3249   ScopeDesc* sd  = scope_desc_in(begin, end);
3250   if (sd != NULL) {
<a name="152" id="anc152"></a><span class="line-modified">3251     st-&gt;move_to(column, 6, 0);</span>
3252     if (sd-&gt;bci() == SynchronizationEntryBCI) {
3253       st-&gt;print(&quot;;*synchronization entry&quot;);
3254     } else if (sd-&gt;bci() == AfterBci) {
3255       st-&gt;print(&quot;;* method exit (unlocked if synchronized)&quot;);
3256     } else if (sd-&gt;bci() == UnwindBci) {
3257       st-&gt;print(&quot;;* unwind (locked if synchronized)&quot;);
3258     } else if (sd-&gt;bci() == AfterExceptionBci) {
3259       st-&gt;print(&quot;;* unwind (unlocked if synchronized)&quot;);
3260     } else if (sd-&gt;bci() == UnknownBci) {
3261       st-&gt;print(&quot;;* unknown&quot;);
3262     } else if (sd-&gt;bci() == InvalidFrameStateBci) {
3263       st-&gt;print(&quot;;* invalid frame state&quot;);
3264     } else {
3265       if (sd-&gt;method() == NULL) {
3266         st-&gt;print(&quot;method is NULL&quot;);
3267       } else if (sd-&gt;method()-&gt;is_native()) {
3268         st-&gt;print(&quot;method is native&quot;);
3269       } else {
3270         Bytecodes::Code bc = sd-&gt;method()-&gt;java_code_at(sd-&gt;bci());
3271         st-&gt;print(&quot;;*%s&quot;, Bytecodes::name(bc));
3272         switch (bc) {
3273         case Bytecodes::_invokevirtual:
3274         case Bytecodes::_invokespecial:
3275         case Bytecodes::_invokestatic:
3276         case Bytecodes::_invokeinterface:
3277           {
<a name="153" id="anc153"></a><span class="line-modified">3278             Bytecode_invoke invoke(methodHandle(thread, sd-&gt;method()), sd-&gt;bci());</span>
3279             st-&gt;print(&quot; &quot;);
3280             if (invoke.name() != NULL)
3281               invoke.name()-&gt;print_symbol_on(st);
3282             else
3283               st-&gt;print(&quot;&lt;UNKNOWN&gt;&quot;);
3284             break;
3285           }
3286         case Bytecodes::_getfield:
3287         case Bytecodes::_putfield:
3288         case Bytecodes::_getstatic:
3289         case Bytecodes::_putstatic:
3290           {
<a name="154" id="anc154"></a><span class="line-modified">3291             Bytecode_field field(methodHandle(thread, sd-&gt;method()), sd-&gt;bci());</span>
3292             st-&gt;print(&quot; &quot;);
3293             if (field.name() != NULL)
3294               field.name()-&gt;print_symbol_on(st);
3295             else
3296               st-&gt;print(&quot;&lt;UNKNOWN&gt;&quot;);
3297           }
3298         default:
3299           break;
3300         }
3301       }
3302       st-&gt;print(&quot; {reexecute=%d rethrow=%d return_oop=%d}&quot;, sd-&gt;should_reexecute(), sd-&gt;rethrow_exception(), sd-&gt;return_oop());
3303     }
3304 
3305     // Print all scopes
3306     for (;sd != NULL; sd = sd-&gt;sender()) {
<a name="155" id="anc155"></a><span class="line-modified">3307       st-&gt;move_to(column, 6, 0);</span>
3308       st-&gt;print(&quot;; -&quot;);
<a name="156" id="anc156"></a><span class="line-added">3309       if (sd-&gt;should_reexecute()) {</span>
<span class="line-added">3310         st-&gt;print(&quot; (reexecute)&quot;);</span>
<span class="line-added">3311       }</span>
3312       if (sd-&gt;method() == NULL) {
3313         st-&gt;print(&quot;method is NULL&quot;);
3314       } else {
3315         sd-&gt;method()-&gt;print_short_name(st);
3316       }
3317       int lineno = sd-&gt;method()-&gt;line_number_from_bci(sd-&gt;bci());
3318       if (lineno != -1) {
3319         st-&gt;print(&quot;@%d (line %d)&quot;, sd-&gt;bci(), lineno);
3320       } else {
3321         st-&gt;print(&quot;@%d&quot;, sd-&gt;bci());
3322       }
3323       st-&gt;cr();
3324     }
3325   }
3326 
3327   // Print relocation information
<a name="157" id="anc157"></a><span class="line-added">3328   // Prevent memory leak: allocating without ResourceMark.</span>
<span class="line-added">3329   ResourceMark rm;</span>
3330   const char* str = reloc_string_for(begin, end);
3331   if (str != NULL) {
3332     if (sd != NULL) st-&gt;cr();
<a name="158" id="anc158"></a><span class="line-modified">3333     st-&gt;move_to(column, 6, 0);</span>
3334     st-&gt;print(&quot;;   {%s}&quot;, str);
3335   }
<a name="159" id="anc159"></a>





3336 }
3337 
<a name="160" id="anc160"></a><span class="line-added">3338 #endif</span>
<span class="line-added">3339 </span>
3340 class DirectNativeCallWrapper: public NativeCallWrapper {
3341 private:
3342   NativeCall* _call;
3343 
3344 public:
3345   DirectNativeCallWrapper(NativeCall* call) : _call(call) {}
3346 
3347   virtual address destination() const { return _call-&gt;destination(); }
3348   virtual address instruction_address() const { return _call-&gt;instruction_address(); }
3349   virtual address next_instruction_address() const { return _call-&gt;next_instruction_address(); }
3350   virtual address return_address() const { return _call-&gt;return_address(); }
3351 
3352   virtual address get_resolve_call_stub(bool is_optimized) const {
3353     if (is_optimized) {
3354       return SharedRuntime::get_resolve_opt_virtual_call_stub();
3355     }
3356     return SharedRuntime::get_resolve_virtual_call_stub();
3357   }
3358 
3359   virtual void set_destination_mt_safe(address dest) {
3360 #if INCLUDE_AOT
3361     if (UseAOT) {
3362       CodeBlob* callee = CodeCache::find_blob(dest);
3363       CompiledMethod* cm = callee-&gt;as_compiled_method_or_null();
3364       if (cm != NULL &amp;&amp; cm-&gt;is_far_code()) {
3365         // Temporary fix, see JDK-8143106
3366         CompiledDirectStaticCall* csc = CompiledDirectStaticCall::at(instruction_address());
<a name="161" id="anc161"></a><span class="line-modified">3367         csc-&gt;set_to_far(methodHandle(Thread::current(), cm-&gt;method()), dest);</span>
3368         return;
3369       }
3370     }
3371 #endif
3372     _call-&gt;set_destination_mt_safe(dest);
3373   }
3374 
3375   virtual void set_to_interpreted(const methodHandle&amp; method, CompiledICInfo&amp; info) {
3376     CompiledDirectStaticCall* csc = CompiledDirectStaticCall::at(instruction_address());
3377 #if INCLUDE_AOT
3378     if (info.to_aot()) {
3379       csc-&gt;set_to_far(method, info.entry());
3380     } else
3381 #endif
3382     {
3383       csc-&gt;set_to_interpreted(method, info.entry());
3384     }
3385   }
3386 
3387   virtual void verify() const {
3388     // make sure code pattern is actually a call imm32 instruction
3389     _call-&gt;verify();
3390     _call-&gt;verify_alignment();
3391   }
3392 
3393   virtual void verify_resolve_call(address dest) const {
3394     CodeBlob* db = CodeCache::find_blob_unsafe(dest);
3395     assert(db != NULL &amp;&amp; !db-&gt;is_adapter_blob(), &quot;must use stub!&quot;);
3396   }
3397 
3398   virtual bool is_call_to_interpreted(address dest) const {
3399     CodeBlob* cb = CodeCache::find_blob(_call-&gt;instruction_address());
3400     return cb-&gt;contains(dest);
3401   }
3402 
3403   virtual bool is_safe_for_patching() const { return false; }
3404 
3405   virtual NativeInstruction* get_load_instruction(virtual_call_Relocation* r) const {
3406     return nativeMovConstReg_at(r-&gt;cached_value());
3407   }
3408 
3409   virtual void *get_data(NativeInstruction* instruction) const {
3410     return (void*)((NativeMovConstReg*) instruction)-&gt;data();
3411   }
3412 
3413   virtual void set_data(NativeInstruction* instruction, intptr_t data) {
3414     ((NativeMovConstReg*) instruction)-&gt;set_data(data);
3415   }
3416 };
3417 
3418 NativeCallWrapper* nmethod::call_wrapper_at(address call) const {
3419   return new DirectNativeCallWrapper((NativeCall*) call);
3420 }
3421 
3422 NativeCallWrapper* nmethod::call_wrapper_before(address return_pc) const {
3423   return new DirectNativeCallWrapper(nativeCall_before(return_pc));
3424 }
3425 
3426 address nmethod::call_instruction_address(address pc) const {
3427   if (NativeCall::is_call_before(pc)) {
3428     NativeCall *ncall = nativeCall_before(pc);
3429     return ncall-&gt;instruction_address();
3430   }
3431   return NULL;
3432 }
3433 
3434 CompiledStaticCall* nmethod::compiledStaticCall_at(Relocation* call_site) const {
3435   return CompiledDirectStaticCall::at(call_site);
3436 }
3437 
3438 CompiledStaticCall* nmethod::compiledStaticCall_at(address call_site) const {
3439   return CompiledDirectStaticCall::at(call_site);
3440 }
3441 
3442 CompiledStaticCall* nmethod::compiledStaticCall_before(address return_addr) const {
3443   return CompiledDirectStaticCall::before(return_addr);
3444 }
3445 
<a name="162" id="anc162"></a><span class="line-modified">3446 #if defined(SUPPORT_DATA_STRUCTS)</span>

3447 void nmethod::print_value_on(outputStream* st) const {
3448   st-&gt;print(&quot;nmethod&quot;);
3449   print_on(st, NULL);
3450 }
<a name="163" id="anc163"></a><span class="line-added">3451 #endif</span>
<span class="line-added">3452 </span>
<span class="line-added">3453 #ifndef PRODUCT</span>
3454 
3455 void nmethod::print_calls(outputStream* st) {
3456   RelocIterator iter(this);
3457   while (iter.next()) {
3458     switch (iter.type()) {
3459     case relocInfo::virtual_call_type:
3460     case relocInfo::opt_virtual_call_type: {
3461       CompiledICLocker ml_verify(this);
3462       CompiledIC_at(&amp;iter)-&gt;print();
3463       break;
3464     }
3465     case relocInfo::static_call_type:
3466       st-&gt;print_cr(&quot;Static call at &quot; INTPTR_FORMAT, p2i(iter.reloc()-&gt;addr()));
3467       CompiledDirectStaticCall::at(iter.reloc())-&gt;print();
3468       break;
3469     default:
3470       break;
3471     }
3472   }
3473 }
3474 
<a name="164" id="anc164"></a>







3475 void nmethod::print_statistics() {
3476   ttyLocker ttyl;
3477   if (xtty != NULL)  xtty-&gt;head(&quot;statistics type=&#39;nmethod&#39;&quot;);
3478   native_nmethod_stats.print_native_nmethod_stats();
3479 #ifdef COMPILER1
3480   c1_java_nmethod_stats.print_nmethod_stats(&quot;C1&quot;);
3481 #endif
3482 #ifdef COMPILER2
3483   c2_java_nmethod_stats.print_nmethod_stats(&quot;C2&quot;);
3484 #endif
3485 #if INCLUDE_JVMCI
3486   jvmci_java_nmethod_stats.print_nmethod_stats(&quot;JVMCI&quot;);
3487 #endif
3488   unknown_java_nmethod_stats.print_nmethod_stats(&quot;Unknown&quot;);
3489   DebugInformationRecorder::print_statistics();
3490 #ifndef PRODUCT
3491   pc_nmethod_stats.print_pc_stats();
3492 #endif
3493   Dependencies::print_statistics();
3494   if (xtty != NULL)  xtty-&gt;tail(&quot;statistics&quot;);
3495 }
3496 
3497 #endif // !PRODUCT
3498 
3499 #if INCLUDE_JVMCI
<a name="165" id="anc165"></a><span class="line-modified">3500 void nmethod::update_speculation(JavaThread* thread) {</span>
<span class="line-modified">3501   jlong speculation = thread-&gt;pending_failed_speculation();</span>
<span class="line-modified">3502   if (speculation != 0) {</span>
<span class="line-modified">3503     guarantee(jvmci_nmethod_data() != NULL, &quot;failed speculation in nmethod without failed speculation list&quot;);</span>
<span class="line-modified">3504     jvmci_nmethod_data()-&gt;add_failed_speculation(this, speculation);</span>
<span class="line-modified">3505     thread-&gt;set_pending_failed_speculation(0);</span>










































3506   }
3507 }
3508 
<a name="166" id="anc166"></a><span class="line-modified">3509 const char* nmethod::jvmci_name() {</span>
<span class="line-modified">3510   if (jvmci_nmethod_data() != NULL) {</span>
<span class="line-modified">3511     return jvmci_nmethod_data()-&gt;name();</span>























































3512   }
3513   return NULL;
3514 }
3515 #endif
<a name="167" id="anc167"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="167" type="hidden" />
</body>
</html>
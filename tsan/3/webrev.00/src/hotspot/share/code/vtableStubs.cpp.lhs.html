<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/code/vtableStubs.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/vtableStubs.hpp&quot;
 27 #include &quot;compiler/compileBroker.hpp&quot;
 28 #include &quot;compiler/disassembler.hpp&quot;
 29 #include &quot;logging/log.hpp&quot;
 30 #include &quot;memory/allocation.inline.hpp&quot;
 31 #include &quot;memory/resourceArea.hpp&quot;
 32 #include &quot;oops/instanceKlass.hpp&quot;
 33 #include &quot;oops/klassVtable.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
 35 #include &quot;prims/forte.hpp&quot;
 36 #include &quot;prims/jvmtiExport.hpp&quot;
 37 #include &quot;runtime/handles.inline.hpp&quot;
 38 #include &quot;runtime/mutexLocker.hpp&quot;
 39 #include &quot;runtime/sharedRuntime.hpp&quot;
 40 #include &quot;utilities/align.hpp&quot;
<a name="2" id="anc2"></a>
 41 #ifdef COMPILER2
 42 #include &quot;opto/matcher.hpp&quot;
 43 #endif
 44 
 45 // -----------------------------------------------------------------------------------------
 46 // Implementation of VtableStub
 47 
 48 address VtableStub::_chunk             = NULL;
 49 address VtableStub::_chunk_end         = NULL;
 50 VMReg   VtableStub::_receiver_location = VMRegImpl::Bad();
 51 
 52 
 53 void* VtableStub::operator new(size_t size, int code_size) throw() {
 54   assert_lock_strong(VtableStubs_lock);
 55   assert(size == sizeof(VtableStub), &quot;mismatched size&quot;);
 56   // compute real VtableStub size (rounded to nearest word)
 57   const int real_size = align_up(code_size + (int)sizeof(VtableStub), wordSize);
 58   // malloc them in chunks to minimize header overhead
 59   const int chunk_factor = 32;
 60   if (_chunk == NULL || _chunk + real_size &gt; _chunk_end) {
 61     const int bytes = chunk_factor * real_size + pd_code_alignment();
 62 
 63    // There is a dependency on the name of the blob in src/share/vm/prims/jvmtiCodeBlobEvents.cpp
 64    // If changing the name, update the other file accordingly.
 65     VtableBlob* blob = VtableBlob::create(&quot;vtable chunks&quot;, bytes);
 66     if (blob == NULL) {
 67       return NULL;
 68     }
 69     _chunk = blob-&gt;content_begin();
 70     _chunk_end = _chunk + bytes;
 71     Forte::register_stub(&quot;vtable stub&quot;, _chunk, _chunk_end);
 72     align_chunk();
 73   }
 74   assert(_chunk + real_size &lt;= _chunk_end, &quot;bad allocation&quot;);
 75   void* res = _chunk;
 76   _chunk += real_size;
 77   align_chunk();
 78  return res;
 79 }
 80 
 81 
 82 void VtableStub::print_on(outputStream* st) const {
<a name="3" id="anc3"></a><span class="line-modified"> 83   st-&gt;print(&quot;vtable stub (index = %d, receiver_location = &quot; INTX_FORMAT &quot;, code = [&quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;[)&quot;,</span>
 84              index(), p2i(receiver_location()), p2i(code_begin()), p2i(code_end()));
 85 }
 86 
<a name="4" id="anc4"></a>
 87 
 88 // -----------------------------------------------------------------------------------------
 89 // Implementation of VtableStubs
 90 //
 91 // For each hash value there&#39;s a linked list of vtable stubs (with that
 92 // hash value). Each list is anchored in a little hash _table, indexed
 93 // by that hash value.
 94 
 95 VtableStub* VtableStubs::_table[VtableStubs::N];
 96 int VtableStubs::_number_of_vtable_stubs = 0;
 97 int VtableStubs::_vtab_stub_size = 0;
 98 int VtableStubs::_itab_stub_size = 0;
 99 
100 #if defined(PRODUCT)
101   // These values are good for the PRODUCT case (no tracing).
102   static const int first_vtableStub_size =  64;
103   static const int first_itableStub_size = 256;
104 #else
105   // These values are good for the non-PRODUCT case (when tracing can be switched on).
106   // To find out, run test workload with
107   //   -Xlog:vtablestubs=Trace -XX:+CountCompiledCalls -XX:+DebugVtables
108   // and use the reported &quot;estimate&quot; value.
109   // Here is a list of observed worst-case values:
110   //               vtable  itable
111   // aarch64:         460     324
112   // arm:               ?       ?
113   // ppc (linux, BE): 404     288
114   // ppc (linux, LE): 356     276
115   // ppc (AIX):       416     296
116   // s390x:           408     256
117   // Solaris-sparc:   792     348
118   // x86 (Linux):     670     309
119   // x86 (MacOS):     682     321
120   static const int first_vtableStub_size = 1024;
121   static const int first_itableStub_size =  512;
122 #endif
123 
124 
125 void VtableStubs::initialize() {
126   VtableStub::_receiver_location = SharedRuntime::name_for_receiver();
127   {
<a name="5" id="anc5"></a><span class="line-modified">128     MutexLockerEx ml(VtableStubs_lock, Mutex::_no_safepoint_check_flag);</span>
129     assert(_number_of_vtable_stubs == 0, &quot;potential performance bug: VtableStubs initialized more than once&quot;);
<a name="6" id="anc6"></a><span class="line-modified">130     assert(is_power_of_2(N), &quot;N must be a power of 2&quot;);</span>
131     for (int i = 0; i &lt; N; i++) {
132       _table[i] = NULL;
133     }
134   }
135 }
136 
137 
138 int VtableStubs::code_size_limit(bool is_vtable_stub) {
139   if (is_vtable_stub) {
140     return _vtab_stub_size &gt; 0 ? _vtab_stub_size : first_vtableStub_size;
141   } else { // itable stub
142     return _itab_stub_size &gt; 0 ? _itab_stub_size : first_itableStub_size;
143   }
144 }   // code_size_limit
145 
146 
147 void VtableStubs::check_and_set_size_limit(bool is_vtable_stub,
148                                            int  code_size,
149                                            int  padding) {
150   const char* name = is_vtable_stub ? &quot;vtable&quot; : &quot;itable&quot;;
151 
152   guarantee(code_size &lt;= code_size_limit(is_vtable_stub),
153             &quot;buffer overflow in %s stub, code_size is %d, limit is %d&quot;, name, code_size, code_size_limit(is_vtable_stub));
154 
155   if (is_vtable_stub) {
156     if (log_is_enabled(Trace, vtablestubs)) {
157       if ( (_vtab_stub_size &gt; 0) &amp;&amp; ((code_size + padding) &gt; _vtab_stub_size) ) {
158         log_trace(vtablestubs)(&quot;%s size estimate needed adjustment from %d to %d bytes&quot;,
159                                name, _vtab_stub_size, code_size + padding);
160       }
161     }
162     if ( (code_size + padding) &gt; _vtab_stub_size ) {
163       _vtab_stub_size = code_size + padding;
164     }
165   } else {  // itable stub
166     if (log_is_enabled(Trace, vtablestubs)) {
167       if ( (_itab_stub_size &gt; 0) &amp;&amp; ((code_size + padding) &gt; _itab_stub_size) ) {
168         log_trace(vtablestubs)(&quot;%s size estimate needed adjustment from %d to %d bytes&quot;,
169                                name, _itab_stub_size, code_size + padding);
170       }
171     }
172     if ( (code_size + padding) &gt; _itab_stub_size ) {
173       _itab_stub_size = code_size + padding;
174     }
175   }
176   return;
177 }   // check_and_set_size_limit
178 
179 
180 void VtableStubs::bookkeeping(MacroAssembler* masm, outputStream* out, VtableStub* s,
181                               address npe_addr, address ame_addr,   bool is_vtable_stub,
182                               int     index,    int     slop_bytes, int  index_dependent_slop) {
183   const char* name        = is_vtable_stub ? &quot;vtable&quot; : &quot;itable&quot;;
184   const int   stub_length = code_size_limit(is_vtable_stub);
185 
186   if (log_is_enabled(Trace, vtablestubs)) {
187     log_trace(vtablestubs)(&quot;%s #%d at &quot; PTR_FORMAT &quot;: size: %d, estimate: %d, slop area: %d&quot;,
188                            name, index, p2i(s-&gt;code_begin()),
189                            (int)(masm-&gt;pc() - s-&gt;code_begin()),
190                            stub_length,
191                            (int)(s-&gt;code_end() - masm-&gt;pc()));
192   }
193   guarantee(masm-&gt;pc() &lt;= s-&gt;code_end(), &quot;%s #%d: overflowed buffer, estimated len: %d, actual len: %d, overrun: %d&quot;,
194                                          name, index, stub_length,
195                                          (int)(masm-&gt;pc() - s-&gt;code_begin()),
196                                          (int)(masm-&gt;pc() - s-&gt;code_end()));
197   assert((masm-&gt;pc() + index_dependent_slop) &lt;= s-&gt;code_end(), &quot;%s #%d: spare space for 32-bit offset: required = %d, available = %d&quot;,
198                                          name, index, index_dependent_slop,
199                                          (int)(s-&gt;code_end() - masm-&gt;pc()));
200 
201   // After the first vtable/itable stub is generated, we have a much
202   // better estimate for the stub size. Remember/update this
203   // estimate after some sanity checks.
204   check_and_set_size_limit(is_vtable_stub, masm-&gt;offset(), slop_bytes);
205   s-&gt;set_exception_points(npe_addr, ame_addr);
206 }
207 
208 
209 address VtableStubs::find_stub(bool is_vtable_stub, int vtable_index) {
210   assert(vtable_index &gt;= 0, &quot;must be positive&quot;);
211 
212   VtableStub* s;
213   {
<a name="7" id="anc7"></a><span class="line-modified">214     MutexLockerEx ml(VtableStubs_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">215     s = ShareVtableStubs ? lookup(is_vtable_stub, vtable_index) : NULL;</span>
216     if (s == NULL) {
217       if (is_vtable_stub) {
218         s = create_vtable_stub(vtable_index);
219       } else {
220         s = create_itable_stub(vtable_index);
221       }
222 
223       // Creation of vtable or itable can fail if there is not enough free space in the code cache.
224       if (s == NULL) {
225         return NULL;
226       }
227 
228       enter(is_vtable_stub, vtable_index, s);
229       if (PrintAdapterHandlers) {
230         tty-&gt;print_cr(&quot;Decoding VtableStub %s[%d]@&quot; INTX_FORMAT,
231                       is_vtable_stub? &quot;vtbl&quot;: &quot;itbl&quot;, vtable_index, p2i(VtableStub::receiver_location()));
232         Disassembler::decode(s-&gt;code_begin(), s-&gt;code_end());
233       }
234       // Notify JVMTI about this stub. The event will be recorded by the enclosing
235       // JvmtiDynamicCodeEventCollector and posted when this thread has released
<a name="8" id="anc8"></a><span class="line-modified">236       // all locks.</span>

237       if (JvmtiExport::should_post_dynamic_code_generated()) {
238         JvmtiExport::post_dynamic_code_generated_while_holding_locks(is_vtable_stub? &quot;vtable stub&quot;: &quot;itable stub&quot;,
239                                                                      s-&gt;code_begin(), s-&gt;code_end());
240       }
241     }
242   }
243   return s-&gt;entry_point();
244 }
245 
246 
247 inline uint VtableStubs::hash(bool is_vtable_stub, int vtable_index){
248   // Assumption: receiver_location &lt; 4 in most cases.
249   int hash = ((vtable_index &lt;&lt; 2) ^ VtableStub::receiver_location()-&gt;value()) + vtable_index;
250   return (is_vtable_stub ? ~hash : hash)  &amp; mask;
251 }
252 
253 
254 VtableStub* VtableStubs::lookup(bool is_vtable_stub, int vtable_index) {
255   assert_lock_strong(VtableStubs_lock);
256   unsigned hash = VtableStubs::hash(is_vtable_stub, vtable_index);
257   VtableStub* s = _table[hash];
258   while( s &amp;&amp; !s-&gt;matches(is_vtable_stub, vtable_index)) s = s-&gt;next();
259   return s;
260 }
261 
262 
263 void VtableStubs::enter(bool is_vtable_stub, int vtable_index, VtableStub* s) {
264   assert_lock_strong(VtableStubs_lock);
265   assert(s-&gt;matches(is_vtable_stub, vtable_index), &quot;bad vtable stub&quot;);
266   unsigned int h = VtableStubs::hash(is_vtable_stub, vtable_index);
267   // enter s at the beginning of the corresponding list
268   s-&gt;set_next(_table[h]);
269   _table[h] = s;
270   _number_of_vtable_stubs++;
271 }
272 
273 VtableStub* VtableStubs::entry_point(address pc) {
<a name="9" id="anc9"></a><span class="line-modified">274   MutexLockerEx ml(VtableStubs_lock, Mutex::_no_safepoint_check_flag);</span>
275   VtableStub* stub = (VtableStub*)(pc - VtableStub::entry_offset());
276   uint hash = VtableStubs::hash(stub-&gt;is_vtable_stub(), stub-&gt;index());
277   VtableStub* s;
278   for (s = _table[hash]; s != NULL &amp;&amp; s != stub; s = s-&gt;next()) {}
279   return (s == stub) ? s : NULL;
280 }
281 
282 bool VtableStubs::contains(address pc) {
283   // simple solution for now - we may want to use
284   // a faster way if this function is called often
285   return stub_containing(pc) != NULL;
286 }
287 
288 
289 VtableStub* VtableStubs::stub_containing(address pc) {
290   // Note: No locking needed since any change to the data structure
291   //       happens with an atomic store into it (we don&#39;t care about
292   //       consistency with the _number_of_vtable_stubs counter).
293   for (int i = 0; i &lt; N; i++) {
294     for (VtableStub* s = _table[i]; s != NULL; s = s-&gt;next()) {
295       if (s-&gt;contains(pc)) return s;
296     }
297   }
298   return NULL;
299 }
300 
301 void vtableStubs_init() {
302   VtableStubs::initialize();
303 }
304 
305 void VtableStubs::vtable_stub_do(void f(VtableStub*)) {
306     for (int i = 0; i &lt; N; i++) {
307         for (VtableStub* s = _table[i]; s != NULL; s = s-&gt;next()) {
308             f(s);
309         }
310     }
311 }
312 
313 
314 //-----------------------------------------------------------------------------------------------------
315 // Non-product code
316 #ifndef PRODUCT
317 
318 extern &quot;C&quot; void bad_compiled_vtable_index(JavaThread* thread, oop receiver, int index) {
319   ResourceMark rm;
320   HandleMark hm;
321   Klass* klass = receiver-&gt;klass();
322   InstanceKlass* ik = InstanceKlass::cast(klass);
323   klassVtable vt = ik-&gt;vtable();
324   ik-&gt;print();
325   fatal(&quot;bad compiled vtable dispatch: receiver &quot; INTPTR_FORMAT &quot;, &quot;
326         &quot;index %d (vtable length %d)&quot;,
327         p2i(receiver), index, vt.length());
328 }
329 
330 #endif // PRODUCT
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/code/codeCache.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CODE_CODECACHE_HPP
 26 #define SHARE_CODE_CODECACHE_HPP
 27 
 28 #include &quot;code/codeBlob.hpp&quot;
 29 #include &quot;code/nmethod.hpp&quot;
 30 #include &quot;gc/shared/gcBehaviours.hpp&quot;
 31 #include &quot;memory/allocation.hpp&quot;
 32 #include &quot;memory/heap.hpp&quot;
 33 #include &quot;oops/instanceKlass.hpp&quot;
 34 #include &quot;oops/oopsHierarchy.hpp&quot;
 35 #include &quot;runtime/mutexLocker.hpp&quot;
 36 
 37 // The CodeCache implements the code cache for various pieces of generated
 38 // code, e.g., compiled java methods, runtime stubs, transition frames, etc.
 39 // The entries in the CodeCache are all CodeBlob&#39;s.
 40 
 41 // -- Implementation --
 42 // The CodeCache consists of one or more CodeHeaps, each of which contains
 43 // CodeBlobs of a specific CodeBlobType. Currently heaps for the following
 44 // types are available:
 45 //  - Non-nmethods: Non-nmethods like Buffers, Adapters and Runtime Stubs
 46 //  - Profiled nmethods: nmethods that are profiled, i.e., those
 47 //    executed at level 2 or 3
 48 //  - Non-Profiled nmethods: nmethods that are not profiled, i.e., those
 49 //    executed at level 1 or 4 and native methods
 50 //  - All: Used for code of all types if code cache segmentation is disabled.
 51 //
 52 // In the rare case of the non-nmethod code heap getting full, non-nmethod code
 53 // will be stored in the non-profiled code heap as a fallback solution.
 54 //
 55 // Depending on the availability of compilers and TieredCompilation there
 56 // may be fewer heaps. The size of the code heaps depends on the values of
 57 // ReservedCodeCacheSize, NonProfiledCodeHeapSize and ProfiledCodeHeapSize
 58 // (see CodeCache::heap_available(..) and CodeCache::initialize_heaps(..)
 59 // for details).
 60 //
 61 // Code cache segmentation is controlled by the flag SegmentedCodeCache.
 62 // If turned off, all code types are stored in a single code heap. By default
 63 // code cache segmentation is turned on if TieredCompilation is enabled and
 64 // ReservedCodeCacheSize &gt;= 240 MB.
 65 //
 66 // All methods of the CodeCache accepting a CodeBlobType only apply to
 67 // CodeBlobs of the given type. For example, iteration over the
 68 // CodeBlobs of a specific type can be done by using CodeCache::first_blob(..)
 69 // and CodeCache::next_blob(..) and providing the corresponding CodeBlobType.
 70 //
 71 // IMPORTANT: If you add new CodeHeaps to the code cache or change the
 72 // existing ones, make sure to adapt the dtrace scripts (jhelper.d) for
 73 // Solaris and BSD.
 74 
 75 class ExceptionCache;
 76 class KlassDepChange;
 77 class OopClosure;
 78 class ShenandoahParallelCodeHeapIterator;
 79 
 80 class CodeCache : AllStatic {
 81   friend class VMStructs;
 82   friend class JVMCIVMStructs;
 83   template &lt;class T, class Filter&gt; friend class CodeBlobIterator;
 84   friend class WhiteBox;
 85   friend class CodeCacheLoader;
 86   friend class ShenandoahParallelCodeHeapIterator;
 87  private:
 88   // CodeHeaps of the cache
 89   static GrowableArray&lt;CodeHeap*&gt;* _heaps;
 90   static GrowableArray&lt;CodeHeap*&gt;* _compiled_heaps;
 91   static GrowableArray&lt;CodeHeap*&gt;* _nmethod_heaps;
 92   static GrowableArray&lt;CodeHeap*&gt;* _allocable_heaps;
 93 
 94   static address _low_bound;                            // Lower bound of CodeHeap addresses
 95   static address _high_bound;                           // Upper bound of CodeHeap addresses
 96   static int _number_of_nmethods_with_dependencies;     // Total number of nmethods with dependencies
 97   static uint8_t _unloading_cycle;                      // Global state for recognizing old nmethods that need to be unloaded
 98 
 99   static ExceptionCache* volatile _exception_cache_purge_list;
100 
101   // CodeHeap management
102   static void initialize_heaps();                             // Initializes the CodeHeaps
103   // Check the code heap sizes set by the user via command line
104   static void check_heap_sizes(size_t non_nmethod_size, size_t profiled_size, size_t non_profiled_size, size_t cache_size, bool all_set);
105   // Creates a new heap with the given name and size, containing CodeBlobs of the given type
106   static void add_heap(ReservedSpace rs, const char* name, int code_blob_type);
107   static CodeHeap* get_code_heap_containing(void* p);         // Returns the CodeHeap containing the given pointer, or NULL
108   static CodeHeap* get_code_heap(const CodeBlob* cb);         // Returns the CodeHeap for the given CodeBlob
109   static CodeHeap* get_code_heap(int code_blob_type);         // Returns the CodeHeap for the given CodeBlobType
110   // Returns the name of the VM option to set the size of the corresponding CodeHeap
111   static const char* get_code_heap_flag_name(int code_blob_type);
112   static ReservedCodeSpace reserve_heap_memory(size_t size);  // Reserves one continuous chunk of memory for the CodeHeaps
113 
114   // Iteration
115   static CodeBlob* first_blob(CodeHeap* heap);                // Returns the first CodeBlob on the given CodeHeap
116   static CodeBlob* first_blob(int code_blob_type);            // Returns the first CodeBlob of the given type
117   static CodeBlob* next_blob(CodeHeap* heap, CodeBlob* cb);   // Returns the next CodeBlob on the given CodeHeap
118 
119   static size_t bytes_allocated_in_freelists();
120   static int    allocated_segments();
121   static size_t freelists_length();
122 
123   // Make private to prevent unsafe calls.  Not all CodeBlob*&#39;s are embedded in a CodeHeap.
124   static bool contains(CodeBlob *p) { fatal(&quot;don&#39;t call me!&quot;); return false; }
125 
126  public:
127   // Initialization
128   static void initialize();
129   static size_t page_size(bool aligned = true, size_t min_pages = 1); // Returns the page size used by the CodeCache
130 
131   static int code_heap_compare(CodeHeap* const &amp;lhs, CodeHeap* const &amp;rhs);
132 
133   static void add_heap(CodeHeap* heap);
134   static const GrowableArray&lt;CodeHeap*&gt;* heaps() { return _heaps; }
135   static const GrowableArray&lt;CodeHeap*&gt;* compiled_heaps() { return _compiled_heaps; }
136   static const GrowableArray&lt;CodeHeap*&gt;* nmethod_heaps() { return _nmethod_heaps; }
137 
138   // Allocation/administration
139   static CodeBlob* allocate(int size, int code_blob_type, int orig_code_blob_type = CodeBlobType::All); // allocates a new CodeBlob
140   static void commit(CodeBlob* cb);                        // called when the allocated CodeBlob has been filled
141   static int  alignment_unit();                            // guaranteed alignment of all CodeBlobs
142   static int  alignment_offset();                          // guaranteed offset of first CodeBlob byte within alignment unit (i.e., allocation header)
143   static void free(CodeBlob* cb);                          // frees a CodeBlob
144   static void free_unused_tail(CodeBlob* cb, size_t used); // frees the unused tail of a CodeBlob (only used by TemplateInterpreter::initialize())
145   static bool contains(void *p);                           // returns whether p is included
146   static bool contains(nmethod* nm);                       // returns whether nm is included
147   static void blobs_do(void f(CodeBlob* cb));              // iterates over all CodeBlobs
148   static void blobs_do(CodeBlobClosure* f);                // iterates over all CodeBlobs
149   static void nmethods_do(void f(nmethod* nm));            // iterates over all nmethods
<a name="1" id="anc1"></a><span class="line-modified">150   static void metadata_do(MetadataClosure* f);             // iterates over metadata in alive nmethods</span>
151 
152   // Lookup
153   static CodeBlob* find_blob(void* start);              // Returns the CodeBlob containing the given address
154   static CodeBlob* find_blob_unsafe(void* start);       // Same as find_blob but does not fail if looking up a zombie method
155   static nmethod*  find_nmethod(void* start);           // Returns the nmethod containing the given address
156   static CompiledMethod* find_compiled(void* start);
157 
158   static int       blob_count();                        // Returns the total number of CodeBlobs in the cache
159   static int       blob_count(int code_blob_type);
160   static int       adapter_count();                     // Returns the total number of Adapters in the cache
161   static int       adapter_count(int code_blob_type);
162   static int       nmethod_count();                     // Returns the total number of nmethods in the cache
163   static int       nmethod_count(int code_blob_type);
164 
165   // GC support
166   static void verify_oops();
167   // If any oops are not marked this method unloads (i.e., breaks root links
168   // to) any unmarked codeBlobs in the cache.  Sets &quot;marked_for_unloading&quot;
169   // to &quot;true&quot; iff some code got unloaded.
170   // &quot;unloading_occurred&quot; controls whether metadata should be cleaned because of class unloading.
171   class UnloadingScope: StackObj {
172     ClosureIsUnloadingBehaviour _is_unloading_behaviour;
<a name="2" id="anc2"></a><span class="line-added">173     IsUnloadingBehaviour*       _saved_behaviour;</span>
174 
175   public:
176     UnloadingScope(BoolObjectClosure* is_alive);
177     ~UnloadingScope();
178   };
179 
180   static void do_unloading(BoolObjectClosure* is_alive, bool unloading_occurred);
181   static uint8_t unloading_cycle() { return _unloading_cycle; }
182   static void increment_unloading_cycle();
183   static void release_exception_cache(ExceptionCache* entry);
184   static void purge_exception_caches();
185 
186   // Printing/debugging
187   static void print();                           // prints summary
188   static void print_internals();
189   static void print_memory_overhead();
190   static void verify();                          // verifies the code cache
191   static void print_trace(const char* event, CodeBlob* cb, int size = 0) PRODUCT_RETURN;
192   static void print_summary(outputStream* st, bool detailed = true); // Prints a summary of the code cache usage
193   static void log_state(outputStream* st);
194   static const char* get_code_heap_name(int code_blob_type)  { return (heap_available(code_blob_type) ? get_code_heap(code_blob_type)-&gt;name() : &quot;Unused&quot;); }
195   static void report_codemem_full(int code_blob_type, bool print);
196 
197   // Dcmd (Diagnostic commands)
198   static void print_codelist(outputStream* st);
199   static void print_layout(outputStream* st);
200 
201   // The full limits of the codeCache
202   static address low_bound()                          { return _low_bound; }
203   static address low_bound(int code_blob_type);
204   static address high_bound()                         { return _high_bound; }
205   static address high_bound(int code_blob_type);
206 
207   // Have to use far call instructions to call this pc.
208   static bool is_far_target(address pc);
209 
210   // Profiling
211   static size_t capacity();
212   static size_t unallocated_capacity(int code_blob_type);
213   static size_t unallocated_capacity();
214   static size_t max_capacity();
215 
216   static double reverse_free_ratio(int code_blob_type);
217 
218   static void clear_inline_caches();                  // clear all inline caches
219   static void cleanup_inline_caches();                // clean unloaded/zombie nmethods from inline caches
220 
221   // Returns true if an own CodeHeap for the given CodeBlobType is available
222   static bool heap_available(int code_blob_type);
223 
224   // Returns the CodeBlobType for the given CompiledMethod
225   static int get_code_blob_type(CompiledMethod* cm) {
226     return get_code_heap(cm)-&gt;code_blob_type();
227   }
228 
229   static bool code_blob_type_accepts_compiled(int type) {
230     bool result = type == CodeBlobType::All || type &lt;= CodeBlobType::MethodProfiled;
231     AOT_ONLY( result = result || type == CodeBlobType::AOT; )
232     return result;
233   }
234 
235   static bool code_blob_type_accepts_nmethod(int type) {
236     return type == CodeBlobType::All || type &lt;= CodeBlobType::MethodProfiled;
237   }
238 
239   static bool code_blob_type_accepts_allocable(int type) {
240     return type &lt;= CodeBlobType::All;
241   }
242 
243 
244   // Returns the CodeBlobType for the given compilation level
245   static int get_code_blob_type(int comp_level) {
246     if (comp_level == CompLevel_none ||
247         comp_level == CompLevel_simple ||
248         comp_level == CompLevel_full_optimization) {
249       // Non profiled methods
250       return CodeBlobType::MethodNonProfiled;
251     } else if (comp_level == CompLevel_limited_profile ||
252                comp_level == CompLevel_full_profile) {
253       // Profiled methods
254       return CodeBlobType::MethodProfiled;
255     }
256     ShouldNotReachHere();
257     return 0;
258   }
259 
260   static void verify_clean_inline_caches();
261   static void verify_icholder_relocations();
262 
263   // Deoptimization
264  private:
265   static int  mark_for_deoptimization(KlassDepChange&amp; changes);
266 
267  public:
268   static void mark_all_nmethods_for_deoptimization();
269   static int  mark_for_deoptimization(Method* dependee);
270   static void make_marked_nmethods_not_entrant();
271 
272   // Flushing and deoptimization
273   static void flush_dependents_on(InstanceKlass* dependee);
<a name="3" id="anc3"></a><span class="line-added">274 </span>
<span class="line-added">275   // RedefineClasses support</span>
276   // Flushing and deoptimization in case of evolution
277   static void mark_for_evol_deoptimization(InstanceKlass* dependee);
278   static int  mark_dependents_for_evol_deoptimization();
<a name="4" id="anc4"></a><span class="line-added">279   static void mark_all_nmethods_for_evol_deoptimization();</span>
280   static void flush_evol_dependents();
<a name="5" id="anc5"></a><span class="line-added">281   static void old_nmethods_do(MetadataClosure* f);</span>
<span class="line-added">282   static void unregister_old_nmethod(CompiledMethod* c);</span>
<span class="line-added">283 </span>
284   // Support for fullspeed debugging
285   static void flush_dependents_on_method(const methodHandle&amp; dependee);
286 
287   // tells how many nmethods have dependencies
288   static int number_of_nmethods_with_dependencies();
289 
290   static int get_codemem_full_count(int code_blob_type) {
291     CodeHeap* heap = get_code_heap(code_blob_type);
292     return (heap != NULL) ? heap-&gt;full_count() : 0;
293   }
294 
295   // CodeHeap State Analytics.
296   // interface methods for CodeHeap printing, called by CompileBroker
<a name="6" id="anc6"></a><span class="line-modified">297   static void aggregate(outputStream *out, size_t granularity);</span>
298   static void discard(outputStream *out);
299   static void print_usedSpace(outputStream *out);
300   static void print_freeSpace(outputStream *out);
301   static void print_count(outputStream *out);
302   static void print_space(outputStream *out);
303   static void print_age(outputStream *out);
304   static void print_names(outputStream *out);
305 };
306 
307 
308 // Iterator to iterate over nmethods in the CodeCache.
309 template &lt;class T, class Filter&gt; class CodeBlobIterator : public StackObj {
310  public:
311   enum LivenessFilter { all_blobs, only_alive, only_alive_and_not_unloading };
312 
313  private:
314   CodeBlob* _code_blob;   // Current CodeBlob
315   GrowableArrayIterator&lt;CodeHeap*&gt; _heap;
316   GrowableArrayIterator&lt;CodeHeap*&gt; _end;
317   bool _only_alive;
318   bool _only_not_unloading;
319 
320  public:
321   CodeBlobIterator(LivenessFilter filter, T* nm = NULL)
322     : _only_alive(filter == only_alive || filter == only_alive_and_not_unloading),
323       _only_not_unloading(filter == only_alive_and_not_unloading)
324   {
325     if (Filter::heaps() == NULL) {
326       return;
327     }
328     _heap = Filter::heaps()-&gt;begin();
329     _end = Filter::heaps()-&gt;end();
330     // If set to NULL, initialized by first call to next()
331     _code_blob = (CodeBlob*)nm;
332     if (nm != NULL) {
333       while(!(*_heap)-&gt;contains_blob(_code_blob)) {
334         ++_heap;
335       }
336       assert((*_heap)-&gt;contains_blob(_code_blob), &quot;match not found&quot;);
337     }
338   }
339 
340   // Advance iterator to next blob
341   bool next() {
342     assert_locked_or_safepoint(CodeCache_lock);
343 
344     for (;;) {
345       // Walk through heaps as required
346       if (!next_blob()) {
347         if (_heap == _end) {
348           return false;
349         }
350         ++_heap;
351         continue;
352       }
353 
354       // Filter is_alive as required
355       if (_only_alive &amp;&amp; !_code_blob-&gt;is_alive()) {
356         continue;
357       }
358 
359       // Filter is_unloading as required
360       if (_only_not_unloading) {
361         CompiledMethod* cm = _code_blob-&gt;as_compiled_method_or_null();
362         if (cm != NULL &amp;&amp; cm-&gt;is_unloading()) {
363           continue;
364         }
365       }
366 
367       return true;
368     }
369   }
370 
371   bool end()  const { return _code_blob == NULL; }
372   T* method() const { return (T*)_code_blob; }
373 
374 private:
375 
376   // Advance iterator to the next blob in the current code heap
377   bool next_blob() {
378     if (_heap == _end) {
379       return false;
380     }
381     CodeHeap *heap = *_heap;
382     // Get first method CodeBlob
383     if (_code_blob == NULL) {
384       _code_blob = CodeCache::first_blob(heap);
385       if (_code_blob == NULL) {
386         return false;
387       } else if (Filter::apply(_code_blob)) {
388         return true;
389       }
390     }
391     // Search for next method CodeBlob
392     _code_blob = CodeCache::next_blob(heap, _code_blob);
393     while (_code_blob != NULL &amp;&amp; !Filter::apply(_code_blob)) {
394       _code_blob = CodeCache::next_blob(heap, _code_blob);
395     }
396     return _code_blob != NULL;
397   }
398 };
399 
400 
401 struct CompiledMethodFilter {
402   static bool apply(CodeBlob* cb) { return cb-&gt;is_compiled(); }
403   static const GrowableArray&lt;CodeHeap*&gt;* heaps() { return CodeCache::compiled_heaps(); }
404 };
405 
406 
407 struct NMethodFilter {
408   static bool apply(CodeBlob* cb) { return cb-&gt;is_nmethod(); }
409   static const GrowableArray&lt;CodeHeap*&gt;* heaps() { return CodeCache::nmethod_heaps(); }
410 };
411 
412 typedef CodeBlobIterator&lt;CompiledMethod, CompiledMethodFilter&gt; CompiledMethodIterator;
413 typedef CodeBlobIterator&lt;nmethod, NMethodFilter&gt; NMethodIterator;
414 
415 #endif // SHARE_CODE_CODECACHE_HPP
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
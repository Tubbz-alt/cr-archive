diff a/src/hotspot/share/code/exceptionHandlerTable.cpp b/src/hotspot/share/code/exceptionHandlerTable.cpp
--- a/src/hotspot/share/code/exceptionHandlerTable.cpp
+++ b/src/hotspot/share/code/exceptionHandlerTable.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1998, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -174,26 +174,40 @@
   *(adr(l)  ) = exec_off;
   *(adr(l)+1) = cont_off;
   _len = l+1;
 };
 
-uint ImplicitExceptionTable::at( uint exec_off ) const {
+uint ImplicitExceptionTable::continuation_offset( uint exec_off ) const {
   uint l = len();
   for( uint i=0; i<l; i++ )
     if( *adr(i) == exec_off )
       return *(adr(i)+1);
   return 0;                     // Failed to find any execption offset
 }
 
 void ImplicitExceptionTable::print(address base) const {
-  tty->print("{");
-  for( uint i=0; i<len(); i++ )
-    tty->print("< " INTPTR_FORMAT ", " INTPTR_FORMAT " > ", p2i(base + *adr(i)), p2i(base + *(adr(i)+1)));
-  tty->print_cr("}");
+  const uint n = len();
+  if (n > 0) {
+    const uint items_per_line = 3;
+    uint i;
+    tty->print_cr("ImplicitExceptionTable (size = %d entries, %d bytes):", n, size_in_bytes());
+    tty->print("{");
+    for (i = 0; i < n; i++) {
+      if (i%items_per_line == 0) {
+        tty->cr();
+        tty->fill_to(3);
+      }
+      tty->print("< " INTPTR_FORMAT ", " INTPTR_FORMAT " > ", p2i(base + *adr(i)), p2i(base + *(adr(i)+1)));
+    }
+    tty->bol();
+    tty->print_cr("}");
+  } else {
+    tty->print_cr("ImplicitExceptionTable is empty");
+  }
 }
 
-ImplicitExceptionTable::ImplicitExceptionTable(const nmethod* nm) {
+ImplicitExceptionTable::ImplicitExceptionTable(const CompiledMethod* nm) {
   if (nm->nul_chk_table_size() == 0) {
     _len = 0;
     _data = NULL;
   } else {
     // the first word is the length if non-zero, so read it out and
@@ -205,22 +219,26 @@
   _size = len();
   assert(size_in_bytes() <= nm->nul_chk_table_size(), "size of space allocated in nmethod incorrect");
 }
 
 void ImplicitExceptionTable::copy_to( nmethod* nm ) {
-  assert(size_in_bytes() <= nm->nul_chk_table_size(), "size of space allocated in nmethod incorrect");
+  copy_bytes_to(nm->nul_chk_table_begin(), nm->nul_chk_table_size());
+}
+
+void ImplicitExceptionTable::copy_bytes_to(address addr, int size) {
+  assert(size_in_bytes() <= size, "size of space allocated in nmethod incorrect");
   if (len() != 0) {
-    implicit_null_entry* nmdata = (implicit_null_entry*)nm->nul_chk_table_begin();
+    implicit_null_entry* nmdata = (implicit_null_entry*)addr;
     // store the length in the first uint
     nmdata[0] = _len;
     nmdata++;
     // copy the table after the length
     memmove( nmdata, _data, 2 * len() * sizeof(implicit_null_entry));
   } else {
     // zero length table takes zero bytes
     assert(size_in_bytes() == 0, "bad size");
-    assert(nm->nul_chk_table_size() == 0, "bad size");
+    assert(size == 0, "bad size");
   }
 }
 
 void ImplicitExceptionTable::verify(nmethod *nm) const {
   for (uint i = 0; i < len(); i++) {

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/code/oopRecorder.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;ci/ciEnv.hpp&quot;
 27 #include &quot;ci/ciInstance.hpp&quot;
 28 #include &quot;ci/ciMetadata.hpp&quot;
<a name="1" id="anc1"></a><span class="line-modified"> 29 #include &quot;code/oopRecorder.inline.hpp&quot;</span>
 30 #include &quot;memory/allocation.inline.hpp&quot;
 31 #include &quot;oops/oop.inline.hpp&quot;
 32 #include &quot;runtime/jniHandles.inline.hpp&quot;
 33 #include &quot;utilities/copy.hpp&quot;
 34 
 35 #ifdef ASSERT
 36 template &lt;class T&gt; int ValueRecorder&lt;T&gt;::_find_index_calls = 0;
 37 template &lt;class T&gt; int ValueRecorder&lt;T&gt;::_hit_indexes      = 0;
 38 template &lt;class T&gt; int ValueRecorder&lt;T&gt;::_missed_indexes   = 0;
 39 #endif //ASSERT
 40 
 41 
 42 template &lt;class T&gt; ValueRecorder&lt;T&gt;::ValueRecorder(Arena* arena) {
 43   _handles  = NULL;
 44   _indexes  = NULL;
 45   _arena    = arena;
 46   _complete = false;
 47 }
 48 
 49 template &lt;class T&gt; template &lt;class X&gt;  ValueRecorder&lt;T&gt;::IndexCache&lt;X&gt;::IndexCache() {
 50   assert(first_index &gt; 0, &quot;initial zero state of cache must be invalid index&quot;);
 51   Copy::zero_to_bytes(&amp;_cache[0], sizeof(_cache));
 52 }
 53 
 54 template &lt;class T&gt; int ValueRecorder&lt;T&gt;::size() {
 55   _complete = true;
 56   if (_handles == NULL)  return 0;
 57   return _handles-&gt;length() * sizeof(T);
 58 }
 59 
 60 template &lt;class T&gt; void ValueRecorder&lt;T&gt;::copy_values_to(nmethod* nm) {
 61   assert(_complete, &quot;must be frozen&quot;);
 62   maybe_initialize();  // get non-null handles, even if we have no oops
 63   nm-&gt;copy_values(_handles);
 64 }
 65 
 66 template &lt;class T&gt; void ValueRecorder&lt;T&gt;::maybe_initialize() {
 67   if (_handles == NULL) {
 68     if (_arena != NULL) {
 69       _handles  = new(_arena) GrowableArray&lt;T&gt;(_arena, 10, 0, 0);
 70       _no_finds = new(_arena) GrowableArray&lt;int&gt;(    _arena, 10, 0, 0);
 71     } else {
 72       _handles  = new GrowableArray&lt;T&gt;(10, 0, 0);
 73       _no_finds = new GrowableArray&lt;int&gt;(    10, 0, 0);
 74     }
 75   }
 76 }
 77 
 78 
 79 template &lt;class T&gt; T ValueRecorder&lt;T&gt;::at(int index) {
 80   // there is always a NULL virtually present as first object
 81   if (index == null_index)  return NULL;
 82   return _handles-&gt;at(index - first_index);
 83 }
 84 
 85 
 86 template &lt;class T&gt; int ValueRecorder&lt;T&gt;::add_handle(T h, bool make_findable) {
 87   assert(!_complete, &quot;cannot allocate more elements after size query&quot;);
 88   maybe_initialize();
 89   // indexing uses 1 as an origin--0 means null
 90   int index = _handles-&gt;length() + first_index;
 91   _handles-&gt;append(h);
 92 
 93   // Support correct operation of find_index().
 94   assert(!(make_findable &amp;&amp; !is_real(h)), &quot;nulls are not findable&quot;);
 95   if (make_findable) {
 96     // This index may be returned from find_index().
 97     if (_indexes != NULL) {
 98       int* cloc = _indexes-&gt;cache_location(h);
 99       _indexes-&gt;set_cache_location_index(cloc, index);
100     } else if (index == index_cache_threshold &amp;&amp; _arena != NULL) {
101       _indexes = new(_arena) IndexCache&lt;T&gt;();
102       for (int i = 0; i &lt; _handles-&gt;length(); i++) {
103         // Load the cache with pre-existing elements.
104         int index0 = i + first_index;
105         if (_no_finds-&gt;contains(index0))  continue;
106         int* cloc = _indexes-&gt;cache_location(_handles-&gt;at(i));
107         _indexes-&gt;set_cache_location_index(cloc, index0);
108       }
109     }
110   } else if (is_real(h)) {
111     // Remember that this index is not to be returned from find_index().
112     // This case is rare, because most or all uses of allocate_index pass
113     // an argument of NULL or Universe::non_oop_word.
114     // Thus, the expected length of _no_finds is zero.
115     _no_finds-&gt;append(index);
116   }
117 
118   return index;
119 }
120 
121 
122 template &lt;class T&gt; int ValueRecorder&lt;T&gt;::maybe_find_index(T h) {
123   debug_only(_find_index_calls++);
124   assert(!_complete, &quot;cannot allocate more elements after size query&quot;);
125   maybe_initialize();
126   if (h == NULL)  return null_index;
127   assert(is_real(h), &quot;must be valid&quot;);
128   int* cloc = (_indexes == NULL)? NULL: _indexes-&gt;cache_location(h);
129   if (cloc != NULL) {
130     int cindex = _indexes-&gt;cache_location_index(cloc);
131     if (cindex == 0) {
132       return -1;   // We know this handle is completely new.
133     }
134     if (cindex &gt;= first_index &amp;&amp; _handles-&gt;at(cindex - first_index) == h) {
135       debug_only(_hit_indexes++);
136       return cindex;
137     }
138     if (!_indexes-&gt;cache_location_collision(cloc)) {
139       return -1;   // We know the current cache occupant is unique to that cloc.
140     }
141   }
142 
143   // Not found in cache, due to a cache collision.  (Or, no cache at all.)
144   // Do a linear search, most recent to oldest.
145   for (int i = _handles-&gt;length() - 1; i &gt;= 0; i--) {
146     if (_handles-&gt;at(i) == h) {
147       int findex = i + first_index;
148       if (_no_finds-&gt;contains(findex))  continue;  // oops; skip this one
149       if (cloc != NULL) {
150         _indexes-&gt;set_cache_location_index(cloc, findex);
151       }
152       debug_only(_missed_indexes++);
153       return findex;
154     }
155   }
156   return -1;
157 }
158 
159 // Explicitly instantiate these types
160 template class ValueRecorder&lt;Metadata*&gt;;
161 template class ValueRecorder&lt;jobject&gt;;
162 
163 oop ObjectLookup::ObjectEntry::oop_value() const { return JNIHandles::resolve(_value); }
164 
165 ObjectLookup::ObjectLookup(): _values(4), _gc_count(Universe::heap()-&gt;total_collections()) {}
166 
167 void ObjectLookup::maybe_resort() {
168   // The values are kept sorted by address which may be invalidated
169   // after a GC, so resort if a GC has occurred since last time.
170   if (_gc_count != Universe::heap()-&gt;total_collections()) {
171     _gc_count = Universe::heap()-&gt;total_collections();
172     _values.sort(sort_by_address);
173   }
174 }
175 
176 int ObjectLookup::sort_by_address(oop a, oop b) {
177   // oopDesc::compare returns the opposite of what this function returned
178   return -(oopDesc::compare(a, b));
179 }
180 
181 int ObjectLookup::sort_by_address(ObjectEntry* a, ObjectEntry* b) {
182   return sort_by_address(a-&gt;oop_value(), b-&gt;oop_value());
183 }
184 
185 int ObjectLookup::sort_oop_by_address(oop const&amp; a, ObjectEntry const&amp; b) {
186   return sort_by_address(a, b.oop_value());
187 }
188 
189 int ObjectLookup::find_index(jobject handle, OopRecorder* oop_recorder) {
190   if (handle == NULL) {
191     return 0;
192   }
193   oop object = JNIHandles::resolve(handle);
194   maybe_resort();
195   bool found;
196   int location = _values.find_sorted&lt;oop, sort_oop_by_address&gt;(object, found);
197   if (!found) {
198     jobject handle = JNIHandles::make_local(object);
199     ObjectEntry r(handle, oop_recorder-&gt;allocate_oop_index(handle));
200     _values.insert_before(location, r);
201     return r.index();
202   }
203   return _values.at(location).index();
204 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
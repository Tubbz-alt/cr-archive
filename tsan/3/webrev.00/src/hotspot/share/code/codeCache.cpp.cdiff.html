<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/code/codeCache.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="codeBlob.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="codeCache.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/codeCache.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 31,23 ***</span>
  #include &quot;code/dependencies.hpp&quot;
  #include &quot;code/dependencyContext.hpp&quot;
  #include &quot;code/icBuffer.hpp&quot;
  #include &quot;code/nmethod.hpp&quot;
  #include &quot;code/pcDesc.hpp&quot;
  #include &quot;compiler/compileBroker.hpp&quot;
  #include &quot;jfr/jfrEvents.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/iterator.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;oops/method.inline.hpp&quot;
  #include &quot;oops/objArrayOop.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/verifyOopClosure.hpp&quot;
  #include &quot;runtime/arguments.hpp&quot;
<span class="line-modified">! #include &quot;runtime/compilationPolicy.hpp&quot;</span>
  #include &quot;runtime/deoptimization.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/icache.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;runtime/mutexLocker.hpp&quot;
<span class="line-new-header">--- 31,25 ---</span>
  #include &quot;code/dependencies.hpp&quot;
  #include &quot;code/dependencyContext.hpp&quot;
  #include &quot;code/icBuffer.hpp&quot;
  #include &quot;code/nmethod.hpp&quot;
  #include &quot;code/pcDesc.hpp&quot;
<span class="line-added">+ #include &quot;compiler/compilationPolicy.hpp&quot;</span>
  #include &quot;compiler/compileBroker.hpp&quot;
  #include &quot;jfr/jfrEvents.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/iterator.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/method.inline.hpp&quot;
  #include &quot;oops/objArrayOop.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/verifyOopClosure.hpp&quot;
  #include &quot;runtime/arguments.hpp&quot;
<span class="line-modified">! #include &quot;runtime/atomic.hpp&quot;</span>
  #include &quot;runtime/deoptimization.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/icache.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;runtime/mutexLocker.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 280,13 ***</span>
          non_nmethod_size/K, min_code_cache_size/K));
    }
  
    // Verify sizes and update flag values
    assert(non_profiled_size + profiled_size + non_nmethod_size == cache_size, &quot;Invalid code heap sizes&quot;);
<span class="line-modified">!   FLAG_SET_ERGO(uintx, NonNMethodCodeHeapSize, non_nmethod_size);</span>
<span class="line-modified">!   FLAG_SET_ERGO(uintx, ProfiledCodeHeapSize, profiled_size);</span>
<span class="line-modified">!   FLAG_SET_ERGO(uintx, NonProfiledCodeHeapSize, non_profiled_size);</span>
  
    // If large page support is enabled, align code heaps according to large
    // page size to make sure that code cache is covered by large pages.
    const size_t alignment = MAX2(page_size(false, 8), (size_t) os::vm_allocation_granularity());
    non_nmethod_size = align_up(non_nmethod_size, alignment);
<span class="line-new-header">--- 282,13 ---</span>
          non_nmethod_size/K, min_code_cache_size/K));
    }
  
    // Verify sizes and update flag values
    assert(non_profiled_size + profiled_size + non_nmethod_size == cache_size, &quot;Invalid code heap sizes&quot;);
<span class="line-modified">!   FLAG_SET_ERGO(NonNMethodCodeHeapSize, non_nmethod_size);</span>
<span class="line-modified">!   FLAG_SET_ERGO(ProfiledCodeHeapSize, profiled_size);</span>
<span class="line-modified">!   FLAG_SET_ERGO(NonProfiledCodeHeapSize, non_profiled_size);</span>
  
    // If large page support is enabled, align code heaps according to large
    // page size to make sure that code cache is covered by large pages.
    const size_t alignment = MAX2(page_size(false, 8), (size_t) os::vm_allocation_granularity());
    non_nmethod_size = align_up(non_nmethod_size, alignment);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 529,11 ***</span>
                            heap-&gt;name(), get_code_heap(type)-&gt;name());
            }
            return allocate(size, type, orig_code_blob_type);
          }
        }
<span class="line-modified">!       MutexUnlockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
        CompileBroker::handle_full_code_cache(orig_code_blob_type);
        return NULL;
      }
      if (PrintCodeCacheExtension) {
        ResourceMark rm;
<span class="line-new-header">--- 531,11 ---</span>
                            heap-&gt;name(), get_code_heap(type)-&gt;name());
            }
            return allocate(size, type, orig_code_blob_type);
          }
        }
<span class="line-modified">!       MutexUnlocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
        CompileBroker::handle_full_code_cache(orig_code_blob_type);
        return NULL;
      }
      if (PrintCodeCacheExtension) {
        ResourceMark rm;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 665,11 ***</span>
    while(iter.next()) {
      f(iter.method());
    }
  }
  
<span class="line-modified">! void CodeCache::metadata_do(void f(Metadata* m)) {</span>
    assert_locked_or_safepoint(CodeCache_lock);
    NMethodIterator iter(NMethodIterator::only_alive_and_not_unloading);
    while(iter.next()) {
      iter.method()-&gt;metadata_do(f);
    }
<span class="line-new-header">--- 667,11 ---</span>
    while(iter.next()) {
      f(iter.method());
    }
  }
  
<span class="line-modified">! void CodeCache::metadata_do(MetadataClosure* f) {</span>
    assert_locked_or_safepoint(CodeCache_lock);
    NMethodIterator iter(NMethodIterator::only_alive_and_not_unloading);
    while(iter.next()) {
      iter.method()-&gt;metadata_do(f);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 746,11 ***</span>
      delete entry;
    } else {
      for (;;) {
        ExceptionCache* purge_list_head = Atomic::load(&amp;_exception_cache_purge_list);
        entry-&gt;set_purge_list_next(purge_list_head);
<span class="line-modified">!       if (Atomic::cmpxchg(entry, &amp;_exception_cache_purge_list, purge_list_head) == purge_list_head) {</span>
          break;
        }
      }
    }
  }
<span class="line-new-header">--- 748,11 ---</span>
      delete entry;
    } else {
      for (;;) {
        ExceptionCache* purge_list_head = Atomic::load(&amp;_exception_cache_purge_list);
        entry-&gt;set_purge_list_next(purge_list_head);
<span class="line-modified">!       if (Atomic::cmpxchg(&amp;_exception_cache_purge_list, purge_list_head, entry) == purge_list_head) {</span>
          break;
        }
      }
    }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 768,32 ***</span>
  }
  
  uint8_t CodeCache::_unloading_cycle = 1;
  
  void CodeCache::increment_unloading_cycle() {
<span class="line-modified">!   if (_unloading_cycle == 1) {</span>
<span class="line-modified">!     _unloading_cycle = 2;</span>
<span class="line-modified">!   } else {</span>
      _unloading_cycle = 1;
    }
  }
  
  CodeCache::UnloadingScope::UnloadingScope(BoolObjectClosure* is_alive)
    : _is_unloading_behaviour(is_alive)
  {
    IsUnloadingBehaviour::set_current(&amp;_is_unloading_behaviour);
    increment_unloading_cycle();
    DependencyContext::cleaning_start();
  }
  
  CodeCache::UnloadingScope::~UnloadingScope() {
<span class="line-modified">!   IsUnloadingBehaviour::set_current(NULL);</span>
    DependencyContext::cleaning_end();
  }
  
  void CodeCache::verify_oops() {
<span class="line-modified">!   MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
    VerifyOopClosure voc;
    NMethodIterator iter(NMethodIterator::only_alive_and_not_unloading);
    while(iter.next()) {
      nmethod* nm = iter.method();
      nm-&gt;oops_do(&amp;voc);
<span class="line-new-header">--- 770,34 ---</span>
  }
  
  uint8_t CodeCache::_unloading_cycle = 1;
  
  void CodeCache::increment_unloading_cycle() {
<span class="line-modified">!   // 2-bit value (see IsUnloadingState in nmethod.cpp for details)</span>
<span class="line-modified">!   // 0 is reserved for new methods.</span>
<span class="line-modified">!   _unloading_cycle = (_unloading_cycle + 1) % 4;</span>
<span class="line-added">+   if (_unloading_cycle == 0) {</span>
      _unloading_cycle = 1;
    }
  }
  
  CodeCache::UnloadingScope::UnloadingScope(BoolObjectClosure* is_alive)
    : _is_unloading_behaviour(is_alive)
  {
<span class="line-added">+   _saved_behaviour = IsUnloadingBehaviour::current();</span>
    IsUnloadingBehaviour::set_current(&amp;_is_unloading_behaviour);
    increment_unloading_cycle();
    DependencyContext::cleaning_start();
  }
  
  CodeCache::UnloadingScope::~UnloadingScope() {
<span class="line-modified">!   IsUnloadingBehaviour::set_current(_saved_behaviour);</span>
    DependencyContext::cleaning_end();
  }
  
  void CodeCache::verify_oops() {
<span class="line-modified">!   MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
    VerifyOopClosure voc;
    NMethodIterator iter(NMethodIterator::only_alive_and_not_unloading);
    while(iter.next()) {
      nmethod* nm = iter.method();
      nm-&gt;oops_do(&amp;voc);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 937,13 ***</span>
    if (SegmentedCodeCache) {
      // Use multiple code heaps
      initialize_heaps();
    } else {
      // Use a single code heap
<span class="line-modified">!     FLAG_SET_ERGO(uintx, NonNMethodCodeHeapSize, 0);</span>
<span class="line-modified">!     FLAG_SET_ERGO(uintx, ProfiledCodeHeapSize, 0);</span>
<span class="line-modified">!     FLAG_SET_ERGO(uintx, NonProfiledCodeHeapSize, 0);</span>
      ReservedCodeSpace rs = reserve_heap_memory(ReservedCodeCacheSize);
      add_heap(rs, &quot;CodeCache&quot;, CodeBlobType::All);
    }
  
    // Initialize ICache flush mechanism
<span class="line-new-header">--- 941,13 ---</span>
    if (SegmentedCodeCache) {
      // Use multiple code heaps
      initialize_heaps();
    } else {
      // Use a single code heap
<span class="line-modified">!     FLAG_SET_ERGO(NonNMethodCodeHeapSize, 0);</span>
<span class="line-modified">!     FLAG_SET_ERGO(ProfiledCodeHeapSize, 0);</span>
<span class="line-modified">!     FLAG_SET_ERGO(NonProfiledCodeHeapSize, 0);</span>
      ReservedCodeSpace rs = reserve_heap_memory(ReservedCodeCacheSize);
      add_heap(rs, &quot;CodeCache&quot;, CodeBlobType::All);
    }
  
    // Initialize ICache flush mechanism
</pre>
<hr />
<pre>
<span class="line-old-header">*** 986,11 ***</span>
  
  // Keeps track of time spent for checking dependencies
  NOT_PRODUCT(static elapsedTimer dependentCheckTime;)
  
  int CodeCache::mark_for_deoptimization(KlassDepChange&amp; changes) {
<span class="line-modified">!   MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
    int number_of_marked_CodeBlobs = 0;
  
    // search the hierarchy looking for nmethods which are affected by the loading of this class
  
    // then search the interfaces this class implements looking for nmethods
<span class="line-new-header">--- 990,11 ---</span>
  
  // Keeps track of time spent for checking dependencies
  NOT_PRODUCT(static elapsedTimer dependentCheckTime;)
  
  int CodeCache::mark_for_deoptimization(KlassDepChange&amp; changes) {
<span class="line-modified">!   MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
    int number_of_marked_CodeBlobs = 0;
  
    // search the hierarchy looking for nmethods which are affected by the loading of this class
  
    // then search the interfaces this class implements looking for nmethods
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1030,68 ***</span>
  #else
    return false;
  #endif
  }
  
<span class="line-modified">! // Just marks the methods in this class as needing deoptimization</span>
<span class="line-modified">! void CodeCache::mark_for_evol_deoptimization(InstanceKlass* dependee) {</span>
<span class="line-modified">!   MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
  
<span class="line-modified">!   // Deoptimize all methods of the evolving class itself</span>
<span class="line-modified">!   Array&lt;Method*&gt;* old_methods = dependee-&gt;methods();</span>
<span class="line-modified">!   for (int i = 0; i &lt; old_methods-&gt;length(); i++) {</span>
<span class="line-modified">!     ResourceMark rm;</span>
<span class="line-modified">!     Method* old_method = old_methods-&gt;at(i);</span>
<span class="line-modified">!     CompiledMethod* nm = old_method-&gt;code();</span>
<span class="line-modified">!     if (nm != NULL) {</span>
<span class="line-modified">!       nm-&gt;mark_for_deoptimization();</span>
      }
    }
  
    // Mark dependent AOT nmethods, which are only found via the class redefined.
    AOTLoader::mark_evol_dependent_methods(dependee);
  }
  
  // Walk compiled methods and mark dependent methods for deoptimization.
  int CodeCache::mark_dependents_for_evol_deoptimization() {
    int number_of_marked_CodeBlobs = 0;
    CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);
    while(iter.next()) {
      CompiledMethod* nm = iter.method();
<span class="line-modified">!     if (nm-&gt;is_marked_for_deoptimization()) {</span>
<span class="line-modified">!       // ...Already marked in the previous pass; count it here.</span>
<span class="line-modified">!       // Also counts AOT compiled methods, already marked.</span>
<span class="line-modified">!       number_of_marked_CodeBlobs++;</span>
<span class="line-removed">-     } else if (nm-&gt;is_evol_dependent()) {</span>
<span class="line-removed">-       ResourceMark rm;</span>
        nm-&gt;mark_for_deoptimization();
        number_of_marked_CodeBlobs++;
<span class="line-removed">-     } else  {</span>
<span class="line-removed">-       // flush caches in case they refer to a redefined Method*</span>
<span class="line-removed">-       nm-&gt;clear_inline_caches();</span>
      }
    }
  
    // return total count of nmethods marked for deoptimization, if zero the caller
    // can skip deoptimization
    return number_of_marked_CodeBlobs;
  }
  
<span class="line-modified">! // Deoptimize all methods</span>
<span class="line-modified">! void CodeCache::mark_all_nmethods_for_deoptimization() {</span>
<span class="line-removed">-   MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
    CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);
    while(iter.next()) {
      CompiledMethod* nm = iter.method();
      if (!nm-&gt;method()-&gt;is_method_handle_intrinsic()) {
        nm-&gt;mark_for_deoptimization();
      }
    }
  }
  
  int CodeCache::mark_for_deoptimization(Method* dependee) {
<span class="line-modified">!   MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
    int number_of_marked_CodeBlobs = 0;
  
    CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);
    while(iter.next()) {
      CompiledMethod* nm = iter.method();
<span class="line-new-header">--- 1034,136 ---</span>
  #else
    return false;
  #endif
  }
  
<span class="line-modified">! #ifdef INCLUDE_JVMTI</span>
<span class="line-modified">! // RedefineClasses support for unloading nmethods that are dependent on &quot;old&quot; methods.</span>
<span class="line-modified">! // We don&#39;t really expect this table to grow very large.  If it does, it can become a hashtable.</span>
<span class="line-added">+ static GrowableArray&lt;CompiledMethod*&gt;* old_compiled_method_table = NULL;</span>
  
<span class="line-modified">! static void add_to_old_table(CompiledMethod* c) {</span>
<span class="line-modified">!   if (old_compiled_method_table == NULL) {</span>
<span class="line-modified">!     old_compiled_method_table = new (ResourceObj::C_HEAP, mtCode) GrowableArray&lt;CompiledMethod*&gt;(100, true);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   old_compiled_method_table-&gt;push(c);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! static void reset_old_method_table() {</span>
<span class="line-added">+   if (old_compiled_method_table != NULL) {</span>
<span class="line-added">+     delete old_compiled_method_table;</span>
<span class="line-added">+     old_compiled_method_table = NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Remove this method when zombied or unloaded.</span>
<span class="line-added">+ void CodeCache::unregister_old_nmethod(CompiledMethod* c) {</span>
<span class="line-added">+   assert_lock_strong(CodeCache_lock);</span>
<span class="line-added">+   if (old_compiled_method_table != NULL) {</span>
<span class="line-added">+     int index = old_compiled_method_table-&gt;find(c);</span>
<span class="line-added">+     if (index != -1) {</span>
<span class="line-added">+       old_compiled_method_table-&gt;delete_at(index);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void CodeCache::old_nmethods_do(MetadataClosure* f) {</span>
<span class="line-added">+   // Walk old method table and mark those on stack.</span>
<span class="line-added">+   int length = 0;</span>
<span class="line-added">+   if (old_compiled_method_table != NULL) {</span>
<span class="line-added">+     length = old_compiled_method_table-&gt;length();</span>
<span class="line-added">+     for (int i = 0; i &lt; length; i++) {</span>
<span class="line-added">+       CompiledMethod* cm = old_compiled_method_table-&gt;at(i);</span>
<span class="line-added">+       // Only walk alive nmethods, the dead ones will get removed by the sweeper.</span>
<span class="line-added">+       if (cm-&gt;is_alive()) {</span>
<span class="line-added">+         old_compiled_method_table-&gt;at(i)-&gt;metadata_do(f);</span>
<span class="line-added">+       }</span>
      }
    }
<span class="line-added">+   log_debug(redefine, class, nmethod)(&quot;Walked %d nmethods for mark_on_stack&quot;, length);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Just marks the methods in this class as needing deoptimization</span>
<span class="line-added">+ void CodeCache::mark_for_evol_deoptimization(InstanceKlass* dependee) {</span>
<span class="line-added">+   assert(SafepointSynchronize::is_at_safepoint(), &quot;Can only do this at a safepoint!&quot;);</span>
  
    // Mark dependent AOT nmethods, which are only found via the class redefined.
<span class="line-added">+   // TODO: add dependencies to aotCompiledMethod&#39;s metadata section so this isn&#39;t</span>
<span class="line-added">+   // needed.</span>
    AOTLoader::mark_evol_dependent_methods(dependee);
  }
  
<span class="line-added">+ </span>
  // Walk compiled methods and mark dependent methods for deoptimization.
  int CodeCache::mark_dependents_for_evol_deoptimization() {
<span class="line-added">+   assert(SafepointSynchronize::is_at_safepoint(), &quot;Can only do this at a safepoint!&quot;);</span>
<span class="line-added">+   // Each redefinition creates a new set of nmethods that have references to &quot;old&quot; Methods</span>
<span class="line-added">+   // So delete old method table and create a new one.</span>
<span class="line-added">+   reset_old_method_table();</span>
<span class="line-added">+ </span>
    int number_of_marked_CodeBlobs = 0;
    CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);
    while(iter.next()) {
      CompiledMethod* nm = iter.method();
<span class="line-modified">!     // Walk all alive nmethods to check for old Methods.</span>
<span class="line-modified">!     // This includes methods whose inline caches point to old methods, so</span>
<span class="line-modified">!     // inline cache clearing is unnecessary.</span>
<span class="line-modified">!     if (nm-&gt;has_evol_metadata()) {</span>
        nm-&gt;mark_for_deoptimization();
<span class="line-added">+       add_to_old_table(nm);</span>
        number_of_marked_CodeBlobs++;
      }
    }
  
    // return total count of nmethods marked for deoptimization, if zero the caller
    // can skip deoptimization
    return number_of_marked_CodeBlobs;
  }
  
<span class="line-modified">! void CodeCache::mark_all_nmethods_for_evol_deoptimization() {</span>
<span class="line-modified">!   assert(SafepointSynchronize::is_at_safepoint(), &quot;Can only do this at a safepoint!&quot;);</span>
    CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);
    while(iter.next()) {
      CompiledMethod* nm = iter.method();
      if (!nm-&gt;method()-&gt;is_method_handle_intrinsic()) {
        nm-&gt;mark_for_deoptimization();
<span class="line-added">+       if (nm-&gt;has_evol_metadata()) {</span>
<span class="line-added">+         add_to_old_table(nm);</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Flushes compiled methods dependent on redefined classes, that have already been</span>
<span class="line-added">+ // marked for deoptimization.</span>
<span class="line-added">+ void CodeCache::flush_evol_dependents() {</span>
<span class="line-added">+   assert(SafepointSynchronize::is_at_safepoint(), &quot;Can only do this at a safepoint!&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // CodeCache can only be updated by a thread_in_VM and they will all be</span>
<span class="line-added">+   // stopped during the safepoint so CodeCache will be safe to update without</span>
<span class="line-added">+   // holding the CodeCache_lock.</span>
<span class="line-added">+ </span>
<span class="line-added">+   // At least one nmethod has been marked for deoptimization</span>
<span class="line-added">+ </span>
<span class="line-added">+   Deoptimization::deoptimize_all_marked();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif // INCLUDE_JVMTI</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Mark methods for deopt (if safe or possible).</span>
<span class="line-added">+ void CodeCache::mark_all_nmethods_for_deoptimization() {</span>
<span class="line-added">+   MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">+   CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);</span>
<span class="line-added">+   while(iter.next()) {</span>
<span class="line-added">+     CompiledMethod* nm = iter.method();</span>
<span class="line-added">+     if (!nm-&gt;is_native_method()) {</span>
<span class="line-added">+       nm-&gt;mark_for_deoptimization();</span>
      }
    }
  }
  
  int CodeCache::mark_for_deoptimization(Method* dependee) {
<span class="line-modified">!   MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
    int number_of_marked_CodeBlobs = 0;
  
    CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);
    while(iter.next()) {
      CompiledMethod* nm = iter.method();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1108,11 ***</span>
  void CodeCache::make_marked_nmethods_not_entrant() {
    assert_locked_or_safepoint(CodeCache_lock);
    CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);
    while(iter.next()) {
      CompiledMethod* nm = iter.method();
<span class="line-modified">!     if (nm-&gt;is_marked_for_deoptimization() &amp;&amp; !nm-&gt;is_not_entrant()) {</span>
        nm-&gt;make_not_entrant();
      }
    }
  }
  
<span class="line-new-header">--- 1180,11 ---</span>
  void CodeCache::make_marked_nmethods_not_entrant() {
    assert_locked_or_safepoint(CodeCache_lock);
    CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);
    while(iter.next()) {
      CompiledMethod* nm = iter.method();
<span class="line-modified">!     if (nm-&gt;is_marked_for_deoptimization()) {</span>
        nm-&gt;make_not_entrant();
      }
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1120,75 ***</span>
  void CodeCache::flush_dependents_on(InstanceKlass* dependee) {
    assert_lock_strong(Compile_lock);
  
    if (number_of_nmethods_with_dependencies() == 0) return;
  
<span class="line-removed">-   // CodeCache can only be updated by a thread_in_VM and they will all be</span>
<span class="line-removed">-   // stopped during the safepoint so CodeCache will be safe to update without</span>
<span class="line-removed">-   // holding the CodeCache_lock.</span>
<span class="line-removed">- </span>
    KlassDepChange changes(dependee);
  
    // Compute the dependent nmethods
    if (mark_for_deoptimization(changes) &gt; 0) {
      // At least one nmethod has been marked for deoptimization
<span class="line-modified">!     VM_Deoptimize op;</span>
<span class="line-removed">-     VMThread::execute(&amp;op);</span>
    }
  }
  
<span class="line-removed">- // Flushes compiled methods dependent on redefined classes, that have already been</span>
<span class="line-removed">- // marked for deoptimization.</span>
<span class="line-removed">- void CodeCache::flush_evol_dependents() {</span>
<span class="line-removed">-   // --- Compile_lock is not held. However we are at a safepoint.</span>
<span class="line-removed">-   assert_locked_or_safepoint(Compile_lock);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // CodeCache can only be updated by a thread_in_VM and they will all be</span>
<span class="line-removed">-   // stopped during the safepoint so CodeCache will be safe to update without</span>
<span class="line-removed">-   // holding the CodeCache_lock.</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // At least one nmethod has been marked for deoptimization</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // All this already happens inside a VM_Operation, so we&#39;ll do all the work here.</span>
<span class="line-removed">-   // Stuff copied from VM_Deoptimize and modified slightly.</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // We do not want any GCs to happen while we are in the middle of this VM operation</span>
<span class="line-removed">-   ResourceMark rm;</span>
<span class="line-removed">-   DeoptimizationMarker dm;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Deoptimize all activations depending on marked nmethods</span>
<span class="line-removed">-   Deoptimization::deoptimize_dependents();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Make the dependent methods not entrant</span>
<span class="line-removed">-   make_marked_nmethods_not_entrant();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  // Flushes compiled methods dependent on dependee
  void CodeCache::flush_dependents_on_method(const methodHandle&amp; m_h) {
    // --- Compile_lock is not held. However we are at a safepoint.
    assert_locked_or_safepoint(Compile_lock);
  
<span class="line-removed">-   // CodeCache can only be updated by a thread_in_VM and they will all be</span>
<span class="line-removed">-   // stopped dring the safepoint so CodeCache will be safe to update without</span>
<span class="line-removed">-   // holding the CodeCache_lock.</span>
<span class="line-removed">- </span>
    // Compute the dependent nmethods
    if (mark_for_deoptimization(m_h()) &gt; 0) {
<span class="line-modified">!     // At least one nmethod has been marked for deoptimization</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // All this already happens inside a VM_Operation, so we&#39;ll do all the work here.</span>
<span class="line-removed">-     // Stuff copied from VM_Deoptimize and modified slightly.</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // We do not want any GCs to happen while we are in the middle of this VM operation</span>
<span class="line-removed">-     ResourceMark rm;</span>
<span class="line-removed">-     DeoptimizationMarker dm;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Deoptimize all activations depending on marked nmethods</span>
<span class="line-removed">-     Deoptimization::deoptimize_dependents();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Make the dependent methods not entrant</span>
<span class="line-removed">-     make_marked_nmethods_not_entrant();</span>
    }
  }
  
  void CodeCache::verify() {
    assert_locked_or_safepoint(CodeCache_lock);
<span class="line-new-header">--- 1192,27 ---</span>
  void CodeCache::flush_dependents_on(InstanceKlass* dependee) {
    assert_lock_strong(Compile_lock);
  
    if (number_of_nmethods_with_dependencies() == 0) return;
  
    KlassDepChange changes(dependee);
  
    // Compute the dependent nmethods
    if (mark_for_deoptimization(changes) &gt; 0) {
      // At least one nmethod has been marked for deoptimization
<span class="line-modified">!     Deoptimization::deoptimize_all_marked();</span>
    }
  }
  
  // Flushes compiled methods dependent on dependee
  void CodeCache::flush_dependents_on_method(const methodHandle&amp; m_h) {
    // --- Compile_lock is not held. However we are at a safepoint.
    assert_locked_or_safepoint(Compile_lock);
  
    // Compute the dependent nmethods
    if (mark_for_deoptimization(m_h()) &gt; 0) {
<span class="line-modified">!     Deoptimization::deoptimize_all_marked();</span>
    }
  }
  
  void CodeCache::verify() {
    assert_locked_or_safepoint(CodeCache_lock);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1237,21 ***</span>
      }
      ResourceMark rm;
      stringStream s;
      // Dump code cache into a buffer before locking the tty.
      {
<span class="line-modified">!       MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
        print_summary(&amp;s);
      }
      {
        ttyLocker ttyl;
        tty-&gt;print(&quot;%s&quot;, s.as_string());
      }
  
      if (heap-&gt;full_count() == 0) {
        if (PrintCodeHeapAnalytics) {
<span class="line-modified">!         CompileBroker::print_heapinfo(tty, &quot;all&quot;, &quot;4096&quot;); // details, may be a lot!</span>
        }
      }
    }
  
    heap-&gt;report_full();
<span class="line-new-header">--- 1261,21 ---</span>
      }
      ResourceMark rm;
      stringStream s;
      // Dump code cache into a buffer before locking the tty.
      {
<span class="line-modified">!       MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
        print_summary(&amp;s);
      }
      {
        ttyLocker ttyl;
        tty-&gt;print(&quot;%s&quot;, s.as_string());
      }
  
      if (heap-&gt;full_count() == 0) {
        if (PrintCodeHeapAnalytics) {
<span class="line-modified">!         CompileBroker::print_heapinfo(tty, &quot;all&quot;, 4096); // details, may be a lot!</span>
        }
      }
    }
  
    heap-&gt;report_full();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1505,11 ***</span>
      st-&gt;print_cr(&quot; full_count=%d&quot;, full_count);
    }
  }
  
  void CodeCache::print_codelist(outputStream* st) {
<span class="line-modified">!   MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
  
    CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);
    while (iter.next()) {
      CompiledMethod* cm = iter.method();
      ResourceMark rm;
<span class="line-new-header">--- 1529,11 ---</span>
      st-&gt;print_cr(&quot; full_count=%d&quot;, full_count);
    }
  }
  
  void CodeCache::print_codelist(outputStream* st) {
<span class="line-modified">!   MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
  
    CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);
    while (iter.next()) {
      CompiledMethod* cm = iter.method();
      ResourceMark rm;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1520,11 ***</span>
                   (intptr_t)cm-&gt;header_begin(), (intptr_t)cm-&gt;code_begin(), (intptr_t)cm-&gt;code_end());
    }
  }
  
  void CodeCache::print_layout(outputStream* st) {
<span class="line-modified">!   MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
    ResourceMark rm;
    print_summary(st, true);
  }
  
  void CodeCache::log_state(outputStream* st) {
<span class="line-new-header">--- 1544,11 ---</span>
                   (intptr_t)cm-&gt;header_begin(), (intptr_t)cm-&gt;code_begin(), (intptr_t)cm-&gt;code_end());
    }
  }
  
  void CodeCache::print_layout(outputStream* st) {
<span class="line-modified">!   MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
    ResourceMark rm;
    print_summary(st, true);
  }
  
  void CodeCache::log_state(outputStream* st) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1534,11 ***</span>
              unallocated_capacity());
  }
  
  //---&lt;  BEGIN  &gt;--- CodeHeap State Analytics.
  
<span class="line-modified">! void CodeCache::aggregate(outputStream *out, const char* granularity) {</span>
    FOR_ALL_ALLOCABLE_HEAPS(heap) {
      CodeHeapState::aggregate(out, (*heap), granularity);
    }
  }
  
<span class="line-new-header">--- 1558,11 ---</span>
              unallocated_capacity());
  }
  
  //---&lt;  BEGIN  &gt;--- CodeHeap State Analytics.
  
<span class="line-modified">! void CodeCache::aggregate(outputStream *out, size_t granularity) {</span>
    FOR_ALL_ALLOCABLE_HEAPS(heap) {
      CodeHeapState::aggregate(out, (*heap), granularity);
    }
  }
  
</pre>
<center><a href="codeBlob.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="codeCache.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/code/nmethod.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="icBuffer.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nmethod.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/nmethod.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -22,10 +22,11 @@</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;jvm.h&quot;
<span class="udiff-line-added">+ #include &quot;asm/assembler.inline.hpp&quot;</span>
  #include &quot;code/codeCache.hpp&quot;
  #include &quot;code/compiledIC.hpp&quot;
  #include &quot;code/compiledMethod.inline.hpp&quot;
  #include &quot;code/dependencies.hpp&quot;
  #include &quot;code/nativeInst.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -40,33 +41,37 @@</span>
  #include &quot;interpreter/bytecode.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/access.inline.hpp&quot;
  #include &quot;oops/method.inline.hpp&quot;
  #include &quot;oops/methodData.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;prims/jvmtiImpl.hpp&quot;
<span class="udiff-line-added">+ #include &quot;prims/jvmtiThreadState.hpp&quot;</span>
  #include &quot;runtime/atomic.hpp&quot;
<span class="udiff-line-added">+ #include &quot;runtime/deoptimization.hpp&quot;</span>
  #include &quot;runtime/flags/flagSetting.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/jniHandles.inline.hpp&quot;
  #include &quot;runtime/orderAccess.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
  #include &quot;runtime/safepointVerifiers.hpp&quot;
<span class="udiff-line-added">+ #include &quot;runtime/serviceThread.hpp&quot;</span>
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/sweeper.hpp&quot;
  #include &quot;runtime/vmThread.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  #include &quot;utilities/dtrace.hpp&quot;
  #include &quot;utilities/events.hpp&quot;
  #include &quot;utilities/resourceHash.hpp&quot;
  #include &quot;utilities/xmlstream.hpp&quot;
  #if INCLUDE_JVMCI
<span class="udiff-line-modified-removed">- #include &quot;jvmci/jvmciJavaClasses.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;jvmci/jvmciRuntime.hpp&quot;</span>
  #endif
  
  #ifdef DTRACE_ENABLED
  
  // Only bother with this argument setup if dtrace is available
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -110,10 +115,14 @@</span>
    int scopes_data_size;
    int scopes_pcs_size;
    int dependencies_size;
    int handler_table_size;
    int nul_chk_table_size;
<span class="udiff-line-added">+ #if INCLUDE_JVMCI</span>
<span class="udiff-line-added">+   int speculations_size;</span>
<span class="udiff-line-added">+   int jvmci_data_size;</span>
<span class="udiff-line-added">+ #endif</span>
    int oops_size;
    int metadata_size;
  
    void note_nmethod(nmethod* nm) {
      nmethod_count += 1;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -127,10 +136,14 @@</span>
      scopes_data_size    += nm-&gt;scopes_data_size();
      scopes_pcs_size     += nm-&gt;scopes_pcs_size();
      dependencies_size   += nm-&gt;dependencies_size();
      handler_table_size  += nm-&gt;handler_table_size();
      nul_chk_table_size  += nm-&gt;nul_chk_table_size();
<span class="udiff-line-added">+ #if INCLUDE_JVMCI</span>
<span class="udiff-line-added">+     speculations_size   += nm-&gt;speculations_size();</span>
<span class="udiff-line-added">+     jvmci_data_size     += nm-&gt;jvmci_data_size();</span>
<span class="udiff-line-added">+ #endif</span>
    }
    void print_nmethod_stats(const char* name) {
      if (nmethod_count == 0)  return;
      tty-&gt;print_cr(&quot;Statistics for %d bytecoded nmethods for %s:&quot;, nmethod_count, name);
      if (total_size != 0)          tty-&gt;print_cr(&quot; total in heap  = %d&quot;, total_size);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -144,10 +157,14 @@</span>
      if (scopes_data_size != 0)    tty-&gt;print_cr(&quot; scopes data    = %d&quot;, scopes_data_size);
      if (scopes_pcs_size != 0)     tty-&gt;print_cr(&quot; scopes pcs     = %d&quot;, scopes_pcs_size);
      if (dependencies_size != 0)   tty-&gt;print_cr(&quot; dependencies   = %d&quot;, dependencies_size);
      if (handler_table_size != 0)  tty-&gt;print_cr(&quot; handler table  = %d&quot;, handler_table_size);
      if (nul_chk_table_size != 0)  tty-&gt;print_cr(&quot; nul chk table  = %d&quot;, nul_chk_table_size);
<span class="udiff-line-added">+ #if INCLUDE_JVMCI</span>
<span class="udiff-line-added">+     if (speculations_size != 0)   tty-&gt;print_cr(&quot; speculations   = %d&quot;, speculations_size);</span>
<span class="udiff-line-added">+     if (jvmci_data_size != 0)     tty-&gt;print_cr(&quot; JVMCI data     = %d&quot;, jvmci_data_size);</span>
<span class="udiff-line-added">+ #endif</span>
    }
  };
  
  struct native_nmethod_stats_struct {
    int native_nmethod_count;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -298,11 +315,11 @@</span>
  ExceptionCache* ExceptionCache::next() {
    return Atomic::load(&amp;_next);
  }
  
  void ExceptionCache::set_next(ExceptionCache *ec) {
<span class="udiff-line-modified-removed">-   Atomic::store(ec, &amp;_next);</span>
<span class="udiff-line-modified-added">+   Atomic::store(&amp;_next, ec);</span>
  }
  
  //-----------------------------------------------------------------------------
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -411,28 +428,23 @@</span>
  void nmethod::init_defaults() {
    _state                      = not_installed;
    _has_flushed_dependencies   = 0;
    _lock_count                 = 0;
    _stack_traversal_mark       = 0;
<span class="udiff-line-modified-removed">-   _unload_reported            = false; // jvmti state</span>
<span class="udiff-line-modified-added">+   _load_reported              = false; // jvmti state</span>
<span class="udiff-line-added">+   _unload_reported            = false;</span>
    _is_far_code                = false; // nmethods are located in CodeCache
  
  #ifdef ASSERT
    _oops_are_stale             = false;
  #endif
  
    _oops_do_mark_link       = NULL;
<span class="udiff-line-removed">-   _jmethod_id              = NULL;</span>
    _osr_link                = NULL;
  #if INCLUDE_RTM_OPT
    _rtm_state               = NoRTM;
  #endif
<span class="udiff-line-removed">- #if INCLUDE_JVMCI</span>
<span class="udiff-line-removed">-   _jvmci_installed_code   = NULL;</span>
<span class="udiff-line-removed">-   _speculation_log        = NULL;</span>
<span class="udiff-line-removed">-   _jvmci_installed_code_triggers_invalidation = false;</span>
<span class="udiff-line-removed">- #endif</span>
  }
  
  nmethod* nmethod::new_native_nmethod(const methodHandle&amp; method,
    int compile_id,
    CodeBuffer *code_buffer,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -444,29 +456,31 @@</span>
    OopMapSet* oop_maps) {
    code_buffer-&gt;finalize_oop_references(method);
    // create nmethod
    nmethod* nm = NULL;
    {
<span class="udiff-line-modified-removed">-     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
      int native_nmethod_size = CodeBlob::allocation_size(code_buffer, sizeof(nmethod));
<span class="udiff-line-added">+ </span>
      CodeOffsets offsets;
      offsets.set_value(CodeOffsets::Verified_Entry, vep_offset);
      offsets.set_value(CodeOffsets::Frame_Complete, frame_complete);
<span class="udiff-line-modified-removed">-     nm = new (native_nmethod_size, CompLevel_none) nmethod(method(), compiler_none, native_nmethod_size,</span>
<span class="udiff-line-modified-removed">-                                             compile_id, &amp;offsets,</span>
<span class="udiff-line-modified-removed">-                                             code_buffer, frame_size,</span>
<span class="udiff-line-modified-removed">-                                             basic_lock_owner_sp_offset,</span>
<span class="udiff-line-modified-removed">-                                             basic_lock_sp_offset, oop_maps);</span>
<span class="udiff-line-modified-added">+     nm = new (native_nmethod_size, CompLevel_none)</span>
<span class="udiff-line-modified-added">+     nmethod(method(), compiler_none, native_nmethod_size,</span>
<span class="udiff-line-modified-added">+             compile_id, &amp;offsets,</span>
<span class="udiff-line-modified-added">+             code_buffer, frame_size,</span>
<span class="udiff-line-modified-added">+             basic_lock_owner_sp_offset,</span>
<span class="udiff-line-added">+             basic_lock_sp_offset,</span>
<span class="udiff-line-added">+             oop_maps);</span>
      NOT_PRODUCT(if (nm != NULL)  native_nmethod_stats.note_native_nmethod(nm));
    }
  
    if (nm != NULL) {
      // verify nmethod
      debug_only(nm-&gt;verify();) // might block
  
      nm-&gt;log_new_nmethod();
<span class="udiff-line-removed">-     nm-&gt;make_in_use();</span>
    }
    return nm;
  }
  
  nmethod* nmethod::new_nmethod(const methodHandle&amp; method,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -481,26 +495,36 @@</span>
    ExceptionHandlerTable* handler_table,
    ImplicitExceptionTable* nul_chk_table,
    AbstractCompiler* compiler,
    int comp_level
  #if INCLUDE_JVMCI
<span class="udiff-line-modified-removed">-   , jweak installed_code,</span>
<span class="udiff-line-modified-removed">-   jweak speculationLog</span>
<span class="udiff-line-modified-added">+   , char* speculations,</span>
<span class="udiff-line-modified-added">+   int speculations_len,</span>
<span class="udiff-line-added">+   int nmethod_mirror_index,</span>
<span class="udiff-line-added">+   const char* nmethod_mirror_name,</span>
<span class="udiff-line-added">+   FailedSpeculation** failed_speculations</span>
  #endif
  )
  {
    assert(debug_info-&gt;oop_recorder() == code_buffer-&gt;oop_recorder(), &quot;shared OR&quot;);
    code_buffer-&gt;finalize_oop_references(method);
    // create nmethod
    nmethod* nm = NULL;
<span class="udiff-line-modified-removed">-   { MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+   { MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-added">+ #if INCLUDE_JVMCI</span>
<span class="udiff-line-added">+     int jvmci_data_size = !compiler-&gt;is_jvmci() ? 0 : JVMCINMethodData::compute_size(nmethod_mirror_name);</span>
<span class="udiff-line-added">+ #endif</span>
      int nmethod_size =
        CodeBlob::allocation_size(code_buffer, sizeof(nmethod))
        + adjust_pcs_size(debug_info-&gt;pcs_size())
        + align_up((int)dependencies-&gt;size_in_bytes(), oopSize)
        + align_up(handler_table-&gt;size_in_bytes()    , oopSize)
        + align_up(nul_chk_table-&gt;size_in_bytes()    , oopSize)
<span class="udiff-line-added">+ #if INCLUDE_JVMCI</span>
<span class="udiff-line-added">+       + align_up(speculations_len                  , oopSize)</span>
<span class="udiff-line-added">+       + align_up(jvmci_data_size                   , oopSize)</span>
<span class="udiff-line-added">+ #endif</span>
        + align_up(debug_info-&gt;data_size()           , oopSize);
  
      nm = new (nmethod_size, comp_level)
      nmethod(method(), compiler-&gt;type(), nmethod_size, compile_id, entry_bci, offsets,
              orig_pc_offset, debug_info, dependencies, code_buffer, frame_size,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -508,16 +532,23 @@</span>
              handler_table,
              nul_chk_table,
              compiler,
              comp_level
  #if INCLUDE_JVMCI
<span class="udiff-line-modified-removed">-             , installed_code,</span>
<span class="udiff-line-modified-removed">-             speculationLog</span>
<span class="udiff-line-modified-added">+             , speculations,</span>
<span class="udiff-line-modified-added">+             speculations_len,</span>
<span class="udiff-line-added">+             jvmci_data_size</span>
  #endif
              );
  
      if (nm != NULL) {
<span class="udiff-line-added">+ #if INCLUDE_JVMCI</span>
<span class="udiff-line-added">+       if (compiler-&gt;is_jvmci()) {</span>
<span class="udiff-line-added">+         // Initialize the JVMCINMethodData object inlined into nm</span>
<span class="udiff-line-added">+         nm-&gt;jvmci_nmethod_data()-&gt;initialize(nmethod_mirror_index, nmethod_mirror_name, failed_speculations);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ #endif</span>
        // To make dependency checking during class loading fast, record
        // the nmethod dependencies in the classes it is dependent on.
        // This allows the dependency checking code to simply walk the
        // class hierarchy above the loaded class, checking only nmethods
        // which are dependent on those classes.  The slow way is to
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -566,13 +597,13 @@</span>
    _is_unloading_state(0),
    _native_receiver_sp_offset(basic_lock_owner_sp_offset),
    _native_basic_lock_sp_offset(basic_lock_sp_offset)
  {
    {
<span class="udiff-line-modified-removed">-     int scopes_data_offset = 0;</span>
<span class="udiff-line-modified-removed">-     int deoptimize_offset       = 0;</span>
<span class="udiff-line-modified-removed">-     int deoptimize_mh_offset    = 0;</span>
<span class="udiff-line-modified-added">+     int scopes_data_offset   = 0;</span>
<span class="udiff-line-modified-added">+     int deoptimize_offset    = 0;</span>
<span class="udiff-line-modified-added">+     int deoptimize_mh_offset = 0;</span>
  
      debug_only(NoSafepointVerifier nsv;)
      assert_locked_or_safepoint(CodeCache_lock);
  
      init_defaults();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -589,11 +620,17 @@</span>
      scopes_data_offset       = _metadata_offset     + align_up(code_buffer-&gt;total_metadata_size(), wordSize);
      _scopes_pcs_offset       = scopes_data_offset;
      _dependencies_offset     = _scopes_pcs_offset;
      _handler_table_offset    = _dependencies_offset;
      _nul_chk_table_offset    = _handler_table_offset;
<span class="udiff-line-added">+ #if INCLUDE_JVMCI</span>
<span class="udiff-line-added">+     _speculations_offset     = _nul_chk_table_offset;</span>
<span class="udiff-line-added">+     _jvmci_data_offset       = _speculations_offset;</span>
<span class="udiff-line-added">+     _nmethod_end_offset      = _jvmci_data_offset;</span>
<span class="udiff-line-added">+ #else</span>
      _nmethod_end_offset      = _nul_chk_table_offset;
<span class="udiff-line-added">+ #endif</span>
      _compile_id              = compile_id;
      _comp_level              = CompLevel_none;
      _entry_point             = code_begin()          + offsets-&gt;value(CodeOffsets::Entry);
      _verified_entry_point    = code_begin()          + offsets-&gt;value(CodeOffsets::Verified_Entry);
      _osr_entry_point         = NULL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -625,22 +662,36 @@</span>
        xtty-&gt;begin_head(&quot;print_native_nmethod&quot;);
        xtty-&gt;method(_method);
        xtty-&gt;stamp();
        xtty-&gt;end_head(&quot; address=&#39;&quot; INTPTR_FORMAT &quot;&#39;&quot;, (intptr_t) this);
      }
<span class="udiff-line-modified-removed">-     // print the header part first</span>
<span class="udiff-line-modified-removed">-     print();</span>
<span class="udiff-line-removed">-     // then print the requested information</span>
<span class="udiff-line-modified-added">+     // Print the header part, then print the requested information.</span>
<span class="udiff-line-modified-added">+     // This is both handled in decode2(), called via print_code() -&gt; decode()</span>
      if (PrintNativeNMethods) {
<span class="udiff-line-added">+       tty-&gt;print_cr(&quot;-------------------------- Assembly (native nmethod) ---------------------------&quot;);</span>
        print_code();
<span class="udiff-line-modified-removed">-       if (oop_maps != NULL) {</span>
<span class="udiff-line-modified-removed">-         oop_maps-&gt;print();</span>
<span class="udiff-line-modified-added">+       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);</span>
<span class="udiff-line-modified-added">+ #if defined(SUPPORT_DATA_STRUCTS)</span>
<span class="udiff-line-added">+       if (AbstractDisassembler::show_structs()) {</span>
<span class="udiff-line-added">+         if (oop_maps != NULL) {</span>
<span class="udiff-line-added">+           tty-&gt;print(&quot;oop maps:&quot;); // oop_maps-&gt;print_on(tty) outputs a cr() at the beginning</span>
<span class="udiff-line-added">+           oop_maps-&gt;print_on(tty);</span>
<span class="udiff-line-added">+           tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);</span>
<span class="udiff-line-added">+         }</span>
        }
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       print(); // print the header part only.</span>
      }
<span class="udiff-line-modified-removed">-     if (PrintRelocations) {</span>
<span class="udiff-line-modified-removed">-       print_relocations();</span>
<span class="udiff-line-modified-added">+ #if defined(SUPPORT_DATA_STRUCTS)</span>
<span class="udiff-line-modified-added">+     if (AbstractDisassembler::show_structs()) {</span>
<span class="udiff-line-added">+       if (PrintRelocations) {</span>
<span class="udiff-line-added">+         print_relocations();</span>
<span class="udiff-line-added">+         tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);</span>
<span class="udiff-line-added">+       }</span>
      }
<span class="udiff-line-added">+ #endif</span>
      if (xtty != NULL) {
        xtty-&gt;tail(&quot;print_native_nmethod&quot;);
      }
    }
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -665,12 +716,13 @@</span>
    ExceptionHandlerTable* handler_table,
    ImplicitExceptionTable* nul_chk_table,
    AbstractCompiler* compiler,
    int comp_level
  #if INCLUDE_JVMCI
<span class="udiff-line-modified-removed">-   , jweak installed_code,</span>
<span class="udiff-line-modified-removed">-   jweak speculation_log</span>
<span class="udiff-line-modified-added">+   , char* speculations,</span>
<span class="udiff-line-modified-added">+   int speculations_len,</span>
<span class="udiff-line-added">+   int jvmci_data_size</span>
  #endif
    )
    : CompiledMethod(method, &quot;nmethod&quot;, type, nmethod_size, sizeof(nmethod), code_buffer, offsets-&gt;value(CodeOffsets::Frame_Complete), frame_size, oop_maps, false),
    _is_unloading_state(0),
    _native_receiver_sp_offset(in_ByteSize(-1)),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -695,19 +747,10 @@</span>
      _consts_offset           = content_offset()      + code_buffer-&gt;total_offset_of(code_buffer-&gt;consts());
      _stub_offset             = content_offset()      + code_buffer-&gt;total_offset_of(code_buffer-&gt;stubs());
      set_ctable_begin(header_begin() + _consts_offset);
  
  #if INCLUDE_JVMCI
<span class="udiff-line-removed">-     _jvmci_installed_code = installed_code;</span>
<span class="udiff-line-removed">-     _speculation_log = speculation_log;</span>
<span class="udiff-line-removed">-     oop obj = JNIHandles::resolve(installed_code);</span>
<span class="udiff-line-removed">-     if (obj == NULL || (obj-&gt;is_a(HotSpotNmethod::klass()) &amp;&amp; HotSpotNmethod::isDefault(obj))) {</span>
<span class="udiff-line-removed">-       _jvmci_installed_code_triggers_invalidation = false;</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       _jvmci_installed_code_triggers_invalidation = true;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      if (compiler-&gt;is_jvmci()) {
        // JVMCI might not produce any stub sections
        if (offsets-&gt;value(CodeOffsets::Exceptions) != -1) {
          _exception_offset        = code_offset()          + offsets-&gt;value(CodeOffsets::Exceptions);
        } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -721,25 +764,24 @@</span>
        if (offsets-&gt;value(CodeOffsets::DeoptMH) != -1) {
          _deopt_mh_handler_begin  = (address) this + code_offset()          + offsets-&gt;value(CodeOffsets::DeoptMH);
        } else {
          _deopt_mh_handler_begin = NULL;
        }
<span class="udiff-line-modified-removed">-     } else {</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-     // Exception handler and deopt handler are in the stub section</span>
<span class="udiff-line-removed">-     assert(offsets-&gt;value(CodeOffsets::Exceptions) != -1, &quot;must be set&quot;);</span>
<span class="udiff-line-removed">-     assert(offsets-&gt;value(CodeOffsets::Deopt     ) != -1, &quot;must be set&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     _exception_offset       = _stub_offset          + offsets-&gt;value(CodeOffsets::Exceptions);</span>
<span class="udiff-line-removed">-     _deopt_handler_begin    = (address) this + _stub_offset          + offsets-&gt;value(CodeOffsets::Deopt);</span>
<span class="udiff-line-removed">-     if (offsets-&gt;value(CodeOffsets::DeoptMH) != -1) {</span>
<span class="udiff-line-removed">-       _deopt_mh_handler_begin  = (address) this + _stub_offset          + offsets-&gt;value(CodeOffsets::DeoptMH);</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       _deopt_mh_handler_begin  = NULL;</span>
<span class="udiff-line-removed">- #if INCLUDE_JVMCI</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     } else</span>
  #endif
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       // Exception handler and deopt handler are in the stub section</span>
<span class="udiff-line-added">+       assert(offsets-&gt;value(CodeOffsets::Exceptions) != -1, &quot;must be set&quot;);</span>
<span class="udiff-line-added">+       assert(offsets-&gt;value(CodeOffsets::Deopt     ) != -1, &quot;must be set&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       _exception_offset       = _stub_offset          + offsets-&gt;value(CodeOffsets::Exceptions);</span>
<span class="udiff-line-added">+       _deopt_handler_begin    = (address) this + _stub_offset          + offsets-&gt;value(CodeOffsets::Deopt);</span>
<span class="udiff-line-added">+       if (offsets-&gt;value(CodeOffsets::DeoptMH) != -1) {</span>
<span class="udiff-line-added">+         _deopt_mh_handler_begin  = (address) this + _stub_offset          + offsets-&gt;value(CodeOffsets::DeoptMH);</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         _deopt_mh_handler_begin  = NULL;</span>
<span class="udiff-line-added">+       }</span>
      }
      if (offsets-&gt;value(CodeOffsets::UnwindHandler) != -1) {
        _unwind_handler_offset = code_offset()         + offsets-&gt;value(CodeOffsets::UnwindHandler);
      } else {
        _unwind_handler_offset = -1;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -751,17 +793,22 @@</span>
  
      _scopes_pcs_offset       = scopes_data_offset    + align_up(debug_info-&gt;data_size       (), oopSize);
      _dependencies_offset     = _scopes_pcs_offset    + adjust_pcs_size(debug_info-&gt;pcs_size());
      _handler_table_offset    = _dependencies_offset  + align_up((int)dependencies-&gt;size_in_bytes (), oopSize);
      _nul_chk_table_offset    = _handler_table_offset + align_up(handler_table-&gt;size_in_bytes(), oopSize);
<span class="udiff-line-added">+ #if INCLUDE_JVMCI</span>
<span class="udiff-line-added">+     _speculations_offset     = _nul_chk_table_offset + align_up(nul_chk_table-&gt;size_in_bytes(), oopSize);</span>
<span class="udiff-line-added">+     _jvmci_data_offset       = _speculations_offset  + align_up(speculations_len, oopSize);</span>
<span class="udiff-line-added">+     _nmethod_end_offset      = _jvmci_data_offset    + align_up(jvmci_data_size, oopSize);</span>
<span class="udiff-line-added">+ #else</span>
      _nmethod_end_offset      = _nul_chk_table_offset + align_up(nul_chk_table-&gt;size_in_bytes(), oopSize);
<span class="udiff-line-added">+ #endif</span>
      _entry_point             = code_begin()          + offsets-&gt;value(CodeOffsets::Entry);
      _verified_entry_point    = code_begin()          + offsets-&gt;value(CodeOffsets::Verified_Entry);
      _osr_entry_point         = code_begin()          + offsets-&gt;value(CodeOffsets::OSR_Entry);
      _exception_cache         = NULL;
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-     _scopes_data_begin = (address) this + scopes_data_offset;</span>
<span class="udiff-line-modified-added">+     _scopes_data_begin       = (address) this + scopes_data_offset;</span>
  
      _pc_desc_container.reset_to(scopes_pcs_begin());
  
      code_buffer-&gt;copy_code_and_locs_to(this);
      // Copy contents of ScopeDescRecorder to nmethod
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -777,10 +824,17 @@</span>
  
      // Copy contents of ExceptionHandlerTable to nmethod
      handler_table-&gt;copy_to(this);
      nul_chk_table-&gt;copy_to(this);
  
<span class="udiff-line-added">+ #if INCLUDE_JVMCI</span>
<span class="udiff-line-added">+     // Copy speculations to nmethod</span>
<span class="udiff-line-added">+     if (speculations_size() != 0) {</span>
<span class="udiff-line-added">+       memcpy(speculations_begin(), speculations, speculations_len);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
      // we use the information of entry points to find out if a method is
      // static or non static
      assert(compiler-&gt;is_c2() || compiler-&gt;is_jvmci() ||
             _method-&gt;is_static() == (entry_point() == _verified_entry_point),
             &quot; entry points must be same for static methods and vice versa&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -796,17 +850,18 @@</span>
    log-&gt;print(&quot; compiler=&#39;%s&#39;&quot;, compiler_name());
    if (TieredCompilation) {
      log-&gt;print(&quot; level=&#39;%d&#39;&quot;, comp_level());
    }
  #if INCLUDE_JVMCI
<span class="udiff-line-modified-removed">-     char buffer[O_BUFLEN];</span>
<span class="udiff-line-modified-removed">-     char* jvmci_name = jvmci_installed_code_name(buffer, O_BUFLEN);</span>
<span class="udiff-line-modified-added">+   if (jvmci_nmethod_data() != NULL) {</span>
<span class="udiff-line-modified-added">+     const char* jvmci_name = jvmci_nmethod_data()-&gt;name();</span>
      if (jvmci_name != NULL) {
<span class="udiff-line-modified-removed">-       log-&gt;print(&quot; jvmci_installed_code_name=&#39;&quot;);</span>
<span class="udiff-line-modified-added">+       log-&gt;print(&quot; jvmci_mirror_name=&#39;&quot;);</span>
        log-&gt;text(&quot;%s&quot;, jvmci_name);
        log-&gt;print(&quot;&#39;&quot;);
      }
<span class="udiff-line-added">+   }</span>
  #endif
  }
  
  
  #define LOG_OFFSET(log, name)                    \
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -867,40 +922,81 @@</span>
  
  void nmethod::print_nmethod(bool printmethod) {
    ttyLocker ttyl;  // keep the following output all in one block
    if (xtty != NULL) {
      xtty-&gt;begin_head(&quot;print_nmethod&quot;);
<span class="udiff-line-added">+     log_identity(xtty);</span>
      xtty-&gt;stamp();
      xtty-&gt;end_head();
    }
<span class="udiff-line-modified-removed">-   // print the header part first</span>
<span class="udiff-line-modified-removed">-   print();</span>
<span class="udiff-line-removed">-   // then print the requested information</span>
<span class="udiff-line-modified-added">+   // Print the header part, then print the requested information.</span>
<span class="udiff-line-modified-added">+   // This is both handled in decode2().</span>
    if (printmethod) {
<span class="udiff-line-modified-removed">-     print_code();</span>
<span class="udiff-line-modified-removed">-     print_pcs();</span>
<span class="udiff-line-modified-removed">-     if (oop_maps()) {</span>
<span class="udiff-line-modified-removed">-       oop_maps()-&gt;print();</span>
<span class="udiff-line-modified-added">+     HandleMark hm;</span>
<span class="udiff-line-modified-added">+     ResourceMark m;</span>
<span class="udiff-line-modified-added">+     if (is_compiled_by_c1()) {</span>
<span class="udiff-line-modified-added">+       tty-&gt;cr();</span>
<span class="udiff-line-added">+       tty-&gt;print_cr(&quot;============================= C1-compiled nmethod ==============================&quot;);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if (is_compiled_by_jvmci()) {</span>
<span class="udiff-line-added">+       tty-&gt;cr();</span>
<span class="udiff-line-added">+       tty-&gt;print_cr(&quot;=========================== JVMCI-compiled nmethod =============================&quot;);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     tty-&gt;print_cr(&quot;----------------------------------- Assembly -----------------------------------&quot;);</span>
<span class="udiff-line-added">+     decode2(tty);</span>
<span class="udiff-line-added">+ #if defined(SUPPORT_DATA_STRUCTS)</span>
<span class="udiff-line-added">+     if (AbstractDisassembler::show_structs()) {</span>
<span class="udiff-line-added">+       // Print the oops from the underlying CodeBlob as well.</span>
<span class="udiff-line-added">+       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);</span>
<span class="udiff-line-added">+       print_oops(tty);</span>
<span class="udiff-line-added">+       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);</span>
<span class="udiff-line-added">+       print_metadata(tty);</span>
<span class="udiff-line-added">+       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);</span>
<span class="udiff-line-added">+       print_pcs();</span>
<span class="udiff-line-added">+       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);</span>
<span class="udiff-line-added">+       if (oop_maps() != NULL) {</span>
<span class="udiff-line-added">+         tty-&gt;print(&quot;oop maps:&quot;); // oop_maps()-&gt;print_on(tty) outputs a cr() at the beginning</span>
<span class="udiff-line-added">+         oop_maps()-&gt;print_on(tty);</span>
<span class="udiff-line-added">+         tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);</span>
<span class="udiff-line-added">+       }</span>
      }
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     print(); // print the header part only.</span>
    }
<span class="udiff-line-modified-removed">-   if (printmethod || PrintDebugInfo || CompilerOracle::has_option_string(_method, &quot;PrintDebugInfo&quot;)) {</span>
<span class="udiff-line-modified-removed">-     print_scopes();</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">-   if (printmethod || PrintRelocations || CompilerOracle::has_option_string(_method, &quot;PrintRelocations&quot;)) {</span>
<span class="udiff-line-modified-removed">-     print_relocations();</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">-   if (printmethod || PrintDependencies || CompilerOracle::has_option_string(_method, &quot;PrintDependencies&quot;)) {</span>
<span class="udiff-line-modified-removed">-     print_dependencies();</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">-   if (printmethod || PrintExceptionHandlers) {</span>
<span class="udiff-line-modified-removed">-     print_handler_table();</span>
<span class="udiff-line-modified-removed">-     print_nul_chk_table();</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">-   if (printmethod) {</span>
<span class="udiff-line-modified-removed">-     print_recorded_oops();</span>
<span class="udiff-line-modified-removed">-     print_recorded_metadata();</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ #if defined(SUPPORT_DATA_STRUCTS)</span>
<span class="udiff-line-modified-added">+   if (AbstractDisassembler::show_structs()) {</span>
<span class="udiff-line-modified-added">+     methodHandle mh(Thread::current(), _method);</span>
<span class="udiff-line-modified-added">+     if (printmethod || PrintDebugInfo || CompilerOracle::has_option_string(mh, &quot;PrintDebugInfo&quot;)) {</span>
<span class="udiff-line-modified-added">+       print_scopes();</span>
<span class="udiff-line-modified-added">+       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+     if (printmethod || PrintRelocations || CompilerOracle::has_option_string(mh, &quot;PrintRelocations&quot;)) {</span>
<span class="udiff-line-modified-added">+       print_relocations();</span>
<span class="udiff-line-modified-added">+       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+     if (printmethod || PrintDependencies || CompilerOracle::has_option_string(mh, &quot;PrintDependencies&quot;)) {</span>
<span class="udiff-line-modified-added">+       print_dependencies();</span>
<span class="udiff-line-modified-added">+       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-added">+     if (printmethod || PrintExceptionHandlers) {</span>
<span class="udiff-line-added">+       print_handler_table();</span>
<span class="udiff-line-added">+       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);</span>
<span class="udiff-line-added">+       print_nul_chk_table();</span>
<span class="udiff-line-added">+       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (printmethod) {</span>
<span class="udiff-line-added">+       print_recorded_oops();</span>
<span class="udiff-line-added">+       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);</span>
<span class="udiff-line-added">+       print_recorded_metadata();</span>
<span class="udiff-line-added">+       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);</span>
<span class="udiff-line-added">+     }</span>
    }
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
    if (xtty != NULL) {
      xtty-&gt;tail(&quot;print_nmethod&quot;);
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -949,11 +1045,11 @@</span>
    while (iter.next()) {
      if (iter.type() == relocInfo::oop_type) {
        oop_Relocation* reloc = iter.oop_reloc();
        if (initialize_immediates &amp;&amp; reloc-&gt;oop_is_immediate()) {
          oop* dest = reloc-&gt;oop_addr();
<span class="udiff-line-modified-removed">-         initialize_immediate_oop(dest, (jobject) *dest);</span>
<span class="udiff-line-modified-added">+         initialize_immediate_oop(dest, cast_from_oop&lt;jobject&gt;(*dest));</span>
        }
        // Refresh the oop-related bits of this instruction.
        reloc-&gt;fix_oop_relocation();
      } else if (iter.type() == relocInfo::metadata_type) {
        metadata_Relocation* reloc = iter.metadata_reloc();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1041,10 +1137,29 @@</span>
    if (mdo == NULL)  return;
    // There is a benign race here.  See comments in methodData.hpp.
    mdo-&gt;inc_decompile_count();
  }
  
<span class="udiff-line-added">+ bool nmethod::try_transition(int new_state_int) {</span>
<span class="udiff-line-added">+   signed char new_state = new_state_int;</span>
<span class="udiff-line-added">+ #ifdef DEBUG</span>
<span class="udiff-line-added">+   if (new_state != unloaded) {</span>
<span class="udiff-line-added">+     assert_lock_strong(CompiledMethod_lock);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+   for (;;) {</span>
<span class="udiff-line-added">+     signed char old_state = Atomic::load(&amp;_state);</span>
<span class="udiff-line-added">+     if (old_state &gt;= new_state) {</span>
<span class="udiff-line-added">+       // Ensure monotonicity of transitions.</span>
<span class="udiff-line-added">+       return false;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if (Atomic::cmpxchg(&amp;_state, old_state, new_state) == old_state) {</span>
<span class="udiff-line-added">+       return true;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void nmethod::make_unloaded() {
    post_compiled_method_unload();
  
    // This nmethod is being unloaded, make sure that dependencies
    // recorded in instanceKlasses get flushed.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1064,11 +1179,13 @@</span>
               p2i(this), p2i(_method));
       ls.cr();
    }
    // Unlink the osr method, so we do not look this up again
    if (is_osr_method()) {
<span class="udiff-line-modified-removed">-     // Invalidate the osr nmethod only once</span>
<span class="udiff-line-modified-added">+     // Invalidate the osr nmethod only once. Note that with concurrent</span>
<span class="udiff-line-added">+     // code cache unloading, OSR nmethods are invalidated before they</span>
<span class="udiff-line-added">+     // are made unloaded. Therefore, this becomes a no-op then.</span>
      if (is_in_use()) {
        invalidate_osr_method();
      }
  #ifdef ASSERT
      if (method() != NULL) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1082,16 +1199,11 @@</span>
    // If _method is already NULL the Method* is about to be unloaded,
    // so we don&#39;t have to break the cycle. Note that it is possible to
    // have the Method* live here, in case we unload the nmethod because
    // it is pointing to some oop (other than the Method*) being unloaded.
    if (_method != NULL) {
<span class="udiff-line-modified-removed">-     // OSR methods point to the Method*, but the Method* does not</span>
<span class="udiff-line-removed">-     // point back!</span>
<span class="udiff-line-removed">-     if (_method-&gt;code() == this) {</span>
<span class="udiff-line-removed">-       _method-&gt;clear_code(); // Break a cycle</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     _method = NULL;            // Clear the method of this dead nmethod</span>
<span class="udiff-line-modified-added">+     _method-&gt;unlink_code(this);</span>
    }
  
    // Make the class unloaded - i.e., change state and notify sweeper
    assert(SafepointSynchronize::is_at_safepoint() || Thread::current()-&gt;is_ConcurrentGC_thread(),
           &quot;must be at safepoint&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1102,37 +1214,44 @@</span>
      clear_ic_callsites();
    }
  
    // Unregister must be done before the state change
    {
<span class="udiff-line-modified-removed">-     MutexLockerEx ml(SafepointSynchronize::is_at_safepoint() ? NULL : CodeCache_lock,</span>
<span class="udiff-line-modified-added">+     MutexLocker ml(SafepointSynchronize::is_at_safepoint() ? NULL : CodeCache_lock,</span>
                       Mutex::_no_safepoint_check_flag);
      Universe::heap()-&gt;unregister_nmethod(this);
    }
  
<span class="udiff-line-added">+   // Clear the method of this dead nmethod</span>
<span class="udiff-line-added">+   set_method(NULL);</span>
<span class="udiff-line-added">+ </span>
    // Log the unloading.
    log_state_change();
  
<span class="udiff-line-removed">- #if INCLUDE_JVMCI</span>
<span class="udiff-line-removed">-   // The method can only be unloaded after the pointer to the installed code</span>
<span class="udiff-line-removed">-   // Java wrapper is no longer alive. Here we need to clear out this weak</span>
<span class="udiff-line-removed">-   // reference to the dead object.</span>
<span class="udiff-line-removed">-   maybe_invalidate_installed_code();</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
    // The Method* is gone at this point
    assert(_method == NULL, &quot;Tautology&quot;);
  
    set_osr_link(NULL);
    NMethodSweeper::report_state_change(this);
  
<span class="udiff-line-modified-removed">-   // The release is only needed for compile-time ordering, as accesses</span>
<span class="udiff-line-modified-removed">-   // into the nmethod after the store are not safe due to the sweeper</span>
<span class="udiff-line-modified-removed">-   // being allowed to free it when the store is observed, during</span>
<span class="udiff-line-modified-removed">-   // concurrent nmethod unloading. Therefore, there is no need for</span>
<span class="udiff-line-modified-removed">-   // acquire on the loader side.</span>
<span class="udiff-line-modified-removed">-   OrderAccess::release_store(&amp;_state, (signed char)unloaded);</span>
<span class="udiff-line-modified-added">+   bool transition_success = try_transition(unloaded);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   // It is an important invariant that there exists no race between</span>
<span class="udiff-line-modified-added">+   // the sweeper and GC thread competing for making the same nmethod</span>
<span class="udiff-line-modified-added">+   // zombie and unloaded respectively. This is ensured by</span>
<span class="udiff-line-modified-added">+   // can_convert_to_zombie() returning false for any is_unloading()</span>
<span class="udiff-line-added">+   // nmethod, informing the sweeper not to step on any GC toes.</span>
<span class="udiff-line-added">+   assert(transition_success, &quot;Invalid nmethod transition to unloaded&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #if INCLUDE_JVMCI</span>
<span class="udiff-line-added">+   // Clear the link between this nmethod and a HotSpotNmethod mirror</span>
<span class="udiff-line-added">+   JVMCINMethodData* nmethod_data = jvmci_nmethod_data();</span>
<span class="udiff-line-added">+   if (nmethod_data != NULL) {</span>
<span class="udiff-line-added">+     nmethod_data-&gt;invalidate_nmethod_mirror(this);</span>
<span class="udiff-line-added">+     nmethod_data-&gt;clear_nmethod_mirror(this);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ #endif</span>
  }
  
  void nmethod::invalidate_osr_method() {
    assert(_entry_bci != InvocationEntryBci, &quot;wrong kind of nmethod&quot;);
    // Remove from list of active nmethods
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1164,66 +1283,55 @@</span>
    if (PrintCompilation &amp;&amp; _state != unloaded) {
      print_on(tty, state_msg);
    }
  }
  
<span class="udiff-line-modified-removed">- void nmethod::unlink_from_method(bool acquire_lock) {</span>
<span class="udiff-line-modified-removed">-   // We need to check if both the _code and _from_compiled_code_entry_point</span>
<span class="udiff-line-modified-removed">-   // refer to this nmethod because there is a race in setting these two fields</span>
<span class="udiff-line-removed">-   // in Method* as seen in bugid 4947125.</span>
<span class="udiff-line-removed">-   // If the vep() points to the zombie nmethod, the memory for the nmethod</span>
<span class="udiff-line-removed">-   // could be flushed and the compiler and vtable stubs could still call</span>
<span class="udiff-line-removed">-   // through it.</span>
<span class="udiff-line-removed">-   if (method() != NULL &amp;&amp; (method()-&gt;code() == this ||</span>
<span class="udiff-line-removed">-                            method()-&gt;from_compiled_entry() == verified_entry_point())) {</span>
<span class="udiff-line-removed">-     method()-&gt;clear_code(acquire_lock);</span>
<span class="udiff-line-modified-added">+ void nmethod::unlink_from_method() {</span>
<span class="udiff-line-modified-added">+   if (method() != NULL) {</span>
<span class="udiff-line-modified-added">+     method()-&gt;unlink_code(this);</span>
    }
  }
  
  /**
   * Common functionality for both make_not_entrant and make_zombie
   */
  bool nmethod::make_not_entrant_or_zombie(int state) {
    assert(state == zombie || state == not_entrant, &quot;must be zombie or not_entrant&quot;);
<span class="udiff-line-removed">-   assert(!is_zombie(), &quot;should not already be a zombie&quot;);</span>
  
<span class="udiff-line-modified-removed">-   if (_state == state) {</span>
<span class="udiff-line-modified-added">+   if (Atomic::load(&amp;_state) &gt;= state) {</span>
      // Avoid taking the lock if already in required state.
      // This is safe from races because the state is an end-state,
      // which the nmethod cannot back out of once entered.
      // No need for fencing either.
      return false;
    }
  
<span class="udiff-line-modified-removed">-   // Make sure neither the nmethod nor the method is flushed in case of a safepoint in code below.</span>
<span class="udiff-line-modified-added">+   // Make sure the nmethod is not flushed.</span>
    nmethodLocker nml(this);
<span class="udiff-line-removed">-   methodHandle the_method(method());</span>
    // This can be called while the system is already at a safepoint which is ok
<span class="udiff-line-modified-removed">-   NoSafepointVerifier nsv(true, !SafepointSynchronize::is_at_safepoint());</span>
<span class="udiff-line-modified-added">+   NoSafepointVerifier nsv;</span>
  
    // during patching, depending on the nmethod state we must notify the GC that
    // code has been unloaded, unregistering it. We cannot do this right while
<span class="udiff-line-modified-removed">-   // holding the Patching_lock because we need to use the CodeCache_lock. This</span>
<span class="udiff-line-modified-added">+   // holding the CompiledMethod_lock because we need to use the CodeCache_lock. This</span>
    // would be prone to deadlocks.
    // This flag is used to remember whether we need to later lock and unregister.
    bool nmethod_needs_unregister = false;
  
    {
<span class="udiff-line-modified-removed">-     // invalidate osr nmethod before acquiring the patching lock since</span>
<span class="udiff-line-modified-removed">-     // they both acquire leaf locks and we don&#39;t want a deadlock.</span>
<span class="udiff-line-modified-added">+     // Enter critical section.  Does not block for safepoint.</span>
<span class="udiff-line-modified-added">+     MutexLocker ml(CompiledMethod_lock-&gt;owned_by_self() ? NULL : CompiledMethod_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-added">+ </span>
      // This logic is equivalent to the logic below for patching the
      // verified entry point of regular methods. We check that the
      // nmethod is in use to ensure that it is invalidated only once.
      if (is_osr_method() &amp;&amp; is_in_use()) {
        // this effectively makes the osr nmethod not entrant
        invalidate_osr_method();
      }
  
<span class="udiff-line-modified-removed">-     // Enter critical section.  Does not block for safepoint.</span>
<span class="udiff-line-removed">-     MutexLockerEx pl(Patching_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (_state == state) {</span>
<span class="udiff-line-modified-added">+     if (Atomic::load(&amp;_state) &gt;= state) {</span>
        // another thread already performed this transition so nothing
        // to do, but return false to indicate this.
        return false;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1246,30 +1354,47 @@</span>
      if ((state == zombie) &amp;&amp; !is_unloaded()) {
        nmethod_needs_unregister = true;
      }
  
      // Must happen before state change. Otherwise we have a race condition in
<span class="udiff-line-modified-removed">-     // nmethod::can_not_entrant_be_converted(). I.e., a method can immediately</span>
<span class="udiff-line-modified-added">+     // nmethod::can_convert_to_zombie(). I.e., a method can immediately</span>
      // transition its state from &#39;not_entrant&#39; to &#39;zombie&#39; without having to wait
      // for stack scanning.
      if (state == not_entrant) {
        mark_as_seen_on_stack();
        OrderAccess::storestore(); // _stack_traversal_mark and _state
      }
  
      // Change state
<span class="udiff-line-modified-removed">-     _state = state;</span>
<span class="udiff-line-modified-added">+     if (!try_transition(state)) {</span>
<span class="udiff-line-added">+       // If the transition fails, it is due to another thread making the nmethod more</span>
<span class="udiff-line-added">+       // dead. In particular, one thread might be making the nmethod unloaded concurrently.</span>
<span class="udiff-line-added">+       // If so, having patched in the jump in the verified entry unnecessarily is fine.</span>
<span class="udiff-line-added">+       // The nmethod is no longer possible to call by Java threads.</span>
<span class="udiff-line-added">+       // Incrementing the decompile count is also fine as the caller of make_not_entrant()</span>
<span class="udiff-line-added">+       // had a valid reason to deoptimize the nmethod.</span>
<span class="udiff-line-added">+       // Marking the nmethod as seen on stack also has no effect, as the nmethod is now</span>
<span class="udiff-line-added">+       // !is_alive(), and the seen on stack value is only used to convert not_entrant</span>
<span class="udiff-line-added">+       // nmethods to zombie in can_convert_to_zombie().</span>
<span class="udiff-line-added">+       return false;</span>
<span class="udiff-line-added">+     }</span>
  
      // Log the transition once
      log_state_change();
  
<span class="udiff-line-removed">-     // Invalidate while holding the patching lock</span>
<span class="udiff-line-removed">-     JVMCI_ONLY(maybe_invalidate_installed_code());</span>
<span class="udiff-line-removed">- </span>
      // Remove nmethod from method.
<span class="udiff-line-modified-removed">-     unlink_from_method(false /* already owns Patching_lock */);</span>
<span class="udiff-line-modified-removed">-   } // leave critical region under Patching_lock</span>
<span class="udiff-line-modified-added">+     unlink_from_method();</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   } // leave critical region under CompiledMethod_lock</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #if INCLUDE_JVMCI</span>
<span class="udiff-line-added">+   // Invalidate can&#39;t occur while holding the Patching lock</span>
<span class="udiff-line-added">+   JVMCINMethodData* nmethod_data = jvmci_nmethod_data();</span>
<span class="udiff-line-added">+   if (nmethod_data != NULL) {</span>
<span class="udiff-line-added">+     nmethod_data-&gt;invalidate_nmethod_mirror(this);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ #endif</span>
  
  #ifdef ASSERT
    if (is_osr_method() &amp;&amp; method() != NULL) {
      // Make sure osr nmethod is invalidated, i.e. not on the list
      bool found = method()-&gt;method_holder()-&gt;remove_osr_nmethod(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1284,17 +1409,25 @@</span>
    if (state == zombie) {
      {
        // Flushing dependencies must be done before any possible
        // safepoint can sneak in, otherwise the oops used by the
        // dependency logic could have become stale.
<span class="udiff-line-modified-removed">-       MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+       MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
        if (nmethod_needs_unregister) {
          Universe::heap()-&gt;unregister_nmethod(this);
        }
        flush_dependencies(/*delete_immediately*/true);
      }
  
<span class="udiff-line-added">+ #if INCLUDE_JVMCI</span>
<span class="udiff-line-added">+     // Now that the nmethod has been unregistered, it&#39;s</span>
<span class="udiff-line-added">+     // safe to clear the HotSpotNmethod mirror oop.</span>
<span class="udiff-line-added">+     if (nmethod_data != NULL) {</span>
<span class="udiff-line-added">+       nmethod_data-&gt;clear_nmethod_mirror(this);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
      // Clear ICStubs to prevent back patching stubs of zombie or flushed
      // nmethods during the next safepoint (see ICStub::finalize), as well
      // as to free up CompiledICHolder resources.
      {
        CompiledICLocker ml(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1318,21 +1451,21 @@</span>
      set_method(NULL);
    } else {
      assert(state == not_entrant, &quot;other cases may need to be handled differently&quot;);
    }
  
<span class="udiff-line-modified-removed">-   if (TraceCreateZombies) {</span>
<span class="udiff-line-modified-added">+   if (TraceCreateZombies &amp;&amp; state == zombie) {</span>
      ResourceMark m;
      tty-&gt;print_cr(&quot;nmethod &lt;&quot; INTPTR_FORMAT &quot;&gt; %s code made %s&quot;, p2i(this), this-&gt;method() ? this-&gt;method()-&gt;name_and_sig_as_C_string() : &quot;null&quot;, (state == not_entrant) ? &quot;not entrant&quot; : &quot;zombie&quot;);
    }
  
    NMethodSweeper::report_state_change(this);
    return true;
  }
  
  void nmethod::flush() {
<span class="udiff-line-modified-removed">-   MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+   MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
    // Note that there are no valid oops in the nmethod anymore.
    assert(!is_osr_method() || is_unloaded() || is_zombie(),
           &quot;osr nmethod must be unloaded or zombie before flushing&quot;);
    assert(is_zombie() || is_osr_method(), &quot;must be a zombie method&quot;);
    assert (!is_locked_by_vm(), &quot;locked methods shouldn&#39;t be flushed&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1356,16 +1489,12 @@</span>
      ExceptionCache* next = ec-&gt;next();
      delete ec;
      ec = next;
    }
  
<span class="udiff-line-removed">- #if INCLUDE_JVMCI</span>
<span class="udiff-line-removed">-   assert(_jvmci_installed_code == NULL, &quot;should have been nulled out when transitioned to zombie&quot;);</span>
<span class="udiff-line-removed">-   assert(_speculation_log == NULL, &quot;should have been nulled out when transitioned to zombie&quot;);</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
    Universe::heap()-&gt;flush_nmethod(this);
<span class="udiff-line-added">+   CodeCache::unregister_old_nmethod(this);</span>
  
    CodeBlob::flush();
    CodeCache::free(this);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1374,10 +1503,17 @@</span>
      return NULL;
    }
    return NativeAccess&lt;AS_NO_KEEPALIVE&gt;::oop_load(oop_addr_at(index));
  }
  
<span class="udiff-line-added">+ oop nmethod::oop_at_phantom(int index) const {</span>
<span class="udiff-line-added">+   if (index == 0) {</span>
<span class="udiff-line-added">+     return NULL;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return NativeAccess&lt;ON_PHANTOM_OOP_REF&gt;::oop_load(oop_addr_at(index));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  //
  // Notify all classes this nmethod is dependent on that it is no
  // longer dependent. This should only be called in two situations.
  // First, when a nmethod transitions to a zombie all dependents need
  // to be clear.  Since zombification happens at a safepoint there&#39;s no
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1427,42 +1563,49 @@</span>
  
  // ------------------------------------------------------------------
  // post_compiled_method_load_event
  // new method for install_code() path
  // Transfer information from compilation to jvmti
<span class="udiff-line-modified-removed">- void nmethod::post_compiled_method_load_event() {</span>
<span class="udiff-line-modified-added">+ void nmethod::post_compiled_method_load_event(JvmtiThreadState* state) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Don&#39;t post this nmethod load event if it is already dying</span>
<span class="udiff-line-added">+   // because the sweeper might already be deleting this nmethod.</span>
<span class="udiff-line-added">+   if (is_not_entrant() &amp;&amp; can_convert_to_zombie()) {</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
  
<span class="udiff-line-modified-removed">-   Method* moop = method();</span>
<span class="udiff-line-modified-added">+   // This is a bad time for a safepoint.  We don&#39;t want</span>
<span class="udiff-line-added">+   // this nmethod to get unloaded while we&#39;re queueing the event.</span>
<span class="udiff-line-added">+   NoSafepointVerifier nsv;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Method* m = method();</span>
    HOTSPOT_COMPILED_METHOD_LOAD(
<span class="udiff-line-modified-removed">-       (char *) moop-&gt;klass_name()-&gt;bytes(),</span>
<span class="udiff-line-modified-removed">-       moop-&gt;klass_name()-&gt;utf8_length(),</span>
<span class="udiff-line-modified-removed">-       (char *) moop-&gt;name()-&gt;bytes(),</span>
<span class="udiff-line-modified-removed">-       moop-&gt;name()-&gt;utf8_length(),</span>
<span class="udiff-line-modified-removed">-       (char *) moop-&gt;signature()-&gt;bytes(),</span>
<span class="udiff-line-modified-removed">-       moop-&gt;signature()-&gt;utf8_length(),</span>
<span class="udiff-line-modified-added">+       (char *) m-&gt;klass_name()-&gt;bytes(),</span>
<span class="udiff-line-modified-added">+       m-&gt;klass_name()-&gt;utf8_length(),</span>
<span class="udiff-line-modified-added">+       (char *) m-&gt;name()-&gt;bytes(),</span>
<span class="udiff-line-modified-added">+       m-&gt;name()-&gt;utf8_length(),</span>
<span class="udiff-line-modified-added">+       (char *) m-&gt;signature()-&gt;bytes(),</span>
<span class="udiff-line-modified-added">+       m-&gt;signature()-&gt;utf8_length(),</span>
        insts_begin(), insts_size());
  
<span class="udiff-line-removed">-   if (JvmtiExport::should_post_compiled_method_load() ||</span>
<span class="udiff-line-removed">-       JvmtiExport::should_post_compiled_method_unload()) {</span>
<span class="udiff-line-removed">-     get_and_cache_jmethod_id();</span>
<span class="udiff-line-removed">-   }</span>
  
    if (JvmtiExport::should_post_compiled_method_load()) {
<span class="udiff-line-modified-removed">-     // Let the Service thread (which is a real Java thread) post the event</span>
<span class="udiff-line-modified-removed">-     MutexLockerEx ml(Service_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-removed">-     JvmtiDeferredEventQueue::enqueue(</span>
<span class="udiff-line-modified-removed">-       JvmtiDeferredEvent::compiled_method_load_event(this));</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">- }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- jmethodID nmethod::get_and_cache_jmethod_id() {</span>
<span class="udiff-line-modified-removed">-   if (_jmethod_id == NULL) {</span>
<span class="udiff-line-modified-removed">-     // Cache the jmethod_id since it can no longer be looked up once the</span>
<span class="udiff-line-modified-removed">-     // method itself has been marked for unloading.</span>
<span class="udiff-line-modified-removed">-     _jmethod_id = method()-&gt;jmethod_id();</span>
<span class="udiff-line-modified-added">+     // Only post unload events if load events are found.</span>
<span class="udiff-line-modified-added">+     set_load_reported();</span>
<span class="udiff-line-modified-added">+     // If a JavaThread hasn&#39;t been passed in, let the Service thread</span>
<span class="udiff-line-modified-added">+     // (which is a real Java thread) post the event</span>
<span class="udiff-line-modified-added">+     JvmtiDeferredEvent event = JvmtiDeferredEvent::compiled_method_load_event(this);</span>
<span class="udiff-line-modified-added">+     if (state == NULL) {</span>
<span class="udiff-line-modified-added">+       // Execute any barrier code for this nmethod as if it&#39;s called, since</span>
<span class="udiff-line-modified-added">+       // keeping it alive looks like stack walking.</span>
<span class="udiff-line-modified-added">+       run_nmethod_entry_barrier();</span>
<span class="udiff-line-modified-added">+       ServiceThread::enqueue_deferred_event(&amp;event);</span>
<span class="udiff-line-modified-added">+     } else {</span>
<span class="udiff-line-modified-added">+       // This enters the nmethod barrier outside in the caller.</span>
<span class="udiff-line-added">+       state-&gt;enqueue_event(&amp;event);</span>
<span class="udiff-line-added">+     }</span>
    }
<span class="udiff-line-removed">-   return _jmethod_id;</span>
  }
  
  void nmethod::post_compiled_method_unload() {
    if (unload_reported()) {
      // During unloading we transition to unloaded and then to zombie
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1474,22 +1617,21 @@</span>
    DTRACE_METHOD_UNLOAD_PROBE(method());
  
    // If a JVMTI agent has enabled the CompiledMethodUnload event then
    // post the event. Sometime later this nmethod will be made a zombie
    // by the sweeper but the Method* will not be valid at that point.
<span class="udiff-line-modified-removed">-   // If the _jmethod_id is null then no load event was ever requested</span>
<span class="udiff-line-removed">-   // so don&#39;t bother posting the unload.  The main reason for this is</span>
<span class="udiff-line-removed">-   // that the jmethodID is a weak reference to the Method* so if</span>
<span class="udiff-line-modified-added">+   // The jmethodID is a weak reference to the Method* so if</span>
    // it&#39;s being unloaded there&#39;s no way to look it up since the weak
    // ref will have been cleared.
<span class="udiff-line-modified-removed">-   if (_jmethod_id != NULL &amp;&amp; JvmtiExport::should_post_compiled_method_unload()) {</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   // Don&#39;t bother posting the unload if the load event wasn&#39;t posted.</span>
<span class="udiff-line-added">+   if (load_reported() &amp;&amp; JvmtiExport::should_post_compiled_method_unload()) {</span>
      assert(!unload_reported(), &quot;already unloaded&quot;);
      JvmtiDeferredEvent event =
<span class="udiff-line-modified-removed">-       JvmtiDeferredEvent::compiled_method_unload_event(this,</span>
<span class="udiff-line-modified-removed">-           _jmethod_id, insts_begin());</span>
<span class="udiff-line-modified-removed">-     MutexLockerEx ml(Service_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-removed">-     JvmtiDeferredEventQueue::enqueue(event);</span>
<span class="udiff-line-modified-added">+       JvmtiDeferredEvent::compiled_method_unload_event(</span>
<span class="udiff-line-modified-added">+           method()-&gt;jmethod_id(), insts_begin());</span>
<span class="udiff-line-modified-added">+     ServiceThread::enqueue_deferred_event(&amp;event);</span>
    }
  
    // The JVMTI CompiledMethodUnload event can be enabled or disabled at
    // any time. As the nmethod is being unloaded now we mark it has
    // having the unload event reported - this will ensure that we don&#39;t
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1497,54 +1639,54 @@</span>
    // event is enabled at the time the nmethod is made a zombie.
    set_unload_reported();
  }
  
  // Iterate over metadata calling this function.   Used by RedefineClasses
<span class="udiff-line-modified-removed">- void nmethod::metadata_do(void f(Metadata*)) {</span>
<span class="udiff-line-modified-added">+ void nmethod::metadata_do(MetadataClosure* f) {</span>
    {
      // Visit all immediate references that are embedded in the instruction stream.
      RelocIterator iter(this, oops_reloc_begin());
      while (iter.next()) {
<span class="udiff-line-modified-removed">-       if (iter.type() == relocInfo::metadata_type ) {</span>
<span class="udiff-line-modified-added">+       if (iter.type() == relocInfo::metadata_type) {</span>
          metadata_Relocation* r = iter.metadata_reloc();
          // In this metadata, we must only follow those metadatas directly embedded in
          // the code.  Other metadatas (oop_index&gt;0) are seen as part of
          // the metadata section below.
          assert(1 == (r-&gt;metadata_is_immediate()) +
                 (r-&gt;metadata_addr() &gt;= metadata_begin() &amp;&amp; r-&gt;metadata_addr() &lt; metadata_end()),
                 &quot;metadata must be found in exactly one place&quot;);
          if (r-&gt;metadata_is_immediate() &amp;&amp; r-&gt;metadata_value() != NULL) {
            Metadata* md = r-&gt;metadata_value();
<span class="udiff-line-modified-removed">-           if (md != _method) f(md);</span>
<span class="udiff-line-modified-added">+           if (md != _method) f-&gt;do_metadata(md);</span>
          }
        } else if (iter.type() == relocInfo::virtual_call_type) {
          // Check compiledIC holders associated with this nmethod
          ResourceMark rm;
          CompiledIC *ic = CompiledIC_at(&amp;iter);
          if (ic-&gt;is_icholder_call()) {
            CompiledICHolder* cichk = ic-&gt;cached_icholder();
<span class="udiff-line-modified-removed">-           f(cichk-&gt;holder_metadata());</span>
<span class="udiff-line-modified-removed">-           f(cichk-&gt;holder_klass());</span>
<span class="udiff-line-modified-added">+           f-&gt;do_metadata(cichk-&gt;holder_metadata());</span>
<span class="udiff-line-modified-added">+           f-&gt;do_metadata(cichk-&gt;holder_klass());</span>
          } else {
            Metadata* ic_oop = ic-&gt;cached_metadata();
            if (ic_oop != NULL) {
<span class="udiff-line-modified-removed">-             f(ic_oop);</span>
<span class="udiff-line-modified-added">+             f-&gt;do_metadata(ic_oop);</span>
            }
          }
        }
      }
    }
  
    // Visit the metadata section
    for (Metadata** p = metadata_begin(); p &lt; metadata_end(); p++) {
      if (*p == Universe::non_oop_word() || *p == NULL)  continue;  // skip non-oops
      Metadata* md = *p;
<span class="udiff-line-modified-removed">-     f(md);</span>
<span class="udiff-line-modified-added">+     f-&gt;do_metadata(md);</span>
    }
  
    // Visit metadata not embedded in the other places.
<span class="udiff-line-modified-removed">-   if (_method != NULL) f(_method);</span>
<span class="udiff-line-modified-added">+   if (_method != NULL) f-&gt;do_metadata(_method);</span>
  }
  
  // The _is_unloading_state encodes a tuple comprising the unloading cycle
  // and the result of IsUnloadingBehaviour::is_unloading() fpr that cycle.
  // This is the bit layout of the _is_unloading_state byte: 00000CCU
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1654,30 +1796,18 @@</span>
           &quot;should not call follow on zombie or unloaded nmethod&quot;);
  
    if (is_unloading()) {
      make_unloaded();
    } else {
<span class="udiff-line-removed">- #if INCLUDE_JVMCI</span>
<span class="udiff-line-removed">-     if (_jvmci_installed_code != NULL) {</span>
<span class="udiff-line-removed">-       if (JNIHandles::is_global_weak_cleared(_jvmci_installed_code)) {</span>
<span class="udiff-line-removed">-         if (_jvmci_installed_code_triggers_invalidation) {</span>
<span class="udiff-line-removed">-           make_not_entrant();</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         clear_jvmci_installed_code();</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
      guarantee(unload_nmethod_caches(unloading_occurred),
                &quot;Should not need transition stubs&quot;);
    }
  }
  
<span class="udiff-line-modified-removed">- void nmethod::oops_do(OopClosure* f, bool allow_zombie) {</span>
<span class="udiff-line-modified-added">+ void nmethod::oops_do(OopClosure* f, bool allow_dead) {</span>
    // make sure the oops ready to receive visitors
<span class="udiff-line-modified-removed">-   assert(allow_zombie || !is_zombie(), &quot;should not call follow on zombie nmethod&quot;);</span>
<span class="udiff-line-removed">-   assert(!is_unloaded(), &quot;should not call follow on unloaded nmethod&quot;);</span>
<span class="udiff-line-modified-added">+   assert(allow_dead || is_alive(), &quot;should not call follow on dead nmethod&quot;);</span>
  
    // Prevent extra code cache walk for platforms that don&#39;t have immediate oops.
    if (relocInfo::mustIterateImmediateOopsInCode()) {
      RelocIterator iter(this, oops_reloc_begin());
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1702,74 +1832,197 @@</span>
      if (*p == Universe::non_oop_word())  continue;  // skip non-oops
      f-&gt;do_oop(p);
    }
  }
  
<span class="udiff-line-removed">- #define NMETHOD_SENTINEL ((nmethod*)badAddress)</span>
<span class="udiff-line-removed">- </span>
  nmethod* volatile nmethod::_oops_do_mark_nmethods;
  
<span class="udiff-line-modified-removed">- // An nmethod is &quot;marked&quot; if its _mark_link is set non-null.</span>
<span class="udiff-line-modified-removed">- // Even if it is the end of the linked list, it will have a non-null link value,</span>
<span class="udiff-line-modified-removed">- // as long as it is on the list.</span>
<span class="udiff-line-modified-removed">- // This code must be MP safe, because it is used from parallel GC passes.</span>
<span class="udiff-line-modified-removed">- bool nmethod::test_set_oops_do_mark() {</span>
<span class="udiff-line-modified-removed">-   assert(nmethod::oops_do_marking_is_active(), &quot;oops_do_marking_prologue must be called&quot;);</span>
<span class="udiff-line-modified-removed">-   if (_oops_do_mark_link == NULL) {</span>
<span class="udiff-line-modified-removed">-     // Claim this nmethod for this thread to mark.</span>
<span class="udiff-line-modified-removed">-     if (Atomic::replace_if_null(NMETHOD_SENTINEL, &amp;_oops_do_mark_link)) {</span>
<span class="udiff-line-modified-removed">-       // Atomically append this nmethod (now claimed) to the head of the list:</span>
<span class="udiff-line-modified-removed">-       nmethod* observed_mark_nmethods = _oops_do_mark_nmethods;</span>
<span class="udiff-line-modified-removed">-       for (;;) {</span>
<span class="udiff-line-modified-removed">-         nmethod* required_mark_nmethods = observed_mark_nmethods;</span>
<span class="udiff-line-modified-removed">-         _oops_do_mark_link = required_mark_nmethods;</span>
<span class="udiff-line-modified-removed">-         observed_mark_nmethods =</span>
<span class="udiff-line-modified-removed">-           Atomic::cmpxchg(this, &amp;_oops_do_mark_nmethods, required_mark_nmethods);</span>
<span class="udiff-line-modified-removed">-         if (observed_mark_nmethods == required_mark_nmethods)</span>
<span class="udiff-line-modified-removed">-           break;</span>
<span class="udiff-line-modified-removed">-       }</span>
<span class="udiff-line-modified-removed">-       // Mark was clear when we first saw this guy.</span>
<span class="udiff-line-modified-removed">-       LogTarget(Trace, gc, nmethod) lt;</span>
<span class="udiff-line-modified-removed">-       if (lt.is_enabled()) {</span>
<span class="udiff-line-modified-removed">-         LogStream ls(lt);</span>
<span class="udiff-line-modified-removed">-         CompileTask::print(&amp;ls, this, &quot;oops_do, mark&quot;, /*short_form:*/ true);</span>
<span class="udiff-line-modified-removed">-       }</span>
<span class="udiff-line-modified-removed">-       return false;</span>
<span class="udiff-line-modified-added">+ void nmethod::oops_do_log_change(const char* state) {</span>
<span class="udiff-line-modified-added">+   LogTarget(Trace, gc, nmethod) lt;</span>
<span class="udiff-line-modified-added">+   if (lt.is_enabled()) {</span>
<span class="udiff-line-modified-added">+     LogStream ls(lt);</span>
<span class="udiff-line-modified-added">+     CompileTask::print(&amp;ls, this, state, true /* short_form */);</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ bool nmethod::oops_do_try_claim() {</span>
<span class="udiff-line-modified-added">+   if (oops_do_try_claim_weak_request()) {</span>
<span class="udiff-line-modified-added">+     nmethod* result = oops_do_try_add_to_list_as_weak_done();</span>
<span class="udiff-line-modified-added">+     assert(result == NULL, &quot;adding to global list as weak done must always succeed.&quot;);</span>
<span class="udiff-line-modified-added">+     return true;</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   return false;</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ bool nmethod::oops_do_try_claim_weak_request() {</span>
<span class="udiff-line-modified-added">+   assert(SafepointSynchronize::is_at_safepoint(), &quot;only at safepoint&quot;);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   if ((_oops_do_mark_link == NULL) &amp;&amp;</span>
<span class="udiff-line-modified-added">+       (Atomic::replace_if_null(&amp;_oops_do_mark_link, mark_link(this, claim_weak_request_tag)))) {</span>
<span class="udiff-line-modified-added">+     oops_do_log_change(&quot;oops_do, mark weak request&quot;);</span>
<span class="udiff-line-modified-added">+     return true;</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   return false;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void nmethod::oops_do_set_strong_done(nmethod* old_head) {</span>
<span class="udiff-line-added">+   _oops_do_mark_link = mark_link(old_head, claim_strong_done_tag);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ nmethod::oops_do_mark_link* nmethod::oops_do_try_claim_strong_done() {</span>
<span class="udiff-line-added">+   assert(SafepointSynchronize::is_at_safepoint(), &quot;only at safepoint&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   oops_do_mark_link* old_next = Atomic::cmpxchg(&amp;_oops_do_mark_link, mark_link(NULL, claim_weak_request_tag), mark_link(this, claim_strong_done_tag));</span>
<span class="udiff-line-added">+   if (old_next == NULL) {</span>
<span class="udiff-line-added">+     oops_do_log_change(&quot;oops_do, mark strong done&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return old_next;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ nmethod::oops_do_mark_link* nmethod::oops_do_try_add_strong_request(nmethod::oops_do_mark_link* next) {</span>
<span class="udiff-line-added">+   assert(SafepointSynchronize::is_at_safepoint(), &quot;only at safepoint&quot;);</span>
<span class="udiff-line-added">+   assert(next == mark_link(this, claim_weak_request_tag), &quot;Should be claimed as weak&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   oops_do_mark_link* old_next = Atomic::cmpxchg(&amp;_oops_do_mark_link, next, mark_link(this, claim_strong_request_tag));</span>
<span class="udiff-line-added">+   if (old_next == next) {</span>
<span class="udiff-line-added">+     oops_do_log_change(&quot;oops_do, mark strong request&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return old_next;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool nmethod::oops_do_try_claim_weak_done_as_strong_done(nmethod::oops_do_mark_link* next) {</span>
<span class="udiff-line-added">+   assert(SafepointSynchronize::is_at_safepoint(), &quot;only at safepoint&quot;);</span>
<span class="udiff-line-added">+   assert(extract_state(next) == claim_weak_done_tag, &quot;Should be claimed as weak done&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   oops_do_mark_link* old_next = Atomic::cmpxchg(&amp;_oops_do_mark_link, next, mark_link(extract_nmethod(next), claim_strong_done_tag));</span>
<span class="udiff-line-added">+   if (old_next == next) {</span>
<span class="udiff-line-added">+     oops_do_log_change(&quot;oops_do, mark weak done -&gt; mark strong done&quot;);</span>
<span class="udiff-line-added">+     return true;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return false;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ nmethod* nmethod::oops_do_try_add_to_list_as_weak_done() {</span>
<span class="udiff-line-added">+   assert(SafepointSynchronize::is_at_safepoint(), &quot;only at safepoint&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   assert(extract_state(_oops_do_mark_link) == claim_weak_request_tag ||</span>
<span class="udiff-line-added">+          extract_state(_oops_do_mark_link) == claim_strong_request_tag,</span>
<span class="udiff-line-added">+          &quot;must be but is nmethod &quot; PTR_FORMAT &quot; %u&quot;, p2i(extract_nmethod(_oops_do_mark_link)), extract_state(_oops_do_mark_link));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   nmethod* old_head = Atomic::xchg(&amp;_oops_do_mark_nmethods, this);</span>
<span class="udiff-line-added">+   // Self-loop if needed.</span>
<span class="udiff-line-added">+   if (old_head == NULL) {</span>
<span class="udiff-line-added">+     old_head = this;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   // Try to install end of list and weak done tag.</span>
<span class="udiff-line-added">+   if (Atomic::cmpxchg(&amp;_oops_do_mark_link, mark_link(this, claim_weak_request_tag), mark_link(old_head, claim_weak_done_tag)) == mark_link(this, claim_weak_request_tag)) {</span>
<span class="udiff-line-added">+     oops_do_log_change(&quot;oops_do, mark weak done&quot;);</span>
<span class="udiff-line-added">+     return NULL;</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     return old_head;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void nmethod::oops_do_add_to_list_as_strong_done() {</span>
<span class="udiff-line-added">+   assert(SafepointSynchronize::is_at_safepoint(), &quot;only at safepoint&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   nmethod* old_head = Atomic::xchg(&amp;_oops_do_mark_nmethods, this);</span>
<span class="udiff-line-added">+   // Self-loop if needed.</span>
<span class="udiff-line-added">+   if (old_head == NULL) {</span>
<span class="udiff-line-added">+     old_head = this;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   assert(_oops_do_mark_link == mark_link(this, claim_strong_done_tag), &quot;must be but is nmethod &quot; PTR_FORMAT &quot; state %u&quot;,</span>
<span class="udiff-line-added">+          p2i(extract_nmethod(_oops_do_mark_link)), extract_state(_oops_do_mark_link));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   oops_do_set_strong_done(old_head);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void nmethod::oops_do_process_weak(OopsDoProcessor* p) {</span>
<span class="udiff-line-added">+   if (!oops_do_try_claim_weak_request()) {</span>
<span class="udiff-line-added">+     // Failed to claim for weak processing.</span>
<span class="udiff-line-added">+     oops_do_log_change(&quot;oops_do, mark weak request fail&quot;);</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   p-&gt;do_regular_processing(this);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   nmethod* old_head = oops_do_try_add_to_list_as_weak_done();</span>
<span class="udiff-line-added">+   if (old_head == NULL) {</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   oops_do_log_change(&quot;oops_do, mark weak done fail&quot;);</span>
<span class="udiff-line-added">+   // Adding to global list failed, another thread added a strong request.</span>
<span class="udiff-line-added">+   assert(extract_state(_oops_do_mark_link) == claim_strong_request_tag,</span>
<span class="udiff-line-added">+          &quot;must be but is %u&quot;, extract_state(_oops_do_mark_link));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   oops_do_log_change(&quot;oops_do, mark weak request -&gt; mark strong done&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   oops_do_set_strong_done(old_head);</span>
<span class="udiff-line-added">+   // Do missing strong processing.</span>
<span class="udiff-line-added">+   p-&gt;do_remaining_strong_processing(this);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void nmethod::oops_do_process_strong(OopsDoProcessor* p) {</span>
<span class="udiff-line-added">+   oops_do_mark_link* next_raw = oops_do_try_claim_strong_done();</span>
<span class="udiff-line-added">+   if (next_raw == NULL) {</span>
<span class="udiff-line-added">+     p-&gt;do_regular_processing(this);</span>
<span class="udiff-line-added">+     oops_do_add_to_list_as_strong_done();</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   // Claim failed. Figure out why and handle it.</span>
<span class="udiff-line-added">+   if (oops_do_has_weak_request(next_raw)) {</span>
<span class="udiff-line-added">+     oops_do_mark_link* old = next_raw;</span>
<span class="udiff-line-added">+     // Claim failed because being weak processed (state == &quot;weak request&quot;).</span>
<span class="udiff-line-added">+     // Try to request deferred strong processing.</span>
<span class="udiff-line-added">+     next_raw = oops_do_try_add_strong_request(old);</span>
<span class="udiff-line-added">+     if (next_raw == old) {</span>
<span class="udiff-line-added">+       // Successfully requested deferred strong processing.</span>
<span class="udiff-line-added">+       return;</span>
      }
<span class="udiff-line-added">+     // Failed because of a concurrent transition. No longer in &quot;weak request&quot; state.</span>
    }
<span class="udiff-line-modified-removed">-   // On fall through, another racing thread marked this nmethod before we did.</span>
<span class="udiff-line-modified-removed">-   return true;</span>
<span class="udiff-line-modified-added">+   if (oops_do_has_any_strong_state(next_raw)) {</span>
<span class="udiff-line-modified-added">+     // Already claimed for strong processing or requested for such.</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (oops_do_try_claim_weak_done_as_strong_done(next_raw)) {</span>
<span class="udiff-line-added">+     // Successfully claimed &quot;weak done&quot; as &quot;strong done&quot;. Do the missing marking.</span>
<span class="udiff-line-added">+     p-&gt;do_remaining_strong_processing(this);</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   // Claim failed, some other thread got it.</span>
  }
  
  void nmethod::oops_do_marking_prologue() {
<span class="udiff-line-added">+   assert_at_safepoint();</span>
<span class="udiff-line-added">+ </span>
    log_trace(gc, nmethod)(&quot;oops_do_marking_prologue&quot;);
<span class="udiff-line-modified-removed">-   assert(_oops_do_mark_nmethods == NULL, &quot;must not call oops_do_marking_prologue twice in a row&quot;);</span>
<span class="udiff-line-removed">-   // We use cmpxchg instead of regular assignment here because the user</span>
<span class="udiff-line-removed">-   // may fork a bunch of threads, and we need them all to see the same state.</span>
<span class="udiff-line-removed">-   nmethod* observed = Atomic::cmpxchg(NMETHOD_SENTINEL, &amp;_oops_do_mark_nmethods, (nmethod*)NULL);</span>
<span class="udiff-line-removed">-   guarantee(observed == NULL, &quot;no races in this sequential code&quot;);</span>
<span class="udiff-line-modified-added">+   assert(_oops_do_mark_nmethods == NULL, &quot;must be empty&quot;);</span>
  }
  
  void nmethod::oops_do_marking_epilogue() {
<span class="udiff-line-modified-removed">-   assert(_oops_do_mark_nmethods != NULL, &quot;must not call oops_do_marking_epilogue twice in a row&quot;);</span>
<span class="udiff-line-modified-removed">-   nmethod* cur = _oops_do_mark_nmethods;</span>
<span class="udiff-line-modified-removed">-   while (cur != NMETHOD_SENTINEL) {</span>
<span class="udiff-line-modified-removed">-     assert(cur != NULL, &quot;not NULL-terminated&quot;);</span>
<span class="udiff-line-modified-removed">-     nmethod* next = cur-&gt;_oops_do_mark_link;</span>
<span class="udiff-line-modified-added">+   assert_at_safepoint();</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   nmethod* next = _oops_do_mark_nmethods;</span>
<span class="udiff-line-modified-added">+   _oops_do_mark_nmethods = NULL;</span>
<span class="udiff-line-modified-added">+   if (next == NULL) {</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   nmethod* cur;</span>
<span class="udiff-line-added">+   do {</span>
<span class="udiff-line-added">+     cur = next;</span>
<span class="udiff-line-added">+     next = extract_nmethod(cur-&gt;_oops_do_mark_link);</span>
      cur-&gt;_oops_do_mark_link = NULL;
      DEBUG_ONLY(cur-&gt;verify_oop_relocations());
  
      LogTarget(Trace, gc, nmethod) lt;
      if (lt.is_enabled()) {
        LogStream ls(lt);
        CompileTask::print(&amp;ls, cur, &quot;oops_do, unmark&quot;, /*short_form:*/ true);
      }
<span class="udiff-line-modified-removed">-     cur = next;</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-removed">-   nmethod* required = _oops_do_mark_nmethods;</span>
<span class="udiff-line-removed">-   nmethod* observed = Atomic::cmpxchg((nmethod*)NULL, &amp;_oops_do_mark_nmethods, required);</span>
<span class="udiff-line-removed">-   guarantee(observed == required, &quot;no races in this sequential code&quot;);</span>
<span class="udiff-line-modified-added">+     // End if self-loop has been detected.</span>
<span class="udiff-line-modified-added">+   } while (cur != next);</span>
    log_trace(gc, nmethod)(&quot;oops_do_marking_epilogue&quot;);
  }
  
  inline bool includes(void* p, void* from, void* to) {
    return from &lt;= p &amp;&amp; p &lt; to;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1984,36 +2237,10 @@</span>
      }
    }
    return found_check;
  }
  
<span class="udiff-line-removed">- bool nmethod::is_evol_dependent() {</span>
<span class="udiff-line-removed">-   for (Dependencies::DepStream deps(this); deps.next(); ) {</span>
<span class="udiff-line-removed">-     if (deps.type() == Dependencies::evol_method) {</span>
<span class="udiff-line-removed">-       Method* method = deps.method_argument(0);</span>
<span class="udiff-line-removed">-       if (method-&gt;is_old()) {</span>
<span class="udiff-line-removed">-         if (log_is_enabled(Debug, redefine, class, nmethod)) {</span>
<span class="udiff-line-removed">-           ResourceMark rm;</span>
<span class="udiff-line-removed">-           log_debug(redefine, class, nmethod)</span>
<span class="udiff-line-removed">-             (&quot;Found evol dependency of nmethod %s.%s(%s) compile_id=%d on method %s.%s(%s)&quot;,</span>
<span class="udiff-line-removed">-              _method-&gt;method_holder()-&gt;external_name(),</span>
<span class="udiff-line-removed">-              _method-&gt;name()-&gt;as_C_string(),</span>
<span class="udiff-line-removed">-              _method-&gt;signature()-&gt;as_C_string(),</span>
<span class="udiff-line-removed">-              compile_id(),</span>
<span class="udiff-line-removed">-              method-&gt;method_holder()-&gt;external_name(),</span>
<span class="udiff-line-removed">-              method-&gt;name()-&gt;as_C_string(),</span>
<span class="udiff-line-removed">-              method-&gt;signature()-&gt;as_C_string());</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         if (TraceDependencies || LogCompilation)</span>
<span class="udiff-line-removed">-           deps.log_dependency(method-&gt;method_holder());</span>
<span class="udiff-line-removed">-         return true;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return false;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  // Called from mark_for_deoptimization, when dependee is invalidated.
  bool nmethod::is_dependent_on_method(Method* dependee) {
    for (Dependencies::DepStream deps(this); deps.next(); ) {
      if (deps.type() != Dependencies::evol_method)
        continue;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2032,40 +2259,10 @@</span>
    }
    return true;
  }
  
  
<span class="udiff-line-removed">- address nmethod::continuation_for_implicit_exception(address pc) {</span>
<span class="udiff-line-removed">-   // Exception happened outside inline-cache check code =&gt; we are inside</span>
<span class="udiff-line-removed">-   // an active nmethod =&gt; use cpc to determine a return address</span>
<span class="udiff-line-removed">-   int exception_offset = pc - code_begin();</span>
<span class="udiff-line-removed">-   int cont_offset = ImplicitExceptionTable(this).at( exception_offset );</span>
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-   if (cont_offset == 0) {</span>
<span class="udiff-line-removed">-     Thread* thread = Thread::current();</span>
<span class="udiff-line-removed">-     ResetNoHandleMark rnm; // Might be called from LEAF/QUICK ENTRY</span>
<span class="udiff-line-removed">-     HandleMark hm(thread);</span>
<span class="udiff-line-removed">-     ResourceMark rm(thread);</span>
<span class="udiff-line-removed">-     CodeBlob* cb = CodeCache::find_blob(pc);</span>
<span class="udiff-line-removed">-     assert(cb != NULL &amp;&amp; cb == this, &quot;&quot;);</span>
<span class="udiff-line-removed">-     ttyLocker ttyl;</span>
<span class="udiff-line-removed">-     tty-&gt;print_cr(&quot;implicit exception happened at &quot; INTPTR_FORMAT, p2i(pc));</span>
<span class="udiff-line-removed">-     print();</span>
<span class="udiff-line-removed">-     method()-&gt;print_codes();</span>
<span class="udiff-line-removed">-     print_code();</span>
<span class="udiff-line-removed">-     print_pcs();</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-   if (cont_offset == 0) {</span>
<span class="udiff-line-removed">-     // Let the normal error handling report the exception</span>
<span class="udiff-line-removed">-     return NULL;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return code_begin() + cont_offset;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
  void nmethod_init() {
    // make sure you didn&#39;t forget to adjust the filler fields
    assert(sizeof(nmethod) % oopSize == 0, &quot;nmethod size must be multiple of a word&quot;);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2086,11 +2283,11 @@</span>
  void nmethodLocker::lock_nmethod(CompiledMethod* cm, bool zombie_ok) {
    if (cm == NULL)  return;
    if (cm-&gt;is_aot()) return;  // FIXME: Revisit once _lock_count is added to aot_method
    nmethod* nm = cm-&gt;as_nmethod();
    Atomic::inc(&amp;nm-&gt;_lock_count);
<span class="udiff-line-modified-removed">-   assert(zombie_ok || !nm-&gt;is_zombie(), &quot;cannot lock a zombie method&quot;);</span>
<span class="udiff-line-modified-added">+   assert(zombie_ok || !nm-&gt;is_zombie(), &quot;cannot lock a zombie method: %p&quot;, nm);</span>
  }
  
  void nmethodLocker::unlock_nmethod(CompiledMethod* cm) {
    if (cm == NULL)  return;
    if (cm-&gt;is_aot()) return;  // FIXME: Revisit once _lock_count is added to aot_method
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2109,20 +2306,33 @@</span>
  public:
    VerifyOopsClosure(nmethod* nm) : _nm(nm), _ok(true) { }
    bool ok() { return _ok; }
    virtual void do_oop(oop* p) {
      if (oopDesc::is_oop_or_null(*p)) return;
<span class="udiff-line-added">+     // Print diagnostic information before calling print_nmethod().</span>
<span class="udiff-line-added">+     // Assertions therein might prevent call from returning.</span>
<span class="udiff-line-added">+     tty-&gt;print_cr(&quot;*** non-oop &quot; PTR_FORMAT &quot; found at &quot; PTR_FORMAT &quot; (offset %d)&quot;,</span>
<span class="udiff-line-added">+                   p2i(*p), p2i(p), (int)((intptr_t)p - (intptr_t)_nm));</span>
      if (_ok) {
        _nm-&gt;print_nmethod(true);
        _ok = false;
      }
<span class="udiff-line-removed">-     tty-&gt;print_cr(&quot;*** non-oop &quot; PTR_FORMAT &quot; found at &quot; PTR_FORMAT &quot; (offset %d)&quot;,</span>
<span class="udiff-line-removed">-                   p2i(*p), p2i(p), (int)((intptr_t)p - (intptr_t)_nm));</span>
    }
    virtual void do_oop(narrowOop* p) { ShouldNotReachHere(); }
  };
  
<span class="udiff-line-added">+ class VerifyMetadataClosure: public MetadataClosure {</span>
<span class="udiff-line-added">+  public:</span>
<span class="udiff-line-added">+   void do_metadata(Metadata* md) {</span>
<span class="udiff-line-added">+     if (md-&gt;is_method()) {</span>
<span class="udiff-line-added">+       Method* method = (Method*)md;</span>
<span class="udiff-line-added">+       assert(!method-&gt;is_old(), &quot;Should not be installing old methods&quot;);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
  void nmethod::verify() {
  
    // Hmm. OSR methods can be deopted but not marked as zombie or not_entrant
    // seems odd.
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2152,25 +2362,54 @@</span>
      if (! p-&gt;verify(this)) {
        tty-&gt;print_cr(&quot;\t\tin nmethod at &quot; INTPTR_FORMAT &quot; (pcs)&quot;, p2i(this));
      }
    }
  
<span class="udiff-line-added">+ #ifdef ASSERT</span>
<span class="udiff-line-added">+ #if INCLUDE_JVMCI</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     // Verify that implicit exceptions that deoptimize have a PcDesc and OopMap</span>
<span class="udiff-line-added">+     ImmutableOopMapSet* oms = oop_maps();</span>
<span class="udiff-line-added">+     ImplicitExceptionTable implicit_table(this);</span>
<span class="udiff-line-added">+     for (uint i = 0; i &lt; implicit_table.len(); i++) {</span>
<span class="udiff-line-added">+       int exec_offset = (int) implicit_table.get_exec_offset(i);</span>
<span class="udiff-line-added">+       if (implicit_table.get_exec_offset(i) == implicit_table.get_cont_offset(i)) {</span>
<span class="udiff-line-added">+         assert(pc_desc_at(code_begin() + exec_offset) != NULL, &quot;missing PcDesc&quot;);</span>
<span class="udiff-line-added">+         bool found = false;</span>
<span class="udiff-line-added">+         for (int i = 0, imax = oms-&gt;count(); i &lt; imax; i++) {</span>
<span class="udiff-line-added">+           if (oms-&gt;pair_at(i)-&gt;pc_offset() == exec_offset) {</span>
<span class="udiff-line-added">+             found = true;</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         assert(found, &quot;missing oopmap&quot;);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
    VerifyOopsClosure voc(this);
    oops_do(&amp;voc);
    assert(voc.ok(), &quot;embedded oops must be OK&quot;);
    Universe::heap()-&gt;verify_nmethod(this);
  
<span class="udiff-line-added">+   assert(_oops_do_mark_link == NULL, &quot;_oops_do_mark_link for %s should be NULL but is &quot; PTR_FORMAT,</span>
<span class="udiff-line-added">+          nm-&gt;method()-&gt;external_name(), p2i(_oops_do_mark_link));</span>
    verify_scopes();
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   CompiledICLocker nm_verify(this);</span>
<span class="udiff-line-added">+   VerifyMetadataClosure vmc;</span>
<span class="udiff-line-added">+   metadata_do(&amp;vmc);</span>
  }
  
  
  void nmethod::verify_interrupt_point(address call_site) {
    // Verify IC only when nmethod installation is finished.
    if (!is_not_installed()) {
      if (CompiledICLocker::is_safe(this)) {
        CompiledIC_at(this, call_site);
<span class="udiff-line-removed">-       CHECK_UNHANDLED_OOPS_ONLY(Thread::current()-&gt;clear_unhandled_oops());</span>
      } else {
        CompiledICLocker ml_verify(this);
        CompiledIC_at(this, call_site);
      }
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2223,101 +2462,108 @@</span>
  
  // -----------------------------------------------------------------------------
  // Printing operations
  
  void nmethod::print() const {
<span class="udiff-line-removed">-   ResourceMark rm;</span>
    ttyLocker ttyl;   // keep the following output all in one block
<span class="udiff-line-added">+   print(tty);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void nmethod::print(outputStream* st) const {</span>
<span class="udiff-line-added">+   ResourceMark rm;</span>
  
<span class="udiff-line-modified-removed">-   tty-&gt;print(&quot;Compiled method &quot;);</span>
<span class="udiff-line-modified-added">+   st-&gt;print(&quot;Compiled method &quot;);</span>
  
    if (is_compiled_by_c1()) {
<span class="udiff-line-modified-removed">-     tty-&gt;print(&quot;(c1) &quot;);</span>
<span class="udiff-line-modified-added">+     st-&gt;print(&quot;(c1) &quot;);</span>
    } else if (is_compiled_by_c2()) {
<span class="udiff-line-modified-removed">-     tty-&gt;print(&quot;(c2) &quot;);</span>
<span class="udiff-line-modified-added">+     st-&gt;print(&quot;(c2) &quot;);</span>
    } else if (is_compiled_by_jvmci()) {
<span class="udiff-line-modified-removed">-     tty-&gt;print(&quot;(JVMCI) &quot;);</span>
<span class="udiff-line-modified-added">+     st-&gt;print(&quot;(JVMCI) &quot;);</span>
    } else {
<span class="udiff-line-modified-removed">-     tty-&gt;print(&quot;(nm) &quot;);</span>
<span class="udiff-line-modified-added">+     st-&gt;print(&quot;(n/a) &quot;);</span>
    }
  
    print_on(tty, NULL);
  
    if (WizardMode) {
<span class="udiff-line-modified-removed">-     tty-&gt;print(&quot;((nmethod*) &quot; INTPTR_FORMAT &quot;) &quot;, p2i(this));</span>
<span class="udiff-line-modified-removed">-     tty-&gt;print(&quot; for method &quot; INTPTR_FORMAT , p2i(method()));</span>
<span class="udiff-line-modified-removed">-     tty-&gt;print(&quot; { &quot;);</span>
<span class="udiff-line-modified-removed">-     tty-&gt;print_cr(&quot;%s &quot;, state());</span>
<span class="udiff-line-modified-removed">-     tty-&gt;print_cr(&quot;}:&quot;);</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">-   if (size              () &gt; 0) tty-&gt;print_cr(&quot; total in heap  [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="udiff-line-modified-removed">-                                               p2i(this),</span>
<span class="udiff-line-modified-removed">-                                               p2i(this) + size(),</span>
<span class="udiff-line-modified-removed">-                                               size());</span>
<span class="udiff-line-modified-removed">-   if (relocation_size   () &gt; 0) tty-&gt;print_cr(&quot; relocation     [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="udiff-line-modified-removed">-                                               p2i(relocation_begin()),</span>
<span class="udiff-line-modified-removed">-                                               p2i(relocation_end()),</span>
<span class="udiff-line-modified-removed">-                                               relocation_size());</span>
<span class="udiff-line-modified-removed">-   if (consts_size       () &gt; 0) tty-&gt;print_cr(&quot; constants      [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="udiff-line-modified-removed">-                                               p2i(consts_begin()),</span>
<span class="udiff-line-modified-removed">-                                               p2i(consts_end()),</span>
<span class="udiff-line-modified-removed">-                                               consts_size());</span>
<span class="udiff-line-modified-removed">-   if (insts_size        () &gt; 0) tty-&gt;print_cr(&quot; main code      [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="udiff-line-modified-removed">-                                               p2i(insts_begin()),</span>
<span class="udiff-line-modified-removed">-                                               p2i(insts_end()),</span>
<span class="udiff-line-modified-removed">-                                               insts_size());</span>
<span class="udiff-line-modified-removed">-   if (stub_size         () &gt; 0) tty-&gt;print_cr(&quot; stub code      [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="udiff-line-modified-removed">-                                               p2i(stub_begin()),</span>
<span class="udiff-line-modified-removed">-                                               p2i(stub_end()),</span>
<span class="udiff-line-modified-removed">-                                               stub_size());</span>
<span class="udiff-line-modified-removed">-   if (oops_size         () &gt; 0) tty-&gt;print_cr(&quot; oops           [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="udiff-line-modified-removed">-                                               p2i(oops_begin()),</span>
<span class="udiff-line-modified-removed">-                                               p2i(oops_end()),</span>
<span class="udiff-line-modified-removed">-                                               oops_size());</span>
<span class="udiff-line-modified-removed">-   if (metadata_size      () &gt; 0) tty-&gt;print_cr(&quot; metadata       [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="udiff-line-modified-removed">-                                               p2i(metadata_begin()),</span>
<span class="udiff-line-modified-removed">-                                               p2i(metadata_end()),</span>
<span class="udiff-line-modified-removed">-                                               metadata_size());</span>
<span class="udiff-line-modified-removed">-   if (scopes_data_size  () &gt; 0) tty-&gt;print_cr(&quot; scopes data    [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="udiff-line-modified-removed">-                                               p2i(scopes_data_begin()),</span>
<span class="udiff-line-modified-removed">-                                               p2i(scopes_data_end()),</span>
<span class="udiff-line-modified-removed">-                                               scopes_data_size());</span>
<span class="udiff-line-modified-removed">-   if (scopes_pcs_size   () &gt; 0) tty-&gt;print_cr(&quot; scopes pcs     [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="udiff-line-modified-removed">-                                               p2i(scopes_pcs_begin()),</span>
<span class="udiff-line-modified-removed">-                                               p2i(scopes_pcs_end()),</span>
<span class="udiff-line-modified-removed">-                                               scopes_pcs_size());</span>
<span class="udiff-line-modified-removed">-   if (dependencies_size () &gt; 0) tty-&gt;print_cr(&quot; dependencies   [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="udiff-line-modified-removed">-                                               p2i(dependencies_begin()),</span>
<span class="udiff-line-modified-removed">-                                               p2i(dependencies_end()),</span>
<span class="udiff-line-modified-removed">-                                               dependencies_size());</span>
<span class="udiff-line-modified-removed">-   if (handler_table_size() &gt; 0) tty-&gt;print_cr(&quot; handler table  [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="udiff-line-modified-removed">-                                               p2i(handler_table_begin()),</span>
<span class="udiff-line-modified-removed">-                                               p2i(handler_table_end()),</span>
<span class="udiff-line-modified-removed">-                                               handler_table_size());</span>
<span class="udiff-line-modified-removed">-   if (nul_chk_table_size() &gt; 0) tty-&gt;print_cr(&quot; nul chk table  [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="udiff-line-modified-removed">-                                               p2i(nul_chk_table_begin()),</span>
<span class="udiff-line-modified-removed">-                                               p2i(nul_chk_table_end()),</span>
<span class="udiff-line-modified-removed">-                                               nul_chk_table_size());</span>
<span class="udiff-line-modified-added">+     st-&gt;print(&quot;((nmethod*) &quot; INTPTR_FORMAT &quot;) &quot;, p2i(this));</span>
<span class="udiff-line-modified-added">+     st-&gt;print(&quot; for method &quot; INTPTR_FORMAT , p2i(method()));</span>
<span class="udiff-line-modified-added">+     st-&gt;print(&quot; { &quot;);</span>
<span class="udiff-line-modified-added">+     st-&gt;print_cr(&quot;%s &quot;, state());</span>
<span class="udiff-line-modified-added">+     st-&gt;print_cr(&quot;}:&quot;);</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   if (size              () &gt; 0) st-&gt;print_cr(&quot; total in heap  [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="udiff-line-modified-added">+                                              p2i(this),</span>
<span class="udiff-line-modified-added">+                                              p2i(this) + size(),</span>
<span class="udiff-line-modified-added">+                                              size());</span>
<span class="udiff-line-modified-added">+   if (relocation_size   () &gt; 0) st-&gt;print_cr(&quot; relocation     [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="udiff-line-modified-added">+                                              p2i(relocation_begin()),</span>
<span class="udiff-line-modified-added">+                                              p2i(relocation_end()),</span>
<span class="udiff-line-modified-added">+                                              relocation_size());</span>
<span class="udiff-line-modified-added">+   if (consts_size       () &gt; 0) st-&gt;print_cr(&quot; constants      [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="udiff-line-modified-added">+                                              p2i(consts_begin()),</span>
<span class="udiff-line-modified-added">+                                              p2i(consts_end()),</span>
<span class="udiff-line-modified-added">+                                              consts_size());</span>
<span class="udiff-line-modified-added">+   if (insts_size        () &gt; 0) st-&gt;print_cr(&quot; main code      [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="udiff-line-modified-added">+                                              p2i(insts_begin()),</span>
<span class="udiff-line-modified-added">+                                              p2i(insts_end()),</span>
<span class="udiff-line-modified-added">+                                              insts_size());</span>
<span class="udiff-line-modified-added">+   if (stub_size         () &gt; 0) st-&gt;print_cr(&quot; stub code      [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="udiff-line-modified-added">+                                              p2i(stub_begin()),</span>
<span class="udiff-line-modified-added">+                                              p2i(stub_end()),</span>
<span class="udiff-line-modified-added">+                                              stub_size());</span>
<span class="udiff-line-modified-added">+   if (oops_size         () &gt; 0) st-&gt;print_cr(&quot; oops           [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="udiff-line-modified-added">+                                              p2i(oops_begin()),</span>
<span class="udiff-line-modified-added">+                                              p2i(oops_end()),</span>
<span class="udiff-line-modified-added">+                                              oops_size());</span>
<span class="udiff-line-modified-added">+   if (metadata_size     () &gt; 0) st-&gt;print_cr(&quot; metadata       [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="udiff-line-modified-added">+                                              p2i(metadata_begin()),</span>
<span class="udiff-line-modified-added">+                                              p2i(metadata_end()),</span>
<span class="udiff-line-modified-added">+                                              metadata_size());</span>
<span class="udiff-line-modified-added">+   if (scopes_data_size  () &gt; 0) st-&gt;print_cr(&quot; scopes data    [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="udiff-line-modified-added">+                                              p2i(scopes_data_begin()),</span>
<span class="udiff-line-modified-added">+                                              p2i(scopes_data_end()),</span>
<span class="udiff-line-modified-added">+                                              scopes_data_size());</span>
<span class="udiff-line-modified-added">+   if (scopes_pcs_size   () &gt; 0) st-&gt;print_cr(&quot; scopes pcs     [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="udiff-line-modified-added">+                                              p2i(scopes_pcs_begin()),</span>
<span class="udiff-line-modified-added">+                                              p2i(scopes_pcs_end()),</span>
<span class="udiff-line-modified-added">+                                              scopes_pcs_size());</span>
<span class="udiff-line-modified-added">+   if (dependencies_size () &gt; 0) st-&gt;print_cr(&quot; dependencies   [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="udiff-line-modified-added">+                                              p2i(dependencies_begin()),</span>
<span class="udiff-line-modified-added">+                                              p2i(dependencies_end()),</span>
<span class="udiff-line-modified-added">+                                              dependencies_size());</span>
<span class="udiff-line-modified-added">+   if (handler_table_size() &gt; 0) st-&gt;print_cr(&quot; handler table  [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="udiff-line-modified-added">+                                              p2i(handler_table_begin()),</span>
<span class="udiff-line-modified-added">+                                              p2i(handler_table_end()),</span>
<span class="udiff-line-modified-added">+                                              handler_table_size());</span>
<span class="udiff-line-modified-added">+   if (nul_chk_table_size() &gt; 0) st-&gt;print_cr(&quot; nul chk table  [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="udiff-line-modified-added">+                                              p2i(nul_chk_table_begin()),</span>
<span class="udiff-line-modified-added">+                                              p2i(nul_chk_table_end()),</span>
<span class="udiff-line-modified-added">+                                              nul_chk_table_size());</span>
<span class="udiff-line-added">+ #if INCLUDE_JVMCI</span>
<span class="udiff-line-added">+   if (speculations_size () &gt; 0) st-&gt;print_cr(&quot; speculations   [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="udiff-line-added">+                                              p2i(speculations_begin()),</span>
<span class="udiff-line-added">+                                              p2i(speculations_end()),</span>
<span class="udiff-line-added">+                                              speculations_size());</span>
<span class="udiff-line-added">+   if (jvmci_data_size   () &gt; 0) st-&gt;print_cr(&quot; JVMCI data     [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="udiff-line-added">+                                              p2i(jvmci_data_begin()),</span>
<span class="udiff-line-added">+                                              p2i(jvmci_data_end()),</span>
<span class="udiff-line-added">+                                              jvmci_data_size());</span>
<span class="udiff-line-added">+ #endif</span>
  }
  
<span class="udiff-line-modified-removed">- #ifndef PRODUCT</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- void nmethod::print_scopes() {</span>
<span class="udiff-line-modified-removed">-   // Find the first pc desc for all scopes in the code and print it.</span>
<span class="udiff-line-modified-removed">-   ResourceMark rm;</span>
<span class="udiff-line-modified-removed">-   for (PcDesc* p = scopes_pcs_begin(); p &lt; scopes_pcs_end(); p++) {</span>
<span class="udiff-line-removed">-     if (p-&gt;scope_decode_offset() == DebugInformationRecorder::serialized_null)</span>
<span class="udiff-line-removed">-       continue;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     ScopeDesc* sd = scope_desc_at(p-&gt;real_pc(this));</span>
<span class="udiff-line-removed">-     while (sd != NULL) {</span>
<span class="udiff-line-removed">-       sd-&gt;print_on(tty, p);</span>
<span class="udiff-line-removed">-       sd = sd-&gt;sender();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+ void nmethod::print_code() {</span>
<span class="udiff-line-modified-added">+   HandleMark hm;</span>
<span class="udiff-line-modified-added">+   ResourceMark m;</span>
<span class="udiff-line-modified-added">+   ttyLocker ttyl;</span>
<span class="udiff-line-modified-added">+   // Call the specialized decode method of this class.</span>
<span class="udiff-line-modified-added">+   decode(tty);</span>
  }
  
<span class="udiff-line-added">+ #ifndef PRODUCT  // called InstanceKlass methods are available only then. Declared as PRODUCT_RETURN</span>
<span class="udiff-line-added">+ </span>
  void nmethod::print_dependencies() {
    ResourceMark rm;
    ttyLocker ttyl;   // keep the following output all in one block
    tty-&gt;print_cr(&quot;Dependencies:&quot;);
    for (Dependencies::DepStream deps(this); deps.next(); ) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2329,71 +2575,395 @@</span>
        }
      }
      deps.log_dependency();  // put it into the xml log also
    }
  }
<span class="udiff-line-added">+ #endif</span>
  
<span class="udiff-line-added">+ #if defined(SUPPORT_DATA_STRUCTS)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Print the oops from the underlying CodeBlob.</span>
<span class="udiff-line-added">+ void nmethod::print_oops(outputStream* st) {</span>
<span class="udiff-line-added">+   HandleMark hm;</span>
<span class="udiff-line-added">+   ResourceMark m;</span>
<span class="udiff-line-added">+   st-&gt;print(&quot;Oops:&quot;);</span>
<span class="udiff-line-added">+   if (oops_begin() &lt; oops_end()) {</span>
<span class="udiff-line-added">+     st-&gt;cr();</span>
<span class="udiff-line-added">+     for (oop* p = oops_begin(); p &lt; oops_end(); p++) {</span>
<span class="udiff-line-added">+       Disassembler::print_location((unsigned char*)p, (unsigned char*)oops_begin(), (unsigned char*)oops_end(), st, true, false);</span>
<span class="udiff-line-added">+       st-&gt;print(PTR_FORMAT &quot; &quot;, *((uintptr_t*)p));</span>
<span class="udiff-line-added">+       if (*p == Universe::non_oop_word()) {</span>
<span class="udiff-line-added">+         st-&gt;print_cr(&quot;NON_OOP&quot;);</span>
<span class="udiff-line-added">+         continue;  // skip non-oops</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       if (*p == NULL) {</span>
<span class="udiff-line-added">+         st-&gt;print_cr(&quot;NULL-oop&quot;);</span>
<span class="udiff-line-added">+         continue;  // skip non-oops</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       (*p)-&gt;print_value_on(st);</span>
<span class="udiff-line-added">+       st-&gt;cr();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     st-&gt;print_cr(&quot; &lt;list empty&gt;&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Print metadata pool.</span>
<span class="udiff-line-added">+ void nmethod::print_metadata(outputStream* st) {</span>
<span class="udiff-line-added">+   HandleMark hm;</span>
<span class="udiff-line-added">+   ResourceMark m;</span>
<span class="udiff-line-added">+   st-&gt;print(&quot;Metadata:&quot;);</span>
<span class="udiff-line-added">+   if (metadata_begin() &lt; metadata_end()) {</span>
<span class="udiff-line-added">+     st-&gt;cr();</span>
<span class="udiff-line-added">+     for (Metadata** p = metadata_begin(); p &lt; metadata_end(); p++) {</span>
<span class="udiff-line-added">+       Disassembler::print_location((unsigned char*)p, (unsigned char*)metadata_begin(), (unsigned char*)metadata_end(), st, true, false);</span>
<span class="udiff-line-added">+       st-&gt;print(PTR_FORMAT &quot; &quot;, *((uintptr_t*)p));</span>
<span class="udiff-line-added">+       if (*p &amp;&amp; *p != Universe::non_oop_word()) {</span>
<span class="udiff-line-added">+         (*p)-&gt;print_value_on(st);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       st-&gt;cr();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     st-&gt;print_cr(&quot; &lt;list empty&gt;&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-added">+ #ifndef PRODUCT  // ScopeDesc::print_on() is available only then. Declared as PRODUCT_RETURN</span>
<span class="udiff-line-added">+ void nmethod::print_scopes_on(outputStream* st) {</span>
<span class="udiff-line-added">+   // Find the first pc desc for all scopes in the code and print it.</span>
<span class="udiff-line-added">+   ResourceMark rm;</span>
<span class="udiff-line-added">+   st-&gt;print(&quot;scopes:&quot;);</span>
<span class="udiff-line-added">+   if (scopes_pcs_begin() &lt; scopes_pcs_end()) {</span>
<span class="udiff-line-added">+     st-&gt;cr();</span>
<span class="udiff-line-added">+     for (PcDesc* p = scopes_pcs_begin(); p &lt; scopes_pcs_end(); p++) {</span>
<span class="udiff-line-added">+       if (p-&gt;scope_decode_offset() == DebugInformationRecorder::serialized_null)</span>
<span class="udiff-line-added">+         continue;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       ScopeDesc* sd = scope_desc_at(p-&gt;real_pc(this));</span>
<span class="udiff-line-added">+       while (sd != NULL) {</span>
<span class="udiff-line-added">+         sd-&gt;print_on(st, p);  // print output ends with a newline</span>
<span class="udiff-line-added">+         sd = sd-&gt;sender();</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     st-&gt;print_cr(&quot; &lt;list empty&gt;&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifndef PRODUCT  // RelocIterator does support printing only then.</span>
  void nmethod::print_relocations() {
    ResourceMark m;       // in case methods get printed via the debugger
    tty-&gt;print_cr(&quot;relocations:&quot;);
    RelocIterator iter(this);
    iter.print();
  }
<span class="udiff-line-added">+ #endif</span>
  
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">- void nmethod::print_pcs() {</span>
<span class="udiff-line-modified-added">+ void nmethod::print_pcs_on(outputStream* st) {</span>
    ResourceMark m;       // in case methods get printed via debugger
<span class="udiff-line-modified-removed">-   tty-&gt;print_cr(&quot;pc-bytecode offsets:&quot;);</span>
<span class="udiff-line-modified-removed">-   for (PcDesc* p = scopes_pcs_begin(); p &lt; scopes_pcs_end(); p++) {</span>
<span class="udiff-line-modified-removed">-     p-&gt;print(this);</span>
<span class="udiff-line-modified-added">+   st-&gt;print(&quot;pc-bytecode offsets:&quot;);</span>
<span class="udiff-line-modified-added">+   if (scopes_pcs_begin() &lt; scopes_pcs_end()) {</span>
<span class="udiff-line-modified-added">+     st-&gt;cr();</span>
<span class="udiff-line-added">+     for (PcDesc* p = scopes_pcs_begin(); p &lt; scopes_pcs_end(); p++) {</span>
<span class="udiff-line-added">+       p-&gt;print_on(st, this);  // print output ends with a newline</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     st-&gt;print_cr(&quot; &lt;list empty&gt;&quot;);</span>
    }
  }
  
<span class="udiff-line-added">+ void nmethod::print_handler_table() {</span>
<span class="udiff-line-added">+   ExceptionHandlerTable(this).print();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void nmethod::print_nul_chk_table() {</span>
<span class="udiff-line-added">+   ImplicitExceptionTable(this).print(code_begin());</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void nmethod::print_recorded_oops() {
<span class="udiff-line-modified-removed">-   tty-&gt;print_cr(&quot;Recorded oops:&quot;);</span>
<span class="udiff-line-modified-removed">-   for (int i = 0; i &lt; oops_count(); i++) {</span>
<span class="udiff-line-modified-removed">-     oop o = oop_at(i);</span>
<span class="udiff-line-modified-removed">-     tty-&gt;print(&quot;#%3d: &quot; INTPTR_FORMAT &quot; &quot;, i, p2i(o));</span>
<span class="udiff-line-modified-removed">-     if (o == Universe::non_oop_word()) {</span>
<span class="udiff-line-modified-removed">-       tty-&gt;print(&quot;non-oop word&quot;);</span>
<span class="udiff-line-modified-removed">-     } else {</span>
<span class="udiff-line-modified-removed">-       if (o != NULL) {</span>
<span class="udiff-line-modified-removed">-         o-&gt;print_value();</span>
<span class="udiff-line-modified-added">+   const int n = oops_count();</span>
<span class="udiff-line-modified-added">+   const int log_n = (n&lt;10) ? 1 : (n&lt;100) ? 2 : (n&lt;1000) ? 3 : (n&lt;10000) ? 4 : 6;</span>
<span class="udiff-line-modified-added">+   tty-&gt;print(&quot;Recorded oops:&quot;);</span>
<span class="udiff-line-modified-added">+   if (n &gt; 0) {</span>
<span class="udiff-line-modified-added">+     tty-&gt;cr();</span>
<span class="udiff-line-modified-added">+     for (int i = 0; i &lt; n; i++) {</span>
<span class="udiff-line-modified-added">+       oop o = oop_at(i);</span>
<span class="udiff-line-modified-added">+       tty-&gt;print(&quot;#%*d: &quot; INTPTR_FORMAT &quot; &quot;, log_n, i, p2i(o));</span>
<span class="udiff-line-modified-added">+       if (o == (oop)Universe::non_oop_word()) {</span>
<span class="udiff-line-added">+         tty-&gt;print(&quot;non-oop word&quot;);</span>
<span class="udiff-line-added">+       } else if (o == NULL) {</span>
<span class="udiff-line-added">+         tty-&gt;print(&quot;NULL-oop&quot;);</span>
        } else {
<span class="udiff-line-modified-removed">-         tty-&gt;print_cr(&quot;NULL&quot;);</span>
<span class="udiff-line-modified-added">+         o-&gt;print_value_on(tty);</span>
        }
<span class="udiff-line-added">+       tty-&gt;cr();</span>
      }
<span class="udiff-line-modified-removed">-     tty-&gt;cr();</span>
<span class="udiff-line-modified-added">+   } else {</span>
<span class="udiff-line-added">+     tty-&gt;print_cr(&quot; &lt;list empty&gt;&quot;);</span>
    }
  }
  
  void nmethod::print_recorded_metadata() {
<span class="udiff-line-modified-removed">-   tty-&gt;print_cr(&quot;Recorded metadata:&quot;);</span>
<span class="udiff-line-modified-removed">-   for (int i = 0; i &lt; metadata_count(); i++) {</span>
<span class="udiff-line-modified-removed">-     Metadata* m = metadata_at(i);</span>
<span class="udiff-line-modified-removed">-     tty-&gt;print(&quot;#%3d: &quot; INTPTR_FORMAT &quot; &quot;, i, p2i(m));</span>
<span class="udiff-line-modified-removed">-     if (m == (Metadata*)Universe::non_oop_word()) {</span>
<span class="udiff-line-modified-removed">-       tty-&gt;print(&quot;non-metadata word&quot;);</span>
<span class="udiff-line-modified-added">+   const int n = metadata_count();</span>
<span class="udiff-line-modified-added">+   const int log_n = (n&lt;10) ? 1 : (n&lt;100) ? 2 : (n&lt;1000) ? 3 : (n&lt;10000) ? 4 : 6;</span>
<span class="udiff-line-modified-added">+   tty-&gt;print(&quot;Recorded metadata:&quot;);</span>
<span class="udiff-line-modified-added">+   if (n &gt; 0) {</span>
<span class="udiff-line-modified-added">+     tty-&gt;cr();</span>
<span class="udiff-line-modified-added">+     for (int i = 0; i &lt; n; i++) {</span>
<span class="udiff-line-added">+       Metadata* m = metadata_at(i);</span>
<span class="udiff-line-added">+       tty-&gt;print(&quot;#%*d: &quot; INTPTR_FORMAT &quot; &quot;, log_n, i, p2i(m));</span>
<span class="udiff-line-added">+       if (m == (Metadata*)Universe::non_oop_word()) {</span>
<span class="udiff-line-added">+         tty-&gt;print(&quot;non-metadata word&quot;);</span>
<span class="udiff-line-added">+       } else if (m == NULL) {</span>
<span class="udiff-line-added">+         tty-&gt;print(&quot;NULL-oop&quot;);</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         Metadata::print_value_on_maybe_null(tty, m);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       tty-&gt;cr();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     tty-&gt;print_cr(&quot; &lt;list empty&gt;&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #if defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_ABSTRACT_ASSEMBLY)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void nmethod::print_constant_pool(outputStream* st) {</span>
<span class="udiff-line-added">+   //-----------------------------------</span>
<span class="udiff-line-added">+   //---&lt;  Print the constant pool  &gt;---</span>
<span class="udiff-line-added">+   //-----------------------------------</span>
<span class="udiff-line-added">+   int consts_size = this-&gt;consts_size();</span>
<span class="udiff-line-added">+   if ( consts_size &gt; 0 ) {</span>
<span class="udiff-line-added">+     unsigned char* cstart = this-&gt;consts_begin();</span>
<span class="udiff-line-added">+     unsigned char* cp     = cstart;</span>
<span class="udiff-line-added">+     unsigned char* cend   = cp + consts_size;</span>
<span class="udiff-line-added">+     unsigned int   bytes_per_line = 4;</span>
<span class="udiff-line-added">+     unsigned int   CP_alignment   = 8;</span>
<span class="udiff-line-added">+     unsigned int   n;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     st-&gt;cr();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     //---&lt;  print CP header to make clear what&#39;s printed  &gt;---</span>
<span class="udiff-line-added">+     if( ((uintptr_t)cp&amp;(CP_alignment-1)) == 0 ) {</span>
<span class="udiff-line-added">+       n = bytes_per_line;</span>
<span class="udiff-line-added">+       st-&gt;print_cr(&quot;[Constant Pool]&quot;);</span>
<span class="udiff-line-added">+       Disassembler::print_location(cp, cstart, cend, st, true, true);</span>
<span class="udiff-line-added">+       Disassembler::print_hexdata(cp, n, st, true);</span>
<span class="udiff-line-added">+       st-&gt;cr();</span>
      } else {
<span class="udiff-line-modified-removed">-       Metadata::print_value_on_maybe_null(tty, m);</span>
<span class="udiff-line-modified-added">+       n = (uintptr_t)cp&amp;(bytes_per_line-1);</span>
<span class="udiff-line-added">+       st-&gt;print_cr(&quot;[Constant Pool (unaligned)]&quot;);</span>
      }
<span class="udiff-line-modified-removed">-     tty-&gt;cr();</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+     //---&lt;  print CP contents, bytes_per_line at a time  &gt;---</span>
<span class="udiff-line-added">+     while (cp &lt; cend) {</span>
<span class="udiff-line-added">+       Disassembler::print_location(cp, cstart, cend, st, true, false);</span>
<span class="udiff-line-added">+       Disassembler::print_hexdata(cp, n, st, false);</span>
<span class="udiff-line-added">+       cp += n;</span>
<span class="udiff-line-added">+       n   = bytes_per_line;</span>
<span class="udiff-line-added">+       st-&gt;cr();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     //---&lt;  Show potential alignment gap between constant pool and code  &gt;---</span>
<span class="udiff-line-added">+     cend = code_begin();</span>
<span class="udiff-line-added">+     if( cp &lt; cend ) {</span>
<span class="udiff-line-added">+       n = 4;</span>
<span class="udiff-line-added">+       st-&gt;print_cr(&quot;[Code entry alignment]&quot;);</span>
<span class="udiff-line-added">+       while (cp &lt; cend) {</span>
<span class="udiff-line-added">+         Disassembler::print_location(cp, cstart, cend, st, false, false);</span>
<span class="udiff-line-added">+         cp += n;</span>
<span class="udiff-line-added">+         st-&gt;cr();</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     st-&gt;print_cr(&quot;[Constant Pool (empty)]&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   st-&gt;cr();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Disassemble this nmethod.</span>
<span class="udiff-line-added">+ // Print additional debug information, if requested. This could be code</span>
<span class="udiff-line-added">+ // comments, block comments, profiling counters, etc.</span>
<span class="udiff-line-added">+ // The undisassembled format is useful no disassembler library is available.</span>
<span class="udiff-line-added">+ // The resulting hex dump (with markers) can be disassembled later, or on</span>
<span class="udiff-line-added">+ // another system, when/where a disassembler library is available.</span>
<span class="udiff-line-added">+ void nmethod::decode2(outputStream* ost) const {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Called from frame::back_trace_with_decode without ResourceMark.</span>
<span class="udiff-line-added">+   ResourceMark rm;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Make sure we have a valid stream to print on.</span>
<span class="udiff-line-added">+   outputStream* st = ost ? ost : tty;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #if defined(SUPPORT_ABSTRACT_ASSEMBLY) &amp;&amp; ! defined(SUPPORT_ASSEMBLY)</span>
<span class="udiff-line-added">+   const bool use_compressed_format    = true;</span>
<span class="udiff-line-added">+   const bool compressed_with_comments = use_compressed_format &amp;&amp; (AbstractDisassembler::show_comment() ||</span>
<span class="udiff-line-added">+                                                                   AbstractDisassembler::show_block_comment());</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+   const bool use_compressed_format    = Disassembler::is_abstract();</span>
<span class="udiff-line-added">+   const bool compressed_with_comments = use_compressed_format &amp;&amp; (AbstractDisassembler::show_comment() ||</span>
<span class="udiff-line-added">+                                                                   AbstractDisassembler::show_block_comment());</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   st-&gt;cr();</span>
<span class="udiff-line-added">+   this-&gt;print(st);</span>
<span class="udiff-line-added">+   st-&gt;cr();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #if defined(SUPPORT_ASSEMBLY)</span>
<span class="udiff-line-added">+   //----------------------------------</span>
<span class="udiff-line-added">+   //---&lt;  Print real disassembly  &gt;---</span>
<span class="udiff-line-added">+   //----------------------------------</span>
<span class="udiff-line-added">+   if (! use_compressed_format) {</span>
<span class="udiff-line-added">+     Disassembler::decode(const_cast&lt;nmethod*&gt;(this), st);</span>
<span class="udiff-line-added">+     return;</span>
    }
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #if defined(SUPPORT_ABSTRACT_ASSEMBLY)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Compressed undisassembled disassembly format.</span>
<span class="udiff-line-added">+   // The following stati are defined/supported:</span>
<span class="udiff-line-added">+   //   = 0 - currently at bol() position, nothing printed yet on current line.</span>
<span class="udiff-line-added">+   //   = 1 - currently at position after print_location().</span>
<span class="udiff-line-added">+   //   &gt; 1 - in the midst of printing instruction stream bytes.</span>
<span class="udiff-line-added">+   int        compressed_format_idx    = 0;</span>
<span class="udiff-line-added">+   int        code_comment_column      = 0;</span>
<span class="udiff-line-added">+   const int  instr_maxlen             = Assembler::instr_maxlen();</span>
<span class="udiff-line-added">+   const uint tabspacing               = 8;</span>
<span class="udiff-line-added">+   unsigned char* start = this-&gt;code_begin();</span>
<span class="udiff-line-added">+   unsigned char* p     = this-&gt;code_begin();</span>
<span class="udiff-line-added">+   unsigned char* end   = this-&gt;code_end();</span>
<span class="udiff-line-added">+   unsigned char* pss   = p; // start of a code section (used for offsets)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if ((start == NULL) || (end == NULL)) {</span>
<span class="udiff-line-added">+     st-&gt;print_cr(&quot;PrintAssembly not possible due to uninitialized section pointers&quot;);</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #if defined(SUPPORT_ABSTRACT_ASSEMBLY)</span>
<span class="udiff-line-added">+   //---&lt;  plain abstract disassembly, no comments or anything, just section headers  &gt;---</span>
<span class="udiff-line-added">+   if (use_compressed_format &amp;&amp; ! compressed_with_comments) {</span>
<span class="udiff-line-added">+     const_cast&lt;nmethod*&gt;(this)-&gt;print_constant_pool(st);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     //---&lt;  Open the output (Marker for post-mortem disassembler)  &gt;---</span>
<span class="udiff-line-added">+     st-&gt;print_cr(&quot;[MachCode]&quot;);</span>
<span class="udiff-line-added">+     const char* header = NULL;</span>
<span class="udiff-line-added">+     address p0 = p;</span>
<span class="udiff-line-added">+     while (p &lt; end) {</span>
<span class="udiff-line-added">+       address pp = p;</span>
<span class="udiff-line-added">+       while ((p &lt; end) &amp;&amp; (header == NULL)) {</span>
<span class="udiff-line-added">+         header = nmethod_section_label(p);</span>
<span class="udiff-line-added">+         pp  = p;</span>
<span class="udiff-line-added">+         p  += Assembler::instr_len(p);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       if (pp &gt; p0) {</span>
<span class="udiff-line-added">+         AbstractDisassembler::decode_range_abstract(p0, pp, start, end, st, Assembler::instr_maxlen());</span>
<span class="udiff-line-added">+         p0 = pp;</span>
<span class="udiff-line-added">+         p  = pp;</span>
<span class="udiff-line-added">+         header = NULL;</span>
<span class="udiff-line-added">+       } else if (header != NULL) {</span>
<span class="udiff-line-added">+         st-&gt;bol();</span>
<span class="udiff-line-added">+         st-&gt;print_cr(&quot;%s&quot;, header);</span>
<span class="udiff-line-added">+         header = NULL;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     //---&lt;  Close the output (Marker for post-mortem disassembler)  &gt;---</span>
<span class="udiff-line-added">+     st-&gt;bol();</span>
<span class="udiff-line-added">+     st-&gt;print_cr(&quot;[/MachCode]&quot;);</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #if defined(SUPPORT_ABSTRACT_ASSEMBLY)</span>
<span class="udiff-line-added">+   //---&lt;  abstract disassembly with comments and section headers merged in  &gt;---</span>
<span class="udiff-line-added">+   if (compressed_with_comments) {</span>
<span class="udiff-line-added">+     const_cast&lt;nmethod*&gt;(this)-&gt;print_constant_pool(st);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     //---&lt;  Open the output (Marker for post-mortem disassembler)  &gt;---</span>
<span class="udiff-line-added">+     st-&gt;print_cr(&quot;[MachCode]&quot;);</span>
<span class="udiff-line-added">+     while ((p &lt; end) &amp;&amp; (p != NULL)) {</span>
<span class="udiff-line-added">+       const int instruction_size_in_bytes = Assembler::instr_len(p);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       //---&lt;  Block comments for nmethod. Interrupts instruction stream, if any.  &gt;---</span>
<span class="udiff-line-added">+       // Outputs a bol() before and a cr() after, but only if a comment is printed.</span>
<span class="udiff-line-added">+       // Prints nmethod_section_label as well.</span>
<span class="udiff-line-added">+       if (AbstractDisassembler::show_block_comment()) {</span>
<span class="udiff-line-added">+         print_block_comment(st, p);</span>
<span class="udiff-line-added">+         if (st-&gt;position() == 0) {</span>
<span class="udiff-line-added">+           compressed_format_idx = 0;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       //---&lt;  New location information after line break  &gt;---</span>
<span class="udiff-line-added">+       if (compressed_format_idx == 0) {</span>
<span class="udiff-line-added">+         code_comment_column   = Disassembler::print_location(p, pss, end, st, false, false);</span>
<span class="udiff-line-added">+         compressed_format_idx = 1;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       //---&lt;  Code comment for current instruction. Address range [p..(p+len))  &gt;---</span>
<span class="udiff-line-added">+       unsigned char* p_end = p + (ssize_t)instruction_size_in_bytes;</span>
<span class="udiff-line-added">+       S390_ONLY(if (p_end &gt; end) p_end = end;) // avoid getting past the end</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       if (AbstractDisassembler::show_comment() &amp;&amp; const_cast&lt;nmethod*&gt;(this)-&gt;has_code_comment(p, p_end)) {</span>
<span class="udiff-line-added">+         //---&lt;  interrupt instruction byte stream for code comment  &gt;---</span>
<span class="udiff-line-added">+         if (compressed_format_idx &gt; 1) {</span>
<span class="udiff-line-added">+           st-&gt;cr();  // interrupt byte stream</span>
<span class="udiff-line-added">+           st-&gt;cr();  // add an empty line</span>
<span class="udiff-line-added">+           code_comment_column = Disassembler::print_location(p, pss, end, st, false, false);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         const_cast&lt;nmethod*&gt;(this)-&gt;print_code_comment_on(st, code_comment_column, p, p_end );</span>
<span class="udiff-line-added">+         st-&gt;bol();</span>
<span class="udiff-line-added">+         compressed_format_idx = 0;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       //---&lt;  New location information after line break  &gt;---</span>
<span class="udiff-line-added">+       if (compressed_format_idx == 0) {</span>
<span class="udiff-line-added">+         code_comment_column   = Disassembler::print_location(p, pss, end, st, false, false);</span>
<span class="udiff-line-added">+         compressed_format_idx = 1;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       //---&lt;  Nicely align instructions for readability  &gt;---</span>
<span class="udiff-line-added">+       if (compressed_format_idx &gt; 1) {</span>
<span class="udiff-line-added">+         Disassembler::print_delimiter(st);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       //---&lt;  Now, finally, print the actual instruction bytes  &gt;---</span>
<span class="udiff-line-added">+       unsigned char* p0 = p;</span>
<span class="udiff-line-added">+       p = Disassembler::decode_instruction_abstract(p, st, instruction_size_in_bytes, instr_maxlen);</span>
<span class="udiff-line-added">+       compressed_format_idx += p - p0;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       if (Disassembler::start_newline(compressed_format_idx-1)) {</span>
<span class="udiff-line-added">+         st-&gt;cr();</span>
<span class="udiff-line-added">+         compressed_format_idx = 0;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     //---&lt;  Close the output (Marker for post-mortem disassembler)  &gt;---</span>
<span class="udiff-line-added">+     st-&gt;bol();</span>
<span class="udiff-line-added">+     st-&gt;print_cr(&quot;[/MachCode]&quot;);</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ #endif</span>
  }
  
<span class="udiff-line-modified-removed">- #endif // PRODUCT</span>
<span class="udiff-line-modified-added">+ #if defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_ABSTRACT_ASSEMBLY)</span>
  
  const char* nmethod::reloc_string_for(u_char* begin, u_char* end) {
    RelocIterator iter(this, begin, end);
    bool have_one = false;
    while (iter.next()) {
      have_one = true;
      switch (iter.type()) {
          case relocInfo::none:                  return &quot;no_reloc&quot;;
          case relocInfo::oop_type: {
<span class="udiff-line-modified-removed">-           stringStream st;</span>
<span class="udiff-line-modified-added">+           // Get a non-resizable resource-allocated stringStream.</span>
<span class="udiff-line-added">+           // Our callees make use of (nested) ResourceMarks.</span>
<span class="udiff-line-added">+           stringStream st(NEW_RESOURCE_ARRAY(char, 1024), 1024);</span>
            oop_Relocation* r = iter.oop_reloc();
            oop obj = r-&gt;oop_value();
            st.print(&quot;oop(&quot;);
            if (obj == NULL) st.print(&quot;NULL&quot;);
            else obj-&gt;print_value_on(&amp;st);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2491,30 +3061,41 @@</span>
                           p-&gt;return_oop());
    }
    return NULL;
  }
  
<span class="udiff-line-modified-removed">- void nmethod::print_nmethod_labels(outputStream* stream, address block_begin) const {</span>
<span class="udiff-line-modified-removed">-   if (block_begin == entry_point())             stream-&gt;print_cr(&quot;[Entry Point]&quot;);</span>
<span class="udiff-line-modified-removed">-   if (block_begin == verified_entry_point())    stream-&gt;print_cr(&quot;[Verified Entry Point]&quot;);</span>
<span class="udiff-line-modified-removed">-   if (JVMCI_ONLY(_exception_offset &gt;= 0 &amp;&amp;) block_begin == exception_begin())         stream-&gt;print_cr(&quot;[Exception Handler]&quot;);</span>
<span class="udiff-line-modified-removed">-   if (block_begin == stub_begin())              stream-&gt;print_cr(&quot;[Stub Code]&quot;);</span>
<span class="udiff-line-modified-removed">-   if (JVMCI_ONLY(_deopt_handler_begin != NULL &amp;&amp;) block_begin == deopt_handler_begin())     stream-&gt;print_cr(&quot;[Deopt Handler Code]&quot;);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   if (has_method_handle_invokes())</span>
<span class="udiff-line-modified-removed">-     if (block_begin == deopt_mh_handler_begin())  stream-&gt;print_cr(&quot;[Deopt MH Handler Code]&quot;);</span>
<span class="udiff-line-modified-added">+ const char* nmethod::nmethod_section_label(address pos) const {</span>
<span class="udiff-line-modified-added">+   const char* label = NULL;</span>
<span class="udiff-line-modified-added">+   if (pos == code_begin())                                              label = &quot;[Instructions begin]&quot;;</span>
<span class="udiff-line-modified-added">+   if (pos == entry_point())                                             label = &quot;[Entry Point]&quot;;</span>
<span class="udiff-line-modified-added">+   if (pos == verified_entry_point())                                    label = &quot;[Verified Entry Point]&quot;;</span>
<span class="udiff-line-modified-added">+   if (has_method_handle_invokes() &amp;&amp; (pos == deopt_mh_handler_begin())) label = &quot;[Deopt MH Handler Code]&quot;;</span>
<span class="udiff-line-modified-added">+   if (pos == consts_begin() &amp;&amp; pos != insts_begin())                    label = &quot;[Constants]&quot;;</span>
<span class="udiff-line-modified-added">+   // Check stub_code before checking exception_handler or deopt_handler.</span>
<span class="udiff-line-modified-added">+   if (pos == this-&gt;stub_begin())                                        label = &quot;[Stub Code]&quot;;</span>
<span class="udiff-line-added">+   if (JVMCI_ONLY(_exception_offset &gt;= 0 &amp;&amp;) pos == exception_begin())           label = &quot;[Exception Handler]&quot;;</span>
<span class="udiff-line-added">+   if (JVMCI_ONLY(_deopt_handler_begin != NULL &amp;&amp;) pos == deopt_handler_begin()) label = &quot;[Deopt Handler Code]&quot;;</span>
<span class="udiff-line-added">+   return label;</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-   if (block_begin == consts_begin())            stream-&gt;print_cr(&quot;[Constants]&quot;);</span>
<span class="udiff-line-modified-added">+ void nmethod::print_nmethod_labels(outputStream* stream, address block_begin, bool print_section_labels) const {</span>
<span class="udiff-line-added">+   if (print_section_labels) {</span>
<span class="udiff-line-added">+     const char* label = nmethod_section_label(block_begin);</span>
<span class="udiff-line-added">+     if (label != NULL) {</span>
<span class="udiff-line-added">+       stream-&gt;bol();</span>
<span class="udiff-line-added">+       stream-&gt;print_cr(&quot;%s&quot;, label);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
  
    if (block_begin == entry_point()) {
<span class="udiff-line-modified-removed">-     methodHandle m = method();</span>
<span class="udiff-line-modified-removed">-     if (m.not_null()) {</span>
<span class="udiff-line-modified-added">+     Method* m = method();</span>
<span class="udiff-line-modified-added">+     if (m != NULL) {</span>
        stream-&gt;print(&quot;  # &quot;);
        m-&gt;print_value_on(stream);
        stream-&gt;cr();
      }
<span class="udiff-line-modified-removed">-     if (m.not_null() &amp;&amp; !is_osr_method()) {</span>
<span class="udiff-line-modified-added">+     if (m != NULL &amp;&amp; !is_osr_method()) {</span>
        ResourceMark rm;
        int sizeargs = m-&gt;size_of_parameters();
        BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, sizeargs);
        VMRegPair* regs   = NEW_RESOURCE_ARRAY(VMRegPair, sizeargs);
        {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2568,16 +3149,14 @@</span>
          stream-&gt;print(&quot;= &quot;);
          if (at_this) {
            m-&gt;method_holder()-&gt;print_value_on(stream);
          } else {
            bool did_name = false;
<span class="udiff-line-modified-removed">-           if (!at_this &amp;&amp; ss.is_object()) {</span>
<span class="udiff-line-modified-removed">-             Symbol* name = ss.as_symbol_or_null();</span>
<span class="udiff-line-modified-removed">-             if (name != NULL) {</span>
<span class="udiff-line-modified-removed">-               name-&gt;print_value_on(stream);</span>
<span class="udiff-line-removed">-               did_name = true;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+           if (!at_this &amp;&amp; ss.is_reference()) {</span>
<span class="udiff-line-modified-added">+             Symbol* name = ss.as_symbol();</span>
<span class="udiff-line-modified-added">+             name-&gt;print_value_on(stream);</span>
<span class="udiff-line-modified-added">+             did_name = true;</span>
            }
            if (!did_name)
              stream-&gt;print(&quot;%s&quot;, type2name(t));
          }
          if (at_old_sp) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2598,36 +3177,80 @@</span>
        }
      }
    }
  }
  
<span class="udiff-line-modified-removed">- void nmethod::print_code_comment_on(outputStream* st, int column, u_char* begin, u_char* end) {</span>
<span class="udiff-line-modified-removed">-   // First, find an oopmap in (begin, end].</span>
<span class="udiff-line-modified-removed">-   // We use the odd half-closed interval so that oop maps and scope descs</span>
<span class="udiff-line-modified-removed">-   // which are tied to the byte after a call are printed with the call itself.</span>
<span class="udiff-line-modified-added">+ // Returns whether this nmethod has code comments.</span>
<span class="udiff-line-modified-added">+ bool nmethod::has_code_comment(address begin, address end) {</span>
<span class="udiff-line-modified-added">+   // scopes?</span>
<span class="udiff-line-modified-added">+   ScopeDesc* sd  = scope_desc_in(begin, end);</span>
<span class="udiff-line-added">+   if (sd != NULL) return true;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // relocations?</span>
<span class="udiff-line-added">+   const char* str = reloc_string_for(begin, end);</span>
<span class="udiff-line-added">+   if (str != NULL) return true;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // implicit exceptions?</span>
<span class="udiff-line-added">+   int cont_offset = ImplicitExceptionTable(this).continuation_offset(begin - code_begin());</span>
<span class="udiff-line-added">+   if (cont_offset != 0) return true;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return false;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void nmethod::print_code_comment_on(outputStream* st, int column, address begin, address end) {</span>
<span class="udiff-line-added">+   ImplicitExceptionTable implicit_table(this);</span>
<span class="udiff-line-added">+   int pc_offset = begin - code_begin();</span>
<span class="udiff-line-added">+   int cont_offset = implicit_table.continuation_offset(pc_offset);</span>
<span class="udiff-line-added">+   bool oop_map_required = false;</span>
<span class="udiff-line-added">+   if (cont_offset != 0) {</span>
<span class="udiff-line-added">+     st-&gt;move_to(column, 6, 0);</span>
<span class="udiff-line-added">+     if (pc_offset == cont_offset) {</span>
<span class="udiff-line-added">+       st-&gt;print(&quot;; implicit exception: deoptimizes&quot;);</span>
<span class="udiff-line-added">+       oop_map_required = true;</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       st-&gt;print(&quot;; implicit exception: dispatches to &quot; INTPTR_FORMAT, p2i(code_begin() + cont_offset));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Find an oopmap in (begin, end].  We use the odd half-closed</span>
<span class="udiff-line-added">+   // interval so that oop maps and scope descs which are tied to the</span>
<span class="udiff-line-added">+   // byte after a call are printed with the call itself.  OopMaps</span>
<span class="udiff-line-added">+   // associated with implicit exceptions are printed with the implicit</span>
<span class="udiff-line-added">+   // instruction.</span>
    address base = code_begin();
    ImmutableOopMapSet* oms = oop_maps();
    if (oms != NULL) {
      for (int i = 0, imax = oms-&gt;count(); i &lt; imax; i++) {
        const ImmutableOopMapPair* pair = oms-&gt;pair_at(i);
        const ImmutableOopMap* om = pair-&gt;get_from(oms);
        address pc = base + pair-&gt;pc_offset();
<span class="udiff-line-modified-removed">-       if (pc &gt; begin) {</span>
<span class="udiff-line-modified-removed">-         if (pc &lt;= end) {</span>
<span class="udiff-line-modified-removed">-           st-&gt;move_to(column);</span>
<span class="udiff-line-modified-added">+       if (pc &gt;= begin) {</span>
<span class="udiff-line-modified-added">+ #if INCLUDE_JVMCI</span>
<span class="udiff-line-modified-added">+         bool is_implicit_deopt = implicit_table.continuation_offset(pair-&gt;pc_offset()) == (uint) pair-&gt;pc_offset();</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+         bool is_implicit_deopt = false;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+         if (is_implicit_deopt ? pc == begin : pc &gt; begin &amp;&amp; pc &lt;= end) {</span>
<span class="udiff-line-added">+           st-&gt;move_to(column, 6, 0);</span>
            st-&gt;print(&quot;; &quot;);
            om-&gt;print_on(st);
<span class="udiff-line-added">+           oop_map_required = false;</span>
          }
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       if (pc &gt; end) {</span>
          break;
        }
      }
    }
<span class="udiff-line-added">+   assert(!oop_map_required, &quot;missed oopmap&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Thread* thread = Thread::current();</span>
  
    // Print any debug info present at this pc.
    ScopeDesc* sd  = scope_desc_in(begin, end);
    if (sd != NULL) {
<span class="udiff-line-modified-removed">-     st-&gt;move_to(column);</span>
<span class="udiff-line-modified-added">+     st-&gt;move_to(column, 6, 0);</span>
      if (sd-&gt;bci() == SynchronizationEntryBCI) {
        st-&gt;print(&quot;;*synchronization entry&quot;);
      } else if (sd-&gt;bci() == AfterBci) {
        st-&gt;print(&quot;;* method exit (unlocked if synchronized)&quot;);
      } else if (sd-&gt;bci() == UnwindBci) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2650,11 +3273,11 @@</span>
          case Bytecodes::_invokevirtual:
          case Bytecodes::_invokespecial:
          case Bytecodes::_invokestatic:
          case Bytecodes::_invokeinterface:
            {
<span class="udiff-line-modified-removed">-             Bytecode_invoke invoke(sd-&gt;method(), sd-&gt;bci());</span>
<span class="udiff-line-modified-added">+             Bytecode_invoke invoke(methodHandle(thread, sd-&gt;method()), sd-&gt;bci());</span>
              st-&gt;print(&quot; &quot;);
              if (invoke.name() != NULL)
                invoke.name()-&gt;print_symbol_on(st);
              else
                st-&gt;print(&quot;&lt;UNKNOWN&gt;&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2663,11 +3286,11 @@</span>
          case Bytecodes::_getfield:
          case Bytecodes::_putfield:
          case Bytecodes::_getstatic:
          case Bytecodes::_putstatic:
            {
<span class="udiff-line-modified-removed">-             Bytecode_field field(sd-&gt;method(), sd-&gt;bci());</span>
<span class="udiff-line-modified-added">+             Bytecode_field field(methodHandle(thread, sd-&gt;method()), sd-&gt;bci());</span>
              st-&gt;print(&quot; &quot;);
              if (field.name() != NULL)
                field.name()-&gt;print_symbol_on(st);
              else
                st-&gt;print(&quot;&lt;UNKNOWN&gt;&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2679,12 +3302,15 @@</span>
        st-&gt;print(&quot; {reexecute=%d rethrow=%d return_oop=%d}&quot;, sd-&gt;should_reexecute(), sd-&gt;rethrow_exception(), sd-&gt;return_oop());
      }
  
      // Print all scopes
      for (;sd != NULL; sd = sd-&gt;sender()) {
<span class="udiff-line-modified-removed">-       st-&gt;move_to(column);</span>
<span class="udiff-line-modified-added">+       st-&gt;move_to(column, 6, 0);</span>
        st-&gt;print(&quot;; -&quot;);
<span class="udiff-line-added">+       if (sd-&gt;should_reexecute()) {</span>
<span class="udiff-line-added">+         st-&gt;print(&quot; (reexecute)&quot;);</span>
<span class="udiff-line-added">+       }</span>
        if (sd-&gt;method() == NULL) {
          st-&gt;print(&quot;method is NULL&quot;);
        } else {
          sd-&gt;method()-&gt;print_short_name(st);
        }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2697,24 +3323,22 @@</span>
        st-&gt;cr();
      }
    }
  
    // Print relocation information
<span class="udiff-line-added">+   // Prevent memory leak: allocating without ResourceMark.</span>
<span class="udiff-line-added">+   ResourceMark rm;</span>
    const char* str = reloc_string_for(begin, end);
    if (str != NULL) {
      if (sd != NULL) st-&gt;cr();
<span class="udiff-line-modified-removed">-     st-&gt;move_to(column);</span>
<span class="udiff-line-modified-added">+     st-&gt;move_to(column, 6, 0);</span>
      st-&gt;print(&quot;;   {%s}&quot;, str);
    }
<span class="udiff-line-removed">-   int cont_offset = ImplicitExceptionTable(this).at(begin - code_begin());</span>
<span class="udiff-line-removed">-   if (cont_offset != 0) {</span>
<span class="udiff-line-removed">-     st-&gt;move_to(column);</span>
<span class="udiff-line-removed">-     st-&gt;print(&quot;; implicit exception: dispatches to &quot; INTPTR_FORMAT, p2i(code_begin() + cont_offset));</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
  }
  
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
  class DirectNativeCallWrapper: public NativeCallWrapper {
  private:
    NativeCall* _call;
  
  public:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2738,11 +3362,11 @@</span>
        CodeBlob* callee = CodeCache::find_blob(dest);
        CompiledMethod* cm = callee-&gt;as_compiled_method_or_null();
        if (cm != NULL &amp;&amp; cm-&gt;is_far_code()) {
          // Temporary fix, see JDK-8143106
          CompiledDirectStaticCall* csc = CompiledDirectStaticCall::at(instruction_address());
<span class="udiff-line-modified-removed">-         csc-&gt;set_to_far(methodHandle(cm-&gt;method()), dest);</span>
<span class="udiff-line-modified-added">+         csc-&gt;set_to_far(methodHandle(Thread::current(), cm-&gt;method()), dest);</span>
          return;
        }
      }
  #endif
      _call-&gt;set_destination_mt_safe(dest);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2817,16 +3441,18 @@</span>
  
  CompiledStaticCall* nmethod::compiledStaticCall_before(address return_addr) const {
    return CompiledDirectStaticCall::before(return_addr);
  }
  
<span class="udiff-line-modified-removed">- #ifndef PRODUCT</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+ #if defined(SUPPORT_DATA_STRUCTS)</span>
  void nmethod::print_value_on(outputStream* st) const {
    st-&gt;print(&quot;nmethod&quot;);
    print_on(st, NULL);
  }
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifndef PRODUCT</span>
  
  void nmethod::print_calls(outputStream* st) {
    RelocIterator iter(this);
    while (iter.next()) {
      switch (iter.type()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2844,18 +3470,10 @@</span>
        break;
      }
    }
  }
  
<span class="udiff-line-removed">- void nmethod::print_handler_table() {</span>
<span class="udiff-line-removed">-   ExceptionHandlerTable(this).print();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void nmethod::print_nul_chk_table() {</span>
<span class="udiff-line-removed">-   ImplicitExceptionTable(this).print(code_begin());</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  void nmethod::print_statistics() {
    ttyLocker ttyl;
    if (xtty != NULL)  xtty-&gt;head(&quot;statistics type=&#39;nmethod&#39;&quot;);
    native_nmethod_stats.print_native_nmethod_stats();
  #ifdef COMPILER1
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2877,118 +3495,21 @@</span>
  }
  
  #endif // !PRODUCT
  
  #if INCLUDE_JVMCI
<span class="udiff-line-modified-removed">- void nmethod::clear_jvmci_installed_code() {</span>
<span class="udiff-line-modified-removed">-   assert_locked_or_safepoint(Patching_lock);</span>
<span class="udiff-line-modified-removed">-   if (_jvmci_installed_code != NULL) {</span>
<span class="udiff-line-modified-removed">-     JNIHandles::destroy_weak_global(_jvmci_installed_code);</span>
<span class="udiff-line-modified-removed">-     _jvmci_installed_code = NULL;</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void nmethod::clear_speculation_log() {</span>
<span class="udiff-line-removed">-   assert_locked_or_safepoint(Patching_lock);</span>
<span class="udiff-line-removed">-   if (_speculation_log != NULL) {</span>
<span class="udiff-line-removed">-     JNIHandles::destroy_weak_global(_speculation_log);</span>
<span class="udiff-line-removed">-     _speculation_log = NULL;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void nmethod::maybe_invalidate_installed_code() {</span>
<span class="udiff-line-removed">-   if (!is_compiled_by_jvmci()) {</span>
<span class="udiff-line-removed">-     return;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   assert(Patching_lock-&gt;is_locked() ||</span>
<span class="udiff-line-removed">-          SafepointSynchronize::is_at_safepoint(), &quot;should be performed under a lock for consistency&quot;);</span>
<span class="udiff-line-removed">-   oop installed_code = JNIHandles::resolve(_jvmci_installed_code);</span>
<span class="udiff-line-removed">-   if (installed_code != NULL) {</span>
<span class="udiff-line-removed">-     // Update the values in the InstalledCode instance if it still refers to this nmethod</span>
<span class="udiff-line-removed">-     nmethod* nm = (nmethod*)InstalledCode::address(installed_code);</span>
<span class="udiff-line-removed">-     if (nm == this) {</span>
<span class="udiff-line-removed">-       if (!is_alive() || is_unloading()) {</span>
<span class="udiff-line-removed">-         // Break the link between nmethod and InstalledCode such that the nmethod</span>
<span class="udiff-line-removed">-         // can subsequently be flushed safely.  The link must be maintained while</span>
<span class="udiff-line-removed">-         // the method could have live activations since invalidateInstalledCode</span>
<span class="udiff-line-removed">-         // might want to invalidate all existing activations.</span>
<span class="udiff-line-removed">-         InstalledCode::set_address(installed_code, 0);</span>
<span class="udiff-line-removed">-         InstalledCode::set_entryPoint(installed_code, 0);</span>
<span class="udiff-line-removed">-       } else if (is_not_entrant()) {</span>
<span class="udiff-line-removed">-         // Remove the entry point so any invocation will fail but keep</span>
<span class="udiff-line-removed">-         // the address link around that so that existing activations can</span>
<span class="udiff-line-removed">-         // be invalidated.</span>
<span class="udiff-line-removed">-         InstalledCode::set_entryPoint(installed_code, 0);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   if (!is_alive() || is_unloading()) {</span>
<span class="udiff-line-removed">-     // Clear these out after the nmethod has been unregistered and any</span>
<span class="udiff-line-removed">-     // updates to the InstalledCode instance have been performed.</span>
<span class="udiff-line-removed">-     clear_jvmci_installed_code();</span>
<span class="udiff-line-removed">-     clear_speculation_log();</span>
<span class="udiff-line-modified-added">+ void nmethod::update_speculation(JavaThread* thread) {</span>
<span class="udiff-line-modified-added">+   jlong speculation = thread-&gt;pending_failed_speculation();</span>
<span class="udiff-line-modified-added">+   if (speculation != 0) {</span>
<span class="udiff-line-modified-added">+     guarantee(jvmci_nmethod_data() != NULL, &quot;failed speculation in nmethod without failed speculation list&quot;);</span>
<span class="udiff-line-modified-added">+     jvmci_nmethod_data()-&gt;add_failed_speculation(this, speculation);</span>
<span class="udiff-line-modified-added">+     thread-&gt;set_pending_failed_speculation(0);</span>
    }
  }
  
<span class="udiff-line-modified-removed">- void nmethod::invalidate_installed_code(Handle installedCode, TRAPS) {</span>
<span class="udiff-line-modified-removed">-   if (installedCode() == NULL) {</span>
<span class="udiff-line-modified-removed">-     THROW(vmSymbols::java_lang_NullPointerException());</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   jlong nativeMethod = InstalledCode::address(installedCode);</span>
<span class="udiff-line-removed">-   nmethod* nm = (nmethod*)nativeMethod;</span>
<span class="udiff-line-removed">-   if (nm == NULL) {</span>
<span class="udiff-line-removed">-     // Nothing to do</span>
<span class="udiff-line-removed">-     return;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   nmethodLocker nml(nm);</span>
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-   {</span>
<span class="udiff-line-removed">-     MutexLockerEx pl(Patching_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-removed">-     // This relationship can only be checked safely under a lock</span>
<span class="udiff-line-removed">-     assert(!nm-&gt;is_alive() || nm-&gt;is_unloading() || nm-&gt;jvmci_installed_code() == installedCode(), &quot;sanity check&quot;);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (nm-&gt;is_alive()) {</span>
<span class="udiff-line-removed">-     // Invalidating the InstalledCode means we want the nmethod</span>
<span class="udiff-line-removed">-     // to be deoptimized.</span>
<span class="udiff-line-removed">-     nm-&gt;mark_for_deoptimization();</span>
<span class="udiff-line-removed">-     VM_Deoptimize op;</span>
<span class="udiff-line-removed">-     VMThread::execute(&amp;op);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Multiple threads could reach this point so we now need to</span>
<span class="udiff-line-removed">-   // lock and re-check the link to the nmethod so that only one</span>
<span class="udiff-line-removed">-   // thread clears it.</span>
<span class="udiff-line-removed">-   MutexLockerEx pl(Patching_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-removed">-   if (InstalledCode::address(installedCode) == nativeMethod) {</span>
<span class="udiff-line-removed">-       InstalledCode::set_address(installedCode, 0);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- oop nmethod::jvmci_installed_code() {</span>
<span class="udiff-line-removed">-   return JNIHandles::resolve(_jvmci_installed_code);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- oop nmethod::speculation_log() {</span>
<span class="udiff-line-removed">-   return JNIHandles::resolve(_speculation_log);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- char* nmethod::jvmci_installed_code_name(char* buf, size_t buflen) const {</span>
<span class="udiff-line-removed">-   if (!this-&gt;is_compiled_by_jvmci()) {</span>
<span class="udiff-line-removed">-     return NULL;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   oop installed_code = JNIHandles::resolve(_jvmci_installed_code);</span>
<span class="udiff-line-removed">-   if (installed_code != NULL) {</span>
<span class="udiff-line-removed">-     oop installed_code_name = NULL;</span>
<span class="udiff-line-removed">-     if (installed_code-&gt;is_a(InstalledCode::klass())) {</span>
<span class="udiff-line-removed">-       installed_code_name = InstalledCode::name(installed_code);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     if (installed_code_name != NULL) {</span>
<span class="udiff-line-removed">-       return java_lang_String::as_utf8_string(installed_code_name, buf, (int)buflen);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+ const char* nmethod::jvmci_name() {</span>
<span class="udiff-line-modified-added">+   if (jvmci_nmethod_data() != NULL) {</span>
<span class="udiff-line-modified-added">+     return jvmci_nmethod_data()-&gt;name();</span>
    }
    return NULL;
  }
  #endif
</pre>
<center><a href="icBuffer.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nmethod.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
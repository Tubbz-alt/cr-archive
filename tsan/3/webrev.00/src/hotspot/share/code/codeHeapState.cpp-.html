<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/code/codeHeapState.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2018, 2019 SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;code/codeHeapState.hpp&quot;
  28 #include &quot;compiler/compileBroker.hpp&quot;
  29 #include &quot;runtime/sweeper.hpp&quot;
  30 
  31 // -------------------------
  32 // |  General Description  |
  33 // -------------------------
  34 // The CodeHeap state analytics are divided in two parts.
  35 // The first part examines the entire CodeHeap and aggregates all
  36 // information that is believed useful/important.
  37 //
  38 // Aggregation condenses the information of a piece of the CodeHeap
  39 // (4096 bytes by default) into an analysis granule. These granules
  40 // contain enough detail to gain initial insight while keeping the
  41 // internal structure sizes in check.
  42 //
  43 // The second part, which consists of several, independent steps,
  44 // prints the previously collected information with emphasis on
  45 // various aspects.
  46 //
  47 // The CodeHeap is a living thing. Therefore, protection against concurrent
  48 // modification (by acquiring the CodeCache_lock) is necessary. It has
  49 // to be provided by the caller of the analysis functions.
  50 // If the CodeCache_lock is not held, the analysis functions may print
  51 // less detailed information or may just do nothing. It is by intention
  52 // that an unprotected invocation is not abnormally terminated.
  53 //
  54 // Data collection and printing is done on an &quot;on request&quot; basis.
  55 // While no request is being processed, there is no impact on performance.
  56 // The CodeHeap state analytics do have some memory footprint.
  57 // The &quot;aggregate&quot; step allocates some data structures to hold the aggregated
  58 // information for later output. These data structures live until they are
  59 // explicitly discarded (function &quot;discard&quot;) or until the VM terminates.
  60 // There is one exception: the function &quot;all&quot; does not leave any data
  61 // structures allocated.
  62 //
  63 // Requests for real-time, on-the-fly analysis can be issued via
  64 //   jcmd &lt;pid&gt; Compiler.CodeHeap_Analytics [&lt;function&gt;] [&lt;granularity&gt;]
  65 //
  66 // If you are (only) interested in how the CodeHeap looks like after running
  67 // a sample workload, you can use the command line option
  68 //   -XX:+PrintCodeHeapAnalytics
  69 // It will cause a full analysis to be written to tty. In addition, a full
  70 // analysis will be written the first time a &quot;CodeCache full&quot; condition is
  71 // detected.
  72 //
  73 // The command line option produces output identical to the jcmd function
  74 //   jcmd &lt;pid&gt; Compiler.CodeHeap_Analytics all 4096
  75 // ---------------------------------------------------------------------------------
  76 
  77 // With this declaration macro, it is possible to switch between
  78 //  - direct output into an argument-passed outputStream and
  79 //  - buffered output into a bufferedStream with subsequent flush
  80 //    of the filled buffer to the outputStream.
  81 #define USE_BUFFEREDSTREAM
  82 
  83 // There are instances when composing an output line or a small set of
  84 // output lines out of many tty-&gt;print() calls creates significant overhead.
  85 // Writing to a bufferedStream buffer first has a significant advantage:
  86 // It uses noticeably less cpu cycles and reduces (when writing to a
  87 // network file) the required bandwidth by at least a factor of ten. Observed on MacOS.
  88 // That clearly makes up for the increased code complexity.
  89 //
  90 // Conversion of existing code is easy and straightforward, if the code already
  91 // uses a parameterized output destination, e.g. &quot;outputStream st&quot;.
  92 //  - rename the formal parameter to any other name, e.g. out_st.
  93 //  - at a suitable place in your code, insert
  94 //      BUFFEREDSTEAM_DECL(buf_st, out_st)
  95 // This will provide all the declarations necessary. After that, all
  96 // buf_st-&gt;print() (and the like) calls will be directed to a bufferedStream object.
  97 // Once a block of output (a line or a small set of lines) is composed, insert
  98 //      BUFFEREDSTREAM_FLUSH(termstring)
  99 // to flush the bufferedStream to the final destination out_st. termstring is just
 100 // an arbitrary string (e.g. &quot;\n&quot;) which is appended to the bufferedStream before
 101 // being written to out_st. Be aware that the last character written MUST be a &#39;\n&#39;.
 102 // Otherwise, buf_st-&gt;position() does not correspond to out_st-&gt;position() any longer.
 103 //      BUFFEREDSTREAM_FLUSH_LOCKED(termstring)
 104 // does the same thing, protected by the ttyLocker lock.
 105 //      BUFFEREDSTREAM_FLUSH_IF(termstring, remSize)
 106 // does a flush only if the remaining buffer space is less than remSize.
 107 //
 108 // To activate, #define USE_BUFFERED_STREAM before including this header.
 109 // If not activated, output will directly go to the originally used outputStream
 110 // with no additional overhead.
 111 //
 112 #if defined(USE_BUFFEREDSTREAM)
 113 // All necessary declarations to print via a bufferedStream
 114 // This macro must be placed before any other BUFFEREDSTREAM*
 115 // macro in the function.
 116 #define BUFFEREDSTREAM_DECL_SIZE(_anyst, _outst, _capa)       \
 117     ResourceMark         _rm;                                 \
 118     /* _anyst  name of the stream as used in the code */      \
 119     /* _outst  stream where final output will go to   */      \
 120     /* _capa   allocated capacity of stream buffer    */      \
 121     size_t           _nflush = 0;                             \
 122     size_t     _nforcedflush = 0;                             \
 123     size_t      _nsavedflush = 0;                             \
 124     size_t     _nlockedflush = 0;                             \
 125     size_t     _nflush_bytes = 0;                             \
 126     size_t         _capacity = _capa;                         \
 127     bufferedStream   _sstobj = bufferedStream(_capa);         \
 128     bufferedStream*  _sstbuf = &amp;_sstobj;                      \
 129     outputStream*    _outbuf = _outst;                        \
 130     bufferedStream*   _anyst = &amp;_sstobj; /* any stream. Use this to just print - no buffer flush.  */
 131 
 132 // Same as above, but with fixed buffer size.
 133 #define BUFFEREDSTREAM_DECL(_anyst, _outst)                   \
 134     BUFFEREDSTREAM_DECL_SIZE(_anyst, _outst, 4*K);
 135 
 136 // Flush the buffer contents unconditionally.
 137 // No action if the buffer is empty.
 138 #define BUFFEREDSTREAM_FLUSH(_termString)                     \
 139     if (((_termString) != NULL) &amp;&amp; (strlen(_termString) &gt; 0)){\
 140       _sstbuf-&gt;print(&quot;%s&quot;, _termString);                      \
 141     }                                                         \
 142     if (_sstbuf != _outbuf) {                                 \
 143       if (_sstbuf-&gt;size() != 0) {                             \
 144         _nforcedflush++; _nflush_bytes += _sstbuf-&gt;size();    \
 145         _outbuf-&gt;print(&quot;%s&quot;, _sstbuf-&gt;as_string());           \
 146         _sstbuf-&gt;reset();                                     \
 147       }                                                       \
 148     }
 149 
 150 // Flush the buffer contents if the remaining capacity is
 151 // less than the given threshold.
 152 #define BUFFEREDSTREAM_FLUSH_IF(_termString, _remSize)        \
 153     if (((_termString) != NULL) &amp;&amp; (strlen(_termString) &gt; 0)){\
 154       _sstbuf-&gt;print(&quot;%s&quot;, _termString);                      \
 155     }                                                         \
 156     if (_sstbuf != _outbuf) {                                 \
 157       if ((_capacity - _sstbuf-&gt;size()) &lt; (size_t)(_remSize)){\
 158         _nflush++; _nforcedflush--;                           \
 159         BUFFEREDSTREAM_FLUSH(&quot;&quot;)                              \
 160       } else {                                                \
 161         _nsavedflush++;                                       \
 162       }                                                       \
 163     }
 164 
 165 // Flush the buffer contents if the remaining capacity is less
 166 // than the calculated threshold (256 bytes + capacity/16)
 167 // That should suffice for all reasonably sized output lines.
 168 #define BUFFEREDSTREAM_FLUSH_AUTO(_termString)                \
 169     BUFFEREDSTREAM_FLUSH_IF(_termString, 256+(_capacity&gt;&gt;4))
 170 
 171 #define BUFFEREDSTREAM_FLUSH_LOCKED(_termString)              \
 172     { ttyLocker ttyl;/* keep this output block together */    \
 173       _nlockedflush++;                                        \
 174       BUFFEREDSTREAM_FLUSH(_termString)                       \
 175     }
 176 
 177 // #define BUFFEREDSTREAM_FLUSH_STAT()                           \
 178 //     if (_sstbuf != _outbuf) {                                 \
 179 //       _outbuf-&gt;print_cr(&quot;%ld flushes (buffer full), %ld forced, %ld locked, %ld bytes total, %ld flushes saved&quot;, _nflush, _nforcedflush, _nlockedflush, _nflush_bytes, _nsavedflush); \
 180 //    }
 181 
 182 #define BUFFEREDSTREAM_FLUSH_STAT()
 183 #else
 184 #define BUFFEREDSTREAM_DECL_SIZE(_anyst, _outst, _capa)       \
 185     size_t       _capacity = _capa;                           \
 186     outputStream*  _outbuf = _outst;                          \
 187     outputStream*  _anyst  = _outst;   /* any stream. Use this to just print - no buffer flush.  */
 188 
 189 #define BUFFEREDSTREAM_DECL(_anyst, _outst)                   \
 190     BUFFEREDSTREAM_DECL_SIZE(_anyst, _outst, 4*K)
 191 
 192 #define BUFFEREDSTREAM_FLUSH(_termString)                     \
 193     if (((_termString) != NULL) &amp;&amp; (strlen(_termString) &gt; 0)){\
 194       _outbuf-&gt;print(&quot;%s&quot;, _termString);                      \
 195     }
 196 
 197 #define BUFFEREDSTREAM_FLUSH_IF(_termString, _remSize)        \
 198     BUFFEREDSTREAM_FLUSH(_termString)
 199 
 200 #define BUFFEREDSTREAM_FLUSH_AUTO(_termString)                \
 201     BUFFEREDSTREAM_FLUSH(_termString)
 202 
 203 #define BUFFEREDSTREAM_FLUSH_LOCKED(_termString)              \
 204     BUFFEREDSTREAM_FLUSH(_termString)
 205 
 206 #define BUFFEREDSTREAM_FLUSH_STAT()
 207 #endif
 208 #define HEX32_FORMAT  &quot;0x%x&quot;  // just a helper format string used below multiple times
 209 
 210 const char  blobTypeChar[] = {&#39; &#39;, &#39;C&#39;, &#39;N&#39;, &#39;I&#39;, &#39;X&#39;, &#39;Z&#39;, &#39;U&#39;, &#39;R&#39;, &#39;?&#39;, &#39;D&#39;, &#39;T&#39;, &#39;E&#39;, &#39;S&#39;, &#39;A&#39;, &#39;M&#39;, &#39;B&#39;, &#39;L&#39; };
 211 const char* blobTypeName[] = {&quot;noType&quot;
 212                              ,     &quot;nMethod (under construction)&quot;
 213                              ,          &quot;nMethod (active)&quot;
 214                              ,               &quot;nMethod (inactive)&quot;
 215                              ,                    &quot;nMethod (deopt)&quot;
 216                              ,                         &quot;nMethod (zombie)&quot;
 217                              ,                              &quot;nMethod (unloaded)&quot;
 218                              ,                                   &quot;runtime stub&quot;
 219                              ,                                        &quot;ricochet stub&quot;
 220                              ,                                             &quot;deopt stub&quot;
 221                              ,                                                  &quot;uncommon trap stub&quot;
 222                              ,                                                       &quot;exception stub&quot;
 223                              ,                                                            &quot;safepoint stub&quot;
 224                              ,                                                                 &quot;adapter blob&quot;
 225                              ,                                                                      &quot;MH adapter blob&quot;
 226                              ,                                                                           &quot;buffer blob&quot;
 227                              ,                                                                                &quot;lastType&quot;
 228                              };
 229 const char* compTypeName[] = { &quot;none&quot;, &quot;c1&quot;, &quot;c2&quot;, &quot;jvmci&quot; };
 230 
 231 // Be prepared for ten different CodeHeap segments. Should be enough for a few years.
 232 const  unsigned int        nSizeDistElements = 31;  // logarithmic range growth, max size: 2**32
 233 const  unsigned int        maxTopSizeBlocks  = 50;
 234 const  unsigned int        tsbStopper        = 2 * maxTopSizeBlocks;
 235 const  unsigned int        maxHeaps          = 10;
 236 static unsigned int        nHeaps            = 0;
 237 static struct CodeHeapStat CodeHeapStatArray[maxHeaps];
 238 
 239 // static struct StatElement *StatArray      = NULL;
 240 static StatElement* StatArray             = NULL;
 241 static int          log2_seg_size         = 0;
 242 static size_t       seg_size              = 0;
 243 static size_t       alloc_granules        = 0;
 244 static size_t       granule_size          = 0;
 245 static bool         segment_granules      = false;
 246 static unsigned int nBlocks_t1            = 0;  // counting &quot;in_use&quot; nmethods only.
 247 static unsigned int nBlocks_t2            = 0;  // counting &quot;in_use&quot; nmethods only.
 248 static unsigned int nBlocks_alive         = 0;  // counting &quot;not_used&quot; and &quot;not_entrant&quot; nmethods only.
 249 static unsigned int nBlocks_dead          = 0;  // counting &quot;zombie&quot; and &quot;unloaded&quot; methods only.
 250 static unsigned int nBlocks_inconstr      = 0;  // counting &quot;inconstruction&quot; nmethods only. This is a transient state.
 251 static unsigned int nBlocks_unloaded      = 0;  // counting &quot;unloaded&quot; nmethods only. This is a transient state.
 252 static unsigned int nBlocks_stub          = 0;
 253 
 254 static struct FreeBlk*          FreeArray = NULL;
 255 static unsigned int      alloc_freeBlocks = 0;
 256 
 257 static struct TopSizeBlk*    TopSizeArray = NULL;
 258 static unsigned int   alloc_topSizeBlocks = 0;
 259 static unsigned int    used_topSizeBlocks = 0;
 260 
 261 static struct SizeDistributionElement*  SizeDistributionArray = NULL;
 262 
 263 // nMethod temperature (hotness) indicators.
 264 static int                     avgTemp    = 0;
 265 static int                     maxTemp    = 0;
 266 static int                     minTemp    = 0;
 267 
 268 static unsigned int  latest_compilation_id   = 0;
 269 static volatile bool initialization_complete = false;
 270 
 271 const char* CodeHeapState::get_heapName(CodeHeap* heap) {
 272   if (SegmentedCodeCache) {
 273     return heap-&gt;name();
 274   } else {
 275     return &quot;CodeHeap&quot;;
 276   }
 277 }
 278 
 279 // returns the index for the heap being processed.
 280 unsigned int CodeHeapState::findHeapIndex(outputStream* out, const char* heapName) {
 281   if (heapName == NULL) {
 282     return maxHeaps;
 283   }
 284   if (SegmentedCodeCache) {
 285     // Search for a pre-existing entry. If found, return that index.
 286     for (unsigned int i = 0; i &lt; nHeaps; i++) {
 287       if (CodeHeapStatArray[i].heapName != NULL &amp;&amp; strcmp(heapName, CodeHeapStatArray[i].heapName) == 0) {
 288         return i;
 289       }
 290     }
 291 
 292     // check if there are more code heap segments than we can handle.
 293     if (nHeaps == maxHeaps) {
 294       out-&gt;print_cr(&quot;Too many heap segments for current limit(%d).&quot;, maxHeaps);
 295       return maxHeaps;
 296     }
 297 
 298     // allocate new slot in StatArray.
 299     CodeHeapStatArray[nHeaps].heapName = heapName;
 300     return nHeaps++;
 301   } else {
 302     nHeaps = 1;
 303     CodeHeapStatArray[0].heapName = heapName;
 304     return 0; // This is the default index if CodeCache is not segmented.
 305   }
 306 }
 307 
 308 void CodeHeapState::get_HeapStatGlobals(outputStream* out, const char* heapName) {
 309   unsigned int ix = findHeapIndex(out, heapName);
 310   if (ix &lt; maxHeaps) {
 311     StatArray             = CodeHeapStatArray[ix].StatArray;
 312     seg_size              = CodeHeapStatArray[ix].segment_size;
 313     log2_seg_size         = seg_size == 0 ? 0 : exact_log2(seg_size);
 314     alloc_granules        = CodeHeapStatArray[ix].alloc_granules;
 315     granule_size          = CodeHeapStatArray[ix].granule_size;
 316     segment_granules      = CodeHeapStatArray[ix].segment_granules;
 317     nBlocks_t1            = CodeHeapStatArray[ix].nBlocks_t1;
 318     nBlocks_t2            = CodeHeapStatArray[ix].nBlocks_t2;
 319     nBlocks_alive         = CodeHeapStatArray[ix].nBlocks_alive;
 320     nBlocks_dead          = CodeHeapStatArray[ix].nBlocks_dead;
 321     nBlocks_inconstr      = CodeHeapStatArray[ix].nBlocks_inconstr;
 322     nBlocks_unloaded      = CodeHeapStatArray[ix].nBlocks_unloaded;
 323     nBlocks_stub          = CodeHeapStatArray[ix].nBlocks_stub;
 324     FreeArray             = CodeHeapStatArray[ix].FreeArray;
 325     alloc_freeBlocks      = CodeHeapStatArray[ix].alloc_freeBlocks;
 326     TopSizeArray          = CodeHeapStatArray[ix].TopSizeArray;
 327     alloc_topSizeBlocks   = CodeHeapStatArray[ix].alloc_topSizeBlocks;
 328     used_topSizeBlocks    = CodeHeapStatArray[ix].used_topSizeBlocks;
 329     SizeDistributionArray = CodeHeapStatArray[ix].SizeDistributionArray;
 330     avgTemp               = CodeHeapStatArray[ix].avgTemp;
 331     maxTemp               = CodeHeapStatArray[ix].maxTemp;
 332     minTemp               = CodeHeapStatArray[ix].minTemp;
 333   } else {
 334     StatArray             = NULL;
 335     seg_size              = 0;
 336     log2_seg_size         = 0;
 337     alloc_granules        = 0;
 338     granule_size          = 0;
 339     segment_granules      = false;
 340     nBlocks_t1            = 0;
 341     nBlocks_t2            = 0;
 342     nBlocks_alive         = 0;
 343     nBlocks_dead          = 0;
 344     nBlocks_inconstr      = 0;
 345     nBlocks_unloaded      = 0;
 346     nBlocks_stub          = 0;
 347     FreeArray             = NULL;
 348     alloc_freeBlocks      = 0;
 349     TopSizeArray          = NULL;
 350     alloc_topSizeBlocks   = 0;
 351     used_topSizeBlocks    = 0;
 352     SizeDistributionArray = NULL;
 353     avgTemp               = 0;
 354     maxTemp               = 0;
 355     minTemp               = 0;
 356   }
 357 }
 358 
 359 void CodeHeapState::set_HeapStatGlobals(outputStream* out, const char* heapName) {
 360   unsigned int ix = findHeapIndex(out, heapName);
 361   if (ix &lt; maxHeaps) {
 362     CodeHeapStatArray[ix].StatArray             = StatArray;
 363     CodeHeapStatArray[ix].segment_size          = seg_size;
 364     CodeHeapStatArray[ix].alloc_granules        = alloc_granules;
 365     CodeHeapStatArray[ix].granule_size          = granule_size;
 366     CodeHeapStatArray[ix].segment_granules      = segment_granules;
 367     CodeHeapStatArray[ix].nBlocks_t1            = nBlocks_t1;
 368     CodeHeapStatArray[ix].nBlocks_t2            = nBlocks_t2;
 369     CodeHeapStatArray[ix].nBlocks_alive         = nBlocks_alive;
 370     CodeHeapStatArray[ix].nBlocks_dead          = nBlocks_dead;
 371     CodeHeapStatArray[ix].nBlocks_inconstr      = nBlocks_inconstr;
 372     CodeHeapStatArray[ix].nBlocks_unloaded      = nBlocks_unloaded;
 373     CodeHeapStatArray[ix].nBlocks_stub          = nBlocks_stub;
 374     CodeHeapStatArray[ix].FreeArray             = FreeArray;
 375     CodeHeapStatArray[ix].alloc_freeBlocks      = alloc_freeBlocks;
 376     CodeHeapStatArray[ix].TopSizeArray          = TopSizeArray;
 377     CodeHeapStatArray[ix].alloc_topSizeBlocks   = alloc_topSizeBlocks;
 378     CodeHeapStatArray[ix].used_topSizeBlocks    = used_topSizeBlocks;
 379     CodeHeapStatArray[ix].SizeDistributionArray = SizeDistributionArray;
 380     CodeHeapStatArray[ix].avgTemp               = avgTemp;
 381     CodeHeapStatArray[ix].maxTemp               = maxTemp;
 382     CodeHeapStatArray[ix].minTemp               = minTemp;
 383   }
 384 }
 385 
 386 //---&lt;  get a new statistics array  &gt;---
 387 void CodeHeapState::prepare_StatArray(outputStream* out, size_t nElem, size_t granularity, const char* heapName) {
 388   if (StatArray == NULL) {
 389     StatArray      = new StatElement[nElem];
 390     //---&lt;  reset some counts  &gt;---
 391     alloc_granules = nElem;
 392     granule_size   = granularity;
 393   }
 394 
 395   if (StatArray == NULL) {
 396     //---&lt;  just do nothing if allocation failed  &gt;---
 397     out-&gt;print_cr(&quot;Statistics could not be collected for %s, probably out of memory.&quot;, heapName);
 398     out-&gt;print_cr(&quot;Current granularity is &quot; SIZE_FORMAT &quot; bytes. Try a coarser granularity.&quot;, granularity);
 399     alloc_granules = 0;
 400     granule_size   = 0;
 401   } else {
 402     //---&lt;  initialize statistics array  &gt;---
 403     memset((void*)StatArray, 0, nElem*sizeof(StatElement));
 404   }
 405 }
 406 
 407 //---&lt;  get a new free block array  &gt;---
 408 void CodeHeapState::prepare_FreeArray(outputStream* out, unsigned int nElem, const char* heapName) {
 409   if (FreeArray == NULL) {
 410     FreeArray      = new FreeBlk[nElem];
 411     //---&lt;  reset some counts  &gt;---
 412     alloc_freeBlocks = nElem;
 413   }
 414 
 415   if (FreeArray == NULL) {
 416     //---&lt;  just do nothing if allocation failed  &gt;---
 417     out-&gt;print_cr(&quot;Free space analysis cannot be done for %s, probably out of memory.&quot;, heapName);
 418     alloc_freeBlocks = 0;
 419   } else {
 420     //---&lt;  initialize free block array  &gt;---
 421     memset((void*)FreeArray, 0, alloc_freeBlocks*sizeof(FreeBlk));
 422   }
 423 }
 424 
 425 //---&lt;  get a new TopSizeArray  &gt;---
 426 void CodeHeapState::prepare_TopSizeArray(outputStream* out, unsigned int nElem, const char* heapName) {
 427   if (TopSizeArray == NULL) {
 428     TopSizeArray   = new TopSizeBlk[nElem];
 429     //---&lt;  reset some counts  &gt;---
 430     alloc_topSizeBlocks = nElem;
 431     used_topSizeBlocks  = 0;
 432   }
 433 
 434   if (TopSizeArray == NULL) {
 435     //---&lt;  just do nothing if allocation failed  &gt;---
 436     out-&gt;print_cr(&quot;Top-%d list of largest CodeHeap blocks can not be collected for %s, probably out of memory.&quot;, nElem, heapName);
 437     alloc_topSizeBlocks = 0;
 438   } else {
 439     //---&lt;  initialize TopSizeArray  &gt;---
 440     memset((void*)TopSizeArray, 0, nElem*sizeof(TopSizeBlk));
 441     used_topSizeBlocks  = 0;
 442   }
 443 }
 444 
 445 //---&lt;  get a new SizeDistributionArray  &gt;---
 446 void CodeHeapState::prepare_SizeDistArray(outputStream* out, unsigned int nElem, const char* heapName) {
 447   if (SizeDistributionArray == NULL) {
 448     SizeDistributionArray = new SizeDistributionElement[nElem];
 449   }
 450 
 451   if (SizeDistributionArray == NULL) {
 452     //---&lt;  just do nothing if allocation failed  &gt;---
 453     out-&gt;print_cr(&quot;Size distribution can not be collected for %s, probably out of memory.&quot;, heapName);
 454   } else {
 455     //---&lt;  initialize SizeDistArray  &gt;---
 456     memset((void*)SizeDistributionArray, 0, nElem*sizeof(SizeDistributionElement));
 457     // Logarithmic range growth. First range starts at _segment_size.
 458     SizeDistributionArray[log2_seg_size-1].rangeEnd = 1U;
 459     for (unsigned int i = log2_seg_size; i &lt; nElem; i++) {
 460       SizeDistributionArray[i].rangeStart = 1U &lt;&lt; (i     - log2_seg_size);
 461       SizeDistributionArray[i].rangeEnd   = 1U &lt;&lt; ((i+1) - log2_seg_size);
 462     }
 463   }
 464 }
 465 
 466 //---&lt;  get a new SizeDistributionArray  &gt;---
 467 void CodeHeapState::update_SizeDistArray(outputStream* out, unsigned int len) {
 468   if (SizeDistributionArray != NULL) {
 469     for (unsigned int i = log2_seg_size-1; i &lt; nSizeDistElements; i++) {
 470       if ((SizeDistributionArray[i].rangeStart &lt;= len) &amp;&amp; (len &lt; SizeDistributionArray[i].rangeEnd)) {
 471         SizeDistributionArray[i].lenSum += len;
 472         SizeDistributionArray[i].count++;
 473         break;
 474       }
 475     }
 476   }
 477 }
 478 
 479 void CodeHeapState::discard_StatArray(outputStream* out) {
 480   if (StatArray != NULL) {
 481     delete StatArray;
 482     StatArray        = NULL;
 483     alloc_granules   = 0;
 484     granule_size     = 0;
 485   }
 486 }
 487 
 488 void CodeHeapState::discard_FreeArray(outputStream* out) {
 489   if (FreeArray != NULL) {
 490     delete[] FreeArray;
 491     FreeArray        = NULL;
 492     alloc_freeBlocks = 0;
 493   }
 494 }
 495 
 496 void CodeHeapState::discard_TopSizeArray(outputStream* out) {
 497   if (TopSizeArray != NULL) {
 498     delete[] TopSizeArray;
 499     TopSizeArray        = NULL;
 500     alloc_topSizeBlocks = 0;
 501     used_topSizeBlocks  = 0;
 502   }
 503 }
 504 
 505 void CodeHeapState::discard_SizeDistArray(outputStream* out) {
 506   if (SizeDistributionArray != NULL) {
 507     delete[] SizeDistributionArray;
 508     SizeDistributionArray = NULL;
 509   }
 510 }
 511 
 512 // Discard all allocated internal data structures.
 513 // This should be done after an analysis session is completed.
 514 void CodeHeapState::discard(outputStream* out, CodeHeap* heap) {
 515   if (!initialization_complete) {
 516     return;
 517   }
 518 
 519   if (nHeaps &gt; 0) {
 520     for (unsigned int ix = 0; ix &lt; nHeaps; ix++) {
 521       get_HeapStatGlobals(out, CodeHeapStatArray[ix].heapName);
 522       discard_StatArray(out);
 523       discard_FreeArray(out);
 524       discard_TopSizeArray(out);
 525       discard_SizeDistArray(out);
 526       set_HeapStatGlobals(out, CodeHeapStatArray[ix].heapName);
 527       CodeHeapStatArray[ix].heapName = NULL;
 528     }
 529     nHeaps = 0;
 530   }
 531 }
 532 
 533 void CodeHeapState::aggregate(outputStream* out, CodeHeap* heap, const char* granularity_request) {
 534   unsigned int nBlocks_free    = 0;
 535   unsigned int nBlocks_used    = 0;
 536   unsigned int nBlocks_zomb    = 0;
 537   unsigned int nBlocks_disconn = 0;
 538   unsigned int nBlocks_notentr = 0;
 539 
 540   //---&lt;  max &amp; min of TopSizeArray  &gt;---
 541   //  it is sufficient to have these sizes as 32bit unsigned ints.
 542   //  The CodeHeap is limited in size to 4GB. Furthermore, the sizes
 543   //  are stored in _segment_size units, scaling them down by a factor of 64 (at least).
 544   unsigned int  currMax          = 0;
 545   unsigned int  currMin          = 0;
 546   unsigned int  currMin_ix       = 0;
 547   unsigned long total_iterations = 0;
 548 
 549   bool  done             = false;
 550   const int min_granules = 256;
 551   const int max_granules = 512*K; // limits analyzable CodeHeap (with segment_granules) to 32M..128M
 552                                   // results in StatArray size of 24M (= max_granules * 48 Bytes per element)
 553                                   // For a 1GB CodeHeap, the granule size must be at least 2kB to not violate the max_granles limit.
 554   const char* heapName   = get_heapName(heap);
 555   BUFFEREDSTREAM_DECL(ast, out)
 556 
 557   if (!initialization_complete) {
 558     memset(CodeHeapStatArray, 0, sizeof(CodeHeapStatArray));
 559     initialization_complete = true;
 560 
 561     printBox(ast, &#39;=&#39;, &quot;C O D E   H E A P   A N A L Y S I S   (general remarks)&quot;, NULL);
 562     ast-&gt;print_cr(&quot;   The code heap analysis function provides deep insights into\n&quot;
 563                   &quot;   the inner workings and the internal state of the Java VM&#39;s\n&quot;
 564                   &quot;   code cache - the place where all the JVM generated machine\n&quot;
 565                   &quot;   code is stored.\n&quot;
 566                   &quot;   \n&quot;
 567                   &quot;   This function is designed and provided for support engineers\n&quot;
 568                   &quot;   to help them understand and solve issues in customer systems.\n&quot;
 569                   &quot;   It is not intended for use and interpretation by other persons.\n&quot;
 570                   &quot;   \n&quot;);
 571     BUFFEREDSTREAM_FLUSH(&quot;&quot;)
 572   }
 573   get_HeapStatGlobals(out, heapName);
 574 
 575 
 576   // Since we are (and must be) analyzing the CodeHeap contents under the CodeCache_lock,
 577   // all heap information is &quot;constant&quot; and can be safely extracted/calculated before we
 578   // enter the while() loop. Actually, the loop will only be iterated once.
 579   char*  low_bound     = heap-&gt;low_boundary();
 580   size_t size          = heap-&gt;capacity();
 581   size_t res_size      = heap-&gt;max_capacity();
 582   seg_size             = heap-&gt;segment_size();
 583   log2_seg_size        = seg_size == 0 ? 0 : exact_log2(seg_size);  // This is a global static value.
 584 
 585   if (seg_size == 0) {
 586     printBox(ast, &#39;-&#39;, &quot;Heap not fully initialized yet, segment size is zero for segment &quot;, heapName);
 587     BUFFEREDSTREAM_FLUSH(&quot;&quot;)
 588     return;
 589   }
 590 
 591   if (!CodeCache_lock-&gt;owned_by_self()) {
 592     printBox(ast, &#39;-&#39;, &quot;aggregate function called without holding the CodeCache_lock for &quot;, heapName);
 593     BUFFEREDSTREAM_FLUSH(&quot;&quot;)
 594     return;
 595   }
 596 
 597   // Calculate granularity of analysis (and output).
 598   //   The CodeHeap is managed (allocated) in segments (units) of CodeCacheSegmentSize.
 599   //   The CodeHeap can become fairly large, in particular in productive real-life systems.
 600   //
 601   //   It is often neither feasible nor desirable to aggregate the data with the highest possible
 602   //   level of detail, i.e. inspecting and printing each segment on its own.
 603   //
 604   //   The granularity parameter allows to specify the level of detail available in the analysis.
 605   //   It must be a positive multiple of the segment size and should be selected such that enough
 606   //   detail is provided while, at the same time, the printed output does not explode.
 607   //
 608   //   By manipulating the granularity value, we enforce that at least min_granules units
 609   //   of analysis are available. We also enforce an upper limit of max_granules units to
 610   //   keep the amount of allocated storage in check.
 611   //
 612   //   Finally, we adjust the granularity such that each granule covers at most 64k-1 segments.
 613   //   This is necessary to prevent an unsigned short overflow while accumulating space information.
 614   //
 615   size_t granularity = strtol(granularity_request, NULL, 0);
 616   if (granularity &gt; size) {
 617     granularity = size;
 618   }
 619   if (size/granularity &lt; min_granules) {
 620     granularity = size/min_granules;                                   // at least min_granules granules
 621   }
 622   granularity = granularity &amp; (~(seg_size - 1));                       // must be multiple of seg_size
 623   if (granularity &lt; seg_size) {
 624     granularity = seg_size;                                            // must be at least seg_size
 625   }
 626   if (size/granularity &gt; max_granules) {
 627     granularity = size/max_granules;                                   // at most max_granules granules
 628   }
 629   granularity = granularity &amp; (~(seg_size - 1));                       // must be multiple of seg_size
 630   if (granularity&gt;&gt;log2_seg_size &gt;= (1L&lt;&lt;sizeof(unsigned short)*8)) {
 631     granularity = ((1L&lt;&lt;(sizeof(unsigned short)*8))-1)&lt;&lt;log2_seg_size; // Limit: (64k-1) * seg_size
 632   }
 633   segment_granules = granularity == seg_size;
 634   size_t granules  = (size + (granularity-1))/granularity;
 635 
 636   printBox(ast, &#39;=&#39;, &quot;C O D E   H E A P   A N A L Y S I S   (used blocks) for segment &quot;, heapName);
 637   ast-&gt;print_cr(&quot;   The aggregate step takes an aggregated snapshot of the CodeHeap.\n&quot;
 638                 &quot;   Subsequent print functions create their output based on this snapshot.\n&quot;
 639                 &quot;   The CodeHeap is a living thing, and every effort has been made for the\n&quot;
 640                 &quot;   collected data to be consistent. Only the method names and signatures\n&quot;
 641                 &quot;   are retrieved at print time. That may lead to rare cases where the\n&quot;
 642                 &quot;   name of a method is no longer available, e.g. because it was unloaded.\n&quot;);
 643   ast-&gt;print_cr(&quot;   CodeHeap committed size &quot; SIZE_FORMAT &quot;K (&quot; SIZE_FORMAT &quot;M), reserved size &quot; SIZE_FORMAT &quot;K (&quot; SIZE_FORMAT &quot;M), %d%% occupied.&quot;,
 644                 size/(size_t)K, size/(size_t)M, res_size/(size_t)K, res_size/(size_t)M, (unsigned int)(100.0*size/res_size));
 645   ast-&gt;print_cr(&quot;   CodeHeap allocation segment size is &quot; SIZE_FORMAT &quot; bytes. This is the smallest possible granularity.&quot;, seg_size);
 646   ast-&gt;print_cr(&quot;   CodeHeap (committed part) is mapped to &quot; SIZE_FORMAT &quot; granules of size &quot; SIZE_FORMAT &quot; bytes.&quot;, granules, granularity);
 647   ast-&gt;print_cr(&quot;   Each granule takes &quot; SIZE_FORMAT &quot; bytes of C heap, that is &quot; SIZE_FORMAT &quot;K in total for statistics data.&quot;, sizeof(StatElement), (sizeof(StatElement)*granules)/(size_t)K);
 648   ast-&gt;print_cr(&quot;   The number of granules is limited to %dk, requiring a granules size of at least %d bytes for a 1GB heap.&quot;, (unsigned int)(max_granules/K), (unsigned int)(G/max_granules));
 649   BUFFEREDSTREAM_FLUSH(&quot;\n&quot;)
 650 
 651 
 652   while (!done) {
 653     //---&lt;  reset counters with every aggregation  &gt;---
 654     nBlocks_t1       = 0;
 655     nBlocks_t2       = 0;
 656     nBlocks_alive    = 0;
 657     nBlocks_dead     = 0;
 658     nBlocks_inconstr = 0;
 659     nBlocks_unloaded = 0;
 660     nBlocks_stub     = 0;
 661 
 662     nBlocks_free     = 0;
 663     nBlocks_used     = 0;
 664     nBlocks_zomb     = 0;
 665     nBlocks_disconn  = 0;
 666     nBlocks_notentr  = 0;
 667 
 668     //---&lt;  discard old arrays if size does not match  &gt;---
 669     if (granules != alloc_granules) {
 670       discard_StatArray(out);
 671       discard_TopSizeArray(out);
 672     }
 673 
 674     //---&lt;  allocate arrays if they don&#39;t yet exist, initialize  &gt;---
 675     prepare_StatArray(out, granules, granularity, heapName);
 676     if (StatArray == NULL) {
 677       set_HeapStatGlobals(out, heapName);
 678       return;
 679     }
 680     prepare_TopSizeArray(out, maxTopSizeBlocks, heapName);
 681     prepare_SizeDistArray(out, nSizeDistElements, heapName);
 682 
 683     latest_compilation_id = CompileBroker::get_compilation_id();
 684     unsigned int highest_compilation_id = 0;
 685     size_t       usedSpace     = 0;
 686     size_t       t1Space       = 0;
 687     size_t       t2Space       = 0;
 688     size_t       aliveSpace    = 0;
 689     size_t       disconnSpace  = 0;
 690     size_t       notentrSpace  = 0;
 691     size_t       deadSpace     = 0;
 692     size_t       inconstrSpace = 0;
 693     size_t       unloadedSpace = 0;
 694     size_t       stubSpace     = 0;
 695     size_t       freeSpace     = 0;
 696     size_t       maxFreeSize   = 0;
 697     HeapBlock*   maxFreeBlock  = NULL;
 698     bool         insane        = false;
 699 
 700     int64_t hotnessAccumulator = 0;
 701     unsigned int n_methods     = 0;
 702     avgTemp       = 0;
 703     minTemp       = (int)(res_size &gt; M ? (res_size/M)*2 : 1);
 704     maxTemp       = -minTemp;
 705 
 706     for (HeapBlock *h = heap-&gt;first_block(); h != NULL &amp;&amp; !insane; h = heap-&gt;next_block(h)) {
 707       unsigned int hb_len     = (unsigned int)h-&gt;length();  // despite being size_t, length can never overflow an unsigned int.
 708       size_t       hb_bytelen = ((size_t)hb_len)&lt;&lt;log2_seg_size;
 709       unsigned int ix_beg     = (unsigned int)(((char*)h-low_bound)/granule_size);
 710       unsigned int ix_end     = (unsigned int)(((char*)h-low_bound+(hb_bytelen-1))/granule_size);
 711       unsigned int compile_id = 0;
 712       CompLevel    comp_lvl   = CompLevel_none;
 713       compType     cType      = noComp;
 714       blobType     cbType     = noType;
 715 
 716       //---&lt;  some sanity checks  &gt;---
 717       // Do not assert here, just check, print error message and return.
 718       // This is a diagnostic function. It is not supposed to tear down the VM.
 719       if ((char*)h &lt;  low_bound) {
 720         insane = true; ast-&gt;print_cr(&quot;Sanity check: HeapBlock @%p below low bound (%p)&quot;, (char*)h, low_bound);
 721       }
 722       if ((char*)h &gt;  (low_bound + res_size)) {
 723         insane = true; ast-&gt;print_cr(&quot;Sanity check: HeapBlock @%p outside reserved range (%p)&quot;, (char*)h, low_bound + res_size);
 724       }
 725       if ((char*)h &gt;  (low_bound + size)) {
 726         insane = true; ast-&gt;print_cr(&quot;Sanity check: HeapBlock @%p outside used range (%p)&quot;, (char*)h, low_bound + size);
 727       }
 728       if (ix_end   &gt;= granules) {
 729         insane = true; ast-&gt;print_cr(&quot;Sanity check: end index (%d) out of bounds (&quot; SIZE_FORMAT &quot;)&quot;, ix_end, granules);
 730       }
 731       if (size     != heap-&gt;capacity()) {
 732         insane = true; ast-&gt;print_cr(&quot;Sanity check: code heap capacity has changed (&quot; SIZE_FORMAT &quot;K to &quot; SIZE_FORMAT &quot;K)&quot;, size/(size_t)K, heap-&gt;capacity()/(size_t)K);
 733       }
 734       if (ix_beg   &gt;  ix_end) {
 735         insane = true; ast-&gt;print_cr(&quot;Sanity check: end index (%d) lower than begin index (%d)&quot;, ix_end, ix_beg);
 736       }
 737       if (insane) {
 738         BUFFEREDSTREAM_FLUSH(&quot;&quot;)
 739         continue;
 740       }
 741 
 742       if (h-&gt;free()) {
 743         nBlocks_free++;
 744         freeSpace    += hb_bytelen;
 745         if (hb_bytelen &gt; maxFreeSize) {
 746           maxFreeSize   = hb_bytelen;
 747           maxFreeBlock  = h;
 748         }
 749       } else {
 750         update_SizeDistArray(out, hb_len);
 751         nBlocks_used++;
 752         usedSpace    += hb_bytelen;
 753         CodeBlob* cb  = (CodeBlob*)heap-&gt;find_start(h);
 754         if (cb != NULL) {
 755           cbType = get_cbType(cb);
 756           if (cb-&gt;is_nmethod()) {
 757             compile_id = ((nmethod*)cb)-&gt;compile_id();
 758             comp_lvl   = (CompLevel)((nmethod*)cb)-&gt;comp_level();
 759             if (((nmethod*)cb)-&gt;is_compiled_by_c1()) {
 760               cType = c1;
 761             }
 762             if (((nmethod*)cb)-&gt;is_compiled_by_c2()) {
 763               cType = c2;
 764             }
 765             if (((nmethod*)cb)-&gt;is_compiled_by_jvmci()) {
 766               cType = jvmci;
 767             }
 768             switch (cbType) {
 769               case nMethod_inuse: { // only for executable methods!!!
 770                 // space for these cbs is accounted for later.
 771                 int temperature = ((nmethod*)cb)-&gt;hotness_counter();
 772                 hotnessAccumulator += temperature;
 773                 n_methods++;
 774                 maxTemp = (temperature &gt; maxTemp) ? temperature : maxTemp;
 775                 minTemp = (temperature &lt; minTemp) ? temperature : minTemp;
 776                 break;
 777               }
 778               case nMethod_notused:
 779                 nBlocks_alive++;
 780                 nBlocks_disconn++;
 781                 aliveSpace     += hb_bytelen;
 782                 disconnSpace   += hb_bytelen;
 783                 break;
 784               case nMethod_notentrant:  // equivalent to nMethod_alive
 785                 nBlocks_alive++;
 786                 nBlocks_notentr++;
 787                 aliveSpace     += hb_bytelen;
 788                 notentrSpace   += hb_bytelen;
 789                 break;
 790               case nMethod_unloaded:
 791                 nBlocks_unloaded++;
 792                 unloadedSpace  += hb_bytelen;
 793                 break;
 794               case nMethod_dead:
 795                 nBlocks_dead++;
 796                 deadSpace      += hb_bytelen;
 797                 break;
 798               case nMethod_inconstruction:
 799                 nBlocks_inconstr++;
 800                 inconstrSpace  += hb_bytelen;
 801                 break;
 802               default:
 803                 break;
 804             }
 805           }
 806 
 807           //------------------------------------------
 808           //---&lt;  register block in TopSizeArray  &gt;---
 809           //------------------------------------------
 810           if (alloc_topSizeBlocks &gt; 0) {
 811             if (used_topSizeBlocks == 0) {
 812               TopSizeArray[0].start    = h;
 813               TopSizeArray[0].len      = hb_len;
 814               TopSizeArray[0].index    = tsbStopper;
 815               TopSizeArray[0].compiler = cType;
 816               TopSizeArray[0].level    = comp_lvl;
 817               TopSizeArray[0].type     = cbType;
 818               currMax    = hb_len;
 819               currMin    = hb_len;
 820               currMin_ix = 0;
 821               used_topSizeBlocks++;
 822             // This check roughly cuts 5000 iterations (JVM98, mixed, dbg, termination stats):
 823             } else if ((used_topSizeBlocks &lt; alloc_topSizeBlocks) &amp;&amp; (hb_len &lt; currMin)) {
 824               //---&lt;  all blocks in list are larger, but there is room left in array  &gt;---
 825               TopSizeArray[currMin_ix].index = used_topSizeBlocks;
 826               TopSizeArray[used_topSizeBlocks].start    = h;
 827               TopSizeArray[used_topSizeBlocks].len      = hb_len;
 828               TopSizeArray[used_topSizeBlocks].index    = tsbStopper;
 829               TopSizeArray[used_topSizeBlocks].compiler = cType;
 830               TopSizeArray[used_topSizeBlocks].level    = comp_lvl;
 831               TopSizeArray[used_topSizeBlocks].type     = cbType;
 832               currMin    = hb_len;
 833               currMin_ix = used_topSizeBlocks;
 834               used_topSizeBlocks++;
 835             } else {
 836               // This check cuts total_iterations by a factor of 6 (JVM98, mixed, dbg, termination stats):
 837               //   We don&#39;t need to search the list if we know beforehand that the current block size is
 838               //   smaller than the currently recorded minimum and there is no free entry left in the list.
 839               if (!((used_topSizeBlocks == alloc_topSizeBlocks) &amp;&amp; (hb_len &lt;= currMin))) {
 840                 if (currMax &lt; hb_len) {
 841                   currMax = hb_len;
 842                 }
 843                 unsigned int i;
 844                 unsigned int prev_i  = tsbStopper;
 845                 unsigned int limit_i =  0;
 846                 for (i = 0; i != tsbStopper; i = TopSizeArray[i].index) {
 847                   if (limit_i++ &gt;= alloc_topSizeBlocks) {
 848                     insane = true; break; // emergency exit
 849                   }
 850                   if (i &gt;= used_topSizeBlocks)  {
 851                     insane = true; break; // emergency exit
 852                   }
 853                   total_iterations++;
 854                   if (TopSizeArray[i].len &lt; hb_len) {
 855                     //---&lt;  We want to insert here, element &lt;i&gt; is smaller than the current one  &gt;---
 856                     if (used_topSizeBlocks &lt; alloc_topSizeBlocks) { // still room for a new entry to insert
 857                       // old entry gets moved to the next free element of the array.
 858                       // That&#39;s necessary to keep the entry for the largest block at index 0.
 859                       // This move might cause the current minimum to be moved to another place
 860                       if (i == currMin_ix) {
 861                         assert(TopSizeArray[i].len == currMin, &quot;sort error&quot;);
 862                         currMin_ix = used_topSizeBlocks;
 863                       }
 864                       memcpy((void*)&amp;TopSizeArray[used_topSizeBlocks], (void*)&amp;TopSizeArray[i], sizeof(TopSizeBlk));
 865                       TopSizeArray[i].start    = h;
 866                       TopSizeArray[i].len      = hb_len;
 867                       TopSizeArray[i].index    = used_topSizeBlocks;
 868                       TopSizeArray[i].compiler = cType;
 869                       TopSizeArray[i].level    = comp_lvl;
 870                       TopSizeArray[i].type     = cbType;
 871                       used_topSizeBlocks++;
 872                     } else { // no room for new entries, current block replaces entry for smallest block
 873                       //---&lt;  Find last entry (entry for smallest remembered block)  &gt;---
 874                       unsigned int      j  = i;
 875                       unsigned int prev_j  = tsbStopper;
 876                       unsigned int limit_j = 0;
 877                       while (TopSizeArray[j].index != tsbStopper) {
 878                         if (limit_j++ &gt;= alloc_topSizeBlocks) {
 879                           insane = true; break; // emergency exit
 880                         }
 881                         if (j &gt;= used_topSizeBlocks)  {
 882                           insane = true; break; // emergency exit
 883                         }
 884                         total_iterations++;
 885                         prev_j = j;
 886                         j      = TopSizeArray[j].index;
 887                       }
 888                       if (!insane) {
 889                         if (prev_j == tsbStopper) {
 890                           //---&lt;  Above while loop did not iterate, we already are the min entry  &gt;---
 891                           //---&lt;  We have to just replace the smallest entry                      &gt;---
 892                           currMin    = hb_len;
 893                           currMin_ix = j;
 894                           TopSizeArray[j].start    = h;
 895                           TopSizeArray[j].len      = hb_len;
 896                           TopSizeArray[j].index    = tsbStopper; // already set!!
 897                           TopSizeArray[j].compiler = cType;
 898                           TopSizeArray[j].level    = comp_lvl;
 899                           TopSizeArray[j].type     = cbType;
 900                         } else {
 901                           //---&lt;  second-smallest entry is now smallest  &gt;---
 902                           TopSizeArray[prev_j].index = tsbStopper;
 903                           currMin    = TopSizeArray[prev_j].len;
 904                           currMin_ix = prev_j;
 905                           //---&lt;  smallest entry gets overwritten  &gt;---
 906                           memcpy((void*)&amp;TopSizeArray[j], (void*)&amp;TopSizeArray[i], sizeof(TopSizeBlk));
 907                           TopSizeArray[i].start    = h;
 908                           TopSizeArray[i].len      = hb_len;
 909                           TopSizeArray[i].index    = j;
 910                           TopSizeArray[i].compiler = cType;
 911                           TopSizeArray[i].level    = comp_lvl;
 912                           TopSizeArray[i].type     = cbType;
 913                         }
 914                       } // insane
 915                     }
 916                     break;
 917                   }
 918                   prev_i = i;
 919                 }
 920                 if (insane) {
 921                   // Note: regular analysis could probably continue by resetting &quot;insane&quot; flag.
 922                   out-&gt;print_cr(&quot;Possible loop in TopSizeBlocks list detected. Analysis aborted.&quot;);
 923                   discard_TopSizeArray(out);
 924                 }
 925               }
 926             }
 927           }
 928           //----------------------------------------------
 929           //---&lt;  END register block in TopSizeArray  &gt;---
 930           //----------------------------------------------
 931         } else {
 932           nBlocks_zomb++;
 933         }
 934 
 935         if (ix_beg == ix_end) {
 936           StatArray[ix_beg].type = cbType;
 937           switch (cbType) {
 938             case nMethod_inuse:
 939               highest_compilation_id = (highest_compilation_id &gt;= compile_id) ? highest_compilation_id : compile_id;
 940               if (comp_lvl &lt; CompLevel_full_optimization) {
 941                 nBlocks_t1++;
 942                 t1Space   += hb_bytelen;
 943                 StatArray[ix_beg].t1_count++;
 944                 StatArray[ix_beg].t1_space += (unsigned short)hb_len;
 945                 StatArray[ix_beg].t1_age    = StatArray[ix_beg].t1_age &lt; compile_id ? compile_id : StatArray[ix_beg].t1_age;
 946               } else {
 947                 nBlocks_t2++;
 948                 t2Space   += hb_bytelen;
 949                 StatArray[ix_beg].t2_count++;
 950                 StatArray[ix_beg].t2_space += (unsigned short)hb_len;
 951                 StatArray[ix_beg].t2_age    = StatArray[ix_beg].t2_age &lt; compile_id ? compile_id : StatArray[ix_beg].t2_age;
 952               }
 953               StatArray[ix_beg].level     = comp_lvl;
 954               StatArray[ix_beg].compiler  = cType;
 955               break;
 956             case nMethod_inconstruction: // let&#39;s count &quot;in construction&quot; nmethods here.
 957             case nMethod_alive:
 958               StatArray[ix_beg].tx_count++;
 959               StatArray[ix_beg].tx_space += (unsigned short)hb_len;
 960               StatArray[ix_beg].tx_age    = StatArray[ix_beg].tx_age &lt; compile_id ? compile_id : StatArray[ix_beg].tx_age;
 961               StatArray[ix_beg].level     = comp_lvl;
 962               StatArray[ix_beg].compiler  = cType;
 963               break;
 964             case nMethod_dead:
 965             case nMethod_unloaded:
 966               StatArray[ix_beg].dead_count++;
 967               StatArray[ix_beg].dead_space += (unsigned short)hb_len;
 968               break;
 969             default:
 970               // must be a stub, if it&#39;s not a dead or alive nMethod
 971               nBlocks_stub++;
 972               stubSpace   += hb_bytelen;
 973               StatArray[ix_beg].stub_count++;
 974               StatArray[ix_beg].stub_space += (unsigned short)hb_len;
 975               break;
 976           }
 977         } else {
 978           unsigned int beg_space = (unsigned int)(granule_size - ((char*)h - low_bound - ix_beg*granule_size));
 979           unsigned int end_space = (unsigned int)(hb_bytelen - beg_space - (ix_end-ix_beg-1)*granule_size);
 980           beg_space = beg_space&gt;&gt;log2_seg_size;  // store in units of _segment_size
 981           end_space = end_space&gt;&gt;log2_seg_size;  // store in units of _segment_size
 982           StatArray[ix_beg].type = cbType;
 983           StatArray[ix_end].type = cbType;
 984           switch (cbType) {
 985             case nMethod_inuse:
 986               highest_compilation_id = (highest_compilation_id &gt;= compile_id) ? highest_compilation_id : compile_id;
 987               if (comp_lvl &lt; CompLevel_full_optimization) {
 988                 nBlocks_t1++;
 989                 t1Space   += hb_bytelen;
 990                 StatArray[ix_beg].t1_count++;
 991                 StatArray[ix_beg].t1_space += (unsigned short)beg_space;
 992                 StatArray[ix_beg].t1_age    = StatArray[ix_beg].t1_age &lt; compile_id ? compile_id : StatArray[ix_beg].t1_age;
 993 
 994                 StatArray[ix_end].t1_count++;
 995                 StatArray[ix_end].t1_space += (unsigned short)end_space;
 996                 StatArray[ix_end].t1_age    = StatArray[ix_end].t1_age &lt; compile_id ? compile_id : StatArray[ix_end].t1_age;
 997               } else {
 998                 nBlocks_t2++;
 999                 t2Space   += hb_bytelen;
1000                 StatArray[ix_beg].t2_count++;
1001                 StatArray[ix_beg].t2_space += (unsigned short)beg_space;
1002                 StatArray[ix_beg].t2_age    = StatArray[ix_beg].t2_age &lt; compile_id ? compile_id : StatArray[ix_beg].t2_age;
1003 
1004                 StatArray[ix_end].t2_count++;
1005                 StatArray[ix_end].t2_space += (unsigned short)end_space;
1006                 StatArray[ix_end].t2_age    = StatArray[ix_end].t2_age &lt; compile_id ? compile_id : StatArray[ix_end].t2_age;
1007               }
1008               StatArray[ix_beg].level     = comp_lvl;
1009               StatArray[ix_beg].compiler  = cType;
1010               StatArray[ix_end].level     = comp_lvl;
1011               StatArray[ix_end].compiler  = cType;
1012               break;
1013             case nMethod_inconstruction: // let&#39;s count &quot;in construction&quot; nmethods here.
1014             case nMethod_alive:
1015               StatArray[ix_beg].tx_count++;
1016               StatArray[ix_beg].tx_space += (unsigned short)beg_space;
1017               StatArray[ix_beg].tx_age    = StatArray[ix_beg].tx_age &lt; compile_id ? compile_id : StatArray[ix_beg].tx_age;
1018 
1019               StatArray[ix_end].tx_count++;
1020               StatArray[ix_end].tx_space += (unsigned short)end_space;
1021               StatArray[ix_end].tx_age    = StatArray[ix_end].tx_age &lt; compile_id ? compile_id : StatArray[ix_end].tx_age;
1022 
1023               StatArray[ix_beg].level     = comp_lvl;
1024               StatArray[ix_beg].compiler  = cType;
1025               StatArray[ix_end].level     = comp_lvl;
1026               StatArray[ix_end].compiler  = cType;
1027               break;
1028             case nMethod_dead:
1029             case nMethod_unloaded:
1030               StatArray[ix_beg].dead_count++;
1031               StatArray[ix_beg].dead_space += (unsigned short)beg_space;
1032               StatArray[ix_end].dead_count++;
1033               StatArray[ix_end].dead_space += (unsigned short)end_space;
1034               break;
1035             default:
1036               // must be a stub, if it&#39;s not a dead or alive nMethod
1037               nBlocks_stub++;
1038               stubSpace   += hb_bytelen;
1039               StatArray[ix_beg].stub_count++;
1040               StatArray[ix_beg].stub_space += (unsigned short)beg_space;
1041               StatArray[ix_end].stub_count++;
1042               StatArray[ix_end].stub_space += (unsigned short)end_space;
1043               break;
1044           }
1045           for (unsigned int ix = ix_beg+1; ix &lt; ix_end; ix++) {
1046             StatArray[ix].type = cbType;
1047             switch (cbType) {
1048               case nMethod_inuse:
1049                 if (comp_lvl &lt; CompLevel_full_optimization) {
1050                   StatArray[ix].t1_count++;
1051                   StatArray[ix].t1_space += (unsigned short)(granule_size&gt;&gt;log2_seg_size);
1052                   StatArray[ix].t1_age    = StatArray[ix].t1_age &lt; compile_id ? compile_id : StatArray[ix].t1_age;
1053                 } else {
1054                   StatArray[ix].t2_count++;
1055                   StatArray[ix].t2_space += (unsigned short)(granule_size&gt;&gt;log2_seg_size);
1056                   StatArray[ix].t2_age    = StatArray[ix].t2_age &lt; compile_id ? compile_id : StatArray[ix].t2_age;
1057                 }
1058                 StatArray[ix].level     = comp_lvl;
1059                 StatArray[ix].compiler  = cType;
1060                 break;
1061               case nMethod_inconstruction: // let&#39;s count &quot;in construction&quot; nmethods here.
1062               case nMethod_alive:
1063                 StatArray[ix].tx_count++;
1064                 StatArray[ix].tx_space += (unsigned short)(granule_size&gt;&gt;log2_seg_size);
1065                 StatArray[ix].tx_age    = StatArray[ix].tx_age &lt; compile_id ? compile_id : StatArray[ix].tx_age;
1066                 StatArray[ix].level     = comp_lvl;
1067                 StatArray[ix].compiler  = cType;
1068                 break;
1069               case nMethod_dead:
1070               case nMethod_unloaded:
1071                 StatArray[ix].dead_count++;
1072                 StatArray[ix].dead_space += (unsigned short)(granule_size&gt;&gt;log2_seg_size);
1073                 break;
1074               default:
1075                 // must be a stub, if it&#39;s not a dead or alive nMethod
1076                 StatArray[ix].stub_count++;
1077                 StatArray[ix].stub_space += (unsigned short)(granule_size&gt;&gt;log2_seg_size);
1078                 break;
1079             }
1080           }
1081         }
1082       }
1083     }
1084     done = true;
1085 
1086     if (!insane) {
1087       // There is a risk for this block (because it contains many print statements) to get
1088       // interspersed with print data from other threads. We take this risk intentionally.
1089       // Getting stalled waiting for tty_lock while holding the CodeCache_lock is not desirable.
1090       printBox(ast, &#39;-&#39;, &quot;Global CodeHeap statistics for segment &quot;, heapName);
1091       ast-&gt;print_cr(&quot;freeSpace        = &quot; SIZE_FORMAT_W(8) &quot;k, nBlocks_free     = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity&quot;, freeSpace/(size_t)K,     nBlocks_free,     (100.0*freeSpace)/size,     (100.0*freeSpace)/res_size);
1092       ast-&gt;print_cr(&quot;usedSpace        = &quot; SIZE_FORMAT_W(8) &quot;k, nBlocks_used     = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity&quot;, usedSpace/(size_t)K,     nBlocks_used,     (100.0*usedSpace)/size,     (100.0*usedSpace)/res_size);
1093       ast-&gt;print_cr(&quot;  Tier1 Space    = &quot; SIZE_FORMAT_W(8) &quot;k, nBlocks_t1       = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity&quot;, t1Space/(size_t)K,       nBlocks_t1,       (100.0*t1Space)/size,       (100.0*t1Space)/res_size);
1094       ast-&gt;print_cr(&quot;  Tier2 Space    = &quot; SIZE_FORMAT_W(8) &quot;k, nBlocks_t2       = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity&quot;, t2Space/(size_t)K,       nBlocks_t2,       (100.0*t2Space)/size,       (100.0*t2Space)/res_size);
1095       ast-&gt;print_cr(&quot;  Alive Space    = &quot; SIZE_FORMAT_W(8) &quot;k, nBlocks_alive    = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity&quot;, aliveSpace/(size_t)K,    nBlocks_alive,    (100.0*aliveSpace)/size,    (100.0*aliveSpace)/res_size);
1096       ast-&gt;print_cr(&quot;    disconnected = &quot; SIZE_FORMAT_W(8) &quot;k, nBlocks_disconn  = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity&quot;, disconnSpace/(size_t)K,  nBlocks_disconn,  (100.0*disconnSpace)/size,  (100.0*disconnSpace)/res_size);
1097       ast-&gt;print_cr(&quot;    not entrant  = &quot; SIZE_FORMAT_W(8) &quot;k, nBlocks_notentr  = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity&quot;, notentrSpace/(size_t)K,  nBlocks_notentr,  (100.0*notentrSpace)/size,  (100.0*notentrSpace)/res_size);
1098       ast-&gt;print_cr(&quot;  inconstrSpace  = &quot; SIZE_FORMAT_W(8) &quot;k, nBlocks_inconstr = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity&quot;, inconstrSpace/(size_t)K, nBlocks_inconstr, (100.0*inconstrSpace)/size, (100.0*inconstrSpace)/res_size);
1099       ast-&gt;print_cr(&quot;  unloadedSpace  = &quot; SIZE_FORMAT_W(8) &quot;k, nBlocks_unloaded = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity&quot;, unloadedSpace/(size_t)K, nBlocks_unloaded, (100.0*unloadedSpace)/size, (100.0*unloadedSpace)/res_size);
1100       ast-&gt;print_cr(&quot;  deadSpace      = &quot; SIZE_FORMAT_W(8) &quot;k, nBlocks_dead     = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity&quot;, deadSpace/(size_t)K,     nBlocks_dead,     (100.0*deadSpace)/size,     (100.0*deadSpace)/res_size);
1101       ast-&gt;print_cr(&quot;  stubSpace      = &quot; SIZE_FORMAT_W(8) &quot;k, nBlocks_stub     = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity&quot;, stubSpace/(size_t)K,     nBlocks_stub,     (100.0*stubSpace)/size,     (100.0*stubSpace)/res_size);
1102       ast-&gt;print_cr(&quot;ZombieBlocks     = %8d. These are HeapBlocks which could not be identified as CodeBlobs.&quot;, nBlocks_zomb);
1103       ast-&gt;cr();
1104       ast-&gt;print_cr(&quot;Segment start          = &quot; INTPTR_FORMAT &quot;, used space      = &quot; SIZE_FORMAT_W(8)&quot;k&quot;, p2i(low_bound), size/K);
1105       ast-&gt;print_cr(&quot;Segment end (used)     = &quot; INTPTR_FORMAT &quot;, remaining space = &quot; SIZE_FORMAT_W(8)&quot;k&quot;, p2i(low_bound) + size, (res_size - size)/K);
1106       ast-&gt;print_cr(&quot;Segment end (reserved) = &quot; INTPTR_FORMAT &quot;, reserved space  = &quot; SIZE_FORMAT_W(8)&quot;k&quot;, p2i(low_bound) + res_size, res_size/K);
1107       ast-&gt;cr();
1108       ast-&gt;print_cr(&quot;latest allocated compilation id = %d&quot;, latest_compilation_id);
1109       ast-&gt;print_cr(&quot;highest observed compilation id = %d&quot;, highest_compilation_id);
1110       ast-&gt;print_cr(&quot;Building TopSizeList iterations = %ld&quot;, total_iterations);
1111       ast-&gt;cr();
1112 
1113       int             reset_val = NMethodSweeper::hotness_counter_reset_val();
1114       double reverse_free_ratio = (res_size &gt; size) ? (double)res_size/(double)(res_size-size) : (double)res_size;
1115       printBox(ast, &#39;-&#39;, &quot;Method hotness information at time of this analysis&quot;, NULL);
1116       ast-&gt;print_cr(&quot;Highest possible method temperature:          %12d&quot;, reset_val);
1117       ast-&gt;print_cr(&quot;Threshold for method to be considered &#39;cold&#39;: %12.3f&quot;, -reset_val + reverse_free_ratio * NmethodSweepActivity);
1118       if (n_methods &gt; 0) {
1119         avgTemp = hotnessAccumulator/n_methods;
1120         ast-&gt;print_cr(&quot;min. hotness = %6d&quot;, minTemp);
1121         ast-&gt;print_cr(&quot;avg. hotness = %6d&quot;, avgTemp);
1122         ast-&gt;print_cr(&quot;max. hotness = %6d&quot;, maxTemp);
1123       } else {
1124         avgTemp = 0;
1125         ast-&gt;print_cr(&quot;No hotness data available&quot;);
1126       }
1127       BUFFEREDSTREAM_FLUSH(&quot;\n&quot;)
1128 
1129       // This loop is intentionally printing directly to &quot;out&quot;.
1130       // It should not print anything, anyway.
1131       out-&gt;print(&quot;Verifying collected data...&quot;);
1132       size_t granule_segs = granule_size&gt;&gt;log2_seg_size;
1133       for (unsigned int ix = 0; ix &lt; granules; ix++) {
1134         if (StatArray[ix].t1_count   &gt; granule_segs) {
1135           out-&gt;print_cr(&quot;t1_count[%d]   = %d&quot;, ix, StatArray[ix].t1_count);
1136         }
1137         if (StatArray[ix].t2_count   &gt; granule_segs) {
1138           out-&gt;print_cr(&quot;t2_count[%d]   = %d&quot;, ix, StatArray[ix].t2_count);
1139         }
1140         if (StatArray[ix].tx_count   &gt; granule_segs) {
1141           out-&gt;print_cr(&quot;tx_count[%d]   = %d&quot;, ix, StatArray[ix].tx_count);
1142         }
1143         if (StatArray[ix].stub_count &gt; granule_segs) {
1144           out-&gt;print_cr(&quot;stub_count[%d] = %d&quot;, ix, StatArray[ix].stub_count);
1145         }
1146         if (StatArray[ix].dead_count &gt; granule_segs) {
1147           out-&gt;print_cr(&quot;dead_count[%d] = %d&quot;, ix, StatArray[ix].dead_count);
1148         }
1149         if (StatArray[ix].t1_space   &gt; granule_segs) {
1150           out-&gt;print_cr(&quot;t1_space[%d]   = %d&quot;, ix, StatArray[ix].t1_space);
1151         }
1152         if (StatArray[ix].t2_space   &gt; granule_segs) {
1153           out-&gt;print_cr(&quot;t2_space[%d]   = %d&quot;, ix, StatArray[ix].t2_space);
1154         }
1155         if (StatArray[ix].tx_space   &gt; granule_segs) {
1156           out-&gt;print_cr(&quot;tx_space[%d]   = %d&quot;, ix, StatArray[ix].tx_space);
1157         }
1158         if (StatArray[ix].stub_space &gt; granule_segs) {
1159           out-&gt;print_cr(&quot;stub_space[%d] = %d&quot;, ix, StatArray[ix].stub_space);
1160         }
1161         if (StatArray[ix].dead_space &gt; granule_segs) {
1162           out-&gt;print_cr(&quot;dead_space[%d] = %d&quot;, ix, StatArray[ix].dead_space);
1163         }
1164         //   this cast is awful! I need it because NT/Intel reports a signed/unsigned mismatch.
1165         if ((size_t)(StatArray[ix].t1_count+StatArray[ix].t2_count+StatArray[ix].tx_count+StatArray[ix].stub_count+StatArray[ix].dead_count) &gt; granule_segs) {
1166           out-&gt;print_cr(&quot;t1_count[%d] = %d, t2_count[%d] = %d, tx_count[%d] = %d, stub_count[%d] = %d&quot;, ix, StatArray[ix].t1_count, ix, StatArray[ix].t2_count, ix, StatArray[ix].tx_count, ix, StatArray[ix].stub_count);
1167         }
1168         if ((size_t)(StatArray[ix].t1_space+StatArray[ix].t2_space+StatArray[ix].tx_space+StatArray[ix].stub_space+StatArray[ix].dead_space) &gt; granule_segs) {
1169           out-&gt;print_cr(&quot;t1_space[%d] = %d, t2_space[%d] = %d, tx_space[%d] = %d, stub_space[%d] = %d&quot;, ix, StatArray[ix].t1_space, ix, StatArray[ix].t2_space, ix, StatArray[ix].tx_space, ix, StatArray[ix].stub_space);
1170         }
1171       }
1172 
1173       // This loop is intentionally printing directly to &quot;out&quot;.
1174       // It should not print anything, anyway.
1175       if (used_topSizeBlocks &gt; 0) {
1176         unsigned int j = 0;
1177         if (TopSizeArray[0].len != currMax) {
1178           out-&gt;print_cr(&quot;currMax(%d) differs from TopSizeArray[0].len(%d)&quot;, currMax, TopSizeArray[0].len);
1179         }
1180         for (unsigned int i = 0; (TopSizeArray[i].index != tsbStopper) &amp;&amp; (j++ &lt; alloc_topSizeBlocks); i = TopSizeArray[i].index) {
1181           if (TopSizeArray[i].len &lt; TopSizeArray[TopSizeArray[i].index].len) {
1182             out-&gt;print_cr(&quot;sort error at index %d: %d !&gt;= %d&quot;, i, TopSizeArray[i].len, TopSizeArray[TopSizeArray[i].index].len);
1183           }
1184         }
1185         if (j &gt;= alloc_topSizeBlocks) {
1186           out-&gt;print_cr(&quot;Possible loop in TopSizeArray chaining!\n  allocBlocks = %d, usedBlocks = %d&quot;, alloc_topSizeBlocks, used_topSizeBlocks);
1187           for (unsigned int i = 0; i &lt; alloc_topSizeBlocks; i++) {
1188             out-&gt;print_cr(&quot;  TopSizeArray[%d].index = %d, len = %d&quot;, i, TopSizeArray[i].index, TopSizeArray[i].len);
1189           }
1190         }
1191       }
1192       out-&gt;print_cr(&quot;...done\n\n&quot;);
1193     } else {
1194       // insane heap state detected. Analysis data incomplete. Just throw it away.
1195       discard_StatArray(out);
1196       discard_TopSizeArray(out);
1197     }
1198   }
1199 
1200 
1201   done        = false;
1202   while (!done &amp;&amp; (nBlocks_free &gt; 0)) {
1203 
1204     printBox(ast, &#39;=&#39;, &quot;C O D E   H E A P   A N A L Y S I S   (free blocks) for segment &quot;, heapName);
1205     ast-&gt;print_cr(&quot;   The aggregate step collects information about all free blocks in CodeHeap.\n&quot;
1206                   &quot;   Subsequent print functions create their output based on this snapshot.\n&quot;);
1207     ast-&gt;print_cr(&quot;   Free space in %s is distributed over %d free blocks.&quot;, heapName, nBlocks_free);
1208     ast-&gt;print_cr(&quot;   Each free block takes &quot; SIZE_FORMAT &quot; bytes of C heap for statistics data, that is &quot; SIZE_FORMAT &quot;K in total.&quot;, sizeof(FreeBlk), (sizeof(FreeBlk)*nBlocks_free)/K);
1209     BUFFEREDSTREAM_FLUSH(&quot;\n&quot;)
1210 
1211     //----------------------------------------
1212     //--  Prepare the FreeArray of FreeBlks --
1213     //----------------------------------------
1214 
1215     //---&lt; discard old array if size does not match  &gt;---
1216     if (nBlocks_free != alloc_freeBlocks) {
1217       discard_FreeArray(out);
1218     }
1219 
1220     prepare_FreeArray(out, nBlocks_free, heapName);
1221     if (FreeArray == NULL) {
1222       done = true;
1223       continue;
1224     }
1225 
1226     //----------------------------------------
1227     //--  Collect all FreeBlks in FreeArray --
1228     //----------------------------------------
1229 
1230     unsigned int ix = 0;
1231     FreeBlock* cur  = heap-&gt;freelist();
1232 
1233     while (cur != NULL) {
1234       if (ix &lt; alloc_freeBlocks) { // don&#39;t index out of bounds if _freelist has more blocks than anticipated
1235         FreeArray[ix].start = cur;
1236         FreeArray[ix].len   = (unsigned int)(cur-&gt;length()&lt;&lt;log2_seg_size);
1237         FreeArray[ix].index = ix;
1238       }
1239       cur  = cur-&gt;link();
1240       ix++;
1241     }
1242     if (ix != alloc_freeBlocks) {
1243       ast-&gt;print_cr(&quot;Free block count mismatch. Expected %d free blocks, but found %d.&quot;, alloc_freeBlocks, ix);
1244       ast-&gt;print_cr(&quot;I will update the counter and retry data collection&quot;);
1245       BUFFEREDSTREAM_FLUSH(&quot;\n&quot;)
1246       nBlocks_free = ix;
1247       continue;
1248     }
1249     done = true;
1250   }
1251 
1252   if (!done || (nBlocks_free == 0)) {
1253     if (nBlocks_free == 0) {
1254       printBox(ast, &#39;-&#39;, &quot;no free blocks found in &quot;, heapName);
1255     } else if (!done) {
1256       ast-&gt;print_cr(&quot;Free block count mismatch could not be resolved.&quot;);
1257       ast-&gt;print_cr(&quot;Try to run \&quot;aggregate\&quot; function to update counters&quot;);
1258     }
1259     BUFFEREDSTREAM_FLUSH(&quot;&quot;)
1260 
1261     //---&lt; discard old array and update global values  &gt;---
1262     discard_FreeArray(out);
1263     set_HeapStatGlobals(out, heapName);
1264     return;
1265   }
1266 
1267   //---&lt;  calculate and fill remaining fields  &gt;---
1268   if (FreeArray != NULL) {
1269     // This loop is intentionally printing directly to &quot;out&quot;.
1270     // It should not print anything, anyway.
1271     for (unsigned int ix = 0; ix &lt; alloc_freeBlocks-1; ix++) {
1272       size_t lenSum = 0;
1273       FreeArray[ix].gap = (unsigned int)((address)FreeArray[ix+1].start - ((address)FreeArray[ix].start + FreeArray[ix].len));
1274       for (HeapBlock *h = heap-&gt;next_block(FreeArray[ix].start); (h != NULL) &amp;&amp; (h != FreeArray[ix+1].start); h = heap-&gt;next_block(h)) {
1275         CodeBlob *cb  = (CodeBlob*)(heap-&gt;find_start(h));
1276         if ((cb != NULL) &amp;&amp; !cb-&gt;is_nmethod()) {
1277           FreeArray[ix].stubs_in_gap = true;
1278         }
1279         FreeArray[ix].n_gapBlocks++;
1280         lenSum += h-&gt;length()&lt;&lt;log2_seg_size;
1281         if (((address)h &lt; ((address)FreeArray[ix].start+FreeArray[ix].len)) || (h &gt;= FreeArray[ix+1].start)) {
1282           out-&gt;print_cr(&quot;unsorted occupied CodeHeap block found @ %p, gap interval [%p, %p)&quot;, h, (address)FreeArray[ix].start+FreeArray[ix].len, FreeArray[ix+1].start);
1283         }
1284       }
1285       if (lenSum != FreeArray[ix].gap) {
1286         out-&gt;print_cr(&quot;Length mismatch for gap between FreeBlk[%d] and FreeBlk[%d]. Calculated: %d, accumulated: %d.&quot;, ix, ix+1, FreeArray[ix].gap, (unsigned int)lenSum);
1287       }
1288     }
1289   }
1290   set_HeapStatGlobals(out, heapName);
1291 
1292   printBox(ast, &#39;=&#39;, &quot;C O D E   H E A P   A N A L Y S I S   C O M P L E T E   for segment &quot;, heapName);
1293   BUFFEREDSTREAM_FLUSH(&quot;\n&quot;)
1294 }
1295 
1296 
1297 void CodeHeapState::print_usedSpace(outputStream* out, CodeHeap* heap) {
1298   if (!initialization_complete) {
1299     return;
1300   }
1301 
1302   const char* heapName   = get_heapName(heap);
1303   get_HeapStatGlobals(out, heapName);
1304 
1305   if ((StatArray == NULL) || (TopSizeArray == NULL) || (used_topSizeBlocks == 0)) {
1306     return;
1307   }
1308   BUFFEREDSTREAM_DECL(ast, out)
1309 
1310   {
1311     printBox(ast, &#39;=&#39;, &quot;U S E D   S P A C E   S T A T I S T I C S   for &quot;, heapName);
1312     ast-&gt;print_cr(&quot;Note: The Top%d list of the largest used blocks associates method names\n&quot;
1313                   &quot;      and other identifying information with the block size data.\n&quot;
1314                   &quot;\n&quot;
1315                   &quot;      Method names are dynamically retrieved from the code cache at print time.\n&quot;
1316                   &quot;      Due to the living nature of the code cache and because the CodeCache_lock\n&quot;
1317                   &quot;      is not continuously held, the displayed name might be wrong or no name\n&quot;
1318                   &quot;      might be found at all. The likelihood for that to happen increases\n&quot;
1319                   &quot;      over time passed between analysis and print step.\n&quot;, used_topSizeBlocks);
1320     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n&quot;)
1321   }
1322 
1323   //----------------------------
1324   //--  Print Top Used Blocks --
1325   //----------------------------
1326   {
1327     char*     low_bound = heap-&gt;low_boundary();
1328     bool      have_CodeCache_lock = CodeCache_lock-&gt;owned_by_self();
1329 
1330     printBox(ast, &#39;-&#39;, &quot;Largest Used Blocks in &quot;, heapName);
1331     print_blobType_legend(ast);
1332 
1333     ast-&gt;fill_to(51);
1334     ast-&gt;print(&quot;%4s&quot;, &quot;blob&quot;);
1335     ast-&gt;fill_to(56);
1336     ast-&gt;print(&quot;%9s&quot;, &quot;compiler&quot;);
1337     ast-&gt;fill_to(66);
1338     ast-&gt;print_cr(&quot;%6s&quot;, &quot;method&quot;);
1339     ast-&gt;print_cr(&quot;%18s %13s %17s %4s %9s  %5s %s&quot;,      &quot;Addr(module)      &quot;, &quot;offset&quot;, &quot;size&quot;, &quot;type&quot;, &quot; type lvl&quot;, &quot; temp&quot;, &quot;Name&quot;);
1340     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;&quot;)
1341 
1342     //---&lt;  print Top Ten Used Blocks  &gt;---
1343     if (used_topSizeBlocks &gt; 0) {
1344       unsigned int printed_topSizeBlocks = 0;
1345       for (unsigned int i = 0; i != tsbStopper; i = TopSizeArray[i].index) {
1346         printed_topSizeBlocks++;
1347         nmethod*           nm = NULL;
1348         const char* blob_name = &quot;unnamed blob or blob name unavailable&quot;;
1349         // heap-&gt;find_start() is safe. Only works on _segmap.
1350         // Returns NULL or void*. Returned CodeBlob may be uninitialized.
1351         HeapBlock* heapBlock = TopSizeArray[i].start;
1352         CodeBlob*  this_blob = (CodeBlob*)(heap-&gt;find_start(heapBlock));
1353         bool    blob_is_safe = blob_access_is_safe(this_blob, NULL);
1354         if (blob_is_safe) {
1355           //---&lt;  access these fields only if we own the CodeCache_lock  &gt;---
1356           if (have_CodeCache_lock) {
1357             blob_name = this_blob-&gt;name();
1358             nm        = this_blob-&gt;as_nmethod_or_null();
1359           }
1360           //---&lt;  blob address  &gt;---
1361           ast-&gt;print(INTPTR_FORMAT, p2i(this_blob));
1362           ast-&gt;fill_to(19);
1363           //---&lt;  blob offset from CodeHeap begin  &gt;---
1364           ast-&gt;print(&quot;(+&quot; PTR32_FORMAT &quot;)&quot;, (unsigned int)((char*)this_blob-low_bound));
1365           ast-&gt;fill_to(33);
1366         } else {
1367           //---&lt;  block address  &gt;---
1368           ast-&gt;print(INTPTR_FORMAT, p2i(TopSizeArray[i].start));
1369           ast-&gt;fill_to(19);
1370           //---&lt;  block offset from CodeHeap begin  &gt;---
1371           ast-&gt;print(&quot;(+&quot; PTR32_FORMAT &quot;)&quot;, (unsigned int)((char*)TopSizeArray[i].start-low_bound));
1372           ast-&gt;fill_to(33);
1373         }
1374 
1375         //---&lt;  print size, name, and signature (for nMethods)  &gt;---
1376         // access nmethod and Method fields only if we own the CodeCache_lock.
1377         // This fact is implicitly transported via nm != NULL.
1378         if (CompiledMethod::nmethod_access_is_safe(nm)) {
1379           ResourceMark rm;
1380           Method* method = nm-&gt;method();
1381           if (nm-&gt;is_in_use()) {
1382             blob_name = method-&gt;name_and_sig_as_C_string();
1383           }
1384           if (nm-&gt;is_not_entrant()) {
1385             blob_name = method-&gt;name_and_sig_as_C_string();
1386           }
1387           //---&lt;  nMethod size in hex  &gt;---
1388           unsigned int total_size = nm-&gt;total_size();
1389           ast-&gt;print(PTR32_FORMAT, total_size);
1390           ast-&gt;print(&quot;(&quot; SIZE_FORMAT_W(4) &quot;K)&quot;, total_size/K);
1391           ast-&gt;fill_to(51);
1392           ast-&gt;print(&quot;  %c&quot;, blobTypeChar[TopSizeArray[i].type]);
1393           //---&lt;  compiler information  &gt;---
1394           ast-&gt;fill_to(56);
1395           ast-&gt;print(&quot;%5s %3d&quot;, compTypeName[TopSizeArray[i].compiler], TopSizeArray[i].level);
1396           //---&lt;  method temperature  &gt;---
1397           ast-&gt;fill_to(67);
1398           ast-&gt;print(&quot;%5d&quot;, nm-&gt;hotness_counter());
1399           //---&lt;  name and signature  &gt;---
1400           ast-&gt;fill_to(67+6);
1401           if (nm-&gt;is_not_installed()) {
1402             ast-&gt;print(&quot; not (yet) installed method &quot;);
1403           }
1404           if (nm-&gt;is_zombie()) {
1405             ast-&gt;print(&quot; zombie method &quot;);
1406           }
1407           ast-&gt;print(&quot;%s&quot;, blob_name);
1408         } else {
1409           //---&lt;  block size in hex  &gt;---
1410           ast-&gt;print(PTR32_FORMAT, (unsigned int)(TopSizeArray[i].len&lt;&lt;log2_seg_size));
1411           ast-&gt;print(&quot;(&quot; SIZE_FORMAT_W(4) &quot;K)&quot;, (TopSizeArray[i].len&lt;&lt;log2_seg_size)/K);
1412           //---&lt;  no compiler information  &gt;---
1413           ast-&gt;fill_to(56);
1414           //---&lt;  name and signature  &gt;---
1415           ast-&gt;fill_to(67+6);
1416           ast-&gt;print(&quot;%s&quot;, blob_name);
1417         }
1418         ast-&gt;cr();
1419         BUFFEREDSTREAM_FLUSH_AUTO(&quot;&quot;)
1420       }
1421       if (used_topSizeBlocks != printed_topSizeBlocks) {
1422         ast-&gt;print_cr(&quot;used blocks: %d, printed blocks: %d&quot;, used_topSizeBlocks, printed_topSizeBlocks);
1423         for (unsigned int i = 0; i &lt; alloc_topSizeBlocks; i++) {
1424           ast-&gt;print_cr(&quot;  TopSizeArray[%d].index = %d, len = %d&quot;, i, TopSizeArray[i].index, TopSizeArray[i].len);
1425           BUFFEREDSTREAM_FLUSH_AUTO(&quot;&quot;)
1426         }
1427       }
1428       BUFFEREDSTREAM_FLUSH(&quot;\n\n&quot;)
1429     }
1430   }
1431 
1432   //-----------------------------
1433   //--  Print Usage Histogram  --
1434   //-----------------------------
1435 
1436   if (SizeDistributionArray != NULL) {
1437     unsigned long total_count = 0;
1438     unsigned long total_size  = 0;
1439     const unsigned long pctFactor = 200;
1440 
1441     for (unsigned int i = 0; i &lt; nSizeDistElements; i++) {
1442       total_count += SizeDistributionArray[i].count;
1443       total_size  += SizeDistributionArray[i].lenSum;
1444     }
1445 
1446     if ((total_count &gt; 0) &amp;&amp; (total_size &gt; 0)) {
1447       printBox(ast, &#39;-&#39;, &quot;Block count histogram for &quot;, heapName);
1448       ast-&gt;print_cr(&quot;Note: The histogram indicates how many blocks (as a percentage\n&quot;
1449                     &quot;      of all blocks) have a size in the given range.\n&quot;
1450                     &quot;      %ld characters are printed per percentage point.\n&quot;, pctFactor/100);
1451       ast-&gt;print_cr(&quot;total size   of all blocks: %7ldM&quot;, (total_size&lt;&lt;log2_seg_size)/M);
1452       ast-&gt;print_cr(&quot;total number of all blocks: %7ld\n&quot;, total_count);
1453       BUFFEREDSTREAM_FLUSH_LOCKED(&quot;&quot;)
1454 
1455       ast-&gt;print_cr(&quot;[Size Range)------avg.-size-+----count-+&quot;);
1456       for (unsigned int i = 0; i &lt; nSizeDistElements; i++) {
1457         if (SizeDistributionArray[i].rangeStart&lt;&lt;log2_seg_size &lt; K) {
1458           ast-&gt;print(&quot;[&quot; SIZE_FORMAT_W(5) &quot; ..&quot; SIZE_FORMAT_W(5) &quot; ): &quot;
1459                     ,(size_t)(SizeDistributionArray[i].rangeStart&lt;&lt;log2_seg_size)
1460                     ,(size_t)(SizeDistributionArray[i].rangeEnd&lt;&lt;log2_seg_size)
1461                     );
1462         } else if (SizeDistributionArray[i].rangeStart&lt;&lt;log2_seg_size &lt; M) {
1463           ast-&gt;print(&quot;[&quot; SIZE_FORMAT_W(5) &quot;K..&quot; SIZE_FORMAT_W(5) &quot;K): &quot;
1464                     ,(SizeDistributionArray[i].rangeStart&lt;&lt;log2_seg_size)/K
1465                     ,(SizeDistributionArray[i].rangeEnd&lt;&lt;log2_seg_size)/K
1466                     );
1467         } else {
1468           ast-&gt;print(&quot;[&quot; SIZE_FORMAT_W(5) &quot;M..&quot; SIZE_FORMAT_W(5) &quot;M): &quot;
1469                     ,(SizeDistributionArray[i].rangeStart&lt;&lt;log2_seg_size)/M
1470                     ,(SizeDistributionArray[i].rangeEnd&lt;&lt;log2_seg_size)/M
1471                     );
1472         }
1473         ast-&gt;print(&quot; %8d | %8d |&quot;,
1474                    SizeDistributionArray[i].count &gt; 0 ? (SizeDistributionArray[i].lenSum&lt;&lt;log2_seg_size)/SizeDistributionArray[i].count : 0,
1475                    SizeDistributionArray[i].count);
1476 
1477         unsigned int percent = pctFactor*SizeDistributionArray[i].count/total_count;
1478         for (unsigned int j = 1; j &lt;= percent; j++) {
1479           ast-&gt;print(&quot;%c&quot;, (j%((pctFactor/100)*10) == 0) ? (&#39;0&#39;+j/(((unsigned int)pctFactor/100)*10)) : &#39;*&#39;);
1480         }
1481         ast-&gt;cr();
1482         BUFFEREDSTREAM_FLUSH_AUTO(&quot;&quot;)
1483       }
1484       ast-&gt;print_cr(&quot;----------------------------+----------+&quot;);
1485       BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
1486 
1487       printBox(ast, &#39;-&#39;, &quot;Contribution per size range to total size for &quot;, heapName);
1488       ast-&gt;print_cr(&quot;Note: The histogram indicates how much space (as a percentage of all\n&quot;
1489                     &quot;      occupied space) is used by the blocks in the given size range.\n&quot;
1490                     &quot;      %ld characters are printed per percentage point.\n&quot;, pctFactor/100);
1491       ast-&gt;print_cr(&quot;total size   of all blocks: %7ldM&quot;, (total_size&lt;&lt;log2_seg_size)/M);
1492       ast-&gt;print_cr(&quot;total number of all blocks: %7ld\n&quot;, total_count);
1493       BUFFEREDSTREAM_FLUSH_LOCKED(&quot;&quot;)
1494 
1495       ast-&gt;print_cr(&quot;[Size Range)------avg.-size-+----count-+&quot;);
1496       for (unsigned int i = 0; i &lt; nSizeDistElements; i++) {
1497         if (SizeDistributionArray[i].rangeStart&lt;&lt;log2_seg_size &lt; K) {
1498           ast-&gt;print(&quot;[&quot; SIZE_FORMAT_W(5) &quot; ..&quot; SIZE_FORMAT_W(5) &quot; ): &quot;
1499                     ,(size_t)(SizeDistributionArray[i].rangeStart&lt;&lt;log2_seg_size)
1500                     ,(size_t)(SizeDistributionArray[i].rangeEnd&lt;&lt;log2_seg_size)
1501                     );
1502         } else if (SizeDistributionArray[i].rangeStart&lt;&lt;log2_seg_size &lt; M) {
1503           ast-&gt;print(&quot;[&quot; SIZE_FORMAT_W(5) &quot;K..&quot; SIZE_FORMAT_W(5) &quot;K): &quot;
1504                     ,(SizeDistributionArray[i].rangeStart&lt;&lt;log2_seg_size)/K
1505                     ,(SizeDistributionArray[i].rangeEnd&lt;&lt;log2_seg_size)/K
1506                     );
1507         } else {
1508           ast-&gt;print(&quot;[&quot; SIZE_FORMAT_W(5) &quot;M..&quot; SIZE_FORMAT_W(5) &quot;M): &quot;
1509                     ,(SizeDistributionArray[i].rangeStart&lt;&lt;log2_seg_size)/M
1510                     ,(SizeDistributionArray[i].rangeEnd&lt;&lt;log2_seg_size)/M
1511                     );
1512         }
1513         ast-&gt;print(&quot; %8d | %8d |&quot;,
1514                    SizeDistributionArray[i].count &gt; 0 ? (SizeDistributionArray[i].lenSum&lt;&lt;log2_seg_size)/SizeDistributionArray[i].count : 0,
1515                    SizeDistributionArray[i].count);
1516 
1517         unsigned int percent = pctFactor*(unsigned long)SizeDistributionArray[i].lenSum/total_size;
1518         for (unsigned int j = 1; j &lt;= percent; j++) {
1519           ast-&gt;print(&quot;%c&quot;, (j%((pctFactor/100)*10) == 0) ? (&#39;0&#39;+j/(((unsigned int)pctFactor/100)*10)) : &#39;*&#39;);
1520         }
1521         ast-&gt;cr();
1522         BUFFEREDSTREAM_FLUSH_AUTO(&quot;&quot;)
1523       }
1524       ast-&gt;print_cr(&quot;----------------------------+----------+&quot;);
1525       BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
1526     }
1527   }
1528 }
1529 
1530 
1531 void CodeHeapState::print_freeSpace(outputStream* out, CodeHeap* heap) {
1532   if (!initialization_complete) {
1533     return;
1534   }
1535 
1536   const char* heapName   = get_heapName(heap);
1537   get_HeapStatGlobals(out, heapName);
1538 
1539   if ((StatArray == NULL) || (FreeArray == NULL) || (alloc_granules == 0)) {
1540     return;
1541   }
1542   BUFFEREDSTREAM_DECL(ast, out)
1543 
1544   {
1545     printBox(ast, &#39;=&#39;, &quot;F R E E   S P A C E   S T A T I S T I C S   for &quot;, heapName);
1546     ast-&gt;print_cr(&quot;Note: in this context, a gap is the occupied space between two free blocks.\n&quot;
1547                   &quot;      Those gaps are of interest if there is a chance that they become\n&quot;
1548                   &quot;      unoccupied, e.g. by class unloading. Then, the two adjacent free\n&quot;
1549                   &quot;      blocks, together with the now unoccupied space, form a new, large\n&quot;
1550                   &quot;      free block.&quot;);
1551     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n&quot;)
1552   }
1553 
1554   {
1555     printBox(ast, &#39;-&#39;, &quot;List of all Free Blocks in &quot;, heapName);
1556 
1557     unsigned int ix = 0;
1558     for (ix = 0; ix &lt; alloc_freeBlocks-1; ix++) {
1559       ast-&gt;print(INTPTR_FORMAT &quot;: Len[%4d] = &quot; HEX32_FORMAT &quot;,&quot;, p2i(FreeArray[ix].start), ix, FreeArray[ix].len);
1560       ast-&gt;fill_to(38);
1561       ast-&gt;print(&quot;Gap[%4d..%4d]: &quot; HEX32_FORMAT &quot; bytes,&quot;, ix, ix+1, FreeArray[ix].gap);
1562       ast-&gt;fill_to(71);
1563       ast-&gt;print(&quot;block count: %6d&quot;, FreeArray[ix].n_gapBlocks);
1564       if (FreeArray[ix].stubs_in_gap) {
1565         ast-&gt;print(&quot; !! permanent gap, contains stubs and/or blobs !!&quot;);
1566       }
1567       ast-&gt;cr();
1568       BUFFEREDSTREAM_FLUSH_AUTO(&quot;&quot;)
1569     }
1570     ast-&gt;print_cr(INTPTR_FORMAT &quot;: Len[%4d] = &quot; HEX32_FORMAT, p2i(FreeArray[ix].start), ix, FreeArray[ix].len);
1571     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n&quot;)
1572   }
1573 
1574 
1575   //-----------------------------------------
1576   //--  Find and Print Top Ten Free Blocks --
1577   //-----------------------------------------
1578 
1579   //---&lt;  find Top Ten Free Blocks  &gt;---
1580   const unsigned int nTop = 10;
1581   unsigned int  currMax10 = 0;
1582   struct FreeBlk* FreeTopTen[nTop];
1583   memset(FreeTopTen, 0, sizeof(FreeTopTen));
1584 
1585   for (unsigned int ix = 0; ix &lt; alloc_freeBlocks; ix++) {
1586     if (FreeArray[ix].len &gt; currMax10) {  // larger than the ten largest found so far
1587       unsigned int currSize = FreeArray[ix].len;
1588 
1589       unsigned int iy;
1590       for (iy = 0; iy &lt; nTop &amp;&amp; FreeTopTen[iy] != NULL; iy++) {
1591         if (FreeTopTen[iy]-&gt;len &lt; currSize) {
1592           for (unsigned int iz = nTop-1; iz &gt; iy; iz--) { // make room to insert new free block
1593             FreeTopTen[iz] = FreeTopTen[iz-1];
1594           }
1595           FreeTopTen[iy] = &amp;FreeArray[ix];        // insert new free block
1596           if (FreeTopTen[nTop-1] != NULL) {
1597             currMax10 = FreeTopTen[nTop-1]-&gt;len;
1598           }
1599           break; // done with this, check next free block
1600         }
1601       }
1602       if (iy &gt;= nTop) {
1603         ast-&gt;print_cr(&quot;Internal logic error. New Max10 = %d detected, but could not be merged. Old Max10 = %d&quot;,
1604                       currSize, currMax10);
1605         continue;
1606       }
1607       if (FreeTopTen[iy] == NULL) {
1608         FreeTopTen[iy] = &amp;FreeArray[ix];
1609         if (iy == (nTop-1)) {
1610           currMax10 = currSize;
1611         }
1612       }
1613     }
1614   }
1615   BUFFEREDSTREAM_FLUSH_AUTO(&quot;&quot;)
1616 
1617   {
1618     printBox(ast, &#39;-&#39;, &quot;Top Ten Free Blocks in &quot;, heapName);
1619 
1620     //---&lt;  print Top Ten Free Blocks  &gt;---
1621     for (unsigned int iy = 0; (iy &lt; nTop) &amp;&amp; (FreeTopTen[iy] != NULL); iy++) {
1622       ast-&gt;print(&quot;Pos %3d: Block %4d - size &quot; HEX32_FORMAT &quot;,&quot;, iy+1, FreeTopTen[iy]-&gt;index, FreeTopTen[iy]-&gt;len);
1623       ast-&gt;fill_to(39);
1624       if (FreeTopTen[iy]-&gt;index == (alloc_freeBlocks-1)) {
1625         ast-&gt;print(&quot;last free block in list.&quot;);
1626       } else {
1627         ast-&gt;print(&quot;Gap (to next) &quot; HEX32_FORMAT &quot;,&quot;, FreeTopTen[iy]-&gt;gap);
1628         ast-&gt;fill_to(63);
1629         ast-&gt;print(&quot;#blocks (in gap) %d&quot;, FreeTopTen[iy]-&gt;n_gapBlocks);
1630       }
1631       ast-&gt;cr();
1632       BUFFEREDSTREAM_FLUSH_AUTO(&quot;&quot;)
1633     }
1634   }
1635   BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n&quot;)
1636 
1637 
1638   //--------------------------------------------------------
1639   //--  Find and Print Top Ten Free-Occupied-Free Triples --
1640   //--------------------------------------------------------
1641 
1642   //---&lt;  find and print Top Ten Triples (Free-Occupied-Free)  &gt;---
1643   currMax10 = 0;
1644   struct FreeBlk  *FreeTopTenTriple[nTop];
1645   memset(FreeTopTenTriple, 0, sizeof(FreeTopTenTriple));
1646 
1647   for (unsigned int ix = 0; ix &lt; alloc_freeBlocks-1; ix++) {
1648     // If there are stubs in the gap, this gap will never become completely free.
1649     // The triple will thus never merge to one free block.
1650     unsigned int lenTriple  = FreeArray[ix].len + (FreeArray[ix].stubs_in_gap ? 0 : FreeArray[ix].gap + FreeArray[ix+1].len);
1651     FreeArray[ix].len = lenTriple;
1652     if (lenTriple &gt; currMax10) {  // larger than the ten largest found so far
1653 
1654       unsigned int iy;
1655       for (iy = 0; (iy &lt; nTop) &amp;&amp; (FreeTopTenTriple[iy] != NULL); iy++) {
1656         if (FreeTopTenTriple[iy]-&gt;len &lt; lenTriple) {
1657           for (unsigned int iz = nTop-1; iz &gt; iy; iz--) {
1658             FreeTopTenTriple[iz] = FreeTopTenTriple[iz-1];
1659           }
1660           FreeTopTenTriple[iy] = &amp;FreeArray[ix];
1661           if (FreeTopTenTriple[nTop-1] != NULL) {
1662             currMax10 = FreeTopTenTriple[nTop-1]-&gt;len;
1663           }
1664           break;
1665         }
1666       }
1667       if (iy == nTop) {
1668         ast-&gt;print_cr(&quot;Internal logic error. New Max10 = %d detected, but could not be merged. Old Max10 = %d&quot;,
1669                       lenTriple, currMax10);
1670         continue;
1671       }
1672       if (FreeTopTenTriple[iy] == NULL) {
1673         FreeTopTenTriple[iy] = &amp;FreeArray[ix];
1674         if (iy == (nTop-1)) {
1675           currMax10 = lenTriple;
1676         }
1677       }
1678     }
1679   }
1680   BUFFEREDSTREAM_FLUSH_AUTO(&quot;&quot;)
1681 
1682   {
1683     printBox(ast, &#39;-&#39;, &quot;Top Ten Free-Occupied-Free Triples in &quot;, heapName);
1684     ast-&gt;print_cr(&quot;  Use this information to judge how likely it is that a large(r) free block\n&quot;
1685                   &quot;  might get created by code cache sweeping.\n&quot;
1686                   &quot;  If all the occupied blocks can be swept, the three free blocks will be\n&quot;
1687                   &quot;  merged into one (much larger) free block. That would reduce free space\n&quot;
1688                   &quot;  fragmentation.\n&quot;);
1689 
1690     //---&lt;  print Top Ten Free-Occupied-Free Triples  &gt;---
1691     for (unsigned int iy = 0; (iy &lt; nTop) &amp;&amp; (FreeTopTenTriple[iy] != NULL); iy++) {
1692       ast-&gt;print(&quot;Pos %3d: Block %4d - size &quot; HEX32_FORMAT &quot;,&quot;, iy+1, FreeTopTenTriple[iy]-&gt;index, FreeTopTenTriple[iy]-&gt;len);
1693       ast-&gt;fill_to(39);
1694       ast-&gt;print(&quot;Gap (to next) &quot; HEX32_FORMAT &quot;,&quot;, FreeTopTenTriple[iy]-&gt;gap);
1695       ast-&gt;fill_to(63);
1696       ast-&gt;print(&quot;#blocks (in gap) %d&quot;, FreeTopTenTriple[iy]-&gt;n_gapBlocks);
1697       ast-&gt;cr();
1698       BUFFEREDSTREAM_FLUSH_AUTO(&quot;&quot;)
1699     }
1700   }
1701   BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n&quot;)
1702 }
1703 
1704 
1705 void CodeHeapState::print_count(outputStream* out, CodeHeap* heap) {
1706   if (!initialization_complete) {
1707     return;
1708   }
1709 
1710   const char* heapName   = get_heapName(heap);
1711   get_HeapStatGlobals(out, heapName);
1712 
1713   if ((StatArray == NULL) || (alloc_granules == 0)) {
1714     return;
1715   }
1716   BUFFEREDSTREAM_DECL(ast, out)
1717 
1718   unsigned int granules_per_line = 32;
1719   char*        low_bound         = heap-&gt;low_boundary();
1720 
1721   {
1722     printBox(ast, &#39;=&#39;, &quot;B L O C K   C O U N T S   for &quot;, heapName);
1723     ast-&gt;print_cr(&quot;  Each granule contains an individual number of heap blocks. Large blocks\n&quot;
1724                   &quot;  may span multiple granules and are counted for each granule they touch.\n&quot;);
1725     if (segment_granules) {
1726       ast-&gt;print_cr(&quot;  You have selected granule size to be as small as segment size.\n&quot;
1727                     &quot;  As a result, each granule contains exactly one block (or a part of one block)\n&quot;
1728                     &quot;  or is displayed as empty (&#39; &#39;) if it&#39;s BlobType does not match the selection.\n&quot;
1729                     &quot;  Occupied granules show their BlobType character, see legend.\n&quot;);
1730       print_blobType_legend(ast);
1731     }
1732     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;&quot;)
1733   }
1734 
1735   {
1736     if (segment_granules) {
1737       printBox(ast, &#39;-&#39;, &quot;Total (all types) count for granule size == segment size&quot;, NULL);
1738 
1739       granules_per_line = 128;
1740       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
1741         print_line_delim(out, ast, low_bound, ix, granules_per_line);
1742         print_blobType_single(ast, StatArray[ix].type);
1743       }
1744     } else {
1745       printBox(ast, &#39;-&#39;, &quot;Total (all tiers) count, 0x1..0xf. &#39;*&#39; indicates &gt;= 16 blocks, &#39; &#39; indicates empty&quot;, NULL);
1746 
1747       granules_per_line = 128;
1748       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
1749         print_line_delim(out, ast, low_bound, ix, granules_per_line);
1750         unsigned int count = StatArray[ix].t1_count   + StatArray[ix].t2_count   + StatArray[ix].tx_count
1751                            + StatArray[ix].stub_count + StatArray[ix].dead_count;
1752         print_count_single(ast, count);
1753       }
1754     }
1755     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;|\n\n\n&quot;)
1756   }
1757 
1758   {
1759     if (nBlocks_t1 &gt; 0) {
1760       printBox(ast, &#39;-&#39;, &quot;Tier1 nMethod count only, 0x1..0xf. &#39;*&#39; indicates &gt;= 16 blocks, &#39; &#39; indicates empty&quot;, NULL);
1761 
1762       granules_per_line = 128;
1763       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
1764         print_line_delim(out, ast, low_bound, ix, granules_per_line);
1765         if (segment_granules &amp;&amp; StatArray[ix].t1_count &gt; 0) {
1766           print_blobType_single(ast, StatArray[ix].type);
1767         } else {
1768           print_count_single(ast, StatArray[ix].t1_count);
1769         }
1770       }
1771       ast-&gt;print(&quot;|&quot;);
1772     } else {
1773       ast-&gt;print(&quot;No Tier1 nMethods found in CodeHeap.&quot;);
1774     }
1775     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
1776   }
1777 
1778   {
1779     if (nBlocks_t2 &gt; 0) {
1780       printBox(ast, &#39;-&#39;, &quot;Tier2 nMethod count only, 0x1..0xf. &#39;*&#39; indicates &gt;= 16 blocks, &#39; &#39; indicates empty&quot;, NULL);
1781 
1782       granules_per_line = 128;
1783       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
1784         print_line_delim(out, ast, low_bound, ix, granules_per_line);
1785         if (segment_granules &amp;&amp; StatArray[ix].t2_count &gt; 0) {
1786           print_blobType_single(ast, StatArray[ix].type);
1787         } else {
1788           print_count_single(ast, StatArray[ix].t2_count);
1789         }
1790       }
1791       ast-&gt;print(&quot;|&quot;);
1792     } else {
1793       ast-&gt;print(&quot;No Tier2 nMethods found in CodeHeap.&quot;);
1794     }
1795     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
1796   }
1797 
1798   {
1799     if (nBlocks_alive &gt; 0) {
1800       printBox(ast, &#39;-&#39;, &quot;not_used/not_entrant/not_installed nMethod count only, 0x1..0xf. &#39;*&#39; indicates &gt;= 16 blocks, &#39; &#39; indicates empty&quot;, NULL);
1801 
1802       granules_per_line = 128;
1803       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
1804         print_line_delim(out, ast, low_bound, ix, granules_per_line);
1805         if (segment_granules &amp;&amp; StatArray[ix].tx_count &gt; 0) {
1806           print_blobType_single(ast, StatArray[ix].type);
1807         } else {
1808           print_count_single(ast, StatArray[ix].tx_count);
1809         }
1810       }
1811       ast-&gt;print(&quot;|&quot;);
1812     } else {
1813       ast-&gt;print(&quot;No not_used/not_entrant nMethods found in CodeHeap.&quot;);
1814     }
1815     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
1816   }
1817 
1818   {
1819     if (nBlocks_stub &gt; 0) {
1820       printBox(ast, &#39;-&#39;, &quot;Stub &amp; Blob count only, 0x1..0xf. &#39;*&#39; indicates &gt;= 16 blocks, &#39; &#39; indicates empty&quot;, NULL);
1821 
1822       granules_per_line = 128;
1823       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
1824         print_line_delim(out, ast, low_bound, ix, granules_per_line);
1825         if (segment_granules &amp;&amp; StatArray[ix].stub_count &gt; 0) {
1826           print_blobType_single(ast, StatArray[ix].type);
1827         } else {
1828           print_count_single(ast, StatArray[ix].stub_count);
1829         }
1830       }
1831       ast-&gt;print(&quot;|&quot;);
1832     } else {
1833       ast-&gt;print(&quot;No Stubs and Blobs found in CodeHeap.&quot;);
1834     }
1835     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
1836   }
1837 
1838   {
1839     if (nBlocks_dead &gt; 0) {
1840       printBox(ast, &#39;-&#39;, &quot;Dead nMethod count only, 0x1..0xf. &#39;*&#39; indicates &gt;= 16 blocks, &#39; &#39; indicates empty&quot;, NULL);
1841 
1842       granules_per_line = 128;
1843       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
1844         print_line_delim(out, ast, low_bound, ix, granules_per_line);
1845         if (segment_granules &amp;&amp; StatArray[ix].dead_count &gt; 0) {
1846           print_blobType_single(ast, StatArray[ix].type);
1847         } else {
1848           print_count_single(ast, StatArray[ix].dead_count);
1849         }
1850       }
1851       ast-&gt;print(&quot;|&quot;);
1852     } else {
1853       ast-&gt;print(&quot;No dead nMethods found in CodeHeap.&quot;);
1854     }
1855     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
1856   }
1857 
1858   {
1859     if (!segment_granules) { // Prevent totally redundant printouts
1860       printBox(ast, &#39;-&#39;, &quot;Count by tier (combined, no dead blocks): &lt;#t1&gt;:&lt;#t2&gt;:&lt;#s&gt;, 0x0..0xf. &#39;*&#39; indicates &gt;= 16 blocks&quot;, NULL);
1861 
1862       granules_per_line = 24;
1863       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
1864         print_line_delim(out, ast, low_bound, ix, granules_per_line);
1865 
1866         print_count_single(ast, StatArray[ix].t1_count);
1867         ast-&gt;print(&quot;:&quot;);
1868         print_count_single(ast, StatArray[ix].t2_count);
1869         ast-&gt;print(&quot;:&quot;);
1870         if (segment_granules &amp;&amp; StatArray[ix].stub_count &gt; 0) {
1871           print_blobType_single(ast, StatArray[ix].type);
1872         } else {
1873           print_count_single(ast, StatArray[ix].stub_count);
1874         }
1875         ast-&gt;print(&quot; &quot;);
1876       }
1877       BUFFEREDSTREAM_FLUSH_LOCKED(&quot;|\n\n\n&quot;)
1878     }
1879   }
1880 }
1881 
1882 
1883 void CodeHeapState::print_space(outputStream* out, CodeHeap* heap) {
1884   if (!initialization_complete) {
1885     return;
1886   }
1887 
1888   const char* heapName   = get_heapName(heap);
1889   get_HeapStatGlobals(out, heapName);
1890 
1891   if ((StatArray == NULL) || (alloc_granules == 0)) {
1892     return;
1893   }
1894   BUFFEREDSTREAM_DECL(ast, out)
1895 
1896   unsigned int granules_per_line = 32;
1897   char*        low_bound         = heap-&gt;low_boundary();
1898 
1899   {
1900     printBox(ast, &#39;=&#39;, &quot;S P A C E   U S A G E  &amp;  F R A G M E N T A T I O N   for &quot;, heapName);
1901     ast-&gt;print_cr(&quot;  The heap space covered by one granule is occupied to a various extend.\n&quot;
1902                   &quot;  The granule occupancy is displayed by one decimal digit per granule.\n&quot;);
1903     if (segment_granules) {
1904       ast-&gt;print_cr(&quot;  You have selected granule size to be as small as segment size.\n&quot;
1905                     &quot;  As a result, each granule contains exactly one block (or a part of one block)\n&quot;
1906                     &quot;  or is displayed as empty (&#39; &#39;) if it&#39;s BlobType does not match the selection.\n&quot;
1907                     &quot;  Occupied granules show their BlobType character, see legend.\n&quot;);
1908       print_blobType_legend(ast);
1909     } else {
1910       ast-&gt;print_cr(&quot;  These digits represent a fill percentage range (see legend).\n&quot;);
1911       print_space_legend(ast);
1912     }
1913     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;&quot;)
1914   }
1915 
1916   {
1917     if (segment_granules) {
1918       printBox(ast, &#39;-&#39;, &quot;Total (all types) space consumption for granule size == segment size&quot;, NULL);
1919 
1920       granules_per_line = 128;
1921       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
1922         print_line_delim(out, ast, low_bound, ix, granules_per_line);
1923         print_blobType_single(ast, StatArray[ix].type);
1924       }
1925     } else {
1926       printBox(ast, &#39;-&#39;, &quot;Total (all types) space consumption. &#39; &#39; indicates empty, &#39;*&#39; indicates full.&quot;, NULL);
1927 
1928       granules_per_line = 128;
1929       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
1930         print_line_delim(out, ast, low_bound, ix, granules_per_line);
1931         unsigned int space    = StatArray[ix].t1_space   + StatArray[ix].t2_space  + StatArray[ix].tx_space
1932                               + StatArray[ix].stub_space + StatArray[ix].dead_space;
1933         print_space_single(ast, space);
1934       }
1935     }
1936     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;|\n\n\n&quot;)
1937   }
1938 
1939   {
1940     if (nBlocks_t1 &gt; 0) {
1941       printBox(ast, &#39;-&#39;, &quot;Tier1 space consumption. &#39; &#39; indicates empty, &#39;*&#39; indicates full&quot;, NULL);
1942 
1943       granules_per_line = 128;
1944       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
1945         print_line_delim(out, ast, low_bound, ix, granules_per_line);
1946         if (segment_granules &amp;&amp; StatArray[ix].t1_space &gt; 0) {
1947           print_blobType_single(ast, StatArray[ix].type);
1948         } else {
1949           print_space_single(ast, StatArray[ix].t1_space);
1950         }
1951       }
1952       ast-&gt;print(&quot;|&quot;);
1953     } else {
1954       ast-&gt;print(&quot;No Tier1 nMethods found in CodeHeap.&quot;);
1955     }
1956     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
1957   }
1958 
1959   {
1960     if (nBlocks_t2 &gt; 0) {
1961       printBox(ast, &#39;-&#39;, &quot;Tier2 space consumption. &#39; &#39; indicates empty, &#39;*&#39; indicates full&quot;, NULL);
1962 
1963       granules_per_line = 128;
1964       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
1965         print_line_delim(out, ast, low_bound, ix, granules_per_line);
1966         if (segment_granules &amp;&amp; StatArray[ix].t2_space &gt; 0) {
1967           print_blobType_single(ast, StatArray[ix].type);
1968         } else {
1969           print_space_single(ast, StatArray[ix].t2_space);
1970         }
1971       }
1972       ast-&gt;print(&quot;|&quot;);
1973     } else {
1974       ast-&gt;print(&quot;No Tier2 nMethods found in CodeHeap.&quot;);
1975     }
1976     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
1977   }
1978 
1979   {
1980     if (nBlocks_alive &gt; 0) {
1981       printBox(ast, &#39;-&#39;, &quot;not_used/not_entrant/not_installed space consumption. &#39; &#39; indicates empty, &#39;*&#39; indicates full&quot;, NULL);
1982 
1983       granules_per_line = 128;
1984       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
1985         print_line_delim(out, ast, low_bound, ix, granules_per_line);
1986         if (segment_granules &amp;&amp; StatArray[ix].tx_space &gt; 0) {
1987           print_blobType_single(ast, StatArray[ix].type);
1988         } else {
1989           print_space_single(ast, StatArray[ix].tx_space);
1990         }
1991       }
1992       ast-&gt;print(&quot;|&quot;);
1993     } else {
1994       ast-&gt;print(&quot;No Tier2 nMethods found in CodeHeap.&quot;);
1995     }
1996     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
1997   }
1998 
1999   {
2000     if (nBlocks_stub &gt; 0) {
2001       printBox(ast, &#39;-&#39;, &quot;Stub and Blob space consumption. &#39; &#39; indicates empty, &#39;*&#39; indicates full&quot;, NULL);
2002 
2003       granules_per_line = 128;
2004       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
2005         print_line_delim(out, ast, low_bound, ix, granules_per_line);
2006         if (segment_granules &amp;&amp; StatArray[ix].stub_space &gt; 0) {
2007           print_blobType_single(ast, StatArray[ix].type);
2008         } else {
2009           print_space_single(ast, StatArray[ix].stub_space);
2010         }
2011       }
2012       ast-&gt;print(&quot;|&quot;);
2013     } else {
2014       ast-&gt;print(&quot;No Stubs and Blobs found in CodeHeap.&quot;);
2015     }
2016     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
2017   }
2018 
2019   {
2020     if (nBlocks_dead &gt; 0) {
2021       printBox(ast, &#39;-&#39;, &quot;Dead space consumption. &#39; &#39; indicates empty, &#39;*&#39; indicates full&quot;, NULL);
2022 
2023       granules_per_line = 128;
2024       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
2025         print_line_delim(out, ast, low_bound, ix, granules_per_line);
2026         print_space_single(ast, StatArray[ix].dead_space);
2027       }
2028       ast-&gt;print(&quot;|&quot;);
2029     } else {
2030       ast-&gt;print(&quot;No dead nMethods found in CodeHeap.&quot;);
2031     }
2032     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
2033   }
2034 
2035   {
2036     if (!segment_granules) { // Prevent totally redundant printouts
2037       printBox(ast, &#39;-&#39;, &quot;Space consumption by tier (combined): &lt;t1%&gt;:&lt;t2%&gt;:&lt;s%&gt;. &#39; &#39; indicates empty, &#39;*&#39; indicates full&quot;, NULL);
2038 
2039       granules_per_line = 24;
2040       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
2041         print_line_delim(out, ast, low_bound, ix, granules_per_line);
2042 
2043         if (segment_granules &amp;&amp; StatArray[ix].t1_space &gt; 0) {
2044           print_blobType_single(ast, StatArray[ix].type);
2045         } else {
2046           print_space_single(ast, StatArray[ix].t1_space);
2047         }
2048         ast-&gt;print(&quot;:&quot;);
2049         if (segment_granules &amp;&amp; StatArray[ix].t2_space &gt; 0) {
2050           print_blobType_single(ast, StatArray[ix].type);
2051         } else {
2052           print_space_single(ast, StatArray[ix].t2_space);
2053         }
2054         ast-&gt;print(&quot;:&quot;);
2055         if (segment_granules &amp;&amp; StatArray[ix].stub_space &gt; 0) {
2056           print_blobType_single(ast, StatArray[ix].type);
2057         } else {
2058           print_space_single(ast, StatArray[ix].stub_space);
2059         }
2060         ast-&gt;print(&quot; &quot;);
2061       }
2062       ast-&gt;print(&quot;|&quot;);
2063       BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
2064     }
2065   }
2066 }
2067 
2068 void CodeHeapState::print_age(outputStream* out, CodeHeap* heap) {
2069   if (!initialization_complete) {
2070     return;
2071   }
2072 
2073   const char* heapName   = get_heapName(heap);
2074   get_HeapStatGlobals(out, heapName);
2075 
2076   if ((StatArray == NULL) || (alloc_granules == 0)) {
2077     return;
2078   }
2079   BUFFEREDSTREAM_DECL(ast, out)
2080 
2081   unsigned int granules_per_line = 32;
2082   char*        low_bound         = heap-&gt;low_boundary();
2083 
2084   {
2085     printBox(ast, &#39;=&#39;, &quot;M E T H O D   A G E   by CompileID for &quot;, heapName);
2086     ast-&gt;print_cr(&quot;  The age of a compiled method in the CodeHeap is not available as a\n&quot;
2087                   &quot;  time stamp. Instead, a relative age is deducted from the method&#39;s compilation ID.\n&quot;
2088                   &quot;  Age information is available for tier1 and tier2 methods only. There is no\n&quot;
2089                   &quot;  age information for stubs and blobs, because they have no compilation ID assigned.\n&quot;
2090                   &quot;  Information for the youngest method (highest ID) in the granule is printed.\n&quot;
2091                   &quot;  Refer to the legend to learn how method age is mapped to the displayed digit.&quot;);
2092     print_age_legend(ast);
2093     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;&quot;)
2094   }
2095 
2096   {
2097     printBox(ast, &#39;-&#39;, &quot;Age distribution. &#39;0&#39; indicates youngest 1/256, &#39;8&#39;: oldest half, &#39; &#39;: no age information&quot;, NULL);
2098 
2099     granules_per_line = 128;
2100     for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
2101       print_line_delim(out, ast, low_bound, ix, granules_per_line);
2102       unsigned int age1      = StatArray[ix].t1_age;
2103       unsigned int age2      = StatArray[ix].t2_age;
2104       unsigned int agex      = StatArray[ix].tx_age;
2105       unsigned int age       = age1 &gt; age2 ? age1 : age2;
2106       age       = age &gt; agex ? age : agex;
2107       print_age_single(ast, age);
2108     }
2109     ast-&gt;print(&quot;|&quot;);
2110     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
2111   }
2112 
2113   {
2114     if (nBlocks_t1 &gt; 0) {
2115       printBox(ast, &#39;-&#39;, &quot;Tier1 age distribution. &#39;0&#39; indicates youngest 1/256, &#39;8&#39;: oldest half, &#39; &#39;: no age information&quot;, NULL);
2116 
2117       granules_per_line = 128;
2118       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
2119         print_line_delim(out, ast, low_bound, ix, granules_per_line);
2120         print_age_single(ast, StatArray[ix].t1_age);
2121       }
2122       ast-&gt;print(&quot;|&quot;);
2123     } else {
2124       ast-&gt;print(&quot;No Tier1 nMethods found in CodeHeap.&quot;);
2125     }
2126     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
2127   }
2128 
2129   {
2130     if (nBlocks_t2 &gt; 0) {
2131       printBox(ast, &#39;-&#39;, &quot;Tier2 age distribution. &#39;0&#39; indicates youngest 1/256, &#39;8&#39;: oldest half, &#39; &#39;: no age information&quot;, NULL);
2132 
2133       granules_per_line = 128;
2134       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
2135         print_line_delim(out, ast, low_bound, ix, granules_per_line);
2136         print_age_single(ast, StatArray[ix].t2_age);
2137       }
2138       ast-&gt;print(&quot;|&quot;);
2139     } else {
2140       ast-&gt;print(&quot;No Tier2 nMethods found in CodeHeap.&quot;);
2141     }
2142     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
2143   }
2144 
2145   {
2146     if (nBlocks_alive &gt; 0) {
2147       printBox(ast, &#39;-&#39;, &quot;not_used/not_entrant/not_installed age distribution. &#39;0&#39; indicates youngest 1/256, &#39;8&#39;: oldest half, &#39; &#39;: no age information&quot;, NULL);
2148 
2149       granules_per_line = 128;
2150       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
2151         print_line_delim(out, ast, low_bound, ix, granules_per_line);
2152         print_age_single(ast, StatArray[ix].tx_age);
2153       }
2154       ast-&gt;print(&quot;|&quot;);
2155     } else {
2156       ast-&gt;print(&quot;No Tier2 nMethods found in CodeHeap.&quot;);
2157     }
2158     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
2159   }
2160 
2161   {
2162     if (!segment_granules) { // Prevent totally redundant printouts
2163       printBox(ast, &#39;-&#39;, &quot;age distribution by tier &lt;a1&gt;:&lt;a2&gt;. &#39;0&#39; indicates youngest 1/256, &#39;8&#39;: oldest half, &#39; &#39;: no age information&quot;, NULL);
2164 
2165       granules_per_line = 32;
2166       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
2167         print_line_delim(out, ast, low_bound, ix, granules_per_line);
2168         print_age_single(ast, StatArray[ix].t1_age);
2169         ast-&gt;print(&quot;:&quot;);
2170         print_age_single(ast, StatArray[ix].t2_age);
2171         ast-&gt;print(&quot; &quot;);
2172       }
2173       ast-&gt;print(&quot;|&quot;);
2174       BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
2175     }
2176   }
2177 }
2178 
2179 
2180 void CodeHeapState::print_names(outputStream* out, CodeHeap* heap) {
2181   if (!initialization_complete) {
2182     return;
2183   }
2184 
2185   const char* heapName   = get_heapName(heap);
2186   get_HeapStatGlobals(out, heapName);
2187 
2188   if ((StatArray == NULL) || (alloc_granules == 0)) {
2189     return;
2190   }
2191   BUFFEREDSTREAM_DECL(ast, out)
2192 
2193   unsigned int granules_per_line   = 128;
2194   char*        low_bound           = heap-&gt;low_boundary();
2195   CodeBlob*    last_blob           = NULL;
2196   bool         name_in_addr_range  = true;
2197   bool         have_CodeCache_lock = CodeCache_lock-&gt;owned_by_self();
2198 
2199   //---&lt;  print at least 128K per block (i.e. between headers)  &gt;---
2200   if (granules_per_line*granule_size &lt; 128*K) {
2201     granules_per_line = (unsigned int)((128*K)/granule_size);
2202   }
2203 
2204   printBox(ast, &#39;=&#39;, &quot;M E T H O D   N A M E S   for &quot;, heapName);
2205   ast-&gt;print_cr(&quot;  Method names are dynamically retrieved from the code cache at print time.\n&quot;
2206                 &quot;  Due to the living nature of the code heap and because the CodeCache_lock\n&quot;
2207                 &quot;  is not continuously held, the displayed name might be wrong or no name\n&quot;
2208                 &quot;  might be found at all. The likelihood for that to happen increases\n&quot;
2209                 &quot;  over time passed between aggregtion and print steps.\n&quot;);
2210   BUFFEREDSTREAM_FLUSH_LOCKED(&quot;&quot;)
2211 
2212   for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
2213     //---&lt;  print a new blob on a new line  &gt;---
2214     if (ix%granules_per_line == 0) {
2215       if (!name_in_addr_range) {
2216         ast-&gt;print_cr(&quot;No methods, blobs, or stubs found in this address range&quot;);
2217       }
2218       name_in_addr_range = false;
2219 
2220       size_t end_ix = (ix+granules_per_line &lt;= alloc_granules) ? ix+granules_per_line : alloc_granules;
2221       ast-&gt;cr();
2222       ast-&gt;print_cr(&quot;--------------------------------------------------------------------&quot;);
2223       ast-&gt;print_cr(&quot;Address range [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;), &quot; SIZE_FORMAT &quot;k&quot;, p2i(low_bound+ix*granule_size), p2i(low_bound + end_ix*granule_size), (end_ix - ix)*granule_size/(size_t)K);
2224       ast-&gt;print_cr(&quot;--------------------------------------------------------------------&quot;);
2225       BUFFEREDSTREAM_FLUSH_AUTO(&quot;&quot;)
2226     }
2227     // Only check granule if it contains at least one blob.
2228     unsigned int nBlobs  = StatArray[ix].t1_count   + StatArray[ix].t2_count + StatArray[ix].tx_count +
2229                            StatArray[ix].stub_count + StatArray[ix].dead_count;
2230     if (nBlobs &gt; 0 ) {
2231     for (unsigned int is = 0; is &lt; granule_size; is+=(unsigned int)seg_size) {
2232       // heap-&gt;find_start() is safe. Only works on _segmap.
2233       // Returns NULL or void*. Returned CodeBlob may be uninitialized.
2234       char*     this_seg  = low_bound + ix*granule_size + is;
2235       CodeBlob* this_blob = (CodeBlob*)(heap-&gt;find_start(this_seg));
2236       bool   blob_is_safe = blob_access_is_safe(this_blob, NULL);
2237       // blob could have been flushed, freed, and merged.
2238       // this_blob &lt; last_blob is an indicator for that.
2239       if (blob_is_safe &amp;&amp; (this_blob &gt; last_blob)) {
2240         last_blob          = this_blob;
2241 
2242         //---&lt;  get type and name  &gt;---
2243         blobType       cbType = noType;
2244         if (segment_granules) {
2245           cbType = (blobType)StatArray[ix].type;
2246         } else {
2247           //---&lt;  access these fields only if we own the CodeCache_lock  &gt;---
2248           if (have_CodeCache_lock) {
2249             cbType = get_cbType(this_blob);
2250           }
2251         }
2252 
2253         //---&lt;  access these fields only if we own the CodeCache_lock  &gt;---
2254         const char* blob_name = &quot;&lt;unavailable&gt;&quot;;
2255         nmethod*           nm = NULL;
2256         if (have_CodeCache_lock) {
2257           blob_name = this_blob-&gt;name();
2258           nm        = this_blob-&gt;as_nmethod_or_null();
2259           // this_blob-&gt;name() could return NULL if no name was given to CTOR. Inlined, maybe invisible on stack
2260           if ((blob_name == NULL) || !os::is_readable_pointer(blob_name)) {
2261             blob_name = &quot;&lt;unavailable&gt;&quot;;
2262           }
2263         }
2264 
2265         //---&lt;  print table header for new print range  &gt;---
2266         if (!name_in_addr_range) {
2267           name_in_addr_range = true;
2268           ast-&gt;fill_to(51);
2269           ast-&gt;print(&quot;%9s&quot;, &quot;compiler&quot;);
2270           ast-&gt;fill_to(61);
2271           ast-&gt;print_cr(&quot;%6s&quot;, &quot;method&quot;);
2272           ast-&gt;print_cr(&quot;%18s %13s %17s %9s  %5s %18s  %s&quot;, &quot;Addr(module)      &quot;, &quot;offset&quot;, &quot;size&quot;, &quot; type lvl&quot;, &quot; temp&quot;, &quot;blobType          &quot;, &quot;Name&quot;);
2273           BUFFEREDSTREAM_FLUSH_AUTO(&quot;&quot;)
2274         }
2275 
2276         //---&lt;  print line prefix (address and offset from CodeHeap start)  &gt;---
2277         ast-&gt;print(INTPTR_FORMAT, p2i(this_blob));
2278         ast-&gt;fill_to(19);
2279         ast-&gt;print(&quot;(+&quot; PTR32_FORMAT &quot;)&quot;, (unsigned int)((char*)this_blob-low_bound));
2280         ast-&gt;fill_to(33);
2281 
2282         // access nmethod and Method fields only if we own the CodeCache_lock.
2283         // This fact is implicitly transported via nm != NULL.
2284         if (CompiledMethod::nmethod_access_is_safe(nm)) {
2285           Method* method = nm-&gt;method();
2286           ResourceMark rm;
2287           //---&lt;  collect all data to locals as quickly as possible  &gt;---
2288           unsigned int total_size = nm-&gt;total_size();
2289           int          hotness    = nm-&gt;hotness_counter();
2290           bool         get_name   = (cbType == nMethod_inuse) || (cbType == nMethod_notused);
2291           //---&lt;  nMethod size in hex  &gt;---
2292           ast-&gt;print(PTR32_FORMAT, total_size);
2293           ast-&gt;print(&quot;(&quot; SIZE_FORMAT_W(4) &quot;K)&quot;, total_size/K);
2294           //---&lt;  compiler information  &gt;---
2295           ast-&gt;fill_to(51);
2296           ast-&gt;print(&quot;%5s %3d&quot;, compTypeName[StatArray[ix].compiler], StatArray[ix].level);
2297           //---&lt;  method temperature  &gt;---
2298           ast-&gt;fill_to(62);
2299           ast-&gt;print(&quot;%5d&quot;, hotness);
2300           //---&lt;  name and signature  &gt;---
2301           ast-&gt;fill_to(62+6);
2302           ast-&gt;print(&quot;%s&quot;, blobTypeName[cbType]);
2303           ast-&gt;fill_to(82+6);
2304           if (cbType == nMethod_dead) {
2305             ast-&gt;print(&quot;%14s&quot;, &quot; zombie method&quot;);
2306           }
2307 
2308           if (get_name) {
2309             Symbol* methName  = method-&gt;name();
2310             const char*   methNameS = (methName == NULL) ? NULL : methName-&gt;as_C_string();
2311             methNameS = (methNameS == NULL) ? &quot;&lt;method name unavailable&gt;&quot; : methNameS;
2312             Symbol* methSig   = method-&gt;signature();
2313             const char*   methSigS  = (methSig  == NULL) ? NULL : methSig-&gt;as_C_string();
2314             methSigS  = (methSigS  == NULL) ? &quot;&lt;method signature unavailable&gt;&quot; : methSigS;
2315             ast-&gt;print(&quot;%s&quot;, methNameS);
2316             ast-&gt;print(&quot;%s&quot;, methSigS);
2317           } else {
2318             ast-&gt;print(&quot;%s&quot;, blob_name);
2319           }
2320         } else if (blob_is_safe) {
2321           ast-&gt;fill_to(62+6);
2322           ast-&gt;print(&quot;%s&quot;, blobTypeName[cbType]);
2323           ast-&gt;fill_to(82+6);
2324           ast-&gt;print(&quot;%s&quot;, blob_name);
2325         } else {
2326           ast-&gt;fill_to(62+6);
2327           ast-&gt;print(&quot;&lt;stale blob&gt;&quot;);
2328         }
2329         ast-&gt;cr();
2330         BUFFEREDSTREAM_FLUSH_AUTO(&quot;&quot;)
2331       } else if (!blob_is_safe &amp;&amp; (this_blob != last_blob) &amp;&amp; (this_blob != NULL)) {
2332         last_blob          = this_blob;
2333       }
2334     }
2335     } // nBlobs &gt; 0
2336   }
2337   BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n&quot;)
2338 }
2339 
2340 
2341 void CodeHeapState::printBox(outputStream* ast, const char border, const char* text1, const char* text2) {
2342   unsigned int lineLen = 1 + 2 + 2 + 1;
2343   char edge, frame;
2344 
2345   if (text1 != NULL) {
2346     lineLen += (unsigned int)strlen(text1); // text1 is much shorter than MAX_INT chars.
2347   }
2348   if (text2 != NULL) {
2349     lineLen += (unsigned int)strlen(text2); // text2 is much shorter than MAX_INT chars.
2350   }
2351   if (border == &#39;-&#39;) {
2352     edge  = &#39;+&#39;;
2353     frame = &#39;|&#39;;
2354   } else {
2355     edge  = border;
2356     frame = border;
2357   }
2358 
2359   ast-&gt;print(&quot;%c&quot;, edge);
2360   for (unsigned int i = 0; i &lt; lineLen-2; i++) {
2361     ast-&gt;print(&quot;%c&quot;, border);
2362   }
2363   ast-&gt;print_cr(&quot;%c&quot;, edge);
2364 
2365   ast-&gt;print(&quot;%c  &quot;, frame);
2366   if (text1 != NULL) {
2367     ast-&gt;print(&quot;%s&quot;, text1);
2368   }
2369   if (text2 != NULL) {
2370     ast-&gt;print(&quot;%s&quot;, text2);
2371   }
2372   ast-&gt;print_cr(&quot;  %c&quot;, frame);
2373 
2374   ast-&gt;print(&quot;%c&quot;, edge);
2375   for (unsigned int i = 0; i &lt; lineLen-2; i++) {
2376     ast-&gt;print(&quot;%c&quot;, border);
2377   }
2378   ast-&gt;print_cr(&quot;%c&quot;, edge);
2379 }
2380 
2381 void CodeHeapState::print_blobType_legend(outputStream* out) {
2382   out-&gt;cr();
2383   printBox(out, &#39;-&#39;, &quot;Block types used in the following CodeHeap dump&quot;, NULL);
2384   for (int type = noType; type &lt; lastType; type += 1) {
2385     out-&gt;print_cr(&quot;  %c - %s&quot;, blobTypeChar[type], blobTypeName[type]);
2386   }
2387   out-&gt;print_cr(&quot;  -----------------------------------------------------&quot;);
2388   out-&gt;cr();
2389 }
2390 
2391 void CodeHeapState::print_space_legend(outputStream* out) {
2392   unsigned int indicator = 0;
2393   unsigned int age_range = 256;
2394   unsigned int range_beg = latest_compilation_id;
2395   out-&gt;cr();
2396   printBox(out, &#39;-&#39;, &quot;Space ranges, based on granule occupancy&quot;, NULL);
2397   out-&gt;print_cr(&quot;    -   0%% == occupancy&quot;);
2398   for (int i=0; i&lt;=9; i++) {
2399     out-&gt;print_cr(&quot;  %d - %3d%% &lt; occupancy &lt; %3d%%&quot;, i, 10*i, 10*(i+1));
2400   }
2401   out-&gt;print_cr(&quot;  * - 100%% == occupancy&quot;);
2402   out-&gt;print_cr(&quot;  ----------------------------------------------&quot;);
2403   out-&gt;cr();
2404 }
2405 
2406 void CodeHeapState::print_age_legend(outputStream* out) {
2407   unsigned int indicator = 0;
2408   unsigned int age_range = 256;
2409   unsigned int range_beg = latest_compilation_id;
2410   out-&gt;cr();
2411   printBox(out, &#39;-&#39;, &quot;Age ranges, based on compilation id&quot;, NULL);
2412   while (age_range &gt; 0) {
2413     out-&gt;print_cr(&quot;  %d - %6d to %6d&quot;, indicator, range_beg, latest_compilation_id - latest_compilation_id/age_range);
2414     range_beg = latest_compilation_id - latest_compilation_id/age_range;
2415     age_range /= 2;
2416     indicator += 1;
2417   }
2418   out-&gt;print_cr(&quot;  -----------------------------------------&quot;);
2419   out-&gt;cr();
2420 }
2421 
2422 void CodeHeapState::print_blobType_single(outputStream* out, u2 /* blobType */ type) {
2423   out-&gt;print(&quot;%c&quot;, blobTypeChar[type]);
2424 }
2425 
2426 void CodeHeapState::print_count_single(outputStream* out, unsigned short count) {
2427   if (count &gt;= 16)    out-&gt;print(&quot;*&quot;);
2428   else if (count &gt; 0) out-&gt;print(&quot;%1.1x&quot;, count);
2429   else                out-&gt;print(&quot; &quot;);
2430 }
2431 
2432 void CodeHeapState::print_space_single(outputStream* out, unsigned short space) {
2433   size_t  space_in_bytes = ((unsigned int)space)&lt;&lt;log2_seg_size;
2434   char    fraction       = (space == 0) ? &#39; &#39; : (space_in_bytes &gt;= granule_size-1) ? &#39;*&#39; : char(&#39;0&#39;+10*space_in_bytes/granule_size);
2435   out-&gt;print(&quot;%c&quot;, fraction);
2436 }
2437 
2438 void CodeHeapState::print_age_single(outputStream* out, unsigned int age) {
2439   unsigned int indicator = 0;
2440   unsigned int age_range = 256;
2441   if (age &gt; 0) {
2442     while ((age_range &gt; 0) &amp;&amp; (latest_compilation_id-age &gt; latest_compilation_id/age_range)) {
2443       age_range /= 2;
2444       indicator += 1;
2445     }
2446     out-&gt;print(&quot;%c&quot;, char(&#39;0&#39;+indicator));
2447   } else {
2448     out-&gt;print(&quot; &quot;);
2449   }
2450 }
2451 
2452 void CodeHeapState::print_line_delim(outputStream* out, outputStream* ast, char* low_bound, unsigned int ix, unsigned int gpl) {
2453   if (ix % gpl == 0) {
2454     if (ix &gt; 0) {
2455       ast-&gt;print(&quot;|&quot;);
2456     }
2457     ast-&gt;cr();
2458     assert(out == ast, &quot;must use the same stream!&quot;);
2459 
2460     ast-&gt;print(INTPTR_FORMAT, p2i(low_bound + ix*granule_size));
2461     ast-&gt;fill_to(19);
2462     ast-&gt;print(&quot;(+&quot; PTR32_FORMAT &quot;): |&quot;, (unsigned int)(ix*granule_size));
2463   }
2464 }
2465 
2466 void CodeHeapState::print_line_delim(outputStream* out, bufferedStream* ast, char* low_bound, unsigned int ix, unsigned int gpl) {
2467   assert(out != ast, &quot;must not use the same stream!&quot;);
2468   if (ix % gpl == 0) {
2469     if (ix &gt; 0) {
2470       ast-&gt;print(&quot;|&quot;);
2471     }
2472     ast-&gt;cr();
2473 
2474     // can&#39;t use BUFFEREDSTREAM_FLUSH_IF(&quot;&quot;, 512) here.
2475     // can&#39;t use this expression. bufferedStream::capacity() does not exist.
2476     // if ((ast-&gt;capacity() - ast-&gt;size()) &lt; 512) {
2477     // Assume instead that default bufferedStream capacity (4K) was used.
2478     if (ast-&gt;size() &gt; 3*K) {
2479       ttyLocker ttyl;
2480       out-&gt;print(&quot;%s&quot;, ast-&gt;as_string());
2481       ast-&gt;reset();
2482     }
2483 
2484     ast-&gt;print(INTPTR_FORMAT, p2i(low_bound + ix*granule_size));
2485     ast-&gt;fill_to(19);
2486     ast-&gt;print(&quot;(+&quot; PTR32_FORMAT &quot;): |&quot;, (unsigned int)(ix*granule_size));
2487   }
2488 }
2489 
2490 CodeHeapState::blobType CodeHeapState::get_cbType(CodeBlob* cb) {
2491   if ((cb != NULL) &amp;&amp; os::is_readable_pointer(cb)) {
2492     if (cb-&gt;is_runtime_stub())                return runtimeStub;
2493     if (cb-&gt;is_deoptimization_stub())         return deoptimizationStub;
2494     if (cb-&gt;is_uncommon_trap_stub())          return uncommonTrapStub;
2495     if (cb-&gt;is_exception_stub())              return exceptionStub;
2496     if (cb-&gt;is_safepoint_stub())              return safepointStub;
2497     if (cb-&gt;is_adapter_blob())                return adapterBlob;
2498     if (cb-&gt;is_method_handles_adapter_blob()) return mh_adapterBlob;
2499     if (cb-&gt;is_buffer_blob())                 return bufferBlob;
2500 
2501     //---&lt;  access these fields only if we own the CodeCache_lock  &gt;---
2502     // Should be ensured by caller. aggregate() amd print_names() do that.
2503     if (CodeCache_lock-&gt;owned_by_self()) {
2504       nmethod*  nm = cb-&gt;as_nmethod_or_null();
2505       if (nm != NULL) { // no is_readable check required, nm = (nmethod*)cb.
2506         if (nm-&gt;is_not_installed()) return nMethod_inconstruction;
2507         if (nm-&gt;is_zombie())        return nMethod_dead;
2508         if (nm-&gt;is_unloaded())      return nMethod_unloaded;
2509         if (nm-&gt;is_in_use())        return nMethod_inuse;
2510         if (nm-&gt;is_alive() &amp;&amp; !(nm-&gt;is_not_entrant()))   return nMethod_notused;
2511         if (nm-&gt;is_alive())         return nMethod_alive;
2512         return nMethod_dead;
2513       }
2514     }
2515   }
2516   return noType;
2517 }
2518 
2519 bool CodeHeapState::blob_access_is_safe(CodeBlob* this_blob, CodeBlob* prev_blob) {
2520   return (this_blob != NULL) &amp;&amp; // a blob must have been found, obviously
2521          ((this_blob == prev_blob) || (prev_blob == NULL)) &amp;&amp;  // when re-checking, the same blob must have been found
2522          (this_blob-&gt;header_size() &gt;= 0) &amp;&amp;
2523          (this_blob-&gt;relocation_size() &gt;= 0) &amp;&amp;
2524          ((address)this_blob + this_blob-&gt;header_size() == (address)(this_blob-&gt;relocation_begin())) &amp;&amp;
2525          ((address)this_blob + CodeBlob::align_code_offset(this_blob-&gt;header_size() + this_blob-&gt;relocation_size()) == (address)(this_blob-&gt;content_begin())) &amp;&amp;
2526          os::is_readable_pointer((address)(this_blob-&gt;relocation_begin())) &amp;&amp;
2527          os::is_readable_pointer(this_blob-&gt;content_begin());
2528 }
    </pre>
  </body>
</html>
diff a/src/hotspot/share/code/debugInfo.cpp b/src/hotspot/share/code/debugInfo.cpp
--- a/src/hotspot/share/code/debugInfo.cpp
+++ b/src/hotspot/share/code/debugInfo.cpp
@@ -24,10 +24,11 @@
 
 #include "precompiled.hpp"
 #include "code/debugInfo.hpp"
 #include "code/debugInfoRec.hpp"
 #include "code/nmethod.hpp"
+#include "memory/universe.hpp"
 #include "oops/oop.inline.hpp"
 #include "runtime/handles.inline.hpp"
 #include "runtime/interfaceSupport.inline.hpp"
 #include "runtime/jniHandles.inline.hpp"
 #include "runtime/thread.hpp"
@@ -48,24 +49,32 @@
 void DebugInfoWriteStream::write_metadata(Metadata* h) {
   write_int(recorder()->oop_recorder()->find_index(h));
 }
 
 oop DebugInfoReadStream::read_oop() {
-  oop o = code()->oop_at(read_int());
+  nmethod* nm = const_cast<CompiledMethod*>(code())->as_nmethod_or_null();
+  oop o;
+  if (nm != NULL) {
+    // Despite these oops being found inside nmethods that are on-stack,
+    // they are not kept alive by all GCs (e.g. G1 and Shenandoah).
+    o = nm->oop_at_phantom(read_int());
+  } else {
+    o = code()->oop_at(read_int());
+  }
   assert(oopDesc::is_oop_or_null(o), "oop only");
   return o;
 }
 
-ScopeValue* DebugInfoReadStream::read_object_value() {
+ScopeValue* DebugInfoReadStream::read_object_value(bool is_auto_box) {
   int id = read_int();
 #ifdef ASSERT
   assert(_obj_pool != NULL, "object pool does not exist");
   for (int i = _obj_pool->length() - 1; i >= 0; i--) {
     assert(_obj_pool->at(i)->as_ObjectValue()->id() != id, "should not be read twice");
   }
 #endif
-  ObjectValue* result = new ObjectValue(id);
+  ObjectValue* result = is_auto_box ? new AutoBoxObjectValue(id) : new ObjectValue(id);
   // Cache the object since an object field could reference it.
   _obj_pool->push(result);
   result->read_object(this);
   return result;
 }
@@ -85,22 +94,24 @@
 
 // Serializing scope values
 
 enum { LOCATION_CODE = 0, CONSTANT_INT_CODE = 1,  CONSTANT_OOP_CODE = 2,
                           CONSTANT_LONG_CODE = 3, CONSTANT_DOUBLE_CODE = 4,
-                          OBJECT_CODE = 5,        OBJECT_ID_CODE = 6 };
+                          OBJECT_CODE = 5,        OBJECT_ID_CODE = 6,
+                          AUTO_BOX_OBJECT_CODE = 7 };
 
 ScopeValue* ScopeValue::read_from(DebugInfoReadStream* stream) {
   ScopeValue* result = NULL;
   switch(stream->read_int()) {
-   case LOCATION_CODE:        result = new LocationValue(stream);        break;
-   case CONSTANT_INT_CODE:    result = new ConstantIntValue(stream);     break;
-   case CONSTANT_OOP_CODE:    result = new ConstantOopReadValue(stream); break;
-   case CONSTANT_LONG_CODE:   result = new ConstantLongValue(stream);    break;
-   case CONSTANT_DOUBLE_CODE: result = new ConstantDoubleValue(stream);  break;
-   case OBJECT_CODE:          result = stream->read_object_value();      break;
-   case OBJECT_ID_CODE:       result = stream->get_cached_object();      break;
+   case LOCATION_CODE:        result = new LocationValue(stream);                        break;
+   case CONSTANT_INT_CODE:    result = new ConstantIntValue(stream);                     break;
+   case CONSTANT_OOP_CODE:    result = new ConstantOopReadValue(stream);                 break;
+   case CONSTANT_LONG_CODE:   result = new ConstantLongValue(stream);                    break;
+   case CONSTANT_DOUBLE_CODE: result = new ConstantDoubleValue(stream);                  break;
+   case OBJECT_CODE:          result = stream->read_object_value(false /*is_auto_box*/); break;
+   case AUTO_BOX_OBJECT_CODE: result = stream->read_object_value(true /*is_auto_box*/);  break;
+   case OBJECT_ID_CODE:       result = stream->get_cached_object();                      break;
    default: ShouldNotReachHere();
   }
   return result;
 }
 
@@ -139,11 +150,11 @@
   if (_visited) {
     stream->write_int(OBJECT_ID_CODE);
     stream->write_int(_id);
   } else {
     _visited = true;
-    stream->write_int(OBJECT_CODE);
+    stream->write_int(is_auto_box() ? AUTO_BOX_OBJECT_CODE : OBJECT_CODE);
     stream->write_int(_id);
     _klass->write_on(stream);
     int length = _field_values.length();
     stream->write_int(length);
     for (int i = 0; i < length; i++) {
@@ -151,11 +162,11 @@
     }
   }
 }
 
 void ObjectValue::print_on(outputStream* st) const {
-  st->print("obj[%d]", _id);
+  st->print("%s[%d]", is_auto_box() ? "box_obj" : "obj", _id);
 }
 
 void ObjectValue::print_fields_on(outputStream* st) const {
 #ifndef PRODUCT
   if (_field_values.length() > 0) {
@@ -220,11 +231,11 @@
   {
     // cannot use ThreadInVMfromNative here since in case of JVMCI compiler,
     // thread is already in VM state.
     ThreadInVMfromUnknown tiv;
     assert(JNIHandles::resolve(value()) == NULL ||
-           Universe::heap()->is_in_reserved(JNIHandles::resolve(value())),
+           Universe::heap()->is_in(JNIHandles::resolve(value())),
            "Should be in heap");
  }
 #endif
   stream->write_int(CONSTANT_OOP_CODE);
   stream->write_handle(value());
@@ -241,11 +252,11 @@
 // ConstantOopReadValue
 
 ConstantOopReadValue::ConstantOopReadValue(DebugInfoReadStream* stream) {
   _value = Handle(Thread::current(), stream->read_oop());
   assert(_value() == NULL ||
-         Universe::heap()->is_in_reserved(_value()), "Should be in heap");
+         Universe::heap()->is_in(_value()), "Should be in heap");
 }
 
 void ConstantOopReadValue::write_on(DebugInfoWriteStream* stream) {
   ShouldNotReachHere();
 }

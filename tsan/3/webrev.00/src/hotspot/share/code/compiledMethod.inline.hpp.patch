diff a/src/hotspot/share/code/compiledMethod.inline.hpp b/src/hotspot/share/code/compiledMethod.inline.hpp
--- a/src/hotspot/share/code/compiledMethod.inline.hpp
+++ b/src/hotspot/share/code/compiledMethod.inline.hpp
@@ -25,12 +25,12 @@
 #ifndef SHARE_CODE_COMPILEDMETHOD_INLINE_HPP
 #define SHARE_CODE_COMPILEDMETHOD_INLINE_HPP
 
 #include "code/compiledMethod.hpp"
 #include "code/nativeInst.hpp"
+#include "runtime/atomic.hpp"
 #include "runtime/frame.hpp"
-#include "runtime/orderAccess.hpp"
 
 inline bool CompiledMethod::is_deopt_pc(address pc) { return is_deopt_entry(pc) || is_deopt_mh_entry(pc); }
 
 // When using JVMCI the address might be off by the size of a call instruction.
 inline bool CompiledMethod::is_deopt_entry(address pc) {
@@ -59,11 +59,11 @@
 }
 
 
 // class ExceptionCache methods
 
-inline int ExceptionCache::count() { return OrderAccess::load_acquire(&_count); }
+inline int ExceptionCache::count() { return Atomic::load_acquire(&_count); }
 
 address ExceptionCache::pc_at(int index) {
   assert(index >= 0 && index < count(),"");
   return _pc[index];
 }
@@ -72,9 +72,9 @@
   assert(index >= 0 && index < count(),"");
   return _handler[index];
 }
 
 // increment_count is only called under lock, but there may be concurrent readers.
-inline void ExceptionCache::increment_count() { OrderAccess::release_store(&_count, _count + 1); }
+inline void ExceptionCache::increment_count() { Atomic::release_store(&_count, _count + 1); }
 
 
 #endif // SHARE_CODE_COMPILEDMETHOD_INLINE_HPP

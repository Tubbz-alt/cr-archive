<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/code/compiledMethod.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compiledIC.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compiledMethod.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/compiledMethod.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/compiledIC.hpp&quot;
 27 #include &quot;code/compiledMethod.inline.hpp&quot;

 28 #include &quot;code/scopeDesc.hpp&quot;
 29 #include &quot;code/codeCache.hpp&quot;
 30 #include &quot;code/icBuffer.hpp&quot;
 31 #include &quot;gc/shared/barrierSet.hpp&quot;

 32 #include &quot;gc/shared/gcBehaviours.hpp&quot;
 33 #include &quot;interpreter/bytecode.inline.hpp&quot;
 34 #include &quot;logging/log.hpp&quot;
 35 #include &quot;logging/logTag.hpp&quot;
 36 #include &quot;memory/resourceArea.hpp&quot;
 37 #include &quot;oops/methodData.hpp&quot;
 38 #include &quot;oops/method.inline.hpp&quot;
 39 #include &quot;prims/methodHandles.hpp&quot;


 40 #include &quot;runtime/handles.inline.hpp&quot;
 41 #include &quot;runtime/mutexLocker.hpp&quot;

 42 
 43 CompiledMethod::CompiledMethod(Method* method, const char* name, CompilerType type, const CodeBlobLayout&amp; layout,
 44                                int frame_complete_offset, int frame_size, ImmutableOopMapSet* oop_maps,
 45                                bool caller_must_gc_arguments)
 46   : CodeBlob(name, type, layout, frame_complete_offset, frame_size, oop_maps, caller_must_gc_arguments),
 47     _mark_for_deoptimization_status(not_marked),
 48     _method(method),
 49     _gc_data(NULL)
 50 {
 51   init_defaults();
 52 }
 53 
 54 CompiledMethod::CompiledMethod(Method* method, const char* name, CompilerType type, int size,
 55                                int header_size, CodeBuffer* cb, int frame_complete_offset, int frame_size,
 56                                OopMapSet* oop_maps, bool caller_must_gc_arguments)
 57   : CodeBlob(name, type, CodeBlobLayout((address) this, size, header_size, cb), cb,
 58              frame_complete_offset, frame_size, oop_maps, caller_must_gc_arguments),
 59     _mark_for_deoptimization_status(not_marked),
 60     _method(method),
 61     _gc_data(NULL)
</pre>
<hr />
<pre>
 83   int state = get_state();
 84   switch (state) {
 85   case not_installed:
 86     return &quot;not installed&quot;;
 87   case in_use:
 88     return &quot;in use&quot;;
 89   case not_used:
 90     return &quot;not_used&quot;;
 91   case not_entrant:
 92     return &quot;not_entrant&quot;;
 93   case zombie:
 94     return &quot;zombie&quot;;
 95   case unloaded:
 96     return &quot;unloaded&quot;;
 97   default:
 98     fatal(&quot;unexpected method state: %d&quot;, state);
 99     return NULL;
100   }
101 }
102 







103 //-----------------------------------------------------------------------------
104 
105 ExceptionCache* CompiledMethod::exception_cache_acquire() const {
<span class="line-modified">106   return OrderAccess::load_acquire(&amp;_exception_cache);</span>
107 }
108 
109 void CompiledMethod::add_exception_cache_entry(ExceptionCache* new_entry) {
110   assert(ExceptionCache_lock-&gt;owned_by_self(),&quot;Must hold the ExceptionCache_lock&quot;);
111   assert(new_entry != NULL,&quot;Must be non null&quot;);
112   assert(new_entry-&gt;next() == NULL, &quot;Must be null&quot;);
113 
114   for (;;) {
115     ExceptionCache *ec = exception_cache();
116     if (ec != NULL) {
117       Klass* ex_klass = ec-&gt;exception_type();
118       if (!ex_klass-&gt;is_loader_alive()) {
119         // We must guarantee that entries are not inserted with new next pointer
120         // edges to ExceptionCache entries with dead klasses, due to bad interactions
121         // with concurrent ExceptionCache cleanup. Therefore, the inserts roll
122         // the head pointer forward to the first live ExceptionCache, so that the new
123         // next pointers always point at live ExceptionCaches, that are not removed due
124         // to concurrent ExceptionCache cleanup.
125         ExceptionCache* next = ec-&gt;next();
<span class="line-modified">126         if (Atomic::cmpxchg(next, &amp;_exception_cache, ec) == ec) {</span>
127           CodeCache::release_exception_cache(ec);
128         }
129         continue;
130       }
131       ec = exception_cache();
132       if (ec != NULL) {
133         new_entry-&gt;set_next(ec);
134       }
135     }
<span class="line-modified">136     if (Atomic::cmpxchg(new_entry, &amp;_exception_cache, ec) == ec) {</span>
137       return;
138     }
139   }
140 }
141 
142 void CompiledMethod::clean_exception_cache() {
143   // For each nmethod, only a single thread may call this cleanup function
144   // at the same time, whether called in STW cleanup or concurrent cleanup.
145   // Note that if the GC is processing exception cache cleaning in a concurrent phase,
146   // then a single writer may contend with cleaning up the head pointer to the
147   // first ExceptionCache node that has a Klass* that is alive. That is fine,
148   // as long as there is no concurrent cleanup of next pointers from concurrent writers.
149   // And the concurrent writers do not clean up next pointers, only the head.
150   // Also note that concurent readers will walk through Klass* pointers that are not
151   // alive. That does not cause ABA problems, because Klass* is deleted after
152   // a handshake with all threads, after all stale ExceptionCaches have been
153   // unlinked. That is also when the CodeCache::exception_cache_purge_list()
154   // is deleted, with all ExceptionCache entries that were cleaned concurrently.
155   // That similarly implies that CAS operations on ExceptionCache entries do not
156   // suffer from ABA problems as unlinking and deletion is separated by a global
157   // handshake operation.
158   ExceptionCache* prev = NULL;
159   ExceptionCache* curr = exception_cache_acquire();
160 
161   while (curr != NULL) {
162     ExceptionCache* next = curr-&gt;next();
163 
164     if (!curr-&gt;exception_type()-&gt;is_loader_alive()) {
165       if (prev == NULL) {
166         // Try to clean head; this is contended by concurrent inserts, that
167         // both lazily clean the head, and insert entries at the head. If
168         // the CAS fails, the operation is restarted.
<span class="line-modified">169         if (Atomic::cmpxchg(next, &amp;_exception_cache, curr) != curr) {</span>
170           prev = NULL;
171           curr = exception_cache_acquire();
172           continue;
173         }
174       } else {
175         // It is impossible to during cleanup connect the next pointer to
176         // an ExceptionCache that has not been published before a safepoint
177         // prior to the cleanup. Therefore, release is not required.
178         prev-&gt;set_next(next);
179       }
180       // prev stays the same.
181 
182       CodeCache::release_exception_cache(curr);
183     } else {
184       prev = curr;
185     }
186 
187     curr = next;
188   }
189 }
</pre>
<hr />
<pre>
328         CompiledIC *ic = CompiledIC_at(&amp;iter);
329         if (TraceCompiledIC) {
330           tty-&gt;print(&quot;noticed icholder &quot; INTPTR_FORMAT &quot; &quot;, p2i(ic-&gt;cached_icholder()));
331           ic-&gt;print();
332         }
333         assert(ic-&gt;cached_icholder() != NULL, &quot;must be non-NULL&quot;);
334         count++;
335       }
336     }
337   }
338 
339   return count;
340 }
341 
342 // Method that knows how to preserve outgoing arguments at call. This method must be
343 // called with a frame corresponding to a Java invoke
344 void CompiledMethod::preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, OopClosure* f) {
345   if (method() != NULL &amp;&amp; !method()-&gt;is_native()) {
346     address pc = fr.pc();
347     SimpleScopeDesc ssd(this, pc);
<span class="line-modified">348     Bytecode_invoke call(ssd.method(), ssd.bci());</span>
349     bool has_receiver = call.has_receiver();
350     bool has_appendix = call.has_appendix();
351     Symbol* signature = call.signature();
352 
353     // The method attached by JIT-compilers should be used, if present.
354     // Bytecode can be inaccurate in such case.
355     Method* callee = attached_method_before_pc(pc);
356     if (callee != NULL) {
357       has_receiver = !(callee-&gt;access_flags().is_static());
358       has_appendix = false;
359       signature = callee-&gt;signature();
360     }
361 
362     fr.oops_compiled_arguments_do(signature, has_receiver, has_appendix, reg_map, f);
363   }
364 }
365 
366 Method* CompiledMethod::attached_method(address call_instr) {
367   assert(code_contains(call_instr), &quot;not part of the nmethod&quot;);
368   RelocIterator iter(this, call_instr, call_instr + 1);
</pre>
<hr />
<pre>
398     iter.reloc()-&gt;clear_inline_cache();
399   }
400 }
401 
402 // Clear IC callsites, releasing ICStubs of all compiled ICs
403 // as well as any associated CompiledICHolders.
404 void CompiledMethod::clear_ic_callsites() {
405   assert(CompiledICLocker::is_safe(this), &quot;mt unsafe call&quot;);
406   ResourceMark rm;
407   RelocIterator iter(this);
408   while(iter.next()) {
409     if (iter.type() == relocInfo::virtual_call_type) {
410       CompiledIC* ic = CompiledIC_at(&amp;iter);
411       ic-&gt;set_to_clean(false);
412     }
413   }
414 }
415 
416 #ifdef ASSERT
417 // Check class_loader is alive for this bit of metadata.
<span class="line-modified">418 static void check_class(Metadata* md) {</span>
<span class="line-modified">419    Klass* klass = NULL;</span>
<span class="line-modified">420    if (md-&gt;is_klass()) {</span>
<span class="line-modified">421      klass = ((Klass*)md);</span>
<span class="line-modified">422    } else if (md-&gt;is_method()) {</span>
<span class="line-modified">423      klass = ((Method*)md)-&gt;method_holder();</span>
<span class="line-modified">424    } else if (md-&gt;is_methodData()) {</span>
<span class="line-modified">425      klass = ((MethodData*)md)-&gt;method()-&gt;method_holder();</span>
<span class="line-modified">426    } else {</span>
<span class="line-modified">427      md-&gt;print();</span>
<span class="line-modified">428      ShouldNotReachHere();</span>
<span class="line-modified">429    }</span>
<span class="line-modified">430    assert(klass-&gt;is_loader_alive(), &quot;must be alive&quot;);</span>
<span class="line-modified">431 }</span>


432 #endif // ASSERT
433 
434 
435 bool CompiledMethod::clean_ic_if_metadata_is_dead(CompiledIC *ic) {
436   if (ic-&gt;is_clean()) {
437     return true;
438   }
439   if (ic-&gt;is_icholder_call()) {
440     // The only exception is compiledICHolder metdata which may
441     // yet be marked below. (We check this further below).
442     CompiledICHolder* cichk_metdata = ic-&gt;cached_icholder();
443 
444     if (cichk_metdata-&gt;is_loader_alive()) {
445       return true;
446     }
447   } else {
448     Metadata* ic_metdata = ic-&gt;cached_metadata();
449     if (ic_metdata != NULL) {
450       if (ic_metdata-&gt;is_klass()) {
451         if (((Klass*)ic_metdata)-&gt;is_loader_alive()) {
452           return true;
453         }
454       } else if (ic_metdata-&gt;is_method()) {
455         Method* method = (Method*)ic_metdata;
456         assert(!method-&gt;is_old(), &quot;old method should have been cleaned&quot;);
457         if (method-&gt;method_holder()-&gt;is_loader_alive()) {
458           return true;
459         }
460       } else {
461         ShouldNotReachHere();
462       }
463     }
464   }
465 
466   return ic-&gt;set_to_clean();
467 }
468 
<span class="line-removed">469 // static_stub_Relocations may have dangling references to</span>
<span class="line-removed">470 // nmethods so trim them out here.  Otherwise it looks like</span>
<span class="line-removed">471 // compiled code is maintaining a link to dead metadata.</span>
<span class="line-removed">472 void CompiledMethod::clean_ic_stubs() {</span>
<span class="line-removed">473 #ifdef ASSERT</span>
<span class="line-removed">474   address low_boundary = oops_reloc_begin();</span>
<span class="line-removed">475   RelocIterator iter(this, low_boundary);</span>
<span class="line-removed">476   while (iter.next()) {</span>
<span class="line-removed">477     address static_call_addr = NULL;</span>
<span class="line-removed">478     if (iter.type() == relocInfo::opt_virtual_call_type) {</span>
<span class="line-removed">479       CompiledIC* cic = CompiledIC_at(&amp;iter);</span>
<span class="line-removed">480       if (!cic-&gt;is_call_to_interpreted()) {</span>
<span class="line-removed">481         static_call_addr = iter.addr();</span>
<span class="line-removed">482       }</span>
<span class="line-removed">483     } else if (iter.type() == relocInfo::static_call_type) {</span>
<span class="line-removed">484       CompiledStaticCall* csc = compiledStaticCall_at(iter.reloc());</span>
<span class="line-removed">485       if (!csc-&gt;is_call_to_interpreted()) {</span>
<span class="line-removed">486         static_call_addr = iter.addr();</span>
<span class="line-removed">487       }</span>
<span class="line-removed">488     }</span>
<span class="line-removed">489     if (static_call_addr != NULL) {</span>
<span class="line-removed">490       RelocIterator sciter(this, low_boundary);</span>
<span class="line-removed">491       while (sciter.next()) {</span>
<span class="line-removed">492         if (sciter.type() == relocInfo::static_stub_type &amp;&amp;</span>
<span class="line-removed">493             sciter.static_stub_reloc()-&gt;static_call() == static_call_addr) {</span>
<span class="line-removed">494           sciter.static_stub_reloc()-&gt;clear_inline_cache();</span>
<span class="line-removed">495         }</span>
<span class="line-removed">496       }</span>
<span class="line-removed">497     }</span>
<span class="line-removed">498   }</span>
<span class="line-removed">499 #endif</span>
<span class="line-removed">500 }</span>
<span class="line-removed">501 </span>
502 // Clean references to unloaded nmethods at addr from this one, which is not unloaded.
503 template &lt;class CompiledICorStaticCall&gt;
504 static bool clean_if_nmethod_is_unloaded(CompiledICorStaticCall *ic, address addr, CompiledMethod* from,
505                                          bool clean_all) {
506   // Ok, to lookup references to zombies here
507   CodeBlob *cb = CodeCache::find_blob_unsafe(addr);
508   CompiledMethod* nm = (cb != NULL) ? cb-&gt;as_compiled_method_or_null() : NULL;
509   if (nm != NULL) {
510     // Clean inline caches pointing to both zombie and not_entrant methods
511     if (clean_all || !nm-&gt;is_in_use() || nm-&gt;is_unloading() || (nm-&gt;method()-&gt;code() != nm)) {
<span class="line-modified">512       if (!ic-&gt;set_to_clean(from-&gt;is_alive())) {</span>













513         return false;
514       }
515       assert(ic-&gt;is_clean(), &quot;nmethod &quot; PTR_FORMAT &quot;not clean %s&quot;, p2i(from), from-&gt;method()-&gt;name_and_sig_as_C_string());
516     }
517   }
518   return true;
519 }
520 
521 static bool clean_if_nmethod_is_unloaded(CompiledIC *ic, CompiledMethod* from,
522                                          bool clean_all) {
523   return clean_if_nmethod_is_unloaded(ic, ic-&gt;ic_destination(), from, clean_all);
524 }
525 
526 static bool clean_if_nmethod_is_unloaded(CompiledStaticCall *csc, CompiledMethod* from,
527                                          bool clean_all) {
528   return clean_if_nmethod_is_unloaded(csc, csc-&gt;destination(), from, clean_all);
529 }
530 
531 // Cleans caches in nmethods that point to either classes that are unloaded
532 // or nmethods that are unloaded.
533 //
534 // Can be called either in parallel by G1 currently or after all
535 // nmethods are unloaded.  Return postponed=true in the parallel case for
536 // inline caches found that point to nmethods that are not yet visited during
537 // the do_unloading walk.
538 bool CompiledMethod::unload_nmethod_caches(bool unloading_occurred) {
539   ResourceMark rm;
540 
541   // Exception cache only needs to be called if unloading occurred
542   if (unloading_occurred) {
543     clean_exception_cache();
544   }
545 
546   if (!cleanup_inline_caches_impl(unloading_occurred, false)) {
547     return false;
548   }
549 
<span class="line-modified">550   // All static stubs need to be cleaned.</span>
<span class="line-removed">551   clean_ic_stubs();</span>
<span class="line-removed">552 </span>
553   // Check that the metadata embedded in the nmethod is alive
<span class="line-modified">554   DEBUG_ONLY(metadata_do(check_class));</span>


555   return true;
556 }
557 















558 void CompiledMethod::cleanup_inline_caches(bool clean_all) {
559   for (;;) {
560     ICRefillVerifier ic_refill_verifier;
561     { CompiledICLocker ic_locker(this);
562       if (cleanup_inline_caches_impl(false, clean_all)) {
563         return;
564       }
565     }


566     InlineCacheBuffer::refill_ic_stubs();
567   }
568 }
569 
570 // Called to clean up after class unloading for live nmethods and from the sweeper
571 // for all methods.
572 bool CompiledMethod::cleanup_inline_caches_impl(bool unloading_occurred, bool clean_all) {
573   assert(CompiledICLocker::is_safe(this), &quot;mt unsafe call&quot;);
574   ResourceMark rm;
575 
576   // Find all calls in an nmethod and clear the ones that point to non-entrant,
577   // zombie and unloaded nmethods.
578   RelocIterator iter(this, oops_reloc_begin());

579   while(iter.next()) {
580 
581     switch (iter.type()) {
582 
583     case relocInfo::virtual_call_type:
584       if (unloading_occurred) {
585         // If class unloading occurred we first clear ICs where the cached metadata
586         // is referring to an unloaded klass or method.
587         if (!clean_ic_if_metadata_is_dead(CompiledIC_at(&amp;iter))) {
588           return false;
589         }
590       }
591 
592       if (!clean_if_nmethod_is_unloaded(CompiledIC_at(&amp;iter), this, clean_all)) {
593         return false;
594       }
595       break;
596 
597     case relocInfo::opt_virtual_call_type:
598       if (!clean_if_nmethod_is_unloaded(CompiledIC_at(&amp;iter), this, clean_all)) {
599         return false;
600       }
601       break;
602 
603     case relocInfo::static_call_type:
604       if (!clean_if_nmethod_is_unloaded(compiledStaticCall_at(iter.reloc()), this, clean_all)) {
605         return false;
606       }
607       break;
608 







































609     default:
610       break;
611     }
612   }
613 
614   return true;
615 }
616 
617 // Iterating over all nmethods, e.g. with the help of CodeCache::nmethods_do(fun) was found
618 // to not be inherently safe. There is a chance that fields are seen which are not properly
619 // initialized. This happens despite the fact that nmethods_do() asserts the CodeCache_lock
620 // to be held.
621 // To bundle knowledge about necessary checks in one place, this function was introduced.
622 // It is not claimed that these checks are sufficient, but they were found to be necessary.
623 bool CompiledMethod::nmethod_access_is_safe(nmethod* nm) {
624   Method* method = (nm == NULL) ? NULL : nm-&gt;method();  // nm-&gt;method() may be uninitialized, i.e. != NULL, but invalid
625   return (nm != NULL) &amp;&amp; (method != NULL) &amp;&amp; (method-&gt;signature() != NULL) &amp;&amp;
626          !nm-&gt;is_zombie() &amp;&amp; !nm-&gt;is_not_installed() &amp;&amp;
627          os::is_readable_pointer(method) &amp;&amp;
628          os::is_readable_pointer(method-&gt;constants()) &amp;&amp;
629          os::is_readable_pointer(method-&gt;signature());
630 }








































































</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/compiledIC.hpp&quot;
 27 #include &quot;code/compiledMethod.inline.hpp&quot;
<span class="line-added"> 28 #include &quot;code/exceptionHandlerTable.hpp&quot;</span>
 29 #include &quot;code/scopeDesc.hpp&quot;
 30 #include &quot;code/codeCache.hpp&quot;
 31 #include &quot;code/icBuffer.hpp&quot;
 32 #include &quot;gc/shared/barrierSet.hpp&quot;
<span class="line-added"> 33 #include &quot;gc/shared/barrierSetNMethod.hpp&quot;</span>
 34 #include &quot;gc/shared/gcBehaviours.hpp&quot;
 35 #include &quot;interpreter/bytecode.inline.hpp&quot;
 36 #include &quot;logging/log.hpp&quot;
 37 #include &quot;logging/logTag.hpp&quot;
 38 #include &quot;memory/resourceArea.hpp&quot;
 39 #include &quot;oops/methodData.hpp&quot;
 40 #include &quot;oops/method.inline.hpp&quot;
 41 #include &quot;prims/methodHandles.hpp&quot;
<span class="line-added"> 42 #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-added"> 43 #include &quot;runtime/deoptimization.hpp&quot;</span>
 44 #include &quot;runtime/handles.inline.hpp&quot;
 45 #include &quot;runtime/mutexLocker.hpp&quot;
<span class="line-added"> 46 #include &quot;runtime/sharedRuntime.hpp&quot;</span>
 47 
 48 CompiledMethod::CompiledMethod(Method* method, const char* name, CompilerType type, const CodeBlobLayout&amp; layout,
 49                                int frame_complete_offset, int frame_size, ImmutableOopMapSet* oop_maps,
 50                                bool caller_must_gc_arguments)
 51   : CodeBlob(name, type, layout, frame_complete_offset, frame_size, oop_maps, caller_must_gc_arguments),
 52     _mark_for_deoptimization_status(not_marked),
 53     _method(method),
 54     _gc_data(NULL)
 55 {
 56   init_defaults();
 57 }
 58 
 59 CompiledMethod::CompiledMethod(Method* method, const char* name, CompilerType type, int size,
 60                                int header_size, CodeBuffer* cb, int frame_complete_offset, int frame_size,
 61                                OopMapSet* oop_maps, bool caller_must_gc_arguments)
 62   : CodeBlob(name, type, CodeBlobLayout((address) this, size, header_size, cb), cb,
 63              frame_complete_offset, frame_size, oop_maps, caller_must_gc_arguments),
 64     _mark_for_deoptimization_status(not_marked),
 65     _method(method),
 66     _gc_data(NULL)
</pre>
<hr />
<pre>
 88   int state = get_state();
 89   switch (state) {
 90   case not_installed:
 91     return &quot;not installed&quot;;
 92   case in_use:
 93     return &quot;in use&quot;;
 94   case not_used:
 95     return &quot;not_used&quot;;
 96   case not_entrant:
 97     return &quot;not_entrant&quot;;
 98   case zombie:
 99     return &quot;zombie&quot;;
100   case unloaded:
101     return &quot;unloaded&quot;;
102   default:
103     fatal(&quot;unexpected method state: %d&quot;, state);
104     return NULL;
105   }
106 }
107 
<span class="line-added">108 //-----------------------------------------------------------------------------</span>
<span class="line-added">109 void CompiledMethod::mark_for_deoptimization(bool inc_recompile_counts) {</span>
<span class="line-added">110   MutexLocker ml(CompiledMethod_lock-&gt;owned_by_self() ? NULL : CompiledMethod_lock,</span>
<span class="line-added">111                  Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">112   _mark_for_deoptimization_status = (inc_recompile_counts ? deoptimize : deoptimize_noupdate);</span>
<span class="line-added">113 }</span>
<span class="line-added">114 </span>
115 //-----------------------------------------------------------------------------
116 
117 ExceptionCache* CompiledMethod::exception_cache_acquire() const {
<span class="line-modified">118   return Atomic::load_acquire(&amp;_exception_cache);</span>
119 }
120 
121 void CompiledMethod::add_exception_cache_entry(ExceptionCache* new_entry) {
122   assert(ExceptionCache_lock-&gt;owned_by_self(),&quot;Must hold the ExceptionCache_lock&quot;);
123   assert(new_entry != NULL,&quot;Must be non null&quot;);
124   assert(new_entry-&gt;next() == NULL, &quot;Must be null&quot;);
125 
126   for (;;) {
127     ExceptionCache *ec = exception_cache();
128     if (ec != NULL) {
129       Klass* ex_klass = ec-&gt;exception_type();
130       if (!ex_klass-&gt;is_loader_alive()) {
131         // We must guarantee that entries are not inserted with new next pointer
132         // edges to ExceptionCache entries with dead klasses, due to bad interactions
133         // with concurrent ExceptionCache cleanup. Therefore, the inserts roll
134         // the head pointer forward to the first live ExceptionCache, so that the new
135         // next pointers always point at live ExceptionCaches, that are not removed due
136         // to concurrent ExceptionCache cleanup.
137         ExceptionCache* next = ec-&gt;next();
<span class="line-modified">138         if (Atomic::cmpxchg(&amp;_exception_cache, ec, next) == ec) {</span>
139           CodeCache::release_exception_cache(ec);
140         }
141         continue;
142       }
143       ec = exception_cache();
144       if (ec != NULL) {
145         new_entry-&gt;set_next(ec);
146       }
147     }
<span class="line-modified">148     if (Atomic::cmpxchg(&amp;_exception_cache, ec, new_entry) == ec) {</span>
149       return;
150     }
151   }
152 }
153 
154 void CompiledMethod::clean_exception_cache() {
155   // For each nmethod, only a single thread may call this cleanup function
156   // at the same time, whether called in STW cleanup or concurrent cleanup.
157   // Note that if the GC is processing exception cache cleaning in a concurrent phase,
158   // then a single writer may contend with cleaning up the head pointer to the
159   // first ExceptionCache node that has a Klass* that is alive. That is fine,
160   // as long as there is no concurrent cleanup of next pointers from concurrent writers.
161   // And the concurrent writers do not clean up next pointers, only the head.
162   // Also note that concurent readers will walk through Klass* pointers that are not
163   // alive. That does not cause ABA problems, because Klass* is deleted after
164   // a handshake with all threads, after all stale ExceptionCaches have been
165   // unlinked. That is also when the CodeCache::exception_cache_purge_list()
166   // is deleted, with all ExceptionCache entries that were cleaned concurrently.
167   // That similarly implies that CAS operations on ExceptionCache entries do not
168   // suffer from ABA problems as unlinking and deletion is separated by a global
169   // handshake operation.
170   ExceptionCache* prev = NULL;
171   ExceptionCache* curr = exception_cache_acquire();
172 
173   while (curr != NULL) {
174     ExceptionCache* next = curr-&gt;next();
175 
176     if (!curr-&gt;exception_type()-&gt;is_loader_alive()) {
177       if (prev == NULL) {
178         // Try to clean head; this is contended by concurrent inserts, that
179         // both lazily clean the head, and insert entries at the head. If
180         // the CAS fails, the operation is restarted.
<span class="line-modified">181         if (Atomic::cmpxchg(&amp;_exception_cache, curr, next) != curr) {</span>
182           prev = NULL;
183           curr = exception_cache_acquire();
184           continue;
185         }
186       } else {
187         // It is impossible to during cleanup connect the next pointer to
188         // an ExceptionCache that has not been published before a safepoint
189         // prior to the cleanup. Therefore, release is not required.
190         prev-&gt;set_next(next);
191       }
192       // prev stays the same.
193 
194       CodeCache::release_exception_cache(curr);
195     } else {
196       prev = curr;
197     }
198 
199     curr = next;
200   }
201 }
</pre>
<hr />
<pre>
340         CompiledIC *ic = CompiledIC_at(&amp;iter);
341         if (TraceCompiledIC) {
342           tty-&gt;print(&quot;noticed icholder &quot; INTPTR_FORMAT &quot; &quot;, p2i(ic-&gt;cached_icholder()));
343           ic-&gt;print();
344         }
345         assert(ic-&gt;cached_icholder() != NULL, &quot;must be non-NULL&quot;);
346         count++;
347       }
348     }
349   }
350 
351   return count;
352 }
353 
354 // Method that knows how to preserve outgoing arguments at call. This method must be
355 // called with a frame corresponding to a Java invoke
356 void CompiledMethod::preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, OopClosure* f) {
357   if (method() != NULL &amp;&amp; !method()-&gt;is_native()) {
358     address pc = fr.pc();
359     SimpleScopeDesc ssd(this, pc);
<span class="line-modified">360     Bytecode_invoke call(methodHandle(Thread::current(), ssd.method()), ssd.bci());</span>
361     bool has_receiver = call.has_receiver();
362     bool has_appendix = call.has_appendix();
363     Symbol* signature = call.signature();
364 
365     // The method attached by JIT-compilers should be used, if present.
366     // Bytecode can be inaccurate in such case.
367     Method* callee = attached_method_before_pc(pc);
368     if (callee != NULL) {
369       has_receiver = !(callee-&gt;access_flags().is_static());
370       has_appendix = false;
371       signature = callee-&gt;signature();
372     }
373 
374     fr.oops_compiled_arguments_do(signature, has_receiver, has_appendix, reg_map, f);
375   }
376 }
377 
378 Method* CompiledMethod::attached_method(address call_instr) {
379   assert(code_contains(call_instr), &quot;not part of the nmethod&quot;);
380   RelocIterator iter(this, call_instr, call_instr + 1);
</pre>
<hr />
<pre>
410     iter.reloc()-&gt;clear_inline_cache();
411   }
412 }
413 
414 // Clear IC callsites, releasing ICStubs of all compiled ICs
415 // as well as any associated CompiledICHolders.
416 void CompiledMethod::clear_ic_callsites() {
417   assert(CompiledICLocker::is_safe(this), &quot;mt unsafe call&quot;);
418   ResourceMark rm;
419   RelocIterator iter(this);
420   while(iter.next()) {
421     if (iter.type() == relocInfo::virtual_call_type) {
422       CompiledIC* ic = CompiledIC_at(&amp;iter);
423       ic-&gt;set_to_clean(false);
424     }
425   }
426 }
427 
428 #ifdef ASSERT
429 // Check class_loader is alive for this bit of metadata.
<span class="line-modified">430 class CheckClass : public MetadataClosure {</span>
<span class="line-modified">431   void do_metadata(Metadata* md) {</span>
<span class="line-modified">432     Klass* klass = NULL;</span>
<span class="line-modified">433     if (md-&gt;is_klass()) {</span>
<span class="line-modified">434       klass = ((Klass*)md);</span>
<span class="line-modified">435     } else if (md-&gt;is_method()) {</span>
<span class="line-modified">436       klass = ((Method*)md)-&gt;method_holder();</span>
<span class="line-modified">437     } else if (md-&gt;is_methodData()) {</span>
<span class="line-modified">438       klass = ((MethodData*)md)-&gt;method()-&gt;method_holder();</span>
<span class="line-modified">439     } else {</span>
<span class="line-modified">440       md-&gt;print();</span>
<span class="line-modified">441       ShouldNotReachHere();</span>
<span class="line-modified">442     }</span>
<span class="line-modified">443     assert(klass-&gt;is_loader_alive(), &quot;must be alive&quot;);</span>
<span class="line-added">444   }</span>
<span class="line-added">445 };</span>
446 #endif // ASSERT
447 
448 
449 bool CompiledMethod::clean_ic_if_metadata_is_dead(CompiledIC *ic) {
450   if (ic-&gt;is_clean()) {
451     return true;
452   }
453   if (ic-&gt;is_icholder_call()) {
454     // The only exception is compiledICHolder metdata which may
455     // yet be marked below. (We check this further below).
456     CompiledICHolder* cichk_metdata = ic-&gt;cached_icholder();
457 
458     if (cichk_metdata-&gt;is_loader_alive()) {
459       return true;
460     }
461   } else {
462     Metadata* ic_metdata = ic-&gt;cached_metadata();
463     if (ic_metdata != NULL) {
464       if (ic_metdata-&gt;is_klass()) {
465         if (((Klass*)ic_metdata)-&gt;is_loader_alive()) {
466           return true;
467         }
468       } else if (ic_metdata-&gt;is_method()) {
469         Method* method = (Method*)ic_metdata;
470         assert(!method-&gt;is_old(), &quot;old method should have been cleaned&quot;);
471         if (method-&gt;method_holder()-&gt;is_loader_alive()) {
472           return true;
473         }
474       } else {
475         ShouldNotReachHere();
476       }
477     }
478   }
479 
480   return ic-&gt;set_to_clean();
481 }
482 

































483 // Clean references to unloaded nmethods at addr from this one, which is not unloaded.
484 template &lt;class CompiledICorStaticCall&gt;
485 static bool clean_if_nmethod_is_unloaded(CompiledICorStaticCall *ic, address addr, CompiledMethod* from,
486                                          bool clean_all) {
487   // Ok, to lookup references to zombies here
488   CodeBlob *cb = CodeCache::find_blob_unsafe(addr);
489   CompiledMethod* nm = (cb != NULL) ? cb-&gt;as_compiled_method_or_null() : NULL;
490   if (nm != NULL) {
491     // Clean inline caches pointing to both zombie and not_entrant methods
492     if (clean_all || !nm-&gt;is_in_use() || nm-&gt;is_unloading() || (nm-&gt;method()-&gt;code() != nm)) {
<span class="line-modified">493       // Inline cache cleaning should only be initiated on CompiledMethods that have been</span>
<span class="line-added">494       // observed to be is_alive(). However, with concurrent code cache unloading, it is</span>
<span class="line-added">495       // possible that by now, the state has been racingly flipped to unloaded if the nmethod</span>
<span class="line-added">496       // being cleaned is_unloading(). This is fine, because if that happens, then the inline</span>
<span class="line-added">497       // caches have already been cleaned under the same CompiledICLocker that we now hold during</span>
<span class="line-added">498       // inline cache cleaning, and we will simply walk the inline caches again, and likely not</span>
<span class="line-added">499       // find much of interest to clean. However, this race prevents us from asserting that the</span>
<span class="line-added">500       // nmethod is_alive(). The is_unloading() function is completely monotonic; once set due</span>
<span class="line-added">501       // to an oop dying, it remains set forever until freed. Because of that, all unloaded</span>
<span class="line-added">502       // nmethods are is_unloading(), but notably, an unloaded nmethod may also subsequently</span>
<span class="line-added">503       // become zombie (when the sweeper converts it to zombie). Therefore, the most precise</span>
<span class="line-added">504       // sanity check we can check for in this context is to not allow zombies.</span>
<span class="line-added">505       assert(!from-&gt;is_zombie(), &quot;should not clean inline caches on zombies&quot;);</span>
<span class="line-added">506       if (!ic-&gt;set_to_clean(!from-&gt;is_unloading())) {</span>
507         return false;
508       }
509       assert(ic-&gt;is_clean(), &quot;nmethod &quot; PTR_FORMAT &quot;not clean %s&quot;, p2i(from), from-&gt;method()-&gt;name_and_sig_as_C_string());
510     }
511   }
512   return true;
513 }
514 
515 static bool clean_if_nmethod_is_unloaded(CompiledIC *ic, CompiledMethod* from,
516                                          bool clean_all) {
517   return clean_if_nmethod_is_unloaded(ic, ic-&gt;ic_destination(), from, clean_all);
518 }
519 
520 static bool clean_if_nmethod_is_unloaded(CompiledStaticCall *csc, CompiledMethod* from,
521                                          bool clean_all) {
522   return clean_if_nmethod_is_unloaded(csc, csc-&gt;destination(), from, clean_all);
523 }
524 
525 // Cleans caches in nmethods that point to either classes that are unloaded
526 // or nmethods that are unloaded.
527 //
528 // Can be called either in parallel by G1 currently or after all
529 // nmethods are unloaded.  Return postponed=true in the parallel case for
530 // inline caches found that point to nmethods that are not yet visited during
531 // the do_unloading walk.
532 bool CompiledMethod::unload_nmethod_caches(bool unloading_occurred) {
533   ResourceMark rm;
534 
535   // Exception cache only needs to be called if unloading occurred
536   if (unloading_occurred) {
537     clean_exception_cache();
538   }
539 
540   if (!cleanup_inline_caches_impl(unloading_occurred, false)) {
541     return false;
542   }
543 
<span class="line-modified">544 #ifdef ASSERT</span>


545   // Check that the metadata embedded in the nmethod is alive
<span class="line-modified">546   CheckClass check_class;</span>
<span class="line-added">547   metadata_do(&amp;check_class);</span>
<span class="line-added">548 #endif</span>
549   return true;
550 }
551 
<span class="line-added">552 void CompiledMethod::run_nmethod_entry_barrier() {</span>
<span class="line-added">553   BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()-&gt;barrier_set_nmethod();</span>
<span class="line-added">554   if (bs_nm != NULL) {</span>
<span class="line-added">555     // We want to keep an invariant that nmethods found through iterations of a Thread&#39;s</span>
<span class="line-added">556     // nmethods found in safepoints have gone through an entry barrier and are not armed.</span>
<span class="line-added">557     // By calling this nmethod entry barrier, it plays along and acts</span>
<span class="line-added">558     // like any other nmethod found on the stack of a thread (fewer surprises).</span>
<span class="line-added">559     nmethod* nm = as_nmethod_or_null();</span>
<span class="line-added">560     if (nm != NULL) {</span>
<span class="line-added">561       bool alive = bs_nm-&gt;nmethod_entry_barrier(nm);</span>
<span class="line-added">562       assert(alive, &quot;should be alive&quot;);</span>
<span class="line-added">563     }</span>
<span class="line-added">564   }</span>
<span class="line-added">565 }</span>
<span class="line-added">566 </span>
567 void CompiledMethod::cleanup_inline_caches(bool clean_all) {
568   for (;;) {
569     ICRefillVerifier ic_refill_verifier;
570     { CompiledICLocker ic_locker(this);
571       if (cleanup_inline_caches_impl(false, clean_all)) {
572         return;
573       }
574     }
<span class="line-added">575     // Call this nmethod entry barrier from the sweeper.</span>
<span class="line-added">576     run_nmethod_entry_barrier();</span>
577     InlineCacheBuffer::refill_ic_stubs();
578   }
579 }
580 
581 // Called to clean up after class unloading for live nmethods and from the sweeper
582 // for all methods.
583 bool CompiledMethod::cleanup_inline_caches_impl(bool unloading_occurred, bool clean_all) {
584   assert(CompiledICLocker::is_safe(this), &quot;mt unsafe call&quot;);
585   ResourceMark rm;
586 
587   // Find all calls in an nmethod and clear the ones that point to non-entrant,
588   // zombie and unloaded nmethods.
589   RelocIterator iter(this, oops_reloc_begin());
<span class="line-added">590   bool is_in_static_stub = false;</span>
591   while(iter.next()) {
592 
593     switch (iter.type()) {
594 
595     case relocInfo::virtual_call_type:
596       if (unloading_occurred) {
597         // If class unloading occurred we first clear ICs where the cached metadata
598         // is referring to an unloaded klass or method.
599         if (!clean_ic_if_metadata_is_dead(CompiledIC_at(&amp;iter))) {
600           return false;
601         }
602       }
603 
604       if (!clean_if_nmethod_is_unloaded(CompiledIC_at(&amp;iter), this, clean_all)) {
605         return false;
606       }
607       break;
608 
609     case relocInfo::opt_virtual_call_type:
610       if (!clean_if_nmethod_is_unloaded(CompiledIC_at(&amp;iter), this, clean_all)) {
611         return false;
612       }
613       break;
614 
615     case relocInfo::static_call_type:
616       if (!clean_if_nmethod_is_unloaded(compiledStaticCall_at(iter.reloc()), this, clean_all)) {
617         return false;
618       }
619       break;
620 
<span class="line-added">621     case relocInfo::static_stub_type: {</span>
<span class="line-added">622       is_in_static_stub = true;</span>
<span class="line-added">623       break;</span>
<span class="line-added">624     }</span>
<span class="line-added">625 </span>
<span class="line-added">626     case relocInfo::metadata_type: {</span>
<span class="line-added">627       // Only the metadata relocations contained in static/opt virtual call stubs</span>
<span class="line-added">628       // contains the Method* passed to c2i adapters. It is the only metadata</span>
<span class="line-added">629       // relocation that needs to be walked, as it is the one metadata relocation</span>
<span class="line-added">630       // that violates the invariant that all metadata relocations have an oop</span>
<span class="line-added">631       // in the compiled method (due to deferred resolution and code patching).</span>
<span class="line-added">632 </span>
<span class="line-added">633       // This causes dead metadata to remain in compiled methods that are not</span>
<span class="line-added">634       // unloading. Unless these slippery metadata relocations of the static</span>
<span class="line-added">635       // stubs are at least cleared, subsequent class redefinition operations</span>
<span class="line-added">636       // will access potentially free memory, and JavaThread execution</span>
<span class="line-added">637       // concurrent to class unloading may call c2i adapters with dead methods.</span>
<span class="line-added">638       if (!is_in_static_stub) {</span>
<span class="line-added">639         // The first metadata relocation after a static stub relocation is the</span>
<span class="line-added">640         // metadata relocation of the static stub used to pass the Method* to</span>
<span class="line-added">641         // c2i adapters.</span>
<span class="line-added">642         continue;</span>
<span class="line-added">643       }</span>
<span class="line-added">644       is_in_static_stub = false;</span>
<span class="line-added">645       metadata_Relocation* r = iter.metadata_reloc();</span>
<span class="line-added">646       Metadata* md = r-&gt;metadata_value();</span>
<span class="line-added">647       if (md != NULL &amp;&amp; md-&gt;is_method()) {</span>
<span class="line-added">648         Method* method = static_cast&lt;Method*&gt;(md);</span>
<span class="line-added">649         if (!method-&gt;method_holder()-&gt;is_loader_alive()) {</span>
<span class="line-added">650           Atomic::store(r-&gt;metadata_addr(), (Method*)NULL);</span>
<span class="line-added">651 </span>
<span class="line-added">652           if (!r-&gt;metadata_is_immediate()) {</span>
<span class="line-added">653             r-&gt;fix_metadata_relocation();</span>
<span class="line-added">654           }</span>
<span class="line-added">655         }</span>
<span class="line-added">656       }</span>
<span class="line-added">657       break;</span>
<span class="line-added">658     }</span>
<span class="line-added">659 </span>
660     default:
661       break;
662     }
663   }
664 
665   return true;
666 }
667 
668 // Iterating over all nmethods, e.g. with the help of CodeCache::nmethods_do(fun) was found
669 // to not be inherently safe. There is a chance that fields are seen which are not properly
670 // initialized. This happens despite the fact that nmethods_do() asserts the CodeCache_lock
671 // to be held.
672 // To bundle knowledge about necessary checks in one place, this function was introduced.
673 // It is not claimed that these checks are sufficient, but they were found to be necessary.
674 bool CompiledMethod::nmethod_access_is_safe(nmethod* nm) {
675   Method* method = (nm == NULL) ? NULL : nm-&gt;method();  // nm-&gt;method() may be uninitialized, i.e. != NULL, but invalid
676   return (nm != NULL) &amp;&amp; (method != NULL) &amp;&amp; (method-&gt;signature() != NULL) &amp;&amp;
677          !nm-&gt;is_zombie() &amp;&amp; !nm-&gt;is_not_installed() &amp;&amp;
678          os::is_readable_pointer(method) &amp;&amp;
679          os::is_readable_pointer(method-&gt;constants()) &amp;&amp;
680          os::is_readable_pointer(method-&gt;signature());
681 }
<span class="line-added">682 </span>
<span class="line-added">683 address CompiledMethod::continuation_for_implicit_exception(address pc, bool for_div0_check) {</span>
<span class="line-added">684   // Exception happened outside inline-cache check code =&gt; we are inside</span>
<span class="line-added">685   // an active nmethod =&gt; use cpc to determine a return address</span>
<span class="line-added">686   int exception_offset = pc - code_begin();</span>
<span class="line-added">687   int cont_offset = ImplicitExceptionTable(this).continuation_offset( exception_offset );</span>
<span class="line-added">688 #ifdef ASSERT</span>
<span class="line-added">689   if (cont_offset == 0) {</span>
<span class="line-added">690     Thread* thread = Thread::current();</span>
<span class="line-added">691     ResetNoHandleMark rnm; // Might be called from LEAF/QUICK ENTRY</span>
<span class="line-added">692     HandleMark hm(thread);</span>
<span class="line-added">693     ResourceMark rm(thread);</span>
<span class="line-added">694     CodeBlob* cb = CodeCache::find_blob(pc);</span>
<span class="line-added">695     assert(cb != NULL &amp;&amp; cb == this, &quot;&quot;);</span>
<span class="line-added">696     ttyLocker ttyl;</span>
<span class="line-added">697     tty-&gt;print_cr(&quot;implicit exception happened at &quot; INTPTR_FORMAT, p2i(pc));</span>
<span class="line-added">698     print();</span>
<span class="line-added">699     method()-&gt;print_codes();</span>
<span class="line-added">700     print_code();</span>
<span class="line-added">701     print_pcs();</span>
<span class="line-added">702   }</span>
<span class="line-added">703 #endif</span>
<span class="line-added">704   if (cont_offset == 0) {</span>
<span class="line-added">705     // Let the normal error handling report the exception</span>
<span class="line-added">706     return NULL;</span>
<span class="line-added">707   }</span>
<span class="line-added">708   if (cont_offset == exception_offset) {</span>
<span class="line-added">709 #if INCLUDE_JVMCI</span>
<span class="line-added">710     Deoptimization::DeoptReason deopt_reason = for_div0_check ? Deoptimization::Reason_div0_check : Deoptimization::Reason_null_check;</span>
<span class="line-added">711     JavaThread *thread = JavaThread::current();</span>
<span class="line-added">712     thread-&gt;set_jvmci_implicit_exception_pc(pc);</span>
<span class="line-added">713     thread-&gt;set_pending_deoptimization(Deoptimization::make_trap_request(deopt_reason,</span>
<span class="line-added">714                                                                          Deoptimization::Action_reinterpret));</span>
<span class="line-added">715     return (SharedRuntime::deopt_blob()-&gt;implicit_exception_uncommon_trap());</span>
<span class="line-added">716 #else</span>
<span class="line-added">717     ShouldNotReachHere();</span>
<span class="line-added">718 #endif</span>
<span class="line-added">719   }</span>
<span class="line-added">720   return code_begin() + cont_offset;</span>
<span class="line-added">721 }</span>
<span class="line-added">722 </span>
<span class="line-added">723 class HasEvolDependency : public MetadataClosure {</span>
<span class="line-added">724   bool _has_evol_dependency;</span>
<span class="line-added">725  public:</span>
<span class="line-added">726   HasEvolDependency() : _has_evol_dependency(false) {}</span>
<span class="line-added">727   void do_metadata(Metadata* md) {</span>
<span class="line-added">728     if (md-&gt;is_method()) {</span>
<span class="line-added">729       Method* method = (Method*)md;</span>
<span class="line-added">730       if (method-&gt;is_old()) {</span>
<span class="line-added">731         _has_evol_dependency = true;</span>
<span class="line-added">732       }</span>
<span class="line-added">733     }</span>
<span class="line-added">734   }</span>
<span class="line-added">735   bool has_evol_dependency() const { return _has_evol_dependency; }</span>
<span class="line-added">736 };</span>
<span class="line-added">737 </span>
<span class="line-added">738 bool CompiledMethod::has_evol_metadata() {</span>
<span class="line-added">739   // Check the metadata in relocIter and CompiledIC and also deoptimize</span>
<span class="line-added">740   // any nmethod that has reference to old methods.</span>
<span class="line-added">741   HasEvolDependency check_evol;</span>
<span class="line-added">742   metadata_do(&amp;check_evol);</span>
<span class="line-added">743   if (check_evol.has_evol_dependency() &amp;&amp; log_is_enabled(Debug, redefine, class, nmethod)) {</span>
<span class="line-added">744     ResourceMark rm;</span>
<span class="line-added">745     log_debug(redefine, class, nmethod)</span>
<span class="line-added">746             (&quot;Found evol dependency of nmethod %s.%s(%s) compile_id=%d on in nmethod metadata&quot;,</span>
<span class="line-added">747              _method-&gt;method_holder()-&gt;external_name(),</span>
<span class="line-added">748              _method-&gt;name()-&gt;as_C_string(),</span>
<span class="line-added">749              _method-&gt;signature()-&gt;as_C_string(),</span>
<span class="line-added">750              compile_id());</span>
<span class="line-added">751   }</span>
<span class="line-added">752   return check_evol.has_evol_dependency();</span>
<span class="line-added">753 }</span>
</pre>
</td>
</tr>
</table>
<center><a href="compiledIC.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compiledMethod.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
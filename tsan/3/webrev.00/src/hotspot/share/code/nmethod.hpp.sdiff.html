<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/code/nmethod.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="nmethod.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oopRecorder.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/nmethod.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CODE_NMETHOD_HPP
 26 #define SHARE_CODE_NMETHOD_HPP
 27 
 28 #include &quot;code/compiledMethod.hpp&quot;
 29 
 30 class DepChange;
 31 class DirectiveSet;
 32 class DebugInformationRecorder;

 33 
 34 // nmethods (native methods) are the compiled code versions of Java methods.
 35 //
 36 // An nmethod contains:
 37 //  - header                 (the nmethod structure)
 38 //  [Relocation]
 39 //  - relocation information
 40 //  - constant part          (doubles, longs and floats used in nmethod)
 41 //  - oop table
 42 //  [Code]
 43 //  - code body
 44 //  - exception handler
 45 //  - stub code
 46 //  [Debugging information]
 47 //  - oop array
 48 //  - data array
 49 //  - pcs
 50 //  [Exception handler table]
 51 //  - handler entry point array
 52 //  [Implicit Null Pointer exception table]
 53 //  - implicit null table array









 54 
 55 class nmethod : public CompiledMethod {
 56   friend class VMStructs;
 57   friend class JVMCIVMStructs;
 58   friend class NMethodSweeper;
 59   friend class CodeCache;  // scavengable oops
<span class="line-modified"> 60  private:</span>
 61 

 62   // Shared fields for all nmethod&#39;s
 63   int       _entry_bci;        // != InvocationEntryBci if this nmethod is an on-stack replacement method
<span class="line-removed"> 64   jmethodID _jmethod_id;       // Cache of method()-&gt;jmethod_id()</span>
<span class="line-removed"> 65 </span>
<span class="line-removed"> 66 #if INCLUDE_JVMCI</span>
<span class="line-removed"> 67   // A weak reference to an InstalledCode object associated with</span>
<span class="line-removed"> 68   // this nmethod.</span>
<span class="line-removed"> 69   jweak     _jvmci_installed_code;</span>
<span class="line-removed"> 70 </span>
<span class="line-removed"> 71   // A weak reference to a SpeculationLog object associated with</span>
<span class="line-removed"> 72   // this nmethod.</span>
<span class="line-removed"> 73   jweak     _speculation_log;</span>
<span class="line-removed"> 74 </span>
<span class="line-removed"> 75   // Determines whether this nmethod is unloaded when the</span>
<span class="line-removed"> 76   // referent in _jvmci_installed_code is cleared. This</span>
<span class="line-removed"> 77   // will be false if the referent is initialized to a</span>
<span class="line-removed"> 78   // HotSpotNMethod object whose isDefault field is true.</span>
<span class="line-removed"> 79   // That is, installed code other than a &quot;default&quot;</span>
<span class="line-removed"> 80   // HotSpotNMethod causes nmethod unloading.</span>
<span class="line-removed"> 81   // This field is ignored once _jvmci_installed_code is NULL.</span>
<span class="line-removed"> 82   bool _jvmci_installed_code_triggers_invalidation;</span>
<span class="line-removed"> 83 #endif</span>
 84 
 85   // To support simple linked-list chaining of nmethods:
 86   nmethod*  _osr_link;         // from InstanceKlass::osr_nmethods_head
 87 















































































































 88   static nmethod* volatile _oops_do_mark_nmethods;
<span class="line-modified"> 89   nmethod*        volatile _oops_do_mark_link;</span>
 90 
 91   // offsets for entry points
 92   address _entry_point;                      // entry point with class check
 93   address _verified_entry_point;             // entry point without class check
 94   address _osr_entry_point;                  // entry point for on stack replacement
 95 
 96   // Offsets for different nmethod parts
 97   int  _exception_offset;
 98   // Offset of the unwind handler if it exists
 99   int _unwind_handler_offset;
100 
101   int _consts_offset;
102   int _stub_offset;
103   int _oops_offset;                       // offset to where embedded oop table begins (inside data)
104   int _metadata_offset;                   // embedded meta data table
105   int _scopes_data_offset;
106   int _scopes_pcs_offset;
107   int _dependencies_offset;
108   int _handler_table_offset;
109   int _nul_chk_table_offset;




110   int _nmethod_end_offset;
111 
112   int code_offset() const { return (address) code_begin() - header_begin(); }
113 
114   // location in frame (offset for sp) that deopt can store the original
115   // pc during a deopt.
116   int _orig_pc_offset;
117 
118   int _compile_id;                           // which compilation made this nmethod
119   int _comp_level;                           // compilation level
120 
121   // protected by CodeCache_lock
122   bool _has_flushed_dependencies;            // Used for maintenance of dependencies (CodeCache_lock)
123 
<span class="line-modified">124   // used by jvmti to track if an unload event has been posted for this nmethod.</span>
125   bool _unload_reported;

126 
<span class="line-modified">127   // Protected by Patching_lock</span>
128   volatile signed char _state;               // {not_installed, in_use, not_entrant, zombie, unloaded}
129 
130 #ifdef ASSERT
131   bool _oops_are_stale;  // indicates that it&#39;s no longer safe to access oops section
132 #endif
133 
134 #if INCLUDE_RTM_OPT
135   // RTM state at compile time. Used during deoptimization to decide
136   // whether to restart collecting RTM locking abort statistic again.
137   RTMState _rtm_state;
138 #endif
139 
140   // Nmethod Flushing lock. If non-zero, then the nmethod is not removed
141   // and is not made into a zombie. However, once the nmethod is made into
142   // a zombie, it will be locked one final time if CompiledMethodUnload
143   // event processing needs to be done.
144   volatile jint _lock_count;
145 
146   // not_entrant method removal. Each mark_sweep pass will update
147   // this mark to current sweep invocation count if it is seen on the
</pre>
<hr />
<pre>
190           OopMapSet* oop_maps);
191 
192   // Creation support
193   nmethod(Method* method,
194           CompilerType type,
195           int nmethod_size,
196           int compile_id,
197           int entry_bci,
198           CodeOffsets* offsets,
199           int orig_pc_offset,
200           DebugInformationRecorder *recorder,
201           Dependencies* dependencies,
202           CodeBuffer *code_buffer,
203           int frame_size,
204           OopMapSet* oop_maps,
205           ExceptionHandlerTable* handler_table,
206           ImplicitExceptionTable* nul_chk_table,
207           AbstractCompiler* compiler,
208           int comp_level
209 #if INCLUDE_JVMCI
<span class="line-modified">210           , jweak installed_code,</span>
<span class="line-modified">211           jweak speculation_log</span>

212 #endif
213           );
214 
215   // helper methods
216   void* operator new(size_t size, int nmethod_size, int comp_level) throw();
217 
218   const char* reloc_string_for(u_char* begin, u_char* end);



219   // Returns true if this thread changed the state of the nmethod or
220   // false if another thread performed the transition.
221   bool make_not_entrant_or_zombie(int state);
222   bool make_entrant() { Unimplemented(); return false; }
223   void inc_decompile_count();
224 
225   // Inform external interfaces that a compiled method has been unloaded
226   void post_compiled_method_unload();
227 
228   // Initailize fields to their default values
229   void init_defaults();
230 
231   // Offsets
232   int content_offset() const                  { return content_begin() - header_begin(); }
233   int data_offset() const                     { return _data_offset; }
234 
235   address header_end() const                  { return (address)    header_begin() + header_size(); }
236 
237  public:
238   // create nmethod with entry_bci
239   static nmethod* new_nmethod(const methodHandle&amp; method,
240                               int compile_id,
241                               int entry_bci,
242                               CodeOffsets* offsets,
243                               int orig_pc_offset,
244                               DebugInformationRecorder* recorder,
245                               Dependencies* dependencies,
246                               CodeBuffer *code_buffer,
247                               int frame_size,
248                               OopMapSet* oop_maps,
249                               ExceptionHandlerTable* handler_table,
250                               ImplicitExceptionTable* nul_chk_table,
251                               AbstractCompiler* compiler,
252                               int comp_level
253 #if INCLUDE_JVMCI
<span class="line-modified">254                               , jweak installed_code = NULL,</span>
<span class="line-modified">255                               jweak speculation_log = NULL</span>



256 #endif
257   );
258 
259   // Only used for unit tests.
260   nmethod()
261     : CompiledMethod(),
262       _is_unloading_state(0),
263       _native_receiver_sp_offset(in_ByteSize(-1)),
264       _native_basic_lock_sp_offset(in_ByteSize(-1)) {}
265 
266 
267   static nmethod* new_native_nmethod(const methodHandle&amp; method,
268                                      int compile_id,
269                                      CodeBuffer *code_buffer,
270                                      int vep_offset,
271                                      int frame_complete,
272                                      int frame_size,
273                                      ByteSize receiver_sp_offset,
274                                      ByteSize basic_lock_sp_offset,
275                                      OopMapSet* oop_maps);
</pre>
<hr />
<pre>
282   address consts_begin          () const          { return           header_begin() + _consts_offset        ; }
283   address consts_end            () const          { return           code_begin()                           ; }
284   address stub_begin            () const          { return           header_begin() + _stub_offset          ; }
285   address stub_end              () const          { return           header_begin() + _oops_offset          ; }
286   address exception_begin       () const          { return           header_begin() + _exception_offset     ; }
287   address unwind_handler_begin  () const          { return _unwind_handler_offset != -1 ? (header_begin() + _unwind_handler_offset) : NULL; }
288   oop*    oops_begin            () const          { return (oop*)   (header_begin() + _oops_offset)         ; }
289   oop*    oops_end              () const          { return (oop*)   (header_begin() + _metadata_offset)     ; }
290 
291   Metadata** metadata_begin   () const            { return (Metadata**)  (header_begin() + _metadata_offset)     ; }
292   Metadata** metadata_end     () const            { return (Metadata**)  _scopes_data_begin; }
293 
294   address scopes_data_end       () const          { return           header_begin() + _scopes_pcs_offset    ; }
295   PcDesc* scopes_pcs_begin      () const          { return (PcDesc*)(header_begin() + _scopes_pcs_offset   ); }
296   PcDesc* scopes_pcs_end        () const          { return (PcDesc*)(header_begin() + _dependencies_offset) ; }
297   address dependencies_begin    () const          { return           header_begin() + _dependencies_offset  ; }
298   address dependencies_end      () const          { return           header_begin() + _handler_table_offset ; }
299   address handler_table_begin   () const          { return           header_begin() + _handler_table_offset ; }
300   address handler_table_end     () const          { return           header_begin() + _nul_chk_table_offset ; }
301   address nul_chk_table_begin   () const          { return           header_begin() + _nul_chk_table_offset ; }







302   address nul_chk_table_end     () const          { return           header_begin() + _nmethod_end_offset   ; }

303 
304   // Sizes
305   int oops_size         () const                  { return (address)  oops_end         () - (address)  oops_begin         (); }
306   int metadata_size     () const                  { return (address)  metadata_end     () - (address)  metadata_begin     (); }
307   int dependencies_size () const                  { return            dependencies_end () -            dependencies_begin (); }




308 
309   int     oops_count() const { assert(oops_size() % oopSize == 0, &quot;&quot;);  return (oops_size() / oopSize) + 1; }
310   int metadata_count() const { assert(metadata_size() % wordSize == 0, &quot;&quot;); return (metadata_size() / wordSize) + 1; }
311 
312   int total_size        () const;
313 
314   void dec_hotness_counter()        { _hotness_counter--; }
315   void set_hotness_counter(int val) { _hotness_counter = val; }
316   int  hotness_counter() const      { return _hotness_counter; }
317 
318   // Containment
319   bool oops_contains         (oop*    addr) const { return oops_begin         () &lt;= addr &amp;&amp; addr &lt; oops_end         (); }
320   bool metadata_contains     (Metadata** addr) const   { return metadata_begin     () &lt;= addr &amp;&amp; addr &lt; metadata_end     (); }
321   bool scopes_data_contains  (address addr) const { return scopes_data_begin  () &lt;= addr &amp;&amp; addr &lt; scopes_data_end  (); }
322   bool scopes_pcs_contains   (PcDesc* addr) const { return scopes_pcs_begin   () &lt;= addr &amp;&amp; addr &lt; scopes_pcs_end   (); }
323 
324   // entry points
325   address entry_point() const                     { return _entry_point;             } // normal entry point
326   address verified_entry_point() const            { return _verified_entry_point;    } // if klass is correct
327 
328   // flag accessing and manipulation
329   bool  is_not_installed() const                  { return _state == not_installed; }
330   bool  is_in_use() const                         { return _state &lt;= in_use; }
<span class="line-modified">331   bool  is_alive() const                          { return _state &lt; zombie; }</span>
332   bool  is_not_entrant() const                    { return _state == not_entrant; }
333   bool  is_zombie() const                         { return _state == zombie; }
334   bool  is_unloaded() const                       { return _state == unloaded; }
335 
336   void clear_unloading_state();
337   virtual bool is_unloading();
338   virtual void do_unloading(bool unloading_occurred);
339 
340 #if INCLUDE_RTM_OPT
341   // rtm state accessing and manipulating
342   RTMState  rtm_state() const                     { return _rtm_state; }
343   void set_rtm_state(RTMState state)              { _rtm_state = state; }
344 #endif
345 
<span class="line-modified">346   void make_in_use()                              { _state = in_use; }</span>


347   // Make the nmethod non entrant. The nmethod will continue to be
348   // alive.  It is used when an uncommon trap happens.  Returns true
349   // if this thread changed the state of the nmethod or false if
350   // another thread performed the transition.
351   bool  make_not_entrant() {
352     assert(!method()-&gt;is_method_handle_intrinsic(), &quot;Cannot make MH intrinsic not entrant&quot;);
353     return make_not_entrant_or_zombie(not_entrant);
354   }
355   bool  make_not_used()    { return make_not_entrant(); }
356   bool  make_zombie()      { return make_not_entrant_or_zombie(zombie); }
357 
<span class="line-removed">358   // used by jvmti to track if the unload event has been reported</span>
<span class="line-removed">359   bool  unload_reported()                         { return _unload_reported; }</span>
<span class="line-removed">360   void  set_unload_reported()                     { _unload_reported = true; }</span>
<span class="line-removed">361 </span>
362   int get_state() const {
363     return _state;
364   }
365 
366   void  make_unloaded();
367 
368   bool has_dependencies()                         { return dependencies_size() != 0; }

369   void flush_dependencies(bool delete_immediately);
370   bool has_flushed_dependencies()                 { return _has_flushed_dependencies; }
371   void set_has_flushed_dependencies()             {
372     assert(!has_flushed_dependencies(), &quot;should only happen once&quot;);
373     _has_flushed_dependencies = 1;
374   }
375 
376   int   comp_level() const                        { return _comp_level; }
377 
<span class="line-modified">378   void unlink_from_method(bool acquire_lock);</span>
379 
380   // Support for oops in scopes and relocs:
381   // Note: index 0 is reserved for null.
382   oop   oop_at(int index) const;

383   oop*  oop_addr_at(int index) const {  // for GC
384     // relocation indexes are biased by 1 (because 0 is reserved)
385     assert(index &gt; 0 &amp;&amp; index &lt;= oops_count(), &quot;must be a valid non-zero index&quot;);
386     assert(!_oops_are_stale, &quot;oops are stale&quot;);
387     return &amp;oops_begin()[index - 1];
388   }
389 
390   // Support for meta data in scopes and relocs:
391   // Note: index 0 is reserved for null.
392   Metadata*     metadata_at(int index) const      { return index == 0 ? NULL: *metadata_addr_at(index); }
393   Metadata**  metadata_addr_at(int index) const {  // for GC
394     // relocation indexes are biased by 1 (because 0 is reserved)
395     assert(index &gt; 0 &amp;&amp; index &lt;= metadata_count(), &quot;must be a valid non-zero index&quot;);
396     return &amp;metadata_begin()[index - 1];
397   }
398 
399   void copy_values(GrowableArray&lt;jobject&gt;* oops);
400   void copy_values(GrowableArray&lt;Metadata*&gt;* metadata);
401 
402   // Relocation support
403 private:
404   void fix_oop_relocations(address begin, address end, bool initialize_immediates);
405   inline void initialize_immediate_oop(oop* dest, jobject handle);
406 
407 public:
408   void fix_oop_relocations(address begin, address end) { fix_oop_relocations(begin, end, false); }
409   void fix_oop_relocations()                           { fix_oop_relocations(NULL, NULL, false); }
410 
411   // Sweeper support
412   long  stack_traversal_mark()                    { return _stack_traversal_mark; }
413   void  set_stack_traversal_mark(long l)          { _stack_traversal_mark = l; }
414 
<span class="line-removed">415   // implicit exceptions support</span>
<span class="line-removed">416   address continuation_for_implicit_exception(address pc);</span>
<span class="line-removed">417 </span>
418   // On-stack replacement support
419   int   osr_entry_bci() const                     { assert(is_osr_method(), &quot;wrong kind of nmethod&quot;); return _entry_bci; }
420   address  osr_entry() const                      { assert(is_osr_method(), &quot;wrong kind of nmethod&quot;); return _osr_entry_point; }
421   void  invalidate_osr_method();
422   nmethod* osr_link() const                       { return _osr_link; }
423   void     set_osr_link(nmethod *n)               { _osr_link = n; }
424 
425   // Verify calls to dead methods have been cleaned.
426   void verify_clean_inline_caches();
427 
428   // unlink and deallocate this nmethod
429   // Only NMethodSweeper class is expected to use this. NMethodSweeper is not
430   // expected to use any other private methods/data in this class.
431 
432  protected:
433   void flush();
434 
435  public:
436   // When true is returned, it is unsafe to remove this nmethod even if
437   // it is a zombie, since the VM or the ServiceThread might still be
438   // using it.
439   bool is_locked_by_vm() const                    { return _lock_count &gt;0; }
440 
441   // See comment at definition of _last_seen_on_stack
442   void mark_as_seen_on_stack();
443   bool can_convert_to_zombie();
444 
445   // Evolution support. We make old (discarded) compiled methods point to new Method*s.
446   void set_method(Method* method) { _method = method; }
447 
448 #if INCLUDE_JVMCI
<span class="line-modified">449   // Gets the InstalledCode object associated with this nmethod</span>
<span class="line-modified">450   // which may be NULL if this nmethod was not compiled by JVMCI</span>
<span class="line-modified">451   // or the weak reference has been cleared.</span>
<span class="line-modified">452   oop jvmci_installed_code();</span>
<span class="line-modified">453 </span>
<span class="line-modified">454   // Copies the value of the name field in the InstalledCode</span>
<span class="line-modified">455   // object (if any) associated with this nmethod into buf.</span>
<span class="line-modified">456   // Returns the value of buf if it was updated otherwise NULL.</span>
<span class="line-modified">457   char* jvmci_installed_code_name(char* buf, size_t buflen) const;</span>
<span class="line-modified">458 </span>
<span class="line-modified">459   // Updates the state of the InstalledCode (if any) associated with</span>
<span class="line-modified">460   // this nmethod based on the current value of _state.</span>
<span class="line-modified">461   void maybe_invalidate_installed_code();</span>
<span class="line-removed">462 </span>
<span class="line-removed">463   // Deoptimizes the nmethod (if any) in the address field of a given</span>
<span class="line-removed">464   // InstalledCode object. The address field is zeroed upon return.</span>
<span class="line-removed">465   static void invalidate_installed_code(Handle installed_code, TRAPS);</span>
<span class="line-removed">466 </span>
<span class="line-removed">467   // Gets the SpeculationLog object associated with this nmethod</span>
<span class="line-removed">468   // which may be NULL if this nmethod was not compiled by JVMCI</span>
<span class="line-removed">469   // or the weak reference has been cleared.</span>
<span class="line-removed">470   oop speculation_log();</span>
<span class="line-removed">471 </span>
<span class="line-removed">472  private:</span>
<span class="line-removed">473   // Deletes the weak reference (if any) to the InstalledCode object</span>
<span class="line-removed">474   // associated with this nmethod.</span>
<span class="line-removed">475   void clear_jvmci_installed_code();</span>
<span class="line-removed">476 </span>
<span class="line-removed">477   // Deletes the weak reference (if any) to the SpeculationLog object</span>
<span class="line-removed">478   // associated with this nmethod.</span>
<span class="line-removed">479   void clear_speculation_log();</span>
<span class="line-removed">480 </span>
<span class="line-removed">481  public:</span>
482 #endif
483 
484  public:
485   void oops_do(OopClosure* f) { oops_do(f, false); }
<span class="line-modified">486   void oops_do(OopClosure* f, bool allow_zombie);</span>






















487 
<span class="line-removed">488   bool test_set_oops_do_mark();</span>
489   static void oops_do_marking_prologue();
490   static void oops_do_marking_epilogue();
<span class="line-removed">491   static bool oops_do_marking_is_active() { return _oops_do_mark_nmethods != NULL; }</span>
<span class="line-removed">492   bool test_oops_do_mark() { return _oops_do_mark_link != NULL; }</span>
493 
494  private:
495   ScopeDesc* scope_desc_in(address begin, address end);
496 
497   address* orig_pc_addr(const frame* fr);
498 






499  public:
500   // copying of debugging information
501   void copy_scopes_pcs(PcDesc* pcs, int count);
502   void copy_scopes_data(address buffer, int size);
503 
504   // Accessor/mutator for the original pc of a frame before a frame was deopted.
505   address get_original_pc(const frame* fr) { return *orig_pc_addr(fr); }
506   void    set_original_pc(const frame* fr, address pc) { *orig_pc_addr(fr) = pc; }
507 
508   // jvmti support:
<span class="line-modified">509   void post_compiled_method_load_event();</span>
<span class="line-removed">510   jmethodID get_and_cache_jmethod_id();</span>
511 
512   // verify operations
513   void verify();
514   void verify_scopes();
515   void verify_interrupt_point(address interrupt_point);
516 







517   // printing support
518   void print()                          const;





519   void print_relocations()                        PRODUCT_RETURN;
<span class="line-modified">520   void print_pcs()                                PRODUCT_RETURN;</span>
<span class="line-modified">521   void print_scopes()                             PRODUCT_RETURN;</span>
<span class="line-modified">522   void print_dependencies()                       PRODUCT_RETURN;</span>
<span class="line-modified">523   void print_value_on(outputStream* st) const     PRODUCT_RETURN;</span>













524   void print_calls(outputStream* st)              PRODUCT_RETURN;
<span class="line-modified">525   void print_handler_table()                      PRODUCT_RETURN;</span>
<span class="line-removed">526   void print_nul_chk_table()                      PRODUCT_RETURN;</span>
<span class="line-removed">527   void print_recorded_oops()                      PRODUCT_RETURN;</span>
<span class="line-removed">528   void print_recorded_metadata()                  PRODUCT_RETURN;</span>
529 
530   void maybe_print_nmethod(DirectiveSet* directive);
531   void print_nmethod(bool print_code);
532 
533   // need to re-define this from CodeBlob else the overload hides it
534   virtual void print_on(outputStream* st) const { CodeBlob::print_on(st); }
535   void print_on(outputStream* st, const char* msg) const;
536 
537   // Logging
538   void log_identity(xmlStream* log) const;
539   void log_new_nmethod() const;
540   void log_state_change() const;
541 
542   // Prints block-level comments, including nmethod specific block labels:
543   virtual void print_block_comment(outputStream* stream, address block_begin) const {

544     print_nmethod_labels(stream, block_begin);
545     CodeBlob::print_block_comment(stream, block_begin);

546   }
<span class="line-modified">547   void print_nmethod_labels(outputStream* stream, address block_begin) const;</span>




548 


549   // Prints a comment for one native instruction (reloc info, pc desc)
550   void print_code_comment_on(outputStream* st, int column, address begin, address end);
<span class="line-removed">551   static void print_statistics() PRODUCT_RETURN;</span>
552 
553   // Compiler task identification.  Note that all OSR methods
554   // are numbered in an independent sequence if CICountOSR is true,
555   // and native method wrappers are also numbered independently if
556   // CICountNative is true.
557   virtual int compile_id() const { return _compile_id; }
558   const char* compile_kind() const;
559 
560   // tells if any of this method&#39;s dependencies have been invalidated
561   // (this is expensive!)
562   static void check_all_dependencies(DepChange&amp; changes);
563 
564   // tells if this compiled method is dependent on the given changes,
565   // and the changes have invalidated it
566   bool check_dependency_on(DepChange&amp; changes);
567 
<span class="line-removed">568   // Evolution support. Tells if this compiled method is dependent on any of</span>
<span class="line-removed">569   // redefined methods, such that if m() is replaced,</span>
<span class="line-removed">570   // this compiled method will have to be deoptimized.</span>
<span class="line-removed">571   bool is_evol_dependent();</span>
<span class="line-removed">572 </span>
573   // Fast breakpoint support. Tells if this compiled method is
574   // dependent on the given method. Returns true if this nmethod
575   // corresponds to the given method as well.
576   virtual bool is_dependent_on_method(Method* dependee);
577 
578   // is it ok to patch at address?
579   bool is_patchable_at(address instr_address);
580 
581   // UseBiasedLocking support
582   ByteSize native_receiver_sp_offset() {
583     return _native_receiver_sp_offset;
584   }
585   ByteSize native_basic_lock_sp_offset() {
586     return _native_basic_lock_sp_offset;
587   }
588 
589   // support for code generation
590   static int verified_entry_point_offset()        { return offset_of(nmethod, _verified_entry_point); }
591   static int osr_entry_point_offset()             { return offset_of(nmethod, _osr_entry_point); }
592   static int state_offset()                       { return offset_of(nmethod, _state); }
593 
<span class="line-modified">594   virtual void metadata_do(void f(Metadata*));</span>
595 
596   NativeCallWrapper* call_wrapper_at(address call) const;
597   NativeCallWrapper* call_wrapper_before(address return_pc) const;
598   address call_instruction_address(address pc) const;
599 
600   virtual CompiledStaticCall* compiledStaticCall_at(Relocation* call_site) const;
601   virtual CompiledStaticCall* compiledStaticCall_at(address addr) const;
602   virtual CompiledStaticCall* compiledStaticCall_before(address addr) const;
603 };
604 
605 // Locks an nmethod so its code will not get removed and it will not
606 // be made into a zombie, even if it is a not_entrant method. After the
607 // nmethod becomes a zombie, if CompiledMethodUnload event processing
608 // needs to be done, then lock_nmethod() is used directly to keep the
609 // generated code from being reused too early.
610 class nmethodLocker : public StackObj {
611   CompiledMethod* _nm;
612 
613  public:
614 
615   // note: nm can be NULL
616   // Only JvmtiDeferredEvent::compiled_method_unload_event()
617   // should pass zombie_ok == true.
618   static void lock_nmethod(CompiledMethod* nm, bool zombie_ok = false);
619   static void unlock_nmethod(CompiledMethod* nm); // (ditto)
620 
621   nmethodLocker(address pc); // derive nm from pc
622   nmethodLocker(nmethod *nm) { _nm = nm; lock_nmethod(_nm); }
623   nmethodLocker(CompiledMethod *nm) {
624     _nm = nm;
625     lock(_nm);
626   }
627 
<span class="line-modified">628   static void lock(CompiledMethod* method) {</span>
629     if (method == NULL) return;
<span class="line-modified">630     lock_nmethod(method);</span>
631   }
632 
633   static void unlock(CompiledMethod* method) {
634     if (method == NULL) return;
635     unlock_nmethod(method);
636   }
637 
638   nmethodLocker() { _nm = NULL; }
639   ~nmethodLocker() {
640     unlock(_nm);
641   }
642 
643   CompiledMethod* code() { return _nm; }
<span class="line-modified">644   void set_code(CompiledMethod* new_nm) {</span>
645     unlock(_nm);   // note:  This works even if _nm==new_nm.
646     _nm = new_nm;
<span class="line-modified">647     lock(_nm);</span>
648   }
649 };
650 
651 #endif // SHARE_CODE_NMETHOD_HPP
</pre>
</td>
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CODE_NMETHOD_HPP
 26 #define SHARE_CODE_NMETHOD_HPP
 27 
 28 #include &quot;code/compiledMethod.hpp&quot;
 29 
 30 class DepChange;
 31 class DirectiveSet;
 32 class DebugInformationRecorder;
<span class="line-added"> 33 class JvmtiThreadState;</span>
 34 
 35 // nmethods (native methods) are the compiled code versions of Java methods.
 36 //
 37 // An nmethod contains:
 38 //  - header                 (the nmethod structure)
 39 //  [Relocation]
 40 //  - relocation information
 41 //  - constant part          (doubles, longs and floats used in nmethod)
 42 //  - oop table
 43 //  [Code]
 44 //  - code body
 45 //  - exception handler
 46 //  - stub code
 47 //  [Debugging information]
 48 //  - oop array
 49 //  - data array
 50 //  - pcs
 51 //  [Exception handler table]
 52 //  - handler entry point array
 53 //  [Implicit Null Pointer exception table]
 54 //  - implicit null table array
<span class="line-added"> 55 //  [Speculations]</span>
<span class="line-added"> 56 //  - encoded speculations array</span>
<span class="line-added"> 57 //  [JVMCINMethodData]</span>
<span class="line-added"> 58 //  - meta data for JVMCI compiled nmethod</span>
<span class="line-added"> 59 </span>
<span class="line-added"> 60 #if INCLUDE_JVMCI</span>
<span class="line-added"> 61 class FailedSpeculation;</span>
<span class="line-added"> 62 class JVMCINMethodData;</span>
<span class="line-added"> 63 #endif</span>
 64 
 65 class nmethod : public CompiledMethod {
 66   friend class VMStructs;
 67   friend class JVMCIVMStructs;
 68   friend class NMethodSweeper;
 69   friend class CodeCache;  // scavengable oops
<span class="line-modified"> 70   friend class JVMCINMethodData;</span>
 71 
<span class="line-added"> 72  private:</span>
 73   // Shared fields for all nmethod&#39;s
 74   int       _entry_bci;        // != InvocationEntryBci if this nmethod is an on-stack replacement method




















 75 
 76   // To support simple linked-list chaining of nmethods:
 77   nmethod*  _osr_link;         // from InstanceKlass::osr_nmethods_head
 78 
<span class="line-added"> 79   // STW two-phase nmethod root processing helpers.</span>
<span class="line-added"> 80   //</span>
<span class="line-added"> 81   // When determining liveness of a given nmethod to do code cache unloading,</span>
<span class="line-added"> 82   // some collectors need to to different things depending on whether the nmethods</span>
<span class="line-added"> 83   // need to absolutely be kept alive during root processing; &quot;strong&quot;ly reachable</span>
<span class="line-added"> 84   // nmethods are known to be kept alive at root processing, but the liveness of</span>
<span class="line-added"> 85   // &quot;weak&quot;ly reachable ones is to be determined later.</span>
<span class="line-added"> 86   //</span>
<span class="line-added"> 87   // We want to allow strong and weak processing of nmethods by different threads</span>
<span class="line-added"> 88   // at the same time without heavy synchronization. Additional constraints are</span>
<span class="line-added"> 89   // to make sure that every nmethod is processed a minimal amount of time, and</span>
<span class="line-added"> 90   // nmethods themselves are always iterated at most once at a particular time.</span>
<span class="line-added"> 91   //</span>
<span class="line-added"> 92   // Note that strong processing work must be a superset of weak processing work</span>
<span class="line-added"> 93   // for this code to work.</span>
<span class="line-added"> 94   //</span>
<span class="line-added"> 95   // We store state and claim information in the _oops_do_mark_link member, using</span>
<span class="line-added"> 96   // the two LSBs for the state and the remaining upper bits for linking together</span>
<span class="line-added"> 97   // nmethods that were already visited.</span>
<span class="line-added"> 98   // The last element is self-looped, i.e. points to itself to avoid some special</span>
<span class="line-added"> 99   // &quot;end-of-list&quot; sentinel value.</span>
<span class="line-added">100   //</span>
<span class="line-added">101   // _oops_do_mark_link special values:</span>
<span class="line-added">102   //</span>
<span class="line-added">103   //   _oops_do_mark_link == NULL: the nmethod has not been visited at all yet, i.e.</span>
<span class="line-added">104   //      is Unclaimed.</span>
<span class="line-added">105   //</span>
<span class="line-added">106   // For other values, its lowest two bits indicate the following states of the nmethod:</span>
<span class="line-added">107   //</span>
<span class="line-added">108   //   weak_request (WR): the nmethod has been claimed by a thread for weak processing</span>
<span class="line-added">109   //   weak_done (WD): weak processing has been completed for this nmethod.</span>
<span class="line-added">110   //   strong_request (SR): the nmethod has been found to need strong processing while</span>
<span class="line-added">111   //       being weak processed.</span>
<span class="line-added">112   //   strong_done (SD): strong processing has been completed for this nmethod .</span>
<span class="line-added">113   //</span>
<span class="line-added">114   // The following shows the _only_ possible progressions of the _oops_do_mark_link</span>
<span class="line-added">115   // pointer.</span>
<span class="line-added">116   //</span>
<span class="line-added">117   // Given</span>
<span class="line-added">118   //   N as the nmethod</span>
<span class="line-added">119   //   X the current next value of _oops_do_mark_link</span>
<span class="line-added">120   //</span>
<span class="line-added">121   // Unclaimed (C)-&gt; N|WR (C)-&gt; X|WD: the nmethod has been processed weakly by</span>
<span class="line-added">122   //   a single thread.</span>
<span class="line-added">123   // Unclaimed (C)-&gt; N|WR (C)-&gt; X|WD (O)-&gt; X|SD: after weak processing has been</span>
<span class="line-added">124   //   completed (as above) another thread found that the nmethod needs strong</span>
<span class="line-added">125   //   processing after all.</span>
<span class="line-added">126   // Unclaimed (C)-&gt; N|WR (O)-&gt; N|SR (C)-&gt; X|SD: during weak processing another</span>
<span class="line-added">127   //   thread finds that the nmethod needs strong processing, marks it as such and</span>
<span class="line-added">128   //   terminates. The original thread completes strong processing.</span>
<span class="line-added">129   // Unclaimed (C)-&gt; N|SD (C)-&gt; X|SD: the nmethod has been processed strongly from</span>
<span class="line-added">130   //   the beginning by a single thread.</span>
<span class="line-added">131   //</span>
<span class="line-added">132   // &quot;|&quot; describes the concatentation of bits in _oops_do_mark_link.</span>
<span class="line-added">133   //</span>
<span class="line-added">134   // The diagram also describes the threads responsible for changing the nmethod to</span>
<span class="line-added">135   // the next state by marking the _transition_ with (C) and (O), which mean &quot;current&quot;</span>
<span class="line-added">136   // and &quot;other&quot; thread respectively.</span>
<span class="line-added">137   //</span>
<span class="line-added">138   struct oops_do_mark_link; // Opaque data type.</span>
<span class="line-added">139 </span>
<span class="line-added">140   // States used for claiming nmethods during root processing.</span>
<span class="line-added">141   static const uint claim_weak_request_tag = 0;</span>
<span class="line-added">142   static const uint claim_weak_done_tag = 1;</span>
<span class="line-added">143   static const uint claim_strong_request_tag = 2;</span>
<span class="line-added">144   static const uint claim_strong_done_tag = 3;</span>
<span class="line-added">145 </span>
<span class="line-added">146   static oops_do_mark_link* mark_link(nmethod* nm, uint tag) {</span>
<span class="line-added">147     assert(tag &lt;= claim_strong_done_tag, &quot;invalid tag %u&quot;, tag);</span>
<span class="line-added">148     assert(is_aligned(nm, 4), &quot;nmethod pointer must have zero lower two LSB&quot;);</span>
<span class="line-added">149     return (oops_do_mark_link*)(((uintptr_t)nm &amp; ~0x3) | tag);</span>
<span class="line-added">150   }</span>
<span class="line-added">151 </span>
<span class="line-added">152   static uint extract_state(oops_do_mark_link* link) {</span>
<span class="line-added">153     return (uint)((uintptr_t)link &amp; 0x3);</span>
<span class="line-added">154   }</span>
<span class="line-added">155 </span>
<span class="line-added">156   static nmethod* extract_nmethod(oops_do_mark_link* link) {</span>
<span class="line-added">157     return (nmethod*)((uintptr_t)link &amp; ~0x3);</span>
<span class="line-added">158   }</span>
<span class="line-added">159 </span>
<span class="line-added">160   void oops_do_log_change(const char* state);</span>
<span class="line-added">161 </span>
<span class="line-added">162   static bool oops_do_has_weak_request(oops_do_mark_link* next) {</span>
<span class="line-added">163     return extract_state(next) == claim_weak_request_tag;</span>
<span class="line-added">164   }</span>
<span class="line-added">165 </span>
<span class="line-added">166   static bool oops_do_has_any_strong_state(oops_do_mark_link* next) {</span>
<span class="line-added">167     return extract_state(next) &gt;= claim_strong_request_tag;</span>
<span class="line-added">168   }</span>
<span class="line-added">169 </span>
<span class="line-added">170   // Attempt Unclaimed -&gt; N|WR transition. Returns true if successful.</span>
<span class="line-added">171   bool oops_do_try_claim_weak_request();</span>
<span class="line-added">172 </span>
<span class="line-added">173   // Attempt Unclaimed -&gt; N|SD transition. Returns the current link.</span>
<span class="line-added">174   oops_do_mark_link* oops_do_try_claim_strong_done();</span>
<span class="line-added">175   // Attempt N|WR -&gt; X|WD transition. Returns NULL if successful, X otherwise.</span>
<span class="line-added">176   nmethod* oops_do_try_add_to_list_as_weak_done();</span>
<span class="line-added">177 </span>
<span class="line-added">178   // Attempt X|WD -&gt; N|SR transition. Returns the current link.</span>
<span class="line-added">179   oops_do_mark_link* oops_do_try_add_strong_request(oops_do_mark_link* next);</span>
<span class="line-added">180   // Attempt X|WD -&gt; X|SD transition. Returns true if successful.</span>
<span class="line-added">181   bool oops_do_try_claim_weak_done_as_strong_done(oops_do_mark_link* next);</span>
<span class="line-added">182 </span>
<span class="line-added">183   // Do the N|SD -&gt; X|SD transition.</span>
<span class="line-added">184   void oops_do_add_to_list_as_strong_done();</span>
<span class="line-added">185 </span>
<span class="line-added">186   // Sets this nmethod as strongly claimed (as part of N|SD -&gt; X|SD and N|SR -&gt; X|SD</span>
<span class="line-added">187   // transitions).</span>
<span class="line-added">188   void oops_do_set_strong_done(nmethod* old_head);</span>
<span class="line-added">189 </span>
190   static nmethod* volatile _oops_do_mark_nmethods;
<span class="line-modified">191   oops_do_mark_link* volatile _oops_do_mark_link;</span>
192 
193   // offsets for entry points
194   address _entry_point;                      // entry point with class check
195   address _verified_entry_point;             // entry point without class check
196   address _osr_entry_point;                  // entry point for on stack replacement
197 
198   // Offsets for different nmethod parts
199   int  _exception_offset;
200   // Offset of the unwind handler if it exists
201   int _unwind_handler_offset;
202 
203   int _consts_offset;
204   int _stub_offset;
205   int _oops_offset;                       // offset to where embedded oop table begins (inside data)
206   int _metadata_offset;                   // embedded meta data table
207   int _scopes_data_offset;
208   int _scopes_pcs_offset;
209   int _dependencies_offset;
210   int _handler_table_offset;
211   int _nul_chk_table_offset;
<span class="line-added">212 #if INCLUDE_JVMCI</span>
<span class="line-added">213   int _speculations_offset;</span>
<span class="line-added">214   int _jvmci_data_offset;</span>
<span class="line-added">215 #endif</span>
216   int _nmethod_end_offset;
217 
218   int code_offset() const { return (address) code_begin() - header_begin(); }
219 
220   // location in frame (offset for sp) that deopt can store the original
221   // pc during a deopt.
222   int _orig_pc_offset;
223 
224   int _compile_id;                           // which compilation made this nmethod
225   int _comp_level;                           // compilation level
226 
227   // protected by CodeCache_lock
228   bool _has_flushed_dependencies;            // Used for maintenance of dependencies (CodeCache_lock)
229 
<span class="line-modified">230   // used by jvmti to track if an event has been posted for this nmethod.</span>
231   bool _unload_reported;
<span class="line-added">232   bool _load_reported;</span>
233 
<span class="line-modified">234   // Protected by CompiledMethod_lock</span>
235   volatile signed char _state;               // {not_installed, in_use, not_entrant, zombie, unloaded}
236 
237 #ifdef ASSERT
238   bool _oops_are_stale;  // indicates that it&#39;s no longer safe to access oops section
239 #endif
240 
241 #if INCLUDE_RTM_OPT
242   // RTM state at compile time. Used during deoptimization to decide
243   // whether to restart collecting RTM locking abort statistic again.
244   RTMState _rtm_state;
245 #endif
246 
247   // Nmethod Flushing lock. If non-zero, then the nmethod is not removed
248   // and is not made into a zombie. However, once the nmethod is made into
249   // a zombie, it will be locked one final time if CompiledMethodUnload
250   // event processing needs to be done.
251   volatile jint _lock_count;
252 
253   // not_entrant method removal. Each mark_sweep pass will update
254   // this mark to current sweep invocation count if it is seen on the
</pre>
<hr />
<pre>
297           OopMapSet* oop_maps);
298 
299   // Creation support
300   nmethod(Method* method,
301           CompilerType type,
302           int nmethod_size,
303           int compile_id,
304           int entry_bci,
305           CodeOffsets* offsets,
306           int orig_pc_offset,
307           DebugInformationRecorder *recorder,
308           Dependencies* dependencies,
309           CodeBuffer *code_buffer,
310           int frame_size,
311           OopMapSet* oop_maps,
312           ExceptionHandlerTable* handler_table,
313           ImplicitExceptionTable* nul_chk_table,
314           AbstractCompiler* compiler,
315           int comp_level
316 #if INCLUDE_JVMCI
<span class="line-modified">317           , char* speculations,</span>
<span class="line-modified">318           int speculations_len,</span>
<span class="line-added">319           int jvmci_data_size</span>
320 #endif
321           );
322 
323   // helper methods
324   void* operator new(size_t size, int nmethod_size, int comp_level) throw();
325 
326   const char* reloc_string_for(u_char* begin, u_char* end);
<span class="line-added">327 </span>
<span class="line-added">328   bool try_transition(int new_state);</span>
<span class="line-added">329 </span>
330   // Returns true if this thread changed the state of the nmethod or
331   // false if another thread performed the transition.
332   bool make_not_entrant_or_zombie(int state);
333   bool make_entrant() { Unimplemented(); return false; }
334   void inc_decompile_count();
335 
336   // Inform external interfaces that a compiled method has been unloaded
337   void post_compiled_method_unload();
338 
339   // Initailize fields to their default values
340   void init_defaults();
341 
342   // Offsets
343   int content_offset() const                  { return content_begin() - header_begin(); }
344   int data_offset() const                     { return _data_offset; }
345 
346   address header_end() const                  { return (address)    header_begin() + header_size(); }
347 
348  public:
349   // create nmethod with entry_bci
350   static nmethod* new_nmethod(const methodHandle&amp; method,
351                               int compile_id,
352                               int entry_bci,
353                               CodeOffsets* offsets,
354                               int orig_pc_offset,
355                               DebugInformationRecorder* recorder,
356                               Dependencies* dependencies,
357                               CodeBuffer *code_buffer,
358                               int frame_size,
359                               OopMapSet* oop_maps,
360                               ExceptionHandlerTable* handler_table,
361                               ImplicitExceptionTable* nul_chk_table,
362                               AbstractCompiler* compiler,
363                               int comp_level
364 #if INCLUDE_JVMCI
<span class="line-modified">365                               , char* speculations = NULL,</span>
<span class="line-modified">366                               int speculations_len = 0,</span>
<span class="line-added">367                               int nmethod_mirror_index = -1,</span>
<span class="line-added">368                               const char* nmethod_mirror_name = NULL,</span>
<span class="line-added">369                               FailedSpeculation** failed_speculations = NULL</span>
370 #endif
371   );
372 
373   // Only used for unit tests.
374   nmethod()
375     : CompiledMethod(),
376       _is_unloading_state(0),
377       _native_receiver_sp_offset(in_ByteSize(-1)),
378       _native_basic_lock_sp_offset(in_ByteSize(-1)) {}
379 
380 
381   static nmethod* new_native_nmethod(const methodHandle&amp; method,
382                                      int compile_id,
383                                      CodeBuffer *code_buffer,
384                                      int vep_offset,
385                                      int frame_complete,
386                                      int frame_size,
387                                      ByteSize receiver_sp_offset,
388                                      ByteSize basic_lock_sp_offset,
389                                      OopMapSet* oop_maps);
</pre>
<hr />
<pre>
396   address consts_begin          () const          { return           header_begin() + _consts_offset        ; }
397   address consts_end            () const          { return           code_begin()                           ; }
398   address stub_begin            () const          { return           header_begin() + _stub_offset          ; }
399   address stub_end              () const          { return           header_begin() + _oops_offset          ; }
400   address exception_begin       () const          { return           header_begin() + _exception_offset     ; }
401   address unwind_handler_begin  () const          { return _unwind_handler_offset != -1 ? (header_begin() + _unwind_handler_offset) : NULL; }
402   oop*    oops_begin            () const          { return (oop*)   (header_begin() + _oops_offset)         ; }
403   oop*    oops_end              () const          { return (oop*)   (header_begin() + _metadata_offset)     ; }
404 
405   Metadata** metadata_begin   () const            { return (Metadata**)  (header_begin() + _metadata_offset)     ; }
406   Metadata** metadata_end     () const            { return (Metadata**)  _scopes_data_begin; }
407 
408   address scopes_data_end       () const          { return           header_begin() + _scopes_pcs_offset    ; }
409   PcDesc* scopes_pcs_begin      () const          { return (PcDesc*)(header_begin() + _scopes_pcs_offset   ); }
410   PcDesc* scopes_pcs_end        () const          { return (PcDesc*)(header_begin() + _dependencies_offset) ; }
411   address dependencies_begin    () const          { return           header_begin() + _dependencies_offset  ; }
412   address dependencies_end      () const          { return           header_begin() + _handler_table_offset ; }
413   address handler_table_begin   () const          { return           header_begin() + _handler_table_offset ; }
414   address handler_table_end     () const          { return           header_begin() + _nul_chk_table_offset ; }
415   address nul_chk_table_begin   () const          { return           header_begin() + _nul_chk_table_offset ; }
<span class="line-added">416 #if INCLUDE_JVMCI</span>
<span class="line-added">417   address nul_chk_table_end     () const          { return           header_begin() + _speculations_offset  ; }</span>
<span class="line-added">418   address speculations_begin    () const          { return           header_begin() + _speculations_offset  ; }</span>
<span class="line-added">419   address speculations_end      () const          { return           header_begin() + _jvmci_data_offset   ; }</span>
<span class="line-added">420   address jvmci_data_begin      () const          { return           header_begin() + _jvmci_data_offset    ; }</span>
<span class="line-added">421   address jvmci_data_end        () const          { return           header_begin() + _nmethod_end_offset   ; }</span>
<span class="line-added">422 #else</span>
423   address nul_chk_table_end     () const          { return           header_begin() + _nmethod_end_offset   ; }
<span class="line-added">424 #endif</span>
425 
426   // Sizes
427   int oops_size         () const                  { return (address)  oops_end         () - (address)  oops_begin         (); }
428   int metadata_size     () const                  { return (address)  metadata_end     () - (address)  metadata_begin     (); }
429   int dependencies_size () const                  { return            dependencies_end () -            dependencies_begin (); }
<span class="line-added">430 #if INCLUDE_JVMCI</span>
<span class="line-added">431   int speculations_size () const                  { return            speculations_end () -            speculations_begin (); }</span>
<span class="line-added">432   int jvmci_data_size   () const                  { return            jvmci_data_end   () -            jvmci_data_begin   (); }</span>
<span class="line-added">433 #endif</span>
434 
435   int     oops_count() const { assert(oops_size() % oopSize == 0, &quot;&quot;);  return (oops_size() / oopSize) + 1; }
436   int metadata_count() const { assert(metadata_size() % wordSize == 0, &quot;&quot;); return (metadata_size() / wordSize) + 1; }
437 
438   int total_size        () const;
439 
440   void dec_hotness_counter()        { _hotness_counter--; }
441   void set_hotness_counter(int val) { _hotness_counter = val; }
442   int  hotness_counter() const      { return _hotness_counter; }
443 
444   // Containment
445   bool oops_contains         (oop*    addr) const { return oops_begin         () &lt;= addr &amp;&amp; addr &lt; oops_end         (); }
446   bool metadata_contains     (Metadata** addr) const   { return metadata_begin     () &lt;= addr &amp;&amp; addr &lt; metadata_end     (); }
447   bool scopes_data_contains  (address addr) const { return scopes_data_begin  () &lt;= addr &amp;&amp; addr &lt; scopes_data_end  (); }
448   bool scopes_pcs_contains   (PcDesc* addr) const { return scopes_pcs_begin   () &lt;= addr &amp;&amp; addr &lt; scopes_pcs_end   (); }
449 
450   // entry points
451   address entry_point() const                     { return _entry_point;             } // normal entry point
452   address verified_entry_point() const            { return _verified_entry_point;    } // if klass is correct
453 
454   // flag accessing and manipulation
455   bool  is_not_installed() const                  { return _state == not_installed; }
456   bool  is_in_use() const                         { return _state &lt;= in_use; }
<span class="line-modified">457   bool  is_alive() const                          { return _state &lt; unloaded; }</span>
458   bool  is_not_entrant() const                    { return _state == not_entrant; }
459   bool  is_zombie() const                         { return _state == zombie; }
460   bool  is_unloaded() const                       { return _state == unloaded; }
461 
462   void clear_unloading_state();
463   virtual bool is_unloading();
464   virtual void do_unloading(bool unloading_occurred);
465 
466 #if INCLUDE_RTM_OPT
467   // rtm state accessing and manipulating
468   RTMState  rtm_state() const                     { return _rtm_state; }
469   void set_rtm_state(RTMState state)              { _rtm_state = state; }
470 #endif
471 
<span class="line-modified">472   bool make_in_use() {</span>
<span class="line-added">473     return try_transition(in_use);</span>
<span class="line-added">474   }</span>
475   // Make the nmethod non entrant. The nmethod will continue to be
476   // alive.  It is used when an uncommon trap happens.  Returns true
477   // if this thread changed the state of the nmethod or false if
478   // another thread performed the transition.
479   bool  make_not_entrant() {
480     assert(!method()-&gt;is_method_handle_intrinsic(), &quot;Cannot make MH intrinsic not entrant&quot;);
481     return make_not_entrant_or_zombie(not_entrant);
482   }
483   bool  make_not_used()    { return make_not_entrant(); }
484   bool  make_zombie()      { return make_not_entrant_or_zombie(zombie); }
485 




486   int get_state() const {
487     return _state;
488   }
489 
490   void  make_unloaded();
491 
492   bool has_dependencies()                         { return dependencies_size() != 0; }
<span class="line-added">493   void print_dependencies()                       PRODUCT_RETURN;</span>
494   void flush_dependencies(bool delete_immediately);
495   bool has_flushed_dependencies()                 { return _has_flushed_dependencies; }
496   void set_has_flushed_dependencies()             {
497     assert(!has_flushed_dependencies(), &quot;should only happen once&quot;);
498     _has_flushed_dependencies = 1;
499   }
500 
501   int   comp_level() const                        { return _comp_level; }
502 
<span class="line-modified">503   void unlink_from_method();</span>
504 
505   // Support for oops in scopes and relocs:
506   // Note: index 0 is reserved for null.
507   oop   oop_at(int index) const;
<span class="line-added">508   oop   oop_at_phantom(int index) const; // phantom reference</span>
509   oop*  oop_addr_at(int index) const {  // for GC
510     // relocation indexes are biased by 1 (because 0 is reserved)
511     assert(index &gt; 0 &amp;&amp; index &lt;= oops_count(), &quot;must be a valid non-zero index&quot;);
512     assert(!_oops_are_stale, &quot;oops are stale&quot;);
513     return &amp;oops_begin()[index - 1];
514   }
515 
516   // Support for meta data in scopes and relocs:
517   // Note: index 0 is reserved for null.
518   Metadata*     metadata_at(int index) const      { return index == 0 ? NULL: *metadata_addr_at(index); }
519   Metadata**  metadata_addr_at(int index) const {  // for GC
520     // relocation indexes are biased by 1 (because 0 is reserved)
521     assert(index &gt; 0 &amp;&amp; index &lt;= metadata_count(), &quot;must be a valid non-zero index&quot;);
522     return &amp;metadata_begin()[index - 1];
523   }
524 
525   void copy_values(GrowableArray&lt;jobject&gt;* oops);
526   void copy_values(GrowableArray&lt;Metadata*&gt;* metadata);
527 
528   // Relocation support
529 private:
530   void fix_oop_relocations(address begin, address end, bool initialize_immediates);
531   inline void initialize_immediate_oop(oop* dest, jobject handle);
532 
533 public:
534   void fix_oop_relocations(address begin, address end) { fix_oop_relocations(begin, end, false); }
535   void fix_oop_relocations()                           { fix_oop_relocations(NULL, NULL, false); }
536 
537   // Sweeper support
538   long  stack_traversal_mark()                    { return _stack_traversal_mark; }
539   void  set_stack_traversal_mark(long l)          { _stack_traversal_mark = l; }
540 



541   // On-stack replacement support
542   int   osr_entry_bci() const                     { assert(is_osr_method(), &quot;wrong kind of nmethod&quot;); return _entry_bci; }
543   address  osr_entry() const                      { assert(is_osr_method(), &quot;wrong kind of nmethod&quot;); return _osr_entry_point; }
544   void  invalidate_osr_method();
545   nmethod* osr_link() const                       { return _osr_link; }
546   void     set_osr_link(nmethod *n)               { _osr_link = n; }
547 
548   // Verify calls to dead methods have been cleaned.
549   void verify_clean_inline_caches();
550 
551   // unlink and deallocate this nmethod
552   // Only NMethodSweeper class is expected to use this. NMethodSweeper is not
553   // expected to use any other private methods/data in this class.
554 
555  protected:
556   void flush();
557 
558  public:
559   // When true is returned, it is unsafe to remove this nmethod even if
560   // it is a zombie, since the VM or the ServiceThread might still be
561   // using it.
562   bool is_locked_by_vm() const                    { return _lock_count &gt;0; }
563 
564   // See comment at definition of _last_seen_on_stack
565   void mark_as_seen_on_stack();
566   bool can_convert_to_zombie();
567 
568   // Evolution support. We make old (discarded) compiled methods point to new Method*s.
569   void set_method(Method* method) { _method = method; }
570 
571 #if INCLUDE_JVMCI
<span class="line-modified">572   // Gets the JVMCI name of this nmethod.</span>
<span class="line-modified">573   const char* jvmci_name();</span>
<span class="line-modified">574 </span>
<span class="line-modified">575   // Records the pending failed speculation in the</span>
<span class="line-modified">576   // JVMCI speculation log associated with this nmethod.</span>
<span class="line-modified">577   void update_speculation(JavaThread* thread);</span>
<span class="line-modified">578 </span>
<span class="line-modified">579   // Gets the data specific to a JVMCI compiled method.</span>
<span class="line-modified">580   // This returns a non-NULL value iff this nmethod was</span>
<span class="line-modified">581   // compiled by the JVMCI compiler.</span>
<span class="line-modified">582   JVMCINMethodData* jvmci_nmethod_data() const {</span>
<span class="line-modified">583     return jvmci_data_size() == 0 ? NULL : (JVMCINMethodData*) jvmci_data_begin();</span>
<span class="line-modified">584   }</span>




















585 #endif
586 
587  public:
588   void oops_do(OopClosure* f) { oops_do(f, false); }
<span class="line-modified">589   void oops_do(OopClosure* f, bool allow_dead);</span>
<span class="line-added">590 </span>
<span class="line-added">591   // All-in-one claiming of nmethods: returns true if the caller successfully claimed that</span>
<span class="line-added">592   // nmethod.</span>
<span class="line-added">593   bool oops_do_try_claim();</span>
<span class="line-added">594 </span>
<span class="line-added">595   // Class containing callbacks for the oops_do_process_weak/strong() methods</span>
<span class="line-added">596   // below.</span>
<span class="line-added">597   class OopsDoProcessor {</span>
<span class="line-added">598   public:</span>
<span class="line-added">599     // Process the oops of the given nmethod based on whether it has been called</span>
<span class="line-added">600     // in a weak or strong processing context, i.e. apply either weak or strong</span>
<span class="line-added">601     // work on it.</span>
<span class="line-added">602     virtual void do_regular_processing(nmethod* nm) = 0;</span>
<span class="line-added">603     // Assuming that the oops of the given nmethod has already been its weak</span>
<span class="line-added">604     // processing applied, apply the remaining strong processing part.</span>
<span class="line-added">605     virtual void do_remaining_strong_processing(nmethod* nm) = 0;</span>
<span class="line-added">606   };</span>
<span class="line-added">607 </span>
<span class="line-added">608   // The following two methods do the work corresponding to weak/strong nmethod</span>
<span class="line-added">609   // processing.</span>
<span class="line-added">610   void oops_do_process_weak(OopsDoProcessor* p);</span>
<span class="line-added">611   void oops_do_process_strong(OopsDoProcessor* p);</span>
612 

613   static void oops_do_marking_prologue();
614   static void oops_do_marking_epilogue();


615 
616  private:
617   ScopeDesc* scope_desc_in(address begin, address end);
618 
619   address* orig_pc_addr(const frame* fr);
620 
<span class="line-added">621   // used by jvmti to track if the load and unload events has been reported</span>
<span class="line-added">622   bool  unload_reported() const                   { return _unload_reported; }</span>
<span class="line-added">623   void  set_unload_reported()                     { _unload_reported = true; }</span>
<span class="line-added">624   bool  load_reported() const                     { return _load_reported; }</span>
<span class="line-added">625   void  set_load_reported()                       { _load_reported = true; }</span>
<span class="line-added">626 </span>
627  public:
628   // copying of debugging information
629   void copy_scopes_pcs(PcDesc* pcs, int count);
630   void copy_scopes_data(address buffer, int size);
631 
632   // Accessor/mutator for the original pc of a frame before a frame was deopted.
633   address get_original_pc(const frame* fr) { return *orig_pc_addr(fr); }
634   void    set_original_pc(const frame* fr, address pc) { *orig_pc_addr(fr) = pc; }
635 
636   // jvmti support:
<span class="line-modified">637   void post_compiled_method_load_event(JvmtiThreadState* state = NULL);</span>

638 
639   // verify operations
640   void verify();
641   void verify_scopes();
642   void verify_interrupt_point(address interrupt_point);
643 
<span class="line-added">644   // Disassemble this nmethod with additional debug information, e.g. information about blocks.</span>
<span class="line-added">645   void decode2(outputStream* st) const;</span>
<span class="line-added">646   void print_constant_pool(outputStream* st);</span>
<span class="line-added">647 </span>
<span class="line-added">648   // Avoid hiding of parent&#39;s &#39;decode(outputStream*)&#39; method.</span>
<span class="line-added">649   void decode(outputStream* st) const { decode2(st); } // just delegate here.</span>
<span class="line-added">650 </span>
651   // printing support
652   void print()                          const;
<span class="line-added">653   void print(outputStream* st)          const;</span>
<span class="line-added">654   void print_code();</span>
<span class="line-added">655 </span>
<span class="line-added">656 #if defined(SUPPORT_DATA_STRUCTS)</span>
<span class="line-added">657   // print output in opt build for disassembler library</span>
658   void print_relocations()                        PRODUCT_RETURN;
<span class="line-modified">659   void print_pcs() { print_pcs_on(tty); }</span>
<span class="line-modified">660   void print_pcs_on(outputStream* st);</span>
<span class="line-modified">661   void print_scopes() { print_scopes_on(tty); }</span>
<span class="line-modified">662   void print_scopes_on(outputStream* st)          PRODUCT_RETURN;</span>
<span class="line-added">663   void print_value_on(outputStream* st) const;</span>
<span class="line-added">664   void print_handler_table();</span>
<span class="line-added">665   void print_nul_chk_table();</span>
<span class="line-added">666   void print_recorded_oops();</span>
<span class="line-added">667   void print_recorded_metadata();</span>
<span class="line-added">668 </span>
<span class="line-added">669   void print_oops(outputStream* st);     // oops from the underlying CodeBlob.</span>
<span class="line-added">670   void print_metadata(outputStream* st); // metadata in metadata pool.</span>
<span class="line-added">671 #else</span>
<span class="line-added">672   // void print_pcs()                             PRODUCT_RETURN;</span>
<span class="line-added">673   void print_pcs()                                { return; }</span>
<span class="line-added">674 #endif</span>
<span class="line-added">675 </span>
676   void print_calls(outputStream* st)              PRODUCT_RETURN;
<span class="line-modified">677   static void print_statistics()                  PRODUCT_RETURN;</span>



678 
679   void maybe_print_nmethod(DirectiveSet* directive);
680   void print_nmethod(bool print_code);
681 
682   // need to re-define this from CodeBlob else the overload hides it
683   virtual void print_on(outputStream* st) const { CodeBlob::print_on(st); }
684   void print_on(outputStream* st, const char* msg) const;
685 
686   // Logging
687   void log_identity(xmlStream* log) const;
688   void log_new_nmethod() const;
689   void log_state_change() const;
690 
691   // Prints block-level comments, including nmethod specific block labels:
692   virtual void print_block_comment(outputStream* stream, address block_begin) const {
<span class="line-added">693 #if defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_ABSTRACT_ASSEMBLY)</span>
694     print_nmethod_labels(stream, block_begin);
695     CodeBlob::print_block_comment(stream, block_begin);
<span class="line-added">696 #endif</span>
697   }
<span class="line-modified">698   bool has_block_comment(address block_begin) {</span>
<span class="line-added">699     return CodeBlob::has_block_comment(block_begin);</span>
<span class="line-added">700   }</span>
<span class="line-added">701   void print_nmethod_labels(outputStream* stream, address block_begin, bool print_section_labels=true) const;</span>
<span class="line-added">702   const char* nmethod_section_label(address pos) const;</span>
703 
<span class="line-added">704   // returns whether this nmethod has code comments.</span>
<span class="line-added">705   bool has_code_comment(address begin, address end);</span>
706   // Prints a comment for one native instruction (reloc info, pc desc)
707   void print_code_comment_on(outputStream* st, int column, address begin, address end);

708 
709   // Compiler task identification.  Note that all OSR methods
710   // are numbered in an independent sequence if CICountOSR is true,
711   // and native method wrappers are also numbered independently if
712   // CICountNative is true.
713   virtual int compile_id() const { return _compile_id; }
714   const char* compile_kind() const;
715 
716   // tells if any of this method&#39;s dependencies have been invalidated
717   // (this is expensive!)
718   static void check_all_dependencies(DepChange&amp; changes);
719 
720   // tells if this compiled method is dependent on the given changes,
721   // and the changes have invalidated it
722   bool check_dependency_on(DepChange&amp; changes);
723 





724   // Fast breakpoint support. Tells if this compiled method is
725   // dependent on the given method. Returns true if this nmethod
726   // corresponds to the given method as well.
727   virtual bool is_dependent_on_method(Method* dependee);
728 
729   // is it ok to patch at address?
730   bool is_patchable_at(address instr_address);
731 
732   // UseBiasedLocking support
733   ByteSize native_receiver_sp_offset() {
734     return _native_receiver_sp_offset;
735   }
736   ByteSize native_basic_lock_sp_offset() {
737     return _native_basic_lock_sp_offset;
738   }
739 
740   // support for code generation
741   static int verified_entry_point_offset()        { return offset_of(nmethod, _verified_entry_point); }
742   static int osr_entry_point_offset()             { return offset_of(nmethod, _osr_entry_point); }
743   static int state_offset()                       { return offset_of(nmethod, _state); }
744 
<span class="line-modified">745   virtual void metadata_do(MetadataClosure* f);</span>
746 
747   NativeCallWrapper* call_wrapper_at(address call) const;
748   NativeCallWrapper* call_wrapper_before(address return_pc) const;
749   address call_instruction_address(address pc) const;
750 
751   virtual CompiledStaticCall* compiledStaticCall_at(Relocation* call_site) const;
752   virtual CompiledStaticCall* compiledStaticCall_at(address addr) const;
753   virtual CompiledStaticCall* compiledStaticCall_before(address addr) const;
754 };
755 
756 // Locks an nmethod so its code will not get removed and it will not
757 // be made into a zombie, even if it is a not_entrant method. After the
758 // nmethod becomes a zombie, if CompiledMethodUnload event processing
759 // needs to be done, then lock_nmethod() is used directly to keep the
760 // generated code from being reused too early.
761 class nmethodLocker : public StackObj {
762   CompiledMethod* _nm;
763 
764  public:
765 
766   // note: nm can be NULL
767   // Only JvmtiDeferredEvent::compiled_method_unload_event()
768   // should pass zombie_ok == true.
769   static void lock_nmethod(CompiledMethod* nm, bool zombie_ok = false);
770   static void unlock_nmethod(CompiledMethod* nm); // (ditto)
771 
772   nmethodLocker(address pc); // derive nm from pc
773   nmethodLocker(nmethod *nm) { _nm = nm; lock_nmethod(_nm); }
774   nmethodLocker(CompiledMethod *nm) {
775     _nm = nm;
776     lock(_nm);
777   }
778 
<span class="line-modified">779   static void lock(CompiledMethod* method, bool zombie_ok = false) {</span>
780     if (method == NULL) return;
<span class="line-modified">781     lock_nmethod(method, zombie_ok);</span>
782   }
783 
784   static void unlock(CompiledMethod* method) {
785     if (method == NULL) return;
786     unlock_nmethod(method);
787   }
788 
789   nmethodLocker() { _nm = NULL; }
790   ~nmethodLocker() {
791     unlock(_nm);
792   }
793 
794   CompiledMethod* code() { return _nm; }
<span class="line-modified">795   void set_code(CompiledMethod* new_nm, bool zombie_ok = false) {</span>
796     unlock(_nm);   // note:  This works even if _nm==new_nm.
797     _nm = new_nm;
<span class="line-modified">798     lock(_nm, zombie_ok);</span>
799   }
800 };
801 
802 #endif // SHARE_CODE_NMETHOD_HPP
</pre>
</td>
</tr>
</table>
<center><a href="nmethod.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oopRecorder.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
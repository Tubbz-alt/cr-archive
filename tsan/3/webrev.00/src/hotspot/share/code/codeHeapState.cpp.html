<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/code/codeHeapState.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2018, 2019 SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;code/codeHeapState.hpp&quot;
  28 #include &quot;compiler/compileBroker.hpp&quot;
  29 #include &quot;runtime/sweeper.hpp&quot;
  30 #include &quot;utilities/powerOfTwo.hpp&quot;
  31 
  32 // -------------------------
  33 // |  General Description  |
  34 // -------------------------
  35 // The CodeHeap state analytics are divided in two parts.
  36 // The first part examines the entire CodeHeap and aggregates all
  37 // information that is believed useful/important.
  38 //
  39 // Aggregation condenses the information of a piece of the CodeHeap
  40 // (4096 bytes by default) into an analysis granule. These granules
  41 // contain enough detail to gain initial insight while keeping the
  42 // internal structure sizes in check.
  43 //
  44 // The second part, which consists of several, independent steps,
  45 // prints the previously collected information with emphasis on
  46 // various aspects.
  47 //
  48 // The CodeHeap is a living thing. Therefore, protection against concurrent
  49 // modification (by acquiring the CodeCache_lock) is necessary. It has
  50 // to be provided by the caller of the analysis functions.
  51 // If the CodeCache_lock is not held, the analysis functions may print
  52 // less detailed information or may just do nothing. It is by intention
  53 // that an unprotected invocation is not abnormally terminated.
  54 //
  55 // Data collection and printing is done on an &quot;on request&quot; basis.
  56 // While no request is being processed, there is no impact on performance.
  57 // The CodeHeap state analytics do have some memory footprint.
  58 // The &quot;aggregate&quot; step allocates some data structures to hold the aggregated
  59 // information for later output. These data structures live until they are
  60 // explicitly discarded (function &quot;discard&quot;) or until the VM terminates.
  61 // There is one exception: the function &quot;all&quot; does not leave any data
  62 // structures allocated.
  63 //
  64 // Requests for real-time, on-the-fly analysis can be issued via
  65 //   jcmd &lt;pid&gt; Compiler.CodeHeap_Analytics [&lt;function&gt;] [&lt;granularity&gt;]
  66 //
  67 // If you are (only) interested in how the CodeHeap looks like after running
  68 // a sample workload, you can use the command line option
  69 //   -XX:+PrintCodeHeapAnalytics
  70 // It will cause a full analysis to be written to tty. In addition, a full
  71 // analysis will be written the first time a &quot;CodeCache full&quot; condition is
  72 // detected.
  73 //
  74 // The command line option produces output identical to the jcmd function
  75 //   jcmd &lt;pid&gt; Compiler.CodeHeap_Analytics all 4096
  76 // ---------------------------------------------------------------------------------
  77 
  78 // With this declaration macro, it is possible to switch between
  79 //  - direct output into an argument-passed outputStream and
  80 //  - buffered output into a bufferedStream with subsequent flush
  81 //    of the filled buffer to the outputStream.
  82 #define USE_BUFFEREDSTREAM
  83 
  84 // There are instances when composing an output line or a small set of
  85 // output lines out of many tty-&gt;print() calls creates significant overhead.
  86 // Writing to a bufferedStream buffer first has a significant advantage:
  87 // It uses noticeably less cpu cycles and reduces (when writing to a
  88 // network file) the required bandwidth by at least a factor of ten. Observed on MacOS.
  89 // That clearly makes up for the increased code complexity.
  90 //
  91 // Conversion of existing code is easy and straightforward, if the code already
  92 // uses a parameterized output destination, e.g. &quot;outputStream st&quot;.
  93 //  - rename the formal parameter to any other name, e.g. out_st.
  94 //  - at a suitable place in your code, insert
  95 //      BUFFEREDSTEAM_DECL(buf_st, out_st)
  96 // This will provide all the declarations necessary. After that, all
  97 // buf_st-&gt;print() (and the like) calls will be directed to a bufferedStream object.
  98 // Once a block of output (a line or a small set of lines) is composed, insert
  99 //      BUFFEREDSTREAM_FLUSH(termstring)
 100 // to flush the bufferedStream to the final destination out_st. termstring is just
 101 // an arbitrary string (e.g. &quot;\n&quot;) which is appended to the bufferedStream before
 102 // being written to out_st. Be aware that the last character written MUST be a &#39;\n&#39;.
 103 // Otherwise, buf_st-&gt;position() does not correspond to out_st-&gt;position() any longer.
 104 //      BUFFEREDSTREAM_FLUSH_LOCKED(termstring)
 105 // does the same thing, protected by the ttyLocker lock.
 106 //      BUFFEREDSTREAM_FLUSH_IF(termstring, remSize)
 107 // does a flush only if the remaining buffer space is less than remSize.
 108 //
 109 // To activate, #define USE_BUFFERED_STREAM before including this header.
 110 // If not activated, output will directly go to the originally used outputStream
 111 // with no additional overhead.
 112 //
 113 #if defined(USE_BUFFEREDSTREAM)
 114 // All necessary declarations to print via a bufferedStream
 115 // This macro must be placed before any other BUFFEREDSTREAM*
 116 // macro in the function.
 117 #define BUFFEREDSTREAM_DECL_SIZE(_anyst, _outst, _capa)       \
 118     ResourceMark         _rm;                                 \
 119     /* _anyst  name of the stream as used in the code */      \
 120     /* _outst  stream where final output will go to   */      \
 121     /* _capa   allocated capacity of stream buffer    */      \
 122     size_t           _nflush = 0;                             \
 123     size_t     _nforcedflush = 0;                             \
 124     size_t      _nsavedflush = 0;                             \
 125     size_t     _nlockedflush = 0;                             \
 126     size_t     _nflush_bytes = 0;                             \
 127     size_t         _capacity = _capa;                         \
 128     bufferedStream   _sstobj(_capa);                          \
 129     bufferedStream*  _sstbuf = &amp;_sstobj;                      \
 130     outputStream*    _outbuf = _outst;                        \
 131     bufferedStream*   _anyst = &amp;_sstobj; /* any stream. Use this to just print - no buffer flush.  */
 132 
 133 // Same as above, but with fixed buffer size.
 134 #define BUFFEREDSTREAM_DECL(_anyst, _outst)                   \
 135     BUFFEREDSTREAM_DECL_SIZE(_anyst, _outst, 4*K);
 136 
 137 // Flush the buffer contents unconditionally.
 138 // No action if the buffer is empty.
 139 #define BUFFEREDSTREAM_FLUSH(_termString)                     \
 140     if (((_termString) != NULL) &amp;&amp; (strlen(_termString) &gt; 0)){\
 141       _sstbuf-&gt;print(&quot;%s&quot;, _termString);                      \
 142     }                                                         \
 143     if (_sstbuf != _outbuf) {                                 \
 144       if (_sstbuf-&gt;size() != 0) {                             \
 145         _nforcedflush++; _nflush_bytes += _sstbuf-&gt;size();    \
 146         _outbuf-&gt;print(&quot;%s&quot;, _sstbuf-&gt;as_string());           \
 147         _sstbuf-&gt;reset();                                     \
 148       }                                                       \
 149     }
 150 
 151 // Flush the buffer contents if the remaining capacity is
 152 // less than the given threshold.
 153 #define BUFFEREDSTREAM_FLUSH_IF(_termString, _remSize)        \
 154     if (((_termString) != NULL) &amp;&amp; (strlen(_termString) &gt; 0)){\
 155       _sstbuf-&gt;print(&quot;%s&quot;, _termString);                      \
 156     }                                                         \
 157     if (_sstbuf != _outbuf) {                                 \
 158       if ((_capacity - _sstbuf-&gt;size()) &lt; (size_t)(_remSize)){\
 159         _nflush++; _nforcedflush--;                           \
 160         BUFFEREDSTREAM_FLUSH(&quot;&quot;)                              \
 161       } else {                                                \
 162         _nsavedflush++;                                       \
 163       }                                                       \
 164     }
 165 
 166 // Flush the buffer contents if the remaining capacity is less
 167 // than the calculated threshold (256 bytes + capacity/16)
 168 // That should suffice for all reasonably sized output lines.
 169 #define BUFFEREDSTREAM_FLUSH_AUTO(_termString)                \
 170     BUFFEREDSTREAM_FLUSH_IF(_termString, 256+(_capacity&gt;&gt;4))
 171 
 172 #define BUFFEREDSTREAM_FLUSH_LOCKED(_termString)              \
 173     { ttyLocker ttyl;/* keep this output block together */    \
 174       _nlockedflush++;                                        \
 175       BUFFEREDSTREAM_FLUSH(_termString)                       \
 176     }
 177 
 178 // #define BUFFEREDSTREAM_FLUSH_STAT()                           \
 179 //     if (_sstbuf != _outbuf) {                                 \
 180 //       _outbuf-&gt;print_cr(&quot;%ld flushes (buffer full), %ld forced, %ld locked, %ld bytes total, %ld flushes saved&quot;, _nflush, _nforcedflush, _nlockedflush, _nflush_bytes, _nsavedflush); \
 181 //    }
 182 
 183 #define BUFFEREDSTREAM_FLUSH_STAT()
 184 #else
 185 #define BUFFEREDSTREAM_DECL_SIZE(_anyst, _outst, _capa)       \
 186     size_t       _capacity = _capa;                           \
 187     outputStream*  _outbuf = _outst;                          \
 188     outputStream*  _anyst  = _outst;   /* any stream. Use this to just print - no buffer flush.  */
 189 
 190 #define BUFFEREDSTREAM_DECL(_anyst, _outst)                   \
 191     BUFFEREDSTREAM_DECL_SIZE(_anyst, _outst, 4*K)
 192 
 193 #define BUFFEREDSTREAM_FLUSH(_termString)                     \
 194     if (((_termString) != NULL) &amp;&amp; (strlen(_termString) &gt; 0)){\
 195       _outbuf-&gt;print(&quot;%s&quot;, _termString);                      \
 196     }
 197 
 198 #define BUFFEREDSTREAM_FLUSH_IF(_termString, _remSize)        \
 199     BUFFEREDSTREAM_FLUSH(_termString)
 200 
 201 #define BUFFEREDSTREAM_FLUSH_AUTO(_termString)                \
 202     BUFFEREDSTREAM_FLUSH(_termString)
 203 
 204 #define BUFFEREDSTREAM_FLUSH_LOCKED(_termString)              \
 205     BUFFEREDSTREAM_FLUSH(_termString)
 206 
 207 #define BUFFEREDSTREAM_FLUSH_STAT()
 208 #endif
 209 #define HEX32_FORMAT  &quot;0x%x&quot;  // just a helper format string used below multiple times
 210 
 211 const char  blobTypeChar[] = {&#39; &#39;, &#39;C&#39;, &#39;N&#39;, &#39;I&#39;, &#39;X&#39;, &#39;Z&#39;, &#39;U&#39;, &#39;R&#39;, &#39;?&#39;, &#39;D&#39;, &#39;T&#39;, &#39;E&#39;, &#39;S&#39;, &#39;A&#39;, &#39;M&#39;, &#39;B&#39;, &#39;L&#39; };
 212 const char* blobTypeName[] = {&quot;noType&quot;
 213                              ,     &quot;nMethod (under construction)&quot;
 214                              ,          &quot;nMethod (active)&quot;
 215                              ,               &quot;nMethod (inactive)&quot;
 216                              ,                    &quot;nMethod (deopt)&quot;
 217                              ,                         &quot;nMethod (zombie)&quot;
 218                              ,                              &quot;nMethod (unloaded)&quot;
 219                              ,                                   &quot;runtime stub&quot;
 220                              ,                                        &quot;ricochet stub&quot;
 221                              ,                                             &quot;deopt stub&quot;
 222                              ,                                                  &quot;uncommon trap stub&quot;
 223                              ,                                                       &quot;exception stub&quot;
 224                              ,                                                            &quot;safepoint stub&quot;
 225                              ,                                                                 &quot;adapter blob&quot;
 226                              ,                                                                      &quot;MH adapter blob&quot;
 227                              ,                                                                           &quot;buffer blob&quot;
 228                              ,                                                                                &quot;lastType&quot;
 229                              };
 230 const char* compTypeName[] = { &quot;none&quot;, &quot;c1&quot;, &quot;c2&quot;, &quot;jvmci&quot; };
 231 
 232 // Be prepared for ten different CodeHeap segments. Should be enough for a few years.
 233 const  unsigned int        nSizeDistElements = 31;  // logarithmic range growth, max size: 2**32
 234 const  unsigned int        maxTopSizeBlocks  = 50;
 235 const  unsigned int        tsbStopper        = 2 * maxTopSizeBlocks;
 236 const  unsigned int        maxHeaps          = 10;
 237 static unsigned int        nHeaps            = 0;
 238 static struct CodeHeapStat CodeHeapStatArray[maxHeaps];
 239 
 240 // static struct StatElement *StatArray      = NULL;
 241 static StatElement* StatArray             = NULL;
 242 static int          log2_seg_size         = 0;
 243 static size_t       seg_size              = 0;
 244 static size_t       alloc_granules        = 0;
 245 static size_t       granule_size          = 0;
 246 static bool         segment_granules      = false;
 247 static unsigned int nBlocks_t1            = 0;  // counting &quot;in_use&quot; nmethods only.
 248 static unsigned int nBlocks_t2            = 0;  // counting &quot;in_use&quot; nmethods only.
 249 static unsigned int nBlocks_alive         = 0;  // counting &quot;not_used&quot; and &quot;not_entrant&quot; nmethods only.
 250 static unsigned int nBlocks_dead          = 0;  // counting &quot;zombie&quot; and &quot;unloaded&quot; methods only.
 251 static unsigned int nBlocks_inconstr      = 0;  // counting &quot;inconstruction&quot; nmethods only. This is a transient state.
 252 static unsigned int nBlocks_unloaded      = 0;  // counting &quot;unloaded&quot; nmethods only. This is a transient state.
 253 static unsigned int nBlocks_stub          = 0;
 254 
 255 static struct FreeBlk*          FreeArray = NULL;
 256 static unsigned int      alloc_freeBlocks = 0;
 257 
 258 static struct TopSizeBlk*    TopSizeArray = NULL;
 259 static unsigned int   alloc_topSizeBlocks = 0;
 260 static unsigned int    used_topSizeBlocks = 0;
 261 
 262 static struct SizeDistributionElement*  SizeDistributionArray = NULL;
 263 
 264 // nMethod temperature (hotness) indicators.
 265 static int                     avgTemp    = 0;
 266 static int                     maxTemp    = 0;
 267 static int                     minTemp    = 0;
 268 
 269 static unsigned int  latest_compilation_id   = 0;
 270 static volatile bool initialization_complete = false;
 271 
 272 const char* CodeHeapState::get_heapName(CodeHeap* heap) {
 273   if (SegmentedCodeCache) {
 274     return heap-&gt;name();
 275   } else {
 276     return &quot;CodeHeap&quot;;
 277   }
 278 }
 279 
 280 // returns the index for the heap being processed.
 281 unsigned int CodeHeapState::findHeapIndex(outputStream* out, const char* heapName) {
 282   if (heapName == NULL) {
 283     return maxHeaps;
 284   }
 285   if (SegmentedCodeCache) {
 286     // Search for a pre-existing entry. If found, return that index.
 287     for (unsigned int i = 0; i &lt; nHeaps; i++) {
 288       if (CodeHeapStatArray[i].heapName != NULL &amp;&amp; strcmp(heapName, CodeHeapStatArray[i].heapName) == 0) {
 289         return i;
 290       }
 291     }
 292 
 293     // check if there are more code heap segments than we can handle.
 294     if (nHeaps == maxHeaps) {
 295       out-&gt;print_cr(&quot;Too many heap segments for current limit(%d).&quot;, maxHeaps);
 296       return maxHeaps;
 297     }
 298 
 299     // allocate new slot in StatArray.
 300     CodeHeapStatArray[nHeaps].heapName = heapName;
 301     return nHeaps++;
 302   } else {
 303     nHeaps = 1;
 304     CodeHeapStatArray[0].heapName = heapName;
 305     return 0; // This is the default index if CodeCache is not segmented.
 306   }
 307 }
 308 
 309 void CodeHeapState::get_HeapStatGlobals(outputStream* out, const char* heapName) {
 310   unsigned int ix = findHeapIndex(out, heapName);
 311   if (ix &lt; maxHeaps) {
 312     StatArray             = CodeHeapStatArray[ix].StatArray;
 313     seg_size              = CodeHeapStatArray[ix].segment_size;
 314     log2_seg_size         = seg_size == 0 ? 0 : exact_log2(seg_size);
 315     alloc_granules        = CodeHeapStatArray[ix].alloc_granules;
 316     granule_size          = CodeHeapStatArray[ix].granule_size;
 317     segment_granules      = CodeHeapStatArray[ix].segment_granules;
 318     nBlocks_t1            = CodeHeapStatArray[ix].nBlocks_t1;
 319     nBlocks_t2            = CodeHeapStatArray[ix].nBlocks_t2;
 320     nBlocks_alive         = CodeHeapStatArray[ix].nBlocks_alive;
 321     nBlocks_dead          = CodeHeapStatArray[ix].nBlocks_dead;
 322     nBlocks_inconstr      = CodeHeapStatArray[ix].nBlocks_inconstr;
 323     nBlocks_unloaded      = CodeHeapStatArray[ix].nBlocks_unloaded;
 324     nBlocks_stub          = CodeHeapStatArray[ix].nBlocks_stub;
 325     FreeArray             = CodeHeapStatArray[ix].FreeArray;
 326     alloc_freeBlocks      = CodeHeapStatArray[ix].alloc_freeBlocks;
 327     TopSizeArray          = CodeHeapStatArray[ix].TopSizeArray;
 328     alloc_topSizeBlocks   = CodeHeapStatArray[ix].alloc_topSizeBlocks;
 329     used_topSizeBlocks    = CodeHeapStatArray[ix].used_topSizeBlocks;
 330     SizeDistributionArray = CodeHeapStatArray[ix].SizeDistributionArray;
 331     avgTemp               = CodeHeapStatArray[ix].avgTemp;
 332     maxTemp               = CodeHeapStatArray[ix].maxTemp;
 333     minTemp               = CodeHeapStatArray[ix].minTemp;
 334   } else {
 335     StatArray             = NULL;
 336     seg_size              = 0;
 337     log2_seg_size         = 0;
 338     alloc_granules        = 0;
 339     granule_size          = 0;
 340     segment_granules      = false;
 341     nBlocks_t1            = 0;
 342     nBlocks_t2            = 0;
 343     nBlocks_alive         = 0;
 344     nBlocks_dead          = 0;
 345     nBlocks_inconstr      = 0;
 346     nBlocks_unloaded      = 0;
 347     nBlocks_stub          = 0;
 348     FreeArray             = NULL;
 349     alloc_freeBlocks      = 0;
 350     TopSizeArray          = NULL;
 351     alloc_topSizeBlocks   = 0;
 352     used_topSizeBlocks    = 0;
 353     SizeDistributionArray = NULL;
 354     avgTemp               = 0;
 355     maxTemp               = 0;
 356     minTemp               = 0;
 357   }
 358 }
 359 
 360 void CodeHeapState::set_HeapStatGlobals(outputStream* out, const char* heapName) {
 361   unsigned int ix = findHeapIndex(out, heapName);
 362   if (ix &lt; maxHeaps) {
 363     CodeHeapStatArray[ix].StatArray             = StatArray;
 364     CodeHeapStatArray[ix].segment_size          = seg_size;
 365     CodeHeapStatArray[ix].alloc_granules        = alloc_granules;
 366     CodeHeapStatArray[ix].granule_size          = granule_size;
 367     CodeHeapStatArray[ix].segment_granules      = segment_granules;
 368     CodeHeapStatArray[ix].nBlocks_t1            = nBlocks_t1;
 369     CodeHeapStatArray[ix].nBlocks_t2            = nBlocks_t2;
 370     CodeHeapStatArray[ix].nBlocks_alive         = nBlocks_alive;
 371     CodeHeapStatArray[ix].nBlocks_dead          = nBlocks_dead;
 372     CodeHeapStatArray[ix].nBlocks_inconstr      = nBlocks_inconstr;
 373     CodeHeapStatArray[ix].nBlocks_unloaded      = nBlocks_unloaded;
 374     CodeHeapStatArray[ix].nBlocks_stub          = nBlocks_stub;
 375     CodeHeapStatArray[ix].FreeArray             = FreeArray;
 376     CodeHeapStatArray[ix].alloc_freeBlocks      = alloc_freeBlocks;
 377     CodeHeapStatArray[ix].TopSizeArray          = TopSizeArray;
 378     CodeHeapStatArray[ix].alloc_topSizeBlocks   = alloc_topSizeBlocks;
 379     CodeHeapStatArray[ix].used_topSizeBlocks    = used_topSizeBlocks;
 380     CodeHeapStatArray[ix].SizeDistributionArray = SizeDistributionArray;
 381     CodeHeapStatArray[ix].avgTemp               = avgTemp;
 382     CodeHeapStatArray[ix].maxTemp               = maxTemp;
 383     CodeHeapStatArray[ix].minTemp               = minTemp;
 384   }
 385 }
 386 
 387 //---&lt;  get a new statistics array  &gt;---
 388 void CodeHeapState::prepare_StatArray(outputStream* out, size_t nElem, size_t granularity, const char* heapName) {
 389   if (StatArray == NULL) {
 390     StatArray      = new StatElement[nElem];
 391     //---&lt;  reset some counts  &gt;---
 392     alloc_granules = nElem;
 393     granule_size   = granularity;
 394   }
 395 
 396   if (StatArray == NULL) {
 397     //---&lt;  just do nothing if allocation failed  &gt;---
 398     out-&gt;print_cr(&quot;Statistics could not be collected for %s, probably out of memory.&quot;, heapName);
 399     out-&gt;print_cr(&quot;Current granularity is &quot; SIZE_FORMAT &quot; bytes. Try a coarser granularity.&quot;, granularity);
 400     alloc_granules = 0;
 401     granule_size   = 0;
 402   } else {
 403     //---&lt;  initialize statistics array  &gt;---
 404     memset((void*)StatArray, 0, nElem*sizeof(StatElement));
 405   }
 406 }
 407 
 408 //---&lt;  get a new free block array  &gt;---
 409 void CodeHeapState::prepare_FreeArray(outputStream* out, unsigned int nElem, const char* heapName) {
 410   if (FreeArray == NULL) {
 411     FreeArray      = new FreeBlk[nElem];
 412     //---&lt;  reset some counts  &gt;---
 413     alloc_freeBlocks = nElem;
 414   }
 415 
 416   if (FreeArray == NULL) {
 417     //---&lt;  just do nothing if allocation failed  &gt;---
 418     out-&gt;print_cr(&quot;Free space analysis cannot be done for %s, probably out of memory.&quot;, heapName);
 419     alloc_freeBlocks = 0;
 420   } else {
 421     //---&lt;  initialize free block array  &gt;---
 422     memset((void*)FreeArray, 0, alloc_freeBlocks*sizeof(FreeBlk));
 423   }
 424 }
 425 
 426 //---&lt;  get a new TopSizeArray  &gt;---
 427 void CodeHeapState::prepare_TopSizeArray(outputStream* out, unsigned int nElem, const char* heapName) {
 428   if (TopSizeArray == NULL) {
 429     TopSizeArray   = new TopSizeBlk[nElem];
 430     //---&lt;  reset some counts  &gt;---
 431     alloc_topSizeBlocks = nElem;
 432     used_topSizeBlocks  = 0;
 433   }
 434 
 435   if (TopSizeArray == NULL) {
 436     //---&lt;  just do nothing if allocation failed  &gt;---
 437     out-&gt;print_cr(&quot;Top-%d list of largest CodeHeap blocks can not be collected for %s, probably out of memory.&quot;, nElem, heapName);
 438     alloc_topSizeBlocks = 0;
 439   } else {
 440     //---&lt;  initialize TopSizeArray  &gt;---
 441     memset((void*)TopSizeArray, 0, nElem*sizeof(TopSizeBlk));
 442     used_topSizeBlocks  = 0;
 443   }
 444 }
 445 
 446 //---&lt;  get a new SizeDistributionArray  &gt;---
 447 void CodeHeapState::prepare_SizeDistArray(outputStream* out, unsigned int nElem, const char* heapName) {
 448   if (SizeDistributionArray == NULL) {
 449     SizeDistributionArray = new SizeDistributionElement[nElem];
 450   }
 451 
 452   if (SizeDistributionArray == NULL) {
 453     //---&lt;  just do nothing if allocation failed  &gt;---
 454     out-&gt;print_cr(&quot;Size distribution can not be collected for %s, probably out of memory.&quot;, heapName);
 455   } else {
 456     //---&lt;  initialize SizeDistArray  &gt;---
 457     memset((void*)SizeDistributionArray, 0, nElem*sizeof(SizeDistributionElement));
 458     // Logarithmic range growth. First range starts at _segment_size.
 459     SizeDistributionArray[log2_seg_size-1].rangeEnd = 1U;
 460     for (unsigned int i = log2_seg_size; i &lt; nElem; i++) {
 461       SizeDistributionArray[i].rangeStart = 1U &lt;&lt; (i     - log2_seg_size);
 462       SizeDistributionArray[i].rangeEnd   = 1U &lt;&lt; ((i+1) - log2_seg_size);
 463     }
 464   }
 465 }
 466 
 467 //---&lt;  get a new SizeDistributionArray  &gt;---
 468 void CodeHeapState::update_SizeDistArray(outputStream* out, unsigned int len) {
 469   if (SizeDistributionArray != NULL) {
 470     for (unsigned int i = log2_seg_size-1; i &lt; nSizeDistElements; i++) {
 471       if ((SizeDistributionArray[i].rangeStart &lt;= len) &amp;&amp; (len &lt; SizeDistributionArray[i].rangeEnd)) {
 472         SizeDistributionArray[i].lenSum += len;
 473         SizeDistributionArray[i].count++;
 474         break;
 475       }
 476     }
 477   }
 478 }
 479 
 480 void CodeHeapState::discard_StatArray(outputStream* out) {
 481   if (StatArray != NULL) {
 482     delete StatArray;
 483     StatArray        = NULL;
 484     alloc_granules   = 0;
 485     granule_size     = 0;
 486   }
 487 }
 488 
 489 void CodeHeapState::discard_FreeArray(outputStream* out) {
 490   if (FreeArray != NULL) {
 491     delete[] FreeArray;
 492     FreeArray        = NULL;
 493     alloc_freeBlocks = 0;
 494   }
 495 }
 496 
 497 void CodeHeapState::discard_TopSizeArray(outputStream* out) {
 498   if (TopSizeArray != NULL) {
 499     delete[] TopSizeArray;
 500     TopSizeArray        = NULL;
 501     alloc_topSizeBlocks = 0;
 502     used_topSizeBlocks  = 0;
 503   }
 504 }
 505 
 506 void CodeHeapState::discard_SizeDistArray(outputStream* out) {
 507   if (SizeDistributionArray != NULL) {
 508     delete[] SizeDistributionArray;
 509     SizeDistributionArray = NULL;
 510   }
 511 }
 512 
 513 // Discard all allocated internal data structures.
 514 // This should be done after an analysis session is completed.
 515 void CodeHeapState::discard(outputStream* out, CodeHeap* heap) {
 516   if (!initialization_complete) {
 517     return;
 518   }
 519 
 520   if (nHeaps &gt; 0) {
 521     for (unsigned int ix = 0; ix &lt; nHeaps; ix++) {
 522       get_HeapStatGlobals(out, CodeHeapStatArray[ix].heapName);
 523       discard_StatArray(out);
 524       discard_FreeArray(out);
 525       discard_TopSizeArray(out);
 526       discard_SizeDistArray(out);
 527       set_HeapStatGlobals(out, CodeHeapStatArray[ix].heapName);
 528       CodeHeapStatArray[ix].heapName = NULL;
 529     }
 530     nHeaps = 0;
 531   }
 532 }
 533 
 534 void CodeHeapState::aggregate(outputStream* out, CodeHeap* heap, size_t granularity) {
 535   unsigned int nBlocks_free    = 0;
 536   unsigned int nBlocks_used    = 0;
 537   unsigned int nBlocks_zomb    = 0;
 538   unsigned int nBlocks_disconn = 0;
 539   unsigned int nBlocks_notentr = 0;
 540 
 541   //---&lt;  max &amp; min of TopSizeArray  &gt;---
 542   //  it is sufficient to have these sizes as 32bit unsigned ints.
 543   //  The CodeHeap is limited in size to 4GB. Furthermore, the sizes
 544   //  are stored in _segment_size units, scaling them down by a factor of 64 (at least).
 545   unsigned int  currMax          = 0;
 546   unsigned int  currMin          = 0;
 547   unsigned int  currMin_ix       = 0;
 548   unsigned long total_iterations = 0;
 549 
 550   bool  done             = false;
 551   const int min_granules = 256;
 552   const int max_granules = 512*K; // limits analyzable CodeHeap (with segment_granules) to 32M..128M
 553                                   // results in StatArray size of 24M (= max_granules * 48 Bytes per element)
 554                                   // For a 1GB CodeHeap, the granule size must be at least 2kB to not violate the max_granles limit.
 555   const char* heapName   = get_heapName(heap);
 556   BUFFEREDSTREAM_DECL(ast, out)
 557 
 558   if (!initialization_complete) {
 559     memset(CodeHeapStatArray, 0, sizeof(CodeHeapStatArray));
 560     initialization_complete = true;
 561 
 562     printBox(ast, &#39;=&#39;, &quot;C O D E   H E A P   A N A L Y S I S   (general remarks)&quot;, NULL);
 563     ast-&gt;print_cr(&quot;   The code heap analysis function provides deep insights into\n&quot;
 564                   &quot;   the inner workings and the internal state of the Java VM&#39;s\n&quot;
 565                   &quot;   code cache - the place where all the JVM generated machine\n&quot;
 566                   &quot;   code is stored.\n&quot;
 567                   &quot;   \n&quot;
 568                   &quot;   This function is designed and provided for support engineers\n&quot;
 569                   &quot;   to help them understand and solve issues in customer systems.\n&quot;
 570                   &quot;   It is not intended for use and interpretation by other persons.\n&quot;
 571                   &quot;   \n&quot;);
 572     BUFFEREDSTREAM_FLUSH(&quot;&quot;)
 573   }
 574   get_HeapStatGlobals(out, heapName);
 575 
 576 
 577   // Since we are (and must be) analyzing the CodeHeap contents under the CodeCache_lock,
 578   // all heap information is &quot;constant&quot; and can be safely extracted/calculated before we
 579   // enter the while() loop. Actually, the loop will only be iterated once.
 580   char*  low_bound     = heap-&gt;low_boundary();
 581   size_t size          = heap-&gt;capacity();
 582   size_t res_size      = heap-&gt;max_capacity();
 583   seg_size             = heap-&gt;segment_size();
 584   log2_seg_size        = seg_size == 0 ? 0 : exact_log2(seg_size);  // This is a global static value.
 585 
 586   if (seg_size == 0) {
 587     printBox(ast, &#39;-&#39;, &quot;Heap not fully initialized yet, segment size is zero for segment &quot;, heapName);
 588     BUFFEREDSTREAM_FLUSH(&quot;&quot;)
 589     return;
 590   }
 591 
 592   if (!CodeCache_lock-&gt;owned_by_self()) {
 593     printBox(ast, &#39;-&#39;, &quot;aggregate function called without holding the CodeCache_lock for &quot;, heapName);
 594     BUFFEREDSTREAM_FLUSH(&quot;&quot;)
 595     return;
 596   }
 597 
 598   // Calculate granularity of analysis (and output).
 599   //   The CodeHeap is managed (allocated) in segments (units) of CodeCacheSegmentSize.
 600   //   The CodeHeap can become fairly large, in particular in productive real-life systems.
 601   //
 602   //   It is often neither feasible nor desirable to aggregate the data with the highest possible
 603   //   level of detail, i.e. inspecting and printing each segment on its own.
 604   //
 605   //   The granularity parameter allows to specify the level of detail available in the analysis.
 606   //   It must be a positive multiple of the segment size and should be selected such that enough
 607   //   detail is provided while, at the same time, the printed output does not explode.
 608   //
 609   //   By manipulating the granularity value, we enforce that at least min_granules units
 610   //   of analysis are available. We also enforce an upper limit of max_granules units to
 611   //   keep the amount of allocated storage in check.
 612   //
 613   //   Finally, we adjust the granularity such that each granule covers at most 64k-1 segments.
 614   //   This is necessary to prevent an unsigned short overflow while accumulating space information.
 615   //
 616   assert(granularity &gt; 0, &quot;granularity should be positive.&quot;);
 617 
 618   if (granularity &gt; size) {
 619     granularity = size;
 620   }
 621   if (size/granularity &lt; min_granules) {
 622     granularity = size/min_granules;                                   // at least min_granules granules
 623   }
 624   granularity = granularity &amp; (~(seg_size - 1));                       // must be multiple of seg_size
 625   if (granularity &lt; seg_size) {
 626     granularity = seg_size;                                            // must be at least seg_size
 627   }
 628   if (size/granularity &gt; max_granules) {
 629     granularity = size/max_granules;                                   // at most max_granules granules
 630   }
 631   granularity = granularity &amp; (~(seg_size - 1));                       // must be multiple of seg_size
 632   if (granularity&gt;&gt;log2_seg_size &gt;= (1L&lt;&lt;sizeof(unsigned short)*8)) {
 633     granularity = ((1L&lt;&lt;(sizeof(unsigned short)*8))-1)&lt;&lt;log2_seg_size; // Limit: (64k-1) * seg_size
 634   }
 635   segment_granules = granularity == seg_size;
 636   size_t granules  = (size + (granularity-1))/granularity;
 637 
 638   printBox(ast, &#39;=&#39;, &quot;C O D E   H E A P   A N A L Y S I S   (used blocks) for segment &quot;, heapName);
 639   ast-&gt;print_cr(&quot;   The aggregate step takes an aggregated snapshot of the CodeHeap.\n&quot;
 640                 &quot;   Subsequent print functions create their output based on this snapshot.\n&quot;
 641                 &quot;   The CodeHeap is a living thing, and every effort has been made for the\n&quot;
 642                 &quot;   collected data to be consistent. Only the method names and signatures\n&quot;
 643                 &quot;   are retrieved at print time. That may lead to rare cases where the\n&quot;
 644                 &quot;   name of a method is no longer available, e.g. because it was unloaded.\n&quot;);
 645   ast-&gt;print_cr(&quot;   CodeHeap committed size &quot; SIZE_FORMAT &quot;K (&quot; SIZE_FORMAT &quot;M), reserved size &quot; SIZE_FORMAT &quot;K (&quot; SIZE_FORMAT &quot;M), %d%% occupied.&quot;,
 646                 size/(size_t)K, size/(size_t)M, res_size/(size_t)K, res_size/(size_t)M, (unsigned int)(100.0*size/res_size));
 647   ast-&gt;print_cr(&quot;   CodeHeap allocation segment size is &quot; SIZE_FORMAT &quot; bytes. This is the smallest possible granularity.&quot;, seg_size);
 648   ast-&gt;print_cr(&quot;   CodeHeap (committed part) is mapped to &quot; SIZE_FORMAT &quot; granules of size &quot; SIZE_FORMAT &quot; bytes.&quot;, granules, granularity);
 649   ast-&gt;print_cr(&quot;   Each granule takes &quot; SIZE_FORMAT &quot; bytes of C heap, that is &quot; SIZE_FORMAT &quot;K in total for statistics data.&quot;, sizeof(StatElement), (sizeof(StatElement)*granules)/(size_t)K);
 650   ast-&gt;print_cr(&quot;   The number of granules is limited to %dk, requiring a granules size of at least %d bytes for a 1GB heap.&quot;, (unsigned int)(max_granules/K), (unsigned int)(G/max_granules));
 651   BUFFEREDSTREAM_FLUSH(&quot;\n&quot;)
 652 
 653 
 654   while (!done) {
 655     //---&lt;  reset counters with every aggregation  &gt;---
 656     nBlocks_t1       = 0;
 657     nBlocks_t2       = 0;
 658     nBlocks_alive    = 0;
 659     nBlocks_dead     = 0;
 660     nBlocks_inconstr = 0;
 661     nBlocks_unloaded = 0;
 662     nBlocks_stub     = 0;
 663 
 664     nBlocks_free     = 0;
 665     nBlocks_used     = 0;
 666     nBlocks_zomb     = 0;
 667     nBlocks_disconn  = 0;
 668     nBlocks_notentr  = 0;
 669 
 670     //---&lt;  discard old arrays if size does not match  &gt;---
 671     if (granules != alloc_granules) {
 672       discard_StatArray(out);
 673       discard_TopSizeArray(out);
 674     }
 675 
 676     //---&lt;  allocate arrays if they don&#39;t yet exist, initialize  &gt;---
 677     prepare_StatArray(out, granules, granularity, heapName);
 678     if (StatArray == NULL) {
 679       set_HeapStatGlobals(out, heapName);
 680       return;
 681     }
 682     prepare_TopSizeArray(out, maxTopSizeBlocks, heapName);
 683     prepare_SizeDistArray(out, nSizeDistElements, heapName);
 684 
 685     latest_compilation_id = CompileBroker::get_compilation_id();
 686     unsigned int highest_compilation_id = 0;
 687     size_t       usedSpace     = 0;
 688     size_t       t1Space       = 0;
 689     size_t       t2Space       = 0;
 690     size_t       aliveSpace    = 0;
 691     size_t       disconnSpace  = 0;
 692     size_t       notentrSpace  = 0;
 693     size_t       deadSpace     = 0;
 694     size_t       inconstrSpace = 0;
 695     size_t       unloadedSpace = 0;
 696     size_t       stubSpace     = 0;
 697     size_t       freeSpace     = 0;
 698     size_t       maxFreeSize   = 0;
 699     HeapBlock*   maxFreeBlock  = NULL;
 700     bool         insane        = false;
 701 
 702     int64_t hotnessAccumulator = 0;
 703     unsigned int n_methods     = 0;
 704     avgTemp       = 0;
 705     minTemp       = (int)(res_size &gt; M ? (res_size/M)*2 : 1);
 706     maxTemp       = -minTemp;
 707 
 708     for (HeapBlock *h = heap-&gt;first_block(); h != NULL &amp;&amp; !insane; h = heap-&gt;next_block(h)) {
 709       unsigned int hb_len     = (unsigned int)h-&gt;length();  // despite being size_t, length can never overflow an unsigned int.
 710       size_t       hb_bytelen = ((size_t)hb_len)&lt;&lt;log2_seg_size;
 711       unsigned int ix_beg     = (unsigned int)(((char*)h-low_bound)/granule_size);
 712       unsigned int ix_end     = (unsigned int)(((char*)h-low_bound+(hb_bytelen-1))/granule_size);
 713       unsigned int compile_id = 0;
 714       CompLevel    comp_lvl   = CompLevel_none;
 715       compType     cType      = noComp;
 716       blobType     cbType     = noType;
 717 
 718       //---&lt;  some sanity checks  &gt;---
 719       // Do not assert here, just check, print error message and return.
 720       // This is a diagnostic function. It is not supposed to tear down the VM.
 721       if ((char*)h &lt;  low_bound) {
 722         insane = true; ast-&gt;print_cr(&quot;Sanity check: HeapBlock @%p below low bound (%p)&quot;, (char*)h, low_bound);
 723       }
 724       if ((char*)h &gt;  (low_bound + res_size)) {
 725         insane = true; ast-&gt;print_cr(&quot;Sanity check: HeapBlock @%p outside reserved range (%p)&quot;, (char*)h, low_bound + res_size);
 726       }
 727       if ((char*)h &gt;  (low_bound + size)) {
 728         insane = true; ast-&gt;print_cr(&quot;Sanity check: HeapBlock @%p outside used range (%p)&quot;, (char*)h, low_bound + size);
 729       }
 730       if (ix_end   &gt;= granules) {
 731         insane = true; ast-&gt;print_cr(&quot;Sanity check: end index (%d) out of bounds (&quot; SIZE_FORMAT &quot;)&quot;, ix_end, granules);
 732       }
 733       if (size     != heap-&gt;capacity()) {
 734         insane = true; ast-&gt;print_cr(&quot;Sanity check: code heap capacity has changed (&quot; SIZE_FORMAT &quot;K to &quot; SIZE_FORMAT &quot;K)&quot;, size/(size_t)K, heap-&gt;capacity()/(size_t)K);
 735       }
 736       if (ix_beg   &gt;  ix_end) {
 737         insane = true; ast-&gt;print_cr(&quot;Sanity check: end index (%d) lower than begin index (%d)&quot;, ix_end, ix_beg);
 738       }
 739       if (insane) {
 740         BUFFEREDSTREAM_FLUSH(&quot;&quot;)
 741         continue;
 742       }
 743 
 744       if (h-&gt;free()) {
 745         nBlocks_free++;
 746         freeSpace    += hb_bytelen;
 747         if (hb_bytelen &gt; maxFreeSize) {
 748           maxFreeSize   = hb_bytelen;
 749           maxFreeBlock  = h;
 750         }
 751       } else {
 752         update_SizeDistArray(out, hb_len);
 753         nBlocks_used++;
 754         usedSpace    += hb_bytelen;
 755         CodeBlob* cb  = (CodeBlob*)heap-&gt;find_start(h);
 756         if (cb != NULL) {
 757           cbType = get_cbType(cb);
 758           if (cb-&gt;is_nmethod()) {
 759             compile_id = ((nmethod*)cb)-&gt;compile_id();
 760             comp_lvl   = (CompLevel)((nmethod*)cb)-&gt;comp_level();
 761             if (((nmethod*)cb)-&gt;is_compiled_by_c1()) {
 762               cType = c1;
 763             }
 764             if (((nmethod*)cb)-&gt;is_compiled_by_c2()) {
 765               cType = c2;
 766             }
 767             if (((nmethod*)cb)-&gt;is_compiled_by_jvmci()) {
 768               cType = jvmci;
 769             }
 770             switch (cbType) {
 771               case nMethod_inuse: { // only for executable methods!!!
 772                 // space for these cbs is accounted for later.
 773                 int temperature = ((nmethod*)cb)-&gt;hotness_counter();
 774                 hotnessAccumulator += temperature;
 775                 n_methods++;
 776                 maxTemp = (temperature &gt; maxTemp) ? temperature : maxTemp;
 777                 minTemp = (temperature &lt; minTemp) ? temperature : minTemp;
 778                 break;
 779               }
 780               case nMethod_notused:
 781                 nBlocks_alive++;
 782                 nBlocks_disconn++;
 783                 aliveSpace     += hb_bytelen;
 784                 disconnSpace   += hb_bytelen;
 785                 break;
 786               case nMethod_notentrant:  // equivalent to nMethod_alive
 787                 nBlocks_alive++;
 788                 nBlocks_notentr++;
 789                 aliveSpace     += hb_bytelen;
 790                 notentrSpace   += hb_bytelen;
 791                 break;
 792               case nMethod_unloaded:
 793                 nBlocks_unloaded++;
 794                 unloadedSpace  += hb_bytelen;
 795                 break;
 796               case nMethod_dead:
 797                 nBlocks_dead++;
 798                 deadSpace      += hb_bytelen;
 799                 break;
 800               case nMethod_inconstruction:
 801                 nBlocks_inconstr++;
 802                 inconstrSpace  += hb_bytelen;
 803                 break;
 804               default:
 805                 break;
 806             }
 807           }
 808 
 809           //------------------------------------------
 810           //---&lt;  register block in TopSizeArray  &gt;---
 811           //------------------------------------------
 812           if (alloc_topSizeBlocks &gt; 0) {
 813             if (used_topSizeBlocks == 0) {
 814               TopSizeArray[0].start    = h;
 815               TopSizeArray[0].len      = hb_len;
 816               TopSizeArray[0].index    = tsbStopper;
 817               TopSizeArray[0].compiler = cType;
 818               TopSizeArray[0].level    = comp_lvl;
 819               TopSizeArray[0].type     = cbType;
 820               currMax    = hb_len;
 821               currMin    = hb_len;
 822               currMin_ix = 0;
 823               used_topSizeBlocks++;
 824             // This check roughly cuts 5000 iterations (JVM98, mixed, dbg, termination stats):
 825             } else if ((used_topSizeBlocks &lt; alloc_topSizeBlocks) &amp;&amp; (hb_len &lt; currMin)) {
 826               //---&lt;  all blocks in list are larger, but there is room left in array  &gt;---
 827               TopSizeArray[currMin_ix].index = used_topSizeBlocks;
 828               TopSizeArray[used_topSizeBlocks].start    = h;
 829               TopSizeArray[used_topSizeBlocks].len      = hb_len;
 830               TopSizeArray[used_topSizeBlocks].index    = tsbStopper;
 831               TopSizeArray[used_topSizeBlocks].compiler = cType;
 832               TopSizeArray[used_topSizeBlocks].level    = comp_lvl;
 833               TopSizeArray[used_topSizeBlocks].type     = cbType;
 834               currMin    = hb_len;
 835               currMin_ix = used_topSizeBlocks;
 836               used_topSizeBlocks++;
 837             } else {
 838               // This check cuts total_iterations by a factor of 6 (JVM98, mixed, dbg, termination stats):
 839               //   We don&#39;t need to search the list if we know beforehand that the current block size is
 840               //   smaller than the currently recorded minimum and there is no free entry left in the list.
 841               if (!((used_topSizeBlocks == alloc_topSizeBlocks) &amp;&amp; (hb_len &lt;= currMin))) {
 842                 if (currMax &lt; hb_len) {
 843                   currMax = hb_len;
 844                 }
 845                 unsigned int i;
 846                 unsigned int prev_i  = tsbStopper;
 847                 unsigned int limit_i =  0;
 848                 for (i = 0; i != tsbStopper; i = TopSizeArray[i].index) {
 849                   if (limit_i++ &gt;= alloc_topSizeBlocks) {
 850                     insane = true; break; // emergency exit
 851                   }
 852                   if (i &gt;= used_topSizeBlocks)  {
 853                     insane = true; break; // emergency exit
 854                   }
 855                   total_iterations++;
 856                   if (TopSizeArray[i].len &lt; hb_len) {
 857                     //---&lt;  We want to insert here, element &lt;i&gt; is smaller than the current one  &gt;---
 858                     if (used_topSizeBlocks &lt; alloc_topSizeBlocks) { // still room for a new entry to insert
 859                       // old entry gets moved to the next free element of the array.
 860                       // That&#39;s necessary to keep the entry for the largest block at index 0.
 861                       // This move might cause the current minimum to be moved to another place
 862                       if (i == currMin_ix) {
 863                         assert(TopSizeArray[i].len == currMin, &quot;sort error&quot;);
 864                         currMin_ix = used_topSizeBlocks;
 865                       }
 866                       memcpy((void*)&amp;TopSizeArray[used_topSizeBlocks], (void*)&amp;TopSizeArray[i], sizeof(TopSizeBlk));
 867                       TopSizeArray[i].start    = h;
 868                       TopSizeArray[i].len      = hb_len;
 869                       TopSizeArray[i].index    = used_topSizeBlocks;
 870                       TopSizeArray[i].compiler = cType;
 871                       TopSizeArray[i].level    = comp_lvl;
 872                       TopSizeArray[i].type     = cbType;
 873                       used_topSizeBlocks++;
 874                     } else { // no room for new entries, current block replaces entry for smallest block
 875                       //---&lt;  Find last entry (entry for smallest remembered block)  &gt;---
 876                       unsigned int      j  = i;
 877                       unsigned int prev_j  = tsbStopper;
 878                       unsigned int limit_j = 0;
 879                       while (TopSizeArray[j].index != tsbStopper) {
 880                         if (limit_j++ &gt;= alloc_topSizeBlocks) {
 881                           insane = true; break; // emergency exit
 882                         }
 883                         if (j &gt;= used_topSizeBlocks)  {
 884                           insane = true; break; // emergency exit
 885                         }
 886                         total_iterations++;
 887                         prev_j = j;
 888                         j      = TopSizeArray[j].index;
 889                       }
 890                       if (!insane) {
 891                         if (prev_j == tsbStopper) {
 892                           //---&lt;  Above while loop did not iterate, we already are the min entry  &gt;---
 893                           //---&lt;  We have to just replace the smallest entry                      &gt;---
 894                           currMin    = hb_len;
 895                           currMin_ix = j;
 896                           TopSizeArray[j].start    = h;
 897                           TopSizeArray[j].len      = hb_len;
 898                           TopSizeArray[j].index    = tsbStopper; // already set!!
 899                           TopSizeArray[j].compiler = cType;
 900                           TopSizeArray[j].level    = comp_lvl;
 901                           TopSizeArray[j].type     = cbType;
 902                         } else {
 903                           //---&lt;  second-smallest entry is now smallest  &gt;---
 904                           TopSizeArray[prev_j].index = tsbStopper;
 905                           currMin    = TopSizeArray[prev_j].len;
 906                           currMin_ix = prev_j;
 907                           //---&lt;  smallest entry gets overwritten  &gt;---
 908                           memcpy((void*)&amp;TopSizeArray[j], (void*)&amp;TopSizeArray[i], sizeof(TopSizeBlk));
 909                           TopSizeArray[i].start    = h;
 910                           TopSizeArray[i].len      = hb_len;
 911                           TopSizeArray[i].index    = j;
 912                           TopSizeArray[i].compiler = cType;
 913                           TopSizeArray[i].level    = comp_lvl;
 914                           TopSizeArray[i].type     = cbType;
 915                         }
 916                       } // insane
 917                     }
 918                     break;
 919                   }
 920                   prev_i = i;
 921                 }
 922                 if (insane) {
 923                   // Note: regular analysis could probably continue by resetting &quot;insane&quot; flag.
 924                   out-&gt;print_cr(&quot;Possible loop in TopSizeBlocks list detected. Analysis aborted.&quot;);
 925                   discard_TopSizeArray(out);
 926                 }
 927               }
 928             }
 929           }
 930           //----------------------------------------------
 931           //---&lt;  END register block in TopSizeArray  &gt;---
 932           //----------------------------------------------
 933         } else {
 934           nBlocks_zomb++;
 935         }
 936 
 937         if (ix_beg == ix_end) {
 938           StatArray[ix_beg].type = cbType;
 939           switch (cbType) {
 940             case nMethod_inuse:
 941               highest_compilation_id = (highest_compilation_id &gt;= compile_id) ? highest_compilation_id : compile_id;
 942               if (comp_lvl &lt; CompLevel_full_optimization) {
 943                 nBlocks_t1++;
 944                 t1Space   += hb_bytelen;
 945                 StatArray[ix_beg].t1_count++;
 946                 StatArray[ix_beg].t1_space += (unsigned short)hb_len;
 947                 StatArray[ix_beg].t1_age    = StatArray[ix_beg].t1_age &lt; compile_id ? compile_id : StatArray[ix_beg].t1_age;
 948               } else {
 949                 nBlocks_t2++;
 950                 t2Space   += hb_bytelen;
 951                 StatArray[ix_beg].t2_count++;
 952                 StatArray[ix_beg].t2_space += (unsigned short)hb_len;
 953                 StatArray[ix_beg].t2_age    = StatArray[ix_beg].t2_age &lt; compile_id ? compile_id : StatArray[ix_beg].t2_age;
 954               }
 955               StatArray[ix_beg].level     = comp_lvl;
 956               StatArray[ix_beg].compiler  = cType;
 957               break;
 958             case nMethod_inconstruction: // let&#39;s count &quot;in construction&quot; nmethods here.
 959             case nMethod_alive:
 960               StatArray[ix_beg].tx_count++;
 961               StatArray[ix_beg].tx_space += (unsigned short)hb_len;
 962               StatArray[ix_beg].tx_age    = StatArray[ix_beg].tx_age &lt; compile_id ? compile_id : StatArray[ix_beg].tx_age;
 963               StatArray[ix_beg].level     = comp_lvl;
 964               StatArray[ix_beg].compiler  = cType;
 965               break;
 966             case nMethod_dead:
 967             case nMethod_unloaded:
 968               StatArray[ix_beg].dead_count++;
 969               StatArray[ix_beg].dead_space += (unsigned short)hb_len;
 970               break;
 971             default:
 972               // must be a stub, if it&#39;s not a dead or alive nMethod
 973               nBlocks_stub++;
 974               stubSpace   += hb_bytelen;
 975               StatArray[ix_beg].stub_count++;
 976               StatArray[ix_beg].stub_space += (unsigned short)hb_len;
 977               break;
 978           }
 979         } else {
 980           unsigned int beg_space = (unsigned int)(granule_size - ((char*)h - low_bound - ix_beg*granule_size));
 981           unsigned int end_space = (unsigned int)(hb_bytelen - beg_space - (ix_end-ix_beg-1)*granule_size);
 982           beg_space = beg_space&gt;&gt;log2_seg_size;  // store in units of _segment_size
 983           end_space = end_space&gt;&gt;log2_seg_size;  // store in units of _segment_size
 984           StatArray[ix_beg].type = cbType;
 985           StatArray[ix_end].type = cbType;
 986           switch (cbType) {
 987             case nMethod_inuse:
 988               highest_compilation_id = (highest_compilation_id &gt;= compile_id) ? highest_compilation_id : compile_id;
 989               if (comp_lvl &lt; CompLevel_full_optimization) {
 990                 nBlocks_t1++;
 991                 t1Space   += hb_bytelen;
 992                 StatArray[ix_beg].t1_count++;
 993                 StatArray[ix_beg].t1_space += (unsigned short)beg_space;
 994                 StatArray[ix_beg].t1_age    = StatArray[ix_beg].t1_age &lt; compile_id ? compile_id : StatArray[ix_beg].t1_age;
 995 
 996                 StatArray[ix_end].t1_count++;
 997                 StatArray[ix_end].t1_space += (unsigned short)end_space;
 998                 StatArray[ix_end].t1_age    = StatArray[ix_end].t1_age &lt; compile_id ? compile_id : StatArray[ix_end].t1_age;
 999               } else {
1000                 nBlocks_t2++;
1001                 t2Space   += hb_bytelen;
1002                 StatArray[ix_beg].t2_count++;
1003                 StatArray[ix_beg].t2_space += (unsigned short)beg_space;
1004                 StatArray[ix_beg].t2_age    = StatArray[ix_beg].t2_age &lt; compile_id ? compile_id : StatArray[ix_beg].t2_age;
1005 
1006                 StatArray[ix_end].t2_count++;
1007                 StatArray[ix_end].t2_space += (unsigned short)end_space;
1008                 StatArray[ix_end].t2_age    = StatArray[ix_end].t2_age &lt; compile_id ? compile_id : StatArray[ix_end].t2_age;
1009               }
1010               StatArray[ix_beg].level     = comp_lvl;
1011               StatArray[ix_beg].compiler  = cType;
1012               StatArray[ix_end].level     = comp_lvl;
1013               StatArray[ix_end].compiler  = cType;
1014               break;
1015             case nMethod_inconstruction: // let&#39;s count &quot;in construction&quot; nmethods here.
1016             case nMethod_alive:
1017               StatArray[ix_beg].tx_count++;
1018               StatArray[ix_beg].tx_space += (unsigned short)beg_space;
1019               StatArray[ix_beg].tx_age    = StatArray[ix_beg].tx_age &lt; compile_id ? compile_id : StatArray[ix_beg].tx_age;
1020 
1021               StatArray[ix_end].tx_count++;
1022               StatArray[ix_end].tx_space += (unsigned short)end_space;
1023               StatArray[ix_end].tx_age    = StatArray[ix_end].tx_age &lt; compile_id ? compile_id : StatArray[ix_end].tx_age;
1024 
1025               StatArray[ix_beg].level     = comp_lvl;
1026               StatArray[ix_beg].compiler  = cType;
1027               StatArray[ix_end].level     = comp_lvl;
1028               StatArray[ix_end].compiler  = cType;
1029               break;
1030             case nMethod_dead:
1031             case nMethod_unloaded:
1032               StatArray[ix_beg].dead_count++;
1033               StatArray[ix_beg].dead_space += (unsigned short)beg_space;
1034               StatArray[ix_end].dead_count++;
1035               StatArray[ix_end].dead_space += (unsigned short)end_space;
1036               break;
1037             default:
1038               // must be a stub, if it&#39;s not a dead or alive nMethod
1039               nBlocks_stub++;
1040               stubSpace   += hb_bytelen;
1041               StatArray[ix_beg].stub_count++;
1042               StatArray[ix_beg].stub_space += (unsigned short)beg_space;
1043               StatArray[ix_end].stub_count++;
1044               StatArray[ix_end].stub_space += (unsigned short)end_space;
1045               break;
1046           }
1047           for (unsigned int ix = ix_beg+1; ix &lt; ix_end; ix++) {
1048             StatArray[ix].type = cbType;
1049             switch (cbType) {
1050               case nMethod_inuse:
1051                 if (comp_lvl &lt; CompLevel_full_optimization) {
1052                   StatArray[ix].t1_count++;
1053                   StatArray[ix].t1_space += (unsigned short)(granule_size&gt;&gt;log2_seg_size);
1054                   StatArray[ix].t1_age    = StatArray[ix].t1_age &lt; compile_id ? compile_id : StatArray[ix].t1_age;
1055                 } else {
1056                   StatArray[ix].t2_count++;
1057                   StatArray[ix].t2_space += (unsigned short)(granule_size&gt;&gt;log2_seg_size);
1058                   StatArray[ix].t2_age    = StatArray[ix].t2_age &lt; compile_id ? compile_id : StatArray[ix].t2_age;
1059                 }
1060                 StatArray[ix].level     = comp_lvl;
1061                 StatArray[ix].compiler  = cType;
1062                 break;
1063               case nMethod_inconstruction: // let&#39;s count &quot;in construction&quot; nmethods here.
1064               case nMethod_alive:
1065                 StatArray[ix].tx_count++;
1066                 StatArray[ix].tx_space += (unsigned short)(granule_size&gt;&gt;log2_seg_size);
1067                 StatArray[ix].tx_age    = StatArray[ix].tx_age &lt; compile_id ? compile_id : StatArray[ix].tx_age;
1068                 StatArray[ix].level     = comp_lvl;
1069                 StatArray[ix].compiler  = cType;
1070                 break;
1071               case nMethod_dead:
1072               case nMethod_unloaded:
1073                 StatArray[ix].dead_count++;
1074                 StatArray[ix].dead_space += (unsigned short)(granule_size&gt;&gt;log2_seg_size);
1075                 break;
1076               default:
1077                 // must be a stub, if it&#39;s not a dead or alive nMethod
1078                 StatArray[ix].stub_count++;
1079                 StatArray[ix].stub_space += (unsigned short)(granule_size&gt;&gt;log2_seg_size);
1080                 break;
1081             }
1082           }
1083         }
1084       }
1085     }
1086     done = true;
1087 
1088     if (!insane) {
1089       // There is a risk for this block (because it contains many print statements) to get
1090       // interspersed with print data from other threads. We take this risk intentionally.
1091       // Getting stalled waiting for tty_lock while holding the CodeCache_lock is not desirable.
1092       printBox(ast, &#39;-&#39;, &quot;Global CodeHeap statistics for segment &quot;, heapName);
1093       ast-&gt;print_cr(&quot;freeSpace        = &quot; SIZE_FORMAT_W(8) &quot;k, nBlocks_free     = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity&quot;, freeSpace/(size_t)K,     nBlocks_free,     (100.0*freeSpace)/size,     (100.0*freeSpace)/res_size);
1094       ast-&gt;print_cr(&quot;usedSpace        = &quot; SIZE_FORMAT_W(8) &quot;k, nBlocks_used     = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity&quot;, usedSpace/(size_t)K,     nBlocks_used,     (100.0*usedSpace)/size,     (100.0*usedSpace)/res_size);
1095       ast-&gt;print_cr(&quot;  Tier1 Space    = &quot; SIZE_FORMAT_W(8) &quot;k, nBlocks_t1       = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity&quot;, t1Space/(size_t)K,       nBlocks_t1,       (100.0*t1Space)/size,       (100.0*t1Space)/res_size);
1096       ast-&gt;print_cr(&quot;  Tier2 Space    = &quot; SIZE_FORMAT_W(8) &quot;k, nBlocks_t2       = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity&quot;, t2Space/(size_t)K,       nBlocks_t2,       (100.0*t2Space)/size,       (100.0*t2Space)/res_size);
1097       ast-&gt;print_cr(&quot;  Alive Space    = &quot; SIZE_FORMAT_W(8) &quot;k, nBlocks_alive    = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity&quot;, aliveSpace/(size_t)K,    nBlocks_alive,    (100.0*aliveSpace)/size,    (100.0*aliveSpace)/res_size);
1098       ast-&gt;print_cr(&quot;    disconnected = &quot; SIZE_FORMAT_W(8) &quot;k, nBlocks_disconn  = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity&quot;, disconnSpace/(size_t)K,  nBlocks_disconn,  (100.0*disconnSpace)/size,  (100.0*disconnSpace)/res_size);
1099       ast-&gt;print_cr(&quot;    not entrant  = &quot; SIZE_FORMAT_W(8) &quot;k, nBlocks_notentr  = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity&quot;, notentrSpace/(size_t)K,  nBlocks_notentr,  (100.0*notentrSpace)/size,  (100.0*notentrSpace)/res_size);
1100       ast-&gt;print_cr(&quot;  inconstrSpace  = &quot; SIZE_FORMAT_W(8) &quot;k, nBlocks_inconstr = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity&quot;, inconstrSpace/(size_t)K, nBlocks_inconstr, (100.0*inconstrSpace)/size, (100.0*inconstrSpace)/res_size);
1101       ast-&gt;print_cr(&quot;  unloadedSpace  = &quot; SIZE_FORMAT_W(8) &quot;k, nBlocks_unloaded = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity&quot;, unloadedSpace/(size_t)K, nBlocks_unloaded, (100.0*unloadedSpace)/size, (100.0*unloadedSpace)/res_size);
1102       ast-&gt;print_cr(&quot;  deadSpace      = &quot; SIZE_FORMAT_W(8) &quot;k, nBlocks_dead     = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity&quot;, deadSpace/(size_t)K,     nBlocks_dead,     (100.0*deadSpace)/size,     (100.0*deadSpace)/res_size);
1103       ast-&gt;print_cr(&quot;  stubSpace      = &quot; SIZE_FORMAT_W(8) &quot;k, nBlocks_stub     = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity&quot;, stubSpace/(size_t)K,     nBlocks_stub,     (100.0*stubSpace)/size,     (100.0*stubSpace)/res_size);
1104       ast-&gt;print_cr(&quot;ZombieBlocks     = %8d. These are HeapBlocks which could not be identified as CodeBlobs.&quot;, nBlocks_zomb);
1105       ast-&gt;cr();
1106       ast-&gt;print_cr(&quot;Segment start          = &quot; INTPTR_FORMAT &quot;, used space      = &quot; SIZE_FORMAT_W(8)&quot;k&quot;, p2i(low_bound), size/K);
1107       ast-&gt;print_cr(&quot;Segment end (used)     = &quot; INTPTR_FORMAT &quot;, remaining space = &quot; SIZE_FORMAT_W(8)&quot;k&quot;, p2i(low_bound) + size, (res_size - size)/K);
1108       ast-&gt;print_cr(&quot;Segment end (reserved) = &quot; INTPTR_FORMAT &quot;, reserved space  = &quot; SIZE_FORMAT_W(8)&quot;k&quot;, p2i(low_bound) + res_size, res_size/K);
1109       ast-&gt;cr();
1110       ast-&gt;print_cr(&quot;latest allocated compilation id = %d&quot;, latest_compilation_id);
1111       ast-&gt;print_cr(&quot;highest observed compilation id = %d&quot;, highest_compilation_id);
1112       ast-&gt;print_cr(&quot;Building TopSizeList iterations = %ld&quot;, total_iterations);
1113       ast-&gt;cr();
1114 
1115       int             reset_val = NMethodSweeper::hotness_counter_reset_val();
1116       double reverse_free_ratio = (res_size &gt; size) ? (double)res_size/(double)(res_size-size) : (double)res_size;
1117       printBox(ast, &#39;-&#39;, &quot;Method hotness information at time of this analysis&quot;, NULL);
1118       ast-&gt;print_cr(&quot;Highest possible method temperature:          %12d&quot;, reset_val);
1119       ast-&gt;print_cr(&quot;Threshold for method to be considered &#39;cold&#39;: %12.3f&quot;, -reset_val + reverse_free_ratio * NmethodSweepActivity);
1120       if (n_methods &gt; 0) {
1121         avgTemp = hotnessAccumulator/n_methods;
1122         ast-&gt;print_cr(&quot;min. hotness = %6d&quot;, minTemp);
1123         ast-&gt;print_cr(&quot;avg. hotness = %6d&quot;, avgTemp);
1124         ast-&gt;print_cr(&quot;max. hotness = %6d&quot;, maxTemp);
1125       } else {
1126         avgTemp = 0;
1127         ast-&gt;print_cr(&quot;No hotness data available&quot;);
1128       }
1129       BUFFEREDSTREAM_FLUSH(&quot;\n&quot;)
1130 
1131       // This loop is intentionally printing directly to &quot;out&quot;.
1132       // It should not print anything, anyway.
1133       out-&gt;print(&quot;Verifying collected data...&quot;);
1134       size_t granule_segs = granule_size&gt;&gt;log2_seg_size;
1135       for (unsigned int ix = 0; ix &lt; granules; ix++) {
1136         if (StatArray[ix].t1_count   &gt; granule_segs) {
1137           out-&gt;print_cr(&quot;t1_count[%d]   = %d&quot;, ix, StatArray[ix].t1_count);
1138         }
1139         if (StatArray[ix].t2_count   &gt; granule_segs) {
1140           out-&gt;print_cr(&quot;t2_count[%d]   = %d&quot;, ix, StatArray[ix].t2_count);
1141         }
1142         if (StatArray[ix].tx_count   &gt; granule_segs) {
1143           out-&gt;print_cr(&quot;tx_count[%d]   = %d&quot;, ix, StatArray[ix].tx_count);
1144         }
1145         if (StatArray[ix].stub_count &gt; granule_segs) {
1146           out-&gt;print_cr(&quot;stub_count[%d] = %d&quot;, ix, StatArray[ix].stub_count);
1147         }
1148         if (StatArray[ix].dead_count &gt; granule_segs) {
1149           out-&gt;print_cr(&quot;dead_count[%d] = %d&quot;, ix, StatArray[ix].dead_count);
1150         }
1151         if (StatArray[ix].t1_space   &gt; granule_segs) {
1152           out-&gt;print_cr(&quot;t1_space[%d]   = %d&quot;, ix, StatArray[ix].t1_space);
1153         }
1154         if (StatArray[ix].t2_space   &gt; granule_segs) {
1155           out-&gt;print_cr(&quot;t2_space[%d]   = %d&quot;, ix, StatArray[ix].t2_space);
1156         }
1157         if (StatArray[ix].tx_space   &gt; granule_segs) {
1158           out-&gt;print_cr(&quot;tx_space[%d]   = %d&quot;, ix, StatArray[ix].tx_space);
1159         }
1160         if (StatArray[ix].stub_space &gt; granule_segs) {
1161           out-&gt;print_cr(&quot;stub_space[%d] = %d&quot;, ix, StatArray[ix].stub_space);
1162         }
1163         if (StatArray[ix].dead_space &gt; granule_segs) {
1164           out-&gt;print_cr(&quot;dead_space[%d] = %d&quot;, ix, StatArray[ix].dead_space);
1165         }
1166         //   this cast is awful! I need it because NT/Intel reports a signed/unsigned mismatch.
1167         if ((size_t)(StatArray[ix].t1_count+StatArray[ix].t2_count+StatArray[ix].tx_count+StatArray[ix].stub_count+StatArray[ix].dead_count) &gt; granule_segs) {
1168           out-&gt;print_cr(&quot;t1_count[%d] = %d, t2_count[%d] = %d, tx_count[%d] = %d, stub_count[%d] = %d&quot;, ix, StatArray[ix].t1_count, ix, StatArray[ix].t2_count, ix, StatArray[ix].tx_count, ix, StatArray[ix].stub_count);
1169         }
1170         if ((size_t)(StatArray[ix].t1_space+StatArray[ix].t2_space+StatArray[ix].tx_space+StatArray[ix].stub_space+StatArray[ix].dead_space) &gt; granule_segs) {
1171           out-&gt;print_cr(&quot;t1_space[%d] = %d, t2_space[%d] = %d, tx_space[%d] = %d, stub_space[%d] = %d&quot;, ix, StatArray[ix].t1_space, ix, StatArray[ix].t2_space, ix, StatArray[ix].tx_space, ix, StatArray[ix].stub_space);
1172         }
1173       }
1174 
1175       // This loop is intentionally printing directly to &quot;out&quot;.
1176       // It should not print anything, anyway.
1177       if (used_topSizeBlocks &gt; 0) {
1178         unsigned int j = 0;
1179         if (TopSizeArray[0].len != currMax) {
1180           out-&gt;print_cr(&quot;currMax(%d) differs from TopSizeArray[0].len(%d)&quot;, currMax, TopSizeArray[0].len);
1181         }
1182         for (unsigned int i = 0; (TopSizeArray[i].index != tsbStopper) &amp;&amp; (j++ &lt; alloc_topSizeBlocks); i = TopSizeArray[i].index) {
1183           if (TopSizeArray[i].len &lt; TopSizeArray[TopSizeArray[i].index].len) {
1184             out-&gt;print_cr(&quot;sort error at index %d: %d !&gt;= %d&quot;, i, TopSizeArray[i].len, TopSizeArray[TopSizeArray[i].index].len);
1185           }
1186         }
1187         if (j &gt;= alloc_topSizeBlocks) {
1188           out-&gt;print_cr(&quot;Possible loop in TopSizeArray chaining!\n  allocBlocks = %d, usedBlocks = %d&quot;, alloc_topSizeBlocks, used_topSizeBlocks);
1189           for (unsigned int i = 0; i &lt; alloc_topSizeBlocks; i++) {
1190             out-&gt;print_cr(&quot;  TopSizeArray[%d].index = %d, len = %d&quot;, i, TopSizeArray[i].index, TopSizeArray[i].len);
1191           }
1192         }
1193       }
1194       out-&gt;print_cr(&quot;...done\n\n&quot;);
1195     } else {
1196       // insane heap state detected. Analysis data incomplete. Just throw it away.
1197       discard_StatArray(out);
1198       discard_TopSizeArray(out);
1199     }
1200   }
1201 
1202 
1203   done        = false;
1204   while (!done &amp;&amp; (nBlocks_free &gt; 0)) {
1205 
1206     printBox(ast, &#39;=&#39;, &quot;C O D E   H E A P   A N A L Y S I S   (free blocks) for segment &quot;, heapName);
1207     ast-&gt;print_cr(&quot;   The aggregate step collects information about all free blocks in CodeHeap.\n&quot;
1208                   &quot;   Subsequent print functions create their output based on this snapshot.\n&quot;);
1209     ast-&gt;print_cr(&quot;   Free space in %s is distributed over %d free blocks.&quot;, heapName, nBlocks_free);
1210     ast-&gt;print_cr(&quot;   Each free block takes &quot; SIZE_FORMAT &quot; bytes of C heap for statistics data, that is &quot; SIZE_FORMAT &quot;K in total.&quot;, sizeof(FreeBlk), (sizeof(FreeBlk)*nBlocks_free)/K);
1211     BUFFEREDSTREAM_FLUSH(&quot;\n&quot;)
1212 
1213     //----------------------------------------
1214     //--  Prepare the FreeArray of FreeBlks --
1215     //----------------------------------------
1216 
1217     //---&lt; discard old array if size does not match  &gt;---
1218     if (nBlocks_free != alloc_freeBlocks) {
1219       discard_FreeArray(out);
1220     }
1221 
1222     prepare_FreeArray(out, nBlocks_free, heapName);
1223     if (FreeArray == NULL) {
1224       done = true;
1225       continue;
1226     }
1227 
1228     //----------------------------------------
1229     //--  Collect all FreeBlks in FreeArray --
1230     //----------------------------------------
1231 
1232     unsigned int ix = 0;
1233     FreeBlock* cur  = heap-&gt;freelist();
1234 
1235     while (cur != NULL) {
1236       if (ix &lt; alloc_freeBlocks) { // don&#39;t index out of bounds if _freelist has more blocks than anticipated
1237         FreeArray[ix].start = cur;
1238         FreeArray[ix].len   = (unsigned int)(cur-&gt;length()&lt;&lt;log2_seg_size);
1239         FreeArray[ix].index = ix;
1240       }
1241       cur  = cur-&gt;link();
1242       ix++;
1243     }
1244     if (ix != alloc_freeBlocks) {
1245       ast-&gt;print_cr(&quot;Free block count mismatch. Expected %d free blocks, but found %d.&quot;, alloc_freeBlocks, ix);
1246       ast-&gt;print_cr(&quot;I will update the counter and retry data collection&quot;);
1247       BUFFEREDSTREAM_FLUSH(&quot;\n&quot;)
1248       nBlocks_free = ix;
1249       continue;
1250     }
1251     done = true;
1252   }
1253 
1254   if (!done || (nBlocks_free == 0)) {
1255     if (nBlocks_free == 0) {
1256       printBox(ast, &#39;-&#39;, &quot;no free blocks found in &quot;, heapName);
1257     } else if (!done) {
1258       ast-&gt;print_cr(&quot;Free block count mismatch could not be resolved.&quot;);
1259       ast-&gt;print_cr(&quot;Try to run \&quot;aggregate\&quot; function to update counters&quot;);
1260     }
1261     BUFFEREDSTREAM_FLUSH(&quot;&quot;)
1262 
1263     //---&lt; discard old array and update global values  &gt;---
1264     discard_FreeArray(out);
1265     set_HeapStatGlobals(out, heapName);
1266     return;
1267   }
1268 
1269   //---&lt;  calculate and fill remaining fields  &gt;---
1270   if (FreeArray != NULL) {
1271     // This loop is intentionally printing directly to &quot;out&quot;.
1272     // It should not print anything, anyway.
1273     for (unsigned int ix = 0; ix &lt; alloc_freeBlocks-1; ix++) {
1274       size_t lenSum = 0;
1275       FreeArray[ix].gap = (unsigned int)((address)FreeArray[ix+1].start - ((address)FreeArray[ix].start + FreeArray[ix].len));
1276       for (HeapBlock *h = heap-&gt;next_block(FreeArray[ix].start); (h != NULL) &amp;&amp; (h != FreeArray[ix+1].start); h = heap-&gt;next_block(h)) {
1277         CodeBlob *cb  = (CodeBlob*)(heap-&gt;find_start(h));
1278         if ((cb != NULL) &amp;&amp; !cb-&gt;is_nmethod()) {
1279           FreeArray[ix].stubs_in_gap = true;
1280         }
1281         FreeArray[ix].n_gapBlocks++;
1282         lenSum += h-&gt;length()&lt;&lt;log2_seg_size;
1283         if (((address)h &lt; ((address)FreeArray[ix].start+FreeArray[ix].len)) || (h &gt;= FreeArray[ix+1].start)) {
1284           out-&gt;print_cr(&quot;unsorted occupied CodeHeap block found @ %p, gap interval [%p, %p)&quot;, h, (address)FreeArray[ix].start+FreeArray[ix].len, FreeArray[ix+1].start);
1285         }
1286       }
1287       if (lenSum != FreeArray[ix].gap) {
1288         out-&gt;print_cr(&quot;Length mismatch for gap between FreeBlk[%d] and FreeBlk[%d]. Calculated: %d, accumulated: %d.&quot;, ix, ix+1, FreeArray[ix].gap, (unsigned int)lenSum);
1289       }
1290     }
1291   }
1292   set_HeapStatGlobals(out, heapName);
1293 
1294   printBox(ast, &#39;=&#39;, &quot;C O D E   H E A P   A N A L Y S I S   C O M P L E T E   for segment &quot;, heapName);
1295   BUFFEREDSTREAM_FLUSH(&quot;\n&quot;)
1296 }
1297 
1298 
1299 void CodeHeapState::print_usedSpace(outputStream* out, CodeHeap* heap) {
1300   if (!initialization_complete) {
1301     return;
1302   }
1303 
1304   const char* heapName   = get_heapName(heap);
1305   get_HeapStatGlobals(out, heapName);
1306 
1307   if ((StatArray == NULL) || (TopSizeArray == NULL) || (used_topSizeBlocks == 0)) {
1308     return;
1309   }
1310   BUFFEREDSTREAM_DECL(ast, out)
1311 
1312   {
1313     printBox(ast, &#39;=&#39;, &quot;U S E D   S P A C E   S T A T I S T I C S   for &quot;, heapName);
1314     ast-&gt;print_cr(&quot;Note: The Top%d list of the largest used blocks associates method names\n&quot;
1315                   &quot;      and other identifying information with the block size data.\n&quot;
1316                   &quot;\n&quot;
1317                   &quot;      Method names are dynamically retrieved from the code cache at print time.\n&quot;
1318                   &quot;      Due to the living nature of the code cache and because the CodeCache_lock\n&quot;
1319                   &quot;      is not continuously held, the displayed name might be wrong or no name\n&quot;
1320                   &quot;      might be found at all. The likelihood for that to happen increases\n&quot;
1321                   &quot;      over time passed between analysis and print step.\n&quot;, used_topSizeBlocks);
1322     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n&quot;)
1323   }
1324 
1325   //----------------------------
1326   //--  Print Top Used Blocks --
1327   //----------------------------
1328   {
1329     char*     low_bound = heap-&gt;low_boundary();
1330     bool      have_CodeCache_lock = CodeCache_lock-&gt;owned_by_self();
1331 
1332     printBox(ast, &#39;-&#39;, &quot;Largest Used Blocks in &quot;, heapName);
1333     print_blobType_legend(ast);
1334 
1335     ast-&gt;fill_to(51);
1336     ast-&gt;print(&quot;%4s&quot;, &quot;blob&quot;);
1337     ast-&gt;fill_to(56);
1338     ast-&gt;print(&quot;%9s&quot;, &quot;compiler&quot;);
1339     ast-&gt;fill_to(66);
1340     ast-&gt;print_cr(&quot;%6s&quot;, &quot;method&quot;);
1341     ast-&gt;print_cr(&quot;%18s %13s %17s %4s %9s  %5s %s&quot;,      &quot;Addr(module)      &quot;, &quot;offset&quot;, &quot;size&quot;, &quot;type&quot;, &quot; type lvl&quot;, &quot; temp&quot;, &quot;Name&quot;);
1342     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;&quot;)
1343 
1344     //---&lt;  print Top Ten Used Blocks  &gt;---
1345     if (used_topSizeBlocks &gt; 0) {
1346       unsigned int printed_topSizeBlocks = 0;
1347       for (unsigned int i = 0; i != tsbStopper; i = TopSizeArray[i].index) {
1348         printed_topSizeBlocks++;
1349         nmethod*           nm = NULL;
1350         const char* blob_name = &quot;unnamed blob or blob name unavailable&quot;;
1351         // heap-&gt;find_start() is safe. Only works on _segmap.
1352         // Returns NULL or void*. Returned CodeBlob may be uninitialized.
1353         HeapBlock* heapBlock = TopSizeArray[i].start;
1354         CodeBlob*  this_blob = (CodeBlob*)(heap-&gt;find_start(heapBlock));
1355         bool    blob_is_safe = blob_access_is_safe(this_blob, NULL);
1356         if (blob_is_safe) {
1357           //---&lt;  access these fields only if we own the CodeCache_lock  &gt;---
1358           if (have_CodeCache_lock) {
1359             blob_name = this_blob-&gt;name();
1360             nm        = this_blob-&gt;as_nmethod_or_null();
1361           }
1362           //---&lt;  blob address  &gt;---
1363           ast-&gt;print(INTPTR_FORMAT, p2i(this_blob));
1364           ast-&gt;fill_to(19);
1365           //---&lt;  blob offset from CodeHeap begin  &gt;---
1366           ast-&gt;print(&quot;(+&quot; PTR32_FORMAT &quot;)&quot;, (unsigned int)((char*)this_blob-low_bound));
1367           ast-&gt;fill_to(33);
1368         } else {
1369           //---&lt;  block address  &gt;---
1370           ast-&gt;print(INTPTR_FORMAT, p2i(TopSizeArray[i].start));
1371           ast-&gt;fill_to(19);
1372           //---&lt;  block offset from CodeHeap begin  &gt;---
1373           ast-&gt;print(&quot;(+&quot; PTR32_FORMAT &quot;)&quot;, (unsigned int)((char*)TopSizeArray[i].start-low_bound));
1374           ast-&gt;fill_to(33);
1375         }
1376 
1377         //---&lt;  print size, name, and signature (for nMethods)  &gt;---
1378         // access nmethod and Method fields only if we own the CodeCache_lock.
1379         // This fact is implicitly transported via nm != NULL.
1380         if (CompiledMethod::nmethod_access_is_safe(nm)) {
1381           ResourceMark rm;
1382           Method* method = nm-&gt;method();
1383           if (nm-&gt;is_in_use()) {
1384             blob_name = method-&gt;name_and_sig_as_C_string();
1385           }
1386           if (nm-&gt;is_not_entrant()) {
1387             blob_name = method-&gt;name_and_sig_as_C_string();
1388           }
1389           //---&lt;  nMethod size in hex  &gt;---
1390           unsigned int total_size = nm-&gt;total_size();
1391           ast-&gt;print(PTR32_FORMAT, total_size);
1392           ast-&gt;print(&quot;(&quot; SIZE_FORMAT_W(4) &quot;K)&quot;, total_size/K);
1393           ast-&gt;fill_to(51);
1394           ast-&gt;print(&quot;  %c&quot;, blobTypeChar[TopSizeArray[i].type]);
1395           //---&lt;  compiler information  &gt;---
1396           ast-&gt;fill_to(56);
1397           ast-&gt;print(&quot;%5s %3d&quot;, compTypeName[TopSizeArray[i].compiler], TopSizeArray[i].level);
1398           //---&lt;  method temperature  &gt;---
1399           ast-&gt;fill_to(67);
1400           ast-&gt;print(&quot;%5d&quot;, nm-&gt;hotness_counter());
1401           //---&lt;  name and signature  &gt;---
1402           ast-&gt;fill_to(67+6);
1403           if (nm-&gt;is_not_installed()) {
1404             ast-&gt;print(&quot; not (yet) installed method &quot;);
1405           }
1406           if (nm-&gt;is_zombie()) {
1407             ast-&gt;print(&quot; zombie method &quot;);
1408           }
1409           ast-&gt;print(&quot;%s&quot;, blob_name);
1410         } else {
1411           //---&lt;  block size in hex  &gt;---
1412           ast-&gt;print(PTR32_FORMAT, (unsigned int)(TopSizeArray[i].len&lt;&lt;log2_seg_size));
1413           ast-&gt;print(&quot;(&quot; SIZE_FORMAT_W(4) &quot;K)&quot;, (TopSizeArray[i].len&lt;&lt;log2_seg_size)/K);
1414           //---&lt;  no compiler information  &gt;---
1415           ast-&gt;fill_to(56);
1416           //---&lt;  name and signature  &gt;---
1417           ast-&gt;fill_to(67+6);
1418           ast-&gt;print(&quot;%s&quot;, blob_name);
1419         }
1420         ast-&gt;cr();
1421         BUFFEREDSTREAM_FLUSH_AUTO(&quot;&quot;)
1422       }
1423       if (used_topSizeBlocks != printed_topSizeBlocks) {
1424         ast-&gt;print_cr(&quot;used blocks: %d, printed blocks: %d&quot;, used_topSizeBlocks, printed_topSizeBlocks);
1425         for (unsigned int i = 0; i &lt; alloc_topSizeBlocks; i++) {
1426           ast-&gt;print_cr(&quot;  TopSizeArray[%d].index = %d, len = %d&quot;, i, TopSizeArray[i].index, TopSizeArray[i].len);
1427           BUFFEREDSTREAM_FLUSH_AUTO(&quot;&quot;)
1428         }
1429       }
1430       BUFFEREDSTREAM_FLUSH(&quot;\n\n&quot;)
1431     }
1432   }
1433 
1434   //-----------------------------
1435   //--  Print Usage Histogram  --
1436   //-----------------------------
1437 
1438   if (SizeDistributionArray != NULL) {
1439     unsigned long total_count = 0;
1440     unsigned long total_size  = 0;
1441     const unsigned long pctFactor = 200;
1442 
1443     for (unsigned int i = 0; i &lt; nSizeDistElements; i++) {
1444       total_count += SizeDistributionArray[i].count;
1445       total_size  += SizeDistributionArray[i].lenSum;
1446     }
1447 
1448     if ((total_count &gt; 0) &amp;&amp; (total_size &gt; 0)) {
1449       printBox(ast, &#39;-&#39;, &quot;Block count histogram for &quot;, heapName);
1450       ast-&gt;print_cr(&quot;Note: The histogram indicates how many blocks (as a percentage\n&quot;
1451                     &quot;      of all blocks) have a size in the given range.\n&quot;
1452                     &quot;      %ld characters are printed per percentage point.\n&quot;, pctFactor/100);
1453       ast-&gt;print_cr(&quot;total size   of all blocks: %7ldM&quot;, (total_size&lt;&lt;log2_seg_size)/M);
1454       ast-&gt;print_cr(&quot;total number of all blocks: %7ld\n&quot;, total_count);
1455       BUFFEREDSTREAM_FLUSH_LOCKED(&quot;&quot;)
1456 
1457       ast-&gt;print_cr(&quot;[Size Range)------avg.-size-+----count-+&quot;);
1458       for (unsigned int i = 0; i &lt; nSizeDistElements; i++) {
1459         if (SizeDistributionArray[i].rangeStart&lt;&lt;log2_seg_size &lt; K) {
1460           ast-&gt;print(&quot;[&quot; SIZE_FORMAT_W(5) &quot; ..&quot; SIZE_FORMAT_W(5) &quot; ): &quot;
1461                     ,(size_t)(SizeDistributionArray[i].rangeStart&lt;&lt;log2_seg_size)
1462                     ,(size_t)(SizeDistributionArray[i].rangeEnd&lt;&lt;log2_seg_size)
1463                     );
1464         } else if (SizeDistributionArray[i].rangeStart&lt;&lt;log2_seg_size &lt; M) {
1465           ast-&gt;print(&quot;[&quot; SIZE_FORMAT_W(5) &quot;K..&quot; SIZE_FORMAT_W(5) &quot;K): &quot;
1466                     ,(SizeDistributionArray[i].rangeStart&lt;&lt;log2_seg_size)/K
1467                     ,(SizeDistributionArray[i].rangeEnd&lt;&lt;log2_seg_size)/K
1468                     );
1469         } else {
1470           ast-&gt;print(&quot;[&quot; SIZE_FORMAT_W(5) &quot;M..&quot; SIZE_FORMAT_W(5) &quot;M): &quot;
1471                     ,(SizeDistributionArray[i].rangeStart&lt;&lt;log2_seg_size)/M
1472                     ,(SizeDistributionArray[i].rangeEnd&lt;&lt;log2_seg_size)/M
1473                     );
1474         }
1475         ast-&gt;print(&quot; %8d | %8d |&quot;,
1476                    SizeDistributionArray[i].count &gt; 0 ? (SizeDistributionArray[i].lenSum&lt;&lt;log2_seg_size)/SizeDistributionArray[i].count : 0,
1477                    SizeDistributionArray[i].count);
1478 
1479         unsigned int percent = pctFactor*SizeDistributionArray[i].count/total_count;
1480         for (unsigned int j = 1; j &lt;= percent; j++) {
1481           ast-&gt;print(&quot;%c&quot;, (j%((pctFactor/100)*10) == 0) ? (&#39;0&#39;+j/(((unsigned int)pctFactor/100)*10)) : &#39;*&#39;);
1482         }
1483         ast-&gt;cr();
1484         BUFFEREDSTREAM_FLUSH_AUTO(&quot;&quot;)
1485       }
1486       ast-&gt;print_cr(&quot;----------------------------+----------+&quot;);
1487       BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
1488 
1489       printBox(ast, &#39;-&#39;, &quot;Contribution per size range to total size for &quot;, heapName);
1490       ast-&gt;print_cr(&quot;Note: The histogram indicates how much space (as a percentage of all\n&quot;
1491                     &quot;      occupied space) is used by the blocks in the given size range.\n&quot;
1492                     &quot;      %ld characters are printed per percentage point.\n&quot;, pctFactor/100);
1493       ast-&gt;print_cr(&quot;total size   of all blocks: %7ldM&quot;, (total_size&lt;&lt;log2_seg_size)/M);
1494       ast-&gt;print_cr(&quot;total number of all blocks: %7ld\n&quot;, total_count);
1495       BUFFEREDSTREAM_FLUSH_LOCKED(&quot;&quot;)
1496 
1497       ast-&gt;print_cr(&quot;[Size Range)------avg.-size-+----count-+&quot;);
1498       for (unsigned int i = 0; i &lt; nSizeDistElements; i++) {
1499         if (SizeDistributionArray[i].rangeStart&lt;&lt;log2_seg_size &lt; K) {
1500           ast-&gt;print(&quot;[&quot; SIZE_FORMAT_W(5) &quot; ..&quot; SIZE_FORMAT_W(5) &quot; ): &quot;
1501                     ,(size_t)(SizeDistributionArray[i].rangeStart&lt;&lt;log2_seg_size)
1502                     ,(size_t)(SizeDistributionArray[i].rangeEnd&lt;&lt;log2_seg_size)
1503                     );
1504         } else if (SizeDistributionArray[i].rangeStart&lt;&lt;log2_seg_size &lt; M) {
1505           ast-&gt;print(&quot;[&quot; SIZE_FORMAT_W(5) &quot;K..&quot; SIZE_FORMAT_W(5) &quot;K): &quot;
1506                     ,(SizeDistributionArray[i].rangeStart&lt;&lt;log2_seg_size)/K
1507                     ,(SizeDistributionArray[i].rangeEnd&lt;&lt;log2_seg_size)/K
1508                     );
1509         } else {
1510           ast-&gt;print(&quot;[&quot; SIZE_FORMAT_W(5) &quot;M..&quot; SIZE_FORMAT_W(5) &quot;M): &quot;
1511                     ,(SizeDistributionArray[i].rangeStart&lt;&lt;log2_seg_size)/M
1512                     ,(SizeDistributionArray[i].rangeEnd&lt;&lt;log2_seg_size)/M
1513                     );
1514         }
1515         ast-&gt;print(&quot; %8d | %8d |&quot;,
1516                    SizeDistributionArray[i].count &gt; 0 ? (SizeDistributionArray[i].lenSum&lt;&lt;log2_seg_size)/SizeDistributionArray[i].count : 0,
1517                    SizeDistributionArray[i].count);
1518 
1519         unsigned int percent = pctFactor*(unsigned long)SizeDistributionArray[i].lenSum/total_size;
1520         for (unsigned int j = 1; j &lt;= percent; j++) {
1521           ast-&gt;print(&quot;%c&quot;, (j%((pctFactor/100)*10) == 0) ? (&#39;0&#39;+j/(((unsigned int)pctFactor/100)*10)) : &#39;*&#39;);
1522         }
1523         ast-&gt;cr();
1524         BUFFEREDSTREAM_FLUSH_AUTO(&quot;&quot;)
1525       }
1526       ast-&gt;print_cr(&quot;----------------------------+----------+&quot;);
1527       BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
1528     }
1529   }
1530 }
1531 
1532 
1533 void CodeHeapState::print_freeSpace(outputStream* out, CodeHeap* heap) {
1534   if (!initialization_complete) {
1535     return;
1536   }
1537 
1538   const char* heapName   = get_heapName(heap);
1539   get_HeapStatGlobals(out, heapName);
1540 
1541   if ((StatArray == NULL) || (FreeArray == NULL) || (alloc_granules == 0)) {
1542     return;
1543   }
1544   BUFFEREDSTREAM_DECL(ast, out)
1545 
1546   {
1547     printBox(ast, &#39;=&#39;, &quot;F R E E   S P A C E   S T A T I S T I C S   for &quot;, heapName);
1548     ast-&gt;print_cr(&quot;Note: in this context, a gap is the occupied space between two free blocks.\n&quot;
1549                   &quot;      Those gaps are of interest if there is a chance that they become\n&quot;
1550                   &quot;      unoccupied, e.g. by class unloading. Then, the two adjacent free\n&quot;
1551                   &quot;      blocks, together with the now unoccupied space, form a new, large\n&quot;
1552                   &quot;      free block.&quot;);
1553     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n&quot;)
1554   }
1555 
1556   {
1557     printBox(ast, &#39;-&#39;, &quot;List of all Free Blocks in &quot;, heapName);
1558 
1559     unsigned int ix = 0;
1560     for (ix = 0; ix &lt; alloc_freeBlocks-1; ix++) {
1561       ast-&gt;print(INTPTR_FORMAT &quot;: Len[%4d] = &quot; HEX32_FORMAT &quot;,&quot;, p2i(FreeArray[ix].start), ix, FreeArray[ix].len);
1562       ast-&gt;fill_to(38);
1563       ast-&gt;print(&quot;Gap[%4d..%4d]: &quot; HEX32_FORMAT &quot; bytes,&quot;, ix, ix+1, FreeArray[ix].gap);
1564       ast-&gt;fill_to(71);
1565       ast-&gt;print(&quot;block count: %6d&quot;, FreeArray[ix].n_gapBlocks);
1566       if (FreeArray[ix].stubs_in_gap) {
1567         ast-&gt;print(&quot; !! permanent gap, contains stubs and/or blobs !!&quot;);
1568       }
1569       ast-&gt;cr();
1570       BUFFEREDSTREAM_FLUSH_AUTO(&quot;&quot;)
1571     }
1572     ast-&gt;print_cr(INTPTR_FORMAT &quot;: Len[%4d] = &quot; HEX32_FORMAT, p2i(FreeArray[ix].start), ix, FreeArray[ix].len);
1573     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n&quot;)
1574   }
1575 
1576 
1577   //-----------------------------------------
1578   //--  Find and Print Top Ten Free Blocks --
1579   //-----------------------------------------
1580 
1581   //---&lt;  find Top Ten Free Blocks  &gt;---
1582   const unsigned int nTop = 10;
1583   unsigned int  currMax10 = 0;
1584   struct FreeBlk* FreeTopTen[nTop];
1585   memset(FreeTopTen, 0, sizeof(FreeTopTen));
1586 
1587   for (unsigned int ix = 0; ix &lt; alloc_freeBlocks; ix++) {
1588     if (FreeArray[ix].len &gt; currMax10) {  // larger than the ten largest found so far
1589       unsigned int currSize = FreeArray[ix].len;
1590 
1591       unsigned int iy;
1592       for (iy = 0; iy &lt; nTop &amp;&amp; FreeTopTen[iy] != NULL; iy++) {
1593         if (FreeTopTen[iy]-&gt;len &lt; currSize) {
1594           for (unsigned int iz = nTop-1; iz &gt; iy; iz--) { // make room to insert new free block
1595             FreeTopTen[iz] = FreeTopTen[iz-1];
1596           }
1597           FreeTopTen[iy] = &amp;FreeArray[ix];        // insert new free block
1598           if (FreeTopTen[nTop-1] != NULL) {
1599             currMax10 = FreeTopTen[nTop-1]-&gt;len;
1600           }
1601           break; // done with this, check next free block
1602         }
1603       }
1604       if (iy &gt;= nTop) {
1605         ast-&gt;print_cr(&quot;Internal logic error. New Max10 = %d detected, but could not be merged. Old Max10 = %d&quot;,
1606                       currSize, currMax10);
1607         continue;
1608       }
1609       if (FreeTopTen[iy] == NULL) {
1610         FreeTopTen[iy] = &amp;FreeArray[ix];
1611         if (iy == (nTop-1)) {
1612           currMax10 = currSize;
1613         }
1614       }
1615     }
1616   }
1617   BUFFEREDSTREAM_FLUSH_AUTO(&quot;&quot;)
1618 
1619   {
1620     printBox(ast, &#39;-&#39;, &quot;Top Ten Free Blocks in &quot;, heapName);
1621 
1622     //---&lt;  print Top Ten Free Blocks  &gt;---
1623     for (unsigned int iy = 0; (iy &lt; nTop) &amp;&amp; (FreeTopTen[iy] != NULL); iy++) {
1624       ast-&gt;print(&quot;Pos %3d: Block %4d - size &quot; HEX32_FORMAT &quot;,&quot;, iy+1, FreeTopTen[iy]-&gt;index, FreeTopTen[iy]-&gt;len);
1625       ast-&gt;fill_to(39);
1626       if (FreeTopTen[iy]-&gt;index == (alloc_freeBlocks-1)) {
1627         ast-&gt;print(&quot;last free block in list.&quot;);
1628       } else {
1629         ast-&gt;print(&quot;Gap (to next) &quot; HEX32_FORMAT &quot;,&quot;, FreeTopTen[iy]-&gt;gap);
1630         ast-&gt;fill_to(63);
1631         ast-&gt;print(&quot;#blocks (in gap) %d&quot;, FreeTopTen[iy]-&gt;n_gapBlocks);
1632       }
1633       ast-&gt;cr();
1634       BUFFEREDSTREAM_FLUSH_AUTO(&quot;&quot;)
1635     }
1636   }
1637   BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n&quot;)
1638 
1639 
1640   //--------------------------------------------------------
1641   //--  Find and Print Top Ten Free-Occupied-Free Triples --
1642   //--------------------------------------------------------
1643 
1644   //---&lt;  find and print Top Ten Triples (Free-Occupied-Free)  &gt;---
1645   currMax10 = 0;
1646   struct FreeBlk  *FreeTopTenTriple[nTop];
1647   memset(FreeTopTenTriple, 0, sizeof(FreeTopTenTriple));
1648 
1649   for (unsigned int ix = 0; ix &lt; alloc_freeBlocks-1; ix++) {
1650     // If there are stubs in the gap, this gap will never become completely free.
1651     // The triple will thus never merge to one free block.
1652     unsigned int lenTriple  = FreeArray[ix].len + (FreeArray[ix].stubs_in_gap ? 0 : FreeArray[ix].gap + FreeArray[ix+1].len);
1653     FreeArray[ix].len = lenTriple;
1654     if (lenTriple &gt; currMax10) {  // larger than the ten largest found so far
1655 
1656       unsigned int iy;
1657       for (iy = 0; (iy &lt; nTop) &amp;&amp; (FreeTopTenTriple[iy] != NULL); iy++) {
1658         if (FreeTopTenTriple[iy]-&gt;len &lt; lenTriple) {
1659           for (unsigned int iz = nTop-1; iz &gt; iy; iz--) {
1660             FreeTopTenTriple[iz] = FreeTopTenTriple[iz-1];
1661           }
1662           FreeTopTenTriple[iy] = &amp;FreeArray[ix];
1663           if (FreeTopTenTriple[nTop-1] != NULL) {
1664             currMax10 = FreeTopTenTriple[nTop-1]-&gt;len;
1665           }
1666           break;
1667         }
1668       }
1669       if (iy == nTop) {
1670         ast-&gt;print_cr(&quot;Internal logic error. New Max10 = %d detected, but could not be merged. Old Max10 = %d&quot;,
1671                       lenTriple, currMax10);
1672         continue;
1673       }
1674       if (FreeTopTenTriple[iy] == NULL) {
1675         FreeTopTenTriple[iy] = &amp;FreeArray[ix];
1676         if (iy == (nTop-1)) {
1677           currMax10 = lenTriple;
1678         }
1679       }
1680     }
1681   }
1682   BUFFEREDSTREAM_FLUSH_AUTO(&quot;&quot;)
1683 
1684   {
1685     printBox(ast, &#39;-&#39;, &quot;Top Ten Free-Occupied-Free Triples in &quot;, heapName);
1686     ast-&gt;print_cr(&quot;  Use this information to judge how likely it is that a large(r) free block\n&quot;
1687                   &quot;  might get created by code cache sweeping.\n&quot;
1688                   &quot;  If all the occupied blocks can be swept, the three free blocks will be\n&quot;
1689                   &quot;  merged into one (much larger) free block. That would reduce free space\n&quot;
1690                   &quot;  fragmentation.\n&quot;);
1691 
1692     //---&lt;  print Top Ten Free-Occupied-Free Triples  &gt;---
1693     for (unsigned int iy = 0; (iy &lt; nTop) &amp;&amp; (FreeTopTenTriple[iy] != NULL); iy++) {
1694       ast-&gt;print(&quot;Pos %3d: Block %4d - size &quot; HEX32_FORMAT &quot;,&quot;, iy+1, FreeTopTenTriple[iy]-&gt;index, FreeTopTenTriple[iy]-&gt;len);
1695       ast-&gt;fill_to(39);
1696       ast-&gt;print(&quot;Gap (to next) &quot; HEX32_FORMAT &quot;,&quot;, FreeTopTenTriple[iy]-&gt;gap);
1697       ast-&gt;fill_to(63);
1698       ast-&gt;print(&quot;#blocks (in gap) %d&quot;, FreeTopTenTriple[iy]-&gt;n_gapBlocks);
1699       ast-&gt;cr();
1700       BUFFEREDSTREAM_FLUSH_AUTO(&quot;&quot;)
1701     }
1702   }
1703   BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n&quot;)
1704 }
1705 
1706 
1707 void CodeHeapState::print_count(outputStream* out, CodeHeap* heap) {
1708   if (!initialization_complete) {
1709     return;
1710   }
1711 
1712   const char* heapName   = get_heapName(heap);
1713   get_HeapStatGlobals(out, heapName);
1714 
1715   if ((StatArray == NULL) || (alloc_granules == 0)) {
1716     return;
1717   }
1718   BUFFEREDSTREAM_DECL(ast, out)
1719 
1720   unsigned int granules_per_line = 32;
1721   char*        low_bound         = heap-&gt;low_boundary();
1722 
1723   {
1724     printBox(ast, &#39;=&#39;, &quot;B L O C K   C O U N T S   for &quot;, heapName);
1725     ast-&gt;print_cr(&quot;  Each granule contains an individual number of heap blocks. Large blocks\n&quot;
1726                   &quot;  may span multiple granules and are counted for each granule they touch.\n&quot;);
1727     if (segment_granules) {
1728       ast-&gt;print_cr(&quot;  You have selected granule size to be as small as segment size.\n&quot;
1729                     &quot;  As a result, each granule contains exactly one block (or a part of one block)\n&quot;
1730                     &quot;  or is displayed as empty (&#39; &#39;) if it&#39;s BlobType does not match the selection.\n&quot;
1731                     &quot;  Occupied granules show their BlobType character, see legend.\n&quot;);
1732       print_blobType_legend(ast);
1733     }
1734     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;&quot;)
1735   }
1736 
1737   {
1738     if (segment_granules) {
1739       printBox(ast, &#39;-&#39;, &quot;Total (all types) count for granule size == segment size&quot;, NULL);
1740 
1741       granules_per_line = 128;
1742       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
1743         print_line_delim(out, ast, low_bound, ix, granules_per_line);
1744         print_blobType_single(ast, StatArray[ix].type);
1745       }
1746     } else {
1747       printBox(ast, &#39;-&#39;, &quot;Total (all tiers) count, 0x1..0xf. &#39;*&#39; indicates &gt;= 16 blocks, &#39; &#39; indicates empty&quot;, NULL);
1748 
1749       granules_per_line = 128;
1750       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
1751         print_line_delim(out, ast, low_bound, ix, granules_per_line);
1752         unsigned int count = StatArray[ix].t1_count   + StatArray[ix].t2_count   + StatArray[ix].tx_count
1753                            + StatArray[ix].stub_count + StatArray[ix].dead_count;
1754         print_count_single(ast, count);
1755       }
1756     }
1757     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;|\n\n\n&quot;)
1758   }
1759 
1760   {
1761     if (nBlocks_t1 &gt; 0) {
1762       printBox(ast, &#39;-&#39;, &quot;Tier1 nMethod count only, 0x1..0xf. &#39;*&#39; indicates &gt;= 16 blocks, &#39; &#39; indicates empty&quot;, NULL);
1763 
1764       granules_per_line = 128;
1765       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
1766         print_line_delim(out, ast, low_bound, ix, granules_per_line);
1767         if (segment_granules &amp;&amp; StatArray[ix].t1_count &gt; 0) {
1768           print_blobType_single(ast, StatArray[ix].type);
1769         } else {
1770           print_count_single(ast, StatArray[ix].t1_count);
1771         }
1772       }
1773       ast-&gt;print(&quot;|&quot;);
1774     } else {
1775       ast-&gt;print(&quot;No Tier1 nMethods found in CodeHeap.&quot;);
1776     }
1777     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
1778   }
1779 
1780   {
1781     if (nBlocks_t2 &gt; 0) {
1782       printBox(ast, &#39;-&#39;, &quot;Tier2 nMethod count only, 0x1..0xf. &#39;*&#39; indicates &gt;= 16 blocks, &#39; &#39; indicates empty&quot;, NULL);
1783 
1784       granules_per_line = 128;
1785       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
1786         print_line_delim(out, ast, low_bound, ix, granules_per_line);
1787         if (segment_granules &amp;&amp; StatArray[ix].t2_count &gt; 0) {
1788           print_blobType_single(ast, StatArray[ix].type);
1789         } else {
1790           print_count_single(ast, StatArray[ix].t2_count);
1791         }
1792       }
1793       ast-&gt;print(&quot;|&quot;);
1794     } else {
1795       ast-&gt;print(&quot;No Tier2 nMethods found in CodeHeap.&quot;);
1796     }
1797     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
1798   }
1799 
1800   {
1801     if (nBlocks_alive &gt; 0) {
1802       printBox(ast, &#39;-&#39;, &quot;not_used/not_entrant/not_installed nMethod count only, 0x1..0xf. &#39;*&#39; indicates &gt;= 16 blocks, &#39; &#39; indicates empty&quot;, NULL);
1803 
1804       granules_per_line = 128;
1805       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
1806         print_line_delim(out, ast, low_bound, ix, granules_per_line);
1807         if (segment_granules &amp;&amp; StatArray[ix].tx_count &gt; 0) {
1808           print_blobType_single(ast, StatArray[ix].type);
1809         } else {
1810           print_count_single(ast, StatArray[ix].tx_count);
1811         }
1812       }
1813       ast-&gt;print(&quot;|&quot;);
1814     } else {
1815       ast-&gt;print(&quot;No not_used/not_entrant nMethods found in CodeHeap.&quot;);
1816     }
1817     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
1818   }
1819 
1820   {
1821     if (nBlocks_stub &gt; 0) {
1822       printBox(ast, &#39;-&#39;, &quot;Stub &amp; Blob count only, 0x1..0xf. &#39;*&#39; indicates &gt;= 16 blocks, &#39; &#39; indicates empty&quot;, NULL);
1823 
1824       granules_per_line = 128;
1825       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
1826         print_line_delim(out, ast, low_bound, ix, granules_per_line);
1827         if (segment_granules &amp;&amp; StatArray[ix].stub_count &gt; 0) {
1828           print_blobType_single(ast, StatArray[ix].type);
1829         } else {
1830           print_count_single(ast, StatArray[ix].stub_count);
1831         }
1832       }
1833       ast-&gt;print(&quot;|&quot;);
1834     } else {
1835       ast-&gt;print(&quot;No Stubs and Blobs found in CodeHeap.&quot;);
1836     }
1837     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
1838   }
1839 
1840   {
1841     if (nBlocks_dead &gt; 0) {
1842       printBox(ast, &#39;-&#39;, &quot;Dead nMethod count only, 0x1..0xf. &#39;*&#39; indicates &gt;= 16 blocks, &#39; &#39; indicates empty&quot;, NULL);
1843 
1844       granules_per_line = 128;
1845       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
1846         print_line_delim(out, ast, low_bound, ix, granules_per_line);
1847         if (segment_granules &amp;&amp; StatArray[ix].dead_count &gt; 0) {
1848           print_blobType_single(ast, StatArray[ix].type);
1849         } else {
1850           print_count_single(ast, StatArray[ix].dead_count);
1851         }
1852       }
1853       ast-&gt;print(&quot;|&quot;);
1854     } else {
1855       ast-&gt;print(&quot;No dead nMethods found in CodeHeap.&quot;);
1856     }
1857     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
1858   }
1859 
1860   {
1861     if (!segment_granules) { // Prevent totally redundant printouts
1862       printBox(ast, &#39;-&#39;, &quot;Count by tier (combined, no dead blocks): &lt;#t1&gt;:&lt;#t2&gt;:&lt;#s&gt;, 0x0..0xf. &#39;*&#39; indicates &gt;= 16 blocks&quot;, NULL);
1863 
1864       granules_per_line = 24;
1865       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
1866         print_line_delim(out, ast, low_bound, ix, granules_per_line);
1867 
1868         print_count_single(ast, StatArray[ix].t1_count);
1869         ast-&gt;print(&quot;:&quot;);
1870         print_count_single(ast, StatArray[ix].t2_count);
1871         ast-&gt;print(&quot;:&quot;);
1872         if (segment_granules &amp;&amp; StatArray[ix].stub_count &gt; 0) {
1873           print_blobType_single(ast, StatArray[ix].type);
1874         } else {
1875           print_count_single(ast, StatArray[ix].stub_count);
1876         }
1877         ast-&gt;print(&quot; &quot;);
1878       }
1879       BUFFEREDSTREAM_FLUSH_LOCKED(&quot;|\n\n\n&quot;)
1880     }
1881   }
1882 }
1883 
1884 
1885 void CodeHeapState::print_space(outputStream* out, CodeHeap* heap) {
1886   if (!initialization_complete) {
1887     return;
1888   }
1889 
1890   const char* heapName   = get_heapName(heap);
1891   get_HeapStatGlobals(out, heapName);
1892 
1893   if ((StatArray == NULL) || (alloc_granules == 0)) {
1894     return;
1895   }
1896   BUFFEREDSTREAM_DECL(ast, out)
1897 
1898   unsigned int granules_per_line = 32;
1899   char*        low_bound         = heap-&gt;low_boundary();
1900 
1901   {
1902     printBox(ast, &#39;=&#39;, &quot;S P A C E   U S A G E  &amp;  F R A G M E N T A T I O N   for &quot;, heapName);
1903     ast-&gt;print_cr(&quot;  The heap space covered by one granule is occupied to a various extend.\n&quot;
1904                   &quot;  The granule occupancy is displayed by one decimal digit per granule.\n&quot;);
1905     if (segment_granules) {
1906       ast-&gt;print_cr(&quot;  You have selected granule size to be as small as segment size.\n&quot;
1907                     &quot;  As a result, each granule contains exactly one block (or a part of one block)\n&quot;
1908                     &quot;  or is displayed as empty (&#39; &#39;) if it&#39;s BlobType does not match the selection.\n&quot;
1909                     &quot;  Occupied granules show their BlobType character, see legend.\n&quot;);
1910       print_blobType_legend(ast);
1911     } else {
1912       ast-&gt;print_cr(&quot;  These digits represent a fill percentage range (see legend).\n&quot;);
1913       print_space_legend(ast);
1914     }
1915     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;&quot;)
1916   }
1917 
1918   {
1919     if (segment_granules) {
1920       printBox(ast, &#39;-&#39;, &quot;Total (all types) space consumption for granule size == segment size&quot;, NULL);
1921 
1922       granules_per_line = 128;
1923       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
1924         print_line_delim(out, ast, low_bound, ix, granules_per_line);
1925         print_blobType_single(ast, StatArray[ix].type);
1926       }
1927     } else {
1928       printBox(ast, &#39;-&#39;, &quot;Total (all types) space consumption. &#39; &#39; indicates empty, &#39;*&#39; indicates full.&quot;, NULL);
1929 
1930       granules_per_line = 128;
1931       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
1932         print_line_delim(out, ast, low_bound, ix, granules_per_line);
1933         unsigned int space    = StatArray[ix].t1_space   + StatArray[ix].t2_space  + StatArray[ix].tx_space
1934                               + StatArray[ix].stub_space + StatArray[ix].dead_space;
1935         print_space_single(ast, space);
1936       }
1937     }
1938     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;|\n\n\n&quot;)
1939   }
1940 
1941   {
1942     if (nBlocks_t1 &gt; 0) {
1943       printBox(ast, &#39;-&#39;, &quot;Tier1 space consumption. &#39; &#39; indicates empty, &#39;*&#39; indicates full&quot;, NULL);
1944 
1945       granules_per_line = 128;
1946       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
1947         print_line_delim(out, ast, low_bound, ix, granules_per_line);
1948         if (segment_granules &amp;&amp; StatArray[ix].t1_space &gt; 0) {
1949           print_blobType_single(ast, StatArray[ix].type);
1950         } else {
1951           print_space_single(ast, StatArray[ix].t1_space);
1952         }
1953       }
1954       ast-&gt;print(&quot;|&quot;);
1955     } else {
1956       ast-&gt;print(&quot;No Tier1 nMethods found in CodeHeap.&quot;);
1957     }
1958     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
1959   }
1960 
1961   {
1962     if (nBlocks_t2 &gt; 0) {
1963       printBox(ast, &#39;-&#39;, &quot;Tier2 space consumption. &#39; &#39; indicates empty, &#39;*&#39; indicates full&quot;, NULL);
1964 
1965       granules_per_line = 128;
1966       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
1967         print_line_delim(out, ast, low_bound, ix, granules_per_line);
1968         if (segment_granules &amp;&amp; StatArray[ix].t2_space &gt; 0) {
1969           print_blobType_single(ast, StatArray[ix].type);
1970         } else {
1971           print_space_single(ast, StatArray[ix].t2_space);
1972         }
1973       }
1974       ast-&gt;print(&quot;|&quot;);
1975     } else {
1976       ast-&gt;print(&quot;No Tier2 nMethods found in CodeHeap.&quot;);
1977     }
1978     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
1979   }
1980 
1981   {
1982     if (nBlocks_alive &gt; 0) {
1983       printBox(ast, &#39;-&#39;, &quot;not_used/not_entrant/not_installed space consumption. &#39; &#39; indicates empty, &#39;*&#39; indicates full&quot;, NULL);
1984 
1985       granules_per_line = 128;
1986       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
1987         print_line_delim(out, ast, low_bound, ix, granules_per_line);
1988         if (segment_granules &amp;&amp; StatArray[ix].tx_space &gt; 0) {
1989           print_blobType_single(ast, StatArray[ix].type);
1990         } else {
1991           print_space_single(ast, StatArray[ix].tx_space);
1992         }
1993       }
1994       ast-&gt;print(&quot;|&quot;);
1995     } else {
1996       ast-&gt;print(&quot;No Tier2 nMethods found in CodeHeap.&quot;);
1997     }
1998     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
1999   }
2000 
2001   {
2002     if (nBlocks_stub &gt; 0) {
2003       printBox(ast, &#39;-&#39;, &quot;Stub and Blob space consumption. &#39; &#39; indicates empty, &#39;*&#39; indicates full&quot;, NULL);
2004 
2005       granules_per_line = 128;
2006       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
2007         print_line_delim(out, ast, low_bound, ix, granules_per_line);
2008         if (segment_granules &amp;&amp; StatArray[ix].stub_space &gt; 0) {
2009           print_blobType_single(ast, StatArray[ix].type);
2010         } else {
2011           print_space_single(ast, StatArray[ix].stub_space);
2012         }
2013       }
2014       ast-&gt;print(&quot;|&quot;);
2015     } else {
2016       ast-&gt;print(&quot;No Stubs and Blobs found in CodeHeap.&quot;);
2017     }
2018     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
2019   }
2020 
2021   {
2022     if (nBlocks_dead &gt; 0) {
2023       printBox(ast, &#39;-&#39;, &quot;Dead space consumption. &#39; &#39; indicates empty, &#39;*&#39; indicates full&quot;, NULL);
2024 
2025       granules_per_line = 128;
2026       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
2027         print_line_delim(out, ast, low_bound, ix, granules_per_line);
2028         print_space_single(ast, StatArray[ix].dead_space);
2029       }
2030       ast-&gt;print(&quot;|&quot;);
2031     } else {
2032       ast-&gt;print(&quot;No dead nMethods found in CodeHeap.&quot;);
2033     }
2034     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
2035   }
2036 
2037   {
2038     if (!segment_granules) { // Prevent totally redundant printouts
2039       printBox(ast, &#39;-&#39;, &quot;Space consumption by tier (combined): &lt;t1%&gt;:&lt;t2%&gt;:&lt;s%&gt;. &#39; &#39; indicates empty, &#39;*&#39; indicates full&quot;, NULL);
2040 
2041       granules_per_line = 24;
2042       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
2043         print_line_delim(out, ast, low_bound, ix, granules_per_line);
2044 
2045         if (segment_granules &amp;&amp; StatArray[ix].t1_space &gt; 0) {
2046           print_blobType_single(ast, StatArray[ix].type);
2047         } else {
2048           print_space_single(ast, StatArray[ix].t1_space);
2049         }
2050         ast-&gt;print(&quot;:&quot;);
2051         if (segment_granules &amp;&amp; StatArray[ix].t2_space &gt; 0) {
2052           print_blobType_single(ast, StatArray[ix].type);
2053         } else {
2054           print_space_single(ast, StatArray[ix].t2_space);
2055         }
2056         ast-&gt;print(&quot;:&quot;);
2057         if (segment_granules &amp;&amp; StatArray[ix].stub_space &gt; 0) {
2058           print_blobType_single(ast, StatArray[ix].type);
2059         } else {
2060           print_space_single(ast, StatArray[ix].stub_space);
2061         }
2062         ast-&gt;print(&quot; &quot;);
2063       }
2064       ast-&gt;print(&quot;|&quot;);
2065       BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
2066     }
2067   }
2068 }
2069 
2070 void CodeHeapState::print_age(outputStream* out, CodeHeap* heap) {
2071   if (!initialization_complete) {
2072     return;
2073   }
2074 
2075   const char* heapName   = get_heapName(heap);
2076   get_HeapStatGlobals(out, heapName);
2077 
2078   if ((StatArray == NULL) || (alloc_granules == 0)) {
2079     return;
2080   }
2081   BUFFEREDSTREAM_DECL(ast, out)
2082 
2083   unsigned int granules_per_line = 32;
2084   char*        low_bound         = heap-&gt;low_boundary();
2085 
2086   {
2087     printBox(ast, &#39;=&#39;, &quot;M E T H O D   A G E   by CompileID for &quot;, heapName);
2088     ast-&gt;print_cr(&quot;  The age of a compiled method in the CodeHeap is not available as a\n&quot;
2089                   &quot;  time stamp. Instead, a relative age is deducted from the method&#39;s compilation ID.\n&quot;
2090                   &quot;  Age information is available for tier1 and tier2 methods only. There is no\n&quot;
2091                   &quot;  age information for stubs and blobs, because they have no compilation ID assigned.\n&quot;
2092                   &quot;  Information for the youngest method (highest ID) in the granule is printed.\n&quot;
2093                   &quot;  Refer to the legend to learn how method age is mapped to the displayed digit.&quot;);
2094     print_age_legend(ast);
2095     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;&quot;)
2096   }
2097 
2098   {
2099     printBox(ast, &#39;-&#39;, &quot;Age distribution. &#39;0&#39; indicates youngest 1/256, &#39;8&#39;: oldest half, &#39; &#39;: no age information&quot;, NULL);
2100 
2101     granules_per_line = 128;
2102     for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
2103       print_line_delim(out, ast, low_bound, ix, granules_per_line);
2104       unsigned int age1      = StatArray[ix].t1_age;
2105       unsigned int age2      = StatArray[ix].t2_age;
2106       unsigned int agex      = StatArray[ix].tx_age;
2107       unsigned int age       = age1 &gt; age2 ? age1 : age2;
2108       age       = age &gt; agex ? age : agex;
2109       print_age_single(ast, age);
2110     }
2111     ast-&gt;print(&quot;|&quot;);
2112     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
2113   }
2114 
2115   {
2116     if (nBlocks_t1 &gt; 0) {
2117       printBox(ast, &#39;-&#39;, &quot;Tier1 age distribution. &#39;0&#39; indicates youngest 1/256, &#39;8&#39;: oldest half, &#39; &#39;: no age information&quot;, NULL);
2118 
2119       granules_per_line = 128;
2120       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
2121         print_line_delim(out, ast, low_bound, ix, granules_per_line);
2122         print_age_single(ast, StatArray[ix].t1_age);
2123       }
2124       ast-&gt;print(&quot;|&quot;);
2125     } else {
2126       ast-&gt;print(&quot;No Tier1 nMethods found in CodeHeap.&quot;);
2127     }
2128     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
2129   }
2130 
2131   {
2132     if (nBlocks_t2 &gt; 0) {
2133       printBox(ast, &#39;-&#39;, &quot;Tier2 age distribution. &#39;0&#39; indicates youngest 1/256, &#39;8&#39;: oldest half, &#39; &#39;: no age information&quot;, NULL);
2134 
2135       granules_per_line = 128;
2136       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
2137         print_line_delim(out, ast, low_bound, ix, granules_per_line);
2138         print_age_single(ast, StatArray[ix].t2_age);
2139       }
2140       ast-&gt;print(&quot;|&quot;);
2141     } else {
2142       ast-&gt;print(&quot;No Tier2 nMethods found in CodeHeap.&quot;);
2143     }
2144     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
2145   }
2146 
2147   {
2148     if (nBlocks_alive &gt; 0) {
2149       printBox(ast, &#39;-&#39;, &quot;not_used/not_entrant/not_installed age distribution. &#39;0&#39; indicates youngest 1/256, &#39;8&#39;: oldest half, &#39; &#39;: no age information&quot;, NULL);
2150 
2151       granules_per_line = 128;
2152       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
2153         print_line_delim(out, ast, low_bound, ix, granules_per_line);
2154         print_age_single(ast, StatArray[ix].tx_age);
2155       }
2156       ast-&gt;print(&quot;|&quot;);
2157     } else {
2158       ast-&gt;print(&quot;No Tier2 nMethods found in CodeHeap.&quot;);
2159     }
2160     BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
2161   }
2162 
2163   {
2164     if (!segment_granules) { // Prevent totally redundant printouts
2165       printBox(ast, &#39;-&#39;, &quot;age distribution by tier &lt;a1&gt;:&lt;a2&gt;. &#39;0&#39; indicates youngest 1/256, &#39;8&#39;: oldest half, &#39; &#39;: no age information&quot;, NULL);
2166 
2167       granules_per_line = 32;
2168       for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
2169         print_line_delim(out, ast, low_bound, ix, granules_per_line);
2170         print_age_single(ast, StatArray[ix].t1_age);
2171         ast-&gt;print(&quot;:&quot;);
2172         print_age_single(ast, StatArray[ix].t2_age);
2173         ast-&gt;print(&quot; &quot;);
2174       }
2175       ast-&gt;print(&quot;|&quot;);
2176       BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n\n&quot;)
2177     }
2178   }
2179 }
2180 
2181 
2182 void CodeHeapState::print_names(outputStream* out, CodeHeap* heap) {
2183   if (!initialization_complete) {
2184     return;
2185   }
2186 
2187   const char* heapName   = get_heapName(heap);
2188   get_HeapStatGlobals(out, heapName);
2189 
2190   if ((StatArray == NULL) || (alloc_granules == 0)) {
2191     return;
2192   }
2193   BUFFEREDSTREAM_DECL(ast, out)
2194 
2195   unsigned int granules_per_line   = 128;
2196   char*        low_bound           = heap-&gt;low_boundary();
2197   CodeBlob*    last_blob           = NULL;
2198   bool         name_in_addr_range  = true;
2199   bool         have_CodeCache_lock = CodeCache_lock-&gt;owned_by_self();
2200 
2201   //---&lt;  print at least 128K per block (i.e. between headers)  &gt;---
2202   if (granules_per_line*granule_size &lt; 128*K) {
2203     granules_per_line = (unsigned int)((128*K)/granule_size);
2204   }
2205 
2206   printBox(ast, &#39;=&#39;, &quot;M E T H O D   N A M E S   for &quot;, heapName);
2207   ast-&gt;print_cr(&quot;  Method names are dynamically retrieved from the code cache at print time.\n&quot;
2208                 &quot;  Due to the living nature of the code heap and because the CodeCache_lock\n&quot;
2209                 &quot;  is not continuously held, the displayed name might be wrong or no name\n&quot;
2210                 &quot;  might be found at all. The likelihood for that to happen increases\n&quot;
2211                 &quot;  over time passed between aggregtion and print steps.\n&quot;);
2212   BUFFEREDSTREAM_FLUSH_LOCKED(&quot;&quot;)
2213 
2214   for (unsigned int ix = 0; ix &lt; alloc_granules; ix++) {
2215     //---&lt;  print a new blob on a new line  &gt;---
2216     if (ix%granules_per_line == 0) {
2217       if (!name_in_addr_range) {
2218         ast-&gt;print_cr(&quot;No methods, blobs, or stubs found in this address range&quot;);
2219       }
2220       name_in_addr_range = false;
2221 
2222       size_t end_ix = (ix+granules_per_line &lt;= alloc_granules) ? ix+granules_per_line : alloc_granules;
2223       ast-&gt;cr();
2224       ast-&gt;print_cr(&quot;--------------------------------------------------------------------&quot;);
2225       ast-&gt;print_cr(&quot;Address range [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;), &quot; SIZE_FORMAT &quot;k&quot;, p2i(low_bound+ix*granule_size), p2i(low_bound + end_ix*granule_size), (end_ix - ix)*granule_size/(size_t)K);
2226       ast-&gt;print_cr(&quot;--------------------------------------------------------------------&quot;);
2227       BUFFEREDSTREAM_FLUSH_AUTO(&quot;&quot;)
2228     }
2229     // Only check granule if it contains at least one blob.
2230     unsigned int nBlobs  = StatArray[ix].t1_count   + StatArray[ix].t2_count + StatArray[ix].tx_count +
2231                            StatArray[ix].stub_count + StatArray[ix].dead_count;
2232     if (nBlobs &gt; 0 ) {
2233     for (unsigned int is = 0; is &lt; granule_size; is+=(unsigned int)seg_size) {
2234       // heap-&gt;find_start() is safe. Only works on _segmap.
2235       // Returns NULL or void*. Returned CodeBlob may be uninitialized.
2236       char*     this_seg  = low_bound + ix*granule_size + is;
2237       CodeBlob* this_blob = (CodeBlob*)(heap-&gt;find_start(this_seg));
2238       bool   blob_is_safe = blob_access_is_safe(this_blob, NULL);
2239       // blob could have been flushed, freed, and merged.
2240       // this_blob &lt; last_blob is an indicator for that.
2241       if (blob_is_safe &amp;&amp; (this_blob &gt; last_blob)) {
2242         last_blob          = this_blob;
2243 
2244         //---&lt;  get type and name  &gt;---
2245         blobType       cbType = noType;
2246         if (segment_granules) {
2247           cbType = (blobType)StatArray[ix].type;
2248         } else {
2249           //---&lt;  access these fields only if we own the CodeCache_lock  &gt;---
2250           if (have_CodeCache_lock) {
2251             cbType = get_cbType(this_blob);
2252           }
2253         }
2254 
2255         //---&lt;  access these fields only if we own the CodeCache_lock  &gt;---
2256         const char* blob_name = &quot;&lt;unavailable&gt;&quot;;
2257         nmethod*           nm = NULL;
2258         if (have_CodeCache_lock) {
2259           blob_name = this_blob-&gt;name();
2260           nm        = this_blob-&gt;as_nmethod_or_null();
2261           // this_blob-&gt;name() could return NULL if no name was given to CTOR. Inlined, maybe invisible on stack
2262           if ((blob_name == NULL) || !os::is_readable_pointer(blob_name)) {
2263             blob_name = &quot;&lt;unavailable&gt;&quot;;
2264           }
2265         }
2266 
2267         //---&lt;  print table header for new print range  &gt;---
2268         if (!name_in_addr_range) {
2269           name_in_addr_range = true;
2270           ast-&gt;fill_to(51);
2271           ast-&gt;print(&quot;%9s&quot;, &quot;compiler&quot;);
2272           ast-&gt;fill_to(61);
2273           ast-&gt;print_cr(&quot;%6s&quot;, &quot;method&quot;);
2274           ast-&gt;print_cr(&quot;%18s %13s %17s %9s  %5s %18s  %s&quot;, &quot;Addr(module)      &quot;, &quot;offset&quot;, &quot;size&quot;, &quot; type lvl&quot;, &quot; temp&quot;, &quot;blobType          &quot;, &quot;Name&quot;);
2275           BUFFEREDSTREAM_FLUSH_AUTO(&quot;&quot;)
2276         }
2277 
2278         //---&lt;  print line prefix (address and offset from CodeHeap start)  &gt;---
2279         ast-&gt;print(INTPTR_FORMAT, p2i(this_blob));
2280         ast-&gt;fill_to(19);
2281         ast-&gt;print(&quot;(+&quot; PTR32_FORMAT &quot;)&quot;, (unsigned int)((char*)this_blob-low_bound));
2282         ast-&gt;fill_to(33);
2283 
2284         // access nmethod and Method fields only if we own the CodeCache_lock.
2285         // This fact is implicitly transported via nm != NULL.
2286         if (CompiledMethod::nmethod_access_is_safe(nm)) {
2287           Method* method = nm-&gt;method();
2288           ResourceMark rm;
2289           //---&lt;  collect all data to locals as quickly as possible  &gt;---
2290           unsigned int total_size = nm-&gt;total_size();
2291           int          hotness    = nm-&gt;hotness_counter();
2292           bool         get_name   = (cbType == nMethod_inuse) || (cbType == nMethod_notused);
2293           //---&lt;  nMethod size in hex  &gt;---
2294           ast-&gt;print(PTR32_FORMAT, total_size);
2295           ast-&gt;print(&quot;(&quot; SIZE_FORMAT_W(4) &quot;K)&quot;, total_size/K);
2296           //---&lt;  compiler information  &gt;---
2297           ast-&gt;fill_to(51);
2298           ast-&gt;print(&quot;%5s %3d&quot;, compTypeName[StatArray[ix].compiler], StatArray[ix].level);
2299           //---&lt;  method temperature  &gt;---
2300           ast-&gt;fill_to(62);
2301           ast-&gt;print(&quot;%5d&quot;, hotness);
2302           //---&lt;  name and signature  &gt;---
2303           ast-&gt;fill_to(62+6);
2304           ast-&gt;print(&quot;%s&quot;, blobTypeName[cbType]);
2305           ast-&gt;fill_to(82+6);
2306           if (cbType == nMethod_dead) {
2307             ast-&gt;print(&quot;%14s&quot;, &quot; zombie method&quot;);
2308           }
2309 
2310           if (get_name) {
2311             Symbol* methName  = method-&gt;name();
2312             const char*   methNameS = (methName == NULL) ? NULL : methName-&gt;as_C_string();
2313             methNameS = (methNameS == NULL) ? &quot;&lt;method name unavailable&gt;&quot; : methNameS;
2314             Symbol* methSig   = method-&gt;signature();
2315             const char*   methSigS  = (methSig  == NULL) ? NULL : methSig-&gt;as_C_string();
2316             methSigS  = (methSigS  == NULL) ? &quot;&lt;method signature unavailable&gt;&quot; : methSigS;
2317             ast-&gt;print(&quot;%s&quot;, methNameS);
2318             ast-&gt;print(&quot;%s&quot;, methSigS);
2319           } else {
2320             ast-&gt;print(&quot;%s&quot;, blob_name);
2321           }
2322         } else if (blob_is_safe) {
2323           ast-&gt;fill_to(62+6);
2324           ast-&gt;print(&quot;%s&quot;, blobTypeName[cbType]);
2325           ast-&gt;fill_to(82+6);
2326           ast-&gt;print(&quot;%s&quot;, blob_name);
2327         } else {
2328           ast-&gt;fill_to(62+6);
2329           ast-&gt;print(&quot;&lt;stale blob&gt;&quot;);
2330         }
2331         ast-&gt;cr();
2332         BUFFEREDSTREAM_FLUSH_AUTO(&quot;&quot;)
2333       } else if (!blob_is_safe &amp;&amp; (this_blob != last_blob) &amp;&amp; (this_blob != NULL)) {
2334         last_blob          = this_blob;
2335       }
2336     }
2337     } // nBlobs &gt; 0
2338   }
2339   BUFFEREDSTREAM_FLUSH_LOCKED(&quot;\n\n&quot;)
2340 }
2341 
2342 
2343 void CodeHeapState::printBox(outputStream* ast, const char border, const char* text1, const char* text2) {
2344   unsigned int lineLen = 1 + 2 + 2 + 1;
2345   char edge, frame;
2346 
2347   if (text1 != NULL) {
2348     lineLen += (unsigned int)strlen(text1); // text1 is much shorter than MAX_INT chars.
2349   }
2350   if (text2 != NULL) {
2351     lineLen += (unsigned int)strlen(text2); // text2 is much shorter than MAX_INT chars.
2352   }
2353   if (border == &#39;-&#39;) {
2354     edge  = &#39;+&#39;;
2355     frame = &#39;|&#39;;
2356   } else {
2357     edge  = border;
2358     frame = border;
2359   }
2360 
2361   ast-&gt;print(&quot;%c&quot;, edge);
2362   for (unsigned int i = 0; i &lt; lineLen-2; i++) {
2363     ast-&gt;print(&quot;%c&quot;, border);
2364   }
2365   ast-&gt;print_cr(&quot;%c&quot;, edge);
2366 
2367   ast-&gt;print(&quot;%c  &quot;, frame);
2368   if (text1 != NULL) {
2369     ast-&gt;print(&quot;%s&quot;, text1);
2370   }
2371   if (text2 != NULL) {
2372     ast-&gt;print(&quot;%s&quot;, text2);
2373   }
2374   ast-&gt;print_cr(&quot;  %c&quot;, frame);
2375 
2376   ast-&gt;print(&quot;%c&quot;, edge);
2377   for (unsigned int i = 0; i &lt; lineLen-2; i++) {
2378     ast-&gt;print(&quot;%c&quot;, border);
2379   }
2380   ast-&gt;print_cr(&quot;%c&quot;, edge);
2381 }
2382 
2383 void CodeHeapState::print_blobType_legend(outputStream* out) {
2384   out-&gt;cr();
2385   printBox(out, &#39;-&#39;, &quot;Block types used in the following CodeHeap dump&quot;, NULL);
2386   for (int type = noType; type &lt; lastType; type += 1) {
2387     out-&gt;print_cr(&quot;  %c - %s&quot;, blobTypeChar[type], blobTypeName[type]);
2388   }
2389   out-&gt;print_cr(&quot;  -----------------------------------------------------&quot;);
2390   out-&gt;cr();
2391 }
2392 
2393 void CodeHeapState::print_space_legend(outputStream* out) {
2394   unsigned int indicator = 0;
2395   unsigned int age_range = 256;
2396   unsigned int range_beg = latest_compilation_id;
2397   out-&gt;cr();
2398   printBox(out, &#39;-&#39;, &quot;Space ranges, based on granule occupancy&quot;, NULL);
2399   out-&gt;print_cr(&quot;    -   0%% == occupancy&quot;);
2400   for (int i=0; i&lt;=9; i++) {
2401     out-&gt;print_cr(&quot;  %d - %3d%% &lt; occupancy &lt; %3d%%&quot;, i, 10*i, 10*(i+1));
2402   }
2403   out-&gt;print_cr(&quot;  * - 100%% == occupancy&quot;);
2404   out-&gt;print_cr(&quot;  ----------------------------------------------&quot;);
2405   out-&gt;cr();
2406 }
2407 
2408 void CodeHeapState::print_age_legend(outputStream* out) {
2409   unsigned int indicator = 0;
2410   unsigned int age_range = 256;
2411   unsigned int range_beg = latest_compilation_id;
2412   out-&gt;cr();
2413   printBox(out, &#39;-&#39;, &quot;Age ranges, based on compilation id&quot;, NULL);
2414   while (age_range &gt; 0) {
2415     out-&gt;print_cr(&quot;  %d - %6d to %6d&quot;, indicator, range_beg, latest_compilation_id - latest_compilation_id/age_range);
2416     range_beg = latest_compilation_id - latest_compilation_id/age_range;
2417     age_range /= 2;
2418     indicator += 1;
2419   }
2420   out-&gt;print_cr(&quot;  -----------------------------------------&quot;);
2421   out-&gt;cr();
2422 }
2423 
2424 void CodeHeapState::print_blobType_single(outputStream* out, u2 /* blobType */ type) {
2425   out-&gt;print(&quot;%c&quot;, blobTypeChar[type]);
2426 }
2427 
2428 void CodeHeapState::print_count_single(outputStream* out, unsigned short count) {
2429   if (count &gt;= 16)    out-&gt;print(&quot;*&quot;);
2430   else if (count &gt; 0) out-&gt;print(&quot;%1.1x&quot;, count);
2431   else                out-&gt;print(&quot; &quot;);
2432 }
2433 
2434 void CodeHeapState::print_space_single(outputStream* out, unsigned short space) {
2435   size_t  space_in_bytes = ((unsigned int)space)&lt;&lt;log2_seg_size;
2436   char    fraction       = (space == 0) ? &#39; &#39; : (space_in_bytes &gt;= granule_size-1) ? &#39;*&#39; : char(&#39;0&#39;+10*space_in_bytes/granule_size);
2437   out-&gt;print(&quot;%c&quot;, fraction);
2438 }
2439 
2440 void CodeHeapState::print_age_single(outputStream* out, unsigned int age) {
2441   unsigned int indicator = 0;
2442   unsigned int age_range = 256;
2443   if (age &gt; 0) {
2444     while ((age_range &gt; 0) &amp;&amp; (latest_compilation_id-age &gt; latest_compilation_id/age_range)) {
2445       age_range /= 2;
2446       indicator += 1;
2447     }
2448     out-&gt;print(&quot;%c&quot;, char(&#39;0&#39;+indicator));
2449   } else {
2450     out-&gt;print(&quot; &quot;);
2451   }
2452 }
2453 
2454 void CodeHeapState::print_line_delim(outputStream* out, outputStream* ast, char* low_bound, unsigned int ix, unsigned int gpl) {
2455   if (ix % gpl == 0) {
2456     if (ix &gt; 0) {
2457       ast-&gt;print(&quot;|&quot;);
2458     }
2459     ast-&gt;cr();
2460     assert(out == ast, &quot;must use the same stream!&quot;);
2461 
2462     ast-&gt;print(INTPTR_FORMAT, p2i(low_bound + ix*granule_size));
2463     ast-&gt;fill_to(19);
2464     ast-&gt;print(&quot;(+&quot; PTR32_FORMAT &quot;): |&quot;, (unsigned int)(ix*granule_size));
2465   }
2466 }
2467 
2468 void CodeHeapState::print_line_delim(outputStream* out, bufferedStream* ast, char* low_bound, unsigned int ix, unsigned int gpl) {
2469   assert(out != ast, &quot;must not use the same stream!&quot;);
2470   if (ix % gpl == 0) {
2471     if (ix &gt; 0) {
2472       ast-&gt;print(&quot;|&quot;);
2473     }
2474     ast-&gt;cr();
2475 
2476     // can&#39;t use BUFFEREDSTREAM_FLUSH_IF(&quot;&quot;, 512) here.
2477     // can&#39;t use this expression. bufferedStream::capacity() does not exist.
2478     // if ((ast-&gt;capacity() - ast-&gt;size()) &lt; 512) {
2479     // Assume instead that default bufferedStream capacity (4K) was used.
2480     if (ast-&gt;size() &gt; 3*K) {
2481       ttyLocker ttyl;
2482       out-&gt;print(&quot;%s&quot;, ast-&gt;as_string());
2483       ast-&gt;reset();
2484     }
2485 
2486     ast-&gt;print(INTPTR_FORMAT, p2i(low_bound + ix*granule_size));
2487     ast-&gt;fill_to(19);
2488     ast-&gt;print(&quot;(+&quot; PTR32_FORMAT &quot;): |&quot;, (unsigned int)(ix*granule_size));
2489   }
2490 }
2491 
2492 CodeHeapState::blobType CodeHeapState::get_cbType(CodeBlob* cb) {
2493   if ((cb != NULL) &amp;&amp; os::is_readable_pointer(cb)) {
2494     if (cb-&gt;is_runtime_stub())                return runtimeStub;
2495     if (cb-&gt;is_deoptimization_stub())         return deoptimizationStub;
2496     if (cb-&gt;is_uncommon_trap_stub())          return uncommonTrapStub;
2497     if (cb-&gt;is_exception_stub())              return exceptionStub;
2498     if (cb-&gt;is_safepoint_stub())              return safepointStub;
2499     if (cb-&gt;is_adapter_blob())                return adapterBlob;
2500     if (cb-&gt;is_method_handles_adapter_blob()) return mh_adapterBlob;
2501     if (cb-&gt;is_buffer_blob())                 return bufferBlob;
2502 
2503     //---&lt;  access these fields only if we own the CodeCache_lock  &gt;---
2504     // Should be ensured by caller. aggregate() amd print_names() do that.
2505     if (CodeCache_lock-&gt;owned_by_self()) {
2506       nmethod*  nm = cb-&gt;as_nmethod_or_null();
2507       if (nm != NULL) { // no is_readable check required, nm = (nmethod*)cb.
2508         if (nm-&gt;is_not_installed()) return nMethod_inconstruction;
2509         if (nm-&gt;is_zombie())        return nMethod_dead;
2510         if (nm-&gt;is_unloaded())      return nMethod_unloaded;
2511         if (nm-&gt;is_in_use())        return nMethod_inuse;
2512         if (nm-&gt;is_alive() &amp;&amp; !(nm-&gt;is_not_entrant()))   return nMethod_notused;
2513         if (nm-&gt;is_alive())         return nMethod_alive;
2514         return nMethod_dead;
2515       }
2516     }
2517   }
2518   return noType;
2519 }
2520 
2521 bool CodeHeapState::blob_access_is_safe(CodeBlob* this_blob, CodeBlob* prev_blob) {
2522   return (this_blob != NULL) &amp;&amp; // a blob must have been found, obviously
2523          ((this_blob == prev_blob) || (prev_blob == NULL)) &amp;&amp;  // when re-checking, the same blob must have been found
2524          (this_blob-&gt;header_size() &gt;= 0) &amp;&amp;
2525          (this_blob-&gt;relocation_size() &gt;= 0) &amp;&amp;
2526          ((address)this_blob + this_blob-&gt;header_size() == (address)(this_blob-&gt;relocation_begin())) &amp;&amp;
2527          ((address)this_blob + CodeBlob::align_code_offset(this_blob-&gt;header_size() + this_blob-&gt;relocation_size()) == (address)(this_blob-&gt;content_begin())) &amp;&amp;
2528          os::is_readable_pointer((address)(this_blob-&gt;relocation_begin())) &amp;&amp;
2529          os::is_readable_pointer(this_blob-&gt;content_begin());
2530 }
    </pre>
  </body>
</html>
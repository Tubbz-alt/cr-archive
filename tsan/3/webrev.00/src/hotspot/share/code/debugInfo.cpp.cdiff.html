<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/code/debugInfo.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compiledMethod.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="debugInfo.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/debugInfo.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,10 ***</span>
<span class="line-new-header">--- 24,11 ---</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;code/debugInfo.hpp&quot;
  #include &quot;code/debugInfoRec.hpp&quot;
  #include &quot;code/nmethod.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/jniHandles.inline.hpp&quot;
  #include &quot;runtime/thread.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 48,24 ***</span>
  void DebugInfoWriteStream::write_metadata(Metadata* h) {
    write_int(recorder()-&gt;oop_recorder()-&gt;find_index(h));
  }
  
  oop DebugInfoReadStream::read_oop() {
<span class="line-modified">!   oop o = code()-&gt;oop_at(read_int());</span>
    assert(oopDesc::is_oop_or_null(o), &quot;oop only&quot;);
    return o;
  }
  
<span class="line-modified">! ScopeValue* DebugInfoReadStream::read_object_value() {</span>
    int id = read_int();
  #ifdef ASSERT
    assert(_obj_pool != NULL, &quot;object pool does not exist&quot;);
    for (int i = _obj_pool-&gt;length() - 1; i &gt;= 0; i--) {
      assert(_obj_pool-&gt;at(i)-&gt;as_ObjectValue()-&gt;id() != id, &quot;should not be read twice&quot;);
    }
  #endif
<span class="line-modified">!   ObjectValue* result = new ObjectValue(id);</span>
    // Cache the object since an object field could reference it.
    _obj_pool-&gt;push(result);
    result-&gt;read_object(this);
    return result;
  }
<span class="line-new-header">--- 49,32 ---</span>
  void DebugInfoWriteStream::write_metadata(Metadata* h) {
    write_int(recorder()-&gt;oop_recorder()-&gt;find_index(h));
  }
  
  oop DebugInfoReadStream::read_oop() {
<span class="line-modified">!   nmethod* nm = const_cast&lt;CompiledMethod*&gt;(code())-&gt;as_nmethod_or_null();</span>
<span class="line-added">+   oop o;</span>
<span class="line-added">+   if (nm != NULL) {</span>
<span class="line-added">+     // Despite these oops being found inside nmethods that are on-stack,</span>
<span class="line-added">+     // they are not kept alive by all GCs (e.g. G1 and Shenandoah).</span>
<span class="line-added">+     o = nm-&gt;oop_at_phantom(read_int());</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     o = code()-&gt;oop_at(read_int());</span>
<span class="line-added">+   }</span>
    assert(oopDesc::is_oop_or_null(o), &quot;oop only&quot;);
    return o;
  }
  
<span class="line-modified">! ScopeValue* DebugInfoReadStream::read_object_value(bool is_auto_box) {</span>
    int id = read_int();
  #ifdef ASSERT
    assert(_obj_pool != NULL, &quot;object pool does not exist&quot;);
    for (int i = _obj_pool-&gt;length() - 1; i &gt;= 0; i--) {
      assert(_obj_pool-&gt;at(i)-&gt;as_ObjectValue()-&gt;id() != id, &quot;should not be read twice&quot;);
    }
  #endif
<span class="line-modified">!   ObjectValue* result = is_auto_box ? new AutoBoxObjectValue(id) : new ObjectValue(id);</span>
    // Cache the object since an object field could reference it.
    _obj_pool-&gt;push(result);
    result-&gt;read_object(this);
    return result;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 85,22 ***</span>
  
  // Serializing scope values
  
  enum { LOCATION_CODE = 0, CONSTANT_INT_CODE = 1,  CONSTANT_OOP_CODE = 2,
                            CONSTANT_LONG_CODE = 3, CONSTANT_DOUBLE_CODE = 4,
<span class="line-modified">!                           OBJECT_CODE = 5,        OBJECT_ID_CODE = 6 };</span>
  
  ScopeValue* ScopeValue::read_from(DebugInfoReadStream* stream) {
    ScopeValue* result = NULL;
    switch(stream-&gt;read_int()) {
<span class="line-modified">!    case LOCATION_CODE:        result = new LocationValue(stream);        break;</span>
<span class="line-modified">!    case CONSTANT_INT_CODE:    result = new ConstantIntValue(stream);     break;</span>
<span class="line-modified">!    case CONSTANT_OOP_CODE:    result = new ConstantOopReadValue(stream); break;</span>
<span class="line-modified">!    case CONSTANT_LONG_CODE:   result = new ConstantLongValue(stream);    break;</span>
<span class="line-modified">!    case CONSTANT_DOUBLE_CODE: result = new ConstantDoubleValue(stream);  break;</span>
<span class="line-modified">!    case OBJECT_CODE:          result = stream-&gt;read_object_value();      break;</span>
<span class="line-modified">!    case OBJECT_ID_CODE:       result = stream-&gt;get_cached_object();      break;</span>
     default: ShouldNotReachHere();
    }
    return result;
  }
  
<span class="line-new-header">--- 94,24 ---</span>
  
  // Serializing scope values
  
  enum { LOCATION_CODE = 0, CONSTANT_INT_CODE = 1,  CONSTANT_OOP_CODE = 2,
                            CONSTANT_LONG_CODE = 3, CONSTANT_DOUBLE_CODE = 4,
<span class="line-modified">!                           OBJECT_CODE = 5,        OBJECT_ID_CODE = 6,</span>
<span class="line-added">+                           AUTO_BOX_OBJECT_CODE = 7 };</span>
  
  ScopeValue* ScopeValue::read_from(DebugInfoReadStream* stream) {
    ScopeValue* result = NULL;
    switch(stream-&gt;read_int()) {
<span class="line-modified">!    case LOCATION_CODE:        result = new LocationValue(stream);                        break;</span>
<span class="line-modified">!    case CONSTANT_INT_CODE:    result = new ConstantIntValue(stream);                     break;</span>
<span class="line-modified">!    case CONSTANT_OOP_CODE:    result = new ConstantOopReadValue(stream);                 break;</span>
<span class="line-modified">!    case CONSTANT_LONG_CODE:   result = new ConstantLongValue(stream);                    break;</span>
<span class="line-modified">!    case CONSTANT_DOUBLE_CODE: result = new ConstantDoubleValue(stream);                  break;</span>
<span class="line-modified">!    case OBJECT_CODE:          result = stream-&gt;read_object_value(false /*is_auto_box*/); break;</span>
<span class="line-modified">!    case AUTO_BOX_OBJECT_CODE: result = stream-&gt;read_object_value(true /*is_auto_box*/);  break;</span>
<span class="line-added">+    case OBJECT_ID_CODE:       result = stream-&gt;get_cached_object();                      break;</span>
     default: ShouldNotReachHere();
    }
    return result;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 139,11 ***</span>
    if (_visited) {
      stream-&gt;write_int(OBJECT_ID_CODE);
      stream-&gt;write_int(_id);
    } else {
      _visited = true;
<span class="line-modified">!     stream-&gt;write_int(OBJECT_CODE);</span>
      stream-&gt;write_int(_id);
      _klass-&gt;write_on(stream);
      int length = _field_values.length();
      stream-&gt;write_int(length);
      for (int i = 0; i &lt; length; i++) {
<span class="line-new-header">--- 150,11 ---</span>
    if (_visited) {
      stream-&gt;write_int(OBJECT_ID_CODE);
      stream-&gt;write_int(_id);
    } else {
      _visited = true;
<span class="line-modified">!     stream-&gt;write_int(is_auto_box() ? AUTO_BOX_OBJECT_CODE : OBJECT_CODE);</span>
      stream-&gt;write_int(_id);
      _klass-&gt;write_on(stream);
      int length = _field_values.length();
      stream-&gt;write_int(length);
      for (int i = 0; i &lt; length; i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 151,11 ***</span>
      }
    }
  }
  
  void ObjectValue::print_on(outputStream* st) const {
<span class="line-modified">!   st-&gt;print(&quot;obj[%d]&quot;, _id);</span>
  }
  
  void ObjectValue::print_fields_on(outputStream* st) const {
  #ifndef PRODUCT
    if (_field_values.length() &gt; 0) {
<span class="line-new-header">--- 162,11 ---</span>
      }
    }
  }
  
  void ObjectValue::print_on(outputStream* st) const {
<span class="line-modified">!   st-&gt;print(&quot;%s[%d]&quot;, is_auto_box() ? &quot;box_obj&quot; : &quot;obj&quot;, _id);</span>
  }
  
  void ObjectValue::print_fields_on(outputStream* st) const {
  #ifndef PRODUCT
    if (_field_values.length() &gt; 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 220,11 ***</span>
    {
      // cannot use ThreadInVMfromNative here since in case of JVMCI compiler,
      // thread is already in VM state.
      ThreadInVMfromUnknown tiv;
      assert(JNIHandles::resolve(value()) == NULL ||
<span class="line-modified">!            Universe::heap()-&gt;is_in_reserved(JNIHandles::resolve(value())),</span>
             &quot;Should be in heap&quot;);
   }
  #endif
    stream-&gt;write_int(CONSTANT_OOP_CODE);
    stream-&gt;write_handle(value());
<span class="line-new-header">--- 231,11 ---</span>
    {
      // cannot use ThreadInVMfromNative here since in case of JVMCI compiler,
      // thread is already in VM state.
      ThreadInVMfromUnknown tiv;
      assert(JNIHandles::resolve(value()) == NULL ||
<span class="line-modified">!            Universe::heap()-&gt;is_in(JNIHandles::resolve(value())),</span>
             &quot;Should be in heap&quot;);
   }
  #endif
    stream-&gt;write_int(CONSTANT_OOP_CODE);
    stream-&gt;write_handle(value());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 241,11 ***</span>
  // ConstantOopReadValue
  
  ConstantOopReadValue::ConstantOopReadValue(DebugInfoReadStream* stream) {
    _value = Handle(Thread::current(), stream-&gt;read_oop());
    assert(_value() == NULL ||
<span class="line-modified">!          Universe::heap()-&gt;is_in_reserved(_value()), &quot;Should be in heap&quot;);</span>
  }
  
  void ConstantOopReadValue::write_on(DebugInfoWriteStream* stream) {
    ShouldNotReachHere();
  }
<span class="line-new-header">--- 252,11 ---</span>
  // ConstantOopReadValue
  
  ConstantOopReadValue::ConstantOopReadValue(DebugInfoReadStream* stream) {
    _value = Handle(Thread::current(), stream-&gt;read_oop());
    assert(_value() == NULL ||
<span class="line-modified">!          Universe::heap()-&gt;is_in(_value()), &quot;Should be in heap&quot;);</span>
  }
  
  void ConstantOopReadValue::write_on(DebugInfoWriteStream* stream) {
    ShouldNotReachHere();
  }
</pre>
<center><a href="compiledMethod.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="debugInfo.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
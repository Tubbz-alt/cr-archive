<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/code/oopRecorder.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CODE_OOPRECORDER_HPP
 26 #define SHARE_CODE_OOPRECORDER_HPP
 27 
<a name="1" id="anc1"></a>
 28 #include &quot;runtime/handles.hpp&quot;
 29 #include &quot;utilities/growableArray.hpp&quot;
 30 
 31 // Recording and retrieval of either oop relocations or metadata in compiled code.
 32 
 33 class CodeBlob;
 34 
 35 template &lt;class T&gt; class ValueRecorder : public StackObj {
 36  public:
 37   // A two-way mapping from positive indexes to oop handles.
 38   // The zero index is reserved for a constant (sharable) null.
 39   // Indexes may not be negative.
 40 
 41   // Use the given arena to manage storage, if not NULL.
 42   // By default, uses the current ResourceArea.
 43   ValueRecorder(Arena* arena = NULL);
 44 
 45   // Generate a new index on which nmethod::oop_addr_at will work.
 46   // allocate_index and find_index never return the same index,
 47   // and allocate_index never returns the same index twice.
 48   // In fact, two successive calls to allocate_index return successive ints.
 49   int allocate_index(T h) {
 50     return add_handle(h, false);
 51   }
 52 
 53   // For a given jobject or Metadata*, this will return the same index
 54   // repeatedly. The index can later be given to nmethod::oop_at or
 55   // metadata_at to retrieve the oop.
 56   // However, the oop must not be changed via nmethod::oop_addr_at.
 57   int find_index(T h) {
 58     int index = maybe_find_index(h);
 59     if (index &lt; 0) {  // previously unallocated
 60       index = add_handle(h, true);
 61     }
 62     return index;
 63   }
 64 
 65   // returns the size of the generated oop/metadata table, for sizing the
 66   // CodeBlob. Must be called after all oops are allocated!
 67   int size();
 68 
 69   // Retrieve the value at a given index.
 70   T at(int index);
 71 
 72   int count() {
 73     if (_handles == NULL) return 0;
 74     // there is always a NULL virtually present as first object
 75     return _handles-&gt;length() + first_index;
 76   }
 77 
 78   // Helper function; returns false for NULL or Universe::non_oop_word().
<a name="2" id="anc2"></a><span class="line-modified"> 79   inline bool is_real(T h);</span>


 80 
 81   // copy the generated table to nmethod
 82   void copy_values_to(nmethod* nm);
 83 
 84   bool is_unused() { return _handles == NULL &amp;&amp; !_complete; }
 85 #ifdef ASSERT
 86   bool is_complete() { return _complete; }
 87 #endif
 88 
 89  private:
 90   // variant of find_index which does not allocate if not found (yields -1)
 91   int maybe_find_index(T h);
 92 
 93   // leaky hash table of handle =&gt; index, to help detect duplicate insertion
 94   template &lt;class X&gt; class IndexCache : public ResourceObj {
 95     // This class is only used by the ValueRecorder class.
 96     friend class ValueRecorder;
 97     enum {
 98       _log_cache_size = 9,
 99       _cache_size = (1&lt;&lt;_log_cache_size),
100       // Index entries are ints.  The LSBit is a collision indicator.
101       _collision_bit_shift = 0,
102       _collision_bit = 1,
103       _index_shift = _collision_bit_shift+1
104     };
105     int _cache[_cache_size];
106     static juint cache_index(X handle) {
107       juint ci = (int) (intptr_t) handle;
108       ci ^= ci &gt;&gt; (BitsPerByte*2);
109       ci += ci &gt;&gt; (BitsPerByte*1);
110       return ci &amp; (_cache_size-1);
111     }
112     int* cache_location(X handle) {
113       return &amp;_cache[ cache_index(handle) ];
114     }
115     static bool cache_location_collision(int* cloc) {
116       return ((*cloc) &amp; _collision_bit) != 0;
117     }
118     static int cache_location_index(int* cloc) {
119       return (*cloc) &gt;&gt; _index_shift;
120     }
121     static void set_cache_location_index(int* cloc, int index) {
122       int cval0 = (*cloc);
123       int cval1 = (index &lt;&lt; _index_shift);
124       if (cval0 != 0 &amp;&amp; cval1 != cval0)  cval1 += _collision_bit;
125       (*cloc) = cval1;
126     }
127     IndexCache();
128   };
129 
130   void maybe_initialize();
131   int add_handle(T h, bool make_findable);
132 
133   enum { null_index = 0, first_index = 1, index_cache_threshold = 20 };
134 
135   GrowableArray&lt;T&gt;*        _handles;  // ordered list (first is always NULL)
136   GrowableArray&lt;int&gt;*       _no_finds; // all unfindable indexes; usually empty
137   IndexCache&lt;T&gt;*           _indexes;  // map: handle -&gt; its probable index
138   Arena*                    _arena;
139   bool                      _complete;
140 
141 #ifdef ASSERT
142   static int _find_index_calls, _hit_indexes, _missed_indexes;
143 #endif
144 };
145 
146 class OopRecorder;
147 
148 class ObjectLookup : public ResourceObj {
149  private:
150   class ObjectEntry {
151    private:
152     jobject _value;
153     int     _index;
154 
155    public:
156     ObjectEntry(jobject value, int index) : _value(value), _index(index) {}
157     ObjectEntry() : _value(NULL), _index(0) {}
158     oop oop_value() const;
159     int index() { return _index; }
160   };
161 
162   GrowableArray&lt;ObjectEntry&gt; _values;
163   unsigned int _gc_count;
164 
165   // Utility sort functions
166   static int sort_by_address(oop a, oop b);
167   static int sort_by_address(ObjectEntry* a, ObjectEntry* b);
168   static int sort_oop_by_address(oop const&amp; a, ObjectEntry const&amp; b);
169 
170  public:
171   ObjectLookup();
172 
173   // Resort list if a GC has occurred since the last sort
174   void maybe_resort();
175   int find_index(jobject object, OopRecorder* oop_recorder);
176 };
177 
178 class OopRecorder : public ResourceObj {
179  private:
180   ValueRecorder&lt;jobject&gt;      _oops;
181   ValueRecorder&lt;Metadata*&gt;    _metadata;
182   ObjectLookup*               _object_lookup;
183  public:
184   OopRecorder(Arena* arena = NULL, bool deduplicate = false): _oops(arena), _metadata(arena) {
185     if (deduplicate) {
186       _object_lookup = new ObjectLookup();
187     } else {
188       _object_lookup = NULL;
189     }
190   }
191 
192   int allocate_oop_index(jobject h) {
193     return _oops.allocate_index(h);
194   }
195   virtual int find_index(jobject h) {
196     return _object_lookup != NULL ? _object_lookup-&gt;find_index(h, this) : _oops.find_index(h);
197   }
198   jobject oop_at(int index) {
199     return _oops.at(index);
200   }
201   int oop_size() {
202     return _oops.size();
203   }
204   int oop_count() {
205     return _oops.count();
206   }
<a name="3" id="anc3"></a><span class="line-modified">207   inline bool is_real(jobject h);</span>


208 
209   int allocate_metadata_index(Metadata* oop) {
210     return _metadata.allocate_index(oop);
211   }
212   virtual int find_index(Metadata* h) {
213     return _metadata.find_index(h);
214   }
215   Metadata* metadata_at(int index) {
216     return _metadata.at(index);
217   }
218   int metadata_size() {
219     return _metadata.size();
220   }
221   int metadata_count() {
222     return _metadata.count();
223   }
<a name="4" id="anc4"></a><span class="line-modified">224   inline bool is_real(Metadata* h);</span>


225 
226   bool is_unused() {
227     return _oops.is_unused() &amp;&amp; _metadata.is_unused();
228   }
229 
230   void freeze() {
231     _oops.size();
232     _metadata.size();
233   }
234 
235   void copy_values_to(nmethod* nm) {
236     if (!_oops.is_unused()) {
237       _oops.copy_values_to(nm);
238     }
239     if (!_metadata.is_unused()) {
240       _metadata.copy_values_to(nm);
241     }
242   }
243 
244 #ifdef ASSERT
245   bool is_complete() {
246     assert(_oops.is_complete() == _metadata.is_complete(), &quot;must agree&quot;);
247     return _oops.is_complete();
248   }
249 #endif
250 };
251 
252 
253 #endif // SHARE_CODE_OOPRECORDER_HPP
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
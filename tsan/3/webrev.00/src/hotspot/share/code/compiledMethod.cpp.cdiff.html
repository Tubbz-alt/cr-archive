<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/code/compiledMethod.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compiledIC.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compiledMethod.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/compiledMethod.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,24 ***</span>
<span class="line-new-header">--- 23,29 ---</span>
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;code/compiledIC.hpp&quot;
  #include &quot;code/compiledMethod.inline.hpp&quot;
<span class="line-added">+ #include &quot;code/exceptionHandlerTable.hpp&quot;</span>
  #include &quot;code/scopeDesc.hpp&quot;
  #include &quot;code/codeCache.hpp&quot;
  #include &quot;code/icBuffer.hpp&quot;
  #include &quot;gc/shared/barrierSet.hpp&quot;
<span class="line-added">+ #include &quot;gc/shared/barrierSetNMethod.hpp&quot;</span>
  #include &quot;gc/shared/gcBehaviours.hpp&quot;
  #include &quot;interpreter/bytecode.inline.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logTag.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;oops/methodData.hpp&quot;
  #include &quot;oops/method.inline.hpp&quot;
  #include &quot;prims/methodHandles.hpp&quot;
<span class="line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-added">+ #include &quot;runtime/deoptimization.hpp&quot;</span>
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/mutexLocker.hpp&quot;
<span class="line-added">+ #include &quot;runtime/sharedRuntime.hpp&quot;</span>
  
  CompiledMethod::CompiledMethod(Method* method, const char* name, CompilerType type, const CodeBlobLayout&amp; layout,
                                 int frame_complete_offset, int frame_size, ImmutableOopMapSet* oop_maps,
                                 bool caller_must_gc_arguments)
    : CodeBlob(name, type, layout, frame_complete_offset, frame_size, oop_maps, caller_must_gc_arguments),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 98,14 ***</span>
      fatal(&quot;unexpected method state: %d&quot;, state);
      return NULL;
    }
  }
  
  //-----------------------------------------------------------------------------
  
  ExceptionCache* CompiledMethod::exception_cache_acquire() const {
<span class="line-modified">!   return OrderAccess::load_acquire(&amp;_exception_cache);</span>
  }
  
  void CompiledMethod::add_exception_cache_entry(ExceptionCache* new_entry) {
    assert(ExceptionCache_lock-&gt;owned_by_self(),&quot;Must hold the ExceptionCache_lock&quot;);
    assert(new_entry != NULL,&quot;Must be non null&quot;);
<span class="line-new-header">--- 103,21 ---</span>
      fatal(&quot;unexpected method state: %d&quot;, state);
      return NULL;
    }
  }
  
<span class="line-added">+ //-----------------------------------------------------------------------------</span>
<span class="line-added">+ void CompiledMethod::mark_for_deoptimization(bool inc_recompile_counts) {</span>
<span class="line-added">+   MutexLocker ml(CompiledMethod_lock-&gt;owned_by_self() ? NULL : CompiledMethod_lock,</span>
<span class="line-added">+                  Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">+   _mark_for_deoptimization_status = (inc_recompile_counts ? deoptimize : deoptimize_noupdate);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  //-----------------------------------------------------------------------------
  
  ExceptionCache* CompiledMethod::exception_cache_acquire() const {
<span class="line-modified">!   return Atomic::load_acquire(&amp;_exception_cache);</span>
  }
  
  void CompiledMethod::add_exception_cache_entry(ExceptionCache* new_entry) {
    assert(ExceptionCache_lock-&gt;owned_by_self(),&quot;Must hold the ExceptionCache_lock&quot;);
    assert(new_entry != NULL,&quot;Must be non null&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 121,21 ***</span>
          // with concurrent ExceptionCache cleanup. Therefore, the inserts roll
          // the head pointer forward to the first live ExceptionCache, so that the new
          // next pointers always point at live ExceptionCaches, that are not removed due
          // to concurrent ExceptionCache cleanup.
          ExceptionCache* next = ec-&gt;next();
<span class="line-modified">!         if (Atomic::cmpxchg(next, &amp;_exception_cache, ec) == ec) {</span>
            CodeCache::release_exception_cache(ec);
          }
          continue;
        }
        ec = exception_cache();
        if (ec != NULL) {
          new_entry-&gt;set_next(ec);
        }
      }
<span class="line-modified">!     if (Atomic::cmpxchg(new_entry, &amp;_exception_cache, ec) == ec) {</span>
        return;
      }
    }
  }
  
<span class="line-new-header">--- 133,21 ---</span>
          // with concurrent ExceptionCache cleanup. Therefore, the inserts roll
          // the head pointer forward to the first live ExceptionCache, so that the new
          // next pointers always point at live ExceptionCaches, that are not removed due
          // to concurrent ExceptionCache cleanup.
          ExceptionCache* next = ec-&gt;next();
<span class="line-modified">!         if (Atomic::cmpxchg(&amp;_exception_cache, ec, next) == ec) {</span>
            CodeCache::release_exception_cache(ec);
          }
          continue;
        }
        ec = exception_cache();
        if (ec != NULL) {
          new_entry-&gt;set_next(ec);
        }
      }
<span class="line-modified">!     if (Atomic::cmpxchg(&amp;_exception_cache, ec, new_entry) == ec) {</span>
        return;
      }
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 164,11 ***</span>
      if (!curr-&gt;exception_type()-&gt;is_loader_alive()) {
        if (prev == NULL) {
          // Try to clean head; this is contended by concurrent inserts, that
          // both lazily clean the head, and insert entries at the head. If
          // the CAS fails, the operation is restarted.
<span class="line-modified">!         if (Atomic::cmpxchg(next, &amp;_exception_cache, curr) != curr) {</span>
            prev = NULL;
            curr = exception_cache_acquire();
            continue;
          }
        } else {
<span class="line-new-header">--- 176,11 ---</span>
      if (!curr-&gt;exception_type()-&gt;is_loader_alive()) {
        if (prev == NULL) {
          // Try to clean head; this is contended by concurrent inserts, that
          // both lazily clean the head, and insert entries at the head. If
          // the CAS fails, the operation is restarted.
<span class="line-modified">!         if (Atomic::cmpxchg(&amp;_exception_cache, curr, next) != curr) {</span>
            prev = NULL;
            curr = exception_cache_acquire();
            continue;
          }
        } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 343,11 ***</span>
  // called with a frame corresponding to a Java invoke
  void CompiledMethod::preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, OopClosure* f) {
    if (method() != NULL &amp;&amp; !method()-&gt;is_native()) {
      address pc = fr.pc();
      SimpleScopeDesc ssd(this, pc);
<span class="line-modified">!     Bytecode_invoke call(ssd.method(), ssd.bci());</span>
      bool has_receiver = call.has_receiver();
      bool has_appendix = call.has_appendix();
      Symbol* signature = call.signature();
  
      // The method attached by JIT-compilers should be used, if present.
<span class="line-new-header">--- 355,11 ---</span>
  // called with a frame corresponding to a Java invoke
  void CompiledMethod::preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, OopClosure* f) {
    if (method() != NULL &amp;&amp; !method()-&gt;is_native()) {
      address pc = fr.pc();
      SimpleScopeDesc ssd(this, pc);
<span class="line-modified">!     Bytecode_invoke call(methodHandle(Thread::current(), ssd.method()), ssd.bci());</span>
      bool has_receiver = call.has_receiver();
      bool has_appendix = call.has_appendix();
      Symbol* signature = call.signature();
  
      // The method attached by JIT-compilers should be used, if present.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 413,24 ***</span>
    }
  }
  
  #ifdef ASSERT
  // Check class_loader is alive for this bit of metadata.
<span class="line-modified">! static void check_class(Metadata* md) {</span>
<span class="line-modified">!    Klass* klass = NULL;</span>
<span class="line-modified">!    if (md-&gt;is_klass()) {</span>
<span class="line-modified">!      klass = ((Klass*)md);</span>
<span class="line-modified">!    } else if (md-&gt;is_method()) {</span>
<span class="line-modified">!      klass = ((Method*)md)-&gt;method_holder();</span>
<span class="line-modified">!    } else if (md-&gt;is_methodData()) {</span>
<span class="line-modified">!      klass = ((MethodData*)md)-&gt;method()-&gt;method_holder();</span>
<span class="line-modified">!    } else {</span>
<span class="line-modified">!      md-&gt;print();</span>
<span class="line-modified">!      ShouldNotReachHere();</span>
<span class="line-modified">!    }</span>
<span class="line-modified">!    assert(klass-&gt;is_loader_alive(), &quot;must be alive&quot;);</span>
<span class="line-modified">! }</span>
  #endif // ASSERT
  
  
  bool CompiledMethod::clean_ic_if_metadata_is_dead(CompiledIC *ic) {
    if (ic-&gt;is_clean()) {
<span class="line-new-header">--- 425,26 ---</span>
    }
  }
  
  #ifdef ASSERT
  // Check class_loader is alive for this bit of metadata.
<span class="line-modified">! class CheckClass : public MetadataClosure {</span>
<span class="line-modified">!   void do_metadata(Metadata* md) {</span>
<span class="line-modified">!     Klass* klass = NULL;</span>
<span class="line-modified">!     if (md-&gt;is_klass()) {</span>
<span class="line-modified">!       klass = ((Klass*)md);</span>
<span class="line-modified">!     } else if (md-&gt;is_method()) {</span>
<span class="line-modified">!       klass = ((Method*)md)-&gt;method_holder();</span>
<span class="line-modified">!     } else if (md-&gt;is_methodData()) {</span>
<span class="line-modified">!       klass = ((MethodData*)md)-&gt;method()-&gt;method_holder();</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       md-&gt;print();</span>
<span class="line-modified">!       ShouldNotReachHere();</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     assert(klass-&gt;is_loader_alive(), &quot;must be alive&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
  #endif // ASSERT
  
  
  bool CompiledMethod::clean_ic_if_metadata_is_dead(CompiledIC *ic) {
    if (ic-&gt;is_clean()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 464,54 ***</span>
    }
  
    return ic-&gt;set_to_clean();
  }
  
<span class="line-removed">- // static_stub_Relocations may have dangling references to</span>
<span class="line-removed">- // nmethods so trim them out here.  Otherwise it looks like</span>
<span class="line-removed">- // compiled code is maintaining a link to dead metadata.</span>
<span class="line-removed">- void CompiledMethod::clean_ic_stubs() {</span>
<span class="line-removed">- #ifdef ASSERT</span>
<span class="line-removed">-   address low_boundary = oops_reloc_begin();</span>
<span class="line-removed">-   RelocIterator iter(this, low_boundary);</span>
<span class="line-removed">-   while (iter.next()) {</span>
<span class="line-removed">-     address static_call_addr = NULL;</span>
<span class="line-removed">-     if (iter.type() == relocInfo::opt_virtual_call_type) {</span>
<span class="line-removed">-       CompiledIC* cic = CompiledIC_at(&amp;iter);</span>
<span class="line-removed">-       if (!cic-&gt;is_call_to_interpreted()) {</span>
<span class="line-removed">-         static_call_addr = iter.addr();</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     } else if (iter.type() == relocInfo::static_call_type) {</span>
<span class="line-removed">-       CompiledStaticCall* csc = compiledStaticCall_at(iter.reloc());</span>
<span class="line-removed">-       if (!csc-&gt;is_call_to_interpreted()) {</span>
<span class="line-removed">-         static_call_addr = iter.addr();</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (static_call_addr != NULL) {</span>
<span class="line-removed">-       RelocIterator sciter(this, low_boundary);</span>
<span class="line-removed">-       while (sciter.next()) {</span>
<span class="line-removed">-         if (sciter.type() == relocInfo::static_stub_type &amp;&amp;</span>
<span class="line-removed">-             sciter.static_stub_reloc()-&gt;static_call() == static_call_addr) {</span>
<span class="line-removed">-           sciter.static_stub_reloc()-&gt;clear_inline_cache();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  // Clean references to unloaded nmethods at addr from this one, which is not unloaded.
  template &lt;class CompiledICorStaticCall&gt;
  static bool clean_if_nmethod_is_unloaded(CompiledICorStaticCall *ic, address addr, CompiledMethod* from,
                                           bool clean_all) {
    // Ok, to lookup references to zombies here
    CodeBlob *cb = CodeCache::find_blob_unsafe(addr);
    CompiledMethod* nm = (cb != NULL) ? cb-&gt;as_compiled_method_or_null() : NULL;
    if (nm != NULL) {
      // Clean inline caches pointing to both zombie and not_entrant methods
      if (clean_all || !nm-&gt;is_in_use() || nm-&gt;is_unloading() || (nm-&gt;method()-&gt;code() != nm)) {
<span class="line-modified">!       if (!ic-&gt;set_to_clean(from-&gt;is_alive())) {</span>
          return false;
        }
        assert(ic-&gt;is_clean(), &quot;nmethod &quot; PTR_FORMAT &quot;not clean %s&quot;, p2i(from), from-&gt;method()-&gt;name_and_sig_as_C_string());
      }
    }
<span class="line-new-header">--- 478,34 ---</span>
    }
  
    return ic-&gt;set_to_clean();
  }
  
  // Clean references to unloaded nmethods at addr from this one, which is not unloaded.
  template &lt;class CompiledICorStaticCall&gt;
  static bool clean_if_nmethod_is_unloaded(CompiledICorStaticCall *ic, address addr, CompiledMethod* from,
                                           bool clean_all) {
    // Ok, to lookup references to zombies here
    CodeBlob *cb = CodeCache::find_blob_unsafe(addr);
    CompiledMethod* nm = (cb != NULL) ? cb-&gt;as_compiled_method_or_null() : NULL;
    if (nm != NULL) {
      // Clean inline caches pointing to both zombie and not_entrant methods
      if (clean_all || !nm-&gt;is_in_use() || nm-&gt;is_unloading() || (nm-&gt;method()-&gt;code() != nm)) {
<span class="line-modified">!       // Inline cache cleaning should only be initiated on CompiledMethods that have been</span>
<span class="line-added">+       // observed to be is_alive(). However, with concurrent code cache unloading, it is</span>
<span class="line-added">+       // possible that by now, the state has been racingly flipped to unloaded if the nmethod</span>
<span class="line-added">+       // being cleaned is_unloading(). This is fine, because if that happens, then the inline</span>
<span class="line-added">+       // caches have already been cleaned under the same CompiledICLocker that we now hold during</span>
<span class="line-added">+       // inline cache cleaning, and we will simply walk the inline caches again, and likely not</span>
<span class="line-added">+       // find much of interest to clean. However, this race prevents us from asserting that the</span>
<span class="line-added">+       // nmethod is_alive(). The is_unloading() function is completely monotonic; once set due</span>
<span class="line-added">+       // to an oop dying, it remains set forever until freed. Because of that, all unloaded</span>
<span class="line-added">+       // nmethods are is_unloading(), but notably, an unloaded nmethod may also subsequently</span>
<span class="line-added">+       // become zombie (when the sweeper converts it to zombie). Therefore, the most precise</span>
<span class="line-added">+       // sanity check we can check for in this context is to not allow zombies.</span>
<span class="line-added">+       assert(!from-&gt;is_zombie(), &quot;should not clean inline caches on zombies&quot;);</span>
<span class="line-added">+       if (!ic-&gt;set_to_clean(!from-&gt;is_unloading())) {</span>
          return false;
        }
        assert(ic-&gt;is_clean(), &quot;nmethod &quot; PTR_FORMAT &quot;not clean %s&quot;, p2i(from), from-&gt;method()-&gt;name_and_sig_as_C_string());
      }
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 545,26 ***</span>
  
    if (!cleanup_inline_caches_impl(unloading_occurred, false)) {
      return false;
    }
  
<span class="line-modified">!   // All static stubs need to be cleaned.</span>
<span class="line-removed">-   clean_ic_stubs();</span>
<span class="line-removed">- </span>
    // Check that the metadata embedded in the nmethod is alive
<span class="line-modified">!   DEBUG_ONLY(metadata_do(check_class));</span>
    return true;
  }
  
  void CompiledMethod::cleanup_inline_caches(bool clean_all) {
    for (;;) {
      ICRefillVerifier ic_refill_verifier;
      { CompiledICLocker ic_locker(this);
        if (cleanup_inline_caches_impl(false, clean_all)) {
          return;
        }
      }
      InlineCacheBuffer::refill_ic_stubs();
    }
  }
  
  // Called to clean up after class unloading for live nmethods and from the sweeper
<span class="line-new-header">--- 539,43 ---</span>
  
    if (!cleanup_inline_caches_impl(unloading_occurred, false)) {
      return false;
    }
  
<span class="line-modified">! #ifdef ASSERT</span>
    // Check that the metadata embedded in the nmethod is alive
<span class="line-modified">!   CheckClass check_class;</span>
<span class="line-added">+   metadata_do(&amp;check_class);</span>
<span class="line-added">+ #endif</span>
    return true;
  }
  
<span class="line-added">+ void CompiledMethod::run_nmethod_entry_barrier() {</span>
<span class="line-added">+   BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()-&gt;barrier_set_nmethod();</span>
<span class="line-added">+   if (bs_nm != NULL) {</span>
<span class="line-added">+     // We want to keep an invariant that nmethods found through iterations of a Thread&#39;s</span>
<span class="line-added">+     // nmethods found in safepoints have gone through an entry barrier and are not armed.</span>
<span class="line-added">+     // By calling this nmethod entry barrier, it plays along and acts</span>
<span class="line-added">+     // like any other nmethod found on the stack of a thread (fewer surprises).</span>
<span class="line-added">+     nmethod* nm = as_nmethod_or_null();</span>
<span class="line-added">+     if (nm != NULL) {</span>
<span class="line-added">+       bool alive = bs_nm-&gt;nmethod_entry_barrier(nm);</span>
<span class="line-added">+       assert(alive, &quot;should be alive&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void CompiledMethod::cleanup_inline_caches(bool clean_all) {
    for (;;) {
      ICRefillVerifier ic_refill_verifier;
      { CompiledICLocker ic_locker(this);
        if (cleanup_inline_caches_impl(false, clean_all)) {
          return;
        }
      }
<span class="line-added">+     // Call this nmethod entry barrier from the sweeper.</span>
<span class="line-added">+     run_nmethod_entry_barrier();</span>
      InlineCacheBuffer::refill_ic_stubs();
    }
  }
  
  // Called to clean up after class unloading for live nmethods and from the sweeper
</pre>
<hr />
<pre>
<span class="line-old-header">*** 574,10 ***</span>
<span class="line-new-header">--- 585,11 ---</span>
    ResourceMark rm;
  
    // Find all calls in an nmethod and clear the ones that point to non-entrant,
    // zombie and unloaded nmethods.
    RelocIterator iter(this, oops_reloc_begin());
<span class="line-added">+   bool is_in_static_stub = false;</span>
    while(iter.next()) {
  
      switch (iter.type()) {
  
      case relocInfo::virtual_call_type:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 604,10 ***</span>
<span class="line-new-header">--- 616,49 ---</span>
        if (!clean_if_nmethod_is_unloaded(compiledStaticCall_at(iter.reloc()), this, clean_all)) {
          return false;
        }
        break;
  
<span class="line-added">+     case relocInfo::static_stub_type: {</span>
<span class="line-added">+       is_in_static_stub = true;</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     case relocInfo::metadata_type: {</span>
<span class="line-added">+       // Only the metadata relocations contained in static/opt virtual call stubs</span>
<span class="line-added">+       // contains the Method* passed to c2i adapters. It is the only metadata</span>
<span class="line-added">+       // relocation that needs to be walked, as it is the one metadata relocation</span>
<span class="line-added">+       // that violates the invariant that all metadata relocations have an oop</span>
<span class="line-added">+       // in the compiled method (due to deferred resolution and code patching).</span>
<span class="line-added">+ </span>
<span class="line-added">+       // This causes dead metadata to remain in compiled methods that are not</span>
<span class="line-added">+       // unloading. Unless these slippery metadata relocations of the static</span>
<span class="line-added">+       // stubs are at least cleared, subsequent class redefinition operations</span>
<span class="line-added">+       // will access potentially free memory, and JavaThread execution</span>
<span class="line-added">+       // concurrent to class unloading may call c2i adapters with dead methods.</span>
<span class="line-added">+       if (!is_in_static_stub) {</span>
<span class="line-added">+         // The first metadata relocation after a static stub relocation is the</span>
<span class="line-added">+         // metadata relocation of the static stub used to pass the Method* to</span>
<span class="line-added">+         // c2i adapters.</span>
<span class="line-added">+         continue;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       is_in_static_stub = false;</span>
<span class="line-added">+       metadata_Relocation* r = iter.metadata_reloc();</span>
<span class="line-added">+       Metadata* md = r-&gt;metadata_value();</span>
<span class="line-added">+       if (md != NULL &amp;&amp; md-&gt;is_method()) {</span>
<span class="line-added">+         Method* method = static_cast&lt;Method*&gt;(md);</span>
<span class="line-added">+         if (!method-&gt;method_holder()-&gt;is_loader_alive()) {</span>
<span class="line-added">+           Atomic::store(r-&gt;metadata_addr(), (Method*)NULL);</span>
<span class="line-added">+ </span>
<span class="line-added">+           if (!r-&gt;metadata_is_immediate()) {</span>
<span class="line-added">+             r-&gt;fix_metadata_relocation();</span>
<span class="line-added">+           }</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      default:
        break;
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 626,5 ***</span>
<span class="line-new-header">--- 677,77 ---</span>
           !nm-&gt;is_zombie() &amp;&amp; !nm-&gt;is_not_installed() &amp;&amp;
           os::is_readable_pointer(method) &amp;&amp;
           os::is_readable_pointer(method-&gt;constants()) &amp;&amp;
           os::is_readable_pointer(method-&gt;signature());
  }
<span class="line-added">+ </span>
<span class="line-added">+ address CompiledMethod::continuation_for_implicit_exception(address pc, bool for_div0_check) {</span>
<span class="line-added">+   // Exception happened outside inline-cache check code =&gt; we are inside</span>
<span class="line-added">+   // an active nmethod =&gt; use cpc to determine a return address</span>
<span class="line-added">+   int exception_offset = pc - code_begin();</span>
<span class="line-added">+   int cont_offset = ImplicitExceptionTable(this).continuation_offset( exception_offset );</span>
<span class="line-added">+ #ifdef ASSERT</span>
<span class="line-added">+   if (cont_offset == 0) {</span>
<span class="line-added">+     Thread* thread = Thread::current();</span>
<span class="line-added">+     ResetNoHandleMark rnm; // Might be called from LEAF/QUICK ENTRY</span>
<span class="line-added">+     HandleMark hm(thread);</span>
<span class="line-added">+     ResourceMark rm(thread);</span>
<span class="line-added">+     CodeBlob* cb = CodeCache::find_blob(pc);</span>
<span class="line-added">+     assert(cb != NULL &amp;&amp; cb == this, &quot;&quot;);</span>
<span class="line-added">+     ttyLocker ttyl;</span>
<span class="line-added">+     tty-&gt;print_cr(&quot;implicit exception happened at &quot; INTPTR_FORMAT, p2i(pc));</span>
<span class="line-added">+     print();</span>
<span class="line-added">+     method()-&gt;print_codes();</span>
<span class="line-added">+     print_code();</span>
<span class="line-added">+     print_pcs();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+   if (cont_offset == 0) {</span>
<span class="line-added">+     // Let the normal error handling report the exception</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (cont_offset == exception_offset) {</span>
<span class="line-added">+ #if INCLUDE_JVMCI</span>
<span class="line-added">+     Deoptimization::DeoptReason deopt_reason = for_div0_check ? Deoptimization::Reason_div0_check : Deoptimization::Reason_null_check;</span>
<span class="line-added">+     JavaThread *thread = JavaThread::current();</span>
<span class="line-added">+     thread-&gt;set_jvmci_implicit_exception_pc(pc);</span>
<span class="line-added">+     thread-&gt;set_pending_deoptimization(Deoptimization::make_trap_request(deopt_reason,</span>
<span class="line-added">+                                                                          Deoptimization::Action_reinterpret));</span>
<span class="line-added">+     return (SharedRuntime::deopt_blob()-&gt;implicit_exception_uncommon_trap());</span>
<span class="line-added">+ #else</span>
<span class="line-added">+     ShouldNotReachHere();</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return code_begin() + cont_offset;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ class HasEvolDependency : public MetadataClosure {</span>
<span class="line-added">+   bool _has_evol_dependency;</span>
<span class="line-added">+  public:</span>
<span class="line-added">+   HasEvolDependency() : _has_evol_dependency(false) {}</span>
<span class="line-added">+   void do_metadata(Metadata* md) {</span>
<span class="line-added">+     if (md-&gt;is_method()) {</span>
<span class="line-added">+       Method* method = (Method*)md;</span>
<span class="line-added">+       if (method-&gt;is_old()) {</span>
<span class="line-added">+         _has_evol_dependency = true;</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+   bool has_evol_dependency() const { return _has_evol_dependency; }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool CompiledMethod::has_evol_metadata() {</span>
<span class="line-added">+   // Check the metadata in relocIter and CompiledIC and also deoptimize</span>
<span class="line-added">+   // any nmethod that has reference to old methods.</span>
<span class="line-added">+   HasEvolDependency check_evol;</span>
<span class="line-added">+   metadata_do(&amp;check_evol);</span>
<span class="line-added">+   if (check_evol.has_evol_dependency() &amp;&amp; log_is_enabled(Debug, redefine, class, nmethod)) {</span>
<span class="line-added">+     ResourceMark rm;</span>
<span class="line-added">+     log_debug(redefine, class, nmethod)</span>
<span class="line-added">+             (&quot;Found evol dependency of nmethod %s.%s(%s) compile_id=%d on in nmethod metadata&quot;,</span>
<span class="line-added">+              _method-&gt;method_holder()-&gt;external_name(),</span>
<span class="line-added">+              _method-&gt;name()-&gt;as_C_string(),</span>
<span class="line-added">+              _method-&gt;signature()-&gt;as_C_string(),</span>
<span class="line-added">+              compile_id());</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return check_evol.has_evol_dependency();</span>
<span class="line-added">+ }</span>
</pre>
<center><a href="compiledIC.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compiledMethod.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
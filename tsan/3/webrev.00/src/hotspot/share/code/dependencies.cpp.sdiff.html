<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/code/dependencies.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="debugInfo.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="dependencies.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/dependencies.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
  91   assert_common_1(leaf_type, ctxk);
  92 }
  93 
  94 void Dependencies::assert_abstract_with_unique_concrete_subtype(ciKlass* ctxk, ciKlass* conck) {
  95   check_ctxk_abstract(ctxk);
  96   assert_common_2(abstract_with_unique_concrete_subtype, ctxk, conck);
  97 }
  98 
  99 void Dependencies::assert_abstract_with_no_concrete_subtype(ciKlass* ctxk) {
 100   check_ctxk_abstract(ctxk);
 101   assert_common_1(abstract_with_no_concrete_subtype, ctxk);
 102 }
 103 
 104 void Dependencies::assert_concrete_with_no_concrete_subtype(ciKlass* ctxk) {
 105   check_ctxk_concrete(ctxk);
 106   assert_common_1(concrete_with_no_concrete_subtype, ctxk);
 107 }
 108 
 109 void Dependencies::assert_unique_concrete_method(ciKlass* ctxk, ciMethod* uniqm) {
 110   check_ctxk(ctxk);

 111   assert_common_2(unique_concrete_method, ctxk, uniqm);
 112 }
 113 
 114 void Dependencies::assert_abstract_with_exclusive_concrete_subtypes(ciKlass* ctxk, ciKlass* k1, ciKlass* k2) {
 115   check_ctxk(ctxk);
 116   assert_common_3(abstract_with_exclusive_concrete_subtypes_2, ctxk, k1, k2);
 117 }
 118 
 119 void Dependencies::assert_exclusive_concrete_methods(ciKlass* ctxk, ciMethod* m1, ciMethod* m2) {
 120   check_ctxk(ctxk);
 121   assert_common_3(exclusive_concrete_methods_2, ctxk, m1, m2);
 122 }
 123 
 124 void Dependencies::assert_has_no_finalizable_subclasses(ciKlass* ctxk) {
 125   check_ctxk(ctxk);
 126   assert_common_1(no_finalizable_subclasses, ctxk);
 127 }
 128 
 129 void Dependencies::assert_call_site_target_value(ciCallSite* call_site, ciMethodHandle* method_handle) {
 130   assert_common_2(call_site_target_value, call_site, method_handle);
</pre>
<hr />
<pre>
 163     // Note that this cannot be done with assertions that
 164     // relate to concreteness or abstractness.
 165     BasicType elemt = ArrayKlass::cast(ctxk)-&gt;element_type();
 166     if (is_java_primitive(elemt))  return;   // Ex:  int[][]
 167     ctxk = ObjArrayKlass::cast(ctxk)-&gt;bottom_klass();
 168     //if (ctxk-&gt;is_final())  return;            // Ex:  String[][]
 169   }
 170   check_ctxk(ctxk);
 171   assert_common_1(leaf_type, DepValue(_oop_recorder, ctxk));
 172 }
 173 
 174 void Dependencies::assert_abstract_with_unique_concrete_subtype(Klass* ctxk, Klass* conck) {
 175   check_ctxk_abstract(ctxk);
 176   DepValue ctxk_dv(_oop_recorder, ctxk);
 177   DepValue conck_dv(_oop_recorder, conck, &amp;ctxk_dv);
 178   assert_common_2(abstract_with_unique_concrete_subtype, ctxk_dv, conck_dv);
 179 }
 180 
 181 void Dependencies::assert_unique_concrete_method(Klass* ctxk, Method* uniqm) {
 182   check_ctxk(ctxk);

 183   assert_common_2(unique_concrete_method, DepValue(_oop_recorder, ctxk), DepValue(_oop_recorder, uniqm));
 184 }
 185 
 186 void Dependencies::assert_call_site_target_value(oop call_site, oop method_handle) {
 187   assert_common_2(call_site_target_value, DepValue(_oop_recorder, JNIHandles::make_local(call_site)), DepValue(_oop_recorder, JNIHandles::make_local(method_handle)));
 188 }
 189 
 190 #endif // INCLUDE_JVMCI
 191 
 192 
 193 // Helper function.  If we are adding a new dep. under ctxk2,
 194 // try to find an old dep. under a broader* ctxk1.  If there is
 195 //
 196 bool Dependencies::maybe_merge_ctxk(GrowableArray&lt;ciBaseObject*&gt;* deps,
 197                                     int ctxk_i, ciKlass* ctxk2) {
 198   ciKlass* ctxk1 = deps-&gt;at(ctxk_i)-&gt;as_metadata()-&gt;as_klass();
 199   if (ctxk2-&gt;is_subtype_of(ctxk1)) {
 200     return true;  // success, and no need to change
 201   } else if (ctxk1-&gt;is_subtype_of(ctxk2)) {
 202     // new context class fully subsumes previous one
</pre>
<hr />
<pre>
 608   3, // unique_concrete_subtypes_2 ctxk, k1, k2
 609   3, // unique_concrete_methods_2 ctxk, m1, m2
 610   1, // no_finalizable_subclasses ctxk
 611   2  // call_site_target_value call_site, method_handle
 612 };
 613 
 614 const char* Dependencies::dep_name(Dependencies::DepType dept) {
 615   if (!dept_in_mask(dept, all_types))  return &quot;?bad-dep?&quot;;
 616   return _dep_name[dept];
 617 }
 618 
 619 int Dependencies::dep_args(Dependencies::DepType dept) {
 620   if (!dept_in_mask(dept, all_types))  return -1;
 621   return _dep_args[dept];
 622 }
 623 
 624 void Dependencies::check_valid_dependency_type(DepType dept) {
 625   guarantee(FIRST_TYPE &lt;= dept &amp;&amp; dept &lt; TYPE_LIMIT, &quot;invalid dependency type: %d&quot;, (int) dept);
 626 }
 627 
<span class="line-modified"> 628 Dependencies::DepType Dependencies::validate_dependencies(CompileTask* task, bool counter_changed, char** failure_detail) {</span>
<span class="line-removed"> 629   // First, check non-klass dependencies as we might return early and</span>
<span class="line-removed"> 630   // not check klass dependencies if the system dictionary</span>
<span class="line-removed"> 631   // modification counter hasn&#39;t changed (see below).</span>
<span class="line-removed"> 632   for (Dependencies::DepStream deps(this); deps.next(); ) {</span>
<span class="line-removed"> 633     if (deps.is_klass_type())  continue;  // skip klass dependencies</span>
<span class="line-removed"> 634     Klass* witness = deps.check_dependency();</span>
<span class="line-removed"> 635     if (witness != NULL) {</span>
<span class="line-removed"> 636       return deps.type();</span>
<span class="line-removed"> 637     }</span>
<span class="line-removed"> 638   }</span>
<span class="line-removed"> 639 </span>
<span class="line-removed"> 640   // Klass dependencies must be checked when the system dictionary</span>
<span class="line-removed"> 641   // changes.  If logging is enabled all violated dependences will be</span>
<span class="line-removed"> 642   // recorded in the log.  In debug mode check dependencies even if</span>
<span class="line-removed"> 643   // the system dictionary hasn&#39;t changed to verify that no invalid</span>
<span class="line-removed"> 644   // dependencies were inserted.  Any violated dependences in this</span>
<span class="line-removed"> 645   // case are dumped to the tty.</span>
<span class="line-removed"> 646   if (!counter_changed &amp;&amp; !trueInDebug) {</span>
<span class="line-removed"> 647     return end_marker;</span>
<span class="line-removed"> 648   }</span>
<span class="line-removed"> 649 </span>
 650   int klass_violations = 0;
 651   DepType result = end_marker;
 652   for (Dependencies::DepStream deps(this); deps.next(); ) {
<span class="line-removed"> 653     if (!deps.is_klass_type())  continue;  // skip non-klass dependencies</span>
 654     Klass* witness = deps.check_dependency();
 655     if (witness != NULL) {
 656       if (klass_violations == 0) {
 657         result = deps.type();
 658         if (failure_detail != NULL &amp;&amp; klass_violations == 0) {
 659           // Use a fixed size buffer to prevent the string stream from
 660           // resizing in the context of an inner resource mark.
 661           char* buffer = NEW_RESOURCE_ARRAY(char, O_BUFLEN);
 662           stringStream st(buffer, O_BUFLEN);
 663           deps.print_dependency(witness, true, &amp;st);
 664           *failure_detail = st.as_string();
 665         }
 666       }
 667       klass_violations++;
<span class="line-modified"> 668       if (!counter_changed) {</span>
<span class="line-removed"> 669         // Dependence failed but counter didn&#39;t change.  Log a message</span>
<span class="line-removed"> 670         // describing what failed and allow the assert at the end to</span>
<span class="line-removed"> 671         // trigger.</span>
<span class="line-removed"> 672         deps.print_dependency(witness);</span>
<span class="line-removed"> 673       } else if (xtty == NULL) {</span>
 674         // If we&#39;re not logging then a single violation is sufficient,
 675         // otherwise we want to log all the dependences which were
 676         // violated.
 677         break;
 678       }
 679     }
 680   }
 681 
<span class="line-removed"> 682   if (klass_violations != 0) {</span>
<span class="line-removed"> 683 #ifdef ASSERT</span>
<span class="line-removed"> 684     if (task != NULL &amp;&amp; !counter_changed &amp;&amp; !PrintCompilation) {</span>
<span class="line-removed"> 685       // Print out the compile task that failed</span>
<span class="line-removed"> 686       task-&gt;print_tty();</span>
<span class="line-removed"> 687     }</span>
<span class="line-removed"> 688 #endif</span>
<span class="line-removed"> 689     assert(counter_changed, &quot;failed dependencies, but counter didn&#39;t change&quot;);</span>
<span class="line-removed"> 690   }</span>
 691   return result;
 692 }
 693 
 694 // for the sake of the compiler log, print out current dependencies:
 695 void Dependencies::log_all_dependencies() {
 696   if (log() == NULL)  return;
 697   ResourceMark rm;
 698   for (int deptv = (int)FIRST_TYPE; deptv &lt; (int)TYPE_LIMIT; deptv++) {
 699     DepType dept = (DepType)deptv;
 700     GrowableArray&lt;ciBaseObject*&gt;* deps = _deps[dept];
 701     int deplen = deps-&gt;length();
 702     if (deplen == 0) {
 703       continue;
 704     }
 705     int stride = dep_args(dept);
 706     GrowableArray&lt;ciBaseObject*&gt;* ciargs = new GrowableArray&lt;ciBaseObject*&gt;(stride);
 707     for (int i = 0; i &lt; deps-&gt;length(); i += stride) {
 708       for (int j = 0; j &lt; stride; j++) {
 709         // flush out the identities before printing
 710         ciargs-&gt;push(deps-&gt;at(i+j));
</pre>
<hr />
<pre>
1830   ClassHierarchyWalker wf(m1);
1831   wf.add_participant(m1-&gt;method_holder());
1832   wf.add_participant(m2-&gt;method_holder());
1833   return wf.find_witness_definer(ctxk, changes);
1834 }
1835 
1836 Klass* Dependencies::check_has_no_finalizable_subclasses(Klass* ctxk, KlassDepChange* changes) {
1837   Klass* search_at = ctxk;
1838   if (changes != NULL)
1839     search_at = changes-&gt;new_type(); // just look at the new bit
1840   return find_finalizable_subclass(search_at);
1841 }
1842 
1843 Klass* Dependencies::check_call_site_target_value(oop call_site, oop method_handle, CallSiteDepChange* changes) {
1844   assert(call_site != NULL, &quot;sanity&quot;);
1845   assert(method_handle != NULL, &quot;sanity&quot;);
1846   assert(call_site-&gt;is_a(SystemDictionary::CallSite_klass()),     &quot;sanity&quot;);
1847 
1848   if (changes == NULL) {
1849     // Validate all CallSites
<span class="line-modified">1850     if (!oopDesc::equals(java_lang_invoke_CallSite::target(call_site), method_handle))</span>
1851       return call_site-&gt;klass();  // assertion failed
1852   } else {
1853     // Validate the given CallSite
<span class="line-modified">1854     if (oopDesc::equals(call_site, changes-&gt;call_site()) &amp;&amp; !oopDesc::equals(java_lang_invoke_CallSite::target(call_site), changes-&gt;method_handle())) {</span>
<span class="line-modified">1855       assert(!oopDesc::equals(method_handle, changes-&gt;method_handle()), &quot;must be&quot;);</span>
1856       return call_site-&gt;klass();  // assertion failed
1857     }
1858   }
1859   return NULL;  // assertion still valid
1860 }
1861 
1862 void Dependencies::DepStream::trace_and_log_witness(Klass* witness) {
1863   if (witness != NULL) {
1864     if (TraceDependencies) {
1865       print_dependency(witness, /*verbose=*/ true);
1866     }
1867     // The following is a no-op unless logging is enabled:
1868     log_dependency(witness);
1869   }
1870 }
1871 
1872 
1873 Klass* Dependencies::DepStream::check_klass_dependency(KlassDepChange* changes) {
1874   assert_locked_or_safepoint(Compile_lock);
1875   Dependencies::check_valid_dependency_type(type());
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
  91   assert_common_1(leaf_type, ctxk);
  92 }
  93 
  94 void Dependencies::assert_abstract_with_unique_concrete_subtype(ciKlass* ctxk, ciKlass* conck) {
  95   check_ctxk_abstract(ctxk);
  96   assert_common_2(abstract_with_unique_concrete_subtype, ctxk, conck);
  97 }
  98 
  99 void Dependencies::assert_abstract_with_no_concrete_subtype(ciKlass* ctxk) {
 100   check_ctxk_abstract(ctxk);
 101   assert_common_1(abstract_with_no_concrete_subtype, ctxk);
 102 }
 103 
 104 void Dependencies::assert_concrete_with_no_concrete_subtype(ciKlass* ctxk) {
 105   check_ctxk_concrete(ctxk);
 106   assert_common_1(concrete_with_no_concrete_subtype, ctxk);
 107 }
 108 
 109 void Dependencies::assert_unique_concrete_method(ciKlass* ctxk, ciMethod* uniqm) {
 110   check_ctxk(ctxk);
<span class="line-added"> 111   check_unique_method(ctxk, uniqm);</span>
 112   assert_common_2(unique_concrete_method, ctxk, uniqm);
 113 }
 114 
 115 void Dependencies::assert_abstract_with_exclusive_concrete_subtypes(ciKlass* ctxk, ciKlass* k1, ciKlass* k2) {
 116   check_ctxk(ctxk);
 117   assert_common_3(abstract_with_exclusive_concrete_subtypes_2, ctxk, k1, k2);
 118 }
 119 
 120 void Dependencies::assert_exclusive_concrete_methods(ciKlass* ctxk, ciMethod* m1, ciMethod* m2) {
 121   check_ctxk(ctxk);
 122   assert_common_3(exclusive_concrete_methods_2, ctxk, m1, m2);
 123 }
 124 
 125 void Dependencies::assert_has_no_finalizable_subclasses(ciKlass* ctxk) {
 126   check_ctxk(ctxk);
 127   assert_common_1(no_finalizable_subclasses, ctxk);
 128 }
 129 
 130 void Dependencies::assert_call_site_target_value(ciCallSite* call_site, ciMethodHandle* method_handle) {
 131   assert_common_2(call_site_target_value, call_site, method_handle);
</pre>
<hr />
<pre>
 164     // Note that this cannot be done with assertions that
 165     // relate to concreteness or abstractness.
 166     BasicType elemt = ArrayKlass::cast(ctxk)-&gt;element_type();
 167     if (is_java_primitive(elemt))  return;   // Ex:  int[][]
 168     ctxk = ObjArrayKlass::cast(ctxk)-&gt;bottom_klass();
 169     //if (ctxk-&gt;is_final())  return;            // Ex:  String[][]
 170   }
 171   check_ctxk(ctxk);
 172   assert_common_1(leaf_type, DepValue(_oop_recorder, ctxk));
 173 }
 174 
 175 void Dependencies::assert_abstract_with_unique_concrete_subtype(Klass* ctxk, Klass* conck) {
 176   check_ctxk_abstract(ctxk);
 177   DepValue ctxk_dv(_oop_recorder, ctxk);
 178   DepValue conck_dv(_oop_recorder, conck, &amp;ctxk_dv);
 179   assert_common_2(abstract_with_unique_concrete_subtype, ctxk_dv, conck_dv);
 180 }
 181 
 182 void Dependencies::assert_unique_concrete_method(Klass* ctxk, Method* uniqm) {
 183   check_ctxk(ctxk);
<span class="line-added"> 184   check_unique_method(ctxk, uniqm);</span>
 185   assert_common_2(unique_concrete_method, DepValue(_oop_recorder, ctxk), DepValue(_oop_recorder, uniqm));
 186 }
 187 
 188 void Dependencies::assert_call_site_target_value(oop call_site, oop method_handle) {
 189   assert_common_2(call_site_target_value, DepValue(_oop_recorder, JNIHandles::make_local(call_site)), DepValue(_oop_recorder, JNIHandles::make_local(method_handle)));
 190 }
 191 
 192 #endif // INCLUDE_JVMCI
 193 
 194 
 195 // Helper function.  If we are adding a new dep. under ctxk2,
 196 // try to find an old dep. under a broader* ctxk1.  If there is
 197 //
 198 bool Dependencies::maybe_merge_ctxk(GrowableArray&lt;ciBaseObject*&gt;* deps,
 199                                     int ctxk_i, ciKlass* ctxk2) {
 200   ciKlass* ctxk1 = deps-&gt;at(ctxk_i)-&gt;as_metadata()-&gt;as_klass();
 201   if (ctxk2-&gt;is_subtype_of(ctxk1)) {
 202     return true;  // success, and no need to change
 203   } else if (ctxk1-&gt;is_subtype_of(ctxk2)) {
 204     // new context class fully subsumes previous one
</pre>
<hr />
<pre>
 610   3, // unique_concrete_subtypes_2 ctxk, k1, k2
 611   3, // unique_concrete_methods_2 ctxk, m1, m2
 612   1, // no_finalizable_subclasses ctxk
 613   2  // call_site_target_value call_site, method_handle
 614 };
 615 
 616 const char* Dependencies::dep_name(Dependencies::DepType dept) {
 617   if (!dept_in_mask(dept, all_types))  return &quot;?bad-dep?&quot;;
 618   return _dep_name[dept];
 619 }
 620 
 621 int Dependencies::dep_args(Dependencies::DepType dept) {
 622   if (!dept_in_mask(dept, all_types))  return -1;
 623   return _dep_args[dept];
 624 }
 625 
 626 void Dependencies::check_valid_dependency_type(DepType dept) {
 627   guarantee(FIRST_TYPE &lt;= dept &amp;&amp; dept &lt; TYPE_LIMIT, &quot;invalid dependency type: %d&quot;, (int) dept);
 628 }
 629 
<span class="line-modified"> 630 Dependencies::DepType Dependencies::validate_dependencies(CompileTask* task, char** failure_detail) {</span>





















 631   int klass_violations = 0;
 632   DepType result = end_marker;
 633   for (Dependencies::DepStream deps(this); deps.next(); ) {

 634     Klass* witness = deps.check_dependency();
 635     if (witness != NULL) {
 636       if (klass_violations == 0) {
 637         result = deps.type();
 638         if (failure_detail != NULL &amp;&amp; klass_violations == 0) {
 639           // Use a fixed size buffer to prevent the string stream from
 640           // resizing in the context of an inner resource mark.
 641           char* buffer = NEW_RESOURCE_ARRAY(char, O_BUFLEN);
 642           stringStream st(buffer, O_BUFLEN);
 643           deps.print_dependency(witness, true, &amp;st);
 644           *failure_detail = st.as_string();
 645         }
 646       }
 647       klass_violations++;
<span class="line-modified"> 648       if (xtty == NULL) {</span>





 649         // If we&#39;re not logging then a single violation is sufficient,
 650         // otherwise we want to log all the dependences which were
 651         // violated.
 652         break;
 653       }
 654     }
 655   }
 656 









 657   return result;
 658 }
 659 
 660 // for the sake of the compiler log, print out current dependencies:
 661 void Dependencies::log_all_dependencies() {
 662   if (log() == NULL)  return;
 663   ResourceMark rm;
 664   for (int deptv = (int)FIRST_TYPE; deptv &lt; (int)TYPE_LIMIT; deptv++) {
 665     DepType dept = (DepType)deptv;
 666     GrowableArray&lt;ciBaseObject*&gt;* deps = _deps[dept];
 667     int deplen = deps-&gt;length();
 668     if (deplen == 0) {
 669       continue;
 670     }
 671     int stride = dep_args(dept);
 672     GrowableArray&lt;ciBaseObject*&gt;* ciargs = new GrowableArray&lt;ciBaseObject*&gt;(stride);
 673     for (int i = 0; i &lt; deps-&gt;length(); i += stride) {
 674       for (int j = 0; j &lt; stride; j++) {
 675         // flush out the identities before printing
 676         ciargs-&gt;push(deps-&gt;at(i+j));
</pre>
<hr />
<pre>
1796   ClassHierarchyWalker wf(m1);
1797   wf.add_participant(m1-&gt;method_holder());
1798   wf.add_participant(m2-&gt;method_holder());
1799   return wf.find_witness_definer(ctxk, changes);
1800 }
1801 
1802 Klass* Dependencies::check_has_no_finalizable_subclasses(Klass* ctxk, KlassDepChange* changes) {
1803   Klass* search_at = ctxk;
1804   if (changes != NULL)
1805     search_at = changes-&gt;new_type(); // just look at the new bit
1806   return find_finalizable_subclass(search_at);
1807 }
1808 
1809 Klass* Dependencies::check_call_site_target_value(oop call_site, oop method_handle, CallSiteDepChange* changes) {
1810   assert(call_site != NULL, &quot;sanity&quot;);
1811   assert(method_handle != NULL, &quot;sanity&quot;);
1812   assert(call_site-&gt;is_a(SystemDictionary::CallSite_klass()),     &quot;sanity&quot;);
1813 
1814   if (changes == NULL) {
1815     // Validate all CallSites
<span class="line-modified">1816     if (java_lang_invoke_CallSite::target(call_site) != method_handle)</span>
1817       return call_site-&gt;klass();  // assertion failed
1818   } else {
1819     // Validate the given CallSite
<span class="line-modified">1820     if (call_site == changes-&gt;call_site() &amp;&amp; java_lang_invoke_CallSite::target(call_site) != changes-&gt;method_handle()) {</span>
<span class="line-modified">1821       assert(method_handle != changes-&gt;method_handle(), &quot;must be&quot;);</span>
1822       return call_site-&gt;klass();  // assertion failed
1823     }
1824   }
1825   return NULL;  // assertion still valid
1826 }
1827 
1828 void Dependencies::DepStream::trace_and_log_witness(Klass* witness) {
1829   if (witness != NULL) {
1830     if (TraceDependencies) {
1831       print_dependency(witness, /*verbose=*/ true);
1832     }
1833     // The following is a no-op unless logging is enabled:
1834     log_dependency(witness);
1835   }
1836 }
1837 
1838 
1839 Klass* Dependencies::DepStream::check_klass_dependency(KlassDepChange* changes) {
1840   assert_locked_or_safepoint(Compile_lock);
1841   Dependencies::check_valid_dependency_type(type());
</pre>
</td>
</tr>
</table>
<center><a href="debugInfo.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="dependencies.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/code/debugInfo.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/debugInfo.hpp&quot;
 27 #include &quot;code/debugInfoRec.hpp&quot;
 28 #include &quot;code/nmethod.hpp&quot;
 29 #include &quot;memory/universe.hpp&quot;
 30 #include &quot;oops/oop.inline.hpp&quot;
 31 #include &quot;runtime/handles.inline.hpp&quot;
 32 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 33 #include &quot;runtime/jniHandles.inline.hpp&quot;
 34 #include &quot;runtime/thread.hpp&quot;
 35 
 36 // Constructors
 37 
 38 DebugInfoWriteStream::DebugInfoWriteStream(DebugInformationRecorder* recorder, int initial_size)
 39 : CompressedWriteStream(initial_size) {
 40   _recorder = recorder;
 41 }
 42 
 43 // Serializing oops
 44 
 45 void DebugInfoWriteStream::write_handle(jobject h) {
 46   write_int(recorder()-&gt;oop_recorder()-&gt;find_index(h));
 47 }
 48 
 49 void DebugInfoWriteStream::write_metadata(Metadata* h) {
 50   write_int(recorder()-&gt;oop_recorder()-&gt;find_index(h));
 51 }
 52 
 53 oop DebugInfoReadStream::read_oop() {
 54   nmethod* nm = const_cast&lt;CompiledMethod*&gt;(code())-&gt;as_nmethod_or_null();
 55   oop o;
 56   if (nm != NULL) {
 57     // Despite these oops being found inside nmethods that are on-stack,
 58     // they are not kept alive by all GCs (e.g. G1 and Shenandoah).
 59     o = nm-&gt;oop_at_phantom(read_int());
 60   } else {
 61     o = code()-&gt;oop_at(read_int());
 62   }
 63   assert(oopDesc::is_oop_or_null(o), &quot;oop only&quot;);
 64   return o;
 65 }
 66 
 67 ScopeValue* DebugInfoReadStream::read_object_value(bool is_auto_box) {
 68   int id = read_int();
 69 #ifdef ASSERT
 70   assert(_obj_pool != NULL, &quot;object pool does not exist&quot;);
 71   for (int i = _obj_pool-&gt;length() - 1; i &gt;= 0; i--) {
 72     assert(_obj_pool-&gt;at(i)-&gt;as_ObjectValue()-&gt;id() != id, &quot;should not be read twice&quot;);
 73   }
 74 #endif
 75   ObjectValue* result = is_auto_box ? new AutoBoxObjectValue(id) : new ObjectValue(id);
 76   // Cache the object since an object field could reference it.
 77   _obj_pool-&gt;push(result);
 78   result-&gt;read_object(this);
 79   return result;
 80 }
 81 
 82 ScopeValue* DebugInfoReadStream::get_cached_object() {
 83   int id = read_int();
 84   assert(_obj_pool != NULL, &quot;object pool does not exist&quot;);
 85   for (int i = _obj_pool-&gt;length() - 1; i &gt;= 0; i--) {
 86     ObjectValue* ov = _obj_pool-&gt;at(i)-&gt;as_ObjectValue();
 87     if (ov-&gt;id() == id) {
 88       return ov;
 89     }
 90   }
 91   ShouldNotReachHere();
 92   return NULL;
 93 }
 94 
 95 // Serializing scope values
 96 
 97 enum { LOCATION_CODE = 0, CONSTANT_INT_CODE = 1,  CONSTANT_OOP_CODE = 2,
 98                           CONSTANT_LONG_CODE = 3, CONSTANT_DOUBLE_CODE = 4,
 99                           OBJECT_CODE = 5,        OBJECT_ID_CODE = 6,
100                           AUTO_BOX_OBJECT_CODE = 7 };
101 
102 ScopeValue* ScopeValue::read_from(DebugInfoReadStream* stream) {
103   ScopeValue* result = NULL;
104   switch(stream-&gt;read_int()) {
105    case LOCATION_CODE:        result = new LocationValue(stream);                        break;
106    case CONSTANT_INT_CODE:    result = new ConstantIntValue(stream);                     break;
107    case CONSTANT_OOP_CODE:    result = new ConstantOopReadValue(stream);                 break;
108    case CONSTANT_LONG_CODE:   result = new ConstantLongValue(stream);                    break;
109    case CONSTANT_DOUBLE_CODE: result = new ConstantDoubleValue(stream);                  break;
110    case OBJECT_CODE:          result = stream-&gt;read_object_value(false /*is_auto_box*/); break;
111    case AUTO_BOX_OBJECT_CODE: result = stream-&gt;read_object_value(true /*is_auto_box*/);  break;
112    case OBJECT_ID_CODE:       result = stream-&gt;get_cached_object();                      break;
113    default: ShouldNotReachHere();
114   }
115   return result;
116 }
117 
118 // LocationValue
119 
120 LocationValue::LocationValue(DebugInfoReadStream* stream) {
121   _location = Location(stream);
122 }
123 
124 void LocationValue::write_on(DebugInfoWriteStream* stream) {
125   stream-&gt;write_int(LOCATION_CODE);
126   location().write_on(stream);
127 }
128 
129 void LocationValue::print_on(outputStream* st) const {
130   location().print_on(st);
131 }
132 
133 // ObjectValue
134 
135 void ObjectValue::set_value(oop value) {
136   _value = Handle(Thread::current(), value);
137 }
138 
139 void ObjectValue::read_object(DebugInfoReadStream* stream) {
140   _klass = read_from(stream);
141   assert(_klass-&gt;is_constant_oop(), &quot;should be constant java mirror oop&quot;);
142   int length = stream-&gt;read_int();
143   for (int i = 0; i &lt; length; i++) {
144     ScopeValue* val = read_from(stream);
145     _field_values.append(val);
146   }
147 }
148 
149 void ObjectValue::write_on(DebugInfoWriteStream* stream) {
150   if (_visited) {
151     stream-&gt;write_int(OBJECT_ID_CODE);
152     stream-&gt;write_int(_id);
153   } else {
154     _visited = true;
155     stream-&gt;write_int(is_auto_box() ? AUTO_BOX_OBJECT_CODE : OBJECT_CODE);
156     stream-&gt;write_int(_id);
157     _klass-&gt;write_on(stream);
158     int length = _field_values.length();
159     stream-&gt;write_int(length);
160     for (int i = 0; i &lt; length; i++) {
161       _field_values.at(i)-&gt;write_on(stream);
162     }
163   }
164 }
165 
166 void ObjectValue::print_on(outputStream* st) const {
167   st-&gt;print(&quot;%s[%d]&quot;, is_auto_box() ? &quot;box_obj&quot; : &quot;obj&quot;, _id);
168 }
169 
170 void ObjectValue::print_fields_on(outputStream* st) const {
171 #ifndef PRODUCT
172   if (_field_values.length() &gt; 0) {
173     _field_values.at(0)-&gt;print_on(st);
174   }
175   for (int i = 1; i &lt; _field_values.length(); i++) {
176     st-&gt;print(&quot;, &quot;);
177     _field_values.at(i)-&gt;print_on(st);
178   }
179 #endif
180 }
181 
182 // ConstantIntValue
183 
184 ConstantIntValue::ConstantIntValue(DebugInfoReadStream* stream) {
185   _value = stream-&gt;read_signed_int();
186 }
187 
188 void ConstantIntValue::write_on(DebugInfoWriteStream* stream) {
189   stream-&gt;write_int(CONSTANT_INT_CODE);
190   stream-&gt;write_signed_int(value());
191 }
192 
193 void ConstantIntValue::print_on(outputStream* st) const {
194   st-&gt;print(&quot;%d&quot;, value());
195 }
196 
197 // ConstantLongValue
198 
199 ConstantLongValue::ConstantLongValue(DebugInfoReadStream* stream) {
200   _value = stream-&gt;read_long();
201 }
202 
203 void ConstantLongValue::write_on(DebugInfoWriteStream* stream) {
204   stream-&gt;write_int(CONSTANT_LONG_CODE);
205   stream-&gt;write_long(value());
206 }
207 
208 void ConstantLongValue::print_on(outputStream* st) const {
209   st-&gt;print(JLONG_FORMAT, value());
210 }
211 
212 // ConstantDoubleValue
213 
214 ConstantDoubleValue::ConstantDoubleValue(DebugInfoReadStream* stream) {
215   _value = stream-&gt;read_double();
216 }
217 
218 void ConstantDoubleValue::write_on(DebugInfoWriteStream* stream) {
219   stream-&gt;write_int(CONSTANT_DOUBLE_CODE);
220   stream-&gt;write_double(value());
221 }
222 
223 void ConstantDoubleValue::print_on(outputStream* st) const {
224   st-&gt;print(&quot;%f&quot;, value());
225 }
226 
227 // ConstantOopWriteValue
228 
229 void ConstantOopWriteValue::write_on(DebugInfoWriteStream* stream) {
230 #ifdef ASSERT
231   {
232     // cannot use ThreadInVMfromNative here since in case of JVMCI compiler,
233     // thread is already in VM state.
234     ThreadInVMfromUnknown tiv;
235     assert(JNIHandles::resolve(value()) == NULL ||
236            Universe::heap()-&gt;is_in(JNIHandles::resolve(value())),
237            &quot;Should be in heap&quot;);
238  }
239 #endif
240   stream-&gt;write_int(CONSTANT_OOP_CODE);
241   stream-&gt;write_handle(value());
242 }
243 
244 void ConstantOopWriteValue::print_on(outputStream* st) const {
245   // using ThreadInVMfromUnknown here since in case of JVMCI compiler,
246   // thread is already in VM state.
247   ThreadInVMfromUnknown tiv;
248   JNIHandles::resolve(value())-&gt;print_value_on(st);
249 }
250 
251 
252 // ConstantOopReadValue
253 
254 ConstantOopReadValue::ConstantOopReadValue(DebugInfoReadStream* stream) {
255   _value = Handle(Thread::current(), stream-&gt;read_oop());
256   assert(_value() == NULL ||
257          Universe::heap()-&gt;is_in(_value()), &quot;Should be in heap&quot;);
258 }
259 
260 void ConstantOopReadValue::write_on(DebugInfoWriteStream* stream) {
261   ShouldNotReachHere();
262 }
263 
264 void ConstantOopReadValue::print_on(outputStream* st) const {
265   if (value()() != NULL) {
266     value()()-&gt;print_value_on(st);
267   } else {
268     st-&gt;print_cr(&quot;NULL&quot;);
269   }
270 }
271 
272 
273 // MonitorValue
274 
275 MonitorValue::MonitorValue(ScopeValue* owner, Location basic_lock, bool eliminated) {
276   _owner       = owner;
277   _basic_lock  = basic_lock;
278   _eliminated  = eliminated;
279 }
280 
281 MonitorValue::MonitorValue(DebugInfoReadStream* stream) {
282   _basic_lock  = Location(stream);
283   _owner       = ScopeValue::read_from(stream);
284   _eliminated  = (stream-&gt;read_bool() != 0);
285 }
286 
287 void MonitorValue::write_on(DebugInfoWriteStream* stream) {
288   _basic_lock.write_on(stream);
289   _owner-&gt;write_on(stream);
290   stream-&gt;write_bool(_eliminated);
291 }
292 
293 #ifndef PRODUCT
294 void MonitorValue::print_on(outputStream* st) const {
295   st-&gt;print(&quot;monitor{&quot;);
296   owner()-&gt;print_on(st);
297   st-&gt;print(&quot;,&quot;);
298   basic_lock().print_on(st);
299   st-&gt;print(&quot;}&quot;);
300   if (_eliminated) {
301     st-&gt;print(&quot; (eliminated)&quot;);
302   }
303 }
304 #endif
    </pre>
  </body>
</html>
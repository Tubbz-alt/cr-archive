<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/code/compiledMethod.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compiledMethod.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compiledMethod.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/compiledMethod.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CODE_COMPILEDMETHOD_HPP
 26 #define SHARE_CODE_COMPILEDMETHOD_HPP
 27 
 28 #include &quot;code/codeBlob.hpp&quot;
 29 #include &quot;code/pcDesc.hpp&quot;
 30 #include &quot;oops/metadata.hpp&quot;
 31 
 32 class Dependencies;
 33 class ExceptionHandlerTable;
 34 class ImplicitExceptionTable;
 35 class AbstractCompiler;
 36 class xmlStream;
 37 class CompiledStaticCall;
 38 class NativeCallWrapper;
 39 class ScopeDesc;
 40 class CompiledIC;

 41 
 42 // This class is used internally by nmethods, to cache
 43 // exception/pc/handler information.
 44 
 45 class ExceptionCache : public CHeapObj&lt;mtCode&gt; {
 46   friend class VMStructs;
 47  private:
 48   enum { cache_size = 16 };
 49   Klass*   _exception_type;
 50   address  _pc[cache_size];
 51   address  _handler[cache_size];
 52   volatile int _count;
 53   ExceptionCache* volatile _next;
 54   ExceptionCache* _purge_list_next;
 55 
 56   inline address pc_at(int index);
 57   void set_pc_at(int index, address a)      { assert(index &gt;= 0 &amp;&amp; index &lt; cache_size,&quot;&quot;); _pc[index] = a; }
 58 
 59   inline address handler_at(int index);
 60   void set_handler_at(int index, address a) { assert(index &gt;= 0 &amp;&amp; index &lt; cache_size,&quot;&quot;); _handler[index] = a; }
</pre>
<hr />
<pre>
190   void set_gc_data(T* gc_data)                    { _gc_data = reinterpret_cast&lt;void*&gt;(gc_data); }
191 
192   bool  has_unsafe_access() const                 { return _has_unsafe_access; }
193   void  set_has_unsafe_access(bool z)             { _has_unsafe_access = z; }
194 
195   bool  has_method_handle_invokes() const         { return _has_method_handle_invokes; }
196   void  set_has_method_handle_invokes(bool z)     { _has_method_handle_invokes = z; }
197 
198   bool  is_lazy_critical_native() const           { return _lazy_critical_native; }
199   void  set_lazy_critical_native(bool z)          { _lazy_critical_native = z; }
200 
201   bool  has_wide_vectors() const                  { return _has_wide_vectors; }
202   void  set_has_wide_vectors(bool z)              { _has_wide_vectors = z; }
203 
204   enum { not_installed = -1, // in construction, only the owner doing the construction is
205                              // allowed to advance state
206          in_use        = 0,  // executable nmethod
207          not_used      = 1,  // not entrant, but revivable
208          not_entrant   = 2,  // marked for deoptimization but activations may still exist,
209                              // will be transformed to zombie when all activations are gone
<span class="line-modified">210          zombie        = 3,  // no activations exist, nmethod is ready for purge</span>
<span class="line-modified">211          unloaded      = 4   // there should be no activations, should not be called,</span>
<span class="line-modified">212                              // will be transformed to zombie immediately</span>
213   };
214 
215   virtual bool  is_in_use() const = 0;
216   virtual int   comp_level() const = 0;
217   virtual int   compile_id() const = 0;
218 
219   virtual address verified_entry_point() const = 0;
220   virtual void log_identity(xmlStream* log) const = 0;
221   virtual void log_state_change() const = 0;
222   virtual bool make_not_used() = 0;
223   virtual bool make_not_entrant() = 0;
224   virtual bool make_entrant() = 0;
225   virtual address entry_point() const = 0;
226   virtual bool make_zombie() = 0;
227   virtual bool is_osr_method() const = 0;
228   virtual int osr_entry_bci() const = 0;
229   Method* method() const                          { return _method; }
230   virtual void print_pcs() = 0;
231   bool is_native_method() const { return _method != NULL &amp;&amp; _method-&gt;is_native(); }
232   bool is_java_method() const { return _method != NULL &amp;&amp; !_method-&gt;is_native(); }
233 
234   // ScopeDesc retrieval operation
235   PcDesc* pc_desc_at(address pc)   { return find_pc_desc(pc, false); }
236   // pc_desc_near returns the first PcDesc at or after the given pc.
237   PcDesc* pc_desc_near(address pc) { return find_pc_desc(pc, true); }
238 
239   // ScopeDesc for an instruction
240   ScopeDesc* scope_desc_at(address pc);
241   ScopeDesc* scope_desc_near(address pc);
242 
243   bool is_at_poll_return(address pc);
244   bool is_at_poll_or_poll_return(address pc);
245 
<span class="line-modified">246   bool  is_marked_for_deoptimization() const      { return _mark_for_deoptimization_status != not_marked; }</span>
<span class="line-modified">247   void  mark_for_deoptimization(bool inc_recompile_counts = true) {</span>
<span class="line-modified">248     _mark_for_deoptimization_status = (inc_recompile_counts ? deoptimize : deoptimize_noupdate);</span>
<span class="line-removed">249   }</span>
250   bool update_recompile_counts() const {
251     // Update recompile counts when either the update is explicitly requested (deoptimize)
252     // or the nmethod is not marked for deoptimization at all (not_marked).
253     // The latter happens during uncommon traps when deoptimized nmethod is made not entrant.
254     return _mark_for_deoptimization_status != deoptimize_noupdate;
255   }
256 
257   static bool nmethod_access_is_safe(nmethod* nm);
258 
259   // tells whether frames described by this nmethod can be deoptimized
260   // note: native wrappers cannot be deoptimized.
261   bool can_be_deoptimized() const { return is_java_method(); }
262 
263   virtual oop oop_at(int index) const = 0;
264   virtual Metadata* metadata_at(int index) const = 0;
265 
266   address scopes_data_begin() const { return _scopes_data_begin; }
267   virtual address scopes_data_end() const = 0;
268   int scopes_data_size() const { return scopes_data_end() - scopes_data_begin(); }
269 
</pre>
<hr />
<pre>
331   // Return true is the PC is one would expect if the frame is being deopted.
332   inline bool is_deopt_pc(address pc);
333   bool is_deopt_mh_entry(address pc) { return pc == deopt_mh_handler_begin(); }
334   inline bool is_deopt_entry(address pc);
335 
336   virtual bool can_convert_to_zombie() = 0;
337   virtual const char* compile_kind() const = 0;
338   virtual int get_state() const = 0;
339 
340   const char* state() const;
341 
342   bool is_far_code() const { return _is_far_code; }
343 
344   bool inlinecache_check_contains(address addr) const {
345     return (addr &gt;= code_begin() &amp;&amp; addr &lt; verified_entry_point());
346   }
347 
348   void preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, OopClosure* f);
349 
350   // implicit exceptions support
<span class="line-modified">351   virtual address continuation_for_implicit_exception(address pc) { return NULL; }</span>

352 
353   static address get_deopt_original_pc(const frame* fr);
354 
355   // Inline cache support for class unloading and nmethod unloading
356  private:
357   bool cleanup_inline_caches_impl(bool unloading_occurred, bool clean_all);
358 


359  public:
360   // Serial version used by sweeper and whitebox test
361   void cleanup_inline_caches(bool clean_all);
362 
363   virtual void clear_inline_caches();
364   void clear_ic_callsites();
365 



366   // Verify and count cached icholder relocations.
367   int  verify_icholder_relocations();
368   void verify_oop_relocations();
369 
<span class="line-modified">370   virtual bool is_evol_dependent() = 0;</span>

371   // Fast breakpoint support. Tells if this compiled method is
372   // dependent on the given method. Returns true if this nmethod
373   // corresponds to the given method as well.
374   virtual bool is_dependent_on_method(Method* dependee) = 0;
375 
376   virtual NativeCallWrapper* call_wrapper_at(address call) const = 0;
377   virtual NativeCallWrapper* call_wrapper_before(address return_pc) const = 0;
378   virtual address call_instruction_address(address pc) const = 0;
379 
380   virtual CompiledStaticCall* compiledStaticCall_at(Relocation* call_site) const = 0;
381   virtual CompiledStaticCall* compiledStaticCall_at(address addr) const = 0;
382   virtual CompiledStaticCall* compiledStaticCall_before(address addr) const = 0;
383 
384   Method* attached_method(address call_pc);
385   Method* attached_method_before_pc(address pc);
386 
<span class="line-modified">387   virtual void metadata_do(void f(Metadata*)) = 0;</span>
388 
389   // GC support
390  protected:
391   address oops_reloc_begin() const;
392 
393  private:
394   bool static clean_ic_if_metadata_is_dead(CompiledIC *ic);
395 
<span class="line-removed">396   void clean_ic_stubs();</span>
<span class="line-removed">397 </span>
398  public:
399   // GC unloading support
400   // Cleans unloaded klasses and unloaded nmethods in inline caches
401 
402   virtual bool is_unloading() = 0;
403 
404   bool unload_nmethod_caches(bool class_unloading_occurred);
405   virtual void do_unloading(bool unloading_occurred) = 0;
406 
407 private:
408   PcDesc* find_pc_desc(address pc, bool approximate) {
409     return _pc_desc_container.find_pc_desc(pc, approximate, PcDescSearch(code_begin(), scopes_pcs_begin(), scopes_pcs_end()));
410   }
411 };
412 
413 #endif // SHARE_CODE_COMPILEDMETHOD_HPP
</pre>
</td>
<td>
<hr />
<pre>
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CODE_COMPILEDMETHOD_HPP
 26 #define SHARE_CODE_COMPILEDMETHOD_HPP
 27 
 28 #include &quot;code/codeBlob.hpp&quot;
 29 #include &quot;code/pcDesc.hpp&quot;
 30 #include &quot;oops/metadata.hpp&quot;
 31 
 32 class Dependencies;
 33 class ExceptionHandlerTable;
 34 class ImplicitExceptionTable;
 35 class AbstractCompiler;
 36 class xmlStream;
 37 class CompiledStaticCall;
 38 class NativeCallWrapper;
 39 class ScopeDesc;
 40 class CompiledIC;
<span class="line-added"> 41 class MetadataClosure;</span>
 42 
 43 // This class is used internally by nmethods, to cache
 44 // exception/pc/handler information.
 45 
 46 class ExceptionCache : public CHeapObj&lt;mtCode&gt; {
 47   friend class VMStructs;
 48  private:
 49   enum { cache_size = 16 };
 50   Klass*   _exception_type;
 51   address  _pc[cache_size];
 52   address  _handler[cache_size];
 53   volatile int _count;
 54   ExceptionCache* volatile _next;
 55   ExceptionCache* _purge_list_next;
 56 
 57   inline address pc_at(int index);
 58   void set_pc_at(int index, address a)      { assert(index &gt;= 0 &amp;&amp; index &lt; cache_size,&quot;&quot;); _pc[index] = a; }
 59 
 60   inline address handler_at(int index);
 61   void set_handler_at(int index, address a) { assert(index &gt;= 0 &amp;&amp; index &lt; cache_size,&quot;&quot;); _handler[index] = a; }
</pre>
<hr />
<pre>
191   void set_gc_data(T* gc_data)                    { _gc_data = reinterpret_cast&lt;void*&gt;(gc_data); }
192 
193   bool  has_unsafe_access() const                 { return _has_unsafe_access; }
194   void  set_has_unsafe_access(bool z)             { _has_unsafe_access = z; }
195 
196   bool  has_method_handle_invokes() const         { return _has_method_handle_invokes; }
197   void  set_has_method_handle_invokes(bool z)     { _has_method_handle_invokes = z; }
198 
199   bool  is_lazy_critical_native() const           { return _lazy_critical_native; }
200   void  set_lazy_critical_native(bool z)          { _lazy_critical_native = z; }
201 
202   bool  has_wide_vectors() const                  { return _has_wide_vectors; }
203   void  set_has_wide_vectors(bool z)              { _has_wide_vectors = z; }
204 
205   enum { not_installed = -1, // in construction, only the owner doing the construction is
206                              // allowed to advance state
207          in_use        = 0,  // executable nmethod
208          not_used      = 1,  // not entrant, but revivable
209          not_entrant   = 2,  // marked for deoptimization but activations may still exist,
210                              // will be transformed to zombie when all activations are gone
<span class="line-modified">211          unloaded      = 3,  // there should be no activations, should not be called, will be</span>
<span class="line-modified">212                              // transformed to zombie by the sweeper, when not &quot;locked in vm&quot;.</span>
<span class="line-modified">213          zombie        = 4   // no activations exist, nmethod is ready for purge</span>
214   };
215 
216   virtual bool  is_in_use() const = 0;
217   virtual int   comp_level() const = 0;
218   virtual int   compile_id() const = 0;
219 
220   virtual address verified_entry_point() const = 0;
221   virtual void log_identity(xmlStream* log) const = 0;
222   virtual void log_state_change() const = 0;
223   virtual bool make_not_used() = 0;
224   virtual bool make_not_entrant() = 0;
225   virtual bool make_entrant() = 0;
226   virtual address entry_point() const = 0;
227   virtual bool make_zombie() = 0;
228   virtual bool is_osr_method() const = 0;
229   virtual int osr_entry_bci() const = 0;
230   Method* method() const                          { return _method; }
231   virtual void print_pcs() = 0;
232   bool is_native_method() const { return _method != NULL &amp;&amp; _method-&gt;is_native(); }
233   bool is_java_method() const { return _method != NULL &amp;&amp; !_method-&gt;is_native(); }
234 
235   // ScopeDesc retrieval operation
236   PcDesc* pc_desc_at(address pc)   { return find_pc_desc(pc, false); }
237   // pc_desc_near returns the first PcDesc at or after the given pc.
238   PcDesc* pc_desc_near(address pc) { return find_pc_desc(pc, true); }
239 
240   // ScopeDesc for an instruction
241   ScopeDesc* scope_desc_at(address pc);
242   ScopeDesc* scope_desc_near(address pc);
243 
244   bool is_at_poll_return(address pc);
245   bool is_at_poll_or_poll_return(address pc);
246 
<span class="line-modified">247   bool  is_marked_for_deoptimization() const { return _mark_for_deoptimization_status != not_marked; }</span>
<span class="line-modified">248   void  mark_for_deoptimization(bool inc_recompile_counts = true);</span>
<span class="line-modified">249 </span>

250   bool update_recompile_counts() const {
251     // Update recompile counts when either the update is explicitly requested (deoptimize)
252     // or the nmethod is not marked for deoptimization at all (not_marked).
253     // The latter happens during uncommon traps when deoptimized nmethod is made not entrant.
254     return _mark_for_deoptimization_status != deoptimize_noupdate;
255   }
256 
257   static bool nmethod_access_is_safe(nmethod* nm);
258 
259   // tells whether frames described by this nmethod can be deoptimized
260   // note: native wrappers cannot be deoptimized.
261   bool can_be_deoptimized() const { return is_java_method(); }
262 
263   virtual oop oop_at(int index) const = 0;
264   virtual Metadata* metadata_at(int index) const = 0;
265 
266   address scopes_data_begin() const { return _scopes_data_begin; }
267   virtual address scopes_data_end() const = 0;
268   int scopes_data_size() const { return scopes_data_end() - scopes_data_begin(); }
269 
</pre>
<hr />
<pre>
331   // Return true is the PC is one would expect if the frame is being deopted.
332   inline bool is_deopt_pc(address pc);
333   bool is_deopt_mh_entry(address pc) { return pc == deopt_mh_handler_begin(); }
334   inline bool is_deopt_entry(address pc);
335 
336   virtual bool can_convert_to_zombie() = 0;
337   virtual const char* compile_kind() const = 0;
338   virtual int get_state() const = 0;
339 
340   const char* state() const;
341 
342   bool is_far_code() const { return _is_far_code; }
343 
344   bool inlinecache_check_contains(address addr) const {
345     return (addr &gt;= code_begin() &amp;&amp; addr &lt; verified_entry_point());
346   }
347 
348   void preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, OopClosure* f);
349 
350   // implicit exceptions support
<span class="line-modified">351   address continuation_for_implicit_div0_exception(address pc) { return continuation_for_implicit_exception(pc, true); }</span>
<span class="line-added">352   address continuation_for_implicit_null_exception(address pc) { return continuation_for_implicit_exception(pc, false); }</span>
353 
354   static address get_deopt_original_pc(const frame* fr);
355 
356   // Inline cache support for class unloading and nmethod unloading
357  private:
358   bool cleanup_inline_caches_impl(bool unloading_occurred, bool clean_all);
359 
<span class="line-added">360   address continuation_for_implicit_exception(address pc, bool for_div0_check);</span>
<span class="line-added">361 </span>
362  public:
363   // Serial version used by sweeper and whitebox test
364   void cleanup_inline_caches(bool clean_all);
365 
366   virtual void clear_inline_caches();
367   void clear_ic_callsites();
368 
<span class="line-added">369   // Execute nmethod barrier code, as if entering through nmethod call.</span>
<span class="line-added">370   void run_nmethod_entry_barrier();</span>
<span class="line-added">371 </span>
372   // Verify and count cached icholder relocations.
373   int  verify_icholder_relocations();
374   void verify_oop_relocations();
375 
<span class="line-modified">376   bool has_evol_metadata();</span>
<span class="line-added">377 </span>
378   // Fast breakpoint support. Tells if this compiled method is
379   // dependent on the given method. Returns true if this nmethod
380   // corresponds to the given method as well.
381   virtual bool is_dependent_on_method(Method* dependee) = 0;
382 
383   virtual NativeCallWrapper* call_wrapper_at(address call) const = 0;
384   virtual NativeCallWrapper* call_wrapper_before(address return_pc) const = 0;
385   virtual address call_instruction_address(address pc) const = 0;
386 
387   virtual CompiledStaticCall* compiledStaticCall_at(Relocation* call_site) const = 0;
388   virtual CompiledStaticCall* compiledStaticCall_at(address addr) const = 0;
389   virtual CompiledStaticCall* compiledStaticCall_before(address addr) const = 0;
390 
391   Method* attached_method(address call_pc);
392   Method* attached_method_before_pc(address pc);
393 
<span class="line-modified">394   virtual void metadata_do(MetadataClosure* f) = 0;</span>
395 
396   // GC support
397  protected:
398   address oops_reloc_begin() const;
399 
400  private:
401   bool static clean_ic_if_metadata_is_dead(CompiledIC *ic);
402 


403  public:
404   // GC unloading support
405   // Cleans unloaded klasses and unloaded nmethods in inline caches
406 
407   virtual bool is_unloading() = 0;
408 
409   bool unload_nmethod_caches(bool class_unloading_occurred);
410   virtual void do_unloading(bool unloading_occurred) = 0;
411 
412 private:
413   PcDesc* find_pc_desc(address pc, bool approximate) {
414     return _pc_desc_container.find_pc_desc(pc, approximate, PcDescSearch(code_begin(), scopes_pcs_begin(), scopes_pcs_end()));
415   }
416 };
417 
418 #endif // SHARE_CODE_COMPILEDMETHOD_HPP
</pre>
</td>
</tr>
</table>
<center><a href="compiledMethod.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compiledMethod.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
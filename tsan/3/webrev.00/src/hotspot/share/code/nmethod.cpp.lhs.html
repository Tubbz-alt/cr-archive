<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/code/nmethod.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
<a name="2" id="anc2"></a>
  27 #include &quot;code/codeCache.hpp&quot;
  28 #include &quot;code/compiledIC.hpp&quot;
  29 #include &quot;code/compiledMethod.inline.hpp&quot;
  30 #include &quot;code/dependencies.hpp&quot;
  31 #include &quot;code/nativeInst.hpp&quot;
  32 #include &quot;code/nmethod.hpp&quot;
  33 #include &quot;code/scopeDesc.hpp&quot;
  34 #include &quot;compiler/abstractCompiler.hpp&quot;
  35 #include &quot;compiler/compileBroker.hpp&quot;
  36 #include &quot;compiler/compileLog.hpp&quot;
  37 #include &quot;compiler/compilerDirectives.hpp&quot;
  38 #include &quot;compiler/directivesParser.hpp&quot;
  39 #include &quot;compiler/disassembler.hpp&quot;
  40 #include &quot;interpreter/bytecode.hpp&quot;
  41 #include &quot;logging/log.hpp&quot;
  42 #include &quot;logging/logStream.hpp&quot;
  43 #include &quot;memory/allocation.inline.hpp&quot;
  44 #include &quot;memory/resourceArea.hpp&quot;
<a name="3" id="anc3"></a>
  45 #include &quot;oops/access.inline.hpp&quot;
  46 #include &quot;oops/method.inline.hpp&quot;
  47 #include &quot;oops/methodData.hpp&quot;
  48 #include &quot;oops/oop.inline.hpp&quot;
  49 #include &quot;prims/jvmtiImpl.hpp&quot;
<a name="4" id="anc4"></a>
  50 #include &quot;runtime/atomic.hpp&quot;
<a name="5" id="anc5"></a>
  51 #include &quot;runtime/flags/flagSetting.hpp&quot;
  52 #include &quot;runtime/frame.inline.hpp&quot;
  53 #include &quot;runtime/handles.inline.hpp&quot;
  54 #include &quot;runtime/jniHandles.inline.hpp&quot;
  55 #include &quot;runtime/orderAccess.hpp&quot;
  56 #include &quot;runtime/os.hpp&quot;
  57 #include &quot;runtime/safepointVerifiers.hpp&quot;
<a name="6" id="anc6"></a>
  58 #include &quot;runtime/sharedRuntime.hpp&quot;
  59 #include &quot;runtime/sweeper.hpp&quot;
  60 #include &quot;runtime/vmThread.hpp&quot;
  61 #include &quot;utilities/align.hpp&quot;
  62 #include &quot;utilities/dtrace.hpp&quot;
  63 #include &quot;utilities/events.hpp&quot;
  64 #include &quot;utilities/resourceHash.hpp&quot;
  65 #include &quot;utilities/xmlstream.hpp&quot;
  66 #if INCLUDE_JVMCI
<a name="7" id="anc7"></a><span class="line-modified">  67 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;</span>
  68 #endif
  69 
  70 #ifdef DTRACE_ENABLED
  71 
  72 // Only bother with this argument setup if dtrace is available
  73 
  74 #define DTRACE_METHOD_UNLOAD_PROBE(method)                                \
  75   {                                                                       \
  76     Method* m = (method);                                                 \
  77     if (m != NULL) {                                                      \
  78       Symbol* klass_name = m-&gt;klass_name();                               \
  79       Symbol* name = m-&gt;name();                                           \
  80       Symbol* signature = m-&gt;signature();                                 \
  81       HOTSPOT_COMPILED_METHOD_UNLOAD(                                     \
  82         (char *) klass_name-&gt;bytes(), klass_name-&gt;utf8_length(),                   \
  83         (char *) name-&gt;bytes(), name-&gt;utf8_length(),                               \
  84         (char *) signature-&gt;bytes(), signature-&gt;utf8_length());                    \
  85     }                                                                     \
  86   }
  87 
  88 #else //  ndef DTRACE_ENABLED
  89 
  90 #define DTRACE_METHOD_UNLOAD_PROBE(method)
  91 
  92 #endif
  93 
  94 //---------------------------------------------------------------------------------
  95 // NMethod statistics
  96 // They are printed under various flags, including:
  97 //   PrintC1Statistics, PrintOptoStatistics, LogVMOutput, and LogCompilation.
  98 // (In the latter two cases, they like other stats are printed to the log only.)
  99 
 100 #ifndef PRODUCT
 101 // These variables are put into one block to reduce relocations
 102 // and make it simpler to print from the debugger.
 103 struct java_nmethod_stats_struct {
 104   int nmethod_count;
 105   int total_size;
 106   int relocation_size;
 107   int consts_size;
 108   int insts_size;
 109   int stub_size;
 110   int scopes_data_size;
 111   int scopes_pcs_size;
 112   int dependencies_size;
 113   int handler_table_size;
 114   int nul_chk_table_size;
<a name="8" id="anc8"></a>



 115   int oops_size;
 116   int metadata_size;
 117 
 118   void note_nmethod(nmethod* nm) {
 119     nmethod_count += 1;
 120     total_size          += nm-&gt;size();
 121     relocation_size     += nm-&gt;relocation_size();
 122     consts_size         += nm-&gt;consts_size();
 123     insts_size          += nm-&gt;insts_size();
 124     stub_size           += nm-&gt;stub_size();
 125     oops_size           += nm-&gt;oops_size();
 126     metadata_size       += nm-&gt;metadata_size();
 127     scopes_data_size    += nm-&gt;scopes_data_size();
 128     scopes_pcs_size     += nm-&gt;scopes_pcs_size();
 129     dependencies_size   += nm-&gt;dependencies_size();
 130     handler_table_size  += nm-&gt;handler_table_size();
 131     nul_chk_table_size  += nm-&gt;nul_chk_table_size();
<a name="9" id="anc9"></a>



 132   }
 133   void print_nmethod_stats(const char* name) {
 134     if (nmethod_count == 0)  return;
 135     tty-&gt;print_cr(&quot;Statistics for %d bytecoded nmethods for %s:&quot;, nmethod_count, name);
 136     if (total_size != 0)          tty-&gt;print_cr(&quot; total in heap  = %d&quot;, total_size);
 137     if (nmethod_count != 0)       tty-&gt;print_cr(&quot; header         = &quot; SIZE_FORMAT, nmethod_count * sizeof(nmethod));
 138     if (relocation_size != 0)     tty-&gt;print_cr(&quot; relocation     = %d&quot;, relocation_size);
 139     if (consts_size != 0)         tty-&gt;print_cr(&quot; constants      = %d&quot;, consts_size);
 140     if (insts_size != 0)          tty-&gt;print_cr(&quot; main code      = %d&quot;, insts_size);
 141     if (stub_size != 0)           tty-&gt;print_cr(&quot; stub code      = %d&quot;, stub_size);
 142     if (oops_size != 0)           tty-&gt;print_cr(&quot; oops           = %d&quot;, oops_size);
 143     if (metadata_size != 0)       tty-&gt;print_cr(&quot; metadata       = %d&quot;, metadata_size);
 144     if (scopes_data_size != 0)    tty-&gt;print_cr(&quot; scopes data    = %d&quot;, scopes_data_size);
 145     if (scopes_pcs_size != 0)     tty-&gt;print_cr(&quot; scopes pcs     = %d&quot;, scopes_pcs_size);
 146     if (dependencies_size != 0)   tty-&gt;print_cr(&quot; dependencies   = %d&quot;, dependencies_size);
 147     if (handler_table_size != 0)  tty-&gt;print_cr(&quot; handler table  = %d&quot;, handler_table_size);
 148     if (nul_chk_table_size != 0)  tty-&gt;print_cr(&quot; nul chk table  = %d&quot;, nul_chk_table_size);
<a name="10" id="anc10"></a>



 149   }
 150 };
 151 
 152 struct native_nmethod_stats_struct {
 153   int native_nmethod_count;
 154   int native_total_size;
 155   int native_relocation_size;
 156   int native_insts_size;
 157   int native_oops_size;
 158   int native_metadata_size;
 159   void note_native_nmethod(nmethod* nm) {
 160     native_nmethod_count += 1;
 161     native_total_size       += nm-&gt;size();
 162     native_relocation_size  += nm-&gt;relocation_size();
 163     native_insts_size       += nm-&gt;insts_size();
 164     native_oops_size        += nm-&gt;oops_size();
 165     native_metadata_size    += nm-&gt;metadata_size();
 166   }
 167   void print_native_nmethod_stats() {
 168     if (native_nmethod_count == 0)  return;
 169     tty-&gt;print_cr(&quot;Statistics for %d native nmethods:&quot;, native_nmethod_count);
 170     if (native_total_size != 0)       tty-&gt;print_cr(&quot; N. total size  = %d&quot;, native_total_size);
 171     if (native_relocation_size != 0)  tty-&gt;print_cr(&quot; N. relocation  = %d&quot;, native_relocation_size);
 172     if (native_insts_size != 0)       tty-&gt;print_cr(&quot; N. main code   = %d&quot;, native_insts_size);
 173     if (native_oops_size != 0)        tty-&gt;print_cr(&quot; N. oops        = %d&quot;, native_oops_size);
 174     if (native_metadata_size != 0)    tty-&gt;print_cr(&quot; N. metadata    = %d&quot;, native_metadata_size);
 175   }
 176 };
 177 
 178 struct pc_nmethod_stats_struct {
 179   int pc_desc_resets;   // number of resets (= number of caches)
 180   int pc_desc_queries;  // queries to nmethod::find_pc_desc
 181   int pc_desc_approx;   // number of those which have approximate true
 182   int pc_desc_repeats;  // number of _pc_descs[0] hits
 183   int pc_desc_hits;     // number of LRU cache hits
 184   int pc_desc_tests;    // total number of PcDesc examinations
 185   int pc_desc_searches; // total number of quasi-binary search steps
 186   int pc_desc_adds;     // number of LUR cache insertions
 187 
 188   void print_pc_stats() {
 189     tty-&gt;print_cr(&quot;PcDesc Statistics:  %d queries, %.2f comparisons per query&quot;,
 190                   pc_desc_queries,
 191                   (double)(pc_desc_tests + pc_desc_searches)
 192                   / pc_desc_queries);
 193     tty-&gt;print_cr(&quot;  caches=%d queries=%d/%d, hits=%d+%d, tests=%d+%d, adds=%d&quot;,
 194                   pc_desc_resets,
 195                   pc_desc_queries, pc_desc_approx,
 196                   pc_desc_repeats, pc_desc_hits,
 197                   pc_desc_tests, pc_desc_searches, pc_desc_adds);
 198   }
 199 };
 200 
 201 #ifdef COMPILER1
 202 static java_nmethod_stats_struct c1_java_nmethod_stats;
 203 #endif
 204 #ifdef COMPILER2
 205 static java_nmethod_stats_struct c2_java_nmethod_stats;
 206 #endif
 207 #if INCLUDE_JVMCI
 208 static java_nmethod_stats_struct jvmci_java_nmethod_stats;
 209 #endif
 210 static java_nmethod_stats_struct unknown_java_nmethod_stats;
 211 
 212 static native_nmethod_stats_struct native_nmethod_stats;
 213 static pc_nmethod_stats_struct pc_nmethod_stats;
 214 
 215 static void note_java_nmethod(nmethod* nm) {
 216 #ifdef COMPILER1
 217   if (nm-&gt;is_compiled_by_c1()) {
 218     c1_java_nmethod_stats.note_nmethod(nm);
 219   } else
 220 #endif
 221 #ifdef COMPILER2
 222   if (nm-&gt;is_compiled_by_c2()) {
 223     c2_java_nmethod_stats.note_nmethod(nm);
 224   } else
 225 #endif
 226 #if INCLUDE_JVMCI
 227   if (nm-&gt;is_compiled_by_jvmci()) {
 228     jvmci_java_nmethod_stats.note_nmethod(nm);
 229   } else
 230 #endif
 231   {
 232     unknown_java_nmethod_stats.note_nmethod(nm);
 233   }
 234 }
 235 #endif // !PRODUCT
 236 
 237 //---------------------------------------------------------------------------------
 238 
 239 
 240 ExceptionCache::ExceptionCache(Handle exception, address pc, address handler) {
 241   assert(pc != NULL, &quot;Must be non null&quot;);
 242   assert(exception.not_null(), &quot;Must be non null&quot;);
 243   assert(handler != NULL, &quot;Must be non null&quot;);
 244 
 245   _count = 0;
 246   _exception_type = exception-&gt;klass();
 247   _next = NULL;
 248   _purge_list_next = NULL;
 249 
 250   add_address_and_handler(pc,handler);
 251 }
 252 
 253 
 254 address ExceptionCache::match(Handle exception, address pc) {
 255   assert(pc != NULL,&quot;Must be non null&quot;);
 256   assert(exception.not_null(),&quot;Must be non null&quot;);
 257   if (exception-&gt;klass() == exception_type()) {
 258     return (test_address(pc));
 259   }
 260 
 261   return NULL;
 262 }
 263 
 264 
 265 bool ExceptionCache::match_exception_with_space(Handle exception) {
 266   assert(exception.not_null(),&quot;Must be non null&quot;);
 267   if (exception-&gt;klass() == exception_type() &amp;&amp; count() &lt; cache_size) {
 268     return true;
 269   }
 270   return false;
 271 }
 272 
 273 
 274 address ExceptionCache::test_address(address addr) {
 275   int limit = count();
 276   for (int i = 0; i &lt; limit; i++) {
 277     if (pc_at(i) == addr) {
 278       return handler_at(i);
 279     }
 280   }
 281   return NULL;
 282 }
 283 
 284 
 285 bool ExceptionCache::add_address_and_handler(address addr, address handler) {
 286   if (test_address(addr) == handler) return true;
 287 
 288   int index = count();
 289   if (index &lt; cache_size) {
 290     set_pc_at(index, addr);
 291     set_handler_at(index, handler);
 292     increment_count();
 293     return true;
 294   }
 295   return false;
 296 }
 297 
 298 ExceptionCache* ExceptionCache::next() {
 299   return Atomic::load(&amp;_next);
 300 }
 301 
 302 void ExceptionCache::set_next(ExceptionCache *ec) {
<a name="11" id="anc11"></a><span class="line-modified"> 303   Atomic::store(ec, &amp;_next);</span>
 304 }
 305 
 306 //-----------------------------------------------------------------------------
 307 
 308 
 309 // Helper used by both find_pc_desc methods.
 310 static inline bool match_desc(PcDesc* pc, int pc_offset, bool approximate) {
 311   NOT_PRODUCT(++pc_nmethod_stats.pc_desc_tests);
 312   if (!approximate)
 313     return pc-&gt;pc_offset() == pc_offset;
 314   else
 315     return (pc-1)-&gt;pc_offset() &lt; pc_offset &amp;&amp; pc_offset &lt;= pc-&gt;pc_offset();
 316 }
 317 
 318 void PcDescCache::reset_to(PcDesc* initial_pc_desc) {
 319   if (initial_pc_desc == NULL) {
 320     _pc_descs[0] = NULL; // native method; no PcDescs at all
 321     return;
 322   }
 323   NOT_PRODUCT(++pc_nmethod_stats.pc_desc_resets);
 324   // reset the cache by filling it with benign (non-null) values
 325   assert(initial_pc_desc-&gt;pc_offset() &lt; 0, &quot;must be sentinel&quot;);
 326   for (int i = 0; i &lt; cache_size; i++)
 327     _pc_descs[i] = initial_pc_desc;
 328 }
 329 
 330 PcDesc* PcDescCache::find_pc_desc(int pc_offset, bool approximate) {
 331   NOT_PRODUCT(++pc_nmethod_stats.pc_desc_queries);
 332   NOT_PRODUCT(if (approximate) ++pc_nmethod_stats.pc_desc_approx);
 333 
 334   // Note: one might think that caching the most recently
 335   // read value separately would be a win, but one would be
 336   // wrong.  When many threads are updating it, the cache
 337   // line it&#39;s in would bounce between caches, negating
 338   // any benefit.
 339 
 340   // In order to prevent race conditions do not load cache elements
 341   // repeatedly, but use a local copy:
 342   PcDesc* res;
 343 
 344   // Step one:  Check the most recently added value.
 345   res = _pc_descs[0];
 346   if (res == NULL) return NULL;  // native method; no PcDescs at all
 347   if (match_desc(res, pc_offset, approximate)) {
 348     NOT_PRODUCT(++pc_nmethod_stats.pc_desc_repeats);
 349     return res;
 350   }
 351 
 352   // Step two:  Check the rest of the LRU cache.
 353   for (int i = 1; i &lt; cache_size; ++i) {
 354     res = _pc_descs[i];
 355     if (res-&gt;pc_offset() &lt; 0) break;  // optimization: skip empty cache
 356     if (match_desc(res, pc_offset, approximate)) {
 357       NOT_PRODUCT(++pc_nmethod_stats.pc_desc_hits);
 358       return res;
 359     }
 360   }
 361 
 362   // Report failure.
 363   return NULL;
 364 }
 365 
 366 void PcDescCache::add_pc_desc(PcDesc* pc_desc) {
 367   NOT_PRODUCT(++pc_nmethod_stats.pc_desc_adds);
 368   // Update the LRU cache by shifting pc_desc forward.
 369   for (int i = 0; i &lt; cache_size; i++)  {
 370     PcDesc* next = _pc_descs[i];
 371     _pc_descs[i] = pc_desc;
 372     pc_desc = next;
 373   }
 374 }
 375 
 376 // adjust pcs_size so that it is a multiple of both oopSize and
 377 // sizeof(PcDesc) (assumes that if sizeof(PcDesc) is not a multiple
 378 // of oopSize, then 2*sizeof(PcDesc) is)
 379 static int adjust_pcs_size(int pcs_size) {
 380   int nsize = align_up(pcs_size,   oopSize);
 381   if ((nsize % sizeof(PcDesc)) != 0) {
 382     nsize = pcs_size + sizeof(PcDesc);
 383   }
 384   assert((nsize % oopSize) == 0, &quot;correct alignment&quot;);
 385   return nsize;
 386 }
 387 
 388 
 389 int nmethod::total_size() const {
 390   return
 391     consts_size()        +
 392     insts_size()         +
 393     stub_size()          +
 394     scopes_data_size()   +
 395     scopes_pcs_size()    +
 396     handler_table_size() +
 397     nul_chk_table_size();
 398 }
 399 
 400 address* nmethod::orig_pc_addr(const frame* fr) {
 401   return (address*) ((address)fr-&gt;unextended_sp() + _orig_pc_offset);
 402 }
 403 
 404 const char* nmethod::compile_kind() const {
 405   if (is_osr_method())     return &quot;osr&quot;;
 406   if (method() != NULL &amp;&amp; is_native_method())  return &quot;c2n&quot;;
 407   return NULL;
 408 }
 409 
 410 // Fill in default values for various flag fields
 411 void nmethod::init_defaults() {
 412   _state                      = not_installed;
 413   _has_flushed_dependencies   = 0;
 414   _lock_count                 = 0;
 415   _stack_traversal_mark       = 0;
<a name="12" id="anc12"></a><span class="line-modified"> 416   _unload_reported            = false; // jvmti state</span>

 417   _is_far_code                = false; // nmethods are located in CodeCache
 418 
 419 #ifdef ASSERT
 420   _oops_are_stale             = false;
 421 #endif
 422 
 423   _oops_do_mark_link       = NULL;
<a name="13" id="anc13"></a><span class="line-removed"> 424   _jmethod_id              = NULL;</span>
 425   _osr_link                = NULL;
 426 #if INCLUDE_RTM_OPT
 427   _rtm_state               = NoRTM;
 428 #endif
<a name="14" id="anc14"></a><span class="line-removed"> 429 #if INCLUDE_JVMCI</span>
<span class="line-removed"> 430   _jvmci_installed_code   = NULL;</span>
<span class="line-removed"> 431   _speculation_log        = NULL;</span>
<span class="line-removed"> 432   _jvmci_installed_code_triggers_invalidation = false;</span>
<span class="line-removed"> 433 #endif</span>
 434 }
 435 
 436 nmethod* nmethod::new_native_nmethod(const methodHandle&amp; method,
 437   int compile_id,
 438   CodeBuffer *code_buffer,
 439   int vep_offset,
 440   int frame_complete,
 441   int frame_size,
 442   ByteSize basic_lock_owner_sp_offset,
 443   ByteSize basic_lock_sp_offset,
 444   OopMapSet* oop_maps) {
 445   code_buffer-&gt;finalize_oop_references(method);
 446   // create nmethod
 447   nmethod* nm = NULL;
 448   {
<a name="15" id="anc15"></a><span class="line-modified"> 449     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
 450     int native_nmethod_size = CodeBlob::allocation_size(code_buffer, sizeof(nmethod));
<a name="16" id="anc16"></a>
 451     CodeOffsets offsets;
 452     offsets.set_value(CodeOffsets::Verified_Entry, vep_offset);
 453     offsets.set_value(CodeOffsets::Frame_Complete, frame_complete);
<a name="17" id="anc17"></a><span class="line-modified"> 454     nm = new (native_nmethod_size, CompLevel_none) nmethod(method(), compiler_none, native_nmethod_size,</span>
<span class="line-modified"> 455                                             compile_id, &amp;offsets,</span>
<span class="line-modified"> 456                                             code_buffer, frame_size,</span>
<span class="line-modified"> 457                                             basic_lock_owner_sp_offset,</span>
<span class="line-modified"> 458                                             basic_lock_sp_offset, oop_maps);</span>


 459     NOT_PRODUCT(if (nm != NULL)  native_nmethod_stats.note_native_nmethod(nm));
 460   }
 461 
 462   if (nm != NULL) {
 463     // verify nmethod
 464     debug_only(nm-&gt;verify();) // might block
 465 
 466     nm-&gt;log_new_nmethod();
<a name="18" id="anc18"></a><span class="line-removed"> 467     nm-&gt;make_in_use();</span>
 468   }
 469   return nm;
 470 }
 471 
 472 nmethod* nmethod::new_nmethod(const methodHandle&amp; method,
 473   int compile_id,
 474   int entry_bci,
 475   CodeOffsets* offsets,
 476   int orig_pc_offset,
 477   DebugInformationRecorder* debug_info,
 478   Dependencies* dependencies,
 479   CodeBuffer* code_buffer, int frame_size,
 480   OopMapSet* oop_maps,
 481   ExceptionHandlerTable* handler_table,
 482   ImplicitExceptionTable* nul_chk_table,
 483   AbstractCompiler* compiler,
 484   int comp_level
 485 #if INCLUDE_JVMCI
<a name="19" id="anc19"></a><span class="line-modified"> 486   , jweak installed_code,</span>
<span class="line-modified"> 487   jweak speculationLog</span>



 488 #endif
 489 )
 490 {
 491   assert(debug_info-&gt;oop_recorder() == code_buffer-&gt;oop_recorder(), &quot;shared OR&quot;);
 492   code_buffer-&gt;finalize_oop_references(method);
 493   // create nmethod
 494   nmethod* nm = NULL;
<a name="20" id="anc20"></a><span class="line-modified"> 495   { MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>



 496     int nmethod_size =
 497       CodeBlob::allocation_size(code_buffer, sizeof(nmethod))
 498       + adjust_pcs_size(debug_info-&gt;pcs_size())
 499       + align_up((int)dependencies-&gt;size_in_bytes(), oopSize)
 500       + align_up(handler_table-&gt;size_in_bytes()    , oopSize)
 501       + align_up(nul_chk_table-&gt;size_in_bytes()    , oopSize)
<a name="21" id="anc21"></a>



 502       + align_up(debug_info-&gt;data_size()           , oopSize);
 503 
 504     nm = new (nmethod_size, comp_level)
 505     nmethod(method(), compiler-&gt;type(), nmethod_size, compile_id, entry_bci, offsets,
 506             orig_pc_offset, debug_info, dependencies, code_buffer, frame_size,
 507             oop_maps,
 508             handler_table,
 509             nul_chk_table,
 510             compiler,
 511             comp_level
 512 #if INCLUDE_JVMCI
<a name="22" id="anc22"></a><span class="line-modified"> 513             , installed_code,</span>
<span class="line-modified"> 514             speculationLog</span>

 515 #endif
 516             );
 517 
 518     if (nm != NULL) {
<a name="23" id="anc23"></a>





 519       // To make dependency checking during class loading fast, record
 520       // the nmethod dependencies in the classes it is dependent on.
 521       // This allows the dependency checking code to simply walk the
 522       // class hierarchy above the loaded class, checking only nmethods
 523       // which are dependent on those classes.  The slow way is to
 524       // check every nmethod for dependencies which makes it linear in
 525       // the number of methods compiled.  For applications with a lot
 526       // classes the slow way is too slow.
 527       for (Dependencies::DepStream deps(nm); deps.next(); ) {
 528         if (deps.type() == Dependencies::call_site_target_value) {
 529           // CallSite dependencies are managed on per-CallSite instance basis.
 530           oop call_site = deps.argument_oop(0);
 531           MethodHandles::add_dependent_nmethod(call_site, nm);
 532         } else {
 533           Klass* klass = deps.context_type();
 534           if (klass == NULL) {
 535             continue;  // ignore things like evol_method
 536           }
 537           // record this nmethod as dependent on this klass
 538           InstanceKlass::cast(klass)-&gt;add_dependent_nmethod(nm);
 539         }
 540       }
 541       NOT_PRODUCT(if (nm != NULL)  note_java_nmethod(nm));
 542     }
 543   }
 544   // Do verification and logging outside CodeCache_lock.
 545   if (nm != NULL) {
 546     // Safepoints in nmethod::verify aren&#39;t allowed because nm hasn&#39;t been installed yet.
 547     DEBUG_ONLY(nm-&gt;verify();)
 548     nm-&gt;log_new_nmethod();
 549   }
 550   return nm;
 551 }
 552 
 553 // For native wrappers
 554 nmethod::nmethod(
 555   Method* method,
 556   CompilerType type,
 557   int nmethod_size,
 558   int compile_id,
 559   CodeOffsets* offsets,
 560   CodeBuffer* code_buffer,
 561   int frame_size,
 562   ByteSize basic_lock_owner_sp_offset,
 563   ByteSize basic_lock_sp_offset,
 564   OopMapSet* oop_maps )
 565   : CompiledMethod(method, &quot;native nmethod&quot;, type, nmethod_size, sizeof(nmethod), code_buffer, offsets-&gt;value(CodeOffsets::Frame_Complete), frame_size, oop_maps, false),
 566   _is_unloading_state(0),
 567   _native_receiver_sp_offset(basic_lock_owner_sp_offset),
 568   _native_basic_lock_sp_offset(basic_lock_sp_offset)
 569 {
 570   {
<a name="24" id="anc24"></a><span class="line-modified"> 571     int scopes_data_offset = 0;</span>
<span class="line-modified"> 572     int deoptimize_offset       = 0;</span>
<span class="line-modified"> 573     int deoptimize_mh_offset    = 0;</span>
 574 
 575     debug_only(NoSafepointVerifier nsv;)
 576     assert_locked_or_safepoint(CodeCache_lock);
 577 
 578     init_defaults();
 579     _entry_bci               = InvocationEntryBci;
 580     // We have no exception handler or deopt handler make the
 581     // values something that will never match a pc like the nmethod vtable entry
 582     _exception_offset        = 0;
 583     _orig_pc_offset          = 0;
 584 
 585     _consts_offset           = data_offset();
 586     _stub_offset             = data_offset();
 587     _oops_offset             = data_offset();
 588     _metadata_offset         = _oops_offset         + align_up(code_buffer-&gt;total_oop_size(), oopSize);
 589     scopes_data_offset       = _metadata_offset     + align_up(code_buffer-&gt;total_metadata_size(), wordSize);
 590     _scopes_pcs_offset       = scopes_data_offset;
 591     _dependencies_offset     = _scopes_pcs_offset;
 592     _handler_table_offset    = _dependencies_offset;
 593     _nul_chk_table_offset    = _handler_table_offset;
<a name="25" id="anc25"></a>




 594     _nmethod_end_offset      = _nul_chk_table_offset;
<a name="26" id="anc26"></a>
 595     _compile_id              = compile_id;
 596     _comp_level              = CompLevel_none;
 597     _entry_point             = code_begin()          + offsets-&gt;value(CodeOffsets::Entry);
 598     _verified_entry_point    = code_begin()          + offsets-&gt;value(CodeOffsets::Verified_Entry);
 599     _osr_entry_point         = NULL;
 600     _exception_cache         = NULL;
 601     _pc_desc_container.reset_to(NULL);
 602     _hotness_counter         = NMethodSweeper::hotness_counter_reset_val();
 603 
 604     _scopes_data_begin = (address) this + scopes_data_offset;
 605     _deopt_handler_begin = (address) this + deoptimize_offset;
 606     _deopt_mh_handler_begin = (address) this + deoptimize_mh_offset;
 607 
 608     code_buffer-&gt;copy_code_and_locs_to(this);
 609     code_buffer-&gt;copy_values_to(this);
 610 
 611     clear_unloading_state();
 612 
 613     Universe::heap()-&gt;register_nmethod(this);
 614     debug_only(Universe::heap()-&gt;verify_nmethod(this));
 615 
 616     CodeCache::commit(this);
 617   }
 618 
 619   if (PrintNativeNMethods || PrintDebugInfo || PrintRelocations || PrintDependencies) {
 620     ttyLocker ttyl;  // keep the following output all in one block
 621     // This output goes directly to the tty, not the compiler log.
 622     // To enable tools to match it up with the compilation activity,
 623     // be sure to tag this tty output with the compile ID.
 624     if (xtty != NULL) {
 625       xtty-&gt;begin_head(&quot;print_native_nmethod&quot;);
 626       xtty-&gt;method(_method);
 627       xtty-&gt;stamp();
 628       xtty-&gt;end_head(&quot; address=&#39;&quot; INTPTR_FORMAT &quot;&#39;&quot;, (intptr_t) this);
 629     }
<a name="27" id="anc27"></a><span class="line-modified"> 630     // print the header part first</span>
<span class="line-modified"> 631     print();</span>
<span class="line-removed"> 632     // then print the requested information</span>
 633     if (PrintNativeNMethods) {
<a name="28" id="anc28"></a>
 634       print_code();
<a name="29" id="anc29"></a><span class="line-modified"> 635       if (oop_maps != NULL) {</span>
<span class="line-modified"> 636         oop_maps-&gt;print();</span>






 637       }
<a name="30" id="anc30"></a>


 638     }
<a name="31" id="anc31"></a><span class="line-modified"> 639     if (PrintRelocations) {</span>
<span class="line-modified"> 640       print_relocations();</span>




 641     }
<a name="32" id="anc32"></a>
 642     if (xtty != NULL) {
 643       xtty-&gt;tail(&quot;print_native_nmethod&quot;);
 644     }
 645   }
 646 }
 647 
 648 void* nmethod::operator new(size_t size, int nmethod_size, int comp_level) throw () {
 649   return CodeCache::allocate(nmethod_size, CodeCache::get_code_blob_type(comp_level));
 650 }
 651 
 652 nmethod::nmethod(
 653   Method* method,
 654   CompilerType type,
 655   int nmethod_size,
 656   int compile_id,
 657   int entry_bci,
 658   CodeOffsets* offsets,
 659   int orig_pc_offset,
 660   DebugInformationRecorder* debug_info,
 661   Dependencies* dependencies,
 662   CodeBuffer *code_buffer,
 663   int frame_size,
 664   OopMapSet* oop_maps,
 665   ExceptionHandlerTable* handler_table,
 666   ImplicitExceptionTable* nul_chk_table,
 667   AbstractCompiler* compiler,
 668   int comp_level
 669 #if INCLUDE_JVMCI
<a name="33" id="anc33"></a><span class="line-modified"> 670   , jweak installed_code,</span>
<span class="line-modified"> 671   jweak speculation_log</span>

 672 #endif
 673   )
 674   : CompiledMethod(method, &quot;nmethod&quot;, type, nmethod_size, sizeof(nmethod), code_buffer, offsets-&gt;value(CodeOffsets::Frame_Complete), frame_size, oop_maps, false),
 675   _is_unloading_state(0),
 676   _native_receiver_sp_offset(in_ByteSize(-1)),
 677   _native_basic_lock_sp_offset(in_ByteSize(-1))
 678 {
 679   assert(debug_info-&gt;oop_recorder() == code_buffer-&gt;oop_recorder(), &quot;shared OR&quot;);
 680   {
 681     debug_only(NoSafepointVerifier nsv;)
 682     assert_locked_or_safepoint(CodeCache_lock);
 683 
 684     _deopt_handler_begin = (address) this;
 685     _deopt_mh_handler_begin = (address) this;
 686 
 687     init_defaults();
 688     _entry_bci               = entry_bci;
 689     _compile_id              = compile_id;
 690     _comp_level              = comp_level;
 691     _orig_pc_offset          = orig_pc_offset;
 692     _hotness_counter         = NMethodSweeper::hotness_counter_reset_val();
 693 
 694     // Section offsets
 695     _consts_offset           = content_offset()      + code_buffer-&gt;total_offset_of(code_buffer-&gt;consts());
 696     _stub_offset             = content_offset()      + code_buffer-&gt;total_offset_of(code_buffer-&gt;stubs());
 697     set_ctable_begin(header_begin() + _consts_offset);
 698 
 699 #if INCLUDE_JVMCI
<a name="34" id="anc34"></a><span class="line-removed"> 700     _jvmci_installed_code = installed_code;</span>
<span class="line-removed"> 701     _speculation_log = speculation_log;</span>
<span class="line-removed"> 702     oop obj = JNIHandles::resolve(installed_code);</span>
<span class="line-removed"> 703     if (obj == NULL || (obj-&gt;is_a(HotSpotNmethod::klass()) &amp;&amp; HotSpotNmethod::isDefault(obj))) {</span>
<span class="line-removed"> 704       _jvmci_installed_code_triggers_invalidation = false;</span>
<span class="line-removed"> 705     } else {</span>
<span class="line-removed"> 706       _jvmci_installed_code_triggers_invalidation = true;</span>
<span class="line-removed"> 707     }</span>
<span class="line-removed"> 708 </span>
 709     if (compiler-&gt;is_jvmci()) {
 710       // JVMCI might not produce any stub sections
 711       if (offsets-&gt;value(CodeOffsets::Exceptions) != -1) {
 712         _exception_offset        = code_offset()          + offsets-&gt;value(CodeOffsets::Exceptions);
 713       } else {
 714         _exception_offset = -1;
 715       }
 716       if (offsets-&gt;value(CodeOffsets::Deopt) != -1) {
 717         _deopt_handler_begin       = (address) this + code_offset()          + offsets-&gt;value(CodeOffsets::Deopt);
 718       } else {
 719         _deopt_handler_begin = NULL;
 720       }
 721       if (offsets-&gt;value(CodeOffsets::DeoptMH) != -1) {
 722         _deopt_mh_handler_begin  = (address) this + code_offset()          + offsets-&gt;value(CodeOffsets::DeoptMH);
 723       } else {
 724         _deopt_mh_handler_begin = NULL;
 725       }
<a name="35" id="anc35"></a><span class="line-modified"> 726     } else {</span>
<span class="line-removed"> 727 #endif</span>
<span class="line-removed"> 728     // Exception handler and deopt handler are in the stub section</span>
<span class="line-removed"> 729     assert(offsets-&gt;value(CodeOffsets::Exceptions) != -1, &quot;must be set&quot;);</span>
<span class="line-removed"> 730     assert(offsets-&gt;value(CodeOffsets::Deopt     ) != -1, &quot;must be set&quot;);</span>
<span class="line-removed"> 731 </span>
<span class="line-removed"> 732     _exception_offset       = _stub_offset          + offsets-&gt;value(CodeOffsets::Exceptions);</span>
<span class="line-removed"> 733     _deopt_handler_begin    = (address) this + _stub_offset          + offsets-&gt;value(CodeOffsets::Deopt);</span>
<span class="line-removed"> 734     if (offsets-&gt;value(CodeOffsets::DeoptMH) != -1) {</span>
<span class="line-removed"> 735       _deopt_mh_handler_begin  = (address) this + _stub_offset          + offsets-&gt;value(CodeOffsets::DeoptMH);</span>
<span class="line-removed"> 736     } else {</span>
<span class="line-removed"> 737       _deopt_mh_handler_begin  = NULL;</span>
<span class="line-removed"> 738 #if INCLUDE_JVMCI</span>
<span class="line-removed"> 739     }</span>
 740 #endif
<a name="36" id="anc36"></a>











 741     }
 742     if (offsets-&gt;value(CodeOffsets::UnwindHandler) != -1) {
 743       _unwind_handler_offset = code_offset()         + offsets-&gt;value(CodeOffsets::UnwindHandler);
 744     } else {
 745       _unwind_handler_offset = -1;
 746     }
 747 
 748     _oops_offset             = data_offset();
 749     _metadata_offset         = _oops_offset          + align_up(code_buffer-&gt;total_oop_size(), oopSize);
 750     int scopes_data_offset   = _metadata_offset      + align_up(code_buffer-&gt;total_metadata_size(), wordSize);
 751 
 752     _scopes_pcs_offset       = scopes_data_offset    + align_up(debug_info-&gt;data_size       (), oopSize);
 753     _dependencies_offset     = _scopes_pcs_offset    + adjust_pcs_size(debug_info-&gt;pcs_size());
 754     _handler_table_offset    = _dependencies_offset  + align_up((int)dependencies-&gt;size_in_bytes (), oopSize);
 755     _nul_chk_table_offset    = _handler_table_offset + align_up(handler_table-&gt;size_in_bytes(), oopSize);
<a name="37" id="anc37"></a>




 756     _nmethod_end_offset      = _nul_chk_table_offset + align_up(nul_chk_table-&gt;size_in_bytes(), oopSize);
<a name="38" id="anc38"></a>
 757     _entry_point             = code_begin()          + offsets-&gt;value(CodeOffsets::Entry);
 758     _verified_entry_point    = code_begin()          + offsets-&gt;value(CodeOffsets::Verified_Entry);
 759     _osr_entry_point         = code_begin()          + offsets-&gt;value(CodeOffsets::OSR_Entry);
 760     _exception_cache         = NULL;
<a name="39" id="anc39"></a><span class="line-modified"> 761 </span>
<span class="line-removed"> 762     _scopes_data_begin = (address) this + scopes_data_offset;</span>
 763 
 764     _pc_desc_container.reset_to(scopes_pcs_begin());
 765 
 766     code_buffer-&gt;copy_code_and_locs_to(this);
 767     // Copy contents of ScopeDescRecorder to nmethod
 768     code_buffer-&gt;copy_values_to(this);
 769     debug_info-&gt;copy_to(this);
 770     dependencies-&gt;copy_to(this);
 771     clear_unloading_state();
 772 
 773     Universe::heap()-&gt;register_nmethod(this);
 774     debug_only(Universe::heap()-&gt;verify_nmethod(this));
 775 
 776     CodeCache::commit(this);
 777 
 778     // Copy contents of ExceptionHandlerTable to nmethod
 779     handler_table-&gt;copy_to(this);
 780     nul_chk_table-&gt;copy_to(this);
 781 
<a name="40" id="anc40"></a>






 782     // we use the information of entry points to find out if a method is
 783     // static or non static
 784     assert(compiler-&gt;is_c2() || compiler-&gt;is_jvmci() ||
 785            _method-&gt;is_static() == (entry_point() == _verified_entry_point),
 786            &quot; entry points must be same for static methods and vice versa&quot;);
 787   }
 788 }
 789 
 790 // Print a short set of xml attributes to identify this nmethod.  The
 791 // output should be embedded in some other element.
 792 void nmethod::log_identity(xmlStream* log) const {
 793   log-&gt;print(&quot; compile_id=&#39;%d&#39;&quot;, compile_id());
 794   const char* nm_kind = compile_kind();
 795   if (nm_kind != NULL)  log-&gt;print(&quot; compile_kind=&#39;%s&#39;&quot;, nm_kind);
 796   log-&gt;print(&quot; compiler=&#39;%s&#39;&quot;, compiler_name());
 797   if (TieredCompilation) {
 798     log-&gt;print(&quot; level=&#39;%d&#39;&quot;, comp_level());
 799   }
 800 #if INCLUDE_JVMCI
<a name="41" id="anc41"></a><span class="line-modified"> 801     char buffer[O_BUFLEN];</span>
<span class="line-modified"> 802     char* jvmci_name = jvmci_installed_code_name(buffer, O_BUFLEN);</span>
 803     if (jvmci_name != NULL) {
<a name="42" id="anc42"></a><span class="line-modified"> 804       log-&gt;print(&quot; jvmci_installed_code_name=&#39;&quot;);</span>
 805       log-&gt;text(&quot;%s&quot;, jvmci_name);
 806       log-&gt;print(&quot;&#39;&quot;);
 807     }
<a name="43" id="anc43"></a>
 808 #endif
 809 }
 810 
 811 
 812 #define LOG_OFFSET(log, name)                    \
 813   if (p2i(name##_end()) - p2i(name##_begin())) \
 814     log-&gt;print(&quot; &quot; XSTR(name) &quot;_offset=&#39;&quot; INTX_FORMAT &quot;&#39;&quot;    , \
 815                p2i(name##_begin()) - p2i(this))
 816 
 817 
 818 void nmethod::log_new_nmethod() const {
 819   if (LogCompilation &amp;&amp; xtty != NULL) {
 820     ttyLocker ttyl;
 821     HandleMark hm;
 822     xtty-&gt;begin_elem(&quot;nmethod&quot;);
 823     log_identity(xtty);
 824     xtty-&gt;print(&quot; entry=&#39;&quot; INTPTR_FORMAT &quot;&#39; size=&#39;%d&#39;&quot;, p2i(code_begin()), size());
 825     xtty-&gt;print(&quot; address=&#39;&quot; INTPTR_FORMAT &quot;&#39;&quot;, p2i(this));
 826 
 827     LOG_OFFSET(xtty, relocation);
 828     LOG_OFFSET(xtty, consts);
 829     LOG_OFFSET(xtty, insts);
 830     LOG_OFFSET(xtty, stub);
 831     LOG_OFFSET(xtty, scopes_data);
 832     LOG_OFFSET(xtty, scopes_pcs);
 833     LOG_OFFSET(xtty, dependencies);
 834     LOG_OFFSET(xtty, handler_table);
 835     LOG_OFFSET(xtty, nul_chk_table);
 836     LOG_OFFSET(xtty, oops);
 837     LOG_OFFSET(xtty, metadata);
 838 
 839     xtty-&gt;method(method());
 840     xtty-&gt;stamp();
 841     xtty-&gt;end_elem();
 842   }
 843 }
 844 
 845 #undef LOG_OFFSET
 846 
 847 
 848 // Print out more verbose output usually for a newly created nmethod.
 849 void nmethod::print_on(outputStream* st, const char* msg) const {
 850   if (st != NULL) {
 851     ttyLocker ttyl;
 852     if (WizardMode) {
 853       CompileTask::print(st, this, msg, /*short_form:*/ true);
 854       st-&gt;print_cr(&quot; (&quot; INTPTR_FORMAT &quot;)&quot;, p2i(this));
 855     } else {
 856       CompileTask::print(st, this, msg, /*short_form:*/ false);
 857     }
 858   }
 859 }
 860 
 861 void nmethod::maybe_print_nmethod(DirectiveSet* directive) {
 862   bool printnmethods = directive-&gt;PrintAssemblyOption || directive-&gt;PrintNMethodsOption;
 863   if (printnmethods || PrintDebugInfo || PrintRelocations || PrintDependencies || PrintExceptionHandlers) {
 864     print_nmethod(printnmethods);
 865   }
 866 }
 867 
 868 void nmethod::print_nmethod(bool printmethod) {
 869   ttyLocker ttyl;  // keep the following output all in one block
 870   if (xtty != NULL) {
 871     xtty-&gt;begin_head(&quot;print_nmethod&quot;);
<a name="44" id="anc44"></a>
 872     xtty-&gt;stamp();
 873     xtty-&gt;end_head();
 874   }
<a name="45" id="anc45"></a><span class="line-modified"> 875   // print the header part first</span>
<span class="line-modified"> 876   print();</span>
<span class="line-removed"> 877   // then print the requested information</span>
 878   if (printmethod) {
<a name="46" id="anc46"></a><span class="line-modified"> 879     print_code();</span>
<span class="line-modified"> 880     print_pcs();</span>
<span class="line-modified"> 881     if (oop_maps()) {</span>
<span class="line-modified"> 882       oop_maps()-&gt;print();</span>























 883     }
<a name="47" id="anc47"></a>


 884   }
<a name="48" id="anc48"></a><span class="line-modified"> 885   if (printmethod || PrintDebugInfo || CompilerOracle::has_option_string(_method, &quot;PrintDebugInfo&quot;)) {</span>
<span class="line-modified"> 886     print_scopes();</span>
<span class="line-modified"> 887   }</span>
<span class="line-modified"> 888   if (printmethod || PrintRelocations || CompilerOracle::has_option_string(_method, &quot;PrintRelocations&quot;)) {</span>
<span class="line-modified"> 889     print_relocations();</span>
<span class="line-modified"> 890   }</span>
<span class="line-modified"> 891   if (printmethod || PrintDependencies || CompilerOracle::has_option_string(_method, &quot;PrintDependencies&quot;)) {</span>
<span class="line-modified"> 892     print_dependencies();</span>
<span class="line-modified"> 893   }</span>
<span class="line-modified"> 894   if (printmethod || PrintExceptionHandlers) {</span>
<span class="line-modified"> 895     print_handler_table();</span>
<span class="line-modified"> 896     print_nul_chk_table();</span>
<span class="line-modified"> 897   }</span>
<span class="line-modified"> 898   if (printmethod) {</span>
<span class="line-modified"> 899     print_recorded_oops();</span>
<span class="line-modified"> 900     print_recorded_metadata();</span>













 901   }
<a name="49" id="anc49"></a>

 902   if (xtty != NULL) {
 903     xtty-&gt;tail(&quot;print_nmethod&quot;);
 904   }
 905 }
 906 
 907 
 908 // Promote one word from an assembly-time handle to a live embedded oop.
 909 inline void nmethod::initialize_immediate_oop(oop* dest, jobject handle) {
 910   if (handle == NULL ||
 911       // As a special case, IC oops are initialized to 1 or -1.
 912       handle == (jobject) Universe::non_oop_word()) {
 913     (*dest) = (oop) handle;
 914   } else {
 915     (*dest) = JNIHandles::resolve_non_null(handle);
 916   }
 917 }
 918 
 919 
 920 // Have to have the same name because it&#39;s called by a template
 921 void nmethod::copy_values(GrowableArray&lt;jobject&gt;* array) {
 922   int length = array-&gt;length();
 923   assert((address)(oops_begin() + length) &lt;= (address)oops_end(), &quot;oops big enough&quot;);
 924   oop* dest = oops_begin();
 925   for (int index = 0 ; index &lt; length; index++) {
 926     initialize_immediate_oop(&amp;dest[index], array-&gt;at(index));
 927   }
 928 
 929   // Now we can fix up all the oops in the code.  We need to do this
 930   // in the code because the assembler uses jobjects as placeholders.
 931   // The code and relocations have already been initialized by the
 932   // CodeBlob constructor, so it is valid even at this early point to
 933   // iterate over relocations and patch the code.
 934   fix_oop_relocations(NULL, NULL, /*initialize_immediates=*/ true);
 935 }
 936 
 937 void nmethod::copy_values(GrowableArray&lt;Metadata*&gt;* array) {
 938   int length = array-&gt;length();
 939   assert((address)(metadata_begin() + length) &lt;= (address)metadata_end(), &quot;big enough&quot;);
 940   Metadata** dest = metadata_begin();
 941   for (int index = 0 ; index &lt; length; index++) {
 942     dest[index] = array-&gt;at(index);
 943   }
 944 }
 945 
 946 void nmethod::fix_oop_relocations(address begin, address end, bool initialize_immediates) {
 947   // re-patch all oop-bearing instructions, just in case some oops moved
 948   RelocIterator iter(this, begin, end);
 949   while (iter.next()) {
 950     if (iter.type() == relocInfo::oop_type) {
 951       oop_Relocation* reloc = iter.oop_reloc();
 952       if (initialize_immediates &amp;&amp; reloc-&gt;oop_is_immediate()) {
 953         oop* dest = reloc-&gt;oop_addr();
<a name="50" id="anc50"></a><span class="line-modified"> 954         initialize_immediate_oop(dest, (jobject) *dest);</span>
 955       }
 956       // Refresh the oop-related bits of this instruction.
 957       reloc-&gt;fix_oop_relocation();
 958     } else if (iter.type() == relocInfo::metadata_type) {
 959       metadata_Relocation* reloc = iter.metadata_reloc();
 960       reloc-&gt;fix_metadata_relocation();
 961     }
 962   }
 963 }
 964 
 965 
 966 void nmethod::verify_clean_inline_caches() {
 967   assert(CompiledICLocker::is_safe(this), &quot;mt unsafe call&quot;);
 968 
 969   ResourceMark rm;
 970   RelocIterator iter(this, oops_reloc_begin());
 971   while(iter.next()) {
 972     switch(iter.type()) {
 973       case relocInfo::virtual_call_type:
 974       case relocInfo::opt_virtual_call_type: {
 975         CompiledIC *ic = CompiledIC_at(&amp;iter);
 976         // Ok, to lookup references to zombies here
 977         CodeBlob *cb = CodeCache::find_blob_unsafe(ic-&gt;ic_destination());
 978         assert(cb != NULL, &quot;destination not in CodeBlob?&quot;);
 979         nmethod* nm = cb-&gt;as_nmethod_or_null();
 980         if( nm != NULL ) {
 981           // Verify that inline caches pointing to both zombie and not_entrant methods are clean
 982           if (!nm-&gt;is_in_use() || (nm-&gt;method()-&gt;code() != nm)) {
 983             assert(ic-&gt;is_clean(), &quot;IC should be clean&quot;);
 984           }
 985         }
 986         break;
 987       }
 988       case relocInfo::static_call_type: {
 989         CompiledStaticCall *csc = compiledStaticCall_at(iter.reloc());
 990         CodeBlob *cb = CodeCache::find_blob_unsafe(csc-&gt;destination());
 991         assert(cb != NULL, &quot;destination not in CodeBlob?&quot;);
 992         nmethod* nm = cb-&gt;as_nmethod_or_null();
 993         if( nm != NULL ) {
 994           // Verify that inline caches pointing to both zombie and not_entrant methods are clean
 995           if (!nm-&gt;is_in_use() || (nm-&gt;method()-&gt;code() != nm)) {
 996             assert(csc-&gt;is_clean(), &quot;IC should be clean&quot;);
 997           }
 998         }
 999         break;
1000       }
1001       default:
1002         break;
1003     }
1004   }
1005 }
1006 
1007 // This is a private interface with the sweeper.
1008 void nmethod::mark_as_seen_on_stack() {
1009   assert(is_alive(), &quot;Must be an alive method&quot;);
1010   // Set the traversal mark to ensure that the sweeper does 2
1011   // cleaning passes before moving to zombie.
1012   set_stack_traversal_mark(NMethodSweeper::traversal_count());
1013 }
1014 
1015 // Tell if a non-entrant method can be converted to a zombie (i.e.,
1016 // there are no activations on the stack, not in use by the VM,
1017 // and not in use by the ServiceThread)
1018 bool nmethod::can_convert_to_zombie() {
1019   // Note that this is called when the sweeper has observed the nmethod to be
1020   // not_entrant. However, with concurrent code cache unloading, the state
1021   // might have moved on to unloaded if it is_unloading(), due to racing
1022   // concurrent GC threads.
1023   assert(is_not_entrant() || is_unloading(), &quot;must be a non-entrant method&quot;);
1024 
1025   // Since the nmethod sweeper only does partial sweep the sweeper&#39;s traversal
1026   // count can be greater than the stack traversal count before it hits the
1027   // nmethod for the second time.
1028   // If an is_unloading() nmethod is still not_entrant, then it is not safe to
1029   // convert it to zombie due to GC unloading interactions. However, if it
1030   // has become unloaded, then it is okay to convert such nmethods to zombie.
1031   return stack_traversal_mark() + 1 &lt; NMethodSweeper::traversal_count() &amp;&amp;
1032          !is_locked_by_vm() &amp;&amp; (!is_unloading() || is_unloaded());
1033 }
1034 
1035 void nmethod::inc_decompile_count() {
1036   if (!is_compiled_by_c2() &amp;&amp; !is_compiled_by_jvmci()) return;
1037   // Could be gated by ProfileTraps, but do not bother...
1038   Method* m = method();
1039   if (m == NULL)  return;
1040   MethodData* mdo = m-&gt;method_data();
1041   if (mdo == NULL)  return;
1042   // There is a benign race here.  See comments in methodData.hpp.
1043   mdo-&gt;inc_decompile_count();
1044 }
1045 
<a name="51" id="anc51"></a>


















1046 void nmethod::make_unloaded() {
1047   post_compiled_method_unload();
1048 
1049   // This nmethod is being unloaded, make sure that dependencies
1050   // recorded in instanceKlasses get flushed.
1051   // Since this work is being done during a GC, defer deleting dependencies from the
1052   // InstanceKlass.
1053   assert(Universe::heap()-&gt;is_gc_active() || Thread::current()-&gt;is_ConcurrentGC_thread(),
1054          &quot;should only be called during gc&quot;);
1055   flush_dependencies(/*delete_immediately*/false);
1056 
1057   // Break cycle between nmethod &amp; method
1058   LogTarget(Trace, class, unload, nmethod) lt;
1059   if (lt.is_enabled()) {
1060     LogStream ls(lt);
1061     ls.print(&quot;making nmethod &quot; INTPTR_FORMAT
1062              &quot; unloadable, Method*(&quot; INTPTR_FORMAT
1063              &quot;) &quot;,
1064              p2i(this), p2i(_method));
1065      ls.cr();
1066   }
1067   // Unlink the osr method, so we do not look this up again
1068   if (is_osr_method()) {
<a name="52" id="anc52"></a><span class="line-modified">1069     // Invalidate the osr nmethod only once</span>


1070     if (is_in_use()) {
1071       invalidate_osr_method();
1072     }
1073 #ifdef ASSERT
1074     if (method() != NULL) {
1075       // Make sure osr nmethod is invalidated, i.e. not on the list
1076       bool found = method()-&gt;method_holder()-&gt;remove_osr_nmethod(this);
1077       assert(!found, &quot;osr nmethod should have been invalidated&quot;);
1078     }
1079 #endif
1080   }
1081 
1082   // If _method is already NULL the Method* is about to be unloaded,
1083   // so we don&#39;t have to break the cycle. Note that it is possible to
1084   // have the Method* live here, in case we unload the nmethod because
1085   // it is pointing to some oop (other than the Method*) being unloaded.
1086   if (_method != NULL) {
<a name="53" id="anc53"></a><span class="line-modified">1087     // OSR methods point to the Method*, but the Method* does not</span>
<span class="line-removed">1088     // point back!</span>
<span class="line-removed">1089     if (_method-&gt;code() == this) {</span>
<span class="line-removed">1090       _method-&gt;clear_code(); // Break a cycle</span>
<span class="line-removed">1091     }</span>
<span class="line-removed">1092     _method = NULL;            // Clear the method of this dead nmethod</span>
1093   }
1094 
1095   // Make the class unloaded - i.e., change state and notify sweeper
1096   assert(SafepointSynchronize::is_at_safepoint() || Thread::current()-&gt;is_ConcurrentGC_thread(),
1097          &quot;must be at safepoint&quot;);
1098 
1099   {
1100     // Clear ICStubs and release any CompiledICHolders.
1101     CompiledICLocker ml(this);
1102     clear_ic_callsites();
1103   }
1104 
1105   // Unregister must be done before the state change
1106   {
<a name="54" id="anc54"></a><span class="line-modified">1107     MutexLockerEx ml(SafepointSynchronize::is_at_safepoint() ? NULL : CodeCache_lock,</span>
1108                      Mutex::_no_safepoint_check_flag);
1109     Universe::heap()-&gt;unregister_nmethod(this);
1110   }
1111 
<a name="55" id="anc55"></a>


1112   // Log the unloading.
1113   log_state_change();
1114 
<a name="56" id="anc56"></a><span class="line-removed">1115 #if INCLUDE_JVMCI</span>
<span class="line-removed">1116   // The method can only be unloaded after the pointer to the installed code</span>
<span class="line-removed">1117   // Java wrapper is no longer alive. Here we need to clear out this weak</span>
<span class="line-removed">1118   // reference to the dead object.</span>
<span class="line-removed">1119   maybe_invalidate_installed_code();</span>
<span class="line-removed">1120 #endif</span>
<span class="line-removed">1121 </span>
1122   // The Method* is gone at this point
1123   assert(_method == NULL, &quot;Tautology&quot;);
1124 
1125   set_osr_link(NULL);
1126   NMethodSweeper::report_state_change(this);
1127 
<a name="57" id="anc57"></a><span class="line-modified">1128   // The release is only needed for compile-time ordering, as accesses</span>
<span class="line-modified">1129   // into the nmethod after the store are not safe due to the sweeper</span>
<span class="line-modified">1130   // being allowed to free it when the store is observed, during</span>
<span class="line-modified">1131   // concurrent nmethod unloading. Therefore, there is no need for</span>
<span class="line-modified">1132   // acquire on the loader side.</span>
<span class="line-modified">1133   OrderAccess::release_store(&amp;_state, (signed char)unloaded);</span>











1134 }
1135 
1136 void nmethod::invalidate_osr_method() {
1137   assert(_entry_bci != InvocationEntryBci, &quot;wrong kind of nmethod&quot;);
1138   // Remove from list of active nmethods
1139   if (method() != NULL) {
1140     method()-&gt;method_holder()-&gt;remove_osr_nmethod(this);
1141   }
1142 }
1143 
1144 void nmethod::log_state_change() const {
1145   if (LogCompilation) {
1146     if (xtty != NULL) {
1147       ttyLocker ttyl;  // keep the following output all in one block
1148       if (_state == unloaded) {
1149         xtty-&gt;begin_elem(&quot;make_unloaded thread=&#39;&quot; UINTX_FORMAT &quot;&#39;&quot;,
1150                          os::current_thread_id());
1151       } else {
1152         xtty-&gt;begin_elem(&quot;make_not_entrant thread=&#39;&quot; UINTX_FORMAT &quot;&#39;%s&quot;,
1153                          os::current_thread_id(),
1154                          (_state == zombie ? &quot; zombie=&#39;1&#39;&quot; : &quot;&quot;));
1155       }
1156       log_identity(xtty);
1157       xtty-&gt;stamp();
1158       xtty-&gt;end_elem();
1159     }
1160   }
1161 
1162   const char *state_msg = _state == zombie ? &quot;made zombie&quot; : &quot;made not entrant&quot;;
1163   CompileTask::print_ul(this, state_msg);
1164   if (PrintCompilation &amp;&amp; _state != unloaded) {
1165     print_on(tty, state_msg);
1166   }
1167 }
1168 
<a name="58" id="anc58"></a><span class="line-modified">1169 void nmethod::unlink_from_method(bool acquire_lock) {</span>
<span class="line-modified">1170   // We need to check if both the _code and _from_compiled_code_entry_point</span>
<span class="line-modified">1171   // refer to this nmethod because there is a race in setting these two fields</span>
<span class="line-removed">1172   // in Method* as seen in bugid 4947125.</span>
<span class="line-removed">1173   // If the vep() points to the zombie nmethod, the memory for the nmethod</span>
<span class="line-removed">1174   // could be flushed and the compiler and vtable stubs could still call</span>
<span class="line-removed">1175   // through it.</span>
<span class="line-removed">1176   if (method() != NULL &amp;&amp; (method()-&gt;code() == this ||</span>
<span class="line-removed">1177                            method()-&gt;from_compiled_entry() == verified_entry_point())) {</span>
<span class="line-removed">1178     method()-&gt;clear_code(acquire_lock);</span>
1179   }
1180 }
1181 
1182 /**
1183  * Common functionality for both make_not_entrant and make_zombie
1184  */
1185 bool nmethod::make_not_entrant_or_zombie(int state) {
1186   assert(state == zombie || state == not_entrant, &quot;must be zombie or not_entrant&quot;);
<a name="59" id="anc59"></a><span class="line-removed">1187   assert(!is_zombie(), &quot;should not already be a zombie&quot;);</span>
1188 
<a name="60" id="anc60"></a><span class="line-modified">1189   if (_state == state) {</span>
1190     // Avoid taking the lock if already in required state.
1191     // This is safe from races because the state is an end-state,
1192     // which the nmethod cannot back out of once entered.
1193     // No need for fencing either.
1194     return false;
1195   }
1196 
<a name="61" id="anc61"></a><span class="line-modified">1197   // Make sure neither the nmethod nor the method is flushed in case of a safepoint in code below.</span>
1198   nmethodLocker nml(this);
<a name="62" id="anc62"></a><span class="line-removed">1199   methodHandle the_method(method());</span>
1200   // This can be called while the system is already at a safepoint which is ok
<a name="63" id="anc63"></a><span class="line-modified">1201   NoSafepointVerifier nsv(true, !SafepointSynchronize::is_at_safepoint());</span>
1202 
1203   // during patching, depending on the nmethod state we must notify the GC that
1204   // code has been unloaded, unregistering it. We cannot do this right while
<a name="64" id="anc64"></a><span class="line-modified">1205   // holding the Patching_lock because we need to use the CodeCache_lock. This</span>
1206   // would be prone to deadlocks.
1207   // This flag is used to remember whether we need to later lock and unregister.
1208   bool nmethod_needs_unregister = false;
1209 
1210   {
<a name="65" id="anc65"></a><span class="line-modified">1211     // invalidate osr nmethod before acquiring the patching lock since</span>
<span class="line-modified">1212     // they both acquire leaf locks and we don&#39;t want a deadlock.</span>

1213     // This logic is equivalent to the logic below for patching the
1214     // verified entry point of regular methods. We check that the
1215     // nmethod is in use to ensure that it is invalidated only once.
1216     if (is_osr_method() &amp;&amp; is_in_use()) {
1217       // this effectively makes the osr nmethod not entrant
1218       invalidate_osr_method();
1219     }
1220 
<a name="66" id="anc66"></a><span class="line-modified">1221     // Enter critical section.  Does not block for safepoint.</span>
<span class="line-removed">1222     MutexLockerEx pl(Patching_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed">1223 </span>
<span class="line-removed">1224     if (_state == state) {</span>
1225       // another thread already performed this transition so nothing
1226       // to do, but return false to indicate this.
1227       return false;
1228     }
1229 
1230     // The caller can be calling the method statically or through an inline
1231     // cache call.
1232     if (!is_osr_method() &amp;&amp; !is_not_entrant()) {
1233       NativeJump::patch_verified_entry(entry_point(), verified_entry_point(),
1234                   SharedRuntime::get_handle_wrong_method_stub());
1235     }
1236 
1237     if (is_in_use() &amp;&amp; update_recompile_counts()) {
1238       // It&#39;s a true state change, so mark the method as decompiled.
1239       // Do it only for transition from alive.
1240       inc_decompile_count();
1241     }
1242 
1243     // If the state is becoming a zombie, signal to unregister the nmethod with
1244     // the heap.
1245     // This nmethod may have already been unloaded during a full GC.
1246     if ((state == zombie) &amp;&amp; !is_unloaded()) {
1247       nmethod_needs_unregister = true;
1248     }
1249 
1250     // Must happen before state change. Otherwise we have a race condition in
<a name="67" id="anc67"></a><span class="line-modified">1251     // nmethod::can_not_entrant_be_converted(). I.e., a method can immediately</span>
1252     // transition its state from &#39;not_entrant&#39; to &#39;zombie&#39; without having to wait
1253     // for stack scanning.
1254     if (state == not_entrant) {
1255       mark_as_seen_on_stack();
1256       OrderAccess::storestore(); // _stack_traversal_mark and _state
1257     }
1258 
1259     // Change state
<a name="68" id="anc68"></a><span class="line-modified">1260     _state = state;</span>











1261 
1262     // Log the transition once
1263     log_state_change();
1264 
<a name="69" id="anc69"></a><span class="line-removed">1265     // Invalidate while holding the patching lock</span>
<span class="line-removed">1266     JVMCI_ONLY(maybe_invalidate_installed_code());</span>
<span class="line-removed">1267 </span>
1268     // Remove nmethod from method.
<a name="70" id="anc70"></a><span class="line-modified">1269     unlink_from_method(false /* already owns Patching_lock */);</span>
<span class="line-modified">1270   } // leave critical region under Patching_lock</span>









1271 
1272 #ifdef ASSERT
1273   if (is_osr_method() &amp;&amp; method() != NULL) {
1274     // Make sure osr nmethod is invalidated, i.e. not on the list
1275     bool found = method()-&gt;method_holder()-&gt;remove_osr_nmethod(this);
1276     assert(!found, &quot;osr nmethod should have been invalidated&quot;);
1277   }
1278 #endif
1279 
1280   // When the nmethod becomes zombie it is no longer alive so the
1281   // dependencies must be flushed.  nmethods in the not_entrant
1282   // state will be flushed later when the transition to zombie
1283   // happens or they get unloaded.
1284   if (state == zombie) {
1285     {
1286       // Flushing dependencies must be done before any possible
1287       // safepoint can sneak in, otherwise the oops used by the
1288       // dependency logic could have become stale.
<a name="71" id="anc71"></a><span class="line-modified">1289       MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
1290       if (nmethod_needs_unregister) {
1291         Universe::heap()-&gt;unregister_nmethod(this);
1292       }
1293       flush_dependencies(/*delete_immediately*/true);
1294     }
1295 
<a name="72" id="anc72"></a>







1296     // Clear ICStubs to prevent back patching stubs of zombie or flushed
1297     // nmethods during the next safepoint (see ICStub::finalize), as well
1298     // as to free up CompiledICHolder resources.
1299     {
1300       CompiledICLocker ml(this);
1301       clear_ic_callsites();
1302     }
1303 
1304     // zombie only - if a JVMTI agent has enabled the CompiledMethodUnload
1305     // event and it hasn&#39;t already been reported for this nmethod then
1306     // report it now. The event may have been reported earlier if the GC
1307     // marked it for unloading). JvmtiDeferredEventQueue support means
1308     // we no longer go to a safepoint here.
1309     post_compiled_method_unload();
1310 
1311 #ifdef ASSERT
1312     // It&#39;s no longer safe to access the oops section since zombie
1313     // nmethods aren&#39;t scanned for GC.
1314     _oops_are_stale = true;
1315 #endif
1316      // the Method may be reclaimed by class unloading now that the
1317      // nmethod is in zombie state
1318     set_method(NULL);
1319   } else {
1320     assert(state == not_entrant, &quot;other cases may need to be handled differently&quot;);
1321   }
1322 
<a name="73" id="anc73"></a><span class="line-modified">1323   if (TraceCreateZombies) {</span>
1324     ResourceMark m;
1325     tty-&gt;print_cr(&quot;nmethod &lt;&quot; INTPTR_FORMAT &quot;&gt; %s code made %s&quot;, p2i(this), this-&gt;method() ? this-&gt;method()-&gt;name_and_sig_as_C_string() : &quot;null&quot;, (state == not_entrant) ? &quot;not entrant&quot; : &quot;zombie&quot;);
1326   }
1327 
1328   NMethodSweeper::report_state_change(this);
1329   return true;
1330 }
1331 
1332 void nmethod::flush() {
<a name="74" id="anc74"></a><span class="line-modified">1333   MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
1334   // Note that there are no valid oops in the nmethod anymore.
1335   assert(!is_osr_method() || is_unloaded() || is_zombie(),
1336          &quot;osr nmethod must be unloaded or zombie before flushing&quot;);
1337   assert(is_zombie() || is_osr_method(), &quot;must be a zombie method&quot;);
1338   assert (!is_locked_by_vm(), &quot;locked methods shouldn&#39;t be flushed&quot;);
1339   assert_locked_or_safepoint(CodeCache_lock);
1340 
1341   // completely deallocate this method
1342   Events::log(JavaThread::current(), &quot;flushing nmethod &quot; INTPTR_FORMAT, p2i(this));
1343   if (PrintMethodFlushing) {
1344     tty-&gt;print_cr(&quot;*flushing %s nmethod %3d/&quot; INTPTR_FORMAT &quot;. Live blobs:&quot; UINT32_FORMAT
1345                   &quot;/Free CodeCache:&quot; SIZE_FORMAT &quot;Kb&quot;,
1346                   is_osr_method() ? &quot;osr&quot; : &quot;&quot;,_compile_id, p2i(this), CodeCache::blob_count(),
1347                   CodeCache::unallocated_capacity(CodeCache::get_code_blob_type(this))/1024);
1348   }
1349 
1350   // We need to deallocate any ExceptionCache data.
1351   // Note that we do not need to grab the nmethod lock for this, it
1352   // better be thread safe if we&#39;re disposing of it!
1353   ExceptionCache* ec = exception_cache();
1354   set_exception_cache(NULL);
1355   while(ec != NULL) {
1356     ExceptionCache* next = ec-&gt;next();
1357     delete ec;
1358     ec = next;
1359   }
1360 
<a name="75" id="anc75"></a><span class="line-removed">1361 #if INCLUDE_JVMCI</span>
<span class="line-removed">1362   assert(_jvmci_installed_code == NULL, &quot;should have been nulled out when transitioned to zombie&quot;);</span>
<span class="line-removed">1363   assert(_speculation_log == NULL, &quot;should have been nulled out when transitioned to zombie&quot;);</span>
<span class="line-removed">1364 #endif</span>
<span class="line-removed">1365 </span>
1366   Universe::heap()-&gt;flush_nmethod(this);
<a name="76" id="anc76"></a>
1367 
1368   CodeBlob::flush();
1369   CodeCache::free(this);
1370 }
1371 
1372 oop nmethod::oop_at(int index) const {
1373   if (index == 0) {
1374     return NULL;
1375   }
1376   return NativeAccess&lt;AS_NO_KEEPALIVE&gt;::oop_load(oop_addr_at(index));
1377 }
1378 
<a name="77" id="anc77"></a>






1379 //
1380 // Notify all classes this nmethod is dependent on that it is no
1381 // longer dependent. This should only be called in two situations.
1382 // First, when a nmethod transitions to a zombie all dependents need
1383 // to be clear.  Since zombification happens at a safepoint there&#39;s no
1384 // synchronization issues.  The second place is a little more tricky.
1385 // During phase 1 of mark sweep class unloading may happen and as a
1386 // result some nmethods may get unloaded.  In this case the flushing
1387 // of dependencies must happen during phase 1 since after GC any
1388 // dependencies in the unloaded nmethod won&#39;t be updated, so
1389 // traversing the dependency information in unsafe.  In that case this
1390 // function is called with a boolean argument and this function only
1391 // notifies instanceKlasses that are reachable
1392 
1393 void nmethod::flush_dependencies(bool delete_immediately) {
1394   DEBUG_ONLY(bool called_by_gc = Universe::heap()-&gt;is_gc_active() || Thread::current()-&gt;is_ConcurrentGC_thread();)
1395   assert(called_by_gc != delete_immediately,
1396   &quot;delete_immediately is false if and only if we are called during GC&quot;);
1397   if (!has_flushed_dependencies()) {
1398     set_has_flushed_dependencies();
1399     for (Dependencies::DepStream deps(this); deps.next(); ) {
1400       if (deps.type() == Dependencies::call_site_target_value) {
1401         // CallSite dependencies are managed on per-CallSite instance basis.
1402         oop call_site = deps.argument_oop(0);
1403         if (delete_immediately) {
1404           assert_locked_or_safepoint(CodeCache_lock);
1405           MethodHandles::remove_dependent_nmethod(call_site, this);
1406         } else {
1407           MethodHandles::clean_dependency_context(call_site);
1408         }
1409       } else {
1410         Klass* klass = deps.context_type();
1411         if (klass == NULL) {
1412           continue;  // ignore things like evol_method
1413         }
1414         // During GC delete_immediately is false, and liveness
1415         // of dependee determines class that needs to be updated.
1416         if (delete_immediately) {
1417           assert_locked_or_safepoint(CodeCache_lock);
1418           InstanceKlass::cast(klass)-&gt;remove_dependent_nmethod(this);
1419         } else if (klass-&gt;is_loader_alive()) {
1420           // The GC may clean dependency contexts concurrently and in parallel.
1421           InstanceKlass::cast(klass)-&gt;clean_dependency_context();
1422         }
1423       }
1424     }
1425   }
1426 }
1427 
1428 // ------------------------------------------------------------------
1429 // post_compiled_method_load_event
1430 // new method for install_code() path
1431 // Transfer information from compilation to jvmti
<a name="78" id="anc78"></a><span class="line-modified">1432 void nmethod::post_compiled_method_load_event() {</span>






1433 
<a name="79" id="anc79"></a><span class="line-modified">1434   Method* moop = method();</span>




1435   HOTSPOT_COMPILED_METHOD_LOAD(
<a name="80" id="anc80"></a><span class="line-modified">1436       (char *) moop-&gt;klass_name()-&gt;bytes(),</span>
<span class="line-modified">1437       moop-&gt;klass_name()-&gt;utf8_length(),</span>
<span class="line-modified">1438       (char *) moop-&gt;name()-&gt;bytes(),</span>
<span class="line-modified">1439       moop-&gt;name()-&gt;utf8_length(),</span>
<span class="line-modified">1440       (char *) moop-&gt;signature()-&gt;bytes(),</span>
<span class="line-modified">1441       moop-&gt;signature()-&gt;utf8_length(),</span>
1442       insts_begin(), insts_size());
1443 
<a name="81" id="anc81"></a><span class="line-removed">1444   if (JvmtiExport::should_post_compiled_method_load() ||</span>
<span class="line-removed">1445       JvmtiExport::should_post_compiled_method_unload()) {</span>
<span class="line-removed">1446     get_and_cache_jmethod_id();</span>
<span class="line-removed">1447   }</span>
1448 
1449   if (JvmtiExport::should_post_compiled_method_load()) {
<a name="82" id="anc82"></a><span class="line-modified">1450     // Let the Service thread (which is a real Java thread) post the event</span>
<span class="line-modified">1451     MutexLockerEx ml(Service_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">1452     JvmtiDeferredEventQueue::enqueue(</span>
<span class="line-modified">1453       JvmtiDeferredEvent::compiled_method_load_event(this));</span>
<span class="line-modified">1454   }</span>
<span class="line-modified">1455 }</span>
<span class="line-modified">1456 </span>
<span class="line-modified">1457 jmethodID nmethod::get_and_cache_jmethod_id() {</span>
<span class="line-modified">1458   if (_jmethod_id == NULL) {</span>
<span class="line-modified">1459     // Cache the jmethod_id since it can no longer be looked up once the</span>
<span class="line-modified">1460     // method itself has been marked for unloading.</span>
<span class="line-modified">1461     _jmethod_id = method()-&gt;jmethod_id();</span>


1462   }
<a name="83" id="anc83"></a><span class="line-removed">1463   return _jmethod_id;</span>
1464 }
1465 
1466 void nmethod::post_compiled_method_unload() {
1467   if (unload_reported()) {
1468     // During unloading we transition to unloaded and then to zombie
1469     // and the unloading is reported during the first transition.
1470     return;
1471   }
1472 
1473   assert(_method != NULL &amp;&amp; !is_unloaded(), &quot;just checking&quot;);
1474   DTRACE_METHOD_UNLOAD_PROBE(method());
1475 
1476   // If a JVMTI agent has enabled the CompiledMethodUnload event then
1477   // post the event. Sometime later this nmethod will be made a zombie
1478   // by the sweeper but the Method* will not be valid at that point.
<a name="84" id="anc84"></a><span class="line-modified">1479   // If the _jmethod_id is null then no load event was ever requested</span>
<span class="line-removed">1480   // so don&#39;t bother posting the unload.  The main reason for this is</span>
<span class="line-removed">1481   // that the jmethodID is a weak reference to the Method* so if</span>
1482   // it&#39;s being unloaded there&#39;s no way to look it up since the weak
1483   // ref will have been cleared.
<a name="85" id="anc85"></a><span class="line-modified">1484   if (_jmethod_id != NULL &amp;&amp; JvmtiExport::should_post_compiled_method_unload()) {</span>


1485     assert(!unload_reported(), &quot;already unloaded&quot;);
1486     JvmtiDeferredEvent event =
<a name="86" id="anc86"></a><span class="line-modified">1487       JvmtiDeferredEvent::compiled_method_unload_event(this,</span>
<span class="line-modified">1488           _jmethod_id, insts_begin());</span>
<span class="line-modified">1489     MutexLockerEx ml(Service_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed">1490     JvmtiDeferredEventQueue::enqueue(event);</span>
1491   }
1492 
1493   // The JVMTI CompiledMethodUnload event can be enabled or disabled at
1494   // any time. As the nmethod is being unloaded now we mark it has
1495   // having the unload event reported - this will ensure that we don&#39;t
1496   // attempt to report the event in the unlikely scenario where the
1497   // event is enabled at the time the nmethod is made a zombie.
1498   set_unload_reported();
1499 }
1500 
1501 // Iterate over metadata calling this function.   Used by RedefineClasses
<a name="87" id="anc87"></a><span class="line-modified">1502 void nmethod::metadata_do(void f(Metadata*)) {</span>
1503   {
1504     // Visit all immediate references that are embedded in the instruction stream.
1505     RelocIterator iter(this, oops_reloc_begin());
1506     while (iter.next()) {
<a name="88" id="anc88"></a><span class="line-modified">1507       if (iter.type() == relocInfo::metadata_type ) {</span>
1508         metadata_Relocation* r = iter.metadata_reloc();
1509         // In this metadata, we must only follow those metadatas directly embedded in
1510         // the code.  Other metadatas (oop_index&gt;0) are seen as part of
1511         // the metadata section below.
1512         assert(1 == (r-&gt;metadata_is_immediate()) +
1513                (r-&gt;metadata_addr() &gt;= metadata_begin() &amp;&amp; r-&gt;metadata_addr() &lt; metadata_end()),
1514                &quot;metadata must be found in exactly one place&quot;);
1515         if (r-&gt;metadata_is_immediate() &amp;&amp; r-&gt;metadata_value() != NULL) {
1516           Metadata* md = r-&gt;metadata_value();
<a name="89" id="anc89"></a><span class="line-modified">1517           if (md != _method) f(md);</span>
1518         }
1519       } else if (iter.type() == relocInfo::virtual_call_type) {
1520         // Check compiledIC holders associated with this nmethod
1521         ResourceMark rm;
1522         CompiledIC *ic = CompiledIC_at(&amp;iter);
1523         if (ic-&gt;is_icholder_call()) {
1524           CompiledICHolder* cichk = ic-&gt;cached_icholder();
<a name="90" id="anc90"></a><span class="line-modified">1525           f(cichk-&gt;holder_metadata());</span>
<span class="line-modified">1526           f(cichk-&gt;holder_klass());</span>
1527         } else {
1528           Metadata* ic_oop = ic-&gt;cached_metadata();
1529           if (ic_oop != NULL) {
<a name="91" id="anc91"></a><span class="line-modified">1530             f(ic_oop);</span>
1531           }
1532         }
1533       }
1534     }
1535   }
1536 
1537   // Visit the metadata section
1538   for (Metadata** p = metadata_begin(); p &lt; metadata_end(); p++) {
1539     if (*p == Universe::non_oop_word() || *p == NULL)  continue;  // skip non-oops
1540     Metadata* md = *p;
<a name="92" id="anc92"></a><span class="line-modified">1541     f(md);</span>
1542   }
1543 
1544   // Visit metadata not embedded in the other places.
<a name="93" id="anc93"></a><span class="line-modified">1545   if (_method != NULL) f(_method);</span>
1546 }
1547 
1548 // The _is_unloading_state encodes a tuple comprising the unloading cycle
1549 // and the result of IsUnloadingBehaviour::is_unloading() fpr that cycle.
1550 // This is the bit layout of the _is_unloading_state byte: 00000CCU
1551 // CC refers to the cycle, which has 2 bits, and U refers to the result of
1552 // IsUnloadingBehaviour::is_unloading() for that unloading cycle.
1553 
1554 class IsUnloadingState: public AllStatic {
1555   static const uint8_t _is_unloading_mask = 1;
1556   static const uint8_t _is_unloading_shift = 0;
1557   static const uint8_t _unloading_cycle_mask = 6;
1558   static const uint8_t _unloading_cycle_shift = 1;
1559 
1560   static uint8_t set_is_unloading(uint8_t state, bool value) {
1561     state &amp;= ~_is_unloading_mask;
1562     if (value) {
1563       state |= 1 &lt;&lt; _is_unloading_shift;
1564     }
1565     assert(is_unloading(state) == value, &quot;unexpected unloading cycle overflow&quot;);
1566     return state;
1567   }
1568 
1569   static uint8_t set_unloading_cycle(uint8_t state, uint8_t value) {
1570     state &amp;= ~_unloading_cycle_mask;
1571     state |= value &lt;&lt; _unloading_cycle_shift;
1572     assert(unloading_cycle(state) == value, &quot;unexpected unloading cycle overflow&quot;);
1573     return state;
1574   }
1575 
1576 public:
1577   static bool is_unloading(uint8_t state) { return (state &amp; _is_unloading_mask) &gt;&gt; _is_unloading_shift == 1; }
1578   static uint8_t unloading_cycle(uint8_t state) { return (state &amp; _unloading_cycle_mask) &gt;&gt; _unloading_cycle_shift; }
1579 
1580   static uint8_t create(bool is_unloading, uint8_t unloading_cycle) {
1581     uint8_t state = 0;
1582     state = set_is_unloading(state, is_unloading);
1583     state = set_unloading_cycle(state, unloading_cycle);
1584     return state;
1585   }
1586 };
1587 
1588 bool nmethod::is_unloading() {
1589   uint8_t state = RawAccess&lt;MO_RELAXED&gt;::load(&amp;_is_unloading_state);
1590   bool state_is_unloading = IsUnloadingState::is_unloading(state);
1591   uint8_t state_unloading_cycle = IsUnloadingState::unloading_cycle(state);
1592   if (state_is_unloading) {
1593     return true;
1594   }
1595   uint8_t current_cycle = CodeCache::unloading_cycle();
1596   if (state_unloading_cycle == current_cycle) {
1597     return false;
1598   }
1599 
1600   // The IsUnloadingBehaviour is responsible for checking if there are any dead
1601   // oops in the CompiledMethod, by calling oops_do on it.
1602   state_unloading_cycle = current_cycle;
1603 
1604   if (is_zombie()) {
1605     // Zombies without calculated unloading epoch are never unloading due to GC.
1606 
1607     // There are no races where a previously observed is_unloading() nmethod
1608     // suddenly becomes not is_unloading() due to here being observed as zombie.
1609 
1610     // With STW unloading, all is_alive() &amp;&amp; is_unloading() nmethods are unlinked
1611     // and unloaded in the safepoint. That makes races where an nmethod is first
1612     // observed as is_alive() &amp;&amp; is_unloading() and subsequently observed as
1613     // is_zombie() impossible.
1614 
1615     // With concurrent unloading, all references to is_unloading() nmethods are
1616     // first unlinked (e.g. IC caches and dependency contexts). Then a global
1617     // handshake operation is performed with all JavaThreads before finally
1618     // unloading the nmethods. The sweeper never converts is_alive() &amp;&amp; is_unloading()
1619     // nmethods to zombies; it waits for them to become is_unloaded(). So before
1620     // the global handshake, it is impossible for is_unloading() nmethods to
1621     // racingly become is_zombie(). And is_unloading() is calculated for all is_alive()
1622     // nmethods before taking that global handshake, meaning that it will never
1623     // be recalculated after the handshake.
1624 
1625     // After that global handshake, is_unloading() nmethods are only observable
1626     // to the iterators, and they will never trigger recomputation of the cached
1627     // is_unloading_state, and hence may not suffer from such races.
1628 
1629     state_is_unloading = false;
1630   } else {
1631     state_is_unloading = IsUnloadingBehaviour::current()-&gt;is_unloading(this);
1632   }
1633 
1634   state = IsUnloadingState::create(state_is_unloading, state_unloading_cycle);
1635 
1636   RawAccess&lt;MO_RELAXED&gt;::store(&amp;_is_unloading_state, state);
1637 
1638   return state_is_unloading;
1639 }
1640 
1641 void nmethod::clear_unloading_state() {
1642   uint8_t state = IsUnloadingState::create(false, CodeCache::unloading_cycle());
1643   RawAccess&lt;MO_RELAXED&gt;::store(&amp;_is_unloading_state, state);
1644 }
1645 
1646 
1647 // This is called at the end of the strong tracing/marking phase of a
1648 // GC to unload an nmethod if it contains otherwise unreachable
1649 // oops.
1650 
1651 void nmethod::do_unloading(bool unloading_occurred) {
1652   // Make sure the oop&#39;s ready to receive visitors
1653   assert(!is_zombie() &amp;&amp; !is_unloaded(),
1654          &quot;should not call follow on zombie or unloaded nmethod&quot;);
1655 
1656   if (is_unloading()) {
1657     make_unloaded();
1658   } else {
<a name="94" id="anc94"></a><span class="line-removed">1659 #if INCLUDE_JVMCI</span>
<span class="line-removed">1660     if (_jvmci_installed_code != NULL) {</span>
<span class="line-removed">1661       if (JNIHandles::is_global_weak_cleared(_jvmci_installed_code)) {</span>
<span class="line-removed">1662         if (_jvmci_installed_code_triggers_invalidation) {</span>
<span class="line-removed">1663           make_not_entrant();</span>
<span class="line-removed">1664         }</span>
<span class="line-removed">1665         clear_jvmci_installed_code();</span>
<span class="line-removed">1666       }</span>
<span class="line-removed">1667     }</span>
<span class="line-removed">1668 #endif</span>
<span class="line-removed">1669 </span>
1670     guarantee(unload_nmethod_caches(unloading_occurred),
1671               &quot;Should not need transition stubs&quot;);
1672   }
1673 }
1674 
<a name="95" id="anc95"></a><span class="line-modified">1675 void nmethod::oops_do(OopClosure* f, bool allow_zombie) {</span>
1676   // make sure the oops ready to receive visitors
<a name="96" id="anc96"></a><span class="line-modified">1677   assert(allow_zombie || !is_zombie(), &quot;should not call follow on zombie nmethod&quot;);</span>
<span class="line-removed">1678   assert(!is_unloaded(), &quot;should not call follow on unloaded nmethod&quot;);</span>
1679 
1680   // Prevent extra code cache walk for platforms that don&#39;t have immediate oops.
1681   if (relocInfo::mustIterateImmediateOopsInCode()) {
1682     RelocIterator iter(this, oops_reloc_begin());
1683 
1684     while (iter.next()) {
1685       if (iter.type() == relocInfo::oop_type ) {
1686         oop_Relocation* r = iter.oop_reloc();
1687         // In this loop, we must only follow those oops directly embedded in
1688         // the code.  Other oops (oop_index&gt;0) are seen as part of scopes_oops.
1689         assert(1 == (r-&gt;oop_is_immediate()) +
1690                (r-&gt;oop_addr() &gt;= oops_begin() &amp;&amp; r-&gt;oop_addr() &lt; oops_end()),
1691                &quot;oop must be found in exactly one place&quot;);
1692         if (r-&gt;oop_is_immediate() &amp;&amp; r-&gt;oop_value() != NULL) {
1693           f-&gt;do_oop(r-&gt;oop_addr());
1694         }
1695       }
1696     }
1697   }
1698 
1699   // Scopes
1700   // This includes oop constants not inlined in the code stream.
1701   for (oop* p = oops_begin(); p &lt; oops_end(); p++) {
1702     if (*p == Universe::non_oop_word())  continue;  // skip non-oops
1703     f-&gt;do_oop(p);
1704   }
1705 }
1706 
<a name="97" id="anc97"></a><span class="line-removed">1707 #define NMETHOD_SENTINEL ((nmethod*)badAddress)</span>
<span class="line-removed">1708 </span>
1709 nmethod* volatile nmethod::_oops_do_mark_nmethods;
1710 
<a name="98" id="anc98"></a><span class="line-modified">1711 // An nmethod is &quot;marked&quot; if its _mark_link is set non-null.</span>
<span class="line-modified">1712 // Even if it is the end of the linked list, it will have a non-null link value,</span>
<span class="line-modified">1713 // as long as it is on the list.</span>
<span class="line-modified">1714 // This code must be MP safe, because it is used from parallel GC passes.</span>
<span class="line-modified">1715 bool nmethod::test_set_oops_do_mark() {</span>
<span class="line-modified">1716   assert(nmethod::oops_do_marking_is_active(), &quot;oops_do_marking_prologue must be called&quot;);</span>
<span class="line-modified">1717   if (_oops_do_mark_link == NULL) {</span>
<span class="line-modified">1718     // Claim this nmethod for this thread to mark.</span>
<span class="line-modified">1719     if (Atomic::replace_if_null(NMETHOD_SENTINEL, &amp;_oops_do_mark_link)) {</span>
<span class="line-modified">1720       // Atomically append this nmethod (now claimed) to the head of the list:</span>
<span class="line-modified">1721       nmethod* observed_mark_nmethods = _oops_do_mark_nmethods;</span>
<span class="line-modified">1722       for (;;) {</span>
<span class="line-modified">1723         nmethod* required_mark_nmethods = observed_mark_nmethods;</span>
<span class="line-modified">1724         _oops_do_mark_link = required_mark_nmethods;</span>
<span class="line-modified">1725         observed_mark_nmethods =</span>
<span class="line-modified">1726           Atomic::cmpxchg(this, &amp;_oops_do_mark_nmethods, required_mark_nmethods);</span>
<span class="line-modified">1727         if (observed_mark_nmethods == required_mark_nmethods)</span>
<span class="line-modified">1728           break;</span>
<span class="line-modified">1729       }</span>
<span class="line-modified">1730       // Mark was clear when we first saw this guy.</span>
<span class="line-modified">1731       LogTarget(Trace, gc, nmethod) lt;</span>
<span class="line-modified">1732       if (lt.is_enabled()) {</span>
<span class="line-modified">1733         LogStream ls(lt);</span>
<span class="line-modified">1734         CompileTask::print(&amp;ls, this, &quot;oops_do, mark&quot;, /*short_form:*/ true);</span>
<span class="line-modified">1735       }</span>
<span class="line-modified">1736       return false;</span>



















































































































1737     }
<a name="99" id="anc99"></a>
1738   }
<a name="100" id="anc100"></a><span class="line-modified">1739   // On fall through, another racing thread marked this nmethod before we did.</span>
<span class="line-modified">1740   return true;</span>








1741 }
1742 
1743 void nmethod::oops_do_marking_prologue() {
<a name="101" id="anc101"></a>

1744   log_trace(gc, nmethod)(&quot;oops_do_marking_prologue&quot;);
<a name="102" id="anc102"></a><span class="line-modified">1745   assert(_oops_do_mark_nmethods == NULL, &quot;must not call oops_do_marking_prologue twice in a row&quot;);</span>
<span class="line-removed">1746   // We use cmpxchg instead of regular assignment here because the user</span>
<span class="line-removed">1747   // may fork a bunch of threads, and we need them all to see the same state.</span>
<span class="line-removed">1748   nmethod* observed = Atomic::cmpxchg(NMETHOD_SENTINEL, &amp;_oops_do_mark_nmethods, (nmethod*)NULL);</span>
<span class="line-removed">1749   guarantee(observed == NULL, &quot;no races in this sequential code&quot;);</span>
1750 }
1751 
1752 void nmethod::oops_do_marking_epilogue() {
<a name="103" id="anc103"></a><span class="line-modified">1753   assert(_oops_do_mark_nmethods != NULL, &quot;must not call oops_do_marking_epilogue twice in a row&quot;);</span>
<span class="line-modified">1754   nmethod* cur = _oops_do_mark_nmethods;</span>
<span class="line-modified">1755   while (cur != NMETHOD_SENTINEL) {</span>
<span class="line-modified">1756     assert(cur != NULL, &quot;not NULL-terminated&quot;);</span>
<span class="line-modified">1757     nmethod* next = cur-&gt;_oops_do_mark_link;</span>






1758     cur-&gt;_oops_do_mark_link = NULL;
1759     DEBUG_ONLY(cur-&gt;verify_oop_relocations());
1760 
1761     LogTarget(Trace, gc, nmethod) lt;
1762     if (lt.is_enabled()) {
1763       LogStream ls(lt);
1764       CompileTask::print(&amp;ls, cur, &quot;oops_do, unmark&quot;, /*short_form:*/ true);
1765     }
<a name="104" id="anc104"></a><span class="line-modified">1766     cur = next;</span>
<span class="line-modified">1767   }</span>
<span class="line-removed">1768   nmethod* required = _oops_do_mark_nmethods;</span>
<span class="line-removed">1769   nmethod* observed = Atomic::cmpxchg((nmethod*)NULL, &amp;_oops_do_mark_nmethods, required);</span>
<span class="line-removed">1770   guarantee(observed == required, &quot;no races in this sequential code&quot;);</span>
1771   log_trace(gc, nmethod)(&quot;oops_do_marking_epilogue&quot;);
1772 }
1773 
1774 inline bool includes(void* p, void* from, void* to) {
1775   return from &lt;= p &amp;&amp; p &lt; to;
1776 }
1777 
1778 
1779 void nmethod::copy_scopes_pcs(PcDesc* pcs, int count) {
1780   assert(count &gt;= 2, &quot;must be sentinel values, at least&quot;);
1781 
1782 #ifdef ASSERT
1783   // must be sorted and unique; we do a binary search in find_pc_desc()
1784   int prev_offset = pcs[0].pc_offset();
1785   assert(prev_offset == PcDesc::lower_offset_limit,
1786          &quot;must start with a sentinel&quot;);
1787   for (int i = 1; i &lt; count; i++) {
1788     int this_offset = pcs[i].pc_offset();
1789     assert(this_offset &gt; prev_offset, &quot;offsets must be sorted&quot;);
1790     prev_offset = this_offset;
1791   }
1792   assert(prev_offset == PcDesc::upper_offset_limit,
1793          &quot;must end with a sentinel&quot;);
1794 #endif //ASSERT
1795 
1796   // Search for MethodHandle invokes and tag the nmethod.
1797   for (int i = 0; i &lt; count; i++) {
1798     if (pcs[i].is_method_handle_invoke()) {
1799       set_has_method_handle_invokes(true);
1800       break;
1801     }
1802   }
1803   assert(has_method_handle_invokes() == (_deopt_mh_handler_begin != NULL), &quot;must have deopt mh handler&quot;);
1804 
1805   int size = count * sizeof(PcDesc);
1806   assert(scopes_pcs_size() &gt;= size, &quot;oob&quot;);
1807   memcpy(scopes_pcs_begin(), pcs, size);
1808 
1809   // Adjust the final sentinel downward.
1810   PcDesc* last_pc = &amp;scopes_pcs_begin()[count-1];
1811   assert(last_pc-&gt;pc_offset() == PcDesc::upper_offset_limit, &quot;sanity&quot;);
1812   last_pc-&gt;set_pc_offset(content_size() + 1);
1813   for (; last_pc + 1 &lt; scopes_pcs_end(); last_pc += 1) {
1814     // Fill any rounding gaps with copies of the last record.
1815     last_pc[1] = last_pc[0];
1816   }
1817   // The following assert could fail if sizeof(PcDesc) is not
1818   // an integral multiple of oopSize (the rounding term).
1819   // If it fails, change the logic to always allocate a multiple
1820   // of sizeof(PcDesc), and fill unused words with copies of *last_pc.
1821   assert(last_pc + 1 == scopes_pcs_end(), &quot;must match exactly&quot;);
1822 }
1823 
1824 void nmethod::copy_scopes_data(u_char* buffer, int size) {
1825   assert(scopes_data_size() &gt;= size, &quot;oob&quot;);
1826   memcpy(scopes_data_begin(), buffer, size);
1827 }
1828 
1829 #ifdef ASSERT
1830 static PcDesc* linear_search(const PcDescSearch&amp; search, int pc_offset, bool approximate) {
1831   PcDesc* lower = search.scopes_pcs_begin();
1832   PcDesc* upper = search.scopes_pcs_end();
1833   lower += 1; // exclude initial sentinel
1834   PcDesc* res = NULL;
1835   for (PcDesc* p = lower; p &lt; upper; p++) {
1836     NOT_PRODUCT(--pc_nmethod_stats.pc_desc_tests);  // don&#39;t count this call to match_desc
1837     if (match_desc(p, pc_offset, approximate)) {
1838       if (res == NULL)
1839         res = p;
1840       else
1841         res = (PcDesc*) badAddress;
1842     }
1843   }
1844   return res;
1845 }
1846 #endif
1847 
1848 
1849 // Finds a PcDesc with real-pc equal to &quot;pc&quot;
1850 PcDesc* PcDescContainer::find_pc_desc_internal(address pc, bool approximate, const PcDescSearch&amp; search) {
1851   address base_address = search.code_begin();
1852   if ((pc &lt; base_address) ||
1853       (pc - base_address) &gt;= (ptrdiff_t) PcDesc::upper_offset_limit) {
1854     return NULL;  // PC is wildly out of range
1855   }
1856   int pc_offset = (int) (pc - base_address);
1857 
1858   // Check the PcDesc cache if it contains the desired PcDesc
1859   // (This as an almost 100% hit rate.)
1860   PcDesc* res = _pc_desc_cache.find_pc_desc(pc_offset, approximate);
1861   if (res != NULL) {
1862     assert(res == linear_search(search, pc_offset, approximate), &quot;cache ok&quot;);
1863     return res;
1864   }
1865 
1866   // Fallback algorithm: quasi-linear search for the PcDesc
1867   // Find the last pc_offset less than the given offset.
1868   // The successor must be the required match, if there is a match at all.
1869   // (Use a fixed radix to avoid expensive affine pointer arithmetic.)
1870   PcDesc* lower = search.scopes_pcs_begin();
1871   PcDesc* upper = search.scopes_pcs_end();
1872   upper -= 1; // exclude final sentinel
1873   if (lower &gt;= upper)  return NULL;  // native method; no PcDescs at all
1874 
1875 #define assert_LU_OK \
1876   /* invariant on lower..upper during the following search: */ \
1877   assert(lower-&gt;pc_offset() &lt;  pc_offset, &quot;sanity&quot;); \
1878   assert(upper-&gt;pc_offset() &gt;= pc_offset, &quot;sanity&quot;)
1879   assert_LU_OK;
1880 
1881   // Use the last successful return as a split point.
1882   PcDesc* mid = _pc_desc_cache.last_pc_desc();
1883   NOT_PRODUCT(++pc_nmethod_stats.pc_desc_searches);
1884   if (mid-&gt;pc_offset() &lt; pc_offset) {
1885     lower = mid;
1886   } else {
1887     upper = mid;
1888   }
1889 
1890   // Take giant steps at first (4096, then 256, then 16, then 1)
1891   const int LOG2_RADIX = 4 /*smaller steps in debug mode:*/ debug_only(-1);
1892   const int RADIX = (1 &lt;&lt; LOG2_RADIX);
1893   for (int step = (1 &lt;&lt; (LOG2_RADIX*3)); step &gt; 1; step &gt;&gt;= LOG2_RADIX) {
1894     while ((mid = lower + step) &lt; upper) {
1895       assert_LU_OK;
1896       NOT_PRODUCT(++pc_nmethod_stats.pc_desc_searches);
1897       if (mid-&gt;pc_offset() &lt; pc_offset) {
1898         lower = mid;
1899       } else {
1900         upper = mid;
1901         break;
1902       }
1903     }
1904     assert_LU_OK;
1905   }
1906 
1907   // Sneak up on the value with a linear search of length ~16.
1908   while (true) {
1909     assert_LU_OK;
1910     mid = lower + 1;
1911     NOT_PRODUCT(++pc_nmethod_stats.pc_desc_searches);
1912     if (mid-&gt;pc_offset() &lt; pc_offset) {
1913       lower = mid;
1914     } else {
1915       upper = mid;
1916       break;
1917     }
1918   }
1919 #undef assert_LU_OK
1920 
1921   if (match_desc(upper, pc_offset, approximate)) {
1922     assert(upper == linear_search(search, pc_offset, approximate), &quot;search ok&quot;);
1923     _pc_desc_cache.add_pc_desc(upper);
1924     return upper;
1925   } else {
1926     assert(NULL == linear_search(search, pc_offset, approximate), &quot;search ok&quot;);
1927     return NULL;
1928   }
1929 }
1930 
1931 
1932 void nmethod::check_all_dependencies(DepChange&amp; changes) {
1933   // Checked dependencies are allocated into this ResourceMark
1934   ResourceMark rm;
1935 
1936   // Turn off dependency tracing while actually testing dependencies.
1937   NOT_PRODUCT( FlagSetting fs(TraceDependencies, false) );
1938 
1939   typedef ResourceHashtable&lt;DependencySignature, int, &amp;DependencySignature::hash,
1940                             &amp;DependencySignature::equals, 11027&gt; DepTable;
1941 
1942   DepTable* table = new DepTable();
1943 
1944   // Iterate over live nmethods and check dependencies of all nmethods that are not
1945   // marked for deoptimization. A particular dependency is only checked once.
1946   NMethodIterator iter(NMethodIterator::only_alive_and_not_unloading);
1947   while(iter.next()) {
1948     nmethod* nm = iter.method();
1949     // Only notify for live nmethods
1950     if (!nm-&gt;is_marked_for_deoptimization()) {
1951       for (Dependencies::DepStream deps(nm); deps.next(); ) {
1952         // Construct abstraction of a dependency.
1953         DependencySignature* current_sig = new DependencySignature(deps);
1954 
1955         // Determine if dependency is already checked. table-&gt;put(...) returns
1956         // &#39;true&#39; if the dependency is added (i.e., was not in the hashtable).
1957         if (table-&gt;put(*current_sig, 1)) {
1958           if (deps.check_dependency() != NULL) {
1959             // Dependency checking failed. Print out information about the failed
1960             // dependency and finally fail with an assert. We can fail here, since
1961             // dependency checking is never done in a product build.
1962             tty-&gt;print_cr(&quot;Failed dependency:&quot;);
1963             changes.print();
1964             nm-&gt;print();
1965             nm-&gt;print_dependencies();
1966             assert(false, &quot;Should have been marked for deoptimization&quot;);
1967           }
1968         }
1969       }
1970     }
1971   }
1972 }
1973 
1974 bool nmethod::check_dependency_on(DepChange&amp; changes) {
1975   // What has happened:
1976   // 1) a new class dependee has been added
1977   // 2) dependee and all its super classes have been marked
1978   bool found_check = false;  // set true if we are upset
1979   for (Dependencies::DepStream deps(this); deps.next(); ) {
1980     // Evaluate only relevant dependencies.
1981     if (deps.spot_check_dependency_at(changes) != NULL) {
1982       found_check = true;
1983       NOT_DEBUG(break);
1984     }
1985   }
1986   return found_check;
1987 }
1988 
<a name="105" id="anc105"></a><span class="line-removed">1989 bool nmethod::is_evol_dependent() {</span>
<span class="line-removed">1990   for (Dependencies::DepStream deps(this); deps.next(); ) {</span>
<span class="line-removed">1991     if (deps.type() == Dependencies::evol_method) {</span>
<span class="line-removed">1992       Method* method = deps.method_argument(0);</span>
<span class="line-removed">1993       if (method-&gt;is_old()) {</span>
<span class="line-removed">1994         if (log_is_enabled(Debug, redefine, class, nmethod)) {</span>
<span class="line-removed">1995           ResourceMark rm;</span>
<span class="line-removed">1996           log_debug(redefine, class, nmethod)</span>
<span class="line-removed">1997             (&quot;Found evol dependency of nmethod %s.%s(%s) compile_id=%d on method %s.%s(%s)&quot;,</span>
<span class="line-removed">1998              _method-&gt;method_holder()-&gt;external_name(),</span>
<span class="line-removed">1999              _method-&gt;name()-&gt;as_C_string(),</span>
<span class="line-removed">2000              _method-&gt;signature()-&gt;as_C_string(),</span>
<span class="line-removed">2001              compile_id(),</span>
<span class="line-removed">2002              method-&gt;method_holder()-&gt;external_name(),</span>
<span class="line-removed">2003              method-&gt;name()-&gt;as_C_string(),</span>
<span class="line-removed">2004              method-&gt;signature()-&gt;as_C_string());</span>
<span class="line-removed">2005         }</span>
<span class="line-removed">2006         if (TraceDependencies || LogCompilation)</span>
<span class="line-removed">2007           deps.log_dependency(method-&gt;method_holder());</span>
<span class="line-removed">2008         return true;</span>
<span class="line-removed">2009       }</span>
<span class="line-removed">2010     }</span>
<span class="line-removed">2011   }</span>
<span class="line-removed">2012   return false;</span>
<span class="line-removed">2013 }</span>
<span class="line-removed">2014 </span>
2015 // Called from mark_for_deoptimization, when dependee is invalidated.
2016 bool nmethod::is_dependent_on_method(Method* dependee) {
2017   for (Dependencies::DepStream deps(this); deps.next(); ) {
2018     if (deps.type() != Dependencies::evol_method)
2019       continue;
2020     Method* method = deps.method_argument(0);
2021     if (method == dependee) return true;
2022   }
2023   return false;
2024 }
2025 
2026 
2027 bool nmethod::is_patchable_at(address instr_addr) {
2028   assert(insts_contains(instr_addr), &quot;wrong nmethod used&quot;);
2029   if (is_zombie()) {
2030     // a zombie may never be patched
2031     return false;
2032   }
2033   return true;
2034 }
2035 
2036 
<a name="106" id="anc106"></a><span class="line-removed">2037 address nmethod::continuation_for_implicit_exception(address pc) {</span>
<span class="line-removed">2038   // Exception happened outside inline-cache check code =&gt; we are inside</span>
<span class="line-removed">2039   // an active nmethod =&gt; use cpc to determine a return address</span>
<span class="line-removed">2040   int exception_offset = pc - code_begin();</span>
<span class="line-removed">2041   int cont_offset = ImplicitExceptionTable(this).at( exception_offset );</span>
<span class="line-removed">2042 #ifdef ASSERT</span>
<span class="line-removed">2043   if (cont_offset == 0) {</span>
<span class="line-removed">2044     Thread* thread = Thread::current();</span>
<span class="line-removed">2045     ResetNoHandleMark rnm; // Might be called from LEAF/QUICK ENTRY</span>
<span class="line-removed">2046     HandleMark hm(thread);</span>
<span class="line-removed">2047     ResourceMark rm(thread);</span>
<span class="line-removed">2048     CodeBlob* cb = CodeCache::find_blob(pc);</span>
<span class="line-removed">2049     assert(cb != NULL &amp;&amp; cb == this, &quot;&quot;);</span>
<span class="line-removed">2050     ttyLocker ttyl;</span>
<span class="line-removed">2051     tty-&gt;print_cr(&quot;implicit exception happened at &quot; INTPTR_FORMAT, p2i(pc));</span>
<span class="line-removed">2052     print();</span>
<span class="line-removed">2053     method()-&gt;print_codes();</span>
<span class="line-removed">2054     print_code();</span>
<span class="line-removed">2055     print_pcs();</span>
<span class="line-removed">2056   }</span>
<span class="line-removed">2057 #endif</span>
<span class="line-removed">2058   if (cont_offset == 0) {</span>
<span class="line-removed">2059     // Let the normal error handling report the exception</span>
<span class="line-removed">2060     return NULL;</span>
<span class="line-removed">2061   }</span>
<span class="line-removed">2062   return code_begin() + cont_offset;</span>
<span class="line-removed">2063 }</span>
<span class="line-removed">2064 </span>
<span class="line-removed">2065 </span>
<span class="line-removed">2066 </span>
2067 void nmethod_init() {
2068   // make sure you didn&#39;t forget to adjust the filler fields
2069   assert(sizeof(nmethod) % oopSize == 0, &quot;nmethod size must be multiple of a word&quot;);
2070 }
2071 
2072 
2073 //-------------------------------------------------------------------------------------------
2074 
2075 
2076 // QQQ might we make this work from a frame??
2077 nmethodLocker::nmethodLocker(address pc) {
2078   CodeBlob* cb = CodeCache::find_blob(pc);
2079   guarantee(cb != NULL &amp;&amp; cb-&gt;is_compiled(), &quot;bad pc for a nmethod found&quot;);
2080   _nm = cb-&gt;as_compiled_method();
2081   lock_nmethod(_nm);
2082 }
2083 
2084 // Only JvmtiDeferredEvent::compiled_method_unload_event()
2085 // should pass zombie_ok == true.
2086 void nmethodLocker::lock_nmethod(CompiledMethod* cm, bool zombie_ok) {
2087   if (cm == NULL)  return;
2088   if (cm-&gt;is_aot()) return;  // FIXME: Revisit once _lock_count is added to aot_method
2089   nmethod* nm = cm-&gt;as_nmethod();
2090   Atomic::inc(&amp;nm-&gt;_lock_count);
<a name="107" id="anc107"></a><span class="line-modified">2091   assert(zombie_ok || !nm-&gt;is_zombie(), &quot;cannot lock a zombie method&quot;);</span>
2092 }
2093 
2094 void nmethodLocker::unlock_nmethod(CompiledMethod* cm) {
2095   if (cm == NULL)  return;
2096   if (cm-&gt;is_aot()) return;  // FIXME: Revisit once _lock_count is added to aot_method
2097   nmethod* nm = cm-&gt;as_nmethod();
2098   Atomic::dec(&amp;nm-&gt;_lock_count);
2099   assert(nm-&gt;_lock_count &gt;= 0, &quot;unmatched nmethod lock/unlock&quot;);
2100 }
2101 
2102 
2103 // -----------------------------------------------------------------------------
2104 // Verification
2105 
2106 class VerifyOopsClosure: public OopClosure {
2107   nmethod* _nm;
2108   bool     _ok;
2109 public:
2110   VerifyOopsClosure(nmethod* nm) : _nm(nm), _ok(true) { }
2111   bool ok() { return _ok; }
2112   virtual void do_oop(oop* p) {
2113     if (oopDesc::is_oop_or_null(*p)) return;
<a name="108" id="anc108"></a>



2114     if (_ok) {
2115       _nm-&gt;print_nmethod(true);
2116       _ok = false;
2117     }
<a name="109" id="anc109"></a><span class="line-removed">2118     tty-&gt;print_cr(&quot;*** non-oop &quot; PTR_FORMAT &quot; found at &quot; PTR_FORMAT &quot; (offset %d)&quot;,</span>
<span class="line-removed">2119                   p2i(*p), p2i(p), (int)((intptr_t)p - (intptr_t)_nm));</span>
2120   }
2121   virtual void do_oop(narrowOop* p) { ShouldNotReachHere(); }
2122 };
2123 
<a name="110" id="anc110"></a>










2124 void nmethod::verify() {
2125 
2126   // Hmm. OSR methods can be deopted but not marked as zombie or not_entrant
2127   // seems odd.
2128 
2129   if (is_zombie() || is_not_entrant() || is_unloaded())
2130     return;
2131 
2132   // Make sure all the entry points are correctly aligned for patching.
2133   NativeJump::check_verified_entry_alignment(entry_point(), verified_entry_point());
2134 
2135   // assert(oopDesc::is_oop(method()), &quot;must be valid&quot;);
2136 
2137   ResourceMark rm;
2138 
2139   if (!CodeCache::contains(this)) {
2140     fatal(&quot;nmethod at &quot; INTPTR_FORMAT &quot; not in zone&quot;, p2i(this));
2141   }
2142 
2143   if(is_native_method() )
2144     return;
2145 
2146   nmethod* nm = CodeCache::find_nmethod(verified_entry_point());
2147   if (nm != this) {
2148     fatal(&quot;findNMethod did not find this nmethod (&quot; INTPTR_FORMAT &quot;)&quot;, p2i(this));
2149   }
2150 
2151   for (PcDesc* p = scopes_pcs_begin(); p &lt; scopes_pcs_end(); p++) {
2152     if (! p-&gt;verify(this)) {
2153       tty-&gt;print_cr(&quot;\t\tin nmethod at &quot; INTPTR_FORMAT &quot; (pcs)&quot;, p2i(this));
2154     }
2155   }
2156 
<a name="111" id="anc111"></a>























2157   VerifyOopsClosure voc(this);
2158   oops_do(&amp;voc);
2159   assert(voc.ok(), &quot;embedded oops must be OK&quot;);
2160   Universe::heap()-&gt;verify_nmethod(this);
2161 
<a name="112" id="anc112"></a>

2162   verify_scopes();
<a name="113" id="anc113"></a>



2163 }
2164 
2165 
2166 void nmethod::verify_interrupt_point(address call_site) {
2167   // Verify IC only when nmethod installation is finished.
2168   if (!is_not_installed()) {
2169     if (CompiledICLocker::is_safe(this)) {
2170       CompiledIC_at(this, call_site);
<a name="114" id="anc114"></a><span class="line-removed">2171       CHECK_UNHANDLED_OOPS_ONLY(Thread::current()-&gt;clear_unhandled_oops());</span>
2172     } else {
2173       CompiledICLocker ml_verify(this);
2174       CompiledIC_at(this, call_site);
2175     }
2176   }
2177 
2178   PcDesc* pd = pc_desc_at(nativeCall_at(call_site)-&gt;return_address());
2179   assert(pd != NULL, &quot;PcDesc must exist&quot;);
2180   for (ScopeDesc* sd = new ScopeDesc(this, pd-&gt;scope_decode_offset(),
2181                                      pd-&gt;obj_decode_offset(), pd-&gt;should_reexecute(), pd-&gt;rethrow_exception(),
2182                                      pd-&gt;return_oop());
2183        !sd-&gt;is_top(); sd = sd-&gt;sender()) {
2184     sd-&gt;verify();
2185   }
2186 }
2187 
2188 void nmethod::verify_scopes() {
2189   if( !method() ) return;       // Runtime stubs have no scope
2190   if (method()-&gt;is_native()) return; // Ignore stub methods.
2191   // iterate through all interrupt point
2192   // and verify the debug information is valid.
2193   RelocIterator iter((nmethod*)this);
2194   while (iter.next()) {
2195     address stub = NULL;
2196     switch (iter.type()) {
2197       case relocInfo::virtual_call_type:
2198         verify_interrupt_point(iter.addr());
2199         break;
2200       case relocInfo::opt_virtual_call_type:
2201         stub = iter.opt_virtual_call_reloc()-&gt;static_stub(false);
2202         verify_interrupt_point(iter.addr());
2203         break;
2204       case relocInfo::static_call_type:
2205         stub = iter.static_call_reloc()-&gt;static_stub(false);
2206         //verify_interrupt_point(iter.addr());
2207         break;
2208       case relocInfo::runtime_call_type:
2209       case relocInfo::runtime_call_w_cp_type: {
2210         address destination = iter.reloc()-&gt;value();
2211         // Right now there is no way to find out which entries support
2212         // an interrupt point.  It would be nice if we had this
2213         // information in a table.
2214         break;
2215       }
2216       default:
2217         break;
2218     }
2219     assert(stub == NULL || stub_contains(stub), &quot;static call stub outside stub section&quot;);
2220   }
2221 }
2222 
2223 
2224 // -----------------------------------------------------------------------------
2225 // Printing operations
2226 
2227 void nmethod::print() const {
<a name="115" id="anc115"></a><span class="line-removed">2228   ResourceMark rm;</span>
2229   ttyLocker ttyl;   // keep the following output all in one block
<a name="116" id="anc116"></a>




2230 
<a name="117" id="anc117"></a><span class="line-modified">2231   tty-&gt;print(&quot;Compiled method &quot;);</span>
2232 
2233   if (is_compiled_by_c1()) {
<a name="118" id="anc118"></a><span class="line-modified">2234     tty-&gt;print(&quot;(c1) &quot;);</span>
2235   } else if (is_compiled_by_c2()) {
<a name="119" id="anc119"></a><span class="line-modified">2236     tty-&gt;print(&quot;(c2) &quot;);</span>
2237   } else if (is_compiled_by_jvmci()) {
<a name="120" id="anc120"></a><span class="line-modified">2238     tty-&gt;print(&quot;(JVMCI) &quot;);</span>
2239   } else {
<a name="121" id="anc121"></a><span class="line-modified">2240     tty-&gt;print(&quot;(nm) &quot;);</span>
2241   }
2242 
2243   print_on(tty, NULL);
2244 
2245   if (WizardMode) {
<a name="122" id="anc122"></a><span class="line-modified">2246     tty-&gt;print(&quot;((nmethod*) &quot; INTPTR_FORMAT &quot;) &quot;, p2i(this));</span>
<span class="line-modified">2247     tty-&gt;print(&quot; for method &quot; INTPTR_FORMAT , p2i(method()));</span>
<span class="line-modified">2248     tty-&gt;print(&quot; { &quot;);</span>
<span class="line-modified">2249     tty-&gt;print_cr(&quot;%s &quot;, state());</span>
<span class="line-modified">2250     tty-&gt;print_cr(&quot;}:&quot;);</span>
<span class="line-modified">2251   }</span>
<span class="line-modified">2252   if (size              () &gt; 0) tty-&gt;print_cr(&quot; total in heap  [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="line-modified">2253                                               p2i(this),</span>
<span class="line-modified">2254                                               p2i(this) + size(),</span>
<span class="line-modified">2255                                               size());</span>
<span class="line-modified">2256   if (relocation_size   () &gt; 0) tty-&gt;print_cr(&quot; relocation     [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="line-modified">2257                                               p2i(relocation_begin()),</span>
<span class="line-modified">2258                                               p2i(relocation_end()),</span>
<span class="line-modified">2259                                               relocation_size());</span>
<span class="line-modified">2260   if (consts_size       () &gt; 0) tty-&gt;print_cr(&quot; constants      [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="line-modified">2261                                               p2i(consts_begin()),</span>
<span class="line-modified">2262                                               p2i(consts_end()),</span>
<span class="line-modified">2263                                               consts_size());</span>
<span class="line-modified">2264   if (insts_size        () &gt; 0) tty-&gt;print_cr(&quot; main code      [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="line-modified">2265                                               p2i(insts_begin()),</span>
<span class="line-modified">2266                                               p2i(insts_end()),</span>
<span class="line-modified">2267                                               insts_size());</span>
<span class="line-modified">2268   if (stub_size         () &gt; 0) tty-&gt;print_cr(&quot; stub code      [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="line-modified">2269                                               p2i(stub_begin()),</span>
<span class="line-modified">2270                                               p2i(stub_end()),</span>
<span class="line-modified">2271                                               stub_size());</span>
<span class="line-modified">2272   if (oops_size         () &gt; 0) tty-&gt;print_cr(&quot; oops           [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="line-modified">2273                                               p2i(oops_begin()),</span>
<span class="line-modified">2274                                               p2i(oops_end()),</span>
<span class="line-modified">2275                                               oops_size());</span>
<span class="line-modified">2276   if (metadata_size      () &gt; 0) tty-&gt;print_cr(&quot; metadata       [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="line-modified">2277                                               p2i(metadata_begin()),</span>
<span class="line-modified">2278                                               p2i(metadata_end()),</span>
<span class="line-modified">2279                                               metadata_size());</span>
<span class="line-modified">2280   if (scopes_data_size  () &gt; 0) tty-&gt;print_cr(&quot; scopes data    [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="line-modified">2281                                               p2i(scopes_data_begin()),</span>
<span class="line-modified">2282                                               p2i(scopes_data_end()),</span>
<span class="line-modified">2283                                               scopes_data_size());</span>
<span class="line-modified">2284   if (scopes_pcs_size   () &gt; 0) tty-&gt;print_cr(&quot; scopes pcs     [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="line-modified">2285                                               p2i(scopes_pcs_begin()),</span>
<span class="line-modified">2286                                               p2i(scopes_pcs_end()),</span>
<span class="line-modified">2287                                               scopes_pcs_size());</span>
<span class="line-modified">2288   if (dependencies_size () &gt; 0) tty-&gt;print_cr(&quot; dependencies   [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="line-modified">2289                                               p2i(dependencies_begin()),</span>
<span class="line-modified">2290                                               p2i(dependencies_end()),</span>
<span class="line-modified">2291                                               dependencies_size());</span>
<span class="line-modified">2292   if (handler_table_size() &gt; 0) tty-&gt;print_cr(&quot; handler table  [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="line-modified">2293                                               p2i(handler_table_begin()),</span>
<span class="line-modified">2294                                               p2i(handler_table_end()),</span>
<span class="line-modified">2295                                               handler_table_size());</span>
<span class="line-modified">2296   if (nul_chk_table_size() &gt; 0) tty-&gt;print_cr(&quot; nul chk table  [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] = %d&quot;,</span>
<span class="line-modified">2297                                               p2i(nul_chk_table_begin()),</span>
<span class="line-modified">2298                                               p2i(nul_chk_table_end()),</span>
<span class="line-modified">2299                                               nul_chk_table_size());</span>










2300 }
2301 
<a name="123" id="anc123"></a><span class="line-modified">2302 #ifndef PRODUCT</span>
<span class="line-modified">2303 </span>
<span class="line-modified">2304 void nmethod::print_scopes() {</span>
<span class="line-modified">2305   // Find the first pc desc for all scopes in the code and print it.</span>
<span class="line-modified">2306   ResourceMark rm;</span>
<span class="line-modified">2307   for (PcDesc* p = scopes_pcs_begin(); p &lt; scopes_pcs_end(); p++) {</span>
<span class="line-removed">2308     if (p-&gt;scope_decode_offset() == DebugInformationRecorder::serialized_null)</span>
<span class="line-removed">2309       continue;</span>
<span class="line-removed">2310 </span>
<span class="line-removed">2311     ScopeDesc* sd = scope_desc_at(p-&gt;real_pc(this));</span>
<span class="line-removed">2312     while (sd != NULL) {</span>
<span class="line-removed">2313       sd-&gt;print_on(tty, p);</span>
<span class="line-removed">2314       sd = sd-&gt;sender();</span>
<span class="line-removed">2315     }</span>
<span class="line-removed">2316   }</span>
2317 }
2318 
<a name="124" id="anc124"></a>

2319 void nmethod::print_dependencies() {
2320   ResourceMark rm;
2321   ttyLocker ttyl;   // keep the following output all in one block
2322   tty-&gt;print_cr(&quot;Dependencies:&quot;);
2323   for (Dependencies::DepStream deps(this); deps.next(); ) {
2324     deps.print_dependency();
2325     Klass* ctxk = deps.context_type();
2326     if (ctxk != NULL) {
2327       if (ctxk-&gt;is_instance_klass() &amp;&amp; InstanceKlass::cast(ctxk)-&gt;is_dependent_nmethod(this)) {
2328         tty-&gt;print_cr(&quot;   [nmethod&lt;=klass]%s&quot;, ctxk-&gt;external_name());
2329       }
2330     }
2331     deps.log_dependency();  // put it into the xml log also
2332   }
2333 }
<a name="125" id="anc125"></a>
2334 
<a name="126" id="anc126"></a>














































2335 
<a name="127" id="anc127"></a>























2336 void nmethod::print_relocations() {
2337   ResourceMark m;       // in case methods get printed via the debugger
2338   tty-&gt;print_cr(&quot;relocations:&quot;);
2339   RelocIterator iter(this);
2340   iter.print();
2341 }
<a name="128" id="anc128"></a>
2342 
<a name="129" id="anc129"></a><span class="line-modified">2343 </span>
<span class="line-removed">2344 void nmethod::print_pcs() {</span>
2345   ResourceMark m;       // in case methods get printed via debugger
<a name="130" id="anc130"></a><span class="line-modified">2346   tty-&gt;print_cr(&quot;pc-bytecode offsets:&quot;);</span>
<span class="line-modified">2347   for (PcDesc* p = scopes_pcs_begin(); p &lt; scopes_pcs_end(); p++) {</span>
<span class="line-modified">2348     p-&gt;print(this);</span>





2349   }
2350 }
2351 
<a name="131" id="anc131"></a>







2352 void nmethod::print_recorded_oops() {
<a name="132" id="anc132"></a><span class="line-modified">2353   tty-&gt;print_cr(&quot;Recorded oops:&quot;);</span>
<span class="line-modified">2354   for (int i = 0; i &lt; oops_count(); i++) {</span>
<span class="line-modified">2355     oop o = oop_at(i);</span>
<span class="line-modified">2356     tty-&gt;print(&quot;#%3d: &quot; INTPTR_FORMAT &quot; &quot;, i, p2i(o));</span>
<span class="line-modified">2357     if (o == Universe::non_oop_word()) {</span>
<span class="line-modified">2358       tty-&gt;print(&quot;non-oop word&quot;);</span>
<span class="line-modified">2359     } else {</span>
<span class="line-modified">2360       if (o != NULL) {</span>
<span class="line-modified">2361         o-&gt;print_value();</span>



2362       } else {
<a name="133" id="anc133"></a><span class="line-modified">2363         tty-&gt;print_cr(&quot;NULL&quot;);</span>
2364       }
<a name="134" id="anc134"></a>
2365     }
<a name="135" id="anc135"></a><span class="line-modified">2366     tty-&gt;cr();</span>

2367   }
2368 }
2369 
2370 void nmethod::print_recorded_metadata() {
<a name="136" id="anc136"></a><span class="line-modified">2371   tty-&gt;print_cr(&quot;Recorded metadata:&quot;);</span>
<span class="line-modified">2372   for (int i = 0; i &lt; metadata_count(); i++) {</span>
<span class="line-modified">2373     Metadata* m = metadata_at(i);</span>
<span class="line-modified">2374     tty-&gt;print(&quot;#%3d: &quot; INTPTR_FORMAT &quot; &quot;, i, p2i(m));</span>
<span class="line-modified">2375     if (m == (Metadata*)Universe::non_oop_word()) {</span>
<span class="line-modified">2376       tty-&gt;print(&quot;non-metadata word&quot;);</span>









































2377     } else {
<a name="137" id="anc137"></a><span class="line-modified">2378       Metadata::print_value_on_maybe_null(tty, m);</span>

2379     }
<a name="138" id="anc138"></a><span class="line-modified">2380     tty-&gt;cr();</span>































































2381   }
<a name="139" id="anc139"></a>






























































































































2382 }
2383 
<a name="140" id="anc140"></a><span class="line-modified">2384 #endif // PRODUCT</span>
2385 
2386 const char* nmethod::reloc_string_for(u_char* begin, u_char* end) {
2387   RelocIterator iter(this, begin, end);
2388   bool have_one = false;
2389   while (iter.next()) {
2390     have_one = true;
2391     switch (iter.type()) {
2392         case relocInfo::none:                  return &quot;no_reloc&quot;;
2393         case relocInfo::oop_type: {
<a name="141" id="anc141"></a><span class="line-modified">2394           stringStream st;</span>


2395           oop_Relocation* r = iter.oop_reloc();
2396           oop obj = r-&gt;oop_value();
2397           st.print(&quot;oop(&quot;);
2398           if (obj == NULL) st.print(&quot;NULL&quot;);
2399           else obj-&gt;print_value_on(&amp;st);
2400           st.print(&quot;)&quot;);
2401           return st.as_string();
2402         }
2403         case relocInfo::metadata_type: {
2404           stringStream st;
2405           metadata_Relocation* r = iter.metadata_reloc();
2406           Metadata* obj = r-&gt;metadata_value();
2407           st.print(&quot;metadata(&quot;);
2408           if (obj == NULL) st.print(&quot;NULL&quot;);
2409           else obj-&gt;print_value_on(&amp;st);
2410           st.print(&quot;)&quot;);
2411           return st.as_string();
2412         }
2413         case relocInfo::runtime_call_type:
2414         case relocInfo::runtime_call_w_cp_type: {
2415           stringStream st;
2416           st.print(&quot;runtime_call&quot;);
2417           CallRelocation* r = (CallRelocation*)iter.reloc();
2418           address dest = r-&gt;destination();
2419           CodeBlob* cb = CodeCache::find_blob(dest);
2420           if (cb != NULL) {
2421             st.print(&quot; %s&quot;, cb-&gt;name());
2422           } else {
2423             ResourceMark rm;
2424             const int buflen = 1024;
2425             char* buf = NEW_RESOURCE_ARRAY(char, buflen);
2426             int offset;
2427             if (os::dll_address_to_function_name(dest, buf, buflen, &amp;offset)) {
2428               st.print(&quot; %s&quot;, buf);
2429               if (offset != 0) {
2430                 st.print(&quot;+%d&quot;, offset);
2431               }
2432             }
2433           }
2434           return st.as_string();
2435         }
2436         case relocInfo::virtual_call_type: {
2437           stringStream st;
2438           st.print_raw(&quot;virtual_call&quot;);
2439           virtual_call_Relocation* r = iter.virtual_call_reloc();
2440           Method* m = r-&gt;method_value();
2441           if (m != NULL) {
2442             assert(m-&gt;is_method(), &quot;&quot;);
2443             m-&gt;print_short_name(&amp;st);
2444           }
2445           return st.as_string();
2446         }
2447         case relocInfo::opt_virtual_call_type: {
2448           stringStream st;
2449           st.print_raw(&quot;optimized virtual_call&quot;);
2450           opt_virtual_call_Relocation* r = iter.opt_virtual_call_reloc();
2451           Method* m = r-&gt;method_value();
2452           if (m != NULL) {
2453             assert(m-&gt;is_method(), &quot;&quot;);
2454             m-&gt;print_short_name(&amp;st);
2455           }
2456           return st.as_string();
2457         }
2458         case relocInfo::static_call_type: {
2459           stringStream st;
2460           st.print_raw(&quot;static_call&quot;);
2461           static_call_Relocation* r = iter.static_call_reloc();
2462           Method* m = r-&gt;method_value();
2463           if (m != NULL) {
2464             assert(m-&gt;is_method(), &quot;&quot;);
2465             m-&gt;print_short_name(&amp;st);
2466           }
2467           return st.as_string();
2468         }
2469         case relocInfo::static_stub_type:      return &quot;static_stub&quot;;
2470         case relocInfo::external_word_type:    return &quot;external_word&quot;;
2471         case relocInfo::internal_word_type:    return &quot;internal_word&quot;;
2472         case relocInfo::section_word_type:     return &quot;section_word&quot;;
2473         case relocInfo::poll_type:             return &quot;poll&quot;;
2474         case relocInfo::poll_return_type:      return &quot;poll_return&quot;;
2475         case relocInfo::trampoline_stub_type:  return &quot;trampoline_stub&quot;;
2476         case relocInfo::type_mask:             return &quot;type_bit_mask&quot;;
2477 
2478         default:
2479           break;
2480     }
2481   }
2482   return have_one ? &quot;other&quot; : NULL;
2483 }
2484 
2485 // Return a the last scope in (begin..end]
2486 ScopeDesc* nmethod::scope_desc_in(address begin, address end) {
2487   PcDesc* p = pc_desc_near(begin+1);
2488   if (p != NULL &amp;&amp; p-&gt;real_pc(this) &lt;= end) {
2489     return new ScopeDesc(this, p-&gt;scope_decode_offset(),
2490                          p-&gt;obj_decode_offset(), p-&gt;should_reexecute(), p-&gt;rethrow_exception(),
2491                          p-&gt;return_oop());
2492   }
2493   return NULL;
2494 }
2495 
<a name="142" id="anc142"></a><span class="line-modified">2496 void nmethod::print_nmethod_labels(outputStream* stream, address block_begin) const {</span>
<span class="line-modified">2497   if (block_begin == entry_point())             stream-&gt;print_cr(&quot;[Entry Point]&quot;);</span>
<span class="line-modified">2498   if (block_begin == verified_entry_point())    stream-&gt;print_cr(&quot;[Verified Entry Point]&quot;);</span>
<span class="line-modified">2499   if (JVMCI_ONLY(_exception_offset &gt;= 0 &amp;&amp;) block_begin == exception_begin())         stream-&gt;print_cr(&quot;[Exception Handler]&quot;);</span>
<span class="line-modified">2500   if (block_begin == stub_begin())              stream-&gt;print_cr(&quot;[Stub Code]&quot;);</span>
<span class="line-modified">2501   if (JVMCI_ONLY(_deopt_handler_begin != NULL &amp;&amp;) block_begin == deopt_handler_begin())     stream-&gt;print_cr(&quot;[Deopt Handler Code]&quot;);</span>
<span class="line-modified">2502 </span>
<span class="line-modified">2503   if (has_method_handle_invokes())</span>
<span class="line-modified">2504     if (block_begin == deopt_mh_handler_begin())  stream-&gt;print_cr(&quot;[Deopt MH Handler Code]&quot;);</span>




2505 
<a name="143" id="anc143"></a><span class="line-modified">2506   if (block_begin == consts_begin())            stream-&gt;print_cr(&quot;[Constants]&quot;);</span>







2507 
2508   if (block_begin == entry_point()) {
<a name="144" id="anc144"></a><span class="line-modified">2509     methodHandle m = method();</span>
<span class="line-modified">2510     if (m.not_null()) {</span>
2511       stream-&gt;print(&quot;  # &quot;);
2512       m-&gt;print_value_on(stream);
2513       stream-&gt;cr();
2514     }
<a name="145" id="anc145"></a><span class="line-modified">2515     if (m.not_null() &amp;&amp; !is_osr_method()) {</span>
2516       ResourceMark rm;
2517       int sizeargs = m-&gt;size_of_parameters();
2518       BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, sizeargs);
2519       VMRegPair* regs   = NEW_RESOURCE_ARRAY(VMRegPair, sizeargs);
2520       {
2521         int sig_index = 0;
2522         if (!m-&gt;is_static())
2523           sig_bt[sig_index++] = T_OBJECT; // &#39;this&#39;
2524         for (SignatureStream ss(m-&gt;signature()); !ss.at_return_type(); ss.next()) {
2525           BasicType t = ss.type();
2526           sig_bt[sig_index++] = t;
2527           if (type2size[t] == 2) {
2528             sig_bt[sig_index++] = T_VOID;
2529           } else {
2530             assert(type2size[t] == 1, &quot;size is 1 or 2&quot;);
2531           }
2532         }
2533         assert(sig_index == sizeargs, &quot;&quot;);
2534       }
2535       const char* spname = &quot;sp&quot;; // make arch-specific?
2536       intptr_t out_preserve = SharedRuntime::java_calling_convention(sig_bt, regs, sizeargs, false);
2537       int stack_slot_offset = this-&gt;frame_size() * wordSize;
2538       int tab1 = 14, tab2 = 24;
2539       int sig_index = 0;
2540       int arg_index = (m-&gt;is_static() ? 0 : -1);
2541       bool did_old_sp = false;
2542       for (SignatureStream ss(m-&gt;signature()); !ss.at_return_type(); ) {
2543         bool at_this = (arg_index == -1);
2544         bool at_old_sp = false;
2545         BasicType t = (at_this ? T_OBJECT : ss.type());
2546         assert(t == sig_bt[sig_index], &quot;sigs in sync&quot;);
2547         if (at_this)
2548           stream-&gt;print(&quot;  # this: &quot;);
2549         else
2550           stream-&gt;print(&quot;  # parm%d: &quot;, arg_index);
2551         stream-&gt;move_to(tab1);
2552         VMReg fst = regs[sig_index].first();
2553         VMReg snd = regs[sig_index].second();
2554         if (fst-&gt;is_reg()) {
2555           stream-&gt;print(&quot;%s&quot;, fst-&gt;name());
2556           if (snd-&gt;is_valid())  {
2557             stream-&gt;print(&quot;:%s&quot;, snd-&gt;name());
2558           }
2559         } else if (fst-&gt;is_stack()) {
2560           int offset = fst-&gt;reg2stack() * VMRegImpl::stack_slot_size + stack_slot_offset;
2561           if (offset == stack_slot_offset)  at_old_sp = true;
2562           stream-&gt;print(&quot;[%s+0x%x]&quot;, spname, offset);
2563         } else {
2564           stream-&gt;print(&quot;reg%d:%d??&quot;, (int)(intptr_t)fst, (int)(intptr_t)snd);
2565         }
2566         stream-&gt;print(&quot; &quot;);
2567         stream-&gt;move_to(tab2);
2568         stream-&gt;print(&quot;= &quot;);
2569         if (at_this) {
2570           m-&gt;method_holder()-&gt;print_value_on(stream);
2571         } else {
2572           bool did_name = false;
<a name="146" id="anc146"></a><span class="line-modified">2573           if (!at_this &amp;&amp; ss.is_object()) {</span>
<span class="line-modified">2574             Symbol* name = ss.as_symbol_or_null();</span>
<span class="line-modified">2575             if (name != NULL) {</span>
<span class="line-modified">2576               name-&gt;print_value_on(stream);</span>
<span class="line-removed">2577               did_name = true;</span>
<span class="line-removed">2578             }</span>
2579           }
2580           if (!did_name)
2581             stream-&gt;print(&quot;%s&quot;, type2name(t));
2582         }
2583         if (at_old_sp) {
2584           stream-&gt;print(&quot;  (%s of caller)&quot;, spname);
2585           did_old_sp = true;
2586         }
2587         stream-&gt;cr();
2588         sig_index += type2size[t];
2589         arg_index += 1;
2590         if (!at_this)  ss.next();
2591       }
2592       if (!did_old_sp) {
2593         stream-&gt;print(&quot;  # &quot;);
2594         stream-&gt;move_to(tab1);
2595         stream-&gt;print(&quot;[%s+0x%x]&quot;, spname, stack_slot_offset);
2596         stream-&gt;print(&quot;  (%s of caller)&quot;, spname);
2597         stream-&gt;cr();
2598       }
2599     }
2600   }
2601 }
2602 
<a name="147" id="anc147"></a><span class="line-modified">2603 void nmethod::print_code_comment_on(outputStream* st, int column, u_char* begin, u_char* end) {</span>
<span class="line-modified">2604   // First, find an oopmap in (begin, end].</span>
<span class="line-modified">2605   // We use the odd half-closed interval so that oop maps and scope descs</span>
<span class="line-modified">2606   // which are tied to the byte after a call are printed with the call itself.</span>

































2607   address base = code_begin();
2608   ImmutableOopMapSet* oms = oop_maps();
2609   if (oms != NULL) {
2610     for (int i = 0, imax = oms-&gt;count(); i &lt; imax; i++) {
2611       const ImmutableOopMapPair* pair = oms-&gt;pair_at(i);
2612       const ImmutableOopMap* om = pair-&gt;get_from(oms);
2613       address pc = base + pair-&gt;pc_offset();
<a name="148" id="anc148"></a><span class="line-modified">2614       if (pc &gt; begin) {</span>
<span class="line-modified">2615         if (pc &lt;= end) {</span>
<span class="line-modified">2616           st-&gt;move_to(column);</span>





2617           st-&gt;print(&quot;; &quot;);
2618           om-&gt;print_on(st);
<a name="149" id="anc149"></a>
2619         }
<a name="150" id="anc150"></a>

2620         break;
2621       }
2622     }
2623   }
<a name="151" id="anc151"></a>


2624 
2625   // Print any debug info present at this pc.
2626   ScopeDesc* sd  = scope_desc_in(begin, end);
2627   if (sd != NULL) {
<a name="152" id="anc152"></a><span class="line-modified">2628     st-&gt;move_to(column);</span>
2629     if (sd-&gt;bci() == SynchronizationEntryBCI) {
2630       st-&gt;print(&quot;;*synchronization entry&quot;);
2631     } else if (sd-&gt;bci() == AfterBci) {
2632       st-&gt;print(&quot;;* method exit (unlocked if synchronized)&quot;);
2633     } else if (sd-&gt;bci() == UnwindBci) {
2634       st-&gt;print(&quot;;* unwind (locked if synchronized)&quot;);
2635     } else if (sd-&gt;bci() == AfterExceptionBci) {
2636       st-&gt;print(&quot;;* unwind (unlocked if synchronized)&quot;);
2637     } else if (sd-&gt;bci() == UnknownBci) {
2638       st-&gt;print(&quot;;* unknown&quot;);
2639     } else if (sd-&gt;bci() == InvalidFrameStateBci) {
2640       st-&gt;print(&quot;;* invalid frame state&quot;);
2641     } else {
2642       if (sd-&gt;method() == NULL) {
2643         st-&gt;print(&quot;method is NULL&quot;);
2644       } else if (sd-&gt;method()-&gt;is_native()) {
2645         st-&gt;print(&quot;method is native&quot;);
2646       } else {
2647         Bytecodes::Code bc = sd-&gt;method()-&gt;java_code_at(sd-&gt;bci());
2648         st-&gt;print(&quot;;*%s&quot;, Bytecodes::name(bc));
2649         switch (bc) {
2650         case Bytecodes::_invokevirtual:
2651         case Bytecodes::_invokespecial:
2652         case Bytecodes::_invokestatic:
2653         case Bytecodes::_invokeinterface:
2654           {
<a name="153" id="anc153"></a><span class="line-modified">2655             Bytecode_invoke invoke(sd-&gt;method(), sd-&gt;bci());</span>
2656             st-&gt;print(&quot; &quot;);
2657             if (invoke.name() != NULL)
2658               invoke.name()-&gt;print_symbol_on(st);
2659             else
2660               st-&gt;print(&quot;&lt;UNKNOWN&gt;&quot;);
2661             break;
2662           }
2663         case Bytecodes::_getfield:
2664         case Bytecodes::_putfield:
2665         case Bytecodes::_getstatic:
2666         case Bytecodes::_putstatic:
2667           {
<a name="154" id="anc154"></a><span class="line-modified">2668             Bytecode_field field(sd-&gt;method(), sd-&gt;bci());</span>
2669             st-&gt;print(&quot; &quot;);
2670             if (field.name() != NULL)
2671               field.name()-&gt;print_symbol_on(st);
2672             else
2673               st-&gt;print(&quot;&lt;UNKNOWN&gt;&quot;);
2674           }
2675         default:
2676           break;
2677         }
2678       }
2679       st-&gt;print(&quot; {reexecute=%d rethrow=%d return_oop=%d}&quot;, sd-&gt;should_reexecute(), sd-&gt;rethrow_exception(), sd-&gt;return_oop());
2680     }
2681 
2682     // Print all scopes
2683     for (;sd != NULL; sd = sd-&gt;sender()) {
<a name="155" id="anc155"></a><span class="line-modified">2684       st-&gt;move_to(column);</span>
2685       st-&gt;print(&quot;; -&quot;);
<a name="156" id="anc156"></a>


2686       if (sd-&gt;method() == NULL) {
2687         st-&gt;print(&quot;method is NULL&quot;);
2688       } else {
2689         sd-&gt;method()-&gt;print_short_name(st);
2690       }
2691       int lineno = sd-&gt;method()-&gt;line_number_from_bci(sd-&gt;bci());
2692       if (lineno != -1) {
2693         st-&gt;print(&quot;@%d (line %d)&quot;, sd-&gt;bci(), lineno);
2694       } else {
2695         st-&gt;print(&quot;@%d&quot;, sd-&gt;bci());
2696       }
2697       st-&gt;cr();
2698     }
2699   }
2700 
2701   // Print relocation information
<a name="157" id="anc157"></a>

2702   const char* str = reloc_string_for(begin, end);
2703   if (str != NULL) {
2704     if (sd != NULL) st-&gt;cr();
<a name="158" id="anc158"></a><span class="line-modified">2705     st-&gt;move_to(column);</span>
2706     st-&gt;print(&quot;;   {%s}&quot;, str);
2707   }
<a name="159" id="anc159"></a><span class="line-removed">2708   int cont_offset = ImplicitExceptionTable(this).at(begin - code_begin());</span>
<span class="line-removed">2709   if (cont_offset != 0) {</span>
<span class="line-removed">2710     st-&gt;move_to(column);</span>
<span class="line-removed">2711     st-&gt;print(&quot;; implicit exception: dispatches to &quot; INTPTR_FORMAT, p2i(code_begin() + cont_offset));</span>
<span class="line-removed">2712   }</span>
<span class="line-removed">2713 </span>
2714 }
2715 
<a name="160" id="anc160"></a>

2716 class DirectNativeCallWrapper: public NativeCallWrapper {
2717 private:
2718   NativeCall* _call;
2719 
2720 public:
2721   DirectNativeCallWrapper(NativeCall* call) : _call(call) {}
2722 
2723   virtual address destination() const { return _call-&gt;destination(); }
2724   virtual address instruction_address() const { return _call-&gt;instruction_address(); }
2725   virtual address next_instruction_address() const { return _call-&gt;next_instruction_address(); }
2726   virtual address return_address() const { return _call-&gt;return_address(); }
2727 
2728   virtual address get_resolve_call_stub(bool is_optimized) const {
2729     if (is_optimized) {
2730       return SharedRuntime::get_resolve_opt_virtual_call_stub();
2731     }
2732     return SharedRuntime::get_resolve_virtual_call_stub();
2733   }
2734 
2735   virtual void set_destination_mt_safe(address dest) {
2736 #if INCLUDE_AOT
2737     if (UseAOT) {
2738       CodeBlob* callee = CodeCache::find_blob(dest);
2739       CompiledMethod* cm = callee-&gt;as_compiled_method_or_null();
2740       if (cm != NULL &amp;&amp; cm-&gt;is_far_code()) {
2741         // Temporary fix, see JDK-8143106
2742         CompiledDirectStaticCall* csc = CompiledDirectStaticCall::at(instruction_address());
<a name="161" id="anc161"></a><span class="line-modified">2743         csc-&gt;set_to_far(methodHandle(cm-&gt;method()), dest);</span>
2744         return;
2745       }
2746     }
2747 #endif
2748     _call-&gt;set_destination_mt_safe(dest);
2749   }
2750 
2751   virtual void set_to_interpreted(const methodHandle&amp; method, CompiledICInfo&amp; info) {
2752     CompiledDirectStaticCall* csc = CompiledDirectStaticCall::at(instruction_address());
2753 #if INCLUDE_AOT
2754     if (info.to_aot()) {
2755       csc-&gt;set_to_far(method, info.entry());
2756     } else
2757 #endif
2758     {
2759       csc-&gt;set_to_interpreted(method, info.entry());
2760     }
2761   }
2762 
2763   virtual void verify() const {
2764     // make sure code pattern is actually a call imm32 instruction
2765     _call-&gt;verify();
2766     _call-&gt;verify_alignment();
2767   }
2768 
2769   virtual void verify_resolve_call(address dest) const {
2770     CodeBlob* db = CodeCache::find_blob_unsafe(dest);
2771     assert(db != NULL &amp;&amp; !db-&gt;is_adapter_blob(), &quot;must use stub!&quot;);
2772   }
2773 
2774   virtual bool is_call_to_interpreted(address dest) const {
2775     CodeBlob* cb = CodeCache::find_blob(_call-&gt;instruction_address());
2776     return cb-&gt;contains(dest);
2777   }
2778 
2779   virtual bool is_safe_for_patching() const { return false; }
2780 
2781   virtual NativeInstruction* get_load_instruction(virtual_call_Relocation* r) const {
2782     return nativeMovConstReg_at(r-&gt;cached_value());
2783   }
2784 
2785   virtual void *get_data(NativeInstruction* instruction) const {
2786     return (void*)((NativeMovConstReg*) instruction)-&gt;data();
2787   }
2788 
2789   virtual void set_data(NativeInstruction* instruction, intptr_t data) {
2790     ((NativeMovConstReg*) instruction)-&gt;set_data(data);
2791   }
2792 };
2793 
2794 NativeCallWrapper* nmethod::call_wrapper_at(address call) const {
2795   return new DirectNativeCallWrapper((NativeCall*) call);
2796 }
2797 
2798 NativeCallWrapper* nmethod::call_wrapper_before(address return_pc) const {
2799   return new DirectNativeCallWrapper(nativeCall_before(return_pc));
2800 }
2801 
2802 address nmethod::call_instruction_address(address pc) const {
2803   if (NativeCall::is_call_before(pc)) {
2804     NativeCall *ncall = nativeCall_before(pc);
2805     return ncall-&gt;instruction_address();
2806   }
2807   return NULL;
2808 }
2809 
2810 CompiledStaticCall* nmethod::compiledStaticCall_at(Relocation* call_site) const {
2811   return CompiledDirectStaticCall::at(call_site);
2812 }
2813 
2814 CompiledStaticCall* nmethod::compiledStaticCall_at(address call_site) const {
2815   return CompiledDirectStaticCall::at(call_site);
2816 }
2817 
2818 CompiledStaticCall* nmethod::compiledStaticCall_before(address return_addr) const {
2819   return CompiledDirectStaticCall::before(return_addr);
2820 }
2821 
<a name="162" id="anc162"></a><span class="line-modified">2822 #ifndef PRODUCT</span>
<span class="line-removed">2823 </span>
2824 void nmethod::print_value_on(outputStream* st) const {
2825   st-&gt;print(&quot;nmethod&quot;);
2826   print_on(st, NULL);
2827 }
<a name="163" id="anc163"></a>


2828 
2829 void nmethod::print_calls(outputStream* st) {
2830   RelocIterator iter(this);
2831   while (iter.next()) {
2832     switch (iter.type()) {
2833     case relocInfo::virtual_call_type:
2834     case relocInfo::opt_virtual_call_type: {
2835       CompiledICLocker ml_verify(this);
2836       CompiledIC_at(&amp;iter)-&gt;print();
2837       break;
2838     }
2839     case relocInfo::static_call_type:
2840       st-&gt;print_cr(&quot;Static call at &quot; INTPTR_FORMAT, p2i(iter.reloc()-&gt;addr()));
2841       CompiledDirectStaticCall::at(iter.reloc())-&gt;print();
2842       break;
2843     default:
2844       break;
2845     }
2846   }
2847 }
2848 
<a name="164" id="anc164"></a><span class="line-removed">2849 void nmethod::print_handler_table() {</span>
<span class="line-removed">2850   ExceptionHandlerTable(this).print();</span>
<span class="line-removed">2851 }</span>
<span class="line-removed">2852 </span>
<span class="line-removed">2853 void nmethod::print_nul_chk_table() {</span>
<span class="line-removed">2854   ImplicitExceptionTable(this).print(code_begin());</span>
<span class="line-removed">2855 }</span>
<span class="line-removed">2856 </span>
2857 void nmethod::print_statistics() {
2858   ttyLocker ttyl;
2859   if (xtty != NULL)  xtty-&gt;head(&quot;statistics type=&#39;nmethod&#39;&quot;);
2860   native_nmethod_stats.print_native_nmethod_stats();
2861 #ifdef COMPILER1
2862   c1_java_nmethod_stats.print_nmethod_stats(&quot;C1&quot;);
2863 #endif
2864 #ifdef COMPILER2
2865   c2_java_nmethod_stats.print_nmethod_stats(&quot;C2&quot;);
2866 #endif
2867 #if INCLUDE_JVMCI
2868   jvmci_java_nmethod_stats.print_nmethod_stats(&quot;JVMCI&quot;);
2869 #endif
2870   unknown_java_nmethod_stats.print_nmethod_stats(&quot;Unknown&quot;);
2871   DebugInformationRecorder::print_statistics();
2872 #ifndef PRODUCT
2873   pc_nmethod_stats.print_pc_stats();
2874 #endif
2875   Dependencies::print_statistics();
2876   if (xtty != NULL)  xtty-&gt;tail(&quot;statistics&quot;);
2877 }
2878 
2879 #endif // !PRODUCT
2880 
2881 #if INCLUDE_JVMCI
<a name="165" id="anc165"></a><span class="line-modified">2882 void nmethod::clear_jvmci_installed_code() {</span>
<span class="line-modified">2883   assert_locked_or_safepoint(Patching_lock);</span>
<span class="line-modified">2884   if (_jvmci_installed_code != NULL) {</span>
<span class="line-modified">2885     JNIHandles::destroy_weak_global(_jvmci_installed_code);</span>
<span class="line-modified">2886     _jvmci_installed_code = NULL;</span>
<span class="line-modified">2887   }</span>
<span class="line-removed">2888 }</span>
<span class="line-removed">2889 </span>
<span class="line-removed">2890 void nmethod::clear_speculation_log() {</span>
<span class="line-removed">2891   assert_locked_or_safepoint(Patching_lock);</span>
<span class="line-removed">2892   if (_speculation_log != NULL) {</span>
<span class="line-removed">2893     JNIHandles::destroy_weak_global(_speculation_log);</span>
<span class="line-removed">2894     _speculation_log = NULL;</span>
<span class="line-removed">2895   }</span>
<span class="line-removed">2896 }</span>
<span class="line-removed">2897 </span>
<span class="line-removed">2898 void nmethod::maybe_invalidate_installed_code() {</span>
<span class="line-removed">2899   if (!is_compiled_by_jvmci()) {</span>
<span class="line-removed">2900     return;</span>
<span class="line-removed">2901   }</span>
<span class="line-removed">2902 </span>
<span class="line-removed">2903   assert(Patching_lock-&gt;is_locked() ||</span>
<span class="line-removed">2904          SafepointSynchronize::is_at_safepoint(), &quot;should be performed under a lock for consistency&quot;);</span>
<span class="line-removed">2905   oop installed_code = JNIHandles::resolve(_jvmci_installed_code);</span>
<span class="line-removed">2906   if (installed_code != NULL) {</span>
<span class="line-removed">2907     // Update the values in the InstalledCode instance if it still refers to this nmethod</span>
<span class="line-removed">2908     nmethod* nm = (nmethod*)InstalledCode::address(installed_code);</span>
<span class="line-removed">2909     if (nm == this) {</span>
<span class="line-removed">2910       if (!is_alive() || is_unloading()) {</span>
<span class="line-removed">2911         // Break the link between nmethod and InstalledCode such that the nmethod</span>
<span class="line-removed">2912         // can subsequently be flushed safely.  The link must be maintained while</span>
<span class="line-removed">2913         // the method could have live activations since invalidateInstalledCode</span>
<span class="line-removed">2914         // might want to invalidate all existing activations.</span>
<span class="line-removed">2915         InstalledCode::set_address(installed_code, 0);</span>
<span class="line-removed">2916         InstalledCode::set_entryPoint(installed_code, 0);</span>
<span class="line-removed">2917       } else if (is_not_entrant()) {</span>
<span class="line-removed">2918         // Remove the entry point so any invocation will fail but keep</span>
<span class="line-removed">2919         // the address link around that so that existing activations can</span>
<span class="line-removed">2920         // be invalidated.</span>
<span class="line-removed">2921         InstalledCode::set_entryPoint(installed_code, 0);</span>
<span class="line-removed">2922       }</span>
<span class="line-removed">2923     }</span>
<span class="line-removed">2924   }</span>
<span class="line-removed">2925   if (!is_alive() || is_unloading()) {</span>
<span class="line-removed">2926     // Clear these out after the nmethod has been unregistered and any</span>
<span class="line-removed">2927     // updates to the InstalledCode instance have been performed.</span>
<span class="line-removed">2928     clear_jvmci_installed_code();</span>
<span class="line-removed">2929     clear_speculation_log();</span>
2930   }
2931 }
2932 
<a name="166" id="anc166"></a><span class="line-modified">2933 void nmethod::invalidate_installed_code(Handle installedCode, TRAPS) {</span>
<span class="line-modified">2934   if (installedCode() == NULL) {</span>
<span class="line-modified">2935     THROW(vmSymbols::java_lang_NullPointerException());</span>
<span class="line-removed">2936   }</span>
<span class="line-removed">2937   jlong nativeMethod = InstalledCode::address(installedCode);</span>
<span class="line-removed">2938   nmethod* nm = (nmethod*)nativeMethod;</span>
<span class="line-removed">2939   if (nm == NULL) {</span>
<span class="line-removed">2940     // Nothing to do</span>
<span class="line-removed">2941     return;</span>
<span class="line-removed">2942   }</span>
<span class="line-removed">2943 </span>
<span class="line-removed">2944   nmethodLocker nml(nm);</span>
<span class="line-removed">2945 #ifdef ASSERT</span>
<span class="line-removed">2946   {</span>
<span class="line-removed">2947     MutexLockerEx pl(Patching_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed">2948     // This relationship can only be checked safely under a lock</span>
<span class="line-removed">2949     assert(!nm-&gt;is_alive() || nm-&gt;is_unloading() || nm-&gt;jvmci_installed_code() == installedCode(), &quot;sanity check&quot;);</span>
<span class="line-removed">2950   }</span>
<span class="line-removed">2951 #endif</span>
<span class="line-removed">2952 </span>
<span class="line-removed">2953   if (nm-&gt;is_alive()) {</span>
<span class="line-removed">2954     // Invalidating the InstalledCode means we want the nmethod</span>
<span class="line-removed">2955     // to be deoptimized.</span>
<span class="line-removed">2956     nm-&gt;mark_for_deoptimization();</span>
<span class="line-removed">2957     VM_Deoptimize op;</span>
<span class="line-removed">2958     VMThread::execute(&amp;op);</span>
<span class="line-removed">2959   }</span>
<span class="line-removed">2960 </span>
<span class="line-removed">2961   // Multiple threads could reach this point so we now need to</span>
<span class="line-removed">2962   // lock and re-check the link to the nmethod so that only one</span>
<span class="line-removed">2963   // thread clears it.</span>
<span class="line-removed">2964   MutexLockerEx pl(Patching_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed">2965   if (InstalledCode::address(installedCode) == nativeMethod) {</span>
<span class="line-removed">2966       InstalledCode::set_address(installedCode, 0);</span>
<span class="line-removed">2967   }</span>
<span class="line-removed">2968 }</span>
<span class="line-removed">2969 </span>
<span class="line-removed">2970 oop nmethod::jvmci_installed_code() {</span>
<span class="line-removed">2971   return JNIHandles::resolve(_jvmci_installed_code);</span>
<span class="line-removed">2972 }</span>
<span class="line-removed">2973 </span>
<span class="line-removed">2974 oop nmethod::speculation_log() {</span>
<span class="line-removed">2975   return JNIHandles::resolve(_speculation_log);</span>
<span class="line-removed">2976 }</span>
<span class="line-removed">2977 </span>
<span class="line-removed">2978 char* nmethod::jvmci_installed_code_name(char* buf, size_t buflen) const {</span>
<span class="line-removed">2979   if (!this-&gt;is_compiled_by_jvmci()) {</span>
<span class="line-removed">2980     return NULL;</span>
<span class="line-removed">2981   }</span>
<span class="line-removed">2982   oop installed_code = JNIHandles::resolve(_jvmci_installed_code);</span>
<span class="line-removed">2983   if (installed_code != NULL) {</span>
<span class="line-removed">2984     oop installed_code_name = NULL;</span>
<span class="line-removed">2985     if (installed_code-&gt;is_a(InstalledCode::klass())) {</span>
<span class="line-removed">2986       installed_code_name = InstalledCode::name(installed_code);</span>
<span class="line-removed">2987     }</span>
<span class="line-removed">2988     if (installed_code_name != NULL) {</span>
<span class="line-removed">2989       return java_lang_String::as_utf8_string(installed_code_name, buf, (int)buflen);</span>
<span class="line-removed">2990     }</span>
2991   }
2992   return NULL;
2993 }
2994 #endif
<a name="167" id="anc167"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="167" type="hidden" />
</body>
</html>
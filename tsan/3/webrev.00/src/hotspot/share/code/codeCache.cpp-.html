<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/code/codeCache.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;code/codeBlob.hpp&quot;
  28 #include &quot;code/codeCache.hpp&quot;
  29 #include &quot;code/codeHeapState.hpp&quot;
  30 #include &quot;code/compiledIC.hpp&quot;
  31 #include &quot;code/dependencies.hpp&quot;
  32 #include &quot;code/dependencyContext.hpp&quot;
  33 #include &quot;code/icBuffer.hpp&quot;
  34 #include &quot;code/nmethod.hpp&quot;
  35 #include &quot;code/pcDesc.hpp&quot;
  36 #include &quot;compiler/compileBroker.hpp&quot;
  37 #include &quot;jfr/jfrEvents.hpp&quot;
  38 #include &quot;logging/log.hpp&quot;
  39 #include &quot;logging/logStream.hpp&quot;
  40 #include &quot;memory/allocation.inline.hpp&quot;
  41 #include &quot;memory/iterator.hpp&quot;
  42 #include &quot;memory/resourceArea.hpp&quot;
  43 #include &quot;oops/method.inline.hpp&quot;
  44 #include &quot;oops/objArrayOop.hpp&quot;
  45 #include &quot;oops/oop.inline.hpp&quot;
  46 #include &quot;oops/verifyOopClosure.hpp&quot;
  47 #include &quot;runtime/arguments.hpp&quot;
  48 #include &quot;runtime/compilationPolicy.hpp&quot;
  49 #include &quot;runtime/deoptimization.hpp&quot;
  50 #include &quot;runtime/handles.inline.hpp&quot;
  51 #include &quot;runtime/icache.hpp&quot;
  52 #include &quot;runtime/java.hpp&quot;
  53 #include &quot;runtime/mutexLocker.hpp&quot;
  54 #include &quot;runtime/safepointVerifiers.hpp&quot;
  55 #include &quot;runtime/sweeper.hpp&quot;
  56 #include &quot;runtime/vmThread.hpp&quot;
  57 #include &quot;services/memoryService.hpp&quot;
  58 #include &quot;utilities/align.hpp&quot;
  59 #include &quot;utilities/vmError.hpp&quot;
  60 #include &quot;utilities/xmlstream.hpp&quot;
  61 #ifdef COMPILER1
  62 #include &quot;c1/c1_Compilation.hpp&quot;
  63 #include &quot;c1/c1_Compiler.hpp&quot;
  64 #endif
  65 #ifdef COMPILER2
  66 #include &quot;opto/c2compiler.hpp&quot;
  67 #include &quot;opto/compile.hpp&quot;
  68 #include &quot;opto/node.hpp&quot;
  69 #endif
  70 
  71 // Helper class for printing in CodeCache
  72 class CodeBlob_sizes {
  73  private:
  74   int count;
  75   int total_size;
  76   int header_size;
  77   int code_size;
  78   int stub_size;
  79   int relocation_size;
  80   int scopes_oop_size;
  81   int scopes_metadata_size;
  82   int scopes_data_size;
  83   int scopes_pcs_size;
  84 
  85  public:
  86   CodeBlob_sizes() {
  87     count            = 0;
  88     total_size       = 0;
  89     header_size      = 0;
  90     code_size        = 0;
  91     stub_size        = 0;
  92     relocation_size  = 0;
  93     scopes_oop_size  = 0;
  94     scopes_metadata_size  = 0;
  95     scopes_data_size = 0;
  96     scopes_pcs_size  = 0;
  97   }
  98 
  99   int total()                                    { return total_size; }
 100   bool is_empty()                                { return count == 0; }
 101 
 102   void print(const char* title) {
 103     tty-&gt;print_cr(&quot; #%d %s = %dK (hdr %d%%,  loc %d%%, code %d%%, stub %d%%, [oops %d%%, metadata %d%%, data %d%%, pcs %d%%])&quot;,
 104                   count,
 105                   title,
 106                   (int)(total() / K),
 107                   header_size             * 100 / total_size,
 108                   relocation_size         * 100 / total_size,
 109                   code_size               * 100 / total_size,
 110                   stub_size               * 100 / total_size,
 111                   scopes_oop_size         * 100 / total_size,
 112                   scopes_metadata_size    * 100 / total_size,
 113                   scopes_data_size        * 100 / total_size,
 114                   scopes_pcs_size         * 100 / total_size);
 115   }
 116 
 117   void add(CodeBlob* cb) {
 118     count++;
 119     total_size       += cb-&gt;size();
 120     header_size      += cb-&gt;header_size();
 121     relocation_size  += cb-&gt;relocation_size();
 122     if (cb-&gt;is_nmethod()) {
 123       nmethod* nm = cb-&gt;as_nmethod_or_null();
 124       code_size        += nm-&gt;insts_size();
 125       stub_size        += nm-&gt;stub_size();
 126 
 127       scopes_oop_size  += nm-&gt;oops_size();
 128       scopes_metadata_size  += nm-&gt;metadata_size();
 129       scopes_data_size += nm-&gt;scopes_data_size();
 130       scopes_pcs_size  += nm-&gt;scopes_pcs_size();
 131     } else {
 132       code_size        += cb-&gt;code_size();
 133     }
 134   }
 135 };
 136 
 137 // Iterate over all CodeHeaps
 138 #define FOR_ALL_HEAPS(heap) for (GrowableArrayIterator&lt;CodeHeap*&gt; heap = _heaps-&gt;begin(); heap != _heaps-&gt;end(); ++heap)
 139 #define FOR_ALL_NMETHOD_HEAPS(heap) for (GrowableArrayIterator&lt;CodeHeap*&gt; heap = _nmethod_heaps-&gt;begin(); heap != _nmethod_heaps-&gt;end(); ++heap)
 140 #define FOR_ALL_ALLOCABLE_HEAPS(heap) for (GrowableArrayIterator&lt;CodeHeap*&gt; heap = _allocable_heaps-&gt;begin(); heap != _allocable_heaps-&gt;end(); ++heap)
 141 
 142 // Iterate over all CodeBlobs (cb) on the given CodeHeap
 143 #define FOR_ALL_BLOBS(cb, heap) for (CodeBlob* cb = first_blob(heap); cb != NULL; cb = next_blob(heap, cb))
 144 
 145 address CodeCache::_low_bound = 0;
 146 address CodeCache::_high_bound = 0;
 147 int CodeCache::_number_of_nmethods_with_dependencies = 0;
 148 ExceptionCache* volatile CodeCache::_exception_cache_purge_list = NULL;
 149 
 150 // Initialize arrays of CodeHeap subsets
 151 GrowableArray&lt;CodeHeap*&gt;* CodeCache::_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray&lt;CodeHeap*&gt; (CodeBlobType::All, true);
 152 GrowableArray&lt;CodeHeap*&gt;* CodeCache::_compiled_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray&lt;CodeHeap*&gt; (CodeBlobType::All, true);
 153 GrowableArray&lt;CodeHeap*&gt;* CodeCache::_nmethod_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray&lt;CodeHeap*&gt; (CodeBlobType::All, true);
 154 GrowableArray&lt;CodeHeap*&gt;* CodeCache::_allocable_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray&lt;CodeHeap*&gt; (CodeBlobType::All, true);
 155 
 156 void CodeCache::check_heap_sizes(size_t non_nmethod_size, size_t profiled_size, size_t non_profiled_size, size_t cache_size, bool all_set) {
 157   size_t total_size = non_nmethod_size + profiled_size + non_profiled_size;
 158   // Prepare error message
 159   const char* error = &quot;Invalid code heap sizes&quot;;
 160   err_msg message(&quot;NonNMethodCodeHeapSize (&quot; SIZE_FORMAT &quot;K) + ProfiledCodeHeapSize (&quot; SIZE_FORMAT &quot;K)&quot;
 161                   &quot; + NonProfiledCodeHeapSize (&quot; SIZE_FORMAT &quot;K) = &quot; SIZE_FORMAT &quot;K&quot;,
 162           non_nmethod_size/K, profiled_size/K, non_profiled_size/K, total_size/K);
 163 
 164   if (total_size &gt; cache_size) {
 165     // Some code heap sizes were explicitly set: total_size must be &lt;= cache_size
 166     message.append(&quot; is greater than ReservedCodeCacheSize (&quot; SIZE_FORMAT &quot;K).&quot;, cache_size/K);
 167     vm_exit_during_initialization(error, message);
 168   } else if (all_set &amp;&amp; total_size != cache_size) {
 169     // All code heap sizes were explicitly set: total_size must equal cache_size
 170     message.append(&quot; is not equal to ReservedCodeCacheSize (&quot; SIZE_FORMAT &quot;K).&quot;, cache_size/K);
 171     vm_exit_during_initialization(error, message);
 172   }
 173 }
 174 
 175 void CodeCache::initialize_heaps() {
 176   bool non_nmethod_set      = FLAG_IS_CMDLINE(NonNMethodCodeHeapSize);
 177   bool profiled_set         = FLAG_IS_CMDLINE(ProfiledCodeHeapSize);
 178   bool non_profiled_set     = FLAG_IS_CMDLINE(NonProfiledCodeHeapSize);
 179   size_t min_size           = os::vm_page_size();
 180   size_t cache_size         = ReservedCodeCacheSize;
 181   size_t non_nmethod_size   = NonNMethodCodeHeapSize;
 182   size_t profiled_size      = ProfiledCodeHeapSize;
 183   size_t non_profiled_size  = NonProfiledCodeHeapSize;
 184   // Check if total size set via command line flags exceeds the reserved size
 185   check_heap_sizes((non_nmethod_set  ? non_nmethod_size  : min_size),
 186                    (profiled_set     ? profiled_size     : min_size),
 187                    (non_profiled_set ? non_profiled_size : min_size),
 188                    cache_size,
 189                    non_nmethod_set &amp;&amp; profiled_set &amp;&amp; non_profiled_set);
 190 
 191   // Determine size of compiler buffers
 192   size_t code_buffers_size = 0;
 193 #ifdef COMPILER1
 194   // C1 temporary code buffers (see Compiler::init_buffer_blob())
 195   const int c1_count = CompilationPolicy::policy()-&gt;compiler_count(CompLevel_simple);
 196   code_buffers_size += c1_count * Compiler::code_buffer_size();
 197 #endif
 198 #ifdef COMPILER2
 199   // C2 scratch buffers (see Compile::init_scratch_buffer_blob())
 200   const int c2_count = CompilationPolicy::policy()-&gt;compiler_count(CompLevel_full_optimization);
 201   // Initial size of constant table (this may be increased if a compiled method needs more space)
 202   code_buffers_size += c2_count * C2Compiler::initial_code_buffer_size();
 203 #endif
 204 
 205   // Increase default non_nmethod_size to account for compiler buffers
 206   if (!non_nmethod_set) {
 207     non_nmethod_size += code_buffers_size;
 208   }
 209   // Calculate default CodeHeap sizes if not set by user
 210   if (!non_nmethod_set &amp;&amp; !profiled_set &amp;&amp; !non_profiled_set) {
 211     // Check if we have enough space for the non-nmethod code heap
 212     if (cache_size &gt; non_nmethod_size) {
 213       // Use the default value for non_nmethod_size and one half of the
 214       // remaining size for non-profiled and one half for profiled methods
 215       size_t remaining_size = cache_size - non_nmethod_size;
 216       profiled_size = remaining_size / 2;
 217       non_profiled_size = remaining_size - profiled_size;
 218     } else {
 219       // Use all space for the non-nmethod heap and set other heaps to minimal size
 220       non_nmethod_size = cache_size - 2 * min_size;
 221       profiled_size = min_size;
 222       non_profiled_size = min_size;
 223     }
 224   } else if (!non_nmethod_set || !profiled_set || !non_profiled_set) {
 225     // The user explicitly set some code heap sizes. Increase or decrease the (default)
 226     // sizes of the other code heaps accordingly. First adapt non-profiled and profiled
 227     // code heap sizes and then only change non-nmethod code heap size if still necessary.
 228     intx diff_size = cache_size - (non_nmethod_size + profiled_size + non_profiled_size);
 229     if (non_profiled_set) {
 230       if (!profiled_set) {
 231         // Adapt size of profiled code heap
 232         if (diff_size &lt; 0 &amp;&amp; ((intx)profiled_size + diff_size) &lt;= 0) {
 233           // Not enough space available, set to minimum size
 234           diff_size += profiled_size - min_size;
 235           profiled_size = min_size;
 236         } else {
 237           profiled_size += diff_size;
 238           diff_size = 0;
 239         }
 240       }
 241     } else if (profiled_set) {
 242       // Adapt size of non-profiled code heap
 243       if (diff_size &lt; 0 &amp;&amp; ((intx)non_profiled_size + diff_size) &lt;= 0) {
 244         // Not enough space available, set to minimum size
 245         diff_size += non_profiled_size - min_size;
 246         non_profiled_size = min_size;
 247       } else {
 248         non_profiled_size += diff_size;
 249         diff_size = 0;
 250       }
 251     } else if (non_nmethod_set) {
 252       // Distribute remaining size between profiled and non-profiled code heaps
 253       diff_size = cache_size - non_nmethod_size;
 254       profiled_size = diff_size / 2;
 255       non_profiled_size = diff_size - profiled_size;
 256       diff_size = 0;
 257     }
 258     if (diff_size != 0) {
 259       // Use non-nmethod code heap for remaining space requirements
 260       assert(!non_nmethod_set &amp;&amp; ((intx)non_nmethod_size + diff_size) &gt; 0, &quot;sanity&quot;);
 261       non_nmethod_size += diff_size;
 262     }
 263   }
 264 
 265   // We do not need the profiled CodeHeap, use all space for the non-profiled CodeHeap
 266   if (!heap_available(CodeBlobType::MethodProfiled)) {
 267     non_profiled_size += profiled_size;
 268     profiled_size = 0;
 269   }
 270   // We do not need the non-profiled CodeHeap, use all space for the non-nmethod CodeHeap
 271   if (!heap_available(CodeBlobType::MethodNonProfiled)) {
 272     non_nmethod_size += non_profiled_size;
 273     non_profiled_size = 0;
 274   }
 275   // Make sure we have enough space for VM internal code
 276   uint min_code_cache_size = CodeCacheMinimumUseSpace DEBUG_ONLY(* 3);
 277   if (non_nmethod_size &lt; min_code_cache_size) {
 278     vm_exit_during_initialization(err_msg(
 279         &quot;Not enough space in non-nmethod code heap to run VM: &quot; SIZE_FORMAT &quot;K &lt; &quot; SIZE_FORMAT &quot;K&quot;,
 280         non_nmethod_size/K, min_code_cache_size/K));
 281   }
 282 
 283   // Verify sizes and update flag values
 284   assert(non_profiled_size + profiled_size + non_nmethod_size == cache_size, &quot;Invalid code heap sizes&quot;);
 285   FLAG_SET_ERGO(uintx, NonNMethodCodeHeapSize, non_nmethod_size);
 286   FLAG_SET_ERGO(uintx, ProfiledCodeHeapSize, profiled_size);
 287   FLAG_SET_ERGO(uintx, NonProfiledCodeHeapSize, non_profiled_size);
 288 
 289   // If large page support is enabled, align code heaps according to large
 290   // page size to make sure that code cache is covered by large pages.
 291   const size_t alignment = MAX2(page_size(false, 8), (size_t) os::vm_allocation_granularity());
 292   non_nmethod_size = align_up(non_nmethod_size, alignment);
 293   profiled_size    = align_down(profiled_size, alignment);
 294 
 295   // Reserve one continuous chunk of memory for CodeHeaps and split it into
 296   // parts for the individual heaps. The memory layout looks like this:
 297   // ---------- high -----------
 298   //    Non-profiled nmethods
 299   //      Profiled nmethods
 300   //         Non-nmethods
 301   // ---------- low ------------
 302   ReservedCodeSpace rs = reserve_heap_memory(cache_size);
 303   ReservedSpace non_method_space    = rs.first_part(non_nmethod_size);
 304   ReservedSpace rest                = rs.last_part(non_nmethod_size);
 305   ReservedSpace profiled_space      = rest.first_part(profiled_size);
 306   ReservedSpace non_profiled_space  = rest.last_part(profiled_size);
 307 
 308   // Non-nmethods (stubs, adapters, ...)
 309   add_heap(non_method_space, &quot;CodeHeap &#39;non-nmethods&#39;&quot;, CodeBlobType::NonNMethod);
 310   // Tier 2 and tier 3 (profiled) methods
 311   add_heap(profiled_space, &quot;CodeHeap &#39;profiled nmethods&#39;&quot;, CodeBlobType::MethodProfiled);
 312   // Tier 1 and tier 4 (non-profiled) methods and native methods
 313   add_heap(non_profiled_space, &quot;CodeHeap &#39;non-profiled nmethods&#39;&quot;, CodeBlobType::MethodNonProfiled);
 314 }
 315 
 316 size_t CodeCache::page_size(bool aligned, size_t min_pages) {
 317   if (os::can_execute_large_page_memory()) {
 318     if (InitialCodeCacheSize &lt; ReservedCodeCacheSize) {
 319       // Make sure that the page size allows for an incremental commit of the reserved space
 320       min_pages = MAX2(min_pages, (size_t)8);
 321     }
 322     return aligned ? os::page_size_for_region_aligned(ReservedCodeCacheSize, min_pages) :
 323                      os::page_size_for_region_unaligned(ReservedCodeCacheSize, min_pages);
 324   } else {
 325     return os::vm_page_size();
 326   }
 327 }
 328 
 329 ReservedCodeSpace CodeCache::reserve_heap_memory(size_t size) {
 330   // Align and reserve space for code cache
 331   const size_t rs_ps = page_size();
 332   const size_t rs_align = MAX2(rs_ps, (size_t) os::vm_allocation_granularity());
 333   const size_t rs_size = align_up(size, rs_align);
 334   ReservedCodeSpace rs(rs_size, rs_align, rs_ps &gt; (size_t) os::vm_page_size());
 335   if (!rs.is_reserved()) {
 336     vm_exit_during_initialization(err_msg(&quot;Could not reserve enough space for code cache (&quot; SIZE_FORMAT &quot;K)&quot;,
 337                                           rs_size/K));
 338   }
 339 
 340   // Initialize bounds
 341   _low_bound = (address)rs.base();
 342   _high_bound = _low_bound + rs.size();
 343   return rs;
 344 }
 345 
 346 // Heaps available for allocation
 347 bool CodeCache::heap_available(int code_blob_type) {
 348   if (!SegmentedCodeCache) {
 349     // No segmentation: use a single code heap
 350     return (code_blob_type == CodeBlobType::All);
 351   } else if (Arguments::is_interpreter_only()) {
 352     // Interpreter only: we don&#39;t need any method code heaps
 353     return (code_blob_type == CodeBlobType::NonNMethod);
 354   } else if (TieredCompilation &amp;&amp; (TieredStopAtLevel &gt; CompLevel_simple)) {
 355     // Tiered compilation: use all code heaps
 356     return (code_blob_type &lt; CodeBlobType::All);
 357   } else {
 358     // No TieredCompilation: we only need the non-nmethod and non-profiled code heap
 359     return (code_blob_type == CodeBlobType::NonNMethod) ||
 360            (code_blob_type == CodeBlobType::MethodNonProfiled);
 361   }
 362 }
 363 
 364 const char* CodeCache::get_code_heap_flag_name(int code_blob_type) {
 365   switch(code_blob_type) {
 366   case CodeBlobType::NonNMethod:
 367     return &quot;NonNMethodCodeHeapSize&quot;;
 368     break;
 369   case CodeBlobType::MethodNonProfiled:
 370     return &quot;NonProfiledCodeHeapSize&quot;;
 371     break;
 372   case CodeBlobType::MethodProfiled:
 373     return &quot;ProfiledCodeHeapSize&quot;;
 374     break;
 375   }
 376   ShouldNotReachHere();
 377   return NULL;
 378 }
 379 
 380 int CodeCache::code_heap_compare(CodeHeap* const &amp;lhs, CodeHeap* const &amp;rhs) {
 381   if (lhs-&gt;code_blob_type() == rhs-&gt;code_blob_type()) {
 382     return (lhs &gt; rhs) ? 1 : ((lhs &lt; rhs) ? -1 : 0);
 383   } else {
 384     return lhs-&gt;code_blob_type() - rhs-&gt;code_blob_type();
 385   }
 386 }
 387 
 388 void CodeCache::add_heap(CodeHeap* heap) {
 389   assert(!Universe::is_fully_initialized(), &quot;late heap addition?&quot;);
 390 
 391   _heaps-&gt;insert_sorted&lt;code_heap_compare&gt;(heap);
 392 
 393   int type = heap-&gt;code_blob_type();
 394   if (code_blob_type_accepts_compiled(type)) {
 395     _compiled_heaps-&gt;insert_sorted&lt;code_heap_compare&gt;(heap);
 396   }
 397   if (code_blob_type_accepts_nmethod(type)) {
 398     _nmethod_heaps-&gt;insert_sorted&lt;code_heap_compare&gt;(heap);
 399   }
 400   if (code_blob_type_accepts_allocable(type)) {
 401     _allocable_heaps-&gt;insert_sorted&lt;code_heap_compare&gt;(heap);
 402   }
 403 }
 404 
 405 void CodeCache::add_heap(ReservedSpace rs, const char* name, int code_blob_type) {
 406   // Check if heap is needed
 407   if (!heap_available(code_blob_type)) {
 408     return;
 409   }
 410 
 411   // Create CodeHeap
 412   CodeHeap* heap = new CodeHeap(name, code_blob_type);
 413   add_heap(heap);
 414 
 415   // Reserve Space
 416   size_t size_initial = MIN2((size_t)InitialCodeCacheSize, rs.size());
 417   size_initial = align_up(size_initial, os::vm_page_size());
 418   if (!heap-&gt;reserve(rs, size_initial, CodeCacheSegmentSize)) {
 419     vm_exit_during_initialization(err_msg(&quot;Could not reserve enough space in %s (&quot; SIZE_FORMAT &quot;K)&quot;,
 420                                           heap-&gt;name(), size_initial/K));
 421   }
 422 
 423   // Register the CodeHeap
 424   MemoryService::add_code_heap_memory_pool(heap, name);
 425 }
 426 
 427 CodeHeap* CodeCache::get_code_heap_containing(void* start) {
 428   FOR_ALL_HEAPS(heap) {
 429     if ((*heap)-&gt;contains(start)) {
 430       return *heap;
 431     }
 432   }
 433   return NULL;
 434 }
 435 
 436 CodeHeap* CodeCache::get_code_heap(const CodeBlob* cb) {
 437   assert(cb != NULL, &quot;CodeBlob is null&quot;);
 438   FOR_ALL_HEAPS(heap) {
 439     if ((*heap)-&gt;contains_blob(cb)) {
 440       return *heap;
 441     }
 442   }
 443   ShouldNotReachHere();
 444   return NULL;
 445 }
 446 
 447 CodeHeap* CodeCache::get_code_heap(int code_blob_type) {
 448   FOR_ALL_HEAPS(heap) {
 449     if ((*heap)-&gt;accepts(code_blob_type)) {
 450       return *heap;
 451     }
 452   }
 453   return NULL;
 454 }
 455 
 456 CodeBlob* CodeCache::first_blob(CodeHeap* heap) {
 457   assert_locked_or_safepoint(CodeCache_lock);
 458   assert(heap != NULL, &quot;heap is null&quot;);
 459   return (CodeBlob*)heap-&gt;first();
 460 }
 461 
 462 CodeBlob* CodeCache::first_blob(int code_blob_type) {
 463   if (heap_available(code_blob_type)) {
 464     return first_blob(get_code_heap(code_blob_type));
 465   } else {
 466     return NULL;
 467   }
 468 }
 469 
 470 CodeBlob* CodeCache::next_blob(CodeHeap* heap, CodeBlob* cb) {
 471   assert_locked_or_safepoint(CodeCache_lock);
 472   assert(heap != NULL, &quot;heap is null&quot;);
 473   return (CodeBlob*)heap-&gt;next(cb);
 474 }
 475 
 476 /**
 477  * Do not seize the CodeCache lock here--if the caller has not
 478  * already done so, we are going to lose bigtime, since the code
 479  * cache will contain a garbage CodeBlob until the caller can
 480  * run the constructor for the CodeBlob subclass he is busy
 481  * instantiating.
 482  */
 483 CodeBlob* CodeCache::allocate(int size, int code_blob_type, int orig_code_blob_type) {
 484   // Possibly wakes up the sweeper thread.
 485   NMethodSweeper::notify(code_blob_type);
 486   assert_locked_or_safepoint(CodeCache_lock);
 487   assert(size &gt; 0, &quot;Code cache allocation request must be &gt; 0 but is %d&quot;, size);
 488   if (size &lt;= 0) {
 489     return NULL;
 490   }
 491   CodeBlob* cb = NULL;
 492 
 493   // Get CodeHeap for the given CodeBlobType
 494   CodeHeap* heap = get_code_heap(code_blob_type);
 495   assert(heap != NULL, &quot;heap is null&quot;);
 496 
 497   while (true) {
 498     cb = (CodeBlob*)heap-&gt;allocate(size);
 499     if (cb != NULL) break;
 500     if (!heap-&gt;expand_by(CodeCacheExpansionSize)) {
 501       // Save original type for error reporting
 502       if (orig_code_blob_type == CodeBlobType::All) {
 503         orig_code_blob_type = code_blob_type;
 504       }
 505       // Expansion failed
 506       if (SegmentedCodeCache) {
 507         // Fallback solution: Try to store code in another code heap.
 508         // NonNMethod -&gt; MethodNonProfiled -&gt; MethodProfiled (-&gt; MethodNonProfiled)
 509         // Note that in the sweeper, we check the reverse_free_ratio of the code heap
 510         // and force stack scanning if less than 10% of the code heap are free.
 511         int type = code_blob_type;
 512         switch (type) {
 513         case CodeBlobType::NonNMethod:
 514           type = CodeBlobType::MethodNonProfiled;
 515           break;
 516         case CodeBlobType::MethodNonProfiled:
 517           type = CodeBlobType::MethodProfiled;
 518           break;
 519         case CodeBlobType::MethodProfiled:
 520           // Avoid loop if we already tried that code heap
 521           if (type == orig_code_blob_type) {
 522             type = CodeBlobType::MethodNonProfiled;
 523           }
 524           break;
 525         }
 526         if (type != code_blob_type &amp;&amp; type != orig_code_blob_type &amp;&amp; heap_available(type)) {
 527           if (PrintCodeCacheExtension) {
 528             tty-&gt;print_cr(&quot;Extension of %s failed. Trying to allocate in %s.&quot;,
 529                           heap-&gt;name(), get_code_heap(type)-&gt;name());
 530           }
 531           return allocate(size, type, orig_code_blob_type);
 532         }
 533       }
 534       MutexUnlockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
 535       CompileBroker::handle_full_code_cache(orig_code_blob_type);
 536       return NULL;
 537     }
 538     if (PrintCodeCacheExtension) {
 539       ResourceMark rm;
 540       if (_nmethod_heaps-&gt;length() &gt;= 1) {
 541         tty-&gt;print(&quot;%s&quot;, heap-&gt;name());
 542       } else {
 543         tty-&gt;print(&quot;CodeCache&quot;);
 544       }
 545       tty-&gt;print_cr(&quot; extended to [&quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;] (&quot; SSIZE_FORMAT &quot; bytes)&quot;,
 546                     (intptr_t)heap-&gt;low_boundary(), (intptr_t)heap-&gt;high(),
 547                     (address)heap-&gt;high() - (address)heap-&gt;low_boundary());
 548     }
 549   }
 550   print_trace(&quot;allocation&quot;, cb, size);
 551   return cb;
 552 }
 553 
 554 void CodeCache::free(CodeBlob* cb) {
 555   assert_locked_or_safepoint(CodeCache_lock);
 556   CodeHeap* heap = get_code_heap(cb);
 557   print_trace(&quot;free&quot;, cb);
 558   if (cb-&gt;is_nmethod()) {
 559     heap-&gt;set_nmethod_count(heap-&gt;nmethod_count() - 1);
 560     if (((nmethod *)cb)-&gt;has_dependencies()) {
 561       _number_of_nmethods_with_dependencies--;
 562     }
 563   }
 564   if (cb-&gt;is_adapter_blob()) {
 565     heap-&gt;set_adapter_count(heap-&gt;adapter_count() - 1);
 566   }
 567 
 568   // Get heap for given CodeBlob and deallocate
 569   get_code_heap(cb)-&gt;deallocate(cb);
 570 
 571   assert(heap-&gt;blob_count() &gt;= 0, &quot;sanity check&quot;);
 572 }
 573 
 574 void CodeCache::free_unused_tail(CodeBlob* cb, size_t used) {
 575   assert_locked_or_safepoint(CodeCache_lock);
 576   guarantee(cb-&gt;is_buffer_blob() &amp;&amp; strncmp(&quot;Interpreter&quot;, cb-&gt;name(), 11) == 0, &quot;Only possible for interpreter!&quot;);
 577   print_trace(&quot;free_unused_tail&quot;, cb);
 578 
 579   // We also have to account for the extra space (i.e. header) used by the CodeBlob
 580   // which provides the memory (see BufferBlob::create() in codeBlob.cpp).
 581   used += CodeBlob::align_code_offset(cb-&gt;header_size());
 582 
 583   // Get heap for given CodeBlob and deallocate its unused tail
 584   get_code_heap(cb)-&gt;deallocate_tail(cb, used);
 585   // Adjust the sizes of the CodeBlob
 586   cb-&gt;adjust_size(used);
 587 }
 588 
 589 void CodeCache::commit(CodeBlob* cb) {
 590   // this is called by nmethod::nmethod, which must already own CodeCache_lock
 591   assert_locked_or_safepoint(CodeCache_lock);
 592   CodeHeap* heap = get_code_heap(cb);
 593   if (cb-&gt;is_nmethod()) {
 594     heap-&gt;set_nmethod_count(heap-&gt;nmethod_count() + 1);
 595     if (((nmethod *)cb)-&gt;has_dependencies()) {
 596       _number_of_nmethods_with_dependencies++;
 597     }
 598   }
 599   if (cb-&gt;is_adapter_blob()) {
 600     heap-&gt;set_adapter_count(heap-&gt;adapter_count() + 1);
 601   }
 602 
 603   // flush the hardware I-cache
 604   ICache::invalidate_range(cb-&gt;content_begin(), cb-&gt;content_size());
 605 }
 606 
 607 bool CodeCache::contains(void *p) {
 608   // S390 uses contains() in current_frame(), which is used before
 609   // code cache initialization if NativeMemoryTracking=detail is set.
 610   S390_ONLY(if (_heaps == NULL) return false;)
 611   // It should be ok to call contains without holding a lock.
 612   FOR_ALL_HEAPS(heap) {
 613     if ((*heap)-&gt;contains(p)) {
 614       return true;
 615     }
 616   }
 617   return false;
 618 }
 619 
 620 bool CodeCache::contains(nmethod *nm) {
 621   return contains((void *)nm);
 622 }
 623 
 624 // This method is safe to call without holding the CodeCache_lock, as long as a dead CodeBlob is not
 625 // looked up (i.e., one that has been marked for deletion). It only depends on the _segmap to contain
 626 // valid indices, which it will always do, as long as the CodeBlob is not in the process of being recycled.
 627 CodeBlob* CodeCache::find_blob(void* start) {
 628   CodeBlob* result = find_blob_unsafe(start);
 629   // We could potentially look up non_entrant methods
 630   guarantee(result == NULL || !result-&gt;is_zombie() || result-&gt;is_locked_by_vm() || VMError::is_error_reported(), &quot;unsafe access to zombie method&quot;);
 631   return result;
 632 }
 633 
 634 // Lookup that does not fail if you lookup a zombie method (if you call this, be sure to know
 635 // what you are doing)
 636 CodeBlob* CodeCache::find_blob_unsafe(void* start) {
 637   // NMT can walk the stack before code cache is created
 638   if (_heaps != NULL) {
 639     CodeHeap* heap = get_code_heap_containing(start);
 640     if (heap != NULL) {
 641       return heap-&gt;find_blob_unsafe(start);
 642     }
 643   }
 644   return NULL;
 645 }
 646 
 647 nmethod* CodeCache::find_nmethod(void* start) {
 648   CodeBlob* cb = find_blob(start);
 649   assert(cb-&gt;is_nmethod(), &quot;did not find an nmethod&quot;);
 650   return (nmethod*)cb;
 651 }
 652 
 653 void CodeCache::blobs_do(void f(CodeBlob* nm)) {
 654   assert_locked_or_safepoint(CodeCache_lock);
 655   FOR_ALL_HEAPS(heap) {
 656     FOR_ALL_BLOBS(cb, *heap) {
 657       f(cb);
 658     }
 659   }
 660 }
 661 
 662 void CodeCache::nmethods_do(void f(nmethod* nm)) {
 663   assert_locked_or_safepoint(CodeCache_lock);
 664   NMethodIterator iter(NMethodIterator::all_blobs);
 665   while(iter.next()) {
 666     f(iter.method());
 667   }
 668 }
 669 
 670 void CodeCache::metadata_do(void f(Metadata* m)) {
 671   assert_locked_or_safepoint(CodeCache_lock);
 672   NMethodIterator iter(NMethodIterator::only_alive_and_not_unloading);
 673   while(iter.next()) {
 674     iter.method()-&gt;metadata_do(f);
 675   }
 676   AOTLoader::metadata_do(f);
 677 }
 678 
 679 int CodeCache::alignment_unit() {
 680   return (int)_heaps-&gt;first()-&gt;alignment_unit();
 681 }
 682 
 683 int CodeCache::alignment_offset() {
 684   return (int)_heaps-&gt;first()-&gt;alignment_offset();
 685 }
 686 
 687 // Mark nmethods for unloading if they contain otherwise unreachable oops.
 688 void CodeCache::do_unloading(BoolObjectClosure* is_alive, bool unloading_occurred) {
 689   assert_locked_or_safepoint(CodeCache_lock);
 690   UnloadingScope scope(is_alive);
 691   CompiledMethodIterator iter(CompiledMethodIterator::only_alive);
 692   while(iter.next()) {
 693     iter.method()-&gt;do_unloading(unloading_occurred);
 694   }
 695 }
 696 
 697 void CodeCache::blobs_do(CodeBlobClosure* f) {
 698   assert_locked_or_safepoint(CodeCache_lock);
 699   FOR_ALL_ALLOCABLE_HEAPS(heap) {
 700     FOR_ALL_BLOBS(cb, *heap) {
 701       if (cb-&gt;is_alive()) {
 702         f-&gt;do_code_blob(cb);
 703 #ifdef ASSERT
 704         if (cb-&gt;is_nmethod()) {
 705           Universe::heap()-&gt;verify_nmethod((nmethod*)cb);
 706         }
 707 #endif //ASSERT
 708       }
 709     }
 710   }
 711 }
 712 
 713 void CodeCache::verify_clean_inline_caches() {
 714 #ifdef ASSERT
 715   NMethodIterator iter(NMethodIterator::only_alive_and_not_unloading);
 716   while(iter.next()) {
 717     nmethod* nm = iter.method();
 718     assert(!nm-&gt;is_unloaded(), &quot;Tautology&quot;);
 719     nm-&gt;verify_clean_inline_caches();
 720     nm-&gt;verify();
 721   }
 722 #endif
 723 }
 724 
 725 void CodeCache::verify_icholder_relocations() {
 726 #ifdef ASSERT
 727   // make sure that we aren&#39;t leaking icholders
 728   int count = 0;
 729   FOR_ALL_HEAPS(heap) {
 730     FOR_ALL_BLOBS(cb, *heap) {
 731       CompiledMethod *nm = cb-&gt;as_compiled_method_or_null();
 732       if (nm != NULL) {
 733         count += nm-&gt;verify_icholder_relocations();
 734       }
 735     }
 736   }
 737   assert(count + InlineCacheBuffer::pending_icholder_count() + CompiledICHolder::live_not_claimed_count() ==
 738          CompiledICHolder::live_count(), &quot;must agree&quot;);
 739 #endif
 740 }
 741 
 742 // Defer freeing of concurrently cleaned ExceptionCache entries until
 743 // after a global handshake operation.
 744 void CodeCache::release_exception_cache(ExceptionCache* entry) {
 745   if (SafepointSynchronize::is_at_safepoint()) {
 746     delete entry;
 747   } else {
 748     for (;;) {
 749       ExceptionCache* purge_list_head = Atomic::load(&amp;_exception_cache_purge_list);
 750       entry-&gt;set_purge_list_next(purge_list_head);
 751       if (Atomic::cmpxchg(entry, &amp;_exception_cache_purge_list, purge_list_head) == purge_list_head) {
 752         break;
 753       }
 754     }
 755   }
 756 }
 757 
 758 // Delete exception caches that have been concurrently unlinked,
 759 // followed by a global handshake operation.
 760 void CodeCache::purge_exception_caches() {
 761   ExceptionCache* curr = _exception_cache_purge_list;
 762   while (curr != NULL) {
 763     ExceptionCache* next = curr-&gt;purge_list_next();
 764     delete curr;
 765     curr = next;
 766   }
 767   _exception_cache_purge_list = NULL;
 768 }
 769 
 770 uint8_t CodeCache::_unloading_cycle = 1;
 771 
 772 void CodeCache::increment_unloading_cycle() {
 773   if (_unloading_cycle == 1) {
 774     _unloading_cycle = 2;
 775   } else {
 776     _unloading_cycle = 1;
 777   }
 778 }
 779 
 780 CodeCache::UnloadingScope::UnloadingScope(BoolObjectClosure* is_alive)
 781   : _is_unloading_behaviour(is_alive)
 782 {
 783   IsUnloadingBehaviour::set_current(&amp;_is_unloading_behaviour);
 784   increment_unloading_cycle();
 785   DependencyContext::cleaning_start();
 786 }
 787 
 788 CodeCache::UnloadingScope::~UnloadingScope() {
 789   IsUnloadingBehaviour::set_current(NULL);
 790   DependencyContext::cleaning_end();
 791 }
 792 
 793 void CodeCache::verify_oops() {
 794   MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
 795   VerifyOopClosure voc;
 796   NMethodIterator iter(NMethodIterator::only_alive_and_not_unloading);
 797   while(iter.next()) {
 798     nmethod* nm = iter.method();
 799     nm-&gt;oops_do(&amp;voc);
 800     nm-&gt;verify_oop_relocations();
 801   }
 802 }
 803 
 804 int CodeCache::blob_count(int code_blob_type) {
 805   CodeHeap* heap = get_code_heap(code_blob_type);
 806   return (heap != NULL) ? heap-&gt;blob_count() : 0;
 807 }
 808 
 809 int CodeCache::blob_count() {
 810   int count = 0;
 811   FOR_ALL_HEAPS(heap) {
 812     count += (*heap)-&gt;blob_count();
 813   }
 814   return count;
 815 }
 816 
 817 int CodeCache::nmethod_count(int code_blob_type) {
 818   CodeHeap* heap = get_code_heap(code_blob_type);
 819   return (heap != NULL) ? heap-&gt;nmethod_count() : 0;
 820 }
 821 
 822 int CodeCache::nmethod_count() {
 823   int count = 0;
 824   FOR_ALL_NMETHOD_HEAPS(heap) {
 825     count += (*heap)-&gt;nmethod_count();
 826   }
 827   return count;
 828 }
 829 
 830 int CodeCache::adapter_count(int code_blob_type) {
 831   CodeHeap* heap = get_code_heap(code_blob_type);
 832   return (heap != NULL) ? heap-&gt;adapter_count() : 0;
 833 }
 834 
 835 int CodeCache::adapter_count() {
 836   int count = 0;
 837   FOR_ALL_HEAPS(heap) {
 838     count += (*heap)-&gt;adapter_count();
 839   }
 840   return count;
 841 }
 842 
 843 address CodeCache::low_bound(int code_blob_type) {
 844   CodeHeap* heap = get_code_heap(code_blob_type);
 845   return (heap != NULL) ? (address)heap-&gt;low_boundary() : NULL;
 846 }
 847 
 848 address CodeCache::high_bound(int code_blob_type) {
 849   CodeHeap* heap = get_code_heap(code_blob_type);
 850   return (heap != NULL) ? (address)heap-&gt;high_boundary() : NULL;
 851 }
 852 
 853 size_t CodeCache::capacity() {
 854   size_t cap = 0;
 855   FOR_ALL_ALLOCABLE_HEAPS(heap) {
 856     cap += (*heap)-&gt;capacity();
 857   }
 858   return cap;
 859 }
 860 
 861 size_t CodeCache::unallocated_capacity(int code_blob_type) {
 862   CodeHeap* heap = get_code_heap(code_blob_type);
 863   return (heap != NULL) ? heap-&gt;unallocated_capacity() : 0;
 864 }
 865 
 866 size_t CodeCache::unallocated_capacity() {
 867   size_t unallocated_cap = 0;
 868   FOR_ALL_ALLOCABLE_HEAPS(heap) {
 869     unallocated_cap += (*heap)-&gt;unallocated_capacity();
 870   }
 871   return unallocated_cap;
 872 }
 873 
 874 size_t CodeCache::max_capacity() {
 875   size_t max_cap = 0;
 876   FOR_ALL_ALLOCABLE_HEAPS(heap) {
 877     max_cap += (*heap)-&gt;max_capacity();
 878   }
 879   return max_cap;
 880 }
 881 
 882 /**
 883  * Returns the reverse free ratio. E.g., if 25% (1/4) of the code heap
 884  * is free, reverse_free_ratio() returns 4.
 885  */
 886 double CodeCache::reverse_free_ratio(int code_blob_type) {
 887   CodeHeap* heap = get_code_heap(code_blob_type);
 888   if (heap == NULL) {
 889     return 0;
 890   }
 891 
 892   double unallocated_capacity = MAX2((double)heap-&gt;unallocated_capacity(), 1.0); // Avoid division by 0;
 893   double max_capacity = (double)heap-&gt;max_capacity();
 894   double result = max_capacity / unallocated_capacity;
 895   assert (max_capacity &gt;= unallocated_capacity, &quot;Must be&quot;);
 896   assert (result &gt;= 1.0, &quot;reverse_free_ratio must be at least 1. It is %f&quot;, result);
 897   return result;
 898 }
 899 
 900 size_t CodeCache::bytes_allocated_in_freelists() {
 901   size_t allocated_bytes = 0;
 902   FOR_ALL_ALLOCABLE_HEAPS(heap) {
 903     allocated_bytes += (*heap)-&gt;allocated_in_freelist();
 904   }
 905   return allocated_bytes;
 906 }
 907 
 908 int CodeCache::allocated_segments() {
 909   int number_of_segments = 0;
 910   FOR_ALL_ALLOCABLE_HEAPS(heap) {
 911     number_of_segments += (*heap)-&gt;allocated_segments();
 912   }
 913   return number_of_segments;
 914 }
 915 
 916 size_t CodeCache::freelists_length() {
 917   size_t length = 0;
 918   FOR_ALL_ALLOCABLE_HEAPS(heap) {
 919     length += (*heap)-&gt;freelist_length();
 920   }
 921   return length;
 922 }
 923 
 924 void icache_init();
 925 
 926 void CodeCache::initialize() {
 927   assert(CodeCacheSegmentSize &gt;= (uintx)CodeEntryAlignment, &quot;CodeCacheSegmentSize must be large enough to align entry points&quot;);
 928 #ifdef COMPILER2
 929   assert(CodeCacheSegmentSize &gt;= (uintx)OptoLoopAlignment,  &quot;CodeCacheSegmentSize must be large enough to align inner loops&quot;);
 930 #endif
 931   assert(CodeCacheSegmentSize &gt;= sizeof(jdouble),    &quot;CodeCacheSegmentSize must be large enough to align constants&quot;);
 932   // This was originally just a check of the alignment, causing failure, instead, round
 933   // the code cache to the page size.  In particular, Solaris is moving to a larger
 934   // default page size.
 935   CodeCacheExpansionSize = align_up(CodeCacheExpansionSize, os::vm_page_size());
 936 
 937   if (SegmentedCodeCache) {
 938     // Use multiple code heaps
 939     initialize_heaps();
 940   } else {
 941     // Use a single code heap
 942     FLAG_SET_ERGO(uintx, NonNMethodCodeHeapSize, 0);
 943     FLAG_SET_ERGO(uintx, ProfiledCodeHeapSize, 0);
 944     FLAG_SET_ERGO(uintx, NonProfiledCodeHeapSize, 0);
 945     ReservedCodeSpace rs = reserve_heap_memory(ReservedCodeCacheSize);
 946     add_heap(rs, &quot;CodeCache&quot;, CodeBlobType::All);
 947   }
 948 
 949   // Initialize ICache flush mechanism
 950   // This service is needed for os::register_code_area
 951   icache_init();
 952 
 953   // Give OS a chance to register generated code area.
 954   // This is used on Windows 64 bit platforms to register
 955   // Structured Exception Handlers for our generated code.
 956   os::register_code_area((char*)low_bound(), (char*)high_bound());
 957 }
 958 
 959 void codeCache_init() {
 960   CodeCache::initialize();
 961   // Load AOT libraries and add AOT code heaps.
 962   AOTLoader::initialize();
 963 }
 964 
 965 //------------------------------------------------------------------------------------------------
 966 
 967 int CodeCache::number_of_nmethods_with_dependencies() {
 968   return _number_of_nmethods_with_dependencies;
 969 }
 970 
 971 void CodeCache::clear_inline_caches() {
 972   assert_locked_or_safepoint(CodeCache_lock);
 973   CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);
 974   while(iter.next()) {
 975     iter.method()-&gt;clear_inline_caches();
 976   }
 977 }
 978 
 979 void CodeCache::cleanup_inline_caches() {
 980   assert_locked_or_safepoint(CodeCache_lock);
 981   NMethodIterator iter(NMethodIterator::only_alive_and_not_unloading);
 982   while(iter.next()) {
 983     iter.method()-&gt;cleanup_inline_caches(/*clean_all=*/true);
 984   }
 985 }
 986 
 987 // Keeps track of time spent for checking dependencies
 988 NOT_PRODUCT(static elapsedTimer dependentCheckTime;)
 989 
 990 int CodeCache::mark_for_deoptimization(KlassDepChange&amp; changes) {
 991   MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
 992   int number_of_marked_CodeBlobs = 0;
 993 
 994   // search the hierarchy looking for nmethods which are affected by the loading of this class
 995 
 996   // then search the interfaces this class implements looking for nmethods
 997   // which might be dependent of the fact that an interface only had one
 998   // implementor.
 999   // nmethod::check_all_dependencies works only correctly, if no safepoint
1000   // can happen
1001   NoSafepointVerifier nsv;
1002   for (DepChange::ContextStream str(changes, nsv); str.next(); ) {
1003     Klass* d = str.klass();
1004     number_of_marked_CodeBlobs += InstanceKlass::cast(d)-&gt;mark_dependent_nmethods(changes);
1005   }
1006 
1007 #ifndef PRODUCT
1008   if (VerifyDependencies) {
1009     // Object pointers are used as unique identifiers for dependency arguments. This
1010     // is only possible if no safepoint, i.e., GC occurs during the verification code.
1011     dependentCheckTime.start();
1012     nmethod::check_all_dependencies(changes);
1013     dependentCheckTime.stop();
1014   }
1015 #endif
1016 
1017   return number_of_marked_CodeBlobs;
1018 }
1019 
1020 CompiledMethod* CodeCache::find_compiled(void* start) {
1021   CodeBlob *cb = find_blob(start);
1022   assert(cb == NULL || cb-&gt;is_compiled(), &quot;did not find an compiled_method&quot;);
1023   return (CompiledMethod*)cb;
1024 }
1025 
1026 bool CodeCache::is_far_target(address target) {
1027 #if INCLUDE_AOT
1028   return NativeCall::is_far_call(_low_bound,  target) ||
1029          NativeCall::is_far_call(_high_bound, target);
1030 #else
1031   return false;
1032 #endif
1033 }
1034 
1035 // Just marks the methods in this class as needing deoptimization
1036 void CodeCache::mark_for_evol_deoptimization(InstanceKlass* dependee) {
1037   MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1038 
1039   // Deoptimize all methods of the evolving class itself
1040   Array&lt;Method*&gt;* old_methods = dependee-&gt;methods();
1041   for (int i = 0; i &lt; old_methods-&gt;length(); i++) {
1042     ResourceMark rm;
1043     Method* old_method = old_methods-&gt;at(i);
1044     CompiledMethod* nm = old_method-&gt;code();
1045     if (nm != NULL) {
1046       nm-&gt;mark_for_deoptimization();
1047     }
1048   }
1049 
1050   // Mark dependent AOT nmethods, which are only found via the class redefined.
1051   AOTLoader::mark_evol_dependent_methods(dependee);
1052 }
1053 
1054 // Walk compiled methods and mark dependent methods for deoptimization.
1055 int CodeCache::mark_dependents_for_evol_deoptimization() {
1056   int number_of_marked_CodeBlobs = 0;
1057   CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);
1058   while(iter.next()) {
1059     CompiledMethod* nm = iter.method();
1060     if (nm-&gt;is_marked_for_deoptimization()) {
1061       // ...Already marked in the previous pass; count it here.
1062       // Also counts AOT compiled methods, already marked.
1063       number_of_marked_CodeBlobs++;
1064     } else if (nm-&gt;is_evol_dependent()) {
1065       ResourceMark rm;
1066       nm-&gt;mark_for_deoptimization();
1067       number_of_marked_CodeBlobs++;
1068     } else  {
1069       // flush caches in case they refer to a redefined Method*
1070       nm-&gt;clear_inline_caches();
1071     }
1072   }
1073 
1074   // return total count of nmethods marked for deoptimization, if zero the caller
1075   // can skip deoptimization
1076   return number_of_marked_CodeBlobs;
1077 }
1078 
1079 // Deoptimize all methods
1080 void CodeCache::mark_all_nmethods_for_deoptimization() {
1081   MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1082   CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);
1083   while(iter.next()) {
1084     CompiledMethod* nm = iter.method();
1085     if (!nm-&gt;method()-&gt;is_method_handle_intrinsic()) {
1086       nm-&gt;mark_for_deoptimization();
1087     }
1088   }
1089 }
1090 
1091 int CodeCache::mark_for_deoptimization(Method* dependee) {
1092   MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1093   int number_of_marked_CodeBlobs = 0;
1094 
1095   CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);
1096   while(iter.next()) {
1097     CompiledMethod* nm = iter.method();
1098     if (nm-&gt;is_dependent_on_method(dependee)) {
1099       ResourceMark rm;
1100       nm-&gt;mark_for_deoptimization();
1101       number_of_marked_CodeBlobs++;
1102     }
1103   }
1104 
1105   return number_of_marked_CodeBlobs;
1106 }
1107 
1108 void CodeCache::make_marked_nmethods_not_entrant() {
1109   assert_locked_or_safepoint(CodeCache_lock);
1110   CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);
1111   while(iter.next()) {
1112     CompiledMethod* nm = iter.method();
1113     if (nm-&gt;is_marked_for_deoptimization() &amp;&amp; !nm-&gt;is_not_entrant()) {
1114       nm-&gt;make_not_entrant();
1115     }
1116   }
1117 }
1118 
1119 // Flushes compiled methods dependent on dependee.
1120 void CodeCache::flush_dependents_on(InstanceKlass* dependee) {
1121   assert_lock_strong(Compile_lock);
1122 
1123   if (number_of_nmethods_with_dependencies() == 0) return;
1124 
1125   // CodeCache can only be updated by a thread_in_VM and they will all be
1126   // stopped during the safepoint so CodeCache will be safe to update without
1127   // holding the CodeCache_lock.
1128 
1129   KlassDepChange changes(dependee);
1130 
1131   // Compute the dependent nmethods
1132   if (mark_for_deoptimization(changes) &gt; 0) {
1133     // At least one nmethod has been marked for deoptimization
1134     VM_Deoptimize op;
1135     VMThread::execute(&amp;op);
1136   }
1137 }
1138 
1139 // Flushes compiled methods dependent on redefined classes, that have already been
1140 // marked for deoptimization.
1141 void CodeCache::flush_evol_dependents() {
1142   // --- Compile_lock is not held. However we are at a safepoint.
1143   assert_locked_or_safepoint(Compile_lock);
1144 
1145   // CodeCache can only be updated by a thread_in_VM and they will all be
1146   // stopped during the safepoint so CodeCache will be safe to update without
1147   // holding the CodeCache_lock.
1148 
1149   // At least one nmethod has been marked for deoptimization
1150 
1151   // All this already happens inside a VM_Operation, so we&#39;ll do all the work here.
1152   // Stuff copied from VM_Deoptimize and modified slightly.
1153 
1154   // We do not want any GCs to happen while we are in the middle of this VM operation
1155   ResourceMark rm;
1156   DeoptimizationMarker dm;
1157 
1158   // Deoptimize all activations depending on marked nmethods
1159   Deoptimization::deoptimize_dependents();
1160 
1161   // Make the dependent methods not entrant
1162   make_marked_nmethods_not_entrant();
1163 }
1164 
1165 // Flushes compiled methods dependent on dependee
1166 void CodeCache::flush_dependents_on_method(const methodHandle&amp; m_h) {
1167   // --- Compile_lock is not held. However we are at a safepoint.
1168   assert_locked_or_safepoint(Compile_lock);
1169 
1170   // CodeCache can only be updated by a thread_in_VM and they will all be
1171   // stopped dring the safepoint so CodeCache will be safe to update without
1172   // holding the CodeCache_lock.
1173 
1174   // Compute the dependent nmethods
1175   if (mark_for_deoptimization(m_h()) &gt; 0) {
1176     // At least one nmethod has been marked for deoptimization
1177 
1178     // All this already happens inside a VM_Operation, so we&#39;ll do all the work here.
1179     // Stuff copied from VM_Deoptimize and modified slightly.
1180 
1181     // We do not want any GCs to happen while we are in the middle of this VM operation
1182     ResourceMark rm;
1183     DeoptimizationMarker dm;
1184 
1185     // Deoptimize all activations depending on marked nmethods
1186     Deoptimization::deoptimize_dependents();
1187 
1188     // Make the dependent methods not entrant
1189     make_marked_nmethods_not_entrant();
1190   }
1191 }
1192 
1193 void CodeCache::verify() {
1194   assert_locked_or_safepoint(CodeCache_lock);
1195   FOR_ALL_HEAPS(heap) {
1196     (*heap)-&gt;verify();
1197     FOR_ALL_BLOBS(cb, *heap) {
1198       if (cb-&gt;is_alive()) {
1199         cb-&gt;verify();
1200       }
1201     }
1202   }
1203 }
1204 
1205 // A CodeHeap is full. Print out warning and report event.
1206 PRAGMA_DIAG_PUSH
1207 PRAGMA_FORMAT_NONLITERAL_IGNORED
1208 void CodeCache::report_codemem_full(int code_blob_type, bool print) {
1209   // Get nmethod heap for the given CodeBlobType and build CodeCacheFull event
1210   CodeHeap* heap = get_code_heap(code_blob_type);
1211   assert(heap != NULL, &quot;heap is null&quot;);
1212 
1213   if ((heap-&gt;full_count() == 0) || print) {
1214     // Not yet reported for this heap, report
1215     if (SegmentedCodeCache) {
1216       ResourceMark rm;
1217       stringStream msg1_stream, msg2_stream;
1218       msg1_stream.print(&quot;%s is full. Compiler has been disabled.&quot;,
1219                         get_code_heap_name(code_blob_type));
1220       msg2_stream.print(&quot;Try increasing the code heap size using -XX:%s=&quot;,
1221                  get_code_heap_flag_name(code_blob_type));
1222       const char *msg1 = msg1_stream.as_string();
1223       const char *msg2 = msg2_stream.as_string();
1224 
1225       log_warning(codecache)(&quot;%s&quot;, msg1);
1226       log_warning(codecache)(&quot;%s&quot;, msg2);
1227       warning(&quot;%s&quot;, msg1);
1228       warning(&quot;%s&quot;, msg2);
1229     } else {
1230       const char *msg1 = &quot;CodeCache is full. Compiler has been disabled.&quot;;
1231       const char *msg2 = &quot;Try increasing the code cache size using -XX:ReservedCodeCacheSize=&quot;;
1232 
1233       log_warning(codecache)(&quot;%s&quot;, msg1);
1234       log_warning(codecache)(&quot;%s&quot;, msg2);
1235       warning(&quot;%s&quot;, msg1);
1236       warning(&quot;%s&quot;, msg2);
1237     }
1238     ResourceMark rm;
1239     stringStream s;
1240     // Dump code cache into a buffer before locking the tty.
1241     {
1242       MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1243       print_summary(&amp;s);
1244     }
1245     {
1246       ttyLocker ttyl;
1247       tty-&gt;print(&quot;%s&quot;, s.as_string());
1248     }
1249 
1250     if (heap-&gt;full_count() == 0) {
1251       if (PrintCodeHeapAnalytics) {
1252         CompileBroker::print_heapinfo(tty, &quot;all&quot;, &quot;4096&quot;); // details, may be a lot!
1253       }
1254     }
1255   }
1256 
1257   heap-&gt;report_full();
1258 
1259   EventCodeCacheFull event;
1260   if (event.should_commit()) {
1261     event.set_codeBlobType((u1)code_blob_type);
1262     event.set_startAddress((u8)heap-&gt;low_boundary());
1263     event.set_commitedTopAddress((u8)heap-&gt;high());
1264     event.set_reservedTopAddress((u8)heap-&gt;high_boundary());
1265     event.set_entryCount(heap-&gt;blob_count());
1266     event.set_methodCount(heap-&gt;nmethod_count());
1267     event.set_adaptorCount(heap-&gt;adapter_count());
1268     event.set_unallocatedCapacity(heap-&gt;unallocated_capacity());
1269     event.set_fullCount(heap-&gt;full_count());
1270     event.commit();
1271   }
1272 }
1273 PRAGMA_DIAG_POP
1274 
1275 void CodeCache::print_memory_overhead() {
1276   size_t wasted_bytes = 0;
1277   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1278       CodeHeap* curr_heap = *heap;
1279       for (CodeBlob* cb = (CodeBlob*)curr_heap-&gt;first(); cb != NULL; cb = (CodeBlob*)curr_heap-&gt;next(cb)) {
1280         HeapBlock* heap_block = ((HeapBlock*)cb) - 1;
1281         wasted_bytes += heap_block-&gt;length() * CodeCacheSegmentSize - cb-&gt;size();
1282       }
1283   }
1284   // Print bytes that are allocated in the freelist
1285   ttyLocker ttl;
1286   tty-&gt;print_cr(&quot;Number of elements in freelist: &quot; SSIZE_FORMAT,       freelists_length());
1287   tty-&gt;print_cr(&quot;Allocated in freelist:          &quot; SSIZE_FORMAT &quot;kB&quot;,  bytes_allocated_in_freelists()/K);
1288   tty-&gt;print_cr(&quot;Unused bytes in CodeBlobs:      &quot; SSIZE_FORMAT &quot;kB&quot;,  (wasted_bytes/K));
1289   tty-&gt;print_cr(&quot;Segment map size:               &quot; SSIZE_FORMAT &quot;kB&quot;,  allocated_segments()/K); // 1 byte per segment
1290 }
1291 
1292 //------------------------------------------------------------------------------------------------
1293 // Non-product version
1294 
1295 #ifndef PRODUCT
1296 
1297 void CodeCache::print_trace(const char* event, CodeBlob* cb, int size) {
1298   if (PrintCodeCache2) {  // Need to add a new flag
1299     ResourceMark rm;
1300     if (size == 0)  size = cb-&gt;size();
1301     tty-&gt;print_cr(&quot;CodeCache %s:  addr: &quot; INTPTR_FORMAT &quot;, size: 0x%x&quot;, event, p2i(cb), size);
1302   }
1303 }
1304 
1305 void CodeCache::print_internals() {
1306   int nmethodCount = 0;
1307   int runtimeStubCount = 0;
1308   int adapterCount = 0;
1309   int deoptimizationStubCount = 0;
1310   int uncommonTrapStubCount = 0;
1311   int bufferBlobCount = 0;
1312   int total = 0;
1313   int nmethodAlive = 0;
1314   int nmethodNotEntrant = 0;
1315   int nmethodZombie = 0;
1316   int nmethodUnloaded = 0;
1317   int nmethodJava = 0;
1318   int nmethodNative = 0;
1319   int max_nm_size = 0;
1320   ResourceMark rm;
1321 
1322   int i = 0;
1323   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1324     if ((_nmethod_heaps-&gt;length() &gt;= 1) &amp;&amp; Verbose) {
1325       tty-&gt;print_cr(&quot;-- %s --&quot;, (*heap)-&gt;name());
1326     }
1327     FOR_ALL_BLOBS(cb, *heap) {
1328       total++;
1329       if (cb-&gt;is_nmethod()) {
1330         nmethod* nm = (nmethod*)cb;
1331 
1332         if (Verbose &amp;&amp; nm-&gt;method() != NULL) {
1333           ResourceMark rm;
1334           char *method_name = nm-&gt;method()-&gt;name_and_sig_as_C_string();
1335           tty-&gt;print(&quot;%s&quot;, method_name);
1336           if(nm-&gt;is_alive()) { tty-&gt;print_cr(&quot; alive&quot;); }
1337           if(nm-&gt;is_not_entrant()) { tty-&gt;print_cr(&quot; not-entrant&quot;); }
1338           if(nm-&gt;is_zombie()) { tty-&gt;print_cr(&quot; zombie&quot;); }
1339         }
1340 
1341         nmethodCount++;
1342 
1343         if(nm-&gt;is_alive()) { nmethodAlive++; }
1344         if(nm-&gt;is_not_entrant()) { nmethodNotEntrant++; }
1345         if(nm-&gt;is_zombie()) { nmethodZombie++; }
1346         if(nm-&gt;is_unloaded()) { nmethodUnloaded++; }
1347         if(nm-&gt;method() != NULL &amp;&amp; nm-&gt;is_native_method()) { nmethodNative++; }
1348 
1349         if(nm-&gt;method() != NULL &amp;&amp; nm-&gt;is_java_method()) {
1350           nmethodJava++;
1351           max_nm_size = MAX2(max_nm_size, nm-&gt;size());
1352         }
1353       } else if (cb-&gt;is_runtime_stub()) {
1354         runtimeStubCount++;
1355       } else if (cb-&gt;is_deoptimization_stub()) {
1356         deoptimizationStubCount++;
1357       } else if (cb-&gt;is_uncommon_trap_stub()) {
1358         uncommonTrapStubCount++;
1359       } else if (cb-&gt;is_adapter_blob()) {
1360         adapterCount++;
1361       } else if (cb-&gt;is_buffer_blob()) {
1362         bufferBlobCount++;
1363       }
1364     }
1365   }
1366 
1367   int bucketSize = 512;
1368   int bucketLimit = max_nm_size / bucketSize + 1;
1369   int *buckets = NEW_C_HEAP_ARRAY(int, bucketLimit, mtCode);
1370   memset(buckets, 0, sizeof(int) * bucketLimit);
1371 
1372   NMethodIterator iter(NMethodIterator::all_blobs);
1373   while(iter.next()) {
1374     nmethod* nm = iter.method();
1375     if(nm-&gt;method() != NULL &amp;&amp; nm-&gt;is_java_method()) {
1376       buckets[nm-&gt;size() / bucketSize]++;
1377     }
1378   }
1379 
1380   tty-&gt;print_cr(&quot;Code Cache Entries (total of %d)&quot;,total);
1381   tty-&gt;print_cr(&quot;-------------------------------------------------&quot;);
1382   tty-&gt;print_cr(&quot;nmethods: %d&quot;,nmethodCount);
1383   tty-&gt;print_cr(&quot;\talive: %d&quot;,nmethodAlive);
1384   tty-&gt;print_cr(&quot;\tnot_entrant: %d&quot;,nmethodNotEntrant);
1385   tty-&gt;print_cr(&quot;\tzombie: %d&quot;,nmethodZombie);
1386   tty-&gt;print_cr(&quot;\tunloaded: %d&quot;,nmethodUnloaded);
1387   tty-&gt;print_cr(&quot;\tjava: %d&quot;,nmethodJava);
1388   tty-&gt;print_cr(&quot;\tnative: %d&quot;,nmethodNative);
1389   tty-&gt;print_cr(&quot;runtime_stubs: %d&quot;,runtimeStubCount);
1390   tty-&gt;print_cr(&quot;adapters: %d&quot;,adapterCount);
1391   tty-&gt;print_cr(&quot;buffer blobs: %d&quot;,bufferBlobCount);
1392   tty-&gt;print_cr(&quot;deoptimization_stubs: %d&quot;,deoptimizationStubCount);
1393   tty-&gt;print_cr(&quot;uncommon_traps: %d&quot;,uncommonTrapStubCount);
1394   tty-&gt;print_cr(&quot;\nnmethod size distribution (non-zombie java)&quot;);
1395   tty-&gt;print_cr(&quot;-------------------------------------------------&quot;);
1396 
1397   for(int i=0; i&lt;bucketLimit; i++) {
1398     if(buckets[i] != 0) {
1399       tty-&gt;print(&quot;%d - %d bytes&quot;,i*bucketSize,(i+1)*bucketSize);
1400       tty-&gt;fill_to(40);
1401       tty-&gt;print_cr(&quot;%d&quot;,buckets[i]);
1402     }
1403   }
1404 
1405   FREE_C_HEAP_ARRAY(int, buckets);
1406   print_memory_overhead();
1407 }
1408 
1409 #endif // !PRODUCT
1410 
1411 void CodeCache::print() {
1412   print_summary(tty);
1413 
1414 #ifndef PRODUCT
1415   if (!Verbose) return;
1416 
1417   CodeBlob_sizes live;
1418   CodeBlob_sizes dead;
1419 
1420   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1421     FOR_ALL_BLOBS(cb, *heap) {
1422       if (!cb-&gt;is_alive()) {
1423         dead.add(cb);
1424       } else {
1425         live.add(cb);
1426       }
1427     }
1428   }
1429 
1430   tty-&gt;print_cr(&quot;CodeCache:&quot;);
1431   tty-&gt;print_cr(&quot;nmethod dependency checking time %fs&quot;, dependentCheckTime.seconds());
1432 
1433   if (!live.is_empty()) {
1434     live.print(&quot;live&quot;);
1435   }
1436   if (!dead.is_empty()) {
1437     dead.print(&quot;dead&quot;);
1438   }
1439 
1440   if (WizardMode) {
1441      // print the oop_map usage
1442     int code_size = 0;
1443     int number_of_blobs = 0;
1444     int number_of_oop_maps = 0;
1445     int map_size = 0;
1446     FOR_ALL_ALLOCABLE_HEAPS(heap) {
1447       FOR_ALL_BLOBS(cb, *heap) {
1448         if (cb-&gt;is_alive()) {
1449           number_of_blobs++;
1450           code_size += cb-&gt;code_size();
1451           ImmutableOopMapSet* set = cb-&gt;oop_maps();
1452           if (set != NULL) {
1453             number_of_oop_maps += set-&gt;count();
1454             map_size           += set-&gt;nr_of_bytes();
1455           }
1456         }
1457       }
1458     }
1459     tty-&gt;print_cr(&quot;OopMaps&quot;);
1460     tty-&gt;print_cr(&quot;  #blobs    = %d&quot;, number_of_blobs);
1461     tty-&gt;print_cr(&quot;  code size = %d&quot;, code_size);
1462     tty-&gt;print_cr(&quot;  #oop_maps = %d&quot;, number_of_oop_maps);
1463     tty-&gt;print_cr(&quot;  map size  = %d&quot;, map_size);
1464   }
1465 
1466 #endif // !PRODUCT
1467 }
1468 
1469 void CodeCache::print_summary(outputStream* st, bool detailed) {
1470   int full_count = 0;
1471   FOR_ALL_HEAPS(heap_iterator) {
1472     CodeHeap* heap = (*heap_iterator);
1473     size_t total = (heap-&gt;high_boundary() - heap-&gt;low_boundary());
1474     if (_heaps-&gt;length() &gt;= 1) {
1475       st-&gt;print(&quot;%s:&quot;, heap-&gt;name());
1476     } else {
1477       st-&gt;print(&quot;CodeCache:&quot;);
1478     }
1479     st-&gt;print_cr(&quot; size=&quot; SIZE_FORMAT &quot;Kb used=&quot; SIZE_FORMAT
1480                  &quot;Kb max_used=&quot; SIZE_FORMAT &quot;Kb free=&quot; SIZE_FORMAT &quot;Kb&quot;,
1481                  total/K, (total - heap-&gt;unallocated_capacity())/K,
1482                  heap-&gt;max_allocated_capacity()/K, heap-&gt;unallocated_capacity()/K);
1483 
1484     if (detailed) {
1485       st-&gt;print_cr(&quot; bounds [&quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;]&quot;,
1486                    p2i(heap-&gt;low_boundary()),
1487                    p2i(heap-&gt;high()),
1488                    p2i(heap-&gt;high_boundary()));
1489 
1490       full_count += get_codemem_full_count(heap-&gt;code_blob_type());
1491     }
1492   }
1493 
1494   if (detailed) {
1495     st-&gt;print_cr(&quot; total_blobs=&quot; UINT32_FORMAT &quot; nmethods=&quot; UINT32_FORMAT
1496                        &quot; adapters=&quot; UINT32_FORMAT,
1497                        blob_count(), nmethod_count(), adapter_count());
1498     st-&gt;print_cr(&quot; compilation: %s&quot;, CompileBroker::should_compile_new_jobs() ?
1499                  &quot;enabled&quot; : Arguments::mode() == Arguments::_int ?
1500                  &quot;disabled (interpreter mode)&quot; :
1501                  &quot;disabled (not enough contiguous free space left)&quot;);
1502     st-&gt;print_cr(&quot;              stopped_count=%d, restarted_count=%d&quot;,
1503                  CompileBroker::get_total_compiler_stopped_count(),
1504                  CompileBroker::get_total_compiler_restarted_count());
1505     st-&gt;print_cr(&quot; full_count=%d&quot;, full_count);
1506   }
1507 }
1508 
1509 void CodeCache::print_codelist(outputStream* st) {
1510   MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1511 
1512   CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);
1513   while (iter.next()) {
1514     CompiledMethod* cm = iter.method();
1515     ResourceMark rm;
1516     char* method_name = cm-&gt;method()-&gt;name_and_sig_as_C_string();
1517     st-&gt;print_cr(&quot;%d %d %d %s [&quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot;]&quot;,
1518                  cm-&gt;compile_id(), cm-&gt;comp_level(), cm-&gt;get_state(),
1519                  method_name,
1520                  (intptr_t)cm-&gt;header_begin(), (intptr_t)cm-&gt;code_begin(), (intptr_t)cm-&gt;code_end());
1521   }
1522 }
1523 
1524 void CodeCache::print_layout(outputStream* st) {
1525   MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1526   ResourceMark rm;
1527   print_summary(st, true);
1528 }
1529 
1530 void CodeCache::log_state(outputStream* st) {
1531   st-&gt;print(&quot; total_blobs=&#39;&quot; UINT32_FORMAT &quot;&#39; nmethods=&#39;&quot; UINT32_FORMAT &quot;&#39;&quot;
1532             &quot; adapters=&#39;&quot; UINT32_FORMAT &quot;&#39; free_code_cache=&#39;&quot; SIZE_FORMAT &quot;&#39;&quot;,
1533             blob_count(), nmethod_count(), adapter_count(),
1534             unallocated_capacity());
1535 }
1536 
1537 //---&lt;  BEGIN  &gt;--- CodeHeap State Analytics.
1538 
1539 void CodeCache::aggregate(outputStream *out, const char* granularity) {
1540   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1541     CodeHeapState::aggregate(out, (*heap), granularity);
1542   }
1543 }
1544 
1545 void CodeCache::discard(outputStream *out) {
1546   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1547     CodeHeapState::discard(out, (*heap));
1548   }
1549 }
1550 
1551 void CodeCache::print_usedSpace(outputStream *out) {
1552   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1553     CodeHeapState::print_usedSpace(out, (*heap));
1554   }
1555 }
1556 
1557 void CodeCache::print_freeSpace(outputStream *out) {
1558   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1559     CodeHeapState::print_freeSpace(out, (*heap));
1560   }
1561 }
1562 
1563 void CodeCache::print_count(outputStream *out) {
1564   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1565     CodeHeapState::print_count(out, (*heap));
1566   }
1567 }
1568 
1569 void CodeCache::print_space(outputStream *out) {
1570   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1571     CodeHeapState::print_space(out, (*heap));
1572   }
1573 }
1574 
1575 void CodeCache::print_age(outputStream *out) {
1576   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1577     CodeHeapState::print_age(out, (*heap));
1578   }
1579 }
1580 
1581 void CodeCache::print_names(outputStream *out) {
1582   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1583     CodeHeapState::print_names(out, (*heap));
1584   }
1585 }
1586 //---&lt;  END  &gt;--- CodeHeap State Analytics.
    </pre>
  </body>
</html>
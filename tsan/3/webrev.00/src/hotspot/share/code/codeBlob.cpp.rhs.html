<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/code/codeBlob.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
 27 #include &quot;code/codeBlob.hpp&quot;
 28 #include &quot;code/codeCache.hpp&quot;
 29 #include &quot;code/icBuffer.hpp&quot;
 30 #include &quot;code/relocInfo.hpp&quot;
 31 #include &quot;code/vtableStubs.hpp&quot;
 32 #include &quot;compiler/disassembler.hpp&quot;
 33 #include &quot;interpreter/bytecode.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added"> 34 #include &quot;interpreter/interpreter.hpp&quot;</span>
 35 #include &quot;memory/allocation.inline.hpp&quot;
 36 #include &quot;memory/heap.hpp&quot;
 37 #include &quot;memory/resourceArea.hpp&quot;
 38 #include &quot;oops/oop.inline.hpp&quot;
 39 #include &quot;prims/forte.hpp&quot;
 40 #include &quot;runtime/handles.inline.hpp&quot;
 41 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 42 #include &quot;runtime/mutexLocker.hpp&quot;
 43 #include &quot;runtime/safepoint.hpp&quot;
 44 #include &quot;runtime/sharedRuntime.hpp&quot;
 45 #include &quot;runtime/vframe.hpp&quot;
 46 #include &quot;services/memoryService.hpp&quot;
 47 #include &quot;utilities/align.hpp&quot;
 48 #ifdef COMPILER1
 49 #include &quot;c1/c1_Runtime1.hpp&quot;
 50 #endif
 51 
 52 const char* CodeBlob::compiler_name() const {
 53   return compilertype2name(_type);
 54 }
 55 
 56 unsigned int CodeBlob::align_code_offset(int offset) {
 57   // align the size to CodeEntryAlignment
 58   return
 59     ((offset + (int)CodeHeap::header_size() + (CodeEntryAlignment-1)) &amp; ~(CodeEntryAlignment-1))
 60     - (int)CodeHeap::header_size();
 61 }
 62 
 63 
 64 // This must be consistent with the CodeBlob constructor&#39;s layout actions.
 65 unsigned int CodeBlob::allocation_size(CodeBuffer* cb, int header_size) {
 66   unsigned int size = header_size;
 67   size += align_up(cb-&gt;total_relocation_size(), oopSize);
 68   // align the size to CodeEntryAlignment
 69   size = align_code_offset(size);
 70   size += align_up(cb-&gt;total_content_size(), oopSize);
 71   size += align_up(cb-&gt;total_oop_size(), oopSize);
 72   size += align_up(cb-&gt;total_metadata_size(), oopSize);
 73   return size;
 74 }
 75 
 76 CodeBlob::CodeBlob(const char* name, CompilerType type, const CodeBlobLayout&amp; layout, int frame_complete_offset, int frame_size, ImmutableOopMapSet* oop_maps, bool caller_must_gc_arguments) :
 77   _type(type),
 78   _size(layout.size()),
 79   _header_size(layout.header_size()),
 80   _frame_complete_offset(frame_complete_offset),
 81   _data_offset(layout.data_offset()),
 82   _frame_size(frame_size),
 83   _code_begin(layout.code_begin()),
 84   _code_end(layout.code_end()),
 85   _content_begin(layout.content_begin()),
 86   _data_end(layout.data_end()),
 87   _relocation_begin(layout.relocation_begin()),
 88   _relocation_end(layout.relocation_end()),
 89   _oop_maps(oop_maps),
 90   _caller_must_gc_arguments(caller_must_gc_arguments),
 91   _strings(CodeStrings()),
 92   _name(name)
 93 {
 94   assert(is_aligned(layout.size(),            oopSize), &quot;unaligned size&quot;);
 95   assert(is_aligned(layout.header_size(),     oopSize), &quot;unaligned size&quot;);
 96   assert(is_aligned(layout.relocation_size(), oopSize), &quot;unaligned size&quot;);
 97   assert(layout.code_end() == layout.content_end(), &quot;must be the same - see code_end()&quot;);
 98 #ifdef COMPILER1
 99   // probably wrong for tiered
100   assert(_frame_size &gt;= -1, &quot;must use frame size or -1 for runtime stubs&quot;);
101 #endif // COMPILER1
102 }
103 
104 CodeBlob::CodeBlob(const char* name, CompilerType type, const CodeBlobLayout&amp; layout, CodeBuffer* cb, int frame_complete_offset, int frame_size, OopMapSet* oop_maps, bool caller_must_gc_arguments) :
105   _type(type),
106   _size(layout.size()),
107   _header_size(layout.header_size()),
108   _frame_complete_offset(frame_complete_offset),
109   _data_offset(layout.data_offset()),
110   _frame_size(frame_size),
111   _code_begin(layout.code_begin()),
112   _code_end(layout.code_end()),
113   _content_begin(layout.content_begin()),
114   _data_end(layout.data_end()),
115   _relocation_begin(layout.relocation_begin()),
116   _relocation_end(layout.relocation_end()),
117   _caller_must_gc_arguments(caller_must_gc_arguments),
118   _strings(CodeStrings()),
119   _name(name)
120 {
121   assert(is_aligned(_size,        oopSize), &quot;unaligned size&quot;);
122   assert(is_aligned(_header_size, oopSize), &quot;unaligned size&quot;);
123   assert(_data_offset &lt;= _size, &quot;codeBlob is too small&quot;);
124   assert(layout.code_end() == layout.content_end(), &quot;must be the same - see code_end()&quot;);
125 
126   set_oop_maps(oop_maps);
127 #ifdef COMPILER1
128   // probably wrong for tiered
129   assert(_frame_size &gt;= -1, &quot;must use frame size or -1 for runtime stubs&quot;);
130 #endif // COMPILER1
131 }
132 
133 
134 // Creates a simple CodeBlob. Sets up the size of the different regions.
135 RuntimeBlob::RuntimeBlob(const char* name, int header_size, int size, int frame_complete, int locs_size)
136   : CodeBlob(name, compiler_none, CodeBlobLayout((address) this, size, header_size, locs_size, size), frame_complete, 0, NULL, false /* caller_must_gc_arguments */)
137 {
138   assert(is_aligned(locs_size, oopSize), &quot;unaligned size&quot;);
139 }
140 
141 
142 // Creates a RuntimeBlob from a CodeBuffer
143 // and copy code and relocation info.
144 RuntimeBlob::RuntimeBlob(
145   const char* name,
146   CodeBuffer* cb,
147   int         header_size,
148   int         size,
149   int         frame_complete,
150   int         frame_size,
151   OopMapSet*  oop_maps,
152   bool        caller_must_gc_arguments
153 ) : CodeBlob(name, compiler_none, CodeBlobLayout((address) this, size, header_size, cb), cb, frame_complete, frame_size, oop_maps, caller_must_gc_arguments) {
154   cb-&gt;copy_code_and_locs_to(this);
155 }
156 
157 void CodeBlob::flush() {
<a name="3" id="anc3"></a><span class="line-modified">158   FREE_C_HEAP_ARRAY(unsigned char, _oop_maps);</span>
<span class="line-modified">159   _oop_maps = NULL;</span>


160   _strings.free();
161 }
162 
163 void CodeBlob::set_oop_maps(OopMapSet* p) {
164   // Danger Will Robinson! This method allocates a big
165   // chunk of memory, its your job to free it.
166   if (p != NULL) {
167     _oop_maps = ImmutableOopMapSet::build_from(p);
168   } else {
169     _oop_maps = NULL;
170   }
171 }
172 
173 
174 void RuntimeBlob::trace_new_stub(RuntimeBlob* stub, const char* name1, const char* name2) {
175   // Do not hold the CodeCache lock during name formatting.
176   assert(!CodeCache_lock-&gt;owned_by_self(), &quot;release CodeCache before registering the stub&quot;);
177 
178   if (stub != NULL) {
179     char stub_id[256];
180     assert(strlen(name1) + strlen(name2) &lt; sizeof(stub_id), &quot;&quot;);
181     jio_snprintf(stub_id, sizeof(stub_id), &quot;%s%s&quot;, name1, name2);
182     if (PrintStubCode) {
183       ttyLocker ttyl;
<a name="4" id="anc4"></a><span class="line-added">184       tty-&gt;print_cr(&quot;- - - [BEGIN] - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -&quot;);</span>
185       tty-&gt;print_cr(&quot;Decoding %s &quot; INTPTR_FORMAT, stub_id, (intptr_t) stub);
<a name="5" id="anc5"></a><span class="line-modified">186       Disassembler::decode(stub-&gt;code_begin(), stub-&gt;code_end(), tty);</span>
<span class="line-added">187       if ((stub-&gt;oop_maps() != NULL) &amp;&amp; AbstractDisassembler::show_structs()) {</span>
<span class="line-added">188         tty-&gt;print_cr(&quot;- - - [OOP MAPS]- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -&quot;);</span>
<span class="line-added">189         stub-&gt;oop_maps()-&gt;print();</span>
<span class="line-added">190       }</span>
<span class="line-added">191       tty-&gt;print_cr(&quot;- - - [END] - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -&quot;);</span>
192       tty-&gt;cr();
193     }
194     Forte::register_stub(stub_id, stub-&gt;code_begin(), stub-&gt;code_end());
195 
196     if (JvmtiExport::should_post_dynamic_code_generated()) {
197       const char* stub_name = name2;
198       if (name2[0] == &#39;\0&#39;)  stub_name = name1;
199       JvmtiExport::post_dynamic_code_generated(stub_name, stub-&gt;code_begin(), stub-&gt;code_end());
200     }
201   }
202 
203   // Track memory usage statistic after releasing CodeCache_lock
204   MemoryService::track_code_cache_memory_usage();
205 }
206 
207 const ImmutableOopMap* CodeBlob::oop_map_for_return_address(address return_address) {
208   assert(_oop_maps != NULL, &quot;nope&quot;);
209   return _oop_maps-&gt;find_map_at_offset((intptr_t) return_address - (intptr_t) code_begin());
210 }
211 
212 void CodeBlob::print_code() {
213   ResourceMark m;
214   Disassembler::decode(this, tty);
215 }
216 
217 //----------------------------------------------------------------------------------------------------
218 // Implementation of BufferBlob
219 
220 
221 BufferBlob::BufferBlob(const char* name, int size)
222 : RuntimeBlob(name, sizeof(BufferBlob), size, CodeOffsets::frame_never_safe, /*locs_size:*/ 0)
223 {}
224 
225 BufferBlob* BufferBlob::create(const char* name, int buffer_size) {
226   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
227 
228   BufferBlob* blob = NULL;
229   unsigned int size = sizeof(BufferBlob);
230   // align the size to CodeEntryAlignment
231   size = CodeBlob::align_code_offset(size);
232   size += align_up(buffer_size, oopSize);
233   assert(name != NULL, &quot;must provide a name&quot;);
234   {
<a name="6" id="anc6"></a><span class="line-modified">235     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
236     blob = new (size) BufferBlob(name, size);
237   }
238   // Track memory usage statistic after releasing CodeCache_lock
239   MemoryService::track_code_cache_memory_usage();
240 
241   return blob;
242 }
243 
244 
245 BufferBlob::BufferBlob(const char* name, int size, CodeBuffer* cb)
246   : RuntimeBlob(name, cb, sizeof(BufferBlob), size, CodeOffsets::frame_never_safe, 0, NULL)
247 {}
248 
249 BufferBlob* BufferBlob::create(const char* name, CodeBuffer* cb) {
250   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
251 
252   BufferBlob* blob = NULL;
253   unsigned int size = CodeBlob::allocation_size(cb, sizeof(BufferBlob));
254   assert(name != NULL, &quot;must provide a name&quot;);
255   {
<a name="7" id="anc7"></a><span class="line-modified">256     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
257     blob = new (size) BufferBlob(name, size, cb);
258   }
259   // Track memory usage statistic after releasing CodeCache_lock
260   MemoryService::track_code_cache_memory_usage();
261 
262   return blob;
263 }
264 
265 void* BufferBlob::operator new(size_t s, unsigned size) throw() {
266   return CodeCache::allocate(size, CodeBlobType::NonNMethod);
267 }
268 
269 void BufferBlob::free(BufferBlob *blob) {
<a name="8" id="anc8"></a><span class="line-added">270   assert(blob != NULL, &quot;caller must check for NULL&quot;);</span>
271   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
272   blob-&gt;flush();
273   {
<a name="9" id="anc9"></a><span class="line-modified">274     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
275     CodeCache::free((RuntimeBlob*)blob);
276   }
277   // Track memory usage statistic after releasing CodeCache_lock
278   MemoryService::track_code_cache_memory_usage();
279 }
280 
281 
282 //----------------------------------------------------------------------------------------------------
283 // Implementation of AdapterBlob
284 
285 AdapterBlob::AdapterBlob(int size, CodeBuffer* cb) :
286   BufferBlob(&quot;I2C/C2I adapters&quot;, size, cb) {
287   CodeCache::commit(this);
288 }
289 
290 AdapterBlob* AdapterBlob::create(CodeBuffer* cb) {
291   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
292 
293   AdapterBlob* blob = NULL;
294   unsigned int size = CodeBlob::allocation_size(cb, sizeof(AdapterBlob));
295   {
<a name="10" id="anc10"></a><span class="line-modified">296     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
297     blob = new (size) AdapterBlob(size, cb);
298   }
299   // Track memory usage statistic after releasing CodeCache_lock
300   MemoryService::track_code_cache_memory_usage();
301 
302   return blob;
303 }
304 
305 VtableBlob::VtableBlob(const char* name, int size) :
306   BufferBlob(name, size) {
307 }
308 
309 VtableBlob* VtableBlob::create(const char* name, int buffer_size) {
310   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
311 
312   VtableBlob* blob = NULL;
313   unsigned int size = sizeof(VtableBlob);
314   // align the size to CodeEntryAlignment
315   size = align_code_offset(size);
316   size += align_up(buffer_size, oopSize);
317   assert(name != NULL, &quot;must provide a name&quot;);
318   {
<a name="11" id="anc11"></a><span class="line-modified">319     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
320     blob = new (size) VtableBlob(name, size);
321   }
322   // Track memory usage statistic after releasing CodeCache_lock
323   MemoryService::track_code_cache_memory_usage();
324 
325   return blob;
326 }
327 
328 //----------------------------------------------------------------------------------------------------
329 // Implementation of MethodHandlesAdapterBlob
330 
331 MethodHandlesAdapterBlob* MethodHandlesAdapterBlob::create(int buffer_size) {
332   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
333 
334   MethodHandlesAdapterBlob* blob = NULL;
335   unsigned int size = sizeof(MethodHandlesAdapterBlob);
336   // align the size to CodeEntryAlignment
337   size = CodeBlob::align_code_offset(size);
338   size += align_up(buffer_size, oopSize);
339   {
<a name="12" id="anc12"></a><span class="line-modified">340     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
341     blob = new (size) MethodHandlesAdapterBlob(size);
342     if (blob == NULL) {
343       vm_exit_out_of_memory(size, OOM_MALLOC_ERROR, &quot;CodeCache: no room for method handle adapter blob&quot;);
344     }
345   }
346   // Track memory usage statistic after releasing CodeCache_lock
347   MemoryService::track_code_cache_memory_usage();
348 
349   return blob;
350 }
351 
352 //----------------------------------------------------------------------------------------------------
353 // Implementation of RuntimeStub
354 
355 RuntimeStub::RuntimeStub(
356   const char* name,
357   CodeBuffer* cb,
358   int         size,
359   int         frame_complete,
360   int         frame_size,
361   OopMapSet*  oop_maps,
362   bool        caller_must_gc_arguments
363 )
364 : RuntimeBlob(name, cb, sizeof(RuntimeStub), size, frame_complete, frame_size, oop_maps, caller_must_gc_arguments)
365 {
366 }
367 
368 RuntimeStub* RuntimeStub::new_runtime_stub(const char* stub_name,
369                                            CodeBuffer* cb,
370                                            int frame_complete,
371                                            int frame_size,
372                                            OopMapSet* oop_maps,
373                                            bool caller_must_gc_arguments)
374 {
375   RuntimeStub* stub = NULL;
376   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
377   {
<a name="13" id="anc13"></a><span class="line-modified">378     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
379     unsigned int size = CodeBlob::allocation_size(cb, sizeof(RuntimeStub));
380     stub = new (size) RuntimeStub(stub_name, cb, size, frame_complete, frame_size, oop_maps, caller_must_gc_arguments);
381   }
382 
383   trace_new_stub(stub, &quot;RuntimeStub - &quot;, stub_name);
384 
385   return stub;
386 }
387 
388 
389 void* RuntimeStub::operator new(size_t s, unsigned size) throw() {
390   void* p = CodeCache::allocate(size, CodeBlobType::NonNMethod);
391   if (!p) fatal(&quot;Initial size of CodeCache is too small&quot;);
392   return p;
393 }
394 
395 // operator new shared by all singletons:
396 void* SingletonBlob::operator new(size_t s, unsigned size) throw() {
397   void* p = CodeCache::allocate(size, CodeBlobType::NonNMethod);
398   if (!p) fatal(&quot;Initial size of CodeCache is too small&quot;);
399   return p;
400 }
401 
402 
403 //----------------------------------------------------------------------------------------------------
404 // Implementation of DeoptimizationBlob
405 
406 DeoptimizationBlob::DeoptimizationBlob(
407   CodeBuffer* cb,
408   int         size,
409   OopMapSet*  oop_maps,
410   int         unpack_offset,
411   int         unpack_with_exception_offset,
412   int         unpack_with_reexecution_offset,
413   int         frame_size
414 )
415 : SingletonBlob(&quot;DeoptimizationBlob&quot;, cb, sizeof(DeoptimizationBlob), size, frame_size, oop_maps)
416 {
417   _unpack_offset           = unpack_offset;
418   _unpack_with_exception   = unpack_with_exception_offset;
419   _unpack_with_reexecution = unpack_with_reexecution_offset;
420 #ifdef COMPILER1
421   _unpack_with_exception_in_tls   = -1;
422 #endif
423 }
424 
425 
426 DeoptimizationBlob* DeoptimizationBlob::create(
427   CodeBuffer* cb,
428   OopMapSet*  oop_maps,
429   int        unpack_offset,
430   int        unpack_with_exception_offset,
431   int        unpack_with_reexecution_offset,
432   int        frame_size)
433 {
434   DeoptimizationBlob* blob = NULL;
435   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
436   {
<a name="14" id="anc14"></a><span class="line-modified">437     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
438     unsigned int size = CodeBlob::allocation_size(cb, sizeof(DeoptimizationBlob));
439     blob = new (size) DeoptimizationBlob(cb,
440                                          size,
441                                          oop_maps,
442                                          unpack_offset,
443                                          unpack_with_exception_offset,
444                                          unpack_with_reexecution_offset,
445                                          frame_size);
446   }
447 
448   trace_new_stub(blob, &quot;DeoptimizationBlob&quot;);
449 
450   return blob;
451 }
452 
453 
454 //----------------------------------------------------------------------------------------------------
455 // Implementation of UncommonTrapBlob
456 
457 #ifdef COMPILER2
458 UncommonTrapBlob::UncommonTrapBlob(
459   CodeBuffer* cb,
460   int         size,
461   OopMapSet*  oop_maps,
462   int         frame_size
463 )
464 : SingletonBlob(&quot;UncommonTrapBlob&quot;, cb, sizeof(UncommonTrapBlob), size, frame_size, oop_maps)
465 {}
466 
467 
468 UncommonTrapBlob* UncommonTrapBlob::create(
469   CodeBuffer* cb,
470   OopMapSet*  oop_maps,
471   int        frame_size)
472 {
473   UncommonTrapBlob* blob = NULL;
474   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
475   {
<a name="15" id="anc15"></a><span class="line-modified">476     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
477     unsigned int size = CodeBlob::allocation_size(cb, sizeof(UncommonTrapBlob));
478     blob = new (size) UncommonTrapBlob(cb, size, oop_maps, frame_size);
479   }
480 
481   trace_new_stub(blob, &quot;UncommonTrapBlob&quot;);
482 
483   return blob;
484 }
485 
486 
487 #endif // COMPILER2
488 
489 
490 //----------------------------------------------------------------------------------------------------
491 // Implementation of ExceptionBlob
492 
493 #ifdef COMPILER2
494 ExceptionBlob::ExceptionBlob(
495   CodeBuffer* cb,
496   int         size,
497   OopMapSet*  oop_maps,
498   int         frame_size
499 )
500 : SingletonBlob(&quot;ExceptionBlob&quot;, cb, sizeof(ExceptionBlob), size, frame_size, oop_maps)
501 {}
502 
503 
504 ExceptionBlob* ExceptionBlob::create(
505   CodeBuffer* cb,
506   OopMapSet*  oop_maps,
507   int         frame_size)
508 {
509   ExceptionBlob* blob = NULL;
510   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
511   {
<a name="16" id="anc16"></a><span class="line-modified">512     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
513     unsigned int size = CodeBlob::allocation_size(cb, sizeof(ExceptionBlob));
514     blob = new (size) ExceptionBlob(cb, size, oop_maps, frame_size);
515   }
516 
517   trace_new_stub(blob, &quot;ExceptionBlob&quot;);
518 
519   return blob;
520 }
521 
522 
523 #endif // COMPILER2
524 
525 
526 //----------------------------------------------------------------------------------------------------
527 // Implementation of SafepointBlob
528 
529 SafepointBlob::SafepointBlob(
530   CodeBuffer* cb,
531   int         size,
532   OopMapSet*  oop_maps,
533   int         frame_size
534 )
535 : SingletonBlob(&quot;SafepointBlob&quot;, cb, sizeof(SafepointBlob), size, frame_size, oop_maps)
536 {}
537 
538 
539 SafepointBlob* SafepointBlob::create(
540   CodeBuffer* cb,
541   OopMapSet*  oop_maps,
542   int         frame_size)
543 {
544   SafepointBlob* blob = NULL;
545   ThreadInVMfromUnknown __tiv;  // get to VM state in case we block on CodeCache_lock
546   {
<a name="17" id="anc17"></a><span class="line-modified">547     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
548     unsigned int size = CodeBlob::allocation_size(cb, sizeof(SafepointBlob));
549     blob = new (size) SafepointBlob(cb, size, oop_maps, frame_size);
550   }
551 
552   trace_new_stub(blob, &quot;SafepointBlob&quot;);
553 
554   return blob;
555 }
556 
557 
558 //----------------------------------------------------------------------------------------------------
559 // Verification and printing
560 
561 void CodeBlob::print_on(outputStream* st) const {
562   st-&gt;print_cr(&quot;[CodeBlob (&quot; INTPTR_FORMAT &quot;)]&quot;, p2i(this));
563   st-&gt;print_cr(&quot;Framesize: %d&quot;, _frame_size);
564 }
565 
<a name="18" id="anc18"></a><span class="line-added">566 void CodeBlob::print() const { print_on(tty); }</span>
<span class="line-added">567 </span>
568 void CodeBlob::print_value_on(outputStream* st) const {
569   st-&gt;print_cr(&quot;[CodeBlob]&quot;);
570 }
571 
572 void CodeBlob::dump_for_addr(address addr, outputStream* st, bool verbose) const {
573   if (is_buffer_blob()) {
574     // the interpreter is generated into a buffer blob
575     InterpreterCodelet* i = Interpreter::codelet_containing(addr);
576     if (i != NULL) {
577       st-&gt;print_cr(INTPTR_FORMAT &quot; is at code_begin+%d in an Interpreter codelet&quot;, p2i(addr), (int)(addr - i-&gt;code_begin()));
578       i-&gt;print_on(st);
579       return;
580     }
581     if (Interpreter::contains(addr)) {
582       st-&gt;print_cr(INTPTR_FORMAT &quot; is pointing into interpreter code&quot;
583                    &quot; (not bytecode specific)&quot;, p2i(addr));
584       return;
585     }
586     //
587     if (AdapterHandlerLibrary::contains(this)) {
588       st-&gt;print_cr(INTPTR_FORMAT &quot; is at code_begin+%d in an AdapterHandler&quot;, p2i(addr), (int)(addr - code_begin()));
589       AdapterHandlerLibrary::print_handler_on(st, this);
590     }
591     // the stubroutines are generated into a buffer blob
592     StubCodeDesc* d = StubCodeDesc::desc_for(addr);
593     if (d != NULL) {
594       st-&gt;print_cr(INTPTR_FORMAT &quot; is at begin+%d in a stub&quot;, p2i(addr), (int)(addr - d-&gt;begin()));
595       d-&gt;print_on(st);
596       st-&gt;cr();
597       return;
598     }
599     if (StubRoutines::contains(addr)) {
600       st-&gt;print_cr(INTPTR_FORMAT &quot; is pointing to an (unnamed) stub routine&quot;, p2i(addr));
601       return;
602     }
603     // the InlineCacheBuffer is using stubs generated into a buffer blob
604     if (InlineCacheBuffer::contains(addr)) {
605       st-&gt;print_cr(INTPTR_FORMAT &quot; is pointing into InlineCacheBuffer&quot;, p2i(addr));
606       return;
607     }
608     VtableStub* v = VtableStubs::stub_containing(addr);
609     if (v != NULL) {
610       st-&gt;print_cr(INTPTR_FORMAT &quot; is at entry_point+%d in a vtable stub&quot;, p2i(addr), (int)(addr - v-&gt;entry_point()));
611       v-&gt;print_on(st);
612       st-&gt;cr();
613       return;
614     }
615   }
616   if (is_nmethod()) {
617     nmethod* nm = (nmethod*)this;
618     ResourceMark rm;
619     st-&gt;print(INTPTR_FORMAT &quot; is at entry_point+%d in (nmethod*)&quot; INTPTR_FORMAT,
620               p2i(addr), (int)(addr - nm-&gt;entry_point()), p2i(nm));
621     if (verbose) {
622       st-&gt;print(&quot; for &quot;);
623       nm-&gt;method()-&gt;print_value_on(st);
624     }
625     st-&gt;cr();
626     nm-&gt;print_nmethod(verbose);
627     return;
628   }
629   st-&gt;print_cr(INTPTR_FORMAT &quot; is at code_begin+%d in &quot;, p2i(addr), (int)(addr - code_begin()));
630   print_on(st);
631 }
632 
633 void RuntimeBlob::verify() {
634   ShouldNotReachHere();
635 }
636 
637 void BufferBlob::verify() {
638   // unimplemented
639 }
640 
641 void BufferBlob::print_on(outputStream* st) const {
642   RuntimeBlob::print_on(st);
643   print_value_on(st);
644 }
645 
646 void BufferBlob::print_value_on(outputStream* st) const {
647   st-&gt;print_cr(&quot;BufferBlob (&quot; INTPTR_FORMAT  &quot;) used for %s&quot;, p2i(this), name());
648 }
649 
650 void RuntimeStub::verify() {
651   // unimplemented
652 }
653 
654 void RuntimeStub::print_on(outputStream* st) const {
655   ttyLocker ttyl;
656   RuntimeBlob::print_on(st);
657   st-&gt;print(&quot;Runtime Stub (&quot; INTPTR_FORMAT &quot;): &quot;, p2i(this));
658   st-&gt;print_cr(&quot;%s&quot;, name());
659   Disassembler::decode((RuntimeBlob*)this, st);
660 }
661 
662 void RuntimeStub::print_value_on(outputStream* st) const {
663   st-&gt;print(&quot;RuntimeStub (&quot; INTPTR_FORMAT &quot;): &quot;, p2i(this)); st-&gt;print(&quot;%s&quot;, name());
664 }
665 
666 void SingletonBlob::verify() {
667   // unimplemented
668 }
669 
670 void SingletonBlob::print_on(outputStream* st) const {
671   ttyLocker ttyl;
672   RuntimeBlob::print_on(st);
673   st-&gt;print_cr(&quot;%s&quot;, name());
674   Disassembler::decode((RuntimeBlob*)this, st);
675 }
676 
677 void SingletonBlob::print_value_on(outputStream* st) const {
678   st-&gt;print_cr(&quot;%s&quot;, name());
679 }
680 
681 void DeoptimizationBlob::print_value_on(outputStream* st) const {
682   st-&gt;print_cr(&quot;Deoptimization (frame not available)&quot;);
683 }
<a name="19" id="anc19"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="19" type="hidden" />
</body>
</html>
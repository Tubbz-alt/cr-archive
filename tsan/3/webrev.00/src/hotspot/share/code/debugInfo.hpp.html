<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/code/debugInfo.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CODE_DEBUGINFO_HPP
 26 #define SHARE_CODE_DEBUGINFO_HPP
 27 
 28 #include &quot;code/compressedStream.hpp&quot;
 29 #include &quot;code/location.hpp&quot;
 30 #include &quot;code/nmethod.hpp&quot;
 31 #include &quot;code/oopRecorder.hpp&quot;
 32 #include &quot;runtime/stackValue.hpp&quot;
 33 #include &quot;runtime/thread.hpp&quot;
 34 #include &quot;utilities/growableArray.hpp&quot;
 35 
 36 // Classes used for serializing debugging information.
 37 // These abstractions are introducted to provide symmetric
 38 // read and write operations.
 39 
 40 // ScopeValue        describes the value of a variable/expression in a scope
 41 // - LocationValue   describes a value in a given location (in frame or register)
 42 // - ConstantValue   describes a constant
 43 
 44 class ConstantOopReadValue;
 45 class ObjectValue;
 46 
 47 class ScopeValue: public ResourceObj {
 48  public:
 49   // Testers
 50   virtual bool is_location() const { return false; }
 51   virtual bool is_object() const { return false; }
 52   virtual bool is_auto_box() const { return false; }
 53   virtual bool is_constant_int() const { return false; }
 54   virtual bool is_constant_double() const { return false; }
 55   virtual bool is_constant_long() const { return false; }
 56   virtual bool is_constant_oop() const { return false; }
 57   virtual bool equals(ScopeValue* other) const { return false; }
 58 
 59   ConstantOopReadValue* as_ConstantOopReadValue() {
 60     assert(is_constant_oop(), &quot;must be&quot;);
 61     return (ConstantOopReadValue*) this;
 62   }
 63 
 64   ObjectValue* as_ObjectValue() {
 65     assert(is_object(), &quot;must be&quot;);
 66     return (ObjectValue*)this;
 67   }
 68 
 69   // Serialization of debugging information
 70   virtual void write_on(DebugInfoWriteStream* stream) = 0;
 71   static ScopeValue* read_from(DebugInfoReadStream* stream);
 72 };
 73 
 74 
 75 // A Location value describes a value in a given location; i.e. the corresponding
 76 // logical entity (e.g., a method temporary) lives in this location.
 77 
 78 class LocationValue: public ScopeValue {
 79  private:
 80   Location  _location;
 81  public:
 82   LocationValue(Location location)           { _location = location; }
 83   bool      is_location() const              { return true; }
 84   Location  location() const                 { return _location; }
 85 
 86   // Serialization of debugging information
 87   LocationValue(DebugInfoReadStream* stream);
 88   void write_on(DebugInfoWriteStream* stream);
 89 
 90   // Printing
 91   void print_on(outputStream* st) const;
 92 };
 93 
 94 
 95 // An ObjectValue describes an object eliminated by escape analysis.
 96 
 97 class ObjectValue: public ScopeValue {
 98  protected:
 99   int                        _id;
100   ScopeValue*                _klass;
101   GrowableArray&lt;ScopeValue*&gt; _field_values;
102   Handle                     _value;
103   bool                       _visited;
104  public:
105   ObjectValue(int id, ScopeValue* klass)
106      : _id(id)
107      , _klass(klass)
108      , _field_values()
109      , _value()
110      , _visited(false) {
111     assert(klass-&gt;is_constant_oop(), &quot;should be constant java mirror oop&quot;);
112   }
113 
114   ObjectValue(int id)
115      : _id(id)
116      , _klass(NULL)
117      , _field_values()
118      , _value()
119      , _visited(false) {}
120 
121   // Accessors
122   bool                        is_object() const         { return true; }
123   int                         id() const                { return _id; }
124   ScopeValue*                 klass() const             { return _klass; }
125   GrowableArray&lt;ScopeValue*&gt;* field_values()            { return &amp;_field_values; }
126   ScopeValue*                 field_at(int i) const     { return _field_values.at(i); }
127   int                         field_size()              { return _field_values.length(); }
128   Handle                      value() const             { return _value; }
129   bool                        is_visited() const        { return _visited; }
130 
131   void                        set_value(oop value);
132   void                        set_visited(bool visited) { _visited = false; }
133 
134   // Serialization of debugging information
135   void read_object(DebugInfoReadStream* stream);
136   void write_on(DebugInfoWriteStream* stream);
137 
138   // Printing
139   void print_on(outputStream* st) const;
140   void print_fields_on(outputStream* st) const;
141 };
142 
143 class AutoBoxObjectValue : public ObjectValue {
144   bool                       _cached;
145 public:
146   bool                       is_auto_box() const        { return true; }
147   bool                       is_cached() const          { return _cached; }
148   void                       set_cached(bool cached)    { _cached = cached; }
149   AutoBoxObjectValue(int id, ScopeValue* klass) : ObjectValue(id, klass), _cached(false) { }
150   AutoBoxObjectValue(int id) : ObjectValue(id), _cached(false) { }
151 };
152 
153 
154 // A ConstantIntValue describes a constant int; i.e., the corresponding logical entity
155 // is either a source constant or its computation has been constant-folded.
156 
157 class ConstantIntValue: public ScopeValue {
158  private:
159   jint _value;
160  public:
161   ConstantIntValue(jint value)         { _value = value; }
162   jint value() const                   { return _value;  }
163   bool is_constant_int() const         { return true;    }
164   bool equals(ScopeValue* other) const { return false;   }
165 
166   // Serialization of debugging information
167   ConstantIntValue(DebugInfoReadStream* stream);
168   void write_on(DebugInfoWriteStream* stream);
169 
170   // Printing
171   void print_on(outputStream* st) const;
172 };
173 
174 class ConstantLongValue: public ScopeValue {
175  private:
176   jlong _value;
177  public:
178   ConstantLongValue(jlong value)       { _value = value; }
179   jlong value() const                  { return _value;  }
180   bool is_constant_long() const        { return true;    }
181   bool equals(ScopeValue* other) const { return false;   }
182 
183   // Serialization of debugging information
184   ConstantLongValue(DebugInfoReadStream* stream);
185   void write_on(DebugInfoWriteStream* stream);
186 
187   // Printing
188   void print_on(outputStream* st) const;
189 };
190 
191 class ConstantDoubleValue: public ScopeValue {
192  private:
193   jdouble _value;
194  public:
195   ConstantDoubleValue(jdouble value)   { _value = value; }
196   jdouble value() const                { return _value;  }
197   bool is_constant_double() const      { return true;    }
198   bool equals(ScopeValue* other) const { return false;   }
199 
200   // Serialization of debugging information
201   ConstantDoubleValue(DebugInfoReadStream* stream);
202   void write_on(DebugInfoWriteStream* stream);
203 
204   // Printing
205   void print_on(outputStream* st) const;
206 };
207 
208 // A ConstantOopWriteValue is created by the compiler to
209 // be written as debugging information.
210 
211 class ConstantOopWriteValue: public ScopeValue {
212  private:
213   jobject _value;
214  public:
215   ConstantOopWriteValue(jobject value) { _value = value; }
216   jobject value() const                { return _value;  }
217   bool is_constant_oop() const         { return true;    }
218   bool equals(ScopeValue* other) const { return false;   }
219 
220   // Serialization of debugging information
221   void write_on(DebugInfoWriteStream* stream);
222 
223   // Printing
224   void print_on(outputStream* st) const;
225 };
226 
227 // A ConstantOopReadValue is created by the VM when reading
228 // debug information
229 
230 class ConstantOopReadValue: public ScopeValue {
231  private:
232   Handle _value;
233  public:
234   Handle value() const                 { return _value;  }
235   bool is_constant_oop() const         { return true;    }
236   bool equals(ScopeValue* other) const { return false;   }
237 
238   // Serialization of debugging information
239   ConstantOopReadValue(DebugInfoReadStream* stream);
240   void write_on(DebugInfoWriteStream* stream);
241 
242   // Printing
243   void print_on(outputStream* st) const;
244 };
245 
246 // MonitorValue describes the pair used for monitor_enter and monitor_exit.
247 
248 class MonitorValue: public ResourceObj {
249  private:
250   ScopeValue* _owner;
251   Location    _basic_lock;
252   bool        _eliminated;
253  public:
254   // Constructor
255   MonitorValue(ScopeValue* owner, Location basic_lock, bool eliminated = false);
256 
257   // Accessors
258   ScopeValue*  owner()      const { return _owner; }
259   Location     basic_lock() const { return _basic_lock;  }
260   bool         eliminated() const { return _eliminated; }
261 
262   // Serialization of debugging information
263   MonitorValue(DebugInfoReadStream* stream);
264   void write_on(DebugInfoWriteStream* stream);
265 
266   // Printing
267   void print_on(outputStream* st) const;
268 };
269 
270 // DebugInfoReadStream specializes CompressedReadStream for reading
271 // debugging information. Used by ScopeDesc.
272 
273 class DebugInfoReadStream : public CompressedReadStream {
274  private:
275   const CompiledMethod* _code;
276   const CompiledMethod* code() const { return _code; }
277   GrowableArray&lt;ScopeValue*&gt;* _obj_pool;
278  public:
279   DebugInfoReadStream(const CompiledMethod* code, int offset, GrowableArray&lt;ScopeValue*&gt;* obj_pool = NULL) :
280     CompressedReadStream(code-&gt;scopes_data_begin(), offset) {
281     _code = code;
282     _obj_pool = obj_pool;
283 
284   } ;
285 
286   oop read_oop();
287   Method* read_method() {
288     Method* o = (Method*)(code()-&gt;metadata_at(read_int()));
289     // is_metadata() is a faster check than is_metaspace_object()
290     assert(o == NULL || o-&gt;is_metadata(), &quot;meta data only&quot;);
291     return o;
292   }
293   ScopeValue* read_object_value(bool is_auto_box);
294   ScopeValue* get_cached_object();
295   // BCI encoding is mostly unsigned, but -1 is a distinguished value
296   int read_bci() { return read_int() + InvocationEntryBci; }
297 };
298 
299 // DebugInfoWriteStream specializes CompressedWriteStream for
300 // writing debugging information. Used by ScopeDescRecorder.
301 
302 class DebugInfoWriteStream : public CompressedWriteStream {
303  private:
304   DebugInformationRecorder* _recorder;
305   DebugInformationRecorder* recorder() const { return _recorder; }
306  public:
307   DebugInfoWriteStream(DebugInformationRecorder* recorder, int initial_size);
308   void write_handle(jobject h);
309   void write_bci(int bci) { write_int(bci - InvocationEntryBci); }
310 
311   void write_metadata(Metadata* m);
312 };
313 
314 #endif // SHARE_CODE_DEBUGINFO_HPP
    </pre>
  </body>
</html>
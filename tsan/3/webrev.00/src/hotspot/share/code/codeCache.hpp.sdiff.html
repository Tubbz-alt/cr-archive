<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/code/codeCache.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="codeCache.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="codeHeapState.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/codeCache.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
130 
131   static int code_heap_compare(CodeHeap* const &amp;lhs, CodeHeap* const &amp;rhs);
132 
133   static void add_heap(CodeHeap* heap);
134   static const GrowableArray&lt;CodeHeap*&gt;* heaps() { return _heaps; }
135   static const GrowableArray&lt;CodeHeap*&gt;* compiled_heaps() { return _compiled_heaps; }
136   static const GrowableArray&lt;CodeHeap*&gt;* nmethod_heaps() { return _nmethod_heaps; }
137 
138   // Allocation/administration
139   static CodeBlob* allocate(int size, int code_blob_type, int orig_code_blob_type = CodeBlobType::All); // allocates a new CodeBlob
140   static void commit(CodeBlob* cb);                        // called when the allocated CodeBlob has been filled
141   static int  alignment_unit();                            // guaranteed alignment of all CodeBlobs
142   static int  alignment_offset();                          // guaranteed offset of first CodeBlob byte within alignment unit (i.e., allocation header)
143   static void free(CodeBlob* cb);                          // frees a CodeBlob
144   static void free_unused_tail(CodeBlob* cb, size_t used); // frees the unused tail of a CodeBlob (only used by TemplateInterpreter::initialize())
145   static bool contains(void *p);                           // returns whether p is included
146   static bool contains(nmethod* nm);                       // returns whether nm is included
147   static void blobs_do(void f(CodeBlob* cb));              // iterates over all CodeBlobs
148   static void blobs_do(CodeBlobClosure* f);                // iterates over all CodeBlobs
149   static void nmethods_do(void f(nmethod* nm));            // iterates over all nmethods
<span class="line-modified">150   static void metadata_do(void f(Metadata* m));            // iterates over metadata in alive nmethods</span>
151 
152   // Lookup
153   static CodeBlob* find_blob(void* start);              // Returns the CodeBlob containing the given address
154   static CodeBlob* find_blob_unsafe(void* start);       // Same as find_blob but does not fail if looking up a zombie method
155   static nmethod*  find_nmethod(void* start);           // Returns the nmethod containing the given address
156   static CompiledMethod* find_compiled(void* start);
157 
158   static int       blob_count();                        // Returns the total number of CodeBlobs in the cache
159   static int       blob_count(int code_blob_type);
160   static int       adapter_count();                     // Returns the total number of Adapters in the cache
161   static int       adapter_count(int code_blob_type);
162   static int       nmethod_count();                     // Returns the total number of nmethods in the cache
163   static int       nmethod_count(int code_blob_type);
164 
165   // GC support
166   static void verify_oops();
167   // If any oops are not marked this method unloads (i.e., breaks root links
168   // to) any unmarked codeBlobs in the cache.  Sets &quot;marked_for_unloading&quot;
169   // to &quot;true&quot; iff some code got unloaded.
170   // &quot;unloading_occurred&quot; controls whether metadata should be cleaned because of class unloading.
171   class UnloadingScope: StackObj {
172     ClosureIsUnloadingBehaviour _is_unloading_behaviour;

173 
174   public:
175     UnloadingScope(BoolObjectClosure* is_alive);
176     ~UnloadingScope();
177   };
178 
179   static void do_unloading(BoolObjectClosure* is_alive, bool unloading_occurred);
180   static uint8_t unloading_cycle() { return _unloading_cycle; }
181   static void increment_unloading_cycle();
182   static void release_exception_cache(ExceptionCache* entry);
183   static void purge_exception_caches();
184 
185   // Printing/debugging
186   static void print();                           // prints summary
187   static void print_internals();
188   static void print_memory_overhead();
189   static void verify();                          // verifies the code cache
190   static void print_trace(const char* event, CodeBlob* cb, int size = 0) PRODUCT_RETURN;
191   static void print_summary(outputStream* st, bool detailed = true); // Prints a summary of the code cache usage
192   static void log_state(outputStream* st);
</pre>
<hr />
<pre>
253       return CodeBlobType::MethodProfiled;
254     }
255     ShouldNotReachHere();
256     return 0;
257   }
258 
259   static void verify_clean_inline_caches();
260   static void verify_icholder_relocations();
261 
262   // Deoptimization
263  private:
264   static int  mark_for_deoptimization(KlassDepChange&amp; changes);
265 
266  public:
267   static void mark_all_nmethods_for_deoptimization();
268   static int  mark_for_deoptimization(Method* dependee);
269   static void make_marked_nmethods_not_entrant();
270 
271   // Flushing and deoptimization
272   static void flush_dependents_on(InstanceKlass* dependee);


273   // Flushing and deoptimization in case of evolution
274   static void mark_for_evol_deoptimization(InstanceKlass* dependee);
275   static int  mark_dependents_for_evol_deoptimization();

276   static void flush_evol_dependents();



277   // Support for fullspeed debugging
278   static void flush_dependents_on_method(const methodHandle&amp; dependee);
279 
280   // tells how many nmethods have dependencies
281   static int number_of_nmethods_with_dependencies();
282 
283   static int get_codemem_full_count(int code_blob_type) {
284     CodeHeap* heap = get_code_heap(code_blob_type);
285     return (heap != NULL) ? heap-&gt;full_count() : 0;
286   }
287 
288   // CodeHeap State Analytics.
289   // interface methods for CodeHeap printing, called by CompileBroker
<span class="line-modified">290   static void aggregate(outputStream *out, const char* granularity);</span>
291   static void discard(outputStream *out);
292   static void print_usedSpace(outputStream *out);
293   static void print_freeSpace(outputStream *out);
294   static void print_count(outputStream *out);
295   static void print_space(outputStream *out);
296   static void print_age(outputStream *out);
297   static void print_names(outputStream *out);
298 };
299 
300 
301 // Iterator to iterate over nmethods in the CodeCache.
302 template &lt;class T, class Filter&gt; class CodeBlobIterator : public StackObj {
303  public:
304   enum LivenessFilter { all_blobs, only_alive, only_alive_and_not_unloading };
305 
306  private:
307   CodeBlob* _code_blob;   // Current CodeBlob
308   GrowableArrayIterator&lt;CodeHeap*&gt; _heap;
309   GrowableArrayIterator&lt;CodeHeap*&gt; _end;
310   bool _only_alive;
</pre>
</td>
<td>
<hr />
<pre>
130 
131   static int code_heap_compare(CodeHeap* const &amp;lhs, CodeHeap* const &amp;rhs);
132 
133   static void add_heap(CodeHeap* heap);
134   static const GrowableArray&lt;CodeHeap*&gt;* heaps() { return _heaps; }
135   static const GrowableArray&lt;CodeHeap*&gt;* compiled_heaps() { return _compiled_heaps; }
136   static const GrowableArray&lt;CodeHeap*&gt;* nmethod_heaps() { return _nmethod_heaps; }
137 
138   // Allocation/administration
139   static CodeBlob* allocate(int size, int code_blob_type, int orig_code_blob_type = CodeBlobType::All); // allocates a new CodeBlob
140   static void commit(CodeBlob* cb);                        // called when the allocated CodeBlob has been filled
141   static int  alignment_unit();                            // guaranteed alignment of all CodeBlobs
142   static int  alignment_offset();                          // guaranteed offset of first CodeBlob byte within alignment unit (i.e., allocation header)
143   static void free(CodeBlob* cb);                          // frees a CodeBlob
144   static void free_unused_tail(CodeBlob* cb, size_t used); // frees the unused tail of a CodeBlob (only used by TemplateInterpreter::initialize())
145   static bool contains(void *p);                           // returns whether p is included
146   static bool contains(nmethod* nm);                       // returns whether nm is included
147   static void blobs_do(void f(CodeBlob* cb));              // iterates over all CodeBlobs
148   static void blobs_do(CodeBlobClosure* f);                // iterates over all CodeBlobs
149   static void nmethods_do(void f(nmethod* nm));            // iterates over all nmethods
<span class="line-modified">150   static void metadata_do(MetadataClosure* f);             // iterates over metadata in alive nmethods</span>
151 
152   // Lookup
153   static CodeBlob* find_blob(void* start);              // Returns the CodeBlob containing the given address
154   static CodeBlob* find_blob_unsafe(void* start);       // Same as find_blob but does not fail if looking up a zombie method
155   static nmethod*  find_nmethod(void* start);           // Returns the nmethod containing the given address
156   static CompiledMethod* find_compiled(void* start);
157 
158   static int       blob_count();                        // Returns the total number of CodeBlobs in the cache
159   static int       blob_count(int code_blob_type);
160   static int       adapter_count();                     // Returns the total number of Adapters in the cache
161   static int       adapter_count(int code_blob_type);
162   static int       nmethod_count();                     // Returns the total number of nmethods in the cache
163   static int       nmethod_count(int code_blob_type);
164 
165   // GC support
166   static void verify_oops();
167   // If any oops are not marked this method unloads (i.e., breaks root links
168   // to) any unmarked codeBlobs in the cache.  Sets &quot;marked_for_unloading&quot;
169   // to &quot;true&quot; iff some code got unloaded.
170   // &quot;unloading_occurred&quot; controls whether metadata should be cleaned because of class unloading.
171   class UnloadingScope: StackObj {
172     ClosureIsUnloadingBehaviour _is_unloading_behaviour;
<span class="line-added">173     IsUnloadingBehaviour*       _saved_behaviour;</span>
174 
175   public:
176     UnloadingScope(BoolObjectClosure* is_alive);
177     ~UnloadingScope();
178   };
179 
180   static void do_unloading(BoolObjectClosure* is_alive, bool unloading_occurred);
181   static uint8_t unloading_cycle() { return _unloading_cycle; }
182   static void increment_unloading_cycle();
183   static void release_exception_cache(ExceptionCache* entry);
184   static void purge_exception_caches();
185 
186   // Printing/debugging
187   static void print();                           // prints summary
188   static void print_internals();
189   static void print_memory_overhead();
190   static void verify();                          // verifies the code cache
191   static void print_trace(const char* event, CodeBlob* cb, int size = 0) PRODUCT_RETURN;
192   static void print_summary(outputStream* st, bool detailed = true); // Prints a summary of the code cache usage
193   static void log_state(outputStream* st);
</pre>
<hr />
<pre>
254       return CodeBlobType::MethodProfiled;
255     }
256     ShouldNotReachHere();
257     return 0;
258   }
259 
260   static void verify_clean_inline_caches();
261   static void verify_icholder_relocations();
262 
263   // Deoptimization
264  private:
265   static int  mark_for_deoptimization(KlassDepChange&amp; changes);
266 
267  public:
268   static void mark_all_nmethods_for_deoptimization();
269   static int  mark_for_deoptimization(Method* dependee);
270   static void make_marked_nmethods_not_entrant();
271 
272   // Flushing and deoptimization
273   static void flush_dependents_on(InstanceKlass* dependee);
<span class="line-added">274 </span>
<span class="line-added">275   // RedefineClasses support</span>
276   // Flushing and deoptimization in case of evolution
277   static void mark_for_evol_deoptimization(InstanceKlass* dependee);
278   static int  mark_dependents_for_evol_deoptimization();
<span class="line-added">279   static void mark_all_nmethods_for_evol_deoptimization();</span>
280   static void flush_evol_dependents();
<span class="line-added">281   static void old_nmethods_do(MetadataClosure* f);</span>
<span class="line-added">282   static void unregister_old_nmethod(CompiledMethod* c);</span>
<span class="line-added">283 </span>
284   // Support for fullspeed debugging
285   static void flush_dependents_on_method(const methodHandle&amp; dependee);
286 
287   // tells how many nmethods have dependencies
288   static int number_of_nmethods_with_dependencies();
289 
290   static int get_codemem_full_count(int code_blob_type) {
291     CodeHeap* heap = get_code_heap(code_blob_type);
292     return (heap != NULL) ? heap-&gt;full_count() : 0;
293   }
294 
295   // CodeHeap State Analytics.
296   // interface methods for CodeHeap printing, called by CompileBroker
<span class="line-modified">297   static void aggregate(outputStream *out, size_t granularity);</span>
298   static void discard(outputStream *out);
299   static void print_usedSpace(outputStream *out);
300   static void print_freeSpace(outputStream *out);
301   static void print_count(outputStream *out);
302   static void print_space(outputStream *out);
303   static void print_age(outputStream *out);
304   static void print_names(outputStream *out);
305 };
306 
307 
308 // Iterator to iterate over nmethods in the CodeCache.
309 template &lt;class T, class Filter&gt; class CodeBlobIterator : public StackObj {
310  public:
311   enum LivenessFilter { all_blobs, only_alive, only_alive_and_not_unloading };
312 
313  private:
314   CodeBlob* _code_blob;   // Current CodeBlob
315   GrowableArrayIterator&lt;CodeHeap*&gt; _heap;
316   GrowableArrayIterator&lt;CodeHeap*&gt; _end;
317   bool _only_alive;
</pre>
</td>
</tr>
</table>
<center><a href="codeCache.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="codeHeapState.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/code/codeBlob.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="codeBlob.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="codeCache.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/codeBlob.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
130   virtual void flush();
131 
132   // Typing
133   virtual bool is_buffer_blob() const                 { return false; }
134   virtual bool is_nmethod() const                     { return false; }
135   virtual bool is_runtime_stub() const                { return false; }
136   virtual bool is_deoptimization_stub() const         { return false; }
137   virtual bool is_uncommon_trap_stub() const          { return false; }
138   virtual bool is_exception_stub() const              { return false; }
139   virtual bool is_safepoint_stub() const              { return false; }
140   virtual bool is_adapter_blob() const                { return false; }
141   virtual bool is_vtable_blob() const                 { return false; }
142   virtual bool is_method_handles_adapter_blob() const { return false; }
143   virtual bool is_aot() const                         { return false; }
144   virtual bool is_compiled() const                    { return false; }
145 
146   inline bool is_compiled_by_c1() const    { return _type == compiler_c1; };
147   inline bool is_compiled_by_c2() const    { return _type == compiler_c2; };
148   inline bool is_compiled_by_jvmci() const { return _type == compiler_jvmci; };
149   const char* compiler_name() const;

150 
151   // Casting
152   nmethod* as_nmethod_or_null()                { return is_nmethod() ? (nmethod*) this : NULL; }
153   nmethod* as_nmethod()                        { assert(is_nmethod(), &quot;must be nmethod&quot;); return (nmethod*) this; }
154   CompiledMethod* as_compiled_method_or_null() { return is_compiled() ? (CompiledMethod*) this : NULL; }
155   CompiledMethod* as_compiled_method()         { assert(is_compiled(), &quot;must be compiled&quot;); return (CompiledMethod*) this; }
156   CodeBlob* as_codeblob_or_null() const        { return (CodeBlob*) this; }
157 
158   // Boundaries
159   address header_begin() const        { return (address) this; }
160   relocInfo* relocation_begin() const { return (relocInfo*) _relocation_begin; };
161   relocInfo* relocation_end() const   { return (relocInfo*) _relocation_end; }
162   address content_begin() const       { return _content_begin; }
163   address content_end() const         { return _code_end; } // _code_end == _content_end is true for all types of blobs for now, it is also checked in the constructor
164   address code_begin() const          { return _code_begin;    }
165   address code_end() const            { return _code_end; }
166   address data_end() const            { return _data_end;      }
167 
168   // This field holds the beginning of the const section in the old code buffer.
169   // It is needed to fix relocations of pc-relative loads when resizing the
</pre>
<hr />
<pre>
194   int frame_complete_offset() const              { return _frame_complete_offset; }
195 
196   // CodeCache support: really only used by the nmethods, but in order to get
197   // asserts and certain bookkeeping to work in the CodeCache they are defined
198   // virtual here.
199   virtual bool is_zombie() const                 { return false; }
200   virtual bool is_locked_by_vm() const           { return false; }
201 
202   virtual bool is_unloaded() const               { return false; }
203   virtual bool is_not_entrant() const            { return false; }
204 
205   // GC support
206   virtual bool is_alive() const                  = 0;
207 
208   // OopMap for frame
209   ImmutableOopMapSet* oop_maps() const           { return _oop_maps; }
210   void set_oop_maps(OopMapSet* p);
211   const ImmutableOopMap* oop_map_for_return_address(address return_address);
212   virtual void preserve_callee_argument_oops(frame fr, const RegisterMap* reg_map, OopClosure* f) = 0;
213 
<span class="line-modified">214   // Frame support</span>
215   int  frame_size() const                        { return _frame_size; }
216   void set_frame_size(int size)                  { _frame_size = size; }
217 
218   // Returns true, if the next frame is responsible for GC&#39;ing oops passed as arguments
219   bool caller_must_gc_arguments(JavaThread* thread) const { return _caller_must_gc_arguments; }
220 
221   // Naming
222   const char* name() const                       { return _name; }
223   void set_name(const char* name)                { _name = name; }
224 
225   // Debugging
226   virtual void verify() = 0;
<span class="line-modified">227   virtual void print() const                     { print_on(tty); };</span>
228   virtual void print_on(outputStream* st) const;
229   virtual void print_value_on(outputStream* st) const;
230   void dump_for_addr(address addr, outputStream* st, bool verbose) const;
231   void print_code();
232 




233   // Print the comment associated with offset on stream, if there is one
234   virtual void print_block_comment(outputStream* stream, address block_begin) const {
235     intptr_t offset = (intptr_t)(block_begin - code_begin());
236     _strings.print_block_comment(stream, offset);
237   }
238 
239   // Transfer ownership of comments to this CodeBlob
240   void set_strings(CodeStrings&amp; strings) {
241     assert(!is_aot(), &quot;invalid on aot&quot;);
242     _strings.assign(strings);
243   }
244 
245   static ByteSize name_field_offset() {
246     return byte_offset_of(CodeBlob, _name);
247   }
248 
249   static ByteSize oop_maps_field_offset() {
250     return byte_offset_of(CodeBlob, _oop_maps);
251   }
252 };
</pre>
<hr />
<pre>
357   RuntimeBlob(
358     const char* name,
359     CodeBuffer* cb,
360     int         header_size,
361     int         size,
362     int         frame_complete,
363     int         frame_size,
364     OopMapSet*  oop_maps,
365     bool        caller_must_gc_arguments = false
366   );
367 
368   // GC support
369   virtual bool is_alive() const                  = 0;
370 
371   void verify();
372 
373   // OopMap for frame
374   virtual void preserve_callee_argument_oops(frame fr, const RegisterMap* reg_map, OopClosure* f)  { ShouldNotReachHere(); }
375 
376   // Debugging
<span class="line-removed">377   void print() const                             { print_on(tty); }</span>
378   virtual void print_on(outputStream* st) const { CodeBlob::print_on(st); }
379   virtual void print_value_on(outputStream* st) const { CodeBlob::print_value_on(st); }
380 
381   // Deal with Disassembler, VTune, Forte, JvmtiExport, MemoryService.
382   static void trace_new_stub(RuntimeBlob* blob, const char* name1, const char* name2 = &quot;&quot;);
383 };
384 
385 class WhiteBox;
386 //----------------------------------------------------------------------------------------------------
387 // BufferBlob: used to hold non-relocatable machine code such as the interpreter, stubroutines, etc.
388 
389 class BufferBlob: public RuntimeBlob {
390   friend class VMStructs;
391   friend class AdapterBlob;
392   friend class VtableBlob;
393   friend class MethodHandlesAdapterBlob;
394   friend class WhiteBox;
395 
396  private:
397   // Creation support
</pre>
</td>
<td>
<hr />
<pre>
130   virtual void flush();
131 
132   // Typing
133   virtual bool is_buffer_blob() const                 { return false; }
134   virtual bool is_nmethod() const                     { return false; }
135   virtual bool is_runtime_stub() const                { return false; }
136   virtual bool is_deoptimization_stub() const         { return false; }
137   virtual bool is_uncommon_trap_stub() const          { return false; }
138   virtual bool is_exception_stub() const              { return false; }
139   virtual bool is_safepoint_stub() const              { return false; }
140   virtual bool is_adapter_blob() const                { return false; }
141   virtual bool is_vtable_blob() const                 { return false; }
142   virtual bool is_method_handles_adapter_blob() const { return false; }
143   virtual bool is_aot() const                         { return false; }
144   virtual bool is_compiled() const                    { return false; }
145 
146   inline bool is_compiled_by_c1() const    { return _type == compiler_c1; };
147   inline bool is_compiled_by_c2() const    { return _type == compiler_c2; };
148   inline bool is_compiled_by_jvmci() const { return _type == compiler_jvmci; };
149   const char* compiler_name() const;
<span class="line-added">150   CompilerType compiler_type() const { return _type; }</span>
151 
152   // Casting
153   nmethod* as_nmethod_or_null()                { return is_nmethod() ? (nmethod*) this : NULL; }
154   nmethod* as_nmethod()                        { assert(is_nmethod(), &quot;must be nmethod&quot;); return (nmethod*) this; }
155   CompiledMethod* as_compiled_method_or_null() { return is_compiled() ? (CompiledMethod*) this : NULL; }
156   CompiledMethod* as_compiled_method()         { assert(is_compiled(), &quot;must be compiled&quot;); return (CompiledMethod*) this; }
157   CodeBlob* as_codeblob_or_null() const        { return (CodeBlob*) this; }
158 
159   // Boundaries
160   address header_begin() const        { return (address) this; }
161   relocInfo* relocation_begin() const { return (relocInfo*) _relocation_begin; };
162   relocInfo* relocation_end() const   { return (relocInfo*) _relocation_end; }
163   address content_begin() const       { return _content_begin; }
164   address content_end() const         { return _code_end; } // _code_end == _content_end is true for all types of blobs for now, it is also checked in the constructor
165   address code_begin() const          { return _code_begin;    }
166   address code_end() const            { return _code_end; }
167   address data_end() const            { return _data_end;      }
168 
169   // This field holds the beginning of the const section in the old code buffer.
170   // It is needed to fix relocations of pc-relative loads when resizing the
</pre>
<hr />
<pre>
195   int frame_complete_offset() const              { return _frame_complete_offset; }
196 
197   // CodeCache support: really only used by the nmethods, but in order to get
198   // asserts and certain bookkeeping to work in the CodeCache they are defined
199   // virtual here.
200   virtual bool is_zombie() const                 { return false; }
201   virtual bool is_locked_by_vm() const           { return false; }
202 
203   virtual bool is_unloaded() const               { return false; }
204   virtual bool is_not_entrant() const            { return false; }
205 
206   // GC support
207   virtual bool is_alive() const                  = 0;
208 
209   // OopMap for frame
210   ImmutableOopMapSet* oop_maps() const           { return _oop_maps; }
211   void set_oop_maps(OopMapSet* p);
212   const ImmutableOopMap* oop_map_for_return_address(address return_address);
213   virtual void preserve_callee_argument_oops(frame fr, const RegisterMap* reg_map, OopClosure* f) = 0;
214 
<span class="line-modified">215   // Frame support. Sizes are in word units.</span>
216   int  frame_size() const                        { return _frame_size; }
217   void set_frame_size(int size)                  { _frame_size = size; }
218 
219   // Returns true, if the next frame is responsible for GC&#39;ing oops passed as arguments
220   bool caller_must_gc_arguments(JavaThread* thread) const { return _caller_must_gc_arguments; }
221 
222   // Naming
223   const char* name() const                       { return _name; }
224   void set_name(const char* name)                { _name = name; }
225 
226   // Debugging
227   virtual void verify() = 0;
<span class="line-modified">228   virtual void print() const;</span>
229   virtual void print_on(outputStream* st) const;
230   virtual void print_value_on(outputStream* st) const;
231   void dump_for_addr(address addr, outputStream* st, bool verbose) const;
232   void print_code();
233 
<span class="line-added">234   bool has_block_comment(address block_begin) const {</span>
<span class="line-added">235     intptr_t offset = (intptr_t)(block_begin - code_begin());</span>
<span class="line-added">236     return _strings.has_block_comment(offset);</span>
<span class="line-added">237   }</span>
238   // Print the comment associated with offset on stream, if there is one
239   virtual void print_block_comment(outputStream* stream, address block_begin) const {
240     intptr_t offset = (intptr_t)(block_begin - code_begin());
241     _strings.print_block_comment(stream, offset);
242   }
243 
244   // Transfer ownership of comments to this CodeBlob
245   void set_strings(CodeStrings&amp; strings) {
246     assert(!is_aot(), &quot;invalid on aot&quot;);
247     _strings.assign(strings);
248   }
249 
250   static ByteSize name_field_offset() {
251     return byte_offset_of(CodeBlob, _name);
252   }
253 
254   static ByteSize oop_maps_field_offset() {
255     return byte_offset_of(CodeBlob, _oop_maps);
256   }
257 };
</pre>
<hr />
<pre>
362   RuntimeBlob(
363     const char* name,
364     CodeBuffer* cb,
365     int         header_size,
366     int         size,
367     int         frame_complete,
368     int         frame_size,
369     OopMapSet*  oop_maps,
370     bool        caller_must_gc_arguments = false
371   );
372 
373   // GC support
374   virtual bool is_alive() const                  = 0;
375 
376   void verify();
377 
378   // OopMap for frame
379   virtual void preserve_callee_argument_oops(frame fr, const RegisterMap* reg_map, OopClosure* f)  { ShouldNotReachHere(); }
380 
381   // Debugging

382   virtual void print_on(outputStream* st) const { CodeBlob::print_on(st); }
383   virtual void print_value_on(outputStream* st) const { CodeBlob::print_value_on(st); }
384 
385   // Deal with Disassembler, VTune, Forte, JvmtiExport, MemoryService.
386   static void trace_new_stub(RuntimeBlob* blob, const char* name1, const char* name2 = &quot;&quot;);
387 };
388 
389 class WhiteBox;
390 //----------------------------------------------------------------------------------------------------
391 // BufferBlob: used to hold non-relocatable machine code such as the interpreter, stubroutines, etc.
392 
393 class BufferBlob: public RuntimeBlob {
394   friend class VMStructs;
395   friend class AdapterBlob;
396   friend class VtableBlob;
397   friend class MethodHandlesAdapterBlob;
398   friend class WhiteBox;
399 
400  private:
401   // Creation support
</pre>
</td>
</tr>
</table>
<center><a href="codeBlob.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="codeCache.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
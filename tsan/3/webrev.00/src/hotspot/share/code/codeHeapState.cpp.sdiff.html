<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/code/codeHeapState.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="codeCache.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="codeHeapState.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/codeHeapState.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;code/codeHeapState.hpp&quot;
  28 #include &quot;compiler/compileBroker.hpp&quot;
  29 #include &quot;runtime/sweeper.hpp&quot;

  30 
  31 // -------------------------
  32 // |  General Description  |
  33 // -------------------------
  34 // The CodeHeap state analytics are divided in two parts.
  35 // The first part examines the entire CodeHeap and aggregates all
  36 // information that is believed useful/important.
  37 //
  38 // Aggregation condenses the information of a piece of the CodeHeap
  39 // (4096 bytes by default) into an analysis granule. These granules
  40 // contain enough detail to gain initial insight while keeping the
  41 // internal structure sizes in check.
  42 //
  43 // The second part, which consists of several, independent steps,
  44 // prints the previously collected information with emphasis on
  45 // various aspects.
  46 //
  47 // The CodeHeap is a living thing. Therefore, protection against concurrent
  48 // modification (by acquiring the CodeCache_lock) is necessary. It has
  49 // to be provided by the caller of the analysis functions.
</pre>
<hr />
<pre>
 107 //
 108 // To activate, #define USE_BUFFERED_STREAM before including this header.
 109 // If not activated, output will directly go to the originally used outputStream
 110 // with no additional overhead.
 111 //
 112 #if defined(USE_BUFFEREDSTREAM)
 113 // All necessary declarations to print via a bufferedStream
 114 // This macro must be placed before any other BUFFEREDSTREAM*
 115 // macro in the function.
 116 #define BUFFEREDSTREAM_DECL_SIZE(_anyst, _outst, _capa)       \
 117     ResourceMark         _rm;                                 \
 118     /* _anyst  name of the stream as used in the code */      \
 119     /* _outst  stream where final output will go to   */      \
 120     /* _capa   allocated capacity of stream buffer    */      \
 121     size_t           _nflush = 0;                             \
 122     size_t     _nforcedflush = 0;                             \
 123     size_t      _nsavedflush = 0;                             \
 124     size_t     _nlockedflush = 0;                             \
 125     size_t     _nflush_bytes = 0;                             \
 126     size_t         _capacity = _capa;                         \
<span class="line-modified"> 127     bufferedStream   _sstobj = bufferedStream(_capa);         \</span>
 128     bufferedStream*  _sstbuf = &amp;_sstobj;                      \
 129     outputStream*    _outbuf = _outst;                        \
 130     bufferedStream*   _anyst = &amp;_sstobj; /* any stream. Use this to just print - no buffer flush.  */
 131 
 132 // Same as above, but with fixed buffer size.
 133 #define BUFFEREDSTREAM_DECL(_anyst, _outst)                   \
 134     BUFFEREDSTREAM_DECL_SIZE(_anyst, _outst, 4*K);
 135 
 136 // Flush the buffer contents unconditionally.
 137 // No action if the buffer is empty.
 138 #define BUFFEREDSTREAM_FLUSH(_termString)                     \
 139     if (((_termString) != NULL) &amp;&amp; (strlen(_termString) &gt; 0)){\
 140       _sstbuf-&gt;print(&quot;%s&quot;, _termString);                      \
 141     }                                                         \
 142     if (_sstbuf != _outbuf) {                                 \
 143       if (_sstbuf-&gt;size() != 0) {                             \
 144         _nforcedflush++; _nflush_bytes += _sstbuf-&gt;size();    \
 145         _outbuf-&gt;print(&quot;%s&quot;, _sstbuf-&gt;as_string());           \
 146         _sstbuf-&gt;reset();                                     \
 147       }                                                       \
</pre>
<hr />
<pre>
 513 // This should be done after an analysis session is completed.
 514 void CodeHeapState::discard(outputStream* out, CodeHeap* heap) {
 515   if (!initialization_complete) {
 516     return;
 517   }
 518 
 519   if (nHeaps &gt; 0) {
 520     for (unsigned int ix = 0; ix &lt; nHeaps; ix++) {
 521       get_HeapStatGlobals(out, CodeHeapStatArray[ix].heapName);
 522       discard_StatArray(out);
 523       discard_FreeArray(out);
 524       discard_TopSizeArray(out);
 525       discard_SizeDistArray(out);
 526       set_HeapStatGlobals(out, CodeHeapStatArray[ix].heapName);
 527       CodeHeapStatArray[ix].heapName = NULL;
 528     }
 529     nHeaps = 0;
 530   }
 531 }
 532 
<span class="line-modified"> 533 void CodeHeapState::aggregate(outputStream* out, CodeHeap* heap, const char* granularity_request) {</span>
 534   unsigned int nBlocks_free    = 0;
 535   unsigned int nBlocks_used    = 0;
 536   unsigned int nBlocks_zomb    = 0;
 537   unsigned int nBlocks_disconn = 0;
 538   unsigned int nBlocks_notentr = 0;
 539 
 540   //---&lt;  max &amp; min of TopSizeArray  &gt;---
 541   //  it is sufficient to have these sizes as 32bit unsigned ints.
 542   //  The CodeHeap is limited in size to 4GB. Furthermore, the sizes
 543   //  are stored in _segment_size units, scaling them down by a factor of 64 (at least).
 544   unsigned int  currMax          = 0;
 545   unsigned int  currMin          = 0;
 546   unsigned int  currMin_ix       = 0;
 547   unsigned long total_iterations = 0;
 548 
 549   bool  done             = false;
 550   const int min_granules = 256;
 551   const int max_granules = 512*K; // limits analyzable CodeHeap (with segment_granules) to 32M..128M
 552                                   // results in StatArray size of 24M (= max_granules * 48 Bytes per element)
 553                                   // For a 1GB CodeHeap, the granule size must be at least 2kB to not violate the max_granles limit.
</pre>
<hr />
<pre>
 595   }
 596 
 597   // Calculate granularity of analysis (and output).
 598   //   The CodeHeap is managed (allocated) in segments (units) of CodeCacheSegmentSize.
 599   //   The CodeHeap can become fairly large, in particular in productive real-life systems.
 600   //
 601   //   It is often neither feasible nor desirable to aggregate the data with the highest possible
 602   //   level of detail, i.e. inspecting and printing each segment on its own.
 603   //
 604   //   The granularity parameter allows to specify the level of detail available in the analysis.
 605   //   It must be a positive multiple of the segment size and should be selected such that enough
 606   //   detail is provided while, at the same time, the printed output does not explode.
 607   //
 608   //   By manipulating the granularity value, we enforce that at least min_granules units
 609   //   of analysis are available. We also enforce an upper limit of max_granules units to
 610   //   keep the amount of allocated storage in check.
 611   //
 612   //   Finally, we adjust the granularity such that each granule covers at most 64k-1 segments.
 613   //   This is necessary to prevent an unsigned short overflow while accumulating space information.
 614   //
<span class="line-modified"> 615   size_t granularity = strtol(granularity_request, NULL, 0);</span>

 616   if (granularity &gt; size) {
 617     granularity = size;
 618   }
 619   if (size/granularity &lt; min_granules) {
 620     granularity = size/min_granules;                                   // at least min_granules granules
 621   }
 622   granularity = granularity &amp; (~(seg_size - 1));                       // must be multiple of seg_size
 623   if (granularity &lt; seg_size) {
 624     granularity = seg_size;                                            // must be at least seg_size
 625   }
 626   if (size/granularity &gt; max_granules) {
 627     granularity = size/max_granules;                                   // at most max_granules granules
 628   }
 629   granularity = granularity &amp; (~(seg_size - 1));                       // must be multiple of seg_size
 630   if (granularity&gt;&gt;log2_seg_size &gt;= (1L&lt;&lt;sizeof(unsigned short)*8)) {
 631     granularity = ((1L&lt;&lt;(sizeof(unsigned short)*8))-1)&lt;&lt;log2_seg_size; // Limit: (64k-1) * seg_size
 632   }
 633   segment_granules = granularity == seg_size;
 634   size_t granules  = (size + (granularity-1))/granularity;
 635 
</pre>
</td>
<td>
<hr />
<pre>
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;code/codeHeapState.hpp&quot;
  28 #include &quot;compiler/compileBroker.hpp&quot;
  29 #include &quot;runtime/sweeper.hpp&quot;
<span class="line-added">  30 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  31 
  32 // -------------------------
  33 // |  General Description  |
  34 // -------------------------
  35 // The CodeHeap state analytics are divided in two parts.
  36 // The first part examines the entire CodeHeap and aggregates all
  37 // information that is believed useful/important.
  38 //
  39 // Aggregation condenses the information of a piece of the CodeHeap
  40 // (4096 bytes by default) into an analysis granule. These granules
  41 // contain enough detail to gain initial insight while keeping the
  42 // internal structure sizes in check.
  43 //
  44 // The second part, which consists of several, independent steps,
  45 // prints the previously collected information with emphasis on
  46 // various aspects.
  47 //
  48 // The CodeHeap is a living thing. Therefore, protection against concurrent
  49 // modification (by acquiring the CodeCache_lock) is necessary. It has
  50 // to be provided by the caller of the analysis functions.
</pre>
<hr />
<pre>
 108 //
 109 // To activate, #define USE_BUFFERED_STREAM before including this header.
 110 // If not activated, output will directly go to the originally used outputStream
 111 // with no additional overhead.
 112 //
 113 #if defined(USE_BUFFEREDSTREAM)
 114 // All necessary declarations to print via a bufferedStream
 115 // This macro must be placed before any other BUFFEREDSTREAM*
 116 // macro in the function.
 117 #define BUFFEREDSTREAM_DECL_SIZE(_anyst, _outst, _capa)       \
 118     ResourceMark         _rm;                                 \
 119     /* _anyst  name of the stream as used in the code */      \
 120     /* _outst  stream where final output will go to   */      \
 121     /* _capa   allocated capacity of stream buffer    */      \
 122     size_t           _nflush = 0;                             \
 123     size_t     _nforcedflush = 0;                             \
 124     size_t      _nsavedflush = 0;                             \
 125     size_t     _nlockedflush = 0;                             \
 126     size_t     _nflush_bytes = 0;                             \
 127     size_t         _capacity = _capa;                         \
<span class="line-modified"> 128     bufferedStream   _sstobj(_capa);                          \</span>
 129     bufferedStream*  _sstbuf = &amp;_sstobj;                      \
 130     outputStream*    _outbuf = _outst;                        \
 131     bufferedStream*   _anyst = &amp;_sstobj; /* any stream. Use this to just print - no buffer flush.  */
 132 
 133 // Same as above, but with fixed buffer size.
 134 #define BUFFEREDSTREAM_DECL(_anyst, _outst)                   \
 135     BUFFEREDSTREAM_DECL_SIZE(_anyst, _outst, 4*K);
 136 
 137 // Flush the buffer contents unconditionally.
 138 // No action if the buffer is empty.
 139 #define BUFFEREDSTREAM_FLUSH(_termString)                     \
 140     if (((_termString) != NULL) &amp;&amp; (strlen(_termString) &gt; 0)){\
 141       _sstbuf-&gt;print(&quot;%s&quot;, _termString);                      \
 142     }                                                         \
 143     if (_sstbuf != _outbuf) {                                 \
 144       if (_sstbuf-&gt;size() != 0) {                             \
 145         _nforcedflush++; _nflush_bytes += _sstbuf-&gt;size();    \
 146         _outbuf-&gt;print(&quot;%s&quot;, _sstbuf-&gt;as_string());           \
 147         _sstbuf-&gt;reset();                                     \
 148       }                                                       \
</pre>
<hr />
<pre>
 514 // This should be done after an analysis session is completed.
 515 void CodeHeapState::discard(outputStream* out, CodeHeap* heap) {
 516   if (!initialization_complete) {
 517     return;
 518   }
 519 
 520   if (nHeaps &gt; 0) {
 521     for (unsigned int ix = 0; ix &lt; nHeaps; ix++) {
 522       get_HeapStatGlobals(out, CodeHeapStatArray[ix].heapName);
 523       discard_StatArray(out);
 524       discard_FreeArray(out);
 525       discard_TopSizeArray(out);
 526       discard_SizeDistArray(out);
 527       set_HeapStatGlobals(out, CodeHeapStatArray[ix].heapName);
 528       CodeHeapStatArray[ix].heapName = NULL;
 529     }
 530     nHeaps = 0;
 531   }
 532 }
 533 
<span class="line-modified"> 534 void CodeHeapState::aggregate(outputStream* out, CodeHeap* heap, size_t granularity) {</span>
 535   unsigned int nBlocks_free    = 0;
 536   unsigned int nBlocks_used    = 0;
 537   unsigned int nBlocks_zomb    = 0;
 538   unsigned int nBlocks_disconn = 0;
 539   unsigned int nBlocks_notentr = 0;
 540 
 541   //---&lt;  max &amp; min of TopSizeArray  &gt;---
 542   //  it is sufficient to have these sizes as 32bit unsigned ints.
 543   //  The CodeHeap is limited in size to 4GB. Furthermore, the sizes
 544   //  are stored in _segment_size units, scaling them down by a factor of 64 (at least).
 545   unsigned int  currMax          = 0;
 546   unsigned int  currMin          = 0;
 547   unsigned int  currMin_ix       = 0;
 548   unsigned long total_iterations = 0;
 549 
 550   bool  done             = false;
 551   const int min_granules = 256;
 552   const int max_granules = 512*K; // limits analyzable CodeHeap (with segment_granules) to 32M..128M
 553                                   // results in StatArray size of 24M (= max_granules * 48 Bytes per element)
 554                                   // For a 1GB CodeHeap, the granule size must be at least 2kB to not violate the max_granles limit.
</pre>
<hr />
<pre>
 596   }
 597 
 598   // Calculate granularity of analysis (and output).
 599   //   The CodeHeap is managed (allocated) in segments (units) of CodeCacheSegmentSize.
 600   //   The CodeHeap can become fairly large, in particular in productive real-life systems.
 601   //
 602   //   It is often neither feasible nor desirable to aggregate the data with the highest possible
 603   //   level of detail, i.e. inspecting and printing each segment on its own.
 604   //
 605   //   The granularity parameter allows to specify the level of detail available in the analysis.
 606   //   It must be a positive multiple of the segment size and should be selected such that enough
 607   //   detail is provided while, at the same time, the printed output does not explode.
 608   //
 609   //   By manipulating the granularity value, we enforce that at least min_granules units
 610   //   of analysis are available. We also enforce an upper limit of max_granules units to
 611   //   keep the amount of allocated storage in check.
 612   //
 613   //   Finally, we adjust the granularity such that each granule covers at most 64k-1 segments.
 614   //   This is necessary to prevent an unsigned short overflow while accumulating space information.
 615   //
<span class="line-modified"> 616   assert(granularity &gt; 0, &quot;granularity should be positive.&quot;);</span>
<span class="line-added"> 617 </span>
 618   if (granularity &gt; size) {
 619     granularity = size;
 620   }
 621   if (size/granularity &lt; min_granules) {
 622     granularity = size/min_granules;                                   // at least min_granules granules
 623   }
 624   granularity = granularity &amp; (~(seg_size - 1));                       // must be multiple of seg_size
 625   if (granularity &lt; seg_size) {
 626     granularity = seg_size;                                            // must be at least seg_size
 627   }
 628   if (size/granularity &gt; max_granules) {
 629     granularity = size/max_granules;                                   // at most max_granules granules
 630   }
 631   granularity = granularity &amp; (~(seg_size - 1));                       // must be multiple of seg_size
 632   if (granularity&gt;&gt;log2_seg_size &gt;= (1L&lt;&lt;sizeof(unsigned short)*8)) {
 633     granularity = ((1L&lt;&lt;(sizeof(unsigned short)*8))-1)&lt;&lt;log2_seg_size; // Limit: (64k-1) * seg_size
 634   }
 635   segment_granules = granularity == seg_size;
 636   size_t granules  = (size + (granularity-1))/granularity;
 637 
</pre>
</td>
</tr>
</table>
<center><a href="codeCache.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="codeHeapState.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/tsan/tsanOopMap.cpp b/src/hotspot/share/tsan/tsanOopMap.cpp
--- a/src/hotspot/share/tsan/tsanOopMap.cpp
+++ b/src/hotspot/share/tsan/tsanOopMap.cpp
@@ -282,11 +282,11 @@
     size_t total_size_words = 0;
     CollectedHeap *heap = Universe::heap();
     for (size_t i = 0; i < map_size; i++) {
       oopDesc *source_obj = oop_map->oop_at(i);
 
-      if (source_obj != NULL && heap->is_in_reserved(source_obj)) {
+      if (source_obj != NULL && heap->is_in(source_obj)) {
         uintx obj_size = oop_map->oop_size_at(i);
         size_t obj_size_bytes = obj_size * HeapWordSize;
         if (is_alive->do_object_b(source_obj)) {
           // The object survived GC, add its updated oop to the new oops map.
           oop target_oop = cast_to_oop((intptr_t)source_obj);
@@ -296,11 +296,11 @@
           // first, then compacts and moves the objects. In this case
           // TsanOopSizeMap::rebuild_oops_map() is called during the adjust-
           // pointer phase, before the collector moves the objects. Thus,
           // we cannot use heap->is_in() or oopDesc::is_oop() to check
           // target_oop.
-          assert(heap->is_in_reserved(target_oop), "Adjustment failed");
+          assert(heap->is_in(target_oop), "Adjustment failed");
           oopDesc *target_obj = target_oop;
           new_map->put(target_obj, obj_size);
           if (target_obj == source_obj) {
             ++unmoved_objects;
             continue;
@@ -506,11 +506,11 @@
   DEBUG_ONLY(NoSafepointVerifier nsv;)
   assert(TsanOopMapImpl::oop_map != NULL, "TsanOopMap not initialized");
   guarantee(addr != NULL, "null oop");
   bool alloc = false;
   {
-    MutexLockerEx mu(TsanOopMap_lock, Mutex::_no_safepoint_check_flag);
+    MutexLocker mu(TsanOopMap_lock, Mutex::_no_safepoint_check_flag);
     // N.B. addr->size() may not be available yet!
     alloc = TsanOopMapImpl::oop_map->put(addr, size);
   }
   if (alloc) {
     __tsan_java_alloc(addr, size * HeapWordSize);
@@ -527,11 +527,11 @@
   DEBUG_ONLY(NoSafepointVerifier nsv;)
   assert(TsanOopMapImpl::oop_map != NULL, "TsanOopMap not initialized");
   guarantee(addr != NULL, "null oop");
   bool in_map = false;
   {
-    MutexLockerEx mu(TsanOopMap_lock, Mutex::_no_safepoint_check_flag);
+    MutexLocker mu(TsanOopMap_lock, Mutex::_no_safepoint_check_flag);
     in_map = TsanOopMapImpl::oop_map->exists(addr);
   }
   return in_map;
 }
 #endif

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/tsan/tsanOopMap.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="tsan.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../utilities/accessFlags.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/tsan/tsanOopMap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
267 
268     // Traverse oop map. For each object that survived GC calculate its new
269     // oop, add it to the new oop map, and append the move from the source oop
270     // to the target one to the moves list. While doing that, collect oop
271     // source and target ranges and count the moves that move an object
272     // downwards (this is heuristics to order the moves, see below).
273     TsanOopSizeMap* new_map = new TsanOopSizeMap(map_size / 2);
274     *n_downward_moves = 0;
275     bool disjoint_regions;
276     char *source_low = reinterpret_cast&lt;char *&gt;(UINTPTR_MAX);
277     char *source_high = NULL;
278     char *target_low = reinterpret_cast&lt;char *&gt;(UINTPTR_MAX);
279     char *target_high = NULL;
280     size_t deleted_objects = 0;
281     size_t unmoved_objects = 0;
282     size_t total_size_words = 0;
283     CollectedHeap *heap = Universe::heap();
284     for (size_t i = 0; i &lt; map_size; i++) {
285       oopDesc *source_obj = oop_map-&gt;oop_at(i);
286 
<span class="line-modified">287       if (source_obj != NULL &amp;&amp; heap-&gt;is_in_reserved(source_obj)) {</span>
288         uintx obj_size = oop_map-&gt;oop_size_at(i);
289         size_t obj_size_bytes = obj_size * HeapWordSize;
290         if (is_alive-&gt;do_object_b(source_obj)) {
291           // The object survived GC, add its updated oop to the new oops map.
292           oop target_oop = cast_to_oop((intptr_t)source_obj);
293           pointer_adjuster-&gt;do_oop(&amp;target_oop);
294           // The memory pointed by target_oop may not be a valid oop yet,
295           // for example the G1 full collector needs to adjust all pointers
296           // first, then compacts and moves the objects. In this case
297           // TsanOopSizeMap::rebuild_oops_map() is called during the adjust-
298           // pointer phase, before the collector moves the objects. Thus,
299           // we cannot use heap-&gt;is_in() or oopDesc::is_oop() to check
300           // target_oop.
<span class="line-modified">301           assert(heap-&gt;is_in_reserved(target_oop), &quot;Adjustment failed&quot;);</span>
302           oopDesc *target_obj = target_oop;
303           new_map-&gt;put(target_obj, obj_size);
304           if (target_obj == source_obj) {
305             ++unmoved_objects;
306             continue;
307           }
308           if (target_obj &lt; source_obj) {
309             ++(*n_downward_moves);
310           }
311           // Append to the moves list.
312           PendingMove move = {(char *)source_obj, (char *)target_obj,
313                               obj_size_bytes};
314           total_size_words += obj_size;
315           moves-&gt;append(move);
316 
317           // Update source and target ranges.
318           source_low = MIN2(source_low, move.source_begin());
319           source_high = MAX2(source_high, move.source_end());
320           target_low = MIN2(target_low, move.target_begin());
321           target_high = MAX2(target_high, move.target_end());
</pre>
<hr />
<pre>
491 
492   // We&#39;re mutating oopMap, but we don&#39;t need to acquire TsanOopMap_lock:
493   // Mutation to map happens at (A) constructor (single threaded) and
494   // (B) add (in mutator threads) and (C) do_weak_oops (single-threaded).
495   // Calls between add are synchronized.
496   // Calls between add and do_weak_oops are synchronized via STW GC.
497   TsanOopMapImpl::TsanOopSizeMap::rebuild_oops_map(
498       is_alive, pointer_adjuster);
499 }
500 
501 // Safe to deal with raw oop; for example this is called in a LEAF function
502 // There is no safepoint in this code: 1) special mutex is used, and
503 // 2) there is no VM state transition
504 // We cannot use ordinary VM mutex, as that requires a state transition.
505 void TsanOopMap::add_oop_with_size(oopDesc *addr, int size) {
506   DEBUG_ONLY(NoSafepointVerifier nsv;)
507   assert(TsanOopMapImpl::oop_map != NULL, &quot;TsanOopMap not initialized&quot;);
508   guarantee(addr != NULL, &quot;null oop&quot;);
509   bool alloc = false;
510   {
<span class="line-modified">511     MutexLockerEx mu(TsanOopMap_lock, Mutex::_no_safepoint_check_flag);</span>
512     // N.B. addr-&gt;size() may not be available yet!
513     alloc = TsanOopMapImpl::oop_map-&gt;put(addr, size);
514   }
515   if (alloc) {
516     __tsan_java_alloc(addr, size * HeapWordSize);
517   }
518 }
519 
520 void TsanOopMap::add_oop(oopDesc *addr) {
521   // N.B. oop&#39;s size field must be init&#39;ed; else addr-&gt;size() crashes.
522   TsanOopMap::add_oop_with_size(addr, addr-&gt;size());
523 }
524 
525 #ifdef ASSERT
526 bool TsanOopMap::exists(oopDesc *addr) {
527   DEBUG_ONLY(NoSafepointVerifier nsv;)
528   assert(TsanOopMapImpl::oop_map != NULL, &quot;TsanOopMap not initialized&quot;);
529   guarantee(addr != NULL, &quot;null oop&quot;);
530   bool in_map = false;
531   {
<span class="line-modified">532     MutexLockerEx mu(TsanOopMap_lock, Mutex::_no_safepoint_check_flag);</span>
533     in_map = TsanOopMapImpl::oop_map-&gt;exists(addr);
534   }
535   return in_map;
536 }
537 #endif
</pre>
</td>
<td>
<hr />
<pre>
267 
268     // Traverse oop map. For each object that survived GC calculate its new
269     // oop, add it to the new oop map, and append the move from the source oop
270     // to the target one to the moves list. While doing that, collect oop
271     // source and target ranges and count the moves that move an object
272     // downwards (this is heuristics to order the moves, see below).
273     TsanOopSizeMap* new_map = new TsanOopSizeMap(map_size / 2);
274     *n_downward_moves = 0;
275     bool disjoint_regions;
276     char *source_low = reinterpret_cast&lt;char *&gt;(UINTPTR_MAX);
277     char *source_high = NULL;
278     char *target_low = reinterpret_cast&lt;char *&gt;(UINTPTR_MAX);
279     char *target_high = NULL;
280     size_t deleted_objects = 0;
281     size_t unmoved_objects = 0;
282     size_t total_size_words = 0;
283     CollectedHeap *heap = Universe::heap();
284     for (size_t i = 0; i &lt; map_size; i++) {
285       oopDesc *source_obj = oop_map-&gt;oop_at(i);
286 
<span class="line-modified">287       if (source_obj != NULL &amp;&amp; heap-&gt;is_in(source_obj)) {</span>
288         uintx obj_size = oop_map-&gt;oop_size_at(i);
289         size_t obj_size_bytes = obj_size * HeapWordSize;
290         if (is_alive-&gt;do_object_b(source_obj)) {
291           // The object survived GC, add its updated oop to the new oops map.
292           oop target_oop = cast_to_oop((intptr_t)source_obj);
293           pointer_adjuster-&gt;do_oop(&amp;target_oop);
294           // The memory pointed by target_oop may not be a valid oop yet,
295           // for example the G1 full collector needs to adjust all pointers
296           // first, then compacts and moves the objects. In this case
297           // TsanOopSizeMap::rebuild_oops_map() is called during the adjust-
298           // pointer phase, before the collector moves the objects. Thus,
299           // we cannot use heap-&gt;is_in() or oopDesc::is_oop() to check
300           // target_oop.
<span class="line-modified">301           assert(heap-&gt;is_in(target_oop), &quot;Adjustment failed&quot;);</span>
302           oopDesc *target_obj = target_oop;
303           new_map-&gt;put(target_obj, obj_size);
304           if (target_obj == source_obj) {
305             ++unmoved_objects;
306             continue;
307           }
308           if (target_obj &lt; source_obj) {
309             ++(*n_downward_moves);
310           }
311           // Append to the moves list.
312           PendingMove move = {(char *)source_obj, (char *)target_obj,
313                               obj_size_bytes};
314           total_size_words += obj_size;
315           moves-&gt;append(move);
316 
317           // Update source and target ranges.
318           source_low = MIN2(source_low, move.source_begin());
319           source_high = MAX2(source_high, move.source_end());
320           target_low = MIN2(target_low, move.target_begin());
321           target_high = MAX2(target_high, move.target_end());
</pre>
<hr />
<pre>
491 
492   // We&#39;re mutating oopMap, but we don&#39;t need to acquire TsanOopMap_lock:
493   // Mutation to map happens at (A) constructor (single threaded) and
494   // (B) add (in mutator threads) and (C) do_weak_oops (single-threaded).
495   // Calls between add are synchronized.
496   // Calls between add and do_weak_oops are synchronized via STW GC.
497   TsanOopMapImpl::TsanOopSizeMap::rebuild_oops_map(
498       is_alive, pointer_adjuster);
499 }
500 
501 // Safe to deal with raw oop; for example this is called in a LEAF function
502 // There is no safepoint in this code: 1) special mutex is used, and
503 // 2) there is no VM state transition
504 // We cannot use ordinary VM mutex, as that requires a state transition.
505 void TsanOopMap::add_oop_with_size(oopDesc *addr, int size) {
506   DEBUG_ONLY(NoSafepointVerifier nsv;)
507   assert(TsanOopMapImpl::oop_map != NULL, &quot;TsanOopMap not initialized&quot;);
508   guarantee(addr != NULL, &quot;null oop&quot;);
509   bool alloc = false;
510   {
<span class="line-modified">511     MutexLocker mu(TsanOopMap_lock, Mutex::_no_safepoint_check_flag);</span>
512     // N.B. addr-&gt;size() may not be available yet!
513     alloc = TsanOopMapImpl::oop_map-&gt;put(addr, size);
514   }
515   if (alloc) {
516     __tsan_java_alloc(addr, size * HeapWordSize);
517   }
518 }
519 
520 void TsanOopMap::add_oop(oopDesc *addr) {
521   // N.B. oop&#39;s size field must be init&#39;ed; else addr-&gt;size() crashes.
522   TsanOopMap::add_oop_with_size(addr, addr-&gt;size());
523 }
524 
525 #ifdef ASSERT
526 bool TsanOopMap::exists(oopDesc *addr) {
527   DEBUG_ONLY(NoSafepointVerifier nsv;)
528   assert(TsanOopMapImpl::oop_map != NULL, &quot;TsanOopMap not initialized&quot;);
529   guarantee(addr != NULL, &quot;null oop&quot;);
530   bool in_map = false;
531   {
<span class="line-modified">532     MutexLocker mu(TsanOopMap_lock, Mutex::_no_safepoint_check_flag);</span>
533     in_map = TsanOopMapImpl::oop_map-&gt;exists(addr);
534   }
535   return in_map;
536 }
537 #endif
</pre>
</td>
</tr>
</table>
<center><a href="tsan.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../utilities/accessFlags.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
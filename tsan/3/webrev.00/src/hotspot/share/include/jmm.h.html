<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/include/jmm.h</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef _JAVA_JMM_H_
 27 #define _JAVA_JMM_H_
 28 
 29 /*
 30  * This is a private interface used by JDK for JVM monitoring
 31  * and management.
 32  *
 33  * Bump the version number when either of the following happens:
 34  *
 35  * 1. There is a change in functions in JmmInterface.
 36  *
 37  * 2. There is a change in the contract between VM and Java classes.
 38  */
 39 
 40 #include &quot;jni.h&quot;
 41 
 42 #ifdef __cplusplus
 43 extern &quot;C&quot; {
 44 #endif
 45 
 46 enum {
 47   JMM_VERSION_1   = 0x20010000,
 48   JMM_VERSION_1_0 = 0x20010000,
 49   JMM_VERSION_1_1 = 0x20010100, // JDK 6
 50   JMM_VERSION_1_2 = 0x20010200, // JDK 7
 51   JMM_VERSION_1_2_1 = 0x20010201, // JDK 7 GA
 52   JMM_VERSION_1_2_2 = 0x20010202,
 53   JMM_VERSION_2   = 0x20020000, // JDK 10
 54   JMM_VERSION_3   = 0x20030000, // JDK 14
 55   JMM_VERSION     = JMM_VERSION_3
 56 };
 57 
 58 typedef struct {
 59   unsigned int isLowMemoryDetectionSupported : 1;
 60   unsigned int isCompilationTimeMonitoringSupported : 1;
 61   unsigned int isThreadContentionMonitoringSupported : 1;
 62   unsigned int isCurrentThreadCpuTimeSupported : 1;
 63   unsigned int isOtherThreadCpuTimeSupported : 1;
 64   unsigned int isObjectMonitorUsageSupported : 1;
 65   unsigned int isSynchronizerUsageSupported : 1;
 66   unsigned int isThreadAllocatedMemorySupported : 1;
 67   unsigned int isRemoteDiagnosticCommandsSupported : 1;
 68   unsigned int : 22;
 69 } jmmOptionalSupport;
 70 
 71 typedef enum {
 72   JMM_CLASS_LOADED_COUNT             = 1,    /* Total number of loaded classes */
 73   JMM_CLASS_UNLOADED_COUNT           = 2,    /* Total number of unloaded classes */
 74   JMM_THREAD_TOTAL_COUNT             = 3,    /* Total number of threads that have been started */
 75   JMM_THREAD_LIVE_COUNT              = 4,    /* Current number of live threads */
 76   JMM_THREAD_PEAK_COUNT              = 5,    /* Peak number of live threads */
 77   JMM_THREAD_DAEMON_COUNT            = 6,    /* Current number of daemon threads */
 78   JMM_JVM_INIT_DONE_TIME_MS          = 7,    /* Time when the JVM finished initialization */
 79   JMM_COMPILE_TOTAL_TIME_MS          = 8,    /* Total accumulated time spent in compilation */
 80   JMM_GC_TIME_MS                     = 9,    /* Total accumulated time spent in collection */
 81   JMM_GC_COUNT                       = 10,   /* Total number of collections */
 82   JMM_JVM_UPTIME_MS                  = 11,   /* The JVM uptime in milliseconds */
 83 
 84   JMM_INTERNAL_ATTRIBUTE_INDEX       = 100,
 85   JMM_CLASS_LOADED_BYTES             = 101,  /* Number of bytes loaded instance classes */
 86   JMM_CLASS_UNLOADED_BYTES           = 102,  /* Number of bytes unloaded instance classes */
 87   JMM_TOTAL_CLASSLOAD_TIME_MS        = 103,  /* Accumulated VM class loader time (TraceClassLoadingTime) */
 88   JMM_VM_GLOBAL_COUNT                = 104,  /* Number of VM internal flags */
 89   JMM_SAFEPOINT_COUNT                = 105,  /* Total number of safepoints */
 90   JMM_TOTAL_SAFEPOINTSYNC_TIME_MS    = 106,  /* Accumulated time spent getting to safepoints */
 91   JMM_TOTAL_STOPPED_TIME_MS          = 107,  /* Accumulated time spent at safepoints */
 92   JMM_TOTAL_APP_TIME_MS              = 108,  /* Accumulated time spent in Java application */
 93   JMM_VM_THREAD_COUNT                = 109,  /* Current number of VM internal threads */
 94   JMM_CLASS_INIT_TOTAL_COUNT         = 110,  /* Number of classes for which initializers were run */
 95   JMM_CLASS_INIT_TOTAL_TIME_MS       = 111,  /* Accumulated time spent in class initializers */
 96   JMM_METHOD_DATA_SIZE_BYTES         = 112,  /* Size of method data in memory */
 97   JMM_CLASS_VERIFY_TOTAL_TIME_MS     = 113,  /* Accumulated time spent in class verifier */
 98   JMM_SHARED_CLASS_LOADED_COUNT      = 114,  /* Number of shared classes loaded */
 99   JMM_SHARED_CLASS_UNLOADED_COUNT    = 115,  /* Number of shared classes unloaded */
100   JMM_SHARED_CLASS_LOADED_BYTES      = 116,  /* Number of bytes loaded shared classes */
101   JMM_SHARED_CLASS_UNLOADED_BYTES    = 117,  /* Number of bytes unloaded shared classes */
102 
103   JMM_OS_ATTRIBUTE_INDEX             = 200,
104   JMM_OS_PROCESS_ID                  = 201,  /* Process id of the JVM */
105   JMM_OS_MEM_TOTAL_PHYSICAL_BYTES    = 202,  /* Physical memory size */
106 
107   JMM_GC_EXT_ATTRIBUTE_INFO_SIZE     = 401   /* the size of the GC specific attributes for a given GC memory manager */
108 } jmmLongAttribute;
109 
110 typedef enum {
111   JMM_VERBOSE_GC                     = 21,
112   JMM_VERBOSE_CLASS                  = 22,
113   JMM_THREAD_CONTENTION_MONITORING   = 23,
114   JMM_THREAD_CPU_TIME                = 24,
115   JMM_THREAD_ALLOCATED_MEMORY        = 25
116 } jmmBoolAttribute;
117 
118 
119 enum {
120   JMM_THREAD_STATE_FLAG_SUSPENDED = 0x00100000,
121   JMM_THREAD_STATE_FLAG_NATIVE    = 0x00400000
122 };
123 
124 #define JMM_THREAD_STATE_FLAG_MASK  0xFFF00000
125 
126 typedef enum {
127   JMM_STAT_PEAK_THREAD_COUNT         = 801,
128   JMM_STAT_THREAD_CONTENTION_COUNT   = 802,
129   JMM_STAT_THREAD_CONTENTION_TIME    = 803,
130   JMM_STAT_THREAD_CONTENTION_STAT    = 804,
131   JMM_STAT_PEAK_POOL_USAGE           = 805,
132   JMM_STAT_GC_STAT                   = 806
133 } jmmStatisticType;
134 
135 typedef enum {
136   JMM_USAGE_THRESHOLD_HIGH            = 901,
137   JMM_USAGE_THRESHOLD_LOW             = 902,
138   JMM_COLLECTION_USAGE_THRESHOLD_HIGH = 903,
139   JMM_COLLECTION_USAGE_THRESHOLD_LOW  = 904
140 } jmmThresholdType;
141 
142 /* Should match what is allowed in globals.hpp */
143 typedef enum {
144   JMM_VMGLOBAL_TYPE_UNKNOWN  = 0,
145   JMM_VMGLOBAL_TYPE_JBOOLEAN = 1,
146   JMM_VMGLOBAL_TYPE_JSTRING  = 2,
147   JMM_VMGLOBAL_TYPE_JLONG    = 3,
148   JMM_VMGLOBAL_TYPE_JDOUBLE  = 4
149 } jmmVMGlobalType;
150 
151 typedef enum {
152   JMM_VMGLOBAL_ORIGIN_DEFAULT      = 1,   /* Default value */
153   JMM_VMGLOBAL_ORIGIN_COMMAND_LINE = 2,   /* Set at command line (or JNI invocation) */
154   JMM_VMGLOBAL_ORIGIN_MANAGEMENT   = 3,   /* Set via management interface */
155   JMM_VMGLOBAL_ORIGIN_ENVIRON_VAR  = 4,   /* Set via environment variables */
156   JMM_VMGLOBAL_ORIGIN_CONFIG_FILE  = 5,   /* Set via config file (such as .hotspotrc) */
157   JMM_VMGLOBAL_ORIGIN_ERGONOMIC    = 6,   /* Set via ergonomic */
158   JMM_VMGLOBAL_ORIGIN_ATTACH_ON_DEMAND = 7,   /* Set via attach */
159   JMM_VMGLOBAL_ORIGIN_OTHER        = 99   /* Set via some other mechanism */
160 } jmmVMGlobalOrigin;
161 
162 typedef struct {
163   jstring           name;
164   jvalue            value;
165   jmmVMGlobalType   type;           /* Data type */
166   jmmVMGlobalOrigin origin;         /* Default or non-default value */
167   unsigned int      writeable : 1;  /* dynamically writeable */
168   unsigned int      external  : 1;  /* external supported interface */
169   unsigned int      reserved  : 30;
170   void *reserved1;
171   void *reserved2;
172 } jmmVMGlobal;
173 
174 typedef struct {
175   const char*  name;
176   char         type;
177   const char*  description;
178 } jmmExtAttributeInfo;
179 
180 /* Caller has to set the following fields before calling GetLastGCStat
181  *   o usage_before_gc               - array of MemoryUsage objects
182  *   o usage_after_gc                - array of MemoryUsage objects
183  *   o gc_ext_attribute_values_size - size of gc_ext_atttribute_values array
184  *   o gc_ext_attribtue_values      - array of jvalues
185  */
186 typedef struct {
187   jlong        gc_index;                       /* Index of the collections */
188   jlong        start_time;                     /* Start time of the GC */
189   jlong        end_time;                       /* End time of the GC */
190   jobjectArray usage_before_gc;                /* Memory usage array before GC */
191   jobjectArray usage_after_gc;                 /* Memory usage array after GC */
192   jint         gc_ext_attribute_values_size;   /* set by the caller of GetGCStat */
193   jvalue*      gc_ext_attribute_values;        /* Array of jvalue for GC extension attributes */
194   jint         num_gc_ext_attributes;          /* number of GC extension attribute values s are filled */
195                                                /* -1 indicates gc_ext_attribute_values is not big enough */
196 } jmmGCStat;
197 
198 typedef struct {
199   const char* name;                /* Name of the diagnostic command */
200   const char* description;         /* Short description */
201   const char* impact;              /* Impact on the JVM */
202   const char* permission_class;    /* Class name of the required permission if any */
203   const char* permission_name;     /* Permission name of the required permission if any */
204   const char* permission_action;   /* Action name of the required permission if any*/
205   int         num_arguments;       /* Number of supported options or arguments */
206   jboolean    enabled;             /* True if the diagnostic command can be invoked, false otherwise*/
207 } dcmdInfo;
208 
209 typedef struct {
210   const char* name;                /* Option/Argument name*/
211   const char* description;         /* Short description */
212   const char* type;                /* Type: STRING, BOOLEAN, etc. */
213   const char* default_string;      /* Default value in a parsable string */
214   jboolean    mandatory;           /* True if the option/argument is mandatory */
215   jboolean    option;              /* True if it is an option, false if it is an argument */
216                                    /* (see diagnosticFramework.hpp for option/argument definitions) */
217   jboolean    multiple;            /* True is the option can be specified several time */
218   int         position;            /* Expected position for this argument (this field is */
219                                    /* meaningless for options) */
220 } dcmdArgInfo;
221 
222 typedef struct jmmInterface_1_ {
223   void*        reserved1;
224   void*        reserved2;
225 
226   jint         (JNICALL *GetVersion)             (JNIEnv *env);
227 
228   jint         (JNICALL *GetOptionalSupport)     (JNIEnv *env,
229                                                   jmmOptionalSupport* support_ptr);
230 
231   jint         (JNICALL *GetThreadInfo)          (JNIEnv *env,
232                                                   jlongArray ids,
233                                                   jint maxDepth,
234                                                   jobjectArray infoArray);
235 
236   jobjectArray (JNICALL *GetMemoryPools)         (JNIEnv* env, jobject mgr);
237 
238   jobjectArray (JNICALL *GetMemoryManagers)      (JNIEnv* env, jobject pool);
239 
240   jobject      (JNICALL *GetMemoryPoolUsage)     (JNIEnv* env, jobject pool);
241   jobject      (JNICALL *GetPeakMemoryPoolUsage) (JNIEnv* env, jobject pool);
242 
243   jlong        (JNICALL *GetOneThreadAllocatedMemory)
244                                                  (JNIEnv *env,
245                                                   jlong thread_id);
246   void         (JNICALL *GetThreadAllocatedMemory)
247                                                  (JNIEnv *env,
248                                                   jlongArray ids,
249                                                   jlongArray sizeArray);
250 
251   jobject      (JNICALL *GetMemoryUsage)         (JNIEnv* env, jboolean heap);
252 
253   jlong        (JNICALL *GetLongAttribute)       (JNIEnv *env, jobject obj, jmmLongAttribute att);
254   jboolean     (JNICALL *GetBoolAttribute)       (JNIEnv *env, jmmBoolAttribute att);
255   jboolean     (JNICALL *SetBoolAttribute)       (JNIEnv *env, jmmBoolAttribute att, jboolean flag);
256 
257   jint         (JNICALL *GetLongAttributes)      (JNIEnv *env,
258                                                   jobject obj,
259                                                   jmmLongAttribute* atts,
260                                                   jint count,
261                                                   jlong* result);
262 
263   jobjectArray (JNICALL *FindCircularBlockedThreads) (JNIEnv *env);
264 
265   // Not used in JDK 6 or JDK 7
266   jlong        (JNICALL *GetThreadCpuTime)       (JNIEnv *env, jlong thread_id);
267 
268   jobjectArray (JNICALL *GetVMGlobalNames)       (JNIEnv *env);
269   jint         (JNICALL *GetVMGlobals)           (JNIEnv *env,
270                                                   jobjectArray names,
271                                                   jmmVMGlobal *globals,
272                                                   jint count);
273 
274   jint         (JNICALL *GetInternalThreadTimes) (JNIEnv *env,
275                                                   jobjectArray names,
276                                                   jlongArray times);
277 
278   jboolean     (JNICALL *ResetStatistic)         (JNIEnv *env,
279                                                   jvalue obj,
280                                                   jmmStatisticType type);
281 
282   void         (JNICALL *SetPoolSensor)          (JNIEnv *env,
283                                                   jobject pool,
284                                                   jmmThresholdType type,
285                                                   jobject sensor);
286 
287   jlong        (JNICALL *SetPoolThreshold)       (JNIEnv *env,
288                                                   jobject pool,
289                                                   jmmThresholdType type,
290                                                   jlong threshold);
291   jobject      (JNICALL *GetPoolCollectionUsage) (JNIEnv* env, jobject pool);
292 
293   jint         (JNICALL *GetGCExtAttributeInfo)  (JNIEnv *env,
294                                                   jobject mgr,
295                                                   jmmExtAttributeInfo *ext_info,
296                                                   jint count);
297   void         (JNICALL *GetLastGCStat)          (JNIEnv *env,
298                                                   jobject mgr,
299                                                   jmmGCStat *gc_stat);
300 
301   jlong        (JNICALL *GetThreadCpuTimeWithKind)
302                                                  (JNIEnv *env,
303                                                   jlong thread_id,
304                                                   jboolean user_sys_cpu_time);
305   void         (JNICALL *GetThreadCpuTimesWithKind)
306                                                  (JNIEnv *env,
307                                                   jlongArray ids,
308                                                   jlongArray timeArray,
309                                                   jboolean user_sys_cpu_time);
310 
311   jint         (JNICALL *DumpHeap0)              (JNIEnv *env,
312                                                   jstring outputfile,
313                                                   jboolean live);
314   jobjectArray (JNICALL *FindDeadlocks)          (JNIEnv *env,
315                                                   jboolean object_monitors_only);
316   void         (JNICALL *SetVMGlobal)            (JNIEnv *env,
317                                                   jstring flag_name,
318                                                   jvalue  new_value);
319   void*        reserved6;
320   jobjectArray (JNICALL *DumpThreads)            (JNIEnv *env,
321                                                   jlongArray ids,
322                                                   jboolean lockedMonitors,
323                                                   jboolean lockedSynchronizers,
324                                                   jint maxDepth);
325   void         (JNICALL *SetGCNotificationEnabled) (JNIEnv *env,
326                                                     jobject mgr,
327                                                     jboolean enabled);
328   jobjectArray (JNICALL *GetDiagnosticCommands)  (JNIEnv *env);
329   void         (JNICALL *GetDiagnosticCommandInfo)
330                                                  (JNIEnv *env,
331                                                   jobjectArray cmds,
332                                                   dcmdInfo *infoArray);
333   void         (JNICALL *GetDiagnosticCommandArgumentsInfo)
334                                                  (JNIEnv *env,
335                                                   jstring commandName,
336                                                   dcmdArgInfo *infoArray);
337   jstring      (JNICALL *ExecuteDiagnosticCommand)
338                                                  (JNIEnv *env,
339                                                   jstring command);
340   void         (JNICALL *SetDiagnosticFrameworkNotificationEnabled)
341                                                  (JNIEnv *env,
342                                                   jboolean enabled);
343 } JmmInterface;
344 
345 #ifdef __cplusplus
346 } /* extern &quot;C&quot; */
347 #endif /* __cplusplus */
348 
349 #endif /* !_JAVA_JMM_H_ */
    </pre>
  </body>
</html>
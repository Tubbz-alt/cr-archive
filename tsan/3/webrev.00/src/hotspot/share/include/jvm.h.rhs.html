<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/include/jvm.h</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #ifndef _JAVASOFT_JVM_H_
  27 #define _JAVASOFT_JVM_H_
  28 
  29 #include &lt;sys/stat.h&gt;
  30 
  31 #include &quot;jni.h&quot;
  32 #include &quot;jvm_md.h&quot;
  33 
  34 #ifdef __cplusplus
  35 extern &quot;C&quot; {
  36 #endif
  37 
  38 /*
  39  * This file contains additional functions exported from the VM.
  40  * These functions are complementary to the standard JNI support.
  41  * There are three parts to this file:
  42  *
  43  * First, this file contains the VM-related functions needed by native
  44  * libraries in the standard Java API. For example, the java.lang.Object
  45  * class needs VM-level functions that wait for and notify monitors.
  46  *
  47  * Second, this file contains the functions and constant definitions
  48  * needed by the byte code verifier and class file format checker.
  49  * These functions allow the verifier and format checker to be written
  50  * in a VM-independent way.
  51  *
  52  * Third, this file contains various I/O and network operations needed
  53  * by the standard Java I/O and network APIs.
  54  */
  55 
  56 /*
  57  * Bump the version number when either of the following happens:
  58  *
  59  * 1. There is a change in JVM_* functions.
  60  *
  61  * 2. There is a change in the contract between VM and Java classes.
  62  *    For example, if the VM relies on a new private field in Thread
  63  *    class.
  64  */
  65 
  66 #define JVM_INTERFACE_VERSION 6
  67 
  68 JNIEXPORT jint JNICALL
  69 JVM_GetInterfaceVersion(void);
  70 
  71 /*************************************************************************
  72  PART 1: Functions for Native Libraries
  73  ************************************************************************/
  74 /*
  75  * java.lang.Object
  76  */
  77 JNIEXPORT jint JNICALL
  78 JVM_IHashCode(JNIEnv *env, jobject obj);
  79 
  80 JNIEXPORT void JNICALL
  81 JVM_MonitorWait(JNIEnv *env, jobject obj, jlong ms);
  82 
  83 JNIEXPORT void JNICALL
  84 JVM_MonitorNotify(JNIEnv *env, jobject obj);
  85 
  86 JNIEXPORT void JNICALL
  87 JVM_MonitorNotifyAll(JNIEnv *env, jobject obj);
  88 
  89 JNIEXPORT jobject JNICALL
  90 JVM_Clone(JNIEnv *env, jobject obj);
  91 
  92 /*
  93  * java.lang.String
  94  */
  95 JNIEXPORT jstring JNICALL
  96 JVM_InternString(JNIEnv *env, jstring str);
  97 
  98 /*
  99  * java.lang.System
 100  */
 101 JNIEXPORT jlong JNICALL
 102 JVM_CurrentTimeMillis(JNIEnv *env, jclass ignored);
 103 
 104 JNIEXPORT jlong JNICALL
 105 JVM_NanoTime(JNIEnv *env, jclass ignored);
 106 
 107 JNIEXPORT jlong JNICALL
 108 JVM_GetNanoTimeAdjustment(JNIEnv *env, jclass ignored, jlong offset_secs);
 109 
 110 JNIEXPORT void JNICALL
 111 JVM_ArrayCopy(JNIEnv *env, jclass ignored, jobject src, jint src_pos,
 112               jobject dst, jint dst_pos, jint length);
 113 
 114 /*
 115  * Return an array of all properties as alternating name and value pairs.
 116  */
 117 JNIEXPORT jobjectArray JNICALL
 118 JVM_GetProperties(JNIEnv *env);
 119 
 120 /*
 121  * java.lang.Runtime
 122  */
 123 JNIEXPORT void JNICALL
 124 JVM_BeforeHalt();
 125 
 126 JNIEXPORT void JNICALL
 127 JVM_Halt(jint code);
 128 
 129 JNIEXPORT void JNICALL
 130 JVM_GC(void);
 131 
 132 /* Returns the number of real-time milliseconds that have elapsed since the
 133  * least-recently-inspected heap object was last inspected by the garbage
 134  * collector.
 135  *
 136  * For simple stop-the-world collectors this value is just the time
 137  * since the most recent collection.  For generational collectors it is the
 138  * time since the oldest generation was most recently collected.  Other
 139  * collectors are free to return a pessimistic estimate of the elapsed time, or
 140  * simply the time since the last full collection was performed.
 141  *
 142  * Note that in the presence of reference objects, a given object that is no
 143  * longer strongly reachable may have to be inspected multiple times before it
 144  * can be reclaimed.
 145  */
 146 JNIEXPORT jlong JNICALL
 147 JVM_MaxObjectInspectionAge(void);
 148 
 149 JNIEXPORT jlong JNICALL
 150 JVM_TotalMemory(void);
 151 
 152 JNIEXPORT jlong JNICALL
 153 JVM_FreeMemory(void);
 154 
 155 JNIEXPORT jlong JNICALL
 156 JVM_MaxMemory(void);
 157 
 158 JNIEXPORT jint JNICALL
 159 JVM_ActiveProcessorCount(void);
 160 
 161 JNIEXPORT void * JNICALL
 162 JVM_LoadLibrary(const char *name);
 163 
 164 JNIEXPORT void JNICALL
 165 JVM_UnloadLibrary(void * handle);
 166 
 167 JNIEXPORT void * JNICALL
 168 JVM_FindLibraryEntry(void *handle, const char *name);
 169 
 170 JNIEXPORT jboolean JNICALL
 171 JVM_IsSupportedJNIVersion(jint version);
 172 
 173 JNIEXPORT jobjectArray JNICALL
 174 JVM_GetVmArguments(JNIEnv *env);
 175 
 176 JNIEXPORT void JNICALL
 177 JVM_InitializeFromArchive(JNIEnv* env, jclass cls);
 178 
 179 /*
 180  * java.lang.Throwable
 181  */
 182 JNIEXPORT void JNICALL
 183 JVM_FillInStackTrace(JNIEnv *env, jobject throwable);
 184 
 185 /*
 186  * java.lang.StackTraceElement
 187  */
 188 JNIEXPORT void JNICALL
 189 JVM_InitStackTraceElementArray(JNIEnv *env, jobjectArray elements, jobject throwable);
 190 
 191 JNIEXPORT void JNICALL
 192 JVM_InitStackTraceElement(JNIEnv* env, jobject element, jobject stackFrameInfo);
 193 
<a name="1" id="anc1"></a><span class="line-added"> 194 /*</span>
<span class="line-added"> 195  * java.lang.NullPointerException</span>
<span class="line-added"> 196  */</span>
<span class="line-added"> 197 </span>
<span class="line-added"> 198 JNIEXPORT jstring JNICALL</span>
<span class="line-added"> 199 JVM_GetExtendedNPEMessage(JNIEnv *env, jthrowable throwable);</span>
<span class="line-added"> 200 </span>
 201 /*
 202  * java.lang.StackWalker
 203  */
 204 enum {
 205   JVM_STACKWALK_FILL_CLASS_REFS_ONLY       = 0x2,
 206   JVM_STACKWALK_GET_CALLER_CLASS           = 0x04,
 207   JVM_STACKWALK_SHOW_HIDDEN_FRAMES         = 0x20,
 208   JVM_STACKWALK_FILL_LIVE_STACK_FRAMES     = 0x100
 209 };
 210 
 211 JNIEXPORT jobject JNICALL
 212 JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jlong mode,
 213                   jint skip_frames, jint frame_count, jint start_index,
 214                   jobjectArray frames);
 215 
 216 JNIEXPORT jint JNICALL
 217 JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jlong mode, jlong anchor,
 218                   jint frame_count, jint start_index,
 219                   jobjectArray frames);
 220 
 221 /*
 222  * java.lang.Thread
 223  */
 224 JNIEXPORT void JNICALL
 225 JVM_StartThread(JNIEnv *env, jobject thread);
 226 
 227 JNIEXPORT void JNICALL
 228 JVM_StopThread(JNIEnv *env, jobject thread, jobject exception);
 229 
 230 JNIEXPORT jboolean JNICALL
 231 JVM_IsThreadAlive(JNIEnv *env, jobject thread);
 232 
 233 JNIEXPORT void JNICALL
 234 JVM_SuspendThread(JNIEnv *env, jobject thread);
 235 
 236 JNIEXPORT void JNICALL
 237 JVM_ResumeThread(JNIEnv *env, jobject thread);
 238 
 239 JNIEXPORT void JNICALL
 240 JVM_SetThreadPriority(JNIEnv *env, jobject thread, jint prio);
 241 
 242 JNIEXPORT void JNICALL
 243 JVM_Yield(JNIEnv *env, jclass threadClass);
 244 
 245 JNIEXPORT void JNICALL
 246 JVM_Sleep(JNIEnv *env, jclass threadClass, jlong millis);
 247 
 248 JNIEXPORT jobject JNICALL
 249 JVM_CurrentThread(JNIEnv *env, jclass threadClass);
 250 
<a name="2" id="anc2"></a>


 251 JNIEXPORT void JNICALL
 252 JVM_Interrupt(JNIEnv *env, jobject thread);
 253 
<a name="3" id="anc3"></a>


 254 JNIEXPORT jboolean JNICALL
 255 JVM_HoldsLock(JNIEnv *env, jclass threadClass, jobject obj);
 256 
 257 JNIEXPORT void JNICALL
 258 JVM_DumpAllStacks(JNIEnv *env, jclass unused);
 259 
 260 JNIEXPORT jobjectArray JNICALL
 261 JVM_GetAllThreads(JNIEnv *env, jclass dummy);
 262 
 263 JNIEXPORT void JNICALL
 264 JVM_SetNativeThreadName(JNIEnv *env, jobject jthread, jstring name);
 265 
 266 /* getStackTrace() and getAllStackTraces() method */
 267 JNIEXPORT jobjectArray JNICALL
 268 JVM_DumpThreads(JNIEnv *env, jclass threadClass, jobjectArray threads);
 269 
 270 /*
 271  * java.lang.SecurityManager
 272  */
 273 JNIEXPORT jobjectArray JNICALL
 274 JVM_GetClassContext(JNIEnv *env);
 275 
 276 /*
 277  * java.lang.Package
 278  */
 279 JNIEXPORT jstring JNICALL
 280 JVM_GetSystemPackage(JNIEnv *env, jstring name);
 281 
 282 JNIEXPORT jobjectArray JNICALL
 283 JVM_GetSystemPackages(JNIEnv *env);
 284 
 285 /*
 286  * java.lang.ref.Finalizer
 287  */
 288 JNIEXPORT jboolean JNICALL
 289 JVM_GetTsanEnabled(JNIEnv *env);
 290 
 291 /*
 292  * java.lang.ref.Reference
 293  */
 294 JNIEXPORT jobject JNICALL
 295 JVM_GetAndClearReferencePendingList(JNIEnv *env);
 296 
 297 JNIEXPORT jboolean JNICALL
 298 JVM_HasReferencePendingList(JNIEnv *env);
 299 
 300 JNIEXPORT void JNICALL
 301 JVM_WaitForReferencePendingList(JNIEnv *env);
 302 
 303 /*
 304  * java.io.ObjectInputStream
 305  */
 306 JNIEXPORT jobject JNICALL
 307 JVM_LatestUserDefinedLoader(JNIEnv *env);
 308 
 309 /*
 310  * java.lang.reflect.Array
 311  */
 312 JNIEXPORT jint JNICALL
 313 JVM_GetArrayLength(JNIEnv *env, jobject arr);
 314 
 315 JNIEXPORT jobject JNICALL
 316 JVM_GetArrayElement(JNIEnv *env, jobject arr, jint index);
 317 
 318 JNIEXPORT jvalue JNICALL
 319 JVM_GetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jint wCode);
 320 
 321 JNIEXPORT void JNICALL
 322 JVM_SetArrayElement(JNIEnv *env, jobject arr, jint index, jobject val);
 323 
 324 JNIEXPORT void JNICALL
 325 JVM_SetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jvalue v,
 326                              unsigned char vCode);
 327 
 328 JNIEXPORT jobject JNICALL
 329 JVM_NewArray(JNIEnv *env, jclass eltClass, jint length);
 330 
 331 JNIEXPORT jobject JNICALL
 332 JVM_NewMultiArray(JNIEnv *env, jclass eltClass, jintArray dim);
 333 
 334 
 335 /*
 336  * Returns the immediate caller class of the native method invoking
 337  * JVM_GetCallerClass.  The Method.invoke and other frames due to
 338  * reflection machinery are skipped.
 339  *
 340  * The caller is expected to be marked with
 341  * jdk.internal.reflect.CallerSensitive. The JVM will throw an
 342  * error if it is not marked properly.
 343  */
 344 JNIEXPORT jclass JNICALL
 345 JVM_GetCallerClass(JNIEnv *env);
 346 
 347 
 348 /*
 349  * Find primitive classes
 350  * utf: class name
 351  */
 352 JNIEXPORT jclass JNICALL
 353 JVM_FindPrimitiveClass(JNIEnv *env, const char *utf);
 354 
 355 
 356 /*
 357  * Find a class from a boot class loader. Returns NULL if class not found.
 358  */
 359 JNIEXPORT jclass JNICALL
 360 JVM_FindClassFromBootLoader(JNIEnv *env, const char *name);
 361 
 362 /*
 363  * Find a class from a given class loader.  Throws ClassNotFoundException.
 364  *  name:   name of class
 365  *  init:   whether initialization is done
 366  *  loader: class loader to look up the class. This may not be the same as the caller&#39;s
 367  *          class loader.
 368  *  caller: initiating class. The initiating class may be null when a security
 369  *          manager is not installed.
 370  */
 371 JNIEXPORT jclass JNICALL
 372 JVM_FindClassFromCaller(JNIEnv *env, const char *name, jboolean init,
 373                         jobject loader, jclass caller);
 374 
 375 /*
 376  * Find a class from a given class.
 377  */
 378 JNIEXPORT jclass JNICALL
 379 JVM_FindClassFromClass(JNIEnv *env, const char *name, jboolean init,
 380                              jclass from);
 381 
 382 /* Find a loaded class cached by the VM */
 383 JNIEXPORT jclass JNICALL
 384 JVM_FindLoadedClass(JNIEnv *env, jobject loader, jstring name);
 385 
 386 /* Define a class */
 387 JNIEXPORT jclass JNICALL
 388 JVM_DefineClass(JNIEnv *env, const char *name, jobject loader, const jbyte *buf,
 389                 jsize len, jobject pd);
 390 
 391 /* Define a class with a source (added in JDK1.5) */
 392 JNIEXPORT jclass JNICALL
 393 JVM_DefineClassWithSource(JNIEnv *env, const char *name, jobject loader,
 394                           const jbyte *buf, jsize len, jobject pd,
 395                           const char *source);
 396 
 397 /*
 398  * Module support funcions
 399  */
 400 
 401 /*
 402  * Define a module with the specified packages and bind the module to the
 403  * given class loader.
 404  *  module:       module to define
 405  *  is_open:      specifies if module is open (currently ignored)
 406  *  version:      the module version
 407  *  location:     the module location
 408  *  packages:     list of packages in the module
 409  *  num_packages: number of packages in the module
 410  */
 411 JNIEXPORT void JNICALL
 412 JVM_DefineModule(JNIEnv *env, jobject module, jboolean is_open, jstring version,
 413                  jstring location, const char* const* packages, jsize num_packages);
 414 
 415 /*
 416  * Set the boot loader&#39;s unnamed module.
 417  *  module: boot loader&#39;s unnamed module
 418  */
 419 JNIEXPORT void JNICALL
 420 JVM_SetBootLoaderUnnamedModule(JNIEnv *env, jobject module);
 421 
 422 /*
 423  * Do a qualified export of a package.
 424  *  from_module: module containing the package to export
 425  *  package:     name of the package to export
 426  *  to_module:   module to export the package to
 427  */
 428 JNIEXPORT void JNICALL
 429 JVM_AddModuleExports(JNIEnv *env, jobject from_module, const char* package, jobject to_module);
 430 
 431 /*
 432  * Do an export of a package to all unnamed modules.
 433  *  from_module: module containing the package to export
 434  *  package:     name of the package to export to all unnamed modules
 435  */
 436 JNIEXPORT void JNICALL
 437 JVM_AddModuleExportsToAllUnnamed(JNIEnv *env, jobject from_module, const char* package);
 438 
 439 /*
 440  * Do an unqualified export of a package.
 441  *  from_module: module containing the package to export
 442  *  package:     name of the package to export
 443  */
 444 JNIEXPORT void JNICALL
 445 JVM_AddModuleExportsToAll(JNIEnv *env, jobject from_module, const char* package);
 446 
 447 /*
 448  * Add a module to the list of modules that a given module can read.
 449  *  from_module:   module requesting read access
 450  *  source_module: module that from_module wants to read
 451  */
 452 JNIEXPORT void JNICALL
 453 JVM_AddReadsModule(JNIEnv *env, jobject from_module, jobject source_module);
 454 
 455 /*
 456  * Reflection support functions
 457  */
 458 
 459 JNIEXPORT jstring JNICALL
 460 JVM_InitClassName(JNIEnv *env, jclass cls);
 461 
 462 JNIEXPORT jobjectArray JNICALL
 463 JVM_GetClassInterfaces(JNIEnv *env, jclass cls);
 464 
 465 JNIEXPORT jboolean JNICALL
 466 JVM_IsInterface(JNIEnv *env, jclass cls);
 467 
 468 JNIEXPORT jobjectArray JNICALL
 469 JVM_GetClassSigners(JNIEnv *env, jclass cls);
 470 
 471 JNIEXPORT void JNICALL
 472 JVM_SetClassSigners(JNIEnv *env, jclass cls, jobjectArray signers);
 473 
 474 JNIEXPORT jobject JNICALL
 475 JVM_GetProtectionDomain(JNIEnv *env, jclass cls);
 476 
 477 JNIEXPORT jboolean JNICALL
 478 JVM_IsArrayClass(JNIEnv *env, jclass cls);
 479 
 480 JNIEXPORT jboolean JNICALL
 481 JVM_IsPrimitiveClass(JNIEnv *env, jclass cls);
 482 
 483 JNIEXPORT jint JNICALL
 484 JVM_GetClassModifiers(JNIEnv *env, jclass cls);
 485 
 486 JNIEXPORT jobjectArray JNICALL
 487 JVM_GetDeclaredClasses(JNIEnv *env, jclass ofClass);
 488 
 489 JNIEXPORT jclass JNICALL
 490 JVM_GetDeclaringClass(JNIEnv *env, jclass ofClass);
 491 
 492 JNIEXPORT jstring JNICALL
 493 JVM_GetSimpleBinaryName(JNIEnv *env, jclass ofClass);
 494 
 495 /* Generics support (JDK 1.5) */
 496 JNIEXPORT jstring JNICALL
 497 JVM_GetClassSignature(JNIEnv *env, jclass cls);
 498 
 499 /* Annotations support (JDK 1.5) */
 500 JNIEXPORT jbyteArray JNICALL
 501 JVM_GetClassAnnotations(JNIEnv *env, jclass cls);
 502 
 503 /* Type use annotations support (JDK 1.8) */
 504 
 505 JNIEXPORT jbyteArray JNICALL
 506 JVM_GetClassTypeAnnotations(JNIEnv *env, jclass cls);
 507 
 508 JNIEXPORT jbyteArray JNICALL
 509 JVM_GetFieldTypeAnnotations(JNIEnv *env, jobject field);
 510 
 511 JNIEXPORT jbyteArray JNICALL
 512 JVM_GetMethodTypeAnnotations(JNIEnv *env, jobject method);
 513 
 514 /*
 515  * New (JDK 1.4) reflection implementation
 516  */
 517 
 518 JNIEXPORT jobjectArray JNICALL
 519 JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 520 
 521 JNIEXPORT jobjectArray JNICALL
 522 JVM_GetClassDeclaredFields(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 523 
 524 JNIEXPORT jobjectArray JNICALL
 525 JVM_GetClassDeclaredConstructors(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 526 
<a name="4" id="anc4"></a><span class="line-added"> 527 </span>
 528 /* Differs from JVM_GetClassModifiers in treatment of inner classes.
 529    This returns the access flags for the class as specified in the
 530    class file rather than searching the InnerClasses attribute (if
 531    present) to find the source-level access flags. Only the values of
 532    the low 13 bits (i.e., a mask of 0x1FFF) are guaranteed to be
 533    valid. */
 534 JNIEXPORT jint JNICALL
 535 JVM_GetClassAccessFlags(JNIEnv *env, jclass cls);
 536 
 537 /* Nestmates - since JDK 11 */
 538 
 539 JNIEXPORT jboolean JNICALL
 540 JVM_AreNestMates(JNIEnv *env, jclass current, jclass member);
 541 
 542 JNIEXPORT jclass JNICALL
 543 JVM_GetNestHost(JNIEnv *env, jclass current);
 544 
 545 JNIEXPORT jobjectArray JNICALL
 546 JVM_GetNestMembers(JNIEnv *env, jclass current);
 547 
<a name="5" id="anc5"></a><span class="line-added"> 548 /* Records - since JDK 14 */</span>
<span class="line-added"> 549 </span>
<span class="line-added"> 550 JNIEXPORT jboolean JNICALL</span>
<span class="line-added"> 551 JVM_IsRecord(JNIEnv *env, jclass cls);</span>
<span class="line-added"> 552 </span>
<span class="line-added"> 553 JNIEXPORT jobjectArray JNICALL</span>
<span class="line-added"> 554 JVM_GetRecordComponents(JNIEnv *env, jclass ofClass);</span>
<span class="line-added"> 555 </span>
 556 /* The following two reflection routines are still needed due to startup time issues */
 557 /*
 558  * java.lang.reflect.Method
 559  */
 560 JNIEXPORT jobject JNICALL
 561 JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0);
 562 
 563 /*
 564  * java.lang.reflect.Constructor
 565  */
 566 JNIEXPORT jobject JNICALL
 567 JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0);
 568 
 569 /*
 570  * Constant pool access; currently used to implement reflective access to annotations (JDK 1.5)
 571  */
 572 
 573 JNIEXPORT jobject JNICALL
 574 JVM_GetClassConstantPool(JNIEnv *env, jclass cls);
 575 
 576 JNIEXPORT jint JNICALL JVM_ConstantPoolGetSize
 577 (JNIEnv *env, jobject unused, jobject jcpool);
 578 
 579 JNIEXPORT jclass JNICALL JVM_ConstantPoolGetClassAt
 580 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 581 
 582 JNIEXPORT jclass JNICALL JVM_ConstantPoolGetClassAtIfLoaded
 583 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 584 
 585 JNIEXPORT jint JNICALL JVM_ConstantPoolGetClassRefIndexAt
 586 (JNIEnv *env, jobject obj, jobject unused, jint index);
 587 
 588 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetMethodAt
 589 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 590 
 591 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetMethodAtIfLoaded
 592 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 593 
 594 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetFieldAt
 595 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 596 
 597 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetFieldAtIfLoaded
 598 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 599 
 600 JNIEXPORT jobjectArray JNICALL JVM_ConstantPoolGetMemberRefInfoAt
 601 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 602 
 603 JNIEXPORT jint JNICALL JVM_ConstantPoolGetNameAndTypeRefIndexAt
 604 (JNIEnv *env, jobject obj, jobject unused, jint index);
 605 
 606 JNIEXPORT jobjectArray JNICALL JVM_ConstantPoolGetNameAndTypeRefInfoAt
 607 (JNIEnv *env, jobject obj, jobject unused, jint index);
 608 
 609 JNIEXPORT jint JNICALL JVM_ConstantPoolGetIntAt
 610 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 611 
 612 JNIEXPORT jlong JNICALL JVM_ConstantPoolGetLongAt
 613 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 614 
 615 JNIEXPORT jfloat JNICALL JVM_ConstantPoolGetFloatAt
 616 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 617 
 618 JNIEXPORT jdouble JNICALL JVM_ConstantPoolGetDoubleAt
 619 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 620 
 621 JNIEXPORT jstring JNICALL JVM_ConstantPoolGetStringAt
 622 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 623 
 624 JNIEXPORT jstring JNICALL JVM_ConstantPoolGetUTF8At
 625 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 626 
 627 JNIEXPORT jbyte JNICALL JVM_ConstantPoolGetTagAt
 628 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 629 
 630 /*
 631  * Parameter reflection
 632  */
 633 
 634 JNIEXPORT jobjectArray JNICALL
 635 JVM_GetMethodParameters(JNIEnv *env, jobject method);
 636 
 637 /*
 638  * java.security.*
 639  */
 640 
 641 JNIEXPORT jobject JNICALL
 642 JVM_GetInheritedAccessControlContext(JNIEnv *env, jclass cls);
 643 
 644 /*
 645  * Ensure that code doing a stackwalk and using javaVFrame::locals() to
 646  * get the value will see a materialized value and not a scalar-replaced
 647  * null value.
 648  */
 649 #define JVM_EnsureMaterializedForStackWalk(env, value) \
 650     do {} while(0) // Nothing to do.  The fact that the value escaped
 651                    // through a native method is enough.
 652 
 653 JNIEXPORT jobject JNICALL
 654 JVM_GetStackAccessControlContext(JNIEnv *env, jclass cls);
 655 
 656 /*
 657  * Signal support, used to implement the shutdown sequence.  Every VM must
 658  * support JVM_SIGINT and JVM_SIGTERM, raising the former for user interrupts
 659  * (^C) and the latter for external termination (kill, system shutdown, etc.).
 660  * Other platform-dependent signal values may also be supported.
 661  */
 662 
 663 JNIEXPORT void * JNICALL
 664 JVM_RegisterSignal(jint sig, void *handler);
 665 
 666 JNIEXPORT jboolean JNICALL
 667 JVM_RaiseSignal(jint sig);
 668 
 669 JNIEXPORT jint JNICALL
 670 JVM_FindSignal(const char *name);
 671 
 672 /*
 673  * Retrieve the assertion directives for the specified class.
 674  */
 675 JNIEXPORT jboolean JNICALL
 676 JVM_DesiredAssertionStatus(JNIEnv *env, jclass unused, jclass cls);
 677 
 678 /*
 679  * Retrieve the assertion directives from the VM.
 680  */
 681 JNIEXPORT jobject JNICALL
 682 JVM_AssertionStatusDirectives(JNIEnv *env, jclass unused);
 683 
 684 /*
 685  * java.util.concurrent.atomic.AtomicLong
 686  */
 687 JNIEXPORT jboolean JNICALL
 688 JVM_SupportsCX8(void);
 689 
 690 /*
 691  * com.sun.dtrace.jsdt support
 692  */
 693 
 694 #define JVM_TRACING_DTRACE_VERSION 1
 695 
 696 /*
 697  * Structure to pass one probe description to JVM
 698  */
 699 typedef struct {
 700     jmethodID method;
 701     jstring   function;
 702     jstring   name;
 703     void*            reserved[4];     // for future use
 704 } JVM_DTraceProbe;
 705 
 706 /**
 707  * Encapsulates the stability ratings for a DTrace provider field
 708  */
 709 typedef struct {
 710     jint nameStability;
 711     jint dataStability;
 712     jint dependencyClass;
 713 } JVM_DTraceInterfaceAttributes;
 714 
 715 /*
 716  * Structure to pass one provider description to JVM
 717  */
 718 typedef struct {
 719     jstring                       name;
 720     JVM_DTraceProbe*              probes;
 721     jint                          probe_count;
 722     JVM_DTraceInterfaceAttributes providerAttributes;
 723     JVM_DTraceInterfaceAttributes moduleAttributes;
 724     JVM_DTraceInterfaceAttributes functionAttributes;
 725     JVM_DTraceInterfaceAttributes nameAttributes;
 726     JVM_DTraceInterfaceAttributes argsAttributes;
 727     void*                         reserved[4]; // for future use
 728 } JVM_DTraceProvider;
 729 
 730 /*
 731  * Get the version number the JVM was built with
 732  */
 733 JNIEXPORT jint JNICALL
 734 JVM_DTraceGetVersion(JNIEnv* env);
 735 
 736 /*
 737  * Register new probe with given signature, return global handle
 738  *
 739  * The version passed in is the version that the library code was
 740  * built with.
 741  */
 742 JNIEXPORT jlong JNICALL
 743 JVM_DTraceActivate(JNIEnv* env, jint version, jstring module_name,
 744   jint providers_count, JVM_DTraceProvider* providers);
 745 
 746 /*
 747  * Check JSDT probe
 748  */
 749 JNIEXPORT jboolean JNICALL
 750 JVM_DTraceIsProbeEnabled(JNIEnv* env, jmethodID method);
 751 
 752 /*
 753  * Destroy custom DOF
 754  */
 755 JNIEXPORT void JNICALL
 756 JVM_DTraceDispose(JNIEnv* env, jlong activation_handle);
 757 
 758 /*
 759  * Check to see if DTrace is supported by OS
 760  */
 761 JNIEXPORT jboolean JNICALL
 762 JVM_DTraceIsSupported(JNIEnv* env);
 763 
 764 /*************************************************************************
 765  PART 2: Support for the Verifier and Class File Format Checker
 766  ************************************************************************/
 767 /*
 768  * Return the class name in UTF format. The result is valid
 769  * until JVM_ReleaseUTf is called.
 770  *
 771  * The caller must treat the string as a constant and not modify it
 772  * in any way.
 773  */
 774 JNIEXPORT const char * JNICALL
 775 JVM_GetClassNameUTF(JNIEnv *env, jclass cb);
 776 
 777 /*
 778  * Returns the constant pool types in the buffer provided by &quot;types.&quot;
 779  */
 780 JNIEXPORT void JNICALL
 781 JVM_GetClassCPTypes(JNIEnv *env, jclass cb, unsigned char *types);
 782 
 783 /*
 784  * Returns the number of Constant Pool entries.
 785  */
 786 JNIEXPORT jint JNICALL
 787 JVM_GetClassCPEntriesCount(JNIEnv *env, jclass cb);
 788 
 789 /*
 790  * Returns the number of *declared* fields or methods.
 791  */
 792 JNIEXPORT jint JNICALL
 793 JVM_GetClassFieldsCount(JNIEnv *env, jclass cb);
 794 
 795 JNIEXPORT jint JNICALL
 796 JVM_GetClassMethodsCount(JNIEnv *env, jclass cb);
 797 
 798 /*
 799  * Returns the CP indexes of exceptions raised by a given method.
 800  * Places the result in the given buffer.
 801  *
 802  * The method is identified by method_index.
 803  */
 804 JNIEXPORT void JNICALL
 805 JVM_GetMethodIxExceptionIndexes(JNIEnv *env, jclass cb, jint method_index,
 806                                 unsigned short *exceptions);
 807 /*
 808  * Returns the number of exceptions raised by a given method.
 809  * The method is identified by method_index.
 810  */
 811 JNIEXPORT jint JNICALL
 812 JVM_GetMethodIxExceptionsCount(JNIEnv *env, jclass cb, jint method_index);
 813 
 814 /*
 815  * Returns the byte code sequence of a given method.
 816  * Places the result in the given buffer.
 817  *
 818  * The method is identified by method_index.
 819  */
 820 JNIEXPORT void JNICALL
 821 JVM_GetMethodIxByteCode(JNIEnv *env, jclass cb, jint method_index,
 822                         unsigned char *code);
 823 
 824 /*
 825  * Returns the length of the byte code sequence of a given method.
 826  * The method is identified by method_index.
 827  */
 828 JNIEXPORT jint JNICALL
 829 JVM_GetMethodIxByteCodeLength(JNIEnv *env, jclass cb, jint method_index);
 830 
 831 /*
 832  * A structure used to a capture exception table entry in a Java method.
 833  */
 834 typedef struct {
 835     jint start_pc;
 836     jint end_pc;
 837     jint handler_pc;
 838     jint catchType;
 839 } JVM_ExceptionTableEntryType;
 840 
 841 /*
 842  * Returns the exception table entry at entry_index of a given method.
 843  * Places the result in the given buffer.
 844  *
 845  * The method is identified by method_index.
 846  */
 847 JNIEXPORT void JNICALL
 848 JVM_GetMethodIxExceptionTableEntry(JNIEnv *env, jclass cb, jint method_index,
 849                                    jint entry_index,
 850                                    JVM_ExceptionTableEntryType *entry);
 851 
 852 /*
 853  * Returns the length of the exception table of a given method.
 854  * The method is identified by method_index.
 855  */
 856 JNIEXPORT jint JNICALL
 857 JVM_GetMethodIxExceptionTableLength(JNIEnv *env, jclass cb, int index);
 858 
 859 /*
 860  * Returns the modifiers of a given field.
 861  * The field is identified by field_index.
 862  */
 863 JNIEXPORT jint JNICALL
 864 JVM_GetFieldIxModifiers(JNIEnv *env, jclass cb, int index);
 865 
 866 /*
 867  * Returns the modifiers of a given method.
 868  * The method is identified by method_index.
 869  */
 870 JNIEXPORT jint JNICALL
 871 JVM_GetMethodIxModifiers(JNIEnv *env, jclass cb, int index);
 872 
 873 /*
 874  * Returns the number of local variables of a given method.
 875  * The method is identified by method_index.
 876  */
 877 JNIEXPORT jint JNICALL
 878 JVM_GetMethodIxLocalsCount(JNIEnv *env, jclass cb, int index);
 879 
 880 /*
 881  * Returns the number of arguments (including this pointer) of a given method.
 882  * The method is identified by method_index.
 883  */
 884 JNIEXPORT jint JNICALL
 885 JVM_GetMethodIxArgsSize(JNIEnv *env, jclass cb, int index);
 886 
 887 /*
 888  * Returns the maximum amount of stack (in words) used by a given method.
 889  * The method is identified by method_index.
 890  */
 891 JNIEXPORT jint JNICALL
 892 JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cb, int index);
 893 
 894 /*
 895  * Is a given method a constructor.
 896  * The method is identified by method_index.
 897  */
 898 JNIEXPORT jboolean JNICALL
 899 JVM_IsConstructorIx(JNIEnv *env, jclass cb, int index);
 900 
 901 /*
 902  * Is the given method generated by the VM.
 903  * The method is identified by method_index.
 904  */
 905 JNIEXPORT jboolean JNICALL
 906 JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cb, int index);
 907 
 908 /*
 909  * Returns the name of a given method in UTF format.
 910  * The result remains valid until JVM_ReleaseUTF is called.
 911  *
 912  * The caller must treat the string as a constant and not modify it
 913  * in any way.
 914  */
 915 JNIEXPORT const char * JNICALL
 916 JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cb, jint index);
 917 
 918 /*
 919  * Returns the signature of a given method in UTF format.
 920  * The result remains valid until JVM_ReleaseUTF is called.
 921  *
 922  * The caller must treat the string as a constant and not modify it
 923  * in any way.
 924  */
 925 JNIEXPORT const char * JNICALL
 926 JVM_GetMethodIxSignatureUTF(JNIEnv *env, jclass cb, jint index);
 927 
 928 /*
 929  * Returns the name of the field referred to at a given constant pool
 930  * index.
 931  *
 932  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 933  * is called.
 934  *
 935  * The caller must treat the string as a constant and not modify it
 936  * in any way.
 937  */
 938 JNIEXPORT const char * JNICALL
 939 JVM_GetCPFieldNameUTF(JNIEnv *env, jclass cb, jint index);
 940 
 941 /*
 942  * Returns the name of the method referred to at a given constant pool
 943  * index.
 944  *
 945  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 946  * is called.
 947  *
 948  * The caller must treat the string as a constant and not modify it
 949  * in any way.
 950  */
 951 JNIEXPORT const char * JNICALL
 952 JVM_GetCPMethodNameUTF(JNIEnv *env, jclass cb, jint index);
 953 
 954 /*
 955  * Returns the signature of the method referred to at a given constant pool
 956  * index.
 957  *
 958  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 959  * is called.
 960  *
 961  * The caller must treat the string as a constant and not modify it
 962  * in any way.
 963  */
 964 JNIEXPORT const char * JNICALL
 965 JVM_GetCPMethodSignatureUTF(JNIEnv *env, jclass cb, jint index);
 966 
 967 /*
 968  * Returns the signature of the field referred to at a given constant pool
 969  * index.
 970  *
 971  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 972  * is called.
 973  *
 974  * The caller must treat the string as a constant and not modify it
 975  * in any way.
 976  */
 977 JNIEXPORT const char * JNICALL
 978 JVM_GetCPFieldSignatureUTF(JNIEnv *env, jclass cb, jint index);
 979 
 980 /*
 981  * Returns the class name referred to at a given constant pool index.
 982  *
 983  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 984  * is called.
 985  *
 986  * The caller must treat the string as a constant and not modify it
 987  * in any way.
 988  */
 989 JNIEXPORT const char * JNICALL
 990 JVM_GetCPClassNameUTF(JNIEnv *env, jclass cb, jint index);
 991 
 992 /*
 993  * Returns the class name referred to at a given constant pool index.
 994  *
 995  * The constant pool entry must refer to a CONSTANT_Fieldref.
 996  *
 997  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 998  * is called.
 999  *
1000  * The caller must treat the string as a constant and not modify it
1001  * in any way.
1002  */
1003 JNIEXPORT const char * JNICALL
1004 JVM_GetCPFieldClassNameUTF(JNIEnv *env, jclass cb, jint index);
1005 
1006 /*
1007  * Returns the class name referred to at a given constant pool index.
1008  *
1009  * The constant pool entry must refer to CONSTANT_Methodref or
1010  * CONSTANT_InterfaceMethodref.
1011  *
1012  * The result is in UTF format and remains valid until JVM_ReleaseUTF
1013  * is called.
1014  *
1015  * The caller must treat the string as a constant and not modify it
1016  * in any way.
1017  */
1018 JNIEXPORT const char * JNICALL
1019 JVM_GetCPMethodClassNameUTF(JNIEnv *env, jclass cb, jint index);
1020 
1021 /*
1022  * Returns the modifiers of a field in calledClass. The field is
1023  * referred to in class cb at constant pool entry index.
1024  *
1025  * The caller must treat the string as a constant and not modify it
1026  * in any way.
1027  *
1028  * Returns -1 if the field does not exist in calledClass.
1029  */
1030 JNIEXPORT jint JNICALL
1031 JVM_GetCPFieldModifiers(JNIEnv *env, jclass cb, int index, jclass calledClass);
1032 
1033 /*
1034  * Returns the modifiers of a method in calledClass. The method is
1035  * referred to in class cb at constant pool entry index.
1036  *
1037  * Returns -1 if the method does not exist in calledClass.
1038  */
1039 JNIEXPORT jint JNICALL
1040 JVM_GetCPMethodModifiers(JNIEnv *env, jclass cb, int index, jclass calledClass);
1041 
1042 /*
1043  * Releases the UTF string obtained from the VM.
1044  */
1045 JNIEXPORT void JNICALL
1046 JVM_ReleaseUTF(const char *utf);
1047 
1048 /*
1049  * Compare if two classes are in the same package.
1050  */
1051 JNIEXPORT jboolean JNICALL
1052 JVM_IsSameClassPackage(JNIEnv *env, jclass class1, jclass class2);
1053 
1054 /* Get classfile constants */
1055 #include &quot;classfile_constants.h&quot;
1056 
<a name="6" id="anc6"></a>












1057 /*
1058  * Support for a VM-independent class format checker.
1059  */
1060 typedef struct {
1061     unsigned long code;    /* byte code */
1062     unsigned long excs;    /* exceptions */
1063     unsigned long etab;    /* catch table */
1064     unsigned long lnum;    /* line number */
1065     unsigned long lvar;    /* local vars */
1066 } method_size_info;
1067 
1068 typedef struct {
1069     unsigned int constants;    /* constant pool */
1070     unsigned int fields;
1071     unsigned int methods;
1072     unsigned int interfaces;
1073     unsigned int fields2;      /* number of static 2-word fields */
1074     unsigned int innerclasses; /* # of records in InnerClasses attr */
1075 
1076     method_size_info clinit;   /* memory used in clinit */
1077     method_size_info main;     /* used everywhere else */
1078 } class_size_info;
1079 
<a name="7" id="anc7"></a>




























1080 #define JVM_RECOGNIZED_CLASS_MODIFIERS (JVM_ACC_PUBLIC | \
1081                                         JVM_ACC_FINAL | \
1082                                         JVM_ACC_SUPER | \
1083                                         JVM_ACC_INTERFACE | \
1084                                         JVM_ACC_ABSTRACT | \
1085                                         JVM_ACC_ANNOTATION | \
1086                                         JVM_ACC_ENUM | \
1087                                         JVM_ACC_SYNTHETIC)
1088 
1089 #define JVM_RECOGNIZED_FIELD_MODIFIERS (JVM_ACC_PUBLIC | \
1090                                         JVM_ACC_PRIVATE | \
1091                                         JVM_ACC_PROTECTED | \
1092                                         JVM_ACC_STATIC | \
1093                                         JVM_ACC_FINAL | \
1094                                         JVM_ACC_VOLATILE | \
1095                                         JVM_ACC_TRANSIENT | \
1096                                         JVM_ACC_ENUM | \
1097                                         JVM_ACC_SYNTHETIC)
1098 
1099 #define JVM_RECOGNIZED_METHOD_MODIFIERS (JVM_ACC_PUBLIC | \
1100                                          JVM_ACC_PRIVATE | \
1101                                          JVM_ACC_PROTECTED | \
1102                                          JVM_ACC_STATIC | \
1103                                          JVM_ACC_FINAL | \
1104                                          JVM_ACC_SYNCHRONIZED | \
1105                                          JVM_ACC_BRIDGE | \
1106                                          JVM_ACC_VARARGS | \
1107                                          JVM_ACC_NATIVE | \
1108                                          JVM_ACC_ABSTRACT | \
1109                                          JVM_ACC_STRICT | \
1110                                          JVM_ACC_SYNTHETIC)
1111 
<a name="8" id="anc8"></a>







1112 
1113 /*************************************************************************
1114  PART 3: I/O and Network Support
1115  ************************************************************************/
1116 
1117 /*
1118  * Convert a pathname into native format.  This function does syntactic
1119  * cleanup, such as removing redundant separator characters.  It modifies
1120  * the given pathname string in place.
1121  */
1122 JNIEXPORT char * JNICALL
1123 JVM_NativePath(char *);
1124 
1125 /*
1126  * The standard printing functions supported by the Java VM. (Should they
1127  * be renamed to JVM_* in the future?
1128  */
1129 
1130 /* jio_snprintf() and jio_vsnprintf() behave like snprintf(3) and vsnprintf(3),
1131  *  respectively, with the following differences:
1132  * - The string written to str is always zero-terminated, also in case of
1133  *   truncation (count is too small to hold the result string), unless count
1134  *   is 0. In case of truncation count-1 characters are written and &#39;\0&#39;
1135  *   appendend.
1136  * - If count is too small to hold the whole string, -1 is returned across
1137  *   all platforms. */
1138 
1139 JNIEXPORT int
1140 jio_vsnprintf(char *str, size_t count, const char *fmt, va_list args);
1141 
1142 JNIEXPORT int
1143 jio_snprintf(char *str, size_t count, const char *fmt, ...);
1144 
1145 JNIEXPORT int
1146 jio_fprintf(FILE *, const char *fmt, ...);
1147 
1148 JNIEXPORT int
1149 jio_vfprintf(FILE *, const char *fmt, va_list args);
1150 
1151 
1152 JNIEXPORT void * JNICALL
1153 JVM_RawMonitorCreate(void);
1154 
1155 JNIEXPORT void JNICALL
1156 JVM_RawMonitorDestroy(void *mon);
1157 
1158 JNIEXPORT jint JNICALL
1159 JVM_RawMonitorEnter(void *mon);
1160 
1161 JNIEXPORT void JNICALL
1162 JVM_RawMonitorExit(void *mon);
1163 
1164 /*
1165  * java.lang.management support
1166  */
1167 JNIEXPORT void* JNICALL
1168 JVM_GetManagement(jint version);
1169 
1170 /*
1171  * com.sun.tools.attach.VirtualMachine support
1172  *
1173  * Initialize the agent properties with the properties maintained in the VM.
1174  */
1175 JNIEXPORT jobject JNICALL
1176 JVM_InitAgentProperties(JNIEnv *env, jobject agent_props);
1177 
1178 JNIEXPORT jstring JNICALL
1179 JVM_GetTemporaryDirectory(JNIEnv *env);
1180 
1181 /* Generics reflection support.
1182  *
1183  * Returns information about the given class&#39;s EnclosingMethod
1184  * attribute, if present, or null if the class had no enclosing
1185  * method.
1186  *
1187  * If non-null, the returned array contains three elements. Element 0
1188  * is the java.lang.Class of which the enclosing method is a member,
1189  * and elements 1 and 2 are the java.lang.Strings for the enclosing
1190  * method&#39;s name and descriptor, respectively.
1191  */
1192 JNIEXPORT jobjectArray JNICALL
1193 JVM_GetEnclosingMethodInfo(JNIEnv* env, jclass ofClass);
1194 
<a name="9" id="anc9"></a>
















































































1195 /*
1196  * This structure is used by the launcher to get the default thread
1197  * stack size from the VM using JNI_GetDefaultJavaVMInitArgs() with a
1198  * version of 1.1.  As it is not supported otherwise, it has been removed
1199  * from jni.h
1200  */
1201 typedef struct JDK1_1InitArgs {
1202     jint version;
1203 
1204     char **properties;
1205     jint checkSource;
1206     jint nativeStackSize;
1207     jint javaStackSize;
1208     jint minHeapSize;
1209     jint maxHeapSize;
1210     jint verifyMode;
1211     char *classpath;
1212 
1213     jint (JNICALL *vfprintf)(FILE *fp, const char *format, va_list args);
1214     void (JNICALL *exit)(jint code);
1215     void (JNICALL *abort)(void);
1216 
1217     jint enableClassGC;
1218     jint enableVerboseGC;
1219     jint disableAsyncGC;
1220     jint verbose;
1221     jboolean debugging;
1222     jint debugPort;
1223 } JDK1_1InitArgs;
1224 
1225 
1226 #ifdef __cplusplus
1227 } /* extern &quot;C&quot; */
1228 
1229 #endif /* __cplusplus */
1230 
1231 #endif /* !_JAVASOFT_JVM_H_ */
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
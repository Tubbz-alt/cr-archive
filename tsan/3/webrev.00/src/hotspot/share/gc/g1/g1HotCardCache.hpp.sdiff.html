<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1HotCardCache.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1HotCardCache.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1IHOPControl.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1HotCardCache.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1HOTCARDCACHE_HPP
 26 #define SHARE_GC_G1_G1HOTCARDCACHE_HPP
 27 
 28 #include &quot;gc/g1/g1CardCounts.hpp&quot;
<span class="line-removed"> 29 #include &quot;gc/g1/g1_globals.hpp&quot;</span>
 30 #include &quot;memory/allocation.hpp&quot;
 31 #include &quot;runtime/safepoint.hpp&quot;
 32 #include &quot;runtime/thread.hpp&quot;
 33 #include &quot;utilities/globalDefinitions.hpp&quot;
 34 
 35 class G1CardTableEntryClosure;
 36 class G1CollectedHeap;
 37 class HeapRegion;
 38 
 39 // An evicting cache of cards that have been logged by the G1 post
 40 // write barrier. Placing a card in the cache delays the refinement
 41 // of the card until the card is evicted, or the cache is drained
 42 // during the next evacuation pause.
 43 //
 44 // The first thing the G1 post write barrier does is to check whether
 45 // the card containing the updated pointer is already dirty and, if
 46 // so, skips the remaining code in the barrier.
 47 //
 48 // Delaying the refinement of a card will make the card fail the
 49 // first is_dirty check in the write barrier, skipping the remainder
</pre>
<hr />
<pre>
 65 
 66 
 67   // The card cache table
 68   CardValue** _hot_cache;
 69 
 70   size_t            _hot_cache_size;
 71 
 72   size_t            _hot_cache_par_chunk_size;
 73 
 74   // Avoids false sharing when concurrently updating _hot_cache_idx or
 75   // _hot_cache_par_claimed_idx. These are never updated at the same time
 76   // thus it&#39;s not necessary to separate them as well
 77   char _pad_before[DEFAULT_CACHE_LINE_SIZE];
 78 
 79   volatile size_t _hot_cache_idx;
 80 
 81   volatile size_t _hot_cache_par_claimed_idx;
 82 
 83   char _pad_after[DEFAULT_CACHE_LINE_SIZE];
 84 





 85   // The number of cached cards a thread claims when flushing the cache
 86   static const int ClaimChunkSize = 32;
 87 
 88  public:
 89   static bool default_use_cache() {
 90     return (G1ConcRSLogCacheSize &gt; 0);
 91   }
 92 
 93   G1HotCardCache(G1CollectedHeap* g1h);
 94   ~G1HotCardCache();
 95 
 96   void initialize(G1RegionToSpaceMapper* card_counts_storage);
 97 
 98   bool use_cache() { return _use_cache; }
 99 
100   void set_use_cache(bool b) {
101     _use_cache = (b ? default_use_cache() : false);
102   }
103 
104   // Returns the card to be refined or NULL.
105   //
106   // Increments the count for given the card. if the card is not &#39;hot&#39;,
107   // it is returned for immediate refining. Otherwise the card is
108   // added to the hot card cache.
109   // If there is enough room in the hot card cache for the card we&#39;re
110   // adding, NULL is returned and no further action in needed.
111   // If we evict a card from the cache to make room for the new card,
112   // the evicted card is then returned for refinement.
113   CardValue* insert(CardValue* card_ptr);
114 
115   // Refine the cards that have delayed as a result of
116   // being in the cache.
<span class="line-modified">117   void drain(G1CardTableEntryClosure* cl, uint worker_i);</span>
118 
119   // Set up for parallel processing of the cards in the hot cache
120   void reset_hot_cache_claimed_index() {
121     _hot_cache_par_claimed_idx = 0;
122   }
123 
124   // Resets the hot card cache and discards the entries.
125   void reset_hot_cache() {
126     assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at a safepoint&quot;);
127     assert(Thread::current()-&gt;is_VM_thread(), &quot;Current thread should be the VMthread&quot;);
128     if (default_use_cache()) {
<span class="line-modified">129         reset_hot_cache_internal();</span>
130     }
131   }
132 
133   // Zeros the values in the card counts table for the given region
134   void reset_card_counts(HeapRegion* hr);
135 




136  private:
137   void reset_hot_cache_internal() {
138     assert(_hot_cache != NULL, &quot;Logic&quot;);
139     _hot_cache_idx = 0;
140     for (size_t i = 0; i &lt; _hot_cache_size; i++) {
141       _hot_cache[i] = NULL;
142     }

143   }
144 };
145 
146 #endif // SHARE_GC_G1_G1HOTCARDCACHE_HPP
</pre>
</td>
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1HOTCARDCACHE_HPP
 26 #define SHARE_GC_G1_G1HOTCARDCACHE_HPP
 27 
 28 #include &quot;gc/g1/g1CardCounts.hpp&quot;

 29 #include &quot;memory/allocation.hpp&quot;
 30 #include &quot;runtime/safepoint.hpp&quot;
 31 #include &quot;runtime/thread.hpp&quot;
 32 #include &quot;utilities/globalDefinitions.hpp&quot;
 33 
 34 class G1CardTableEntryClosure;
 35 class G1CollectedHeap;
 36 class HeapRegion;
 37 
 38 // An evicting cache of cards that have been logged by the G1 post
 39 // write barrier. Placing a card in the cache delays the refinement
 40 // of the card until the card is evicted, or the cache is drained
 41 // during the next evacuation pause.
 42 //
 43 // The first thing the G1 post write barrier does is to check whether
 44 // the card containing the updated pointer is already dirty and, if
 45 // so, skips the remaining code in the barrier.
 46 //
 47 // Delaying the refinement of a card will make the card fail the
 48 // first is_dirty check in the write barrier, skipping the remainder
</pre>
<hr />
<pre>
 64 
 65 
 66   // The card cache table
 67   CardValue** _hot_cache;
 68 
 69   size_t            _hot_cache_size;
 70 
 71   size_t            _hot_cache_par_chunk_size;
 72 
 73   // Avoids false sharing when concurrently updating _hot_cache_idx or
 74   // _hot_cache_par_claimed_idx. These are never updated at the same time
 75   // thus it&#39;s not necessary to separate them as well
 76   char _pad_before[DEFAULT_CACHE_LINE_SIZE];
 77 
 78   volatile size_t _hot_cache_idx;
 79 
 80   volatile size_t _hot_cache_par_claimed_idx;
 81 
 82   char _pad_after[DEFAULT_CACHE_LINE_SIZE];
 83 
<span class="line-added"> 84   // Records whether insertion overflowed the hot card cache at least once. This</span>
<span class="line-added"> 85   // avoids the need for a separate atomic counter of how many valid entries are</span>
<span class="line-added"> 86   // in the HCC.</span>
<span class="line-added"> 87   volatile bool _cache_wrapped_around;</span>
<span class="line-added"> 88 </span>
 89   // The number of cached cards a thread claims when flushing the cache
 90   static const int ClaimChunkSize = 32;
 91 
 92  public:
 93   static bool default_use_cache() {
 94     return (G1ConcRSLogCacheSize &gt; 0);
 95   }
 96 
 97   G1HotCardCache(G1CollectedHeap* g1h);
 98   ~G1HotCardCache();
 99 
100   void initialize(G1RegionToSpaceMapper* card_counts_storage);
101 
102   bool use_cache() { return _use_cache; }
103 
104   void set_use_cache(bool b) {
105     _use_cache = (b ? default_use_cache() : false);
106   }
107 
108   // Returns the card to be refined or NULL.
109   //
110   // Increments the count for given the card. if the card is not &#39;hot&#39;,
111   // it is returned for immediate refining. Otherwise the card is
112   // added to the hot card cache.
113   // If there is enough room in the hot card cache for the card we&#39;re
114   // adding, NULL is returned and no further action in needed.
115   // If we evict a card from the cache to make room for the new card,
116   // the evicted card is then returned for refinement.
117   CardValue* insert(CardValue* card_ptr);
118 
119   // Refine the cards that have delayed as a result of
120   // being in the cache.
<span class="line-modified">121   void drain(G1CardTableEntryClosure* cl, uint worker_id);</span>
122 
123   // Set up for parallel processing of the cards in the hot cache
124   void reset_hot_cache_claimed_index() {
125     _hot_cache_par_claimed_idx = 0;
126   }
127 
128   // Resets the hot card cache and discards the entries.
129   void reset_hot_cache() {
130     assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at a safepoint&quot;);
131     assert(Thread::current()-&gt;is_VM_thread(), &quot;Current thread should be the VMthread&quot;);
132     if (default_use_cache()) {
<span class="line-modified">133       reset_hot_cache_internal();</span>
134     }
135   }
136 
137   // Zeros the values in the card counts table for the given region
138   void reset_card_counts(HeapRegion* hr);
139 
<span class="line-added">140   // Number of entries in the HCC.</span>
<span class="line-added">141   size_t num_entries() const {</span>
<span class="line-added">142     return _cache_wrapped_around ? _hot_cache_size : _hot_cache_idx + 1;</span>
<span class="line-added">143   }</span>
144  private:
145   void reset_hot_cache_internal() {
146     assert(_hot_cache != NULL, &quot;Logic&quot;);
147     _hot_cache_idx = 0;
148     for (size_t i = 0; i &lt; _hot_cache_size; i++) {
149       _hot_cache[i] = NULL;
150     }
<span class="line-added">151     _cache_wrapped_around = false;</span>
152   }
153 };
154 
155 #endif // SHARE_GC_G1_G1HOTCARDCACHE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="g1HotCardCache.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1IHOPControl.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
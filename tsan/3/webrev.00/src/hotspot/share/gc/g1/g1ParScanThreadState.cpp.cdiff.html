<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/g1/g1ParScanThreadState.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1PageBasedVirtualSpace.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ParScanThreadState.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1ParScanThreadState.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 28,84 ***</span>
  #include &quot;gc/g1/g1CollectionSet.hpp&quot;
  #include &quot;gc/g1/g1OopClosures.inline.hpp&quot;
  #include &quot;gc/g1/g1ParScanThreadState.inline.hpp&quot;
  #include &quot;gc/g1/g1RootClosures.hpp&quot;
  #include &quot;gc/g1/g1StringDedup.hpp&quot;
<span class="line-modified">! #include &quot;gc/shared/gcTrace.hpp&quot;</span>
  #include &quot;gc/shared/taskqueue.inline.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;oops/access.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/prefetch.inline.hpp&quot;
  
  G1ParScanThreadState::G1ParScanThreadState(G1CollectedHeap* g1h,
                                             uint worker_id,
                                             size_t young_cset_length,
                                             size_t optional_cset_length)
    : _g1h(g1h),
      _refs(g1h-&gt;task_queue(worker_id)),
<span class="line-modified">!     _dcq(&amp;g1h-&gt;dirty_card_queue_set()),</span>
      _ct(g1h-&gt;card_table()),
      _closures(NULL),
      _plab_allocator(NULL),
      _age_table(false),
      _tenuring_threshold(g1h-&gt;policy()-&gt;tenuring_threshold()),
      _scanner(g1h, this),
      _worker_id(worker_id),
      _stack_trim_upper_threshold(GCDrainStackTargetSize * 2 + 1),
      _stack_trim_lower_threshold(GCDrainStackTargetSize),
      _trim_ticks(),
      _old_gen_is_full(false),
<span class="line-modified">!     _num_optional_regions(optional_cset_length)</span>
  {
<span class="line-modified">!   // we allocate G1YoungSurvRateNumRegions plus one entries, since</span>
<span class="line-modified">!   // we &quot;sacrifice&quot; entry 0 to keep track of surviving bytes for</span>
<span class="line-removed">-   // non-young regions (where the age is -1)</span>
    // We also add a few elements at the beginning and at the end in
    // an attempt to eliminate cache contention
<span class="line-modified">!   size_t real_length = 1 + young_cset_length;</span>
<span class="line-removed">-   size_t array_length = PADDING_ELEM_NUM +</span>
<span class="line-removed">-                       real_length +</span>
<span class="line-removed">-                       PADDING_ELEM_NUM;</span>
    _surviving_young_words_base = NEW_C_HEAP_ARRAY(size_t, array_length, mtGC);
<span class="line-removed">-   if (_surviving_young_words_base == NULL)</span>
<span class="line-removed">-     vm_exit_out_of_memory(array_length * sizeof(size_t), OOM_MALLOC_ERROR,</span>
<span class="line-removed">-                           &quot;Not enough space for young surv histo.&quot;);</span>
    _surviving_young_words = _surviving_young_words_base + PADDING_ELEM_NUM;
<span class="line-modified">!   memset(_surviving_young_words, 0, real_length * sizeof(size_t));</span>
  
    _plab_allocator = new G1PLABAllocator(_g1h-&gt;allocator());
  
<span class="line-removed">-   _dest[InCSetState::NotInCSet]    = InCSetState::NotInCSet;</span>
    // The dest for Young is used when the objects are aged enough to
    // need to be moved to the next space.
<span class="line-modified">!   _dest[InCSetState::Young]        = InCSetState::Old;</span>
<span class="line-modified">!   _dest[InCSetState::Old]          = InCSetState::Old;</span>
  
    _closures = G1EvacuationRootClosures::create_root_closures(this, _g1h);
  
    _oops_into_optional_regions = new G1OopStarChunkedList[_num_optional_regions];
  }
  
<span class="line-modified">! // Pass locally gathered statistics to global state.</span>
<span class="line-modified">! void G1ParScanThreadState::flush(size_t* surviving_young_words) {</span>
<span class="line-modified">!   _dcq.flush();</span>
    // Update allocation statistics.
    _plab_allocator-&gt;flush_and_retire_stats();
    _g1h-&gt;policy()-&gt;record_age_table(&amp;_age_table);
  
<span class="line-modified">!   uint length = _g1h-&gt;collection_set()-&gt;young_region_length();</span>
<span class="line-modified">!   for (uint region_index = 0; region_index &lt; length; region_index++) {</span>
<span class="line-modified">!     surviving_young_words[region_index] += _surviving_young_words[region_index];</span>
    }
  }
  
  G1ParScanThreadState::~G1ParScanThreadState() {
    delete _plab_allocator;
    delete _closures;
    FREE_C_HEAP_ARRAY(size_t, _surviving_young_words_base);
    delete[] _oops_into_optional_regions;
  }
  
  size_t G1ParScanThreadState::lab_waste_words() const {
    return _plab_allocator-&gt;waste();
  }
<span class="line-new-header">--- 28,88 ---</span>
  #include &quot;gc/g1/g1CollectionSet.hpp&quot;
  #include &quot;gc/g1/g1OopClosures.inline.hpp&quot;
  #include &quot;gc/g1/g1ParScanThreadState.inline.hpp&quot;
  #include &quot;gc/g1/g1RootClosures.hpp&quot;
  #include &quot;gc/g1/g1StringDedup.hpp&quot;
<span class="line-modified">! #include &quot;gc/g1/g1Trace.hpp&quot;</span>
  #include &quot;gc/shared/taskqueue.inline.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;oops/access.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/prefetch.inline.hpp&quot;
  
  G1ParScanThreadState::G1ParScanThreadState(G1CollectedHeap* g1h,
<span class="line-added">+                                            G1RedirtyCardsQueueSet* rdcqs,</span>
                                             uint worker_id,
                                             size_t young_cset_length,
                                             size_t optional_cset_length)
    : _g1h(g1h),
      _refs(g1h-&gt;task_queue(worker_id)),
<span class="line-modified">!     _rdcq(rdcqs),</span>
      _ct(g1h-&gt;card_table()),
      _closures(NULL),
      _plab_allocator(NULL),
      _age_table(false),
      _tenuring_threshold(g1h-&gt;policy()-&gt;tenuring_threshold()),
      _scanner(g1h, this),
      _worker_id(worker_id),
<span class="line-added">+     _last_enqueued_card(SIZE_MAX),</span>
      _stack_trim_upper_threshold(GCDrainStackTargetSize * 2 + 1),
      _stack_trim_lower_threshold(GCDrainStackTargetSize),
      _trim_ticks(),
<span class="line-added">+     _surviving_young_words_base(NULL),</span>
<span class="line-added">+     _surviving_young_words(NULL),</span>
<span class="line-added">+     _surviving_words_length(young_cset_length + 1),</span>
      _old_gen_is_full(false),
<span class="line-modified">!     _num_optional_regions(optional_cset_length),</span>
<span class="line-added">+     _numa(g1h-&gt;numa()),</span>
<span class="line-added">+     _obj_alloc_stat(NULL)</span>
  {
<span class="line-modified">!   // We allocate number of young gen regions in the collection set plus one</span>
<span class="line-modified">!   // entries, since entry 0 keeps track of surviving bytes for non-young regions.</span>
    // We also add a few elements at the beginning and at the end in
    // an attempt to eliminate cache contention
<span class="line-modified">!   size_t array_length = PADDING_ELEM_NUM + _surviving_words_length + PADDING_ELEM_NUM;</span>
    _surviving_young_words_base = NEW_C_HEAP_ARRAY(size_t, array_length, mtGC);
    _surviving_young_words = _surviving_young_words_base + PADDING_ELEM_NUM;
<span class="line-modified">!   memset(_surviving_young_words, 0, _surviving_words_length * sizeof(size_t));</span>
  
    _plab_allocator = new G1PLABAllocator(_g1h-&gt;allocator());
  
    // The dest for Young is used when the objects are aged enough to
    // need to be moved to the next space.
<span class="line-modified">!   _dest[G1HeapRegionAttr::Young] = G1HeapRegionAttr::Old;</span>
<span class="line-modified">!   _dest[G1HeapRegionAttr::Old]   = G1HeapRegionAttr::Old;</span>
  
    _closures = G1EvacuationRootClosures::create_root_closures(this, _g1h);
  
    _oops_into_optional_regions = new G1OopStarChunkedList[_num_optional_regions];
<span class="line-added">+ </span>
<span class="line-added">+   initialize_numa_stats();</span>
  }
  
<span class="line-modified">! size_t G1ParScanThreadState::flush(size_t* surviving_young_words) {</span>
<span class="line-modified">!   _rdcq.flush();</span>
<span class="line-modified">!   flush_numa_stats();</span>
    // Update allocation statistics.
    _plab_allocator-&gt;flush_and_retire_stats();
    _g1h-&gt;policy()-&gt;record_age_table(&amp;_age_table);
  
<span class="line-modified">!   size_t sum = 0;</span>
<span class="line-modified">!   for (uint i = 0; i &lt; _surviving_words_length; i++) {</span>
<span class="line-modified">!     surviving_young_words[i] += _surviving_young_words[i];</span>
<span class="line-added">+     sum += _surviving_young_words[i];</span>
    }
<span class="line-added">+   return sum;</span>
  }
  
  G1ParScanThreadState::~G1ParScanThreadState() {
    delete _plab_allocator;
    delete _closures;
    FREE_C_HEAP_ARRAY(size_t, _surviving_young_words_base);
    delete[] _oops_into_optional_regions;
<span class="line-added">+   FREE_C_HEAP_ARRAY(size_t, _obj_alloc_stat);</span>
  }
  
  size_t G1ParScanThreadState::lab_waste_words() const {
    return _plab_allocator-&gt;waste();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 155,24 ***</span>
      // Fully drain the queue.
      trim_queue_to_threshold(0);
    } while (!_refs-&gt;is_empty());
  }
  
<span class="line-modified">! HeapWord* G1ParScanThreadState::allocate_in_next_plab(InCSetState const state,</span>
<span class="line-removed">-                                                       InCSetState* dest,</span>
                                                        size_t word_sz,
<span class="line-modified">!                                                       bool previous_plab_refill_failed) {</span>
<span class="line-modified">!   assert(state.is_in_cset_or_humongous(), &quot;Unexpected state: &quot; CSETSTATE_FORMAT, state.value());</span>
<span class="line-modified">!   assert(dest-&gt;is_in_cset_or_humongous(), &quot;Unexpected dest: &quot; CSETSTATE_FORMAT, dest-&gt;value());</span>
  
    // Right now we only have two types of regions (young / old) so
    // let&#39;s keep the logic here simple. We can generalize it when necessary.
    if (dest-&gt;is_young()) {
      bool plab_refill_in_old_failed = false;
<span class="line-modified">!     HeapWord* const obj_ptr = _plab_allocator-&gt;allocate(InCSetState::Old,</span>
                                                          word_sz,
<span class="line-modified">!                                                         &amp;plab_refill_in_old_failed);</span>
      // Make sure that we won&#39;t attempt to copy any other objects out
      // of a survivor region (given that apparently we cannot allocate
      // any new ones) to avoid coming into this slow path again and again.
      // Only consider failed PLAB refill here: failed inline allocations are
      // typically large, so not indicative of remaining space.
<span class="line-new-header">--- 159,25 ---</span>
      // Fully drain the queue.
      trim_queue_to_threshold(0);
    } while (!_refs-&gt;is_empty());
  }
  
<span class="line-modified">! HeapWord* G1ParScanThreadState::allocate_in_next_plab(G1HeapRegionAttr* dest,</span>
                                                        size_t word_sz,
<span class="line-modified">!                                                       bool previous_plab_refill_failed,</span>
<span class="line-modified">!                                                       uint node_index) {</span>
<span class="line-modified">! </span>
<span class="line-added">+   assert(dest-&gt;is_in_cset_or_humongous(), &quot;Unexpected dest: %s region attr&quot;, dest-&gt;get_type_str());</span>
  
    // Right now we only have two types of regions (young / old) so
    // let&#39;s keep the logic here simple. We can generalize it when necessary.
    if (dest-&gt;is_young()) {
      bool plab_refill_in_old_failed = false;
<span class="line-modified">!     HeapWord* const obj_ptr = _plab_allocator-&gt;allocate(G1HeapRegionAttr::Old,</span>
                                                          word_sz,
<span class="line-modified">!                                                         &amp;plab_refill_in_old_failed,</span>
<span class="line-added">+                                                         node_index);</span>
      // Make sure that we won&#39;t attempt to copy any other objects out
      // of a survivor region (given that apparently we cannot allocate
      // any new ones) to avoid coming into this slow path again and again.
      // Only consider failed PLAB refill here: failed inline allocations are
      // typically large, so not indicative of remaining space.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 188,76 ***</span>
        _old_gen_is_full = plab_refill_in_old_failed;
      }
      return obj_ptr;
    } else {
      _old_gen_is_full = previous_plab_refill_failed;
<span class="line-modified">!     assert(dest-&gt;is_old(), &quot;Unexpected dest: &quot; CSETSTATE_FORMAT, dest-&gt;value());</span>
      // no other space to try.
      return NULL;
    }
  }
  
<span class="line-modified">! InCSetState G1ParScanThreadState::next_state(InCSetState const state, markOop const m, uint&amp; age) {</span>
<span class="line-modified">!   if (state.is_young()) {</span>
<span class="line-modified">!     age = !m-&gt;has_displaced_mark_helper() ? m-&gt;age()</span>
<span class="line-modified">!                                           : m-&gt;displaced_mark_helper()-&gt;age();</span>
      if (age &lt; _tenuring_threshold) {
<span class="line-modified">!       return state;</span>
      }
    }
<span class="line-modified">!   return dest(state);</span>
  }
  
<span class="line-modified">! void G1ParScanThreadState::report_promotion_event(InCSetState const dest_state,</span>
                                                    oop const old, size_t word_sz, uint age,
<span class="line-modified">!                                                   HeapWord * const obj_ptr) const {</span>
<span class="line-modified">!   PLAB* alloc_buf = _plab_allocator-&gt;alloc_buffer(dest_state);</span>
    if (alloc_buf-&gt;contains(obj_ptr)) {
      _g1h-&gt;_gc_tracer_stw-&gt;report_promotion_in_new_plab_event(old-&gt;klass(), word_sz * HeapWordSize, age,
<span class="line-modified">!                                                              dest_state.value() == InCSetState::Old,</span>
                                                               alloc_buf-&gt;word_sz() * HeapWordSize);
    } else {
      _g1h-&gt;_gc_tracer_stw-&gt;report_promotion_outside_plab_event(old-&gt;klass(), word_sz * HeapWordSize, age,
<span class="line-modified">!                                                               dest_state.value() == InCSetState::Old);</span>
    }
  }
  
<span class="line-modified">! oop G1ParScanThreadState::copy_to_survivor_space(InCSetState const state,</span>
                                                   oop const old,
<span class="line-modified">!                                                  markOop const old_mark) {</span>
    const size_t word_sz = old-&gt;size();
<span class="line-removed">-   HeapRegion* const from_region = _g1h-&gt;heap_region_containing(old);</span>
<span class="line-removed">-   // +1 to make the -1 indexes valid...</span>
<span class="line-removed">-   const int young_index = from_region-&gt;young_index_in_cset()+1;</span>
<span class="line-removed">-   assert( (from_region-&gt;is_young() &amp;&amp; young_index &gt;  0) ||</span>
<span class="line-removed">-          (!from_region-&gt;is_young() &amp;&amp; young_index == 0), &quot;invariant&quot; );</span>
  
    uint age = 0;
<span class="line-modified">!   InCSetState dest_state = next_state(state, old_mark, age);</span>
    // The second clause is to prevent premature evacuation failure in case there
    // is still space in survivor, but old gen is full.
<span class="line-modified">!   if (_old_gen_is_full &amp;&amp; dest_state.is_old()) {</span>
      return handle_evacuation_failure_par(old, old_mark);
    }
<span class="line-modified">!   HeapWord* obj_ptr = _plab_allocator-&gt;plab_allocate(dest_state, word_sz);</span>
  
    // PLAB allocations should succeed most of the time, so we&#39;ll
    // normally check against NULL once and that&#39;s it.
    if (obj_ptr == NULL) {
      bool plab_refill_failed = false;
<span class="line-modified">!     obj_ptr = _plab_allocator-&gt;allocate_direct_or_new_plab(dest_state, word_sz, &amp;plab_refill_failed);</span>
      if (obj_ptr == NULL) {
<span class="line-modified">!       obj_ptr = allocate_in_next_plab(state, &amp;dest_state, word_sz, plab_refill_failed);</span>
        if (obj_ptr == NULL) {
          // This will either forward-to-self, or detect that someone else has
          // installed a forwarding pointer.
          return handle_evacuation_failure_par(old, old_mark);
        }
      }
      if (_g1h-&gt;_gc_tracer_stw-&gt;should_report_promotion_events()) {
        // The events are checked individually as part of the actual commit
<span class="line-modified">!       report_promotion_event(dest_state, old, word_sz, age, obj_ptr);</span>
      }
    }
  
    assert(obj_ptr != NULL, &quot;when we get here, allocation should have succeeded&quot;);
    assert(_g1h-&gt;is_in_reserved(obj_ptr), &quot;Allocated memory should be in the heap&quot;);
<span class="line-new-header">--- 193,77 ---</span>
        _old_gen_is_full = plab_refill_in_old_failed;
      }
      return obj_ptr;
    } else {
      _old_gen_is_full = previous_plab_refill_failed;
<span class="line-modified">!     assert(dest-&gt;is_old(), &quot;Unexpected dest region attr: %s&quot;, dest-&gt;get_type_str());</span>
      // no other space to try.
      return NULL;
    }
  }
  
<span class="line-modified">! G1HeapRegionAttr G1ParScanThreadState::next_region_attr(G1HeapRegionAttr const region_attr, markWord const m, uint&amp; age) {</span>
<span class="line-modified">!   if (region_attr.is_young()) {</span>
<span class="line-modified">!     age = !m.has_displaced_mark_helper() ? m.age()</span>
<span class="line-modified">!                                          : m.displaced_mark_helper().age();</span>
      if (age &lt; _tenuring_threshold) {
<span class="line-modified">!       return region_attr;</span>
      }
    }
<span class="line-modified">!   return dest(region_attr);</span>
  }
  
<span class="line-modified">! void G1ParScanThreadState::report_promotion_event(G1HeapRegionAttr const dest_attr,</span>
                                                    oop const old, size_t word_sz, uint age,
<span class="line-modified">!                                                   HeapWord * const obj_ptr, uint node_index) const {</span>
<span class="line-modified">!   PLAB* alloc_buf = _plab_allocator-&gt;alloc_buffer(dest_attr, node_index);</span>
    if (alloc_buf-&gt;contains(obj_ptr)) {
      _g1h-&gt;_gc_tracer_stw-&gt;report_promotion_in_new_plab_event(old-&gt;klass(), word_sz * HeapWordSize, age,
<span class="line-modified">!                                                              dest_attr.type() == G1HeapRegionAttr::Old,</span>
                                                               alloc_buf-&gt;word_sz() * HeapWordSize);
    } else {
      _g1h-&gt;_gc_tracer_stw-&gt;report_promotion_outside_plab_event(old-&gt;klass(), word_sz * HeapWordSize, age,
<span class="line-modified">!                                                               dest_attr.type() == G1HeapRegionAttr::Old);</span>
    }
  }
  
<span class="line-modified">! oop G1ParScanThreadState::copy_to_survivor_space(G1HeapRegionAttr const region_attr,</span>
                                                   oop const old,
<span class="line-modified">!                                                  markWord const old_mark) {</span>
    const size_t word_sz = old-&gt;size();
  
    uint age = 0;
<span class="line-modified">!   G1HeapRegionAttr dest_attr = next_region_attr(region_attr, old_mark, age);</span>
    // The second clause is to prevent premature evacuation failure in case there
    // is still space in survivor, but old gen is full.
<span class="line-modified">!   if (_old_gen_is_full &amp;&amp; dest_attr.is_old()) {</span>
      return handle_evacuation_failure_par(old, old_mark);
    }
<span class="line-modified">!   HeapRegion* const from_region = _g1h-&gt;heap_region_containing(old);</span>
<span class="line-added">+   uint node_index = from_region-&gt;node_index();</span>
<span class="line-added">+ </span>
<span class="line-added">+   HeapWord* obj_ptr = _plab_allocator-&gt;plab_allocate(dest_attr, word_sz, node_index);</span>
  
    // PLAB allocations should succeed most of the time, so we&#39;ll
    // normally check against NULL once and that&#39;s it.
    if (obj_ptr == NULL) {
      bool plab_refill_failed = false;
<span class="line-modified">!     obj_ptr = _plab_allocator-&gt;allocate_direct_or_new_plab(dest_attr, word_sz, &amp;plab_refill_failed, node_index);</span>
      if (obj_ptr == NULL) {
<span class="line-modified">!       assert(region_attr.is_in_cset(), &quot;Unexpected region attr type: %s&quot;, region_attr.get_type_str());</span>
<span class="line-added">+       obj_ptr = allocate_in_next_plab(&amp;dest_attr, word_sz, plab_refill_failed, node_index);</span>
        if (obj_ptr == NULL) {
          // This will either forward-to-self, or detect that someone else has
          // installed a forwarding pointer.
          return handle_evacuation_failure_par(old, old_mark);
        }
      }
<span class="line-added">+     update_numa_stats(node_index);</span>
<span class="line-added">+ </span>
      if (_g1h-&gt;_gc_tracer_stw-&gt;should_report_promotion_events()) {
        // The events are checked individually as part of the actual commit
<span class="line-modified">!       report_promotion_event(dest_attr, old, word_sz, age, obj_ptr, node_index);</span>
      }
    }
  
    assert(obj_ptr != NULL, &quot;when we get here, allocation should have succeeded&quot;);
    assert(_g1h-&gt;is_in_reserved(obj_ptr), &quot;Allocated memory should be in the heap&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 265,46 ***</span>
  #ifndef PRODUCT
    // Should this evacuation fail?
    if (_g1h-&gt;evacuation_should_fail()) {
      // Doing this after all the allocation attempts also tests the
      // undo_allocation() method too.
<span class="line-modified">!     _plab_allocator-&gt;undo_allocation(dest_state, obj_ptr, word_sz);</span>
      return handle_evacuation_failure_par(old, old_mark);
    }
  #endif // !PRODUCT
  
    // We&#39;re going to allocate linearly, so might as well prefetch ahead.
    Prefetch::write(obj_ptr, PrefetchCopyIntervalInBytes);
  
    const oop obj = oop(obj_ptr);
    const oop forward_ptr = old-&gt;forward_to_atomic(obj, old_mark, memory_order_relaxed);
    if (forward_ptr == NULL) {
<span class="line-modified">!     Copy::aligned_disjoint_words((HeapWord*) old, obj_ptr, word_sz);</span>
  
<span class="line-modified">!     if (dest_state.is_young()) {</span>
<span class="line-modified">!       if (age &lt; markOopDesc::max_age) {</span>
          age++;
        }
<span class="line-modified">!       if (old_mark-&gt;has_displaced_mark_helper()) {</span>
          // In this case, we have to install the mark word first,
          // otherwise obj looks to be forwarded (the old mark word,
          // which contains the forward pointer, was copied)
          obj-&gt;set_mark_raw(old_mark);
<span class="line-modified">!         markOop new_mark = old_mark-&gt;displaced_mark_helper()-&gt;set_age(age);</span>
<span class="line-modified">!         old_mark-&gt;set_displaced_mark_helper(new_mark);</span>
        } else {
<span class="line-modified">!         obj-&gt;set_mark_raw(old_mark-&gt;set_age(age));</span>
        }
        _age_table.add(age, word_sz);
      } else {
        obj-&gt;set_mark_raw(old_mark);
      }
  
      if (G1StringDedup::is_enabled()) {
<span class="line-modified">!       const bool is_from_young = state.is_young();</span>
<span class="line-modified">!       const bool is_to_young = dest_state.is_young();</span>
<span class="line-modified">!       assert(is_from_young == _g1h-&gt;heap_region_containing(old)-&gt;is_young(),</span>
               &quot;sanity&quot;);
        assert(is_to_young == _g1h-&gt;heap_region_containing(obj)-&gt;is_young(),
               &quot;sanity&quot;);
        G1StringDedup::enqueue_from_evacuation(is_from_young,
                                               is_to_young,
<span class="line-new-header">--- 271,51 ---</span>
  #ifndef PRODUCT
    // Should this evacuation fail?
    if (_g1h-&gt;evacuation_should_fail()) {
      // Doing this after all the allocation attempts also tests the
      // undo_allocation() method too.
<span class="line-modified">!     _plab_allocator-&gt;undo_allocation(dest_attr, obj_ptr, word_sz, node_index);</span>
      return handle_evacuation_failure_par(old, old_mark);
    }
  #endif // !PRODUCT
  
    // We&#39;re going to allocate linearly, so might as well prefetch ahead.
    Prefetch::write(obj_ptr, PrefetchCopyIntervalInBytes);
  
    const oop obj = oop(obj_ptr);
    const oop forward_ptr = old-&gt;forward_to_atomic(obj, old_mark, memory_order_relaxed);
    if (forward_ptr == NULL) {
<span class="line-modified">!     Copy::aligned_disjoint_words(cast_from_oop&lt;HeapWord*&gt;(old), obj_ptr, word_sz);</span>
<span class="line-added">+ </span>
<span class="line-added">+     const uint young_index = from_region-&gt;young_index_in_cset();</span>
  
<span class="line-modified">!     assert((from_region-&gt;is_young() &amp;&amp; young_index &gt;  0) ||</span>
<span class="line-modified">!            (!from_region-&gt;is_young() &amp;&amp; young_index == 0), &quot;invariant&quot; );</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (dest_attr.is_young()) {</span>
<span class="line-added">+       if (age &lt; markWord::max_age) {</span>
          age++;
        }
<span class="line-modified">!       if (old_mark.has_displaced_mark_helper()) {</span>
          // In this case, we have to install the mark word first,
          // otherwise obj looks to be forwarded (the old mark word,
          // which contains the forward pointer, was copied)
          obj-&gt;set_mark_raw(old_mark);
<span class="line-modified">!         markWord new_mark = old_mark.displaced_mark_helper().set_age(age);</span>
<span class="line-modified">!         old_mark.set_displaced_mark_helper(new_mark);</span>
        } else {
<span class="line-modified">!         obj-&gt;set_mark_raw(old_mark.set_age(age));</span>
        }
        _age_table.add(age, word_sz);
      } else {
        obj-&gt;set_mark_raw(old_mark);
      }
  
      if (G1StringDedup::is_enabled()) {
<span class="line-modified">!       const bool is_from_young = region_attr.is_young();</span>
<span class="line-modified">!       const bool is_to_young = dest_attr.is_young();</span>
<span class="line-modified">!       assert(is_from_young == from_region-&gt;is_young(),</span>
               &quot;sanity&quot;);
        assert(is_to_young == _g1h-&gt;heap_region_containing(obj)-&gt;is_young(),
               &quot;sanity&quot;);
        G1StringDedup::enqueue_from_evacuation(is_from_young,
                                               is_to_young,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 320,25 ***</span>
        // length field of the from-space object.
        arrayOop(obj)-&gt;set_length(0);
        oop* old_p = set_partial_array_mask(old);
        do_oop_partial_array(old_p);
      } else {
<span class="line-modified">!       G1ScanInYoungSetter x(&amp;_scanner, dest_state.is_young());</span>
        obj-&gt;oop_iterate_backwards(&amp;_scanner);
      }
      return obj;
    } else {
<span class="line-modified">!     _plab_allocator-&gt;undo_allocation(dest_state, obj_ptr, word_sz);</span>
      return forward_ptr;
    }
  }
  
  G1ParScanThreadState* G1ParScanThreadStateSet::state_for_worker(uint worker_id) {
    assert(worker_id &lt; _n_workers, &quot;out of bounds access&quot;);
    if (_states[worker_id] == NULL) {
      _states[worker_id] =
<span class="line-modified">!       new G1ParScanThreadState(_g1h, worker_id, _young_cset_length, _optional_cset_length);</span>
    }
    return _states[worker_id];
  }
  
  const size_t* G1ParScanThreadStateSet::surviving_young_words() const {
<span class="line-new-header">--- 331,25 ---</span>
        // length field of the from-space object.
        arrayOop(obj)-&gt;set_length(0);
        oop* old_p = set_partial_array_mask(old);
        do_oop_partial_array(old_p);
      } else {
<span class="line-modified">!       G1ScanInYoungSetter x(&amp;_scanner, dest_attr.is_young());</span>
        obj-&gt;oop_iterate_backwards(&amp;_scanner);
      }
      return obj;
    } else {
<span class="line-modified">!     _plab_allocator-&gt;undo_allocation(dest_attr, obj_ptr, word_sz, node_index);</span>
      return forward_ptr;
    }
  }
  
  G1ParScanThreadState* G1ParScanThreadStateSet::state_for_worker(uint worker_id) {
    assert(worker_id &lt; _n_workers, &quot;out of bounds access&quot;);
    if (_states[worker_id] == NULL) {
      _states[worker_id] =
<span class="line-modified">!       new G1ParScanThreadState(_g1h, _rdcqs, worker_id, _young_cset_length, _optional_cset_length);</span>
    }
    return _states[worker_id];
  }
  
  const size_t* G1ParScanThreadStateSet::surviving_young_words() const {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 347,20 ***</span>
  }
  
  void G1ParScanThreadStateSet::flush() {
    assert(!_flushed, &quot;thread local state from the per thread states should be flushed once&quot;);
  
<span class="line-modified">!   for (uint worker_index = 0; worker_index &lt; _n_workers; ++worker_index) {</span>
<span class="line-modified">!     G1ParScanThreadState* pss = _states[worker_index];</span>
  
      if (pss == NULL) {
        continue;
      }
  
<span class="line-modified">!     pss-&gt;flush(_surviving_young_words_total);</span>
      delete pss;
<span class="line-modified">!     _states[worker_index] = NULL;</span>
    }
    _flushed = true;
  }
  
  void G1ParScanThreadStateSet::record_unused_optional_region(HeapRegion* hr) {
<span class="line-new-header">--- 358,31 ---</span>
  }
  
  void G1ParScanThreadStateSet::flush() {
    assert(!_flushed, &quot;thread local state from the per thread states should be flushed once&quot;);
  
<span class="line-modified">!   for (uint worker_id = 0; worker_id &lt; _n_workers; ++worker_id) {</span>
<span class="line-modified">!     G1ParScanThreadState* pss = _states[worker_id];</span>
  
      if (pss == NULL) {
        continue;
      }
  
<span class="line-modified">!     G1GCPhaseTimes* p = _g1h-&gt;phase_times();</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Need to get the following two before the call to G1ParThreadScanState::flush()</span>
<span class="line-added">+     // because it resets the PLAB allocator where we get this info from.</span>
<span class="line-added">+     size_t lab_waste_bytes = pss-&gt;lab_waste_words() * HeapWordSize;</span>
<span class="line-added">+     size_t lab_undo_waste_bytes = pss-&gt;lab_undo_waste_words() * HeapWordSize;</span>
<span class="line-added">+     size_t copied_bytes = pss-&gt;flush(_surviving_young_words_total) * HeapWordSize;</span>
<span class="line-added">+ </span>
<span class="line-added">+     p-&gt;record_or_add_thread_work_item(G1GCPhaseTimes::MergePSS, worker_id, copied_bytes, G1GCPhaseTimes::MergePSSCopiedBytes);</span>
<span class="line-added">+     p-&gt;record_or_add_thread_work_item(G1GCPhaseTimes::MergePSS, worker_id, lab_waste_bytes, G1GCPhaseTimes::MergePSSLABWasteBytes);</span>
<span class="line-added">+     p-&gt;record_or_add_thread_work_item(G1GCPhaseTimes::MergePSS, worker_id, lab_undo_waste_bytes, G1GCPhaseTimes::MergePSSLABUndoWasteBytes);</span>
<span class="line-added">+ </span>
      delete pss;
<span class="line-modified">!     _states[worker_id] = NULL;</span>
    }
    _flushed = true;
  }
  
  void G1ParScanThreadStateSet::record_unused_optional_region(HeapRegion* hr) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 370,15 ***</span>
      if (pss == NULL) {
        continue;
      }
  
      size_t used_memory = pss-&gt;oops_into_optional_region(hr)-&gt;used_memory();
<span class="line-modified">!     _g1h-&gt;phase_times()-&gt;record_or_add_thread_work_item(G1GCPhaseTimes::OptScanRS, worker_index, used_memory, G1GCPhaseTimes::OptCSetUsedMemory);</span>
    }
  }
  
<span class="line-modified">! oop G1ParScanThreadState::handle_evacuation_failure_par(oop old, markOop m) {</span>
    assert(_g1h-&gt;is_in_cset(old), &quot;Object &quot; PTR_FORMAT &quot; should be in the CSet&quot;, p2i(old));
  
    oop forward_ptr = old-&gt;forward_to_atomic(old, m, memory_order_relaxed);
    if (forward_ptr == NULL) {
      // Forward-to-self succeeded. We are the &quot;owner&quot; of the object.
<span class="line-new-header">--- 392,15 ---</span>
      if (pss == NULL) {
        continue;
      }
  
      size_t used_memory = pss-&gt;oops_into_optional_region(hr)-&gt;used_memory();
<span class="line-modified">!     _g1h-&gt;phase_times()-&gt;record_or_add_thread_work_item(G1GCPhaseTimes::OptScanHR, worker_index, used_memory, G1GCPhaseTimes::ScanHRUsedMemory);</span>
    }
  }
  
<span class="line-modified">! oop G1ParScanThreadState::handle_evacuation_failure_par(oop old, markWord m) {</span>
    assert(_g1h-&gt;is_in_cset(old), &quot;Object &quot; PTR_FORMAT &quot; should be in the CSet&quot;, p2i(old));
  
    oop forward_ptr = old-&gt;forward_to_atomic(old, m, memory_order_relaxed);
    if (forward_ptr == NULL) {
      // Forward-to-self succeeded. We are the &quot;owner&quot; of the object.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 405,24 ***</span>
             p2i(old), p2i(forward_ptr));
      return forward_ptr;
    }
  }
  G1ParScanThreadStateSet::G1ParScanThreadStateSet(G1CollectedHeap* g1h,
                                                   uint n_workers,
                                                   size_t young_cset_length,
                                                   size_t optional_cset_length) :
      _g1h(g1h),
      _states(NEW_C_HEAP_ARRAY(G1ParScanThreadState*, n_workers, mtGC)),
<span class="line-modified">!     _surviving_young_words_total(NEW_C_HEAP_ARRAY(size_t, young_cset_length, mtGC)),</span>
      _young_cset_length(young_cset_length),
      _optional_cset_length(optional_cset_length),
      _n_workers(n_workers),
      _flushed(false) {
    for (uint i = 0; i &lt; n_workers; ++i) {
      _states[i] = NULL;
    }
<span class="line-modified">!   memset(_surviving_young_words_total, 0, young_cset_length * sizeof(size_t));</span>
  }
  
  G1ParScanThreadStateSet::~G1ParScanThreadStateSet() {
    assert(_flushed, &quot;thread local state from the per thread states should have been flushed&quot;);
    FREE_C_HEAP_ARRAY(G1ParScanThreadState*, _states);
<span class="line-new-header">--- 427,26 ---</span>
             p2i(old), p2i(forward_ptr));
      return forward_ptr;
    }
  }
  G1ParScanThreadStateSet::G1ParScanThreadStateSet(G1CollectedHeap* g1h,
<span class="line-added">+                                                  G1RedirtyCardsQueueSet* rdcqs,</span>
                                                   uint n_workers,
                                                   size_t young_cset_length,
                                                   size_t optional_cset_length) :
      _g1h(g1h),
<span class="line-added">+     _rdcqs(rdcqs),</span>
      _states(NEW_C_HEAP_ARRAY(G1ParScanThreadState*, n_workers, mtGC)),
<span class="line-modified">!     _surviving_young_words_total(NEW_C_HEAP_ARRAY(size_t, young_cset_length + 1, mtGC)),</span>
      _young_cset_length(young_cset_length),
      _optional_cset_length(optional_cset_length),
      _n_workers(n_workers),
      _flushed(false) {
    for (uint i = 0; i &lt; n_workers; ++i) {
      _states[i] = NULL;
    }
<span class="line-modified">!   memset(_surviving_young_words_total, 0, (young_cset_length + 1) * sizeof(size_t));</span>
  }
  
  G1ParScanThreadStateSet::~G1ParScanThreadStateSet() {
    assert(_flushed, &quot;thread local state from the per thread states should have been flushed&quot;);
    FREE_C_HEAP_ARRAY(G1ParScanThreadState*, _states);
</pre>
<center><a href="g1PageBasedVirtualSpace.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ParScanThreadState.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/g1/g1RemSet.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/g1/g1BarrierSet.hpp&quot;
  27 #include &quot;gc/g1/g1BlockOffsetTable.inline.hpp&quot;
  28 #include &quot;gc/g1/g1CardTable.inline.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added">  29 #include &quot;gc/g1/g1CardTableEntryClosure.hpp&quot;</span>
  30 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  31 #include &quot;gc/g1/g1ConcurrentRefine.hpp&quot;
  32 #include &quot;gc/g1/g1DirtyCardQueue.hpp&quot;
  33 #include &quot;gc/g1/g1FromCardCache.hpp&quot;
  34 #include &quot;gc/g1/g1GCPhaseTimes.hpp&quot;
  35 #include &quot;gc/g1/g1HotCardCache.hpp&quot;
  36 #include &quot;gc/g1/g1OopClosures.inline.hpp&quot;
  37 #include &quot;gc/g1/g1RootClosures.hpp&quot;
  38 #include &quot;gc/g1/g1RemSet.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added">  39 #include &quot;gc/g1/g1SharedDirtyCardQueue.hpp&quot;</span>
  40 #include &quot;gc/g1/heapRegion.inline.hpp&quot;
  41 #include &quot;gc/g1/heapRegionManager.inline.hpp&quot;
<a name="3" id="anc3"></a><span class="line-modified">  42 #include &quot;gc/g1/heapRegionRemSet.inline.hpp&quot;</span>
<span class="line-added">  43 #include &quot;gc/g1/sparsePRT.hpp&quot;</span>
  44 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
<a name="4" id="anc4"></a><span class="line-added">  45 #include &quot;gc/shared/ptrQueue.hpp&quot;</span>
  46 #include &quot;gc/shared/suspendibleThreadSet.hpp&quot;
  47 #include &quot;jfr/jfrEvents.hpp&quot;
  48 #include &quot;memory/iterator.hpp&quot;
  49 #include &quot;memory/resourceArea.hpp&quot;
  50 #include &quot;oops/access.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
<a name="5" id="anc5"></a><span class="line-added">  52 #include &quot;runtime/atomic.hpp&quot;</span>
  53 #include &quot;runtime/os.hpp&quot;
  54 #include &quot;utilities/align.hpp&quot;
  55 #include &quot;utilities/globalDefinitions.hpp&quot;
  56 #include &quot;utilities/stack.inline.hpp&quot;
  57 #include &quot;utilities/ticks.hpp&quot;
  58 
<a name="6" id="anc6"></a><span class="line-modified">  59 // Collects information about the overall heap root scan progress during an evacuation.</span>
<span class="line-added">  60 //</span>
<span class="line-added">  61 // Scanning the remembered sets works by first merging all sources of cards to be</span>
<span class="line-added">  62 // scanned (log buffers, hcc, remembered sets) into a single data structure to remove</span>
<span class="line-added">  63 // duplicates and simplify work distribution.</span>
<span class="line-added">  64 //</span>
<span class="line-added">  65 // During the following card scanning we not only scan this combined set of cards, but</span>
<span class="line-added">  66 // also remember that these were completely scanned. The following evacuation passes</span>
<span class="line-added">  67 // do not scan these cards again, and so need to be preserved across increments.</span>
<span class="line-added">  68 //</span>
<span class="line-added">  69 // The representation for all the cards to scan is the card table: cards can have</span>
<span class="line-added">  70 // one of three states during GC:</span>
<span class="line-added">  71 // - clean: these cards will not be scanned in this pass</span>
<span class="line-added">  72 // - dirty: these cards will be scanned in this pass</span>
<span class="line-added">  73 // - scanned: these cards have already been scanned in a previous pass</span>
<span class="line-added">  74 //</span>
<span class="line-added">  75 // After all evacuation is done, we reset the card table to clean.</span>
<span class="line-added">  76 //</span>
<span class="line-added">  77 // Work distribution occurs on &quot;chunk&quot; basis, i.e. contiguous ranges of cards. As an</span>
<span class="line-added">  78 // additional optimization, during card merging we remember which regions and which</span>
<span class="line-added">  79 // chunks actually contain cards to be scanned. Threads iterate only across these</span>
<span class="line-added">  80 // regions, and only compete for chunks containing any cards.</span>
<span class="line-added">  81 //</span>
<span class="line-added">  82 // Within these chunks, a worker scans the card table on &quot;blocks&quot; of cards, i.e.</span>
<span class="line-added">  83 // contiguous ranges of dirty cards to be scanned. These blocks are converted to actual</span>
<span class="line-added">  84 // memory ranges and then passed on to actual scanning.</span>
  85 class G1RemSetScanState : public CHeapObj&lt;mtGC&gt; {
<a name="7" id="anc7"></a><span class="line-added">  86   class G1DirtyRegions;</span>
<span class="line-added">  87 </span>
<span class="line-added">  88   size_t _max_regions;</span>
<span class="line-added">  89 </span>
<span class="line-added">  90   // Has this region that is part of the regions in the collection set been processed yet.</span>
<span class="line-added">  91   typedef bool G1RemsetIterState;</span>
<span class="line-added">  92 </span>
<span class="line-added">  93   G1RemsetIterState volatile* _collection_set_iter_state;</span>
<span class="line-added">  94 </span>
<span class="line-added">  95   // Card table iteration claim for each heap region, from 0 (completely unscanned)</span>
<span class="line-added">  96   // to (&gt;=) HeapRegion::CardsPerRegion (completely scanned).</span>
<span class="line-added">  97   uint volatile* _card_table_scan_state;</span>
<span class="line-added">  98 </span>
<span class="line-added">  99   // Return &quot;optimal&quot; number of chunks per region we want to use for claiming areas</span>
<span class="line-added"> 100   // within a region to claim. Dependent on the region size as proxy for the heap</span>
<span class="line-added"> 101   // size, we limit the total number of chunks to limit memory usage and maintenance</span>
<span class="line-added"> 102   // effort of that table vs. granularity of distributing scanning work.</span>
<span class="line-added"> 103   // Testing showed that 8 for 1M/2M region, 16 for 4M/8M regions, 32 for 16/32M regions</span>
<span class="line-added"> 104   // seems to be such a good trade-off.</span>
<span class="line-added"> 105   static uint get_chunks_per_region(uint log_region_size) {</span>
<span class="line-added"> 106     // Limit the expected input values to current known possible values of the</span>
<span class="line-added"> 107     // (log) region size. Adjust as necessary after testing if changing the permissible</span>
<span class="line-added"> 108     // values for region size.</span>
<span class="line-added"> 109     assert(log_region_size &gt;= 20 &amp;&amp; log_region_size &lt;= 25,</span>
<span class="line-added"> 110            &quot;expected value in [20,25], but got %u&quot;, log_region_size);</span>
<span class="line-added"> 111     return 1u &lt;&lt; (log_region_size / 2 - 7);</span>
<span class="line-added"> 112   }</span>
<span class="line-added"> 113 </span>
<span class="line-added"> 114   uint _scan_chunks_per_region;         // Number of chunks per region.</span>
<span class="line-added"> 115   uint8_t _log_scan_chunks_per_region;  // Log of number of chunks per region.</span>
<span class="line-added"> 116   bool* _region_scan_chunks;</span>
<span class="line-added"> 117   size_t _num_total_scan_chunks;        // Total number of elements in _region_scan_chunks.</span>
<span class="line-added"> 118   uint8_t _scan_chunks_shift;           // For conversion between card index and chunk index.</span>
<span class="line-added"> 119 public:</span>
<span class="line-added"> 120   uint scan_chunk_size() const { return (uint)1 &lt;&lt; _scan_chunks_shift; }</span>
<span class="line-added"> 121 </span>
<span class="line-added"> 122   // Returns whether the chunk corresponding to the given region/card in region contain a</span>
<span class="line-added"> 123   // dirty card, i.e. actually needs scanning.</span>
<span class="line-added"> 124   bool chunk_needs_scan(uint const region_idx, uint const card_in_region) const {</span>
<span class="line-added"> 125     size_t const idx = ((size_t)region_idx &lt;&lt; _log_scan_chunks_per_region) + (card_in_region &gt;&gt; _scan_chunks_shift);</span>
<span class="line-added"> 126     assert(idx &lt; _num_total_scan_chunks, &quot;Index &quot; SIZE_FORMAT &quot; out of bounds &quot; SIZE_FORMAT,</span>
<span class="line-added"> 127            idx, _num_total_scan_chunks);</span>
<span class="line-added"> 128     return _region_scan_chunks[idx];</span>
<span class="line-added"> 129   }</span>
<span class="line-added"> 130 </span>
 131 private:
<a name="8" id="anc8"></a><span class="line-added"> 132   // The complete set of regions which card table needs to be cleared at the end of GC because</span>
<span class="line-added"> 133   // we scribbled all over them.</span>
<span class="line-added"> 134   G1DirtyRegions* _all_dirty_regions;</span>
<span class="line-added"> 135   // The set of regions which card table needs to be scanned for new dirty cards</span>
<span class="line-added"> 136   // in the current evacuation pass.</span>
<span class="line-added"> 137   G1DirtyRegions* _next_dirty_regions;</span>
<span class="line-added"> 138 </span>
<span class="line-added"> 139   // Set of (unique) regions that can be added to concurrently.</span>
<span class="line-added"> 140   class G1DirtyRegions : public CHeapObj&lt;mtGC&gt; {</span>
<span class="line-added"> 141     uint* _buffer;</span>
<span class="line-added"> 142     uint _cur_idx;</span>
<span class="line-added"> 143     size_t _max_regions;</span>
<span class="line-added"> 144 </span>
<span class="line-added"> 145     bool* _contains;</span>
<span class="line-added"> 146 </span>
<span class="line-added"> 147   public:</span>
<span class="line-added"> 148     G1DirtyRegions(size_t max_regions) :</span>
<span class="line-added"> 149       _buffer(NEW_C_HEAP_ARRAY(uint, max_regions, mtGC)),</span>
<span class="line-added"> 150       _cur_idx(0),</span>
<span class="line-added"> 151       _max_regions(max_regions),</span>
<span class="line-added"> 152       _contains(NEW_C_HEAP_ARRAY(bool, max_regions, mtGC)) {</span>
<span class="line-added"> 153 </span>
<span class="line-added"> 154       reset();</span>
<span class="line-added"> 155     }</span>
<span class="line-added"> 156 </span>
<span class="line-added"> 157     static size_t chunk_size() { return M; }</span>
<span class="line-added"> 158 </span>
<span class="line-added"> 159     ~G1DirtyRegions() {</span>
<span class="line-added"> 160       FREE_C_HEAP_ARRAY(uint, _buffer);</span>
<span class="line-added"> 161       FREE_C_HEAP_ARRAY(bool, _contains);</span>
<span class="line-added"> 162     }</span>
<span class="line-added"> 163 </span>
<span class="line-added"> 164     void reset() {</span>
<span class="line-added"> 165       _cur_idx = 0;</span>
<span class="line-added"> 166       ::memset(_contains, false, _max_regions * sizeof(bool));</span>
<span class="line-added"> 167     }</span>
<span class="line-added"> 168 </span>
<span class="line-added"> 169     uint size() const { return _cur_idx; }</span>
<span class="line-added"> 170 </span>
<span class="line-added"> 171     uint at(uint idx) const {</span>
<span class="line-added"> 172       assert(idx &lt; _cur_idx, &quot;Index %u beyond valid regions&quot;, idx);</span>
<span class="line-added"> 173       return _buffer[idx];</span>
<span class="line-added"> 174     }</span>
<span class="line-added"> 175 </span>
<span class="line-added"> 176     void add_dirty_region(uint region) {</span>
<span class="line-added"> 177       if (_contains[region]) {</span>
<span class="line-added"> 178         return;</span>
<span class="line-added"> 179       }</span>
<span class="line-added"> 180 </span>
<span class="line-added"> 181       bool marked_as_dirty = Atomic::cmpxchg(&amp;_contains[region], false, true) == false;</span>
<span class="line-added"> 182       if (marked_as_dirty) {</span>
<span class="line-added"> 183         uint allocated = Atomic::fetch_and_add(&amp;_cur_idx, 1u);</span>
<span class="line-added"> 184         _buffer[allocated] = region;</span>
<span class="line-added"> 185       }</span>
<span class="line-added"> 186     }</span>
<span class="line-added"> 187 </span>
<span class="line-added"> 188     // Creates the union of this and the other G1DirtyRegions.</span>
<span class="line-added"> 189     void merge(const G1DirtyRegions* other) {</span>
<span class="line-added"> 190       for (uint i = 0; i &lt; other-&gt;size(); i++) {</span>
<span class="line-added"> 191         uint region = other-&gt;at(i);</span>
<span class="line-added"> 192         if (!_contains[region]) {</span>
<span class="line-added"> 193           _buffer[_cur_idx++] = region;</span>
<span class="line-added"> 194           _contains[region] = true;</span>
<span class="line-added"> 195         }</span>
<span class="line-added"> 196       }</span>
<span class="line-added"> 197     }</span>
<span class="line-added"> 198   };</span>
<span class="line-added"> 199 </span>
<span class="line-added"> 200   // For each region, contains the maximum top() value to be used during this garbage</span>
<span class="line-added"> 201   // collection. Subsumes common checks like filtering out everything but old and</span>
<span class="line-added"> 202   // humongous regions outside the collection set.</span>
<span class="line-added"> 203   // This is valid because we are not interested in scanning stray remembered set</span>
<span class="line-added"> 204   // entries from free or archive regions.</span>
<span class="line-added"> 205   HeapWord** _scan_top;</span>
<span class="line-added"> 206 </span>
 207   class G1ClearCardTableTask : public AbstractGangTask {
 208     G1CollectedHeap* _g1h;
<a name="9" id="anc9"></a><span class="line-modified"> 209     G1DirtyRegions* _regions;</span>
<span class="line-modified"> 210     uint _chunk_length;</span>
<span class="line-modified"> 211 </span>
<span class="line-added"> 212     uint volatile _cur_dirty_regions;</span>
<span class="line-added"> 213 </span>
<span class="line-added"> 214     G1RemSetScanState* _scan_state;</span>
 215 
<a name="10" id="anc10"></a>
 216   public:
 217     G1ClearCardTableTask(G1CollectedHeap* g1h,
<a name="11" id="anc11"></a><span class="line-modified"> 218                          G1DirtyRegions* regions,</span>
<span class="line-modified"> 219                          uint chunk_length,</span>
<span class="line-modified"> 220                          G1RemSetScanState* scan_state) :</span>
 221       AbstractGangTask(&quot;G1 Clear Card Table Task&quot;),
 222       _g1h(g1h),
<a name="12" id="anc12"></a><span class="line-modified"> 223       _regions(regions),</span>

 224       _chunk_length(chunk_length),
<a name="13" id="anc13"></a><span class="line-modified"> 225       _cur_dirty_regions(0),</span>
<span class="line-added"> 226       _scan_state(scan_state) {</span>
 227 
 228       assert(chunk_length &gt; 0, &quot;must be&quot;);
 229     }
 230 
<a name="14" id="anc14"></a><span class="line-modified"> 231     static uint chunk_size() { return M; }</span>
 232 
 233     void work(uint worker_id) {
<a name="15" id="anc15"></a><span class="line-modified"> 234       while (_cur_dirty_regions &lt; _regions-&gt;size()) {</span>
<span class="line-modified"> 235         uint next = Atomic::fetch_and_add(&amp;_cur_dirty_regions, _chunk_length);</span>
<span class="line-modified"> 236         uint max = MIN2(next + _chunk_length, _regions-&gt;size());</span>
 237 
<a name="16" id="anc16"></a><span class="line-modified"> 238         for (uint i = next; i &lt; max; i++) {</span>
<span class="line-modified"> 239           HeapRegion* r = _g1h-&gt;region_at(_regions-&gt;at(i));</span>
 240           if (!r-&gt;is_survivor()) {
 241             r-&gt;clear_cardtable();
 242           }
 243         }
 244       }
 245     }
 246   };
 247 
<a name="17" id="anc17"></a><span class="line-modified"> 248   // Clear the card table of &quot;dirty&quot; regions.</span>
<span class="line-modified"> 249   void clear_card_table(WorkGang* workers) {</span>
<span class="line-modified"> 250     uint num_regions = _all_dirty_regions-&gt;size();</span>






























 251 
<a name="18" id="anc18"></a><span class="line-modified"> 252     if (num_regions == 0) {</span>
<span class="line-modified"> 253       return;</span>






 254     }
<a name="19" id="anc19"></a>
 255 
<a name="20" id="anc20"></a><span class="line-modified"> 256     uint const num_chunks = (uint)(align_up((size_t)num_regions &lt;&lt; HeapRegion::LogCardsPerRegion, G1ClearCardTableTask::chunk_size()) / G1ClearCardTableTask::chunk_size());</span>
<span class="line-modified"> 257     uint const num_workers = MIN2(num_chunks, workers-&gt;active_workers());</span>
<span class="line-modified"> 258     uint const chunk_length = G1ClearCardTableTask::chunk_size() / (uint)HeapRegion::CardsPerRegion;</span>
<span class="line-modified"> 259 </span>
<span class="line-modified"> 260     // Iterate over the dirty cards region list.</span>
<span class="line-modified"> 261     G1ClearCardTableTask cl(G1CollectedHeap::heap(), _all_dirty_regions, chunk_length, this);</span>
<span class="line-added"> 262 </span>
<span class="line-added"> 263     log_debug(gc, ergo)(&quot;Running %s using %u workers for %u &quot;</span>
<span class="line-added"> 264                         &quot;units of work for %u regions.&quot;,</span>
<span class="line-added"> 265                         cl.name(), num_workers, num_chunks, num_regions);</span>
<span class="line-added"> 266     workers-&gt;run_task(&amp;cl, num_workers);</span>
<span class="line-added"> 267 </span>
<span class="line-added"> 268 #ifndef PRODUCT</span>
<span class="line-added"> 269     G1CollectedHeap::heap()-&gt;verifier()-&gt;verify_card_table_cleanup();</span>
<span class="line-added"> 270 #endif</span>
<span class="line-added"> 271   }</span>
<span class="line-added"> 272 </span>
 273 public:
 274   G1RemSetScanState() :
 275     _max_regions(0),
<a name="21" id="anc21"></a><span class="line-modified"> 276     _collection_set_iter_state(NULL),</span>
<span class="line-modified"> 277     _card_table_scan_state(NULL),</span>
<span class="line-modified"> 278     _scan_chunks_per_region(get_chunks_per_region(HeapRegion::LogOfHRGrainBytes)),</span>
<span class="line-modified"> 279     _log_scan_chunks_per_region(log2_uint(_scan_chunks_per_region)),</span>
<span class="line-modified"> 280     _region_scan_chunks(NULL),</span>
<span class="line-added"> 281     _num_total_scan_chunks(0),</span>
<span class="line-added"> 282     _scan_chunks_shift(0),</span>
<span class="line-added"> 283     _all_dirty_regions(NULL),</span>
<span class="line-added"> 284     _next_dirty_regions(NULL),</span>
 285     _scan_top(NULL) {
 286   }
 287 
 288   ~G1RemSetScanState() {
<a name="22" id="anc22"></a><span class="line-modified"> 289     FREE_C_HEAP_ARRAY(G1RemsetIterState, _collection_set_iter_state);</span>
<span class="line-modified"> 290     FREE_C_HEAP_ARRAY(uint, _card_table_scan_state);</span>
<span class="line-modified"> 291     FREE_C_HEAP_ARRAY(bool, _region_scan_chunks);</span>
<span class="line-modified"> 292     FREE_C_HEAP_ARRAY(HeapWord*, _scan_top);</span>











 293   }
 294 
<a name="23" id="anc23"></a><span class="line-modified"> 295   void initialize(size_t max_regions) {</span>
<span class="line-modified"> 296     assert(_collection_set_iter_state == NULL, &quot;Must not be initialized twice&quot;);</span>

 297     _max_regions = max_regions;
<a name="24" id="anc24"></a><span class="line-modified"> 298     _collection_set_iter_state = NEW_C_HEAP_ARRAY(G1RemsetIterState, max_regions, mtGC);</span>
<span class="line-modified"> 299     _card_table_scan_state = NEW_C_HEAP_ARRAY(uint, max_regions, mtGC);</span>
<span class="line-modified"> 300     _num_total_scan_chunks = max_regions * _scan_chunks_per_region;</span>
<span class="line-modified"> 301     _region_scan_chunks = NEW_C_HEAP_ARRAY(bool, _num_total_scan_chunks, mtGC);</span>
<span class="line-added"> 302 </span>
<span class="line-added"> 303     _scan_chunks_shift = (uint8_t)log2_intptr(HeapRegion::CardsPerRegion / _scan_chunks_per_region);</span>
 304     _scan_top = NEW_C_HEAP_ARRAY(HeapWord*, max_regions, mtGC);
 305   }
 306 
<a name="25" id="anc25"></a><span class="line-modified"> 307   void prepare() {</span>
<span class="line-modified"> 308     // Reset the claim and clear scan top for all regions, including</span>
<span class="line-modified"> 309     // regions currently not available or free. Since regions might</span>
<span class="line-modified"> 310     // become used during the collection these values must be valid</span>
<span class="line-added"> 311     // for those regions as well.</span>
<span class="line-added"> 312     for (size_t i = 0; i &lt; _max_regions; i++) {</span>
<span class="line-added"> 313       reset_region_claim((uint)i);</span>
<span class="line-added"> 314       clear_scan_top((uint)i);</span>
 315     }
 316 
<a name="26" id="anc26"></a><span class="line-modified"> 317     _all_dirty_regions = new G1DirtyRegions(_max_regions);</span>
<span class="line-modified"> 318     _next_dirty_regions = new G1DirtyRegions(_max_regions);</span>




 319   }
 320 
<a name="27" id="anc27"></a><span class="line-modified"> 321   void prepare_for_merge_heap_roots() {</span>
<span class="line-modified"> 322     _all_dirty_regions-&gt;merge(_next_dirty_regions);</span>
<span class="line-modified"> 323 </span>
<span class="line-modified"> 324     _next_dirty_regions-&gt;reset();</span>
<span class="line-modified"> 325     for (size_t i = 0; i &lt; _max_regions; i++) {</span>
<span class="line-modified"> 326       _card_table_scan_state[i] = 0;</span>
 327     }
<a name="28" id="anc28"></a><span class="line-modified"> 328 </span>
<span class="line-modified"> 329     ::memset(_region_scan_chunks, false, _num_total_scan_chunks * sizeof(*_region_scan_chunks));</span>
 330   }
 331 
<a name="29" id="anc29"></a><span class="line-modified"> 332   // Returns whether the given region contains cards we need to scan. The remembered</span>
<span class="line-modified"> 333   // set and other sources may contain cards that</span>
<span class="line-modified"> 334   // - are in uncommitted regions</span>
<span class="line-modified"> 335   // - are located in the collection set</span>
<span class="line-modified"> 336   // - are located in free regions</span>
<span class="line-added"> 337   // as we do not clean up remembered sets before merging heap roots.</span>
<span class="line-added"> 338   bool contains_cards_to_process(uint const region_idx) const {</span>
<span class="line-added"> 339     HeapRegion* hr = G1CollectedHeap::heap()-&gt;region_at_or_null(region_idx);</span>
<span class="line-added"> 340     return (hr != NULL &amp;&amp; !hr-&gt;in_collection_set() &amp;&amp; hr-&gt;is_old_or_humongous_or_archive());</span>
<span class="line-added"> 341   }</span>
<span class="line-added"> 342 </span>
<span class="line-added"> 343   size_t num_visited_cards() const {</span>
<span class="line-added"> 344     size_t result = 0;</span>
<span class="line-added"> 345     for (uint i = 0; i &lt; _num_total_scan_chunks; i++) {</span>
<span class="line-added"> 346       if (_region_scan_chunks[i]) {</span>
<span class="line-added"> 347         result++;</span>
<span class="line-added"> 348       }</span>
 349     }
<a name="30" id="anc30"></a><span class="line-modified"> 350     return result * (HeapRegion::CardsPerRegion / _scan_chunks_per_region);</span>

 351   }
 352 
<a name="31" id="anc31"></a><span class="line-modified"> 353   size_t num_cards_in_dirty_regions() const {</span>
<span class="line-modified"> 354     return _next_dirty_regions-&gt;size() * HeapRegion::CardsPerRegion;</span>


 355   }
 356 
<a name="32" id="anc32"></a><span class="line-modified"> 357   void set_chunk_region_dirty(size_t const region_card_idx) {</span>
<span class="line-modified"> 358     size_t chunk_idx = region_card_idx &gt;&gt; _scan_chunks_shift;</span>
<span class="line-modified"> 359     for (uint i = 0; i &lt; _scan_chunks_per_region; i++) {</span>
<span class="line-modified"> 360       _region_scan_chunks[chunk_idx++] = true;</span>
<span class="line-added"> 361     }</span>
 362   }
 363 
<a name="33" id="anc33"></a><span class="line-modified"> 364   void set_chunk_dirty(size_t const card_idx) {</span>
<span class="line-modified"> 365     assert((card_idx &gt;&gt; _scan_chunks_shift) &lt; _num_total_scan_chunks,</span>
<span class="line-modified"> 366            &quot;Trying to access index &quot; SIZE_FORMAT &quot; out of bounds &quot; SIZE_FORMAT,</span>
<span class="line-modified"> 367            card_idx &gt;&gt; _scan_chunks_shift, _num_total_scan_chunks);</span>
<span class="line-added"> 368     size_t const chunk_idx = card_idx &gt;&gt; _scan_chunks_shift;</span>
<span class="line-added"> 369     if (!_region_scan_chunks[chunk_idx]) {</span>
<span class="line-added"> 370       _region_scan_chunks[chunk_idx] = true;</span>
<span class="line-added"> 371     }</span>
<span class="line-added"> 372   }</span>
<span class="line-added"> 373 </span>
<span class="line-added"> 374   void cleanup(WorkGang* workers) {</span>
<span class="line-added"> 375     _all_dirty_regions-&gt;merge(_next_dirty_regions);</span>
<span class="line-added"> 376 </span>
<span class="line-added"> 377     clear_card_table(workers);</span>
<span class="line-added"> 378 </span>
<span class="line-added"> 379     delete _all_dirty_regions;</span>
<span class="line-added"> 380     _all_dirty_regions = NULL;</span>
<span class="line-added"> 381 </span>
<span class="line-added"> 382     delete _next_dirty_regions;</span>
<span class="line-added"> 383     _next_dirty_regions = NULL;</span>
 384   }
 385 
<a name="34" id="anc34"></a><span class="line-modified"> 386   void iterate_dirty_regions_from(HeapRegionClosure* cl, uint worker_id) {</span>
<span class="line-modified"> 387     uint num_regions = _next_dirty_regions-&gt;size();</span>
<span class="line-added"> 388 </span>
<span class="line-added"> 389     if (num_regions == 0) {</span>
 390       return;
 391     }
 392 
<a name="35" id="anc35"></a><span class="line-modified"> 393     G1CollectedHeap* g1h = G1CollectedHeap::heap();</span>
<span class="line-modified"> 394 </span>
<span class="line-modified"> 395     WorkGang* workers = g1h-&gt;workers();</span>
<span class="line-modified"> 396     uint const max_workers = workers-&gt;active_workers();</span>
<span class="line-added"> 397 </span>
<span class="line-added"> 398     uint const start_pos = num_regions * worker_id / max_workers;</span>
<span class="line-added"> 399     uint cur = start_pos;</span>
<span class="line-added"> 400 </span>
<span class="line-added"> 401     do {</span>
<span class="line-added"> 402       bool result = cl-&gt;do_heap_region(g1h-&gt;region_at(_next_dirty_regions-&gt;at(cur)));</span>
<span class="line-added"> 403       guarantee(!result, &quot;Not allowed to ask for early termination.&quot;);</span>
<span class="line-added"> 404       cur++;</span>
<span class="line-added"> 405       if (cur == _next_dirty_regions-&gt;size()) {</span>
<span class="line-added"> 406         cur = 0;</span>
<span class="line-added"> 407       }</span>
<span class="line-added"> 408     } while (cur != start_pos);</span>
 409   }
 410 
<a name="36" id="anc36"></a><span class="line-modified"> 411   void reset_region_claim(uint region_idx) {</span>
<span class="line-modified"> 412     _collection_set_iter_state[region_idx] = false;</span>
 413   }
 414 
<a name="37" id="anc37"></a><span class="line-modified"> 415   // Attempt to claim the given region in the collection set for iteration. Returns true</span>
<span class="line-modified"> 416   // if this call caused the transition from Unclaimed to Claimed.</span>
<span class="line-modified"> 417   inline bool claim_collection_set_region(uint region) {</span>
<span class="line-modified"> 418     assert(region &lt; _max_regions, &quot;Tried to access invalid region %u&quot;, region);</span>
<span class="line-added"> 419     if (_collection_set_iter_state[region]) {</span>
<span class="line-added"> 420       return false;</span>
 421     }
<a name="38" id="anc38"></a><span class="line-added"> 422     return !Atomic::cmpxchg(&amp;_collection_set_iter_state[region], false, true);</span>
<span class="line-added"> 423   }</span>
 424 
<a name="39" id="anc39"></a><span class="line-modified"> 425   bool has_cards_to_scan(uint region) {</span>
<span class="line-modified"> 426     assert(region &lt; _max_regions, &quot;Tried to access invalid region %u&quot;, region);</span>
<span class="line-modified"> 427     return _card_table_scan_state[region] &lt; HeapRegion::CardsPerRegion;</span>
<span class="line-added"> 428   }</span>
 429 
<a name="40" id="anc40"></a><span class="line-modified"> 430   uint claim_cards_to_scan(uint region, uint increment) {</span>
<span class="line-modified"> 431     assert(region &lt; _max_regions, &quot;Tried to access invalid region %u&quot;, region);</span>
<span class="line-added"> 432     return Atomic::fetch_and_add(&amp;_card_table_scan_state[region], increment);</span>
<span class="line-added"> 433   }</span>
 434 
<a name="41" id="anc41"></a><span class="line-modified"> 435   void add_dirty_region(uint const region) {</span>
<span class="line-modified"> 436 #ifdef ASSERT</span>
<span class="line-modified"> 437    HeapRegion* hr = G1CollectedHeap::heap()-&gt;region_at(region);</span>
<span class="line-modified"> 438    assert(!hr-&gt;in_collection_set() &amp;&amp; hr-&gt;is_old_or_humongous_or_archive(),</span>
<span class="line-added"> 439           &quot;Region %u is not suitable for scanning, is %sin collection set or %s&quot;,</span>
<span class="line-added"> 440           hr-&gt;hrm_index(), hr-&gt;in_collection_set() ? &quot;&quot; : &quot;not &quot;, hr-&gt;get_short_type_str());</span>
<span class="line-added"> 441 #endif</span>
<span class="line-added"> 442     _next_dirty_regions-&gt;add_dirty_region(region);</span>
<span class="line-added"> 443   }</span>
 444 
<a name="42" id="anc42"></a><span class="line-modified"> 445   void add_all_dirty_region(uint region) {</span>
<span class="line-modified"> 446 #ifdef ASSERT</span>
<span class="line-added"> 447     HeapRegion* hr = G1CollectedHeap::heap()-&gt;region_at(region);</span>
<span class="line-added"> 448     assert(hr-&gt;in_collection_set(),</span>
<span class="line-added"> 449            &quot;Only add young regions to all dirty regions directly but %u is %s&quot;,</span>
<span class="line-added"> 450            hr-&gt;hrm_index(), hr-&gt;get_short_type_str());</span>
 451 #endif
<a name="43" id="anc43"></a><span class="line-added"> 452     _all_dirty_regions-&gt;add_dirty_region(region);</span>
<span class="line-added"> 453   }</span>
<span class="line-added"> 454 </span>
<span class="line-added"> 455   void set_scan_top(uint region_idx, HeapWord* value) {</span>
<span class="line-added"> 456     _scan_top[region_idx] = value;</span>
<span class="line-added"> 457   }</span>
<span class="line-added"> 458 </span>
<span class="line-added"> 459   HeapWord* scan_top(uint region_idx) const {</span>
<span class="line-added"> 460     return _scan_top[region_idx];</span>
<span class="line-added"> 461   }</span>
<span class="line-added"> 462 </span>
<span class="line-added"> 463   void clear_scan_top(uint region_idx) {</span>
<span class="line-added"> 464     set_scan_top(region_idx, NULL);</span>
 465   }
 466 };
 467 
 468 G1RemSet::G1RemSet(G1CollectedHeap* g1h,
 469                    G1CardTable* ct,
 470                    G1HotCardCache* hot_card_cache) :
 471   _scan_state(new G1RemSetScanState()),
<a name="44" id="anc44"></a><span class="line-modified"> 472   _prev_period_summary(false),</span>
 473   _g1h(g1h),
<a name="45" id="anc45"></a>
 474   _ct(ct),
 475   _g1p(_g1h-&gt;policy()),
 476   _hot_card_cache(hot_card_cache) {
 477 }
 478 
 479 G1RemSet::~G1RemSet() {
<a name="46" id="anc46"></a><span class="line-modified"> 480   delete _scan_state;</span>


 481 }
 482 
 483 uint G1RemSet::num_par_rem_sets() {
 484   return G1DirtyCardQueueSet::num_par_ids() + G1ConcurrentRefine::max_num_threads() + MAX2(ConcGCThreads, ParallelGCThreads);
 485 }
 486 
 487 void G1RemSet::initialize(size_t capacity, uint max_regions) {
 488   G1FromCardCache::initialize(num_par_rem_sets(), max_regions);
 489   _scan_state-&gt;initialize(max_regions);
 490 }
 491 
<a name="47" id="anc47"></a><span class="line-modified"> 492 // Helper class to scan and detect ranges of cards that need to be scanned on the</span>
<span class="line-modified"> 493 // card table.</span>
<span class="line-modified"> 494 class G1CardTableScanner : public StackObj {</span>
<span class="line-modified"> 495 public:</span>
<span class="line-modified"> 496   typedef CardTable::CardValue CardValue;</span>















 497 
<a name="48" id="anc48"></a><span class="line-modified"> 498 private:</span>
<span class="line-modified"> 499   CardValue* const _base_addr;</span>


 500 
<a name="49" id="anc49"></a><span class="line-modified"> 501   CardValue* _cur_addr;</span>
<span class="line-modified"> 502   CardValue* const _end_addr;</span>





 503 
<a name="50" id="anc50"></a><span class="line-modified"> 504   static const size_t ToScanMask = G1CardTable::g1_card_already_scanned;</span>
<span class="line-modified"> 505   static const size_t ExpandedToScanMask = G1CardTable::WordAlreadyScanned;</span>

 506 
<a name="51" id="anc51"></a><span class="line-modified"> 507   bool cur_addr_aligned() const {</span>
<span class="line-modified"> 508     return ((uintptr_t)_cur_addr) % sizeof(size_t) == 0;</span>



 509   }
 510 
<a name="52" id="anc52"></a><span class="line-modified"> 511   bool cur_card_is_dirty() const {</span>
<span class="line-modified"> 512     CardValue value = *_cur_addr;</span>
<span class="line-added"> 513     return (value &amp; ToScanMask) == 0;</span>
<span class="line-added"> 514   }</span>
<span class="line-added"> 515 </span>
<span class="line-added"> 516   bool cur_word_of_cards_contains_any_dirty_card() const {</span>
<span class="line-added"> 517     assert(cur_addr_aligned(), &quot;Current address should be aligned&quot;);</span>
<span class="line-added"> 518     size_t const value = *(size_t*)_cur_addr;</span>
<span class="line-added"> 519     return (~value &amp; ExpandedToScanMask) != 0;</span>
<span class="line-added"> 520   }</span>
<span class="line-added"> 521 </span>
<span class="line-added"> 522   bool cur_word_of_cards_all_dirty_cards() const {</span>
<span class="line-added"> 523     size_t const value = *(size_t*)_cur_addr;</span>
<span class="line-added"> 524     return value == G1CardTable::WordAllDirty;</span>
<span class="line-added"> 525   }</span>
<span class="line-added"> 526 </span>
<span class="line-added"> 527   size_t get_and_advance_pos() {</span>
<span class="line-added"> 528     _cur_addr++;</span>
<span class="line-added"> 529     return pointer_delta(_cur_addr, _base_addr, sizeof(CardValue)) - 1;</span>
<span class="line-added"> 530   }</span>
<span class="line-added"> 531 </span>
<span class="line-added"> 532 public:</span>
<span class="line-added"> 533   G1CardTableScanner(CardValue* start_card, size_t size) :</span>
<span class="line-added"> 534     _base_addr(start_card),</span>
<span class="line-added"> 535     _cur_addr(start_card),</span>
<span class="line-added"> 536     _end_addr(start_card + size) {</span>
<span class="line-added"> 537 </span>
<span class="line-added"> 538     assert(is_aligned(start_card, sizeof(size_t)), &quot;Unaligned start addr &quot; PTR_FORMAT, p2i(start_card));</span>
<span class="line-added"> 539     assert(is_aligned(size, sizeof(size_t)), &quot;Unaligned size &quot; SIZE_FORMAT, size);</span>
<span class="line-added"> 540   }</span>
<span class="line-added"> 541 </span>
<span class="line-added"> 542   size_t find_next_dirty() {</span>
<span class="line-added"> 543     while (!cur_addr_aligned()) {</span>
<span class="line-added"> 544       if (cur_card_is_dirty()) {</span>
<span class="line-added"> 545         return get_and_advance_pos();</span>
<span class="line-added"> 546       }</span>
<span class="line-added"> 547       _cur_addr++;</span>
<span class="line-added"> 548     }</span>
<span class="line-added"> 549 </span>
<span class="line-added"> 550     assert(cur_addr_aligned(), &quot;Current address should be aligned now.&quot;);</span>
<span class="line-added"> 551     while (_cur_addr != _end_addr) {</span>
<span class="line-added"> 552       if (cur_word_of_cards_contains_any_dirty_card()) {</span>
<span class="line-added"> 553         for (size_t i = 0; i &lt; sizeof(size_t); i++) {</span>
<span class="line-added"> 554           if (cur_card_is_dirty()) {</span>
<span class="line-added"> 555             return get_and_advance_pos();</span>
<span class="line-added"> 556           }</span>
<span class="line-added"> 557           _cur_addr++;</span>
<span class="line-added"> 558         }</span>
<span class="line-added"> 559         assert(false, &quot;Should not reach here given we detected a dirty card in the word.&quot;);</span>
<span class="line-added"> 560       }</span>
<span class="line-added"> 561       _cur_addr += sizeof(size_t);</span>
<span class="line-added"> 562     }</span>
<span class="line-added"> 563     return get_and_advance_pos();</span>
 564   }
 565 
<a name="53" id="anc53"></a><span class="line-modified"> 566   size_t find_next_non_dirty() {</span>
<span class="line-modified"> 567     assert(_cur_addr &lt;= _end_addr, &quot;Not allowed to search for marks after area.&quot;);</span>
 568 
<a name="54" id="anc54"></a><span class="line-modified"> 569     while (!cur_addr_aligned()) {</span>
<span class="line-modified"> 570       if (!cur_card_is_dirty()) {</span>
<span class="line-added"> 571         return get_and_advance_pos();</span>
<span class="line-added"> 572       }</span>
<span class="line-added"> 573       _cur_addr++;</span>
<span class="line-added"> 574     }</span>
 575 
<a name="55" id="anc55"></a><span class="line-modified"> 576     assert(cur_addr_aligned(), &quot;Current address should be aligned now.&quot;);</span>
<span class="line-modified"> 577     while (_cur_addr != _end_addr) {</span>
<span class="line-modified"> 578       if (!cur_word_of_cards_all_dirty_cards()) {</span>
<span class="line-modified"> 579         for (size_t i = 0; i &lt; sizeof(size_t); i++) {</span>
<span class="line-added"> 580           if (!cur_card_is_dirty()) {</span>
<span class="line-added"> 581             return get_and_advance_pos();</span>
<span class="line-added"> 582           }</span>
<span class="line-added"> 583           _cur_addr++;</span>
<span class="line-added"> 584         }</span>
<span class="line-added"> 585         assert(false, &quot;Should not reach here given we detected a non-dirty card in the word.&quot;);</span>
<span class="line-added"> 586       }</span>
<span class="line-added"> 587       _cur_addr += sizeof(size_t);</span>
 588     }
<a name="56" id="anc56"></a><span class="line-modified"> 589     return get_and_advance_pos();</span>
<span class="line-modified"> 590   }</span>
<span class="line-modified"> 591 };</span>
<span class="line-added"> 592 </span>
<span class="line-added"> 593 // Helper class to claim dirty chunks within the card table.</span>
<span class="line-added"> 594 class G1CardTableChunkClaimer {</span>
<span class="line-added"> 595   G1RemSetScanState* _scan_state;</span>
<span class="line-added"> 596   uint _region_idx;</span>
<span class="line-added"> 597   uint _cur_claim;</span>
<span class="line-added"> 598 </span>
<span class="line-added"> 599 public:</span>
<span class="line-added"> 600   G1CardTableChunkClaimer(G1RemSetScanState* scan_state, uint region_idx) :</span>
<span class="line-added"> 601     _scan_state(scan_state),</span>
<span class="line-added"> 602     _region_idx(region_idx),</span>
<span class="line-added"> 603     _cur_claim(0) {</span>
<span class="line-added"> 604     guarantee(size() &lt;= HeapRegion::CardsPerRegion, &quot;Should not claim more space than possible.&quot;);</span>
<span class="line-added"> 605   }</span>
<span class="line-added"> 606 </span>
<span class="line-added"> 607   bool has_next() {</span>
<span class="line-added"> 608     while (true) {</span>
<span class="line-added"> 609       _cur_claim = _scan_state-&gt;claim_cards_to_scan(_region_idx, size());</span>
<span class="line-added"> 610       if (_cur_claim &gt;= HeapRegion::CardsPerRegion) {</span>
<span class="line-added"> 611         return false;</span>
<span class="line-added"> 612       }</span>
<span class="line-added"> 613       if (_scan_state-&gt;chunk_needs_scan(_region_idx, _cur_claim)) {</span>
<span class="line-added"> 614         return true;</span>
<span class="line-added"> 615       }</span>
 616     }
<a name="57" id="anc57"></a><span class="line-modified"> 617   }</span>
 618 
<a name="58" id="anc58"></a><span class="line-modified"> 619   uint value() const { return _cur_claim; }</span>
<span class="line-modified"> 620   uint size() const { return _scan_state-&gt;scan_chunk_size(); }</span>
<span class="line-added"> 621 };</span>
 622 
<a name="59" id="anc59"></a><span class="line-added"> 623 // Scans a heap region for dirty cards.</span>
<span class="line-added"> 624 class G1ScanHRForRegionClosure : public HeapRegionClosure {</span>
<span class="line-added"> 625   G1CollectedHeap* _g1h;</span>
<span class="line-added"> 626   G1CardTable* _ct;</span>
<span class="line-added"> 627   G1BlockOffsetTable* _bot;</span>
<span class="line-added"> 628 </span>
<span class="line-added"> 629   G1ParScanThreadState* _pss;</span>
<span class="line-added"> 630 </span>
<span class="line-added"> 631   G1RemSetScanState* _scan_state;</span>
<span class="line-added"> 632 </span>
<span class="line-added"> 633   G1GCPhaseTimes::GCParPhases _phase;</span>
<span class="line-added"> 634 </span>
<span class="line-added"> 635   uint   _worker_id;</span>
<span class="line-added"> 636 </span>
<span class="line-added"> 637   size_t _cards_scanned;</span>
<span class="line-added"> 638   size_t _blocks_scanned;</span>
<span class="line-added"> 639   size_t _chunks_claimed;</span>
<span class="line-added"> 640 </span>
<span class="line-added"> 641   Tickspan _rem_set_root_scan_time;</span>
<span class="line-added"> 642   Tickspan _rem_set_trim_partially_time;</span>
<span class="line-added"> 643 </span>
<span class="line-added"> 644   // The address to which this thread already scanned (walked the heap) up to during</span>
<span class="line-added"> 645   // card scanning (exclusive).</span>
<span class="line-added"> 646   HeapWord* _scanned_to;</span>
<span class="line-added"> 647 </span>
<span class="line-added"> 648   HeapWord* scan_memregion(uint region_idx_for_card, MemRegion mr) {</span>
<span class="line-added"> 649     HeapRegion* const card_region = _g1h-&gt;region_at(region_idx_for_card);</span>
<span class="line-added"> 650     G1ScanCardClosure card_cl(_g1h, _pss);</span>
<span class="line-added"> 651 </span>
<span class="line-added"> 652     HeapWord* const scanned_to = card_region-&gt;oops_on_memregion_seq_iterate_careful&lt;true&gt;(mr, &amp;card_cl);</span>
<span class="line-added"> 653     assert(scanned_to != NULL, &quot;Should be able to scan range&quot;);</span>
<span class="line-added"> 654     assert(scanned_to &gt;= mr.end(), &quot;Scanned to &quot; PTR_FORMAT &quot; less than range &quot; PTR_FORMAT, p2i(scanned_to), p2i(mr.end()));</span>
<span class="line-added"> 655 </span>
<span class="line-added"> 656     _pss-&gt;trim_queue_partially();</span>
<span class="line-added"> 657     return scanned_to;</span>
<span class="line-added"> 658   }</span>
<span class="line-added"> 659 </span>
<span class="line-added"> 660   void do_claimed_block(uint const region_idx_for_card, size_t const first_card, size_t const num_cards) {</span>
<span class="line-added"> 661     HeapWord* const card_start = _bot-&gt;address_for_index_raw(first_card);</span>
 662 #ifdef ASSERT
 663     HeapRegion* hr = _g1h-&gt;region_at_or_null(region_idx_for_card);
 664     assert(hr == NULL || hr-&gt;is_in_reserved(card_start),
<a name="60" id="anc60"></a><span class="line-modified"> 665              &quot;Card start &quot; PTR_FORMAT &quot; to scan outside of region %u&quot;, p2i(card_start), _g1h-&gt;region_at(region_idx_for_card)-&gt;hrm_index());</span>
 666 #endif
 667     HeapWord* const top = _scan_state-&gt;scan_top(region_idx_for_card);
 668     if (card_start &gt;= top) {
<a name="61" id="anc61"></a><span class="line-modified"> 669       return;</span>
<span class="line-added"> 670     }</span>
<span class="line-added"> 671 </span>
<span class="line-added"> 672     HeapWord* scan_end = MIN2(card_start + (num_cards &lt;&lt; BOTConstants::LogN_words), top);</span>
<span class="line-added"> 673     if (_scanned_to &gt;= scan_end) {</span>
<span class="line-added"> 674       return;</span>
 675     }
<a name="62" id="anc62"></a><span class="line-added"> 676     MemRegion mr(MAX2(card_start, _scanned_to), scan_end);</span>
<span class="line-added"> 677     _scanned_to = scan_memregion(region_idx_for_card, mr);</span>
<span class="line-added"> 678 </span>
<span class="line-added"> 679     _cards_scanned += num_cards;</span>
<span class="line-added"> 680   }</span>
<span class="line-added"> 681 </span>
<span class="line-added"> 682   ALWAYSINLINE void do_card_block(uint const region_idx, size_t const first_card, size_t const num_cards) {</span>
<span class="line-added"> 683     _ct-&gt;mark_as_scanned(first_card, num_cards);</span>
<span class="line-added"> 684     do_claimed_block(region_idx, first_card, num_cards);</span>
<span class="line-added"> 685     _blocks_scanned++;</span>
<span class="line-added"> 686   }</span>
<span class="line-added"> 687 </span>
<span class="line-added"> 688    void scan_heap_roots(HeapRegion* r) {</span>
<span class="line-added"> 689     EventGCPhaseParallel event;</span>
<span class="line-added"> 690     uint const region_idx = r-&gt;hrm_index();</span>
<span class="line-added"> 691 </span>
<span class="line-added"> 692     ResourceMark rm;</span>
<span class="line-added"> 693 </span>
<span class="line-added"> 694     G1CardTableChunkClaimer claim(_scan_state, region_idx);</span>
<span class="line-added"> 695 </span>
<span class="line-added"> 696     // Set the current scan &quot;finger&quot; to NULL for every heap region to scan. Since</span>
<span class="line-added"> 697     // the claim value is monotonically increasing, the check to not scan below this</span>
<span class="line-added"> 698     // will filter out objects spanning chunks within the region too then, as opposed</span>
<span class="line-added"> 699     // to resetting this value for every claim.</span>
<span class="line-added"> 700     _scanned_to = NULL;</span>
<span class="line-added"> 701 </span>
<span class="line-added"> 702     while (claim.has_next()) {</span>
<span class="line-added"> 703       size_t const region_card_base_idx = ((size_t)region_idx &lt;&lt; HeapRegion::LogCardsPerRegion) + claim.value();</span>
<span class="line-added"> 704       CardTable::CardValue* const base_addr = _ct-&gt;byte_for_index(region_card_base_idx);</span>
<span class="line-added"> 705 </span>
<span class="line-added"> 706       G1CardTableScanner scan(base_addr, claim.size());</span>
<span class="line-added"> 707 </span>
<span class="line-added"> 708       size_t first_scan_idx = scan.find_next_dirty();</span>
<span class="line-added"> 709       while (first_scan_idx != claim.size()) {</span>
<span class="line-added"> 710         assert(*_ct-&gt;byte_for_index(region_card_base_idx + first_scan_idx) &lt;= 0x1, &quot;is %d at region %u idx &quot; SIZE_FORMAT, *_ct-&gt;byte_for_index(region_card_base_idx + first_scan_idx), region_idx, first_scan_idx);</span>
<span class="line-added"> 711 </span>
<span class="line-added"> 712         size_t const last_scan_idx = scan.find_next_non_dirty();</span>
<span class="line-added"> 713         size_t const len = last_scan_idx - first_scan_idx;</span>
<span class="line-added"> 714 </span>
<span class="line-added"> 715         do_card_block(region_idx, region_card_base_idx + first_scan_idx, len);</span>
 716 
<a name="63" id="anc63"></a><span class="line-modified"> 717         if (last_scan_idx == claim.size()) {</span>
<span class="line-modified"> 718           break;</span>
<span class="line-modified"> 719         }</span>
<span class="line-added"> 720 </span>
<span class="line-added"> 721         first_scan_idx = scan.find_next_dirty();</span>
<span class="line-added"> 722       }</span>
<span class="line-added"> 723       _chunks_claimed++;</span>
 724     }
 725 
<a name="64" id="anc64"></a><span class="line-modified"> 726     event.commit(GCId::current(), _worker_id, G1GCPhaseTimes::phase_name(G1GCPhaseTimes::ScanHR));</span>
<span class="line-modified"> 727   }</span>
<span class="line-modified"> 728 </span>
<span class="line-modified"> 729 public:</span>
<span class="line-modified"> 730   G1ScanHRForRegionClosure(G1RemSetScanState* scan_state,</span>
<span class="line-modified"> 731                            G1ParScanThreadState* pss,</span>
<span class="line-modified"> 732                            uint worker_id,</span>
<span class="line-added"> 733                            G1GCPhaseTimes::GCParPhases phase) :</span>
<span class="line-added"> 734     _g1h(G1CollectedHeap::heap()),</span>
<span class="line-added"> 735     _ct(_g1h-&gt;card_table()),</span>
<span class="line-added"> 736     _bot(_g1h-&gt;bot()),</span>
<span class="line-added"> 737     _pss(pss),</span>
<span class="line-added"> 738     _scan_state(scan_state),</span>
<span class="line-added"> 739     _phase(phase),</span>
<span class="line-added"> 740     _worker_id(worker_id),</span>
<span class="line-added"> 741     _cards_scanned(0),</span>
<span class="line-added"> 742     _blocks_scanned(0),</span>
<span class="line-added"> 743     _chunks_claimed(0),</span>
<span class="line-added"> 744     _rem_set_root_scan_time(),</span>
<span class="line-added"> 745     _rem_set_trim_partially_time(),</span>
<span class="line-added"> 746     _scanned_to(NULL) {</span>
<span class="line-added"> 747   }</span>
 748 
<a name="65" id="anc65"></a><span class="line-modified"> 749   bool do_heap_region(HeapRegion* r) {</span>
<span class="line-added"> 750     assert(!r-&gt;in_collection_set() &amp;&amp; r-&gt;is_old_or_humongous_or_archive(),</span>
<span class="line-added"> 751            &quot;Should only be called on old gen non-collection set regions but region %u is not.&quot;,</span>
<span class="line-added"> 752            r-&gt;hrm_index());</span>
<span class="line-added"> 753     uint const region_idx = r-&gt;hrm_index();</span>
 754 
<a name="66" id="anc66"></a><span class="line-modified"> 755     if (_scan_state-&gt;has_cards_to_scan(region_idx)) {</span>
<span class="line-added"> 756       G1EvacPhaseWithTrimTimeTracker timer(_pss, _rem_set_root_scan_time, _rem_set_trim_partially_time);</span>
<span class="line-added"> 757       scan_heap_roots(r);</span>
<span class="line-added"> 758     }</span>
<span class="line-added"> 759     return false;</span>
 760   }
<a name="67" id="anc67"></a>

 761 
<a name="68" id="anc68"></a><span class="line-modified"> 762   Tickspan rem_set_root_scan_time() const { return _rem_set_root_scan_time; }</span>
<span class="line-modified"> 763   Tickspan rem_set_trim_partially_time() const { return _rem_set_trim_partially_time; }</span>
<span class="line-modified"> 764 </span>
<span class="line-modified"> 765   size_t cards_scanned() const { return _cards_scanned; }</span>
<span class="line-modified"> 766   size_t blocks_scanned() const { return _blocks_scanned; }</span>
<span class="line-modified"> 767   size_t chunks_claimed() const { return _chunks_claimed; }</span>
<span class="line-modified"> 768 };</span>
<span class="line-modified"> 769 </span>
<span class="line-added"> 770 void G1RemSet::scan_heap_roots(G1ParScanThreadState* pss,</span>
<span class="line-added"> 771                             uint worker_id,</span>
<span class="line-added"> 772                             G1GCPhaseTimes::GCParPhases scan_phase,</span>
<span class="line-added"> 773                             G1GCPhaseTimes::GCParPhases objcopy_phase) {</span>
<span class="line-added"> 774   G1ScanHRForRegionClosure cl(_scan_state, pss, worker_id, scan_phase);</span>
<span class="line-added"> 775   _scan_state-&gt;iterate_dirty_regions_from(&amp;cl, worker_id);</span>
<span class="line-added"> 776 </span>
<span class="line-added"> 777   G1GCPhaseTimes* p = _g1p-&gt;phase_times();</span>
<span class="line-added"> 778 </span>
<span class="line-added"> 779   p-&gt;record_or_add_time_secs(objcopy_phase, worker_id, cl.rem_set_trim_partially_time().seconds());</span>
<span class="line-added"> 780 </span>
<span class="line-added"> 781   p-&gt;record_or_add_time_secs(scan_phase, worker_id, cl.rem_set_root_scan_time().seconds());</span>
<span class="line-added"> 782   p-&gt;record_or_add_thread_work_item(scan_phase, worker_id, cl.cards_scanned(), G1GCPhaseTimes::ScanHRScannedCards);</span>
<span class="line-added"> 783   p-&gt;record_or_add_thread_work_item(scan_phase, worker_id, cl.blocks_scanned(), G1GCPhaseTimes::ScanHRScannedBlocks);</span>
<span class="line-added"> 784   p-&gt;record_or_add_thread_work_item(scan_phase, worker_id, cl.chunks_claimed(), G1GCPhaseTimes::ScanHRClaimedChunks);</span>
 785 }
 786 
<a name="69" id="anc69"></a><span class="line-modified"> 787 // Heap region closure to be applied to all regions in the current collection set</span>
<span class="line-modified"> 788 // increment to fix up non-card related roots.</span>
<span class="line-modified"> 789 class G1ScanCollectionSetRegionClosure : public HeapRegionClosure {</span>
<span class="line-modified"> 790   G1ParScanThreadState* _pss;</span>
<span class="line-modified"> 791   G1RemSetScanState* _scan_state;</span>
<span class="line-added"> 792 </span>
<span class="line-added"> 793   G1GCPhaseTimes::GCParPhases _scan_phase;</span>
<span class="line-added"> 794   G1GCPhaseTimes::GCParPhases _code_roots_phase;</span>
<span class="line-added"> 795 </span>
<span class="line-added"> 796   uint _worker_id;</span>
<span class="line-added"> 797 </span>
<span class="line-added"> 798   size_t _opt_refs_scanned;</span>
<span class="line-added"> 799   size_t _opt_refs_memory_used;</span>
<span class="line-added"> 800 </span>
<span class="line-added"> 801   Tickspan _strong_code_root_scan_time;</span>
<span class="line-added"> 802   Tickspan _strong_code_trim_partially_time;</span>
<span class="line-added"> 803 </span>
<span class="line-added"> 804   Tickspan _rem_set_opt_root_scan_time;</span>
<span class="line-added"> 805   Tickspan _rem_set_opt_trim_partially_time;</span>
<span class="line-added"> 806 </span>
<span class="line-added"> 807   void scan_opt_rem_set_roots(HeapRegion* r) {</span>
<span class="line-added"> 808     EventGCPhaseParallel event;</span>
<span class="line-added"> 809 </span>
<span class="line-added"> 810     G1OopStarChunkedList* opt_rem_set_list = _pss-&gt;oops_into_optional_region(r);</span>
<span class="line-added"> 811 </span>
<span class="line-added"> 812     G1ScanCardClosure scan_cl(G1CollectedHeap::heap(), _pss);</span>
<span class="line-added"> 813     G1ScanRSForOptionalClosure cl(G1CollectedHeap::heap(), &amp;scan_cl);</span>
<span class="line-added"> 814     _opt_refs_scanned += opt_rem_set_list-&gt;oops_do(&amp;cl, _pss-&gt;closures()-&gt;strong_oops());</span>
<span class="line-added"> 815     _opt_refs_memory_used += opt_rem_set_list-&gt;used_memory();</span>
<span class="line-added"> 816 </span>
<span class="line-added"> 817     event.commit(GCId::current(), _worker_id, G1GCPhaseTimes::phase_name(_scan_phase));</span>
<span class="line-added"> 818   }</span>
<span class="line-added"> 819 </span>
<span class="line-added"> 820 public:</span>
<span class="line-added"> 821   G1ScanCollectionSetRegionClosure(G1RemSetScanState* scan_state,</span>
<span class="line-added"> 822                                    G1ParScanThreadState* pss,</span>
<span class="line-added"> 823                                    uint worker_id,</span>
<span class="line-added"> 824                                    G1GCPhaseTimes::GCParPhases scan_phase,</span>
<span class="line-added"> 825                                    G1GCPhaseTimes::GCParPhases code_roots_phase) :</span>
<span class="line-added"> 826     _pss(pss),</span>
<span class="line-added"> 827     _scan_state(scan_state),</span>
<span class="line-added"> 828     _scan_phase(scan_phase),</span>
<span class="line-added"> 829     _code_roots_phase(code_roots_phase),</span>
<span class="line-added"> 830     _worker_id(worker_id),</span>
<span class="line-added"> 831     _opt_refs_scanned(0),</span>
<span class="line-added"> 832     _opt_refs_memory_used(0),</span>
<span class="line-added"> 833     _strong_code_root_scan_time(),</span>
<span class="line-added"> 834     _strong_code_trim_partially_time(),</span>
<span class="line-added"> 835     _rem_set_opt_root_scan_time(),</span>
<span class="line-added"> 836     _rem_set_opt_trim_partially_time() { }</span>
<span class="line-added"> 837 </span>
<span class="line-added"> 838   bool do_heap_region(HeapRegion* r) {</span>
<span class="line-added"> 839     uint const region_idx = r-&gt;hrm_index();</span>
<span class="line-added"> 840 </span>
<span class="line-added"> 841     // The individual references for the optional remembered set are per-worker, so we</span>
<span class="line-added"> 842     // always need to scan them.</span>
<span class="line-added"> 843     if (r-&gt;has_index_in_opt_cset()) {</span>
<span class="line-added"> 844       G1EvacPhaseWithTrimTimeTracker timer(_pss, _rem_set_opt_root_scan_time, _rem_set_opt_trim_partially_time);</span>
<span class="line-added"> 845       scan_opt_rem_set_roots(r);</span>
<span class="line-added"> 846     }</span>
<span class="line-added"> 847 </span>
<span class="line-added"> 848     if (_scan_state-&gt;claim_collection_set_region(region_idx)) {</span>
<span class="line-added"> 849       EventGCPhaseParallel event;</span>
<span class="line-added"> 850 </span>
<span class="line-added"> 851       G1EvacPhaseWithTrimTimeTracker timer(_pss, _strong_code_root_scan_time, _strong_code_trim_partially_time);</span>
<span class="line-added"> 852       // Scan the strong code root list attached to the current region</span>
<span class="line-added"> 853       r-&gt;strong_code_roots_do(_pss-&gt;closures()-&gt;weak_codeblobs());</span>
<span class="line-added"> 854 </span>
<span class="line-added"> 855       event.commit(GCId::current(), _worker_id, G1GCPhaseTimes::phase_name(_code_roots_phase));</span>
<span class="line-added"> 856     }</span>
 857 
<a name="70" id="anc70"></a>

 858     return false;
 859   }
 860 
<a name="71" id="anc71"></a><span class="line-modified"> 861   Tickspan strong_code_root_scan_time() const { return _strong_code_root_scan_time;  }</span>
<span class="line-modified"> 862   Tickspan strong_code_root_trim_partially_time() const { return _strong_code_trim_partially_time; }</span>
<span class="line-modified"> 863 </span>
<span class="line-added"> 864   Tickspan rem_set_opt_root_scan_time() const { return _rem_set_opt_root_scan_time; }</span>
<span class="line-added"> 865   Tickspan rem_set_opt_trim_partially_time() const { return _rem_set_opt_trim_partially_time; }</span>
<span class="line-added"> 866 </span>
<span class="line-added"> 867   size_t opt_refs_scanned() const { return _opt_refs_scanned; }</span>
<span class="line-added"> 868   size_t opt_refs_memory_used() const { return _opt_refs_memory_used; }</span>
<span class="line-added"> 869 };</span>
<span class="line-added"> 870 </span>
<span class="line-added"> 871 void G1RemSet::scan_collection_set_regions(G1ParScanThreadState* pss,</span>
<span class="line-added"> 872                                            uint worker_id,</span>
<span class="line-added"> 873                                            G1GCPhaseTimes::GCParPhases scan_phase,</span>
<span class="line-added"> 874                                            G1GCPhaseTimes::GCParPhases coderoots_phase,</span>
<span class="line-added"> 875                                            G1GCPhaseTimes::GCParPhases objcopy_phase) {</span>
<span class="line-added"> 876   G1ScanCollectionSetRegionClosure cl(_scan_state, pss, worker_id, scan_phase, coderoots_phase);</span>
<span class="line-added"> 877   _g1h-&gt;collection_set_iterate_increment_from(&amp;cl, worker_id);</span>
<span class="line-added"> 878 </span>
<span class="line-added"> 879   G1GCPhaseTimes* p = _g1h-&gt;phase_times();</span>
<span class="line-added"> 880 </span>
<span class="line-added"> 881   p-&gt;record_or_add_time_secs(scan_phase, worker_id, cl.rem_set_opt_root_scan_time().seconds());</span>
<span class="line-added"> 882   p-&gt;record_or_add_time_secs(scan_phase, worker_id, cl.rem_set_opt_trim_partially_time().seconds());</span>
<span class="line-added"> 883 </span>
<span class="line-added"> 884   p-&gt;record_or_add_time_secs(coderoots_phase, worker_id, cl.strong_code_root_scan_time().seconds());</span>
<span class="line-added"> 885   p-&gt;add_time_secs(objcopy_phase, worker_id, cl.strong_code_root_trim_partially_time().seconds());</span>
<span class="line-added"> 886 </span>
<span class="line-added"> 887   // At this time we record some metrics only for the evacuations after the initial one.</span>
<span class="line-added"> 888   if (scan_phase == G1GCPhaseTimes::OptScanHR) {</span>
<span class="line-added"> 889     p-&gt;record_or_add_thread_work_item(scan_phase, worker_id, cl.opt_refs_scanned(), G1GCPhaseTimes::ScanHRScannedOptRefs);</span>
<span class="line-added"> 890     p-&gt;record_or_add_thread_work_item(scan_phase, worker_id, cl.opt_refs_memory_used(), G1GCPhaseTimes::ScanHRUsedMemory);</span>
 891   }
<a name="72" id="anc72"></a><span class="line-added"> 892 }</span>
 893 
<a name="73" id="anc73"></a><span class="line-modified"> 894 void G1RemSet::prepare_region_for_scan(HeapRegion* region) {</span>
<span class="line-modified"> 895   uint hrm_index = region-&gt;hrm_index();</span>
<span class="line-modified"> 896 </span>
<span class="line-modified"> 897   if (region-&gt;in_collection_set()) {</span>
<span class="line-added"> 898     // Young regions had their card table marked as young at their allocation;</span>
<span class="line-added"> 899     // we need to make sure that these marks are cleared at the end of GC, *but*</span>
<span class="line-added"> 900     // they should not be scanned for cards.</span>
<span class="line-added"> 901     // So directly add them to the &quot;all_dirty_regions&quot;.</span>
<span class="line-added"> 902     // Same for regions in the (initial) collection set: they may contain cards from</span>
<span class="line-added"> 903     // the log buffers, make sure they are cleaned.</span>
<span class="line-added"> 904     _scan_state-&gt;add_all_dirty_region(hrm_index);</span>
<span class="line-added"> 905   } else if (region-&gt;is_old_or_humongous_or_archive()) {</span>
<span class="line-added"> 906     _scan_state-&gt;set_scan_top(hrm_index, region-&gt;top());</span>
<span class="line-added"> 907   } else {</span>
<span class="line-added"> 908     assert(region-&gt;is_free(), &quot;Should only be free region at this point %s&quot;, region-&gt;get_type_str());</span>
 909   }
<a name="74" id="anc74"></a>
 910 }
 911 
<a name="75" id="anc75"></a><span class="line-modified"> 912 void G1RemSet::prepare_for_scan_heap_roots() {</span>
<span class="line-modified"> 913   G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();</span>
<span class="line-modified"> 914   dcqs.concatenate_logs();</span>

 915 
<a name="76" id="anc76"></a><span class="line-modified"> 916   _scan_state-&gt;prepare();</span>
<span class="line-added"> 917 }</span>
 918 
<a name="77" id="anc77"></a><span class="line-modified"> 919 class G1MergeHeapRootsTask : public AbstractGangTask {</span>

 920 
<a name="78" id="anc78"></a><span class="line-modified"> 921   // Visitor for remembered sets, dropping entries onto the card table.</span>
<span class="line-modified"> 922   class G1MergeCardSetClosure : public HeapRegionClosure {</span>
<span class="line-modified"> 923     G1RemSetScanState* _scan_state;</span>
<span class="line-added"> 924     G1CardTable* _ct;</span>
 925 
<a name="79" id="anc79"></a><span class="line-modified"> 926     uint _merged_sparse;</span>
<span class="line-modified"> 927     uint _merged_fine;</span>
<span class="line-modified"> 928     uint _merged_coarse;</span>
 929 
<a name="80" id="anc80"></a><span class="line-modified"> 930     size_t _cards_dirty;</span>
<span class="line-modified"> 931 </span>
<span class="line-modified"> 932     // Returns if the region contains cards we need to scan. If so, remember that</span>
<span class="line-modified"> 933     // region in the current set of dirty regions.</span>
<span class="line-added"> 934     bool remember_if_interesting(uint const region_idx) {</span>
<span class="line-added"> 935       if (!_scan_state-&gt;contains_cards_to_process(region_idx)) {</span>
<span class="line-added"> 936         return false;</span>
<span class="line-added"> 937       }</span>
<span class="line-added"> 938       _scan_state-&gt;add_dirty_region(region_idx);</span>
<span class="line-added"> 939       return true;</span>
<span class="line-added"> 940     }</span>
<span class="line-added"> 941   public:</span>
<span class="line-added"> 942     G1MergeCardSetClosure(G1RemSetScanState* scan_state) :</span>
<span class="line-added"> 943       _scan_state(scan_state),</span>
<span class="line-added"> 944       _ct(G1CollectedHeap::heap()-&gt;card_table()),</span>
<span class="line-added"> 945       _merged_sparse(0),</span>
<span class="line-added"> 946       _merged_fine(0),</span>
<span class="line-added"> 947       _merged_coarse(0),</span>
<span class="line-added"> 948       _cards_dirty(0) { }</span>
<span class="line-added"> 949 </span>
<span class="line-added"> 950     void next_coarse_prt(uint const region_idx) {</span>
<span class="line-added"> 951       if (!remember_if_interesting(region_idx)) {</span>
<span class="line-added"> 952         return;</span>
<span class="line-added"> 953       }</span>
<span class="line-added"> 954 </span>
<span class="line-added"> 955       _merged_coarse++;</span>
<span class="line-added"> 956 </span>
<span class="line-added"> 957       size_t region_base_idx = (size_t)region_idx &lt;&lt; HeapRegion::LogCardsPerRegion;</span>
<span class="line-added"> 958       _cards_dirty += _ct-&gt;mark_region_dirty(region_base_idx, HeapRegion::CardsPerRegion);</span>
<span class="line-added"> 959       _scan_state-&gt;set_chunk_region_dirty(region_base_idx);</span>
<span class="line-added"> 960     }</span>
<span class="line-added"> 961 </span>
<span class="line-added"> 962     void next_fine_prt(uint const region_idx, BitMap* bm) {</span>
<span class="line-added"> 963       if (!remember_if_interesting(region_idx)) {</span>
<span class="line-added"> 964         return;</span>
<span class="line-added"> 965       }</span>
<span class="line-added"> 966 </span>
<span class="line-added"> 967       _merged_fine++;</span>
<span class="line-added"> 968 </span>
<span class="line-added"> 969       size_t const region_base_idx = (size_t)region_idx &lt;&lt; HeapRegion::LogCardsPerRegion;</span>
<span class="line-added"> 970       BitMap::idx_t cur = bm-&gt;get_next_one_offset(0);</span>
<span class="line-added"> 971       while (cur != bm-&gt;size()) {</span>
<span class="line-added"> 972         _cards_dirty += _ct-&gt;mark_clean_as_dirty(region_base_idx + cur);</span>
<span class="line-added"> 973         _scan_state-&gt;set_chunk_dirty(region_base_idx + cur);</span>
<span class="line-added"> 974         cur = bm-&gt;get_next_one_offset(cur + 1);</span>
<span class="line-added"> 975       }</span>
<span class="line-added"> 976     }</span>
<span class="line-added"> 977 </span>
<span class="line-added"> 978     void next_sparse_prt(uint const region_idx, SparsePRTEntry::card_elem_t* cards, uint const num_cards) {</span>
<span class="line-added"> 979       if (!remember_if_interesting(region_idx)) {</span>
<span class="line-added"> 980         return;</span>
<span class="line-added"> 981       }</span>
<span class="line-added"> 982 </span>
<span class="line-added"> 983       _merged_sparse++;</span>
<span class="line-added"> 984 </span>
<span class="line-added"> 985       size_t const region_base_idx = (size_t)region_idx &lt;&lt; HeapRegion::LogCardsPerRegion;</span>
<span class="line-added"> 986       for (uint i = 0; i &lt; num_cards; i++) {</span>
<span class="line-added"> 987         size_t card_idx = region_base_idx + cards[i];</span>
<span class="line-added"> 988         _cards_dirty += _ct-&gt;mark_clean_as_dirty(card_idx);</span>
<span class="line-added"> 989         _scan_state-&gt;set_chunk_dirty(card_idx);</span>
<span class="line-added"> 990       }</span>
<span class="line-added"> 991     }</span>
<span class="line-added"> 992 </span>
<span class="line-added"> 993     virtual bool do_heap_region(HeapRegion* r) {</span>
<span class="line-added"> 994       assert(r-&gt;in_collection_set() || r-&gt;is_starts_humongous(), &quot;must be&quot;);</span>
<span class="line-added"> 995 </span>
<span class="line-added"> 996       HeapRegionRemSet* rem_set = r-&gt;rem_set();</span>
<span class="line-added"> 997       if (!rem_set-&gt;is_empty()) {</span>
<span class="line-added"> 998         rem_set-&gt;iterate_prts(*this);</span>
<span class="line-added"> 999       }</span>
<span class="line-added">1000 </span>
<span class="line-added">1001       return false;</span>
<span class="line-added">1002     }</span>
<span class="line-added">1003 </span>
<span class="line-added">1004     size_t merged_sparse() const { return _merged_sparse; }</span>
<span class="line-added">1005     size_t merged_fine() const { return _merged_fine; }</span>
<span class="line-added">1006     size_t merged_coarse() const { return _merged_coarse; }</span>
<span class="line-added">1007 </span>
<span class="line-added">1008     size_t cards_dirty() const { return _cards_dirty; }</span>
<span class="line-added">1009   };</span>
<span class="line-added">1010 </span>
<span class="line-added">1011   // Visitor for the remembered sets of humongous candidate regions to merge their</span>
<span class="line-added">1012   // remembered set into the card table.</span>
<span class="line-added">1013   class G1FlushHumongousCandidateRemSets : public HeapRegionClosure {</span>
<span class="line-added">1014     G1MergeCardSetClosure _cl;</span>
<span class="line-added">1015 </span>
<span class="line-added">1016   public:</span>
<span class="line-added">1017     G1FlushHumongousCandidateRemSets(G1RemSetScanState* scan_state) : _cl(scan_state) { }</span>
<span class="line-added">1018 </span>
<span class="line-added">1019     virtual bool do_heap_region(HeapRegion* r) {</span>
<span class="line-added">1020       G1CollectedHeap* g1h = G1CollectedHeap::heap();</span>
<span class="line-added">1021 </span>
<span class="line-added">1022       if (!r-&gt;is_starts_humongous() ||</span>
<span class="line-added">1023           !g1h-&gt;region_attr(r-&gt;hrm_index()).is_humongous() ||</span>
<span class="line-added">1024           r-&gt;rem_set()-&gt;is_empty()) {</span>
<span class="line-added">1025         return false;</span>
<span class="line-added">1026       }</span>
<span class="line-added">1027 </span>
<span class="line-added">1028       guarantee(r-&gt;rem_set()-&gt;occupancy_less_or_equal_than(G1RSetSparseRegionEntries),</span>
<span class="line-added">1029                 &quot;Found a not-small remembered set here. This is inconsistent with previous assumptions.&quot;);</span>
<span class="line-added">1030 </span>
<span class="line-added">1031       _cl.do_heap_region(r);</span>
<span class="line-added">1032 </span>
<span class="line-added">1033       // We should only clear the card based remembered set here as we will not</span>
<span class="line-added">1034       // implicitly rebuild anything else during eager reclaim. Note that at the moment</span>
<span class="line-added">1035       // (and probably never) we do not enter this path if there are other kind of</span>
<span class="line-added">1036       // remembered sets for this region.</span>
<span class="line-added">1037       r-&gt;rem_set()-&gt;clear_locked(true /* only_cardset */);</span>
<span class="line-added">1038       // Clear_locked() above sets the state to Empty. However we want to continue</span>
<span class="line-added">1039       // collecting remembered set entries for humongous regions that were not</span>
<span class="line-added">1040       // reclaimed.</span>
<span class="line-added">1041       r-&gt;rem_set()-&gt;set_state_complete();</span>
<span class="line-added">1042 #ifdef ASSERT</span>
<span class="line-added">1043       G1HeapRegionAttr region_attr = g1h-&gt;region_attr(r-&gt;hrm_index());</span>
<span class="line-added">1044       assert(region_attr.needs_remset_update(), &quot;must be&quot;);</span>
<span class="line-added">1045 #endif</span>
<span class="line-added">1046       assert(r-&gt;rem_set()-&gt;is_empty(), &quot;At this point any humongous candidate remembered set must be empty.&quot;);</span>
<span class="line-added">1047 </span>
<span class="line-added">1048       return false;</span>
<span class="line-added">1049     }</span>
<span class="line-added">1050 </span>
<span class="line-added">1051     size_t merged_sparse() const { return _cl.merged_sparse(); }</span>
<span class="line-added">1052     size_t merged_fine() const { return _cl.merged_fine(); }</span>
<span class="line-added">1053     size_t merged_coarse() const { return _cl.merged_coarse(); }</span>
<span class="line-added">1054 </span>
<span class="line-added">1055     size_t cards_dirty() const { return _cl.cards_dirty(); }</span>
<span class="line-added">1056   };</span>
<span class="line-added">1057 </span>
<span class="line-added">1058   // Visitor for the log buffer entries to merge them into the card table.</span>
<span class="line-added">1059   class G1MergeLogBufferCardsClosure : public G1CardTableEntryClosure {</span>
<span class="line-added">1060     G1RemSetScanState* _scan_state;</span>
<span class="line-added">1061     G1CardTable* _ct;</span>
<span class="line-added">1062 </span>
<span class="line-added">1063     size_t _cards_dirty;</span>
<span class="line-added">1064     size_t _cards_skipped;</span>
<span class="line-added">1065   public:</span>
<span class="line-added">1066     G1MergeLogBufferCardsClosure(G1CollectedHeap* g1h, G1RemSetScanState* scan_state) :</span>
<span class="line-added">1067       _scan_state(scan_state), _ct(g1h-&gt;card_table()), _cards_dirty(0), _cards_skipped(0)</span>
<span class="line-added">1068     {}</span>
<span class="line-added">1069 </span>
<span class="line-added">1070     void do_card_ptr(CardValue* card_ptr, uint worker_id) {</span>
<span class="line-added">1071       // The only time we care about recording cards that</span>
<span class="line-added">1072       // contain references that point into the collection set</span>
<span class="line-added">1073       // is during RSet updating within an evacuation pause.</span>
<span class="line-added">1074       // In this case worker_id should be the id of a GC worker thread.</span>
<span class="line-added">1075       assert(SafepointSynchronize::is_at_safepoint(), &quot;not during an evacuation pause&quot;);</span>
<span class="line-added">1076 </span>
<span class="line-added">1077       uint const region_idx = _ct-&gt;region_idx_for(card_ptr);</span>
<span class="line-added">1078 </span>
<span class="line-added">1079       // The second clause must come after - the log buffers might contain cards to uncommited</span>
<span class="line-added">1080       // regions.</span>
<span class="line-added">1081       // This code may count duplicate entries in the log buffers (even if rare) multiple</span>
<span class="line-added">1082       // times.</span>
<span class="line-added">1083       if (_scan_state-&gt;contains_cards_to_process(region_idx) &amp;&amp; (*card_ptr == G1CardTable::dirty_card_val())) {</span>
<span class="line-added">1084         _scan_state-&gt;add_dirty_region(region_idx);</span>
<span class="line-added">1085         _scan_state-&gt;set_chunk_dirty(_ct-&gt;index_for_cardvalue(card_ptr));</span>
<span class="line-added">1086         _cards_dirty++;</span>
<span class="line-added">1087       } else {</span>
<span class="line-added">1088         // We may have had dirty cards in the (initial) collection set (or the</span>
<span class="line-added">1089         // young regions which are always in the initial collection set). We do</span>
<span class="line-added">1090         // not fix their cards here: we already added these regions to the set of</span>
<span class="line-added">1091         // regions to clear the card table at the end during the prepare() phase.</span>
<span class="line-added">1092         _cards_skipped++;</span>
<span class="line-added">1093       }</span>
<span class="line-added">1094     }</span>
<span class="line-added">1095 </span>
<span class="line-added">1096     size_t cards_dirty() const { return _cards_dirty; }</span>
<span class="line-added">1097     size_t cards_skipped() const { return _cards_skipped; }</span>
<span class="line-added">1098   };</span>
<span class="line-added">1099 </span>
<span class="line-added">1100   HeapRegionClaimer _hr_claimer;</span>
<span class="line-added">1101   G1RemSetScanState* _scan_state;</span>
<span class="line-added">1102   BufferNode::Stack _dirty_card_buffers;</span>
<span class="line-added">1103   bool _initial_evacuation;</span>
<span class="line-added">1104 </span>
<span class="line-added">1105   volatile bool _fast_reclaim_handled;</span>
<span class="line-added">1106 </span>
<span class="line-added">1107   void apply_closure_to_dirty_card_buffers(G1MergeLogBufferCardsClosure* cl, uint worker_id) {</span>
<span class="line-added">1108     G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();</span>
<span class="line-added">1109     size_t buffer_size = dcqs.buffer_size();</span>
<span class="line-added">1110     while (BufferNode* node = _dirty_card_buffers.pop()) {</span>
<span class="line-added">1111       cl-&gt;apply_to_buffer(node, buffer_size, worker_id);</span>
<span class="line-added">1112       dcqs.deallocate_buffer(node);</span>
<span class="line-added">1113     }</span>
<span class="line-added">1114   }</span>
1115 
<a name="81" id="anc81"></a>

1116 public:
<a name="82" id="anc82"></a><span class="line-modified">1117   G1MergeHeapRootsTask(G1RemSetScanState* scan_state, uint num_workers, bool initial_evacuation) :</span>
<span class="line-modified">1118     AbstractGangTask(&quot;G1 Merge Heap Roots&quot;),</span>
<span class="line-modified">1119     _hr_claimer(num_workers),</span>
<span class="line-modified">1120     _scan_state(scan_state),</span>
<span class="line-modified">1121     _dirty_card_buffers(),</span>
<span class="line-modified">1122     _initial_evacuation(initial_evacuation),</span>
<span class="line-modified">1123     _fast_reclaim_handled(false)</span>
<span class="line-modified">1124   {</span>
<span class="line-modified">1125     if (initial_evacuation) {</span>
<span class="line-modified">1126       G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();</span>
<span class="line-modified">1127       G1BufferNodeList buffers = dcqs.take_all_completed_buffers();</span>
<span class="line-modified">1128       if (buffers._entry_count != 0) {</span>
<span class="line-modified">1129         _dirty_card_buffers.prepend(*buffers._head, *buffers._tail);</span>
<span class="line-modified">1130       }</span>




1131     }
<a name="83" id="anc83"></a>
1132   }
1133 
<a name="84" id="anc84"></a><span class="line-modified">1134   virtual void work(uint worker_id) {</span>
<span class="line-modified">1135     G1CollectedHeap* g1h = G1CollectedHeap::heap();</span>
<span class="line-modified">1136     G1GCPhaseTimes* p = g1h-&gt;phase_times();</span>
1137 
<a name="85" id="anc85"></a><span class="line-modified">1138     G1GCPhaseTimes::GCParPhases merge_remset_phase = _initial_evacuation ?</span>
<span class="line-modified">1139                                                      G1GCPhaseTimes::MergeRS :</span>
<span class="line-added">1140                                                      G1GCPhaseTimes::OptMergeRS;</span>
<span class="line-added">1141 </span>
<span class="line-added">1142     // We schedule flushing the remembered sets of humongous fast reclaim candidates</span>
<span class="line-added">1143     // onto the card table first to allow the remaining parallelized tasks hide it.</span>
<span class="line-added">1144     if (_initial_evacuation &amp;&amp;</span>
<span class="line-added">1145         p-&gt;fast_reclaim_humongous_candidates() &gt; 0 &amp;&amp;</span>
<span class="line-added">1146         !_fast_reclaim_handled &amp;&amp;</span>
<span class="line-added">1147         !Atomic::cmpxchg(&amp;_fast_reclaim_handled, false, true)) {</span>
1148 
<a name="86" id="anc86"></a><span class="line-modified">1149       G1GCParPhaseTimesTracker x(p, G1GCPhaseTimes::MergeER, worker_id);</span>
<span class="line-modified">1150 </span>
<span class="line-modified">1151       G1FlushHumongousCandidateRemSets cl(_scan_state);</span>
<span class="line-added">1152       g1h-&gt;heap_region_iterate(&amp;cl);</span>
<span class="line-added">1153 </span>
<span class="line-added">1154       p-&gt;record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_sparse(), G1GCPhaseTimes::MergeRSMergedSparse);</span>
<span class="line-added">1155       p-&gt;record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_fine(), G1GCPhaseTimes::MergeRSMergedFine);</span>
<span class="line-added">1156       p-&gt;record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_coarse(), G1GCPhaseTimes::MergeRSMergedCoarse);</span>
<span class="line-added">1157       p-&gt;record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.cards_dirty(), G1GCPhaseTimes::MergeRSDirtyCards);</span>
<span class="line-added">1158     }</span>
<span class="line-added">1159 </span>
<span class="line-added">1160     // Merge remembered sets of current candidates.</span>
<span class="line-added">1161     {</span>
<span class="line-added">1162       G1GCParPhaseTimesTracker x(p, merge_remset_phase, worker_id, _initial_evacuation /* must_record */);</span>
<span class="line-added">1163       G1MergeCardSetClosure cl(_scan_state);</span>
<span class="line-added">1164       g1h-&gt;collection_set_iterate_increment_from(&amp;cl, &amp;_hr_claimer, worker_id);</span>
<span class="line-added">1165 </span>
<span class="line-added">1166       p-&gt;record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_sparse(), G1GCPhaseTimes::MergeRSMergedSparse);</span>
<span class="line-added">1167       p-&gt;record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_fine(), G1GCPhaseTimes::MergeRSMergedFine);</span>
<span class="line-added">1168       p-&gt;record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_coarse(), G1GCPhaseTimes::MergeRSMergedCoarse);</span>
<span class="line-added">1169       p-&gt;record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.cards_dirty(), G1GCPhaseTimes::MergeRSDirtyCards);</span>
<span class="line-added">1170     }</span>
1171 
<a name="87" id="anc87"></a><span class="line-modified">1172     // Apply closure to log entries in the HCC.</span>
<span class="line-modified">1173     if (_initial_evacuation &amp;&amp; G1HotCardCache::default_use_cache()) {</span>
<span class="line-modified">1174       assert(merge_remset_phase == G1GCPhaseTimes::MergeRS, &quot;Wrong merge phase&quot;);</span>
<span class="line-added">1175       G1GCParPhaseTimesTracker x(p, G1GCPhaseTimes::MergeHCC, worker_id);</span>
<span class="line-added">1176       G1MergeLogBufferCardsClosure cl(g1h, _scan_state);</span>
<span class="line-added">1177       g1h-&gt;iterate_hcc_closure(&amp;cl, worker_id);</span>
<span class="line-added">1178 </span>
<span class="line-added">1179       p-&gt;record_thread_work_item(G1GCPhaseTimes::MergeHCC, worker_id, cl.cards_dirty(), G1GCPhaseTimes::MergeHCCDirtyCards);</span>
<span class="line-added">1180       p-&gt;record_thread_work_item(G1GCPhaseTimes::MergeHCC, worker_id, cl.cards_skipped(), G1GCPhaseTimes::MergeHCCSkippedCards);</span>
<span class="line-added">1181     }</span>
<span class="line-added">1182 </span>
<span class="line-added">1183     // Now apply the closure to all remaining log entries.</span>
<span class="line-added">1184     if (_initial_evacuation) {</span>
<span class="line-added">1185       assert(merge_remset_phase == G1GCPhaseTimes::MergeRS, &quot;Wrong merge phase&quot;);</span>
<span class="line-added">1186       G1GCParPhaseTimesTracker x(p, G1GCPhaseTimes::MergeLB, worker_id);</span>
<span class="line-added">1187 </span>
<span class="line-added">1188       G1MergeLogBufferCardsClosure cl(g1h, _scan_state);</span>
<span class="line-added">1189       apply_closure_to_dirty_card_buffers(&amp;cl, worker_id);</span>
<span class="line-added">1190 </span>
<span class="line-added">1191       p-&gt;record_thread_work_item(G1GCPhaseTimes::MergeLB, worker_id, cl.cards_dirty(), G1GCPhaseTimes::MergeLBDirtyCards);</span>
<span class="line-added">1192       p-&gt;record_thread_work_item(G1GCPhaseTimes::MergeLB, worker_id, cl.cards_skipped(), G1GCPhaseTimes::MergeLBSkippedCards);</span>
<span class="line-added">1193     }</span>
1194   }
<a name="88" id="anc88"></a><span class="line-added">1195 };</span>
<span class="line-added">1196 </span>
<span class="line-added">1197 void G1RemSet::print_merge_heap_roots_stats() {</span>
<span class="line-added">1198   size_t num_visited_cards = _scan_state-&gt;num_visited_cards();</span>
<span class="line-added">1199 </span>
<span class="line-added">1200   size_t total_dirty_region_cards = _scan_state-&gt;num_cards_in_dirty_regions();</span>
<span class="line-added">1201 </span>
<span class="line-added">1202   G1CollectedHeap* g1h = G1CollectedHeap::heap();</span>
<span class="line-added">1203   size_t total_old_region_cards =</span>
<span class="line-added">1204     (g1h-&gt;num_regions() - (g1h-&gt;num_free_regions() - g1h-&gt;collection_set()-&gt;cur_length())) * HeapRegion::CardsPerRegion;</span>
<span class="line-added">1205 </span>
<span class="line-added">1206   log_debug(gc,remset)(&quot;Visited cards &quot; SIZE_FORMAT &quot; Total dirty &quot; SIZE_FORMAT &quot; (%.2lf%%) Total old &quot; SIZE_FORMAT &quot; (%.2lf%%)&quot;,</span>
<span class="line-added">1207                        num_visited_cards,</span>
<span class="line-added">1208                        total_dirty_region_cards,</span>
<span class="line-added">1209                        percent_of(num_visited_cards, total_dirty_region_cards),</span>
<span class="line-added">1210                        total_old_region_cards,</span>
<span class="line-added">1211                        percent_of(num_visited_cards, total_old_region_cards));</span>
<span class="line-added">1212 }</span>
<span class="line-added">1213 </span>
<span class="line-added">1214 void G1RemSet::merge_heap_roots(bool initial_evacuation) {</span>
<span class="line-added">1215   G1CollectedHeap* g1h = G1CollectedHeap::heap();</span>
1216 
<a name="89" id="anc89"></a>
1217   {
<a name="90" id="anc90"></a><span class="line-modified">1218     Ticks start = Ticks::now();</span>
1219 
<a name="91" id="anc91"></a><span class="line-modified">1220     _scan_state-&gt;prepare_for_merge_heap_roots();</span>


1221 
<a name="92" id="anc92"></a><span class="line-modified">1222     Tickspan total = Ticks::now() - start;</span>
<span class="line-modified">1223     if (initial_evacuation) {</span>
<span class="line-added">1224       g1h-&gt;phase_times()-&gt;record_prepare_merge_heap_roots_time(total.seconds() * 1000.0);</span>
<span class="line-added">1225     } else {</span>
<span class="line-added">1226       g1h-&gt;phase_times()-&gt;record_or_add_optional_prepare_merge_heap_roots_time(total.seconds() * 1000.0);</span>
<span class="line-added">1227     }</span>
1228   }
<a name="93" id="anc93"></a>
1229 
<a name="94" id="anc94"></a><span class="line-modified">1230   WorkGang* workers = g1h-&gt;workers();</span>
<span class="line-modified">1231   size_t const increment_length = g1h-&gt;collection_set()-&gt;increment_length();</span>


1232 
<a name="95" id="anc95"></a><span class="line-modified">1233   uint const num_workers = initial_evacuation ? workers-&gt;active_workers() :</span>
<span class="line-modified">1234                                                 MIN2(workers-&gt;active_workers(), (uint)increment_length);</span>
<span class="line-modified">1235 </span>
<span class="line-added">1236   {</span>
<span class="line-added">1237     G1MergeHeapRootsTask cl(_scan_state, num_workers, initial_evacuation);</span>
<span class="line-added">1238     log_debug(gc, ergo)(&quot;Running %s using %u workers for &quot; SIZE_FORMAT &quot; regions&quot;,</span>
<span class="line-added">1239                         cl.name(), num_workers, increment_length);</span>
<span class="line-added">1240     workers-&gt;run_task(&amp;cl, num_workers);</span>
<span class="line-added">1241   }</span>
<span class="line-added">1242 </span>
<span class="line-added">1243   if (log_is_enabled(Debug, gc, remset)) {</span>
<span class="line-added">1244     print_merge_heap_roots_stats();</span>
<span class="line-added">1245   }</span>
<span class="line-added">1246 }</span>
1247 
<a name="96" id="anc96"></a><span class="line-modified">1248 void G1RemSet::exclude_region_from_scan(uint region_idx) {</span>
<span class="line-added">1249   _scan_state-&gt;clear_scan_top(region_idx);</span>
1250 }
1251 
<a name="97" id="anc97"></a><span class="line-modified">1252 void G1RemSet::cleanup_after_scan_heap_roots() {</span>
1253   G1GCPhaseTimes* phase_times = _g1h-&gt;phase_times();
1254 
1255   // Set all cards back to clean.
1256   double start = os::elapsedTime();
<a name="98" id="anc98"></a><span class="line-modified">1257   _scan_state-&gt;cleanup(_g1h-&gt;workers());</span>
1258   phase_times-&gt;record_clear_ct_time((os::elapsedTime() - start) * 1000.0);
1259 }
1260 
1261 inline void check_card_ptr(CardTable::CardValue* card_ptr, G1CardTable* ct) {
1262 #ifdef ASSERT
1263   G1CollectedHeap* g1h = G1CollectedHeap::heap();
1264   assert(g1h-&gt;is_in_exact(ct-&gt;addr_for(card_ptr)),
1265          &quot;Card at &quot; PTR_FORMAT &quot; index &quot; SIZE_FORMAT &quot; representing heap at &quot; PTR_FORMAT &quot; (%u) must be in committed heap&quot;,
1266          p2i(card_ptr),
1267          ct-&gt;index_for(ct-&gt;addr_for(card_ptr)),
1268          p2i(ct-&gt;addr_for(card_ptr)),
1269          g1h-&gt;addr_to_region(ct-&gt;addr_for(card_ptr)));
1270 #endif
1271 }
1272 
<a name="99" id="anc99"></a><span class="line-modified">1273 bool G1RemSet::clean_card_before_refine(CardValue** const card_ptr_addr) {</span>

1274   assert(!_g1h-&gt;is_gc_active(), &quot;Only call concurrently&quot;);
1275 
<a name="100" id="anc100"></a><span class="line-modified">1276   CardValue* card_ptr = *card_ptr_addr;</span>
<span class="line-added">1277   // Find the start address represented by the card.</span>
1278   HeapWord* start = _ct-&gt;addr_for(card_ptr);
1279   // And find the region containing it.
1280   HeapRegion* r = _g1h-&gt;heap_region_containing_or_null(start);
1281 
1282   // If this is a (stale) card into an uncommitted region, exit.
1283   if (r == NULL) {
<a name="101" id="anc101"></a><span class="line-modified">1284     return false;</span>
1285   }
1286 
1287   check_card_ptr(card_ptr, _ct);
1288 
1289   // If the card is no longer dirty, nothing to do.
<a name="102" id="anc102"></a><span class="line-added">1290   // We cannot load the card value before the &quot;r == NULL&quot; check, because G1</span>
<span class="line-added">1291   // could uncommit parts of the card table covering uncommitted regions.</span>
1292   if (*card_ptr != G1CardTable::dirty_card_val()) {
<a name="103" id="anc103"></a><span class="line-modified">1293     return false;</span>
1294   }
1295 
1296   // This check is needed for some uncommon cases where we should
1297   // ignore the card.
1298   //
1299   // The region could be young.  Cards for young regions are
1300   // distinctly marked (set to g1_young_gen), so the post-barrier will
1301   // filter them out.  However, that marking is performed
1302   // concurrently.  A write to a young object could occur before the
1303   // card has been marked young, slipping past the filter.
1304   //
1305   // The card could be stale, because the region has been freed since
1306   // the card was recorded. In this case the region type could be
1307   // anything.  If (still) free or (reallocated) young, just ignore
1308   // it.  If (reallocated) old or humongous, the later card trimming
1309   // and additional checks in iteration may detect staleness.  At
1310   // worst, we end up processing a stale card unnecessarily.
1311   //
1312   // In the normal (non-stale) case, the synchronization between the
1313   // enqueueing of the card and processing it here will have ensured
1314   // we see the up-to-date region type here.
1315   if (!r-&gt;is_old_or_humongous_or_archive()) {
<a name="104" id="anc104"></a><span class="line-modified">1316     return false;</span>
1317   }
1318 
1319   // The result from the hot card cache insert call is either:
1320   //   * pointer to the current card
1321   //     (implying that the current card is not &#39;hot&#39;),
1322   //   * null
1323   //     (meaning we had inserted the card ptr into the &quot;hot&quot; card cache,
1324   //     which had some headroom),
1325   //   * a pointer to a &quot;hot&quot; card that was evicted from the &quot;hot&quot; cache.
1326   //
1327 
1328   if (_hot_card_cache-&gt;use_cache()) {
1329     assert(!SafepointSynchronize::is_at_safepoint(), &quot;sanity&quot;);
1330 
1331     const CardValue* orig_card_ptr = card_ptr;
1332     card_ptr = _hot_card_cache-&gt;insert(card_ptr);
1333     if (card_ptr == NULL) {
1334       // There was no eviction. Nothing to do.
<a name="105" id="anc105"></a><span class="line-modified">1335       return false;</span>
1336     } else if (card_ptr != orig_card_ptr) {
1337       // Original card was inserted and an old card was evicted.
1338       start = _ct-&gt;addr_for(card_ptr);
1339       r = _g1h-&gt;heap_region_containing(start);
1340 
1341       // Check whether the region formerly in the cache should be
1342       // ignored, as discussed earlier for the original card.  The
1343       // region could have been freed while in the cache.
1344       if (!r-&gt;is_old_or_humongous_or_archive()) {
<a name="106" id="anc106"></a><span class="line-modified">1345         return false;</span>
1346       }
<a name="107" id="anc107"></a><span class="line-added">1347       *card_ptr_addr = card_ptr;</span>
1348     } // Else we still have the original card.
1349   }
1350 
1351   // Trim the region designated by the card to what&#39;s been allocated
1352   // in the region.  The card could be stale, or the card could cover
1353   // (part of) an object at the end of the allocated space and extend
1354   // beyond the end of allocation.
1355 
<a name="108" id="anc108"></a><span class="line-modified">1356   // Non-humongous objects are either allocated in the old regions during GC,</span>
<span class="line-modified">1357   // or mapped in archive regions during startup. So if region is old or</span>
<span class="line-modified">1358   // archive then top is stable.</span>
<span class="line-modified">1359   // Humongous object allocation sets top last; if top has not yet been set,</span>
<span class="line-modified">1360   // this is a stale card and we&#39;ll end up with an empty intersection.</span>
<span class="line-added">1361   // If this is not a stale card, the synchronization between the</span>
1362   // enqueuing of the card and processing it here will have ensured
1363   // we see the up-to-date top here.
1364   HeapWord* scan_limit = r-&gt;top();
1365 
1366   if (scan_limit &lt;= start) {
1367     // If the trimmed region is empty, the card must be stale.
<a name="109" id="anc109"></a><span class="line-modified">1368     return false;</span>
1369   }
1370 
1371   // Okay to clean and process the card now.  There are still some
1372   // stale card cases that may be detected by iteration and dealt with
1373   // as iteration failure.
1374   *const_cast&lt;volatile CardValue*&gt;(card_ptr) = G1CardTable::clean_card_val();
1375 
<a name="110" id="anc110"></a><span class="line-modified">1376   return true;</span>
<span class="line-modified">1377 }</span>
<span class="line-modified">1378 </span>
<span class="line-modified">1379 void G1RemSet::refine_card_concurrently(CardValue* const card_ptr,</span>
<span class="line-modified">1380                                         const uint worker_id) {</span>
<span class="line-modified">1381   assert(!_g1h-&gt;is_gc_active(), &quot;Only call concurrently&quot;);</span>
<span class="line-modified">1382   check_card_ptr(card_ptr, _ct);</span>
<span class="line-added">1383 </span>
<span class="line-added">1384   // Construct the MemRegion representing the card.</span>
<span class="line-added">1385   HeapWord* start = _ct-&gt;addr_for(card_ptr);</span>
<span class="line-added">1386   // And find the region containing it.</span>
<span class="line-added">1387   HeapRegion* r = _g1h-&gt;heap_region_containing(start);</span>
<span class="line-added">1388   // This reload of the top is safe even though it happens after the full</span>
<span class="line-added">1389   // fence, because top is stable for old, archive and unfiltered humongous</span>
<span class="line-added">1390   // regions, so it must return the same value as the previous load when</span>
<span class="line-added">1391   // cleaning the card. Also cleaning the card and refinement of the card</span>
<span class="line-added">1392   // cannot span across safepoint, so we don&#39;t need to worry about top being</span>
<span class="line-added">1393   // changed during safepoint.</span>
<span class="line-added">1394   HeapWord* scan_limit = r-&gt;top();</span>
<span class="line-added">1395   assert(scan_limit &gt; start, &quot;sanity&quot;);</span>
1396 
1397   // Don&#39;t use addr_for(card_ptr + 1) which can ask for
1398   // a card beyond the heap.
1399   HeapWord* end = start + G1CardTable::card_size_in_words;
1400   MemRegion dirty_region(start, MIN2(scan_limit, end));
1401   assert(!dirty_region.is_empty(), &quot;sanity&quot;);
1402 
<a name="111" id="anc111"></a><span class="line-modified">1403   G1ConcurrentRefineOopClosure conc_refine_cl(_g1h, worker_id);</span>
<span class="line-modified">1404   if (r-&gt;oops_on_memregion_seq_iterate_careful&lt;false&gt;(dirty_region, &amp;conc_refine_cl) != NULL) {</span>
<span class="line-modified">1405     return;</span>













































1406   }
1407 
<a name="112" id="anc112"></a><span class="line-modified">1408   // If unable to process the card then we encountered an unparsable</span>
<span class="line-modified">1409   // part of the heap (e.g. a partially allocated object, so only</span>
<span class="line-modified">1410   // temporarily a problem) while processing a stale card.  Despite</span>
<span class="line-modified">1411   // the card being stale, we can&#39;t simply ignore it, because we&#39;ve</span>
<span class="line-modified">1412   // already marked the card cleaned, so taken responsibility for</span>
<span class="line-modified">1413   // ensuring the card gets scanned.</span>
<span class="line-modified">1414   //</span>
<span class="line-modified">1415   // However, the card might have gotten re-dirtied and re-enqueued</span>
<span class="line-added">1416   // while we worked.  (In fact, it&#39;s pretty likely.)</span>
<span class="line-added">1417   if (*card_ptr == G1CardTable::dirty_card_val()) {</span>
<span class="line-added">1418     return;</span>
1419   }
1420 
<a name="113" id="anc113"></a><span class="line-modified">1421   // Re-dirty the card and enqueue in the *shared* queue.  Can&#39;t use</span>
<span class="line-modified">1422   // the thread-local queue, because that might be the queue that is</span>
<span class="line-modified">1423   // being processed by us; we could be a Java thread conscripted to</span>
<span class="line-modified">1424   // perform refinement on our queue&#39;s current buffer.</span>
<span class="line-modified">1425   *card_ptr = G1CardTable::dirty_card_val();</span>
<span class="line-modified">1426   G1BarrierSet::shared_dirty_card_queue().enqueue(card_ptr);</span>





1427 }
1428 
1429 void G1RemSet::print_periodic_summary_info(const char* header, uint period_count) {
1430   if ((G1SummarizeRSetStatsPeriod &gt; 0) &amp;&amp; log_is_enabled(Trace, gc, remset) &amp;&amp;
1431       (period_count % G1SummarizeRSetStatsPeriod == 0)) {
1432 
<a name="114" id="anc114"></a><span class="line-modified">1433     G1RemSetSummary current;</span>
1434     _prev_period_summary.subtract_from(&amp;current);
1435 
1436     Log(gc, remset) log;
1437     log.trace(&quot;%s&quot;, header);
1438     ResourceMark rm;
1439     LogStream ls(log.trace());
1440     _prev_period_summary.print_on(&amp;ls);
1441 
1442     _prev_period_summary.set(&amp;current);
1443   }
1444 }
1445 
1446 void G1RemSet::print_summary_info() {
1447   Log(gc, remset, exit) log;
1448   if (log.is_trace()) {
1449     log.trace(&quot; Cumulative RS summary&quot;);
<a name="115" id="anc115"></a><span class="line-modified">1450     G1RemSetSummary current;</span>
1451     ResourceMark rm;
1452     LogStream ls(log.trace());
1453     current.print_on(&amp;ls);
1454   }
1455 }
1456 
1457 class G1RebuildRemSetTask: public AbstractGangTask {
1458   // Aggregate the counting data that was constructed concurrently
1459   // with marking.
1460   class G1RebuildRemSetHeapRegionClosure : public HeapRegionClosure {
1461     G1ConcurrentMark* _cm;
1462     G1RebuildRemSetClosure _update_cl;
1463 
1464     // Applies _update_cl to the references of the given object, limiting objArrays
1465     // to the given MemRegion. Returns the amount of words actually scanned.
1466     size_t scan_for_references(oop const obj, MemRegion mr) {
1467       size_t const obj_size = obj-&gt;size();
1468       // All non-objArrays and objArrays completely within the mr
1469       // can be scanned without passing the mr.
<a name="116" id="anc116"></a><span class="line-modified">1470       if (!obj-&gt;is_objArray() || mr.contains(MemRegion(cast_from_oop&lt;HeapWord*&gt;(obj), obj_size))) {</span>
1471         obj-&gt;oop_iterate(&amp;_update_cl);
1472         return obj_size;
1473       }
1474       // This path is for objArrays crossing the given MemRegion. Only scan the
1475       // area within the MemRegion.
1476       obj-&gt;oop_iterate(&amp;_update_cl, mr);
<a name="117" id="anc117"></a><span class="line-modified">1477       return mr.intersection(MemRegion(cast_from_oop&lt;HeapWord*&gt;(obj), obj_size)).word_size();</span>
1478     }
1479 
1480     // A humongous object is live (with respect to the scanning) either
1481     // a) it is marked on the bitmap as such
1482     // b) its TARS is larger than TAMS, i.e. has been allocated during marking.
1483     bool is_humongous_live(oop const humongous_obj, const G1CMBitMap* const bitmap, HeapWord* tams, HeapWord* tars) const {
1484       return bitmap-&gt;is_marked(humongous_obj) || (tars &gt; tams);
1485     }
1486 
1487     // Iterator over the live objects within the given MemRegion.
1488     class LiveObjIterator : public StackObj {
1489       const G1CMBitMap* const _bitmap;
1490       const HeapWord* _tams;
1491       const MemRegion _mr;
1492       HeapWord* _current;
1493 
1494       bool is_below_tams() const {
1495         return _current &lt; _tams;
1496       }
1497 
1498       bool is_live(HeapWord* obj) const {
1499         return !is_below_tams() || _bitmap-&gt;is_marked(obj);
1500       }
1501 
1502       HeapWord* bitmap_limit() const {
1503         return MIN2(const_cast&lt;HeapWord*&gt;(_tams), _mr.end());
1504       }
1505 
1506       void move_if_below_tams() {
1507         if (is_below_tams() &amp;&amp; has_next()) {
1508           _current = _bitmap-&gt;get_next_marked_addr(_current, bitmap_limit());
1509         }
1510       }
1511     public:
1512       LiveObjIterator(const G1CMBitMap* const bitmap, const HeapWord* tams, const MemRegion mr, HeapWord* first_oop_into_mr) :
1513           _bitmap(bitmap),
1514           _tams(tams),
1515           _mr(mr),
1516           _current(first_oop_into_mr) {
1517 
1518         assert(_current &lt;= _mr.start(),
1519                &quot;First oop &quot; PTR_FORMAT &quot; should extend into mr [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
1520                p2i(first_oop_into_mr), p2i(mr.start()), p2i(mr.end()));
1521 
1522         // Step to the next live object within the MemRegion if needed.
1523         if (is_live(_current)) {
1524           // Non-objArrays were scanned by the previous part of that region.
1525           if (_current &lt; mr.start() &amp;&amp; !oop(_current)-&gt;is_objArray()) {
1526             _current += oop(_current)-&gt;size();
1527             // We might have positioned _current on a non-live object. Reposition to the next
1528             // live one if needed.
1529             move_if_below_tams();
1530           }
1531         } else {
1532           // The object at _current can only be dead if below TAMS, so we can use the bitmap.
1533           // immediately.
1534           _current = _bitmap-&gt;get_next_marked_addr(_current, bitmap_limit());
1535           assert(_current == _mr.end() || is_live(_current),
1536                  &quot;Current &quot; PTR_FORMAT &quot; should be live (%s) or beyond the end of the MemRegion (&quot; PTR_FORMAT &quot;)&quot;,
1537                  p2i(_current), BOOL_TO_STR(is_live(_current)), p2i(_mr.end()));
1538         }
1539       }
1540 
1541       void move_to_next() {
1542         _current += next()-&gt;size();
1543         move_if_below_tams();
1544       }
1545 
1546       oop next() const {
1547         oop result = oop(_current);
1548         assert(is_live(_current),
1549                &quot;Object &quot; PTR_FORMAT &quot; must be live TAMS &quot; PTR_FORMAT &quot; below %d mr &quot; PTR_FORMAT &quot; &quot; PTR_FORMAT &quot; outside %d&quot;,
1550                p2i(_current), p2i(_tams), _tams &gt; _current, p2i(_mr.start()), p2i(_mr.end()), _mr.contains(result));
1551         return result;
1552       }
1553 
1554       bool has_next() const {
1555         return _current &lt; _mr.end();
1556       }
1557     };
1558 
1559     // Rebuild remembered sets in the part of the region specified by mr and hr.
1560     // Objects between the bottom of the region and the TAMS are checked for liveness
1561     // using the given bitmap. Objects between TAMS and TARS are assumed to be live.
1562     // Returns the number of live words between bottom and TAMS.
1563     size_t rebuild_rem_set_in_region(const G1CMBitMap* const bitmap,
1564                                      HeapWord* const top_at_mark_start,
1565                                      HeapWord* const top_at_rebuild_start,
1566                                      HeapRegion* hr,
1567                                      MemRegion mr) {
1568       size_t marked_words = 0;
1569 
1570       if (hr-&gt;is_humongous()) {
1571         oop const humongous_obj = oop(hr-&gt;humongous_start_region()-&gt;bottom());
1572         if (is_humongous_live(humongous_obj, bitmap, top_at_mark_start, top_at_rebuild_start)) {
1573           // We need to scan both [bottom, TAMS) and [TAMS, top_at_rebuild_start);
1574           // however in case of humongous objects it is sufficient to scan the encompassing
1575           // area (top_at_rebuild_start is always larger or equal to TAMS) as one of the
1576           // two areas will be zero sized. I.e. TAMS is either
1577           // the same as bottom or top(_at_rebuild_start). There is no way TAMS has a different
1578           // value: this would mean that TAMS points somewhere into the object.
1579           assert(hr-&gt;top() == top_at_mark_start || hr-&gt;top() == top_at_rebuild_start,
1580                  &quot;More than one object in the humongous region?&quot;);
1581           humongous_obj-&gt;oop_iterate(&amp;_update_cl, mr);
<a name="118" id="anc118"></a><span class="line-modified">1582           return top_at_mark_start != hr-&gt;bottom() ? mr.intersection(MemRegion(cast_from_oop&lt;HeapWord*&gt;(humongous_obj), humongous_obj-&gt;size())).byte_size() : 0;</span>
1583         } else {
1584           return 0;
1585         }
1586       }
1587 
1588       for (LiveObjIterator it(bitmap, top_at_mark_start, mr, hr-&gt;block_start(mr.start())); it.has_next(); it.move_to_next()) {
1589         oop obj = it.next();
1590         size_t scanned_size = scan_for_references(obj, mr);
<a name="119" id="anc119"></a><span class="line-modified">1591         if (cast_from_oop&lt;HeapWord*&gt;(obj) &lt; top_at_mark_start) {</span>
1592           marked_words += scanned_size;
1593         }
1594       }
1595 
1596       return marked_words * HeapWordSize;
1597     }
1598 public:
1599   G1RebuildRemSetHeapRegionClosure(G1CollectedHeap* g1h,
1600                                    G1ConcurrentMark* cm,
1601                                    uint worker_id) :
1602     HeapRegionClosure(),
1603     _cm(cm),
1604     _update_cl(g1h, worker_id) { }
1605 
1606     bool do_heap_region(HeapRegion* hr) {
1607       if (_cm-&gt;has_aborted()) {
1608         return true;
1609       }
1610 
1611       uint const region_idx = hr-&gt;hrm_index();
1612       DEBUG_ONLY(HeapWord* const top_at_rebuild_start_check = _cm-&gt;top_at_rebuild_start(region_idx);)
1613       assert(top_at_rebuild_start_check == NULL ||
1614              top_at_rebuild_start_check &gt; hr-&gt;bottom(),
1615              &quot;A TARS (&quot; PTR_FORMAT &quot;) == bottom() (&quot; PTR_FORMAT &quot;) indicates the old region %u is empty (%s)&quot;,
1616              p2i(top_at_rebuild_start_check), p2i(hr-&gt;bottom()),  region_idx, hr-&gt;get_type_str());
1617 
1618       size_t total_marked_bytes = 0;
1619       size_t const chunk_size_in_words = G1RebuildRemSetChunkSize / HeapWordSize;
1620 
1621       HeapWord* const top_at_mark_start = hr-&gt;prev_top_at_mark_start();
1622 
1623       HeapWord* cur = hr-&gt;bottom();
1624       while (cur &lt; hr-&gt;end()) {
1625         // After every iteration (yield point) we need to check whether the region&#39;s
1626         // TARS changed due to e.g. eager reclaim.
1627         HeapWord* const top_at_rebuild_start = _cm-&gt;top_at_rebuild_start(region_idx);
1628         if (top_at_rebuild_start == NULL) {
1629           return false;
1630         }
1631 
1632         MemRegion next_chunk = MemRegion(hr-&gt;bottom(), top_at_rebuild_start).intersection(MemRegion(cur, chunk_size_in_words));
1633         if (next_chunk.is_empty()) {
1634           break;
1635         }
1636 
1637         const Ticks start = Ticks::now();
1638         size_t marked_bytes = rebuild_rem_set_in_region(_cm-&gt;prev_mark_bitmap(),
1639                                                         top_at_mark_start,
1640                                                         top_at_rebuild_start,
1641                                                         hr,
1642                                                         next_chunk);
1643         Tickspan time = Ticks::now() - start;
1644 
1645         log_trace(gc, remset, tracking)(&quot;Rebuilt region %u &quot;
1646                                         &quot;live &quot; SIZE_FORMAT &quot; &quot;
1647                                         &quot;time %.3fms &quot;
1648                                         &quot;marked bytes &quot; SIZE_FORMAT &quot; &quot;
1649                                         &quot;bot &quot; PTR_FORMAT &quot; &quot;
1650                                         &quot;TAMS &quot; PTR_FORMAT &quot; &quot;
1651                                         &quot;TARS &quot; PTR_FORMAT,
1652                                         region_idx,
1653                                         _cm-&gt;liveness(region_idx) * HeapWordSize,
1654                                         time.seconds() * 1000.0,
1655                                         marked_bytes,
1656                                         p2i(hr-&gt;bottom()),
1657                                         p2i(top_at_mark_start),
1658                                         p2i(top_at_rebuild_start));
1659 
1660         if (marked_bytes &gt; 0) {
1661           total_marked_bytes += marked_bytes;
1662         }
1663         cur += chunk_size_in_words;
1664 
1665         _cm-&gt;do_yield_check();
1666         if (_cm-&gt;has_aborted()) {
1667           return true;
1668         }
1669       }
1670       // In the final iteration of the loop the region might have been eagerly reclaimed.
1671       // Simply filter out those regions. We can not just use region type because there
1672       // might have already been new allocations into these regions.
1673       DEBUG_ONLY(HeapWord* const top_at_rebuild_start = _cm-&gt;top_at_rebuild_start(region_idx);)
1674       assert(top_at_rebuild_start == NULL ||
1675              total_marked_bytes == hr-&gt;marked_bytes(),
1676              &quot;Marked bytes &quot; SIZE_FORMAT &quot; for region %u (%s) in [bottom, TAMS) do not match calculated marked bytes &quot; SIZE_FORMAT &quot; &quot;
1677              &quot;(&quot; PTR_FORMAT &quot; &quot; PTR_FORMAT &quot; &quot; PTR_FORMAT &quot;)&quot;,
1678              total_marked_bytes, hr-&gt;hrm_index(), hr-&gt;get_type_str(), hr-&gt;marked_bytes(),
1679              p2i(hr-&gt;bottom()), p2i(top_at_mark_start), p2i(top_at_rebuild_start));
1680        // Abort state may have changed after the yield check.
1681       return _cm-&gt;has_aborted();
1682     }
1683   };
1684 
1685   HeapRegionClaimer _hr_claimer;
1686   G1ConcurrentMark* _cm;
1687 
1688   uint _worker_id_offset;
1689 public:
1690   G1RebuildRemSetTask(G1ConcurrentMark* cm,
1691                       uint n_workers,
1692                       uint worker_id_offset) :
1693       AbstractGangTask(&quot;G1 Rebuild Remembered Set&quot;),
1694       _hr_claimer(n_workers),
1695       _cm(cm),
1696       _worker_id_offset(worker_id_offset) {
1697   }
1698 
1699   void work(uint worker_id) {
1700     SuspendibleThreadSetJoiner sts_join;
1701 
1702     G1CollectedHeap* g1h = G1CollectedHeap::heap();
1703 
1704     G1RebuildRemSetHeapRegionClosure cl(g1h, _cm, _worker_id_offset + worker_id);
1705     g1h-&gt;heap_region_par_iterate_from_worker_offset(&amp;cl, &amp;_hr_claimer, worker_id);
1706   }
1707 };
1708 
1709 void G1RemSet::rebuild_rem_set(G1ConcurrentMark* cm,
1710                                WorkGang* workers,
1711                                uint worker_id_offset) {
1712   uint num_workers = workers-&gt;active_workers();
1713 
1714   G1RebuildRemSetTask cl(cm,
1715                          num_workers,
1716                          worker_id_offset);
1717   workers-&gt;run_task(&amp;cl, num_workers);
1718 }
<a name="120" id="anc120"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="120" type="hidden" />
</body>
</html>
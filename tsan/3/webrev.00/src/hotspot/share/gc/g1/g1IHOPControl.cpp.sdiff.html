<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1IHOPControl.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1HotCardCache.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1IHOPControl.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1IHOPControl.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 27 #include &quot;gc/g1/g1IHOPControl.hpp&quot;
 28 #include &quot;gc/g1/g1Predictions.hpp&quot;
<span class="line-modified"> 29 #include &quot;gc/shared/gcTrace.hpp&quot;</span>
 30 #include &quot;logging/log.hpp&quot;
 31 
 32 G1IHOPControl::G1IHOPControl(double initial_ihop_percent) :
 33   _initial_ihop_percent(initial_ihop_percent),
 34   _target_occupancy(0),
 35   _last_allocation_time_s(0.0),
 36   _last_allocated_bytes(0)
 37 {
 38   assert(_initial_ihop_percent &gt;= 0.0 &amp;&amp; _initial_ihop_percent &lt;= 100.0, &quot;Initial IHOP value must be between 0 and 100 but is %.3f&quot;, initial_ihop_percent);
 39 }
 40 
 41 void G1IHOPControl::update_target_occupancy(size_t new_target_occupancy) {
 42   log_debug(gc, ihop)(&quot;Target occupancy update: old: &quot; SIZE_FORMAT &quot;B, new: &quot; SIZE_FORMAT &quot;B&quot;,
 43                       _target_occupancy, new_target_occupancy);
 44   _target_occupancy = new_target_occupancy;
 45 }
 46 
 47 void G1IHOPControl::update_allocation_info(double allocation_time_s, size_t allocated_bytes, size_t additional_buffer_size) {
 48   assert(allocation_time_s &gt;= 0.0, &quot;Allocation time must be positive but is %.3f&quot;, allocation_time_s);
 49 
</pre>
<hr />
<pre>
 96 }
 97 
 98 size_t G1AdaptiveIHOPControl::actual_target_threshold() const {
 99   guarantee(_target_occupancy &gt; 0, &quot;Target occupancy still not updated yet.&quot;);
100   // The actual target threshold takes the heap reserve and the expected waste in
101   // free space  into account.
102   // _heap_reserve is that part of the total heap capacity that is reserved for
103   // eventual promotion failure.
104   // _heap_waste is the amount of space will never be reclaimed in any
105   // heap, so can not be used for allocation during marking and must always be
106   // considered.
107 
108   double safe_total_heap_percentage = MIN2((double)(_heap_reserve_percent + _heap_waste_percent), 100.0);
109 
110   return (size_t)MIN2(
111     G1CollectedHeap::heap()-&gt;max_capacity() * (100.0 - safe_total_heap_percentage) / 100.0,
112     _target_occupancy * (100.0 - _heap_waste_percent) / 100.0
113     );
114 }
115 




116 bool G1AdaptiveIHOPControl::have_enough_data_for_prediction() const {
117   return ((size_t)_marking_times_s.num() &gt;= G1AdaptiveIHOPNumInitialSamples) &amp;&amp;
118          ((size_t)_allocation_rate_s.num() &gt;= G1AdaptiveIHOPNumInitialSamples);
119 }
120 
121 size_t G1AdaptiveIHOPControl::get_conc_mark_start_threshold() {
122   if (have_enough_data_for_prediction()) {
<span class="line-modified">123     double pred_marking_time = _predictor-&gt;get_new_prediction(&amp;_marking_times_s);</span>
<span class="line-modified">124     double pred_promotion_rate = _predictor-&gt;get_new_prediction(&amp;_allocation_rate_s);</span>
125     size_t pred_promotion_size = (size_t)(pred_marking_time * pred_promotion_rate);
126 
127     size_t predicted_needed_bytes_during_marking =
128       pred_promotion_size +
129       // In reality we would need the maximum size of the young gen during
130       // marking. This is a conservative estimate.
131       _last_unrestrained_young_size;
132 
133     size_t internal_threshold = actual_target_threshold();
134     size_t predicted_initiating_threshold = predicted_needed_bytes_during_marking &lt; internal_threshold ?
135                                             internal_threshold - predicted_needed_bytes_during_marking :
136                                             0;
137     return predicted_initiating_threshold;
138   } else {
139     // Use the initial value.
140     return (size_t)(_initial_ihop_percent * _target_occupancy / 100.0);
141   }
142 }
143 
144 void G1AdaptiveIHOPControl::update_allocation_info(double allocation_time_s,
</pre>
<hr />
<pre>
151 
152   _last_unrestrained_young_size = additional_buffer_size;
153 }
154 
155 void G1AdaptiveIHOPControl::update_marking_length(double marking_length_s) {
156    assert(marking_length_s &gt;= 0.0, &quot;Marking length must be larger than zero but is %.3f&quot;, marking_length_s);
157   _marking_times_s.add(marking_length_s);
158 }
159 
160 void G1AdaptiveIHOPControl::print() {
161   G1IHOPControl::print();
162   size_t actual_target = actual_target_threshold();
163   log_debug(gc, ihop)(&quot;Adaptive IHOP information (value update), threshold: &quot; SIZE_FORMAT &quot;B (%1.2f), internal target occupancy: &quot; SIZE_FORMAT &quot;B, &quot;
164                       &quot;occupancy: &quot; SIZE_FORMAT &quot;B, additional buffer size: &quot; SIZE_FORMAT &quot;B, predicted old gen allocation rate: %1.2fB/s, &quot;
165                       &quot;predicted marking phase length: %1.2fms, prediction active: %s&quot;,
166                       get_conc_mark_start_threshold(),
167                       percent_of(get_conc_mark_start_threshold(), actual_target),
168                       actual_target,
169                       G1CollectedHeap::heap()-&gt;used(),
170                       _last_unrestrained_young_size,
<span class="line-modified">171                       _predictor-&gt;get_new_prediction(&amp;_allocation_rate_s),</span>
<span class="line-modified">172                       _predictor-&gt;get_new_prediction(&amp;_marking_times_s) * 1000.0,</span>
173                       have_enough_data_for_prediction() ? &quot;true&quot; : &quot;false&quot;);
174 }
175 
176 void G1AdaptiveIHOPControl::send_trace_event(G1NewTracer* tracer) {
177   G1IHOPControl::send_trace_event(tracer);
178   tracer-&gt;report_adaptive_ihop_statistics(get_conc_mark_start_threshold(),
179                                           actual_target_threshold(),
180                                           G1CollectedHeap::heap()-&gt;used(),
181                                           _last_unrestrained_young_size,
<span class="line-modified">182                                           _predictor-&gt;get_new_prediction(&amp;_allocation_rate_s),</span>
<span class="line-modified">183                                           _predictor-&gt;get_new_prediction(&amp;_marking_times_s),</span>
184                                           have_enough_data_for_prediction());
185 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 27 #include &quot;gc/g1/g1IHOPControl.hpp&quot;
 28 #include &quot;gc/g1/g1Predictions.hpp&quot;
<span class="line-modified"> 29 #include &quot;gc/g1/g1Trace.hpp&quot;</span>
 30 #include &quot;logging/log.hpp&quot;
 31 
 32 G1IHOPControl::G1IHOPControl(double initial_ihop_percent) :
 33   _initial_ihop_percent(initial_ihop_percent),
 34   _target_occupancy(0),
 35   _last_allocation_time_s(0.0),
 36   _last_allocated_bytes(0)
 37 {
 38   assert(_initial_ihop_percent &gt;= 0.0 &amp;&amp; _initial_ihop_percent &lt;= 100.0, &quot;Initial IHOP value must be between 0 and 100 but is %.3f&quot;, initial_ihop_percent);
 39 }
 40 
 41 void G1IHOPControl::update_target_occupancy(size_t new_target_occupancy) {
 42   log_debug(gc, ihop)(&quot;Target occupancy update: old: &quot; SIZE_FORMAT &quot;B, new: &quot; SIZE_FORMAT &quot;B&quot;,
 43                       _target_occupancy, new_target_occupancy);
 44   _target_occupancy = new_target_occupancy;
 45 }
 46 
 47 void G1IHOPControl::update_allocation_info(double allocation_time_s, size_t allocated_bytes, size_t additional_buffer_size) {
 48   assert(allocation_time_s &gt;= 0.0, &quot;Allocation time must be positive but is %.3f&quot;, allocation_time_s);
 49 
</pre>
<hr />
<pre>
 96 }
 97 
 98 size_t G1AdaptiveIHOPControl::actual_target_threshold() const {
 99   guarantee(_target_occupancy &gt; 0, &quot;Target occupancy still not updated yet.&quot;);
100   // The actual target threshold takes the heap reserve and the expected waste in
101   // free space  into account.
102   // _heap_reserve is that part of the total heap capacity that is reserved for
103   // eventual promotion failure.
104   // _heap_waste is the amount of space will never be reclaimed in any
105   // heap, so can not be used for allocation during marking and must always be
106   // considered.
107 
108   double safe_total_heap_percentage = MIN2((double)(_heap_reserve_percent + _heap_waste_percent), 100.0);
109 
110   return (size_t)MIN2(
111     G1CollectedHeap::heap()-&gt;max_capacity() * (100.0 - safe_total_heap_percentage) / 100.0,
112     _target_occupancy * (100.0 - _heap_waste_percent) / 100.0
113     );
114 }
115 
<span class="line-added">116 double G1AdaptiveIHOPControl::predict(TruncatedSeq const* seq) const {</span>
<span class="line-added">117   return _predictor-&gt;predict_zero_bounded(seq);</span>
<span class="line-added">118 }</span>
<span class="line-added">119 </span>
120 bool G1AdaptiveIHOPControl::have_enough_data_for_prediction() const {
121   return ((size_t)_marking_times_s.num() &gt;= G1AdaptiveIHOPNumInitialSamples) &amp;&amp;
122          ((size_t)_allocation_rate_s.num() &gt;= G1AdaptiveIHOPNumInitialSamples);
123 }
124 
125 size_t G1AdaptiveIHOPControl::get_conc_mark_start_threshold() {
126   if (have_enough_data_for_prediction()) {
<span class="line-modified">127     double pred_marking_time = predict(&amp;_marking_times_s);</span>
<span class="line-modified">128     double pred_promotion_rate = predict(&amp;_allocation_rate_s);</span>
129     size_t pred_promotion_size = (size_t)(pred_marking_time * pred_promotion_rate);
130 
131     size_t predicted_needed_bytes_during_marking =
132       pred_promotion_size +
133       // In reality we would need the maximum size of the young gen during
134       // marking. This is a conservative estimate.
135       _last_unrestrained_young_size;
136 
137     size_t internal_threshold = actual_target_threshold();
138     size_t predicted_initiating_threshold = predicted_needed_bytes_during_marking &lt; internal_threshold ?
139                                             internal_threshold - predicted_needed_bytes_during_marking :
140                                             0;
141     return predicted_initiating_threshold;
142   } else {
143     // Use the initial value.
144     return (size_t)(_initial_ihop_percent * _target_occupancy / 100.0);
145   }
146 }
147 
148 void G1AdaptiveIHOPControl::update_allocation_info(double allocation_time_s,
</pre>
<hr />
<pre>
155 
156   _last_unrestrained_young_size = additional_buffer_size;
157 }
158 
159 void G1AdaptiveIHOPControl::update_marking_length(double marking_length_s) {
160    assert(marking_length_s &gt;= 0.0, &quot;Marking length must be larger than zero but is %.3f&quot;, marking_length_s);
161   _marking_times_s.add(marking_length_s);
162 }
163 
164 void G1AdaptiveIHOPControl::print() {
165   G1IHOPControl::print();
166   size_t actual_target = actual_target_threshold();
167   log_debug(gc, ihop)(&quot;Adaptive IHOP information (value update), threshold: &quot; SIZE_FORMAT &quot;B (%1.2f), internal target occupancy: &quot; SIZE_FORMAT &quot;B, &quot;
168                       &quot;occupancy: &quot; SIZE_FORMAT &quot;B, additional buffer size: &quot; SIZE_FORMAT &quot;B, predicted old gen allocation rate: %1.2fB/s, &quot;
169                       &quot;predicted marking phase length: %1.2fms, prediction active: %s&quot;,
170                       get_conc_mark_start_threshold(),
171                       percent_of(get_conc_mark_start_threshold(), actual_target),
172                       actual_target,
173                       G1CollectedHeap::heap()-&gt;used(),
174                       _last_unrestrained_young_size,
<span class="line-modified">175                       predict(&amp;_allocation_rate_s),</span>
<span class="line-modified">176                       predict(&amp;_marking_times_s) * 1000.0,</span>
177                       have_enough_data_for_prediction() ? &quot;true&quot; : &quot;false&quot;);
178 }
179 
180 void G1AdaptiveIHOPControl::send_trace_event(G1NewTracer* tracer) {
181   G1IHOPControl::send_trace_event(tracer);
182   tracer-&gt;report_adaptive_ihop_statistics(get_conc_mark_start_threshold(),
183                                           actual_target_threshold(),
184                                           G1CollectedHeap::heap()-&gt;used(),
185                                           _last_unrestrained_young_size,
<span class="line-modified">186                                           predict(&amp;_allocation_rate_s),</span>
<span class="line-modified">187                                           predict(&amp;_marking_times_s),</span>
188                                           have_enough_data_for_prediction());
189 }
</pre>
</td>
</tr>
</table>
<center><a href="g1HotCardCache.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1IHOPControl.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/g1/heapRegion.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/nmethod.hpp&quot;
 27 #include &quot;gc/g1/g1BlockOffsetTable.inline.hpp&quot;
 28 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 29 #include &quot;gc/g1/g1CollectionSet.hpp&quot;
 30 #include &quot;gc/g1/g1HeapRegionTraceType.hpp&quot;
<a name="1" id="anc1"></a>
 31 #include &quot;gc/g1/g1OopClosures.inline.hpp&quot;
 32 #include &quot;gc/g1/heapRegion.inline.hpp&quot;
 33 #include &quot;gc/g1/heapRegionBounds.inline.hpp&quot;
 34 #include &quot;gc/g1/heapRegionManager.inline.hpp&quot;
 35 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
 36 #include &quot;gc/g1/heapRegionTracer.hpp&quot;
 37 #include &quot;gc/shared/genOopClosures.inline.hpp&quot;
<a name="2" id="anc2"></a><span class="line-removed"> 38 #include &quot;gc/shared/space.inline.hpp&quot;</span>
 39 #include &quot;logging/log.hpp&quot;
 40 #include &quot;logging/logStream.hpp&quot;
 41 #include &quot;memory/iterator.inline.hpp&quot;
 42 #include &quot;memory/resourceArea.hpp&quot;
 43 #include &quot;oops/access.inline.hpp&quot;
 44 #include &quot;oops/compressedOops.inline.hpp&quot;
 45 #include &quot;oops/oop.inline.hpp&quot;
<a name="3" id="anc3"></a><span class="line-removed"> 46 #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-removed"> 47 #include &quot;runtime/orderAccess.hpp&quot;</span>
<span class="line-removed"> 48 #include &quot;utilities/growableArray.hpp&quot;</span>
 49 
 50 int    HeapRegion::LogOfHRGrainBytes = 0;
 51 int    HeapRegion::LogOfHRGrainWords = 0;
<a name="4" id="anc4"></a>
 52 size_t HeapRegion::GrainBytes        = 0;
 53 size_t HeapRegion::GrainWords        = 0;
 54 size_t HeapRegion::CardsPerRegion    = 0;
 55 
 56 size_t HeapRegion::max_region_size() {
 57   return HeapRegionBounds::max_size();
 58 }
 59 
 60 size_t HeapRegion::min_region_size_in_words() {
 61   return HeapRegionBounds::min_size() &gt;&gt; LogHeapWordSize;
 62 }
 63 
 64 void HeapRegion::setup_heap_region_size(size_t initial_heap_size, size_t max_heap_size) {
 65   size_t region_size = G1HeapRegionSize;
 66   if (FLAG_IS_DEFAULT(G1HeapRegionSize)) {
 67     size_t average_heap_size = (initial_heap_size + max_heap_size) / 2;
 68     region_size = MAX2(average_heap_size / HeapRegionBounds::target_number(),
 69                        HeapRegionBounds::min_size());
 70   }
 71 
 72   int region_size_log = log2_long((jlong) region_size);
 73   // Recalculate the region size to make sure it&#39;s a power of
 74   // 2. This means that region_size is the largest power of 2 that&#39;s
 75   // &lt;= what we&#39;ve calculated so far.
 76   region_size = ((size_t)1 &lt;&lt; region_size_log);
 77 
 78   // Now make sure that we don&#39;t go over or under our limits.
 79   if (region_size &lt; HeapRegionBounds::min_size()) {
 80     region_size = HeapRegionBounds::min_size();
 81   } else if (region_size &gt; HeapRegionBounds::max_size()) {
 82     region_size = HeapRegionBounds::max_size();
 83   }
 84 
 85   // And recalculate the log.
 86   region_size_log = log2_long((jlong) region_size);
 87 
 88   // Now, set up the globals.
 89   guarantee(LogOfHRGrainBytes == 0, &quot;we should only set it once&quot;);
 90   LogOfHRGrainBytes = region_size_log;
 91 
 92   guarantee(LogOfHRGrainWords == 0, &quot;we should only set it once&quot;);
 93   LogOfHRGrainWords = LogOfHRGrainBytes - LogHeapWordSize;
 94 
 95   guarantee(GrainBytes == 0, &quot;we should only set it once&quot;);
 96   // The cast to int is safe, given that we&#39;ve bounded region_size by
 97   // MIN_REGION_SIZE and MAX_REGION_SIZE.
 98   GrainBytes = region_size;
 99   log_info(gc, heap)(&quot;Heap region size: &quot; SIZE_FORMAT &quot;M&quot;, GrainBytes / M);
100 
101   guarantee(GrainWords == 0, &quot;we should only set it once&quot;);
102   GrainWords = GrainBytes &gt;&gt; LogHeapWordSize;
103   guarantee((size_t) 1 &lt;&lt; LogOfHRGrainWords == GrainWords, &quot;sanity&quot;);
104 
105   guarantee(CardsPerRegion == 0, &quot;we should only set it once&quot;);
106   CardsPerRegion = GrainBytes &gt;&gt; G1CardTable::card_shift;
107 
<a name="5" id="anc5"></a>

108   if (G1HeapRegionSize != GrainBytes) {
<a name="6" id="anc6"></a><span class="line-modified">109     FLAG_SET_ERGO(size_t, G1HeapRegionSize, GrainBytes);</span>
110   }
111 }
112 
<a name="7" id="anc7"></a><span class="line-modified">113 void HeapRegion::hr_clear(bool keep_remset, bool clear_space, bool locked) {</span>













114   assert(_humongous_start_region == NULL,
115          &quot;we should have already filtered out humongous regions&quot;);
116   assert(!in_collection_set(),
117          &quot;Should not clear heap region %u in the collection set&quot;, hrm_index());
118 
<a name="8" id="anc8"></a><span class="line-modified">119   set_young_index_in_cset(-1);</span>

120   uninstall_surv_rate_group();
121   set_free();
122   reset_pre_dummy_top();
123 
<a name="9" id="anc9"></a><span class="line-modified">124   if (!keep_remset) {</span>
<span class="line-removed">125     if (locked) {</span>
<span class="line-removed">126       rem_set()-&gt;clear_locked();</span>
<span class="line-removed">127     } else {</span>
<span class="line-removed">128       rem_set()-&gt;clear();</span>
<span class="line-removed">129     }</span>
<span class="line-removed">130   }</span>
131 
132   zero_marked_bytes();
133 
134   init_top_at_mark_start();
135   if (clear_space) clear(SpaceDecorator::Mangle);
<a name="10" id="anc10"></a>


136 }
137 
138 void HeapRegion::clear_cardtable() {
139   G1CardTable* ct = G1CollectedHeap::heap()-&gt;card_table();
140   ct-&gt;clear(MemRegion(bottom(), end()));
141 }
142 
143 void HeapRegion::calc_gc_efficiency() {
144   // GC efficiency is the ratio of how much space would be
145   // reclaimed over how long we predict it would take to reclaim it.
<a name="11" id="anc11"></a><span class="line-modified">146   G1CollectedHeap* g1h = G1CollectedHeap::heap();</span>
<span class="line-removed">147   G1Policy* policy = g1h-&gt;policy();</span>
148 
149   // Retrieve a prediction of the elapsed time for this region for
150   // a mixed gc because the region will only be evacuated during a
151   // mixed gc.
<a name="12" id="anc12"></a><span class="line-modified">152   double region_elapsed_time_ms =</span>
<span class="line-removed">153     policy-&gt;predict_region_elapsed_time_ms(this, false /* for_young_gc */);</span>
154   _gc_efficiency = (double) reclaimable_bytes() / region_elapsed_time_ms;
155 }
156 
157 void HeapRegion::set_free() {
158   report_region_type_change(G1HeapRegionTraceType::Free);
159   _type.set_free();
160 }
161 
162 void HeapRegion::set_eden() {
163   report_region_type_change(G1HeapRegionTraceType::Eden);
164   _type.set_eden();
165 }
166 
167 void HeapRegion::set_eden_pre_gc() {
168   report_region_type_change(G1HeapRegionTraceType::Eden);
169   _type.set_eden_pre_gc();
170 }
171 
172 void HeapRegion::set_survivor() {
173   report_region_type_change(G1HeapRegionTraceType::Survivor);
174   _type.set_survivor();
175 }
176 
177 void HeapRegion::move_to_old() {
178   if (_type.relabel_as_old()) {
179     report_region_type_change(G1HeapRegionTraceType::Old);
180   }
181 }
182 
183 void HeapRegion::set_old() {
184   report_region_type_change(G1HeapRegionTraceType::Old);
185   _type.set_old();
186 }
187 
188 void HeapRegion::set_open_archive() {
189   report_region_type_change(G1HeapRegionTraceType::OpenArchive);
190   _type.set_open_archive();
191 }
192 
193 void HeapRegion::set_closed_archive() {
194   report_region_type_change(G1HeapRegionTraceType::ClosedArchive);
195   _type.set_closed_archive();
196 }
197 
198 void HeapRegion::set_starts_humongous(HeapWord* obj_top, size_t fill_size) {
199   assert(!is_humongous(), &quot;sanity / pre-condition&quot;);
200   assert(top() == bottom(), &quot;should be empty&quot;);
201 
202   report_region_type_change(G1HeapRegionTraceType::StartsHumongous);
203   _type.set_starts_humongous();
204   _humongous_start_region = this;
205 
206   _bot_part.set_for_starts_humongous(obj_top, fill_size);
207 }
208 
209 void HeapRegion::set_continues_humongous(HeapRegion* first_hr) {
210   assert(!is_humongous(), &quot;sanity / pre-condition&quot;);
211   assert(top() == bottom(), &quot;should be empty&quot;);
212   assert(first_hr-&gt;is_starts_humongous(), &quot;pre-condition&quot;);
213 
214   report_region_type_change(G1HeapRegionTraceType::ContinuesHumongous);
215   _type.set_continues_humongous();
216   _humongous_start_region = first_hr;
217 
218   _bot_part.set_object_can_span(true);
219 }
220 
221 void HeapRegion::clear_humongous() {
222   assert(is_humongous(), &quot;pre-condition&quot;);
223 
224   assert(capacity() == HeapRegion::GrainBytes, &quot;pre-condition&quot;);
225   _humongous_start_region = NULL;
226 
227   _bot_part.set_object_can_span(false);
228 }
229 
230 HeapRegion::HeapRegion(uint hrm_index,
231                        G1BlockOffsetTable* bot,
232                        MemRegion mr) :
<a name="13" id="anc13"></a><span class="line-modified">233     G1ContiguousSpace(bot),</span>
<span class="line-modified">234     _rem_set(NULL),</span>
<span class="line-modified">235     _hrm_index(hrm_index),</span>
<span class="line-modified">236     _type(),</span>
<span class="line-modified">237     _humongous_start_region(NULL),</span>
<span class="line-modified">238     _evacuation_failed(false),</span>
<span class="line-modified">239     _next(NULL), _prev(NULL),</span>







240 #ifdef ASSERT
<a name="14" id="anc14"></a><span class="line-modified">241     _containing_set(NULL),</span>
242 #endif
<a name="15" id="anc15"></a><span class="line-modified">243     _prev_marked_bytes(0), _next_marked_bytes(0), _gc_efficiency(0.0),</span>
<span class="line-modified">244     _index_in_opt_cset(G1OptionalCSet::InvalidCSetIndex), _young_index_in_cset(-1),</span>
<span class="line-modified">245     _surv_rate_group(NULL), _age_index(-1),</span>
<span class="line-modified">246     _prev_top_at_mark_start(NULL), _next_top_at_mark_start(NULL),</span>
<span class="line-modified">247     _recorded_rs_length(0), _predicted_elapsed_time_ms(0)</span>
248 {
<a name="16" id="anc16"></a><span class="line-modified">249   _rem_set = new HeapRegionRemSet(bot, this);</span>

250 
<a name="17" id="anc17"></a><span class="line-modified">251   initialize(mr);</span>

252 }
253 
<a name="18" id="anc18"></a><span class="line-modified">254 void HeapRegion::initialize(MemRegion mr, bool clear_space, bool mangle_space) {</span>
255   assert(_rem_set-&gt;is_empty(), &quot;Remembered set must be empty&quot;);
256 
<a name="19" id="anc19"></a><span class="line-modified">257   G1ContiguousSpace::initialize(mr, clear_space, mangle_space);</span>


258 
<a name="20" id="anc20"></a><span class="line-removed">259   hr_clear(false /*par*/, false /*clear_space*/);</span>
260   set_top(bottom());
<a name="21" id="anc21"></a>



261 }
262 
263 void HeapRegion::report_region_type_change(G1HeapRegionTraceType::Type to) {
264   HeapRegionTracer::send_region_type_change(_hrm_index,
265                                             get_trace_type(),
266                                             to,
267                                             (uintptr_t)bottom(),
268                                             used());
269 }
270 
271 void HeapRegion::note_self_forwarding_removal_start(bool during_initial_mark,
272                                                     bool during_conc_mark) {
273   // We always recreate the prev marking info and we&#39;ll explicitly
274   // mark all objects we find to be self-forwarded on the prev
275   // bitmap. So all objects need to be below PTAMS.
276   _prev_marked_bytes = 0;
277 
278   if (during_initial_mark) {
279     // During initial-mark, we&#39;ll also explicitly mark all objects
280     // we find to be self-forwarded on the next bitmap. So all
281     // objects need to be below NTAMS.
282     _next_top_at_mark_start = top();
283     _next_marked_bytes = 0;
284   } else if (during_conc_mark) {
285     // During concurrent mark, all objects in the CSet (including
286     // the ones we find to be self-forwarded) are implicitly live.
287     // So all objects need to be above NTAMS.
288     _next_top_at_mark_start = bottom();
289     _next_marked_bytes = 0;
290   }
291 }
292 
293 void HeapRegion::note_self_forwarding_removal_end(size_t marked_bytes) {
294   assert(marked_bytes &lt;= used(),
295          &quot;marked: &quot; SIZE_FORMAT &quot; used: &quot; SIZE_FORMAT, marked_bytes, used());
296   _prev_top_at_mark_start = top();
297   _prev_marked_bytes = marked_bytes;
298 }
299 
300 // Code roots support
301 
302 void HeapRegion::add_strong_code_root(nmethod* nm) {
303   HeapRegionRemSet* hrrs = rem_set();
304   hrrs-&gt;add_strong_code_root(nm);
305 }
306 
307 void HeapRegion::add_strong_code_root_locked(nmethod* nm) {
308   assert_locked_or_safepoint(CodeCache_lock);
309   HeapRegionRemSet* hrrs = rem_set();
310   hrrs-&gt;add_strong_code_root_locked(nm);
311 }
312 
313 void HeapRegion::remove_strong_code_root(nmethod* nm) {
314   HeapRegionRemSet* hrrs = rem_set();
315   hrrs-&gt;remove_strong_code_root(nm);
316 }
317 
318 void HeapRegion::strong_code_roots_do(CodeBlobClosure* blk) const {
319   HeapRegionRemSet* hrrs = rem_set();
320   hrrs-&gt;strong_code_roots_do(blk);
321 }
322 
323 class VerifyStrongCodeRootOopClosure: public OopClosure {
324   const HeapRegion* _hr;
325   bool _failures;
326   bool _has_oops_in_region;
327 
328   template &lt;class T&gt; void do_oop_work(T* p) {
329     T heap_oop = RawAccess&lt;&gt;::oop_load(p);
330     if (!CompressedOops::is_null(heap_oop)) {
331       oop obj = CompressedOops::decode_not_null(heap_oop);
332 
333       // Note: not all the oops embedded in the nmethod are in the
334       // current region. We only look at those which are.
335       if (_hr-&gt;is_in(obj)) {
336         // Object is in the region. Check that its less than top
<a name="22" id="anc22"></a><span class="line-modified">337         if (_hr-&gt;top() &lt;= (HeapWord*)obj) {</span>
338           // Object is above top
339           log_error(gc, verify)(&quot;Object &quot; PTR_FORMAT &quot; in region &quot; HR_FORMAT &quot; is above top &quot;,
340                                 p2i(obj), HR_FORMAT_PARAMS(_hr));
341           _failures = true;
342           return;
343         }
344         // Nmethod has at least one oop in the current region
345         _has_oops_in_region = true;
346       }
347     }
348   }
349 
350 public:
351   VerifyStrongCodeRootOopClosure(const HeapRegion* hr):
352     _hr(hr), _failures(false), _has_oops_in_region(false) {}
353 
354   void do_oop(narrowOop* p) { do_oop_work(p); }
355   void do_oop(oop* p)       { do_oop_work(p); }
356 
357   bool failures()           { return _failures; }
358   bool has_oops_in_region() { return _has_oops_in_region; }
359 };
360 
361 class VerifyStrongCodeRootCodeBlobClosure: public CodeBlobClosure {
362   const HeapRegion* _hr;
363   bool _failures;
364 public:
365   VerifyStrongCodeRootCodeBlobClosure(const HeapRegion* hr) :
366     _hr(hr), _failures(false) {}
367 
368   void do_code_blob(CodeBlob* cb) {
369     nmethod* nm = (cb == NULL) ? NULL : cb-&gt;as_compiled_method()-&gt;as_nmethod_or_null();
370     if (nm != NULL) {
371       // Verify that the nemthod is live
372       if (!nm-&gt;is_alive()) {
373         log_error(gc, verify)(&quot;region [&quot; PTR_FORMAT &quot;,&quot; PTR_FORMAT &quot;] has dead nmethod &quot; PTR_FORMAT &quot; in its strong code roots&quot;,
374                               p2i(_hr-&gt;bottom()), p2i(_hr-&gt;end()), p2i(nm));
375         _failures = true;
376       } else {
377         VerifyStrongCodeRootOopClosure oop_cl(_hr);
378         nm-&gt;oops_do(&amp;oop_cl);
379         if (!oop_cl.has_oops_in_region()) {
380           log_error(gc, verify)(&quot;region [&quot; PTR_FORMAT &quot;,&quot; PTR_FORMAT &quot;] has nmethod &quot; PTR_FORMAT &quot; in its strong code roots with no pointers into region&quot;,
381                                 p2i(_hr-&gt;bottom()), p2i(_hr-&gt;end()), p2i(nm));
382           _failures = true;
383         } else if (oop_cl.failures()) {
384           log_error(gc, verify)(&quot;region [&quot; PTR_FORMAT &quot;,&quot; PTR_FORMAT &quot;] has other failures for nmethod &quot; PTR_FORMAT,
385                                 p2i(_hr-&gt;bottom()), p2i(_hr-&gt;end()), p2i(nm));
386           _failures = true;
387         }
388       }
389     }
390   }
391 
392   bool failures()       { return _failures; }
393 };
394 
395 void HeapRegion::verify_strong_code_roots(VerifyOption vo, bool* failures) const {
396   if (!G1VerifyHeapRegionCodeRoots) {
397     // We&#39;re not verifying code roots.
398     return;
399   }
400   if (vo == VerifyOption_G1UseFullMarking) {
401     // Marking verification during a full GC is performed after class
402     // unloading, code cache unloading, etc so the strong code roots
403     // attached to each heap region are in an inconsistent state. They won&#39;t
404     // be consistent until the strong code roots are rebuilt after the
405     // actual GC. Skip verifying the strong code roots in this particular
406     // time.
407     assert(VerifyDuringGC, &quot;only way to get here&quot;);
408     return;
409   }
410 
411   HeapRegionRemSet* hrrs = rem_set();
412   size_t strong_code_roots_length = hrrs-&gt;strong_code_roots_list_length();
413 
414   // if this region is empty then there should be no entries
415   // on its strong code root list
416   if (is_empty()) {
417     if (strong_code_roots_length &gt; 0) {
418       log_error(gc, verify)(&quot;region &quot; HR_FORMAT &quot; is empty but has &quot; SIZE_FORMAT &quot; code root entries&quot;,
419                             HR_FORMAT_PARAMS(this), strong_code_roots_length);
420       *failures = true;
421     }
422     return;
423   }
424 
425   if (is_continues_humongous()) {
426     if (strong_code_roots_length &gt; 0) {
427       log_error(gc, verify)(&quot;region &quot; HR_FORMAT &quot; is a continuation of a humongous region but has &quot; SIZE_FORMAT &quot; code root entries&quot;,
428                             HR_FORMAT_PARAMS(this), strong_code_roots_length);
429       *failures = true;
430     }
431     return;
432   }
433 
434   VerifyStrongCodeRootCodeBlobClosure cb_cl(this);
435   strong_code_roots_do(&amp;cb_cl);
436 
437   if (cb_cl.failures()) {
438     *failures = true;
439   }
440 }
441 
442 void HeapRegion::print() const { print_on(tty); }
<a name="23" id="anc23"></a>
443 void HeapRegion::print_on(outputStream* st) const {
444   st-&gt;print(&quot;|%4u&quot;, this-&gt;_hrm_index);
445   st-&gt;print(&quot;|&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT,
446             p2i(bottom()), p2i(top()), p2i(end()));
447   st-&gt;print(&quot;|%3d%%&quot;, (int) ((double) used() * 100 / capacity()));
448   st-&gt;print(&quot;|%2s&quot;, get_short_type_str());
449   if (in_collection_set()) {
450     st-&gt;print(&quot;|CS&quot;);
451   } else {
452     st-&gt;print(&quot;|  &quot;);
453   }
<a name="24" id="anc24"></a><span class="line-modified">454   st-&gt;print_cr(&quot;|TAMS &quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;| %s &quot;,</span>
455                p2i(prev_top_at_mark_start()), p2i(next_top_at_mark_start()), rem_set()-&gt;get_state_str());
<a name="25" id="anc25"></a>








456 }
457 
458 class G1VerificationClosure : public BasicOopIterateClosure {
459 protected:
460   G1CollectedHeap* _g1h;
461   G1CardTable *_ct;
462   oop _containing_obj;
463   bool _failures;
464   int _n_failures;
465   VerifyOption _vo;
466 public:
467   // _vo == UsePrevMarking -&gt; use &quot;prev&quot; marking information,
468   // _vo == UseNextMarking -&gt; use &quot;next&quot; marking information,
469   // _vo == UseFullMarking -&gt; use &quot;next&quot; marking bitmap but no TAMS.
470   G1VerificationClosure(G1CollectedHeap* g1h, VerifyOption vo) :
471     _g1h(g1h), _ct(g1h-&gt;card_table()),
472     _containing_obj(NULL), _failures(false), _n_failures(0), _vo(vo) {
473   }
474 
475   void set_containing_obj(oop obj) {
476     _containing_obj = obj;
477   }
478 
479   bool failures() { return _failures; }
480   int n_failures() { return _n_failures; }
481 
482   void print_object(outputStream* out, oop obj) {
483 #ifdef PRODUCT
484     Klass* k = obj-&gt;klass();
485     const char* class_name = k-&gt;external_name();
486     out-&gt;print_cr(&quot;class name %s&quot;, class_name);
487 #else // PRODUCT
488     obj-&gt;print_on(out);
489 #endif // PRODUCT
490   }
491 
492   // This closure provides its own oop verification code.
493   debug_only(virtual bool should_verify_oops() { return false; })
494 };
495 
496 class VerifyLiveClosure : public G1VerificationClosure {
497 public:
498   VerifyLiveClosure(G1CollectedHeap* g1h, VerifyOption vo) : G1VerificationClosure(g1h, vo) {}
499   virtual void do_oop(narrowOop* p) { do_oop_work(p); }
500   virtual void do_oop(oop* p) { do_oop_work(p); }
501 
502   template &lt;class T&gt;
503   void do_oop_work(T* p) {
504     assert(_containing_obj != NULL, &quot;Precondition&quot;);
505     assert(!_g1h-&gt;is_obj_dead_cond(_containing_obj, _vo),
506       &quot;Precondition&quot;);
507     verify_liveness(p);
508   }
509 
510   template &lt;class T&gt;
511   void verify_liveness(T* p) {
512     T heap_oop = RawAccess&lt;&gt;::oop_load(p);
513     Log(gc, verify) log;
514     if (!CompressedOops::is_null(heap_oop)) {
515       oop obj = CompressedOops::decode_not_null(heap_oop);
516       bool failed = false;
<a name="26" id="anc26"></a><span class="line-modified">517       if (!_g1h-&gt;is_in_closed_subset(obj) || _g1h-&gt;is_obj_dead_cond(obj, _vo)) {</span>
<span class="line-modified">518         MutexLockerEx x(ParGCRareEvent_lock,</span>
519           Mutex::_no_safepoint_check_flag);
520 
521         if (!_failures) {
522           log.error(&quot;----------&quot;);
523         }
524         ResourceMark rm;
<a name="27" id="anc27"></a><span class="line-modified">525         if (!_g1h-&gt;is_in_closed_subset(obj)) {</span>
526           HeapRegion* from = _g1h-&gt;heap_region_containing((HeapWord*)p);
527           log.error(&quot;Field &quot; PTR_FORMAT &quot; of live obj &quot; PTR_FORMAT &quot; in region &quot; HR_FORMAT,
528                     p2i(p), p2i(_containing_obj), HR_FORMAT_PARAMS(from));
529           LogStream ls(log.error());
530           print_object(&amp;ls, _containing_obj);
531           HeapRegion* const to = _g1h-&gt;heap_region_containing(obj);
532           log.error(&quot;points to obj &quot; PTR_FORMAT &quot; in region &quot; HR_FORMAT &quot; remset %s&quot;,
533                     p2i(obj), HR_FORMAT_PARAMS(to), to-&gt;rem_set()-&gt;get_state_str());
534         } else {
535           HeapRegion* from = _g1h-&gt;heap_region_containing((HeapWord*)p);
<a name="28" id="anc28"></a><span class="line-modified">536           HeapRegion* to = _g1h-&gt;heap_region_containing((HeapWord*)obj);</span>
537           log.error(&quot;Field &quot; PTR_FORMAT &quot; of live obj &quot; PTR_FORMAT &quot; in region &quot; HR_FORMAT,
538                     p2i(p), p2i(_containing_obj), HR_FORMAT_PARAMS(from));
539           LogStream ls(log.error());
540           print_object(&amp;ls, _containing_obj);
541           log.error(&quot;points to dead obj &quot; PTR_FORMAT &quot; in region &quot; HR_FORMAT,
542                     p2i(obj), HR_FORMAT_PARAMS(to));
543           print_object(&amp;ls, obj);
544         }
545         log.error(&quot;----------&quot;);
546         _failures = true;
547         failed = true;
548         _n_failures++;
549       }
550     }
551   }
552 };
553 
554 class VerifyRemSetClosure : public G1VerificationClosure {
555 public:
556   VerifyRemSetClosure(G1CollectedHeap* g1h, VerifyOption vo) : G1VerificationClosure(g1h, vo) {}
557   virtual void do_oop(narrowOop* p) { do_oop_work(p); }
558   virtual void do_oop(oop* p) { do_oop_work(p); }
559 
560   template &lt;class T&gt;
561   void do_oop_work(T* p) {
562     assert(_containing_obj != NULL, &quot;Precondition&quot;);
563     assert(!_g1h-&gt;is_obj_dead_cond(_containing_obj, _vo),
564       &quot;Precondition&quot;);
565     verify_remembered_set(p);
566   }
567 
568   template &lt;class T&gt;
569   void verify_remembered_set(T* p) {
570     T heap_oop = RawAccess&lt;&gt;::oop_load(p);
571     Log(gc, verify) log;
572     if (!CompressedOops::is_null(heap_oop)) {
573       oop obj = CompressedOops::decode_not_null(heap_oop);
574       HeapRegion* from = _g1h-&gt;heap_region_containing((HeapWord*)p);
575       HeapRegion* to = _g1h-&gt;heap_region_containing(obj);
576       if (from != NULL &amp;&amp; to != NULL &amp;&amp;
577         from != to &amp;&amp;
578         !to-&gt;is_pinned() &amp;&amp;
579         to-&gt;rem_set()-&gt;is_complete()) {
580         jbyte cv_obj = *_ct-&gt;byte_for_const(_containing_obj);
581         jbyte cv_field = *_ct-&gt;byte_for_const(p);
582         const jbyte dirty = G1CardTable::dirty_card_val();
583 
584         bool is_bad = !(from-&gt;is_young()
585           || to-&gt;rem_set()-&gt;contains_reference(p)
586           || (_containing_obj-&gt;is_objArray() ?
587                 cv_field == dirty :
588                 cv_obj == dirty || cv_field == dirty));
589         if (is_bad) {
<a name="29" id="anc29"></a><span class="line-modified">590           MutexLockerEx x(ParGCRareEvent_lock,</span>
591             Mutex::_no_safepoint_check_flag);
592 
593           if (!_failures) {
594             log.error(&quot;----------&quot;);
595           }
596           log.error(&quot;Missing rem set entry:&quot;);
597           log.error(&quot;Field &quot; PTR_FORMAT &quot; of obj &quot; PTR_FORMAT &quot; in region &quot; HR_FORMAT,
598                     p2i(p), p2i(_containing_obj), HR_FORMAT_PARAMS(from));
599           ResourceMark rm;
600           LogStream ls(log.error());
601           _containing_obj-&gt;print_on(&amp;ls);
602           log.error(&quot;points to obj &quot; PTR_FORMAT &quot; in region &quot; HR_FORMAT &quot; remset %s&quot;,
603                     p2i(obj), HR_FORMAT_PARAMS(to), to-&gt;rem_set()-&gt;get_state_str());
604           if (oopDesc::is_oop(obj)) {
605             obj-&gt;print_on(&amp;ls);
606           }
607           log.error(&quot;Obj head CTE = %d, field CTE = %d.&quot;, cv_obj, cv_field);
608           log.error(&quot;----------&quot;);
609           _failures = true;
610           _n_failures++;
611         }
612       }
613     }
614   }
615 };
616 
617 // Closure that applies the given two closures in sequence.
618 class G1Mux2Closure : public BasicOopIterateClosure {
619   OopClosure* _c1;
620   OopClosure* _c2;
621 public:
622   G1Mux2Closure(OopClosure *c1, OopClosure *c2) { _c1 = c1; _c2 = c2; }
623   template &lt;class T&gt; inline void do_oop_work(T* p) {
624     // Apply first closure; then apply the second.
625     _c1-&gt;do_oop(p);
626     _c2-&gt;do_oop(p);
627   }
628   virtual inline void do_oop(oop* p) { do_oop_work(p); }
629   virtual inline void do_oop(narrowOop* p) { do_oop_work(p); }
630 
631   // This closure provides its own oop verification code.
632   debug_only(virtual bool should_verify_oops() { return false; })
633 };
634 
<a name="30" id="anc30"></a><span class="line-removed">635 // This really ought to be commoned up into OffsetTableContigSpace somehow.</span>
<span class="line-removed">636 // We would need a mechanism to make that code skip dead objects.</span>
<span class="line-removed">637 </span>
638 void HeapRegion::verify(VerifyOption vo,
639                         bool* failures) const {
640   G1CollectedHeap* g1h = G1CollectedHeap::heap();
641   *failures = false;
642   HeapWord* p = bottom();
643   HeapWord* prev_p = NULL;
644   VerifyLiveClosure vl_cl(g1h, vo);
645   VerifyRemSetClosure vr_cl(g1h, vo);
646   bool is_region_humongous = is_humongous();
647   size_t object_num = 0;
648   while (p &lt; top()) {
649     oop obj = oop(p);
650     size_t obj_size = block_size(p);
651     object_num += 1;
652 
653     if (!g1h-&gt;is_obj_dead_cond(obj, this, vo)) {
654       if (oopDesc::is_oop(obj)) {
655         Klass* klass = obj-&gt;klass();
656         bool is_metaspace_object = Metaspace::contains(klass);
657         if (!is_metaspace_object) {
658           log_error(gc, verify)(&quot;klass &quot; PTR_FORMAT &quot; of object &quot; PTR_FORMAT &quot; &quot;
659                                 &quot;not metadata&quot;, p2i(klass), p2i(obj));
660           *failures = true;
661           return;
662         } else if (!klass-&gt;is_klass()) {
663           log_error(gc, verify)(&quot;klass &quot; PTR_FORMAT &quot; of object &quot; PTR_FORMAT &quot; &quot;
664                                 &quot;not a klass&quot;, p2i(klass), p2i(obj));
665           *failures = true;
666           return;
667         } else {
668           vl_cl.set_containing_obj(obj);
669           if (!g1h-&gt;collector_state()-&gt;in_full_gc() || G1VerifyRSetsDuringFullGC) {
670             // verify liveness and rem_set
671             vr_cl.set_containing_obj(obj);
672             G1Mux2Closure mux(&amp;vl_cl, &amp;vr_cl);
673             obj-&gt;oop_iterate(&amp;mux);
674 
675             if (vr_cl.failures()) {
676               *failures = true;
677             }
678             if (G1MaxVerifyFailures &gt;= 0 &amp;&amp;
679               vr_cl.n_failures() &gt;= G1MaxVerifyFailures) {
680               return;
681             }
682           } else {
683             // verify only liveness
684             obj-&gt;oop_iterate(&amp;vl_cl);
685           }
686           if (vl_cl.failures()) {
687             *failures = true;
688           }
689           if (G1MaxVerifyFailures &gt;= 0 &amp;&amp;
690               vl_cl.n_failures() &gt;= G1MaxVerifyFailures) {
691             return;
692           }
693         }
694       } else {
695         log_error(gc, verify)(PTR_FORMAT &quot; not an oop&quot;, p2i(obj));
696         *failures = true;
697         return;
698       }
699     }
700     prev_p = p;
701     p += obj_size;
702   }
703 
704   if (!is_young() &amp;&amp; !is_empty()) {
705     _bot_part.verify();
706   }
707 
708   if (is_region_humongous) {
709     oop obj = oop(this-&gt;humongous_start_region()-&gt;bottom());
<a name="31" id="anc31"></a><span class="line-modified">710     if ((HeapWord*)obj &gt; bottom() || (HeapWord*)obj + obj-&gt;size() &lt; bottom()) {</span>
711       log_error(gc, verify)(&quot;this humongous region is not part of its&#39; humongous object &quot; PTR_FORMAT, p2i(obj));
712       *failures = true;
713       return;
714     }
715   }
716 
717   if (!is_region_humongous &amp;&amp; p != top()) {
718     log_error(gc, verify)(&quot;end of last object &quot; PTR_FORMAT &quot; &quot;
719                           &quot;does not match top &quot; PTR_FORMAT, p2i(p), p2i(top()));
720     *failures = true;
721     return;
722   }
723 
724   HeapWord* the_end = end();
725   // Do some extra BOT consistency checking for addresses in the
726   // range [top, end). BOT look-ups in this range should yield
727   // top. No point in doing that if top == end (there&#39;s nothing there).
728   if (p &lt; the_end) {
729     // Look up top
730     HeapWord* addr_1 = p;
<a name="32" id="anc32"></a><span class="line-modified">731     HeapWord* b_start_1 = _bot_part.block_start_const(addr_1);</span>
732     if (b_start_1 != p) {
733       log_error(gc, verify)(&quot;BOT look up for top: &quot; PTR_FORMAT &quot; &quot;
734                             &quot; yielded &quot; PTR_FORMAT &quot;, expecting &quot; PTR_FORMAT,
735                             p2i(addr_1), p2i(b_start_1), p2i(p));
736       *failures = true;
737       return;
738     }
739 
740     // Look up top + 1
741     HeapWord* addr_2 = p + 1;
742     if (addr_2 &lt; the_end) {
<a name="33" id="anc33"></a><span class="line-modified">743       HeapWord* b_start_2 = _bot_part.block_start_const(addr_2);</span>
744       if (b_start_2 != p) {
745         log_error(gc, verify)(&quot;BOT look up for top + 1: &quot; PTR_FORMAT &quot; &quot;
746                               &quot; yielded &quot; PTR_FORMAT &quot;, expecting &quot; PTR_FORMAT,
747                               p2i(addr_2), p2i(b_start_2), p2i(p));
748         *failures = true;
749         return;
750       }
751     }
752 
753     // Look up an address between top and end
754     size_t diff = pointer_delta(the_end, p) / 2;
755     HeapWord* addr_3 = p + diff;
756     if (addr_3 &lt; the_end) {
<a name="34" id="anc34"></a><span class="line-modified">757       HeapWord* b_start_3 = _bot_part.block_start_const(addr_3);</span>
758       if (b_start_3 != p) {
759         log_error(gc, verify)(&quot;BOT look up for top + diff: &quot; PTR_FORMAT &quot; &quot;
760                               &quot; yielded &quot; PTR_FORMAT &quot;, expecting &quot; PTR_FORMAT,
761                               p2i(addr_3), p2i(b_start_3), p2i(p));
762         *failures = true;
763         return;
764       }
765     }
766 
767     // Look up end - 1
768     HeapWord* addr_4 = the_end - 1;
<a name="35" id="anc35"></a><span class="line-modified">769     HeapWord* b_start_4 = _bot_part.block_start_const(addr_4);</span>
770     if (b_start_4 != p) {
771       log_error(gc, verify)(&quot;BOT look up for end - 1: &quot; PTR_FORMAT &quot; &quot;
772                             &quot; yielded &quot; PTR_FORMAT &quot;, expecting &quot; PTR_FORMAT,
773                             p2i(addr_4), p2i(b_start_4), p2i(p));
774       *failures = true;
775       return;
776     }
777   }
778 
779   verify_strong_code_roots(vo, failures);
780 }
781 
782 void HeapRegion::verify() const {
783   bool dummy = false;
784   verify(VerifyOption_G1UsePrevMarking, /* failures */ &amp;dummy);
785 }
786 
787 void HeapRegion::verify_rem_set(VerifyOption vo, bool* failures) const {
788   G1CollectedHeap* g1h = G1CollectedHeap::heap();
789   *failures = false;
790   HeapWord* p = bottom();
791   HeapWord* prev_p = NULL;
792   VerifyRemSetClosure vr_cl(g1h, vo);
793   while (p &lt; top()) {
794     oop obj = oop(p);
795     size_t obj_size = block_size(p);
796 
797     if (!g1h-&gt;is_obj_dead_cond(obj, this, vo)) {
798       if (oopDesc::is_oop(obj)) {
799         vr_cl.set_containing_obj(obj);
800         obj-&gt;oop_iterate(&amp;vr_cl);
801 
802         if (vr_cl.failures()) {
803           *failures = true;
804         }
805         if (G1MaxVerifyFailures &gt;= 0 &amp;&amp;
806           vr_cl.n_failures() &gt;= G1MaxVerifyFailures) {
807           return;
808         }
809       } else {
810         log_error(gc, verify)(PTR_FORMAT &quot; not an oop&quot;, p2i(obj));
811         *failures = true;
812         return;
813       }
814     }
815 
816     prev_p = p;
817     p += obj_size;
818   }
819 }
820 
821 void HeapRegion::verify_rem_set() const {
822   bool failures = false;
823   verify_rem_set(VerifyOption_G1UsePrevMarking, &amp;failures);
824   guarantee(!failures, &quot;HeapRegion RemSet verification failed&quot;);
825 }
826 
<a name="36" id="anc36"></a><span class="line-modified">827 void HeapRegion::prepare_for_compaction(CompactPoint* cp) {</span>
<span class="line-removed">828   // Not used for G1 anymore, but pure virtual in Space.</span>
<span class="line-removed">829   ShouldNotReachHere();</span>
<span class="line-removed">830 }</span>
<span class="line-removed">831 </span>
<span class="line-removed">832 // G1OffsetTableContigSpace code; copied from space.cpp.  Hope this can go</span>
<span class="line-removed">833 // away eventually.</span>
<span class="line-removed">834 </span>
<span class="line-removed">835 void G1ContiguousSpace::clear(bool mangle_space) {</span>
836   set_top(bottom());
<a name="37" id="anc37"></a><span class="line-modified">837   CompactibleSpace::clear(mangle_space);</span>




838   reset_bot();
839 }
<a name="38" id="anc38"></a><span class="line-removed">840 #ifndef PRODUCT</span>
<span class="line-removed">841 void G1ContiguousSpace::mangle_unused_area() {</span>
<span class="line-removed">842   mangle_unused_area_complete();</span>
<span class="line-removed">843 }</span>
844 
<a name="39" id="anc39"></a><span class="line-modified">845 void G1ContiguousSpace::mangle_unused_area_complete() {</span>

846   SpaceMangler::mangle_region(MemRegion(top(), end()));
847 }
848 #endif
849 
<a name="40" id="anc40"></a><span class="line-modified">850 void G1ContiguousSpace::print() const {</span>
<span class="line-removed">851   print_short();</span>
<span class="line-removed">852   tty-&gt;print_cr(&quot; [&quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;, &quot;</span>
<span class="line-removed">853                 INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;)&quot;,</span>
<span class="line-removed">854                 p2i(bottom()), p2i(top()), p2i(_bot_part.threshold()), p2i(end()));</span>
<span class="line-removed">855 }</span>
<span class="line-removed">856 </span>
<span class="line-removed">857 HeapWord* G1ContiguousSpace::initialize_threshold() {</span>
858   return _bot_part.initialize_threshold();
859 }
860 
<a name="41" id="anc41"></a><span class="line-modified">861 HeapWord* G1ContiguousSpace::cross_threshold(HeapWord* start,</span>
<span class="line-removed">862                                                     HeapWord* end) {</span>
863   _bot_part.alloc_block(start, end);
864   return _bot_part.threshold();
865 }
866 
<a name="42" id="anc42"></a><span class="line-modified">867 void G1ContiguousSpace::safe_object_iterate(ObjectClosure* blk) {</span>
<span class="line-removed">868   object_iterate(blk);</span>
<span class="line-removed">869 }</span>
<span class="line-removed">870 </span>
<span class="line-removed">871 void G1ContiguousSpace::object_iterate(ObjectClosure* blk) {</span>
872   HeapWord* p = bottom();
873   while (p &lt; top()) {
874     if (block_is_obj(p)) {
875       blk-&gt;do_object(oop(p));
876     }
877     p += block_size(p);
878   }
879 }
<a name="43" id="anc43"></a><span class="line-removed">880 </span>
<span class="line-removed">881 G1ContiguousSpace::G1ContiguousSpace(G1BlockOffsetTable* bot) :</span>
<span class="line-removed">882   _top(NULL),</span>
<span class="line-removed">883   _bot_part(bot, this),</span>
<span class="line-removed">884   _par_alloc_lock(Mutex::leaf, &quot;OffsetTableContigSpace par alloc lock&quot;, true),</span>
<span class="line-removed">885   _pre_dummy_top(NULL)</span>
<span class="line-removed">886 {</span>
<span class="line-removed">887 }</span>
<span class="line-removed">888 </span>
<span class="line-removed">889 void G1ContiguousSpace::initialize(MemRegion mr, bool clear_space, bool mangle_space) {</span>
<span class="line-removed">890   CompactibleSpace::initialize(mr, clear_space, mangle_space);</span>
<span class="line-removed">891   _top = bottom();</span>
<span class="line-removed">892   set_saved_mark_word(NULL);</span>
<span class="line-removed">893   reset_bot();</span>
<span class="line-removed">894 }</span>
<a name="44" id="anc44"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="44" type="hidden" />
</body>
</html>
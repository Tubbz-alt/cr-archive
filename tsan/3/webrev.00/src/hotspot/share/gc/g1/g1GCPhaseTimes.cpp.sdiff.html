<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1GCPhaseTimes.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1FullGCScope.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1GCPhaseTimes.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1GCPhaseTimes.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 27 #include &quot;gc/g1/g1GCPhaseTimes.hpp&quot;
 28 #include &quot;gc/g1/g1HotCardCache.hpp&quot;
 29 #include &quot;gc/g1/g1ParScanThreadState.inline.hpp&quot;
 30 #include &quot;gc/g1/g1StringDedup.hpp&quot;
 31 #include &quot;gc/shared/gcTimer.hpp&quot;
 32 #include &quot;gc/shared/workerDataArray.inline.hpp&quot;
 33 #include &quot;memory/resourceArea.hpp&quot;
 34 #include &quot;logging/log.hpp&quot;
 35 #include &quot;logging/logStream.hpp&quot;
 36 #include &quot;runtime/timer.hpp&quot;
 37 #include &quot;runtime/os.hpp&quot;
 38 #include &quot;utilities/macros.hpp&quot;
 39 
<span class="line-modified"> 40 static const char* Indents[5] = {&quot;&quot;, &quot;  &quot;, &quot;    &quot;, &quot;      &quot;, &quot;        &quot;};</span>




 41 
 42 G1GCPhaseTimes::G1GCPhaseTimes(STWGCTimer* gc_timer, uint max_gc_threads) :
 43   _max_gc_threads(max_gc_threads),
 44   _gc_start_counter(0),
 45   _gc_pause_time_ms(0.0),
 46   _ref_phase_times(gc_timer, max_gc_threads),
 47   _weak_phase_times(max_gc_threads)
 48 {
 49   assert(max_gc_threads &gt; 0, &quot;Must have some GC threads&quot;);
 50 
<span class="line-modified"> 51   _gc_par_phases[GCWorkerStart] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;GC Worker Start (ms):&quot;);</span>
<span class="line-modified"> 52   _gc_par_phases[ExtRootScan] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Ext Root Scanning (ms):&quot;);</span>
 53 
 54   // Root scanning phases
<span class="line-modified"> 55   _gc_par_phases[ThreadRoots] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Thread Roots (ms):&quot;);</span>
<span class="line-modified"> 56   _gc_par_phases[UniverseRoots] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Universe Roots (ms):&quot;);</span>
<span class="line-modified"> 57   _gc_par_phases[JNIRoots] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;JNI Handles Roots (ms):&quot;);</span>
<span class="line-modified"> 58   _gc_par_phases[ObjectSynchronizerRoots] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;ObjectSynchronizer Roots (ms):&quot;);</span>
<span class="line-modified"> 59   _gc_par_phases[ManagementRoots] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Management Roots (ms):&quot;);</span>
<span class="line-modified"> 60   _gc_par_phases[SystemDictionaryRoots] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;SystemDictionary Roots (ms):&quot;);</span>
<span class="line-modified"> 61   _gc_par_phases[CLDGRoots] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;CLDG Roots (ms):&quot;);</span>
<span class="line-modified"> 62   _gc_par_phases[JVMTIRoots] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;JVMTI Roots (ms):&quot;);</span>
<span class="line-modified"> 63 #if INCLUDE_AOT</span>
<span class="line-modified"> 64   _gc_par_phases[AOTCodeRoots] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;AOT Root Scan (ms):&quot;);</span>
<span class="line-modified"> 65 #endif</span>
<span class="line-modified"> 66   _gc_par_phases[CMRefRoots] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;CM RefProcessor Roots (ms):&quot;);</span>
<span class="line-modified"> 67   _gc_par_phases[WaitForStrongCLD] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Wait For Strong CLD (ms):&quot;);</span>
<span class="line-modified"> 68   _gc_par_phases[WeakCLDRoots] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Weak CLD Roots (ms):&quot;);</span>
<span class="line-modified"> 69   _gc_par_phases[SATBFiltering] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;SATB Filtering (ms):&quot;);</span>
<span class="line-modified"> 70 </span>
<span class="line-modified"> 71   _gc_par_phases[UpdateRS] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Update RS (ms):&quot;);</span>









 72   if (G1HotCardCache::default_use_cache()) {
<span class="line-modified"> 73     _gc_par_phases[ScanHCC] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Scan HCC (ms):&quot;);</span>


 74   } else {
<span class="line-modified"> 75     _gc_par_phases[ScanHCC] = NULL;</span>
 76   }
<span class="line-modified"> 77   _gc_par_phases[ScanRS] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Scan RS (ms):&quot;);</span>
<span class="line-modified"> 78   _gc_par_phases[OptScanRS] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Optional Scan RS (ms):&quot;);</span>
<span class="line-modified"> 79   _gc_par_phases[CodeRoots] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Code Root Scanning (ms):&quot;);</span>
<span class="line-modified"> 80   _gc_par_phases[ObjCopy] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Object Copy (ms):&quot;);</span>
<span class="line-modified"> 81   _gc_par_phases[OptObjCopy] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Optional Object Copy (ms):&quot;);</span>
<span class="line-modified"> 82   _gc_par_phases[Termination] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Termination (ms):&quot;);</span>
<span class="line-modified"> 83   _gc_par_phases[GCWorkerTotal] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;GC Worker Total (ms):&quot;);</span>
<span class="line-modified"> 84   _gc_par_phases[GCWorkerEnd] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;GC Worker End (ms):&quot;);</span>
<span class="line-modified"> 85   _gc_par_phases[Other] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;GC Worker Other (ms):&quot;);</span>
<span class="line-modified"> 86 </span>
<span class="line-modified"> 87   _scan_rs_scanned_cards = new WorkerDataArray&lt;size_t&gt;(max_gc_threads, &quot;Scanned Cards:&quot;);</span>
<span class="line-modified"> 88   _gc_par_phases[ScanRS]-&gt;link_thread_work_items(_scan_rs_scanned_cards, ScanRSScannedCards);</span>
<span class="line-modified"> 89   _scan_rs_claimed_cards = new WorkerDataArray&lt;size_t&gt;(max_gc_threads, &quot;Claimed Cards:&quot;);</span>
<span class="line-modified"> 90   _gc_par_phases[ScanRS]-&gt;link_thread_work_items(_scan_rs_claimed_cards, ScanRSClaimedCards);</span>
<span class="line-modified"> 91   _scan_rs_skipped_cards = new WorkerDataArray&lt;size_t&gt;(max_gc_threads, &quot;Skipped Cards:&quot;);</span>
<span class="line-modified"> 92   _gc_par_phases[ScanRS]-&gt;link_thread_work_items(_scan_rs_skipped_cards, ScanRSSkippedCards);</span>
<span class="line-modified"> 93 </span>
<span class="line-modified"> 94   _opt_cset_scanned_cards = new WorkerDataArray&lt;size_t&gt;(max_gc_threads, &quot;Scanned Cards:&quot;);</span>
<span class="line-modified"> 95   _gc_par_phases[OptScanRS]-&gt;link_thread_work_items(_opt_cset_scanned_cards, OptCSetScannedCards);</span>
<span class="line-modified"> 96   _opt_cset_claimed_cards = new WorkerDataArray&lt;size_t&gt;(max_gc_threads, &quot;Claimed Cards:&quot;);</span>
<span class="line-modified"> 97   _gc_par_phases[OptScanRS]-&gt;link_thread_work_items(_opt_cset_claimed_cards, OptCSetClaimedCards);</span>
<span class="line-modified"> 98   _opt_cset_skipped_cards = new WorkerDataArray&lt;size_t&gt;(max_gc_threads, &quot;Skipped Cards:&quot;);</span>
<span class="line-modified"> 99   _gc_par_phases[OptScanRS]-&gt;link_thread_work_items(_opt_cset_skipped_cards, OptCSetSkippedCards);</span>
<span class="line-modified">100   _opt_cset_used_memory = new WorkerDataArray&lt;size_t&gt;(max_gc_threads, &quot;Used Memory:&quot;);</span>
<span class="line-modified">101   _gc_par_phases[OptScanRS]-&gt;link_thread_work_items(_opt_cset_used_memory, OptCSetUsedMemory);</span>
<span class="line-modified">102 </span>
<span class="line-modified">103   _update_rs_processed_buffers = new WorkerDataArray&lt;size_t&gt;(max_gc_threads, &quot;Processed Buffers:&quot;);</span>
<span class="line-modified">104   _gc_par_phases[UpdateRS]-&gt;link_thread_work_items(_update_rs_processed_buffers, UpdateRSProcessedBuffers);</span>
<span class="line-modified">105   _update_rs_scanned_cards = new WorkerDataArray&lt;size_t&gt;(max_gc_threads, &quot;Scanned Cards:&quot;);</span>
<span class="line-modified">106   _gc_par_phases[UpdateRS]-&gt;link_thread_work_items(_update_rs_scanned_cards, UpdateRSScannedCards);</span>
<span class="line-modified">107   _update_rs_skipped_cards = new WorkerDataArray&lt;size_t&gt;(max_gc_threads, &quot;Skipped Cards:&quot;);</span>
<span class="line-modified">108   _gc_par_phases[UpdateRS]-&gt;link_thread_work_items(_update_rs_skipped_cards, UpdateRSSkippedCards);</span>
<span class="line-modified">109 </span>
<span class="line-modified">110   _obj_copy_lab_waste = new WorkerDataArray&lt;size_t&gt;(max_gc_threads, &quot;LAB Waste&quot;);</span>
<span class="line-removed">111   _gc_par_phases[ObjCopy]-&gt;link_thread_work_items(_obj_copy_lab_waste, ObjCopyLABWaste);</span>
<span class="line-removed">112   _obj_copy_lab_undo_waste = new WorkerDataArray&lt;size_t&gt;(max_gc_threads, &quot;LAB Undo Waste&quot;);</span>
<span class="line-removed">113   _gc_par_phases[ObjCopy]-&gt;link_thread_work_items(_obj_copy_lab_undo_waste, ObjCopyLABUndoWaste);</span>
<span class="line-removed">114 </span>
<span class="line-removed">115   _termination_attempts = new WorkerDataArray&lt;size_t&gt;(max_gc_threads, &quot;Termination Attempts:&quot;);</span>
<span class="line-removed">116   _gc_par_phases[Termination]-&gt;link_thread_work_items(_termination_attempts);</span>
117 
118   if (UseStringDeduplication) {
<span class="line-modified">119     _gc_par_phases[StringDedupQueueFixup] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Queue Fixup (ms):&quot;);</span>
<span class="line-modified">120     _gc_par_phases[StringDedupTableFixup] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Table Fixup (ms):&quot;);</span>
121   } else {
122     _gc_par_phases[StringDedupQueueFixup] = NULL;
123     _gc_par_phases[StringDedupTableFixup] = NULL;
124   }
125 
<span class="line-modified">126   _gc_par_phases[RedirtyCards] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Parallel Redirty (ms):&quot;);</span>
<span class="line-modified">127   _redirtied_cards = new WorkerDataArray&lt;size_t&gt;(max_gc_threads, &quot;Redirtied Cards:&quot;);</span>
<span class="line-removed">128   _gc_par_phases[RedirtyCards]-&gt;link_thread_work_items(_redirtied_cards);</span>
129 
<span class="line-modified">130   _gc_par_phases[YoungFreeCSet] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Young Free Collection Set (ms):&quot;);</span>
<span class="line-modified">131   _gc_par_phases[NonYoungFreeCSet] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Non-Young Free Collection Set (ms):&quot;);</span>


132 
133   reset();
134 }
135 
136 void G1GCPhaseTimes::reset() {
<span class="line-modified">137   _cur_collection_par_time_ms = 0.0;</span>
<span class="line-modified">138   _cur_optional_evac_ms = 0.0;</span>
139   _cur_collection_code_root_fixup_time_ms = 0.0;
140   _cur_strong_code_root_purge_time_ms = 0.0;




141   _cur_evac_fail_recalc_used = 0.0;
142   _cur_evac_fail_remove_self_forwards = 0.0;
143   _cur_string_deduplication_time_ms = 0.0;
144   _cur_prepare_tlab_time_ms = 0.0;
145   _cur_resize_tlab_time_ms = 0.0;
146   _cur_derived_pointer_table_update_time_ms = 0.0;
147   _cur_clear_ct_time_ms = 0.0;
148   _cur_expand_heap_time_ms = 0.0;
149   _cur_ref_proc_time_ms = 0.0;
150   _cur_collection_start_sec = 0.0;
151   _root_region_scan_wait_time_ms = 0.0;
152   _external_accounted_time_ms = 0.0;

153   _recorded_clear_claimed_marks_time_ms = 0.0;
154   _recorded_young_cset_choice_time_ms = 0.0;
155   _recorded_non_young_cset_choice_time_ms = 0.0;
156   _recorded_redirty_logged_cards_time_ms = 0.0;
157   _recorded_preserve_cm_referents_time_ms = 0.0;
<span class="line-removed">158   _recorded_merge_pss_time_ms = 0.0;</span>
159   _recorded_start_new_cset_time_ms = 0.0;
160   _recorded_total_free_cset_time_ms = 0.0;
161   _recorded_serial_free_cset_time_ms = 0.0;


162   _cur_fast_reclaim_humongous_time_ms = 0.0;
<span class="line-modified">163   _cur_fast_reclaim_humongous_register_time_ms = 0.0;</span>
164   _cur_fast_reclaim_humongous_total = 0;
165   _cur_fast_reclaim_humongous_candidates = 0;
166   _cur_fast_reclaim_humongous_reclaimed = 0;
167   _cur_verify_before_time_ms = 0.0;
168   _cur_verify_after_time_ms = 0.0;
169 
170   for (int i = 0; i &lt; GCParPhasesSentinel; i++) {
171     if (_gc_par_phases[i] != NULL) {
172       _gc_par_phases[i]-&gt;reset();
173     }
174   }
175 
176   _ref_phase_times.reset();
177   _weak_phase_times.reset();
178 }
179 
180 void G1GCPhaseTimes::note_gc_start() {
181   _gc_start_counter = os::elapsed_counter();
182   reset();
183 }
</pre>
<hr />
<pre>
192   double value = _gc_par_phases[phase]-&gt;get(worker);
193   if (value != WorkerDataArray&lt;double&gt;::uninitialized()) {
194     return value;
195   }
196   return 0.0;
197 }
198 
199 void G1GCPhaseTimes::note_gc_end() {
200   _gc_pause_time_ms = TimeHelper::counter_to_millis(os::elapsed_counter() - _gc_start_counter);
201 
202   double uninitialized = WorkerDataArray&lt;double&gt;::uninitialized();
203 
204   for (uint i = 0; i &lt; _max_gc_threads; i++) {
205     double worker_start = _gc_par_phases[GCWorkerStart]-&gt;get(i);
206     if (worker_start != uninitialized) {
207       assert(_gc_par_phases[GCWorkerEnd]-&gt;get(i) != uninitialized, &quot;Worker started but not ended.&quot;);
208       double total_worker_time = _gc_par_phases[GCWorkerEnd]-&gt;get(i) - _gc_par_phases[GCWorkerStart]-&gt;get(i);
209       record_time_secs(GCWorkerTotal, i , total_worker_time);
210 
211       double worker_known_time = worker_time(ExtRootScan, i) +
<span class="line-modified">212                                  worker_time(ScanHCC, i) +</span>
<span class="line-removed">213                                  worker_time(UpdateRS, i) +</span>
<span class="line-removed">214                                  worker_time(ScanRS, i) +</span>
215                                  worker_time(CodeRoots, i) +
216                                  worker_time(ObjCopy, i) +
217                                  worker_time(Termination, i);
218 
219       record_time_secs(Other, i, total_worker_time - worker_known_time);
220     } else {
221       // Make sure all slots are uninitialized since this thread did not seem to have been started
222       ASSERT_PHASE_UNINITIALIZED(GCWorkerEnd);
223       ASSERT_PHASE_UNINITIALIZED(ExtRootScan);
<span class="line-modified">224       ASSERT_PHASE_UNINITIALIZED(ScanHCC);</span>
<span class="line-modified">225       ASSERT_PHASE_UNINITIALIZED(UpdateRS);</span>
<span class="line-modified">226       ASSERT_PHASE_UNINITIALIZED(ScanRS);</span>



227       ASSERT_PHASE_UNINITIALIZED(CodeRoots);

228       ASSERT_PHASE_UNINITIALIZED(ObjCopy);

229       ASSERT_PHASE_UNINITIALIZED(Termination);
230     }
231   }
232 }
233 
234 #undef ASSERT_PHASE_UNINITIALIZED
235 
236 // record the time a phase took in seconds
<span class="line-modified">237 void G1GCPhaseTimes::record_time_secs(GCParPhases phase, uint worker_i, double secs) {</span>
<span class="line-modified">238   _gc_par_phases[phase]-&gt;set(worker_i, secs);</span>
239 }
240 
241 // add a number of seconds to a phase
<span class="line-modified">242 void G1GCPhaseTimes::add_time_secs(GCParPhases phase, uint worker_i, double secs) {</span>
<span class="line-modified">243   _gc_par_phases[phase]-&gt;add(worker_i, secs);</span>
244 }
245 
<span class="line-modified">246 void G1GCPhaseTimes::record_or_add_time_secs(GCParPhases phase, uint worker_i, double secs) {</span>
<span class="line-modified">247   if (_gc_par_phases[phase]-&gt;get(worker_i) == _gc_par_phases[phase]-&gt;uninitialized()) {</span>
<span class="line-modified">248     record_time_secs(phase, worker_i, secs);</span>
249   } else {
<span class="line-modified">250     add_time_secs(phase, worker_i, secs);</span>
251   }
252 }
253 
<span class="line-modified">254 void G1GCPhaseTimes::record_thread_work_item(GCParPhases phase, uint worker_i, size_t count, uint index) {</span>
<span class="line-modified">255   _gc_par_phases[phase]-&gt;set_thread_work_item(worker_i, count, index);</span>




256 }
257 
<span class="line-modified">258 void G1GCPhaseTimes::record_or_add_thread_work_item(GCParPhases phase, uint worker_i, size_t count, uint index) {</span>
<span class="line-modified">259   _gc_par_phases[phase]-&gt;set_or_add_thread_work_item(worker_i, count, index);</span>




260 }
261 
262 // return the average time for a phase in milliseconds
263 double G1GCPhaseTimes::average_time_ms(GCParPhases phase) {



264   return _gc_par_phases[phase]-&gt;average() * 1000.0;
265 }
266 
267 size_t G1GCPhaseTimes::sum_thread_work_items(GCParPhases phase, uint index) {



268   assert(_gc_par_phases[phase]-&gt;thread_work_items(index) != NULL, &quot;No sub count&quot;);
269   return _gc_par_phases[phase]-&gt;thread_work_items(index)-&gt;sum();
270 }
271 
272 template &lt;class T&gt;
<span class="line-modified">273 void G1GCPhaseTimes::details(T* phase, const char* indent) const {</span>
274   LogTarget(Trace, gc, phases, task) lt;
275   if (lt.is_enabled()) {
276     LogStream ls(lt);
<span class="line-modified">277     ls.print(&quot;%s&quot;, indent);</span>
278     phase-&gt;print_details_on(&amp;ls);
279   }
280 }
281 
<span class="line-modified">282 void G1GCPhaseTimes::log_phase(WorkerDataArray&lt;double&gt;* phase, uint indent, outputStream* out, bool print_sum) const {</span>
<span class="line-modified">283   out-&gt;print(&quot;%s&quot;, Indents[indent]);</span>
284   phase-&gt;print_summary_on(out, print_sum);
<span class="line-modified">285   details(phase, Indents[indent]);</span>
286 
287   for (uint i = 0; i &lt; phase-&gt;MaxThreadWorkItems; i++) {
288     WorkerDataArray&lt;size_t&gt;* work_items = phase-&gt;thread_work_items(i);
289     if (work_items != NULL) {
<span class="line-modified">290       out-&gt;print(&quot;%s&quot;, Indents[indent + 1]);</span>
291       work_items-&gt;print_summary_on(out, true);
<span class="line-modified">292       details(work_items, Indents[indent + 1]);</span>
293     }
294   }
295 }
296 
297 void G1GCPhaseTimes::debug_phase(WorkerDataArray&lt;double&gt;* phase, uint extra_indent) const {
298   LogTarget(Debug, gc, phases) lt;
299   if (lt.is_enabled()) {
300     ResourceMark rm;
301     LogStream ls(lt);
302     log_phase(phase, 2 + extra_indent, &amp;ls, true);
303   }
304 }
305 
<span class="line-modified">306 void G1GCPhaseTimes::trace_phase(WorkerDataArray&lt;double&gt;* phase, bool print_sum) const {</span>
307   LogTarget(Trace, gc, phases) lt;
308   if (lt.is_enabled()) {
309     LogStream ls(lt);
<span class="line-modified">310     log_phase(phase, 3, &amp;ls, print_sum);</span>
311   }
312 }
313 
314 #define TIME_FORMAT &quot;%.1lfms&quot;
315 
316 void G1GCPhaseTimes::info_time(const char* name, double value) const {
<span class="line-modified">317   log_info(gc, phases)(&quot;%s%s: &quot; TIME_FORMAT, Indents[1], name, value);</span>
318 }
319 
320 void G1GCPhaseTimes::debug_time(const char* name, double value) const {
<span class="line-modified">321   log_debug(gc, phases)(&quot;%s%s: &quot; TIME_FORMAT, Indents[2], name, value);</span>
322 }
323 
324 void G1GCPhaseTimes::debug_time_for_reference(const char* name, double value) const {
325   LogTarget(Debug, gc, phases) lt;
326   LogTarget(Debug, gc, phases, ref) lt2;
327 
328   if (lt.is_enabled()) {
329     LogStream ls(lt);
<span class="line-modified">330     ls.print_cr(&quot;%s%s: &quot; TIME_FORMAT, Indents[2], name, value);</span>
331   } else if (lt2.is_enabled()) {
332     LogStream ls(lt2);
<span class="line-modified">333     ls.print_cr(&quot;%s%s: &quot; TIME_FORMAT, Indents[2], name, value);</span>
334   }
335 }
336 
337 void G1GCPhaseTimes::trace_time(const char* name, double value) const {
<span class="line-modified">338   log_trace(gc, phases)(&quot;%s%s: &quot; TIME_FORMAT, Indents[3], name, value);</span>
339 }
340 
341 void G1GCPhaseTimes::trace_count(const char* name, size_t value) const {
<span class="line-modified">342   log_trace(gc, phases)(&quot;%s%s: &quot; SIZE_FORMAT, Indents[3], name, value);</span>
343 }
344 
345 double G1GCPhaseTimes::print_pre_evacuate_collection_set() const {
346   const double sum_ms = _root_region_scan_wait_time_ms +
347                         _recorded_young_cset_choice_time_ms +
348                         _recorded_non_young_cset_choice_time_ms +
<span class="line-modified">349                         _cur_fast_reclaim_humongous_register_time_ms +</span>

350                         _recorded_clear_claimed_marks_time_ms;
351 
352   info_time(&quot;Pre Evacuate Collection Set&quot;, sum_ms);
353 
354   if (_root_region_scan_wait_time_ms &gt; 0.0) {
355     debug_time(&quot;Root Region Scan Waiting&quot;, _root_region_scan_wait_time_ms);
356   }
357   debug_time(&quot;Prepare TLABs&quot;, _cur_prepare_tlab_time_ms);
358   debug_time(&quot;Choose Collection Set&quot;, (_recorded_young_cset_choice_time_ms + _recorded_non_young_cset_choice_time_ms));

359   if (G1EagerReclaimHumongousObjects) {
<span class="line-removed">360     debug_time(&quot;Humongous Register&quot;, _cur_fast_reclaim_humongous_register_time_ms);</span>
361     trace_count(&quot;Humongous Total&quot;, _cur_fast_reclaim_humongous_total);
362     trace_count(&quot;Humongous Candidate&quot;, _cur_fast_reclaim_humongous_candidates);
363   }
364 

365   if (_recorded_clear_claimed_marks_time_ms &gt; 0.0) {
366     debug_time(&quot;Clear Claimed Marks&quot;, _recorded_clear_claimed_marks_time_ms);
367   }
368   return sum_ms;
369 }
370 
371 double G1GCPhaseTimes::print_evacuate_optional_collection_set() const {
<span class="line-modified">372   const double sum_ms = _cur_optional_evac_ms;</span>
373   if (sum_ms &gt; 0) {
<span class="line-modified">374     info_time(&quot;Evacuate Optional Collection Set&quot;, sum_ms);</span>
<span class="line-modified">375     debug_phase(_gc_par_phases[OptScanRS]);</span>





376     debug_phase(_gc_par_phases[OptObjCopy]);


377   }
378   return sum_ms;
379 }
380 
<span class="line-modified">381 double G1GCPhaseTimes::print_evacuate_collection_set() const {</span>
<span class="line-modified">382   const double sum_ms = _cur_collection_par_time_ms;</span>








383 
<span class="line-modified">384   info_time(&quot;Evacuate Collection Set&quot;, sum_ms);</span>
385 
386   trace_phase(_gc_par_phases[GCWorkerStart], false);
387   debug_phase(_gc_par_phases[ExtRootScan]);
<span class="line-modified">388   for (int i = ExtRootScanSubPhasesStart; i &lt;= ExtRootScanSubPhasesEnd; i++) {</span>
389     trace_phase(_gc_par_phases[i]);
390   }
<span class="line-modified">391   if (G1HotCardCache::default_use_cache()) {</span>
<span class="line-removed">392     debug_phase(_gc_par_phases[ScanHCC]);</span>
<span class="line-removed">393   }</span>
<span class="line-removed">394   debug_phase(_gc_par_phases[UpdateRS]);</span>
<span class="line-removed">395   debug_phase(_gc_par_phases[ScanRS]);</span>
396   debug_phase(_gc_par_phases[CodeRoots]);
397   debug_phase(_gc_par_phases[ObjCopy]);
398   debug_phase(_gc_par_phases[Termination]);
399   debug_phase(_gc_par_phases[Other]);
400   debug_phase(_gc_par_phases[GCWorkerTotal]);
401   trace_phase(_gc_par_phases[GCWorkerEnd], false);
402 
<span class="line-modified">403   return sum_ms;</span>
404 }
405 
406 double G1GCPhaseTimes::print_post_evacuate_collection_set() const {
407   const double evac_fail_handling = _cur_evac_fail_recalc_used +
408                                     _cur_evac_fail_remove_self_forwards;


409   const double sum_ms = evac_fail_handling +
410                         _cur_collection_code_root_fixup_time_ms +
411                         _recorded_preserve_cm_referents_time_ms +
412                         _cur_ref_proc_time_ms +
413                         (_weak_phase_times.total_time_sec() * MILLIUNITS) +
414                         _cur_clear_ct_time_ms +
<span class="line-modified">415                         _recorded_merge_pss_time_ms +</span>
416                         _cur_strong_code_root_purge_time_ms +
417                         _recorded_redirty_logged_cards_time_ms +
418                         _recorded_total_free_cset_time_ms +

419                         _cur_fast_reclaim_humongous_time_ms +
420                         _cur_expand_heap_time_ms +
421                         _cur_string_deduplication_time_ms;
422 
423   info_time(&quot;Post Evacuate Collection Set&quot;, sum_ms);
424 
425   debug_time(&quot;Code Roots Fixup&quot;, _cur_collection_code_root_fixup_time_ms);
426 
427   debug_time(&quot;Clear Card Table&quot;, _cur_clear_ct_time_ms);
428 
429   debug_time_for_reference(&quot;Reference Processing&quot;, _cur_ref_proc_time_ms);
430   _ref_phase_times.print_all_references(2, false);
431   _weak_phase_times.log_print(2);
432 
433   if (G1StringDedup::is_enabled()) {
434     debug_time(&quot;String Deduplication&quot;, _cur_string_deduplication_time_ms);
435     debug_phase(_gc_par_phases[StringDedupQueueFixup], 1);
436     debug_phase(_gc_par_phases[StringDedupTableFixup], 1);
437   }
438 
439   if (G1CollectedHeap::heap()-&gt;evacuation_failed()) {
440     debug_time(&quot;Evacuation Failure&quot;, evac_fail_handling);
441     trace_time(&quot;Recalculate Used&quot;, _cur_evac_fail_recalc_used);
442     trace_time(&quot;Remove Self Forwards&quot;,_cur_evac_fail_remove_self_forwards);
443   }
444 
<span class="line-modified">445   debug_time(&quot;Merge Per-Thread State&quot;, _recorded_merge_pss_time_ms);</span>
446   debug_time(&quot;Code Roots Purge&quot;, _cur_strong_code_root_purge_time_ms);
447 
448   debug_time(&quot;Redirty Cards&quot;, _recorded_redirty_logged_cards_time_ms);
449   trace_phase(_gc_par_phases[RedirtyCards]);
450 #if COMPILER2_OR_JVMCI
451   debug_time(&quot;DerivedPointerTable Update&quot;, _cur_derived_pointer_table_update_time_ms);
452 #endif
453 
454   debug_time(&quot;Free Collection Set&quot;, _recorded_total_free_cset_time_ms);
<span class="line-modified">455   trace_time(&quot;Free Collection Set Serial&quot;, _recorded_serial_free_cset_time_ms);</span>
<span class="line-modified">456   trace_phase(_gc_par_phases[YoungFreeCSet]);</span>
<span class="line-modified">457   trace_phase(_gc_par_phases[NonYoungFreeCSet]);</span>





458 
459   if (G1EagerReclaimHumongousObjects) {
460     debug_time(&quot;Humongous Reclaim&quot;, _cur_fast_reclaim_humongous_time_ms);
461     trace_count(&quot;Humongous Reclaimed&quot;, _cur_fast_reclaim_humongous_reclaimed);
462   }
463   debug_time(&quot;Start New Collection Set&quot;, _recorded_start_new_cset_time_ms);
464   if (UseTLAB &amp;&amp; ResizeTLAB) {
465     debug_time(&quot;Resize TLABs&quot;, _cur_resize_tlab_time_ms);
466   }
467   debug_time(&quot;Expand Heap After Collection&quot;, _cur_expand_heap_time_ms);
468 
469 
470   return sum_ms;
471 }
472 
473 void G1GCPhaseTimes::print_other(double accounted_ms) const {
474   info_time(&quot;Other&quot;, _gc_pause_time_ms - accounted_ms);
475 }
476 
477 void G1GCPhaseTimes::print() {
478   note_gc_end();
479 
480   if (_cur_verify_before_time_ms &gt; 0.0) {
481     debug_time(&quot;Verify Before&quot;, _cur_verify_before_time_ms);
482   }
483 
484   double accounted_ms = 0.0;
485   accounted_ms += print_pre_evacuate_collection_set();
<span class="line-modified">486   accounted_ms += print_evacuate_collection_set();</span>
487   accounted_ms += print_evacuate_optional_collection_set();
488   accounted_ms += print_post_evacuate_collection_set();
489   print_other(accounted_ms);
490 
491   if (_cur_verify_after_time_ms &gt; 0.0) {
492     debug_time(&quot;Verify After&quot;, _cur_verify_after_time_ms);
493   }
494 }
495 
496 const char* G1GCPhaseTimes::phase_name(GCParPhases phase) {
497   static const char* names[] = {
498       &quot;GCWorkerStart&quot;,
499       &quot;ExtRootScan&quot;,
500       &quot;ThreadRoots&quot;,
501       &quot;UniverseRoots&quot;,
502       &quot;JNIRoots&quot;,
503       &quot;ObjectSynchronizerRoots&quot;,
504       &quot;ManagementRoots&quot;,
505       &quot;SystemDictionaryRoots&quot;,
506       &quot;CLDGRoots&quot;,
507       &quot;JVMTIRoots&quot;,
<span class="line-modified">508 #if INCLUDE_AOT</span>
<span class="line-removed">509       &quot;AOTCodeRoots&quot;,</span>
<span class="line-removed">510 #endif</span>
511       &quot;CMRefRoots&quot;,
<span class="line-modified">512       &quot;WaitForStrongCLD&quot;,</span>
<span class="line-modified">513       &quot;WeakCLDRoots&quot;,</span>
<span class="line-modified">514       &quot;SATBFiltering&quot;,</span>
<span class="line-modified">515       &quot;UpdateRS&quot;,</span>
<span class="line-modified">516       &quot;ScanHCC&quot;,</span>
<span class="line-modified">517       &quot;ScanRS&quot;,</span>
<span class="line-modified">518       &quot;OptScanRS&quot;,</span>
519       &quot;CodeRoots&quot;,

520       &quot;ObjCopy&quot;,
521       &quot;OptObjCopy&quot;,
522       &quot;Termination&quot;,

523       &quot;Other&quot;,
524       &quot;GCWorkerTotal&quot;,
525       &quot;GCWorkerEnd&quot;,
526       &quot;StringDedupQueueFixup&quot;,
527       &quot;StringDedupTableFixup&quot;,
528       &quot;RedirtyCards&quot;,

529       &quot;YoungFreeCSet&quot;,
<span class="line-modified">530       &quot;NonYoungFreeCSet&quot;</span>


531       //GCParPhasesSentinel only used to tell end of enum
532       };
533 
534   STATIC_ASSERT(ARRAY_SIZE(names) == G1GCPhaseTimes::GCParPhasesSentinel); // GCParPhases enum and corresponding string array should have the same &quot;length&quot;, this tries to assert it
535 
536   return names[phase];
537 }
538 
539 G1EvacPhaseWithTrimTimeTracker::G1EvacPhaseWithTrimTimeTracker(G1ParScanThreadState* pss, Tickspan&amp; total_time, Tickspan&amp; trim_time) :
540   _pss(pss),
541   _start(Ticks::now()),
542   _total_time(total_time),
543   _trim_time(trim_time),
544   _stopped(false) {
545 
546   assert(_pss-&gt;trim_ticks().value() == 0, &quot;Possibly remaining trim ticks left over from previous use&quot;);
547 }
548 
549 G1EvacPhaseWithTrimTimeTracker::~G1EvacPhaseWithTrimTimeTracker() {
550   if (!_stopped) {
551     stop();
552   }
553 }
554 
555 void G1EvacPhaseWithTrimTimeTracker::stop() {
556   assert(!_stopped, &quot;Should only be called once&quot;);
557   _total_time += (Ticks::now() - _start) - _pss-&gt;trim_ticks();
558   _trim_time += _pss-&gt;trim_ticks();
559   _pss-&gt;reset_trim_ticks();
560   _stopped = true;
561 }
562 
<span class="line-modified">563 G1GCParPhaseTimesTracker::G1GCParPhaseTimesTracker(G1GCPhaseTimes* phase_times, G1GCPhaseTimes::GCParPhases phase, uint worker_id) :</span>
<span class="line-modified">564   _start_time(), _phase(phase), _phase_times(phase_times), _worker_id(worker_id), _event() {</span>
565   if (_phase_times != NULL) {
566     _start_time = Ticks::now();
567   }
568 }
569 
570 G1GCParPhaseTimesTracker::~G1GCParPhaseTimesTracker() {
571   if (_phase_times != NULL) {
<span class="line-modified">572     _phase_times-&gt;record_time_secs(_phase, _worker_id, (Ticks::now() - _start_time).seconds());</span>




573     _event.commit(GCId::current(), _worker_id, G1GCPhaseTimes::phase_name(_phase));
574   }
575 }
576 
577 G1EvacPhaseTimesTracker::G1EvacPhaseTimesTracker(G1GCPhaseTimes* phase_times,
578                                                  G1ParScanThreadState* pss,
579                                                  G1GCPhaseTimes::GCParPhases phase,
580                                                  uint worker_id) :
581   G1GCParPhaseTimesTracker(phase_times, phase, worker_id),
582   _total_time(),
583   _trim_time(),
584   _trim_tracker(pss, _total_time, _trim_time) {
585 }
586 
587 G1EvacPhaseTimesTracker::~G1EvacPhaseTimesTracker() {
588   if (_phase_times != NULL) {
589     // Explicitly stop the trim tracker since it&#39;s not yet destructed.
590     _trim_tracker.stop();
591     // Exclude trim time by increasing the start time.
592     _start_time += _trim_time;
</pre>
</td>
<td>
<hr />
<pre>
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 27 #include &quot;gc/g1/g1GCPhaseTimes.hpp&quot;
 28 #include &quot;gc/g1/g1HotCardCache.hpp&quot;
 29 #include &quot;gc/g1/g1ParScanThreadState.inline.hpp&quot;
 30 #include &quot;gc/g1/g1StringDedup.hpp&quot;
 31 #include &quot;gc/shared/gcTimer.hpp&quot;
 32 #include &quot;gc/shared/workerDataArray.inline.hpp&quot;
 33 #include &quot;memory/resourceArea.hpp&quot;
 34 #include &quot;logging/log.hpp&quot;
 35 #include &quot;logging/logStream.hpp&quot;
 36 #include &quot;runtime/timer.hpp&quot;
 37 #include &quot;runtime/os.hpp&quot;
 38 #include &quot;utilities/macros.hpp&quot;
 39 
<span class="line-modified"> 40 static const char* indent(uint level) {</span>
<span class="line-added"> 41   static const char* Indents[] = {&quot;&quot;, &quot;  &quot;, &quot;    &quot;, &quot;      &quot;, &quot;        &quot;, &quot;          &quot;};</span>
<span class="line-added"> 42   assert(level &lt; ARRAY_SIZE(Indents), &quot;Too high indent level %u&quot;, level);</span>
<span class="line-added"> 43   return Indents[level];</span>
<span class="line-added"> 44 }</span>
 45 
 46 G1GCPhaseTimes::G1GCPhaseTimes(STWGCTimer* gc_timer, uint max_gc_threads) :
 47   _max_gc_threads(max_gc_threads),
 48   _gc_start_counter(0),
 49   _gc_pause_time_ms(0.0),
 50   _ref_phase_times(gc_timer, max_gc_threads),
 51   _weak_phase_times(max_gc_threads)
 52 {
 53   assert(max_gc_threads &gt; 0, &quot;Must have some GC threads&quot;);
 54 
<span class="line-modified"> 55   _gc_par_phases[GCWorkerStart] = new WorkerDataArray&lt;double&gt;(&quot;GC Worker Start (ms):&quot;, max_gc_threads);</span>
<span class="line-modified"> 56   _gc_par_phases[ExtRootScan] = new WorkerDataArray&lt;double&gt;(&quot;Ext Root Scanning (ms):&quot;, max_gc_threads);</span>
 57 
 58   // Root scanning phases
<span class="line-modified"> 59   _gc_par_phases[ThreadRoots] = new WorkerDataArray&lt;double&gt;(&quot;Thread Roots (ms):&quot;, max_gc_threads);</span>
<span class="line-modified"> 60   _gc_par_phases[UniverseRoots] = new WorkerDataArray&lt;double&gt;(&quot;Universe Roots (ms):&quot;, max_gc_threads);</span>
<span class="line-modified"> 61   _gc_par_phases[JNIRoots] = new WorkerDataArray&lt;double&gt;(&quot;JNI Handles Roots (ms):&quot;, max_gc_threads);</span>
<span class="line-modified"> 62   _gc_par_phases[ObjectSynchronizerRoots] = new WorkerDataArray&lt;double&gt;(&quot;ObjectSynchronizer Roots (ms):&quot;, max_gc_threads);</span>
<span class="line-modified"> 63   _gc_par_phases[ManagementRoots] = new WorkerDataArray&lt;double&gt;(&quot;Management Roots (ms):&quot;, max_gc_threads);</span>
<span class="line-modified"> 64   _gc_par_phases[SystemDictionaryRoots] = new WorkerDataArray&lt;double&gt;(&quot;SystemDictionary Roots (ms):&quot;, max_gc_threads);</span>
<span class="line-modified"> 65   _gc_par_phases[CLDGRoots] = new WorkerDataArray&lt;double&gt;(&quot;CLDG Roots (ms):&quot;, max_gc_threads);</span>
<span class="line-modified"> 66   _gc_par_phases[JVMTIRoots] = new WorkerDataArray&lt;double&gt;(&quot;JVMTI Roots (ms):&quot;, max_gc_threads);</span>
<span class="line-modified"> 67   AOT_ONLY(_gc_par_phases[AOTCodeRoots] = new WorkerDataArray&lt;double&gt;(&quot;AOT Root Scan (ms):&quot;, max_gc_threads);)</span>
<span class="line-modified"> 68   _gc_par_phases[CMRefRoots] = new WorkerDataArray&lt;double&gt;(&quot;CM RefProcessor Roots (ms):&quot;, max_gc_threads);</span>
<span class="line-modified"> 69 </span>
<span class="line-modified"> 70   _gc_par_phases[MergeER] = new WorkerDataArray&lt;double&gt;(&quot;Eager Reclaim (ms):&quot;, max_gc_threads);</span>
<span class="line-modified"> 71 </span>
<span class="line-modified"> 72   _gc_par_phases[MergeRS] = new WorkerDataArray&lt;double&gt;(&quot;Remembered Sets (ms):&quot;, max_gc_threads);</span>
<span class="line-modified"> 73   _gc_par_phases[MergeRS]-&gt;create_thread_work_items(&quot;Merged Sparse:&quot;, MergeRSMergedSparse);</span>
<span class="line-modified"> 74   _gc_par_phases[MergeRS]-&gt;create_thread_work_items(&quot;Merged Fine:&quot;, MergeRSMergedFine);</span>
<span class="line-modified"> 75   _gc_par_phases[MergeRS]-&gt;create_thread_work_items(&quot;Merged Coarse:&quot;, MergeRSMergedCoarse);</span>
<span class="line-added"> 76   _gc_par_phases[MergeRS]-&gt;create_thread_work_items(&quot;Dirty Cards:&quot;, MergeRSDirtyCards);</span>
<span class="line-added"> 77 </span>
<span class="line-added"> 78   _gc_par_phases[OptMergeRS] = new WorkerDataArray&lt;double&gt;(&quot;Optional Remembered Sets (ms):&quot;, max_gc_threads);</span>
<span class="line-added"> 79   _gc_par_phases[OptMergeRS]-&gt;create_thread_work_items(&quot;Merged Sparse:&quot;, MergeRSMergedSparse);</span>
<span class="line-added"> 80   _gc_par_phases[OptMergeRS]-&gt;create_thread_work_items(&quot;Merged Fine:&quot;, MergeRSMergedFine);</span>
<span class="line-added"> 81   _gc_par_phases[OptMergeRS]-&gt;create_thread_work_items(&quot;Merged Coarse:&quot;, MergeRSMergedCoarse);</span>
<span class="line-added"> 82   _gc_par_phases[OptMergeRS]-&gt;create_thread_work_items(&quot;Dirty Cards:&quot;, MergeRSDirtyCards);</span>
<span class="line-added"> 83 </span>
<span class="line-added"> 84   _gc_par_phases[MergeLB] = new WorkerDataArray&lt;double&gt;(&quot;Log Buffers (ms):&quot;, max_gc_threads);</span>
 85   if (G1HotCardCache::default_use_cache()) {
<span class="line-modified"> 86     _gc_par_phases[MergeHCC] = new WorkerDataArray&lt;double&gt;(&quot;Hot Card Cache (ms):&quot;, max_gc_threads);</span>
<span class="line-added"> 87     _gc_par_phases[MergeHCC]-&gt;create_thread_work_items(&quot;Dirty Cards:&quot;, MergeHCCDirtyCards);</span>
<span class="line-added"> 88     _gc_par_phases[MergeHCC]-&gt;create_thread_work_items(&quot;Skipped Cards:&quot;, MergeHCCSkippedCards);</span>
 89   } else {
<span class="line-modified"> 90     _gc_par_phases[MergeHCC] = NULL;</span>
 91   }
<span class="line-modified"> 92   _gc_par_phases[ScanHR] = new WorkerDataArray&lt;double&gt;(&quot;Scan Heap Roots (ms):&quot;, max_gc_threads);</span>
<span class="line-modified"> 93   _gc_par_phases[OptScanHR] = new WorkerDataArray&lt;double&gt;(&quot;Optional Scan Heap Roots (ms):&quot;, max_gc_threads);</span>
<span class="line-modified"> 94   _gc_par_phases[CodeRoots] = new WorkerDataArray&lt;double&gt;(&quot;Code Root Scan (ms):&quot;, max_gc_threads);</span>
<span class="line-modified"> 95   _gc_par_phases[OptCodeRoots] = new WorkerDataArray&lt;double&gt;(&quot;Optional Code Root Scan (ms):&quot;, max_gc_threads);</span>
<span class="line-modified"> 96   _gc_par_phases[ObjCopy] = new WorkerDataArray&lt;double&gt;(&quot;Object Copy (ms):&quot;, max_gc_threads);</span>
<span class="line-modified"> 97   _gc_par_phases[OptObjCopy] = new WorkerDataArray&lt;double&gt;(&quot;Optional Object Copy (ms):&quot;, max_gc_threads);</span>
<span class="line-modified"> 98   _gc_par_phases[Termination] = new WorkerDataArray&lt;double&gt;(&quot;Termination (ms):&quot;, max_gc_threads);</span>
<span class="line-modified"> 99   _gc_par_phases[OptTermination] = new WorkerDataArray&lt;double&gt;(&quot;Optional Termination (ms):&quot;, max_gc_threads);</span>
<span class="line-modified">100   _gc_par_phases[GCWorkerTotal] = new WorkerDataArray&lt;double&gt;(&quot;GC Worker Total (ms):&quot;, max_gc_threads);</span>
<span class="line-modified">101   _gc_par_phases[GCWorkerEnd] = new WorkerDataArray&lt;double&gt;(&quot;GC Worker End (ms):&quot;, max_gc_threads);</span>
<span class="line-modified">102   _gc_par_phases[Other] = new WorkerDataArray&lt;double&gt;(&quot;GC Worker Other (ms):&quot;, max_gc_threads);</span>
<span class="line-modified">103 </span>
<span class="line-modified">104   _gc_par_phases[ScanHR]-&gt;create_thread_work_items(&quot;Scanned Cards:&quot;, ScanHRScannedCards);</span>
<span class="line-modified">105   _gc_par_phases[ScanHR]-&gt;create_thread_work_items(&quot;Scanned Blocks:&quot;, ScanHRScannedBlocks);</span>
<span class="line-modified">106   _gc_par_phases[ScanHR]-&gt;create_thread_work_items(&quot;Claimed Chunks:&quot;, ScanHRClaimedChunks);</span>
<span class="line-modified">107 </span>
<span class="line-modified">108   _gc_par_phases[OptScanHR]-&gt;create_thread_work_items(&quot;Scanned Cards:&quot;, ScanHRScannedCards);</span>
<span class="line-modified">109   _gc_par_phases[OptScanHR]-&gt;create_thread_work_items(&quot;Scanned Blocks:&quot;, ScanHRScannedBlocks);</span>
<span class="line-modified">110   _gc_par_phases[OptScanHR]-&gt;create_thread_work_items(&quot;Claimed Chunks:&quot;, ScanHRClaimedChunks);</span>
<span class="line-modified">111   _gc_par_phases[OptScanHR]-&gt;create_thread_work_items(&quot;Scanned Refs:&quot;, ScanHRScannedOptRefs);</span>
<span class="line-modified">112   _gc_par_phases[OptScanHR]-&gt;create_thread_work_items(&quot;Used Memory:&quot;, ScanHRUsedMemory);</span>
<span class="line-modified">113 </span>
<span class="line-modified">114   _gc_par_phases[MergeLB]-&gt;create_thread_work_items(&quot;Dirty Cards:&quot;, MergeLBDirtyCards);</span>
<span class="line-modified">115   _gc_par_phases[MergeLB]-&gt;create_thread_work_items(&quot;Skipped Cards:&quot;, MergeLBSkippedCards);</span>
<span class="line-modified">116 </span>
<span class="line-modified">117   _gc_par_phases[MergePSS] = new WorkerDataArray&lt;double&gt;(&quot;Merge Per-Thread State&quot;, 1 /* length */, true /* is_serial */);</span>
<span class="line-modified">118 </span>
<span class="line-modified">119   _gc_par_phases[MergePSS]-&gt;create_thread_work_items(&quot;Copied Bytes&quot;, MergePSSCopiedBytes, max_gc_threads);</span>
<span class="line-modified">120   _gc_par_phases[MergePSS]-&gt;create_thread_work_items(&quot;LAB Waste&quot;, MergePSSLABWasteBytes, max_gc_threads);</span>
<span class="line-modified">121   _gc_par_phases[MergePSS]-&gt;create_thread_work_items(&quot;LAB Undo Waste&quot;, MergePSSLABUndoWasteBytes, max_gc_threads);</span>
<span class="line-modified">122 </span>
<span class="line-modified">123   _gc_par_phases[Termination]-&gt;create_thread_work_items(&quot;Termination Attempts:&quot;);</span>
<span class="line-modified">124 </span>
<span class="line-modified">125   _gc_par_phases[OptTermination]-&gt;create_thread_work_items(&quot;Optional Termination Attempts:&quot;);</span>






126 
127   if (UseStringDeduplication) {
<span class="line-modified">128     _gc_par_phases[StringDedupQueueFixup] = new WorkerDataArray&lt;double&gt;(&quot;Queue Fixup (ms):&quot;, max_gc_threads);</span>
<span class="line-modified">129     _gc_par_phases[StringDedupTableFixup] = new WorkerDataArray&lt;double&gt;(&quot;Table Fixup (ms):&quot;, max_gc_threads);</span>
130   } else {
131     _gc_par_phases[StringDedupQueueFixup] = NULL;
132     _gc_par_phases[StringDedupTableFixup] = NULL;
133   }
134 
<span class="line-modified">135   _gc_par_phases[RedirtyCards] = new WorkerDataArray&lt;double&gt;(&quot;Parallel Redirty (ms):&quot;, max_gc_threads);</span>
<span class="line-modified">136   _gc_par_phases[RedirtyCards]-&gt;create_thread_work_items(&quot;Redirtied Cards:&quot;);</span>

137 
<span class="line-modified">138   _gc_par_phases[ParFreeCSet] = new WorkerDataArray&lt;double&gt;(&quot;Parallel Free Collection Set (ms):&quot;, max_gc_threads);</span>
<span class="line-modified">139   _gc_par_phases[YoungFreeCSet] = new WorkerDataArray&lt;double&gt;(&quot;Young Free Collection Set (ms):&quot;, max_gc_threads);</span>
<span class="line-added">140   _gc_par_phases[NonYoungFreeCSet] = new WorkerDataArray&lt;double&gt;(&quot;Non-Young Free Collection Set (ms):&quot;, max_gc_threads);</span>
<span class="line-added">141   _gc_par_phases[RebuildFreeList] = new WorkerDataArray&lt;double&gt;(&quot;Parallel Rebuild Free List (ms):&quot;, max_gc_threads);</span>
142 
143   reset();
144 }
145 
146 void G1GCPhaseTimes::reset() {
<span class="line-modified">147   _cur_collection_initial_evac_time_ms = 0.0;</span>
<span class="line-modified">148   _cur_optional_evac_time_ms = 0.0;</span>
149   _cur_collection_code_root_fixup_time_ms = 0.0;
150   _cur_strong_code_root_purge_time_ms = 0.0;
<span class="line-added">151   _cur_merge_heap_roots_time_ms = 0.0;</span>
<span class="line-added">152   _cur_optional_merge_heap_roots_time_ms = 0.0;</span>
<span class="line-added">153   _cur_prepare_merge_heap_roots_time_ms = 0.0;</span>
<span class="line-added">154   _cur_optional_prepare_merge_heap_roots_time_ms = 0.0;</span>
155   _cur_evac_fail_recalc_used = 0.0;
156   _cur_evac_fail_remove_self_forwards = 0.0;
157   _cur_string_deduplication_time_ms = 0.0;
158   _cur_prepare_tlab_time_ms = 0.0;
159   _cur_resize_tlab_time_ms = 0.0;
160   _cur_derived_pointer_table_update_time_ms = 0.0;
161   _cur_clear_ct_time_ms = 0.0;
162   _cur_expand_heap_time_ms = 0.0;
163   _cur_ref_proc_time_ms = 0.0;
164   _cur_collection_start_sec = 0.0;
165   _root_region_scan_wait_time_ms = 0.0;
166   _external_accounted_time_ms = 0.0;
<span class="line-added">167   _recorded_prepare_heap_roots_time_ms = 0.0;</span>
168   _recorded_clear_claimed_marks_time_ms = 0.0;
169   _recorded_young_cset_choice_time_ms = 0.0;
170   _recorded_non_young_cset_choice_time_ms = 0.0;
171   _recorded_redirty_logged_cards_time_ms = 0.0;
172   _recorded_preserve_cm_referents_time_ms = 0.0;

173   _recorded_start_new_cset_time_ms = 0.0;
174   _recorded_total_free_cset_time_ms = 0.0;
175   _recorded_serial_free_cset_time_ms = 0.0;
<span class="line-added">176   _recorded_total_rebuild_freelist_time_ms = 0.0;</span>
<span class="line-added">177   _recorded_serial_rebuild_freelist_time_ms = 0.0;</span>
178   _cur_fast_reclaim_humongous_time_ms = 0.0;
<span class="line-modified">179   _cur_region_register_time = 0.0;</span>
180   _cur_fast_reclaim_humongous_total = 0;
181   _cur_fast_reclaim_humongous_candidates = 0;
182   _cur_fast_reclaim_humongous_reclaimed = 0;
183   _cur_verify_before_time_ms = 0.0;
184   _cur_verify_after_time_ms = 0.0;
185 
186   for (int i = 0; i &lt; GCParPhasesSentinel; i++) {
187     if (_gc_par_phases[i] != NULL) {
188       _gc_par_phases[i]-&gt;reset();
189     }
190   }
191 
192   _ref_phase_times.reset();
193   _weak_phase_times.reset();
194 }
195 
196 void G1GCPhaseTimes::note_gc_start() {
197   _gc_start_counter = os::elapsed_counter();
198   reset();
199 }
</pre>
<hr />
<pre>
208   double value = _gc_par_phases[phase]-&gt;get(worker);
209   if (value != WorkerDataArray&lt;double&gt;::uninitialized()) {
210     return value;
211   }
212   return 0.0;
213 }
214 
215 void G1GCPhaseTimes::note_gc_end() {
216   _gc_pause_time_ms = TimeHelper::counter_to_millis(os::elapsed_counter() - _gc_start_counter);
217 
218   double uninitialized = WorkerDataArray&lt;double&gt;::uninitialized();
219 
220   for (uint i = 0; i &lt; _max_gc_threads; i++) {
221     double worker_start = _gc_par_phases[GCWorkerStart]-&gt;get(i);
222     if (worker_start != uninitialized) {
223       assert(_gc_par_phases[GCWorkerEnd]-&gt;get(i) != uninitialized, &quot;Worker started but not ended.&quot;);
224       double total_worker_time = _gc_par_phases[GCWorkerEnd]-&gt;get(i) - _gc_par_phases[GCWorkerStart]-&gt;get(i);
225       record_time_secs(GCWorkerTotal, i , total_worker_time);
226 
227       double worker_known_time = worker_time(ExtRootScan, i) +
<span class="line-modified">228                                  worker_time(ScanHR, i) +</span>


229                                  worker_time(CodeRoots, i) +
230                                  worker_time(ObjCopy, i) +
231                                  worker_time(Termination, i);
232 
233       record_time_secs(Other, i, total_worker_time - worker_known_time);
234     } else {
235       // Make sure all slots are uninitialized since this thread did not seem to have been started
236       ASSERT_PHASE_UNINITIALIZED(GCWorkerEnd);
237       ASSERT_PHASE_UNINITIALIZED(ExtRootScan);
<span class="line-modified">238       ASSERT_PHASE_UNINITIALIZED(MergeER);</span>
<span class="line-modified">239       ASSERT_PHASE_UNINITIALIZED(MergeRS);</span>
<span class="line-modified">240       ASSERT_PHASE_UNINITIALIZED(OptMergeRS);</span>
<span class="line-added">241       ASSERT_PHASE_UNINITIALIZED(MergeHCC);</span>
<span class="line-added">242       ASSERT_PHASE_UNINITIALIZED(MergeLB);</span>
<span class="line-added">243       ASSERT_PHASE_UNINITIALIZED(ScanHR);</span>
244       ASSERT_PHASE_UNINITIALIZED(CodeRoots);
<span class="line-added">245       ASSERT_PHASE_UNINITIALIZED(OptCodeRoots);</span>
246       ASSERT_PHASE_UNINITIALIZED(ObjCopy);
<span class="line-added">247       ASSERT_PHASE_UNINITIALIZED(OptObjCopy);</span>
248       ASSERT_PHASE_UNINITIALIZED(Termination);
249     }
250   }
251 }
252 
253 #undef ASSERT_PHASE_UNINITIALIZED
254 
255 // record the time a phase took in seconds
<span class="line-modified">256 void G1GCPhaseTimes::record_time_secs(GCParPhases phase, uint worker_id, double secs) {</span>
<span class="line-modified">257   _gc_par_phases[phase]-&gt;set(worker_id, secs);</span>
258 }
259 
260 // add a number of seconds to a phase
<span class="line-modified">261 void G1GCPhaseTimes::add_time_secs(GCParPhases phase, uint worker_id, double secs) {</span>
<span class="line-modified">262   _gc_par_phases[phase]-&gt;add(worker_id, secs);</span>
263 }
264 
<span class="line-modified">265 void G1GCPhaseTimes::record_or_add_time_secs(GCParPhases phase, uint worker_id, double secs) {</span>
<span class="line-modified">266   if (_gc_par_phases[phase]-&gt;get(worker_id) == _gc_par_phases[phase]-&gt;uninitialized()) {</span>
<span class="line-modified">267     record_time_secs(phase, worker_id, secs);</span>
268   } else {
<span class="line-modified">269     add_time_secs(phase, worker_id, secs);</span>
270   }
271 }
272 
<span class="line-modified">273 double G1GCPhaseTimes::get_time_secs(GCParPhases phase, uint worker_id) {</span>
<span class="line-modified">274   return _gc_par_phases[phase]-&gt;get(worker_id);</span>
<span class="line-added">275 }</span>
<span class="line-added">276 </span>
<span class="line-added">277 void G1GCPhaseTimes::record_thread_work_item(GCParPhases phase, uint worker_id, size_t count, uint index) {</span>
<span class="line-added">278   _gc_par_phases[phase]-&gt;set_thread_work_item(worker_id, count, index);</span>
279 }
280 
<span class="line-modified">281 void G1GCPhaseTimes::record_or_add_thread_work_item(GCParPhases phase, uint worker_id, size_t count, uint index) {</span>
<span class="line-modified">282   _gc_par_phases[phase]-&gt;set_or_add_thread_work_item(worker_id, count, index);</span>
<span class="line-added">283 }</span>
<span class="line-added">284 </span>
<span class="line-added">285 size_t G1GCPhaseTimes::get_thread_work_item(GCParPhases phase, uint worker_id, uint index) {</span>
<span class="line-added">286   return _gc_par_phases[phase]-&gt;get_thread_work_item(worker_id, index);</span>
287 }
288 
289 // return the average time for a phase in milliseconds
290 double G1GCPhaseTimes::average_time_ms(GCParPhases phase) {
<span class="line-added">291   if (_gc_par_phases[phase] == NULL) {</span>
<span class="line-added">292     return 0.0;</span>
<span class="line-added">293   }</span>
294   return _gc_par_phases[phase]-&gt;average() * 1000.0;
295 }
296 
297 size_t G1GCPhaseTimes::sum_thread_work_items(GCParPhases phase, uint index) {
<span class="line-added">298   if (_gc_par_phases[phase] == NULL) {</span>
<span class="line-added">299     return 0;</span>
<span class="line-added">300   }</span>
301   assert(_gc_par_phases[phase]-&gt;thread_work_items(index) != NULL, &quot;No sub count&quot;);
302   return _gc_par_phases[phase]-&gt;thread_work_items(index)-&gt;sum();
303 }
304 
305 template &lt;class T&gt;
<span class="line-modified">306 void G1GCPhaseTimes::details(T* phase, const char* indent_str) const {</span>
307   LogTarget(Trace, gc, phases, task) lt;
308   if (lt.is_enabled()) {
309     LogStream ls(lt);
<span class="line-modified">310     ls.print(&quot;%s&quot;, indent_str);</span>
311     phase-&gt;print_details_on(&amp;ls);
312   }
313 }
314 
<span class="line-modified">315 void G1GCPhaseTimes::log_phase(WorkerDataArray&lt;double&gt;* phase, uint indent_level, outputStream* out, bool print_sum) const {</span>
<span class="line-modified">316   out-&gt;print(&quot;%s&quot;, indent(indent_level));</span>
317   phase-&gt;print_summary_on(out, print_sum);
<span class="line-modified">318   details(phase, indent(indent_level));</span>
319 
320   for (uint i = 0; i &lt; phase-&gt;MaxThreadWorkItems; i++) {
321     WorkerDataArray&lt;size_t&gt;* work_items = phase-&gt;thread_work_items(i);
322     if (work_items != NULL) {
<span class="line-modified">323       out-&gt;print(&quot;%s&quot;, indent(indent_level + 1));</span>
324       work_items-&gt;print_summary_on(out, true);
<span class="line-modified">325       details(work_items, indent(indent_level + 1));</span>
326     }
327   }
328 }
329 
330 void G1GCPhaseTimes::debug_phase(WorkerDataArray&lt;double&gt;* phase, uint extra_indent) const {
331   LogTarget(Debug, gc, phases) lt;
332   if (lt.is_enabled()) {
333     ResourceMark rm;
334     LogStream ls(lt);
335     log_phase(phase, 2 + extra_indent, &amp;ls, true);
336   }
337 }
338 
<span class="line-modified">339 void G1GCPhaseTimes::trace_phase(WorkerDataArray&lt;double&gt;* phase, bool print_sum, uint extra_indent) const {</span>
340   LogTarget(Trace, gc, phases) lt;
341   if (lt.is_enabled()) {
342     LogStream ls(lt);
<span class="line-modified">343     log_phase(phase, 3 + extra_indent, &amp;ls, print_sum);</span>
344   }
345 }
346 
347 #define TIME_FORMAT &quot;%.1lfms&quot;
348 
349 void G1GCPhaseTimes::info_time(const char* name, double value) const {
<span class="line-modified">350   log_info(gc, phases)(&quot;%s%s: &quot; TIME_FORMAT, indent(1), name, value);</span>
351 }
352 
353 void G1GCPhaseTimes::debug_time(const char* name, double value) const {
<span class="line-modified">354   log_debug(gc, phases)(&quot;%s%s: &quot; TIME_FORMAT, indent(2), name, value);</span>
355 }
356 
357 void G1GCPhaseTimes::debug_time_for_reference(const char* name, double value) const {
358   LogTarget(Debug, gc, phases) lt;
359   LogTarget(Debug, gc, phases, ref) lt2;
360 
361   if (lt.is_enabled()) {
362     LogStream ls(lt);
<span class="line-modified">363     ls.print_cr(&quot;%s%s: &quot; TIME_FORMAT, indent(2), name, value);</span>
364   } else if (lt2.is_enabled()) {
365     LogStream ls(lt2);
<span class="line-modified">366     ls.print_cr(&quot;%s%s: &quot; TIME_FORMAT, indent(2), name, value);</span>
367   }
368 }
369 
370 void G1GCPhaseTimes::trace_time(const char* name, double value) const {
<span class="line-modified">371   log_trace(gc, phases)(&quot;%s%s: &quot; TIME_FORMAT, indent(3), name, value);</span>
372 }
373 
374 void G1GCPhaseTimes::trace_count(const char* name, size_t value) const {
<span class="line-modified">375   log_trace(gc, phases)(&quot;%s%s: &quot; SIZE_FORMAT, indent(3), name, value);</span>
376 }
377 
378 double G1GCPhaseTimes::print_pre_evacuate_collection_set() const {
379   const double sum_ms = _root_region_scan_wait_time_ms +
380                         _recorded_young_cset_choice_time_ms +
381                         _recorded_non_young_cset_choice_time_ms +
<span class="line-modified">382                         _cur_region_register_time +</span>
<span class="line-added">383                         _recorded_prepare_heap_roots_time_ms +</span>
384                         _recorded_clear_claimed_marks_time_ms;
385 
386   info_time(&quot;Pre Evacuate Collection Set&quot;, sum_ms);
387 
388   if (_root_region_scan_wait_time_ms &gt; 0.0) {
389     debug_time(&quot;Root Region Scan Waiting&quot;, _root_region_scan_wait_time_ms);
390   }
391   debug_time(&quot;Prepare TLABs&quot;, _cur_prepare_tlab_time_ms);
392   debug_time(&quot;Choose Collection Set&quot;, (_recorded_young_cset_choice_time_ms + _recorded_non_young_cset_choice_time_ms));
<span class="line-added">393   debug_time(&quot;Region Register&quot;, _cur_region_register_time);</span>
394   if (G1EagerReclaimHumongousObjects) {

395     trace_count(&quot;Humongous Total&quot;, _cur_fast_reclaim_humongous_total);
396     trace_count(&quot;Humongous Candidate&quot;, _cur_fast_reclaim_humongous_candidates);
397   }
398 
<span class="line-added">399   debug_time(&quot;Prepare Heap Roots&quot;, _recorded_prepare_heap_roots_time_ms);</span>
400   if (_recorded_clear_claimed_marks_time_ms &gt; 0.0) {
401     debug_time(&quot;Clear Claimed Marks&quot;, _recorded_clear_claimed_marks_time_ms);
402   }
403   return sum_ms;
404 }
405 
406 double G1GCPhaseTimes::print_evacuate_optional_collection_set() const {
<span class="line-modified">407   const double sum_ms = _cur_optional_evac_time_ms + _cur_optional_merge_heap_roots_time_ms;</span>
408   if (sum_ms &gt; 0) {
<span class="line-modified">409     info_time(&quot;Merge Optional Heap Roots&quot;, _cur_optional_merge_heap_roots_time_ms);</span>
<span class="line-modified">410 </span>
<span class="line-added">411     debug_time(&quot;Prepare Optional Merge Heap Roots&quot;, _cur_optional_prepare_merge_heap_roots_time_ms);</span>
<span class="line-added">412     debug_phase(_gc_par_phases[OptMergeRS]);</span>
<span class="line-added">413 </span>
<span class="line-added">414     info_time(&quot;Evacuate Optional Collection Set&quot;, _cur_optional_evac_time_ms);</span>
<span class="line-added">415     debug_phase(_gc_par_phases[OptScanHR]);</span>
416     debug_phase(_gc_par_phases[OptObjCopy]);
<span class="line-added">417     debug_phase(_gc_par_phases[OptCodeRoots]);</span>
<span class="line-added">418     debug_phase(_gc_par_phases[OptTermination]);</span>
419   }
420   return sum_ms;
421 }
422 
<span class="line-modified">423 double G1GCPhaseTimes::print_evacuate_initial_collection_set() const {</span>
<span class="line-modified">424   info_time(&quot;Merge Heap Roots&quot;, _cur_merge_heap_roots_time_ms);</span>
<span class="line-added">425 </span>
<span class="line-added">426   debug_time(&quot;Prepare Merge Heap Roots&quot;, _cur_prepare_merge_heap_roots_time_ms);</span>
<span class="line-added">427   debug_phase(_gc_par_phases[MergeER]);</span>
<span class="line-added">428   debug_phase(_gc_par_phases[MergeRS]);</span>
<span class="line-added">429   if (G1HotCardCache::default_use_cache()) {</span>
<span class="line-added">430     debug_phase(_gc_par_phases[MergeHCC]);</span>
<span class="line-added">431   }</span>
<span class="line-added">432   debug_phase(_gc_par_phases[MergeLB]);</span>
433 
<span class="line-modified">434   info_time(&quot;Evacuate Collection Set&quot;, _cur_collection_initial_evac_time_ms);</span>
435 
436   trace_phase(_gc_par_phases[GCWorkerStart], false);
437   debug_phase(_gc_par_phases[ExtRootScan]);
<span class="line-modified">438   for (int i = ExtRootScanSubPhasesFirst; i &lt;= ExtRootScanSubPhasesLast; i++) {</span>
439     trace_phase(_gc_par_phases[i]);
440   }
<span class="line-modified">441   debug_phase(_gc_par_phases[ScanHR]);</span>




442   debug_phase(_gc_par_phases[CodeRoots]);
443   debug_phase(_gc_par_phases[ObjCopy]);
444   debug_phase(_gc_par_phases[Termination]);
445   debug_phase(_gc_par_phases[Other]);
446   debug_phase(_gc_par_phases[GCWorkerTotal]);
447   trace_phase(_gc_par_phases[GCWorkerEnd], false);
448 
<span class="line-modified">449   return _cur_collection_initial_evac_time_ms + _cur_merge_heap_roots_time_ms;</span>
450 }
451 
452 double G1GCPhaseTimes::print_post_evacuate_collection_set() const {
453   const double evac_fail_handling = _cur_evac_fail_recalc_used +
454                                     _cur_evac_fail_remove_self_forwards;
<span class="line-added">455   assert(_gc_par_phases[MergePSS]-&gt;get(0) != WorkerDataArray&lt;double&gt;::uninitialized(), &quot;must be set&quot;);</span>
<span class="line-added">456   const double merge_pss = _gc_par_phases[MergePSS]-&gt;get(0) * MILLIUNITS;</span>
457   const double sum_ms = evac_fail_handling +
458                         _cur_collection_code_root_fixup_time_ms +
459                         _recorded_preserve_cm_referents_time_ms +
460                         _cur_ref_proc_time_ms +
461                         (_weak_phase_times.total_time_sec() * MILLIUNITS) +
462                         _cur_clear_ct_time_ms +
<span class="line-modified">463                         merge_pss +</span>
464                         _cur_strong_code_root_purge_time_ms +
465                         _recorded_redirty_logged_cards_time_ms +
466                         _recorded_total_free_cset_time_ms +
<span class="line-added">467                         _recorded_total_rebuild_freelist_time_ms +</span>
468                         _cur_fast_reclaim_humongous_time_ms +
469                         _cur_expand_heap_time_ms +
470                         _cur_string_deduplication_time_ms;
471 
472   info_time(&quot;Post Evacuate Collection Set&quot;, sum_ms);
473 
474   debug_time(&quot;Code Roots Fixup&quot;, _cur_collection_code_root_fixup_time_ms);
475 
476   debug_time(&quot;Clear Card Table&quot;, _cur_clear_ct_time_ms);
477 
478   debug_time_for_reference(&quot;Reference Processing&quot;, _cur_ref_proc_time_ms);
479   _ref_phase_times.print_all_references(2, false);
480   _weak_phase_times.log_print(2);
481 
482   if (G1StringDedup::is_enabled()) {
483     debug_time(&quot;String Deduplication&quot;, _cur_string_deduplication_time_ms);
484     debug_phase(_gc_par_phases[StringDedupQueueFixup], 1);
485     debug_phase(_gc_par_phases[StringDedupTableFixup], 1);
486   }
487 
488   if (G1CollectedHeap::heap()-&gt;evacuation_failed()) {
489     debug_time(&quot;Evacuation Failure&quot;, evac_fail_handling);
490     trace_time(&quot;Recalculate Used&quot;, _cur_evac_fail_recalc_used);
491     trace_time(&quot;Remove Self Forwards&quot;,_cur_evac_fail_remove_self_forwards);
492   }
493 
<span class="line-modified">494   debug_phase(_gc_par_phases[MergePSS], 0);</span>
495   debug_time(&quot;Code Roots Purge&quot;, _cur_strong_code_root_purge_time_ms);
496 
497   debug_time(&quot;Redirty Cards&quot;, _recorded_redirty_logged_cards_time_ms);
498   trace_phase(_gc_par_phases[RedirtyCards]);
499 #if COMPILER2_OR_JVMCI
500   debug_time(&quot;DerivedPointerTable Update&quot;, _cur_derived_pointer_table_update_time_ms);
501 #endif
502 
503   debug_time(&quot;Free Collection Set&quot;, _recorded_total_free_cset_time_ms);
<span class="line-modified">504   trace_time(&quot;Serial Free Collection Set&quot;, _recorded_serial_free_cset_time_ms);</span>
<span class="line-modified">505   trace_phase(_gc_par_phases[ParFreeCSet]);</span>
<span class="line-modified">506   trace_phase(_gc_par_phases[YoungFreeCSet], true, 1);</span>
<span class="line-added">507   trace_phase(_gc_par_phases[NonYoungFreeCSet], true, 1);</span>
<span class="line-added">508 </span>
<span class="line-added">509   debug_time(&quot;Rebuild Free List&quot;, _recorded_total_rebuild_freelist_time_ms);</span>
<span class="line-added">510   trace_time(&quot;Serial Rebuild Free List &quot;, _recorded_serial_rebuild_freelist_time_ms);</span>
<span class="line-added">511   trace_phase(_gc_par_phases[RebuildFreeList]);</span>
512 
513   if (G1EagerReclaimHumongousObjects) {
514     debug_time(&quot;Humongous Reclaim&quot;, _cur_fast_reclaim_humongous_time_ms);
515     trace_count(&quot;Humongous Reclaimed&quot;, _cur_fast_reclaim_humongous_reclaimed);
516   }
517   debug_time(&quot;Start New Collection Set&quot;, _recorded_start_new_cset_time_ms);
518   if (UseTLAB &amp;&amp; ResizeTLAB) {
519     debug_time(&quot;Resize TLABs&quot;, _cur_resize_tlab_time_ms);
520   }
521   debug_time(&quot;Expand Heap After Collection&quot;, _cur_expand_heap_time_ms);
522 
523 
524   return sum_ms;
525 }
526 
527 void G1GCPhaseTimes::print_other(double accounted_ms) const {
528   info_time(&quot;Other&quot;, _gc_pause_time_ms - accounted_ms);
529 }
530 
531 void G1GCPhaseTimes::print() {
532   note_gc_end();
533 
534   if (_cur_verify_before_time_ms &gt; 0.0) {
535     debug_time(&quot;Verify Before&quot;, _cur_verify_before_time_ms);
536   }
537 
538   double accounted_ms = 0.0;
539   accounted_ms += print_pre_evacuate_collection_set();
<span class="line-modified">540   accounted_ms += print_evacuate_initial_collection_set();</span>
541   accounted_ms += print_evacuate_optional_collection_set();
542   accounted_ms += print_post_evacuate_collection_set();
543   print_other(accounted_ms);
544 
545   if (_cur_verify_after_time_ms &gt; 0.0) {
546     debug_time(&quot;Verify After&quot;, _cur_verify_after_time_ms);
547   }
548 }
549 
550 const char* G1GCPhaseTimes::phase_name(GCParPhases phase) {
551   static const char* names[] = {
552       &quot;GCWorkerStart&quot;,
553       &quot;ExtRootScan&quot;,
554       &quot;ThreadRoots&quot;,
555       &quot;UniverseRoots&quot;,
556       &quot;JNIRoots&quot;,
557       &quot;ObjectSynchronizerRoots&quot;,
558       &quot;ManagementRoots&quot;,
559       &quot;SystemDictionaryRoots&quot;,
560       &quot;CLDGRoots&quot;,
561       &quot;JVMTIRoots&quot;,
<span class="line-modified">562       AOT_ONLY(&quot;AOTCodeRoots&quot; COMMA)</span>


563       &quot;CMRefRoots&quot;,
<span class="line-modified">564       &quot;MergeER&quot;,</span>
<span class="line-modified">565       &quot;MergeRS&quot;,</span>
<span class="line-modified">566       &quot;OptMergeRS&quot;,</span>
<span class="line-modified">567       &quot;MergeLB&quot;,</span>
<span class="line-modified">568       &quot;MergeHCC&quot;,</span>
<span class="line-modified">569       &quot;ScanHR&quot;,</span>
<span class="line-modified">570       &quot;OptScanHR&quot;,</span>
571       &quot;CodeRoots&quot;,
<span class="line-added">572       &quot;OptCodeRoots&quot;,</span>
573       &quot;ObjCopy&quot;,
574       &quot;OptObjCopy&quot;,
575       &quot;Termination&quot;,
<span class="line-added">576       &quot;OptTermination&quot;,</span>
577       &quot;Other&quot;,
578       &quot;GCWorkerTotal&quot;,
579       &quot;GCWorkerEnd&quot;,
580       &quot;StringDedupQueueFixup&quot;,
581       &quot;StringDedupTableFixup&quot;,
582       &quot;RedirtyCards&quot;,
<span class="line-added">583       &quot;ParFreeCSet&quot;,</span>
584       &quot;YoungFreeCSet&quot;,
<span class="line-modified">585       &quot;NonYoungFreeCSet&quot;,</span>
<span class="line-added">586       &quot;RebuildFreeList&quot;,</span>
<span class="line-added">587       &quot;MergePSS&quot;</span>
588       //GCParPhasesSentinel only used to tell end of enum
589       };
590 
591   STATIC_ASSERT(ARRAY_SIZE(names) == G1GCPhaseTimes::GCParPhasesSentinel); // GCParPhases enum and corresponding string array should have the same &quot;length&quot;, this tries to assert it
592 
593   return names[phase];
594 }
595 
596 G1EvacPhaseWithTrimTimeTracker::G1EvacPhaseWithTrimTimeTracker(G1ParScanThreadState* pss, Tickspan&amp; total_time, Tickspan&amp; trim_time) :
597   _pss(pss),
598   _start(Ticks::now()),
599   _total_time(total_time),
600   _trim_time(trim_time),
601   _stopped(false) {
602 
603   assert(_pss-&gt;trim_ticks().value() == 0, &quot;Possibly remaining trim ticks left over from previous use&quot;);
604 }
605 
606 G1EvacPhaseWithTrimTimeTracker::~G1EvacPhaseWithTrimTimeTracker() {
607   if (!_stopped) {
608     stop();
609   }
610 }
611 
612 void G1EvacPhaseWithTrimTimeTracker::stop() {
613   assert(!_stopped, &quot;Should only be called once&quot;);
614   _total_time += (Ticks::now() - _start) - _pss-&gt;trim_ticks();
615   _trim_time += _pss-&gt;trim_ticks();
616   _pss-&gt;reset_trim_ticks();
617   _stopped = true;
618 }
619 
<span class="line-modified">620 G1GCParPhaseTimesTracker::G1GCParPhaseTimesTracker(G1GCPhaseTimes* phase_times, G1GCPhaseTimes::GCParPhases phase, uint worker_id, bool must_record) :</span>
<span class="line-modified">621   _start_time(), _phase(phase), _phase_times(phase_times), _worker_id(worker_id), _event(), _must_record(must_record) {</span>
622   if (_phase_times != NULL) {
623     _start_time = Ticks::now();
624   }
625 }
626 
627 G1GCParPhaseTimesTracker::~G1GCParPhaseTimesTracker() {
628   if (_phase_times != NULL) {
<span class="line-modified">629     if (_must_record) {</span>
<span class="line-added">630       _phase_times-&gt;record_time_secs(_phase, _worker_id, (Ticks::now() - _start_time).seconds());</span>
<span class="line-added">631     } else {</span>
<span class="line-added">632       _phase_times-&gt;record_or_add_time_secs(_phase, _worker_id, (Ticks::now() - _start_time).seconds());</span>
<span class="line-added">633     }</span>
634     _event.commit(GCId::current(), _worker_id, G1GCPhaseTimes::phase_name(_phase));
635   }
636 }
637 
638 G1EvacPhaseTimesTracker::G1EvacPhaseTimesTracker(G1GCPhaseTimes* phase_times,
639                                                  G1ParScanThreadState* pss,
640                                                  G1GCPhaseTimes::GCParPhases phase,
641                                                  uint worker_id) :
642   G1GCParPhaseTimesTracker(phase_times, phase, worker_id),
643   _total_time(),
644   _trim_time(),
645   _trim_tracker(pss, _total_time, _trim_time) {
646 }
647 
648 G1EvacPhaseTimesTracker::~G1EvacPhaseTimesTracker() {
649   if (_phase_times != NULL) {
650     // Explicitly stop the trim tracker since it&#39;s not yet destructed.
651     _trim_tracker.stop();
652     // Exclude trim time by increasing the start time.
653     _start_time += _trim_time;
</pre>
</td>
</tr>
</table>
<center><a href="g1FullGCScope.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1GCPhaseTimes.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
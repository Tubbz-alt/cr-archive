<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/g1/g1SATBMarkQueueSet.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 27 #include &quot;gc/g1/g1SATBMarkQueueSet.hpp&quot;
 28 #include &quot;gc/g1/g1ThreadLocalData.hpp&quot;
 29 #include &quot;gc/g1/heapRegion.hpp&quot;
 30 #include &quot;gc/shared/satbMarkQueue.hpp&quot;
 31 #include &quot;oops/oop.hpp&quot;
 32 #include &quot;utilities/debug.hpp&quot;
 33 #include &quot;utilities/globalDefinitions.hpp&quot;
 34 
 35 G1SATBMarkQueueSet::G1SATBMarkQueueSet() : _g1h(NULL) {}
 36 
 37 void G1SATBMarkQueueSet::initialize(G1CollectedHeap* g1h,
 38                                     Monitor* cbl_mon,
 39                                     BufferNode::Allocator* allocator,
 40                                     size_t process_completed_buffers_threshold,
 41                                     uint buffer_enqueue_threshold_percentage) {
 42   SATBMarkQueueSet::initialize(cbl_mon,
 43                                allocator,
 44                                process_completed_buffers_threshold,
 45                                buffer_enqueue_threshold_percentage);
 46   _g1h = g1h;
 47 }
 48 
 49 void G1SATBMarkQueueSet::handle_zero_index_for_thread(Thread* t) {
 50   G1ThreadLocalData::satb_mark_queue(t).handle_zero_index();
 51 }
 52 
 53 SATBMarkQueue&amp; G1SATBMarkQueueSet::satb_queue_for_thread(Thread* const t) const{
 54   return G1ThreadLocalData::satb_mark_queue(t);
 55 }
 56 
 57 // Return true if a SATB buffer entry refers to an object that
 58 // requires marking.
 59 //
 60 // The entry must point into the G1 heap.  In particular, it must not
 61 // be a NULL pointer.  NULL pointers are pre-filtered and never
 62 // inserted into a SATB buffer.
 63 //
 64 // An entry that is below the NTAMS pointer for the containing heap
 65 // region requires marking. Such an entry must point to a valid object.
 66 //
 67 // An entry that is at least the NTAMS pointer for the containing heap
 68 // region might be any of the following, none of which should be marked.
 69 //
 70 // * A reference to an object allocated since marking started.
 71 //   According to SATB, such objects are implicitly kept live and do
 72 //   not need to be dealt with via SATB buffer processing.
 73 //
 74 // * A reference to a young generation object. Young objects are
 75 //   handled separately and are not marked by concurrent marking.
 76 //
 77 // * A stale reference to a young generation object. If a young
 78 //   generation object reference is recorded and not filtered out
 79 //   before being moved by a young collection, the reference becomes
 80 //   stale.
 81 //
 82 // * A stale reference to an eagerly reclaimed humongous object.  If a
 83 //   humongous object is recorded and then reclaimed, the reference
 84 //   becomes stale.
 85 //
 86 // The stale reference cases are implicitly handled by the NTAMS
 87 // comparison. Because of the possibility of stale references, buffer
 88 // processing must be somewhat circumspect and not assume entries
 89 // in an unfiltered buffer refer to valid objects.
 90 
 91 static inline bool requires_marking(const void* entry, G1CollectedHeap* g1h) {
 92   // Includes rejection of NULL pointers.
 93   assert(g1h-&gt;is_in_reserved(entry),
 94          &quot;Non-heap pointer in SATB buffer: &quot; PTR_FORMAT, p2i(entry));
 95 
 96   HeapRegion* region = g1h-&gt;heap_region_containing(entry);
 97   assert(region != NULL, &quot;No region for &quot; PTR_FORMAT, p2i(entry));
 98   if (entry &gt;= region-&gt;next_top_at_mark_start()) {
 99     return false;
100   }
101 
102   assert(oopDesc::is_oop(oop(entry), true /* ignore mark word */),
103          &quot;Invalid oop in SATB buffer: &quot; PTR_FORMAT, p2i(entry));
104 
105   return true;
106 }
107 
108 static inline bool discard_entry(const void* entry, G1CollectedHeap* g1h) {
109   return !requires_marking(entry, g1h) || g1h-&gt;is_marked_next((oop)entry);
110 }
111 
112 // Workaround for not yet having std::bind.
113 class G1SATBMarkQueueFilterFn {
114   G1CollectedHeap* _g1h;
115 
116 public:
117   G1SATBMarkQueueFilterFn(G1CollectedHeap* g1h) : _g1h(g1h) {}
118 
119   // Return true if entry should be filtered out (removed), false if
120   // it should be retained.
121   bool operator()(const void* entry) const {
122     return discard_entry(entry, _g1h);
123   }
124 };
125 
126 void G1SATBMarkQueueSet::filter(SATBMarkQueue* queue) {
127   assert(_g1h != NULL, &quot;SATB queue set not initialized&quot;);
128   apply_filter(G1SATBMarkQueueFilterFn(_g1h), queue);
129 }
    </pre>
  </body>
</html>
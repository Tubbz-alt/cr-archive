diff a/src/hotspot/share/gc/g1/g1BlockOffsetTable.cpp b/src/hotspot/share/gc/g1/g1BlockOffsetTable.cpp
--- a/src/hotspot/share/gc/g1/g1BlockOffsetTable.cpp
+++ b/src/hotspot/share/gc/g1/g1BlockOffsetTable.cpp
@@ -23,12 +23,11 @@
  */
 
 #include "precompiled.hpp"
 #include "gc/g1/g1BlockOffsetTable.inline.hpp"
 #include "gc/g1/g1CollectedHeap.inline.hpp"
-#include "gc/g1/heapRegion.hpp"
-#include "gc/shared/space.hpp"
+#include "gc/g1/heapRegion.inline.hpp"
 #include "logging/log.hpp"
 #include "oops/oop.inline.hpp"
 #include "runtime/java.hpp"
 #include "services/memTracker.hpp"
 
@@ -72,16 +71,16 @@
 
 //////////////////////////////////////////////////////////////////////
 // G1BlockOffsetTablePart
 //////////////////////////////////////////////////////////////////////
 
-G1BlockOffsetTablePart::G1BlockOffsetTablePart(G1BlockOffsetTable* array, G1ContiguousSpace* gsp) :
+G1BlockOffsetTablePart::G1BlockOffsetTablePart(G1BlockOffsetTable* array, HeapRegion* hr) :
   _next_offset_threshold(NULL),
   _next_offset_index(0),
   DEBUG_ONLY(_object_can_span(false) COMMA)
   _bot(array),
-  _space(gsp)
+  _hr(hr)
 {
 }
 
 // The arguments follow the normal convention of denoting
 // a right-open interval: [start, end)
@@ -139,11 +138,11 @@
 // above.
 void G1BlockOffsetTablePart::set_remainder_to_point_to_start_incl(size_t start_card, size_t end_card) {
   if (start_card > end_card) {
     return;
   }
-  assert(start_card > _bot->index_for(_space->bottom()), "Cannot be first card");
+  assert(start_card > _bot->index_for(_hr->bottom()), "Cannot be first card");
   assert(_bot->offset_array(start_card-1) <= BOTConstants::N_words,
          "Offset card has an unexpected value");
   size_t start_card_for_region = start_card;
   u_char offset = max_jubyte;
   for (uint i = 0; i < BOTConstants::N_powers; i++) {
@@ -222,11 +221,11 @@
                             (n_index == next_index ? 0 : BOTConstants::N_words);
   assert(next_boundary <= _bot->_reserved.end(),
          "next_boundary is beyond the end of the covered region "
          " next_boundary " PTR_FORMAT " _array->_end " PTR_FORMAT,
          p2i(next_boundary), p2i(_bot->_reserved.end()));
-  if (addr >= _space->top()) return _space->top();
+  if (addr >= _hr->top()) return _hr->top();
   while (next_boundary < addr) {
     while (n <= next_boundary) {
       q = n;
       oop obj = oop(q);
       if (obj->klass_or_null_acquire() == NULL) return q;
@@ -324,13 +323,13 @@
   }
 #endif
 }
 
 void G1BlockOffsetTablePart::verify() const {
-  assert(_space->bottom() < _space->top(), "Only non-empty regions should be verified.");
-  size_t start_card = _bot->index_for(_space->bottom());
-  size_t end_card = _bot->index_for(_space->top() - 1);
+  assert(_hr->bottom() < _hr->top(), "Only non-empty regions should be verified.");
+  size_t start_card = _bot->index_for(_hr->bottom());
+  size_t end_card = _bot->index_for(_hr->top() - 1);
 
   for (size_t current_card = start_card; current_card < end_card; current_card++) {
     u_char entry = _bot->offset_array(current_card);
     if (entry < BOTConstants::N_words) {
       // The entry should point to an object before the current card. Verify that
@@ -340,13 +339,13 @@
       HeapWord* obj_end = card_address - entry;
       while (obj_end < card_address) {
         HeapWord* obj = obj_end;
         size_t obj_size = block_size(obj);
         obj_end = obj + obj_size;
-        guarantee(obj_end > obj && obj_end <= _space->top(),
+        guarantee(obj_end > obj && obj_end <= _hr->top(),
                   "Invalid object end. obj: " PTR_FORMAT " obj_size: " SIZE_FORMAT " obj_end: " PTR_FORMAT " top: " PTR_FORMAT,
-                  p2i(obj), obj_size, p2i(obj_end), p2i(_space->top()));
+                  p2i(obj), obj_size, p2i(obj_end), p2i(_hr->top()));
       }
     } else {
       // Because we refine the BOT based on which cards are dirty there is not much we can verify here.
       // We need to make sure that we are going backwards and that we don't pass the start of the
       // corresponding heap region. But that is about all we can verify.
@@ -357,13 +356,13 @@
       guarantee(backskip <= max_backskip,
                 "Going backwards beyond the start_card. start_card: " SIZE_FORMAT " current_card: " SIZE_FORMAT " backskip: " SIZE_FORMAT,
                 start_card, current_card, backskip);
 
       HeapWord* backskip_address = _bot->address_for_index(current_card - backskip);
-      guarantee(backskip_address >= _space->bottom(),
+      guarantee(backskip_address >= _hr->bottom(),
                 "Going backwards beyond bottom of the region: bottom: " PTR_FORMAT ", backskip_address: " PTR_FORMAT,
-                p2i(_space->bottom()), p2i(backskip_address));
+                p2i(_hr->bottom()), p2i(backskip_address));
     }
   }
 }
 
 #ifdef ASSERT
@@ -371,17 +370,16 @@
   _object_can_span = can_span;
 }
 #endif
 
 #ifndef PRODUCT
-void
-G1BlockOffsetTablePart::print_on(outputStream* out) {
-  size_t from_index = _bot->index_for(_space->bottom());
-  size_t to_index = _bot->index_for(_space->end());
+void G1BlockOffsetTablePart::print_on(outputStream* out) {
+  size_t from_index = _bot->index_for(_hr->bottom());
+  size_t to_index = _bot->index_for(_hr->end());
   out->print_cr(">> BOT for area [" PTR_FORMAT "," PTR_FORMAT ") "
                 "cards [" SIZE_FORMAT "," SIZE_FORMAT ")",
-                p2i(_space->bottom()), p2i(_space->end()), from_index, to_index);
+                p2i(_hr->bottom()), p2i(_hr->end()), from_index, to_index);
   for (size_t i = from_index; i < to_index; ++i) {
     out->print_cr("  entry " SIZE_FORMAT_W(8) " | " PTR_FORMAT " : %3u",
                   i, p2i(_bot->address_for_index(i)),
                   (uint) _bot->offset_array(i));
   }
@@ -389,41 +387,35 @@
   out->print_cr("  next offset index:     " SIZE_FORMAT, _next_offset_index);
 }
 #endif // !PRODUCT
 
 HeapWord* G1BlockOffsetTablePart::initialize_threshold_raw() {
-  assert(!G1CollectedHeap::heap()->is_in_reserved(_bot->_offset_array),
-         "just checking");
-  _next_offset_index = _bot->index_for_raw(_space->bottom());
+  _next_offset_index = _bot->index_for_raw(_hr->bottom());
   _next_offset_index++;
   _next_offset_threshold =
     _bot->address_for_index_raw(_next_offset_index);
   return _next_offset_threshold;
 }
 
 void G1BlockOffsetTablePart::zero_bottom_entry_raw() {
-  assert(!G1CollectedHeap::heap()->is_in_reserved(_bot->_offset_array),
-         "just checking");
-  size_t bottom_index = _bot->index_for_raw(_space->bottom());
-  assert(_bot->address_for_index_raw(bottom_index) == _space->bottom(),
+  size_t bottom_index = _bot->index_for_raw(_hr->bottom());
+  assert(_bot->address_for_index_raw(bottom_index) == _hr->bottom(),
          "Precondition of call");
   _bot->set_offset_array_raw(bottom_index, 0);
 }
 
 HeapWord* G1BlockOffsetTablePart::initialize_threshold() {
-  assert(!G1CollectedHeap::heap()->is_in_reserved(_bot->_offset_array),
-         "just checking");
-  _next_offset_index = _bot->index_for(_space->bottom());
+  _next_offset_index = _bot->index_for(_hr->bottom());
   _next_offset_index++;
   _next_offset_threshold =
     _bot->address_for_index(_next_offset_index);
   return _next_offset_threshold;
 }
 
 void G1BlockOffsetTablePart::set_for_starts_humongous(HeapWord* obj_top, size_t fill_size) {
   // The first BOT entry should have offset 0.
   reset_bot();
-  alloc_block(_space->bottom(), obj_top);
+  alloc_block(_hr->bottom(), obj_top);
   if (fill_size > 0) {
     alloc_block(obj_top, fill_size);
   }
 }

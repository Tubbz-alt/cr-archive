<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/g1/g1ConcurrentMark.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1ConcurrentMark.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ConcurrentMark.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1ConcurrentMark.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 28,11 ***</span>
<span class="line-new-header">--- 28,14 ---</span>
  #include &quot;gc/g1/g1ConcurrentMarkBitMap.hpp&quot;
  #include &quot;gc/g1/g1ConcurrentMarkObjArrayProcessor.hpp&quot;
  #include &quot;gc/g1/g1HeapVerifier.hpp&quot;
  #include &quot;gc/g1/g1RegionMarkStatsCache.hpp&quot;
  #include &quot;gc/g1/heapRegionSet.hpp&quot;
<span class="line-added">+ #include &quot;gc/shared/taskTerminator.hpp&quot;</span>
  #include &quot;gc/shared/taskqueue.hpp&quot;
<span class="line-added">+ #include &quot;gc/shared/verifyOption.hpp&quot;</span>
<span class="line-added">+ #include &quot;gc/shared/workgroup.hpp&quot;</span>
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;utilities/compilerWarnings.hpp&quot;
  
  class ConcurrentGCTimer;
  class G1ConcurrentMarkThread;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 41,10 ***</span>
<span class="line-new-header">--- 44,11 ---</span>
  class G1CMTask;
  class G1ConcurrentMark;
  class G1OldTracer;
  class G1RegionToSpaceMapper;
  class G1SurvivorRegions;
<span class="line-added">+ class ThreadClosure;</span>
  
  PRAGMA_DIAG_PUSH
  // warning C4522: multiple assignment operators specified
  PRAGMA_DISABLE_MSVC_WARNING(4522)
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 219,22 ***</span>
    // Apply Fn to every oop on the mark stack. The mark stack must not
    // be modified while iterating.
    template&lt;typename Fn&gt; void iterate(Fn fn) const PRODUCT_RETURN;
  };
  
<span class="line-modified">! // Root Regions are regions that contain objects from nTAMS to top. These are roots</span>
<span class="line-modified">! // for marking, i.e. their referenced objects must be kept alive to maintain the</span>
  // SATB invariant.
<span class="line-modified">! // We could scan and mark them through during the initial-mark pause, but for</span>
  // pause time reasons we move this work to the concurrent phase.
  // We need to complete this procedure before the next GC because it might determine
  // that some of these &quot;root objects&quot; are dead, potentially dropping some required
  // references.
<span class="line-modified">! // Root regions comprise of the complete contents of survivor regions, and any</span>
<span class="line-modified">! // objects copied into old gen during GC.</span>
<span class="line-modified">! class G1CMRootRegions {</span>
<span class="line-modified">!   HeapRegion** _root_regions;</span>
    size_t const _max_regions;
  
    volatile size_t _num_root_regions; // Actual number of root regions.
  
    volatile size_t _claimed_root_regions; // Number of root regions currently claimed.
<span class="line-new-header">--- 223,24 ---</span>
    // Apply Fn to every oop on the mark stack. The mark stack must not
    // be modified while iterating.
    template&lt;typename Fn&gt; void iterate(Fn fn) const PRODUCT_RETURN;
  };
  
<span class="line-modified">! // Root MemRegions are memory areas that contain objects which references are</span>
<span class="line-modified">! // roots wrt to the marking. They must be scanned before marking to maintain the</span>
  // SATB invariant.
<span class="line-modified">! // Typically they contain the areas from nTAMS to top of the regions.</span>
<span class="line-added">+ // We could scan and mark through these objects during the initial-mark pause, but for</span>
  // pause time reasons we move this work to the concurrent phase.
  // We need to complete this procedure before the next GC because it might determine
  // that some of these &quot;root objects&quot; are dead, potentially dropping some required
  // references.
<span class="line-modified">! // Root MemRegions comprise of the contents of survivor regions at the end</span>
<span class="line-modified">! // of the GC, and any objects copied into the old gen during GC.</span>
<span class="line-modified">! class G1CMRootMemRegions {</span>
<span class="line-modified">!   // The set of root MemRegions.</span>
<span class="line-added">+   MemRegion*   _root_regions;</span>
    size_t const _max_regions;
  
    volatile size_t _num_root_regions; // Actual number of root regions.
  
    volatile size_t _claimed_root_regions; // Number of root regions currently claimed.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 243,17 ***</span>
    volatile bool _should_abort;
  
    void notify_scan_done();
  
  public:
<span class="line-modified">!   G1CMRootRegions(uint const max_regions);</span>
<span class="line-modified">!   ~G1CMRootRegions();</span>
  
    // Reset the data structure to allow addition of new root regions.
    void reset();
  
<span class="line-modified">!   void add(HeapRegion* hr);</span>
  
    // Reset the claiming / scanning of the root regions.
    void prepare_for_scan();
  
    // Forces get_next() to return NULL so that the iteration aborts early.
<span class="line-new-header">--- 249,17 ---</span>
    volatile bool _should_abort;
  
    void notify_scan_done();
  
  public:
<span class="line-modified">!   G1CMRootMemRegions(uint const max_regions);</span>
<span class="line-modified">!   ~G1CMRootMemRegions();</span>
  
    // Reset the data structure to allow addition of new root regions.
    void reset();
  
<span class="line-modified">!   void add(HeapWord* start, HeapWord* end);</span>
  
    // Reset the claiming / scanning of the root regions.
    void prepare_for_scan();
  
    // Forces get_next() to return NULL so that the iteration aborts early.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 261,13 ***</span>
  
    // Return true if the CM thread are actively scanning root regions,
    // false otherwise.
    bool scan_in_progress() { return _scan_in_progress; }
  
<span class="line-modified">!   // Claim the next root region to scan atomically, or return NULL if</span>
    // all have been claimed.
<span class="line-modified">!   HeapRegion* claim_next();</span>
  
    // The number of root regions to scan.
    uint num_root_regions() const;
  
    void cancel_scan();
<span class="line-new-header">--- 267,13 ---</span>
  
    // Return true if the CM thread are actively scanning root regions,
    // false otherwise.
    bool scan_in_progress() { return _scan_in_progress; }
  
<span class="line-modified">!   // Claim the next root MemRegion to scan atomically, or return NULL if</span>
    // all have been claimed.
<span class="line-modified">!   const MemRegion* claim_next();</span>
  
    // The number of root regions to scan.
    uint num_root_regions() const;
  
    void cancel_scan();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 307,11 ***</span>
  
    // Heap bounds
    MemRegion const         _heap;
  
    // Root region tracking and claiming
<span class="line-modified">!   G1CMRootRegions         _root_regions;</span>
  
    // For grey objects
    G1CMMarkStack           _global_mark_stack; // Grey objects behind global finger
    HeapWord* volatile      _finger;            // The global finger, region aligned,
                                                // always pointing to the end of the
<span class="line-new-header">--- 313,11 ---</span>
  
    // Heap bounds
    MemRegion const         _heap;
  
    // Root region tracking and claiming
<span class="line-modified">!   G1CMRootMemRegions         _root_regions;</span>
  
    // For grey objects
    G1CMMarkStack           _global_mark_stack; // Grey objects behind global finger
    HeapWord* volatile      _finger;            // The global finger, region aligned,
                                                // always pointing to the end of the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 407,14 ***</span>
    void set_concurrency_and_phase(uint active_tasks, bool concurrent);
  
    // Prints all gathered CM-related statistics
    void print_stats();
  
<span class="line-modified">!   HeapWord*               finger()           { return _finger;   }</span>
<span class="line-modified">!   bool                    concurrent()       { return _concurrent; }</span>
<span class="line-modified">!   uint                    active_tasks()     { return _num_active_tasks; }</span>
<span class="line-modified">!   ParallelTaskTerminator* terminator() const { return _terminator.terminator(); }</span>
  
    // Claims the next available region to be scanned by a marking
    // task/thread. It might return NULL if the next region is empty or
    // we have run out of regions. In the latter case, out_of_regions()
    // determines whether we&#39;ve really run out of regions or the task
<span class="line-new-header">--- 413,14 ---</span>
    void set_concurrency_and_phase(uint active_tasks, bool concurrent);
  
    // Prints all gathered CM-related statistics
    void print_stats();
  
<span class="line-modified">!   HeapWord*           finger()       { return _finger;   }</span>
<span class="line-modified">!   bool                concurrent()   { return _concurrent; }</span>
<span class="line-modified">!   uint                active_tasks() { return _num_active_tasks; }</span>
<span class="line-modified">!   TaskTerminator*     terminator()   { return &amp;_terminator; }</span>
  
    // Claims the next available region to be scanned by a marking
    // task/thread. It might return NULL if the next region is empty or
    // we have run out of regions. In the latter case, out_of_regions()
    // determines whether we&#39;ve really run out of regions or the task
</pre>
<hr />
<pre>
<span class="line-old-header">*** 498,11 ***</span>
    }
    size_t mark_stack_size() const                { return _global_mark_stack.size(); }
    size_t partial_mark_stack_size_target() const { return _global_mark_stack.capacity() / 3; }
    bool mark_stack_empty() const                 { return _global_mark_stack.is_empty(); }
  
<span class="line-modified">!   G1CMRootRegions* root_regions() { return &amp;_root_regions; }</span>
  
    void concurrent_cycle_start();
    // Abandon current marking iteration due to a Full GC.
    void concurrent_cycle_abort();
    void concurrent_cycle_end();
<span class="line-new-header">--- 504,11 ---</span>
    }
    size_t mark_stack_size() const                { return _global_mark_stack.size(); }
    size_t partial_mark_stack_size_target() const { return _global_mark_stack.capacity() / 3; }
    bool mark_stack_empty() const                 { return _global_mark_stack.is_empty(); }
  
<span class="line-modified">!   G1CMRootMemRegions* root_regions() { return &amp;_root_regions; }</span>
  
    void concurrent_cycle_start();
    // Abandon current marking iteration due to a Full GC.
    void concurrent_cycle_abort();
    void concurrent_cycle_end();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 551,12 ***</span>
  
    // Scan all the root regions and mark everything reachable from
    // them.
    void scan_root_regions();
  
<span class="line-modified">!   // Scan a single root region from nTAMS to top and mark everything reachable from it.</span>
<span class="line-modified">!   void scan_root_region(HeapRegion* hr, uint worker_id);</span>
  
    // Do concurrent phase of marking, to a tentative transitive closure.
    void mark_from_roots();
  
    // Do concurrent preclean work.
<span class="line-new-header">--- 557,12 ---</span>
  
    // Scan all the root regions and mark everything reachable from
    // them.
    void scan_root_regions();
  
<span class="line-modified">!   // Scan a single root MemRegion to mark everything reachable from it.</span>
<span class="line-modified">!   void scan_root_region(const MemRegion* region, uint worker_id);</span>
  
    // Do concurrent phase of marking, to a tentative transitive closure.
    void mark_from_roots();
  
    // Do concurrent preclean work.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 577,11 ***</span>
    inline bool is_marked_in_prev_bitmap(oop p) const;
  
    // Verify that there are no collection set oops on the stacks (taskqueues /
    // global mark stack) and fingers (global / per-task).
    // If marking is not in progress, it&#39;s a no-op.
<span class="line-modified">!   void verify_no_cset_oops() PRODUCT_RETURN;</span>
  
    inline bool do_yield_check();
  
    bool has_aborted()      { return _has_aborted; }
  
<span class="line-new-header">--- 583,11 ---</span>
    inline bool is_marked_in_prev_bitmap(oop p) const;
  
    // Verify that there are no collection set oops on the stacks (taskqueues /
    // global mark stack) and fingers (global / per-task).
    // If marking is not in progress, it&#39;s a no-op.
<span class="line-modified">!   void verify_no_collection_set_oops() PRODUCT_RETURN;</span>
  
    inline bool do_yield_check();
  
    bool has_aborted()      { return _has_aborted; }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 695,11 ***</span>
    // Termination time of this task
    double                      _termination_time_ms;
    // When this task got into the termination protocol
    double                      _termination_start_time_ms;
  
<span class="line-modified">!   TruncatedSeq                _marking_step_diffs_ms;</span>
  
    // Updates the local fields after this task has claimed
    // a new region to scan
    void setup_for_region(HeapRegion* hr);
    // Makes the limit of the region up-to-date
<span class="line-new-header">--- 701,11 ---</span>
    // Termination time of this task
    double                      _termination_time_ms;
    // When this task got into the termination protocol
    double                      _termination_start_time_ms;
  
<span class="line-modified">!   TruncatedSeq                _marking_step_diff_ms;</span>
  
    // Updates the local fields after this task has claimed
    // a new region to scan
    void setup_for_region(HeapRegion* hr);
    // Makes the limit of the region up-to-date
</pre>
<center><a href="g1ConcurrentMark.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ConcurrentMark.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
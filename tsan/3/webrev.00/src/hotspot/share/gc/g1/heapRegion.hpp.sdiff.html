<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/heapRegion.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="heapRegion.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegion.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/heapRegion.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_HEAPREGION_HPP
 26 #define SHARE_GC_G1_HEAPREGION_HPP
 27 
 28 #include &quot;gc/g1/g1BlockOffsetTable.hpp&quot;
 29 #include &quot;gc/g1/g1HeapRegionTraceType.hpp&quot;

 30 #include &quot;gc/g1/heapRegionTracer.hpp&quot;
 31 #include &quot;gc/g1/heapRegionType.hpp&quot;
<span class="line-removed"> 32 #include &quot;gc/g1/survRateGroup.hpp&quot;</span>
 33 #include &quot;gc/shared/ageTable.hpp&quot;
<span class="line-removed"> 34 #include &quot;gc/shared/cardTable.hpp&quot;</span>
 35 #include &quot;gc/shared/spaceDecorator.hpp&quot;


 36 #include &quot;utilities/macros.hpp&quot;
 37 
<span class="line-removed"> 38 // A HeapRegion is the smallest piece of a G1CollectedHeap that</span>
<span class="line-removed"> 39 // can be collected independently.</span>
<span class="line-removed"> 40 </span>
<span class="line-removed"> 41 // NOTE: Although a HeapRegion is a Space, its</span>
<span class="line-removed"> 42 // Space::initDirtyCardClosure method must not be called.</span>
<span class="line-removed"> 43 // The problem is that the existence of this method breaks</span>
<span class="line-removed"> 44 // the independence of barrier sets from remembered sets.</span>
<span class="line-removed"> 45 // The solution is to remove this method from the definition</span>
<span class="line-removed"> 46 // of a Space.</span>
<span class="line-removed"> 47 </span>
<span class="line-removed"> 48 // Each heap region is self contained. top() and end() can never</span>
<span class="line-removed"> 49 // be set beyond the end of the region. For humongous objects,</span>
<span class="line-removed"> 50 // the first region is a StartsHumongous region. If the humongous</span>
<span class="line-removed"> 51 // object is larger than a heap region, the following regions will</span>
<span class="line-removed"> 52 // be of type ContinuesHumongous. In this case the top() of the</span>
<span class="line-removed"> 53 // StartHumongous region and all ContinuesHumongous regions except</span>
<span class="line-removed"> 54 // the last will point to their own end. The last ContinuesHumongous</span>
<span class="line-removed"> 55 // region may have top() equal the end of object if there isn&#39;t</span>
<span class="line-removed"> 56 // room for filler objects to pad out to the end of the region.</span>
<span class="line-removed"> 57 </span>
 58 class G1CollectedHeap;
 59 class G1CMBitMap;
<span class="line-modified"> 60 class G1IsAliveAndApplyClosure;</span>
 61 class HeapRegionRemSet;
<span class="line-removed"> 62 class HeapRegionRemSetIterator;</span>
 63 class HeapRegion;
 64 class HeapRegionSetBase;
 65 class nmethod;
 66 
 67 #define HR_FORMAT &quot;%u:(%s)[&quot; PTR_FORMAT &quot;,&quot; PTR_FORMAT &quot;,&quot; PTR_FORMAT &quot;]&quot;
 68 #define HR_FORMAT_PARAMS(_hr_) \
 69                 (_hr_)-&gt;hrm_index(), \
 70                 (_hr_)-&gt;get_short_type_str(), \
 71                 p2i((_hr_)-&gt;bottom()), p2i((_hr_)-&gt;top()), p2i((_hr_)-&gt;end())
 72 
 73 // sentinel value for hrm_index
 74 #define G1_NO_HRM_INDEX ((uint) -1)
 75 
<span class="line-modified"> 76 // The complicating factor is that BlockOffsetTable diverged</span>
<span class="line-modified"> 77 // significantly, and we need functionality that is only in the G1 version.</span>
<span class="line-modified"> 78 // So I copied that code, which led to an alternate G1 version of</span>
<span class="line-modified"> 79 // OffsetTableContigSpace.  If the two versions of BlockOffsetTable could</span>
<span class="line-modified"> 80 // be reconciled, then G1OffsetTableContigSpace could go away.</span>
<span class="line-modified"> 81 </span>
<span class="line-modified"> 82 // The idea behind time stamps is the following. We want to keep track of</span>
<span class="line-modified"> 83 // the highest address where it&#39;s safe to scan objects for each region.</span>
<span class="line-modified"> 84 // This is only relevant for current GC alloc regions so we keep a time stamp</span>
<span class="line-modified"> 85 // per region to determine if the region has been allocated during the current</span>
<span class="line-modified"> 86 // GC or not. If the time stamp is current we report a scan_top value which</span>
<span class="line-modified"> 87 // was saved at the end of the previous GC for retained alloc regions and which is</span>
<span class="line-modified"> 88 // equal to the bottom for all other regions.</span>
<span class="line-removed"> 89 // There is a race between card scanners and allocating gc workers where we must ensure</span>
<span class="line-removed"> 90 // that card scanners do not read the memory allocated by the gc workers.</span>
<span class="line-removed"> 91 // In order to enforce that, we must not return a value of _top which is more recent than the</span>
<span class="line-removed"> 92 // time stamp. This is due to the fact that a region may become a gc alloc region at</span>
<span class="line-removed"> 93 // some point after we&#39;ve read the timestamp value as being &lt; the current time stamp.</span>
<span class="line-removed"> 94 // The time stamps are re-initialized to zero at cleanup and at Full GCs.</span>
<span class="line-removed"> 95 // The current scheme that uses sequential unsigned ints will fail only if we have 4b</span>
<span class="line-removed"> 96 // evacuation pauses between two cleanups, which is _highly_ unlikely.</span>
<span class="line-removed"> 97 class G1ContiguousSpace: public CompactibleSpace {</span>
 98   friend class VMStructs;




 99   HeapWord* volatile _top;
<span class="line-modified">100  protected:</span>

101   G1BlockOffsetTablePart _bot_part;
102   Mutex _par_alloc_lock;
103   // When we need to retire an allocation region, while other threads
104   // are also concurrently trying to allocate into it, we typically
105   // allocate a dummy object at the end of the region to ensure that
106   // no more allocations can take place in it. However, sometimes we
107   // want to know where the end of the last &quot;real&quot; object we allocated
108   // into the region was and this is what this keeps track.
109   HeapWord* _pre_dummy_top;
110 
<span class="line-modified">111  public:</span>
<span class="line-modified">112   G1ContiguousSpace(G1BlockOffsetTable* bot);</span>




113 
114   void set_top(HeapWord* value) { _top = value; }
115   HeapWord* top() const { return _top; }
116 
<span class="line-modified">117  protected:</span>
<span class="line-modified">118   // Reset the G1ContiguousSpace.</span>
<span class="line-modified">119   virtual void initialize(MemRegion mr, bool clear_space, bool mangle_space);</span>





























120 
<span class="line-modified">121   HeapWord* volatile* top_addr() { return &amp;_top; }</span>
<span class="line-modified">122   // Try to allocate at least min_word_size and up to desired_size from this Space.</span>



123   // Returns NULL if not possible, otherwise sets actual_word_size to the amount of
124   // space allocated.
<span class="line-modified">125   // This version assumes that all allocation requests to this Space are properly</span>
126   // synchronized.
127   inline HeapWord* allocate_impl(size_t min_word_size, size_t desired_word_size, size_t* actual_word_size);
<span class="line-modified">128   // Try to allocate at least min_word_size and up to desired_size from this Space.</span>
129   // Returns NULL if not possible, otherwise sets actual_word_size to the amount of
130   // space allocated.
131   // This version synchronizes with other calls to par_allocate_impl().
132   inline HeapWord* par_allocate_impl(size_t min_word_size, size_t desired_word_size, size_t* actual_word_size);
133 
<span class="line-modified">134  public:</span>
<span class="line-modified">135   void reset_after_compaction() { set_top(compaction_top()); }</span>
<span class="line-removed">136 </span>
<span class="line-removed">137   size_t used() const { return byte_size(bottom(), top()); }</span>
<span class="line-removed">138   size_t free() const { return byte_size(top(), end()); }</span>
<span class="line-removed">139   bool is_free_block(const HeapWord* p) const { return p &gt;= top(); }</span>
<span class="line-removed">140 </span>
<span class="line-removed">141   MemRegion used_region() const { return MemRegion(bottom(), top()); }</span>
142 
143   void object_iterate(ObjectClosure* blk);
<span class="line-removed">144   void safe_object_iterate(ObjectClosure* blk);</span>
<span class="line-removed">145 </span>
<span class="line-removed">146   void mangle_unused_area() PRODUCT_RETURN;</span>
<span class="line-removed">147   void mangle_unused_area_complete() PRODUCT_RETURN;</span>
<span class="line-removed">148 </span>
<span class="line-removed">149   // See the comment above in the declaration of _pre_dummy_top for an</span>
<span class="line-removed">150   // explanation of what it is.</span>
<span class="line-removed">151   void set_pre_dummy_top(HeapWord* pre_dummy_top) {</span>
<span class="line-removed">152     assert(is_in(pre_dummy_top) &amp;&amp; pre_dummy_top &lt;= top(), &quot;pre-condition&quot;);</span>
<span class="line-removed">153     _pre_dummy_top = pre_dummy_top;</span>
<span class="line-removed">154   }</span>
<span class="line-removed">155   HeapWord* pre_dummy_top() {</span>
<span class="line-removed">156     return (_pre_dummy_top == NULL) ? top() : _pre_dummy_top;</span>
<span class="line-removed">157   }</span>
<span class="line-removed">158   void reset_pre_dummy_top() { _pre_dummy_top = NULL; }</span>
<span class="line-removed">159 </span>
<span class="line-removed">160   virtual void clear(bool mangle_space);</span>
<span class="line-removed">161 </span>
<span class="line-removed">162   HeapWord* block_start(const void* p);</span>
<span class="line-removed">163   HeapWord* block_start_const(const void* p) const;</span>
164 
165   // Allocation (return NULL if full).  Assumes the caller has established
<span class="line-modified">166   // mutually exclusive access to the space.</span>
167   HeapWord* allocate(size_t min_word_size, size_t desired_word_size, size_t* actual_word_size);
168   // Allocation (return NULL if full).  Enforces mutual exclusion internally.
169   HeapWord* par_allocate(size_t min_word_size, size_t desired_word_size, size_t* actual_word_size);
170 
<span class="line-modified">171   virtual HeapWord* allocate(size_t word_size);</span>
<span class="line-modified">172   virtual HeapWord* par_allocate(size_t word_size);</span>
<span class="line-removed">173 </span>
<span class="line-removed">174   HeapWord* saved_mark_word() const { ShouldNotReachHere(); return NULL; }</span>
175 
<span class="line-modified">176   // MarkSweep support phase3</span>
<span class="line-modified">177   virtual HeapWord* initialize_threshold();</span>
<span class="line-modified">178   virtual HeapWord* cross_threshold(HeapWord* start, HeapWord* end);</span>
179 
<span class="line-modified">180   virtual void print() const;</span>
181 
<span class="line-modified">182   void reset_bot() {</span>
<span class="line-modified">183     _bot_part.reset_bot();</span>
<span class="line-modified">184   }</span>



185 
<span class="line-modified">186   void print_bot_on(outputStream* out) {</span>
<span class="line-modified">187     _bot_part.print_on(out);</span>
188   }
<span class="line-modified">189 };</span>

190 
<span class="line-modified">191 class HeapRegion: public G1ContiguousSpace {</span>
<span class="line-modified">192   friend class VMStructs;</span>
<span class="line-removed">193   // Allow scan_and_forward to call (private) overrides for auxiliary functions on this class</span>
<span class="line-removed">194   template &lt;typename SpaceType&gt;</span>
<span class="line-removed">195   friend void CompactibleSpace::scan_and_forward(SpaceType* space, CompactPoint* cp);</span>
<span class="line-removed">196  private:</span>
197 
<span class="line-modified">198   // The remembered set for this region.</span>
<span class="line-modified">199   // (Might want to make this &quot;inline&quot; later, to avoid some alloc failure</span>
<span class="line-removed">200   // issues.)</span>
<span class="line-removed">201   HeapRegionRemSet* _rem_set;</span>
202 
<span class="line-modified">203   // Auxiliary functions for scan_and_forward support.</span>
<span class="line-modified">204   // See comments for CompactibleSpace for more information.</span>
<span class="line-modified">205   inline HeapWord* scan_limit() const {</span>
<span class="line-removed">206     return top();</span>
<span class="line-removed">207   }</span>
208 
<span class="line-modified">209   inline bool scanned_block_is_obj(const HeapWord* addr) const {</span>
<span class="line-modified">210     return true; // Always true, since scan_limit is top</span>
<span class="line-modified">211   }</span>

212 
<span class="line-modified">213   inline size_t scanned_block_size(const HeapWord* addr) const {</span>
<span class="line-modified">214     return HeapRegion::block_size(addr); // Avoid virtual call</span>
215   }
216 
<span class="line-modified">217   void report_region_type_change(G1HeapRegionTraceType::Type to);</span>
<span class="line-modified">218 </span>
<span class="line-modified">219   // Returns whether the given object address refers to a dead object, and either the</span>
<span class="line-removed">220   // size of the object (if live) or the size of the block (if dead) in size.</span>
<span class="line-removed">221   // May</span>
<span class="line-removed">222   // - only called with obj &lt; top()</span>
<span class="line-removed">223   // - not called on humongous objects or archive regions</span>
<span class="line-removed">224   inline bool is_obj_dead_with_size(const oop obj, const G1CMBitMap* const prev_bitmap, size_t* size) const;</span>
225 
<span class="line-modified">226  protected:</span>
<span class="line-modified">227   // The index of this region in the heap region sequence.</span>
<span class="line-removed">228   uint  _hrm_index;</span>
229 
230   HeapRegionType _type;
231 
232   // For a humongous region, region in which it starts.
233   HeapRegion* _humongous_start_region;
234 
235   // True iff an attempt to evacuate an object in the region failed.
236   bool _evacuation_failed;
237 






238   // Fields used by the HeapRegionSetBase class and subclasses.
239   HeapRegion* _next;
240   HeapRegion* _prev;
241 #ifdef ASSERT
242   HeapRegionSetBase* _containing_set;
243 #endif // ASSERT
244 
<span class="line-removed">245   // We use concurrent marking to determine the amount of live data</span>
<span class="line-removed">246   // in each heap region.</span>
<span class="line-removed">247   size_t _prev_marked_bytes;    // Bytes known to be live via last completed marking.</span>
<span class="line-removed">248   size_t _next_marked_bytes;    // Bytes known to be live via in-progress marking.</span>
<span class="line-removed">249 </span>
<span class="line-removed">250   // The calculated GC efficiency of the region.</span>
<span class="line-removed">251   double _gc_efficiency;</span>
<span class="line-removed">252 </span>
<span class="line-removed">253   // The index in the optional regions array, if this region</span>
<span class="line-removed">254   // is considered optional during a mixed collections.</span>
<span class="line-removed">255   uint _index_in_opt_cset;</span>
<span class="line-removed">256   int  _young_index_in_cset;</span>
<span class="line-removed">257   SurvRateGroup* _surv_rate_group;</span>
<span class="line-removed">258   int  _age_index;</span>
<span class="line-removed">259 </span>
260   // The start of the unmarked area. The unmarked area extends from this
261   // word until the top and/or end of the region, and is the part
262   // of the region for which no marking was done, i.e. objects may
263   // have been allocated in this part since the last mark phase.
264   // &quot;prev&quot; is the top at the start of the last completed marking.
265   // &quot;next&quot; is the top at the start of the in-progress marking (if any.)
266   HeapWord* _prev_top_at_mark_start;
267   HeapWord* _next_top_at_mark_start;
<span class="line-modified">268   // If a collection pause is in progress, this is the top at the start</span>
<span class="line-modified">269   // of that pause.</span>



270 
271   void init_top_at_mark_start() {
272     assert(_prev_marked_bytes == 0 &amp;&amp;
273            _next_marked_bytes == 0,
274            &quot;Must be called after zero_marked_bytes.&quot;);
<span class="line-modified">275     HeapWord* bot = bottom();</span>
<span class="line-removed">276     _prev_top_at_mark_start = bot;</span>
<span class="line-removed">277     _next_top_at_mark_start = bot;</span>
278   }
279 





280   // Cached attributes used in the collection set policy information
281 
<span class="line-modified">282   // The RSet length that was added to the total value</span>
<span class="line-modified">283   // for the collection set.</span>
<span class="line-removed">284   size_t _recorded_rs_length;</span>
285 
<span class="line-modified">286   // The predicted elapsed time that was added to total value</span>
<span class="line-removed">287   // for the collection set.</span>
<span class="line-removed">288   double _predicted_elapsed_time_ms;</span>
289 
<span class="line-modified">290   // Iterate over the references in a humongous objects and apply the given closure</span>
<span class="line-modified">291   // to them.</span>









292   // Humongous objects are allocated directly in the old-gen. So we need special
293   // handling for concurrent processing encountering an in-progress allocation.



294   template &lt;class Closure, bool is_gc_active&gt;
<span class="line-modified">295   inline bool do_oops_on_card_in_humongous(MemRegion mr,</span>
<span class="line-modified">296                                            Closure* cl,</span>
<span class="line-modified">297                                            G1CollectedHeap* g1h);</span>
298 
299   // Returns the block size of the given (dead, potentially having its class unloaded) object
300   // starting at p extending to at most the prev TAMS using the given mark bitmap.
301   inline size_t block_size_using_bitmap(const HeapWord* p, const G1CMBitMap* const prev_bitmap) const;
<span class="line-modified">302  public:</span>
<span class="line-modified">303   HeapRegion(uint hrm_index,</span>
<span class="line-modified">304              G1BlockOffsetTable* bot,</span>
<span class="line-modified">305              MemRegion mr);</span>


306 
307   // Initializing the HeapRegion not only resets the data structure, but also
308   // resets the BOT for that heap region.
309   // The default values for clear_space means that we will do the clearing if
310   // there&#39;s clearing to be done ourselves. We also always mangle the space.
<span class="line-modified">311   virtual void initialize(MemRegion mr, bool clear_space = false, bool mangle_space = SpaceDecorator::Mangle);</span>
312 
313   static int    LogOfHRGrainBytes;
314   static int    LogOfHRGrainWords;

315 
316   static size_t GrainBytes;
317   static size_t GrainWords;
318   static size_t CardsPerRegion;
319 
320   static size_t align_up_to_region_byte_size(size_t sz) {
321     return (sz + (size_t) GrainBytes - 1) &amp;
322                                       ~((1 &lt;&lt; (size_t) LogOfHRGrainBytes) - 1);
323   }
324 
<span class="line-removed">325 </span>
326   // Returns whether a field is in the same region as the obj it points to.
327   template &lt;typename T&gt;
328   static bool is_in_same_region(T* p, oop obj) {
329     assert(p != NULL, &quot;p can&#39;t be NULL&quot;);
330     assert(obj != NULL, &quot;obj can&#39;t be NULL&quot;);
331     return (((uintptr_t) p ^ cast_from_oop&lt;uintptr_t&gt;(obj)) &gt;&gt; LogOfHRGrainBytes) == 0;
332   }
333 
334   static size_t max_region_size();
335   static size_t min_region_size_in_words();
336 
337   // It sets up the heap region size (GrainBytes / GrainWords), as
338   // well as other related fields that are based on the heap region
339   // size (LogOfHRGrainBytes / LogOfHRGrainWords /
340   // CardsPerRegion). All those fields are considered constant
341   // throughout the JVM&#39;s execution, therefore they should only be set
342   // up once during initialization time.
343   static void setup_heap_region_size(size_t initial_heap_size, size_t max_heap_size);
344 
<span class="line-removed">345   // All allocated blocks are occupied by objects in a HeapRegion</span>
<span class="line-removed">346   bool block_is_obj(const HeapWord* p) const;</span>
<span class="line-removed">347 </span>
<span class="line-removed">348   // Returns whether the given object is dead based on TAMS and bitmap.</span>
<span class="line-removed">349   bool is_obj_dead(const oop obj, const G1CMBitMap* const prev_bitmap) const;</span>
<span class="line-removed">350 </span>
<span class="line-removed">351   // Returns the object size for all valid block starts</span>
<span class="line-removed">352   // and the amount of unallocated words if called on top()</span>
<span class="line-removed">353   size_t block_size(const HeapWord* p) const;</span>
<span class="line-removed">354 </span>
<span class="line-removed">355   // Scans through the region using the bitmap to determine what</span>
<span class="line-removed">356   // objects to call size_t ApplyToMarkedClosure::apply(oop) for.</span>
<span class="line-removed">357   template&lt;typename ApplyToMarkedClosure&gt;</span>
<span class="line-removed">358   inline void apply_to_marked_objects(G1CMBitMap* bitmap, ApplyToMarkedClosure* closure);</span>
<span class="line-removed">359   // Override for scan_and_forward support.</span>
<span class="line-removed">360   void prepare_for_compaction(CompactPoint* cp);</span>
<span class="line-removed">361   // Update heap region to be consistent after compaction.</span>
<span class="line-removed">362   void complete_compaction();</span>
<span class="line-removed">363 </span>
<span class="line-removed">364   inline HeapWord* par_allocate_no_bot_updates(size_t min_word_size, size_t desired_word_size, size_t* word_size);</span>
<span class="line-removed">365   inline HeapWord* allocate_no_bot_updates(size_t word_size);</span>
<span class="line-removed">366   inline HeapWord* allocate_no_bot_updates(size_t min_word_size, size_t desired_word_size, size_t* actual_size);</span>
<span class="line-removed">367 </span>
<span class="line-removed">368   // If this region is a member of a HeapRegionManager, the index in that</span>
<span class="line-removed">369   // sequence, otherwise -1.</span>
<span class="line-removed">370   uint hrm_index() const { return _hrm_index; }</span>
<span class="line-removed">371 </span>
372   // The number of bytes marked live in the region in the last marking phase.
373   size_t marked_bytes()    { return _prev_marked_bytes; }
374   size_t live_bytes() {
375     return (top() - prev_top_at_mark_start()) * HeapWordSize + marked_bytes();
376   }
377 
378   // The number of bytes counted in the next marking.
379   size_t next_marked_bytes() { return _next_marked_bytes; }
380   // The number of bytes live wrt the next marking.
381   size_t next_live_bytes() {
382     return
383       (top() - next_top_at_mark_start()) * HeapWordSize + next_marked_bytes();
384   }
385 
386   // A lower bound on the amount of garbage bytes in the region.
387   size_t garbage_bytes() {
388     size_t used_at_mark_start_bytes =
389       (prev_top_at_mark_start() - bottom()) * HeapWordSize;
390     return used_at_mark_start_bytes - marked_bytes();
391   }
</pre>
<hr />
<pre>
393   // Return the amount of bytes we&#39;ll reclaim if we collect this
394   // region. This includes not only the known garbage bytes in the
395   // region but also any unallocated space in it, i.e., [top, end),
396   // since it will also be reclaimed if we collect the region.
397   size_t reclaimable_bytes() {
398     size_t known_live_bytes = live_bytes();
399     assert(known_live_bytes &lt;= capacity(), &quot;sanity&quot;);
400     return capacity() - known_live_bytes;
401   }
402 
403   // An upper bound on the number of live bytes in the region.
404   size_t max_live_bytes() { return used() - garbage_bytes(); }
405 
406   void add_to_marked_bytes(size_t incr_bytes) {
407     _next_marked_bytes = _next_marked_bytes + incr_bytes;
408   }
409 
410   void zero_marked_bytes()      {
411     _prev_marked_bytes = _next_marked_bytes = 0;
412   }
















413 
414   const char* get_type_str() const { return _type.get_str(); }
415   const char* get_short_type_str() const { return _type.get_short_str(); }
416   G1HeapRegionTraceType::Type get_trace_type() { return _type.get_trace_type(); }
417 
418   bool is_free() const { return _type.is_free(); }
419 
420   bool is_young()    const { return _type.is_young();    }
421   bool is_eden()     const { return _type.is_eden();     }
422   bool is_survivor() const { return _type.is_survivor(); }
423 
424   bool is_humongous() const { return _type.is_humongous(); }
425   bool is_starts_humongous() const { return _type.is_starts_humongous(); }
426   bool is_continues_humongous() const { return _type.is_continues_humongous();   }
427 
428   bool is_old() const { return _type.is_old(); }
429 
430   bool is_old_or_humongous() const { return _type.is_old_or_humongous(); }
431 
432   bool is_old_or_humongous_or_archive() const { return _type.is_old_or_humongous_or_archive(); }
433 
434   // A pinned region contains objects which are not moved by garbage collections.
435   // Humongous regions and archive regions are pinned.
436   bool is_pinned() const { return _type.is_pinned(); }
437 
438   // An archive region is a pinned region, also tagged as old, which
439   // should not be marked during mark/sweep. This allows the address
440   // space to be shared by JVM instances.
441   bool is_archive()        const { return _type.is_archive(); }
442   bool is_open_archive()   const { return _type.is_open_archive(); }
443   bool is_closed_archive() const { return _type.is_closed_archive(); }
444 












445   // For a humongous region, region in which it starts.
446   HeapRegion* humongous_start_region() const {
447     return _humongous_start_region;
448   }
449 
450   // Makes the current region be a &quot;starts humongous&quot; region, i.e.,
451   // the first region in a series of one or more contiguous regions
452   // that will contain a single &quot;humongous&quot; object.
453   //
454   // obj_top : points to the top of the humongous object.
455   // fill_size : size of the filler object at the end of the region series.
456   void set_starts_humongous(HeapWord* obj_top, size_t fill_size);
457 
458   // Makes the current region be a &quot;continues humongous&#39;
459   // region. first_hr is the &quot;start humongous&quot; region of the series
460   // which this region will be part of.
461   void set_continues_humongous(HeapRegion* first_hr);
462 
463   // Unsets the humongous-related fields on the region.
464   void clear_humongous();
465 
466   // If the region has a remembered set, return a pointer to it.
467   HeapRegionRemSet* rem_set() const {
468     return _rem_set;
469   }
470 
471   inline bool in_collection_set() const;
472 
473   // Methods used by the HeapRegionSetBase class and subclasses.
474 
475   // Getter and setter for the next and prev fields used to link regions into
476   // linked lists.

477   HeapRegion* next()              { return _next; }
<span class="line-removed">478   HeapRegion* prev()              { return _prev; }</span>
479 
<span class="line-removed">480   void set_next(HeapRegion* next) { _next = next; }</span>
481   void set_prev(HeapRegion* prev) { _prev = prev; }



482 
483   // Every region added to a set is tagged with a reference to that
484   // set. This is used for doing consistency checking to make sure that
485   // the contents of a set are as they should be and it&#39;s only
486   // available in non-product builds.
487 #ifdef ASSERT
488   void set_containing_set(HeapRegionSetBase* containing_set) {
<span class="line-modified">489     assert((containing_set == NULL &amp;&amp; _containing_set != NULL) ||</span>
<span class="line-modified">490            (containing_set != NULL &amp;&amp; _containing_set == NULL),</span>
491            &quot;containing_set: &quot; PTR_FORMAT &quot; &quot;
492            &quot;_containing_set: &quot; PTR_FORMAT,
493            p2i(containing_set), p2i(_containing_set));
494 
495     _containing_set = containing_set;
496   }
497 
498   HeapRegionSetBase* containing_set() { return _containing_set; }
499 #else // ASSERT
500   void set_containing_set(HeapRegionSetBase* containing_set) { }
501 
502   // containing_set() is only used in asserts so there&#39;s no reason
503   // to provide a dummy version of it.
504 #endif // ASSERT
505 
506 
<span class="line-modified">507   // Reset the HeapRegion to default values.</span>
<span class="line-removed">508   // If skip_remset is true, do not clear the remembered set.</span>
509   // If clear_space is true, clear the HeapRegion&#39;s memory.
<span class="line-modified">510   // If locked is true, assume we are the only thread doing this operation.</span>
<span class="line-modified">511   void hr_clear(bool skip_remset, bool clear_space, bool locked = false);</span>
512   // Clear the card table corresponding to this region.
513   void clear_cardtable();
514 
<span class="line-modified">515   // Get the start of the unmarked area in this region.</span>
<span class="line-modified">516   HeapWord* prev_top_at_mark_start() const { return _prev_top_at_mark_start; }</span>
<span class="line-removed">517   HeapWord* next_top_at_mark_start() const { return _next_top_at_mark_start; }</span>
<span class="line-removed">518 </span>
<span class="line-removed">519   // Note the start or end of marking. This tells the heap region</span>
<span class="line-removed">520   // that the collector is about to start or has finished (concurrently)</span>
<span class="line-removed">521   // marking the heap.</span>
522 
<span class="line-modified">523   // Notify the region that concurrent marking is starting. Initialize</span>
<span class="line-modified">524   // all fields related to the next marking info.</span>
<span class="line-modified">525   inline void note_start_of_marking();</span>
526 
<span class="line-modified">527   // Notify the region that concurrent marking has finished. Copy the</span>
<span class="line-modified">528   // (now finalized) next marking info fields into the prev marking</span>
<span class="line-modified">529   // info fields.</span>
<span class="line-modified">530   inline void note_end_of_marking();</span>
531 
532   // Notify the region that we are about to start processing
533   // self-forwarded objects during evac failure handling.
534   void note_self_forwarding_removal_start(bool during_initial_mark,
535                                           bool during_conc_mark);
536 
537   // Notify the region that we have finished processing self-forwarded
538   // objects during evac failure handling.
539   void note_self_forwarding_removal_end(size_t marked_bytes);
540 
<span class="line-modified">541   void reset_during_compaction() {</span>
<span class="line-modified">542     assert(is_humongous(),</span>
<span class="line-modified">543            &quot;should only be called for humongous regions&quot;);</span>
<span class="line-removed">544 </span>
<span class="line-removed">545     zero_marked_bytes();</span>
<span class="line-removed">546     init_top_at_mark_start();</span>
547   }



548 
549   void calc_gc_efficiency(void);
550   double gc_efficiency() const { return _gc_efficiency;}
551 
<span class="line-modified">552   uint index_in_opt_cset() const { return _index_in_opt_cset; }</span>
<span class="line-modified">553   void set_index_in_opt_cset(uint index) { _index_in_opt_cset = index; }</span>
<span class="line-modified">554 </span>
<span class="line-modified">555   int  young_index_in_cset() const { return _young_index_in_cset; }</span>
<span class="line-modified">556   void set_young_index_in_cset(int index) {</span>
<span class="line-modified">557     assert( (index == -1) || is_young(), &quot;pre-condition&quot; );</span>
558     _young_index_in_cset = index;
559   }
560 
<span class="line-modified">561   int age_in_surv_rate_group() {</span>
<span class="line-modified">562     assert( _surv_rate_group != NULL, &quot;pre-condition&quot; );</span>
<span class="line-removed">563     assert( _age_index &gt; -1, &quot;pre-condition&quot; );</span>
<span class="line-removed">564     return _surv_rate_group-&gt;age_in_group(_age_index);</span>
<span class="line-removed">565   }</span>
<span class="line-removed">566 </span>
<span class="line-removed">567   void record_surv_words_in_group(size_t words_survived) {</span>
<span class="line-removed">568     assert( _surv_rate_group != NULL, &quot;pre-condition&quot; );</span>
<span class="line-removed">569     assert( _age_index &gt; -1, &quot;pre-condition&quot; );</span>
<span class="line-removed">570     int age_in_group = age_in_surv_rate_group();</span>
<span class="line-removed">571     _surv_rate_group-&gt;record_surviving_words(age_in_group, words_survived);</span>
<span class="line-removed">572   }</span>
<span class="line-removed">573 </span>
<span class="line-removed">574   int age_in_surv_rate_group_cond() {</span>
<span class="line-removed">575     if (_surv_rate_group != NULL)</span>
<span class="line-removed">576       return age_in_surv_rate_group();</span>
<span class="line-removed">577     else</span>
<span class="line-removed">578       return -1;</span>
<span class="line-removed">579   }</span>
<span class="line-removed">580 </span>
<span class="line-removed">581   SurvRateGroup* surv_rate_group() {</span>
<span class="line-removed">582     return _surv_rate_group;</span>
<span class="line-removed">583   }</span>
<span class="line-removed">584 </span>
<span class="line-removed">585   void install_surv_rate_group(SurvRateGroup* surv_rate_group) {</span>
<span class="line-removed">586     assert( surv_rate_group != NULL, &quot;pre-condition&quot; );</span>
<span class="line-removed">587     assert( _surv_rate_group == NULL, &quot;pre-condition&quot; );</span>
<span class="line-removed">588     assert( is_young(), &quot;pre-condition&quot; );</span>
<span class="line-removed">589 </span>
<span class="line-removed">590     _surv_rate_group = surv_rate_group;</span>
<span class="line-removed">591     _age_index = surv_rate_group-&gt;next_age_index();</span>
<span class="line-removed">592   }</span>
<span class="line-removed">593 </span>
<span class="line-removed">594   void uninstall_surv_rate_group() {</span>
<span class="line-removed">595     if (_surv_rate_group != NULL) {</span>
<span class="line-removed">596       assert( _age_index &gt; -1, &quot;pre-condition&quot; );</span>
<span class="line-removed">597       assert( is_young(), &quot;pre-condition&quot; );</span>
<span class="line-removed">598 </span>
<span class="line-removed">599       _surv_rate_group = NULL;</span>
<span class="line-removed">600       _age_index = -1;</span>
<span class="line-removed">601     } else {</span>
<span class="line-removed">602       assert( _age_index == -1, &quot;pre-condition&quot; );</span>
<span class="line-removed">603     }</span>
<span class="line-removed">604   }</span>
605 
<span class="line-modified">606   void set_free();</span>
607 
<span class="line-modified">608   void set_eden();</span>
<span class="line-removed">609   void set_eden_pre_gc();</span>
<span class="line-removed">610   void set_survivor();</span>
611 
<span class="line-modified">612   void move_to_old();</span>
<span class="line-modified">613   void set_old();</span>
614 
<span class="line-modified">615   void set_open_archive();</span>
<span class="line-removed">616   void set_closed_archive();</span>
617 
618   // Determine if an object has been allocated since the last
619   // mark performed by the collector. This returns true iff the object
620   // is within the unmarked area of the region.
621   bool obj_allocated_since_prev_marking(oop obj) const {
<span class="line-modified">622     return (HeapWord *) obj &gt;= prev_top_at_mark_start();</span>
623   }
624   bool obj_allocated_since_next_marking(oop obj) const {
<span class="line-modified">625     return (HeapWord *) obj &gt;= next_top_at_mark_start();</span>
626   }
627 
<span class="line-modified">628   // Returns the &quot;evacuation_failed&quot; property of the region.</span>
<span class="line-modified">629   bool evacuation_failed() { return _evacuation_failed; }</span>
630 
<span class="line-modified">631   // Sets the &quot;evacuation_failed&quot; property of the region.</span>
<span class="line-removed">632   void set_evacuation_failed(bool b) {</span>
<span class="line-removed">633     _evacuation_failed = b;</span>
<span class="line-removed">634 </span>
<span class="line-removed">635     if (b) {</span>
<span class="line-removed">636       _next_marked_bytes = 0;</span>
<span class="line-removed">637     }</span>
<span class="line-removed">638   }</span>
<span class="line-removed">639 </span>
<span class="line-removed">640   // Iterate over the objects overlapping part of a card, applying cl</span>
641   // to all references in the region.  This is a helper for
642   // G1RemSet::refine_card*, and is tightly coupled with them.
<span class="line-modified">643   // mr is the memory region covered by the card, trimmed to the</span>
<span class="line-removed">644   // allocated space for this region.  Must not be empty.</span>
645   // This region must be old or humongous.
<span class="line-modified">646   // Returns true if the designated objects were successfully</span>
<span class="line-modified">647   // processed, false if an unparsable part of the heap was</span>
<span class="line-modified">648   // encountered; that only happens when invoked concurrently with the</span>
<span class="line-removed">649   // mutator.</span>
650   template &lt;bool is_gc_active, class Closure&gt;
<span class="line-modified">651   inline bool oops_on_card_seq_iterate_careful(MemRegion mr, Closure* cl);</span>
<span class="line-removed">652 </span>
<span class="line-removed">653   size_t recorded_rs_length() const        { return _recorded_rs_length; }</span>
<span class="line-removed">654   double predicted_elapsed_time_ms() const { return _predicted_elapsed_time_ms; }</span>
<span class="line-removed">655 </span>
<span class="line-removed">656   void set_recorded_rs_length(size_t rs_length) {</span>
<span class="line-removed">657     _recorded_rs_length = rs_length;</span>
<span class="line-removed">658   }</span>
<span class="line-removed">659 </span>
<span class="line-removed">660   void set_predicted_elapsed_time_ms(double ms) {</span>
<span class="line-removed">661     _predicted_elapsed_time_ms = ms;</span>
<span class="line-removed">662   }</span>
663 
664   // Routines for managing a list of code roots (attached to the
665   // this region&#39;s RSet) that point into this heap region.
666   void add_strong_code_root(nmethod* nm);
667   void add_strong_code_root_locked(nmethod* nm);
668   void remove_strong_code_root(nmethod* nm);
669 
670   // Applies blk-&gt;do_code_blob() to each of the entries in
671   // the strong code roots list for this region
672   void strong_code_roots_do(CodeBlobClosure* blk) const;
673 



674   // Verify that the entries on the strong code root list for this
675   // region are live and include at least one pointer into this region.
676   void verify_strong_code_roots(VerifyOption vo, bool* failures) const;
677 
678   void print() const;
679   void print_on(outputStream* st) const;
680 
681   // vo == UsePrevMarking -&gt; use &quot;prev&quot; marking information,
682   // vo == UseNextMarking -&gt; use &quot;next&quot; marking information
683   // vo == UseFullMarking -&gt; use &quot;next&quot; marking bitmap but no TAMS
684   //
685   // NOTE: Only the &quot;prev&quot; marking information is guaranteed to be
686   // consistent most of the time, so most calls to this should use
687   // vo == UsePrevMarking.
688   // Currently, there is only one case where this is called with
689   // vo == UseNextMarking, which is to verify the &quot;next&quot; marking
690   // information at the end of remark.
691   // Currently there is only one place where this is called with
692   // vo == UseFullMarking, which is to verify the marking during a
693   // full GC.
694   void verify(VerifyOption vo, bool *failures) const;
695 
<span class="line-modified">696   // Override; it uses the &quot;prev&quot; marking information</span>
<span class="line-modified">697   virtual void verify() const;</span>
698 
699   void verify_rem_set(VerifyOption vo, bool *failures) const;
700   void verify_rem_set() const;
701 };
702 
703 // HeapRegionClosure is used for iterating over regions.
704 // Terminates the iteration when the &quot;do_heap_region&quot; method returns &quot;true&quot;.
705 class HeapRegionClosure : public StackObj {
706   friend class HeapRegionManager;
707   friend class G1CollectionSet;
708   friend class G1CollectionSetCandidates;
709 
710   bool _is_complete;
711   void set_incomplete() { _is_complete = false; }
712 
<span class="line-modified">713  public:</span>
714   HeapRegionClosure(): _is_complete(true) {}
715 
716   // Typically called on each region until it returns true.
717   virtual bool do_heap_region(HeapRegion* r) = 0;
718 
719   // True after iteration if the closure was applied to all heap regions
720   // and returned &quot;false&quot; in all cases.
721   bool is_complete() { return _is_complete; }
722 };
723 
724 #endif // SHARE_GC_G1_HEAPREGION_HPP
</pre>
</td>
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_HEAPREGION_HPP
 26 #define SHARE_GC_G1_HEAPREGION_HPP
 27 
 28 #include &quot;gc/g1/g1BlockOffsetTable.hpp&quot;
 29 #include &quot;gc/g1/g1HeapRegionTraceType.hpp&quot;
<span class="line-added"> 30 #include &quot;gc/g1/g1SurvRateGroup.hpp&quot;</span>
 31 #include &quot;gc/g1/heapRegionTracer.hpp&quot;
 32 #include &quot;gc/g1/heapRegionType.hpp&quot;

 33 #include &quot;gc/shared/ageTable.hpp&quot;

 34 #include &quot;gc/shared/spaceDecorator.hpp&quot;
<span class="line-added"> 35 #include &quot;gc/shared/verifyOption.hpp&quot;</span>
<span class="line-added"> 36 #include &quot;runtime/mutex.hpp&quot;</span>
 37 #include &quot;utilities/macros.hpp&quot;
 38 




















 39 class G1CollectedHeap;
 40 class G1CMBitMap;
<span class="line-modified"> 41 class G1Predictions;</span>
 42 class HeapRegionRemSet;

 43 class HeapRegion;
 44 class HeapRegionSetBase;
 45 class nmethod;
 46 
 47 #define HR_FORMAT &quot;%u:(%s)[&quot; PTR_FORMAT &quot;,&quot; PTR_FORMAT &quot;,&quot; PTR_FORMAT &quot;]&quot;
 48 #define HR_FORMAT_PARAMS(_hr_) \
 49                 (_hr_)-&gt;hrm_index(), \
 50                 (_hr_)-&gt;get_short_type_str(), \
 51                 p2i((_hr_)-&gt;bottom()), p2i((_hr_)-&gt;top()), p2i((_hr_)-&gt;end())
 52 
 53 // sentinel value for hrm_index
 54 #define G1_NO_HRM_INDEX ((uint) -1)
 55 
<span class="line-modified"> 56 // A HeapRegion is the smallest piece of a G1CollectedHeap that</span>
<span class="line-modified"> 57 // can be collected independently.</span>
<span class="line-modified"> 58 </span>
<span class="line-modified"> 59 // Each heap region is self contained. top() and end() can never</span>
<span class="line-modified"> 60 // be set beyond the end of the region. For humongous objects,</span>
<span class="line-modified"> 61 // the first region is a StartsHumongous region. If the humongous</span>
<span class="line-modified"> 62 // object is larger than a heap region, the following regions will</span>
<span class="line-modified"> 63 // be of type ContinuesHumongous. In this case the top() of the</span>
<span class="line-modified"> 64 // StartHumongous region and all ContinuesHumongous regions except</span>
<span class="line-modified"> 65 // the last will point to their own end. The last ContinuesHumongous</span>
<span class="line-modified"> 66 // region may have top() equal the end of object if there isn&#39;t</span>
<span class="line-modified"> 67 // room for filler objects to pad out to the end of the region.</span>
<span class="line-modified"> 68 class HeapRegion : public CHeapObj&lt;mtGC&gt; {</span>









 69   friend class VMStructs;
<span class="line-added"> 70 </span>
<span class="line-added"> 71   HeapWord* const _bottom;</span>
<span class="line-added"> 72   HeapWord* const _end;</span>
<span class="line-added"> 73 </span>
 74   HeapWord* volatile _top;
<span class="line-modified"> 75   HeapWord* _compaction_top;</span>
<span class="line-added"> 76 </span>
 77   G1BlockOffsetTablePart _bot_part;
 78   Mutex _par_alloc_lock;
 79   // When we need to retire an allocation region, while other threads
 80   // are also concurrently trying to allocate into it, we typically
 81   // allocate a dummy object at the end of the region to ensure that
 82   // no more allocations can take place in it. However, sometimes we
 83   // want to know where the end of the last &quot;real&quot; object we allocated
 84   // into the region was and this is what this keeps track.
 85   HeapWord* _pre_dummy_top;
 86 
<span class="line-modified"> 87 public:</span>
<span class="line-modified"> 88   HeapWord* bottom() const         { return _bottom; }</span>
<span class="line-added"> 89   HeapWord* end() const            { return _end;    }</span>
<span class="line-added"> 90 </span>
<span class="line-added"> 91   void set_compaction_top(HeapWord* compaction_top) { _compaction_top = compaction_top; }</span>
<span class="line-added"> 92   HeapWord* compaction_top() const { return _compaction_top; }</span>
 93 
 94   void set_top(HeapWord* value) { _top = value; }
 95   HeapWord* top() const { return _top; }
 96 
<span class="line-modified"> 97   // See the comment above in the declaration of _pre_dummy_top for an</span>
<span class="line-modified"> 98   // explanation of what it is.</span>
<span class="line-modified"> 99   void set_pre_dummy_top(HeapWord* pre_dummy_top) {</span>
<span class="line-added">100     assert(is_in(pre_dummy_top) &amp;&amp; pre_dummy_top &lt;= top(), &quot;pre-condition&quot;);</span>
<span class="line-added">101     _pre_dummy_top = pre_dummy_top;</span>
<span class="line-added">102   }</span>
<span class="line-added">103   HeapWord* pre_dummy_top() { return (_pre_dummy_top == NULL) ? top() : _pre_dummy_top; }</span>
<span class="line-added">104   void reset_pre_dummy_top() { _pre_dummy_top = NULL; }</span>
<span class="line-added">105 </span>
<span class="line-added">106   // Returns true iff the given the heap  region contains the</span>
<span class="line-added">107   // given address as part of an allocated object. This may</span>
<span class="line-added">108   // be a potentially, so we restrict its use to assertion checks only.</span>
<span class="line-added">109   bool is_in(const void* p) const {</span>
<span class="line-added">110     return is_in_reserved(p);</span>
<span class="line-added">111   }</span>
<span class="line-added">112   bool is_in(oop obj) const {</span>
<span class="line-added">113     return is_in((void*)obj);</span>
<span class="line-added">114   }</span>
<span class="line-added">115   // Returns true iff the given reserved memory of the space contains the</span>
<span class="line-added">116   // given address.</span>
<span class="line-added">117   bool is_in_reserved(const void* p) const { return _bottom &lt;= p &amp;&amp; p &lt; _end; }</span>
<span class="line-added">118 </span>
<span class="line-added">119   size_t capacity()     const { return byte_size(bottom(), end()); }</span>
<span class="line-added">120   size_t used() const { return byte_size(bottom(), top()); }</span>
<span class="line-added">121   size_t free() const { return byte_size(top(), end()); }</span>
<span class="line-added">122 </span>
<span class="line-added">123   bool is_empty() const { return used() == 0; }</span>
<span class="line-added">124 </span>
<span class="line-added">125 private:</span>
<span class="line-added">126   void reset_after_compaction() { set_top(compaction_top()); }</span>
<span class="line-added">127 </span>
<span class="line-added">128   void clear(bool mangle_space);</span>
129 
<span class="line-modified">130   HeapWord* block_start_const(const void* p) const;</span>
<span class="line-modified">131 </span>
<span class="line-added">132   void mangle_unused_area() PRODUCT_RETURN;</span>
<span class="line-added">133 </span>
<span class="line-added">134   // Try to allocate at least min_word_size and up to desired_size from this region.</span>
135   // Returns NULL if not possible, otherwise sets actual_word_size to the amount of
136   // space allocated.
<span class="line-modified">137   // This version assumes that all allocation requests to this HeapRegion are properly</span>
138   // synchronized.
139   inline HeapWord* allocate_impl(size_t min_word_size, size_t desired_word_size, size_t* actual_word_size);
<span class="line-modified">140   // Try to allocate at least min_word_size and up to desired_size from this HeapRegion.</span>
141   // Returns NULL if not possible, otherwise sets actual_word_size to the amount of
142   // space allocated.
143   // This version synchronizes with other calls to par_allocate_impl().
144   inline HeapWord* par_allocate_impl(size_t min_word_size, size_t desired_word_size, size_t* actual_word_size);
145 
<span class="line-modified">146 public:</span>
<span class="line-modified">147   HeapWord* block_start(const void* p);</span>






148 
149   void object_iterate(ObjectClosure* blk);




















150 
151   // Allocation (return NULL if full).  Assumes the caller has established
<span class="line-modified">152   // mutually exclusive access to the HeapRegion.</span>
153   HeapWord* allocate(size_t min_word_size, size_t desired_word_size, size_t* actual_word_size);
154   // Allocation (return NULL if full).  Enforces mutual exclusion internally.
155   HeapWord* par_allocate(size_t min_word_size, size_t desired_word_size, size_t* actual_word_size);
156 
<span class="line-modified">157   HeapWord* allocate(size_t word_size);</span>
<span class="line-modified">158   HeapWord* par_allocate(size_t word_size);</span>


159 
<span class="line-modified">160   inline HeapWord* par_allocate_no_bot_updates(size_t min_word_size, size_t desired_word_size, size_t* word_size);</span>
<span class="line-modified">161   inline HeapWord* allocate_no_bot_updates(size_t word_size);</span>
<span class="line-modified">162   inline HeapWord* allocate_no_bot_updates(size_t min_word_size, size_t desired_word_size, size_t* actual_size);</span>
163 
<span class="line-modified">164   // Full GC support methods.</span>
165 
<span class="line-modified">166   HeapWord* initialize_threshold();</span>
<span class="line-modified">167   HeapWord* cross_threshold(HeapWord* start, HeapWord* end);</span>
<span class="line-modified">168   // Update heap region to be consistent after Full GC compaction.</span>
<span class="line-added">169   void reset_humongous_during_compaction() {</span>
<span class="line-added">170     assert(is_humongous(),</span>
<span class="line-added">171            &quot;should only be called for humongous regions&quot;);</span>
172 
<span class="line-modified">173     zero_marked_bytes();</span>
<span class="line-modified">174     init_top_at_mark_start();</span>
175   }
<span class="line-modified">176   // Update heap region to be consistent after Full GC compaction.</span>
<span class="line-added">177   void complete_compaction();</span>
178 
<span class="line-modified">179   // All allocated blocks are occupied by objects in a HeapRegion</span>
<span class="line-modified">180   bool block_is_obj(const HeapWord* p) const;</span>




181 
<span class="line-modified">182   // Returns whether the given object is dead based on TAMS and bitmap.</span>
<span class="line-modified">183   bool is_obj_dead(const oop obj, const G1CMBitMap* const prev_bitmap) const;</span>


184 
<span class="line-modified">185   // Returns the object size for all valid block starts</span>
<span class="line-modified">186   // and the amount of unallocated words if called on top()</span>
<span class="line-modified">187   size_t block_size(const HeapWord* p) const;</span>


188 
<span class="line-modified">189   // Scans through the region using the bitmap to determine what</span>
<span class="line-modified">190   // objects to call size_t ApplyToMarkedClosure::apply(oop) for.</span>
<span class="line-modified">191   template&lt;typename ApplyToMarkedClosure&gt;</span>
<span class="line-added">192   inline void apply_to_marked_objects(G1CMBitMap* bitmap, ApplyToMarkedClosure* closure);</span>
193 
<span class="line-modified">194   void reset_bot() {</span>
<span class="line-modified">195     _bot_part.reset_bot();</span>
196   }
197 
<span class="line-modified">198 private:</span>
<span class="line-modified">199   // The remembered set for this region.</span>
<span class="line-modified">200   HeapRegionRemSet* _rem_set;</span>





201 
<span class="line-modified">202   // Cached index of this region in the heap region sequence.</span>
<span class="line-modified">203   const uint _hrm_index;</span>

204 
205   HeapRegionType _type;
206 
207   // For a humongous region, region in which it starts.
208   HeapRegion* _humongous_start_region;
209 
210   // True iff an attempt to evacuate an object in the region failed.
211   bool _evacuation_failed;
212 
<span class="line-added">213   static const uint InvalidCSetIndex = UINT_MAX;</span>
<span class="line-added">214 </span>
<span class="line-added">215   // The index in the optional regions array, if this region</span>
<span class="line-added">216   // is considered optional during a mixed collections.</span>
<span class="line-added">217   uint _index_in_opt_cset;</span>
<span class="line-added">218 </span>
219   // Fields used by the HeapRegionSetBase class and subclasses.
220   HeapRegion* _next;
221   HeapRegion* _prev;
222 #ifdef ASSERT
223   HeapRegionSetBase* _containing_set;
224 #endif // ASSERT
225 















226   // The start of the unmarked area. The unmarked area extends from this
227   // word until the top and/or end of the region, and is the part
228   // of the region for which no marking was done, i.e. objects may
229   // have been allocated in this part since the last mark phase.
230   // &quot;prev&quot; is the top at the start of the last completed marking.
231   // &quot;next&quot; is the top at the start of the in-progress marking (if any.)
232   HeapWord* _prev_top_at_mark_start;
233   HeapWord* _next_top_at_mark_start;
<span class="line-modified">234 </span>
<span class="line-modified">235   // We use concurrent marking to determine the amount of live data</span>
<span class="line-added">236   // in each heap region.</span>
<span class="line-added">237   size_t _prev_marked_bytes;    // Bytes known to be live via last completed marking.</span>
<span class="line-added">238   size_t _next_marked_bytes;    // Bytes known to be live via in-progress marking.</span>
239 
240   void init_top_at_mark_start() {
241     assert(_prev_marked_bytes == 0 &amp;&amp;
242            _next_marked_bytes == 0,
243            &quot;Must be called after zero_marked_bytes.&quot;);
<span class="line-modified">244     _prev_top_at_mark_start = _next_top_at_mark_start = bottom();</span>


245   }
246 
<span class="line-added">247   // Data for young region survivor prediction.</span>
<span class="line-added">248   uint  _young_index_in_cset;</span>
<span class="line-added">249   G1SurvRateGroup* _surv_rate_group;</span>
<span class="line-added">250   int  _age_index;</span>
<span class="line-added">251 </span>
252   // Cached attributes used in the collection set policy information
253 
<span class="line-modified">254   // The calculated GC efficiency of the region.</span>
<span class="line-modified">255   double _gc_efficiency;</span>

256 
<span class="line-modified">257   uint _node_index;</span>


258 
<span class="line-modified">259   void report_region_type_change(G1HeapRegionTraceType::Type to);</span>
<span class="line-modified">260 </span>
<span class="line-added">261   // Returns whether the given object address refers to a dead object, and either the</span>
<span class="line-added">262   // size of the object (if live) or the size of the block (if dead) in size.</span>
<span class="line-added">263   // May</span>
<span class="line-added">264   // - only called with obj &lt; top()</span>
<span class="line-added">265   // - not called on humongous objects or archive regions</span>
<span class="line-added">266   inline bool is_obj_dead_with_size(const oop obj, const G1CMBitMap* const prev_bitmap, size_t* size) const;</span>
<span class="line-added">267 </span>
<span class="line-added">268   // Iterate over the references covered by the given MemRegion in a humongous</span>
<span class="line-added">269   // object and apply the given closure to them.</span>
270   // Humongous objects are allocated directly in the old-gen. So we need special
271   // handling for concurrent processing encountering an in-progress allocation.
<span class="line-added">272   // Returns the address after the last actually scanned or NULL if the area could</span>
<span class="line-added">273   // not be scanned (That should only happen when invoked concurrently with the</span>
<span class="line-added">274   // mutator).</span>
275   template &lt;class Closure, bool is_gc_active&gt;
<span class="line-modified">276   inline HeapWord* do_oops_on_memregion_in_humongous(MemRegion mr,</span>
<span class="line-modified">277                                                      Closure* cl,</span>
<span class="line-modified">278                                                      G1CollectedHeap* g1h);</span>
279 
280   // Returns the block size of the given (dead, potentially having its class unloaded) object
281   // starting at p extending to at most the prev TAMS using the given mark bitmap.
282   inline size_t block_size_using_bitmap(const HeapWord* p, const G1CMBitMap* const prev_bitmap) const;
<span class="line-modified">283 public:</span>
<span class="line-modified">284   HeapRegion(uint hrm_index, G1BlockOffsetTable* bot, MemRegion mr);</span>
<span class="line-modified">285 </span>
<span class="line-modified">286   // If this region is a member of a HeapRegionManager, the index in that</span>
<span class="line-added">287   // sequence, otherwise -1.</span>
<span class="line-added">288   uint hrm_index() const { return _hrm_index; }</span>
289 
290   // Initializing the HeapRegion not only resets the data structure, but also
291   // resets the BOT for that heap region.
292   // The default values for clear_space means that we will do the clearing if
293   // there&#39;s clearing to be done ourselves. We also always mangle the space.
<span class="line-modified">294   void initialize(bool clear_space = false, bool mangle_space = SpaceDecorator::Mangle);</span>
295 
296   static int    LogOfHRGrainBytes;
297   static int    LogOfHRGrainWords;
<span class="line-added">298   static int    LogCardsPerRegion;</span>
299 
300   static size_t GrainBytes;
301   static size_t GrainWords;
302   static size_t CardsPerRegion;
303 
304   static size_t align_up_to_region_byte_size(size_t sz) {
305     return (sz + (size_t) GrainBytes - 1) &amp;
306                                       ~((1 &lt;&lt; (size_t) LogOfHRGrainBytes) - 1);
307   }
308 

309   // Returns whether a field is in the same region as the obj it points to.
310   template &lt;typename T&gt;
311   static bool is_in_same_region(T* p, oop obj) {
312     assert(p != NULL, &quot;p can&#39;t be NULL&quot;);
313     assert(obj != NULL, &quot;obj can&#39;t be NULL&quot;);
314     return (((uintptr_t) p ^ cast_from_oop&lt;uintptr_t&gt;(obj)) &gt;&gt; LogOfHRGrainBytes) == 0;
315   }
316 
317   static size_t max_region_size();
318   static size_t min_region_size_in_words();
319 
320   // It sets up the heap region size (GrainBytes / GrainWords), as
321   // well as other related fields that are based on the heap region
322   // size (LogOfHRGrainBytes / LogOfHRGrainWords /
323   // CardsPerRegion). All those fields are considered constant
324   // throughout the JVM&#39;s execution, therefore they should only be set
325   // up once during initialization time.
326   static void setup_heap_region_size(size_t initial_heap_size, size_t max_heap_size);
327 



























328   // The number of bytes marked live in the region in the last marking phase.
329   size_t marked_bytes()    { return _prev_marked_bytes; }
330   size_t live_bytes() {
331     return (top() - prev_top_at_mark_start()) * HeapWordSize + marked_bytes();
332   }
333 
334   // The number of bytes counted in the next marking.
335   size_t next_marked_bytes() { return _next_marked_bytes; }
336   // The number of bytes live wrt the next marking.
337   size_t next_live_bytes() {
338     return
339       (top() - next_top_at_mark_start()) * HeapWordSize + next_marked_bytes();
340   }
341 
342   // A lower bound on the amount of garbage bytes in the region.
343   size_t garbage_bytes() {
344     size_t used_at_mark_start_bytes =
345       (prev_top_at_mark_start() - bottom()) * HeapWordSize;
346     return used_at_mark_start_bytes - marked_bytes();
347   }
</pre>
<hr />
<pre>
349   // Return the amount of bytes we&#39;ll reclaim if we collect this
350   // region. This includes not only the known garbage bytes in the
351   // region but also any unallocated space in it, i.e., [top, end),
352   // since it will also be reclaimed if we collect the region.
353   size_t reclaimable_bytes() {
354     size_t known_live_bytes = live_bytes();
355     assert(known_live_bytes &lt;= capacity(), &quot;sanity&quot;);
356     return capacity() - known_live_bytes;
357   }
358 
359   // An upper bound on the number of live bytes in the region.
360   size_t max_live_bytes() { return used() - garbage_bytes(); }
361 
362   void add_to_marked_bytes(size_t incr_bytes) {
363     _next_marked_bytes = _next_marked_bytes + incr_bytes;
364   }
365 
366   void zero_marked_bytes()      {
367     _prev_marked_bytes = _next_marked_bytes = 0;
368   }
<span class="line-added">369   // Get the start of the unmarked area in this region.</span>
<span class="line-added">370   HeapWord* prev_top_at_mark_start() const { return _prev_top_at_mark_start; }</span>
<span class="line-added">371   HeapWord* next_top_at_mark_start() const { return _next_top_at_mark_start; }</span>
<span class="line-added">372 </span>
<span class="line-added">373   // Note the start or end of marking. This tells the heap region</span>
<span class="line-added">374   // that the collector is about to start or has finished (concurrently)</span>
<span class="line-added">375   // marking the heap.</span>
<span class="line-added">376 </span>
<span class="line-added">377   // Notify the region that concurrent marking is starting. Initialize</span>
<span class="line-added">378   // all fields related to the next marking info.</span>
<span class="line-added">379   inline void note_start_of_marking();</span>
<span class="line-added">380 </span>
<span class="line-added">381   // Notify the region that concurrent marking has finished. Copy the</span>
<span class="line-added">382   // (now finalized) next marking info fields into the prev marking</span>
<span class="line-added">383   // info fields.</span>
<span class="line-added">384   inline void note_end_of_marking();</span>
385 
386   const char* get_type_str() const { return _type.get_str(); }
387   const char* get_short_type_str() const { return _type.get_short_str(); }
388   G1HeapRegionTraceType::Type get_trace_type() { return _type.get_trace_type(); }
389 
390   bool is_free() const { return _type.is_free(); }
391 
392   bool is_young()    const { return _type.is_young();    }
393   bool is_eden()     const { return _type.is_eden();     }
394   bool is_survivor() const { return _type.is_survivor(); }
395 
396   bool is_humongous() const { return _type.is_humongous(); }
397   bool is_starts_humongous() const { return _type.is_starts_humongous(); }
398   bool is_continues_humongous() const { return _type.is_continues_humongous();   }
399 
400   bool is_old() const { return _type.is_old(); }
401 
402   bool is_old_or_humongous() const { return _type.is_old_or_humongous(); }
403 
404   bool is_old_or_humongous_or_archive() const { return _type.is_old_or_humongous_or_archive(); }
405 
406   // A pinned region contains objects which are not moved by garbage collections.
407   // Humongous regions and archive regions are pinned.
408   bool is_pinned() const { return _type.is_pinned(); }
409 
410   // An archive region is a pinned region, also tagged as old, which
411   // should not be marked during mark/sweep. This allows the address
412   // space to be shared by JVM instances.
413   bool is_archive()        const { return _type.is_archive(); }
414   bool is_open_archive()   const { return _type.is_open_archive(); }
415   bool is_closed_archive() const { return _type.is_closed_archive(); }
416 
<span class="line-added">417   void set_free();</span>
<span class="line-added">418 </span>
<span class="line-added">419   void set_eden();</span>
<span class="line-added">420   void set_eden_pre_gc();</span>
<span class="line-added">421   void set_survivor();</span>
<span class="line-added">422 </span>
<span class="line-added">423   void move_to_old();</span>
<span class="line-added">424   void set_old();</span>
<span class="line-added">425 </span>
<span class="line-added">426   void set_open_archive();</span>
<span class="line-added">427   void set_closed_archive();</span>
<span class="line-added">428 </span>
429   // For a humongous region, region in which it starts.
430   HeapRegion* humongous_start_region() const {
431     return _humongous_start_region;
432   }
433 
434   // Makes the current region be a &quot;starts humongous&quot; region, i.e.,
435   // the first region in a series of one or more contiguous regions
436   // that will contain a single &quot;humongous&quot; object.
437   //
438   // obj_top : points to the top of the humongous object.
439   // fill_size : size of the filler object at the end of the region series.
440   void set_starts_humongous(HeapWord* obj_top, size_t fill_size);
441 
442   // Makes the current region be a &quot;continues humongous&#39;
443   // region. first_hr is the &quot;start humongous&quot; region of the series
444   // which this region will be part of.
445   void set_continues_humongous(HeapRegion* first_hr);
446 
447   // Unsets the humongous-related fields on the region.
448   void clear_humongous();
449 
450   // If the region has a remembered set, return a pointer to it.
451   HeapRegionRemSet* rem_set() const {
452     return _rem_set;
453   }
454 
455   inline bool in_collection_set() const;
456 
457   // Methods used by the HeapRegionSetBase class and subclasses.
458 
459   // Getter and setter for the next and prev fields used to link regions into
460   // linked lists.
<span class="line-added">461   void set_next(HeapRegion* next) { _next = next; }</span>
462   HeapRegion* next()              { return _next; }

463 

464   void set_prev(HeapRegion* prev) { _prev = prev; }
<span class="line-added">465   HeapRegion* prev()              { return _prev; }</span>
<span class="line-added">466 </span>
<span class="line-added">467   void unlink_from_list();</span>
468 
469   // Every region added to a set is tagged with a reference to that
470   // set. This is used for doing consistency checking to make sure that
471   // the contents of a set are as they should be and it&#39;s only
472   // available in non-product builds.
473 #ifdef ASSERT
474   void set_containing_set(HeapRegionSetBase* containing_set) {
<span class="line-modified">475     assert((containing_set != NULL &amp;&amp; _containing_set == NULL) ||</span>
<span class="line-modified">476             containing_set == NULL,</span>
477            &quot;containing_set: &quot; PTR_FORMAT &quot; &quot;
478            &quot;_containing_set: &quot; PTR_FORMAT,
479            p2i(containing_set), p2i(_containing_set));
480 
481     _containing_set = containing_set;
482   }
483 
484   HeapRegionSetBase* containing_set() { return _containing_set; }
485 #else // ASSERT
486   void set_containing_set(HeapRegionSetBase* containing_set) { }
487 
488   // containing_set() is only used in asserts so there&#39;s no reason
489   // to provide a dummy version of it.
490 #endif // ASSERT
491 
492 
<span class="line-modified">493   // Reset the HeapRegion to default values and clear its remembered set.</span>

494   // If clear_space is true, clear the HeapRegion&#39;s memory.
<span class="line-modified">495   // Callers must ensure this is not called by multiple threads at the same time.</span>
<span class="line-modified">496   void hr_clear(bool clear_space);</span>
497   // Clear the card table corresponding to this region.
498   void clear_cardtable();
499 
<span class="line-modified">500   // Returns the &quot;evacuation_failed&quot; property of the region.</span>
<span class="line-modified">501   bool evacuation_failed() { return _evacuation_failed; }</span>





502 
<span class="line-modified">503   // Sets the &quot;evacuation_failed&quot; property of the region.</span>
<span class="line-modified">504   void set_evacuation_failed(bool b) {</span>
<span class="line-modified">505     _evacuation_failed = b;</span>
506 
<span class="line-modified">507     if (b) {</span>
<span class="line-modified">508       _next_marked_bytes = 0;</span>
<span class="line-modified">509     }</span>
<span class="line-modified">510   }</span>
511 
512   // Notify the region that we are about to start processing
513   // self-forwarded objects during evac failure handling.
514   void note_self_forwarding_removal_start(bool during_initial_mark,
515                                           bool during_conc_mark);
516 
517   // Notify the region that we have finished processing self-forwarded
518   // objects during evac failure handling.
519   void note_self_forwarding_removal_end(size_t marked_bytes);
520 
<span class="line-modified">521   uint index_in_opt_cset() const {</span>
<span class="line-modified">522     assert(has_index_in_opt_cset(), &quot;Opt cset index not set.&quot;);</span>
<span class="line-modified">523     return _index_in_opt_cset;</span>



524   }
<span class="line-added">525   bool has_index_in_opt_cset() const { return _index_in_opt_cset != InvalidCSetIndex; }</span>
<span class="line-added">526   void set_index_in_opt_cset(uint index) { _index_in_opt_cset = index; }</span>
<span class="line-added">527   void clear_index_in_opt_cset() { _index_in_opt_cset = InvalidCSetIndex; }</span>
528 
529   void calc_gc_efficiency(void);
530   double gc_efficiency() const { return _gc_efficiency;}
531 
<span class="line-modified">532   uint  young_index_in_cset() const { return _young_index_in_cset; }</span>
<span class="line-modified">533   void clear_young_index_in_cset() { _young_index_in_cset = 0; }</span>
<span class="line-modified">534   void set_young_index_in_cset(uint index) {</span>
<span class="line-modified">535     assert(index != UINT_MAX, &quot;just checking&quot;);</span>
<span class="line-modified">536     assert(index != 0, &quot;just checking&quot;);</span>
<span class="line-modified">537     assert(is_young(), &quot;pre-condition&quot;);</span>
538     _young_index_in_cset = index;
539   }
540 
<span class="line-modified">541   int age_in_surv_rate_group() const;</span>
<span class="line-modified">542   bool has_valid_age_in_surv_rate() const;</span>










































543 
<span class="line-modified">544   bool has_surv_rate_group() const;</span>
545 
<span class="line-modified">546   double surv_rate_prediction(G1Predictions const&amp; predictor) const;</span>


547 
<span class="line-modified">548   void install_surv_rate_group(G1SurvRateGroup* surv_rate_group);</span>
<span class="line-modified">549   void uninstall_surv_rate_group();</span>
550 
<span class="line-modified">551   void record_surv_words_in_group(size_t words_survived);</span>

552 
553   // Determine if an object has been allocated since the last
554   // mark performed by the collector. This returns true iff the object
555   // is within the unmarked area of the region.
556   bool obj_allocated_since_prev_marking(oop obj) const {
<span class="line-modified">557     return cast_from_oop&lt;HeapWord*&gt;(obj) &gt;= prev_top_at_mark_start();</span>
558   }
559   bool obj_allocated_since_next_marking(oop obj) const {
<span class="line-modified">560     return cast_from_oop&lt;HeapWord*&gt;(obj) &gt;= next_top_at_mark_start();</span>
561   }
562 
<span class="line-modified">563   // Update the region state after a failed evacuation.</span>
<span class="line-modified">564   void handle_evacuation_failure();</span>
565 
<span class="line-modified">566   // Iterate over the objects overlapping the given memory region, applying cl</span>









567   // to all references in the region.  This is a helper for
568   // G1RemSet::refine_card*, and is tightly coupled with them.
<span class="line-modified">569   // mr must not be empty. Must be trimmed to the allocated/parseable space in this region.</span>

570   // This region must be old or humongous.
<span class="line-modified">571   // Returns the next unscanned address if the designated objects were successfully</span>
<span class="line-modified">572   // processed, NULL if an unparseable part of the heap was encountered (That should</span>
<span class="line-modified">573   // only happen when invoked concurrently with the mutator).</span>

574   template &lt;bool is_gc_active, class Closure&gt;
<span class="line-modified">575   inline HeapWord* oops_on_memregion_seq_iterate_careful(MemRegion mr, Closure* cl);</span>











576 
577   // Routines for managing a list of code roots (attached to the
578   // this region&#39;s RSet) that point into this heap region.
579   void add_strong_code_root(nmethod* nm);
580   void add_strong_code_root_locked(nmethod* nm);
581   void remove_strong_code_root(nmethod* nm);
582 
583   // Applies blk-&gt;do_code_blob() to each of the entries in
584   // the strong code roots list for this region
585   void strong_code_roots_do(CodeBlobClosure* blk) const;
586 
<span class="line-added">587   uint node_index() const { return _node_index; }</span>
<span class="line-added">588   void set_node_index(uint node_index) { _node_index = node_index; }</span>
<span class="line-added">589 </span>
590   // Verify that the entries on the strong code root list for this
591   // region are live and include at least one pointer into this region.
592   void verify_strong_code_roots(VerifyOption vo, bool* failures) const;
593 
594   void print() const;
595   void print_on(outputStream* st) const;
596 
597   // vo == UsePrevMarking -&gt; use &quot;prev&quot; marking information,
598   // vo == UseNextMarking -&gt; use &quot;next&quot; marking information
599   // vo == UseFullMarking -&gt; use &quot;next&quot; marking bitmap but no TAMS
600   //
601   // NOTE: Only the &quot;prev&quot; marking information is guaranteed to be
602   // consistent most of the time, so most calls to this should use
603   // vo == UsePrevMarking.
604   // Currently, there is only one case where this is called with
605   // vo == UseNextMarking, which is to verify the &quot;next&quot; marking
606   // information at the end of remark.
607   // Currently there is only one place where this is called with
608   // vo == UseFullMarking, which is to verify the marking during a
609   // full GC.
610   void verify(VerifyOption vo, bool *failures) const;
611 
<span class="line-modified">612   // Verify using the &quot;prev&quot; marking information</span>
<span class="line-modified">613   void verify() const;</span>
614 
615   void verify_rem_set(VerifyOption vo, bool *failures) const;
616   void verify_rem_set() const;
617 };
618 
619 // HeapRegionClosure is used for iterating over regions.
620 // Terminates the iteration when the &quot;do_heap_region&quot; method returns &quot;true&quot;.
621 class HeapRegionClosure : public StackObj {
622   friend class HeapRegionManager;
623   friend class G1CollectionSet;
624   friend class G1CollectionSetCandidates;
625 
626   bool _is_complete;
627   void set_incomplete() { _is_complete = false; }
628 
<span class="line-modified">629 public:</span>
630   HeapRegionClosure(): _is_complete(true) {}
631 
632   // Typically called on each region until it returns true.
633   virtual bool do_heap_region(HeapRegion* r) = 0;
634 
635   // True after iteration if the closure was applied to all heap regions
636   // and returned &quot;false&quot; in all cases.
637   bool is_complete() { return _is_complete; }
638 };
639 
640 #endif // SHARE_GC_G1_HEAPREGION_HPP
</pre>
</td>
</tr>
</table>
<center><a href="heapRegion.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegion.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
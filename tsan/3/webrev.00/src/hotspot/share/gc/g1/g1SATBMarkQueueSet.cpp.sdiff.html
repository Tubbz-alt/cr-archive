<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1SATBMarkQueueSet.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1RootProcessor.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1SATBMarkQueueSet.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1SATBMarkQueueSet.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 27 #include &quot;gc/g1/g1SATBMarkQueueSet.hpp&quot;
 28 #include &quot;gc/g1/g1ThreadLocalData.hpp&quot;
 29 #include &quot;gc/g1/heapRegion.hpp&quot;
 30 #include &quot;gc/shared/satbMarkQueue.hpp&quot;
 31 #include &quot;oops/oop.hpp&quot;
 32 #include &quot;utilities/debug.hpp&quot;
 33 #include &quot;utilities/globalDefinitions.hpp&quot;
 34 
<span class="line-modified"> 35 G1SATBMarkQueueSet::G1SATBMarkQueueSet() : _g1h(NULL) {}</span>
<span class="line-modified"> 36 </span>
<span class="line-modified"> 37 void G1SATBMarkQueueSet::initialize(G1CollectedHeap* g1h,</span>
<span class="line-removed"> 38                                     Monitor* cbl_mon,</span>
<span class="line-removed"> 39                                     BufferNode::Allocator* allocator,</span>
<span class="line-removed"> 40                                     size_t process_completed_buffers_threshold,</span>
<span class="line-removed"> 41                                     uint buffer_enqueue_threshold_percentage) {</span>
<span class="line-removed"> 42   SATBMarkQueueSet::initialize(cbl_mon,</span>
<span class="line-removed"> 43                                allocator,</span>
<span class="line-removed"> 44                                process_completed_buffers_threshold,</span>
<span class="line-removed"> 45                                buffer_enqueue_threshold_percentage);</span>
<span class="line-removed"> 46   _g1h = g1h;</span>
<span class="line-removed"> 47 }</span>
 48 
 49 void G1SATBMarkQueueSet::handle_zero_index_for_thread(Thread* t) {
 50   G1ThreadLocalData::satb_mark_queue(t).handle_zero_index();
 51 }
 52 
 53 SATBMarkQueue&amp; G1SATBMarkQueueSet::satb_queue_for_thread(Thread* const t) const{
 54   return G1ThreadLocalData::satb_mark_queue(t);
 55 }
 56 
 57 // Return true if a SATB buffer entry refers to an object that
 58 // requires marking.
 59 //
 60 // The entry must point into the G1 heap.  In particular, it must not
 61 // be a NULL pointer.  NULL pointers are pre-filtered and never
 62 // inserted into a SATB buffer.
 63 //
 64 // An entry that is below the NTAMS pointer for the containing heap
 65 // region requires marking. Such an entry must point to a valid object.
 66 //
 67 // An entry that is at least the NTAMS pointer for the containing heap
</pre>
<hr />
<pre>
 97   assert(region != NULL, &quot;No region for &quot; PTR_FORMAT, p2i(entry));
 98   if (entry &gt;= region-&gt;next_top_at_mark_start()) {
 99     return false;
100   }
101 
102   assert(oopDesc::is_oop(oop(entry), true /* ignore mark word */),
103          &quot;Invalid oop in SATB buffer: &quot; PTR_FORMAT, p2i(entry));
104 
105   return true;
106 }
107 
108 static inline bool discard_entry(const void* entry, G1CollectedHeap* g1h) {
109   return !requires_marking(entry, g1h) || g1h-&gt;is_marked_next((oop)entry);
110 }
111 
112 // Workaround for not yet having std::bind.
113 class G1SATBMarkQueueFilterFn {
114   G1CollectedHeap* _g1h;
115 
116 public:
<span class="line-modified">117   G1SATBMarkQueueFilterFn(G1CollectedHeap* g1h) : _g1h(g1h) {}</span>
118 
119   // Return true if entry should be filtered out (removed), false if
120   // it should be retained.
121   bool operator()(const void* entry) const {
122     return discard_entry(entry, _g1h);
123   }
124 };
125 
126 void G1SATBMarkQueueSet::filter(SATBMarkQueue* queue) {
<span class="line-modified">127   assert(_g1h != NULL, &quot;SATB queue set not initialized&quot;);</span>
<span class="line-removed">128   apply_filter(G1SATBMarkQueueFilterFn(_g1h), queue);</span>
129 }
</pre>
</td>
<td>
<hr />
<pre>
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 27 #include &quot;gc/g1/g1SATBMarkQueueSet.hpp&quot;
 28 #include &quot;gc/g1/g1ThreadLocalData.hpp&quot;
 29 #include &quot;gc/g1/heapRegion.hpp&quot;
 30 #include &quot;gc/shared/satbMarkQueue.hpp&quot;
 31 #include &quot;oops/oop.hpp&quot;
 32 #include &quot;utilities/debug.hpp&quot;
 33 #include &quot;utilities/globalDefinitions.hpp&quot;
 34 
<span class="line-modified"> 35 G1SATBMarkQueueSet::G1SATBMarkQueueSet(BufferNode::Allocator* allocator) :</span>
<span class="line-modified"> 36   SATBMarkQueueSet(allocator)</span>
<span class="line-modified"> 37 {}</span>










 38 
 39 void G1SATBMarkQueueSet::handle_zero_index_for_thread(Thread* t) {
 40   G1ThreadLocalData::satb_mark_queue(t).handle_zero_index();
 41 }
 42 
 43 SATBMarkQueue&amp; G1SATBMarkQueueSet::satb_queue_for_thread(Thread* const t) const{
 44   return G1ThreadLocalData::satb_mark_queue(t);
 45 }
 46 
 47 // Return true if a SATB buffer entry refers to an object that
 48 // requires marking.
 49 //
 50 // The entry must point into the G1 heap.  In particular, it must not
 51 // be a NULL pointer.  NULL pointers are pre-filtered and never
 52 // inserted into a SATB buffer.
 53 //
 54 // An entry that is below the NTAMS pointer for the containing heap
 55 // region requires marking. Such an entry must point to a valid object.
 56 //
 57 // An entry that is at least the NTAMS pointer for the containing heap
</pre>
<hr />
<pre>
 87   assert(region != NULL, &quot;No region for &quot; PTR_FORMAT, p2i(entry));
 88   if (entry &gt;= region-&gt;next_top_at_mark_start()) {
 89     return false;
 90   }
 91 
 92   assert(oopDesc::is_oop(oop(entry), true /* ignore mark word */),
 93          &quot;Invalid oop in SATB buffer: &quot; PTR_FORMAT, p2i(entry));
 94 
 95   return true;
 96 }
 97 
 98 static inline bool discard_entry(const void* entry, G1CollectedHeap* g1h) {
 99   return !requires_marking(entry, g1h) || g1h-&gt;is_marked_next((oop)entry);
100 }
101 
102 // Workaround for not yet having std::bind.
103 class G1SATBMarkQueueFilterFn {
104   G1CollectedHeap* _g1h;
105 
106 public:
<span class="line-modified">107   G1SATBMarkQueueFilterFn() : _g1h(G1CollectedHeap::heap()) {}</span>
108 
109   // Return true if entry should be filtered out (removed), false if
110   // it should be retained.
111   bool operator()(const void* entry) const {
112     return discard_entry(entry, _g1h);
113   }
114 };
115 
116 void G1SATBMarkQueueSet::filter(SATBMarkQueue* queue) {
<span class="line-modified">117   apply_filter(G1SATBMarkQueueFilterFn(), queue);</span>

118 }
</pre>
</td>
</tr>
</table>
<center><a href="g1RootProcessor.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1SATBMarkQueueSet.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/g1/g1CollectionSet.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1CollectionSet.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1CollectionSetCandidates.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1CollectionSet.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 34,58 ***</span>
  class G1GCPhaseTimes;
  class G1ParScanThreadStateSet;
  class G1Policy;
  class G1SurvivorRegions;
  class HeapRegion;
  class HeapRegionClosure;
  
  class G1CollectionSet {
    G1CollectedHeap* _g1h;
    G1Policy* _policy;
  
<span class="line-modified">!   // All old gen collection set candidate regions for the current mixed gc phase.</span>
    G1CollectionSetCandidates* _candidates;
  
    uint _eden_region_length;
    uint _survivor_region_length;
    uint _old_region_length;
  
    // The actual collection set as a set of region indices.
    // All entries in _collection_set_regions below _collection_set_cur_length are
<span class="line-modified">!   // assumed to be valid entries.</span>
    // We assume that at any time there is at most only one writer and (one or more)
    // concurrent readers. This means we are good with using storestore and loadload
    // barriers on the writer and reader respectively only.
    uint* _collection_set_regions;
    volatile size_t _collection_set_cur_length;
    size_t _collection_set_max_length;
  
<span class="line-modified">!   // When doing mixed collections we can add old regions to the collection, which</span>
<span class="line-modified">!   // can be collected if there is enough time. We call these optional regions and</span>
<span class="line-modified">!   // the pointer to these regions are stored in the array below.</span>
<span class="line-modified">!   HeapRegion** _optional_regions;</span>
<span class="line-modified">!   uint _optional_region_length;</span>
<span class="line-removed">-   uint _optional_region_max_length;</span>
  
    // The number of bytes in the collection set before the pause. Set from
    // the incrementally built collection set at the start of an evacuation
<span class="line-modified">!   // pause, and incremented in finalize_old_part() when adding old regions</span>
<span class="line-removed">-   // (if any) to the collection set.</span>
    size_t _bytes_used_before;
  
<span class="line-modified">!   size_t _recorded_rs_lengths;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // The associated information that is maintained while the incremental</span>
<span class="line-modified">!   // collection set is being built with young regions. Used to populate</span>
<span class="line-removed">-   // the recorded info for the evacuation pause.</span>
  
    enum CSetBuildType {
      Active,             // We are actively building the collection set
      Inactive            // We are not actively building the collection set
    };
  
    CSetBuildType _inc_build_state;
  
    // The number of bytes in the incrementally built collection set.
    // Used to set _collection_set_bytes_used_before at the start of
    // an evacuation pause.
    size_t _inc_bytes_used_before;
<span class="line-new-header">--- 34,167 ---</span>
  class G1GCPhaseTimes;
  class G1ParScanThreadStateSet;
  class G1Policy;
  class G1SurvivorRegions;
  class HeapRegion;
<span class="line-added">+ class HeapRegionClaimer;</span>
  class HeapRegionClosure;
  
<span class="line-added">+ // The collection set.</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // The set of regions that are evacuated during an evacuation pause.</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // At the end of a collection, before freeing the collection set, this set</span>
<span class="line-added">+ // contains all regions that were evacuated during this collection:</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // - survivor regions from the last collection (if any)</span>
<span class="line-added">+ // - eden regions allocated by the mutator</span>
<span class="line-added">+ // - old gen regions evacuated during mixed gc</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // This set is built incrementally at mutator time as regions are retired, and</span>
<span class="line-added">+ // if this had been a mixed gc, some additional (during gc) incrementally added</span>
<span class="line-added">+ // old regions from the collection set candidates built during the concurrent</span>
<span class="line-added">+ // cycle.</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // A more detailed overview of how the collection set changes over time follows:</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // 0) at the end of GC the survivor regions are added to this collection set.</span>
<span class="line-added">+ // 1) the mutator incrementally adds eden regions as they retire</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // ----- gc starts</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // 2) prepare (finalize) young regions of the collection set for collection</span>
<span class="line-added">+ //    - relabel the survivors as eden</span>
<span class="line-added">+ //    - finish up the incremental building that happened at mutator time</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // iff this is a young-only collection:</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // a3) evacuate the current collection set in one &quot;initial evacuation&quot; phase</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // iff this is a mixed collection:</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // b3) calculate the set of old gen regions we may be able to collect in this</span>
<span class="line-added">+ //     collection from the list of collection set candidates.</span>
<span class="line-added">+ //     - one part is added to the current collection set</span>
<span class="line-added">+ //     - the remainder regions are labeled as optional, and NOT yet added to the</span>
<span class="line-added">+ //     collection set.</span>
<span class="line-added">+ // b4) evacuate the current collection set in the &quot;initial evacuation&quot; phase</span>
<span class="line-added">+ // b5) evacuate the optional regions in the &quot;optional evacuation&quot; phase. This is</span>
<span class="line-added">+ //     done in increments (or rounds).</span>
<span class="line-added">+ //     b5-1) add a few of the optional regions to the current collection set</span>
<span class="line-added">+ //     b5-2) evacuate only these newly added optional regions. For this mechanism we</span>
<span class="line-added">+ //     reuse the incremental collection set building infrastructure (used also at</span>
<span class="line-added">+ //     mutator time).</span>
<span class="line-added">+ //     b5-3) repeat from b5-1 until the policy determines we are done</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // all collections</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // 6) free the collection set (contains all regions now; empties collection set</span>
<span class="line-added">+ //    afterwards)</span>
<span class="line-added">+ // 7) add survivors to this collection set</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // ----- gc ends</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // goto 1)</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // Examples of how the collection set might look over time:</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // Legend:</span>
<span class="line-added">+ // S = survivor, E = eden, O = old.</span>
<span class="line-added">+ // |xxxx| = increment (with increment markers), containing four regions</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // |SSSS|                         ... after step 0), with four survivor regions</span>
<span class="line-added">+ // |SSSSEE|                       ... at step 1), after retiring two eden regions</span>
<span class="line-added">+ // |SSSSEEEE|                     ... after step 1), after retiring four eden regions</span>
<span class="line-added">+ // |EEEEEEEE|                     ... after step 2)</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // iff this is a young-only collection</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // EEEEEEEE||                      ... after step a3), after initial evacuation phase</span>
<span class="line-added">+ // ||                              ... after step 6)</span>
<span class="line-added">+ // |SS|                            ... after step 7), with two survivor regions</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // iff this is a mixed collection</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // |EEEEEEEEOOOO|                  ... after step b3), added four regions to be</span>
<span class="line-added">+ //                                     evacuated in the &quot;initial evacuation&quot; phase</span>
<span class="line-added">+ // EEEEEEEEOOOO||                  ... after step b4), incremental part is empty</span>
<span class="line-added">+ //                                     after evacuation</span>
<span class="line-added">+ // EEEEEEEEOOOO|OO|                ... after step b5.1), added two regions to be</span>
<span class="line-added">+ //                                     evacuated in the first round of the</span>
<span class="line-added">+ //                                     &quot;optional evacuation&quot; phase</span>
<span class="line-added">+ // EEEEEEEEOOOOOO|O|               ... after step b5.1), added one region to be</span>
<span class="line-added">+ //                                     evacuated in the second round of the</span>
<span class="line-added">+ //                                     &quot;optional evacuation&quot; phase</span>
<span class="line-added">+ // EEEEEEEEOOOOOOO||               ... after step b5), the complete collection set.</span>
<span class="line-added">+ // ||                              ... after step b6)</span>
<span class="line-added">+ // |SSS|                           ... after step 7), with three survivor regions</span>
<span class="line-added">+ //</span>
  class G1CollectionSet {
    G1CollectedHeap* _g1h;
    G1Policy* _policy;
  
<span class="line-modified">!   // All old gen collection set candidate regions for the current mixed phase.</span>
    G1CollectionSetCandidates* _candidates;
  
    uint _eden_region_length;
    uint _survivor_region_length;
    uint _old_region_length;
  
    // The actual collection set as a set of region indices.
    // All entries in _collection_set_regions below _collection_set_cur_length are
<span class="line-modified">!   // assumed to be part of the collection set.</span>
    // We assume that at any time there is at most only one writer and (one or more)
    // concurrent readers. This means we are good with using storestore and loadload
    // barriers on the writer and reader respectively only.
    uint* _collection_set_regions;
    volatile size_t _collection_set_cur_length;
    size_t _collection_set_max_length;
  
<span class="line-modified">!   // When doing mixed collections we can add old regions to the collection set, which</span>
<span class="line-modified">!   // will be collected only if there is enough time. We call these optional regions.</span>
<span class="line-modified">!   // This member records the current number of regions that are of that type that</span>
<span class="line-modified">!   // correspond to the first x entries in the collection set candidates.</span>
<span class="line-modified">!   uint _num_optional_regions;</span>
  
    // The number of bytes in the collection set before the pause. Set from
    // the incrementally built collection set at the start of an evacuation
<span class="line-modified">!   // pause, and updated as more regions are added to the collection set.</span>
    size_t _bytes_used_before;
  
<span class="line-modified">!   // The number of cards in the remembered set in the collection set. Set from</span>
<span class="line-modified">!   // the incrementally built collection set at the start of an evacuation</span>
<span class="line-modified">!   // pause, and updated as more regions are added to the collection set.</span>
<span class="line-modified">!   size_t _recorded_rs_length;</span>
  
    enum CSetBuildType {
      Active,             // We are actively building the collection set
      Inactive            // We are not actively building the collection set
    };
  
    CSetBuildType _inc_build_state;
<span class="line-added">+   size_t _inc_part_start;</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Information about eden regions in the incremental collection set.</span>
<span class="line-added">+   struct IncCollectionSetRegionStat {</span>
<span class="line-added">+     // The predicted non-copy time that was added to the total incremental value</span>
<span class="line-added">+     // for the collection set.</span>
<span class="line-added">+     double _non_copy_time_ms;</span>
<span class="line-added">+     // The remembered set length that was added to the total incremental value</span>
<span class="line-added">+     // for the collection set.</span>
<span class="line-added">+     size_t _rs_length;</span>
<span class="line-added">+ </span>
<span class="line-added">+ #ifdef ASSERT</span>
<span class="line-added">+     // Resets members to &quot;uninitialized&quot; values.</span>
<span class="line-added">+     void reset() { _rs_length = ~(size_t)0; _non_copy_time_ms = -1.0; }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+   };</span>
<span class="line-added">+ </span>
<span class="line-added">+   IncCollectionSetRegionStat* _inc_collection_set_stats;</span>
<span class="line-added">+   // The associated information that is maintained while the incremental</span>
<span class="line-added">+   // collection set is being built with *young* regions. Used to populate</span>
<span class="line-added">+   // the recorded info for the evacuation pause.</span>
  
    // The number of bytes in the incrementally built collection set.
    // Used to set _collection_set_bytes_used_before at the start of
    // an evacuation pause.
    size_t _inc_bytes_used_before;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 93,44 ***</span>
    // The RSet lengths recorded for regions in the CSet. It is updated
    // by the thread that adds a new region to the CSet. We assume that
    // only one thread can be allocating a new CSet region (currently,
    // it does so after taking the Heap_lock) hence no need to
    // synchronize updates to this field.
<span class="line-modified">!   size_t _inc_recorded_rs_lengths;</span>
  
    // A concurrent refinement thread periodically samples the young
<span class="line-modified">!   // region RSets and needs to update _inc_recorded_rs_lengths as</span>
    // the RSets grow. Instead of having to synchronize updates to that
    // field we accumulate them in this field and add it to
<span class="line-modified">!   // _inc_recorded_rs_lengths_diffs at the start of a GC.</span>
<span class="line-modified">!   ssize_t _inc_recorded_rs_lengths_diffs;</span>
  
    // The predicted elapsed time it will take to collect the regions in
    // the CSet. This is updated by the thread that adds a new region to
<span class="line-modified">!   // the CSet. See the comment for _inc_recorded_rs_lengths about</span>
    // MT-safety assumptions.
<span class="line-modified">!   double _inc_predicted_elapsed_time_ms;</span>
  
<span class="line-modified">!   // See the comment for _inc_recorded_rs_lengths_diffs.</span>
<span class="line-modified">!   double _inc_predicted_elapsed_time_ms_diffs;</span>
  
<span class="line-modified">!   G1CollectorState* collector_state();</span>
    G1GCPhaseTimes* phase_times();
  
    void verify_young_cset_indices() const NOT_DEBUG_RETURN;
<span class="line-removed">-   void add_as_optional(HeapRegion* hr);</span>
<span class="line-removed">-   void add_as_old(HeapRegion* hr);</span>
<span class="line-removed">-   bool optional_is_full();</span>
  
  public:
    G1CollectionSet(G1CollectedHeap* g1h, G1Policy* policy);
    ~G1CollectionSet();
  
    // Initializes the collection set giving the maximum possible length of the collection set.
    void initialize(uint max_region_length);
<span class="line-removed">-   void initialize_optional(uint max_length);</span>
<span class="line-removed">-   void free_optional_regions();</span>
  
    void clear_candidates();
  
    void set_candidates(G1CollectionSetCandidates* candidates) {
      assert(_candidates == NULL, &quot;Trying to replace collection set candidates.&quot;);
<span class="line-new-header">--- 202,76 ---</span>
    // The RSet lengths recorded for regions in the CSet. It is updated
    // by the thread that adds a new region to the CSet. We assume that
    // only one thread can be allocating a new CSet region (currently,
    // it does so after taking the Heap_lock) hence no need to
    // synchronize updates to this field.
<span class="line-modified">!   size_t _inc_recorded_rs_length;</span>
  
    // A concurrent refinement thread periodically samples the young
<span class="line-modified">!   // region RSets and needs to update _inc_recorded_rs_length as</span>
    // the RSets grow. Instead of having to synchronize updates to that
    // field we accumulate them in this field and add it to
<span class="line-modified">!   // _inc_recorded_rs_length_diff at the start of a GC.</span>
<span class="line-modified">!   size_t _inc_recorded_rs_length_diff;</span>
  
    // The predicted elapsed time it will take to collect the regions in
    // the CSet. This is updated by the thread that adds a new region to
<span class="line-modified">!   // the CSet. See the comment for _inc_recorded_rs_length about</span>
    // MT-safety assumptions.
<span class="line-modified">!   double _inc_predicted_non_copy_time_ms;</span>
  
<span class="line-modified">!   // See the comment for _inc_recorded_rs_length_diff.</span>
<span class="line-modified">!   double _inc_predicted_non_copy_time_ms_diff;</span>
  
<span class="line-modified">!   void set_recorded_rs_length(size_t rs_length);</span>
<span class="line-added">+ </span>
<span class="line-added">+   G1CollectorState* collector_state() const;</span>
    G1GCPhaseTimes* phase_times();
  
    void verify_young_cset_indices() const NOT_DEBUG_RETURN;
  
<span class="line-added">+   double predict_region_non_copy_time_ms(HeapRegion* hr) const;</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Update the incremental collection set information when adding a region.</span>
<span class="line-added">+   void add_young_region_common(HeapRegion* hr);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Add old region &quot;hr&quot; to the collection set.</span>
<span class="line-added">+   void add_old_region(HeapRegion* hr);</span>
<span class="line-added">+   void free_optional_regions();</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Add old region &quot;hr&quot; to optional collection set.</span>
<span class="line-added">+   void add_optional_region(HeapRegion* hr);</span>
<span class="line-added">+ </span>
<span class="line-added">+   void move_candidates_to_collection_set(uint num_regions);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Finalize the young part of the initial collection set. Relabel survivor regions</span>
<span class="line-added">+   // as Eden and calculate a prediction on how long the evacuation of all young regions</span>
<span class="line-added">+   // will take.</span>
<span class="line-added">+   double finalize_young_part(double target_pause_time_ms, G1SurvivorRegions* survivors);</span>
<span class="line-added">+   // Perform any final calculations on the incremental collection set fields before we</span>
<span class="line-added">+   // can use them.</span>
<span class="line-added">+   void finalize_incremental_building();</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Select the old regions of the initial collection set and determine how many optional</span>
<span class="line-added">+   // regions we might be able to evacuate in this pause.</span>
<span class="line-added">+   void finalize_old_part(double time_remaining_ms);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Iterate the part of the collection set given by the offset and length applying the given</span>
<span class="line-added">+   // HeapRegionClosure. The worker_id will determine where in the part to start the iteration</span>
<span class="line-added">+   // to allow for more efficient parallel iteration.</span>
<span class="line-added">+   void iterate_part_from(HeapRegionClosure* cl,</span>
<span class="line-added">+                          HeapRegionClaimer* hr_claimer,</span>
<span class="line-added">+                          size_t offset,</span>
<span class="line-added">+                          size_t length,</span>
<span class="line-added">+                          uint worker_id,</span>
<span class="line-added">+                          uint total_workers) const;</span>
  public:
    G1CollectionSet(G1CollectedHeap* g1h, G1Policy* policy);
    ~G1CollectionSet();
  
    // Initializes the collection set giving the maximum possible length of the collection set.
    void initialize(uint max_region_length);
  
    void clear_candidates();
  
    void set_candidates(G1CollectionSetCandidates* candidates) {
      assert(_candidates == NULL, &quot;Trying to replace collection set candidates.&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 139,67 ***</span>
    G1CollectionSetCandidates* candidates() { return _candidates; }
  
    void init_region_lengths(uint eden_cset_region_length,
                             uint survivor_cset_region_length);
  
<span class="line-removed">-   void set_recorded_rs_lengths(size_t rs_lengths);</span>
<span class="line-removed">- </span>
    uint region_length() const       { return young_region_length() +
                                              old_region_length(); }
    uint young_region_length() const { return eden_region_length() +
                                              survivor_region_length(); }
  
    uint eden_region_length() const     { return _eden_region_length;     }
    uint survivor_region_length() const { return _survivor_region_length; }
    uint old_region_length() const      { return _old_region_length;      }
<span class="line-modified">!   uint optional_region_length() const { return _optional_region_length; }</span>
  
    // Incremental collection set support
  
    // Initialize incremental collection set info.
    void start_incremental_building();
  
<span class="line-modified">!   // Perform any final calculations on the incremental collection set fields</span>
<span class="line-modified">!   // before we can use them.</span>
<span class="line-modified">!   void finalize_incremental_building();</span>
  
<span class="line-modified">!   // Reset the contents of the collection set.</span>
<span class="line-modified">!   void clear();</span>
  
<span class="line-modified">!   // Iterate over the collection set, applying the given HeapRegionClosure on all of them.</span>
<span class="line-modified">!   // If may_be_aborted is true, iteration may be aborted using the return value of the</span>
<span class="line-removed">-   // called closure method.</span>
    void iterate(HeapRegionClosure* cl) const;
  
<span class="line-modified">!   // Iterate over the collection set, applying the given HeapRegionClosure on all of them,</span>
<span class="line-removed">-   // trying to optimally spread out starting position of total_workers workers given the</span>
<span class="line-removed">-   // caller&#39;s worker_id.</span>
<span class="line-removed">-   void iterate_from(HeapRegionClosure* cl, uint worker_id, uint total_workers) const;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Stop adding regions to the incremental collection set.</span>
<span class="line-removed">-   void stop_incremental_building() { _inc_build_state = Inactive; }</span>
  
<span class="line-modified">!   size_t recorded_rs_lengths() { return _recorded_rs_lengths; }</span>
  
    size_t bytes_used_before() const {
      return _bytes_used_before;
    }
  
    void reset_bytes_used_before() {
      _bytes_used_before = 0;
    }
  
<span class="line-modified">!   // Choose a new collection set.  Marks the chosen regions as being</span>
<span class="line-modified">!   // &quot;in_collection_set&quot;.</span>
<span class="line-modified">!   double finalize_young_part(double target_pause_time_ms, G1SurvivorRegions* survivors);</span>
<span class="line-modified">!   void finalize_old_part(double time_remaining_ms);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Add old region &quot;hr&quot; to the collection set.</span>
<span class="line-modified">!   void add_old_region(HeapRegion* hr);</span>
<span class="line-modified">! </span>
<span class="line-removed">-   // Add old region &quot;hr&quot; to optional collection set.</span>
<span class="line-removed">-   void add_optional_region(HeapRegion* hr);</span>
  
    // Update information about hr in the aggregated information for
    // the incrementally built collection set.
    void update_young_region_prediction(HeapRegion* hr, size_t new_rs_length);
  
<span class="line-new-header">--- 280,69 ---</span>
    G1CollectionSetCandidates* candidates() { return _candidates; }
  
    void init_region_lengths(uint eden_cset_region_length,
                             uint survivor_cset_region_length);
  
    uint region_length() const       { return young_region_length() +
                                              old_region_length(); }
    uint young_region_length() const { return eden_region_length() +
                                              survivor_region_length(); }
  
    uint eden_region_length() const     { return _eden_region_length;     }
    uint survivor_region_length() const { return _survivor_region_length; }
    uint old_region_length() const      { return _old_region_length;      }
<span class="line-modified">!   uint optional_region_length() const { return _num_optional_regions; }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Reset the contents of the collection set.</span>
<span class="line-added">+   void clear();</span>
  
    // Incremental collection set support
  
    // Initialize incremental collection set info.
    void start_incremental_building();
<span class="line-added">+   // Start a new collection set increment.</span>
<span class="line-added">+   void update_incremental_marker() { _inc_build_state = Active; _inc_part_start = _collection_set_cur_length; }</span>
<span class="line-added">+   // Stop adding regions to the current collection set increment.</span>
<span class="line-added">+   void stop_incremental_building() { _inc_build_state = Inactive; }</span>
  
<span class="line-modified">!   // Iterate over the current collection set increment applying the given HeapRegionClosure</span>
<span class="line-modified">!   // from a starting position determined by the given worker id.</span>
<span class="line-modified">!   void iterate_incremental_part_from(HeapRegionClosure* cl, HeapRegionClaimer* hr_claimer, uint worker_id, uint total_workers) const;</span>
  
<span class="line-modified">!   // Returns the length of the current increment in number of regions.</span>
<span class="line-modified">!   size_t increment_length() const { return _collection_set_cur_length - _inc_part_start; }</span>
<span class="line-added">+   // Returns the length of the whole current collection set in number of regions</span>
<span class="line-added">+   size_t cur_length() const { return _collection_set_cur_length; }</span>
  
<span class="line-modified">!   // Iterate over the entire collection set (all increments calculated so far), applying</span>
<span class="line-modified">!   // the given HeapRegionClosure on all of them.</span>
    void iterate(HeapRegionClosure* cl) const;
<span class="line-added">+   void par_iterate(HeapRegionClosure* cl,</span>
<span class="line-added">+                    HeapRegionClaimer* hr_claimer,</span>
<span class="line-added">+                    uint worker_id,</span>
<span class="line-added">+                    uint total_workers) const;</span>
  
<span class="line-modified">!   void iterate_optional(HeapRegionClosure* cl) const;</span>
  
<span class="line-modified">!   size_t recorded_rs_length() { return _recorded_rs_length; }</span>
  
    size_t bytes_used_before() const {
      return _bytes_used_before;
    }
  
    void reset_bytes_used_before() {
      _bytes_used_before = 0;
    }
  
<span class="line-modified">!   // Finalize the initial collection set consisting of all young regions potentially a</span>
<span class="line-modified">!   // few old gen regions.</span>
<span class="line-modified">!   void finalize_initial_collection_set(double target_pause_time_ms, G1SurvivorRegions* survivor);</span>
<span class="line-modified">!   // Finalize the next collection set from the set of available optional old gen regions.</span>
<span class="line-modified">!   bool finalize_optional_for_evacuation(double remaining_pause_time);</span>
<span class="line-modified">!   // Abandon (clean up) optional collection set regions that were not evacuated in this</span>
<span class="line-modified">!   // pause.</span>
<span class="line-modified">!   void abandon_optional_collection_set(G1ParScanThreadStateSet* pss);</span>
  
    // Update information about hr in the aggregated information for
    // the incrementally built collection set.
    void update_young_region_prediction(HeapRegion* hr, size_t new_rs_length);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 212,75 ***</span>
  #ifndef PRODUCT
    bool verify_young_ages();
  
    void print(outputStream* st);
  #endif // !PRODUCT
<span class="line-removed">- </span>
<span class="line-removed">-   double predict_region_elapsed_time_ms(HeapRegion* hr);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   void clear_optional_region(const HeapRegion* hr);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   HeapRegion* optional_region_at(uint i) const {</span>
<span class="line-removed">-     assert(_optional_regions != NULL, &quot;Not yet initialized&quot;);</span>
<span class="line-removed">-     assert(i &lt; _optional_region_length, &quot;index %u out of bounds (%u)&quot;, i, _optional_region_length);</span>
<span class="line-removed">-     return _optional_regions[i];</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   HeapRegion* remove_last_optional_region() {</span>
<span class="line-removed">-     assert(_optional_regions != NULL, &quot;Not yet initialized&quot;);</span>
<span class="line-removed">-     assert(_optional_region_length != 0, &quot;No region to remove&quot;);</span>
<span class="line-removed">-     _optional_region_length--;</span>
<span class="line-removed">-     HeapRegion* removed = _optional_regions[_optional_region_length];</span>
<span class="line-removed">-     _optional_regions[_optional_region_length] = NULL;</span>
<span class="line-removed">-     return removed;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">- private:</span>
<span class="line-removed">-   // Update the incremental collection set information when adding a region.</span>
<span class="line-removed">-   void add_young_region_common(HeapRegion* hr);</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Helper class to manage the optional regions in a Mixed collection.</span>
<span class="line-removed">- class G1OptionalCSet : public StackObj {</span>
<span class="line-removed">- private:</span>
<span class="line-removed">-   G1CollectionSet* _cset;</span>
<span class="line-removed">-   G1ParScanThreadStateSet* _pset;</span>
<span class="line-removed">-   uint _current_index;</span>
<span class="line-removed">-   uint _current_limit;</span>
<span class="line-removed">-   bool _prepare_failed;</span>
<span class="line-removed">-   bool _evacuation_failed;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   void prepare_to_evacuate_optional_region(HeapRegion* hr);</span>
<span class="line-removed">- </span>
<span class="line-removed">- public:</span>
<span class="line-removed">-   static const uint InvalidCSetIndex = UINT_MAX;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   G1OptionalCSet(G1CollectionSet* cset, G1ParScanThreadStateSet* pset) :</span>
<span class="line-removed">-     _cset(cset),</span>
<span class="line-removed">-     _pset(pset),</span>
<span class="line-removed">-     _current_index(0),</span>
<span class="line-removed">-     _current_limit(0),</span>
<span class="line-removed">-     _prepare_failed(false),</span>
<span class="line-removed">-     _evacuation_failed(false) { }</span>
<span class="line-removed">-   // The destructor returns regions to the collection set candidates set and</span>
<span class="line-removed">-   // frees the optional structure in the collection set.</span>
<span class="line-removed">-   ~G1OptionalCSet();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   uint current_index() { return _current_index; }</span>
<span class="line-removed">-   uint current_limit() { return _current_limit; }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   uint size();</span>
<span class="line-removed">-   bool is_empty();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   HeapRegion* region_at(uint index);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Prepare a set of regions for optional evacuation.</span>
<span class="line-removed">-   void prepare_evacuation(double time_left_ms);</span>
<span class="line-removed">-   bool prepare_failed();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Complete the evacuation of the previously prepared</span>
<span class="line-removed">-   // regions by updating their state and check for failures.</span>
<span class="line-removed">-   void complete_evacuation();</span>
<span class="line-removed">-   bool evacuation_failed();</span>
  };
  
  #endif // SHARE_GC_G1_G1COLLECTIONSET_HPP
<span class="line-new-header">--- 355,8 ---</span>
</pre>
<center><a href="g1CollectionSet.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1CollectionSetCandidates.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
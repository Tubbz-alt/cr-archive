<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1ConcurrentMarkThread.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1ConcurrentMarkObjArrayProcessor.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ConcurrentMarkThread.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1ConcurrentMarkThread.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
 27 #include &quot;gc/g1/g1Analytics.hpp&quot;
 28 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 29 #include &quot;gc/g1/g1ConcurrentMark.inline.hpp&quot;
 30 #include &quot;gc/g1/g1ConcurrentMarkThread.inline.hpp&quot;
 31 #include &quot;gc/g1/g1MMUTracker.hpp&quot;
 32 #include &quot;gc/g1/g1Policy.hpp&quot;
 33 #include &quot;gc/g1/g1RemSet.hpp&quot;

 34 #include &quot;gc/g1/g1VMOperations.hpp&quot;
 35 #include &quot;gc/shared/concurrentGCPhaseManager.hpp&quot;
 36 #include &quot;gc/shared/gcId.hpp&quot;
<span class="line-removed"> 37 #include &quot;gc/shared/gcTrace.hpp&quot;</span>
 38 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
 39 #include &quot;gc/shared/suspendibleThreadSet.hpp&quot;
 40 #include &quot;logging/log.hpp&quot;
 41 #include &quot;memory/resourceArea.hpp&quot;
 42 #include &quot;runtime/handles.inline.hpp&quot;
 43 #include &quot;runtime/vmThread.hpp&quot;
 44 #include &quot;utilities/debug.hpp&quot;
 45 
 46 // ======= Concurrent Mark Thread ========
 47 
 48 // Check order in EXPAND_CURRENT_PHASES
 49 STATIC_ASSERT(ConcurrentGCPhaseManager::UNCONSTRAINED_PHASE &lt;
 50               ConcurrentGCPhaseManager::IDLE_PHASE);
 51 
 52 #define EXPAND_CONCURRENT_PHASES(expander)                                 \
 53   expander(ANY, = ConcurrentGCPhaseManager::UNCONSTRAINED_PHASE, NULL)     \
 54   expander(IDLE, = ConcurrentGCPhaseManager::IDLE_PHASE, NULL)             \
 55   expander(CONCURRENT_CYCLE,, &quot;Concurrent Cycle&quot;)                          \
 56   expander(CLEAR_CLAIMED_MARKS,, &quot;Concurrent Clear Claimed Marks&quot;)         \
 57   expander(SCAN_ROOT_REGIONS,, &quot;Concurrent Scan Root Regions&quot;)             \
</pre>
<hr />
<pre>
 90 class CMRemark : public VoidClosure {
 91   G1ConcurrentMark* _cm;
 92 public:
 93   CMRemark(G1ConcurrentMark* cm) : _cm(cm) {}
 94 
 95   void do_void(){
 96     _cm-&gt;remark();
 97   }
 98 };
 99 
100 class CMCleanup : public VoidClosure {
101   G1ConcurrentMark* _cm;
102 public:
103   CMCleanup(G1ConcurrentMark* cm) : _cm(cm) {}
104 
105   void do_void(){
106     _cm-&gt;cleanup();
107   }
108 };
109 
<span class="line-modified">110 double G1ConcurrentMarkThread::mmu_sleep_time(G1Policy* g1_policy, bool remark) {</span>
111   // There are 3 reasons to use SuspendibleThreadSetJoiner.
112   // 1. To avoid concurrency problem.
113   //    - G1MMUTracker::add_pause(), when_sec() and its variation(when_ms() etc..) can be called
114   //      concurrently from ConcurrentMarkThread and VMThread.
115   // 2. If currently a gc is running, but it has not yet updated the MMU,
116   //    we will not forget to consider that pause in the MMU calculation.
117   // 3. If currently a gc is running, ConcurrentMarkThread will wait it to be finished.
118   //    And then sleep for predicted amount of time by delay_to_keep_mmu().
119   SuspendibleThreadSetJoiner sts_join;
120 
121   const G1Analytics* analytics = g1_policy-&gt;analytics();
<span class="line-removed">122   double now = os::elapsedTime();</span>
123   double prediction_ms = remark ? analytics-&gt;predict_remark_time_ms()
124                                 : analytics-&gt;predict_cleanup_time_ms();

125   G1MMUTracker *mmu_tracker = g1_policy-&gt;mmu_tracker();
<span class="line-modified">126   return mmu_tracker-&gt;when_ms(now, prediction_ms);</span>

127 }
128 
129 void G1ConcurrentMarkThread::delay_to_keep_mmu(G1Policy* g1_policy, bool remark) {
<span class="line-modified">130   if (g1_policy-&gt;adaptive_young_list_length()) {</span>
<span class="line-modified">131     jlong sleep_time_ms = mmu_sleep_time(g1_policy, remark);</span>
<span class="line-modified">132     if (!_cm-&gt;has_aborted() &amp;&amp; sleep_time_ms &gt; 0) {</span>
<span class="line-modified">133       os::sleep(this, sleep_time_ms, false);</span>











134     }
135   }
136 }
137 
138 class G1ConcPhaseTimer : public GCTraceConcTimeImpl&lt;LogLevel::Info, LOG_TAGS(gc, marking)&gt; {
139   G1ConcurrentMark* _cm;
140 
141  public:
142   G1ConcPhaseTimer(G1ConcurrentMark* cm, const char* title) :
143     GCTraceConcTimeImpl&lt;LogLevel::Info,  LogTag::_gc, LogTag::_marking&gt;(title),
144     _cm(cm)
145   {
146     _cm-&gt;gc_timer_cm()-&gt;register_gc_concurrent_start(title);
147   }
148 
149   ~G1ConcPhaseTimer() {
150     _cm-&gt;gc_timer_cm()-&gt;register_gc_concurrent_end();
151   }
152 };
153 
</pre>
<hr />
<pre>
364         delay_to_keep_mmu(policy, false /* cleanup */);
365       }
366 
367       if (!_cm-&gt;has_aborted()) {
368         CMCleanup cl_cl(_cm);
369         VM_G1Concurrent op(&amp;cl_cl, &quot;Pause Cleanup&quot;);
370         VMThread::execute(&amp;op);
371       }
372 
373       // We now want to allow clearing of the marking bitmap to be
374       // suspended by a collection pause.
375       // We may have aborted just before the remark. Do not bother clearing the
376       // bitmap then, as it has been done during mark abort.
377       if (!_cm-&gt;has_aborted()) {
378         G1ConcPhase p(G1ConcurrentPhase::CLEANUP_FOR_NEXT_MARK, this);
379         _cm-&gt;cleanup_for_next_mark();
380       }
381     }
382 
383     // Update the number of full collections that have been
<span class="line-modified">384     // completed. This will also notify the FullGCCount_lock in case a</span>
385     // Java thread is waiting for a full GC to happen (e.g., it
386     // called System.gc() with +ExplicitGCInvokesConcurrent).
387     {
388       SuspendibleThreadSetJoiner sts_join;
389       g1h-&gt;increment_old_marking_cycles_completed(true /* concurrent */);
390 
391       _cm-&gt;concurrent_cycle_end();
392     }
393 
394     cpmanager.set_phase(G1ConcurrentPhase::IDLE, _cm-&gt;has_aborted() /* force */);
395   }
396   _cm-&gt;root_regions()-&gt;cancel_scan();
397 }
398 
399 void G1ConcurrentMarkThread::stop_service() {
<span class="line-modified">400   MutexLockerEx ml(CGC_lock, Mutex::_no_safepoint_check_flag);</span>
401   CGC_lock-&gt;notify_all();
402 }
403 
404 
405 void G1ConcurrentMarkThread::sleep_before_next_cycle() {
406   // We join here because we don&#39;t want to do the &quot;shouldConcurrentMark()&quot;
407   // below while the world is otherwise stopped.
408   assert(!in_progress(), &quot;should have been cleared&quot;);
409 
<span class="line-modified">410   MutexLockerEx x(CGC_lock, Mutex::_no_safepoint_check_flag);</span>
411   while (!started() &amp;&amp; !should_terminate()) {
<span class="line-modified">412     CGC_lock-&gt;wait(Mutex::_no_safepoint_check_flag);</span>
413   }
414 
415   if (started()) {
416     set_in_progress();
417   }
418 }
</pre>
</td>
<td>
<hr />
<pre>
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
 27 #include &quot;gc/g1/g1Analytics.hpp&quot;
 28 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 29 #include &quot;gc/g1/g1ConcurrentMark.inline.hpp&quot;
 30 #include &quot;gc/g1/g1ConcurrentMarkThread.inline.hpp&quot;
 31 #include &quot;gc/g1/g1MMUTracker.hpp&quot;
 32 #include &quot;gc/g1/g1Policy.hpp&quot;
 33 #include &quot;gc/g1/g1RemSet.hpp&quot;
<span class="line-added"> 34 #include &quot;gc/g1/g1Trace.hpp&quot;</span>
 35 #include &quot;gc/g1/g1VMOperations.hpp&quot;
 36 #include &quot;gc/shared/concurrentGCPhaseManager.hpp&quot;
 37 #include &quot;gc/shared/gcId.hpp&quot;

 38 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
 39 #include &quot;gc/shared/suspendibleThreadSet.hpp&quot;
 40 #include &quot;logging/log.hpp&quot;
 41 #include &quot;memory/resourceArea.hpp&quot;
 42 #include &quot;runtime/handles.inline.hpp&quot;
 43 #include &quot;runtime/vmThread.hpp&quot;
 44 #include &quot;utilities/debug.hpp&quot;
 45 
 46 // ======= Concurrent Mark Thread ========
 47 
 48 // Check order in EXPAND_CURRENT_PHASES
 49 STATIC_ASSERT(ConcurrentGCPhaseManager::UNCONSTRAINED_PHASE &lt;
 50               ConcurrentGCPhaseManager::IDLE_PHASE);
 51 
 52 #define EXPAND_CONCURRENT_PHASES(expander)                                 \
 53   expander(ANY, = ConcurrentGCPhaseManager::UNCONSTRAINED_PHASE, NULL)     \
 54   expander(IDLE, = ConcurrentGCPhaseManager::IDLE_PHASE, NULL)             \
 55   expander(CONCURRENT_CYCLE,, &quot;Concurrent Cycle&quot;)                          \
 56   expander(CLEAR_CLAIMED_MARKS,, &quot;Concurrent Clear Claimed Marks&quot;)         \
 57   expander(SCAN_ROOT_REGIONS,, &quot;Concurrent Scan Root Regions&quot;)             \
</pre>
<hr />
<pre>
 90 class CMRemark : public VoidClosure {
 91   G1ConcurrentMark* _cm;
 92 public:
 93   CMRemark(G1ConcurrentMark* cm) : _cm(cm) {}
 94 
 95   void do_void(){
 96     _cm-&gt;remark();
 97   }
 98 };
 99 
100 class CMCleanup : public VoidClosure {
101   G1ConcurrentMark* _cm;
102 public:
103   CMCleanup(G1ConcurrentMark* cm) : _cm(cm) {}
104 
105   void do_void(){
106     _cm-&gt;cleanup();
107   }
108 };
109 
<span class="line-modified">110 double G1ConcurrentMarkThread::mmu_delay_end(G1Policy* g1_policy, bool remark) {</span>
111   // There are 3 reasons to use SuspendibleThreadSetJoiner.
112   // 1. To avoid concurrency problem.
113   //    - G1MMUTracker::add_pause(), when_sec() and its variation(when_ms() etc..) can be called
114   //      concurrently from ConcurrentMarkThread and VMThread.
115   // 2. If currently a gc is running, but it has not yet updated the MMU,
116   //    we will not forget to consider that pause in the MMU calculation.
117   // 3. If currently a gc is running, ConcurrentMarkThread will wait it to be finished.
118   //    And then sleep for predicted amount of time by delay_to_keep_mmu().
119   SuspendibleThreadSetJoiner sts_join;
120 
121   const G1Analytics* analytics = g1_policy-&gt;analytics();

122   double prediction_ms = remark ? analytics-&gt;predict_remark_time_ms()
123                                 : analytics-&gt;predict_cleanup_time_ms();
<span class="line-added">124   double prediction = prediction_ms / MILLIUNITS;</span>
125   G1MMUTracker *mmu_tracker = g1_policy-&gt;mmu_tracker();
<span class="line-modified">126   double now = os::elapsedTime();</span>
<span class="line-added">127   return now + mmu_tracker-&gt;when_sec(now, prediction);</span>
128 }
129 
130 void G1ConcurrentMarkThread::delay_to_keep_mmu(G1Policy* g1_policy, bool remark) {
<span class="line-modified">131   if (g1_policy-&gt;use_adaptive_young_list_length()) {</span>
<span class="line-modified">132     double delay_end_sec = mmu_delay_end(g1_policy, remark);</span>
<span class="line-modified">133     // Wait for timeout or thread termination request.</span>
<span class="line-modified">134     MonitorLocker ml(CGC_lock, Monitor::_no_safepoint_check_flag);</span>
<span class="line-added">135     while (!_cm-&gt;has_aborted()) {</span>
<span class="line-added">136       double sleep_time_sec = (delay_end_sec - os::elapsedTime());</span>
<span class="line-added">137       jlong sleep_time_ms = ceil(sleep_time_sec * MILLIUNITS);</span>
<span class="line-added">138       if (sleep_time_ms &lt;= 0) {</span>
<span class="line-added">139         break;                  // Passed end time.</span>
<span class="line-added">140       } else if (ml.wait(sleep_time_ms, Monitor::_no_safepoint_check_flag)) {</span>
<span class="line-added">141         break;                  // Timeout =&gt; reached end time.</span>
<span class="line-added">142       } else if (should_terminate()) {</span>
<span class="line-added">143         break;                  // Wakeup for pending termination request.</span>
<span class="line-added">144       }</span>
<span class="line-added">145       // Other (possibly spurious) wakeup.  Retry with updated sleep time.</span>
146     }
147   }
148 }
149 
150 class G1ConcPhaseTimer : public GCTraceConcTimeImpl&lt;LogLevel::Info, LOG_TAGS(gc, marking)&gt; {
151   G1ConcurrentMark* _cm;
152 
153  public:
154   G1ConcPhaseTimer(G1ConcurrentMark* cm, const char* title) :
155     GCTraceConcTimeImpl&lt;LogLevel::Info,  LogTag::_gc, LogTag::_marking&gt;(title),
156     _cm(cm)
157   {
158     _cm-&gt;gc_timer_cm()-&gt;register_gc_concurrent_start(title);
159   }
160 
161   ~G1ConcPhaseTimer() {
162     _cm-&gt;gc_timer_cm()-&gt;register_gc_concurrent_end();
163   }
164 };
165 
</pre>
<hr />
<pre>
376         delay_to_keep_mmu(policy, false /* cleanup */);
377       }
378 
379       if (!_cm-&gt;has_aborted()) {
380         CMCleanup cl_cl(_cm);
381         VM_G1Concurrent op(&amp;cl_cl, &quot;Pause Cleanup&quot;);
382         VMThread::execute(&amp;op);
383       }
384 
385       // We now want to allow clearing of the marking bitmap to be
386       // suspended by a collection pause.
387       // We may have aborted just before the remark. Do not bother clearing the
388       // bitmap then, as it has been done during mark abort.
389       if (!_cm-&gt;has_aborted()) {
390         G1ConcPhase p(G1ConcurrentPhase::CLEANUP_FOR_NEXT_MARK, this);
391         _cm-&gt;cleanup_for_next_mark();
392       }
393     }
394 
395     // Update the number of full collections that have been
<span class="line-modified">396     // completed. This will also notify the G1OldGCCount_lock in case a</span>
397     // Java thread is waiting for a full GC to happen (e.g., it
398     // called System.gc() with +ExplicitGCInvokesConcurrent).
399     {
400       SuspendibleThreadSetJoiner sts_join;
401       g1h-&gt;increment_old_marking_cycles_completed(true /* concurrent */);
402 
403       _cm-&gt;concurrent_cycle_end();
404     }
405 
406     cpmanager.set_phase(G1ConcurrentPhase::IDLE, _cm-&gt;has_aborted() /* force */);
407   }
408   _cm-&gt;root_regions()-&gt;cancel_scan();
409 }
410 
411 void G1ConcurrentMarkThread::stop_service() {
<span class="line-modified">412   MutexLocker ml(CGC_lock, Mutex::_no_safepoint_check_flag);</span>
413   CGC_lock-&gt;notify_all();
414 }
415 
416 
417 void G1ConcurrentMarkThread::sleep_before_next_cycle() {
418   // We join here because we don&#39;t want to do the &quot;shouldConcurrentMark()&quot;
419   // below while the world is otherwise stopped.
420   assert(!in_progress(), &quot;should have been cleared&quot;);
421 
<span class="line-modified">422   MonitorLocker ml(CGC_lock, Mutex::_no_safepoint_check_flag);</span>
423   while (!started() &amp;&amp; !should_terminate()) {
<span class="line-modified">424     ml.wait();</span>
425   }
426 
427   if (started()) {
428     set_in_progress();
429   }
430 }
</pre>
</td>
</tr>
</table>
<center><a href="g1ConcurrentMarkObjArrayProcessor.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ConcurrentMarkThread.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
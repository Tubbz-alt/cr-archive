diff a/src/hotspot/share/gc/g1/g1Policy.hpp b/src/hotspot/share/gc/g1/g1Policy.hpp
--- a/src/hotspot/share/gc/g1/g1Policy.hpp
+++ b/src/hotspot/share/gc/g1/g1Policy.hpp
@@ -23,14 +23,13 @@
  */
 
 #ifndef SHARE_GC_G1_G1POLICY_HPP
 #define SHARE_GC_G1_G1POLICY_HPP
 
-#include "gc/g1/g1CollectorPolicy.hpp"
 #include "gc/g1/g1CollectorState.hpp"
 #include "gc/g1/g1GCPhaseTimes.hpp"
-#include "gc/g1/g1InCSetState.hpp"
+#include "gc/g1/g1HeapRegionAttr.hpp"
 #include "gc/g1/g1InitialMarkToMixedTimeTracker.hpp"
 #include "gc/g1/g1MMUTracker.hpp"
 #include "gc/g1/g1RemSetTrackingPolicy.hpp"
 #include "gc/g1/g1Predictions.hpp"
 #include "gc/g1/g1YoungGenSizer.hpp"
@@ -42,10 +41,11 @@
 //   * choice of collection set.
 //   * when to collect.
 
 class HeapRegion;
 class G1CollectionSet;
+class G1CollectionSetCandidates;
 class G1CollectionSetChooser;
 class G1IHOPControl;
 class G1Analytics;
 class G1SurvivorRegions;
 class G1YoungGenSizer;
@@ -80,39 +80,45 @@
 
   // The max number of regions we can extend the eden by while the GC
   // locker is active. This should be >= _young_list_target_length;
   uint _young_list_max_length;
 
-  // SurvRateGroups below must be initialized after the predictor because they
-  // indirectly use it through this object passed to their constructor.
-  SurvRateGroup* _short_lived_surv_rate_group;
-  SurvRateGroup* _survivor_surv_rate_group;
+  // The survivor rate groups below must be initialized after the predictor because they
+  // indirectly use it through the "this" object passed to their constructor.
+  G1SurvRateGroup* _eden_surv_rate_group;
+  G1SurvRateGroup* _survivor_surv_rate_group;
 
   double _reserve_factor;
   // This will be set when the heap is expanded
   // for the first time during initialization.
   uint   _reserve_regions;
 
   G1YoungGenSizer* _young_gen_sizer;
 
   uint _free_regions_at_end_of_collection;
 
-  size_t _max_rs_lengths;
+  size_t _rs_length;
 
-  size_t _rs_lengths_prediction;
+  size_t _rs_length_prediction;
 
-  size_t _pending_cards;
+  size_t _pending_cards_at_gc_start;
+  size_t _pending_cards_at_prev_gc_end;
+  size_t _total_mutator_refined_cards;
+  size_t _total_concurrent_refined_cards;
+  Tickspan _total_concurrent_refinement_time;
 
   // The amount of allocated bytes in old gen during the last mutator and the following
   // young GC phase.
   size_t _bytes_allocated_in_old_since_last_gc;
 
   G1InitialMarkToMixedTimeTracker _initial_mark_to_mixed;
 
   bool should_update_surv_rate_group_predictors() {
     return collector_state()->in_young_only_phase() && !collector_state()->mark_or_rebuild_in_progress();
   }
+
+  double logged_cards_processing_time() const;
 public:
   const G1Predictions& predictor() const { return _predictor; }
   const G1Analytics* analytics()   const { return const_cast<const G1Analytics*>(_analytics); }
 
   G1RemSetTrackingPolicy* remset_tracker() { return &_remset_tracker; }
@@ -120,34 +126,39 @@
   // Add the given number of bytes to the total number of allocated bytes in the old gen.
   void add_bytes_allocated_in_old_since_last_gc(size_t bytes) { _bytes_allocated_in_old_since_last_gc += bytes; }
 
   void set_region_eden(HeapRegion* hr) {
     hr->set_eden();
-    hr->install_surv_rate_group(_short_lived_surv_rate_group);
+    hr->install_surv_rate_group(_eden_surv_rate_group);
   }
 
   void set_region_survivor(HeapRegion* hr) {
     assert(hr->is_survivor(), "pre-condition");
     hr->install_surv_rate_group(_survivor_surv_rate_group);
   }
 
-  void record_max_rs_lengths(size_t rs_lengths) {
-    _max_rs_lengths = rs_lengths;
+  void record_rs_length(size_t rs_length) {
+    _rs_length = rs_length;
   }
 
-  double predict_base_elapsed_time_ms(size_t pending_cards) const;
-  double predict_base_elapsed_time_ms(size_t pending_cards,
-                                      size_t scanned_cards) const;
-  size_t predict_bytes_to_copy(HeapRegion* hr) const;
-  double predict_region_elapsed_time_ms(HeapRegion* hr, bool for_young_gc) const;
+  double predict_base_elapsed_time_ms(size_t num_pending_cards) const;
 
-  double predict_survivor_regions_evac_time() const;
+private:
+  double predict_base_elapsed_time_ms(size_t num_pending_cards, size_t rs_length) const;
+
+  double predict_region_copy_time_ms(HeapRegion* hr) const;
+
+public:
+
+  double predict_eden_copy_time_ms(uint count, size_t* bytes_to_copy = NULL) const;
+  double predict_region_non_copy_time_ms(HeapRegion* hr, bool for_young_gc) const;
+  double predict_region_total_time_ms(HeapRegion* hr, bool for_young_gc) const;
 
   void cset_regions_freed() {
     bool update = should_update_surv_rate_group_predictors();
 
-    _short_lived_surv_rate_group->all_surviving_words_recorded(predictor(), update);
+    _eden_surv_rate_group->all_surviving_words_recorded(predictor(), update);
     _survivor_surv_rate_group->all_surviving_words_recorded(predictor(), update);
   }
 
   G1MMUTracker* mmu_tracker() {
     return _mmu_tracker;
@@ -159,16 +170,10 @@
 
   double max_pause_time_ms() const {
     return _mmu_tracker->max_gc_time() * 1000.0;
   }
 
-  double predict_yg_surv_rate(int age, SurvRateGroup* surv_rate_group) const;
-
-  double predict_yg_surv_rate(int age) const;
-
-  double accum_yg_surv_rate_pred(int age) const;
-
 private:
   G1CollectionSet* _collection_set;
   double average_time_ms(G1GCPhaseTimes::GCParPhases phase) const;
   double other_time_ms(double pause_time_ms) const;
 
@@ -176,13 +181,10 @@
   double non_young_other_time_ms() const;
   double constant_other_time_ms(double pause_time_ms) const;
 
   G1CollectionSetChooser* cset_chooser() const;
 
-  // The number of bytes copied during the GC.
-  size_t _bytes_copied_during_gc;
-
   // Stash a pointer to the g1 heap.
   G1CollectedHeap* _g1h;
 
   G1GCPhaseTimes* _phase_times;
 
@@ -190,21 +192,21 @@
   // determine whether we should initiate a new marking.
   double _mark_remark_start_sec;
   double _mark_cleanup_start_sec;
 
   // Updates the internal young list maximum and target lengths. Returns the
-  // unbounded young list target length.
+  // unbounded young list target length. If no rs_length parameter is passed,
+  // predict the RS length using the prediction model, otherwise use the
+  // given rs_length as the prediction.
   uint update_young_list_max_and_target_length();
-  uint update_young_list_max_and_target_length(size_t rs_lengths);
+  uint update_young_list_max_and_target_length(size_t rs_length);
 
   // Update the young list target length either by setting it to the
   // desired fixed value or by calculating it using G1's pause
-  // prediction model. If no rs_lengths parameter is passed, predict
-  // the RS lengths using the prediction model, otherwise use the
-  // given rs_lengths as the prediction.
+  // prediction model.
   // Returns the unbounded young list target length.
-  uint update_young_list_target_length(size_t rs_lengths);
+  uint update_young_list_target_length(size_t rs_length);
 
   // Calculate and return the minimum desired young list target
   // length. This is the minimum desired young list length according
   // to the user's inputs.
   uint calculate_young_list_desired_min_length(uint base_min_length) const;
@@ -213,38 +215,41 @@
   // length. This is the maximum desired young list length according
   // to the user's inputs.
   uint calculate_young_list_desired_max_length() const;
 
   // Calculate and return the maximum young list target length that
-  // can fit into the pause time goal. The parameters are: rs_lengths
+  // can fit into the pause time goal. The parameters are: rs_length
   // represent the prediction of how large the young RSet lengths will
   // be, base_min_length is the already existing number of regions in
   // the young list, min_length and max_length are the desired min and
   // max young list length according to the user's inputs.
-  uint calculate_young_list_target_length(size_t rs_lengths,
+  uint calculate_young_list_target_length(size_t rs_length,
                                           uint base_min_length,
                                           uint desired_min_length,
                                           uint desired_max_length) const;
 
   // Result of the bounded_young_list_target_length() method, containing both the
   // bounded as well as the unbounded young list target lengths in this order.
   typedef Pair<uint, uint, StackObj> YoungTargetLengths;
-  YoungTargetLengths young_list_target_lengths(size_t rs_lengths) const;
+  YoungTargetLengths young_list_target_lengths(size_t rs_length) const;
+
+  void update_rs_length_prediction();
+  void update_rs_length_prediction(size_t prediction);
 
-  void update_rs_lengths_prediction();
-  void update_rs_lengths_prediction(size_t prediction);
+  size_t predict_bytes_to_copy(HeapRegion* hr) const;
+  double predict_survivor_regions_evac_time() const;
 
   // Check whether a given young length (young_length) fits into the
   // given target pause time and whether the prediction for the amount
   // of objects to be copied for the given length will fit into the
   // given free space (expressed by base_free_regions).  It is used by
   // calculate_young_list_target_length().
   bool predict_will_fit(uint young_length, double base_time_ms,
                         uint base_free_regions, double target_pause_time_ms) const;
 
 public:
-  size_t pending_cards() const { return _pending_cards; }
+  size_t pending_cards_at_gc_start() const { return _pending_cards_at_gc_start; }
 
   // Calculate the minimum number of old regions we'll add to the CSet
   // during a mixed GC.
   uint calc_min_old_cset_length() const;
 
@@ -279,26 +284,29 @@
   PauseKind young_gc_pause_kind() const;
   // Record the given STW pause with the given start and end times (in s).
   void record_pause(PauseKind kind, double start, double end);
   // Indicate that we aborted marking before doing any mixed GCs.
   void abort_time_to_mixed_tracking();
+
+  void record_concurrent_refinement_data(bool is_full_collection);
+
 public:
 
-  G1Policy(G1CollectorPolicy* policy, STWGCTimer* gc_timer);
+  G1Policy(STWGCTimer* gc_timer);
 
   virtual ~G1Policy();
 
-  static G1Policy* create_policy(G1CollectorPolicy* policy, STWGCTimer* gc_timer_stw);
+  static G1Policy* create_policy(STWGCTimer* gc_timer_stw);
 
   G1CollectorState* collector_state() const;
 
   G1GCPhaseTimes* phase_times() const { return _phase_times; }
 
-  // Check the current value of the young list RSet lengths and
+  // Check the current value of the young list RSet length and
   // compare it against the last prediction. If the current value is
   // higher, recalculate the young list target length prediction.
-  void revise_young_list_target_length_if_necessary(size_t rs_lengths);
+  void revise_young_list_target_length_if_necessary(size_t rs_length);
 
   // This should be called after the heap is resized.
   void record_new_heap_size(uint new_number_of_regions);
 
   virtual void init(G1CollectedHeap* g1h, G1CollectionSet* collection_set);
@@ -309,11 +317,11 @@
 
   bool about_to_start_mixed_phase() const;
 
   // Record the start and end of an evacuation pause.
   void record_collection_pause_start(double start_time_sec);
-  virtual void record_collection_pause_end(double pause_time_ms, size_t cards_scanned, size_t heap_used_bytes_before_gc);
+  virtual void record_collection_pause_end(double pause_time_ms);
 
   // Record the start and end of a full collection.
   void record_full_collection_start();
   virtual void record_full_collection_end();
 
@@ -328,25 +336,28 @@
   void record_concurrent_mark_cleanup_start();
   void record_concurrent_mark_cleanup_end();
 
   void print_phases();
 
-  // Record how much space we copied during a GC. This is typically
-  // called when a GC alloc region is being retired.
-  void record_bytes_copied_during_gc(size_t bytes) {
-    _bytes_copied_during_gc += bytes;
-  }
-
-  // The amount of space we copied during a GC.
-  size_t bytes_copied_during_gc() const {
-    return _bytes_copied_during_gc;
-  }
-
   bool next_gc_should_be_mixed(const char* true_action_str,
                                const char* false_action_str) const;
 
-  void finalize_collection_set(double target_pause_time_ms, G1SurvivorRegions* survivor);
+  // Calculate and return the number of initial and optional old gen regions from
+  // the given collection set candidates and the remaining time.
+  void calculate_old_collection_set_regions(G1CollectionSetCandidates* candidates,
+                                            double time_remaining_ms,
+                                            uint& num_initial_regions,
+                                            uint& num_optional_regions);
+
+  // Calculate the number of optional regions from the given collection set candidates,
+  // the remaining time and the maximum number of these regions and return the number
+  // of actually selected regions in num_optional_regions.
+  void calculate_optional_collection_set_regions(G1CollectionSetCandidates* candidates,
+                                                 uint const max_optional_regions,
+                                                 double time_remaining_ms,
+                                                 uint& num_optional_regions);
+
 private:
   // Set the state to start a concurrent marking cycle and clear
   // _initiate_conc_mark_if_possible because it has now been
   // acted on.
   void initiate_conc_mark();
@@ -364,29 +375,21 @@
   // marking thread has completed its work during the previous cycle,
   // it will set in_initial_mark_gc() to so that the pause does
   // the initial-mark work and start a marking cycle.
   void decide_on_conc_mark_initiation();
 
-  void finished_recalculating_age_indexes(bool is_survivors) {
-    if (is_survivors) {
-      _survivor_surv_rate_group->finished_recalculating_age_indexes();
-    } else {
-      _short_lived_surv_rate_group->finished_recalculating_age_indexes();
-    }
-  }
-
   size_t young_list_target_length() const { return _young_list_target_length; }
 
   bool should_allocate_mutator_region() const;
 
   bool can_expand_young_list() const;
 
   uint young_list_max_length() const {
     return _young_list_max_length;
   }
 
-  bool adaptive_young_list_length() const;
+  bool use_adaptive_young_list_length() const;
 
   void transfer_survivors_to_cset(const G1SurvivorRegions* survivors);
 
 private:
   //
@@ -401,15 +404,17 @@
   uint _max_survivor_regions;
 
   AgeTable _survivors_age_table;
 
   size_t desired_survivor_size(uint max_regions) const;
-public:
+
   // Fraction used when predicting how many optional regions to include in
   // the CSet. This fraction of the available time is used for optional regions,
   // the rest is used to add old regions to the normal CSet.
   double optional_prediction_fraction() { return 0.2; }
+
+public:
   // Fraction used when evacuating the optional regions. This fraction of the
   // remaining time is used to choose what regions to include in the evacuation.
   double optional_evacuation_fraction() { return 0.75; }
 
   uint tenuring_threshold() const { return _tenuring_threshold; }

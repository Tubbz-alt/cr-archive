<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/g1/g1Allocator.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1Allocator.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Analytics.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1Allocator.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -26,125 +26,145 @@</span>
  #define SHARE_GC_G1_G1ALLOCATOR_INLINE_HPP
  
  #include &quot;gc/g1/g1Allocator.hpp&quot;
  #include &quot;gc/g1/g1AllocRegion.inline.hpp&quot;
  #include &quot;gc/shared/plab.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  
<span class="udiff-line-modified-removed">- inline MutatorAllocRegion* G1Allocator::mutator_alloc_region() {</span>
<span class="udiff-line-modified-removed">-   return &amp;_mutator_alloc_region;</span>
<span class="udiff-line-modified-added">+ inline uint G1Allocator::current_node_index() const {</span>
<span class="udiff-line-modified-added">+   return _numa-&gt;index_of_current_thread();</span>
  }
  
<span class="udiff-line-modified-removed">- inline SurvivorGCAllocRegion* G1Allocator::survivor_gc_alloc_region() {</span>
<span class="udiff-line-modified-removed">-   return &amp;_survivor_gc_alloc_region;</span>
<span class="udiff-line-modified-added">+ inline MutatorAllocRegion* G1Allocator::mutator_alloc_region(uint node_index) {</span>
<span class="udiff-line-modified-added">+   assert(node_index &lt; _num_alloc_regions, &quot;Invalid index: %u&quot;, node_index);</span>
<span class="udiff-line-added">+   return &amp;_mutator_alloc_regions[node_index];</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ inline SurvivorGCAllocRegion* G1Allocator::survivor_gc_alloc_region(uint node_index) {</span>
<span class="udiff-line-added">+   assert(node_index &lt; _num_alloc_regions, &quot;Invalid index: %u&quot;, node_index);</span>
<span class="udiff-line-added">+   return &amp;_survivor_gc_alloc_regions[node_index];</span>
  }
  
  inline OldGCAllocRegion* G1Allocator::old_gc_alloc_region() {
    return &amp;_old_gc_alloc_region;
  }
  
  inline HeapWord* G1Allocator::attempt_allocation(size_t min_word_size,
                                                   size_t desired_word_size,
                                                   size_t* actual_word_size) {
<span class="udiff-line-modified-removed">-   HeapWord* result = mutator_alloc_region()-&gt;attempt_retained_allocation(min_word_size, desired_word_size, actual_word_size);</span>
<span class="udiff-line-modified-added">+   uint node_index = current_node_index();</span>
<span class="udiff-line-added">+   HeapWord* result = mutator_alloc_region(node_index)-&gt;attempt_retained_allocation(min_word_size, desired_word_size, actual_word_size);</span>
    if (result != NULL) {
      return result;
    }
<span class="udiff-line-modified-removed">-   return mutator_alloc_region()-&gt;attempt_allocation(min_word_size, desired_word_size, actual_word_size);</span>
<span class="udiff-line-modified-added">+   return mutator_alloc_region(node_index)-&gt;attempt_allocation(min_word_size, desired_word_size, actual_word_size);</span>
  }
  
  inline HeapWord* G1Allocator::attempt_allocation_locked(size_t word_size) {
<span class="udiff-line-modified-removed">-   HeapWord* result = mutator_alloc_region()-&gt;attempt_allocation_locked(word_size);</span>
<span class="udiff-line-modified-removed">-   assert(result != NULL || mutator_alloc_region()-&gt;get() == NULL,</span>
<span class="udiff-line-modified-removed">-          &quot;Must not have a mutator alloc region if there is no memory, but is &quot; PTR_FORMAT, p2i(mutator_alloc_region()-&gt;get()));</span>
<span class="udiff-line-modified-added">+   uint node_index = current_node_index();</span>
<span class="udiff-line-modified-added">+   HeapWord* result = mutator_alloc_region(node_index)-&gt;attempt_allocation_locked(word_size);</span>
<span class="udiff-line-modified-added">+   assert(result != NULL || mutator_alloc_region(node_index)-&gt;get() == NULL,</span>
<span class="udiff-line-added">+          &quot;Must not have a mutator alloc region if there is no memory, but is &quot; PTR_FORMAT, p2i(mutator_alloc_region(node_index)-&gt;get()));</span>
    return result;
  }
  
  inline HeapWord* G1Allocator::attempt_allocation_force(size_t word_size) {
<span class="udiff-line-modified-removed">-   return mutator_alloc_region()-&gt;attempt_allocation_force(word_size);</span>
<span class="udiff-line-modified-added">+   uint node_index = current_node_index();</span>
<span class="udiff-line-added">+   return mutator_alloc_region(node_index)-&gt;attempt_allocation_force(word_size);</span>
  }
  
<span class="udiff-line-modified-removed">- inline PLAB* G1PLABAllocator::alloc_buffer(InCSetState dest) {</span>
<span class="udiff-line-modified-added">+ inline PLAB* G1PLABAllocator::alloc_buffer(G1HeapRegionAttr dest, uint node_index) const {</span>
    assert(dest.is_valid(),
<span class="udiff-line-modified-removed">-          &quot;Allocation buffer index out of bounds: &quot; CSETSTATE_FORMAT, dest.value());</span>
<span class="udiff-line-modified-removed">-   assert(_alloc_buffers[dest.value()] != NULL,</span>
<span class="udiff-line-modified-removed">-          &quot;Allocation buffer is NULL: &quot; CSETSTATE_FORMAT, dest.value());</span>
<span class="udiff-line-modified-removed">-   return _alloc_buffers[dest.value()];</span>
<span class="udiff-line-modified-added">+          &quot;Allocation buffer index out of bounds: %s&quot;, dest.get_type_str());</span>
<span class="udiff-line-modified-added">+   assert(_alloc_buffers[dest.type()] != NULL,</span>
<span class="udiff-line-modified-added">+          &quot;Allocation buffer is NULL: %s&quot;, dest.get_type_str());</span>
<span class="udiff-line-modified-added">+   return alloc_buffer(dest.type(), node_index);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ inline PLAB* G1PLABAllocator::alloc_buffer(region_type_t dest, uint node_index) const {</span>
<span class="udiff-line-added">+   assert(dest &lt; G1HeapRegionAttr::Num,</span>
<span class="udiff-line-added">+          &quot;Allocation buffer index out of bounds: %u&quot;, dest);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (dest == G1HeapRegionAttr::Young) {</span>
<span class="udiff-line-added">+     assert(node_index &lt; alloc_buffers_length(dest),</span>
<span class="udiff-line-added">+            &quot;Allocation buffer index out of bounds: %u, %u&quot;, dest, node_index);</span>
<span class="udiff-line-added">+     return _alloc_buffers[dest][node_index];</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     return _alloc_buffers[dest][0];</span>
<span class="udiff-line-added">+   }</span>
  }
  
<span class="udiff-line-modified-removed">- inline HeapWord* G1PLABAllocator::plab_allocate(InCSetState dest,</span>
<span class="udiff-line-modified-removed">-                                                 size_t word_sz) {</span>
<span class="udiff-line-modified-removed">-   PLAB* buffer = alloc_buffer(dest);</span>
<span class="udiff-line-modified-added">+ inline uint G1PLABAllocator::alloc_buffers_length(region_type_t dest) const {</span>
<span class="udiff-line-modified-added">+   if (dest == G1HeapRegionAttr::Young) {</span>
<span class="udiff-line-modified-added">+     return _allocator-&gt;num_nodes();</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     return 1;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ inline HeapWord* G1PLABAllocator::plab_allocate(G1HeapRegionAttr dest,</span>
<span class="udiff-line-added">+                                                 size_t word_sz,</span>
<span class="udiff-line-added">+                                                 uint node_index) {</span>
<span class="udiff-line-added">+   PLAB* buffer = alloc_buffer(dest, node_index);</span>
    if (_survivor_alignment_bytes == 0 || !dest.is_young()) {
      return buffer-&gt;allocate(word_sz);
    } else {
      return buffer-&gt;allocate_aligned(word_sz, _survivor_alignment_bytes);
    }
  }
  
<span class="udiff-line-modified-removed">- inline HeapWord* G1PLABAllocator::allocate(InCSetState dest,</span>
<span class="udiff-line-modified-added">+ inline HeapWord* G1PLABAllocator::allocate(G1HeapRegionAttr dest,</span>
                                             size_t word_sz,
<span class="udiff-line-modified-removed">-                                            bool* refill_failed) {</span>
<span class="udiff-line-modified-removed">-   HeapWord* const obj = plab_allocate(dest, word_sz);</span>
<span class="udiff-line-modified-added">+                                            bool* refill_failed,</span>
<span class="udiff-line-modified-added">+                                            uint node_index) {</span>
<span class="udiff-line-added">+   HeapWord* const obj = plab_allocate(dest, word_sz, node_index);</span>
    if (obj != NULL) {
      return obj;
    }
<span class="udiff-line-modified-removed">-   return allocate_direct_or_new_plab(dest, word_sz, refill_failed);</span>
<span class="udiff-line-modified-added">+   return allocate_direct_or_new_plab(dest, word_sz, refill_failed, node_index);</span>
  }
  
  // Create the maps which is used to identify archive objects.
  inline void G1ArchiveAllocator::enable_archive_object_check() {
    if (_archive_check_enabled) {
      return;
    }
  
    _archive_check_enabled = true;
    size_t length = G1CollectedHeap::heap()-&gt;max_reserved_capacity();
<span class="udiff-line-modified-removed">-   _closed_archive_region_map.initialize((HeapWord*)Universe::heap()-&gt;base(),</span>
<span class="udiff-line-modified-removed">-                                         (HeapWord*)Universe::heap()-&gt;base() + length,</span>
<span class="udiff-line-modified-removed">-                                         HeapRegion::GrainBytes);</span>
<span class="udiff-line-removed">-   _open_archive_region_map.initialize((HeapWord*)Universe::heap()-&gt;base(),</span>
<span class="udiff-line-removed">-                                       (HeapWord*)Universe::heap()-&gt;base() + length,</span>
<span class="udiff-line-removed">-                                       HeapRegion::GrainBytes);</span>
<span class="udiff-line-modified-added">+   _archive_region_map.initialize(G1CollectedHeap::heap()-&gt;base(),</span>
<span class="udiff-line-modified-added">+                                  G1CollectedHeap::heap()-&gt;base() + length,</span>
<span class="udiff-line-modified-added">+                                  HeapRegion::GrainBytes);</span>
  }
  
  // Set the regions containing the specified address range as archive.
  inline void G1ArchiveAllocator::set_range_archive(MemRegion range, bool open) {
    assert(_archive_check_enabled, &quot;archive range check not enabled&quot;);
    log_info(gc, cds)(&quot;Mark %s archive regions in map: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;]&quot;,
                       open ? &quot;open&quot; : &quot;closed&quot;,
                       p2i(range.start()),
                       p2i(range.last()));
<span class="udiff-line-modified-removed">-   if (open) {</span>
<span class="udiff-line-modified-removed">-     _open_archive_region_map.set_by_address(range, true);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     _closed_archive_region_map.set_by_address(range, true);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   uint8_t const value = open ? G1ArchiveRegionMap::OpenArchive : G1ArchiveRegionMap::ClosedArchive;</span>
<span class="udiff-line-modified-added">+   _archive_region_map.set_by_address(range, value);</span>
  }
  
  // Clear the archive regions map containing the specified address range.
<span class="udiff-line-modified-removed">- inline void G1ArchiveAllocator::clear_range_archive(MemRegion range, bool open) {</span>
<span class="udiff-line-modified-added">+ inline void G1ArchiveAllocator::clear_range_archive(MemRegion range) {</span>
    assert(_archive_check_enabled, &quot;archive range check not enabled&quot;);
<span class="udiff-line-modified-removed">-   log_info(gc, cds)(&quot;Clear %s archive regions in map: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;]&quot;,</span>
<span class="udiff-line-removed">-                     open ? &quot;open&quot; : &quot;closed&quot;,</span>
<span class="udiff-line-modified-added">+   log_info(gc, cds)(&quot;Clear archive regions in map: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;]&quot;,</span>
                      p2i(range.start()),
                      p2i(range.last()));
<span class="udiff-line-modified-removed">-   if (open) {</span>
<span class="udiff-line-removed">-     _open_archive_region_map.set_by_address(range, false);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     _closed_archive_region_map.set_by_address(range, false);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   _archive_region_map.set_by_address(range, G1ArchiveRegionMap::NoArchive);</span>
  }
  
  // Check if an object is in a closed archive region using the _archive_region_map.
  inline bool G1ArchiveAllocator::in_closed_archive_range(oop object) {
<span class="udiff-line-modified-removed">-   // This is the out-of-line part of is_closed_archive_object test, done separately</span>
<span class="udiff-line-removed">-   // to avoid additional performance impact when the check is not enabled.</span>
<span class="udiff-line-removed">-   return _closed_archive_region_map.get_by_address((HeapWord*)object);</span>
<span class="udiff-line-modified-added">+   return _archive_region_map.get_by_address(cast_from_oop&lt;HeapWord*&gt;(object)) == G1ArchiveRegionMap::ClosedArchive;</span>
  }
  
  inline bool G1ArchiveAllocator::in_open_archive_range(oop object) {
<span class="udiff-line-modified-removed">-   return _open_archive_region_map.get_by_address((HeapWord*)object);</span>
<span class="udiff-line-modified-added">+   return _archive_region_map.get_by_address(cast_from_oop&lt;HeapWord*&gt;(object)) == G1ArchiveRegionMap::OpenArchive;</span>
  }
  
  // Check if archive object checking is enabled, to avoid calling in_open/closed_archive_range
  // unnecessarily.
  inline bool G1ArchiveAllocator::archive_check_enabled() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -158,10 +178,10 @@</span>
  inline bool G1ArchiveAllocator::is_open_archive_object(oop object) {
    return (archive_check_enabled() &amp;&amp; in_open_archive_range(object));
  }
  
  inline bool G1ArchiveAllocator::is_archived_object(oop object) {
<span class="udiff-line-modified-removed">-   return (archive_check_enabled() &amp;&amp; (in_closed_archive_range(object) ||</span>
<span class="udiff-line-modified-removed">-                                       in_open_archive_range(object)));</span>
<span class="udiff-line-modified-added">+   return archive_check_enabled() &amp;&amp;</span>
<span class="udiff-line-modified-added">+          (_archive_region_map.get_by_address(cast_from_oop&lt;HeapWord*&gt;(object)) != G1ArchiveRegionMap::NoArchive);</span>
  }
  
  #endif // SHARE_GC_G1_G1ALLOCATOR_INLINE_HPP
</pre>
<center><a href="g1Allocator.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Analytics.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
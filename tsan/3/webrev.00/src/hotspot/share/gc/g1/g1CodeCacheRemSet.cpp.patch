diff a/src/hotspot/share/gc/g1/g1CodeCacheRemSet.cpp b/src/hotspot/share/gc/g1/g1CodeCacheRemSet.cpp
--- a/src/hotspot/share/gc/g1/g1CodeCacheRemSet.cpp
+++ b/src/hotspot/share/gc/g1/g1CodeCacheRemSet.cpp
@@ -30,10 +30,11 @@
 #include "gc/g1/heapRegion.hpp"
 #include "memory/heap.hpp"
 #include "memory/iterator.hpp"
 #include "oops/access.inline.hpp"
 #include "oops/oop.inline.hpp"
+#include "runtime/atomic.hpp"
 #include "utilities/hashtable.inline.hpp"
 #include "utilities/stack.inline.hpp"
 
 G1CodeRootSetTable* volatile G1CodeRootSetTable::_purge_list = NULL;
 
@@ -156,23 +157,23 @@
 G1CodeRootSet::~G1CodeRootSet() {
   delete _table;
 }
 
 G1CodeRootSetTable* G1CodeRootSet::load_acquire_table() {
-  return OrderAccess::load_acquire(&_table);
+  return Atomic::load_acquire(&_table);
 }
 
 void G1CodeRootSet::allocate_small_table() {
   G1CodeRootSetTable* temp = new G1CodeRootSetTable(SmallSize);
 
-  OrderAccess::release_store(&_table, temp);
+  Atomic::release_store(&_table, temp);
 }
 
 void G1CodeRootSetTable::purge_list_append(G1CodeRootSetTable* table) {
   for (;;) {
     table->_purge_next = _purge_list;
-    G1CodeRootSetTable* old = Atomic::cmpxchg(table, &_purge_list, table->_purge_next);
+    G1CodeRootSetTable* old = Atomic::cmpxchg(&_purge_list, table->_purge_next, table);
     if (old == table->_purge_next) {
       break;
     }
   }
 }
@@ -192,11 +193,11 @@
 
   _table->copy_to(temp);
 
   G1CodeRootSetTable::purge_list_append(_table);
 
-  OrderAccess::release_store(&_table, temp);
+  Atomic::release_store(&_table, temp);
 }
 
 void G1CodeRootSet::purge() {
   G1CodeRootSetTable::purge();
 }

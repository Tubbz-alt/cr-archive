<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/gc/g1/g1FreeIdSet.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1FreeIdSet.hpp&quot;
 27 #include &quot;memory/allocation.inline.hpp&quot;
 28 #include &quot;runtime/atomic.hpp&quot;
 29 #include &quot;utilities/debug.hpp&quot;
 30 #include &quot;utilities/globalDefinitions.hpp&quot;
 31 #include &quot;utilities/macros.hpp&quot;
 32 
 33 G1FreeIdSet::G1FreeIdSet(uint start, uint size) :
 34   _sem(size),          // counting semaphore for available ids
 35   _next(NULL),         // array of &quot;next&quot; indices
 36   _start(start),       // first id value
 37   _size(size),         // number of available ids
 38   _head_index_mask(0), // mask for extracting index from a _head value.
 39   _head(0)             // low part: index; high part: update counter
 40 {
 41   assert(size != 0, &quot;precondition&quot;);
 42   assert(start &lt;= (UINT_MAX - size),
 43          &quot;start (%u) + size (%u) overflow: &quot;, start, size);
 44   // 2^shift must be greater than size. Equal is not permitted, because
 45   // size is the &quot;end of list&quot; value, and can be the index part of _head.
 46   uint shift = log2_intptr((uintptr_t)size) + 1;
 47   assert(shift &lt;= (BitsPerWord / 2), &quot;excessive size %u&quot;, size);
 48   _head_index_mask = (uintx(1) &lt;&lt; shift) - 1;
 49   assert(size &lt;= _head_index_mask, &quot;invariant&quot;);
 50   _next = NEW_C_HEAP_ARRAY(uint, size, mtGC);
 51   for (uint i = 0; i &lt; size; ++i) {
 52     _next[i] = i + 1;
 53   }
 54 }
 55 
 56 G1FreeIdSet::~G1FreeIdSet() {
 57   FREE_C_HEAP_ARRAY(uint, _next);
 58 }
 59 
 60 uint G1FreeIdSet::head_index(uintx head) const {
 61   return head &amp; _head_index_mask;
 62 }
 63 
 64 uintx G1FreeIdSet::make_head(uint index, uintx old_head) const {
 65   // Include incremented old update counter to avoid ABA problem.
 66   return index | ((old_head &amp; ~_head_index_mask) + 1 + _head_index_mask);
 67 }
 68 
 69 const uint Claimed = UINT_MAX;
 70 
 71 uint G1FreeIdSet::claim_par_id() {
 72   _sem.wait();
 73   // Semaphore gate permits passage by no more than the number of
 74   // available ids, so there must be one that we can claim.  But there
 75   // may be multiple threads trying to claim ids at the same time.
 76   uintx old_head = Atomic::load(&amp;_head);
 77   uint index;
 78   while (true) {
 79     index = head_index(old_head);
 80     assert(index &lt; _size, &quot;invariant&quot;);
 81     uintx new_head = make_head(_next[index], old_head);
 82     new_head = Atomic::cmpxchg(&amp;_head, old_head, new_head);
 83     if (new_head == old_head) break;
 84     old_head = new_head;
 85   }
 86   DEBUG_ONLY(_next[index] = Claimed;)
 87   return _start + index;
 88 }
 89 
 90 void G1FreeIdSet::release_par_id(uint id) {
 91   uint index = id - _start;
 92   assert(index &lt; _size, &quot;invalid id %u&quot;, id);
 93   assert(_next[index] == Claimed, &quot;precondition&quot;);
 94   uintx old_head = Atomic::load(&amp;_head);
 95   while (true) {
 96     _next[index] = head_index(old_head);
 97     uintx new_head = make_head(index, old_head);
 98     new_head = Atomic::cmpxchg(&amp;_head, old_head, new_head);
 99     if (new_head == old_head) break;
100     old_head = new_head;
101   }
102   // Now that id has been released, permit another thread through the gate.
103   _sem.signal();
104 }
    </pre>
  </body>
</html>